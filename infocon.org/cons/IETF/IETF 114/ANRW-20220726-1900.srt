1
00:00:24,080 --> 00:00:27,080
um

2
00:01:45,680 --> 00:01:47,119
all right everybody we'll just give it a

3
00:01:47,119 --> 00:01:48,960
couple of minutes just see people are

4
00:01:48,960 --> 00:01:52,199
still joining

5
00:03:36,959 --> 00:03:39,959
hello

6
00:04:12,080 --> 00:04:14,879
all right uh it looks like the rate of

7
00:04:14,879 --> 00:04:18,079
people uh joining the room has slowed

8
00:04:18,079 --> 00:04:20,880
down so uh welcome everybody can i just

9
00:04:20,880 --> 00:04:22,960
check that you can all see and hear me

10
00:04:22,960 --> 00:04:25,960
okay

11
00:04:32,479 --> 00:04:35,280
all right uh in that case uh welcome

12
00:04:35,280 --> 00:04:38,080
everybody to the second of the uh

13
00:04:38,080 --> 00:04:41,040
applied networking research workshop uh

14
00:04:41,040 --> 00:04:44,639
sessions for 2022

15
00:04:44,639 --> 00:04:46,240
my name is colin perkins from the

16
00:04:46,240 --> 00:04:49,360
university of glasgow i'm pleased to be

17
00:04:49,360 --> 00:04:51,520
chairing this special session on

18
00:04:51,520 --> 00:04:55,719
protocol specification techniques

19
00:04:57,520 --> 00:05:00,000
so i'd like to begin with the the usual

20
00:05:00,000 --> 00:05:02,560
reminders um

21
00:05:02,560 --> 00:05:05,280
the applied networking research workshop

22
00:05:05,280 --> 00:05:08,840
is organized uh by acm sig karma by the

23
00:05:08,840 --> 00:05:11,840
irtf and it's co-located with the ietf

24
00:05:11,840 --> 00:05:14,000
meeting as you all know

25
00:05:14,000 --> 00:05:16,080
and as a result that means we we follow

26
00:05:16,080 --> 00:05:19,199
the itf's intellectual disclosure

27
00:05:19,199 --> 00:05:21,039
intellectual property rights disclosure

28
00:05:21,039 --> 00:05:22,479
rules

29
00:05:22,479 --> 00:05:24,800
so by uh participating in this meeting

30
00:05:24,800 --> 00:05:26,880
you follow the rules which i'm sure

31
00:05:26,880 --> 00:05:29,440
you're also familiar with uh

32
00:05:29,440 --> 00:05:30,320
um

33
00:05:30,320 --> 00:05:31,840
you you agree to follow the rules which

34
00:05:31,840 --> 00:05:33,919
are all familiar which i hope you are

35
00:05:33,919 --> 00:05:36,560
all familiar with uh and that's a if

36
00:05:36,560 --> 00:05:39,440
you're speaking at the microphones um

37
00:05:39,440 --> 00:05:40,479
and you

38
00:05:40,479 --> 00:05:42,320
you know of any uh patents or an

39
00:05:42,320 --> 00:05:45,199
intellectual property that covers uh

40
00:05:45,199 --> 00:05:46,720
covers the topic you're discussing then

41
00:05:46,720 --> 00:05:49,520
you agree to to disclose that

42
00:05:49,520 --> 00:05:52,479
uh the the links on the slide point to

43
00:05:52,479 --> 00:05:53,199
the

44
00:05:53,199 --> 00:05:56,560
the detailed policies there

45
00:05:57,199 --> 00:06:00,800
in uh addition um this session is being

46
00:06:00,800 --> 00:06:03,840
recorded uh and will be uh available

47
00:06:03,840 --> 00:06:07,360
online on youtube after the session

48
00:06:07,360 --> 00:06:08,800
and if you

49
00:06:08,800 --> 00:06:11,440
speak at microphones in the room if you

50
00:06:11,440 --> 00:06:12,240
um

51
00:06:12,240 --> 00:06:14,080
join during the session remotely then

52
00:06:14,080 --> 00:06:16,000
you you agree to being recorded and you

53
00:06:16,000 --> 00:06:17,680
agree to that recording being made

54
00:06:17,680 --> 00:06:18,840
publicly

55
00:06:18,840 --> 00:06:21,199
available uh in addition if you're

56
00:06:21,199 --> 00:06:23,280
participating in person and you're not

57
00:06:23,280 --> 00:06:25,280
wearing one of the red uh do not

58
00:06:25,280 --> 00:06:28,000
photograph lanyards then you uh

59
00:06:28,000 --> 00:06:30,080
consent to uh appearing in the

60
00:06:30,080 --> 00:06:32,639
recordings and in the um the

61
00:06:32,639 --> 00:06:35,120
the photographs of the session

62
00:06:35,120 --> 00:06:37,600
uh and uh online participants if you

63
00:06:37,600 --> 00:06:39,199
unmute your microphone and turn on your

64
00:06:39,199 --> 00:06:41,840
camera again you may be recorded and the

65
00:06:41,840 --> 00:06:44,319
recording may be published

66
00:06:44,319 --> 00:06:46,000
and as i say this recording is being

67
00:06:46,000 --> 00:06:48,720
published it is being recorded and i

68
00:06:48,720 --> 00:06:52,400
believe the closer being live streamed

69
00:06:55,120 --> 00:06:57,599
any uh personal information you give to

70
00:06:57,599 --> 00:07:00,560
the ietf to the irtf will be handled in

71
00:07:00,560 --> 00:07:02,560
accordance with the privacy policy and

72
00:07:02,560 --> 00:07:04,639
there's a link to that on the slide that

73
00:07:04,639 --> 00:07:06,319
mostly mostly applies to your

74
00:07:06,319 --> 00:07:08,960
registration details

75
00:07:08,960 --> 00:07:12,160
and by participating in the the irtf you

76
00:07:12,160 --> 00:07:13,520
agree to

77
00:07:13,520 --> 00:07:14,880
work respectfully with the other

78
00:07:14,880 --> 00:07:17,680
participants and you agree to follow the

79
00:07:17,680 --> 00:07:20,479
code of conduct

80
00:07:20,560 --> 00:07:23,120
if you have any questions or concerns

81
00:07:23,120 --> 00:07:26,000
about that please either contact me or

82
00:07:26,000 --> 00:07:27,919
contact the ombuds team

83
00:07:27,919 --> 00:07:29,759
and the link with the contact details

84
00:07:29,759 --> 00:07:33,360
for the ombuds team is on the slide

85
00:07:36,080 --> 00:07:39,039
and a final reminder before we start

86
00:07:39,039 --> 00:07:41,440
because of um

87
00:07:41,440 --> 00:07:44,000
the the risk of covet

88
00:07:44,000 --> 00:07:47,039
as a safety measure we are requiring all

89
00:07:47,039 --> 00:07:50,319
in-person participants in this meeting

90
00:07:50,319 --> 00:07:52,800
and in the other itf controlled areas of

91
00:07:52,800 --> 00:07:54,800
the meeting venue

92
00:07:54,800 --> 00:07:55,840
to where

93
00:07:55,840 --> 00:08:00,319
n95 uh or equivalent masks um at all at

94
00:08:00,319 --> 00:08:02,479
all times uh what while they're in this

95
00:08:02,479 --> 00:08:04,319
meeting or in the the itf controlled

96
00:08:04,319 --> 00:08:05,919
areas

97
00:08:05,919 --> 00:08:08,560
the only exception for that is for the

98
00:08:08,560 --> 00:08:09,520
um

99
00:08:09,520 --> 00:08:11,840
the speakers in the session who are

100
00:08:11,840 --> 00:08:14,319
actively giving the talks

101
00:08:14,319 --> 00:08:16,479
at the front microphone

102
00:08:16,479 --> 00:08:19,199
if you're making a

103
00:08:19,199 --> 00:08:20,879
comment or asking a question from the

104
00:08:20,879 --> 00:08:22,879
floor microphone we do ask that you

105
00:08:22,879 --> 00:08:25,919
remain uh masked at all times let me ask

106
00:08:25,919 --> 00:08:27,360
you remain

107
00:08:27,360 --> 00:08:28,639
masked

108
00:08:28,639 --> 00:08:30,479
while you are

109
00:08:30,479 --> 00:08:33,679
in the meeting at all times

110
00:08:39,360 --> 00:08:41,839
okay

111
00:08:41,919 --> 00:08:43,360
so

112
00:08:43,360 --> 00:08:46,320
this is the applied networking research

113
00:08:46,320 --> 00:08:48,160
workshop

114
00:08:48,160 --> 00:08:49,760
the um

115
00:08:49,760 --> 00:08:52,560
goal of the a rw

116
00:08:52,560 --> 00:08:56,560
is to provide a forum for

117
00:08:56,560 --> 00:08:59,519
researchers vendors network operators

118
00:08:59,519 --> 00:09:02,240
and the standards community to to talk

119
00:09:02,240 --> 00:09:05,279
about uh to discuss uh interesting new

120
00:09:05,279 --> 00:09:09,279
results in applied networking research

121
00:09:09,279 --> 00:09:11,360
um one of the goals is to try and find

122
00:09:11,360 --> 00:09:13,839
inspiration uh from the topics and and

123
00:09:13,839 --> 00:09:16,160
the problems being discussed in the itf

124
00:09:16,160 --> 00:09:17,760
and the other is to try and connect the

125
00:09:17,760 --> 00:09:21,120
research community with um the iatf and

126
00:09:21,120 --> 00:09:23,760
to help bring new ideas into the itf

127
00:09:23,760 --> 00:09:26,000
community into the standards community

128
00:09:26,000 --> 00:09:27,920
the goal is to encourage this two-way

129
00:09:27,920 --> 00:09:30,880
exchange of ideas

130
00:09:31,040 --> 00:09:35,519
the a rw is very much there to encourage

131
00:09:35,519 --> 00:09:37,839
hopefully the submission of new

132
00:09:37,839 --> 00:09:39,600
new research results that could form the

133
00:09:39,600 --> 00:09:42,480
basis of engineering work in the itf

134
00:09:42,480 --> 00:09:45,120
uh but also to to help better specify

135
00:09:45,120 --> 00:09:46,800
internet protocols

136
00:09:46,800 --> 00:09:48,800
possibly change operational practices

137
00:09:48,800 --> 00:09:51,120
possibly uh influence future research

138
00:09:51,120 --> 00:09:53,440
and experimentation in the ietf and the

139
00:09:53,440 --> 00:09:56,080
irtf

140
00:09:58,800 --> 00:10:00,240
one of the

141
00:10:00,240 --> 00:10:03,279
key areas there i think is

142
00:10:03,279 --> 00:10:05,120
one of the key goals for the workshop is

143
00:10:05,120 --> 00:10:07,360
to think about how we can better specify

144
00:10:07,360 --> 00:10:10,320
internet protocols

145
00:10:10,560 --> 00:10:11,360
and

146
00:10:11,360 --> 00:10:15,040
a lot of this has been in the form of

147
00:10:15,040 --> 00:10:17,760
ideas for new protocols themselves

148
00:10:17,760 --> 00:10:20,399
i mean as as we saw in in the talks this

149
00:10:20,399 --> 00:10:22,959
morning uh as we've seen it in the

150
00:10:22,959 --> 00:10:25,760
previous what versions of this workshop

151
00:10:25,760 --> 00:10:29,040
um we've had a lot of talks uh about how

152
00:10:29,040 --> 00:10:32,480
to to specify new protocols about new

153
00:10:32,480 --> 00:10:34,160
protocol designs improvements to

154
00:10:34,160 --> 00:10:37,600
protocols and so on

155
00:10:37,760 --> 00:10:39,440
part of the discussion though i i think

156
00:10:39,440 --> 00:10:41,279
is how it's not

157
00:10:41,279 --> 00:10:43,680
what new protocols we might need or how

158
00:10:43,680 --> 00:10:46,000
to improve protocols but how to specify

159
00:10:46,000 --> 00:10:48,640
protocols

160
00:10:49,680 --> 00:10:51,519
something we we haven't discussed so

161
00:10:51,519 --> 00:10:54,160
much in the a and rw uh which i think is

162
00:10:54,160 --> 00:10:55,680
one of the goals of this session is to

163
00:10:55,680 --> 00:10:58,000
try and start to think about how we

164
00:10:58,000 --> 00:11:01,920
describe and specify protocols

165
00:11:01,920 --> 00:11:04,320
um how we can you know think about how

166
00:11:04,320 --> 00:11:06,800
we can specify uh how we can ensure that

167
00:11:06,800 --> 00:11:08,720
the protocols we're specifying are

168
00:11:08,720 --> 00:11:10,720
consistent and correct

169
00:11:10,720 --> 00:11:13,279
and how we can verify the specific

170
00:11:13,279 --> 00:11:15,600
specifications we are writing

171
00:11:15,600 --> 00:11:17,600
as researchers or as engineers in the

172
00:11:17,600 --> 00:11:19,519
ietf

173
00:11:19,519 --> 00:11:21,760
are correct and how we can validate if

174
00:11:21,760 --> 00:11:23,360
the implementations match those

175
00:11:23,360 --> 00:11:25,519
specifications

176
00:11:25,519 --> 00:11:27,440
i think one of the key goals

177
00:11:27,440 --> 00:11:29,440
of writing a specification is to

178
00:11:29,440 --> 00:11:31,120
communicate and communicate in a way

179
00:11:31,120 --> 00:11:33,440
that we know that what is written in the

180
00:11:33,440 --> 00:11:35,519
spec is correct and that we can check

181
00:11:35,519 --> 00:11:37,360
that the implementations match that

182
00:11:37,360 --> 00:11:38,959
specification

183
00:11:38,959 --> 00:11:40,160
check that

184
00:11:40,160 --> 00:11:41,440
you know the specification is

185
00:11:41,440 --> 00:11:43,360
self-consistent the implementations

186
00:11:43,360 --> 00:11:45,440
match the specification and everything

187
00:11:45,440 --> 00:11:48,160
should interwork

188
00:11:52,560 --> 00:11:55,360
the way we have historically done that

189
00:11:55,360 --> 00:11:57,680
in the ietf community in the

190
00:11:57,680 --> 00:11:59,680
standardization community has been

191
00:11:59,680 --> 00:12:02,800
though to use natural language

192
00:12:02,800 --> 00:12:05,600
we write rfcs in english

193
00:12:05,600 --> 00:12:07,920
and we use english prose to describe and

194
00:12:07,920 --> 00:12:10,720
specify the protocols

195
00:12:10,720 --> 00:12:12,720
and yes we occasionally use formal

196
00:12:12,720 --> 00:12:15,600
language right we've been using abnf for

197
00:12:15,600 --> 00:12:17,440
example for for longer and i've been

198
00:12:17,440 --> 00:12:19,519
involved in the itf which is

199
00:12:19,519 --> 00:12:21,440
far too many years

200
00:12:21,440 --> 00:12:23,920
more recently we've started using

201
00:12:23,920 --> 00:12:26,480
yang in a lot of specifications and

202
00:12:26,480 --> 00:12:28,560
there's a number of other languages of

203
00:12:28,560 --> 00:12:31,680
scattered around around the rfc series

204
00:12:31,680 --> 00:12:34,560
but predominantly we specify rfcs in

205
00:12:34,560 --> 00:12:37,560
english

206
00:12:38,800 --> 00:12:41,279
what i'm hoping we can start to do in

207
00:12:41,279 --> 00:12:43,200
the session is to start to discuss

208
00:12:43,200 --> 00:12:44,800
whether this is the right way of writing

209
00:12:44,800 --> 00:12:47,760
protocol specifications

210
00:12:47,760 --> 00:12:49,600
i'll start to discuss to what extent

211
00:12:49,600 --> 00:12:52,320
formal methods structured specification

212
00:12:52,320 --> 00:12:55,440
languages natural language processing

213
00:12:55,440 --> 00:12:57,760
or other techniques can help to describe

214
00:12:57,760 --> 00:13:00,720
network protocols

215
00:13:04,000 --> 00:13:07,600
the goal is very much not

216
00:13:07,600 --> 00:13:10,480
to think about how we change

217
00:13:10,480 --> 00:13:13,360
think about how rfcs are prepared

218
00:13:13,360 --> 00:13:15,839
right it was um what what i i hope was a

219
00:13:15,839 --> 00:13:18,000
light-hearted comment in the

220
00:13:18,000 --> 00:13:20,160
the chat earlier about is this about

221
00:13:20,160 --> 00:13:22,720
whether we use markdown or xml for

222
00:13:22,720 --> 00:13:25,839
for writing rfcs right the goal of today

223
00:13:25,839 --> 00:13:27,600
is not to start a conversation about the

224
00:13:27,600 --> 00:13:29,519
rfc series

225
00:13:29,519 --> 00:13:31,279
the goal is to start a conversation

226
00:13:31,279 --> 00:13:33,120
about how we specify protocols in

227
00:13:33,120 --> 00:13:34,959
general

228
00:13:34,959 --> 00:13:36,560
and whether english is the right way of

229
00:13:36,560 --> 00:13:38,560
writing these protocols to what extent

230
00:13:38,560 --> 00:13:40,160
formal methods or other techniques

231
00:13:40,160 --> 00:13:43,279
should be incorporated

232
00:13:46,240 --> 00:13:48,399
i'd like to use this session hopefully

233
00:13:48,399 --> 00:13:50,160
to start a conversation

234
00:13:50,160 --> 00:13:51,839
so that's a conversation about how we

235
00:13:51,839 --> 00:13:54,000
specify protocols

236
00:13:54,000 --> 00:13:56,880
and hopefully to begin to connect um

237
00:13:56,880 --> 00:13:59,440
academic researchers who are studying

238
00:13:59,440 --> 00:14:01,839
protocol specification

239
00:14:01,839 --> 00:14:03,839
with the engineers in the itf the

240
00:14:03,839 --> 00:14:07,199
researchers in the itf and the irtf that

241
00:14:07,199 --> 00:14:09,519
specify protocol standards and design

242
00:14:09,519 --> 00:14:13,240
and develop new protocols

243
00:14:17,519 --> 00:14:22,000
so uh our agenda for today um

244
00:14:22,800 --> 00:14:24,320
we have we just finished the the

245
00:14:24,320 --> 00:14:26,880
introduction status update um and then

246
00:14:26,880 --> 00:14:31,199
we we have three invited talks

247
00:14:31,199 --> 00:14:33,920
first talk will be by

248
00:14:33,920 --> 00:14:35,920
max von hippel from northeastern

249
00:14:35,920 --> 00:14:39,279
university we'll be talking about um

250
00:14:39,279 --> 00:14:41,680
automated attack synthesis by extracting

251
00:14:41,680 --> 00:14:43,440
finite state machines from critical

252
00:14:43,440 --> 00:14:45,839
specifications

253
00:14:45,839 --> 00:14:47,920
uh that will be followed by a talk from

254
00:14:47,920 --> 00:14:51,120
jane yen from usc i'll be talking about

255
00:14:51,120 --> 00:14:52,880
some work they've been doing

256
00:14:52,880 --> 00:14:56,320
on tools for disambiguating rfcs

257
00:14:56,320 --> 00:14:57,680
and then finally chris wood from

258
00:14:57,680 --> 00:14:59,920
cloudflare will be um

259
00:14:59,920 --> 00:15:01,360
talking about some of the work that's

260
00:15:01,360 --> 00:15:03,120
been happening in the crypto forum

261
00:15:03,120 --> 00:15:05,040
research group and some of the the

262
00:15:05,040 --> 00:15:07,040
successes and limitations of the way

263
00:15:07,040 --> 00:15:09,360
that group has been um specifying

264
00:15:09,360 --> 00:15:10,839
cryptographic

265
00:15:10,839 --> 00:15:13,120
standards and then at the end

266
00:15:13,120 --> 00:15:15,120
we have a i hope some some time for

267
00:15:15,120 --> 00:15:16,959
discussion uh

268
00:15:16,959 --> 00:15:19,600
before we close

269
00:15:19,600 --> 00:15:21,440
um there is a

270
00:15:21,440 --> 00:15:23,920
note that there's a hedgedock for notes

271
00:15:23,920 --> 00:15:26,720
the link is on the slide here um

272
00:15:26,720 --> 00:15:29,360
if you have questions or comments either

273
00:15:29,360 --> 00:15:31,680
put them in the chat or put them in

274
00:15:31,680 --> 00:15:33,040
in the hedge dock i guess probably

275
00:15:33,040 --> 00:15:34,880
better to put them in in the chat

276
00:15:34,880 --> 00:15:36,240
there's also a session in the hedge

277
00:15:36,240 --> 00:15:38,959
docker in the notes if you

278
00:15:38,959 --> 00:15:41,040
would like us to get in touch about any

279
00:15:41,040 --> 00:15:43,120
of this work uh if you're interested in

280
00:15:43,120 --> 00:15:44,880
following up on any of these ideas then

281
00:15:44,880 --> 00:15:46,959
please put your name in there

282
00:15:46,959 --> 00:15:48,000
and

283
00:15:48,000 --> 00:15:50,399
we'll try and follow up afterwards and

284
00:15:50,399 --> 00:15:51,519
we'll talk more about this in the

285
00:15:51,519 --> 00:15:55,360
discussion session at the end

286
00:15:55,360 --> 00:15:59,040
so for that uh if max is present in the

287
00:15:59,040 --> 00:16:00,480
room uh

288
00:16:00,480 --> 00:16:02,880
he could come up and i'd like to to hand

289
00:16:02,880 --> 00:16:04,240
over to him

290
00:16:04,240 --> 00:16:06,800
for the first

291
00:16:06,839 --> 00:16:08,639
talk right

292
00:16:08,639 --> 00:16:12,000
i'm curious i'm ready to go

293
00:16:14,000 --> 00:16:15,199
should i use this microphone or the

294
00:16:15,199 --> 00:16:16,720
other ones

295
00:16:16,720 --> 00:16:20,279
stay anywhere okay

296
00:16:23,600 --> 00:16:24,480
all right

297
00:16:24,480 --> 00:16:26,720
all right

298
00:16:27,440 --> 00:16:28,560
and

299
00:16:28,560 --> 00:16:30,800
okay and

300
00:16:30,800 --> 00:16:32,399
uh colin can you give me control over

301
00:16:32,399 --> 00:16:33,920
the slides

302
00:16:33,920 --> 00:16:36,720
yep i'm just uh trying to find the right

303
00:16:36,720 --> 00:16:39,759
button in me took

304
00:16:40,639 --> 00:16:42,560
got it all right thank you very much

305
00:16:42,560 --> 00:16:44,959
you got it

306
00:16:44,959 --> 00:16:47,440
okay over to you

307
00:16:47,440 --> 00:16:49,759
all right my name is max von hippel i'm

308
00:16:49,759 --> 00:16:51,600
a fourth year phd student at

309
00:16:51,600 --> 00:16:53,680
northeastern university and today i'll

310
00:16:53,680 --> 00:16:55,680
be talking to you about automated attack

311
00:16:55,680 --> 00:16:57,519
synthesis by extracting finite state

312
00:16:57,519 --> 00:16:59,600
machines from rfcs from protocol

313
00:16:59,600 --> 00:17:01,360
specification documents

314
00:17:01,360 --> 00:17:03,199
this was a collaborative work with maria

315
00:17:03,199 --> 00:17:05,520
lenoir pacheco from purdue who recently

316
00:17:05,520 --> 00:17:08,720
graduated and is now a professor at

317
00:17:08,720 --> 00:17:10,559
university of colorado boulder as well

318
00:17:10,559 --> 00:17:13,760
as her advisor dan goldwater at purdue

319
00:17:13,760 --> 00:17:15,280
another student from my lab ben

320
00:17:15,280 --> 00:17:17,520
weintraub and our advisor christina

321
00:17:17,520 --> 00:17:20,559
nieto retaro and this work was presented

322
00:17:20,559 --> 00:17:22,559
also at the ieee security and privacy

323
00:17:22,559 --> 00:17:24,959
conference

324
00:17:25,359 --> 00:17:27,119
so today we're going to be talking or at

325
00:17:27,119 --> 00:17:28,400
least i'm going to be talking about

326
00:17:28,400 --> 00:17:31,440
automated protocol analysis

327
00:17:31,440 --> 00:17:33,440
this is old news to those of you who who

328
00:17:33,440 --> 00:17:34,720
build protocols so everybody in this

329
00:17:34,720 --> 00:17:36,640
room but uh but the internet runs on

330
00:17:36,640 --> 00:17:40,799
protocols such as tcp udp etc and um

331
00:17:40,799 --> 00:17:42,480
these protocols create a sort of shared

332
00:17:42,480 --> 00:17:43,840
language for computers to talk to one

333
00:17:43,840 --> 00:17:45,360
another here we have picture the

334
00:17:45,360 --> 00:17:47,360
internet or specifically the arpanet in

335
00:17:47,360 --> 00:17:49,520
december 1969 at the time there were

336
00:17:49,520 --> 00:17:51,600
four computers talking to one another

337
00:17:51,600 --> 00:17:53,200
the internet has grown considerably

338
00:17:53,200 --> 00:17:56,160
since that picture was drawn

339
00:17:56,960 --> 00:17:58,720
i'm a formal methods researcher and in

340
00:17:58,720 --> 00:18:00,960
formal methods we call these things

341
00:18:00,960 --> 00:18:02,640
crippy structures

342
00:18:02,640 --> 00:18:05,600
but to normal software engineers

343
00:18:05,600 --> 00:18:07,039
protocols are described by finite state

344
00:18:07,039 --> 00:18:10,559
machines and a finite state machine is

345
00:18:10,559 --> 00:18:12,720
actually a completely unambiguous

346
00:18:12,720 --> 00:18:14,559
specification of the language of a

347
00:18:14,559 --> 00:18:15,760
protocol

348
00:18:15,760 --> 00:18:17,679
and essentially when i say that a

349
00:18:17,679 --> 00:18:19,120
protocol makes us that two computers

350
00:18:19,120 --> 00:18:20,720
speak the same language i'm saying

351
00:18:20,720 --> 00:18:22,400
something both informal and formal the

352
00:18:22,400 --> 00:18:24,240
formal statement is that they run

353
00:18:24,240 --> 00:18:25,760
either the same state machine or state

354
00:18:25,760 --> 00:18:28,320
machines that accept the same language

355
00:18:28,320 --> 00:18:29,840
the informal one is that they know how

356
00:18:29,840 --> 00:18:32,720
to talk to one another

357
00:18:34,160 --> 00:18:35,520
in our group at northeastern we

358
00:18:35,520 --> 00:18:36,880
specialize in studying these finite

359
00:18:36,880 --> 00:18:38,320
state machines either using formal

360
00:18:38,320 --> 00:18:39,919
methods or other approaches and trying

361
00:18:39,919 --> 00:18:42,559
to find flaws in them so we take a

362
00:18:42,559 --> 00:18:44,640
protocol the protocol we define a

363
00:18:44,640 --> 00:18:47,440
protocol to be whatever is in these rfc

364
00:18:47,440 --> 00:18:49,679
we then formalize it using a finite

365
00:18:49,679 --> 00:18:51,600
state machine that we write in some

366
00:18:51,600 --> 00:18:53,360
language like pramela

367
00:18:53,360 --> 00:18:55,840
or upol or something like this and then

368
00:18:55,840 --> 00:18:57,679
we have a tool that generates attacks

369
00:18:57,679 --> 00:19:00,160
against that that protocol

370
00:19:00,160 --> 00:19:03,200
expresses an fsm

371
00:19:04,320 --> 00:19:06,160
so there's kind of a lot of hidden steps

372
00:19:06,160 --> 00:19:07,360
in between there right going from

373
00:19:07,360 --> 00:19:10,320
specification to fsm to attacks and i'd

374
00:19:10,320 --> 00:19:13,200
like to disambiguate that a little bit

375
00:19:13,200 --> 00:19:15,760
when we talk about protocols we first

376
00:19:15,760 --> 00:19:17,280
and foremost have to talk about rfc

377
00:19:17,280 --> 00:19:19,120
specifications right which is obviously

378
00:19:19,120 --> 00:19:21,280
especially salient in this context

379
00:19:21,280 --> 00:19:22,960
these are written by the ietf the

380
00:19:22,960 --> 00:19:24,559
written in english prose which i think

381
00:19:24,559 --> 00:19:26,880
is is the topic of today's conversation

382
00:19:26,880 --> 00:19:29,120
um and although they they may seem

383
00:19:29,120 --> 00:19:30,880
technical to somebody who doesn't write

384
00:19:30,880 --> 00:19:32,720
these documents for a living the reality

385
00:19:32,720 --> 00:19:34,240
is that they really could be quite a bit

386
00:19:34,240 --> 00:19:36,799
more technical than they are right um so

387
00:19:36,799 --> 00:19:38,080
for example they could be written in

388
00:19:38,080 --> 00:19:40,000
 or agda they could be written in a

389
00:19:40,000 --> 00:19:41,520
in a programming language if we wanted

390
00:19:41,520 --> 00:19:43,600
them to um and there are advantages and

391
00:19:43,600 --> 00:19:45,120
disadvantages to

392
00:19:45,120 --> 00:19:48,159
their current presentation

393
00:19:48,559 --> 00:19:50,799
then a programmer reads these rfc

394
00:19:50,799 --> 00:19:53,039
specifications and implements them so on

395
00:19:53,039 --> 00:19:55,200
the left we have the uh well a tiny

396
00:19:55,200 --> 00:19:58,080
little screenshot of the dccp rfc and on

397
00:19:58,080 --> 00:19:59,360
the right we have a tiny little

398
00:19:59,360 --> 00:20:00,799
screenshot of dc

399
00:20:00,799 --> 00:20:04,000
dccp implemented in the linux kernel and

400
00:20:04,000 --> 00:20:05,840
there are all sorts of decisions that

401
00:20:05,840 --> 00:20:07,600
the implementer has to make when

402
00:20:07,600 --> 00:20:11,600
implementing uh the the rfc um

403
00:20:11,600 --> 00:20:14,080
and that doesn't just include decisions

404
00:20:14,080 --> 00:20:15,600
about how to implement some

405
00:20:15,600 --> 00:20:17,360
functionality like oh this list needs to

406
00:20:17,360 --> 00:20:19,760
be sorted will i use you know merge sort

407
00:20:19,760 --> 00:20:22,400
or or bubble sort but also decisions

408
00:20:22,400 --> 00:20:24,080
about what it is that the specification

409
00:20:24,080 --> 00:20:26,000
actually says in the first place because

410
00:20:26,000 --> 00:20:27,360
since it's written in english that's not

411
00:20:27,360 --> 00:20:30,320
inherently clear

412
00:20:30,559 --> 00:20:33,600
so when the implementer reads the rfc

413
00:20:33,600 --> 00:20:35,520
specification and decides what she is

414
00:20:35,520 --> 00:20:37,600
going to implement um

415
00:20:37,600 --> 00:20:39,200
implicitly she's creating a mental model

416
00:20:39,200 --> 00:20:41,440
in her head and to me as a formal

417
00:20:41,440 --> 00:20:42,960
methods person i view that mental model

418
00:20:42,960 --> 00:20:44,559
as a finite state machine

419
00:20:44,559 --> 00:20:46,000
but it doesn't really matter you could

420
00:20:46,000 --> 00:20:47,520
view it as any isomorphic thing the

421
00:20:47,520 --> 00:20:49,600
point is that obviously a human being

422
00:20:49,600 --> 00:20:51,840
reading english text is going to to

423
00:20:51,840 --> 00:20:53,360
imagine what that text is supposed to

424
00:20:53,360 --> 00:20:56,240
communicate and that thing that that she

425
00:20:56,240 --> 00:20:58,320
or he imagines is

426
00:20:58,320 --> 00:21:00,960
some expression abstractly of what they

427
00:21:00,960 --> 00:21:02,799
intend to implement they then go and

428
00:21:02,799 --> 00:21:04,559
implement it and hopefully there's no

429
00:21:04,559 --> 00:21:07,840
errors in that process either

430
00:21:08,000 --> 00:21:10,720
so bugs in a protocol implementation can

431
00:21:10,720 --> 00:21:13,360
arise from any one of the steps in this

432
00:21:13,360 --> 00:21:14,960
process first of all there could be

433
00:21:14,960 --> 00:21:16,640
fundamental design flaws in the

434
00:21:16,640 --> 00:21:18,400
specification it could be that we

435
00:21:18,400 --> 00:21:20,480
specified something that was bad right

436
00:21:20,480 --> 00:21:22,480
it was a bad idea and the idea needs to

437
00:21:22,480 --> 00:21:25,120
be reworked

438
00:21:25,200 --> 00:21:27,760
it's also entirely possible that the

439
00:21:27,760 --> 00:21:29,919
mental model the finite state machine is

440
00:21:29,919 --> 00:21:32,720
wrong in other words that the programmer

441
00:21:32,720 --> 00:21:34,960
or implementer made some mistake when

442
00:21:34,960 --> 00:21:36,400
she read the specification and

443
00:21:36,400 --> 00:21:38,000
misinterpreted something now we could

444
00:21:38,000 --> 00:21:39,280
blame that on the programmer or blame it

445
00:21:39,280 --> 00:21:40,480
on the author it doesn't really matter

446
00:21:40,480 --> 00:21:42,000
but mathematically there could be a

447
00:21:42,000 --> 00:21:43,440
discrepancy between the finite state

448
00:21:43,440 --> 00:21:45,039
machine that the programmer intends to

449
00:21:45,039 --> 00:21:46,799
implement and the one that was

450
00:21:46,799 --> 00:21:48,960
abstractly described by the protocol

451
00:21:48,960 --> 00:21:51,919
text by the rfc

452
00:21:52,400 --> 00:21:54,559
and then finally it's entirely possible

453
00:21:54,559 --> 00:21:57,200
that the specification is great and the

454
00:21:57,200 --> 00:21:58,320
finite state machine that the programmer

455
00:21:58,320 --> 00:22:00,320
imagines is great but the programmer has

456
00:22:00,320 --> 00:22:01,840
a typo or something and so there's some

457
00:22:01,840 --> 00:22:03,520
bug in implementation

458
00:22:03,520 --> 00:22:05,280
which was unintended right so the

459
00:22:05,280 --> 00:22:06,400
programmer writes something that does

460
00:22:06,400 --> 00:22:09,840
not do what she intended to do

461
00:22:10,559 --> 00:22:12,880
this last class of bug is an extremely

462
00:22:12,880 --> 00:22:14,480
well-studied problem and there are a ton

463
00:22:14,480 --> 00:22:16,000
of really great techniques for

464
00:22:16,000 --> 00:22:17,600
approaching it and it does not interest

465
00:22:17,600 --> 00:22:19,440
me today so we will be talking about the

466
00:22:19,440 --> 00:22:21,760
other two

467
00:22:21,760 --> 00:22:23,360
so this presentation is going to focus

468
00:22:23,360 --> 00:22:24,880
on fundamental issues with protocol

469
00:22:24,880 --> 00:22:26,720
design and ambiguities and omissions in

470
00:22:26,720 --> 00:22:29,440
the specification

471
00:22:30,159 --> 00:22:31,840
the first half of this presentation will

472
00:22:31,840 --> 00:22:33,760
be about how we can automatically

473
00:22:33,760 --> 00:22:35,520
extract a finite state machine from a

474
00:22:35,520 --> 00:22:37,200
protocol specification so i'm going to

475
00:22:37,200 --> 00:22:39,039
take an rfc document and i'm going to

476
00:22:39,039 --> 00:22:41,440
automatically guess or extract to find a

477
00:22:41,440 --> 00:22:42,960
state machine that should represent that

478
00:22:42,960 --> 00:22:44,080
rfc

479
00:22:44,080 --> 00:22:46,080
this is sort of like automating the

480
00:22:46,080 --> 00:22:47,760
first step that the implementer does

481
00:22:47,760 --> 00:22:49,280
when she reads the specification and

482
00:22:49,280 --> 00:22:51,120
tries to decide what it says before she

483
00:22:51,120 --> 00:22:53,200
goes and implements it in rust or go or

484
00:22:53,200 --> 00:22:55,360
whatever

485
00:22:55,360 --> 00:22:57,280
the second half will be doing something

486
00:22:57,280 --> 00:22:59,039
useful with that so in order to measure

487
00:22:59,039 --> 00:23:00,480
that the extracted final state machine

488
00:23:00,480 --> 00:23:01,600
is actually good for something i'm going

489
00:23:01,600 --> 00:23:03,120
to do something with it and by something

490
00:23:03,120 --> 00:23:04,559
i mean attack synthesis i'm going to

491
00:23:04,559 --> 00:23:06,320
automatically generate attacks

492
00:23:06,320 --> 00:23:07,760
if you're in this room and you're like

493
00:23:07,760 --> 00:23:09,039
well that sounds cool but i don't care

494
00:23:09,039 --> 00:23:10,960
about security um i'll tell you right

495
00:23:10,960 --> 00:23:12,720
now you can view these attacks as bugs

496
00:23:12,720 --> 00:23:14,159
so you could also view it as i'm going

497
00:23:14,159 --> 00:23:15,840
to automatically find bugs

498
00:23:15,840 --> 00:23:17,120
so this is relevant whether or not you

499
00:23:17,120 --> 00:23:19,840
care about security

500
00:23:20,080 --> 00:23:21,760
so let's focus on the first part first

501
00:23:21,760 --> 00:23:22,720
and then we'll move on to the second

502
00:23:22,720 --> 00:23:24,640
part

503
00:23:24,640 --> 00:23:26,080
when we try to extract a finite state

504
00:23:26,080 --> 00:23:27,200
machine from a request for comments

505
00:23:27,200 --> 00:23:28,799
document there are a number of critical

506
00:23:28,799 --> 00:23:30,480
challenges that we faced first and

507
00:23:30,480 --> 00:23:31,919
foremost there's simply no one-to-one

508
00:23:31,919 --> 00:23:33,280
mapping between the text and what we

509
00:23:33,280 --> 00:23:35,520
call this canonical finite state machine

510
00:23:35,520 --> 00:23:38,480
in fact it takes human expertise to read

511
00:23:38,480 --> 00:23:41,440
a rfc and interpret what it is that it

512
00:23:41,440 --> 00:23:43,679
says or should say

513
00:23:43,679 --> 00:23:44,960
for a number of reasons that we'll get

514
00:23:44,960 --> 00:23:47,200
into

515
00:23:47,600 --> 00:23:49,360
second and related to the first point

516
00:23:49,360 --> 00:23:50,880
rfcs contain omissions mistakes and

517
00:23:50,880 --> 00:23:53,039
ambiguities here's an example from the

518
00:23:53,039 --> 00:23:56,320
dccp rfc where a sentence if interpreted

519
00:23:56,320 --> 00:23:58,000
mathematically would imply the existence

520
00:23:58,000 --> 00:23:59,760
of a transition from part open to open

521
00:23:59,760 --> 00:24:02,080
upon receipt of a dccp closed packet but

522
00:24:02,080 --> 00:24:03,520
of course that would be nonsensical if

523
00:24:03,520 --> 00:24:05,279
you receive a dccp closed packet you

524
00:24:05,279 --> 00:24:07,120
should close your connection not go to

525
00:24:07,120 --> 00:24:10,000
open and so um uh if you read the rest

526
00:24:10,000 --> 00:24:11,200
of the document it becomes clear that

527
00:24:11,200 --> 00:24:12,880
that transition should not exist but if

528
00:24:12,880 --> 00:24:14,720
you read this sentence and interpret it

529
00:24:14,720 --> 00:24:16,880
literally it clearly implies the

530
00:24:16,880 --> 00:24:18,720
transition that isn't there and i will

531
00:24:18,720 --> 00:24:19,840
tell you from

532
00:24:19,840 --> 00:24:21,600
now years of experience that rfc

533
00:24:21,600 --> 00:24:22,960
documents are riddled with sentences

534
00:24:22,960 --> 00:24:25,360
like these

535
00:24:26,000 --> 00:24:27,520
another problem is that off-the-shelf

536
00:24:27,520 --> 00:24:28,880
natural language processing tools are

537
00:24:28,880 --> 00:24:30,960
simply not suitable generally speaking

538
00:24:30,960 --> 00:24:33,039
they are trained on newswire text or

539
00:24:33,039 --> 00:24:34,559
books or things like this that are

540
00:24:34,559 --> 00:24:36,480
non-technical in nature and so they face

541
00:24:36,480 --> 00:24:38,080
the exact same problem that i faced when

542
00:24:38,080 --> 00:24:39,760
i tried to describe my research to my

543
00:24:39,760 --> 00:24:41,279
girlfriend who's not a programmer which

544
00:24:41,279 --> 00:24:42,799
is that i use all sorts of lingo that

545
00:24:42,799 --> 00:24:45,120
are kind of domain specific and and

546
00:24:45,120 --> 00:24:46,720
don't mean anything to people in other

547
00:24:46,720 --> 00:24:49,919
fields like in her case biology so um we

548
00:24:49,919 --> 00:24:51,440
need something that's trained on

549
00:24:51,440 --> 00:24:53,039
relevant text such as computer

550
00:24:53,039 --> 00:24:55,520
networking textbooks or stack page stack

551
00:24:55,520 --> 00:24:58,840
exchange stack overflow questions

552
00:24:58,840 --> 00:25:01,520
etc finally there's a ton of variation

553
00:25:01,520 --> 00:25:02,640
in the language and structure of

554
00:25:02,640 --> 00:25:04,640
different rfcs and this is one of the i

555
00:25:04,640 --> 00:25:05,840
think interesting results we'll show

556
00:25:05,840 --> 00:25:08,559
today is that spoiler alert the dccp rfc

557
00:25:08,559 --> 00:25:10,240
is more complicated than tcp one at

558
00:25:10,240 --> 00:25:14,480
least in terms of its english text

559
00:25:14,480 --> 00:25:16,640
so we have a multi-step approach the

560
00:25:16,640 --> 00:25:18,159
first step is that we create a technical

561
00:25:18,159 --> 00:25:20,400
language embedding um

562
00:25:20,400 --> 00:25:21,679
essentially what we're doing here is

563
00:25:21,679 --> 00:25:23,679
that rather than impose our own concept

564
00:25:23,679 --> 00:25:25,600
of what the most natural vector space is

565
00:25:25,600 --> 00:25:27,919
for the text that describes an rfc to

566
00:25:27,919 --> 00:25:29,600
live in we are allowing a machine

567
00:25:29,600 --> 00:25:31,520
learning model to come up with an ideal

568
00:25:31,520 --> 00:25:33,440
vector space that it wants to learn from

569
00:25:33,440 --> 00:25:35,840
um that embedding is going to capture

570
00:25:35,840 --> 00:25:37,200
all sorts of interesting things about

571
00:25:37,200 --> 00:25:40,559
the text such as uh the the punctuation

572
00:25:40,559 --> 00:25:42,960
of sentences or the use of mathematical

573
00:25:42,960 --> 00:25:45,760
symbols etc

574
00:25:45,919 --> 00:25:47,600
second we have a zero shot protocol

575
00:25:47,600 --> 00:25:49,520
information extraction that's where

576
00:25:49,520 --> 00:25:51,200
we're going to take the text that is now

577
00:25:51,200 --> 00:25:52,559
projected into the vector space of our

578
00:25:52,559 --> 00:25:54,159
technical language embedding and we're

579
00:25:54,159 --> 00:25:55,840
going to automatically extract an

580
00:25:55,840 --> 00:25:57,600
intermediary representation which i'll

581
00:25:57,600 --> 00:25:59,600
get into more later which contains

582
00:25:59,600 --> 00:26:01,840
sufficiently much information for us to

583
00:26:01,840 --> 00:26:04,320
then in a subsequent step extract a

584
00:26:04,320 --> 00:26:06,320
finite state machine so i want to stress

585
00:26:06,320 --> 00:26:08,480
this point that we don't do end to end

586
00:26:08,480 --> 00:26:11,360
in one step from english to fsm we break

587
00:26:11,360 --> 00:26:13,600
it down into smaller sub-problems and we

588
00:26:13,600 --> 00:26:14,799
essentially create a structured

589
00:26:14,799 --> 00:26:16,320
intermediary representation which is an

590
00:26:16,320 --> 00:26:18,880
xml document that has enough data for us

591
00:26:18,880 --> 00:26:20,640
to then in a third step extract the

592
00:26:20,640 --> 00:26:22,159
finite state machine in a rather

593
00:26:22,159 --> 00:26:24,559
heuristic manner

594
00:26:24,559 --> 00:26:26,320
finally we do something useful with that

595
00:26:26,320 --> 00:26:28,720
fsm in our cases attack synthesis i'd

596
00:26:28,720 --> 00:26:30,000
like to stress that you can do other

597
00:26:30,000 --> 00:26:31,919
things if you care about other things so

598
00:26:31,919 --> 00:26:33,120
if you were like well i don't care about

599
00:26:33,120 --> 00:26:34,720
attacks i'm not a security person but i

600
00:26:34,720 --> 00:26:37,360
care about bugs i care about correctness

601
00:26:37,360 --> 00:26:38,880
monitors whatever well boy do i have

602
00:26:38,880 --> 00:26:39,919
other tools for you there are other

603
00:26:39,919 --> 00:26:41,360
things you can do with these

604
00:26:41,360 --> 00:26:42,960
but what we did was attack synthesis

605
00:26:42,960 --> 00:26:44,880
because uh frankly my dissertation is

606
00:26:44,880 --> 00:26:46,960
going to be about attack synthesis so i

607
00:26:46,960 --> 00:26:50,240
applied attack synthesis

608
00:26:50,880 --> 00:26:52,720
let's talk about step one in step one we

609
00:26:52,720 --> 00:26:53,840
want to learn a technical language

610
00:26:53,840 --> 00:26:55,600
embedding as i said i don't want to

611
00:26:55,600 --> 00:26:57,840
impose my own personal moral ethical

612
00:26:57,840 --> 00:26:59,679
beliefs about uh the natural vector

613
00:26:59,679 --> 00:27:01,279
space of rfc documents rather i'm going

614
00:27:01,279 --> 00:27:02,640
to let the computer decide this we use

615
00:27:02,640 --> 00:27:04,880
something called burt the idea of bert

616
00:27:04,880 --> 00:27:07,200
loosely speaking is that it takes a

617
00:27:07,200 --> 00:27:09,200
contextualized approach to understanding

618
00:27:09,200 --> 00:27:11,200
what words mean so the word reset could

619
00:27:11,200 --> 00:27:12,480
mean something different in different

620
00:27:12,480 --> 00:27:14,880
contexts because it is informed by the

621
00:27:14,880 --> 00:27:16,720
words around it

622
00:27:16,720 --> 00:27:19,919
we train on roughly 9000 documents and

623
00:27:19,919 --> 00:27:23,360
roughly 475 million words uh so our bert

624
00:27:23,360 --> 00:27:25,200
model is trained on quite a lot of data

625
00:27:25,200 --> 00:27:27,840
that includes um stack exchange stack

626
00:27:27,840 --> 00:27:30,880
overflow networking textbooks um all

627
00:27:30,880 --> 00:27:34,159
sorts of other things

628
00:27:34,159 --> 00:27:35,840
next we want to do protocol information

629
00:27:35,840 --> 00:27:37,440
extraction so just to remind you in case

630
00:27:37,440 --> 00:27:39,919
you missed it um i now have some text

631
00:27:39,919 --> 00:27:41,679
that is projected into my vector space

632
00:27:41,679 --> 00:27:43,679
and i want to translate it into an xml

633
00:27:43,679 --> 00:27:45,039
document i'll show you what that looks

634
00:27:45,039 --> 00:27:47,200
like momentarily which somehow captures

635
00:27:47,200 --> 00:27:49,679
um enough data for me to then be able to

636
00:27:49,679 --> 00:27:51,039
extract a finite state machine in a

637
00:27:51,039 --> 00:27:52,720
straightforward manner so i i

638
00:27:52,720 --> 00:27:54,159
essentially want to read the text so put

639
00:27:54,159 --> 00:27:55,840
differently i want to teach a computer

640
00:27:55,840 --> 00:27:57,760
how to read and interpret the english

641
00:27:57,760 --> 00:27:59,919
language rfc document now that it has it

642
00:27:59,919 --> 00:28:02,159
in its own natural language which is the

643
00:28:02,159 --> 00:28:04,000
the burton coding so here's a little

644
00:28:04,000 --> 00:28:07,039
snapshot from the dccp rfc and i'm going

645
00:28:07,039 --> 00:28:08,960
to show you how we would uh

646
00:28:08,960 --> 00:28:11,120
put this into a intermediary

647
00:28:11,120 --> 00:28:13,760
representation

648
00:28:13,840 --> 00:28:15,200
first we need to know what it means for

649
00:28:15,200 --> 00:28:16,720
the computer to read the document so to

650
00:28:16,720 --> 00:28:18,480
do this we invent a grammar shown here

651
00:28:18,480 --> 00:28:20,640
in broadcast now our form the grammar

652
00:28:20,640 --> 00:28:22,240
contains a few different types of tags

653
00:28:22,240 --> 00:28:23,919
it has definition tags that are used to

654
00:28:23,919 --> 00:28:27,200
define states events etc

655
00:28:27,200 --> 00:28:28,960
reference tags that reference previously

656
00:28:28,960 --> 00:28:31,039
defined states

657
00:28:31,039 --> 00:28:34,080
transition events etc

658
00:28:34,080 --> 00:28:35,919
state machine tags that tag essentially

659
00:28:35,919 --> 00:28:37,360
the structure of the finite state

660
00:28:37,360 --> 00:28:38,960
machine in the document any references

661
00:28:38,960 --> 00:28:40,640
to transitions or other logic that

662
00:28:40,640 --> 00:28:42,720
relate to the state machine and then

663
00:28:42,720 --> 00:28:44,880
finally control flow tags that

664
00:28:44,880 --> 00:28:47,039
essentially uh capture logical structure

665
00:28:47,039 --> 00:28:48,240
in the fsm so when you read these

666
00:28:48,240 --> 00:28:49,760
documents a lot of times they have kind

667
00:28:49,760 --> 00:28:51,760
of complicated if else structure uh

668
00:28:51,760 --> 00:28:53,760
often that's related to the indentation

669
00:28:53,760 --> 00:28:56,000
of different blocks of text and um our

670
00:28:56,000 --> 00:28:57,919
nlp is going to capture that using these

671
00:28:57,919 --> 00:29:00,720
control flow tags

672
00:29:01,360 --> 00:29:03,039
so here's that same quote again but this

673
00:29:03,039 --> 00:29:04,240
time it's now wrapped in our

674
00:29:04,240 --> 00:29:05,760
intermediary representation structure in

675
00:29:05,760 --> 00:29:07,679
our xml we have a control block on the

676
00:29:07,679 --> 00:29:10,640
outside that scopes our search

677
00:29:10,640 --> 00:29:12,559
we have a transition block that contains

678
00:29:12,559 --> 00:29:14,240
an entire state machine transition

679
00:29:14,240 --> 00:29:15,600
including the

680
00:29:15,600 --> 00:29:18,000
source state and the

681
00:29:18,000 --> 00:29:19,600
target state

682
00:29:19,600 --> 00:29:22,159
and then we have an event and we know

683
00:29:22,159 --> 00:29:24,960
what exactly uh occurs on that event so

684
00:29:24,960 --> 00:29:26,399
from the perspective of a formal methods

685
00:29:26,399 --> 00:29:28,320
person i now have the source state the

686
00:29:28,320 --> 00:29:29,760
target state and the label on the

687
00:29:29,760 --> 00:29:31,760
transition in my cryptic structure but

688
00:29:31,760 --> 00:29:32,880
from the perspective of a software

689
00:29:32,880 --> 00:29:35,760
engineer i have you know an edge in the

690
00:29:35,760 --> 00:29:37,279
directed graph that is my final state

691
00:29:37,279 --> 00:29:40,279
machine

692
00:29:40,799 --> 00:29:43,279
in order to go from text to this

693
00:29:43,279 --> 00:29:44,799
intermediary representation without

694
00:29:44,799 --> 00:29:46,640
requiring a bunch of grad students to

695
00:29:46,640 --> 00:29:48,960
spend countless hours annotating things

696
00:29:48,960 --> 00:29:51,279
we use a machine learning approach uh in

697
00:29:51,279 --> 00:29:52,320
fact we use two different machine

698
00:29:52,320 --> 00:29:53,600
learning approaches we compare them the

699
00:29:53,600 --> 00:29:55,039
first one is a linear conditional random

700
00:29:55,039 --> 00:29:56,480
fields model which starts out by

701
00:29:56,480 --> 00:29:59,120
splitting text into chunks

702
00:29:59,120 --> 00:30:01,520
it then extracts features uh

703
00:30:01,520 --> 00:30:03,360
from the the

704
00:30:03,360 --> 00:30:07,039
embedding that that the chunks are in

705
00:30:07,039 --> 00:30:08,880
and then feeds those into a linear

706
00:30:08,880 --> 00:30:10,559
conditional random field linear

707
00:30:10,559 --> 00:30:12,480
condition conditional random fields

708
00:30:12,480 --> 00:30:14,480
model which builds on the markovian

709
00:30:14,480 --> 00:30:15,520
assumption that the next state is

710
00:30:15,520 --> 00:30:19,039
predicated only on the previous one

711
00:30:19,919 --> 00:30:22,559
we also experiment with a

712
00:30:22,559 --> 00:30:25,039
neural analog to this model which is

713
00:30:25,039 --> 00:30:26,960
kind of morally the same but it uses a

714
00:30:26,960 --> 00:30:28,640
neural network instead of

715
00:30:28,640 --> 00:30:31,919
the the linear classifier

716
00:30:32,960 --> 00:30:34,080
so we

717
00:30:34,080 --> 00:30:35,360
evaluate

718
00:30:35,360 --> 00:30:36,880
these against each other and also in

719
00:30:36,880 --> 00:30:38,880
contrast to a completely rule-based

720
00:30:38,880 --> 00:30:40,720
heuristic program which we don't expect

721
00:30:40,720 --> 00:30:42,399
to do very well because this

722
00:30:42,399 --> 00:30:44,640
doesn't learn anything um the rule-based

723
00:30:44,640 --> 00:30:47,440
system uh in fact performs poorly as we

724
00:30:47,440 --> 00:30:50,559
expect achieving uh below 35

725
00:30:50,559 --> 00:30:53,120
token level accuracy and and similarly

726
00:30:53,120 --> 00:30:56,240
bad span level accuracy uh in contrast

727
00:30:56,240 --> 00:30:56,960
the

728
00:30:56,960 --> 00:30:58,960
linear crf and neural crf models perform

729
00:30:58,960 --> 00:31:00,640
quite a bit better with the neural one

730
00:31:00,640 --> 00:31:02,320
slightly outperforming the linear one

731
00:31:02,320 --> 00:31:03,840
and you'll actually see in almost all

732
00:31:03,840 --> 00:31:05,039
the metrics we showed today that the

733
00:31:05,039 --> 00:31:06,399
neural model slightly outperforms the

734
00:31:06,399 --> 00:31:07,600
linear model which is another

735
00:31:07,600 --> 00:31:10,240
interesting result

736
00:31:10,880 --> 00:31:12,480
so now that we've

737
00:31:12,480 --> 00:31:14,880
gone from text to embedding to

738
00:31:14,880 --> 00:31:16,799
intermediary representation we now have

739
00:31:16,799 --> 00:31:18,240
these rfc documents that are expressed

740
00:31:18,240 --> 00:31:20,480
in xml like this you can imagine big

741
00:31:20,480 --> 00:31:22,080
long document entirely structured with

742
00:31:22,080 --> 00:31:24,320
xml tags that say what's happening where

743
00:31:24,320 --> 00:31:26,159
and now i need to extract to find a

744
00:31:26,159 --> 00:31:28,159
state machine from that and i want to be

745
00:31:28,159 --> 00:31:29,840
very clear this itself is not a finite

746
00:31:29,840 --> 00:31:31,440
state machine a finite state machine

747
00:31:31,440 --> 00:31:34,399
would consist of things like this actual

748
00:31:34,399 --> 00:31:36,159
transitions right i need to interpret

749
00:31:36,159 --> 00:31:39,360
the xml and extract the fsm so how am i

750
00:31:39,360 --> 00:31:40,640
going to do that

751
00:31:40,640 --> 00:31:42,240
pretty much in the most boring possible

752
00:31:42,240 --> 00:31:43,679
way i'm going to use an entirely

753
00:31:43,679 --> 00:31:46,640
heuristic algorithm that exploits the

754
00:31:46,640 --> 00:31:48,240
very structured nature of the xml to

755
00:31:48,240 --> 00:31:50,399
extract the fsm um

756
00:31:50,399 --> 00:31:52,480
and uh happy to talk about this more but

757
00:31:52,480 --> 00:31:54,080
if you want to improve on our work a

758
00:31:54,080 --> 00:31:56,000
good place to start would be on the fsm

759
00:31:56,000 --> 00:31:57,279
extraction algorithm because at the

760
00:31:57,279 --> 00:31:58,880
moment we're not using machine learning

761
00:31:58,880 --> 00:32:00,480
for that step and i think a fruitful

762
00:32:00,480 --> 00:32:03,600
thing to do would be to try that

763
00:32:03,919 --> 00:32:06,720
once we've extracted the fsm uh we want

764
00:32:06,720 --> 00:32:08,880
to know how good is it right i mean it's

765
00:32:08,880 --> 00:32:10,480
it's probably not exactly what was

766
00:32:10,480 --> 00:32:12,559
written in the text so so how close is

767
00:32:12,559 --> 00:32:13,760
it

768
00:32:13,760 --> 00:32:15,279
so we compare against one that i wrote

769
00:32:15,279 --> 00:32:16,960
by hand and to get back to the point

770
00:32:16,960 --> 00:32:18,320
about why all this is necessary i will

771
00:32:18,320 --> 00:32:20,240
tell you it took quite a long time to

772
00:32:20,240 --> 00:32:22,159
write that by hand because there are all

773
00:32:22,159 --> 00:32:23,840
sorts of subtleties when you get into a

774
00:32:23,840 --> 00:32:25,279
model checking environment of the

775
00:32:25,279 --> 00:32:26,880
ordering of events

776
00:32:26,880 --> 00:32:28,159
and the semantics of the channels that

777
00:32:28,159 --> 00:32:30,960
connect uh to two processes that are not

778
00:32:30,960 --> 00:32:32,799
captured by just the diagram that you

779
00:32:32,799 --> 00:32:35,120
find in your average rfc document um so

780
00:32:35,120 --> 00:32:36,720
we expect to have 20 transitions in our

781
00:32:36,720 --> 00:32:38,640
tcp fsm

782
00:32:38,640 --> 00:32:40,080
we

783
00:32:40,080 --> 00:32:43,519
also hand annotate or hand create an xml

784
00:32:43,519 --> 00:32:46,240
for the tcp rfc and we call that our

785
00:32:46,240 --> 00:32:48,480
gold xml and then our fsm from that is

786
00:32:48,480 --> 00:32:50,399
the gold fsm so that one should have

787
00:32:50,399 --> 00:32:52,080
perfect annotations and any bugs are

788
00:32:52,080 --> 00:32:54,240
related to either ambiguities and text

789
00:32:54,240 --> 00:32:56,320
or problems with our extraction

790
00:32:56,320 --> 00:32:59,120
algorithm um so comparing these we find

791
00:32:59,120 --> 00:33:00,000
that

792
00:33:00,000 --> 00:33:02,399
the gold fsm does uh quite well we

793
00:33:02,399 --> 00:33:03,519
define a transition as being

794
00:33:03,519 --> 00:33:05,120
approximately correct if his source

795
00:33:05,120 --> 00:33:07,360
state target state are both correct and

796
00:33:07,360 --> 00:33:08,880
at least one of the events on the label

797
00:33:08,880 --> 00:33:10,399
is correct but it might have like the

798
00:33:10,399 --> 00:33:14,559
wrong order of events like um say you

799
00:33:14,559 --> 00:33:16,720
maybe receive scene and then send back

800
00:33:16,720 --> 00:33:19,360
instead of the opposite or something um

801
00:33:19,360 --> 00:33:21,679
and and in the case of gold we find

802
00:33:21,679 --> 00:33:22,880
slightly fewer transitions than we

803
00:33:22,880 --> 00:33:24,480
expect to but almost all the ones we get

804
00:33:24,480 --> 00:33:26,320
are are approximately correct with the

805
00:33:26,320 --> 00:33:27,679
linear neural models there's quite a bit

806
00:33:27,679 --> 00:33:31,039
of noise so although we find uh most of

807
00:33:31,039 --> 00:33:32,240
the transitions we expect to find we

808
00:33:32,240 --> 00:33:33,360
also get a bunch of incorrect

809
00:33:33,360 --> 00:33:35,918
transitions

810
00:33:36,960 --> 00:33:40,880
so comparing to our skyline we find that

811
00:33:40,880 --> 00:33:42,399
another interesting result here is that

812
00:33:42,399 --> 00:33:45,120
in the very particular case of tcp the

813
00:33:45,120 --> 00:33:47,200
neural and linear models extract

814
00:33:47,200 --> 00:33:49,039
different intermediary representations

815
00:33:49,039 --> 00:33:50,320
but actually

816
00:33:50,320 --> 00:33:52,000
all that is modulated away by the finite

817
00:33:52,000 --> 00:33:53,760
state machine extraction algorithm so

818
00:33:53,760 --> 00:33:55,039
any differences in

819
00:33:55,039 --> 00:33:56,880
intermediary representations do not

820
00:33:56,880 --> 00:33:59,120
matter in this particular case in terms

821
00:33:59,120 --> 00:34:00,559
of the extracted fsm although this

822
00:34:00,559 --> 00:34:03,360
doesn't generalize

823
00:34:04,159 --> 00:34:08,159
looking at dccp we find uh deceptively

824
00:34:08,159 --> 00:34:09,918
more transitions than we did with tcp

825
00:34:09,918 --> 00:34:12,079
but we expect substantially more so

826
00:34:12,079 --> 00:34:14,320
fractionally less are found we expect to

827
00:34:14,320 --> 00:34:16,320
have 34 total transitions with the gold

828
00:34:16,320 --> 00:34:18,480
we only get 17. as you can see the

829
00:34:18,480 --> 00:34:20,560
linear and neural models

830
00:34:20,560 --> 00:34:23,119
do not perform as well as gold

831
00:34:23,119 --> 00:34:24,879
but again neural slightly outperforms

832
00:34:24,879 --> 00:34:27,279
linear

833
00:34:27,679 --> 00:34:29,599
okay so um

834
00:34:29,599 --> 00:34:31,119
let's talk about kind of

835
00:34:31,119 --> 00:34:32,879
why we miss things because as you just

836
00:34:32,879 --> 00:34:34,159
saw in these graphs we missed a

837
00:34:34,159 --> 00:34:36,800
substantial number of transitions

838
00:34:36,800 --> 00:34:38,639
so there's two problems one is missing

839
00:34:38,639 --> 00:34:40,159
transitions the other is incorrect

840
00:34:40,159 --> 00:34:41,760
transitions and we'll start with missing

841
00:34:41,760 --> 00:34:44,399
transitions here's an example from the

842
00:34:44,399 --> 00:34:46,879
dccp rfc

843
00:34:46,879 --> 00:34:49,199
for a transition going from close weight

844
00:34:49,199 --> 00:34:52,879
to last stack in which you send a fee

845
00:34:52,879 --> 00:34:54,399
this text contains mention of the

846
00:34:54,399 --> 00:34:57,040
message that was sent to the fiend

847
00:34:57,040 --> 00:34:58,640
and the state that you started in the

848
00:34:58,640 --> 00:34:59,760
close weight

849
00:34:59,760 --> 00:35:01,280
but it does not mention the state that

850
00:35:01,280 --> 00:35:03,280
you go to last stack to find that you

851
00:35:03,280 --> 00:35:04,640
need to search like i think four

852
00:35:04,640 --> 00:35:06,400
paragraphs up in the document and find

853
00:35:06,400 --> 00:35:08,320
something indented back three lines and

854
00:35:08,320 --> 00:35:10,000
it would implicitly tell you that it was

855
00:35:10,000 --> 00:35:11,359
last act but there's really no way that

856
00:35:11,359 --> 00:35:12,880
a computer could figure that out and

857
00:35:12,880 --> 00:35:14,560
even a human being like myself reading

858
00:35:14,560 --> 00:35:15,680
this would have to search around for a

859
00:35:15,680 --> 00:35:17,920
while to try to figure it out um

860
00:35:17,920 --> 00:35:19,359
also if we wrote a rule to tell the

861
00:35:19,359 --> 00:35:21,040
computer to look that far back it would

862
00:35:21,040 --> 00:35:23,040
cause problems when we parse other parts

863
00:35:23,040 --> 00:35:24,800
of the document so this is a good

864
00:35:24,800 --> 00:35:26,400
example of why you can have missing

865
00:35:26,400 --> 00:35:29,119
transitions when you extract from

866
00:35:29,119 --> 00:35:31,839
an rfc

867
00:35:32,000 --> 00:35:34,480
so we do an evaluation and try to figure

868
00:35:34,480 --> 00:35:36,720
out why it is that we miss transitions

869
00:35:36,720 --> 00:35:38,320
and we we do this by actually manually

870
00:35:38,320 --> 00:35:39,599
inspecting every single missing

871
00:35:39,599 --> 00:35:40,800
transition

872
00:35:40,800 --> 00:35:44,480
we find that in the case of tcp um

873
00:35:44,480 --> 00:35:46,240
most of the missing transitions are due

874
00:35:46,240 --> 00:35:48,560
to omissions or ambiguities in the text

875
00:35:48,560 --> 00:35:50,000
the thing i just showed you i would

876
00:35:50,000 --> 00:35:51,920
consider to be an omission or ambiguity

877
00:35:51,920 --> 00:35:53,760
i think it's ambiguous because

878
00:35:53,760 --> 00:35:55,359
you have to search in other parts of the

879
00:35:55,359 --> 00:35:56,560
document that are pretty far away

880
00:35:56,560 --> 00:35:58,079
paragraphs away to figure out where the

881
00:35:58,079 --> 00:36:00,400
transition's supposed to go

882
00:36:00,400 --> 00:36:01,599
however there's also a number of

883
00:36:01,599 --> 00:36:03,680
extraction errors for tcp in contrast

884
00:36:03,680 --> 00:36:04,720
with

885
00:36:04,720 --> 00:36:07,119
dccp we also get some prediction errors

886
00:36:07,119 --> 00:36:08,960
which is interesting

887
00:36:08,960 --> 00:36:11,280
but that might just be a scaling aspect

888
00:36:11,280 --> 00:36:12,480
because there are so many more

889
00:36:12,480 --> 00:36:14,400
transitions in dccp so who knows if you

890
00:36:14,400 --> 00:36:16,320
guys added like 20 more transitions to

891
00:36:16,320 --> 00:36:17,680
tcp maybe i would get some prediction

892
00:36:17,680 --> 00:36:21,040
errors with tcp i'm not really sure

893
00:36:21,520 --> 00:36:23,440
uh it should be noted we missed very few

894
00:36:23,440 --> 00:36:25,359
for tcp

895
00:36:25,359 --> 00:36:28,800
and additionally this result with gold

896
00:36:28,800 --> 00:36:31,119
implies that the dccp specification is

897
00:36:31,119 --> 00:36:32,560
substantially more ambiguous than the

898
00:36:32,560 --> 00:36:37,280
tcp one because the uh fraction of

899
00:36:37,280 --> 00:36:38,960
of missing transitions that are due to

900
00:36:38,960 --> 00:36:40,560
omissions or ambiguity

901
00:36:40,560 --> 00:36:41,920
is substantially larger than the

902
00:36:41,920 --> 00:36:43,520
fraction that's due to extraction errors

903
00:36:43,520 --> 00:36:45,680
in contrast to the same analysis with

904
00:36:45,680 --> 00:36:48,160
the gold tcp

905
00:36:48,160 --> 00:36:49,680
uh uh

906
00:36:49,680 --> 00:36:52,160
fsm right so uh in both these cases

907
00:36:52,160 --> 00:36:53,599
we're using our skyline intermediary

908
00:36:53,599 --> 00:36:55,440
representation so any problems are at

909
00:36:55,440 --> 00:36:59,280
the extraction level or in the spec

910
00:36:59,440 --> 00:37:01,839
and again the the neural model is is

911
00:37:01,839 --> 00:37:04,480
slightly better

912
00:37:05,119 --> 00:37:07,440
next we look at incorrect transitions so

913
00:37:07,440 --> 00:37:08,800
i've told you about missing transitions

914
00:37:08,800 --> 00:37:10,400
and i've said that essentially they can

915
00:37:10,400 --> 00:37:11,680
happen for multiple reasons but they

916
00:37:11,680 --> 00:37:13,440
mostly happen because of omissions or

917
00:37:13,440 --> 00:37:15,520
ambiguities in the text

918
00:37:15,520 --> 00:37:16,720
another question would be what about

919
00:37:16,720 --> 00:37:18,240
when we make a mistake when we extract a

920
00:37:18,240 --> 00:37:19,920
transition that's just completely off it

921
00:37:19,920 --> 00:37:21,680
has the wrong start state or the wrong

922
00:37:21,680 --> 00:37:24,079
target state both um or none of the

923
00:37:24,079 --> 00:37:26,320
correct events on the transition uh in

924
00:37:26,320 --> 00:37:28,160
the case of tcp

925
00:37:28,160 --> 00:37:29,599
they're primarily caused by prediction

926
00:37:29,599 --> 00:37:31,359
errors so this would be something we can

927
00:37:31,359 --> 00:37:33,200
improve on right

928
00:37:33,200 --> 00:37:34,880
the prediction errors are are part of

929
00:37:34,880 --> 00:37:37,839
our and their their problems with our

930
00:37:37,839 --> 00:37:39,359
methodology so our methodology can be

931
00:37:39,359 --> 00:37:40,800
improved to not have so many prediction

932
00:37:40,800 --> 00:37:42,480
errors uh potentially even just by

933
00:37:42,480 --> 00:37:46,960
training on more rfcs to be honest um

934
00:37:46,960 --> 00:37:50,160
in dccp however looking at the gold we

935
00:37:50,160 --> 00:37:51,760
find that a substantial number of

936
00:37:51,760 --> 00:37:54,000
incorrectly extracted transitions are

937
00:37:54,000 --> 00:37:55,839
due to omissions or ambiguities in the

938
00:37:55,839 --> 00:37:57,280
text

939
00:37:57,280 --> 00:37:59,359
and so this again highlights that the

940
00:37:59,359 --> 00:38:01,760
dccp rfc uh

941
00:38:01,760 --> 00:38:03,680
experimentally appears to be more

942
00:38:03,680 --> 00:38:06,640
ambiguous than the tcp1 along numerous

943
00:38:06,640 --> 00:38:09,759
metrics that we can measure

944
00:38:11,280 --> 00:38:14,400
we underperform on dccp

945
00:38:14,400 --> 00:38:15,520
in terms of

946
00:38:15,520 --> 00:38:18,520
what

947
00:38:19,839 --> 00:38:22,000
how many transitions we can extract um

948
00:38:22,000 --> 00:38:23,839
and and conversely how many errors we

949
00:38:23,839 --> 00:38:26,000
have and again this suggests that dccp

950
00:38:26,000 --> 00:38:28,640
is more complex

951
00:38:29,520 --> 00:38:31,680
okay so now i've told you uh end to end

952
00:38:31,680 --> 00:38:34,160
that we have a way to automatically read

953
00:38:34,160 --> 00:38:36,560
an rfc document and extract a finite

954
00:38:36,560 --> 00:38:38,400
state machine and i've shown you that

955
00:38:38,400 --> 00:38:39,599
the final state machine has a number of

956
00:38:39,599 --> 00:38:41,520
errors including missing transitions and

957
00:38:41,520 --> 00:38:43,599
also transitions that are wrong

958
00:38:43,599 --> 00:38:45,359
and i'm going to claim perhaps

959
00:38:45,359 --> 00:38:47,440
scandalously that despite these errors

960
00:38:47,440 --> 00:38:49,359
it is good enough to do something useful

961
00:38:49,359 --> 00:38:50,880
uh to me that useful thing is going to

962
00:38:50,880 --> 00:38:53,599
be attack synthesis so um that means the

963
00:38:53,599 --> 00:38:55,119
automatic generation of attacks against

964
00:38:55,119 --> 00:38:57,520
the protocol but you could also view

965
00:38:57,520 --> 00:38:59,839
this as the automatic uh discovery of

966
00:38:59,839 --> 00:39:02,560
potential bugs

967
00:39:03,680 --> 00:39:04,400
so

968
00:39:04,400 --> 00:39:06,160
uh i used an attack synthesis tool

969
00:39:06,160 --> 00:39:08,079
called korg which i created which is why

970
00:39:08,079 --> 00:39:10,880
i used it uh i presented korg at safe

971
00:39:10,880 --> 00:39:13,440
comp 2020 which was in lisbon portugal

972
00:39:13,440 --> 00:39:14,960
but i was over the internet because of

973
00:39:14,960 --> 00:39:16,800
covet unfortunately so hopefully next

974
00:39:16,800 --> 00:39:18,720
time we'll get to go to lisbon um cork

975
00:39:18,720 --> 00:39:20,079
takes his input and extracted finite

976
00:39:20,079 --> 00:39:21,119
state machine like the one we just

977
00:39:21,119 --> 00:39:22,880
generated uh

978
00:39:22,880 --> 00:39:25,119
a linear temporal logic property this is

979
00:39:25,119 --> 00:39:26,720
just a formalization of what it means

980
00:39:26,720 --> 00:39:28,400
for the state machine to

981
00:39:28,400 --> 00:39:30,480
be correct so an example of a property

982
00:39:30,480 --> 00:39:32,079
would be that

983
00:39:32,079 --> 00:39:34,560
there's no active close

984
00:39:34,560 --> 00:39:36,800
in dccp so i could have a property

985
00:39:36,800 --> 00:39:38,320
saying you never have both peers closing

986
00:39:38,320 --> 00:39:40,480
at once

987
00:39:40,480 --> 00:39:42,560
it then creates a system in which two

988
00:39:42,560 --> 00:39:44,079
pures are communicating over a

989
00:39:44,079 --> 00:39:46,240
vulnerable channel so it injects a

990
00:39:46,240 --> 00:39:47,599
vulnerability into the channel between

991
00:39:47,599 --> 00:39:49,839
them a man in the middle and it asks if

992
00:39:49,839 --> 00:39:51,760
in that threat model uh the property

993
00:39:51,760 --> 00:39:54,000
could be violated so we're not asking if

994
00:39:54,000 --> 00:39:55,440
the protocol's correct on its own we

995
00:39:55,440 --> 00:39:56,800
kind of assume it is in fact we don't

996
00:39:56,800 --> 00:39:58,400
even look at properties unless uh

997
00:39:58,400 --> 00:40:00,480
they're satisfied by the prop the model

998
00:40:00,480 --> 00:40:02,320
in isolation but we want to know

999
00:40:02,320 --> 00:40:04,800
under attack is this still satisfied the

1000
00:40:04,800 --> 00:40:06,720
spin model checker reduces this to a

1001
00:40:06,720 --> 00:40:08,800
language emptiness problem uh by

1002
00:40:08,800 --> 00:40:10,800
intersection of a book automaton with

1003
00:40:10,800 --> 00:40:13,040
the system but basically it does fancy

1004
00:40:13,040 --> 00:40:14,240
formal methods

1005
00:40:14,240 --> 00:40:16,880
from the 80s and it says no

1006
00:40:16,880 --> 00:40:18,480
the system is not correct when it's

1007
00:40:18,480 --> 00:40:20,079
under attack here's a counterexample

1008
00:40:20,079 --> 00:40:22,079
which is just a sequence of events

1009
00:40:22,079 --> 00:40:23,440
that the system goes through in which

1010
00:40:23,440 --> 00:40:25,040
the property's violated

1011
00:40:25,040 --> 00:40:27,040
finally cork takes that counter-example

1012
00:40:27,040 --> 00:40:29,040
and turns it into an attacker program

1013
00:40:29,040 --> 00:40:31,119
that simply replays that attack so it's

1014
00:40:31,119 --> 00:40:34,000
a pretty simple approach

1015
00:40:34,640 --> 00:40:36,480
we looked at two case studies tcp and

1016
00:40:36,480 --> 00:40:40,160
dccp uh the fsms shown here are made by

1017
00:40:40,160 --> 00:40:42,000
me and have been extensively model

1018
00:40:42,000 --> 00:40:43,599
checked for the number of properties and

1019
00:40:43,599 --> 00:40:45,760
shown to satisfy all of them so these

1020
00:40:45,760 --> 00:40:47,760
can be viewed as perhaps more canonical

1021
00:40:47,760 --> 00:40:48,800
than the

1022
00:40:48,800 --> 00:40:50,400
fsms that you'll find in the rfc

1023
00:40:50,400 --> 00:40:52,720
documents or in any number of security

1024
00:40:52,720 --> 00:40:54,720
papers where they do maybe graph guided

1025
00:40:54,720 --> 00:40:55,920
search but they don't really care that

1026
00:40:55,920 --> 00:40:57,440
they satisfy formal mathematical

1027
00:40:57,440 --> 00:40:59,760
properties

1028
00:40:59,760 --> 00:41:02,000
for tcp we use four properties the first

1029
00:41:02,000 --> 00:41:04,240
three came from my paper when i

1030
00:41:04,240 --> 00:41:06,640
presented the korg tool where i also

1031
00:41:06,640 --> 00:41:08,560
used tcp as a case study and the fourth

1032
00:41:08,560 --> 00:41:10,560
was written by ben weintraub

1033
00:41:10,560 --> 00:41:12,400
all four though are written based off a

1034
00:41:12,400 --> 00:41:15,520
close reading of the tcp rfc

1035
00:41:15,520 --> 00:41:16,960
likewise we also have four properties

1036
00:41:16,960 --> 00:41:18,640
for dccp i don't think these are

1037
00:41:18,640 --> 00:41:19,839
incredibly interesting properties so

1038
00:41:19,839 --> 00:41:21,119
i'll kind of skip them but i'm happy to

1039
00:41:21,119 --> 00:41:22,400
talk about them afterward if people have

1040
00:41:22,400 --> 00:41:24,720
questions

1041
00:41:25,200 --> 00:41:27,200
we generate a number of attacks this is

1042
00:41:27,200 --> 00:41:28,480
kind of a confusing table so i'm going

1043
00:41:28,480 --> 00:41:31,040
to try to break it down into sub points

1044
00:41:31,040 --> 00:41:33,280
essentially with tcp there's only one

1045
00:41:33,280 --> 00:41:35,200
property with which we are successfully

1046
00:41:35,200 --> 00:41:36,880
able to generate attacks using any of

1047
00:41:36,880 --> 00:41:38,640
our extracted finite state machines we

1048
00:41:38,640 --> 00:41:40,640
generate very few attacks with tcp but

1049
00:41:40,640 --> 00:41:42,240
all of the attacks work meaning all of

1050
00:41:42,240 --> 00:41:43,760
them are confirmed on my handwritten

1051
00:41:43,760 --> 00:41:46,000
model so there's no false positives in

1052
00:41:46,000 --> 00:41:47,839
contrast with dccp we're able to

1053
00:41:47,839 --> 00:41:49,200
generate attacks using all four

1054
00:41:49,200 --> 00:41:52,400
properties um however we get some false

1055
00:41:52,400 --> 00:41:54,480
positives so for example with the third

1056
00:41:54,480 --> 00:41:57,520
property i wrote for dccp using the fsm

1057
00:41:57,520 --> 00:41:58,720
that was extracted with our linear

1058
00:41:58,720 --> 00:42:00,640
conditional random fields model we

1059
00:42:00,640 --> 00:42:02,960
generate 13 attacks and all 13 are false

1060
00:42:02,960 --> 00:42:05,200
positives so uh

1061
00:42:05,200 --> 00:42:06,880
again there's sort of a noise to signal

1062
00:42:06,880 --> 00:42:09,440
ratio thing here where i'm generating

1063
00:42:09,440 --> 00:42:11,839
more attacks with dccp but there's more

1064
00:42:11,839 --> 00:42:13,920
errors i generate very few with tcp but

1065
00:42:13,920 --> 00:42:16,319
there's zero errors again to me this

1066
00:42:16,319 --> 00:42:19,200
seems to indicate more ambiguity or more

1067
00:42:19,200 --> 00:42:22,000
complexity in the dccp rfc because

1068
00:42:22,000 --> 00:42:23,520
errors in the attack synthesis step are

1069
00:42:23,520 --> 00:42:25,119
caused by errors in the finite state

1070
00:42:25,119 --> 00:42:26,079
machine

1071
00:42:26,079 --> 00:42:27,599
so this is fairly predictable for the

1072
00:42:27,599 --> 00:42:31,800
results i showed you up until this point

1073
00:42:32,400 --> 00:42:33,839
okay when i say the word attack it can

1074
00:42:33,839 --> 00:42:35,760
mean any number of things and people use

1075
00:42:35,760 --> 00:42:37,280
this word rather liberally so i want to

1076
00:42:37,280 --> 00:42:38,640
give some examples what i mean by an

1077
00:42:38,640 --> 00:42:40,160
attack so you know what exactly i'm

1078
00:42:40,160 --> 00:42:42,480
saying one attack would be to inject an

1079
00:42:42,480 --> 00:42:45,359
act to the first peer and a tcp active

1080
00:42:45,359 --> 00:42:47,599
passive establishment routine in order

1081
00:42:47,599 --> 00:42:50,079
to if i remember correctly get that pure

1082
00:42:50,079 --> 00:42:52,359
stuck and seen received because it can

1083
00:42:52,359 --> 00:42:54,480
non-deterministically decide to exit but

1084
00:42:54,480 --> 00:42:56,240
if it doesn't decide to exit for example

1085
00:42:56,240 --> 00:42:57,599
if it's configured to have a very long

1086
00:42:57,599 --> 00:42:59,440
timeout time then it could stay there

1087
00:42:59,440 --> 00:43:02,400
forever um or essentially forever uh

1088
00:43:02,400 --> 00:43:04,160
they may sound a little silly but if you

1089
00:43:04,160 --> 00:43:06,000
talk to samuel giro at lincoln labs

1090
00:43:06,000 --> 00:43:07,440
he'll tell you that he's found tcp

1091
00:43:07,440 --> 00:43:08,880
implementations in the wild to have this

1092
00:43:08,880 --> 00:43:12,079
bug and in fact i found stack exchange

1093
00:43:12,079 --> 00:43:14,000
queries even experts exchange queries

1094
00:43:14,000 --> 00:43:15,680
from people who had this problem where

1095
00:43:15,680 --> 00:43:17,440
their tcp connections hung forever

1096
00:43:17,440 --> 00:43:18,640
because they'd configured the timeout

1097
00:43:18,640 --> 00:43:20,720
incorrectly another example which is

1098
00:43:20,720 --> 00:43:22,960
much more complicated which we also find

1099
00:43:22,960 --> 00:43:25,040
would be to elaborately spoof each peer

1100
00:43:25,040 --> 00:43:27,440
and a dccp connection in order to guide

1101
00:43:27,440 --> 00:43:29,680
the other one into close rack

1102
00:43:29,680 --> 00:43:31,280
this is sort of a silly attack because

1103
00:43:31,280 --> 00:43:32,480
i'm not really sure

1104
00:43:32,480 --> 00:43:34,319
what like an elite russian hacker would

1105
00:43:34,319 --> 00:43:37,119
want with this however it is a violation

1106
00:43:37,119 --> 00:43:38,160
of a correctness property because

1107
00:43:38,160 --> 00:43:40,560
there's no active active close in dccp

1108
00:43:40,560 --> 00:43:41,920
so if i can induce an active active

1109
00:43:41,920 --> 00:43:43,359
close maybe i can cause a deadlock or

1110
00:43:43,359 --> 00:43:44,800
something

1111
00:43:44,800 --> 00:43:46,560
and i want to point out this interesting

1112
00:43:46,560 --> 00:43:48,400
point that because our approach is based

1113
00:43:48,400 --> 00:43:50,560
on model checking we'll find many many

1114
00:43:50,560 --> 00:43:52,720
variants on kind of the same attack and

1115
00:43:52,720 --> 00:43:55,520
um so indeed we find many variants on

1116
00:43:55,520 --> 00:43:57,440
this attack and i can show you dozens of

1117
00:43:57,440 --> 00:43:58,720
different ways to essentially do the

1118
00:43:58,720 --> 00:44:01,118
same thing

1119
00:44:01,920 --> 00:44:02,960
i want to conclude with future

1120
00:44:02,960 --> 00:44:05,119
directions so um

1121
00:44:05,119 --> 00:44:06,319
the research i showed you today was

1122
00:44:06,319 --> 00:44:08,560
presented at uh s p to a security

1123
00:44:08,560 --> 00:44:11,599
audience and um uh you know there's kind

1124
00:44:11,599 --> 00:44:12,880
of a certain set of things that interest

1125
00:44:12,880 --> 00:44:14,800
them in terms of breaking protocols but

1126
00:44:14,800 --> 00:44:16,800
i think for you you may have different

1127
00:44:16,800 --> 00:44:18,000
interests in terms of maybe building

1128
00:44:18,000 --> 00:44:19,200
protocols and won't be broken from the

1129
00:44:19,200 --> 00:44:22,560
first uh first place so it'd be nice if

1130
00:44:22,560 --> 00:44:23,599
we could automatically highlight

1131
00:44:23,599 --> 00:44:25,200
omissions and ambiguities in the rfc

1132
00:44:25,200 --> 00:44:27,440
text and i think that we're part of the

1133
00:44:27,440 --> 00:44:29,599
way there if we can kind of take our

1134
00:44:29,599 --> 00:44:31,920
tool and make it say i'm kind of

1135
00:44:31,920 --> 00:44:33,440
confused about how to interpret this

1136
00:44:33,440 --> 00:44:35,359
piece of text could you clarify it that

1137
00:44:35,359 --> 00:44:37,680
might be a useful

1138
00:44:37,680 --> 00:44:39,680
functionality for rfc authors to be able

1139
00:44:39,680 --> 00:44:41,440
to know when something they wrote is not

1140
00:44:41,440 --> 00:44:43,280
entirely clear

1141
00:44:43,280 --> 00:44:44,480
another thing i'd like to do is

1142
00:44:44,480 --> 00:44:47,280
automatically suggest bug fixes so if i

1143
00:44:47,280 --> 00:44:48,480
extract the finance state machine and

1144
00:44:48,480 --> 00:44:50,240
the rfc author looks at it and says yeah

1145
00:44:50,240 --> 00:44:51,280
actually that looks correct i think

1146
00:44:51,280 --> 00:44:53,119
that's what i intended to describe and

1147
00:44:53,119 --> 00:44:54,960
then i find an attack against it well

1148
00:44:54,960 --> 00:44:57,119
it'd be nice if i could use some uh

1149
00:44:57,119 --> 00:44:58,400
synthesis techniques from the formal

1150
00:44:58,400 --> 00:44:59,760
methods community to automatically

1151
00:44:59,760 --> 00:45:01,680
suggest a patch that would resolve that

1152
00:45:01,680 --> 00:45:03,040
problem and we actually have an

1153
00:45:03,040 --> 00:45:04,240
undergrad working on that problem with

1154
00:45:04,240 --> 00:45:06,079
us right now which is very exciting

1155
00:45:06,079 --> 00:45:07,200
um

1156
00:45:07,200 --> 00:45:08,640
a completely different

1157
00:45:08,640 --> 00:45:10,400
kind of vein of research that we'd like

1158
00:45:10,400 --> 00:45:11,760
to undergo is to extract logical

1159
00:45:11,760 --> 00:45:13,359
properties right now i'm writing those

1160
00:45:13,359 --> 00:45:14,960
properties from hand

1161
00:45:14,960 --> 00:45:16,800
that's not easy writing properties from

1162
00:45:16,800 --> 00:45:17,760
hand is

1163
00:45:17,760 --> 00:45:19,040
maybe not quite as hard as writing

1164
00:45:19,040 --> 00:45:20,560
models by hand but they're both much

1165
00:45:20,560 --> 00:45:22,400
more difficult than they seem uh and

1166
00:45:22,400 --> 00:45:23,920
it's very easy to write a property that

1167
00:45:23,920 --> 00:45:25,760
for example is vacuously true and then

1168
00:45:25,760 --> 00:45:27,440
you really can't do anything with it um

1169
00:45:27,440 --> 00:45:28,960
so there's a lot of logical subtleties

1170
00:45:28,960 --> 00:45:30,480
in these things

1171
00:45:30,480 --> 00:45:32,000
we'd like to offer support for secure

1172
00:45:32,000 --> 00:45:33,680
protocols there's a lot of kind of

1173
00:45:33,680 --> 00:45:35,280
interesting problems to this like

1174
00:45:35,280 --> 00:45:36,960
capturing the arithmetic that goes into

1175
00:45:36,960 --> 00:45:38,960
the cryptography and such a protocol uh

1176
00:45:38,960 --> 00:45:41,280
capturing secrecy requirements and we

1177
00:45:41,280 --> 00:45:42,400
might have to take a different approach

1178
00:45:42,400 --> 00:45:44,000
in terms of the back end for example

1179
00:45:44,000 --> 00:45:46,560
maybe relying on pro verif or tamarin

1180
00:45:46,560 --> 00:45:48,480
instead of uh quark

1181
00:45:48,480 --> 00:45:49,680
um

1182
00:45:49,680 --> 00:45:51,280
i think that finally it would be really

1183
00:45:51,280 --> 00:45:52,640
nice if we could take all of these

1184
00:45:52,640 --> 00:45:54,079
different ideas and turn them into some

1185
00:45:54,079 --> 00:45:56,000
sort of cohesive software suite for an

1186
00:45:56,000 --> 00:45:58,480
rfc author in the loop so an rfc author

1187
00:45:58,480 --> 00:46:01,040
or authors are writing an rfc it would

1188
00:46:01,040 --> 00:46:03,440
be nice if they could run our code and

1189
00:46:03,440 --> 00:46:05,599
be told hey this seems ambiguous maybe

1190
00:46:05,599 --> 00:46:08,160
you could clarify this uh and and they

1191
00:46:08,160 --> 00:46:09,680
could kind of have a feedback loop to do

1192
00:46:09,680 --> 00:46:11,040
so until

1193
00:46:11,040 --> 00:46:13,280
they automatically get an unambiguous

1194
00:46:13,280 --> 00:46:15,599
piece of text uh and you could even

1195
00:46:15,599 --> 00:46:17,440
imagine um

1196
00:46:17,440 --> 00:46:19,440
perhaps mixing formal language with the

1197
00:46:19,440 --> 00:46:21,440
english to make it so that if the rfc

1198
00:46:21,440 --> 00:46:22,480
author actually likes the way they

1199
00:46:22,480 --> 00:46:24,160
describe something in english they could

1200
00:46:24,160 --> 00:46:25,680
just give little formal hints about how

1201
00:46:25,680 --> 00:46:26,880
to change it

1202
00:46:26,880 --> 00:46:28,079
and that's it with that i'll take any

1203
00:46:28,079 --> 00:46:31,040
questions thank you very much

1204
00:46:31,610 --> 00:46:38,570
[Applause]

1205
00:46:41,359 --> 00:46:42,400
it's okay

1206
00:46:42,400 --> 00:46:44,720
okay all right thank you very much

1207
00:46:44,720 --> 00:46:47,359
excellent talk uh i see a couple of

1208
00:46:47,359 --> 00:46:49,920
people in the queue

1209
00:46:49,920 --> 00:46:51,760
um

1210
00:46:51,760 --> 00:46:53,440
who's first uh

1211
00:46:53,440 --> 00:46:54,560
ishii

1212
00:46:54,560 --> 00:46:57,119
nishida

1213
00:47:00,079 --> 00:47:02,319
web service so i think this is very

1214
00:47:02,319 --> 00:47:04,240
interesting research thank you so much

1215
00:47:04,240 --> 00:47:05,440
and

1216
00:47:05,440 --> 00:47:08,000
then i this might be a part of a huge

1217
00:47:08,000 --> 00:47:10,400
direction but uh one of the complicated

1218
00:47:10,400 --> 00:47:13,280
things for tcp is congestion control and

1219
00:47:13,280 --> 00:47:15,520
loss recovery yeah and then

1220
00:47:15,520 --> 00:47:16,560
i'm

1221
00:47:16,560 --> 00:47:19,599
wondering if we you know

1222
00:47:19,599 --> 00:47:21,280
you can apply this technology to the

1223
00:47:21,280 --> 00:47:23,119
congestion control gross recovery and

1224
00:47:23,119 --> 00:47:25,440
how it's promising that's what i'm

1225
00:47:25,440 --> 00:47:27,440
curious about yeah that's a fantastic

1226
00:47:27,440 --> 00:47:28,880
question um

1227
00:47:28,880 --> 00:47:30,880
my current project is congestion control

1228
00:47:30,880 --> 00:47:34,319
uh however um i have not been applying

1229
00:47:34,319 --> 00:47:36,160
nlp to the problem i've been

1230
00:47:36,160 --> 00:47:38,400
manually modeling a

1231
00:47:38,400 --> 00:47:40,240
congestion control algorithm of interest

1232
00:47:40,240 --> 00:47:42,000
i think that congestion control is

1233
00:47:42,000 --> 00:47:44,079
pretty complicated and it would be

1234
00:47:44,079 --> 00:47:45,760
fantastic if we could

1235
00:47:45,760 --> 00:47:48,559
partially automate the modeling um but

1236
00:47:48,559 --> 00:47:50,400
i'm trying to get an intuition for the

1237
00:47:50,400 --> 00:47:51,839
modeling to begin with by doing it by

1238
00:47:51,839 --> 00:47:54,240
hand before we consider automating it

1239
00:47:54,240 --> 00:47:55,760
but i mean you basically predicted the

1240
00:47:55,760 --> 00:47:57,119
next year in my life so yeah that's

1241
00:47:57,119 --> 00:47:59,040
that's that's what i'm doing thanks so

1242
00:47:59,040 --> 00:48:02,000
much thank you

1243
00:48:04,960 --> 00:48:07,200
all right thank you uh michael

1244
00:48:07,200 --> 00:48:08,079
um

1245
00:48:08,079 --> 00:48:10,240
you said you use um

1246
00:48:10,240 --> 00:48:12,400
you analyze the text to get the finite

1247
00:48:12,400 --> 00:48:13,760
state machines

1248
00:48:13,760 --> 00:48:14,210
um

1249
00:48:14,210 --> 00:48:15,520
[Music]

1250
00:48:15,520 --> 00:48:18,880
most of the transport rfcs contain a

1251
00:48:18,880 --> 00:48:20,880
graphical representation of the finite

1252
00:48:20,880 --> 00:48:22,240
state machine

1253
00:48:22,240 --> 00:48:22,830
so

1254
00:48:22,830 --> 00:48:24,559
[Music]

1255
00:48:24,559 --> 00:48:28,240
did you also consider using that or

1256
00:48:28,240 --> 00:48:31,440
is that too hard or too weak or

1257
00:48:31,440 --> 00:48:33,280
that's a great question

1258
00:48:33,280 --> 00:48:35,119
so uh i did

1259
00:48:35,119 --> 00:48:36,720
write a little toy script that could

1260
00:48:36,720 --> 00:48:40,559
read um the the ascii diagrams and rfcs

1261
00:48:40,559 --> 00:48:41,839
and got it to work on quite a few of

1262
00:48:41,839 --> 00:48:43,119
them but there was nothing very

1263
00:48:43,119 --> 00:48:45,359
scientific about it i just kind of wrote

1264
00:48:45,359 --> 00:48:47,760
a little heuristic python script

1265
00:48:47,760 --> 00:48:49,119
i've spoken to maria about this and

1266
00:48:49,119 --> 00:48:51,200
apparently maria did the natural

1267
00:48:51,200 --> 00:48:52,720
language processing for the most part on

1268
00:48:52,720 --> 00:48:54,880
this project i did all the fm

1269
00:48:54,880 --> 00:48:56,880
maria says that there is kind of a field

1270
00:48:56,880 --> 00:48:59,119
of nlp that deals specifically with

1271
00:48:59,119 --> 00:49:01,440
diagrams and figures and it could be

1272
00:49:01,440 --> 00:49:03,040
applied to this type of problem which is

1273
00:49:03,040 --> 00:49:04,880
an interesting approach i will tell you

1274
00:49:04,880 --> 00:49:06,559
however that the fsm diagrams are

1275
00:49:06,559 --> 00:49:08,240
missing a bunch of information for

1276
00:49:08,240 --> 00:49:10,000
example if i recall correctly i think

1277
00:49:10,000 --> 00:49:12,720
that the tcp fsm diagram is missing a

1278
00:49:12,720 --> 00:49:14,079
core component of the active active

1279
00:49:14,079 --> 00:49:16,000
close routine

1280
00:49:16,000 --> 00:49:18,319
and in the dccp one i think that there

1281
00:49:18,319 --> 00:49:19,839
was again

1282
00:49:19,839 --> 00:49:21,599
oh you know what i think in dccp there's

1283
00:49:21,599 --> 00:49:22,960
a transition that's shown in the diagram

1284
00:49:22,960 --> 00:49:24,640
but not in the text there's a bunch of

1285
00:49:24,640 --> 00:49:26,079
places where the diagrams are missing

1286
00:49:26,079 --> 00:49:27,760
things there's also this problem when

1287
00:49:27,760 --> 00:49:29,440
protocols have multiple diagrams that

1288
00:49:29,440 --> 00:49:31,599
have to be somehow merged like if you

1289
00:49:31,599 --> 00:49:33,119
look at ltp which is a pretty

1290
00:49:33,119 --> 00:49:34,400
interesting protocol that's used in

1291
00:49:34,400 --> 00:49:36,559
space exploration it has i think like

1292
00:49:36,559 --> 00:49:38,800
seven or eight fsm diagrams in it that

1293
00:49:38,800 --> 00:49:39,680
all

1294
00:49:39,680 --> 00:49:41,920
interact in uh i would say

1295
00:49:41,920 --> 00:49:44,880
mathematically ambiguous ways even dccp

1296
00:49:44,880 --> 00:49:46,800
has multiple fsm diagrams because it has

1297
00:49:46,800 --> 00:49:48,960
one for the state changing stable and

1298
00:49:48,960 --> 00:49:50,720
unstable and then another one for the

1299
00:49:50,720 --> 00:49:52,800
communication so

1300
00:49:52,800 --> 00:49:54,880
diagrams are interesting i'm not

1301
00:49:54,880 --> 00:49:56,480
personally working on that problem i do

1302
00:49:56,480 --> 00:49:58,079
think it merits attention but i don't

1303
00:49:58,079 --> 00:49:59,520
think is a golden ticket to

1304
00:49:59,520 --> 00:50:01,680
automatically getting

1305
00:50:01,680 --> 00:50:03,920
good fsm from rfc documents

1306
00:50:03,920 --> 00:50:05,760
no but it would be very good but it

1307
00:50:05,760 --> 00:50:07,200
would be very good if there is a

1308
00:50:07,200 --> 00:50:09,520
disagreement between your fsm

1309
00:50:09,520 --> 00:50:11,520
representation and the one shown on the

1310
00:50:11,520 --> 00:50:12,559
graphic

1311
00:50:12,559 --> 00:50:13,280
to

1312
00:50:13,280 --> 00:50:15,119
to make that available to make this

1313
00:50:15,119 --> 00:50:16,640
difference available to the authors

1314
00:50:16,640 --> 00:50:19,760
because that might not be intended

1315
00:50:19,760 --> 00:50:21,440
yeah that's a good point we we mentioned

1316
00:50:21,440 --> 00:50:23,280
these things in our paper but i'd also

1317
00:50:23,280 --> 00:50:25,040
be happy to summarize some of the

1318
00:50:25,040 --> 00:50:26,960
differences uh in an email to whoever

1319
00:50:26,960 --> 00:50:28,880
would find that interesting so maybe

1320
00:50:28,880 --> 00:50:30,800
offline you can help me know who would

1321
00:50:30,800 --> 00:50:32,800
like to know about things i found in the

1322
00:50:32,800 --> 00:50:33,839
rrc

1323
00:50:33,839 --> 00:50:35,920
that that maybe could be improved

1324
00:50:35,920 --> 00:50:37,280
thank you

1325
00:50:37,280 --> 00:50:40,440
thank you

1326
00:50:44,400 --> 00:50:45,839
great work

1327
00:50:45,839 --> 00:50:48,400
very interesting i want just two

1328
00:50:48,400 --> 00:50:51,200
questions quick the first one you've

1329
00:50:51,200 --> 00:50:53,359
shown two different methods one with

1330
00:50:53,359 --> 00:50:55,440
linear one with uh i don't remember

1331
00:50:55,440 --> 00:50:56,400
sorry

1332
00:50:56,400 --> 00:50:59,040
anyway i wanted to ask if they are wrong

1333
00:50:59,040 --> 00:51:02,400
in the same way or they actually could

1334
00:51:02,400 --> 00:51:06,000
be used together to cross validate each

1335
00:51:06,000 --> 00:51:09,200
other and say okay

1336
00:51:09,200 --> 00:51:10,400
yeah that's a good question i haven't

1337
00:51:10,400 --> 00:51:11,520
thought about that

1338
00:51:11,520 --> 00:51:13,040
maria probably has

1339
00:51:13,040 --> 00:51:15,200
yeah i'm sure that you could use them to

1340
00:51:15,200 --> 00:51:16,640
you could do some sort of intersectional

1341
00:51:16,640 --> 00:51:18,800
approach potentially right where you you

1342
00:51:18,800 --> 00:51:20,240
have like a higher layer that takes as

1343
00:51:20,240 --> 00:51:22,880
input both models and then finds kind of

1344
00:51:22,880 --> 00:51:24,480
where they agree um that sounds

1345
00:51:24,480 --> 00:51:26,400
interesting i i haven't tried that but i

1346
00:51:26,400 --> 00:51:28,720
think it's a good idea thank you and the

1347
00:51:28,720 --> 00:51:31,040
second one is if you are taking else

1348
00:51:31,040 --> 00:51:32,880
into account not now my maybe in the

1349
00:51:32,880 --> 00:51:34,880
future the problem of

1350
00:51:34,880 --> 00:51:36,720
the length of the fields because

1351
00:51:36,720 --> 00:51:38,480
sometimes the same transition is

1352
00:51:38,480 --> 00:51:41,359
actually governed governed by some

1353
00:51:41,359 --> 00:51:42,319
fields

1354
00:51:42,319 --> 00:51:45,040
it might be either too short or too long

1355
00:51:45,040 --> 00:51:47,680
or well usually too short

1356
00:51:47,680 --> 00:51:48,960
and

1357
00:51:48,960 --> 00:51:51,920
also that might be a problem for the

1358
00:51:51,920 --> 00:51:53,440
state machine yeah that's a great

1359
00:51:53,440 --> 00:51:56,240
question um i would say that prior work

1360
00:51:56,240 --> 00:51:58,720
before i started my phd by my group

1361
00:51:58,720 --> 00:52:00,720
specifically by samuel giro who as i

1362
00:52:00,720 --> 00:52:02,720
said is at lincoln labs now working with

1363
00:52:02,720 --> 00:52:05,760
maria um applied similar techniques to

1364
00:52:05,760 --> 00:52:07,119
figure out the packet structures of

1365
00:52:07,119 --> 00:52:08,640
protocols using natural language

1366
00:52:08,640 --> 00:52:11,200
processing applied to rfcs and you could

1367
00:52:11,200 --> 00:52:12,720
potentially combine these approaches

1368
00:52:12,720 --> 00:52:14,319
right so if you have one approach to

1369
00:52:14,319 --> 00:52:15,680
find the packet structure and another to

1370
00:52:15,680 --> 00:52:17,280
find the finite state machine and then

1371
00:52:17,280 --> 00:52:19,920
you can go from just reasoning about

1372
00:52:19,920 --> 00:52:21,520
kind of your atomic propositions of like

1373
00:52:21,520 --> 00:52:24,079
scene and fiend to actual full-fledged

1374
00:52:24,079 --> 00:52:25,200
packets

1375
00:52:25,200 --> 00:52:26,880
then that sets you up to pretty nicely

1376
00:52:26,880 --> 00:52:29,359
be able to make arithmetic statements

1377
00:52:29,359 --> 00:52:30,800
about the contents of those packets

1378
00:52:30,800 --> 00:52:32,640
right such as their length so that would

1379
00:52:32,640 --> 00:52:34,800
be a next step however from a formal

1380
00:52:34,800 --> 00:52:36,240
method perspective is complicated

1381
00:52:36,240 --> 00:52:37,599
because you get into a state space

1382
00:52:37,599 --> 00:52:39,200
explosion problem so you probably

1383
00:52:39,200 --> 00:52:40,480
wouldn't want to use model checking at

1384
00:52:40,480 --> 00:52:41,839
that point if you're going to reason

1385
00:52:41,839 --> 00:52:43,440
about the packet details you'd want to

1386
00:52:43,440 --> 00:52:44,800
use another approach

1387
00:52:44,800 --> 00:52:46,400
but yeah it is interesting and something

1388
00:52:46,400 --> 00:52:48,079
we've thought about yeah thank you thank

1389
00:52:48,079 --> 00:52:50,960
you great work

1390
00:52:51,920 --> 00:52:55,200
uh this is artwork from microsoft

1391
00:52:55,200 --> 00:52:56,880
so i think there was one thing that i

1392
00:52:56,880 --> 00:53:01,160
found a bit missing in the evaluation

1393
00:53:01,359 --> 00:53:02,640
so obviously

1394
00:53:02,640 --> 00:53:03,920
your current

1395
00:53:03,920 --> 00:53:07,520
extraction don't have very good accuracy

1396
00:53:07,520 --> 00:53:09,119
and also you have the additional loss

1397
00:53:09,119 --> 00:53:12,240
from the translation to state machine

1398
00:53:12,240 --> 00:53:15,040
so have you tried to actually uh do the

1399
00:53:15,040 --> 00:53:16,559
work that you suggest in the future

1400
00:53:16,559 --> 00:53:19,200
steps for the tl for instance for tcp or

1401
00:53:19,200 --> 00:53:20,480
for uh

1402
00:53:20,480 --> 00:53:21,839
gccp

1403
00:53:21,839 --> 00:53:23,359
which would be essentially

1404
00:53:23,359 --> 00:53:24,800
measuring how many trends you need to

1405
00:53:24,800 --> 00:53:28,319
actually make in the original rfc until

1406
00:53:28,319 --> 00:53:31,119
you get to the point where you actually

1407
00:53:31,119 --> 00:53:32,480
don't have any missing transition

1408
00:53:32,480 --> 00:53:34,319
anymore and you don't have any false

1409
00:53:34,319 --> 00:53:37,040
positions anymore because it feels like

1410
00:53:37,040 --> 00:53:38,880
with some that many errors

1411
00:53:38,880 --> 00:53:40,319
you would need to essentially uh

1412
00:53:40,319 --> 00:53:42,400
completely rewrite everything it would

1413
00:53:42,400 --> 00:53:44,800
be like very

1414
00:53:44,800 --> 00:53:46,559
frustrating for the rfc authors to

1415
00:53:46,559 --> 00:53:48,240
actually do that methodology so do you

1416
00:53:48,240 --> 00:53:49,599
have any kind of

1417
00:53:49,599 --> 00:53:50,880
thought on that or did you do any

1418
00:53:50,880 --> 00:53:52,400
experiments on that

1419
00:53:52,400 --> 00:53:53,839
great question i have two thoughts on

1420
00:53:53,839 --> 00:53:55,119
that first of all

1421
00:53:55,119 --> 00:53:56,800
we have not worked on this yet because i

1422
00:53:56,800 --> 00:53:58,960
think there's a lot to improve in

1423
00:53:58,960 --> 00:54:00,319
um

1424
00:54:00,319 --> 00:54:01,839
in our methodology before we try to

1425
00:54:01,839 --> 00:54:03,839
improve the rfcs so i mean just from an

1426
00:54:03,839 --> 00:54:05,280
academic perspective i understand that

1427
00:54:05,280 --> 00:54:07,760
as like the ietf community you are more

1428
00:54:07,760 --> 00:54:09,760
interested in improving the rfcs but as

1429
00:54:09,760 --> 00:54:11,760
academics working on trying to find cool

1430
00:54:11,760 --> 00:54:13,520
ways to extract information from

1431
00:54:13,520 --> 00:54:15,440
documents we're perhaps

1432
00:54:15,440 --> 00:54:17,520
focused right now on improving our ways

1433
00:54:17,520 --> 00:54:18,800
of extracting information from documents

1434
00:54:18,800 --> 00:54:20,559
and as you can see with prediction error

1435
00:54:20,559 --> 00:54:21,760
there's a lot that we could improve on

1436
00:54:21,760 --> 00:54:23,280
right by training on more documents and

1437
00:54:23,280 --> 00:54:25,680
improving our model structure um that

1438
00:54:25,680 --> 00:54:28,079
being said i think actually that

1439
00:54:28,079 --> 00:54:29,760
what we'll eventually find when we do

1440
00:54:29,760 --> 00:54:31,280
get to doing this experiment is that the

1441
00:54:31,280 --> 00:54:32,880
amount of changes necessary is not that

1442
00:54:32,880 --> 00:54:34,800
great i think for the most part it would

1443
00:54:34,800 --> 00:54:36,240
be things like you have a sentence in

1444
00:54:36,240 --> 00:54:38,319
which the target state is implicit and

1445
00:54:38,319 --> 00:54:40,640
you just add the words to

1446
00:54:40,640 --> 00:54:41,839
scene received to the end of the

1447
00:54:41,839 --> 00:54:43,599
sentence and now it's explicit right

1448
00:54:43,599 --> 00:54:44,880
essentially taking things that to a

1449
00:54:44,880 --> 00:54:47,280
human are implied and making them

1450
00:54:47,280 --> 00:54:49,520
explicit because i'd rather have a

1451
00:54:49,520 --> 00:54:51,119
slightly redundant boring spec that's

1452
00:54:51,119 --> 00:54:52,799
unambiguous then one that's very

1453
00:54:52,799 --> 00:54:55,200
cleverly written and i get confused by

1454
00:54:55,200 --> 00:54:57,200
um so i actually do not think it would

1455
00:54:57,200 --> 00:54:59,440
take that many changes in order to make

1456
00:54:59,440 --> 00:55:01,440
it unambiguous

1457
00:55:01,440 --> 00:55:04,000
good thanks thank you

1458
00:55:04,000 --> 00:55:06,400
all right thank you uh a reminder that

1459
00:55:06,400 --> 00:55:08,559
we we're using the meat echo queue so we

1460
00:55:08,559 --> 00:55:10,240
can do the the local and remote people

1461
00:55:10,240 --> 00:55:11,440
in the queue

1462
00:55:11,440 --> 00:55:16,160
uh last question i think is by jonathan

1463
00:55:17,599 --> 00:55:19,119
yes yeah um

1464
00:55:19,119 --> 00:55:20,640
so i i'm uh

1465
00:55:20,640 --> 00:55:22,319
i i spend a lot of my time doing

1466
00:55:22,319 --> 00:55:25,759
tamarind modeling so um

1467
00:55:26,480 --> 00:55:28,480
um

1468
00:55:28,480 --> 00:55:32,160
i'm interested to know why you're using

1469
00:55:32,160 --> 00:55:33,599
fsm

1470
00:55:33,599 --> 00:55:35,040
because

1471
00:55:35,040 --> 00:55:36,720
almost all protocols that i've come

1472
00:55:36,720 --> 00:55:37,839
across

1473
00:55:37,839 --> 00:55:39,920
cannot be expressed as an fsm you need

1474
00:55:39,920 --> 00:55:42,160
tokens or they have states or

1475
00:55:42,160 --> 00:55:44,240
you're actually very limited to

1476
00:55:44,240 --> 00:55:46,880
maybe just tcp i i can't imagine what

1477
00:55:46,880 --> 00:55:49,440
other ones don't have state

1478
00:55:49,440 --> 00:55:52,240
yeah this is a fantastic question um so

1479
00:55:52,240 --> 00:55:54,640
uh people who work in tamarin or pro

1480
00:55:54,640 --> 00:55:56,000
verif or

1481
00:55:56,000 --> 00:55:59,040
dare i say kryptol are um uh interacting

1482
00:55:59,040 --> 00:56:01,119
with mostly cryptographic protocols or

1483
00:56:01,119 --> 00:56:02,480
protocols that use cryptographic

1484
00:56:02,480 --> 00:56:04,000
primitives and they care about things

1485
00:56:04,000 --> 00:56:05,599
like secrecy and privacy and and i care

1486
00:56:05,599 --> 00:56:07,280
about those things too but um but

1487
00:56:07,280 --> 00:56:08,720
because they care about those things

1488
00:56:08,720 --> 00:56:10,480
they they need to reason about threat

1489
00:56:10,480 --> 00:56:11,920
models where secrecy or privacy or

1490
00:56:11,920 --> 00:56:13,680
confidentiality et cetera could be

1491
00:56:13,680 --> 00:56:15,280
violated and attacks against those

1492
00:56:15,280 --> 00:56:18,240
things and um fsms are are i would say

1493
00:56:18,240 --> 00:56:19,359
probably not the right approach for that

1494
00:56:19,359 --> 00:56:21,280
so i think we agree on that front and i

1495
00:56:21,280 --> 00:56:22,720
i think that um maybe a more type

1496
00:56:22,720 --> 00:56:25,200
theoretic approach like uh what what

1497
00:56:25,200 --> 00:56:28,480
cameron does is quite good um

1498
00:56:28,480 --> 00:56:30,319
there actually are quite a few protocols

1499
00:56:30,319 --> 00:56:32,799
that uh have at least components that

1500
00:56:32,799 --> 00:56:34,640
can be studied using fsms mostly

1501
00:56:34,640 --> 00:56:36,319
communication protocols

1502
00:56:36,319 --> 00:56:40,720
examples include ltp tcp dccp sctp

1503
00:56:40,720 --> 00:56:43,760
sftp ftp

1504
00:56:43,760 --> 00:56:45,599
and some

1505
00:56:45,599 --> 00:56:46,880
also some newer protocols i've been

1506
00:56:46,880 --> 00:56:48,160
looking at

1507
00:56:48,160 --> 00:56:50,400
that are not related to itf uh which

1508
00:56:50,400 --> 00:56:52,400
we'll release in future work so i would

1509
00:56:52,400 --> 00:56:54,559
say that many things that

1510
00:56:54,559 --> 00:56:56,559
are communication protocols that have

1511
00:56:56,559 --> 00:56:58,079
handshakes in which you establish some

1512
00:56:58,079 --> 00:56:59,839
sort of connection are are very well

1513
00:56:59,839 --> 00:57:01,920
described by fsms but another aspect to

1514
00:57:01,920 --> 00:57:03,760
your question is that we often will take

1515
00:57:03,760 --> 00:57:05,200
a protocol and break it into chunks and

1516
00:57:05,200 --> 00:57:06,960
say this chunk can be studied by model

1517
00:57:06,960 --> 00:57:09,599
checking with uh an fsm representing

1518
00:57:09,599 --> 00:57:11,440
that component of the protocol but this

1519
00:57:11,440 --> 00:57:13,520
other chunk might be best studied in

1520
00:57:13,520 --> 00:57:15,040
some other way so the cryptographic

1521
00:57:15,040 --> 00:57:17,040
aspects are probably not suitable to to

1522
00:57:17,040 --> 00:57:18,480
model checking

1523
00:57:18,480 --> 00:57:19,520
yeah thanks for the question though

1524
00:57:19,520 --> 00:57:22,000
great question

1525
00:57:24,400 --> 00:57:26,480
all right thank you uh

1526
00:57:26,480 --> 00:57:28,160
really excellent talk really excellent

1527
00:57:28,160 --> 00:57:29,760
questions uh there's a bunch of

1528
00:57:29,760 --> 00:57:32,079
discussion in the chat as well which you

1529
00:57:32,079 --> 00:57:34,160
might want to look at uh

1530
00:57:34,160 --> 00:57:36,720
uh so in a couple of minutes so thank

1531
00:57:36,720 --> 00:57:38,720
you again max your talk

1532
00:57:38,720 --> 00:57:41,080
thank you very much

1533
00:57:41,080 --> 00:57:45,270
[Applause]

1534
00:57:46,000 --> 00:57:48,720
all right thank you so our next speaker

1535
00:57:48,720 --> 00:57:52,240
today is jane yen from

1536
00:57:52,240 --> 00:57:54,799
the university of southern california uh

1537
00:57:54,799 --> 00:57:57,280
who is going to talk about tools for

1538
00:57:57,280 --> 00:58:00,960
disambiguating rfcs

1539
00:58:01,040 --> 00:58:03,599
yes thank you

1540
00:58:03,599 --> 00:58:05,200
okay

1541
00:58:05,200 --> 00:58:08,799
okay can everyone hear me

1542
00:58:08,799 --> 00:58:12,720
okay great um so hi everyone um so today

1543
00:58:12,720 --> 00:58:14,960
i want to talk about our work that i

1544
00:58:14,960 --> 00:58:17,680
work with my advisors barack robin and

1545
00:58:17,680 --> 00:58:19,520
ramesh govindam

1546
00:58:19,520 --> 00:58:23,040
the topic is tools for disambiguating

1547
00:58:23,040 --> 00:58:25,599
rfc

1548
00:58:25,920 --> 00:58:27,760
let me start from giving you some

1549
00:58:27,760 --> 00:58:30,640
numbers that i got from the rfc editor

1550
00:58:30,640 --> 00:58:32,160
website

1551
00:58:32,160 --> 00:58:34,640
here this table shows the number of

1552
00:58:34,640 --> 00:58:38,319
published rfcs each year from 2016 to

1553
00:58:38,319 --> 00:58:39,839
2021

1554
00:58:39,839 --> 00:58:42,720
we can notice that the published number

1555
00:58:42,720 --> 00:58:46,400
ranges from almost 200 to 300.

1556
00:58:46,400 --> 00:58:50,640
so assuming each rfc is about 10 pages

1557
00:58:50,640 --> 00:58:53,760
that means there are about 2 000 or 3

1558
00:58:53,760 --> 00:58:56,079
thousands of pages every year that

1559
00:58:56,079 --> 00:58:58,799
should be reviewed and studied and then

1560
00:58:58,799 --> 00:59:00,400
considered

1561
00:59:00,400 --> 00:59:02,799
it doesn't sound like a small number to

1562
00:59:02,799 --> 00:59:05,920
me it also indicates that great human

1563
00:59:05,920 --> 00:59:09,520
efforts in involved

1564
00:59:09,839 --> 00:59:12,799
so human efforts is involved in various

1565
00:59:12,799 --> 00:59:15,839
parts of the specification production

1566
00:59:15,839 --> 00:59:16,960
process

1567
00:59:16,960 --> 00:59:19,680
and as an example here is a working

1568
00:59:19,680 --> 00:59:20,720
group

1569
00:59:20,720 --> 00:59:23,760
they will need to gather and discuss

1570
00:59:23,760 --> 00:59:24,720
which

1571
00:59:24,720 --> 00:59:27,040
uh and or what protocol needs to be

1572
00:59:27,040 --> 00:59:29,680
standardized and there will be one or

1573
00:59:29,680 --> 00:59:32,400
more specification authors composing the

1574
00:59:32,400 --> 00:59:34,480
contents of spec

1575
00:59:34,480 --> 00:59:37,280
although it might be obvious the content

1576
00:59:37,280 --> 00:59:40,160
is full of domain specific knowledge and

1577
00:59:40,160 --> 00:59:42,480
would require professionals to verify

1578
00:59:42,480 --> 00:59:44,079
the content

1579
00:59:44,079 --> 00:59:47,359
any unclear detail is picked out by

1580
00:59:47,359 --> 00:59:50,240
human examination

1581
00:59:50,240 --> 00:59:53,200
when we speak of the concerns about the

1582
00:59:53,200 --> 00:59:54,960
quality of a spec

1583
00:59:54,960 --> 00:59:57,359
it is hard to neglect the impact of

1584
00:59:57,359 --> 00:59:59,200
ambiguities

1585
00:59:59,200 --> 01:00:01,680
with the existence of the ambiguities in

1586
01:00:01,680 --> 01:00:02,720
a spec

1587
01:00:02,720 --> 01:00:04,880
different protocol implementers could

1588
01:00:04,880 --> 01:00:06,880
interpret the content differently and

1589
01:00:06,880 --> 01:00:08,640
generate multiple versions of the

1590
01:00:08,640 --> 01:00:11,200
protocols

1591
01:00:11,200 --> 01:00:14,240
and here's one example which might cause

1592
01:00:14,240 --> 01:00:16,799
different interpretations

1593
01:00:16,799 --> 01:00:19,920
it says the checksum is the 16-bit one's

1594
01:00:19,920 --> 01:00:22,640
complement of the one's complement sound

1595
01:00:22,640 --> 01:00:24,960
of the icmp message starting with the

1596
01:00:24,960 --> 01:00:28,079
icmv type

1597
01:00:28,079 --> 01:00:30,880
at first glance it might not be obvious

1598
01:00:30,880 --> 01:00:34,240
why the sentence is ambiguous however

1599
01:00:34,240 --> 01:00:36,480
when we focus on the last part of this

1600
01:00:36,480 --> 01:00:40,319
sentence it explicitly

1601
01:00:40,319 --> 01:00:42,960
explicitly mentions the checksum starts

1602
01:00:42,960 --> 01:00:46,079
with icmp type but it doesn't mention

1603
01:00:46,079 --> 01:00:48,079
where the checksum computation should

1604
01:00:48,079 --> 01:00:48,960
end

1605
01:00:48,960 --> 01:00:51,440
so how could this affect a person's

1606
01:00:51,440 --> 01:00:54,240
interpretation

1607
01:00:54,319 --> 01:00:57,280
here i show the icmp header to help

1608
01:00:57,280 --> 01:00:59,920
illustrate how we can at least come up

1609
01:00:59,920 --> 01:01:02,640
with two different interpretations

1610
01:01:02,640 --> 01:01:05,119
one is to check some only the icmp

1611
01:01:05,119 --> 01:01:06,319
header part

1612
01:01:06,319 --> 01:01:08,480
and the other is to check some both the

1613
01:01:08,480 --> 01:01:10,640
header and the payload

1614
01:01:10,640 --> 01:01:12,960
as shown the two different

1615
01:01:12,960 --> 01:01:15,359
interpretations would lead to different

1616
01:01:15,359 --> 01:01:18,559
protocol implementations

1617
01:01:18,559 --> 01:01:21,200
so with this example we noticed that

1618
01:01:21,200 --> 01:01:24,079
using an ambiguous specification could

1619
01:01:24,079 --> 01:01:26,000
not only result in different

1620
01:01:26,000 --> 01:01:29,240
implementation but also result in bug

1621
01:01:29,240 --> 01:01:32,000
implementations and or security

1622
01:01:32,000 --> 01:01:35,000
vulnerabilities

1623
01:01:35,040 --> 01:01:35,839
so

1624
01:01:35,839 --> 01:01:38,640
if we go back to our scenario of

1625
01:01:38,640 --> 01:01:41,599
generating a spec the working group and

1626
01:01:41,599 --> 01:01:44,319
the spec authors all know the importance

1627
01:01:44,319 --> 01:01:46,799
of delivering correct message over the

1628
01:01:46,799 --> 01:01:48,720
spec

1629
01:01:48,720 --> 01:01:51,440
to spec reader so there are some

1630
01:01:51,440 --> 01:01:53,839
guidelines to follow and they are useful

1631
01:01:53,839 --> 01:01:57,200
to reduce the ambiguities

1632
01:01:57,200 --> 01:01:58,079
but

1633
01:01:58,079 --> 01:02:01,440
do we know whether we are close to near

1634
01:02:01,440 --> 01:02:06,440
zero ambiguity for the specification

1635
01:02:07,760 --> 01:02:11,119
motivated by this question we presented

1636
01:02:11,119 --> 01:02:14,160
our work in uh last year cycle and and

1637
01:02:14,160 --> 01:02:15,760
our w

1638
01:02:15,760 --> 01:02:18,000
following i will introduce what they are

1639
01:02:18,000 --> 01:02:21,640
about respectively

1640
01:02:22,079 --> 01:02:24,160
the first one is sage

1641
01:02:24,160 --> 01:02:26,400
in this work we get to know what

1642
01:02:26,400 --> 01:02:28,880
ambiguity exists in a number of

1643
01:02:28,880 --> 01:02:31,200
long-standing protocols

1644
01:02:31,200 --> 01:02:34,559
specifically we uncover by instances of

1645
01:02:34,559 --> 01:02:36,799
ambiguity and sex instances of

1646
01:02:36,799 --> 01:02:38,559
underspecification

1647
01:02:38,559 --> 01:02:41,039
in icmprbc

1648
01:02:41,039 --> 01:02:42,880
with an ambiguous

1649
01:02:42,880 --> 01:02:45,359
specification we are able to generate

1650
01:02:45,359 --> 01:02:48,079
executable code that can interoperate

1651
01:02:48,079 --> 01:02:50,480
with the third party code

1652
01:02:50,480 --> 01:02:53,039
and they generalize to significant

1653
01:02:53,039 --> 01:02:57,200
sections of bfd igmp and ntp

1654
01:02:57,200 --> 01:02:59,520
well as an introduction i leave some

1655
01:02:59,520 --> 01:03:02,079
detail in our paper and aim to give an

1656
01:03:02,079 --> 01:03:05,039
overview of it

1657
01:03:05,520 --> 01:03:08,400
so in sage we apply natural language

1658
01:03:08,400 --> 01:03:10,880
processing techniques on it to discover

1659
01:03:10,880 --> 01:03:13,200
existence of ambiguities

1660
01:03:13,200 --> 01:03:15,119
to do so we need to understand the

1661
01:03:15,119 --> 01:03:17,920
semantics of the specification which is

1662
01:03:17,920 --> 01:03:22,160
commonly termed as the semantic parsing

1663
01:03:22,160 --> 01:03:24,720
and ultimately we want to leverage the

1664
01:03:24,720 --> 01:03:26,559
results from

1665
01:03:26,559 --> 01:03:28,880
semantic parsing to generate a low

1666
01:03:28,880 --> 01:03:33,200
low-level executable protocol code

1667
01:03:34,000 --> 01:03:36,880
since semantic parsing is not perfect

1668
01:03:36,880 --> 01:03:39,359
and may possibly never be perfect in the

1669
01:03:39,359 --> 01:03:40,799
future

1670
01:03:40,799 --> 01:03:43,280
once ambiguous sentences are found we

1671
01:03:43,280 --> 01:03:45,920
will need to involve human efforts to

1672
01:03:45,920 --> 01:03:47,920
edit those sentences

1673
01:03:47,920 --> 01:03:50,160
when a specification is unambiguous

1674
01:03:50,160 --> 01:03:52,160
executable protocol code can be

1675
01:03:52,160 --> 01:03:55,520
automatically generated

1676
01:03:56,079 --> 01:03:58,799
and in this work we face a number of

1677
01:03:58,799 --> 01:04:01,280
challenges

1678
01:04:01,280 --> 01:04:04,079
first semantic parser only parses

1679
01:04:04,079 --> 01:04:06,960
generic terms but specifications could

1680
01:04:06,960 --> 01:04:09,599
use domain-specific languages languages

1681
01:04:09,599 --> 01:04:14,000
such as checksum once complement etc

1682
01:04:14,000 --> 01:04:15,359
and second

1683
01:04:15,359 --> 01:04:17,680
semantic parsing is not perfect and

1684
01:04:17,680 --> 01:04:19,839
therefore multiple representations might

1685
01:04:19,839 --> 01:04:24,400
be generated but only a subset is

1686
01:04:24,839 --> 01:04:28,000
valid finally when we generate semantic

1687
01:04:28,000 --> 01:04:30,319
representations we need to convert them

1688
01:04:30,319 --> 01:04:34,799
into correct executable code

1689
01:04:35,920 --> 01:04:38,000
in this work we make the following

1690
01:04:38,000 --> 01:04:40,720
corresponding contributions first we

1691
01:04:40,720 --> 01:04:43,440
extend the generic semantic parser with

1692
01:04:43,440 --> 01:04:47,760
domain-specific syntax and semantics

1693
01:04:47,760 --> 01:04:50,880
second we automate this integration of

1694
01:04:50,880 --> 01:04:53,119
poor semantic representations with

1695
01:04:53,119 --> 01:04:56,400
defined checking rules

1696
01:04:56,400 --> 01:04:58,720
and third we compile semantic

1697
01:04:58,720 --> 01:05:02,959
representations into executable code

1698
01:05:03,920 --> 01:05:06,079
sage has three components that

1699
01:05:06,079 --> 01:05:08,319
correspond to the contributions and

1700
01:05:08,319 --> 01:05:11,119
respectively they are semantic parsing

1701
01:05:11,119 --> 01:05:13,200
disaggregation and code generator

1702
01:05:13,200 --> 01:05:15,760
components

1703
01:05:15,760 --> 01:05:18,559
a complete rfc parsing workflow will

1704
01:05:18,559 --> 01:05:20,000
look like this

1705
01:05:20,000 --> 01:05:22,480
in addition to the already introduced

1706
01:05:22,480 --> 01:05:24,640
three components human will be involved

1707
01:05:24,640 --> 01:05:27,039
in the loop

1708
01:05:27,039 --> 01:05:29,920
after the disability phase if more than

1709
01:05:29,920 --> 01:05:32,240
one representation remains it means we

1710
01:05:32,240 --> 01:05:34,559
discover ambiguities so we provide

1711
01:05:34,559 --> 01:05:37,200
feedback to the user who is likely the

1712
01:05:37,200 --> 01:05:39,680
specification author to resolve

1713
01:05:39,680 --> 01:05:43,839
ambiguity by rewriting the sentences

1714
01:05:43,839 --> 01:05:47,119
also if a sentence is unambiguous sage

1715
01:05:47,119 --> 01:05:49,359
will proceed to map the intermediate

1716
01:05:49,359 --> 01:05:51,839
representation to a code snippet the

1717
01:05:51,839 --> 01:05:54,880
code snippets will undergo unit tests to

1718
01:05:54,880 --> 01:05:57,680
check if it performs any underspecified

1719
01:05:57,680 --> 01:06:00,799
political behavior

1720
01:06:01,520 --> 01:06:03,760
i will introduce the main idea of each

1721
01:06:03,760 --> 01:06:05,200
component

1722
01:06:05,200 --> 01:06:09,279
first semantic parsing component

1723
01:06:10,000 --> 01:06:13,119
the purpose of doing semantic parsing is

1724
01:06:13,119 --> 01:06:16,240
to derive a semantic representation

1725
01:06:16,240 --> 01:06:18,799
therefore what we can expect is to take

1726
01:06:18,799 --> 01:06:22,079
in a textual sentence and turn it into a

1727
01:06:22,079 --> 01:06:24,880
chosen intermediate representation

1728
01:06:24,880 --> 01:06:27,039
and in our work we use a semantic

1729
01:06:27,039 --> 01:06:29,920
representation called logical form

1730
01:06:29,920 --> 01:06:32,319
a simple logical form is composed of a

1731
01:06:32,319 --> 01:06:36,480
predicate with a number of arguments

1732
01:06:36,640 --> 01:06:39,280
the key observation here

1733
01:06:39,280 --> 01:06:42,400
is that a logical form is a unifying

1734
01:06:42,400 --> 01:06:44,880
abstraction for dissemination and code

1735
01:06:44,880 --> 01:06:47,839
generation

1736
01:06:48,319 --> 01:06:50,640
we do not change the functionality of

1737
01:06:50,640 --> 01:06:53,839
the parser itself but for us to properly

1738
01:06:53,839 --> 01:06:56,000
parse our text we have to extend the

1739
01:06:56,000 --> 01:06:58,400
syntax and semantic parts

1740
01:06:58,400 --> 01:07:01,119
for example the nlp parser wouldn't

1741
01:07:01,119 --> 01:07:04,880
recognize all the nouns or noun phrases

1742
01:07:04,880 --> 01:07:07,839
so we have to use uh so

1743
01:07:07,839 --> 01:07:10,400
in this work we use a generic parser

1744
01:07:10,400 --> 01:07:13,520
called spacey and we extend the species

1745
01:07:13,520 --> 01:07:14,400
term

1746
01:07:14,400 --> 01:07:17,200
dictionary with networking terms such as

1747
01:07:17,200 --> 01:07:19,920
one's complement

1748
01:07:19,920 --> 01:07:21,920
and for the semantic parts a

1749
01:07:21,920 --> 01:07:23,760
specification might include some

1750
01:07:23,760 --> 01:07:26,000
idiomatic usage

1751
01:07:26,000 --> 01:07:29,280
for example the equivalent mark in zero

1752
01:07:29,280 --> 01:07:32,720
equals to echo reply is not a sign that

1753
01:07:32,720 --> 01:07:36,000
can be processed by the generic parser

1754
01:07:36,000 --> 01:07:38,079
after we add the semantics for it the

1755
01:07:38,079 --> 01:07:40,880
parser could understand that it is an

1756
01:07:40,880 --> 01:07:43,280
association relations in the

1757
01:07:43,280 --> 01:07:45,760
sentence

1758
01:07:46,319 --> 01:07:48,720
next let me introduce how we leverage

1759
01:07:48,720 --> 01:07:53,359
logical forms to discover ambiguities

1760
01:07:54,319 --> 01:07:58,079
if the lp parsing yields something other

1761
01:07:58,079 --> 01:08:01,440
than exactly one logical form we call it

1762
01:08:01,440 --> 01:08:04,880
a true ambiguity

1763
01:08:05,039 --> 01:08:08,319
an example of a zero logical form case

1764
01:08:08,319 --> 01:08:11,359
is that a sentence is incomplete due to

1765
01:08:11,359 --> 01:08:15,119
missing subject in the sentence

1766
01:08:15,359 --> 01:08:18,560
and another example of more than one

1767
01:08:18,560 --> 01:08:21,120
logical form case is that a sentence

1768
01:08:21,120 --> 01:08:24,158
uses in precise language such as using a

1769
01:08:24,158 --> 01:08:26,399
terminology that can be interpreted as

1770
01:08:26,399 --> 01:08:29,519
two different concepts

1771
01:08:30,799 --> 01:08:33,600
so the nlp parser has limitation and

1772
01:08:33,600 --> 01:08:35,759
could generate additional logical forms

1773
01:08:35,759 --> 01:08:38,399
that do not indicate the true ambiguity

1774
01:08:38,399 --> 01:08:39,600
cases

1775
01:08:39,600 --> 01:08:41,920
therefore we define five different types

1776
01:08:41,920 --> 01:08:44,560
of check-in rules to eliminate these

1777
01:08:44,560 --> 01:08:46,479
additional logical forms

1778
01:08:46,479 --> 01:08:49,279
the by-checking rules are type argument

1779
01:08:49,279 --> 01:08:50,880
ordering predicate ordering

1780
01:08:50,880 --> 01:08:53,359
distributivity and associativity

1781
01:08:53,359 --> 01:08:54,880
respectively

1782
01:08:54,880 --> 01:08:56,960
but for more detailed introduction of

1783
01:08:56,960 --> 01:08:59,198
these five chicken rules

1784
01:08:59,198 --> 01:09:02,799
you can find in our paper

1785
01:09:03,520 --> 01:09:06,640
after disambiguation every sentence uses

1786
01:09:06,640 --> 01:09:09,920
only one logical form as an ambiguous

1787
01:09:09,920 --> 01:09:11,359
specification

1788
01:09:11,359 --> 01:09:15,679
then we move on to the code generator

1789
01:09:15,920 --> 01:09:19,120
the code generator works as follows

1790
01:09:19,120 --> 01:09:21,600
it checks in a logical form and its

1791
01:09:21,600 --> 01:09:24,479
contextual information and turns it into

1792
01:09:24,479 --> 01:09:26,319
executable code

1793
01:09:26,319 --> 01:09:28,399
this example is simple and

1794
01:09:28,399 --> 01:09:30,960
straightforward to map a logical form to

1795
01:09:30,960 --> 01:09:34,319
an executable code but this converting

1796
01:09:34,319 --> 01:09:36,560
process can get far more complex than

1797
01:09:36,560 --> 01:09:38,719
this example

1798
01:09:38,719 --> 01:09:42,399
we include we also include more complex

1799
01:09:42,399 --> 01:09:45,439
example in the paper so you may check it

1800
01:09:45,439 --> 01:09:48,599
out later

1801
01:09:48,799 --> 01:09:51,279
um i'm only giving you an idea of what

1802
01:09:51,279 --> 01:09:54,800
kind of evaluation we've done in sage we

1803
01:09:54,800 --> 01:09:59,840
um put the sage is on rcmp rfc we apply

1804
01:09:59,840 --> 01:10:01,280
the sage on

1805
01:10:01,280 --> 01:10:04,320
and prfc and use generic linux pin and

1806
01:10:04,320 --> 01:10:06,719
truss route on the center side and use

1807
01:10:06,719 --> 01:10:08,640
the package formulation function to

1808
01:10:08,640 --> 01:10:11,199
generate a reply packet back to the

1809
01:10:11,199 --> 01:10:12,159
center

1810
01:10:12,159 --> 01:10:14,480
the tested ping and threshold programs

1811
01:10:14,480 --> 01:10:16,719
are able to process our automatically

1812
01:10:16,719 --> 01:10:19,040
generated reply packets

1813
01:10:19,040 --> 01:10:21,360
as for showing the efficacy of applying

1814
01:10:21,360 --> 01:10:24,000
disambiguation rules we analyze how many

1815
01:10:24,000 --> 01:10:26,640
logical forms are generated as the base

1816
01:10:26,640 --> 01:10:29,199
and how the value goes down to one after

1817
01:10:29,199 --> 01:10:32,400
all checks are complete

1818
01:10:34,000 --> 01:10:37,360
i have focused on how we use sage to

1819
01:10:37,360 --> 01:10:39,679
understand an rfc

1820
01:10:39,679 --> 01:10:43,280
and but in our nrw paper we extend the

1821
01:10:43,280 --> 01:10:46,000
discussion to cover what else challenges

1822
01:10:46,000 --> 01:10:49,280
haven't been addressed and how the work

1823
01:10:49,280 --> 01:10:52,880
can be possibly extended

1824
01:10:54,239 --> 01:10:57,360
while siege takes a significant step

1825
01:10:57,360 --> 01:10:59,360
towards automatic specification

1826
01:10:59,360 --> 01:11:00,880
processing

1827
01:11:00,880 --> 01:11:03,840
their much work remains

1828
01:11:03,840 --> 01:11:06,640
in an rfc there are many components

1829
01:11:06,640 --> 01:11:09,600
stages able to parse packet formats

1830
01:11:09,600 --> 01:11:11,360
pseudocode

1831
01:11:11,360 --> 01:11:13,840
but there remains other components it

1832
01:11:13,840 --> 01:11:16,320
hasn't supported such as stage machine

1833
01:11:16,320 --> 01:11:20,480
communication pattern and architecture

1834
01:11:21,679 --> 01:11:23,920
in addition to the limitations shown

1835
01:11:23,920 --> 01:11:26,320
there are other challenges that can also

1836
01:11:26,320 --> 01:11:28,960
be considered from code generation

1837
01:11:28,960 --> 01:11:30,480
perspectives

1838
01:11:30,480 --> 01:11:33,199
thinking of stage as not only a method

1839
01:11:33,199 --> 01:11:36,239
to understand the level of ambiguities

1840
01:11:36,239 --> 01:11:38,840
but also a method to automate the code

1841
01:11:38,840 --> 01:11:41,520
generation there is a lot of room to

1842
01:11:41,520 --> 01:11:45,120
automate the code generation part

1843
01:11:45,120 --> 01:11:46,400
there's

1844
01:11:46,400 --> 01:11:49,520
for example sage mostly parses sentence

1845
01:11:49,520 --> 01:11:51,920
by sentence to determine a sentence

1846
01:11:51,920 --> 01:11:54,800
ambiguity and generates code according

1847
01:11:54,800 --> 01:11:57,040
to the order of descriptions

1848
01:11:57,040 --> 01:11:59,600
however it's unrealistic to assume that

1849
01:11:59,600 --> 01:12:02,080
all specifications use self-contained

1850
01:12:02,080 --> 01:12:04,640
sentences every time that means we

1851
01:12:04,640 --> 01:12:07,040
should consider the relationship between

1852
01:12:07,040 --> 01:12:09,520
sentences and how a sentence can provide

1853
01:12:09,520 --> 01:12:11,920
the context to generate the code for

1854
01:12:11,920 --> 01:12:16,400
authors for another sentence

1855
01:12:17,840 --> 01:12:20,000
another challenge could be discovering

1856
01:12:20,000 --> 01:12:23,920
the mismatched or miscaptured behavior

1857
01:12:23,920 --> 01:12:26,320
for example we have both text and

1858
01:12:26,320 --> 01:12:28,960
syntactical components which might be a

1859
01:12:28,960 --> 01:12:30,159
diagram

1860
01:12:30,159 --> 01:12:32,480
what if the information in the diagram

1861
01:12:32,480 --> 01:12:35,360
is not inc is not consistent with the

1862
01:12:35,360 --> 01:12:37,520
textual description

1863
01:12:37,520 --> 01:12:40,159
or what if a piece of information is

1864
01:12:40,159 --> 01:12:43,120
illustrated in a diagram but there is no

1865
01:12:43,120 --> 01:12:45,840
textual explanation should the protocol

1866
01:12:45,840 --> 01:12:48,239
implementer implement that part of the

1867
01:12:48,239 --> 01:12:51,239
diagram

1868
01:12:51,760 --> 01:12:54,800
supposing that we are able to process a

1869
01:12:54,800 --> 01:12:57,679
single rfc already what about some

1870
01:12:57,679 --> 01:13:00,080
protocol describing its functionalities

1871
01:13:00,080 --> 01:13:03,120
or constraints across multiple rfcs

1872
01:13:03,120 --> 01:13:06,080
in some cases a protocol gets revised

1873
01:13:06,080 --> 01:13:08,400
and added more constraints in

1874
01:13:08,400 --> 01:13:10,560
implementation with the publication of

1875
01:13:10,560 --> 01:13:13,040
another rfc how to aggregate the

1876
01:13:13,040 --> 01:13:17,480
information from multiple rfcs

1877
01:13:18,480 --> 01:13:20,719
then there's another type of challenge

1878
01:13:20,719 --> 01:13:23,040
which is aggregating the information of

1879
01:13:23,040 --> 01:13:25,760
multiple protocols instead of one

1880
01:13:25,760 --> 01:13:26,960
protocol

1881
01:13:26,960 --> 01:13:29,600
in practice we send packets with a stack

1882
01:13:29,600 --> 01:13:32,640
of protocols when we want to generate

1883
01:13:32,640 --> 01:13:35,199
the code of a stack of protocols how do

1884
01:13:35,199 --> 01:13:37,280
we exactly organize

1885
01:13:37,280 --> 01:13:40,320
correctly organize and categorize the

1886
01:13:40,320 --> 01:13:43,679
information from diverse rfcs

1887
01:13:43,679 --> 01:13:45,679
in addition how do we select the

1888
01:13:45,679 --> 01:13:48,159
constraints or values while the stack of

1889
01:13:48,159 --> 01:13:51,839
protocols is slightly different

1890
01:13:53,040 --> 01:13:55,520
yet another interesting perspective is

1891
01:13:55,520 --> 01:13:58,400
to consider the logical functionality

1892
01:13:58,400 --> 01:14:00,400
versus the performance of a protocol

1893
01:14:00,400 --> 01:14:01,760
implementation

1894
01:14:01,760 --> 01:14:04,560
a protocol rfc usually focuses on

1895
01:14:04,560 --> 01:14:08,000
describing its logical functionality and

1896
01:14:08,000 --> 01:14:10,560
lifts the flexibility of implementing

1897
01:14:10,560 --> 01:14:14,000
code to any reader of the rfc

1898
01:14:14,000 --> 01:14:15,840
that means we will know the political

1899
01:14:15,840 --> 01:14:17,760
implementation should be logically

1900
01:14:17,760 --> 01:14:20,239
correct but not about how the

1901
01:14:20,239 --> 01:14:21,840
performance will be

1902
01:14:21,840 --> 01:14:24,000
if the spec author suggests any

1903
01:14:24,000 --> 01:14:26,880
performance oriented implementation will

1904
01:14:26,880 --> 01:14:29,199
we be able to differentiate them and

1905
01:14:29,199 --> 01:14:31,199
leave out the implementation as the

1906
01:14:31,199 --> 01:14:33,840
flexibility or the freedom of the code

1907
01:14:33,840 --> 01:14:34,880
of

1908
01:14:34,880 --> 01:14:37,840
code implementer

1909
01:14:39,120 --> 01:14:41,760
the last part i would like to present is

1910
01:14:41,760 --> 01:14:45,760
our current work direction

1911
01:14:46,159 --> 01:14:48,960
i have shown this figure previously it

1912
01:14:48,960 --> 01:14:51,520
illustrates how we process an rfc

1913
01:14:51,520 --> 01:14:54,239
document and involve a feedback loop to

1914
01:14:54,239 --> 01:14:56,800
indicate the human user where the

1915
01:14:56,800 --> 01:14:58,640
ambiguity exists

1916
01:14:58,640 --> 01:15:00,880
i would like to point out there is still

1917
01:15:00,880 --> 01:15:03,280
room to improve the involved human

1918
01:15:03,280 --> 01:15:04,239
efforts

1919
01:15:04,239 --> 01:15:07,040
such as how to assist editing ambiguous

1920
01:15:07,040 --> 01:15:08,239
sentences

1921
01:15:08,239 --> 01:15:10,880
or to extend sage to support more

1922
01:15:10,880 --> 01:15:13,520
protocols

1923
01:15:14,560 --> 01:15:17,440
this leads to another two challenges we

1924
01:15:17,440 --> 01:15:19,120
need to deal with

1925
01:15:19,120 --> 01:15:21,679
considering how we can assist editing

1926
01:15:21,679 --> 01:15:22,880
ambiguous

1927
01:15:22,880 --> 01:15:26,159
sentences we might also want to ask

1928
01:15:26,159 --> 01:15:28,719
can we avoid writing an

1929
01:15:28,719 --> 01:15:31,840
ambiguous sentence in the first place

1930
01:15:31,840 --> 01:15:34,159
as for the other challenge

1931
01:15:34,159 --> 01:15:36,560
we have only talked about a subset of

1932
01:15:36,560 --> 01:15:38,880
specification components what else

1933
01:15:38,880 --> 01:15:42,640
protocols are we going to support

1934
01:15:44,800 --> 01:15:46,880
regarding the first challenge we are

1935
01:15:46,880 --> 01:15:49,600
motivated to design a user interface

1936
01:15:49,600 --> 01:15:51,840
tool that can guide the spec author to

1937
01:15:51,840 --> 01:15:54,320
input only essential information for the

1938
01:15:54,320 --> 01:15:57,280
protocol then we will use the extracted

1939
01:15:57,280 --> 01:15:59,280
essential information to produce an

1940
01:15:59,280 --> 01:16:01,600
ambiguous readable english text and

1941
01:16:01,600 --> 01:16:04,640
executable code

1942
01:16:05,120 --> 01:16:07,760
as for the second challenge we are aware

1943
01:16:07,760 --> 01:16:09,920
that stage 4 protocols require

1944
01:16:09,920 --> 01:16:13,280
considerably more complicated operations

1945
01:16:13,280 --> 01:16:16,800
and many protocols belong to this group

1946
01:16:16,800 --> 01:16:19,040
unlike stateless protocols a staple

1947
01:16:19,040 --> 01:16:21,199
protocol is required to keep internal

1948
01:16:21,199 --> 01:16:23,520
states to integrate packet contents

1949
01:16:23,520 --> 01:16:25,520
given the current state

1950
01:16:25,520 --> 01:16:27,760
the ability to keep historical

1951
01:16:27,760 --> 01:16:29,520
information could allow us to

1952
01:16:29,520 --> 01:16:34,360
significantly cover more protocols

1953
01:16:35,199 --> 01:16:36,080
so

1954
01:16:36,080 --> 01:16:38,400
now let me piece together

1955
01:16:38,400 --> 01:16:40,400
we would like to give the user a

1956
01:16:40,400 --> 01:16:42,719
friendly interface that is able to

1957
01:16:42,719 --> 01:16:45,040
extract the essential information we

1958
01:16:45,040 --> 01:16:47,199
need without ambiguity

1959
01:16:47,199 --> 01:16:49,360
as one of the options we might design

1960
01:16:49,360 --> 01:16:52,480
interfaces similar to microsoft archive

1961
01:16:52,480 --> 01:16:54,560
which leverage the web interface and

1962
01:16:54,560 --> 01:16:56,320
puzzle-like shapes to generate

1963
01:16:56,320 --> 01:16:59,360
executable codes but for us our output

1964
01:16:59,360 --> 01:17:00,880
becomes the

1965
01:17:00,880 --> 01:17:03,840
english sentences

1966
01:17:04,080 --> 01:17:06,320
once we design a parser and parse the

1967
01:17:06,320 --> 01:17:08,320
information received from the user

1968
01:17:08,320 --> 01:17:11,120
interface we leverage the information to

1969
01:17:11,120 --> 01:17:13,760
both compose easy to read english

1970
01:17:13,760 --> 01:17:17,840
sentences and the executable code

1971
01:17:18,640 --> 01:17:20,640
the last part we would like to fill in

1972
01:17:20,640 --> 01:17:23,120
is what essential protocol elements are

1973
01:17:23,120 --> 01:17:24,400
considered

1974
01:17:24,400 --> 01:17:26,320
as i mentioned we want to deal with

1975
01:17:26,320 --> 01:17:28,080
stateful protocol

1976
01:17:28,080 --> 01:17:30,719
from our internal discussion we believe

1977
01:17:30,719 --> 01:17:33,360
a reasonable stats should concern

1978
01:17:33,360 --> 01:17:35,360
contains skymer

1979
01:17:35,360 --> 01:17:37,760
less received packets output packet and

1980
01:17:37,760 --> 01:17:39,520
the program's deeds

1981
01:17:39,520 --> 01:17:42,480
this constitutes our vision of a useful

1982
01:17:42,480 --> 01:17:44,640
tool to generate bi-directional

1983
01:17:44,640 --> 01:17:47,199
unambiguous english text and precise

1984
01:17:47,199 --> 01:17:50,320
executable code

1985
01:17:50,320 --> 01:17:52,400
this is my last slide i'm happy to take

1986
01:17:52,400 --> 01:17:54,080
questions and also interested in

1987
01:17:54,080 --> 01:17:55,920
learning your opinions about the current

1988
01:17:55,920 --> 01:17:58,640
work i leave my contact information and

1989
01:17:58,640 --> 01:18:00,719
the open source code of the mentioned

1990
01:18:00,719 --> 01:18:03,840
siege on the side

1991
01:18:05,760 --> 01:18:06,800
all right

1992
01:18:06,800 --> 01:18:08,080
thank you train

1993
01:18:08,080 --> 01:18:10,610
a real really excellent talk

1994
01:18:10,610 --> 01:18:14,719
[Applause]

1995
01:18:14,719 --> 01:18:18,480
uh does anybody have any comments uh or

1996
01:18:18,480 --> 01:18:22,919
questions about this talk

1997
01:18:27,760 --> 01:18:29,679
a couple of minutes to come up maybe i

1998
01:18:29,679 --> 01:18:31,120
think one one of the the things which

1999
01:18:31,120 --> 01:18:32,640
interested me about the work is is that

2000
01:18:32,640 --> 01:18:34,480
it really nicely complements the the

2001
01:18:34,480 --> 01:18:37,120
previous talk and that we we have

2002
01:18:37,120 --> 01:18:38,640
you you're modeling aspects of the

2003
01:18:38,640 --> 01:18:40,239
protocol which are not not perhaps

2004
01:18:40,239 --> 01:18:42,960
captured by the finite state machines

2005
01:18:42,960 --> 01:18:45,520
and so there's a nice complement between

2006
01:18:45,520 --> 01:18:48,000
the two

2007
01:18:49,040 --> 01:18:49,320
um

2008
01:18:49,320 --> 01:18:50,640
[Music]

2009
01:18:50,640 --> 01:18:55,199
one question for me i mean you um

2010
01:18:55,199 --> 01:18:57,760
you know your you know but both this

2011
01:18:57,760 --> 01:19:00,159
this this mechanism and the the

2012
01:19:00,159 --> 01:19:02,000
mechanisms you've developed and the

2013
01:19:02,000 --> 01:19:03,920
mechanisms and the previous talk are all

2014
01:19:03,920 --> 01:19:06,320
based around natural language processing

2015
01:19:06,320 --> 01:19:09,920
and so on um how how expensive are they

2016
01:19:09,920 --> 01:19:12,159
to run how what was the sort of runtime

2017
01:19:12,159 --> 01:19:13,600
for these models

2018
01:19:13,600 --> 01:19:16,560
um the round-time is um longs for

2019
01:19:16,560 --> 01:19:20,320
processing the icmp rfc it contains

2020
01:19:20,320 --> 01:19:21,280
um

2021
01:19:21,280 --> 01:19:23,840
seven oh sorry i forgot the exact number

2022
01:19:23,840 --> 01:19:27,040
messages but to to process that whole

2023
01:19:27,040 --> 01:19:31,840
rfc is runs for about five minutes

2024
01:19:32,080 --> 01:19:33,920
okay so so so it's it's not

2025
01:19:33,920 --> 01:19:35,760
instantaneous but it's not

2026
01:19:35,760 --> 01:19:39,840
crazy long yeah okay yes good because um

2027
01:19:39,840 --> 01:19:43,679
part of the complexity is due to

2028
01:19:43,679 --> 01:19:44,480
the

2029
01:19:44,480 --> 01:19:47,840
the lp parser that it has to analyze how

2030
01:19:47,840 --> 01:19:50,159
many different kinds of

2031
01:19:50,159 --> 01:19:52,320
way to

2032
01:19:52,320 --> 01:19:54,960
generate the semantic representation so

2033
01:19:54,960 --> 01:19:57,760
there are ones that you have a so for

2034
01:19:57,760 --> 01:20:00,880
example if you have a noun phrase that

2035
01:20:00,880 --> 01:20:03,600
can be interpreted in multiple ways then

2036
01:20:03,600 --> 01:20:06,880
all of them have to get enumerated um to

2037
01:20:06,880 --> 01:20:09,120
generate the representation so that

2038
01:20:09,120 --> 01:20:11,440
takes uh that takes the majority of the

2039
01:20:11,440 --> 01:20:13,040
time

2040
01:20:13,040 --> 01:20:14,880
yeah okay makes sense all right thank

2041
01:20:14,880 --> 01:20:15,840
you

2042
01:20:15,840 --> 01:20:17,360
uh

2043
01:20:17,360 --> 01:20:19,120
folk i guess

2044
01:20:19,120 --> 01:20:20,960
here in the room

2045
01:20:20,960 --> 01:20:23,120
yes i am

2046
01:20:23,120 --> 01:20:25,600
uh thanks well okay maybe i'm a little

2047
01:20:25,600 --> 01:20:27,520
bit sidetracking

2048
01:20:27,520 --> 01:20:28,040
um

2049
01:20:28,040 --> 01:20:30,400
[Music]

2050
01:20:30,400 --> 01:20:33,600
with the comments to start towards colin

2051
01:20:33,600 --> 01:20:37,040
colin you said well okay we are used to

2052
01:20:37,040 --> 01:20:40,080
do the specifications in english prose

2053
01:20:40,080 --> 01:20:43,199
well okay kind of uh one some sometimes

2054
01:20:43,199 --> 01:20:43,920
we

2055
01:20:43,920 --> 01:20:46,320
enhance the specifications by some

2056
01:20:46,320 --> 01:20:49,440
formal stuff

2057
01:20:49,920 --> 01:20:51,760
i would not

2058
01:20:51,760 --> 01:20:53,920
consider ascii art

2059
01:20:53,920 --> 01:20:56,880
as a real formal

2060
01:20:56,880 --> 01:21:00,000
enhancements of the rfcs but they are in

2061
01:21:00,000 --> 01:21:02,040
there and in the iec

2062
01:21:02,040 --> 01:21:05,199
icmprcs obviously

2063
01:21:05,199 --> 01:21:06,400
and

2064
01:21:06,400 --> 01:21:07,600
kind of

2065
01:21:07,600 --> 01:21:09,199
i wonder

2066
01:21:09,199 --> 01:21:11,440
how does the nlp

2067
01:21:11,440 --> 01:21:15,199
actually deal with stuff like that

2068
01:21:15,199 --> 01:21:17,840
are you are you kind of doing the manual

2069
01:21:17,840 --> 01:21:20,400
transformation to

2070
01:21:20,400 --> 01:21:23,599
reasonable data

2071
01:21:24,480 --> 01:21:27,120
data structure definitions

2072
01:21:27,120 --> 01:21:28,480
by hand

2073
01:21:28,480 --> 01:21:32,080
and continue from there or

2074
01:21:32,080 --> 01:21:35,040
the other way or ask around

2075
01:21:35,040 --> 01:21:36,239
would

2076
01:21:36,239 --> 01:21:37,120
it

2077
01:21:37,120 --> 01:21:39,679
actually help you

2078
01:21:39,679 --> 01:21:42,400
to have in the rfcs

2079
01:21:42,400 --> 01:21:43,840
more formal

2080
01:21:43,840 --> 01:21:46,639
and more modern ways of specifications

2081
01:21:46,639 --> 01:21:50,639
of the relevant data structures

2082
01:21:52,320 --> 01:21:55,440
okay so for the ascii arts

2083
01:21:55,440 --> 01:21:56,400
parts

2084
01:21:56,400 --> 01:22:00,159
um we didn't we didn't use the nlp

2085
01:22:00,159 --> 01:22:03,920
parts lv tool to parse that um instead

2086
01:22:03,920 --> 01:22:07,040
we parse the ascii art of the packet

2087
01:22:07,040 --> 01:22:10,560
header by writing another small program

2088
01:22:10,560 --> 01:22:13,199
to parse it and it can automatically

2089
01:22:13,199 --> 01:22:15,440
extract the structure the the packet

2090
01:22:15,440 --> 01:22:18,159
header structure so that's one of it

2091
01:22:18,159 --> 01:22:21,600
and um i just want to address in another

2092
01:22:21,600 --> 01:22:23,280
perspective is

2093
01:22:23,280 --> 01:22:25,760
as our current work is

2094
01:22:25,760 --> 01:22:27,760
trying to extract the essential

2095
01:22:27,760 --> 01:22:30,560
information out of it by by looking at

2096
01:22:30,560 --> 01:22:32,320
those essential information we are

2097
01:22:32,320 --> 01:22:34,159
thinking not only to generate the

2098
01:22:34,159 --> 01:22:36,639
english text or the executable code we

2099
01:22:36,639 --> 01:22:39,199
also are thinking we are also thinking

2100
01:22:39,199 --> 01:22:40,080
to

2101
01:22:40,080 --> 01:22:42,159
use those information to generate the

2102
01:22:42,159 --> 01:22:45,120
diagram automatically so that's in the

2103
01:22:45,120 --> 01:22:48,239
future we can we expect that

2104
01:22:48,239 --> 01:22:50,800
the authors can directly compare the

2105
01:22:50,800 --> 01:22:52,400
diagram

2106
01:22:52,400 --> 01:22:54,320
or it can automatically

2107
01:22:54,320 --> 01:22:57,760
use the diagram generated in the rfc so

2108
01:22:57,760 --> 01:23:01,280
that it can help illustrate the idea so

2109
01:23:01,280 --> 01:23:06,120
i hope that and answer your question

2110
01:23:08,639 --> 01:23:11,600
yeah okay good good great thank you uh

2111
01:23:11,600 --> 01:23:15,120
jonathan highland i guess

2112
01:23:15,440 --> 01:23:16,880
hi and

2113
01:23:16,880 --> 01:23:18,560
that was a really interesting talk thank

2114
01:23:18,560 --> 01:23:20,639
you um

2115
01:23:20,639 --> 01:23:23,199
i was just sitting there thinking

2116
01:23:23,199 --> 01:23:25,120
wouldn't it be easier

2117
01:23:25,120 --> 01:23:28,239
for us to formally specify protocols

2118
01:23:28,239 --> 01:23:31,199
and then use some tool with nlp

2119
01:23:31,199 --> 01:23:33,760
to generate the pros spec

2120
01:23:33,760 --> 01:23:35,679
and then we can be sure that the pro

2121
01:23:35,679 --> 01:23:36,800
spec

2122
01:23:36,800 --> 01:23:39,440
actually implements the uh formal

2123
01:23:39,440 --> 01:23:41,440
specification and then we can check the

2124
01:23:41,440 --> 01:23:43,920
formal specification

2125
01:23:43,920 --> 01:23:45,920
yeah so uh i

2126
01:23:45,920 --> 01:23:49,920
agree that is also one way to do that um

2127
01:23:49,920 --> 01:23:52,719
the thing is we have to gap we we have

2128
01:23:52,719 --> 01:23:56,400
to fill in the gap of uh how to convert

2129
01:23:56,400 --> 01:23:59,440
between the former specification um a

2130
01:23:59,440 --> 01:24:02,159
formal language um former specific

2131
01:24:02,159 --> 01:24:04,159
specific engineering language to the

2132
01:24:04,159 --> 01:24:07,360
english text so that part is still

2133
01:24:07,360 --> 01:24:10,560
missing over there and um it's

2134
01:24:10,560 --> 01:24:13,440
and i think there's one problem over

2135
01:24:13,440 --> 01:24:15,760
here is there are too many different

2136
01:24:15,760 --> 01:24:18,080
kinds of intermediate representations so

2137
01:24:18,080 --> 01:24:20,320
formal specification language is sort of

2138
01:24:20,320 --> 01:24:22,880
like another intermediate representation

2139
01:24:22,880 --> 01:24:24,719
um you can always choose like different

2140
01:24:24,719 --> 01:24:26,639
ones and then try to

2141
01:24:26,639 --> 01:24:29,120
fill in the gap from the english text to

2142
01:24:29,120 --> 01:24:32,080
that representation so i i would say

2143
01:24:32,080 --> 01:24:34,719
that is totally a doable and

2144
01:24:34,719 --> 01:24:38,080
actually a good way to go from it um but

2145
01:24:38,080 --> 01:24:41,199
our first work stage is to just directly

2146
01:24:41,199 --> 01:24:44,080
choose a simpler way to do the first

2147
01:24:44,080 --> 01:24:46,159
first step to analyze whether we can

2148
01:24:46,159 --> 01:24:48,000
find some ambiguities

2149
01:24:48,000 --> 01:24:51,280
but for further specification i agree

2150
01:24:51,280 --> 01:24:52,239
that's

2151
01:24:52,239 --> 01:24:54,639
writing a formal specification language

2152
01:24:54,639 --> 01:24:56,800
and then

2153
01:24:56,800 --> 01:24:58,719
and then generate the english text might

2154
01:24:58,719 --> 01:25:02,080
be also a very doable way um but i think

2155
01:25:02,080 --> 01:25:04,320
we start from like a smaller

2156
01:25:04,320 --> 01:25:06,080
um scope

2157
01:25:06,080 --> 01:25:08,800
from the state machine to just have some

2158
01:25:08,800 --> 01:25:10,719
like simpler

2159
01:25:10,719 --> 01:25:13,440
probably some uh simpler language

2160
01:25:13,440 --> 01:25:15,760
english text language and just to

2161
01:25:15,760 --> 01:25:18,400
generate a very cool

2162
01:25:18,400 --> 01:25:21,920
uh cruel simple english text um but we

2163
01:25:21,920 --> 01:25:24,400
have to see whether that is a good

2164
01:25:24,400 --> 01:25:27,199
approach first otherwise that we are not

2165
01:25:27,199 --> 01:25:28,800
sure whether we should go from the

2166
01:25:28,800 --> 01:25:31,040
formal specification language to the

2167
01:25:31,040 --> 01:25:33,040
english text because formal

2168
01:25:33,040 --> 01:25:35,120
specification specification language

2169
01:25:35,120 --> 01:25:36,719
text um

2170
01:25:36,719 --> 01:25:39,040
i believe it's more you need to take

2171
01:25:39,040 --> 01:25:40,560
some time to

2172
01:25:40,560 --> 01:25:42,880
learn and to pick up and then to do

2173
01:25:42,880 --> 01:25:45,520
those things but if we just

2174
01:25:45,520 --> 01:25:47,600
extract the essential information like

2175
01:25:47,600 --> 01:25:49,760
just some key value pairs and we can

2176
01:25:49,760 --> 01:25:51,840
just directly go from those information

2177
01:25:51,840 --> 01:25:54,239
and generate text that might be also

2178
01:25:54,239 --> 01:25:57,839
another good way to go yeah

2179
01:25:59,280 --> 01:26:00,400
thank you

2180
01:26:00,400 --> 01:26:02,159
great great thank you

2181
01:26:02,159 --> 01:26:04,239
i'm conscious that we we have one more

2182
01:26:04,239 --> 01:26:06,320
talk and we're running a little little

2183
01:26:06,320 --> 01:26:08,880
behind time so uh again thank you again

2184
01:26:08,880 --> 01:26:11,800
jane was that really excellent

2185
01:26:11,800 --> 01:26:16,480
[Applause]

2186
01:26:16,480 --> 01:26:19,360
all right thank you the next speaker is

2187
01:26:19,360 --> 01:26:23,239
uh chris wood

2188
01:26:23,280 --> 01:26:26,159
who i believe is there in person is that

2189
01:26:26,159 --> 01:26:28,400
right

2190
01:26:33,120 --> 01:26:35,280
yeah hello um

2191
01:26:35,280 --> 01:26:36,639
trying to figure out how to control this

2192
01:26:36,639 --> 01:26:38,159
remotely

2193
01:26:38,159 --> 01:26:40,800
all right i shouldn't theory have passed

2194
01:26:40,800 --> 01:26:42,239
you control

2195
01:26:42,239 --> 01:26:45,440
great i got it

2196
01:26:45,920 --> 01:26:48,000
all right so to you chris

2197
01:26:48,000 --> 01:26:49,840
all right thanks all right everyone uh

2198
01:26:49,840 --> 01:26:52,320
my name is chris wood do some

2199
01:26:52,320 --> 01:26:55,120
uh work a number of places in the ietf

2200
01:26:55,120 --> 01:26:58,560
uh in particular in um the cfrg as a as

2201
01:26:58,560 --> 01:27:00,239
of i guess recently

2202
01:27:00,239 --> 01:27:01,840
uh do

2203
01:27:01,840 --> 01:27:03,199
i help out

2204
01:27:03,199 --> 01:27:05,120
producing technical specifications for

2205
01:27:05,120 --> 01:27:06,639
that particular group

2206
01:27:06,639 --> 01:27:08,000
and uh

2207
01:27:08,000 --> 01:27:09,280
what i'm going to try to talk to you

2208
01:27:09,280 --> 01:27:10,560
about is

2209
01:27:10,560 --> 01:27:13,679
i think a problem that has been emerging

2210
01:27:13,679 --> 01:27:16,320
in that particular group which is not

2211
01:27:16,320 --> 01:27:18,320
it's not only in the cfrg it exists

2212
01:27:18,320 --> 01:27:20,480
elsewhere um

2213
01:27:20,480 --> 01:27:23,199
and uh it's on it's on this topic of you

2214
01:27:23,199 --> 01:27:25,679
know uh how how can we improve the

2215
01:27:25,679 --> 01:27:28,480
quality of specifications um in in in

2216
01:27:28,480 --> 01:27:30,960
the cfrg and elsewhere in the ietf and

2217
01:27:30,960 --> 01:27:33,199
irtf

2218
01:27:33,199 --> 01:27:36,159
and uh i should say first and foremost

2219
01:27:36,159 --> 01:27:38,560
that this is very much based on you know

2220
01:27:38,560 --> 01:27:40,639
my own personal experience writing these

2221
01:27:40,639 --> 01:27:42,320
things trying to

2222
01:27:42,320 --> 01:27:43,199
like

2223
01:27:43,199 --> 01:27:45,280
communicate technical

2224
01:27:45,280 --> 01:27:47,360
things in a way that's clear and concise

2225
01:27:47,360 --> 01:27:48,639
to people

2226
01:27:48,639 --> 01:27:50,480
i've not not like talked about this with

2227
01:27:50,480 --> 01:27:52,880
many other people i've not like asked

2228
01:27:52,880 --> 01:27:55,520
for a review on the slides so i uh you

2229
01:27:55,520 --> 01:27:56,960
know if you disagree that's cool we

2230
01:27:56,960 --> 01:27:58,239
should talk about it

2231
01:27:58,239 --> 01:27:59,120
um

2232
01:27:59,120 --> 01:28:01,920
and uh this does not like consensus of

2233
01:28:01,920 --> 01:28:04,320
the cfrg in any way particular or any

2234
01:28:04,320 --> 01:28:06,320
any way shape or form also i'm not

2235
01:28:06,320 --> 01:28:08,159
trying to like point fingers or blame

2236
01:28:08,159 --> 01:28:10,000
people and in fact i like i work on a

2237
01:28:10,000 --> 01:28:11,280
lot of documents so i should just be

2238
01:28:11,280 --> 01:28:13,679
pointing the fingers at myself

2239
01:28:13,679 --> 01:28:15,440
i really want to see if there's a way a

2240
01:28:15,440 --> 01:28:17,199
reasonable way forward for the itf and

2241
01:28:17,199 --> 01:28:18,880
the irtf to

2242
01:28:18,880 --> 01:28:20,639
improve the the overall quality of the

2243
01:28:20,639 --> 01:28:22,320
outputs

2244
01:28:22,320 --> 01:28:25,120
and so this is an attempt to do that

2245
01:28:25,120 --> 01:28:26,400
okay

2246
01:28:26,400 --> 01:28:27,840
so i'm going to start with what i think

2247
01:28:27,840 --> 01:28:30,639
is sort of the the problem um or

2248
01:28:30,639 --> 01:28:32,800
maybe it's not a problem but i

2249
01:28:32,800 --> 01:28:34,960
depending on your perspective but i'm

2250
01:28:34,960 --> 01:28:38,159
i'm going to refer to it as a problem

2251
01:28:38,560 --> 01:28:42,560
so in in theory the cfrg is is uh is

2252
01:28:42,560 --> 01:28:43,760
chartered to do

2253
01:28:43,760 --> 01:28:44,960
um

2254
01:28:44,960 --> 01:28:47,679
a lot of things it's pretty broads broke

2255
01:28:47,679 --> 01:28:50,800
uh uh pretty broad charter um

2256
01:28:50,800 --> 01:28:52,560
you could summarize it in the sentence

2257
01:28:52,560 --> 01:28:54,320
that i have sort of coded here it's

2258
01:28:54,320 --> 01:28:56,560
meant to sort of effectively bridge

2259
01:28:56,560 --> 01:28:58,159
things that happen

2260
01:28:58,159 --> 01:29:00,719
in in academia in theory and sort of

2261
01:29:00,719 --> 01:29:03,679
bring them into practice um documenting

2262
01:29:03,679 --> 01:29:04,960
things that like are written down in

2263
01:29:04,960 --> 01:29:08,080
cryptographic like related papers or and

2264
01:29:08,080 --> 01:29:11,040
published in conferences and whatnot and

2265
01:29:11,040 --> 01:29:12,800
present them in a way that people can

2266
01:29:12,800 --> 01:29:14,639
actually use them

2267
01:29:14,639 --> 01:29:17,120
and to do so via what are referred to as

2268
01:29:17,120 --> 01:29:19,600
informational rfcs

2269
01:29:19,600 --> 01:29:22,000
an informational rfc

2270
01:29:22,000 --> 01:29:22,719
just

2271
01:29:22,719 --> 01:29:25,040
contains information does not go through

2272
01:29:25,040 --> 01:29:28,960
the same sort of uh like editorial or or

2273
01:29:28,960 --> 01:29:30,800
rather review process the same sort of

2274
01:29:30,800 --> 01:29:35,840
rigor that other things in the ietf and

2275
01:29:35,840 --> 01:29:37,760
elsewhere go through

2276
01:29:37,760 --> 01:29:40,320
so that sort of bar to publication of an

2277
01:29:40,320 --> 01:29:42,960
informational rfc has like historically

2278
01:29:42,960 --> 01:29:45,280
been lower than that of like a standard

2279
01:29:45,280 --> 01:29:48,480
track or proposed standard

2280
01:29:48,719 --> 01:29:49,760
that's

2281
01:29:49,760 --> 01:29:51,760
kind of a problem because

2282
01:29:51,760 --> 01:29:54,400
in practice the cfrd specifications i

2283
01:29:54,400 --> 01:29:56,960
think demand a much much higher bar

2284
01:29:56,960 --> 01:29:58,880
uh for what they're actually

2285
01:29:58,880 --> 01:30:01,360
being used for you you could

2286
01:30:01,360 --> 01:30:04,000
go back and look at all the many of this

2287
01:30:04,000 --> 01:30:06,080
many of the specifications or rfcs that

2288
01:30:06,080 --> 01:30:08,320
came from the cfrg

2289
01:30:08,320 --> 01:30:10,560
and look at how often they're used and

2290
01:30:10,560 --> 01:30:12,239
referenced in practice

2291
01:30:12,239 --> 01:30:13,679
and it should be very clear that these

2292
01:30:13,679 --> 01:30:15,760
are very very important documents like

2293
01:30:15,760 --> 01:30:18,239
things like hmac hkdf

2294
01:30:18,239 --> 01:30:21,199
uh crypto9 eddsa

2295
01:30:21,199 --> 01:30:24,159
and hpke that's a recent one um

2296
01:30:24,159 --> 01:30:26,639
these are all like fundamental to how

2297
01:30:26,639 --> 01:30:30,320
the ietf and even other irtf groups

2298
01:30:30,320 --> 01:30:33,760
design reason about and build protocols

2299
01:30:33,760 --> 01:30:37,440
the security protocols in particular

2300
01:30:37,679 --> 01:30:39,760
moreover these specifications that are

2301
01:30:39,760 --> 01:30:42,960
developed have a huge audience

2302
01:30:42,960 --> 01:30:44,719
they are meant to

2303
01:30:44,719 --> 01:30:46,480
be useful to people who are designing

2304
01:30:46,480 --> 01:30:47,679
protocols they want to be able to

2305
01:30:47,679 --> 01:30:49,920
consume these cryptographic objects

2306
01:30:49,920 --> 01:30:52,239
um they're also useful to people

2307
01:30:52,239 --> 01:30:53,679
reviewing these particular

2308
01:30:53,679 --> 01:30:55,120
specifications to make sure they're

2309
01:30:55,120 --> 01:30:56,560
consistent with things that have been

2310
01:30:56,560 --> 01:30:59,440
like analyzed and proved in practice

2311
01:30:59,440 --> 01:31:01,040
and there's probably lots of other

2312
01:31:01,040 --> 01:31:02,880
audiences as well

2313
01:31:02,880 --> 01:31:04,480
but the gist is that

2314
01:31:04,480 --> 01:31:06,639
uh the the stakes are very high i think

2315
01:31:06,639 --> 01:31:08,159
for the things that the cfrg does

2316
01:31:08,159 --> 01:31:10,480
despite what the charter lists um so

2317
01:31:10,480 --> 01:31:14,880
quality of its outputs is is critical um

2318
01:31:14,880 --> 01:31:18,320
and uh so

2319
01:31:19,440 --> 01:31:21,520
i'm going to be trying to focus on like

2320
01:31:21,520 --> 01:31:24,719
specification quality here um

2321
01:31:24,719 --> 01:31:27,360
and uh what do i mean by specification

2322
01:31:27,360 --> 01:31:28,840
quality

2323
01:31:28,840 --> 01:31:32,719
so i i claim that there are at least

2324
01:31:32,719 --> 01:31:35,120
three sort of fundamental aspects of a

2325
01:31:35,120 --> 01:31:37,360
technical specification first of which

2326
01:31:37,360 --> 01:31:39,440
is like the functional piece of it like

2327
01:31:39,440 --> 01:31:41,600
what does this thing do

2328
01:31:41,600 --> 01:31:44,480
and cfrg is actually kind of

2329
01:31:44,480 --> 01:31:46,400
it's quite uh

2330
01:31:46,400 --> 01:31:48,719
nice in that like typically the things

2331
01:31:48,719 --> 01:31:50,880
that it works on are much much simpler

2332
01:31:50,880 --> 01:31:52,400
compared to protocols that the ietf

2333
01:31:52,400 --> 01:31:54,000
standardizes so

2334
01:31:54,000 --> 01:31:55,520
it was only until i guess recently that

2335
01:31:55,520 --> 01:31:57,360
we actually started looking at real

2336
01:31:57,360 --> 01:31:58,880
protocols that involve like sending

2337
01:31:58,880 --> 01:32:01,440
messages between different parties um

2338
01:32:01,440 --> 01:32:02,719
historically it's just been like you

2339
01:32:02,719 --> 01:32:04,719
know an algorithm specifying algorithm

2340
01:32:04,719 --> 01:32:06,560
that has some steps and an api and a

2341
01:32:06,560 --> 01:32:09,679
syntax and stuff like that

2342
01:32:09,679 --> 01:32:10,880
so i'm just going to refer to these

2343
01:32:10,880 --> 01:32:12,960
things as objects

2344
01:32:12,960 --> 01:32:14,800
and the the functional description of

2345
01:32:14,800 --> 01:32:16,480
this object is you know what does it do

2346
01:32:16,480 --> 01:32:18,320
what's purpose what is its purpose like

2347
01:32:18,320 --> 01:32:20,159
i just kind of want to reason about how

2348
01:32:20,159 --> 01:32:21,760
i might use and hold this particular

2349
01:32:21,760 --> 01:32:23,360
thing

2350
01:32:23,360 --> 01:32:26,320
the second part or a second part is what

2351
01:32:26,320 --> 01:32:28,639
i refer to as the syntax specification

2352
01:32:28,639 --> 01:32:31,199
and it's like how do i what does its api

2353
01:32:31,199 --> 01:32:32,960
look like how would i interact with it

2354
01:32:32,960 --> 01:32:34,480
if i were to implement this in like a

2355
01:32:34,480 --> 01:32:36,320
type safe language what would that api

2356
01:32:36,320 --> 01:32:38,960
look like and how might i enforce it

2357
01:32:38,960 --> 01:32:42,400
and the third uh component is like the

2358
01:32:42,400 --> 01:32:45,600
actual implementation like how do i how

2359
01:32:45,600 --> 01:32:47,440
would i write code

2360
01:32:47,440 --> 01:32:49,920
to implement this particular algorithm

2361
01:32:49,920 --> 01:32:51,920
and to do so correctly

2362
01:32:51,920 --> 01:32:53,280
um

2363
01:32:53,280 --> 01:32:55,360
and keeping in mind the different

2364
01:32:55,360 --> 01:32:58,880
audiences that were listed earlier

2365
01:32:58,880 --> 01:33:00,400
it's important to make sure that each of

2366
01:33:00,400 --> 01:33:01,920
these different

2367
01:33:01,920 --> 01:33:03,440
components of a specification are

2368
01:33:03,440 --> 01:33:05,040
tailored to the relevant audiences so

2369
01:33:05,040 --> 01:33:06,239
for example the implementation

2370
01:33:06,239 --> 01:33:07,840
specifications would be written such

2371
01:33:07,840 --> 01:33:09,600
that implementers can actually use it

2372
01:33:09,600 --> 01:33:11,280
and implement the thing correctly

2373
01:33:11,280 --> 01:33:12,960
whereas like the functional piece of a

2374
01:33:12,960 --> 01:33:14,560
particular specification needs to be

2375
01:33:14,560 --> 01:33:16,400
written such that people who want to

2376
01:33:16,400 --> 01:33:18,320
just figure out what this thing is doing

2377
01:33:18,320 --> 01:33:20,080
can do so without having to understand

2378
01:33:20,080 --> 01:33:21,920
the implementation details like you

2379
01:33:21,920 --> 01:33:23,679
shouldn't have to be a cryptographer to

2380
01:33:23,679 --> 01:33:26,159
understand like what an rsa signature is

2381
01:33:26,159 --> 01:33:28,560
or whatever like that these are like

2382
01:33:28,560 --> 01:33:30,719
simple concepts and

2383
01:33:30,719 --> 01:33:32,400
people building these protocols in the

2384
01:33:32,400 --> 01:33:33,920
ietf

2385
01:33:33,920 --> 01:33:35,440
should not have to be experts to use

2386
01:33:35,440 --> 01:33:37,120
them they should be like easy to use

2387
01:33:37,120 --> 01:33:38,800
hard to misuse that sort of thing blah

2388
01:33:38,800 --> 01:33:41,120
blah blah

2389
01:33:41,679 --> 01:33:43,040
okay

2390
01:33:43,040 --> 01:33:43,840
um

2391
01:33:43,840 --> 01:33:45,040
and to

2392
01:33:45,040 --> 01:33:46,719
figure out whether or not you know the

2393
01:33:46,719 --> 01:33:49,280
the the specification or the the

2394
01:33:49,280 --> 01:33:50,800
different components of a specification

2395
01:33:50,800 --> 01:33:54,080
written satisfy these like these goals

2396
01:33:54,080 --> 01:33:55,280
there's like

2397
01:33:55,280 --> 01:33:56,719
there's like questions you can ask

2398
01:33:56,719 --> 01:33:58,880
yourself as an editor or an author of a

2399
01:33:58,880 --> 01:34:01,199
document

2400
01:34:01,199 --> 01:34:03,440
i think the the first and foremost

2401
01:34:03,440 --> 01:34:05,360
one that comes to mind for me is like is

2402
01:34:05,360 --> 01:34:07,040
the specification

2403
01:34:07,040 --> 01:34:08,480
easy to use

2404
01:34:08,480 --> 01:34:10,400
easy to understand and use like can i

2405
01:34:10,400 --> 01:34:11,920
just like read it and figure out what

2406
01:34:11,920 --> 01:34:13,440
the thing is doing

2407
01:34:13,440 --> 01:34:15,520
can i reason about like the behavior of

2408
01:34:15,520 --> 01:34:17,440
the cryptographic object could i

2409
01:34:17,440 --> 01:34:19,760
reasonably like think about what the api

2410
01:34:19,760 --> 01:34:22,239
might look like and what the exceptional

2411
01:34:22,239 --> 01:34:23,920
cases might be if i try to hold this

2412
01:34:23,920 --> 01:34:26,560
thing the wrong way

2413
01:34:26,560 --> 01:34:28,480
second most important question is like

2414
01:34:28,480 --> 01:34:30,159
if i'm reading this thing and i were to

2415
01:34:30,159 --> 01:34:31,760
try to do a faithful implementation of

2416
01:34:31,760 --> 01:34:34,159
it would i produce a consistent and

2417
01:34:34,159 --> 01:34:36,159
correct implementation that i could

2418
01:34:36,159 --> 01:34:37,760
interoperate with other people's

2419
01:34:37,760 --> 01:34:40,560
implementations

2420
01:34:40,639 --> 01:34:42,719
and that depends on you know the

2421
01:34:42,719 --> 01:34:44,480
behavior being well defined it depends

2422
01:34:44,480 --> 01:34:45,920
on the implementation description being

2423
01:34:45,920 --> 01:34:47,360
clear and so on

2424
01:34:47,360 --> 01:34:49,280
um and

2425
01:34:49,280 --> 01:34:50,880
lots of other questions i'm sure would

2426
01:34:50,880 --> 01:34:53,280
come up to to try to figure out whether

2427
01:34:53,280 --> 01:34:56,960
or not you're on the right track

2428
01:34:57,520 --> 01:34:59,280
so i want to look at a couple examples

2429
01:34:59,280 --> 01:35:01,760
um that uh

2430
01:35:01,760 --> 01:35:05,119
the the the cfrg has done um

2431
01:35:05,119 --> 01:35:07,679
and to try to uh reason about these two

2432
01:35:07,679 --> 01:35:09,040
high-level questions is the

2433
01:35:09,040 --> 01:35:11,440
specification easy to use and understand

2434
01:35:11,440 --> 01:35:13,040
and will it yield consistent and correct

2435
01:35:13,040 --> 01:35:15,600
implementations and i picked on an rfc

2436
01:35:15,600 --> 01:35:17,520
that gets picked on a lot

2437
01:35:17,520 --> 01:35:20,239
rfc 8032 for addsa

2438
01:35:20,239 --> 01:35:21,760
has this uh

2439
01:35:21,760 --> 01:35:24,560
one component of the draft specifies how

2440
01:35:24,560 --> 01:35:27,920
you like verify digital signatures um

2441
01:35:27,920 --> 01:35:30,320
don't need to read this

2442
01:35:30,320 --> 01:35:32,639
in fact uh i encourage you not to read

2443
01:35:32,639 --> 01:35:34,159
it because you might get bored but i

2444
01:35:34,159 --> 01:35:36,719
will just note that in this this final

2445
01:35:36,719 --> 01:35:39,360
piece of this particular body of text

2446
01:35:39,360 --> 01:35:42,000
they have something like

2447
01:35:42,000 --> 01:35:43,040
you could do

2448
01:35:43,040 --> 01:35:44,960
or we recommend you do this one thing

2449
01:35:44,960 --> 01:35:47,600
for correctness and security and safety

2450
01:35:47,600 --> 01:35:49,360
but maybe if you're feeling up for it

2451
01:35:49,360 --> 01:35:52,159
maybe you do this other thing instead um

2452
01:35:52,159 --> 01:35:54,159
and it turns out that has been the cause

2453
01:35:54,159 --> 01:35:55,679
of tremendous amount of pain and

2454
01:35:55,679 --> 01:35:57,119
practice it's been the cause of like

2455
01:35:57,119 --> 01:35:59,280
security problems in practice

2456
01:35:59,280 --> 01:35:59,590
um

2457
01:35:59,590 --> 01:36:00,719
[Music]

2458
01:36:00,719 --> 01:36:02,320
people just don't agree on like what

2459
01:36:02,320 --> 01:36:04,639
signatures are valid and that's that's

2460
01:36:04,639 --> 01:36:06,719
probably not a desirable property for a

2461
01:36:06,719 --> 01:36:08,400
digital signature scheme

2462
01:36:08,400 --> 01:36:11,280
so i would claim um

2463
01:36:11,280 --> 01:36:12,159
that

2464
01:36:12,159 --> 01:36:14,159
uh to answer the first question like

2465
01:36:14,159 --> 01:36:15,840
yeah the specification is easy to use

2466
01:36:15,840 --> 01:36:17,280
and understand like it's actually a

2467
01:36:17,280 --> 01:36:18,480
really well written technical

2468
01:36:18,480 --> 01:36:19,840
specification

2469
01:36:19,840 --> 01:36:20,719
um

2470
01:36:20,719 --> 01:36:22,800
but was it written in such a way that it

2471
01:36:22,800 --> 01:36:23,920
yields consistent and correct

2472
01:36:23,920 --> 01:36:27,199
implementations unfortunately not um and

2473
01:36:27,199 --> 01:36:28,320
uh

2474
01:36:28,320 --> 01:36:30,400
just my own personal opinion like i said

2475
01:36:30,400 --> 01:36:31,840
if you disagree with any of this that's

2476
01:36:31,840 --> 01:36:35,040
fine we could talk about it

2477
01:36:36,560 --> 01:36:38,400
okay another example is actually an

2478
01:36:38,400 --> 01:36:39,760
ongoing specification that's being

2479
01:36:39,760 --> 01:36:41,600
developed right now uh this thing called

2480
01:36:41,600 --> 01:36:43,360
opaque um

2481
01:36:43,360 --> 01:36:46,239
opaque is uh

2482
01:36:46,400 --> 01:36:48,320
without describing what these terms are

2483
01:36:48,320 --> 01:36:52,400
it's uh basically um it's a compiler for

2484
01:36:52,400 --> 01:36:54,159
taking a bunch of different pieces or a

2485
01:36:54,159 --> 01:36:55,360
bunch of different cryptographic

2486
01:36:55,360 --> 01:36:58,560
algorithms gluing them together and

2487
01:36:58,560 --> 01:37:00,960
the the result is a is a password

2488
01:37:00,960 --> 01:37:03,840
authenticated key exchange protocol

2489
01:37:03,840 --> 01:37:05,199
um

2490
01:37:05,199 --> 01:37:06,560
uh

2491
01:37:06,560 --> 01:37:09,040
conceptually like once you if you

2492
01:37:09,040 --> 01:37:11,440
understand the object and understand the

2493
01:37:11,440 --> 01:37:15,040
protocol it's pretty easy to think about

2494
01:37:15,040 --> 01:37:16,880
unfortunately to like actually

2495
01:37:16,880 --> 01:37:19,440
understand the spec and implement it

2496
01:37:19,440 --> 01:37:21,119
correctly

2497
01:37:21,119 --> 01:37:23,520
you have to understand and be familiar

2498
01:37:23,520 --> 01:37:26,080
with all these other concepts like what

2499
01:37:26,080 --> 01:37:28,239
the authenticate exchange thing is what

2500
01:37:28,239 --> 01:37:29,040
this

2501
01:37:29,040 --> 01:37:32,320
vo prf thing is what what hash to curve

2502
01:37:32,320 --> 01:37:33,600
means what a prime primordial group

2503
01:37:33,600 --> 01:37:34,639
means

2504
01:37:34,639 --> 01:37:35,520
and

2505
01:37:35,520 --> 01:37:37,520
there's other relevant specifications

2506
01:37:37,520 --> 01:37:39,760
not listed here that are likely also in

2507
01:37:39,760 --> 01:37:43,040
this dependency tree um that are like

2508
01:37:43,040 --> 01:37:45,280
necessary to understand opaque

2509
01:37:45,280 --> 01:37:46,560
um

2510
01:37:46,560 --> 01:37:50,719
and uh so i to to to i guess answer the

2511
01:37:50,719 --> 01:37:52,239
two questions i would say that this

2512
01:37:52,239 --> 01:37:54,480
specification is not easy to understand

2513
01:37:54,480 --> 01:37:55,520
and use

2514
01:37:55,520 --> 01:37:56,400
um

2515
01:37:56,400 --> 01:37:57,520
uh

2516
01:37:57,520 --> 01:37:59,520
and will yield correct and consistent

2517
01:37:59,520 --> 01:38:01,920
implementations uh their stress factors

2518
01:38:01,920 --> 01:38:04,159
and people have done it so maybe that

2519
01:38:04,159 --> 01:38:05,760
that check is a bit biased but maybe

2520
01:38:05,760 --> 01:38:06,800
there should not be a check there

2521
01:38:06,800 --> 01:38:08,080
because it's still an ongoing draft so

2522
01:38:08,080 --> 01:38:09,119
we don't know

2523
01:38:09,119 --> 01:38:09,920
um

2524
01:38:09,920 --> 01:38:11,920
but the takeaway is that like this is an

2525
01:38:11,920 --> 01:38:13,840
incredibly complicated document it could

2526
01:38:13,840 --> 01:38:16,320
be much potentially be much simpler if

2527
01:38:16,320 --> 01:38:18,560
if you try to uh

2528
01:38:18,560 --> 01:38:20,719
change up like what the what the the

2529
01:38:20,719 --> 01:38:23,119
features that were supported are and

2530
01:38:23,119 --> 01:38:25,440
and and whatnot but um

2531
01:38:25,440 --> 01:38:27,280
it's not simple to understand and that's

2532
01:38:27,280 --> 01:38:29,280
not great for security relevant

2533
01:38:29,280 --> 01:38:31,840
protocols

2534
01:38:32,639 --> 01:38:34,719
okay um

2535
01:38:34,719 --> 01:38:36,159
so i think the the

2536
01:38:36,159 --> 01:38:39,760
the the core problem here uh is that

2537
01:38:39,760 --> 01:38:41,360
uh

2538
01:38:41,360 --> 01:38:43,199
the nature of the work that the cfrg

2539
01:38:43,199 --> 01:38:45,360
does is highly technical

2540
01:38:45,360 --> 01:38:47,119
and it's highly technical and has to be

2541
01:38:47,119 --> 01:38:50,320
consumable by like different audiences

2542
01:38:50,320 --> 01:38:51,040
with

2543
01:38:51,040 --> 01:38:53,600
different levels of expertise

2544
01:38:53,600 --> 01:38:54,400
and

2545
01:38:54,400 --> 01:38:56,159
different purposes for consuming that

2546
01:38:56,159 --> 01:38:58,320
technical specification um like an

2547
01:38:58,320 --> 01:38:59,840
implementer just wants to know how to

2548
01:38:59,840 --> 01:39:01,119
implement the thing the protocol

2549
01:39:01,119 --> 01:39:02,560
designer wants to know how to use the

2550
01:39:02,560 --> 01:39:03,360
thing

2551
01:39:03,360 --> 01:39:04,400
um

2552
01:39:04,400 --> 01:39:07,040
and the the problem is like this is a

2553
01:39:07,040 --> 01:39:09,040
hard problem so there's like no way

2554
01:39:09,040 --> 01:39:10,400
around it other than just acknowledging

2555
01:39:10,400 --> 01:39:12,159
that this is a hard problem like writing

2556
01:39:12,159 --> 01:39:14,400
a technical specification that takes all

2557
01:39:14,400 --> 01:39:16,080
of these boxes in such a way that it's

2558
01:39:16,080 --> 01:39:18,080
maximally useful easy to implement and

2559
01:39:18,080 --> 01:39:19,760
correct and consistent

2560
01:39:19,760 --> 01:39:22,320
um is is not an easy thing to do and

2561
01:39:22,320 --> 01:39:23,760
we've been doing it for trying to do it

2562
01:39:23,760 --> 01:39:25,280
for many many years i do think we're

2563
01:39:25,280 --> 01:39:27,280
improving

2564
01:39:27,280 --> 01:39:28,719
but i think there's more that can be

2565
01:39:28,719 --> 01:39:29,840
done

2566
01:39:29,840 --> 01:39:31,360
and

2567
01:39:31,360 --> 01:39:32,880
trying to shine a light on you know

2568
01:39:32,880 --> 01:39:34,080
potentially

2569
01:39:34,080 --> 01:39:37,679
more weight more things that can be done

2570
01:39:38,960 --> 01:39:40,480
so i wanna i wanna

2571
01:39:40,480 --> 01:39:41,520
uh

2572
01:39:41,520 --> 01:39:44,639
call out one particular draft that uh is

2573
01:39:44,639 --> 01:39:46,639
going through the process right now

2574
01:39:46,639 --> 01:39:48,000
uh to

2575
01:39:48,000 --> 01:39:51,520
kind of showcase how we chose to uh

2576
01:39:51,520 --> 01:39:52,800
you know

2577
01:39:52,800 --> 01:39:55,040
structure the specification

2578
01:39:55,040 --> 01:39:56,960
in such a way that it does try to tick

2579
01:39:56,960 --> 01:39:59,600
some of these boxes in what i consider

2580
01:39:59,600 --> 01:40:01,360
to be a useful way for people who are

2581
01:40:01,360 --> 01:40:04,000
consuming the spec

2582
01:40:04,000 --> 01:40:07,600
so this draft called hash to curve

2583
01:40:07,760 --> 01:40:09,600
it is uh

2584
01:40:09,600 --> 01:40:11,119
again without going into any of the math

2585
01:40:11,119 --> 01:40:13,520
details it's basically just like a hash

2586
01:40:13,520 --> 01:40:14,719
function

2587
01:40:14,719 --> 01:40:16,320
uh or it's a specification that

2588
01:40:16,320 --> 01:40:18,159
describes a hash function that takes as

2589
01:40:18,159 --> 01:40:21,520
input arbitrary data a string and

2590
01:40:21,520 --> 01:40:25,280
produces a point on a curve

2591
01:40:25,600 --> 01:40:27,199
and

2592
01:40:27,199 --> 01:40:28,960
that's basically it at the highest of

2593
01:40:28,960 --> 01:40:31,520
levels it's a very simple interface

2594
01:40:31,520 --> 01:40:33,280
it can be summarized in this one picture

2595
01:40:33,280 --> 01:40:34,239
here

2596
01:40:34,239 --> 01:40:35,119
it's

2597
01:40:35,119 --> 01:40:37,840
internal steps are like quite simple

2598
01:40:37,840 --> 01:40:39,600
and

2599
01:40:39,600 --> 01:40:41,760
and and and pretty easy to

2600
01:40:41,760 --> 01:40:43,920
i guess like if if you don't want to

2601
01:40:43,920 --> 01:40:46,080
know more it's it's easy to figure out i

2602
01:40:46,080 --> 01:40:46,960
guess

2603
01:40:46,960 --> 01:40:49,360
uh what what the i guess high level

2604
01:40:49,360 --> 01:40:51,520
functionality is basically from this

2605
01:40:51,520 --> 01:40:52,880
so um

2606
01:40:52,880 --> 01:40:55,360
as i go through next couple slides just

2607
01:40:55,360 --> 01:40:57,360
i guess keep in mind and ask yourself

2608
01:40:57,360 --> 01:40:58,800
you know is

2609
01:40:58,800 --> 01:41:00,239
like based on the limited set of

2610
01:41:00,239 --> 01:41:02,000
information i'm going to present like is

2611
01:41:02,000 --> 01:41:03,360
the specification easy to use and

2612
01:41:03,360 --> 01:41:05,360
understand and will it you'll consistent

2613
01:41:05,360 --> 01:41:08,400
in correct implementations

2614
01:41:08,400 --> 01:41:10,800
okay um so let's consider

2615
01:41:10,800 --> 01:41:14,080
the the functional description of this

2616
01:41:14,080 --> 01:41:17,440
particular specification first that is

2617
01:41:17,440 --> 01:41:18,400
uh

2618
01:41:18,400 --> 01:41:20,000
what the part of the specification

2619
01:41:20,000 --> 01:41:21,360
that's written for the people who just

2620
01:41:21,360 --> 01:41:23,199
want to understand what hashing to curve

2621
01:41:23,199 --> 01:41:24,560
means

2622
01:41:24,560 --> 01:41:25,360
so

2623
01:41:25,360 --> 01:41:27,199
i'm if i'm reading this specification

2624
01:41:27,199 --> 01:41:29,199
for the first time i might go to the

2625
01:41:29,199 --> 01:41:30,639
part of the spec that describes like

2626
01:41:30,639 --> 01:41:32,639
what this functionality is and i come

2627
01:41:32,639 --> 01:41:34,639
across this this

2628
01:41:34,639 --> 01:41:37,040
blurb here that describes hash to curve

2629
01:41:37,040 --> 01:41:38,880
with some input produces an output and

2630
01:41:38,880 --> 01:41:40,480
there's some there's just little there's

2631
01:41:40,480 --> 01:41:42,560
these few steps here

2632
01:41:42,560 --> 01:41:44,239
okay but maybe i want to know like what

2633
01:41:44,239 --> 01:41:45,679
these steps are

2634
01:41:45,679 --> 01:41:47,760
helpfully there's like similarly simple

2635
01:41:47,760 --> 01:41:49,760
descriptions in the draft that describe

2636
01:41:49,760 --> 01:41:51,679
each of these different steps

2637
01:41:51,679 --> 01:41:53,119
without any of the implementation

2638
01:41:53,119 --> 01:41:54,400
details like you don't need to

2639
01:41:54,400 --> 01:41:56,480
understand them to figure out like what

2640
01:41:56,480 --> 01:41:59,280
this particular function is doing

2641
01:41:59,280 --> 01:42:01,040
like this this is sufficient i would

2642
01:42:01,040 --> 01:42:02,960
claim for understanding what like the

2643
01:42:02,960 --> 01:42:05,920
function of hash to curve is doing

2644
01:42:05,920 --> 01:42:07,040
um

2645
01:42:07,040 --> 01:42:09,040
and i think that's like a good balance

2646
01:42:09,040 --> 01:42:13,239
for this particular audience

2647
01:42:14,000 --> 01:42:16,320
now let's consider the api designer

2648
01:42:16,320 --> 01:42:18,480
so an api designer looks at the same you

2649
01:42:18,480 --> 01:42:19,199
know

2650
01:42:19,199 --> 01:42:21,199
section of text

2651
01:42:21,199 --> 01:42:23,600
it sees like oh there's this uh there's

2652
01:42:23,600 --> 01:42:25,600
this thing called map to curve

2653
01:42:25,600 --> 01:42:27,440
as one of the steps that i have to you

2654
01:42:27,440 --> 01:42:30,559
know invoke when like

2655
01:42:30,960 --> 01:42:32,639
in an implementation of hash to curve

2656
01:42:32,639 --> 01:42:35,520
what is this map to curve thing to do

2657
01:42:35,520 --> 01:42:38,400
there's specific sessions that describe

2658
01:42:38,400 --> 01:42:40,080
what the high level

2659
01:42:40,080 --> 01:42:42,719
syntax and api for hash to curve would

2660
01:42:42,719 --> 01:42:44,800
be for different like curves that you

2661
01:42:44,800 --> 01:42:47,280
might target um i just talked about one

2662
01:42:47,280 --> 01:42:49,520
this alligator two method for one map to

2663
01:42:49,520 --> 01:42:53,040
curve thing it describes basically all

2664
01:42:53,040 --> 01:42:55,440
of the parameters that you might need to

2665
01:42:55,440 --> 01:42:57,760
configure for this particular function

2666
01:42:57,760 --> 01:42:59,679
what are the constants that are relevant

2667
01:42:59,679 --> 01:43:02,080
for this like particular function

2668
01:43:02,080 --> 01:43:03,679
what are the exceptional cases that

2669
01:43:03,679 --> 01:43:05,360
might you might have to specify when

2670
01:43:05,360 --> 01:43:07,280
thinking about an api

2671
01:43:07,280 --> 01:43:10,000
um and

2672
01:43:10,000 --> 01:43:11,280
like this there's this other thing

2673
01:43:11,280 --> 01:43:13,040
called sign of the output but don't

2674
01:43:13,040 --> 01:43:15,840
worry about that um and i've truncated

2675
01:43:15,840 --> 01:43:17,440
some of the like

2676
01:43:17,440 --> 01:43:19,920
text that follows because from a like an

2677
01:43:19,920 --> 01:43:22,400
api perspective this is kind of i would

2678
01:43:22,400 --> 01:43:23,199
say

2679
01:43:23,199 --> 01:43:27,119
mostly what you need um

2680
01:43:27,280 --> 01:43:29,119
okay

2681
01:43:29,119 --> 01:43:31,040
now you're now let's say you're like

2682
01:43:31,040 --> 01:43:33,199
you're the implementer and you want to

2683
01:43:33,199 --> 01:43:34,960
actually like try to implement this

2684
01:43:34,960 --> 01:43:36,960
thing to make sure that

2685
01:43:36,960 --> 01:43:39,760
you know it uh i i can use it for some

2686
01:43:39,760 --> 01:43:41,440
protocol it interoperates with some

2687
01:43:41,440 --> 01:43:43,199
other implementation

2688
01:43:43,199 --> 01:43:45,600
again start on the left

2689
01:43:45,600 --> 01:43:48,000
go to this map to curve thing

2690
01:43:48,000 --> 01:43:50,480
and then i follow the pointers down to

2691
01:43:50,480 --> 01:43:52,159
like the actual implementation

2692
01:43:52,159 --> 01:43:54,080
description of alligator 2 in this

2693
01:43:54,080 --> 01:43:55,920
particular case

2694
01:43:55,920 --> 01:43:58,639
um and it goes into excruciating detail

2695
01:43:58,639 --> 01:43:59,600
about

2696
01:43:59,600 --> 01:44:01,840
every single step that needs to be done

2697
01:44:01,840 --> 01:44:04,239
with like comments as necessary for like

2698
01:44:04,239 --> 01:44:06,400
the different parts of the pseudo code

2699
01:44:06,400 --> 01:44:08,800
noting like for example on line three

2700
01:44:08,800 --> 01:44:11,199
like what in exceptional cases um that

2701
01:44:11,199 --> 01:44:13,600
was like described earlier in the syntax

2702
01:44:13,600 --> 01:44:15,440
and the api

2703
01:44:15,440 --> 01:44:16,480
and

2704
01:44:16,480 --> 01:44:19,280
this seems uh and moreover it's not it's

2705
01:44:19,280 --> 01:44:20,560
not actually included in this back but

2706
01:44:20,560 --> 01:44:22,159
this is

2707
01:44:22,159 --> 01:44:24,080
almost there's almost a one-to-one

2708
01:44:24,080 --> 01:44:25,760
mapping between this implementation

2709
01:44:25,760 --> 01:44:27,520
description as written here and the

2710
01:44:27,520 --> 01:44:28,800
reference implementation that we

2711
01:44:28,800 --> 01:44:31,760
provided in sage um not the sage that

2712
01:44:31,760 --> 01:44:33,440
was talked about in the previous uh

2713
01:44:33,440 --> 01:44:35,520
presentation

2714
01:44:35,520 --> 01:44:36,560
um

2715
01:44:36,560 --> 01:44:38,880
and so with the ultimate purpose to be

2716
01:44:38,880 --> 01:44:39,760
like

2717
01:44:39,760 --> 01:44:42,080
each step along the way minimizing

2718
01:44:42,080 --> 01:44:44,239
potential source of errors and interrupt

2719
01:44:44,239 --> 01:44:46,719
bugs or whatever

2720
01:44:46,719 --> 01:44:49,719
so

2721
01:44:50,159 --> 01:44:51,760
coming back to the the original

2722
01:44:51,760 --> 01:44:54,719
questions um

2723
01:44:54,719 --> 01:44:57,360
if you were to approach this document

2724
01:44:57,360 --> 01:44:59,199
and ask yourself you know is it easy to

2725
01:44:59,199 --> 01:45:00,800
use and understand

2726
01:45:00,800 --> 01:45:02,239
and we'll yield consistently correct

2727
01:45:02,239 --> 01:45:03,600
implementations

2728
01:45:03,600 --> 01:45:04,560
uh

2729
01:45:04,560 --> 01:45:07,199
i'm not going to like put checks or x's

2730
01:45:07,199 --> 01:45:08,639
or question marks next to them you know

2731
01:45:08,639 --> 01:45:10,080
i'll leave it to you to decide as an

2732
01:45:10,080 --> 01:45:12,080
interested reader

2733
01:45:12,080 --> 01:45:14,639
but i offer you offer it to you as a you

2734
01:45:14,639 --> 01:45:17,040
know potential way to think about how we

2735
01:45:17,040 --> 01:45:18,719
might structure these particular

2736
01:45:18,719 --> 01:45:21,520
documents i think this one went through

2737
01:45:21,520 --> 01:45:23,280
uh i spent a lot of time in the group

2738
01:45:23,280 --> 01:45:24,960
went through a lot of refactoring and

2739
01:45:24,960 --> 01:45:27,040
revisions and i think um it does a

2740
01:45:27,040 --> 01:45:28,639
reasonable job at like striking a good

2741
01:45:28,639 --> 01:45:30,800
balance

2742
01:45:30,800 --> 01:45:32,400
so i may have just implicitly answered

2743
01:45:32,400 --> 01:45:35,520
these things but anyways

2744
01:45:35,520 --> 01:45:37,840
okay

2745
01:45:38,320 --> 01:45:40,159
drawing on hash to curve i think there's

2746
01:45:40,159 --> 01:45:41,520
a number of things we can do going

2747
01:45:41,520 --> 01:45:43,920
forward to sort of improve the overall

2748
01:45:43,920 --> 01:45:45,440
output of the

2749
01:45:45,440 --> 01:45:46,960
things that we're doing in the cfrg and

2750
01:45:46,960 --> 01:45:48,480
i'm going to enumerate just a couple

2751
01:45:48,480 --> 01:45:50,639
high-level things

2752
01:45:50,639 --> 01:45:52,159
without drilling into any specific

2753
01:45:52,159 --> 01:45:53,600
details because a lot of it will vary

2754
01:45:53,600 --> 01:45:55,360
based on like the thing that's being

2755
01:45:55,360 --> 01:45:57,600
specified how involved it is like is it

2756
01:45:57,600 --> 01:46:01,600
a protocol or not and so on

2757
01:46:01,920 --> 01:46:05,440
um i think the the most obvious one um

2758
01:46:05,440 --> 01:46:07,360
is to just consider the audience uh it

2759
01:46:07,360 --> 01:46:09,920
should be fairly clear if this is like

2760
01:46:09,920 --> 01:46:11,679
written technical communication and

2761
01:46:11,679 --> 01:46:13,119
that's obviously important for any sort

2762
01:46:13,119 --> 01:46:15,920
of communication

2763
01:46:16,000 --> 01:46:18,320
but that means like making it easy for

2764
01:46:18,320 --> 01:46:20,560
the audience to like stitch these

2765
01:46:20,560 --> 01:46:22,880
different pieces of the spec together

2766
01:46:22,880 --> 01:46:23,840
so

2767
01:46:23,840 --> 01:46:27,119
maybe that means like or that does mean

2768
01:46:27,119 --> 01:46:29,040
being consistent where consistency

2769
01:46:29,040 --> 01:46:31,440
matters like if you're

2770
01:46:31,440 --> 01:46:34,239
using pseudocode to describe

2771
01:46:34,239 --> 01:46:36,080
different implementations of different

2772
01:46:36,080 --> 01:46:38,960
things in the specification use the same

2773
01:46:38,960 --> 01:46:41,360
format of pseudocode at every single

2774
01:46:41,360 --> 01:46:43,600
step of the way don't introduce like one

2775
01:46:43,600 --> 01:46:46,159
different format for you know section a

2776
01:46:46,159 --> 01:46:47,440
and then in the appendix use something

2777
01:46:47,440 --> 01:46:49,679
entirely different consistency

2778
01:46:49,679 --> 01:46:51,920
everywhere will help and will go a long

2779
01:46:51,920 --> 01:46:53,840
way

2780
01:46:53,840 --> 01:46:55,600
and also like hashtag curve does i claim

2781
01:46:55,600 --> 01:46:57,520
that like any time you are using

2782
01:46:57,520 --> 01:46:59,520
pseudocode try to make it as close as

2783
01:46:59,520 --> 01:47:00,960
possible to the actual reference

2784
01:47:00,960 --> 01:47:02,400
implementation that you are providing

2785
01:47:02,400 --> 01:47:04,400
with your specification and we should

2786
01:47:04,400 --> 01:47:06,000
require reference implementations for

2787
01:47:06,000 --> 01:47:07,040
these things

2788
01:47:07,040 --> 01:47:08,639
um

2789
01:47:08,639 --> 01:47:09,920
but there's

2790
01:47:09,920 --> 01:47:11,679
there's a lot of uh there's been a lot

2791
01:47:11,679 --> 01:47:13,119
of interesting discussion in various

2792
01:47:13,119 --> 01:47:15,119
like back analysis to in terms of like

2793
01:47:15,119 --> 01:47:16,880
what this reference implementation

2794
01:47:16,880 --> 01:47:18,400
format should be should it be say should

2795
01:47:18,400 --> 01:47:21,679
it be rush should be something else

2796
01:47:21,679 --> 01:47:22,639
uh

2797
01:47:22,639 --> 01:47:24,080
maybe that's something we should all

2798
01:47:24,080 --> 01:47:26,320
talk about but um try to make trying to

2799
01:47:26,320 --> 01:47:28,880
make them as close as possible um as i

2800
01:47:28,880 --> 01:47:29,920
think a

2801
01:47:29,920 --> 01:47:32,800
admirable goal

2802
01:47:33,679 --> 01:47:35,600
and on the heels of that i would say

2803
01:47:35,600 --> 01:47:36,480
that

2804
01:47:36,480 --> 01:47:38,400
consistency sort of

2805
01:47:38,400 --> 01:47:40,000
uh

2806
01:47:40,000 --> 01:47:42,400
beyond like sort of format consistency

2807
01:47:42,400 --> 01:47:45,360
in concepts is incredibly important

2808
01:47:45,360 --> 01:47:46,880
primarily because we want to reduce the

2809
01:47:46,880 --> 01:47:49,040
cognitive load of people who are reading

2810
01:47:49,040 --> 01:47:51,119
these specifications

2811
01:47:51,119 --> 01:47:51,920
so

2812
01:47:51,920 --> 01:47:53,760
not only like reusing formats but we're

2813
01:47:53,760 --> 01:47:55,760
using concepts

2814
01:47:55,760 --> 01:47:59,280
in draft itself but also across drafts

2815
01:47:59,280 --> 01:48:01,600
so if we're talking about say elliptic

2816
01:48:01,600 --> 01:48:04,320
curves in one draft and groups or prime

2817
01:48:04,320 --> 01:48:06,639
order groups in another draft that could

2818
01:48:06,639 --> 01:48:08,719
be confusing to people because sometimes

2819
01:48:08,719 --> 01:48:10,239
they're used interchangeably even though

2820
01:48:10,239 --> 01:48:12,960
they shouldn't but sometimes they are

2821
01:48:12,960 --> 01:48:14,960
so being consistency where you being

2822
01:48:14,960 --> 01:48:16,800
consistent where you can is incredibly

2823
01:48:16,800 --> 01:48:19,280
important using a shared vocabulary for

2824
01:48:19,280 --> 01:48:20,560
the things that we're talking about is

2825
01:48:20,560 --> 01:48:22,080
incredibly important

2826
01:48:22,080 --> 01:48:23,600
um

2827
01:48:23,600 --> 01:48:26,560
and uh i think for the most part the the

2828
01:48:26,560 --> 01:48:28,239
some of the documents that the cfrg is

2829
01:48:28,239 --> 01:48:29,760
working on right now

2830
01:48:29,760 --> 01:48:32,000
uh are like certainly they're internally

2831
01:48:32,000 --> 01:48:33,679
consistent i think the review process is

2832
01:48:33,679 --> 01:48:35,920
such that like it gets a tremendous

2833
01:48:35,920 --> 01:48:37,440
amount of review in the in the group

2834
01:48:37,440 --> 01:48:39,440
before it goes out then it goes through

2835
01:48:39,440 --> 01:48:42,239
like this formal the review panel step

2836
01:48:42,239 --> 01:48:44,000
um and then

2837
01:48:44,000 --> 01:48:45,440
there's a number of other steps but i

2838
01:48:45,440 --> 01:48:48,080
don't remember what they are um and i

2839
01:48:48,080 --> 01:48:49,520
think like

2840
01:48:49,520 --> 01:48:51,119
we have reached a level of internal

2841
01:48:51,119 --> 01:48:53,040
consistency but external consistency

2842
01:48:53,040 --> 01:48:54,880
across drafts is

2843
01:48:54,880 --> 01:48:56,719
uh

2844
01:48:56,719 --> 01:48:58,880
it could be improved um

2845
01:48:58,880 --> 01:49:00,560
and that's a hard problem because you

2846
01:49:00,560 --> 01:49:03,199
know things and concepts change over

2847
01:49:03,199 --> 01:49:05,600
time like what was like

2848
01:49:05,600 --> 01:49:07,199
maybe you know

2849
01:49:07,199 --> 01:49:08,960
we used to talk about the curves as you

2850
01:49:08,960 --> 01:49:10,800
know the best thing since sliced bread

2851
01:49:10,800 --> 01:49:12,639
but now we want to mostly we were

2852
01:49:12,639 --> 01:49:14,080
talking about like primordial groups

2853
01:49:14,080 --> 01:49:15,440
instead of elliptic curves we want to

2854
01:49:15,440 --> 01:49:17,360
kind of shy away from elliptic curves in

2855
01:49:17,360 --> 01:49:18,320
general

2856
01:49:18,320 --> 01:49:19,440
um

2857
01:49:19,440 --> 01:49:21,920
uh so

2858
01:49:21,920 --> 01:49:23,760
maintaining consistency over time is is

2859
01:49:23,760 --> 01:49:25,199
difficult but

2860
01:49:25,199 --> 01:49:27,520
i think for you know

2861
01:49:27,520 --> 01:49:28,880
batches of drafts that are being

2862
01:49:28,880 --> 01:49:31,119
developed at around the same time it's

2863
01:49:31,119 --> 01:49:34,080
it's not on a reasonable request

2864
01:49:34,080 --> 01:49:36,880
and something we could do

2865
01:49:37,440 --> 01:49:40,719
okay and i think the last one is

2866
01:49:40,719 --> 01:49:42,719
sort of a

2867
01:49:42,719 --> 01:49:45,920
call to action i guess to embrace formal

2868
01:49:45,920 --> 01:49:47,280
methods and formality where it's

2869
01:49:47,280 --> 01:49:48,560
appropriate

2870
01:49:48,560 --> 01:49:51,199
there is a tremendous amount of work and

2871
01:49:51,199 --> 01:49:53,440
referenced informally referenced and

2872
01:49:53,440 --> 01:49:55,199
formally verified implementations of

2873
01:49:55,199 --> 01:49:57,280
especially cryptographic algorithms

2874
01:49:57,280 --> 01:49:59,199
like hacks back and hackle star and

2875
01:49:59,199 --> 01:50:01,040
whatnot

2876
01:50:01,040 --> 01:50:03,440
whether or not they're suitable for the

2877
01:50:03,440 --> 01:50:06,560
you know permanent nature of an rfc is

2878
01:50:06,560 --> 01:50:09,440
not immediately clear to me

2879
01:50:09,440 --> 01:50:12,800
but all of this work uh that basically

2880
01:50:12,800 --> 01:50:15,040
lets someone take one single

2881
01:50:15,040 --> 01:50:16,639
implementation

2882
01:50:16,639 --> 01:50:18,400
and you know

2883
01:50:18,400 --> 01:50:20,639
produce test factors from it produce

2884
01:50:20,639 --> 01:50:21,760
other like

2885
01:50:21,760 --> 01:50:23,360
implementations in different languages

2886
01:50:23,360 --> 01:50:25,920
that they can test out uh and sometimes

2887
01:50:25,920 --> 01:50:27,440
produce like optimized implementations

2888
01:50:27,440 --> 01:50:29,040
as well that are just suitable to plop

2889
01:50:29,040 --> 01:50:30,880
in production systems

2890
01:50:30,880 --> 01:50:33,280
those those are those are good things

2891
01:50:33,280 --> 01:50:36,560
and it removes any like choice

2892
01:50:36,560 --> 01:50:38,400
chance of potential error from someone

2893
01:50:38,400 --> 01:50:40,480
implementing these things themselves

2894
01:50:40,480 --> 01:50:42,320
trying to you know interpret an

2895
01:50:42,320 --> 01:50:44,639
implementation description or syntax

2896
01:50:44,639 --> 01:50:46,719
description or whatever and potentially

2897
01:50:46,719 --> 01:50:48,239
getting it wrong

2898
01:50:48,239 --> 01:50:49,679
um

2899
01:50:49,679 --> 01:50:52,000
i i was alluding to earlier it's like

2900
01:50:52,000 --> 01:50:53,599
still not clear what it's like the right

2901
01:50:53,599 --> 01:50:56,800
format for this uh this

2902
01:50:56,800 --> 01:50:58,960
uh these like reference implementations

2903
01:50:58,960 --> 01:51:01,440
be it like something based in python

2904
01:51:01,440 --> 01:51:03,320
you know that a dsa

2905
01:51:03,320 --> 01:51:06,239
rc8032 uses python to describe some of

2906
01:51:06,239 --> 01:51:08,159
the relevant steps

2907
01:51:08,159 --> 01:51:10,159
um more recently things have been using

2908
01:51:10,159 --> 01:51:12,879
a lot of sage

2909
01:51:13,599 --> 01:51:14,960
because it's convenient and there's

2910
01:51:14,960 --> 01:51:17,119
there's like been a developing sort of

2911
01:51:17,119 --> 01:51:19,760
library in which we can use or the

2912
01:51:19,760 --> 01:51:21,360
developing

2913
01:51:21,360 --> 01:51:23,199
uh

2914
01:51:23,199 --> 01:51:24,560
i guess you can call it a library a

2915
01:51:24,560 --> 01:51:26,800
library of like the the specs that are

2916
01:51:26,800 --> 01:51:29,360
being developed the building blocks um

2917
01:51:29,360 --> 01:51:31,280
and and drafts are like building on

2918
01:51:31,280 --> 01:51:32,639
these building blocks and adding more

2919
01:51:32,639 --> 01:51:35,040
building blocks and and and whatnot

2920
01:51:35,040 --> 01:51:36,239
there's no reason you couldn't do this

2921
01:51:36,239 --> 01:51:39,119
in rust or hacks back or whatever um

2922
01:51:39,119 --> 01:51:40,960
i think it it'd be interesting to

2923
01:51:40,960 --> 01:51:42,480
experiment with different reference

2924
01:51:42,480 --> 01:51:44,480
implementations and see what is most

2925
01:51:44,480 --> 01:51:46,159
approachable from an implemented

2926
01:51:46,159 --> 01:51:47,840
implementer's

2927
01:51:47,840 --> 01:51:50,320
um and what is what is good for

2928
01:51:50,320 --> 01:51:54,559
really the you know inclusion in an rc

2929
01:51:55,679 --> 01:51:57,760
okay um so i want to wrap up and lose

2930
01:51:57,760 --> 01:52:00,080
some time for questions um

2931
01:52:00,080 --> 01:52:03,040
uh so i my

2932
01:52:03,040 --> 01:52:04,960
core point here is that like the work

2933
01:52:04,960 --> 01:52:06,960
that the cfrg does again is incredibly

2934
01:52:06,960 --> 01:52:09,119
important um we don't call them

2935
01:52:09,119 --> 01:52:10,560
standards they're not technically

2936
01:52:10,560 --> 01:52:12,400
standards but i think

2937
01:52:12,400 --> 01:52:13,440
um

2938
01:52:13,440 --> 01:52:15,360
if it you know walks like a duck and

2939
01:52:15,360 --> 01:52:17,040
quacks like a duck it is a duck these

2940
01:52:17,040 --> 01:52:18,960
things should be considered standards in

2941
01:52:18,960 --> 01:52:21,280
my opinion um they are incredibly

2942
01:52:21,280 --> 01:52:23,280
valuable and important to what the ietf

2943
01:52:23,280 --> 01:52:24,880
and irtf is doing

2944
01:52:24,880 --> 01:52:26,639
um and i think we should

2945
01:52:26,639 --> 01:52:28,800
treat them as such uh

2946
01:52:28,800 --> 01:52:30,239
there's definitely a lot more work that

2947
01:52:30,239 --> 01:52:33,280
we can be doing both within the group um

2948
01:52:33,280 --> 01:52:35,840
even in the rtf for you know

2949
01:52:35,840 --> 01:52:37,360
producing

2950
01:52:37,360 --> 01:52:40,159
uh tooling like sage or

2951
01:52:40,159 --> 01:52:41,440
the name that was in the first one i

2952
01:52:41,440 --> 01:52:42,960
apologize um

2953
01:52:42,960 --> 01:52:45,360
to uh improve the the quality of these

2954
01:52:45,360 --> 01:52:46,719
specifications

2955
01:52:46,719 --> 01:52:49,280
uh there's like ways that document

2956
01:52:49,280 --> 01:52:51,599
editors can you know right now start

2957
01:52:51,599 --> 01:52:52,639
improving the quality of their

2958
01:52:52,639 --> 01:52:54,960
specifications uh through like better

2959
01:52:54,960 --> 01:52:57,520
pros better better use of terminology

2960
01:52:57,520 --> 01:53:01,119
better um more consistency what have you

2961
01:53:01,119 --> 01:53:02,000
um

2962
01:53:02,000 --> 01:53:03,920
and i think it's about time that we

2963
01:53:03,920 --> 01:53:06,159
really took the question of uh or the

2964
01:53:06,159 --> 01:53:07,920
the task of exploring formal method

2965
01:53:07,920 --> 01:53:10,800
approaches for cfrg specifications

2966
01:53:10,800 --> 01:53:12,639
seriously um

2967
01:53:12,639 --> 01:53:14,159
and uh i don't know i don't know what

2968
01:53:14,159 --> 01:53:15,599
that looks like in practice if it's like

2969
01:53:15,599 --> 01:53:17,840
a task force that go off and like try to

2970
01:53:17,840 --> 01:53:19,119
you know work through these different

2971
01:53:19,119 --> 01:53:21,199
options if it's a group in the rtf to

2972
01:53:21,199 --> 01:53:22,239
sort of

2973
01:53:22,239 --> 01:53:23,280
uh

2974
01:53:23,280 --> 01:53:25,360
explore this area

2975
01:53:25,360 --> 01:53:27,199
i think you know anything is a

2976
01:53:27,199 --> 01:53:28,800
reasonable start here but i think it's

2977
01:53:28,800 --> 01:53:30,480
uh given all the work that's been done i

2978
01:53:30,480 --> 01:53:33,119
think it's it's now it's now time to

2979
01:53:33,119 --> 01:53:35,199
start uh actually pulling it into the

2980
01:53:35,199 --> 01:53:37,119
cfrg

2981
01:53:37,119 --> 01:53:38,560
um

2982
01:53:38,560 --> 01:53:40,719
with that i guess i'll

2983
01:53:40,719 --> 01:53:43,520
i'll close for questions um if you have

2984
01:53:43,520 --> 01:53:45,760
any

2985
01:53:48,239 --> 01:53:50,480
all right yeah jonathan

2986
01:53:50,480 --> 01:53:55,119
[Applause]

2987
01:53:55,119 --> 01:53:57,199
i think thank you very much chris uh

2988
01:53:57,199 --> 01:53:57,700
jonathan

2989
01:53:57,700 --> 01:53:59,119
[Music]

2990
01:53:59,119 --> 01:54:01,440
so uh i was just thinking

2991
01:54:01,440 --> 01:54:02,960
if we are going to have reference

2992
01:54:02,960 --> 01:54:06,320
implementations and pseudo code

2993
01:54:06,320 --> 01:54:08,159
which has precedence right if the

2994
01:54:08,159 --> 01:54:09,760
reference implementation doesn't agree

2995
01:54:09,760 --> 01:54:11,599
with what's written in the spec

2996
01:54:11,599 --> 01:54:13,840
which one do we consider correct do we

2997
01:54:13,840 --> 01:54:17,760
have to decide on a case-by-case basis

2998
01:54:17,760 --> 01:54:19,280
my personal opinion is that we should

2999
01:54:19,280 --> 01:54:20,880
have reference implementations in no

3000
01:54:20,880 --> 01:54:22,639
pseudo code um

3001
01:54:22,639 --> 01:54:24,080
but uh

3002
01:54:24,080 --> 01:54:25,840
like the that's just not the way specs

3003
01:54:25,840 --> 01:54:27,040
are published right now we have

3004
01:54:27,040 --> 01:54:28,480
pseudocode to describe the things and

3005
01:54:28,480 --> 01:54:29,840
reference implementations sort of hang

3006
01:54:29,840 --> 01:54:32,159
off the side of them

3007
01:54:32,159 --> 01:54:33,599
it would be great if there was like one

3008
01:54:33,599 --> 01:54:35,679
clear correct description of what thing

3009
01:54:35,679 --> 01:54:37,280
is and how it's implemented not two

3010
01:54:37,280 --> 01:54:41,679
possibly inconsistent representations

3011
01:54:41,679 --> 01:54:44,080
so yeah

3012
01:54:48,560 --> 01:54:50,960
all right thank you uh

3013
01:54:50,960 --> 01:54:53,040
thomas

3014
01:54:53,040 --> 01:54:56,800
i guess because you're in the room

3015
01:54:58,159 --> 01:55:01,440
i i didn't sign in

3016
01:55:03,840 --> 01:55:05,840
thomas is in the room but uh there's

3017
01:55:05,840 --> 01:55:06,800
other people in the queue so i guess

3018
01:55:06,800 --> 01:55:08,320
nick go ahead

3019
01:55:08,320 --> 01:55:10,239
oh okay um

3020
01:55:10,239 --> 01:55:11,599
so

3021
01:55:11,599 --> 01:55:14,719
what about producing non-informational

3022
01:55:14,719 --> 01:55:16,639
drafts within the cfrg is that

3023
01:55:16,639 --> 01:55:18,480
completely out of the question no i

3024
01:55:18,480 --> 01:55:22,000
don't think so for that i i i like

3025
01:55:22,000 --> 01:55:23,360
does it

3026
01:55:23,360 --> 01:55:26,000
i don't think so um

3027
01:55:26,000 --> 01:55:27,679
whether or not that would i mean the

3028
01:55:27,679 --> 01:55:30,320
topic of like should the cfrgb and irtf

3029
01:55:30,320 --> 01:55:33,119
versus itf has come up before my general

3030
01:55:33,119 --> 01:55:34,480
stance has been like

3031
01:55:34,480 --> 01:55:36,560
if it's not broke don't fix it like from

3032
01:55:36,560 --> 01:55:37,360
a

3033
01:55:37,360 --> 01:55:40,960
like a iotf versus ietf perspective but

3034
01:55:40,960 --> 01:55:42,560
um

3035
01:55:42,560 --> 01:55:44,320
i

3036
01:55:44,320 --> 01:55:46,480
i can't see any harm from like

3037
01:55:46,480 --> 01:55:48,880
rechartering to potentially

3038
01:55:48,880 --> 01:55:50,639
you know

3039
01:55:50,639 --> 01:55:53,360
uh explicitly include like

3040
01:55:53,360 --> 01:55:56,320
non-informational documents

3041
01:55:56,320 --> 01:55:58,320
okay thanks

3042
01:55:58,320 --> 01:56:00,560
i mean there are procedural issues there

3043
01:56:00,560 --> 01:56:01,360
but

3044
01:56:01,360 --> 01:56:03,760
in practice uh we

3045
01:56:03,760 --> 01:56:05,280
cfog should be producing as good

3046
01:56:05,280 --> 01:56:07,280
equality documents as it can

3047
01:56:07,280 --> 01:56:08,159
and

3048
01:56:08,159 --> 01:56:09,679
yeah we can have the arguments about

3049
01:56:09,679 --> 01:56:11,599
whether it should be an atf or an ircf

3050
01:56:11,599 --> 01:56:14,840
group later

3051
01:56:14,960 --> 01:56:17,440
it's us

3052
01:56:19,280 --> 01:56:21,119
i guess um i'll go

3053
01:56:21,119 --> 01:56:23,040
um siobhan said brave

3054
01:56:23,040 --> 01:56:25,280
this goes to a discussion that we were

3055
01:56:25,280 --> 01:56:27,280
having on slack chris but

3056
01:56:27,280 --> 01:56:29,280
um security proofs and

3057
01:56:29,280 --> 01:56:30,639
like do you think there's a conflict

3058
01:56:30,639 --> 01:56:32,719
between this the proof and

3059
01:56:32,719 --> 01:56:35,679
implementation complexity or simplicity

3060
01:56:35,679 --> 01:56:36,800
um

3061
01:56:36,800 --> 01:56:38,719
then like should you what should you do

3062
01:56:38,719 --> 01:56:40,480
and maybe you can say in the draft like

3063
01:56:40,480 --> 01:56:42,639
go and look at this other place where we

3064
01:56:42,639 --> 01:56:44,239
did something slightly different and

3065
01:56:44,239 --> 01:56:46,239
then proved it um

3066
01:56:46,239 --> 01:56:48,320
yeah just wondering what i think

3067
01:56:48,320 --> 01:56:50,239
anecdotally like the security proof

3068
01:56:50,239 --> 01:56:52,560
should trump everything um if the

3069
01:56:52,560 --> 01:56:54,000
implementation doesn't match there

3070
01:56:54,000 --> 01:56:55,920
should be like very clear reason as to

3071
01:56:55,920 --> 01:56:57,440
why it doesn't match perhaps with like

3072
01:56:57,440 --> 01:56:59,520
justification as to why it would deviate

3073
01:56:59,520 --> 01:57:01,920
from what has been analyzed in practice

3074
01:57:01,920 --> 01:57:02,960
um

3075
01:57:02,960 --> 01:57:04,880
uh but i think we should strive very

3076
01:57:04,880 --> 01:57:07,040
hard to keep like all these things

3077
01:57:07,040 --> 01:57:09,040
consistent and i would include like the

3078
01:57:09,040 --> 01:57:10,880
the the security model and the analysis

3079
01:57:10,880 --> 01:57:12,480
that's been done as part of like the

3080
01:57:12,480 --> 01:57:14,639
description of the specification

3081
01:57:14,639 --> 01:57:16,159
um

3082
01:57:16,159 --> 01:57:18,960
uh so

3083
01:57:19,280 --> 01:57:20,880
yeah

3084
01:57:20,880 --> 01:57:24,360
keep everything consistent

3085
01:57:24,639 --> 01:57:25,440
and

3086
01:57:25,440 --> 01:57:27,119
hi again this is

3087
01:57:27,119 --> 01:57:30,320
me thomas of pecorella and for real

3088
01:57:30,320 --> 01:57:31,360
anyway

3089
01:57:31,360 --> 01:57:34,320
i'd love to have a specification written

3090
01:57:34,320 --> 01:57:38,800
like you said i really love it i have

3091
01:57:38,800 --> 01:57:40,480
mixed feelings about reference

3092
01:57:40,480 --> 01:57:43,280
implementations

3093
01:57:43,360 --> 01:57:44,639
because

3094
01:57:44,639 --> 01:57:47,199
i fear that for some

3095
01:57:47,199 --> 01:57:48,800
cryptographic algorithms having a

3096
01:57:48,800 --> 01:57:51,360
reference implementation would lead to

3097
01:57:51,360 --> 01:57:54,239
more errors than

3098
01:57:54,239 --> 01:57:55,360
on

3099
01:57:55,360 --> 01:57:57,920
carefully written one meaning timing

3100
01:57:57,920 --> 01:58:01,360
errors or stuff like that

3101
01:58:01,360 --> 01:58:03,280
possible timing attacks i mean somebody

3102
01:58:03,280 --> 01:58:04,880
that just grabbed the reference

3103
01:58:04,880 --> 01:58:06,480
implementation transform it in another

3104
01:58:06,480 --> 01:58:07,520
language

3105
01:58:07,520 --> 01:58:09,760
by some mathematic immediate don't use

3106
01:58:09,760 --> 01:58:11,840
the brain and go on

3107
01:58:11,840 --> 01:58:14,560
i would love to have however some test

3108
01:58:14,560 --> 01:58:15,679
cases

3109
01:58:15,679 --> 01:58:20,400
like if these numbers are there you must

3110
01:58:20,400 --> 01:58:22,080
reach this point

3111
01:58:22,080 --> 01:58:25,119
because i fear that in some cases uh

3112
01:58:25,119 --> 01:58:26,960
this could be

3113
01:58:26,960 --> 01:58:28,639
more useful to

3114
01:58:28,639 --> 01:58:31,520
debug or test case your particular

3115
01:58:31,520 --> 01:58:34,520
implementation

3116
01:58:34,560 --> 01:58:36,400
um i mean yeah i certainly agree that

3117
01:58:36,400 --> 01:58:38,560
the test cases and test factors are

3118
01:58:38,560 --> 01:58:41,520
invaluable um and uh i think

3119
01:58:41,520 --> 01:58:43,520
most of the the specifications that i'm

3120
01:58:43,520 --> 01:58:45,360
aware of including probably would be the

3121
01:58:45,360 --> 01:58:46,239
best

3122
01:58:46,239 --> 01:58:47,599
yeah yeah um

3123
01:58:47,599 --> 01:58:48,800
in terms of like

3124
01:58:48,800 --> 01:58:50,239
whether or not reference implementation

3125
01:58:50,239 --> 01:58:51,920
should exist uh that it was actually an

3126
01:58:51,920 --> 01:58:53,440
explicit choice to use something like

3127
01:58:53,440 --> 01:58:56,800
sage to describe uh these like hashtag

3128
01:58:56,800 --> 01:59:00,320
based drafts because you can't just like

3129
01:59:00,320 --> 01:59:01,679
easily

3130
01:59:01,679 --> 01:59:04,000
take sage code and plop it in production

3131
01:59:04,000 --> 01:59:05,520
we want to make sure that was like

3132
01:59:05,520 --> 01:59:07,920
something you did not ever do and we

3133
01:59:07,920 --> 01:59:09,920
furthermore we took steps in the

3134
01:59:09,920 --> 01:59:11,599
reference implementation to try to

3135
01:59:11,599 --> 01:59:12,960
describe

3136
01:59:12,960 --> 01:59:13,840
uh

3137
01:59:13,840 --> 01:59:14,719
you know

3138
01:59:14,719 --> 01:59:16,639
uh or avoid sort of i guess

3139
01:59:16,639 --> 01:59:18,239
implementation pitfall so for example if

3140
01:59:18,239 --> 01:59:19,840
there you need to do like a comparison

3141
01:59:19,840 --> 01:59:21,840
of two like byte strings and constant

3142
01:59:21,840 --> 01:59:24,560
time we didn't just like in python say

3143
01:59:24,560 --> 01:59:27,440
like does a equal b we would say like if

3144
01:59:27,440 --> 01:59:28,719
a

3145
01:59:28,719 --> 01:59:30,480
is equal to b constant time i forget

3146
01:59:30,480 --> 01:59:31,920
like the extra actual string but like

3147
01:59:31,920 --> 01:59:33,760
you make it very clear like you know

3148
01:59:33,760 --> 01:59:35,440
this this is how you would actually

3149
01:59:35,440 --> 01:59:38,080
implement in practice um but i mean it's

3150
01:59:38,080 --> 01:59:39,360
a good point like should should

3151
01:59:39,360 --> 01:59:43,440
reference implementation exist uh

3152
01:59:43,599 --> 01:59:46,239
i i i tend to think they're useful but

3153
01:59:46,239 --> 01:59:47,840
write a reference implementation that

3154
01:59:47,840 --> 01:59:51,440
cannot be used as it is by um

3155
01:59:51,440 --> 01:59:52,719
let's say

3156
01:59:52,719 --> 01:59:55,520
an undergraduate student doesn't um

3157
01:59:55,520 --> 01:59:57,440
actually have time to actually do

3158
01:59:57,440 --> 01:59:58,880
something right

3159
01:59:58,880 --> 02:00:00,960
that would be great and i'm all up for

3160
02:00:00,960 --> 02:00:04,320
it yeah i mean uh i guess the other

3161
02:00:04,320 --> 02:00:06,239
other side of that coin is there are

3162
02:00:06,239 --> 02:00:08,080
projects like uh

3163
02:00:08,080 --> 02:00:10,560
i mean like the the recent nist pqc

3164
02:00:10,560 --> 02:00:11,920
competition that all the reference

3165
02:00:11,920 --> 02:00:13,840
implementations there were actually very

3166
02:00:13,840 --> 02:00:15,520
high quality implementations and they

3167
02:00:15,520 --> 02:00:17,119
perform very well

3168
02:00:17,119 --> 02:00:19,119
um you could reasonably take some of

3169
02:00:19,119 --> 02:00:20,880
those and plot them in production if you

3170
02:00:20,880 --> 02:00:24,000
were you know if if you wanted to do so

3171
02:00:24,000 --> 02:00:25,520
and

3172
02:00:25,520 --> 02:00:27,040
i guess it depends on you know what sort

3173
02:00:27,040 --> 02:00:29,040
of bar you hold for you know the

3174
02:00:29,040 --> 02:00:30,560
reference implementation yes it also

3175
02:00:30,560 --> 02:00:32,400
depends on how long you want to to have

3176
02:00:32,400 --> 02:00:34,239
the rfc

3177
02:00:34,239 --> 02:00:36,239
and how long is the code yeah yeah of

3178
02:00:36,239 --> 02:00:37,520
course

3179
02:00:37,520 --> 02:00:41,000
thank you yeah

3180
02:00:41,280 --> 02:00:43,599
hey this is max uh great talk i just

3181
02:00:43,599 --> 02:00:45,360
wanted to say i've found at least one

3182
02:00:45,360 --> 02:00:48,000
protocol where uh not the pseudo code

3183
02:00:48,000 --> 02:00:49,679
but the english language text did not

3184
02:00:49,679 --> 02:00:51,360
match the reference implementation not

3185
02:00:51,360 --> 02:00:53,760
an ietf one but one from outside so that

3186
02:00:53,760 --> 02:00:56,159
can happen too um and

3187
02:00:56,159 --> 02:00:57,920
i i do think it's maybe a good idea to

3188
02:00:57,920 --> 02:01:00,400
work be worth considering to say

3189
02:01:00,400 --> 02:01:02,800
what what should be um that somebody

3190
02:01:02,800 --> 02:01:04,400
else mentioned like believed if there's

3191
02:01:04,400 --> 02:01:05,920
a discrepancy right so the spec could

3192
02:01:05,920 --> 02:01:07,679
maybe say if there's a discrepancy

3193
02:01:07,679 --> 02:01:09,360
between this and the implementation you

3194
02:01:09,360 --> 02:01:10,719
should always fall on the side of i

3195
02:01:10,719 --> 02:01:12,320
don't know whichever right and and that

3196
02:01:12,320 --> 02:01:14,400
way you have it be unambiguous so maybe

3197
02:01:14,400 --> 02:01:15,760
there's something worth yeah that's not

3198
02:01:15,760 --> 02:01:18,320
a bad idea

3199
02:01:20,880 --> 02:01:22,800
all right thank you very much uh just to

3200
02:01:22,800 --> 02:01:24,239
follow on from that last point i think

3201
02:01:24,239 --> 02:01:26,880
it's very very clear that uh

3202
02:01:26,880 --> 02:01:28,000
yeah uh

3203
02:01:28,000 --> 02:01:29,760
chris had some some great examples but

3204
02:01:29,760 --> 02:01:32,719
this is very much not a a cfig specific

3205
02:01:32,719 --> 02:01:34,800
set of problems there are ambiguities

3206
02:01:34,800 --> 02:01:36,320
and issues with all of the

3207
02:01:36,320 --> 02:01:37,920
specifications

3208
02:01:37,920 --> 02:01:39,679
uh and certainly looking at the the

3209
02:01:39,679 --> 02:01:41,520
dependency graph colin jennings has for

3210
02:01:41,520 --> 02:01:43,760
the web rtc specifications and the

3211
02:01:43,760 --> 02:01:46,080
sprawling massive documents there

3212
02:01:46,080 --> 02:01:48,480
uh i think it's it's clear this is a an

3213
02:01:48,480 --> 02:01:50,480
issue of consistency that we we have in

3214
02:01:50,480 --> 02:01:54,239
in many different parts of the community

3215
02:01:54,719 --> 02:01:56,639
um so

3216
02:01:56,639 --> 02:01:58,800
what what i've been trying to do uh with

3217
02:01:58,800 --> 02:02:00,560
these talks is is to sort of try and

3218
02:02:00,560 --> 02:02:02,239
stimulate some discussion try and see if

3219
02:02:02,239 --> 02:02:04,560
there's interest in

3220
02:02:04,560 --> 02:02:06,800
your research on protocol specification

3221
02:02:06,800 --> 02:02:09,040
thinking about how we specify protocols

3222
02:02:09,040 --> 02:02:10,239
in in the

3223
02:02:10,239 --> 02:02:13,360
in in the itf and the irtf communities

3224
02:02:13,360 --> 02:02:14,880
uh it's time to think about what are the

3225
02:02:14,880 --> 02:02:17,119
research challenges in ineffective

3226
02:02:17,119 --> 02:02:19,920
protocol specification and how we can

3227
02:02:19,920 --> 02:02:23,679
improve the way we specify protocols

3228
02:02:23,679 --> 02:02:24,560
um

3229
02:02:24,560 --> 02:02:25,360
there's certainly been a lot of

3230
02:02:25,360 --> 02:02:27,760
discussion in the chat uh and a lot of

3231
02:02:27,760 --> 02:02:30,080
really good questions to the talks and i

3232
02:02:30,080 --> 02:02:31,760
think there are three fantastic talks

3233
02:02:31,760 --> 02:02:33,840
there so thank you everybody for for

3234
02:02:33,840 --> 02:02:35,920
both giving the talks and for the

3235
02:02:35,920 --> 02:02:38,400
discussion in the chat

3236
02:02:38,400 --> 02:02:41,360
um i i am certainly looking to to gauge

3237
02:02:41,360 --> 02:02:43,360
interest uh to see if people are

3238
02:02:43,360 --> 02:02:45,520
interested in potential irtf work in

3239
02:02:45,520 --> 02:02:47,599
this area

3240
02:02:47,599 --> 02:02:49,679
if you are interested in this pl please

3241
02:02:49,679 --> 02:02:51,679
do talk to the speakers

3242
02:02:51,679 --> 02:02:53,150
please do talk to me

3243
02:02:53,150 --> 02:02:54,320
[Music]

3244
02:02:54,320 --> 02:02:55,520
and

3245
02:02:55,520 --> 02:02:57,360
if if you would be interested in

3246
02:02:57,360 --> 02:02:59,679
following up on this put your names into

3247
02:02:59,679 --> 02:03:00,960
the

3248
02:03:00,960 --> 02:03:03,280
um that the documents that's linked on

3249
02:03:03,280 --> 02:03:05,199
the slide and i i just put in the chat

3250
02:03:05,199 --> 02:03:07,599
uh and we're you know not normally i

3251
02:03:07,599 --> 02:03:10,480
would arrange a a lunch meeting or

3252
02:03:10,480 --> 02:03:12,560
something at the itf um

3253
02:03:12,560 --> 02:03:14,159
in covered times that's obviously a

3254
02:03:14,159 --> 02:03:16,400
little bit difficult but please do put

3255
02:03:16,400 --> 02:03:18,239
your names in the chat we'll arrange a

3256
02:03:18,239 --> 02:03:20,480
call at some point

3257
02:03:20,480 --> 02:03:22,000
if there's interest and see if we can

3258
02:03:22,000 --> 02:03:24,000
take this further

3259
02:03:24,000 --> 02:03:27,040
so um thank you uh again to everybody

3260
02:03:27,040 --> 02:03:29,280
thank you to the speakers thank you to

3261
02:03:29,280 --> 02:03:32,320
everybody for for paying attention um

3262
02:03:32,320 --> 02:03:33,920
if there are any final questions i'm

3263
02:03:33,920 --> 02:03:37,199
very happy to take them and if not

3264
02:03:37,199 --> 02:03:40,519
thank you again

3265
02:03:47,760 --> 02:03:51,280
all right thanks everybody

3266
02:03:51,679 --> 02:03:54,000
look out for the nrw call for papers for

3267
02:03:54,000 --> 02:03:55,430
next year

3268
02:03:55,430 --> 02:03:58,619
[Applause]

