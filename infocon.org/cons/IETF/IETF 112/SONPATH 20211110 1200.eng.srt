1
00:00:12,160 --> 00:00:13,599
i think we should give it another minute

2
00:00:13,599 --> 00:00:14,920
or two before we

3
00:00:14,920 --> 00:00:18,400
start yes i agree kirsten i'm looking at

4
00:00:18,400 --> 00:00:20,720
the github

5
00:00:20,720 --> 00:00:21,920
the

6
00:00:21,920 --> 00:00:26,359
latest draft is

7
00:00:30,000 --> 00:00:31,359
10th november

8
00:00:31,359 --> 00:00:35,000
still today okay

9
00:01:19,280 --> 00:01:20,080
so

10
00:01:20,080 --> 00:01:23,360
glenn while we're waiting

11
00:01:23,360 --> 00:01:26,520
there is a

12
00:01:26,520 --> 00:01:27,759
[Music]

13
00:01:27,759 --> 00:01:32,400
pull request to create a tools.md

14
00:01:32,400 --> 00:01:35,840
do you maybe want to merge that

15
00:01:36,000 --> 00:01:40,600
okay i'll take a look thank you

16
00:01:50,079 --> 00:01:52,479
sorry is this a pull request against the

17
00:01:52,479 --> 00:01:56,240
main repo i see no requests yeah i don't

18
00:01:56,240 --> 00:01:57,439
see it either

19
00:01:57,439 --> 00:01:59,119
so wait a minute

20
00:01:59,119 --> 00:02:00,640
probably i simply didn't create the

21
00:02:00,640 --> 00:02:04,200
actual requests

22
00:02:15,280 --> 00:02:18,280
um

23
00:02:23,440 --> 00:02:23,760
yep

24
00:02:23,760 --> 00:02:26,850
[Music]

25
00:02:28,000 --> 00:02:31,040
that explains us

26
00:02:32,160 --> 00:02:36,359
number 135 now

27
00:02:36,560 --> 00:02:38,640
okay this is not changing the document

28
00:02:38,640 --> 00:02:40,000
at all it's just

29
00:02:40,000 --> 00:02:42,160
saving some information from an issue

30
00:02:42,160 --> 00:02:43,360
into a

31
00:02:43,360 --> 00:02:47,239
separate micron file

32
00:02:50,720 --> 00:02:53,120
yeah looks good to me i'll merge that

33
00:02:53,120 --> 00:02:54,560
thank you

34
00:02:54,560 --> 00:02:56,400
so where is it uh okay i'll take you

35
00:02:56,400 --> 00:02:59,720
right for it

36
00:03:05,120 --> 00:03:07,360
shall we start now and i i presume that

37
00:03:07,360 --> 00:03:11,920
stefan will join us uh at some point

38
00:03:13,280 --> 00:03:16,640
yeah he said 10 to 15 minutes stage

39
00:03:16,640 --> 00:03:19,280
yeah i mean we'll spend the first uh bit

40
00:03:19,280 --> 00:03:21,040
of that just getting through the the

41
00:03:21,040 --> 00:03:23,080
usual administration yeah

42
00:03:23,080 --> 00:03:25,519
[Music]

43
00:03:25,519 --> 00:03:28,239
cool okay so i'll do the i can do the

44
00:03:28,239 --> 00:03:30,720
formal introduction as i always do so

45
00:03:30,720 --> 00:03:32,799
this is the json path working group for

46
00:03:32,799 --> 00:03:37,239
i eat ietf 112.

47
00:03:37,360 --> 00:03:40,480
uh the usual disclaimer uh as this is an

48
00:03:40,480 --> 00:03:43,200
ietf meeting the note2l applies

49
00:03:43,200 --> 00:03:46,159
and all the bcps and guidance that you

50
00:03:46,159 --> 00:03:48,480
see stated here applies to this meeting

51
00:03:48,480 --> 00:03:51,040
as well uh if you have any questions you

52
00:03:51,040 --> 00:03:53,120
can ask the ombuds team uh or you can

53
00:03:53,120 --> 00:03:55,360
also ask francesca who is

54
00:03:55,360 --> 00:03:57,680
uh uh quietly sitting in the background

55
00:03:57,680 --> 00:03:58,799
there

56
00:03:58,799 --> 00:04:01,120
um

57
00:04:01,120 --> 00:04:02,319
uh

58
00:04:02,319 --> 00:04:04,879
probably a good idea uh carsten are you

59
00:04:04,879 --> 00:04:06,799
able to take notes when you're not

60
00:04:06,799 --> 00:04:08,640
speaking or

61
00:04:08,640 --> 00:04:09,840
is there somebody else who could help

62
00:04:09,840 --> 00:04:11,680
volunteer

63
00:04:11,680 --> 00:04:13,040
uh

64
00:04:13,040 --> 00:04:14,480
i think it would be much better if

65
00:04:14,480 --> 00:04:16,399
somebody should

66
00:04:16,399 --> 00:04:19,440
work on that so i i'm sure pitching but

67
00:04:19,440 --> 00:04:20,959
uh

68
00:04:20,959 --> 00:04:22,479
um

69
00:04:22,479 --> 00:04:23,919
i'm afraid i'm going to speak a lot

70
00:04:23,919 --> 00:04:25,199
today

71
00:04:25,199 --> 00:04:26,960
okay that's fine i guess what we can do

72
00:04:26,960 --> 00:04:28,639
then is what we've done in the past

73
00:04:28,639 --> 00:04:30,960
which is i'll uh crank out some notes

74
00:04:30,960 --> 00:04:33,040
from from the vod

75
00:04:33,040 --> 00:04:36,240
uh when it's uploaded a little bit later

76
00:04:36,240 --> 00:04:37,600
um

77
00:04:37,600 --> 00:04:40,960
the blue sheets using the the

78
00:04:40,960 --> 00:04:42,800
shared nodes in the kodiamg and that's

79
00:04:42,800 --> 00:04:45,120
where i will be typing into

80
00:04:45,120 --> 00:04:45,919
yep

81
00:04:45,919 --> 00:04:48,240
okay and and then i can just sort of

82
00:04:48,240 --> 00:04:49,840
add in anything else that needs to be

83
00:04:49,840 --> 00:04:50,800
support

84
00:04:50,800 --> 00:04:52,560
needed including that you missed that's

85
00:04:52,560 --> 00:04:53,440
fine

86
00:04:53,440 --> 00:04:54,880
blue sheets are automatic because we're

87
00:04:54,880 --> 00:04:57,520
using meat echo this time

88
00:04:57,520 --> 00:04:58,720
i will try and

89
00:04:58,720 --> 00:05:00,960
do my best to

90
00:05:00,960 --> 00:05:04,479
keep keep an eye on the chat

91
00:05:04,560 --> 00:05:08,160
in case anybody needs to pipe up

92
00:05:08,840 --> 00:05:10,960
um and

93
00:05:10,960 --> 00:05:13,600
uh but if somebody could nudge me

94
00:05:13,600 --> 00:05:15,600
uh that would be uh if i miss anything

95
00:05:15,600 --> 00:05:17,520
that would be kind of helpful do we have

96
00:05:17,520 --> 00:05:21,280
any agenda bashing that needs to be done

97
00:05:21,280 --> 00:05:23,600
um the agenda is

98
00:05:23,600 --> 00:05:25,840
this

99
00:05:32,880 --> 00:05:35,680
um perhaps we need to discuss

100
00:05:35,680 --> 00:05:40,000
regex in filters uh again because i'm a

101
00:05:40,000 --> 00:05:42,800
bit unclear about the direction

102
00:05:42,800 --> 00:05:43,600
yep

103
00:05:43,600 --> 00:05:46,000
uh tim and i had discussed that as a as

104
00:05:46,000 --> 00:05:48,160
a potential thing and maybe if we have

105
00:05:48,160 --> 00:05:51,120
time for that

106
00:05:51,120 --> 00:05:54,720
um after after i guess cast carson's

107
00:05:54,720 --> 00:05:56,400
gone through the issues we can include

108
00:05:56,400 --> 00:05:57,840
it

109
00:05:57,840 --> 00:05:59,280
yeah okay

110
00:05:59,280 --> 00:06:01,759
so i think we can actually i think

111
00:06:01,759 --> 00:06:04,560
let's try to do that because i think

112
00:06:04,560 --> 00:06:05,520
um

113
00:06:05,520 --> 00:06:08,080
i think that that's a fairly short item

114
00:06:08,080 --> 00:06:09,919
based on our discussion

115
00:06:09,919 --> 00:06:10,240
uh

116
00:06:10,240 --> 00:06:11,360
[Music]

117
00:06:11,360 --> 00:06:13,280
last time i mean

118
00:06:13,280 --> 00:06:16,479
do you want to do it now then

119
00:06:17,280 --> 00:06:19,840
well let me just offer the following um

120
00:06:19,840 --> 00:06:21,600
sure if people don't mind can take a

121
00:06:21,600 --> 00:06:24,639
minute um is that at our last get

122
00:06:24,639 --> 00:06:27,360
together we had a consensus that

123
00:06:27,360 --> 00:06:30,160
um we can't really have json uh pardon

124
00:06:30,160 --> 00:06:32,960
me or reg access unless we

125
00:06:32,960 --> 00:06:35,440
describe what we mean by reg x's

126
00:06:35,440 --> 00:06:36,160
and

127
00:06:36,160 --> 00:06:36,880
there

128
00:06:36,880 --> 00:06:39,120
at that time

129
00:06:39,120 --> 00:06:40,960
was nothing very concrete you know

130
00:06:40,960 --> 00:06:43,520
carson had scratched out a proposal

131
00:06:43,520 --> 00:06:46,160
so you know as things stand now

132
00:06:46,160 --> 00:06:48,000
we're probably not going to have rexes

133
00:06:48,000 --> 00:06:49,759
and filter expressions

134
00:06:49,759 --> 00:06:50,960
unless somebody's willing to do a bunch

135
00:06:50,960 --> 00:06:54,159
of work that i haven't heard about

136
00:06:54,479 --> 00:06:57,680
yeah i have a slide on that

137
00:07:00,960 --> 00:07:02,240
okay well let's push that on the stack

138
00:07:02,240 --> 00:07:04,560
then and uh

139
00:07:04,560 --> 00:07:06,479
dive into the issues

140
00:07:06,479 --> 00:07:07,520
okay

141
00:07:07,520 --> 00:07:09,759
so i guess the format of today's meeting

142
00:07:09,759 --> 00:07:12,400
is is that tim did you want to cover

143
00:07:12,400 --> 00:07:13,280
your

144
00:07:13,280 --> 00:07:14,319
uh

145
00:07:14,319 --> 00:07:16,400
your editorial notes and the things you

146
00:07:16,400 --> 00:07:17,680
uh

147
00:07:17,680 --> 00:07:19,440
the the various sections of the document

148
00:07:19,440 --> 00:07:20,400
only

149
00:07:20,400 --> 00:07:22,160
on list and go through those to start

150
00:07:22,160 --> 00:07:25,759
with and then we pick up carsten's

151
00:07:25,759 --> 00:07:27,599
issues

152
00:07:27,599 --> 00:07:29,840
cool uh did you want to uh share a

153
00:07:29,840 --> 00:07:31,440
screen or did you want me to bring up

154
00:07:31,440 --> 00:07:32,880
the email

155
00:07:32,880 --> 00:07:34,960
if you could just bring up the email

156
00:07:34,960 --> 00:07:36,639
sure i'm like finding my own having

157
00:07:36,639 --> 00:07:38,080
trouble finding my own damn email i may

158
00:07:38,080 --> 00:07:41,440
have absolutely accidentally yeah

159
00:07:43,199 --> 00:07:44,560
um

160
00:07:44,560 --> 00:07:47,440
nuked it somehow

161
00:07:47,759 --> 00:07:50,080
uh

162
00:07:51,759 --> 00:07:53,520
here it is

163
00:07:53,520 --> 00:07:56,400
okay i got it it's in the

164
00:07:56,400 --> 00:07:58,960
i'll drop the url into the chat

165
00:07:58,960 --> 00:08:02,520
just to be sure

166
00:08:13,440 --> 00:08:14,479
um

167
00:08:14,479 --> 00:08:17,840
so anyhow uh having read the draft i

168
00:08:17,840 --> 00:08:19,599
came away actually fairly

169
00:08:19,599 --> 00:08:23,440
cheered up because um the draft uh

170
00:08:23,440 --> 00:08:25,599
isn't terrible you know the the the

171
00:08:25,599 --> 00:08:27,520
important parts that you know describe

172
00:08:27,520 --> 00:08:29,680
the syntax and the semantics

173
00:08:29,680 --> 00:08:31,280
are

174
00:08:31,280 --> 00:08:33,919
mostly pretty okay with with editorial

175
00:08:33,919 --> 00:08:36,719
notes uh to be added and then

176
00:08:36,719 --> 00:08:40,559
a huge number of our open issues are all

177
00:08:40,559 --> 00:08:41,519
um

178
00:08:41,519 --> 00:08:44,159
uh stuck down in section four the

179
00:08:44,159 --> 00:08:46,959
expression language um karsten you've

180
00:08:46,959 --> 00:08:49,440
done around since this

181
00:08:49,440 --> 00:08:51,760
um

182
00:08:51,839 --> 00:08:53,920
and everybody's looked at this i think

183
00:08:53,920 --> 00:08:58,640
what in here needs further discussion

184
00:08:58,640 --> 00:09:01,120
kirsten

185
00:09:03,120 --> 00:09:06,839
anybody else in preparing this meeting

186
00:09:06,839 --> 00:09:09,839
i actually tried to

187
00:09:09,839 --> 00:09:11,680
uh

188
00:09:11,680 --> 00:09:13,680
tackle the big things here i haven't

189
00:09:13,680 --> 00:09:15,920
taken all the small things

190
00:09:15,920 --> 00:09:17,760
um because

191
00:09:17,760 --> 00:09:19,760
yeah they are in the end they are not so

192
00:09:19,760 --> 00:09:21,120
small

193
00:09:21,120 --> 00:09:22,640
with the amount of editing that is

194
00:09:22,640 --> 00:09:24,480
required

195
00:09:24,480 --> 00:09:25,279
but

196
00:09:25,279 --> 00:09:27,519
i think some of these should probably go

197
00:09:27,519 --> 00:09:30,000
into issues so we can have

198
00:09:30,000 --> 00:09:31,270
a little bit more

199
00:09:31,270 --> 00:09:32,560
[Music]

200
00:09:32,560 --> 00:09:34,720
discussion about

201
00:09:34,720 --> 00:09:36,959
them and some of them are really

202
00:09:36,959 --> 00:09:39,519
uh editorial and and we need another

203
00:09:39,519 --> 00:09:40,800
editorial

204
00:09:40,800 --> 00:09:42,480
uh round so

205
00:09:42,480 --> 00:09:44,720
basically i think i get back to this

206
00:09:44,720 --> 00:09:47,360
mail after this meeting but

207
00:09:47,360 --> 00:09:49,680
um i think most of it is done at this

208
00:09:49,680 --> 00:09:50,720
point

209
00:09:50,720 --> 00:09:51,600
okay

210
00:09:51,600 --> 00:09:53,040
okay

211
00:09:53,040 --> 00:09:57,440
that's good um the one thing um

212
00:09:57,440 --> 00:10:00,640
i wanted to raise here is in the

213
00:10:00,640 --> 00:10:02,800
in

214
00:10:02,839 --> 00:10:07,600
the a section three five

215
00:10:09,839 --> 00:10:11,760
i can't find it in my own notes the

216
00:10:11,760 --> 00:10:14,160
section

217
00:10:14,480 --> 00:10:16,800
that has all the different uh

218
00:10:16,800 --> 00:10:19,920
uh 3581

219
00:10:23,120 --> 00:10:25,360
i was hoping we would have examples

220
00:10:25,360 --> 00:10:27,360
um do people agree with that in spirit

221
00:10:27,360 --> 00:10:29,920
that for each of the uh

222
00:10:29,920 --> 00:10:32,880
uh selectors

223
00:10:37,519 --> 00:10:41,600
there are several ways to do examples

224
00:10:42,000 --> 00:10:43,600
so

225
00:10:43,600 --> 00:10:45,519
there is one

226
00:10:45,519 --> 00:10:46,480
issue

227
00:10:46,480 --> 00:10:48,880
if i remember correctly that asks for an

228
00:10:48,880 --> 00:10:50,399
appendix with

229
00:10:50,399 --> 00:10:52,000
examples

230
00:10:52,000 --> 00:10:53,040
and

231
00:10:53,040 --> 00:10:54,079
i think

232
00:10:54,079 --> 00:10:57,680
that that's a pretty good objective to

233
00:10:57,680 --> 00:11:00,000
have an exp appendix that has at least

234
00:11:00,000 --> 00:11:02,640
one example for each

235
00:11:02,640 --> 00:11:05,120
uh component of of the syntax and

236
00:11:05,120 --> 00:11:08,160
hopefully of the semantics by that

237
00:11:08,160 --> 00:11:09,360
as well

238
00:11:09,360 --> 00:11:11,040
that's right so i found it in section

239
00:11:11,040 --> 00:11:12,880
3.5.2

240
00:11:12,880 --> 00:11:16,800
um which uh

241
00:11:18,160 --> 00:11:20,720
particularly under dot selector uh oh

242
00:11:20,720 --> 00:11:22,480
yeah so dot selector dot wild card all

243
00:11:22,480 --> 00:11:24,700
these things in 3.5 right

244
00:11:24,700 --> 00:11:27,600
[Music]

245
00:11:27,600 --> 00:11:29,240
there's the

246
00:11:29,240 --> 00:11:30,320
rootselector.selector.weldguardindex

247
00:11:30,320 --> 00:11:32,560
index wealthguard i don't know i i just

248
00:11:32,560 --> 00:11:35,440
when i read a spec i i i find it so much

249
00:11:35,440 --> 00:11:37,279
happier if you know i read each piece of

250
00:11:37,279 --> 00:11:39,120
little descriptive prose and an example

251
00:11:39,120 --> 00:11:42,680
of what that looks like

252
00:11:43,920 --> 00:11:46,320
yeah i mean i agree with that um the

253
00:11:46,320 --> 00:11:48,880
only danger in putting examples in early

254
00:11:48,880 --> 00:11:51,200
is it sometimes tricks people into not

255
00:11:51,200 --> 00:11:52,800
actually defining

256
00:11:52,800 --> 00:11:56,639
um the content in a normative way

257
00:11:56,639 --> 00:11:58,800
fair enough yeah

258
00:11:58,800 --> 00:12:00,560
but in most cases we already have pretty

259
00:12:00,560 --> 00:12:04,160
well right so yeah yeah

260
00:12:05,680 --> 00:12:08,480
okay i'm just going to leave that in a

261
00:12:08,480 --> 00:12:10,959
you know as a suggestion to the editors

262
00:12:10,959 --> 00:12:13,279
and i might actually go and do a pr

263
00:12:13,279 --> 00:12:15,120
myself on that if nobody else is

264
00:12:15,120 --> 00:12:16,480
interested but i want to make sure

265
00:12:16,480 --> 00:12:20,760
nobody objects to that

266
00:12:26,399 --> 00:12:29,040
okay so having said that it sounds like

267
00:12:29,040 --> 00:12:29,920
um

268
00:12:29,920 --> 00:12:30,800
uh

269
00:12:30,800 --> 00:12:32,720
we have we the people at least on the

270
00:12:32,720 --> 00:12:34,160
call here have a

271
00:12:34,160 --> 00:12:36,399
uh somewhat shared view of the state of

272
00:12:36,399 --> 00:12:38,639
the spec and what we need to do to get

273
00:12:38,639 --> 00:12:41,120
finished

274
00:12:42,480 --> 00:12:43,839
let's talk about schedules a little bit

275
00:12:43,839 --> 00:12:46,000
if nobody objects

276
00:12:46,000 --> 00:12:47,920
how much work do we have left here i'm

277
00:12:47,920 --> 00:12:49,519
going to say

278
00:12:49,519 --> 00:12:53,839
not that much and we could

279
00:12:54,480 --> 00:12:56,720
think seriously about bringing a draft

280
00:12:56,720 --> 00:13:01,800
forward to the isg at the next ietf

281
00:13:09,440 --> 00:13:11,519
um yeah i think that's that's probably

282
00:13:11,519 --> 00:13:15,920
doable um just um to be clear i'm not

283
00:13:15,920 --> 00:13:18,320
currently working on the

284
00:13:18,320 --> 00:13:20,480
compliance test suite or the reference

285
00:13:20,480 --> 00:13:22,079
implementation

286
00:13:22,079 --> 00:13:23,440
so i think we're talking about just

287
00:13:23,440 --> 00:13:25,120
having the draft available in that time

288
00:13:25,120 --> 00:13:27,440
frame

289
00:13:28,160 --> 00:13:29,920
glenn did you go get a serious job or

290
00:13:29,920 --> 00:13:31,680
something

291
00:13:31,680 --> 00:13:33,200
uh no i got involved in some other

292
00:13:33,200 --> 00:13:37,040
things outside this so a bit distracted

293
00:13:37,040 --> 00:13:40,320
um and since marco dropped out i

294
00:13:40,320 --> 00:13:43,120
lost my main compatriot on those uh

295
00:13:43,120 --> 00:13:44,399
aspects

296
00:13:44,399 --> 00:13:46,959
quite like bouncing off people and

297
00:13:46,959 --> 00:13:50,319
rather than doing a solo effort

298
00:13:55,199 --> 00:13:56,480
okay

299
00:13:56,480 --> 00:13:59,040
fair enough so

300
00:13:59,040 --> 00:14:00,959
i just wanted to share my opinions there

301
00:14:00,959 --> 00:14:02,959
on on on the state of the draft and what

302
00:14:02,959 --> 00:14:06,479
needs to be done um

303
00:14:10,079 --> 00:14:11,360
that's fine

304
00:14:11,360 --> 00:14:13,199
okay i'm done with that

305
00:14:13,199 --> 00:14:15,360
um so we we had a couple of issues

306
00:14:15,360 --> 00:14:16,639
queued up

307
00:14:16,639 --> 00:14:19,360
james back to you

308
00:14:21,360 --> 00:14:24,079
uh yeah sorry i've just been uh

309
00:14:24,079 --> 00:14:27,600
struggling to to share the screen uh and

310
00:14:27,600 --> 00:14:28,880
uh trying to

311
00:14:28,880 --> 00:14:32,079
triage it with me to meet echo um i've

312
00:14:32,079 --> 00:14:33,839
started it again yeah

313
00:14:33,839 --> 00:14:35,120
we're not off to a good start with the

314
00:14:35,120 --> 00:14:37,120
technology this time around

315
00:14:37,120 --> 00:14:39,839
uh i'll let cast and do the screen

316
00:14:39,839 --> 00:14:41,760
driving now and you can do your talking

317
00:14:41,760 --> 00:14:44,760
carsten

318
00:14:45,120 --> 00:14:46,560
yeah thank you

319
00:14:46,560 --> 00:14:48,560
so i was just in the middle of opening

320
00:14:48,560 --> 00:14:49,839
an issue

321
00:14:49,839 --> 00:14:53,800
for the inline examples

322
00:15:04,480 --> 00:15:06,880
okay so that's not going to be on my

323
00:15:06,880 --> 00:15:08,320
slides yet

324
00:15:08,320 --> 00:15:10,320
number 136

325
00:15:10,320 --> 00:15:12,560
feel free to fill in that

326
00:15:12,560 --> 00:15:13,600
issue

327
00:15:13,600 --> 00:15:17,040
um so what i did is i i went through the

328
00:15:17,040 --> 00:15:18,320
issues

329
00:15:18,320 --> 00:15:20,480
newest first

330
00:15:20,480 --> 00:15:23,360
and um try to find out

331
00:15:23,360 --> 00:15:26,880
where we are with these issues

332
00:15:26,880 --> 00:15:28,959
that has turned out to be

333
00:15:28,959 --> 00:15:32,079
difficult uh for for about five of them

334
00:15:32,079 --> 00:15:34,240
because they they are really

335
00:15:34,240 --> 00:15:37,279
just streams of consciousness uh brain

336
00:15:37,279 --> 00:15:40,959
dumps and it's not even clear that uh

337
00:15:40,959 --> 00:15:42,800
this very defined issue

338
00:15:42,800 --> 00:15:44,880
is defined there let's talk about them

339
00:15:44,880 --> 00:15:46,320
at the end

340
00:15:46,320 --> 00:15:48,720
um so let me talk about the ones where

341
00:15:48,720 --> 00:15:50,399
where i think i understand what they are

342
00:15:50,399 --> 00:15:52,079
about

343
00:15:52,079 --> 00:15:56,000
and the most recent one uh was uh 127

344
00:15:56,000 --> 00:15:58,959
when i started doing these slides

345
00:15:58,959 --> 00:16:02,079
and the the question was

346
00:16:02,079 --> 00:16:04,720
should we provide for structure types in

347
00:16:04,720 --> 00:16:07,759
incontainable so for the in

348
00:16:07,759 --> 00:16:10,480
operator

349
00:16:10,480 --> 00:16:11,920
we

350
00:16:11,920 --> 00:16:15,199
would need to do two things to

351
00:16:15,199 --> 00:16:17,600
allow that we would have to put in a

352
00:16:17,600 --> 00:16:20,240
value notation for structure types

353
00:16:20,240 --> 00:16:22,480
and we would need to define the

354
00:16:22,480 --> 00:16:25,519
comparison semantics for structured

355
00:16:25,519 --> 00:16:26,800
types

356
00:16:26,800 --> 00:16:31,360
um so right now the value notation is

357
00:16:31,360 --> 00:16:33,120
limited to

358
00:16:33,120 --> 00:16:34,800
primitive

359
00:16:34,800 --> 00:16:38,320
types and actually it's it's different

360
00:16:38,320 --> 00:16:40,399
in the various places

361
00:16:40,399 --> 00:16:44,720
uh where uh we uh need it

362
00:16:44,720 --> 00:16:48,000
uh so uh that's maybe one thing where

363
00:16:48,000 --> 00:16:50,720
where we can think about

364
00:16:50,720 --> 00:16:52,720
whether it should be possible to search

365
00:16:52,720 --> 00:16:55,920
for true or false in a containable

366
00:16:55,920 --> 00:16:57,360
and so on

367
00:16:57,360 --> 00:16:59,120
um

368
00:16:59,120 --> 00:17:01,120
so that's one thing we would need to

369
00:17:01,120 --> 00:17:04,240
fill in

370
00:17:04,240 --> 00:17:06,319
and that that's not entirely trivial we

371
00:17:06,319 --> 00:17:08,880
cannot just copy the json syntax because

372
00:17:08,880 --> 00:17:11,839
uh jsonpath has a more lenient

373
00:17:11,839 --> 00:17:13,839
syntax so we

374
00:17:13,839 --> 00:17:17,839
at least have to patch that a little bit

375
00:17:17,839 --> 00:17:19,760
and of course an interesting question

376
00:17:19,760 --> 00:17:21,199
once you actually

377
00:17:21,199 --> 00:17:24,079
have array and object constructors in

378
00:17:24,079 --> 00:17:26,000
your value notation

379
00:17:26,000 --> 00:17:26,880
um

380
00:17:26,880 --> 00:17:29,120
what can you actually construct them

381
00:17:29,120 --> 00:17:30,880
from can you only construct them from

382
00:17:30,880 --> 00:17:33,200
literals or but can you also construct

383
00:17:33,200 --> 00:17:35,120
them from

384
00:17:35,120 --> 00:17:38,000
results of of nested queries

385
00:17:38,000 --> 00:17:41,360
and um well i would say if if we do all

386
00:17:41,360 --> 00:17:44,000
this then we we probably also should

387
00:17:44,000 --> 00:17:45,440
allow path and

388
00:17:45,440 --> 00:17:46,720
this

389
00:17:46,720 --> 00:17:47,760
but

390
00:17:47,760 --> 00:17:50,799
maybe we should first find out whether

391
00:17:50,799 --> 00:17:52,799
we actually want to do this

392
00:17:52,799 --> 00:17:55,120
on the comparison semantics i think

393
00:17:55,120 --> 00:17:56,160
that's

394
00:17:56,160 --> 00:17:59,440
pretty obvious it's not the semantics

395
00:17:59,440 --> 00:18:02,160
defined by javascript

396
00:18:02,160 --> 00:18:05,840
but it would be a deep

397
00:18:05,840 --> 00:18:09,200
recursion to to define

398
00:18:09,200 --> 00:18:11,520
equality

399
00:18:11,520 --> 00:18:12,960
and

400
00:18:12,960 --> 00:18:16,320
yeah in in 120 or in the

401
00:18:16,320 --> 00:18:17,600
interim

402
00:18:17,600 --> 00:18:20,880
uh two months ago we we said we really

403
00:18:20,880 --> 00:18:23,280
just want array literals composed of

404
00:18:23,280 --> 00:18:25,440
primitive values

405
00:18:25,440 --> 00:18:28,559
um so the existence of this issue seems

406
00:18:28,559 --> 00:18:29,360
to

407
00:18:29,360 --> 00:18:31,679
tell me that

408
00:18:31,679 --> 00:18:34,559
we we are reconsidering

409
00:18:34,559 --> 00:18:36,080
this

410
00:18:36,080 --> 00:18:39,039
and i'd like to hear where we should go

411
00:18:39,039 --> 00:18:41,120
with this

412
00:18:41,120 --> 00:18:43,600
so so you reopened this uh karsten based

413
00:18:43,600 --> 00:18:46,799
on on on discussion from where

414
00:18:46,799 --> 00:18:49,120
in some other issues i think

415
00:18:49,120 --> 00:18:50,799
oh okay okay

416
00:18:50,799 --> 00:18:53,039
um

417
00:18:53,919 --> 00:18:55,520
you find it

418
00:18:55,520 --> 00:18:58,080
so you know i i i agree with what you

419
00:18:58,080 --> 00:19:00,160
said that i i thought we had addressed

420
00:19:00,160 --> 00:19:02,640
this and decided to go with array only

421
00:19:02,640 --> 00:19:04,320
and and literal only

422
00:19:04,320 --> 00:19:06,720
is there sentiment for uh

423
00:19:06,720 --> 00:19:10,200
reopening this

424
00:19:13,600 --> 00:19:15,600
i'm always concerned about the element

425
00:19:15,600 --> 00:19:18,400
of surprise if you have a comparison

426
00:19:18,400 --> 00:19:19,919
with a um

427
00:19:19,919 --> 00:19:24,919
a structured value path on the left

428
00:19:25,440 --> 00:19:29,200
that's a different question

429
00:19:29,200 --> 00:19:31,440
okay

430
00:19:34,960 --> 00:19:36,400
yeah i'm looking at the discussion on

431
00:19:36,400 --> 00:19:38,240
the issue here and the examples of

432
00:19:38,240 --> 00:19:40,559
course in in carson's original post are

433
00:19:40,559 --> 00:19:44,399
very helpful you know the

434
00:19:46,480 --> 00:19:47,760
so we're talking about having structured

435
00:19:47,760 --> 00:19:49,360
values or i'm looking at stefan's

436
00:19:49,360 --> 00:19:51,200
comments pardon me so are we talking

437
00:19:51,200 --> 00:19:53,840
about

438
00:19:55,919 --> 00:19:57,440
so at the current time if we look at

439
00:19:57,440 --> 00:19:59,919
stefan's examples of array examples his

440
00:19:59,919 --> 00:20:03,480
very first one

441
00:20:09,440 --> 00:20:11,200
if you look at the array examples there

442
00:20:11,200 --> 00:20:13,200
are we're talking about on the left side

443
00:20:13,200 --> 00:20:15,039
on before the in is that the subject of

444
00:20:15,039 --> 00:20:17,440
the issue

445
00:20:19,440 --> 00:20:20,880
well the issue is really is about the

446
00:20:20,880 --> 00:20:23,440
right-hand side but

447
00:20:23,440 --> 00:20:24,640
yes

448
00:20:24,640 --> 00:20:27,120
if we don't have structured values in

449
00:20:27,120 --> 00:20:30,080
our notation at all then we cannot even

450
00:20:30,080 --> 00:20:31,120
write

451
00:20:31,120 --> 00:20:35,239
the second array example

452
00:20:48,799 --> 00:20:50,640
the the examples are instructive i mean

453
00:20:50,640 --> 00:20:53,520
the second one is

454
00:20:53,679 --> 00:20:55,440
a different semantic

455
00:20:55,440 --> 00:20:56,960
yes

456
00:20:56,960 --> 00:20:59,280
the containment that's

457
00:20:59,280 --> 00:21:02,000
being a substring or something like that

458
00:21:02,000 --> 00:21:04,559
yeah yeah i mean my the last comment

459
00:21:04,559 --> 00:21:06,080
from stefan

460
00:21:06,080 --> 00:21:07,039
um

461
00:21:07,039 --> 00:21:10,159
agrees with my critique of that he says

462
00:21:10,159 --> 00:21:13,840
he agrees that we shouldn't deal with

463
00:21:14,840 --> 00:21:16,960
subsets right so i mean the difference

464
00:21:16,960 --> 00:21:18,400
between the second and third examples

465
00:21:18,400 --> 00:21:19,520
are

466
00:21:19,520 --> 00:21:21,679
is interesting so the third example

467
00:21:21,679 --> 00:21:23,360
if you allowed literals on the left hand

468
00:21:23,360 --> 00:21:27,120
side makes sense the second one doesn't

469
00:21:27,120 --> 00:21:28,000
yeah

470
00:21:28,000 --> 00:21:31,039
well it's false uh it makes sense but

471
00:21:31,039 --> 00:21:32,080
it's false

472
00:21:32,080 --> 00:21:33,440
yeah you're correct

473
00:21:33,440 --> 00:21:34,880
you're correct

474
00:21:34,880 --> 00:21:36,400
and uh

475
00:21:36,400 --> 00:21:38,480
and

476
00:21:38,480 --> 00:21:40,159
then you know there's the corner cases

477
00:21:40,159 --> 00:21:41,840
about

478
00:21:41,840 --> 00:21:45,240
the empty arrays

479
00:21:46,960 --> 00:21:50,480
yeah i'm not sure that's the corner case

480
00:21:52,159 --> 00:21:54,640
i i think i think if we take out the

481
00:21:54,640 --> 00:21:55,679
subset

482
00:21:55,679 --> 00:21:58,799
part of the semantics the second example

483
00:21:58,799 --> 00:22:00,559
uh becomes false

484
00:22:00,559 --> 00:22:02,799
and one two three

485
00:22:02,799 --> 00:22:06,400
four the fourth example becomes false

486
00:22:06,400 --> 00:22:07,760
and the first thing

487
00:22:07,760 --> 00:22:10,400
becomes true

488
00:22:10,640 --> 00:22:12,880
uh yeah the third one's true

489
00:22:12,880 --> 00:22:15,120
as well

490
00:22:15,120 --> 00:22:17,039
and uh

491
00:22:17,039 --> 00:22:19,039
and the last one is also

492
00:22:19,039 --> 00:22:20,400
if you're going to allow that kind of

493
00:22:20,400 --> 00:22:22,880
thing true

494
00:22:23,120 --> 00:22:26,439
yeah yes

495
00:22:30,480 --> 00:22:33,360
yeah so to to me it really

496
00:22:33,360 --> 00:22:35,679
is a question about user requirements

497
00:22:35,679 --> 00:22:39,360
and i'm just seeing two comments in

498
00:22:39,360 --> 00:22:40,480
the chat

499
00:22:40,480 --> 00:22:43,600
from people who actually are users and

500
00:22:43,600 --> 00:22:45,200
it would be great if

501
00:22:45,200 --> 00:22:47,520
they could speak up and tell us whether

502
00:22:47,520 --> 00:22:50,679
they need

503
00:22:57,280 --> 00:23:00,080
i i was looking in uh the the big

504
00:23:00,080 --> 00:23:01,440
comparison

505
00:23:01,440 --> 00:23:04,760
and uh

506
00:23:08,000 --> 00:23:10,880
no there's not much there

507
00:23:16,240 --> 00:23:18,640
so this you know this this does actually

508
00:23:18,640 --> 00:23:21,039
add noticeable complexity

509
00:23:21,039 --> 00:23:23,120
um

510
00:23:23,120 --> 00:23:24,559
unless there are voices saying they need

511
00:23:24,559 --> 00:23:26,480
this my instinct is to say let's just

512
00:23:26,480 --> 00:23:29,679
leave it with literals only

513
00:23:30,000 --> 00:23:31,360
i mean

514
00:23:31,360 --> 00:23:33,520
i agree with that but i'll go further

515
00:23:33,520 --> 00:23:35,840
and say do we need the in operator at

516
00:23:35,840 --> 00:23:37,918
all

517
00:23:46,320 --> 00:23:50,400
ah i started my crew do you hear me now

518
00:23:50,400 --> 00:23:51,840
hi stefan

519
00:23:51,840 --> 00:23:54,799
hi hello hello everybody hiya

520
00:23:54,799 --> 00:23:57,679
okay you are discussing

521
00:23:57,679 --> 00:24:00,880
uh issue 120

522
00:24:00,880 --> 00:24:03,039
7 127

523
00:24:03,039 --> 00:24:06,240
uh one no 27 okay

524
00:24:06,240 --> 00:24:07,120
yep

525
00:24:07,120 --> 00:24:11,120
sorry we've got uh daryl in the queue

526
00:24:11,120 --> 00:24:12,720
daryl speak up

527
00:24:12,720 --> 00:24:14,320
hey um

528
00:24:14,320 --> 00:24:16,320
just going i'm just going through some

529
00:24:16,320 --> 00:24:19,279
of the examples that we use within um

530
00:24:19,279 --> 00:24:21,760
the overlays proposal that we've been

531
00:24:21,760 --> 00:24:24,480
working on for open api and i can't

532
00:24:24,480 --> 00:24:26,720
think of any scenario

533
00:24:26,720 --> 00:24:28,799
where we would want to do

534
00:24:28,799 --> 00:24:32,880
um in with a structure we do have

535
00:24:32,880 --> 00:24:34,720
scenarios where we would want to be able

536
00:24:34,720 --> 00:24:36,400
to use in

537
00:24:36,400 --> 00:24:36,800
um

538
00:24:36,800 --> 00:24:38,240
[Music]

539
00:24:38,240 --> 00:24:40,960
with a with a primitive value so i i

540
00:24:40,960 --> 00:24:42,480
think

541
00:24:42,480 --> 00:24:44,960
allowing in with primitive is is a nice

542
00:24:44,960 --> 00:24:46,400
compromise

543
00:24:46,400 --> 00:24:49,919
uh and i do see lots of usage of queries

544
00:24:49,919 --> 00:24:52,320
um across different scenarios with just

545
00:24:52,320 --> 00:24:55,039
in of a primitive because in with ids or

546
00:24:55,039 --> 00:24:56,720
in with tags

547
00:24:56,720 --> 00:24:58,799
you're looking for is this tag in this

548
00:24:58,799 --> 00:25:02,960
list there's this id in this list

549
00:25:02,960 --> 00:25:05,520
but the structured one i i'm struggling

550
00:25:05,520 --> 00:25:09,440
to come up with this scenario for

551
00:25:11,039 --> 00:25:14,240
yeah my feeling is that the literals

552
00:25:14,240 --> 00:25:17,039
matching literals in arrays is

553
00:25:17,039 --> 00:25:19,760
pretty easy to specify and not that hard

554
00:25:19,760 --> 00:25:21,520
to implement

555
00:25:21,520 --> 00:25:21,790
um

556
00:25:21,790 --> 00:25:23,919
[Music]

557
00:25:23,919 --> 00:25:25,840
so i would lean to leaving the in

558
00:25:25,840 --> 00:25:27,200
operator

559
00:25:27,200 --> 00:25:29,840
in

560
00:25:36,640 --> 00:25:39,120
yeah so we only need a

561
00:25:39,120 --> 00:25:42,159
value notation for raise which right now

562
00:25:42,159 --> 00:25:43,919
doesn't exist

563
00:25:43,919 --> 00:25:45,330
did i have a slide on that no

564
00:25:45,330 --> 00:25:47,039
[Music]

565
00:25:47,039 --> 00:25:48,480
oh i i did

566
00:25:48,480 --> 00:25:49,760
so this

567
00:25:49,760 --> 00:25:52,080
production ray literal isn't defined at

568
00:25:52,080 --> 00:25:54,080
this point in time but it should not be

569
00:25:54,080 --> 00:25:55,279
too hard

570
00:25:55,279 --> 00:25:56,340
uh to define it

571
00:25:56,340 --> 00:25:57,919
[Music]

572
00:25:57,919 --> 00:26:00,720
so that that would be the action

573
00:26:00,720 --> 00:26:03,279
uh from this issue

574
00:26:03,279 --> 00:26:04,880
and it does it doesn't seem that an

575
00:26:04,880 --> 00:26:07,760
array literal would screw up or collide

576
00:26:07,760 --> 00:26:09,200
with any other syntax or anything like

577
00:26:09,200 --> 00:26:11,440
that

578
00:26:11,440 --> 00:26:13,120
so just to be clear

579
00:26:13,120 --> 00:26:15,279
the uh that scenario with an array

580
00:26:15,279 --> 00:26:17,279
literal on the right-hand side

581
00:26:17,279 --> 00:26:20,640
uh would be equivalent to a disjunction

582
00:26:20,640 --> 00:26:21,840
yes

583
00:26:21,840 --> 00:26:25,840
yeah okay it's a bit more compact

584
00:26:27,279 --> 00:26:28,480
well i see what you're saying glenn so

585
00:26:28,480 --> 00:26:29,679
you could say

586
00:26:29,679 --> 00:26:31,840
it

587
00:26:32,240 --> 00:26:34,799
you could do it as a bunch of ours

588
00:26:34,799 --> 00:26:39,400
yeah so it's just syntactic sugar really

589
00:26:43,039 --> 00:26:44,559
yeah and i think the important thing is

590
00:26:44,559 --> 00:26:46,240
that we actually

591
00:26:46,240 --> 00:26:48,640
define the semantics of in in terms of

592
00:26:48,640 --> 00:26:51,600
the semantics of the equals

593
00:26:51,600 --> 00:26:53,840
operator so we don't repeat ourselves

594
00:26:53,840 --> 00:26:56,158
here

595
00:27:04,480 --> 00:27:07,840
after that

596
00:27:09,679 --> 00:27:12,559
um i mean this isn't the precise um

597
00:27:12,559 --> 00:27:14,480
issue we're talking about but my

598
00:27:14,480 --> 00:27:16,559
concern with the in operator is when we

599
00:27:16,559 --> 00:27:19,279
have a path on each side

600
00:27:19,279 --> 00:27:21,200
and when we have a structured

601
00:27:21,200 --> 00:27:22,559
path to a structured value on the

602
00:27:22,559 --> 00:27:25,200
left-hand side and a path to an array

603
00:27:25,200 --> 00:27:26,720
containing that structured value on the

604
00:27:26,720 --> 00:27:28,159
right-hand side

605
00:27:28,159 --> 00:27:29,760
and then i think it violates the

606
00:27:29,760 --> 00:27:32,240
principle of least surprise

607
00:27:32,240 --> 00:27:33,440
but i'm happy to put that on the back

608
00:27:33,440 --> 00:27:36,159
burner if this is out of order

609
00:27:36,159 --> 00:27:38,720
no no it's highly material i mean we

610
00:27:38,720 --> 00:27:41,039
could say that we could say that unless

611
00:27:41,039 --> 00:27:44,080
the left-hand side selects a primitive

612
00:27:44,080 --> 00:27:47,039
the answer is always false

613
00:27:47,039 --> 00:27:48,320
yeah and i think that violates the

614
00:27:48,320 --> 00:27:51,279
principle of least surprise in the case

615
00:27:51,279 --> 00:27:53,600
that would also make it hard to actually

616
00:27:53,600 --> 00:27:57,399
extend this later

617
00:28:04,159 --> 00:28:07,039
that leads me back to the examples

618
00:28:07,039 --> 00:28:09,279
um

619
00:28:13,760 --> 00:28:14,720
yeah so

620
00:28:14,720 --> 00:28:17,840
we have a general issue that that

621
00:28:17,840 --> 00:28:20,540
i think isn't really

622
00:28:20,540 --> 00:28:24,000
[Music]

623
00:28:24,000 --> 00:28:26,960
encapsulated in an issue of its own but

624
00:28:26,960 --> 00:28:29,279
it comes up in other issues

625
00:28:29,279 --> 00:28:31,600
what does it actually mean to have a

626
00:28:31,600 --> 00:28:33,600
path

627
00:28:33,600 --> 00:28:36,000
somewhere in an expression a comparison

628
00:28:36,000 --> 00:28:37,279
expression

629
00:28:37,279 --> 00:28:38,399
or

630
00:28:38,399 --> 00:28:40,559
in a place where boolean expression is

631
00:28:40,559 --> 00:28:42,640
required

632
00:28:42,640 --> 00:28:44,720
i think we have pretty good consensus

633
00:28:44,720 --> 00:28:46,320
for what it means

634
00:28:46,320 --> 00:28:48,320
in the boolean case

635
00:28:48,320 --> 00:28:49,039
but

636
00:28:49,039 --> 00:28:50,480
we haven't really discussed what it

637
00:28:50,480 --> 00:28:52,399
means in a comparison

638
00:28:52,399 --> 00:28:54,159
uh case

639
00:28:54,159 --> 00:28:57,200
and this would be essentially

640
00:28:57,200 --> 00:28:59,600
inheriting that problem that we haven't

641
00:28:59,600 --> 00:29:02,159
discussed what a path means in a

642
00:29:02,159 --> 00:29:03,279
comparison

643
00:29:03,279 --> 00:29:05,760
position

644
00:29:11,679 --> 00:29:13,679
i mean we could print the problem by by

645
00:29:13,679 --> 00:29:14,720
having

646
00:29:14,720 --> 00:29:17,200
literals only

647
00:29:17,200 --> 00:29:19,600
on the left side of n

648
00:29:19,600 --> 00:29:23,439
on the left side that would be weird

649
00:29:24,480 --> 00:29:26,159
i mean sorry uh primitives only yeah but

650
00:29:26,159 --> 00:29:27,919
literals literals only no no paths on

651
00:29:27,919 --> 00:29:29,360
the left side

652
00:29:29,360 --> 00:29:31,840
well that's why you usually have an in

653
00:29:31,840 --> 00:29:33,760
you want to see whether the thing you

654
00:29:33,760 --> 00:29:34,640
found

655
00:29:34,640 --> 00:29:37,520
somewhere in the document is in a set of

656
00:29:37,520 --> 00:29:38,880
values

657
00:29:38,880 --> 00:29:41,440
yeah okay fair enough

658
00:29:41,440 --> 00:29:42,559
the the

659
00:29:42,559 --> 00:29:44,080
more interesting question is what

660
00:29:44,080 --> 00:29:47,840
happens if if it's on the right side

661
00:29:47,840 --> 00:29:50,720
because then you have a note list and is

662
00:29:50,720 --> 00:29:52,960
that actually

663
00:29:52,960 --> 00:29:56,159
the same as an array or

664
00:29:56,159 --> 00:30:00,159
do we extract arrays from these nodes

665
00:30:00,159 --> 00:30:03,679
that that's not where defined

666
00:30:03,679 --> 00:30:04,559
and

667
00:30:04,559 --> 00:30:06,559
on on the left hand side of course if

668
00:30:06,559 --> 00:30:08,799
the path is a note list with more than

669
00:30:08,799 --> 00:30:09,919
one

670
00:30:09,919 --> 00:30:11,840
element we also have to

671
00:30:11,840 --> 00:30:14,480
decide to what that means

672
00:30:14,480 --> 00:30:16,240
right but but for defining it from the

673
00:30:16,240 --> 00:30:18,399
point of view of somebody writing a json

674
00:30:18,399 --> 00:30:19,279
path

675
00:30:19,279 --> 00:30:23,840
they think in terms of you know

676
00:30:24,080 --> 00:30:26,559
json stuff not not node lists

677
00:30:26,559 --> 00:30:28,880
um and you know these examples here and

678
00:30:28,880 --> 00:30:30,880
from stefan are

679
00:30:30,880 --> 00:30:33,520
presented that way in terms of json yeah

680
00:30:33,520 --> 00:30:36,000
so they don't don't address the the

681
00:30:36,000 --> 00:30:37,840
other problem that i was trying to bring

682
00:30:37,840 --> 00:30:40,000
up

683
00:30:42,159 --> 00:30:45,120
if you write a json path you might might

684
00:30:45,120 --> 00:30:47,600
have in in your mind that you

685
00:30:47,600 --> 00:30:50,480
have nailed down a specific node with

686
00:30:50,480 --> 00:30:52,720
the path expression and then of course

687
00:30:52,720 --> 00:30:54,320
the semantics are

688
00:30:54,320 --> 00:30:55,360
symbol

689
00:30:55,360 --> 00:30:58,159
just extract the value from that node

690
00:30:58,159 --> 00:31:00,000
and compare it

691
00:31:00,000 --> 00:31:03,120
as as we would compare a value on that

692
00:31:03,120 --> 00:31:04,480
left hand side

693
00:31:04,480 --> 00:31:06,000
and if that

694
00:31:06,000 --> 00:31:08,240
value is structured

695
00:31:08,240 --> 00:31:10,080
it cannot match anything on the right

696
00:31:10,080 --> 00:31:14,000
hand side because we only have simple

697
00:31:14,000 --> 00:31:17,039
values in the array literally

698
00:31:17,039 --> 00:31:20,000
that that's easy but if the path

699
00:31:20,000 --> 00:31:23,279
actually gives you several candidates

700
00:31:23,279 --> 00:31:26,399
um what does that mean

701
00:31:27,039 --> 00:31:29,120
well that's a different issue that's

702
00:31:29,120 --> 00:31:30,399
but it's probably an issue that will

703
00:31:30,399 --> 00:31:33,840
inform what we do with this issue

704
00:31:36,000 --> 00:31:38,559
so so daryl what would the shape of the

705
00:31:38,559 --> 00:31:40,640
queries you might like to do look like

706
00:31:40,640 --> 00:31:43,519
would would it uh would you know you

707
00:31:43,519 --> 00:31:44,720
would you say

708
00:31:44,720 --> 00:31:47,279
dollar dot a dot b

709
00:31:47,279 --> 00:31:48,159
in

710
00:31:48,159 --> 00:31:50,000
you know dollar dot c dot d kind of

711
00:31:50,000 --> 00:31:51,200
thing

712
00:31:51,200 --> 00:31:53,519
uh interestingly we we

713
00:31:53,519 --> 00:31:54,799
use it

714
00:31:54,799 --> 00:31:57,200
this particular in the opposite case

715
00:31:57,200 --> 00:31:59,440
so we have a notion of

716
00:31:59,440 --> 00:32:00,399
um

717
00:32:00,399 --> 00:32:02,720
i want to apply this

718
00:32:02,720 --> 00:32:05,360
or merge this change

719
00:32:05,360 --> 00:32:07,039
uh if

720
00:32:07,039 --> 00:32:08,080
um

721
00:32:08,080 --> 00:32:09,919
this literal trait

722
00:32:09,919 --> 00:32:13,360
exists in the list of traits associated

723
00:32:13,360 --> 00:32:15,120
with the target

724
00:32:15,120 --> 00:32:16,000
so

725
00:32:16,000 --> 00:32:21,039
the the path is querying into the dark

726
00:32:21,039 --> 00:32:24,159
for an array and we want to know whether

727
00:32:24,159 --> 00:32:27,039
a particular literal is in that list

728
00:32:27,039 --> 00:32:30,480
so we would be literal is in

729
00:32:30,480 --> 00:32:32,320
list of trades

730
00:32:32,320 --> 00:32:34,799
so literal is in dollar dot

731
00:32:34,799 --> 00:32:38,080
trade list or something like that

732
00:32:41,279 --> 00:32:42,960
i mean we could i mean i can see both

733
00:32:42,960 --> 00:32:45,919
scenarios but

734
00:32:50,320 --> 00:32:51,840
so suppose

735
00:32:51,840 --> 00:32:53,840
the the path

736
00:32:53,840 --> 00:32:56,559
on on the right side of n

737
00:32:56,559 --> 00:32:58,879
is

738
00:32:59,039 --> 00:33:02,720
identifies anything but an array

739
00:33:03,120 --> 00:33:04,640
then the

740
00:33:04,640 --> 00:33:06,720
in does not succeed

741
00:33:06,720 --> 00:33:08,399
is that right yeah it doesn't it

742
00:33:08,399 --> 00:33:11,200
wouldn't

743
00:33:11,200 --> 00:33:13,679
i wouldn't know how to

744
00:33:13,679 --> 00:33:15,840
interpret that

745
00:33:15,840 --> 00:33:17,519
question

746
00:33:17,519 --> 00:33:18,880
was that the

747
00:33:18,880 --> 00:33:20,000
note list

748
00:33:20,000 --> 00:33:21,840
resulting from the path actually is

749
00:33:21,840 --> 00:33:23,440
converted

750
00:33:23,440 --> 00:33:26,320
into an array for this

751
00:33:26,320 --> 00:33:27,519
interpretation i don't think that's what

752
00:33:27,519 --> 00:33:29,360
i'm saying i'm saying that

753
00:33:29,360 --> 00:33:32,399
if i say something is in dollar dot a

754
00:33:32,399 --> 00:33:33,279
if

755
00:33:33,279 --> 00:33:36,000
if dollar dot a is not an array not a

756
00:33:36,000 --> 00:33:38,880
json array then it doesn't match

757
00:33:38,880 --> 00:33:41,360
yeah so the alternative to that

758
00:33:41,360 --> 00:33:43,519
interpretation which i understand

759
00:33:43,519 --> 00:33:46,240
would be that you actually

760
00:33:46,240 --> 00:33:49,200
use a path that delivers

761
00:33:49,200 --> 00:33:51,760
the number of nodes

762
00:33:51,760 --> 00:33:54,000
in place of an array

763
00:33:54,000 --> 00:33:55,840
and go through the node list and see

764
00:33:55,840 --> 00:33:57,760
whether you have a match

765
00:33:57,760 --> 00:34:00,640
so you say in dollar dot a dot star you

766
00:34:00,640 --> 00:34:01,519
mean

767
00:34:01,519 --> 00:34:03,440
yeah something

768
00:34:03,440 --> 00:34:06,080
or into a particular property in an

769
00:34:06,080 --> 00:34:07,840
object

770
00:34:07,840 --> 00:34:10,800
so you you'd path into

771
00:34:10,800 --> 00:34:12,399
there'd be an array of objects you could

772
00:34:12,399 --> 00:34:15,359
path into a property on that object

773
00:34:15,359 --> 00:34:17,040
and that would produce your node list

774
00:34:17,040 --> 00:34:20,839
that you could then query

775
00:34:29,760 --> 00:34:31,119
json world

776
00:34:31,119 --> 00:34:33,440
key

777
00:34:33,520 --> 00:34:35,679
so so in json we have you know objects

778
00:34:35,679 --> 00:34:38,159
and arrays and objects have members

779
00:34:38,159 --> 00:34:40,800
which have names and values

780
00:34:40,800 --> 00:34:42,079
okay so

781
00:34:42,079 --> 00:34:43,918
basically selecting a member of an

782
00:34:43,918 --> 00:34:45,359
object

783
00:34:45,359 --> 00:34:47,119
if you had an array of objects you could

784
00:34:47,119 --> 00:34:50,960
select a member of an object

785
00:34:50,960 --> 00:34:54,000
across an array which would then create

786
00:34:54,000 --> 00:34:57,040
a node list of all of those

787
00:34:57,040 --> 00:34:59,280
the literal values of the member if the

788
00:34:59,280 --> 00:35:03,640
if the member has a primitive value

789
00:35:03,760 --> 00:35:06,480
so if you had an array of fruit objects

790
00:35:06,480 --> 00:35:07,440
and

791
00:35:07,440 --> 00:35:09,280
every fruit had a member which was a

792
00:35:09,280 --> 00:35:10,720
color

793
00:35:10,720 --> 00:35:16,118
you could pick out all of the blue fruit

794
00:35:16,240 --> 00:35:19,280
we have a different issue on whether

795
00:35:19,280 --> 00:35:22,400
selection actually is possible

796
00:35:22,400 --> 00:35:24,800
because what you describe is

797
00:35:24,800 --> 00:35:26,640
a projection

798
00:35:26,640 --> 00:35:27,760
where you

799
00:35:27,760 --> 00:35:29,040
take

800
00:35:29,040 --> 00:35:31,119
an array of objects

801
00:35:31,119 --> 00:35:34,480
and extract a single

802
00:35:34,480 --> 00:35:37,599
member identified by by a name

803
00:35:37,599 --> 00:35:40,320
from sorry the array elements

804
00:35:40,320 --> 00:35:43,040
yeah okay so it's it's the in operator

805
00:35:43,040 --> 00:35:45,359
becomes is there a blue fruit in the

806
00:35:45,359 --> 00:35:46,880
list

807
00:35:46,880 --> 00:35:49,040
yeah

808
00:35:49,680 --> 00:35:52,240
okay but we already can do that with a

809
00:35:52,240 --> 00:35:54,960
filter expression so um

810
00:35:54,960 --> 00:35:56,960
the the simple case where we just want

811
00:35:56,960 --> 00:35:59,280
to know whether it's there or not

812
00:35:59,280 --> 00:36:01,119
doesn't need the in operation that can

813
00:36:01,119 --> 00:36:03,040
be done with the filter expression and

814
00:36:03,040 --> 00:36:04,640
if the filter explosion impression is

815
00:36:04,640 --> 00:36:06,960
empty then you don't have a match

816
00:36:06,960 --> 00:36:08,560
and if the filter expression is not

817
00:36:08,560 --> 00:36:12,079
empty you do have a mesh

818
00:36:12,079 --> 00:36:13,599
right

819
00:36:13,599 --> 00:36:15,760
yeah which which brings us back to is in

820
00:36:15,760 --> 00:36:18,320
only useful when you have an array of

821
00:36:18,320 --> 00:36:19,520
literals

822
00:36:19,520 --> 00:36:22,520
primitives

823
00:36:26,320 --> 00:36:28,079
i think that would be a good

824
00:36:28,079 --> 00:36:30,800
simplification

825
00:36:35,280 --> 00:36:38,560
i think this is a quite good example

826
00:36:38,560 --> 00:36:40,640
regarding issue

827
00:36:40,640 --> 00:36:43,640
122.

828
00:36:44,720 --> 00:36:48,640
i think i didn't cut it right

829
00:36:48,640 --> 00:36:52,079
carson your example

830
00:36:52,079 --> 00:36:53,359
at

831
00:36:53,359 --> 00:36:54,880
color in

832
00:36:54,880 --> 00:36:58,560
dollar dot dot allowed color i i was

833
00:36:58,560 --> 00:37:02,000
thinking about loud colors uh so

834
00:37:02,000 --> 00:37:05,920
returning an arrow an array of arrays

835
00:37:05,920 --> 00:37:07,359
but

836
00:37:07,359 --> 00:37:08,880
this example

837
00:37:08,880 --> 00:37:10,000
with

838
00:37:10,000 --> 00:37:12,720
a lot of fruits and

839
00:37:12,720 --> 00:37:15,920
note lists of fruits

840
00:37:15,920 --> 00:37:19,040
and then selecting all

841
00:37:19,040 --> 00:37:21,440
blue fruits is

842
00:37:21,440 --> 00:37:22,480
a

843
00:37:22,480 --> 00:37:25,359
nice example where we generally are

844
00:37:25,359 --> 00:37:29,920
generating an array of

845
00:37:30,079 --> 00:37:33,200
object members and then

846
00:37:33,200 --> 00:37:34,320
query

847
00:37:34,320 --> 00:37:35,200
by

848
00:37:35,200 --> 00:37:37,599
the in operator if

849
00:37:37,599 --> 00:37:39,119
that

850
00:37:39,119 --> 00:37:40,960
color in this case

851
00:37:40,960 --> 00:37:46,960
is included or is found in this array

852
00:37:49,200 --> 00:37:51,440
assuming you have an n operator the

853
00:37:51,440 --> 00:37:53,440
saying in

854
00:37:53,440 --> 00:37:54,800
when you're talking about an array

855
00:37:54,800 --> 00:37:57,359
that's part of the you know json

856
00:37:57,359 --> 00:37:58,640
data

857
00:37:58,640 --> 00:38:00,400
as opposed to in when you're talking

858
00:38:00,400 --> 00:38:02,480
about the results of a query with star

859
00:38:02,480 --> 00:38:04,160
in it or something like that feel like

860
00:38:04,160 --> 00:38:05,820
really different things

861
00:38:05,820 --> 00:38:09,499
[Music]

862
00:38:12,160 --> 00:38:14,160
this requires

863
00:38:14,160 --> 00:38:16,319
to

864
00:38:16,720 --> 00:38:19,520
to turn a note list into an array

865
00:38:19,520 --> 00:38:21,839
and this is the only

866
00:38:21,839 --> 00:38:22,800
uh

867
00:38:22,800 --> 00:38:24,640
one in the

868
00:38:24,640 --> 00:38:26,079
spec where we

869
00:38:26,079 --> 00:38:26,960
uh

870
00:38:26,960 --> 00:38:29,839
demand this

871
00:38:29,839 --> 00:38:31,280
well it's the only place in respect

872
00:38:31,280 --> 00:38:32,800
where we actually handle arrays because

873
00:38:32,800 --> 00:38:34,640
otherwise we we are only handling

874
00:38:34,640 --> 00:38:36,000
primitive

875
00:38:36,000 --> 00:38:37,040
um

876
00:38:37,040 --> 00:38:38,560
types so that that would not be a

877
00:38:38,560 --> 00:38:40,480
surprise

878
00:38:40,480 --> 00:38:41,280
but

879
00:38:41,280 --> 00:38:43,119
yeah we don't have to turn it into an

880
00:38:43,119 --> 00:38:45,040
array we could simply define what it

881
00:38:45,040 --> 00:38:47,440
means to have a path

882
00:38:47,440 --> 00:38:50,320
as a container

883
00:38:50,880 --> 00:38:53,359
we can use the array as a useful analogy

884
00:38:53,359 --> 00:38:55,760
for defining that

885
00:38:55,760 --> 00:38:56,560
but

886
00:38:56,560 --> 00:38:59,599
we don't have to say the path turns into

887
00:38:59,599 --> 00:39:02,160
an array because that has other

888
00:39:02,160 --> 00:39:03,280
interesting

889
00:39:03,280 --> 00:39:04,560
issues

890
00:39:04,560 --> 00:39:06,640
okay so no another point of view it's

891
00:39:06,640 --> 00:39:08,160
okay

892
00:39:08,160 --> 00:39:10,480
another way to

893
00:39:10,480 --> 00:39:11,520
go ahead

894
00:39:11,520 --> 00:39:14,000
yeah another way to sidestep this issue

895
00:39:14,000 --> 00:39:15,040
is the

896
00:39:15,040 --> 00:39:17,280
approach i pointed to before in proposal

897
00:39:17,280 --> 00:39:18,000
a

898
00:39:18,000 --> 00:39:19,760
which rather than allowing a general

899
00:39:19,760 --> 00:39:22,240
path on the right-hand side of in

900
00:39:22,240 --> 00:39:24,000
would have a more restrictive path which

901
00:39:24,000 --> 00:39:26,400
should only deliver a node list of

902
00:39:26,400 --> 00:39:28,400
maximum size one

903
00:39:28,400 --> 00:39:30,000
so we'd have to be an empty node list

904
00:39:30,000 --> 00:39:31,359
which would yield the value of the

905
00:39:31,359 --> 00:39:33,520
result false or it would be no less than

906
00:39:33,520 --> 00:39:35,440
a single value and then we'll be testing

907
00:39:35,440 --> 00:39:38,640
against that single value

908
00:39:41,440 --> 00:39:43,119
uh especially that gets rid of the

909
00:39:43,119 --> 00:39:46,000
options of having dot star and square

910
00:39:46,000 --> 00:39:47,839
bracket star and similar things and dot

911
00:39:47,839 --> 00:39:50,640
dot and so on

912
00:39:51,839 --> 00:39:54,400
where the single value could be an array

913
00:39:54,400 --> 00:39:57,200
yeah sure

914
00:39:57,200 --> 00:39:59,520
and that's probably just the case

915
00:39:59,520 --> 00:40:02,560
and n doesn't make sense unless it is

916
00:40:02,560 --> 00:40:05,119
yeah right

917
00:40:05,280 --> 00:40:05,920
so

918
00:40:05,920 --> 00:40:07,599
let me let me throw another example at

919
00:40:07,599 --> 00:40:09,599
you that i think is is

920
00:40:09,599 --> 00:40:11,839
would would not be able to be do done if

921
00:40:11,839 --> 00:40:15,280
you had that constraint so i have a json

922
00:40:15,280 --> 00:40:19,040
document with a list of companies

923
00:40:19,040 --> 00:40:21,520
and each company has

924
00:40:21,520 --> 00:40:25,599
a member that is an array of locations

925
00:40:25,599 --> 00:40:27,839
where that company is present

926
00:40:27,839 --> 00:40:31,040
so it's an array of objects with like an

927
00:40:31,040 --> 00:40:33,359
address with a city property

928
00:40:33,359 --> 00:40:37,200
and i want to do a filter on that

929
00:40:37,200 --> 00:40:39,920
set of companies so it's find me the

930
00:40:39,920 --> 00:40:44,240
company that has a location

931
00:40:44,240 --> 00:40:47,040
in the city of detroit

932
00:40:47,040 --> 00:40:49,599
so there i mean i would use a filter and

933
00:40:49,599 --> 00:40:52,079
in the filter condition i would have an

934
00:40:52,079 --> 00:40:52,960
in

935
00:40:52,960 --> 00:40:55,359
and i would want to do

936
00:40:55,359 --> 00:40:58,640
in and i would want to have a path on

937
00:40:58,640 --> 00:41:01,040
the right hand side of the n that digs

938
00:41:01,040 --> 00:41:03,040
into the locations and pulls out the

939
00:41:03,040 --> 00:41:07,599
cities that each company is uh

940
00:41:07,599 --> 00:41:09,119
present in

941
00:41:09,119 --> 00:41:11,119
and there may be multiple cities that

942
00:41:11,119 --> 00:41:13,760
the company is present in

943
00:41:13,760 --> 00:41:15,920
so if if the path on the right hand side

944
00:41:15,920 --> 00:41:18,000
only brings back one then am i right

945
00:41:18,000 --> 00:41:19,440
understand that that wouldn't be

946
00:41:19,440 --> 00:41:22,319
something we could do

947
00:41:23,760 --> 00:41:25,680
so the current time the in operator is a

948
00:41:25,680 --> 00:41:27,680
boolean right it just selects

949
00:41:27,680 --> 00:41:29,599
something

950
00:41:29,599 --> 00:41:32,160
a filter expression

951
00:41:32,160 --> 00:41:36,640
assuming you had a city field in your

952
00:41:37,040 --> 00:41:37,920
um

953
00:41:37,920 --> 00:41:39,280
so if you had a city field in your

954
00:41:39,280 --> 00:41:40,400
objects you could do it with an existing

955
00:41:40,400 --> 00:41:42,640
filter expression fine

956
00:41:42,640 --> 00:41:46,240
if the city field were an array oh

957
00:41:46,240 --> 00:41:47,520
um

958
00:41:47,520 --> 00:41:49,359
well i'm thinking nested right so you

959
00:41:49,359 --> 00:41:51,200
you've got one array of companies and

960
00:41:51,200 --> 00:41:53,760
then in each company you have an array

961
00:41:53,760 --> 00:41:56,400
of locations with addresses

962
00:41:56,400 --> 00:41:58,319
so you'd have a filter

963
00:41:58,319 --> 00:42:00,240
but in that filter expression i presume

964
00:42:00,240 --> 00:42:02,400
you can put an in condition in the

965
00:42:02,400 --> 00:42:03,520
filter

966
00:42:03,520 --> 00:42:06,000
expression

967
00:42:07,119 --> 00:42:09,520
yes so you essentially need a nested

968
00:42:09,520 --> 00:42:10,560
query

969
00:42:10,560 --> 00:42:11,839
yeah

970
00:42:11,839 --> 00:42:15,000
at all

971
00:42:18,319 --> 00:42:20,480
you you write a filter that gives you

972
00:42:20,480 --> 00:42:23,200
the list of companies

973
00:42:23,200 --> 00:42:24,000
and

974
00:42:24,000 --> 00:42:27,040
with the the nested query you look into

975
00:42:27,040 --> 00:42:29,760
each company whether it actually has

976
00:42:29,760 --> 00:42:32,000
the value you're looking for

977
00:42:32,000 --> 00:42:34,400
so you would have a nested

978
00:42:34,400 --> 00:42:36,400
query where the query

979
00:42:36,400 --> 00:42:38,400
for the location would be nested in the

980
00:42:38,400 --> 00:42:40,319
query for the company okay so you'd use

981
00:42:40,319 --> 00:42:42,480
a filter for the second thing too okay

982
00:42:42,480 --> 00:42:44,640
yeah so maybe that's i have to look into

983
00:42:44,640 --> 00:42:47,119
the filter syntax a bit more

984
00:42:47,119 --> 00:42:49,119
yeah we need to make examples so i think

985
00:42:49,119 --> 00:42:51,040
that that's really

986
00:42:51,040 --> 00:42:52,880
what my takeaway here that we need to

987
00:42:52,880 --> 00:42:54,800
make examples

988
00:42:54,800 --> 00:42:57,680
that show that we don't really need a

989
00:42:57,680 --> 00:42:58,800
path

990
00:42:58,800 --> 00:43:01,200
on the right hand side because these can

991
00:43:01,200 --> 00:43:05,200
all be done with filter expressions

992
00:43:05,200 --> 00:43:06,160
and

993
00:43:06,160 --> 00:43:07,920
if we have these examples then i think

994
00:43:07,920 --> 00:43:10,640
we can simplify this to just

995
00:43:10,640 --> 00:43:12,960
allowing array literal

996
00:43:12,960 --> 00:43:16,560
on the right hand side of the container

997
00:43:17,839 --> 00:43:19,760
at that point it seems much less

998
00:43:19,760 --> 00:43:21,119
valuable

999
00:43:21,119 --> 00:43:24,359
to be honest

1000
00:43:27,520 --> 00:43:30,079
i tend to agree with carson's approach

1001
00:43:30,079 --> 00:43:30,960
to

1002
00:43:30,960 --> 00:43:33,599
have a nested filter to

1003
00:43:33,599 --> 00:43:37,359
in the first step select

1004
00:43:38,880 --> 00:43:42,480
the areas the area of

1005
00:43:42,480 --> 00:43:43,839
cities

1006
00:43:43,839 --> 00:43:47,599
a company is present and

1007
00:43:47,599 --> 00:43:51,200
for each company for each

1008
00:43:51,200 --> 00:43:52,480
cities

1009
00:43:52,480 --> 00:43:53,359
of

1010
00:43:53,359 --> 00:43:55,359
each company i will

1011
00:43:55,359 --> 00:43:57,839
test by the in

1012
00:43:57,839 --> 00:44:00,960
operator if

1013
00:44:01,280 --> 00:44:02,480
that

1014
00:44:02,480 --> 00:44:03,599
city

1015
00:44:03,599 --> 00:44:05,119
of question is

1016
00:44:05,119 --> 00:44:08,119
contained

1017
00:44:17,119 --> 00:44:20,079
okay so so um

1018
00:44:20,079 --> 00:44:23,760
examples would be helpful as you said

1019
00:44:23,760 --> 00:44:25,599
um

1020
00:44:25,599 --> 00:44:27,359
at the moment

1021
00:44:27,359 --> 00:44:29,280
based on this discussion

1022
00:44:29,280 --> 00:44:31,920
i'm i'm having

1023
00:44:31,920 --> 00:44:34,400
difficulties seeing

1024
00:44:34,400 --> 00:44:36,640
where an in operator with just an array

1025
00:44:36,640 --> 00:44:39,040
lateral on the right

1026
00:44:39,040 --> 00:44:40,480
is interesting

1027
00:44:40,480 --> 00:44:43,040
and valuable

1028
00:44:43,599 --> 00:44:47,560
do we have use cases for that

1029
00:45:02,640 --> 00:45:04,880
i mean it becomes a shorthand for

1030
00:45:04,880 --> 00:45:07,680
or right at that point

1031
00:45:07,680 --> 00:45:10,680
correct

1032
00:45:23,440 --> 00:45:24,720
yeah i don't have a strong opinion on

1033
00:45:24,720 --> 00:45:26,560
this um

1034
00:45:26,560 --> 00:45:27,839
i never having used this construct

1035
00:45:27,839 --> 00:45:30,160
myself in jason pass i just don't have a

1036
00:45:30,160 --> 00:45:31,680
strong feeling for

1037
00:45:31,680 --> 00:45:34,720
how useful it really is

1038
00:45:34,720 --> 00:45:36,960
and whether it's worth the work to

1039
00:45:36,960 --> 00:45:39,119
to put it into the spec it sounds like

1040
00:45:39,119 --> 00:45:40,880
you know most most of the kinds of

1041
00:45:40,880 --> 00:45:42,079
things we're talking about can be done

1042
00:45:42,079 --> 00:45:44,240
with

1043
00:45:44,839 --> 00:45:46,800
filters do you think editors do you want

1044
00:45:46,800 --> 00:45:49,200
to put it in

1045
00:45:52,720 --> 00:45:55,119
well i still think it would be handy and

1046
00:45:55,119 --> 00:45:57,520
if we define it in such a way that it

1047
00:45:57,520 --> 00:45:59,599
really doesn't add complexity because

1048
00:45:59,599 --> 00:46:02,240
it's really just a shorthand for for

1049
00:46:02,240 --> 00:46:04,640
this junction of comparisons

1050
00:46:04,640 --> 00:46:06,319
then i think it's not a problem putting

1051
00:46:06,319 --> 00:46:09,480
it in

1052
00:46:23,920 --> 00:46:28,280
anybody object to that approach

1053
00:46:30,560 --> 00:46:31,599
we are

1054
00:46:31,599 --> 00:46:32,960
discussing

1055
00:46:32,960 --> 00:46:36,400
having structured types in

1056
00:46:36,400 --> 00:46:38,880
comparisons and

1057
00:46:38,880 --> 00:46:39,680
on

1058
00:46:39,680 --> 00:46:43,520
the left-hand side of

1059
00:46:43,520 --> 00:46:45,599
in

1060
00:46:45,680 --> 00:46:48,319
the containable

1061
00:46:48,319 --> 00:46:50,960
and i also tend

1062
00:46:50,960 --> 00:46:53,359
to allowing this

1063
00:46:53,359 --> 00:46:57,200
if it's really straight forward

1064
00:46:57,200 --> 00:46:58,560
and

1065
00:46:58,560 --> 00:47:00,480
not

1066
00:47:00,480 --> 00:47:04,800
very complex with implementations

1067
00:47:05,440 --> 00:47:08,240
so having structured types on the left

1068
00:47:08,240 --> 00:47:11,760
means you have to define

1069
00:47:11,760 --> 00:47:12,720
uh

1070
00:47:12,720 --> 00:47:14,480
object equality have we already we

1071
00:47:14,480 --> 00:47:17,440
haven't done that yet have we

1072
00:47:18,880 --> 00:47:21,119
yes

1073
00:47:22,319 --> 00:47:25,359
but you can also have a path on the left

1074
00:47:25,359 --> 00:47:26,559
hand side

1075
00:47:26,559 --> 00:47:28,079
yeah yeah so you have a left on so if

1076
00:47:28,079 --> 00:47:29,839
you have a path on the left hand side

1077
00:47:29,839 --> 00:47:32,880
and the path selects an object

1078
00:47:32,880 --> 00:47:34,240
yes

1079
00:47:34,240 --> 00:47:36,480
and then is that always false

1080
00:47:36,480 --> 00:47:38,160
or are we going to try and do object

1081
00:47:38,160 --> 00:47:40,319
equality in an array that might be

1082
00:47:40,319 --> 00:47:41,520
appear that might turn up on the

1083
00:47:41,520 --> 00:47:43,760
right-hand side

1084
00:47:43,760 --> 00:47:45,599
if you have an array

1085
00:47:45,599 --> 00:47:48,720
on the right-hand side and exactly this

1086
00:47:48,720 --> 00:47:52,400
object is in this

1087
00:47:52,400 --> 00:47:55,760
container in this array you will get a

1088
00:47:55,760 --> 00:47:56,800
match

1089
00:47:56,800 --> 00:48:01,040
this would be the consequence of that

1090
00:48:01,040 --> 00:48:02,000
right

1091
00:48:02,000 --> 00:48:03,760
um

1092
00:48:03,760 --> 00:48:05,680
does anybody have an opinion on that

1093
00:48:05,680 --> 00:48:08,559
that strikes me as as requiring us to

1094
00:48:08,559 --> 00:48:10,960
define object equality have we we

1095
00:48:10,960 --> 00:48:12,319
haven't done that yet anywhere else have

1096
00:48:12,319 --> 00:48:13,280
we

1097
00:48:13,280 --> 00:48:13,580
no

1098
00:48:13,580 --> 00:48:16,400
[Music]

1099
00:48:16,400 --> 00:48:18,000
and i

1100
00:48:18,000 --> 00:48:22,960
would say it is near trivial to do that

1101
00:48:22,960 --> 00:48:25,119
that there are way more complicated

1102
00:48:25,119 --> 00:48:27,359
parts in for instance equality of

1103
00:48:27,359 --> 00:48:28,720
strings

1104
00:48:28,720 --> 00:48:33,359
than inequality of arrays and objects

1105
00:48:33,359 --> 00:48:37,680
um but yeah it just adds one additional

1106
00:48:37,680 --> 00:48:39,520
thing you have to think about

1107
00:48:39,520 --> 00:48:42,480
uh so this is not about in this is about

1108
00:48:42,480 --> 00:48:45,200
equals equals would

1109
00:48:45,200 --> 00:48:46,559
allow

1110
00:48:46,559 --> 00:48:49,760
values on on both sides that that are

1111
00:48:49,760 --> 00:48:51,200
structured

1112
00:48:51,200 --> 00:48:52,079
and

1113
00:48:52,079 --> 00:48:54,400
then the next question is how far do we

1114
00:48:54,400 --> 00:48:56,960
go with the value notation

1115
00:48:56,960 --> 00:48:59,280
for these values so are we able to

1116
00:48:59,280 --> 00:49:01,359
notate arrays

1117
00:49:01,359 --> 00:49:04,240
and and objects that's

1118
00:49:04,240 --> 00:49:06,960
not much harder than defining comparison

1119
00:49:06,960 --> 00:49:09,920
so it's also a relatively inexpensive

1120
00:49:09,920 --> 00:49:11,760
thing to do

1121
00:49:11,760 --> 00:49:13,520
so if we actually have use cases for

1122
00:49:13,520 --> 00:49:15,520
this then i would say let's go ahead

1123
00:49:15,520 --> 00:49:17,839
with it

1124
00:49:22,960 --> 00:49:26,240
yeah i'd like to see a use case which

1125
00:49:26,240 --> 00:49:31,479
can't be satisfied by filters alone

1126
00:49:34,800 --> 00:49:38,839
i think daryl may have one

1127
00:49:52,720 --> 00:49:54,079
sorry i don't really have guidance to

1128
00:49:54,079 --> 00:49:56,640
offer here i i

1129
00:49:56,640 --> 00:49:58,240
i'm in favor of keeping the spec as

1130
00:49:58,240 --> 00:50:00,160
simple as possible but if there but you

1131
00:50:00,160 --> 00:50:02,400
know it does sound like a tractable

1132
00:50:02,400 --> 00:50:04,240
drafting problem to

1133
00:50:04,240 --> 00:50:05,280
to

1134
00:50:05,280 --> 00:50:08,240
define what the literals look like and

1135
00:50:08,240 --> 00:50:11,359
and produce surprise free results

1136
00:50:11,359 --> 00:50:13,599
but it's a substantial piece of work

1137
00:50:13,599 --> 00:50:14,720
um

1138
00:50:14,720 --> 00:50:17,280
so i think i what glenn said i'd want to

1139
00:50:17,280 --> 00:50:18,160
see

1140
00:50:18,160 --> 00:50:21,879
i'd want to see use cases

1141
00:50:27,760 --> 00:50:29,680
yes use cases

1142
00:50:29,680 --> 00:50:33,118
for this would be very helpful

1143
00:50:33,760 --> 00:50:36,240
so james is there a document where we

1144
00:50:36,240 --> 00:50:38,720
could find those rdap

1145
00:50:38,720 --> 00:50:41,839
use cases

1146
00:50:44,160 --> 00:50:45,359
uh

1147
00:50:45,359 --> 00:50:47,760
i guess you're talking to james gold yes

1148
00:50:47,760 --> 00:50:50,760
sorry

1149
00:50:56,800 --> 00:50:59,040
um

1150
00:51:02,319 --> 00:51:04,480
uh he did post a link earlier in the

1151
00:51:04,480 --> 00:51:06,319
chat other question is are there any

1152
00:51:06,319 --> 00:51:09,839
examples james

1153
00:51:13,520 --> 00:51:17,520
so how is rdap using json passes there

1154
00:51:17,520 --> 00:51:18,960
so

1155
00:51:18,960 --> 00:51:23,119
yeah so james posted a link to the draft

1156
00:51:23,119 --> 00:51:26,240
in question in the chat if you scroll up

1157
00:51:26,240 --> 00:51:30,160
a little bit or i can paste it back in

1158
00:51:32,160 --> 00:51:34,720
redacted fields in the registration data

1159
00:51:34,720 --> 00:51:37,440
access

1160
00:51:37,440 --> 00:51:40,800
i'll pretend i know what that means

1161
00:51:46,400 --> 00:51:49,119
are there examples

1162
00:51:49,119 --> 00:51:52,880
yes uh yes there is around uh section

1163
00:51:52,880 --> 00:51:56,079
3.2 can you hear me yes yes got it yes

1164
00:51:56,079 --> 00:51:58,160
you're audible yeah yeah there are

1165
00:51:58,160 --> 00:51:59,680
examples um

1166
00:51:59,680 --> 00:52:02,880
pretty much the goal of that draft

1167
00:52:02,880 --> 00:52:05,200
is uh i'm not sure if you're familiar

1168
00:52:05,200 --> 00:52:06,800
with who is

1169
00:52:06,800 --> 00:52:10,480
for domain names um art app is a json

1170
00:52:10,480 --> 00:52:12,400
version of who is

1171
00:52:12,400 --> 00:52:15,359
um and pretty much uh the need is to be

1172
00:52:15,359 --> 00:52:16,720
able to

1173
00:52:16,720 --> 00:52:19,119
explicitly specify what data has been

1174
00:52:19,119 --> 00:52:20,640
redacted

1175
00:52:20,640 --> 00:52:23,839
for privacy reasons uh and so

1176
00:52:23,839 --> 00:52:25,920
uh one approach that was being discussed

1177
00:52:25,920 --> 00:52:27,760
wasn't used like placeholder text and

1178
00:52:27,760 --> 00:52:29,920
that sort of thing but

1179
00:52:29,920 --> 00:52:32,800
the decision uh was within the working

1180
00:52:32,800 --> 00:52:35,040
group was to create an extension

1181
00:52:35,040 --> 00:52:38,400
to explicitly specify which of the json

1182
00:52:38,400 --> 00:52:40,800
members have been redacted so you can

1183
00:52:40,800 --> 00:52:42,720
tell the difference between it

1184
00:52:42,720 --> 00:52:46,640
non-existence and redaction so um pretty

1185
00:52:46,640 --> 00:52:49,280
much there's the use of json path to

1186
00:52:49,280 --> 00:52:51,200
formally define

1187
00:52:51,200 --> 00:52:55,680
uh what members have been redacted now

1188
00:52:55,680 --> 00:52:57,280
there's a combo of whether or not

1189
00:52:57,280 --> 00:53:00,160
there's redaction of object numbers or

1190
00:53:00,160 --> 00:53:02,800
of arrays because

1191
00:53:02,800 --> 00:53:04,319
um

1192
00:53:04,319 --> 00:53:08,720
rdap actually includes the use of

1193
00:53:10,160 --> 00:53:13,040
the name of it already

1194
00:53:13,280 --> 00:53:15,440
uh fixed length arrays

1195
00:53:15,440 --> 00:53:19,440
um that uh include contact data that uh

1196
00:53:19,440 --> 00:53:21,440
you pretty you can't remove you just

1197
00:53:21,440 --> 00:53:22,880
have to clear it

1198
00:53:22,880 --> 00:53:24,880
so we need to have the ability to

1199
00:53:24,880 --> 00:53:27,440
specify positions within an array

1200
00:53:27,440 --> 00:53:29,680
so there are uh examples within the

1201
00:53:29,680 --> 00:53:33,280
draft of the use of jsonpath so

1202
00:53:33,280 --> 00:53:36,319
if you uh review it and take a look uh

1203
00:53:36,319 --> 00:53:38,240
please provide any feedback related to

1204
00:53:38,240 --> 00:53:39,440
any uh

1205
00:53:39,440 --> 00:53:41,920
changes that uh you're thinking that

1206
00:53:41,920 --> 00:53:44,400
you're you're considering in this

1207
00:53:44,400 --> 00:53:47,200
uh draft and whether or not it needs to

1208
00:53:47,200 --> 00:53:49,119
be fixed in

1209
00:53:49,119 --> 00:53:52,079
the rdap redaction act so james i'm

1210
00:53:52,079 --> 00:53:53,680
looking at your first example here just

1211
00:53:53,680 --> 00:53:55,359
above section four

1212
00:53:55,359 --> 00:53:58,000
um okay and yeah i need to get to it

1213
00:53:58,000 --> 00:54:01,520
myself hold on sorry about that

1214
00:54:01,520 --> 00:54:03,920
all right

1215
00:54:05,920 --> 00:54:07,359
okay

1216
00:54:07,359 --> 00:54:10,160
and the first so you say you know we're

1217
00:54:10,160 --> 00:54:12,319
looking inside the redacted object and

1218
00:54:12,319 --> 00:54:13,440
it's got a

1219
00:54:13,440 --> 00:54:15,200
path member

1220
00:54:15,200 --> 00:54:17,280
and

1221
00:54:17,280 --> 00:54:18,400
i think it's actually probably got a

1222
00:54:18,400 --> 00:54:20,160
json syntax error in there but let's not

1223
00:54:20,160 --> 00:54:22,559
be pedantic

1224
00:54:22,559 --> 00:54:25,839
so the first part of it

1225
00:54:29,599 --> 00:54:31,680
is a filter expression right if i read

1226
00:54:31,680 --> 00:54:34,000
this properly i did validate the the

1227
00:54:34,000 --> 00:54:37,040
json path which uh which application

1228
00:54:37,040 --> 00:54:40,000
used to validate them but uh

1229
00:54:40,000 --> 00:54:41,920
they they were they were act they were

1230
00:54:41,920 --> 00:54:45,839
correct at the time yeah you've got a uh

1231
00:54:45,839 --> 00:54:46,559
a

1232
00:54:46,559 --> 00:54:48,480
a new line a return in the middle of

1233
00:54:48,480 --> 00:54:49,839
your

1234
00:54:49,839 --> 00:54:51,280
yeah that's because

1235
00:54:51,280 --> 00:54:53,200
that's because of the pagination

1236
00:54:53,200 --> 00:54:56,000
oh okay sorry pardon me pardon me okay

1237
00:54:56,000 --> 00:54:57,440
sorry about that

1238
00:54:57,440 --> 00:54:59,680
you know

1239
00:55:04,319 --> 00:55:06,640
am i my internal mental json path parser

1240
00:55:06,640 --> 00:55:08,160
isn't that great

1241
00:55:08,160 --> 00:55:10,480
um but this looks like yeah this is not

1242
00:55:10,480 --> 00:55:12,880
you know honestly the uh

1243
00:55:12,880 --> 00:55:15,440
there is a the name which we're going to

1244
00:55:15,440 --> 00:55:17,920
be setting up in iana registry uh as

1245
00:55:17,920 --> 00:55:18,880
well

1246
00:55:18,880 --> 00:55:22,480
uh to enable for a more human readable

1247
00:55:22,480 --> 00:55:24,799
indication of what the redacted member

1248
00:55:24,799 --> 00:55:26,559
is but then to have the actual

1249
00:55:26,559 --> 00:55:28,880
expression language for software to be

1250
00:55:28,880 --> 00:55:30,400
able to

1251
00:55:30,400 --> 00:55:31,760
identify

1252
00:55:31,760 --> 00:55:34,760
elements

1253
00:55:36,400 --> 00:55:37,839
so if you actually applied the json path

1254
00:55:37,839 --> 00:55:39,119
you would expect to get an empty field

1255
00:55:39,119 --> 00:55:41,359
back

1256
00:55:41,760 --> 00:55:43,520
it depends there's two different ways to

1257
00:55:43,520 --> 00:55:45,520
redact one is to remove and the other

1258
00:55:45,520 --> 00:55:47,040
one is to

1259
00:55:47,040 --> 00:55:49,359
have it be empty

1260
00:55:49,359 --> 00:55:53,280
right so j j cart is the name of the uh

1261
00:55:53,280 --> 00:55:56,640
of the rfc uh that's used in art app to

1262
00:55:56,640 --> 00:55:59,280
express contact data

1263
00:55:59,280 --> 00:56:02,720
and so uh that uses a heavy dose of

1264
00:56:02,720 --> 00:56:05,040
fixed length arrays

1265
00:56:05,040 --> 00:56:07,599
and so uh to be able to redact let's say

1266
00:56:07,599 --> 00:56:10,480
i don't know a telephone number

1267
00:56:10,480 --> 00:56:14,240
in j card it's not removal it's actually

1268
00:56:14,240 --> 00:56:16,240
blanking out or having to be a null

1269
00:56:16,240 --> 00:56:17,359
string

1270
00:56:17,359 --> 00:56:19,119
got it these examples are useful thanks

1271
00:56:19,119 --> 00:56:20,559
um but

1272
00:56:20,559 --> 00:56:22,240
on the face of it it looks to me like

1273
00:56:22,240 --> 00:56:23,920
they're all filters we're not really

1274
00:56:23,920 --> 00:56:26,319
using the n operator

1275
00:56:26,319 --> 00:56:29,200
no no that's what i was asking

1276
00:56:29,200 --> 00:56:32,160
i want to know whether or not

1277
00:56:32,400 --> 00:56:33,920
in was applicable

1278
00:56:33,920 --> 00:56:36,319
but yeah we don't have the use of the

1279
00:56:36,319 --> 00:56:39,599
inoperator in this rat

1280
00:56:42,799 --> 00:56:44,559
i think we just run out of use cases in

1281
00:56:44,559 --> 00:56:46,160
that case

1282
00:56:46,160 --> 00:56:48,879
yeah um

1283
00:56:50,559 --> 00:56:52,799
i'm so let's the radical idea would say

1284
00:56:52,799 --> 00:56:55,839
let's just take n out

1285
00:56:56,559 --> 00:56:58,640
if you want disjunction just write a

1286
00:56:58,640 --> 00:56:59,599
bunch of

1287
00:56:59,599 --> 00:57:01,839
you know

1288
00:57:07,200 --> 00:57:09,760
i can't disagree with it

1289
00:57:09,760 --> 00:57:11,280
sorry did you say you did or didn't

1290
00:57:11,280 --> 00:57:15,200
disagree i can't disagree

1291
00:57:16,400 --> 00:57:19,280
it's yeah i agree entirely but um others

1292
00:57:19,280 --> 00:57:22,799
are pushing for this so let them speak

1293
00:57:23,280 --> 00:57:24,000
so

1294
00:57:24,000 --> 00:57:26,480
i think our trait scenario

1295
00:57:26,480 --> 00:57:27,920
where

1296
00:57:27,920 --> 00:57:29,680
we need

1297
00:57:29,680 --> 00:57:32,720
the on the right hand side a path would

1298
00:57:32,720 --> 00:57:34,400
need the n

1299
00:57:34,400 --> 00:57:35,599
is that not

1300
00:57:35,599 --> 00:57:36,720
because

1301
00:57:36,720 --> 00:57:40,000
i don't think you can use an or

1302
00:57:40,000 --> 00:57:42,079
because i want to find you would use the

1303
00:57:42,079 --> 00:57:44,880
filter expression

1304
00:57:45,040 --> 00:57:47,520
you you would use the value that you're

1305
00:57:47,520 --> 00:57:49,040
looking for

1306
00:57:49,040 --> 00:57:51,839
as as the comparison value in a filter

1307
00:57:51,839 --> 00:57:54,160
expression so you you just filter out

1308
00:57:54,160 --> 00:57:56,000
all the instances

1309
00:57:56,000 --> 00:57:58,720
that have that value

1310
00:57:58,720 --> 00:57:59,760
and

1311
00:57:59,760 --> 00:58:02,480
if that list of instances is empty then

1312
00:58:02,480 --> 00:58:05,040
you don't have a match and if it's not

1313
00:58:05,040 --> 00:58:08,400
empty you have a match

1314
00:58:08,400 --> 00:58:11,680
but how do i do a filter

1315
00:58:11,680 --> 00:58:14,319
that says

1316
00:58:14,319 --> 00:58:17,520
this array of strings

1317
00:58:17,520 --> 00:58:21,799
contains one of these values

1318
00:58:22,960 --> 00:58:24,640
are you talking about literals are you

1319
00:58:24,640 --> 00:58:26,079
talking about things you find in the

1320
00:58:26,079 --> 00:58:29,200
document so in in the target document

1321
00:58:29,200 --> 00:58:31,200
there are objects that have

1322
00:58:31,200 --> 00:58:33,280
a member which is an array of string

1323
00:58:33,280 --> 00:58:36,319
literals yes and i want to get all i

1324
00:58:36,319 --> 00:58:40,079
want to pull back the objects that

1325
00:58:40,079 --> 00:58:42,880
have an array that contains one of one

1326
00:58:42,880 --> 00:58:44,559
of those stringless rules

1327
00:58:44,559 --> 00:58:46,319
yeah so then you have nested filter

1328
00:58:46,319 --> 00:58:48,000
expressions you have a

1329
00:58:48,000 --> 00:58:49,839
inner filter expression that goes

1330
00:58:49,839 --> 00:58:51,920
through the array

1331
00:58:51,920 --> 00:58:54,960
and gives you those array entries that

1332
00:58:54,960 --> 00:58:58,880
actually are what you're looking for

1333
00:58:59,040 --> 00:59:01,040
in the end you either have a match or

1334
00:59:01,040 --> 00:59:02,640
you don't have a match

1335
00:59:02,640 --> 00:59:04,880
and you use that boolean to actually

1336
00:59:04,880 --> 00:59:06,799
control an outer

1337
00:59:06,799 --> 00:59:09,280
filter that gives you the objects that

1338
00:59:09,280 --> 00:59:10,960
have this array

1339
00:59:10,960 --> 00:59:12,400
right and that's why i said we really

1340
00:59:12,400 --> 00:59:15,359
need to create examples because it yes

1341
00:59:15,359 --> 00:59:17,839
twisted thinking but i think it comes in

1342
00:59:17,839 --> 00:59:19,920
quite handy at the end

1343
00:59:19,920 --> 00:59:21,760
yeah i i agree i'm trying to create that

1344
00:59:21,760 --> 00:59:23,760
in my head and failing

1345
00:59:23,760 --> 00:59:25,040
so exactly

1346
00:59:25,040 --> 00:59:28,480
not not made for hits it's made for

1347
00:59:28,480 --> 00:59:31,480
editors

1348
00:59:32,000 --> 00:59:35,680
okay i'm starting to hear that um

1349
00:59:35,680 --> 00:59:37,200
uh

1350
00:59:37,200 --> 00:59:39,200
we're not 100 we are not at the moment

1351
00:59:39,200 --> 00:59:40,880
convinced that in

1352
00:59:40,880 --> 00:59:42,559
really adds value as anything more than

1353
00:59:42,559 --> 00:59:44,160
syntactic sugar

1354
00:59:44,160 --> 00:59:45,680
and

1355
00:59:45,680 --> 00:59:47,359
even at that level there's not a lot of

1356
00:59:47,359 --> 00:59:49,440
huge demand for it um

1357
00:59:49,440 --> 00:59:52,480
um carson as uh

1358
00:59:52,480 --> 00:59:54,319
well one of us should should

1359
00:59:54,319 --> 00:59:55,680
write that query

1360
00:59:55,680 --> 00:59:57,280
i'm going to have to go off and

1361
00:59:57,280 --> 00:59:58,720
ready to convince myself if it works but

1362
00:59:58,720 --> 01:00:01,839
i'll take your word for it

1363
01:00:02,000 --> 01:00:04,799
yeah can can whoever's work taking notes

1364
01:00:04,799 --> 01:00:08,839
make an action for me

1365
01:00:20,960 --> 01:00:21,920
okay

1366
01:00:21,920 --> 01:00:24,240
um

1367
01:00:25,680 --> 01:00:27,280
so karsten are you okay with just

1368
01:00:27,280 --> 01:00:29,440
leaving it out

1369
01:00:29,440 --> 01:00:31,359
what is it

1370
01:00:31,359 --> 01:00:33,359
the in

1371
01:00:33,359 --> 01:00:35,359
i'm okay with it

1372
01:00:35,359 --> 01:00:37,040
but i also was trying to accommodate

1373
01:00:37,040 --> 01:00:40,400
what stefan said

1374
01:00:40,640 --> 01:00:43,839
stefan what do you think

1375
01:00:44,640 --> 01:00:46,960
uh regarding uh

1376
01:00:46,960 --> 01:00:48,160
accepting

1377
01:00:48,160 --> 01:00:49,599
structure types

1378
01:00:49,599 --> 01:00:51,359
on the left hand side no

1379
01:00:51,359 --> 01:00:54,480
just the the the proposal on the table

1380
01:00:54,480 --> 01:00:57,680
is we don't really need in

1381
01:00:57,680 --> 01:01:01,040
we don't really need the in operator

1382
01:01:01,040 --> 01:01:03,279
yep

1383
01:01:04,559 --> 01:01:06,960
we have a we have a lot of

1384
01:01:06,960 --> 01:01:09,200
use cases that can't be solved with the

1385
01:01:09,200 --> 01:01:11,839
filter operator

1386
01:01:11,839 --> 01:01:14,559
well the field operator is is useful if

1387
01:01:14,559 --> 01:01:15,599
the

1388
01:01:15,599 --> 01:01:17,520
the right hand side comes from the

1389
01:01:17,520 --> 01:01:18,559
document

1390
01:01:18,559 --> 01:01:21,440
if the right hand side is part of the

1391
01:01:21,440 --> 01:01:24,160
path expression then this is just a

1392
01:01:24,160 --> 01:01:25,599
shorthand

1393
01:01:25,599 --> 01:01:27,920
for a disjunction for an or

1394
01:01:27,920 --> 01:01:31,119
but it still might be a rather

1395
01:01:31,119 --> 01:01:32,240
useful

1396
01:01:32,240 --> 01:01:34,799
shorthand

1397
01:01:35,359 --> 01:01:36,960
yes it's

1398
01:01:36,960 --> 01:01:39,839
correct you can

1399
01:01:40,160 --> 01:01:43,040
you can substitute the inoperator

1400
01:01:43,040 --> 01:01:44,559
through a

1401
01:01:44,559 --> 01:01:47,760
chain of or

1402
01:01:49,359 --> 01:01:51,440
expressions

1403
01:01:51,440 --> 01:01:53,280
yes i think

1404
01:01:53,280 --> 01:01:55,039
this is correct so

1405
01:01:55,039 --> 01:01:56,000
it's

1406
01:01:56,000 --> 01:01:57,680
you can

1407
01:01:57,680 --> 01:01:59,839
uh call it

1408
01:01:59,839 --> 01:02:02,078
uh

1409
01:02:03,680 --> 01:02:07,200
we can substitute it

1410
01:02:07,359 --> 01:02:09,039
so we we

1411
01:02:09,039 --> 01:02:10,960
do not need it

1412
01:02:10,960 --> 01:02:14,000
well okay let's minimalize

1413
01:02:14,000 --> 01:02:17,750
the spec it's okay i'm a minimalist

1414
01:02:17,750 --> 01:02:20,000
[Music]

1415
01:02:20,000 --> 01:02:22,960
and one advantage is that it's

1416
01:02:22,960 --> 01:02:25,599
relatively easy to add later on because

1417
01:02:25,599 --> 01:02:27,520
it would be a syntax error

1418
01:02:27,520 --> 01:02:29,359
in the current spec

1419
01:02:29,359 --> 01:02:32,000
so i'm i'm not feeling too uncomfortable

1420
01:02:32,000 --> 01:02:34,319
uncomfortable with leaving it out

1421
01:02:34,319 --> 01:02:36,559
because we can always edit data

1422
01:02:36,559 --> 01:02:38,079
okay we've invested quite a bit of time

1423
01:02:38,079 --> 01:02:40,880
in this shall we for the moment uh

1424
01:02:40,880 --> 01:02:42,960
declare that we will

1425
01:02:42,960 --> 01:02:45,119
simply not use this operator and you

1426
01:02:45,119 --> 01:02:47,599
know note that it's easy to add back in

1427
01:02:47,599 --> 01:02:50,160
if uh

1428
01:02:50,400 --> 01:02:53,760
real demand manifests

1429
01:02:58,799 --> 01:03:02,280
okay with me

1430
01:03:02,640 --> 01:03:04,879
yes

1431
01:03:05,520 --> 01:03:07,839
yes okay

1432
01:03:07,839 --> 01:03:09,440
okay

1433
01:03:09,440 --> 01:03:10,720
kirsten you want to move to our next

1434
01:03:10,720 --> 01:03:12,079
issue

1435
01:03:12,079 --> 01:03:14,000
yes we spent the first hour on the first

1436
01:03:14,000 --> 01:03:17,760
issue and we only have about 36 left

1437
01:03:17,760 --> 01:03:18,559
so

1438
01:03:18,559 --> 01:03:19,839
um

1439
01:03:19,839 --> 01:03:22,559
there is a proposal for an extension

1440
01:03:22,559 --> 01:03:24,960
that that

1441
01:03:24,960 --> 01:03:29,839
kind of adds x include to the jsonpath

1442
01:03:29,839 --> 01:03:34,078
and i would like to not do this

1443
01:03:35,520 --> 01:03:37,759
here

1444
01:03:42,640 --> 01:03:44,720
speaking as an individual uh i think

1445
01:03:44,720 --> 01:03:47,440
that this should be uh another ex part

1446
01:03:47,440 --> 01:03:51,680
of whatever we do in the extension space

1447
01:03:54,559 --> 01:03:56,000
i'm just looking at this thing to see

1448
01:03:56,000 --> 01:03:56,839
are there

1449
01:03:56,839 --> 01:04:01,839
compelling example use cases in it

1450
01:04:05,760 --> 01:04:08,880
oh my gosh it's huge

1451
01:04:11,680 --> 01:04:14,799
i also tend to not

1452
01:04:14,799 --> 01:04:16,400
include this

1453
01:04:16,400 --> 01:04:19,039
it adds a lot of

1454
01:04:19,039 --> 01:04:21,119
complexity to the

1455
01:04:21,119 --> 01:04:23,599
spec there's also a ton of

1456
01:04:23,599 --> 01:04:27,440
weird corner cases that comes with this

1457
01:04:27,440 --> 01:04:28,880
yes

1458
01:04:28,880 --> 01:04:34,240
it reminds me an awful lot of xml dtd's

1459
01:04:36,000 --> 01:04:39,880
for better or worse

1460
01:04:40,079 --> 01:04:41,599
yeah actually the main problem with the

1461
01:04:41,599 --> 01:04:44,160
proposal is that it destroys data

1462
01:04:44,160 --> 01:04:45,440
transparency

1463
01:04:45,440 --> 01:04:48,799
so you no longer can have every

1464
01:04:48,799 --> 01:04:51,599
uh json string value

1465
01:04:51,599 --> 01:04:53,920
in your input document because some of

1466
01:04:53,920 --> 01:04:55,760
these string values suddenly mean

1467
01:04:55,760 --> 01:04:57,359
something else

1468
01:04:57,359 --> 01:04:58,400
and

1469
01:04:58,400 --> 01:05:01,359
that's a pretty big step

1470
01:05:01,359 --> 01:05:02,640
okay is anybody going to speak up and

1471
01:05:02,640 --> 01:05:05,280
say we want this thing

1472
01:05:05,280 --> 01:05:06,079
um

1473
01:05:06,079 --> 01:05:10,319
unfortunately the uh both uh greg and

1474
01:05:10,319 --> 01:05:11,839
the uh

1475
01:05:11,839 --> 01:05:13,760
aforementioned author's name is not here

1476
01:05:13,760 --> 01:05:16,480
i don't think

1477
01:05:19,839 --> 01:05:22,240
i think what we probably should do is uh

1478
01:05:22,240 --> 01:05:24,319
comment on the issue

1479
01:05:24,319 --> 01:05:26,640
uh with with sort of the consensus from

1480
01:05:26,640 --> 01:05:28,000
this meeting that i think we should

1481
01:05:28,000 --> 01:05:29,920
include this in the base rfc but we

1482
01:05:29,920 --> 01:05:31,359
should leave it open

1483
01:05:31,359 --> 01:05:33,440
that it should be possible

1484
01:05:33,440 --> 01:05:38,160
uh when we if we support extensions

1485
01:05:42,480 --> 01:05:44,480
yeah the fun part is that this can be

1486
01:05:44,480 --> 01:05:46,880
framed as a preparation step before you

1487
01:05:46,880 --> 01:05:49,520
apply the actual json path

1488
01:05:49,520 --> 01:05:52,000
processing so it could be a completely

1489
01:05:52,000 --> 01:05:55,359
diff different part of the processing

1490
01:05:55,359 --> 01:05:57,280
model and wouldn't influence json path

1491
01:05:57,280 --> 01:05:58,319
at all

1492
01:05:58,319 --> 01:06:00,000
that doesn't mean you would implement it

1493
01:06:00,000 --> 01:06:01,680
this way but it would be defined that

1494
01:06:01,680 --> 01:06:04,680
way

1495
01:06:08,000 --> 01:06:09,839
okay so um

1496
01:06:09,839 --> 01:06:12,400
somebody will take the action item to um

1497
01:06:12,400 --> 01:06:14,400
write a comment on the issue

1498
01:06:14,400 --> 01:06:16,319
about this who who can sign up to do

1499
01:06:16,319 --> 01:06:17,359
that

1500
01:06:17,359 --> 01:06:18,720
i can

1501
01:06:18,720 --> 01:06:20,400
okay thank you kirsten

1502
01:06:20,400 --> 01:06:22,640
thank you

1503
01:06:24,559 --> 01:06:26,559
thanks

1504
01:06:26,559 --> 01:06:28,480
oops

1505
01:06:28,480 --> 01:06:30,559
what happened oh

1506
01:06:30,559 --> 01:06:31,760
um

1507
01:06:31,760 --> 01:06:35,200
yeah number 123 is absent equal to

1508
01:06:35,200 --> 01:06:38,880
absent so we are now in the the realm of

1509
01:06:38,880 --> 01:06:42,000
comparison semantics

1510
01:06:42,000 --> 01:06:45,680
and uh we we have

1511
01:06:45,680 --> 01:06:48,240
json values that we can compare with

1512
01:06:48,240 --> 01:06:49,200
currently

1513
01:06:49,200 --> 01:06:50,960
just primitive

1514
01:06:50,960 --> 01:06:52,160
values

1515
01:06:52,160 --> 01:06:54,480
and we have

1516
01:06:54,480 --> 01:06:56,640
[Music]

1517
01:06:56,640 --> 01:06:58,799
paths that we can write into the

1518
01:06:58,799 --> 01:07:01,039
comparison expressions

1519
01:07:01,039 --> 01:07:03,839
and these paths of course can

1520
01:07:03,839 --> 01:07:05,599
create an empty

1521
01:07:05,599 --> 01:07:08,079
node list

1522
01:07:08,079 --> 01:07:10,319
and the question is

1523
01:07:10,319 --> 01:07:12,720
what happens if you have two paths on

1524
01:07:12,720 --> 01:07:14,960
both sides of the comparison

1525
01:07:14,960 --> 01:07:16,319
and both

1526
01:07:16,319 --> 01:07:18,559
return an empty node list

1527
01:07:18,559 --> 01:07:23,640
does this compare or does it not compare

1528
01:07:30,319 --> 01:07:32,720
i see the javascript behavior is

1529
01:07:32,720 --> 01:07:36,959
um that undefined equals undefined

1530
01:07:38,000 --> 01:07:41,000
yes

1531
01:07:43,039 --> 01:07:46,079
ever the optimist

1532
01:07:52,960 --> 01:07:55,839
my natural inclination would done for

1533
01:07:55,839 --> 01:07:57,680
the original

1534
01:07:57,680 --> 01:07:59,200
is the original proposal saying it's

1535
01:07:59,200 --> 01:08:01,680
false if i have two things that don't

1536
01:08:01,680 --> 01:08:04,078
exist

1537
01:08:04,400 --> 01:08:08,000
i don't think i'm ever intentionally

1538
01:08:08,000 --> 01:08:09,359
trying to

1539
01:08:09,359 --> 01:08:12,480
detect that condition

1540
01:08:16,799 --> 01:08:19,279
well and uh as uh

1541
01:08:19,279 --> 01:08:22,960
who is it as daniel parker writes

1542
01:08:22,960 --> 01:08:26,080
in j way you would it you know you get

1543
01:08:26,080 --> 01:08:27,198
uh

1544
01:08:27,198 --> 01:08:31,080
that match can never work

1545
01:08:42,000 --> 01:08:46,080
unfortunately we have no undefined data

1546
01:08:46,080 --> 01:08:47,120
type in

1547
01:08:47,120 --> 01:08:49,679
json

1548
01:08:49,679 --> 01:08:52,679
so

1549
01:08:53,839 --> 01:08:57,040
we can convert it to false and this is

1550
01:08:57,040 --> 01:08:57,920
where

1551
01:08:57,920 --> 01:09:00,000
a lot of arguments

1552
01:09:00,000 --> 01:09:02,479
came up

1553
01:09:03,279 --> 01:09:05,520
when you compare

1554
01:09:05,520 --> 01:09:08,000
existing value

1555
01:09:08,000 --> 01:09:09,120
false

1556
01:09:09,120 --> 01:09:10,000
to an

1557
01:09:10,000 --> 01:09:11,520
not existing

1558
01:09:11,520 --> 01:09:13,439
value

1559
01:09:13,439 --> 01:09:15,279
converted to false

1560
01:09:15,279 --> 01:09:16,319
must be

1561
01:09:16,319 --> 01:09:17,759
true but

1562
01:09:17,759 --> 01:09:22,319
i think we need to distinguish these

1563
01:09:22,319 --> 01:09:23,520
cases

1564
01:09:23,520 --> 01:09:25,040
and this is a

1565
01:09:25,040 --> 01:09:26,479
little problem

1566
01:09:26,479 --> 01:09:28,718
but

1567
01:09:28,799 --> 01:09:29,600
it's

1568
01:09:29,600 --> 01:09:31,600
no problem to

1569
01:09:31,600 --> 01:09:32,560
handle

1570
01:09:32,560 --> 01:09:33,520
these

1571
01:09:33,520 --> 01:09:35,839
two undefined

1572
01:09:35,839 --> 01:09:37,839
comparisons like

1573
01:09:37,839 --> 01:09:40,399
javascript not a number

1574
01:09:40,399 --> 01:09:43,198
where we are not a number is not equal

1575
01:09:43,198 --> 01:09:45,198
not a number

1576
01:09:45,198 --> 01:09:47,679
in javascript it's we

1577
01:09:47,679 --> 01:09:52,560
i think we we are free to define it

1578
01:09:52,560 --> 01:09:53,279
we

1579
01:09:53,279 --> 01:09:54,880
don't need to

1580
01:09:54,880 --> 01:09:56,480
handle it loud

1581
01:09:56,480 --> 01:10:00,840
like javascript where undefined is equal

1582
01:10:00,840 --> 01:10:03,600
undefined yeah i have to say in my mind

1583
01:10:03,600 --> 01:10:07,120
that this feels like not a number

1584
01:10:08,640 --> 01:10:10,880
and the semantic the not a number in any

1585
01:10:10,880 --> 01:10:14,480
comparison is always false

1586
01:10:15,440 --> 01:10:17,839
yes

1587
01:10:18,800 --> 01:10:22,320
yeah if one if one wanted the semantics

1588
01:10:22,320 --> 01:10:24,000
that not finding something on the left

1589
01:10:24,000 --> 01:10:25,440
hand side and not finding something on

1590
01:10:25,440 --> 01:10:26,719
the right hand side

1591
01:10:26,719 --> 01:10:28,719
means it's not the same

1592
01:10:28,719 --> 01:10:31,360
then we could do something like

1593
01:10:31,360 --> 01:10:34,320
not a number but

1594
01:10:35,040 --> 01:10:39,080
for some reason i want that semantics

1595
01:10:46,400 --> 01:10:48,880
so if if i'm comparing two issues and

1596
01:10:48,880 --> 01:10:51,280
and uh one issue doesn't have a pull

1597
01:10:51,280 --> 01:10:52,960
request and the other one also doesn't

1598
01:10:52,960 --> 01:10:54,320
have a pull request

1599
01:10:54,320 --> 01:10:56,000
why why shouldn't

1600
01:10:56,000 --> 01:10:59,840
that be the same

1601
01:11:02,400 --> 01:11:04,800
is the is i mean

1602
01:11:04,800 --> 01:11:06,480
what you really want is an exists

1603
01:11:06,480 --> 01:11:08,080
predicate which really asks the question

1604
01:11:08,080 --> 01:11:09,679
you're trying to ask yeah we have that

1605
01:11:09,679 --> 01:11:12,719
we have that so you can combine

1606
01:11:12,719 --> 01:11:14,080
then that's what you should use and it

1607
01:11:14,080 --> 01:11:16,559
should not

1608
01:11:18,080 --> 01:11:20,719
we we want to compare

1609
01:11:20,719 --> 01:11:22,960
a missing thing is

1610
01:11:22,960 --> 01:11:27,679
equal another missing thing and

1611
01:11:27,679 --> 01:11:30,719
in fact we are interested in the things

1612
01:11:30,719 --> 01:11:35,920
themselves but we we can't compare them

1613
01:11:35,920 --> 01:11:37,600
and

1614
01:11:37,600 --> 01:11:38,960
discuss

1615
01:11:38,960 --> 01:11:42,640
the missing of them it's

1616
01:11:46,800 --> 01:11:49,120
i'm not quite sure what

1617
01:11:49,120 --> 01:11:51,120
both both uh

1618
01:11:51,120 --> 01:11:52,640
arguments

1619
01:11:52,640 --> 01:11:54,719
have some

1620
01:11:54,719 --> 01:11:57,520
little truth

1621
01:11:58,480 --> 01:12:00,159
i think it's

1622
01:12:00,159 --> 01:12:02,719
a definition

1623
01:12:02,719 --> 01:12:03,520
thing

1624
01:12:03,520 --> 01:12:05,679
i can't remember how

1625
01:12:05,679 --> 01:12:08,640
many implementations to

1626
01:12:08,640 --> 01:12:09,920
uh

1627
01:12:09,920 --> 01:12:11,920
equal and

1628
01:12:11,920 --> 01:12:12,880
how to

1629
01:12:12,880 --> 01:12:14,719
unequal

1630
01:12:14,719 --> 01:12:16,719
yeah so see actually

1631
01:12:16,719 --> 01:12:18,719
see bergman actually posted on the issue

1632
01:12:18,719 --> 01:12:20,560
and saying there's there's no consensus

1633
01:12:20,560 --> 01:12:23,440
not even a majority oh yeah yeah yeah i

1634
01:12:23,440 --> 01:12:26,239
i remember

1635
01:12:28,320 --> 01:12:29,520
basically naive javascript

1636
01:12:29,520 --> 01:12:31,360
implementations will probably

1637
01:12:31,360 --> 01:12:33,679
do it

1638
01:12:35,520 --> 01:12:37,199
in the case of jsonpath though we're

1639
01:12:37,199 --> 01:12:39,760
using boolean expressions primarily for

1640
01:12:39,760 --> 01:12:41,760
filters right so

1641
01:12:41,760 --> 01:12:43,199
it's the case of

1642
01:12:43,199 --> 01:12:45,360
i want to go and retrieve a bunch of

1643
01:12:45,360 --> 01:12:47,679
objects that meet a criteria

1644
01:12:47,679 --> 01:12:50,480
in the case where we run into does not

1645
01:12:50,480 --> 01:12:52,320
exist

1646
01:12:52,320 --> 01:12:55,280
then we don't know whether it's equal or

1647
01:12:55,280 --> 01:12:57,760
not equal

1648
01:12:57,760 --> 01:12:58,719
so

1649
01:12:58,719 --> 01:12:59,440
i

1650
01:12:59,440 --> 01:13:00,800
would have thought

1651
01:13:00,800 --> 01:13:02,960
the default behavior is don't return

1652
01:13:02,960 --> 01:13:04,560
that thing if you can't determine

1653
01:13:04,560 --> 01:13:06,320
whether or not

1654
01:13:06,320 --> 01:13:09,360
the condition is met

1655
01:13:10,719 --> 01:13:13,679
which i think is

1656
01:13:13,679 --> 01:13:16,560
going back to the not a number approach

1657
01:13:16,560 --> 01:13:19,560
right

1658
01:13:20,640 --> 01:13:21,600
indeed

1659
01:13:21,600 --> 01:13:25,120
i think that's a fair analogy

1660
01:13:28,320 --> 01:13:29,840
so karsten you seem to be the one here

1661
01:13:29,840 --> 01:13:31,600
who who likes this

1662
01:13:31,600 --> 01:13:33,679
um

1663
01:13:33,679 --> 01:13:36,560
well first of all we all agree on

1664
01:13:36,560 --> 01:13:38,800
mapping the empty node list to a value

1665
01:13:38,800 --> 01:13:40,480
and we we just disagree on whether it

1666
01:13:40,480 --> 01:13:41,990
should be undefined or not a number

1667
01:13:41,990 --> 01:13:43,280
[Music]

1668
01:13:43,280 --> 01:13:44,719
and

1669
01:13:44,719 --> 01:13:46,880
i think that that's a significant

1670
01:13:46,880 --> 01:13:48,080
progress

1671
01:13:48,080 --> 01:13:50,320
having that agreement and then we can

1672
01:13:50,320 --> 01:13:52,480
actually look look at

1673
01:13:52,480 --> 01:13:54,880
examples and use cases to decide the

1674
01:13:54,880 --> 01:13:57,040
undefined versus not a number

1675
01:13:57,040 --> 01:14:00,360
uh thing

1676
01:14:11,760 --> 01:14:14,000
so you had the use the one use case of

1677
01:14:14,000 --> 01:14:16,880
you know what was it with prs with no

1678
01:14:16,880 --> 01:14:19,280
um something or other

1679
01:14:19,280 --> 01:14:21,520
issues npr's so you

1680
01:14:21,520 --> 01:14:23,600
look at

1681
01:14:23,600 --> 01:14:26,480
does does the issue have the same pr as

1682
01:14:26,480 --> 01:14:30,080
some other issue and if it's not there

1683
01:14:30,080 --> 01:14:32,719
then yes it has the same pr but if i

1684
01:14:32,719 --> 01:14:36,080
want to to test whether it has a pr at

1685
01:14:36,080 --> 01:14:37,040
all

1686
01:14:37,040 --> 01:14:39,040
then i do what lynn

1687
01:14:39,040 --> 01:14:43,159
wrote in in the chat

1688
01:14:46,239 --> 01:14:48,640
so i would first do an existence test

1689
01:14:48,640 --> 01:14:51,199
and and then do a comparison lens

1690
01:14:51,199 --> 01:14:53,360
example had an existence test and a few

1691
01:14:53,360 --> 01:14:55,040
more existing sets which is not what i

1692
01:14:55,040 --> 01:14:58,640
meant but we have existence tests so we

1693
01:14:58,640 --> 01:14:58,910
can

1694
01:14:58,910 --> 01:15:00,400
[Music]

1695
01:15:00,400 --> 01:15:04,159
code ourselves out of either decision

1696
01:15:04,159 --> 01:15:07,599
uh we just have to decide

1697
01:15:09,040 --> 01:15:10,320
so at the moment you would prefer

1698
01:15:10,320 --> 01:15:12,320
undefined like behavior

1699
01:15:12,320 --> 01:15:14,559
yes

1700
01:15:20,159 --> 01:15:21,920
we don't vote we don't vote in the itf

1701
01:15:21,920 --> 01:15:23,520
but at the moment i think you're in a

1702
01:15:23,520 --> 01:15:24,880
minority there

1703
01:15:24,880 --> 01:15:27,360
yeah yeah we call that in the rough

1704
01:15:27,360 --> 01:15:29,600
because we don't count but

1705
01:15:29,600 --> 01:15:31,679
it seems most people like like

1706
01:15:31,679 --> 01:15:32,690
another number better

1707
01:15:32,690 --> 01:15:34,000
[Music]

1708
01:15:34,000 --> 01:15:36,800
than undefined

1709
01:15:36,960 --> 01:15:40,320
to be more concrete here if i have

1710
01:15:40,320 --> 01:15:42,239
two objects and i

1711
01:15:42,239 --> 01:15:44,800
compare the color from both

1712
01:15:44,800 --> 01:15:46,000
but they

1713
01:15:46,000 --> 01:15:49,040
both have no color and i

1714
01:15:49,040 --> 01:15:53,280
uh ask if a dot color is equals

1715
01:15:53,280 --> 01:15:56,159
b dot color

1716
01:15:56,320 --> 01:15:58,080
should be true

1717
01:15:58,080 --> 01:16:00,640
i like carson's approach

1718
01:16:00,640 --> 01:16:05,040
if you really want to know if

1719
01:16:05,120 --> 01:16:08,159
one of the objects has

1720
01:16:08,159 --> 01:16:09,440
no

1721
01:16:09,440 --> 01:16:13,440
color color is missing you can

1722
01:16:13,440 --> 01:16:14,880
explicitly

1723
01:16:14,880 --> 01:16:15,760
test

1724
01:16:15,760 --> 01:16:18,080
that with the existence

1725
01:16:18,080 --> 01:16:21,080
operator

1726
01:16:26,800 --> 01:16:29,040
so

1727
01:16:30,239 --> 01:16:32,880
at dot color

1728
01:16:32,880 --> 01:16:35,199
and at

1729
01:16:35,199 --> 01:16:36,080
dot

1730
01:16:36,080 --> 01:16:38,560
color equals

1731
01:16:38,560 --> 01:16:42,880
dollar dot color for instance

1732
01:16:46,480 --> 01:16:49,600
yeah so you whatever we decide you can

1733
01:16:49,600 --> 01:16:51,600
always write

1734
01:16:51,600 --> 01:16:54,800
an existence test that inverts what we

1735
01:16:54,800 --> 01:16:57,679
decided so the question really is which

1736
01:16:57,679 --> 01:17:00,840
is the the default what happens if you

1737
01:17:00,840 --> 01:17:02,960
don't uh

1738
01:17:02,960 --> 01:17:05,840
further specify it with an existence

1739
01:17:05,840 --> 01:17:07,040
test

1740
01:17:07,040 --> 01:17:09,520
and yeah my gut feeling is that that

1741
01:17:09,520 --> 01:17:11,840
undefined is uh

1742
01:17:11,840 --> 01:17:16,239
the right thing so to to um

1743
01:17:16,239 --> 01:17:18,159
paths that

1744
01:17:18,159 --> 01:17:20,080
create no nodes

1745
01:17:20,080 --> 01:17:22,719
are the same for comparison unless you

1746
01:17:22,719 --> 01:17:25,760
go ahead and do your own existence check

1747
01:17:25,760 --> 01:17:27,760
and i'm hearing other people

1748
01:17:27,760 --> 01:17:30,239
saying that they would consider that

1749
01:17:30,239 --> 01:17:32,799
unnatural

1750
01:17:33,280 --> 01:17:35,120
my intuition says that the potential for

1751
01:17:35,120 --> 01:17:37,120
surprises is greater in the undefined

1752
01:17:37,120 --> 01:17:38,239
case

1753
01:17:38,239 --> 01:17:40,000
but i actually don't have an example to

1754
01:17:40,000 --> 01:17:42,159
back that up should we should we have a

1755
01:17:42,159 --> 01:17:46,639
use case contest on this one yes please

1756
01:17:51,440 --> 01:17:54,480
okay so i think our takeaway should

1757
01:17:54,480 --> 01:17:56,159
and please this is just

1758
01:17:56,159 --> 01:17:58,960
please disagree if you'd like my feeling

1759
01:17:58,960 --> 01:18:01,120
is we should take this to the mailing

1760
01:18:01,120 --> 01:18:03,840
list and and store some use throw some

1761
01:18:03,840 --> 01:18:05,520
use cases at each other

1762
01:18:05,520 --> 01:18:07,280
and uh

1763
01:18:07,280 --> 01:18:10,840
use that to guide our final

1764
01:18:10,840 --> 01:18:13,760
decision yeah but we we have whittled it

1765
01:18:13,760 --> 01:18:16,640
down to undefined and not a number so

1766
01:18:16,640 --> 01:18:18,480
these are the two semantics that we have

1767
01:18:18,480 --> 01:18:20,480
to decide between and that that's a

1768
01:18:20,480 --> 01:18:23,199
major process

1769
01:18:23,199 --> 01:18:26,199
great

1770
01:18:26,239 --> 01:18:27,840
yes

1771
01:18:27,840 --> 01:18:31,280
uh i think we just successfully got rid

1772
01:18:31,280 --> 01:18:34,320
of this problem

1773
01:18:38,400 --> 01:18:41,280
um

1774
01:18:41,280 --> 01:18:44,800
yeah here the

1775
01:18:45,360 --> 01:18:45,820
um

1776
01:18:45,820 --> 01:18:47,600
[Music]

1777
01:18:47,600 --> 01:18:50,960
we don't have an in-operator anymore and

1778
01:18:50,960 --> 01:18:52,960
we have

1779
01:18:52,960 --> 01:18:55,120
we haven't

1780
01:18:55,120 --> 01:18:56,960
defined what a ray x operator is so

1781
01:18:56,960 --> 01:19:00,640
maybe we can skip this one as well

1782
01:19:05,440 --> 01:19:08,320
this was we had a long discussion about

1783
01:19:08,320 --> 01:19:10,880
truthiness so what what does it mean to

1784
01:19:10,880 --> 01:19:13,199
use

1785
01:19:13,199 --> 01:19:15,440
dot foo as a standalone expression so

1786
01:19:15,440 --> 01:19:16,880
what what does a

1787
01:19:16,880 --> 01:19:19,440
path expression mean in the context of

1788
01:19:19,440 --> 01:19:20,110
the expression

1789
01:19:20,110 --> 01:19:21,199
[Music]

1790
01:19:21,199 --> 01:19:22,640
language

1791
01:19:22,640 --> 01:19:24,080
and uh

1792
01:19:24,080 --> 01:19:26,560
for for comparisons i think it's it's

1793
01:19:26,560 --> 01:19:29,360
pretty clear that we fetch the value

1794
01:19:29,360 --> 01:19:32,640
uh that is at that place and we we still

1795
01:19:32,640 --> 01:19:34,880
have to find out what we do if there is

1796
01:19:34,880 --> 01:19:36,960
no such value but this is the undefined

1797
01:19:36,960 --> 01:19:38,480
versus nan

1798
01:19:38,480 --> 01:19:39,600
problem

1799
01:19:39,600 --> 01:19:42,640
but for a boolean context we had some

1800
01:19:42,640 --> 01:19:45,360
discussion on whether we go with one of

1801
01:19:45,360 --> 01:19:47,280
those truthiness

1802
01:19:47,280 --> 01:19:50,320
things or turn at fu in a boolean

1803
01:19:50,320 --> 01:19:52,640
contest context to a

1804
01:19:52,640 --> 01:19:53,840
pure

1805
01:19:53,840 --> 01:19:55,520
existence

1806
01:19:55,520 --> 01:19:57,199
test

1807
01:19:57,199 --> 01:19:59,280
and my proposal is

1808
01:19:59,280 --> 01:20:02,000
yes it's an existence test and there are

1809
01:20:02,000 --> 01:20:03,520
two reasons for that

1810
01:20:03,520 --> 01:20:06,159
uh one is we don't have any other way to

1811
01:20:06,159 --> 01:20:08,719
do an existence test and this is the

1812
01:20:08,719 --> 01:20:10,000
best

1813
01:20:10,000 --> 01:20:12,480
uh and shortest way to do it

1814
01:20:12,480 --> 01:20:15,840
and second it gets rid of the truthiness

1815
01:20:15,840 --> 01:20:18,239
weirdness that we all love in in

1816
01:20:18,239 --> 01:20:20,719
javascript

1817
01:20:20,719 --> 01:20:23,280
is an empty array true or false

1818
01:20:23,280 --> 01:20:25,520
is an empty object true or false

1819
01:20:25,520 --> 01:20:26,800
and so on

1820
01:20:26,800 --> 01:20:28,719
it's a string with a single zero

1821
01:20:28,719 --> 01:20:30,400
character and a true or false is a

1822
01:20:30,400 --> 01:20:33,120
string with two zero characters and 12

1823
01:20:33,120 --> 01:20:34,159
volts

1824
01:20:34,159 --> 01:20:36,400
um so we wouldn't simply simply would

1825
01:20:36,400 --> 01:20:40,239
not open that kind of ones

1826
01:20:43,760 --> 01:20:46,320
so so just you're you're in favor of

1827
01:20:46,320 --> 01:20:48,080
pure existence test

1828
01:20:48,080 --> 01:20:49,679
yes

1829
01:20:49,679 --> 01:20:51,920
right

1830
01:20:51,920 --> 01:20:54,480
does anybody want to argue

1831
01:20:54,480 --> 01:20:56,718
for

1832
01:20:58,639 --> 01:21:02,800
the you know the the alternative

1833
01:21:04,080 --> 01:21:06,400
glenn

1834
01:21:07,600 --> 01:21:09,760
no i fully support that

1835
01:21:09,760 --> 01:21:11,120
okay that's what i thought i just wanted

1836
01:21:11,120 --> 01:21:13,120
to make sure i was reading you correctly

1837
01:21:13,120 --> 01:21:15,040
i i like it i just have one

1838
01:21:15,040 --> 01:21:17,199
clarification

1839
01:21:17,199 --> 01:21:18,719
if foo

1840
01:21:18,719 --> 01:21:22,000
was present but a boolean member that's

1841
01:21:22,000 --> 01:21:24,159
false it returns false even though it's

1842
01:21:24,159 --> 01:21:26,480
present right

1843
01:21:26,480 --> 01:21:27,440
no

1844
01:21:27,440 --> 01:21:29,840
no i think that's what we're just saying

1845
01:21:29,840 --> 01:21:31,679
but so

1846
01:21:31,679 --> 01:21:35,360
if you want to use the value of that

1847
01:21:35,360 --> 01:21:36,880
path expression

1848
01:21:36,880 --> 01:21:40,920
you need to put in a comparison

1849
01:21:43,360 --> 01:21:45,520
ah so you'd have to say

1850
01:21:45,520 --> 01:21:47,920
at dot foo equals

1851
01:21:47,920 --> 01:21:48,800
truth

1852
01:21:48,800 --> 01:21:50,000
true

1853
01:21:50,000 --> 01:21:52,480
you don't get at the value without using

1854
01:21:52,480 --> 01:21:55,199
a comparison expression

1855
01:21:55,199 --> 01:21:58,638
got it thank you yep

1856
01:22:03,280 --> 01:22:07,320
i sense something like consensus

1857
01:22:11,520 --> 01:22:14,960
okay i invite that up again

1858
01:22:23,120 --> 01:22:25,840
okay

1859
01:22:27,600 --> 01:22:29,840
one eight yeah i think that's just the

1860
01:22:29,840 --> 01:22:30,260
same

1861
01:22:30,260 --> 01:22:32,400
[Music]

1862
01:22:32,400 --> 01:22:34,480
issue and uh

1863
01:22:34,480 --> 01:22:36,080
probably we can

1864
01:22:36,080 --> 01:22:39,840
resolve it in the same direction

1865
01:22:42,960 --> 01:22:45,199
i like to have issues like this at the

1866
01:22:45,199 --> 01:22:47,120
end but

1867
01:22:47,120 --> 01:22:49,040
yeah

1868
01:22:49,040 --> 01:22:50,639
so the question was

1869
01:22:50,639 --> 01:22:53,600
do we do any normalization in our

1870
01:22:53,600 --> 01:22:57,360
comparisons and it turns out that

1871
01:22:57,360 --> 01:23:00,960
existing implementations don't

1872
01:23:00,960 --> 01:23:01,980
which

1873
01:23:01,980 --> 01:23:03,520
[Music]

1874
01:23:03,520 --> 01:23:06,000
being a german i consider to be a bit of

1875
01:23:06,000 --> 01:23:07,280
a problem

1876
01:23:07,280 --> 01:23:09,600
so this may be a place where you want to

1877
01:23:09,600 --> 01:23:11,040
to

1878
01:23:11,040 --> 01:23:13,840
do some extension sooner or later

1879
01:23:13,840 --> 01:23:17,120
but i'm i'm happy with that as the basic

1880
01:23:17,120 --> 01:23:19,199
uh behavior so it would essentially be a

1881
01:23:19,199 --> 01:23:20,880
byte string comparison if you think in

1882
01:23:20,880 --> 01:23:23,280
utf-8 or a code point

1883
01:23:23,280 --> 01:23:24,400
sequence

1884
01:23:24,400 --> 01:23:28,560
comparison if you think in unicode

1885
01:23:28,560 --> 01:23:30,400
code points

1886
01:23:30,400 --> 01:23:31,440
and

1887
01:23:31,440 --> 01:23:33,760
we can always go ahead and edit

1888
01:23:33,760 --> 01:23:36,239
normalizing later

1889
01:23:36,239 --> 01:23:38,639
and we probably would add a normalizing

1890
01:23:38,639 --> 01:23:41,040
comparison but also a normalizing

1891
01:23:41,040 --> 01:23:44,239
indexing and that's maybe something that

1892
01:23:44,239 --> 01:23:46,400
people don't have in mind when they

1893
01:23:46,400 --> 01:23:50,080
discuss this so if i'm looking for

1894
01:23:50,080 --> 01:23:52,560
i i think that if you want normalization

1895
01:23:52,560 --> 01:23:54,639
you really sorry i

1896
01:23:54,639 --> 01:23:56,080
chair hat off but

1897
01:23:56,080 --> 01:23:57,360
i'm passionate about this one if you

1898
01:23:57,360 --> 01:23:58,960
want normalization you have to ask for

1899
01:23:58,960 --> 01:24:00,000
it

1900
01:24:00,000 --> 01:24:01,600
you know otherwise you have

1901
01:24:01,600 --> 01:24:03,840
yes

1902
01:24:04,639 --> 01:24:06,960
i totally agree with that

1903
01:24:06,960 --> 01:24:08,960
because you have to say what kind of

1904
01:24:08,960 --> 01:24:10,320
normalization

1905
01:24:10,320 --> 01:24:12,799
exactly

1906
01:24:13,920 --> 01:24:15,360
and and i think you know if you look

1907
01:24:15,360 --> 01:24:19,040
across the spectrum of iatf rfcs um the

1908
01:24:19,040 --> 01:24:23,040
the practice is is very uniform that um

1909
01:24:23,040 --> 01:24:26,480
don't normalize just don't

1910
01:24:28,880 --> 01:24:31,760
well it's a little bit more subtle but

1911
01:24:31,760 --> 01:24:32,960
uh

1912
01:24:32,960 --> 01:24:36,480
yeah you don't just

1913
01:24:36,480 --> 01:24:38,719
normalize everything upon ingestion that

1914
01:24:38,719 --> 01:24:40,960
that it was a mistake that should never

1915
01:24:40,960 --> 01:24:42,639
be done

1916
01:24:42,639 --> 01:24:45,120
by the way to be better i think i prefer

1917
01:24:45,120 --> 01:24:46,800
uh code point comparison to a byte

1918
01:24:46,800 --> 01:24:49,280
string comparison because that you know

1919
01:24:49,280 --> 01:24:50,480
you might be using java and it's

1920
01:24:50,480 --> 01:24:52,320
actually utf-16 inside your code you

1921
01:24:52,320 --> 01:24:53,840
know you don't have to look at bytes

1922
01:24:53,840 --> 01:24:54,880
right

1923
01:24:54,880 --> 01:24:58,800
yeah so we can phrase it as budget

1924
01:25:04,080 --> 01:25:06,159
and that's not called unit comparison

1925
01:25:06,159 --> 01:25:06,960
but

1926
01:25:06,960 --> 01:25:10,440
point comparison

1927
01:25:12,960 --> 01:25:15,280
good

1928
01:25:17,280 --> 01:25:18,860
uh

1929
01:25:18,860 --> 01:25:21,840
[Music]

1930
01:25:21,840 --> 01:25:24,239
i didn't write any texts for this

1931
01:25:24,239 --> 01:25:28,320
109 let's have a look here

1932
01:25:30,239 --> 01:25:34,000
filtering without child selection

1933
01:25:34,000 --> 01:25:37,120
yeah i think that the question was

1934
01:25:37,120 --> 01:25:41,559
uh can can your

1935
01:25:42,639 --> 01:25:44,400
well right right now a filter expression

1936
01:25:44,400 --> 01:25:47,040
always goes into something and selects

1937
01:25:47,040 --> 01:25:48,719
things from that

1938
01:25:48,719 --> 01:25:50,880
and can you actually write a filter

1939
01:25:50,880 --> 01:25:53,840
expression that is not going into

1940
01:25:53,840 --> 01:25:56,320
something

1941
01:25:56,960 --> 01:25:59,040
which is a bit

1942
01:25:59,040 --> 01:26:00,960
weird but there were some examples in

1943
01:26:00,960 --> 01:26:02,400
that

1944
01:26:02,400 --> 01:26:05,400
ticket

1945
01:26:10,639 --> 01:26:12,000
i'm going through this trying to find

1946
01:26:12,000 --> 01:26:16,280
the thing you can't currently do

1947
01:26:38,000 --> 01:26:41,000
okay

1948
01:26:50,320 --> 01:26:52,800
uh stefan has a nice comment back in

1949
01:26:52,800 --> 01:26:55,199
july

1950
01:26:58,960 --> 01:27:03,560
yes i re i'm reading my comment

1951
01:27:14,400 --> 01:27:17,400
so

1952
01:27:29,360 --> 01:27:32,599
oh gosh

1953
01:27:36,400 --> 01:27:38,320
that was exactly my reaction when i read

1954
01:27:38,320 --> 01:27:40,799
the slides

1955
01:27:41,920 --> 01:27:43,440
i sympathize with you nuts and not

1956
01:27:43,440 --> 01:27:45,040
summarizing this one

1957
01:27:45,040 --> 01:27:47,120
question

1958
01:27:47,120 --> 01:27:50,239
yeah so my take is

1959
01:27:50,239 --> 01:27:51,440
this

1960
01:27:51,440 --> 01:27:54,800
really all works like it should and you

1961
01:27:54,800 --> 01:27:57,360
you have to work hard to come up with a

1962
01:27:57,360 --> 01:28:00,239
an example where where it doesn't work

1963
01:28:00,239 --> 01:28:02,400
so

1964
01:28:03,920 --> 01:28:05,600
maybe the main problem

1965
01:28:05,600 --> 01:28:06,719
here is

1966
01:28:06,719 --> 01:28:09,040
that came up after about half of the

1967
01:28:09,040 --> 01:28:10,080
discussion

1968
01:28:10,080 --> 01:28:12,080
that we don't have a good way to get at

1969
01:28:12,080 --> 01:28:13,520
the key

1970
01:28:13,520 --> 01:28:17,840
of an entry of the member

1971
01:28:19,120 --> 01:28:22,000
i think i understand

1972
01:28:22,000 --> 01:28:26,080
the the question now again

1973
01:28:26,080 --> 01:28:30,880
we we we do have a problem uh

1974
01:28:30,960 --> 01:28:33,199
to

1975
01:28:33,280 --> 01:28:35,120
select

1976
01:28:35,120 --> 01:28:36,880
from

1977
01:28:36,880 --> 01:28:40,360
the argument

1978
01:28:42,080 --> 01:28:46,239
take take the initial

1979
01:28:46,560 --> 01:28:47,840
question

1980
01:28:47,840 --> 01:28:49,440
there is

1981
01:28:49,440 --> 01:28:52,880
the argument is an object having four

1982
01:28:52,880 --> 01:28:55,199
members a b c d

1983
01:28:55,199 --> 01:28:56,480
and

1984
01:28:56,480 --> 01:28:58,239
we are not able

1985
01:28:58,239 --> 01:28:59,920
to

1986
01:28:59,920 --> 01:29:01,120
query

1987
01:29:01,120 --> 01:29:03,199
the argument

1988
01:29:03,199 --> 01:29:05,599
having

1989
01:29:06,719 --> 01:29:08,800
a member

1990
01:29:08,800 --> 01:29:10,719
named

1991
01:29:10,719 --> 01:29:12,000
a or

1992
01:29:12,000 --> 01:29:13,920
d

1993
01:29:13,920 --> 01:29:17,120
it's simply not possible you

1994
01:29:17,120 --> 01:29:20,639
all we can do is iterate

1995
01:29:20,639 --> 01:29:22,000
over the

1996
01:29:22,000 --> 01:29:24,000
argument

1997
01:29:24,000 --> 01:29:25,040
and

1998
01:29:25,040 --> 01:29:26,400
we get

1999
01:29:26,400 --> 01:29:31,360
the values of each member but we cannot

2000
01:29:31,360 --> 01:29:32,719
address

2001
01:29:32,719 --> 01:29:34,159
the key

2002
01:29:34,159 --> 01:29:36,400
so

2003
01:29:36,560 --> 01:29:38,960
the the

2004
01:29:38,960 --> 01:29:42,239
the subject of this issue

2005
01:29:42,239 --> 01:29:43,520
was

2006
01:29:43,520 --> 01:29:45,360
in the end i

2007
01:29:45,360 --> 01:29:47,199
i think

2008
01:29:47,199 --> 01:29:50,719
that we need something like at key or a

2009
01:29:50,719 --> 01:29:53,199
function to address

2010
01:29:53,199 --> 01:29:55,120
the key of

2011
01:29:55,120 --> 01:29:56,719
that

2012
01:29:56,719 --> 01:29:58,000
current

2013
01:29:58,000 --> 01:30:01,040
selected member or

2014
01:30:01,040 --> 01:30:04,000
element makes no sense but the key of a

2015
01:30:04,000 --> 01:30:07,000
member

2016
01:30:07,520 --> 01:30:10,400
but only

2017
01:30:11,760 --> 01:30:12,480
no

2018
01:30:12,480 --> 01:30:14,719
not not only for

2019
01:30:14,719 --> 01:30:16,400
the

2020
01:30:16,400 --> 01:30:19,040
top level

2021
01:30:19,120 --> 01:30:20,560
object

2022
01:30:20,560 --> 01:30:22,480
but for

2023
01:30:22,480 --> 01:30:25,600
every uh object but

2024
01:30:25,600 --> 01:30:27,520
carson was

2025
01:30:27,520 --> 01:30:30,960
correctly referring to the possibility

2026
01:30:30,960 --> 01:30:32,000
to

2027
01:30:32,000 --> 01:30:34,239
have

2028
01:30:36,400 --> 01:30:39,120
queries

2029
01:30:39,440 --> 01:30:42,320
containing queries

2030
01:30:42,320 --> 01:30:44,560
but this is not possible

2031
01:30:44,560 --> 01:30:49,440
at the top level and this is the problem

2032
01:30:49,440 --> 01:30:50,320
uh

2033
01:30:50,320 --> 01:30:52,719
addressed here i think if i remember

2034
01:30:52,719 --> 01:30:55,280
correctly

2035
01:30:56,159 --> 01:30:57,760
yeah once you have selected the value

2036
01:30:57,760 --> 01:30:59,360
you have lost the

2037
01:30:59,360 --> 01:31:00,800
member name

2038
01:31:00,800 --> 01:31:02,560
that's really

2039
01:31:02,560 --> 01:31:04,320
the the problem that we have in a

2040
01:31:04,320 --> 01:31:07,320
nutshell

2041
01:31:18,560 --> 01:31:19,920
uh

2042
01:31:19,920 --> 01:31:22,480
for objects deeper in the

2043
01:31:22,480 --> 01:31:24,320
in the tree we can

2044
01:31:24,320 --> 01:31:26,320
resolve this by

2045
01:31:26,320 --> 01:31:29,840
having a query inside of a query but

2046
01:31:29,840 --> 01:31:32,239
this is not possible for the

2047
01:31:32,239 --> 01:31:34,080
top level

2048
01:31:34,080 --> 01:31:36,559
object

2049
01:31:39,360 --> 01:31:40,800
i think having the

2050
01:31:40,800 --> 01:31:42,239
key

2051
01:31:42,239 --> 01:31:45,440
syntax seems like a fairly

2052
01:31:45,440 --> 01:31:49,280
natural extension to support that

2053
01:31:49,280 --> 01:31:51,040
well that means you can get at the key

2054
01:31:51,040 --> 01:31:52,480
but then you no longer can get at the

2055
01:31:52,480 --> 01:31:54,879
video

2056
01:31:55,840 --> 01:31:58,880
isn't at the value in this case

2057
01:31:58,880 --> 01:32:01,120
yes

2058
01:32:01,840 --> 01:32:04,639
that's why it feels kind of there's

2059
01:32:04,639 --> 01:32:06,719
there's at for the value and at key for

2060
01:32:06,719 --> 01:32:09,120
the key of the of the value referenced

2061
01:32:09,120 --> 01:32:12,360
by app

2062
01:32:12,560 --> 01:32:14,560
yes and and how do you construct

2063
01:32:14,560 --> 01:32:18,000
something that you actually return

2064
01:32:23,840 --> 01:32:25,920
assuming it would primarily be used in

2065
01:32:25,920 --> 01:32:28,400
filters

2066
01:32:32,639 --> 01:32:33,520
that's right you're looking for

2067
01:32:33,520 --> 01:32:36,239
something that can be used in filters

2068
01:32:36,239 --> 01:32:37,520
sorry

2069
01:32:37,520 --> 01:32:38,639
you're looking for something that can be

2070
01:32:38,639 --> 01:32:41,520
used in filters right right so at key

2071
01:32:41,520 --> 01:32:42,560
equals

2072
01:32:42,560 --> 01:32:44,719
a

2073
01:32:47,280 --> 01:32:49,920
yeah but that still the filter gives you

2074
01:32:49,920 --> 01:32:51,920
the value not the key

2075
01:32:51,920 --> 01:32:53,280
so the the

2076
01:32:53,280 --> 01:32:55,040
expression language would have a way of

2077
01:32:55,040 --> 01:32:57,120
getting at the key but it doesn't allow

2078
01:32:57,120 --> 01:32:58,560
you to return

2079
01:32:58,560 --> 01:33:00,719
the key so you're essentially in the

2080
01:33:00,719 --> 01:33:02,159
where clause

2081
01:33:02,159 --> 01:33:04,000
of a select statement

2082
01:33:04,000 --> 01:33:06,800
but you you don't get to modify the

2083
01:33:06,800 --> 01:33:10,239
select part of the select statement

2084
01:33:10,239 --> 01:33:12,560
so oh i see they want to return

2085
01:33:12,560 --> 01:33:16,320
the key as well and they know that yes

2086
01:33:18,400 --> 01:33:21,120
and this is entirely outside the current

2087
01:33:21,120 --> 01:33:23,199
processing model which is why it's so

2088
01:33:23,199 --> 01:33:25,599
puzzling

2089
01:33:28,159 --> 01:33:31,520
it's quite simply as that you

2090
01:33:31,520 --> 01:33:32,639
want to

2091
01:33:32,639 --> 01:33:33,679
query

2092
01:33:33,679 --> 01:33:37,040
the top level argument for

2093
01:33:37,040 --> 01:33:38,320
uh

2094
01:33:38,320 --> 01:33:41,440
owing a member named a

2095
01:33:41,440 --> 01:33:43,120
does

2096
01:33:43,120 --> 01:33:46,880
the top level object have a member named

2097
01:33:46,880 --> 01:33:48,560
a that's

2098
01:33:48,560 --> 01:33:49,880
at current not possible

2099
01:33:49,880 --> 01:33:52,400
[Music]

2100
01:33:52,400 --> 01:33:54,239
well the querying is possible you can

2101
01:33:54,239 --> 01:33:55,600
write down the where will you but you

2102
01:33:55,600 --> 01:33:58,960
cannot write down the select

2103
01:34:00,239 --> 01:34:02,560
what you get is the value not the whole

2104
01:34:02,560 --> 01:34:05,560
thing

2105
01:34:05,840 --> 01:34:07,840
was there actually a request in the

2106
01:34:07,840 --> 01:34:09,360
thread for that

2107
01:34:09,360 --> 01:34:11,040
because i think the initial request was

2108
01:34:11,040 --> 01:34:15,040
just being able to filter by the key

2109
01:34:16,320 --> 01:34:18,480
yeah i think that that was a bit of an

2110
01:34:18,480 --> 01:34:20,239
[Music]

2111
01:34:20,239 --> 01:34:23,360
unfortunate phrasing

2112
01:34:31,199 --> 01:34:34,320
all we can do is to iterate over

2113
01:34:34,320 --> 01:34:37,440
all members of the top level object

2114
01:34:37,440 --> 01:34:38,400
and

2115
01:34:38,400 --> 01:34:39,679
ask

2116
01:34:39,679 --> 01:34:40,639
for

2117
01:34:40,639 --> 01:34:45,360
their values but we cannot ask for

2118
01:34:45,360 --> 01:34:47,199
the uh

2119
01:34:47,199 --> 01:34:50,080
for the key so

2120
01:34:50,080 --> 01:34:51,760
uh

2121
01:34:51,760 --> 01:34:55,360
it's simply not possible to

2122
01:34:55,360 --> 01:34:57,679
answer the question

2123
01:34:57,679 --> 01:34:59,199
via a query

2124
01:34:59,199 --> 01:35:02,800
does top level object have a member

2125
01:35:02,800 --> 01:35:03,760
called

2126
01:35:03,760 --> 01:35:04,880
named

2127
01:35:04,880 --> 01:35:07,040
a

2128
01:35:07,360 --> 01:35:08,719
you can answer that question but you

2129
01:35:08,719 --> 01:35:11,760
cannot return that member

2130
01:35:12,159 --> 01:35:15,839
how can i answer that question

2131
01:35:20,000 --> 01:35:21,679
no no

2132
01:35:21,679 --> 01:35:24,080
no it means

2133
01:35:24,080 --> 01:35:24,880
earth

2134
01:35:24,880 --> 01:35:28,400
a b c d

2135
01:35:28,400 --> 01:35:30,880
if you are if you ask

2136
01:35:30,880 --> 01:35:35,440
at dot a you ask for the first member do

2137
01:35:35,440 --> 01:35:36,639
you have

2138
01:35:36,639 --> 01:35:38,000
uh

2139
01:35:38,000 --> 01:35:39,520
do you are you

2140
01:35:39,520 --> 01:35:42,880
object and i have a member called a

2141
01:35:42,880 --> 01:35:45,840
yes it's one level deeper

2142
01:35:45,840 --> 01:35:47,840
what you return is wondering deeper but

2143
01:35:47,840 --> 01:35:50,400
the question that you are answering

2144
01:35:50,400 --> 01:35:52,800
is the same

2145
01:35:52,800 --> 01:35:53,920
i'm trying to

2146
01:35:53,920 --> 01:35:56,000
explain that this is really a problem

2147
01:35:56,000 --> 01:35:57,920
with what you return and not a problem

2148
01:35:57,920 --> 01:36:01,440
with selecting in the right place

2149
01:36:02,159 --> 01:36:04,320
the the ad

2150
01:36:04,320 --> 01:36:05,119
is

2151
01:36:05,119 --> 01:36:07,520
during the iteration process

2152
01:36:07,520 --> 01:36:09,840
will deliver

2153
01:36:09,840 --> 01:36:14,000
the members a b c and d

2154
01:36:14,000 --> 01:36:15,679
and if you

2155
01:36:15,679 --> 01:36:16,800
query

2156
01:36:16,800 --> 01:36:18,719
at dot a

2157
01:36:18,719 --> 01:36:21,440
you ask for each member do you have a

2158
01:36:21,440 --> 01:36:25,040
member named a

2159
01:36:25,040 --> 01:36:26,000
so

2160
01:36:26,000 --> 01:36:28,320
it would be true

2161
01:36:28,320 --> 01:36:30,400
hold only if

2162
01:36:30,400 --> 01:36:31,679
a

2163
01:36:31,679 --> 01:36:38,520
or b or c or d do have a member named a

2164
01:36:40,080 --> 01:36:41,679
you wouldn't be able to use a filter

2165
01:36:41,679 --> 01:36:43,920
expression because

2166
01:36:43,920 --> 01:36:45,920
that has the semantics that you are

2167
01:36:45,920 --> 01:36:51,239
describing you just would write at dot a

2168
01:36:59,760 --> 01:37:03,040
so you you cannot undo the diving into

2169
01:37:03,040 --> 01:37:04,000
the

2170
01:37:04,000 --> 01:37:06,159
structure that the filter expression

2171
01:37:06,159 --> 01:37:08,480
does but i don't think that's actually a

2172
01:37:08,480 --> 01:37:10,960
problem the problem here is that

2173
01:37:10,960 --> 01:37:14,080
people don't want add.a

2174
01:37:14,080 --> 01:37:15,840
they want

2175
01:37:15,840 --> 01:37:17,920
a new object

2176
01:37:17,920 --> 01:37:20,880
that just has the member a and nothing

2177
01:37:20,880 --> 01:37:23,119
else

2178
01:37:24,000 --> 01:37:27,679
and that kind of projection we can do

2179
01:37:31,440 --> 01:37:33,440
i'm confused

2180
01:37:33,440 --> 01:37:35,870
this is a very confusing subject

2181
01:37:35,870 --> 01:37:40,269
[Laughter]

2182
01:37:41,360 --> 01:37:43,280
what should we do

2183
01:37:43,280 --> 01:37:45,280
oh i i thought i understood it but now i

2184
01:37:45,280 --> 01:37:49,800
realized i don't understand it oh

2185
01:37:59,440 --> 01:38:02,719
i agree that we need

2186
01:38:04,560 --> 01:38:07,280
an example

2187
01:38:07,360 --> 01:38:11,119
chapter in in in the spec where where

2188
01:38:11,119 --> 01:38:12,080
we

2189
01:38:12,080 --> 01:38:13,440
do need

2190
01:38:13,440 --> 01:38:16,880
examples like this

2191
01:38:16,880 --> 01:38:19,760
and solutions

2192
01:38:24,320 --> 01:38:25,760
i'm looking at the very first statement

2193
01:38:25,760 --> 01:38:28,320
of the problem

2194
01:38:28,719 --> 01:38:29,760
yeah

2195
01:38:29,760 --> 01:38:31,520
and i'm having trouble understanding

2196
01:38:31,520 --> 01:38:35,360
what uh what he wants

2197
01:38:35,600 --> 01:38:37,119
what does he want his output to look

2198
01:38:37,119 --> 01:38:40,080
like what i mean what

2199
01:38:42,080 --> 01:38:43,600
yeah i think we need clarification

2200
01:38:43,600 --> 01:38:45,840
really

2201
01:38:52,880 --> 01:38:56,080
he wants to

2202
01:38:56,400 --> 01:38:57,679
select

2203
01:38:57,679 --> 01:38:59,199
all

2204
01:38:59,199 --> 01:39:01,199
sub-objects

2205
01:39:01,199 --> 01:39:05,440
of the the top-level object except

2206
01:39:05,440 --> 01:39:06,960
the last one

2207
01:39:06,960 --> 01:39:07,679
so

2208
01:39:07,679 --> 01:39:11,679
you need to identify the objects via

2209
01:39:11,679 --> 01:39:15,440
their key but you can't

2210
01:39:15,440 --> 01:39:16,159
so

2211
01:39:16,159 --> 01:39:17,600
it

2212
01:39:17,600 --> 01:39:21,199
reduces to the problem to

2213
01:39:21,199 --> 01:39:22,400
ask

2214
01:39:22,400 --> 01:39:26,639
the selected objects selected by it

2215
01:39:26,639 --> 01:39:29,440
for their key

2216
01:39:30,800 --> 01:39:33,040
right

2217
01:39:34,400 --> 01:39:36,239
good go ahead

2218
01:39:36,239 --> 01:39:38,719
if you look at the

2219
01:39:38,719 --> 01:39:40,800
solution he provides

2220
01:39:40,800 --> 01:39:44,159
he essentially is doing projection

2221
01:39:44,159 --> 01:39:47,280
and again json path is not doing

2222
01:39:47,280 --> 01:39:49,440
projection it's only doing selection so

2223
01:39:49,440 --> 01:39:52,560
the where part of an sql statement

2224
01:39:52,560 --> 01:39:56,400
it's not doing the select part

2225
01:39:56,400 --> 01:39:59,199
and of course we could put that in but

2226
01:39:59,199 --> 01:40:01,119
that would be a pretty significant

2227
01:40:01,119 --> 01:40:04,880
addition to the processing model

2228
01:40:04,960 --> 01:40:07,119
i mean at some level the

2229
01:40:07,119 --> 01:40:09,280
a member of an object is not really a

2230
01:40:09,280 --> 01:40:11,360
standalone citizen

2231
01:40:11,360 --> 01:40:12,880
where the member includes both the name

2232
01:40:12,880 --> 01:40:14,320
and the value

2233
01:40:14,320 --> 01:40:16,639
right yes

2234
01:40:16,639 --> 01:40:19,600
but once you have a

2235
01:40:20,239 --> 01:40:21,119
member

2236
01:40:21,119 --> 01:40:23,119
identified by

2237
01:40:23,119 --> 01:40:24,880
the ad

2238
01:40:24,880 --> 01:40:26,320
operator you

2239
01:40:26,320 --> 01:40:28,480
cannot tell

2240
01:40:28,480 --> 01:40:31,839
its key anymore

2241
01:40:33,040 --> 01:40:34,960
well that's the point isn't it that

2242
01:40:34,960 --> 01:40:37,119
doesn't identify a member it identifies

2243
01:40:37,119 --> 01:40:41,119
the value of the member

2244
01:40:41,440 --> 01:40:45,360
yes so we've lost context

2245
01:40:48,880 --> 01:40:51,360
yes you know a key function would be

2246
01:40:51,360 --> 01:40:53,440
magical in a sense

2247
01:40:53,440 --> 01:40:55,600
because you're applying key to a

2248
01:40:55,600 --> 01:40:57,360
value and you're suddenly

2249
01:40:57,360 --> 01:40:59,440
able to tell the context

2250
01:40:59,440 --> 01:41:01,040
so i think it breaks our processing

2251
01:41:01,040 --> 01:41:05,239
model and we should support this

2252
01:41:09,679 --> 01:41:11,199
it's interesting because because we've

2253
01:41:11,199 --> 01:41:13,440
noticed the problem properly in the spec

2254
01:41:13,440 --> 01:41:15,840
we're doing we started with james bath

2255
01:41:15,840 --> 01:41:18,000
and james path is optimized for

2256
01:41:18,000 --> 01:41:20,159
projections and isn't

2257
01:41:20,159 --> 01:41:23,760
as good at actually pointing at things

2258
01:41:23,760 --> 01:41:25,920
it's maybe maybe the answer is you're

2259
01:41:25,920 --> 01:41:27,600
using the wrong tool for the job if you

2260
01:41:27,600 --> 01:41:31,080
want to do projections

2261
01:41:34,400 --> 01:41:39,080
adjacent path should focus on selection

2262
01:41:49,040 --> 01:41:50,320
yeah i confess to not having thought

2263
01:41:50,320 --> 01:41:51,679
about this one

2264
01:41:51,679 --> 01:41:53,840
enough i'm looking at the various

2265
01:41:53,840 --> 01:41:56,159
proposed solutions

2266
01:41:56,159 --> 01:42:00,360
and none of them are really beautiful

2267
01:42:05,520 --> 01:42:08,719
yeah so for people that are as old as i

2268
01:42:08,719 --> 01:42:10,239
am

2269
01:42:10,239 --> 01:42:15,159
jason passes x path and not exit 30.

2270
01:42:17,760 --> 01:42:20,960
now if you had the at key syntax

2271
01:42:20,960 --> 01:42:23,840
that would allow you to do selections

2272
01:42:23,840 --> 01:42:25,760
based on

2273
01:42:25,760 --> 01:42:29,280
what the key of this value was

2274
01:42:29,280 --> 01:42:31,280
so it's still in the spirit of i'm

2275
01:42:31,280 --> 01:42:33,600
selecting things not projecting things

2276
01:42:33,600 --> 01:42:34,719
yeah

2277
01:42:34,719 --> 01:42:36,320
um it just

2278
01:42:36,320 --> 01:42:38,800
doesn't support

2279
01:42:38,800 --> 01:42:41,280
you would go up in the hierarchy

2280
01:42:41,280 --> 01:42:44,320
which we currently don't

2281
01:42:47,440 --> 01:42:49,840
but that's a smaller change to the

2282
01:42:49,840 --> 01:42:52,960
processing model than

2283
01:42:52,960 --> 01:42:56,679
actually adding protection

2284
01:43:09,199 --> 01:43:11,920
that key does i mean you know it's as if

2285
01:43:11,920 --> 01:43:13,360
each

2286
01:43:13,360 --> 01:43:14,960
val each each

2287
01:43:14,960 --> 01:43:17,280
member value had a sort of a pseudo

2288
01:43:17,280 --> 01:43:19,199
attribute a pseudo member of itself

2289
01:43:19,199 --> 01:43:20,719
called key that point back points back

2290
01:43:20,719 --> 01:43:22,880
to its parent right sort of like the dot

2291
01:43:22,880 --> 01:43:25,920
dot on

2292
01:43:27,199 --> 01:43:30,000
yep exactly

2293
01:43:30,000 --> 01:43:31,360
but again i think you know we should

2294
01:43:31,360 --> 01:43:32,639
probably

2295
01:43:32,639 --> 01:43:36,000
hunt for examples as to

2296
01:43:36,000 --> 01:43:37,920
uh specific cases where that's

2297
01:43:37,920 --> 01:43:39,679
absolutely neat because it is only a

2298
01:43:39,679 --> 01:43:43,199
problem at the root right

2299
01:43:44,159 --> 01:43:45,360
and maybe there aren't that many

2300
01:43:45,360 --> 01:43:49,119
scenarios where it's it's needed

2301
01:43:50,639 --> 01:43:52,560
well the lack of projection is a problem

2302
01:43:52,560 --> 01:43:54,400
everywhere

2303
01:43:54,400 --> 01:43:56,719
so i think i could make examples that

2304
01:43:56,719 --> 01:43:59,520
expose this problem at

2305
01:43:59,520 --> 01:44:02,719
other places in the route

2306
01:44:04,400 --> 01:44:05,520
but i think

2307
01:44:05,520 --> 01:44:07,920
trying to bring projection capabilities

2308
01:44:07,920 --> 01:44:09,600
in as well

2309
01:44:09,600 --> 01:44:12,960
is probably a much bigger issue

2310
01:44:12,960 --> 01:44:13,300
true

2311
01:44:13,300 --> 01:44:16,399
[Music]

2312
01:44:18,880 --> 01:44:22,080
so where are we coming in on i think um

2313
01:44:22,080 --> 01:44:23,679
i think we acknowledge

2314
01:44:23,679 --> 01:44:25,199
the issue the you know the issue is a

2315
01:44:25,199 --> 01:44:26,719
real issue

2316
01:44:26,719 --> 01:44:27,760
um

2317
01:44:27,760 --> 01:44:29,360
so first of all are we interested in

2318
01:44:29,360 --> 01:44:31,760
trying to solve it

2319
01:44:31,760 --> 01:44:34,760
um

2320
01:44:35,119 --> 01:44:36,000
and

2321
01:44:36,000 --> 01:44:38,239
i'm not hearing

2322
01:44:38,239 --> 01:44:39,600
a lot of

2323
01:44:39,600 --> 01:44:41,840
eagerness to try and solve this one

2324
01:44:41,840 --> 01:44:46,280
absent some more compelling use cases

2325
01:44:48,080 --> 01:44:51,840
it's a fact that this issue

2326
01:44:51,840 --> 01:44:53,440
did come not very

2327
01:44:53,440 --> 01:44:55,280
uh often

2328
01:44:55,280 --> 01:44:57,199
in the past so

2329
01:44:57,199 --> 01:45:03,040
it's not a very important issue i think

2330
01:45:03,040 --> 01:45:05,119
i

2331
01:45:05,119 --> 01:45:08,400
tried mentally to put this object in the

2332
01:45:08,400 --> 01:45:11,760
first comment one level deeper and even

2333
01:45:11,760 --> 01:45:14,800
then you cannot

2334
01:45:14,800 --> 01:45:17,440
you cannot exclude

2335
01:45:17,440 --> 01:45:18,239
the

2336
01:45:18,239 --> 01:45:21,119
d member

2337
01:45:21,119 --> 01:45:23,860
only in that case where you

2338
01:45:23,860 --> 01:45:27,040
[Music]

2339
01:45:27,280 --> 01:45:30,719
where you name explicitly the other

2340
01:45:30,719 --> 01:45:32,480
members but

2341
01:45:32,480 --> 01:45:34,719
this is

2342
01:45:34,719 --> 01:45:36,560
not practically

2343
01:45:36,560 --> 01:45:40,960
with big objects i think

2344
01:45:41,440 --> 01:45:44,440
so

2345
01:45:46,480 --> 01:45:49,199
it's okay i agree if we don't

2346
01:45:49,199 --> 01:45:50,239
care

2347
01:45:50,239 --> 01:45:53,759
much about this issue

2348
01:45:54,960 --> 01:45:56,719
so should we say provisionally that for

2349
01:45:56,719 --> 01:45:58,400
the moment we are going to acknowledge

2350
01:45:58,400 --> 01:45:59,199
but

2351
01:45:59,199 --> 01:46:00,400
not address

2352
01:46:00,400 --> 01:46:02,719
this issue and

2353
01:46:02,719 --> 01:46:04,880
encourage anybody who cares to

2354
01:46:04,880 --> 01:46:08,840
bring a convincing use case

2355
01:46:13,600 --> 01:46:15,760
yes

2356
01:46:15,760 --> 01:46:18,400
so i write

2357
01:46:18,400 --> 01:46:20,960
won't fix

2358
01:46:23,520 --> 01:46:24,639
yeah

2359
01:46:24,639 --> 01:46:26,880
i think even with a convincing use case

2360
01:46:26,880 --> 01:46:29,360
i wouldn't want to put it in necessarily

2361
01:46:29,360 --> 01:46:30,560
because i think it's probably out of

2362
01:46:30,560 --> 01:46:32,719
scope

2363
01:46:32,719 --> 01:46:34,320
it's a significant

2364
01:46:34,320 --> 01:46:37,199
extension of the processing model

2365
01:46:37,199 --> 01:46:39,040
yeah and i don't think we necessarily

2366
01:46:39,040 --> 01:46:42,719
want to address all use cases

2367
01:46:43,440 --> 01:46:45,199
okay

2368
01:46:45,199 --> 01:46:46,159
what

2369
01:46:46,159 --> 01:46:49,199
got some got any more

2370
01:46:50,239 --> 01:46:54,678
yeah we're on slide 14 of 37.

2371
01:46:55,679 --> 01:47:00,080
i think we just closed this

2372
01:47:00,080 --> 01:47:02,800
please look at the last pull request

2373
01:47:02,800 --> 01:47:04,560
that was merged but i don't think we

2374
01:47:04,560 --> 01:47:06,159
need to discuss this here i think we

2375
01:47:06,159 --> 01:47:06,960
have

2376
01:47:06,960 --> 01:47:09,679
consensus here

2377
01:47:09,679 --> 01:47:12,880
so this was about the

2378
01:47:12,880 --> 01:47:16,000
order of results

2379
01:47:16,000 --> 01:47:19,360
and we are saying this is pre-order but

2380
01:47:19,360 --> 01:47:21,520
acknowledging that objects are unordered

2381
01:47:21,520 --> 01:47:24,400
in json so there is non-determinism

2382
01:47:24,400 --> 01:47:26,639
and there are some better words in that

2383
01:47:26,639 --> 01:47:27,840
request

2384
01:47:27,840 --> 01:47:31,600
that should be explaining this

2385
01:47:33,840 --> 01:47:37,440
seems like the only sensible thing to do

2386
01:47:40,000 --> 01:47:43,119
this is pagination

2387
01:47:43,119 --> 01:47:44,480
which i think

2388
01:47:44,480 --> 01:47:47,199
is a good thing but maybe outside of

2389
01:47:47,199 --> 01:47:50,159
jsonpath

2390
01:47:50,159 --> 01:47:53,440
um so typically when

2391
01:47:53,440 --> 01:47:56,000
um i would write a query i would then

2392
01:47:56,000 --> 01:47:58,560
tell the api oh by the way only give me

2393
01:47:58,560 --> 01:48:01,679
the first 20 hits

2394
01:48:01,679 --> 01:48:03,760
that i would see that in the api but of

2395
01:48:03,760 --> 01:48:06,880
course there are cases conceivable where

2396
01:48:06,880 --> 01:48:09,360
you want to have pagination inside a

2397
01:48:09,360 --> 01:48:11,840
json path expression i'm just having a

2398
01:48:11,840 --> 01:48:16,360
hard time thinking of such cases

2399
01:48:18,960 --> 01:48:20,480
yeah i mean i mean the whole point is

2400
01:48:20,480 --> 01:48:22,000
that jsonpass should be declarative

2401
01:48:22,000 --> 01:48:25,199
right and it specifies what

2402
01:48:25,199 --> 01:48:29,360
what the output is not how you access it

2403
01:48:30,800 --> 01:48:33,520
well giving a number i want 20 of those

2404
01:48:33,520 --> 01:48:37,199
that's still rather declarative

2405
01:48:41,520 --> 01:48:43,360
so i'm not sure that is a good argument

2406
01:48:43,360 --> 01:48:44,320
but

2407
01:48:44,320 --> 01:48:46,159
i think a good argument is that this is

2408
01:48:46,159 --> 01:48:49,759
something that an api usually does

2409
01:48:51,280 --> 01:48:54,159
i i'm not sure i'm sold on the the

2410
01:48:54,159 --> 01:48:56,560
scenario of paging but i think the

2411
01:48:56,560 --> 01:48:58,840
scenario of just being able to

2412
01:48:58,840 --> 01:49:02,000
say select object but only give me back

2413
01:49:02,000 --> 01:49:03,520
five of them

2414
01:49:03,520 --> 01:49:05,520
i think might be

2415
01:49:05,520 --> 01:49:09,480
a valuable use case

2416
01:49:16,960 --> 01:49:18,400
because i may want to present those on

2417
01:49:18,400 --> 01:49:21,599
the ui i may be only interested in

2418
01:49:21,599 --> 01:49:22,880
getting some

2419
01:49:22,880 --> 01:49:24,639
sample set of data to play around with

2420
01:49:24,639 --> 01:49:26,639
there may be a thousand

2421
01:49:26,639 --> 01:49:29,199
objects in the target document but i

2422
01:49:29,199 --> 01:49:31,520
only want to i only need a few in order

2423
01:49:31,520 --> 01:49:33,760
to achieve my goal and rather than

2424
01:49:33,760 --> 01:49:35,280
returning the full results and then

2425
01:49:35,280 --> 01:49:37,440
throwing the rest away

2426
01:49:37,440 --> 01:49:40,880
if we can save effort where the

2427
01:49:40,880 --> 01:49:42,960
the selection mechanism only has to find

2428
01:49:42,960 --> 01:49:45,280
a few

2429
01:49:46,880 --> 01:49:49,679
i can see value there

2430
01:49:49,679 --> 01:49:53,040
can you not do that with our slice

2431
01:49:53,679 --> 01:49:54,480
i

2432
01:49:54,480 --> 01:49:56,320
very possibly once again showing my

2433
01:49:56,320 --> 01:49:59,280
ignorance on the spec

2434
01:50:03,360 --> 01:50:05,599
a slice only applies to raise doesn't it

2435
01:50:05,599 --> 01:50:10,040
we're talking here about a node list

2436
01:50:12,560 --> 01:50:15,800
that's true

2437
01:50:27,119 --> 01:50:30,800
i think we need to decide if we

2438
01:50:30,800 --> 01:50:31,679
uh

2439
01:50:31,679 --> 01:50:35,280
want to uh

2440
01:50:35,520 --> 01:50:36,560
allow

2441
01:50:36,560 --> 01:50:40,320
or support some kind of post processing

2442
01:50:40,320 --> 01:50:44,320
of the results of a query which i would

2443
01:50:44,320 --> 01:50:46,639
uh suggest that

2444
01:50:46,639 --> 01:50:49,840
this happens here or

2445
01:50:49,840 --> 01:50:50,639
to

2446
01:50:50,639 --> 01:50:53,040
extend the query

2447
01:50:53,040 --> 01:50:54,880
capabilities to

2448
01:50:54,880 --> 01:50:56,480
do exactly

2449
01:50:56,480 --> 01:50:58,159
that

2450
01:50:58,159 --> 01:51:00,320
so

2451
01:51:00,560 --> 01:51:03,199
return only the last five or the first

2452
01:51:03,199 --> 01:51:04,400
five or

2453
01:51:04,400 --> 01:51:06,880
something in somewhere in the middle

2454
01:51:06,880 --> 01:51:10,560
five elements of the

2455
01:51:10,560 --> 01:51:14,400
of the result note list

2456
01:51:15,119 --> 01:51:16,400
it's

2457
01:51:16,400 --> 01:51:19,799
hard to do

2458
01:51:20,719 --> 01:51:23,760
but it would return again a note list

2459
01:51:23,760 --> 01:51:26,000
which

2460
01:51:28,239 --> 01:51:29,920
subsequent queries

2461
01:51:29,920 --> 01:51:30,960
would be

2462
01:51:30,960 --> 01:51:33,679
both possible

2463
01:51:33,679 --> 01:51:36,480
theoretically

2464
01:51:43,199 --> 01:51:45,679
there currently isn't any ordering

2465
01:51:45,679 --> 01:51:48,960
capabilities in the results right

2466
01:51:48,960 --> 01:51:49,920
in

2467
01:51:49,920 --> 01:51:51,840
in the json expression so i don't know

2468
01:51:51,840 --> 01:51:54,480
whether saying first or last or middle

2469
01:51:54,480 --> 01:51:56,159
actually adds any value i think it's

2470
01:51:56,159 --> 01:51:57,520
purely just

2471
01:51:57,520 --> 01:51:58,800
a limit

2472
01:51:58,800 --> 01:52:00,639
capability that

2473
01:52:00,639 --> 01:52:03,840
is the useful thing

2474
01:52:06,719 --> 01:52:08,400
oh yeah i'm coming down on the side of

2475
01:52:08,400 --> 01:52:10,320
comparison here is this this feels like

2476
01:52:10,320 --> 01:52:13,840
an api problem not a

2477
01:52:15,040 --> 01:52:17,599
you know our title is expressions you

2478
01:52:17,599 --> 01:52:20,239
know expressions for for json and this

2479
01:52:20,239 --> 01:52:23,678
doesn't feel like part of the expression

2480
01:52:25,040 --> 01:52:28,360
seems fair

2481
01:52:30,159 --> 01:52:32,960
i agree with that

2482
01:52:35,119 --> 01:52:37,440
and we probably also can

2483
01:52:37,440 --> 01:52:39,599
come up with a way to take this

2484
01:52:39,599 --> 01:52:41,199
information on

2485
01:52:41,199 --> 01:52:43,679
to a json path if people find that

2486
01:52:43,679 --> 01:52:46,239
convenient

2487
01:52:47,440 --> 01:52:49,920
so we have in sql we have limit we have

2488
01:52:49,920 --> 01:52:52,960
offset we have order by which is

2489
01:52:52,960 --> 01:52:54,960
pretty important if you only want to

2490
01:52:54,960 --> 01:52:56,840
have a limited number of

2491
01:52:56,840 --> 01:53:00,719
results um so that would need to be part

2492
01:53:00,719 --> 01:53:03,599
of that extension

2493
01:53:06,320 --> 01:53:07,280
um

2494
01:53:07,280 --> 01:53:09,920
but then i'm cognizant of time because

2495
01:53:09,920 --> 01:53:14,080
we've got only about seven minutes left

2496
01:53:14,080 --> 01:53:15,119
um

2497
01:53:15,119 --> 01:53:17,599
and glenn you said you wanted to cover

2498
01:53:17,599 --> 01:53:20,880
uh regular expressions which is still

2499
01:53:20,880 --> 01:53:23,760
um a handful of slides

2500
01:53:23,760 --> 01:53:24,639
down

2501
01:53:24,639 --> 01:53:26,080
is that something we might want to cover

2502
01:53:26,080 --> 01:53:28,000
and then leave a couple more minutes to

2503
01:53:28,000 --> 01:53:31,119
wrap up and uh perhaps discuss when

2504
01:53:31,119 --> 01:53:33,840
we might have our next meeting if we are

2505
01:53:33,840 --> 01:53:36,800
uh having an interim sure

2506
01:53:36,800 --> 01:53:39,800
cool

2507
01:53:44,639 --> 01:53:45,840
so

2508
01:53:45,840 --> 01:53:48,960
you know looking at the slide here

2509
01:53:48,960 --> 01:53:50,560
um

2510
01:53:50,560 --> 01:53:51,360
is

2511
01:53:51,360 --> 01:53:53,520
the first option open to us is there a

2512
01:53:53,520 --> 01:53:55,840
regular expression flavor that we could

2513
01:53:55,840 --> 01:53:57,760
select

2514
01:53:57,760 --> 01:53:58,460
there are two

2515
01:53:58,460 --> 01:54:01,720
[Music]

2516
01:54:06,080 --> 01:54:09,360
i'm trying to swap in this discussion um

2517
01:54:09,360 --> 01:54:13,440
we didn't like xsd for some reason

2518
01:54:15,599 --> 01:54:18,560
well we didn't like one aspect of xsd so

2519
01:54:18,560 --> 01:54:21,360
we essentially if we do xsd this means

2520
01:54:21,360 --> 01:54:23,839
subsetting

2521
01:54:27,119 --> 01:54:29,760
character subtraction is a non-starter

2522
01:54:29,760 --> 01:54:33,560
in most implementations

2523
01:54:37,920 --> 01:54:40,320
i guess my concern is that um regular

2524
01:54:40,320 --> 01:54:43,199
expression syntax and semantics seems

2525
01:54:43,199 --> 01:54:45,440
like an orthogonal concern

2526
01:54:45,440 --> 01:54:47,280
uh to jsonpath

2527
01:54:47,280 --> 01:54:49,520
we ought to be able to mix and match

2528
01:54:49,520 --> 01:54:51,360
so um you know i

2529
01:54:51,360 --> 01:54:53,199
prefer to

2530
01:54:53,199 --> 01:54:55,280
not to have to

2531
01:54:55,280 --> 01:54:58,159
freeze or pick a particular regular

2532
01:54:58,159 --> 01:55:00,880
expression syntax in the

2533
01:55:00,880 --> 01:55:03,040
standard but to allow you to make some

2534
01:55:03,040 --> 01:55:05,040
matches so you could then have

2535
01:55:05,040 --> 01:55:08,960
json path over xsd or jsonpath over re2

2536
01:55:08,960 --> 01:55:11,440
or whatever regular expression

2537
01:55:11,440 --> 01:55:13,679
language you choose

2538
01:55:13,679 --> 01:55:15,440
it obviously the limit's interoperation

2539
01:55:15,440 --> 01:55:17,040
but i think it's it's more attractive

2540
01:55:17,040 --> 01:55:18,639
for standard

2541
01:55:18,639 --> 01:55:20,800
yeah but little yeah it's operational is

2542
01:55:20,800 --> 01:55:23,280
a big deal

2543
01:55:28,560 --> 01:55:30,000
i would hope that the

2544
01:55:30,000 --> 01:55:34,239
same uh the same json path

2545
01:55:34,239 --> 01:55:36,480
applied to the same argument

2546
01:55:36,480 --> 01:55:38,960
would produce the same result modulo

2547
01:55:38,960 --> 01:55:40,239
ordering

2548
01:55:40,239 --> 01:55:41,840
uh

2549
01:55:41,840 --> 01:55:44,480
consistently

2550
01:55:45,040 --> 01:55:47,119
yeah i mean what i had in mind was that

2551
01:55:47,119 --> 01:55:50,880
uh jason path over princess re2 would

2552
01:55:50,880 --> 01:55:52,880
interoperate perfectly with jason path

2553
01:55:52,880 --> 01:55:54,239
over re2

2554
01:55:54,239 --> 01:55:56,239
but not necessarily perfectly with jason

2555
01:55:56,239 --> 01:55:59,799
path over xsd

2556
01:56:03,760 --> 01:56:05,840
well first of all regular expressions

2557
01:56:05,840 --> 01:56:08,400
are a mathematical concept that that is

2558
01:56:08,400 --> 01:56:10,080
expressed in these

2559
01:56:10,080 --> 01:56:12,880
various forms of

2560
01:56:12,880 --> 01:56:15,440
real world regular expressions

2561
01:56:15,440 --> 01:56:16,320
and

2562
01:56:16,320 --> 01:56:18,880
some of them are going pretty far away

2563
01:56:18,880 --> 01:56:21,280
from the concept of regular expressions

2564
01:56:21,280 --> 01:56:23,360
like like pcie and

2565
01:56:23,360 --> 01:56:26,560
ecmascript that was built from pcie

2566
01:56:26,560 --> 01:56:29,119
and some are rather closer you can

2567
01:56:29,119 --> 01:56:30,960
actually

2568
01:56:30,960 --> 01:56:32,719
use the implementation of regular

2569
01:56:32,719 --> 01:56:35,840
language to to implement this

2570
01:56:35,840 --> 01:56:38,239
um so that that's for instance true for

2571
01:56:38,239 --> 01:56:39,599
the xsd

2572
01:56:39,599 --> 01:56:40,840
regular

2573
01:56:40,840 --> 01:56:42,480
expressions

2574
01:56:42,480 --> 01:56:45,679
so by by defining a subset that is

2575
01:56:45,679 --> 01:56:48,080
essentially within

2576
01:56:48,080 --> 01:56:52,320
the the field of chomsky type 3

2577
01:56:52,320 --> 01:56:54,320
languages the mathematical form of

2578
01:56:54,320 --> 01:56:56,480
regular expressions

2579
01:56:56,480 --> 01:56:58,480
so we could have something that can be

2580
01:56:58,480 --> 01:57:01,920
mapped to to just about any

2581
01:57:01,920 --> 01:57:03,920
flavor that is out there

2582
01:57:03,920 --> 01:57:05,840
but that's a piece of work that has to

2583
01:57:05,840 --> 01:57:08,000
be done i have started it in in this

2584
01:57:08,000 --> 01:57:11,360
irig x document but it probably needs a

2585
01:57:11,360 --> 01:57:13,760
couple of more iterations before it's

2586
01:57:13,760 --> 01:57:15,679
ready for consumption

2587
01:57:15,679 --> 01:57:17,599
and implementers you know aren't i

2588
01:57:17,599 --> 01:57:19,040
suspect in most cases going to be

2589
01:57:19,040 --> 01:57:20,480
thinking about

2590
01:57:20,480 --> 01:57:21,760
the chomsky type they're going to be

2591
01:57:21,760 --> 01:57:25,840
thinking about what library can i use

2592
01:57:25,920 --> 01:57:27,679
um because you know i don't think a json

2593
01:57:27,679 --> 01:57:29,199
path implementer should have to also

2594
01:57:29,199 --> 01:57:30,560
implement regular expressions they

2595
01:57:30,560 --> 01:57:31,360
should

2596
01:57:31,360 --> 01:57:33,119
be able to

2597
01:57:33,119 --> 01:57:36,320
say regex.match

2598
01:57:37,280 --> 01:57:39,280
yeah that was my concern really

2599
01:57:39,280 --> 01:57:41,119
if you have to build up a mapping to

2600
01:57:41,119 --> 01:57:42,960
your um

2601
01:57:42,960 --> 01:57:46,320
whatever your language uh library is for

2602
01:57:46,320 --> 01:57:48,719
regular expressions and do do a mapping

2603
01:57:48,719 --> 01:57:51,199
of iregxp or whatever then it's puts a

2604
01:57:51,199 --> 01:57:54,480
big burden on the implementer

2605
01:57:57,840 --> 01:57:59,760
i will say that most of the people i

2606
01:57:59,760 --> 01:58:01,280
interact with who are interested in

2607
01:58:01,280 --> 01:58:03,599
working with jason path are also

2608
01:58:03,599 --> 01:58:06,480
in parallel working with jason schema

2609
01:58:06,480 --> 01:58:07,440
um

2610
01:58:07,440 --> 01:58:09,280
and so they have

2611
01:58:09,280 --> 01:58:10,719
their they've

2612
01:58:10,719 --> 01:58:13,280
picked their particular flavor and there

2613
01:58:13,280 --> 01:58:15,199
would be value at least to that part of

2614
01:58:15,199 --> 01:58:17,040
the audience to

2615
01:58:17,040 --> 01:58:18,239
um

2616
01:58:18,239 --> 01:58:20,560
doing something very similar

2617
01:58:20,560 --> 01:58:22,639
what clever is that

2618
01:58:22,639 --> 01:58:23,920
it's a

2619
01:58:23,920 --> 01:58:27,040
they reference ecma 262 and then they

2620
01:58:27,040 --> 01:58:29,440
have a recommendation of sticking to a

2621
01:58:29,440 --> 01:58:31,960
subset

2622
01:58:31,960 --> 01:58:35,149
[Music]

2623
01:58:40,960 --> 01:58:42,960
so i regex

2624
01:58:42,960 --> 01:58:45,840
might be the way to go

2625
01:58:45,840 --> 01:58:47,119
for

2626
01:58:47,119 --> 01:58:49,440
the

2627
01:58:49,440 --> 01:58:54,919
json schema and for jsonpath also

2628
01:59:04,719 --> 01:59:05,840
well

2629
01:59:05,840 --> 01:59:07,840
so

2630
01:59:07,840 --> 01:59:10,639
there's the possibility of the

2631
01:59:10,639 --> 01:59:13,360
of looking at trying to adopt what jason

2632
01:59:13,360 --> 01:59:14,560
schema did

2633
01:59:14,560 --> 01:59:17,280
there's the possibility of subsetting

2634
01:59:17,280 --> 01:59:20,000
w3xsd

2635
01:59:20,000 --> 01:59:21,599
there's a possibility of writing our own

2636
01:59:21,599 --> 01:59:24,239
so we have

2637
01:59:24,560 --> 01:59:27,679
three options on the table

2638
01:59:28,320 --> 01:59:29,840
all the various things before us this is

2639
01:59:29,840 --> 01:59:31,679
the one that has the greatest potential

2640
01:59:31,679 --> 01:59:33,679
to delay the product of this working

2641
01:59:33,679 --> 01:59:36,000
group by years

2642
01:59:36,000 --> 01:59:39,040
yeah absolutely

2643
01:59:39,440 --> 01:59:41,040
perhaps we should take this little

2644
01:59:41,040 --> 01:59:44,639
discussion to the list

2645
01:59:44,639 --> 01:59:47,920
and present those three options

2646
01:59:48,880 --> 01:59:51,199
well could we also include my option

2647
01:59:51,199 --> 01:59:52,960
which was to

2648
01:59:52,960 --> 01:59:54,960
factor out the um

2649
01:59:54,960 --> 01:59:57,679
regular expression language

2650
01:59:57,679 --> 01:59:59,840
yep

2651
02:00:00,560 --> 02:00:02,239
and realistic there's five options the

2652
02:00:02,239 --> 02:00:04,960
other one is don't have them

2653
02:00:04,960 --> 02:00:05,920
yeah

2654
02:00:05,920 --> 02:00:06,880
yep

2655
02:00:06,880 --> 02:00:07,760
okay

2656
02:00:07,760 --> 02:00:09,280
shall we shall we leave as an action

2657
02:00:09,280 --> 02:00:11,280
point to take the list

2658
02:00:11,280 --> 02:00:12,719
yes please

2659
02:00:12,719 --> 02:00:14,960
okay

2660
02:00:16,239 --> 02:00:18,400
okay we are out of time and i have to go

2661
02:00:18,400 --> 02:00:20,800
do some things anything else we can

2662
02:00:20,800 --> 02:00:22,000
squeeze in

2663
02:00:22,000 --> 02:00:23,679
yes the one thing that we do need to

2664
02:00:23,679 --> 02:00:25,840
discuss is when our next meeting is

2665
02:00:25,840 --> 02:00:28,639
itf113

2666
02:00:28,639 --> 02:00:29,920
is

2667
02:00:29,920 --> 02:00:32,280
um happening in

2668
02:00:32,280 --> 02:00:35,599
mid-march as i understand it

2669
02:00:35,599 --> 02:00:37,440
and i also understand that it won't be

2670
02:00:37,440 --> 02:00:40,400
in bangkok this time but i'm not certain

2671
02:00:40,400 --> 02:00:41,679
of that

2672
02:00:41,679 --> 02:00:43,760
should we be scheduling an interim

2673
02:00:43,760 --> 02:00:46,719
meeting uh before then say in january or

2674
02:00:46,719 --> 02:00:49,760
february after new year

2675
02:00:49,760 --> 02:00:51,679
if we want to finish this we should have

2676
02:00:51,679 --> 02:00:55,360
one about once every month yeah

2677
02:00:55,360 --> 02:00:57,440
okay

2678
02:00:57,440 --> 02:01:00,400
um perhaps it's too early for

2679
02:01:00,400 --> 02:01:01,599
sorry go on

2680
02:01:01,599 --> 02:01:03,360
let's try for january

2681
02:01:03,360 --> 02:01:05,360
okay well okay i think we can put a

2682
02:01:05,360 --> 02:01:09,559
doodle pole to the mailing list

2683
02:01:11,599 --> 02:01:12,639
okay

2684
02:01:12,639 --> 02:01:14,000
okay okay thank you everybody this has

2685
02:01:14,000 --> 02:01:15,679
been super constructive

2686
02:01:15,679 --> 02:01:17,840
um and i think we've pushed this thing a

2687
02:01:17,840 --> 02:01:19,280
little further uphill

2688
02:01:19,280 --> 02:01:21,679
and i'm optimistic that we have a finish

2689
02:01:21,679 --> 02:01:23,520
line inside if we can

2690
02:01:23,520 --> 02:01:26,639
figure out what to do with reggae

2691
02:01:28,239 --> 02:01:30,320
yeah thanks guys it was great

2692
02:01:30,320 --> 02:01:32,080
okay thank you everybody i have to be

2693
02:01:32,080 --> 02:01:33,920
rude and run away right now bye thank

2694
02:01:33,920 --> 02:01:35,520
you thank you everybody

2695
02:01:35,520 --> 02:01:37,119
thank you

2696
02:01:37,119 --> 02:01:40,119
cheers

