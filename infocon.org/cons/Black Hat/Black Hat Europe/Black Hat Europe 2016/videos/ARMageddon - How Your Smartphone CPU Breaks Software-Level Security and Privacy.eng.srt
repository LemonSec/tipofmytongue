1
00:00:00,030 --> 00:00:02,190
hello and welcome to our talk Armageddon

2
00:00:02,190 --> 00:00:04,589
how your smartphone CPU breaks off the

3
00:00:04,589 --> 00:00:08,099
level security and privacy in the

4
00:00:08,099 --> 00:00:09,750
beginning I want to say that if you have

5
00:00:09,750 --> 00:00:11,849
a so safe software infrastructure

6
00:00:11,849 --> 00:00:14,610
meaning that your code has no back this

7
00:00:14,610 --> 00:00:16,260
does not mean that the execution will be

8
00:00:16,260 --> 00:00:18,539
safe because the hardware where the

9
00:00:18,539 --> 00:00:20,160
software runs on may leak information

10
00:00:20,160 --> 00:00:23,460
and today we want to focus on the CPU

11
00:00:23,460 --> 00:00:25,890
cache because maybe you've seen in the

12
00:00:25,890 --> 00:00:28,320
past that cache attacks can be used for

13
00:00:28,320 --> 00:00:30,900
covered communication and to attack rip

14
00:00:30,900 --> 00:00:33,210
two implementations however they have

15
00:00:33,210 --> 00:00:35,610
only been demonstrated on intellect 86

16
00:00:35,610 --> 00:00:39,180
or now and as mobile devices like

17
00:00:39,180 --> 00:00:41,250
smartphones and tablets have become the

18
00:00:41,250 --> 00:00:43,110
most important personal computing device

19
00:00:43,110 --> 00:00:45,629
in the past and despite the fact that

20
00:00:45,629 --> 00:00:47,190
people thought that those that X cannot

21
00:00:47,190 --> 00:00:50,100
be applied on mobile devices we wanted

22
00:00:50,100 --> 00:00:52,770
to investigate why they don't work on

23
00:00:52,770 --> 00:00:54,660
arm and if we can do something about

24
00:00:54,660 --> 00:00:57,960
that but before that I want to introduce

25
00:00:57,960 --> 00:01:00,870
myself my name is Moe it's lip I'm from

26
00:01:00,870 --> 00:01:03,210
cut University of Technology and I'm a

27
00:01:03,210 --> 00:01:05,099
master student and I've just finished my

28
00:01:05,099 --> 00:01:07,680
master thesis if you want you can reach

29
00:01:07,680 --> 00:01:09,540
me on Twitter writing an email or just

30
00:01:09,540 --> 00:01:13,680
come and talk to me later on and my name

31
00:01:13,680 --> 00:01:15,990
is Clemens in movies I finished my PhD

32
00:01:15,990 --> 00:01:18,390
last year and I'm now post doc at class

33
00:01:18,390 --> 00:01:21,259
University of Technology you can also

34
00:01:21,259 --> 00:01:24,090
reach me on Twitter or by email or even

35
00:01:24,090 --> 00:01:27,900
later the rest of the research team is

36
00:01:27,900 --> 00:01:29,790
composed of Daniel who's half age type

37
00:01:29,790 --> 00:01:30,210
sir

38
00:01:30,210 --> 00:01:32,490
and stefan monk out and we are all from

39
00:01:32,490 --> 00:01:35,360
class University of Technology and

40
00:01:35,360 --> 00:01:37,890
before we delve into the details we are

41
00:01:37,890 --> 00:01:47,220
going to show you a quick demo so on

42
00:01:47,220 --> 00:01:50,909
left you should see the screen of this

43
00:01:50,909 --> 00:01:56,430
galaxy s6 and we have just started up

44
00:01:56,430 --> 00:01:58,619
the messenger app and on the right side

45
00:01:58,619 --> 00:02:01,469
we have a terminal and we will start our

46
00:02:01,469 --> 00:02:05,610
spy tool and now Clementine will type

47
00:02:05,610 --> 00:02:09,360
something into the smartphone and as you

48
00:02:09,360 --> 00:02:11,008
can see on the right whenever she

49
00:02:11,008 --> 00:02:13,920
presses and character our spy tool

50
00:02:13,920 --> 00:02:16,740
catches that and also if she presses the

51
00:02:16,740 --> 00:02:20,520
spacebar we see that on the right and at

52
00:02:20,520 --> 00:02:22,380
some point if she may decide that she

53
00:02:22,380 --> 00:02:24,540
wants to delete the word or a character

54
00:02:24,540 --> 00:02:27,810
we can also spy on that so because of

55
00:02:27,810 --> 00:02:30,209
that we can derive the words at length

56
00:02:30,209 --> 00:02:33,390
of the word she types and spy on the

57
00:02:33,390 --> 00:02:36,989
user and we will now show you how this

58
00:02:36,989 --> 00:02:40,470
is done and as we said this is no

59
00:02:40,470 --> 00:02:43,590
software pack it's just because of the

60
00:02:43,590 --> 00:02:48,870
hardware so for the rest of our talk we

61
00:02:48,870 --> 00:02:49,769
first give you some background

62
00:02:49,769 --> 00:02:52,170
information about CPU caches and about

63
00:02:52,170 --> 00:02:54,510
the CPU architecture on intellect 86 as

64
00:02:54,510 --> 00:02:57,660
well as on arm then we will discuss the

65
00:02:57,660 --> 00:03:00,150
challenges why those attacks are so hard

66
00:03:00,150 --> 00:03:03,600
to can be mounted alarm and then we will

67
00:03:03,600 --> 00:03:05,040
show you how you can solve those

68
00:03:05,040 --> 00:03:07,980
challenges then we will demonstrate you

69
00:03:07,980 --> 00:03:09,900
some attack scenarios what you can do

70
00:03:09,900 --> 00:03:10,769
with those attacks

71
00:03:10,769 --> 00:03:13,739
besides the demo and in the end we will

72
00:03:13,739 --> 00:03:15,060
give you all the tools that we've

73
00:03:15,060 --> 00:03:17,930
developed to mount such attacks and

74
00:03:17,930 --> 00:03:19,859
Clementine is going to tell you now

75
00:03:19,859 --> 00:03:24,150
about cache attacks in general yeah so

76
00:03:24,150 --> 00:03:27,090
as you may know we have a memory

77
00:03:27,090 --> 00:03:29,459
hierarchy that is composed of CPU

78
00:03:29,459 --> 00:03:33,030
registers different levels of sip of the

79
00:03:33,030 --> 00:03:35,430
CPU cache the main memory which is the

80
00:03:35,430 --> 00:03:38,579
DRAM and the disks or storage and we

81
00:03:38,579 --> 00:03:41,010
have different timings depending on

82
00:03:41,010 --> 00:03:43,200
where data reside on and this is

83
00:03:43,200 --> 00:03:45,150
precisely what we are going to exploit

84
00:03:45,150 --> 00:03:46,950
in cache attacks and in particular the

85
00:03:46,950 --> 00:03:49,680
difference of timing between data in the

86
00:03:49,680 --> 00:03:52,260
cache and in the main memory so if data

87
00:03:52,260 --> 00:03:54,989
resides in the cache and the access is

88
00:03:54,989 --> 00:03:56,670
going to be fast we call that a cache

89
00:03:56,670 --> 00:03:59,400
hit and if data is not in the cache then

90
00:03:59,400 --> 00:04:00,840
we have to retrieve it from the main

91
00:04:00,840 --> 00:04:03,269
memory and it's slow and we call that a

92
00:04:03,269 --> 00:04:06,480
cache miss now you can clearly see that

93
00:04:06,480 --> 00:04:08,609
we have we can see the difference

94
00:04:08,609 --> 00:04:11,190
between cache hits here and cache misses

95
00:04:11,190 --> 00:04:13,290
here and this is basically what we

96
00:04:13,290 --> 00:04:15,090
always talk to do when we not a cache

97
00:04:15,090 --> 00:04:18,209
attack we time the cache hit and the

98
00:04:18,209 --> 00:04:20,910
cache misses and then we can have some

99
00:04:20,910 --> 00:04:22,890
threshold because we know that we will

100
00:04:22,890 --> 00:04:26,150
never have any cache miss below as 700

101
00:04:26,150 --> 00:04:29,030
CPU cycles and then just by measuring

102
00:04:29,030 --> 00:04:32,240
the time an access take we can say it's

103
00:04:32,240 --> 00:04:36,620
a cache hit or it's a cache miss so we

104
00:04:36,620 --> 00:04:38,570
also need for this cache attacks to know

105
00:04:38,570 --> 00:04:42,259
precisely how the CPU cache work for um

106
00:04:42,259 --> 00:04:44,660
and Inter CPU we have set associative

107
00:04:44,660 --> 00:04:48,500
caches so we have data that is loaded in

108
00:04:48,500 --> 00:04:50,600
a specific set and that depends on some

109
00:04:50,600 --> 00:04:53,060
bits of the address so this is a cache

110
00:04:53,060 --> 00:04:56,990
set here then we have several ways per

111
00:04:56,990 --> 00:05:01,460
set so this is one way here we have four

112
00:05:01,460 --> 00:05:04,610
ways and a cache line is loading in a

113
00:05:04,610 --> 00:05:06,080
specific way depending on the

114
00:05:06,080 --> 00:05:08,090
replacement policy of the CPU because

115
00:05:08,090 --> 00:05:10,580
usually when at the CPU loads a cache

116
00:05:10,580 --> 00:05:12,440
line into the cache it has to evict a

117
00:05:12,440 --> 00:05:14,930
previous line to make someone fog to

118
00:05:14,930 --> 00:05:17,510
make some room for the new cache line so

119
00:05:17,510 --> 00:05:19,970
the cache line is here for example and

120
00:05:19,970 --> 00:05:21,470
this is the smallest unit we are going

121
00:05:21,470 --> 00:05:26,000
to talk about so now on to cache attacks

122
00:05:26,000 --> 00:05:27,889
we have different types of Cascia text

123
00:05:27,889 --> 00:05:30,229
and the first one is called flush and we

124
00:05:30,229 --> 00:05:32,449
load and here what's really important is

125
00:05:32,449 --> 00:05:34,190
that we have some shared memory between

126
00:05:34,190 --> 00:05:37,070
the attacker and the victim so here that

127
00:05:37,070 --> 00:05:39,590
can be for example a shared library so

128
00:05:39,590 --> 00:05:41,840
the etiquette starts by mapping this

129
00:05:41,840 --> 00:05:44,810
shared library and data that is shared

130
00:05:44,810 --> 00:05:47,000
in the memory is going to be shared in

131
00:05:47,000 --> 00:05:49,580
the cache so if data if the cache Ram is

132
00:05:49,580 --> 00:05:51,409
in the cache it's in the cache for both

133
00:05:51,409 --> 00:05:54,560
the attacker and the victim so what the

134
00:05:54,560 --> 00:05:56,389
attacker now is going to do is the

135
00:05:56,389 --> 00:05:57,979
attacker is going to flush this shared

136
00:05:57,979 --> 00:06:00,169
cache line and so that it's neither in

137
00:06:00,169 --> 00:06:01,520
the cache for the attacker and the

138
00:06:01,520 --> 00:06:04,669
victim and then he's going to let the

139
00:06:04,669 --> 00:06:07,669
victim perform for example encryption

140
00:06:07,669 --> 00:06:10,490
that data come out to spy on and then

141
00:06:10,490 --> 00:06:13,400
the CPU will automatically reload some

142
00:06:13,400 --> 00:06:16,370
data now the attacker wants to know if

143
00:06:16,370 --> 00:06:18,380
this particular cache line was accessed

144
00:06:18,380 --> 00:06:20,780
by the victim so the attacker then we

145
00:06:20,780 --> 00:06:22,460
lost the data and measure the time it

146
00:06:22,460 --> 00:06:24,830
takes and by measuring the time it takes

147
00:06:24,830 --> 00:06:26,780
you can know if it's in the CPU cache

148
00:06:26,780 --> 00:06:29,030
which means that the victim did access

149
00:06:29,030 --> 00:06:31,220
this particular cache line and if it was

150
00:06:31,220 --> 00:06:33,349
not in the cache then the victim did not

151
00:06:33,349 --> 00:06:35,479
access so this attack is actually quite

152
00:06:35,479 --> 00:06:37,070
powerful because the attacker can know

153
00:06:37,070 --> 00:06:37,970
if

154
00:06:37,970 --> 00:06:40,280
the victim accessed one particular cache

155
00:06:40,280 --> 00:06:44,600
line which is usually around 64 bytes so

156
00:06:44,600 --> 00:06:46,850
this was the case in which we had some

157
00:06:46,850 --> 00:06:49,340
kind of shared memory if we don't have

158
00:06:49,340 --> 00:06:51,140
any kind of shall memory we can use Fram

159
00:06:51,140 --> 00:06:54,140
in probe so here the attacker is going

160
00:06:54,140 --> 00:06:57,890
to start by filling the cache and then

161
00:06:57,890 --> 00:07:00,020
again let's the victim perform for

162
00:07:00,020 --> 00:07:02,360
example encryption and again the victim

163
00:07:02,360 --> 00:07:04,220
is going and the CPU is going to

164
00:07:04,220 --> 00:07:06,350
automatically load data and this is

165
00:07:06,350 --> 00:07:08,390
going to evict some of the line of the

166
00:07:08,390 --> 00:07:10,820
attacker so here and the victim evicted

167
00:07:10,820 --> 00:07:13,430
1/9 of the attacker then another line

168
00:07:13,430 --> 00:07:16,250
and now the attacker wants to know if

169
00:07:16,250 --> 00:07:19,970
the victim access this particular cache

170
00:07:19,970 --> 00:07:21,980
set and the attacker won't know which

171
00:07:21,980 --> 00:07:23,540
particular cache line but you can know

172
00:07:23,540 --> 00:07:26,270
if add the attacker exceed the victim

173
00:07:26,270 --> 00:07:28,600
access this kashyap so is going to

174
00:07:28,600 --> 00:07:32,000
prototype previously put in the cache so

175
00:07:32,000 --> 00:07:33,920
here on the first time that's a fast

176
00:07:33,920 --> 00:07:35,360
access because they died still in the

177
00:07:35,360 --> 00:07:38,810
cache and on the second line is a slow

178
00:07:38,810 --> 00:07:43,669
axis because the victim has a evicted

179
00:07:43,669 --> 00:07:46,010
one cache line of the article so the

180
00:07:46,010 --> 00:07:47,960
attacker now knows that ok the victim

181
00:07:47,960 --> 00:07:49,669
access some cache line that reside in

182
00:07:49,669 --> 00:07:53,270
this precise cache set and now what it

183
00:07:53,270 --> 00:07:54,620
is going to tell you about the

184
00:07:54,620 --> 00:07:57,770
differences between Intel x86 and arm so

185
00:07:57,770 --> 00:07:59,570
the first thing we need we need to be

186
00:07:59,570 --> 00:08:01,970
capable and find a way to remove an

187
00:08:01,970 --> 00:08:03,440
address out of the cache to the main

188
00:08:03,440 --> 00:08:05,570
memory and for this we need to

189
00:08:05,570 --> 00:08:08,900
invalidate the cache line and we have to

190
00:08:08,900 --> 00:08:11,020
cache maintenance instructions available

191
00:08:11,020 --> 00:08:14,930
which do that for us and on intellect 86

192
00:08:14,930 --> 00:08:17,210
you may know the unprivileged CL flash

193
00:08:17,210 --> 00:08:19,370
instruction which you can use to perform

194
00:08:19,370 --> 00:08:22,520
this task on the other hand on army 7

195
00:08:22,520 --> 00:08:24,230
while we have such cache maintenance

196
00:08:24,230 --> 00:08:26,300
instructions we can't use them because

197
00:08:26,300 --> 00:08:28,130
they are privileged and they need a

198
00:08:28,130 --> 00:08:30,620
kernel module to be unlocked for users

199
00:08:30,620 --> 00:08:32,780
based and this is not the case normally

200
00:08:32,780 --> 00:08:35,990
in addition on arm v8 we have also

201
00:08:35,990 --> 00:08:38,120
privileged instructions but four of them

202
00:08:38,120 --> 00:08:41,710
can be unlocked to user space entirely

203
00:08:41,710 --> 00:08:45,080
and the first big challenge there is

204
00:08:45,080 --> 00:08:46,880
that we have no flash instruction

205
00:08:46,880 --> 00:08:49,490
available on arm that we can use without

206
00:08:49,490 --> 00:08:51,210
any privileges

207
00:08:51,210 --> 00:08:54,060
so the easiest thing which comes to mind

208
00:08:54,060 --> 00:08:55,770
is we just fill the whole cache with

209
00:08:55,770 --> 00:08:57,390
different data then we are going to

210
00:08:57,390 --> 00:08:59,250
evict our target address and we are fine

211
00:08:59,250 --> 00:09:02,970
however this is way too slow so we can't

212
00:09:02,970 --> 00:09:05,580
rely on that we can improve on that by

213
00:09:05,580 --> 00:09:08,850
just filling a specific hash set and as

214
00:09:08,850 --> 00:09:10,920
you can see in this illustration the

215
00:09:10,920 --> 00:09:12,839
green block is the address you want to

216
00:09:12,839 --> 00:09:15,630
evict and we just start accessing as

217
00:09:15,630 --> 00:09:17,520
many addresses which map to the same

218
00:09:17,520 --> 00:09:20,730
cache set as we have ways so at one

219
00:09:20,730 --> 00:09:22,860
point we're going to evicted our gate

220
00:09:22,860 --> 00:09:27,270
address sounds easy it is easy but it's

221
00:09:27,270 --> 00:09:29,100
only the ideal case if we have a least

222
00:09:29,100 --> 00:09:31,890
recently used replacement policy on the

223
00:09:31,890 --> 00:09:36,120
cache active but in real life we don't

224
00:09:36,120 --> 00:09:37,680
have that because we have absurd a

225
00:09:37,680 --> 00:09:40,980
random replacement policy and when we do

226
00:09:40,980 --> 00:09:43,709
the same thing again just add accessing

227
00:09:43,709 --> 00:09:45,959
addresses it may happen that we just

228
00:09:45,959 --> 00:09:47,580
evict the address we have just loaded

229
00:09:47,580 --> 00:09:50,670
into the cache so in the end our target

230
00:09:50,670 --> 00:09:53,010
address will still remain in the cache

231
00:09:53,010 --> 00:09:55,110
and so this approach is also highly

232
00:09:55,110 --> 00:09:58,260
inefficient so the second challenge is

233
00:09:58,260 --> 00:09:59,970
that we have to take care of the

234
00:09:59,970 --> 00:10:02,880
pseudo-random replacement policy to find

235
00:10:02,880 --> 00:10:04,920
a nice way to evict the address still

236
00:10:04,920 --> 00:10:08,970
out of the cache in a fast way the

237
00:10:08,970 --> 00:10:10,620
second thing that we need to mount such

238
00:10:10,620 --> 00:10:13,050
cache attacks is we need to be able to

239
00:10:13,050 --> 00:10:15,630
measure the time it needs to take to

240
00:10:15,630 --> 00:10:18,870
load the address and on intellect 86 we

241
00:10:18,870 --> 00:10:21,089
have the RDS see instruction which is

242
00:10:21,089 --> 00:10:24,510
also unprivileged while we can access

243
00:10:24,510 --> 00:10:26,550
the cycle count on arm as well we can

244
00:10:26,550 --> 00:10:30,600
only do that in privileged mode so this

245
00:10:30,600 --> 00:10:34,560
is not easily done in a non rooted

246
00:10:34,560 --> 00:10:37,380
device and all the previous attacks that

247
00:10:37,380 --> 00:10:39,240
have been published require root access

248
00:10:39,240 --> 00:10:41,070
on the device so they are not very

249
00:10:41,070 --> 00:10:41,880
practical

250
00:10:41,880 --> 00:10:44,579
so the third challenge that we have is

251
00:10:44,579 --> 00:10:46,440
that we need to find unprivileged timing

252
00:10:46,440 --> 00:10:49,529
sources which are as accurate as we can

253
00:10:49,529 --> 00:10:52,800
as we need to distinguish between a

254
00:10:52,800 --> 00:10:58,230
cache it and the cache miss so beside

255
00:10:58,230 --> 00:11:00,000
cache maintenance and timing we also

256
00:11:00,000 --> 00:11:01,860
have the cache hierarchy that is quite

257
00:11:01,860 --> 00:11:04,370
different on our main on Intel CPUs

258
00:11:04,370 --> 00:11:06,950
so this is for Intel CPUs at the modern

259
00:11:06,950 --> 00:11:09,589
Intel CPUs so we have usually three

260
00:11:09,589 --> 00:11:12,140
levels of caches 11 1 and level 2 I

261
00:11:12,140 --> 00:11:14,630
private to each car and we have the last

262
00:11:14,630 --> 00:11:17,150
level cache that is level 3 and this one

263
00:11:17,150 --> 00:11:20,570
and it's also inclusive which means that

264
00:11:20,570 --> 00:11:22,760
everything that is on level 1 and level

265
00:11:22,760 --> 00:11:25,760
2 will also be in this last level cache

266
00:11:25,760 --> 00:11:29,089
and in that also means that a shell

267
00:11:29,089 --> 00:11:31,700
memory that is shared in Shannon with is

268
00:11:31,700 --> 00:11:33,860
shared in the cache across all cost

269
00:11:33,860 --> 00:11:36,589
so we have no restriction on where and

270
00:11:36,589 --> 00:11:40,400
the Spy is with respect to the victim so

271
00:11:40,400 --> 00:11:42,320
the victim might pin cos 0 and the

272
00:11:42,320 --> 00:11:44,570
attacker can be on post ring it will not

273
00:11:44,570 --> 00:11:46,910
be a problem thanks to this inclusive

274
00:11:46,910 --> 00:11:50,570
property now on ARM Cortex

275
00:11:50,570 --> 00:11:54,080
a cpu we have two levels of caches now

276
00:11:54,080 --> 00:11:56,350
level 1 is still private and level 2 is

277
00:11:56,350 --> 00:11:59,839
shared but this time it is not inclusive

278
00:11:59,839 --> 00:12:02,390
and that means that shared memory that

279
00:12:02,390 --> 00:12:04,730
is not in level 2 is not shared in the

280
00:12:04,730 --> 00:12:07,730
cache and that people thought that it

281
00:12:07,730 --> 00:12:09,950
was basically the biggest obstacle to

282
00:12:09,950 --> 00:12:11,980
performing cross core

283
00:12:11,980 --> 00:12:16,100
cache attacks on arm so that's our first

284
00:12:16,100 --> 00:12:19,970
channel we have non included caches then

285
00:12:19,970 --> 00:12:22,279
we have the cache hierarchy on arm pick

286
00:12:22,279 --> 00:12:24,770
little and here we have not only one

287
00:12:24,770 --> 00:12:28,910
CPUs but two multiple CPUs and the input

288
00:12:28,910 --> 00:12:31,760
interconnected by this calling and we

289
00:12:31,760 --> 00:12:34,339
have the level 2 cache that is shared

290
00:12:34,339 --> 00:12:38,330
across core but only of one CPUs so we

291
00:12:38,330 --> 00:12:40,820
have CPUs that do not share a cache and

292
00:12:40,820 --> 00:12:42,800
once again we would like to have no

293
00:12:42,800 --> 00:12:44,720
restriction on where the attacker is

294
00:12:44,720 --> 00:12:48,140
with respect to the victim and this is

295
00:12:48,140 --> 00:12:50,990
our first challenge we have no shared

296
00:12:50,990 --> 00:12:57,350
cache between these CPUs so let's solve

297
00:12:57,350 --> 00:12:59,540
these challenges we have those five

298
00:12:59,540 --> 00:13:01,600
challenges so now flush instruction

299
00:13:01,600 --> 00:13:04,520
obscure random replacement policy no

300
00:13:04,520 --> 00:13:06,920
unprivileged timing non-inclusive caches

301
00:13:06,920 --> 00:13:09,560
and no shell cash so I'll start with the

302
00:13:09,560 --> 00:13:12,440
first one no flash instruction so the

303
00:13:12,440 --> 00:13:13,880
idea is quite simple we are going to

304
00:13:13,880 --> 00:13:15,410
replace this missing flash instruction

305
00:13:15,410 --> 00:13:17,730
with cash eviction

306
00:13:17,730 --> 00:13:20,389
that actually works well on a intel x86

307
00:13:20,389 --> 00:13:22,529
because we have brahmin probe that i

308
00:13:22,529 --> 00:13:23,730
showed you at the beginning this one

309
00:13:23,730 --> 00:13:26,220
does not need any flash instruction and

310
00:13:26,220 --> 00:13:29,130
if we have some kind of shell memory but

311
00:13:29,130 --> 00:13:31,560
no flash instruction we can perform a

312
00:13:31,560 --> 00:13:33,990
variant of flash envelope that is called

313
00:13:33,990 --> 00:13:37,670
Ava can reload so challenge one done or

314
00:13:37,670 --> 00:13:41,970
is it well actually no it's not done yet

315
00:13:41,970 --> 00:13:44,279
because addiction can be slow and

316
00:13:44,279 --> 00:13:46,800
unreliable unless you know how to

317
00:13:46,800 --> 00:13:49,709
properly Big Data and this is kind of

318
00:13:49,709 --> 00:13:51,360
our thing in the group we're really good

319
00:13:51,360 --> 00:13:52,949
at editing data from the cache and that

320
00:13:52,949 --> 00:13:56,070
was in fact the central idea of all row

321
00:13:56,070 --> 00:13:58,620
homogeneous paper so if you recall

322
00:13:58,620 --> 00:14:01,410
rahama you access the theorem in some

323
00:14:01,410 --> 00:14:03,389
kind of patterns and then you're going

324
00:14:03,389 --> 00:14:06,000
to have a bit flip in one location that

325
00:14:06,000 --> 00:14:09,510
you never accessed so you need to reach

326
00:14:09,510 --> 00:14:11,760
the theorem and bypass the cache to do

327
00:14:11,760 --> 00:14:14,040
that and we also did that on JavaScript

328
00:14:14,040 --> 00:14:15,720
where you do not have any flash

329
00:14:15,720 --> 00:14:17,910
instructions so we're going to use the

330
00:14:17,910 --> 00:14:19,470
same kind of techniques that we did for

331
00:14:19,470 --> 00:14:23,370
this one which leads me to my to the

332
00:14:23,370 --> 00:14:25,560
second challenge this pseudo random

333
00:14:25,560 --> 00:14:28,230
replacement policy because evicting the

334
00:14:28,230 --> 00:14:30,060
cache would be really easy if it was not

335
00:14:30,060 --> 00:14:32,250
for this one because the cache on to be

336
00:14:32,250 --> 00:14:36,000
discarded is chosen to the randomly so

337
00:14:36,000 --> 00:14:40,110
what we did on kind of all Intel CPUs

338
00:14:40,110 --> 00:14:44,010
was accessing only ones and addresses in

339
00:14:44,010 --> 00:14:47,040
an N way cache sets such as mobis showed

340
00:14:47,040 --> 00:14:49,290
you earlier but because of the pillar

341
00:14:49,290 --> 00:14:51,510
random replacement policy this is really

342
00:14:51,510 --> 00:14:54,089
slow and unreliable so what we are going

343
00:14:54,089 --> 00:14:55,949
to do is we are going to access

344
00:14:55,949 --> 00:14:57,930
addresses that fills in to the same

345
00:14:57,930 --> 00:14:59,910
cache set not only once but several

346
00:14:59,910 --> 00:15:02,579
times and with different access patterns

347
00:15:02,579 --> 00:15:05,850
and the replacement policy is supposed

348
00:15:05,850 --> 00:15:07,709
to be pseudo-random so we should not be

349
00:15:07,709 --> 00:15:09,750
able to really influence anything but as

350
00:15:09,750 --> 00:15:11,910
we're going to see it actually works

351
00:15:11,910 --> 00:15:15,360
really well so this is the kind of

352
00:15:15,360 --> 00:15:17,220
numbers that we can have with the

353
00:15:17,220 --> 00:15:20,310
Alcatel OneTouch pop too so if we access

354
00:15:20,310 --> 00:15:22,589
48 addresses that fit into the same

355
00:15:22,589 --> 00:15:26,430
cache set we access them one by one it

356
00:15:26,430 --> 00:15:28,680
takes six thousand cycles which is quite

357
00:15:28,680 --> 00:15:30,970
fast but the eviction rate is really bad

358
00:15:30,970 --> 00:15:37,319
the eviction rate is basically how the

359
00:15:37,319 --> 00:15:44,050
sorry if the line that we wanted to

360
00:15:44,050 --> 00:15:45,939
evict has actually been evicted so here

361
00:15:45,939 --> 00:15:48,370
it's actually been evicted in 70% of the

362
00:15:48,370 --> 00:15:52,029
cases which is really bad we want

363
00:15:52,029 --> 00:15:53,800
something better than that so if we

364
00:15:53,800 --> 00:15:55,810
access more addresses then the eviction

365
00:15:55,810 --> 00:15:59,319
rate goes up we have 96 percent eviction

366
00:15:59,319 --> 00:16:02,879
rates and it now is quite slow we have

367
00:16:02,879 --> 00:16:05,980
33,000 cycles so we can access even more

368
00:16:05,980 --> 00:16:09,129
addresses let's say 800 ad eviction rate

369
00:16:09,129 --> 00:16:12,279
is no good 99 point 10 percents but it's

370
00:16:12,279 --> 00:16:16,029
really really way too slow 1 142,000

371
00:16:16,029 --> 00:16:18,459
cycles so we are going to access these

372
00:16:18,459 --> 00:16:21,699
addresses multiple times and now is only

373
00:16:21,699 --> 00:16:26,439
21 addresses that we access 96 times we

374
00:16:26,439 --> 00:16:28,089
have an eviction rate of ninety nine

375
00:16:28,089 --> 00:16:30,490
point ninety three percent and it only

376
00:16:30,490 --> 00:16:33,339
takes four thousand cycles we can even

377
00:16:33,339 --> 00:16:35,559
do a little bit better with 22 addresses

378
00:16:35,559 --> 00:16:39,129
even a bit more accesses with an

379
00:16:39,129 --> 00:16:42,370
eviction rate of 99.99 percent I takes

380
00:16:42,370 --> 00:16:44,769
five thousand cycles and with twenty

381
00:16:44,769 --> 00:16:46,240
three addresses then we have an

382
00:16:46,240 --> 00:16:47,920
addiction rate that is perfect we

383
00:16:47,920 --> 00:16:50,920
measure on 100% and it took six thousand

384
00:16:50,920 --> 00:16:53,259
cycles so this is really good and even

385
00:16:53,259 --> 00:16:54,550
the timing is better than the first one

386
00:16:54,550 --> 00:16:58,089
we had a very bad eviction rate so now

387
00:16:58,089 --> 00:16:59,350
I'm pretty sure that it sounded all

388
00:16:59,350 --> 00:17:01,389
voodoo we have different addresses we

389
00:17:01,389 --> 00:17:04,209
access them multiple times this is the

390
00:17:04,209 --> 00:17:05,559
kind of thing that we started to do

391
00:17:05,559 --> 00:17:08,709
manually with roham areas but it's

392
00:17:08,709 --> 00:17:10,329
really a pain to do so we fully

393
00:17:10,329 --> 00:17:13,390
automated this process the idea is that

394
00:17:13,390 --> 00:17:14,679
we are going to generate a lot of

395
00:17:14,679 --> 00:17:17,919
eviction strategies executive on the

396
00:17:17,919 --> 00:17:20,380
target device and then we have a lot of

397
00:17:20,380 --> 00:17:22,270
log files and we are going to build a

398
00:17:22,270 --> 00:17:24,579
database to be able to compare this

399
00:17:24,579 --> 00:17:27,429
eviction strategies so as the eviction

400
00:17:27,429 --> 00:17:29,559
strategies usually depend on the device

401
00:17:29,559 --> 00:17:31,809
because the cash characteristic are

402
00:17:31,809 --> 00:17:33,220
going to change from one device to the

403
00:17:33,220 --> 00:17:36,070
other we can find with these methods a

404
00:17:36,070 --> 00:17:38,409
fast an addiction efficient eviction

405
00:17:38,409 --> 00:17:42,010
strategies for any device and this is

406
00:17:42,010 --> 00:17:43,630
the kind of thing that we can now obtain

407
00:17:43,630 --> 00:17:44,740
with this eviction

408
00:17:44,740 --> 00:17:47,050
strategy so if you have some kind of

409
00:17:47,050 --> 00:17:48,910
shell memory but no flush instruction

410
00:17:48,910 --> 00:17:51,460
you can use evict and reload with these

411
00:17:51,460 --> 00:17:53,470
eviction strategies and as you can see

412
00:17:53,470 --> 00:17:56,380
we can really distinguish between the

413
00:17:56,380 --> 00:17:58,929
victim access and no victim access so we

414
00:17:58,929 --> 00:18:00,490
can have a threshold then this is with

415
00:18:00,490 --> 00:18:04,390
the kind of traffic you want to have now

416
00:18:04,390 --> 00:18:06,010
for priming probe if you do not have any

417
00:18:06,010 --> 00:18:08,980
kind of shell memory you have a bit more

418
00:18:08,980 --> 00:18:10,990
noise but you can still see this peak

419
00:18:10,990 --> 00:18:14,290
and if you put a threshold just after

420
00:18:14,290 --> 00:18:15,910
this peak you can say that roughly

421
00:18:15,910 --> 00:18:17,830
everything that is below this is no

422
00:18:17,830 --> 00:18:19,809
victim access everything that is after

423
00:18:19,809 --> 00:18:22,240
this is victim access so it looks a bit

424
00:18:22,240 --> 00:18:24,190
more noisy but as you will see later we

425
00:18:24,190 --> 00:18:26,440
can still mount a very powerful cache

426
00:18:26,440 --> 00:18:30,850
attack with that so the next challenge

427
00:18:30,850 --> 00:18:32,740
that we need to solve is that we don't

428
00:18:32,740 --> 00:18:35,140
have an unprivileged timing sauce and as

429
00:18:35,140 --> 00:18:36,610
I told you that the Foreman's counter

430
00:18:36,610 --> 00:18:38,410
can only be accessed in privileged mode

431
00:18:38,410 --> 00:18:40,270
so we need to find something different

432
00:18:40,270 --> 00:18:42,370
that we can use to distinguish between a

433
00:18:42,370 --> 00:18:44,770
cache hit in the cache miss and the

434
00:18:44,770 --> 00:18:46,570
first thing that we found is you can use

435
00:18:46,570 --> 00:18:48,820
the graphic interface with the probe

436
00:18:48,820 --> 00:18:50,800
event open Cisco which is unprivileged

437
00:18:50,800 --> 00:18:53,530
and we can also access the cycle counter

438
00:18:53,530 --> 00:18:54,820
through that

439
00:18:54,820 --> 00:18:57,220
however on new devices it's not

440
00:18:57,220 --> 00:18:59,200
available anymore on the one hand we

441
00:18:59,200 --> 00:19:01,720
just can't access the cipher counter or

442
00:19:01,720 --> 00:19:03,880
the kernel isn't built with this module

443
00:19:03,880 --> 00:19:08,080
so it doesn't work however we can also

444
00:19:08,080 --> 00:19:10,929
use the basic function clock at time we

445
00:19:10,929 --> 00:19:13,660
can pass the timer as an argument and we

446
00:19:13,660 --> 00:19:16,630
will have a nanosecond resolution if

447
00:19:16,630 --> 00:19:19,870
this wouldn't be available we can have a

448
00:19:19,870 --> 00:19:21,730
very simple approach by just

449
00:19:21,730 --> 00:19:23,980
implementing a thread counter which is a

450
00:19:23,980 --> 00:19:26,530
thread running on a different core just

451
00:19:26,530 --> 00:19:28,720
incrementing a global variable and this

452
00:19:28,720 --> 00:19:31,809
is enough for distinguishing cache hits

453
00:19:31,809 --> 00:19:34,120
and cache misses so we have now free

454
00:19:34,120 --> 00:19:35,980
unprivileged timing sources that we can

455
00:19:35,980 --> 00:19:38,410
use and they all give us a nanosecond

456
00:19:38,410 --> 00:19:40,960
resolution and this is enough to

457
00:19:40,960 --> 00:19:43,780
distinguish hits from misses as we can

458
00:19:43,780 --> 00:19:47,050
see on this plot so on the Left we have

459
00:19:47,050 --> 00:19:49,840
all the timing sources measuring a cache

460
00:19:49,840 --> 00:19:52,360
hit and then we have a huge gap and on

461
00:19:52,360 --> 00:19:54,640
the right we have the same only for the

462
00:19:54,640 --> 00:19:56,770
cache misses and it's easy to find the

463
00:19:56,770 --> 00:19:58,050
threshold in between

464
00:19:58,050 --> 00:20:00,180
we can use for our measurements in the

465
00:20:00,180 --> 00:20:04,050
end so the next thing that we have to

466
00:20:04,050 --> 00:20:05,610
take care of and this is probably one of

467
00:20:05,610 --> 00:20:07,530
the hardest challenges is that we have

468
00:20:07,530 --> 00:20:11,070
non-inclusive caches because for in this

469
00:20:11,070 --> 00:20:13,680
scenario the victim process is running

470
00:20:13,680 --> 00:20:16,710
on core zero and an address is loaded in

471
00:20:16,710 --> 00:20:18,480
its first level instruction cache and

472
00:20:18,480 --> 00:20:21,270
our attacking process is running on core

473
00:20:21,270 --> 00:20:24,000
one and this cache is for instance

474
00:20:24,000 --> 00:20:25,890
instruction inclusive and data

475
00:20:25,890 --> 00:20:28,350
non-inclusive and this means that the

476
00:20:28,350 --> 00:20:30,990
data from the instruction cache here has

477
00:20:30,990 --> 00:20:33,360
also be to be in the last level cache

478
00:20:33,360 --> 00:20:36,600
and what we can do now to evict the data

479
00:20:36,600 --> 00:20:38,520
from the first level cache of the other

480
00:20:38,520 --> 00:20:40,590
core which is private to the other cores

481
00:20:40,590 --> 00:20:44,250
by just filling our own local data cache

482
00:20:44,250 --> 00:20:47,310
and starting populating the last level

483
00:20:47,310 --> 00:20:50,370
cache and at some point we are going to

484
00:20:50,370 --> 00:20:52,350
evict the address out of the last level

485
00:20:52,350 --> 00:20:55,260
cache and because it's inclusive it will

486
00:20:55,260 --> 00:20:57,420
also get evicted from the first level

487
00:20:57,420 --> 00:20:59,970
cache and now we were able to evict an

488
00:20:59,970 --> 00:21:02,610
address from another core even if we

489
00:21:02,610 --> 00:21:06,270
don't have inclusive caches entirely so

490
00:21:06,270 --> 00:21:08,460
the second thing we need to do we need

491
00:21:08,460 --> 00:21:10,560
to find a way to measure if the other

492
00:21:10,560 --> 00:21:14,220
core has reloaded the address and the

493
00:21:14,220 --> 00:21:15,750
solution is that there are cache

494
00:21:15,750 --> 00:21:18,060
coherency protocols in place on the CPU

495
00:21:18,060 --> 00:21:20,970
which run all the time and they allow us

496
00:21:20,970 --> 00:21:23,700
to fetch data from a remote core and the

497
00:21:23,700 --> 00:21:25,710
reason behind this is that loading the

498
00:21:25,710 --> 00:21:27,960
data from another core is still faster

499
00:21:27,960 --> 00:21:29,700
if we need to have a memory access and

500
00:21:29,700 --> 00:21:32,670
as you can see on the plot while it

501
00:21:32,670 --> 00:21:35,790
takes roughly 100 hundred cycles more to

502
00:21:35,790 --> 00:21:38,310
load the address from another core it's

503
00:21:38,310 --> 00:21:40,170
still much faster than if it would have

504
00:21:40,170 --> 00:21:42,060
to make a memory access to the main

505
00:21:42,060 --> 00:21:45,360
memory and we can exploit this to

506
00:21:45,360 --> 00:21:47,040
measure if the address has been loaded

507
00:21:47,040 --> 00:21:49,320
by the other core so we can run

508
00:21:49,320 --> 00:21:53,160
cross-court decks as well the last thing

509
00:21:53,160 --> 00:21:55,350
we need to fix is that we have no shared

510
00:21:55,350 --> 00:21:59,010
cache on modern phones with which have

511
00:21:59,010 --> 00:22:01,740
multiple CPUs so that there is no shared

512
00:22:01,740 --> 00:22:04,740
cache between them and the answer is

513
00:22:04,740 --> 00:22:06,990
again cache coherency protocols because

514
00:22:06,990 --> 00:22:09,150
they allow us to fetch data not only

515
00:22:09,150 --> 00:22:10,860
from the remote core but

516
00:22:10,860 --> 00:22:13,320
from the remote CPU and this is also

517
00:22:13,320 --> 00:22:15,059
faster than if we would have to access

518
00:22:15,059 --> 00:22:18,390
the T RAM and why we see here that it's

519
00:22:18,390 --> 00:22:21,270
much slower than a local access it's

520
00:22:21,270 --> 00:22:24,510
still roughly 100 cycles faster than if

521
00:22:24,510 --> 00:22:26,640
we have to make an access to the DRAM

522
00:22:26,640 --> 00:22:30,620
and regarding that for performance

523
00:22:30,620 --> 00:22:33,929
things we need to we can exploit the

524
00:22:33,929 --> 00:22:35,429
cache coherency protocols which are

525
00:22:35,429 --> 00:22:38,840
running all the time and now we have

526
00:22:38,840 --> 00:22:41,100
found a solution for all those

527
00:22:41,100 --> 00:22:43,559
challenges and we want to present you

528
00:22:43,559 --> 00:22:46,020
some attack scenarios beside the demo

529
00:22:46,020 --> 00:22:47,450
that we've showed you in the beginning

530
00:22:47,450 --> 00:22:50,610
so the first thing you can do is you can

531
00:22:50,610 --> 00:22:53,070
build covered communication so for

532
00:22:53,070 --> 00:22:55,230
instance a user installs a malicious

533
00:22:55,230 --> 00:22:57,780
gallery application and he is not

534
00:22:57,780 --> 00:22:59,880
suspicious when he installs this app

535
00:22:59,880 --> 00:23:02,070
because the only permission it needs is

536
00:23:02,070 --> 00:23:04,559
to access the images so it doesn't need

537
00:23:04,559 --> 00:23:06,990
an internet access or read the contact

538
00:23:06,990 --> 00:23:09,990
data of the user in addition the user

539
00:23:09,990 --> 00:23:12,150
wants to see what the weather is outside

540
00:23:12,150 --> 00:23:13,890
and installs the malicious weather

541
00:23:13,890 --> 00:23:16,320
widget and he's also not suspicious

542
00:23:16,320 --> 00:23:18,150
because the only permission it requires

543
00:23:18,150 --> 00:23:21,049
is to have access to the Internet so

544
00:23:21,049 --> 00:23:24,750
what if both apps can build a cover

545
00:23:24,750 --> 00:23:26,580
channel to communicate with each other

546
00:23:26,580 --> 00:23:29,340
so that the gallery app can send the

547
00:23:29,340 --> 00:23:31,679
image to the weather app which uploads

548
00:23:31,679 --> 00:23:35,400
it to the Internet and so if two

549
00:23:35,400 --> 00:23:37,260
applications want to communicate with

550
00:23:37,260 --> 00:23:39,270
each other but they are not allowed to

551
00:23:39,270 --> 00:23:41,160
do so because they either don't have the

552
00:23:41,160 --> 00:23:43,530
permissions or there's just no mechanism

553
00:23:43,530 --> 00:23:46,230
they can use like shared memory they can

554
00:23:46,230 --> 00:23:48,960
use a cabbage channel and a cabbage

555
00:23:48,960 --> 00:23:51,179
channel enables to unprivileged

556
00:23:51,179 --> 00:23:53,220
applications to communicate with each

557
00:23:53,220 --> 00:23:56,429
other but it does not use any data

558
00:23:56,429 --> 00:23:58,200
transfer mechanism that is provided by

559
00:23:58,200 --> 00:24:01,559
the operating system and this evades the

560
00:24:01,559 --> 00:24:03,780
sandboxing concept and also the

561
00:24:03,780 --> 00:24:06,780
permission system and because you have

562
00:24:06,780 --> 00:24:08,940
two apps which need to work together

563
00:24:08,940 --> 00:24:11,660
this is called a collusion attack and

564
00:24:11,660 --> 00:24:14,549
what we did was we built a cover channel

565
00:24:14,549 --> 00:24:17,520
using the cache so we used addresses

566
00:24:17,520 --> 00:24:19,410
from shared memory from a shared library

567
00:24:19,410 --> 00:24:23,559
on executable and we transmitted bits

568
00:24:23,559 --> 00:24:26,710
through cash hits and cache misses so as

569
00:24:26,710 --> 00:24:28,749
an example if you want to transmit to

570
00:24:28,749 --> 00:24:31,509
zero you just to send the doesn't access

571
00:24:31,509 --> 00:24:33,909
the address and so the receiver would

572
00:24:33,909 --> 00:24:36,220
measure a cache miss if you want to

573
00:24:36,220 --> 00:24:38,889
transmit one the sender would access the

574
00:24:38,889 --> 00:24:40,720
address and the receiver will measure a

575
00:24:40,720 --> 00:24:43,929
cache hit and using those building

576
00:24:43,929 --> 00:24:46,299
blocks we can build the protocol based

577
00:24:46,299 --> 00:24:49,330
on packets so we use the sequence number

578
00:24:49,330 --> 00:24:51,789
and also a checksum to protect our

579
00:24:51,789 --> 00:24:53,590
payload so that we can check the

580
00:24:53,590 --> 00:24:55,990
integrity of the data and can recent

581
00:24:55,990 --> 00:24:58,899
data if we require to on the other hand

582
00:24:58,899 --> 00:25:01,240
the receiver responds with the sequence

583
00:25:01,240 --> 00:25:05,409
number he has already received and our

584
00:25:05,409 --> 00:25:07,419
cover channel works using flash and

585
00:25:07,419 --> 00:25:09,879
reload techniques evict and reload and

586
00:25:09,879 --> 00:25:11,769
also flash and flash which we haven't

587
00:25:11,769 --> 00:25:13,779
discussed but basically the flash

588
00:25:13,779 --> 00:25:15,669
instruction also leaks timing

589
00:25:15,669 --> 00:25:17,590
information depending of the if the

590
00:25:17,590 --> 00:25:19,990
address is cached or not so we can use

591
00:25:19,990 --> 00:25:24,129
it instead of the reload step so our

592
00:25:24,129 --> 00:25:26,440
cover channel works across core and also

593
00:25:26,440 --> 00:25:29,619
across CPU and is way faster than any of

594
00:25:29,619 --> 00:25:31,360
the state-of-the-art cover channel which

595
00:25:31,360 --> 00:25:34,779
has been published so for instance we

596
00:25:34,779 --> 00:25:37,509
had a cover terminal using the volume

597
00:25:37,509 --> 00:25:40,809
settings and it only got 150 bits per

598
00:25:40,809 --> 00:25:44,289
second or one using the type of intense

599
00:25:44,289 --> 00:25:49,090
with 4k bits per second so our cover

600
00:25:49,090 --> 00:25:51,460
channel in the best case using flash and

601
00:25:51,460 --> 00:25:56,649
reload had one megabit per second and as

602
00:25:56,649 --> 00:25:58,809
you can see when we use a victim reload

603
00:25:58,809 --> 00:26:01,179
it still it's much slower of course

604
00:26:01,179 --> 00:26:04,210
because there's much noise but it's even

605
00:26:04,210 --> 00:26:06,490
fat is still faster than any previously

606
00:26:06,490 --> 00:26:09,340
discovered cover channel and now

607
00:26:09,340 --> 00:26:11,230
Clementine will tell us how we did the

608
00:26:11,230 --> 00:26:14,110
demo and how you can use our attacks to

609
00:26:14,110 --> 00:26:17,590
spy on the user so on our second case

610
00:26:17,590 --> 00:26:19,899
study and for the rest and the attack

611
00:26:19,899 --> 00:26:21,580
scenario is a bit different than for the

612
00:26:21,580 --> 00:26:24,129
cover channel here we do not have two

613
00:26:24,129 --> 00:26:25,990
malicious application but just one

614
00:26:25,990 --> 00:26:27,909
malicious application that is going to

615
00:26:27,909 --> 00:26:32,620
spy on the other benign applications so

616
00:26:32,620 --> 00:26:35,590
problem is always which address do we

617
00:26:35,590 --> 00:26:38,320
want to spy on so locating these event

618
00:26:38,320 --> 00:26:42,430
dependent memory accesses so to do that

619
00:26:42,430 --> 00:26:44,620
we had cache Don Pettit acts on Intel

620
00:26:44,620 --> 00:26:47,680
CPUs and basically reported that one so

621
00:26:47,680 --> 00:26:50,350
the first step is we are going to map a

622
00:26:50,350 --> 00:26:53,020
shared library or executable then we are

623
00:26:53,020 --> 00:26:54,970
going to repeatedly trigger an events

624
00:26:54,970 --> 00:26:56,830
and in parallel of that we are going to

625
00:26:56,830 --> 00:27:01,390
use flash and we load on one address if

626
00:27:01,390 --> 00:27:03,250
we have a lot of cache hits then it

627
00:27:03,250 --> 00:27:04,540
means that the address the specific

628
00:27:04,540 --> 00:27:06,640
address is used by the library or the

629
00:27:06,640 --> 00:27:09,070
executive on and then we are going to

630
00:27:09,070 --> 00:27:11,860
repeat this second step for every

631
00:27:11,860 --> 00:27:16,270
address of the library if then you want

632
00:27:16,270 --> 00:27:18,010
to spy on more events then you just

633
00:27:18,010 --> 00:27:21,550
repeat step two and three so we obtain a

634
00:27:21,550 --> 00:27:23,440
catch template matrix which is basically

635
00:27:23,440 --> 00:27:25,809
how many cache hits we have for each

636
00:27:25,809 --> 00:27:27,730
pair event and address so if you have a

637
00:27:27,730 --> 00:27:29,920
dark cell it means we had many cache

638
00:27:29,920 --> 00:27:32,230
hits if you have a light cell no cash no

639
00:27:32,230 --> 00:27:35,170
cache its we can do that on shell memory

640
00:27:35,170 --> 00:27:37,990
and also add binaries so this example is

641
00:27:37,990 --> 00:27:40,690
on the android keyboard and what's quite

642
00:27:40,690 --> 00:27:42,820
interesting in here is to see that we

643
00:27:42,820 --> 00:27:45,490
have different numbers of cache sheets

644
00:27:45,490 --> 00:27:47,590
for different addresses depending on

645
00:27:47,590 --> 00:27:50,950
which type of input we had so here the

646
00:27:50,950 --> 00:27:53,200
user pressed an alphabet key the enter

647
00:27:53,200 --> 00:27:55,059
key the space key and the backspace key

648
00:27:55,059 --> 00:27:58,510
and if you see for example if we spy on

649
00:27:58,510 --> 00:28:00,490
this address in particular the only

650
00:28:00,490 --> 00:28:03,130
event that causes cache hits is the

651
00:28:03,130 --> 00:28:04,780
alphabet so if we spy on this one and we

652
00:28:04,780 --> 00:28:06,670
had some cash sheets it means that the

653
00:28:06,670 --> 00:28:09,400
user press an alphabet key now we can

654
00:28:09,400 --> 00:28:12,070
also combine different addresses and for

655
00:28:12,070 --> 00:28:14,170
example if we combine these two address

656
00:28:14,170 --> 00:28:15,790
since then we can differentiate between

657
00:28:15,790 --> 00:28:17,940
the backspace and the alphabet because

658
00:28:17,940 --> 00:28:20,500
both the backspace and the alphabets

659
00:28:20,500 --> 00:28:22,809
have cache hits on this address but only

660
00:28:22,809 --> 00:28:25,030
the alphabet Healthcare shapes on this

661
00:28:25,030 --> 00:28:28,270
one so basically if we have cache hits

662
00:28:28,270 --> 00:28:30,250
on this address but no cache sheets on

663
00:28:30,250 --> 00:28:31,690
this one it means that is the backspace

664
00:28:31,690 --> 00:28:33,429
and we can differentiate between

665
00:28:33,429 --> 00:28:35,500
alphabet and backspace like that and

666
00:28:35,500 --> 00:28:38,290
this is basically what we have seen in

667
00:28:38,290 --> 00:28:41,890
the demo so that was now to see from

668
00:28:41,890 --> 00:28:44,890
which address we are going to choose to

669
00:28:44,890 --> 00:28:45,809
monitor

670
00:28:45,809 --> 00:28:48,359
and now monitoring them using a victim

671
00:28:48,359 --> 00:28:50,639
reload and so on two different addresses

672
00:28:50,639 --> 00:28:53,159
on the Alcatel OneTouch pop two on this

673
00:28:53,159 --> 00:28:55,799
text file you can see that we can really

674
00:28:55,799 --> 00:28:58,619
differentiate keys from spaces so we

675
00:28:58,619 --> 00:29:01,320
have first we have very precise timing

676
00:29:01,320 --> 00:29:04,049
here and we have exactly one cache hit

677
00:29:04,049 --> 00:29:06,719
per of space that the users pressed so

678
00:29:06,719 --> 00:29:09,419
we can really see the in Turkey stroke

679
00:29:09,419 --> 00:29:12,029
timing here and we can modern that

680
00:29:12,029 --> 00:29:15,059
distinguish between the keys and the

681
00:29:15,059 --> 00:29:17,759
space because there is one address that

682
00:29:17,759 --> 00:29:21,080
reacts only two space has been pressed

683
00:29:21,080 --> 00:29:24,839
so we have a different fit between a key

684
00:29:24,839 --> 00:29:28,109
and spaces and really precise timing so

685
00:29:28,109 --> 00:29:30,389
this was an example on the keyboard but

686
00:29:30,389 --> 00:29:33,119
that is really endless possibilities

687
00:29:33,119 --> 00:29:36,299
just can alter libraries and as long as

688
00:29:36,299 --> 00:29:38,399
you have some secret dependent accesses

689
00:29:38,399 --> 00:29:40,019
then you will be able to automate these

690
00:29:40,019 --> 00:29:42,269
attacks and the really neat thing is

691
00:29:42,269 --> 00:29:45,330
that you do not need any source code for

692
00:29:45,330 --> 00:29:49,349
that just use the occasional method X so

693
00:29:49,349 --> 00:29:51,239
you can spy and learn about the users

694
00:29:51,239 --> 00:29:54,239
behavior other kind of attacks that we

695
00:29:54,239 --> 00:29:56,820
can foresee is like if the user turned

696
00:29:56,820 --> 00:30:00,799
on the GPS out the camera for example

697
00:30:00,799 --> 00:30:03,419
now we have our third case study and

698
00:30:03,419 --> 00:30:04,979
we're going to add a cryptographic

699
00:30:04,979 --> 00:30:09,479
algorithms using cache attacks so our

700
00:30:09,479 --> 00:30:11,849
use case is the AES t-tables and this

701
00:30:11,849 --> 00:30:13,559
one is a fast software implementation

702
00:30:13,559 --> 00:30:16,080
because it uses sub pre computed look-up

703
00:30:16,080 --> 00:30:19,320
tables now the bad thing is that since

704
00:30:19,320 --> 00:30:21,869
2006 it is known to be vulnerable to

705
00:30:21,869 --> 00:30:24,299
cyber attacks so the attack has been

706
00:30:24,299 --> 00:30:26,460
done by all wicked an and it's a

707
00:30:26,460 --> 00:30:29,429
one-round known plaintext attack so you

708
00:30:29,429 --> 00:30:31,559
have Peter plaintext MK the secret key

709
00:30:31,559 --> 00:30:34,349
and at each round are you're going to

710
00:30:34,349 --> 00:30:37,499
compute an intermediate state and on the

711
00:30:37,499 --> 00:30:39,570
first round this intermediate state is

712
00:30:39,570 --> 00:30:42,119
AD the access table indices and it's

713
00:30:42,119 --> 00:30:44,940
just basically plaintext so secret key

714
00:30:44,940 --> 00:30:48,359
now this is a known plaintext attack so

715
00:30:48,359 --> 00:30:51,509
if we are able to recover this access

716
00:30:51,509 --> 00:30:53,369
table indices it means that we have

717
00:30:53,369 --> 00:30:56,210
recovered the key because it's just so

718
00:30:56,210 --> 00:30:59,690
so this has been shown in 2003

719
00:30:59,690 --> 00:31:02,180
that's ten years ago so nobody uses that

720
00:31:02,180 --> 00:31:05,810
anymore right no that's actually the

721
00:31:05,810 --> 00:31:08,330
default implementation of bouncy castle

722
00:31:08,330 --> 00:31:11,480
it uses these two tables and we've seen

723
00:31:11,480 --> 00:31:12,920
that we can monitor a lot of things with

724
00:31:12,920 --> 00:31:15,200
cache attack so let's monitor these tea

725
00:31:15,200 --> 00:31:17,840
tables entries now the difference

726
00:31:17,840 --> 00:31:19,670
between this attack and the previous one

727
00:31:19,670 --> 00:31:22,220
is that for the previous one we had some

728
00:31:22,220 --> 00:31:24,740
kind of shell memory here the Java

729
00:31:24,740 --> 00:31:26,660
Virtual Machine creates a copy of the

730
00:31:26,660 --> 00:31:30,110
tea table when the app starts so it

731
00:31:30,110 --> 00:31:31,670
means that we do not have any kind of

732
00:31:31,670 --> 00:31:34,100
shell memory so we cannot use a victim

733
00:31:34,100 --> 00:31:36,740
reload of flushing reload but at the

734
00:31:36,740 --> 00:31:38,900
beginning I've shown you we have priming

735
00:31:38,900 --> 00:31:40,370
probe if you don't have any kind of

736
00:31:40,370 --> 00:31:43,180
shell memory so we just use that and

737
00:31:43,180 --> 00:31:46,550
here's the time the kind of figure that

738
00:31:46,550 --> 00:31:47,870
you can have if the attack is successful

739
00:31:47,870 --> 00:31:51,590
so here you have to plant expert values

740
00:31:51,590 --> 00:31:54,860
and here the at the addresses and the

741
00:31:54,860 --> 00:31:57,170
addresses are basically which tea table

742
00:31:57,170 --> 00:32:00,200
entry was accessed and this has been

743
00:32:00,200 --> 00:32:02,780
done using a key that is all zeros and

744
00:32:02,780 --> 00:32:04,880
as long as you have this really nice

745
00:32:04,880 --> 00:32:06,380
diagonal it means that the attack

746
00:32:06,380 --> 00:32:09,380
succeeded if the key is not zeros then

747
00:32:09,380 --> 00:32:10,820
you will just have a different access

748
00:32:10,820 --> 00:32:13,730
pattern here but you can in each case

749
00:32:13,730 --> 00:32:15,770
recover which T turbulently was accessed

750
00:32:15,770 --> 00:32:19,400
and therefore recover the key and now

751
00:32:19,400 --> 00:32:22,430
our last case study and in addition we

752
00:32:22,430 --> 00:32:24,140
want to show you that you can also use

753
00:32:24,140 --> 00:32:25,880
those attacks to monitor all the UM

754
00:32:25,880 --> 00:32:28,340
trust zone and the UM trust zone is a

755
00:32:28,340 --> 00:32:31,340
hardware based security technology which

756
00:32:31,340 --> 00:32:33,530
provides you with a secure execution

757
00:32:33,530 --> 00:32:36,920
environment and roots of trust and there

758
00:32:36,920 --> 00:32:38,600
are small applications running on it

759
00:32:38,600 --> 00:32:40,610
called trust let's and the run in the

760
00:32:40,610 --> 00:32:42,470
secure world in parallel to your

761
00:32:42,470 --> 00:32:45,200
untrusted operating system and they

762
00:32:45,200 --> 00:32:47,570
implement things like a credential store

763
00:32:47,570 --> 00:32:50,210
or a secure element for payments or

764
00:32:50,210 --> 00:32:53,750
maybe digital rights management and one

765
00:32:53,750 --> 00:32:56,120
wants to assume that information which

766
00:32:56,120 --> 00:32:58,430
is stored and processed in the trusted

767
00:32:58,430 --> 00:33:00,620
world should not be leaked to the non

768
00:33:00,620 --> 00:33:03,350
secure world however we find on one

769
00:33:03,350 --> 00:33:05,210
smartphone there is a trust let which

770
00:33:05,210 --> 00:33:06,470
you can use to create our essay

771
00:33:06,470 --> 00:33:10,880
signatures for arbitrary data and we

772
00:33:10,880 --> 00:33:12,710
measured some time difference

773
00:33:12,710 --> 00:33:16,279
depending on the key that is used and we

774
00:33:16,279 --> 00:33:17,539
had no knowledge about the

775
00:33:17,539 --> 00:33:19,789
implementation of the trusted operating

776
00:33:19,789 --> 00:33:22,130
system and also not about the trust let

777
00:33:22,130 --> 00:33:24,679
so we didn't have any source code and

778
00:33:24,679 --> 00:33:27,289
it's not necessarily required to do

779
00:33:27,289 --> 00:33:30,080
something without having a source code

780
00:33:30,080 --> 00:33:32,870
so what we can do is we can distinguish

781
00:33:32,870 --> 00:33:35,720
between valid and invalid keys that are

782
00:33:35,720 --> 00:33:38,390
processed in the trust zone and on this

783
00:33:38,390 --> 00:33:41,809
plot you see on the x-axis the cash set

784
00:33:41,809 --> 00:33:44,929
that is used and on the y-axis the mean

785
00:33:44,929 --> 00:33:48,220
squared error from two measurements in

786
00:33:48,220 --> 00:33:51,230
comparison with the mean over all valid

787
00:33:51,230 --> 00:33:54,409
keys and the black line is an invalid

788
00:33:54,409 --> 00:33:55,610
key and you see there is a huge

789
00:33:55,610 --> 00:33:58,010
difference on almost every care set if

790
00:33:58,010 --> 00:34:01,010
you use an invalid key in on the other

791
00:34:01,010 --> 00:34:03,890
hand if user valid key and over here you

792
00:34:03,890 --> 00:34:05,960
can see you can also distinguish between

793
00:34:05,960 --> 00:34:08,629
which key has been used on some cash

794
00:34:08,629 --> 00:34:11,839
sets and maybe you can build more

795
00:34:11,839 --> 00:34:14,239
sophisticated tags on that because the

796
00:34:14,239 --> 00:34:16,099
drafts on in the end leaks to the

797
00:34:16,099 --> 00:34:17,989
untrusted world and so you can monitor

798
00:34:17,989 --> 00:34:21,230
what's happening in the trust zone so

799
00:34:21,230 --> 00:34:23,869
last but not least we want to show you

800
00:34:23,869 --> 00:34:26,000
the tools that we have developed to

801
00:34:26,000 --> 00:34:29,989
mount such cash attacks and the first

802
00:34:29,989 --> 00:34:31,730
thing we did we build the library to

803
00:34:31,730 --> 00:34:33,800
build cross-platform cache attacks you

804
00:34:33,800 --> 00:34:36,020
can write your attic code once and can

805
00:34:36,020 --> 00:34:40,369
execute it on x86 mv7 and on v8 and it

806
00:34:40,369 --> 00:34:42,469
implements various attack techniques

807
00:34:42,469 --> 00:34:44,060
where some of them we've showed you

808
00:34:44,060 --> 00:34:47,000
previously and it's open source and you

809
00:34:47,000 --> 00:34:50,750
can down it download it online and all

810
00:34:50,750 --> 00:34:52,790
the describe examples that we have

811
00:34:52,790 --> 00:34:55,159
showed you today have been developed on

812
00:34:55,159 --> 00:34:58,310
top on this life of this library and we

813
00:34:58,310 --> 00:35:00,530
also include eviction strategies for the

814
00:35:00,530 --> 00:35:02,930
devices that we have used so you can go

815
00:35:02,930 --> 00:35:05,030
and try to code yourself if you have the

816
00:35:05,030 --> 00:35:08,810
same device and we provide you with a

817
00:35:08,810 --> 00:35:11,720
very sophisticated example code and good

818
00:35:11,720 --> 00:35:13,700
documentation how you can install and

819
00:35:13,700 --> 00:35:16,849
use the library and in addition this

820
00:35:16,849 --> 00:35:19,130
library also allows you to implement

821
00:35:19,130 --> 00:35:22,880
cross-platform roham attacks and this is

822
00:35:22,880 --> 00:35:25,400
the github all that we have and you can

823
00:35:25,400 --> 00:35:26,520
just go there

824
00:35:26,520 --> 00:35:29,370
download the code in addition if you

825
00:35:29,370 --> 00:35:31,590
have a device that we didn't have and

826
00:35:31,590 --> 00:35:33,240
you still want to mount those attacks

827
00:35:33,240 --> 00:35:35,340
you can use our eviction strategy

828
00:35:35,340 --> 00:35:38,580
evaluator and this is basically the tool

829
00:35:38,580 --> 00:35:41,250
which automatically tries several

830
00:35:41,250 --> 00:35:43,220
eviction strategies on your phone and

831
00:35:43,220 --> 00:35:45,990
provide you with a database that you can

832
00:35:45,990 --> 00:35:47,850
use to analyze and find an eviction

833
00:35:47,850 --> 00:35:50,760
strategy you want to use and it's also

834
00:35:50,760 --> 00:35:55,020
in our repository and last but not least

835
00:35:55,020 --> 00:35:57,540
we have also an implementation of the

836
00:35:57,540 --> 00:35:59,580
cache template the text so that you can

837
00:35:59,580 --> 00:36:01,920
also use them to find libraries and

838
00:36:01,920 --> 00:36:04,350
executables for vulnerable addresses so

839
00:36:04,350 --> 00:36:06,150
you can spy on the user like we did in

840
00:36:06,150 --> 00:36:09,090
the demo and we even give you a small

841
00:36:09,090 --> 00:36:11,250
tool which you can use to simulate input

842
00:36:11,250 --> 00:36:13,290
events so that you don't have to be on

843
00:36:13,290 --> 00:36:15,090
the phone and type everything manually

844
00:36:15,090 --> 00:36:18,000
and you find this also in our repository

845
00:36:18,000 --> 00:36:21,600
and now Clementine wants to talk about

846
00:36:21,600 --> 00:36:23,580
some countermeasures what we can do to

847
00:36:23,580 --> 00:36:27,060
prevent maybe some of these attacks so

848
00:36:27,060 --> 00:36:30,390
the first thing to know is that we had

849
00:36:30,390 --> 00:36:33,780
cache attacks on Intel CPUs for a good

850
00:36:33,780 --> 00:36:36,510
decade now and we still haven't found a

851
00:36:36,510 --> 00:36:38,490
good solution to prevent them because it

852
00:36:38,490 --> 00:36:40,440
uses this really crucial element for

853
00:36:40,440 --> 00:36:42,840
perform that is the CPU cache and we

854
00:36:42,840 --> 00:36:45,090
cannot just get rid of the cache doesn't

855
00:36:45,090 --> 00:36:46,280
make any sense

856
00:36:46,280 --> 00:36:49,050
so a first countermeasure that had been

857
00:36:49,050 --> 00:36:52,140
proposed for Intel CPUs was to have more

858
00:36:52,140 --> 00:36:54,660
coarse-grained timers because we really

859
00:36:54,660 --> 00:36:56,910
need to make it to find the difference

860
00:36:56,910 --> 00:36:59,280
between caches and cache misses and that

861
00:36:59,280 --> 00:37:01,650
is in the order of nanoseconds so the

862
00:37:01,650 --> 00:37:03,930
idea is if we have a more coarse grained

863
00:37:03,930 --> 00:37:06,060
timers that is on the resolution of

864
00:37:06,060 --> 00:37:07,830
let's say milliseconds we wouldn't be

865
00:37:07,830 --> 00:37:09,270
able to differentiate between these

866
00:37:09,270 --> 00:37:11,850
cache hits and these cache misses the

867
00:37:11,850 --> 00:37:13,680
thing is that as we've just shown you a

868
00:37:13,680 --> 00:37:16,260
thread timer is sufficient to recover an

869
00:37:16,260 --> 00:37:18,450
accuracy in the order of nanoseconds so

870
00:37:18,450 --> 00:37:21,000
as long as we had some really true

871
00:37:21,000 --> 00:37:23,340
parallelism for this file we will be

872
00:37:23,340 --> 00:37:26,340
able to have fine-grained timers so this

873
00:37:26,340 --> 00:37:28,940
is really not a good countermeasure and

874
00:37:28,940 --> 00:37:31,980
the second one is no shell memory so if

875
00:37:31,980 --> 00:37:33,510
we do not have any shell memory we

876
00:37:33,510 --> 00:37:36,120
cannot use a flush in Medora we can

877
00:37:36,120 --> 00:37:38,250
reload and this out

878
00:37:38,250 --> 00:37:41,070
easiest attacks we can do and also the

879
00:37:41,070 --> 00:37:44,040
most fine-grained so we can be very

880
00:37:44,040 --> 00:37:46,200
precise with this attacks the thing is

881
00:37:46,200 --> 00:37:48,510
that it that left us with priming probe

882
00:37:48,510 --> 00:37:51,960
and we can still come really nice

883
00:37:51,960 --> 00:37:54,450
attacks like we've shown you earlier so

884
00:37:54,450 --> 00:37:56,370
that was that was still raised the

885
00:37:56,370 --> 00:37:57,900
powerful attacker so that would still be

886
00:37:57,900 --> 00:38:00,780
a good thing to implement especially if

887
00:38:00,780 --> 00:38:03,330
we also have the system information that

888
00:38:03,330 --> 00:38:05,220
is restricted so for example no access

889
00:38:05,220 --> 00:38:07,470
to page map so in this case we wouldn't

890
00:38:07,470 --> 00:38:10,560
have any access to physical addresses

891
00:38:10,560 --> 00:38:13,230
and that makes the hotter the attacks

892
00:38:13,230 --> 00:38:16,290
much harder again for prevent probe how

893
00:38:16,290 --> 00:38:19,290
does again still possible it just raises

894
00:38:19,290 --> 00:38:22,620
the power for the attackers now I think

895
00:38:22,620 --> 00:38:25,680
a crucial thing is that on modern smart

896
00:38:25,680 --> 00:38:27,780
phones we have cryptographic instruction

897
00:38:27,780 --> 00:38:32,250
extensions so using like AES suitable

898
00:38:32,250 --> 00:38:34,470
implementation it should not be the case

899
00:38:34,470 --> 00:38:38,550
so yet this instruction extension are

900
00:38:38,550 --> 00:38:39,840
still not the default everywhere this is

901
00:38:39,840 --> 00:38:41,040
really bad

902
00:38:41,040 --> 00:38:43,320
also if you have a device that does not

903
00:38:43,320 --> 00:38:45,480
have these extensions we also know how

904
00:38:45,480 --> 00:38:49,860
to have crypto algorithm and software

905
00:38:49,860 --> 00:38:52,260
only that do not leak any information so

906
00:38:52,260 --> 00:38:56,220
that should be the case now it's not a

907
00:38:56,220 --> 00:38:58,770
system-wide a solution so it still

908
00:38:58,770 --> 00:39:01,050
wouldn't protect from a spy music

909
00:39:01,050 --> 00:39:02,640
behavior on the keyboard like we showed

910
00:39:02,640 --> 00:39:06,780
you in the demo so I think the message

911
00:39:06,780 --> 00:39:09,240
here is we know how to protect crypto so

912
00:39:09,240 --> 00:39:12,150
we should do that for the rest there is

913
00:39:12,150 --> 00:39:14,040
really no satisfying solution we didn't

914
00:39:14,040 --> 00:39:16,710
found solutions for Intel CPUs I'm not

915
00:39:16,710 --> 00:39:18,810
realistic that we find solution for arm

916
00:39:18,810 --> 00:39:22,610
CPU anytime soon now for the conclusion

917
00:39:22,610 --> 00:39:26,430
so what we've seen today is that all of

918
00:39:26,430 --> 00:39:28,260
the powerful cache attacks are also

919
00:39:28,260 --> 00:39:30,870
applicable to mobile devices and they do

920
00:39:30,870 --> 00:39:33,000
not require any permission or any

921
00:39:33,000 --> 00:39:35,490
privilege and you can use them to build

922
00:39:35,490 --> 00:39:37,830
fast copper channels to evade the

923
00:39:37,830 --> 00:39:40,650
sandboxing and privileged permission

924
00:39:40,650 --> 00:39:43,560
system and you can use them to spy on

925
00:39:43,560 --> 00:39:45,270
the user's activity with a very high

926
00:39:45,270 --> 00:39:47,430
accuracy as we have seen in the demo as

927
00:39:47,430 --> 00:39:50,370
well and you can also use it to derive

928
00:39:50,370 --> 00:39:51,210
cryptographic

929
00:39:51,210 --> 00:39:53,400
cheese and to monitor the um trust zone

930
00:39:53,400 --> 00:39:57,270
which should not be possible so we want

931
00:39:57,270 --> 00:39:58,910
to thank you for your attention and

932
00:39:58,910 --> 00:40:01,320
welcome you to try our tools yourself

933
00:40:01,320 --> 00:40:04,109
they are all online and if you have any

934
00:40:04,109 --> 00:40:07,380
questions feel free to ask them or talk

935
00:40:07,380 --> 00:40:10,550
to us later thank you

