1
00:00:00,060 --> 00:00:02,820
okay so hello everyone and thank you

2
00:00:02,820 --> 00:00:04,830
very much for coming today we are going

3
00:00:04,830 --> 00:00:07,710
to see a research that we and we've

4
00:00:07,710 --> 00:00:09,420
conducted last year on Qualcomm virus

5
00:00:09,420 --> 00:00:13,349
code for Android and so our agenda for

6
00:00:13,349 --> 00:00:14,030
today

7
00:00:14,030 --> 00:00:16,770
first we will speak about chips

8
00:00:16,770 --> 00:00:19,350
generally add a location in the

9
00:00:19,350 --> 00:00:22,350
ecosystem of Android how they fix and

10
00:00:22,350 --> 00:00:24,269
affect the overall security of Android

11
00:00:24,269 --> 00:00:27,420
and then we will focus small Qualcomm as

12
00:00:27,420 --> 00:00:31,349
a chipset and if you sum of its

13
00:00:31,349 --> 00:00:34,079
different subsystems afterwards will

14
00:00:34,079 --> 00:00:36,780
reveal a new not anymore the

15
00:00:36,780 --> 00:00:39,719
vulnerabilities that we found including

16
00:00:39,719 --> 00:00:43,410
a video name of one of them and finally

17
00:00:43,410 --> 00:00:46,140
we will discuss some streaking point for

18
00:00:46,140 --> 00:00:49,110
in the security of Android and ideas how

19
00:00:49,110 --> 00:00:52,800
to improve it so 30 seconds about myself

20
00:00:52,800 --> 00:00:55,949
and my name is Adam donenfeld I've been

21
00:00:55,949 --> 00:00:57,660
a security researcher for years and

22
00:00:57,660 --> 00:01:00,480
mainly the mobile field but I've done

23
00:01:00,480 --> 00:01:03,120
some this is covered as well I really

24
00:01:03,120 --> 00:01:04,739
done a security assessment and

25
00:01:04,739 --> 00:01:07,790
exploitation right now and now I work

26
00:01:07,790 --> 00:01:10,830
for in Tesla security researcher for

27
00:01:10,830 --> 00:01:13,439
Android and in my free time I also a

28
00:01:13,439 --> 00:01:16,350
study German additionally I would like

29
00:01:16,350 --> 00:01:19,439
to think abortion done your body and

30
00:01:19,439 --> 00:01:22,110
powerful burn goals for helping me and

31
00:01:22,110 --> 00:01:25,020
supporting me during the hard moments in

32
00:01:25,020 --> 00:01:28,619
the research so let's talk about Android

33
00:01:28,619 --> 00:01:31,710
and the energetic architecture the

34
00:01:31,710 --> 00:01:34,200
Android supply chain consists of very

35
00:01:34,200 --> 00:01:36,390
few fundamental players we all know

36
00:01:36,390 --> 00:01:39,119
first one is the Linux kernel with

37
00:01:39,119 --> 00:01:41,790
humidification like binder for example

38
00:01:41,790 --> 00:01:44,520
and then we have the Android project

39
00:01:44,520 --> 00:01:47,369
which is exclusively developed by Google

40
00:01:47,369 --> 00:01:51,000
but also third-party contributors and

41
00:01:51,000 --> 00:01:53,909
patches amplifications and we also have

42
00:01:53,909 --> 00:01:58,409
the OEMs like Samsung LG HTC associate

43
00:01:58,409 --> 00:02:01,590
many others but that's not completely

44
00:02:01,590 --> 00:02:04,500
there is another player that is often

45
00:02:04,500 --> 00:02:06,540
are estimated for its effect on the

46
00:02:06,540 --> 00:02:11,459
security of Android chips it and the

47
00:02:11,459 --> 00:02:11,870
chips

48
00:02:11,870 --> 00:02:15,349
a very important fall in the supply

49
00:02:15,349 --> 00:02:17,870
chain of Android for two main reasons

50
00:02:17,870 --> 00:02:20,450
first of all most of them unification

51
00:02:20,450 --> 00:02:23,239
are used most of the of the chipset

52
00:02:23,239 --> 00:02:25,819
modifications are usually very essential

53
00:02:25,819 --> 00:02:28,430
and in a very low level in the system

54
00:02:28,430 --> 00:02:30,799
and that means that if we find the

55
00:02:30,799 --> 00:02:34,069
security but it often leads to a game

56
00:02:34,069 --> 00:02:36,319
over in the persuasion of privilege

57
00:02:36,319 --> 00:02:38,739
escalations in Android now additionally

58
00:02:38,739 --> 00:02:42,530
since chipsets usually distribute the

59
00:02:42,530 --> 00:02:46,040
patch and of too many different OEMs it

60
00:02:46,040 --> 00:02:49,160
means that the single vulnerability in

61
00:02:49,160 --> 00:02:51,680
the chipset code is most likely

62
00:02:51,680 --> 00:02:54,769
affecting multiple OMS and supposing a

63
00:02:54,769 --> 00:02:56,870
very larger risk than a vulnerability in

64
00:02:56,870 --> 00:03:02,450
just om code now let's see I know that

65
00:03:02,450 --> 00:03:05,390
the market is fragmented very equally

66
00:03:05,390 --> 00:03:08,030
and not here we can see here that

67
00:03:08,030 --> 00:03:11,170
Qualcomm dominates the market and it is

68
00:03:11,170 --> 00:03:15,109
the most popular arm and chips chips at

69
00:03:15,109 --> 00:03:17,690
a manufacturer and when they was there

70
00:03:17,690 --> 00:03:19,489
for a very interesting target for our

71
00:03:19,489 --> 00:03:23,769
research so let's talk about welcome

72
00:03:23,769 --> 00:03:26,780
Qualcomm has a very large impact on over

73
00:03:26,780 --> 00:03:29,810
system in fact in fact there are a lot

74
00:03:29,810 --> 00:03:31,760
of different subsystems which are

75
00:03:31,760 --> 00:03:35,090
completely written by Qualcomm each one

76
00:03:35,090 --> 00:03:36,919
of these subsystems is a great place to

77
00:03:36,919 --> 00:03:40,099
start looking for vulnerabilities and if

78
00:03:40,099 --> 00:03:41,930
the system is if the component is

79
00:03:41,930 --> 00:03:44,599
low-level enough in the whole system one

80
00:03:44,599 --> 00:03:46,790
bug would probably be enough to

81
00:03:46,790 --> 00:03:48,980
completely compromise the device and

82
00:03:48,980 --> 00:03:51,799
that's without mentioning components

83
00:03:51,799 --> 00:03:54,139
that have been modified to satisfy the

84
00:03:54,139 --> 00:03:57,319
requirements of Qualcomm and let's see

85
00:03:57,319 --> 00:04:00,280
an example of one of these so our first

86
00:04:00,280 --> 00:04:04,370
vulnerability and we call it as minion

87
00:04:04,370 --> 00:04:07,250
devil it's a vulnerability in the Ashman

88
00:04:07,250 --> 00:04:11,269
module action module is the acronym is

89
00:04:11,269 --> 00:04:14,629
the Android a shared memory it's a

90
00:04:14,629 --> 00:04:16,849
proprietary memory allocator it is

91
00:04:16,849 --> 00:04:20,089
implemented in the files fot here close

92
00:04:20,089 --> 00:04:23,120
sharing a memory between processes

93
00:04:23,120 --> 00:04:27,020
and it reminds a little bit the Linux Sh

94
00:04:27,020 --> 00:04:30,949
a mechanism except that few differences

95
00:04:30,949 --> 00:04:35,000
like it supports a file based API so the

96
00:04:35,000 --> 00:04:36,860
whole interact usage of this mechanism

97
00:04:36,860 --> 00:04:41,600
is by file descriptors now Qualcomm a

98
00:04:41,600 --> 00:04:43,910
wanted to expand the nodded

99
00:04:43,910 --> 00:04:46,190
functionality but the API of this

100
00:04:46,190 --> 00:04:50,030
mechanism the kernel API so it wanted to

101
00:04:50,030 --> 00:04:53,540
easily receive information just by

102
00:04:53,540 --> 00:04:55,490
getting a file script own from the user

103
00:04:55,490 --> 00:04:59,210
and that's one of the functions that

104
00:04:59,210 --> 00:05:01,520
Qualcomm added so as you can see here

105
00:05:01,520 --> 00:05:04,220
let's see I don't think it works ok so

106
00:05:04,220 --> 00:05:05,750
as you can see here the function

107
00:05:05,750 --> 00:05:08,330
receives an input parameter of Alice

108
00:05:08,330 --> 00:05:12,560
crypto and free output pointers and the

109
00:05:12,560 --> 00:05:15,050
what the function does is converting the

110
00:05:15,050 --> 00:05:17,330
file descriptor so a struct file which

111
00:05:17,330 --> 00:05:19,490
is the internal representation of file

112
00:05:19,490 --> 00:05:21,860
in the Linux kernel then the function

113
00:05:21,860 --> 00:05:23,930
checks if it is indeed a national file

114
00:05:23,930 --> 00:05:26,780
and if it is it just extract data from

115
00:05:26,780 --> 00:05:29,570
the private data of the file which is

116
00:05:29,570 --> 00:05:33,650
the pointer to the U to the pointer to

117
00:05:33,650 --> 00:05:35,810
information and it depends on every type

118
00:05:35,810 --> 00:05:38,570
of file so it just extract information

119
00:05:38,570 --> 00:05:42,620
to the output pointers and exits now a

120
00:05:42,620 --> 00:05:45,200
question that each security researcher

121
00:05:45,200 --> 00:05:48,860
must must ask himself is how does

122
00:05:48,860 --> 00:05:51,740
welcome verify that our F files crypto

123
00:05:51,740 --> 00:05:54,460
is indeed a nice inside the script all

124
00:05:54,460 --> 00:05:56,330
know for those of you who are a little

125
00:05:56,330 --> 00:05:59,090
bit less familiar with the linux api

126
00:05:59,090 --> 00:06:03,470
what we what usually have is the way to

127
00:06:03,470 --> 00:06:05,060
distinguish between different file types

128
00:06:05,060 --> 00:06:08,990
is by the operation handlers for example

129
00:06:08,990 --> 00:06:11,690
let's take a circuit file in a modular

130
00:06:11,690 --> 00:06:15,410
file if we perform a write operation on

131
00:06:15,410 --> 00:06:17,780
a circuit file obviously the behavior is

132
00:06:17,780 --> 00:06:19,669
different in comparison to a jeweler

133
00:06:19,669 --> 00:06:22,430
file now again everything is done by the

134
00:06:22,430 --> 00:06:24,560
kernel so we can just compare pointers

135
00:06:24,560 --> 00:06:26,270
and eventually this handlers are just

136
00:06:26,270 --> 00:06:28,610
pointers so just compare a pointer and

137
00:06:28,610 --> 00:06:31,280
we can see if the type of the file we

138
00:06:31,280 --> 00:06:34,010
think is is actually type way we were

139
00:06:34,010 --> 00:06:36,360
looking for but

140
00:06:36,360 --> 00:06:38,939
welcome decided that it's boring to do

141
00:06:38,939 --> 00:06:42,539
the obvious and instead of doing that we

142
00:06:42,539 --> 00:06:44,669
checked what's the name of the file and

143
00:06:44,669 --> 00:06:46,919
all if it's in if the file name is - man

144
00:06:46,919 --> 00:06:53,460
it might be Russian files no so so let's

145
00:06:53,460 --> 00:06:56,430
see what we have here we need to create

146
00:06:56,430 --> 00:06:59,099
a file name called - ma'am on the top of

147
00:06:59,099 --> 00:07:01,500
a mounting point now why on top of a

148
00:07:01,500 --> 00:07:04,110
mounting point because it's slash Ashman

149
00:07:04,110 --> 00:07:08,280
and it gets the just get the full path

150
00:07:08,280 --> 00:07:12,860
from the mounting point so unfortunately

151
00:07:12,860 --> 00:07:16,229
slash is the RAM disk and it is just

152
00:07:16,229 --> 00:07:18,419
read-only and any other mounting point

153
00:07:18,419 --> 00:07:20,669
is not accessible for the untrusted

154
00:07:20,669 --> 00:07:22,860
application now again if we would

155
00:07:22,860 --> 00:07:25,259
beforehand we can just do whatever we

156
00:07:25,259 --> 00:07:27,599
want but we are taking into perspective

157
00:07:27,599 --> 00:07:29,719
that we are unprivileged at this point

158
00:07:29,719 --> 00:07:33,360
so the way we found to overcome this

159
00:07:33,360 --> 00:07:35,639
problem was using unique feature called

160
00:07:35,639 --> 00:07:40,080
OBB so obviously is a Parker binary blob

161
00:07:40,080 --> 00:07:44,759
is deprecated but still works so few

162
00:07:44,759 --> 00:07:47,159
years ago if you would want if you would

163
00:07:47,159 --> 00:07:48,719
have wanted to upload the nap to the

164
00:07:48,719 --> 00:07:52,440
google play it h8 mustn't be more than

165
00:07:52,440 --> 00:07:56,159
100 100 megabytes so let's take for

166
00:07:56,159 --> 00:07:58,830
example games game steps extra sound

167
00:07:58,830 --> 00:08:01,440
pictures however and they usually cross

168
00:08:01,440 --> 00:08:03,990
this limitation so what usually what

169
00:08:03,990 --> 00:08:06,120
they used to do is first download the

170
00:08:06,120 --> 00:08:08,159
main functionality of the app and then

171
00:08:08,159 --> 00:08:11,099
externally download all the graphics and

172
00:08:11,099 --> 00:08:14,789
textures so all would be is basically a

173
00:08:14,789 --> 00:08:17,120
file system that anyone can create

174
00:08:17,120 --> 00:08:19,680
externally download and then just mount

175
00:08:19,680 --> 00:08:23,310
it so yeah it's a kind of fun so what we

176
00:08:23,310 --> 00:08:26,669
did was first to created an OBB file

177
00:08:26,669 --> 00:08:29,339
system and report a file called Ashman

178
00:08:29,339 --> 00:08:33,029
in it's a top and directory then we just

179
00:08:33,029 --> 00:08:35,789
mounted it we did we don't need any

180
00:08:35,789 --> 00:08:37,620
permission for that by the way and then

181
00:08:37,620 --> 00:08:40,380
we have a file name called a Ashman on

182
00:08:40,380 --> 00:08:41,760
the top of a mounting point and we can

183
00:08:41,760 --> 00:08:46,250
just send it to my channel and have fun

184
00:08:48,680 --> 00:08:54,059
okay now work to the next example in a

185
00:08:54,059 --> 00:08:57,360
completely different module again by the

186
00:08:57,360 --> 00:08:59,910
mast of this asteroid and about

187
00:08:59,910 --> 00:09:02,910
disclosure and this is a very important

188
00:09:02,910 --> 00:09:04,699
point to during the presentation we

189
00:09:04,699 --> 00:09:08,370
reported the vulnerability back in April

190
00:09:08,370 --> 00:09:11,879
and Qualcomm confirmed that is it is

191
00:09:11,879 --> 00:09:13,649
indeed a vulnerability in months later

192
00:09:13,649 --> 00:09:16,709
which is reasonable and then they

193
00:09:16,709 --> 00:09:20,069
release the patch in 28th of July but

194
00:09:20,069 --> 00:09:22,800
even though it was public since its 28th

195
00:09:22,800 --> 00:09:25,980
of July to date there was a public

196
00:09:25,980 --> 00:09:29,069
advisory we will fix it only in the 6th

197
00:09:29,069 --> 00:09:31,860
of September so everyone in the road

198
00:09:31,860 --> 00:09:34,290
head or more than a month to see the

199
00:09:34,290 --> 00:09:37,439
vulnerability explore it and you know

200
00:09:37,439 --> 00:09:41,370
still that I do hacker stuff so going to

201
00:09:41,370 --> 00:09:43,769
the next vulnerability in a completely

202
00:09:43,769 --> 00:09:47,309
different module so this one is the IPS

203
00:09:47,309 --> 00:09:50,100
IPC ultra module it is an IPC mechanism

204
00:09:50,100 --> 00:09:53,490
that was written XK by Qualcomm it is

205
00:09:53,490 --> 00:09:56,009
not it should not be accessible from an

206
00:09:56,009 --> 00:09:59,399
untrusted application and it is it is

207
00:09:59,399 --> 00:10:02,569
not very accessible now but it was and

208
00:10:02,569 --> 00:10:04,740
Google just added an excellent tool to

209
00:10:04,740 --> 00:10:11,069
block it so this IPC mechanism is just

210
00:10:11,069 --> 00:10:14,370
socket safe assembly number 27 AF MSM

211
00:10:14,370 --> 00:10:17,610
IPC and it's you can just send receive

212
00:10:17,610 --> 00:10:19,769
messages to other sockets in the family

213
00:10:19,769 --> 00:10:23,790
in the absolutely but it has fuel cool

214
00:10:23,790 --> 00:10:25,519
features that we are going to see

215
00:10:25,519 --> 00:10:28,860
freedom is for example you can whitelist

216
00:10:28,860 --> 00:10:32,429
or black or blacklist a sockets based on

217
00:10:32,429 --> 00:10:34,620
group IDs which is very interesting if

218
00:10:34,620 --> 00:10:37,220
you want to prevent unprivileged

219
00:10:37,220 --> 00:10:39,449
processes from talking to you and

220
00:10:39,449 --> 00:10:42,660
another feature that we are going to go

221
00:10:42,660 --> 00:10:46,199
to see is monitoring the system anyone

222
00:10:46,199 --> 00:10:48,509
in the system could just monitor

223
00:10:48,509 --> 00:10:50,279
creation or destruction of this

224
00:10:50,279 --> 00:10:53,459
endpoints and well calls my opinion now

225
00:10:53,459 --> 00:10:55,439
the best thing about it requires no

226
00:10:55,439 --> 00:10:59,939
permission to use so and there are four

227
00:10:59,939 --> 00:11:01,590
types of this socket

228
00:11:01,590 --> 00:11:04,260
a client's port control port IRS support

229
00:11:04,260 --> 00:11:06,300
and server port we are not going to talk

230
00:11:06,300 --> 00:11:08,190
about IRS support and server fault

231
00:11:08,190 --> 00:11:11,130
because they required high permission

232
00:11:11,130 --> 00:11:14,340
speeds so each time we create a socket

233
00:11:14,340 --> 00:11:16,910
it is by default the client port and

234
00:11:16,910 --> 00:11:19,080
transport is just the socket that can

235
00:11:19,080 --> 00:11:21,810
send and receive data and if you wanted

236
00:11:21,810 --> 00:11:24,030
the control port we had to issue Nayak

237
00:11:24,030 --> 00:11:25,800
tail and then our client port will be

238
00:11:25,800 --> 00:11:28,950
converted to a control port now how does

239
00:11:28,950 --> 00:11:30,600
this how does this look in the channel

240
00:11:30,600 --> 00:11:34,380
this is the function that handles iocked

241
00:11:34,380 --> 00:11:35,040
a request

242
00:11:35,040 --> 00:11:37,770
it's very risk the restrictive and

243
00:11:37,770 --> 00:11:40,110
straightforward every time you issue an

244
00:11:40,110 --> 00:11:42,330
axle on the system it locks the socket

245
00:11:42,330 --> 00:11:45,000
so we cannot issue to excels at the same

246
00:11:45,000 --> 00:11:49,380
time and in the socket and according to

247
00:11:49,380 --> 00:11:52,470
our request it does stuff so if we issue

248
00:11:52,470 --> 00:11:55,260
IPC well trioxide bankotsu port our

249
00:11:55,260 --> 00:11:57,930
socket will be converted from whatever

250
00:11:57,930 --> 00:12:01,890
it is to at LAN port that's the code

251
00:12:01,890 --> 00:12:04,680
that converts the socket when I say

252
00:12:04,680 --> 00:12:08,040
convert it just means take a a socket

253
00:12:08,040 --> 00:12:10,110
from at least eight and move it to this

254
00:12:10,110 --> 00:12:14,190
B now second because the laser doesn't

255
00:12:14,190 --> 00:12:18,930
walk on the screen wait so this is just

256
00:12:18,930 --> 00:12:22,500
a lock to the client port socket to the

257
00:12:22,500 --> 00:12:24,540
list then we take the object out from

258
00:12:24,540 --> 00:12:26,220
the client port from the client fault

259
00:12:26,220 --> 00:12:28,260
list we unlock the sock we unlock the

260
00:12:28,260 --> 00:12:30,720
list we lock the console port list we

261
00:12:30,720 --> 00:12:33,120
add our objects to the control port list

262
00:12:33,120 --> 00:12:36,300
then we unlock it so pretty

263
00:12:36,300 --> 00:12:38,280
straightforward but there is a

264
00:12:38,280 --> 00:12:40,080
vulnerability and we are going to see it

265
00:12:40,080 --> 00:12:43,080
now it's kind of how to follow but we

266
00:12:43,080 --> 00:12:44,310
really try to make it as close as

267
00:12:44,310 --> 00:12:47,400
possible so we are going to convert this

268
00:12:47,400 --> 00:12:50,310
object to a control port so the first

269
00:12:50,310 --> 00:12:53,220
line the first command is to lock the

270
00:12:53,220 --> 00:12:55,260
client list and then we take the object

271
00:12:55,260 --> 00:12:57,840
out from his list and now it's not in

272
00:12:57,840 --> 00:13:00,540
any list then we unlock it we unlock the

273
00:13:00,540 --> 00:13:02,850
client list we lock the control list we

274
00:13:02,850 --> 00:13:04,950
add the object to the control list and

275
00:13:04,950 --> 00:13:09,390
we unlock it not so complicated and

276
00:13:09,390 --> 00:13:11,940
there was nothing wrong with the flow

277
00:13:11,940 --> 00:13:14,320
that we saw here but

278
00:13:14,320 --> 00:13:16,240
there's always this but what happens

279
00:13:16,240 --> 00:13:19,600
when we convert control port to control

280
00:13:19,600 --> 00:13:22,000
port George no limitation for that so

281
00:13:22,000 --> 00:13:23,769
let's examine the code we lock the

282
00:13:23,769 --> 00:13:26,470
client list we take the object out from

283
00:13:26,470 --> 00:13:29,259
his list which is not locked we unlock

284
00:13:29,259 --> 00:13:31,889
the client list locking the control list

285
00:13:31,889 --> 00:13:34,420
putting the object back and unlocking

286
00:13:34,420 --> 00:13:35,380
the control list

287
00:13:35,380 --> 00:13:38,110
now for those of you who missed it even

288
00:13:38,110 --> 00:13:40,839
though the control is is unlocked we

289
00:13:40,839 --> 00:13:45,819
modify it and fun stuff can happen here

290
00:13:45,819 --> 00:13:48,819
so what we do what do we have here or

291
00:13:48,819 --> 00:13:51,790
what is operatives come to the control

292
00:13:51,790 --> 00:13:54,550
post list is modified without a lock so

293
00:13:54,550 --> 00:13:56,440
we can delete two objects simultaneously

294
00:13:56,440 --> 00:13:59,560
and therefore there is a race condition

295
00:13:59,560 --> 00:14:05,100
here and which leads to easily now I

296
00:14:05,100 --> 00:14:09,690
love the television to anyway and we

297
00:14:09,690 --> 00:14:12,790
know there is a explanation of how to

298
00:14:12,790 --> 00:14:15,040
exploit what you forward step abilities

299
00:14:15,040 --> 00:14:19,389
but and because we added some stuff we

300
00:14:19,389 --> 00:14:21,040
are going to skip it but you can find it

301
00:14:21,040 --> 00:14:23,860
online or asking later and now demo time

302
00:14:23,860 --> 00:14:27,339
so and what we're going to do because it

303
00:14:27,339 --> 00:14:32,170
found it back in the end of 2015 and we

304
00:14:32,170 --> 00:14:35,170
are using Marshall in this case so we

305
00:14:35,170 --> 00:14:38,050
are just installing our PLC we are going

306
00:14:38,050 --> 00:14:41,800
to see now that the device is not rooted

307
00:14:41,800 --> 00:14:44,050
and that it is indeed a genuine killer

308
00:14:44,050 --> 00:14:47,709
version and that gives a marshmallow

309
00:14:47,709 --> 00:14:51,480
Marshall device you can see here our

310
00:14:51,480 --> 00:14:54,819
build version release and we are not

311
00:14:54,819 --> 00:14:56,949
rooted of course so there are no

312
00:14:56,949 --> 00:14:58,870
prerequisite is a saline lock is

313
00:14:58,870 --> 00:15:06,569
enforcing and we are not putting s foot

314
00:15:07,319 --> 00:15:13,899
okay so our PLC ultimately installed

315
00:15:13,899 --> 00:15:15,939
this towards assuage file in the system

316
00:15:15,939 --> 00:15:18,699
partition and it also creates a local

317
00:15:18,699 --> 00:15:22,360
service at port 1 3 3 7 just receive

318
00:15:22,360 --> 00:15:25,630
texts and issues issues the dist excess

319
00:15:25,630 --> 00:15:28,420
root come s would comment so basically

320
00:15:28,420 --> 00:15:31,480
netcat and then a system and put it just

321
00:15:31,480 --> 00:15:35,050
called a comment so we're going to see

322
00:15:35,050 --> 00:15:38,440
now that system is normal

323
00:15:38,440 --> 00:15:41,490
there's nothing suspicious there and

324
00:15:41,490 --> 00:15:46,990
that's our services port 127 is just not

325
00:15:46,990 --> 00:15:49,350
there yet

326
00:15:49,530 --> 00:15:54,490
great so now we're going to actually

327
00:15:54,490 --> 00:15:56,650
exploit the vulnerability it takes

328
00:15:56,650 --> 00:15:59,290
approximately three seconds to do that

329
00:15:59,290 --> 00:16:04,540
and but because the GUI you know lots of

330
00:16:04,540 --> 00:16:10,810
stuff maybe six seconds okay so the

331
00:16:10,810 --> 00:16:12,610
sweet file that we are going to place in

332
00:16:12,610 --> 00:16:14,650
the system partition is called su gang

333
00:16:14,650 --> 00:16:16,540
cause of my left to the German language

334
00:16:16,540 --> 00:16:18,760
and so I don't you see it's so junk file

335
00:16:18,760 --> 00:16:20,680
which is a sweet file in order to see

336
00:16:20,680 --> 00:16:24,270
that the service is up we are now with

337
00:16:24,270 --> 00:16:27,700
the entire I mean three seconds but

338
00:16:27,700 --> 00:16:36,390
cleans up from stuff okay

339
00:16:36,390 --> 00:16:39,490
and this point device at this release

340
00:16:39,490 --> 00:16:41,880
file is placed the service is up and now

341
00:16:41,880 --> 00:16:46,030
we're going to see a difference you're

342
00:16:46,030 --> 00:16:49,480
still at one is fruit but SLE knocks on

343
00:16:49,480 --> 00:16:53,050
your enforcing the system and we're

344
00:16:53,050 --> 00:16:54,610
going to see now that if we try to

345
00:16:54,610 --> 00:16:56,410
connect to one four three seven

346
00:16:56,410 --> 00:16:58,720
we are not no longer getting connection

347
00:16:58,720 --> 00:17:00,820
refused and if we see the system

348
00:17:00,820 --> 00:17:02,320
partition we see that we have a to gunk

349
00:17:02,320 --> 00:17:04,780
file at the bottom here and it is a

350
00:17:04,780 --> 00:17:07,900
sweet file and we can read the f-stop

351
00:17:07,900 --> 00:17:09,280
which is only accessible to watch

352
00:17:09,280 --> 00:17:12,459
processes again we just connect to the

353
00:17:12,459 --> 00:17:16,720
service and we are buying a suit who am

354
00:17:16,720 --> 00:17:20,650
i think also yeah cool so that was a

355
00:17:20,650 --> 00:17:23,770
limo three seconds exploit and again for

356
00:17:23,770 --> 00:17:25,959
more details for how ideas just come at

357
00:17:25,959 --> 00:17:28,680
me after the presentation

358
00:17:28,680 --> 00:17:31,360
another very disappointing point about

359
00:17:31,360 --> 00:17:32,980
the disclosure process of this

360
00:17:32,980 --> 00:17:37,180
vulnerability we reported it back in the

361
00:17:37,180 --> 00:17:42,010
beginning of February 2016 a week later

362
00:17:42,010 --> 00:17:44,110
confirmed confirm the vulnerability and

363
00:17:44,110 --> 00:17:47,080
release the patch in the end of April

364
00:17:47,080 --> 00:17:49,210
when I say release the patch I mean a

365
00:17:49,210 --> 00:17:50,950
public test so everyone can see the

366
00:17:50,950 --> 00:17:54,730
vulnerability but still it took four

367
00:17:54,730 --> 00:17:57,640
months four months till it was actually

368
00:17:57,640 --> 00:18:00,460
fixed on the most selective devices of

369
00:18:00,460 --> 00:18:02,410
Google so four months for hackers to

370
00:18:02,410 --> 00:18:06,910
exploit it and nothing prevented them

371
00:18:06,910 --> 00:18:11,770
from doing this ok another case but now

372
00:18:11,770 --> 00:18:14,260
before we go to the next case we have to

373
00:18:14,260 --> 00:18:17,050
talk 30 seconds about a mechanism called

374
00:18:17,050 --> 00:18:20,350
IDR so IDR is the Linux kernel mechanism

375
00:18:20,350 --> 00:18:25,180
and it it allows a mapping between safe

376
00:18:25,180 --> 00:18:28,330
IDs that's how I call them safe IDs and

377
00:18:28,330 --> 00:18:30,670
kernel objects we need that because if

378
00:18:30,670 --> 00:18:32,650
we want to give the user mode agenda to

379
00:18:32,650 --> 00:18:35,020
some objects we don't want to reveal the

380
00:18:35,020 --> 00:18:36,700
kernel address for the act so we just

381
00:18:36,700 --> 00:18:39,430
use the MEK this mechanism so how how it

382
00:18:39,430 --> 00:18:42,580
works in de facto these are ones to

383
00:18:42,580 --> 00:18:45,790
create a an object a kernel object the

384
00:18:45,790 --> 00:18:48,010
kernel allocates data and initializes an

385
00:18:48,010 --> 00:18:51,460
object so it has a channel address but

386
00:18:51,460 --> 00:18:53,260
we don't want to reveal this address to

387
00:18:53,260 --> 00:18:56,050
the user so we just pass this address to

388
00:18:56,050 --> 00:18:58,660
the IDR mechanism get our mechanism now

389
00:18:58,660 --> 00:19:01,120
maps between these kernel address and

390
00:19:01,120 --> 00:19:04,330
just a safe number and this safe number

391
00:19:04,330 --> 00:19:06,580
is returned to the user and every time

392
00:19:06,580 --> 00:19:09,190
Duty we want to refer these objects

393
00:19:09,190 --> 00:19:12,100
perform comment on it or whatever it

394
00:19:12,100 --> 00:19:14,110
will just send the colonel this number

395
00:19:14,110 --> 00:19:18,760
so it's very easy to use that and very -

396
00:19:18,760 --> 00:19:23,230
very useful so with that said let's see

397
00:19:23,230 --> 00:19:27,220
the last module that were going to see

398
00:19:27,220 --> 00:19:27,640
today

399
00:19:27,640 --> 00:19:31,120
- vulnerabilities in this model and the

400
00:19:31,120 --> 00:19:32,920
model is called cage a cell or kennel

401
00:19:32,920 --> 00:19:35,500
graphic support layer written by welcome

402
00:19:35,500 --> 00:19:37,600
to supports on graphic stuffs and

403
00:19:37,600 --> 00:19:41,710
vulnerabilities it is a wrapper to the

404
00:19:41,710 --> 00:19:44,740
GPU driver the advil driver and it

405
00:19:44,740 --> 00:19:47,380
communicates with the user mode and to

406
00:19:47,380 --> 00:19:49,930
render graphics now let's see the actual

407
00:19:49,930 --> 00:19:52,840
attack surface here and first of all it

408
00:19:52,840 --> 00:19:54,280
is accessible funny and privileges

409
00:19:54,280 --> 00:19:54,870
application

410
00:19:54,870 --> 00:19:56,970
even now because it's graphics and

411
00:19:56,970 --> 00:19:59,160
graphics of cool and everyone loves

412
00:19:59,160 --> 00:20:03,390
graphics so we open it using the

413
00:20:03,390 --> 00:20:06,840
stopping a device called kgs L - a - 3d

414
00:20:06,840 --> 00:20:10,320
0 no permissions are needed and it has

415
00:20:10,320 --> 00:20:11,490
26

416
00:20:11,490 --> 00:20:13,830
I hope tails which are apples to the

417
00:20:13,830 --> 00:20:18,360
adrenal and adviser so let's see how it

418
00:20:18,360 --> 00:20:21,900
works this is just a part from the table

419
00:20:21,900 --> 00:20:23,640
I took from the axis I hope today I will

420
00:20:23,640 --> 00:20:26,600
talk stable I showed it for brevity but

421
00:20:26,600 --> 00:20:29,490
you can see that it's very simple to

422
00:20:29,490 --> 00:20:32,370
find the appropriate function from

423
00:20:32,370 --> 00:20:34,559
dioctyl and let's take for example

424
00:20:34,559 --> 00:20:37,830
drowse CTX create which creates a new

425
00:20:37,830 --> 00:20:40,110
context in the system we'll see that

426
00:20:40,110 --> 00:20:44,010
this function and receives a command and

427
00:20:44,010 --> 00:20:47,070
data data is completely controllable by

428
00:20:47,070 --> 00:20:49,710
the user it is not user mode address but

429
00:20:49,710 --> 00:20:52,200
it is just copied from the user and we

430
00:20:52,200 --> 00:20:54,390
see that eventually it takes the flags

431
00:20:54,390 --> 00:20:57,510
from our user parameters and it goes to

432
00:20:57,510 --> 00:20:59,820
it calls another function called draw

433
00:20:59,820 --> 00:21:03,600
city X create in F stable what is a

434
00:21:03,600 --> 00:21:05,940
stable a stable is the add value

435
00:21:05,940 --> 00:21:08,010
function table and we can see that there

436
00:21:08,010 --> 00:21:10,860
is a corresponding function and from the

437
00:21:10,860 --> 00:21:14,460
F table from here so here we eventually

438
00:21:14,460 --> 00:21:16,200
all the functions that we have in kg

439
00:21:16,200 --> 00:21:18,420
cell are just rappers - most of them are

440
00:21:18,420 --> 00:21:21,420
just rappers - a design of func a table

441
00:21:21,420 --> 00:21:23,850
and to convince you that this is a very

442
00:21:23,850 --> 00:21:27,210
unsafe mechanism the two vulnerabilities

443
00:21:27,210 --> 00:21:29,940
that we found didn't he didn't even we

444
00:21:29,940 --> 00:21:31,860
didn't even have to go to the Advent and

445
00:21:31,860 --> 00:21:34,650
visor they were just in the water in

446
00:21:34,650 --> 00:21:37,890
wrapping of the user mode parameter so

447
00:21:37,890 --> 00:21:40,410
our first vulnerability we call it in

448
00:21:40,410 --> 00:21:42,690
cocoa route the vulnerability is in in

449
00:21:42,690 --> 00:21:45,150
an object called sync source it is used

450
00:21:45,150 --> 00:21:47,400
to synchronize between the GPU and

451
00:21:47,400 --> 00:21:50,160
currently running application absolutely

452
00:21:50,160 --> 00:21:52,320
themselves it is usually wrapped by our

453
00:21:52,320 --> 00:21:56,100
graphic engines like OpenGL and soon by

454
00:21:56,100 --> 00:22:00,050
WebGL a 2.0 which means we could have

455
00:22:00,050 --> 00:22:02,700
two wheels late if we would find it in

456
00:22:02,700 --> 00:22:05,010
two years you could have had remotes to

457
00:22:05,010 --> 00:22:07,140
the channels from the web now we don't

458
00:22:07,140 --> 00:22:08,610
have to know a lot about the app

459
00:22:08,610 --> 00:22:10,559
to understand the vulnerability we just

460
00:22:10,559 --> 00:22:11,820
have to know how to create it and

461
00:22:11,820 --> 00:22:14,610
destroy it and as you saw before with

462
00:22:14,610 --> 00:22:16,770
the idea mechanism at the idea mechanism

463
00:22:16,770 --> 00:22:19,320
this object is referent referenced by

464
00:22:19,320 --> 00:22:23,040
this safe ID so that's the function that

465
00:22:23,040 --> 00:22:26,610
destroys the object theydo cleans it up

466
00:22:26,610 --> 00:22:30,330
and as you can see here and the user as

467
00:22:30,330 --> 00:22:32,640
I said before the users controls the

468
00:22:32,640 --> 00:22:35,970
data for a pointer so we use the

469
00:22:35,970 --> 00:22:40,470
controls this poem ID and what this

470
00:22:40,470 --> 00:22:42,809
function does is first checking whether

471
00:22:42,809 --> 00:22:45,540
this is a real object in the system by

472
00:22:45,540 --> 00:22:48,090
calling cage assessing source gets and

473
00:22:48,090 --> 00:22:51,330
then if it is if there is a sink sauce

474
00:22:51,330 --> 00:22:54,000
it drops the restaurant twice why twice

475
00:22:54,000 --> 00:22:56,700
once for the creation and once again

476
00:22:56,700 --> 00:22:59,730
because this also takes reference so how

477
00:22:59,730 --> 00:23:01,919
does it look let's say that the rest of

478
00:23:01,919 --> 00:23:03,980
the reference count of the object is 1

479
00:23:03,980 --> 00:23:06,720
this function increases the rest one by

480
00:23:06,720 --> 00:23:09,090
one so another of can be stool and then

481
00:23:09,090 --> 00:23:10,890
it is wrote one for the creation and

482
00:23:10,890 --> 00:23:12,750
once because we took a reference here

483
00:23:12,750 --> 00:23:17,840
and then the object is freed but this

484
00:23:17,840 --> 00:23:21,929
six lines of code are vulnerable to a

485
00:23:21,929 --> 00:23:27,299
race condition there is no pending a

486
00:23:27,299 --> 00:23:28,919
pending check and there is no check that

487
00:23:28,919 --> 00:23:32,360
the object is about to be freed so and

488
00:23:32,360 --> 00:23:35,190
what happens if two threads call this

489
00:23:35,190 --> 00:23:37,919
function at the same time and we have an

490
00:23:37,919 --> 00:23:40,200
object with the ref count one and we

491
00:23:40,200 --> 00:23:42,929
just call this destroy I octal with the

492
00:23:42,929 --> 00:23:46,410
same ID two different effort so first

493
00:23:46,410 --> 00:23:49,220
add the ref count is increased to two

494
00:23:49,220 --> 00:23:51,419
the entry of count is dropped back to

495
00:23:51,419 --> 00:23:54,179
one then there is a context which if it

496
00:23:54,179 --> 00:23:55,850
we also increased the ref one by one

497
00:23:55,850 --> 00:23:59,910
drops it again going back to a the

498
00:23:59,910 --> 00:24:02,220
debrief cond is dropped to zero and at

499
00:24:02,220 --> 00:24:04,860
this point the object is freeze and

500
00:24:04,860 --> 00:24:07,200
reclaim able by any of your favorites

501
00:24:07,200 --> 00:24:10,710
heap can hit cons playing techniques but

502
00:24:10,710 --> 00:24:13,350
12e is not done yet so we are going back

503
00:24:13,350 --> 00:24:15,690
to Fred B which now drops the ref count

504
00:24:15,690 --> 00:24:19,860
a on a free memory so here we can either

505
00:24:19,860 --> 00:24:22,080
just drop a reference for one

506
00:24:22,080 --> 00:24:25,260
for objects or we can get the system to

507
00:24:25,260 --> 00:24:27,480
destroy a different object and maybe

508
00:24:27,480 --> 00:24:30,000
control the destructive flow to get code

509
00:24:30,000 --> 00:24:33,120
execution now again to summarize it the

510
00:24:33,120 --> 00:24:35,250
very simple vulnerability we create the

511
00:24:35,250 --> 00:24:37,230
stings of objects we know the idea

512
00:24:37,230 --> 00:24:39,840
number two first destroying the idea

513
00:24:39,840 --> 00:24:42,539
this object the radicand is reduced to

514
00:24:42,539 --> 00:24:46,649
minus 1 and just after all once it is on

515
00:24:46,649 --> 00:24:49,679
zero and we can just exploit the killer

516
00:24:49,679 --> 00:24:54,419
memory and have user softly okay the

517
00:24:54,419 --> 00:24:58,980
closure so here it was reasonable we

518
00:24:58,980 --> 00:25:02,070
reported it in the photo fourth of April

519
00:25:02,070 --> 00:25:04,950
and one month later Qualcomm confirmed

520
00:25:04,950 --> 00:25:07,679
the vulnerability and one more fighter

521
00:25:07,679 --> 00:25:10,409
they released a public patch and on the

522
00:25:10,409 --> 00:25:11,220
same day

523
00:25:11,220 --> 00:25:15,179
Google deployed it so that devices not

524
00:25:15,179 --> 00:25:17,960
the best story not the best release but

525
00:25:17,960 --> 00:25:21,710
reasonable okay now the last

526
00:25:21,710 --> 00:25:24,450
vulnerability and the same mechanism

527
00:25:24,450 --> 00:25:26,519
again the cages cell mechanism we didn't

528
00:25:26,519 --> 00:25:29,779
even get to the advent one the last

529
00:25:29,779 --> 00:25:32,630
vulnerability is called kangaroos and

530
00:25:32,630 --> 00:25:35,730
the vulnerability is in mapping between

531
00:25:35,730 --> 00:25:40,169
user day user mode data to GPU day a

532
00:25:40,169 --> 00:25:43,320
data the edge GPU memory story each time

533
00:25:43,320 --> 00:25:46,470
we map a data it is referenced by the

534
00:25:46,470 --> 00:25:49,080
idea mechanism and an object that

535
00:25:49,080 --> 00:25:51,240
represents our mapping is also created

536
00:25:51,240 --> 00:25:53,340
it represents the range of the mapping

537
00:25:53,340 --> 00:25:57,169
the protection level will count and are

538
00:25:57,169 --> 00:26:01,169
not interesting stuff so after we found

539
00:26:01,169 --> 00:26:04,039
some cocoa to say okay let's go to the

540
00:26:04,039 --> 00:26:07,409
cleanup function maybe you can also find

541
00:26:07,409 --> 00:26:09,480
the vulnerability there and then we saw

542
00:26:09,480 --> 00:26:12,029
this again you can see the user control

543
00:26:12,029 --> 00:26:16,590
the data and again by there is an ID for

544
00:26:16,590 --> 00:26:19,620
the idea mechanism and we see that if

545
00:26:19,620 --> 00:26:22,919
there is a if there is an entry just

546
00:26:22,919 --> 00:26:25,049
cleans it up now we were happy because

547
00:26:25,049 --> 00:26:27,510
you didn't see any spin lock or

548
00:26:27,510 --> 00:26:29,490
something like that and then we went to

549
00:26:29,490 --> 00:26:32,669
share my free entry and unfortunately

550
00:26:32,669 --> 00:26:36,090
they will know right this time

551
00:26:36,090 --> 00:26:38,280
so here every time we call it the story

552
00:26:38,280 --> 00:26:41,520
on one of these objects first atomically

553
00:26:41,520 --> 00:26:44,340
it gets some field and it swaps it with

554
00:26:44,340 --> 00:26:47,460
yes and no it's the opposite to a value

555
00:26:47,460 --> 00:26:49,800
and then only once it drops to refcon

556
00:26:49,800 --> 00:26:52,860
twice and again since this function in

557
00:26:52,860 --> 00:26:55,530
this function takes the ref count on the

558
00:26:55,530 --> 00:26:59,610
object now it is dropped here but it

559
00:26:59,610 --> 00:27:03,000
will only be cleaned up once so they

560
00:27:03,000 --> 00:27:04,860
load it appropriately and no

561
00:27:04,860 --> 00:27:08,280
vulnerability here and in a desperation

562
00:27:08,280 --> 00:27:10,740
we said maybe the allocation function is

563
00:27:10,740 --> 00:27:14,970
vulnerable somehow and then we so we

564
00:27:14,970 --> 00:27:17,100
went to the allocation function so the

565
00:27:17,100 --> 00:27:19,650
way we map the data first we met we

566
00:27:19,650 --> 00:27:23,100
initialize the objects the W objects

567
00:27:23,100 --> 00:27:25,170
that represent the mapping then they

568
00:27:25,170 --> 00:27:28,640
call kgs mm mm entry at each process

569
00:27:28,640 --> 00:27:31,740
entry is the the object that represents

570
00:27:31,740 --> 00:27:34,620
the mapping and then it fills us

571
00:27:34,620 --> 00:27:37,440
associated with an ideal number then it

572
00:27:37,440 --> 00:27:40,530
just maps it to the process and here

573
00:27:40,530 --> 00:27:43,560
just like before and we didn't see any

574
00:27:43,560 --> 00:27:46,050
spin lock and there is a problem because

575
00:27:46,050 --> 00:27:49,830
if we call at this point at this point

576
00:27:49,830 --> 00:27:52,080
after the idea log this object is

577
00:27:52,080 --> 00:27:53,940
already referenceable from out of

578
00:27:53,940 --> 00:27:56,430
threads that means that at this point we

579
00:27:56,430 --> 00:27:59,190
can already call the cleanup function

580
00:27:59,190 --> 00:28:03,870
and then this entire code right normal

581
00:28:03,870 --> 00:28:06,720
here this entire code is going to call

582
00:28:06,720 --> 00:28:08,640
it with you it is going to call it

583
00:28:08,640 --> 00:28:10,890
reduce the entry object even though it

584
00:28:10,890 --> 00:28:14,630
might be already freed at this point so

585
00:28:14,630 --> 00:28:17,220
let's see the normal use case of this

586
00:28:17,220 --> 00:28:18,000
object

587
00:28:18,000 --> 00:28:21,510
first of all a thread a Maps data to the

588
00:28:21,510 --> 00:28:24,300
GPU so the kernel allocates objects were

589
00:28:24,300 --> 00:28:27,600
present snapping then it associates it

590
00:28:27,600 --> 00:28:30,390
with an ID our number with our value

591
00:28:30,390 --> 00:28:34,200
then it initializes the object then if

592
00:28:34,200 --> 00:28:36,300
you want to UM map to unmapped

593
00:28:36,300 --> 00:28:40,710
a this memory we just call and we just

594
00:28:40,710 --> 00:28:42,960
call the risk I have tell the colonel

595
00:28:42,960 --> 00:28:45,510
checks where this ID is already in the

596
00:28:45,510 --> 00:28:48,630
system and if it is it simply

597
00:28:48,630 --> 00:28:51,510
simple it simply freeze it from the

598
00:28:51,510 --> 00:28:55,470
channel but as I said before if this is

599
00:28:55,470 --> 00:28:57,570
our current situation we know that our

600
00:28:57,570 --> 00:29:00,120
next number is going to be six here so

601
00:29:00,120 --> 00:29:02,850
we can call on the same time map in

602
00:29:02,850 --> 00:29:05,310
unmapped so first you just map data and

603
00:29:05,310 --> 00:29:09,240
an object is allocated it is maps to the

604
00:29:09,240 --> 00:29:12,780
idea items but then we unmet the data

605
00:29:12,780 --> 00:29:16,050
before it is already initialized so they

606
00:29:16,050 --> 00:29:17,640
can detect where the number six is

607
00:29:17,640 --> 00:29:19,890
already in the system

608
00:29:19,890 --> 00:29:21,660
and since it since it is already in the

609
00:29:21,660 --> 00:29:25,560
system it just freezes from the oh it

610
00:29:25,560 --> 00:29:28,020
just a freezes the memory like a free

611
00:29:28,020 --> 00:29:30,740
and at this point this is a reclaimer

612
00:29:30,740 --> 00:29:34,140
later this is a reclaim herbal scramble

613
00:29:34,140 --> 00:29:36,360
update data we can spray the killer heap

614
00:29:36,360 --> 00:29:39,300
and catch it but Fred a did not finish

615
00:29:39,300 --> 00:29:41,940
it and now it will operate on free data

616
00:29:41,940 --> 00:29:43,920
which you control and we can manipulate

617
00:29:43,920 --> 00:29:46,500
to elevate our privileges and compromise

618
00:29:46,500 --> 00:29:52,820
the system so again a summary of this

619
00:29:52,820 --> 00:29:56,910
summary of this vulnerability

620
00:29:56,910 --> 00:29:59,700
first we map memory then we know which

621
00:29:59,700 --> 00:30:02,130
idea number we are going to get so we

622
00:30:02,130 --> 00:30:04,710
three we are going to issue

623
00:30:04,710 --> 00:30:07,320
I am mapping request and uh nothing

624
00:30:07,320 --> 00:30:09,930
request on and cannulate on two

625
00:30:09,930 --> 00:30:12,480
different threads and before the mapping

626
00:30:12,480 --> 00:30:14,940
mapper thread is done a return from the

627
00:30:14,940 --> 00:30:17,070
camera mode we are going to have users

628
00:30:17,070 --> 00:30:19,440
two three case in the function on the

629
00:30:19,440 --> 00:30:22,830
entry parameter and the picture of a

630
00:30:22,830 --> 00:30:26,070
drunken group okay

631
00:30:26,070 --> 00:30:29,250
again this closure M it adds closure

632
00:30:29,250 --> 00:30:34,020
procedure we reported the vulnerability

633
00:30:34,020 --> 00:30:36,840
at the same time in fourth of April to

634
00:30:36,840 --> 00:30:39,150
Qualcomm and they confirmed it on the

635
00:30:39,150 --> 00:30:42,300
second of May and kokum worries it's

636
00:30:42,300 --> 00:30:44,370
they on the same time within cocoa roots

637
00:30:44,370 --> 00:30:47,400
on the 6th of July but for some reason

638
00:30:47,400 --> 00:30:50,460
Google fixed it only I want one month

639
00:30:50,460 --> 00:30:53,490
later on the first of August why we

640
00:30:53,490 --> 00:30:57,240
don't know what and now we created an

641
00:30:57,240 --> 00:30:59,340
app in check point that checks whether

642
00:30:59,340 --> 00:31:02,279
you you are vulnerable to any of this

643
00:31:02,279 --> 00:31:05,429
vulnerabilities more than half a million

644
00:31:05,429 --> 00:31:08,690
downloads happened in just one month and

645
00:31:08,690 --> 00:31:11,879
we got we got some users could opt in to

646
00:31:11,879 --> 00:31:14,789
send us some anonymous data and the

647
00:31:14,789 --> 00:31:16,889
statistics were taken in mid-august and

648
00:31:16,889 --> 00:31:19,229
we're all and at this time all the

649
00:31:19,229 --> 00:31:21,859
vulnerabilities were already public and

650
00:31:21,859 --> 00:31:27,179
that's the information we saw so 63% of

651
00:31:27,179 --> 00:31:29,700
the devices or vulnerable to at least

652
00:31:29,700 --> 00:31:32,639
one of these vulnerabilities again this

653
00:31:32,639 --> 00:31:35,159
reveals a very bad situation where

654
00:31:35,159 --> 00:31:38,070
classic user to feel vulnerabilities a

655
00:31:38,070 --> 00:31:40,799
public while not patched on most of the

656
00:31:40,799 --> 00:31:44,039
device in the world we had we take your

657
00:31:44,039 --> 00:31:45,859
into consideration device into these

658
00:31:45,859 --> 00:31:48,749
statistics devices that were not

659
00:31:48,749 --> 00:31:50,969
vulnerable from the first place like

660
00:31:50,969 --> 00:31:52,979
media tech devices that is didn't have

661
00:31:52,979 --> 00:31:55,289
the Qualcomm code so the number of the

662
00:31:55,289 --> 00:31:58,139
vulnerable devices that successfully

663
00:31:58,139 --> 00:32:00,479
received the patch is probably even

664
00:32:00,479 --> 00:32:04,919
lower and next to interesting

665
00:32:04,919 --> 00:32:08,070
information a number of vulnerable

666
00:32:08,070 --> 00:32:12,450
devices for each vulnerability and this

667
00:32:12,450 --> 00:32:14,909
is the first one we shot we saw with the

668
00:32:14,909 --> 00:32:17,210
Ashman these are the two cages

669
00:32:17,210 --> 00:32:19,769
vulnerabilities and this is the one with

670
00:32:19,769 --> 00:32:23,519
the IPC and as you can see I bet the

671
00:32:23,519 --> 00:32:26,070
reported the vulnerabilities back in

672
00:32:26,070 --> 00:32:29,549
April for the for the booth free and for

673
00:32:29,549 --> 00:32:33,570
the equal about one the IPC over a

674
00:32:33,570 --> 00:32:37,499
router was reported in February still

675
00:32:37,499 --> 00:32:39,869
half a year later almost half of the

676
00:32:39,869 --> 00:32:42,779
market is vulnerable to the koala owner

677
00:32:42,779 --> 00:32:47,669
ability again I mean it's not supposed

678
00:32:47,669 --> 00:32:49,619
to be it isn't supposed to take so much

679
00:32:49,619 --> 00:32:50,039
time

680
00:32:50,039 --> 00:32:53,580
especially when public patch by patches

681
00:32:53,580 --> 00:32:55,909
by Qualcomm are already available and

682
00:32:55,909 --> 00:33:00,869
the last piece of information this

683
00:33:00,869 --> 00:33:02,789
actually does it have to do with the for

684
00:33:02,789 --> 00:33:05,759
vulnerabilities we saw here but we can

685
00:33:05,759 --> 00:33:08,969
see just and this this this is just

686
00:33:08,969 --> 00:33:10,679
based on half more than half a million

687
00:33:10,679 --> 00:33:14,879
devices in mid-august less than 10% of

688
00:33:14,879 --> 00:33:15,509
the market

689
00:33:15,509 --> 00:33:16,200
head

690
00:33:16,200 --> 00:33:20,159
the latest batch and if we look just to

691
00:33:20,159 --> 00:33:24,509
may May 2016 we see that more at Lee a

692
00:33:24,509 --> 00:33:27,029
sorry if you look free month before

693
00:33:27,029 --> 00:33:28,710
August we see that most of the market

694
00:33:28,710 --> 00:33:31,320
did not even receive the security pass

695
00:33:31,320 --> 00:33:35,369
now this is it just means that I mean

696
00:33:35,369 --> 00:33:37,980
this has to be changed all this entire

697
00:33:37,980 --> 00:33:41,330
purge mechanism and with that said and

698
00:33:41,330 --> 00:33:44,580
suggestions first of all the supply

699
00:33:44,580 --> 00:33:47,519
chain of Android prevents actually

700
00:33:47,519 --> 00:33:49,529
prevents security patches from being

701
00:33:49,529 --> 00:33:52,109
distributed efficiently to the influent

702
00:33:52,109 --> 00:33:54,840
user a chipset vulnerability is

703
00:33:54,840 --> 00:33:57,419
extremely important in the case because

704
00:33:57,419 --> 00:34:00,059
every window has to adapt and to this

705
00:34:00,059 --> 00:34:03,320
view distributed on is own secondly

706
00:34:03,320 --> 00:34:05,940
sending security patches to the device

707
00:34:05,940 --> 00:34:08,730
once a month is not ideal once the

708
00:34:08,730 --> 00:34:10,980
device is infected is the vulnerable

709
00:34:10,980 --> 00:34:12,780
sorry and the attacker doesn't

710
00:34:12,780 --> 00:34:15,329
necessarily have to exploit the

711
00:34:15,329 --> 00:34:17,059
vulnerability again and again

712
00:34:17,059 --> 00:34:20,460
out-of-band patches are seen often in

713
00:34:20,460 --> 00:34:23,250
other platforms like and windows and

714
00:34:23,250 --> 00:34:25,619
even by iOS which is also a mobile

715
00:34:25,619 --> 00:34:29,369
platform and finally I want to address

716
00:34:29,369 --> 00:34:31,139
something that appeared a lot on the

717
00:34:31,139 --> 00:34:32,609
media following the release of this

718
00:34:32,609 --> 00:34:37,530
research verify apps so will oil verify

719
00:34:37,530 --> 00:34:40,049
apps doesn't harm your device it

720
00:34:40,049 --> 00:34:41,879
requires a lot of collaboration with

721
00:34:41,879 --> 00:34:45,449
Google to work appropriately we also are

722
00:34:45,449 --> 00:34:47,629
the publication of these vulnerabilities

723
00:34:47,629 --> 00:34:50,520
verify apps did not or any other

724
00:34:50,520 --> 00:34:53,179
built-in mechanism cqt mechanism in

725
00:34:53,179 --> 00:34:56,520
android did not detect any of these bugs

726
00:34:56,520 --> 00:34:59,309
it takes a lot of time and nice amount

727
00:34:59,309 --> 00:35:01,730
of efforts to actually distribute this

728
00:35:01,730 --> 00:35:04,290
protection of the devices and it

729
00:35:04,290 --> 00:35:06,390
requires Google to have cooperation with

730
00:35:06,390 --> 00:35:06,780
us

731
00:35:06,780 --> 00:35:10,020
so verify apps is not a magic mechanism

732
00:35:10,020 --> 00:35:12,690
that protects ads it just it requires a

733
00:35:12,690 --> 00:35:15,510
lot of work to actually prevent new

734
00:35:15,510 --> 00:35:19,470
threat and that's it I hope you enjoy

735
00:35:19,470 --> 00:35:20,670
the presentation and got some new

736
00:35:20,670 --> 00:35:23,790
insight and if you have any question

737
00:35:23,790 --> 00:35:26,099
about anything since this is the last

738
00:35:26,099 --> 00:35:27,200
presentation

739
00:35:27,200 --> 00:35:29,329
for today we'll do it outside because

740
00:35:29,329 --> 00:35:32,780
the people negative talk clear oh thank

741
00:35:32,780 --> 00:35:33,110
you

742
00:35:33,110 --> 00:35:39,630
[Applause]

