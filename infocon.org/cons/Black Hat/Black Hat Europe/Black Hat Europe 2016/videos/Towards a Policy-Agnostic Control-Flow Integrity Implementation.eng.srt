1
00:00:00,030 --> 00:00:04,170
okay so good afternoon everyone welcome

2
00:00:04,170 --> 00:00:07,350
to our session this talk is about a hard

3
00:00:07,350 --> 00:00:09,870
hard way are supported control for

4
00:00:09,870 --> 00:00:14,250
integrity we name it as policy agnostic

5
00:00:14,250 --> 00:00:16,650
control flow integrity this is not a new

6
00:00:16,650 --> 00:00:18,900
topic but it's been a very hot topic

7
00:00:18,900 --> 00:00:21,900
recently so we trying to tell you more

8
00:00:21,900 --> 00:00:24,330
of our research outcome in this area

9
00:00:24,330 --> 00:00:27,930
especially to involve hardware in the

10
00:00:27,930 --> 00:00:33,120
whole scenario so before the talk I

11
00:00:33,120 --> 00:00:35,820
would like to introduce myself and the

12
00:00:35,820 --> 00:00:36,989
other two speakers

13
00:00:36,989 --> 00:00:39,660
my name is Eugene and I'm from

14
00:00:39,660 --> 00:00:42,390
University of Central Florida I'm also a

15
00:00:42,390 --> 00:00:44,750
researcher in the cyber immunity lab and

16
00:00:44,750 --> 00:00:47,910
the other two speakers one is in

17
00:00:47,910 --> 00:00:50,100
Sullivan and the other Orlando areas

18
00:00:50,100 --> 00:00:51,870
they all from the University of Central

19
00:00:51,870 --> 00:00:54,480
Florida and you can tell that we wear

20
00:00:54,480 --> 00:00:58,829
all the codes we have because in we

21
00:00:58,829 --> 00:01:00,539
build in Florida for too long we almost

22
00:01:00,539 --> 00:01:05,760
forget how to survive in winter so going

23
00:01:05,760 --> 00:01:08,659
through this talk though this is a

24
00:01:08,659 --> 00:01:13,920
high-level outline of our talk so we

25
00:01:13,920 --> 00:01:15,619
will introduce the motivation and the

26
00:01:15,619 --> 00:01:18,900
run time attacks and also then we will

27
00:01:18,900 --> 00:01:22,200
discuss the defense against the code

28
00:01:22,200 --> 00:01:24,960
reuse attacks and then our work in

29
00:01:24,960 --> 00:01:27,840
hardware design requirement and the core

30
00:01:27,840 --> 00:01:30,990
part of the policy agnostic CFI control

31
00:01:30,990 --> 00:01:35,780
flow integrity so before I'm going

32
00:01:35,780 --> 00:01:42,750
inside the we will not change oh good so

33
00:01:42,750 --> 00:01:47,250
before we introduce the key technology

34
00:01:47,250 --> 00:01:50,549
key techniques so we want to discuss the

35
00:01:50,549 --> 00:01:52,470
motivation the motivation is that the

36
00:01:52,470 --> 00:01:54,329
high-level motivation is very simple we

37
00:01:54,329 --> 00:01:57,240
want to protect all the native code

38
00:01:57,240 --> 00:02:00,540
so one thing we want to discuss first is

39
00:02:00,540 --> 00:02:03,329
that we have been for many decades of

40
00:02:03,329 --> 00:02:06,920
runtime attack the arm raise and

41
00:02:06,920 --> 00:02:09,899
starting from the 1988 at the first

42
00:02:09,899 --> 00:02:12,720
internet forum and then we have the code

43
00:02:12,720 --> 00:02:13,800
inject a care

44
00:02:13,800 --> 00:02:16,800
return to Liberty attack and Ayana and

45
00:02:16,800 --> 00:02:20,700
then in 2007 they come to the return

46
00:02:20,700 --> 00:02:22,800
oriented programming it's kind of like

47
00:02:22,800 --> 00:02:25,770
open a new arena for the attack and

48
00:02:25,770 --> 00:02:28,020
defense and the multiple defense

49
00:02:28,020 --> 00:02:30,060
solution has been proposed and they all

50
00:02:30,060 --> 00:02:32,160
begin bypassed and then new solution

51
00:02:32,160 --> 00:02:38,070
have been developed so even though it's

52
00:02:38,070 --> 00:02:41,550
been like decades in this area we still

53
00:02:41,550 --> 00:02:44,400
see a lot of very recent examples that

54
00:02:44,400 --> 00:02:48,920
people using this return or rent

55
00:02:48,920 --> 00:02:51,570
oriented programming or we call the

56
00:02:51,570 --> 00:02:54,690
color reuse attack to compromise our

57
00:02:54,690 --> 00:02:58,110
modern system and this is the 2013 case

58
00:02:58,110 --> 00:03:01,790
and we have a 2015 case in a black head

59
00:03:01,790 --> 00:03:04,470
presentation and even in this year's the

60
00:03:04,470 --> 00:03:09,350
cisco router exploit and the government

61
00:03:09,350 --> 00:03:12,300
kind of like trying to attack it a human

62
00:03:12,300 --> 00:03:16,470
rights group so everyone says that this

63
00:03:16,470 --> 00:03:18,510
area is a very interesting area it's

64
00:03:18,510 --> 00:03:21,900
been investigated for so long but we

65
00:03:21,900 --> 00:03:25,170
keep on finding some new weakness in our

66
00:03:25,170 --> 00:03:28,730
new defense solutions where people can

67
00:03:28,730 --> 00:03:34,739
bypass those defend solution and so

68
00:03:34,739 --> 00:03:38,280
again another high-level thing so that

69
00:03:38,280 --> 00:03:40,560
we want to see that of it we know that

70
00:03:40,560 --> 00:03:43,410
you see the high pack impact and we also

71
00:03:43,410 --> 00:03:46,830
not just academic the the industry also

72
00:03:46,830 --> 00:03:50,730
proposed so many solutions like these

73
00:03:50,730 --> 00:03:55,770
are a list of their tools provided but I

74
00:03:55,770 --> 00:03:59,760
mean very sadly that this method have

75
00:03:59,760 --> 00:04:01,920
already been through either can be

76
00:04:01,920 --> 00:04:06,060
bypassed or not sufficient enough so so

77
00:04:06,060 --> 00:04:08,459
this eventually as we said azam race is

78
00:04:08,459 --> 00:04:11,580
and very interesting attacking scenario

79
00:04:11,580 --> 00:04:15,720
that we keep on come up with new defense

80
00:04:15,720 --> 00:04:19,680
but new offense method seems even top of

81
00:04:19,680 --> 00:04:25,620
a factor so again this is we give a very

82
00:04:25,620 --> 00:04:27,510
high-level summary of

83
00:04:27,510 --> 00:04:29,580
would have already been proposed so

84
00:04:29,580 --> 00:04:31,350
people always ask oh this is a very hot

85
00:04:31,350 --> 00:04:33,570
area people proposed so many solutions

86
00:04:33,570 --> 00:04:36,300
and this is a very high-level summary

87
00:04:36,300 --> 00:04:39,530
from the first side we have so many CFI

88
00:04:39,530 --> 00:04:43,170
Rocard binds efi a bunch of them the

89
00:04:43,170 --> 00:04:45,810
some of them from academic some of them

90
00:04:45,810 --> 00:04:50,370
from industry however for a tech side we

91
00:04:50,370 --> 00:04:52,890
have so many attacks method also been

92
00:04:52,890 --> 00:04:56,540
proposed to either bypass or to

93
00:04:56,540 --> 00:04:59,430
compromise the whole protection solution

94
00:04:59,430 --> 00:05:03,990
so so up the decades of this M race we

95
00:05:03,990 --> 00:05:06,210
are still seeking practical and a secure

96
00:05:06,210 --> 00:05:10,410
solution and if this is the the I would

97
00:05:10,410 --> 00:05:12,150
say the beauty of cyber security

98
00:05:12,150 --> 00:05:14,790
research topic that some reason topic we

99
00:05:14,790 --> 00:05:16,980
may find as a fundamental solution but

100
00:05:16,980 --> 00:05:19,380
not on this one so that's why we keep on

101
00:05:19,380 --> 00:05:21,900
coming up with new idea and our research

102
00:05:21,900 --> 00:05:24,420
is trying to provide from hardware

103
00:05:24,420 --> 00:05:28,760
perspective some fundamental solution so

104
00:05:28,760 --> 00:05:34,020
going further discuss the water running

105
00:05:34,020 --> 00:05:40,260
time attack would be so first it's some

106
00:05:40,260 --> 00:05:41,880
like background just for your

107
00:05:41,880 --> 00:05:43,650
information if you already know that you

108
00:05:43,650 --> 00:05:45,270
can skip this slide so first thing is

109
00:05:45,270 --> 00:05:48,720
that we call a code inject attacks it

110
00:05:48,720 --> 00:05:50,640
was a coding Jack attack so we have

111
00:05:50,640 --> 00:05:54,450
basic blocks there and the attackers can

112
00:05:54,450 --> 00:05:57,780
leverage some of the design flaws for

113
00:05:57,780 --> 00:06:00,870
example like buffer overflow it's a very

114
00:06:00,870 --> 00:06:04,350
popular bug and then the attacker will

115
00:06:04,350 --> 00:06:07,290
interact a malicious coded there so then

116
00:06:07,290 --> 00:06:11,180
they will changes a control flow and

117
00:06:12,770 --> 00:06:16,200
22.2 the militias in java code so that

118
00:06:16,200 --> 00:06:19,800
they can do anything they want to

119
00:06:19,800 --> 00:06:22,020
compromise system but this has been

120
00:06:22,020 --> 00:06:24,570
protected nicely by a very simple

121
00:06:24,570 --> 00:06:27,570
solution the DEP the data executive

122
00:06:27,570 --> 00:06:30,900
prevention so then come up with a color

123
00:06:30,900 --> 00:06:34,280
reuse attack this time since the

124
00:06:34,280 --> 00:06:37,410
injected coder will not be exact it so

125
00:06:37,410 --> 00:06:39,420
the attacker will change in the control

126
00:06:39,420 --> 00:06:41,490
flow

127
00:06:41,490 --> 00:06:45,569
and reusing some existing code blocks

128
00:06:45,569 --> 00:06:49,979
via so in this way they can build up the

129
00:06:49,979 --> 00:06:52,530
functionality they don't really need to

130
00:06:52,530 --> 00:06:55,410
rely on any of the newly injected code

131
00:06:55,410 --> 00:06:58,229
but just a reusing the existing code but

132
00:06:58,229 --> 00:07:00,599
just to organize them in the malicious

133
00:07:00,599 --> 00:07:04,889
way so this is the official name is we

134
00:07:04,889 --> 00:07:08,039
call the return oriented programming or

135
00:07:08,039 --> 00:07:11,880
it's recorded be a prominent code of

136
00:07:11,880 --> 00:07:15,419
reuse attacks so and it helped been

137
00:07:15,419 --> 00:07:18,419
proved to be turing-complete so this is

138
00:07:18,419 --> 00:07:20,580
really like horrifying people because

139
00:07:20,580 --> 00:07:22,349
people sometime argue there are things

140
00:07:22,349 --> 00:07:25,319
you can only use existing code maybe you

141
00:07:25,319 --> 00:07:27,449
cannot do anything you want but people

142
00:07:27,449 --> 00:07:29,729
have to prove that ok turing-complete

143
00:07:29,729 --> 00:07:35,639
so before going tip of the the Rob

144
00:07:35,639 --> 00:07:38,250
attack here is some like basic steps

145
00:07:38,250 --> 00:07:40,860
that how you need to perform a Rob

146
00:07:40,860 --> 00:07:43,639
attack and a Thea is some of the

147
00:07:43,639 --> 00:07:45,659
terminology that we will use the iron

148
00:07:45,659 --> 00:07:48,620
arm of the returning structuring the

149
00:07:48,620 --> 00:07:51,750
basic block or the instruction sequence

150
00:07:51,750 --> 00:07:53,969
chain that we use in every gadget we

151
00:07:53,969 --> 00:07:57,630
combine them together so again so what's

152
00:07:57,630 --> 00:08:01,020
the thread model here so what are we

153
00:08:01,020 --> 00:08:04,530
really trying to protect here so in in

154
00:08:04,530 --> 00:08:08,509
our work we first assume that the

155
00:08:08,509 --> 00:08:13,650
application is protected by GDP and the

156
00:08:13,650 --> 00:08:16,380
attacker knows the memory layout it's

157
00:08:16,380 --> 00:08:19,500
transparent but what does attacker can

158
00:08:19,500 --> 00:08:22,409
do first the attack can disclose the

159
00:08:22,409 --> 00:08:26,400
readable memory and then the attacker

160
00:08:26,400 --> 00:08:29,580
can manipulate the writable memory so

161
00:08:29,580 --> 00:08:32,339
this is the baseline this is very like

162
00:08:32,339 --> 00:08:34,919
low request to attack that if the

163
00:08:34,919 --> 00:08:37,440
attacker have this capability then we

164
00:08:37,440 --> 00:08:39,630
believe that it's a reasonable attack

165
00:08:39,630 --> 00:08:43,469
model and then comes our solution that

166
00:08:43,469 --> 00:08:47,070
we want to defend against the code reuse

167
00:08:47,070 --> 00:08:51,920
attack and in would have pick this up

168
00:08:53,089 --> 00:08:56,250
okay so without you know belaboring the

169
00:08:56,250 --> 00:08:57,990
point just for some background

170
00:08:57,990 --> 00:08:59,910
information and completeness there's

171
00:08:59,910 --> 00:09:01,560
sort of two defenses against code reuse

172
00:09:01,560 --> 00:09:03,450
attacks and you can either apply

173
00:09:03,450 --> 00:09:06,200
randomization or control flow integrity

174
00:09:06,200 --> 00:09:08,670
randomization is a great defense because

175
00:09:08,670 --> 00:09:10,290
it has really low performance overhead

176
00:09:10,290 --> 00:09:13,500
and scales well with complex software

177
00:09:13,500 --> 00:09:15,750
like operating systems and browsers

178
00:09:15,750 --> 00:09:18,990
however it's vulnerable to information

179
00:09:18,990 --> 00:09:21,480
disclosure and requires a high amount of

180
00:09:21,480 --> 00:09:23,910
entropy from sort of some brute forcing

181
00:09:23,910 --> 00:09:26,610
style attack control so integrity on the

182
00:09:26,610 --> 00:09:28,199
other hand offers formal security

183
00:09:28,199 --> 00:09:31,440
guarantees but there's some trade-offs

184
00:09:31,440 --> 00:09:34,260
associated with The Associated analysis

185
00:09:34,260 --> 00:09:36,380
to build a control flow integrity policy

186
00:09:36,380 --> 00:09:39,420
that requires trade-offs and performance

187
00:09:39,420 --> 00:09:41,579
and security and it's also challenging

188
00:09:41,579 --> 00:09:44,850
to integrate a complex software and to

189
00:09:44,850 --> 00:09:47,519
cover completely a operating system

190
00:09:47,519 --> 00:09:51,990
overall randomization ultimately is

191
00:09:51,990 --> 00:09:54,300
vulnerable to memory leakage it's both

192
00:09:54,300 --> 00:09:56,220
direct and indirect memory disclosure

193
00:09:56,220 --> 00:09:58,740
will allow you to break sort of the most

194
00:09:58,740 --> 00:10:01,890
fine grain and Salar scheme to date and

195
00:10:01,890 --> 00:10:03,720
this is basically just reading a direct

196
00:10:03,720 --> 00:10:07,079
code pointer in a code page or leaking a

197
00:10:07,079 --> 00:10:08,459
code pointer from a data page it's just

198
00:10:08,459 --> 00:10:11,220
a stack or heap this is trivial to do

199
00:10:11,220 --> 00:10:12,600
and has been shown to be trivial to do

200
00:10:12,600 --> 00:10:15,480
in JIT style codes like in a browser in

201
00:10:15,480 --> 00:10:17,970
your firefox and our collaborators have

202
00:10:17,970 --> 00:10:20,640
sort of examined that extensively and

203
00:10:20,640 --> 00:10:22,529
shown that current randomization

204
00:10:22,529 --> 00:10:24,269
defenses or fine-grained randomization

205
00:10:24,269 --> 00:10:26,670
defenses are actually vulnerable to that

206
00:10:26,670 --> 00:10:27,990
so this is the current state of the art

207
00:10:27,990 --> 00:10:32,310
for randomization so we're going to go

208
00:10:32,310 --> 00:10:33,660
ahead and start talking about the

209
00:10:33,660 --> 00:10:35,819
requirements right so what you have to

210
00:10:35,819 --> 00:10:37,620
sort of solve if you want to build some

211
00:10:37,620 --> 00:10:40,949
hardware defense um but before we do

212
00:10:40,949 --> 00:10:42,209
that I just need to sort of get a

213
00:10:42,209 --> 00:10:43,949
baseline for everybody on what control

214
00:10:43,949 --> 00:10:46,199
file integrity ultimately is and it is

215
00:10:46,199 --> 00:10:47,910
effectively just restricting control

216
00:10:47,910 --> 00:10:51,779
flow to benign and correct targets and

217
00:10:51,779 --> 00:10:53,610
the intuition is very straightforward

218
00:10:53,610 --> 00:10:55,949
could reuse attacks divert control flow

219
00:10:55,949 --> 00:10:58,110
from benign and direct targets so

220
00:10:58,110 --> 00:11:01,319
presumably if I have a great CFI policy

221
00:11:01,319 --> 00:11:03,690
I'm going to be able to detect some

222
00:11:03,690 --> 00:11:06,570
control flow hijacking

223
00:11:06,570 --> 00:11:08,640
this is again approval e to correct

224
00:11:08,640 --> 00:11:10,530
security mechanism with a powerful

225
00:11:10,530 --> 00:11:13,350
attack model in the sense that I have I

226
00:11:13,350 --> 00:11:15,120
allow the attacker access to complete

227
00:11:15,120 --> 00:11:18,030
memory and allow him access to write up

228
00:11:18,030 --> 00:11:20,910
data pages that are writable and to read

229
00:11:20,910 --> 00:11:22,830
code pages so he can actually look at

230
00:11:22,830 --> 00:11:25,110
what sort of where functions are in the

231
00:11:25,110 --> 00:11:27,330
program space and so we sort of don't

232
00:11:27,330 --> 00:11:30,750
assume that randomization is in place it

233
00:11:30,750 --> 00:11:32,700
also provides deterministic protection

234
00:11:32,700 --> 00:11:37,530
at runtime so the basics are fairly

235
00:11:37,530 --> 00:11:39,120
straightforward we have two basic blocks

236
00:11:39,120 --> 00:11:41,010
and what we want to do is from the

237
00:11:41,010 --> 00:11:42,630
control flow graph we want to build a

238
00:11:42,630 --> 00:11:44,520
sort of labeling mechanism that

239
00:11:44,520 --> 00:11:47,220
determines where to and from these

240
00:11:47,220 --> 00:11:50,040
control flow box can redirect control so

241
00:11:50,040 --> 00:11:51,900
in this case we have this node label a

242
00:11:51,900 --> 00:11:54,720
and we're going to check at exit if it's

243
00:11:54,720 --> 00:11:58,200
targeting its intended of path otherwise

244
00:11:58,200 --> 00:11:59,970
it's going to throw an error if it

245
00:11:59,970 --> 00:12:02,220
targets a separate path of course the

246
00:12:02,220 --> 00:12:06,060
issue is that control flow and graph

247
00:12:06,060 --> 00:12:08,790
analysis is in general undecidable so

248
00:12:08,790 --> 00:12:10,950
what you do is you typically do what's

249
00:12:10,950 --> 00:12:12,930
called a points to analysis and this is

250
00:12:12,930 --> 00:12:17,070
conservative the intuition is that you

251
00:12:17,070 --> 00:12:20,310
don't want to and intentionally under

252
00:12:20,310 --> 00:12:22,500
approximate the control flow the points

253
00:12:22,500 --> 00:12:24,990
to analysis so that you have a more

254
00:12:24,990 --> 00:12:29,070
precise pointer set rather you're going

255
00:12:29,070 --> 00:12:31,140
to over approximate that to prevent

256
00:12:31,140 --> 00:12:33,660
breaking the program what this leads to

257
00:12:33,660 --> 00:12:36,270
though in terms of the issues with CFI

258
00:12:36,270 --> 00:12:37,980
is that the precision of the control

259
00:12:37,980 --> 00:12:40,080
flow graph analysis actually determines

260
00:12:40,080 --> 00:12:42,930
the security of a CFI policy so ideally

261
00:12:42,930 --> 00:12:44,490
we'd like every edge in the control flow

262
00:12:44,490 --> 00:12:47,250
graph to be unique so that you can't

263
00:12:47,250 --> 00:12:49,200
sort of arbitrarily redirect control or

264
00:12:49,200 --> 00:12:52,310
bin control flow within your CFI policy

265
00:12:52,310 --> 00:12:55,770
so as an example of this we can have

266
00:12:55,770 --> 00:12:57,840
some sort of static analysis that's flow

267
00:12:57,840 --> 00:13:00,300
and context sensitive where we can

268
00:13:00,300 --> 00:13:03,090
recover completely the intended control

269
00:13:03,090 --> 00:13:04,650
flow targets at a particular point

270
00:13:04,650 --> 00:13:07,980
however this requires a mini CFI check

271
00:13:07,980 --> 00:13:10,560
at that instrumentation point and

272
00:13:10,560 --> 00:13:12,120
basically is going to degrade

273
00:13:12,120 --> 00:13:13,440
performance overall

274
00:13:13,440 --> 00:13:16,020
so as an optimization step or a

275
00:13:16,020 --> 00:13:18,630
concession we merge these labels in this

276
00:13:18,630 --> 00:13:20,100
case four and five

277
00:13:20,100 --> 00:13:24,329
from node B so that we have a single

278
00:13:24,329 --> 00:13:26,100
label and we reduce the number of checks

279
00:13:26,100 --> 00:13:29,069
we have to perform after eat before each

280
00:13:29,069 --> 00:13:32,040
control flow transfer I mean ultimately

281
00:13:32,040 --> 00:13:35,730
this is going to this is an instance of

282
00:13:35,730 --> 00:13:38,130
where the CFG provision precision

283
00:13:38,130 --> 00:13:41,339
reduces the security because because an

284
00:13:41,339 --> 00:13:45,810
attacker can we redirect control flow to

285
00:13:45,810 --> 00:13:48,720
labels where the emerging has occurred

286
00:13:48,720 --> 00:13:51,690
in this case I can redirect control if I

287
00:13:51,690 --> 00:13:54,240
find some vulnerability within node C to

288
00:13:54,240 --> 00:13:57,540
node D or just back to node C again to

289
00:13:57,540 --> 00:14:00,449
come to perform some loop operation and

290
00:14:00,449 --> 00:14:04,139
my code reduce attack what we found is

291
00:14:04,139 --> 00:14:06,089
that a dynamic points to analysis

292
00:14:06,089 --> 00:14:08,540
actually kind of resolves this issue and

293
00:14:08,540 --> 00:14:11,310
what that effectively is is an estimate

294
00:14:11,310 --> 00:14:13,889
of the number of runtime branches that

295
00:14:13,889 --> 00:14:15,269
can be referenced at a particular

296
00:14:15,269 --> 00:14:17,160
indirect branch site during runtime and

297
00:14:17,160 --> 00:14:19,829
the method is we just insert an indirect

298
00:14:19,829 --> 00:14:21,930
callback a call back at the indirect

299
00:14:21,930 --> 00:14:24,300
branch target site to a routine that

300
00:14:24,300 --> 00:14:27,720
tries to match its points to set and if

301
00:14:27,720 --> 00:14:29,519
we find a match then we sort of count

302
00:14:29,519 --> 00:14:33,000
that as a reference within the valid

303
00:14:33,000 --> 00:14:34,560
points to set and we found that

304
00:14:34,560 --> 00:14:36,540
basically during runtime 90% of the

305
00:14:36,540 --> 00:14:39,540
dynamic points to set were singleton so

306
00:14:39,540 --> 00:14:42,000
the over approximation and static

307
00:14:42,000 --> 00:14:44,759
analysis can be reduced to unique

308
00:14:44,759 --> 00:14:47,399
branches if you incorporate a dynamic

309
00:14:47,399 --> 00:14:49,470
runtime I mean a dynamic points to

310
00:14:49,470 --> 00:14:51,300
analysis into your control flow graph

311
00:14:51,300 --> 00:14:54,449
construction of course this is limited

312
00:14:54,449 --> 00:14:56,819
by the execution path coverage right so

313
00:14:56,819 --> 00:14:59,519
it's not it's sort of undecidable that a

314
00:14:59,519 --> 00:15:01,319
program will halt and so if we can be

315
00:15:01,319 --> 00:15:03,870
guaranteed that will will cover the

316
00:15:03,870 --> 00:15:06,269
entire execution trace of the program

317
00:15:06,269 --> 00:15:09,120
but given this we can sort of recover

318
00:15:09,120 --> 00:15:11,519
more CFG precision overall and prevent

319
00:15:11,519 --> 00:15:13,259
this sort of style of control flow

320
00:15:13,259 --> 00:15:17,600
bending within the policy itself so

321
00:15:17,600 --> 00:15:19,740
ultimately what we're doing is we're

322
00:15:19,740 --> 00:15:21,569
protecting certain types of instructions

323
00:15:21,569 --> 00:15:23,759
and we're only protecting instructions

324
00:15:23,759 --> 00:15:25,410
that are dereferencing memory and

325
00:15:25,410 --> 00:15:28,260
directly write direct code pointers are

326
00:15:28,260 --> 00:15:30,089
not something that we're concerned with

327
00:15:30,089 --> 00:15:31,980
because you can't code pages are not

328
00:15:31,980 --> 00:15:34,040
writable right

329
00:15:34,040 --> 00:15:35,959
but this is an issue for instrumentation

330
00:15:35,959 --> 00:15:39,769
so 15% of the branches are indirect

331
00:15:39,769 --> 00:15:42,829
given a in a general case and a general

332
00:15:42,829 --> 00:15:45,499
execution trace of a program the large

333
00:15:45,499 --> 00:15:47,119
majority of them are returns and

334
00:15:47,119 --> 00:15:49,160
indirect calls but there's going to be

335
00:15:49,160 --> 00:15:51,439
some jumps as well which amounts to

336
00:15:51,439 --> 00:15:53,449
billions of executed branch instructions

337
00:15:53,449 --> 00:15:55,749
and if we're going to do static

338
00:15:55,749 --> 00:15:58,609
instrumentation where we have a function

339
00:15:58,609 --> 00:16:02,600
call a return or a jump and we need to

340
00:16:02,600 --> 00:16:04,489
sort of instrument the the code to do a

341
00:16:04,489 --> 00:16:07,129
CFI check where what we're doing is be

342
00:16:07,129 --> 00:16:08,869
referencing from the target destination

343
00:16:08,869 --> 00:16:10,730
the label and then we're doing a

344
00:16:10,730 --> 00:16:13,040
comparison prior to transferring control

345
00:16:13,040 --> 00:16:15,139
right that this is going to incur

346
00:16:15,139 --> 00:16:16,730
significant amount of overhead both in

347
00:16:16,730 --> 00:16:18,799
instruction latency and instructions

348
00:16:18,799 --> 00:16:21,739
side and on average that degrade that

349
00:16:21,739 --> 00:16:23,949
degrades performance pretty rapidly so

350
00:16:23,949 --> 00:16:26,389
what we measured is that we have some

351
00:16:26,389 --> 00:16:28,459
average of 35 percent slowdown if you're

352
00:16:28,459 --> 00:16:30,470
doing these styles of checks across

353
00:16:30,470 --> 00:16:32,629
these different types of CPUs so we have

354
00:16:32,629 --> 00:16:34,999
some server and CPUs and some more high

355
00:16:34,999 --> 00:16:37,790
performance i7 CPUs and the performance

356
00:16:37,790 --> 00:16:39,439
degradation is pretty constant across

357
00:16:39,439 --> 00:16:43,069
them there's also some other issues

358
00:16:43,069 --> 00:16:44,329
associated with different elements

359
00:16:44,329 --> 00:16:47,149
within the micro architectural stack so

360
00:16:47,149 --> 00:16:49,369
I cache pressure reduces due to this

361
00:16:49,369 --> 00:16:52,220
instrumentation pretty significantly and

362
00:16:52,220 --> 00:16:56,299
the the degradation and memory access

363
00:16:56,299 --> 00:16:58,970
latency is the one that were most

364
00:16:58,970 --> 00:17:01,069
concerned with right so dereferencing

365
00:17:01,069 --> 00:17:03,739
memory rate is going to basically occupy

366
00:17:03,739 --> 00:17:06,439
a lot of the overhead and it's going to

367
00:17:06,439 --> 00:17:08,839
dominate that so in a sort of hardware

368
00:17:08,839 --> 00:17:10,099
based solution you're going to want to

369
00:17:10,099 --> 00:17:11,919
try and reduce that right by adding

370
00:17:11,919 --> 00:17:14,329
potentially dedicated element storage

371
00:17:14,329 --> 00:17:16,369
elements to maintain your CFI metadata

372
00:17:16,369 --> 00:17:22,750
that is used in checking your CFI policy

373
00:17:23,740 --> 00:17:26,750
finally there's some other issues with

374
00:17:26,750 --> 00:17:28,429
label granularity that need to be

375
00:17:28,429 --> 00:17:31,429
resolved and pose issues for CFI policy

376
00:17:31,429 --> 00:17:33,799
overall so ultimately calls the shared

377
00:17:33,799 --> 00:17:35,360
objects cannot be recalled either

378
00:17:35,360 --> 00:17:37,340
external objects where I'm like sort of

379
00:17:37,340 --> 00:17:39,019
linking in something externally when I'm

380
00:17:39,019 --> 00:17:41,659
compiling it and the idea is you don't

381
00:17:41,659 --> 00:17:43,850
really know how to label this you can't

382
00:17:43,850 --> 00:17:46,220
actually a fix a label to this at

383
00:17:46,220 --> 00:17:46,970
runtime the

384
00:17:46,970 --> 00:17:49,159
because multiple other objects multiple

385
00:17:49,159 --> 00:17:51,020
processes are going to be trying to

386
00:17:51,020 --> 00:17:53,750
access this right so process a wants to

387
00:17:53,750 --> 00:17:56,659
you know get some function from lid C

388
00:17:56,659 --> 00:17:58,039
and process being once they get the same

389
00:17:58,039 --> 00:18:00,230
function so how do i label those and

390
00:18:00,230 --> 00:18:03,200
that's the basic issue so the solution

391
00:18:03,200 --> 00:18:05,120
to this traditionally has been just to

392
00:18:05,120 --> 00:18:06,950
apply a single label to all those

393
00:18:06,950 --> 00:18:10,820
external functions of course this is not

394
00:18:10,820 --> 00:18:12,830
ideal because we can ultimately just

395
00:18:12,830 --> 00:18:15,140
redirect control to all of those labels

396
00:18:15,140 --> 00:18:18,020
because it's just a simple CFI check so

397
00:18:18,020 --> 00:18:20,120
this is an example of sort of some

398
00:18:20,120 --> 00:18:21,799
concession you have to make based on

399
00:18:21,799 --> 00:18:23,960
some limitation in the control flow

400
00:18:23,960 --> 00:18:25,700
graph analysis coverage that some

401
00:18:25,700 --> 00:18:28,940
dynamic points to analysis can help and

402
00:18:28,940 --> 00:18:32,559
to recover and resolve ultimately so the

403
00:18:32,559 --> 00:18:35,870
coarse grained CFI policies sort of

404
00:18:35,870 --> 00:18:40,059
amount to are reduced to generic

405
00:18:40,059 --> 00:18:42,470
abstractions on the check so for

406
00:18:42,470 --> 00:18:44,419
instance you can only return to a call

407
00:18:44,419 --> 00:18:46,940
preceded instruction in this case you

408
00:18:46,940 --> 00:18:48,650
know the ret will either target these

409
00:18:48,650 --> 00:18:50,600
and these are all great right but if i

410
00:18:50,600 --> 00:18:52,580
jump there then you know if i can't I

411
00:18:52,580 --> 00:18:55,130
can't do that all right and so for

412
00:18:55,130 --> 00:18:57,110
forward edge policy something similar

413
00:18:57,110 --> 00:18:59,240
occurs i can only target forward edges

414
00:18:59,240 --> 00:19:02,059
and it will trigger a fault if i target

415
00:19:02,059 --> 00:19:03,559
something other than a function entry

416
00:19:03,559 --> 00:19:06,919
all right so this sounds great right but

417
00:19:06,919 --> 00:19:09,679
in the long run reason it is sort of

418
00:19:09,679 --> 00:19:11,720
determined that there isn't really great

419
00:19:11,720 --> 00:19:14,020
there are too many call sites available

420
00:19:14,020 --> 00:19:18,140
the heuristics associated with um like

421
00:19:18,140 --> 00:19:20,510
the length of the number of returns

422
00:19:20,510 --> 00:19:22,909
executed prior to executing a system

423
00:19:22,909 --> 00:19:27,169
call or too many indirect jumps and

424
00:19:27,169 --> 00:19:30,049
calls all basically provide wiggle room

425
00:19:30,049 --> 00:19:32,270
for me to sort of bend the control flow

426
00:19:32,270 --> 00:19:33,980
within these policies and around these

427
00:19:33,980 --> 00:19:36,620
policies and there's been a significant

428
00:19:36,620 --> 00:19:38,480
amount of work done demonstrating this

429
00:19:38,480 --> 00:19:40,190
and the list goes on I basically just

430
00:19:40,190 --> 00:19:41,840
highlighted the ones that I think are

431
00:19:41,840 --> 00:19:46,429
the most interesting so for instance

432
00:19:46,429 --> 00:19:49,280
coop is incredibly difficult to solve as

433
00:19:49,280 --> 00:19:52,450
an in general no CFI defense not even on

434
00:19:52,450 --> 00:19:55,190
lob MV table verification which does

435
00:19:55,190 --> 00:19:58,100
very very fine-grain class hierarchy

436
00:19:58,100 --> 00:19:59,899
distinctions between virtual table

437
00:19:59,899 --> 00:20:00,830
functions

438
00:20:00,830 --> 00:20:03,290
can't handle coupe so this is like one

439
00:20:03,290 --> 00:20:05,180
issue that still is sort of open for

440
00:20:05,180 --> 00:20:10,280
research so and a final thing that we

441
00:20:10,280 --> 00:20:12,320
need to sort of think about when we're

442
00:20:12,320 --> 00:20:14,900
talking about our labeling is return

443
00:20:14,900 --> 00:20:17,150
these are the totally difficult to

444
00:20:17,150 --> 00:20:18,980
manage because you could have two

445
00:20:18,980 --> 00:20:20,900
functions targeting a single call site

446
00:20:20,900 --> 00:20:23,780
and my control flow graph analysis is

447
00:20:23,780 --> 00:20:29,000
basically going to recover this sort of

448
00:20:29,000 --> 00:20:31,820
label 1 and label to write as its points

449
00:20:31,820 --> 00:20:35,210
to set okay now imagine that I make a

450
00:20:35,210 --> 00:20:38,270
call from function a and then redirect

451
00:20:38,270 --> 00:20:43,700
too late to back to B this is valid

452
00:20:43,700 --> 00:20:45,260
within my control file integrity policy

453
00:20:45,260 --> 00:20:47,360
because the points to set is actually

454
00:20:47,360 --> 00:20:50,290
label to is valid within this set so

455
00:20:50,290 --> 00:20:53,330
this basically allows granularity in

456
00:20:53,330 --> 00:20:55,580
your return address protection and a

457
00:20:55,580 --> 00:20:57,470
shadow start actually solves this right

458
00:20:57,470 --> 00:20:59,240
a shadow stack tightly coupled call

459
00:20:59,240 --> 00:21:01,880
return pairs basically it guarantees

460
00:21:01,880 --> 00:21:03,230
that you'll only return to your most

461
00:21:03,230 --> 00:21:06,890
recent call site okay but this

462
00:21:06,890 --> 00:21:09,980
unfortunately encourage some sort of

463
00:21:09,980 --> 00:21:13,310
overhead so while ideally I would like

464
00:21:13,310 --> 00:21:15,770
to implement a shadow stack policy

465
00:21:15,770 --> 00:21:17,570
you're going to have to address some

466
00:21:17,570 --> 00:21:19,490
issues with memory hierarchy latency and

467
00:21:19,490 --> 00:21:21,620
bandwidth and sort of nested function

468
00:21:21,620 --> 00:21:24,470
calls so just some basic analysis in

469
00:21:24,470 --> 00:21:27,730
some generic environment we've done some

470
00:21:27,730 --> 00:21:30,260
analysis with the memory hierarchy

471
00:21:30,260 --> 00:21:32,540
bottlenecks and sort of read latency is

472
00:21:32,540 --> 00:21:34,280
kind of stable and it's not very high

473
00:21:34,280 --> 00:21:36,650
right and if you to in read latency then

474
00:21:36,650 --> 00:21:40,070
you can incur get a significant

475
00:21:40,070 --> 00:21:41,630
improvement in the overhead for your

476
00:21:41,630 --> 00:21:45,320
shadow stack implementation but you have

477
00:21:45,320 --> 00:21:47,240
to do that custom right we want to sort

478
00:21:47,240 --> 00:21:49,430
of avoid nobody wants to sort of go in

479
00:21:49,430 --> 00:21:51,530
and tune every sort of program they've

480
00:21:51,530 --> 00:21:53,210
ever written what about let's see what

481
00:21:53,210 --> 00:21:56,360
about you know this is it's too much and

482
00:21:56,360 --> 00:21:58,040
you can see here like that the

483
00:21:58,040 --> 00:22:00,470
degradation in performance which is the

484
00:22:00,470 --> 00:22:02,180
red line sort of drops off significantly

485
00:22:02,180 --> 00:22:04,850
at around twenty nested function calls

486
00:22:04,850 --> 00:22:07,400
on so this is a typical sort of behavior

487
00:22:07,400 --> 00:22:09,680
that's going to affect your shadow stack

488
00:22:09,680 --> 00:22:14,240
overall surprisingly though these these

489
00:22:14,240 --> 00:22:16,310
two works right here these two I need to

490
00:22:16,310 --> 00:22:18,020
include two pieces of research because

491
00:22:18,020 --> 00:22:19,040
they're great it actually says

492
00:22:19,040 --> 00:22:20,780
traditional Java stack only incur twelve

493
00:22:20,780 --> 00:22:22,160
percent overhead so there are

494
00:22:22,160 --> 00:22:23,840
optimizations that you can make to

495
00:22:23,840 --> 00:22:27,680
reduce what we've shown here and LLVM

496
00:22:27,680 --> 00:22:29,510
stay stuck which is a new protection

497
00:22:29,510 --> 00:22:31,520
that's just being incorporated into the

498
00:22:31,520 --> 00:22:34,790
LLVM stream actually only incurs 0.1%

499
00:22:34,790 --> 00:22:36,790
overhead

500
00:22:36,790 --> 00:22:40,190
unfortunately despite the reduction in

501
00:22:40,190 --> 00:22:41,630
overhead they've done that at the cost

502
00:22:41,630 --> 00:22:44,300
of security and so our collaborators who

503
00:22:44,300 --> 00:22:45,920
unfortunately couldn't be here to speak

504
00:22:45,920 --> 00:22:49,640
about this topic have investigated this

505
00:22:49,640 --> 00:22:53,420
and found that you can in fact break CFI

506
00:22:53,420 --> 00:22:55,310
implementations that are using shadow

507
00:22:55,310 --> 00:22:57,680
software shadow stack and one of the

508
00:22:57,680 --> 00:22:59,600
reasons for this is that they optimized

509
00:22:59,600 --> 00:23:01,760
a compiler critical CFI pointers that

510
00:23:01,760 --> 00:23:04,280
are spilled onto the stack and they're

511
00:23:04,280 --> 00:23:06,590
able to use an overwrite to corrupt that

512
00:23:06,590 --> 00:23:09,050
filled pointer at which point when the

513
00:23:09,050 --> 00:23:13,010
CFI checking mechanism go start to work

514
00:23:13,010 --> 00:23:15,200
it doesn't realize that there's a

515
00:23:15,200 --> 00:23:18,220
malicious efi pointer in the stack so

516
00:23:18,220 --> 00:23:21,160
this is actually shown to bypass this uh

517
00:23:21,160 --> 00:23:24,050
IFC see on vtable verification

518
00:23:24,050 --> 00:23:30,100
implementation for safe stack and as so

519
00:23:30,100 --> 00:23:33,260
given that we have the sort of overview

520
00:23:33,260 --> 00:23:35,150
that we have these forward edge policies

521
00:23:35,150 --> 00:23:38,270
that are really great now for CFI we

522
00:23:38,270 --> 00:23:40,580
have google's VTV and i FCC safe

523
00:23:40,580 --> 00:23:43,540
dispatch which can really really

524
00:23:43,540 --> 00:23:46,460
generate some fine-grained CFI policies

525
00:23:46,460 --> 00:23:50,000
for C++ applications and the assumption

526
00:23:50,000 --> 00:23:52,250
is that the backward edge CFI through

527
00:23:52,250 --> 00:23:54,140
safe to your shadow stack protection

528
00:23:54,140 --> 00:23:56,660
will completely solve this issue right

529
00:23:56,660 --> 00:23:58,040
we don't really have to think about

530
00:23:58,040 --> 00:24:00,260
control flow hijacking anymore we just

531
00:24:00,260 --> 00:24:03,110
say we just use the TV in combination

532
00:24:03,110 --> 00:24:04,910
with some software shadow stacks like

533
00:24:04,910 --> 00:24:07,340
for instance all of them clinging except

534
00:24:07,340 --> 00:24:10,100
tomorrow you're going to hear a talk and

535
00:24:10,100 --> 00:24:13,400
I recommend you all go there where some

536
00:24:13,400 --> 00:24:15,890
researchers and ESCO tests and herbert

537
00:24:15,890 --> 00:24:17,929
boss thinks from the USAC will be

538
00:24:17,929 --> 00:24:19,850
presenting a bypass playing safe stack

539
00:24:19,850 --> 00:24:23,179
so what this cordis shows is that like

540
00:24:23,179 --> 00:24:25,130
sort of the underlying assumptions

541
00:24:25,130 --> 00:24:26,659
behind shelf software shot

542
00:24:26,659 --> 00:24:29,210
sex and being able to main maintain

543
00:24:29,210 --> 00:24:31,580
isolation within the software stock is

544
00:24:31,580 --> 00:24:33,470
going to be problematic overall we want

545
00:24:33,470 --> 00:24:37,489
to kind of address that issue so with

546
00:24:37,489 --> 00:24:39,259
that background information and sort of

547
00:24:39,259 --> 00:24:41,119
the motivation details we're going to

548
00:24:41,119 --> 00:24:43,039
try and introduce at a base level what

549
00:24:43,039 --> 00:24:46,099
the our implementation actually is we

550
00:24:46,099 --> 00:24:47,779
call it hey six plus plus it was

551
00:24:47,779 --> 00:24:50,509
presented at DAC in 2015 we also

552
00:24:50,509 --> 00:24:53,090
presented a prior work in back in 2015

553
00:24:53,090 --> 00:24:55,399
which it's called hey fix and won the

554
00:24:55,399 --> 00:24:57,590
best paper there it was with our

555
00:24:57,590 --> 00:25:01,399
collaborators here and the outcomes of

556
00:25:01,399 --> 00:25:03,229
that are that we have some really

557
00:25:03,229 --> 00:25:06,109
stateful policy agnostic CFI

558
00:25:06,109 --> 00:25:07,759
implementation for both backward and

559
00:25:07,759 --> 00:25:11,119
forward edges we created some

560
00:25:11,119 --> 00:25:12,470
implementation that doesn't require

561
00:25:12,470 --> 00:25:15,109
source code modifications to instrument

562
00:25:15,109 --> 00:25:20,149
your application or to recover a CFG we

563
00:25:20,149 --> 00:25:22,369
have a precise fee fi policy enforcement

564
00:25:22,369 --> 00:25:24,200
for both forward and backward edges with

565
00:25:24,200 --> 00:25:26,929
no heuristics incorporated and we try to

566
00:25:26,929 --> 00:25:28,489
limit the amount of concessions and

567
00:25:28,489 --> 00:25:29,629
we'll sort of go over what those

568
00:25:29,629 --> 00:25:31,099
concessions are but we think those are

569
00:25:31,099 --> 00:25:33,679
good anyway we also have some isolated

570
00:25:33,679 --> 00:25:37,009
memory for CFI metadata it turns out

571
00:25:37,009 --> 00:25:38,419
that when it when we actually

572
00:25:38,419 --> 00:25:40,070
incorporate the entire system and

573
00:25:40,070 --> 00:25:42,499
encourage less than 3% overhead which is

574
00:25:42,499 --> 00:25:45,619
as a worst case which is pretty good in

575
00:25:45,619 --> 00:25:48,349
our in our estimation and it supports

576
00:25:48,349 --> 00:25:50,419
multitasking and shared library so it's

577
00:25:50,419 --> 00:25:52,549
practical and can scale to complex

578
00:25:52,549 --> 00:25:55,029
software we also have a mechanism for

579
00:25:55,029 --> 00:25:58,039
interoperability with legacy code which

580
00:25:58,039 --> 00:25:59,330
is kind of important because not

581
00:25:59,330 --> 00:26:00,830
everything that you're executing on your

582
00:26:00,830 --> 00:26:04,369
system is going to be instrumented with

583
00:26:04,369 --> 00:26:07,549
CFI protection so at a high level the

584
00:26:07,549 --> 00:26:09,559
state model has an initialization phase

585
00:26:09,559 --> 00:26:12,349
which is in an idle state and is

586
00:26:12,349 --> 00:26:14,299
checking for a C if I disabled bit if we

587
00:26:14,299 --> 00:26:16,729
have C if I enabled then we just ain't

588
00:26:16,729 --> 00:26:19,479
endorsed EFI execution and move forward

589
00:26:19,479 --> 00:26:21,919
for a forward edge control flow state

590
00:26:21,919 --> 00:26:24,289
model it's again very straight forward

591
00:26:24,289 --> 00:26:26,749
which is one of the benefits of I think

592
00:26:26,749 --> 00:26:28,309
our implementation is it's sort of kind

593
00:26:28,309 --> 00:26:29,450
of intuitive how you would implement

594
00:26:29,450 --> 00:26:32,450
this is ran a CFI execution state if

595
00:26:32,450 --> 00:26:34,669
we're executing just instructions that

596
00:26:34,669 --> 00:26:36,559
are non-branching instructions right we

597
00:26:36,559 --> 00:26:38,029
just stay in this state we don't need to

598
00:26:38,029 --> 00:26:40,130
do anything if we encounter

599
00:26:40,130 --> 00:26:42,920
call or jump then we need to save these

600
00:26:42,920 --> 00:26:45,380
call targets right so that later on when

601
00:26:45,380 --> 00:26:47,840
we actually enter the target we can do a

602
00:26:47,840 --> 00:26:51,350
check all right so upon execution of the

603
00:26:51,350 --> 00:26:54,200
call and jump it's just simply just the

604
00:26:54,200 --> 00:26:57,800
check workout no trap the program if it

605
00:26:57,800 --> 00:26:59,000
does yet you're good to continue

606
00:26:59,000 --> 00:27:01,760
execution the same thing can be said for

607
00:27:01,760 --> 00:27:04,250
the backward edge CFI policy which

608
00:27:04,250 --> 00:27:06,800
handles returns so again we're going to

609
00:27:06,800 --> 00:27:09,050
trap otherwise we're going to continue

610
00:27:09,050 --> 00:27:11,260
at the label state checking matches

611
00:27:11,260 --> 00:27:13,820
again this offers a supportable

612
00:27:13,820 --> 00:27:16,220
co-financed efi processes and strict

613
00:27:16,220 --> 00:27:18,530
enforcement of unique ford edge and back

614
00:27:18,530 --> 00:27:22,700
roads control flow target target in

615
00:27:22,700 --> 00:27:25,130
order to do this we have to sort of

616
00:27:25,130 --> 00:27:27,920
manage the internal hardware in some way

617
00:27:27,920 --> 00:27:30,110
so we choose I chose a mechanism which

618
00:27:30,110 --> 00:27:32,120
is just maintaining an internal machine

619
00:27:32,120 --> 00:27:37,400
register which has elements for the CFI

620
00:27:37,400 --> 00:27:39,650
label and it can be extended into those

621
00:27:39,650 --> 00:27:41,960
reserved bits at the most significant

622
00:27:41,960 --> 00:27:43,910
bits of the register

623
00:27:43,910 --> 00:27:45,800
we have some interrupt service requests

624
00:27:45,800 --> 00:27:48,350
flag for when the operating system needs

625
00:27:48,350 --> 00:27:50,720
to handle requests for switching tasks

626
00:27:50,720 --> 00:27:52,550
or overflowing or under flowing the

627
00:27:52,550 --> 00:27:54,590
label states stack and we have some

628
00:27:54,590 --> 00:27:57,380
other sort of checks and flags that

629
00:27:57,380 --> 00:28:00,590
enable us to moderate requests to the

630
00:28:00,590 --> 00:28:02,600
label state stacker label state register

631
00:28:02,600 --> 00:28:05,630
to trigger errors to stop the execution

632
00:28:05,630 --> 00:28:08,750
or even to bow or gate the CFI hardware

633
00:28:08,750 --> 00:28:10,850
so that you can sort of lower the energy

634
00:28:10,850 --> 00:28:13,280
consumption needed when there is no CFI

635
00:28:13,280 --> 00:28:14,840
necessary you don't need to sort of

636
00:28:14,840 --> 00:28:19,700
check see if i so we've actually we've

637
00:28:19,700 --> 00:28:22,340
introduced the efi extensions to perform

638
00:28:22,340 --> 00:28:24,110
these tasks these basic tasks it

639
00:28:24,110 --> 00:28:28,100
requires five we have a pre c in a pre j

640
00:28:28,100 --> 00:28:31,010
so this sets up the call target and then

641
00:28:31,010 --> 00:28:32,900
we have a separate instruction of c fi

642
00:28:32,900 --> 00:28:35,030
branch that sets up the backward edge

643
00:28:35,030 --> 00:28:37,310
target we want it to do this sort of

644
00:28:37,310 --> 00:28:40,340
architectural independent and not sort

645
00:28:40,340 --> 00:28:42,620
of perform any optimizations specific to

646
00:28:42,620 --> 00:28:44,180
any is a where i might be able to

647
00:28:44,180 --> 00:28:46,940
incorporate the CFI procedure pj into a

648
00:28:46,940 --> 00:28:49,910
CFI branch to make it as general as

649
00:28:49,910 --> 00:28:51,290
possible

650
00:28:51,290 --> 00:28:53,940
in order to accomplish so there

651
00:28:53,940 --> 00:28:55,559
these instructions and manipulate them

652
00:28:55,559 --> 00:28:57,120
these guys sort of control the label

653
00:28:57,120 --> 00:28:59,210
state register in the label state stack

654
00:28:59,210 --> 00:29:02,100
they have allow separation of calls and

655
00:29:02,100 --> 00:29:04,769
jumps right so there can't be any sort

656
00:29:04,769 --> 00:29:07,139
of a funny business associated with

657
00:29:07,139 --> 00:29:09,809
using a jump pointer from a switch

658
00:29:09,809 --> 00:29:13,919
statement as a pointer from a call and a

659
00:29:13,919 --> 00:29:16,980
lot of unique labels / targets and the

660
00:29:16,980 --> 00:29:18,659
shadow stack enables return sewing the

661
00:29:18,659 --> 00:29:22,559
most recently issued Paul safe so just

662
00:29:22,559 --> 00:29:24,419
as a quick overview and I'll kind of try

663
00:29:24,419 --> 00:29:26,039
to breeze through this we're going to

664
00:29:26,039 --> 00:29:29,820
set up the label state using a CFIB our

665
00:29:29,820 --> 00:29:31,649
instruction by pushing a label on to the

666
00:29:31,649 --> 00:29:34,049
shadow stack we're then going to push

667
00:29:34,049 --> 00:29:35,970
the label for the return target into a

668
00:29:35,970 --> 00:29:38,070
register this register is dedicated

669
00:29:38,070 --> 00:29:39,419
hardware so we don't have to do any

670
00:29:39,419 --> 00:29:41,370
memory dereference instructions you can

671
00:29:41,370 --> 00:29:43,320
sort of access this in single cycle

672
00:29:43,320 --> 00:29:45,840
latency and sort of take advantage of

673
00:29:45,840 --> 00:29:48,000
modern out of order execution and

674
00:29:48,000 --> 00:29:50,549
register renaming to handle this

675
00:29:50,549 --> 00:29:54,570
situation as quickly as possible once we

676
00:29:54,570 --> 00:29:56,490
enter the target we're going to perform

677
00:29:56,490 --> 00:29:58,440
a CFI label check with what's currently

678
00:29:58,440 --> 00:30:00,570
at the label state register for a

679
00:30:00,570 --> 00:30:05,279
forward edge once we then execute if

680
00:30:05,279 --> 00:30:06,480
that check passes then we're going to

681
00:30:06,480 --> 00:30:07,950
enter the function and we're going to

682
00:30:07,950 --> 00:30:10,169
get to a point where we need to execute

683
00:30:10,169 --> 00:30:12,570
a return so that's when the return

684
00:30:12,570 --> 00:30:15,299
policy ring comes into place the return

685
00:30:15,299 --> 00:30:17,250
policy is simply going to look at the

686
00:30:17,250 --> 00:30:19,799
most recently pushed label at the top of

687
00:30:19,799 --> 00:30:22,590
the stack so we tightly couple the call

688
00:30:22,590 --> 00:30:24,419
and return pairs and this sort of grows

689
00:30:24,419 --> 00:30:26,490
down right as you would imagine it would

690
00:30:26,490 --> 00:30:28,889
and it's very intuitive the idea right I

691
00:30:28,889 --> 00:30:31,590
make a call from A to B I'm a call from

692
00:30:31,590 --> 00:30:34,320
B to C I can't return from C to a right

693
00:30:34,320 --> 00:30:36,269
in this implementation alright so the

694
00:30:36,269 --> 00:30:37,769
shadow stack tightly coupled these and

695
00:30:37,769 --> 00:30:39,509
enforces that I'm only returning to us

696
00:30:39,509 --> 00:30:46,529
we to the most recent call site one

697
00:30:46,529 --> 00:30:47,879
other thing we have to take care of it's

698
00:30:47,879 --> 00:30:50,100
sort of interfacing with the hardware in

699
00:30:50,100 --> 00:30:51,570
order to do that we have to sort of map

700
00:30:51,570 --> 00:30:55,620
a label state stack status register to

701
00:30:55,620 --> 00:30:58,740
i/o and this sort of needs to this needs

702
00:30:58,740 --> 00:31:00,450
to contain information for the operating

703
00:31:00,450 --> 00:31:01,980
system to handle the bounds for the

704
00:31:01,980 --> 00:31:04,409
shadow stack size the current pointer of

705
00:31:04,409 --> 00:31:07,380
the shadow stack and ten

706
00:31:07,380 --> 00:31:10,020
some sort of interrupt request routine

707
00:31:10,020 --> 00:31:12,300
that we serve we found down the line if

708
00:31:12,300 --> 00:31:13,650
we need to contact switch turning and

709
00:31:13,650 --> 00:31:15,540
underflow or underflow this could be

710
00:31:15,540 --> 00:31:17,690
able to implemented as a machine

711
00:31:17,690 --> 00:31:20,130
specific register so that you don't have

712
00:31:20,130 --> 00:31:22,530
to do CPU buffs activities and you can

713
00:31:22,530 --> 00:31:24,450
ensure only privileged access to that

714
00:31:24,450 --> 00:31:26,910
instruction just in our our case we

715
00:31:26,910 --> 00:31:31,710
didn't do that so to answer why sort of

716
00:31:31,710 --> 00:31:34,680
you need hardware for CFI I think we try

717
00:31:34,680 --> 00:31:36,720
to show that in terms of efficiency you

718
00:31:36,720 --> 00:31:38,520
can get improved runtime overhead with

719
00:31:38,520 --> 00:31:40,650
dedicated label register and shadow

720
00:31:40,650 --> 00:31:43,920
stack due to the instruction

721
00:31:43,920 --> 00:31:46,350
instrumentation we have limited I cross

722
00:31:46,350 --> 00:31:47,910
pressure because we're emitting less

723
00:31:47,910 --> 00:31:49,980
code and using hard dedicated Hardware

724
00:31:49,980 --> 00:31:53,850
element and register moves so we could

725
00:31:53,850 --> 00:31:56,790
eliminate that sort of degradation and

726
00:31:56,790 --> 00:31:59,100
performance overall we also have reduced

727
00:31:59,100 --> 00:32:00,870
ecash pressure because we're not setting

728
00:32:00,870 --> 00:32:04,560
up some CFI metadata in the programs

729
00:32:04,560 --> 00:32:07,890
data space we have a dedicated label

730
00:32:07,890 --> 00:32:11,070
state stack and that sort of avoids

731
00:32:11,070 --> 00:32:12,900
referencing from d cache and those

732
00:32:12,900 --> 00:32:14,970
instructions that we instrument are that

733
00:32:14,970 --> 00:32:16,320
we've introduced are actually single

734
00:32:16,320 --> 00:32:18,690
cycle instructions all we do is we

735
00:32:18,690 --> 00:32:21,300
simple we simply toggle the functional

736
00:32:21,300 --> 00:32:23,340
units so that they execute as no

737
00:32:23,340 --> 00:32:25,350
operation instructions and then the CFI

738
00:32:25,350 --> 00:32:27,000
hardware sort of manages their

739
00:32:27,000 --> 00:32:30,180
operations separate from the out of

740
00:32:30,180 --> 00:32:34,530
order functional unit and as from a

741
00:32:34,530 --> 00:32:36,390
security perspective we are sort of

742
00:32:36,390 --> 00:32:38,520
eliminating the significant number of

743
00:32:38,520 --> 00:32:41,880
policy concessions due to a possibility

744
00:32:41,880 --> 00:32:44,460
of pointer aliasing analysis and the

745
00:32:44,460 --> 00:32:47,610
associated labeling issues we have we do

746
00:32:47,610 --> 00:32:50,220
this with a point one time points to

747
00:32:50,220 --> 00:32:52,890
analysis we have some isolated memory

748
00:32:52,890 --> 00:32:55,290
which prevents the software shadow sack

749
00:32:55,290 --> 00:32:57,240
attacks like stack to filer represented

750
00:32:57,240 --> 00:32:59,310
I'm not exactly sure the details for the

751
00:32:59,310 --> 00:33:00,720
talk tomorrow but potentially it

752
00:33:00,720 --> 00:33:02,700
prevents that as well and we have this

753
00:33:02,700 --> 00:33:04,440
precise policy enforcement that is

754
00:33:04,440 --> 00:33:06,270
agnostic with respect to the labeling

755
00:33:06,270 --> 00:33:08,910
mechanism so if I want to label all of

756
00:33:08,910 --> 00:33:11,730
the arm if I want to label all of the

757
00:33:11,730 --> 00:33:15,210
code in my CF I protected program with

758
00:33:15,210 --> 00:33:17,520
the same label then I have just a basic

759
00:33:17,520 --> 00:33:20,040
single equivalence class via five policy

760
00:33:20,040 --> 00:33:21,340
and I could upgrade

761
00:33:21,340 --> 00:33:25,020
or downgrade that you know peruse

762
00:33:25,020 --> 00:33:27,790
without being said I'm going to sort of

763
00:33:27,790 --> 00:33:29,980
introduce Orlando and he'll finish out

764
00:33:29,980 --> 00:33:32,770
the talk for us right so we have this

765
00:33:32,770 --> 00:33:34,900
very nice piece of hardware that didn't

766
00:33:34,900 --> 00:33:37,570
hear introduced for us unfortunately we

767
00:33:37,570 --> 00:33:40,210
need to control this guy somehow we have

768
00:33:40,210 --> 00:33:41,710
to run this on top of an operating

769
00:33:41,710 --> 00:33:44,380
system we have the problem the modern

770
00:33:44,380 --> 00:33:45,250
operating system to actually

771
00:33:45,250 --> 00:33:47,200
multitasking systems and we only have

772
00:33:47,200 --> 00:33:49,510
one CFI module we have multiple

773
00:33:49,510 --> 00:33:52,540
processes though and plus we have legacy

774
00:33:52,540 --> 00:33:54,310
code you know the program you go back in

775
00:33:54,310 --> 00:33:56,050
the year 2000 that your business really

776
00:33:56,050 --> 00:33:59,290
needs and you can't really replace so we

777
00:33:59,290 --> 00:34:00,940
have a few showings ahead of us we need

778
00:34:00,940 --> 00:34:02,920
to be able to share this efi subsystem

779
00:34:02,920 --> 00:34:05,500
across multiple processes we need to

780
00:34:05,500 --> 00:34:08,139
keep a separation of processes as well

781
00:34:08,139 --> 00:34:10,570
we need to keep the CFI state for each

782
00:34:10,570 --> 00:34:12,850
process independent from each other we

783
00:34:12,850 --> 00:34:14,889
need to be able to handle whatever

784
00:34:14,889 --> 00:34:18,190
exceptions TRC f5 module exposures to us

785
00:34:18,190 --> 00:34:21,370
close again the legacy code big elephant

786
00:34:21,370 --> 00:34:23,710
in the room there so we have to make a

787
00:34:23,710 --> 00:34:26,530
few changes to the way programs run on

788
00:34:26,530 --> 00:34:30,159
your computer so we have a scheduling

789
00:34:30,159 --> 00:34:32,679
issue first of all have a processes

790
00:34:32,679 --> 00:34:35,440
currently running the CPU and suddenly a

791
00:34:35,440 --> 00:34:37,210
new process is being scared you'll come

792
00:34:37,210 --> 00:34:40,239
see and it has its own CFI state we need

793
00:34:40,239 --> 00:34:41,199
to be able to handle these things

794
00:34:41,199 --> 00:34:43,960
somehow there is a second case that

795
00:34:43,960 --> 00:34:46,330
happens you have one process running

796
00:34:46,330 --> 00:34:49,719
second process comes in it also has it

797
00:34:49,719 --> 00:34:51,850
doesn't have any CFI state it's not CFI

798
00:34:51,850 --> 00:34:53,830
instrumented so we have to handle

799
00:34:53,830 --> 00:34:58,030
somehow what do you what to do here then

800
00:34:58,030 --> 00:35:00,790
we have a problem with the shadow

801
00:35:00,790 --> 00:35:03,790
staggers world 11 shuttle stack turns

802
00:35:03,790 --> 00:35:05,800
out space is limited and we have this

803
00:35:05,800 --> 00:35:09,370
pain on die broke into the cpu so we do

804
00:35:09,370 --> 00:35:12,250
a function call or the program there's a

805
00:35:12,250 --> 00:35:13,590
function call

806
00:35:13,590 --> 00:35:16,390
just another function call and another

807
00:35:16,390 --> 00:35:18,550
function call and another function call

808
00:35:18,550 --> 00:35:20,320
and we still have no returns and then we

809
00:35:20,320 --> 00:35:22,780
do another function call and we have a

810
00:35:22,780 --> 00:35:24,900
problem we have no more space there so

811
00:35:24,900 --> 00:35:28,750
we run out of shadow stack space so what

812
00:35:28,750 --> 00:35:31,480
do we do here well you could say yeah

813
00:35:31,480 --> 00:35:34,120
sure why not just get some metrics see

814
00:35:34,120 --> 00:35:35,020
how big

815
00:35:35,020 --> 00:35:37,240
need to make the shadow stack and see

816
00:35:37,240 --> 00:35:40,570
what happens well unfortunately that's

817
00:35:40,570 --> 00:35:44,410
not very scalable you can't really make

818
00:35:44,410 --> 00:35:46,270
this large memories put them inside of

819
00:35:46,270 --> 00:35:50,110
CPU plus you can't also get a whole

820
00:35:50,110 --> 00:35:51,850
bunch of programs and say yeah my worst

821
00:35:51,850 --> 00:35:54,520
case scenario in this set what T so I'm

822
00:35:54,520 --> 00:35:57,340
just going to build it like that then

823
00:35:57,340 --> 00:35:59,020
there's also the thing that if you need

824
00:35:59,020 --> 00:36:01,750
to empty this area inside the CPU it

825
00:36:01,750 --> 00:36:04,780
takes time as well so if you're copying

826
00:36:04,780 --> 00:36:06,760
that in kernel space you can see you're

827
00:36:06,760 --> 00:36:08,430
going to see something like that there

828
00:36:08,430 --> 00:36:11,290
if for some reason you feel like you

829
00:36:11,290 --> 00:36:13,150
need to go into that shadow stack and

830
00:36:13,150 --> 00:36:15,700
put something else in that place it's

831
00:36:15,700 --> 00:36:17,890
going to take time if you do this doing

832
00:36:17,890 --> 00:36:20,170
scheduling well your scheduler is now a

833
00:36:20,170 --> 00:36:22,480
lot slower you don't want your scheduler

834
00:36:22,480 --> 00:36:26,410
to eat of CPU time that much so that

835
00:36:26,410 --> 00:36:28,480
means that let's talk some preliminaries

836
00:36:28,480 --> 00:36:30,430
here first of all a process control

837
00:36:30,430 --> 00:36:32,530
block is to sustain the standard data

838
00:36:32,530 --> 00:36:34,210
structuring pretty much every single

839
00:36:34,210 --> 00:36:36,640
modern operating system it's how the

840
00:36:36,640 --> 00:36:39,220
operating system kernel sees your

841
00:36:39,220 --> 00:36:41,500
processes if you're working in Linux you

842
00:36:41,500 --> 00:36:43,210
can look in that file in there for tax

843
00:36:43,210 --> 00:36:47,170
tasks drugs this takes about 1.7 kilo

844
00:36:47,170 --> 00:36:50,770
bytes in a 32-bit system on Linux and

845
00:36:50,770 --> 00:36:53,470
well the process control block contains

846
00:36:53,470 --> 00:36:54,910
some information about the process

847
00:36:54,910 --> 00:36:57,130
namely its execution state where we're

848
00:36:57,130 --> 00:36:58,990
running where some b-process were

849
00:36:58,990 --> 00:37:02,260
suspended waiting for IO stuff like that

850
00:37:02,260 --> 00:37:04,540
week until it also contains all your

851
00:37:04,540 --> 00:37:06,430
memory allocations that the process

852
00:37:06,430 --> 00:37:09,700
process has made who want the process

853
00:37:09,700 --> 00:37:12,280
the group of the process important the

854
00:37:12,280 --> 00:37:13,690
process ID as well

855
00:37:13,690 --> 00:37:16,390
io starts information and well we also

856
00:37:16,390 --> 00:37:20,260
have the CPU contact state we do see a

857
00:37:20,260 --> 00:37:23,410
five module on a CPU so let's look at

858
00:37:23,410 --> 00:37:25,380
that guy and see what we have there on a

859
00:37:25,380 --> 00:37:28,360
modern system like x86 weeks before you

860
00:37:28,360 --> 00:37:29,950
have your interest rates or file which

861
00:37:29,950 --> 00:37:31,960
gets backed up in there every time you

862
00:37:31,960 --> 00:37:37,840
do any task in in the Leon 3 processor

863
00:37:37,840 --> 00:37:39,310
which is what we use stuff for

864
00:37:39,310 --> 00:37:41,170
implementation you have a couple more

865
00:37:41,170 --> 00:37:43,690
racers that you have to take care of you

866
00:37:43,690 --> 00:37:45,610
have some floating-point registers you

867
00:37:45,610 --> 00:37:48,290
have CPU status registers

868
00:37:48,290 --> 00:37:50,660
and well since we're putting stuff in

869
00:37:50,660 --> 00:37:53,090
there might as well put in all CSI

870
00:37:53,090 --> 00:37:55,280
information for the process in the cpu

871
00:37:55,280 --> 00:37:58,250
context today as well so we extend that

872
00:37:58,250 --> 00:38:02,270
guy and every time we do we do a task

873
00:38:02,270 --> 00:38:04,280
switch or something happens for CFI

874
00:38:04,280 --> 00:38:06,650
module we go ahead and modify the kernel

875
00:38:06,650 --> 00:38:09,950
to handle that for us so adding to the

876
00:38:09,950 --> 00:38:12,560
scheduler then we need to see whether or

877
00:38:12,560 --> 00:38:15,230
current process you see fi aware or not

878
00:38:15,230 --> 00:38:19,100
if it is we want to backup the SEFI

879
00:38:19,100 --> 00:38:21,800
state into a process control block and

880
00:38:21,800 --> 00:38:23,840
the next process that we're about to

881
00:38:23,840 --> 00:38:26,930
execute which I can see whether or not

882
00:38:26,930 --> 00:38:30,320
the FI aware if it is well use fixed

883
00:38:30,320 --> 00:38:32,480
order to a five-state otherwise just

884
00:38:32,480 --> 00:38:34,790
disable to see a five module that being

885
00:38:34,790 --> 00:38:37,070
said have some animations here for that

886
00:38:37,070 --> 00:38:39,530
process one is currently running process

887
00:38:39,530 --> 00:38:41,840
- it's about to be scheduled so we see

888
00:38:41,840 --> 00:38:44,150
that it's here process one is efi aware

889
00:38:44,150 --> 00:38:48,560
we get its efi state push it into into

890
00:38:48,560 --> 00:38:50,660
the process control block we check

891
00:38:50,660 --> 00:38:54,020
process to see that it's efi aware well

892
00:38:54,020 --> 00:38:56,750
just go ahead and restore that CSI state

893
00:38:56,750 --> 00:38:58,280
and now we're free to keep running

894
00:38:58,280 --> 00:39:00,290
process - what if nothing ever happen to

895
00:39:00,290 --> 00:39:03,170
it on the second case well we have

896
00:39:03,170 --> 00:39:06,170
process one running we see that it's vfi

897
00:39:06,170 --> 00:39:08,420
aware we are about to schedule process -

898
00:39:08,420 --> 00:39:13,340
so we backup process one on CFI state we

899
00:39:13,340 --> 00:39:16,190
go to process two now we see that it's

900
00:39:16,190 --> 00:39:18,500
not the FI over so we just go ahead and

901
00:39:18,500 --> 00:39:20,900
disable a TFI module we can go ahead and

902
00:39:20,900 --> 00:39:23,570
begin executing process two now and no

903
00:39:23,570 --> 00:39:25,070
exceptions will occur at that point

904
00:39:25,070 --> 00:39:27,710
however there is still the stack on the

905
00:39:27,710 --> 00:39:29,960
stack issue we already use the process

906
00:39:29,960 --> 00:39:31,490
control block for this plane so you

907
00:39:31,490 --> 00:39:33,530
might as well utilized for this as well

908
00:39:33,530 --> 00:39:36,290
on our flow use copy a portion of that

909
00:39:36,290 --> 00:39:38,420
shadow stack into the process control

910
00:39:38,420 --> 00:39:41,390
block go ahead and move you move the top

911
00:39:41,390 --> 00:39:42,590
portion of the shuttle stack to the

912
00:39:42,590 --> 00:39:44,630
bottom we can do this with a flash copy

913
00:39:44,630 --> 00:39:47,030
on hardware and then they said that

914
00:39:47,030 --> 00:39:49,820
little shadow stack pointer to the its

915
00:39:49,820 --> 00:39:52,160
new location the underflow process is

916
00:39:52,160 --> 00:39:53,450
effectively the same thing in Reverse

917
00:39:53,450 --> 00:39:55,310
got something from the process control

918
00:39:55,310 --> 00:39:57,980
block and put it back into the into the

919
00:39:57,980 --> 00:40:00,650
shadow stack and again set the shadows

920
00:40:00,650 --> 00:40:04,700
pointer to the new location so in an

921
00:40:04,700 --> 00:40:08,020
animation there you can see go ahead and

922
00:40:08,020 --> 00:40:11,029
get the bottom portion put it on the CFI

923
00:40:11,029 --> 00:40:12,950
context on the portion of the process

924
00:40:12,950 --> 00:40:15,200
control block then you see your flash

925
00:40:15,200 --> 00:40:18,109
copy and execution continues as normal

926
00:40:18,109 --> 00:40:22,520
now lastly we need to investigate or CFI

927
00:40:22,520 --> 00:40:25,069
faults there is a control flow violation

928
00:40:25,069 --> 00:40:28,750
occurring well the subsystem detects it

929
00:40:28,750 --> 00:40:31,640
right now we just go ahead and add an

930
00:40:31,640 --> 00:40:33,589
entry on the colonel logs and then we

931
00:40:33,589 --> 00:40:36,230
send to fig go to the process if you're

932
00:40:36,230 --> 00:40:38,990
familiar with the a UNIX way of signal

933
00:40:38,990 --> 00:40:41,089
handling sig kill cannot be caught by

934
00:40:41,089 --> 00:40:44,150
user land at any points so we terminate

935
00:40:44,150 --> 00:40:46,490
the process technically speaking we

936
00:40:46,490 --> 00:40:49,549
could go ahead and under set ascending

937
00:40:49,549 --> 00:40:52,279
your signal ones and take actions based

938
00:40:52,279 --> 00:40:54,230
on that there's a few little

939
00:40:54,230 --> 00:40:55,849
miscellaneous steps as well that we need

940
00:40:55,849 --> 00:40:58,760
to talk about so you need to have these

941
00:40:58,760 --> 00:41:00,799
instructions in your command your

942
00:41:00,799 --> 00:41:03,410
program so get an instrumenting compiler

943
00:41:03,410 --> 00:41:05,510
your assembler of course needs to be

944
00:41:05,510 --> 00:41:07,520
able to recognize these instructions as

945
00:41:07,520 --> 00:41:11,720
well so we extend an assembler any see

946
00:41:11,720 --> 00:41:13,760
any assembly code that's in your runtime

947
00:41:13,760 --> 00:41:15,440
needs to be passed to include these

948
00:41:15,440 --> 00:41:17,359
instructions as well or what the CFI

949
00:41:17,359 --> 00:41:19,130
subsystem will detect on software

950
00:41:19,130 --> 00:41:21,799
violations unnecessarily and well then

951
00:41:21,799 --> 00:41:23,599
we go ahead and compile some stuff and

952
00:41:23,599 --> 00:41:25,250
when you do that you're going to see

953
00:41:25,250 --> 00:41:28,029
that so on average one to two percent

954
00:41:28,029 --> 00:41:31,640
performance overhead and well relative

955
00:41:31,640 --> 00:41:35,329
to the number of course and indirect

956
00:41:35,329 --> 00:41:36,920
jobs that you have on your binary you're

957
00:41:36,920 --> 00:41:39,770
going to see a slight increase in your

958
00:41:39,770 --> 00:41:42,559
resulting binaries in or testing with so

959
00:41:42,559 --> 00:41:46,970
about 13 percent or so now there have

960
00:41:46,970 --> 00:41:48,410
been other guys that have attempted to

961
00:41:48,410 --> 00:41:50,630
do this before us as well so we should

962
00:41:50,630 --> 00:41:53,180
give them credit for the work as well we

963
00:41:53,180 --> 00:41:56,359
have cuido at all in 2006 with

964
00:41:56,359 --> 00:41:59,059
architectural support for CFI however

965
00:41:59,059 --> 00:42:02,210
they only give us four core screen

966
00:42:02,210 --> 00:42:05,390
backward edge return policy land here

967
00:42:05,390 --> 00:42:07,910
gives you also coarse grain forward and

968
00:42:07,910 --> 00:42:10,400
backward edge of policy for CFI as well

969
00:42:10,400 --> 00:42:14,119
this is actually kind of good but

970
00:42:14,119 --> 00:42:17,869
can be sadly bypassed we have also HD fi

971
00:42:17,869 --> 00:42:19,819
which one best paper award this year as

972
00:42:19,819 --> 00:42:23,509
well it provides a fine grain forward

973
00:42:23,509 --> 00:42:25,430
and backward edge support but it only

974
00:42:25,430 --> 00:42:27,410
does it on single threaded embedded

975
00:42:27,410 --> 00:42:28,970
systems or you don't have multi-touch

976
00:42:28,970 --> 00:42:31,099
screen you don't have an operating

977
00:42:31,099 --> 00:42:32,749
system behind this thing you don't have

978
00:42:32,749 --> 00:42:35,720
shared libraries and this year as well

979
00:42:35,720 --> 00:42:39,710
until I release our the control on their

980
00:42:39,710 --> 00:42:41,990
own control of flow policy extension for

981
00:42:41,990 --> 00:42:44,240
the CPUs they apparently have been

982
00:42:44,240 --> 00:42:46,369
working on this for quite a bit now they

983
00:42:46,369 --> 00:42:48,980
have a built in however a shadow stack

984
00:42:48,980 --> 00:42:50,630
as well they get a new razor for this

985
00:42:50,630 --> 00:42:52,640
the shadow stack pointer that you are a

986
00:42:52,640 --> 00:42:54,440
couple of instructions to manipulate

987
00:42:54,440 --> 00:42:56,289
this shadow stack pointer as well

988
00:42:56,289 --> 00:42:59,480
however it suffers a bit when it comes

989
00:42:59,480 --> 00:43:02,869
to forward edges any indirect jumps or

990
00:43:02,869 --> 00:43:06,589
calls in Intel's SEFI they can target

991
00:43:06,589 --> 00:43:09,589
any branch end instruction there is

992
00:43:09,589 --> 00:43:12,349
really there's a course claim policy

993
00:43:12,349 --> 00:43:15,559
there so comparing your approach to the

994
00:43:15,559 --> 00:43:18,170
other guys well ACF try has some very

995
00:43:18,170 --> 00:43:20,809
nice performance overhead however they

996
00:43:20,809 --> 00:43:23,599
use the D on three processor implement

997
00:43:23,599 --> 00:43:25,579
implement in this park version eight

998
00:43:25,579 --> 00:43:28,809
instruction set and they use some very

999
00:43:28,809 --> 00:43:31,249
architecture specific optimizations like

1000
00:43:31,249 --> 00:43:33,049
putting things on the upike window

1001
00:43:33,049 --> 00:43:35,289
bottom branch on branching structure

1002
00:43:35,289 --> 00:43:37,730
instructions and things like that and

1003
00:43:37,730 --> 00:43:41,200
will intercept your mayor implementation

1004
00:43:41,200 --> 00:43:44,509
any call or jump instruction can target

1005
00:43:44,509 --> 00:43:46,880
any end branch instruction that makes it

1006
00:43:46,880 --> 00:43:50,420
rather weak for a sophisticated attacker

1007
00:43:50,420 --> 00:43:52,369
that's been said that's all we got guys

1008
00:43:52,369 --> 00:43:54,559
if you have any questions or feel free

1009
00:43:54,559 --> 00:44:07,069
to ask thank you what's the response

1010
00:44:07,069 --> 00:44:09,349
which it manifests available in this

1011
00:44:09,349 --> 00:44:12,109
part of the chip manifest is one two

1012
00:44:12,109 --> 00:44:16,880
images so what we said at the back end

1013
00:44:16,880 --> 00:44:19,069
of the talk is that Intel is actually

1014
00:44:19,069 --> 00:44:21,499
pursuing this and they're interested in

1015
00:44:21,499 --> 00:44:23,329
doing the control flow enforcement

1016
00:44:23,329 --> 00:44:25,309
technology for shadow stack one of the

1017
00:44:25,309 --> 00:44:27,830
issues is eyeshadow sack

1018
00:44:27,830 --> 00:44:29,660
Harbor shadow effect sort of guarantees

1019
00:44:29,660 --> 00:44:31,460
this really fine grained backward at sea

1020
00:44:31,460 --> 00:44:33,950
of five policy and an open issue is the

1021
00:44:33,950 --> 00:44:37,400
forward edge mechanism I think that when

1022
00:44:37,400 --> 00:44:40,250
it is released and produced that

1023
00:44:40,250 --> 00:44:42,290
potentially you know other manufacturers

1024
00:44:42,290 --> 00:44:44,240
will jump on board considering that

1025
00:44:44,240 --> 00:44:46,070
these sort of rock style attacks are

1026
00:44:46,070 --> 00:44:48,650
still prevalent and there shouldn't be

1027
00:44:48,650 --> 00:44:50,120
right because there are solutions that

1028
00:44:50,120 --> 00:44:55,120
can prevent them this is your hundred

1029
00:44:55,120 --> 00:44:57,710
ninety nine changes compounded by the

1030
00:44:57,710 --> 00:45:00,640
destruction what some call optimization

1031
00:45:00,640 --> 00:45:03,970
that is you just a little washing

1032
00:45:03,970 --> 00:45:07,640
don't act so in the case of a tail call

1033
00:45:07,640 --> 00:45:09,590
optimization this is one of the others

1034
00:45:09,590 --> 00:45:12,580
knife corner cases that we came across

1035
00:45:12,580 --> 00:45:16,430
you effectively have a jump to where you

1036
00:45:16,430 --> 00:45:18,830
will normally have a call which means

1037
00:45:18,830 --> 00:45:21,860
that instead of just going and pushing a

1038
00:45:21,860 --> 00:45:24,680
value on your on your on your regular

1039
00:45:24,680 --> 00:45:27,230
stack and shuttle stack use go directly

1040
00:45:27,230 --> 00:45:28,550
to a new location

1041
00:45:28,550 --> 00:45:30,890
well the backward dish is actually check

1042
00:45:30,890 --> 00:45:33,860
on the original color so you go from A

1043
00:45:33,860 --> 00:45:36,320
to B but then from B G jump in to see

1044
00:45:36,320 --> 00:45:38,960
the shack actually happens back in a so

1045
00:45:38,960 --> 00:45:41,000
we don't really see that issue there

1046
00:45:41,000 --> 00:45:44,270
when we do the jump from B to C we never

1047
00:45:44,270 --> 00:45:47,120
see that backward edge we have to return

1048
00:45:47,120 --> 00:45:54,200
back in to be there so we we actually we

1049
00:45:54,200 --> 00:45:55,610
actually never saw the compiler

1050
00:45:55,610 --> 00:45:57,680
reintroducing any weird shenanigans in

1051
00:45:57,680 --> 00:46:01,070
there since we we tightly coupled or cs5

1052
00:46:01,070 --> 00:46:04,580
checks to our to explicitly to call when

1053
00:46:04,580 --> 00:46:06,620
the compiler sees a little optimization

1054
00:46:06,620 --> 00:46:08,420
they can make it can make their it

1055
00:46:08,420 --> 00:46:10,270
eliminates the call it also eliminates

1056
00:46:10,270 --> 00:46:12,440
any possible check that we will

1057
00:46:12,440 --> 00:46:16,930
introduce at a point for backward edges

1058
00:46:23,350 --> 00:46:32,780
so we basically Sarika and so we have

1059
00:46:32,780 --> 00:46:35,210
both implementations for the spark up

1060
00:46:35,210 --> 00:46:37,430
spark p8 and for x86

1061
00:46:37,430 --> 00:46:40,600
slash 64

1062
00:46:41,030 --> 00:46:43,640
for Delia and the social sector sector

1063
00:46:43,640 --> 00:46:45,740
extension right so I mean Jesus is on

1064
00:46:45,740 --> 00:46:47,930
your instructions already able to

1065
00:46:47,930 --> 00:46:50,780
benchmark on day six so we run it in a

1066
00:46:50,780 --> 00:46:53,900
cycle accurate emulator we use the yeah

1067
00:46:53,900 --> 00:46:55,580
so basically we're using a cycle

1068
00:46:55,580 --> 00:46:57,350
accurate emulator and so the performance

1069
00:46:57,350 --> 00:46:58,970
results are going to sort of vary with

1070
00:46:58,970 --> 00:47:01,400
respect to actual hardware right but in

1071
00:47:01,400 --> 00:47:04,280
general there's a long lineage of using

1072
00:47:04,280 --> 00:47:06,800
emulators and sort of getting semi

1073
00:47:06,800 --> 00:47:09,200
reliable results right within of course

1074
00:47:09,200 --> 00:47:12,890
a percent error all right good close

1075
00:47:12,890 --> 00:47:22,220
your second question okay I'm gonna come

1076
00:47:22,220 --> 00:47:27,530
in some of aggression yeah thanks for

1077
00:47:27,530 --> 00:47:29,940
attending talk guys yeah thank you

1078
00:47:29,940 --> 00:47:32,639
[Applause]

