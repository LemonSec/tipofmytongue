1
00:00:00,060 --> 00:00:02,009
Hey look like at thank you for coming

2
00:00:02,009 --> 00:00:05,490
and waking up early today we're going to

3
00:00:05,490 --> 00:00:09,000
talk about reverse engineering and I

4
00:00:09,000 --> 00:00:11,160
mean hopefully you're going to enjoy the

5
00:00:11,160 --> 00:00:14,790
troll which is the important bit of the

6
00:00:14,790 --> 00:00:17,720
talk so the tool is already on github

7
00:00:17,720 --> 00:00:20,670
it's free as in free software MIT

8
00:00:20,670 --> 00:00:23,390
license and BSD all the components are

9
00:00:23,390 --> 00:00:26,939
MIT and BSD you can do reverse

10
00:00:26,939 --> 00:00:28,980
engineering without doing any assembly

11
00:00:28,980 --> 00:00:32,159
and even without doing any C so if you

12
00:00:32,159 --> 00:00:34,500
know how to do some Lua scripting that

13
00:00:34,500 --> 00:00:36,300
should be enough to automate like a fair

14
00:00:36,300 --> 00:00:38,820
bit of reverse engineering this talk is

15
00:00:38,820 --> 00:00:40,050
really about taking a new approach to

16
00:00:40,050 --> 00:00:43,260
reverse engineering I have way too much

17
00:00:43,260 --> 00:00:46,079
content that said feel free to interrupt

18
00:00:46,079 --> 00:00:48,180
me raise your hand if you have questions

19
00:00:48,180 --> 00:00:50,250
and feel free to make some noise if you

20
00:00:50,250 --> 00:00:55,530
like it so why am I so this was my first

21
00:00:55,530 --> 00:00:59,850
research 'va at Def Con 16 that's like

22
00:00:59,850 --> 00:01:02,730
eight nine years ago now so it was about

23
00:01:02,730 --> 00:01:05,880
like finding I mean the way interruption

24
00:01:05,880 --> 00:01:08,430
10 in the bias was endo by all the

25
00:01:08,430 --> 00:01:11,310
industry was wrong and this led us to

26
00:01:11,310 --> 00:01:13,770
write a single exploit which would work

27
00:01:13,770 --> 00:01:16,290
against all the biases on the planet

28
00:01:16,290 --> 00:01:18,509
BitLocker as far as I know it was the

29
00:01:18,509 --> 00:01:20,689
first exploit against BitLocker

30
00:01:20,689 --> 00:01:23,729
TrueCrypt and all the minor full disk

31
00:01:23,729 --> 00:01:26,280
encryption software so that was kind of

32
00:01:26,280 --> 00:01:28,560
RAD the password was in plaintext in

33
00:01:28,560 --> 00:01:29,310
memory forever

34
00:01:29,310 --> 00:01:32,970
in all the software another research I

35
00:01:32,970 --> 00:01:35,100
did for Def Con and blackhat some time

36
00:01:35,100 --> 00:01:39,380
back was back during back during a bias

37
00:01:39,380 --> 00:01:42,509
so the state of the art back then was if

38
00:01:42,509 --> 00:01:44,009
you're familiar with the frack article

39
00:01:44,009 --> 00:01:46,100
from the people from call security

40
00:01:46,100 --> 00:01:48,570
basically the state of the art was like

41
00:01:48,570 --> 00:01:50,850
you take a bias you identify the

42
00:01:50,850 --> 00:01:53,520
checksumming routine you would inject a

43
00:01:53,520 --> 00:01:55,350
new function inside the bias which would

44
00:01:55,350 --> 00:01:57,600
be malicious and then compensate the

45
00:01:57,600 --> 00:01:59,700
bias and flash it back to your

46
00:01:59,700 --> 00:02:01,890
motherboard this way you could infect

47
00:02:01,890 --> 00:02:04,409
one motherboard so instead of doing this

48
00:02:04,409 --> 00:02:07,020
we took the bestop and sold BIOS

49
00:02:07,020 --> 00:02:10,080
available coreboot ensue bias and we

50
00:02:10,080 --> 00:02:12,420
engineered from scratch the the bias

51
00:02:12,420 --> 00:02:14,800
with malware in

52
00:02:14,800 --> 00:02:16,440
the benefit would be instead of

53
00:02:16,440 --> 00:02:18,700
infecting one motherboard we would

54
00:02:18,700 --> 00:02:21,130
infect 300 different motherboards and

55
00:02:21,130 --> 00:02:22,480
that was kind of cool

56
00:02:22,480 --> 00:02:24,640
so the MIT Technology Review was like

57
00:02:24,640 --> 00:02:26,920
wow that's a computer infection that can

58
00:02:26,920 --> 00:02:28,770
never be cured

59
00:02:28,770 --> 00:02:31,420
Forbes liked it to like they did a paper

60
00:02:31,420 --> 00:02:34,630
on it and stuff which leads like imaging

61
00:02:34,630 --> 00:02:36,730
the kind of you know online presence it

62
00:02:36,730 --> 00:02:39,550
gives me you mostly famous for writing

63
00:02:39,550 --> 00:02:42,910
malware more recently last year we

64
00:02:42,910 --> 00:02:46,170
presented at blackhat this attack on

65
00:02:46,170 --> 00:02:49,300
NetBIOS and SMB you should familiar with

66
00:02:49,300 --> 00:02:51,880
the traditional SMB relay attack from

67
00:02:51,880 --> 00:02:55,240
the 90s really we discovered that you

68
00:02:55,240 --> 00:02:56,800
can do the same thing from the internet

69
00:02:56,800 --> 00:02:59,170
and steal Active Directory credentials

70
00:02:59,170 --> 00:03:01,960
from the Internet that's work we did

71
00:03:01,960 --> 00:03:06,310
with my team at Salesforce and so we

72
00:03:06,310 --> 00:03:08,020
with the first attack against Windows 10

73
00:03:08,020 --> 00:03:10,960
the week it was released and there's no

74
00:03:10,960 --> 00:03:13,630
fixed against it so if you still allow a

75
00:03:13,630 --> 00:03:17,280
bound SMB traffic on the Windows Network

76
00:03:17,280 --> 00:03:20,980
basically there's no fix questions so

77
00:03:20,980 --> 00:03:22,709
far

78
00:03:22,709 --> 00:03:26,410
disclaimer so what I'm going to present

79
00:03:26,410 --> 00:03:28,540
today is my own research my employer

80
00:03:28,540 --> 00:03:30,220
doesn't want to be associated with it in

81
00:03:30,220 --> 00:03:34,930
any way which lead to this slide thanks

82
00:03:34,930 --> 00:03:36,070
to the Electronic Frontier Foundation

83
00:03:36,070 --> 00:03:39,310
for providing legal assistance they've

84
00:03:39,310 --> 00:03:41,650
been pretty amazing on this I mean if

85
00:03:41,650 --> 00:03:44,200
you do reverse engineering especially if

86
00:03:44,200 --> 00:03:46,450
like like I do you live in the US it's a

87
00:03:46,450 --> 00:03:49,180
serious matter and the folks from the e

88
00:03:49,180 --> 00:03:50,890
FF like you know provide free assistance

89
00:03:50,890 --> 00:03:52,810
and they actually have lawyers we are

90
00:03:52,810 --> 00:03:54,820
super competent on the topic and I could

91
00:03:54,820 --> 00:03:58,739
not afford anyway so kudos to them

92
00:03:58,739 --> 00:04:01,270
agenda so today we're going to talk

93
00:04:01,270 --> 00:04:02,980
about so the witchcraft compiler

94
00:04:02,980 --> 00:04:05,500
collection I'm gonna introduce quickly

95
00:04:05,500 --> 00:04:08,650
like what are the components I'm gonna

96
00:04:08,650 --> 00:04:11,380
show you how to transform a binary into

97
00:04:11,380 --> 00:04:13,780
a shared library so we will call this

98
00:04:13,780 --> 00:04:17,769
Libby fine then I will show you how to

99
00:04:17,769 --> 00:04:20,440
take a final binary and unlink it back

100
00:04:20,440 --> 00:04:23,020
to radical to relocate table object

101
00:04:23,020 --> 00:04:26,340
files that can later be relinked in

102
00:04:26,340 --> 00:04:30,630
the new binary or shared library then

103
00:04:30,630 --> 00:04:32,730
I'll show you how to transform a P file

104
00:04:32,730 --> 00:04:36,060
into an L F and then we do some proper

105
00:04:36,060 --> 00:04:39,660
witchcraft in particular I'll show you

106
00:04:39,660 --> 00:04:42,050
what you have like reflection like

107
00:04:42,050 --> 00:04:45,210
capabilities much like in Java but

108
00:04:45,210 --> 00:04:48,600
without a VM for binaries of course none

109
00:04:48,600 --> 00:04:50,030
of this is supposed to work

110
00:04:50,030 --> 00:04:53,610
so if if any of you are like computer

111
00:04:53,610 --> 00:04:55,139
science teacher or something like this

112
00:04:55,139 --> 00:04:57,510
you may get a stroke if we have doctors

113
00:04:57,510 --> 00:04:59,070
in the room like please monitor for each

114
00:04:59,070 --> 00:05:01,070
other

115
00:05:01,070 --> 00:05:03,750
okay let's do it I am way too much

116
00:05:03,750 --> 00:05:08,400
content so the the toolset is comprised

117
00:05:08,400 --> 00:05:10,830
of mostly three binaries there's a

118
00:05:10,830 --> 00:05:14,729
linker there's a compiler and there's a

119
00:05:14,729 --> 00:05:19,229
dynamic interpreter I call them compiler

120
00:05:19,229 --> 00:05:21,030
but they really take diner ease as an

121
00:05:21,030 --> 00:05:24,630
input and not source code and based on

122
00:05:24,630 --> 00:05:28,830
those binaries what I've built a number

123
00:05:28,830 --> 00:05:31,500
of utilities on top of them which are

124
00:05:31,500 --> 00:05:35,180
merely a script based on those tools so

125
00:05:35,180 --> 00:05:38,729
the targets I mean the host machine as

126
00:05:38,729 --> 00:05:41,039
the host machine has to be a Linux

127
00:05:41,039 --> 00:05:45,180
machine but the binaries we analyze not

128
00:05:45,180 --> 00:05:49,410
necessarily I'll show you in particular

129
00:05:49,410 --> 00:05:52,860
what you analyze dynamically arm

130
00:05:52,860 --> 00:05:56,910
binaries and Intel Linux machine without

131
00:05:56,910 --> 00:06:02,910
a VM let's start with the Libre fication

132
00:06:02,910 --> 00:06:06,660
so out of the three components wld is

133
00:06:06,660 --> 00:06:10,979
like the the linker witchcraft linker so

134
00:06:10,979 --> 00:06:13,590
when this Lybia fication thing where

135
00:06:13,590 --> 00:06:15,419
we're going to try to take a binary and

136
00:06:15,419 --> 00:06:19,190
transform it back into a shared library

137
00:06:19,460 --> 00:06:24,109
so let's let's just start with the demo

138
00:06:28,800 --> 00:06:31,240
you guys get to see this to be small

139
00:06:31,240 --> 00:06:44,339
isn't it but uh much better about that

140
00:06:44,339 --> 00:06:47,430
yeah okay

141
00:06:47,430 --> 00:06:56,159
so you read the source code of the demo

142
00:07:00,809 --> 00:07:03,819
so basically we're gonna take probe TPD

143
00:07:03,819 --> 00:07:05,979
somehow I'm gonna transform it into a

144
00:07:05,979 --> 00:07:08,889
shared library Pro FTP do so I'm gonna

145
00:07:08,889 --> 00:07:09,789
show you how that works

146
00:07:09,789 --> 00:07:12,490
and then this sicko does what basically

147
00:07:12,490 --> 00:07:14,439
use this DL app app to load the shared

148
00:07:14,439 --> 00:07:16,569
library in memory and it looks for a

149
00:07:16,569 --> 00:07:18,610
symbol inside the shared library called

150
00:07:18,610 --> 00:07:21,659
PR version get string which returns

151
00:07:21,659 --> 00:07:24,789
inside probe TPD the version of Pro FTP

152
00:07:24,789 --> 00:07:27,189
D we're just going to do a printf of

153
00:07:27,189 --> 00:07:32,229
that so how do we get private TPD to be

154
00:07:32,229 --> 00:07:35,550
transformed into a shared library

155
00:07:37,259 --> 00:07:41,559
basically the magic happens here so we -

156
00:07:41,559 --> 00:07:46,330
we take Pro FTP D we copy it into /tmp

157
00:07:46,330 --> 00:07:52,409
and then we defy it and automatically

158
00:07:52,409 --> 00:07:55,149
that's going to transform Pro TPD into a

159
00:07:55,149 --> 00:07:57,909
shared library so I'm gonna do it with

160
00:07:57,909 --> 00:07:59,680
the make file first and then we'll do it

161
00:07:59,680 --> 00:08:04,959
like manually so now if I run their

162
00:08:04,959 --> 00:08:09,159
generated executable demo one you can

163
00:08:09,159 --> 00:08:13,839
see that the version of pro FTP d dot s

164
00:08:13,839 --> 00:08:16,959
o is 1.3 dot 3 D and that really comes

165
00:08:16,959 --> 00:08:19,240
from it's really a function inside Pro

166
00:08:19,240 --> 00:08:23,289
FTP D so that's up right that's

167
00:08:23,289 --> 00:08:28,349
not supposed to work so how come it does

168
00:08:29,399 --> 00:08:31,990
so we did exactly this I can redo it

169
00:08:31,990 --> 00:08:34,750
manually if you like but so basically we

170
00:08:34,750 --> 00:08:37,448
copy privacy pin into /tmp we verify it

171
00:08:37,448 --> 00:08:40,360
it's initially an executable if you run

172
00:08:40,360 --> 00:08:41,419
the file comment on it

173
00:08:41,419 --> 00:08:43,460
tells us okay it's an executable and

174
00:08:43,460 --> 00:08:47,180
then the witchcraft linker will patch it

175
00:08:47,180 --> 00:08:49,700
somehow into a shared library and then

176
00:08:49,700 --> 00:08:54,410
we can invoke yeah we can invoke it and

177
00:08:54,410 --> 00:08:56,510
load it as a shared library which is

178
00:08:56,510 --> 00:08:58,940
what developin was doing what's amazing

179
00:08:58,940 --> 00:09:01,670
though so I mean if I look into /tmp I

180
00:09:01,670 --> 00:09:04,870
should have proved TPD things to there

181
00:09:04,870 --> 00:09:09,250
maybe okay let's do it manually

182
00:09:12,520 --> 00:09:14,930
okay so privacy PD right now is an

183
00:09:14,930 --> 00:09:23,540
executable WL d DB Phi preceding not

184
00:09:23,540 --> 00:09:28,040
that's not what I wanted to do - man

185
00:09:28,040 --> 00:09:29,720
asleep if I what's better

186
00:09:29,720 --> 00:09:32,630
and now if I ask it's okay what the type

187
00:09:32,630 --> 00:09:35,680
of this thing no it's a shared library

188
00:09:35,680 --> 00:09:36,940
okay

189
00:09:36,940 --> 00:09:43,850
what's amazing though it's also still in

190
00:09:43,850 --> 00:09:50,350
a valid executable what just happened

191
00:09:50,350 --> 00:09:51,530
okay

192
00:09:51,530 --> 00:09:59,150
this is so cool let's take a minute yeah

193
00:09:59,150 --> 00:10:00,500
I'm pretty proud of myself that was a

194
00:10:00,500 --> 00:10:02,380
good one

195
00:10:02,380 --> 00:10:06,080
okay so what do we really do we only

196
00:10:06,080 --> 00:10:09,020
really patch one byte so if we compare

197
00:10:09,020 --> 00:10:12,380
the original Pro FTP D with with the one

198
00:10:12,380 --> 00:10:16,460
we just patched we transformed into in

199
00:10:16,460 --> 00:10:20,300
the heater the ele feeder we basically

200
00:10:20,300 --> 00:10:22,280
just change the type from you and

201
00:10:22,280 --> 00:10:24,560
executable to your shared library and

202
00:10:24,560 --> 00:10:27,200
you would think that makes no sense it

203
00:10:27,200 --> 00:10:31,010
actually does the okay so that the

204
00:10:31,010 --> 00:10:35,150
source code I showed you there's a

205
00:10:35,150 --> 00:10:38,270
couple reason why this works there again

206
00:10:38,270 --> 00:10:41,840
if you a teacher in computer science you

207
00:10:41,840 --> 00:10:44,510
might be like that makes no sense but in

208
00:10:44,510 --> 00:10:47,000
reality if you're a hacker you might

209
00:10:47,000 --> 00:10:50,200
know the way a SLR is being introduced

210
00:10:50,200 --> 00:10:53,870
in the kernel when with that when did we

211
00:10:53,870 --> 00:10:55,070
introduce yes

212
00:10:55,070 --> 00:10:59,870
in the Linux kernel okay what's this at

213
00:10:59,870 --> 00:11:05,149
all okay randomization so the idea was

214
00:11:05,149 --> 00:11:06,620
like we'd like we'd like to have

215
00:11:06,620 --> 00:11:10,370
executable a return the random to

216
00:11:10,370 --> 00:11:12,949
execute at a different address for basic

217
00:11:12,949 --> 00:11:15,709
security reasons the idea being if you

218
00:11:15,709 --> 00:11:17,630
out code offsets that's not gonna work

219
00:11:17,630 --> 00:11:20,930
anymore so instead of recreating a world

220
00:11:20,930 --> 00:11:22,940
to Shane and it won't compile are and

221
00:11:22,940 --> 00:11:27,529
all that the trick in kernel 2.6 dot 16

222
00:11:27,529 --> 00:11:30,829
so that's over ten years ago was to say

223
00:11:30,829 --> 00:11:33,050
we're gonna make shared libraries

224
00:11:33,050 --> 00:11:35,329
executable because shared library is

225
00:11:35,329 --> 00:11:37,310
supposed to be I mean they can be loaded

226
00:11:37,310 --> 00:11:40,009
at at any address in memory okay and

227
00:11:40,009 --> 00:11:44,060
like non randomized executables so the

228
00:11:44,060 --> 00:11:45,740
trick in the kernel you can look at the

229
00:11:45,740 --> 00:11:49,970
patch for this 2.6 dot 16 and on was to

230
00:11:49,970 --> 00:11:54,170
say in candle and if the ELA feeder is

231
00:11:54,170 --> 00:11:56,889
of type eg exact which is the old

232
00:11:56,889 --> 00:12:00,170
executable way we fit sanity gene which

233
00:12:00,170 --> 00:12:02,120
is really a shared library then it's a

234
00:12:02,120 --> 00:12:05,930
valid executable and you can run it so

235
00:12:05,930 --> 00:12:08,120
what I just did by taking this private

236
00:12:08,120 --> 00:12:10,370
GPD binary which cannot be randomized

237
00:12:10,370 --> 00:12:12,459
because it was compiled this way and

238
00:12:12,459 --> 00:12:15,319
patching one byte is to create a non

239
00:12:15,319 --> 00:12:17,600
relocatable share library because it

240
00:12:17,600 --> 00:12:19,760
cannot be loaded at any address it's

241
00:12:19,760 --> 00:12:21,560
only valid if it executes at this given

242
00:12:21,560 --> 00:12:24,800
address but interestingly yeah it's

243
00:12:24,800 --> 00:12:26,690
still valid binary and now we can pass

244
00:12:26,690 --> 00:12:28,880
it to the elephant which is a function

245
00:12:28,880 --> 00:12:31,399
inside the dynamic linker responsible

246
00:12:31,399 --> 00:12:33,110
for yeah loading like your shared

247
00:12:33,110 --> 00:12:35,569
libraries and and and link relocations

248
00:12:35,569 --> 00:12:38,240
so the benefit is I don't get to do any

249
00:12:38,240 --> 00:12:40,130
of this manually myself the ELA pandas

250
00:12:40,130 --> 00:12:42,019
only work for me all I did was really

251
00:12:42,019 --> 00:12:47,029
patch one byte that's cool what thank

252
00:12:47,029 --> 00:12:53,959
you okay first a new seat belt that was

253
00:12:53,959 --> 00:12:58,880
the most normal demo of my talk okay

254
00:12:58,880 --> 00:13:01,290
let's play with Apache

255
00:13:01,290 --> 00:13:09,270
I like that one a lot okay I think I

256
00:13:09,270 --> 00:13:14,070
have to demo strategy let's start with

257
00:13:14,070 --> 00:13:16,190
that

258
00:13:19,820 --> 00:13:25,170
so basically I'm gonna call inside the C

259
00:13:25,170 --> 00:13:26,330
function

260
00:13:26,330 --> 00:13:29,400
I'm gonna call EP gets have a banner

261
00:13:29,400 --> 00:13:33,660
which is a function inside Apache Apache

262
00:13:33,660 --> 00:13:35,880
is already compiled as a shared library

263
00:13:35,880 --> 00:13:38,460
if you like because it supports this a

264
00:13:38,460 --> 00:13:42,180
lot okay so if we ask what is the fight

265
00:13:42,180 --> 00:13:48,600
type of Apache it's actually a shared

266
00:13:48,600 --> 00:13:51,600
object already okay because it's being

267
00:13:51,600 --> 00:13:55,260
compared with the SLR know the real

268
00:13:55,260 --> 00:13:58,140
bizarre bit get ready for this we're

269
00:13:58,140 --> 00:14:03,410
gonna compile this C code by linking

270
00:14:03,410 --> 00:14:08,610
against slash user is been Apache which

271
00:14:08,610 --> 00:14:10,890
is a binary right so you're not really

272
00:14:10,890 --> 00:14:16,470
supposed to do that if I look in

273
00:14:16,470 --> 00:14:23,970
particular at the way this binary is no

274
00:14:23,970 --> 00:14:28,080
linked you ready for this okay so this

275
00:14:28,080 --> 00:14:31,650
is listing all inside this new binary I

276
00:14:31,650 --> 00:14:34,050
just created all the shared libraries

277
00:14:34,050 --> 00:14:36,720
linked against it what do you think of

278
00:14:36,720 --> 00:14:46,440
the second one what and amazingly it

279
00:14:46,440 --> 00:14:52,860
works so this C function inside Apache

280
00:14:52,860 --> 00:14:55,350
we just called it from inside your own C

281
00:14:55,350 --> 00:14:57,390
code and in the semi you know in the

282
00:14:57,390 --> 00:15:00,120
same way this Apache function returns

283
00:15:00,120 --> 00:15:02,160
like you know a banner associated with

284
00:15:02,160 --> 00:15:05,310
like the current version of Apache this

285
00:15:05,310 --> 00:15:11,790
is cool what okay I can show you right

286
00:15:11,790 --> 00:15:15,140
now another way to do it

287
00:15:20,900 --> 00:15:24,090
so right now I did this statically right

288
00:15:24,090 --> 00:15:26,580
like I write my own code and I'm linking

289
00:15:26,580 --> 00:15:29,280
against either this pro CPD stuff we

290
00:15:29,280 --> 00:15:34,610
patched or Apache so the the witchcraft

291
00:15:34,610 --> 00:15:37,350
compiler also come with an interpreter

292
00:15:37,350 --> 00:15:39,210
which allows us to do this dynamically

293
00:15:39,210 --> 00:15:42,900
without writing any C code so the script

294
00:15:42,900 --> 00:15:45,030
is a fully script table language I'll

295
00:15:45,030 --> 00:15:47,100
explain you more about this but a way to

296
00:15:47,100 --> 00:15:48,900
do exactly the same thing in three lines

297
00:15:48,900 --> 00:15:52,170
of I don't exactly what kind of language

298
00:15:52,170 --> 00:15:56,070
that is it's actually the language of

299
00:15:56,070 --> 00:15:59,090
the witchcraft compiler which is

300
00:15:59,090 --> 00:16:03,570
reflected capi plus you are so we can

301
00:16:03,570 --> 00:16:06,660
call directly this function okay so this

302
00:16:06,660 --> 00:16:10,160
this loads are inside the dynamic

303
00:16:10,160 --> 00:16:13,650
witchcraft interpret our slash user bin

304
00:16:13,650 --> 00:16:15,960
Apache too it makes all the functions

305
00:16:15,960 --> 00:16:19,320
from Apache available to call inside the

306
00:16:19,320 --> 00:16:21,600
interpreter itself and we can just like

307
00:16:21,600 --> 00:16:22,700
Colette's

308
00:16:22,700 --> 00:16:25,320
but the result into a variable a and

309
00:16:25,320 --> 00:16:33,300
print a and if we run that hopefully yep

310
00:16:33,300 --> 00:16:36,080
the result is the same

311
00:16:36,080 --> 00:16:41,700
that was cool what okay so that's

312
00:16:41,700 --> 00:16:52,110
exactly what we just saw so the idea was

313
00:16:52,110 --> 00:16:54,300
to take to take a binary and transform

314
00:16:54,300 --> 00:16:56,220
it back in sorry to take a binary and

315
00:16:56,220 --> 00:16:57,360
transform it back into your shared

316
00:16:57,360 --> 00:17:01,680
library how about we take a binary and

317
00:17:01,680 --> 00:17:04,619
we transform it back into relocatable

318
00:17:04,619 --> 00:17:06,930
object files which is the typical a part

319
00:17:06,930 --> 00:17:11,839
of compiler before the linking process

320
00:17:11,869 --> 00:17:14,520
the benefit of this is even if I don't

321
00:17:14,520 --> 00:17:17,189
have the source code basically if I can

322
00:17:17,189 --> 00:17:19,980
come back to relocatable files I can

323
00:17:19,980 --> 00:17:22,230
reuse any function in there and link it

324
00:17:22,230 --> 00:17:25,280
into my own projects

325
00:17:25,390 --> 00:17:28,000
to put it in other words the typical

326
00:17:28,000 --> 00:17:29,980
approach to reverse engineering is so

327
00:17:29,980 --> 00:17:31,570
you have source code it gets compiled to

328
00:17:31,570 --> 00:17:33,940
really culpable objects and gets linked

329
00:17:33,940 --> 00:17:37,990
into binaries and typically the the way

330
00:17:37,990 --> 00:17:39,850
people do reverse engineering is like

331
00:17:39,850 --> 00:17:41,830
okay I'm gonna take those binaries and

332
00:17:41,830 --> 00:17:43,690
try to get back somehow to the source

333
00:17:43,690 --> 00:17:46,690
code there's a number of reason why this

334
00:17:46,690 --> 00:17:48,580
is not gonna work super well in

335
00:17:48,580 --> 00:17:52,060
particular well like the compiler add

336
00:17:52,060 --> 00:17:54,670
this on routine to it like you know

337
00:17:54,670 --> 00:17:56,710
we're working with an Intel Architecture

338
00:17:56,710 --> 00:17:58,510
so you have all the problem of like what

339
00:17:58,510 --> 00:18:00,550
is the size of an instruction on a Sisk

340
00:18:00,550 --> 00:18:03,730
machine things like this so instead of

341
00:18:03,730 --> 00:18:07,360
doing this yeah I'm just gonna use the

342
00:18:07,360 --> 00:18:09,250
witchcraft compiler collection which

343
00:18:09,250 --> 00:18:11,290
takes binaries as an input and gives

344
00:18:11,290 --> 00:18:18,130
back relocatable objects so I call it a

345
00:18:18,130 --> 00:18:20,590
compiler but it doesn't it doesn't at

346
00:18:20,590 --> 00:18:22,210
all work like a compiler right it

347
00:18:22,210 --> 00:18:24,480
doesn't take source code as an it but

348
00:18:24,480 --> 00:18:27,010
the reason we took we call it like this

349
00:18:27,010 --> 00:18:30,720
is the common line is very close to GCC

350
00:18:30,720 --> 00:18:35,950
so to get the same uppity you give it

351
00:18:35,950 --> 00:18:37,870
the binary as an impact instead of

352
00:18:37,870 --> 00:18:39,910
source code you give it pretty much the

353
00:18:39,910 --> 00:18:42,490
same the same arguments as you would

354
00:18:42,490 --> 00:18:45,400
with GCC and magically you get the same

355
00:18:45,400 --> 00:18:52,960
output so a and a thing to notice with

356
00:18:52,960 --> 00:18:55,510
WCC that the front end is built with

357
00:18:55,510 --> 00:18:59,410
lead BFD so it's actually what is would

358
00:18:59,410 --> 00:19:01,000
easily be FD you guys know what it

359
00:19:01,000 --> 00:19:03,150
stands for

360
00:19:03,150 --> 00:19:05,320
yeah big deal

361
00:19:05,320 --> 00:19:09,880
hahaha so the idea was like at some

362
00:19:09,880 --> 00:19:12,400
stage the new project we're like okay

363
00:19:12,400 --> 00:19:14,830
we'd like to have a uniform way to work

364
00:19:14,830 --> 00:19:18,490
across architectures and to work not

365
00:19:18,490 --> 00:19:20,500
only your across like you know physical

366
00:19:20,500 --> 00:19:22,530
architecture like arm emits or whatever

367
00:19:22,530 --> 00:19:27,370
but also across file formats so we BFG

368
00:19:27,370 --> 00:19:31,420
can work with like p files cough

369
00:19:31,420 --> 00:19:34,480
exotic stuff and the benefit of writing

370
00:19:34,480 --> 00:19:36,580
my compiler with this is that my input

371
00:19:36,580 --> 00:19:38,740
actually does not need to be any enough

372
00:19:38,740 --> 00:19:41,080
I can give it a P file as an input for

373
00:19:41,080 --> 00:19:43,270
instance and get an e LF has a nut but

374
00:19:43,270 --> 00:19:48,820
if I like what so I'm gonna show you a

375
00:19:48,820 --> 00:19:52,630
full demo of all these real inking thing

376
00:19:52,630 --> 00:20:02,620
works ok so this is a very small

377
00:20:02,620 --> 00:20:09,480
application which just prints the string

378
00:20:09,480 --> 00:20:11,890
but interestingly it has a whole bunch

379
00:20:11,890 --> 00:20:14,650
of free locations so not only I mean

380
00:20:14,650 --> 00:20:16,660
when when you importing functions like

381
00:20:16,660 --> 00:20:20,170
this for instance printf so you have a

382
00:20:20,170 --> 00:20:23,290
jump to like the procedure linkage table

383
00:20:23,290 --> 00:20:25,690
which has a pointer to the global offset

384
00:20:25,690 --> 00:20:28,900
table and basically when you execute the

385
00:20:28,900 --> 00:20:31,000
binary the dynamic linker is responsible

386
00:20:31,000 --> 00:20:33,100
for finding printf in the Lib C so

387
00:20:33,100 --> 00:20:34,990
knowing that printf is inside the deep

388
00:20:34,990 --> 00:20:37,929
sea is up coding inside your binary but

389
00:20:37,929 --> 00:20:39,640
it has to find the path for the Dipsy

390
00:20:39,640 --> 00:20:43,960
load it in memory and modify modify your

391
00:20:43,960 --> 00:20:48,280
got so that whenever you try to call

392
00:20:48,280 --> 00:20:51,730
this function ya the pointer inside the

393
00:20:51,730 --> 00:20:54,220
gut is gonna be initialized assuming you

394
00:20:54,220 --> 00:20:58,540
don't do lazy binding well anyway

395
00:20:58,540 --> 00:21:01,300
strings for instance like this this

396
00:21:01,300 --> 00:21:03,100
string in yellow or this string in

397
00:21:03,100 --> 00:21:05,230
yellow the in different sections right

398
00:21:05,230 --> 00:21:09,330
this the static strings end up in the

399
00:21:09,330 --> 00:21:14,820
read-only that a read-only data section

400
00:21:14,820 --> 00:21:19,510
so the text is referencing data which is

401
00:21:19,510 --> 00:21:21,100
in another section and there is a

402
00:21:21,100 --> 00:21:22,960
relocation for that and the dynamic

403
00:21:22,960 --> 00:21:24,760
linker pon execution is gonna initialize

404
00:21:24,760 --> 00:21:28,330
that true so long story short this

405
00:21:28,330 --> 00:21:30,130
covers all the type of common area

406
00:21:30,130 --> 00:21:32,380
locations right two other sections two

407
00:21:32,380 --> 00:21:35,290
functions and stuff like that so let's

408
00:21:35,290 --> 00:21:41,650
compile this quickly okay so this is the

409
00:21:41,650 --> 00:21:44,860
original binary it does a no blackhat

410
00:21:44,860 --> 00:21:48,580
okay big deal if we look at the make

411
00:21:48,580 --> 00:21:50,330
file

412
00:21:50,330 --> 00:21:53,570
so we're gonna take so first off okay

413
00:21:53,570 --> 00:21:55,850
the first line we do compiled small

414
00:21:55,850 --> 00:21:58,360
which has just run and prints blackhat

415
00:21:58,360 --> 00:22:04,120
then we use WCC to take small and

416
00:22:04,480 --> 00:22:07,280
produce a Reno katemel object file out

417
00:22:07,280 --> 00:22:12,700
of it okay and then rereading this

418
00:22:12,700 --> 00:22:16,100
relocatable object file into smoke - and

419
00:22:16,100 --> 00:22:22,120
the question is the small to run and

420
00:22:22,120 --> 00:22:25,210
does it produce the same outputs and

421
00:22:25,210 --> 00:22:29,500
possibly does it have the same checksum

422
00:22:30,010 --> 00:22:32,510
so the amazing thing is that small -

423
00:22:32,510 --> 00:22:34,610
does run and does produce the same

424
00:22:34,610 --> 00:22:40,300
output okay thank you okay

425
00:22:43,430 --> 00:22:47,510
and if we look at the checksums then not

426
00:22:47,510 --> 00:22:52,610
the same files so to be fully honest

427
00:22:52,610 --> 00:22:55,190
with you I don't have to yet all the

428
00:22:55,190 --> 00:22:58,310
type of relocation that I theory is

429
00:22:58,310 --> 00:23:02,330
supported by the Intel compiler I mean

430
00:23:02,330 --> 00:23:05,420
the Intel specification and four other

431
00:23:05,420 --> 00:23:07,400
architecture there's also other type of

432
00:23:07,400 --> 00:23:10,190
relocations so you lp's most welcome you

433
00:23:10,190 --> 00:23:12,170
should want to contribute to this - this

434
00:23:12,170 --> 00:23:14,120
- all like I think we have a good basis

435
00:23:14,120 --> 00:23:17,600
it works in you know typical cases now

436
00:23:17,600 --> 00:23:20,150
you you might find exotic binary or

437
00:23:20,150 --> 00:23:22,160
produce exotic binaries on people that

438
00:23:22,160 --> 00:23:24,680
are going to defeat the compiler feel

439
00:23:24,680 --> 00:23:26,150
free to submit them and to submit

440
00:23:26,150 --> 00:23:29,170
patches that would be great

441
00:23:29,170 --> 00:23:31,760
so that's pretty much what we just

442
00:23:31,760 --> 00:23:36,080
explained okay I think the next slide is

443
00:23:36,080 --> 00:23:41,919
my best slide ever you ready for this I

444
00:23:43,780 --> 00:23:47,320
think it's self-explanatory

445
00:23:48,220 --> 00:23:51,590
so we're gonna take a pee file and try

446
00:23:51,590 --> 00:23:55,580
to transform it into an e.l.f because

447
00:23:55,580 --> 00:23:57,400
why not

448
00:23:57,400 --> 00:24:00,440
so I'm actually gonna yeah let's do it

449
00:24:00,440 --> 00:24:02,740
manually

450
00:24:03,450 --> 00:24:17,250
so I'm gonna take chrome yep

451
00:24:17,250 --> 00:24:22,330
actually okay so I complete chrome into

452
00:24:22,330 --> 00:24:24,820
/tmp okay

453
00:24:24,820 --> 00:24:33,539
it's a 32-bit P file and we're gonna use

454
00:24:33,539 --> 00:24:38,860
WCC to transform it back into an object

455
00:24:38,860 --> 00:24:41,049
file so the comment line is very similar

456
00:24:41,049 --> 00:24:43,840
to GCC right if I want object files I

457
00:24:43,840 --> 00:24:47,379
use many C so the impact is going to be

458
00:24:47,379 --> 00:24:50,259
chrome and the output for instance /tmp

459
00:24:50,259 --> 00:24:54,970
chrome dot s so because why not or

460
00:24:54,970 --> 00:24:57,129
chrome dot oh here we go

461
00:24:57,129 --> 00:25:09,750
ah what did I do wrong

462
00:25:17,820 --> 00:25:20,620
okay please give you ants to your

463
00:25:20,620 --> 00:25:22,810
neighbor we all gonna worship the

464
00:25:22,810 --> 00:25:31,110
demigods together that's okay

465
00:25:31,110 --> 00:25:34,900
okay I'm out of sync we'd like you know

466
00:25:34,900 --> 00:25:37,780
I I keep patching the bug that people

467
00:25:37,780 --> 00:25:39,700
report on github so I'm not quite sure

468
00:25:39,700 --> 00:25:41,020
where this doesn't work but it's

469
00:25:41,020 --> 00:25:46,450
supposed to work so the idea is there

470
00:25:46,450 --> 00:25:49,300
again since we're using BFG as an iPad

471
00:25:49,300 --> 00:25:53,290
the I mean as a passing library the in

472
00:25:53,290 --> 00:25:54,970
pub does not strictly have to be any

473
00:25:54,970 --> 00:25:59,440
Aleph no good question what is the point

474
00:25:59,440 --> 00:26:01,840
in doing this because my connell doesn't

475
00:26:01,840 --> 00:26:04,930
have the NT primitives anyway right so

476
00:26:04,930 --> 00:26:07,450
like if chrome is asking like okay I

477
00:26:07,450 --> 00:26:09,670
need entry in the scroll whatever

478
00:26:09,670 --> 00:26:12,040
function from the from the Windows

479
00:26:12,040 --> 00:26:15,700
kernel my POSIX system is not gonna know

480
00:26:15,700 --> 00:26:16,980
what that is

481
00:26:16,980 --> 00:26:20,770
so you can still call pew functions this

482
00:26:20,770 --> 00:26:23,230
way so with the function you know if you

483
00:26:23,230 --> 00:26:25,330
have a function in chrome that you know

484
00:26:25,330 --> 00:26:28,210
you have identified as being useful and

485
00:26:28,210 --> 00:26:29,980
it's self-contained like it's not

486
00:26:29,980 --> 00:26:32,200
importing any function from the and

487
00:26:32,200 --> 00:26:34,570
chicken or anything like that that will

488
00:26:34,570 --> 00:26:38,110
work to do something better to be honest

489
00:26:38,110 --> 00:26:41,050
I think we could really run this chrome

490
00:26:41,050 --> 00:26:45,070
dot easy transformed into an e LF only

491
00:26:45,070 --> 00:26:49,270
win on a POSIX machine by using the API

492
00:26:49,270 --> 00:26:53,640
of wine which is basically already enf

493
00:26:53,640 --> 00:26:58,000
formatted and does provide somewhat an

494
00:26:58,000 --> 00:27:01,270
equivalent of an NT kernel this is left

495
00:27:01,270 --> 00:27:03,250
as an exercise to the reader if you want

496
00:27:03,250 --> 00:27:05,140
to salvage the patch correct I would

497
00:27:05,140 --> 00:27:11,710
absolutely take it okay there again I'm

498
00:27:11,710 --> 00:27:14,380
sorry I'm sorry for any computer science

499
00:27:14,380 --> 00:27:16,180
teacher right like that that's gonna be

500
00:27:16,180 --> 00:27:19,470
tough we're gonna run an OP and DSD

501
00:27:19,470 --> 00:27:24,870
binary naturally on Linux without a VM

502
00:27:24,870 --> 00:27:28,050
because why not

503
00:27:30,100 --> 00:27:36,140
okay so here it goes that the binary we

504
00:27:36,140 --> 00:27:40,940
gonna run so if I try to if I try to run

505
00:27:40,940 --> 00:27:46,700
it like this Bosch is telling me no such

506
00:27:46,700 --> 00:27:48,350
file or directory which is bizarre

507
00:27:48,350 --> 00:27:51,590
because the file exists right so if I

508
00:27:51,590 --> 00:27:54,170
ask Astraeus like okay why you're not

509
00:27:54,170 --> 00:27:56,300
running this open BSD binary when I try

510
00:27:56,300 --> 00:28:00,890
to execute it it tells me also no such

511
00:28:00,890 --> 00:28:02,480
file or directory hmm

512
00:28:02,480 --> 00:28:05,800
so even you know even exec V didn't work

513
00:28:05,800 --> 00:28:08,930
if you look at the kernel source code of

514
00:28:08,930 --> 00:28:11,020
what's happening when you try to do this

515
00:28:11,020 --> 00:28:14,090
basically when you try to so when you

516
00:28:14,090 --> 00:28:16,070
try to run the binary it gets loaded

517
00:28:16,070 --> 00:28:18,560
because it's a valid DLF it gets loaded

518
00:28:18,560 --> 00:28:21,380
in memory and then the kernel looks for

519
00:28:21,380 --> 00:28:24,950
the dynamic linker and the path of it of

520
00:28:24,950 --> 00:28:28,990
the dynamic linker of this binary is

521
00:28:36,880 --> 00:28:40,760
either the exec and D dot a so let me

522
00:28:40,760 --> 00:28:43,520
copy this so that the typical path of

523
00:28:43,520 --> 00:28:47,660
for a bsd binary let me verify to bsd

524
00:28:47,660 --> 00:28:56,450
binary by the way up and bsd okay so of

525
00:28:56,450 --> 00:28:59,510
course this dynamic linker path i don't

526
00:28:59,510 --> 00:29:01,550
have any such vital directory

527
00:29:01,550 --> 00:29:03,770
okay so the error message is really

528
00:29:03,770 --> 00:29:08,510
coming from the kernel okay so are we

529
00:29:08,510 --> 00:29:15,590
gonna run this on linux so I could patch

530
00:29:15,590 --> 00:29:17,900
the path of the dynamic linker to

531
00:29:17,900 --> 00:29:20,830
provide it the dynamic linker of Linux

532
00:29:20,830 --> 00:29:23,870
instead of doing this I'm gonna copy my

533
00:29:23,870 --> 00:29:26,330
real dynamic linker to the path that the

534
00:29:26,330 --> 00:29:28,760
binary is expecting that's a bit less

535
00:29:28,760 --> 00:29:35,110
intrusive then I have a problem of I

536
00:29:35,110 --> 00:29:41,060
mean the functions inside basically the

537
00:29:41,060 --> 00:29:41,900
name of the

538
00:29:41,900 --> 00:29:44,390
name of the Lib C inside the the OpenBSD

539
00:29:44,390 --> 00:29:46,940
binary is called Lib C dot s o dot 60

540
00:29:46,940 --> 00:29:50,870
2.0 even if you're not a Linux expert

541
00:29:50,870 --> 00:29:54,470
that's not the name of my my lip C

542
00:29:54,470 --> 00:29:57,890
library on Linux mine is really called

543
00:29:57,890 --> 00:30:00,680
Lib C dot s so that's six so we're gonna

544
00:30:00,680 --> 00:30:03,020
patch this I do this like a barbarian

545
00:30:03,020 --> 00:30:07,760
use it said okay so we're gonna patch

546
00:30:07,760 --> 00:30:09,770
this original binary transforming like

547
00:30:09,770 --> 00:30:15,290
this name by Lib C dot six and we're

548
00:30:15,290 --> 00:30:18,080
gonna model plus X and then it will

549
00:30:18,080 --> 00:30:20,030
almost run there will be one problem

550
00:30:20,030 --> 00:30:25,490
left is gonna ask me for a missing

551
00:30:25,490 --> 00:30:31,160
symbol at exit oh that does not exist on

552
00:30:31,160 --> 00:30:36,230
Linux machines but does exist on I mean

553
00:30:36,230 --> 00:30:38,720
is expected by the binary so basically

554
00:30:38,720 --> 00:30:43,010
the way around this is we create a stub

555
00:30:43,010 --> 00:30:46,130
for it in C we with the same function

556
00:30:46,130 --> 00:30:48,170
prototype at exit does nothing right

557
00:30:48,170 --> 00:30:50,690
basically coming these structures I mean

558
00:30:50,690 --> 00:30:52,580
it's initializing these structures so

559
00:30:52,580 --> 00:30:56,390
that when the binary exits you can go

560
00:30:56,390 --> 00:30:58,580
through these structures for the purpose

561
00:30:58,580 --> 00:31:00,320
of this demo we don't really care what's

562
00:31:00,320 --> 00:31:03,980
happening once you exit okay so we're

563
00:31:03,980 --> 00:31:05,900
gonna create this small shared library

564
00:31:05,900 --> 00:31:07,790
like this with missing function

565
00:31:07,790 --> 00:31:14,210
prototype and LD preload it okay so I

566
00:31:14,210 --> 00:31:16,250
can show you the original source code of

567
00:31:16,250 --> 00:31:19,280
the FMC dot C as it was compiled on the

568
00:31:19,280 --> 00:31:21,500
bsd machine it doesn't do anything

569
00:31:21,500 --> 00:31:23,150
interesting it basically there's a

570
00:31:23,150 --> 00:31:28,730
printf of static Toto static great and

571
00:31:28,730 --> 00:31:37,130
if we tap make it just did the printf

572
00:31:37,130 --> 00:31:40,570
phanie of static Toto buzz blah static

573
00:31:40,570 --> 00:31:44,840
so we just ran an open BSD binary not

574
00:31:44,840 --> 00:31:50,080
even Linux with the limit of this

575
00:31:50,840 --> 00:31:52,700
so this works because there's no system

576
00:31:52,700 --> 00:31:54,830
call down inside the banner itself right

577
00:31:54,830 --> 00:31:56,809
bykova system codes which are done

578
00:31:56,809 --> 00:31:59,419
basically down inside share libraries

579
00:31:59,419 --> 00:32:01,879
and by loading the appropriate shared

580
00:32:01,879 --> 00:32:05,360
libraries you know I'm tricking the

581
00:32:05,360 --> 00:32:07,610
system into like you know calling the

582
00:32:07,610 --> 00:32:09,710
right system call instead of calling our

583
00:32:09,710 --> 00:32:13,100
OpenBSD system calls now if the if the

584
00:32:13,100 --> 00:32:15,799
binary was for instance statically

585
00:32:15,799 --> 00:32:21,080
linked and was doing itself wrong system

586
00:32:21,080 --> 00:32:23,360
calls from the binary where we would

587
00:32:23,360 --> 00:32:25,070
have to we would have to trick it and

588
00:32:25,070 --> 00:32:27,169
like patch that inside the binary to

589
00:32:27,169 --> 00:32:30,070
compensate the system call make sense

590
00:32:30,070 --> 00:32:32,409
too easy

591
00:32:32,409 --> 00:32:39,309
let's call what any questions so far

592
00:32:39,309 --> 00:32:41,860
it's just you too easy

593
00:32:41,860 --> 00:32:47,299
okay binary reflection so that's that's

594
00:32:47,299 --> 00:32:53,480
that's beautiful so binary reflection

595
00:32:53,480 --> 00:32:55,009
what are we talking about you should

596
00:32:55,009 --> 00:32:57,499
tell me a reflection without a VM I

597
00:32:57,499 --> 00:32:59,090
don't even know what that's supposed to

598
00:32:59,090 --> 00:33:02,509
mean like let's say I would like I would

599
00:33:02,509 --> 00:33:05,059
like functions equivalent to reflection

600
00:33:05,059 --> 00:33:09,320
in Java so being able to load

601
00:33:09,320 --> 00:33:12,200
applications enumerate the function

602
00:33:12,200 --> 00:33:15,350
prototype instantiate them in memory and

603
00:33:15,350 --> 00:33:20,210
call them as I like so we're gonna do

604
00:33:20,210 --> 00:33:27,710
exactly that but without a VM so the the

605
00:33:27,710 --> 00:33:30,700
magic happens around DL open like like

606
00:33:30,700 --> 00:33:37,249
we showed initially so wsh is okay I

607
00:33:37,249 --> 00:33:40,149
showed you fourth Oh to unlink so the

608
00:33:40,149 --> 00:33:46,369
the dynamic linker I showed you the WCC

609
00:33:46,369 --> 00:33:49,789
the compiler now I'm gonna show you wsh

610
00:33:49,789 --> 00:33:53,779
which is the witchcraft shell so it's

611
00:33:53,779 --> 00:33:56,480
rebuilt around lua and the trick is

612
00:33:56,480 --> 00:33:59,690
whenever you load a shared library using

613
00:33:59,690 --> 00:34:04,340
GL open in memory POSIX says the dynamic

614
00:34:04,340 --> 00:34:04,850
linker

615
00:34:04,850 --> 00:34:09,020
as to keep a cache of all the functions

616
00:34:09,020 --> 00:34:10,790
loaded in memory along with their

617
00:34:10,790 --> 00:34:16,580
address so if I can dump that basically

618
00:34:16,580 --> 00:34:18,560
I know all the functions which exist in

619
00:34:18,560 --> 00:34:21,280
memory and I know we have to call them

620
00:34:21,280 --> 00:34:26,000
in terms of prototyping I can cheat even

621
00:34:26,000 --> 00:34:27,290
if I don't know exactly how many

622
00:34:27,290 --> 00:34:32,960
arguments the function expects I mean on

623
00:34:32,960 --> 00:34:35,900
a 64-bit machine basically imaging you

624
00:34:35,900 --> 00:34:37,489
have a function taking three arguments

625
00:34:37,489 --> 00:34:39,170
what happened if I pass it four

626
00:34:39,170 --> 00:34:41,150
arguments while I'm initializing an

627
00:34:41,150 --> 00:34:42,830
additional register which is not going

628
00:34:42,830 --> 00:34:45,980
to be used nobody cares if he was on a

629
00:34:45,980 --> 00:34:48,320
32-bit machine it would be like passing

630
00:34:48,320 --> 00:34:50,270
additional arguments on the stack which

631
00:34:50,270 --> 00:34:53,630
will also never be popped and never be

632
00:34:53,630 --> 00:34:56,330
pushed back so long story short you

633
00:34:56,330 --> 00:34:57,800
don't exactly need to know the exact

634
00:34:57,800 --> 00:35:02,710
prototype of a function to call them and

635
00:35:02,710 --> 00:35:05,690
notice that we didn't do any disassembly

636
00:35:05,690 --> 00:35:07,550
and we didn't do a need a compilation

637
00:35:07,550 --> 00:35:16,750
either ok I'm going to skip this for now

638
00:35:16,750 --> 00:35:20,920
too much text not cool

639
00:35:21,730 --> 00:35:26,750
proper witchcraft so assume for now we

640
00:35:26,750 --> 00:35:29,720
get this reflection stuff to work and I

641
00:35:29,720 --> 00:35:31,910
did basically a very small blue

642
00:35:31,910 --> 00:35:34,400
interpreter just so that I can get back

643
00:35:34,400 --> 00:35:36,680
the result of my functions and I can

644
00:35:36,680 --> 00:35:41,000
pass arguments easily ok so the

645
00:35:41,000 --> 00:35:43,040
resulting programming language which is

646
00:35:43,040 --> 00:35:46,670
basically reflected c-plus you are I

647
00:35:46,670 --> 00:35:50,030
call that punk C because it allows you

648
00:35:50,030 --> 00:35:56,210
to write almost C with some tricks so

649
00:35:56,210 --> 00:35:58,430
that the language of the the interpreter

650
00:35:58,430 --> 00:36:01,040
itself you can type the comments

651
00:36:01,040 --> 00:36:04,730
directly inside wsh or you type all the

652
00:36:04,730 --> 00:36:06,200
comments the exact comments you would

653
00:36:06,200 --> 00:36:08,390
type in the interpreter you write them

654
00:36:08,390 --> 00:36:09,410
in a text file

655
00:36:09,410 --> 00:36:12,770
you call that W SH and this is it the

656
00:36:12,770 --> 00:36:15,020
witchcraft child will understand that

657
00:36:15,020 --> 00:36:17,300
those are comment and this is a script

658
00:36:17,300 --> 00:36:20,240
of course you can use the traditional

659
00:36:20,240 --> 00:36:22,470
shebang mechanism if you don't want to

660
00:36:22,470 --> 00:36:27,660
call it top WH the more time so I'm

661
00:36:27,660 --> 00:36:29,190
gonna show you this is gonna go really

662
00:36:29,190 --> 00:36:37,140
fast but uh but this is cool so here is

663
00:36:37,140 --> 00:36:42,360
the script I'm gonna execute okay you

664
00:36:42,360 --> 00:36:43,800
can see that I'm basically typing

665
00:36:43,800 --> 00:36:45,630
comments in there they're gonna be

666
00:36:45,630 --> 00:36:53,340
executed okay this is gonna be too fast

667
00:36:53,340 --> 00:36:54,990
but this is going to show you a bit like

668
00:36:54,990 --> 00:36:56,520
what are all the capabilities of this

669
00:36:56,520 --> 00:37:02,580
tool so we can load libraries I can load

670
00:37:02,580 --> 00:37:05,910
Apache if I ask em show me the libraries

671
00:37:05,910 --> 00:37:09,120
in memory there's more libraries okay I

672
00:37:09,120 --> 00:37:11,790
can get a mapping of the programming

673
00:37:11,790 --> 00:37:14,250
leader all the section leaders to verify

674
00:37:14,250 --> 00:37:16,140
its consistent I can actually breathe

675
00:37:16,140 --> 00:37:18,330
for the address space using em sync

676
00:37:18,330 --> 00:37:20,970
which is a function which is supposed to

677
00:37:20,970 --> 00:37:23,370
synchronize back a page to disk if it's

678
00:37:23,370 --> 00:37:25,170
mapped so this allows you to brute-force

679
00:37:25,170 --> 00:37:29,030
anything even if /proc is not available

680
00:37:29,030 --> 00:37:31,920
but the EEP which is not back by files

681
00:37:31,920 --> 00:37:35,190
unless using a map whatever you can call

682
00:37:35,190 --> 00:37:37,650
things like get peed you can get like a

683
00:37:37,650 --> 00:37:39,420
list of all the functions available in

684
00:37:39,420 --> 00:37:43,950
memory and their addresses you can call

685
00:37:43,950 --> 00:37:46,410
those functions you can ask information

686
00:37:46,410 --> 00:37:51,120
about memory location you can grab so

687
00:37:51,120 --> 00:37:54,840
you can grab stuff in memory the result

688
00:37:54,840 --> 00:37:57,270
of grab being a function itself you can

689
00:37:57,270 --> 00:37:59,940
turn that into G so that you can

690
00:37:59,940 --> 00:38:02,070
dereference later on I explain you more

691
00:38:02,070 --> 00:38:06,330
about that you can search things in

692
00:38:06,330 --> 00:38:08,700
memory like functions by name you can

693
00:38:08,700 --> 00:38:10,410
call those functions like we just did

694
00:38:10,410 --> 00:38:15,180
before displaying banners we can use

695
00:38:15,180 --> 00:38:17,910
break points which are not back by

696
00:38:17,910 --> 00:38:21,390
interruption 13 by interruption 3 I'll

697
00:38:21,390 --> 00:38:23,580
explain you that too

698
00:38:23,580 --> 00:38:25,680
we can use C functions directly from the

699
00:38:25,680 --> 00:38:29,040
shell we can ex dump memory

700
00:38:29,040 --> 00:38:30,630
what else can we do we can get

701
00:38:30,630 --> 00:38:35,369
information about memory locations okay

702
00:38:35,369 --> 00:38:37,320
so if I do a malloc I can get the return

703
00:38:37,320 --> 00:38:42,450
pointer asking what it is so that is

704
00:38:42,450 --> 00:38:45,599
pretty trivial when the application

705
00:38:45,599 --> 00:38:47,880
crashes on the read or write and stuff

706
00:38:47,880 --> 00:38:49,980
like that the application does not die

707
00:38:49,980 --> 00:38:51,780
which is cool because it's not picture

708
00:38:51,780 --> 00:38:56,280
is based you can get context about all

709
00:38:56,280 --> 00:38:58,230
the functions you call I'm gonna do all

710
00:38:58,230 --> 00:39:00,020
that manually later on like don't worry

711
00:39:00,020 --> 00:39:02,540
for the peoples of my demo like just

712
00:39:02,540 --> 00:39:06,810
just assume this this stuff works so

713
00:39:06,810 --> 00:39:08,670
right now we're doing this with an Intel

714
00:39:08,670 --> 00:39:14,430
binary because we loaded like Apache and

715
00:39:14,430 --> 00:39:19,050
SSH in memory okay we can export either

716
00:39:19,050 --> 00:39:20,760
Zinn see if we want to compile them

717
00:39:20,760 --> 00:39:24,960
later on we can call main we can call

718
00:39:24,960 --> 00:39:27,570
md5 functions outside and stuff like

719
00:39:27,570 --> 00:39:29,550
that okay so that was cool but that

720
00:39:29,550 --> 00:39:31,470
wasn't an Intel binary why am i showing

721
00:39:31,470 --> 00:39:32,420
you this

722
00:39:32,420 --> 00:39:36,599
you ready for this okay we're gonna do

723
00:39:36,599 --> 00:39:40,380
the exact same thing but right now I

724
00:39:40,380 --> 00:39:43,830
cross-compiled wsh as a non binary and

725
00:39:43,830 --> 00:39:46,500
then using a web load of qmu which does

726
00:39:46,500 --> 00:39:50,130
G binary translation for me in memory so

727
00:39:50,130 --> 00:39:51,900
basically right now I'm running an arm

728
00:39:51,900 --> 00:39:55,380
by neri with a VM on my Linux machine

729
00:39:55,380 --> 00:39:58,200
which is Intel based and as you can see

730
00:39:58,200 --> 00:39:59,910
like basically the output of this

731
00:39:59,910 --> 00:40:01,619
comment is the same as the previous one

732
00:40:01,619 --> 00:40:05,430
so we can debug pretty much fully on

733
00:40:05,430 --> 00:40:09,900
binaries yeah with our VM that's also

734
00:40:09,900 --> 00:40:12,170
know what

735
00:40:15,730 --> 00:40:18,520
Thank You sin that was sin that was

736
00:40:18,520 --> 00:40:21,880
really fast I'm gonna redo it manually

737
00:40:21,880 --> 00:40:27,390
with you more slowly so let's stop wsh

738
00:40:27,390 --> 00:40:30,400
it typically expects a binary I mean you

739
00:40:30,400 --> 00:40:32,589
can pass it an optional binary as an

740
00:40:32,589 --> 00:40:40,140
argument so let's load for instance SSH

741
00:40:41,010 --> 00:40:46,089
so WH is routing SSH in memory I get a

742
00:40:46,089 --> 00:40:49,839
prompt back let's take a look at the

743
00:40:49,839 --> 00:40:54,760
comments available okay so all those are

744
00:40:54,760 --> 00:40:57,040
like built-in comments okay

745
00:40:57,040 --> 00:41:02,079
things like X dumping memory information

746
00:41:02,079 --> 00:41:05,049
about memory mappings information about

747
00:41:05,049 --> 00:41:10,329
symbols stuffed research so functions

748
00:41:10,329 --> 00:41:12,790
like grep which hello to which allow you

749
00:41:12,790 --> 00:41:16,569
to grab any map including the EEP you

750
00:41:16,569 --> 00:41:18,490
can load more than one library so for

751
00:41:18,490 --> 00:41:20,619
instance right now I can ask it ok show

752
00:41:20,619 --> 00:41:21,549
me the library

753
00:41:21,549 --> 00:41:24,220
show me the libraries that you have

754
00:41:24,220 --> 00:41:26,349
loaded into your address space it's

755
00:41:26,349 --> 00:41:28,809
worth understanding this is not right

756
00:41:28,809 --> 00:41:31,119
this is not working like a typical

757
00:41:31,119 --> 00:41:33,250
debugger where you have a debugger

758
00:41:33,250 --> 00:41:36,549
debugging at the baggy since I'm using

759
00:41:36,549 --> 00:41:40,390
DL open what the interpreter is doing is

760
00:41:40,390 --> 00:41:43,299
loading in this case SSH and all these

761
00:41:43,299 --> 00:41:45,700
dependencies inside the zone address

762
00:41:45,700 --> 00:41:48,220
space and not inside another address

763
00:41:48,220 --> 00:41:50,559
space the benefit is you don't need P

764
00:41:50,559 --> 00:41:57,700
trace and another advantage is that when

765
00:41:57,700 --> 00:42:01,359
the witchcraft interpreter is examining

766
00:42:01,359 --> 00:42:03,220
his own memory is at the same time

767
00:42:03,220 --> 00:42:04,990
examining like you know the memory of

768
00:42:04,990 --> 00:42:07,290
SSH or whatever program you know them

769
00:42:07,290 --> 00:42:10,299
so let's not one more program so for

770
00:42:10,299 --> 00:42:12,369
instance let's load like you know this

771
00:42:12,369 --> 00:42:15,809
world Apache in addition

772
00:42:19,780 --> 00:42:23,650
okay so after loading SSH I had 23

773
00:42:23,650 --> 00:42:26,410
libraries I also needed Apache so free I

774
00:42:26,410 --> 00:42:31,150
have more now okay now I have 28 and you

775
00:42:31,150 --> 00:42:33,100
can see that you know all the

776
00:42:33,100 --> 00:42:35,620
dependencies of both ssh and apache have

777
00:42:35,620 --> 00:42:40,390
been mapped in memory so what are the

778
00:42:40,390 --> 00:42:42,010
functions available for me to program

779
00:42:42,010 --> 00:42:45,330
with that a lot of common dysfunctions

780
00:42:45,330 --> 00:42:54,120
up to hobb so I have the library way

781
00:42:54,120 --> 00:42:57,760
when the function leaves the name of the

782
00:42:57,760 --> 00:42:59,620
function and then a bunch of information

783
00:42:59,620 --> 00:43:03,880
in this case I have like 8 5 8 about

784
00:43:03,880 --> 00:43:06,460
8,000 functions that are loaded in

785
00:43:06,460 --> 00:43:08,440
memory and then I can call directly for

786
00:43:08,440 --> 00:43:12,100
my interpreter okay

787
00:43:12,100 --> 00:43:14,560
let's search for stuff which returns

788
00:43:14,560 --> 00:43:24,100
versions for instance ok 17 so let's

789
00:43:24,100 --> 00:43:26,770
call API version string for instance we

790
00:43:26,770 --> 00:43:29,140
would assume returns the string which is

791
00:43:29,140 --> 00:43:31,870
like the function of leave APR which

792
00:43:31,870 --> 00:43:34,930
comes with Apache right so if I want to

793
00:43:34,930 --> 00:43:36,970
do this I can write something like this

794
00:43:36,970 --> 00:43:40,060
and that's why I used you ah it's to be

795
00:43:40,060 --> 00:43:42,820
able to you know lose valuable living in

796
00:43:42,820 --> 00:43:45,450
memory and existing and stuff like that

797
00:43:45,450 --> 00:43:47,590
so if I want to call it with zero

798
00:43:47,590 --> 00:43:50,680
arguments I just call it like this and

799
00:43:50,680 --> 00:43:56,650
hopefully about print of a is gonna

800
00:43:56,650 --> 00:44:00,430
return me the version of EBP ah this is

801
00:44:00,430 --> 00:44:09,970
C chord okay how about another one new

802
00:44:09,970 --> 00:44:12,899
get deep C version

803
00:44:15,240 --> 00:44:19,090
so if I wanted to pass it arguments I'll

804
00:44:19,090 --> 00:44:23,140
just write it something like this okay

805
00:44:23,140 --> 00:44:25,660
and I just called this function inside

806
00:44:25,660 --> 00:44:28,720
the lip see with argument for 1/4 1/4

807
00:44:28,720 --> 00:44:35,080
1/4 1/4 and that the version of my beep

808
00:44:35,080 --> 00:44:39,730
see this is also know what so the beauty

809
00:44:39,730 --> 00:44:42,790
of using the Wow

810
00:44:42,790 --> 00:44:45,820
is that you can return more than one

811
00:44:45,820 --> 00:44:51,010
return value so actually every time I

812
00:44:51,010 --> 00:44:52,630
call a function like this inside the

813
00:44:52,630 --> 00:44:55,030
interpreter it transparently also

814
00:44:55,030 --> 00:44:55,810
returns me

815
00:44:55,810 --> 00:44:57,970
this is your second variable a context

816
00:44:57,970 --> 00:45:01,300
which describes what happened when you

817
00:45:01,300 --> 00:45:05,980
try to execute this function so if I

818
00:45:05,980 --> 00:45:09,940
dump it it tells me when you try to do

819
00:45:09,940 --> 00:45:14,350
this call here so this function came

820
00:45:14,350 --> 00:45:16,750
from this library we called it with one

821
00:45:16,750 --> 00:45:20,830
argument okay one arguments arrow number

822
00:45:20,830 --> 00:45:25,050
is zero which means success no error and

823
00:45:25,050 --> 00:45:28,180
the return value with this and no signal

824
00:45:28,180 --> 00:45:30,700
was associated with this you may be what

825
00:45:30,700 --> 00:45:34,420
the point in doing this the point is to

826
00:45:34,420 --> 00:45:38,050
have automated function prototyping so

827
00:45:38,050 --> 00:45:40,690
let's take for instance we said lib a PR

828
00:45:40,690 --> 00:45:48,490
there's a building feather inside the

829
00:45:48,490 --> 00:45:52,379
interpreter so

830
00:45:58,650 --> 00:46:01,110
okay if I tell this is gonna look for

831
00:46:01,110 --> 00:46:04,080
any library which has APR into his name

832
00:46:04,080 --> 00:46:06,240
and you merit all the functions in them

833
00:46:06,240 --> 00:46:08,490
and call them with random arguments

834
00:46:08,490 --> 00:46:11,570
hopefully that's gonna somewhat crash

835
00:46:11,570 --> 00:46:14,090
okay so that's what it's doing right now

836
00:46:14,090 --> 00:46:18,210
so the colors mean like okay if you

837
00:46:18,210 --> 00:46:21,000
segmentation fault on a read like a

838
00:46:21,000 --> 00:46:24,060
typically ear is green it tried to read

839
00:46:24,060 --> 00:46:27,270
0 which is not mapped so that crashed

840
00:46:27,270 --> 00:46:29,820
when it's ready try to execute The

841
00:46:29,820 --> 00:46:36,600
Associated The Associated pointer so why

842
00:46:36,600 --> 00:46:42,800
is this cool well if I reload it okay

843
00:46:42,800 --> 00:46:47,880
that gene if I ask it in memory show me

844
00:46:47,880 --> 00:46:49,740
the prototype of all the functions

845
00:46:49,740 --> 00:46:52,340
you've learned through this execution

846
00:46:52,340 --> 00:46:55,410
it's gonna tell me okay I try to execute

847
00:46:55,410 --> 00:47:00,750
for instance I use printf and I

848
00:47:00,750 --> 00:47:02,610
discovered that the second argument is

849
00:47:02,610 --> 00:47:05,580
an impute argument so this is a notation

850
00:47:05,580 --> 00:47:08,370
on top of the prototype of the function

851
00:47:08,370 --> 00:47:10,890
if you ever read the source code of

852
00:47:10,890 --> 00:47:14,070
Microsoft because it leaked because you

853
00:47:14,070 --> 00:47:16,410
did some consulting for them or whatever

854
00:47:16,410 --> 00:47:20,340
hahaha they were trying at some stage to

855
00:47:20,340 --> 00:47:22,170
annotate every function like this like

856
00:47:22,170 --> 00:47:24,420
what is read what is written and what is

857
00:47:24,420 --> 00:47:27,800
executed the benefit for it being to do

858
00:47:27,800 --> 00:47:32,520
onion static analysis so basically the

859
00:47:32,520 --> 00:47:34,710
tool can discover this by itself by

860
00:47:34,710 --> 00:47:37,800
trying to execute you know with choosen

861
00:47:37,800 --> 00:47:40,860
arguments all those functions and it

862
00:47:40,860 --> 00:47:43,500
tells you for instance like okay this

863
00:47:43,500 --> 00:47:45,510
function here the first argument is a

864
00:47:45,510 --> 00:47:49,410
function pointer we did disassemble we

865
00:47:49,410 --> 00:47:57,030
didn t compile this is awesome what to

866
00:47:57,030 --> 00:47:58,380
be fair and L thought that would work

867
00:47:58,380 --> 00:48:02,460
but but it does so we can do stuff like

868
00:48:02,460 --> 00:48:09,000
grep let's grab for Lib for instance in

869
00:48:09,000 --> 00:48:10,830
all the address space so all the

870
00:48:10,830 --> 00:48:12,090
functions are all

871
00:48:12,090 --> 00:48:16,130
share libraries and all the mappings

872
00:48:16,160 --> 00:48:21,000
okay so let's grab and the return in a

873
00:48:21,000 --> 00:48:24,540
is actually a table which I can dump and

874
00:48:24,540 --> 00:48:26,850
it will contain all the offsets of a of

875
00:48:26,850 --> 00:48:30,750
you know that matched so it found like a

876
00:48:30,750 --> 00:48:33,120
hundred and seventy occurrences of Lib

877
00:48:33,120 --> 00:48:37,350
in memory this is way easier than trying

878
00:48:37,350 --> 00:48:42,890
to use a debugger or all disassembled so

879
00:48:42,920 --> 00:48:49,740
what are the functions do we have yeah I

880
00:48:49,740 --> 00:48:54,210
guess that'd be it for now okay a cool

881
00:48:54,210 --> 00:49:01,140
thing is you can export you can export a

882
00:49:01,140 --> 00:49:03,330
basic prototype for all those functions

883
00:49:03,330 --> 00:49:05,790
that will generate you see eaters so you

884
00:49:05,790 --> 00:49:09,270
can read Inc against shared libraries

885
00:49:09,270 --> 00:49:12,750
and to be honest you don't cut the fun

886
00:49:12,750 --> 00:49:14,910
you don't actually need you don't

887
00:49:14,910 --> 00:49:16,830
actually need for your compiler to be a

888
00:49:16,830 --> 00:49:18,870
P and you understand what you mean you

889
00:49:18,870 --> 00:49:20,190
don't need to pass them a whole lot of

890
00:49:20,190 --> 00:49:21,930
information you should just define the

891
00:49:21,930 --> 00:49:24,570
function pointer as a void star which is

892
00:49:24,570 --> 00:49:26,580
gonna be like eight bytes on a 64-bit

893
00:49:26,580 --> 00:49:28,290
machine and you don't even tell them how

894
00:49:28,290 --> 00:49:31,080
many argument the function take GCC is

895
00:49:31,080 --> 00:49:33,260
going to be happy with that

896
00:49:33,260 --> 00:49:38,400
which is cool okay so with the describe

897
00:49:38,400 --> 00:49:43,770
demo we did the arm one future work so

898
00:49:43,770 --> 00:49:45,630
if you want to contribute patches stuff

899
00:49:45,630 --> 00:49:50,010
I would really like right now my eat

900
00:49:50,010 --> 00:49:52,350
memory allocator is using the same

901
00:49:52,350 --> 00:49:55,740
memory allocator from the Lib C so Peeta

902
00:49:55,740 --> 00:49:56,420
Mellark

903
00:49:56,420 --> 00:50:02,520
then the binaries we analyzed this sucks

904
00:50:02,520 --> 00:50:04,230
because if we have a memory corruption

905
00:50:04,230 --> 00:50:07,800
I'm gonna corrupt also my EEP so using a

906
00:50:07,800 --> 00:50:11,070
secondary EEP a locator we done us to

907
00:50:11,070 --> 00:50:13,440
segregate that and when there is a

908
00:50:13,440 --> 00:50:15,090
memory corruption that which we are in

909
00:50:15,090 --> 00:50:17,820
the debug application we would then

910
00:50:17,820 --> 00:50:19,620
trigger memory corruption inside our own

911
00:50:19,620 --> 00:50:23,790
application so that would be cool we

912
00:50:23,790 --> 00:50:25,530
could do that using Peeta Mellark itself

913
00:50:25,530 --> 00:50:25,800
by

914
00:50:25,800 --> 00:50:29,190
defining another arena for the EEP but I

915
00:50:29,190 --> 00:50:32,130
think a secondary memory allocator by

916
00:50:32,130 --> 00:50:34,350
looking against you know another version

917
00:50:34,350 --> 00:50:36,330
of Malik or Jubilee as Malik

918
00:50:36,330 --> 00:50:41,850
would do remote debugging I've actually

919
00:50:41,850 --> 00:50:44,880
already merged this so if you look at

920
00:50:44,880 --> 00:50:47,900
the example on get up there's already an

921
00:50:47,900 --> 00:50:51,260
example of doing remote debugging

922
00:50:51,260 --> 00:50:54,360
process injection so something like if

923
00:50:54,360 --> 00:50:56,250
you have a running process could we

924
00:50:56,250 --> 00:51:01,290
inject wsh inside a running process the

925
00:51:01,290 --> 00:51:03,600
limitation I have right now is I

926
00:51:03,600 --> 00:51:06,750
explained you that when I patch when we

927
00:51:06,750 --> 00:51:08,310
take a binary and transform it into a

928
00:51:08,310 --> 00:51:10,320
shared library by patching one byte in

929
00:51:10,320 --> 00:51:14,460
the either the results in binary is not

930
00:51:14,460 --> 00:51:17,010
relocatable okay it's not a real share

931
00:51:17,010 --> 00:51:19,140
library in the sense it has to be mapped

932
00:51:19,140 --> 00:51:20,000
at a given address

933
00:51:20,000 --> 00:51:24,840
so to avoid conflicts I compile wsh with

934
00:51:24,840 --> 00:51:26,910
a custom linker script to give an

935
00:51:26,910 --> 00:51:28,740
address which is different from the one

936
00:51:28,740 --> 00:51:32,160
typical compilers would give you this

937
00:51:32,160 --> 00:51:34,140
means that it's not a shared library and

938
00:51:34,140 --> 00:51:38,100
I cannot inject it so yeah a bit of work

939
00:51:38,100 --> 00:51:42,180
to journalist shadow mapping internal

940
00:51:42,180 --> 00:51:44,130
tracing stuff like that something I

941
00:51:44,130 --> 00:51:47,430
really like is to use the output of L

942
00:51:47,430 --> 00:51:50,060
trace or s trace on the binary and

943
00:51:50,060 --> 00:51:52,560
transform that directly into a wsh

944
00:51:52,560 --> 00:51:57,240
script that's not too much work I think

945
00:51:57,240 --> 00:52:01,740
that should work for next time any

946
00:52:01,740 --> 00:52:04,100
questions

947
00:52:04,160 --> 00:52:07,160
yep

948
00:52:11,740 --> 00:52:15,310
I can't yet can we pass in the

949
00:52:15,310 --> 00:52:17,700
microphone

950
00:52:35,630 --> 00:52:39,290
yeah is there a risk that some kernel

951
00:52:39,290 --> 00:52:41,390
developer will see some of these bugs

952
00:52:41,390 --> 00:52:43,400
and try and fix it so it won't work in

953
00:52:43,400 --> 00:52:48,350
future um I mean the only thing we live

954
00:52:48,350 --> 00:52:54,279
ridging from the kernel is the fact that

955
00:52:55,120 --> 00:53:00,860
basically a SLR works I I don't think

956
00:53:00,860 --> 00:53:03,020
the trade-off would be you know in favor

957
00:53:03,020 --> 00:53:06,130
of breaking my to break my tool to

958
00:53:06,130 --> 00:53:08,750
destroy fifteen years of security on the

959
00:53:08,750 --> 00:53:11,150
Linux kernel so that's that's rather

960
00:53:11,150 --> 00:53:13,790
unlikely but honestly like all the stuff

961
00:53:13,790 --> 00:53:15,980
I'm using alike you know POSIX features

962
00:53:15,980 --> 00:53:18,230
the nut bugs so that's not gonna get

963
00:53:18,230 --> 00:53:20,420
fixed that's so that's that's how it's

964
00:53:20,420 --> 00:53:22,640
supposed to work I mean I understand

965
00:53:22,640 --> 00:53:25,910
it's counterintuitive but it's very much

966
00:53:25,910 --> 00:53:29,600
standard in particular the trick of

967
00:53:29,600 --> 00:53:32,330
using yellow pen and of them being the

968
00:53:32,330 --> 00:53:35,150
cache of the dynamic linker is not Lipsy

969
00:53:35,150 --> 00:53:37,280
specific it's a POSIX compliance

970
00:53:37,280 --> 00:53:39,830
requirement which means you don't have

971
00:53:39,830 --> 00:53:42,170
to use the Lipsy if you use micro Lipsy

972
00:53:42,170 --> 00:53:44,540
or other Lipsey's that's also going to

973
00:53:44,540 --> 00:53:46,810
work so it's fairly portable actually

974
00:53:46,810 --> 00:53:54,500
good question though Windows Windows I

975
00:53:54,500 --> 00:53:55,910
mean it's a good question because

976
00:53:55,910 --> 00:53:57,110
they're starting to be POSIX compliant

977
00:53:57,110 --> 00:54:00,200
to a degree with Ubuntu I haven't tried

978
00:54:00,200 --> 00:54:11,420
much to be honest yeah yeah it's it's

979
00:54:11,420 --> 00:54:14,260
yeah yeah it's a fair question

980
00:54:14,260 --> 00:54:19,970
it's worth trying to compile w-c-c on on

981
00:54:19,970 --> 00:54:22,400
Windows machine and let me know I

982
00:54:22,400 --> 00:54:25,010
haven't tried to be honest I I don't do

983
00:54:25,010 --> 00:54:31,040
a lot of window any other question well

984
00:54:31,040 --> 00:54:34,060
thank you for your time today

