1
00:00:00,030 --> 00:00:03,449
good morning my presentation is mainly

2
00:00:03,449 --> 00:00:06,000
about exploitation method that can be

3
00:00:06,000 --> 00:00:07,620
applied for you to the freeze and the

4
00:00:07,620 --> 00:00:08,280
whiplash

5
00:00:08,280 --> 00:00:10,980
my name is Quentin wind and here's a

6
00:00:10,980 --> 00:00:13,410
brief introduction of myself and the

7
00:00:13,410 --> 00:00:15,000
security research off angle and

8
00:00:15,000 --> 00:00:18,240
previously most of my time focusing on

9
00:00:18,240 --> 00:00:21,060
flash security find its vulnerabilities

10
00:00:21,060 --> 00:00:23,130
and keep track of the state of art of

11
00:00:23,130 --> 00:00:25,890
exploitation and many of the bugs

12
00:00:25,890 --> 00:00:28,080
I reported will be also made public

13
00:00:28,080 --> 00:00:29,570
through internet bug bounties and

14
00:00:29,570 --> 00:00:32,009
currently the top line contributor for

15
00:00:32,009 --> 00:00:34,110
this platform and maybe forever

16
00:00:34,110 --> 00:00:36,300
Jacqueline has stopped accepting new

17
00:00:36,300 --> 00:00:40,440
flash vulnerabilities you know in their

18
00:00:40,440 --> 00:00:43,320
opening they think flash Express no

19
00:00:43,320 --> 00:00:45,690
longer had the same impact as when they

20
00:00:45,690 --> 00:00:47,850
start so they will shipping the bomb

21
00:00:47,850 --> 00:00:50,370
here resource to open source

22
00:00:50,370 --> 00:00:54,480
infrastructure and the method local talk

23
00:00:54,480 --> 00:00:56,190
about today is developed during the

24
00:00:56,190 --> 00:01:00,210
research of T V 2016 1 & 7 which is the

25
00:01:00,210 --> 00:01:03,059
use of the free discover and recorded Oh

26
00:01:03,059 --> 00:01:07,380
be dismayed so here is the gen of my

27
00:01:07,380 --> 00:01:10,320
speech I will start with our start by

28
00:01:10,320 --> 00:01:12,240
introducing the basic ideas of our

29
00:01:12,240 --> 00:01:14,939
classical flash exploit works in how

30
00:01:14,939 --> 00:01:17,540
recently medications prevent class click

31
00:01:17,540 --> 00:01:21,570
next I will show a man method which can

32
00:01:21,570 --> 00:01:23,909
bypass these mitigations and then we'll

33
00:01:23,909 --> 00:01:26,970
do to exploit step by step with this

34
00:01:26,970 --> 00:01:30,990
method for CVE 2016 107 at the end of

35
00:01:30,990 --> 00:01:32,640
the talk I will also discuss how to

36
00:01:32,640 --> 00:01:36,180
exploit under 64 billion worm and how we

37
00:01:36,180 --> 00:01:39,680
know sin affects the exploitation

38
00:01:41,230 --> 00:01:44,450
so for the past three years maybe more

39
00:01:44,450 --> 00:01:47,480
the classical flash exploited as many

40
00:01:47,480 --> 00:01:49,520
about crop the land field of a vector

41
00:01:49,520 --> 00:01:52,490
object no matter what happened what type

42
00:01:52,490 --> 00:01:57,500
the bug is so for example here overflow

43
00:01:57,500 --> 00:02:00,860
and the x1 was started by spring vectors

44
00:02:00,860 --> 00:02:03,680
and leak memory hose by freeing some of

45
00:02:03,680 --> 00:02:05,990
the vectors so that when the bone grew

46
00:02:05,990 --> 00:02:08,479
buffer is created and it occupies one of

47
00:02:08,479 --> 00:02:10,520
the nerman holes and throught the lens

48
00:02:10,520 --> 00:02:12,500
field of the vector object are true

49
00:02:12,500 --> 00:02:15,260
during the works the rector with a very

50
00:02:15,260 --> 00:02:17,240
large length will be used to search the

51
00:02:17,240 --> 00:02:19,370
process memory for regarded shell-toes

52
00:02:19,370 --> 00:02:21,830
and buffers all kinds of structures to

53
00:02:21,830 --> 00:02:24,740
my need for exploited work and then

54
00:02:24,740 --> 00:02:26,420
finally the rope train will be triggered

55
00:02:26,420 --> 00:02:29,660
by a facebook function table and when it

56
00:02:29,660 --> 00:02:31,400
comes to use of the phrase the process

57
00:02:31,400 --> 00:02:34,040
is very similar with the proper hit

58
00:02:34,040 --> 00:02:37,160
memory layout the vulnerable object

59
00:02:37,160 --> 00:02:39,290
following one of the memory hosts will

60
00:02:39,290 --> 00:02:41,390
be released because of users are free

61
00:02:41,390 --> 00:02:43,430
and the autopilot with control vector

62
00:02:43,430 --> 00:02:48,590
data and after that when a member

63
00:02:48,590 --> 00:02:50,270
function or member property of this

64
00:02:50,270 --> 00:02:52,459
longing pointer is invoked a fully

65
00:02:52,459 --> 00:02:54,140
controllable memory right will corrupt

66
00:02:54,140 --> 00:02:56,450
one one of the last field of the vector

67
00:02:56,450 --> 00:02:59,000
object and we will find that across the

68
00:02:59,000 --> 00:03:01,459
director everything else goes like that

69
00:03:01,459 --> 00:03:05,720
out here overflow since the last field

70
00:03:05,720 --> 00:03:07,670
is located at beginning part of the

71
00:03:07,670 --> 00:03:09,950
vector buffer this American women to be

72
00:03:09,950 --> 00:03:13,640
crop it with wireless a flash even

73
00:03:13,640 --> 00:03:15,560
browser vulnerabilities so this

74
00:03:15,560 --> 00:03:17,600
technique has been very popular for the

75
00:03:17,600 --> 00:03:20,570
past years mainly because Adobe only

76
00:03:20,570 --> 00:03:23,780
speaks the vulnerability itself is that

77
00:03:23,780 --> 00:03:27,620
us mitigate the exploitation method so

78
00:03:27,620 --> 00:03:30,380
finally last December the popularity of

79
00:03:30,380 --> 00:03:32,720
hacking the hacking team / exploit

80
00:03:32,720 --> 00:03:35,330
played a major role for Dobis final

81
00:03:35,330 --> 00:03:37,550
decision so working with Google project

82
00:03:37,550 --> 00:03:40,489
0 Adobe as communications director and

83
00:03:40,489 --> 00:03:41,840
often the munication

84
00:03:41,840 --> 00:03:43,140
[Music]

85
00:03:43,140 --> 00:03:45,730
the last field is moved to the metadata

86
00:03:45,730 --> 00:03:48,880
part of the vector object only left with

87
00:03:48,880 --> 00:03:51,610
the verification field in the same

88
00:03:51,610 --> 00:03:54,670
position since the last field and the

89
00:03:54,670 --> 00:03:57,160
verification field are now in different

90
00:03:57,160 --> 00:03:59,260
memory block corrupt them at same time

91
00:03:59,260 --> 00:04:02,160
is not practical

92
00:04:02,160 --> 00:04:06,160
besides the vector mitigation Adobe also

93
00:04:06,160 --> 00:04:08,590
as verification fields to byte array

94
00:04:08,590 --> 00:04:11,140
which is not a very popular or relaxed

95
00:04:11,140 --> 00:04:14,580
structure that is widely used in exploit

96
00:04:14,580 --> 00:04:17,230
well the lens field and the verification

97
00:04:17,230 --> 00:04:19,570
fields are now still staying the same

98
00:04:19,570 --> 00:04:22,750
memory block although very rare powerful

99
00:04:22,750 --> 00:04:24,940
zero-day exploit including those used by

100
00:04:24,940 --> 00:04:28,030
Ponton we were able to rate the

101
00:04:28,030 --> 00:04:30,130
verification field first and then

102
00:04:30,130 --> 00:04:33,130
calculate a security value by XOR the

103
00:04:33,130 --> 00:04:34,990
lens field and the verification fuse and

104
00:04:34,990 --> 00:04:37,480
then crop them with the new value at the

105
00:04:37,480 --> 00:04:41,260
same time but this behavior is highly

106
00:04:41,260 --> 00:04:42,670
depends on the quality of the

107
00:04:42,670 --> 00:04:44,980
vulnerability to read and interrupt

108
00:04:44,980 --> 00:04:47,440
almost instant bug itself is capable of

109
00:04:47,440 --> 00:04:49,360
read and write enemies of the memory

110
00:04:49,360 --> 00:04:51,700
let's say a type confusion so even

111
00:04:51,700 --> 00:04:54,430
without corruption of the byte array the

112
00:04:54,430 --> 00:04:56,070
vulnerability itself can finish

113
00:04:56,070 --> 00:04:58,660
exploitation and to crop by the readers

114
00:04:58,660 --> 00:05:01,650
make the exploit code simpler to write

115
00:05:01,650 --> 00:05:04,900
and decide the length rotation isolated

116
00:05:04,900 --> 00:05:07,090
heap is also introduced into Adobe Flash

117
00:05:07,090 --> 00:05:09,640
right now there are many hit predictions

118
00:05:09,640 --> 00:05:12,150
inside flash

119
00:05:12,150 --> 00:05:15,220
well this technique is first explained

120
00:05:15,220 --> 00:05:18,310
in Google reactors blog and basically

121
00:05:18,310 --> 00:05:21,070
the data and the object are now staring

122
00:05:21,070 --> 00:05:23,950
in the different memory box so even if

123
00:05:23,950 --> 00:05:26,050
there's the use of the free we cannot

124
00:05:26,050 --> 00:05:28,690
control its memory with vector or byte

125
00:05:28,690 --> 00:05:32,110
array anymore yet it is still possible

126
00:05:32,110 --> 00:05:34,600
to control the Freid object with other

127
00:05:34,600 --> 00:05:36,400
class objects in the same field

128
00:05:36,400 --> 00:05:38,830
partition and that is something we're

129
00:05:38,830 --> 00:05:42,810
going to use later for our exploit work

130
00:05:42,900 --> 00:05:47,020
so in summary communications have

131
00:05:47,020 --> 00:05:49,210
disarmed the classical and popular flash

132
00:05:49,210 --> 00:05:51,590
exploit method and

133
00:05:51,590 --> 00:05:53,130
[Applause]

134
00:05:53,130 --> 00:05:56,170
before communication there may be to

135
00:05:56,170 --> 00:05:58,630
reflash exploring the wild for a month

136
00:05:58,630 --> 00:06:00,460
but after the mitigation there may be

137
00:06:00,460 --> 00:06:02,560
just one or two flash explore in the

138
00:06:02,560 --> 00:06:04,030
wild for half a year

139
00:06:04,030 --> 00:06:06,790
so the mitigation itself is very useful

140
00:06:06,790 --> 00:06:09,940
and powerful and today will minute focus

141
00:06:09,940 --> 00:06:11,830
on use of the fridge let's see how to

142
00:06:11,830 --> 00:06:15,270
bring this type of bug back to life so

143
00:06:15,270 --> 00:06:18,010
what is really necessary for use of the

144
00:06:18,010 --> 00:06:21,400
free bulwark in my opinion I think a rig

145
00:06:21,400 --> 00:06:23,500
primitive helps a lot and that is the

146
00:06:23,500 --> 00:06:27,040
past years flash exploit all shares so

147
00:06:27,040 --> 00:06:28,840
right now only with the red primitive

148
00:06:28,840 --> 00:06:31,900
can find regards and prefers to store

149
00:06:31,900 --> 00:06:34,300
shellcode and wrappers to set excluded

150
00:06:34,300 --> 00:06:36,880
bit of shellcode as we're talking about

151
00:06:36,880 --> 00:06:39,820
uses the free we were able to fake would

152
00:06:39,820 --> 00:06:42,130
function table by just memory occupation

153
00:06:42,130 --> 00:06:45,360
so right from the list not insensitive

154
00:06:45,360 --> 00:06:48,010
currently exploit can with primitive by

155
00:06:48,010 --> 00:06:50,500
tempering the land field of a vector

156
00:06:50,500 --> 00:06:55,870
object by the rate and other structures

157
00:06:55,870 --> 00:06:59,470
that work like a rate where our Provost

158
00:06:59,470 --> 00:07:02,800
temper start dress after a relaxed

159
00:07:02,800 --> 00:07:06,190
structure also by the rate and vector

160
00:07:06,190 --> 00:07:08,380
another only candidates there are other

161
00:07:08,380 --> 00:07:10,630
relaxed workers inside Adobe Flash and

162
00:07:10,630 --> 00:07:13,360
for proof of concept I will start with

163
00:07:13,360 --> 00:07:15,669
the simplest or relaxed structure the

164
00:07:15,669 --> 00:07:18,520
stirring object so if a class holds the

165
00:07:18,520 --> 00:07:20,620
screen inside a structure will be

166
00:07:20,620 --> 00:07:22,600
something like this there will be a

167
00:07:22,600 --> 00:07:24,880
working function table a reference cone

168
00:07:24,880 --> 00:07:28,270
other views at least contain a buffer

169
00:07:28,270 --> 00:07:31,510
and the last dedicate to a string but at

170
00:07:31,510 --> 00:07:33,040
the edge screen here I'm talking about

171
00:07:33,040 --> 00:07:36,010
it's not an ActionScript string so if it

172
00:07:36,010 --> 00:07:37,720
is really an ActionScript string it

173
00:07:37,720 --> 00:07:39,700
would be just a reference pointer here

174
00:07:39,700 --> 00:07:42,760
instead of a buffer any less but some

175
00:07:42,760 --> 00:07:44,560
class they choose to store the string

176
00:07:44,560 --> 00:07:48,660
inside with no further operations so

177
00:07:48,660 --> 00:07:51,400
they will use the self define light

178
00:07:51,400 --> 00:07:54,220
widget structure in spite of the high

179
00:07:54,220 --> 00:07:57,910
weight hit ActionScript string so

180
00:07:57,910 --> 00:08:00,520
somehow with the help of use of the free

181
00:08:00,520 --> 00:08:02,800
we were able to release the class memory

182
00:08:02,800 --> 00:08:05,440
and then control it normally by

183
00:08:05,440 --> 00:08:06,460
probation

184
00:08:06,460 --> 00:08:08,410
we're the start address of the string

185
00:08:08,410 --> 00:08:12,070
object and the NA desired value right

186
00:08:12,070 --> 00:08:14,199
now we're able to access the target

187
00:08:14,199 --> 00:08:16,509
memory through the string object and

188
00:08:16,509 --> 00:08:19,050
after dealing with the target memory

189
00:08:19,050 --> 00:08:21,669
let's assume we can release this class

190
00:08:21,669 --> 00:08:23,949
memory again and in the real world case

191
00:08:23,949 --> 00:08:25,509
I will show you how this step can be

192
00:08:25,509 --> 00:08:28,389
done but currently let's just assume the

193
00:08:28,389 --> 00:08:31,360
step can finish itself so when the class

194
00:08:31,360 --> 00:08:33,880
number is released again we can occupied

195
00:08:33,880 --> 00:08:36,339
with another bunch of data where start

196
00:08:36,339 --> 00:08:38,770
address can be another value and with

197
00:08:38,770 --> 00:08:41,289
such release and occupation over and

198
00:08:41,289 --> 00:08:43,929
over the string object becomes the rate

199
00:08:43,929 --> 00:08:46,480
primitive and that is the main idea of

200
00:08:46,480 --> 00:08:50,080
our exploitation method since there were

201
00:08:50,080 --> 00:08:52,510
- cycles off we'll leave an occupation

202
00:08:52,510 --> 00:08:54,910
the method is named as use of their user

203
00:08:54,910 --> 00:08:57,910
for free but this is maybe to ideal

204
00:08:57,910 --> 00:08:59,740
situation so let's come back to the

205
00:08:59,740 --> 00:09:02,320
beginning of the use of the free when

206
00:09:02,320 --> 00:09:04,290
the vulnerable object is released a

207
00:09:04,290 --> 00:09:06,490
structure may not contain a screen

208
00:09:06,490 --> 00:09:08,680
inside so we should occupy its class

209
00:09:08,680 --> 00:09:11,440
memory with other classes our selected

210
00:09:11,440 --> 00:09:14,190
classes would host is drawing inside and

211
00:09:14,190 --> 00:09:17,890
after the well because of isolated hip

212
00:09:17,890 --> 00:09:19,959
this to class memory should also stay in

213
00:09:19,959 --> 00:09:22,180
the same key partition and in the same

214
00:09:22,180 --> 00:09:22,630
side

215
00:09:22,630 --> 00:09:27,010
so after occupation will invoke the

216
00:09:27,010 --> 00:09:30,010
water function of the Dunham's pointer

217
00:09:30,010 --> 00:09:33,130
it is now the water function with the

218
00:09:33,130 --> 00:09:35,320
same effect but in the selected class

219
00:09:35,320 --> 00:09:38,650
memory is being indexed the key point is

220
00:09:38,650 --> 00:09:41,980
that such type confusion status wasn't

221
00:09:41,980 --> 00:09:45,760
expected by any of the function so this

222
00:09:45,760 --> 00:09:48,550
unexpected behavior may help us release

223
00:09:48,550 --> 00:09:51,940
the class memory and then when we are in

224
00:09:51,940 --> 00:09:53,650
the rate of primitive situations that we

225
00:09:53,650 --> 00:09:56,470
have discussed before so here are the

226
00:09:56,470 --> 00:09:57,190
basic steps

227
00:09:57,190 --> 00:09:58,630
turning our use of the free interval

228
00:09:58,630 --> 00:10:01,000
rate primitive but these are all

229
00:10:01,000 --> 00:10:03,550
abstract concepts so let's go through a

230
00:10:03,550 --> 00:10:05,529
real-world case to see how this actually

231
00:10:05,529 --> 00:10:10,630
works cv 2016 1 + 7 is the use of the

232
00:10:10,630 --> 00:10:14,589
phrase I discovered in P SDK class the

233
00:10:14,589 --> 00:10:17,020
SDK belongs to media core package I

234
00:10:17,020 --> 00:10:19,310
discovered package

235
00:10:19,310 --> 00:10:20,840
I think this package is firstly

236
00:10:20,840 --> 00:10:23,180
introducing to flash version 19 and I

237
00:10:23,180 --> 00:10:25,550
discovered this package by decompiling

238
00:10:25,550 --> 00:10:27,410
the player global file and across

239
00:10:27,410 --> 00:10:30,100
comparing it with this old version

240
00:10:30,100 --> 00:10:32,390
there were many classes and there this

241
00:10:32,390 --> 00:10:35,530
package but all of this classes and

242
00:10:35,530 --> 00:10:38,810
undocumented there is only some related

243
00:10:38,810 --> 00:10:42,170
information can be formed from another

244
00:10:42,170 --> 00:10:44,450
Adobe products called prime time players

245
00:10:44,450 --> 00:10:50,390
DK this SDK is many to use developed to

246
00:10:50,390 --> 00:10:53,390
as many use to develop TV based

247
00:10:53,390 --> 00:10:55,880
cross-platform application and for the

248
00:10:55,880 --> 00:10:58,280
PC environment the SDK is a bunch of

249
00:10:58,280 --> 00:11:01,970
ActionScript files so my best guess is

250
00:11:01,970 --> 00:11:04,550
that the package I found is the native

251
00:11:04,550 --> 00:11:07,880
it's a native implementation of this SDK

252
00:11:07,880 --> 00:11:10,760
inside Flash Player to accelerate the

253
00:11:10,760 --> 00:11:14,630
running speed apparently when the first

254
00:11:14,630 --> 00:11:16,670
time this package is introduced into

255
00:11:16,670 --> 00:11:20,810
flash at heaven be inserted tastic on

256
00:11:20,810 --> 00:11:23,690
many many memory corruption last August

257
00:11:23,690 --> 00:11:27,380
and after reporting them to Adobe to

258
00:11:27,380 --> 00:11:30,470
choose to remove the entire package from

259
00:11:30,470 --> 00:11:33,980
its next version so for that moment I

260
00:11:33,980 --> 00:11:36,290
just think maybe the whole package

261
00:11:36,290 --> 00:11:39,320
shouldn't be exposed to the developer

262
00:11:39,320 --> 00:11:42,500
but after half a year the whole package

263
00:11:42,500 --> 00:11:45,740
is back into a flash version 21 so the

264
00:11:45,740 --> 00:11:49,700
truth behind is finish fix all of this

265
00:11:49,700 --> 00:11:52,040
memory corruption takes time so Adobe

266
00:11:52,040 --> 00:11:55,250
use half a year to finish fix audit all

267
00:11:55,250 --> 00:11:58,040
of this box and reintroduce them into

268
00:11:58,040 --> 00:12:00,200
flash versions and one and the use of

269
00:12:00,200 --> 00:12:01,780
the free we're talking about here is

270
00:12:01,780 --> 00:12:04,310
discovered right after P SDK and

271
00:12:04,310 --> 00:12:06,910
immediate all packages back

272
00:12:06,910 --> 00:12:10,040
here's the code snippet - triggering the

273
00:12:10,040 --> 00:12:13,160
use of the free the only way to get an

274
00:12:13,160 --> 00:12:16,310
instance of P SDK is through is statical

275
00:12:16,310 --> 00:12:19,190
number property called little capital P

276
00:12:19,190 --> 00:12:23,480
SDK so apparently the class memory is

277
00:12:23,480 --> 00:12:25,730
constructed and initialized by

278
00:12:25,730 --> 00:12:27,800
ActionScript virtual machine the AVM

279
00:12:27,800 --> 00:12:28,670
itself

280
00:12:28,670 --> 00:12:30,620
so naturally the class memory should

281
00:12:30,620 --> 00:12:34,070
also be destructed and cleaned by AVM

282
00:12:34,070 --> 00:12:37,399
automatically but the weird part is that

283
00:12:37,399 --> 00:12:39,589
this class also contains a method called

284
00:12:39,589 --> 00:12:42,110
relief which can be invoked directly

285
00:12:42,110 --> 00:12:43,850
from the ActionScript level to

286
00:12:43,850 --> 00:12:46,490
explicitly release the class memory of P

287
00:12:46,490 --> 00:12:50,810
SDK well this is relative case for

288
00:12:50,810 --> 00:12:52,730
ActionScript objects normally other

289
00:12:52,730 --> 00:12:54,980
flash objects are completely managed by

290
00:12:54,980 --> 00:12:58,160
an MVC the garbage collector so the only

291
00:12:58,160 --> 00:12:59,839
way to actually release the class memory

292
00:12:59,839 --> 00:13:01,880
is you just don't use them so the

293
00:13:01,880 --> 00:13:03,800
reference count of this class will be 0

294
00:13:03,800 --> 00:13:06,620
and M MVC will scan all the objects and

295
00:13:06,620 --> 00:13:08,660
find the proper moment to actually

296
00:13:08,660 --> 00:13:11,089
release the class member but as this

297
00:13:11,089 --> 00:13:13,579
class is undocumented so we don't know

298
00:13:13,579 --> 00:13:18,380
if this release is necessary or not but

299
00:13:18,380 --> 00:13:21,050
at least the reference count wasn't

300
00:13:21,050 --> 00:13:23,870
clean after release so the atom

301
00:13:23,870 --> 00:13:25,579
reference pointer is still pointing to

302
00:13:25,579 --> 00:13:28,430
the class memory after release and women

303
00:13:28,430 --> 00:13:30,380
in woke the water function with this

304
00:13:30,380 --> 00:13:33,560
pointer there goes the over textbook use

305
00:13:33,560 --> 00:13:36,980
it for free so the root cause of this

306
00:13:36,980 --> 00:13:39,020
throne of vulnerabilities theory is that

307
00:13:39,020 --> 00:13:43,880
we understand let's go build a exploit P

308
00:13:43,880 --> 00:13:47,120
SDK takes 32 bytes there are two with a

309
00:13:47,120 --> 00:13:49,670
function table at beginning of this

310
00:13:49,670 --> 00:13:53,390
class memory all the member functions

311
00:13:53,390 --> 00:13:54,770
that can be invoked from the

312
00:13:54,770 --> 00:13:56,839
ActionScript level are index in the

313
00:13:56,839 --> 00:13:59,180
first word function table and the

314
00:13:59,180 --> 00:14:01,490
structure is index index in the second

315
00:14:01,490 --> 00:14:03,589
one but the destructor can only be

316
00:14:03,589 --> 00:14:07,520
invoked by mm GCV other views of this

317
00:14:07,520 --> 00:14:10,220
class are irrelevant to our ex-wife

318
00:14:10,220 --> 00:14:12,380
so I will skip some asteroid

319
00:14:12,380 --> 00:14:16,250
demonstration so after P SDK is released

320
00:14:16,250 --> 00:14:19,400
we should occupy s-class memory with

321
00:14:19,400 --> 00:14:22,790
another class as we discussed before so

322
00:14:22,790 --> 00:14:24,860
I manually checked all the classes and

323
00:14:24,860 --> 00:14:26,900
their media core package I think there

324
00:14:26,900 --> 00:14:29,530
are most likely the best candidates

325
00:14:29,530 --> 00:14:32,150
classes under the same package a very

326
00:14:32,150 --> 00:14:34,100
likely to implement in a similar way

327
00:14:34,100 --> 00:14:38,660
especially for their hip perdition so

328
00:14:38,660 --> 00:14:41,420
finally after several checks I pick

329
00:14:41,420 --> 00:14:44,980
track it contains to Springfield and

330
00:14:44,980 --> 00:14:48,350
after memory alignment track is in the

331
00:14:48,350 --> 00:14:51,710
same size of P SDK so meaning that when

332
00:14:51,710 --> 00:14:54,350
P SDK is released newly constructed

333
00:14:54,350 --> 00:14:57,530
tracks or the occupies memory and right

334
00:14:57,530 --> 00:15:00,350
now will invoke the water function of P

335
00:15:00,350 --> 00:15:02,750
SDK let's say the career dispatcher

336
00:15:02,750 --> 00:15:06,170
located at 14 hex of that it is now the

337
00:15:06,170 --> 00:15:08,540
virtual function of track being indexed

338
00:15:08,540 --> 00:15:12,680
and this type confusion function call

339
00:15:12,680 --> 00:15:15,110
treated the second double word of

340
00:15:15,110 --> 00:15:16,970
current class memory to be a reference

341
00:15:16,970 --> 00:15:19,700
count decrement it and release current

342
00:15:19,700 --> 00:15:22,670
memory if the reference count is 0 so

343
00:15:22,670 --> 00:15:24,800
this type confusion call is very like a

344
00:15:24,800 --> 00:15:28,250
destructor and the second double word of

345
00:15:28,250 --> 00:15:30,620
current class memory is happened to be

346
00:15:30,620 --> 00:15:33,320
the last field of the first ring object

347
00:15:33,320 --> 00:15:34,280
inside track

348
00:15:34,280 --> 00:15:36,650
so simply initialize track with the

349
00:15:36,650 --> 00:15:38,900
single character string can we control

350
00:15:38,900 --> 00:15:40,910
this field to be one and after the

351
00:15:40,910 --> 00:15:43,400
convention the memory of track will be

352
00:15:43,400 --> 00:15:45,980
released and right now we have a

353
00:15:45,980 --> 00:15:48,830
stunning pointer and type of track that

354
00:15:48,830 --> 00:15:52,340
is create advice but we still need to

355
00:15:52,340 --> 00:15:54,790
find a way to occupy the memory of track

356
00:15:54,790 --> 00:15:57,650
to control its content and release a

357
00:15:57,650 --> 00:16:00,620
class memory again and there I will

358
00:16:00,620 --> 00:16:03,710
introduce you step by to rate which is

359
00:16:03,710 --> 00:16:05,930
another which is a very handy function

360
00:16:05,930 --> 00:16:08,270
that almost born to finish the task that

361
00:16:08,270 --> 00:16:10,910
we have left it can occupy the memory of

362
00:16:10,910 --> 00:16:14,330
track and then release it at the same

363
00:16:14,330 --> 00:16:16,760
time to satisfy the race simply

364
00:16:16,760 --> 00:16:19,490
duplicate the input by to rate inside

365
00:16:19,490 --> 00:16:22,040
metadata and metadata also belongs to

366
00:16:22,040 --> 00:16:24,380
media called package so it is sharing

367
00:16:24,380 --> 00:16:28,850
the same condition with track P SDK self

368
00:16:28,850 --> 00:16:32,040
as rate will allocate a temporal space

369
00:16:32,040 --> 00:16:37,800
- pre-processing the input battery its

370
00:16:37,800 --> 00:16:40,380
encoding and the lens it's okay

371
00:16:40,380 --> 00:16:42,450
the instead of a delay will allocate

372
00:16:42,450 --> 00:16:44,850
another memory to save the content of

373
00:16:44,850 --> 00:16:47,640
this to save the content of this byte

374
00:16:47,640 --> 00:16:50,040
array and save the pointer inside

375
00:16:50,040 --> 00:16:53,250
metadata since this temporary space is

376
00:16:53,250 --> 00:16:55,890
first allocated if the input byte array

377
00:16:55,890 --> 00:16:59,040
is 32 bytes long the same size of P SDK

378
00:16:59,040 --> 00:17:01,050
the temporary space is what else

379
00:17:01,050 --> 00:17:09,300
occupies the memory of P SDK so we can

380
00:17:09,300 --> 00:17:11,790
just use a sort of device alarm by the

381
00:17:11,790 --> 00:17:14,220
rate and evokes that rather is the

382
00:17:14,220 --> 00:17:16,010
memory of track will be controlled and

383
00:17:16,010 --> 00:17:20,819
the best part of this is when an end of

384
00:17:20,819 --> 00:17:24,089
set up at array this temporal space will

385
00:17:24,089 --> 00:17:28,040
be released explicitly so meaning that

386
00:17:28,040 --> 00:17:30,690
the memory of tracks fitting with

387
00:17:30,690 --> 00:17:32,670
control content still being freed

388
00:17:32,670 --> 00:17:36,210
waiting for next occupation recall from

389
00:17:36,210 --> 00:17:39,000
the last part when P SDK is released

390
00:17:39,000 --> 00:17:42,030
tracks text position and type confusion

391
00:17:42,030 --> 00:17:43,830
function call release track memory again

392
00:17:43,830 --> 00:17:47,430
and for the rate primitives part each

393
00:17:47,430 --> 00:17:49,590
time we want to read access the target

394
00:17:49,590 --> 00:17:52,370
of memory will just use set by the rate

395
00:17:52,370 --> 00:17:55,800
with 32 bytes long byte arrays which is

396
00:17:55,800 --> 00:17:59,520
16 of that to be the target address the

397
00:17:59,520 --> 00:18:02,550
16 of that is happen to be the second

398
00:18:02,550 --> 00:18:07,380
string field inside track so up instead

399
00:18:07,380 --> 00:18:09,690
by the rate will invoke track stock

400
00:18:09,690 --> 00:18:11,490
language which is the second string

401
00:18:11,490 --> 00:18:14,870
field we can access the target memory

402
00:18:14,870 --> 00:18:17,880
right now address that the screen last

403
00:18:17,880 --> 00:18:20,250
before there is no need to be a large

404
00:18:20,250 --> 00:18:23,370
number 8,000 as the returning of the

405
00:18:23,370 --> 00:18:26,550
string object contains an encoding

406
00:18:26,550 --> 00:18:28,560
problem so if there's some special

407
00:18:28,560 --> 00:18:31,110
character in the string memory in the

408
00:18:31,110 --> 00:18:33,270
target memory the returning of the

409
00:18:33,270 --> 00:18:35,370
string will be broken and in that case

410
00:18:35,370 --> 00:18:39,090
we'll still need to read a target memory

411
00:18:39,090 --> 00:18:41,670
character of the character so just that

412
00:18:41,670 --> 00:18:44,700
last before so in most cases the

413
00:18:44,700 --> 00:18:45,660
returning value

414
00:18:45,660 --> 00:18:48,360
we'll be 4 bytes long he can easily

415
00:18:48,360 --> 00:18:51,630
convert it to the int value very can

416
00:18:51,630 --> 00:18:53,820
going to deal with with other part of

417
00:18:53,820 --> 00:18:59,850
off your exploit so right now we have

418
00:18:59,850 --> 00:19:01,710
the ability to read any part of the

419
00:19:01,710 --> 00:19:05,940
memory I think everything else can only

420
00:19:05,940 --> 00:19:07,440
limited by imagination there will be

421
00:19:07,440 --> 00:19:10,110
many options let's say we can rate a

422
00:19:10,110 --> 00:19:12,930
stable location spread with vector

423
00:19:12,930 --> 00:19:16,620
object others author electro-optic is

424
00:19:16,620 --> 00:19:19,430
filled with current class pointer this

425
00:19:19,430 --> 00:19:22,470
other vector cannot be used to be crop

426
00:19:22,470 --> 00:19:25,050
it and still a very feasible way for hip

427
00:19:25,050 --> 00:19:28,440
spring so when we rate a stable location

428
00:19:28,440 --> 00:19:32,340
we know that this pointer is located

429
00:19:32,340 --> 00:19:35,010
right after the metadata director object

430
00:19:35,010 --> 00:19:37,740
and with this pointer we can easily

431
00:19:37,740 --> 00:19:40,170
define other self defined variables

432
00:19:40,170 --> 00:19:43,650
inside our class let's say we can find

433
00:19:43,650 --> 00:19:46,370
the byte array that's during the track

434
00:19:46,370 --> 00:19:50,100
vector and there are started with 54 X

435
00:19:50,100 --> 00:19:55,140
offset width as we know the with simple

436
00:19:55,140 --> 00:19:56,790
reverse-engineering you can know the

437
00:19:56,790 --> 00:19:58,800
structure of this class so you can find

438
00:19:58,800 --> 00:20:00,600
a buffer inside to store a shellcode

439
00:20:00,600 --> 00:20:02,730
rope chain favorite function table and

440
00:20:02,730 --> 00:20:05,880
this trick is firstly used by hacking in

441
00:20:05,880 --> 00:20:07,970
splash exploit it is very efficient

442
00:20:07,970 --> 00:20:11,610
there is no need for total for searching

443
00:20:11,610 --> 00:20:15,930
of your self defined variables and after

444
00:20:15,930 --> 00:20:17,940
that we can use one of the water

445
00:20:17,940 --> 00:20:19,830
function table of this class to find a

446
00:20:19,830 --> 00:20:22,020
model based of Flash and start to search

447
00:20:22,020 --> 00:20:25,620
the rope rope carcass but for exploit

448
00:20:25,620 --> 00:20:28,140
and after every buffer is filled a

449
00:20:28,140 --> 00:20:32,100
linked set bat array is invoked one more

450
00:20:32,100 --> 00:20:33,990
time to prop the second word function

451
00:20:33,990 --> 00:20:38,040
table of P SDK the reason we choose the

452
00:20:38,040 --> 00:20:39,960
segment water function table instead of

453
00:20:39,960 --> 00:20:44,220
the first one is that as you can

454
00:20:44,220 --> 00:20:46,470
remember it is the temporary space that

455
00:20:46,470 --> 00:20:48,570
occupies and controls the memory of P

456
00:20:48,570 --> 00:20:51,300
SDK and the release of this temporary

457
00:20:51,300 --> 00:20:53,940
space has one minor set in fact it

458
00:20:53,940 --> 00:20:56,550
modifies the first byte of current class

459
00:20:56,550 --> 00:20:58,890
memory meaning that we cannot fully

460
00:20:58,890 --> 00:20:59,650
control the

461
00:20:59,650 --> 00:21:02,020
first walk was a function table so it

462
00:21:02,020 --> 00:21:05,890
reads the second one and two we can crop

463
00:21:05,890 --> 00:21:07,300
the second order function table point

464
00:21:07,300 --> 00:21:10,690
into our obtain the second water

465
00:21:10,690 --> 00:21:13,180
function table belongs to the destructor

466
00:21:13,180 --> 00:21:16,630
of P SDK so after every exploit code

467
00:21:16,630 --> 00:21:19,600
that we have written in the flash file

468
00:21:19,600 --> 00:21:20,980
is executed

469
00:21:20,980 --> 00:21:24,340
mmm VC will kicking and try to release

470
00:21:24,340 --> 00:21:26,020
the other class memory and that is the

471
00:21:26,020 --> 00:21:29,430
moment our world cane is being excluded

472
00:21:29,430 --> 00:21:32,830
the rope chain is simply pointy x to a

473
00:21:32,830 --> 00:21:35,260
controllable memory and invoke a wrapper

474
00:21:35,260 --> 00:21:38,620
is that slash so this record is very

475
00:21:38,620 --> 00:21:40,870
convenient you just invoke a point in

476
00:21:40,870 --> 00:21:43,000
EXO controllable memory make sure X

477
00:21:43,000 --> 00:21:47,070
minus 8 and X minus 4 pointing to the

478
00:21:47,070 --> 00:21:49,300
start address and the length of the

479
00:21:49,300 --> 00:21:51,700
shellcode and the wrapper will invoke

480
00:21:51,700 --> 00:21:54,010
which were protected inside to set the

481
00:21:54,010 --> 00:21:55,720
excluded beat of the shellcode and then

482
00:21:55,720 --> 00:21:58,990
jump over this wrapper code is firstly

483
00:21:58,990 --> 00:22:03,430
used by CV 2014 there were 5 1 5 the

484
00:22:03,430 --> 00:22:05,310
searching pattern for this wrapper

485
00:22:05,310 --> 00:22:08,740
hasn't changed ever since until flash

486
00:22:08,740 --> 00:22:12,160
version on the - the reason for this

487
00:22:12,160 --> 00:22:14,950
changing is a new mitigation called a

488
00:22:14,950 --> 00:22:17,020
memory protector is introduced into

489
00:22:17,020 --> 00:22:20,590
flash versions on the - but as this new

490
00:22:20,590 --> 00:22:22,210
medication doesn't affect our

491
00:22:22,210 --> 00:22:24,610
exploitation or the vulnerabilities so I

492
00:22:24,610 --> 00:22:28,420
have keep as its demonstration at

493
00:22:28,420 --> 00:22:30,550
medication part but I will mention this

494
00:22:30,550 --> 00:22:33,720
mitigation later in the conclusion

495
00:22:33,720 --> 00:22:37,390
so after invoke the wrapper and then

496
00:22:37,390 --> 00:22:39,670
we'll jump over to the shellcode the

497
00:22:39,670 --> 00:22:44,190
demo the code is running and expelling

498
00:22:44,190 --> 00:22:47,770
the with primitive part will be a little

499
00:22:47,770 --> 00:22:50,470
time consuming as you can see there are

500
00:22:50,470 --> 00:22:53,230
6 or 10 lines for the X PRIZE work for

501
00:22:53,230 --> 00:22:55,480
the reprint the work this is highly

502
00:22:55,480 --> 00:22:57,940
weighted compared to the traditional a

503
00:22:57,940 --> 00:23:01,650
vector + index number

504
00:23:07,340 --> 00:23:09,990
so currently what we have discussed this

505
00:23:09,990 --> 00:23:12,330
and there 32-bit environment what about

506
00:23:12,330 --> 00:23:16,620
64-bit environment first thing the

507
00:23:16,620 --> 00:23:18,780
pointer is changing from four bytes long

508
00:23:18,780 --> 00:23:21,330
to eight bytes long and many class are

509
00:23:21,330 --> 00:23:24,630
in different size as a result P SDK and

510
00:23:24,630 --> 00:23:26,850
track these two classes and now in

511
00:23:26,850 --> 00:23:28,650
different size though they cannot occupy

512
00:23:28,650 --> 00:23:31,770
each other we should find another class

513
00:23:31,770 --> 00:23:35,250
to occupy the memory of P SDK and that

514
00:23:35,250 --> 00:23:38,280
is media resource new resources and also

515
00:23:38,280 --> 00:23:40,860
under unique or package so it is shared

516
00:23:40,860 --> 00:23:43,650
within a partition and it contains

517
00:23:43,650 --> 00:23:44,520
string inside

518
00:23:44,520 --> 00:23:46,950
so after P SDK is released media

519
00:23:46,950 --> 00:23:48,690
resource with an occupies memory and

520
00:23:48,690 --> 00:23:51,120
this time the type confusion function

521
00:23:51,120 --> 00:23:54,210
call will treat the f0x off staff to be

522
00:23:54,210 --> 00:23:56,670
a reference card decremented religions

523
00:23:56,670 --> 00:23:59,070
memory if the reference count is 0 so

524
00:23:59,070 --> 00:24:02,180
this is very similar with 32-bit but

525
00:24:02,180 --> 00:24:04,530
except this time we cannot control the

526
00:24:04,530 --> 00:24:07,230
f0x of that memory with milli resource

527
00:24:07,230 --> 00:24:11,190
itself just 0 is very large number and

528
00:24:11,190 --> 00:24:13,410
this memory is a spawn of new resource

529
00:24:13,410 --> 00:24:19,710
universe is only 40 or 50 bytes long so

530
00:24:19,710 --> 00:24:21,300
we should occupy it in the control this

531
00:24:21,300 --> 00:24:26,060
part of memory before P SDK is released

532
00:24:26,060 --> 00:24:29,100
there are two reasons why we can invoke

533
00:24:29,100 --> 00:24:32,240
set by the way one at one time to

534
00:24:32,240 --> 00:24:35,370
control this part of memory the first

535
00:24:35,370 --> 00:24:38,700
reason is that P SDK and track and MIDI

536
00:24:38,700 --> 00:24:40,770
resource all these classes we have

537
00:24:40,770 --> 00:24:42,810
discussed and the medical package there

538
00:24:42,810 --> 00:24:44,910
using a different hit partition compared

539
00:24:44,910 --> 00:24:48,560
to traditional flash objects

540
00:24:48,920 --> 00:24:51,300
traditionally other flash objects are

541
00:24:51,300 --> 00:24:54,390
completely managed by MMP see where were

542
00:24:54,390 --> 00:24:58,500
to Allah on self defined flash it but

543
00:24:58,500 --> 00:25:01,260
for this classes we have discussed their

544
00:25:01,260 --> 00:25:03,840
managed by malloc and free directly on

545
00:25:03,840 --> 00:25:08,250
the deferred heap of the CRT tip so that

546
00:25:08,250 --> 00:25:11,100
means the memory of P SDK and this

547
00:25:11,100 --> 00:25:14,250
classes are very pure there won't be any

548
00:25:14,250 --> 00:25:17,610
interferes of the memory after P SDK

549
00:25:17,610 --> 00:25:20,769
into our set

550
00:25:20,769 --> 00:25:22,330
so instead of added weight is invoked it

551
00:25:22,330 --> 00:25:25,240
is the first time the memory of after

552
00:25:25,240 --> 00:25:28,360
the memory after P SDK is allocated so

553
00:25:28,360 --> 00:25:31,059
that is reason we can control the part

554
00:25:31,059 --> 00:25:34,120
of memory and the second reason is P SDK

555
00:25:34,120 --> 00:25:37,659
take 40 or 50 bytes and there are two

556
00:25:37,659 --> 00:25:40,000
memory blocks inside battery as you can

557
00:25:40,000 --> 00:25:42,639
remember so these two three memory

558
00:25:42,639 --> 00:25:45,370
blocks added together help us control

559
00:25:45,370 --> 00:25:49,000
the memory of fzero-x offset then we can

560
00:25:49,000 --> 00:25:51,940
set that whether to do one and this time

561
00:25:51,940 --> 00:25:53,980
type of confusion call 10 works

562
00:25:53,980 --> 00:25:56,230
correctly and release the memory of new

563
00:25:56,230 --> 00:25:58,510
resource so again we're in the r8

564
00:25:58,510 --> 00:26:01,690
primitive situation but this time we

565
00:26:01,690 --> 00:26:04,769
cannot just read a stable location

566
00:26:04,769 --> 00:26:11,519
spread with vector object anymore since

567
00:26:11,519 --> 00:26:14,740
traditional flash objects under 64-bit

568
00:26:14,740 --> 00:26:17,019
environment are high 32-bit randomized

569
00:26:17,019 --> 00:26:20,409
so even we have sprayed terabytes of

570
00:26:20,409 --> 00:26:23,260
memory who cannot control is a stable

571
00:26:23,260 --> 00:26:26,730
location with our control the data

572
00:26:27,750 --> 00:26:31,990
likely find that springing network flash

573
00:26:31,990 --> 00:26:34,240
objects doesn't derive the high entropy

574
00:26:34,240 --> 00:26:37,570
and it would under Windows 7 so I just

575
00:26:37,570 --> 00:26:40,000
choose another class under medical

576
00:26:40,000 --> 00:26:43,649
package it is a tacit as you notice

577
00:26:43,649 --> 00:26:44,919
malloc

578
00:26:44,919 --> 00:26:48,580
so and as it works like an array the

579
00:26:48,580 --> 00:26:50,740
class inside it will duplicate himself

580
00:26:50,740 --> 00:26:54,279
and spring the memory when we invoke the

581
00:26:54,279 --> 00:26:59,370
constructor all the class memory will be

582
00:26:59,370 --> 00:27:02,370
the third highest degree will remain 0

583
00:27:02,370 --> 00:27:05,200
so we can start to brutal for searching

584
00:27:05,200 --> 00:27:07,899
this buried memory and one of the class

585
00:27:07,899 --> 00:27:09,909
being sprayed as needed resource as you

586
00:27:09,909 --> 00:27:11,590
can remember it contains the string

587
00:27:11,590 --> 00:27:14,169
inside also there is a inter value so

588
00:27:14,169 --> 00:27:16,750
this interval can be used as a flag we

589
00:27:16,750 --> 00:27:18,850
when we find a flag during approved for

590
00:27:18,850 --> 00:27:20,950
searching we know the new resources here

591
00:27:20,950 --> 00:27:23,490
and metadata is adjacent

592
00:27:23,490 --> 00:27:26,590
metadata can be used as a replacement of

593
00:27:26,590 --> 00:27:29,908
vector and byte array

594
00:27:30,630 --> 00:27:33,260
it contains the buffer inside just like

595
00:27:33,260 --> 00:27:36,690
lectura by the rate and this buffer can

596
00:27:36,690 --> 00:27:40,710
be is defined where fixed offset only to

597
00:27:40,710 --> 00:27:44,280
notice that the offset for the second

598
00:27:44,280 --> 00:27:47,330
stab is calculated where a hash function

599
00:27:47,330 --> 00:27:50,190
the hash value is only zero to seven and

600
00:27:50,190 --> 00:27:54,750
the input value is the key names that is

601
00:27:54,750 --> 00:27:59,070
the first parameter of set byte array so

602
00:27:59,070 --> 00:28:01,110
would there is very likely a hash

603
00:28:01,110 --> 00:28:03,210
collision but we don't add one and hash

604
00:28:03,210 --> 00:28:06,690
collision or otherwise there will be a

605
00:28:06,690 --> 00:28:08,880
list structure inside metadata and

606
00:28:08,880 --> 00:28:11,400
finding the buffer inside would be very

607
00:28:11,400 --> 00:28:14,280
much difficult so we just choose

608
00:28:14,280 --> 00:28:17,370
different names as and make sure their

609
00:28:17,370 --> 00:28:19,500
hash value is different as we don't need

610
00:28:19,500 --> 00:28:24,750
so many buffers so after all of this has

611
00:28:24,750 --> 00:28:27,330
done we can find other buffers and this

612
00:28:27,330 --> 00:28:28,890
buffers can be filled and linked just

613
00:28:28,890 --> 00:28:31,800
like 32-bit and the fake would function

614
00:28:31,800 --> 00:28:35,640
type of trick works just like before so

615
00:28:35,640 --> 00:28:37,890
currently all of this has been discussed

616
00:28:37,890 --> 00:28:40,920
and their Windows seven what about

617
00:28:40,920 --> 00:28:44,340
Windows 10 first I didn't intend to view

618
00:28:44,340 --> 00:28:46,080
the full workload exploit any windows

619
00:28:46,080 --> 00:28:48,060
pain as for window 7 there are many new

620
00:28:48,060 --> 00:28:51,270
things new media new mitigations new

621
00:28:51,270 --> 00:28:54,810
hips barry method and new hip partition

622
00:28:54,810 --> 00:28:57,030
also there are a lot of reverse

623
00:28:57,030 --> 00:28:59,130
engineering of water closets and they're

624
00:28:59,130 --> 00:29:01,170
mediocre so i don't want to do all of

625
00:29:01,170 --> 00:29:04,380
this and open it again I just needed to

626
00:29:04,380 --> 00:29:06,120
take a quick peek to see with a

627
00:29:06,120 --> 00:29:09,270
different full understand first P SDK is

628
00:29:09,270 --> 00:29:12,900
still malloc on the low fraggin hip the

629
00:29:12,900 --> 00:29:16,200
rfh this is absolutely the same with

630
00:29:16,200 --> 00:29:19,620
Windows 7 but our FH itself is changing

631
00:29:19,620 --> 00:29:23,640
from windows 7 to Windows 10 there is a

632
00:29:23,640 --> 00:29:27,050
heap randomization added into Windows 10

633
00:29:27,050 --> 00:29:30,120
so for Windows 7 when the memory of P

634
00:29:30,120 --> 00:29:33,270
SDK is released it comes down to the

635
00:29:33,270 --> 00:29:35,430
freely comes down to the end of the

636
00:29:35,430 --> 00:29:35,910
frailest

637
00:29:35,910 --> 00:29:38,970
and when next allocation is coming the

638
00:29:38,970 --> 00:29:41,220
last memory blocks being freed will be

639
00:29:41,220 --> 00:29:43,110
the next one being allocated so it is

640
00:29:43,110 --> 00:29:43,890
very pretty

641
00:29:43,890 --> 00:29:46,320
but we know that the memory of PSD K

642
00:29:46,320 --> 00:29:48,000
will be occupied with just one

643
00:29:48,000 --> 00:29:53,460
occupation with just one allocation but

644
00:29:53,460 --> 00:29:55,800
for Windows 10 there's a bitmap

645
00:29:55,800 --> 00:29:58,260
controlling the low pragma HIPPA

646
00:29:58,260 --> 00:30:01,440
allocation but we can still use the free

647
00:30:01,440 --> 00:30:04,680
list model to explain what happened so

648
00:30:04,680 --> 00:30:06,990
when the memory of PSD K is released it

649
00:30:06,990 --> 00:30:09,630
comes down to the free list let's say

650
00:30:09,630 --> 00:30:11,990
there is 16 blocks in this free list and

651
00:30:11,990 --> 00:30:15,450
when next allocation is coming our FH

652
00:30:15,450 --> 00:30:17,820
will randomly choose one of those 16

653
00:30:17,820 --> 00:30:19,650
blocks to the next one being allocated

654
00:30:19,650 --> 00:30:22,140
meaning that we don't know if the memory

655
00:30:22,140 --> 00:30:25,050
of PSD K is occupied or not with just

656
00:30:25,050 --> 00:30:28,620
one allocation so a director idea is to

657
00:30:28,620 --> 00:30:30,960
bypass this is Multiple Occupation as

658
00:30:30,960 --> 00:30:33,810
you have said there are 16 blocks so 100

659
00:30:33,810 --> 00:30:36,510
we just use 16 allocations make sure the

660
00:30:36,510 --> 00:30:40,770
P SDK memory is occupied but this is

661
00:30:40,770 --> 00:30:42,120
only partially correct

662
00:30:42,120 --> 00:30:45,030
as you can see for the first 15

663
00:30:45,030 --> 00:30:47,790
allocation everything goes normal but

664
00:30:47,790 --> 00:30:52,890
for the 16th allocation error SH won't

665
00:30:52,890 --> 00:30:55,140
use the last memory block inside this

666
00:30:55,140 --> 00:30:56,820
free list and it will allocate a new

667
00:30:56,820 --> 00:30:59,490
free list and choose one of those memory

668
00:30:59,490 --> 00:31:01,820
blocks to be next one being allocated

669
00:31:01,820 --> 00:31:05,700
just to enlarge the randomization but

670
00:31:05,700 --> 00:31:07,590
this randomization is still limited

671
00:31:07,590 --> 00:31:10,320
after two or three cycles of free list

672
00:31:10,320 --> 00:31:13,440
allocation our F issue will finally

673
00:31:13,440 --> 00:31:17,040
release realize that well I still have a

674
00:31:17,040 --> 00:31:19,320
memory block in by the first frailest

675
00:31:19,320 --> 00:31:22,440
and why not using it is waste so that is

676
00:31:22,440 --> 00:31:25,970
the moment our sh will allocated last

677
00:31:25,970 --> 00:31:28,500
memory block inside the first free list

678
00:31:28,500 --> 00:31:30,660
and that is the moment we know the

679
00:31:30,660 --> 00:31:34,260
memory of PSD is occupied all of this

680
00:31:34,260 --> 00:31:36,480
demonstrations is based on black box

681
00:31:36,480 --> 00:31:39,870
keep experiments but I have discussed

682
00:31:39,870 --> 00:31:42,390
with other people who have done fully

683
00:31:42,390 --> 00:31:46,110
reverse engineering of indeed L to see

684
00:31:46,110 --> 00:31:48,800
how our epoch works and all of this

685
00:31:48,800 --> 00:31:51,750
demonstrations has been confirmed so

686
00:31:51,750 --> 00:31:54,390
meaning that after P SDK is released we

687
00:31:54,390 --> 00:31:56,390
can construct tracks

688
00:31:56,390 --> 00:31:59,060
hundreds of times and this will make

689
00:31:59,060 --> 00:32:01,940
sure the memory of PS DK is occupied and

690
00:32:01,940 --> 00:32:04,340
this time the type confusion phone call

691
00:32:04,340 --> 00:32:06,980
actually makes things easier for us we

692
00:32:06,980 --> 00:32:08,870
do need to control any part of memory

693
00:32:08,870 --> 00:32:11,840
just pass the parameter to u1 and then

694
00:32:11,840 --> 00:32:14,000
the memory of track will be released and

695
00:32:14,000 --> 00:32:15,920
then we're in the grid printing

696
00:32:15,920 --> 00:32:19,010
situation but this time still for the

697
00:32:19,010 --> 00:32:21,200
Federation will need multiple occupation

698
00:32:21,200 --> 00:32:23,600
meaning that for each cycle we need to

699
00:32:23,600 --> 00:32:26,750
use multiple satellite array to control

700
00:32:26,750 --> 00:32:29,540
the content off track but I didn't go in

701
00:32:29,540 --> 00:32:31,610
a step further so other windows 10

702
00:32:31,610 --> 00:32:34,160
brings us a topping worms use that their

703
00:32:34,160 --> 00:32:35,870
users are free and still finding its way

704
00:32:35,870 --> 00:32:41,330
for rate primitives so for the

705
00:32:41,330 --> 00:32:44,590
conclusion part first of all things

706
00:32:44,590 --> 00:32:48,070
after we're pouring this is due to Adobe

707
00:32:48,070 --> 00:32:50,810
their faces manually remove the

708
00:32:50,810 --> 00:32:52,550
reference pointer from the access code

709
00:32:52,550 --> 00:32:56,030
level which is used to invoke release

710
00:32:56,030 --> 00:32:58,910
and when as that when is that manually

711
00:32:58,910 --> 00:33:01,010
meaning that if this fix can be bypassed

712
00:33:01,010 --> 00:33:05,090
so there goes another vulnerability CV

713
00:33:05,090 --> 00:33:08,870
2016 4 for 8 and I bypass this first

714
00:33:08,870 --> 00:33:11,390
expired declare on to reference pointing

715
00:33:11,390 --> 00:33:15,260
to P SDK and invoke release was one of

716
00:33:15,260 --> 00:33:16,850
them but triggering the users are free

717
00:33:16,850 --> 00:33:20,210
with another and to explore the second

718
00:33:20,210 --> 00:33:23,690
vulnerability there is I find that there

719
00:33:23,690 --> 00:33:27,320
is only one line change necessary for

720
00:33:27,320 --> 00:33:29,330
the export work only the Tribune Park

721
00:33:29,330 --> 00:33:33,020
and but when the want try to explore the

722
00:33:33,020 --> 00:33:35,600
second buck it is now flash version 22

723
00:33:35,600 --> 00:33:38,810
as I have told you before there was a

724
00:33:38,810 --> 00:33:41,360
memory protector a new mitigation is

725
00:33:41,360 --> 00:33:44,420
added into adobe flash memory of the

726
00:33:44,420 --> 00:33:47,360
detector is used to delay the free of

727
00:33:47,360 --> 00:33:50,450
objects mitigation many use for users

728
00:33:50,450 --> 00:33:52,820
are free and maybe some can learn from

729
00:33:52,820 --> 00:33:55,850
Microsoft ie that this medication

730
00:33:55,850 --> 00:33:58,940
doesn't affect our exploitation or the

731
00:33:58,940 --> 00:34:01,070
vulnerability even if we're talking

732
00:34:01,070 --> 00:34:05,060
about use of the free and the reason for

733
00:34:05,060 --> 00:34:07,100
that is memory protector only may be

734
00:34:07,100 --> 00:34:09,340
only focusing on

735
00:34:09,340 --> 00:34:12,800
objects that are managed by MMP see not

736
00:34:12,800 --> 00:34:15,790
our Malik and the freight manage objects

737
00:34:15,790 --> 00:34:18,650
or maybe this member protector only

738
00:34:18,650 --> 00:34:22,070
focusing on stack pointers but our

739
00:34:22,070 --> 00:34:25,969
pointers saved in the heap design PSD K

740
00:34:25,969 --> 00:34:28,550
but I haven't give it a song the

741
00:34:28,550 --> 00:34:31,820
thorough analysis as this it doesn't

742
00:34:31,820 --> 00:34:36,530
affect my exploitation so for the second

743
00:34:36,530 --> 00:34:40,760
fix Adobe choose again to will remove

744
00:34:40,760 --> 00:34:43,790
this function from echo script level so

745
00:34:43,790 --> 00:34:45,500
if they really don't need this function

746
00:34:45,500 --> 00:34:47,630
why should they introduce it at first

747
00:34:47,630 --> 00:34:50,179
place so maybe this is just another

748
00:34:50,179 --> 00:34:52,880
temporary piece just as before ask Matt

749
00:34:52,880 --> 00:34:56,840
September fix many times before so once

750
00:34:56,840 --> 00:34:59,870
I have a heap overflow and after a patch

751
00:34:59,870 --> 00:35:02,750
the Hebrew flow is gone and the reason

752
00:35:02,750 --> 00:35:06,230
for that is the heap memory is double so

753
00:35:06,230 --> 00:35:08,240
my Hebrew look and not overfilled that

754
00:35:08,240 --> 00:35:10,340
much of memory and that is reason it's

755
00:35:10,340 --> 00:35:12,860
gone but after several versions of Adobe

756
00:35:12,860 --> 00:35:16,550
Flash the bug is back so I checked the

757
00:35:16,550 --> 00:35:18,890
code again I see the calculation of the

758
00:35:18,890 --> 00:35:21,800
heap memory is rolling back so the truth

759
00:35:21,800 --> 00:35:24,650
is the first speaks is temporary for

760
00:35:24,650 --> 00:35:27,830
some other people's people flow but

761
00:35:27,830 --> 00:35:29,570
after several versions after doping

762
00:35:29,570 --> 00:35:31,610
figure out how to calculate the right

763
00:35:31,610 --> 00:35:33,650
size of heap they rolling back to the

764
00:35:33,650 --> 00:35:35,870
old calculation but that it doesn't

765
00:35:35,870 --> 00:35:38,570
speak doesn't speak my Hebrew flow so it

766
00:35:38,570 --> 00:35:41,120
is back so if this speaks is actually a

767
00:35:41,120 --> 00:35:41,870
temporary fix

768
00:35:41,870 --> 00:35:44,420
after several versions of flash maybe it

769
00:35:44,420 --> 00:35:47,120
will come back if still they use manual

770
00:35:47,120 --> 00:35:49,940
a with remove of this pointer there may

771
00:35:49,940 --> 00:35:54,290
be still a by us so for the use of the

772
00:35:54,290 --> 00:35:56,720
use of free I think it's relevant common

773
00:35:56,720 --> 00:35:58,760
way to explore using for freeze in dobby

774
00:35:58,760 --> 00:36:02,870
flash although the first part that it

775
00:36:02,870 --> 00:36:04,760
used a type confusion function call to

776
00:36:04,760 --> 00:36:06,680
release the class memory seems a little

777
00:36:06,680 --> 00:36:10,690
complicated but I have accomplished this

778
00:36:10,690 --> 00:36:13,340
under three versions of Adobe Flash and

779
00:36:13,340 --> 00:36:16,340
32-bit and 64-bit and Windows seven and

780
00:36:16,340 --> 00:36:18,090
a third to speed and Windows 10

781
00:36:18,090 --> 00:36:21,600
so I think it is still practical only

782
00:36:21,600 --> 00:36:24,620
you need a lot of reverse engineering

783
00:36:24,620 --> 00:36:27,500
and currently we're dealing with a

784
00:36:27,500 --> 00:36:30,210
string object and thus give us a rate

785
00:36:30,210 --> 00:36:32,610
primitive and in the future if we can

786
00:36:32,610 --> 00:36:35,310
find some other or relaxed structure to

787
00:36:35,310 --> 00:36:37,710
prop with maybe you can get a right

788
00:36:37,710 --> 00:36:39,480
primitive and that it will be much

789
00:36:39,480 --> 00:36:41,880
helpful for the exploit of work and the

790
00:36:41,880 --> 00:36:46,530
winners pain and the problem for the

791
00:36:46,530 --> 00:36:48,510
string objects is when you try to raid

792
00:36:48,510 --> 00:36:51,090
the target memory everything goes well

793
00:36:51,090 --> 00:36:54,720
but we try to write the target memory it

794
00:36:54,720 --> 00:36:57,300
will allocate a new buffer to say what

795
00:36:57,300 --> 00:37:00,330
you're going to write and then save the

796
00:37:00,330 --> 00:37:02,550
pointer inside so we cannot just write

797
00:37:02,550 --> 00:37:05,700
and in target memory but if you can find

798
00:37:05,700 --> 00:37:08,010
another or relax rupture which use a

799
00:37:08,010 --> 00:37:10,980
target address to be the one written

800
00:37:10,980 --> 00:37:14,310
that that that is we can find a right

801
00:37:14,310 --> 00:37:17,580
primitive and the idea behind it use

802
00:37:17,580 --> 00:37:19,080
that their users are free I think is

803
00:37:19,080 --> 00:37:22,110
more common as I've seen such release

804
00:37:22,110 --> 00:37:25,440
and occupation and type confusion things

805
00:37:25,440 --> 00:37:29,970
in an iOS kernel exploit so I think this

806
00:37:29,970 --> 00:37:32,460
method the idea behind this method can

807
00:37:32,460 --> 00:37:35,160
be implemented in other platforms and

808
00:37:35,160 --> 00:37:38,190
software's so that is all for my

809
00:37:38,190 --> 00:37:42,440
presentation thank you very much

