1
00:00:00,000 --> 00:00:02,790
okay so let's get started I'll take you

2
00:00:02,790 --> 00:00:05,730
thank you all for being here I'm going

3
00:00:05,730 --> 00:00:09,200
to talk today about code obfuscation and

4
00:00:09,200 --> 00:00:11,940
the training of dynamic static and

5
00:00:11,940 --> 00:00:14,960
symbolic approaches for Delta squishy

6
00:00:14,960 --> 00:00:18,330
okay so am i I'm Robyn Davis and Stella

7
00:00:18,330 --> 00:00:20,070
PC students at the Atomic Energy

8
00:00:20,070 --> 00:00:22,350
Commission in France I'm working with

9
00:00:22,350 --> 00:00:24,090
the bottom bar down which is a full-time

10
00:00:24,090 --> 00:00:27,300
researcher we basically working in the

11
00:00:27,300 --> 00:00:31,980
software safety safety and security lab

12
00:00:31,980 --> 00:00:35,130
which is primarily doing a safety for

13
00:00:35,130 --> 00:00:38,579
critical embedded systems are known for

14
00:00:38,579 --> 00:00:43,200
it's a platform for analyzing C code but

15
00:00:43,200 --> 00:00:44,910
I'm part of the small team that is

16
00:00:44,910 --> 00:00:49,379
working on binary for security okay so

17
00:00:49,379 --> 00:00:52,500
what's the context what to go so the

18
00:00:52,500 --> 00:00:54,360
part is there is a lot of malware in the

19
00:00:54,360 --> 00:00:57,690
wild some of the some of them are up to

20
00:00:57,690 --> 00:01:00,989
speed so we'd like to address them and

21
00:01:00,989 --> 00:01:03,359
to get rid of sophistication in order to

22
00:01:03,359 --> 00:01:06,390
perform some more in-depth analysis so

23
00:01:06,390 --> 00:01:08,490
the first thing is trying to locate

24
00:01:08,490 --> 00:01:11,010
obfuscation if there is any and in

25
00:01:11,010 --> 00:01:13,290
second step trying to remove it possible

26
00:01:13,290 --> 00:01:17,159
and all that the goal is to recover some

27
00:01:17,159 --> 00:01:18,840
kind of eye level view of the program

28
00:01:18,840 --> 00:01:21,890
which is usually the control flow graphs

29
00:01:21,890 --> 00:01:25,619
the challenges static dynamic and

30
00:01:25,619 --> 00:01:27,920
symbolic approaches used alone are

31
00:01:27,920 --> 00:01:31,189
sometimes are not enough for addressing

32
00:01:31,189 --> 00:01:33,720
binaries that are fitted with different

33
00:01:33,720 --> 00:01:34,530
sophistications

34
00:01:34,530 --> 00:01:38,490
and obviously we have some scalability

35
00:01:38,490 --> 00:01:40,799
and robustness issues when dealing with

36
00:01:40,799 --> 00:01:46,140
instruct code our proposal is first a

37
00:01:46,140 --> 00:01:48,750
new symbolic method for addressing

38
00:01:48,750 --> 00:01:51,720
infeasibility based problems I'm going

39
00:01:51,720 --> 00:01:54,509
to talk about it after that and we

40
00:01:54,509 --> 00:01:57,240
propose the combinations are handling

41
00:01:57,240 --> 00:01:59,640
multiple kinds of applications on by

42
00:01:59,640 --> 00:02:02,430
mixing different approaches what web

43
00:02:02,430 --> 00:02:05,729
achieved so far is a set of tools for

44
00:02:05,729 --> 00:02:09,300
analyzing buyer needs some detection

45
00:02:09,300 --> 00:02:13,500
algorithms for several obfuscation and

46
00:02:13,500 --> 00:02:16,710
I will show great example on external

47
00:02:16,710 --> 00:02:20,910
malware okay so the long term objectives

48
00:02:20,910 --> 00:02:26,670
is to use a dynamic disassembly which is

49
00:02:26,670 --> 00:02:29,940
meant to be safe because our instruction

50
00:02:29,940 --> 00:02:32,610
decode it are being executed

51
00:02:32,610 --> 00:02:35,160
so we have the subset of the program

52
00:02:35,160 --> 00:02:36,960
that were sure to be executive all and

53
00:02:36,960 --> 00:02:40,350
we'd like to improve it

54
00:02:40,350 --> 00:02:43,980
we've static disassembly but making the

55
00:02:43,980 --> 00:02:46,440
static design be more smart if we can

56
00:02:46,440 --> 00:02:50,310
say by guiding it with symbolic

57
00:02:50,310 --> 00:02:52,590
execution and obfuscation related

58
00:02:52,590 --> 00:02:58,620
information so what's the agenda today

59
00:02:58,620 --> 00:03:01,770
I'm going to do some quick recall but

60
00:03:01,770 --> 00:03:03,930
disassembling and dynamic symbolic

61
00:03:03,930 --> 00:03:07,220
executions then I will present our two

62
00:03:07,220 --> 00:03:11,910
proposals then I will just talk rapidly

63
00:03:11,910 --> 00:03:14,160
up the the binstock platform that have

64
00:03:14,160 --> 00:03:16,500
been working on for the past few years

65
00:03:16,500 --> 00:03:19,110
and then I will move on to the the for

66
00:03:19,110 --> 00:03:22,280
the two case studies the first is on

67
00:03:22,280 --> 00:03:25,739
several Packers and the last is is on

68
00:03:25,739 --> 00:03:30,120
external ok so what's like to

69
00:03:30,120 --> 00:03:34,650
disassemble of the scaly code the ID is

70
00:03:34,650 --> 00:03:37,940
to are recover some usable

71
00:03:37,940 --> 00:03:40,290
representation of the program getting

72
00:03:40,290 --> 00:03:43,200
rid of what everything that is yields

73
00:03:43,200 --> 00:03:48,959
listen to the program ok so yeah and so

74
00:03:48,959 --> 00:03:51,390
and this is an assertion essential tasks

75
00:03:51,390 --> 00:03:54,330
to perform before any in-depth analysis

76
00:03:54,330 --> 00:03:57,209
to understand what the program is really

77
00:03:57,209 --> 00:04:02,100
doing ok so the desire somebody

78
00:04:02,100 --> 00:04:04,160
processes as a critical it can be

79
00:04:04,160 --> 00:04:07,350
divided into three steps the first step

80
00:04:07,350 --> 00:04:10,890
is the cut discovery on so finding into

81
00:04:10,890 --> 00:04:12,870
the big block of bytes

82
00:04:12,870 --> 00:04:15,090
what's code what data into the program

83
00:04:15,090 --> 00:04:18,529
into the section it implies to deal with

84
00:04:18,529 --> 00:04:20,910
instructions of your lapping for

85
00:04:20,910 --> 00:04:24,060
instance on x86 the same bytes can be

86
00:04:24,060 --> 00:04:25,350
shared between two different

87
00:04:25,350 --> 00:04:27,300
instructions on the

88
00:04:27,300 --> 00:04:30,870
we're where your start decoding so

89
00:04:30,870 --> 00:04:32,370
that's the first challenge while

90
00:04:32,370 --> 00:04:34,889
disassembling the second step is the

91
00:04:34,889 --> 00:04:37,800
control flow graph reconstructions so

92
00:04:37,800 --> 00:04:40,289
basically creating the nodes and hedges

93
00:04:40,289 --> 00:04:44,699
to encode the flow of the program so it

94
00:04:44,699 --> 00:04:47,550
implies to deal with indirect control

95
00:04:47,550 --> 00:04:50,009
flow like jump a dynamic jump and sit

96
00:04:50,009 --> 00:04:52,500
like this functions that are never

97
00:04:52,500 --> 00:04:57,720
returning and yeah and a lot that is the

98
00:04:57,720 --> 00:05:01,440
partitioning namely trying to create

99
00:05:01,440 --> 00:05:03,419
some segmentation into the control flow

100
00:05:03,419 --> 00:05:07,020
graph to create some different functions

101
00:05:07,020 --> 00:05:10,169
in order to make it more of visible

102
00:05:10,169 --> 00:05:14,569
unusable for a user program view so

103
00:05:14,569 --> 00:05:17,490
trying to recovering the functions it's

104
00:05:17,490 --> 00:05:19,800
kind of difficult because functions can

105
00:05:19,800 --> 00:05:22,889
share some parts of their code that they

106
00:05:22,889 --> 00:05:26,009
might not be contiguous into the binary

107
00:05:26,009 --> 00:05:28,530
and it also implies to deal with tail

108
00:05:28,530 --> 00:05:31,289
calls it's when you call a function by

109
00:05:31,289 --> 00:05:37,830
making a single jump okay obfuscation

110
00:05:37,830 --> 00:05:42,270
the broad definition of it is any me

111
00:05:42,270 --> 00:05:44,550
that aims at slowing down the disease's

112
00:05:44,550 --> 00:05:47,310
only and the analysis process of a

113
00:05:47,310 --> 00:05:50,880
program either for human or automated

114
00:05:50,880 --> 00:05:55,289
algorithm so there's plenty of

115
00:05:55,289 --> 00:05:58,979
application used so far and I'm not

116
00:05:58,979 --> 00:06:02,310
going to talk about all of them but what

117
00:06:02,310 --> 00:06:05,400
you can identify into them is that there

118
00:06:05,400 --> 00:06:09,599
is in the general sense to kind of add

119
00:06:09,599 --> 00:06:11,849
sophistication the the applications that

120
00:06:11,849 --> 00:06:13,889
are more targeting the control of the

121
00:06:13,889 --> 00:06:17,699
program hiding on the edges in the graph

122
00:06:17,699 --> 00:06:20,789
and the application that are targeting

123
00:06:20,789 --> 00:06:23,310
the data of the program like ciphering

124
00:06:23,310 --> 00:06:26,719
string hiding the contents or hiding

125
00:06:26,719 --> 00:06:27,900
honey

126
00:06:27,900 --> 00:06:29,969
valuable assets into the program in

127
00:06:29,969 --> 00:06:34,800
order to prevent some prevent signatures

128
00:06:34,800 --> 00:06:39,180
or things like this so we can there as a

129
00:06:39,180 --> 00:06:41,190
control obfuscation there is

130
00:06:41,190 --> 00:06:43,320
you have the flattening jump encoding

131
00:06:43,320 --> 00:06:47,430
virtual machines and so on and what you

132
00:06:47,430 --> 00:06:49,950
can see is that on this obfuscation also

133
00:06:49,950 --> 00:06:53,010
have an impact on the analysis that you

134
00:06:53,010 --> 00:06:56,610
can perform on it as an example the last

135
00:06:56,610 --> 00:06:58,740
of discussion is the obfuscation using

136
00:06:58,740 --> 00:07:01,890
using signal on exceptions and it is

137
00:07:01,890 --> 00:07:03,420
typically the kind of sophistication

138
00:07:03,420 --> 00:07:05,900
that we cannot handle in the static way

139
00:07:05,900 --> 00:07:08,730
because we cannot know when an exception

140
00:07:08,730 --> 00:07:10,530
is going to be raised and things like

141
00:07:10,530 --> 00:07:14,130
this so the application have an impact

142
00:07:14,130 --> 00:07:15,900
on the kind of analysis we can perform

143
00:07:15,900 --> 00:07:19,890
on it and I'm going to talk about two of

144
00:07:19,890 --> 00:07:21,770
them today so that I will present some

145
00:07:21,770 --> 00:07:23,870
detection algorithm

146
00:07:23,870 --> 00:07:28,050
the first one is opak predicates on the

147
00:07:28,050 --> 00:07:30,420
back predicate is typically a predicate

148
00:07:30,420 --> 00:07:32,610
that is always true or always false

149
00:07:32,610 --> 00:07:35,940
but this property is difficult to two

150
00:07:35,940 --> 00:07:39,300
digits just by looking at the predicate

151
00:07:39,300 --> 00:07:42,410
you have an example on the right arm

152
00:07:42,410 --> 00:07:46,530
here rigged regardless of the values

153
00:07:46,530 --> 00:07:50,310
that can be taken by X or Y on this

154
00:07:50,310 --> 00:07:54,630
predicate would always be true so below

155
00:07:54,630 --> 00:07:57,810
you have the Assembly of this predicate

156
00:07:57,810 --> 00:08:00,030
and you basically have one of the two

157
00:08:00,030 --> 00:08:03,240
branches that is dead so the question is

158
00:08:03,240 --> 00:08:07,230
okay why why doing this the answer is

159
00:08:07,230 --> 00:08:10,470
that it can be tell us to grow

160
00:08:10,470 --> 00:08:12,480
artificially the size of the code by

161
00:08:12,480 --> 00:08:14,730
hiding some dead code into death in the

162
00:08:14,730 --> 00:08:18,419
dead branches and by the way droning the

163
00:08:18,419 --> 00:08:21,570
genuine cut into it so you can use

164
00:08:21,570 --> 00:08:24,930
whatever whatever is invariant into your

165
00:08:24,930 --> 00:08:27,660
program to encode opaque predicates it

166
00:08:27,660 --> 00:08:30,120
can be Herod Matic like here it can be

167
00:08:30,120 --> 00:08:33,240
some variant or on your data structure

168
00:08:33,240 --> 00:08:36,510
could be pointer aliasing concurrency in

169
00:08:36,510 --> 00:08:39,870
things like this so we are going to to

170
00:08:39,870 --> 00:08:43,260
deal with that obfuscation today and the

171
00:08:43,260 --> 00:08:45,630
second obfuscation is the course tag

172
00:08:45,630 --> 00:08:48,300
tempering the constant tempering is

173
00:08:48,300 --> 00:08:51,480
basically the mean of violating the

174
00:08:51,480 --> 00:08:54,310
compilation scheme saying that

175
00:08:54,310 --> 00:08:57,340
we are read instruction is always

176
00:08:57,340 --> 00:09:01,720
returning to the color and because a red

177
00:09:01,720 --> 00:09:04,510
instruction is basically just a jump on

178
00:09:04,510 --> 00:09:06,550
the top value on the stack

179
00:09:06,550 --> 00:09:08,770
it depends at runtime what's on the

180
00:09:08,770 --> 00:09:10,779
stack at this moment to know where

181
00:09:10,779 --> 00:09:13,089
you're going to jump and if you have an

182
00:09:13,089 --> 00:09:17,200
example on the right so this bit of code

183
00:09:17,200 --> 00:09:20,800
is basically the call will push the

184
00:09:20,800 --> 00:09:24,040
address of the pop on the stack the top

185
00:09:24,040 --> 00:09:26,950
will pop its own address it will then

186
00:09:26,950 --> 00:09:29,800
increment it in the head push it back

187
00:09:29,800 --> 00:09:32,500
again on the stack and the return

188
00:09:32,500 --> 00:09:34,260
instruction is basically going to jump

189
00:09:34,260 --> 00:09:36,930
one byte further

190
00:09:36,930 --> 00:09:41,080
after the RET instruction so that static

191
00:09:41,080 --> 00:09:44,050
disassembly would stop these are

192
00:09:44,050 --> 00:09:46,060
something at the RET instruction not

193
00:09:46,060 --> 00:09:48,700
seeing like the pelo payload is really

194
00:09:48,700 --> 00:09:52,180
located after so that's the kind of

195
00:09:52,180 --> 00:09:55,240
tricks that are kind of annoying when

196
00:09:55,240 --> 00:09:57,279
you want to disassemble obfuscated

197
00:09:57,279 --> 00:09:59,640
program

198
00:09:59,700 --> 00:10:01,560
okay the obfuscation

199
00:10:01,560 --> 00:10:04,540
it's basically we would like it to be

200
00:10:04,540 --> 00:10:08,500
the full reverting of the obfuscating

201
00:10:08,500 --> 00:10:12,520
transformations but sometimes I mean

202
00:10:12,520 --> 00:10:14,800
often it's impossible to do the reverse

203
00:10:14,800 --> 00:10:16,360
operations because we are loading

204
00:10:16,360 --> 00:10:20,620
informations in the obfuscation path so

205
00:10:20,620 --> 00:10:23,740
we consider the application the fact of

206
00:10:23,740 --> 00:10:25,870
simplifying the code is in order to

207
00:10:25,870 --> 00:10:32,170
facilitate further analysis okay so a

208
00:10:32,170 --> 00:10:35,050
quick recall that disassembly we

209
00:10:35,050 --> 00:10:37,810
consider correct a disassembly if it

210
00:10:37,810 --> 00:10:41,980
only disassembled genuine executable

211
00:10:41,980 --> 00:10:45,190
instructions so that instructions not

212
00:10:45,190 --> 00:10:47,320
which is assembled and we call a

213
00:10:47,320 --> 00:10:49,089
disassembly complete if managed to

214
00:10:49,089 --> 00:10:51,430
disassemble on the other although

215
00:10:51,430 --> 00:10:54,720
instruction so what we basically have is

216
00:10:54,720 --> 00:10:57,310
with a static approach you are meant to

217
00:10:57,310 --> 00:10:59,770
disassemble the whole program but you

218
00:10:59,770 --> 00:11:02,500
can be fooled into disassembling some

219
00:11:02,500 --> 00:11:06,459
that data bytes or dead branches and

220
00:11:06,459 --> 00:11:08,080
you're basically

221
00:11:08,080 --> 00:11:10,630
blocked by all the dynamic jump here

222
00:11:10,630 --> 00:11:14,200
with the jump EAX for instance so you

223
00:11:14,200 --> 00:11:16,810
the Daniel is do scale but it's not

224
00:11:16,810 --> 00:11:19,390
promised too many application like self

225
00:11:19,390 --> 00:11:24,180
modification and so on on the other hand

226
00:11:24,180 --> 00:11:27,519
dynamic disassembly will disassemble a

227
00:11:27,519 --> 00:11:30,550
subset of the program but we are sure it

228
00:11:30,550 --> 00:11:35,290
to be executable and the main advantage

229
00:11:35,290 --> 00:11:38,200
of dynamics that is dropped to a usually

230
00:11:38,200 --> 00:11:40,600
self modification and this kind of

231
00:11:40,600 --> 00:11:42,120
obfuscation

232
00:11:42,120 --> 00:11:44,829
the shortcoming of this method is that

233
00:11:44,829 --> 00:11:48,130
it dependent on the input so that in

234
00:11:48,130 --> 00:11:49,420
theory if you want to cover the whole

235
00:11:49,420 --> 00:11:51,670
program you have to provide all the

236
00:11:51,670 --> 00:11:55,690
possible inputs to your program and this

237
00:11:55,690 --> 00:11:57,430
is where dynamic symbolic execution

238
00:11:57,430 --> 00:12:01,180
comes in which is also known as conchal

239
00:12:01,180 --> 00:12:05,320
execution so symbolic execution is

240
00:12:05,320 --> 00:12:07,600
basically the mean of simulating the

241
00:12:07,600 --> 00:12:10,450
program using symbolic values rather

242
00:12:10,450 --> 00:12:13,750
than constant values in order to obtain

243
00:12:13,750 --> 00:12:17,470
some relationship on the path so as an

244
00:12:17,470 --> 00:12:20,950
example you have this small snippet of

245
00:12:20,950 --> 00:12:23,050
code where there is two nested if I

246
00:12:23,050 --> 00:12:25,029
would like to know what are the

247
00:12:25,029 --> 00:12:27,250
conditions following to reach the print

248
00:12:27,250 --> 00:12:30,130
instructions so in the middle you have

249
00:12:30,130 --> 00:12:32,740
basically the the graph of the functions

250
00:12:32,740 --> 00:12:36,730
and in order to reach the print okay yes

251
00:12:36,730 --> 00:12:39,520
hey that should be less than ten and

252
00:12:39,520 --> 00:12:42,850
it's also should be greater than B so

253
00:12:42,850 --> 00:12:45,490
that gives us some relationship on the

254
00:12:45,490 --> 00:12:48,720
path and that leads to the given formula

255
00:12:48,720 --> 00:12:52,449
which is a less than ten and a greater

256
00:12:52,449 --> 00:12:55,690
than B and a solution for that is a

257
00:12:55,690 --> 00:12:58,560
equal five and for instance be equal one

258
00:12:58,560 --> 00:13:02,529
usually the last step are we hand it to

259
00:13:02,529 --> 00:13:08,649
like of the shelf SMT solver and going

260
00:13:08,649 --> 00:13:11,320
dynamic so dynamic symbolic execution in

261
00:13:11,320 --> 00:13:14,260
the mean of working on the dynamic path

262
00:13:14,260 --> 00:13:16,570
so the first task you don't choose it

263
00:13:16,570 --> 00:13:18,130
you just run your program and you obtain

264
00:13:18,130 --> 00:13:20,829
the path of execution and you render the

265
00:13:20,829 --> 00:13:22,830
top of it

266
00:13:22,830 --> 00:13:25,240
so the question is for this question why

267
00:13:25,240 --> 00:13:27,630
why using a dynamic symbolic execution

268
00:13:27,630 --> 00:13:32,550
and an answer for this question is first

269
00:13:32,550 --> 00:13:36,970
obfuscation usually alter the syntax of

270
00:13:36,970 --> 00:13:39,340
the program breaking the nodes edges of

271
00:13:39,340 --> 00:13:41,860
the graph but you should keep the

272
00:13:41,860 --> 00:13:44,170
semantics of the program because you

273
00:13:44,170 --> 00:13:46,150
want your program to still do what it's

274
00:13:46,150 --> 00:13:49,090
meant to do after application and by the

275
00:13:49,090 --> 00:13:53,020
way a DAC allows to find new paths like

276
00:13:53,020 --> 00:13:56,350
in the previous example with a and B we

277
00:13:56,350 --> 00:13:59,260
would have the satisfying inputs for the

278
00:13:59,260 --> 00:14:01,750
two parameters of the fictions to get

279
00:14:01,750 --> 00:14:05,080
into that path so that that's valuable

280
00:14:05,080 --> 00:14:09,280
analysis in our case a more complicated

281
00:14:09,280 --> 00:14:12,460
example so let's consider that on we

282
00:14:12,460 --> 00:14:15,480
have a switch with for K three cases the

283
00:14:15,480 --> 00:14:19,240
Assembly obtained and what we have

284
00:14:19,240 --> 00:14:22,120
obtained with dynamic execution so we

285
00:14:22,120 --> 00:14:25,990
obtain a piece of the control flow graph

286
00:14:25,990 --> 00:14:29,560
and if you have if we want for instance

287
00:14:29,560 --> 00:14:33,610
to reach the case C which is meant to be

288
00:14:33,610 --> 00:14:37,990
two we get that path and we obtained the

289
00:14:37,990 --> 00:14:41,020
relationship on that path in order to to

290
00:14:41,020 --> 00:14:45,100
take this path into the program so he

291
00:14:45,100 --> 00:14:47,140
tell us to generate inputs for tearing

292
00:14:47,140 --> 00:14:50,920
path but as you can notice here we have

293
00:14:50,920 --> 00:14:55,240
missed one of the target of the jump eix

294
00:14:55,240 --> 00:14:57,520
of the switch so we can basically ask

295
00:14:57,520 --> 00:15:00,100
okay what could be the values for EAX at

296
00:15:00,100 --> 00:15:03,820
that point of the program so that we can

297
00:15:03,820 --> 00:15:08,440
maybe find new jump targets so it

298
00:15:08,440 --> 00:15:11,290
basically gives the given formula you

299
00:15:11,290 --> 00:15:13,420
want EAX to be different from zero and

300
00:15:13,420 --> 00:15:15,990
two and the solution for that is one

301
00:15:15,990 --> 00:15:21,510
because we have missed one of the denote

302
00:15:21,510 --> 00:15:24,100
so that's the main advantage of using

303
00:15:24,100 --> 00:15:29,290
dynamic symbolic connection in theory so

304
00:15:29,290 --> 00:15:34,360
going dynamic AB the advantage of

305
00:15:34,360 --> 00:15:37,269
having feasible path so we are showing

306
00:15:37,269 --> 00:15:39,399
it to be suitable into the program we

307
00:15:39,399 --> 00:15:41,379
can potentially generate new inputs and

308
00:15:41,379 --> 00:15:44,619
it allows to thwart basic tricks of Fox

309
00:15:44,619 --> 00:15:47,439
education like code overlapping cells

310
00:15:47,439 --> 00:15:50,649
modification and things like this so in

311
00:15:50,649 --> 00:15:53,619
comparison to static and dynamic it's

312
00:15:53,619 --> 00:15:56,100
robust and correct thanks to dynamic

313
00:15:56,100 --> 00:15:59,589
aspect and it's more complete because it

314
00:15:59,589 --> 00:16:02,110
allows to generate new paths

315
00:16:02,110 --> 00:16:05,139
the main shortcomings of this method is

316
00:16:05,139 --> 00:16:07,509
that it has some scalability issues

317
00:16:07,509 --> 00:16:10,540
because when you have you obtain some

318
00:16:10,540 --> 00:16:13,569
strong relation on the path that it

319
00:16:13,569 --> 00:16:15,360
might be really difficult to solve and

320
00:16:15,360 --> 00:16:17,980
that makes it really difficult to scale

321
00:16:17,980 --> 00:16:23,290
then okay so we have dynamic simmer

322
00:16:23,290 --> 00:16:25,660
institution it allows us to find new

323
00:16:25,660 --> 00:16:27,759
target for dynamic gems to cover new

324
00:16:27,759 --> 00:16:30,519
branches and so on but what if instead

325
00:16:30,519 --> 00:16:33,100
we want to check some incredibility

326
00:16:33,100 --> 00:16:35,350
properties like we want to make sure

327
00:16:35,350 --> 00:16:39,970
that read instruction is always going to

328
00:16:39,970 --> 00:16:42,149
return to the cold instructions or

329
00:16:42,149 --> 00:16:45,009
another example for back predicate we

330
00:16:45,009 --> 00:16:47,350
want to to check that we are always

331
00:16:47,350 --> 00:16:51,069
going to check to take one of the two

332
00:16:51,069 --> 00:16:53,110
branches so we would like to check the

333
00:16:53,110 --> 00:16:56,439
infallibility of some events so in the

334
00:16:56,439 --> 00:16:57,910
case of Papa cricket it will be the

335
00:16:57,910 --> 00:17:00,759
increase ability of going into one of

336
00:17:00,759 --> 00:17:04,750
the two branches so there is a problem

337
00:17:04,750 --> 00:17:07,990
the Thunderer forwards DSE is not only

338
00:17:07,990 --> 00:17:12,279
adapt for such problem and that's why we

339
00:17:12,279 --> 00:17:15,130
propose a new approach which is the

340
00:17:15,130 --> 00:17:18,398
backward bounded DSC so it's a

341
00:17:18,398 --> 00:17:23,500
complementary approach to forward DSC so

342
00:17:23,500 --> 00:17:25,929
the basic idea is that you have for

343
00:17:25,929 --> 00:17:28,720
instance here a conditional jump and you

344
00:17:28,720 --> 00:17:31,269
would like to check that we cannot take

345
00:17:31,269 --> 00:17:33,970
for instance one of the two branches so

346
00:17:33,970 --> 00:17:35,740
you're going to execute it symbolically

347
00:17:35,740 --> 00:17:39,519
in a backward manner if you don't go

348
00:17:39,519 --> 00:17:43,630
back enough you will have you will not

349
00:17:43,630 --> 00:17:47,169
prove it to be infeasible if you manage

350
00:17:47,169 --> 00:17:47,830
for

351
00:17:47,830 --> 00:17:52,090
and here to read them to the email you

352
00:17:52,090 --> 00:17:55,390
will prove that you cannot get into the

353
00:17:55,390 --> 00:17:59,200
branch and if you manage to go up to

354
00:17:59,200 --> 00:18:00,490
here for instance you are complete

355
00:18:00,490 --> 00:18:02,260
because you have backtracked on all the

356
00:18:02,260 --> 00:18:08,049
dependencies of the registers another

357
00:18:08,049 --> 00:18:10,990
exam is for call stack tampering so

358
00:18:10,990 --> 00:18:12,490
basically if you have four read

359
00:18:12,490 --> 00:18:15,789
instructions here you go back to the

360
00:18:15,789 --> 00:18:18,130
return to the coal by symbolically

361
00:18:18,130 --> 00:18:21,519
executing it backward and you can have a

362
00:18:21,519 --> 00:18:23,200
false negative if you don't go back

363
00:18:23,200 --> 00:18:28,330
enough and and uh you can be correct if

364
00:18:28,330 --> 00:18:31,090
you find here there we have the

365
00:18:31,090 --> 00:18:34,330
tempering and you can manage to be

366
00:18:34,330 --> 00:18:36,130
complete if you cover all the branches

367
00:18:36,130 --> 00:18:40,480
leading to that read instruction okay so

368
00:18:40,480 --> 00:18:46,500
other summary the back part bounded DAC

369
00:18:46,500 --> 00:18:50,139
is bounded so the main advantage to this

370
00:18:50,139 --> 00:18:52,659
approach is that it's scale to whatever

371
00:18:52,659 --> 00:18:55,360
track execution trust length you are

372
00:18:55,360 --> 00:18:57,639
dealing with and that's important for

373
00:18:57,639 --> 00:19:01,090
obfuscation and it does not solve the

374
00:19:01,090 --> 00:19:04,990
same problem that stand or DAC so it's a

375
00:19:04,990 --> 00:19:07,630
complimentary approach the point is that

376
00:19:07,630 --> 00:19:09,730
here for instance if you go back four

377
00:19:09,730 --> 00:19:13,600
steps backward from the logical point of

378
00:19:13,600 --> 00:19:15,850
view you are going to over approximate

379
00:19:15,850 --> 00:19:17,710
all the possible paths leading to that

380
00:19:17,710 --> 00:19:21,700
location and moving one step further if

381
00:19:21,700 --> 00:19:23,799
you have proved your property by moving

382
00:19:23,799 --> 00:19:27,450
four steps backward it will still be

383
00:19:27,450 --> 00:19:33,250
infeasible by moving five steps so and

384
00:19:33,250 --> 00:19:35,830
it's not forced negative neither false

385
00:19:35,830 --> 00:19:39,010
positive free but the rates are quite

386
00:19:39,010 --> 00:19:45,389
low okay what about the bound selection

387
00:19:45,389 --> 00:19:48,100
so typically for caustic tempering we

388
00:19:48,100 --> 00:19:50,049
are going to return from the red to the

389
00:19:50,049 --> 00:19:52,980
cold and for back for decades

390
00:19:52,980 --> 00:19:56,020
the point is finding the right balance

391
00:19:56,020 --> 00:19:58,630
between the false negative you can we

392
00:19:58,630 --> 00:20:01,149
can have on the false positive and by

393
00:20:01,149 --> 00:20:01,779
bit

394
00:20:01,779 --> 00:20:03,759
marking classical back predicate that

395
00:20:03,759 --> 00:20:08,049
you have found usually 16 to 20

396
00:20:08,049 --> 00:20:10,210
instruction backward with enough for

397
00:20:10,210 --> 00:20:16,269
proving the the opacity of predicate so

398
00:20:16,269 --> 00:20:20,080
the idea is to use this algorithm into a

399
00:20:20,080 --> 00:20:22,779
combination of dynamic disassembly

400
00:20:22,779 --> 00:20:25,719
static disassembly and dynamic symbolic

401
00:20:25,719 --> 00:20:29,729
execution and the high D is to compute

402
00:20:29,729 --> 00:20:32,759
some obfuscation related data with

403
00:20:32,759 --> 00:20:36,690
symbolic execution and provide it to

404
00:20:36,690 --> 00:20:39,389
static disassembly in order to

405
00:20:39,389 --> 00:20:41,679
preventing it to disassemble dead

406
00:20:41,679 --> 00:20:45,129
branches I'm telling it to disassemble

407
00:20:45,129 --> 00:20:49,629
read targets and things like this so

408
00:20:49,629 --> 00:20:56,460
that is from a safe a partial graph you

409
00:20:56,460 --> 00:20:58,570
improve it with static disassembly

410
00:20:58,570 --> 00:21:02,229
guided by dynamic symbolic execution and

411
00:21:02,229 --> 00:21:04,149
you get potentially with dynamic

412
00:21:04,149 --> 00:21:05,649
symbolic execution by the way generate

413
00:21:05,649 --> 00:21:08,440
new inputs for generating new traces and

414
00:21:08,440 --> 00:21:14,019
so on so has an example here you we have

415
00:21:14,019 --> 00:21:17,379
a partial graph obtained by running the

416
00:21:17,379 --> 00:21:21,940
program we have handled some targets for

417
00:21:21,940 --> 00:21:24,969
dynamic jumps because we are doing it

418
00:21:24,969 --> 00:21:29,529
dynamically we can induce some layers of

419
00:21:29,529 --> 00:21:32,559
self modification because we are simply

420
00:21:32,559 --> 00:21:36,519
going to execute them then you can

421
00:21:36,519 --> 00:21:39,940
enlarge the the control flow graph we

422
00:21:39,940 --> 00:21:43,330
static disassembly and also preventing

423
00:21:43,330 --> 00:21:45,249
the static is a zombie to disassemble

424
00:21:45,249 --> 00:21:48,580
for instance here a dead branches if you

425
00:21:48,580 --> 00:21:51,969
manage to prove that it's so back we can

426
00:21:51,969 --> 00:21:55,119
man instruct the static dessert for me

427
00:21:55,119 --> 00:21:58,269
to disassemble wet target if they are

428
00:21:58,269 --> 00:22:00,789
not returning to the call and obviously

429
00:22:00,789 --> 00:22:02,889
we can instruct a statically that's only

430
00:22:02,889 --> 00:22:07,690
not to disassemble the instruction right

431
00:22:07,690 --> 00:22:10,859
after the call if we never written to it

432
00:22:10,859 --> 00:22:13,679
followed by basically student some more

433
00:22:13,679 --> 00:22:15,510
safe and precise

434
00:22:15,510 --> 00:22:19,080
either somebody of the program okay so

435
00:22:19,080 --> 00:22:21,600
this combination and these algorithms

436
00:22:21,600 --> 00:22:24,000
you are implementing it them into bin

437
00:22:24,000 --> 00:22:26,340
sack which is our platform for binary

438
00:22:26,340 --> 00:22:27,110
analysis

439
00:22:27,110 --> 00:22:29,640
it's basically composed of three

440
00:22:29,640 --> 00:22:32,670
entities the main platform we bin check

441
00:22:32,670 --> 00:22:34,950
which is doing static analysis symbolic

442
00:22:34,950 --> 00:22:37,800
executions and many other

443
00:22:37,800 --> 00:22:40,950
functionalities we are using a tool

444
00:22:40,950 --> 00:22:42,720
called pin Tech which is our dynamic

445
00:22:42,720 --> 00:22:44,730
instrumentation which is basically based

446
00:22:44,730 --> 00:22:50,130
on pin so for now we only do x86 and the

447
00:22:50,130 --> 00:22:54,600
last entity is hydrosect which is a hide

448
00:22:54,600 --> 00:22:57,060
a plugin for triggering analysis

449
00:22:57,060 --> 00:22:59,760
recovering the result and so on and all

450
00:22:59,760 --> 00:23:02,400
these three entities our community with

451
00:23:02,400 --> 00:23:07,350
misses queuing and 0 mq okay so pins

452
00:23:07,350 --> 00:23:10,620
like is based on pin not the latest

453
00:23:10,620 --> 00:23:13,800
versions but the one before he can

454
00:23:13,800 --> 00:23:15,990
generate obviously execution trace in

455
00:23:15,990 --> 00:23:18,720
protobuf it works on Linux Windows we

456
00:23:18,720 --> 00:23:21,060
can configure it with JSON file for

457
00:23:21,060 --> 00:23:22,920
instance if you'd like to do some

458
00:23:22,920 --> 00:23:26,220
on-the-fly value patching or all these

459
00:23:26,220 --> 00:23:29,220
kind of things and it keep tracks of the

460
00:23:29,220 --> 00:23:31,530
self modification layer that we we might

461
00:23:31,530 --> 00:23:36,240
be executing problem is that we don't

462
00:23:36,240 --> 00:23:39,240
have all the anti debug all the mtv vm

463
00:23:39,240 --> 00:23:41,460
control measures that might be used by

464
00:23:41,460 --> 00:23:46,220
malware for evading such instrumentation

465
00:23:46,220 --> 00:23:49,710
then bin sec it basically provides a

466
00:23:49,710 --> 00:23:52,620
front-end for x86 into our intermediate

467
00:23:52,620 --> 00:23:55,290
representation and provide some static

468
00:23:55,290 --> 00:23:59,100
analysis abstract interpretation and I

469
00:23:59,100 --> 00:24:01,710
did implemented the dynamic symbolic

470
00:24:01,710 --> 00:24:04,640
execution so we provide many

471
00:24:04,640 --> 00:24:08,940
functionalities for pass coverage and so

472
00:24:08,940 --> 00:24:14,760
on and the most critical points on which

473
00:24:14,760 --> 00:24:19,380
we have invested most of our time was

474
00:24:19,380 --> 00:24:21,480
the path predicate optimization because

475
00:24:21,480 --> 00:24:24,930
in the end the problem is always the

476
00:24:24,930 --> 00:24:27,060
scalability of the formula you are going

477
00:24:27,060 --> 00:24:29,560
to generate so

478
00:24:29,560 --> 00:24:31,540
this is the most critical part you have

479
00:24:31,540 --> 00:24:34,560
to to generate formula that are

480
00:24:34,560 --> 00:24:37,060
optimized enough to be solvable in a

481
00:24:37,060 --> 00:24:40,390
reasonable amount of time so there's a

482
00:24:40,390 --> 00:24:43,270
lot of other dynamic symbolic execution

483
00:24:43,270 --> 00:24:46,660
out there free time I am s2e and

484
00:24:46,660 --> 00:24:49,900
basically all the CGG challenger of the

485
00:24:49,900 --> 00:24:54,250
Doppler challenge either

486
00:24:54,250 --> 00:24:57,160
it's a arm plugin for either that

487
00:24:57,160 --> 00:24:59,620
leverage the results of the analysis

488
00:24:59,620 --> 00:25:01,840
into either because it provides some

489
00:25:01,840 --> 00:25:06,460
nice UI and high-level functionality for

490
00:25:06,460 --> 00:25:08,770
manipulating binaries so we take

491
00:25:08,770 --> 00:25:12,610
advantage of this and it basically do

492
00:25:12,610 --> 00:25:17,950
the post analysis of the results okay so

493
00:25:17,950 --> 00:25:20,260
that's great but let's move on to the

494
00:25:20,260 --> 00:25:26,050
concrete studies so we selected 33

495
00:25:26,050 --> 00:25:29,920
Packers from the wall and we say okay

496
00:25:29,920 --> 00:25:31,720
let's try to find if there is some OPAC

497
00:25:31,720 --> 00:25:33,580
predicates or contact tampering into

498
00:25:33,580 --> 00:25:39,220
them so we basically analyze 30 33 of

499
00:25:39,220 --> 00:25:42,910
them we bounded the execution to with 10

500
00:25:42,910 --> 00:25:45,610
million instructions and the gold was

501
00:25:45,610 --> 00:25:48,490
basically to perform some kind of fully

502
00:25:48,490 --> 00:25:51,160
automated and systematic analysis of the

503
00:25:51,160 --> 00:25:56,590
Packers to to validate our approaches so

504
00:25:56,590 --> 00:25:58,420
this is the results they are not

505
00:25:58,420 --> 00:26:02,680
complete but this is some of them that's

506
00:26:02,680 --> 00:26:04,870
kind of dense but what we can quickly

507
00:26:04,870 --> 00:26:08,320
see is that ok the analysis scale

508
00:26:08,320 --> 00:26:11,020
because we managed to thanks to the

509
00:26:11,020 --> 00:26:13,380
backboard bound edse we managed to

510
00:26:13,380 --> 00:26:17,610
analyze multimillion tracks lamp paths

511
00:26:17,610 --> 00:26:21,670
so the techniques works well and it

512
00:26:21,670 --> 00:26:23,860
basically managed also to find some good

513
00:26:23,860 --> 00:26:26,920
matches for OPIC predicates and caustic

514
00:26:26,920 --> 00:26:30,640
tempering and with that amount of values

515
00:26:30,640 --> 00:26:35,140
it's beyond false positive rate and the

516
00:26:35,140 --> 00:26:38,650
last aspect that was surprising is for

517
00:26:38,650 --> 00:26:40,929
instance some of the factors only have

518
00:26:40,929 --> 00:26:43,120
one tempering

519
00:26:43,120 --> 00:26:46,120
for the read instructions and it

520
00:26:46,120 --> 00:26:48,580
appeared that it was Packer that were

521
00:26:48,580 --> 00:26:50,860
doing the tail transition to the

522
00:26:50,860 --> 00:26:53,650
original entry point of the program by

523
00:26:53,650 --> 00:26:55,810
doing a push and right instructions

524
00:26:55,810 --> 00:26:57,850
so obviously the RET instruction is

525
00:26:57,850 --> 00:27:02,890
going to be detected as tempered okay

526
00:27:02,890 --> 00:27:06,400
what we have found into into it so for

527
00:27:06,400 --> 00:27:08,560
instance in AC products we found plenty

528
00:27:08,560 --> 00:27:10,480
of a pack predicate and there were

529
00:27:10,480 --> 00:27:14,280
basically just chaining our to strictly

530
00:27:14,280 --> 00:27:17,770
exclusive conditions so GS g NS and we

531
00:27:17,770 --> 00:27:21,010
found all the possible alternatives so g

532
00:27:21,010 --> 00:27:26,320
PG and PG o GN o and so on why not we

533
00:27:26,320 --> 00:27:29,050
found in armadillo door is e^x is e^x

534
00:27:29,050 --> 00:27:32,680
it's obviously going to be zero so we

535
00:27:32,680 --> 00:27:34,390
are always going to take one punch

536
00:27:34,390 --> 00:27:39,010
that's primitive but still working on

537
00:27:39,010 --> 00:27:42,100
from contact tampering into for instance

538
00:27:42,100 --> 00:27:44,320
HP product so this is basically the four

539
00:27:44,320 --> 00:27:46,330
first instruction of the program this

540
00:27:46,330 --> 00:27:49,630
push push read read so basically when

541
00:27:49,630 --> 00:27:51,520
you disassemble with Ida it just gives

542
00:27:51,520 --> 00:27:54,010
you four instruction so it's not really

543
00:27:54,010 --> 00:27:56,670
worth it

544
00:27:56,670 --> 00:27:58,960
another one that we found also in AC

545
00:27:58,960 --> 00:28:02,440
product so we perform a call and then we

546
00:28:02,440 --> 00:28:04,600
modify at the top of the stack the value

547
00:28:04,600 --> 00:28:06,760
will just return to it so we're going to

548
00:28:06,760 --> 00:28:11,170
jump somewhere else another caustic

549
00:28:11,170 --> 00:28:12,820
tampering that you found in aspect this

550
00:28:12,820 --> 00:28:15,690
time and the dynamic instrumentation

551
00:28:15,690 --> 00:28:18,910
yielded that we did entered into a new

552
00:28:18,910 --> 00:28:22,960
process modification layer and so you

553
00:28:22,960 --> 00:28:25,150
can see the tampering here push zero in

554
00:28:25,150 --> 00:28:28,900
red but on dynamically at the execution

555
00:28:28,900 --> 00:28:32,410
at wrong time did instruction the move

556
00:28:32,410 --> 00:28:34,960
is going to patch the push instructions

557
00:28:34,960 --> 00:28:37,150
with the original trim point and then

558
00:28:37,150 --> 00:28:40,150
jumped into the original program so

559
00:28:40,150 --> 00:28:42,580
that's why we detected that we did enter

560
00:28:42,580 --> 00:28:46,120
into a new soft modification layer last

561
00:28:46,120 --> 00:28:49,090
example is an attack predicate in aspect

562
00:28:49,090 --> 00:28:52,930
so you have moved 0 into BL compare dl

563
00:28:52,930 --> 00:28:56,830
to 0 and GN z so when i reversed

564
00:28:56,830 --> 00:28:58,780
the program I'm looking to it I was like

565
00:28:58,780 --> 00:29:01,270
okay that'll apply predicates our

566
00:29:01,270 --> 00:29:04,390
algorithm will manage to find it but

567
00:29:04,390 --> 00:29:07,020
under our while looking at the results

568
00:29:07,020 --> 00:29:09,370
the resultant yeah now it's okay I've

569
00:29:09,370 --> 00:29:12,040
covered the two branches so I was like

570
00:29:12,040 --> 00:29:13,450
okay there's something wrong with my

571
00:29:13,450 --> 00:29:16,870
algorithms but by looking at the dynamic

572
00:29:16,870 --> 00:29:19,960
execution trace I just can kind of the

573
00:29:19,960 --> 00:29:22,500
same trick and it appeared that the

574
00:29:22,500 --> 00:29:24,970
instructions that is on the right branch

575
00:29:24,970 --> 00:29:28,870
is going to patch the opcodes of the

576
00:29:28,870 --> 00:29:31,240
move so that later on when you come back

577
00:29:31,240 --> 00:29:33,520
in the GN that you're going to take the

578
00:29:33,520 --> 00:29:38,080
other branch and that's pretty much why

579
00:29:38,080 --> 00:29:41,260
we validate the fact that it's

580
00:29:41,260 --> 00:29:42,730
interesting to retain the dynamic

581
00:29:42,730 --> 00:29:45,190
symbolic execution rather than purely

582
00:29:45,190 --> 00:29:47,680
static because purely static stability

583
00:29:47,680 --> 00:29:50,740
section whom have detected such are

584
00:29:50,740 --> 00:29:57,280
tricks okay so let's go on to the the

585
00:29:57,280 --> 00:30:01,900
big deal external so you've probably

586
00:30:01,900 --> 00:30:04,720
heard about this group for the past few

587
00:30:04,720 --> 00:30:07,570
months so they goes by the name of 850

588
00:30:07,570 --> 00:30:10,930
28 fancy bare surfaces that need one

589
00:30:10,930 --> 00:30:14,530
storm and so on they have been targeting

590
00:30:14,530 --> 00:30:19,210
lots of with entities they - you German

591
00:30:19,210 --> 00:30:22,780
Parliament's TVs like Mon in France and

592
00:30:22,780 --> 00:30:25,240
recently the Democratic National

593
00:30:25,240 --> 00:30:30,750
Committee GMC it basically used lots of

594
00:30:30,750 --> 00:30:34,170
zero days to to spread it to infect the

595
00:30:34,170 --> 00:30:39,340
the targets and very recently yeah very

596
00:30:39,340 --> 00:30:43,390
recently an electoral ballot is this

597
00:30:43,390 --> 00:30:46,870
Monday Monday there was the release of

598
00:30:46,870 --> 00:30:50,290
the details by Google of zero day into

599
00:30:50,290 --> 00:30:52,840
flash and Windows 10 for sandbox escape

600
00:30:52,840 --> 00:30:55,840
and it appeared that it was this group

601
00:30:55,840 --> 00:30:58,960
that was using it for targeting the

602
00:30:58,960 --> 00:31:03,180
targets so they also use plenty of tools

603
00:31:03,180 --> 00:31:06,850
droppers downloaders rootkit boot kit

604
00:31:06,850 --> 00:31:09,630
and so on and we are going to

605
00:31:09,630 --> 00:31:15,270
focus on external okay so the main

606
00:31:15,270 --> 00:31:19,710
malware is expedient it's running on the

607
00:31:19,710 --> 00:31:21,990
infected machines and they're going to

608
00:31:21,990 --> 00:31:23,010
find

609
00:31:23,010 --> 00:31:25,200
trying to reach the CNC server the

610
00:31:25,200 --> 00:31:27,390
control command server and if you cannot

611
00:31:27,390 --> 00:31:30,299
connect to it directly it's going to

612
00:31:30,299 --> 00:31:32,010
find on the internal network if you can

613
00:31:32,010 --> 00:31:35,610
find the external malware or to connect

614
00:31:35,610 --> 00:31:39,179
to the CMT through it so external is

615
00:31:39,179 --> 00:31:43,710
basically a proxy a ciphering proxy that

616
00:31:43,710 --> 00:31:45,600
is going to encapsulate all the

617
00:31:45,600 --> 00:31:49,230
connections to rc4 cipher and

618
00:31:49,230 --> 00:31:52,850
encapsulate the whole thing into TLS and

619
00:31:52,850 --> 00:31:55,289
a friend of mine John Caliphate that

620
00:31:55,289 --> 00:31:58,679
would like to thank providing me three

621
00:31:58,679 --> 00:32:04,620
samples of external the first one is has

622
00:32:04,620 --> 00:32:08,070
been compiled in June 2015 if dates are

623
00:32:08,070 --> 00:32:11,070
correct and it probably melted two other

624
00:32:11,070 --> 00:32:15,570
samples and the point is on the two

625
00:32:15,570 --> 00:32:18,270
other samples are twice bigger than the

626
00:32:18,270 --> 00:32:21,539
original sample almost so first the

627
00:32:21,539 --> 00:32:24,120
first one is 1.1 megabytes and the to

628
00:32:24,120 --> 00:32:29,429
order at 2.1 and 1.8 megabytes so and if

629
00:32:29,429 --> 00:32:31,140
dates are still correct

630
00:32:31,140 --> 00:32:32,760
they have been combined like the second

631
00:32:32,760 --> 00:32:34,830
one I think about one week later and the

632
00:32:34,830 --> 00:32:37,350
other one few months later so that will

633
00:32:37,350 --> 00:32:39,960
be surprising to add so that much new

634
00:32:39,960 --> 00:32:41,880
functionalities into the program within

635
00:32:41,880 --> 00:32:44,669
the small range of time so just by

636
00:32:44,669 --> 00:32:48,059
looking into it we we found lots and

637
00:32:48,059 --> 00:32:50,490
lots and lots of a pack for decades so

638
00:32:50,490 --> 00:32:53,880
the first question was ok can we remove

639
00:32:53,880 --> 00:32:59,130
it and the answer is yes so far it works

640
00:32:59,130 --> 00:33:02,330
well and one of the main questions was

641
00:33:02,330 --> 00:33:05,280
are there new functionality into G up to

642
00:33:05,280 --> 00:33:06,960
scale it binaries because what we would

643
00:33:06,960 --> 00:33:08,850
analyze a few scary binaries if you have

644
00:33:08,850 --> 00:33:12,120
not obsessed gated one and the answer

645
00:33:12,120 --> 00:33:13,770
lies that we'd like to know if there is

646
00:33:13,770 --> 00:33:15,840
new functionalities into the duplicated

647
00:33:15,840 --> 00:33:19,650
samples and the answer for that is I

648
00:33:19,650 --> 00:33:22,080
don't know

649
00:33:22,080 --> 00:33:24,120
okay but because I've get rid of the

650
00:33:24,120 --> 00:33:26,910
obfuscation this is the next step toward

651
00:33:26,910 --> 00:33:28,830
finding there is a function actually I'm

652
00:33:28,830 --> 00:33:31,200
going to to give some insights of there

653
00:33:31,200 --> 00:33:34,860
or not there is new tonight into it so

654
00:33:34,860 --> 00:33:38,370
what the analysis context so first we

655
00:33:38,370 --> 00:33:40,710
are going to go fully static in a

656
00:33:40,710 --> 00:33:42,390
position to what we have presented

657
00:33:42,390 --> 00:33:45,000
before because it appeared that the

658
00:33:45,000 --> 00:33:47,130
malware was not using any access

659
00:33:47,130 --> 00:33:49,230
modification features so we basically

660
00:33:49,230 --> 00:33:51,000
have the whole CFG even though it's

661
00:33:51,000 --> 00:33:54,600
really big and a good argument is that

662
00:33:54,600 --> 00:33:56,850
we don't want to connect to the command

663
00:33:56,850 --> 00:33:59,220
control server neither to wait for

664
00:33:59,220 --> 00:34:02,370
clients to connect on the the proxy in

665
00:34:02,370 --> 00:34:04,800
order to obtain some relevant executions

666
00:34:04,800 --> 00:34:08,360
so we are going to do it for aesthetic

667
00:34:08,360 --> 00:34:11,370
so first that we perform our epic

668
00:34:11,370 --> 00:34:13,020
predicate detection with our backward

669
00:34:13,020 --> 00:34:16,770
bounded GC and so on we will try to

670
00:34:16,770 --> 00:34:20,639
recover some high-level predicates so

671
00:34:20,639 --> 00:34:22,920
trying to find what kind of predicates

672
00:34:22,920 --> 00:34:27,300
the absolute then if everything goes

673
00:34:27,300 --> 00:34:28,949
right in the two first steps we should

674
00:34:28,949 --> 00:34:32,100
be able to remove all dead code and the

675
00:34:32,100 --> 00:34:34,980
spurious instructions so basically it's

676
00:34:34,980 --> 00:34:36,630
various instructions or instructions

677
00:34:36,630 --> 00:34:39,360
that are involved into the OPAC

678
00:34:39,360 --> 00:34:42,330
predicate computation but only for that

679
00:34:42,330 --> 00:34:44,850
so if you manage to prove that there is

680
00:34:44,850 --> 00:34:47,670
not bad predicate you can basically get

681
00:34:47,670 --> 00:34:48,750
rid of the instruction that are

682
00:34:48,750 --> 00:34:53,550
completing it and last if anything goes

683
00:34:53,550 --> 00:34:57,150
right up to here we normally should be

684
00:34:57,150 --> 00:35:01,110
able to extract the unab CA d CFG of the

685
00:35:01,110 --> 00:35:06,390
program okay so a few points about the

686
00:35:06,390 --> 00:35:10,950
high-level predicate recovery so the

687
00:35:10,950 --> 00:35:12,900
goal is to complete the dependency on

688
00:35:12,900 --> 00:35:15,750
the predicate in order to backtrack all

689
00:35:15,750 --> 00:35:18,120
the the instructions involved in the

690
00:35:18,120 --> 00:35:21,390
computation so on the left you have an

691
00:35:21,390 --> 00:35:23,430
example of an applied predicates that

692
00:35:23,430 --> 00:35:27,000
you have flown into eternal and on the

693
00:35:27,000 --> 00:35:31,200
right you have the formula generated in

694
00:35:31,200 --> 00:35:31,890
SMT

695
00:35:31,890 --> 00:35:34,410
so if you basically backtrack

696
00:35:34,410 --> 00:35:37,799
on the two parameters of the compare you

697
00:35:37,799 --> 00:35:40,609
can basically normally recreate the

698
00:35:40,609 --> 00:35:44,400
expressions that is being computed for

699
00:35:44,400 --> 00:35:47,460
instance here its beauty meal and so on

700
00:35:47,460 --> 00:35:51,059
and you fold the whole thing you obtain

701
00:35:51,059 --> 00:35:54,450
the predicate synthesized and by

702
00:35:54,450 --> 00:35:57,450
replacing the register with XYZ and so

703
00:35:57,450 --> 00:36:01,250
on so the idea of this is was trying to

704
00:36:01,250 --> 00:36:04,559
identify the different patterns that

705
00:36:04,559 --> 00:36:09,000
I've used okay what about the results so

706
00:36:09,000 --> 00:36:12,980
the two binaries basically have three

707
00:36:12,980 --> 00:36:17,390
30,000 conditional gems that we all text

708
00:36:17,390 --> 00:36:20,700
the the symbolic eviction took one hour

709
00:36:20,700 --> 00:36:24,960
mostly and the synthesis also but I was

710
00:36:24,960 --> 00:36:29,190
not I didn't really optimized it it was

711
00:36:29,190 --> 00:36:31,770
in Python running into I dog it's kind

712
00:36:31,770 --> 00:36:34,980
of yeah I could have done better and so

713
00:36:34,980 --> 00:36:36,450
basically the analysis of the two

714
00:36:36,450 --> 00:36:39,180
temples took 1 hour and half which is

715
00:36:39,180 --> 00:36:43,440
okay if you have time or if you want to

716
00:36:43,440 --> 00:36:50,430
take for many coffees with okay so

717
00:36:50,430 --> 00:36:53,010
basically Alf of the conditional objects

718
00:36:53,010 --> 00:36:55,349
or genuine conditional jumps which are

719
00:36:55,349 --> 00:36:57,599
right which is good and the significant

720
00:36:57,599 --> 00:37:01,950
amount of them are effects and among

721
00:37:01,950 --> 00:37:04,529
them we managed to find what are the how

722
00:37:04,529 --> 00:37:06,170
many false positive and false negative

723
00:37:06,170 --> 00:37:09,329
there were and the question is how do we

724
00:37:09,329 --> 00:37:11,819
have obtained the false positive and

725
00:37:11,819 --> 00:37:14,190
false negative and this is basically

726
00:37:14,190 --> 00:37:17,039
because the synthesis yelled that they

727
00:37:17,039 --> 00:37:19,650
only use two different predicates into

728
00:37:19,650 --> 00:37:24,720
the program so the well-known seven x y

729
00:37:24,720 --> 00:37:28,049
square and so on and another one that we

730
00:37:28,049 --> 00:37:29,599
have never seen elsewhere in other

731
00:37:29,599 --> 00:37:32,520
obfuscators which might be good for

732
00:37:32,520 --> 00:37:34,140
doing some signatures or I don't know

733
00:37:34,140 --> 00:37:37,589
and using these two patterns have been

734
00:37:37,589 --> 00:37:40,950
able to identify among the result which

735
00:37:40,950 --> 00:37:42,839
predicates were false positive and which

736
00:37:42,839 --> 00:37:45,750
one were false negative and we basically

737
00:37:45,750 --> 00:37:48,950
miss really few of them

738
00:37:48,950 --> 00:37:54,330
okay then then I try to find what was

739
00:37:54,330 --> 00:37:56,460
bad ik distributions of the obfuscation

740
00:37:56,460 --> 00:37:59,460
within the the functions and it appeared

741
00:37:59,460 --> 00:38:03,330
that most of the functions are not

742
00:38:03,330 --> 00:38:06,570
obfuscated at all so three thousands of

743
00:38:06,570 --> 00:38:09,540
them are not sophisticated and by

744
00:38:09,540 --> 00:38:11,940
looking at them it was basically the the

745
00:38:11,940 --> 00:38:14,160
functions of the statically linked

746
00:38:14,160 --> 00:38:16,080
libraries that were embedded into the

747
00:38:16,080 --> 00:38:19,080
program they are using open ssl and so

748
00:38:19,080 --> 00:38:20,250
on and all these functions are not

749
00:38:20,250 --> 00:38:23,850
officiated why not but it allows us to

750
00:38:23,850 --> 00:38:26,940
narrow the analysis on the obfuscated

751
00:38:26,940 --> 00:38:30,120
sample so we only have like 500

752
00:38:30,120 --> 00:38:33,540
frictions remaining so that's a lot but

753
00:38:33,540 --> 00:38:35,940
that's better than three thousands of

754
00:38:35,940 --> 00:38:42,510
them the code coverage so we started

755
00:38:42,510 --> 00:38:46,770
from five hundred thousands instruction

756
00:38:46,770 --> 00:38:50,210
by propagating the liveness of

757
00:38:50,210 --> 00:38:52,980
instructions we obtain two hundred

758
00:38:52,980 --> 00:38:54,570
thousands of them that were still alive

759
00:38:54,570 --> 00:38:57,270
and when you remove the dead instruction

760
00:38:57,270 --> 00:38:59,910
and spurious instructions you obtain

761
00:38:59,910 --> 00:39:04,140
basically our difference with the an

762
00:39:04,140 --> 00:39:07,020
upscale example which is for the simple

763
00:39:07,020 --> 00:39:10,020
one forty seven thousand instruction and

764
00:39:10,020 --> 00:39:12,750
for the second temple is nine thousand

765
00:39:12,750 --> 00:39:16,350
instructions so that's actually really

766
00:39:16,350 --> 00:39:19,890
low could that be noise that remains

767
00:39:19,890 --> 00:39:22,920
from our analogy that could have meet

768
00:39:22,920 --> 00:39:28,110
some spurious instruction also on so we

769
00:39:28,110 --> 00:39:31,980
with these results we are kind of not

770
00:39:31,980 --> 00:39:33,990
optimistic about the fact that there is

771
00:39:33,990 --> 00:39:35,820
really new functionalities in dedicated

772
00:39:35,820 --> 00:39:42,960
samples so basically you have the

773
00:39:42,960 --> 00:39:45,330
control flow graph of a function I took

774
00:39:45,330 --> 00:39:48,330
the first one I've found when you

775
00:39:48,330 --> 00:39:50,460
perform the analysis you are able to to

776
00:39:50,460 --> 00:39:52,440
flag the basic blocks if their lives

777
00:39:52,440 --> 00:39:55,890
dead and so on and this allows you to

778
00:39:55,890 --> 00:39:57,560
extract from it

779
00:39:57,560 --> 00:40:01,369
the unassociated

780
00:40:01,369 --> 00:40:05,869
control flow graph okay so I'm going to

781
00:40:05,869 --> 00:40:11,770
do a quick demo so I'm going to run

782
00:40:13,030 --> 00:40:18,320
binstock power as a server so it turns

783
00:40:18,320 --> 00:40:22,580
locally on my machine and then I'm going

784
00:40:22,580 --> 00:40:31,610
to launch Shia so this is external this

785
00:40:31,610 --> 00:40:33,350
is one of the first function function is

786
00:40:33,350 --> 00:40:39,650
the start function it's kind of big but

787
00:40:39,650 --> 00:40:42,460
not that much

788
00:40:45,580 --> 00:40:53,960
I'm loading hide effect our plugin I'm

789
00:40:53,960 --> 00:40:57,800
going to connect to VIN cyclically so so

790
00:40:57,800 --> 00:41:00,560
here we are we are connected and I'm

791
00:41:00,560 --> 00:41:02,030
going to trigger the analogy that

792
00:41:02,030 --> 00:41:04,520
developed for for these samples the

793
00:41:04,520 --> 00:41:06,619
static go back so the back predicate

794
00:41:06,619 --> 00:41:10,280
analysis but statically we set the bound

795
00:41:10,280 --> 00:41:12,770
to 16 it should be enough for most of

796
00:41:12,770 --> 00:41:21,020
them and with and I'm going only to

797
00:41:21,020 --> 00:41:25,070
analyze this routine okay so these

798
00:41:25,070 --> 00:41:28,880
basically generates design configuration

799
00:41:28,880 --> 00:41:30,609
pilot is going to be sent to be insect

800
00:41:30,609 --> 00:41:34,420
along with all the sub passes of the

801
00:41:34,420 --> 00:41:38,750
conditional jumps of the functions and B

802
00:41:38,750 --> 00:41:41,270
okay so start there is 45 conditional

803
00:41:41,270 --> 00:41:43,580
jumps in the functions so it processes

804
00:41:43,580 --> 00:41:50,900
them all and here it is so among the 45

805
00:41:50,900 --> 00:41:52,820
conditional jumps there is only two of

806
00:41:52,820 --> 00:41:56,270
them that were genuine and 43 of the

807
00:41:56,270 --> 00:41:58,850
others were back predicates and we can

808
00:41:58,850 --> 00:42:01,490
double check it by looking at the

809
00:42:01,490 --> 00:42:03,200
predicates that have been synthesized

810
00:42:03,200 --> 00:42:05,630
and as you can see it's always the same

811
00:42:05,630 --> 00:42:08,750
kind of sometimes we did not manage to

812
00:42:08,750 --> 00:42:10,700
replace the register by a placeholder

813
00:42:10,700 --> 00:42:13,400
but we can basically see that their

814
00:42:13,400 --> 00:42:14,270
whole

815
00:42:14,270 --> 00:42:17,810
the same predicates and among them there

816
00:42:17,810 --> 00:42:20,870
was only two that were not the back so

817
00:42:20,870 --> 00:42:23,810
at the top of that I've implemented like

818
00:42:23,810 --> 00:42:26,540
fancy functionalities for highlighting

819
00:42:26,540 --> 00:42:29,870
in the control flow graph what is that

820
00:42:29,870 --> 00:42:31,940
what is alive so so that tells us to

821
00:42:31,940 --> 00:42:36,620
quickly see what what's of interest I

822
00:42:36,620 --> 00:42:39,260
can also a lie highlight the spurious

823
00:42:39,260 --> 00:42:41,600
instructions here you can see that all

824
00:42:41,600 --> 00:42:45,080
this insertions are just calculating the

825
00:42:45,080 --> 00:42:48,560
OPAC predicates so if you remove it you

826
00:42:48,560 --> 00:42:53,600
can basically have the pain and at the

827
00:42:53,600 --> 00:42:57,790
top of that we can have like to hide a

828
00:42:57,790 --> 00:43:01,280
ap I have done some extractions to

829
00:43:01,280 --> 00:43:09,770
reduce CFG and here it is so this is

830
00:43:09,770 --> 00:43:11,540
basically the function without all the

831
00:43:11,540 --> 00:43:13,790
spirits instruction and date code which

832
00:43:13,790 --> 00:43:18,110
is more visible and usable for further

833
00:43:18,110 --> 00:43:25,490
analysis okay so it's back to you okay

834
00:43:25,490 --> 00:43:26,750
so what are your conclusions about

835
00:43:26,750 --> 00:43:30,350
external so manual checking of extracted

836
00:43:30,350 --> 00:43:32,960
CFG with the original functions of the

837
00:43:32,960 --> 00:43:37,030
first samples didn't yield really

838
00:43:37,030 --> 00:43:40,580
significant differences or any new

839
00:43:40,580 --> 00:43:42,020
functionalities but that would really

840
00:43:42,020 --> 00:43:45,470
require more in-depth blood similarity

841
00:43:45,470 --> 00:43:49,940
like bindi for so long for trying to

842
00:43:49,940 --> 00:43:52,910
find this among these 500 remaining

843
00:43:52,910 --> 00:43:54,560
functions you can find something of

844
00:43:54,560 --> 00:43:57,830
interest the application itself is

845
00:43:57,830 --> 00:44:00,850
natural II it was kind of great because

846
00:44:00,850 --> 00:44:06,380
they managed to create some four

847
00:44:06,380 --> 00:44:08,690
dependencies between the instantiation

848
00:44:08,690 --> 00:44:11,090
of variables when they are usage to the

849
00:44:11,090 --> 00:44:14,960
predicate so the depth might be quite

850
00:44:14,960 --> 00:44:20,900
big and also they do some code reuse

851
00:44:20,900 --> 00:44:23,270
code sharing between the predicates so

852
00:44:23,270 --> 00:44:25,610
all the predicated nor are not

853
00:44:25,610 --> 00:44:27,130
standalone

854
00:44:27,130 --> 00:44:29,110
are relying on each other for computing

855
00:44:29,110 --> 00:44:31,780
some parts and so on so I kind of caught

856
00:44:31,780 --> 00:44:34,120
sharing and dependency bit with each

857
00:44:34,120 --> 00:44:38,470
other and I would ally and I chef if you

858
00:44:38,470 --> 00:44:40,480
want to have more information about the

859
00:44:40,480 --> 00:44:42,790
external excitement and so on I highly

860
00:44:42,790 --> 00:44:45,490
recommend the presentation visiting the

861
00:44:45,490 --> 00:44:48,580
beer del by John Calvin JC Campos Santa

862
00:44:48,580 --> 00:44:50,410
magic tree it has been presented that we

863
00:44:50,410 --> 00:44:53,020
can but it's going to be presented at

864
00:44:53,020 --> 00:44:58,450
but counts how this year okay what about

865
00:44:58,450 --> 00:45:01,180
the takeaways of beans ik so this is

866
00:45:01,180 --> 00:45:02,890
definitely the tip of what can be done

867
00:45:02,890 --> 00:45:05,710
we've been sick I've only shown what you

868
00:45:05,710 --> 00:45:07,210
can do with dynamic symbolic execution

869
00:45:07,210 --> 00:45:10,690
but bins like also allows to do abstract

870
00:45:10,690 --> 00:45:12,670
interpretation stimulations

871
00:45:12,670 --> 00:45:15,520
it has some optimization and many

872
00:45:15,520 --> 00:45:18,430
interesting things so more is it to come

873
00:45:18,430 --> 00:45:21,910
the platform is really young types of

874
00:45:21,910 --> 00:45:24,610
documentation stabilize the API is that

875
00:45:24,610 --> 00:45:28,660
it's coming but still we can download it

876
00:45:28,660 --> 00:45:31,090
try to experiment with it if you have

877
00:45:31,090 --> 00:45:32,710
any questions just ask

878
00:45:32,710 --> 00:45:37,630
we are available and the main takeaway

879
00:45:37,630 --> 00:45:40,870
of the torque is backward boundaries DSU

880
00:45:40,870 --> 00:45:45,250
scales well and we have managed to to

881
00:45:45,250 --> 00:45:47,860
show it on packers that are kind of huge

882
00:45:47,860 --> 00:45:52,900
in terms of execution trust length the

883
00:45:52,900 --> 00:45:55,480
backward bounded days are yelled really

884
00:45:55,480 --> 00:45:57,070
good results on this channel because we

885
00:45:57,070 --> 00:46:00,010
managed to to get rid of the obfuscation

886
00:46:00,010 --> 00:46:03,850
and we definitely think that combining

887
00:46:03,850 --> 00:46:09,010
dynamic static and symbolic analysis and

888
00:46:09,010 --> 00:46:11,500
approaches is definitely the way to go

889
00:46:11,500 --> 00:46:15,600
on obfuscated binaries in order to

890
00:46:15,600 --> 00:46:17,440
handle the different kind of

891
00:46:17,440 --> 00:46:19,120
sophistication we can meet to this

892
00:46:19,120 --> 00:46:22,840
program and that's all for me

893
00:46:22,840 --> 00:46:24,730
thank you if you have any questions are

894
00:46:24,730 --> 00:46:27,630
the happy to answer

895
00:47:16,760 --> 00:47:23,280
yeah we yeah um even though for instance

896
00:47:23,280 --> 00:47:25,349
on external even though sometimes they

897
00:47:25,349 --> 00:47:30,420
have some for dependency we managed to

898
00:47:30,420 --> 00:47:33,330
recover enough constraints on the input

899
00:47:33,330 --> 00:47:35,520
so that we can prove the opacity of the

900
00:47:35,520 --> 00:47:38,400
predicate so you don't need to backtrack

901
00:47:38,400 --> 00:47:42,240
all the dependency but by backtrack for

902
00:47:42,240 --> 00:47:43,890
the example of a predicate should

903
00:47:43,890 --> 00:47:45,869
backtrack enough to recover enough

904
00:47:45,869 --> 00:47:48,510
constraints on the variables you will be

905
00:47:48,510 --> 00:47:56,839
able to prove the infeasibility yeah

906
00:47:58,760 --> 00:48:02,250
yeah maybe basically for for your

907
00:48:02,250 --> 00:48:05,010
question tried multiple bound for this

908
00:48:05,010 --> 00:48:08,910
problem and found out that 16 to 20 was

909
00:48:08,910 --> 00:48:11,580
kind of great yeah it was the best and

910
00:48:11,580 --> 00:48:13,500
between for negative and false positive

911
00:48:13,500 --> 00:48:16,080
to because there are still some false

912
00:48:16,080 --> 00:48:18,859
positive or false negative

913
00:48:28,770 --> 00:48:33,990
okay depression was you know if we're

914
00:48:33,990 --> 00:48:37,690
the modelers in parallelization and the

915
00:48:37,690 --> 00:48:38,760
answer for that

916
00:48:38,760 --> 00:48:42,250
you should normally execute symbolically

917
00:48:42,250 --> 00:48:44,980
all the thread separately and yeah it's

918
00:48:44,980 --> 00:48:46,960
kind of difficult to model that the

919
00:48:46,960 --> 00:48:48,990
interactions in memory that can have

920
00:48:48,990 --> 00:48:52,210
yeah that's kind of complicated we

921
00:48:52,210 --> 00:48:55,440
basically don't do it for now

922
00:49:01,710 --> 00:49:02,890
okay

923
00:49:02,890 --> 00:49:26,860
so there is no questions yeah I'm not

924
00:49:26,860 --> 00:49:29,470
looked into the CD flattening discussion

925
00:49:29,470 --> 00:49:32,470
but yeah that would be a very great deal

926
00:49:32,470 --> 00:49:35,770
to try to find to write down them for

927
00:49:35,770 --> 00:49:38,680
the limit but I'm not really sure that

928
00:49:38,680 --> 00:49:41,380
if for the specific cases using it

929
00:49:41,380 --> 00:49:43,570
backward is really valuable

930
00:49:43,570 --> 00:50:03,040
I don't know how yeah sure yeah so

931
00:50:03,040 --> 00:50:05,110
that's why we still have some photos

932
00:50:05,110 --> 00:50:06,160
even false negatives

933
00:50:06,160 --> 00:50:08,050
sometimes just because we took the wrong

934
00:50:08,050 --> 00:50:12,520
branch we will falsely believe that it's

935
00:50:12,520 --> 00:50:14,950
a fact and a predicate while we could

936
00:50:14,950 --> 00:50:17,440
have come from somewhere else and then

937
00:50:17,440 --> 00:50:21,150
of Stetz replying your questions

938
00:50:25,530 --> 00:50:29,430
okay so thank you all

