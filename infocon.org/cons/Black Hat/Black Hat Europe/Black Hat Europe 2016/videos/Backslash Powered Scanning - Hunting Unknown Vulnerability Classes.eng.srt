1
00:00:00,030 --> 00:00:02,280
right welcome to backslash powered

2
00:00:02,280 --> 00:00:05,970
scaling imagine if you could conduct a

3
00:00:05,970 --> 00:00:09,360
pen test and only do the interesting

4
00:00:09,360 --> 00:00:12,179
bits if you could skip through the hours

5
00:00:12,179 --> 00:00:13,889
of repetitive fuzzing and trolling

6
00:00:13,889 --> 00:00:16,770
through meaningless results and jump

7
00:00:16,770 --> 00:00:19,770
straight to that one page that reacts in

8
00:00:19,770 --> 00:00:22,230
a mysterious way to your every input the

9
00:00:22,230 --> 00:00:23,850
page that turns out to be vulnerable to

10
00:00:23,850 --> 00:00:25,859
code injection in the language you've

11
00:00:25,859 --> 00:00:28,310
never heard of or sequel injection

12
00:00:28,310 --> 00:00:30,869
behind a heavyweight filter that almost

13
00:00:30,869 --> 00:00:32,340
stops you from cracking open the

14
00:00:32,340 --> 00:00:35,940
database the kind of page the no

15
00:00:35,940 --> 00:00:38,370
blackbox vulnerability scanner would

16
00:00:38,370 --> 00:00:41,610
ever find in this session I'll share

17
00:00:41,610 --> 00:00:43,050
with you the conception and development

18
00:00:43,050 --> 00:00:46,200
of an open-source scanner that can find

19
00:00:46,200 --> 00:00:50,879
research-grade vonner abilities this all

20
00:00:50,879 --> 00:00:54,090
got started around four years ago I just

21
00:00:54,090 --> 00:00:57,750
begun a pen test for we'll call market

22
00:00:57,750 --> 00:01:00,629
Iser and I had a little bit of a problem

23
00:01:00,629 --> 00:01:02,789
which was a market Iser hadn't got

24
00:01:02,789 --> 00:01:04,949
around to give me any login credentials

25
00:01:04,949 --> 00:01:09,119
and you know sometimes when you look at

26
00:01:09,119 --> 00:01:10,890
a website just through the design and

27
00:01:10,890 --> 00:01:12,540
the look of the site you could kind of

28
00:01:12,540 --> 00:01:15,030
feel the vulnerability screaming out at

29
00:01:15,030 --> 00:01:18,030
you from inside it that was happening

30
00:01:18,030 --> 00:01:19,200
with the site and it was really

31
00:01:19,200 --> 00:01:20,700
upsetting because I couldn't log in and

32
00:01:20,700 --> 00:01:24,030
get access to any of this attack surface

33
00:01:24,030 --> 00:01:28,610
I didn't even know a valid user name and

34
00:01:28,610 --> 00:01:30,840
eventually they did give me some login

35
00:01:30,840 --> 00:01:33,540
creds and I loved him found some sequel

36
00:01:33,540 --> 00:01:34,979
injection dumped out all the passwords

37
00:01:34,979 --> 00:01:37,470
which were naturally stored in plain

38
00:01:37,470 --> 00:01:40,229
text and I found that the password of

39
00:01:40,229 --> 00:01:42,840
the company's director was market either

40
00:01:42,840 --> 00:01:47,549
one so in effect his username was more

41
00:01:47,549 --> 00:01:52,110
secure than his password and I'm sure

42
00:01:52,110 --> 00:01:55,500
this situation of being locked out of an

43
00:01:55,500 --> 00:01:57,090
application when you know there's loads

44
00:01:57,090 --> 00:01:59,369
of juicy stuff inside the app and lots

45
00:01:59,369 --> 00:02:01,320
of weak passwords in between you and

46
00:02:01,320 --> 00:02:03,390
being inside the app is a familiar

47
00:02:03,390 --> 00:02:07,710
situation so after this I thought never

48
00:02:07,710 --> 00:02:11,550
again and I made a tool called let me in

49
00:02:11,550 --> 00:02:13,300
which will send a low

50
00:02:13,300 --> 00:02:15,640
of usernames a load of potential

51
00:02:15,640 --> 00:02:18,490
usernames which you feed it and it will

52
00:02:18,490 --> 00:02:21,880
analyze the responses and also use some

53
00:02:21,880 --> 00:02:23,860
statistical tests on the timing of the

54
00:02:23,860 --> 00:02:27,130
responses to try and identify any subtle

55
00:02:27,130 --> 00:02:30,580
clue as to which if any of the usernames

56
00:02:30,580 --> 00:02:34,630
are valid and this worked really well on

57
00:02:34,630 --> 00:02:37,660
about 30% of websites and failed

58
00:02:37,660 --> 00:02:40,990
probably on the other 70 and while

59
00:02:40,990 --> 00:02:43,450
trying to make it work on those 70 I

60
00:02:43,450 --> 00:02:46,060
realize this this technology could be

61
00:02:46,060 --> 00:02:49,060
used for something far cooler and that's

62
00:02:49,060 --> 00:02:52,050
what I'm here to share with you today

63
00:02:52,050 --> 00:02:55,120
first I'll talk about the three failures

64
00:02:55,120 --> 00:02:59,170
of scanners three huge blind spots but

65
00:02:59,170 --> 00:03:01,420
pretty much all wrong ability scanners

66
00:03:01,420 --> 00:03:03,100
have when it comes to finding

67
00:03:03,100 --> 00:03:05,370
server-side injection vulnerabilities

68
00:03:05,370 --> 00:03:07,680
vulnerabilities like sequel injection

69
00:03:07,680 --> 00:03:10,570
code injection OS command injection that

70
00:03:10,570 --> 00:03:13,960
kind of stuff and then I'll talk about

71
00:03:13,960 --> 00:03:17,230
two two novel approaches that we can

72
00:03:17,230 --> 00:03:19,300
take and that I've implemented that

73
00:03:19,300 --> 00:03:22,090
avoid these blind spots entirely I'll

74
00:03:22,090 --> 00:03:24,190
look at the results that I found when I

75
00:03:24,190 --> 00:03:26,560
ran these two scanners on a couple of

76
00:03:26,560 --> 00:03:29,800
thousand websites and I'll look at what

77
00:03:29,800 --> 00:03:32,650
else we can do with this tech then take

78
00:03:32,650 --> 00:03:36,940
five minutes of questions first off I

79
00:03:36,940 --> 00:03:39,459
should mention that I work at port

80
00:03:39,459 --> 00:03:41,110
swagger where we make a tool that you

81
00:03:41,110 --> 00:03:43,980
may have heard of called burp suite and

82
00:03:43,980 --> 00:03:46,500
the cool part of my role there is to

83
00:03:46,500 --> 00:03:50,650
design new scanner checks so although

84
00:03:50,650 --> 00:03:52,420
I'm about to spend the next few slides

85
00:03:52,420 --> 00:03:54,580
pretty much slagging off from ability

86
00:03:54,580 --> 00:03:56,730
scanners I'm doing it from a position of

87
00:03:56,730 --> 00:03:59,260
respect I think they're doing great work

88
00:03:59,260 --> 00:04:03,010
and but people just need to be honest

89
00:04:03,010 --> 00:04:04,870
about what the challenges and what the

90
00:04:04,870 --> 00:04:08,350
failings are I should also mention the

91
00:04:08,350 --> 00:04:11,980
last year I talked at blackhat USA about

92
00:04:11,980 --> 00:04:14,230
a new type of vulnerability called

93
00:04:14,230 --> 00:04:18,370
server site template injection and one

94
00:04:18,370 --> 00:04:20,738
of the core things that I'm going to

95
00:04:20,738 --> 00:04:23,650
show you today is that this new scanning

96
00:04:23,650 --> 00:04:25,690
technique could find vulnerabilities

97
00:04:25,690 --> 00:04:26,850
like

98
00:04:26,850 --> 00:04:29,520
a site template injection before they're

99
00:04:29,520 --> 00:04:32,100
publicly known about so it can find

100
00:04:32,100 --> 00:04:36,680
unknown types of injection vulnerability

101
00:04:37,160 --> 00:04:40,770
okay the first blind spot is that

102
00:04:40,770 --> 00:04:42,840
security through obscurity really works

103
00:04:42,840 --> 00:04:47,430
against scallops if you're using a

104
00:04:47,430 --> 00:04:49,590
modern scanner it almost certainly will

105
00:04:49,590 --> 00:04:51,360
detect some types of server-side

106
00:04:51,360 --> 00:04:54,360
templating injection but from this list

107
00:04:54,360 --> 00:04:57,450
of the most popular template engines how

108
00:04:57,450 --> 00:05:01,170
many do you think that it finds probably

109
00:05:01,170 --> 00:05:03,210
not all of them and that just the list

110
00:05:03,210 --> 00:05:04,950
of the most popular ones

111
00:05:04,950 --> 00:05:09,120
for example arts point recently got code

112
00:05:09,120 --> 00:05:12,990
execution on paypal using dust KS which

113
00:05:12,990 --> 00:05:15,390
is the server-side templating j'en not

114
00:05:15,390 --> 00:05:19,470
on that list and it's worse than that

115
00:05:19,470 --> 00:05:21,570
because two years ago of course most

116
00:05:21,570 --> 00:05:23,670
scanners detected server site template

117
00:05:23,670 --> 00:05:25,740
injection it's not the vulnerable

118
00:05:25,740 --> 00:05:28,860
systems weren't being scanned I know for

119
00:05:28,860 --> 00:05:31,800
a fact that they absolutely were because

120
00:05:31,800 --> 00:05:34,140
someone reported a false negative

121
00:05:34,140 --> 00:05:36,720
inverse XSS check and when I

122
00:05:36,720 --> 00:05:38,730
investigated myself to figure out what

123
00:05:38,730 --> 00:05:41,010
was going on I found the server was

124
00:05:41,010 --> 00:05:42,090
vulnerable to server-side templating

125
00:05:42,090 --> 00:05:47,160
Junction and okay you might say well it

126
00:05:47,160 --> 00:05:50,220
makes sense that if I'm using an obscure

127
00:05:50,220 --> 00:05:52,170
template engine something in the long

128
00:05:52,170 --> 00:05:54,780
tail then scanners will fail to find

129
00:05:54,780 --> 00:05:57,090
that vulnerability but it's actually

130
00:05:57,090 --> 00:06:00,690
worse than that because using an obscure

131
00:06:00,690 --> 00:06:03,140
piece of tech or some slightly unusual

132
00:06:03,140 --> 00:06:05,790
configuration can lead to completely

133
00:06:05,790 --> 00:06:07,910
unrelated vulnerabilities being missed

134
00:06:07,910 --> 00:06:12,330
for example many scanners finds local

135
00:06:12,330 --> 00:06:15,000
foil include vulnerabilities by using

136
00:06:15,000 --> 00:06:18,050
them to read the ATC password file and

137
00:06:18,050 --> 00:06:21,510
if you're using SC Linux and that may

138
00:06:21,510 --> 00:06:23,580
well block the application from having

139
00:06:23,580 --> 00:06:26,270
permission to read et Cie password file

140
00:06:26,270 --> 00:06:29,280
and then all these scanners will fail to

141
00:06:29,280 --> 00:06:33,979
find local file includes it's pretty bad

142
00:06:34,610 --> 00:06:38,310
so okay let's assume whether we're now

143
00:06:38,310 --> 00:06:40,740
scanning and applications that

144
00:06:40,740 --> 00:06:43,410
all that is vulnerable in a well-known

145
00:06:43,410 --> 00:06:45,660
language so this one's vulnerable to PHP

146
00:06:45,660 --> 00:06:50,910
code injection a client code line code

147
00:06:50,910 --> 00:06:52,560
injection so the way to detect this

148
00:06:52,560 --> 00:06:55,650
would be to send a sneak base payload

149
00:06:55,650 --> 00:06:57,690
like this and then time liver spots if

150
00:06:57,690 --> 00:06:59,520
application takes ten seconds to respond

151
00:06:59,520 --> 00:07:02,580
then it's probably vulnerable so far so

152
00:07:02,580 --> 00:07:06,509
good but what if parentheses are

153
00:07:06,509 --> 00:07:09,960
filtered out well as a human we can

154
00:07:09,960 --> 00:07:12,300
still adapt and exploit it but the

155
00:07:12,300 --> 00:07:13,740
scanner won't find this it'll just get a

156
00:07:13,740 --> 00:07:14,690
false negative

157
00:07:14,690 --> 00:07:17,909
similarly if there's a a a Web

158
00:07:17,909 --> 00:07:19,560
Application Firewall doing something

159
00:07:19,560 --> 00:07:22,560
like looking to the sleep keyword the

160
00:07:22,560 --> 00:07:24,240
scanner will fail to find it but we can

161
00:07:24,240 --> 00:07:27,930
probably adapt and bypass this and of

162
00:07:27,930 --> 00:07:29,370
course if double quotes are filtered

163
00:07:29,370 --> 00:07:32,580
once again the scanner may fail to find

164
00:07:32,580 --> 00:07:35,030
it it's not the scanners can't send

165
00:07:35,030 --> 00:07:37,740
can't send these three variants here

166
00:07:37,740 --> 00:07:40,349
it's that this is a tiny sample of the

167
00:07:40,349 --> 00:07:42,930
possible variations and filters for any

168
00:07:42,930 --> 00:07:46,169
given application might have of these

169
00:07:46,169 --> 00:07:49,860
three two are ones that I found found

170
00:07:49,860 --> 00:07:52,199
personally on ten tests and one is one

171
00:07:52,199 --> 00:07:56,669
that someone else by note that in fact

172
00:07:56,669 --> 00:08:00,780
the situation is so bad that if you put

173
00:08:00,780 --> 00:08:03,960
your if you put your sequel statement

174
00:08:03,960 --> 00:08:06,330
strings in double quotes harder than

175
00:08:06,330 --> 00:08:08,610
single quotes many scanners will just

176
00:08:08,610 --> 00:08:10,380
fail to find sequel injection on your

177
00:08:10,380 --> 00:08:13,319
application throughout but that could be

178
00:08:13,319 --> 00:08:19,110
useful in some cases okay so now assume

179
00:08:19,110 --> 00:08:20,849
okay we've got a known technology and

180
00:08:20,849 --> 00:08:23,520
we've got no filters or kind of weird

181
00:08:23,520 --> 00:08:24,800
variants whatsoever

182
00:08:24,800 --> 00:08:28,620
surely this can do this it simply needs

183
00:08:28,620 --> 00:08:31,520
to figure out where to put the payload

184
00:08:31,520 --> 00:08:34,979
this request is going to an endpoint on

185
00:08:34,979 --> 00:08:36,570
eBay that used to be vulnerable to

186
00:08:36,570 --> 00:08:39,419
remote code execution via PHP injection

187
00:08:39,419 --> 00:08:42,149
and the obvious place to put the payload

188
00:08:42,149 --> 00:08:44,910
is in the isn't the cube cube parameter

189
00:08:44,910 --> 00:08:46,890
which I've highlighted but that won't

190
00:08:46,890 --> 00:08:49,529
work and putting it in the cookie won't

191
00:08:49,529 --> 00:08:50,459
work either

192
00:08:50,459 --> 00:08:52,850
neither will putting it in the further

193
00:08:52,850 --> 00:08:54,930
or the user-agent

194
00:08:54,930 --> 00:08:57,569
or the path or even guessing some

195
00:08:57,569 --> 00:09:01,680
additional headers to put it in and by

196
00:09:01,680 --> 00:09:03,329
the time a scanner has reached this

197
00:09:03,329 --> 00:09:04,829
point and tried all of these locations

198
00:09:04,829 --> 00:09:06,959
that sent an awful lot of payloads as

199
00:09:06,959 --> 00:09:10,529
wasted a lot of time in order to exploit

200
00:09:10,529 --> 00:09:13,800
this application we need to specify an

201
00:09:13,800 --> 00:09:16,920
additional Q parameter so that we're

202
00:09:16,920 --> 00:09:21,120
passing in an array this was found by a

203
00:09:21,120 --> 00:09:23,040
manual tester because he noticed that

204
00:09:23,040 --> 00:09:26,220
the original Q parameter was behaving in

205
00:09:26,220 --> 00:09:28,529
a suspicious way he found that it was

206
00:09:28,529 --> 00:09:30,360
correcting his spelling when he

207
00:09:30,360 --> 00:09:32,129
misspelled things and also that it was

208
00:09:32,129 --> 00:09:35,250
thought filtering out certain keywords

209
00:09:35,250 --> 00:09:38,699
so he went okay that's a bit weird I'm

210
00:09:38,699 --> 00:09:40,709
going to I'm going to investigate

211
00:09:40,709 --> 00:09:43,050
further and and try some more extreme

212
00:09:43,050 --> 00:09:45,000
measures such as specifying an

213
00:09:45,000 --> 00:09:50,129
additional Q parameter so the million

214
00:09:50,129 --> 00:09:53,550
payload problem simply put is is that a

215
00:09:53,550 --> 00:09:55,620
scanner could identify all of those

216
00:09:55,620 --> 00:09:57,029
vulnerabilities if it's sent all of

217
00:09:57,029 --> 00:09:59,399
those payloads but to find every

218
00:09:59,399 --> 00:10:01,470
possible variant for every technology it

219
00:10:01,470 --> 00:10:03,930
will be sending a million probes per

220
00:10:03,930 --> 00:10:06,360
input and it would never finish scanning

221
00:10:06,360 --> 00:10:10,819
anything scanners can't do that so there

222
00:10:10,819 --> 00:10:13,860
they're reduced to sending best effort

223
00:10:13,860 --> 00:10:16,529
payloads that will find most variants of

224
00:10:16,529 --> 00:10:19,459
a vulnerability and most of the time

225
00:10:19,459 --> 00:10:23,009
that does the job but the remaining time

226
00:10:23,009 --> 00:10:25,559
it fails completely and that's what

227
00:10:25,559 --> 00:10:27,839
leads to people saying scanners are good

228
00:10:27,839 --> 00:10:32,730
for finding low-hanging fruit what we

229
00:10:32,730 --> 00:10:34,290
need is a scanner that finds high hang

230
00:10:34,290 --> 00:10:40,829
for it in order to what we need to do to

231
00:10:40,829 --> 00:10:43,620
achieve this is to make a scanner aren't

232
00:10:43,620 --> 00:10:46,470
harnesses that concept of intuition that

233
00:10:46,470 --> 00:10:49,559
that manual tester had so rather than

234
00:10:49,559 --> 00:10:51,689
sending a highly specific payload that

235
00:10:51,689 --> 00:10:54,360
says something like finally injection

236
00:10:54,360 --> 00:10:56,339
into a double quoted string being

237
00:10:56,339 --> 00:10:59,670
evaluated in PHP with no filters we're

238
00:10:59,670 --> 00:11:01,589
going to send a really generic payload

239
00:11:01,589 --> 00:11:04,319
that says finally something interesting

240
00:11:04,319 --> 00:11:07,319
and then if we if we do find something

241
00:11:07,319 --> 00:11:08,430
interesting we

242
00:11:08,430 --> 00:11:11,760
focus on that and investigate further we

243
00:11:11,760 --> 00:11:13,950
can implement this in a in a kind of

244
00:11:13,950 --> 00:11:16,860
cycle so to begin with we only need this

245
00:11:16,860 --> 00:11:19,890
most generic probe so we can send that

246
00:11:19,890 --> 00:11:22,790
to loads of servers and manually

247
00:11:22,790 --> 00:11:25,410
investigate the results and use that to

248
00:11:25,410 --> 00:11:27,240
work out what code we need to automate

249
00:11:27,240 --> 00:11:30,029
the next stage of this cycle to classify

250
00:11:30,029 --> 00:11:35,130
those those results so I'm going to

251
00:11:35,130 --> 00:11:37,529
start with a really specific payload and

252
00:11:37,529 --> 00:11:39,589
try to make it as generic as possible

253
00:11:39,589 --> 00:11:41,730
this payload here will find you

254
00:11:41,730 --> 00:11:44,010
server-side templating section into free

255
00:11:44,010 --> 00:11:48,600
market if we if we reduce it down to

256
00:11:48,600 --> 00:11:50,940
this then we'll find server site

257
00:11:50,940 --> 00:11:53,010
template injection in quite a few

258
00:11:53,010 --> 00:11:54,690
different template engines that all

259
00:11:54,690 --> 00:11:57,120
support the same interpolation syntax

260
00:11:57,120 --> 00:12:00,600
and if we reduce it further then we can

261
00:12:00,600 --> 00:12:03,300
find code injection in any language that

262
00:12:03,300 --> 00:12:06,870
supports hex escapes but we can still do

263
00:12:06,870 --> 00:12:09,570
better than that because some languages

264
00:12:09,570 --> 00:12:12,779
like noticeably most databases don't

265
00:12:12,779 --> 00:12:16,560
support hex escapes within strings so

266
00:12:16,560 --> 00:12:18,660
what we're going to do is send two

267
00:12:18,660 --> 00:12:22,320
backslashes to the application and if we

268
00:12:22,320 --> 00:12:25,110
see only one backslash come back to us

269
00:12:25,110 --> 00:12:27,720
that tells us that our input may be

270
00:12:27,720 --> 00:12:32,790
being evaluated server-side and pretty

271
00:12:32,790 --> 00:12:34,800
much every language out there supports

272
00:12:34,800 --> 00:12:40,470
backslashes having sent that payload we

273
00:12:40,470 --> 00:12:42,839
then need to gather further information

274
00:12:42,839 --> 00:12:44,520
to figure out okay what's actually

275
00:12:44,520 --> 00:12:47,279
happening here and I found that the most

276
00:12:47,279 --> 00:12:51,540
effective way to achieve that is to is

277
00:12:51,540 --> 00:12:53,490
to figure out what the baseline of that

278
00:12:53,490 --> 00:12:56,400
of the application is for like what the

279
00:12:56,400 --> 00:12:59,070
default behavior is by sending an

280
00:12:59,070 --> 00:13:03,750
invalid escape like slash Zed Zed we can

281
00:13:03,750 --> 00:13:05,820
then sure escaping loads of other

282
00:13:05,820 --> 00:13:10,980
characters and look out for anomalies so

283
00:13:10,980 --> 00:13:15,050
here we can see that if we if we escape

284
00:13:15,050 --> 00:13:18,870
the curly character then the backslash

285
00:13:18,870 --> 00:13:21,120
vanishes and that tells us that the

286
00:13:21,120 --> 00:13:22,630
curly has

287
00:13:22,630 --> 00:13:24,370
has a special significance to the

288
00:13:24,370 --> 00:13:27,160
application and it gives us a kind of

289
00:13:27,160 --> 00:13:32,290
clue as to what's going on and we can

290
00:13:32,290 --> 00:13:34,839
try this with all special characters and

291
00:13:34,839 --> 00:13:37,060
build and build a kind of fingerprint

292
00:13:37,060 --> 00:13:39,459
based on which special characters are

293
00:13:39,459 --> 00:13:43,110
actually significant to the application

294
00:13:43,110 --> 00:13:46,290
it's worth noting that this process is

295
00:13:46,290 --> 00:13:50,170
really efficient because for 99.9% of

296
00:13:50,170 --> 00:13:53,140
inputs we only need to send two

297
00:13:53,140 --> 00:13:55,360
backslashes and we'll get two

298
00:13:55,360 --> 00:13:56,860
backslashes back and we'll know that

299
00:13:56,860 --> 00:14:00,040
nothing interesting is Hamming here it's

300
00:14:00,040 --> 00:14:02,140
only for a tiny number of inputs where

301
00:14:02,140 --> 00:14:03,610
we have where we have to do this

302
00:14:03,610 --> 00:14:06,370
follow-up work just like how a manual

303
00:14:06,370 --> 00:14:11,200
test that works so the result is that at

304
00:14:11,200 --> 00:14:13,589
a glance we've got a reasonable idea as

305
00:14:13,589 --> 00:14:17,410
how interesting something is on the left

306
00:14:17,410 --> 00:14:20,290
here you can see loads of loads of

307
00:14:20,290 --> 00:14:22,990
transformations with which the scanner

308
00:14:22,990 --> 00:14:25,420
thinks are interesting and those are all

309
00:14:25,420 --> 00:14:27,370
those characters are all associated with

310
00:14:27,370 --> 00:14:30,310
markdown syntax because it is in fact

311
00:14:30,310 --> 00:14:31,990
vulnerable to server-side markdown

312
00:14:31,990 --> 00:14:35,170
injection on the right the only

313
00:14:35,170 --> 00:14:38,079
transformation is that slash zero gets

314
00:14:38,079 --> 00:14:42,070
converted into an old byte so what's

315
00:14:42,070 --> 00:14:44,290
probably happening here is that the

316
00:14:44,290 --> 00:14:47,110
server is calling PHP strip slashes

317
00:14:47,110 --> 00:14:51,910
function on the input and so in that's

318
00:14:51,910 --> 00:14:56,410
not a vulnerability by itself but at a

319
00:14:56,410 --> 00:14:59,860
glance we can tell that and I could make

320
00:14:59,860 --> 00:15:02,020
the scanner filter out those issues

321
00:15:02,020 --> 00:15:04,510
entirely but actually in some situations

322
00:15:04,510 --> 00:15:07,959
being able to inject byte when an input

323
00:15:07,959 --> 00:15:09,940
is halfway through being processed is

324
00:15:09,940 --> 00:15:13,959
really quite useful so what we've got

325
00:15:13,959 --> 00:15:16,209
here is an extremely efficient check

326
00:15:16,209 --> 00:15:18,420
that can identify a huge range of

327
00:15:18,420 --> 00:15:21,190
different issues and it doesn't really

328
00:15:21,190 --> 00:15:22,810
care much about things like filters

329
00:15:22,810 --> 00:15:24,370
because it's sending such simple

330
00:15:24,370 --> 00:15:28,420
payloads however there's a huge

331
00:15:28,420 --> 00:15:32,790
fundamental design flaw with this

332
00:15:33,440 --> 00:15:37,279
and that's but it relies on process

333
00:15:37,279 --> 00:15:41,569
input reflection so if I send two

334
00:15:41,569 --> 00:15:45,649
slashes and that lands in a an escaped

335
00:15:45,649 --> 00:15:48,379
sequels sequel statement it will be

336
00:15:48,379 --> 00:15:50,660
converted to one slash but I will never

337
00:15:50,660 --> 00:15:53,540
know that happened unless the server who

338
00:15:53,540 --> 00:15:56,779
reflects the sequel statement back to me

339
00:15:56,779 --> 00:16:00,920
after after evaluation so this can find

340
00:16:00,920 --> 00:16:02,660
really cool things but it will also get

341
00:16:02,660 --> 00:16:05,329
you tons and tons of false negatives you

342
00:16:05,329 --> 00:16:06,740
can't just run this technique on

343
00:16:06,740 --> 00:16:10,750
something and then be sure that it's X

344
00:16:10,750 --> 00:16:14,079
but that's okay because we can do better

345
00:16:14,079 --> 00:16:17,449
using the response analysis technology

346
00:16:17,449 --> 00:16:20,000
from let me in and carefully crafted

347
00:16:20,000 --> 00:16:23,649
pairs of payloads we can look at

348
00:16:23,649 --> 00:16:27,290
responses and identify tiny differences

349
00:16:27,290 --> 00:16:31,490
which indicate a suspicious behavior so

350
00:16:31,490 --> 00:16:34,519
to give a very simple example if we send

351
00:16:34,519 --> 00:16:36,560
a single quote and that and the

352
00:16:36,560 --> 00:16:39,139
applications with response changes and

353
00:16:39,139 --> 00:16:41,029
then we escape that quote and the

354
00:16:41,029 --> 00:16:43,069
applications responses the verts to what

355
00:16:43,069 --> 00:16:45,980
it originally was we can say okay

356
00:16:45,980 --> 00:16:47,540
there's probably something interesting

357
00:16:47,540 --> 00:16:52,269
here and follow-up in this context the

358
00:16:52,269 --> 00:16:57,259
base the base is the rich applications

359
00:16:57,259 --> 00:17:00,199
original response to us so the response

360
00:17:00,199 --> 00:17:02,240
before we did any tampering with the

361
00:17:02,240 --> 00:17:04,909
input and if we send a single quote and

362
00:17:04,909 --> 00:17:07,309
it matches the base then we know there's

363
00:17:07,309 --> 00:17:09,740
nothing interesting happening here if it

364
00:17:09,740 --> 00:17:12,199
doesn't match the base then we can

365
00:17:12,199 --> 00:17:16,939
follow up and if that revert to matching

366
00:17:16,939 --> 00:17:19,939
the base you can go okay that's

367
00:17:19,939 --> 00:17:21,709
interesting there's something worth

368
00:17:21,709 --> 00:17:24,020
investigating the application is

369
00:17:24,020 --> 00:17:26,359
probably putting our input in a single

370
00:17:26,359 --> 00:17:30,280
quoted string in some language or other

371
00:17:30,280 --> 00:17:33,200
using this technique using pairs of

372
00:17:33,200 --> 00:17:35,900
probes we can ask a series of questions

373
00:17:35,900 --> 00:17:40,280
of the application so we can start for

374
00:17:40,280 --> 00:17:42,230
efficiency sake with something really

375
00:17:42,230 --> 00:17:43,700
simple like saying does the application

376
00:17:43,700 --> 00:17:47,340
react to a general-purpose substring

377
00:17:47,340 --> 00:17:50,400
and if it does then we can go okay let's

378
00:17:50,400 --> 00:17:53,000
investigate further and try each

379
00:17:53,000 --> 00:17:55,460
individual part of that of that

380
00:17:55,460 --> 00:17:57,770
fostering to figure out which part

381
00:17:57,770 --> 00:18:02,130
caused the reaction so in this case the

382
00:18:02,130 --> 00:18:04,710
scanner found the double quote is what

383
00:18:04,710 --> 00:18:05,970
caused the difference in the

384
00:18:05,970 --> 00:18:09,270
applications response then we can try

385
00:18:09,270 --> 00:18:11,280
and work out whether we can concatenate

386
00:18:11,280 --> 00:18:15,150
strings and so we can try dot and pipe

387
00:18:15,150 --> 00:18:17,940
and plus and here we found that plus can

388
00:18:17,940 --> 00:18:21,240
be used for for concatenation and then

389
00:18:21,240 --> 00:18:24,510
we can K say okay can we inject a

390
00:18:24,510 --> 00:18:27,840
function call and here we we're using

391
00:18:27,840 --> 00:18:30,120
the ABS function which is a really

392
00:18:30,120 --> 00:18:32,490
generic function like it exists in

393
00:18:32,490 --> 00:18:34,860
pretty much every language out there so

394
00:18:34,860 --> 00:18:39,330
we we don't need to know what the what

395
00:18:39,330 --> 00:18:41,040
the language that's being you service ID

396
00:18:41,040 --> 00:18:44,610
is at this point and then finally having

397
00:18:44,610 --> 00:18:47,220
found that we can then say okay is this

398
00:18:47,220 --> 00:18:49,740
a language that I already know about so

399
00:18:49,740 --> 00:18:53,330
the scanner will then try a list of

400
00:18:53,330 --> 00:18:56,160
functions that that I know only work in

401
00:18:56,160 --> 00:18:58,260
one particular language and use that to

402
00:18:58,260 --> 00:19:01,470
work out exactly which language is if it

403
00:19:01,470 --> 00:19:05,700
can and that's that that's quite cool by

404
00:19:05,700 --> 00:19:08,430
self but it's finding code injection in

405
00:19:08,430 --> 00:19:10,890
a wide range of languages in a really

406
00:19:10,890 --> 00:19:15,360
efficient way but the best thing is that

407
00:19:15,360 --> 00:19:17,430
the scanner doesn't have to get all the

408
00:19:17,430 --> 00:19:19,770
way to the end of this process maybe

409
00:19:19,770 --> 00:19:22,350
this is code injection in an on loan in

410
00:19:22,350 --> 00:19:24,780
an unknown language that means the

411
00:19:24,780 --> 00:19:27,560
scanner will probably get this far and

412
00:19:27,560 --> 00:19:30,090
that's absolutely fine because the

413
00:19:30,090 --> 00:19:31,890
scanner will still report this and as a

414
00:19:31,890 --> 00:19:34,500
as a pen tester I can figure out what's

415
00:19:34,500 --> 00:19:36,720
going on with really quite easily

416
00:19:36,720 --> 00:19:39,890
maybe that application is sorting out

417
00:19:39,890 --> 00:19:42,300
parentheses well that's fine because the

418
00:19:42,300 --> 00:19:44,340
scanner will still get this far and tell

419
00:19:44,340 --> 00:19:46,710
me and as a pen tester I can figure out

420
00:19:46,710 --> 00:19:49,320
what's going on so what we have hot have

421
00:19:49,320 --> 00:19:51,450
here is something that can handle one

422
00:19:51,450 --> 00:19:53,730
lone languages it can handle filters and

423
00:19:53,730 --> 00:19:57,080
they can handle variants of issues

424
00:19:57,560 --> 00:19:58,800
that's

425
00:19:58,800 --> 00:20:01,500
a screenshot of the result that I just

426
00:20:01,500 --> 00:20:09,780
showed okay and this technique isn't

427
00:20:09,780 --> 00:20:12,510
just limited to finding string ejections

428
00:20:12,510 --> 00:20:14,760
you can also find injections in two

429
00:20:14,760 --> 00:20:16,620
numeric contexts you can find

430
00:20:16,620 --> 00:20:18,450
interpolation you can find injection

431
00:20:18,450 --> 00:20:21,780
into order by clauses you can find

432
00:20:21,780 --> 00:20:24,950
direct code injection by using inline

433
00:20:24,950 --> 00:20:27,900
comments so the payload on the left in

434
00:20:27,900 --> 00:20:29,850
the comment line is an invalid comment

435
00:20:29,850 --> 00:20:33,510
because it closes itself and you can

436
00:20:33,510 --> 00:20:35,820
even find function hijacking which is

437
00:20:35,820 --> 00:20:39,000
something you see in particularly in PHP

438
00:20:39,000 --> 00:20:44,460
from time to time at this point you're

439
00:20:44,460 --> 00:20:46,410
hopefully thinking that sounds pretty

440
00:20:46,410 --> 00:20:48,120
powerful and you might be wondering

441
00:20:48,120 --> 00:20:50,760
seeing how simple it is why I wasn't

442
00:20:50,760 --> 00:20:55,680
done ten years ago the answer is that

443
00:20:55,680 --> 00:20:57,690
I've completely skipped over the

444
00:20:57,690 --> 00:21:00,240
question of how you tell whether the

445
00:21:00,240 --> 00:21:02,610
responses from the application are

446
00:21:02,610 --> 00:21:06,330
actually significantly different because

447
00:21:06,330 --> 00:21:10,080
applications responses in real life

448
00:21:10,080 --> 00:21:12,570
outside of the lab environment are full

449
00:21:12,570 --> 00:21:15,450
of of dynamic content like time stamps

450
00:21:15,450 --> 00:21:17,550
and cash Buster's and just random stuff

451
00:21:17,550 --> 00:21:19,490
because why not

452
00:21:19,490 --> 00:21:23,670
the original intuition that I had when I

453
00:21:23,670 --> 00:21:26,670
tackle this that I used in let me in is

454
00:21:26,670 --> 00:21:30,450
that his applications responses are

455
00:21:30,450 --> 00:21:33,690
basically composed of static blocks with

456
00:21:33,690 --> 00:21:37,620
small dynamic areas so I used the

457
00:21:37,620 --> 00:21:41,220
longest common subsequence algorithm to

458
00:21:41,220 --> 00:21:43,350
find out where the static box were and

459
00:21:43,350 --> 00:21:46,730
then stitch together these static blocks

460
00:21:46,730 --> 00:21:49,200
using wild card to make a gigantic

461
00:21:49,200 --> 00:21:51,660
regular expression that will match the

462
00:21:51,660 --> 00:21:54,330
response from the application if it

463
00:21:54,330 --> 00:21:56,280
hadn't if it had an inconsequential

464
00:21:56,280 --> 00:21:58,410
change but if there was a significant

465
00:21:58,410 --> 00:22:02,430
change it shouldn't match it and this

466
00:22:02,430 --> 00:22:05,010
worked 100% of the time about 30% of the

467
00:22:05,010 --> 00:22:09,060
time and the rest of the time I planned

468
00:22:09,060 --> 00:22:11,650
into problems the most

469
00:22:11,650 --> 00:22:14,410
reoccurring problem were performance was

470
00:22:14,410 --> 00:22:17,350
performance issues so the longest common

471
00:22:17,350 --> 00:22:20,140
subsequence algorithm is Big O N squared

472
00:22:20,140 --> 00:22:22,930
which means as the applications response

473
00:22:22,930 --> 00:22:26,560
gets longer it takes a lot longer - Lee

474
00:22:26,560 --> 00:22:29,770
scan it and I also found that in some

475
00:22:29,770 --> 00:22:31,800
cases the regular expressions that this

476
00:22:31,800 --> 00:22:34,630
process generated was so complicated

477
00:22:34,630 --> 00:22:36,910
that they launched a regular expression

478
00:22:36,910 --> 00:22:38,830
denial of service attack on my own

479
00:22:38,830 --> 00:22:43,630
computer also some applications simply

480
00:22:43,630 --> 00:22:47,620
don't really play by this idea of static

481
00:22:47,620 --> 00:22:49,960
blocks with small dynamic sections they

482
00:22:49,960 --> 00:22:51,670
will just give you completely different

483
00:22:51,670 --> 00:22:54,310
responses sometimes because they feel

484
00:22:54,310 --> 00:22:57,130
like it and trying to make a regex that

485
00:22:57,130 --> 00:22:59,350
matches two completely different

486
00:22:59,350 --> 00:23:01,030
responses that both have dynamic

487
00:23:01,030 --> 00:23:04,050
sections is not much fun

488
00:23:04,050 --> 00:23:07,540
what's also not much fun is debugging a

489
00:23:07,540 --> 00:23:10,240
regex that's four thousand lines long to

490
00:23:10,240 --> 00:23:11,680
figure out why it doesn't match a

491
00:23:11,680 --> 00:23:14,890
particular response and some

492
00:23:14,890 --> 00:23:17,920
applications also shuffle shuffle the

493
00:23:17,920 --> 00:23:20,650
order of content within the response on

494
00:23:20,650 --> 00:23:22,750
every page on every page loads which

495
00:23:22,750 --> 00:23:25,920
this approach doesn't handle very well

496
00:23:25,920 --> 00:23:29,590
and finally even really basic things

497
00:23:29,590 --> 00:23:32,170
like time stamps can break this

498
00:23:32,170 --> 00:23:36,130
technique by definition certain

499
00:23:36,130 --> 00:23:38,260
characters within a time stamp change

500
00:23:38,260 --> 00:23:41,950
only every ten or say 60 seconds so it's

501
00:23:41,950 --> 00:23:43,720
very easy to think that your payload

502
00:23:43,720 --> 00:23:45,100
caused a major change in the

503
00:23:45,100 --> 00:23:47,170
applications response when it was

504
00:23:47,170 --> 00:23:48,820
actually just the time that your payload

505
00:23:48,820 --> 00:23:55,570
was set you might think that you can fix

506
00:23:55,570 --> 00:23:58,150
every one of these problems and continue

507
00:23:58,150 --> 00:24:01,420
using this a dis approach or something

508
00:24:01,420 --> 00:24:05,710
very similar to it and maybe you can but

509
00:24:05,710 --> 00:24:08,050
I used to think that and that's why this

510
00:24:08,050 --> 00:24:11,190
wasn't released three years ago

511
00:24:11,190 --> 00:24:15,850
fortunately there's a better way what we

512
00:24:15,850 --> 00:24:19,330
can do is work is work out certain

513
00:24:19,330 --> 00:24:22,300
attributes of the response that we can

514
00:24:22,300 --> 00:24:25,480
consistently calculate in an efficient

515
00:24:25,480 --> 00:24:29,020
and liable way and then simply take note

516
00:24:29,020 --> 00:24:32,260
of which attributes stay constant which

517
00:24:32,260 --> 00:24:34,510
ones don't change when you send the same

518
00:24:34,510 --> 00:24:39,880
payload a few times for example if the

519
00:24:39,880 --> 00:24:44,110
application gives you a a 200 ok every

520
00:24:44,110 --> 00:24:47,320
time you send a request to it until you

521
00:24:47,320 --> 00:24:48,910
send a CERN payload and then it gives

522
00:24:48,910 --> 00:24:50,860
you a 500 error you know there's

523
00:24:50,860 --> 00:24:52,630
something interesting happening there

524
00:24:52,630 --> 00:24:55,120
but we can go much more fine-grained

525
00:24:55,120 --> 00:24:59,710
than that we can even the work out the

526
00:24:59,710 --> 00:25:02,620
scanner has found a vulnerability some

527
00:25:02,620 --> 00:25:05,169
sequel injection in a real application

528
00:25:05,169 --> 00:25:07,630
where the only evidence that it found

529
00:25:07,630 --> 00:25:10,090
was that when you put a single quote in

530
00:25:10,090 --> 00:25:12,400
a single word vanished from the

531
00:25:12,400 --> 00:25:16,840
applications spots we've made an API for

532
00:25:16,840 --> 00:25:19,990
burp suite to do this work for you so

533
00:25:19,990 --> 00:25:23,350
you can simply feed this objects a list

534
00:25:23,350 --> 00:25:26,250
of responses from the application and

535
00:25:26,250 --> 00:25:29,530
then and then call a function which will

536
00:25:29,530 --> 00:25:32,140
tell you which attributes of this

537
00:25:32,140 --> 00:25:34,480
response haven't changed so basically

538
00:25:34,480 --> 00:25:38,590
which ones can be trusted what we're

539
00:25:38,590 --> 00:25:42,370
absolutely not trying to do here is

540
00:25:42,370 --> 00:25:44,919
predict what effect a specific payload

541
00:25:44,919 --> 00:25:48,970
will have on the application it this is

542
00:25:48,970 --> 00:25:52,740
simply saying what attributes of like

543
00:25:52,740 --> 00:25:56,559
this is simply saying how can i how can

544
00:25:56,559 --> 00:25:58,690
I recognize which parts of the response

545
00:25:58,690 --> 00:26:00,760
can be relied on and which parts just

546
00:26:00,760 --> 00:26:02,049
change randomly because they feel like

547
00:26:02,049 --> 00:26:08,140
it although the pro pairs that I've

548
00:26:08,140 --> 00:26:11,500
showed you might look quite simple the

549
00:26:11,500 --> 00:26:13,030
way they're chosen and the way that

550
00:26:13,030 --> 00:26:14,620
they're sent to the application is

551
00:26:14,620 --> 00:26:19,540
actually really really important so the

552
00:26:19,540 --> 00:26:22,020
most obvious problem is the applications

553
00:26:22,020 --> 00:26:25,000
responses contain random content and as

554
00:26:25,000 --> 00:26:26,919
I've mentioned we can deal with this by

555
00:26:26,919 --> 00:26:30,250
repeating Propst but if you simply

556
00:26:30,250 --> 00:26:33,669
alternate between your two points then

557
00:26:33,669 --> 00:26:35,830
you'll get completely destroyed by

558
00:26:35,830 --> 00:26:37,540
certain applications which alternate in

559
00:26:37,540 --> 00:26:39,430
the response they give you because you

560
00:26:39,430 --> 00:26:41,890
seeing that your probe is causing the

561
00:26:41,890 --> 00:26:43,900
response to change when it's actually

562
00:26:43,900 --> 00:26:45,520
the order that you're sending the

563
00:26:45,520 --> 00:26:49,660
opponent so in order to fix that you

564
00:26:49,660 --> 00:26:51,610
need to shuffle the order that you send

565
00:26:51,610 --> 00:26:54,970
suppose it don't just automate some

566
00:26:54,970 --> 00:26:57,570
particularly fiendish applications have

567
00:26:57,570 --> 00:27:01,720
deterministic random context so on the

568
00:27:01,720 --> 00:27:04,930
live site that I found used the content

569
00:27:04,930 --> 00:27:07,810
of the query string as a seed to a

570
00:27:07,810 --> 00:27:10,450
random number generator which are used

571
00:27:10,450 --> 00:27:13,060
to pick which testimonial it would show

572
00:27:13,060 --> 00:27:16,960
you so if you send a single quote over

573
00:27:16,960 --> 00:27:19,090
and over you'll get the same testimonial

574
00:27:19,090 --> 00:27:21,100
every time and as soon as you escape

575
00:27:21,100 --> 00:27:22,180
that quote you get a different

576
00:27:22,180 --> 00:27:23,830
testimonial you go yes this is

577
00:27:23,830 --> 00:27:25,060
vulnerable to sequel injection or

578
00:27:25,060 --> 00:27:27,130
something and it's actually not one ball

579
00:27:27,130 --> 00:27:33,250
to anything in order to fix a issue we

580
00:27:33,250 --> 00:27:35,620
need to take each item within the

581
00:27:35,620 --> 00:27:41,080
prepare and make cosmetic alterations to

582
00:27:41,080 --> 00:27:45,850
it so if we send 7 over 0 + 7 / 0 0 that

583
00:27:45,850 --> 00:27:48,340
should have the same effect on any

584
00:27:48,340 --> 00:27:51,190
vulnerable server but it will have a

585
00:27:51,190 --> 00:27:53,410
completely different effect when it's

586
00:27:53,410 --> 00:27:58,360
fed into a random number generator ok

587
00:27:58,360 --> 00:28:00,040
that's enough about how the scanner

588
00:28:00,040 --> 00:28:01,870
works in theory what we really want to

589
00:28:01,870 --> 00:28:04,690
hear is what happens when I run it on

590
00:28:04,690 --> 00:28:08,320
2,000 systems so first I ran it on some

591
00:28:08,320 --> 00:28:11,890
hand coded labs on some intentionally

592
00:28:11,890 --> 00:28:14,260
vulnerable applications and some old

593
00:28:14,260 --> 00:28:16,390
applications but I knew were vulnerable

594
00:28:16,390 --> 00:28:18,340
and I'm running on pen tests where it

595
00:28:18,340 --> 00:28:20,530
got some some quite cool results but I

596
00:28:20,530 --> 00:28:22,540
have a relatively limited supply of pen

597
00:28:22,540 --> 00:28:25,480
tests and I needed to run it on more

598
00:28:25,480 --> 00:28:28,780
sites so I thought ok I'm going to run

599
00:28:28,780 --> 00:28:31,960
this on every single site that has a bug

600
00:28:31,960 --> 00:28:33,820
bounty program that doesn't say that you

601
00:28:33,820 --> 00:28:37,360
can't scan them and this is great

602
00:28:37,360 --> 00:28:40,810
because I was able to find a couple of

603
00:28:40,810 --> 00:28:45,970
thousand such sites the only and it has

604
00:28:45,970 --> 00:28:47,050
a side benefit in that you might

605
00:28:47,050 --> 00:28:48,430
actually get paid

606
00:28:48,430 --> 00:28:51,420
the only catch

607
00:28:51,420 --> 00:28:54,060
is that the term black box doesn't

608
00:28:54,060 --> 00:28:56,670
really do this justice because if you're

609
00:28:56,670 --> 00:28:58,170
running your scanner on two thousand

610
00:28:58,170 --> 00:29:01,380
sites and looking into the and looking

611
00:29:01,380 --> 00:29:03,120
into the results you don't really have

612
00:29:03,120 --> 00:29:05,760
time to get familiar with any given site

613
00:29:05,760 --> 00:29:09,780
in any depth so you have no idea what

614
00:29:09,780 --> 00:29:11,790
technologies that this application is

615
00:29:11,790 --> 00:29:14,640
running on whether you're getting serve

616
00:29:14,640 --> 00:29:16,500
stuff from a server farm or an

617
00:29:16,500 --> 00:29:19,080
individual server or whether there's a

618
00:29:19,080 --> 00:29:21,120
web application firewall in the way just

619
00:29:21,120 --> 00:29:23,760
tampering with everything you do you

620
00:29:23,760 --> 00:29:25,380
have no idea so you're going into

621
00:29:25,380 --> 00:29:27,780
everything completely blind which is

622
00:29:27,780 --> 00:29:29,730
something to watch out for it and try

623
00:29:29,730 --> 00:29:33,770
and replicate this for reasons of

624
00:29:33,770 --> 00:29:36,900
politeness basically to avoid flooding

625
00:29:36,900 --> 00:29:38,520
these people from traffic and then

626
00:29:38,520 --> 00:29:40,260
making them say that please don't

627
00:29:40,260 --> 00:29:44,550
automatically scan us I needed to to

628
00:29:44,550 --> 00:29:46,830
throttle the scanner to send one request

629
00:29:46,830 --> 00:29:50,430
per three seconds per hostname so that

630
00:29:50,430 --> 00:29:53,250
book could send a thousand requests per

631
00:29:53,250 --> 00:29:55,770
second perhaps but each individual

632
00:29:55,770 --> 00:29:58,260
server would only get one request per

633
00:29:58,260 --> 00:30:02,190
three seconds so I've made and I've made

634
00:30:02,190 --> 00:30:04,380
an open-source extension called

635
00:30:04,380 --> 00:30:08,910
distribute damage which will do that but

636
00:30:08,910 --> 00:30:12,060
I the point of this of this extension

637
00:30:12,060 --> 00:30:16,020
was to be polite but what I notice is

638
00:30:16,020 --> 00:30:19,680
that if you use this we back fast

639
00:30:19,680 --> 00:30:21,270
powered scanner with no other scanner

640
00:30:21,270 --> 00:30:24,240
checks turned on then from the server's

641
00:30:24,240 --> 00:30:26,190
point of view you're sending a tiny

642
00:30:26,190 --> 00:30:27,870
number of quite innocuous looking

643
00:30:27,870 --> 00:30:32,160
payloads really slowly so if you're on a

644
00:30:32,160 --> 00:30:34,850
red team and you're trying to remain

645
00:30:34,850 --> 00:30:37,500
undetected this combo might come in

646
00:30:37,500 --> 00:30:42,600
quite useful okay now I'm going to look

647
00:30:42,600 --> 00:30:45,930
through some results that we got from

648
00:30:45,930 --> 00:30:49,200
the scanning it might help to think of

649
00:30:49,200 --> 00:30:51,330
this scanner I don't think of it as a

650
00:30:51,330 --> 00:30:53,670
scanner think of it as like a highly

651
00:30:53,670 --> 00:30:57,600
enthusiastic rookie security tester so

652
00:30:57,600 --> 00:31:00,620
if you give them a well known

653
00:31:00,620 --> 00:31:04,230
vulnerability with no filters then there

654
00:31:04,230 --> 00:31:04,890
will identify

655
00:31:04,890 --> 00:31:07,050
why exactly what's happening and I'll

656
00:31:07,050 --> 00:31:09,030
just tell you and that will be that so

657
00:31:09,030 --> 00:31:12,270
this is a real report from a live web

658
00:31:12,270 --> 00:31:17,370
site that was running WordPress and had

659
00:31:17,370 --> 00:31:21,439
a sequel injection in the user agent and

660
00:31:21,560 --> 00:31:25,080
I have a glance we can tell exactly

661
00:31:25,080 --> 00:31:29,640
what's going on right and that's cool

662
00:31:29,640 --> 00:31:32,370
it's called or we can format in a really

663
00:31:32,370 --> 00:31:35,070
efficient way because we're only sending

664
00:31:35,070 --> 00:31:38,550
like two requests to the vast majority

665
00:31:38,550 --> 00:31:41,100
of inputs that we've still found

666
00:31:41,100 --> 00:31:43,110
something that's quite specific by

667
00:31:43,110 --> 00:31:46,320
following up automatically but aside

668
00:31:46,320 --> 00:31:49,590
from that it's it's no better than any

669
00:31:49,590 --> 00:31:51,330
other scanner if you point your scanner

670
00:31:51,330 --> 00:31:54,060
at this input it will say like 300

671
00:31:54,060 --> 00:31:56,870
requests but it will find this relative

672
00:31:56,870 --> 00:32:00,900
the strength of this intone is that if

673
00:32:00,900 --> 00:32:02,870
if you point them as something trickier

674
00:32:02,870 --> 00:32:05,280
they will tell you I found something

675
00:32:05,280 --> 00:32:06,060
interesting

676
00:32:06,060 --> 00:32:10,110
can you help me out this was the first

677
00:32:10,110 --> 00:32:12,750
critical vulnerability that this kind of

678
00:32:12,750 --> 00:32:15,750
found would anyone like to take a guess

679
00:32:15,750 --> 00:32:22,860
as to what it is no okay this is PHP

680
00:32:22,860 --> 00:32:25,560
code injection and the application is

681
00:32:25,560 --> 00:32:29,370
filtering out prevents this its blind

682
00:32:29,370 --> 00:32:31,860
spot number two and because they're

683
00:32:31,860 --> 00:32:33,930
being filtered out the scanner wasn't

684
00:32:33,930 --> 00:32:37,650
able to inject any function calls but it

685
00:32:37,650 --> 00:32:40,140
pointed this out to me and within it

686
00:32:40,140 --> 00:32:42,450
about half an hour I'd figured out what

687
00:32:42,450 --> 00:32:44,340
was happening I had a show on the box so

688
00:32:44,340 --> 00:32:49,050
that was nice I think that and this was

689
00:32:49,050 --> 00:32:51,090
on a site that had been heavily tested

690
00:32:51,090 --> 00:32:54,870
by manual testers but I think that they

691
00:32:54,870 --> 00:32:57,870
missed this issue is that this input was

692
00:32:57,870 --> 00:33:01,170
in the past and a test that probably

693
00:33:01,170 --> 00:33:04,410
wouldn't think probably wouldn't expect

694
00:33:04,410 --> 00:33:07,710
an application to be calling eval on the

695
00:33:07,710 --> 00:33:09,360
part right it's a little bit of a weird

696
00:33:09,360 --> 00:33:10,980
thing it's the sort of thing that you

697
00:33:10,980 --> 00:33:12,840
expect something from an Internet of

698
00:33:12,840 --> 00:33:14,850
Things device farther than a household

699
00:33:14,850 --> 00:33:17,480
name website

700
00:33:18,110 --> 00:33:22,020
the scanner found a lot of regex

701
00:33:22,020 --> 00:33:24,180
injection so it's worth being able to

702
00:33:24,180 --> 00:33:26,490
recognize us sometimes it's really

703
00:33:26,490 --> 00:33:29,750
obvious you get a helpful error message

704
00:33:29,750 --> 00:33:35,550
most of the time you can recognize it

705
00:33:35,550 --> 00:33:37,340
because the application identifies

706
00:33:37,340 --> 00:33:39,690
because the scanner identifies how it

707
00:33:39,690 --> 00:33:42,570
handles back references if you send a

708
00:33:42,570 --> 00:33:46,290
string with slashes Eoin and your hand

709
00:33:46,290 --> 00:33:48,900
in the response it's been expanded to

710
00:33:48,900 --> 00:33:51,030
something you can be reasonably sure

711
00:33:51,030 --> 00:33:52,860
that that's vulnerable to regex

712
00:33:52,860 --> 00:33:58,160
injection the the pro pear scanner will

713
00:33:58,160 --> 00:34:01,380
we will normally classify this as

714
00:34:01,380 --> 00:34:04,380
backslash because it identifies there

715
00:34:04,380 --> 00:34:06,660
aren't any strings that you can break

716
00:34:06,660 --> 00:34:09,270
out of but if you put a training

717
00:34:09,270 --> 00:34:13,650
backslash that escapes something by the

718
00:34:13,650 --> 00:34:16,920
end of the regex which causes a syntax

719
00:34:16,920 --> 00:34:19,320
error and then if you escape that then

720
00:34:19,320 --> 00:34:23,660
it stops causing such things axilla and

721
00:34:24,440 --> 00:34:27,300
most of the time the regex injection

722
00:34:27,300 --> 00:34:32,940
isn't very interesting the best that it

723
00:34:32,940 --> 00:34:35,900
can be used for is a regular expression

724
00:34:35,900 --> 00:34:39,780
denial of service attack but

725
00:34:39,780 --> 00:34:41,400
occasionally it's more interesting than

726
00:34:41,400 --> 00:34:44,480
that as we'll see in a little bit

727
00:34:44,480 --> 00:34:47,340
sometimes the scanner will find false

728
00:34:47,340 --> 00:34:49,500
positives so here it's trying to find

729
00:34:49,500 --> 00:34:52,860
function injection by sending the name

730
00:34:52,860 --> 00:34:55,409
of a real function and the name of them

731
00:34:55,409 --> 00:34:58,590
of a made-up function and what it's

732
00:34:58,590 --> 00:35:01,470
doing is searching the Google code

733
00:35:01,470 --> 00:35:05,220
codebase so of course real functions are

734
00:35:05,220 --> 00:35:06,690
going to be found in large numbers and

735
00:35:06,690 --> 00:35:08,640
invalid functions are not going to be

736
00:35:08,640 --> 00:35:10,680
found so it thinks this is vulnerable to

737
00:35:10,680 --> 00:35:14,540
function to function hijacking however

738
00:35:14,540 --> 00:35:19,890
we can fix this with a tiny tweak all we

739
00:35:19,890 --> 00:35:22,800
need to all we need to do to prevent

740
00:35:22,800 --> 00:35:26,550
this from ever happening again is to

741
00:35:26,550 --> 00:35:29,070
send the name of a valid function that

742
00:35:29,070 --> 00:35:31,160
will give an ever

743
00:35:31,160 --> 00:35:32,420
when it's called with arbitrary

744
00:35:32,420 --> 00:35:34,069
arguments which is what happens in

745
00:35:34,069 --> 00:35:37,430
function hijacking so by simply sending

746
00:35:37,430 --> 00:35:40,460
malloc we'll get an error back if the

747
00:35:40,460 --> 00:35:43,069
application is vulnerable to function

748
00:35:43,069 --> 00:35:45,019
hijacking but if we're searching a code

749
00:35:45,019 --> 00:35:46,579
base will probably get lots of hits from

750
00:35:46,579 --> 00:35:49,430
malloc and we won't can we won't

751
00:35:49,430 --> 00:35:51,769
erroneously conclude that it's

752
00:35:51,769 --> 00:35:53,769
vulnerable

753
00:35:53,769 --> 00:35:56,890
other times the scanner will find

754
00:35:56,890 --> 00:35:58,490
intelligence things that aren't

755
00:35:58,490 --> 00:36:00,950
vulnerabilities but are really quite

756
00:36:00,950 --> 00:36:05,450
useful to note so here by injecting a

757
00:36:05,450 --> 00:36:07,940
valid inline comment and an invalid

758
00:36:07,940 --> 00:36:10,640
inline comment the scanner thought that

759
00:36:10,640 --> 00:36:14,390
it found maybe some code injection and I

760
00:36:14,390 --> 00:36:16,039
investigated and the normal code

761
00:36:16,039 --> 00:36:18,380
injection false positives follow-ups

762
00:36:18,380 --> 00:36:21,440
didn't get me anywhere and then I

763
00:36:21,440 --> 00:36:23,240
noticed that the application responded

764
00:36:23,240 --> 00:36:26,059
to a valid HTML comment the same way as

765
00:36:26,059 --> 00:36:32,269
a valid inline comment okay that's quite

766
00:36:32,269 --> 00:36:35,599
weird maybe this is vulnerable to some

767
00:36:35,599 --> 00:36:37,609
kind of server-side template injection

768
00:36:37,609 --> 00:36:39,440
because I've seen the sort of behavior

769
00:36:39,440 --> 00:36:43,490
with server-side templating gesture and

770
00:36:43,490 --> 00:36:47,180
then Gareth Hayes noticed it responds to

771
00:36:47,180 --> 00:36:49,549
an input with a valid HTML tag in a

772
00:36:49,549 --> 00:36:51,970
different way to one with a invalid tag

773
00:36:51,970 --> 00:36:55,009
which makes it pretty obvious what's

774
00:36:55,009 --> 00:36:56,809
actually happening here which is that

775
00:36:56,809 --> 00:36:58,579
there's a Web Application Firewall and

776
00:36:58,579 --> 00:37:01,490
it's rewriting requests to remove

777
00:37:01,490 --> 00:37:06,190
comments and to remove valid HTML tags

778
00:37:06,190 --> 00:37:10,039
so it's not a vulnerability but it is

779
00:37:10,039 --> 00:37:12,980
potentially quite useful to know because

780
00:37:12,980 --> 00:37:15,799
we know for example that normal scanning

781
00:37:15,799 --> 00:37:17,599
on that application probably won't find

782
00:37:17,599 --> 00:37:20,299
anything and we can also use the request

783
00:37:20,299 --> 00:37:23,420
rewriting to the bypass web browsers

784
00:37:23,420 --> 00:37:25,670
cross-site scripting filters which might

785
00:37:25,670 --> 00:37:27,130
come in handy

786
00:37:27,130 --> 00:37:32,960
so rather than changing a back slash

787
00:37:32,960 --> 00:37:35,480
powered scanner to filter these out what

788
00:37:35,480 --> 00:37:37,430
I've made it what you can make it do is

789
00:37:37,430 --> 00:37:41,089
add a follow-up payload that will

790
00:37:41,089 --> 00:37:43,970
basically recognize and classify this so

791
00:37:43,970 --> 00:37:44,960
if it finds

792
00:37:44,960 --> 00:37:47,660
something where a valid inline comment

793
00:37:47,660 --> 00:37:50,990
works then it will try a HTML comment

794
00:37:50,990 --> 00:37:52,700
and then and then it can say this is

795
00:37:52,700 --> 00:37:55,700
probably a Web Application Firewall do

796
00:37:55,700 --> 00:38:00,470
what you will without information a lot

797
00:38:00,470 --> 00:38:04,369
of the time the scanner will find issues

798
00:38:04,369 --> 00:38:05,660
that will drive you insane

799
00:38:05,660 --> 00:38:07,700
this is a problem with the scanner that

800
00:38:07,700 --> 00:38:09,770
finds research-grade vulnerabilities

801
00:38:09,770 --> 00:38:11,089
research-grade

802
00:38:11,089 --> 00:38:13,310
doesn't mean it's easy to figure out

803
00:38:13,310 --> 00:38:17,359
what's going on or to exploit it so here

804
00:38:17,359 --> 00:38:19,630
it found some really shady behavior and

805
00:38:19,630 --> 00:38:23,810
after maybe half a day of magic manually

806
00:38:23,810 --> 00:38:26,420
investigating is one input all I found

807
00:38:26,420 --> 00:38:29,960
was that if I unicode escaped an input I

808
00:38:29,960 --> 00:38:31,940
got the same result as if I didn't

809
00:38:31,940 --> 00:38:36,560
unicode escaped that input great if I

810
00:38:36,560 --> 00:38:38,089
had to take a wild guess I would say

811
00:38:38,089 --> 00:38:40,460
that that was injection into Apache Solr

812
00:38:40,460 --> 00:38:44,510
JSON API but I have no idea really and

813
00:38:44,510 --> 00:38:48,730
that will happen quite often and

814
00:38:48,730 --> 00:38:51,980
sometimes sometimes the scanner will

815
00:38:51,980 --> 00:38:55,280
really take you for a write so this is a

816
00:38:55,280 --> 00:38:57,770
site of Tesla's that used to be within

817
00:38:57,770 --> 00:38:59,480
the scope of their bug bounty program

818
00:38:59,480 --> 00:39:08,119
and what the scanner found I'm not going

819
00:39:08,119 --> 00:39:09,710
to demonstrate scanning it because it is

820
00:39:09,710 --> 00:39:14,869
out of scope now but so you can see here

821
00:39:14,869 --> 00:39:16,460
we've got something that says document

822
00:39:16,460 --> 00:39:20,150
ID equals seven one five two I want to

823
00:39:20,150 --> 00:39:27,020
and we've got other oh thanks for coming

824
00:39:27,020 --> 00:39:29,320
out

825
00:39:33,850 --> 00:39:36,310
okie-doke so we've got small enough or

826
00:39:36,310 --> 00:39:39,010
something that says document ID equals

827
00:39:39,010 --> 00:39:41,920
75 1 2 let me just show you that's all

828
00:39:41,920 --> 00:39:46,030
the actual webpage looks like and if we

829
00:39:46,030 --> 00:39:50,410
do divide by 0 here then the response

830
00:39:50,410 --> 00:39:52,540
then we get a 500 internal server right

831
00:39:52,540 --> 00:39:58,960
and if I do divided by 1 then we get a

832
00:39:58,960 --> 00:40:01,510
200 ok so it looks like they might be

833
00:40:01,510 --> 00:40:05,170
calling eval on this simple but the

834
00:40:05,170 --> 00:40:07,900
obvious follow ups don't work like if we

835
00:40:07,900 --> 00:40:11,410
do what / 1 / what / 1 - 1

836
00:40:11,410 --> 00:40:14,320
it still works which we would expect to

837
00:40:14,320 --> 00:40:17,080
fail right rather because 1 minus 1 is 0

838
00:40:17,080 --> 00:40:18,700
it should be divided by 0 but it's not

839
00:40:18,700 --> 00:40:19,260
working

840
00:40:19,260 --> 00:40:22,600
that's quite wet and I also found if I

841
00:40:22,600 --> 00:40:26,110
do minus 0 we get a syntax error and if

842
00:40:26,110 --> 00:40:30,730
I do minus 1 then it works pretty

843
00:40:30,730 --> 00:40:34,870
strange and then I found if I do minus

844
00:40:34,870 --> 00:40:42,820
12 then it works and if I do - 13 and I

845
00:40:42,820 --> 00:40:46,750
again ever can anyone tell me what's

846
00:40:46,750 --> 00:40:49,740
happening here you lead it another clue

847
00:40:49,740 --> 00:40:52,780
okay yes exactly

848
00:40:52,780 --> 00:40:55,450
so let me just show you that show you

849
00:40:55,450 --> 00:40:57,790
that for the rest of you let me change

850
00:40:57,790 --> 00:41:03,510
this to / 12 and then / 31 right and

851
00:41:03,510 --> 00:41:08,410
then / 32 it's pausing this input as a

852
00:41:08,410 --> 00:41:10,690
date there's nothing evaluation going on

853
00:41:10,690 --> 00:41:12,940
whatsoever and you probably just waited

854
00:41:12,940 --> 00:41:16,740
two days on that oh well

855
00:41:18,880 --> 00:41:22,360
what here is a version of PHP myadmin

856
00:41:22,360 --> 00:41:27,430
which is missing lady one patch and it's

857
00:41:27,430 --> 00:41:32,100
running on a version of PHP that's

858
00:41:32,100 --> 00:41:38,140
slightly out of date and here you can as

859
00:41:38,140 --> 00:41:41,110
a human just just by looking at this we

860
00:41:41,110 --> 00:41:44,320
can tell that it's vulnerable to regex

861
00:41:44,320 --> 00:41:46,840
injection and

862
00:41:46,840 --> 00:41:50,810
if I scan this then you'll see the

863
00:41:50,810 --> 00:41:53,180
scanner will say that this is vulnerable

864
00:41:53,180 --> 00:41:57,650
to regex injection so it will notice

865
00:41:57,650 --> 00:42:00,680
that this slash and zero gets converted

866
00:42:00,680 --> 00:42:03,830
into the string cake which is a pretty

867
00:42:03,830 --> 00:42:12,680
good sign of vertex injection so PHP has

868
00:42:12,680 --> 00:42:16,820
this fantastic feature where I can

869
00:42:16,820 --> 00:42:23,210
specify this /e flag and how this works

870
00:42:23,210 --> 00:42:27,440
it's quite quite unreliable and that

871
00:42:27,440 --> 00:42:30,170
means that whatever I type in the row

872
00:42:30,170 --> 00:42:33,980
space hood box will be evaluated so

873
00:42:33,980 --> 00:42:36,350
there we've got vegek injection and we

874
00:42:36,350 --> 00:42:38,869
pretty easily turned it into something

875
00:42:38,869 --> 00:42:40,280
well we can execute arbitrary shell

876
00:42:40,280 --> 00:42:43,460
commands so regex injection sometimes

877
00:42:43,460 --> 00:42:48,160
it's rubbish other times it's quite good

878
00:42:58,570 --> 00:43:01,570
okay what else can we do

879
00:43:01,570 --> 00:43:04,060
we can identify when inputs can be

880
00:43:04,060 --> 00:43:06,820
enumerated so this is something that I

881
00:43:06,820 --> 00:43:08,700
haven't implemented in this version of

882
00:43:08,700 --> 00:43:11,320
the scanner but I verified that it can

883
00:43:11,320 --> 00:43:14,400
be done and it should be coming soon so

884
00:43:14,400 --> 00:43:18,340
if we find that as a scanner that if we

885
00:43:18,340 --> 00:43:21,750
increment this ID number we get unique

886
00:43:21,750 --> 00:43:24,160
the sponsors every time that we

887
00:43:24,160 --> 00:43:26,980
increment it then that tells us okay

888
00:43:26,980 --> 00:43:28,810
we've got some way of getting some kind

889
00:43:28,810 --> 00:43:31,360
of unique data but it might be something

890
00:43:31,360 --> 00:43:34,030
really boring like a calendar that's all

891
00:43:34,030 --> 00:43:36,280
and we're incrementing the date by

892
00:43:36,280 --> 00:43:39,010
adding a large number to these inputs

893
00:43:39,010 --> 00:43:41,770
and verifying that that they were

894
00:43:41,770 --> 00:43:45,060
responsibly get match we can filter out

895
00:43:45,060 --> 00:43:47,530
infinite series like dates and

896
00:43:47,530 --> 00:43:51,400
timestamps and we can use this to find

897
00:43:51,400 --> 00:43:54,660
anything that can be enumerated really

898
00:43:54,660 --> 00:44:01,000
which can be quite handy we can also use

899
00:44:01,000 --> 00:44:03,430
the scanner use this response to

900
00:44:03,430 --> 00:44:06,250
different technology for cold start

901
00:44:06,250 --> 00:44:10,440
brute-force attacks like what let me in

902
00:44:10,440 --> 00:44:14,440
was doing so getting user names when you

903
00:44:14,440 --> 00:44:16,450
don't know a single valid user name so

904
00:44:16,450 --> 00:44:18,880
you can't simply fingerprint the

905
00:44:18,880 --> 00:44:21,580
response of the application to a valid

906
00:44:21,580 --> 00:44:24,430
user name before you start and similarly

907
00:44:24,430 --> 00:44:26,580
you can get files and folder names and

908
00:44:26,580 --> 00:44:29,230
parameter names are better than current

909
00:44:29,230 --> 00:44:33,190
techcamp and you can potentially use

910
00:44:33,190 --> 00:44:36,400
this to fish for gadgets when you've got

911
00:44:36,400 --> 00:44:38,760
an object deserialization

912
00:44:38,760 --> 00:44:42,370
vulnerability I haven't tried this out

913
00:44:42,370 --> 00:44:46,000
yet but I think in theory you could use

914
00:44:46,000 --> 00:44:48,160
this to build an exploit to get your

915
00:44:48,160 --> 00:44:50,740
code execution it's an arbitrary object

916
00:44:50,740 --> 00:44:53,560
of civilization from a purely blackbox

917
00:44:53,560 --> 00:44:55,740
point of view with no source code access

918
00:44:55,740 --> 00:45:00,040
I'm not 100% sure if this will work but

919
00:45:00,040 --> 00:45:01,480
it would be really cool if it does so I

920
00:45:01,480 --> 00:45:05,800
am planning on trying it out okay you

921
00:45:05,800 --> 00:45:08,080
can grab the source codes online I've

922
00:45:08,080 --> 00:45:10,510
also just released a white paper which

923
00:45:10,510 --> 00:45:12,210
has

924
00:45:12,210 --> 00:45:14,820
it's getting more examples in it so that

925
00:45:14,820 --> 00:45:16,500
might be helpful with processing these

926
00:45:16,500 --> 00:45:20,130
scanners results if you just want to

927
00:45:20,130 --> 00:45:22,859
install this tool then it's in the burp

928
00:45:22,859 --> 00:45:25,320
app store and if you don't have that as

929
00:45:25,320 --> 00:45:27,750
I mentioned it is open source so you can

930
00:45:27,750 --> 00:45:29,670
port it to work on that if you feel like

931
00:45:29,670 --> 00:45:33,300
it let me just say this is not one of

932
00:45:33,300 --> 00:45:35,700
those security tools but gets released

933
00:45:35,700 --> 00:45:37,650
in a presentation at a conference and

934
00:45:37,650 --> 00:45:40,950
then never update it it has a huge

935
00:45:40,950 --> 00:45:43,290
potential and I'm planning on making

936
00:45:43,290 --> 00:45:45,780
plenty of improvements to it over the

937
00:45:45,780 --> 00:45:48,180
next few months and potentially the next

938
00:45:48,180 --> 00:45:52,680
few years the three key things to

939
00:45:52,680 --> 00:45:54,960
remember that scanners can find

940
00:45:54,960 --> 00:45:57,260
research-grade vulnerabilities

941
00:45:57,260 --> 00:45:59,250
particularly if they focus on enhancing

942
00:45:59,250 --> 00:46:03,089
rather than replacing the pen tester and

943
00:46:03,089 --> 00:46:06,300
this is just the beginning I'm going to

944
00:46:06,300 --> 00:46:09,780
take five minutes of questions now if

945
00:46:09,780 --> 00:46:12,420
you've got it any more after that you

946
00:46:12,420 --> 00:46:14,520
can speak to me out the back or send me

947
00:46:14,520 --> 00:46:16,680
an email don't forget to follow me on

948
00:46:16,680 --> 00:46:19,440
Twitter thank you for listening

949
00:46:19,440 --> 00:46:26,099
[Applause]

