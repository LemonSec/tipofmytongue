1
00:00:00,030 --> 00:00:02,879
hello blackhat we are very happy to be

2
00:00:02,879 --> 00:00:06,029
here and showed you your late latest

3
00:00:06,029 --> 00:00:08,280
research regarding compression side

4
00:00:08,280 --> 00:00:09,440
tunnel tags

5
00:00:09,440 --> 00:00:13,469
let us first introduce ourselves I'm

6
00:00:13,469 --> 00:00:17,640
ever here is Genesis and Dimitri's where

7
00:00:17,640 --> 00:00:19,260
researchers at the University of Athens

8
00:00:19,260 --> 00:00:22,020
in Greece and this is a collaborative

9
00:00:22,020 --> 00:00:25,500
work with professor Angela chaos with

10
00:00:25,500 --> 00:00:28,980
share in cyber security and privacy at

11
00:00:28,980 --> 00:00:33,059
the University of Edinburgh as we assume

12
00:00:33,059 --> 00:00:34,710
that most of you already know that a

13
00:00:34,710 --> 00:00:40,250
bridge broke HTTP and 34:8 back in 2033

14
00:00:40,250 --> 00:00:44,670
13 people who break upgraded from stream

15
00:00:44,670 --> 00:00:47,969
ciphers to block ciphers to the ES and

16
00:00:47,969 --> 00:00:52,770
so they were safe but rupture in 2016

17
00:00:52,770 --> 00:00:56,670
attacked HTTPS with block ciphers what

18
00:00:56,670 --> 00:00:58,469
we're going to show today is a generic

19
00:00:58,469 --> 00:01:00,840
defense for a compressor side-channel

20
00:01:00,840 --> 00:01:05,459
attacks we propose it it's the best

21
00:01:05,459 --> 00:01:07,860
balance between compression and security

22
00:01:07,860 --> 00:01:10,920
regarding the other proposal and we will

23
00:01:10,920 --> 00:01:13,740
launch today a number source

24
00:01:13,740 --> 00:01:15,960
implementation of our defense in many

25
00:01:15,960 --> 00:01:20,790
popular web frameworks so we will talk

26
00:01:20,790 --> 00:01:24,420
about the next one our is the history of

27
00:01:24,420 --> 00:01:27,060
compression side channel attacks and the

28
00:01:27,060 --> 00:01:29,460
attack vector and then we will move to

29
00:01:29,460 --> 00:01:33,090
the city XD sense we will define the

30
00:01:33,090 --> 00:01:34,619
origin the secret and the cross

31
00:01:34,619 --> 00:01:38,400
compression of the city XD sense the

32
00:01:38,400 --> 00:01:40,770
permutation we will discuss the CTX

33
00:01:40,770 --> 00:01:42,869
architecture and then we will release

34
00:01:42,869 --> 00:01:46,619
our our new tool and to we'll talk about

35
00:01:46,619 --> 00:01:51,630
future work so in 2012 crime was the

36
00:01:51,630 --> 00:01:57,750
first attack to successful a attacks egg

37
00:01:57,750 --> 00:02:02,969
it by in side channel compression it

38
00:02:02,969 --> 00:02:06,750
targeted HTTP requests mostly headers to

39
00:02:06,750 --> 00:02:09,949
hijack sessions and steal cookies and

40
00:02:09,949 --> 00:02:12,569
took advantages of the characteristics

41
00:02:12,569 --> 00:02:13,900
of the deflate algorithm

42
00:02:13,900 --> 00:02:16,440
which is the the most popular

43
00:02:16,440 --> 00:02:20,440
compression algorithm of today it hinted

44
00:02:20,440 --> 00:02:23,080
at attacking responses although it

45
00:02:23,080 --> 00:02:27,159
didn't implement it and after that crime

46
00:02:27,159 --> 00:02:28,690
was mitigated by disabling the

47
00:02:28,690 --> 00:02:32,459
compression at the TLS level so no no

48
00:02:32,459 --> 00:02:34,920
side channel compression attacks for

49
00:02:34,920 --> 00:02:40,799
HTTP requests were possible time 2013

50
00:02:40,799 --> 00:02:43,810
exploited compression on HTTP requests

51
00:02:43,810 --> 00:02:47,019
it exploited compression by measuring

52
00:02:47,019 --> 00:02:50,829
time time transmission instead of size

53
00:02:50,829 --> 00:02:54,549
payload and because of that there was no

54
00:02:54,549 --> 00:02:58,750
need for money the middle-ages next with

55
00:02:58,750 --> 00:03:02,680
bridge again 2013 exploited HTTP

56
00:03:02,680 --> 00:03:06,670
response body the main secret was some

57
00:03:06,670 --> 00:03:08,769
tokens some secret tokens

58
00:03:08,769 --> 00:03:13,120
it has had stream ciphers and added some

59
00:03:13,120 --> 00:03:16,480
methods to bypass compression noise due

60
00:03:16,480 --> 00:03:22,018
to the compression attack the admin pool

61
00:03:22,319 --> 00:03:25,720
2015 rc4 is considering secure and

62
00:03:25,720 --> 00:03:28,599
that's why most website moved from

63
00:03:28,599 --> 00:03:30,970
street side from stream ciphers to block

64
00:03:30,970 --> 00:03:35,109
ciphers and that's why now ESA es is the

65
00:03:35,109 --> 00:03:36,629
industry standard

66
00:03:36,629 --> 00:03:41,260
Roger 2016 exploit compression against

67
00:03:41,260 --> 00:03:42,959
HTTP responses

68
00:03:42,959 --> 00:03:47,230
it attacks block ciphers AES and in

69
00:03:47,230 --> 00:03:49,269
order to achieve that it performs

70
00:03:49,269 --> 00:03:53,019
statistical analysis and bypasses a

71
00:03:53,019 --> 00:03:55,480
noise and length hiding so even in the

72
00:03:55,480 --> 00:04:00,160
latest versions of TLS a 1.3 roger is

73
00:04:00,160 --> 00:04:05,040
still is still possible roger is a

74
00:04:05,040 --> 00:04:07,780
production called framework which

75
00:04:07,780 --> 00:04:10,120
automates the attack and makes the

76
00:04:10,120 --> 00:04:14,470
process much easier and the last was a

77
00:04:14,470 --> 00:04:17,769
presenting black Satya USA 2016 it's

78
00:04:17,769 --> 00:04:21,849
heist which abuses the way responses are

79
00:04:21,849 --> 00:04:25,530
sent of the TLS several level by

80
00:04:25,530 --> 00:04:28,020
changing the TCP window

81
00:04:28,020 --> 00:04:30,760
and again like time there was no need

82
00:04:30,760 --> 00:04:35,380
for a money in the middle what agent so

83
00:04:35,380 --> 00:04:37,780
uh let's go quickly through the attack

84
00:04:37,780 --> 00:04:40,230
methodology how compression attack works

85
00:04:40,230 --> 00:04:43,780
I want to ask the audience how many of

86
00:04:43,780 --> 00:04:45,850
you have have seen any of the

87
00:04:45,850 --> 00:04:47,320
compression side channel attacks before

88
00:04:47,320 --> 00:04:50,590
like breach or crime or time by a raise

89
00:04:50,590 --> 00:04:52,930
of hands okay so most of you have seen

90
00:04:52,930 --> 00:04:54,820
this I'll go through this real quick so

91
00:04:54,820 --> 00:04:58,200
the idea here is that we have about two

92
00:04:58,200 --> 00:05:01,060
plaintext tests on our score test and

93
00:05:01,060 --> 00:05:04,870
test underscore Rand and if this

94
00:05:04,870 --> 00:05:08,020
compresses this and we compress this as

95
00:05:08,020 --> 00:05:10,090
well then this will have a better

96
00:05:10,090 --> 00:05:11,950
compression ratio than this one because

97
00:05:11,950 --> 00:05:14,620
here this some sort of repetition so if

98
00:05:14,620 --> 00:05:17,320
the plaintext is partially secret and

99
00:05:17,320 --> 00:05:18,970
partially controlled by an adversary and

100
00:05:18,970 --> 00:05:20,470
it's taken through a compression

101
00:05:20,470 --> 00:05:22,570
function then the adversary by measuring

102
00:05:22,570 --> 00:05:25,450
the length of the on on the network they

103
00:05:25,450 --> 00:05:27,850
can tell if they actually hit the

104
00:05:27,850 --> 00:05:30,310
correct secret so that's the big idea of

105
00:05:30,310 --> 00:05:34,240
the this attack and the two components

106
00:05:34,240 --> 00:05:36,070
these two two constitutes constituent

107
00:05:36,070 --> 00:05:37,900
components are the reflection this is a

108
00:05:37,900 --> 00:05:39,310
part of the plaintext controlled by the

109
00:05:39,310 --> 00:05:41,350
adversary and then the secret is the

110
00:05:41,350 --> 00:05:44,440
part of the plaintext that is the target

111
00:05:44,440 --> 00:05:48,210
of the adversary and so if we go to a

112
00:05:48,210 --> 00:05:51,340
diagram like this this is the adversary

113
00:05:51,340 --> 00:05:53,920
they're targeting a victim on the

114
00:05:53,920 --> 00:05:57,160
network and then the victim hits an HTTP

115
00:05:57,160 --> 00:05:59,830
website like Gmail and the attacker

116
00:05:59,830 --> 00:06:02,680
makes the victim make several requests

117
00:06:02,680 --> 00:06:05,230
to Gmail for example by make it by using

118
00:06:05,230 --> 00:06:06,910
Java Script on some different website

119
00:06:06,910 --> 00:06:09,730
here they're injecting some code to do

120
00:06:09,730 --> 00:06:12,310
that and then they measure the TLS

121
00:06:12,310 --> 00:06:14,310
encrypted responses on the network and

122
00:06:14,310 --> 00:06:16,270
extract the length from that because

123
00:06:16,270 --> 00:06:19,060
length is preserved across encryption so

124
00:06:19,060 --> 00:06:20,920
that's the basic idea and if we look at

125
00:06:20,920 --> 00:06:22,960
Gmail a response for example you see

126
00:06:22,960 --> 00:06:25,530
this exactly what's happening there is a

127
00:06:25,530 --> 00:06:28,570
this is a search page of Gmail and it

128
00:06:28,570 --> 00:06:31,060
includes two different things here is

129
00:06:31,060 --> 00:06:34,030
the CSRF token if the adversary feels

130
00:06:34,030 --> 00:06:36,430
that they can impersonate the victim and

131
00:06:36,430 --> 00:06:39,250
then if the attacker puts on the URL

132
00:06:39,250 --> 00:06:41,009
some search curie this is

133
00:06:41,009 --> 00:06:43,020
like that in the HTML like this so if

134
00:06:43,020 --> 00:06:44,969
they search for this it's reflected and

135
00:06:44,969 --> 00:06:47,249
then if these compressed together well

136
00:06:47,249 --> 00:06:49,409
then the attacker knows that they get

137
00:06:49,409 --> 00:06:51,029
the correct secret and they can do that

138
00:06:51,029 --> 00:06:53,009
letter by letter so that's the basic

139
00:06:53,009 --> 00:06:55,349
idea and this is already what breach is

140
00:06:55,349 --> 00:07:01,050
doing in ruptures doing timewise okay so

141
00:07:01,050 --> 00:07:03,360
at this point we'll introduce our

142
00:07:03,360 --> 00:07:08,099
defense which are and mitigates attacks

143
00:07:08,099 --> 00:07:11,279
that use this vector so we will this is

144
00:07:11,279 --> 00:07:14,729
the CTX defense and what this defense

145
00:07:14,729 --> 00:07:18,539
does is protect context by using a

146
00:07:18,539 --> 00:07:20,460
periodic manner in order to separate

147
00:07:20,460 --> 00:07:23,699
secrets and avoid cross compression

148
00:07:23,699 --> 00:07:25,229
between secrets from different origins

149
00:07:25,229 --> 00:07:28,349
so this definition of whistle introduces

150
00:07:28,349 --> 00:07:31,399
some notions that need to be explained

151
00:07:31,399 --> 00:07:34,770
firstly what is in origin so we say that

152
00:07:34,770 --> 00:07:38,009
an origin is the party that generated

153
00:07:38,009 --> 00:07:40,770
the secret now this party can be either

154
00:07:40,770 --> 00:07:44,249
the web publication or a user that uses

155
00:07:44,249 --> 00:07:46,979
this web service and we will say that

156
00:07:46,979 --> 00:07:49,680
all secrets that were generated by the

157
00:07:49,680 --> 00:07:51,839
same origin will be compressed together

158
00:07:51,839 --> 00:07:53,610
and we will allow cross compression

159
00:07:53,610 --> 00:07:56,879
whereas a to secret that were generated

160
00:07:56,879 --> 00:07:58,949
from different origins will not be

161
00:07:58,949 --> 00:08:01,769
compressed together so for example if we

162
00:08:01,769 --> 00:08:05,999
have an inbox at Google in books we see

163
00:08:05,999 --> 00:08:10,680
that we have some mails and the sender

164
00:08:10,680 --> 00:08:13,919
of the emails could be used as an origin

165
00:08:13,919 --> 00:08:18,089
so the purple ones were generated by Ava

166
00:08:18,089 --> 00:08:21,689
which is one origin and the orange ones

167
00:08:21,689 --> 00:08:23,490
were generated by Demeter's with who is

168
00:08:23,490 --> 00:08:28,050
the different origin so these all these

169
00:08:28,050 --> 00:08:31,080
generated some secrets and these secrets

170
00:08:31,080 --> 00:08:34,679
well secrets in the HCP response can be

171
00:08:34,679 --> 00:08:37,589
anything practic technically any part of

172
00:08:37,589 --> 00:08:40,078
the response which is encrypted can be

173
00:08:40,078 --> 00:08:42,870
considered a secret but in general we'll

174
00:08:42,870 --> 00:08:47,190
say that the secret is any piece of

175
00:08:47,190 --> 00:08:50,040
information in the response that can be

176
00:08:50,040 --> 00:08:52,350
accessed only when the user is loading

177
00:08:52,350 --> 00:08:54,779
so this can either be some

178
00:08:54,779 --> 00:08:58,410
a financial data a SSL token some

179
00:08:58,410 --> 00:09:01,829
private messages or emails or other

180
00:09:01,829 --> 00:09:04,649
sensitive data so for example in our

181
00:09:04,649 --> 00:09:09,209
previous example we saw that Ava sent

182
00:09:09,209 --> 00:09:12,180
some emails and the body of those emails

183
00:09:12,180 --> 00:09:14,670
can be configured and considered secret

184
00:09:14,670 --> 00:09:17,309
now all bodies of all the emails are

185
00:09:17,309 --> 00:09:20,430
secrets because they are set its data go

186
00:09:20,430 --> 00:09:24,439
ahead for the user of the service but

187
00:09:24,439 --> 00:09:26,639
different secrets we generate by

188
00:09:26,639 --> 00:09:29,670
different origin so the purple bodies of

189
00:09:29,670 --> 00:09:32,809
emails were generated by Dimitri's and

190
00:09:32,809 --> 00:09:36,660
the by Ava sorry and the orange ones

191
00:09:36,660 --> 00:09:40,350
will generate images so an orange email

192
00:09:40,350 --> 00:09:45,089
is a secret generated by a different

193
00:09:45,089 --> 00:09:48,269
origin than a purple email and in that

194
00:09:48,269 --> 00:09:53,759
case we say that secrets like emails

195
00:09:53,759 --> 00:09:55,649
that were generated from the same origin

196
00:09:55,649 --> 00:09:58,620
are allowed to compress together so all

197
00:09:58,620 --> 00:10:01,500
emails that were generated by Ava will

198
00:10:01,500 --> 00:10:05,519
be compressed together whereas emails

199
00:10:05,519 --> 00:10:07,860
that were sent from a different page

200
00:10:07,860 --> 00:10:10,050
people will not be compressed together

201
00:10:10,050 --> 00:10:12,750
so we will not allow cross compression

202
00:10:12,750 --> 00:10:17,279
and what is cross compression okay let's

203
00:10:17,279 --> 00:10:22,649
say with two elements in plain text

204
00:10:22,649 --> 00:10:26,089
we have element a you have a lemon B and

205
00:10:26,089 --> 00:10:30,779
if we allow cross compression then the

206
00:10:30,779 --> 00:10:33,480
presence of a during compression will

207
00:10:33,480 --> 00:10:36,509
affect the compression of B so for

208
00:10:36,509 --> 00:10:39,809
example if we're using lz77 algorithm

209
00:10:39,809 --> 00:10:43,399
for compression and we have plain text a

210
00:10:43,399 --> 00:10:46,139
concatenated with B where a is secret

211
00:10:46,139 --> 00:10:50,129
one and B is secret too then when using

212
00:10:50,129 --> 00:10:53,610
cross compression LC 77 will actually

213
00:10:53,610 --> 00:10:56,970
use a pointer for the second secret

214
00:10:56,970 --> 00:11:01,230
string and it will so show to the first

215
00:11:01,230 --> 00:11:04,379
secret string so the compression will be

216
00:11:04,379 --> 00:11:07,199
something like that this is an example

217
00:11:07,199 --> 00:11:08,280
of a course compare

218
00:11:08,280 --> 00:11:10,110
if we don't have our cross compression

219
00:11:10,110 --> 00:11:16,080
then uh both of these plaintext a and B

220
00:11:16,080 --> 00:11:22,080
would be a so l77

221
00:11:22,080 --> 00:11:27,480
will not use a pointer and how can we in

222
00:11:27,480 --> 00:11:30,950
general protect from our secrets from

223
00:11:30,950 --> 00:11:35,880
this side child they were proposed many

224
00:11:35,880 --> 00:11:39,440
solutions for solving this problem and

225
00:11:39,440 --> 00:11:44,120
in previous papers which they proposed a

226
00:11:44,120 --> 00:11:47,150
disabling compression altogether now

227
00:11:47,150 --> 00:11:49,830
this method obviously solves the problem

228
00:11:49,830 --> 00:11:50,130
because

229
00:11:50,130 --> 00:11:52,110
compression is the side channel that

230
00:11:52,110 --> 00:11:54,900
allows this attack however the

231
00:11:54,900 --> 00:11:58,530
performance penalty but will come from

232
00:11:58,530 --> 00:12:01,770
disabling compression altogether is in

233
00:12:01,770 --> 00:12:04,530
real world terms unacceptable so we

234
00:12:04,530 --> 00:12:06,380
can't actually disable compression a

235
00:12:06,380 --> 00:12:09,120
second proposal would be to change the

236
00:12:09,120 --> 00:12:13,290
compression function and change it in

237
00:12:13,290 --> 00:12:16,530
order to prevent cross compression

238
00:12:16,530 --> 00:12:19,020
between secrets and reflection or

239
00:12:19,020 --> 00:12:24,600
adversary generic data in general but in

240
00:12:24,600 --> 00:12:30,240
theory we are we're finding so far that

241
00:12:30,240 --> 00:12:32,280
all good compression functions are

242
00:12:32,280 --> 00:12:35,010
vulnerable and we don't have a practical

243
00:12:35,010 --> 00:12:37,980
example of a compression function that

244
00:12:37,980 --> 00:12:42,210
actually prevents side channels like the

245
00:12:42,210 --> 00:12:45,990
one we saw before so this also is so far

246
00:12:45,990 --> 00:12:48,180
not a good solution

247
00:12:48,180 --> 00:12:50,760
I third solution could be to modify the

248
00:12:50,760 --> 00:12:53,940
web server and the compression module

249
00:12:53,940 --> 00:12:57,350
that runs on the web server in order to

250
00:12:57,350 --> 00:12:59,000
[Music]

251
00:12:59,000 --> 00:13:01,560
annotate different parts of the page and

252
00:13:01,560 --> 00:13:04,730
not compress these parts together but

253
00:13:04,730 --> 00:13:07,890
this also has some problems because in

254
00:13:07,890 --> 00:13:09,870
this case we have to both change the web

255
00:13:09,870 --> 00:13:11,940
server and the application level

256
00:13:11,940 --> 00:13:16,230
services and also this is this method

257
00:13:16,230 --> 00:13:19,530
actually makes it really kind of hard to

258
00:13:19,530 --> 00:13:21,510
achieve good compression rate so

259
00:13:21,510 --> 00:13:24,000
it's in a middle ground but it's not

260
00:13:24,000 --> 00:13:27,930
that easy to actually develop it and a

261
00:13:27,930 --> 00:13:30,209
third solution would be to actually add

262
00:13:30,209 --> 00:13:34,970
some random data which prevent the

263
00:13:34,970 --> 00:13:39,709
attacks from reducing easily what is a

264
00:13:39,709 --> 00:13:41,820
good compression and what is about

265
00:13:41,820 --> 00:13:44,519
compression so when we run the different

266
00:13:44,519 --> 00:13:47,190
candidates in our attack adding random

267
00:13:47,190 --> 00:13:52,589
padding would probably hide the fact

268
00:13:52,589 --> 00:13:54,449
that good candidates compress better

269
00:13:54,449 --> 00:13:56,519
that bad context and this was actually

270
00:13:56,519 --> 00:13:59,699
implemented until s13 however in rapture

271
00:13:59,699 --> 00:14:04,230
we are it showed that this method is

272
00:14:04,230 --> 00:14:07,440
also susceptible to alignment using

273
00:14:07,440 --> 00:14:11,279
alignment alphabet to result in blocks

274
00:14:11,279 --> 00:14:13,199
in block alignment in the block ciphers

275
00:14:13,199 --> 00:14:16,079
or it is also susceptible to statistical

276
00:14:16,079 --> 00:14:18,990
analysis so it is actually kind of a

277
00:14:18,990 --> 00:14:20,430
half measure it doesn't solve the

278
00:14:20,430 --> 00:14:23,029
problem it just pushes it to the future

279
00:14:23,029 --> 00:14:26,220
our proposal is actually to change the

280
00:14:26,220 --> 00:14:31,380
response blinded so this is in the

281
00:14:31,380 --> 00:14:35,579
middle ground and we have implemented it

282
00:14:35,579 --> 00:14:38,519
in order to prevent these side-channel

283
00:14:38,519 --> 00:14:40,550
attacks

284
00:14:41,329 --> 00:14:46,310
okay so city X protects HTTP responses

285
00:14:46,310 --> 00:14:50,370
since we already said that due to the

286
00:14:50,370 --> 00:14:53,399
mitigation of crime that no compression

287
00:14:53,399 --> 00:14:56,880
attacks are no longer feasible so City X

288
00:14:56,880 --> 00:14:58,290
is only for the responses

289
00:14:58,290 --> 00:15:01,019
it runs ended at the application layer

290
00:15:01,019 --> 00:15:04,079
so there is no need for modifications of

291
00:15:04,079 --> 00:15:06,329
the web standards or the web server and

292
00:15:06,329 --> 00:15:10,589
is obtained as we will show from our

293
00:15:10,589 --> 00:15:13,350
experiments it's the best balance

294
00:15:13,350 --> 00:15:15,540
between performance and security we

295
00:15:15,540 --> 00:15:18,389
achieve this we achieve full prevention

296
00:15:18,389 --> 00:15:21,180
of complete latex recovery just by a

297
00:15:21,180 --> 00:15:23,819
slight compression size increase and

298
00:15:23,819 --> 00:15:26,730
with just a small time performance

299
00:15:26,730 --> 00:15:29,910
overhead so what we propose is a

300
00:15:29,910 --> 00:15:33,269
successful defense for all known

301
00:15:33,269 --> 00:15:34,290
compression attacks

302
00:15:34,290 --> 00:15:35,240
such as

303
00:15:35,240 --> 00:15:37,700
all these mentioned before time crime

304
00:15:37,700 --> 00:15:42,649
Brits so what the application developer

305
00:15:42,649 --> 00:15:45,350
has to do in order to include CTX

306
00:15:45,350 --> 00:15:49,760
defense to hit their application they

307
00:15:49,760 --> 00:15:52,580
need to import two libraries one for the

308
00:15:52,580 --> 00:15:56,300
server side or the specific a web

309
00:15:56,300 --> 00:15:59,660
framework they use and for one for the

310
00:15:59,660 --> 00:16:03,730
client side then they need to select

311
00:16:03,730 --> 00:16:07,010
which portions of the color of the

312
00:16:07,010 --> 00:16:11,140
context are considered fifth secret and

313
00:16:11,140 --> 00:16:15,040
define origin for its secret now if we

314
00:16:15,040 --> 00:16:19,160
we can divide our whole response in many

315
00:16:19,160 --> 00:16:22,700
origins we could have one origin per

316
00:16:22,700 --> 00:16:25,730
secret but this is the same as a

317
00:16:25,730 --> 00:16:28,550
completely disabling compression which

318
00:16:28,550 --> 00:16:31,399
is no dude and we could also have one

319
00:16:31,399 --> 00:16:34,630
origin for the whole plain text which

320
00:16:34,630 --> 00:16:39,200
would result in no CDX protection so we

321
00:16:39,200 --> 00:16:41,060
need to define the origins for its

322
00:16:41,060 --> 00:16:45,980
secret here is an example we have a for

323
00:16:45,980 --> 00:16:50,120
loop this is a template and we have a

324
00:16:50,120 --> 00:16:52,910
for loop for emails and we want what we

325
00:16:52,910 --> 00:16:56,420
want to show is a table it's the center

326
00:16:56,420 --> 00:17:00,290
of the email and then the body and what

327
00:17:00,290 --> 00:17:03,440
the developer has to do so as the city

328
00:17:03,440 --> 00:17:06,500
expect the sensitive part of the

329
00:17:06,500 --> 00:17:10,119
response which is the email body is that

330
00:17:10,119 --> 00:17:14,059
we see a we use CTX protect tag and we

331
00:17:14,059 --> 00:17:17,510
use email and email body and email

332
00:17:17,510 --> 00:17:21,459
sender email body is our secret and

333
00:17:21,459 --> 00:17:26,630
email sender is our origin after that he

334
00:17:26,630 --> 00:17:29,330
has to include CTX permutations this is

335
00:17:29,330 --> 00:17:33,500
a script add projection which includes

336
00:17:33,500 --> 00:17:37,240
all the permutations for its origin and

337
00:17:37,240 --> 00:17:41,540
the final one the physics object is the

338
00:17:41,540 --> 00:17:46,910
client now if we didn't use a CTX

339
00:17:46,910 --> 00:17:48,800
protection what this

340
00:17:48,800 --> 00:17:52,700
the response that would travel through

341
00:17:52,700 --> 00:17:55,850
the network and this is it would be

342
00:17:55,850 --> 00:17:58,880
encrypted okay but this is the response

343
00:17:58,880 --> 00:18:02,950
that the server would send now if we use

344
00:18:02,950 --> 00:18:08,960
City protection what an advisory would

345
00:18:08,960 --> 00:18:13,070
see is something like that instead of

346
00:18:13,070 --> 00:18:15,740
the city XProtect tag we have this deal

347
00:18:15,740 --> 00:18:19,490
here which is a data set X origin with

348
00:18:19,490 --> 00:18:22,880
an integer to define which origin this

349
00:18:22,880 --> 00:18:26,960
is and then we have the secret the email

350
00:18:26,960 --> 00:18:31,970
body per muted and now this is not easy

351
00:18:31,970 --> 00:18:35,510
and advisor can distinguish and it can

352
00:18:35,510 --> 00:18:38,410
perform a set channel compression attack

353
00:18:38,410 --> 00:18:41,900
now let's talk about permutations we

354
00:18:41,900 --> 00:18:44,390
need first to define the secret alphabet

355
00:18:44,390 --> 00:18:50,150
this is we need to to know what all the

356
00:18:50,150 --> 00:18:53,630
characters that the secret may include

357
00:18:53,630 --> 00:18:56,930
it could be a ski it could be utf-8 or

358
00:18:56,930 --> 00:19:02,920
anything else and then we we perform a

359
00:19:02,920 --> 00:19:06,170
sender Adam permutation for the secret

360
00:19:06,170 --> 00:19:09,320
for each origin we know network see it

361
00:19:09,320 --> 00:19:13,400
secret sorry for it secret out of it and

362
00:19:13,400 --> 00:19:16,070
we used fishery Yates south logarithm

363
00:19:16,070 --> 00:19:19,400
which is which performs an unbiased

364
00:19:19,400 --> 00:19:22,360
permutation meaning that each element

365
00:19:22,360 --> 00:19:25,600
has the same probability of being chosen

366
00:19:25,600 --> 00:19:28,930
then we permute the secrets using the

367
00:19:28,930 --> 00:19:31,400
the origins permutation that we

368
00:19:31,400 --> 00:19:37,610
generated before and then this this HTTP

369
00:19:37,610 --> 00:19:40,450
response with the per muted secrets or

370
00:19:40,450 --> 00:19:43,100
TLS encrypted and traveled and

371
00:19:43,100 --> 00:19:44,890
transmitted through the network

372
00:19:44,890 --> 00:19:49,760
once on the user's browser we apply

373
00:19:49,760 --> 00:19:52,430
inverse permutation and we typically we

374
00:19:52,430 --> 00:19:55,910
decode the secret here is an example of

375
00:19:55,910 --> 00:19:59,420
how this happens we have two origins or

376
00:19:59,420 --> 00:20:02,360
it's in one and origin two and here are

377
00:20:02,360 --> 00:20:04,370
are the permutations of course there are

378
00:20:04,370 --> 00:20:06,860
more but here is what we're going to

379
00:20:06,860 --> 00:20:10,280
need and we have two secrets from origin

380
00:20:10,280 --> 00:20:14,600
one secret one and secret two as you can

381
00:20:14,600 --> 00:20:17,480
see this is a permitted secret we use

382
00:20:17,480 --> 00:20:20,540
the same permutation for the same origin

383
00:20:20,540 --> 00:20:24,880
so secret and secret are the same and

384
00:20:24,880 --> 00:20:26,900
okay one and two are different because

385
00:20:26,900 --> 00:20:30,800
they have different permutations and for

386
00:20:30,800 --> 00:20:34,190
the secret generated from origin - we

387
00:20:34,190 --> 00:20:36,140
have a completely different permutation

388
00:20:36,140 --> 00:20:39,280
because the different origin and a

389
00:20:39,280 --> 00:20:42,680
completely new permutation has been

390
00:20:42,680 --> 00:20:49,820
generated the power of the bridge attack

391
00:20:49,820 --> 00:20:52,670
lies under the assumption that we can

392
00:20:52,670 --> 00:20:55,820
perform multiple requests - to the

393
00:20:55,820 --> 00:21:01,010
target and after that do some

394
00:21:01,010 --> 00:21:04,310
statistical analysis what we were

395
00:21:04,310 --> 00:21:07,100
implemented is that parity Theory

396
00:21:07,100 --> 00:21:09,200
response we have nuclear origin

397
00:21:09,200 --> 00:21:12,860
permutations so multiple requests are

398
00:21:12,860 --> 00:21:16,340
made multiple pred and different

399
00:21:16,340 --> 00:21:18,500
commuted secrets are being transmitted

400
00:21:18,500 --> 00:21:22,910
to the network statistical analysis is

401
00:21:22,910 --> 00:21:29,570
no longer feasible okay so at this point

402
00:21:29,570 --> 00:21:33,500
we have found that there is a problem we

403
00:21:33,500 --> 00:21:34,910
have found that there are some attacks

404
00:21:34,910 --> 00:21:37,850
that use compression in order to bypass

405
00:21:37,850 --> 00:21:41,000
security we have developed a defense

406
00:21:41,000 --> 00:21:45,580
that actually mitigate this problem and

407
00:21:45,580 --> 00:21:51,320
we want to argue why this is a better

408
00:21:51,320 --> 00:21:56,290
solution than other proposed methods for

409
00:21:56,290 --> 00:21:58,160
mitigating these attacks

410
00:21:58,160 --> 00:22:03,140
so we'll perform some experiment in

411
00:22:03,140 --> 00:22:11,750
order to measure our defense we take the

412
00:22:11,750 --> 00:22:15,800
size overhead that is added to

413
00:22:15,800 --> 00:22:18,890
once so this is actually the kind of the

414
00:22:18,890 --> 00:22:21,800
body the man who is penalty when the

415
00:22:21,800 --> 00:22:23,810
server is sending the responses over the

416
00:22:23,810 --> 00:22:26,570
network and the time performance which

417
00:22:26,570 --> 00:22:30,950
translates to the server time the the

418
00:22:30,950 --> 00:22:35,120
time the server needs in order to apply

419
00:22:35,120 --> 00:22:38,030
CTX and the time that the client needs

420
00:22:38,030 --> 00:22:41,270
in order to deeper mute the secrets that

421
00:22:41,270 --> 00:22:45,650
were sent over the network so our web

422
00:22:45,650 --> 00:22:53,930
page is basically a 650 kilobyte HTML

423
00:22:53,930 --> 00:22:57,710
page the uncompressed page is a 650

424
00:22:57,710 --> 00:23:01,400
kilobyte this is a fairly regular in the

425
00:23:01,400 --> 00:23:03,470
real world systems like YouTube or

426
00:23:03,470 --> 00:23:07,580
Facebook the timelines are about that

427
00:23:07,580 --> 00:23:12,440
size we use the 50 origins so with we

428
00:23:12,440 --> 00:23:16,400
assumed that this page in this page the

429
00:23:16,400 --> 00:23:19,910
content was generated by 50 different

430
00:23:19,910 --> 00:23:22,610
people or channels or even the

431
00:23:22,610 --> 00:23:25,310
application that generates CSS tokens

432
00:23:25,310 --> 00:23:30,800
for example and we assume that one

433
00:23:30,800 --> 00:23:34,310
percent of this web page is actually a

434
00:23:34,310 --> 00:23:38,390
secret so we distribute this one percent

435
00:23:38,390 --> 00:23:43,490
to the 5000 it is equally now 1% might

436
00:23:43,490 --> 00:23:46,490
seem a little low or might seem a little

437
00:23:46,490 --> 00:23:50,150
high it it is actually kind of higher

438
00:23:50,150 --> 00:23:53,810
than real-world systems use because we

439
00:23:53,810 --> 00:23:57,350
found that for example a facebook front

440
00:23:57,350 --> 00:24:02,960
page had like 0.5% secrets and all other

441
00:24:02,960 --> 00:24:07,130
stuff in there are cDNA libraries or CSS

442
00:24:07,130 --> 00:24:10,940
libraries or static HTML code which is

443
00:24:10,940 --> 00:24:17,090
not a secret actually so 1% my inner

444
00:24:17,090 --> 00:24:21,070
example I'd be a bit exaggerated for a

445
00:24:21,070 --> 00:24:25,930
facebook timeline for example but with

446
00:24:25,930 --> 00:24:29,810
is actually a good rate to s

447
00:24:29,810 --> 00:24:34,370
our defense and well this 1% is equal to

448
00:24:34,370 --> 00:24:37,340
deviated origins so we say that there is

449
00:24:37,340 --> 00:24:40,040
one secret position in the response

450
00:24:40,040 --> 00:24:43,880
priority now even if there were multiple

451
00:24:43,880 --> 00:24:47,030
positions we City X allows cross

452
00:24:47,030 --> 00:24:49,760
compression so even if we use like two

453
00:24:49,760 --> 00:24:52,940
or three secret petitions this X would

454
00:24:52,940 --> 00:24:55,280
actually be compressed together so it

455
00:24:55,280 --> 00:24:57,550
doesn't make that much difference in

456
00:24:57,550 --> 00:25:01,220
considering our experiments okay

457
00:25:01,220 --> 00:25:04,520
and we run these experiments and we

458
00:25:04,520 --> 00:25:06,470
found some kind of interesting results

459
00:25:06,470 --> 00:25:12,140
so I will compare our defense with the

460
00:25:12,140 --> 00:25:15,110
other proposals the first proposal was

461
00:25:15,110 --> 00:25:17,860
to desert the compression altogether and

462
00:25:17,860 --> 00:25:20,960
as I said at at the beginning this is

463
00:25:20,960 --> 00:25:25,700
actually kind of bad in performance

464
00:25:25,700 --> 00:25:28,760
terms so if we disable the compression

465
00:25:28,760 --> 00:25:32,620
in this web page with these heuristics

466
00:25:32,620 --> 00:25:37,210
the size overhead will be a one-point

467
00:25:37,210 --> 00:25:42,500
1000% so the response that would be

468
00:25:42,500 --> 00:25:44,530
transmitted over the network would

469
00:25:44,530 --> 00:25:50,450
effectively be 12 times or so other the

470
00:25:50,450 --> 00:25:53,300
compressed one but we sent right now so

471
00:25:53,300 --> 00:25:56,750
that obviously introduces a bandwidth

472
00:25:56,750 --> 00:26:03,380
problem and also again depending on the

473
00:26:03,380 --> 00:26:07,700
network that the user is using or of the

474
00:26:07,700 --> 00:26:09,920
server this might result in actually a

475
00:26:09,920 --> 00:26:14,300
few seconds delay of loading time in the

476
00:26:14,300 --> 00:26:18,770
response so I think that for a fairly

477
00:26:18,770 --> 00:26:23,780
regular big application that has not so

478
00:26:23,780 --> 00:26:26,360
many like a thousand clients this is

479
00:26:26,360 --> 00:26:29,120
kinda bad this is really bad

480
00:26:29,120 --> 00:26:32,180
a second proposal that was actually used

481
00:26:32,180 --> 00:26:34,490
by Facebook in order to prevent exactly

482
00:26:34,490 --> 00:26:38,150
bridge from stealing Caesar tokens from

483
00:26:38,150 --> 00:26:41,570
Facebook was masking secrets and what

484
00:26:41,570 --> 00:26:43,730
what this method does is

485
00:26:43,730 --> 00:26:47,650
a secret and it generates a random

486
00:26:47,650 --> 00:26:52,450
string of the same size and it applies

487
00:26:52,450 --> 00:26:56,300
an XOR of the mask the randomly

488
00:26:56,300 --> 00:26:58,910
generated mask and the secret this is

489
00:26:58,910 --> 00:27:01,460
done for every response so obviously a

490
00:27:01,460 --> 00:27:03,740
in every response the transmitted secret

491
00:27:03,740 --> 00:27:07,910
will be different and we the attacker

492
00:27:07,910 --> 00:27:12,310
cannot use the statistical analysis to

493
00:27:12,310 --> 00:27:17,800
find the secret but this method actually

494
00:27:17,800 --> 00:27:22,130
what this and practically give that is

495
00:27:22,130 --> 00:27:25,460
disable compression because if you mask

496
00:27:25,460 --> 00:27:29,060
a secret then the data that will take

497
00:27:29,060 --> 00:27:30,680
the place of the secret will be

498
00:27:30,680 --> 00:27:33,680
practically random so they will not

499
00:27:33,680 --> 00:27:35,540
compress well with the rest of the page

500
00:27:35,540 --> 00:27:39,460
so in this case you actually kind of

501
00:27:39,460 --> 00:27:42,920
disable compression for secret and also

502
00:27:42,920 --> 00:27:44,720
double the size of those secrets because

503
00:27:44,720 --> 00:27:48,260
each time you have to include both the

504
00:27:48,260 --> 00:27:51,170
the master secret and the mask in order

505
00:27:51,170 --> 00:27:55,580
to apply the de masking in a client so

506
00:27:55,580 --> 00:27:59,720
in this case if you practically disable

507
00:27:59,720 --> 00:28:04,130
compression for altogether for secret

508
00:28:04,130 --> 00:28:08,840
you have a about 21 percent size

509
00:28:08,840 --> 00:28:12,800
overhead so the the face that will be

510
00:28:12,800 --> 00:28:15,590
sent over the network will be like one

511
00:28:15,590 --> 00:28:19,040
point two one times the the size it is

512
00:28:19,040 --> 00:28:22,880
right now and well that doesn't sound so

513
00:28:22,880 --> 00:28:27,500
bad it might result in a in a few dozens

514
00:28:27,500 --> 00:28:31,370
of milliseconds delay for the network

515
00:28:31,370 --> 00:28:34,550
transmission or the web server to apply

516
00:28:34,550 --> 00:28:38,900
masking it well in some cases if you're

517
00:28:38,900 --> 00:28:41,780
not so worried about performance or if

518
00:28:41,780 --> 00:28:44,360
the secrets are that important and you

519
00:28:44,360 --> 00:28:46,490
don't have any other solutions well it

520
00:28:46,490 --> 00:28:48,020
could be a solution yes you could

521
00:28:48,020 --> 00:28:51,110
probably use it but well we propose City

522
00:28:51,110 --> 00:28:55,040
X is actually allows for a better

523
00:28:55,040 --> 00:28:57,950
compression ratio and that is because

524
00:28:57,950 --> 00:29:01,610
we allow compression of the secrets and

525
00:29:01,610 --> 00:29:05,870
because the permutation is the same for

526
00:29:05,870 --> 00:29:08,990
all secrets these will actually compress

527
00:29:08,990 --> 00:29:12,110
well because the protected secret will

528
00:29:12,110 --> 00:29:14,810
have the same statistical similarities

529
00:29:14,810 --> 00:29:17,090
done the unprotected secret although it

530
00:29:17,090 --> 00:29:18,800
will obviously be different because it

531
00:29:18,800 --> 00:29:22,270
is per muted so in this case our

532
00:29:22,270 --> 00:29:25,730
experiments so that when using CTX for

533
00:29:25,730 --> 00:29:28,460
this same webpage the size over

534
00:29:28,460 --> 00:29:32,200
will be about 5% which translates to

535
00:29:32,200 --> 00:29:37,340
approximately 7 kilobytes of data that

536
00:29:37,340 --> 00:29:40,490
will be sent over the network compared

537
00:29:40,490 --> 00:29:43,670
to what is the place right now and this

538
00:29:43,670 --> 00:29:46,280
delay on the server side in order to

539
00:29:46,280 --> 00:29:48,440
generate all the permutations in order

540
00:29:48,440 --> 00:29:50,990
to mask all this to permute yeah all the

541
00:29:50,990 --> 00:29:53,780
secrets in order to create all the div

542
00:29:53,780 --> 00:29:57,220
tags and send it over the network and

543
00:29:57,220 --> 00:30:00,590
deeper muted on ohmic lines and actually

544
00:30:00,590 --> 00:30:04,160
so the web page is a few milliseconds

545
00:30:04,160 --> 00:30:07,220
time like for 2 to 10 milliseconds so

546
00:30:07,220 --> 00:30:11,150
this is pretty good this this

547
00:30:11,150 --> 00:30:15,140
performance penalty is in general could

548
00:30:15,140 --> 00:30:17,120
be considered acceptable either for

549
00:30:17,120 --> 00:30:19,940
large applications that have millions of

550
00:30:19,940 --> 00:30:23,300
clients because what this does is

551
00:30:23,300 --> 00:30:26,450
actually mitigated a serious problem

552
00:30:26,450 --> 00:30:31,420
with every little performance penalty

553
00:30:31,420 --> 00:30:37,160
and well up to this point we have seen

554
00:30:37,160 --> 00:30:39,650
that there are some different elements

555
00:30:39,650 --> 00:30:43,070
and some different parts of the defense

556
00:30:43,070 --> 00:30:47,030
that actually change how it runs and

557
00:30:47,030 --> 00:30:50,600
these parts are the origins they are how

558
00:30:50,600 --> 00:30:52,880
many secrets are in the webpage so if

559
00:30:52,880 --> 00:30:54,800
you have like 1% of the webpage to

560
00:30:54,800 --> 00:30:58,670
secret compared to 90% well this

561
00:30:58,670 --> 00:31:01,490
obviously will affect the performance of

562
00:31:01,490 --> 00:31:03,740
CTX because there is much more things

563
00:31:03,740 --> 00:31:05,720
that needs to be permuted

564
00:31:05,720 --> 00:31:09,890
and also if the total response is bigger

565
00:31:09,890 --> 00:31:10,760
than

566
00:31:10,760 --> 00:31:16,760
CTX will also have a different type of

567
00:31:16,760 --> 00:31:20,040
performance penalties because civics

568
00:31:20,040 --> 00:31:24,840
indeed adds some constant length of data

569
00:31:24,840 --> 00:31:27,150
and that is for example the div tags or

570
00:31:27,150 --> 00:31:31,020
the jason that included that has the

571
00:31:31,020 --> 00:31:36,570
permutations in it or the actual CX

572
00:31:36,570 --> 00:31:40,020
client script tag so what we have found

573
00:31:40,020 --> 00:31:43,680
is is that the more origins you use the

574
00:31:43,680 --> 00:31:46,770
worse the performance of CX will be and

575
00:31:46,770 --> 00:31:48,930
that actually makes sense because if you

576
00:31:48,930 --> 00:31:52,800
use more origins then a secret will be

577
00:31:52,800 --> 00:31:56,280
divided in more parts so compression

578
00:31:56,280 --> 00:32:01,260
will be disabled for those parts and the

579
00:32:01,260 --> 00:32:04,020
compression rate will go down so

580
00:32:04,020 --> 00:32:08,100
performance will also go down and while

581
00:32:08,100 --> 00:32:10,800
deciding which origins you want to use

582
00:32:10,800 --> 00:32:16,460
is actually a good it should actually be

583
00:32:16,460 --> 00:32:18,870
taken into serious consideration in

584
00:32:18,870 --> 00:32:21,990
order to avoid a performance penalties

585
00:32:21,990 --> 00:32:25,790
that what could be avoided for example

586
00:32:25,790 --> 00:32:28,740
also if the total of secrets in the

587
00:32:28,740 --> 00:32:31,500
webpage are going up then performance

588
00:32:31,500 --> 00:32:34,140
also goes down because the more secrets

589
00:32:34,140 --> 00:32:36,990
you have to mask - the more secrets you

590
00:32:36,990 --> 00:32:42,830
have to protect so the bigger the other

591
00:32:42,830 --> 00:32:46,770
per muted our data in the response will

592
00:32:46,770 --> 00:32:49,740
be the longer the permutation to be

593
00:32:49,740 --> 00:32:54,150
applied will be so the server side and

594
00:32:54,150 --> 00:32:57,810
the client sides that actually apply the

595
00:32:57,810 --> 00:32:59,910
permutation and the D permutation will

596
00:32:59,910 --> 00:33:03,020
take longer so that actually makes sense

597
00:33:03,020 --> 00:33:06,510
however if there are more origins a more

598
00:33:06,510 --> 00:33:10,830
secret pair origin then because CTX

599
00:33:10,830 --> 00:33:14,460
allows cross compression the performance

600
00:33:14,460 --> 00:33:16,650
will go up because the compression rate

601
00:33:16,650 --> 00:33:18,960
will be better so secret will be

602
00:33:18,960 --> 00:33:20,820
compressed together because they come

603
00:33:20,820 --> 00:33:23,280
from the same origin and the length will

604
00:33:23,280 --> 00:33:24,300
be actually small

605
00:33:24,300 --> 00:33:27,510
and smaller because our compression will

606
00:33:27,510 --> 00:33:28,950
be better

607
00:33:28,950 --> 00:33:31,260
and finally if the total response goes

608
00:33:31,260 --> 00:33:35,030
up then the performance will also go up

609
00:33:35,030 --> 00:33:41,580
because as we get and that kind kind of

610
00:33:41,580 --> 00:33:44,820
addition because it's not so obvious at

611
00:33:44,820 --> 00:33:47,970
first why what happens why when the

612
00:33:47,970 --> 00:33:51,030
total is bigger we have better sex

613
00:33:51,030 --> 00:33:54,120
performers and someone might consider B

614
00:33:54,120 --> 00:33:58,820
K if it would it could be possible that

615
00:33:58,820 --> 00:34:01,890
the more the bigger the response was the

616
00:34:01,890 --> 00:34:04,200
more the thicker there were and actually

617
00:34:04,200 --> 00:34:06,990
that would result in in a worse

618
00:34:06,990 --> 00:34:11,040
performance but the thing is that we we

619
00:34:11,040 --> 00:34:14,340
have a bigger is a response then the

620
00:34:14,340 --> 00:34:18,900
actual bite size that will be included

621
00:34:18,900 --> 00:34:22,110
as an overhead in the compressed text

622
00:34:22,110 --> 00:34:24,210
will be sent over the network it's

623
00:34:24,210 --> 00:34:26,460
fairly the same it's not that different

624
00:34:26,460 --> 00:34:29,550
so for example for a small page and for

625
00:34:29,550 --> 00:34:33,139
a fairly large space like Facebook the

626
00:34:33,139 --> 00:34:36,780
overhead penalty in bytes will be from

627
00:34:36,780 --> 00:34:39,900
seven to ten it's not that much however

628
00:34:39,900 --> 00:34:44,120
the more the beginners response of the

629
00:34:44,120 --> 00:34:48,030
the less the impact this overhead will

630
00:34:48,030 --> 00:34:52,280
have all the actually a performance so

631
00:34:52,280 --> 00:34:56,040
for a large web page these seven or

632
00:34:56,040 --> 00:35:00,510
eight or nine kilobytes will be kind of

633
00:35:00,510 --> 00:35:04,380
hidden in the large the larger context

634
00:35:04,380 --> 00:35:09,260
of the response so only if you use a

635
00:35:09,260 --> 00:35:12,240
bigger response and when you have a

636
00:35:12,240 --> 00:35:15,420
bigger application CPX actually is even

637
00:35:15,420 --> 00:35:19,050
better so this is a diagram that shows

638
00:35:19,050 --> 00:35:25,950
exactly this the the x-axis is the

639
00:35:25,950 --> 00:35:28,680
response size so we started from a

640
00:35:28,680 --> 00:35:32,280
thirteen kilobyte web page this is the

641
00:35:32,280 --> 00:35:36,840
not compressed HTML response of the

642
00:35:36,840 --> 00:35:41,490
webpage and we go all the way up to 650

643
00:35:41,490 --> 00:35:46,230
kilobyte a web responses like Facebook

644
00:35:46,230 --> 00:35:50,670
like YouTube like Twitter and what we

645
00:35:50,670 --> 00:35:54,390
see is that the Left y-axis is the

646
00:35:54,390 --> 00:35:58,860
percentage of overhead penalty that city

647
00:35:58,860 --> 00:36:02,910
exerts so for a really really small web

648
00:36:02,910 --> 00:36:04,560
base like 13 kilobytes

649
00:36:04,560 --> 00:36:07,860
the penalty is kind of large yeah the

650
00:36:07,860 --> 00:36:13,860
CTX will result in about 2.2 percent

651
00:36:13,860 --> 00:36:18,660
overhead in the response so with if we

652
00:36:18,660 --> 00:36:23,280
you have a web site that sent back 10 or

653
00:36:23,280 --> 00:36:28,490
20 kilo byte responses CTX will kind of

654
00:36:28,490 --> 00:36:32,780
double or results in 2.5 times the

655
00:36:32,780 --> 00:36:38,070
vegies content that would be sent if you

656
00:36:38,070 --> 00:36:40,860
were not protected at all but what this

657
00:36:40,860 --> 00:36:44,550
means is that actually the the actual

658
00:36:44,550 --> 00:36:47,760
and data but are sent which are sown at

659
00:36:47,760 --> 00:36:51,930
the right y axis will be about a bit a

660
00:36:51,930 --> 00:36:56,100
bit over five kilobytes so because it is

661
00:36:56,100 --> 00:36:58,410
a small web page five kilobytes make it

662
00:36:58,410 --> 00:37:00,380
a gator of different a difference and

663
00:37:00,380 --> 00:37:05,310
yeah it will actually be compared to

664
00:37:05,310 --> 00:37:07,470
what you had before it will be much

665
00:37:07,470 --> 00:37:11,370
longer but as you evolve your

666
00:37:11,370 --> 00:37:13,890
application you add more stuff you add

667
00:37:13,890 --> 00:37:18,440
more functions you add more features and

668
00:37:18,440 --> 00:37:22,650
the response grows larger but you

669
00:37:22,650 --> 00:37:26,670
continue to use DX and CTX actually

670
00:37:26,670 --> 00:37:30,170
continues to add the same amount of

671
00:37:30,170 --> 00:37:34,350
response by it it goes from five

672
00:37:34,350 --> 00:37:39,950
kilobyte and we see that for us the

673
00:37:39,950 --> 00:37:44,250
response page grows larger the purple

674
00:37:44,250 --> 00:37:47,250
line actually goes down because this is

675
00:37:47,250 --> 00:37:50,609
the percentage of the

676
00:37:50,609 --> 00:37:56,609
X penalty and the orange line will well

677
00:37:56,609 --> 00:37:59,220
it will say the same at about some time

678
00:37:59,220 --> 00:38:02,279
and then it will it will grow a larger

679
00:38:02,279 --> 00:38:06,239
but in a more spin a smoother way so for

680
00:38:06,239 --> 00:38:10,499
example for like 500 kilobyte page you

681
00:38:10,499 --> 00:38:14,160
will add five point five kilobytes of

682
00:38:14,160 --> 00:38:18,210
data and this actually means that you

683
00:38:18,210 --> 00:38:22,980
are kind of double the response because

684
00:38:22,980 --> 00:38:29,700
yeah you still have used to use 50x it

685
00:38:29,700 --> 00:38:32,849
still visible compression up the point

686
00:38:32,849 --> 00:38:37,549
but if you use a web application that

687
00:38:37,549 --> 00:38:42,920
sent back like six hundred kilobytes

688
00:38:43,069 --> 00:38:46,349
responses the added data will be like

689
00:38:46,349 --> 00:38:51,140
seven kilobyte so the actual overhead in

690
00:38:51,140 --> 00:38:57,019
percent percentage terms will be about

691
00:38:57,019 --> 00:39:01,170
ten percent which is totally stable it's

692
00:39:01,170 --> 00:39:04,470
a four because four in six hundred

693
00:39:04,470 --> 00:39:06,839
kilobytes well seven don't make that

694
00:39:06,839 --> 00:39:10,739
much difference at all okay so this were

695
00:39:10,739 --> 00:39:15,420
absolutely the experiments that what we

696
00:39:15,420 --> 00:39:24,900
as we run so I want to show you a little

697
00:39:24,900 --> 00:39:28,289
bit about how how this works ckx

698
00:39:28,289 --> 00:39:30,599
architecture will go through the server

699
00:39:30,599 --> 00:39:33,569
and the client side a little bit so how

700
00:39:33,569 --> 00:39:39,509
does it work what the server does is it

701
00:39:39,509 --> 00:39:42,390
goes through the the tags that you have

702
00:39:42,390 --> 00:39:44,609
on your Django or whatever service out

703
00:39:44,609 --> 00:39:47,670
using and it generates the new

704
00:39:47,670 --> 00:39:50,279
permutation for every origin so if it

705
00:39:50,279 --> 00:39:51,720
sees a new origin it will generate a new

706
00:39:51,720 --> 00:39:53,549
permutation and notice that this is

707
00:39:53,549 --> 00:39:57,450
basically just a a replacement cipher as

708
00:39:57,450 --> 00:39:59,549
these are cipher lock kind of thing

709
00:39:59,549 --> 00:40:03,299
right and then this permutation will be

710
00:40:03,299 --> 00:40:04,320
stored for each one

711
00:40:04,320 --> 00:40:07,260
virgin and apply to each secret if two

712
00:40:07,260 --> 00:40:09,810
secrets share the same origin then the

713
00:40:09,810 --> 00:40:11,160
same permutation will be applied to them

714
00:40:11,160 --> 00:40:13,410
and notice that this happens every time

715
00:40:13,410 --> 00:40:15,990
a request hit this hits the server so

716
00:40:15,990 --> 00:40:18,780
the permutations are different every

717
00:40:18,780 --> 00:40:20,490
time and this is why this works

718
00:40:20,490 --> 00:40:23,430
basically and then at the end of the

719
00:40:23,430 --> 00:40:25,590
HTML body in the way that you saw the

720
00:40:25,590 --> 00:40:28,830
HTML code there's the tag that you saw

721
00:40:28,830 --> 00:40:30,690
with the permutations this basically

722
00:40:30,690 --> 00:40:33,090
includes the data that allows the client

723
00:40:33,090 --> 00:40:35,370
to unfirm Ute so this is just a jason

724
00:40:35,370 --> 00:40:39,360
like data painted to it so that's the

725
00:40:39,360 --> 00:40:41,940
service side part and then the client

726
00:40:41,940 --> 00:40:44,100
side part just does exactly the opposite

727
00:40:44,100 --> 00:40:46,080
so it looks for these specially crafted

728
00:40:46,080 --> 00:40:48,780
div tags and then it goes through your

729
00:40:48,780 --> 00:40:52,320
dom once pages to load it and also

730
00:40:52,320 --> 00:40:55,260
parses adjacent to find out what the

731
00:40:55,260 --> 00:40:58,410
permutations of servers and then it

732
00:40:58,410 --> 00:41:00,150
applies the permutations in Reverse on

733
00:41:00,150 --> 00:41:02,160
each secret so that the original data

734
00:41:02,160 --> 00:41:06,630
can be recovered okay so today's a big

735
00:41:06,630 --> 00:41:09,090
moment for our team because we're making

736
00:41:09,090 --> 00:41:10,950
this old sort of this software

737
00:41:10,950 --> 00:41:14,670
open-source it's actually right now open

738
00:41:14,670 --> 00:41:17,400
source on on github we just made it

739
00:41:17,400 --> 00:41:20,400
public you can go here to download it

740
00:41:20,400 --> 00:41:22,260
and install it and you can also go to

741
00:41:22,260 --> 00:41:25,410
our website on CTX defense com2 to

742
00:41:25,410 --> 00:41:28,410
download and install it so today we're

743
00:41:28,410 --> 00:41:31,770
launching it for three web frameworks on

744
00:41:31,770 --> 00:41:35,310
the server side one is django one is

745
00:41:35,310 --> 00:41:39,600
fisk and one is no js' a note reyes you

746
00:41:39,600 --> 00:41:42,170
can use a bunch of different templating

747
00:41:42,170 --> 00:41:46,110
like jade and it works well with the

748
00:41:46,110 --> 00:41:49,560
expressed framework this is MIT license

749
00:41:49,560 --> 00:41:51,810
and we're also providing a client which

750
00:41:51,810 --> 00:41:53,820
is published on Bower so you can install

751
00:41:53,820 --> 00:41:56,970
it on your websites right now and play

752
00:41:56,970 --> 00:42:04,140
with it yeah and these of course the

753
00:42:04,140 --> 00:42:07,110
Python endnote frameworks are on pi pi

754
00:42:07,110 --> 00:42:11,310
and npm everything is public okay and

755
00:42:11,310 --> 00:42:14,760
then we're hoping that you will take our

756
00:42:14,760 --> 00:42:16,710
code and maybe implement it in different

757
00:42:16,710 --> 00:42:18,049
frameworks

758
00:42:18,049 --> 00:42:21,259
we are the Python and JavaScript

759
00:42:21,259 --> 00:42:23,450
libraries that we have showed here while

760
00:42:23,450 --> 00:42:24,680
we have provided specific

761
00:42:24,680 --> 00:42:26,509
implementations for Django in flask and

762
00:42:26,509 --> 00:42:29,089
Express we have also provided generic

763
00:42:29,089 --> 00:42:31,220
libraries for the cryptographic part so

764
00:42:31,220 --> 00:42:33,319
you can just reuse these and build your

765
00:42:33,319 --> 00:42:35,480
own for your own framework or your

766
00:42:35,480 --> 00:42:37,099
custom web application like Ruby on

767
00:42:37,099 --> 00:42:41,150
Rails and then this implementation works

768
00:42:41,150 --> 00:42:42,950
for limited encodings so limited

769
00:42:42,950 --> 00:42:45,079
alphabet we are hoping you can

770
00:42:45,079 --> 00:42:47,259
contribute with different encodings

771
00:42:47,259 --> 00:42:50,859
because otherwise it's not very usable

772
00:42:50,859 --> 00:42:53,990
so what yeah if we only support ASCII

773
00:42:53,990 --> 00:42:56,029
and utf-8 maybe some languages will not

774
00:42:56,029 --> 00:43:00,099
work well and then if you want to also

775
00:43:00,099 --> 00:43:02,750
go on our github one other thing that we

776
00:43:02,750 --> 00:43:05,809
want is to support client-side

777
00:43:05,809 --> 00:43:09,859
frameworks like react so that this

778
00:43:09,859 --> 00:43:11,750
protection can also apply on Jason

779
00:43:11,750 --> 00:43:15,589
restful endpoints I would be good okay

780
00:43:15,589 --> 00:43:19,759
so the key takeaways is HTTP plus gzip

781
00:43:19,759 --> 00:43:23,630
is still broken even if you use TLS 1.3

782
00:43:23,630 --> 00:43:27,440
this is still attackable we showed you

783
00:43:27,440 --> 00:43:29,900
also some examples of interesting

784
00:43:29,900 --> 00:43:33,170
interesting as aerial cases where

785
00:43:33,170 --> 00:43:35,630
there's the reflection is not very clear

786
00:43:35,630 --> 00:43:37,730
for example this one adversary

787
00:43:37,730 --> 00:43:40,549
controlled email body and one victim

788
00:43:40,549 --> 00:43:42,980
controlled email body and the adversary

789
00:43:42,980 --> 00:43:44,359
can use that as a reflection which is

790
00:43:44,359 --> 00:43:50,240
quite counterintuitive and then CTX is a

791
00:43:50,240 --> 00:43:52,460
solution to this so we invite you to

792
00:43:52,460 --> 00:43:54,799
start using it start reporting bugs and

793
00:43:54,799 --> 00:43:57,440
show us if it's good or not tell us what

794
00:43:57,440 --> 00:44:00,589
you think so that's it from us and we'll

795
00:44:00,589 --> 00:44:03,759
be happy to take your questions

796
00:44:05,030 --> 00:44:12,389
[Applause]

797
00:44:15,470 --> 00:44:16,869
[Music]

798
00:44:16,869 --> 00:44:18,710
are there any questions

799
00:44:18,710 --> 00:44:34,280
oh yeah so the the HTTP headers are

800
00:44:34,280 --> 00:44:36,619
typically not compressed if you use

801
00:44:36,619 --> 00:44:39,530
lowest version of TLS the request is not

802
00:44:39,530 --> 00:44:41,480
compressed at all and the response is

803
00:44:41,480 --> 00:44:44,210
not compressed and then the body of the

804
00:44:44,210 --> 00:44:46,520
HTTP is compressed but that that doesn't

805
00:44:46,520 --> 00:44:48,049
quote the header the header defines a

806
00:44:48,049 --> 00:44:49,880
compression method so you're safe on

807
00:44:49,880 --> 00:44:55,210
that any other questions before lunch

808
00:45:03,460 --> 00:45:05,780
okay so let's go back to the email case

809
00:45:05,780 --> 00:45:08,589
that's a good question

810
00:45:10,569 --> 00:45:13,640
so say here the problem we saw with

811
00:45:13,640 --> 00:45:17,059
breach is that if the adversary

812
00:45:17,059 --> 00:45:19,520
extending the victim emails say that

813
00:45:19,520 --> 00:45:21,200
immediately is the adversary here and

814
00:45:21,200 --> 00:45:23,210
he's sending me some emails and these

815
00:45:23,210 --> 00:45:26,390
are specially crafted reflections and he

816
00:45:26,390 --> 00:45:28,700
was feel whatever ever has sent me on

817
00:45:28,700 --> 00:45:31,520
this other email that's that kind of the

818
00:45:31,520 --> 00:45:33,349
attack model there if the mid-race is

819
00:45:33,349 --> 00:45:36,650
able to find out one word from this

820
00:45:36,650 --> 00:45:39,589
email this will compress together so if

821
00:45:39,589 --> 00:45:40,910
we use the same permutation for these

822
00:45:40,910 --> 00:45:42,980
two then these will still compress

823
00:45:42,980 --> 00:45:45,109
together that's kind of the point but if

824
00:45:45,109 --> 00:45:46,609
we use a different permutation here and

825
00:45:46,609 --> 00:45:48,200
a different permutation there then these

826
00:45:48,200 --> 00:45:49,910
will more compress together but the

827
00:45:49,910 --> 00:45:51,680
emails from the same origin will

828
00:45:51,680 --> 00:45:52,970
compress together to achieve better

829
00:45:52,970 --> 00:45:54,619
performance so that's the reason we are

830
00:45:54,619 --> 00:46:02,660
we have to have separate origins okay

831
00:46:02,660 --> 00:46:04,930
any other

832
00:46:07,000 --> 00:46:09,540
all right thank you very much

833
00:46:09,540 --> 00:46:13,790
[Applause]

