1
00:00:00,000 --> 00:00:02,399
so hello everyone my name is anezka

2
00:00:02,399 --> 00:00:05,040
touch and I'm going to present our work

3
00:00:05,040 --> 00:00:08,039
in which we looked at a new security

4
00:00:08,039 --> 00:00:10,889
feature in LLVM client which is called

5
00:00:10,889 --> 00:00:14,849
safe stack it's quite recently added to

6
00:00:14,849 --> 00:00:17,640
the compiler so let me give an outline

7
00:00:17,640 --> 00:00:19,920
of the presentation first so I will

8
00:00:19,920 --> 00:00:22,289
first explain like what safes like this

9
00:00:22,289 --> 00:00:25,170
we will look at what it is good for look

10
00:00:25,170 --> 00:00:27,240
at it a little bit added internals and

11
00:00:27,240 --> 00:00:31,859
then we will look at its weaknesses so

12
00:00:31,859 --> 00:00:35,520
we will look at neglected pointers which

13
00:00:35,520 --> 00:00:37,530
are implementation issues then we will

14
00:00:37,530 --> 00:00:39,690
look at more fundamental problems like

15
00:00:39,690 --> 00:00:41,520
that spraying and allocation Oracle's

16
00:00:41,520 --> 00:00:46,079
and then we will conclude the talk so

17
00:00:46,079 --> 00:00:49,079
safes like what is it as I said some new

18
00:00:49,079 --> 00:00:51,360
security feature in the compiler in the

19
00:00:51,360 --> 00:00:54,690
LLVM tool chain and it's essentially

20
00:00:54,690 --> 00:00:58,859
again to prevent controller hijacks on

21
00:00:58,859 --> 00:01:03,049
the stack and originally this has been

22
00:01:03,049 --> 00:01:07,560
proposed by researchers Kuznetsov and

23
00:01:07,560 --> 00:01:10,500
and others and code code pointer

24
00:01:10,500 --> 00:01:13,200
integrity paper in this paper they try

25
00:01:13,200 --> 00:01:15,990
to hide and protect all the code

26
00:01:15,990 --> 00:01:19,290
pointers because attackers exploit the

27
00:01:19,290 --> 00:01:21,090
code pointers they try to overwrite them

28
00:01:21,090 --> 00:01:24,150
and then get control of the program to

29
00:01:24,150 --> 00:01:27,390
do malicious stuff for example do Rob

30
00:01:27,390 --> 00:01:30,240
execute a rope chain and in the end take

31
00:01:30,240 --> 00:01:32,340
control or compromise the machine or the

32
00:01:32,340 --> 00:01:38,909
computer yeah so and it has also been

33
00:01:38,909 --> 00:01:42,720
proposed for integrating it into TTC I

34
00:01:42,720 --> 00:01:50,520
think some previous D developers are

35
00:01:50,520 --> 00:01:52,710
thinking of providing the safe stack

36
00:01:52,710 --> 00:01:56,909
feature out of the box so this means

37
00:01:56,909 --> 00:02:00,000
that if you install a freebsd operating

38
00:02:00,000 --> 00:02:02,610
system probably you will have the safe

39
00:02:02,610 --> 00:02:07,020
side teacher on in its default

40
00:02:07,020 --> 00:02:09,490
configuration so

41
00:02:09,490 --> 00:02:15,130
actually yeah quite I think that people

42
00:02:15,130 --> 00:02:16,930
look at it right now

43
00:02:16,930 --> 00:02:19,690
and we thought we also wanted to look at

44
00:02:19,690 --> 00:02:22,750
it as my but from from its security

45
00:02:22,750 --> 00:02:28,240
perspective how safe is the safe side so

46
00:02:28,240 --> 00:02:34,000
what is safes like doing so let's say we

47
00:02:34,000 --> 00:02:36,450
have so let me show this with an example

48
00:02:36,450 --> 00:02:41,110
so here we have a in a program where

49
00:02:41,110 --> 00:02:45,130
safe sex is not applied to say the stack

50
00:02:45,130 --> 00:02:48,540
contains the program execution context

51
00:02:48,540 --> 00:02:53,620
of the process and it has code pointers

52
00:02:53,620 --> 00:02:55,090
to return addresses it has local

53
00:02:55,090 --> 00:03:00,690
variables pushed by the functions and

54
00:03:00,690 --> 00:03:04,570
what saves like does is when you apply a

55
00:03:04,570 --> 00:03:08,740
stack it separates values on the stack

56
00:03:08,740 --> 00:03:11,590
so it adds an additional second

57
00:03:11,590 --> 00:03:14,020
alternative stack which contains edges

58
00:03:14,020 --> 00:03:19,380
taken which they define as a dangerous

59
00:03:19,380 --> 00:03:25,420
data data that can potentially cause

60
00:03:25,420 --> 00:03:28,420
problems like Oh over writing the code

61
00:03:28,420 --> 00:03:29,650
pointers on the stack like the return

62
00:03:29,650 --> 00:03:33,600
address I will show this with an example

63
00:03:34,290 --> 00:03:37,360
so what is it good again so let's say we

64
00:03:37,360 --> 00:03:39,280
have a memory corruption in the program

65
00:03:39,280 --> 00:03:43,870
and buffer a can be overflowing with

66
00:03:43,870 --> 00:03:46,570
data what the tacker can do is if it

67
00:03:46,570 --> 00:03:49,450
overflows the data and buffer a it can

68
00:03:49,450 --> 00:03:53,170
override the return address and this is

69
00:03:53,170 --> 00:03:54,670
very valuable for an attacker because

70
00:03:54,670 --> 00:03:58,750
here it can initiate the control flow

71
00:03:58,750 --> 00:04:04,210
hijack of the program but when you apply

72
00:04:04,210 --> 00:04:08,680
a flag the vulnerability will happen on

73
00:04:08,680 --> 00:04:13,959
the unsafe stack and attacker cannot

74
00:04:13,959 --> 00:04:16,089
override the sensitive information to

75
00:04:16,089 --> 00:04:18,160
sense the data the return address called

76
00:04:18,160 --> 00:04:20,738
pointer on the stack

77
00:04:20,738 --> 00:04:23,229
so it's good again it protects return

78
00:04:23,229 --> 00:04:26,500
addresses so good it is good against

79
00:04:26,500 --> 00:04:28,509
stack buffer overflows that try to

80
00:04:28,509 --> 00:04:32,220
override the return address on the stack

81
00:04:32,220 --> 00:04:35,590
but it is also good against some other

82
00:04:35,590 --> 00:04:39,910
problem so let's say we have a variable

83
00:04:39,910 --> 00:04:44,860
in the heap it has a pointer that is a

84
00:04:44,860 --> 00:04:47,380
pointer to the buffer to buffer

85
00:04:47,380 --> 00:04:51,130
a on the stack so if the attacker has

86
00:04:51,130 --> 00:04:53,770
some information disclosure capability

87
00:04:53,770 --> 00:04:56,470
it will be able to leak the location of

88
00:04:56,470 --> 00:05:02,550
the stack and continue its exploitation

89
00:05:02,550 --> 00:05:04,750
so the thing is the stack should

90
00:05:04,750 --> 00:05:06,729
actually be hidden from the tackle and

91
00:05:06,729 --> 00:05:11,169
if the attacker can't find the stack it

92
00:05:11,169 --> 00:05:15,550
can it also needs adversary and some

93
00:05:15,550 --> 00:05:17,440
bright capabilities to then overwrite

94
00:05:17,440 --> 00:05:21,550
the values on the stack so information

95
00:05:21,550 --> 00:05:24,610
disclosures that's this one so the thing

96
00:05:24,610 --> 00:05:28,570
is but for a will then be moved to the

97
00:05:28,570 --> 00:05:31,240
unsafe stack in your place a stack so

98
00:05:31,240 --> 00:05:33,639
the buffer a pointer will not be

99
00:05:33,639 --> 00:05:35,409
pointing to the stack that contains

100
00:05:35,409 --> 00:05:37,360
return addresses but it will point to

101
00:05:37,360 --> 00:05:40,330
the unsafe stack so it also stops

102
00:05:40,330 --> 00:05:45,479
actually the stack location disclosure

103
00:05:46,530 --> 00:05:48,940
so programs also leaking the stack

104
00:05:48,940 --> 00:05:52,719
location so how does it look in the

105
00:05:52,719 --> 00:05:56,289
process memory when you apply safe stack

106
00:05:56,289 --> 00:05:58,270
it separates the values in the unsafe

107
00:05:58,270 --> 00:06:01,530
stack and puts the on say stack in a map

108
00:06:01,530 --> 00:06:09,490
area so nothing interesting the

109
00:06:09,490 --> 00:06:11,169
interesting part is as I mentioned

110
00:06:11,169 --> 00:06:12,639
already if there's a pointer to the

111
00:06:12,639 --> 00:06:14,800
stack this pointer will be pointing to

112
00:06:14,800 --> 00:06:16,719
the unsafe stacks or the safe stack will

113
00:06:16,719 --> 00:06:20,949
be protected from having pointers to so

114
00:06:20,949 --> 00:06:23,289
pointers to save stack may not appear in

115
00:06:23,289 --> 00:06:25,270
reachable memory to keep the safe stack

116
00:06:25,270 --> 00:06:27,130
hidden so we want to try you want to

117
00:06:27,130 --> 00:06:29,500
hide the safe stack from the attacker

118
00:06:29,500 --> 00:06:33,530
and with reachable memory I mean

119
00:06:33,530 --> 00:06:37,620
like so if the attacker starts well has

120
00:06:37,620 --> 00:06:39,120
involved information disclosure

121
00:06:39,120 --> 00:06:43,370
capabilities and it starts leaking data

122
00:06:43,370 --> 00:06:50,520
it can leave the data region and it can

123
00:06:50,520 --> 00:06:52,590
follow pointers to other regions and

124
00:06:52,590 --> 00:06:55,020
click try to lick as many as possible in

125
00:06:55,020 --> 00:06:57,660
the memory space so that's the reach of

126
00:06:57,660 --> 00:07:01,080
reachable memory and preferably there

127
00:07:01,080 --> 00:07:07,140
should be no pointer to the safe side so

128
00:07:07,140 --> 00:07:08,580
let's also look a little bit at the

129
00:07:08,580 --> 00:07:13,080
internals here is an example main

130
00:07:13,080 --> 00:07:17,580
function with a buffer this buffer is

131
00:07:17,580 --> 00:07:22,140
being provided to string copy and this

132
00:07:22,140 --> 00:07:24,000
is not really a safe program an attacker

133
00:07:24,000 --> 00:07:27,840
could provide any length in the argument

134
00:07:27,840 --> 00:07:32,790
ok so at 0 should be a 1 so if the

135
00:07:32,790 --> 00:07:37,770
tanker provides a very long argument it

136
00:07:37,770 --> 00:07:39,570
will overflow the return address on the

137
00:07:39,570 --> 00:07:47,940
stack and so that's the problem here how

138
00:07:47,940 --> 00:07:52,110
does it look in the assembly code second

139
00:07:52,110 --> 00:07:56,750
block shows the some assembly code where

140
00:07:56,750 --> 00:08:00,780
safe sex multiply this piece of assembly

141
00:08:00,780 --> 00:08:03,930
up allocates some space on the normal

142
00:08:03,930 --> 00:08:06,600
stack for the buffer so the buffer is

143
00:08:06,600 --> 00:08:10,910
located on this normal stack and when it

144
00:08:10,910 --> 00:08:14,130
calls string copied Pro it's sent it

145
00:08:14,130 --> 00:08:17,850
gives an address it provides address of

146
00:08:17,850 --> 00:08:21,180
buffer to string copy and yet it

147
00:08:21,180 --> 00:08:24,060
actually operates on the stack and in

148
00:08:24,060 --> 00:08:28,620
the safe stack example the buffer is

149
00:08:28,620 --> 00:08:31,740
located on a safe stack the are safe

150
00:08:31,740 --> 00:08:37,200
stack is maintained through a pointer in

151
00:08:37,200 --> 00:08:41,030
the thread-local storage

152
00:08:41,289 --> 00:08:43,240
Jesus through the FS register that

153
00:08:43,240 --> 00:08:45,760
register is a special register that

154
00:08:45,760 --> 00:08:49,540
contains the base of the thread control

155
00:08:49,540 --> 00:08:52,900
block and so it takes an offset from

156
00:08:52,900 --> 00:08:56,830
this FS register and get the pointer

157
00:08:56,830 --> 00:09:01,930
from the local storage end and then

158
00:09:01,930 --> 00:09:08,710
stores the buffer on this a stack so it

159
00:09:08,710 --> 00:09:10,870
doesn't use the RSP pointer budgets use

160
00:09:10,870 --> 00:09:13,900
FS register and takes offset to get the

161
00:09:13,900 --> 00:09:22,510
other side pointed so instead of using

162
00:09:22,510 --> 00:09:25,120
the RSP pointer and getting added to the

163
00:09:25,120 --> 00:09:28,360
stack it gets the it gets an address to

164
00:09:28,360 --> 00:09:31,750
the unsafe stack so in the third block

165
00:09:31,750 --> 00:09:34,810
in the safe side example it retrieves

166
00:09:34,810 --> 00:09:40,630
the address from a reading value in our

167
00:09:40,630 --> 00:09:44,020
50 and in the normal example it uses RSP

168
00:09:44,020 --> 00:09:49,750
okay so since that can be enabled by

169
00:09:49,750 --> 00:09:52,510
setting the safe stack sanitized flag

170
00:09:52,510 --> 00:09:57,880
and essentially it moves the others

171
00:09:57,880 --> 00:10:00,250
taken objects to the alternative stack

172
00:10:00,250 --> 00:10:03,730
which prevents the end leaking the stack

173
00:10:03,730 --> 00:10:06,610
location location of home safe sex and

174
00:10:06,610 --> 00:10:10,930
it relies on a SLR our question is how

175
00:10:10,930 --> 00:10:14,170
safe is the safe sex actually and for

176
00:10:14,170 --> 00:10:16,360
this we look at these two things so can

177
00:10:16,360 --> 00:10:21,040
we still leak the location of the of the

178
00:10:21,040 --> 00:10:25,000
sales tax and because it's relies on SLR

179
00:10:25,000 --> 00:10:31,630
can we can this reline so we will look

180
00:10:31,630 --> 00:10:36,370
at three problems one is that there are

181
00:10:36,370 --> 00:10:39,460
still pointers actually in the program

182
00:10:39,460 --> 00:10:42,700
we'll go over them and then two more

183
00:10:42,700 --> 00:10:44,290
fundamental problems like thread

184
00:10:44,290 --> 00:10:47,440
spraying and allocation Oracle's let's

185
00:10:47,440 --> 00:10:49,750
start with the neglected points but

186
00:10:49,750 --> 00:10:52,440
before we start

187
00:10:53,279 --> 00:10:56,589
we are assuming that the program has a

188
00:10:56,589 --> 00:10:58,600
memory corruption and that this memory

189
00:10:58,600 --> 00:11:00,430
corruption enables an attacker to have

190
00:11:00,430 --> 00:11:06,070
an absolutely right primitive which with

191
00:11:06,070 --> 00:11:08,010
which the attacker can leak the heat and

192
00:11:08,010 --> 00:11:11,740
module data so it can which can read out

193
00:11:11,740 --> 00:11:15,100
the data but it doesn't know where this

194
00:11:15,100 --> 00:11:19,810
stack is and the goal is to find locate

195
00:11:19,810 --> 00:11:26,710
the safe stack so cystic ensures there

196
00:11:26,710 --> 00:11:32,290
are no pointers to the stack so what we

197
00:11:32,290 --> 00:11:36,660
did we analyzed some programs with a

198
00:11:36,660 --> 00:11:44,800
Python script and use gdb we walked the

199
00:11:44,800 --> 00:11:46,660
whole memory space and then just looked

200
00:11:46,660 --> 00:11:50,350
for pointers that would point to the

201
00:11:50,350 --> 00:11:52,960
safe stack region so we collected the

202
00:11:52,960 --> 00:11:55,420
spec locations and then just went over

203
00:11:55,420 --> 00:12:00,070
the memory and then collected addresses

204
00:12:00,070 --> 00:12:02,589
that would point to the collected stack

205
00:12:02,589 --> 00:12:04,510
regions and then we manually verified

206
00:12:04,510 --> 00:12:11,190
all the pointers so we found pointers in

207
00:12:11,190 --> 00:12:14,110
a we found pointers and we categorize

208
00:12:14,110 --> 00:12:15,970
them in three groups like we found

209
00:12:15,970 --> 00:12:18,160
points in the heap we found pointers in

210
00:12:18,160 --> 00:12:20,500
libraries and something very interesting

211
00:12:20,500 --> 00:12:25,510
is other thread ID mmm

212
00:12:25,510 --> 00:12:28,839
we'll look at that so what we found in a

213
00:12:28,839 --> 00:12:33,390
heap we found some thread management

214
00:12:33,390 --> 00:12:36,880
related structure which is called

215
00:12:36,880 --> 00:12:41,370
dynamic thread vector this contains

216
00:12:41,370 --> 00:12:46,360
pointers to TLS blocks so the

217
00:12:46,360 --> 00:12:48,700
thread-local storage blocks and get a

218
00:12:48,700 --> 00:12:53,650
thread-local storage corresponds to a

219
00:12:53,650 --> 00:13:00,579
module library and this module has its

220
00:13:00,579 --> 00:13:02,190
own

221
00:13:02,190 --> 00:13:05,160
specific values which it stores in its

222
00:13:05,160 --> 00:13:09,000
own thread-local storage block libraries

223
00:13:09,000 --> 00:13:11,040
and modules that are loaded with the

224
00:13:11,040 --> 00:13:13,980
program at at the load time of the

225
00:13:13,980 --> 00:13:17,550
program create static TLS blocks and

226
00:13:17,550 --> 00:13:19,590
libraries that are loaded later during

227
00:13:19,590 --> 00:13:23,750
runtime they create dynamic TLS blocks

228
00:13:23,750 --> 00:13:28,560
okay so in this dynamic thread vector

229
00:13:28,560 --> 00:13:31,620
there are pointers that point to the SEC

230
00:13:31,620 --> 00:13:39,120
but how so the thread control block is

231
00:13:39,120 --> 00:13:43,010
located on the stack and the static TLS

232
00:13:43,010 --> 00:13:45,960
thread lock slash blocks are adjacent to

233
00:13:45,960 --> 00:13:49,280
this TCB to this thread control block

234
00:13:49,280 --> 00:13:53,820
and DTV the the dynamic set vector

235
00:13:53,820 --> 00:13:57,270
points to the static TLS block so in the

236
00:13:57,270 --> 00:14:00,450
end it also points to the stack so you

237
00:14:00,450 --> 00:14:02,820
have pointers in the heap that point to

238
00:14:02,820 --> 00:14:10,950
the stack for if you would like to know

239
00:14:10,950 --> 00:14:13,500
more about the structure so here it's

240
00:14:13,500 --> 00:14:15,300
all about the pointers but if you like

241
00:14:15,300 --> 00:14:17,010
to know more about pointers you can

242
00:14:17,010 --> 00:14:19,520
follow this link to read more about

243
00:14:19,520 --> 00:14:22,350
thread management and TLS blocks and TCP

244
00:14:22,350 --> 00:14:28,470
box so there are also pointers in

245
00:14:28,470 --> 00:14:32,790
libraries to very interesting ones that

246
00:14:32,790 --> 00:14:37,650
could give you all spec locations are

247
00:14:37,650 --> 00:14:40,160
the stack used and the stack user

248
00:14:40,160 --> 00:14:42,900
variables in the P thread library so the

249
00:14:42,900 --> 00:14:45,450
P set library uses these two variables

250
00:14:45,450 --> 00:14:50,310
to do its thread management spec used so

251
00:14:50,310 --> 00:14:52,400
these two variables are linked lists

252
00:14:52,400 --> 00:14:55,980
that point to the TCD which are for

253
00:14:55,980 --> 00:14:59,040
secondary stack so for secondary stress

254
00:14:59,040 --> 00:15:02,460
I will take a lot of secondary thread so

255
00:15:02,460 --> 00:15:04,260
we have a main thread that is created by

256
00:15:04,260 --> 00:15:06,810
the kernel but program when the program

257
00:15:06,810 --> 00:15:08,760
starts you have one stack that is

258
00:15:08,760 --> 00:15:11,220
created by the kernel that's the main

259
00:15:11,220 --> 00:15:12,900
stack

260
00:15:12,900 --> 00:15:15,450
and the threats that are created

261
00:15:15,450 --> 00:15:17,160
afterwards during runtime those are the

262
00:15:17,160 --> 00:15:19,680
secondary threat and stacked used points

263
00:15:19,680 --> 00:15:24,510
to secondary to secondary threats stacks

264
00:15:24,510 --> 00:15:26,910
and statues are points to sector to the

265
00:15:26,910 --> 00:15:31,230
main threat and actually they point to

266
00:15:31,230 --> 00:15:34,200
the TCB and as I said the TCB's on stack

267
00:15:34,200 --> 00:15:36,630
but for me that the TCP is not on the

268
00:15:36,630 --> 00:15:40,080
stack attend a in the heap so this is

269
00:15:40,080 --> 00:15:43,290
also interesting but if you have the TCB

270
00:15:43,290 --> 00:15:46,140
you can get the stack because the tcp

271
00:15:46,140 --> 00:15:50,430
the thread control block has itself also

272
00:15:50,430 --> 00:15:54,570
pointer to the stack like where the

273
00:15:54,570 --> 00:15:58,279
stack starts and how large the stack is

274
00:15:58,279 --> 00:16:01,320
okay so that's like you used em stack

275
00:16:01,320 --> 00:16:06,870
lizard there are also other pointers for

276
00:16:06,870 --> 00:16:09,360
example Lipsy

277
00:16:09,360 --> 00:16:11,400
there is the program invocation name and

278
00:16:11,400 --> 00:16:14,220
a program implication short name this

279
00:16:14,220 --> 00:16:17,790
just point to the name of the program

280
00:16:17,790 --> 00:16:21,270
but these are located on the main stack

281
00:16:21,270 --> 00:16:24,930
so on the main stack you have that

282
00:16:24,930 --> 00:16:28,380
itself but also before just before the

283
00:16:28,380 --> 00:16:30,660
stack we have its environment rivals and

284
00:16:30,660 --> 00:16:33,690
argument list and there these two

285
00:16:33,690 --> 00:16:37,410
variables point to let GCC as the

286
00:16:37,410 --> 00:16:41,820
variable names they have mister pointers

287
00:16:41,820 --> 00:16:45,120
for point to the argument list also on

288
00:16:45,120 --> 00:16:52,220
the main stack the LD library the loader

289
00:16:52,220 --> 00:16:58,200
also has some pointers as the main say

290
00:16:58,200 --> 00:17:00,060
environment environment point to the

291
00:17:00,060 --> 00:17:02,520
environment list the LRV points the

292
00:17:02,520 --> 00:17:04,140
argument list and leave the stack end

293
00:17:04,140 --> 00:17:06,959
points to start location of the main

294
00:17:06,959 --> 00:17:10,939
stack so where the stack starts growing

295
00:17:10,939 --> 00:17:17,130
an RT LD global arrow structure a very

296
00:17:17,130 --> 00:17:19,650
large structure but also has some

297
00:17:19,650 --> 00:17:21,829
pointers to environment Bible

298
00:17:21,829 --> 00:17:24,440
so there are pointers

299
00:17:24,440 --> 00:17:28,850
yeah it can be six but another

300
00:17:28,850 --> 00:17:33,920
interesting one is a log n so Alec and

301
00:17:33,920 --> 00:17:40,070
is used to in the memory management so

302
00:17:40,070 --> 00:17:42,860
when an application calls Mal'akh it

303
00:17:42,860 --> 00:17:47,510
used a log end to to see where the last

304
00:17:47,510 --> 00:17:50,360
allocation was and then it allocates

305
00:17:50,360 --> 00:17:54,500
more at that location but if the

306
00:17:54,500 --> 00:17:56,990
application overloads malloc like Chrome

307
00:17:56,990 --> 00:18:00,440
and Firefox does this a lot and becomes

308
00:18:00,440 --> 00:18:09,350
like a stale pointer and and this brings

309
00:18:09,350 --> 00:18:12,980
us back to the TCD

310
00:18:12,980 --> 00:18:14,360
and the dynamic set vector that is

311
00:18:14,360 --> 00:18:17,090
allocated for the main main thread these

312
00:18:17,090 --> 00:18:19,250
two are allocated in the heap these are

313
00:18:19,250 --> 00:18:21,590
the first two red structures remains

314
00:18:21,590 --> 00:18:24,110
that these are in the heap and a look

315
00:18:24,110 --> 00:18:26,350
and points the region that contains

316
00:18:26,350 --> 00:18:28,670
these two structures or the dynamics at

317
00:18:28,670 --> 00:18:33,020
sector and the TCD block of the main

318
00:18:33,020 --> 00:18:37,010
thread so it's a still pointer that's

319
00:18:37,010 --> 00:18:39,620
point still to the region that has some

320
00:18:39,620 --> 00:18:42,320
interesting structures so an attacker

321
00:18:42,320 --> 00:18:48,290
could get this pointer another

322
00:18:48,290 --> 00:18:51,910
interesting one is the thread IDs

323
00:18:51,910 --> 00:18:57,560
pthread api so the API for trading

324
00:18:57,560 --> 00:19:00,860
threads and managing threads use a

325
00:19:00,860 --> 00:19:06,680
thread ID pthread key type but this type

326
00:19:06,680 --> 00:19:10,930
is not just some that some some number

327
00:19:10,930 --> 00:19:13,640
indicates the NS number of thread but

328
00:19:13,640 --> 00:19:20,170
it's the address of the thread tgd blog

329
00:19:20,170 --> 00:19:26,240
but tcp is on the stack so and so if so

330
00:19:26,240 --> 00:19:27,660
if the plication

331
00:19:27,660 --> 00:19:31,020
does some threat management and it's

332
00:19:31,020 --> 00:19:31,770
pointers

333
00:19:31,770 --> 00:19:35,550
I mean stores the threat IDs in its data

334
00:19:35,550 --> 00:19:39,140
region of the heap it is storing

335
00:19:39,140 --> 00:19:42,480
pointers to the stack actually this was

336
00:19:42,480 --> 00:19:48,170
very interesting also libraries can yeah

337
00:19:48,170 --> 00:19:51,740
here an example like let XML to that

338
00:19:51,740 --> 00:19:55,560
library stores the stores a pointer to

339
00:19:55,560 --> 00:19:59,010
the main threat Italy like that's not

340
00:19:59,010 --> 00:20:05,910
the purpose but that's what happens okay

341
00:20:05,910 --> 00:20:09,180
so let's assume these implementation

342
00:20:09,180 --> 00:20:10,890
issues are fixed and there are no

343
00:20:10,890 --> 00:20:16,740
pointers pointing to the stack then

344
00:20:16,740 --> 00:20:18,570
what'm attacker could do is try to

345
00:20:18,570 --> 00:20:22,500
randomly hit the safe stack but if the

346
00:20:22,500 --> 00:20:24,870
address space is so large that it's

347
00:20:24,870 --> 00:20:28,140
entropy is very high so the chance that

348
00:20:28,140 --> 00:20:32,340
you hit this tag is quite low so what

349
00:20:32,340 --> 00:20:36,510
could he do to increase his chance to

350
00:20:36,510 --> 00:20:40,710
hit the safe stack well reduce the

351
00:20:40,710 --> 00:20:44,400
entropy through threat spraying but

352
00:20:44,400 --> 00:20:46,800
let's first go over what this entropy

353
00:20:46,800 --> 00:20:48,590
actually

354
00:20:48,590 --> 00:20:51,390
entropy is degree of randomness of

355
00:20:51,390 --> 00:20:55,170
something in in the memory that is given

356
00:20:55,170 --> 00:20:59,550
in bits so let's start with a simple

357
00:20:59,550 --> 00:21:04,110
example in which we where we have a

358
00:21:04,110 --> 00:21:06,360
three bit address space and then we will

359
00:21:06,360 --> 00:21:11,280
look at 64-bit address space so this

360
00:21:11,280 --> 00:21:12,930
pretty big edge state has eight blocks

361
00:21:12,930 --> 00:21:19,500
of eight blocks of one byte each and in

362
00:21:19,500 --> 00:21:22,470
the figure on the right side of the

363
00:21:22,470 --> 00:21:27,810
slide we are trying to hide to by this

364
00:21:27,810 --> 00:21:32,870
memory region since it is occupying

365
00:21:32,870 --> 00:21:35,430
consuming one bit of the three that

366
00:21:35,430 --> 00:21:38,120
address space

367
00:21:38,280 --> 00:21:40,620
we say this memory region has an entropy

368
00:21:40,620 --> 00:21:45,660
of two bits it's consuming one bit from

369
00:21:45,660 --> 00:21:48,360
this entropy in bits you can understand

370
00:21:48,360 --> 00:21:52,050
that the head chance is 1/2 to the power

371
00:21:52,050 --> 00:21:55,620
of 2 which the entropy which is 25% so

372
00:21:55,620 --> 00:21:58,920
if you try to randomly hit the safe side

373
00:21:58,920 --> 00:22:01,470
or all this memory region then your

374
00:22:01,470 --> 00:22:05,460
chance of hitting it is 25% and if you

375
00:22:05,460 --> 00:22:07,800
are if you have a probe capability and

376
00:22:07,800 --> 00:22:09,330
you're trying to probe for it you would

377
00:22:09,330 --> 00:22:14,400
need 4 probes in the worst case okay so

378
00:22:14,400 --> 00:22:16,830
if the memory region would be 4 bytes

379
00:22:16,830 --> 00:22:21,090
would occupy all of the other states or

380
00:22:21,090 --> 00:22:24,800
this 3 bit address states it will occupy

381
00:22:24,800 --> 00:22:29,160
2 bits of the address space and entropy

382
00:22:29,160 --> 00:22:32,190
would be one bit which means that a

383
00:22:32,190 --> 00:22:36,300
chance either 50% or the worst-case

384
00:22:36,300 --> 00:22:42,030
probing number of probes is 2 okay so

385
00:22:42,030 --> 00:22:45,360
let's now look at the 64-bit address

386
00:22:45,360 --> 00:22:50,040
space if we try to hide one byte the

387
00:22:50,040 --> 00:22:54,770
entropy of this one bite is just 64 bits

388
00:22:54,770 --> 00:22:59,400
with Linux in the user space it uses 47

389
00:22:59,400 --> 00:23:02,790
bits with addresses so entropy

390
00:23:02,790 --> 00:23:08,820
reducibility so 47 bits we try to hide

391
00:23:08,820 --> 00:23:10,350
that one byte in the Linux head of state

392
00:23:10,350 --> 00:23:16,740
but you cannot just allocate one byte

393
00:23:16,740 --> 00:23:19,890
and address space because memory

394
00:23:19,890 --> 00:23:22,470
allocation happens on a page granularity

395
00:23:22,470 --> 00:23:28,320
which is 4096 bytes so you will be

396
00:23:28,320 --> 00:23:31,200
allocating toothpowder bytes so it will

397
00:23:31,200 --> 00:23:34,290
consume 12 bits of the address space so

398
00:23:34,290 --> 00:23:37,170
first entropy was 47 bits for one bite

399
00:23:37,170 --> 00:23:41,250
for 4096 bytes this entropy reduced to

400
00:23:41,250 --> 00:23:46,179
35 bits okay

401
00:23:46,179 --> 00:23:51,309
of and Linux the default text size is 8

402
00:23:51,309 --> 00:23:52,119
megabyte

403
00:23:52,119 --> 00:23:56,559
this consumes 2 to the power 23 bytes of

404
00:23:56,559 --> 00:24:00,610
memory and which means entropy for one

405
00:24:00,610 --> 00:24:14,669
safe stack is for 24 bits in 64 30 so I

406
00:24:14,669 --> 00:24:16,960
explained this to get to the thread

407
00:24:16,960 --> 00:24:19,590
spraying contact because thread spraying

408
00:24:19,590 --> 00:24:24,369
is about legitimately trying to form as

409
00:24:24,369 --> 00:24:26,169
many threads as possible in the program

410
00:24:26,169 --> 00:24:30,669
and to reduce the entropy so we want to

411
00:24:30,669 --> 00:24:33,070
have to entropy as low as possible what

412
00:24:33,070 --> 00:24:35,830
can we do so we can spawn another set if

413
00:24:35,830 --> 00:24:37,539
we double the size of the stacks in the

414
00:24:37,539 --> 00:24:41,619
memory the entropy reduces by one bit if

415
00:24:41,619 --> 00:24:44,169
we double size again it reduce it

416
00:24:44,169 --> 00:24:46,119
reduces the entropy of the sex by 1 bit

417
00:24:46,119 --> 00:24:50,289
again so if you can spawn like 128

418
00:24:50,289 --> 00:24:55,570
thousand threads the entropy so finding

419
00:24:55,570 --> 00:25:00,309
a stack becomes the entropy for sex

420
00:25:00,309 --> 00:25:05,019
becomes 7 bits which means that you

421
00:25:05,019 --> 00:25:08,740
would need so the worst case the number

422
00:25:08,740 --> 00:25:12,690
of probes would be 128 probes the

423
00:25:12,690 --> 00:25:15,639
interesting thing is that in Linux a map

424
00:25:15,639 --> 00:25:22,869
has an entropy of 40 bits which causes

425
00:25:22,869 --> 00:25:26,769
to drop the entropy for the 120,000

426
00:25:26,769 --> 00:25:28,720
threads and the Stags

427
00:25:28,720 --> 00:25:37,659
to become their 0 bits so the idea is to

428
00:25:37,659 --> 00:25:39,749
spawn lots of threads and just reduce

429
00:25:39,749 --> 00:25:42,240
adentro can increase the heat change

430
00:25:42,240 --> 00:25:44,590
because yeah we don't have pointers and

431
00:25:44,590 --> 00:25:49,119
we want to find the safe stack so we

432
00:25:49,119 --> 00:25:49,809
instead

433
00:25:49,809 --> 00:25:55,509
several applications so I will go over

434
00:25:55,509 --> 00:26:00,999
Firefox a MySQL how we could spawn many

435
00:26:00,999 --> 00:26:07,139
threats and spawn stacks so in Firefox

436
00:26:07,139 --> 00:26:10,389
when you spawn when you start a

437
00:26:10,389 --> 00:26:12,940
dedicated web worker in JavaScript it

438
00:26:12,940 --> 00:26:19,840
creates a new thread but the number of

439
00:26:19,840 --> 00:26:22,119
threads the number of web workers is

440
00:26:22,119 --> 00:26:25,989
limited it is you can just create 20 web

441
00:26:25,989 --> 00:26:30,369
workers per domain name and the web

442
00:26:30,369 --> 00:26:33,070
worker thread spec size is 2 megabytes

443
00:26:33,070 --> 00:26:37,869
and it's entropy of this stack is 19

444
00:26:37,869 --> 00:26:41,049
bits so how did I compute this the Linux

445
00:26:41,049 --> 00:26:44,080
as I mentioned before has an entropy of

446
00:26:44,080 --> 00:26:47,889
40 bits like m map for the stack because

447
00:26:47,889 --> 00:26:49,869
the entropy of 40 bits 2 megabyte

448
00:26:49,869 --> 00:26:53,440
occupies 21 bits and at the state so the

449
00:26:53,440 --> 00:26:57,339
stack has 90 bits of entropy if you are

450
00:26:57,339 --> 00:27:01,210
trying to hit this stack you would need

451
00:27:01,210 --> 00:27:07,529
about 500,000 probes quite a lot

452
00:27:07,799 --> 00:27:12,940
if you spawned 20 thread this number of

453
00:27:12,940 --> 00:27:17,769
probes reduced to 30k 30,000 and entropy

454
00:27:17,769 --> 00:27:23,169
is 15 bit but we can do better we can

455
00:27:23,169 --> 00:27:29,469
load more we can cause the page to have

456
00:27:29,469 --> 00:27:36,669
more we can through iframes you can load

457
00:27:36,669 --> 00:27:41,529
pages from other domains and and there

458
00:27:41,529 --> 00:27:43,359
is no limit on number of iframes in the

459
00:27:43,359 --> 00:27:47,190
page so because you can have unlimited

460
00:27:47,190 --> 00:27:55,470
number of web workers in page um so for

461
00:27:55,470 --> 00:28:00,780
sample if you spawn 16,000 webworkers

462
00:28:00,780 --> 00:28:04,100
you would drop the entropy to five bits

463
00:28:04,100 --> 00:28:07,530
which is quite low and the number of

464
00:28:07,530 --> 00:28:12,510
probes will be 32 probes and worst case

465
00:28:12,510 --> 00:28:17,340
within 32 probes to hit this create a

466
00:28:17,340 --> 00:28:26,490
spec in MySQL a new thread is being

467
00:28:26,490 --> 00:28:29,549
started with every network connection

468
00:28:29,549 --> 00:28:33,510
and the number of connections is 151

469
00:28:33,510 --> 00:28:38,270
that's default the default configuration

470
00:28:38,870 --> 00:28:43,760
the threads of excise is 256 kilobyte

471
00:28:43,760 --> 00:28:47,340
which has an entropy of 22 bits and if

472
00:28:47,340 --> 00:28:50,940
you exhaustion on the connection so if

473
00:28:50,940 --> 00:28:57,630
you start 151 connections to MySQL you

474
00:28:57,630 --> 00:29:02,580
will be having 151 more stacks in the

475
00:29:02,580 --> 00:29:05,240
other space and it's entropy reduced to

476
00:29:05,240 --> 00:29:10,880
15 bits but as we assumed an attacker

477
00:29:10,880 --> 00:29:15,840
has the arteries wide capability and in

478
00:29:15,840 --> 00:29:19,740
MySQL the number of connections is

479
00:29:19,740 --> 00:29:22,169
regulated by a variable max connection

480
00:29:22,169 --> 00:29:25,159
so if the attacker changes this variable

481
00:29:25,159 --> 00:29:28,260
it can create more connections to the

482
00:29:28,260 --> 00:29:33,500
server to mysql and start more thread

483
00:29:33,500 --> 00:29:37,110
but it can also regulate the it can also

484
00:29:37,110 --> 00:29:39,870
modify the stack size because it's also

485
00:29:39,870 --> 00:29:43,190
just in the data region of the MySQL

486
00:29:43,190 --> 00:29:47,640
binary so if an attacker sets the max

487
00:29:47,640 --> 00:29:52,110
connections to 400 4096 connections and

488
00:29:52,110 --> 00:29:56,669
the stack size to 256 megabytes and

489
00:29:56,669 --> 00:30:00,150
exhaust the connections it would reduce

490
00:30:00,150 --> 00:30:05,659
the entropy of the stack to 0 bits

491
00:30:05,990 --> 00:30:10,530
so Linux use the 7s region in the

492
00:30:10,530 --> 00:30:13,049
address space so it would exhaust 7f

493
00:30:13,049 --> 00:30:22,110
memory region and by well by exhausting

494
00:30:22,110 --> 00:30:26,700
this region address so this address

495
00:30:26,700 --> 00:30:31,260
shown on slide 7 f 0 0 0 is a very high

496
00:30:31,260 --> 00:30:36,590
chance of having locating a safe stack

497
00:30:39,650 --> 00:30:43,350
so by spraying lots of threats and

498
00:30:43,350 --> 00:30:45,270
spawning stacks is welcome you weaken

499
00:30:45,270 --> 00:30:49,230
and to chance to hit the safe sack will

500
00:30:49,230 --> 00:30:51,809
be increased but spraying might not

501
00:30:51,809 --> 00:30:53,960
always be possible for example Firefox

502
00:30:53,960 --> 00:30:57,840
we were just lucky that by loading other

503
00:30:57,840 --> 00:31:00,510
pages by I'm loading auto domain you

504
00:31:00,510 --> 00:31:03,150
would be able to start more thread and

505
00:31:03,150 --> 00:31:05,850
in MySQL we could play with some

506
00:31:05,850 --> 00:31:10,530
variables in the data section but for

507
00:31:10,530 --> 00:31:15,169
example nginx you might not be able to

508
00:31:15,169 --> 00:31:18,409
spawn more thread if it's not configured

509
00:31:18,409 --> 00:31:21,870
as having as being multi-threaded for

510
00:31:21,870 --> 00:31:27,409
example for this there's a new approach

511
00:31:27,409 --> 00:31:30,960
you can use allocation Oracle's quite

512
00:31:30,960 --> 00:31:35,820
interested let's see what it is so let's

513
00:31:35,820 --> 00:31:41,580
look at the memory space again so we

514
00:31:41,580 --> 00:31:44,730
want to find the safe stack but there

515
00:31:44,730 --> 00:31:46,679
are no pointers to it as we assumed in

516
00:31:46,679 --> 00:31:52,620
the end we cannot spawn threads so how

517
00:31:52,620 --> 00:31:56,490
can we find the safe stack so

518
00:31:56,490 --> 00:31:58,080
interesting to note is there are holes

519
00:31:58,080 --> 00:32:03,620
in a memory space if we know the size

520
00:32:03,620 --> 00:32:07,260
from the heap to the safe stack we can

521
00:32:07,260 --> 00:32:09,080
infer the location to save that because

522
00:32:09,080 --> 00:32:14,390
we attack her in a threat model knows

523
00:32:14,390 --> 00:32:17,280
the location of data and keep all this

524
00:32:17,280 --> 00:32:18,120
close

525
00:32:18,120 --> 00:32:20,520
so the location of the heap is not where

526
00:32:20,520 --> 00:32:27,470
it ends if we can incur the size we can

527
00:32:27,470 --> 00:32:29,669
size between hip and safe side we can

528
00:32:29,669 --> 00:32:31,919
get to the safe side by just adding the

529
00:32:31,919 --> 00:32:41,130
size to the hip location rating so in

530
00:32:41,130 --> 00:32:45,299
this memory model for the process these

531
00:32:45,299 --> 00:32:49,250
three holes have a minimum and a maximum

532
00:32:49,250 --> 00:32:58,980
size so what the idea is that we will

533
00:32:58,980 --> 00:33:01,919
try to allocate large chunks of memory

534
00:33:01,919 --> 00:33:08,700
and and by doing this repeatedly we will

535
00:33:08,700 --> 00:33:15,299
try to infer the size of the hole so we

536
00:33:15,299 --> 00:33:18,690
will allocate some memory and if it

537
00:33:18,690 --> 00:33:21,750
succeeds we know the hole is probably

538
00:33:21,750 --> 00:33:24,929
larger we will try again we will try a

539
00:33:24,929 --> 00:33:29,010
much larger size if it fails you know

540
00:33:29,010 --> 00:33:32,940
this hole is smaller and we will repeat

541
00:33:32,940 --> 00:33:37,529
this until we find the right size of the

542
00:33:37,529 --> 00:33:40,049
hole and this is done with a binary

543
00:33:40,049 --> 00:33:45,929
search it's quite bad so one primitive

544
00:33:45,929 --> 00:33:48,000
so there are two primitives we define

545
00:33:48,000 --> 00:33:50,000
two primitives one primitive of

546
00:33:50,000 --> 00:33:52,049
allocation Oracle's is the ephemeral

547
00:33:52,049 --> 00:33:56,370
allocation primitive where the allocated

548
00:33:56,370 --> 00:33:57,390
memory is short-lived

549
00:33:57,390 --> 00:34:00,390
that gets allocated but shortly later

550
00:34:00,390 --> 00:34:02,760
get to be allocated and it looks as

551
00:34:02,760 --> 00:34:03,179
follows

552
00:34:03,179 --> 00:34:06,000
so we control the size or for example

553
00:34:06,000 --> 00:34:10,469
malloc function it allocates some memory

554
00:34:10,469 --> 00:34:14,219
the blade it frees this location this

555
00:34:14,219 --> 00:34:18,770
memory and then it replies the results

556
00:34:18,770 --> 00:34:22,310
to the client

557
00:34:24,120 --> 00:34:26,219
strategy is the client sends a request

558
00:34:26,219 --> 00:34:28,860
to the server server allocate some

559
00:34:28,860 --> 00:34:33,480
memory and then the server responds with

560
00:34:33,480 --> 00:34:35,760
the result to the client and the client

561
00:34:35,760 --> 00:34:43,290
can infer what happened at the server so

562
00:34:43,290 --> 00:34:46,530
let's say we induce what we insert the

563
00:34:46,530 --> 00:34:50,730
edge of the size of memory region middle

564
00:34:50,730 --> 00:34:55,020
of the whole a with the short list

565
00:34:55,020 --> 00:35:01,020
primitive but we want to find we want to

566
00:35:01,020 --> 00:35:03,090
know the size between the heap and say

567
00:35:03,090 --> 00:35:05,510
so we have to continue allocating and

568
00:35:05,510 --> 00:35:11,820
finding the size of this region but

569
00:35:11,820 --> 00:35:15,540
because the allocated memory if we did

570
00:35:15,540 --> 00:35:20,580
with the short lift technique then we

571
00:35:20,580 --> 00:35:22,620
get to be allocated so we need something

572
00:35:22,620 --> 00:35:25,320
to keep that region allocated because we

573
00:35:25,320 --> 00:35:27,480
want to continue we want to build on top

574
00:35:27,480 --> 00:35:29,550
of it you won't have that we want to

575
00:35:29,550 --> 00:35:33,170
keep it there and then we want to do the

576
00:35:33,170 --> 00:35:36,360
we want to probe again for the for a

577
00:35:36,360 --> 00:35:38,850
hole size and then we want it we want

578
00:35:38,850 --> 00:35:45,090
this to end up in OB what can we do then

579
00:35:45,090 --> 00:35:46,440
we can use the second primitive the

580
00:35:46,440 --> 00:35:49,590
persistent allocation primitive it's

581
00:35:49,590 --> 00:35:52,730
quite straightforward in this primitive

582
00:35:52,730 --> 00:35:56,460
the the allocation we prevented the

583
00:35:56,460 --> 00:36:03,390
allocation of the memory and usually we

584
00:36:03,390 --> 00:36:07,590
can transform the shortlist primitive

585
00:36:07,590 --> 00:36:13,170
into a long-lived primitive by for

586
00:36:13,170 --> 00:36:15,840
example keeping the connection open or

587
00:36:15,840 --> 00:36:19,610
just not completing the request reply

588
00:36:19,610 --> 00:36:27,089
communication so we can

589
00:36:27,089 --> 00:36:30,769
keep the memory allocated for hole a and

590
00:36:30,769 --> 00:36:34,859
then we can use the shortly primitives

591
00:36:34,859 --> 00:36:37,440
to get the size between heap and a safe

592
00:36:37,440 --> 00:36:42,509
stack once we have that we can compute

593
00:36:42,509 --> 00:36:44,789
address of safe stack and then we and

594
00:36:44,789 --> 00:36:51,630
then we know we're safe thank you so how

595
00:36:51,630 --> 00:36:56,190
can we do that and what do we need we

596
00:36:56,190 --> 00:37:00,989
want an easier way to allocate large

597
00:37:00,989 --> 00:37:03,119
regions we need to find a way in the

598
00:37:03,119 --> 00:37:07,499
program and also to remove a way to

599
00:37:07,499 --> 00:37:12,630
infer like what the server did so an

600
00:37:12,630 --> 00:37:14,960
nginx

601
00:37:14,960 --> 00:37:19,979
you can what we found is you can change

602
00:37:19,979 --> 00:37:23,249
the this variable in memory the pool

603
00:37:23,249 --> 00:37:27,299
size and when a new connection happens

604
00:37:27,299 --> 00:37:33,150
it will use this full size to allocate

605
00:37:33,150 --> 00:37:39,630
the memory and we found this by using a

606
00:37:39,630 --> 00:37:44,819
taint propagation framework in which we

607
00:37:44,819 --> 00:37:47,460
paint the whole memory when the server

608
00:37:47,460 --> 00:37:51,960
is idle and then we sent a connection to

609
00:37:51,960 --> 00:37:56,369
the server and then we follow the taint

610
00:37:56,369 --> 00:37:59,339
propagation and as a change sink we set

611
00:37:59,339 --> 00:38:02,119
the arguments of memory allocation

612
00:38:02,119 --> 00:38:05,279
functions and in this way we found the

613
00:38:05,279 --> 00:38:11,230
full size and the

614
00:38:11,230 --> 00:38:14,530
way to detect whether the allocation at

615
00:38:14,530 --> 00:38:16,740
the server field or not there are

616
00:38:16,740 --> 00:38:24,400
different kind of options the one is the

617
00:38:24,400 --> 00:38:29,700
server just replies with status it says

618
00:38:29,700 --> 00:38:32,230
it gives you the page as you request it

619
00:38:32,230 --> 00:38:35,619
or just as something wrong happened or

620
00:38:35,619 --> 00:38:43,000
it just so it can auto option is that

621
00:38:43,000 --> 00:38:45,970
the server crashes so it just doesn't

622
00:38:45,970 --> 00:38:48,580
reply most of the connection closest or

623
00:38:48,580 --> 00:38:51,040
it gives you when it succeeds it's it

624
00:38:51,040 --> 00:38:53,320
gives you okay it is and gives you the

625
00:38:53,320 --> 00:38:58,960
page or a site timing side channel can

626
00:38:58,960 --> 00:39:03,430
happen so an example I will show you in

627
00:39:03,430 --> 00:39:07,450
which server we used such as a side

628
00:39:07,450 --> 00:39:11,380
channel so in a side channel you measure

629
00:39:11,380 --> 00:39:17,080
the the time and then do the time for

630
00:39:17,080 --> 00:39:20,920
the response and then if it's a if the

631
00:39:20,920 --> 00:39:24,780
server replied quick it means probably

632
00:39:24,780 --> 00:39:27,190
everything it was fine well of course it

633
00:39:27,190 --> 00:39:31,090
depends on the server okay you can infer

634
00:39:31,090 --> 00:39:34,690
like on response whether it succeed it

635
00:39:34,690 --> 00:39:38,859
or not nginx for example when the

636
00:39:38,859 --> 00:39:41,320
allocation fails it closes the

637
00:39:41,320 --> 00:39:46,980
connection but like TBD it crashes so

638
00:39:46,980 --> 00:39:50,020
the reason would likely to be crashes is

639
00:39:50,020 --> 00:39:52,960
that when allocates the large memory

640
00:39:52,960 --> 00:39:56,440
region it tries to initialize this

641
00:39:56,440 --> 00:39:58,990
region imagine so it

642
00:39:58,990 --> 00:40:02,830
allocate a large memory region and when

643
00:40:02,830 --> 00:40:05,350
allocate is not it's not a problem but

644
00:40:05,350 --> 00:40:07,810
when it starts initiating initializing

645
00:40:07,810 --> 00:40:13,090
the memory it starts using physical

646
00:40:13,090 --> 00:40:15,430
memory memory and if there's not enough

647
00:40:15,430 --> 00:40:17,320
physical memory it will run out of

648
00:40:17,320 --> 00:40:20,460
memory and then it will crash

649
00:40:21,539 --> 00:40:34,349
but the nice thing is so if the location

650
00:40:34,349 --> 00:40:37,829
fails the response will take long and if

651
00:40:37,829 --> 00:40:41,399
it succeeds it will be it will be much

652
00:40:41,399 --> 00:40:47,549
faster and then light TPD restarts when

653
00:40:47,549 --> 00:40:49,909
it crashes

654
00:40:50,359 --> 00:40:52,619
so the assumption with allocation

655
00:40:52,619 --> 00:40:55,409
Oracle's is that a memory overcome it

656
00:40:55,409 --> 00:40:59,299
should be enabled but in some servers

657
00:40:59,299 --> 00:41:02,819
this this feature is enabled because it

658
00:41:02,819 --> 00:41:10,559
also hosts like like big data software

659
00:41:10,559 --> 00:41:13,139
like it is Hadoop or virtual

660
00:41:13,139 --> 00:41:16,289
virtualization in such cases memory

661
00:41:16,289 --> 00:41:17,399
overcome it might be needed and

662
00:41:17,399 --> 00:41:19,199
interesting to notice then for example

663
00:41:19,199 --> 00:41:22,499
Android we learned recently that memory

664
00:41:22,499 --> 00:41:26,579
overcommit is enabled by default and

665
00:41:26,579 --> 00:41:29,369
even if it is disabled an attacker can

666
00:41:29,369 --> 00:41:32,699
still try it well might be able to do

667
00:41:32,699 --> 00:41:36,359
allocation might be executed occasional

668
00:41:36,359 --> 00:41:38,039
Oracle primitives

669
00:41:38,039 --> 00:41:43,189
if you can control these flags of memory

670
00:41:43,189 --> 00:41:46,069
memories being allocated for example it

671
00:41:46,069 --> 00:41:49,649
if it can set the map no reserve flag

672
00:41:49,649 --> 00:41:54,779
and a map it doesn't look at the memory

673
00:41:54,779 --> 00:41:58,339
over commit flag it just allocate the

674
00:41:58,339 --> 00:42:02,759
memory without reserving any physical

675
00:42:02,759 --> 00:42:09,239
memory to conclude my talk implementing

676
00:42:09,239 --> 00:42:11,849
safe sex without pointers to it might

677
00:42:11,849 --> 00:42:14,159
not be trivial as we have seen there are

678
00:42:14,159 --> 00:42:19,739
quite some pointers to it so some effort

679
00:42:19,739 --> 00:42:21,809
is still needed to fix all of these

680
00:42:21,809 --> 00:42:27,130
pointers and SLR is maybe not a good

681
00:42:27,130 --> 00:42:30,120
[Music]

682
00:42:30,120 --> 00:42:33,610
thing to rely on because there different

683
00:42:33,610 --> 00:42:35,890
ways you can weaken it like first paying

684
00:42:35,890 --> 00:42:38,830
allocation Oracle's and we think that

685
00:42:38,830 --> 00:42:40,780
proper isolation like software fault

686
00:42:40,780 --> 00:42:43,690
isolation or you put binaries on memory

687
00:42:43,690 --> 00:42:47,380
access might be a good way to protect

688
00:42:47,380 --> 00:42:52,750
safe side and mitigate these attacks if

689
00:42:52,750 --> 00:42:56,850
you are interesting we stock a below in

690
00:42:56,850 --> 00:43:00,940
these topics and you might also want to

691
00:43:00,940 --> 00:43:02,260
read the papers that has more

692
00:43:02,260 --> 00:43:05,590
information about these things thank you

693
00:43:05,590 --> 00:43:07,900
for listening with your questions

694
00:43:07,900 --> 00:43:09,540
ideally I would like

695
00:43:09,540 --> 00:43:12,829
[Applause]

