1
00:00:00,030 --> 00:00:03,090
hi everybody sorry for being late or the

2
00:00:03,090 --> 00:00:06,569
problem with our laptop so we had to use

3
00:00:06,569 --> 00:00:10,650
other laptop so today we are going to

4
00:00:10,650 --> 00:00:12,780
talk about ghost in the PLC designing an

5
00:00:12,780 --> 00:00:14,219
undetectable programmable logic

6
00:00:14,219 --> 00:00:16,560
controller rootkit European control

7
00:00:16,560 --> 00:00:20,789
attack my name is Ali epoxy and I'm PhD

8
00:00:20,789 --> 00:00:23,189
student at distributed and and embedded

9
00:00:23,189 --> 00:00:25,740
system security group at University of

10
00:00:25,740 --> 00:00:29,279
Twente in the Netherlands and visiting

11
00:00:29,279 --> 00:00:31,289
researcher chair of system security of

12
00:00:31,289 --> 00:00:34,200
Rock University Bochum in Germany I'm

13
00:00:34,200 --> 00:00:37,980
doing some system level security proxy

14
00:00:37,980 --> 00:00:41,969
Elsie's their budget ok hello guys I'm

15
00:00:41,969 --> 00:00:42,989
Majid and research and development

16
00:00:42,989 --> 00:00:47,640
engineer at quarks lab are you involved

17
00:00:47,640 --> 00:00:48,930
in this research with AP as an

18
00:00:48,930 --> 00:00:51,239
independent security researcher so they

19
00:00:51,239 --> 00:00:53,100
are not representing on behalf of my

20
00:00:53,100 --> 00:00:59,699
current or former employer alright so we

21
00:00:59,699 --> 00:01:04,080
are going to describe our work so just

22
00:01:04,080 --> 00:01:06,060
one thing I have to mention that this is

23
00:01:06,060 --> 00:01:08,880
not that not all of the research we did

24
00:01:08,880 --> 00:01:11,479
basically what we did today had some

25
00:01:11,479 --> 00:01:14,220
components about actual physical process

26
00:01:14,220 --> 00:01:16,590
exploitation which we can't expose

27
00:01:16,590 --> 00:01:18,560
because it was part of the EU project

28
00:01:18,560 --> 00:01:21,509
but we are going to expose the details

29
00:01:21,509 --> 00:01:24,330
about the attack itself so it doesn't

30
00:01:24,330 --> 00:01:26,490
contain process exploitation because we

31
00:01:26,490 --> 00:01:28,920
looked at a specific process in

32
00:01:28,920 --> 00:01:31,590
different utilities to exploit them

33
00:01:31,590 --> 00:01:34,020
anyway so today we are going to first

34
00:01:34,020 --> 00:01:36,329
give you some background on existing

35
00:01:36,329 --> 00:01:38,130
attacks and defenses for embedded

36
00:01:38,130 --> 00:01:40,799
systems this is important the maybe not

37
00:01:40,799 --> 00:01:46,530
exactly fully what we what we are doing

38
00:01:46,530 --> 00:01:48,600
but it is important because we wanted to

39
00:01:48,600 --> 00:01:51,299
look at existing active defense and

40
00:01:51,299 --> 00:01:53,579
attack against amulet systems and then

41
00:01:53,579 --> 00:01:55,590
we look at them and see which one of

42
00:01:55,590 --> 00:01:57,600
them are actually applicable to PLC's

43
00:01:57,600 --> 00:02:00,299
and then later we are going to the core

44
00:02:00,299 --> 00:02:02,520
problem which is a pink control and we

45
00:02:02,520 --> 00:02:03,899
give you a background on thin control

46
00:02:03,899 --> 00:02:05,700
and we explain the problem with pin

47
00:02:05,700 --> 00:02:08,280
control it's not well we believe that

48
00:02:08,280 --> 00:02:09,959
it's not a software problem it's mostly

49
00:02:09,959 --> 00:02:11,400
hardware problem and then we explain our

50
00:02:11,400 --> 00:02:13,470
root key to a range of our attacks

51
00:02:13,470 --> 00:02:16,080
we decided to add some stuff about each

52
00:02:16,080 --> 00:02:18,900
variant of our work we will have some

53
00:02:18,900 --> 00:02:21,920
demos including a demo in a real PLC

54
00:02:21,920 --> 00:02:24,180
because again there was some comments

55
00:02:24,180 --> 00:02:25,620
about our work which we decided to do it

56
00:02:25,620 --> 00:02:27,720
in a VLP as well and we'll have some

57
00:02:27,720 --> 00:02:31,740
discussions yeah so first of all what is

58
00:02:31,740 --> 00:02:34,800
talking about and what is not about so

59
00:02:34,800 --> 00:02:37,380
the talk is basically trying to uncover

60
00:02:37,380 --> 00:02:41,670
existing design flaws in PLC's and we

61
00:02:41,670 --> 00:02:43,740
believe that that this kind of attack

62
00:02:43,740 --> 00:02:46,820
can be used in future by the attackers

63
00:02:46,820 --> 00:02:50,670
but today with the situation we have in

64
00:02:50,670 --> 00:02:52,740
the Americas and especially in PLC's we

65
00:02:52,740 --> 00:02:54,660
believe that it therefore easier

66
00:02:54,660 --> 00:02:57,360
attacking techniques but of course the

67
00:02:57,360 --> 00:02:59,250
vendors which some of them actually are

68
00:02:59,250 --> 00:03:01,200
here and actually did lots of thing they

69
00:03:01,200 --> 00:03:03,270
are trying to defeat those kind of

70
00:03:03,270 --> 00:03:06,540
trivial attacks magic ok so this

71
00:03:06,540 --> 00:03:08,640
research wasn't about developing another

72
00:03:08,640 --> 00:03:10,770
version of a Sportsnet so we're not

73
00:03:10,770 --> 00:03:12,740
going to unveil any fully functional

74
00:03:12,740 --> 00:03:15,870
rootkit like it's not about the symbol

75
00:03:15,870 --> 00:03:17,480
single binary that you can learn

76
00:03:17,480 --> 00:03:20,790
everywhere on every PLC with with any

77
00:03:20,790 --> 00:03:22,680
operating system or any architecture

78
00:03:22,680 --> 00:03:24,660
we're not going to talk about any one

79
00:03:24,660 --> 00:03:26,790
vulnerable to discovery technique or any

80
00:03:26,790 --> 00:03:29,250
exploitation techniques so there's also

81
00:03:29,250 --> 00:03:32,850
knows your data leak and we consider

82
00:03:32,850 --> 00:03:33,920
that our attack is cross-platform

83
00:03:33,920 --> 00:03:37,709
because the underlying flaw is not

84
00:03:37,709 --> 00:03:39,660
related to any operating system or to

85
00:03:39,660 --> 00:03:43,260
any hardware architecture so it's a the

86
00:03:43,260 --> 00:03:47,400
flaw is a big general flow into embedded

87
00:03:47,400 --> 00:03:49,260
systems which are going to explain later

88
00:03:49,260 --> 00:03:51,150
and of course we are not going to name

89
00:03:51,150 --> 00:03:57,450
any vendor so no names and shapes ok so

90
00:03:57,450 --> 00:03:59,549
first things first let's see what what

91
00:03:59,549 --> 00:04:01,260
is the critical infrastructure the

92
00:04:01,260 --> 00:04:03,090
protocol infrastructures are basically

93
00:04:03,090 --> 00:04:05,250
the element of the infrastructure that

94
00:04:05,250 --> 00:04:07,620
if lost could pose a significant threat

95
00:04:07,620 --> 00:04:10,380
to the system service and communication

96
00:04:10,380 --> 00:04:13,290
for example the electrical and nuclear

97
00:04:13,290 --> 00:04:17,040
facilities the water purification the

98
00:04:17,040 --> 00:04:19,200
gaseous stations and of course military

99
00:04:19,200 --> 00:04:22,370
and transport transportation

100
00:04:22,570 --> 00:04:25,300
okay based on our previous experiences

101
00:04:25,300 --> 00:04:27,070
the attackers are mostly a status

102
00:04:27,070 --> 00:04:29,170
sponsored they are using zero days and

103
00:04:29,170 --> 00:04:30,040
they're using highly sophisticated

104
00:04:30,040 --> 00:04:31,210
techniques

105
00:04:31,210 --> 00:04:32,890
that's as sophisticated evasion

106
00:04:32,890 --> 00:04:34,780
techniques one of the well-known example

107
00:04:34,780 --> 00:04:38,920
and in this is operation Olympic and Fox

108
00:04:38,920 --> 00:04:42,730
not actually so like any other attack

109
00:04:42,730 --> 00:04:44,680
before starting the attack that I could

110
00:04:44,680 --> 00:04:46,300
need to get into the network without

111
00:04:46,300 --> 00:04:46,990
being detected

112
00:04:46,990 --> 00:04:50,290
I had been an interesting research in

113
00:04:50,290 --> 00:04:52,810
this area which has in the presented at

114
00:04:52,810 --> 00:04:55,420
blackhat your 2014 as well which called

115
00:04:55,420 --> 00:04:57,610
defeating the emulation based Network

116
00:04:57,610 --> 00:05:00,760
intrusion detection systems and then

117
00:05:00,760 --> 00:05:02,550
once the attacker gets into the network

118
00:05:02,550 --> 00:05:05,140
the second step is to start manipulating

119
00:05:05,140 --> 00:05:07,300
the process there's another good

120
00:05:07,300 --> 00:05:09,790
research in this area by marina corte

121
00:05:09,790 --> 00:05:11,650
file is called dam vulnerable chemical

122
00:05:11,650 --> 00:05:13,750
process to the research appearance to

123
00:05:13,750 --> 00:05:18,070
asset okay so the PLC's are one of the

124
00:05:18,070 --> 00:05:20,500
main components of every critical

125
00:05:20,500 --> 00:05:22,990
infrastructure the the PLC's are

126
00:05:22,990 --> 00:05:25,000
basically in embedded systems running

127
00:05:25,000 --> 00:05:28,480
and runtime operating system the we can

128
00:05:28,480 --> 00:05:30,970
program the plc is using logics so the

129
00:05:30,970 --> 00:05:33,430
logic is basically a program that that

130
00:05:33,430 --> 00:05:37,660
plc executes and based on this logic it

131
00:05:37,660 --> 00:05:39,880
will make the plc for example to read

132
00:05:39,880 --> 00:05:42,190
some of the value from a physical IO as

133
00:05:42,190 --> 00:05:44,440
an input and do some processing and

134
00:05:44,440 --> 00:05:46,570
based on on that input and based on the

135
00:05:46,570 --> 00:05:48,760
result of that processing it will update

136
00:05:48,760 --> 00:05:51,460
some outputs for example imagine that we

137
00:05:51,460 --> 00:05:54,040
have a temperature sensor as input and

138
00:05:54,040 --> 00:05:56,710
the logic makes the plc to read the

139
00:05:56,710 --> 00:05:59,140
temperature and in the processing part

140
00:05:59,140 --> 00:06:01,090
it will see if the temperature is not

141
00:06:01,090 --> 00:06:03,670
higher than a predefined temperature

142
00:06:03,670 --> 00:06:06,070
into the logic and if it's higher it

143
00:06:06,070 --> 00:06:07,750
will update some outputs for example

144
00:06:07,750 --> 00:06:10,600
turning on an alarm what or whatever

145
00:06:10,600 --> 00:06:11,550
else

146
00:06:11,550 --> 00:06:14,410
so let's here we are going to take a

147
00:06:14,410 --> 00:06:16,810
look at all all the existing attacks and

148
00:06:16,810 --> 00:06:19,060
defenses on em that the systems and

149
00:06:19,060 --> 00:06:19,780
PLC's

150
00:06:19,780 --> 00:06:22,600
so first of all we have the tag called

151
00:06:22,600 --> 00:06:24,940
firmware modification attack which the

152
00:06:24,940 --> 00:06:27,760
attacker basically take a firmware image

153
00:06:27,760 --> 00:06:30,160
and starts modifying this remember and

154
00:06:30,160 --> 00:06:32,140
injecting his malicious code and then

155
00:06:32,140 --> 00:06:34,660
uploading this this malicious firmware

156
00:06:34,660 --> 00:06:35,920
onto the device

157
00:06:35,920 --> 00:06:39,370
the second type is is logic modification

158
00:06:39,370 --> 00:06:41,500
which in this attack the attacker

159
00:06:41,500 --> 00:06:43,120
instead of modifying the firmware is

160
00:06:43,120 --> 00:06:46,390
what he will try to modify the logic

161
00:06:46,390 --> 00:06:47,800
actually and then upload the malicious

162
00:06:47,800 --> 00:06:50,590
logic to to control the plot the process

163
00:06:50,590 --> 00:06:52,780
the another class of attack here which

164
00:06:52,780 --> 00:06:54,400
is which exists for a long time on the

165
00:06:54,400 --> 00:06:56,590
under on the PC Wars is called control

166
00:06:56,590 --> 00:06:59,310
flow attack which is basically the

167
00:06:59,310 --> 00:07:02,110
memory corruption buffer overflows and

168
00:07:02,110 --> 00:07:05,380
you know this kind of attacks then other

169
00:07:05,380 --> 00:07:07,330
attacks called authentication bypass

170
00:07:07,330 --> 00:07:10,300
which is a really simple attack and but

171
00:07:10,300 --> 00:07:14,530
unfortunately it's very common which is

172
00:07:14,530 --> 00:07:16,750
about the default password in the PLC's

173
00:07:16,750 --> 00:07:18,550
which can you can see it everywhere even

174
00:07:18,550 --> 00:07:20,710
into the real world system and real

175
00:07:20,710 --> 00:07:24,610
critical infrastructures the last coin

176
00:07:24,610 --> 00:07:28,900
here is the ICS malware which the

177
00:07:28,900 --> 00:07:30,700
malware is attacking directly to the

178
00:07:30,700 --> 00:07:33,580
SCADA software and by controlling this

179
00:07:33,580 --> 00:07:35,530
color software actually he will try to

180
00:07:35,530 --> 00:07:38,730
manipulate the process of the PLC the

181
00:07:38,730 --> 00:07:41,170
again which good example here is the

182
00:07:41,170 --> 00:07:45,040
Silk stocks net so for all those attacks

183
00:07:45,040 --> 00:07:46,960
we have the defenses as well the

184
00:07:46,960 --> 00:07:49,240
attestation or memory attestation is one

185
00:07:49,240 --> 00:07:52,150
of those defense in attestation the the

186
00:07:52,150 --> 00:07:56,910
protection make the solution is try to

187
00:07:56,910 --> 00:08:00,910
to verify integrity of a system for

188
00:08:00,910 --> 00:08:03,400
example in memory at the station the

189
00:08:03,400 --> 00:08:05,860
defensive solution will try to ensure

190
00:08:05,860 --> 00:08:09,760
that the memory region is is not changed

191
00:08:09,760 --> 00:08:12,010
and if we compare it with the checksum

192
00:08:12,010 --> 00:08:14,080
then we have similar integrity

193
00:08:14,080 --> 00:08:15,820
verification which is a which is the

194
00:08:15,820 --> 00:08:19,380
defense against the firmware a filmer

195
00:08:19,380 --> 00:08:22,300
modification and logic and agree a

196
00:08:22,300 --> 00:08:24,850
logical modification actually and then

197
00:08:24,850 --> 00:08:27,670
the last kind of defense are our hoop

198
00:08:27,670 --> 00:08:29,590
detections the code hooking and data

199
00:08:29,590 --> 00:08:31,390
hooking which we are going to talk in

200
00:08:31,390 --> 00:08:34,840
more detail about that okay so from all

201
00:08:34,840 --> 00:08:36,640
those defenses there are only few of

202
00:08:36,640 --> 00:08:38,080
them which match the following

203
00:08:38,080 --> 00:08:39,669
requirements are actually applicable to

204
00:08:39,669 --> 00:08:42,520
the PLC's so the proposed solution

205
00:08:42,520 --> 00:08:44,080
should not require any hardware

206
00:08:44,080 --> 00:08:46,810
modification and because on the PLC's we

207
00:08:46,810 --> 00:08:48,880
have limited amount of resource the poor

208
00:08:48,880 --> 00:08:50,680
proposed solution should not pose extra

209
00:08:50,680 --> 00:08:53,320
overhead to the device and then because

210
00:08:53,320 --> 00:08:55,660
you know almost all of the already

211
00:08:55,660 --> 00:08:57,430
manufactured PLC's are not supporting

212
00:08:57,430 --> 00:09:00,430
virtualization so if the proposed

213
00:09:00,430 --> 00:09:02,950
solution is virtualization based is not

214
00:09:02,950 --> 00:09:06,190
applicable to the PLC's as well so if

215
00:09:06,190 --> 00:09:08,260
you do all those protection in two basic

216
00:09:08,260 --> 00:09:09,970
categories trivial and non-trivial

217
00:09:09,970 --> 00:09:12,820
defenses we can put logic checks on

218
00:09:12,820 --> 00:09:14,800
verification forensic easy verification

219
00:09:14,800 --> 00:09:18,250
as a trivial defense and all hospice

220
00:09:18,250 --> 00:09:20,380
intrusion detection system in

221
00:09:20,380 --> 00:09:23,140
non-trivial category so the duple ganger

222
00:09:23,140 --> 00:09:25,120
and other scope ej are two good example

223
00:09:25,120 --> 00:09:27,850
of non-trivial defense so let's let's

224
00:09:27,850 --> 00:09:30,030
take a look at how they're working so

225
00:09:30,030 --> 00:09:32,350
duplicate here actually using the memory

226
00:09:32,350 --> 00:09:34,150
attestation technique what it does it's

227
00:09:34,150 --> 00:09:37,030
actually take a firmware image it will

228
00:09:37,030 --> 00:09:38,560
scan this at this frame her for

229
00:09:38,560 --> 00:09:41,080
executable and live code and it will

230
00:09:41,080 --> 00:09:43,420
randomly install some watch points and

231
00:09:43,420 --> 00:09:46,270
later in the gig at one time every time

232
00:09:46,270 --> 00:09:48,220
that this watch points are hit it will

233
00:09:48,220 --> 00:09:50,200
verify a checksum of the memory region

234
00:09:50,200 --> 00:09:52,690
so as far as this change the checksum is

235
00:09:52,690 --> 00:09:54,310
not changed it will consider that

236
00:09:54,310 --> 00:09:55,870
everything is good at it will at the

237
00:09:55,870 --> 00:09:58,960
execution to plot then we have otoscope

238
00:09:58,960 --> 00:10:03,140
ejr the otoscope ejr is a basically a

239
00:10:03,140 --> 00:10:04,290
[Music]

240
00:10:04,290 --> 00:10:06,310
protection against the control flow

241
00:10:06,310 --> 00:10:08,790
anomalies it has two different phases

242
00:10:08,790 --> 00:10:12,940
except it will actually which called

243
00:10:12,940 --> 00:10:15,880
loop gather some information related to

244
00:10:15,880 --> 00:10:19,480
the execution and it's like you know

245
00:10:19,480 --> 00:10:21,540
function a function is everything good

246
00:10:21,540 --> 00:10:24,190
like like function addresses like return

247
00:10:24,190 --> 00:10:26,710
addresses of the function function

248
00:10:26,710 --> 00:10:29,140
parameter and this kind of stuff as it

249
00:10:29,140 --> 00:10:31,330
will store all of them and in data

250
00:10:31,330 --> 00:10:33,160
structure called trusted location list

251
00:10:33,160 --> 00:10:35,980
and later in the protection mode is will

252
00:10:35,980 --> 00:10:37,450
compare all the wrong time values

253
00:10:37,450 --> 00:10:40,210
against this already gathered values

254
00:10:40,210 --> 00:10:41,950
which called trusted location list and

255
00:10:41,950 --> 00:10:44,200
as far as these two values are are

256
00:10:44,200 --> 00:10:45,490
matching it will consider that

257
00:10:45,490 --> 00:10:47,260
everything is good and let the execution

258
00:10:47,260 --> 00:10:51,340
to to continue so up until now we have

259
00:10:51,340 --> 00:10:53,170
per we have discussed about two

260
00:10:53,170 --> 00:10:55,840
different defensive solution against

261
00:10:55,840 --> 00:10:58,210
poaching and data hooking the code

262
00:10:58,210 --> 00:11:00,160
switching is basically when the attacker

263
00:11:00,160 --> 00:11:01,839
try to divert the execution of a

264
00:11:01,839 --> 00:11:02,620
function

265
00:11:02,620 --> 00:11:04,960
to another higher parts of memory which

266
00:11:04,960 --> 00:11:07,090
he controls and he put his malicious

267
00:11:07,090 --> 00:11:08,830
code and once the malicious code is

268
00:11:08,830 --> 00:11:10,390
executed it's a jump back to the good

269
00:11:10,390 --> 00:11:15,430
function and data hooking is is it's

270
00:11:15,430 --> 00:11:17,730
kinda attacked that the attacker not

271
00:11:17,730 --> 00:11:20,350
doing anything with the code but in CDs

272
00:11:20,350 --> 00:11:23,350
we'll try he will try to modify it and

273
00:11:23,350 --> 00:11:25,750
elements of data structure in memory for

274
00:11:25,750 --> 00:11:29,590
example a syscall table in linux okay so

275
00:11:29,590 --> 00:11:32,970
like any other defensive solution the

276
00:11:32,970 --> 00:11:36,190
duple ganger and otoscope ejr has their

277
00:11:36,190 --> 00:11:36,880
own weaknesses

278
00:11:36,880 --> 00:11:39,850
for example the doppelganger is not able

279
00:11:39,850 --> 00:11:42,250
to verify the dynamic memory for example

280
00:11:42,250 --> 00:11:44,260
imagine that there is a malicious code

281
00:11:44,260 --> 00:11:46,060
is dynamically loaded into memory and

282
00:11:46,060 --> 00:11:48,520
then get it can be executed the do

283
00:11:48,520 --> 00:11:50,770
programmer is not able to to monitor it

284
00:11:50,770 --> 00:11:51,940
it actually doesn't see it

285
00:11:51,940 --> 00:11:56,260
and for otoscope ujr because which using

286
00:11:56,260 --> 00:11:58,360
static references a setting referencing

287
00:11:58,360 --> 00:12:01,810
and so if the attack is happening in the

288
00:12:01,810 --> 00:12:03,520
part of the code and parts of the memory

289
00:12:03,520 --> 00:12:05,980
which wasn't money should actually in

290
00:12:05,980 --> 00:12:08,710
the learning mode of otoscope ejr then

291
00:12:08,710 --> 00:12:10,960
later in the protection phase the

292
00:12:10,960 --> 00:12:13,690
otoscope AJR is not able to monitor and

293
00:12:13,690 --> 00:12:16,990
do any protection about that attack okay

294
00:12:16,990 --> 00:12:19,170
so this was a background about all

295
00:12:19,170 --> 00:12:21,490
attacks and defenses early going to give

296
00:12:21,490 --> 00:12:23,320
you some background on pimkin Hey

297
00:12:23,320 --> 00:12:25,660
thank you actually I like this

298
00:12:25,660 --> 00:12:29,860
microphone I don't have to say loud so I

299
00:12:29,860 --> 00:12:32,260
guess you're here to listen about the

300
00:12:32,260 --> 00:12:34,090
the core problem and this part is

301
00:12:34,090 --> 00:12:36,010
actually talking about the core problem

302
00:12:36,010 --> 00:12:40,140
so a background on pin control well

303
00:12:40,140 --> 00:12:41,880
let's look at

304
00:12:41,880 --> 00:12:44,860
so basically pin controller like like

305
00:12:44,860 --> 00:12:48,220
these are the pins in the CPU or SOC s

306
00:12:48,220 --> 00:12:51,840
and basically basically it's like

307
00:12:51,840 --> 00:12:54,370
controlled by a system we call it in

308
00:12:54,370 --> 00:12:56,710
control it can be slightly different in

309
00:12:56,710 --> 00:12:58,150
different architectures but they're the

310
00:12:58,150 --> 00:12:59,850
foundation all of them are saying

311
00:12:59,850 --> 00:13:03,100
majority of abilities and 95% of them

312
00:13:03,100 --> 00:13:05,320
are actually based on kingpin based

313
00:13:05,320 --> 00:13:08,530
control and you it consists of two parts

314
00:13:08,530 --> 00:13:11,200
pin configuration and pin multiplexing

315
00:13:11,200 --> 00:13:14,830
so let's start with pin multiplexing so

316
00:13:14,830 --> 00:13:15,800
what is pin much

317
00:13:15,800 --> 00:13:18,860
be multiplexing very very simple means

318
00:13:18,860 --> 00:13:21,320
that you can have multiple functionality

319
00:13:21,320 --> 00:13:25,190
in a CPU pin or SOC team and you can

320
00:13:25,190 --> 00:13:28,040
change the functionality when you want

321
00:13:28,040 --> 00:13:30,620
usually tapping at the time but you can

322
00:13:30,620 --> 00:13:32,350
actually change it any time you want and

323
00:13:32,350 --> 00:13:35,510
usually you have a switch in the SOC and

324
00:13:35,510 --> 00:13:37,010
here is for example a multiplex screen

325
00:13:37,010 --> 00:13:38,690
which you can change the functionality

326
00:13:38,690 --> 00:13:42,440
to do different stuff so let's give you

327
00:13:42,440 --> 00:13:44,810
example you know you I don't want to

328
00:13:44,810 --> 00:13:46,250
mention company's name but for example

329
00:13:46,250 --> 00:13:48,740
you have a phone a and phone be the

330
00:13:48,740 --> 00:13:51,680
company a is very nice and provide you

331
00:13:51,680 --> 00:13:53,329
with a SD card reader so which you can

332
00:13:53,329 --> 00:13:56,149
put your phone to the back you can put

333
00:13:56,149 --> 00:13:58,640
the SD card to your phone increase the

334
00:13:58,640 --> 00:14:00,740
storage of your phone but fine the

335
00:14:00,740 --> 00:14:03,740
company be have the same CPU or as you

336
00:14:03,740 --> 00:14:06,620
see but doesn't have a sticker so what

337
00:14:06,620 --> 00:14:08,600
they do is that basically they multiplex

338
00:14:08,600 --> 00:14:11,300
the pins which was being used for SD

339
00:14:11,300 --> 00:14:14,209
card operations and you use it for other

340
00:14:14,209 --> 00:14:16,339
purpose that thing won't affect me so

341
00:14:16,339 --> 00:14:18,560
you can have multiple functionality not

342
00:14:18,560 --> 00:14:20,720
at the same time but just you can have

343
00:14:20,720 --> 00:14:23,000
multiple functionalities one of them you

344
00:14:23,000 --> 00:14:26,300
can use at a time but basically our

345
00:14:26,300 --> 00:14:29,060
switch to you can basically you can

346
00:14:29,060 --> 00:14:31,399
decide what you want so neck next okay

347
00:14:31,399 --> 00:14:34,160
thanks so what is ping configuration

348
00:14:34,160 --> 00:14:38,839
configuration actually simpler so you

349
00:14:38,839 --> 00:14:42,050
know when you have a logic now here is

350
00:14:42,050 --> 00:14:45,079
an example a very very basic logic of a

351
00:14:45,079 --> 00:14:47,690
PLC so if you say for example I write a

352
00:14:47,690 --> 00:14:50,060
pin to be input and this pin number is

353
00:14:50,060 --> 00:14:53,720
24 and then there is a pin I describe as

354
00:14:53,720 --> 00:14:55,339
output you can actually see it here -

355
00:14:55,339 --> 00:14:57,680
this is for example output pin and this

356
00:14:57,680 --> 00:15:00,199
is the inputs mean and then I decide to

357
00:15:00,199 --> 00:15:02,959
turn on and off something connected to

358
00:15:02,959 --> 00:15:05,089
the dispenser let's say it's the LED I

359
00:15:05,089 --> 00:15:07,399
want to turn it on and off every five

360
00:15:07,399 --> 00:15:08,510
seconds so what will happen is that

361
00:15:08,510 --> 00:15:11,029
basically you describe the input pin

362
00:15:11,029 --> 00:15:15,440
here and output pin here and normally

363
00:15:15,440 --> 00:15:17,750
the standard the rule is that input pin

364
00:15:17,750 --> 00:15:19,850
you can only read from it but you can't

365
00:15:19,850 --> 00:15:21,380
write through okay

366
00:15:21,380 --> 00:15:23,959
the output pin you can both read and

367
00:15:23,959 --> 00:15:26,600
write from it is this concept which we

368
00:15:26,600 --> 00:15:29,010
are talking actually you can have

369
00:15:29,010 --> 00:15:31,260
different kind of interfaces in your PLC

370
00:15:31,260 --> 00:15:33,510
so you can actually use the spi I don't

371
00:15:33,510 --> 00:15:36,839
know some piercings use some some kind

372
00:15:36,839 --> 00:15:39,269
of serial interfaces which there which

373
00:15:39,269 --> 00:15:40,680
we are they are talking with their i/o

374
00:15:40,680 --> 00:15:44,329
they are K bus d bus I don't know like

375
00:15:44,329 --> 00:15:46,649
SPI like lots of different but the

376
00:15:46,649 --> 00:15:48,389
foundation the underlying system we are

377
00:15:48,389 --> 00:15:50,399
talking on underlying system you are the

378
00:15:50,399 --> 00:15:56,760
same and next sorry ok so there is a

379
00:15:56,760 --> 00:15:59,639
problem the problem is that the pin

380
00:15:59,639 --> 00:16:01,170
multiplexing itself and pin

381
00:16:01,170 --> 00:16:02,940
configuration so when you say the pain

382
00:16:02,940 --> 00:16:05,310
is input or output there is nothing

383
00:16:05,310 --> 00:16:08,190
tells the operating system that the pin

384
00:16:08,190 --> 00:16:10,290
got multiplex or the pin got can

385
00:16:10,290 --> 00:16:12,600
reconfigure and that's missing is a

386
00:16:12,600 --> 00:16:15,320
problem and we show it is a problem

387
00:16:15,320 --> 00:16:18,570
magic next yeah so before I say let's

388
00:16:18,570 --> 00:16:21,089
look actually how PLC is talking with

389
00:16:21,089 --> 00:16:26,370
his i/o in very very very basic right so

390
00:16:26,370 --> 00:16:29,220
usually you have a PLC runtime what will

391
00:16:29,220 --> 00:16:30,510
happen is that you are uploading your

392
00:16:30,510 --> 00:16:32,430
logic again we have this sample logic

393
00:16:32,430 --> 00:16:34,019
and we have some inputs and then

394
00:16:34,019 --> 00:16:36,149
updating some outputs what will happen

395
00:16:36,149 --> 00:16:38,010
is that the PLC read the logic and knows

396
00:16:38,010 --> 00:16:41,339
that okay so thin 24 is inputs and thin

397
00:16:41,339 --> 00:16:44,190
22 is output so I have to prepare it to

398
00:16:44,190 --> 00:16:46,740
be input and output and then after it's

399
00:16:46,740 --> 00:16:48,990
going to update out with every some

400
00:16:48,990 --> 00:16:51,630
seconds and well first of all you can't

401
00:16:51,630 --> 00:16:54,060
just talk to the i/o in a physical

402
00:16:54,060 --> 00:16:55,769
memory if you don't have MMU in your

403
00:16:55,769 --> 00:16:59,279
hardware if you do have an MU in your

404
00:16:59,279 --> 00:17:01,050
hardware and so what will happen is that

405
00:17:01,050 --> 00:17:03,899
the PLC will ask various address of

406
00:17:03,899 --> 00:17:06,270
visual memory of the i/o which I can

407
00:17:06,270 --> 00:17:08,609
write and then based on that it's right

408
00:17:08,609 --> 00:17:11,609
to values here that's very very basic

409
00:17:11,609 --> 00:17:15,209
form of it next okay so you have to

410
00:17:15,209 --> 00:17:18,949
press yeah that's it that's it okay so

411
00:17:18,949 --> 00:17:21,630
so what will happen here is that again

412
00:17:21,630 --> 00:17:23,099
we are going to actually show it in

413
00:17:23,099 --> 00:17:25,020
animation and show you the problem too

414
00:17:25,020 --> 00:17:27,359
so that's something that we have a PLC

415
00:17:27,359 --> 00:17:30,450
runtime and so here we are assuming that

416
00:17:30,450 --> 00:17:31,590
you are directly tracking with the

417
00:17:31,590 --> 00:17:32,820
operating system but it might be a

418
00:17:32,820 --> 00:17:34,710
driver or something else that you are

419
00:17:34,710 --> 00:17:36,780
talking so it's not it might be not the

420
00:17:36,780 --> 00:17:38,400
case that you are directly talking to it

421
00:17:38,400 --> 00:17:40,320
so what will happen is that PLC says

422
00:17:40,320 --> 00:17:42,840
okay I have to use this I own memories

423
00:17:42,840 --> 00:17:44,640
right so these are your memories have to

424
00:17:44,640 --> 00:17:46,350
be provided for me you can talk directly

425
00:17:46,350 --> 00:17:48,659
to physical memory because we assume

426
00:17:48,659 --> 00:17:51,419
that you have MMU and then it will add

427
00:17:51,419 --> 00:17:53,940
operating system or whatever to map this

428
00:17:53,940 --> 00:17:57,120
physical I own memory not if you are too

429
00:17:57,120 --> 00:17:59,789
fat can you not hold it yes I mentioned

430
00:17:59,789 --> 00:18:02,220
it is combined now you just went into it

431
00:18:02,220 --> 00:18:08,159
but don't do it too bad so so now so you

432
00:18:08,159 --> 00:18:10,799
have a physical memory the the PLC

433
00:18:10,799 --> 00:18:13,320
runtime or driver or whatever is asked

434
00:18:13,320 --> 00:18:16,140
for visual physical audio memory as a

435
00:18:16,140 --> 00:18:18,299
visual memory and what will happen is

436
00:18:18,299 --> 00:18:19,620
that you basically have a mirroring

437
00:18:19,620 --> 00:18:22,230
between these two so then here is let's

438
00:18:22,230 --> 00:18:24,270
assume that this is our logic so you we

439
00:18:24,270 --> 00:18:26,990
want to LED blink every five seconds and

440
00:18:26,990 --> 00:18:31,230
the inputs pin which is pin 24 is the

441
00:18:31,230 --> 00:18:34,320
input pin and pin 22 is output pin so

442
00:18:34,320 --> 00:18:36,390
that's actually basically the logic you

443
00:18:36,390 --> 00:18:39,690
see here so pin 24 input pin 22 outputs

444
00:18:39,690 --> 00:18:41,669
and the pin 22 for example here

445
00:18:41,669 --> 00:18:44,039
connected to LED so you are turning on

446
00:18:44,039 --> 00:18:45,960
an opera LED every five seconds what

447
00:18:45,960 --> 00:18:48,090
will happen is that fresh you have to

448
00:18:48,090 --> 00:18:50,309
config the pin the pin configuration so

449
00:18:50,309 --> 00:18:52,980
you say next now I did now it's time

450
00:18:52,980 --> 00:18:56,130
okay so you are saying okay pin 24 is an

451
00:18:56,130 --> 00:18:58,919
input pin so we write value 0 in a state

452
00:18:58,919 --> 00:19:02,669
of 13 so the pin state is 0 which means

453
00:19:02,669 --> 00:19:06,360
pin is inputs and think 22 is output pin

454
00:19:06,360 --> 00:19:09,659
so we write value 1 to it and then you

455
00:19:09,659 --> 00:19:11,130
basically write it to a vient rely on

456
00:19:11,130 --> 00:19:13,710
memory and then basically once you write

457
00:19:13,710 --> 00:19:15,779
it video erm you you are actually

458
00:19:15,779 --> 00:19:18,720
writing to the physical memory the same

459
00:19:18,720 --> 00:19:22,440
value right fine then you are going to

460
00:19:22,440 --> 00:19:24,029
read the edges because well the logic

461
00:19:24,029 --> 00:19:27,149
saying while the pin 22 scene 24 which

462
00:19:27,149 --> 00:19:29,039
is an input is true so you are reading

463
00:19:29,039 --> 00:19:31,590
values from visual memory but actually

464
00:19:31,590 --> 00:19:33,120
this value is coming from physical

465
00:19:33,120 --> 00:19:36,600
memory and well then you are going to

466
00:19:36,600 --> 00:19:40,230
change the i/o every 5 second turn on an

467
00:19:40,230 --> 00:19:42,630
OP LED so basically up means writing

468
00:19:42,630 --> 00:19:46,470
value 0 or R means value 1 to the to the

469
00:19:46,470 --> 00:19:48,179
to the re open output screen so

470
00:19:48,179 --> 00:19:51,570
basically turn on and off LED and this

471
00:19:51,570 --> 00:19:53,460
once you write this value it will get

472
00:19:53,460 --> 00:19:54,899
written to the physical memory again

473
00:19:54,899 --> 00:19:56,120
okay

474
00:19:56,120 --> 00:19:59,000
so far so good everything is fine but

475
00:19:59,000 --> 00:20:02,059
there is a problem go forward

476
00:20:02,059 --> 00:20:07,779
yeah moe moe moe moe

477
00:20:08,860 --> 00:20:13,669
so okay so now let's go back so let's

478
00:20:13,669 --> 00:20:16,400
assume now we are a tracker and what we

479
00:20:16,400 --> 00:20:19,580
do is that so we had team 22 ads outs

480
00:20:19,580 --> 00:20:21,919
which you remember so the value in the

481
00:20:21,919 --> 00:20:25,510
state register was one this time next

482
00:20:25,510 --> 00:20:27,890
this time what we do is that we are

483
00:20:27,890 --> 00:20:31,520
going to say pin 22 is the input so we

484
00:20:31,520 --> 00:20:33,559
change the configuration of the team

485
00:20:33,559 --> 00:20:36,679
from being outputs to inputs and we

486
00:20:36,679 --> 00:20:39,200
write it to the state register and of

487
00:20:39,200 --> 00:20:41,179
course this value will get mapped the

488
00:20:41,179 --> 00:20:44,809
physical memory so you have now 0 14 22

489
00:20:44,809 --> 00:20:47,600
which means this pin is inputs it is not

490
00:20:47,600 --> 00:20:50,899
anymore outfits but nobody knows because

491
00:20:50,899 --> 00:20:52,429
you don't have any kind of interrupt or

492
00:20:52,429 --> 00:20:54,470
feedback to tell the operating system or

493
00:20:54,470 --> 00:20:56,380
whatever that this pin is not anymore

494
00:20:56,380 --> 00:21:00,620
output P so then the PHP runtime doesn't

495
00:21:00,620 --> 00:21:02,870
know about it so it continues to do the

496
00:21:02,870 --> 00:21:04,789
logic which we had five second turn on

497
00:21:04,789 --> 00:21:10,490
and off led so yes so this is getting

498
00:21:10,490 --> 00:21:13,149
map net right next trying to write and

499
00:21:13,149 --> 00:21:15,679
writing a value 0 or 1 so it's write

500
00:21:15,679 --> 00:21:18,590
value 0 or 1 to turn on and off led but

501
00:21:18,590 --> 00:21:20,390
here's the problem the problem happening

502
00:21:20,390 --> 00:21:23,690
here once the value want to get written

503
00:21:23,690 --> 00:21:24,740
to the physical memory

504
00:21:24,740 --> 00:21:29,740
next you will not have to write and

505
00:21:29,740 --> 00:21:34,010
that's a problem so this is why we call

506
00:21:34,010 --> 00:21:36,110
it a memory illusion because what you

507
00:21:36,110 --> 00:21:37,730
see in the virtual memory which

508
00:21:37,730 --> 00:21:39,559
available to any software in the

509
00:21:39,559 --> 00:21:42,080
operating system you see value 0 or 1

510
00:21:42,080 --> 00:21:44,149
but actually this value never changed

511
00:21:44,149 --> 00:21:47,570
here so in physical world you don't have

512
00:21:47,570 --> 00:21:50,059
it in virtual world you have it so even

513
00:21:50,059 --> 00:21:51,590
if you go check the values what you

514
00:21:51,590 --> 00:21:54,260
wrote to the to the virtual memory you

515
00:21:54,260 --> 00:21:55,760
see everything is fine but actually in

516
00:21:55,760 --> 00:21:58,190
physical memory you don't why because

517
00:21:58,190 --> 00:21:59,720
you change the state of a pin to the

518
00:21:59,720 --> 00:22:02,090
inputs CPU doesn't accept right

519
00:22:02,090 --> 00:22:04,669
operation to the input field but the

520
00:22:04,669 --> 00:22:07,159
problem here is a problem it doesn't

521
00:22:07,159 --> 00:22:09,560
tell you that I don't accept it

522
00:22:09,560 --> 00:22:13,460
it just say thing is fine so no feedback

523
00:22:13,460 --> 00:22:17,330
no no other so normally what you assume

524
00:22:17,330 --> 00:22:19,340
is that once you fail to write to the

525
00:22:19,340 --> 00:22:21,650
physical memory you expect some kind of

526
00:22:21,650 --> 00:22:23,840
failure I don't know for example copying

527
00:22:23,840 --> 00:22:27,020
a file to your SD or memory card once

528
00:22:27,020 --> 00:22:29,630
you like take it out suddenly you get an

529
00:22:29,630 --> 00:22:32,390
error saying hey remember the SD card or

530
00:22:32,390 --> 00:22:34,910
USB yes this is not anymore available

531
00:22:34,910 --> 00:22:38,860
this is not the case that's a problem so

532
00:22:38,860 --> 00:22:42,530
so what we talked about was that well we

533
00:22:42,530 --> 00:22:44,690
wanted to we know about all existing

534
00:22:44,690 --> 00:22:47,690
defenses so we know about otoscope ejr

535
00:22:47,690 --> 00:22:49,640
which detecting function hooking we know

536
00:22:49,640 --> 00:22:52,490
about like duper gang gear or software

537
00:22:52,490 --> 00:22:54,800
symbiotes which basically verify the

538
00:22:54,800 --> 00:22:57,140
integrity of executable part of the plc

539
00:22:57,140 --> 00:22:59,900
runtime so and of course we know there

540
00:22:59,900 --> 00:23:01,820
are some logic checksums and stuff so we

541
00:23:01,820 --> 00:23:03,530
don't want to do any of these things who

542
00:23:03,530 --> 00:23:05,810
King I don't know modifying binaries or

543
00:23:05,810 --> 00:23:09,260
like changing the logic so we want and

544
00:23:09,260 --> 00:23:10,850
actually we want to use this weakness

545
00:23:10,850 --> 00:23:12,530
this problem which we explain now there

546
00:23:12,530 --> 00:23:15,200
is no feedback so there where it comes

547
00:23:15,200 --> 00:23:16,820
the pin control attack and basically pin

548
00:23:16,820 --> 00:23:18,590
controllers actives consists of two

549
00:23:18,590 --> 00:23:21,650
parts so it's not just one thing it's to

550
00:23:21,650 --> 00:23:24,020
seen so transport pin configuration

551
00:23:24,020 --> 00:23:27,050
attack which is basically we we exploit

552
00:23:27,050 --> 00:23:29,450
the configuration of the pins how we

553
00:23:29,450 --> 00:23:33,230
describe it like in the PLC and the next

554
00:23:33,230 --> 00:23:35,090
is a pin multiplexing attack and that's

555
00:23:35,090 --> 00:23:36,800
the one which is interesting which we

556
00:23:36,800 --> 00:23:38,240
show later that how we are manipulating

557
00:23:38,240 --> 00:23:42,410
the analog data in the in the PLC so and

558
00:23:42,410 --> 00:23:44,780
of course once we do this kind of attack

559
00:23:44,780 --> 00:23:47,690
the PLC never knows about it and now I'm

560
00:23:47,690 --> 00:23:51,520
going to explain how they are work but

561
00:23:51,520 --> 00:23:54,260
before we have two variants as

562
00:23:54,260 --> 00:23:56,270
implementation of our attack first one

563
00:23:56,270 --> 00:23:57,770
is the rootkit variants and another one

564
00:23:57,770 --> 00:23:59,660
is a malicious C code which we converted

565
00:23:59,660 --> 00:24:02,510
it to the shellcode for a PLC which

566
00:24:02,510 --> 00:24:04,190
basically do the same there is a

567
00:24:04,190 --> 00:24:05,780
difference between them the difference

568
00:24:05,780 --> 00:24:10,340
is that in a rootkit variant we have we

569
00:24:10,340 --> 00:24:11,900
need for example root access of course

570
00:24:11,900 --> 00:24:13,460
because it's a rootkit right so if you

571
00:24:13,460 --> 00:24:17,290
go next yet so as unit you village and

572
00:24:17,290 --> 00:24:20,420
you need some knowledge of SOC registers

573
00:24:20,420 --> 00:24:22,850
it took us for any new PLC

574
00:24:22,850 --> 00:24:25,639
- cause for a week - to get like enough

575
00:24:25,639 --> 00:24:28,639
information about SOC registers I don't

576
00:24:28,639 --> 00:24:30,200
think a state sponsor detectives need

577
00:24:30,200 --> 00:24:33,200
that much time and the next one is the

578
00:24:33,200 --> 00:24:36,440
knowledge of mathematics I think I do it

579
00:24:36,440 --> 00:24:38,720
thank ya the another one is a knowledge

580
00:24:38,720 --> 00:24:40,580
of mapping between our yoking and the

581
00:24:40,580 --> 00:24:43,250
logic so this is important but is

582
00:24:43,250 --> 00:24:44,870
available in a PLC once you are

583
00:24:44,870 --> 00:24:47,029
uploading the the logic to the PLC

584
00:24:47,029 --> 00:24:48,950
basically the logic describe all of

585
00:24:48,950 --> 00:24:50,419
these things the mapping between are

586
00:24:50,419 --> 00:24:52,399
your pins and the logic so it is

587
00:24:52,399 --> 00:24:55,820
available there for anybody to read the

588
00:24:55,820 --> 00:24:57,649
second variant which basically doesn't

589
00:24:57,649 --> 00:24:59,450
need from taxes but it's just need to X

590
00:24:59,450 --> 00:25:02,240
equal privileges PLC runtime so anything

591
00:25:02,240 --> 00:25:04,549
that your PHP runtime is running we need

592
00:25:04,549 --> 00:25:06,559
just equal privilege and of course we

593
00:25:06,559 --> 00:25:08,899
saw all of them we need to have system

594
00:25:08,899 --> 00:25:10,399
level access so we are assuming you're

595
00:25:10,399 --> 00:25:13,460
kind of having a control flow attack

596
00:25:13,460 --> 00:25:15,320
inside your PLC to get access to it so

597
00:25:15,320 --> 00:25:17,750
that's it or let's say you are using a

598
00:25:17,750 --> 00:25:19,519
backdoor passwords also we are in

599
00:25:19,519 --> 00:25:21,649
control vertex because we like mod

600
00:25:21,649 --> 00:25:23,059
second variants but let's look at the

601
00:25:23,059 --> 00:25:27,019
first variant press forget that you are

602
00:25:27,019 --> 00:25:30,950
a parent so in the first variant we want

603
00:25:30,950 --> 00:25:33,950
to precisely manipulate the re operation

604
00:25:33,950 --> 00:25:37,279
okay so we are going to use something

605
00:25:37,279 --> 00:25:40,070
called processor debug registers it is

606
00:25:40,070 --> 00:25:43,190
not something it was out there I think

607
00:25:43,190 --> 00:25:47,149
since 2006 or 7 first time was a frack

608
00:25:47,149 --> 00:25:49,549
magazine there was an article about it -

609
00:25:49,549 --> 00:25:51,799
designing a rootkit based on well mostly

610
00:25:51,799 --> 00:25:54,799
for Intel our structure but well we we

611
00:25:54,799 --> 00:25:56,690
used processor debug using our route

612
00:25:56,690 --> 00:25:59,210
sheets in ARM architecture to do there

613
00:25:59,210 --> 00:26:03,320
our attack well what are it well

614
00:26:03,320 --> 00:26:07,429
basically normally what you have in

615
00:26:07,429 --> 00:26:09,080
function hooking which magic describe

616
00:26:09,080 --> 00:26:11,419
you are like intercepting a function

617
00:26:11,419 --> 00:26:13,580
call and once you might change the

618
00:26:13,580 --> 00:26:15,379
arguments of the function to do

619
00:26:15,379 --> 00:26:18,019
something you want or like divert the

620
00:26:18,019 --> 00:26:20,029
code execution flow and do something

621
00:26:20,029 --> 00:26:22,480
else instead of the original operation

622
00:26:22,480 --> 00:26:25,490
what we do is we are not doing

623
00:26:25,490 --> 00:26:27,980
functionally what we do we intercept in

624
00:26:27,980 --> 00:26:30,769
our rootkit variants we intercept access

625
00:26:30,769 --> 00:26:33,919
to i/o physical or visual memory so you

626
00:26:33,919 --> 00:26:36,559
remember we mapped i/o address well

627
00:26:36,559 --> 00:26:38,120
we put those addresses into the debugger

628
00:26:38,120 --> 00:26:41,799
Charlotte go to the next page oops

629
00:26:41,799 --> 00:26:45,320
yeah so we believe that we come back by

630
00:26:45,320 --> 00:26:47,120
combining a pin configuration problem

631
00:26:47,120 --> 00:26:48,470
which you don't have any feedback and

632
00:26:48,470 --> 00:26:51,590
the processor debug user we actually can

633
00:26:51,590 --> 00:26:54,230
do that like how well we put the

634
00:26:54,230 --> 00:26:56,299
argument again we show all your memory

635
00:26:56,299 --> 00:26:58,009
address which you are going to write the

636
00:26:58,009 --> 00:27:01,100
values and get later it's get written to

637
00:27:01,100 --> 00:27:02,840
the physical memory we are putting those

638
00:27:02,840 --> 00:27:04,370
addresses into the debug register and

639
00:27:04,370 --> 00:27:07,129
then once the PLC wants to do something

640
00:27:07,129 --> 00:27:09,799
we manipulate the configuration of the

641
00:27:09,799 --> 00:27:11,330
pink or multiplexing of the things so

642
00:27:11,330 --> 00:27:14,149
here's the example how it works let's

643
00:27:14,149 --> 00:27:17,990
say you are going to write turn on and

644
00:27:17,990 --> 00:27:21,139
off LED controlled by a PLC every 5

645
00:27:21,139 --> 00:27:24,080
seconds I want at the attacker to change

646
00:27:24,080 --> 00:27:27,529
it to work every 10 seconds like turn on

647
00:27:27,529 --> 00:27:31,039
and off a LED so what I do and of course

648
00:27:31,039 --> 00:27:32,779
I want to be a still so I don't want you

649
00:27:32,779 --> 00:27:35,029
know for example let's say it's not LED

650
00:27:35,029 --> 00:27:37,190
this is a gate you're opening and

651
00:27:37,190 --> 00:27:39,619
closing so it's like I want you don't

652
00:27:39,619 --> 00:27:41,600
know later that I didn't close and open

653
00:27:41,600 --> 00:27:44,210
the gate - so what I do for right so I

654
00:27:44,210 --> 00:27:46,070
have to both do manipulation up right

655
00:27:46,070 --> 00:27:48,710
and read operation so what I do is here

656
00:27:48,710 --> 00:27:51,049
for example I put the i/o visual memory

657
00:27:51,049 --> 00:27:53,600
address into the debug visitor and it

658
00:27:53,600 --> 00:27:56,210
let it be there the PLC is start to

659
00:27:56,210 --> 00:27:59,450
execute a logic it intercept it noticed

660
00:27:59,450 --> 00:28:01,700
so next step is that the PS is going to

661
00:28:01,700 --> 00:28:04,309
write the i/o we intercept the write

662
00:28:04,309 --> 00:28:06,769
operation but we don't change anything

663
00:28:06,769 --> 00:28:09,110
there what we do change is that we

664
00:28:09,110 --> 00:28:10,909
change the state of a team which is

665
00:28:10,909 --> 00:28:12,559
output screen because you are writing Q

666
00:28:12,559 --> 00:28:14,869
to an input speed so we changed the

667
00:28:14,869 --> 00:28:17,539
state we switched it to input speed and

668
00:28:17,539 --> 00:28:19,580
then we'll let the execution continue

669
00:28:19,580 --> 00:28:21,950
what will happen is that the plc going

670
00:28:21,950 --> 00:28:23,990
to write to the visual memory but this

671
00:28:23,990 --> 00:28:25,970
pin which is plc is going to write is

672
00:28:25,970 --> 00:28:28,190
not anymore output speed because we

673
00:28:28,190 --> 00:28:30,879
change the state from outputs to inputs

674
00:28:30,879 --> 00:28:34,129
doesn't work so one of your write

675
00:28:34,129 --> 00:28:36,200
operations doesn't work next time we can

676
00:28:36,200 --> 00:28:37,999
just change it to back to the input pin

677
00:28:37,999 --> 00:28:39,710
to the output pin and it's working

678
00:28:39,710 --> 00:28:40,700
perfectly it's fine

679
00:28:40,700 --> 00:28:42,110
so it's like we are basically changing

680
00:28:42,110 --> 00:28:44,899
the larger process to something else for

681
00:28:44,899 --> 00:28:46,190
read manipulation it's a little bit

682
00:28:46,190 --> 00:28:48,470
harder because we've allocation actually

683
00:28:48,470 --> 00:28:49,940
happening lots of nuts

684
00:28:49,940 --> 00:28:51,769
more often compared to the readwrite

685
00:28:51,769 --> 00:28:54,169
manipulation so what we do is again we

686
00:28:54,169 --> 00:28:56,990
put the the the are you register related

687
00:28:56,990 --> 00:28:59,419
to read back reading values to the debug

688
00:28:59,419 --> 00:29:02,480
register and then we let the PLC read

689
00:29:02,480 --> 00:29:04,669
the values from the oil once we notice

690
00:29:04,669 --> 00:29:06,440
that the PLC is going to read the values

691
00:29:06,440 --> 00:29:08,990
we change the state of the input spin

692
00:29:08,990 --> 00:29:10,460
which you are reading because you are

693
00:29:10,460 --> 00:29:12,950
always reading from input P we change a

694
00:29:12,950 --> 00:29:14,629
set of an input pin to the output stream

695
00:29:14,629 --> 00:29:17,149
and we write the value we want to write

696
00:29:17,149 --> 00:29:19,370
so we can write whatever if you are

697
00:29:19,370 --> 00:29:20,870
reading a temperature from analog data

698
00:29:20,870 --> 00:29:23,059
we can just change the values that write

699
00:29:23,059 --> 00:29:25,480
something else in a visual memory and

700
00:29:25,480 --> 00:29:28,009
the read continues but I drew the

701
00:29:28,009 --> 00:29:34,730
already so well we will have some demo

702
00:29:34,730 --> 00:29:36,980
actually three right now will have four

703
00:29:36,980 --> 00:29:40,250
totally but three of them now and for

704
00:29:40,250 --> 00:29:43,100
that you have to explain what logic they

705
00:29:43,100 --> 00:29:46,039
are so simple logic we had again every

706
00:29:46,039 --> 00:29:49,220
five second we want to LED blink okay if

707
00:29:49,220 --> 00:29:51,710
this is an example we have in a tree the

708
00:29:51,710 --> 00:29:55,370
depressed two demos we have so we want

709
00:29:55,370 --> 00:29:58,610
the LED blink every five seconds and and

710
00:29:58,610 --> 00:30:03,950
that's it's Abdellah T blinking and we

711
00:30:03,950 --> 00:30:06,590
have a real attack against a real PLC

712
00:30:06,590 --> 00:30:09,169
and for this one we have a LED which

713
00:30:09,169 --> 00:30:11,149
blinking every two seconds and we want

714
00:30:11,149 --> 00:30:15,259
to change to for example not blinking

715
00:30:15,259 --> 00:30:17,059
every time it once we want it links

716
00:30:17,059 --> 00:30:21,710
every time v wants okay and that's the

717
00:30:21,710 --> 00:30:24,500
example of it so this was the first test

718
00:30:24,500 --> 00:30:27,440
that we had for a like for the first

719
00:30:27,440 --> 00:30:30,200
video which will show it to you and this

720
00:30:30,200 --> 00:30:32,600
is the second video we covered the name

721
00:30:32,600 --> 00:30:34,970
of the company and that one is not the

722
00:30:34,970 --> 00:30:40,269
company name was just power source

723
00:30:50,700 --> 00:30:52,920
stop working

724
00:30:52,920 --> 00:30:55,480
no you have to push it to the other vid

725
00:30:55,480 --> 00:30:59,200
so sorry I need to move eternal yet

726
00:30:59,200 --> 00:31:04,500
screen and risk uh-huh

727
00:31:04,500 --> 00:31:11,980
so let's go back with it so so in this

728
00:31:11,980 --> 00:31:15,130
example so we have a LEDs turning on and

729
00:31:15,130 --> 00:31:17,410
up early every five seconds each time we

730
00:31:17,410 --> 00:31:19,510
are going to do kind of a dot attack so

731
00:31:19,510 --> 00:31:22,330
we don't let the PLC control it but we

732
00:31:22,330 --> 00:31:24,610
show you that we are intercepting every

733
00:31:24,610 --> 00:31:27,760
time PLC run time want to turn on an OP

734
00:31:27,760 --> 00:31:30,430
LED so every five second led is going to

735
00:31:30,430 --> 00:31:32,500
turn on and off so if the value is true

736
00:31:32,500 --> 00:31:33,310
here daily

737
00:31:33,310 --> 00:31:42,460
so right now LEDs on and wait yeah PLC

738
00:31:42,460 --> 00:31:46,540
run time here the value is true which

739
00:31:46,540 --> 00:31:48,550
means the LED is on if the value is

740
00:31:48,550 --> 00:31:49,000
false

741
00:31:49,000 --> 00:31:51,070
it means the LED is off okay so that's

742
00:31:51,070 --> 00:31:52,810
the basic thing so you have just led

743
00:31:52,810 --> 00:31:56,680
turning on and off every five seconds so

744
00:31:56,680 --> 00:31:59,200
then we are going to actually run our

745
00:31:59,200 --> 00:32:09,970
routine it is moving forward I think we

746
00:32:09,970 --> 00:32:11,200
are just having loaded we're just

747
00:32:11,200 --> 00:32:14,200
extending all over so not important

748
00:32:14,200 --> 00:32:17,080
right here now so as you can see it's

749
00:32:17,080 --> 00:32:19,060
still led standing on an upper five

750
00:32:19,060 --> 00:32:21,610
second everything is fine but now we are

751
00:32:21,610 --> 00:32:23,800
going to take control of it we don't let

752
00:32:23,800 --> 00:32:26,680
the LED any more blinking but the PLC

753
00:32:26,680 --> 00:32:29,200
runtime doesn't know that why because we

754
00:32:29,200 --> 00:32:33,960
change the configuration of the P so 21

755
00:32:33,960 --> 00:32:41,650
yeah and so now the operation the

756
00:32:41,650 --> 00:32:43,150
physical process actually are not the

757
00:32:43,150 --> 00:32:44,740
LED as you can see is not blinking

758
00:32:44,740 --> 00:32:48,070
anymore right but we show you we just

759
00:32:48,070 --> 00:32:50,260
intentionally made a lot locks in the

760
00:32:50,260 --> 00:32:53,740
kernel like to show you that actually we

761
00:32:53,740 --> 00:32:56,230
are intercepting every time PHC runtime

762
00:32:56,230 --> 00:32:59,250
is writing so are you

763
00:33:03,749 --> 00:33:06,579
so you can see here but we are we are

764
00:33:06,579 --> 00:33:08,709
not letting the PC because we basically

765
00:33:08,709 --> 00:33:13,659
a intercept every call operation but we

766
00:33:13,659 --> 00:33:15,249
don't let the right operation actually

767
00:33:15,249 --> 00:33:21,489
happen for accident accessing the PLC we

768
00:33:21,489 --> 00:33:23,589
change the functionality of the PLC in

769
00:33:23,589 --> 00:33:27,219
output pin to an input pin yeah and

770
00:33:27,219 --> 00:33:31,629
there is a personís line every time but

771
00:33:31,629 --> 00:33:36,129
yeah so yeah as you can see in the

772
00:33:36,129 --> 00:33:38,019
physical process the PLC runtime here

773
00:33:38,019 --> 00:33:39,729
saying the value is false

774
00:33:39,729 --> 00:33:43,690
or wait for it wait true but actually it

775
00:33:43,690 --> 00:33:46,599
is not true the LED is not on and off

776
00:33:46,599 --> 00:33:48,609
every five seconds what we see is that

777
00:33:48,609 --> 00:33:50,440
the LED is turning on and off every five

778
00:33:50,440 --> 00:33:55,929
second but it's not so this one was just

779
00:33:55,929 --> 00:33:57,879
a kind of a dot effect so we then let

780
00:33:57,879 --> 00:33:59,799
the process continues but what about we

781
00:33:59,799 --> 00:34:02,049
want to change the actual process so

782
00:34:02,049 --> 00:34:04,119
let's say right now we were doing every

783
00:34:04,119 --> 00:34:05,829
five seconds the logic but this time we

784
00:34:05,829 --> 00:34:07,959
want to change the logic to to work

785
00:34:07,959 --> 00:34:10,929
every to change every instead of every

786
00:34:10,929 --> 00:34:12,819
five second to bring every one second so

787
00:34:12,819 --> 00:34:14,768
here the PLT run time here in the output

788
00:34:14,768 --> 00:34:18,009
is false then get true it means LEDs on

789
00:34:18,009 --> 00:34:21,609
true LEDs on so it's blink every five

790
00:34:21,609 --> 00:34:23,918
second and then we load our basically

791
00:34:23,918 --> 00:34:25,899
route sheet design we are actually

792
00:34:25,899 --> 00:34:28,059
manipulating the process we manipulating

793
00:34:28,059 --> 00:34:31,899
in the way we want okay so now it is

794
00:34:31,899 --> 00:34:33,460
blinking every two second but what you

795
00:34:33,460 --> 00:34:35,799
see here is true for five seconds and

796
00:34:35,799 --> 00:34:39,609
false for five seconds so the PLC oops

797
00:34:39,609 --> 00:34:44,399
can you go just go back some seconds yes

798
00:34:44,399 --> 00:34:50,859
so again you see it play so see that

799
00:34:50,859 --> 00:34:53,529
again it's blinking but actually the

800
00:34:53,529 --> 00:34:55,960
compare the software is seeing that

801
00:34:55,960 --> 00:34:59,140
everything is fine PLC is running every

802
00:34:59,140 --> 00:35:00,700
five second LED on and off but actually

803
00:35:00,700 --> 00:35:02,410
in physical world it is not the case

804
00:35:02,410 --> 00:35:06,009
right so later there were some comments

805
00:35:06,009 --> 00:35:07,630
I think in some conferences and we

806
00:35:07,630 --> 00:35:09,490
decided to actually have a demo a real

807
00:35:09,490 --> 00:35:11,920
PhD as well it just just quickly

808
00:35:11,920 --> 00:35:14,680
like last week and we covered the name

809
00:35:14,680 --> 00:35:20,380
of the render thank you and yeah and

810
00:35:20,380 --> 00:35:23,140
thank you my student my master student

811
00:35:23,140 --> 00:35:24,579
who is now working on his thesis for

812
00:35:24,579 --> 00:35:27,010
defense against this kind of attack he

813
00:35:27,010 --> 00:35:28,569
just actually asked me to make this

814
00:35:28,569 --> 00:35:32,319
video for us in Dedes so again this time

815
00:35:32,319 --> 00:35:34,569
we are turning on and off LED every

816
00:35:34,569 --> 00:35:36,190
every two seconds here

817
00:35:36,190 --> 00:35:38,349
our attack here is a little bit slower

818
00:35:38,349 --> 00:35:40,329
so it take time until it's kicking but

819
00:35:40,329 --> 00:35:43,510
we see that it's a true LEDs on false

820
00:35:43,510 --> 00:35:45,970
LEDs off right so that's very simple and

821
00:35:45,970 --> 00:35:48,730
then we basically load our attack tanks

822
00:35:48,730 --> 00:35:50,950
and ready for making if you watch this

823
00:35:50,950 --> 00:35:58,329
later so now we decide the LED to stop

824
00:35:58,329 --> 00:36:02,589
and not working anymore and so just you

825
00:36:02,589 --> 00:36:04,510
just saw it very fast filling but then

826
00:36:04,510 --> 00:36:06,819
we take control of it so LED is now true

827
00:36:06,819 --> 00:36:10,000
but it's not true then we decide to turn

828
00:36:10,000 --> 00:36:12,670
on LED because we decided it so let's

829
00:36:12,670 --> 00:36:15,430
say LEDs start again but actually right

830
00:36:15,430 --> 00:36:17,799
now it doesn't work so we say any blink

831
00:36:17,799 --> 00:36:20,470
an LED is blinking now so but in the

832
00:36:20,470 --> 00:36:23,770
control software there well the PLC

833
00:36:23,770 --> 00:36:26,290
runtime assuming the defib the control

834
00:36:26,290 --> 00:36:27,730
software and the PC entire assuming

835
00:36:27,730 --> 00:36:29,710
everything is fine you don't touch

836
00:36:29,710 --> 00:36:31,240
anything and we don't touch the logic

837
00:36:31,240 --> 00:36:34,299
there so again we say LED a stop tell

838
00:36:34,299 --> 00:36:36,309
you stop but you see here that the the

839
00:36:36,309 --> 00:36:38,349
LED for example is true but it's not

840
00:36:38,349 --> 00:36:41,500
because LEDs not on so that's the

841
00:36:41,500 --> 00:36:43,599
problem so you see completely different

842
00:36:43,599 --> 00:36:45,220
things with what's happening in the

843
00:36:45,220 --> 00:36:47,079
software but what's happening is in the

844
00:36:47,079 --> 00:36:49,420
physical world so basically again that

845
00:36:49,420 --> 00:36:51,520
memory illusion reflect itself so you

846
00:36:51,520 --> 00:36:53,230
see something else in a physical world

847
00:36:53,230 --> 00:36:55,270
but the operator sees something else in

848
00:36:55,270 --> 00:36:58,420
the engine he saw so we again we decide

849
00:36:58,420 --> 00:37:00,430
so you read it several times to just

850
00:37:00,430 --> 00:37:03,220
show that we decide when the PLC runtime

851
00:37:03,220 --> 00:37:07,359
to have to turn on and off the LED any

852
00:37:07,359 --> 00:37:11,319
close it I think we can one will have

853
00:37:11,319 --> 00:37:20,270
another them close this one

854
00:37:20,270 --> 00:37:22,330
you

855
00:37:31,470 --> 00:37:35,730
so you had three demos so magic you want

856
00:37:35,730 --> 00:37:38,060
to add some yep so before starting

857
00:37:38,060 --> 00:37:44,100
attacking the actually the PLC we start

858
00:37:44,100 --> 00:37:46,500
by uh by analyzing the the PLC one time

859
00:37:46,500 --> 00:37:49,650
as you may know the the PLC binaries are

860
00:37:49,650 --> 00:37:51,810
not very well protected but in one of

861
00:37:51,810 --> 00:37:56,550
the case we will be working on on you

862
00:37:56,550 --> 00:37:59,010
know a binary which was based which had

863
00:37:59,010 --> 00:38:00,630
you know basic protections against

864
00:38:00,630 --> 00:38:03,390
aesthetic analysis and dynamic analysis

865
00:38:03,390 --> 00:38:05,280
for example in this case which was quite

866
00:38:05,280 --> 00:38:07,260
surprising in this case the binary is

867
00:38:07,260 --> 00:38:10,040
simply packed as you can see neither pro

868
00:38:10,040 --> 00:38:13,470
the about nineteen ninety four percent

869
00:38:13,470 --> 00:38:15,420
of the binary is data and just few

870
00:38:15,420 --> 00:38:17,610
functions that unpacking the code into

871
00:38:17,610 --> 00:38:19,740
memory and doing the final jump the same

872
00:38:19,740 --> 00:38:21,210
binary from the same vendor was

873
00:38:21,210 --> 00:38:23,130
protected against some anti debug links

874
00:38:23,130 --> 00:38:24,750
as well which was the parent process

875
00:38:24,750 --> 00:38:27,900
attacking to attaching to his child

876
00:38:27,900 --> 00:38:29,760
process so this way the child process

877
00:38:29,760 --> 00:38:33,260
was in the bug bound and it's not allow

878
00:38:33,260 --> 00:38:36,480
another debugger to attach to do you

879
00:38:36,480 --> 00:38:39,630
know the dynamic paralyzes but because

880
00:38:39,630 --> 00:38:41,400
we knew what we were looking for we

881
00:38:41,400 --> 00:38:44,640
didn't try to bypass those those those

882
00:38:44,640 --> 00:38:46,110
protections there were no protections

883
00:38:46,110 --> 00:38:48,150
and very well documented on the Internet

884
00:38:48,150 --> 00:38:51,210
what we did we use s Trace that the

885
00:38:51,210 --> 00:38:53,430
tricky part is using x-rays on some

886
00:38:53,430 --> 00:38:55,020
PLC's is that because we have some

887
00:38:55,020 --> 00:38:57,360
limited amount of resources on on the

888
00:38:57,360 --> 00:38:59,700
PLC's and the s race is generating huge

889
00:38:59,700 --> 00:39:03,780
amounts of output and you know it simply

890
00:39:03,780 --> 00:39:05,760
crashed the PLC so what we did we used

891
00:39:05,760 --> 00:39:08,880
an a slightly modified version of s

892
00:39:08,880 --> 00:39:11,520
raised together just that kind of

893
00:39:11,520 --> 00:39:13,020
information that we are interested for

894
00:39:13,020 --> 00:39:16,710
in in over analysis so as Ali has

895
00:39:16,710 --> 00:39:19,770
already explained we are using the bar

896
00:39:19,770 --> 00:39:21,780
register in our attack this thing has

897
00:39:21,780 --> 00:39:23,840
been introduced in a frac magazine by a

898
00:39:23,840 --> 00:39:26,670
good friend of mine half dead it's a

899
00:39:26,670 --> 00:39:28,170
good good paper if you're interested

900
00:39:28,170 --> 00:39:31,560
interested on this topic so if you

901
00:39:31,560 --> 00:39:33,090
remember the two protection that we have

902
00:39:33,090 --> 00:39:34,830
already discussed about the do

903
00:39:34,830 --> 00:39:36,450
programmer which was a data protection

904
00:39:36,450 --> 00:39:39,780
attack against data hooking and otoscope

905
00:39:39,780 --> 00:39:42,630
EGR which was a defensive solution

906
00:39:42,630 --> 00:39:45,600
against the cultural King so simply

907
00:39:45,600 --> 00:39:49,130
just but just by using the bar resistors

908
00:39:49,130 --> 00:39:52,170
because we are not modifying any codes

909
00:39:52,170 --> 00:39:54,330
into memory we can simply evade otoscope

910
00:39:54,330 --> 00:39:57,570
EGR and because we are loading over our

911
00:39:57,570 --> 00:40:00,090
module of a kernel module or the

912
00:40:00,090 --> 00:40:02,280
non-rigid variants you know dynamically

913
00:40:02,280 --> 00:40:04,650
into memory the otoscope ej the duple

914
00:40:04,650 --> 00:40:07,170
gangers are actually evaded as well so

915
00:40:07,170 --> 00:40:09,870
as you've seen in the demos we are not

916
00:40:09,870 --> 00:40:13,140
doing any further modification and not

917
00:40:13,140 --> 00:40:17,280
any lot logic modification yeah

918
00:40:17,280 --> 00:40:19,980
okay so we actually analyze our routine

919
00:40:19,980 --> 00:40:22,560
at the performance wise because we

920
00:40:22,560 --> 00:40:25,800
wanted to folder to extra work so here

921
00:40:25,800 --> 00:40:29,340
is a bio fluctuation after i/o so this

922
00:40:29,340 --> 00:40:31,080
is not any more simple process which we

923
00:40:31,080 --> 00:40:32,400
were manipulating every parts again

924
00:40:32,400 --> 00:40:34,760
Singh so we put the fastest possible

925
00:40:34,760 --> 00:40:37,530
changes so normally our peers our gates

926
00:40:37,530 --> 00:40:39,810
you could like change every four minutes

927
00:40:39,810 --> 00:40:42,210
second that was the maximal speed what

928
00:40:42,210 --> 00:40:43,710
we put it for example in the logic that

929
00:40:43,710 --> 00:40:46,400
every three minutes I can't change it so

930
00:40:46,400 --> 00:40:49,200
the blue lines are the the one the

931
00:40:49,200 --> 00:40:50,880
normal are you manipulation are you

932
00:40:50,880 --> 00:40:53,010
working and this one is like basically

933
00:40:53,010 --> 00:40:55,920
the PLC which gets manipulate audio you

934
00:40:55,920 --> 00:40:57,930
can see fluctuations almost even less

935
00:40:57,930 --> 00:41:02,370
than actual PHP runtime IO so it's like

936
00:41:02,370 --> 00:41:05,160
it kind of shoe it like you can actually

937
00:41:05,160 --> 00:41:06,840
compute it with the noises in the audio

938
00:41:06,840 --> 00:41:10,410
and that's that but there was some bad

939
00:41:10,410 --> 00:41:11,580
things there was if there are some

940
00:41:11,580 --> 00:41:14,010
shorter first of all for right

941
00:41:14,010 --> 00:41:15,750
manipulation what we are doing so

942
00:41:15,750 --> 00:41:17,580
basically you are turning on and off the

943
00:41:17,580 --> 00:41:19,980
motor or opening closing your gate well

944
00:41:19,980 --> 00:41:21,600
that's not the problem because we had

945
00:41:21,600 --> 00:41:24,540
like nearly 5 percent overhead but the

946
00:41:24,540 --> 00:41:26,430
problem was with read manipulation

947
00:41:26,430 --> 00:41:29,580
because if you are changing a process

948
00:41:29,580 --> 00:41:31,560
for example you have a boiler and you're

949
00:41:31,560 --> 00:41:33,810
turning closing and opening a gate in a

950
00:41:33,810 --> 00:41:35,940
boiler what you want to do is that you

951
00:41:35,940 --> 00:41:38,220
don't want that later operators see

952
00:41:38,220 --> 00:41:40,170
about temperature in the boiler going

953
00:41:40,170 --> 00:41:41,490
higher so you have to do read

954
00:41:41,490 --> 00:41:44,100
manipulation as well so for that we had

955
00:41:44,100 --> 00:41:46,230
a problem the problem was that we had

956
00:41:46,230 --> 00:41:48,420
twenty first twenty three percent CP

957
00:41:48,420 --> 00:41:51,680
overhead and that was too much for us so

958
00:41:51,680 --> 00:41:57,330
what we did was that we think of course

959
00:41:57,330 --> 00:41:58,170
it

960
00:41:58,170 --> 00:42:00,150
rootkits actually we consider real-time

961
00:42:00,150 --> 00:42:03,510
features of the TLC one time so kind of

962
00:42:03,510 --> 00:42:08,490
real-time with it but anyway so what we

963
00:42:08,490 --> 00:42:10,860
did we made a second variant of our

964
00:42:10,860 --> 00:42:13,560
attack so we didn't need to have root

965
00:42:13,560 --> 00:42:15,030
sheet because there are some good

966
00:42:15,030 --> 00:42:16,560
companies around here that they are

967
00:42:16,560 --> 00:42:18,840
verifying the the driver in the kernel

968
00:42:18,840 --> 00:42:20,700
there are some companies or doing that

969
00:42:20,700 --> 00:42:24,240
not all of them and so what we did is

970
00:42:24,240 --> 00:42:27,120
said hey the PLC runtime itself is not

971
00:42:27,120 --> 00:42:29,280
in right usually is not in the kernel

972
00:42:29,280 --> 00:42:31,380
but it's actually doing the same thing

973
00:42:31,380 --> 00:42:34,080
as we do so why not we can just use the

974
00:42:34,080 --> 00:42:36,390
same way as the PLC runtime you to

975
00:42:36,390 --> 00:42:38,130
manipulate the process so we did

976
00:42:38,130 --> 00:42:39,630
intellectually the performance over is

977
00:42:39,630 --> 00:42:43,110
actually below one person's we can

978
00:42:43,110 --> 00:42:45,330
actually use already mapped RSS by the

979
00:42:45,330 --> 00:42:49,560
PLC on time or we can actually remap or

980
00:42:49,560 --> 00:42:52,830
ourselves the are your memory and

981
00:42:52,830 --> 00:42:54,630
actually we can run it as a shell code

982
00:42:54,630 --> 00:42:56,910
so you can use any kind of legitimate

983
00:42:56,910 --> 00:42:59,370
request for are you device drivers see

984
00:42:59,370 --> 00:43:03,300
the first mmm so second variants what we

985
00:43:03,300 --> 00:43:05,460
did well for it my pleasure is very

986
00:43:05,460 --> 00:43:08,460
simple you just what you do is that you

987
00:43:08,460 --> 00:43:10,650
just simply constantly write the values

988
00:43:10,650 --> 00:43:13,380
you want to the input screen so it's

989
00:43:13,380 --> 00:43:15,180
just you just change the state just

990
00:43:15,180 --> 00:43:17,250
write whatever you want appears on time

991
00:43:17,250 --> 00:43:18,930
always read the values you want mostly

992
00:43:18,930 --> 00:43:22,230
most and for right manipulation it's a

993
00:43:22,230 --> 00:43:23,760
little bit more tricky because we didn't

994
00:43:23,760 --> 00:43:25,860
want to constantly write whatever we

995
00:43:25,860 --> 00:43:28,200
want we wanted to be very more accurate

996
00:43:28,200 --> 00:43:30,930
like the same way as the route it was so

997
00:43:30,930 --> 00:43:32,790
what we did we had to find something we

998
00:43:32,790 --> 00:43:35,460
call it reference starting time so what

999
00:43:35,460 --> 00:43:37,920
is reference is starting time well you

1000
00:43:37,920 --> 00:43:39,660
know do you remember the example we had

1001
00:43:39,660 --> 00:43:41,070
like every fax I can turn on an

1002
00:43:41,070 --> 00:43:42,960
opportunity so it's like you don't know

1003
00:43:42,960 --> 00:43:46,050
exactly which from which relative time

1004
00:43:46,050 --> 00:43:48,510
you are starting writing to the i/o so

1005
00:43:48,510 --> 00:43:51,960
you have to know exactly from let's say

1006
00:43:51,960 --> 00:43:56,430
our word we can say at 12:30 and 26

1007
00:43:56,430 --> 00:43:59,340
second the first five seconds starts and

1008
00:43:59,340 --> 00:44:02,580
the next five second will be at 31 like

1009
00:44:02,580 --> 00:44:06,000
like 12 31 for example so you have to

1010
00:44:06,000 --> 00:44:07,410
know this is starting time so once you

1011
00:44:07,410 --> 00:44:08,640
notice the starting time which you can

1012
00:44:08,640 --> 00:44:11,070
just read from the i/o and then what you

1013
00:44:11,070 --> 00:44:11,880
do is that right

1014
00:44:11,880 --> 00:44:14,130
for the references starting time arrives

1015
00:44:14,130 --> 00:44:16,079
what you do is that you set the input

1016
00:44:16,079 --> 00:44:18,750
pin to the input the plz runtime read it

1017
00:44:18,750 --> 00:44:21,329
and then you write the value in pods so

1018
00:44:21,329 --> 00:44:23,130
you just set the pin to the output and

1019
00:44:23,130 --> 00:44:26,700
write to it and that's it so so far what

1020
00:44:26,700 --> 00:44:28,980
we did actually all up it was what you

1021
00:44:28,980 --> 00:44:30,390
thought control so do to allow your

1022
00:44:30,390 --> 00:44:32,730
manipulation what about analog data well

1023
00:44:32,730 --> 00:44:34,890
for analog data if you just want to

1024
00:44:34,890 --> 00:44:37,819
especially if it's you know like input

1025
00:44:37,819 --> 00:44:40,670
stuff for example temperature sensor

1026
00:44:40,670 --> 00:44:43,589
well he's very easy you can just just

1027
00:44:43,589 --> 00:44:45,240
again just write to the physical or in

1028
00:44:45,240 --> 00:44:47,359
memory using a debugger Easter or

1029
00:44:47,359 --> 00:44:50,220
something else is that a technique which

1030
00:44:50,220 --> 00:44:52,440
we are calling a PC plus one which we're

1031
00:44:52,440 --> 00:44:54,660
not letting the PLC run time right to

1032
00:44:54,660 --> 00:44:59,759
the i/o but another way actually to do

1033
00:44:59,759 --> 00:45:01,259
the analog manipulation is pin

1034
00:45:01,259 --> 00:45:03,240
multiplexing we didn't talk about it

1035
00:45:03,240 --> 00:45:05,099
right because most of the thing with it

1036
00:45:05,099 --> 00:45:06,509
was just about changing the inputs

1037
00:45:06,509 --> 00:45:09,480
outputs also to input but what about we

1038
00:45:09,480 --> 00:45:12,180
pin multiplexing attack so we actually

1039
00:45:12,180 --> 00:45:14,279
need a pin multiplexing attack we have a

1040
00:45:14,279 --> 00:45:17,309
motor which is controlled by PWM like IO

1041
00:45:17,309 --> 00:45:19,740
interface and what we do is that we

1042
00:45:19,740 --> 00:45:22,170
multiplex the pin which is being used

1043
00:45:22,170 --> 00:45:24,569
for PWM and use it for other

1044
00:45:24,569 --> 00:45:26,220
functionality we basically stop the

1045
00:45:26,220 --> 00:45:28,589
motor from working but the PLC on time I

1046
00:45:28,589 --> 00:45:33,480
assume here is working yeah so this is

1047
00:45:33,480 --> 00:45:35,640
an example of actually you can write the

1048
00:45:35,640 --> 00:45:37,950
value so basically analog data is

1049
00:45:37,950 --> 00:45:42,740
basically multiple digital values and

1050
00:45:42,740 --> 00:45:47,808
demo for you have to just move the video

1051
00:45:50,779 --> 00:45:57,019
so you have to stop the video ok yeah

1052
00:45:57,590 --> 00:46:02,510
so so here you have a motor which is

1053
00:46:02,510 --> 00:46:05,810
rotating like moving forward and

1054
00:46:05,810 --> 00:46:07,430
backward this is the value you see it's

1055
00:46:07,430 --> 00:46:09,800
moving forward and then it goes back

1056
00:46:09,800 --> 00:46:12,320
down and like moving backward so this is

1057
00:46:12,320 --> 00:46:14,840
the value PLC C and then what we do is

1058
00:46:14,840 --> 00:46:17,030
that we are multiplexing the pin which

1059
00:46:17,030 --> 00:46:19,130
is used for PWM positive motivation

1060
00:46:19,130 --> 00:46:22,490
control and do the attack a steel motor

1061
00:46:22,490 --> 00:46:25,550
is rotating but once we load our like

1062
00:46:25,550 --> 00:46:28,640
attack it's not going to work anymore

1063
00:46:28,640 --> 00:46:32,000
because we multiplex the p10 like race

1064
00:46:32,000 --> 00:46:33,640
wait for it

1065
00:46:33,640 --> 00:46:36,740
yeah so now the motor I stopped working

1066
00:46:36,740 --> 00:46:38,120
but what you see in the software is that

1067
00:46:38,120 --> 00:46:39,830
everything is fine motor is still

1068
00:46:39,830 --> 00:46:42,560
rotating forward and backward but it's

1069
00:46:42,560 --> 00:46:44,060
not happening in physical work because

1070
00:46:44,060 --> 00:46:46,490
motor it stops because the multiplex the

1071
00:46:46,490 --> 00:46:48,980
p-problem channel doesn't know that if

1072
00:46:48,980 --> 00:46:51,530
it multiplexity physically disconnected

1073
00:46:51,530 --> 00:46:54,080
the PWM controller but the philsie

1074
00:46:54,080 --> 00:46:55,820
doesn't know about you don't have

1075
00:46:55,820 --> 00:46:59,380
physical connection to it this is crazy

1076
00:46:59,500 --> 00:47:07,930
you can actually see here can I have

1077
00:47:10,420 --> 00:47:14,360
okay so what about other future

1078
00:47:14,360 --> 00:47:17,570
possibilities pressure park one thing

1079
00:47:17,570 --> 00:47:19,550
you can do is actually originally

1080
00:47:19,550 --> 00:47:21,650
exploit but there are some other kind of

1081
00:47:21,650 --> 00:47:24,230
registers in or like functionalities in

1082
00:47:24,230 --> 00:47:26,060
the i/o for example pull-up and pulldown

1083
00:47:26,060 --> 00:47:28,070
resistor electrical engineers know it

1084
00:47:28,070 --> 00:47:30,560
very well in the audio interfaces and

1085
00:47:30,560 --> 00:47:32,930
maybe we don't know but maybe you can

1086
00:47:32,930 --> 00:47:35,720
actually disable the the pull-up come

1087
00:47:35,720 --> 00:47:37,760
down well actually you can disable and

1088
00:47:37,760 --> 00:47:40,070
enable them but maybe you can remotely

1089
00:47:40,070 --> 00:47:41,900
manipulate audio interfaces your

1090
00:47:41,900 --> 00:47:44,030
powerful electromagnetic field so you

1091
00:47:44,030 --> 00:47:45,860
don't need to have actually any code

1092
00:47:45,860 --> 00:47:47,870
inside the PLC but remotely we are

1093
00:47:47,870 --> 00:47:49,280
electromagnet will change the audio

1094
00:47:49,280 --> 00:47:56,060
values next so the discussion what we

1095
00:47:56,060 --> 00:47:58,340
believe again is that for now attackers

1096
00:47:58,340 --> 00:48:00,680
basically can do for simpler techniques

1097
00:48:00,680 --> 00:48:04,100
they can manipulate the logic they can

1098
00:48:04,100 --> 00:48:06,770
modify a PLC runtime executable but

1099
00:48:06,770 --> 00:48:08,900
fixing this kind of attack because they

1100
00:48:08,900 --> 00:48:11,180
are trivial attack fixing them all also

1101
00:48:11,180 --> 00:48:11,450
three

1102
00:48:11,450 --> 00:48:13,160
for vendors of course summoners are

1103
00:48:13,160 --> 00:48:16,069
doing that and they are even taking

1104
00:48:16,069 --> 00:48:17,540
further step to fixing these problems

1105
00:48:17,540 --> 00:48:20,390
you can actually it is not hard to have

1106
00:48:20,390 --> 00:48:22,819
a proper authentication it's not like to

1107
00:48:22,819 --> 00:48:25,599
having like a proper logic checksum or

1108
00:48:25,599 --> 00:48:28,760
having a proper PLC one time you take it

1109
00:48:28,760 --> 00:48:31,430
to verification but once you have these

1110
00:48:31,430 --> 00:48:33,380
things in place then we believe that the

1111
00:48:33,380 --> 00:48:35,420
next step for attackers is like what we

1112
00:48:35,420 --> 00:48:36,950
did pin control attack is like one of

1113
00:48:36,950 --> 00:48:39,619
the examples of it so you don't have to

1114
00:48:39,619 --> 00:48:41,180
do the function hooking which there are

1115
00:48:41,180 --> 00:48:44,180
some active defenses for it and so yeah

1116
00:48:44,180 --> 00:48:46,059
so this is the next step for attackers

1117
00:48:46,059 --> 00:48:51,020
oops okay so so what we believe is that

1118
00:48:51,020 --> 00:48:53,299
we need actually more focus on system

1119
00:48:53,299 --> 00:48:54,920
level security of control devices in

1120
00:48:54,920 --> 00:48:57,799
future because in future you will have

1121
00:48:57,799 --> 00:49:00,170
more sophisticated techniques for

1122
00:49:00,170 --> 00:49:02,809
example one of the end translation get

1123
00:49:02,809 --> 00:49:04,910
into the to the PLC was getting system

1124
00:49:04,910 --> 00:49:07,040
level access so once you fix the problem

1125
00:49:07,040 --> 00:49:08,960
of authentication the next problem is

1126
00:49:08,960 --> 00:49:11,359
having for example buffer overflow

1127
00:49:11,359 --> 00:49:13,430
attacks in a PLC we need something like

1128
00:49:13,430 --> 00:49:15,349
control flow integrity in the PLC's as

1129
00:49:15,349 --> 00:49:17,390
well too you know it's not just in an

1130
00:49:17,390 --> 00:49:19,010
Intel board that you have such things

1131
00:49:19,010 --> 00:49:21,440
but you need more advanced defensive

1132
00:49:21,440 --> 00:49:23,690
techniques there to wealth in control

1133
00:49:23,690 --> 00:49:25,280
attack is again we believe that is

1134
00:49:25,280 --> 00:49:26,869
because it's caused by lack of

1135
00:49:26,869 --> 00:49:28,880
interrupts for IO configuration and IO

1136
00:49:28,880 --> 00:49:31,609
multiplexing registers and it can have

1137
00:49:31,609 --> 00:49:33,920
significant consequences and in any it

1138
00:49:33,920 --> 00:49:35,329
can work basically in any embedded

1139
00:49:35,329 --> 00:49:36,859
system but any abilities on which mostly

1140
00:49:36,859 --> 00:49:39,619
use its are you as a important tool so

1141
00:49:39,619 --> 00:49:42,680
it can be a PLC it can be ie D it can be

1142
00:49:42,680 --> 00:49:45,140
even a car issues we are studying at one

1143
00:49:45,140 --> 00:49:47,630
so yeah so you can actually use it for

1144
00:49:47,630 --> 00:49:49,490
every other thing Matt if you have a

1145
00:49:49,490 --> 00:49:52,099
solution for us what we're proposing a

1146
00:49:52,099 --> 00:49:53,720
solution for over attack it would be

1147
00:49:53,720 --> 00:49:55,880
easier to to changing the default

1148
00:49:55,880 --> 00:49:58,309
passwords and putting in place some

1149
00:49:58,309 --> 00:50:01,119
through those tubular defenses but you

1150
00:50:01,119 --> 00:50:05,200
for now we can propose a slower

1151
00:50:05,200 --> 00:50:07,819
Rooskies variant which can be monitoring

1152
00:50:07,819 --> 00:50:09,680
the pin configuration in kernel mode and

1153
00:50:09,680 --> 00:50:12,230
the protection for our node non-risk

1154
00:50:12,230 --> 00:50:14,809
each variant simply by doing I of

1155
00:50:14,809 --> 00:50:17,619
separation and not for not allowing the

1156
00:50:17,619 --> 00:50:21,859
unprivileged process process to doing re

1157
00:50:21,859 --> 00:50:23,630
operations directly we can actually

1158
00:50:23,630 --> 00:50:25,880
mitigate

1159
00:50:25,880 --> 00:50:29,390
we can actually reduce our attack okay

1160
00:50:29,390 --> 00:50:31,089
so thank you for presenting at our

1161
00:50:31,089 --> 00:50:33,679
presentation sorry for those switches

1162
00:50:33,679 --> 00:50:35,119
between the slides it would be easier

1163
00:50:35,119 --> 00:50:36,529
with reduce control anyway yeah

1164
00:50:36,529 --> 00:50:38,479
everything that has a beginning has an

1165
00:50:38,479 --> 00:50:45,769
end so is there any question so we don't

1166
00:50:45,769 --> 00:50:47,839
have a question fine okay ran out of the

1167
00:50:47,839 --> 00:50:50,169
time so oh maybe we can talk later

1168
00:50:50,169 --> 00:50:53,979
sorry thank you

1169
00:50:54,200 --> 00:50:58,419
[Applause]

