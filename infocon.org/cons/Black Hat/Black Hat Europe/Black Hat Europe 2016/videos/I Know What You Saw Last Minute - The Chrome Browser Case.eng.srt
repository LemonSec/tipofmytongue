1
00:00:00,000 --> 00:00:02,220
hello everyone if you want to hear me

2
00:00:02,220 --> 00:00:06,690
very well hear me well right so my name

3
00:00:06,690 --> 00:00:08,880
is Ron Dubin i'ma pages student from Ben

4
00:00:08,880 --> 00:00:11,550
Gurion University Israel my PhD advisor

5
00:00:11,550 --> 00:00:13,769
is Professor offer a doll and my page a

6
00:00:13,769 --> 00:00:16,049
special advisor our dr. Amit veer and

7
00:00:16,049 --> 00:00:19,189
dr. Phil Perry from a Yale University I

8
00:00:19,189 --> 00:00:22,230
just admitted my page my bitmap eg that

9
00:00:22,230 --> 00:00:24,600
is three days ago so I'm extremely happy

10
00:00:24,600 --> 00:00:26,730
to fill this long journey at blackhat

11
00:00:26,730 --> 00:00:29,730
the name of our title is I know what is

12
00:00:29,730 --> 00:00:32,130
so last minute and you are going to

13
00:00:32,130 --> 00:00:34,320
investigate together YouTube videos

14
00:00:34,320 --> 00:00:37,489
traffic encrypted network traffic from

15
00:00:37,489 --> 00:00:41,640
extracted form on browser with html5

16
00:00:41,640 --> 00:00:44,760
player over HTTP to and clip that

17
00:00:44,760 --> 00:00:52,980
application layer well my research is

18
00:00:52,980 --> 00:00:55,530
all about how to optimize HTTP adaptive

19
00:00:55,530 --> 00:00:58,260
streaming in steps encryption is such a

20
00:00:58,260 --> 00:01:01,410
huge part in in today's networks we

21
00:01:01,410 --> 00:01:04,290
investigate how can we understand what

22
00:01:04,290 --> 00:01:06,420
is the content inside the encryption

23
00:01:06,420 --> 00:01:09,000
what is the quality of the video your

24
00:01:09,000 --> 00:01:09,680
viewing

25
00:01:09,680 --> 00:01:12,270
what is your quality of experience and

26
00:01:12,270 --> 00:01:14,970
while researching this we found very

27
00:01:14,970 --> 00:01:16,920
very interesting that patterns in the

28
00:01:16,920 --> 00:01:19,950
data and it is our story today currently

29
00:01:19,950 --> 00:01:21,470
I'm a senior data scientist at Circular

30
00:01:21,470 --> 00:01:23,659
working on crowdsource model

31
00:01:23,659 --> 00:01:27,330
classification problems and our agenda

32
00:01:27,330 --> 00:01:29,040
is as follows we are going to discuss

33
00:01:29,040 --> 00:01:31,710
what is the motivation what is a

34
00:01:31,710 --> 00:01:34,409
scenario we are speaking about what is

35
00:01:34,409 --> 00:01:36,509
our problem and why present it here at

36
00:01:36,509 --> 00:01:40,500
blackhat how can I know what videos

37
00:01:40,500 --> 00:01:42,990
names which titles you actually saw last

38
00:01:42,990 --> 00:01:46,110
minute and how this work is actually

39
00:01:46,110 --> 00:01:48,740
different from other related works

40
00:01:48,740 --> 00:01:51,299
we showed the proposed algorithm and

41
00:01:51,299 --> 00:01:54,479
results as usual so the motivation is

42
00:01:54,479 --> 00:01:57,030
pretty clear Google encouraged Network 5

43
00:01:57,030 --> 00:01:59,759
is free it is reported with 70% of

44
00:01:59,759 --> 00:02:02,969
Google online traffic is encrypted good

45
00:02:02,969 --> 00:02:05,219
encourage our to do so by giving a

46
00:02:05,219 --> 00:02:08,399
ranking boost in the search engine now a

47
00:02:08,399 --> 00:02:11,640
well-known fact is that a CPA keeps that

48
00:02:11,640 --> 00:02:12,819
anonymous

49
00:02:12,819 --> 00:02:15,370
this means that the Internet Service

50
00:02:15,370 --> 00:02:18,069
Providers your ISP can snoop your

51
00:02:18,069 --> 00:02:21,819
traffic let's try to break it so our

52
00:02:21,819 --> 00:02:24,340
scenario is a passive sniffing as you

53
00:02:24,340 --> 00:02:25,870
probably know that is sniffing it is by

54
00:02:25,870 --> 00:02:27,489
the ice field in order to understand

55
00:02:27,489 --> 00:02:29,680
which application you're using how much

56
00:02:29,680 --> 00:02:31,299
better you're consuming what is the

57
00:02:31,299 --> 00:02:33,129
quality of experience from the different

58
00:02:33,129 --> 00:02:36,189
service you're using however they also

59
00:02:36,189 --> 00:02:38,140
created an open-source intelligence

60
00:02:38,140 --> 00:02:41,109
vector from your traffic they are using

61
00:02:41,109 --> 00:02:42,519
your search history

62
00:02:42,519 --> 00:02:45,849
you're a visited site and they sell it

63
00:02:45,849 --> 00:02:48,760
to third party it's interesting to say

64
00:02:48,760 --> 00:02:52,060
that last month in the registry the FCC

65
00:02:52,060 --> 00:02:54,340
acknowledged this problem and a new law

66
00:02:54,340 --> 00:02:57,310
now prohibits the eyes fixed radio

67
00:02:57,310 --> 00:03:00,189
traffic without your permission and very

68
00:03:00,189 --> 00:03:03,700
interesting however UIC is not the only

69
00:03:03,700 --> 00:03:06,430
one with access to this data to your

70
00:03:06,430 --> 00:03:09,159
little traffic your government or maybe

71
00:03:09,159 --> 00:03:12,939
others have this action now if you can

72
00:03:12,939 --> 00:03:15,010
create an open source intelligence

73
00:03:15,010 --> 00:03:19,900
vector from YouTube videos we actually

74
00:03:19,900 --> 00:03:22,260
can learn a lot of interesting things

75
00:03:22,260 --> 00:03:25,389
now we all know the to tube if there

76
00:03:25,389 --> 00:03:27,299
were also shell largest video platforms

77
00:03:27,299 --> 00:03:30,310
it's not only used for pop music right

78
00:03:30,310 --> 00:03:33,129
it's used for propaganda demonstration

79
00:03:33,129 --> 00:03:36,940
all over the world now if you can take a

80
00:03:36,940 --> 00:03:39,970
set of videos that belong to specific

81
00:03:39,970 --> 00:03:42,310
groups let's say a terror of the like

82
00:03:42,310 --> 00:03:46,000
eyes and we can actually point it out

83
00:03:46,000 --> 00:03:50,139
which users consume those videos we can

84
00:03:50,139 --> 00:03:51,459
create an open-source intelligence

85
00:03:51,459 --> 00:03:55,150
vessel that can give us insight that was

86
00:03:55,150 --> 00:03:58,030
lost until 2003 when YouTube actually

87
00:03:58,030 --> 00:04:04,060
started using the encryption now how are

88
00:04:04,060 --> 00:04:06,430
the scenarios possible with this data

89
00:04:06,430 --> 00:04:08,889
I'm sure you can think about them so

90
00:04:08,889 --> 00:04:11,650
actually our purpose is to show you that

91
00:04:11,650 --> 00:04:14,949
HTTPS hup-two is nothing else in order

92
00:04:14,949 --> 00:04:16,720
to keep your viewing habits or to

93
00:04:16,720 --> 00:04:19,509
protect your viewing habits now our

94
00:04:19,509 --> 00:04:21,849
contribution is as follows we have a

95
00:04:21,849 --> 00:04:23,860
very large data set that is already

96
00:04:23,860 --> 00:04:26,139
available for download so you can play

97
00:04:26,139 --> 00:04:26,660
with

98
00:04:26,660 --> 00:04:30,020
we have the data crawler that enable you

99
00:04:30,020 --> 00:04:34,130
to get to put any URL to download this

100
00:04:34,130 --> 00:04:37,850
save the encrypted pickup the capture of

101
00:04:37,850 --> 00:04:40,250
the data and extend it to different

102
00:04:40,250 --> 00:04:43,760
titles or different problems the main we

103
00:04:43,760 --> 00:04:46,070
are actually investigating videos but

104
00:04:46,070 --> 00:04:49,430
maybe it's possible to other social

105
00:04:49,430 --> 00:04:52,160
media data so with this tool you can

106
00:04:52,160 --> 00:04:55,040
already have a head start and we'll show

107
00:04:55,040 --> 00:04:56,690
you a new traffic features which

108
00:04:56,690 --> 00:04:59,120
represent the data and justification

109
00:04:59,120 --> 00:05:02,570
algorithms now we saw we'll begin with

110
00:05:02,570 --> 00:05:04,220
the rest of the details I want to talk

111
00:05:04,220 --> 00:05:06,710
about a common mistake as people ask me

112
00:05:06,710 --> 00:05:08,180
run what is the problem

113
00:05:08,180 --> 00:05:11,210
you see you ever here have a better

114
00:05:11,210 --> 00:05:14,990
culture you have here the HTTPS and then

115
00:05:14,990 --> 00:05:17,030
you have the URL in the end of the URL

116
00:05:17,030 --> 00:05:20,630
you have the video ID tag you can use

117
00:05:20,630 --> 00:05:22,970
the HTTP headers that are visible in the

118
00:05:22,970 --> 00:05:25,670
network and static extracted using a

119
00:05:25,670 --> 00:05:27,740
deep packet inspection and you're done

120
00:05:27,740 --> 00:05:29,840
the only problem this is a common

121
00:05:29,840 --> 00:05:31,880
mistake it's not smooth when you are

122
00:05:31,880 --> 00:05:33,560
using you but with your browser and you

123
00:05:33,560 --> 00:05:36,200
go surfing too with HTTPS to any site

124
00:05:36,200 --> 00:05:38,750
the first thing you have if you have the

125
00:05:38,750 --> 00:05:40,730
hair cell TLS handshake

126
00:05:40,730 --> 00:05:42,800
this actually protects your data

127
00:05:42,800 --> 00:05:45,920
therefore the HTTP headers are not

128
00:05:45,920 --> 00:05:48,980
visible in the network so how can I know

129
00:05:48,980 --> 00:05:53,870
what you saw so first we need to

130
00:05:53,870 --> 00:05:55,730
understand how YouTube videos are

131
00:05:55,730 --> 00:05:58,970
encoded then we need to understand how

132
00:05:58,970 --> 00:06:02,630
the player request the data after that

133
00:06:02,630 --> 00:06:04,640
we to understand how the data is

134
00:06:04,640 --> 00:06:06,170
distributed in the network and what

135
00:06:06,170 --> 00:06:06,980
patterns

136
00:06:06,980 --> 00:06:09,890
does it create if we can take all those

137
00:06:09,890 --> 00:06:12,350
things together we can create a great

138
00:06:12,350 --> 00:06:15,050
machine learning classifier that will

139
00:06:15,050 --> 00:06:18,080
tell us which video title you actually

140
00:06:18,080 --> 00:06:20,600
saw so let's start investigating

141
00:06:20,600 --> 00:06:24,560
together before let's talk about what is

142
00:06:24,560 --> 00:06:28,010
it HTTP adaptive streaming API data

143
00:06:28,010 --> 00:06:30,590
streaming is a solution for mobile and

144
00:06:30,590 --> 00:06:32,870
fixed networks when the tail went which

145
00:06:32,870 --> 00:06:35,840
tends to fluctuate in the engine when

146
00:06:35,840 --> 00:06:38,030
you request high-quality video in the

147
00:06:38,030 --> 00:06:40,000
next segment seconds your

148
00:06:40,000 --> 00:06:43,530
bad with decrease therefore you player

149
00:06:43,530 --> 00:06:46,330
one say we're able to download the video

150
00:06:46,330 --> 00:06:48,460
in the high quality and which we buffer

151
00:06:48,460 --> 00:06:50,320
and your quality of experience will

152
00:06:50,320 --> 00:06:53,440
decrease so what was the solution we

153
00:06:53,440 --> 00:06:57,250
take high quality video and encoded in

154
00:06:57,250 --> 00:07:00,040
several quality and representation

155
00:07:00,040 --> 00:07:03,640
layers each is independent encoded in

156
00:07:03,640 --> 00:07:06,700
valuable bitrate encoding and has

157
00:07:06,700 --> 00:07:10,150
different quality and resolution then

158
00:07:10,150 --> 00:07:13,900
each quality plantation is segmented to

159
00:07:13,900 --> 00:07:17,230
fix segments one second to 50 seconds

160
00:07:17,230 --> 00:07:19,750
depends of the configuration this is a

161
00:07:19,750 --> 00:07:22,240
general purpose of our HTP adaptive

162
00:07:22,240 --> 00:07:24,040
streaming works ok

163
00:07:24,040 --> 00:07:28,440
now the player request video risk

164
00:07:28,440 --> 00:07:30,910
request video resource read from the

165
00:07:30,910 --> 00:07:34,390
server and receive a manifest or media

166
00:07:34,390 --> 00:07:36,910
presentation description which indicates

167
00:07:36,910 --> 00:07:38,950
which quality and representation layers

168
00:07:38,950 --> 00:07:42,130
exist at the server then in the player

169
00:07:42,130 --> 00:07:44,770
automatic mode step after step the

170
00:07:44,770 --> 00:07:47,650
player algorithm estimate the network

171
00:07:47,650 --> 00:07:49,750
condition the playout buffer and based

172
00:07:49,750 --> 00:07:52,240
on this algorithm select which segment

173
00:07:52,240 --> 00:07:54,610
will give us the maximum quality of

174
00:07:54,610 --> 00:07:58,030
experience however YouTube specifically

175
00:07:58,030 --> 00:08:01,419
does it work in very large segments the

176
00:08:01,419 --> 00:08:03,760
work in the granularity granularity of

177
00:08:03,760 --> 00:08:07,000
very small segments using HTTP

178
00:08:07,000 --> 00:08:10,300
byte-range requests this gives them the

179
00:08:10,300 --> 00:08:14,110
ability to ask a specific small chunks

180
00:08:14,110 --> 00:08:17,380
of the data and how this data behaved

181
00:08:17,380 --> 00:08:19,390
and how we request data we need to

182
00:08:19,390 --> 00:08:23,919
investigate together now if I take

183
00:08:23,919 --> 00:08:28,419
Wireshark and capture the data we can

184
00:08:28,419 --> 00:08:30,910
see that we have two different possible

185
00:08:30,910 --> 00:08:33,940
modes of operation the first one is the

186
00:08:33,940 --> 00:08:36,130
automatic mode in this mode we let the

187
00:08:36,130 --> 00:08:38,620
player to estimate which the quality

188
00:08:38,620 --> 00:08:42,010
will be the most suitable to download we

189
00:08:42,010 --> 00:08:44,080
can see that traffic is illustrated in

190
00:08:44,080 --> 00:08:48,550
high traffic bursts and silence in the

191
00:08:48,550 --> 00:08:50,770
beginning we don't see it very well why

192
00:08:50,770 --> 00:08:53,500
because we have several different

193
00:08:53,500 --> 00:08:55,870
flow that helps desert download the

194
00:08:55,870 --> 00:08:58,630
video faster each flow is represented by

195
00:08:58,630 --> 00:09:01,060
a five star representation of sauce

196
00:09:01,060 --> 00:09:04,390
recipe sauce despot and application type

197
00:09:04,390 --> 00:09:08,500
which is TCP now now we understand how

198
00:09:08,500 --> 00:09:10,720
the video in the automatic mode looks

199
00:09:10,720 --> 00:09:13,180
like but we don't understand on them

200
00:09:13,180 --> 00:09:15,670
still what is the content inside each

201
00:09:15,670 --> 00:09:18,490
verse and we don't understand how the

202
00:09:18,490 --> 00:09:20,860
player request the data because we can

203
00:09:20,860 --> 00:09:23,860
see the de fruit of each birth is

204
00:09:23,860 --> 00:09:26,670
different and we don't understand why

205
00:09:26,670 --> 00:09:29,920
now there is a relative mode the code is

206
00:09:29,920 --> 00:09:32,410
named the sixth mode in this mode you

207
00:09:32,410 --> 00:09:35,320
request from the player a specific video

208
00:09:35,320 --> 00:09:39,760
quality change the player knows what

209
00:09:39,760 --> 00:09:41,980
quality to download from beginning till

210
00:09:41,980 --> 00:09:44,200
the end he downloads a three-minute

211
00:09:44,200 --> 00:09:47,620
video very very fast and after 45 around

212
00:09:47,620 --> 00:09:50,410
40 seconds davina actually is double is

213
00:09:50,410 --> 00:09:55,060
downloaded fully so the problem is that

214
00:09:55,060 --> 00:09:57,310
in this mode we have a single valuable

215
00:09:57,310 --> 00:09:58,780
bit weight because we select a specific

216
00:09:58,780 --> 00:10:01,570
quality for example cemetery added 20 P

217
00:10:01,570 --> 00:10:03,940
in this mode we have multi variable

218
00:10:03,940 --> 00:10:06,700
bitrate since we have several viable bit

219
00:10:06,700 --> 00:10:08,470
weights that are possible to be selected

220
00:10:08,470 --> 00:10:10,420
so this case is much more complicated

221
00:10:10,420 --> 00:10:14,820
and we want to check this one off now

222
00:10:14,820 --> 00:10:18,010
Wireshark is a very good tool to examine

223
00:10:18,010 --> 00:10:19,920
encrypted network traffic however

224
00:10:19,920 --> 00:10:23,020
sometimes it's very hard to filter out

225
00:10:23,020 --> 00:10:25,570
different information then if you're

226
00:10:25,570 --> 00:10:28,540
using fiddler web debug proxy you can

227
00:10:28,540 --> 00:10:30,970
filter out different data and to see

228
00:10:30,970 --> 00:10:33,010
what is what is the behavior in a time

229
00:10:33,010 --> 00:10:33,370
span

230
00:10:33,370 --> 00:10:37,030
so let's filter out only the video and

231
00:10:37,030 --> 00:10:40,600
audio and only the video we can see and

232
00:10:40,600 --> 00:10:42,430
you can see here something very very

233
00:10:42,430 --> 00:10:45,190
interesting first we can see for example

234
00:10:45,190 --> 00:10:48,460
the ditch slow and this low are not the

235
00:10:48,460 --> 00:10:48,940
same

236
00:10:48,940 --> 00:10:51,760
this gives us indication that we have a

237
00:10:51,760 --> 00:10:54,550
mixture of audio and video in a single

238
00:10:54,550 --> 00:10:57,970
flow we can see there's a large amount

239
00:10:57,970 --> 00:11:01,510
of data and a time span of the request

240
00:11:01,510 --> 00:11:04,240
this gives us indication that we can

241
00:11:04,240 --> 00:11:07,240
maybe will not be able in the increase

242
00:11:07,240 --> 00:11:09,910
that network traffic to understand and

243
00:11:09,910 --> 00:11:13,930
to isolate each one of those requests

244
00:11:13,930 --> 00:11:15,310
you can see we have three different

245
00:11:15,310 --> 00:11:16,540
requests here we have two different

246
00:11:16,540 --> 00:11:19,270
requests can we isolate each request and

247
00:11:19,270 --> 00:11:20,980
understand it in the network traffic

248
00:11:20,980 --> 00:11:23,680
center of the same flow and which HTTP

249
00:11:23,680 --> 00:11:26,500
HTTP - which is a multiplex application

250
00:11:26,500 --> 00:11:28,510
layer protocol we will not be able to

251
00:11:28,510 --> 00:11:30,010
distinguish between the different data

252
00:11:30,010 --> 00:11:33,060
and describe and use create a

253
00:11:33,060 --> 00:11:37,180
complication to the classification now

254
00:11:37,180 --> 00:11:39,490
we have to remember it's HTTP - there

255
00:11:39,490 --> 00:11:42,190
are other things other messages that can

256
00:11:42,190 --> 00:11:44,860
come in each one of the slow and with

257
00:11:44,860 --> 00:11:46,420
multi variable bitrate

258
00:11:46,420 --> 00:11:49,649
each flow can have several different

259
00:11:49,649 --> 00:11:53,950
quality from the our presentation so

260
00:11:53,950 --> 00:11:57,750
this is add additional complexity now

261
00:11:57,750 --> 00:12:01,149
let's try to understand how the player

262
00:12:01,149 --> 00:12:04,209
requests the data and what is the effect

263
00:12:04,209 --> 00:12:06,220
of each byte range

264
00:12:06,220 --> 00:12:09,250
request we take three different networks

265
00:12:09,250 --> 00:12:12,399
the same computer the same video title

266
00:12:12,399 --> 00:12:16,120
and the same a video quality and figure

267
00:12:16,120 --> 00:12:19,270
out only the video in this graph and we

268
00:12:19,270 --> 00:12:20,709
can see that the behavior is very very

269
00:12:20,709 --> 00:12:23,950
interesting we can see here we all start

270
00:12:23,950 --> 00:12:27,700
in the same writer throughput which is

271
00:12:27,700 --> 00:12:29,770
very limited because of the TCP window

272
00:12:29,770 --> 00:12:33,399
behavior each flow based on the TCP

273
00:12:33,399 --> 00:12:35,649
window behavior is increasing every RTT

274
00:12:35,649 --> 00:12:39,520
in general so we can see that they all

275
00:12:39,520 --> 00:12:42,520
start in the same location but when we

276
00:12:42,520 --> 00:12:44,829
will get more data the variability of

277
00:12:44,829 --> 00:12:47,350
the request is very very large we can

278
00:12:47,350 --> 00:12:51,310
see we have two similar download but the

279
00:12:51,310 --> 00:12:53,560
only similar is a lot exact they don't

280
00:12:53,560 --> 00:12:57,010
have the same exact values and we can

281
00:12:57,010 --> 00:12:59,320
see that third one is that look shifted

282
00:12:59,320 --> 00:13:02,170
each request is very variable it is

283
00:13:02,170 --> 00:13:04,600
actually different and this is a -

284
00:13:04,600 --> 00:13:06,880
complexity since the request of the

285
00:13:06,880 --> 00:13:09,670
player is the can be dependent may be in

286
00:13:09,670 --> 00:13:12,630
the network conditions in your quality

287
00:13:12,630 --> 00:13:17,290
now how this box is different from other

288
00:13:17,290 --> 00:13:18,450
related work

289
00:13:18,450 --> 00:13:20,690
well most of the application

290
00:13:20,690 --> 00:13:24,000
classification problems actually discuss

291
00:13:24,000 --> 00:13:27,589
how to differentiate between YouTube

292
00:13:27,589 --> 00:13:32,579
fill Twitter Skype bitter end there are

293
00:13:32,579 --> 00:13:34,769
many many different books that look at

294
00:13:34,769 --> 00:13:36,690
the same domain problem domain however

295
00:13:36,690 --> 00:13:40,410
very very few related book discuss what

296
00:13:40,410 --> 00:13:42,899
is the content inside the encrypted

297
00:13:42,899 --> 00:13:46,110
applications so right it L investigates

298
00:13:46,110 --> 00:13:49,199
the voice over IP traffic for language

299
00:13:49,199 --> 00:13:52,709
identification the video the audio is

300
00:13:52,709 --> 00:13:55,040
encoded in valuable bits of quality and

301
00:13:55,040 --> 00:13:56,850
exploit the vulnerability of the

302
00:13:56,850 --> 00:13:59,970
controlling neo and suppose s did

303
00:13:59,970 --> 00:14:03,990
similar things with video titles and is

304
00:14:03,990 --> 00:14:08,130
I did it on RTP and TCP so however our

305
00:14:08,130 --> 00:14:10,560
work is actually different why first we

306
00:14:10,560 --> 00:14:12,600
have the publication of the HTTP by

307
00:14:12,600 --> 00:14:14,940
French request where the multi variable

308
00:14:14,940 --> 00:14:16,560
bitrate and not a single variable

309
00:14:16,560 --> 00:14:19,649
bitrate quality and its HTTP version two

310
00:14:19,649 --> 00:14:21,990
we have different information in each

311
00:14:21,990 --> 00:14:25,470
flow impossible is possible for you so

312
00:14:25,470 --> 00:14:29,670
what is our solution first we need to

313
00:14:29,670 --> 00:14:32,070
understand what is the packet what is

314
00:14:32,070 --> 00:14:34,649
the traffic flowing in our system so we

315
00:14:34,649 --> 00:14:36,839
divide it into two steps we have the

316
00:14:36,839 --> 00:14:38,850
connection matching which is responsible

317
00:14:38,850 --> 00:14:41,070
to understand if a connection

318
00:14:41,070 --> 00:14:45,329
it's new or it's ongoing if it's new the

319
00:14:45,329 --> 00:14:46,890
next model will be the deep packet

320
00:14:46,890 --> 00:14:49,290
inspection module and since the network

321
00:14:49,290 --> 00:14:51,510
is encrypted we will try to understand

322
00:14:51,510 --> 00:14:53,970
which application is it based on the

323
00:14:53,970 --> 00:14:56,760
client hello message of the SS SS TLS

324
00:14:56,760 --> 00:14:59,190
and insight on the same bench on the

325
00:14:59,190 --> 00:15:01,319
service name indicator field what

326
00:15:01,319 --> 00:15:04,890
service the player requests from the

327
00:15:04,890 --> 00:15:07,709
server and we will see that from YouTube

328
00:15:07,709 --> 00:15:10,410
for example it's Google Video so we can

329
00:15:10,410 --> 00:15:12,630
filter out only the content we actually

330
00:15:12,630 --> 00:15:17,610
want then each ongoing flow will go to

331
00:15:17,610 --> 00:15:20,220
feature extraction since we need to

332
00:15:20,220 --> 00:15:22,470
represent the socket relative or a lot

333
00:15:22,470 --> 00:15:24,209
of different flows a lot of different

334
00:15:24,209 --> 00:15:26,790
packet we need to set it to to create a

335
00:15:26,790 --> 00:15:28,980
structure that a machine learning

336
00:15:28,980 --> 00:15:31,830
process which we can understand

337
00:15:31,830 --> 00:15:34,140
so after the feature extraction we are

338
00:15:34,140 --> 00:15:35,490
creating a pre-processing and the

339
00:15:35,490 --> 00:15:37,350
classification algorithms which we are

340
00:15:37,350 --> 00:15:41,400
going to discuss now there are many many

341
00:15:41,400 --> 00:15:43,650
different kinds of features extractions

342
00:15:43,650 --> 00:15:46,410
for application traffic for include the

343
00:15:46,410 --> 00:15:49,200
publication traffic there are about 70

344
00:15:49,200 --> 00:15:51,960
very well-known features most of them

345
00:15:51,960 --> 00:15:56,460
have a are initiated based on the packet

346
00:15:56,460 --> 00:15:59,420
lamp different time delays and

347
00:15:59,420 --> 00:16:02,040
throughput this is the base features and

348
00:16:02,040 --> 00:16:03,690
you have many many directions many many

349
00:16:03,690 --> 00:16:05,610
variations many many statistical

350
00:16:05,610 --> 00:16:06,990
probation you can do about them

351
00:16:06,990 --> 00:16:08,670
but those are the basics and those

352
00:16:08,670 --> 00:16:12,150
features are great they are great but in

353
00:16:12,150 --> 00:16:14,640
order to understand how to differentiate

354
00:16:14,640 --> 00:16:17,400
between different applications but if

355
00:16:17,400 --> 00:16:20,160
you have the same application the

356
00:16:20,160 --> 00:16:22,770
content those features were not able to

357
00:16:22,770 --> 00:16:26,940
represent your traffic very well so we

358
00:16:26,940 --> 00:16:28,280
need a different solution after

359
00:16:28,280 --> 00:16:30,990
investigating of having a free learning

360
00:16:30,990 --> 00:16:33,630
group program learn but clearly in the

361
00:16:33,630 --> 00:16:36,200
very work that actually try to classify

362
00:16:36,200 --> 00:16:40,920
what is the each pickup video quality we

363
00:16:40,920 --> 00:16:43,020
understand that in order to understand

364
00:16:43,020 --> 00:16:46,290
what is the title we want to classify we

365
00:16:46,290 --> 00:16:48,930
need to present it as we create a bit

366
00:16:48,930 --> 00:16:51,780
per figure and this is a representation

367
00:16:51,780 --> 00:16:55,140
which leads to come all the data of this

368
00:16:55,140 --> 00:16:57,990
burst and when we see silent there is a

369
00:16:57,990 --> 00:16:59,880
sort of silence in this YouTube traffic

370
00:16:59,880 --> 00:17:03,440
we say hey because it is in the feature

371
00:17:03,440 --> 00:17:07,079
now why we use it first it is the

372
00:17:07,079 --> 00:17:10,220
traffic Elliot is very very simple

373
00:17:10,220 --> 00:17:12,900
available for real-time classification

374
00:17:12,900 --> 00:17:15,569
and we will show it in the white paper a

375
00:17:15,569 --> 00:17:17,040
notify I don't think I don't have enough

376
00:17:17,040 --> 00:17:18,930
time to show it here that it actually

377
00:17:18,930 --> 00:17:22,800
robust to packet loss and delay now

378
00:17:22,800 --> 00:17:26,490
let's take a single video title which

379
00:17:26,490 --> 00:17:32,700
have 90 different downloads okay we can

380
00:17:32,700 --> 00:17:35,280
see the horizontal line where the big

381
00:17:35,280 --> 00:17:39,630
big feature index and the vertical line

382
00:17:39,630 --> 00:17:44,100
is our different download what can we

383
00:17:44,100 --> 00:17:45,600
learn from here

384
00:17:45,600 --> 00:17:48,269
the first thing is we can change the

385
00:17:48,269 --> 00:17:51,899
distressed and second indexes have low

386
00:17:51,899 --> 00:17:54,269
variability there are two reasons for

387
00:17:54,269 --> 00:17:56,869
that the first one is the TCP window

388
00:17:56,869 --> 00:17:59,190
limitations which actually limit the

389
00:17:59,190 --> 00:18:02,009
amount of data the server can send now

390
00:18:02,009 --> 00:18:05,580
the second reason is we are actually a

391
00:18:05,580 --> 00:18:07,889
mistaken in the beginning sense those

392
00:18:07,889 --> 00:18:10,470
pics are coming very very close we are

393
00:18:10,470 --> 00:18:12,359
not able to distinguish between them and

394
00:18:12,359 --> 00:18:15,840
sometimes we actually we can see it very

395
00:18:15,840 --> 00:18:18,869
well here but sometimes we classify a

396
00:18:18,869 --> 00:18:21,090
single pic and sometimes we cannot and

397
00:18:21,090 --> 00:18:23,729
we have two or more traffic peaks in

398
00:18:23,729 --> 00:18:28,139
begin the beginning however from the

399
00:18:28,139 --> 00:18:30,869
third peak until the end we have very

400
00:18:30,869 --> 00:18:34,109
high variability in the traffic this

401
00:18:34,109 --> 00:18:37,919
means that a vector classifier that is

402
00:18:37,919 --> 00:18:40,590
dependent on the order of the data we

403
00:18:40,590 --> 00:18:43,009
have a lot of trouble to understand and

404
00:18:43,009 --> 00:18:44,549
differentiate between different

405
00:18:44,549 --> 00:18:46,769
applications even even in the same of

406
00:18:46,769 --> 00:18:50,070
the same title because the data

407
00:18:50,070 --> 00:18:51,869
variability is actually the entire

408
00:18:51,869 --> 00:18:55,529
bitrate range and this is a very big

409
00:18:55,529 --> 00:18:59,190
complication that we need to solve now

410
00:18:59,190 --> 00:19:01,799
in the pre-processing we actually try to

411
00:19:01,799 --> 00:19:05,570
so the data volubility so if you can

412
00:19:05,570 --> 00:19:08,099
understand an estimate which one of

413
00:19:08,099 --> 00:19:11,009
those fix is an audio peak we can

414
00:19:11,009 --> 00:19:13,019
decrease the overall variability of the

415
00:19:13,019 --> 00:19:17,489
data so we break the filler research we

416
00:19:17,489 --> 00:19:19,769
found that out you picks usually are

417
00:19:19,769 --> 00:19:23,820
lower than 400 kilobytes so if you can

418
00:19:23,820 --> 00:19:26,099
extract them we can help vector

419
00:19:26,099 --> 00:19:27,979
classifier to classify the data better

420
00:19:27,979 --> 00:19:34,979
but since 2013 YouTube started work with

421
00:19:34,979 --> 00:19:38,249
a single audio quality high video

422
00:19:38,249 --> 00:19:41,309
quality high audio quality with all the

423
00:19:41,309 --> 00:19:46,590
video quality available now the behavior

424
00:19:46,590 --> 00:19:49,139
the bitrate request behavior of the

425
00:19:49,139 --> 00:19:52,049
audio traffic it's much less viable it's

426
00:19:52,049 --> 00:19:53,879
not the same as the video which we can

427
00:19:53,879 --> 00:19:56,009
see high variability therefore if you

428
00:19:56,009 --> 00:19:58,409
can and if you can create a classifier

429
00:19:58,409 --> 00:19:59,160
that

430
00:19:59,160 --> 00:20:02,040
how can how to exploit the low

431
00:20:02,040 --> 00:20:04,560
variability of the audio you can

432
00:20:04,560 --> 00:20:07,320
actually use it as an anchor to the

433
00:20:07,320 --> 00:20:11,160
classification process now we propose

434
00:20:11,160 --> 00:20:13,830
two different algorithms the first one

435
00:20:13,830 --> 00:20:16,440
is a support vector machine using a

436
00:20:16,440 --> 00:20:20,220
radial basis kernel function and it

437
00:20:20,220 --> 00:20:23,580
receives the bit perfect features as we

438
00:20:23,580 --> 00:20:27,150
saw in the matrix rectangle and we add

439
00:20:27,150 --> 00:20:29,760
our proposed solution which based on the

440
00:20:29,760 --> 00:20:32,010
nearest neighbor algorithm which is a

441
00:20:32,010 --> 00:20:35,520
similarity classifier which receives the

442
00:20:35,520 --> 00:20:37,950
bit of pick stretch features which I

443
00:20:37,950 --> 00:20:41,640
will define shortly now there are other

444
00:20:41,640 --> 00:20:43,500
things I can say about SVM it's really

445
00:20:43,500 --> 00:20:45,780
good classifier but edit presented

446
00:20:45,780 --> 00:20:48,300
earlier in the mat in there in the

447
00:20:48,300 --> 00:20:51,440
feature matrix of the single title

448
00:20:51,440 --> 00:20:54,750
classifier which depends on the indexes

449
00:20:54,750 --> 00:20:57,120
of the data in terms of that is such a

450
00:20:57,120 --> 00:20:59,640
variable such a it's such a strong

451
00:20:59,640 --> 00:21:03,030
variability those classifier would have

452
00:21:03,030 --> 00:21:04,740
a lot of difficulty to classify the data

453
00:21:04,740 --> 00:21:07,830
therefore SVM a random forest

454
00:21:07,830 --> 00:21:10,890
classifiers so usually very very good

455
00:21:10,890 --> 00:21:13,050
I'm not the are not giving the best

456
00:21:13,050 --> 00:21:15,390
results in this case so what I actually

457
00:21:15,390 --> 00:21:18,480
why do I explain it well the reason is

458
00:21:18,480 --> 00:21:21,540
that if you are using our next

459
00:21:21,540 --> 00:21:25,290
quantifier in the feature to the SVM

460
00:21:25,290 --> 00:21:27,960
classifier you can create a very very

461
00:21:27,960 --> 00:21:30,330
strong classifier and it is our new walk

462
00:21:30,330 --> 00:21:33,260
which well going to walk right now I

463
00:21:33,260 --> 00:21:35,790
want to explain what is the big secret

464
00:21:35,790 --> 00:21:38,340
features that I discussed earlier let's

465
00:21:38,340 --> 00:21:41,640
define s IJ is set of little peak

466
00:21:41,640 --> 00:21:44,460
without any duplication this is the set

467
00:21:44,460 --> 00:21:46,640
extracted for each vector

468
00:21:46,640 --> 00:21:50,760
well I if the video title index n J is a

469
00:21:50,760 --> 00:21:55,080
dream index if we if we have 90 download

470
00:21:55,080 --> 00:21:59,490
copies the J will be 1 to 90 now let's

471
00:21:59,490 --> 00:22:02,120
define what is the newest level

472
00:22:02,120 --> 00:22:05,070
similarity algorithm the similarity of

473
00:22:05,070 --> 00:22:09,300
two set is defined by the sign of the

474
00:22:09,300 --> 00:22:15,420
intersection now for each title I we try

475
00:22:15,420 --> 00:22:18,900
to understand which copy J give us the

476
00:22:18,900 --> 00:22:23,730
maximum similarity then for each title I

477
00:22:23,730 --> 00:22:26,670
I'm trying to understand which of them

478
00:22:26,670 --> 00:22:29,790
give us the maximum criminality but we

479
00:22:29,790 --> 00:22:31,560
as a result have to be larger than

480
00:22:31,560 --> 00:22:34,200
threshold the session was set based on

481
00:22:34,200 --> 00:22:36,960
the cross-validation and not

482
00:22:36,960 --> 00:22:39,660
surprisingly the threshold is too why

483
00:22:39,660 --> 00:22:41,640
because of the disappearing to behavior

484
00:22:41,640 --> 00:22:46,500
and the way we swap the feature we have

485
00:22:46,500 --> 00:22:48,330
for a variable data such as you already

486
00:22:48,330 --> 00:22:51,510
can download we have the training set

487
00:22:51,510 --> 00:22:55,620
which includes 30 videos titles each of

488
00:22:55,620 --> 00:22:59,070
them have 100 copies we separate them

489
00:22:59,070 --> 00:23:03,390
for very interesting 94 training 10 for

490
00:23:03,390 --> 00:23:07,770
testing then we have videos businesses

491
00:23:07,770 --> 00:23:10,980
that are outside of our training this

492
00:23:10,980 --> 00:23:13,020
means it's the out videos that we don't

493
00:23:13,020 --> 00:23:15,410
know them we want to classify them as

494
00:23:15,410 --> 00:23:19,850
unknown and we have traditional data set

495
00:23:19,850 --> 00:23:23,490
let's actually try to understand if our

496
00:23:23,490 --> 00:23:25,650
feature is robust to puppet loss and

497
00:23:25,650 --> 00:23:28,440
delay I don't have enough time to go

498
00:23:28,440 --> 00:23:30,570
over them but they will appear in the

499
00:23:30,570 --> 00:23:33,750
white paper now let's try to understand

500
00:23:33,750 --> 00:23:36,240
what is the classification accuracy

501
00:23:36,240 --> 00:23:40,140
using different data set sizes we can

502
00:23:40,140 --> 00:23:43,740
see for a single single topic third

503
00:23:43,740 --> 00:23:47,990
title / video title we already achieved

504
00:23:47,990 --> 00:23:52,230
78 percent accuracy if we increase the

505
00:23:52,230 --> 00:23:55,800
database to five copies per title our

506
00:23:55,800 --> 00:23:58,050
accuracy actually raises to 92 percent

507
00:23:58,050 --> 00:24:02,600
and go on if you have a large data set

508
00:24:02,600 --> 00:24:06,240
you can be more robust to unpredictable

509
00:24:06,240 --> 00:24:07,410
network changes

510
00:24:07,410 --> 00:24:10,170
left with the network quality changes

511
00:24:10,170 --> 00:24:13,860
and large that will help you to overcome

512
00:24:13,860 --> 00:24:18,720
them now let's try to send what is the

513
00:24:18,720 --> 00:24:21,360
classification accuracy and we have

514
00:24:21,360 --> 00:24:23,220
other go file GUI and elsewhere which

515
00:24:23,220 --> 00:24:23,730
achieves

516
00:24:23,730 --> 00:24:24,820
70% a few

517
00:24:24,820 --> 00:24:26,710
things but instead suitable for this

518
00:24:26,710 --> 00:24:29,080
problem so I want to discuss a bit about

519
00:24:29,080 --> 00:24:32,980
in a lot but in our suggest solutions we

520
00:24:32,980 --> 00:24:37,059
have 98% accuracy now there are two

521
00:24:37,059 --> 00:24:39,429
different two different arrows we

522
00:24:39,429 --> 00:24:42,490
actually have in our data set by way

523
00:24:42,490 --> 00:24:44,860
into the atom line which will be totally

524
00:24:44,860 --> 00:24:46,870
read this means that we have 100

525
00:24:46,870 --> 00:24:49,480
percents we can see with arrows I don't

526
00:24:49,480 --> 00:24:51,100
know how well you see it right there and

527
00:24:51,100 --> 00:24:51,880
right there

528
00:24:51,880 --> 00:24:54,220
with arrows between the different titles

529
00:24:54,220 --> 00:24:56,830
this is the worst mistake we can have

530
00:24:56,830 --> 00:24:59,830
why in a real system you cannot

531
00:24:59,830 --> 00:25:01,960
understand if you have a mistake and

532
00:25:01,960 --> 00:25:02,950
lock in the traffic setting it's

533
00:25:02,950 --> 00:25:06,490
encrypted so our future work try to

534
00:25:06,490 --> 00:25:09,429
minimize any of those mistakes now we

535
00:25:09,429 --> 00:25:12,070
have additional mistakes when we say

536
00:25:12,070 --> 00:25:15,970
that we have video title I but we didn't

537
00:25:15,970 --> 00:25:19,600
well we were unable to clarify and sense

538
00:25:19,600 --> 00:25:21,610
if the dispatch the threshold in these

539
00:25:21,610 --> 00:25:24,639
cases we say it unknown in this case it

540
00:25:24,639 --> 00:25:28,419
only a larger data set will help us to

541
00:25:28,419 --> 00:25:32,559
overcome those problems we just added

542
00:25:32,559 --> 00:25:35,769
the 200 video titles that are not found

543
00:25:35,769 --> 00:25:38,139
in our training testing and fine which

544
00:25:38,139 --> 00:25:41,110
is 100% accuracy because I say

545
00:25:41,110 --> 00:25:43,240
unfortunately one of the sense because

546
00:25:43,240 --> 00:25:45,700
we already saw earlier that in our train

547
00:25:45,700 --> 00:25:49,840
tests we achieved 98% so this is

548
00:25:49,840 --> 00:25:52,299
actually 8 100 video titles which are

549
00:25:52,299 --> 00:25:54,970
already available in the site but we

550
00:25:54,970 --> 00:25:56,980
does it our algorithm with thousand

551
00:25:56,980 --> 00:25:59,169
videos and you estimate that in real

552
00:25:59,169 --> 00:26:01,360
network our classification accuracy will

553
00:26:01,360 --> 00:26:06,039
be around 92% this is a one of our

554
00:26:06,039 --> 00:26:09,610
ongoing results of instead of 30 video

555
00:26:09,610 --> 00:26:13,509
titles we use 100 video title and we say

556
00:26:13,509 --> 00:26:16,779
that we get accuracy of 90 3.6 there is

557
00:26:16,779 --> 00:26:19,029
something very very interesting to show

558
00:26:19,029 --> 00:26:21,730
you that happens exactly here we have

559
00:26:21,730 --> 00:26:26,350
two different videos that are slide and

560
00:26:26,350 --> 00:26:29,110
they are very very similar in the

561
00:26:29,110 --> 00:26:31,769
traffic pattern as a result there are

562
00:26:31,769 --> 00:26:33,639
around 50 percent

563
00:26:33,639 --> 00:26:35,769
mistakes between the levels between them

564
00:26:35,769 --> 00:26:38,470
now this actually means

565
00:26:38,470 --> 00:26:41,500
that algorithm is good for valuable bit

566
00:26:41,500 --> 00:26:43,390
rate traffic and if you are using a

567
00:26:43,390 --> 00:26:46,690
static video such as music when you have

568
00:26:46,690 --> 00:26:49,240
finger style it's only speaking voices

569
00:26:49,240 --> 00:26:51,820
our classifier will not give you the

570
00:26:51,820 --> 00:26:57,700
best solution so conclusion we actually

571
00:26:57,700 --> 00:27:00,150
created an open-source intelligence

572
00:27:00,150 --> 00:27:04,270
vector from YouTube video traffic we

573
00:27:04,270 --> 00:27:07,419
show you that HP - even at the traffic

574
00:27:07,419 --> 00:27:10,720
is encrypted we still can understand

575
00:27:10,720 --> 00:27:14,530
what content the user requests our

576
00:27:14,530 --> 00:27:16,690
algorithm present 93 eight percent

577
00:27:16,690 --> 00:27:20,140
accuracy and our contribution is color

578
00:27:20,140 --> 00:27:25,990
data set and algorithms in any questions

579
00:27:25,990 --> 00:27:29,070
thank you very much for coming

