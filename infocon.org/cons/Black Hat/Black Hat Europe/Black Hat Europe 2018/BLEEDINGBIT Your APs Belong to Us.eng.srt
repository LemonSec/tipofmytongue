1
00:00:00,030 --> 00:00:05,670
so my name is Ben Surrey I'm the VP of

2
00:00:02,460 --> 00:00:08,400
research at Armas and today with me I

3
00:00:05,670 --> 00:00:12,840
have a doors Iseman he's a researcher my

4
00:00:08,400 --> 00:00:14,849
team Varmus is an agent agent society

5
00:00:12,840 --> 00:00:17,189
security company which is focused on

6
00:00:14,849 --> 00:00:19,980
security IRT devices and many many

7
00:00:17,190 --> 00:00:22,320
devices in general specifically in

8
00:00:19,980 --> 00:00:23,670
enterprise organizations part of the

9
00:00:22,320 --> 00:00:25,529
goal of our company is to better

10
00:00:23,670 --> 00:00:27,510
understand the threat landscape that IOT

11
00:00:25,529 --> 00:00:29,310
devices and wireless protocols in

12
00:00:27,510 --> 00:00:32,300
general pose on the security of an

13
00:00:29,310 --> 00:00:37,530
enterprise network so part of this cause

14
00:00:32,299 --> 00:00:39,870
came and led us to this research and it

15
00:00:37,530 --> 00:00:42,180
started by understanding that there is a

16
00:00:39,870 --> 00:00:45,120
recent trend in which Enterprise great

17
00:00:42,180 --> 00:00:47,430
access points actually embed in them in

18
00:00:45,120 --> 00:00:51,239
addition a radio chip abby lee able to

19
00:00:47,430 --> 00:00:55,500
flow energy chip and this additional

20
00:00:51,239 --> 00:00:57,899
chip is there to have new features for

21
00:00:55,500 --> 00:01:01,410
access points but we also naturally

22
00:00:57,899 --> 00:01:03,000
introduces a new threat landscape it

23
00:01:01,410 --> 00:01:07,048
opens the possibility of a network

24
00:01:03,000 --> 00:01:08,460
bridge coming from a ble connection and

25
00:01:07,049 --> 00:01:10,740
in fact in the process of this research

26
00:01:08,460 --> 00:01:14,339
we thought we found two zero day

27
00:01:10,740 --> 00:01:18,119
vulnerabilities affecting TI billy chips

28
00:01:14,340 --> 00:01:22,530
that are used by Aruba Meraki and Cisco

29
00:01:18,119 --> 00:01:26,549
access points and so what is our agenda

30
00:01:22,530 --> 00:01:29,570
for today it's it's quite packed so I

31
00:01:26,549 --> 00:01:32,630
hope we've managed to get to everything

32
00:01:29,570 --> 00:01:36,298
but initially I'm going to talk about

33
00:01:32,630 --> 00:01:37,619
Billy in general where is it used why is

34
00:01:36,299 --> 00:01:39,960
it used

35
00:01:37,619 --> 00:01:43,490
how is it being adopted in different

36
00:01:39,960 --> 00:01:45,929
verticals in the environment and then

37
00:01:43,490 --> 00:01:47,520
specifically on access points why is it

38
00:01:45,930 --> 00:01:49,860
using the access points what are the

39
00:01:47,520 --> 00:01:53,210
features that are embedded in access

40
00:01:49,860 --> 00:01:56,549
points for triggering lvd

41
00:01:53,210 --> 00:01:59,699
functionalities then I'm going to talk

42
00:01:56,549 --> 00:02:03,329
about over-the-air firmware upgrades for

43
00:01:59,700 --> 00:02:05,040
ble chips so what are the mechanism is

44
00:02:03,329 --> 00:02:08,489
for allow OTA

45
00:02:05,040 --> 00:02:11,670
upgrades really chips are they secure

46
00:02:08,489 --> 00:02:12,660
when are they secure and so forth and

47
00:02:11,670 --> 00:02:14,220
then we're going to

48
00:02:12,660 --> 00:02:17,760
the two of all about vulnerabilities

49
00:02:14,220 --> 00:02:19,200
that I mentioned the first is if ability

50
00:02:17,760 --> 00:02:23,100
that affects every back this points

51
00:02:19,200 --> 00:02:26,670
there really shimmer in the beauty chip

52
00:02:23,100 --> 00:02:27,960
that's using interact-as points and then

53
00:02:26,670 --> 00:02:30,030
I'm going to talk about second

54
00:02:27,960 --> 00:02:33,930
vulnerability which is gonna be latina

55
00:02:30,030 --> 00:02:37,710
TI's Texas in France merely stack but is

56
00:02:33,930 --> 00:02:39,900
used in many of their whaling ships and

57
00:02:37,710 --> 00:02:42,570
this is an RC vulnerability I think

58
00:02:39,900 --> 00:02:45,660
maybe as far as I know

59
00:02:42,570 --> 00:02:47,820
first mobility found in a melee

60
00:02:45,660 --> 00:02:49,950
controller or Bluetooth controller level

61
00:02:47,820 --> 00:02:54,359
right so really close to the hardware

62
00:02:49,950 --> 00:02:56,609
level and indoor talking extensively

63
00:02:54,360 --> 00:02:59,490
about how we exploited this

64
00:02:56,610 --> 00:03:02,360
vulnerability on a Cisco access point

65
00:02:59,490 --> 00:03:09,870
and in general impact of this on

66
00:03:02,360 --> 00:03:13,650
networks and the security of really so

67
00:03:09,870 --> 00:03:15,690
to begin to begin just a bit about

68
00:03:13,650 --> 00:03:17,820
bluetooth or energy why why is it used

69
00:03:15,690 --> 00:03:20,700
what is the benefits of having Bluetooth

70
00:03:17,820 --> 00:03:23,160
Low Energy and different environments

71
00:03:20,700 --> 00:03:24,899
different verticals so Bluetooth Low

72
00:03:23,160 --> 00:03:26,609
Energy is kind of on the cool new kid

73
00:03:24,900 --> 00:03:29,190
around the block when you look at a

74
00:03:26,610 --> 00:03:32,370
little sparkle in general it's been

75
00:03:29,190 --> 00:03:35,600
around a few years but it's really not

76
00:03:32,370 --> 00:03:39,959
adopted very fast by many industries

77
00:03:35,600 --> 00:03:43,560
there are good causes for this it is the

78
00:03:39,959 --> 00:03:48,900
newer version of bluetooth so it doesn't

79
00:03:43,560 --> 00:03:52,739
have many of old generation code that

80
00:03:48,900 --> 00:03:55,200
was involved in Bluetooth so it's much

81
00:03:52,739 --> 00:03:57,360
cleaner and it's also lower energy right

82
00:03:55,200 --> 00:04:00,238
so there was a lot of applications that

83
00:03:57,360 --> 00:04:02,459
can benefit from being lower energy and

84
00:04:00,239 --> 00:04:04,200
it is being used in many vehicles like I

85
00:04:02,459 --> 00:04:07,220
mentioned it's using the healthcare

86
00:04:04,200 --> 00:04:09,589
devices medical devices in healthcare

87
00:04:07,220 --> 00:04:13,830
systems in general in manufacturing

88
00:04:09,590 --> 00:04:16,918
warehouses and facilities in retail and

89
00:04:13,830 --> 00:04:20,090
in general IOT devices that are if you

90
00:04:16,918 --> 00:04:20,089
can find throughout officers

91
00:04:20,269 --> 00:04:25,950
but why really is it used in access

92
00:04:23,010 --> 00:04:28,409
points what is the use case they're so

93
00:04:25,950 --> 00:04:30,960
access points had the advantage of

94
00:04:28,410 --> 00:04:32,640
already being deployed throughout many

95
00:04:30,960 --> 00:04:35,340
organizations right there are the

96
00:04:32,640 --> 00:04:38,340
backbone to serving Wi-Fi to the entire

97
00:04:35,340 --> 00:04:41,099
organization so they're already the

98
00:04:38,340 --> 00:04:43,080
infrastructure is already there so any

99
00:04:41,100 --> 00:04:45,330
application that you really can benefit

100
00:04:43,080 --> 00:04:48,060
from the fact that an access point can

101
00:04:45,330 --> 00:04:50,030
be part of that application since it's

102
00:04:48,060 --> 00:04:52,830
already deployed in the organization and

103
00:04:50,030 --> 00:04:54,599
in fact there are many different

104
00:04:52,830 --> 00:04:57,359
applications that take in versions of

105
00:04:54,600 --> 00:04:59,790
this ability you have indoor navigation

106
00:04:57,360 --> 00:05:02,730
systems for example you want to do

107
00:04:59,790 --> 00:05:05,720
navigations inside closed building and

108
00:05:02,730 --> 00:05:08,940
so that's points we sent out beacons

109
00:05:05,720 --> 00:05:11,420
which can help implement internal

110
00:05:08,940 --> 00:05:14,100
vacation systems you can also see the

111
00:05:11,420 --> 00:05:16,620
medical asset tracking applications or

112
00:05:14,100 --> 00:05:20,130
other asset tracking applications where

113
00:05:16,620 --> 00:05:22,650
you want to track devices their location

114
00:05:20,130 --> 00:05:23,969
and so you put a beacon on on the

115
00:05:22,650 --> 00:05:27,239
devices on the track and the access

116
00:05:23,970 --> 00:05:30,870
points will track these weekends retails

117
00:05:27,240 --> 00:05:34,860
also use belief or a customer tracking

118
00:05:30,870 --> 00:05:38,190
or what you also look at as spying on

119
00:05:34,860 --> 00:05:40,080
their customers and in some sense but

120
00:05:38,190 --> 00:05:43,080
this allows them to engage with

121
00:05:40,080 --> 00:05:45,390
customers right and to know some

122
00:05:43,080 --> 00:05:46,979
specific person entered the shopping

123
00:05:45,390 --> 00:05:48,750
mall or something and now we can show

124
00:05:46,980 --> 00:05:51,360
him a specific advertisement or

125
00:05:48,750 --> 00:05:53,790
something and then you have the last a

126
00:05:51,360 --> 00:05:55,950
use case that's getting traction also

127
00:05:53,790 --> 00:05:59,250
innovation here is the use of smart

128
00:05:55,950 --> 00:06:02,880
sensors mainly in manufacturing but

129
00:05:59,250 --> 00:06:05,550
others as well the sensors will send out

130
00:06:02,880 --> 00:06:07,290
the read over ble beacons and at this

131
00:06:05,550 --> 00:06:09,390
point can serve as gateways to those

132
00:06:07,290 --> 00:06:11,790
beacons that are connecting them to

133
00:06:09,390 --> 00:06:16,200
which loud order or the Internet in

134
00:06:11,790 --> 00:06:19,200
general but really when we looked at the

135
00:06:16,200 --> 00:06:22,110
availability is found in these devices

136
00:06:19,200 --> 00:06:24,229
in these chips and their effect on

137
00:06:22,110 --> 00:06:29,880
practice points in or networks through

138
00:06:24,230 --> 00:06:32,550
that ability is our impact was similar

139
00:06:29,880 --> 00:06:32,980
to the Internet's impact once we really

140
00:06:32,550 --> 00:06:35,320
sorry

141
00:06:32,980 --> 00:06:38,560
why I really do you need Billy in access

142
00:06:35,320 --> 00:06:40,690
points and like one person voting staff

143
00:06:38,560 --> 00:06:46,360
dot obviously it is there to increase

144
00:06:40,690 --> 00:06:48,400
the tax service so as I mentioned our

145
00:06:46,360 --> 00:06:51,070
two vulnerabilities we found and we're

146
00:06:48,400 --> 00:06:53,799
going to discuss today Billy stack has

147
00:06:51,070 --> 00:06:56,710
different layers and different functions

148
00:06:53,800 --> 00:06:59,170
to in the layers in the eyes tips we're

149
00:06:56,710 --> 00:07:02,289
going to talk about most of these errors

150
00:06:59,170 --> 00:07:04,630
are embedded inside the inside one chip

151
00:07:02,290 --> 00:07:07,060
it's a system on chip so it has it

152
00:07:04,630 --> 00:07:09,340
embedded all of these layers inside the

153
00:07:07,060 --> 00:07:12,490
chip but it can also be split between a

154
00:07:09,340 --> 00:07:14,320
couple of different processors it's much

155
00:07:12,490 --> 00:07:17,260
simpler than the classic Bluetooth it's

156
00:07:14,320 --> 00:07:19,420
not so many parts but essentially you

157
00:07:17,260 --> 00:07:20,770
have inter controller layer you have a

158
00:07:19,420 --> 00:07:23,760
physical layer you have the link layer

159
00:07:20,770 --> 00:07:26,530
that does most of the basic

160
00:07:23,760 --> 00:07:29,440
functionalities lowly functionalities

161
00:07:26,530 --> 00:07:32,739
for the protocol in clear

162
00:07:29,440 --> 00:07:35,650
we also found one wall ability as I

163
00:07:32,740 --> 00:07:38,800
mentioned that affects Billy stacks in

164
00:07:35,650 --> 00:07:40,719
ki chips and this ships are already also

165
00:07:38,800 --> 00:07:43,480
used by Cisco and Oracle access points

166
00:07:40,720 --> 00:07:45,730
so they affect these but we can also

167
00:07:43,480 --> 00:07:48,670
affect other devices right because it's

168
00:07:45,730 --> 00:07:51,310
a really stack availability in these

169
00:07:48,670 --> 00:07:53,560
chips any device that uses these chips

170
00:07:51,310 --> 00:07:55,720
in the vulnerable state will be affected

171
00:07:53,560 --> 00:07:57,520
by this one ability so it's it has a

172
00:07:55,720 --> 00:08:00,700
potential to affect many devices when

173
00:07:57,520 --> 00:08:03,430
you continue up the stack you have all

174
00:08:00,700 --> 00:08:06,610
these parts that are in the host layer

175
00:08:03,430 --> 00:08:08,470
and they are they were function is more

176
00:08:06,610 --> 00:08:10,560
high-level they create creating

177
00:08:08,470 --> 00:08:14,050
connections listening for connections

178
00:08:10,560 --> 00:08:17,380
you have this specific part is called

179
00:08:14,050 --> 00:08:19,810
gat which is the most simple way to

180
00:08:17,380 --> 00:08:22,930
transform transferred a data over mealy

181
00:08:19,810 --> 00:08:23,890
it's like a REST API you may like for

182
00:08:22,930 --> 00:08:26,620
Billy

183
00:08:23,890 --> 00:08:28,960
so it allows you really a simple way to

184
00:08:26,620 --> 00:08:30,970
transfer data and on top of that you

185
00:08:28,960 --> 00:08:32,650
have a specific application and that

186
00:08:30,970 --> 00:08:35,169
will obviously change between one device

187
00:08:32,650 --> 00:08:38,169
in another what is let's use case of

188
00:08:35,169 --> 00:08:40,510
baby and in this there we found the one

189
00:08:38,169 --> 00:08:43,710
ability that effects Aruba which I'm

190
00:08:40,510 --> 00:08:43,710
going to talk about now

191
00:08:46,180 --> 00:08:50,540
so when you look at over there are

192
00:08:48,440 --> 00:08:54,440
solutions for a few more upgrades in

193
00:08:50,540 --> 00:08:56,630
Billy chips so these chips are

194
00:08:54,440 --> 00:08:58,730
standalone device right you don't have

195
00:08:56,630 --> 00:09:00,950
any other communication channel other

196
00:08:58,730 --> 00:09:02,570
than melee they are not connected to the

197
00:09:00,950 --> 00:09:05,270
internet they are standalone you can

198
00:09:02,570 --> 00:09:08,030
find them in IOT devices or even in

199
00:09:05,270 --> 00:09:11,420
access points where they're alongside

200
00:09:08,030 --> 00:09:14,300
another processor and so they need to

201
00:09:11,420 --> 00:09:17,780
find a way to neutralize over there or

202
00:09:14,300 --> 00:09:19,490
verbally and so we we wanted to see what

203
00:09:17,780 --> 00:09:22,459
are the challenges in these solutions

204
00:09:19,490 --> 00:09:25,330
there are two major vendors that do ble

205
00:09:22,460 --> 00:09:27,920
chips standalone system of chips

206
00:09:25,330 --> 00:09:29,630
Texas Instruments and Nordic

207
00:09:27,920 --> 00:09:32,900
semiconductors there are others but just

208
00:09:29,630 --> 00:09:37,310
for the ease of for this let's consider

209
00:09:32,900 --> 00:09:41,060
these two and they have each separate

210
00:09:37,310 --> 00:09:43,189
framework for doing okay upgrades Texas

211
00:09:41,060 --> 00:09:46,400
Instruments has OAD over-the-air

212
00:09:43,190 --> 00:09:48,680
download and nordic has the fu device

213
00:09:46,400 --> 00:09:51,199
firmware upgrade so the challenges in

214
00:09:48,680 --> 00:09:54,560
securing these solutions these

215
00:09:51,200 --> 00:09:58,040
frameworks are obvious right you need to

216
00:09:54,560 --> 00:10:00,349
find a way to transfer the fumer over

217
00:09:58,040 --> 00:10:03,170
biele in a secure manner so it can't be

218
00:10:00,350 --> 00:10:05,900
captured really has encryption but in

219
00:10:03,170 --> 00:10:08,689
order to use that Egyptian the best way

220
00:10:05,900 --> 00:10:10,819
to do so is to create a bond a baby bond

221
00:10:08,690 --> 00:10:14,780
which is the equivalent of bluetooth

222
00:10:10,820 --> 00:10:17,090
caring and so that's another challenge

223
00:10:14,780 --> 00:10:19,730
we want these connections to be offer a

224
00:10:17,090 --> 00:10:21,650
bonded baby connection and then you want

225
00:10:19,730 --> 00:10:24,550
to use authentication that's also

226
00:10:21,650 --> 00:10:28,579
connect connected to the fact you have

227
00:10:24,550 --> 00:10:29,990
you've done a billabong trial so is the

228
00:10:28,580 --> 00:10:32,360
connection of antiquated can you

229
00:10:29,990 --> 00:10:34,520
validate who is doing the firmware

230
00:10:32,360 --> 00:10:36,830
upgrade and lastly but most importantly

231
00:10:34,520 --> 00:10:39,079
you want to validate the integrity of

232
00:10:36,830 --> 00:10:41,450
the femurs that is being uploaded with a

233
00:10:39,080 --> 00:10:43,390
signature or in other means you want to

234
00:10:41,450 --> 00:10:45,510
validate the shimmer is may be

235
00:10:43,390 --> 00:10:49,139
trustworthy

236
00:10:45,510 --> 00:10:51,569
I think practice these frameworks exist

237
00:10:49,139 --> 00:10:54,209
for a few years but not so many the

238
00:10:51,570 --> 00:10:57,540
recent versions are more secure but the

239
00:10:54,209 --> 00:11:00,359
ones that are used today in market that

240
00:10:57,540 --> 00:11:02,730
secure or not secure at all the funeral

241
00:11:00,360 --> 00:11:05,010
encrypt order of the error the add

242
00:11:02,730 --> 00:11:06,959
connections is not offended again this

243
00:11:05,010 --> 00:11:10,470
is by judicial configuration each

244
00:11:06,959 --> 00:11:12,359
application can change this but but by

245
00:11:10,470 --> 00:11:15,269
default it's not educated and the

246
00:11:12,360 --> 00:11:17,250
funeral is not validated or if it is

247
00:11:15,269 --> 00:11:22,199
validated it uses a week before

248
00:11:17,250 --> 00:11:23,970
signature that can be abused so when we

249
00:11:22,199 --> 00:11:25,859
looked in Aruba at this point we wanted

250
00:11:23,970 --> 00:11:29,160
to understand what is the attack surface

251
00:11:25,860 --> 00:11:32,430
here and so the first thing we did is we

252
00:11:29,160 --> 00:11:35,610
tried to connect to get when the Aruba

253
00:11:32,430 --> 00:11:38,489
is in weakening mode so we and at this

254
00:11:35,610 --> 00:11:41,250
point has a different mode when it's

255
00:11:38,490 --> 00:11:43,500
using the BD functionalities but the

256
00:11:41,250 --> 00:11:45,540
most basic one is using a beginning mode

257
00:11:43,500 --> 00:11:48,089
it just sends out specific unique

258
00:11:45,540 --> 00:11:50,760
identifier over advertising packets but

259
00:11:48,089 --> 00:11:53,190
to our surprise even in that mode the

260
00:11:50,760 --> 00:11:57,329
gas was still open and we can connect to

261
00:11:53,190 --> 00:12:00,029
it and see the services that this device

262
00:11:57,329 --> 00:12:02,969
exposes more interesting was the

263
00:12:00,029 --> 00:12:06,240
specific unique identifier which is CI

264
00:12:02,970 --> 00:12:08,610
is a ID service so it seems there is

265
00:12:06,240 --> 00:12:11,870
just maybe the ability to upload from

266
00:12:08,610 --> 00:12:15,420
you to this beauty tip over Oh Edie a

267
00:12:11,870 --> 00:12:18,209
bit about oh it in general just to

268
00:12:15,420 --> 00:12:20,699
understand the mechanics of it it's

269
00:12:18,209 --> 00:12:23,339
pretty simple you have a user there is a

270
00:12:20,699 --> 00:12:23,849
device you want to upload it if you were

271
00:12:23,339 --> 00:12:26,100
to it

272
00:12:23,850 --> 00:12:28,319
the first thing is initiating a gas

273
00:12:26,100 --> 00:12:30,690
connection and then you can send an

274
00:12:28,319 --> 00:12:33,540
immediate identify message simple

275
00:12:30,690 --> 00:12:36,269
message with similar header in it and if

276
00:12:33,540 --> 00:12:39,300
that's where is in the correct version

277
00:12:36,269 --> 00:12:41,069
or something something pretty simple the

278
00:12:39,300 --> 00:12:43,319
device will acknowledge it by sending

279
00:12:41,069 --> 00:12:45,930
image block request which will then

280
00:12:43,319 --> 00:12:47,729
follow an image block message sent from

281
00:12:45,930 --> 00:12:50,638
the user to device containing a chunk of

282
00:12:47,730 --> 00:12:52,290
the femur and this will continue this

283
00:12:50,639 --> 00:12:54,720
process design new chunks of the femur

284
00:12:52,290 --> 00:12:57,000
will be in a loop until all chunks have

285
00:12:54,720 --> 00:12:57,830
been sent at which point the device will

286
00:12:57,000 --> 00:12:58,940
reboot

287
00:12:57,830 --> 00:13:02,540
into the new camera so very

288
00:12:58,940 --> 00:13:04,970
straightforward so naturally we tried

289
00:13:02,540 --> 00:13:07,880
just uploading our femur over OED today

290
00:13:04,970 --> 00:13:09,440
we'll back this point and it didn't

291
00:13:07,880 --> 00:13:10,970
really work we initiated a got

292
00:13:09,440 --> 00:13:13,430
connection we sent an image identified

293
00:13:10,970 --> 00:13:15,430
but no response always received so

294
00:13:13,430 --> 00:13:17,510
something was customized by

295
00:13:15,430 --> 00:13:20,239
implementation and we wanted to find out

296
00:13:17,510 --> 00:13:22,550
find out what so the logical next step

297
00:13:20,240 --> 00:13:27,800
let's open the stop let's hook up the

298
00:13:22,550 --> 00:13:29,599
debugger and dump the fumarole and in

299
00:13:27,800 --> 00:13:33,199
fact when looking at this function that

300
00:13:29,600 --> 00:13:34,459
does the functionalities in the

301
00:13:33,200 --> 00:13:37,190
framework we noticed there is an

302
00:13:34,459 --> 00:13:39,680
additional call to mem compare yeah so

303
00:13:37,190 --> 00:13:41,750
may be added like I mentioned something

304
00:13:39,680 --> 00:13:45,979
custom that validates you know it in

305
00:13:41,750 --> 00:13:49,820
some sense when you look at the eyes

306
00:13:45,980 --> 00:13:53,360
away the function this function receives

307
00:13:49,820 --> 00:13:57,200
any gap right request and then

308
00:13:53,360 --> 00:13:59,930
dispatches them to specific functions so

309
00:13:57,200 --> 00:14:01,910
it's very simple you compare the unique

310
00:13:59,930 --> 00:14:06,290
identifier is being being waiting right

311
00:14:01,910 --> 00:14:08,689
now to the image identifies new D and if

312
00:14:06,290 --> 00:14:13,849
it is so you you can call the function

313
00:14:08,690 --> 00:14:17,270
that handles that that message and if if

314
00:14:13,850 --> 00:14:19,700
you find it to be equal to another value

315
00:14:17,270 --> 00:14:21,740
for the image block method you can call

316
00:14:19,700 --> 00:14:25,459
that function lets handle that message

317
00:14:21,740 --> 00:14:27,860
so it's very straightforward in a robust

318
00:14:25,459 --> 00:14:30,170
implementation like I said we found that

319
00:14:27,860 --> 00:14:32,560
there is an additional code here and

320
00:14:30,170 --> 00:14:36,260
zooming in on the main comparison that I

321
00:14:32,560 --> 00:14:37,969
talked about before there is just two

322
00:14:36,260 --> 00:14:41,890
more men compares or three more memo

323
00:14:37,970 --> 00:14:44,570
compares here that validate another

324
00:14:41,890 --> 00:14:47,120
unique identifier and if you write a

325
00:14:44,570 --> 00:14:51,290
specific unique identifier of the OED

326
00:14:47,120 --> 00:14:53,630
unlock team with a specific value with

327
00:14:51,290 --> 00:14:56,300
oh it cooking then that unlocks the

328
00:14:53,630 --> 00:15:00,260
specific global state is already

329
00:14:56,300 --> 00:15:04,160
unlocked and if you do this with another

330
00:15:00,260 --> 00:15:06,860
value that unlocks another state this is

331
00:15:04,160 --> 00:15:09,140
some cell record of the function that we

332
00:15:06,860 --> 00:15:11,990
were reverse-engineer before

333
00:15:09,140 --> 00:15:13,160
so obviously every bad added encourage a

334
00:15:11,990 --> 00:15:15,740
heart or a password to their

335
00:15:13,160 --> 00:15:18,860
implementation it is not me out one two

336
00:15:15,740 --> 00:15:26,180
three four but it's not a good solution

337
00:15:18,860 --> 00:15:29,209
either way and so really what this is is

338
00:15:26,180 --> 00:15:31,540
the ability to upload famer over be lean

339
00:15:29,209 --> 00:15:34,369
on Senate uh no physical connection

340
00:15:31,540 --> 00:15:36,050
using this haircut password and then you

341
00:15:34,370 --> 00:15:45,260
can have your own matrix code on this

342
00:15:36,050 --> 00:15:47,630
really cheap so what what can an

343
00:15:45,260 --> 00:15:49,069
attacker do by gaining access to a

344
00:15:47,630 --> 00:15:50,990
really cheap in silent access point

345
00:15:49,070 --> 00:15:54,350
right is still initially is still

346
00:15:50,990 --> 00:15:58,279
confined to only being affecting this

347
00:15:54,350 --> 00:16:01,060
specific chip continue is what is the

348
00:15:58,279 --> 00:16:03,890
next step for him so at this point

349
00:16:01,060 --> 00:16:07,880
design is such that Billy chip has

350
00:16:03,890 --> 00:16:11,930
access to to your interfaces zero York

351
00:16:07,880 --> 00:16:14,630
interfaces one of them is used for a

352
00:16:11,930 --> 00:16:16,969
configuration of the ble chip form of

353
00:16:14,630 --> 00:16:19,010
the main CPU and from Beadie packets

354
00:16:16,970 --> 00:16:21,110
being sent back from the Bailey chip to

355
00:16:19,010 --> 00:16:23,390
the main CPU so this interface is one

356
00:16:21,110 --> 00:16:25,190
avenue for an attacker to look for

357
00:16:23,390 --> 00:16:27,670
additional vulnerabilities to try and

358
00:16:25,190 --> 00:16:31,100
target the main CPU of an at this point

359
00:16:27,670 --> 00:16:34,880
but another one exists here that will be

360
00:16:31,100 --> 00:16:38,209
much simpler every access points can be

361
00:16:34,880 --> 00:16:41,720
configured to allow a user to connect to

362
00:16:38,209 --> 00:16:43,459
a console to a terminal console over a

363
00:16:41,720 --> 00:16:45,380
BD connection so this is the same

364
00:16:43,459 --> 00:16:48,109
console you get if you can attack serial

365
00:16:45,380 --> 00:16:50,390
cable to a network device but this is

366
00:16:48,110 --> 00:16:52,040
offered over a BD connection you listed

367
00:16:50,390 --> 00:16:53,029
to be useful in some scenarios where

368
00:16:52,040 --> 00:16:55,610
there at this point

369
00:16:53,029 --> 00:16:56,930
I needs to be configured you know for

370
00:16:55,610 --> 00:17:01,370
network configurations it's not

371
00:16:56,930 --> 00:17:05,540
physically accessible its way up in the

372
00:17:01,370 --> 00:17:06,890
ceiling or something so this feature is

373
00:17:05,540 --> 00:17:08,569
implemented by the fact that the UART

374
00:17:06,890 --> 00:17:11,120
interface between the console and the

375
00:17:08,569 --> 00:17:14,418
main CPU is shared with merely chip so

376
00:17:11,119 --> 00:17:16,179
the melee chip may be able to use this

377
00:17:14,419 --> 00:17:18,940
interface

378
00:17:16,180 --> 00:17:21,630
by an attacker and get access to that

379
00:17:18,940 --> 00:17:25,660
shell interface and this interface

380
00:17:21,630 --> 00:17:27,820
exposes few commands you can configure

381
00:17:25,660 --> 00:17:29,710
the network configurations of an access

382
00:17:27,819 --> 00:17:32,129
point you can even send packets within

383
00:17:29,710 --> 00:17:34,840
the network it can be password protected

384
00:17:32,130 --> 00:17:38,170
but it actually can also be not

385
00:17:34,840 --> 00:17:40,330
protected it's not them it must and can

386
00:17:38,170 --> 00:17:43,590
also potentially be work force so it's

387
00:17:40,330 --> 00:17:48,340
not it's not clear how the security

388
00:17:43,590 --> 00:17:52,860
solution so how would an attack with me

389
00:17:48,340 --> 00:17:55,090
look like how would it be carried out

390
00:17:52,860 --> 00:17:58,090
first like I mentioned you can upload

391
00:17:55,090 --> 00:18:01,540
the mer-ka-ba chip using the hardware

392
00:17:58,090 --> 00:18:03,550
passwords then the attacker can use a

393
00:18:01,540 --> 00:18:06,159
few more that gives me access to this

394
00:18:03,550 --> 00:18:09,250
console connection although this

395
00:18:06,160 --> 00:18:11,560
connection is configurable by the main

396
00:18:09,250 --> 00:18:14,770
CPU the ble chip is the one that carries

397
00:18:11,560 --> 00:18:16,270
out whether it's on or off so once

398
00:18:14,770 --> 00:18:19,440
you're on that chip you can make it

399
00:18:16,270 --> 00:18:22,720
access that your interface regardless

400
00:18:19,440 --> 00:18:25,690
looking at an entire network here or

401
00:18:22,720 --> 00:18:26,950
zooming out a bit and at this point will

402
00:18:25,690 --> 00:18:29,320
generally have access to multiple

403
00:18:26,950 --> 00:18:30,400
segments right I preserve both the

404
00:18:29,320 --> 00:18:33,040
corporate network and in the guest

405
00:18:30,400 --> 00:18:35,920
network or maybe other segments so

406
00:18:33,040 --> 00:18:38,040
gaining access to the main CPU of an

407
00:18:35,920 --> 00:18:42,130
access point can potentially lead in a

408
00:18:38,040 --> 00:18:43,360
calculus all of these segments if the

409
00:18:42,130 --> 00:18:45,880
network is connected to the Internet

410
00:18:43,360 --> 00:18:47,500
like many are in fact we can also take

411
00:18:45,880 --> 00:18:50,470
advantage of this and create an outbound

412
00:18:47,500 --> 00:18:53,890
connection to a C&C server and that at

413
00:18:50,470 --> 00:18:55,390
that point he no longer needs to be in

414
00:18:53,890 --> 00:18:56,710
vicinity of the device that he's

415
00:18:55,390 --> 00:18:59,470
attacking he doesn't need to use really

416
00:18:56,710 --> 00:19:01,600
he can create a backdoor over that C&C

417
00:18:59,470 --> 00:19:05,260
connection and then the attack and

418
00:19:01,600 --> 00:19:09,070
continue over the Internet ok so we

419
00:19:05,260 --> 00:19:13,120
wanted to to see how an attack like this

420
00:19:09,070 --> 00:19:15,790
will work and because we are also

421
00:19:13,120 --> 00:19:18,310
engineers and we like the idea of it we

422
00:19:15,790 --> 00:19:20,970
decided to take the attack airborne as

423
00:19:18,310 --> 00:19:20,970
you'd see in a minute

424
00:19:21,970 --> 00:19:30,190
[Music]

425
00:19:29,010 --> 00:19:35,230
yeah

426
00:19:30,190 --> 00:19:39,040
so our office is in Tel Aviv in a pine

427
00:19:35,230 --> 00:19:41,770
floor so we want to see if we can come

428
00:19:39,040 --> 00:19:43,320
from the era literally in attack in a

429
00:19:41,770 --> 00:19:48,370
row back this point sitting in our

430
00:19:43,320 --> 00:19:51,310
office we installed an Ubuntu on an old

431
00:19:48,370 --> 00:19:54,340
nex-5 we attached to a drone I'm a

432
00:19:51,310 --> 00:19:55,659
hacker for this demonstration in the

433
00:19:54,340 --> 00:19:57,850
smartphone is connected with the server

434
00:19:55,660 --> 00:20:00,580
connection to a scene server C&C server

435
00:19:57,850 --> 00:20:02,500
which the laptop is also connected to so

436
00:20:00,580 --> 00:20:12,929
the laptop on the ground controls the

437
00:20:02,500 --> 00:20:17,950
smartphone in there so getting to the

438
00:20:12,930 --> 00:20:20,440
27th floor was a bit of a challenge and

439
00:20:17,950 --> 00:20:22,490
the Maverick didn't really like the

440
00:20:20,440 --> 00:20:29,770
added weight but but he managed

441
00:20:22,490 --> 00:20:29,770
[Music]

442
00:20:32,450 --> 00:20:37,420
[Music]

443
00:20:34,740 --> 00:20:44,740
in here on the table is their back this

444
00:20:37,420 --> 00:20:47,110
point waiting to be owned okay so once

445
00:20:44,740 --> 00:20:49,960
once you're in the drone or the

446
00:20:47,110 --> 00:20:52,030
smartphone is nearby you can search for

447
00:20:49,960 --> 00:20:54,010
beacons they're about access point using

448
00:20:52,030 --> 00:20:56,920
beginning mode right so you can find the

449
00:20:54,010 --> 00:20:59,700
market race by that you can see use the

450
00:20:56,920 --> 00:21:02,050
gut tool to find the OBD service and

451
00:20:59,700 --> 00:21:04,180
then we wrote this small script that

452
00:21:02,050 --> 00:21:05,950
just uses the heart or the password we

453
00:21:04,180 --> 00:21:09,100
retrieved from the streamer and uploads

454
00:21:05,950 --> 00:21:10,960
our own weather system or this is a bit

455
00:21:09,100 --> 00:21:16,840
sped up but it takes about a minute to

456
00:21:10,960 --> 00:21:19,420
upload a few more so that fumer allows

457
00:21:16,840 --> 00:21:21,669
us access unauthenticated to this shell

458
00:21:19,420 --> 00:21:24,250
interface so we just use the shell

459
00:21:21,670 --> 00:21:25,510
access on the 18 and through this Billie

460
00:21:24,250 --> 00:21:27,750
connection we can change network

461
00:21:25,510 --> 00:21:31,030
configurations

462
00:21:27,750 --> 00:21:35,830
you know if can figure out all of these

463
00:21:31,030 --> 00:21:37,510
commands and you can also send packets

464
00:21:35,830 --> 00:21:40,990
within the network there is a ping

465
00:21:37,510 --> 00:21:43,120
command for that an interesting aspect

466
00:21:40,990 --> 00:21:46,540
is that Billy is connected to this

467
00:21:43,120 --> 00:21:49,540
console interface even throughout a boot

468
00:21:46,540 --> 00:21:50,920
of a reboot of the device so by

469
00:21:49,540 --> 00:21:53,080
rebooting the AAP through this interface

470
00:21:50,920 --> 00:21:56,410
we can access the bootloader shell over

471
00:21:53,080 --> 00:21:59,350
this media connection and change boot

472
00:21:56,410 --> 00:22:01,510
parameters maybe potentially even upload

473
00:21:59,350 --> 00:22:09,189
like an older version of the entire ap

474
00:22:01,510 --> 00:22:11,470
or something as I mentioned if the

475
00:22:09,190 --> 00:22:13,300
attacker does achieve code execution on

476
00:22:11,470 --> 00:22:15,670
the main CPU he can create an out world

477
00:22:13,300 --> 00:22:19,169
connection and then the facility of the

478
00:22:15,670 --> 00:22:19,170
drone is no longer needed

479
00:22:20,870 --> 00:22:24,459
[Music]

480
00:22:26,180 --> 00:22:29,319
[Applause]

481
00:22:29,630 --> 00:22:37,650
okay yeah so this is one ability the

482
00:22:34,770 --> 00:22:39,960
rubberband is significant but we have

483
00:22:37,650 --> 00:22:41,910
more to discuss so this second ability

484
00:22:39,960 --> 00:22:44,730
as I mentioned is in T is Billy stack

485
00:22:41,910 --> 00:22:47,010
and it effects is kuraki am at this

486
00:22:44,730 --> 00:22:49,200
point but potentially other devices and

487
00:22:47,010 --> 00:22:53,160
this mobility is in the code that parses

488
00:22:49,200 --> 00:22:55,200
beacons parses incoming packets in Billy

489
00:22:53,160 --> 00:22:57,780
you have different roles a device can be

490
00:22:55,200 --> 00:23:00,900
scanner it's kind of role or an

491
00:22:57,780 --> 00:23:02,550
advertiser role and it's simple right

492
00:23:00,900 --> 00:23:04,110
when one device would send out beacons

493
00:23:02,550 --> 00:23:06,270
through what is called advertising

494
00:23:04,110 --> 00:23:09,120
packets and the other will listen to

495
00:23:06,270 --> 00:23:11,790
these packets and in parse them as they

496
00:23:09,120 --> 00:23:13,919
come in and you have three channels for

497
00:23:11,790 --> 00:23:16,560
that are fixed channels for advertising

498
00:23:13,920 --> 00:23:18,330
packets on Billy and so the advertiser

499
00:23:16,560 --> 00:23:19,740
will send these packets on all of these

500
00:23:18,330 --> 00:23:20,909
channels and the scanner will hop

501
00:23:19,740 --> 00:23:22,680
between these three between the

502
00:23:20,910 --> 00:23:27,720
frequencies and listen to these packets

503
00:23:22,680 --> 00:23:29,430
a Billy packet is has a structure that

504
00:23:27,720 --> 00:23:32,040
is pretty straightforward you have a

505
00:23:29,430 --> 00:23:34,260
preamble fixed access address and then a

506
00:23:32,040 --> 00:23:36,290
PDU that is different between shape this

507
00:23:34,260 --> 00:23:38,879
advertising channel or another channel

508
00:23:36,290 --> 00:23:42,629
in advertising channel you have a two

509
00:23:38,880 --> 00:23:46,710
bytes header and then 30 up to 37 bytes

510
00:23:42,630 --> 00:23:50,460
of payload this two byte header is built

511
00:23:46,710 --> 00:23:52,260
up with different flags but there is one

512
00:23:50,460 --> 00:23:57,090
interesting piece here that I want to

513
00:23:52,260 --> 00:23:59,100
mention there is a length field in the

514
00:23:57,090 --> 00:24:00,750
header and that actually changed the

515
00:23:59,100 --> 00:24:03,389
length field changed between Bluetooth

516
00:24:00,750 --> 00:24:06,330
4.2 in verses 5 with the 5 is now

517
00:24:03,390 --> 00:24:09,690
becoming interesting to the market so

518
00:24:06,330 --> 00:24:12,439
chips are being designed to use this new

519
00:24:09,690 --> 00:24:15,240
protocol and the length field between

520
00:24:12,440 --> 00:24:19,140
4.2 and will size increased from six

521
00:24:15,240 --> 00:24:22,500
bits to a bit and in the order of

522
00:24:19,140 --> 00:24:25,980
version in 4.20 an additional two bits

523
00:24:22,500 --> 00:24:28,050
in that bite reserved for future use are

524
00:24:25,980 --> 00:24:31,020
a few bits and they were also always

525
00:24:28,050 --> 00:24:33,570
supposed to be 0 bits so this change in

526
00:24:31,020 --> 00:24:35,300
the specification might have in

527
00:24:33,570 --> 00:24:37,200
retrospect

528
00:24:35,300 --> 00:24:39,629
leave it to the variability that we

529
00:24:37,200 --> 00:24:41,790
found we're not sure but but this looks

530
00:24:39,630 --> 00:24:45,600
ominous right the fact that the length

531
00:24:41,790 --> 00:24:49,200
field has changes as a potential for for

532
00:24:45,600 --> 00:24:53,340
bugs looking specifically on the

533
00:24:49,200 --> 00:24:55,950
architecture of TI is a mealy chip it's

534
00:24:53,340 --> 00:24:58,409
a it's a part of quite an interesting

535
00:24:55,950 --> 00:25:00,240
device you have you have two cores you

536
00:24:58,410 --> 00:25:03,690
have the main CPU that's running an arm

537
00:25:00,240 --> 00:25:08,370
CPU and this one does most of the logic

538
00:25:03,690 --> 00:25:10,740
work most of the Billy stack logic and

539
00:25:08,370 --> 00:25:13,649
then you have your radio color that also

540
00:25:10,740 --> 00:25:15,930
runs it now scene CPU and that one does

541
00:25:13,650 --> 00:25:18,390
the more more physical layer stuff and

542
00:25:15,930 --> 00:25:21,030
it really the low-level handling of

543
00:25:18,390 --> 00:25:23,820
packets and the link layer is actually

544
00:25:21,030 --> 00:25:26,639
split between these two cores and they

545
00:25:23,820 --> 00:25:29,850
have a shared interface to exchange the

546
00:25:26,640 --> 00:25:31,950
packets that are coming in there are

547
00:25:29,850 --> 00:25:34,530
also systems where you have an

548
00:25:31,950 --> 00:25:35,820
additional CPU like an access point so

549
00:25:34,530 --> 00:25:38,160
the application layer will be split

550
00:25:35,820 --> 00:25:41,070
between the Billy chip and the external

551
00:25:38,160 --> 00:25:45,000
CPU over some interface other york the

552
00:25:41,070 --> 00:25:49,110
face or not or another like many devices

553
00:25:45,000 --> 00:25:50,940
and other devices right there there is

554
00:25:49,110 --> 00:25:52,459
no inherent security in this chip there

555
00:25:50,940 --> 00:25:59,430
is no use of data execution prevention

556
00:25:52,460 --> 00:26:01,800
no SLR and no MMU so finding

557
00:25:59,430 --> 00:26:03,830
availability here still has the

558
00:26:01,800 --> 00:26:06,690
challenge of being able to exploit it

559
00:26:03,830 --> 00:26:08,879
like any other one Willa T but the chip

560
00:26:06,690 --> 00:26:12,780
itself will not stop availability with

561
00:26:08,880 --> 00:26:15,350
inherent mitigations okay looking at

562
00:26:12,780 --> 00:26:18,660
this function this is the function that

563
00:26:15,350 --> 00:26:21,000
parses advertising packets as they are

564
00:26:18,660 --> 00:26:24,870
coming into the chip when it is scanning

565
00:26:21,000 --> 00:26:27,920
for advertising packets and it will do

566
00:26:24,870 --> 00:26:30,149
some parsing of the tacit in some

567
00:26:27,920 --> 00:26:34,110
handling of different types of packets

568
00:26:30,150 --> 00:26:35,220
and such I mean instantly we see that

569
00:26:34,110 --> 00:26:37,709
there are a few problems in this

570
00:26:35,220 --> 00:26:39,720
function the first thing is this

571
00:26:37,710 --> 00:26:40,430
handling of the length field that I

572
00:26:39,720 --> 00:26:42,540
talked about

573
00:26:40,430 --> 00:26:45,120
as I mentioned it's supposed to be six

574
00:26:42,540 --> 00:26:48,149
bits but this code here takes the entire

575
00:26:45,120 --> 00:26:49,049
eight dates from the header and calls it

576
00:26:48,150 --> 00:26:50,580
the pack

577
00:26:49,049 --> 00:26:53,039
I didn't interact this is the packet

578
00:26:50,580 --> 00:26:55,769
length so it doesn't mask out the RFU

579
00:26:53,039 --> 00:26:57,990
meets the reserved bits in the second

580
00:26:55,769 --> 00:27:02,549
problem here is the third line on that

581
00:26:57,990 --> 00:27:04,259
red box where the code will increase six

582
00:27:02,549 --> 00:27:08,820
bytes from the packet length so there's

583
00:27:04,259 --> 00:27:10,440
a potential here to do an intro and the

584
00:27:08,820 --> 00:27:15,029
data length is actually actually a

585
00:27:10,440 --> 00:27:18,600
signed integer in this if case and so if

586
00:27:15,029 --> 00:27:20,100
it is a small number if it's minus 1 or

587
00:27:18,600 --> 00:27:23,668
minus 2 or something it won't be

588
00:27:20,100 --> 00:27:25,590
detected is a large packet but even if

589
00:27:23,669 --> 00:27:27,450
it is detected the function that is

590
00:27:25,590 --> 00:27:30,360
called the hull of sir handler is

591
00:27:27,450 --> 00:27:32,659
actually a null function that does

592
00:27:30,360 --> 00:27:34,918
nothing so the code will carry on and

593
00:27:32,659 --> 00:27:37,350
there is a copy loop at the end of the

594
00:27:34,919 --> 00:27:40,950
function using the packet length pass to

595
00:27:37,350 --> 00:27:45,299
it it will copy then tack it onto the

596
00:27:40,950 --> 00:27:47,820
advertising data pointer so this is many

597
00:27:45,299 --> 00:27:50,789
powerless here in the next step for us

598
00:27:47,820 --> 00:27:52,789
is let's try and crash it let's send

599
00:27:50,789 --> 00:27:56,309
different packets and see what happens

600
00:27:52,789 --> 00:27:57,840
you mentioned there are the length field

601
00:27:56,309 --> 00:28:00,240
which is 6 bits but you also have the

602
00:27:57,840 --> 00:28:02,189
RFU bits and all the 8 bits together are

603
00:28:00,240 --> 00:28:04,740
considered as the length of a packet so

604
00:28:02,190 --> 00:28:07,919
we have a couple of parameters to to

605
00:28:04,740 --> 00:28:10,110
play with initial step we'll let's send

606
00:28:07,919 --> 00:28:12,840
the largest package we can in the 8 bits

607
00:28:10,110 --> 00:28:15,870
but if in crash so if something is not

608
00:28:12,840 --> 00:28:17,908
as expected right now the next step was

609
00:28:15,870 --> 00:28:19,799
write and send a very small packet right

610
00:28:17,909 --> 00:28:23,340
maybe we can hit this integer on the

611
00:28:19,799 --> 00:28:25,320
flow but this also doesn't crash next

612
00:28:23,340 --> 00:28:27,480
thing we thought maybe we can't really

613
00:28:25,320 --> 00:28:29,039
touch these bits there are a few bits so

614
00:28:27,480 --> 00:28:32,730
let's send the largest package we can

615
00:28:29,039 --> 00:28:35,220
within 6 bits if we all also be changing

616
00:28:32,730 --> 00:28:39,000
out of bounds but it's also didn't crash

617
00:28:35,220 --> 00:28:41,279
the store sanity check we decided a

618
00:28:39,000 --> 00:28:43,950
central RS packet we can within the

619
00:28:41,279 --> 00:28:46,980
specification limit a 37 by it's packet

620
00:28:43,950 --> 00:28:48,509
this limit privacy did reach the code

621
00:28:46,980 --> 00:28:51,360
that we were looking looking at so we

622
00:28:48,509 --> 00:28:53,610
are partially in the right direction and

623
00:28:51,360 --> 00:28:55,918
last let's try and carry on one of the

624
00:28:53,610 --> 00:28:58,769
are a few bits but keep the packet at

625
00:28:55,919 --> 00:29:00,540
SRI 7 bytes so it is a short packet

626
00:28:58,769 --> 00:29:02,220
but it may be

627
00:29:00,540 --> 00:29:04,440
be perceived by the code as a large

628
00:29:02,220 --> 00:29:08,790
packet which will result in corruption

629
00:29:04,440 --> 00:29:10,530
and in fact that did pass the device so

630
00:29:08,790 --> 00:29:12,720
we understood there is another mechanism

631
00:29:10,530 --> 00:29:14,399
here that validates the input to others

632
00:29:12,720 --> 00:29:17,850
and cut the code we were looking at what

633
00:29:14,400 --> 00:29:19,470
is that mechanism as I mentioned the

634
00:29:17,850 --> 00:29:22,020
main CPU and the radio core shared the

635
00:29:19,470 --> 00:29:24,930
links are there both do part of it and

636
00:29:22,020 --> 00:29:28,680
when we went back to the manual it was

637
00:29:24,930 --> 00:29:33,090
clear that the radio validates packets

638
00:29:28,680 --> 00:29:34,680
to be between 6 and 37 bytes but when we

639
00:29:33,090 --> 00:29:36,300
look at the code from the radio code we

640
00:29:34,680 --> 00:29:39,150
see that it looks at the length of the

641
00:29:36,300 --> 00:29:41,490
packet as 6 bits as the fine defined in

642
00:29:39,150 --> 00:29:43,560
the specification where is the main core

643
00:29:41,490 --> 00:29:47,970
looked at the entire 8 bits so this

644
00:29:43,560 --> 00:29:49,889
difference leads to this one ability by

645
00:29:47,970 --> 00:29:51,600
sending a small packet but turning on

646
00:29:49,890 --> 00:29:53,640
one of the are a few bits or both of

647
00:29:51,600 --> 00:29:55,679
them it would result in a memory

648
00:29:53,640 --> 00:29:58,670
corruption and how we exploited this

649
00:29:55,680 --> 00:30:03,690
corruption and on the Cisco access point

650
00:29:58,670 --> 00:30:05,640
back to talk to you now okay so I'm

651
00:30:03,690 --> 00:30:08,310
gonna dive deep into exploiting this

652
00:30:05,640 --> 00:30:10,230
vulnerability but before we start

653
00:30:08,310 --> 00:30:12,810
exploiting we need that victim so we

654
00:30:10,230 --> 00:30:15,390
chose this Co IP to exploit the town

655
00:30:12,810 --> 00:30:18,240
because it contains the CC 26:40 chip

656
00:30:15,390 --> 00:30:20,430
and naturally we opened it up hooked up

657
00:30:18,240 --> 00:30:22,380
a debugger and the floor and started not

658
00:30:20,430 --> 00:30:25,050
understanding where the data that is

659
00:30:22,380 --> 00:30:27,990
being that is corrupting and what are we

660
00:30:25,050 --> 00:30:29,550
exactly corrupting so looking back at

661
00:30:27,990 --> 00:30:31,740
the vulnerable function that Ben talked

662
00:30:29,550 --> 00:30:33,450
about you can see that the advertising

663
00:30:31,740 --> 00:30:35,940
that our variable is coming from the

664
00:30:33,450 --> 00:30:36,570
caller function which is advertising

665
00:30:35,940 --> 00:30:38,460
packet

666
00:30:36,570 --> 00:30:41,820
advertising packet is a global variable

667
00:30:38,460 --> 00:30:44,760
that is statically allocated in memory

668
00:30:41,820 --> 00:30:46,770
which is its inari array that contains

669
00:30:44,760 --> 00:30:49,980
the advertising packet that has arrived

670
00:30:46,770 --> 00:30:51,810
and it's it's a new fixed address it's

671
00:30:49,980 --> 00:30:53,910
been mentioned there are no SLR no def

672
00:30:51,810 --> 00:30:55,830
here so it will be allocated at the same

673
00:30:53,910 --> 00:30:59,070
address every time and there's a lot of

674
00:30:55,830 --> 00:31:01,199
interesting stuff to overflow after it's

675
00:30:59,070 --> 00:31:03,389
in the data section so the one that

676
00:31:01,200 --> 00:31:07,350
sticks out the most are the these three

677
00:31:03,390 --> 00:31:09,480
function pointers which are system

678
00:31:07,350 --> 00:31:11,939
critical function pointers the Deaf in

679
00:31:09,480 --> 00:31:13,539
what he uses so the first point of the I

680
00:31:11,940 --> 00:31:15,369
call dispatcher is the

681
00:31:13,539 --> 00:31:17,440
Tim Colgate where every system called

682
00:31:15,369 --> 00:31:19,119
the firm makes every mullick goes

683
00:31:17,440 --> 00:31:21,460
through there that looks like a really

684
00:31:19,119 --> 00:31:22,988
good target for us to control and the

685
00:31:21,460 --> 00:31:25,330
other two are the enter and exit

686
00:31:22,989 --> 00:31:28,539
critical section function pointer which

687
00:31:25,330 --> 00:31:30,519
does exactly that it looks good as well

688
00:31:28,539 --> 00:31:32,080
they are called quite often Li but not

689
00:31:30,519 --> 00:31:35,590
as much as the dispatcher so we're gonna

690
00:31:32,080 --> 00:31:37,539
head for for it so going back to the

691
00:31:35,590 --> 00:31:40,629
vulnerable function you can see the data

692
00:31:37,539 --> 00:31:42,759
that the function parses is coming from

693
00:31:40,629 --> 00:31:45,009
some data entry key so we needed to do

694
00:31:42,759 --> 00:31:47,049
some research and understand what is

695
00:31:45,009 --> 00:31:49,960
this data cue and where does this data

696
00:31:47,049 --> 00:31:53,320
come from so this data cue is basically

697
00:31:49,960 --> 00:31:55,419
four entries of packets that arrives

698
00:31:53,320 --> 00:31:57,519
from between the radio : the main core

699
00:31:55,419 --> 00:32:01,269
it is allocated in the shared RAM memory

700
00:31:57,519 --> 00:32:03,820
between those cores and it's linked

701
00:32:01,269 --> 00:32:06,580
together to form a cyclic list and also

702
00:32:03,820 --> 00:32:08,529
they are contiguous in memory so let's

703
00:32:06,580 --> 00:32:10,439
go over quickly how would the packet

704
00:32:08,529 --> 00:32:13,629
that is being received would look like

705
00:32:10,440 --> 00:32:15,729
so the pack the radio core and the main

706
00:32:13,629 --> 00:32:18,279
core starts off at the start of the this

707
00:32:15,729 --> 00:32:20,109
list the radio corrosives a packet from

708
00:32:18,279 --> 00:32:23,139
there so it needs to mark the entry as

709
00:32:20,109 --> 00:32:24,879
being used goes on and fills the data

710
00:32:23,139 --> 00:32:26,498
and then frees the entry so the main

711
00:32:24,879 --> 00:32:28,330
core can now start passing it

712
00:32:26,499 --> 00:32:30,340
while the main core is passing it the

713
00:32:28,330 --> 00:32:32,499
radio core had received another packet

714
00:32:30,340 --> 00:32:34,658
from the air and filled it up in the

715
00:32:32,499 --> 00:32:37,090
next entry so the main core can go on

716
00:32:34,659 --> 00:32:39,309
and parse it as well this happens in a

717
00:32:37,090 --> 00:32:41,259
cyclic motion meaning that when the

718
00:32:39,309 --> 00:32:43,359
radio call will hit the fourth entry it

719
00:32:41,259 --> 00:32:46,179
will go back to the first entry and so

720
00:32:43,359 --> 00:32:47,619
on and so forth ok so now that we

721
00:32:46,179 --> 00:32:50,830
understand where the data is coming from

722
00:32:47,619 --> 00:32:53,080
let's look at this scenario a normal

723
00:32:50,830 --> 00:32:54,639
advertising packet had arrived and then

724
00:32:53,080 --> 00:32:56,799
the vulnerable function had copied it

725
00:32:54,639 --> 00:32:59,109
onto the advertising packet global

726
00:32:56,799 --> 00:33:01,840
variable okay so far so good another

727
00:32:59,109 --> 00:33:04,418
normal advertising packet had come same

728
00:33:01,840 --> 00:33:06,220
here but now a triggering packet had

729
00:33:04,419 --> 00:33:07,840
arrived meaning that we have turned on

730
00:33:06,220 --> 00:33:10,269
one or two of there are a few bits

731
00:33:07,840 --> 00:33:12,340
inside those packet but it's in the

732
00:33:10,269 --> 00:33:15,309
legitimate length and now one out of

733
00:33:12,340 --> 00:33:17,408
bands copy will be initiated inside this

734
00:33:15,309 --> 00:33:20,200
function and we can see that the data

735
00:33:17,409 --> 00:33:22,419
that resides inside entry number three

736
00:33:20,200 --> 00:33:24,249
will be copied onto the I call pointers

737
00:33:22,419 --> 00:33:26,710
that you would like to control okay so

738
00:33:24,249 --> 00:33:28,659
this gives us a little bit of hint of

739
00:33:26,710 --> 00:33:31,419
where will the data that we want to

740
00:33:28,659 --> 00:33:33,669
control will be held if this happens in

741
00:33:31,419 --> 00:33:36,279
the second entry then the fourth entry

742
00:33:33,669 --> 00:33:38,500
will will be copied onto the icon

743
00:33:36,279 --> 00:33:39,970
pointers but what happens if it will

744
00:33:38,500 --> 00:33:43,210
trigger from the third of the fourth

745
00:33:39,970 --> 00:33:45,010
entry we copy that of one after the data

746
00:33:43,210 --> 00:33:47,260
entry queue which we cannot hope to

747
00:33:45,010 --> 00:33:51,399
control and this puts this form of

748
00:33:47,260 --> 00:33:52,779
expectation at 50% success rate so now

749
00:33:51,399 --> 00:33:54,729
that we understand that we would like to

750
00:33:52,779 --> 00:33:56,919
control data entries that are not the

751
00:33:54,730 --> 00:33:59,980
triggering one we need obviously to

752
00:33:56,919 --> 00:34:01,899
spray this data entry queue so I'm gonna

753
00:33:59,980 --> 00:34:03,909
go back a little bit about how Billy

754
00:34:01,899 --> 00:34:06,158
does is advertising

755
00:34:03,909 --> 00:34:08,609
basically there are three advertising

756
00:34:06,159 --> 00:34:11,050
channels or frequencies which

757
00:34:08,609 --> 00:34:12,699
advertising packets are sent on and the

758
00:34:11,050 --> 00:34:14,679
radio car is gonna hop between them

759
00:34:12,699 --> 00:34:17,199
looking for advertising packets so

760
00:34:14,679 --> 00:34:18,790
basically if you want or the radio call

761
00:34:17,199 --> 00:34:20,080
to receive a spray packet every time

762
00:34:18,790 --> 00:34:22,810
we're going to need to be on all three

763
00:34:20,080 --> 00:34:25,839
channels also the radio the main core

764
00:34:22,810 --> 00:34:27,909
the radio call head has a packet

765
00:34:25,839 --> 00:34:29,949
duplication mechanism that helps it

766
00:34:27,909 --> 00:34:31,810
prevent seeing duplicated packets and

767
00:34:29,949 --> 00:34:33,848
basically it validates that it hasn't

768
00:34:31,810 --> 00:34:35,799
seen this packet from the same sender

769
00:34:33,849 --> 00:34:37,480
from the same MAC address so basically

770
00:34:35,800 --> 00:34:39,399
we're just going to randomize every MAC

771
00:34:37,480 --> 00:34:42,399
address of the packet and then we will

772
00:34:39,399 --> 00:34:43,929
easily circumvent this mechanism so now

773
00:34:42,399 --> 00:34:46,659
that we understand how we're gonna spray

774
00:34:43,929 --> 00:34:49,418
we're basically just gonna spray packets

775
00:34:46,659 --> 00:34:50,950
that hold out desired I call values that

776
00:34:49,418 --> 00:34:53,049
we would like to put on the I call

777
00:34:50,949 --> 00:34:54,399
pointers and then after some time we're

778
00:34:53,050 --> 00:34:56,560
going to trigger the overflow and do it

779
00:34:54,399 --> 00:34:59,618
again and again hoping to fall into the

780
00:34:56,560 --> 00:35:02,650
right place inside scanning process so

781
00:34:59,619 --> 00:35:05,290
our strategy is as follows will trigger

782
00:35:02,650 --> 00:35:07,420
the packet the open flow from one entry

783
00:35:05,290 --> 00:35:09,759
while copying on to the icon pointers

784
00:35:07,420 --> 00:35:11,530
and now we need to put meaningful values

785
00:35:09,760 --> 00:35:13,510
inside those I call pointers so we could

786
00:35:11,530 --> 00:35:15,310
execute code so it's been mentioned we

787
00:35:13,510 --> 00:35:17,320
have no def here meaning we can execute

788
00:35:15,310 --> 00:35:19,330
data and we know exactly where our

789
00:35:17,320 --> 00:35:22,150
overflow packet will be held because

790
00:35:19,330 --> 00:35:24,670
it's in advertising packet so let's put

791
00:35:22,150 --> 00:35:26,260
this address inside I'll call dispatcher

792
00:35:24,670 --> 00:35:26,740
and then when the next sis call is

793
00:35:26,260 --> 00:35:28,450
called

794
00:35:26,740 --> 00:35:30,669
we'll just jump on to our packet and

795
00:35:28,450 --> 00:35:33,640
execute our packet sounds simple enough

796
00:35:30,670 --> 00:35:34,750
but we have a lot of limitations on this

797
00:35:33,640 --> 00:35:38,109
exploitation

798
00:35:34,750 --> 00:35:39,630
first every advertising packet holds 37

799
00:35:38,109 --> 00:35:42,360
bytes maximum of that

800
00:35:39,630 --> 00:35:44,250
so we control the trigger packet and we

801
00:35:42,360 --> 00:35:46,530
control the spray packet but spray

802
00:35:44,250 --> 00:35:50,060
packet has three I call pointers values

803
00:35:46,530 --> 00:35:53,310
it needs to whole so we are left with 62

804
00:35:50,060 --> 00:35:55,470
shellcode bytes that we can use in our

805
00:35:53,310 --> 00:35:58,080
exploitation this is not a lot of bytes

806
00:35:55,470 --> 00:35:59,879
to maneuver within but let's talk about

807
00:35:58,080 --> 00:36:02,490
the task at hand that we're gonna need

808
00:35:59,880 --> 00:36:04,230
to do inside those 62 bytes we're gonna

809
00:36:02,490 --> 00:36:05,819
prevent future over fuel crashes I'm

810
00:36:04,230 --> 00:36:07,560
going to talk about it in a bit we're

811
00:36:05,820 --> 00:36:09,210
going to install some sort of backdoor

812
00:36:07,560 --> 00:36:11,340
because we want to keep communicating

813
00:36:09,210 --> 00:36:12,810
with the chip and controlling it and

814
00:36:11,340 --> 00:36:15,540
we're gonna need to restore the chip

815
00:36:12,810 --> 00:36:18,660
state because we are running from a sis

816
00:36:15,540 --> 00:36:21,150
call that runs a packet which the system

817
00:36:18,660 --> 00:36:22,529
things were kind of in a weird state and

818
00:36:21,150 --> 00:36:24,240
we're going to need to restore its

819
00:36:22,530 --> 00:36:26,850
original state so it will keep scanning

820
00:36:24,240 --> 00:36:28,979
as usual and we have corrupted a lot of

821
00:36:26,850 --> 00:36:32,549
that on our way to the I call point is

822
00:36:28,980 --> 00:36:36,030
basically a 109 bytes of corrupted data

823
00:36:32,550 --> 00:36:37,800
that was written by our overflow until

824
00:36:36,030 --> 00:36:40,230
we hit the I call pointers without

825
00:36:37,800 --> 00:36:42,150
control values this is more bytes that

826
00:36:40,230 --> 00:36:44,190
we corrupt then we can actually control

827
00:36:42,150 --> 00:36:46,590
in this exploitation because we have

828
00:36:44,190 --> 00:36:48,720
only 62 shellcode bytes meaning that if

829
00:36:46,590 --> 00:36:51,000
we will bring all the data with us we

830
00:36:48,720 --> 00:36:53,040
basically have on a little bit more than

831
00:36:51,000 --> 00:36:54,450
half of the bytes that we need to

832
00:36:53,040 --> 00:36:56,880
restore so we're gonna need to find a

833
00:36:54,450 --> 00:36:58,740
solution for that and also we're gonna

834
00:36:56,880 --> 00:37:00,210
need to return some error value because

835
00:36:58,740 --> 00:37:02,279
we don't have enough bytes to actually

836
00:37:00,210 --> 00:37:04,500
do the system call that is expected of

837
00:37:02,280 --> 00:37:06,900
us because we are running from a 16 call

838
00:37:04,500 --> 00:37:09,150
back and then we're gonna need to patch

839
00:37:06,900 --> 00:37:10,680
the system call address back the I call

840
00:37:09,150 --> 00:37:14,130
dispatch it back to its original value

841
00:37:10,680 --> 00:37:15,480
so we want we want to be called every

842
00:37:14,130 --> 00:37:19,680
time a system call happened then the

843
00:37:15,480 --> 00:37:21,450
system can continue as usual so I looked

844
00:37:19,680 --> 00:37:23,310
at it at first I was like oh man it

845
00:37:21,450 --> 00:37:25,950
can't be done like logically we don't

846
00:37:23,310 --> 00:37:27,570
have enough bytes to do it and I

847
00:37:25,950 --> 00:37:29,460
remember talking with Ben about it and

848
00:37:27,570 --> 00:37:31,530
saying let's just not exploit this

849
00:37:29,460 --> 00:37:33,570
whenever it's it's too much but Ben told

850
00:37:31,530 --> 00:37:35,250
me let's take it part by part and so I

851
00:37:33,570 --> 00:37:38,910
will take you through part by part of

852
00:37:35,250 --> 00:37:40,650
our exploitation so the first problem is

853
00:37:38,910 --> 00:37:42,569
preventing future overflows what do I

854
00:37:40,650 --> 00:37:44,370
mean by that let's imagine a trigger

855
00:37:42,570 --> 00:37:46,050
packet had arrived in the entry number 2

856
00:37:44,370 --> 00:37:48,900
and we controlled with Osprey an entry

857
00:37:46,050 --> 00:37:50,520
number 4 now the overflow will be

858
00:37:48,900 --> 00:37:52,020
triggered our code will run and

859
00:37:50,520 --> 00:37:52,910
everything is good in the world but what

860
00:37:52,020 --> 00:37:54,410
happens if

861
00:37:52,910 --> 00:37:56,720
another triggered package just arrived

862
00:37:54,410 --> 00:38:00,440
in entry number three so after a shell

863
00:37:56,720 --> 00:38:03,080
code has gotten executed the main code

864
00:38:00,440 --> 00:38:04,640
will go on to pass the third entry and

865
00:38:03,080 --> 00:38:06,319
then copy uncontrolled data on the I

866
00:38:04,640 --> 00:38:08,839
call pointers and basically crush the

867
00:38:06,320 --> 00:38:11,840
chip if this is left on fixed we will

868
00:38:08,840 --> 00:38:13,940
eventually sometime crush the chip so

869
00:38:11,840 --> 00:38:17,030
this is bled obviously we need to find a

870
00:38:13,940 --> 00:38:19,280
way to fix it so let's assume our

871
00:38:17,030 --> 00:38:22,010
triggered packet was from the second

872
00:38:19,280 --> 00:38:24,530
entry and now we can we have executed

873
00:38:22,010 --> 00:38:27,110
code we do this nifty little trick where

874
00:38:24,530 --> 00:38:28,820
we link the same entry that triggered

875
00:38:27,110 --> 00:38:30,830
the vulnerability to itself effectively

876
00:38:28,820 --> 00:38:32,450
freezing other entries from being

877
00:38:30,830 --> 00:38:34,580
touched by the main core or the radio

878
00:38:32,450 --> 00:38:35,299
core because now they don't even know

879
00:38:34,580 --> 00:38:38,090
they exist

880
00:38:35,300 --> 00:38:39,920
and now when the when another packet

881
00:38:38,090 --> 00:38:42,290
will come the radio echo will fill the

882
00:38:39,920 --> 00:38:44,150
second entry but the Manco will have to

883
00:38:42,290 --> 00:38:46,850
wait until it finish because the entry

884
00:38:44,150 --> 00:38:48,770
the data entry queue is only one entry

885
00:38:46,850 --> 00:38:50,690
long so now when the main hall will pass

886
00:38:48,770 --> 00:38:53,150
it everything is good but now another

887
00:38:50,690 --> 00:38:54,650
trigger packet come no problem because

888
00:38:53,150 --> 00:38:56,870
we're in the same pool state that we

889
00:38:54,650 --> 00:38:59,060
used to and now the copy will be called

890
00:38:56,870 --> 00:39:01,520
again and we'll still won't crush the

891
00:38:59,060 --> 00:39:03,710
chip but execute code again meaning that

892
00:39:01,520 --> 00:39:06,230
when we first succeed we will succeed

893
00:39:03,710 --> 00:39:08,480
every time after doing this trick this

894
00:39:06,230 --> 00:39:11,390
trick costs us about three armed

895
00:39:08,480 --> 00:39:15,920
instructions that's not a lot and we are

896
00:39:11,390 --> 00:39:18,259
left with 56 shellcode bytes okay so now

897
00:39:15,920 --> 00:39:20,270
the hot pot we need to restore execution

898
00:39:18,260 --> 00:39:22,520
of the chip to its original state I

899
00:39:20,270 --> 00:39:24,590
don't have the time to go into

900
00:39:22,520 --> 00:39:26,780
everything but I'm just going to talk

901
00:39:24,590 --> 00:39:28,370
about after a lot of research we did we

902
00:39:26,780 --> 00:39:30,200
found that these variables must be

903
00:39:28,370 --> 00:39:33,380
restored for in order for the chip to be

904
00:39:30,200 --> 00:39:35,540
in its original state so we wrote some

905
00:39:33,380 --> 00:39:38,150
code that does exactly that but I

906
00:39:35,540 --> 00:39:41,330
haven't mentioned our overflow will

907
00:39:38,150 --> 00:39:43,850
corrupt some gap task related variables

908
00:39:41,330 --> 00:39:45,830
there that are 16 bytes long so now

909
00:39:43,850 --> 00:39:48,500
after restoring everything we need and

910
00:39:45,830 --> 00:39:50,870
we have 17 banks of shellcode left for

911
00:39:48,500 --> 00:39:53,900
us to do logic we need to restore

912
00:39:50,870 --> 00:39:56,240
sixteen bytes of data which means that

913
00:39:53,900 --> 00:39:58,850
even we can do it in zero instructions

914
00:39:56,240 --> 00:40:02,060
we'll still have one shellcode bytes for

915
00:39:58,850 --> 00:40:04,400
for our logic to do which basically is a

916
00:40:02,060 --> 00:40:06,740
half of our arm instruction so our

917
00:40:04,400 --> 00:40:09,650
expert just restores execution and does

918
00:40:06,740 --> 00:40:10,910
nothing this is obviously bad and we're

919
00:40:09,650 --> 00:40:13,940
gonna need to go back to the drawing

920
00:40:10,910 --> 00:40:17,629
board and take an eight-second look at

921
00:40:13,940 --> 00:40:19,730
this so we did some more research and

922
00:40:17,630 --> 00:40:22,640
found out that basically if we stop the

923
00:40:19,730 --> 00:40:25,280
gab desk from ever running again we can

924
00:40:22,640 --> 00:40:27,740
just restore those three variables put a

925
00:40:25,280 --> 00:40:30,050
null inside one of the gap test

926
00:40:27,740 --> 00:40:32,209
callbacks which make it would make it

927
00:40:30,050 --> 00:40:35,780
stop running and then we can just

928
00:40:32,210 --> 00:40:38,089
restore those three variables making it

929
00:40:35,780 --> 00:40:41,780
not that byte expensive for us to

930
00:40:38,089 --> 00:40:45,500
restore those those variables and we

931
00:40:41,780 --> 00:40:47,330
could now do we now have 32 shellcode

932
00:40:45,500 --> 00:40:49,160
bytes for us to maneuver within still

933
00:40:47,330 --> 00:40:51,950
not a lot but it's lists it's something

934
00:40:49,160 --> 00:40:53,839
so now that we have restored their

935
00:40:51,950 --> 00:40:56,089
execution we're gonna need to install

936
00:40:53,839 --> 00:40:58,160
some form of a backdoor because we have

937
00:40:56,089 --> 00:40:59,630
only 32 bytes of shellcode left we're

938
00:40:58,160 --> 00:41:02,598
gonna need a vector to be really really

939
00:40:59,630 --> 00:41:04,520
lightweight in size efficient and also

940
00:41:02,599 --> 00:41:06,880
we would like to put there somewhere it

941
00:41:04,520 --> 00:41:09,650
won't cost us a lot of time and

942
00:41:06,880 --> 00:41:12,560
instructions to install the hook for our

943
00:41:09,650 --> 00:41:15,050
backdoor so our backdoor that we come up

944
00:41:12,560 --> 00:41:18,380
with will be this bed oh it's only 8

945
00:41:15,050 --> 00:41:20,480
bytes long it will it will sit our

946
00:41:18,380 --> 00:41:22,790
shellcode will read rewrite it just

947
00:41:20,480 --> 00:41:24,530
above the advertising packet by global

948
00:41:22,790 --> 00:41:27,440
variable what it does is basically

949
00:41:24,530 --> 00:41:30,140
checks if the first four bytes of the

950
00:41:27,440 --> 00:41:31,910
packet that is been received is a magic

951
00:41:30,140 --> 00:41:33,650
value in this case PC but because

952
00:41:31,910 --> 00:41:36,200
everything is static we can predict PC

953
00:41:33,650 --> 00:41:38,000
every time and if it's the magic value

954
00:41:36,200 --> 00:41:41,899
it will jump over it and just execute

955
00:41:38,000 --> 00:41:44,180
our packet that's great and we need some

956
00:41:41,900 --> 00:41:46,430
we need now we need some runtime for our

957
00:41:44,180 --> 00:41:48,649
back though so remember we control the I

958
00:41:46,430 --> 00:41:51,348
call pointers so why not use the other

959
00:41:48,650 --> 00:41:52,820
two we'll use the entry critical section

960
00:41:51,349 --> 00:41:55,010
to execute our back door it is called

961
00:41:52,820 --> 00:41:56,510
many times during one packet parsing

962
00:41:55,010 --> 00:41:58,609
making sure our vector will be called

963
00:41:56,510 --> 00:42:00,500
every time a new packet has arrived and

964
00:41:58,609 --> 00:42:02,420
we'll use the exit critical section

965
00:42:00,500 --> 00:42:04,700
basically because we don't have enough

966
00:42:02,420 --> 00:42:06,260
bytes in the end row and in our back

967
00:42:04,700 --> 00:42:08,240
door to do the actual enter critical

968
00:42:06,260 --> 00:42:09,920
section we'll just put a gadget that

969
00:42:08,240 --> 00:42:11,209
does nothing inside the exit critical

970
00:42:09,920 --> 00:42:14,690
section and render this mechanism

971
00:42:11,210 --> 00:42:17,119
useless but still we get some execution

972
00:42:14,690 --> 00:42:20,450
time for back though so let's recap all

973
00:42:17,119 --> 00:42:23,089
of our back door first we set up some

974
00:42:20,450 --> 00:42:24,618
environment they're reading some

975
00:42:23,089 --> 00:42:26,540
variables into registers then we're

976
00:42:24,619 --> 00:42:27,980
going to stop the gap test from running

977
00:42:26,540 --> 00:42:29,779
we're going to install our back though

978
00:42:27,980 --> 00:42:31,359
this is to store instructions because

979
00:42:29,780 --> 00:42:34,220
our back door is only eight bytes long

980
00:42:31,359 --> 00:42:36,410
then we're going to link the data entry

981
00:42:34,220 --> 00:42:38,270
that has triggered the vulnerability to

982
00:42:36,410 --> 00:42:40,060
itself using other entries in making

983
00:42:38,270 --> 00:42:42,020
sure we won't crash in the next figure

984
00:42:40,060 --> 00:42:43,880
then we're going to restore our

985
00:42:42,020 --> 00:42:45,619
corrupted values as I mentioned we need

986
00:42:43,880 --> 00:42:47,570
to restore only two variables the time I

987
00:42:45,619 --> 00:42:49,579
had in the Bailey dispatch task ID and

988
00:42:47,570 --> 00:42:52,160
then we're gonna unhook ourselves from

989
00:42:49,579 --> 00:42:54,440
the Cisco and then Gateway because we

990
00:42:52,160 --> 00:42:56,810
want we don't want to run again and

991
00:42:54,440 --> 00:43:00,079
that's it basically we have exploited

992
00:42:56,810 --> 00:43:02,029
the CC 2640 we don't need 32 bytes of

993
00:43:00,079 --> 00:43:04,490
shellcode that we had in our disposal

994
00:43:02,030 --> 00:43:06,560
and now I'm gonna press the stage two

995
00:43:04,490 --> 00:43:17,750
bandits gonna talk about the demo thank

996
00:43:06,560 --> 00:43:20,000
you so as you as you saw it was quite

997
00:43:17,750 --> 00:43:24,740
challenging to achieve execution through

998
00:43:20,000 --> 00:43:29,569
this small bug but but eventually we did

999
00:43:24,740 --> 00:43:33,399
it I don't show a small a short video on

1000
00:43:29,569 --> 00:43:34,730
how this is exploited so you have again

1001
00:43:33,400 --> 00:43:38,540
the hacker

1002
00:43:34,730 --> 00:43:41,480
it controls raspberry pi that connect it

1003
00:43:38,540 --> 00:43:44,150
to a new belief that device can be used

1004
00:43:41,480 --> 00:43:47,030
to send MIDI packets custom packets and

1005
00:43:44,150 --> 00:43:49,130
this attacks this gratis point on the

1006
00:43:47,030 --> 00:43:51,589
right we can see the attacker is

1007
00:43:49,130 --> 00:43:54,020
scanning for ble beacons when the attack

1008
00:43:51,589 --> 00:43:57,980
is finished we will see the targeted

1009
00:43:54,020 --> 00:44:01,069
device beginning a specific message a

1010
00:43:57,980 --> 00:44:02,960
specific so on the Left we can see the

1011
00:44:01,069 --> 00:44:04,550
attack going on we send the spray

1012
00:44:02,960 --> 00:44:06,859
packets we send the trigger overflow and

1013
00:44:04,550 --> 00:44:11,240
now once we have a backdoor we upload

1014
00:44:06,859 --> 00:44:14,450
our specific beacon data onto the device

1015
00:44:11,240 --> 00:44:16,569
using that regular backdoor and we tell

1016
00:44:14,450 --> 00:44:19,009
the chip to start advertising this

1017
00:44:16,569 --> 00:44:23,270
malicious weekend and you can see on the

1018
00:44:19,010 --> 00:44:26,990
right the AP is saying it has been owned

1019
00:44:23,270 --> 00:44:31,880
and an indication of compromise from

1020
00:44:26,990 --> 00:44:34,308
familiar just from the VDP hands so in

1021
00:44:31,880 --> 00:44:35,270
that state any device nearby that scans

1022
00:44:34,309 --> 00:44:38,990
from Billy weekend's

1023
00:44:35,270 --> 00:44:43,069
like my smartphone we will show that in

1024
00:44:38,990 --> 00:45:01,220
fact the beacon is saying you're a piece

1025
00:44:43,069 --> 00:45:06,259
we don't to us okay so yes we really at

1026
00:45:01,220 --> 00:45:08,839
the end I just want to tip to talk about

1027
00:45:06,260 --> 00:45:12,700
three takeaways I think should be taken

1028
00:45:08,839 --> 00:45:16,339
from this research first the fact that

1029
00:45:12,700 --> 00:45:17,990
Billy chips radio chips that are

1030
00:45:16,339 --> 00:45:20,000
sometimes considered peripheral chips

1031
00:45:17,990 --> 00:45:22,848
can also be vulnerable to attack right

1032
00:45:20,000 --> 00:45:26,450
they have CPUs they run code they can be

1033
00:45:22,849 --> 00:45:28,339
vulnerable if they are vulnerable this

1034
00:45:26,450 --> 00:45:30,169
can lead to something greater this can

1035
00:45:28,339 --> 00:45:32,270
lead in an access point environment for

1036
00:45:30,170 --> 00:45:33,829
example to a network breach so you can

1037
00:45:32,270 --> 00:45:36,829
start for something very small like a

1038
00:45:33,829 --> 00:45:39,650
billy chip but this can go on and then

1039
00:45:36,829 --> 00:45:42,140
targeting an entire network code and

1040
00:45:39,650 --> 00:45:43,520
third the fact is that access points in

1041
00:45:42,140 --> 00:45:46,250
network infrastructure devices in

1042
00:45:43,520 --> 00:45:49,940
general or practically also unmanaged

1043
00:45:46,250 --> 00:45:51,920
devices the Billy chip inside the access

1044
00:45:49,940 --> 00:45:53,839
point is not managed right the access

1045
00:45:51,920 --> 00:45:55,460
point itself is just a device that

1046
00:45:53,839 --> 00:45:57,619
service Wi-Fi it doesn't have an agent

1047
00:45:55,460 --> 00:46:01,520
on it it doesn't have too many too much

1048
00:45:57,619 --> 00:46:03,589
inherent security so in the global like

1049
00:46:01,520 --> 00:46:04,390
you zooming out from the bits that we

1050
00:46:03,589 --> 00:46:07,819
talked about

1051
00:46:04,390 --> 00:46:09,740
it is a general picture and obviously

1052
00:46:07,819 --> 00:46:13,910
this is a slang step that should be

1053
00:46:09,740 --> 00:46:15,859
looked at we have a white paper that we

1054
00:46:13,910 --> 00:46:18,859
tell is all of what we talked about in

1055
00:46:15,859 --> 00:46:20,420
detail on our website and all the

1056
00:46:18,859 --> 00:46:21,680
affected devices and one of it is

1057
00:46:20,420 --> 00:46:23,299
obviously we did it

1058
00:46:21,680 --> 00:46:25,129
security disclosure process which I

1059
00:46:23,299 --> 00:46:28,190
haven't talked about but it's also

1060
00:46:25,130 --> 00:46:29,720
detailed in this website and I think we

1061
00:46:28,190 --> 00:46:32,829
have like three minutes for questions if

1062
00:46:29,720 --> 00:46:32,828
anybody want to ask

1063
00:46:36,810 --> 00:46:42,660
maybe we were really really clear that's

1064
00:46:39,610 --> 00:46:42,660
a good sign right

1065
00:46:46,240 --> 00:46:51,959
thank you very much

1066
00:46:48,780 --> 00:46:51,959
[Applause]

