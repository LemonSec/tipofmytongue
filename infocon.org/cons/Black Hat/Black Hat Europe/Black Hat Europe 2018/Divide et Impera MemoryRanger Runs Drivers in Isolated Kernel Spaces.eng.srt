1
00:00:00,000 --> 00:00:07,470
hi I'm eager today I like to show to

2
00:00:04,230 --> 00:00:10,830
present you my memory Ranger which can

3
00:00:07,470 --> 00:00:13,739
isolate drivers code and allocated data

4
00:00:10,830 --> 00:00:16,590
from illegal access in the kernel mode

5
00:00:13,740 --> 00:00:19,439
memory this topic is of critical

6
00:00:16,590 --> 00:00:21,660
importance for all security experts who

7
00:00:19,439 --> 00:00:25,230
are dealing with protection of operating

8
00:00:21,660 --> 00:00:30,179
systems a few words about me

9
00:00:25,230 --> 00:00:31,980
I earned my PhD seven years ago my area

10
00:00:30,179 --> 00:00:34,649
of expertise includes Windows kernel

11
00:00:31,980 --> 00:00:37,590
security I am a fan of Windows current

12
00:00:34,649 --> 00:00:40,500
security rootkit detection and hyper

13
00:00:37,590 --> 00:00:45,180
biases I carried out security research

14
00:00:40,500 --> 00:00:47,100
projects by my own as a hobby I'm a fan

15
00:00:45,180 --> 00:00:50,700
of cross-disciplinary research you can

16
00:00:47,100 --> 00:00:52,579
find my results in my blog here by the

17
00:00:50,700 --> 00:00:56,670
way I'm fond of traveling and

18
00:00:52,579 --> 00:01:00,480
powerlifting as well I have divided my

19
00:00:56,670 --> 00:01:02,190
talk into three main parts firstly we'll

20
00:01:00,480 --> 00:01:05,970
be looking at the consequences of

21
00:01:02,190 --> 00:01:08,490
attacks on kernel memory after that I'll

22
00:01:05,970 --> 00:01:11,280
give you a brief analysis of Windows

23
00:01:08,490 --> 00:01:13,289
built-in security features and research

24
00:01:11,280 --> 00:01:17,220
projects which are designed to protect

25
00:01:13,290 --> 00:01:20,400
kernel memory finally I'll show you how

26
00:01:17,220 --> 00:01:24,600
I solve this problem using my memory

27
00:01:20,400 --> 00:01:29,970
ranger feel free to ask me any questions

28
00:01:24,600 --> 00:01:33,298
at the end of the talk nowadays kernel

29
00:01:29,970 --> 00:01:36,240
mode drivers share the same memory space

30
00:01:33,299 --> 00:01:39,240
with the rest of the OS kernel all

31
00:01:36,240 --> 00:01:42,329
drivers can read and write any part of

32
00:01:39,240 --> 00:01:46,048
kernel mode memory without any hardware

33
00:01:42,329 --> 00:01:48,570
restrictions this fact makes the modern

34
00:01:46,049 --> 00:01:54,149
operating systems to be proved - rootkit

35
00:01:48,570 --> 00:01:57,270
attacks and kernel exploitation let's

36
00:01:54,149 --> 00:01:59,790
have a look malware driver can dump the

37
00:01:57,270 --> 00:02:03,000
drivers code and tamper allocated memory

38
00:01:59,790 --> 00:02:05,369
for example Windows internal structures

39
00:02:03,000 --> 00:02:09,330
and allocated data or the third-party

40
00:02:05,369 --> 00:02:13,300
drivers as a result hackers can escalate

41
00:02:09,330 --> 00:02:16,150
privileges hide their footprints still

42
00:02:13,300 --> 00:02:17,740
secrets or even disrupt industrial

43
00:02:16,150 --> 00:02:21,670
processes which are controlled by

44
00:02:17,740 --> 00:02:29,640
drivers nowadays so let me demonstrate

45
00:02:21,670 --> 00:02:32,980
you some of these attacks let's imagine

46
00:02:29,640 --> 00:02:36,100
just let's imagine two houses with

47
00:02:32,980 --> 00:02:38,980
private art collections Russian house

48
00:02:36,100 --> 00:02:41,560
and the British one the Russian house in

49
00:02:38,980 --> 00:02:45,399
Russian house we can see the painting of

50
00:02:41,560 --> 00:02:47,950
my silicon dean scheme you know he was a

51
00:02:45,400 --> 00:02:50,380
great Russian painter as the banks his

52
00:02:47,950 --> 00:02:52,329
art is in the British house I hope

53
00:02:50,380 --> 00:02:54,690
everyone is familiar with banks his

54
00:02:52,330 --> 00:02:58,270
painting and the recent scandal with

55
00:02:54,690 --> 00:03:02,590
shredding his painting in London this is

56
00:02:58,270 --> 00:03:05,640
the painting yeah and here is the heck

57
00:03:02,590 --> 00:03:09,100
attacker who wants to grab all these

58
00:03:05,640 --> 00:03:12,160
masterpiece use these houses are not

59
00:03:09,100 --> 00:03:15,220
protected the both private collections

60
00:03:12,160 --> 00:03:20,620
will be stolen in the kernel mode memory

61
00:03:15,220 --> 00:03:23,080
this situation is absolutely the same if

62
00:03:20,620 --> 00:03:26,400
drivers are not protected the data can

63
00:03:23,080 --> 00:03:29,470
be stolen let's see how it can happen I

64
00:03:26,400 --> 00:03:32,050
will load two drivers the Russian driver

65
00:03:29,470 --> 00:03:35,470
and the British one which store the data

66
00:03:32,050 --> 00:03:37,989
in the allocated memory pools after that

67
00:03:35,470 --> 00:03:40,390
the attackers driver will be loaded to

68
00:03:37,989 --> 00:03:42,820
dump the Russian the drivers code and

69
00:03:40,390 --> 00:03:46,570
still both Russian and British data

70
00:03:42,820 --> 00:03:49,359
buffers and finally I will show how the

71
00:03:46,570 --> 00:03:55,079
attacker can even escalate process

72
00:03:49,360 --> 00:03:55,080
privileges let's see how it can happen

73
00:04:03,870 --> 00:04:13,349
[Music]

74
00:04:10,430 --> 00:04:16,079
I'm launching a Russian console which

75
00:04:13,349 --> 00:04:18,930
laws a Russian driver in the same way

76
00:04:16,079 --> 00:04:21,209
I'm loading the British driver finally

77
00:04:18,930 --> 00:04:24,990
the heck attack is launching his driver

78
00:04:21,209 --> 00:04:26,729
to access kernel memory now the attack

79
00:04:24,990 --> 00:04:31,080
is trying to dump the Russian driver

80
00:04:26,729 --> 00:04:34,680
using it's loaded address the attacker

81
00:04:31,080 --> 00:04:38,490
is copies copying this address and we

82
00:04:34,680 --> 00:04:41,120
can see the attacker is successful

83
00:04:38,490 --> 00:04:46,320
reading the first byte which is M and

84
00:04:41,120 --> 00:04:49,560
the second byte which is Z this is

85
00:04:46,320 --> 00:04:56,430
typical P a file header what was the

86
00:04:49,560 --> 00:04:58,830
British driver the attacker has

87
00:04:56,430 --> 00:05:05,130
successfully dumped first two bytes as

88
00:04:58,830 --> 00:05:08,789
well we can see that the code of both

89
00:05:05,130 --> 00:05:10,919
drivers can be stolen now let's move on

90
00:05:08,789 --> 00:05:15,630
to the private data which can be stored

91
00:05:10,919 --> 00:05:18,150
in the allocated memory the Russian

92
00:05:15,630 --> 00:05:22,080
driver is allocating data and setting it

93
00:05:18,150 --> 00:05:27,049
content as Vasily Kandinsky lecture can

94
00:05:22,080 --> 00:05:30,690
gain skin we copy this address and

95
00:05:27,050 --> 00:05:35,070
reading this data the data has been

96
00:05:30,690 --> 00:05:38,849
allocated the British driver is

97
00:05:35,070 --> 00:05:47,150
allocating memory and setting banks as

98
00:05:38,849 --> 00:05:47,150
its content now let's check banks in

99
00:05:50,690 --> 00:05:59,370
it's alright the data has been allocated

100
00:05:56,700 --> 00:06:02,639
now the attacker wants to steal this

101
00:05:59,370 --> 00:06:04,830
priceless data content to steal

102
00:06:02,639 --> 00:06:07,770
Kandinsky hackers need to know the

103
00:06:04,830 --> 00:06:11,039
corresponding memory address let's

104
00:06:07,770 --> 00:06:18,080
assume they do know this address because

105
00:06:11,040 --> 00:06:23,100
usually hackers do know everything so

106
00:06:18,080 --> 00:06:25,620
the attacker can read this data let's

107
00:06:23,100 --> 00:06:27,960
have a look yeah the Kandinsky has been

108
00:06:25,620 --> 00:06:31,530
stolen okay

109
00:06:27,960 --> 00:06:36,739
and now the attacker is overwriting

110
00:06:31,530 --> 00:06:40,080
Kandinsky using for example four ones

111
00:06:36,740 --> 00:06:44,370
okay let's go back to the Russian driver

112
00:06:40,080 --> 00:06:45,870
and check the content we can see and the

113
00:06:44,370 --> 00:06:48,690
attacker can read this data and

114
00:06:45,870 --> 00:06:53,250
overwrite it we have only four ones

115
00:06:48,690 --> 00:06:57,360
instead we can see that the attacker did

116
00:06:53,250 --> 00:06:59,940
modify the data now the attacker is

117
00:06:57,360 --> 00:07:05,750
entering the British house to steal

118
00:06:59,940 --> 00:07:05,750
bankses art he copies this address and

119
00:07:07,669 --> 00:07:15,030
we can see that a Banksy has been stolen

120
00:07:10,320 --> 00:07:19,670
and after all the writing we use photos

121
00:07:15,030 --> 00:07:21,380
and let's check the original collection

122
00:07:19,670 --> 00:07:26,550
[Music]

123
00:07:21,380 --> 00:07:29,039
the collection has been disappeared and

124
00:07:26,550 --> 00:07:33,570
both data buffers were stolen and

125
00:07:29,039 --> 00:07:40,969
modified okay now let's go back to our

126
00:07:33,570 --> 00:07:40,969
slides and close the video

127
00:07:49,150 --> 00:07:55,520
hack attacker has successfully stolen

128
00:07:52,250 --> 00:07:57,740
both private collections it means that

129
00:07:55,520 --> 00:08:00,948
our houses were not protected in a

130
00:07:57,740 --> 00:08:04,099
proper way what was wrong how can we

131
00:08:00,949 --> 00:08:04,550
prevent this attack how can we defend

132
00:08:04,099 --> 00:08:07,878
them

133
00:08:04,550 --> 00:08:10,460
we will see it later and now let's go

134
00:08:07,879 --> 00:08:28,310
back to demo to see how the attacker can

135
00:08:10,460 --> 00:08:31,729
even escalate bruises privileges now the

136
00:08:28,310 --> 00:08:34,250
attack is starting the CMD console after

137
00:08:31,729 --> 00:08:37,520
launching it he's getting its process ID

138
00:08:34,250 --> 00:08:41,360
using this string here is VP ad he's

139
00:08:37,520 --> 00:08:45,350
hoping it's PID we can see that CMD has

140
00:08:41,360 --> 00:08:47,690
uses privileges and it is not enough for

141
00:08:45,350 --> 00:08:53,270
example to reconfigure the Windows

142
00:08:47,690 --> 00:08:56,209
Firewall let's have a look yes access is

143
00:08:53,270 --> 00:08:59,029
denied which is expected now the

144
00:08:56,209 --> 00:09:01,609
attacker is trying to elevate the same D

145
00:08:59,029 --> 00:09:04,279
privileges he's using proof command with

146
00:09:01,610 --> 00:09:07,880
process ID let's go back and check the

147
00:09:04,279 --> 00:09:11,990
police again we can see that the

148
00:09:07,880 --> 00:09:14,870
privileges have been escalated now the

149
00:09:11,990 --> 00:09:17,750
simba has the highest privileges and now

150
00:09:14,870 --> 00:09:21,740
CMD can reconfigure windows firewall

151
00:09:17,750 --> 00:09:34,820
service and even can turn it off let's

152
00:09:21,740 --> 00:09:37,190
have a look well we have we can see only

153
00:09:34,820 --> 00:09:39,680
a small message which confirms that the

154
00:09:37,190 --> 00:09:42,320
windows firewall is out of service and

155
00:09:39,680 --> 00:09:46,819
it cannot be automatically restarted

156
00:09:42,320 --> 00:09:49,490
this is very good news for hackers but

157
00:09:46,820 --> 00:09:51,950
let's wait for particle reaction which

158
00:09:49,490 --> 00:09:57,140
is designed to prevent illegal memory

159
00:09:51,950 --> 00:10:01,540
modifications we've been waiting for as

160
00:09:57,140 --> 00:10:06,999
long as 10 hours it is quite a long time

161
00:10:01,540 --> 00:10:06,998
and let's have a look what will happen

162
00:10:07,329 --> 00:10:16,309
and we can see that nothing has happened

163
00:10:12,639 --> 00:10:19,009
the West hasn't been crushed it means

164
00:10:16,309 --> 00:10:28,689
that posh God didn't prevent this

165
00:10:19,009 --> 00:10:28,689
invasion and the u.s. became an affected

166
00:10:33,129 --> 00:10:39,589
so we can see that Windows kernel can

167
00:10:36,679 --> 00:10:42,800
not prevent illegal memory access the

168
00:10:39,589 --> 00:10:45,050
attacker can read the drivers code still

169
00:10:42,800 --> 00:10:48,349
and change allocated data and even

170
00:10:45,050 --> 00:10:50,779
escalate process privileges without any

171
00:10:48,350 --> 00:10:54,619
security reaction such as a blue screen

172
00:10:50,779 --> 00:10:57,110
of death let's have a look at the

173
00:10:54,619 --> 00:11:00,490
current situation with memory protection

174
00:10:57,110 --> 00:11:02,990
projects look at this table

175
00:11:00,490 --> 00:11:05,269
Microsoft has developed a number of

176
00:11:02,990 --> 00:11:08,269
security features for memory protection

177
00:11:05,269 --> 00:11:10,369
the third one is device guard which

178
00:11:08,269 --> 00:11:14,240
provides kernel code integrity by

179
00:11:10,369 --> 00:11:17,179
marking executable pages as read-only so

180
00:11:14,240 --> 00:11:20,899
any modifications of the code will crush

181
00:11:17,179 --> 00:11:23,720
the system not that and the second one

182
00:11:20,899 --> 00:11:26,809
is patch guard which crushes their ways

183
00:11:23,720 --> 00:11:28,970
after revealing some changes of internal

184
00:11:26,809 --> 00:11:31,459
structures for example in process

185
00:11:28,970 --> 00:11:33,860
unlinking but you just sing that part

186
00:11:31,459 --> 00:11:37,069
guard doesn't protect approach

187
00:11:33,860 --> 00:11:39,110
structures completely finally window

188
00:11:37,069 --> 00:11:41,979
security does not protect memory

189
00:11:39,110 --> 00:11:45,619
allocated by the third-party drivers

190
00:11:41,980 --> 00:11:48,589
also many security experts from all

191
00:11:45,619 --> 00:11:51,259
around the world are trying to fill this

192
00:11:48,589 --> 00:11:53,420
gap there are several research projects

193
00:11:51,259 --> 00:11:56,749
which are designed for memory protection

194
00:11:53,420 --> 00:12:01,790
and you can see that there is no general

195
00:11:56,749 --> 00:12:04,069
solution no general solution which can

196
00:12:01,790 --> 00:12:07,490
deal with all these issues at the same

197
00:12:04,069 --> 00:12:10,759
time today I will propose the solution I

198
00:12:07,490 --> 00:12:12,850
will present you my memory ranger which

199
00:12:10,759 --> 00:12:15,139
can provide which provides both

200
00:12:12,850 --> 00:12:20,269
integrity and confidentiality

201
00:12:15,139 --> 00:12:23,899
for drivers and allocated data look at

202
00:12:20,269 --> 00:12:26,869
this nowadays kernel-mode drivers share

203
00:12:23,899 --> 00:12:31,939
the same memory space with the rest of

204
00:12:26,869 --> 00:12:35,029
the OS kernel if we can move these two

205
00:12:31,939 --> 00:12:38,569
drivers with their allocations into two

206
00:12:35,029 --> 00:12:41,660
separate memory enclosures we'll protect

207
00:12:38,569 --> 00:12:44,809
the memory from each other the thing is

208
00:12:41,660 --> 00:12:49,519
that windows OS doesn't give us such an

209
00:12:44,809 --> 00:12:52,069
eternity so luckily for us had the

210
00:12:49,519 --> 00:12:54,079
virtualization technology provides the

211
00:12:52,069 --> 00:12:57,229
mechanism which can be used to implement

212
00:12:54,079 --> 00:13:00,858
the idea of memory isolation

213
00:12:57,230 --> 00:13:04,970
I mean extended page tables or EPT

214
00:13:00,859 --> 00:13:07,339
feature without EPT guest physical

215
00:13:04,970 --> 00:13:11,059
addresses are used to access hosts

216
00:13:07,339 --> 00:13:16,970
physical memory here address H is equal

217
00:13:11,059 --> 00:13:19,939
to address G using EPT we get an

218
00:13:16,970 --> 00:13:23,360
additional or second level of address

219
00:13:19,939 --> 00:13:25,639
translation when EPT is enabled guest

220
00:13:23,360 --> 00:13:28,160
physical addresses are translated to

221
00:13:25,639 --> 00:13:34,129
host physical addresses by traversing a

222
00:13:28,160 --> 00:13:37,850
set of EPT paging sriracha's we can see

223
00:13:34,129 --> 00:13:41,629
that now address h is equal to the

224
00:13:37,850 --> 00:13:47,329
address it not to G let's have a look at

225
00:13:41,629 --> 00:13:49,610
apt details EPT structures includes EPT

226
00:13:47,329 --> 00:13:51,799
entries which determined the mapping

227
00:13:49,610 --> 00:13:55,610
between the guest memory and the host

228
00:13:51,799 --> 00:14:01,449
memory each EPT entry includes memory

229
00:13:55,610 --> 00:14:04,459
access bits and page frame number or pfm

230
00:14:01,449 --> 00:14:07,160
so this number is linked to the

231
00:14:04,459 --> 00:14:09,349
corresponding host physical address it

232
00:14:07,160 --> 00:14:13,549
can be used to prevent access to a

233
00:14:09,350 --> 00:14:15,619
protected date we can redirect the

234
00:14:13,549 --> 00:14:19,699
access from the protected data to the

235
00:14:15,619 --> 00:14:23,470
fake one by changing PFN value to the

236
00:14:19,699 --> 00:14:27,559
address of fake page another thing is

237
00:14:23,470 --> 00:14:28,899
memory access bits they indicate where

238
00:14:27,559 --> 00:14:31,589
the access attempts

239
00:14:28,899 --> 00:14:34,629
loud the page reference by this number

240
00:14:31,589 --> 00:14:37,839
any disallowed access attempts will

241
00:14:34,629 --> 00:14:41,529
trigger EPT violations and then controls

242
00:14:37,839 --> 00:14:44,829
goes to the hypervisor so we can trap

243
00:14:41,529 --> 00:14:48,160
read write and execute access to the

244
00:14:44,829 --> 00:14:52,329
page by changing this memory access bits

245
00:14:48,160 --> 00:14:56,110
and the final fish is that we can

246
00:14:52,329 --> 00:14:58,239
allocate several EPT paging structures

247
00:14:56,110 --> 00:15:00,970
with various memory access

248
00:14:58,240 --> 00:15:03,999
configurations and by switching between

249
00:15:00,970 --> 00:15:09,009
them we can organize drivers execution

250
00:15:03,999 --> 00:15:11,410
in isolated enclaves we can see that EPT

251
00:15:09,009 --> 00:15:15,040
future seems to be very promising for

252
00:15:11,410 --> 00:15:18,759
memory isolation let me show you how all

253
00:15:15,040 --> 00:15:23,199
these ideas are implemented in my memory

254
00:15:18,759 --> 00:15:26,230
Ranger I explored the following scenario

255
00:15:23,199 --> 00:15:28,839
the OS kernel and other drivers are

256
00:15:26,230 --> 00:15:32,589
loaded into the memory and access their

257
00:15:28,839 --> 00:15:34,480
data we have only two legal access

258
00:15:32,589 --> 00:15:39,910
attempts which are marked by green

259
00:15:34,480 --> 00:15:42,759
arrows as the driver a is loaded it

260
00:15:39,910 --> 00:15:46,029
allocates memory and access is newly

261
00:15:42,759 --> 00:15:48,220
allocated data all in all now we have

262
00:15:46,029 --> 00:15:51,040
three legal access attempts which are

263
00:15:48,220 --> 00:15:54,249
marked by green by horizontal lines all

264
00:15:51,040 --> 00:15:56,649
horizontal lines are legal access nor

265
00:15:54,249 --> 00:16:01,360
horizontal lines which are red are

266
00:15:56,649 --> 00:16:04,360
illegal we have three illegal access

267
00:16:01,360 --> 00:16:06,279
attempts driver a modifies the OS

268
00:16:04,360 --> 00:16:10,829
internal structures for example to

269
00:16:06,279 --> 00:16:13,990
escalate privileges or to do something

270
00:16:10,829 --> 00:16:16,959
other drivers read the memory of a

271
00:16:13,990 --> 00:16:19,779
driver a for example to dump this driver

272
00:16:16,959 --> 00:16:24,279
in order to reverse engineering purpose

273
00:16:19,779 --> 00:16:27,429
and finally when other drivers try to

274
00:16:24,279 --> 00:16:29,410
override its allocated data for example

275
00:16:27,429 --> 00:16:34,299
to steal something or to attack this

276
00:16:29,410 --> 00:16:36,939
data as you remember that all drivers

277
00:16:34,299 --> 00:16:39,329
share the same memory space all these

278
00:16:36,939 --> 00:16:41,550
illegal access attempts are becoming

279
00:16:39,329 --> 00:16:45,699
uncontrolled

280
00:16:41,550 --> 00:16:48,399
now let's roll back and launch memoranda

281
00:16:45,700 --> 00:16:51,850
to isolate driver eight from the rest of

282
00:16:48,399 --> 00:16:55,089
the OS kernel first of all my memories

283
00:16:51,850 --> 00:16:58,240
allocates the default EPT structure

284
00:16:55,089 --> 00:17:01,600
although the drivers and Windows kernel

285
00:16:58,240 --> 00:17:06,220
are executed inside the default EPT

286
00:17:01,600 --> 00:17:09,579
structure memory ranger traps the

287
00:17:06,220 --> 00:17:13,270
loading of drive a and allocates in you

288
00:17:09,579 --> 00:17:16,178
EPT structure for driver a this EP

289
00:17:13,270 --> 00:17:20,139
disruption is designed specifically for

290
00:17:16,179 --> 00:17:22,540
this new driver ma'am arranger updates

291
00:17:20,140 --> 00:17:26,260
all EPG structures in the following way

292
00:17:22,540 --> 00:17:30,100
only driver a and OS kernel are executed

293
00:17:26,260 --> 00:17:34,000
inside this view EPG structure all other

294
00:17:30,100 --> 00:17:38,370
drivers can be executed in this memory

295
00:17:34,000 --> 00:17:41,860
because we've got to restrict the access

296
00:17:38,370 --> 00:17:44,168
in the new EPT structure memory access

297
00:17:41,860 --> 00:17:46,479
base have been cleared to zero for oil

298
00:17:44,169 --> 00:17:50,590
structures to restrict access from

299
00:17:46,480 --> 00:17:55,660
driver a here driver a cannot access OS

300
00:17:50,590 --> 00:17:58,540
kernel structures also in the default

301
00:17:55,660 --> 00:18:02,380
EPT structure memory access bits for

302
00:17:58,540 --> 00:18:05,440
drive a have been cleared as well so we

303
00:18:02,380 --> 00:18:08,380
can see the following picture driver a

304
00:18:05,440 --> 00:18:11,950
can be executed only in this memory

305
00:18:08,380 --> 00:18:14,130
while other drivers can be executed in

306
00:18:11,950 --> 00:18:21,280
the default EP destruction

307
00:18:14,130 --> 00:18:24,790
so after drive a allocates memory data

308
00:18:21,280 --> 00:18:28,149
my memory and updates all EPT structures

309
00:18:24,790 --> 00:18:30,280
again as a result any access from other

310
00:18:28,150 --> 00:18:32,500
drivers to the driver a and its

311
00:18:30,280 --> 00:18:35,799
allocated memory will be trapped and

312
00:18:32,500 --> 00:18:38,260
blocked all in all all access to the oil

313
00:18:35,799 --> 00:18:42,400
structures is forbidden for the driver a

314
00:18:38,260 --> 00:18:45,220
it means that drive a can access its

315
00:18:42,400 --> 00:18:47,740
memory only in these EBT structures and

316
00:18:45,220 --> 00:18:50,200
this memory cannot be accessed by other

317
00:18:47,740 --> 00:18:54,880
drivers because they executed in another

318
00:18:50,200 --> 00:18:58,730
memory which this data is forbidden

319
00:18:54,880 --> 00:19:01,190
in the same way memory allocates a

320
00:18:58,730 --> 00:19:03,590
separate EPT structure for each new

321
00:19:01,190 --> 00:19:08,149
driver and updates all other EPT

322
00:19:03,590 --> 00:19:10,189
structures it looks like a separate like

323
00:19:08,149 --> 00:19:13,729
drivers content in the kernel mode

324
00:19:10,190 --> 00:19:18,159
memory this is the main idea on this

325
00:19:13,730 --> 00:19:21,590
topic let's move on to the demonstration

326
00:19:18,159 --> 00:19:24,889
let's add one more treasure-house to our

327
00:19:21,590 --> 00:19:27,949
criminal story let it be American house

328
00:19:24,889 --> 00:19:32,658
full of Jackson Pollock paintings now we

329
00:19:27,950 --> 00:19:35,360
have three houses we'll free private art

330
00:19:32,659 --> 00:19:39,350
collections and the attacker is more

331
00:19:35,360 --> 00:19:43,699
motivated so to protect these houses we

332
00:19:39,350 --> 00:19:47,299
need to build at least a fence it helps

333
00:19:43,700 --> 00:19:50,419
to prevent attackers access and also as

334
00:19:47,299 --> 00:19:56,480
alleged three houses from each other as

335
00:19:50,419 --> 00:19:59,539
well in the kernel mode the drivers

336
00:19:56,480 --> 00:20:03,110
member will be isolated in the same way

337
00:19:59,539 --> 00:20:06,440
I will load three drivers we call them

338
00:20:03,110 --> 00:20:09,620
Russian British and American all three

339
00:20:06,440 --> 00:20:12,649
drivers store the data in the allocated

340
00:20:09,620 --> 00:20:15,129
memory pools after that I will launch a

341
00:20:12,649 --> 00:20:17,870
malware driver in order to steal and

342
00:20:15,129 --> 00:20:20,658
modify these databases as well as

343
00:20:17,870 --> 00:20:23,418
dumping the drivers code finally a

344
00:20:20,659 --> 00:20:26,509
malware driver will try to escalate

345
00:20:23,419 --> 00:20:29,690
process privileges let's have a look

346
00:20:26,509 --> 00:20:32,500
what will happen if I launch memoranda

347
00:20:29,690 --> 00:20:32,500
before

348
00:20:39,960 --> 00:20:57,080
oops

349
00:20:42,440 --> 00:20:59,390
yeah just a minute yep

350
00:20:57,080 --> 00:21:01,850
first of all I'm launching my ranger

351
00:20:59,390 --> 00:21:05,150
console application it allows the driver

352
00:21:01,850 --> 00:21:07,399
and activates the hypervisor here is in

353
00:21:05,150 --> 00:21:10,100
the left corner we've got a memory

354
00:21:07,400 --> 00:21:13,280
ranger console application then I'm

355
00:21:10,100 --> 00:21:16,100
launching three drivers Russian British

356
00:21:13,280 --> 00:21:20,270
at the center and American on the right

357
00:21:16,100 --> 00:21:24,350
corner finally the hack attack is

358
00:21:20,270 --> 00:21:28,460
launching its driver its console will be

359
00:21:24,350 --> 00:21:31,939
at the center now the attacker wants to

360
00:21:28,460 --> 00:21:38,060
dump the Russian rebel force he copies

361
00:21:31,940 --> 00:21:42,770
is address and we can see that now

362
00:21:38,060 --> 00:21:49,850
attacker can read nothing what about the

363
00:21:42,770 --> 00:21:53,030
next byte he has a zero value as well so

364
00:21:49,850 --> 00:21:56,270
we can see that attacker fails to dump

365
00:21:53,030 --> 00:22:05,450
this driver now let's leave the content

366
00:21:56,270 --> 00:22:10,310
using the driver itself yet now we have

367
00:22:05,450 --> 00:22:12,590
M and Z value we can see that mammal

368
00:22:10,310 --> 00:22:15,440
Ranger can protect the content of the

369
00:22:12,590 --> 00:22:18,350
Russian driver now the attack is

370
00:22:15,440 --> 00:22:21,140
entering the British house he is going

371
00:22:18,350 --> 00:22:25,699
to dump the British driver his copy its

372
00:22:21,140 --> 00:22:27,580
address and trying to read its content

373
00:22:25,700 --> 00:22:32,210
let's have a look

374
00:22:27,580 --> 00:22:35,600
so he gets a zero value again mammal

375
00:22:32,210 --> 00:22:37,700
range is foisting the fake no data to

376
00:22:35,600 --> 00:22:41,629
the attack instead of the real one

377
00:22:37,700 --> 00:22:46,000
now let's try to access the British

378
00:22:41,630 --> 00:22:50,480
driver using the British driver itself

379
00:22:46,000 --> 00:22:55,730
we're reading this data and now we're

380
00:22:50,480 --> 00:22:58,730
reading m & z bytes it means that man

381
00:22:55,730 --> 00:23:02,120
can prevent unauthorized access attempts

382
00:22:58,730 --> 00:23:05,450
and grants the legal access and now

383
00:23:02,120 --> 00:23:09,969
let's check is the American driver can

384
00:23:05,450 --> 00:23:09,970
dump British driver without attackers

385
00:23:10,570 --> 00:23:16,790
yeah we're moving to the American driver

386
00:23:13,580 --> 00:23:23,409
and tries to dump with the British

387
00:23:16,790 --> 00:23:23,409
driver we have zero value again

388
00:23:24,130 --> 00:23:37,970
isolates drivers from each other any

389
00:23:29,120 --> 00:23:40,429
applause okay say thank you now let's

390
00:23:37,970 --> 00:23:43,130
move on to the private data which can be

391
00:23:40,430 --> 00:23:45,230
stored in the allocated memory of the

392
00:23:43,130 --> 00:23:51,190
Russian driver I'm allocating wassily

393
00:23:45,230 --> 00:23:51,190
kandinsky now let's check the allocation

394
00:23:56,050 --> 00:24:01,399
Vasily Kandinsky data has been allocated

395
00:23:58,930 --> 00:24:07,810
for the British driver I'm allocating

396
00:24:01,400 --> 00:24:07,810
banksy now let's check the allocation

397
00:24:12,240 --> 00:24:18,809
and finally for that now we're moving to

398
00:24:15,960 --> 00:24:23,039
the American driver I'm allocating the

399
00:24:18,809 --> 00:24:27,019
date and setting Jackson Pollack now

400
00:24:23,039 --> 00:24:27,019
let's check this allocation finally

401
00:24:30,080 --> 00:24:38,070
Jackson Pollock now the attacker wants

402
00:24:34,980 --> 00:24:41,789
to steal all these treasures let's see

403
00:24:38,070 --> 00:24:44,820
if he doesn't manage that he is starting

404
00:24:41,789 --> 00:24:49,190
with Russian house and Kandinsky art his

405
00:24:44,820 --> 00:24:49,189
cotton is a dress and tries to read

406
00:24:50,600 --> 00:24:56,969
let's have a look

407
00:24:53,600 --> 00:25:00,059
yep the attacker can read only a note

408
00:24:56,970 --> 00:25:04,279
string now he is trying to overwrite

409
00:25:00,059 --> 00:25:07,440
this data using for once for example

410
00:25:04,279 --> 00:25:10,490
it's time to check if the Kandinsky has

411
00:25:07,440 --> 00:25:14,999
been modified we read the date again

412
00:25:10,490 --> 00:25:17,159
yeah and we can see that mammal range is

413
00:25:14,999 --> 00:25:21,629
protecting this data hackers

414
00:25:17,159 --> 00:25:24,119
failed to steal and modify Kandinsky now

415
00:25:21,629 --> 00:25:28,908
the attack is entering the British house

416
00:25:24,119 --> 00:25:33,029
to steal Banksy his copy is address and

417
00:25:28,909 --> 00:25:36,210
we can see that the attacker we can read

418
00:25:33,029 --> 00:25:42,299
nothing again now he's trying to

419
00:25:36,210 --> 00:25:44,990
override this data now we go back to the

420
00:25:42,299 --> 00:25:48,119
British app and check Banksy collection

421
00:25:44,990 --> 00:25:52,100
yeah we can see that mammal range is

422
00:25:48,119 --> 00:25:55,019
protecting Banksy as well and now

423
00:25:52,100 --> 00:25:57,149
finally let's check is the American

424
00:25:55,019 --> 00:26:02,249
driver can still banks a collection from

425
00:25:57,149 --> 00:26:04,678
the British house without attacker we

426
00:26:02,249 --> 00:26:09,960
are moving to the American driver and

427
00:26:04,679 --> 00:26:13,499
tries to read Banksy collection yeah no

428
00:26:09,960 --> 00:26:17,749
result now he's trying to overwrite this

429
00:26:13,499 --> 00:26:17,749
data using American driver

430
00:26:19,129 --> 00:26:23,059
let's check the collection

431
00:26:24,279 --> 00:26:29,749
we can see that memory range is

432
00:26:27,279 --> 00:26:33,799
isolating drivers allocation from each

433
00:26:29,749 --> 00:26:36,919
other as well so we can change the data

434
00:26:33,799 --> 00:26:40,249
only by the driver which our case this

435
00:26:36,919 --> 00:26:42,950
very data before let's check it let's

436
00:26:40,249 --> 00:26:45,649
replace Vasily Kandinsky with ivan

437
00:26:42,950 --> 00:26:47,960
aivazovsky he was a genius russian

438
00:26:45,649 --> 00:26:52,129
painter who double check Vasily

439
00:26:47,960 --> 00:26:55,669
Kandinsky and of writing it's replacing

440
00:26:52,129 --> 00:27:02,330
with ivan aivazovsky and let's check the

441
00:26:55,669 --> 00:27:04,539
date again so the allocated batter has

442
00:27:02,330 --> 00:27:10,678
been updated in a legal way

443
00:27:04,539 --> 00:27:14,440
memory is protected even allocated data

444
00:27:10,679 --> 00:27:17,159
now let's check a British escalation

445
00:27:14,440 --> 00:27:23,070
attack the attack is launched in CMD

446
00:27:17,159 --> 00:27:25,570
getting the same D identification and

447
00:27:23,070 --> 00:27:28,389
checking the privileges as we expected

448
00:27:25,570 --> 00:27:32,950
Cindy has uses privileges and cannot

449
00:27:28,389 --> 00:27:36,969
reconfigure Windows Firewall which is

450
00:27:32,950 --> 00:27:39,460
expected the access is denied the attack

451
00:27:36,970 --> 00:27:41,559
is trying to elevate and the simply

452
00:27:39,460 --> 00:27:44,850
privileges the tech is using proof

453
00:27:41,559 --> 00:27:47,769
command with process ID

454
00:27:44,850 --> 00:27:49,809
let's check the privileges we can see

455
00:27:47,769 --> 00:27:52,929
that simply has still uses privileges

456
00:27:49,809 --> 00:27:53,529
and can not reconfigure the Windows

457
00:27:52,929 --> 00:27:58,539
Firewall

458
00:27:53,529 --> 00:28:01,090
it means the attacker is failed CMD is

459
00:27:58,539 --> 00:28:20,879
not able to stop Windows Firewall

460
00:28:01,090 --> 00:28:24,658
service so you've just seen that this is

461
00:28:20,879 --> 00:28:28,149
kernel mode drivers with a small fence

462
00:28:24,659 --> 00:28:30,609
yeah you've just seen that memory range

463
00:28:28,149 --> 00:28:33,428
prevents illegal memory access by

464
00:28:30,609 --> 00:28:37,418
running drivers into isolated kernel

465
00:28:33,429 --> 00:28:39,879
spaces or enclosures let's have a look

466
00:28:37,419 --> 00:28:43,840
at memory access rules which are

467
00:28:39,879 --> 00:28:45,998
provided by memory Ranger memory ranger

468
00:28:43,840 --> 00:28:49,449
protects memory according to the

469
00:28:45,999 --> 00:28:53,139
principle of least privilege missoula

470
00:28:49,450 --> 00:28:58,720
loaded drivers can access only their own

471
00:28:53,139 --> 00:29:00,908
code the read and write access to the

472
00:28:58,720 --> 00:29:05,369
data is granted only to the drivers

473
00:29:00,909 --> 00:29:10,590
which allocate these data batters o

474
00:29:05,369 --> 00:29:13,629
other memory access attempts are blocked

475
00:29:10,590 --> 00:29:16,449
memory ranger protects drivers code from

476
00:29:13,629 --> 00:29:19,269
being dumped it prevents read and write

477
00:29:16,450 --> 00:29:23,020
access to the allocated data and finally

478
00:29:19,269 --> 00:29:25,590
it prevents approach escalation attack

479
00:29:23,020 --> 00:29:30,040
now let's move on to the memory

480
00:29:25,590 --> 00:29:33,879
architecture this memory range includes

481
00:29:30,040 --> 00:29:36,100
the following three parts memory Mon rwx

482
00:29:33,880 --> 00:29:39,670
which is on the left the central

483
00:29:36,100 --> 00:29:43,178
component is DDI mod and the final is

484
00:29:39,670 --> 00:29:46,300
memory access policy the third two parts

485
00:29:43,179 --> 00:29:48,850
were developed by Satoshi turned on his

486
00:29:46,300 --> 00:29:53,800
genius researcher from Japan during our

487
00:29:48,850 --> 00:29:56,379
collaboration memory Mon rwx processes

488
00:29:53,800 --> 00:29:59,590
for loading and new drivers and present

489
00:29:56,380 --> 00:30:03,100
processes as well as all apt violations

490
00:29:59,590 --> 00:30:05,409
while Digimon installs the invisible

491
00:30:03,100 --> 00:30:08,080
hooks and kernel functions which

492
00:30:05,410 --> 00:30:11,080
allocated and deallocate memory

493
00:30:08,080 --> 00:30:13,689
I developed a memory access policy which

494
00:30:11,080 --> 00:30:18,730
is a kind of brain for the first two

495
00:30:13,690 --> 00:30:21,070
parts for each newly loaded process mam

496
00:30:18,730 --> 00:30:23,260
arranged ads before in structure to the

497
00:30:21,070 --> 00:30:25,990
list this structure includes pearl

498
00:30:23,260 --> 00:30:30,700
society and the address of it's a

499
00:30:25,990 --> 00:30:33,010
process structure for each newly loaded

500
00:30:30,700 --> 00:30:34,030
driver memory range as the Fallen

501
00:30:33,010 --> 00:30:35,920
structure to the list

502
00:30:34,030 --> 00:30:38,559
destruction closes an address of

503
00:30:35,920 --> 00:30:40,690
allocated EPT structure which is all

504
00:30:38,559 --> 00:30:43,450
hated specifically for this driver as

505
00:30:40,690 --> 00:30:46,480
well as drivers start and end undresses

506
00:30:43,450 --> 00:30:49,320
and a vector to collect memory addresses

507
00:30:46,480 --> 00:30:52,210
which will be allocated by this driver

508
00:30:49,320 --> 00:30:55,960
each time the driver allocates memory

509
00:30:52,210 --> 00:30:59,080
data memory as the full information to

510
00:30:55,960 --> 00:31:02,500
the list this structure includes the

511
00:30:59,080 --> 00:31:07,030
data the address and the size of newly

512
00:31:02,500 --> 00:31:09,730
allocated data memory access policy

513
00:31:07,030 --> 00:31:13,240
managed all this list and decides to

514
00:31:09,730 --> 00:31:15,760
grant memory access or to denied all the

515
00:31:13,240 --> 00:31:20,710
details about memory and architecture

516
00:31:15,760 --> 00:31:23,530
are in my white paper to put it in a

517
00:31:20,710 --> 00:31:26,230
nutshell the mam arranged dispatcher is

518
00:31:23,530 --> 00:31:28,510
here it processes three

519
00:31:26,230 --> 00:31:34,540
EPT violations read write and execute

520
00:31:28,510 --> 00:31:36,820
and one VM exit for execute violation

521
00:31:34,540 --> 00:31:39,610
mam arranger changes point

522
00:31:36,820 --> 00:31:43,389
to the appropriate EPT structure so the

523
00:31:39,610 --> 00:31:46,418
kernel mode code continues its execution

524
00:31:43,389 --> 00:31:49,418
into the corresponding EPT instruction

525
00:31:46,419 --> 00:31:51,820
this looks like swapping context in the

526
00:31:49,419 --> 00:31:56,320
user mode application but in the kernel

527
00:31:51,820 --> 00:31:58,570
mode drivers for read and write

528
00:31:56,320 --> 00:32:02,678
violations mem arranged checks whether

529
00:31:58,570 --> 00:32:06,009
this axis is legal and for illegal

530
00:32:02,679 --> 00:32:08,409
access the memory range changes PSN

531
00:32:06,009 --> 00:32:11,110
value or page frame number or the

532
00:32:08,409 --> 00:32:14,909
protected data to the fake one and

533
00:32:11,110 --> 00:32:19,330
allows access to this fake data and

534
00:32:14,909 --> 00:32:22,149
finally it sets monitor trap flag as a

535
00:32:19,330 --> 00:32:25,090
result after a driver reason the fake

536
00:32:22,149 --> 00:32:31,389
data the control goes to the hypervisor

537
00:32:25,090 --> 00:32:33,850
again and now memory Ranger restores pfn

538
00:32:31,389 --> 00:32:37,178
value to the protected data and blocks

539
00:32:33,850 --> 00:32:44,939
any access to this page finally it

540
00:32:37,179 --> 00:32:48,220
resets the monitor trap flag here are

541
00:32:44,940 --> 00:32:52,240
steps to add and you deta to be

542
00:32:48,220 --> 00:32:54,370
protected by my memory ranger first of

543
00:32:52,240 --> 00:32:57,009
all you need to create a list of

544
00:32:54,370 --> 00:32:59,018
addresses and sizes of memory regions

545
00:32:57,009 --> 00:33:01,990
which are needed to be protected and

546
00:32:59,019 --> 00:33:06,879
clear access bits to restrict the access

547
00:33:01,990 --> 00:33:11,080
and don't forget to update your list for

548
00:33:06,879 --> 00:33:14,259
example using callback functions then

549
00:33:11,080 --> 00:33:17,830
dispatch EPT violations which occur

550
00:33:14,259 --> 00:33:18,789
during access your data to process all

551
00:33:17,830 --> 00:33:22,178
violations

552
00:33:18,789 --> 00:33:26,379
you have three input parameters type of

553
00:33:22,179 --> 00:33:30,730
access read or write in our address of

554
00:33:26,379 --> 00:33:32,649
module which tries to access and finally

555
00:33:30,730 --> 00:33:35,169
the address of data which has been

556
00:33:32,649 --> 00:33:36,789
accessed this looks like IP address

557
00:33:35,169 --> 00:33:40,299
we've got source address and destination

558
00:33:36,789 --> 00:33:43,029
race who is trying to access and what

559
00:33:40,299 --> 00:33:47,230
kind of data this model tries to access

560
00:33:43,029 --> 00:33:49,539
and type of access read or write you can

561
00:33:47,230 --> 00:33:55,149
only monitor the access attempts as well

562
00:33:49,539 --> 00:33:58,110
as redirect them now let's move on to

563
00:33:55,149 --> 00:34:02,139
the final step which is the benchmark

564
00:33:58,110 --> 00:34:04,479
assessment I measure at the time of

565
00:34:02,139 --> 00:34:08,679
legal access from driver to the

566
00:34:04,480 --> 00:34:11,520
allocated data in for situations without

567
00:34:08,679 --> 00:34:14,918
memory protection with enabled cache

568
00:34:11,520 --> 00:34:17,918
with disabled cache and with to memory

569
00:34:14,918 --> 00:34:20,888
protectors all main pro and memory

570
00:34:17,918 --> 00:34:24,158
rangin all named pro or allocated memory

571
00:34:20,889 --> 00:34:27,099
protector is the closest competitor for

572
00:34:24,159 --> 00:34:32,169
memory ranger which I developed on a

573
00:34:27,099 --> 00:34:35,379
hero as well all impro uses only one

574
00:34:32,168 --> 00:34:39,790
EPT structure to prevent illegal access

575
00:34:35,379 --> 00:34:42,699
attempts only to the allocated memory we

576
00:34:39,790 --> 00:34:45,279
can see that memo range is a bit slower

577
00:34:42,699 --> 00:34:48,549
than access to the memory with disabled

578
00:34:45,280 --> 00:34:53,649
cache and it three times faster than the

579
00:34:48,550 --> 00:34:57,430
closest competitor we are close to the

580
00:34:53,649 --> 00:34:59,470
end of our dramatic story let me recap

581
00:34:57,430 --> 00:35:02,549
very briefly on what I've presented and

582
00:34:59,470 --> 00:35:05,319
what you alone first of all I

583
00:35:02,550 --> 00:35:08,079
demonstrated when drivers can access

584
00:35:05,319 --> 00:35:12,130
kernel mode memory without any security

585
00:35:08,079 --> 00:35:14,650
reaction then I presented memory ranger

586
00:35:12,130 --> 00:35:17,859
which can prevent unauthorized memory

587
00:35:14,650 --> 00:35:21,579
access by running drivers into isolated

588
00:35:17,859 --> 00:35:26,828
enclaves finally I I like to highlight

589
00:35:21,579 --> 00:35:29,380
while important thing and I suppose that

590
00:35:26,829 --> 00:35:31,900
memo Ranger seems to prevent the recent

591
00:35:29,380 --> 00:35:35,440
side-channel attacks like spectre and

592
00:35:31,900 --> 00:35:39,880
meltdown and I think it would be

593
00:35:35,440 --> 00:35:42,910
interesting to to test this memory

594
00:35:39,880 --> 00:35:45,760
ranger using these attacks and if anyone

595
00:35:42,910 --> 00:35:48,040
has a prototype of Spector and Mel down

596
00:35:45,760 --> 00:35:53,079
please send it I will test and we will

597
00:35:48,040 --> 00:35:55,930
see the result and I just like to

598
00:35:53,079 --> 00:35:58,500
conclude with old Latin expression it is

599
00:35:55,930 --> 00:35:58,500
on the screen

600
00:35:58,960 --> 00:36:06,550
this is very famous expression I believe

601
00:36:03,880 --> 00:36:09,670
that it is applicable not only for Asian

602
00:36:06,550 --> 00:36:17,590
Sparta but only for kernel-mode drivers

603
00:36:09,670 --> 00:36:25,150
in used windows thank you that's it and

604
00:36:17,590 --> 00:36:27,730
now and now we are moving to the most

605
00:36:25,150 --> 00:36:34,350
interesting part of today's topic for

606
00:36:27,730 --> 00:36:37,920
your questions please raise your hands

607
00:36:34,350 --> 00:36:40,600
we've got just one question

608
00:36:37,920 --> 00:36:42,940
hello thanks for the talk

609
00:36:40,600 --> 00:36:46,000
is it correct my understanding correct

610
00:36:42,940 --> 00:36:49,810
that you can only use memory ranger on

611
00:36:46,000 --> 00:36:53,410
x86 platforms so it's like architecture

612
00:36:49,810 --> 00:36:56,799
specific the thing is that memory range

613
00:36:53,410 --> 00:36:59,799
is based on hypervisor facilities and it

614
00:36:56,800 --> 00:37:03,220
is works on all platforms which supports

615
00:36:59,800 --> 00:37:07,570
vt-x technology with EPT provided by

616
00:37:03,220 --> 00:37:11,680
Intel not only for Windows this is let's

617
00:37:07,570 --> 00:37:15,190
open some interesting slide with memory

618
00:37:11,680 --> 00:37:20,730
and jacket area there are a lot of

619
00:37:15,190 --> 00:37:24,460
projects for UNIX operating system which

620
00:37:20,730 --> 00:37:27,670
focusing on similar similar tasks yeah

621
00:37:24,460 --> 00:37:29,590
and for ARM architecture you know

622
00:37:27,670 --> 00:37:35,290
they've got similar hypervisor

623
00:37:29,590 --> 00:37:37,980
facilities yet so technically it can

624
00:37:35,290 --> 00:37:41,830
work arm

625
00:37:37,980 --> 00:37:43,930
technically work I think in in all intro

626
00:37:41,830 --> 00:37:48,640
computers which has been sold for the

627
00:37:43,930 --> 00:37:51,040
last ten years yes for AMD computers we

628
00:37:48,640 --> 00:37:56,109
have bought similar technologies for the

629
00:37:51,040 --> 00:38:02,170
last 10 years and I think for arm around

630
00:37:56,110 --> 00:38:03,910
computers as well yeah you ought you

631
00:38:02,170 --> 00:38:08,050
also mentioned there are unique

632
00:38:03,910 --> 00:38:11,379
solutions how it would be different on

633
00:38:08,050 --> 00:38:12,110
UNIX of for example like on Linux

634
00:38:11,380 --> 00:38:14,600
systems I

635
00:38:12,110 --> 00:38:16,850
know that like Linux likes to pass

636
00:38:14,600 --> 00:38:20,480
internal data structures from one piece

637
00:38:16,850 --> 00:38:22,610
of code to another so technically you

638
00:38:20,480 --> 00:38:25,160
can operate on an internal data

639
00:38:22,610 --> 00:38:27,170
structure which is not necessarily it

640
00:38:25,160 --> 00:38:30,500
can be allocated by another driver and

641
00:38:27,170 --> 00:38:32,900
you have a legit way legit need to

642
00:38:30,500 --> 00:38:36,800
access it yeah

643
00:38:32,900 --> 00:38:40,040
this is a very complicated question the

644
00:38:36,800 --> 00:38:43,160
thing is that nowadays mam arranger does

645
00:38:40,040 --> 00:38:46,520
not provide shared access to one memory

646
00:38:43,160 --> 00:38:50,149
for two drivers but access policies can

647
00:38:46,520 --> 00:38:53,930
be adopted yeah to improve it the thing

648
00:38:50,150 --> 00:38:56,450
is that now rules are quite simple yeah

649
00:38:53,930 --> 00:38:58,580
only drive a whole a case memory has

650
00:38:56,450 --> 00:39:02,779
full access to this data all other

651
00:38:58,580 --> 00:39:05,569
accesses can't access but my idea is we

652
00:39:02,780 --> 00:39:09,590
can generate a memory access rules on

653
00:39:05,570 --> 00:39:11,660
the compile phase when we compile our

654
00:39:09,590 --> 00:39:13,490
drivers using visual studio in the

655
00:39:11,660 --> 00:39:16,069
development phase we can generate

656
00:39:13,490 --> 00:39:18,200
because developers always know which

657
00:39:16,070 --> 00:39:20,420
memory because for example several

658
00:39:18,200 --> 00:39:27,640
drivers usually compiled in the one

659
00:39:20,420 --> 00:39:31,010
solution and in now we can prepare

660
00:39:27,640 --> 00:39:33,109
appropriate memory access rules the

661
00:39:31,010 --> 00:39:36,680
thing is that for linux based solutions

662
00:39:33,110 --> 00:39:39,950
they've got operating system we've open

663
00:39:36,680 --> 00:39:45,560
a code for example linux ubuntu and a

664
00:39:39,950 --> 00:39:50,450
lot of EV and they got more mechanisms

665
00:39:45,560 --> 00:39:55,490
to protect memory yeah in my paper yeah

666
00:39:50,450 --> 00:40:00,109
I want if you if you you can read my

667
00:39:55,490 --> 00:40:03,049
paper there I think about about 30

668
00:40:00,110 --> 00:40:05,360
projects which are folks on precisely

669
00:40:03,050 --> 00:40:08,870
this topic how to protect memory and

670
00:40:05,360 --> 00:40:11,660
vast majority is developed for UNIX

671
00:40:08,870 --> 00:40:15,819
based systems not for Windows just few

672
00:40:11,660 --> 00:40:19,100
for Windows thank you thank you

673
00:40:15,820 --> 00:40:22,660
actually this is the big problem with

674
00:40:19,100 --> 00:40:25,910
memory protection in kernel mode because

675
00:40:22,660 --> 00:40:31,240
the main idea of Microsoft company

676
00:40:25,910 --> 00:40:34,430
is that Kurama drivers do not include

677
00:40:31,240 --> 00:40:38,270
malware or don't have molnár abilities

678
00:40:34,430 --> 00:40:40,520
and we always trust kernel-mode but

679
00:40:38,270 --> 00:40:43,599
nowadays we can see a lot of examples of

680
00:40:40,520 --> 00:40:47,720
malware which can leverage drivers

681
00:40:43,599 --> 00:40:51,910
facilities we can a lot of drivers which

682
00:40:47,720 --> 00:40:53,980
can include owner abilities yeah

683
00:40:51,910 --> 00:40:57,799
attacks for example Stuxnet is

684
00:40:53,980 --> 00:41:04,910
old-fashioned attack more than 10 10 12

685
00:40:57,799 --> 00:41:09,410
years ago the thing is it I think it

686
00:41:04,910 --> 00:41:12,109
will be good idea to implement the

687
00:41:09,410 --> 00:41:14,210
mechanism of process switching between

688
00:41:12,109 --> 00:41:18,950
process like process context in the

689
00:41:14,210 --> 00:41:21,770
kernel mode yeah for especially for

690
00:41:18,950 --> 00:41:24,529
windows because we've got source code

691
00:41:21,770 --> 00:41:27,619
was there kernel and we can protect

692
00:41:24,530 --> 00:41:34,730
these drivers oh we've got one question

693
00:41:27,619 --> 00:41:38,960
more thank you so as far as I know a

694
00:41:34,730 --> 00:41:43,190
hyper-v also uses Intel a apt so does

695
00:41:38,960 --> 00:41:45,289
your software run next hyper-v or is

696
00:41:43,190 --> 00:41:50,150
there a problem to use it both on one

697
00:41:45,289 --> 00:41:53,089
system the thing is that I've tested a

698
00:41:50,150 --> 00:41:57,680
memory ranger without hyper-v and this

699
00:41:53,089 --> 00:42:00,529
is quite an issue to work this two

700
00:41:57,680 --> 00:42:03,529
different solutions which use same

701
00:42:00,529 --> 00:42:08,329
technology the translational EPT at the

702
00:42:03,529 --> 00:42:11,960
same machine this is will be my next

703
00:42:08,329 --> 00:42:13,990
steps to check not only with hyper-v

704
00:42:11,960 --> 00:42:17,890
with another technologies like with

705
00:42:13,990 --> 00:42:20,689
antivirus systems

706
00:42:17,890 --> 00:42:24,788
let's see but maybe hyper we will

707
00:42:20,690 --> 00:42:26,119
integrate memory ranger principles yeah

708
00:42:24,789 --> 00:42:33,380
thank you

709
00:42:26,119 --> 00:42:36,020
oh we've got one more question so it

710
00:42:33,380 --> 00:42:38,359
works only on newly loaded drivers yeah

711
00:42:36,020 --> 00:42:39,609
only annually load the drivers yep so it

712
00:42:38,359 --> 00:42:45,119
should be possible to unload

713
00:42:39,609 --> 00:42:48,609
driver and load it again he means it

714
00:42:45,119 --> 00:42:52,599
loaded driver and then unload is if a

715
00:42:48,609 --> 00:42:58,239
driver is previously loaded in order to

716
00:42:52,599 --> 00:43:03,009
be here - - - - yeah

717
00:42:58,239 --> 00:43:05,440
to avoid this protection yeah yeah the

718
00:43:03,009 --> 00:43:10,359
thing is I haven't tested your scenario

719
00:43:05,440 --> 00:43:11,950
but you know the current version of

720
00:43:10,359 --> 00:43:14,650
memory range is just proof of concept

721
00:43:11,950 --> 00:43:18,189
prototype it doesn't support unloading

722
00:43:14,650 --> 00:43:21,009
drivers and deleting context EPT

723
00:43:18,190 --> 00:43:24,609
structures yeah

724
00:43:21,009 --> 00:43:28,089
I assume the drivers will load it in a

725
00:43:24,609 --> 00:43:29,769
legal way like using service Control

726
00:43:28,089 --> 00:43:32,019
Manager because there are various

727
00:43:29,769 --> 00:43:36,819
hackers a process to load kernel-mode

728
00:43:32,019 --> 00:43:41,229
code and and continuously working just

729
00:43:36,819 --> 00:43:46,089
like Nvidia drivers yeah so this would

730
00:43:41,229 --> 00:43:49,299
be a suggestion already loaded - I don't

731
00:43:46,089 --> 00:43:52,719
find the memory allocations and we map

732
00:43:49,299 --> 00:43:55,719
them using a new EP t to protect

733
00:43:52,719 --> 00:43:59,380
existing loaded drivers here you mean

734
00:43:55,719 --> 00:44:03,579
just patching EPT rules yeah you know

735
00:43:59,380 --> 00:44:06,849
yeah thank you for questions it's a hack

736
00:44:03,579 --> 00:44:09,849
absolutely thinking about yes you're

737
00:44:06,849 --> 00:44:12,849
right if you can now this in the current

738
00:44:09,849 --> 00:44:16,150
version memory access memory rules yeah

739
00:44:12,849 --> 00:44:19,449
they do not protect it from being ridden

740
00:44:16,150 --> 00:44:23,170
over written yes you can change rules

741
00:44:19,449 --> 00:44:26,140
yeah but it can be possible to protect

742
00:44:23,170 --> 00:44:28,890
these rules using specific EPT structure

743
00:44:26,140 --> 00:44:32,709
for memory Ranger and these rules yeah

744
00:44:28,890 --> 00:44:38,549
yeah this is one of key point here yeah

745
00:44:32,709 --> 00:44:38,549
you understand everything thank you

746
00:44:41,190 --> 00:44:49,109
we've got some minutes yeah five minutes

747
00:44:44,339 --> 00:44:51,960
oh we got one more question how do you

748
00:44:49,109 --> 00:44:53,460
protect your driver when you're booting

749
00:44:51,960 --> 00:44:54,900
your machine from another may be

750
00:44:53,460 --> 00:44:56,880
malicious driver that was already

751
00:44:54,900 --> 00:44:59,010
installing your machine maybe we'll try

752
00:44:56,880 --> 00:45:02,119
to disable your drive and avoid this

753
00:44:59,010 --> 00:45:05,520
protection and disable these protections

754
00:45:02,119 --> 00:45:07,890
nowadays I don't provide any mechanism

755
00:45:05,520 --> 00:45:11,400
to protect my drivers from malware

756
00:45:07,890 --> 00:45:15,328
driver I just consider this scenario -

757
00:45:11,400 --> 00:45:19,380
yeah but it's possible - to implement

758
00:45:15,329 --> 00:45:21,510
some ideas but it's only arm race yeah

759
00:45:19,380 --> 00:45:26,010
how many techniques do you know how many

760
00:45:21,510 --> 00:45:28,349
techniques are implemented yeah also if

761
00:45:26,010 --> 00:45:29,099
we watch few minutes I can show you one

762
00:45:28,349 --> 00:45:32,490
more demo

763
00:45:29,099 --> 00:45:36,930
do you have some more questions no no

764
00:45:32,490 --> 00:45:40,740
let's see one more demo without sound

765
00:45:36,930 --> 00:45:45,270
but yeah this video will demonstrate an

766
00:45:40,740 --> 00:45:48,359
early version of memory Ranger yeah and

767
00:45:45,270 --> 00:45:52,529
we can see the another interesting

768
00:45:48,359 --> 00:45:55,109
question how often we need to swap

769
00:45:52,529 --> 00:46:03,210
context between different EPT structures

770
00:45:55,109 --> 00:46:06,779
to protect our driver first we'll launch

771
00:46:03,210 --> 00:46:11,579
memory Ranger yeah yeah

772
00:46:06,779 --> 00:46:17,660
the memory has been loaded yeah now well

773
00:46:11,579 --> 00:46:17,660
loaded memory which allocates memory

774
00:46:20,960 --> 00:46:28,829
copy is address and track

775
00:46:23,400 --> 00:46:35,400
yeah yeah yeah

776
00:46:28,829 --> 00:46:37,440
in the this which shows the switch

777
00:46:35,400 --> 00:46:39,630
between the default apt and the

778
00:46:37,440 --> 00:46:43,619
protected DVD here is from the default

779
00:46:39,630 --> 00:46:47,130
to the protected in a session you can

780
00:46:43,619 --> 00:46:49,770
see how how often we change our apt

781
00:46:47,130 --> 00:46:51,720
pointer between various drivers in this

782
00:46:49,770 --> 00:46:54,890
case we've got only one protected driver

783
00:46:51,720 --> 00:46:58,069
and all others all other drivers

784
00:46:54,890 --> 00:47:00,379
in the default apt one only one driver

785
00:46:58,070 --> 00:47:05,120
which is memory allocated loaded in the

786
00:47:00,380 --> 00:47:10,940
protector just for example how often and

787
00:47:05,120 --> 00:47:20,900
this is attacker attack is loaded into

788
00:47:10,940 --> 00:47:26,350
the default EPT instruction now attacker

789
00:47:20,900 --> 00:47:34,840
wants to dump this driver and we can see

790
00:47:26,350 --> 00:47:38,750
yep that memo Ranger let's have a look

791
00:47:34,840 --> 00:47:43,030
yeah and what about the next address yep

792
00:47:38,750 --> 00:47:48,770
and yeah we've got only one read access

793
00:47:43,030 --> 00:47:52,820
because we read only one byte and now

794
00:47:48,770 --> 00:47:57,650
it's time to check allocation I allocate

795
00:47:52,820 --> 00:48:00,050
just ABCD yeah we demonstrated it the

796
00:47:57,650 --> 00:48:04,160
member has been Oh like again here is

797
00:48:00,050 --> 00:48:06,890
the point now we're reading the content

798
00:48:04,160 --> 00:48:11,600
of our driver using our drive itself

799
00:48:06,890 --> 00:48:16,009
got a minute yeah and to read just one

800
00:48:11,600 --> 00:48:19,549
bite we need to got a lot of switching

801
00:48:16,010 --> 00:48:23,090
between EPT console you know because

802
00:48:19,550 --> 00:48:24,830
we've got scheduler we've got lots of

803
00:48:23,090 --> 00:48:29,060
file system drivers which need to be

804
00:48:24,830 --> 00:48:32,480
executed and you can see how many 1 2 3

805
00:48:29,060 --> 00:48:36,070
4 swishing to read just one bite from

806
00:48:32,480 --> 00:48:36,070
our protected driver

807
00:48:43,710 --> 00:48:52,200
yeah we were just one minute and now

808
00:48:49,710 --> 00:49:00,780
it's time to check allocation we

809
00:48:52,200 --> 00:49:03,720
allocate ABCD without painters yeah you

810
00:49:00,780 --> 00:49:07,170
can see how many interceptions how many

811
00:49:03,720 --> 00:49:12,299
solutions is needed to hotel like it she

812
00:49:07,170 --> 00:49:16,800
buys yeah anyway I will copy this

813
00:49:12,300 --> 00:49:21,140
address and move to the attacker we

814
00:49:16,800 --> 00:49:21,140
double-check the data has been allocated

815
00:49:24,950 --> 00:49:35,399
who tries to overwrite this data yeah

816
00:49:29,599 --> 00:49:37,109
yeah this is this is our data and the

817
00:49:35,400 --> 00:49:39,770
data have been allocated we would double

818
00:49:37,109 --> 00:49:39,770
effort to end

819
00:49:49,940 --> 00:49:58,720
yeah but restore and now we tries to

820
00:49:52,580 --> 00:50:02,900
access this data using another driver

821
00:49:58,720 --> 00:50:04,359
yep and the data doesn't protect it and

822
00:50:02,900 --> 00:50:07,340
you can see there are a lot of

823
00:50:04,360 --> 00:50:13,460
interceptions switches switches using

824
00:50:07,340 --> 00:50:16,220
protect driver and not protected yeah

825
00:50:13,460 --> 00:50:20,240
this is close to the question about

826
00:50:16,220 --> 00:50:29,390
benchmark assessment and how fast memory

827
00:50:20,240 --> 00:50:31,479
Nia is working and that's it yes thank

828
00:50:29,390 --> 00:50:31,480
you

