1
00:00:00,000 --> 00:00:04,569
my name is Alexander I work as a
software security engineer poor in those

2
00:00:04,569 --> 00:00:11,559
open source technology center in today's
thought is focused on a fuzzy approach

3
00:00:11,559 --> 00:00:19,160
that target system components in and
read the main points of the presentation

4
00:00:19,160 --> 00:00:24,730
first we'll have six and that deals with
a set of general methods and concepts

5
00:00:24,730 --> 00:00:29,960
that can be used for housing in an
Android environment this approach will

6
00:00:29,960 --> 00:00:34,579
not try to offer a complete picture but
rather to give an example or a starting

7
00:00:34,579 --> 00:00:39,329
point for someone who is interested in
this topic then we'll see how this

8
00:00:39,329 --> 00:00:45,129
approach applies to several real-life
rising good targets from the Android OS

9
00:00:45,129 --> 00:00:50,570
will see how they approach applies to
finding stage fright which is the media

10
00:00:50,570 --> 00:00:55,649
from Morgan Android and then we'll see
how this approach applies to the Android

11
00:00:55,649 --> 00:01:01,329
application installer towards the end of
the session will also have an

12
00:01:01,329 --> 00:01:05,750
alternative approach will discuss how to
use the popular American flag you look

13
00:01:05,750 --> 00:01:21,750
inside the the Android OS approach first
we'll see a few methods in which we can

14
00:01:21,750 --> 00:01:27,840
generate from this set up for our
funding needs the actual execution or

15
00:01:27,840 --> 00:01:31,180
running of the tests won't be taken into
consideration for the section because

16
00:01:31,180 --> 00:01:37,079
this is a process that is highly
specific for each target so we will

17
00:01:37,079 --> 00:01:44,470
discuss about this in more detail for
example for his project example then we

18
00:01:44,470 --> 00:01:49,009
will go on and see how we can monitor
the results

19
00:01:49,009 --> 00:01:53,810
inside the funding campaign under it
will see how to do this and to get the

20
00:01:53,810 --> 00:02:00,140
results in real-time in the Fortune case
when running a positive campaign and we

21
00:02:00,140 --> 00:02:00,630
have

22
00:02:00,630 --> 00:02:08,008
other results or other crashes we need a
way to automatically sort out the unique

23
00:02:08,008 --> 00:02:14,950
issues so we can see we can develop a
mechanism will see how to how to do this

24
00:02:14,950 --> 00:02:21,089
and in the end when we have only the
unique issues and the few unique issues

25
00:02:21,090 --> 00:02:29,430
need a way to analyze them to debug them
to sort the sort them based on their

26
00:02:29,430 --> 00:02:38,450
severity and receive their exploitable
or not so generally speaking about

27
00:02:38,450 --> 00:02:43,609
causing we have mutational focusing on
one hand and Jonathan focusing on the

28
00:02:43,610 --> 00:02:52,459
other hand causing needs that we take
initial set of inputs or this cases and

29
00:02:52,459 --> 00:02:57,040
we tried to apply different mutations to
them we need to take into consideration

30
00:02:57,040 --> 00:03:02,200
that while applying those mutations we
need to make sure that the target

31
00:03:02,200 --> 00:03:08,690
component system that we are fasting
needs to believe that we are feeding is

32
00:03:08,690 --> 00:03:14,819
valid so we need to pass those initial
test cases but give them structure

33
00:03:14,819 --> 00:03:21,179
invalid generation proton generational
fussing is based on the fact that we

34
00:03:21,180 --> 00:03:23,870
tried to create the march from input
from scratch

35
00:03:23,870 --> 00:03:29,579
we need to know the internals of the
formatter the structure of the data that

36
00:03:29,579 --> 00:03:37,950
we are heading to target and based on
that format we need to try to create an

37
00:03:37,950 --> 00:03:45,100
important that is also my farm but also
structure is valid for the projects that

38
00:03:45,100 --> 00:03:50,730
I'm going to talk about today this is
the to set that we've been using so

39
00:03:50,730 --> 00:03:55,358
first there is the basic funding
framework which is a mutational father

40
00:03:55,359 --> 00:04:05,170
at targets application that applications
that consume filing put this to the BFF

41
00:04:05,170 --> 00:04:08,000
is based on other popular tool

42
00:04:08,000 --> 00:04:13,360
it's based on a modified version of this
still don't have books which is actually

43
00:04:13,360 --> 00:04:19,320
a very small tool but more more
specialized 1 it specializes in

44
00:04:19,320 --> 00:04:25,020
targeting multimedia products both of
these tools work on Linux environments

45
00:04:25,020 --> 00:04:34,810
have announced on down there is actually
a collection of many small farming tools

46
00:04:34,810 --> 00:04:40,810
its main advantage and the reason why we
used it for our project or projects is

47
00:04:40,810 --> 00:04:45,250
the fact that you can pass seat to it so
when you actually get a crash you can

48
00:04:45,250 --> 00:04:50,430
easily go back and reproduce that crash
and also there's the American fuzzy

49
00:04:50,430 --> 00:04:54,900
little I think you are all familiar with
it I'm going to talk more into detail

50
00:04:54,900 --> 00:05:05,510
about it into a separate section of the
presentation so let's say we've

51
00:05:05,510 --> 00:05:13,099
generated Rd and we've executed on the
device we need to wait to see what

52
00:05:13,100 --> 00:05:19,680
happens if it's possible in real time
with that we are feeding 22 the Android

53
00:05:19,680 --> 00:05:27,450
OS if you're familiar with the landing
system Android you know that you can

54
00:05:27,450 --> 00:05:33,780
access it through the locate command the
thing is that each time a fatal crash

55
00:05:33,780 --> 00:05:41,080
occurs which time crash occurs at the
native code level in Android a fatal

56
00:05:41,080 --> 00:05:45,169
message is generated and inserted into
the local buffer the local buffer

57
00:05:45,169 --> 00:05:50,359
contains messages to and from all the
new system components are not only from

58
00:05:50,360 --> 00:05:56,690
applications as well and they are sorted
using priorities there are total seven

59
00:05:56,690 --> 00:06:04,150
priorities for messages that are
including two local local buffer we are

60
00:06:04,150 --> 00:06:09,150
interested in the fate of messages so
what we do each time we

61
00:06:09,150 --> 00:06:16,370
sound test get this case to be executed
on Android device we also partitioning

62
00:06:16,370 --> 00:06:26,020
cert fatal message in the local buffer
so for example this is an artificial

63
00:06:26,020 --> 00:06:31,479
certain messaging to the local buffer
you can see it has a fatal priority here

64
00:06:31,480 --> 00:06:41,070
you can manage using this command the
priority the component and other useful

65
00:06:41,070 --> 00:06:47,099
information about the test case usually
I'd recommend that you answered here

66
00:06:47,100 --> 00:06:51,890
information about how to actually
reproduce a crash for example if you are

67
00:06:51,890 --> 00:06:58,800
facing media files this would be more
simple example we could include hear the

68
00:06:58,800 --> 00:07:04,980
name of the file that was sent to be
decoded on the device and then have that

69
00:07:04,980 --> 00:07:10,400
media files saved let's say locally on
the local machine that is connected to

70
00:07:10,400 --> 00:07:17,530
the meander device so each time you send
that this case we get and when an actual

71
00:07:17,530 --> 00:07:21,729
fatal message that is actually generated
by the system like this one that's a

72
00:07:21,730 --> 00:07:27,880
segmentation fault will have a way to
reproduce that crash because this cases

73
00:07:27,880 --> 00:07:33,830
are sense sequentially we know that
these segmentation fault is Europe is

74
00:07:33,830 --> 00:07:43,300
produced by this component also as I
said earlier it's important to note that

75
00:07:43,300 --> 00:07:48,300
we must including in the message a way
to actually reproduce that crash because

76
00:07:48,300 --> 00:07:54,730
in some cases it won't be possible to
actually saved put that caused that

77
00:07:54,730 --> 00:08:00,760
crash you can you can have information
like seed or or stuff like that

78
00:08:00,760 --> 00:08:09,760
so we generate the data we've executed
and they are and we've generated the

79
00:08:09,760 --> 00:08:13,710
logs for testing campaign let's say
we've run

80
00:08:13,710 --> 00:08:19,020
testing campaign for a period of time
one day and we've generated deadlock

81
00:08:19,020 --> 00:08:24,909
that has the template that I mentioned
in the previous slide if we have a large

82
00:08:24,910 --> 00:08:31,310
number of crashes and we can go manually
through them we can go and check each

83
00:08:31,310 --> 00:08:37,840
photo singer and seed that caused it and
see if it's unicorn up and get

84
00:08:37,840 --> 00:08:43,440
information about that question we need
to wait to sort them in an ultimate

85
00:08:43,440 --> 00:08:50,570
matter what we do is besides the fatal
message that is generated each time

86
00:08:50,570 --> 00:08:59,460
crash occurs in the and read local we
have an entry that is generated in the

87
00:08:59,460 --> 00:09:03,620
daytime storms files on the device so
you have what is known that is generated

88
00:09:03,620 --> 00:09:08,710
for each crash in Android the tombstone
file contains a lot of useful

89
00:09:08,710 --> 00:09:13,940
information contains the type of signal
the code for that signal the value of

90
00:09:13,940 --> 00:09:21,430
the registries at a time of the crash
and back brace for that pressure what is

91
00:09:21,430 --> 00:09:25,229
interesting for us from the perspective
of power from the perspective of the

92
00:09:25,230 --> 00:09:30,880
trust mechanism is the program counter
value for the last component in the

93
00:09:30,880 --> 00:09:42,010
backtrace so this value will be unique
for each crash the thing is that we need

94
00:09:42,010 --> 00:09:47,770
to carefully applied this mechanism
because if we are testing on different

95
00:09:47,770 --> 00:09:54,329
images on the phone bills of Android if
we will have the same identical crash

96
00:09:54,330 --> 00:09:59,480
the program counter will differ so this
mechanism applies only if we are testing

97
00:09:59,480 --> 00:10:03,779
on the exact same bill different runs

98
00:10:03,779 --> 00:10:08,930
here are more details about the actual
implementation of the trio's mechanism

99
00:10:08,930 --> 00:10:16,079
so let's aim had initial testing phase
where we executed the files and we

100
00:10:16,079 --> 00:10:20,859
generated that the logs that have that
specific format we save the logs with

101
00:10:20,860 --> 00:10:29,069
that specific format and we parse them
identified the crisis see what input

102
00:10:29,069 --> 00:10:34,628
produced the crash it can either be
directed the file that produced that

103
00:10:34,629 --> 00:10:40,639
crash or ways to reproduce it and for
each of the identified imports what we

104
00:10:40,639 --> 00:10:43,899
do is right across from the crash we
resent it

105
00:10:43,899 --> 00:10:49,939
device see if it actually crisis the
device if it does generate the tombstone

106
00:10:49,939 --> 00:10:53,769
so we grabbed that one stone which had
the program counter from the backtrace

107
00:10:53,769 --> 00:10:59,230
and if it's a value that has not been
previously encountered many pools that

108
00:10:59,230 --> 00:11:05,199
it is a new issue what we do then is we
save the tombstone because you want

109
00:11:05,199 --> 00:11:11,529
information about the crash and also we
save the input if it's possible or the

110
00:11:11,529 --> 00:11:24,559
exact information about how to reproduce
the crash issues generally speaking we

111
00:11:24,559 --> 00:11:30,149
most cases we are left with a number
that we can go from and try to analyze

112
00:11:30,149 --> 00:11:36,000
them the first place we go to see
information about the crash is as

113
00:11:36,000 --> 00:11:43,709
mentioned earlier the tombstone signal
type and the single code can give us the

114
00:11:43,709 --> 00:11:50,550
first clues of what's going on with that
that crash there are also useful

115
00:11:50,550 --> 00:11:56,939
information in the registry values that
will solve algeria's generally contains

116
00:11:56,939 --> 00:12:01,998
useful information from look at so
additional information besides the stuff

117
00:12:01,999 --> 00:12:04,990
that is that is on the screen

118
00:12:04,990 --> 00:12:13,240
where else can we go we can go to the
message those are two examples of

119
00:12:13,240 --> 00:12:21,920
grasses on stage fright the first is a
narrow for and there were six and this

120
00:12:21,920 --> 00:12:29,599
is how we can identify what is going on
with these errors so one is an invalid

121
00:12:29,600 --> 00:12:40,779
read and wanted to write Jerry speaking
in these are the types of issues that

122
00:12:40,779 --> 00:12:48,170
we've encountered but I'll talk about
this a bit later on you can also use gdb

123
00:12:48,170 --> 00:12:55,610
for that you first need to enable DHCP
server on the device you can do this

124
00:12:55,610 --> 00:13:04,630
case you can either start the process
that you want to debug and attach the

125
00:13:04,630 --> 00:13:10,800
GDP server to the process idea of the
target or you can actually if the

126
00:13:10,800 --> 00:13:14,670
process can be started using an
executable binary you can start to

127
00:13:14,670 --> 00:13:19,870
directly using gdb server and mentioned
the port that will later be used from

128
00:13:19,870 --> 00:13:25,540
the local machine to mention the target
they all you have to do is forward the

129
00:13:25,540 --> 00:13:29,640
TCP port on the local machine on the
machine that is connected to the Android

130
00:13:29,640 --> 00:13:35,860
device restarted EB target the remote
port and continued the reason the

131
00:13:35,860 --> 00:13:42,510
process execution it's also useful if
you have the Android tree and you've

132
00:13:42,510 --> 00:13:47,000
built an image that you've actually
flashed on the device you can load the

133
00:13:47,000 --> 00:13:54,399
debugging symbols and have more
information on your debugging session if

134
00:13:54,399 --> 00:13:58,459
you have access to the source code which
is the case of Andrea generally speaking

135
00:13:58,459 --> 00:14:03,489
there are some bands that you have that
you don't have access to the source code

136
00:14:03,490 --> 00:14:09,790
like 20 what was the exact line of the
source code that produced the crash

137
00:14:09,790 --> 00:14:18,149
occurred at the time so far and the
backtrace and you identify the program

138
00:14:18,149 --> 00:14:23,290
counter value for the components that
you are debugging in the example on the

139
00:14:23,290 --> 00:14:23,890
screen

140
00:14:23,890 --> 00:14:28,149
we don't really want to see the exact
line of code from the functions from

141
00:14:28,149 --> 00:14:33,520
Lipsy would actually we want to see the
component that crashing early stage

142
00:14:33,520 --> 00:14:39,430
fright for example and that is why we
take this program come to value and pass

143
00:14:39,430 --> 00:14:46,170
it to crystalline this is the path to
the symbols from the and retreat so you

144
00:14:46,170 --> 00:14:51,560
need to build an image and i truly
flashes on a device in order to use

145
00:14:51,560 --> 00:14:53,319
address line in this way

146
00:14:53,320 --> 00:15:08,550
ok example how we applied the things
I've mentioned until now to real testing

147
00:15:08,550 --> 00:15:13,910
scenario the station right framework is
the media from working and read it has

148
00:15:13,910 --> 00:15:19,029
been highly publicized lately because of
the so-called they tried but I'm gonna

149
00:15:19,029 --> 00:15:23,450
try to to show you how to report
wrongdoing against it

150
00:15:23,450 --> 00:15:31,529
first of all a few reasons that make
audio and video attractive terrorist

151
00:15:31,529 --> 00:15:35,220
attack vectors

152
00:15:35,220 --> 00:15:41,740
the fact that audio and video are by no
means that something complex data so the

153
00:15:41,740 --> 00:15:46,170
streams are parsed by a lot of
specialized components which can result

154
00:15:46,170 --> 00:15:52,170
in a lot of memory issues memory
corruption issues then there is the fact

155
00:15:52,170 --> 00:16:00,310
that we have a large attack surface this
means that the chances of finding an

156
00:16:00,310 --> 00:16:07,469
issue that is actually destroy the world
are higher in Android and in general I

157
00:16:07,470 --> 00:16:13,440
think there is also the user perception
that media files are harmless so users a

158
00:16:13,440 --> 00:16:14,570
normal user as well

159
00:16:14,570 --> 00:16:19,330
have second thoughts when downloading or
playing media files from untrusted

160
00:16:19,330 --> 00:16:29,130
sources and also towards specifically
because it has basic model and only need

161
00:16:29,130 --> 00:16:36,689
special permissions win for example
surfing the web and downloading a media

162
00:16:36,690 --> 00:16:42,760
campaign or also there was the victor
that made the stationary bike popular

163
00:16:42,760 --> 00:16:54,230
sending the media for this is the
overview testing process in this case so

164
00:16:54,230 --> 00:17:02,510
what we need to have is a large set of
valid media files we try to force them

165
00:17:02,510 --> 00:17:06,449
so too much from them in various ways
using the to say that I mentioned in the

166
00:17:06,449 --> 00:17:11,280
beginning of the presentation but in the
same time trying to keep them structure

167
00:17:11,280 --> 00:17:18,329
we then direct them to the appropriate
decoders so for this specific case the

168
00:17:18,329 --> 00:17:22,800
target is the stage right media
framework we monitored system for

169
00:17:22,800 --> 00:17:28,139
potential issues using very similar
approach the one that I've mentioned

170
00:17:28,140 --> 00:17:36,080
earlier and then because it is the case
the project gave a lot of crisis lot of

171
00:17:36,080 --> 00:17:39,889
results we passed the results from the
three r's mechanism and analyze the

172
00:17:39,890 --> 00:17:45,340
issues separately

173
00:17:45,340 --> 00:17:55,939
project so this project began sometimes
in March 2014 we looked and so try to

174
00:17:55,940 --> 00:18:03,360
figure out how to actually pass the
invalid media files to our target and

175
00:18:03,360 --> 00:18:08,879
the first solutions were passing the
media files to different player

176
00:18:08,880 --> 00:18:15,150
applications from Android or trying to
use the G Java API however the best

177
00:18:15,150 --> 00:18:19,630
solution we came up with was the state
right command line interface that can be

178
00:18:19,630 --> 00:18:25,800
optionally built from beyond retreat
into and then pushed onto an Android

179
00:18:25,800 --> 00:18:31,430
device this had the main advantage that
it bypassed the general air so we had

180
00:18:31,430 --> 00:18:36,630
access directly to the native kohler of
the states right now from work and that

181
00:18:36,630 --> 00:18:43,580
is actually where all the crashes occur
all the issues appear this is an example

182
00:18:43,580 --> 00:18:50,439
of the uses of this by ensuring it has
the main functionality of the coding

183
00:18:50,440 --> 00:18:57,120
audio and video files also for
audiophiles it can offer playback

184
00:18:57,120 --> 00:19:02,979
capabilities there is the advantages so
that you can try to force the uses Java

185
00:19:02,980 --> 00:19:07,710
software codec and hard work over there
so we had two tests in both scenarios

186
00:19:07,710 --> 00:19:14,130
and also the possibility of extracting
the family of four the mediafire this is

187
00:19:14,130 --> 00:19:22,360
also a place where crisis cannot go when
parsing the image associated with this

188
00:19:22,360 --> 00:19:26,540
is an example of an actual that is
constructed using the approach of

189
00:19:26,540 --> 00:19:33,770
mentioned earlier for this specific
example the files were my phone using

190
00:19:33,770 --> 00:19:37,770
the basic funding framework which is I
said is based on a modified version of

191
00:19:37,770 --> 00:19:45,200
Zeus so each time we do what we do is we
have the initial valid media files we

192
00:19:45,200 --> 00:19:49,640
face them locally so not only devices on
performance issues and then for each

193
00:19:49,640 --> 00:19:54,300
first five we send it to the device will
push it onto the device and try to be

194
00:19:54,300 --> 00:19:57,710
coded busing it as a parameter to the
stage fright minor

195
00:19:57,710 --> 00:20:06,340
this time we do this we also assert that
message with the song this case this is

196
00:20:06,340 --> 00:20:11,750
simple we have the funding of the media
file that is also saved locally on our

197
00:20:11,750 --> 00:20:17,899
computer when an actual segmentation
fault appears we all know that this file

198
00:20:17,899 --> 00:20:22,149
is responsible for this crash and it
will be easy to reproduce it because we

199
00:20:22,149 --> 00:20:30,789
have the final say these are strong
results so the project as I said earlier

200
00:20:30,789 --> 00:20:33,539
began in March 2014

201
00:20:33,539 --> 00:20:41,230
this was a time when we first reported
the first issues to google the initial

202
00:20:41,230 --> 00:20:45,850
results so during the first week on a
classroom devices that was composed of

203
00:20:45,850 --> 00:20:50,949
less than 20 device Android devices had
thousands and thousands of crashes and

204
00:20:50,950 --> 00:20:54,640
that's why we had to come out with
automated trust mechanism to sort out

205
00:20:54,640 --> 00:21:02,669
the issues the first serious issues that
affected the stage fright library were

206
00:21:02,669 --> 00:21:08,279
included in the Android partners
security bulletins from September 2014

207
00:21:08,279 --> 00:21:14,120
these were the girl flows are similar to
the issues that are coming on as a

208
00:21:14,120 --> 00:21:21,250
statewide bug they have the CD ideas
from the screen the tool is now open

209
00:21:21,250 --> 00:21:26,169
sourced it has been open source in
February 2015 it's available on github

210
00:21:26,169 --> 00:21:33,200
we don't actually use it anymore as it
is to use it as a complementary solution

211
00:21:33,200 --> 00:21:36,390
alongside with FL I'll be talking about
this

212
00:21:36,390 --> 00:21:38,500
towards the end of the session

213
00:21:38,500 --> 00:21:45,460
I will move on towards the next project
example which is facing the Android

214
00:21:45,460 --> 00:21:52,590
application install process this is an
interesting project from a few

215
00:21:52,590 --> 00:21:58,830
perspectives first there's the fact that
the component that handles the install

216
00:21:58,830 --> 00:22:02,060
process in and read more specifically
during stalled amok

217
00:22:02,060 --> 00:22:08,399
runs with high system privileges so any
issue that is found and is found to be

218
00:22:08,400 --> 00:22:18,690
exploitable can be considered to be a
high-profile issue then having an EPK so

219
00:22:18,690 --> 00:22:23,840
any PK's the file that we used to
install an application on the device

220
00:22:23,840 --> 00:22:28,860
then it begins the file it contains the
job of the composer of a cold and native

221
00:22:28,860 --> 00:22:34,290
libraries it's one of the few ways in
which an unprivileged user can sending

222
00:22:34,290 --> 00:22:35,780
put towards

223
00:22:35,780 --> 00:22:40,090
system components tour's previous
components and Android and also there is

224
00:22:40,090 --> 00:22:47,230
the fact that there are regularly found
by fostering are not usually found by

225
00:22:47,230 --> 00:22:52,960
regular evaluations so are not found by
chicks that are done for example before

226
00:22:52,960 --> 00:23:03,000
the applications are uploaded into the
Play Store we identified two approaches

227
00:23:03,000 --> 00:23:09,180
to testing approaches one specific to
Android versions before lollipop because

228
00:23:09,180 --> 00:23:17,060
of the dog carts which so we 400
lollipop we had done virtual machine

229
00:23:17,060 --> 00:23:24,760
after death or lollipop and marshmallow
we have the Android runtime art the

230
00:23:24,760 --> 00:23:28,860
steps that are taking during the regular
install process in android

231
00:23:28,860 --> 00:23:33,889
we've seen that there are two components
for each of the

232
00:23:33,890 --> 00:23:38,180
Android versions that are interesting
from my perspective in the case of

233
00:23:38,180 --> 00:23:43,470
lollipop and art it was dismemberment
next to vote and in the case of get GATT

234
00:23:43,470 --> 00:23:52,470
and other previous versions and it was
this component they sought takes text

235
00:23:52,470 --> 00:24:00,930
file as a parameter and converts it to
10 85 which is actually regular is then

236
00:24:00,930 --> 00:24:07,410
used to open the application it's the
files stored on the device and its use

237
00:24:07,410 --> 00:24:15,800
to to play the application uses
different file format so it can receive

238
00:24:15,800 --> 00:24:20,870
text file into an optimized text which
is then stored on the device so these

239
00:24:20,870 --> 00:24:27,199
are our main targets the next vote and
accept the thing is that they installed

240
00:24:27,200 --> 00:24:31,470
the month which is the company that runs
with high system privileges for us this

241
00:24:31,470 --> 00:24:36,240
pro processes without dropping
privileges so these are in turn

242
00:24:36,240 --> 00:24:47,200
privilege components they would this
would be general testing flow we need to

243
00:24:47,200 --> 00:24:59,640
have initial set of APK files from apk
files what we do is we take each apk and

244
00:24:59,640 --> 00:25:06,380
we extracted components in this is
basically operation because the PK's

245
00:25:06,380 --> 00:25:13,750
generally speaking just enough I'll then
we was the apk components that are of

246
00:25:13,750 --> 00:25:19,370
interest to us and then in the case of
dog be coming to repair kit SDK and send

247
00:25:19,370 --> 00:25:24,489
it to me and install process in the case
of art the things are more simpler we

248
00:25:24,490 --> 00:25:28,890
can actually are you know she passed
different components directly to the X

249
00:25:28,890 --> 00:25:34,260
200 see about that

250
00:25:34,260 --> 00:25:43,540
components of an apk things that are of
interest to us our classes point X

251
00:25:43,540 --> 00:25:49,830
because this is the fact that we will
actually be facing an alternative

252
00:25:49,830 --> 00:25:53,850
funding target could be the enduring
manifest XML but this is not in the

253
00:25:53,850 --> 00:26:00,889
scope of this project directory contains
the signing information for the apk so

254
00:26:00,890 --> 00:26:06,130
for example if you have an apk and we
start modified things around it the

255
00:26:06,130 --> 00:26:11,410
manifest file the textile and then we
repackage it and try to install it on a

256
00:26:11,410 --> 00:26:17,540
device that won't be possible because
the signing information won't match so

257
00:26:17,540 --> 00:26:23,860
after we modify anything in particular
point decline to reinstall that

258
00:26:23,860 --> 00:26:37,919
application to re-sign it this is the
approach on Android Kit Kat on Dec sup

259
00:26:37,920 --> 00:26:43,530
the thing is that although the next up
is a standalone binary in the Android

260
00:26:43,530 --> 00:26:48,700
device so you can see it in the end of
advice you can pass their other

261
00:26:48,700 --> 00:26:52,890
parameters to pass to it and these can
be obtained from Ursa like environment

262
00:26:52,890 --> 00:26:58,450
so what the solution that we came up
with was to actually simulate the entire

263
00:26:58,450 --> 00:27:09,220
apk install process and for that so we
takin apk we we far as the extracted the

264
00:27:09,220 --> 00:27:15,090
file for the moment let's say we found
it now explain later exactly how we do

265
00:27:15,090 --> 00:27:20,419
this because it's important we remove
the original text from the initial apk

266
00:27:20,420 --> 00:27:28,710
using the apt to we were packaged deal
became known as the new first text this

267
00:27:28,710 --> 00:27:37,060
is not also between we need to create
restore so we can actually signed that

268
00:27:37,060 --> 00:27:39,210
apk we knew that would

269
00:27:39,210 --> 00:27:46,289
the key to we remove the old or outdated
meetings directory and then we signed

270
00:27:46,289 --> 00:27:50,590
the petition that all we have to do is
just run adb install and try to install

271
00:27:50,590 --> 00:27:58,189
the apk excerpt will actually be
responsible for parsing the corrupt text

272
00:27:58,190 --> 00:28:03,149
file and any issues that will occur
generally occur in to this component

273
00:28:03,149 --> 00:28:09,250
thing to do except this is an example of
a log that is constructed using the

274
00:28:09,250 --> 00:28:15,500
following approach mentioned earlier for
this scenario you've used the word

275
00:28:15,500 --> 00:28:21,020
answer to so we need to have in each
message that is inserted into local

276
00:28:21,020 --> 00:28:27,440
buffer is the name of the apk the name
of the initial valid apk and the scene

277
00:28:27,440 --> 00:28:36,730
that we have used to fund the next lap
now we don't actually saved each apk we

278
00:28:36,730 --> 00:28:44,149
just have a safe place when we encounter
people sing like this one assimilation

279
00:28:44,149 --> 00:28:51,600
for all we have to do is take the valid
apk and passage for the process I

280
00:28:51,600 --> 00:28:58,178
mentioned in the previous two slides and
the first step we can use or dams are

281
00:28:58,179 --> 00:29:04,580
too was a text file with the seed and
this should give us the exactly became

282
00:29:04,580 --> 00:29:13,210
that produced the crash in the case of
texts wrote the things are remote

283
00:29:13,210 --> 00:29:19,159
simpler because also there is a
standalone by on the Android device show

284
00:29:19,159 --> 00:29:26,950
you can pass takes out of it and the
father is the output so all you have to

285
00:29:26,950 --> 00:29:32,000
do is just 16 2002 minus minus text file
and the textile you want to pass it in

286
00:29:32,000 --> 00:29:40,940
my notes Minnesota in funding for for
the output this is the log example for

287
00:29:40,940 --> 00:29:42,200
this case

288
00:29:42,200 --> 00:29:49,350
we have named directly the name of the
decks because in the case of the next

289
00:29:49,350 --> 00:29:56,010
time we don't bring the apk so what we
do is we have the initial pool of APK

290
00:29:56,010 --> 00:30:03,170
files and we extract the initial
textiles however if we do encounter

291
00:30:03,170 --> 00:30:13,510
something like this one we take during
shows XRD and visit with redemption in

292
00:30:13,510 --> 00:30:21,040
the seed if if next world crashes so we
have a question that we actually also

293
00:30:21,040 --> 00:30:26,570
try to reproduce the crash in a normal
user scenario we try to me to the next

294
00:30:26,570 --> 00:30:32,700
file into the original apk and try to
produce the crash when using this area

295
00:30:32,700 --> 00:30:38,980
also so for example we show on before
you wouldn't want to include appeal

296
00:30:38,980 --> 00:30:43,310
seeing a report will include a text file
but also the apk file that would produce

297
00:30:43,310 --> 00:30:48,780
the crash it would be the same crash but
with two different attack because they

298
00:30:48,780 --> 00:30:58,080
see as I said earlier the actual funding
of the textile is a little bit tricky

299
00:30:58,080 --> 00:31:03,730
we've identified freeways of performing
the first the fighting against the

300
00:31:03,730 --> 00:31:08,450
textiles the thing is that the Android
OS employees a large number of

301
00:31:08,450 --> 00:31:12,280
registrations at install time against
the textile to check if it's actually

302
00:31:12,280 --> 00:31:18,639
valid so we've identified these free
alternatives I'm gonna go through each

303
00:31:18,640 --> 00:31:27,940
one of them the first one is so these
are examples of those verifications

304
00:31:27,940 --> 00:31:34,060
verification errors so we do have
exposed and start modifying things

305
00:31:34,060 --> 00:31:35,370
through it

306
00:31:35,370 --> 00:31:40,479
these are two types of errors that
encounter for example but file size but

307
00:31:40,480 --> 00:31:44,290
took some other thing is we don't want
these

308
00:31:44,290 --> 00:31:50,020
areas to appear because it means that
the system didn't actually parse input

309
00:31:50,020 --> 00:31:57,180
he just stopped in the header in so that
things aren't alright and there there

310
00:31:57,180 --> 00:32:00,770
isn't a way actually to produce a crash
in this scenario so what we want to do

311
00:32:00,770 --> 00:32:08,180
is to treat the system to believing that
the trial is actually valid for this we

312
00:32:08,180 --> 00:32:15,340
need to understand the text file format
I'm not going to go into detail and

313
00:32:15,340 --> 00:32:21,020
there are few important sections first
there is the header that contains

314
00:32:21,020 --> 00:32:22,960
general information about the file

315
00:32:22,960 --> 00:32:30,440
things like header size file size six
arms magic numbers and you but also

316
00:32:30,440 --> 00:32:37,160
specific information about the section 6
offered to buy this photo ID's header

317
00:32:37,160 --> 00:32:42,680
will contain two fields of set for that
section and the size for that section

318
00:32:42,680 --> 00:32:50,710
fields contain the actual content from
the compile Java code from the from the

319
00:32:50,710 --> 00:32:56,380
compile Java code and also there is
optional field the map that contains

320
00:32:56,380 --> 00:33:01,730
information regarding the officers and
the type of content that is inside each

321
00:33:01,730 --> 00:33:06,480
section

322
00:33:06,480 --> 00:33:16,580
so the first start firing randomly the
file and then come back and try to

323
00:33:16,580 --> 00:33:23,030
repair as much as possible in this case
what we can repair is the magic number

324
00:33:23,030 --> 00:33:29,270
which is a constant the checksum because
we can recalculate the checksum for the

325
00:33:29,270 --> 00:33:34,520
resulting file after the fighting has
been done this is also the case of the

326
00:33:34,520 --> 00:33:41,260
show on signature in the file size these
can both we computed the head of size

327
00:33:41,260 --> 00:33:48,110
and then you are constant values and if
by any chance we modified it during the

328
00:33:48,110 --> 00:33:59,389
round of funding process we we come back
and correct values is a more targeted

329
00:33:59,390 --> 00:34:03,990
one because the data section contains
the more the most interesting

330
00:34:03,990 --> 00:34:10,629
information like strings and variables
we only does this section so what we do

331
00:34:10,629 --> 00:34:17,830
with the initial text file with split
entry we have the first part with the

332
00:34:17,830 --> 00:34:23,889
header and all the sections we had the
second part in how the third part the

333
00:34:23,889 --> 00:34:32,109
map we found was only the data randomly
using renounce up and then we blew

334
00:34:32,109 --> 00:34:38,219
chunks back together and we come back to
the header and tried to fix is not just

335
00:34:38,219 --> 00:34:44,368
possible we started the fields from the
head there that we've fixed as in the

336
00:34:44,369 --> 00:34:50,350
previous approach we can also take a
look at the map upset so for example if

337
00:34:50,350 --> 00:34:56,449
we withdrew funds the data and it grew
in size the opposite of the map will

338
00:34:56,449 --> 00:35:02,450
change and this this field can be
computed we have information we can

339
00:35:02,450 --> 00:35:10,470
actually calculate how big is the fuzz
datafile and also that a precise

340
00:35:10,470 --> 00:35:19,140
these this is actually the approach that
gave the most promising results so most

341
00:35:19,140 --> 00:35:25,609
crashes in the most interesting ones
there's also this approach which is a

342
00:35:25,609 --> 00:35:31,150
completely now fighting method we just
take initial valid textiles and we

343
00:35:31,150 --> 00:35:35,780
passed them food the basic funding
framework we don't look at the head of

344
00:35:35,780 --> 00:35:41,630
it all and then just pass but it back to
the next owned by honoring this would be

345
00:35:41,630 --> 00:35:51,080
an example of log in this case for this
scenario we save all the text files that

346
00:35:51,080 --> 00:35:56,069
are being generated and if actual
segmentation fault occurs or other

347
00:35:56,070 --> 00:36:06,849
freedom single we will have that the X
files saved on local machine results so

348
00:36:06,849 --> 00:36:11,570
the number of crashes wasn't as
spectacular as in the case of stage

349
00:36:11,570 --> 00:36:19,640
fright but in the initial phases of the
project we had about 1,000 crashes not

350
00:36:19,640 --> 00:36:26,940
unique per week on a cluster of thirty
to forty Android devices there is a

351
00:36:26,940 --> 00:36:32,589
critical issue that occurred using the
targeted funding approach we've reported

352
00:36:32,589 --> 00:36:43,740
it to Google and the TV assigned in 2014
November 2014 there are also a lot of

353
00:36:43,740 --> 00:36:48,259
low priority issues that were reported
both in jet and lollipop

354
00:36:48,260 --> 00:36:53,089
but these were not considered to be
exploitable there are the project is

355
00:36:53,089 --> 00:37:03,810
still under development so we have a lot
of issues that are under investigation

356
00:37:03,810 --> 00:37:13,220
to speak a little bit about an
alternative approach that uses the very

357
00:37:13,220 --> 00:37:20,310
popular American Plaza look to a few
words about the tool in general it's an

358
00:37:20,310 --> 00:37:24,970
instrumentation based funding to
Universe 2000 modes the normal and

359
00:37:24,970 --> 00:37:29,540
instrumental mode it also has a third
let's see more though the Peruvian

360
00:37:29,540 --> 00:37:36,110
rabbit note that you know you can feed
crashes to try to get new crashes from

361
00:37:36,110 --> 00:37:43,730
crisis that already occurred its main
advantage is the fact that detects

362
00:37:43,730 --> 00:37:49,930
changes to the program control show and
confine your pets and finding

363
00:37:49,930 --> 00:37:56,890
interesting this cases that can be sent
to the target it's pretty much automated

364
00:37:56,890 --> 00:38:04,190
he detects both crashes and hangs it
tries to do best effort to sort out the

365
00:38:04,190 --> 00:38:14,810
issues I used a modified version of the
two version that was developed by my

366
00:38:14,810 --> 00:38:20,990
colleague Adrian he developed a report
for the tool for Android its public

367
00:38:20,990 --> 00:38:30,330
available now it's on the mailing list
from the AFL to this is how we used to

368
00:38:30,330 --> 00:38:32,779
france stage fright

369
00:38:32,780 --> 00:38:38,990
if you've ever worked with fell to know
that there are few prerequisites before

370
00:38:38,990 --> 00:38:43,640
actually starting the tool in the case
of Android what we need to have on the

371
00:38:43,640 --> 00:38:53,859
device is fruit mounted device these the
route and remount are less serious so we

372
00:38:53,860 --> 00:39:01,590
can push the AFL testing binary and also
the target by for example in the case of

373
00:39:01,590 --> 00:39:06,820
stage fright because the binaries
doesn't come

374
00:39:06,820 --> 00:39:11,070
building to the default and retreat
money to build our own buying and then

375
00:39:11,070 --> 00:39:17,540
pushed on the device so we want to push
down in system being new to have the

376
00:39:17,540 --> 00:39:25,850
device mounted also you want to load
angel seeds things'll valid media files

377
00:39:25,850 --> 00:39:33,060
and a prerequisite that the specific to
film is released to said the scaling

378
00:39:33,060 --> 00:39:40,340
government governor to perform to
performance thing is if the initial

379
00:39:40,340 --> 00:39:47,220
media files contain important that
generates across from the beginning the

380
00:39:47,220 --> 00:39:54,799
DFL to real rejected so if you want to
automate this we need to make sure that

381
00:39:54,800 --> 00:40:00,000
the show scenes that we load onto the
devices do not contain inputs that

382
00:40:00,000 --> 00:40:05,090
producer crash when we are working with
the classroom let's say then some

383
00:40:05,090 --> 00:40:11,630
devices we need to figure out a way to
to do this in an automated manner so

384
00:40:11,630 --> 00:40:20,990
what we tried was we start the fell too
with a timeout and check if it finds a

385
00:40:20,990 --> 00:40:27,799
crash that produced the producers crash
and if it does wait until the time out

386
00:40:27,800 --> 00:40:36,330
dance and restarted again so we have a
loop with a four-run with a timeout when

387
00:40:36,330 --> 00:40:41,870
it gets rid of old test cases that
produced the crash will then go and

388
00:40:41,870 --> 00:40:46,650
start their film normally and redirected
so pretty

389
00:40:46,650 --> 00:40:54,619
results reporting format to definitely
let's say so can we can run it

390
00:40:54,619 --> 00:41:00,619
automated manner

391
00:41:00,619 --> 00:41:10,789
diagram that shows how we've integrated
the custom funding to help so we have

392
00:41:10,789 --> 00:41:17,079
the initial phase the sea generation
were we generate valid first media files

393
00:41:17,079 --> 00:41:25,740
we load the seeds onto the devices were
we start using the the process that I've

394
00:41:25,740 --> 00:41:33,069
mentioned in the previous slide we run
FL 24 period of time usually two or

395
00:41:33,069 --> 00:41:39,589
three days then we get the crashes and
hangs the thing is that on each device

396
00:41:39,589 --> 00:41:45,220
after we report an issue as being unique
but another device will also report an

397
00:41:45,220 --> 00:41:51,740
issue is being unique although the
issues aren't unique for the general

398
00:41:51,740 --> 00:41:59,609
target that is why we need to pass the
crisis the results that if I'll give us

399
00:41:59,609 --> 00:42:10,480
food for custom based closer we pass it
then we generate the logs I mentioned

400
00:42:10,480 --> 00:42:18,739
earlier and from there we have the logs
that are parsed and passed through the

401
00:42:18,739 --> 00:42:23,309
trash mechanism where we actually get
the real issues there's also another

402
00:42:23,309 --> 00:42:30,720
reason why we need to the media files
food our customs officer is the fact

403
00:42:30,720 --> 00:42:35,910
that the media files running on a
restricted environment in FL so you can

404
00:42:35,910 --> 00:42:42,430
see for example you have to set the
memory limit and the time oh we're in

405
00:42:42,430 --> 00:42:50,739
the case of our Father the media files
run more closely to normal use the

406
00:42:50,739 --> 00:42:55,799
scenario so some questions that are
reported to have may not actually

407
00:42:55,799 --> 00:43:02,150
reproduce in normal user scenario

408
00:43:02,150 --> 00:43:09,270
some results using this approach the
most notable was a heap corruption that

409
00:43:09,270 --> 00:43:14,200
could lead to arbitrary code execution
using the media server process this was

410
00:43:14,200 --> 00:43:20,950
discovered this summer it was included
in the Nexus security bulletins from

411
00:43:20,950 --> 00:43:27,149
August 2015 there are also a lot of
protein issues things like more pointed

412
00:43:27,150 --> 00:43:40,470
references or division by zero stuff and
a few conclusions

413
00:43:40,470 --> 00:43:47,689
first of all rounder environment is a
little bit trickier than normal Linux

414
00:43:47,690 --> 00:43:53,789
environment also stage fright is not
really a bug was more like a library

415
00:43:53,789 --> 00:44:00,619
that has a lot to lot of issues and it's
really important know the internals of

416
00:44:00,619 --> 00:44:04,950
the compound that you are targeting so
you can actually have better results

417
00:44:04,950 --> 00:44:10,129
there is also the case when you perform
downsizing and get lucky that's also

418
00:44:10,130 --> 00:44:15,089
building that's about it

419
00:44:15,089 --> 00:44:21,650
these are other people that contributed
to these projects Adrian developed and

420
00:44:21,650 --> 00:44:27,859
report for AFL Costa Marc seem also have
a lot of the incoming port for the

421
00:44:27,859 --> 00:44:34,098
projects of us supported the development
of these projects and also if you have

422
00:44:34,099 --> 00:44:34,660
questions

