1
00:00:00,860 --> 00:00:09,840
[Music]

2
00:00:09,840 --> 00:00:13,120
hello everyone my name is jonghyun lin i

3
00:00:13,120 --> 00:00:16,079
am a phd student from penn state my

4
00:00:16,079 --> 00:00:18,560
research focuses on exploitation and

5
00:00:18,560 --> 00:00:20,880
defense on complex software

6
00:00:20,880 --> 00:00:22,480
today i'm going to talk about

7
00:00:22,480 --> 00:00:24,560
exploitation in linux kernel

8
00:00:24,560 --> 00:00:27,359
specifically how it turns unexploitable

9
00:00:27,359 --> 00:00:29,679
box into explorable ones

10
00:00:29,679 --> 00:00:32,238
and how we utilize the same method to

11
00:00:32,238 --> 00:00:35,680
find the exploit primitive automatically

12
00:00:35,680 --> 00:00:37,600
we will demonstrate this on the

13
00:00:37,600 --> 00:00:39,840
exploitation of a real world kernel bug

14
00:00:39,840 --> 00:00:41,840
in centaurus kernel

15
00:00:41,840 --> 00:00:44,719
this work is done with the help of my

16
00:00:44,719 --> 00:00:47,520
collaborator uh turn my advisor sir

17
00:00:47,520 --> 00:00:50,559
using who are from penn state as well

18
00:00:50,559 --> 00:00:53,039
and my mentor currently from i do

19
00:00:53,039 --> 00:00:56,000
research usa

20
00:00:57,120 --> 00:00:59,760
i'm going to start with a bug example

21
00:00:59,760 --> 00:01:01,920
that shows different memory corruption

22
00:01:01,920 --> 00:01:03,760
in two kernel sites

23
00:01:03,760 --> 00:01:06,240
and then i will introduce the definition

24
00:01:06,240 --> 00:01:09,360
of multiple arrow behavior of bugs

25
00:01:09,360 --> 00:01:11,280
after this i will talk about a new

26
00:01:11,280 --> 00:01:14,240
approach to turning unexploitable

27
00:01:14,240 --> 00:01:18,080
trash bags between two exploitable ones

28
00:01:18,080 --> 00:01:21,280
with this approach i will show how an

29
00:01:21,280 --> 00:01:24,320
ignored trash bag in central's kernel

30
00:01:24,320 --> 00:01:26,159
was successfully turned into an

31
00:01:26,159 --> 00:01:27,600
exploitable one

32
00:01:27,600 --> 00:01:29,840
which in reality has powerful memory

33
00:01:29,840 --> 00:01:31,759
corruption abilities like

34
00:01:31,759 --> 00:01:34,320
leaking kernel data and hijacking kernel

35
00:01:34,320 --> 00:01:35,840
control flow

36
00:01:35,840 --> 00:01:38,640
and finally i will talk about the

37
00:01:38,640 --> 00:01:40,960
implication of multiple behavior to

38
00:01:40,960 --> 00:01:43,839
kernel security

39
00:01:45,119 --> 00:01:48,079
before moving to the example of bug i

40
00:01:48,079 --> 00:01:50,399
would like to discuss what it means in

41
00:01:50,399 --> 00:01:55,280
terms of unexploitable in this talk

42
00:01:55,280 --> 00:01:58,000
in general an unexploitable back is a

43
00:01:58,000 --> 00:02:00,880
bug that is likely to exploit

44
00:02:00,880 --> 00:02:03,759
to exploit the back we usually start

45
00:02:03,759 --> 00:02:05,520
from an arrow

46
00:02:05,520 --> 00:02:07,680
the arrow allows you to create another

47
00:02:07,680 --> 00:02:08,720
arrow

48
00:02:08,720 --> 00:02:10,239
eventually

49
00:02:10,239 --> 00:02:12,480
you achieve your goal from an arrow you

50
00:02:12,480 --> 00:02:13,680
created

51
00:02:13,680 --> 00:02:16,239
for example you want to hijack kernel

52
00:02:16,239 --> 00:02:18,800
execution you start from a memory

53
00:02:18,800 --> 00:02:20,400
overflow arrow

54
00:02:20,400 --> 00:02:22,560
then you utilize the overflow to

55
00:02:22,560 --> 00:02:25,360
override function pointer

56
00:02:25,360 --> 00:02:27,599
which results in another arrow and this

57
00:02:27,599 --> 00:02:29,599
provides you the kernel execution

58
00:02:29,599 --> 00:02:32,238
hijacking

59
00:02:32,640 --> 00:02:35,440
when we say unexploitable we basically

60
00:02:35,440 --> 00:02:38,319
mean that the arrow we found is not able

61
00:02:38,319 --> 00:02:40,879
to propagate to other arrows that will

62
00:02:40,879 --> 00:02:43,680
lead to our exploitation goal

63
00:02:43,680 --> 00:02:47,519
the difficulty of propagating arrows

64
00:02:47,519 --> 00:02:48,800
is one

65
00:02:48,800 --> 00:02:51,440
is com comes is from the block of

66
00:02:51,440 --> 00:02:54,000
mitigation and the limitation of

67
00:02:54,000 --> 00:02:55,519
original errors

68
00:02:55,519 --> 00:02:57,440
for example making memory at zero

69
00:02:57,440 --> 00:02:59,920
address is not allowed in this kernel

70
00:02:59,920 --> 00:03:02,000
which blocks the propagation of a num

71
00:03:02,000 --> 00:03:04,720
point of the reference error accessing

72
00:03:04,720 --> 00:03:06,800
memory address not in page table is not

73
00:03:06,800 --> 00:03:08,959
allowed as well

74
00:03:08,959 --> 00:03:11,840
so arrows like general protection faults

75
00:03:11,840 --> 00:03:13,519
and non-pointed derivance cannot

76
00:03:13,519 --> 00:03:16,080
propagate

77
00:03:16,640 --> 00:03:18,720
sometimes the arrow doesn't have memory

78
00:03:18,720 --> 00:03:21,760
corruption ability like warning bygone

79
00:03:21,760 --> 00:03:22,879
arrow

80
00:03:22,879 --> 00:03:25,360
these are kernel debugging features they

81
00:03:25,360 --> 00:03:27,519
will generate a warning message without

82
00:03:27,519 --> 00:03:30,080
corrupting kernel state so it cannot

83
00:03:30,080 --> 00:03:33,840
propagate as well

84
00:03:34,640 --> 00:03:36,560
compared to other arrows they will

85
00:03:36,560 --> 00:03:38,640
demonstrate severe memory corrupting

86
00:03:38,640 --> 00:03:39,920
ability

87
00:03:39,920 --> 00:03:42,400
less likely to exploit arrows get less

88
00:03:42,400 --> 00:03:45,200
attention from the community

89
00:03:45,200 --> 00:03:48,319
here is the statistic from historical

90
00:03:48,319 --> 00:03:50,159
kernel cves

91
00:03:50,159 --> 00:03:53,680
the uf auto bond double free arrows make

92
00:03:53,680 --> 00:03:56,239
up the larger portion of cves

93
00:03:56,239 --> 00:03:59,120
the second largest one is arrows

94
00:03:59,120 --> 00:04:01,360
with limited memory corruption abilities

95
00:04:01,360 --> 00:04:03,760
like general protection fault

96
00:04:03,760 --> 00:04:08,000
and 9.0 reference which account for 31

97
00:04:08,000 --> 00:04:10,080
of cves

98
00:04:10,080 --> 00:04:12,159
arrows without memory corruption only

99
00:04:12,159 --> 00:04:15,840
make up one percent savings

100
00:04:15,840 --> 00:04:18,399
other than smaller portion the cvss

101
00:04:18,399 --> 00:04:20,959
score for this type of airbag

102
00:04:20,959 --> 00:04:24,079
is lower as well

103
00:04:24,639 --> 00:04:27,600
the average services score for uf auto

104
00:04:27,600 --> 00:04:31,600
bond double three arrows is 6.17

105
00:04:31,600 --> 00:04:33,440
while the average score for general

106
00:04:33,440 --> 00:04:37,080
protection fault 9.3 reference is

107
00:04:37,080 --> 00:04:38,639
5.48

108
00:04:38,639 --> 00:04:43,160
and the nets for warning is 3.75

109
00:04:44,320 --> 00:04:47,040
so they get less attention when we see

110
00:04:47,040 --> 00:04:50,479
an arrow like warning or 9.3 reference

111
00:04:50,479 --> 00:04:53,040
we may think they are unexploitable in

112
00:04:53,040 --> 00:04:55,840
other words they are trash bags because

113
00:04:55,840 --> 00:04:57,600
their memory corruption ability is

114
00:04:57,600 --> 00:04:58,880
limited

115
00:04:58,880 --> 00:05:01,440
but most exploitation requires memory

116
00:05:01,440 --> 00:05:04,000
corruption

117
00:05:05,840 --> 00:05:07,039
however

118
00:05:07,039 --> 00:05:09,520
this may not always be true

119
00:05:09,520 --> 00:05:12,000
this is a real kernel back being fixed

120
00:05:12,000 --> 00:05:14,160
in absolutely silently

121
00:05:14,160 --> 00:05:17,280
here are some code snippets of the block

122
00:05:17,280 --> 00:05:19,280
there are three functions contributing

123
00:05:19,280 --> 00:05:21,360
to the arrow let's go through it one by

124
00:05:21,360 --> 00:05:24,320
one

125
00:05:24,320 --> 00:05:26,479
the first one is the time attach

126
00:05:26,479 --> 00:05:27,759
function

127
00:05:27,759 --> 00:05:30,080
the time flag here is controlled by

128
00:05:30,080 --> 00:05:31,120
users

129
00:05:31,120 --> 00:05:32,560
in this function

130
00:05:32,560 --> 00:05:35,759
if the young api flag is enabled which

131
00:05:35,759 --> 00:05:36,720
means

132
00:05:36,720 --> 00:05:39,120
if condition is satisfied it will

133
00:05:39,120 --> 00:05:42,000
initialize a timer and link current api

134
00:05:42,000 --> 00:05:44,080
to the list of the device

135
00:05:44,080 --> 00:05:46,880
otherwise there will be no timer and

136
00:05:46,880 --> 00:05:49,039
kernel api will not be linked into the

137
00:05:49,039 --> 00:05:52,039
device

138
00:05:52,720 --> 00:05:54,639
the second function we need to look at

139
00:05:54,639 --> 00:05:56,720
is the time detach function

140
00:05:56,720 --> 00:06:00,080
these two are pair attach and detach

141
00:06:00,080 --> 00:06:03,440
here if the api flag is enabled

142
00:06:03,440 --> 00:06:06,319
it will cancel the timer from the api

143
00:06:06,319 --> 00:06:07,360
object

144
00:06:07,360 --> 00:06:10,319
and remove the api from the list

145
00:06:10,319 --> 00:06:12,800
otherwise the kernel thinks the api

146
00:06:12,800 --> 00:06:14,800
functionality is not enabled and it will

147
00:06:14,800 --> 00:06:16,560
not cancel the timer

148
00:06:16,560 --> 00:06:18,880
and we will not delete

149
00:06:18,880 --> 00:06:20,560
the linked list

150
00:06:20,560 --> 00:06:23,440
but eventually it will destroy the file

151
00:06:23,440 --> 00:06:26,080
which will free the memory of the api

152
00:06:26,080 --> 00:06:28,479
object

153
00:06:29,759 --> 00:06:32,240
the last one is the function to free the

154
00:06:32,240 --> 00:06:33,280
device

155
00:06:33,280 --> 00:06:35,759
when it's called it will go through the

156
00:06:35,759 --> 00:06:38,479
api list and see which one is still in

157
00:06:38,479 --> 00:06:42,560
the list and destroy them one by one

158
00:06:45,039 --> 00:06:47,360
now let's look at how the bug will

159
00:06:47,360 --> 00:06:49,840
happen

160
00:06:50,880 --> 00:06:53,120
since the time flag is controlled by

161
00:06:53,120 --> 00:06:56,240
users users can specify inconsistent

162
00:06:56,240 --> 00:06:58,240
flags between the tongue attached and

163
00:06:58,240 --> 00:07:00,319
the time detach function

164
00:07:00,319 --> 00:07:03,680
specifically if you also disable the api

165
00:07:03,680 --> 00:07:07,440
flag intent attach function

166
00:07:07,520 --> 00:07:09,039
the timer in the

167
00:07:09,039 --> 00:07:13,919
api object will not be initialized

168
00:07:13,919 --> 00:07:16,560
and the api will be nopi will not be in

169
00:07:16,560 --> 00:07:19,039
the list

170
00:07:20,720 --> 00:07:24,560
and then the user enable the api flag

171
00:07:24,560 --> 00:07:27,599
and in a time detach

172
00:07:28,639 --> 00:07:31,840
it will cancel the timer

173
00:07:32,319 --> 00:07:35,039
and inside the timer cancel function it

174
00:07:35,039 --> 00:07:37,440
will dereference a pointer in the timer

175
00:07:37,440 --> 00:07:39,919
object

176
00:07:40,000 --> 00:07:42,800
but since the timer is not initialized

177
00:07:42,800 --> 00:07:45,360
so there will be no valid pointer in the

178
00:07:45,360 --> 00:07:46,800
timer object

179
00:07:46,800 --> 00:07:48,639
so the kernel will dereference a num

180
00:07:48,639 --> 00:07:50,960
pointer and generate a pointer

181
00:07:50,960 --> 00:07:53,840
dereference error

182
00:07:55,039 --> 00:07:57,199
a question for this is whether this

183
00:07:57,199 --> 00:08:00,560
arrow is exploitable

184
00:08:01,759 --> 00:08:04,879
the execution always leads to access of

185
00:08:04,879 --> 00:08:08,000
the timer object but the timer object is

186
00:08:08,000 --> 00:08:11,360
not initialized which is full of zero

187
00:08:11,360 --> 00:08:13,759
so it will always dereference a num

188
00:08:13,759 --> 00:08:15,599
pointer

189
00:08:15,599 --> 00:08:18,160
however mapping memory at zero address

190
00:08:18,160 --> 00:08:21,039
is not allowed in this current

191
00:08:21,039 --> 00:08:26,680
so this arrow is less likely to exploit

192
00:08:27,680 --> 00:08:30,240
the back could actually have a totally

193
00:08:30,240 --> 00:08:32,559
different arrow behavior if we trigger

194
00:08:32,559 --> 00:08:34,399
it differently

195
00:08:34,399 --> 00:08:37,919
this time we enable the api flag

196
00:08:37,919 --> 00:08:39,120
in a time

197
00:08:39,120 --> 00:08:42,320
in the time attach function

198
00:08:42,320 --> 00:08:45,040
and we will have a timer initialized and

199
00:08:45,040 --> 00:08:46,880
the current learning api will be linked

200
00:08:46,880 --> 00:08:50,120
in the list

201
00:08:54,399 --> 00:08:57,120
next we disable the api flag in the time

202
00:08:57,120 --> 00:09:00,000
detach function

203
00:09:00,240 --> 00:09:01,120
so

204
00:09:01,120 --> 00:09:04,320
the api will be still in the list but it

205
00:09:04,320 --> 00:09:06,000
will destroy it

206
00:09:06,000 --> 00:09:09,320
by the file

207
00:09:13,440 --> 00:09:16,160
next we free the device and the kernel

208
00:09:16,160 --> 00:09:18,399
will go over the api list

209
00:09:18,399 --> 00:09:23,080
and access to the navr object

210
00:09:23,279 --> 00:09:24,959
which was

211
00:09:24,959 --> 00:09:26,720
which was freed in a time detached

212
00:09:26,720 --> 00:09:29,120
function and this will result in a uf

213
00:09:29,120 --> 00:09:31,519
arrow

214
00:09:33,200 --> 00:09:35,360
the arrow becomes different how about

215
00:09:35,360 --> 00:09:37,680
the exploitability

216
00:09:37,680 --> 00:09:41,440
exploiting this uf is straightforward

217
00:09:41,440 --> 00:09:43,920
the vulnerable object is allocated in

218
00:09:43,920 --> 00:09:46,720
general case which means attackers can

219
00:09:46,720 --> 00:09:49,200
allocate another type of object in the

220
00:09:49,200 --> 00:09:51,839
same cache

221
00:09:52,080 --> 00:09:54,720
looking at the definition of the object

222
00:09:54,720 --> 00:09:59,440
it contains an escape buff object

223
00:09:59,600 --> 00:10:02,880
so when freeing the unapi struct object

224
00:10:02,880 --> 00:10:07,279
it will free the sk buff inside

225
00:10:07,839 --> 00:10:10,640
an attacker can get a control hijacking

226
00:10:10,640 --> 00:10:14,480
ability when freeing sk buff

227
00:10:14,480 --> 00:10:16,800
because the free of sk buff will

228
00:10:16,800 --> 00:10:19,200
dereference a function pointer inside

229
00:10:19,200 --> 00:10:20,640
the sk buff

230
00:10:20,640 --> 00:10:23,519
by spraying memory attacker can temper

231
00:10:23,519 --> 00:10:26,560
the sk bar pointer to a fake object

232
00:10:26,560 --> 00:10:28,079
where the function pointer can be

233
00:10:28,079 --> 00:10:29,200
controlled

234
00:10:29,200 --> 00:10:31,680
after this attacker can obtain a control

235
00:10:31,680 --> 00:10:34,959
for hijacking ability

236
00:10:35,440 --> 00:10:38,480
in this case we successfully turned the

237
00:10:38,480 --> 00:10:40,560
i exploitable crash

238
00:10:40,560 --> 00:10:44,399
to an exploitable uf for the same bug

239
00:10:44,399 --> 00:10:46,720
the uf doesn't require complicated

240
00:10:46,720 --> 00:10:49,040
exploitation methods you spread the

241
00:10:49,040 --> 00:10:51,279
memory and you will be able to hijack

242
00:10:51,279 --> 00:10:52,820
the kernel execution flow

243
00:10:52,820 --> 00:10:55,120
[Music]

244
00:10:55,120 --> 00:10:59,959
why this is possible to kernel box

245
00:11:00,399 --> 00:11:03,120
because kernel bugs are complicated

246
00:11:03,120 --> 00:11:05,279
the same bug could cause different crash

247
00:11:05,279 --> 00:11:07,519
behaviors that we call them multiple

248
00:11:07,519 --> 00:11:10,079
arrow behaviors of bugs

249
00:11:10,079 --> 00:11:12,399
when the bug is triggered differently it

250
00:11:12,399 --> 00:11:15,040
shows different arrow behaviors in this

251
00:11:15,040 --> 00:11:16,000
case

252
00:11:16,000 --> 00:11:18,880
it's different inconsistency

253
00:11:18,880 --> 00:11:20,959
of conflag between the tile attached

254
00:11:20,959 --> 00:11:22,900
function and the tiny patch function

255
00:11:22,900 --> 00:11:25,040
[Music]

256
00:11:25,040 --> 00:11:27,440
arrow behaviors demonstrate the bug

257
00:11:27,440 --> 00:11:30,320
effects which indeed is the memory

258
00:11:30,320 --> 00:11:32,320
corruption ability

259
00:11:32,320 --> 00:11:35,040
when we expose multiviral behaviors of

260
00:11:35,040 --> 00:11:37,440
bugs we will be able to figure out the

261
00:11:37,440 --> 00:11:40,160
memory corruption ability of the bug for

262
00:11:40,160 --> 00:11:43,279
example we'll be able to know the bug

263
00:11:43,279 --> 00:11:46,160
could cause a uf other than a nonpointed

264
00:11:46,160 --> 00:11:48,880
reference arrow

265
00:11:49,279 --> 00:11:51,760
different bug effects represent

266
00:11:51,760 --> 00:11:54,000
different exploit potential

267
00:11:54,000 --> 00:11:56,560
when we see a kernel always crash with

268
00:11:56,560 --> 00:11:57,519
with

269
00:11:57,519 --> 00:12:00,240
a 9.0 reference arrow the bug might be

270
00:12:00,240 --> 00:12:02,240
less likely to exploit

271
00:12:02,240 --> 00:12:03,440
however

272
00:12:03,440 --> 00:12:05,440
when we find the new inputs that will

273
00:12:05,440 --> 00:12:08,560
cause kernel to generate a uf arrow we

274
00:12:08,560 --> 00:12:11,680
might be able to to utilize the uf to do

275
00:12:11,680 --> 00:12:14,479
exploitation

276
00:12:14,880 --> 00:12:18,160
so with different bug effects exposed we

277
00:12:18,160 --> 00:12:20,880
will be able to find bug effects that is

278
00:12:20,880 --> 00:12:23,440
most likely to exploit to have a better

279
00:12:23,440 --> 00:12:25,920
estimation of exploitability

280
00:12:25,920 --> 00:12:29,040
and we probably will turn unexploitable

281
00:12:29,040 --> 00:12:31,200
bugs to exploitable ones

282
00:12:31,200 --> 00:12:34,320
but how to do this

283
00:12:34,800 --> 00:12:37,040
first of all to find the multiple error

284
00:12:37,040 --> 00:12:38,880
behaviors of bugs

285
00:12:38,880 --> 00:12:40,720
coverage based on buzzing is not

286
00:12:40,720 --> 00:12:41,839
suitable

287
00:12:41,839 --> 00:12:44,000
because we need to trigger the same bug

288
00:12:44,000 --> 00:12:46,720
differently to expose their multiplier

289
00:12:46,720 --> 00:12:47,920
behaviors

290
00:12:47,920 --> 00:12:50,160
which need to test on the same piece of

291
00:12:50,160 --> 00:12:53,120
code over and over again however

292
00:12:53,120 --> 00:12:56,000
coverage-based advisor by design will

293
00:12:56,000 --> 00:12:58,160
try to test all new code as much as

294
00:12:58,160 --> 00:12:59,519
possible

295
00:12:59,519 --> 00:13:03,360
intuitively this is contrary to our goal

296
00:13:03,360 --> 00:13:04,959
so

297
00:13:04,959 --> 00:13:07,760
we propose an object-driven kernel

298
00:13:07,760 --> 00:13:09,120
function

299
00:13:09,120 --> 00:13:11,680
the inside of our approach is to use

300
00:13:11,680 --> 00:13:13,760
kernel objects to bundle the fusing

301
00:13:13,760 --> 00:13:14,720
scope

302
00:13:14,720 --> 00:13:17,360
we use the reachability of the kernel

303
00:13:17,360 --> 00:13:19,200
objects as an additional function

304
00:13:19,200 --> 00:13:22,160
feedback this feedback allows us to

305
00:13:22,160 --> 00:13:24,399
differentiate inputs when the bug is

306
00:13:24,399 --> 00:13:27,279
triggered differently

307
00:13:27,279 --> 00:13:29,120
we implement our approach as a

308
00:13:29,120 --> 00:13:34,440
customized puzzle based on this caller

309
00:13:36,480 --> 00:13:39,519
specifically our first step is to find

310
00:13:39,519 --> 00:13:41,440
the kernel objects

311
00:13:41,440 --> 00:13:44,639
we take the crash report as input

312
00:13:44,639 --> 00:13:47,199
we start from the code where the crash

313
00:13:47,199 --> 00:13:50,240
happens then we backward analyze the dev

314
00:13:50,240 --> 00:13:53,760
use sharing of the data along the way

315
00:13:53,760 --> 00:13:55,360
we collect the type of information of

316
00:13:55,360 --> 00:13:58,079
the data flow

317
00:13:58,800 --> 00:14:01,440
here is the example of how we identified

318
00:14:01,440 --> 00:14:04,639
the object for buzzing in this case it's

319
00:14:04,639 --> 00:14:07,120
a non-pointed reference in timer active

320
00:14:07,120 --> 00:14:09,279
function

321
00:14:09,279 --> 00:14:12,000
we backward analyze and first find the

322
00:14:12,000 --> 00:14:15,040
timer structure

323
00:14:15,120 --> 00:14:17,760
then we follow the data flow and we find

324
00:14:17,760 --> 00:14:20,560
the api struct and time file structure

325
00:14:20,560 --> 00:14:24,000
in the time detach function

326
00:14:24,480 --> 00:14:27,279
with the objects on hands we then use a

327
00:14:27,279 --> 00:14:30,240
customized compiler to instrument the

328
00:14:30,240 --> 00:14:33,040
basic block which are involved with the

329
00:14:33,040 --> 00:14:35,199
operation of these objects the

330
00:14:35,199 --> 00:14:37,440
instrumented code will send object

331
00:14:37,440 --> 00:14:39,360
feedback to the fuzzer when it's

332
00:14:39,360 --> 00:14:40,720
executed

333
00:14:40,720 --> 00:14:43,680
so in addition to code coverage we also

334
00:14:43,680 --> 00:14:46,240
have object coverage as a feedback to

335
00:14:46,240 --> 00:14:47,680
buzzer

336
00:14:47,680 --> 00:14:50,639
we also have a new seed selection and a

337
00:14:50,639 --> 00:14:53,120
new input mutation approach based on the

338
00:14:53,120 --> 00:14:57,320
feedback of object

339
00:14:58,160 --> 00:15:00,240
our tool and other details will be

340
00:15:00,240 --> 00:15:03,120
released soon

341
00:15:05,040 --> 00:15:07,199
kernel objects kernel box

342
00:15:07,199 --> 00:15:09,519
have multiple arrow behaviors which

343
00:15:09,519 --> 00:15:12,560
represent different exploit potential as

344
00:15:12,560 --> 00:15:15,440
such a bug with seemingly low security

345
00:15:15,440 --> 00:15:16,560
arrow

346
00:15:16,560 --> 00:15:18,639
could have other severe arrows that

347
00:15:18,639 --> 00:15:20,560
result in exploitation

348
00:15:20,560 --> 00:15:23,760
so what does this mean

349
00:15:23,839 --> 00:15:26,000
two kernel vendors don't rely on single

350
00:15:26,000 --> 00:15:27,600
error behavior to estimate the

351
00:15:27,600 --> 00:15:29,519
exploitability of bug

352
00:15:29,519 --> 00:15:32,720
when you see a bug shows warning arrow

353
00:15:32,720 --> 00:15:35,360
the bug might be able to cause a uf

354
00:15:35,360 --> 00:15:36,800
somewhere else

355
00:15:36,800 --> 00:15:39,519
relying on single arrow behavior of bug

356
00:15:39,519 --> 00:15:41,759
could underestimate the consequence of

357
00:15:41,759 --> 00:15:42,639
them

358
00:15:42,639 --> 00:15:45,600
so please fix all the bugs if there has

359
00:15:45,600 --> 00:15:48,240
a patch from upstream you'll never know

360
00:15:48,240 --> 00:15:50,320
whether a trivial fix is a critical

361
00:15:50,320 --> 00:15:54,000
security fix or not

362
00:15:54,000 --> 00:15:56,720
and to offensive technique researchers

363
00:15:56,720 --> 00:15:59,040
a similar trash bag could result in

364
00:15:59,040 --> 00:16:00,480
exploitation

365
00:16:00,480 --> 00:16:02,880
you'll see a warning report for a bug

366
00:16:02,880 --> 00:16:05,199
you might be able to see a uf arrow if

367
00:16:05,199 --> 00:16:08,079
you expose the other arrow behaviors of

368
00:16:08,079 --> 00:16:09,199
their back

369
00:16:09,199 --> 00:16:10,800
other than that

370
00:16:10,800 --> 00:16:13,440
exposing arrow behavior also help you

371
00:16:13,440 --> 00:16:16,639
find better primitives for exploitation

372
00:16:16,639 --> 00:16:17,920
for example

373
00:16:17,920 --> 00:16:20,000
you already find the uf

374
00:16:20,000 --> 00:16:22,560
exposing other error behaviors will tell

375
00:16:22,560 --> 00:16:26,800
you other primitive this uf has

376
00:16:28,000 --> 00:16:31,440
lastly there may be a lot of unfixed

377
00:16:31,440 --> 00:16:34,399
exploitable bug in vendors kernel

378
00:16:34,399 --> 00:16:36,959
these unfixed bugs may look like

379
00:16:36,959 --> 00:16:39,759
non-security back firstly but if you

380
00:16:39,759 --> 00:16:42,240
expose their other bug effects you might

381
00:16:42,240 --> 00:16:44,240
be able to observe severe memory

382
00:16:44,240 --> 00:16:47,360
corruption ability

383
00:16:47,920 --> 00:16:51,120
we have a perfect example for this

384
00:16:51,120 --> 00:16:54,320
this cve was fixed in upstream back in

385
00:16:54,320 --> 00:16:56,320
march 2020

386
00:16:56,320 --> 00:16:58,720
it was first discovered by this caller

387
00:16:58,720 --> 00:17:01,759
with a warning arrow

388
00:17:01,759 --> 00:17:04,480
but in reality it could result in severe

389
00:17:04,480 --> 00:17:07,119
uf arrow if the bug is triggered

390
00:17:07,119 --> 00:17:09,678
differently

391
00:17:11,119 --> 00:17:14,000
we investigated whether it's fixed

392
00:17:14,000 --> 00:17:17,199
inventor's kernel it turns out by august

393
00:17:17,199 --> 00:17:18,720
2021

394
00:17:18,720 --> 00:17:21,919
it's a zero day in central sevens kernel

395
00:17:21,919 --> 00:17:24,559
and other central space distros like

396
00:17:24,559 --> 00:17:28,559
tencent oils and early os

397
00:17:30,400 --> 00:17:32,720
all right let's look at the bug

398
00:17:32,720 --> 00:17:36,000
so on the right side it's a is the error

399
00:17:36,000 --> 00:17:38,480
message generated by case

400
00:17:38,480 --> 00:17:41,120
it details logs the allocation entry of

401
00:17:41,120 --> 00:17:43,760
the vulnerable object for the uf

402
00:17:43,760 --> 00:17:47,440
the vulnerable object is allocated by k0

403
00:17:47,440 --> 00:17:49,760
in road for change function

404
00:17:49,760 --> 00:17:50,640
and

405
00:17:50,640 --> 00:17:52,640
it's free the backward queue in rows for

406
00:17:52,640 --> 00:17:55,679
delete filter and it turns out the free

407
00:17:55,679 --> 00:17:57,919
work was queued by root for chain

408
00:17:57,919 --> 00:17:59,760
function as well

409
00:17:59,760 --> 00:18:00,480
so

410
00:18:00,480 --> 00:18:03,360
the vulnerable object is allocated and

411
00:18:03,360 --> 00:18:05,600
freed by the same function

412
00:18:05,600 --> 00:18:08,160
and the leo f arrow is triggered after

413
00:18:08,160 --> 00:18:10,880
the free object is accessed in another

414
00:18:10,880 --> 00:18:13,880
function

415
00:18:15,280 --> 00:18:18,480
so what does road fall change do

416
00:18:18,480 --> 00:18:20,960
it basically does two things

417
00:18:20,960 --> 00:18:24,320
the first thing to is to allocate a road

418
00:18:24,320 --> 00:18:26,080
for filter object

419
00:18:26,080 --> 00:18:28,799
when users requires a new filter to

420
00:18:28,799 --> 00:18:31,919
kernel it allocates the object and

421
00:18:31,919 --> 00:18:34,960
initialize it properly

422
00:18:34,960 --> 00:18:38,320
the second thing it does is to update

423
00:18:38,320 --> 00:18:40,799
the road for filter object

424
00:18:40,799 --> 00:18:43,440
for users requires to modify the rows

425
00:18:43,440 --> 00:18:46,880
for filter it first allocate a new one

426
00:18:46,880 --> 00:18:49,360
and then copy the content of the old one

427
00:18:49,360 --> 00:18:52,240
to a new one and finally it will re you

428
00:18:52,240 --> 00:18:56,000
will remove the new one and freeze

429
00:18:56,000 --> 00:18:59,039
the role for object is managed by

430
00:18:59,039 --> 00:19:02,880
managed in the linked list

431
00:19:02,880 --> 00:19:06,160
so when updating the correct operation

432
00:19:06,160 --> 00:19:09,039
to delete the other route for object is

433
00:19:09,039 --> 00:19:11,760
to remove it from the linked list then

434
00:19:11,760 --> 00:19:13,120
for it

435
00:19:13,120 --> 00:19:15,840
it's wrong if we remove the new one from

436
00:19:15,840 --> 00:19:19,760
the linked list and freely old one

437
00:19:20,400 --> 00:19:23,440
and this is exactly how this bug

438
00:19:23,440 --> 00:19:25,440
happened and how the

439
00:19:25,440 --> 00:19:27,919
how the bug is fixed

440
00:19:27,919 --> 00:19:30,480
here is the patch to fix the bug

441
00:19:30,480 --> 00:19:33,200
the code in red is the root cause of the

442
00:19:33,200 --> 00:19:35,760
bug and then the code in green is what

443
00:19:35,760 --> 00:19:37,760
is fixed

444
00:19:37,760 --> 00:19:40,400
the bug only removes the new allocated

445
00:19:40,400 --> 00:19:42,880
object from the list and then the old

446
00:19:42,880 --> 00:19:45,840
one gets freed in the following

447
00:19:45,840 --> 00:19:48,400
so we will have a free object in the

448
00:19:48,400 --> 00:19:51,799
linked list

449
00:19:53,679 --> 00:19:55,760
this is a bug report that the state's

450
00:19:55,760 --> 00:19:58,400
caller first identified this bug

451
00:19:58,400 --> 00:20:01,200
it shows a warning arrow that happens at

452
00:20:01,200 --> 00:20:02,799
calling rcu

453
00:20:02,799 --> 00:20:05,200
it requires collision to trigger

454
00:20:05,200 --> 00:20:07,360
so the first glance of this factory

455
00:20:07,360 --> 00:20:09,520
probe will give you the sense that the

456
00:20:09,520 --> 00:20:12,240
trigger of this bug is very unstable

457
00:20:12,240 --> 00:20:15,039
because a lot of unreproducible bugs are

458
00:20:15,039 --> 00:20:19,480
related with rco operations

459
00:20:20,000 --> 00:20:23,200
however based on this bug report using

460
00:20:23,200 --> 00:20:26,159
our tool we are able to find its other

461
00:20:26,159 --> 00:20:29,440
other error behaviors and discover other

462
00:20:29,440 --> 00:20:33,039
exploit primitives automatically

463
00:20:33,039 --> 00:20:35,280
this is the uf arrow trigger when the

464
00:20:35,280 --> 00:20:37,840
free object is accessed in the root for

465
00:20:37,840 --> 00:20:40,559
get function

466
00:20:42,159 --> 00:20:43,120
and

467
00:20:43,120 --> 00:20:45,760
this is another uf arrow triggered when

468
00:20:45,760 --> 00:20:48,559
the freed object is accessed in the root

469
00:20:48,559 --> 00:20:49,520
destroy function

470
00:20:49,520 --> 00:20:52,320
[Music]

471
00:20:52,320 --> 00:20:55,440
and this is another uf arrow found file

472
00:20:55,440 --> 00:20:57,520
tool automatically

473
00:20:57,520 --> 00:21:00,720
in the root for dump function

474
00:21:00,720 --> 00:21:02,640
different uf arrows in different

475
00:21:02,640 --> 00:21:05,520
functions represents different exploit

476
00:21:05,520 --> 00:21:08,159
primitives when doing exploitation

477
00:21:08,159 --> 00:21:10,000
these automatically discovered

478
00:21:10,000 --> 00:21:11,760
primitives are very useful in the

479
00:21:11,760 --> 00:21:13,760
exploitation of this bug

480
00:21:13,760 --> 00:21:16,159
let me show you how we use them to

481
00:21:16,159 --> 00:21:19,200
exploit this bar

482
00:21:20,799 --> 00:21:21,600
so

483
00:21:21,600 --> 00:21:23,600
for example we could utilize the

484
00:21:23,600 --> 00:21:26,159
automatically discovered primitive to

485
00:21:26,159 --> 00:21:28,960
bypass kslr

486
00:21:28,960 --> 00:21:30,960
looking at the uf arrow found in roots

487
00:21:30,960 --> 00:21:33,440
for dump function the function has

488
00:21:33,440 --> 00:21:35,120
several calls to

489
00:21:35,120 --> 00:21:37,679
a push function which will send current

490
00:21:37,679 --> 00:21:39,600
data to user space

491
00:21:39,600 --> 00:21:41,039
and this means

492
00:21:41,039 --> 00:21:43,200
there are some data fields in a

493
00:21:43,200 --> 00:21:45,520
vulnerable object will be leaked to user

494
00:21:45,520 --> 00:21:48,640
space through the root photon function

495
00:21:48,640 --> 00:21:51,679
to bypass ksr we can spray kernel

496
00:21:51,679 --> 00:21:52,799
pointers

497
00:21:52,799 --> 00:21:54,480
in the leaked field

498
00:21:54,480 --> 00:21:56,159
and then trigger the root for dump

499
00:21:56,159 --> 00:21:59,120
function took to read kernel pointers to

500
00:21:59,120 --> 00:22:01,840
user space

501
00:22:03,520 --> 00:22:04,960
to hijack control flow in the

502
00:22:04,960 --> 00:22:07,520
exploitation we could also utilize the

503
00:22:07,520 --> 00:22:10,400
automatically discovered uf arrow in the

504
00:22:10,400 --> 00:22:12,720
root for destroy function

505
00:22:12,720 --> 00:22:15,440
the function will queue a kernel rco

506
00:22:15,440 --> 00:22:16,320
work

507
00:22:16,320 --> 00:22:18,720
in which a function to handle the work

508
00:22:18,720 --> 00:22:20,799
will be stored in object

509
00:22:20,799 --> 00:22:23,120
specifically looking at the definition

510
00:22:23,120 --> 00:22:25,600
of root for filter structure

511
00:22:25,600 --> 00:22:28,640
there is a nested data structure called

512
00:22:28,640 --> 00:22:30,480
rco work

513
00:22:30,480 --> 00:22:33,520
which stores the information of the rco

514
00:22:33,520 --> 00:22:36,880
world and inside the rco work structure

515
00:22:36,880 --> 00:22:38,840
there is a structure called work

516
00:22:38,840 --> 00:22:41,120
structure which contains a function

517
00:22:41,120 --> 00:22:43,600
pointer to handle the work

518
00:22:43,600 --> 00:22:45,760
so indeed there is a function pointer

519
00:22:45,760 --> 00:22:48,400
inside the vulnerable object

520
00:22:48,400 --> 00:22:50,799
attackers could spread kernel memory to

521
00:22:50,799 --> 00:22:52,720
overwrite the function point of the

522
00:22:52,720 --> 00:22:55,120
queue in the rco world

523
00:22:55,120 --> 00:22:57,440
and eventually attacker will obtain a

524
00:22:57,440 --> 00:22:59,840
control flow hijacking primitive from

525
00:22:59,840 --> 00:23:02,480
this uf arrow happened in root for

526
00:23:02,480 --> 00:23:05,520
destroy function

527
00:23:06,880 --> 00:23:09,600
in summary facts has multiplier

528
00:23:09,600 --> 00:23:11,200
behaviors when they are triggered

529
00:23:11,200 --> 00:23:14,400
differently for example bug may generate

530
00:23:14,400 --> 00:23:16,480
a num point the reference arrow and may

531
00:23:16,480 --> 00:23:18,720
generate a f error

532
00:23:18,720 --> 00:23:20,960
with multiple arrow behaviors of bug

533
00:23:20,960 --> 00:23:23,840
exposed we will be able to find the

534
00:23:23,840 --> 00:23:26,159
worst bug effects to determine the

535
00:23:26,159 --> 00:23:28,559
exploitability of the bug

536
00:23:28,559 --> 00:23:29,919
in addition

537
00:23:29,919 --> 00:23:32,559
we can also utilize it to help discover

538
00:23:32,559 --> 00:23:34,240
exploit primitives

539
00:23:34,240 --> 00:23:37,919
and find the inputs for it automatically

540
00:23:37,919 --> 00:23:40,000
in this example we are able to

541
00:23:40,000 --> 00:23:41,520
automatically find the exploit

542
00:23:41,520 --> 00:23:44,720
primitives that help bypass kslr and

543
00:23:44,720 --> 00:23:49,400
obtain control for hijacking ability

544
00:23:51,120 --> 00:23:53,520
in addition to utilizing automatically

545
00:23:53,520 --> 00:23:55,679
discovered primitive to exploit the

546
00:23:55,679 --> 00:23:58,240
spark i would like to talk about a

547
00:23:58,240 --> 00:24:00,320
generic exploitation method for

548
00:24:00,320 --> 00:24:04,480
exploiting uaf in linux kernel

549
00:24:04,480 --> 00:24:06,799
the exploitation only requires free

550
00:24:06,799 --> 00:24:09,360
ability from the uaf

551
00:24:09,360 --> 00:24:12,400
specifically uf should be able to free

552
00:24:12,400 --> 00:24:15,039
the vulnerable object again after

553
00:24:15,039 --> 00:24:17,200
spraying another object to occupy the

554
00:24:17,200 --> 00:24:19,760
memory slot

555
00:24:19,760 --> 00:24:22,960
also i will utilize the universal spray

556
00:24:22,960 --> 00:24:25,360
objects to achieve leaking and ranking

557
00:24:25,360 --> 00:24:27,918
ability

558
00:24:28,880 --> 00:24:31,840
so to apply this technique in exploiting

559
00:24:31,840 --> 00:24:34,720
this bug we first free the vulnerable

560
00:24:34,720 --> 00:24:37,200
object

561
00:24:38,559 --> 00:24:42,320
out after freeing the memory is free but

562
00:24:42,320 --> 00:24:44,400
there has a dangling point referencing

563
00:24:44,400 --> 00:24:47,039
it

564
00:24:47,039 --> 00:24:50,880
then we spray the universal spray object

565
00:24:50,880 --> 00:24:53,440
to occupy the memory slot

566
00:24:53,440 --> 00:24:56,559
here we use the message structure

567
00:24:56,559 --> 00:24:58,960
it's a flexible structure so it can be

568
00:24:58,960 --> 00:25:01,600
allocated in any general cache

569
00:25:01,600 --> 00:25:04,959
depending on user control

570
00:25:05,840 --> 00:25:08,480
then we free the spread object to the

571
00:25:08,480 --> 00:25:09,679
vulnerable

572
00:25:09,679 --> 00:25:11,840
through the vulnerability this is the

573
00:25:11,840 --> 00:25:14,080
place where we utilize the ability of

574
00:25:14,080 --> 00:25:15,679
the vulnerability

575
00:25:15,679 --> 00:25:18,720
after freeing the message object becomes

576
00:25:18,720 --> 00:25:21,120
free

577
00:25:21,840 --> 00:25:25,200
after this we spray a victim object

578
00:25:25,200 --> 00:25:27,520
which contains pointers

579
00:25:27,520 --> 00:25:29,760
it could be function pointers or heap

580
00:25:29,760 --> 00:25:32,400
pointers

581
00:25:34,080 --> 00:25:36,640
then we we call the store message

582
00:25:36,640 --> 00:25:37,679
function

583
00:25:37,679 --> 00:25:39,919
which will copy the content of the

584
00:25:39,919 --> 00:25:42,880
object message to user space

585
00:25:42,880 --> 00:25:45,520
and this will leak the content of the

586
00:25:45,520 --> 00:25:48,400
victim object to user space

587
00:25:48,400 --> 00:25:52,960
so we will be able to leak current data

588
00:25:54,720 --> 00:25:56,799
and we could also temper the function

589
00:25:56,799 --> 00:25:59,200
pointer inside through the message

590
00:25:59,200 --> 00:26:01,679
objects to get control flow hijacking

591
00:26:01,679 --> 00:26:02,880
ability

592
00:26:02,880 --> 00:26:05,679
the whole process is very standard and

593
00:26:05,679 --> 00:26:08,080
it has a potential to be developed as an

594
00:26:08,080 --> 00:26:10,159
automatic exploit generation approach

595
00:26:10,159 --> 00:26:13,200
for you exploiting uf in kernel

596
00:26:13,200 --> 00:26:15,279
i have implemented the exploitation

597
00:26:15,279 --> 00:26:19,200
method exploiting this ui this cve

598
00:26:19,200 --> 00:26:21,679
and i believe a lot of code can be

599
00:26:21,679 --> 00:26:24,640
reviewed can be reused exploiting other

600
00:26:24,640 --> 00:26:27,840
uf's in kernel

601
00:26:28,799 --> 00:26:30,320
there is one more thing about

602
00:26:30,320 --> 00:26:31,760
exploitation

603
00:26:31,760 --> 00:26:33,919
sometimes we have the controllable

604
00:26:33,919 --> 00:26:36,720
hijacking ability but we cannot control

605
00:26:36,720 --> 00:26:39,279
the arguments of the control flow

606
00:26:39,279 --> 00:26:41,440
for example the argument is always a

607
00:26:41,440 --> 00:26:44,320
keeper address

608
00:26:44,720 --> 00:26:47,919
and we cannot hijack ctrl to run command

609
00:26:47,919 --> 00:26:48,880
function

610
00:26:48,880 --> 00:26:51,440
because the argument is not pointing to

611
00:26:51,440 --> 00:26:54,400
a stream buffer that we can control

612
00:26:54,400 --> 00:26:57,360
and we cannot call to native red cr4

613
00:26:57,360 --> 00:26:58,320
function

614
00:26:58,320 --> 00:27:00,880
because the first argument is a heap

615
00:27:00,880 --> 00:27:03,440
address which cannot help us disable

616
00:27:03,440 --> 00:27:07,240
smap and smep

617
00:27:08,000 --> 00:27:10,480
in this situation we can try some

618
00:27:10,480 --> 00:27:12,640
function gauges in kernel

619
00:27:12,640 --> 00:27:15,039
for example the install

620
00:27:15,039 --> 00:27:17,679
execute credits function before kernel

621
00:27:17,679 --> 00:27:21,279
5.8 or the commit on a set

622
00:27:21,279 --> 00:27:25,240
after kernel 5.7

623
00:27:26,640 --> 00:27:29,520
these two functions contains contain

624
00:27:29,520 --> 00:27:31,600
perfect gadgets that will change the

625
00:27:31,600 --> 00:27:34,000
credential of current process

626
00:27:34,000 --> 00:27:36,799
specifically looking at the install sql

627
00:27:36,799 --> 00:27:38,240
credits function

628
00:27:38,240 --> 00:27:40,799
as long as we can set the credit field

629
00:27:40,799 --> 00:27:43,600
of the argument to indeed credit which

630
00:27:43,600 --> 00:27:46,240
is a global variable we are able to

631
00:27:46,240 --> 00:27:48,159
change the credential of our current

632
00:27:48,159 --> 00:27:51,279
process to root

633
00:27:53,279 --> 00:27:55,840
the code is available in my github repo

634
00:27:55,840 --> 00:27:59,600
you are welcome to take a look at it

635
00:28:01,520 --> 00:28:03,840
finally i would like to summarize

636
00:28:03,840 --> 00:28:06,080
several takeaways here

637
00:28:06,080 --> 00:28:08,880
first a kernel box could have multiple

638
00:28:08,880 --> 00:28:10,399
error behaviors

639
00:28:10,399 --> 00:28:12,960
so when you see a trash bank it could

640
00:28:12,960 --> 00:28:15,520
result in severe memory corruption

641
00:28:15,520 --> 00:28:18,880
if other error behavior is exposed

642
00:28:18,880 --> 00:28:22,320
so for vendors please adopt fixes from

643
00:28:22,320 --> 00:28:27,200
upstream even if it fixes trash box

644
00:28:27,200 --> 00:28:28,320
second

645
00:28:28,320 --> 00:28:31,200
we could utilize the tool to find him to

646
00:28:31,200 --> 00:28:33,440
find multiple behaviors of bug and

647
00:28:33,440 --> 00:28:35,440
define the exploit primitives

648
00:28:35,440 --> 00:28:36,960
automatically

649
00:28:36,960 --> 00:28:39,919
as shown in the example we are able to

650
00:28:39,919 --> 00:28:42,960
find primitives of bypassing kslr and

651
00:28:42,960 --> 00:28:46,320
hijacking control flow automatically

652
00:28:46,320 --> 00:28:47,520
lastly

653
00:28:47,520 --> 00:28:50,159
there might be other unfixed exploitable

654
00:28:50,159 --> 00:28:53,120
bugs in vendors kernel because most

655
00:28:53,120 --> 00:28:55,760
vendors only fix cve bugs

656
00:28:55,760 --> 00:28:58,640
but a lot of bugs don't have cves and

657
00:28:58,640 --> 00:29:01,760
their exploitability are unknown to them

658
00:29:01,760 --> 00:29:04,399
these bugs could be very severe but look

659
00:29:04,399 --> 00:29:05,440
like

660
00:29:05,440 --> 00:29:08,480
trash box so they get ignored

661
00:29:08,480 --> 00:29:10,559
checking by the vendor's adult fixes

662
00:29:10,559 --> 00:29:12,640
from upstream could be a great way to

663
00:29:12,640 --> 00:29:15,840
hunt for zero days

664
00:29:16,960 --> 00:29:18,640
that's all of my talk

665
00:29:18,640 --> 00:29:21,120
this is john palin from penn state my

666
00:29:21,120 --> 00:29:23,279
research focuses on exploitation and

667
00:29:23,279 --> 00:29:25,600
defense you can find my other

668
00:29:25,600 --> 00:29:28,640
information from my personal website

669
00:29:28,640 --> 00:29:30,480
i'm looking for internship for next

670
00:29:30,480 --> 00:29:33,039
summer so if you know there is any

671
00:29:33,039 --> 00:29:34,240
opportunity

672
00:29:34,240 --> 00:29:36,559
feel free to send me a message

673
00:29:36,559 --> 00:29:38,799
here is my twitter and you can find my

674
00:29:38,799 --> 00:29:40,559
other contact information from my

675
00:29:40,559 --> 00:29:42,559
personal website as well

676
00:29:42,559 --> 00:29:44,640
it's a great honor being here to share

677
00:29:44,640 --> 00:29:49,200
my work now i'm happy to take questions

678
00:29:49,200 --> 00:29:58,819
[Music]

679
00:29:59,360 --> 00:30:01,439
you

