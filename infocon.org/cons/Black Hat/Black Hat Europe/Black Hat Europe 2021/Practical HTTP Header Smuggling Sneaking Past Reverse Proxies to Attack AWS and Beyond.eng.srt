1
00:00:00,860 --> 00:00:09,840
[Music]

2
00:00:09,840 --> 00:00:11,840
hello and welcome to this session on

3
00:00:11,840 --> 00:00:14,400
practical http header smartplane where

4
00:00:14,400 --> 00:00:15,839
we're going to look at some of the ways

5
00:00:15,839 --> 00:00:18,400
we can sneak http request headers past

6
00:00:18,400 --> 00:00:19,840
reverse proxies

7
00:00:19,840 --> 00:00:22,000
and some of the fun vulnerability

8
00:00:22,000 --> 00:00:23,840
exploitation we can get as a result of

9
00:00:23,840 --> 00:00:25,920
that but before we jump into that we

10
00:00:25,920 --> 00:00:28,000
need to have the mandatory who am i side

11
00:00:28,000 --> 00:00:30,560
so hello i'm daniel thatcher i work at a

12
00:00:30,560 --> 00:00:32,399
company called intruder we're a

13
00:00:32,399 --> 00:00:33,920
cloud-based vulnerability scanner

14
00:00:33,920 --> 00:00:35,840
focused on making continuous monitoring

15
00:00:35,840 --> 00:00:36,719
easy

16
00:00:36,719 --> 00:00:38,399
i work there as a researcher as a

17
00:00:38,399 --> 00:00:40,559
penetration tester as well as providing

18
00:00:40,559 --> 00:00:42,320
some of the security expertise for the

19
00:00:42,320 --> 00:00:44,160
platform

20
00:00:44,160 --> 00:00:46,160
a lot of my research is focused on black

21
00:00:46,160 --> 00:00:48,160
box scenarios as these are the ones i

22
00:00:48,160 --> 00:00:51,039
find myself working most often and to me

23
00:00:51,039 --> 00:00:53,440
they tend to be the most interesting

24
00:00:53,440 --> 00:00:55,520
i've also got some links to our social

25
00:00:55,520 --> 00:00:57,680
media and our research blogs

26
00:00:57,680 --> 00:00:59,520
which you will be available at the end

27
00:00:59,520 --> 00:01:02,559
of the presentation as well

28
00:01:02,559 --> 00:01:04,720
so what are we going to talk about today

29
00:01:04,720 --> 00:01:06,320
we're going to start a review of a

30
00:01:06,320 --> 00:01:08,400
review of the model that we're using to

31
00:01:08,400 --> 00:01:10,840
describe a modern worm applications

32
00:01:10,840 --> 00:01:13,040
architecture we're then going to move on

33
00:01:13,040 --> 00:01:14,720
to discussing what is actually header

34
00:01:14,720 --> 00:01:16,320
smuggling

35
00:01:16,320 --> 00:01:18,159
some talk about the detection of header

36
00:01:18,159 --> 00:01:20,000
smuggling and then a look at some

37
00:01:20,000 --> 00:01:21,920
applications

38
00:01:21,920 --> 00:01:23,680
finally we'll finish off talking about

39
00:01:23,680 --> 00:01:25,759
how to defend against head smuggling and

40
00:01:25,759 --> 00:01:27,759
some conclusions and talk of where the

41
00:01:27,759 --> 00:01:31,200
research can go in the future

42
00:01:31,600 --> 00:01:33,920
so how is a modern web application set

43
00:01:33,920 --> 00:01:34,720
up

44
00:01:34,720 --> 00:01:36,159
well we're going to model it in this

45
00:01:36,159 --> 00:01:38,240
talk as a front-end and a back-end

46
00:01:38,240 --> 00:01:39,520
server

47
00:01:39,520 --> 00:01:41,200
the front-end server is typically

48
00:01:41,200 --> 00:01:44,479
responsible for duties such as caching

49
00:01:44,479 --> 00:01:46,880
load balancing or acting as a web

50
00:01:46,880 --> 00:01:49,119
application firewall whereas the backend

51
00:01:49,119 --> 00:01:50,799
server is what actually runs the

52
00:01:50,799 --> 00:01:52,880
application's code and logic is

53
00:01:52,880 --> 00:01:55,360
responsible for accessing all the data

54
00:01:55,360 --> 00:01:57,360
of the application

55
00:01:57,360 --> 00:01:59,200
now it's really important to mention

56
00:01:59,200 --> 00:02:01,280
that this is just a model

57
00:02:01,280 --> 00:02:03,119
and in most scenarios including the ones

58
00:02:03,119 --> 00:02:05,280
we'll see today it's actually a massive

59
00:02:05,280 --> 00:02:07,360
oversimplification of reality

60
00:02:07,360 --> 00:02:09,520
however this model allows us to

61
00:02:09,520 --> 00:02:11,920
understand a lot of behavior we see and

62
00:02:11,920 --> 00:02:13,440
allows us to move forward with

63
00:02:13,440 --> 00:02:15,840
exploitation by assuming the setup is

64
00:02:15,840 --> 00:02:17,120
like this

65
00:02:17,120 --> 00:02:19,520
but if you find yourself in a situation

66
00:02:19,520 --> 00:02:20,879
where you're trying to understand some

67
00:02:20,879 --> 00:02:23,440
behavior this is an assumption worth

68
00:02:23,440 --> 00:02:26,239
challenging as usually the front-end

69
00:02:26,239 --> 00:02:28,720
servers could be a chain of more servers

70
00:02:28,720 --> 00:02:30,800
they could be multiple back-end servers

71
00:02:30,800 --> 00:02:32,879
or the setup could be more complex than

72
00:02:32,879 --> 00:02:37,200
this in ways you couldn't even imagine

73
00:02:37,200 --> 00:02:40,480
now generally front-end servers use http

74
00:02:40,480 --> 00:02:42,640
headers to pass information to back-end

75
00:02:42,640 --> 00:02:43,840
servers

76
00:02:43,840 --> 00:02:46,080
a great example of this is the exported

77
00:02:46,080 --> 00:02:48,160
four-header which front-end servers

78
00:02:48,160 --> 00:02:50,400
typically put the client ip address in

79
00:02:50,400 --> 00:02:52,400
so the back end servers can know the

80
00:02:52,400 --> 00:02:53,840
initial ip address from which the

81
00:02:53,840 --> 00:02:55,920
request originated

82
00:02:55,920 --> 00:02:57,519
this makes it quite important for

83
00:02:57,519 --> 00:02:59,920
front-end servers to actually filter out

84
00:02:59,920 --> 00:03:01,599
headers such as these from the client's

85
00:03:01,599 --> 00:03:02,720
request

86
00:03:02,720 --> 00:03:05,360
otherwise as a user i'd be able to put

87
00:03:05,360 --> 00:03:06,879
whatever value i wanted into the

88
00:03:06,879 --> 00:03:09,200
exported four header and spoof my ip

89
00:03:09,200 --> 00:03:10,239
address

90
00:03:10,239 --> 00:03:11,760
so if the information these headers is

91
00:03:11,760 --> 00:03:13,840
to be trusted the front end server needs

92
00:03:13,840 --> 00:03:16,319
to validate it and filter some

93
00:03:16,319 --> 00:03:18,080
information out if it was provided by

94
00:03:18,080 --> 00:03:20,319
the clients

95
00:03:20,319 --> 00:03:23,120
we also get some interesting situations

96
00:03:23,120 --> 00:03:25,440
when the servers disagree about either

97
00:03:25,440 --> 00:03:27,920
the value or the existence of a header

98
00:03:27,920 --> 00:03:29,920
so one we've seen a lot of in recent

99
00:03:29,920 --> 00:03:31,840
years is request smuggling

100
00:03:31,840 --> 00:03:33,680
when servers disagree about either the

101
00:03:33,680 --> 00:03:35,519
value or the existence the content

102
00:03:35,519 --> 00:03:37,760
length and transfer encoding headers

103
00:03:37,760 --> 00:03:40,560
this can often lead to request smuggling

104
00:03:40,560 --> 00:03:42,000
similarly we'll also look at the

105
00:03:42,000 --> 00:03:44,000
situation in this talk where this leads

106
00:03:44,000 --> 00:03:45,760
to cash poisoning when two servers

107
00:03:45,760 --> 00:03:49,200
disagree on the value of the header

108
00:03:49,840 --> 00:03:52,080
now with that in mind what actually is

109
00:03:52,080 --> 00:03:53,760
header smuggling

110
00:03:53,760 --> 00:03:55,360
simply put it's the process of

111
00:03:55,360 --> 00:03:57,360
disguising a header so that it will be

112
00:03:57,360 --> 00:03:58,959
passed differently by different web

113
00:03:58,959 --> 00:04:01,519
servers and in this research we're going

114
00:04:01,519 --> 00:04:03,360
to focus on the situation where the

115
00:04:03,360 --> 00:04:05,760
front-end server misses a header or

116
00:04:05,760 --> 00:04:07,439
doesn't pass it

117
00:04:07,439 --> 00:04:10,400
in the way that the back-end server does

118
00:04:10,400 --> 00:04:12,239
and then the backend server passes it as

119
00:04:12,239 --> 00:04:13,519
we want it to

120
00:04:13,519 --> 00:04:15,519
without the front end server modifying

121
00:04:15,519 --> 00:04:17,279
it

122
00:04:17,279 --> 00:04:18,798
how do we discuss headers well we're

123
00:04:18,798 --> 00:04:21,600
doing what i terms of mutation which is

124
00:04:21,600 --> 00:04:23,440
simply a modification you can make to a

125
00:04:23,440 --> 00:04:25,520
header to cause different servers to

126
00:04:25,520 --> 00:04:27,440
pass it differently

127
00:04:27,440 --> 00:04:30,080
so some examples of mutations include

128
00:04:30,080 --> 00:04:31,840
the identity mutation where we do

129
00:04:31,840 --> 00:04:33,919
nothing to the header so this x my

130
00:04:33,919 --> 00:04:36,720
header test header here will look pretty

131
00:04:36,720 --> 00:04:38,800
much as you'd expect a standard 80 to be

132
00:04:38,800 --> 00:04:40,720
headed look

133
00:04:40,720 --> 00:04:42,960
however if you use underscores in header

134
00:04:42,960 --> 00:04:45,680
names it's quite common for some servers

135
00:04:45,680 --> 00:04:48,639
to process it as it was the x my header

136
00:04:48,639 --> 00:04:50,639
test header we had on the last slide

137
00:04:50,639 --> 00:04:52,080
whereas some will see it as a different

138
00:04:52,080 --> 00:04:53,680
header

139
00:04:53,680 --> 00:04:55,360
similarly when we see a lot in request

140
00:04:55,360 --> 00:04:57,520
smuggling is putting white space in

141
00:04:57,520 --> 00:04:59,120
places around the header for example

142
00:04:59,120 --> 00:05:00,960
here before the column and it's worth

143
00:05:00,960 --> 00:05:02,479
noting at this point that a lot of these

144
00:05:02,479 --> 00:05:04,880
mutations come from request smuggling

145
00:05:04,880 --> 00:05:07,120
research as you may have recognized

146
00:05:07,120 --> 00:05:09,039
already

147
00:05:09,039 --> 00:05:10,479
another one we see quite commonly is

148
00:05:10,479 --> 00:05:12,720
white space at the start of the header

149
00:05:12,720 --> 00:05:14,160
and one we're going to see a lot of in

150
00:05:14,160 --> 00:05:15,280
this talk

151
00:05:15,280 --> 00:05:17,520
is including some random junk in the

152
00:05:17,520 --> 00:05:20,479
header name after a space so some

153
00:05:20,479 --> 00:05:22,800
servers will pass this header as a

154
00:05:22,800 --> 00:05:25,840
header called x my header abcd

155
00:05:25,840 --> 00:05:27,680
whereas others will just pass it as a

156
00:05:27,680 --> 00:05:29,919
header called x my header with a value

157
00:05:29,919 --> 00:05:32,400
of test

158
00:05:33,440 --> 00:05:35,440
so this research set out to find a

159
00:05:35,440 --> 00:05:37,360
methodology for detecting header

160
00:05:37,360 --> 00:05:39,440
smuggling and there were two key aims of

161
00:05:39,440 --> 00:05:41,039
this methodology

162
00:05:41,039 --> 00:05:42,720
the first is that it would identify

163
00:05:42,720 --> 00:05:45,039
mutations in a generic way where you

164
00:05:45,039 --> 00:05:46,880
find a mutation independently of a

165
00:05:46,880 --> 00:05:49,840
header so once a mutation has been found

166
00:05:49,840 --> 00:05:51,840
we can apply it to any header to sneak

167
00:05:51,840 --> 00:05:53,680
it through to the back end server

168
00:05:53,680 --> 00:05:54,960
without being recognized by the

169
00:05:54,960 --> 00:05:56,880
front-end server

170
00:05:56,880 --> 00:05:58,720
the second aim was that it would work in

171
00:05:58,720 --> 00:06:00,720
black box scenarios as i mentioned at

172
00:06:00,720 --> 00:06:02,319
the top of the talk these are the

173
00:06:02,319 --> 00:06:04,240
scenarios that i find myself in most

174
00:06:04,240 --> 00:06:06,400
often and personally for my research

175
00:06:06,400 --> 00:06:08,000
find most interesting so these are the

176
00:06:08,000 --> 00:06:11,440
ones i chose to focus on

177
00:06:11,440 --> 00:06:13,199
now i'm going to explain the methodology

178
00:06:13,199 --> 00:06:15,440
through the use of an example so the

179
00:06:15,440 --> 00:06:17,360
methodology works by testing one

180
00:06:17,360 --> 00:06:19,600
mutation at a time and trying to

181
00:06:19,600 --> 00:06:21,280
determine whether it can be used to

182
00:06:21,280 --> 00:06:23,520
achieve header smuggling so in this

183
00:06:23,520 --> 00:06:25,120
example we're looking at the mutation

184
00:06:25,120 --> 00:06:28,080
which adds an abcd after the space to

185
00:06:28,080 --> 00:06:29,440
the header name

186
00:06:29,440 --> 00:06:30,880
and we're going to see

187
00:06:30,880 --> 00:06:33,120
if the front-end server will process

188
00:06:33,120 --> 00:06:35,440
this as a header other than a header

189
00:06:35,440 --> 00:06:36,960
called x header

190
00:06:36,960 --> 00:06:38,800
while the back end will still see it as

191
00:06:38,800 --> 00:06:42,240
the x header header

192
00:06:46,720 --> 00:06:49,520
so to start off the detection process

193
00:06:49,520 --> 00:06:51,440
we use what may look like a fairly

194
00:06:51,440 --> 00:06:53,759
normal request the only thing that might

195
00:06:53,759 --> 00:06:55,199
stand out to you about slightly strange

196
00:06:55,199 --> 00:06:56,560
in this request

197
00:06:56,560 --> 00:06:58,720
is that it is a get request but it has a

198
00:06:58,720 --> 00:07:00,400
content length header in there and the

199
00:07:00,400 --> 00:07:01,919
value of the content length header is

200
00:07:01,919 --> 00:07:03,599
set to zero so we're actually not

201
00:07:03,599 --> 00:07:05,599
including a body

202
00:07:05,599 --> 00:07:07,360
now most servers are completely fine

203
00:07:07,360 --> 00:07:09,840
with this so as we can see here we get

204
00:07:09,840 --> 00:07:12,560
to 200 okay indicating the response we

205
00:07:12,560 --> 00:07:14,880
really expected for a get request to the

206
00:07:14,880 --> 00:07:17,280
home page

207
00:07:17,280 --> 00:07:19,520
the next step is to put an invalid value

208
00:07:19,520 --> 00:07:21,680
in that content length header

209
00:07:21,680 --> 00:07:23,919
and as we can see here unsurprisingly

210
00:07:23,919 --> 00:07:26,639
this causes an error this indicates that

211
00:07:26,639 --> 00:07:28,000
one of the servers in the chain is

212
00:07:28,000 --> 00:07:30,080
trying to pass the content length header

213
00:07:30,080 --> 00:07:31,919
and when it sees an invalid value such

214
00:07:31,919 --> 00:07:33,759
as the z here it's going to throw an

215
00:07:33,759 --> 00:07:35,759
error

216
00:07:35,759 --> 00:07:37,759
now we repeat this process with our

217
00:07:37,759 --> 00:07:39,280
mutated header

218
00:07:39,280 --> 00:07:41,759
so here again we're putting this content

219
00:07:41,759 --> 00:07:44,400
length value of zero in the mutated

220
00:07:44,400 --> 00:07:46,319
content length at this time

221
00:07:46,319 --> 00:07:48,319
and we get a response that we expect

222
00:07:48,319 --> 00:07:50,720
without any errors

223
00:07:50,720 --> 00:07:52,639
now when we put an invalid value in

224
00:07:52,639 --> 00:07:54,960
there we again get an error so we know

225
00:07:54,960 --> 00:07:57,120
that some server in the chain is passing

226
00:07:57,120 --> 00:07:59,360
this

227
00:07:59,360 --> 00:08:00,879
now there's a couple of key things to

228
00:08:00,879 --> 00:08:02,560
look at here to determine whether we

229
00:08:02,560 --> 00:08:04,400
have header smuggling

230
00:08:04,400 --> 00:08:06,720
the first is a comparison between our

231
00:08:06,720 --> 00:08:08,560
requests that set the content length to

232
00:08:08,560 --> 00:08:11,039
zero it's quite important that these set

233
00:08:11,039 --> 00:08:12,560
the same response

234
00:08:12,560 --> 00:08:14,479
and using this we can know that our

235
00:08:14,479 --> 00:08:15,919
mutated header

236
00:08:15,919 --> 00:08:17,919
hasn't been so malformed that one of the

237
00:08:17,919 --> 00:08:19,759
servers in the chain has rejected it or

238
00:08:19,759 --> 00:08:22,240
refused to pass the request completely

239
00:08:22,240 --> 00:08:23,919
every server has continued to pass the

240
00:08:23,919 --> 00:08:26,400
request as a valid http request and

241
00:08:26,400 --> 00:08:29,599
return the response we expect

242
00:08:29,599 --> 00:08:31,840
we also need to compare the errors now

243
00:08:31,840 --> 00:08:34,080
importantly here with our mutated

244
00:08:34,080 --> 00:08:36,320
unmutated header when we put an invalid

245
00:08:36,320 --> 00:08:39,039
value in them we get different errors

246
00:08:39,039 --> 00:08:40,719
and this suggests that the errors are

247
00:08:40,719 --> 00:08:42,958
coming from different servers which are

248
00:08:42,958 --> 00:08:45,279
erroring when they see an invalid value

249
00:08:45,279 --> 00:08:47,440
in the content length header

250
00:08:47,440 --> 00:08:49,279
so one of our servers is reading the

251
00:08:49,279 --> 00:08:51,600
content length unmutated header

252
00:08:51,600 --> 00:08:53,200
whereas another one it seems to be

253
00:08:53,200 --> 00:08:56,800
passing our mutated header

254
00:08:57,120 --> 00:08:59,040
now as we know that

255
00:08:59,040 --> 00:09:00,880
the server which is likely the front-end

256
00:09:00,880 --> 00:09:03,440
server which is passing the unmutated

257
00:09:03,440 --> 00:09:04,480
header

258
00:09:04,480 --> 00:09:06,399
is not throwing an error

259
00:09:06,399 --> 00:09:08,080
for our mutated header as we're getting

260
00:09:08,080 --> 00:09:09,839
a different error back

261
00:09:09,839 --> 00:09:11,600
this suggests that

262
00:09:11,600 --> 00:09:13,360
that second error of the mutated header

263
00:09:13,360 --> 00:09:15,360
is coming from a backend server

264
00:09:15,360 --> 00:09:16,959
which is reading this while the front

265
00:09:16,959 --> 00:09:20,160
end is ignoring that mutated header

266
00:09:20,160 --> 00:09:20,959
so

267
00:09:20,959 --> 00:09:22,959
we have a mutation which allows us to

268
00:09:22,959 --> 00:09:24,800
sneak a header through to the back end

269
00:09:24,800 --> 00:09:27,040
without the front end seeing it

270
00:09:27,040 --> 00:09:28,640
where do we get from here

271
00:09:28,640 --> 00:09:30,720
well sometimes we might know a header we

272
00:09:30,720 --> 00:09:31,680
want to

273
00:09:31,680 --> 00:09:33,839
test already and sneak through a great

274
00:09:33,839 --> 00:09:35,600
example of this is the exported for

275
00:09:35,600 --> 00:09:37,680
header where if we're coming across some

276
00:09:37,680 --> 00:09:39,920
ip restrictions this might be a great

277
00:09:39,920 --> 00:09:41,360
candidate to try and sneak through to

278
00:09:41,360 --> 00:09:42,800
the back end to bypass these

279
00:09:42,800 --> 00:09:44,240
restrictions

280
00:09:44,240 --> 00:09:45,279
however

281
00:09:45,279 --> 00:09:47,440
often we don't know a specific header

282
00:09:47,440 --> 00:09:49,040
which will be interesting for our target

283
00:09:49,040 --> 00:09:51,120
system and we just want to try guess as

284
00:09:51,120 --> 00:09:53,279
many headers as possible

285
00:09:53,279 --> 00:09:55,279
now for this in my research i've been

286
00:09:55,279 --> 00:09:57,200
using an updated version of james

287
00:09:57,200 --> 00:09:59,360
kettle's pram miner extension

288
00:09:59,360 --> 00:10:01,120
which i will be releasing as well as

289
00:10:01,120 --> 00:10:02,640
part of the research at the time of the

290
00:10:02,640 --> 00:10:05,360
conference what this updated version

291
00:10:05,360 --> 00:10:07,680
will do is it will search for mutations

292
00:10:07,680 --> 00:10:09,360
which allow us to sneak a header through

293
00:10:09,360 --> 00:10:10,800
to the back end

294
00:10:10,800 --> 00:10:12,800
and then with each of those mutations it

295
00:10:12,800 --> 00:10:13,760
finds

296
00:10:13,760 --> 00:10:16,240
it will try every header that paraminer

297
00:10:16,240 --> 00:10:18,320
will try anyway and see if it can

298
00:10:18,320 --> 00:10:21,760
trigger some interesting behavior

299
00:10:22,959 --> 00:10:24,560
so we're going to look at some examples

300
00:10:24,560 --> 00:10:25,360
now

301
00:10:25,360 --> 00:10:26,959
and the first one of these examples is

302
00:10:26,959 --> 00:10:29,440
in aws api gateway

303
00:10:29,440 --> 00:10:32,320
now api gateway is a service from aws

304
00:10:32,320 --> 00:10:35,519
which allows you to build http apis

305
00:10:35,519 --> 00:10:38,640
built on lambda functions which are aws

306
00:10:38,640 --> 00:10:41,680
version of serverless functions

307
00:10:41,680 --> 00:10:43,839
in essence you run the code for your

308
00:10:43,839 --> 00:10:45,440
function without having to maintain any

309
00:10:45,440 --> 00:10:47,600
of the infrastructure and you only pay

310
00:10:47,600 --> 00:10:51,120
for the execution time of your function

311
00:10:51,120 --> 00:10:53,680
now if you want to limit ip access to

312
00:10:53,680 --> 00:10:55,519
one of these

313
00:10:55,519 --> 00:10:58,000
functions or one of these apis you use

314
00:10:58,000 --> 00:11:00,079
what's called a resource policy which

315
00:11:00,079 --> 00:11:03,920
you apply to your api gateway service

316
00:11:03,920 --> 00:11:05,600
i have an example of the resource policy

317
00:11:05,600 --> 00:11:07,360
here which may be of interest to some of

318
00:11:07,360 --> 00:11:09,519
you more familiar with aws

319
00:11:09,519 --> 00:11:12,160
but the important part here is that only

320
00:11:12,160 --> 00:11:15,279
the ip addresses 1.2.3.4

321
00:11:15,279 --> 00:11:18,560
and the range 100 8

322
00:11:18,560 --> 00:11:20,399
are allowed to make requests to this

323
00:11:20,399 --> 00:11:21,440
service

324
00:11:21,440 --> 00:11:23,880
unfortunately i don't own the ip address

325
00:11:23,880 --> 00:11:26,959
1.2.3.4 and can't send requests from it

326
00:11:26,959 --> 00:11:28,399
and in this example we're sending

327
00:11:28,399 --> 00:11:29,920
requests from outside the customers

328
00:11:29,920 --> 00:11:32,000
cloud account so there's no way i can

329
00:11:32,000 --> 00:11:35,839
send from that internal range either

330
00:11:35,839 --> 00:11:38,399
now if we set up an api with api gateway

331
00:11:38,399 --> 00:11:40,480
and apply this resource policy

332
00:11:40,480 --> 00:11:42,560
and send a request to it

333
00:11:42,560 --> 00:11:44,880
we unsurprisingly get a 403 forbidden

334
00:11:44,880 --> 00:11:46,399
because we're not requesting from an

335
00:11:46,399 --> 00:11:49,120
allowed ip address

336
00:11:49,120 --> 00:11:51,680
a perhaps slightly naive approach might

337
00:11:51,680 --> 00:11:54,000
be to just include the exported 4 header

338
00:11:54,000 --> 00:11:56,160
in our request with an ip address on the

339
00:11:56,160 --> 00:11:57,760
white list

340
00:11:57,760 --> 00:12:00,720
and unsurprisingly this doesn't bypass

341
00:12:00,720 --> 00:12:02,639
aws's restrictions

342
00:12:02,639 --> 00:12:04,000
would be nice and it's always worth

343
00:12:04,000 --> 00:12:05,760
testing but i don't think that's going

344
00:12:05,760 --> 00:12:08,399
to come as a shock to anyone

345
00:12:08,399 --> 00:12:10,959
however through some testing i

346
00:12:10,959 --> 00:12:12,399
discovered that i could sneak headers

347
00:12:12,399 --> 00:12:14,240
through to the back end by using this

348
00:12:14,240 --> 00:12:16,399
mutation of adding some junk after a

349
00:12:16,399 --> 00:12:18,079
space in the header name

350
00:12:18,079 --> 00:12:20,079
and the back end would still pass it as

351
00:12:20,079 --> 00:12:21,839
though that space and training

352
00:12:21,839 --> 00:12:23,920
characters weren't there so i tried the

353
00:12:23,920 --> 00:12:25,440
following requests

354
00:12:25,440 --> 00:12:27,920
and i got through to my api bypassing

355
00:12:27,920 --> 00:12:29,279
all the restrictions

356
00:12:29,279 --> 00:12:31,279
so that's quite a nice start

357
00:12:31,279 --> 00:12:34,160
but often we won't actually know an ip

358
00:12:34,160 --> 00:12:35,839
address which is allowed through to the

359
00:12:35,839 --> 00:12:38,399
api we might be able to work it out but

360
00:12:38,399 --> 00:12:40,000
we'll be blind guessing quite a bit and

361
00:12:40,000 --> 00:12:41,920
that's quite difficult

362
00:12:41,920 --> 00:12:44,000
so i moved on to trying something

363
00:12:44,000 --> 00:12:46,240
perhaps more stupid but putting an

364
00:12:46,240 --> 00:12:48,079
imbalanced value in there that can't be

365
00:12:48,079 --> 00:12:50,079
passed as an ip address in this case a

366
00:12:50,079 --> 00:12:51,440
letter z

367
00:12:51,440 --> 00:12:56,399
and quite fortunately this also worked

368
00:12:56,480 --> 00:12:59,040
so to summarize that we could bypass

369
00:12:59,040 --> 00:13:00,240
bypass

370
00:13:00,240 --> 00:13:02,639
ip restrictions in api gateway resource

371
00:13:02,639 --> 00:13:04,800
policies by adding this header and the

372
00:13:04,800 --> 00:13:07,839
slide to the request

373
00:13:08,639 --> 00:13:10,720
another similar example that i have also

374
00:13:10,720 --> 00:13:12,639
reported to aws

375
00:13:12,639 --> 00:13:14,959
was incognito which is used for identity

376
00:13:14,959 --> 00:13:16,480
management

377
00:13:16,480 --> 00:13:19,040
now cognito on a penetration test that i

378
00:13:19,040 --> 00:13:21,680
was working on their cognito instance

379
00:13:21,680 --> 00:13:24,959
was limiting access to the clients

380
00:13:24,959 --> 00:13:27,279
whereas rate limiting you so if you send

381
00:13:27,279 --> 00:13:29,040
too many requests i believe was five

382
00:13:29,040 --> 00:13:31,120
within a short period of time your ip

383
00:13:31,120 --> 00:13:34,079
address will get blocked for a while

384
00:13:34,079 --> 00:13:35,440
however

385
00:13:35,440 --> 00:13:37,200
i've discovered that if you add the x

386
00:13:37,200 --> 00:13:39,440
folded four header with that's a

387
00:13:39,440 --> 00:13:41,519
vertical tab after the colon you can see

388
00:13:41,519 --> 00:13:43,600
in the slide there and then any other

389
00:13:43,600 --> 00:13:45,040
value

390
00:13:45,040 --> 00:13:47,040
your you would no longer be blocked and

391
00:13:47,040 --> 00:13:49,199
you'd get five more requests it's

392
00:13:49,199 --> 00:13:50,880
important to note here that you couldn't

393
00:13:50,880 --> 00:13:53,120
cycle the bank of this header including

394
00:13:53,120 --> 00:13:56,000
valid ip addresses and you wouldn't get

395
00:13:56,000 --> 00:13:57,920
any more requests so this is a very

396
00:13:57,920 --> 00:14:00,320
minor bug that takes your limit from

397
00:14:00,320 --> 00:14:02,560
five requests to 10 total within a short

398
00:14:02,560 --> 00:14:03,839
period of time

399
00:14:03,839 --> 00:14:06,320
however i feel it's quite a nice demo of

400
00:14:06,320 --> 00:14:08,079
what can be done and even though the

401
00:14:08,079 --> 00:14:10,079
impact is minimal i think it's worth

402
00:14:10,079 --> 00:14:14,199
mentioning just as an example

403
00:14:17,839 --> 00:14:19,360
another example we're going to look at

404
00:14:19,360 --> 00:14:21,600
today is cash poisoning

405
00:14:21,600 --> 00:14:23,760
so i reported the issue

406
00:14:23,760 --> 00:14:26,079
with bypassing the resource policy ipa

407
00:14:26,079 --> 00:14:28,399
address restrictions to aws

408
00:14:28,399 --> 00:14:30,800
and they fairly promptly fixed it

409
00:14:30,800 --> 00:14:32,399
however i noticed that i could still

410
00:14:32,399 --> 00:14:33,839
sneak headers through to back-end

411
00:14:33,839 --> 00:14:36,240
servers using that same mutation of

412
00:14:36,240 --> 00:14:37,600
adding a space and some trading

413
00:14:37,600 --> 00:14:39,040
characters

414
00:14:39,040 --> 00:14:40,959
so i started to think about

415
00:14:40,959 --> 00:14:42,959
what else could i add here that could be

416
00:14:42,959 --> 00:14:44,639
interesting

417
00:14:44,639 --> 00:14:46,320
now there's probably a lot of headers

418
00:14:46,320 --> 00:14:48,639
that turn onto api gateway that would be

419
00:14:48,639 --> 00:14:49,920
interesting if you knew them but i

420
00:14:49,920 --> 00:14:51,440
couldn't find any

421
00:14:51,440 --> 00:14:53,199
however one that perhaps is quite

422
00:14:53,199 --> 00:14:55,040
interesting is the host header as it's a

423
00:14:55,040 --> 00:14:58,240
bit more fundamental to the request

424
00:14:58,240 --> 00:15:01,120
so i set up two apis to test with the

425
00:15:01,120 --> 00:15:02,880
first one you can see here is this

426
00:15:02,880 --> 00:15:05,760
victim api and a request to slash a on

427
00:15:05,760 --> 00:15:09,040
this will just give you real response a

428
00:15:09,040 --> 00:15:12,480
the second api is this attacker api

429
00:15:12,480 --> 00:15:14,399
and for reasons we'll see in a second

430
00:15:14,399 --> 00:15:16,720
this responds with poisoned a when you

431
00:15:16,720 --> 00:15:18,560
request it

432
00:15:18,560 --> 00:15:21,279
so the question is what happens when i

433
00:15:21,279 --> 00:15:23,199
send the following request

434
00:15:23,199 --> 00:15:24,800
here we have two host headers an

435
00:15:24,800 --> 00:15:26,639
unmutated one which

436
00:15:26,639 --> 00:15:28,800
is for the victim api and the mutated

437
00:15:28,800 --> 00:15:31,680
header which is for the attacker api

438
00:15:31,680 --> 00:15:33,920
well it turns out api gateway will give

439
00:15:33,920 --> 00:15:35,920
us the response for the attacker api

440
00:15:35,920 --> 00:15:39,519
this poisoned a response

441
00:15:39,680 --> 00:15:40,639
so

442
00:15:40,639 --> 00:15:42,079
this becomes interesting when we

443
00:15:42,079 --> 00:15:43,759
introduce a cache

444
00:15:43,759 --> 00:15:45,759
to test i set up cloudfront in front of

445
00:15:45,759 --> 00:15:48,480
my api gateway instance and i set the

446
00:15:48,480 --> 00:15:50,720
all viewer request policy which

447
00:15:50,720 --> 00:15:52,399
effectively means that cloudfront will

448
00:15:52,399 --> 00:15:55,440
forward all headers to api gateway

449
00:15:55,440 --> 00:15:56,959
i then sent the request from the

450
00:15:56,959 --> 00:15:58,399
previous slide

451
00:15:58,399 --> 00:16:00,639
now cloudfront doesn't pass this mutated

452
00:16:00,639 --> 00:16:03,199
host header so it sees the host header

453
00:16:03,199 --> 00:16:06,720
for the victim api and it thinks the url

454
00:16:06,720 --> 00:16:08,959
is for the victims api

455
00:16:08,959 --> 00:16:11,440
however api gateway for this request

456
00:16:11,440 --> 00:16:13,040
gives us a response from the attackers

457
00:16:13,040 --> 00:16:15,360
api which the attacker controls in this

458
00:16:15,360 --> 00:16:17,120
scenario

459
00:16:17,120 --> 00:16:19,199
what happens as a result here is

460
00:16:19,199 --> 00:16:22,000
cloudfront will cache the result under

461
00:16:22,000 --> 00:16:24,800
the victim's api cache but the response

462
00:16:24,800 --> 00:16:26,160
will be completely controlled by the

463
00:16:26,160 --> 00:16:27,440
attacker

464
00:16:27,440 --> 00:16:29,839
this allows an attacker to target a

465
00:16:29,839 --> 00:16:31,759
victim using cloudfront or any other

466
00:16:31,759 --> 00:16:33,279
caching proxy which will forward these

467
00:16:33,279 --> 00:16:36,639
headers in front of api gateway and just

468
00:16:36,639 --> 00:16:39,279
overwrite any responses in their cache

469
00:16:39,279 --> 00:16:41,279
with any value completely under the

470
00:16:41,279 --> 00:16:44,240
attacker's control

471
00:16:45,839 --> 00:16:48,000
now we're also going to look at cl.cl

472
00:16:48,000 --> 00:16:50,240
request smuggling i.e request smuggling

473
00:16:50,240 --> 00:16:52,880
based on two content length headers

474
00:16:52,880 --> 00:16:55,040
now a lot of requests only recently has

475
00:16:55,040 --> 00:16:56,800
been based on the use of a transfer

476
00:16:56,800 --> 00:16:59,120
encoding and a content length header

477
00:16:59,120 --> 00:17:02,399
however at blackhat usa 2020 amic client

478
00:17:02,399 --> 00:17:04,959
presents debug in squid and abyss which

479
00:17:04,959 --> 00:17:07,359
was based on two content length headers

480
00:17:07,359 --> 00:17:10,240
one of them being mutated

481
00:17:10,240 --> 00:17:12,240
now he detected this through white box

482
00:17:12,240 --> 00:17:14,799
testing but i was curious about whether

483
00:17:14,799 --> 00:17:16,319
it was possible to detect these sorts of

484
00:17:16,319 --> 00:17:18,480
bugs through black box testing and

485
00:17:18,480 --> 00:17:20,160
importantly whether it was possible to

486
00:17:20,160 --> 00:17:21,599
do it safely

487
00:17:21,599 --> 00:17:23,119
so those of you familiar with james

488
00:17:23,119 --> 00:17:25,119
kettle's detection techniques based on

489
00:17:25,119 --> 00:17:27,280
timeouts for request smuggling might be

490
00:17:27,280 --> 00:17:29,280
wondering why we can't just adapt those

491
00:17:29,280 --> 00:17:30,880
directly

492
00:17:30,880 --> 00:17:32,320
the issue is when you're looking at

493
00:17:32,320 --> 00:17:35,120
cl.cl request smuggling if you don't

494
00:17:35,120 --> 00:17:36,880
know which server is going to pass which

495
00:17:36,880 --> 00:17:38,720
header out of the front end of backend

496
00:17:38,720 --> 00:17:41,520
server you have a 50 chance of causing a

497
00:17:41,520 --> 00:17:43,840
timeout in the vulnerable system but you

498
00:17:43,840 --> 00:17:45,919
also have a 50 chance of leaving some

499
00:17:45,919 --> 00:17:47,679
data in the socket and affecting another

500
00:17:47,679 --> 00:17:49,679
user's request and this is something we

501
00:17:49,679 --> 00:17:52,880
generally want to avoid

502
00:17:53,600 --> 00:17:55,840
so just to recap the setup

503
00:17:55,840 --> 00:17:58,640
we have squid acting as a front end

504
00:17:58,640 --> 00:18:00,880
doing some caching in front of abyss now

505
00:18:00,880 --> 00:18:02,559
you can exploit this bug to do more than

506
00:18:02,559 --> 00:18:04,400
caching you can directly affect other

507
00:18:04,400 --> 00:18:05,760
users requests

508
00:18:05,760 --> 00:18:07,840
however i'm showing caching here as i

509
00:18:07,840 --> 00:18:10,400
think it's the nicest sort of simple way

510
00:18:10,400 --> 00:18:13,200
to show this bug

511
00:18:13,200 --> 00:18:15,679
now so the bug that amicline presented

512
00:18:15,679 --> 00:18:18,320
looks like this we start with a fairly

513
00:18:18,320 --> 00:18:20,720
normal post request shown here in green

514
00:18:20,720 --> 00:18:22,559
the only slightly strange thing about it

515
00:18:22,559 --> 00:18:24,880
is we have two content length headers

516
00:18:24,880 --> 00:18:27,200
one unmutated content length header

517
00:18:27,200 --> 00:18:29,440
which says the length of the body is 33

518
00:18:29,440 --> 00:18:31,919
bytes and one mutated content length

519
00:18:31,919 --> 00:18:33,760
header which says the length of the body

520
00:18:33,760 --> 00:18:35,600
is zero bytes

521
00:18:35,600 --> 00:18:37,360
now what's going to happen is our

522
00:18:37,360 --> 00:18:40,160
front-end server squid is going to read

523
00:18:40,160 --> 00:18:42,799
our unmutated content length header and

524
00:18:42,799 --> 00:18:44,960
believe that this is a post request with

525
00:18:44,960 --> 00:18:48,000
a body of length 33 bytes so it sees two

526
00:18:48,000 --> 00:18:50,320
requests in this stream the first being

527
00:18:50,320 --> 00:18:52,400
what we have in green without post

528
00:18:52,400 --> 00:18:54,559
request and the body of this post

529
00:18:54,559 --> 00:18:56,720
request is shown in blue

530
00:18:56,720 --> 00:18:58,320
it then thinks the second request in

531
00:18:58,320 --> 00:19:00,960
this stream starts in red there and is a

532
00:19:00,960 --> 00:19:02,960
request and is a get request to the

533
00:19:02,960 --> 00:19:05,200
slash doesn't exist page

534
00:19:05,200 --> 00:19:06,720
so it's going to cache the result of

535
00:19:06,720 --> 00:19:09,360
this request for the path slash doesn't

536
00:19:09,360 --> 00:19:11,280
exist

537
00:19:11,280 --> 00:19:12,880
however

538
00:19:12,880 --> 00:19:15,039
the back end server abyss is going to

539
00:19:15,039 --> 00:19:17,520
read on mutated content length header

540
00:19:17,520 --> 00:19:19,039
which says that the length of the

541
00:19:19,039 --> 00:19:21,360
request is 0 bytes the length of the

542
00:19:21,360 --> 00:19:23,200
body is 0 bytes even

543
00:19:23,200 --> 00:19:25,120
so it thinks that the second request in

544
00:19:25,120 --> 00:19:27,200
the stream starts in blue there that

545
00:19:27,200 --> 00:19:30,320
request to slash a.html with a header

546
00:19:30,320 --> 00:19:31,840
called something and a value it just

547
00:19:31,840 --> 00:19:33,600
doesn't really care about

548
00:19:33,600 --> 00:19:35,679
and then again it's a request as before

549
00:19:35,679 --> 00:19:39,840
to squidoo1 to rs lab

550
00:19:40,080 --> 00:19:40,799
so

551
00:19:40,799 --> 00:19:42,799
just to show this in a diagram we have

552
00:19:42,799 --> 00:19:44,640
squid on the front end

553
00:19:44,640 --> 00:19:46,400
reading the unmutated content length

554
00:19:46,400 --> 00:19:48,400
header i'm thinking the second request

555
00:19:48,400 --> 00:19:50,720
is to the slash doesn't exist path

556
00:19:50,720 --> 00:19:52,799
and abyss on the back end reading our

557
00:19:52,799 --> 00:19:54,640
mutated content length header and

558
00:19:54,640 --> 00:19:56,400
thinking the second request is two slash

559
00:19:56,400 --> 00:19:58,080
a.html

560
00:19:58,080 --> 00:19:59,919
so squid is going to cache the value of

561
00:19:59,919 --> 00:20:02,720
a.html under a different path and this

562
00:20:02,720 --> 00:20:04,960
is the simple demo to show that cache

563
00:20:04,960 --> 00:20:07,440
poisoning exists

564
00:20:07,440 --> 00:20:10,159
so how do we detect this black box well

565
00:20:10,159 --> 00:20:12,080
we're working with detecting mutations

566
00:20:12,080 --> 00:20:13,520
here and that's something we've already

567
00:20:13,520 --> 00:20:14,880
looked at

568
00:20:14,880 --> 00:20:16,240
so we just need to modify our

569
00:20:16,240 --> 00:20:18,400
methodology slightly

570
00:20:18,400 --> 00:20:20,080
so this might look fairly similar to

571
00:20:20,080 --> 00:20:22,400
before we've got a post request and the

572
00:20:22,400 --> 00:20:23,760
slightly strange thing about it is we

573
00:20:23,760 --> 00:20:26,000
have two content length headers and one

574
00:20:26,000 --> 00:20:27,440
of them is mutated

575
00:20:27,440 --> 00:20:29,360
now we start off by setting the value of

576
00:20:29,360 --> 00:20:31,039
both of these to zero

577
00:20:31,039 --> 00:20:33,280
and we get a 200 okay and the response

578
00:20:33,280 --> 00:20:35,679
we expect for this post request

579
00:20:35,679 --> 00:20:37,600
so we know that this is being passed as

580
00:20:37,600 --> 00:20:40,880
normal and we haven't broken anything

581
00:20:40,880 --> 00:20:43,360
then we put an invalid value inside the

582
00:20:43,360 --> 00:20:45,840
content length header that isn't mutated

583
00:20:45,840 --> 00:20:48,640
so this content length z you see here

584
00:20:48,640 --> 00:20:50,960
and unsurprisingly we get an error in

585
00:20:50,960 --> 00:20:53,840
this case a 411 length required as one

586
00:20:53,840 --> 00:20:55,280
of the servers in the chain is trying to

587
00:20:55,280 --> 00:20:56,799
look at the content length of this post

588
00:20:56,799 --> 00:20:58,559
request and not be able to find it due

589
00:20:58,559 --> 00:21:01,200
to our invalid value

590
00:21:01,200 --> 00:21:03,360
uh so similarly we try again with the

591
00:21:03,360 --> 00:21:05,200
mutated content length header now i'm

592
00:21:05,200 --> 00:21:07,120
showing this request with zero bytes in

593
00:21:07,120 --> 00:21:08,559
both headers

594
00:21:08,559 --> 00:21:10,720
again for comparison

595
00:21:10,720 --> 00:21:12,720
but when we push an invalid value in our

596
00:21:12,720 --> 00:21:14,880
mutated content length header we also

597
00:21:14,880 --> 00:21:17,039
get an error however it's a different

598
00:21:17,039 --> 00:21:19,280
error to what we saw last time

599
00:21:19,280 --> 00:21:21,039
so we can infer that this error has been

600
00:21:21,039 --> 00:21:22,960
generated by a different server in the

601
00:21:22,960 --> 00:21:25,039
chain

602
00:21:25,039 --> 00:21:26,080
so

603
00:21:26,080 --> 00:21:27,919
we now know that we have two servers

604
00:21:27,919 --> 00:21:30,799
server a and server b server a is

605
00:21:30,799 --> 00:21:32,720
reading our unmutated content length

606
00:21:32,720 --> 00:21:34,720
header and server b is reading our

607
00:21:34,720 --> 00:21:37,200
mutated content length header we don't

608
00:21:37,200 --> 00:21:39,120
actually know at this point which is the

609
00:21:39,120 --> 00:21:40,799
front-end server and which is the

610
00:21:40,799 --> 00:21:42,400
back-end server and this is very

611
00:21:42,400 --> 00:21:44,320
important to know this before we

612
00:21:44,320 --> 00:21:46,080
continue testing so that we can continue

613
00:21:46,080 --> 00:21:48,480
testing safely and minimize the danger

614
00:21:48,480 --> 00:21:51,919
of affecting another user's request

615
00:21:51,919 --> 00:21:53,600
so to find out which is a front-end

616
00:21:53,600 --> 00:21:56,240
server we do something quite simple we

617
00:21:56,240 --> 00:21:58,159
just send a post request with only one

618
00:21:58,159 --> 00:22:00,240
content length header not mutated and

619
00:22:00,240 --> 00:22:02,240
put an imbalanced value in it

620
00:22:02,240 --> 00:22:04,000
we expect the front end server to pass

621
00:22:04,000 --> 00:22:06,080
this request as we expect any server to

622
00:22:06,080 --> 00:22:09,120
pass it and we see a 411 length required

623
00:22:09,120 --> 00:22:10,559
which we can assume is from the front

624
00:22:10,559 --> 00:22:13,760
end server comparing to our testing

625
00:22:13,760 --> 00:22:16,400
earlier this is the same as when we put

626
00:22:16,400 --> 00:22:17,840
this value in the unmutated header

627
00:22:17,840 --> 00:22:18,799
before

628
00:22:18,799 --> 00:22:20,400
so we can assume that when we send two

629
00:22:20,400 --> 00:22:22,480
headers it's the front-end server in

630
00:22:22,480 --> 00:22:25,039
this case squid which is reading the

631
00:22:25,039 --> 00:22:27,039
unmutated content length header and

632
00:22:27,039 --> 00:22:28,880
therefore the back end server abyss

633
00:22:28,880 --> 00:22:31,760
reasonably mutated one

634
00:22:31,760 --> 00:22:33,440
so we've got quite a good chance of

635
00:22:33,440 --> 00:22:35,280
request smuggling here as we can send

636
00:22:35,280 --> 00:22:37,440
two content length headers and specify

637
00:22:37,440 --> 00:22:39,520
different content lengths in them and

638
00:22:39,520 --> 00:22:41,360
this and the two servers that we're

639
00:22:41,360 --> 00:22:42,480
looking at

640
00:22:42,480 --> 00:22:44,240
will think the request has a different

641
00:22:44,240 --> 00:22:46,000
body to each other

642
00:22:46,000 --> 00:22:48,080
however this doesn't guarantee request

643
00:22:48,080 --> 00:22:50,000
modeling that's quite important to

644
00:22:50,000 --> 00:22:51,679
highlight you actually need to continue

645
00:22:51,679 --> 00:22:53,039
testing

646
00:22:53,039 --> 00:22:54,799
it's quite common in this sort of

647
00:22:54,799 --> 00:22:56,640
scenario for the back-end server to

648
00:22:56,640 --> 00:22:58,159
actually be looking at both content

649
00:22:58,159 --> 00:23:00,559
length headers and continuing as normal

650
00:23:00,559 --> 00:23:02,480
if they have the same value but as soon

651
00:23:02,480 --> 00:23:04,320
as you put a different value in those

652
00:23:04,320 --> 00:23:06,400
headers it will complain and throw an

653
00:23:06,400 --> 00:23:09,200
error at you so you can generate a

654
00:23:09,200 --> 00:23:11,520
timeout in a similar way to james

655
00:23:11,520 --> 00:23:13,120
kettle's research by essentially

656
00:23:13,120 --> 00:23:15,360
starving the back end of content and

657
00:23:15,360 --> 00:23:16,559
full details of that will be in the

658
00:23:16,559 --> 00:23:18,320
white paper as well as some exploitation

659
00:23:18,320 --> 00:23:19,440
scripts

660
00:23:19,440 --> 00:23:21,039
but the general advice from here is that

661
00:23:21,039 --> 00:23:22,799
you need to confirm beyond this and

662
00:23:22,799 --> 00:23:24,080
often you have to actually just try

663
00:23:24,080 --> 00:23:26,240
exploit the system which obviously you

664
00:23:26,240 --> 00:23:29,600
have to be quite careful about

665
00:23:30,799 --> 00:23:33,039
so we've looked at some

666
00:23:33,039 --> 00:23:35,679
header smuggling and the question is

667
00:23:35,679 --> 00:23:37,840
how do we defend against this

668
00:23:37,840 --> 00:23:39,760
well part of the defense i recommend is

669
00:23:39,760 --> 00:23:41,440
to use the tooling i'm going to be

670
00:23:41,440 --> 00:23:43,679
releasing as part of this research and

671
00:23:43,679 --> 00:23:45,679
scan any systems you're conf you're

672
00:23:45,679 --> 00:23:47,840
concerned about

673
00:23:47,840 --> 00:23:50,559
another piece of defense i consider key

674
00:23:50,559 --> 00:23:52,400
is on front-end servers

675
00:23:52,400 --> 00:23:55,360
don't forward malformed or suspicious

676
00:23:55,360 --> 00:23:56,720
headers

677
00:23:56,720 --> 00:23:58,960
so cloudflare don't afford headers with

678
00:23:58,960 --> 00:24:00,880
a space in for example

679
00:24:00,880 --> 00:24:02,799
and that saved them from being used in

680
00:24:02,799 --> 00:24:05,120
the example earlier with api gateway and

681
00:24:05,120 --> 00:24:07,520
the cache poisoning

682
00:24:07,520 --> 00:24:09,760
and this is also the approach that aws

683
00:24:09,760 --> 00:24:11,919
are taking to resolve this issue within

684
00:24:11,919 --> 00:24:14,000
api gateway they're writing a lot of

685
00:24:14,000 --> 00:24:16,000
tests to test the services with an api

686
00:24:16,000 --> 00:24:18,320
gateway to make sure they don't forward

687
00:24:18,320 --> 00:24:21,200
these malformed headers

688
00:24:21,200 --> 00:24:22,640
and there's also this concept that you

689
00:24:22,640 --> 00:24:24,720
should be quite liberal about passing

690
00:24:24,720 --> 00:24:27,039
protocols such as http

691
00:24:27,039 --> 00:24:29,360
however if it's for a back-end server

692
00:24:29,360 --> 00:24:30,799
and you're expecting the request to be

693
00:24:30,799 --> 00:24:32,880
filtered or normalized by a front-end

694
00:24:32,880 --> 00:24:35,679
server this doesn't necessarily apply as

695
00:24:35,679 --> 00:24:37,200
you won't be seeing requests from all

696
00:24:37,200 --> 00:24:39,279
sorts of different implementations of

697
00:24:39,279 --> 00:24:41,760
http you should only be seeing requests

698
00:24:41,760 --> 00:24:44,080
from one implementation so you can be a

699
00:24:44,080 --> 00:24:46,240
lot more strict and that can help defend

700
00:24:46,240 --> 00:24:49,600
against these vulnerabilities

701
00:24:49,840 --> 00:24:52,480
now in terms of future research i think

702
00:24:52,480 --> 00:24:54,080
there are plenty more applications to be

703
00:24:54,080 --> 00:24:56,480
found i'd recommend that you just go and

704
00:24:56,480 --> 00:24:58,559
scan as many systems as you can with my

705
00:24:58,559 --> 00:25:01,120
modified turbo intruder find interesting

706
00:25:01,120 --> 00:25:03,200
behavior that you probably can't predict

707
00:25:03,200 --> 00:25:05,440
right now and go play with it and see if

708
00:25:05,440 --> 00:25:07,760
you can exploit something

709
00:25:07,760 --> 00:25:10,400
we've of course also seen a lot of http

710
00:25:10,400 --> 00:25:12,720
2 request smuggling research this year

711
00:25:12,720 --> 00:25:16,080
focused on http 2 to 81 downgrades and

712
00:25:16,080 --> 00:25:18,320
this has also led to lots of new ways to

713
00:25:18,320 --> 00:25:20,159
sneak headers through to the back end

714
00:25:20,159 --> 00:25:21,520
with the focus on the transfer and

715
00:25:21,520 --> 00:25:23,520
coding header in general

716
00:25:23,520 --> 00:25:25,279
so these techniques i haven't looked at

717
00:25:25,279 --> 00:25:27,200
as part of my research but that could

718
00:25:27,200 --> 00:25:28,480
definitely provide some interesting

719
00:25:28,480 --> 00:25:30,720
results if you go and look at those

720
00:25:30,720 --> 00:25:32,320
i've also made some assumptions in my

721
00:25:32,320 --> 00:25:33,679
research which are probably worth

722
00:25:33,679 --> 00:25:35,840
addressing i've assumed that front and

723
00:25:35,840 --> 00:25:37,279
back end servers will give different

724
00:25:37,279 --> 00:25:38,799
errors to each other

725
00:25:38,799 --> 00:25:40,159
i've also assumed that all headers are

726
00:25:40,159 --> 00:25:42,000
passed the same so if you find one

727
00:25:42,000 --> 00:25:44,080
mutation that works with a content

728
00:25:44,080 --> 00:25:45,679
length header we're assuming it works

729
00:25:45,679 --> 00:25:47,840
with every other header which may not be

730
00:25:47,840 --> 00:25:51,279
true although it generally seems to be

731
00:25:51,279 --> 00:25:53,120
and i've also assumed that all servers

732
00:25:53,120 --> 00:25:55,279
pass the content length header and get

733
00:25:55,279 --> 00:25:57,760
requests which is mostly true but there

734
00:25:57,760 --> 00:25:59,120
are definitely some servers i've seen

735
00:25:59,120 --> 00:26:00,799
which don't do this

736
00:26:00,799 --> 00:26:02,240
so those will be missed by the

737
00:26:02,240 --> 00:26:05,200
methodology of this research

738
00:26:05,200 --> 00:26:06,720
now there are some references here which

739
00:26:06,720 --> 00:26:08,960
i'd encourage you to go check out these

740
00:26:08,960 --> 00:26:10,320
have really been informative in this

741
00:26:10,320 --> 00:26:12,159
research there's also some other

742
00:26:12,159 --> 00:26:14,000
resources which again you can find in

743
00:26:14,000 --> 00:26:15,760
the slides and if you found this talk

744
00:26:15,760 --> 00:26:17,039
interesting i think you should probably

745
00:26:17,039 --> 00:26:18,400
have a look at these as you'll enjoy

746
00:26:18,400 --> 00:26:19,919
them as well

747
00:26:19,919 --> 00:26:22,320
and thank you for coming so links to our

748
00:26:22,320 --> 00:26:24,000
blogs there i'd like to say a massive

749
00:26:24,000 --> 00:26:26,000
thank you to the aws security team

750
00:26:26,000 --> 00:26:27,919
who've been really helpful and really

751
00:26:27,919 --> 00:26:29,120
good to work with throughout this

752
00:26:29,120 --> 00:26:31,120
research

753
00:26:31,120 --> 00:26:33,039
and also we're hiring so you have a bit

754
00:26:33,039 --> 00:26:35,279
of experience come and talk to us

755
00:26:35,279 --> 00:26:38,170
and are there any questions

756
00:26:38,170 --> 00:26:47,779
[Music]

