1
00:00:00,910 --> 00:00:09,040
[Music]

2
00:00:09,040 --> 00:00:11,200
hello everybody my name is dana and i'm

3
00:00:11,200 --> 00:00:13,040
here with my colleague martin and today

4
00:00:13,040 --> 00:00:15,839
we will discuss about usb based attacks

5
00:00:15,839 --> 00:00:17,440
at rescuer we do a lot of embedded

6
00:00:17,440 --> 00:00:19,520
research and today we would like to tell

7
00:00:19,520 --> 00:00:22,160
you the story of how we use what we call

8
00:00:22,160 --> 00:00:23,680
the forgotten vulnerability to

9
00:00:23,680 --> 00:00:26,160
compromise our target by just inserting

10
00:00:26,160 --> 00:00:28,400
a malicious usb device

11
00:00:28,400 --> 00:00:30,720
so our agenda for today is the following

12
00:00:30,720 --> 00:00:32,640
we will discuss about the relevance of

13
00:00:32,640 --> 00:00:35,360
usb based attacks we will then tell you

14
00:00:35,360 --> 00:00:36,880
a little bit more about the forgotten

15
00:00:36,880 --> 00:00:38,399
vulnerability

16
00:00:38,399 --> 00:00:39,840
after that we will share our

17
00:00:39,840 --> 00:00:42,320
exploitation methods and approach

18
00:00:42,320 --> 00:00:44,559
and we will show you how this attack

19
00:00:44,559 --> 00:00:46,719
looks like by giving a demo

20
00:00:46,719 --> 00:00:48,879
and we will conclude our presentation by

21
00:00:48,879 --> 00:00:51,039
giving a few discussion points on our

22
00:00:51,039 --> 00:00:53,039
final takeaways

23
00:00:53,039 --> 00:00:53,920
so

24
00:00:53,920 --> 00:00:56,559
why do we care about usb based attacks

25
00:00:56,559 --> 00:00:58,800
so there are several reasons for this

26
00:00:58,800 --> 00:01:01,680
but here we will only mention the main

27
00:01:01,680 --> 00:01:03,039
the ones that we consider that are the

28
00:01:03,039 --> 00:01:04,239
main ones

29
00:01:04,239 --> 00:01:06,880
the first reason is that the usb

30
00:01:06,880 --> 00:01:09,439
interface is available in pretty much

31
00:01:09,439 --> 00:01:11,680
all devices

32
00:01:11,680 --> 00:01:14,000
even closed down devices actually

33
00:01:14,000 --> 00:01:16,720
support typically usb interfaces the

34
00:01:16,720 --> 00:01:19,920
second reason is that the usb interface

35
00:01:19,920 --> 00:01:21,680
is generally available from the moment

36
00:01:21,680 --> 00:01:23,920
the device is powered on till the moment

37
00:01:23,920 --> 00:01:26,640
the device is powered off that makes it

38
00:01:26,640 --> 00:01:28,240
really interesting

39
00:01:28,240 --> 00:01:30,479
the third reason is that the usb

40
00:01:30,479 --> 00:01:32,799
protocol is quite complex and that makes

41
00:01:32,799 --> 00:01:34,159
it error prone

42
00:01:34,159 --> 00:01:36,159
c scholar has demonstrated in the last

43
00:01:36,159 --> 00:01:38,240
few years that there are still a lot of

44
00:01:38,240 --> 00:01:40,079
vulnerabilities to be uncovered in the

45
00:01:40,079 --> 00:01:42,880
usb drivers of the linux kernel

46
00:01:42,880 --> 00:01:45,200
and these vulnerabilities get found but

47
00:01:45,200 --> 00:01:48,000
they also get exploited in the wild and

48
00:01:48,000 --> 00:01:50,479
recent research has shown the potential

49
00:01:50,479 --> 00:01:52,479
of such vulnerabilities

50
00:01:52,479 --> 00:01:54,640
so now we can move forward to the

51
00:01:54,640 --> 00:01:57,600
forgotten vulnerability so what is this

52
00:01:57,600 --> 00:01:59,840
vulnerability about this is basically a

53
00:01:59,840 --> 00:02:01,759
double free in the linux kernel while we

54
00:02:01,759 --> 00:02:04,240
were doing research on our device we

55
00:02:04,240 --> 00:02:06,079
found this vulnerability to shortly

56
00:02:06,079 --> 00:02:08,239
after discover that a researcher called

57
00:02:08,239 --> 00:02:11,920
andre conovalo also founded in 2016. he

58
00:02:11,920 --> 00:02:13,920
actually made a really nice blog post

59
00:02:13,920 --> 00:02:15,360
where he explains about the

60
00:02:15,360 --> 00:02:17,120
vulnerability and his exploitation

61
00:02:17,120 --> 00:02:18,160
approach

62
00:02:18,160 --> 00:02:19,840
to give a little bit more details this

63
00:02:19,840 --> 00:02:21,920
is a vulnerability in the usb midi

64
00:02:21,920 --> 00:02:23,200
subsystem

65
00:02:23,200 --> 00:02:25,200
andrei demonstrated that it was possible

66
00:02:25,200 --> 00:02:27,120
to both cause a denial of service in the

67
00:02:27,120 --> 00:02:28,959
linux kernel but also gained code

68
00:02:28,959 --> 00:02:31,280
execution so he managed to turn this

69
00:02:31,280 --> 00:02:33,280
double free vulnerability into a use

70
00:02:33,280 --> 00:02:34,560
after free

71
00:02:34,560 --> 00:02:36,560
and he used um

72
00:02:36,560 --> 00:02:38,879
these two primitives to actually shape

73
00:02:38,879 --> 00:02:40,319
the heap and bring it into an

74
00:02:40,319 --> 00:02:41,840
exploitable state

75
00:02:41,840 --> 00:02:44,720
these are the cisco uh interface

76
00:02:44,720 --> 00:02:47,040
and also he used sockets in order to do

77
00:02:47,040 --> 00:02:50,080
this so now you may be asking yourself

78
00:02:50,080 --> 00:02:52,480
usb midi devices are not that common why

79
00:02:52,480 --> 00:02:55,760
do we care about this vulnerability well

80
00:02:55,760 --> 00:02:58,239
the fact is that this driver was enabled

81
00:02:58,239 --> 00:03:00,560
in pretty much every device that uses

82
00:03:00,560 --> 00:03:01,599
linux

83
00:03:01,599 --> 00:03:04,720
this meant that the issue affected even

84
00:03:04,720 --> 00:03:07,120
major distributions such as ubuntu and

85
00:03:07,120 --> 00:03:08,239
fedora

86
00:03:08,239 --> 00:03:09,920
of course in order to exploit this

87
00:03:09,920 --> 00:03:12,239
vulnerability you need physical access

88
00:03:12,239 --> 00:03:13,840
to the device

89
00:03:13,840 --> 00:03:16,400
so now you might also be asking yourself

90
00:03:16,400 --> 00:03:17,920
why do we still care right this

91
00:03:17,920 --> 00:03:19,680
vulnerability was found

92
00:03:19,680 --> 00:03:21,200
five years ago

93
00:03:21,200 --> 00:03:22,800
so we wanted to share

94
00:03:22,800 --> 00:03:25,680
um a little timeline with events

95
00:03:25,680 --> 00:03:28,959
to answer that question so in 2016 andre

96
00:03:28,959 --> 00:03:30,720
found the vulnerability and shortly

97
00:03:30,720 --> 00:03:33,440
after the issue was patched upstream and

98
00:03:33,440 --> 00:03:35,519
a cve was assigned to it

99
00:03:35,519 --> 00:03:37,760
four years later when martin and i were

100
00:03:37,760 --> 00:03:40,239
doing research on a device we stumbled

101
00:03:40,239 --> 00:03:42,640
across this vulnerability and two months

102
00:03:42,640 --> 00:03:44,959
later we actually had a successful

103
00:03:44,959 --> 00:03:46,480
exploit running

104
00:03:46,480 --> 00:03:48,319
this is the story that we will tell in

105
00:03:48,319 --> 00:03:50,000
this presentation how we managed to do

106
00:03:50,000 --> 00:03:50,959
that

107
00:03:50,959 --> 00:03:52,560
so just to give you a little bit of

108
00:03:52,560 --> 00:03:54,640
background on the device this is a

109
00:03:54,640 --> 00:03:56,799
broadly used device that's probably in

110
00:03:56,799 --> 00:03:59,519
millions of households

111
00:03:59,519 --> 00:04:01,840
it had a pretty trimmed down version of

112
00:04:01,840 --> 00:04:05,840
linux that was based on kernel 4.x

113
00:04:05,840 --> 00:04:08,239
and as far as we could see they were

114
00:04:08,239 --> 00:04:10,560
actively backporting all the security

115
00:04:10,560 --> 00:04:12,799
fixes or at least most of them

116
00:04:12,799 --> 00:04:14,560
the most important characteristic of

117
00:04:14,560 --> 00:04:16,880
this device is that it was completely

118
00:04:16,880 --> 00:04:18,079
locked down

119
00:04:18,079 --> 00:04:21,120
so our attack surface was really limited

120
00:04:21,120 --> 00:04:24,320
we only had one usb interface then a

121
00:04:24,320 --> 00:04:26,720
network interface and a heavily sandbox

122
00:04:26,720 --> 00:04:29,440
browser on top of that we did not have

123
00:04:29,440 --> 00:04:33,040
any sort of output so

124
00:04:33,040 --> 00:04:36,560
upon crashes we could not see anything

125
00:04:36,560 --> 00:04:38,479
the actual device is not relevant for

126
00:04:38,479 --> 00:04:40,560
this stock what we want to show is our

127
00:04:40,560 --> 00:04:43,040
exploitation approach on our methods

128
00:04:43,040 --> 00:04:45,199
so now let's dive a little bit deeper

129
00:04:45,199 --> 00:04:47,199
into the vulnerability to see how is

130
00:04:47,199 --> 00:04:48,080
this

131
00:04:48,080 --> 00:04:49,040
triggered

132
00:04:49,040 --> 00:04:51,199
so triggering this variability is

133
00:04:51,199 --> 00:04:53,280
surprisingly easy you just need to

134
00:04:53,280 --> 00:04:55,759
connect a misconfigure usb midi device

135
00:04:55,759 --> 00:04:58,080
and you will cause this to happen

136
00:04:58,080 --> 00:05:01,039
so when you start a device

137
00:05:01,039 --> 00:05:03,600
a process called probing will start so

138
00:05:03,600 --> 00:05:06,160
the linux kernel will start the process

139
00:05:06,160 --> 00:05:08,000
to find the proper drivers that can

140
00:05:08,000 --> 00:05:09,759
handle that device

141
00:05:09,759 --> 00:05:11,919
and an important thing to know is that

142
00:05:11,919 --> 00:05:14,160
the probing process is driven by the

143
00:05:14,160 --> 00:05:17,120
host in this case the host is our target

144
00:05:17,120 --> 00:05:19,680
so it all starts with the usb hub work

145
00:05:19,680 --> 00:05:22,400
you and this work you basically contains

146
00:05:22,400 --> 00:05:24,639
all the events that the kernel needs to

147
00:05:24,639 --> 00:05:26,880
handle related to usb

148
00:05:26,880 --> 00:05:29,120
then after that a handshake will start

149
00:05:29,120 --> 00:05:30,639
between the host and the device we

150
00:05:30,639 --> 00:05:33,039
insert and the host will be asking some

151
00:05:33,039 --> 00:05:35,520
questions like who are you what are your

152
00:05:35,520 --> 00:05:38,000
capabilities what's your name and there

153
00:05:38,000 --> 00:05:40,960
can be more messages depending on the

154
00:05:40,960 --> 00:05:42,639
first exchange

155
00:05:42,639 --> 00:05:44,320
the important thing to note there is

156
00:05:44,320 --> 00:05:46,400
that the device that we insert

157
00:05:46,400 --> 00:05:48,800
um does not have a lot of freedom it

158
00:05:48,800 --> 00:05:52,320
just needs to reply to the host requests

159
00:05:52,320 --> 00:05:53,440
and in a

160
00:05:53,440 --> 00:05:56,720
reply in a specific format

161
00:05:56,720 --> 00:05:58,080
so um

162
00:05:58,080 --> 00:05:59,919
along the road

163
00:05:59,919 --> 00:06:01,919
then we will start

164
00:06:01,919 --> 00:06:04,800
initializing objects and we will end up

165
00:06:04,800 --> 00:06:07,120
in the code that handles midi

166
00:06:07,120 --> 00:06:08,479
devices

167
00:06:08,479 --> 00:06:09,440
then

168
00:06:09,440 --> 00:06:11,440
the kernel will decide to allocate an

169
00:06:11,440 --> 00:06:14,240
object which here we call umidi

170
00:06:14,240 --> 00:06:16,080
on the heap

171
00:06:16,080 --> 00:06:18,080
since we are inserting a device that's

172
00:06:18,080 --> 00:06:20,080
misconfigured the kernel will also

173
00:06:20,080 --> 00:06:23,199
realize that this device is

174
00:06:23,199 --> 00:06:25,520
not properly

175
00:06:25,520 --> 00:06:27,600
showing its information and this will

176
00:06:27,600 --> 00:06:30,240
cause the first free of this

177
00:06:30,240 --> 00:06:32,240
object that was allocated but the

178
00:06:32,240 --> 00:06:35,280
process doesn't stop there because the

179
00:06:35,280 --> 00:06:38,479
error will be propagated and then

180
00:06:38,479 --> 00:06:41,919
as a probing failure result and the as

181
00:06:41,919 --> 00:06:44,160
the aftermath there will be a second

182
00:06:44,160 --> 00:06:47,360
free this is basically what causes the

183
00:06:47,360 --> 00:06:48,880
vulnerability

184
00:06:48,880 --> 00:06:49,919
to happen

185
00:06:49,919 --> 00:06:50,720
so

186
00:06:50,720 --> 00:06:54,560
let's now talk a bit about the linux

187
00:06:54,560 --> 00:06:56,160
memory allocator

188
00:06:56,160 --> 00:06:58,880
so since a really early version of linux

189
00:06:58,880 --> 00:07:01,759
slab is the default allocator this is

190
00:07:01,759 --> 00:07:03,840
the subsystem that handles allocations

191
00:07:03,840 --> 00:07:05,759
and the allocations of the kernel and

192
00:07:05,759 --> 00:07:07,840
the important thing for us

193
00:07:07,840 --> 00:07:10,160
is that in order to handle memory

194
00:07:10,160 --> 00:07:13,039
this allocator groups chunks into

195
00:07:13,039 --> 00:07:15,199
structures that we call slabs so

196
00:07:15,199 --> 00:07:17,919
basically all the objects that are of

197
00:07:17,919 --> 00:07:20,080
the same size

198
00:07:20,080 --> 00:07:22,560
end up in the same

199
00:07:22,560 --> 00:07:23,440
slot

200
00:07:23,440 --> 00:07:25,680
the thing is that of course not all the

201
00:07:25,680 --> 00:07:27,599
objects are going to be

202
00:07:27,599 --> 00:07:29,919
of the same size so upon receiving

203
00:07:29,919 --> 00:07:31,759
certain allocation requests the kernel

204
00:07:31,759 --> 00:07:34,160
will check it will round the size to an

205
00:07:34,160 --> 00:07:35,919
appropriate slab and then the slab will

206
00:07:35,919 --> 00:07:37,919
be chosen

207
00:07:37,919 --> 00:07:38,800
the

208
00:07:38,800 --> 00:07:41,360
slava locator also needs of course a way

209
00:07:41,360 --> 00:07:44,720
of keeping track of the chunks that are

210
00:07:44,720 --> 00:07:47,280
available for giving when a request

211
00:07:47,280 --> 00:07:49,919
comes this is done by

212
00:07:49,919 --> 00:07:52,160
using a free list that's basically a

213
00:07:52,160 --> 00:07:54,080
single linked list

214
00:07:54,080 --> 00:07:56,240
another important thing to know is that

215
00:07:56,240 --> 00:07:58,080
this single linked list is handled in a

216
00:07:58,080 --> 00:08:01,440
sort of a fifo way so first in first out

217
00:08:01,440 --> 00:08:04,319
that means that the first object that is

218
00:08:04,319 --> 00:08:06,160
inserted in the list will also be the

219
00:08:06,160 --> 00:08:09,440
first object to be given upon a memory

220
00:08:09,440 --> 00:08:11,199
allocation request

221
00:08:11,199 --> 00:08:12,400
and this

222
00:08:12,400 --> 00:08:14,560
specific behavior is really important

223
00:08:14,560 --> 00:08:18,080
for shaping our free list

224
00:08:18,080 --> 00:08:20,560
so in order to see what happens with the

225
00:08:20,560 --> 00:08:24,560
hip while this vulnerability

226
00:08:24,560 --> 00:08:27,199
happens we will see a series of images

227
00:08:27,199 --> 00:08:29,440
first we start with the free list as the

228
00:08:29,440 --> 00:08:32,320
kernel has it before anything happens

229
00:08:32,320 --> 00:08:34,958
once we allocate the umidi object the

230
00:08:34,958 --> 00:08:37,519
freely shape will change we will give

231
00:08:37,519 --> 00:08:39,839
away chunk one so then now the three

232
00:08:39,839 --> 00:08:42,559
lists will be pointing to chunk two

233
00:08:42,559 --> 00:08:44,560
when we do the first three if no other

234
00:08:44,560 --> 00:08:46,959
allocation happens in between

235
00:08:46,959 --> 00:08:49,839
we will get back to our initial state

236
00:08:49,839 --> 00:08:51,519
we will have the free list with all the

237
00:08:51,519 --> 00:08:54,399
chunks because chunk one will return the

238
00:08:54,399 --> 00:08:56,640
problem is that when we do the second

239
00:08:56,640 --> 00:08:57,519
free

240
00:08:57,519 --> 00:08:59,920
again if no other object was allocated

241
00:08:59,920 --> 00:09:02,160
in between we will end up in this

242
00:09:02,160 --> 00:09:05,120
situation this basically means that with

243
00:09:05,120 --> 00:09:07,120
this vulnerability we managed to corrupt

244
00:09:07,120 --> 00:09:09,200
the free list of the kernel and from

245
00:09:09,200 --> 00:09:11,760
this point on the kernel will constantly

246
00:09:11,760 --> 00:09:12,640
give

247
00:09:12,640 --> 00:09:15,279
this same chunk to all the allocations

248
00:09:15,279 --> 00:09:18,880
that are requested this opens the door

249
00:09:18,880 --> 00:09:20,839
for memory corruption

250
00:09:20,839 --> 00:09:23,920
attacks and as a closing remark for this

251
00:09:23,920 --> 00:09:26,320
section we want to show you the fix

252
00:09:26,320 --> 00:09:28,959
so basically the fix consisted in just

253
00:09:28,959 --> 00:09:32,959
removing one line of one of the freeze

254
00:09:32,959 --> 00:09:34,240
and that was it

255
00:09:34,240 --> 00:09:37,200
then the vulnerability was fixed

256
00:09:37,200 --> 00:09:39,360
now i would like to give the floor to

257
00:09:39,360 --> 00:09:41,040
martin who will talk about our

258
00:09:41,040 --> 00:09:44,079
exploitation approach

259
00:09:44,240 --> 00:09:46,240
so let's talk about how we actually

260
00:09:46,240 --> 00:09:48,080
exploited this vulnerability and the

261
00:09:48,080 --> 00:09:51,519
approach we took to develop our method

262
00:09:51,519 --> 00:09:54,000
so as we have seen devices are severely

263
00:09:54,000 --> 00:09:55,519
constrained in what they can do when

264
00:09:55,519 --> 00:09:57,760
they are communicated with the host and

265
00:09:57,760 --> 00:10:00,320
in principle they only can respond to

266
00:10:00,320 --> 00:10:02,079
the request the host is sending to the

267
00:10:02,079 --> 00:10:04,560
devices that means that devices cannot

268
00:10:04,560 --> 00:10:06,880
initiate arbitrary communication or send

269
00:10:06,880 --> 00:10:09,200
arbitrary data back to the host and this

270
00:10:09,200 --> 00:10:11,200
is severely limiting the exploitation

271
00:10:11,200 --> 00:10:13,120
primitives we have of to our

272
00:10:13,120 --> 00:10:14,800
availability

273
00:10:14,800 --> 00:10:16,800
to understand what we are working with

274
00:10:16,800 --> 00:10:18,720
we need to take a deeper look at the bd

275
00:10:18,720 --> 00:10:20,320
object and how

276
00:10:20,320 --> 00:10:21,839
what is happening with the heap of the

277
00:10:21,839 --> 00:10:25,360
system so the midi object is a structure

278
00:10:25,360 --> 00:10:28,480
of 272 bytes of memory and it gets

279
00:10:28,480 --> 00:10:31,040
allocated on the kernel heap and because

280
00:10:31,040 --> 00:10:34,399
it is 272 bytes and the kernel or the

281
00:10:34,399 --> 00:10:36,880
slab allocator is rounding up its sizes

282
00:10:36,880 --> 00:10:38,399
it means it will

283
00:10:38,399 --> 00:10:41,680
land on the slab for 512 byte objects

284
00:10:41,680 --> 00:10:43,839
and this slab has interesting

285
00:10:43,839 --> 00:10:45,600
characteristics at least interesting

286
00:10:45,600 --> 00:10:47,519
characteristics for exploiting the

287
00:10:47,519 --> 00:10:48,480
system

288
00:10:48,480 --> 00:10:50,720
what we found is that

289
00:10:50,720 --> 00:10:54,000
512 bytes is a nice amount for crafting

290
00:10:54,000 --> 00:10:56,480
our attack but what's way more important

291
00:10:56,480 --> 00:10:58,640
is that this slab is a relatively low

292
00:10:58,640 --> 00:11:01,279
activity actually we have noticed that

293
00:11:01,279 --> 00:11:03,760
this slab seems to be mostly used for

294
00:11:03,760 --> 00:11:06,160
network related activity and that are

295
00:11:06,160 --> 00:11:07,680
then also the things that might be

296
00:11:07,680 --> 00:11:10,240
interfering with our attack

297
00:11:10,240 --> 00:11:11,920
due to the fact that this is a

298
00:11:11,920 --> 00:11:14,560
relatively low activity slab this has

299
00:11:14,560 --> 00:11:15,920
been really one of the key

300
00:11:15,920 --> 00:11:17,600
characteristics that allows us to

301
00:11:17,600 --> 00:11:19,760
exploit this vulnerability on the system

302
00:11:19,760 --> 00:11:22,079
because we have to win the race between

303
00:11:22,079 --> 00:11:24,399
the double free and the actual

304
00:11:24,399 --> 00:11:26,000
fact that something is happening with

305
00:11:26,000 --> 00:11:28,399
the heap again

306
00:11:28,399 --> 00:11:30,480
so how are we going to turn this double

307
00:11:30,480 --> 00:11:32,399
free into something that is actually

308
00:11:32,399 --> 00:11:35,120
useful because after the double free we

309
00:11:35,120 --> 00:11:37,120
have a loop in our free list

310
00:11:37,120 --> 00:11:39,200
what we noticed is that all allocations

311
00:11:39,200 --> 00:11:41,920
that occur on the same cpu core and on

312
00:11:41,920 --> 00:11:43,360
the same slab

313
00:11:43,360 --> 00:11:45,279
actually are getting the same memory

314
00:11:45,279 --> 00:11:47,120
chunk assigned every time you do an

315
00:11:47,120 --> 00:11:48,880
allocation as has been explained by

316
00:11:48,880 --> 00:11:51,600
donna however this is just panicking the

317
00:11:51,600 --> 00:11:53,760
kernel in a matter of seconds

318
00:11:53,760 --> 00:11:56,240
so what is happening well we do multiple

319
00:11:56,240 --> 00:12:00,000
allocations each of them are returning

320
00:12:00,000 --> 00:12:02,320
the same address due to the loop we have

321
00:12:02,320 --> 00:12:04,079
in our system

322
00:12:04,079 --> 00:12:05,519
because it's a

323
00:12:05,519 --> 00:12:07,519
linked list what we actually have is we

324
00:12:07,519 --> 00:12:09,279
have the start of the list but we also

325
00:12:09,279 --> 00:12:11,519
have a pointer to the next chunk this

326
00:12:11,519 --> 00:12:13,200
pointer is stored at the first eight

327
00:12:13,200 --> 00:12:15,839
bytes of our chunk and due to the loop

328
00:12:15,839 --> 00:12:18,560
in the list it is pointing to itself

329
00:12:18,560 --> 00:12:22,720
that also means that when we are

330
00:12:22,720 --> 00:12:24,560
updating the free list or actually

331
00:12:24,560 --> 00:12:27,040
actually allocating memory we will take

332
00:12:27,040 --> 00:12:30,079
this pointer from the start of the check

333
00:12:30,079 --> 00:12:31,680
this means that when we have an

334
00:12:31,680 --> 00:12:34,240
allocated jump and we are writing data

335
00:12:34,240 --> 00:12:35,440
to it

336
00:12:35,440 --> 00:12:37,120
due to the loop in the free list the

337
00:12:37,120 --> 00:12:38,480
next allocation

338
00:12:38,480 --> 00:12:40,959
will actually start using the address

339
00:12:40,959 --> 00:12:42,000
that we

340
00:12:42,000 --> 00:12:44,240
have at the beginning of that chunk

341
00:12:44,240 --> 00:12:45,600
this means that if we have two

342
00:12:45,600 --> 00:12:47,839
consecutive allocations and we control

343
00:12:47,839 --> 00:12:50,320
the content of those allocations we can

344
00:12:50,320 --> 00:12:52,480
actually make the free list point to an

345
00:12:52,480 --> 00:12:54,639
arbitrary location in memory and the

346
00:12:54,639 --> 00:12:56,800
third allocation will then return the

347
00:12:56,800 --> 00:12:58,560
address we have put in the freelance

348
00:12:58,560 --> 00:13:00,000
pointer

349
00:13:00,000 --> 00:13:02,079
if you then control the content that is

350
00:13:02,079 --> 00:13:04,079
written to that address we have an

351
00:13:04,079 --> 00:13:06,320
arbitrary right primitive in our system

352
00:13:06,320 --> 00:13:09,279
and this is the base primitive for the x

353
00:13:09,279 --> 00:13:12,160
for our exploit

354
00:13:12,160 --> 00:13:14,480
so what do we have we have a chunk on

355
00:13:14,480 --> 00:13:16,560
the 512 by swap

356
00:13:16,560 --> 00:13:18,800
we need to have three memory allocations

357
00:13:18,800 --> 00:13:20,959
in a row and we need to control the data

358
00:13:20,959 --> 00:13:23,600
of those memory allocations ideally we

359
00:13:23,600 --> 00:13:25,680
control the content that is written to

360
00:13:25,680 --> 00:13:28,320
all allocations however we can't get

361
00:13:28,320 --> 00:13:30,320
away with if it's only controlling the

362
00:13:30,320 --> 00:13:32,399
first and the last allocation the first

363
00:13:32,399 --> 00:13:35,279
allocation we need to set the address

364
00:13:35,279 --> 00:13:37,760
that we are going to target with our

365
00:13:37,760 --> 00:13:40,079
right and the third allocation what is

366
00:13:40,079 --> 00:13:42,399
written to that allocation is actually

367
00:13:42,399 --> 00:13:44,399
the payload that is being delivered to

368
00:13:44,399 --> 00:13:47,519
our arbitrary memory location however

369
00:13:47,519 --> 00:13:49,120
there are we going to write an

370
00:13:49,120 --> 00:13:51,120
exploitation primitive with exactly

371
00:13:51,120 --> 00:13:53,519
these characteristics that is also

372
00:13:53,519 --> 00:13:56,000
accessible over usb and we have been

373
00:13:56,000 --> 00:13:58,399
digging through several usb drivers and

374
00:13:58,399 --> 00:14:00,800
at a certain moment we were encountering

375
00:14:00,800 --> 00:14:03,360
a very interesting usb driver and this

376
00:14:03,360 --> 00:14:06,560
usb driver is the usb hid protocol or

377
00:14:06,560 --> 00:14:08,480
human interface devices and it is

378
00:14:08,480 --> 00:14:10,320
basically a generic protocol for

379
00:14:10,320 --> 00:14:13,440
keyboards mousers game controllers etc

380
00:14:13,440 --> 00:14:15,120
and it basically allows you to describe

381
00:14:15,120 --> 00:14:17,440
your device through a series of inputs

382
00:14:17,440 --> 00:14:18,720
and outputs

383
00:14:18,720 --> 00:14:20,480
and the way it works is that the usb

384
00:14:20,480 --> 00:14:22,720
protocol is extended with two additional

385
00:14:22,720 --> 00:14:25,360
descriptors the first one is the hcd

386
00:14:25,360 --> 00:14:26,880
destructor and the second one is the

387
00:14:26,880 --> 00:14:28,800
haste id report descriptor and the haste

388
00:14:28,800 --> 00:14:30,720
id report descriptor is basically an

389
00:14:30,720 --> 00:14:33,199
arbitrarily sized blob of data that is

390
00:14:33,199 --> 00:14:35,279
describing your device and the

391
00:14:35,279 --> 00:14:37,040
interesting bit of this is is that this

392
00:14:37,040 --> 00:14:39,360
report descriptor has a variable length

393
00:14:39,360 --> 00:14:41,839
gets dynamically allocated and the

394
00:14:41,839 --> 00:14:43,760
actual length that will be allocated is

395
00:14:43,760 --> 00:14:47,519
delivered in the initial hid descriptor

396
00:14:47,519 --> 00:14:49,360
so let's now take a look at the probing

397
00:14:49,360 --> 00:14:52,160
process that happens for hid devices one

398
00:14:52,160 --> 00:14:53,839
of the main functions that is doing the

399
00:14:53,839 --> 00:14:57,440
problem is the usb hid pass function the

400
00:14:57,440 --> 00:15:00,480
usb hd pass function will first

401
00:15:00,480 --> 00:15:02,800
do request the hcd descriptor and the

402
00:15:02,800 --> 00:15:05,279
hsid descriptor will have the size of

403
00:15:05,279 --> 00:15:07,120
the report descriptor which is then

404
00:15:07,120 --> 00:15:10,000
stored in the air size variable

405
00:15:10,000 --> 00:15:12,160
then it will start allocating memory for

406
00:15:12,160 --> 00:15:14,079
storing the report descriptor and

407
00:15:14,079 --> 00:15:16,000
actually call the corresponding function

408
00:15:16,000 --> 00:15:17,040
to read

409
00:15:17,040 --> 00:15:19,040
retrieve the report descriptor from the

410
00:15:19,040 --> 00:15:21,680
device this is done by the haste id cad

411
00:15:21,680 --> 00:15:24,000
class descriptor function

412
00:15:24,000 --> 00:15:25,760
but then as a next step we start

413
00:15:25,760 --> 00:15:27,680
actually processing this report

414
00:15:27,680 --> 00:15:29,680
descriptor and there we see some very

415
00:15:29,680 --> 00:15:32,000
interesting behavior this happens in the

416
00:15:32,000 --> 00:15:34,399
haste id open report function which is

417
00:15:34,399 --> 00:15:36,480
quite a bit later in the in the probing

418
00:15:36,480 --> 00:15:39,120
process of this device and interestingly

419
00:15:39,120 --> 00:15:41,920
enough this driver is making two copies

420
00:15:41,920 --> 00:15:43,920
of our reaper descriptor buffer and it's

421
00:15:43,920 --> 00:15:44,959
just

422
00:15:44,959 --> 00:15:47,279
allocating the same size of memory and

423
00:15:47,279 --> 00:15:49,519
just coping over the content of the

424
00:15:49,519 --> 00:15:51,279
buffer

425
00:15:51,279 --> 00:15:53,920
the k-man dot function is basically a

426
00:15:53,920 --> 00:15:56,240
combination of a k malloc and a mem copy

427
00:15:56,240 --> 00:15:58,639
with the purpose to duplicate a buffer

428
00:15:58,639 --> 00:16:01,360
however what we have here are our three

429
00:16:01,360 --> 00:16:04,320
allocations in a row and the content we

430
00:16:04,320 --> 00:16:05,440
control

431
00:16:05,440 --> 00:16:07,839
aka we have here our average very right

432
00:16:07,839 --> 00:16:10,959
primitive that we can reach from outside

433
00:16:10,959 --> 00:16:13,360
over usb

434
00:16:13,360 --> 00:16:15,199
but how are we then going to exploit

435
00:16:15,199 --> 00:16:17,199
that on the real device because remember

436
00:16:17,199 --> 00:16:19,839
on the real device we have no way to see

437
00:16:19,839 --> 00:16:21,519
what is happening in the device the

438
00:16:21,519 --> 00:16:24,160
device might work the device might crash

439
00:16:24,160 --> 00:16:26,000
but that's all the information we can

440
00:16:26,000 --> 00:16:27,920
get we have no insight in what's

441
00:16:27,920 --> 00:16:30,399
happening on the device and due to that

442
00:16:30,399 --> 00:16:31,199
we

443
00:16:31,199 --> 00:16:33,920
invested heavily in created creating a

444
00:16:33,920 --> 00:16:36,320
development environment that allows us

445
00:16:36,320 --> 00:16:39,040
to actually develop the attack before we

446
00:16:39,040 --> 00:16:42,800
try to execute it on the real device

447
00:16:42,800 --> 00:16:43,600
and

448
00:16:43,600 --> 00:16:46,160
one of the main problems we have is how

449
00:16:46,160 --> 00:16:48,720
do we craft our attack in such a way

450
00:16:48,720 --> 00:16:51,199
that we reliable win the race between

451
00:16:51,199 --> 00:16:53,759
the double free and actually allocating

452
00:16:53,759 --> 00:16:55,759
the buffer for the report descriptors

453
00:16:55,759 --> 00:16:58,800
but also how are we crafting a payload

454
00:16:58,800 --> 00:16:59,759
that

455
00:16:59,759 --> 00:17:00,639
is

456
00:17:00,639 --> 00:17:02,959
working for our specific target luckily

457
00:17:02,959 --> 00:17:04,880
enough we did have access to the

458
00:17:04,880 --> 00:17:07,359
plaintext binaries which helped us a lot

459
00:17:07,359 --> 00:17:10,880
however we'd have no information

460
00:17:10,880 --> 00:17:13,119
from the runtime of the device and what

461
00:17:13,119 --> 00:17:15,839
we did is we actually did a lot of work

462
00:17:15,839 --> 00:17:17,599
in preparing our attack using the

463
00:17:17,599 --> 00:17:20,319
grammar emulator

464
00:17:20,319 --> 00:17:22,559
what we did is that we basically tried

465
00:17:22,559 --> 00:17:25,439
to model the real device as close as

466
00:17:25,439 --> 00:17:28,319
possible in the emulator and this has as

467
00:17:28,319 --> 00:17:30,480
major benefit that we could completely

468
00:17:30,480 --> 00:17:33,840
control and debug our attack before we

469
00:17:33,840 --> 00:17:35,600
had to do it on the real device in the

470
00:17:35,600 --> 00:17:37,600
blind and this has been really

471
00:17:37,600 --> 00:17:40,240
critically to get a sufficient

472
00:17:40,240 --> 00:17:42,480
understanding of how the attack is

473
00:17:42,480 --> 00:17:45,280
behaving and the elements that we need

474
00:17:45,280 --> 00:17:47,600
to control to make it work

475
00:17:47,600 --> 00:17:49,600
of course an emulator is not a real

476
00:17:49,600 --> 00:17:52,000
device the binary is different

477
00:17:52,000 --> 00:17:53,679
the

478
00:17:53,679 --> 00:17:55,600
device behavior is different the

479
00:17:55,600 --> 00:17:58,000
activity is different

480
00:17:58,000 --> 00:18:01,280
however we really tried hard in making

481
00:18:01,280 --> 00:18:03,520
sure that all the critical code paths

482
00:18:03,520 --> 00:18:05,679
and all the data structures are as close

483
00:18:05,679 --> 00:18:08,000
as possible to the real device also by

484
00:18:08,000 --> 00:18:11,120
comparing our emulated kernel with the

485
00:18:11,120 --> 00:18:14,080
real device

486
00:18:14,080 --> 00:18:16,320
however until the very last it remained

487
00:18:16,320 --> 00:18:17,919
the question how accurate is the

488
00:18:17,919 --> 00:18:20,720
emulation that we are doing on our

489
00:18:20,720 --> 00:18:23,679
device of our device and how is it

490
00:18:23,679 --> 00:18:27,039
actually mapping to the real environment

491
00:18:27,039 --> 00:18:30,880
so in q ammo we can of course

492
00:18:30,880 --> 00:18:32,960
test our kernel but how are we going to

493
00:18:32,960 --> 00:18:34,880
test this real attack and what we did is

494
00:18:34,880 --> 00:18:36,799
we actually took the

495
00:18:36,799 --> 00:18:40,240
emulated devices of guamo for usb and we

496
00:18:40,240 --> 00:18:42,320
basically repurposed that so we took the

497
00:18:42,320 --> 00:18:44,320
mouse and we made a midi device out of

498
00:18:44,320 --> 00:18:46,880
it which has the invalid configuration

499
00:18:46,880 --> 00:18:48,640
triggering the double free and we

500
00:18:48,640 --> 00:18:50,880
changed the tablet interface

501
00:18:50,880 --> 00:18:53,280
such that it is using its hid report

502
00:18:53,280 --> 00:18:55,520
descriptor to deliver the payload which

503
00:18:55,520 --> 00:18:56,720
then gets

504
00:18:56,720 --> 00:18:58,720
copied and written to memory to the

505
00:18:58,720 --> 00:19:00,320
address we want

506
00:19:00,320 --> 00:19:03,440
and to our real surprise is that

507
00:19:03,440 --> 00:19:05,679
we almost had to change

508
00:19:05,679 --> 00:19:07,760
nothing only of course the addresses and

509
00:19:07,760 --> 00:19:10,080
the offsets and similar things but it

510
00:19:10,080 --> 00:19:11,840
almost worked out of the box on the real

511
00:19:11,840 --> 00:19:13,919
device and that was really a surprise to

512
00:19:13,919 --> 00:19:14,960
us

513
00:19:14,960 --> 00:19:16,720
but how are we actually going to do this

514
00:19:16,720 --> 00:19:18,559
on a real device because you will not

515
00:19:18,559 --> 00:19:21,280
find a usb device that first represents

516
00:19:21,280 --> 00:19:23,520
itself as a media device doing a double

517
00:19:23,520 --> 00:19:26,080
free and then say hey i'm in hid device

518
00:19:26,080 --> 00:19:28,400
and i want to deliver a payload that it

519
00:19:28,400 --> 00:19:30,000
gets written somewhere in your address

520
00:19:30,000 --> 00:19:31,760
space and what we used is the face

521
00:19:31,760 --> 00:19:33,840
dancer framework this is a very nice

522
00:19:33,840 --> 00:19:35,919
open source framework to implement

523
00:19:35,919 --> 00:19:39,039
arbitrary usb devices in python and we

524
00:19:39,039 --> 00:19:41,520
then use the great fat board to make it

525
00:19:41,520 --> 00:19:43,679
interface with our target and what we

526
00:19:43,679 --> 00:19:45,520
did is we changed the face sensor

527
00:19:45,520 --> 00:19:48,240
framework in such a way that it first

528
00:19:48,240 --> 00:19:50,559
connects a midi device triggers a double

529
00:19:50,559 --> 00:19:52,960
free disconnects itself connects us in

530
00:19:52,960 --> 00:19:55,600
his id device and delivers the payload

531
00:19:55,600 --> 00:19:57,520
and hopefully that results in something

532
00:19:57,520 --> 00:19:58,720
useful for us

533
00:19:58,720 --> 00:20:00,559
what's very critical here is that the

534
00:20:00,559 --> 00:20:02,480
triggering of the double free the

535
00:20:02,480 --> 00:20:04,720
disconnecting connecting and delivering

536
00:20:04,720 --> 00:20:06,400
of the payload need to be as close as

537
00:20:06,400 --> 00:20:08,880
possible the timing of the allocation of

538
00:20:08,880 --> 00:20:10,640
the reboot descriptor should be as close

539
00:20:10,640 --> 00:20:12,480
as possible as the triggering of the

540
00:20:12,480 --> 00:20:14,000
double free because if there is

541
00:20:14,000 --> 00:20:16,320
something else trying to use this slab

542
00:20:16,320 --> 00:20:18,320
for a different purpose that might crash

543
00:20:18,320 --> 00:20:20,880
the kernel due to the corruption we have

544
00:20:20,880 --> 00:20:22,159
passed

545
00:20:22,159 --> 00:20:23,919
but what is the kind of payload we are

546
00:20:23,919 --> 00:20:26,000
actually going to deliver and one of the

547
00:20:26,000 --> 00:20:28,159
main questions there is the code of the

548
00:20:28,159 --> 00:20:30,559
kernel writable if the code is not

549
00:20:30,559 --> 00:20:32,799
writable you will have to resort to some

550
00:20:32,799 --> 00:20:35,440
form of data only attack however in our

551
00:20:35,440 --> 00:20:37,440
case we could actually override the

552
00:20:37,440 --> 00:20:39,520
kernel code because it was map writable

553
00:20:39,520 --> 00:20:41,520
on this very specific device and by

554
00:20:41,520 --> 00:20:43,760
overwriting the kernel code we could get

555
00:20:43,760 --> 00:20:46,320
our get arbitrary code execution in the

556
00:20:46,320 --> 00:20:48,159
context of the kernel but one of the

557
00:20:48,159 --> 00:20:50,159
main questions here is where are we

558
00:20:50,159 --> 00:20:52,559
going to hijack the kernel code and

559
00:20:52,559 --> 00:20:54,960
getting code execution and do something

560
00:20:54,960 --> 00:20:57,840
for it naturally for us one of the

561
00:20:57,840 --> 00:21:00,880
logical locations to take control would

562
00:21:00,880 --> 00:21:02,880
be as close as possible where our

563
00:21:02,880 --> 00:21:04,880
payload is written to memory this is the

564
00:21:04,880 --> 00:21:06,400
h this is the

565
00:21:06,400 --> 00:21:09,200
assembly code of the haste id open

566
00:21:09,200 --> 00:21:11,520
report function and we see the two k

567
00:21:11,520 --> 00:21:15,840
member calls inside the code

568
00:21:15,840 --> 00:21:18,320
that we want to target our payload to

569
00:21:18,320 --> 00:21:20,480
start executing as close as possible

570
00:21:20,480 --> 00:21:22,720
after the second game end up because

571
00:21:22,720 --> 00:21:24,960
this is the function that is going to

572
00:21:24,960 --> 00:21:27,200
write our payload to memory

573
00:21:27,200 --> 00:21:29,360
what we did is actually we override the

574
00:21:29,360 --> 00:21:31,520
code slightly before the branch to this

575
00:21:31,520 --> 00:21:34,480
function because due to the start of our

576
00:21:34,480 --> 00:21:37,039
payload having the destination address

577
00:21:37,039 --> 00:21:38,960
that we want to write to which is not

578
00:21:38,960 --> 00:21:41,440
executable code and then when the k-man

579
00:21:41,440 --> 00:21:43,760
verb returns it will actually start

580
00:21:43,760 --> 00:21:46,080
executing the first instruction of our

581
00:21:46,080 --> 00:21:47,280
payload

582
00:21:47,280 --> 00:21:49,440
how are we then designing our payloads

583
00:21:49,440 --> 00:21:51,760
well what we did is we again went back

584
00:21:51,760 --> 00:21:54,000
to coemo and we started crafting

585
00:21:54,000 --> 00:21:56,240
different payloads and our very first

586
00:21:56,240 --> 00:21:58,240
payload was simply calling the print

587
00:21:58,240 --> 00:22:01,039
function and seeing we could print

588
00:22:01,039 --> 00:22:02,880
a message to the console and seeing how

589
00:22:02,880 --> 00:22:06,000
the kernel panicked of course this is

590
00:22:06,000 --> 00:22:06,880
not

591
00:22:06,880 --> 00:22:09,600
very useful however

592
00:22:09,600 --> 00:22:12,400
it gave gave us the confirmation

593
00:22:12,400 --> 00:22:14,400
that we could actually gain code

594
00:22:14,400 --> 00:22:18,320
execution in the context of the kernel

595
00:22:18,400 --> 00:22:20,400
the next step that we did and that was

596
00:22:20,400 --> 00:22:22,400
also very useful to do on the real

597
00:22:22,400 --> 00:22:25,120
device is calling the usb getstring

598
00:22:25,120 --> 00:22:27,280
function this is going to do and get

599
00:22:27,280 --> 00:22:29,280
string descriptor request to the usb

600
00:22:29,280 --> 00:22:31,679
device and this is one of the very few

601
00:22:31,679 --> 00:22:34,559
things we could observe from the outside

602
00:22:34,559 --> 00:22:36,000
what would happen is when we take

603
00:22:36,000 --> 00:22:39,120
control of the kernel

604
00:22:39,120 --> 00:22:41,039
when we take control of the kernel is

605
00:22:41,039 --> 00:22:42,720
that when we call this function we see

606
00:22:42,720 --> 00:22:45,520
on the usb device that the kernel asks

607
00:22:45,520 --> 00:22:49,200
for a string descriptor that we specify

608
00:22:49,200 --> 00:22:51,120
while this is very likely that the

609
00:22:51,120 --> 00:22:53,440
kernel panics afterwards at least what

610
00:22:53,440 --> 00:22:55,360
we can see is that we successfully got

611
00:22:55,360 --> 00:22:57,760
code execution on the device

612
00:22:57,760 --> 00:22:59,520
and then we went through several

613
00:22:59,520 --> 00:23:02,480
iterations and the final version of our

614
00:23:02,480 --> 00:23:04,480
attack we could actually

615
00:23:04,480 --> 00:23:06,799
clean up the mess we have caused inside

616
00:23:06,799 --> 00:23:08,799
the memory of the device such that we

617
00:23:08,799 --> 00:23:10,640
could run the exploit pretty much an

618
00:23:10,640 --> 00:23:12,559
indefinite amount of times on this

619
00:23:12,559 --> 00:23:14,720
specific device

620
00:23:14,720 --> 00:23:16,880
so how does our payload look like well

621
00:23:16,880 --> 00:23:19,200
as i told before we are constrained in

622
00:23:19,200 --> 00:23:22,320
size to 512 bytes and at the very start

623
00:23:22,320 --> 00:23:24,400
we have the destination address where we

624
00:23:24,400 --> 00:23:27,280
want our want to write our payload to

625
00:23:27,280 --> 00:23:29,360
then we have some mandatory cleanup

626
00:23:29,360 --> 00:23:31,200
steps to prevent the kernel from

627
00:23:31,200 --> 00:23:32,799
instantly panicking the moment we

628
00:23:32,799 --> 00:23:35,120
deliver the payload and then we have the

629
00:23:35,120 --> 00:23:37,600
actual useful part of our payload this

630
00:23:37,600 --> 00:23:39,520
could for example be running on shell

631
00:23:39,520 --> 00:23:41,919
command as root extracting some data

632
00:23:41,919 --> 00:23:44,960
like cryptographic keys or disabling

633
00:23:44,960 --> 00:23:48,159
some of the protections like si linux

634
00:23:48,159 --> 00:23:50,880
to be able to actually run the attack

635
00:23:50,880 --> 00:23:53,200
multiple times we need to augment our

636
00:23:53,200 --> 00:23:55,120
payload with some other steps for

637
00:23:55,120 --> 00:23:57,360
example we need to restore the code or

638
00:23:57,360 --> 00:23:59,279
at least the most critical parts of the

639
00:23:59,279 --> 00:24:01,440
code we have overwritten we need to

640
00:24:01,440 --> 00:24:04,080
clean up and we need to do a proper

641
00:24:04,080 --> 00:24:06,320
return and make sure the probing process

642
00:24:06,320 --> 00:24:09,200
fails because that way we can actually

643
00:24:09,200 --> 00:24:11,200
trigger the probing multiple time and

644
00:24:11,200 --> 00:24:13,600
get code execution multiple times and we

645
00:24:13,600 --> 00:24:16,400
can simply make the actual useful part

646
00:24:16,400 --> 00:24:18,240
of the payload differ each time we get

647
00:24:18,240 --> 00:24:20,320
code execution and for example run

648
00:24:20,320 --> 00:24:23,039
different drill shell commands each time

649
00:24:23,039 --> 00:24:25,919
we execute our attack

650
00:24:25,919 --> 00:24:28,000
so what are we then going to execute for

651
00:24:28,000 --> 00:24:30,400
example on the device well

652
00:24:30,400 --> 00:24:33,200
we can run arbitrary commands as root

653
00:24:33,200 --> 00:24:34,960
using a function in the kernel called

654
00:24:34,960 --> 00:24:36,640
run command this is a well-known

655
00:24:36,640 --> 00:24:39,520
technique to turn an arbitrary code

656
00:24:39,520 --> 00:24:41,360
execution in the linux kernel in

657
00:24:41,360 --> 00:24:43,760
actually doing something useful however

658
00:24:43,760 --> 00:24:45,200
something we noticed is that this

659
00:24:45,200 --> 00:24:46,880
function does not function from the

660
00:24:46,880 --> 00:24:48,480
interrupt context

661
00:24:48,480 --> 00:24:50,880
this is exactly the context the usb hub

662
00:24:50,880 --> 00:24:53,840
work you work under so when we actually

663
00:24:53,840 --> 00:24:56,159
tried using this function our kernel

664
00:24:56,159 --> 00:24:58,480
would panic because it is not valid to

665
00:24:58,480 --> 00:25:00,400
be used that way

666
00:25:00,400 --> 00:25:02,240
alternatively you can use the system

667
00:25:02,240 --> 00:25:04,240
work queue to schedule the start of a

668
00:25:04,240 --> 00:25:06,880
new process by pushing this as a work

669
00:25:06,880 --> 00:25:08,960
item onto the work queue and then the

670
00:25:08,960 --> 00:25:10,960
system work queue will take care of it

671
00:25:10,960 --> 00:25:13,120
that the process gets started luckily

672
00:25:13,120 --> 00:25:15,200
for us there is already a mechanism in

673
00:25:15,200 --> 00:25:17,120
the kernel that does this and that we

674
00:25:17,120 --> 00:25:19,120
could simply repurpose there are the

675
00:25:19,120 --> 00:25:21,120
functions orderly reboot and orderly

676
00:25:21,120 --> 00:25:23,919
shutdown that basically are scheduling

677
00:25:23,919 --> 00:25:26,400
the execution of a command through the

678
00:25:26,400 --> 00:25:28,880
system work you and then calls the run

679
00:25:28,880 --> 00:25:31,360
command function with this command and

680
00:25:31,360 --> 00:25:33,840
these commands that get executed are

681
00:25:33,840 --> 00:25:36,000
frightable with our specific kernel so

682
00:25:36,000 --> 00:25:37,840
we could simply change the command and

683
00:25:37,840 --> 00:25:39,600
call the

684
00:25:39,600 --> 00:25:42,400
and call the relevant function

685
00:25:42,400 --> 00:25:46,000
so what are we then going to execute

686
00:25:46,000 --> 00:25:48,480
with our with good privileges well we

687
00:25:48,480 --> 00:25:50,640
can of course pick any binary we want in

688
00:25:50,640 --> 00:25:52,960
the file system but as we talked before

689
00:25:52,960 --> 00:25:54,720
this is a very minimal system and there

690
00:25:54,720 --> 00:25:56,799
are effectively no useful binaries in

691
00:25:56,799 --> 00:25:58,000
the system

692
00:25:58,000 --> 00:26:00,720
um however we are doing a usb attack so

693
00:26:00,720 --> 00:26:02,640
why not use a usb stick and that is

694
00:26:02,640 --> 00:26:04,720
indeed what we did we simply were

695
00:26:04,720 --> 00:26:07,520
putting a reverse shell binary on a usb

696
00:26:07,520 --> 00:26:11,520
stick which we then were running from uh

697
00:26:11,520 --> 00:26:14,320
using our exploit of course ideally the

698
00:26:14,320 --> 00:26:16,480
usb stand gets outer mounted by the

699
00:26:16,480 --> 00:26:18,480
system in our case we have to do a

700
00:26:18,480 --> 00:26:20,640
little bit more work to manually mount

701
00:26:20,640 --> 00:26:22,640
the usb stick

702
00:26:22,640 --> 00:26:25,279
on our device and what about sl linux

703
00:26:25,279 --> 00:26:26,880
that might prevent you to spawn new

704
00:26:26,880 --> 00:26:29,279
processors well we simply had to disable

705
00:26:29,279 --> 00:26:31,200
it for example in our case we could set

706
00:26:31,200 --> 00:26:33,039
the air forcing variable to zero which

707
00:26:33,039 --> 00:26:34,720
is a well-known technique but you could

708
00:26:34,720 --> 00:26:36,640
of course also patch the in-memory

709
00:26:36,640 --> 00:26:38,559
policy database or use one of the other

710
00:26:38,559 --> 00:26:41,279
techniques that i know

711
00:26:41,279 --> 00:26:43,600
so we have preferred a demo that is

712
00:26:43,600 --> 00:26:45,520
demonstrating our attack we have

713
00:26:45,520 --> 00:26:49,039
recorded our demo for the presentation

714
00:26:49,039 --> 00:26:51,520
which we now would like to show to you

715
00:26:51,520 --> 00:26:53,200
in this demo we would like to

716
00:26:53,200 --> 00:26:55,039
demonstrate the attack we have discussed

717
00:26:55,039 --> 00:26:57,279
so far we took a several years old

718
00:26:57,279 --> 00:26:59,279
smartphone which has a linux kernel that

719
00:26:59,279 --> 00:27:01,360
is quite similar to the device we

720
00:27:01,360 --> 00:27:03,200
originally exploited using this

721
00:27:03,200 --> 00:27:04,559
vulnerability

722
00:27:04,559 --> 00:27:06,799
updated to the latest firmware version

723
00:27:06,799 --> 00:27:08,480
the phone is not vulnerable to this

724
00:27:08,480 --> 00:27:10,640
attack therefore we created and

725
00:27:10,640 --> 00:27:12,960
installed a custom kernel that contains

726
00:27:12,960 --> 00:27:14,960
the vulnerability as well as a few small

727
00:27:14,960 --> 00:27:17,440
modifications such as disabling some

728
00:27:17,440 --> 00:27:19,840
vendor-specific kerneling hardening the

729
00:27:19,840 --> 00:27:22,080
original device didn't have

730
00:27:22,080 --> 00:27:24,080
on the right side we have a netcat

731
00:27:24,080 --> 00:27:25,600
instance waiting for incoming

732
00:27:25,600 --> 00:27:28,480
connections then we gain code execution

733
00:27:28,480 --> 00:27:30,399
in the context of the linux kernel we

734
00:27:30,399 --> 00:27:32,399
will use this to launch a reverse shell

735
00:27:32,399 --> 00:27:34,240
on the phone that connects to the netcat

736
00:27:34,240 --> 00:27:36,240
instance giving us a shell on the phone

737
00:27:36,240 --> 00:27:38,480
with root privileges which then allows

738
00:27:38,480 --> 00:27:40,559
accessing the phone's data

739
00:27:40,559 --> 00:27:42,799
on the left side we are going to run the

740
00:27:42,799 --> 00:27:45,600
exploit implemented in python using the

741
00:27:45,600 --> 00:27:48,240
face dancer framework first it will

742
00:27:48,240 --> 00:27:50,480
connect a midi device that triggers to

743
00:27:50,480 --> 00:27:53,440
use after free vulnerability then it

744
00:27:53,440 --> 00:27:56,240
disconnects and connects the hrd device

745
00:27:56,240 --> 00:27:58,000
delivering the payload with the shell

746
00:27:58,000 --> 00:28:00,399
code all of this will happen within a

747
00:28:00,399 --> 00:28:02,320
few hundred milliseconds and you will

748
00:28:02,320 --> 00:28:04,399
see the usb communication quickly

749
00:28:04,399 --> 00:28:05,679
scrolling by

750
00:28:05,679 --> 00:28:07,840
the longer these two steps take the

751
00:28:07,840 --> 00:28:10,000
lower the probability within the race

752
00:28:10,000 --> 00:28:12,000
however we notice that when the device

753
00:28:12,000 --> 00:28:14,000
has been idle for several minutes we

754
00:28:14,000 --> 00:28:17,840
have a quite high chance of success

755
00:28:21,279 --> 00:28:23,120
as you can see on the right side the

756
00:28:23,120 --> 00:28:25,120
attack worked and we have an incoming

757
00:28:25,120 --> 00:28:27,919
connection showing we successfully got a

758
00:28:27,919 --> 00:28:29,600
rootshell on the phone giving us full

759
00:28:29,600 --> 00:28:32,240
control over the android environment as

760
00:28:32,240 --> 00:28:34,960
this is a demo we will use this to show

761
00:28:34,960 --> 00:28:37,279
how this allows unlocking the device by

762
00:28:37,279 --> 00:28:40,240
simulating physical input however if the

763
00:28:40,240 --> 00:28:42,000
phone is already fully booted and

764
00:28:42,000 --> 00:28:44,080
unlocked before exploitation of this

765
00:28:44,080 --> 00:28:46,480
vulnerability gives immediate access to

766
00:28:46,480 --> 00:28:48,880
all data stored on the device

767
00:28:48,880 --> 00:28:50,799
and now we will talk about

768
00:28:50,799 --> 00:28:53,279
our discussion points we will first want

769
00:28:53,279 --> 00:28:55,840
to discuss about the attack challenges

770
00:28:55,840 --> 00:28:58,000
as martin mentioned earlier winning the

771
00:28:58,000 --> 00:29:00,320
race is one of our main challenges we

772
00:29:00,320 --> 00:29:02,720
need a very specific sequence sequence

773
00:29:02,720 --> 00:29:03,840
of events

774
00:29:03,840 --> 00:29:06,240
um to succeed and this is basically

775
00:29:06,240 --> 00:29:08,080
inserting the usb midi device to cause

776
00:29:08,080 --> 00:29:10,720
the double f3 disconnecting it connect

777
00:29:10,720 --> 00:29:12,880
the other device to uh deliver the

778
00:29:12,880 --> 00:29:15,039
payload so um

779
00:29:15,039 --> 00:29:19,200
if we are dealing if with slabs with low

780
00:29:19,200 --> 00:29:21,440
activity we will have a high chance of

781
00:29:21,440 --> 00:29:23,360
winning the race whereas if we would be

782
00:29:23,360 --> 00:29:25,679
dealing with high activity slabs that

783
00:29:25,679 --> 00:29:27,120
will be more complicated so that's

784
00:29:27,120 --> 00:29:29,039
something to take into account the

785
00:29:29,039 --> 00:29:31,120
second thing is the cache behavior since

786
00:29:31,120 --> 00:29:34,240
we chose to override the kernel's code

787
00:29:34,240 --> 00:29:36,240
caches could make it hard to predict

788
00:29:36,240 --> 00:29:38,799
where exactly we are taking control this

789
00:29:38,799 --> 00:29:41,200
could be mitigated of course by adding

790
00:29:41,200 --> 00:29:42,480
an obsolete

791
00:29:42,480 --> 00:29:44,880
but you need to have space to fit it in

792
00:29:44,880 --> 00:29:46,880
your payload slot

793
00:29:46,880 --> 00:29:48,720
and the third thing we wanted to discuss

794
00:29:48,720 --> 00:29:50,960
is about exploit mitigation so what if

795
00:29:50,960 --> 00:29:52,960
the kernel has address-based layout

796
00:29:52,960 --> 00:29:55,520
randomization this is a hurdle that we

797
00:29:55,520 --> 00:29:58,000
will need to overcome so either finding

798
00:29:58,000 --> 00:30:01,120
another vulnerability to leak a pointer

799
00:30:01,120 --> 00:30:02,640
or an address of the kernel so we can

800
00:30:02,640 --> 00:30:04,799
then dynamically calculate our addresses

801
00:30:04,799 --> 00:30:07,279
or we could also choose to brute force

802
00:30:07,279 --> 00:30:09,520
it but this approach has the downside

803
00:30:09,520 --> 00:30:12,159
that of course the kernel will crash if

804
00:30:12,159 --> 00:30:14,640
we don't hit the correct address and in

805
00:30:14,640 --> 00:30:17,360
some cases this might not be acceptable

806
00:30:17,360 --> 00:30:19,039
the second thing are all kind of

807
00:30:19,039 --> 00:30:21,520
protections code and data can be

808
00:30:21,520 --> 00:30:23,600
protected so then if that happens we

809
00:30:23,600 --> 00:30:25,279
need to look for other attack paths

810
00:30:25,279 --> 00:30:27,840
either a data only attack or also we can

811
00:30:27,840 --> 00:30:30,720
think of for example trying to override

812
00:30:30,720 --> 00:30:32,320
privileged

813
00:30:32,320 --> 00:30:35,520
process code from the kernel's fist map

814
00:30:35,520 --> 00:30:37,600
which would allow us to gain control as

815
00:30:37,600 --> 00:30:38,960
well

816
00:30:38,960 --> 00:30:43,279
and the third point is all kind of heap

817
00:30:43,279 --> 00:30:44,880
hardening techniques

818
00:30:44,880 --> 00:30:47,840
so for example the free list metadata

819
00:30:47,840 --> 00:30:50,559
could be checked or the allocations

820
00:30:50,559 --> 00:30:52,720
could be randomized those are all

821
00:30:52,720 --> 00:30:54,880
factors that could make our attack

822
00:30:54,880 --> 00:30:57,760
impossible to execute

823
00:30:57,760 --> 00:30:59,679
if we talk about applicability we think

824
00:30:59,679 --> 00:31:02,399
that similar bugs in a lower activity

825
00:31:02,399 --> 00:31:04,799
slab could be exploited using our

826
00:31:04,799 --> 00:31:07,440
methods but of course the precise steps

827
00:31:07,440 --> 00:31:09,519
of the exploitation will really depend

828
00:31:09,519 --> 00:31:10,799
on the device there are different

829
00:31:10,799 --> 00:31:12,480
factors to consider such as the

830
00:31:12,480 --> 00:31:14,960
architecture the device configuration

831
00:31:14,960 --> 00:31:17,760
vendor specific customizations and the

832
00:31:17,760 --> 00:31:20,640
exploit mitigations

833
00:31:20,640 --> 00:31:22,799
about our exploit requirements

834
00:31:22,799 --> 00:31:26,480
as andres exploit we of course need

835
00:31:26,480 --> 00:31:28,399
to have physical access to the device

836
00:31:28,399 --> 00:31:31,039
and we need this vulnerable driver to be

837
00:31:31,039 --> 00:31:34,080
enabled with our approach we managed to

838
00:31:34,080 --> 00:31:36,240
remove two of the prerequisites because

839
00:31:36,240 --> 00:31:38,480
we don't need to have unprivileged code

840
00:31:38,480 --> 00:31:40,399
execution since we are doing everything

841
00:31:40,399 --> 00:31:43,200
from the usb subsystem that runs in the

842
00:31:43,200 --> 00:31:45,360
interrupt context of the kernel and we

843
00:31:45,360 --> 00:31:47,760
also don't need any other interface we

844
00:31:47,760 --> 00:31:48,960
are just

845
00:31:48,960 --> 00:31:51,440
using the elements we have with the usb

846
00:31:51,440 --> 00:31:52,960
protocol stack

847
00:31:52,960 --> 00:31:54,960
but as we mentioned several times

848
00:31:54,960 --> 00:31:56,000
already

849
00:31:56,000 --> 00:31:58,880
we do need a low activity slab because

850
00:31:58,880 --> 00:32:01,440
for us um it's not

851
00:32:01,440 --> 00:32:05,519
that easy um to keep bashing the

852
00:32:05,519 --> 00:32:07,519
heap until we win the race

853
00:32:07,519 --> 00:32:09,120
so this is a prerequisite that's quite

854
00:32:09,120 --> 00:32:10,399
important

855
00:32:10,399 --> 00:32:12,480
um and now we would like to conclude our

856
00:32:12,480 --> 00:32:14,799
talk with three main takeaways the first

857
00:32:14,799 --> 00:32:16,000
takeaway

858
00:32:16,000 --> 00:32:17,200
is that

859
00:32:17,200 --> 00:32:18,880
even though vulnerabilities might be

860
00:32:18,880 --> 00:32:22,000
easy to fix as we showed

861
00:32:22,000 --> 00:32:23,679
it's not that easy to propagate all

862
00:32:23,679 --> 00:32:25,679
these fixes to devices that are already

863
00:32:25,679 --> 00:32:27,600
deployed on the field

864
00:32:27,600 --> 00:32:29,360
another thing we learned is that

865
00:32:29,360 --> 00:32:30,960
investing time in your debugging

866
00:32:30,960 --> 00:32:33,279
environment is very important so this

867
00:32:33,279 --> 00:32:35,600
really allowed us to see to the detail

868
00:32:35,600 --> 00:32:37,679
what was going on with our

869
00:32:37,679 --> 00:32:40,799
exploit and actually it was quite easy

870
00:32:40,799 --> 00:32:42,880
to port it to the actual device once we

871
00:32:42,880 --> 00:32:45,039
have done all the work of replicating

872
00:32:45,039 --> 00:32:46,320
the environment

873
00:32:46,320 --> 00:32:49,120
and the last thing is that usb attacks

874
00:32:49,120 --> 00:32:51,840
are quite powerful and in this

875
00:32:51,840 --> 00:32:54,480
presentation we demonstrated how we

876
00:32:54,480 --> 00:32:57,039
could compromise a device by just using

877
00:32:57,039 --> 00:32:58,559
the usb

878
00:32:58,559 --> 00:32:59,840
protocol

879
00:32:59,840 --> 00:33:01,760
sometimes it might even be your only

880
00:33:01,760 --> 00:33:03,120
attack vector

881
00:33:03,120 --> 00:33:04,720
and with this we would like to conclude

882
00:33:04,720 --> 00:33:06,880
the presentation and ask whether there

883
00:33:06,880 --> 00:33:09,740
are any questions

884
00:33:09,740 --> 00:33:19,319
[Music]

885
00:33:19,840 --> 00:33:21,918
you

