1
00:00:00,910 --> 00:00:08,720
[Music]

2
00:00:08,720 --> 00:00:10,160
hello everyone welcome to our

3
00:00:10,160 --> 00:00:12,240
presentation at blackhead europe today

4
00:00:12,240 --> 00:00:14,799
our topic is the out of exporting user 3

5
00:00:14,799 --> 00:00:17,840
by written to bpf in android kernel

6
00:00:17,840 --> 00:00:19,439
here's the gender we will introduce the

7
00:00:19,439 --> 00:00:22,000
internals of the effective model in the

8
00:00:22,000 --> 00:00:24,160
android common kernel including the path

9
00:00:24,160 --> 00:00:25,439
vulnerabilities

10
00:00:25,439 --> 00:00:28,240
and then analyze the user-free bug cbe

11
00:00:28,240 --> 00:00:32,159
2021 0399 we will later talk about how

12
00:00:32,159 --> 00:00:34,480
to exploit the vulnerability or modern

13
00:00:34,480 --> 00:00:37,920
android device including a demo video

14
00:00:37,920 --> 00:00:40,000
moreover i will talk about another user

15
00:00:40,000 --> 00:00:41,600
free bug found

16
00:00:41,600 --> 00:00:43,120
in this kind of module while i'm writing

17
00:00:43,120 --> 00:00:45,280
the park richard will talk about android

18
00:00:45,280 --> 00:00:47,120
kind of mitigations and how google

19
00:00:47,120 --> 00:00:49,680
detects as excellent code at scale

20
00:00:49,680 --> 00:00:51,840
fibrous approaches

21
00:00:51,840 --> 00:00:52,640
cool

22
00:00:52,640 --> 00:00:55,520
so let's take a look at the affected

23
00:00:55,520 --> 00:00:59,359
endocrine model xt on the score qtgid

24
00:00:59,359 --> 00:01:00,960
the module is mainly used for tracking

25
00:01:00,960 --> 00:01:03,760
the network traffic on a per second

26
00:01:03,760 --> 00:01:07,680
basis for unique app 693 it is replaced

27
00:01:07,680 --> 00:01:10,960
by ebpf since ngq so on android pi and

28
00:01:10,960 --> 00:01:13,360
or versions are affected and basically

29
00:01:13,360 --> 00:01:15,840
how it works is that a user space

30
00:01:15,840 --> 00:01:18,960
program may send command data to the

31
00:01:18,960 --> 00:01:22,240
current module such as asking kernel to

32
00:01:22,240 --> 00:01:25,360
tag a socket or on text socket

33
00:01:25,360 --> 00:01:27,280
circuit basically means we want the

34
00:01:27,280 --> 00:01:29,360
engine kernel to check the specific

35
00:01:29,360 --> 00:01:31,759
socket file descriptor and provide

36
00:01:31,759 --> 00:01:34,640
network usage information back to the

37
00:01:34,640 --> 00:01:35,840
user space

38
00:01:35,840 --> 00:01:37,280
and you can interact with the kernel

39
00:01:37,280 --> 00:01:39,920
module by adb or you may use android

40
00:01:39,920 --> 00:01:42,560
apis like traffic status

41
00:01:42,560 --> 00:01:44,720
i'm cool now i will introduce three

42
00:01:44,720 --> 00:01:47,200
different uh scenarios open the module

43
00:01:47,200 --> 00:01:51,360
tag socket and contact socket

44
00:01:51,680 --> 00:01:54,240
one use this program open the kernel

45
00:01:54,240 --> 00:01:56,240
module the model will allocate two

46
00:01:56,240 --> 00:01:58,240
different structures in respect of per

47
00:01:58,240 --> 00:02:00,799
uid and pid and as you can see there

48
00:02:00,799 --> 00:02:03,360
will be only one unique uid tag data

49
00:02:03,360 --> 00:02:05,200
structure but there might be multiple

50
00:02:05,200 --> 00:02:07,520
procedure data structures for every pid

51
00:02:07,520 --> 00:02:10,720
which are essentially linked to the uid

52
00:02:10,720 --> 00:02:12,640
tab data structure

53
00:02:12,640 --> 00:02:15,599
and while i use this space program text

54
00:02:15,599 --> 00:02:18,800
socket it has to provide all sorts of

55
00:02:18,800 --> 00:02:20,959
information such as the socket file

56
00:02:20,959 --> 00:02:24,239
description user id etc

57
00:02:24,239 --> 00:02:26,400
and two different data structures will

58
00:02:26,400 --> 00:02:29,440
be allocated in terms of the uid and the

59
00:02:29,440 --> 00:02:31,440
pid

60
00:02:31,440 --> 00:02:33,680
so first of all the model will find the

61
00:02:33,680 --> 00:02:36,800
corresponding ui detect data structure

62
00:02:36,800 --> 00:02:39,360
from ui detect data tree which is a

63
00:02:39,360 --> 00:02:40,720
global variable

64
00:02:40,720 --> 00:02:42,800
advocate structure tech graph and

65
00:02:42,800 --> 00:02:45,120
initialize the tag and the reference

66
00:02:45,120 --> 00:02:47,200
columns and also following the similar

67
00:02:47,200 --> 00:02:49,519
pattern the kernel will find prog q2

68
00:02:49,519 --> 00:02:52,160
data from a global variable and allocate

69
00:02:52,160 --> 00:02:54,160
a structure called subtab

70
00:02:54,160 --> 00:02:55,840
and different subtext structures are

71
00:02:55,840 --> 00:02:57,680
linked together

72
00:02:57,680 --> 00:02:58,959
as you can see

73
00:02:58,959 --> 00:03:00,959
please remember the subtext structure

74
00:03:00,959 --> 00:03:03,360
because later we will see a user free

75
00:03:03,360 --> 00:03:04,879
happens here

76
00:03:04,879 --> 00:03:08,720
cool so here is the overview of all the

77
00:03:08,720 --> 00:03:10,879
related kernel data structures while

78
00:03:10,879 --> 00:03:12,640
socket is tactic

79
00:03:12,640 --> 00:03:15,200
and as we mentioned in the last slide

80
00:03:15,200 --> 00:03:17,920
the model will create tech rep structure

81
00:03:17,920 --> 00:03:19,760
and subtext structures

82
00:03:19,760 --> 00:03:21,360
so

83
00:03:21,360 --> 00:03:24,239
when a circuit is untacted the relevance

84
00:03:24,239 --> 00:03:28,080
come in the tag wrap is decreased

85
00:03:28,080 --> 00:03:31,040
and subtac is unlinked from the linked

86
00:03:31,040 --> 00:03:33,519
list and three later you may also

87
00:03:33,519 --> 00:03:36,000
imagine the basic idea of how cleanup

88
00:03:36,000 --> 00:03:36,959
works

89
00:03:36,959 --> 00:03:39,680
when a user decides to cross module is

90
00:03:39,680 --> 00:03:41,920
that all the related socket tag and

91
00:03:41,920 --> 00:03:44,560
proxy to this data structure will be

92
00:03:44,560 --> 00:03:47,280
unlinked and free

93
00:03:47,280 --> 00:03:48,080
cool

94
00:03:48,080 --> 00:03:48,879
so

95
00:03:48,879 --> 00:03:50,720
since the model was introduced in

96
00:03:50,720 --> 00:03:53,840
android since 2011 there were two

97
00:03:53,840 --> 00:03:56,000
vulnerabilities reported to google in

98
00:03:56,000 --> 00:03:57,120
the past

99
00:03:57,120 --> 00:04:02,400
so the first bug is cv 2016 3809 this

100
00:04:02,400 --> 00:04:04,400
one is pretty well known it's very

101
00:04:04,400 --> 00:04:06,400
important kernel information leak issue

102
00:04:06,400 --> 00:04:08,640
for leaking the kernel stock address

103
00:04:08,640 --> 00:04:11,760
you may just read the certified system

104
00:04:11,760 --> 00:04:13,680
and the raw pointer is written to the

105
00:04:13,680 --> 00:04:14,959
user space

106
00:04:14,959 --> 00:04:17,199
it helps a lot of exploit to make them

107
00:04:17,199 --> 00:04:19,120
more stable and easier to exploit the

108
00:04:19,120 --> 00:04:22,320
kernel such as the pinball expert

109
00:04:22,320 --> 00:04:24,240
the root cause is pretty obvious because

110
00:04:24,240 --> 00:04:26,400
the format string is not applied

111
00:04:26,400 --> 00:04:27,440
properly

112
00:04:27,440 --> 00:04:31,199
so a novel user may might be able to

113
00:04:31,199 --> 00:04:33,280
read the draw pointed address

114
00:04:33,280 --> 00:04:35,040
cool

115
00:04:35,040 --> 00:04:37,600
the other one is a user-free on

116
00:04:37,600 --> 00:04:40,800
tag wrap tree by risk condition due to

117
00:04:40,800 --> 00:04:43,919
improv blocking so as you can see from

118
00:04:43,919 --> 00:04:47,199
2011 to 2020 there are only two

119
00:04:47,199 --> 00:04:49,520
vulnerabilities in this model and the

120
00:04:49,520 --> 00:04:53,199
model got replaced since ngq by ebpl

121
00:04:53,199 --> 00:04:53,919
so

122
00:04:53,919 --> 00:04:57,199
what can possibly go wrong in 2021

123
00:04:57,199 --> 00:05:00,320
um the bug was reported by the external

124
00:05:00,320 --> 00:05:02,400
researcher earlier this year saying that

125
00:05:02,400 --> 00:05:05,280
there is a financial user free

126
00:05:05,280 --> 00:05:07,360
under certain conditions no proof of

127
00:05:07,360 --> 00:05:10,960
concept or exploitation details provided

128
00:05:10,960 --> 00:05:13,600
but researchers believe it's impossible

129
00:05:13,600 --> 00:05:16,400
to export our modern devices because of

130
00:05:16,400 --> 00:05:18,639
the hardware level mitigation user

131
00:05:18,639 --> 00:05:20,000
access overwrite

132
00:05:20,000 --> 00:05:22,960
which is enabled on kernel 4.14 by

133
00:05:22,960 --> 00:05:26,080
default and usually android x3 will

134
00:05:26,080 --> 00:05:28,080
choose to temper the address limit so

135
00:05:28,080 --> 00:05:30,880
the expert can use pipe cisco to do

136
00:05:30,880 --> 00:05:32,639
actually kind of read and write there

137
00:05:32,639 --> 00:05:34,720
are a lot of ways to

138
00:05:34,720 --> 00:05:37,360
temper the address limit like for

139
00:05:37,360 --> 00:05:40,240
instance you may set up a drop job

140
00:05:40,240 --> 00:05:42,639
to several well no kind of functions and

141
00:05:42,639 --> 00:05:44,240
the kernel is happy to override the

142
00:05:44,240 --> 00:05:46,320
address limit for you

143
00:05:46,320 --> 00:05:47,919
but with the

144
00:05:47,919 --> 00:05:50,400
user access override mitigation it's not

145
00:05:50,400 --> 00:05:53,520
likely to export currently this way and

146
00:05:53,520 --> 00:05:55,680
that's why external researchers believe

147
00:05:55,680 --> 00:05:57,600
the vulnerability might not be able to

148
00:05:57,600 --> 00:06:00,960
export on modern devices and thus the

149
00:06:00,960 --> 00:06:03,120
google industry team decided to

150
00:06:03,120 --> 00:06:04,639
investigate the likelihood of

151
00:06:04,639 --> 00:06:06,479
exploitation this vulnerability

152
00:06:06,479 --> 00:06:08,479
and see if it still works on modern

153
00:06:08,479 --> 00:06:11,039
devices

154
00:06:11,039 --> 00:06:12,800
therefore when the bug was reported to

155
00:06:12,800 --> 00:06:14,880
google richard quickly wrote a minimum

156
00:06:14,880 --> 00:06:16,720
part for kendall crash

157
00:06:16,720 --> 00:06:19,120
it's very simple as you can see a text

158
00:06:19,120 --> 00:06:22,319
socket and then untag the socket from

159
00:06:22,319 --> 00:06:24,479
chart process x to program and kind of

160
00:06:24,479 --> 00:06:25,440
crash

161
00:06:25,440 --> 00:06:27,759
so how is it possible

162
00:06:27,759 --> 00:06:30,720
let's take a closer look at how on text

163
00:06:30,720 --> 00:06:34,000
okay actually works because one a

164
00:06:34,000 --> 00:06:36,960
user space program opens the module as

165
00:06:36,960 --> 00:06:39,520
we said before the model will create

166
00:06:39,520 --> 00:06:41,440
procured data structure

167
00:06:41,440 --> 00:06:42,800
by pid

168
00:06:42,800 --> 00:06:43,840
so

169
00:06:43,840 --> 00:06:45,759
first of all the kernel module tries to

170
00:06:45,759 --> 00:06:48,400
find the corresponding pro qd data

171
00:06:48,400 --> 00:06:52,240
structure based on pid

172
00:06:52,240 --> 00:06:54,319
then unlinks the subtab structure and

173
00:06:54,319 --> 00:06:57,520
free it however as you can see there is

174
00:06:57,520 --> 00:07:01,680
a starting check it says like if the

175
00:07:01,680 --> 00:07:03,919
procured data structure is not found by

176
00:07:03,919 --> 00:07:07,120
pid the model will complain without

177
00:07:07,120 --> 00:07:08,479
doing anything

178
00:07:08,479 --> 00:07:10,319
but the subject text structure will

179
00:07:10,319 --> 00:07:13,759
still get free later so we have a free

180
00:07:13,759 --> 00:07:17,280
subtext structure resize in the

181
00:07:17,280 --> 00:07:19,360
subtab link list

182
00:07:19,360 --> 00:07:21,599
cool so next step is about how to

183
00:07:21,599 --> 00:07:24,240
actually this vulnerability so

184
00:07:24,240 --> 00:07:26,639
let's see how to accelerate this that

185
00:07:26,639 --> 00:07:29,280
this vulnerability to modern

186
00:07:29,280 --> 00:07:31,199
android pipe device which has the

187
00:07:31,199 --> 00:07:32,960
adjusted limit check user access

188
00:07:32,960 --> 00:07:35,919
overwrite slap release random and harden

189
00:07:35,919 --> 00:07:38,400
mitigations and later i will show video

190
00:07:38,400 --> 00:07:41,520
on how to exploit xiaomi mi 9 device

191
00:07:41,520 --> 00:07:43,919
with the latest kind of version 4.14 for

192
00:07:43,919 --> 00:07:45,440
android pi with the aforementioned

193
00:07:45,440 --> 00:07:46,960
mitigations

194
00:07:46,960 --> 00:07:48,240
cool

195
00:07:48,240 --> 00:07:49,440
um so

196
00:07:49,440 --> 00:07:51,360
first of all if you are not very

197
00:07:51,360 --> 00:07:52,720
familiar with android kind of

198
00:07:52,720 --> 00:07:55,120
expectations most android

199
00:07:55,120 --> 00:07:58,560
devices nowadays use k malloc 108 as the

200
00:07:58,560 --> 00:08:02,000
minimum size of the step object so the

201
00:08:02,000 --> 00:08:05,360
size of the object allocated by k malloc

202
00:08:05,360 --> 00:08:06,800
is actually

203
00:08:06,800 --> 00:08:08,639
128 bytes

204
00:08:08,639 --> 00:08:10,240
the first kind of system we want to

205
00:08:10,240 --> 00:08:12,479
abuse is eventfd

206
00:08:12,479 --> 00:08:15,360
so as you can see the member count

207
00:08:15,360 --> 00:08:17,840
overlaps the leasehold in the

208
00:08:17,840 --> 00:08:19,520
subtext structure

209
00:08:19,520 --> 00:08:21,520
the idea for

210
00:08:21,520 --> 00:08:25,199
doing kernel heap league is that

211
00:08:25,199 --> 00:08:27,840
well subtech is already free

212
00:08:27,840 --> 00:08:30,560
spread event fd to make sure an event of

213
00:08:30,560 --> 00:08:33,919
these structures occupy the free uh sub

214
00:08:33,919 --> 00:08:35,440
tax structure

215
00:08:35,440 --> 00:08:37,519
and now you can see two stock tax

216
00:08:37,519 --> 00:08:39,519
structure linked together

217
00:08:39,519 --> 00:08:40,880
and the

218
00:08:40,880 --> 00:08:43,200
left side is spread by

219
00:08:43,200 --> 00:08:44,880
event of d

220
00:08:44,880 --> 00:08:47,839
cool and then we untag the subtext

221
00:08:47,839 --> 00:08:50,000
structure on the right side

222
00:08:50,000 --> 00:08:52,720
so the only primitive will overwrite

223
00:08:52,720 --> 00:08:56,320
come to the address of the list head

224
00:08:56,320 --> 00:08:58,160
and then we can read the certified

225
00:08:58,160 --> 00:09:00,480
system to get the count from the event

226
00:09:00,480 --> 00:09:04,080
empty so we can

227
00:09:04,080 --> 00:09:06,160
leak kernel keep addresses and later

228
00:09:06,160 --> 00:09:10,240
turn this into a special kind of w3

229
00:09:10,240 --> 00:09:11,680
so

230
00:09:11,680 --> 00:09:14,240
a knife idea for getting double free in

231
00:09:14,240 --> 00:09:16,640
this case is that

232
00:09:16,640 --> 00:09:18,240
you may ask for this user free

233
00:09:18,240 --> 00:09:21,680
vulnerability and probably craft to

234
00:09:21,680 --> 00:09:24,240
same subtext structure so kernel might

235
00:09:24,240 --> 00:09:25,440
be able to

236
00:09:25,440 --> 00:09:26,399
like

237
00:09:26,399 --> 00:09:27,839
release a sub

238
00:09:27,839 --> 00:09:29,360
structure twice

239
00:09:29,360 --> 00:09:32,000
but essentially the kernel model also

240
00:09:32,000 --> 00:09:34,560
has to like unlink the subtext structure

241
00:09:34,560 --> 00:09:37,200
and free them later so what happens if

242
00:09:37,200 --> 00:09:39,839
we have uh two identical stock tax

243
00:09:39,839 --> 00:09:41,920
structures or

244
00:09:41,920 --> 00:09:43,920
the stock tax charge has the invalid

245
00:09:43,920 --> 00:09:45,360
attack

246
00:09:45,360 --> 00:09:47,600
obvious silicon will crash because there

247
00:09:47,600 --> 00:09:49,839
are several security checks in the

248
00:09:49,839 --> 00:09:52,640
cleanup code so for example if we crop a

249
00:09:52,640 --> 00:09:55,200
circuit structure with embedded tag

250
00:09:55,200 --> 00:09:56,720
the kernel crashes because the

251
00:09:56,720 --> 00:09:59,200
corresponding tag rep structure does not

252
00:09:59,200 --> 00:10:00,399
exist

253
00:10:00,399 --> 00:10:03,519
and if we create two identical subtext

254
00:10:03,519 --> 00:10:05,360
structure the reference card will become

255
00:10:05,360 --> 00:10:08,959
invalid so kind of word crash 2.

256
00:10:08,959 --> 00:10:10,240
therefore

257
00:10:10,240 --> 00:10:12,720
in order to bypass all the security

258
00:10:12,720 --> 00:10:14,160
checks

259
00:10:14,160 --> 00:10:16,560
here is the way i figure out so first of

260
00:10:16,560 --> 00:10:17,680
all

261
00:10:17,680 --> 00:10:20,800
untapped the subtab b structure by a

262
00:10:20,800 --> 00:10:24,000
chart process so we have a

263
00:10:24,000 --> 00:10:26,560
user free first okay

264
00:10:26,560 --> 00:10:31,200
and then we spray event fd to occupy the

265
00:10:31,200 --> 00:10:33,279
subtext b structure

266
00:10:33,279 --> 00:10:35,519
and then on tag the circuit text

267
00:10:35,519 --> 00:10:36,800
structure c

268
00:10:36,800 --> 00:10:39,200
so the unlinked primitive will help us

269
00:10:39,200 --> 00:10:41,200
link the address of the

270
00:10:41,200 --> 00:10:43,200
subtext tag c

271
00:10:43,200 --> 00:10:44,160
okay

272
00:10:44,160 --> 00:10:46,720
and similarly you may leak the list head

273
00:10:46,720 --> 00:10:49,040
address as we mentioned earlier

274
00:10:49,040 --> 00:10:51,440
and there are also the subtext structure

275
00:10:51,440 --> 00:10:53,040
e f and g

276
00:10:53,040 --> 00:10:54,800
in the linked list but we will talk

277
00:10:54,800 --> 00:10:56,399
about them later

278
00:10:56,399 --> 00:10:58,640
so uh now in order to bypass the

279
00:10:58,640 --> 00:11:00,880
security checks we have to spray the

280
00:11:00,880 --> 00:11:02,320
first two objects

281
00:11:02,320 --> 00:11:05,360
and do tech impersonation

282
00:11:05,360 --> 00:11:06,320
okay

283
00:11:06,320 --> 00:11:09,279
so the original tag are b and d and now

284
00:11:09,279 --> 00:11:12,640
we already overwrite the tag to

285
00:11:12,640 --> 00:11:15,120
enf

286
00:11:15,120 --> 00:11:17,760
and then overwrite the next list to the

287
00:11:17,760 --> 00:11:20,000
this header node so we actually unlink

288
00:11:20,000 --> 00:11:22,640
the subtext structure e fg from the

289
00:11:22,640 --> 00:11:24,959
linked list and the model cleanup code

290
00:11:24,959 --> 00:11:26,959
will never see them on the

291
00:11:26,959 --> 00:11:28,480
subtac link list

292
00:11:28,480 --> 00:11:30,160
we may also have to free these two

293
00:11:30,160 --> 00:11:32,320
crafted objects because the first eight

294
00:11:32,320 --> 00:11:34,640
bytes of the object must be a valid

295
00:11:34,640 --> 00:11:37,279
address for rb erase operation

296
00:11:37,279 --> 00:11:38,399
okay

297
00:11:38,399 --> 00:11:39,200
so

298
00:11:39,200 --> 00:11:41,600
in this we may free the crafted circuit

299
00:11:41,600 --> 00:11:44,480
text gestures without changing any

300
00:11:44,480 --> 00:11:46,320
kernel checks we will later use this

301
00:11:46,320 --> 00:11:49,200
primitive for performing a

302
00:11:49,200 --> 00:11:50,639
specialty free

303
00:11:50,639 --> 00:11:52,240
okay

304
00:11:52,240 --> 00:11:54,320
and by the way four devices are still

305
00:11:54,320 --> 00:11:58,760
vulnerable to cv 2016-3809

306
00:11:58,800 --> 00:12:00,800
exporting the kernel might be much

307
00:12:00,800 --> 00:12:04,240
easier because we can abuse the subpoena

308
00:12:04,240 --> 00:12:06,560
from the model cleanup code and craft a

309
00:12:06,560 --> 00:12:08,959
corrupted kind of stock structure

310
00:12:08,959 --> 00:12:11,360
okay and

311
00:12:11,360 --> 00:12:13,839
if you check the size of the subtext

312
00:12:13,839 --> 00:12:14,880
gesture

313
00:12:14,880 --> 00:12:16,720
it's 64 bytes

314
00:12:16,720 --> 00:12:20,000
so luckily a 128 by slab object can hold

315
00:12:20,000 --> 00:12:22,720
two subtext structure and thus we may

316
00:12:22,720 --> 00:12:24,639
impersonate the tag g

317
00:12:24,639 --> 00:12:26,880
and craft another subtext structure in

318
00:12:26,880 --> 00:12:29,200
the same slab object

319
00:12:29,200 --> 00:12:31,440
and when the model is doing a clean up

320
00:12:31,440 --> 00:12:34,320
the mod the kind of model will free the

321
00:12:34,320 --> 00:12:36,320
suck tag and free the sub tag in the

322
00:12:36,320 --> 00:12:39,200
middle consequently which will help us

323
00:12:39,200 --> 00:12:41,120
the canoeists area by this special

324
00:12:41,120 --> 00:12:43,120
candidate free

325
00:12:43,120 --> 00:12:44,079
and

326
00:12:44,079 --> 00:12:46,639
to recognize here we may consider

327
00:12:46,639 --> 00:12:48,720
smearing the slab at the beginning of

328
00:12:48,720 --> 00:12:51,760
the x-ray in this following way and keep

329
00:12:51,760 --> 00:12:54,160
opening the proc cpu info for asking the

330
00:12:54,160 --> 00:12:56,399
kernel allocated in terms of sequence

331
00:12:56,399 --> 00:12:57,519
file

332
00:12:57,519 --> 00:12:58,560
structures

333
00:12:58,560 --> 00:13:01,040
because of the w3 the sequence file

334
00:13:01,040 --> 00:13:02,240
structures

335
00:13:02,240 --> 00:13:04,839
are likely to overlap each other in this

336
00:13:04,839 --> 00:13:06,480
case

337
00:13:06,480 --> 00:13:08,000
okay

338
00:13:08,000 --> 00:13:10,160
the overlapped event fd and sequence

339
00:13:10,160 --> 00:13:14,320
file leads to a very interesting result

340
00:13:14,320 --> 00:13:16,720
that comes from the event fd

341
00:13:16,720 --> 00:13:19,519
now becomes a sequence operation

342
00:13:19,519 --> 00:13:21,519
and luckily the spin lock from the event

343
00:13:21,519 --> 00:13:24,079
fd context just works because it

344
00:13:24,079 --> 00:13:26,000
overlapped the spin lock from the

345
00:13:26,000 --> 00:13:27,760
sequence file structure

346
00:13:27,760 --> 00:13:29,040
so we can

347
00:13:29,040 --> 00:13:31,519
easily connect there

348
00:13:31,519 --> 00:13:34,079
and if the staff release is not hardened

349
00:13:34,079 --> 00:13:36,399
you may also abuse double free primitive

350
00:13:36,399 --> 00:13:38,639
to do kernel space mirror attack

351
00:13:38,639 --> 00:13:40,399
but unfortunately the mitigation is

352
00:13:40,399 --> 00:13:43,120
enabled in midnight device

353
00:13:43,120 --> 00:13:46,000
so abusing the double free primate

354
00:13:46,000 --> 00:13:49,600
directly is not very possible

355
00:13:49,600 --> 00:13:51,760
there are also other candidates such as

356
00:13:51,760 --> 00:13:54,399
escape underscore put where you may

357
00:13:54,399 --> 00:13:56,880
control the sub gesture

358
00:13:56,880 --> 00:13:58,639
it might be possible to use this

359
00:13:58,639 --> 00:14:00,880
preemptive to disable assignments and

360
00:14:00,880 --> 00:14:03,839
could canopy restriction

361
00:14:04,480 --> 00:14:06,560
but my approach is to override the

362
00:14:06,560 --> 00:14:08,160
sequence operation because sequence

363
00:14:08,160 --> 00:14:09,839
operation contains several kind of

364
00:14:09,839 --> 00:14:12,240
function pointer so tempering the

365
00:14:12,240 --> 00:14:14,160
sequence operation might be a king

366
00:14:14,160 --> 00:14:17,920
injection for us so

367
00:14:17,920 --> 00:14:20,399
let's take a look at event fdm

368
00:14:20,399 --> 00:14:22,000
not only you can

369
00:14:22,000 --> 00:14:25,279
use event fd to leak kernel information

370
00:14:25,279 --> 00:14:27,920
we can also write data to the event of

371
00:14:27,920 --> 00:14:29,519
defined exclusion

372
00:14:29,519 --> 00:14:32,240
and override the count so in this case

373
00:14:32,240 --> 00:14:35,120
we can control the count from the

374
00:14:35,120 --> 00:14:37,920
eventfd which is equivalent to

375
00:14:37,920 --> 00:14:40,160
overwriting the sequence operation

376
00:14:40,160 --> 00:14:42,560
but since we have a lot of file

377
00:14:42,560 --> 00:14:45,519
descriptor over in the cpu info how can

378
00:14:45,519 --> 00:14:48,000
we find the file descriptor of the

379
00:14:48,000 --> 00:14:50,160
overlapped sequence or sequence file

380
00:14:50,160 --> 00:14:51,760
object

381
00:14:51,760 --> 00:14:54,240
my solution is to overwrite the sequence

382
00:14:54,240 --> 00:14:55,760
operation from

383
00:14:55,760 --> 00:14:59,120
cpu info op to consolesub and read data

384
00:14:59,120 --> 00:15:00,399
from every

385
00:15:00,399 --> 00:15:02,959
file descriptor so we can find

386
00:15:02,959 --> 00:15:05,920
the corresponding file description

387
00:15:05,920 --> 00:15:08,320
and as we mentioned before now the

388
00:15:08,320 --> 00:15:10,639
challenge is to

389
00:15:10,639 --> 00:15:12,959
craft a sequence operation to control

390
00:15:12,959 --> 00:15:16,399
kernel ip and perform an escalation of

391
00:15:16,399 --> 00:15:17,440
privilege

392
00:15:17,440 --> 00:15:19,519
we might need to spray a sequence file

393
00:15:19,519 --> 00:15:21,680
again in order to ask kernel to use the

394
00:15:21,680 --> 00:15:24,160
crafted sequence operation correctly

395
00:15:24,160 --> 00:15:26,639
and if user access override is not

396
00:15:26,639 --> 00:15:29,199
enabled you may use the drop gadget on

397
00:15:29,199 --> 00:15:30,399
the

398
00:15:30,399 --> 00:15:32,160
kernel guest software function to

399
00:15:32,160 --> 00:15:34,320
gracefully temper the address limit but

400
00:15:34,320 --> 00:15:36,560
unfortunately it doesn't work on 4.4 in

401
00:15:36,560 --> 00:15:39,199
kernel the kernel will check the address

402
00:15:39,199 --> 00:15:41,839
and limit during error ciscos and kernel

403
00:15:41,839 --> 00:15:43,920
enables hardware level mitigation user

404
00:15:43,920 --> 00:15:45,600
access overwrite

405
00:15:45,600 --> 00:15:48,560
so we have to find

406
00:15:48,560 --> 00:15:51,120
another way to properly fill the

407
00:15:51,120 --> 00:15:53,199
drop gadget

408
00:15:53,199 --> 00:15:55,920
um as mentioned by project zero we can

409
00:15:55,920 --> 00:15:59,040
invoke bpf program as the

410
00:15:59,040 --> 00:16:01,040
ultimate rob

411
00:16:01,040 --> 00:16:04,240
if the second argument is the address of

412
00:16:04,240 --> 00:16:07,199
the bpf instructions then kernel is very

413
00:16:07,199 --> 00:16:09,360
happy to ask you arbitrary bpf

414
00:16:09,360 --> 00:16:12,160
instructions without verification thus

415
00:16:12,160 --> 00:16:14,240
we can use this

416
00:16:14,240 --> 00:16:16,639
ultimate drop to do the local escalation

417
00:16:16,639 --> 00:16:19,759
of privilege and as a consequence

418
00:16:19,759 --> 00:16:20,800
you can

419
00:16:20,800 --> 00:16:23,120
get an abstract kind of read and write

420
00:16:23,120 --> 00:16:25,440
primitive for instance you may disable

421
00:16:25,440 --> 00:16:29,600
kernel pointed risk and say linux

422
00:16:29,600 --> 00:16:34,480
and also you can you can hammer the

423
00:16:34,959 --> 00:16:36,959
stock escape correct

424
00:16:36,959 --> 00:16:39,600
by executing upgrade bpf instructions

425
00:16:39,600 --> 00:16:42,880
and finally get a routine you can put

426
00:16:42,880 --> 00:16:46,800
the bvf instructions in a step 110

427
00:16:46,800 --> 00:16:48,839
bytes object because these bvf

428
00:16:48,839 --> 00:16:52,240
instructions are just 108 bytes

429
00:16:52,240 --> 00:16:53,120
okay

430
00:16:53,120 --> 00:16:54,480
cool so

431
00:16:54,480 --> 00:16:56,160
here is the

432
00:16:56,160 --> 00:16:58,240
video demo video about

433
00:16:58,240 --> 00:17:00,240
tons midnight device

434
00:17:00,240 --> 00:17:03,720
in 10 seconds

435
00:17:10,640 --> 00:17:13,760
so now we have russia

436
00:17:16,880 --> 00:17:19,839
cool

437
00:17:22,000 --> 00:17:23,599
one more thing about this kind of module

438
00:17:23,599 --> 00:17:25,439
is that i found another user free

439
00:17:25,439 --> 00:17:28,400
vulnerability when writing the puck uh

440
00:17:28,400 --> 00:17:30,720
it's basically a risk condition

441
00:17:30,720 --> 00:17:32,320
so when

442
00:17:32,320 --> 00:17:35,679
cpu0 gets the lock retrieve an object

443
00:17:35,679 --> 00:17:37,200
from q

444
00:17:37,200 --> 00:17:39,360
release the log and read the tag from

445
00:17:39,360 --> 00:17:40,480
the object

446
00:17:40,480 --> 00:17:43,600
uh however another cpu may grab the lock

447
00:17:43,600 --> 00:17:45,200
free object

448
00:17:45,200 --> 00:17:46,880
and

449
00:17:46,880 --> 00:17:48,080
drop the log

450
00:17:48,080 --> 00:17:51,200
so on project applications may talk to

451
00:17:51,200 --> 00:17:54,640
uh network standard manager in a very

452
00:17:54,640 --> 00:17:56,480
conventional way and lead kind of

453
00:17:56,480 --> 00:17:58,400
information it's probably going to take

454
00:17:58,400 --> 00:18:00,720
some time for leaking kernel information

455
00:18:00,720 --> 00:18:02,320
but it works

456
00:18:02,320 --> 00:18:04,559
so the patch is to make sure the object

457
00:18:04,559 --> 00:18:06,000
read operation

458
00:18:06,000 --> 00:18:09,440
is also protected by the lock

459
00:18:09,440 --> 00:18:14,000
so the summary of x protein cv 2021 0399

460
00:18:14,000 --> 00:18:16,160
is that first of all we have to get a

461
00:18:16,160 --> 00:18:18,799
special kind of free primitive

462
00:18:18,799 --> 00:18:21,679
and the overlapping event and sequence

463
00:18:21,679 --> 00:18:24,320
file structures can hijack the control

464
00:18:24,320 --> 00:18:27,039
flow by crafting sequence operation by

465
00:18:27,039 --> 00:18:28,400
writing to the

466
00:18:28,400 --> 00:18:30,480
event fd descriptor

467
00:18:30,480 --> 00:18:33,039
and also by reading the event id5

468
00:18:33,039 --> 00:18:34,720
descriptor we can leak kernel

469
00:18:34,720 --> 00:18:36,559
information

470
00:18:36,559 --> 00:18:39,120
also if user's override mitigation is

471
00:18:39,120 --> 00:18:42,320
enabled return to bpf might be on your

472
00:18:42,320 --> 00:18:43,679
friends

473
00:18:43,679 --> 00:18:45,520
and now please work on regional for the

474
00:18:45,520 --> 00:18:47,360
rest of presentation about defensive

475
00:18:47,360 --> 00:18:49,600
side

476
00:18:49,760 --> 00:18:51,440
now that xinyu has explained the

477
00:18:51,440 --> 00:18:53,520
exploitation i'll look at some of the

478
00:18:53,520 --> 00:18:55,600
mitigations making this more difficult

479
00:18:55,600 --> 00:18:58,000
or impossible and then review some of

480
00:18:58,000 --> 00:19:00,080
our defensive systems that help us find

481
00:19:00,080 --> 00:19:02,720
malicious software

482
00:19:02,720 --> 00:19:05,120
starting with kernel mitigations the

483
00:19:05,120 --> 00:19:07,200
first one is a compilation setting

484
00:19:07,200 --> 00:19:09,360
affecting pointers in the free lists

485
00:19:09,360 --> 00:19:11,760
maintained by memory management

486
00:19:11,760 --> 00:19:15,919
added in linux 4.14 in november 2017

487
00:19:15,919 --> 00:19:18,960
config slab free list hardened excels

488
00:19:18,960 --> 00:19:21,200
the free list pointer in slub caches

489
00:19:21,200 --> 00:19:24,000
with a per cash random value this makes

490
00:19:24,000 --> 00:19:26,080
exploiting free list pointer overrides

491
00:19:26,080 --> 00:19:28,480
more difficult as unless the attacker

492
00:19:28,480 --> 00:19:31,280
also knows the xor value they don't get

493
00:19:31,280 --> 00:19:33,360
control of the memory address

494
00:19:33,360 --> 00:19:35,919
this can be bypassed using the signal fd

495
00:19:35,919 --> 00:19:37,679
technique shown on the slide and

496
00:19:37,679 --> 00:19:39,200
described earlier

497
00:19:39,200 --> 00:19:41,760
spraying signal fd context structures

498
00:19:41,760 --> 00:19:44,400
allows a mostly user-specified value to

499
00:19:44,400 --> 00:19:47,120
be set via the mask argument i say

500
00:19:47,120 --> 00:19:49,280
mostly because two additional bits are

501
00:19:49,280 --> 00:19:51,760
set in the value written so the attacker

502
00:19:51,760 --> 00:19:54,240
doesn't have complete control over it

503
00:19:54,240 --> 00:19:56,320
but detection of the list corruption can

504
00:19:56,320 --> 00:19:58,960
be avoided

505
00:19:59,039 --> 00:20:01,840
kernel electric fence is a low overhead

506
00:20:01,840 --> 00:20:04,080
sampling based memory safety error

507
00:20:04,080 --> 00:20:07,600
detector added to linux in 2020

508
00:20:07,600 --> 00:20:10,640
it detects out of bounds heap access use

509
00:20:10,640 --> 00:20:13,760
after free and invalid free errors

510
00:20:13,760 --> 00:20:16,000
k-fence uses a sampling interval to

511
00:20:16,000 --> 00:20:18,159
determine whether to apply guards to a

512
00:20:18,159 --> 00:20:20,559
memory allocation when the sample

513
00:20:20,559 --> 00:20:22,720
interval is reached the next memory

514
00:20:22,720 --> 00:20:24,960
allocation made will be guarded and the

515
00:20:24,960 --> 00:20:27,200
sample interval is reset

516
00:20:27,200 --> 00:20:29,280
the guarded memory allocation requires

517
00:20:29,280 --> 00:20:31,919
additional page table entries one page

518
00:20:31,919 --> 00:20:34,080
of memory for the allocation itself and

519
00:20:34,080 --> 00:20:36,320
the guard page either side of it

520
00:20:36,320 --> 00:20:38,320
the actual memory allocation is made

521
00:20:38,320 --> 00:20:40,080
either at the beginning or the end of

522
00:20:40,080 --> 00:20:41,200
its page

523
00:20:41,200 --> 00:20:43,280
the remainder of this page is not used

524
00:20:43,280 --> 00:20:45,440
for other allocations but is filled with

525
00:20:45,440 --> 00:20:47,520
known patterns to enable detecting

526
00:20:47,520 --> 00:20:50,240
incorrect rights into this area

527
00:20:50,240 --> 00:20:52,480
other underflows or overflows will be

528
00:20:52,480 --> 00:20:54,720
caught by the guard pages

529
00:20:54,720 --> 00:20:56,880
k fence will not detect every memory

530
00:20:56,880 --> 00:20:59,280
safety error as not every allocation

531
00:20:59,280 --> 00:21:01,760
will be guarded an individual kernel is

532
00:21:01,760 --> 00:21:04,320
very unlikely to apply guards to a given

533
00:21:04,320 --> 00:21:05,840
memory allocation

534
00:21:05,840 --> 00:21:08,240
however with enough systems running it

535
00:21:08,240 --> 00:21:10,240
code paths which cause errors will get

536
00:21:10,240 --> 00:21:12,159
exercised with guards applied to those

537
00:21:12,159 --> 00:21:16,960
allocations identifying bugs

538
00:21:16,960 --> 00:21:18,320
the common technique in kernel

539
00:21:18,320 --> 00:21:20,880
exploitation was to overwrite the user

540
00:21:20,880 --> 00:21:23,280
mode address limit value this was used

541
00:21:23,280 --> 00:21:24,799
by the kernel to check whether an

542
00:21:24,799 --> 00:21:27,039
address provided by user mode via assist

543
00:21:27,039 --> 00:21:29,919
call is allowable or safe to access are

544
00:21:29,919 --> 00:21:32,320
you whether it was a user mode address

545
00:21:32,320 --> 00:21:34,400
addresses below the limit are okay

546
00:21:34,400 --> 00:21:36,640
addresses above the limit are not

547
00:21:36,640 --> 00:21:38,080
if the address limit could be

548
00:21:38,080 --> 00:21:40,799
overwritten by -1 the kernel would think

549
00:21:40,799 --> 00:21:42,880
that it was okay for user mode to access

550
00:21:42,880 --> 00:21:44,880
the entire address space including

551
00:21:44,880 --> 00:21:46,320
kernel memory

552
00:21:46,320 --> 00:21:48,080
having overwritten the address limit

553
00:21:48,080 --> 00:21:50,640
using an exploit to read kernel memory

554
00:21:50,640 --> 00:21:53,600
from user mode a pipe would be created

555
00:21:53,600 --> 00:21:56,240
next a write syscall to the pipe using a

556
00:21:56,240 --> 00:21:58,080
kernel memory address for its buffer

557
00:21:58,080 --> 00:22:00,000
would copy from the desired kernel

558
00:22:00,000 --> 00:22:02,320
memory into the pipes buffer

559
00:22:02,320 --> 00:22:04,320
this will be followed by a read syscall

560
00:22:04,320 --> 00:22:06,480
to read the data from the pipe buffer

561
00:22:06,480 --> 00:22:08,320
and place it into the given user mode

562
00:22:08,320 --> 00:22:09,440
buffer

563
00:22:09,440 --> 00:22:11,520
a similar two-step process can be used

564
00:22:11,520 --> 00:22:13,440
to write the kernel memory

565
00:22:13,440 --> 00:22:15,520
the right cisco writes data into the

566
00:22:15,520 --> 00:22:17,760
pipes buffer then the read syscall

567
00:22:17,760 --> 00:22:19,520
reached from the pipe into a kernel

568
00:22:19,520 --> 00:22:20,960
address

569
00:22:20,960 --> 00:22:22,640
this exploitation technique was

570
00:22:22,640 --> 00:22:24,960
mitigated using arm's user access

571
00:22:24,960 --> 00:22:28,159
override bit uao changes the behavior of

572
00:22:28,159 --> 00:22:31,280
the ldtr and stdr instructions when they

573
00:22:31,280 --> 00:22:33,360
are used by the kernel to perform memory

574
00:22:33,360 --> 00:22:34,960
copy operations

575
00:22:34,960 --> 00:22:37,280
for example those required by read write

576
00:22:37,280 --> 00:22:39,760
syscalls in the technique just given

577
00:22:39,760 --> 00:22:42,000
if the uao bit is set then the

578
00:22:42,000 --> 00:22:44,000
instructions behave as privileged load

579
00:22:44,000 --> 00:22:46,720
store and cannot access user memory if

580
00:22:46,720 --> 00:22:49,120
the uao bit is clear the instructions

581
00:22:49,120 --> 00:22:50,960
are unprivileged and cannot access

582
00:22:50,960 --> 00:22:54,000
kernel memory so whichever state the uao

583
00:22:54,000 --> 00:22:56,080
bit is in one of the read or write

584
00:22:56,080 --> 00:22:58,320
operations will fail and the attacker

585
00:22:58,320 --> 00:23:00,400
cannot access kernel memory using this

586
00:23:00,400 --> 00:23:01,919
technique

587
00:23:01,919 --> 00:23:03,520
this can be worked around using the

588
00:23:03,520 --> 00:23:05,440
return to bpf technique described

589
00:23:05,440 --> 00:23:07,840
earlier address limit protection has

590
00:23:07,840 --> 00:23:09,840
also changed in more recent versions of

591
00:23:09,840 --> 00:23:12,080
linux resulting in the removal of this

592
00:23:12,080 --> 00:23:15,199
configuration option

593
00:23:15,679 --> 00:23:17,919
from the explanation of the exploitation

594
00:23:17,919 --> 00:23:20,159
earlier you may remember the sequence

595
00:23:20,159 --> 00:23:22,720
file structure was used overlapping

596
00:23:22,720 --> 00:23:25,679
event fd context and sequence file

597
00:23:25,679 --> 00:23:27,840
allowed shinyu to use the sequence file

598
00:23:27,840 --> 00:23:30,559
structures sequence operation member as

599
00:23:30,559 --> 00:23:33,039
the event fd context structures count

600
00:23:33,039 --> 00:23:35,440
member and therefore leak kernel memory

601
00:23:35,440 --> 00:23:36,640
addresses

602
00:23:36,640 --> 00:23:38,960
later on in the exploitation process

603
00:23:38,960 --> 00:23:41,279
overwriting sequence operations was used

604
00:23:41,279 --> 00:23:42,799
to demonstrate control of the

605
00:23:42,799 --> 00:23:44,799
instruction pointer

606
00:23:44,799 --> 00:23:46,720
sequence file has been used in many

607
00:23:46,720 --> 00:23:49,279
linux kernel experts moving it into a

608
00:23:49,279 --> 00:23:51,279
dedicated cache would obviously make the

609
00:23:51,279 --> 00:23:53,679
techniques mentioned stop working as it

610
00:23:53,679 --> 00:23:55,279
would not be possible to confuse

611
00:23:55,279 --> 00:23:58,159
structure types

612
00:23:58,559 --> 00:24:00,480
control flow integrity tries to make

613
00:24:00,480 --> 00:24:02,640
sure that indirect calls and functions

614
00:24:02,640 --> 00:24:04,480
go where they are supposed to

615
00:24:04,480 --> 00:24:06,480
without this attackers can hijack the

616
00:24:06,480 --> 00:24:08,480
control flow of the program or in this

617
00:24:08,480 --> 00:24:10,799
case the kernel by changing function

618
00:24:10,799 --> 00:24:13,760
pointer addresses or return addresses

619
00:24:13,760 --> 00:24:16,240
cfi is implemented for android using

620
00:24:16,240 --> 00:24:18,559
clang and is performed at the final link

621
00:24:18,559 --> 00:24:20,640
stage so all information is available

622
00:24:20,640 --> 00:24:22,400
regarding function addresses and their

623
00:24:22,400 --> 00:24:24,799
callers this does somewhat increase the

624
00:24:24,799 --> 00:24:27,520
link time when building the kernel image

625
00:24:27,520 --> 00:24:29,760
for indirect calls the compiler

626
00:24:29,760 --> 00:24:31,679
essentially inserts a check on the

627
00:24:31,679 --> 00:24:33,760
target address just before the call

628
00:24:33,760 --> 00:24:34,880
happens

629
00:24:34,880 --> 00:24:36,720
if the target address is not in the list

630
00:24:36,720 --> 00:24:38,880
of allowed addresses for that call site

631
00:24:38,880 --> 00:24:40,480
the kernel panics

632
00:24:40,480 --> 00:24:42,480
as shown on the slide in this case

633
00:24:42,480 --> 00:24:44,840
trying to use the modified sequence file

634
00:24:44,840 --> 00:24:47,679
operations would have been detected so

635
00:24:47,679 --> 00:24:49,919
an alternative way to execute return to

636
00:24:49,919 --> 00:24:53,039
bpf would have been required

637
00:24:53,039 --> 00:24:55,520
cfi usage in android has been increasing

638
00:24:55,520 --> 00:24:57,520
each year as more oems enable the

639
00:24:57,520 --> 00:24:59,279
feature in their kernels

640
00:24:59,279 --> 00:25:01,840
cfi is also used in the generic kernel

641
00:25:01,840 --> 00:25:04,080
image project so as newer android

642
00:25:04,080 --> 00:25:06,960
devices start shipping with gki kernels

643
00:25:06,960 --> 00:25:09,440
cfi support across android will continue

644
00:25:09,440 --> 00:25:12,080
to increase

645
00:25:12,640 --> 00:25:14,960
this kernel configuration setting causes

646
00:25:14,960 --> 00:25:17,279
bpf to always use the just-in-time

647
00:25:17,279 --> 00:25:20,400
compiler the bpf instruction interpreter

648
00:25:20,400 --> 00:25:22,720
itself is not compiled with this setting

649
00:25:22,720 --> 00:25:24,960
enabled so it is not present in the

650
00:25:24,960 --> 00:25:27,600
kernel image as xingi demonstrated

651
00:25:27,600 --> 00:25:28,480
earlier

652
00:25:28,480 --> 00:25:31,279
if the bpf interpreter is present then

653
00:25:31,279 --> 00:25:32,960
having control of the instruction

654
00:25:32,960 --> 00:25:35,039
pointer and some arguments allows it to

655
00:25:35,039 --> 00:25:37,520
be called to execute arbitrary bpf

656
00:25:37,520 --> 00:25:39,520
instructions without them having gone

657
00:25:39,520 --> 00:25:41,279
through the verifier

658
00:25:41,279 --> 00:25:43,840
this blocks the return to bpf technique

659
00:25:43,840 --> 00:25:46,080
that was used to bypass other mitigation

660
00:25:46,080 --> 00:25:48,639
techniques

661
00:25:48,799 --> 00:25:51,600
the final kernel mitigation config debug

662
00:25:51,600 --> 00:25:53,760
list is another one recommended by

663
00:25:53,760 --> 00:25:56,400
project xero this time by maddie stone

664
00:25:56,400 --> 00:25:59,279
which is also now required for android

665
00:25:59,279 --> 00:26:01,200
after an operation on a linked list

666
00:26:01,200 --> 00:26:03,200
element the forward and backward

667
00:26:03,200 --> 00:26:05,039
pointers are checked to ensure that the

668
00:26:05,039 --> 00:26:06,880
links between elements in the list are

669
00:26:06,880 --> 00:26:07,919
valid

670
00:26:07,919 --> 00:26:09,440
this means that list corruption is

671
00:26:09,440 --> 00:26:12,000
detected as it occurs which would stop

672
00:26:12,000 --> 00:26:13,760
the techniques described earlier from

673
00:26:13,760 --> 00:26:15,360
being used

674
00:26:15,360 --> 00:26:17,679
so there are a number of mitigations

675
00:26:17,679 --> 00:26:19,440
which could have and in some cases

676
00:26:19,440 --> 00:26:21,440
actually did block various parts of the

677
00:26:21,440 --> 00:26:23,679
exploit some of these were encountered

678
00:26:23,679 --> 00:26:25,600
on devices during development of the

679
00:26:25,600 --> 00:26:27,679
exploit and these were able to be worked

680
00:26:27,679 --> 00:26:28,799
around

681
00:26:28,799 --> 00:26:31,039
multiple mitigations that together block

682
00:26:31,039 --> 00:26:33,200
all parts of the exploitation techniques

683
00:26:33,200 --> 00:26:35,520
described here are required now on

684
00:26:35,520 --> 00:26:38,080
android so other vulnerabilities in the

685
00:26:38,080 --> 00:26:42,158
future will require different methods

686
00:26:42,640 --> 00:26:44,080
now we'll talk about some of the other

687
00:26:44,080 --> 00:26:47,600
ways we protect android users

688
00:26:47,600 --> 00:26:49,760
starting with on-device protection

689
00:26:49,760 --> 00:26:51,760
android's application verification

690
00:26:51,760 --> 00:26:53,679
feature is something you may be familiar

691
00:26:53,679 --> 00:26:55,840
with when an app is side loaded for

692
00:26:55,840 --> 00:26:58,559
example the verifier will check to see

693
00:26:58,559 --> 00:27:01,039
if it's known to be malware as well as

694
00:27:01,039 --> 00:27:03,919
checking for specific apks this also

695
00:27:03,919 --> 00:27:06,000
looks at the similarity of the apk on

696
00:27:06,000 --> 00:27:07,039
device

697
00:27:07,039 --> 00:27:09,200
information about known bad applications

698
00:27:09,200 --> 00:27:11,440
for the similarity check is provided by

699
00:27:11,440 --> 00:27:13,919
google servers this is to handle small

700
00:27:13,919 --> 00:27:16,159
differences in an apk's contents which

701
00:27:16,159 --> 00:27:17,919
would defeat hash comparisons for

702
00:27:17,919 --> 00:27:19,039
example

703
00:27:19,039 --> 00:27:20,960
this covers the case where a side loaded

704
00:27:20,960 --> 00:27:23,039
application contains a local privilege

705
00:27:23,039 --> 00:27:25,200
elevation exploit to support malicious

706
00:27:25,200 --> 00:27:26,880
activities

707
00:27:26,880 --> 00:27:28,880
advanced protection is an opt-in system

708
00:27:28,880 --> 00:27:30,960
that most visibly enables two-factor

709
00:27:30,960 --> 00:27:33,279
authentication and restricts app

710
00:27:33,279 --> 00:27:35,120
installations to a subset of those

711
00:27:35,120 --> 00:27:36,960
available on google play

712
00:27:36,960 --> 00:27:38,960
site loading is disabled and cannot be

713
00:27:38,960 --> 00:27:40,000
enabled

714
00:27:40,000 --> 00:27:41,760
limiting the pool of apps that can be

715
00:27:41,760 --> 00:27:43,760
installed makes users less likely to

716
00:27:43,760 --> 00:27:46,640
encounter malware

717
00:27:46,640 --> 00:27:49,360
moving to server-side analysis we have a

718
00:27:49,360 --> 00:27:51,440
lot of infrastructure analyzing android

719
00:27:51,440 --> 00:27:52,799
applications

720
00:27:52,799 --> 00:27:54,399
all applications are constantly

721
00:27:54,399 --> 00:27:56,559
re-analyzed so that any new detection

722
00:27:56,559 --> 00:27:58,799
rules or analysis systems are applied to

723
00:27:58,799 --> 00:28:01,039
everything over time we use static

724
00:28:01,039 --> 00:28:03,120
analysis to generate information from

725
00:28:03,120 --> 00:28:06,080
apk contents and dynamic analysis to run

726
00:28:06,080 --> 00:28:08,000
the app in an instrumented environment

727
00:28:08,000 --> 00:28:10,720
to get information about what it does

728
00:28:10,720 --> 00:28:12,799
we inspect packers and obfuscators to

729
00:28:12,799 --> 00:28:15,520
support better static analysis the graph

730
00:28:15,520 --> 00:28:17,279
here shows the proportion of malware

731
00:28:17,279 --> 00:28:19,039
apps that are protected by different

732
00:28:19,039 --> 00:28:20,080
packers

733
00:28:20,080 --> 00:28:21,679
data like this shows trends in the

734
00:28:21,679 --> 00:28:24,159
ecosystem and allows us to identify

735
00:28:24,159 --> 00:28:26,799
changes in packer popularity which can

736
00:28:26,799 --> 00:28:28,159
indicate that there's a new packer

737
00:28:28,159 --> 00:28:30,960
available for example the long-term

738
00:28:30,960 --> 00:28:33,039
objective of any analysis work that we

739
00:28:33,039 --> 00:28:34,880
do is to automate the process of

740
00:28:34,880 --> 00:28:37,200
extracting new information or performing

741
00:28:37,200 --> 00:28:39,200
additional detection based off what we

742
00:28:39,200 --> 00:28:41,279
learned

743
00:28:41,279 --> 00:28:43,120
static analysis scales better than

744
00:28:43,120 --> 00:28:45,600
dynamic analysis but it can be difficult

745
00:28:45,600 --> 00:28:48,000
to understand what's happening the image

746
00:28:48,000 --> 00:28:50,000
on the left here shows the control flow

747
00:28:50,000 --> 00:28:52,880
for a very simple exploit sample cve

748
00:28:52,880 --> 00:28:55,600
2016-5195

749
00:28:55,600 --> 00:28:57,840
the characteristic m advise and seek

750
00:28:57,840 --> 00:28:59,919
right loops are easy to see

751
00:28:59,919 --> 00:29:01,600
on the right is a different larger

752
00:29:01,600 --> 00:29:03,679
exploit and the middle image shows an

753
00:29:03,679 --> 00:29:06,480
obfuscated function as displayed by ida

754
00:29:06,480 --> 00:29:07,919
which is considerably harder to

755
00:29:07,919 --> 00:29:09,440
understand

756
00:29:09,440 --> 00:29:11,440
dynamic analysis lets you see what the

757
00:29:11,440 --> 00:29:13,919
code actually does provided you can get

758
00:29:13,919 --> 00:29:15,679
it to run and perform its malicious

759
00:29:15,679 --> 00:29:16,880
actions

760
00:29:16,880 --> 00:29:18,880
exploits are generally straightforward

761
00:29:18,880 --> 00:29:21,440
in that they try to exploit the device

762
00:29:21,440 --> 00:29:22,880
there may be checks for whether the

763
00:29:22,880 --> 00:29:25,279
device is supported particularly if the

764
00:29:25,279 --> 00:29:27,440
exploit needs known memory addresses or

765
00:29:27,440 --> 00:29:29,360
offsets and cannot derive these at

766
00:29:29,360 --> 00:29:30,559
runtime

767
00:29:30,559 --> 00:29:32,399
but these can always be knocked out if

768
00:29:32,399 --> 00:29:34,000
you don't mind the risk of crashing your

769
00:29:34,000 --> 00:29:36,080
test device

770
00:29:36,080 --> 00:29:37,760
routing exploits generally need to

771
00:29:37,760 --> 00:29:39,760
interact with the os

772
00:29:39,760 --> 00:29:41,600
obviously if an exploit needs a certain

773
00:29:41,600 --> 00:29:43,600
device driver you have to have the right

774
00:29:43,600 --> 00:29:45,840
device to run it on

775
00:29:45,840 --> 00:29:47,840
if you can see what the exploit asks the

776
00:29:47,840 --> 00:29:49,919
kernel to do then you can start to

777
00:29:49,919 --> 00:29:52,000
understand what's happening

778
00:29:52,000 --> 00:29:54,640
ebpf one of a number of tracing and

779
00:29:54,640 --> 00:29:57,039
monitoring systems for linux allows

780
00:29:57,039 --> 00:29:58,799
monitoring of kernel calls and the

781
00:29:58,799 --> 00:30:00,880
parameters they are given which will

782
00:30:00,880 --> 00:30:03,600
show any suspect behavior the exploit

783
00:30:03,600 --> 00:30:05,760
described by junior relies on kernel

784
00:30:05,760 --> 00:30:07,919
heap sprays to control use after freeze

785
00:30:07,919 --> 00:30:11,440
by manipulating kernel heat layout

786
00:30:11,440 --> 00:30:13,200
heap sprays are typically performed by

787
00:30:13,200 --> 00:30:15,120
allocating and releasing large numbers

788
00:30:15,120 --> 00:30:17,919
of particular objects for example files

789
00:30:17,919 --> 00:30:20,559
or sockets

790
00:30:20,960 --> 00:30:22,480
the technical paper covers the

791
00:30:22,480 --> 00:30:24,399
behavioral detection example in more

792
00:30:24,399 --> 00:30:26,320
detail than we have time for now so

793
00:30:26,320 --> 00:30:28,320
please take a look at that

794
00:30:28,320 --> 00:30:30,240
on the left we can see the start of the

795
00:30:30,240 --> 00:30:32,880
output from xinhu's exploit on the right

796
00:30:32,880 --> 00:30:34,640
we can see output from the trace at

797
00:30:34,640 --> 00:30:36,559
about the same time

798
00:30:36,559 --> 00:30:39,600
at this point you can see 25 000 calls

799
00:30:39,600 --> 00:30:42,240
to event fd which is not normal behavior

800
00:30:42,240 --> 00:30:45,600
for an android application

801
00:30:45,679 --> 00:30:47,760
the next thing that happens is every

802
00:30:47,760 --> 00:30:50,480
second event fd handle is closed which

803
00:30:50,480 --> 00:30:52,880
is again unusual behavior

804
00:30:52,880 --> 00:30:55,120
the suspicious behavior continues in

805
00:30:55,120 --> 00:30:57,519
similar fashion the exploit launches

806
00:30:57,519 --> 00:30:59,120
threads to perform more memory

807
00:30:59,120 --> 00:31:01,039
manipulation work

808
00:31:01,039 --> 00:31:02,960
this exploit has to perform these

809
00:31:02,960 --> 00:31:06,080
actions so if we can see them or similar

810
00:31:06,080 --> 00:31:08,399
happening we can see it

811
00:31:08,399 --> 00:31:10,559
interleaving these required actions with

812
00:31:10,559 --> 00:31:12,559
garbage calls might help disguise the

813
00:31:12,559 --> 00:31:15,279
activities but could affect timing and

814
00:31:15,279 --> 00:31:18,080
hence expert reliability and we may be

815
00:31:18,080 --> 00:31:20,240
able to identify and ignore garbage

816
00:31:20,240 --> 00:31:22,960
calls as well

817
00:31:23,279 --> 00:31:25,200
xingyu encountered a number of problems

818
00:31:25,200 --> 00:31:27,440
developing the exploit but with a lot of

819
00:31:27,440 --> 00:31:29,840
work heap manipulation and help from

820
00:31:29,840 --> 00:31:32,000
other people he overcame them

821
00:31:32,000 --> 00:31:34,080
the workarounds were themselves defeated

822
00:31:34,080 --> 00:31:36,240
by further mitigations which you can

823
00:31:36,240 --> 00:31:38,720
find on current android devices

824
00:31:38,720 --> 00:31:40,559
we mentioned the generic kernel image

825
00:31:40,559 --> 00:31:43,039
project this means kernel updates get

826
00:31:43,039 --> 00:31:45,600
onto user devices faster as there is

827
00:31:45,600 --> 00:31:47,600
less effort involved across the android

828
00:31:47,600 --> 00:31:50,399
ecosystem in updating kernels resulting

829
00:31:50,399 --> 00:31:54,000
in better protection for android users

830
00:31:54,000 --> 00:31:55,760
thank you to two people without whom

831
00:31:55,760 --> 00:31:57,600
this work would not have happened

832
00:31:57,600 --> 00:31:59,840
janhorn for discussing exploitation

833
00:31:59,840 --> 00:32:02,159
techniques suggesting workarounds for

834
00:32:02,159 --> 00:32:04,320
mitigations and more mitigations for the

835
00:32:04,320 --> 00:32:07,519
workarounds and zyjo for donating his

836
00:32:07,519 --> 00:32:09,919
mi9 phone for exploit development and

837
00:32:09,919 --> 00:32:11,039
testing

838
00:32:11,039 --> 00:32:13,120
finally thank you for watching this

839
00:32:13,120 --> 00:32:15,680
presentation

840
00:32:15,680 --> 00:32:25,289
[Music]

