1
00:00:06,360 --> 00:00:09,440
[Music]

2
00:00:09,440 --> 00:00:12,080
good morning and welcome to hb2 the

3
00:00:12,080 --> 00:00:14,559
sequel is always worse

4
00:00:14,559 --> 00:00:16,640
this is the only in-person edition of

5
00:00:16,640 --> 00:00:18,880
this talk so thanks for coming i hope

6
00:00:18,880 --> 00:00:20,720
you enjoy it

7
00:00:20,720 --> 00:00:23,279
have you ever seen something that was so

8
00:00:23,279 --> 00:00:26,240
complex it just had to be hackable if

9
00:00:26,240 --> 00:00:29,519
only you had time to understand it

10
00:00:29,519 --> 00:00:32,960
http 2 is a beautiful beast but it is

11
00:00:32,960 --> 00:00:34,880
complex and where there's complexity

12
00:00:34,880 --> 00:00:37,120
people take shortcuts and things go

13
00:00:37,120 --> 00:00:38,239
wrong

14
00:00:38,239 --> 00:00:40,079
in this session i'll show how you can

15
00:00:40,079 --> 00:00:42,320
use new features in h2 for a range of

16
00:00:42,320 --> 00:00:45,039
high impact attacks and also how those

17
00:00:45,039 --> 00:00:46,960
shed light on a type of request

18
00:00:46,960 --> 00:00:49,360
smuggling that has always existed but

19
00:00:49,360 --> 00:00:52,000
never really been noticed

20
00:00:52,000 --> 00:00:55,280
complexity causes trouble for me too

21
00:00:55,280 --> 00:00:57,600
i first looked at the hb2 spec way back

22
00:00:57,600 --> 00:01:00,480
in 2019 during my http desync attacks

23
00:01:00,480 --> 00:01:01,760
research

24
00:01:01,760 --> 00:01:04,159
and i loaded up the spec looked at the

25
00:01:04,159 --> 00:01:06,640
size of the browser scroll bar and

26
00:01:06,640 --> 00:01:09,520
proceeded to skim read it so fast that i

27
00:01:09,520 --> 00:01:10,960
didn't even read the security

28
00:01:10,960 --> 00:01:12,720
considerations

29
00:01:12,720 --> 00:01:15,119
my next encounter with h2 was after i

30
00:01:15,119 --> 00:01:18,400
presented that research at blackout usa

31
00:01:18,400 --> 00:01:20,080
a member of the audience said did those

32
00:01:20,080 --> 00:01:23,119
techniques work against http 2

33
00:01:23,119 --> 00:01:24,799
and my answer was no it's completely

34
00:01:24,799 --> 00:01:27,759
secure against that kind of thing

35
00:01:27,759 --> 00:01:30,720
and my third encounter was later that

36
00:01:30,720 --> 00:01:33,040
night at a party in vegas somewhere

37
00:01:33,040 --> 00:01:34,560
someone basically just walked up to me

38
00:01:34,560 --> 00:01:35,920
and told me exactly how you could

39
00:01:35,920 --> 00:01:38,799
actually hack things running hb2 with

40
00:01:38,799 --> 00:01:40,799
that style of technique

41
00:01:40,799 --> 00:01:42,320
and

42
00:01:42,320 --> 00:01:44,159
what they explained to me sounded really

43
00:01:44,159 --> 00:01:47,439
promising but i just spent nine months

44
00:01:47,439 --> 00:01:50,000
exploiting request smuggling and desync

45
00:01:50,000 --> 00:01:52,000
attacks and i really didn't want to be

46
00:01:52,000 --> 00:01:54,320
doing any more at that moment so instead

47
00:01:54,320 --> 00:01:56,640
i went off and spent a year doing web

48
00:01:56,640 --> 00:01:58,640
cache poisoning

49
00:01:58,640 --> 00:02:00,479
when i came back though i tried this

50
00:02:00,479 --> 00:02:02,799
technique out and it really worked i

51
00:02:02,799 --> 00:02:04,880
could hack all kinds of interesting

52
00:02:04,880 --> 00:02:06,159
systems

53
00:02:06,159 --> 00:02:08,878
there was just one fly in the ointment

54
00:02:08,878 --> 00:02:11,280
and that was bit bucket

55
00:02:11,280 --> 00:02:14,000
every heuristic that i tried indicated

56
00:02:14,000 --> 00:02:16,640
that bit bucket should be vulnerable

57
00:02:16,640 --> 00:02:19,520
but every actual exploit i tried

58
00:02:19,520 --> 00:02:20,840
reliably

59
00:02:20,840 --> 00:02:23,680
failed and normally when i encounter

60
00:02:23,680 --> 00:02:25,040
something like this

61
00:02:25,040 --> 00:02:27,040
i'll spend a couple of days on it maybe

62
00:02:27,040 --> 00:02:28,879
a couple of weeks and then give up cut

63
00:02:28,879 --> 00:02:30,640
my losses and move on to researching

64
00:02:30,640 --> 00:02:32,319
something else

65
00:02:32,319 --> 00:02:35,599
but i'd seen a scenario that was almost

66
00:02:35,599 --> 00:02:38,239
identical to this during my original

67
00:02:38,239 --> 00:02:40,160
request smuggling research and i really

68
00:02:40,160 --> 00:02:41,840
didn't want to let it escape me a second

69
00:02:41,840 --> 00:02:44,239
time so i kept coming back to this month

70
00:02:44,239 --> 00:02:47,680
after month and eventually in january i

71
00:02:47,680 --> 00:02:49,599
found proper evidence that bitbucket

72
00:02:49,599 --> 00:02:51,599
genuinely was vulnerable

73
00:02:51,599 --> 00:02:53,120
but i still couldn't actually do any

74
00:02:53,120 --> 00:02:55,599
real damage with this technique it like

75
00:02:55,599 --> 00:02:57,360
it was definitely vulnerable but

76
00:02:57,360 --> 00:03:00,400
there was no realistic exploit path

77
00:03:00,400 --> 00:03:02,080
other than that though

78
00:03:02,080 --> 00:03:03,280
things with this research were going

79
00:03:03,280 --> 00:03:06,080
really well until march when emil

80
00:03:06,080 --> 00:03:07,519
published the research that he'd been

81
00:03:07,519 --> 00:03:10,159
doing at the same time as me on the same

82
00:03:10,159 --> 00:03:11,200
topic

83
00:03:11,200 --> 00:03:13,920
and this meant that my presentation was

84
00:03:13,920 --> 00:03:16,560
at risk of just not containing anything

85
00:03:16,560 --> 00:03:19,360
very groundbreaking i really needed to

86
00:03:19,360 --> 00:03:22,319
find something new fast

87
00:03:22,319 --> 00:03:24,879
so naturally i went back to bitbucket

88
00:03:24,879 --> 00:03:27,760
again and this time i finally cracked it

89
00:03:27,760 --> 00:03:30,400
and this led to a cascade of findings

90
00:03:30,400 --> 00:03:32,840
including a new more powerful type of

91
00:03:32,840 --> 00:03:36,000
desynchronization technique

92
00:03:36,000 --> 00:03:38,080
an entire class of issue that was

93
00:03:38,080 --> 00:03:41,120
formerly useless becoming exploitable

94
00:03:41,120 --> 00:03:42,959
at last seen having to log everyone out

95
00:03:42,959 --> 00:03:45,280
of jiva worldwide which was quite fun to

96
00:03:45,280 --> 00:03:47,519
monitor on twitter

97
00:03:47,519 --> 00:03:49,680
and atlassian getting the computer

98
00:03:49,680 --> 00:03:51,840
emergency response team involved and

99
00:03:51,840 --> 00:03:55,040
awarding me triple their maximum bounty

100
00:03:55,040 --> 00:03:56,239
so

101
00:03:56,239 --> 00:03:58,640
out of that mess i've managed to extract

102
00:03:58,640 --> 00:04:01,040
some information that i hope you'll find

103
00:04:01,040 --> 00:04:02,959
really quite useful

104
00:04:02,959 --> 00:04:05,040
i'm not going to try and explain this in

105
00:04:05,040 --> 00:04:07,439
chronological order because looking back

106
00:04:07,439 --> 00:04:09,120
at it it doesn't make much sense even to

107
00:04:09,120 --> 00:04:09,840
me

108
00:04:09,840 --> 00:04:12,400
instead first i'll show how you can use

109
00:04:12,400 --> 00:04:15,439
hp2 for request smuggling then i'll

110
00:04:15,439 --> 00:04:17,440
focus on request tunneling and show

111
00:04:17,440 --> 00:04:19,358
practical techniques to confirm and

112
00:04:19,358 --> 00:04:20,639
exploit it

113
00:04:20,639 --> 00:04:22,400
then i'll cover some other kind of

114
00:04:22,400 --> 00:04:24,800
miscellaneous hp2 techniques

115
00:04:24,800 --> 00:04:26,800
and some practical considerations and

116
00:04:26,800 --> 00:04:29,040
then wrap up with five minutes of

117
00:04:29,040 --> 00:04:31,440
questions

118
00:04:31,440 --> 00:04:34,960
although hb2 is complex there's only

119
00:04:34,960 --> 00:04:36,720
four key things that you need to

120
00:04:36,720 --> 00:04:38,080
understand

121
00:04:38,080 --> 00:04:40,400
in order to effectively use the attacks

122
00:04:40,400 --> 00:04:43,280
shown in this presentation so let's get

123
00:04:43,280 --> 00:04:44,639
started

124
00:04:44,639 --> 00:04:46,960
what you can see here is an identical

125
00:04:46,960 --> 00:04:51,680
request represented in hb1 and hp2

126
00:04:51,680 --> 00:04:54,000
the first key difference is that whereas

127
00:04:54,000 --> 00:04:56,560
hp1 has the has the request line

128
00:04:56,560 --> 00:04:59,120
containing the method and the path hb2

129
00:04:59,120 --> 00:05:01,039
instead has pseudo headers which just

130
00:05:01,039 --> 00:05:02,720
look like normal headers

131
00:05:02,720 --> 00:05:05,120
but they start with a colon

132
00:05:05,120 --> 00:05:07,840
the second difference is that hb1 is a

133
00:05:07,840 --> 00:05:10,240
plain text protocol so for example if

134
00:05:10,240 --> 00:05:11,440
you look at it on the wire with

135
00:05:11,440 --> 00:05:14,080
wireshark or tcp dump you can actually

136
00:05:14,080 --> 00:05:15,039
read it

137
00:05:15,039 --> 00:05:17,280
and also that means from a server's

138
00:05:17,280 --> 00:05:20,080
point of view parsing http requests is

139
00:05:20,080 --> 00:05:22,560
done with string operations like looking

140
00:05:22,560 --> 00:05:25,280
for new lines and that's why it tends to

141
00:05:25,280 --> 00:05:27,759
fall apart generally when you attack it

142
00:05:27,759 --> 00:05:31,520
hb2 meanwhile is a binary protocol using

143
00:05:31,520 --> 00:05:33,680
fixed offsets and such like more like

144
00:05:33,680 --> 00:05:35,680
say tcp

145
00:05:35,680 --> 00:05:36,720
and

146
00:05:36,720 --> 00:05:38,320
if you look at it on the wire it just

147
00:05:38,320 --> 00:05:40,479
looks like binary junk and so what i'm

148
00:05:40,479 --> 00:05:42,880
showing you whenever i represent a hb2

149
00:05:42,880 --> 00:05:45,440
request on a slide is just a human

150
00:05:45,440 --> 00:05:47,919
readable abstraction of it so for

151
00:05:47,919 --> 00:05:50,479
example pseudo headers aren't actually

152
00:05:50,479 --> 00:05:52,800
ascii strings to start with a colon that

153
00:05:52,800 --> 00:05:55,919
actually mapped in the rfc to predefined

154
00:05:55,919 --> 00:05:57,759
bytes

155
00:05:57,759 --> 00:05:59,440
the third difference

156
00:05:59,440 --> 00:06:01,919
is the way the two protocols

157
00:06:01,919 --> 00:06:04,080
tell the server what the length of a

158
00:06:04,080 --> 00:06:06,560
message is with http one you need the

159
00:06:06,560 --> 00:06:08,319
content length or the transfer encoding

160
00:06:08,319 --> 00:06:09,680
header that hopefully you're familiar

161
00:06:09,680 --> 00:06:12,319
with uh whereas in hb2 you don't need

162
00:06:12,319 --> 00:06:13,919
either of those because the length of

163
00:06:13,919 --> 00:06:16,160
the message is built in at the frame

164
00:06:16,160 --> 00:06:17,360
layer

165
00:06:17,360 --> 00:06:19,440
so

166
00:06:19,440 --> 00:06:21,039
it's not shown on these slides because

167
00:06:21,039 --> 00:06:23,440
it's at a slightly lower level but it's

168
00:06:23,440 --> 00:06:25,759
basically impossible to send a hb2

169
00:06:25,759 --> 00:06:28,240
message that is genuinely ambiguous

170
00:06:28,240 --> 00:06:30,160
about what the length of it is

171
00:06:30,160 --> 00:06:31,680
and that's why i thought request

172
00:06:31,680 --> 00:06:36,479
smuggling against hp2 was impossible

173
00:06:37,440 --> 00:06:40,000
the fourth and final key difference is

174
00:06:40,000 --> 00:06:41,520
the way the two protocols handle

175
00:06:41,520 --> 00:06:44,000
multiple requests sent over a single

176
00:06:44,000 --> 00:06:45,199
connection

177
00:06:45,199 --> 00:06:47,840
on hp1 it's terrible you basically you

178
00:06:47,840 --> 00:06:49,520
open your tcp socket and you just whack

179
00:06:49,520 --> 00:06:51,599
the requests down the socket one after

180
00:06:51,599 --> 00:06:53,599
the other and you just read them back in

181
00:06:53,599 --> 00:06:56,160
order and you use the order that the

182
00:06:56,160 --> 00:06:57,919
response has come back to work out which

183
00:06:57,919 --> 00:07:01,039
responses match to which requests and

184
00:07:01,039 --> 00:07:02,639
that is going to become quite

185
00:07:02,639 --> 00:07:05,199
significant later on

186
00:07:05,199 --> 00:07:07,680
whereas in hb2 they have this concept of

187
00:07:07,680 --> 00:07:10,720
a stream id which is basically a label

188
00:07:10,720 --> 00:07:13,840
on every request that lets the browser

189
00:07:13,840 --> 00:07:16,319
and the server correlate requests and

190
00:07:16,319 --> 00:07:17,680
responses and means they don't

191
00:07:17,680 --> 00:07:20,160
necessarily have to be sent back in

192
00:07:20,160 --> 00:07:22,479
order

193
00:07:23,360 --> 00:07:24,240
so

194
00:07:24,240 --> 00:07:26,479
now we understand http 2 let's see what

195
00:07:26,479 --> 00:07:28,080
damage we can do

196
00:07:28,080 --> 00:07:31,039
as usual all the targets in this section

197
00:07:31,039 --> 00:07:33,840
are real websites that had bug bounty

198
00:07:33,840 --> 00:07:35,840
programs uh i found all these

199
00:07:35,840 --> 00:07:38,400
vulnerabilities with the automated tool

200
00:07:38,400 --> 00:07:41,280
hp request smuggler that i have released

201
00:07:41,280 --> 00:07:42,160
and

202
00:07:42,160 --> 00:07:44,879
of any bounties earned 50 have been

203
00:07:44,879 --> 00:07:46,879
donated to local charities by my company

204
00:07:46,879 --> 00:07:48,319
and the other half are going to be spent

205
00:07:48,319 --> 00:07:49,759
on beer

206
00:07:49,759 --> 00:07:52,400
and if you see that squiggle icon at the

207
00:07:52,400 --> 00:07:55,120
bottom that means that there's a

208
00:07:55,120 --> 00:07:57,120
live online replica of that

209
00:07:57,120 --> 00:07:59,039
vulnerability on our website that you

210
00:07:59,039 --> 00:08:01,680
can spin up for free and practice this

211
00:08:01,680 --> 00:08:02,639
hacking

212
00:08:02,639 --> 00:08:04,479
technique for yourself

213
00:08:04,479 --> 00:08:05,360
uh

214
00:08:05,360 --> 00:08:07,599
just to get familiar with it in a safe

215
00:08:07,599 --> 00:08:08,960
environment that won't

216
00:08:08,960 --> 00:08:12,240
affect any real people

217
00:08:12,240 --> 00:08:13,039
so

218
00:08:13,039 --> 00:08:15,039
why is request smuggling possible

219
00:08:15,039 --> 00:08:16,560
against hp2

220
00:08:16,560 --> 00:08:18,960
because the majority of servers that

221
00:08:18,960 --> 00:08:21,520
speak hb2 to clients are actually

222
00:08:21,520 --> 00:08:24,879
rewriting these hb2 requests as http1

223
00:08:24,879 --> 00:08:26,879
and then forwarding them to the backend

224
00:08:26,879 --> 00:08:27,919
server

225
00:08:27,919 --> 00:08:30,319
this behavior which i call http

226
00:08:30,319 --> 00:08:31,680
downgrading

227
00:08:31,680 --> 00:08:34,159
is ridiculously common in fact on some

228
00:08:34,159 --> 00:08:36,240
front-end servers you can't even disable

229
00:08:36,240 --> 00:08:39,039
this it's not even possible to use http

230
00:08:39,039 --> 00:08:41,440
2 end to end

231
00:08:41,440 --> 00:08:43,760
what hdb downgrading does is it

232
00:08:43,760 --> 00:08:45,760
basically dodges all the security

233
00:08:45,760 --> 00:08:48,000
benefits that you should be getting from

234
00:08:48,000 --> 00:08:50,399
using hb2

235
00:08:50,399 --> 00:08:52,240
in fact it arguably makes things worse

236
00:08:52,240 --> 00:08:53,200
because

237
00:08:53,200 --> 00:08:55,760
with classic request muggling it happens

238
00:08:55,760 --> 00:08:57,360
because the front end or the back end

239
00:08:57,360 --> 00:09:00,080
normally uh disagree about whether to

240
00:09:00,080 --> 00:09:01,760
use the content length header or the

241
00:09:01,760 --> 00:09:03,680
transfer encoding header to know the

242
00:09:03,680 --> 00:09:06,000
length of the message

243
00:09:06,000 --> 00:09:08,480
but if you're doing hb2 downgrading

244
00:09:08,480 --> 00:09:11,519
well the back end doesn't know the hb2

245
00:09:11,519 --> 00:09:13,600
message length that information isn't

246
00:09:13,600 --> 00:09:15,680
directly accessible accessible to it so

247
00:09:15,680 --> 00:09:18,000
it has to rely on this translation step

248
00:09:18,000 --> 00:09:20,480
that the front-end dots

249
00:09:20,480 --> 00:09:22,480
and if that sounds like a bit of a mess

250
00:09:22,480 --> 00:09:24,399
that's because it is if you take your

251
00:09:24,399 --> 00:09:25,680
front end

252
00:09:25,680 --> 00:09:27,760
and you turn on hb2 support via

253
00:09:27,760 --> 00:09:30,160
downgrading you've basically doubled the

254
00:09:30,160 --> 00:09:32,000
number of ways that you may be

255
00:09:32,000 --> 00:09:36,279
vulnerable to request smuggling

256
00:09:36,720 --> 00:09:39,600
so let's start with a really simple case

257
00:09:39,600 --> 00:09:40,720
study

258
00:09:40,720 --> 00:09:43,600
the hb2 rfc says

259
00:09:43,600 --> 00:09:45,600
although the content length header is

260
00:09:45,600 --> 00:09:48,000
not required in hb2 because of the frame

261
00:09:48,000 --> 00:09:50,080
length you're actually allowed to send

262
00:09:50,080 --> 00:09:52,240
the content length header provided it's

263
00:09:52,240 --> 00:09:53,360
correct

264
00:09:53,360 --> 00:09:55,760
and netflix used the front end which

265
00:09:55,760 --> 00:09:58,320
forgot to verify that the content length

266
00:09:58,320 --> 00:09:59,920
was correct

267
00:09:59,920 --> 00:10:02,320
so when they did downgrading the

268
00:10:02,320 --> 00:10:04,000
the back end would interpret the

269
00:10:04,000 --> 00:10:07,440
resulting request as 1.5 messages

270
00:10:07,440 --> 00:10:09,519
and the data shown in orange would be

271
00:10:09,519 --> 00:10:12,160
append appended to the start of the next

272
00:10:12,160 --> 00:10:15,920
user's request to hit that website

273
00:10:15,920 --> 00:10:18,160
and here i've i've crafted the orange

274
00:10:18,160 --> 00:10:20,800
data so it will trigger that user to get

275
00:10:20,800 --> 00:10:23,440
redirected to my website

276
00:10:23,440 --> 00:10:25,680
so by sending that in real time i could

277
00:10:25,680 --> 00:10:27,279
redirect random

278
00:10:27,279 --> 00:10:29,440
requests and with a bit of luck redirect

279
00:10:29,440 --> 00:10:31,360
some javascript in

280
00:10:31,360 --> 00:10:32,800
imports and gain

281
00:10:32,800 --> 00:10:34,800
persistent control of other live netflix

282
00:10:34,800 --> 00:10:36,959
users accounts stealing passwords and

283
00:10:36,959 --> 00:10:39,839
credit card details and the like

284
00:10:39,839 --> 00:10:42,399
for that uh i got a 20k bounty off

285
00:10:42,399 --> 00:10:44,079
netflix which was nice

286
00:10:44,079 --> 00:10:45,360
and they also

287
00:10:45,360 --> 00:10:46,880
tracked the root cause of this

288
00:10:46,880 --> 00:10:49,600
vulnerability back to the neti java

289
00:10:49,600 --> 00:10:51,839
library

290
00:10:51,839 --> 00:10:52,959
after that

291
00:10:52,959 --> 00:10:54,560
motivating start let's move on to

292
00:10:54,560 --> 00:10:57,680
something teeny bit more complex the hb2

293
00:10:57,680 --> 00:11:00,800
rfc uh it's pretty good in general but

294
00:11:00,800 --> 00:11:02,000
it's

295
00:11:02,000 --> 00:11:03,600
sometimes it doesn't really explain the

296
00:11:03,600 --> 00:11:06,480
consequences of things so they say

297
00:11:06,480 --> 00:11:08,399
any message containing connection

298
00:11:08,399 --> 00:11:11,040
specific header fields must be treated

299
00:11:11,040 --> 00:11:12,800
as malformed and

300
00:11:12,800 --> 00:11:14,959
maybe that doesn't sound super serious

301
00:11:14,959 --> 00:11:17,519
and amazon's application load balancer

302
00:11:17,519 --> 00:11:19,440
ignored that line

303
00:11:19,440 --> 00:11:21,360
of the rfc

304
00:11:21,360 --> 00:11:23,279
what did that mean well

305
00:11:23,279 --> 00:11:26,079
here we've got oaths law enforcement

306
00:11:26,079 --> 00:11:29,120
backdoor portal thing and they're using

307
00:11:29,120 --> 00:11:31,040
application load balancer

308
00:11:31,040 --> 00:11:33,600
and one connection specific header field

309
00:11:33,600 --> 00:11:36,560
is transfer encoding chunked so they've

310
00:11:36,560 --> 00:11:38,720
downgraded this request which should

311
00:11:38,720 --> 00:11:41,519
have been rejected as malformed and once

312
00:11:41,519 --> 00:11:43,040
again the back end has become

313
00:11:43,040 --> 00:11:45,600
desynchronized and i've appended some

314
00:11:45,600 --> 00:11:47,519
data to the next request shown in orange

315
00:11:47,519 --> 00:11:50,399
which once again triggers a redirect to

316
00:11:50,399 --> 00:11:52,079
my server

317
00:11:52,079 --> 00:11:54,800
when i reported this they said well it's

318
00:11:54,800 --> 00:11:57,200
just a redirect what damage can it do

319
00:11:57,200 --> 00:11:58,800
and i was like are you asking me to

320
00:11:58,800 --> 00:12:00,560
exploit some live users and they were

321
00:12:00,560 --> 00:12:03,200
like yes so i was like fantastic uh and

322
00:12:03,200 --> 00:12:04,320
i did

323
00:12:04,320 --> 00:12:06,160
and what i found was i kept redirecting

324
00:12:06,160 --> 00:12:07,920
people who were in the middle of i was

325
00:12:07,920 --> 00:12:10,320
logging flows and we're there by leaking

326
00:12:10,320 --> 00:12:13,360
oauth codes via the referral header

327
00:12:13,360 --> 00:12:17,040
for that i got 7k off oath

328
00:12:17,040 --> 00:12:19,200
this technique also worked on everything

329
00:12:19,200 --> 00:12:22,399
using the imperver cloud web application

330
00:12:22,399 --> 00:12:24,480
firewall which is supposed to make

331
00:12:24,480 --> 00:12:27,600
websites more secure

332
00:12:27,600 --> 00:12:29,279
on another site

333
00:12:29,279 --> 00:12:31,600
this was another oath target i could

334
00:12:31,600 --> 00:12:33,760
once again use the same technique thanks

335
00:12:33,760 --> 00:12:35,600
to application load balancer to trigger

336
00:12:35,600 --> 00:12:37,519
redirect to my server

337
00:12:37,519 --> 00:12:40,160
and here when i redirected people i saw

338
00:12:40,160 --> 00:12:41,600
something else

339
00:12:41,600 --> 00:12:43,839
people kept sending requests to my

340
00:12:43,839 --> 00:12:46,639
website that basically said

341
00:12:46,639 --> 00:12:48,480
hey there can i have permission to send

342
00:12:48,480 --> 00:12:50,079
you my password

343
00:12:50,079 --> 00:12:51,920
so i was like okay sure i wrote up some

344
00:12:51,920 --> 00:12:54,480
code and i said yeah go ahead send me

345
00:12:54,480 --> 00:12:56,720
your credentials please uh and they did

346
00:12:56,720 --> 00:12:58,560
and i've got a brilliant video taken

347
00:12:58,560 --> 00:13:01,440
with tcp dump showing a stream of

348
00:13:01,440 --> 00:13:03,600
credentials being sent to my server in

349
00:13:03,600 --> 00:13:05,519
real time which i really wanted to share

350
00:13:05,519 --> 00:13:09,200
but it's impossible to redact uh

351
00:13:09,200 --> 00:13:12,399
so yeah and after that i got 10k off

352
00:13:12,399 --> 00:13:14,959
once again

353
00:13:15,200 --> 00:13:18,079
that was the basic stuff hopefully all

354
00:13:18,079 --> 00:13:19,680
fairly familiar stuff if you're familiar

355
00:13:19,680 --> 00:13:20,959
with request smuggling now things are

356
00:13:20,959 --> 00:13:24,000
going to get a bit more http too

357
00:13:24,000 --> 00:13:27,279
one cool thing about h2 is that it's a

358
00:13:27,279 --> 00:13:29,839
binary protocol and as part of that it

359
00:13:29,839 --> 00:13:31,760
lets you put arbitrary characters

360
00:13:31,760 --> 00:13:34,959
wherever you like and relies on an extra

361
00:13:34,959 --> 00:13:37,200
layer of server logic to say things like

362
00:13:37,200 --> 00:13:38,560
actually no you shouldn't put that

363
00:13:38,560 --> 00:13:39,920
character

364
00:13:39,920 --> 00:13:41,839
in that location

365
00:13:41,839 --> 00:13:44,800
so firefox's start page was powered by

366
00:13:44,800 --> 00:13:47,440
the netlify cdn

367
00:13:47,440 --> 00:13:49,279
and they forgot to say that you can't

368
00:13:49,279 --> 00:13:50,720
put new lines

369
00:13:50,720 --> 00:13:53,199
in hp header values this is something

370
00:13:53,199 --> 00:13:56,320
which is impossible in hp1

371
00:13:56,320 --> 00:13:58,720
and thanks to that we've got the request

372
00:13:58,720 --> 00:14:00,800
header injection vulnerability that i'm

373
00:14:00,800 --> 00:14:02,720
exploiting here to trigger request

374
00:14:02,720 --> 00:14:03,760
smuggling

375
00:14:03,760 --> 00:14:06,880
and smuggle malicious prefix here

376
00:14:06,880 --> 00:14:08,720
because there's a cdn

377
00:14:08,720 --> 00:14:11,600
by changing my prefix to have my own

378
00:14:11,600 --> 00:14:14,160
host header i can make requests to

379
00:14:14,160 --> 00:14:16,560
firefox's start page

380
00:14:16,560 --> 00:14:18,800
i serve content from my own site on the

381
00:14:18,800 --> 00:14:21,920
netlify cdn and also netify would cache

382
00:14:21,920 --> 00:14:23,360
that and thereby serve it up

383
00:14:23,360 --> 00:14:26,160
persistently so effectively i got full

384
00:14:26,160 --> 00:14:28,880
persistent control over every page on

385
00:14:28,880 --> 00:14:32,399
every website using the netlify cdn

386
00:14:32,399 --> 00:14:35,680
and for that i got 2k off mozilla and 2k

387
00:14:35,680 --> 00:14:39,040
off netlify

388
00:14:39,440 --> 00:14:41,519
now when i try the same technique on

389
00:14:41,519 --> 00:14:43,199
atlassian's jira

390
00:14:43,199 --> 00:14:47,120
something unexpected happened

391
00:14:47,760 --> 00:14:48,800
i was

392
00:14:48,800 --> 00:14:51,279
expecting to see two different responses

393
00:14:51,279 --> 00:14:52,720
coming back

394
00:14:52,720 --> 00:14:55,199
uh the normal one and the poison one the

395
00:14:55,199 --> 00:14:57,040
text is probably pretty small but you

396
00:14:57,040 --> 00:14:58,399
can probably see we're not getting two

397
00:14:58,399 --> 00:15:00,240
responses coming back we're getting a

398
00:15:00,240 --> 00:15:02,959
huge range of responses

399
00:15:02,959 --> 00:15:04,880
which i've had to adapt

400
00:15:04,880 --> 00:15:06,240
because they're clearly coming from

401
00:15:06,240 --> 00:15:08,560
different jiva deployments they're

402
00:15:08,560 --> 00:15:10,399
intended for different people and they

403
00:15:10,399 --> 00:15:12,639
contain a huge amount of sensitive

404
00:15:12,639 --> 00:15:14,320
information

405
00:15:14,320 --> 00:15:15,120
and

406
00:15:15,120 --> 00:15:17,279
i had no idea why that happened

407
00:15:17,279 --> 00:15:19,680
uh and eventually i was able to figure

408
00:15:19,680 --> 00:15:20,480
out

409
00:15:20,480 --> 00:15:22,800
what the issue was because i could put

410
00:15:22,800 --> 00:15:25,440
new lines in headers i decided to try

411
00:15:25,440 --> 00:15:27,760
and put my malicious prefix entirely

412
00:15:27,760 --> 00:15:29,839
inside the foo header instead of putting

413
00:15:29,839 --> 00:15:31,199
it in the body

414
00:15:31,199 --> 00:15:34,240
just because it kind of seemed easier

415
00:15:34,240 --> 00:15:36,800
and i forgot that when a front end does

416
00:15:36,800 --> 00:15:38,720
downgrading it's going to put a couple

417
00:15:38,720 --> 00:15:41,759
of new lines on the end of the headers

418
00:15:41,759 --> 00:15:43,279
so in my head

419
00:15:43,279 --> 00:15:46,079
i was sending 1.5 requests to the back

420
00:15:46,079 --> 00:15:49,680
end but i was actually sending exactly

421
00:15:49,680 --> 00:15:51,680
two requests and when you do that

422
00:15:51,680 --> 00:15:54,880
something slightly special happens so

423
00:15:54,880 --> 00:15:57,199
the i got the response to the first

424
00:15:57,199 --> 00:15:58,639
request

425
00:15:58,639 --> 00:16:00,720
the response to the second smuggled one

426
00:16:00,720 --> 00:16:02,959
went to the next user but then because

427
00:16:02,959 --> 00:16:04,639
it perfectly lined up

428
00:16:04,639 --> 00:16:06,880
that user's response went to the next

429
00:16:06,880 --> 00:16:09,279
user and so on

430
00:16:09,279 --> 00:16:11,680
so this didn't just send incorrect

431
00:16:11,680 --> 00:16:13,920
responses to me it sent random

432
00:16:13,920 --> 00:16:17,120
authenticated responses to everybody

433
00:16:17,120 --> 00:16:19,199
and thanks to the set cookie header this

434
00:16:19,199 --> 00:16:21,680
was effectively logging random people

435
00:16:21,680 --> 00:16:23,440
into random accounts

436
00:16:23,440 --> 00:16:25,199
worldwide

437
00:16:25,199 --> 00:16:27,040
and i didn't realize this and i gave

438
00:16:27,040 --> 00:16:28,720
this pock to the security team and they

439
00:16:28,720 --> 00:16:31,040
were running it without realizing it

440
00:16:31,040 --> 00:16:32,720
and then they realized it

441
00:16:32,720 --> 00:16:34,720
and that's why they had to log everyone

442
00:16:34,720 --> 00:16:37,759
out of jira

443
00:16:37,759 --> 00:16:39,920
this technique as we saw it worked on

444
00:16:39,920 --> 00:16:42,480
netlify it also it worked on jira

445
00:16:42,480 --> 00:16:44,800
because they were using the pulse secure

446
00:16:44,800 --> 00:16:47,360
virtual traffic manager front end you

447
00:16:47,360 --> 00:16:49,920
might have heard of pulse secure

448
00:16:49,920 --> 00:16:52,639
it also worked on f5's big ip load

449
00:16:52,639 --> 00:16:55,279
balancer and it also predictably worked

450
00:16:55,279 --> 00:16:57,759
on the imperver web application firewall

451
00:16:57,759 --> 00:16:59,759
even after they'd fixed the previous

452
00:16:59,759 --> 00:17:00,959
issue

453
00:17:00,959 --> 00:17:02,880
the disclosure of that one last one was

454
00:17:02,880 --> 00:17:04,400
slightly messy because when they fixed

455
00:17:04,400 --> 00:17:06,400
the previous issue they didn't actually

456
00:17:06,400 --> 00:17:09,039
tell me that they'd fixed it so when i

457
00:17:09,039 --> 00:17:10,400
reported this

458
00:17:10,400 --> 00:17:12,000
to them several months before my

459
00:17:12,000 --> 00:17:14,400
presentation at blackout usa they didn't

460
00:17:14,400 --> 00:17:16,079
reply and i didn't really think anything

461
00:17:16,079 --> 00:17:17,839
of it and then the day before my

462
00:17:17,839 --> 00:17:19,359
presentation i checked back and they

463
00:17:19,359 --> 00:17:20,959
were still vulnerable

464
00:17:20,959 --> 00:17:22,959
uh so i had to get in contact with them

465
00:17:22,959 --> 00:17:25,039
quite urgently uh but

466
00:17:25,039 --> 00:17:27,439
fortunately they were able to deploy

467
00:17:27,439 --> 00:17:30,559
a waffle using their own waff to patch

468
00:17:30,559 --> 00:17:32,640
their waff and thereby secure their

469
00:17:32,640 --> 00:17:34,960
customers

470
00:17:34,960 --> 00:17:38,240
while waiting for the post-secure proper

471
00:17:38,240 --> 00:17:40,720
fix to this issue atlassian tried out a

472
00:17:40,720 --> 00:17:43,120
few hot fixes on joa and it kind of

473
00:17:43,120 --> 00:17:44,720
shows some of the things that

474
00:17:44,720 --> 00:17:46,480
can some of the variants of these issues

475
00:17:46,480 --> 00:17:47,679
that you can find

476
00:17:47,679 --> 00:17:49,360
so one issue with it was there were

477
00:17:49,360 --> 00:17:51,360
filtering header names but they weren't

478
00:17:51,360 --> 00:17:53,440
filtering new lines in head of

479
00:17:53,440 --> 00:17:55,360
sorry they were filtering values but not

480
00:17:55,360 --> 00:17:58,480
names and by itself you can't do that

481
00:17:58,480 --> 00:18:00,320
much with that but by also putting

482
00:18:00,320 --> 00:18:02,400
colons in header names you can make that

483
00:18:02,400 --> 00:18:04,080
practically exploitable

484
00:18:04,080 --> 00:18:06,559
and trigger request monkey

485
00:18:06,559 --> 00:18:08,880
also uh they were filtering names and

486
00:18:08,880 --> 00:18:10,559
values by this point but they forgot to

487
00:18:10,559 --> 00:18:12,880
filter studio headers called causing

488
00:18:12,880 --> 00:18:15,440
request line injection which could once

489
00:18:15,440 --> 00:18:17,840
again cause request smuggling

490
00:18:17,840 --> 00:18:20,000
and finally in the path pseudo header

491
00:18:20,000 --> 00:18:21,840
only they blocked the slash r slash n

492
00:18:21,840 --> 00:18:23,840
sequence but they didn't block slash in

493
00:18:23,840 --> 00:18:26,640
by itself which is still sufficient

494
00:18:26,640 --> 00:18:29,760
for successful exploitation

495
00:18:29,760 --> 00:18:32,080
so there in summary we've seen a range

496
00:18:32,080 --> 00:18:33,280
of techniques that you can use to

497
00:18:33,280 --> 00:18:35,919
exploit hp2 downgrades and achieve

498
00:18:35,919 --> 00:18:38,720
requests smuggling

499
00:18:40,080 --> 00:18:41,520
now we're going to take a look at

500
00:18:41,520 --> 00:18:42,720
something

501
00:18:42,720 --> 00:18:44,080
less flashy

502
00:18:44,080 --> 00:18:46,160
and less obvious but still quite

503
00:18:46,160 --> 00:18:47,840
dangerous

504
00:18:47,840 --> 00:18:50,000
when you find a request smuggling

505
00:18:50,000 --> 00:18:52,559
vulnerability the possible attacks that

506
00:18:52,559 --> 00:18:54,480
you have available that will actually

507
00:18:54,480 --> 00:18:55,360
work

508
00:18:55,360 --> 00:18:57,600
are affected by how the front end

509
00:18:57,600 --> 00:18:59,760
decides whether to reuse an existing

510
00:18:59,760 --> 00:19:02,000
connection with the back end server or

511
00:19:02,000 --> 00:19:03,600
to create a new one

512
00:19:03,600 --> 00:19:05,120
normally there's some kind of shared

513
00:19:05,120 --> 00:19:06,640
connection pool when you can exploit

514
00:19:06,640 --> 00:19:08,880
random users just fine

515
00:19:08,880 --> 00:19:11,200
but sometimes you'll find that you can

516
00:19:11,200 --> 00:19:12,880
only affect

517
00:19:12,880 --> 00:19:15,840
requests coming from your own ip and

518
00:19:15,840 --> 00:19:17,760
when you see that that's because the

519
00:19:17,760 --> 00:19:20,559
front end is only is mapping one connect

520
00:19:20,559 --> 00:19:22,480
it's creating one connection to the

521
00:19:22,480 --> 00:19:25,919
backend server per client ip

522
00:19:25,919 --> 00:19:27,600
but that scenario is not that

523
00:19:27,600 --> 00:19:29,120
inconvenient because it's still

524
00:19:29,120 --> 00:19:31,120
exploitable via cache poisoning and you

525
00:19:31,120 --> 00:19:33,919
can still leak internal headers and

526
00:19:33,919 --> 00:19:35,919
maybe if you use a vpn you can exploit

527
00:19:35,919 --> 00:19:40,400
everyone else using the vpn and so on

528
00:19:40,480 --> 00:19:43,840
what bitbucket had was the most extreme

529
00:19:43,840 --> 00:19:45,440
scenario

530
00:19:45,440 --> 00:19:47,760
where they create a new connection to

531
00:19:47,760 --> 00:19:50,240
the back end for every single request

532
00:19:50,240 --> 00:19:52,880
they never ever reuse connections to the

533
00:19:52,880 --> 00:19:54,720
back end and what i'm going to show you

534
00:19:54,720 --> 00:19:57,520
is how to prove this issue really exists

535
00:19:57,520 --> 00:19:59,360
and some new exploit paths that let you

536
00:19:59,360 --> 00:20:01,760
enable header theft and cache poisoning

537
00:20:01,760 --> 00:20:04,080
to basically make this a practical

538
00:20:04,080 --> 00:20:06,640
useful issue

539
00:20:06,640 --> 00:20:08,880
let's visualize what happens here so

540
00:20:08,880 --> 00:20:10,960
here we're targeting bitbucket or

541
00:20:10,960 --> 00:20:13,120
someone like that and

542
00:20:13,120 --> 00:20:14,960
you can see we've successfully smuggled

543
00:20:14,960 --> 00:20:17,840
1.5 requests to the back end

544
00:20:17,840 --> 00:20:19,520
but because the front end is never going

545
00:20:19,520 --> 00:20:22,400
to reuse this socket

546
00:20:22,400 --> 00:20:24,720
it's just being discarded and the data

547
00:20:24,720 --> 00:20:26,240
shown in orange is effectively being

548
00:20:26,240 --> 00:20:28,480
discarded by the back end or the front

549
00:20:28,480 --> 00:20:30,000
end and

550
00:20:30,000 --> 00:20:32,480
the request shown in green the victim is

551
00:20:32,480 --> 00:20:34,480
completely unaffected by whatever we've

552
00:20:34,480 --> 00:20:36,240
tried to do

553
00:20:36,240 --> 00:20:38,159
this happens naturally on some server

554
00:20:38,159 --> 00:20:39,919
setups and it's also deliberately

555
00:20:39,919 --> 00:20:43,280
triggered by amazon's http desync

556
00:20:43,280 --> 00:20:45,360
guardian uh whenever it sees a

557
00:20:45,360 --> 00:20:48,000
suspicious request i should mention that

558
00:20:48,000 --> 00:20:50,240
it didn't regard my hp 2 attacks as

559
00:20:50,240 --> 00:20:53,280
being suspicious

560
00:20:53,679 --> 00:20:56,080
so this causes a bunch of problems

561
00:20:56,080 --> 00:20:58,000
the first one is with

562
00:20:58,000 --> 00:20:59,840
confirming that there is really a

563
00:20:59,840 --> 00:21:01,919
vulnerability present because although

564
00:21:01,919 --> 00:21:05,039
the the classic timeout-based technique

565
00:21:05,039 --> 00:21:06,559
that you can use to find request

566
00:21:06,559 --> 00:21:08,240
smuggling still detects this

567
00:21:08,240 --> 00:21:09,600
vulnerability

568
00:21:09,600 --> 00:21:11,679
the normal confirmation strategy of

569
00:21:11,679 --> 00:21:13,760
sending a bunch of

570
00:21:13,760 --> 00:21:15,760
of requests and confirming the earlier

571
00:21:15,760 --> 00:21:18,240
requests affect later ones

572
00:21:18,240 --> 00:21:20,080
doesn't work so it's easy to mistake

573
00:21:20,080 --> 00:21:23,679
this for a false positive report

574
00:21:23,679 --> 00:21:26,640
you might think it's quite easy to

575
00:21:26,640 --> 00:21:28,240
to detect just smuggle a complete

576
00:21:28,240 --> 00:21:29,200
request

577
00:21:29,200 --> 00:21:31,919
and see if you get two responses but

578
00:21:31,919 --> 00:21:34,000
the response that you can see here

579
00:21:34,000 --> 00:21:36,240
doesn't actually show that this target

580
00:21:36,240 --> 00:21:38,640
is really vulnerable because that's how

581
00:21:38,640 --> 00:21:42,559
hb 1.1 pipelining works so what that

582
00:21:42,559 --> 00:21:43,679
tells you is

583
00:21:43,679 --> 00:21:45,280
maybe they're vulnerable maybe they're

584
00:21:45,280 --> 00:21:47,600
not it's actually basically a useless

585
00:21:47,600 --> 00:21:50,480
piece of information

586
00:21:50,480 --> 00:21:55,600
fortunately hb 2 fixes this with hp 2

587
00:21:55,600 --> 00:21:58,000
if you trigger request tunneling and

588
00:21:58,000 --> 00:22:00,080
smuggle our whole request then you'll

589
00:22:00,080 --> 00:22:03,120
see a hp 1.1 headers nested inside the

590
00:22:03,120 --> 00:22:06,480
body of the hb2 response clearly proving

591
00:22:06,480 --> 00:22:08,320
that they are vulnerable

592
00:22:08,320 --> 00:22:11,360
to request tunneling

593
00:22:11,360 --> 00:22:13,200
the next problem

594
00:22:13,200 --> 00:22:15,440
is that request tunneling is often blind

595
00:22:15,440 --> 00:22:17,520
which means you can't see the second

596
00:22:17,520 --> 00:22:18,640
response

597
00:22:18,640 --> 00:22:20,640
the reason for that is that the front

598
00:22:20,640 --> 00:22:23,120
end often looks at the content length

599
00:22:23,120 --> 00:22:25,600
header that it's received from the back

600
00:22:25,600 --> 00:22:26,480
end

601
00:22:26,480 --> 00:22:28,640
and it only reads that many bytes off

602
00:22:28,640 --> 00:22:30,960
the socket before passing the response

603
00:22:30,960 --> 00:22:32,400
onto you

604
00:22:32,400 --> 00:22:34,480
and that means you can trigger two

605
00:22:34,480 --> 00:22:36,559
responses but you won't actually see the

606
00:22:36,559 --> 00:22:38,960
second one and this is what bitbucket

607
00:22:38,960 --> 00:22:40,640
had

608
00:22:40,640 --> 00:22:42,720
i found a solution to this problem by

609
00:22:42,720 --> 00:22:44,880
accident i i think sometimes you can

610
00:22:44,880 --> 00:22:46,400
make up for not really knowing what

611
00:22:46,400 --> 00:22:47,840
you're doing just by spending a huge

612
00:22:47,840 --> 00:22:50,640
amount of time on something and that's

613
00:22:50,640 --> 00:22:51,919
what happened here so i was hitting

614
00:22:51,919 --> 00:22:54,559
loads of endpoints on bitbucket and one

615
00:22:54,559 --> 00:22:56,000
of these endpoints was serving some

616
00:22:56,000 --> 00:22:57,840
massive file download

617
00:22:57,840 --> 00:23:00,080
and the file download was so big that

618
00:23:00,080 --> 00:23:02,559
when i hit it in burp repeat it every

619
00:23:02,559 --> 00:23:04,880
time it rendered it made the whole of

620
00:23:04,880 --> 00:23:06,960
burp lag

621
00:23:06,960 --> 00:23:08,880
and it was getting on my nerves so i

622
00:23:08,880 --> 00:23:10,159
thought you know what i actually don't

623
00:23:10,159 --> 00:23:12,320
need the response body

624
00:23:12,320 --> 00:23:14,320
so why don't i just switch the method to

625
00:23:14,320 --> 00:23:16,320
head and as soon as i change the method

626
00:23:16,320 --> 00:23:19,200
to head i started seeing two responses

627
00:23:19,200 --> 00:23:20,720
coming back

628
00:23:20,720 --> 00:23:22,640
that's because their front end hadn't

629
00:23:22,640 --> 00:23:24,720
special cased head and the back end had

630
00:23:24,720 --> 00:23:26,480
still served a content length even

631
00:23:26,480 --> 00:23:27,919
though it wasn't actually intending to

632
00:23:27,919 --> 00:23:29,520
serve a body because when you receive a

633
00:23:29,520 --> 00:23:32,159
head request you don't serve a body

634
00:23:32,159 --> 00:23:34,320
so the front hand so the front end had

635
00:23:34,320 --> 00:23:37,200
over red into the nested response from

636
00:23:37,200 --> 00:23:38,240
the back end

637
00:23:38,240 --> 00:23:40,400
and sent it on to me

638
00:23:40,400 --> 00:23:43,440
so you can often use this this technique

639
00:23:43,440 --> 00:23:46,400
to make request tunneling non-blind

640
00:23:46,400 --> 00:23:48,240
the only catch is that

641
00:23:48,240 --> 00:23:50,960
typically this is based on some kind of

642
00:23:50,960 --> 00:23:53,840
race condition scenario so you may have

643
00:23:53,840 --> 00:23:55,279
to find

644
00:23:55,279 --> 00:23:56,880
you may have to try this a bunch of

645
00:23:56,880 --> 00:24:00,080
times and if your nested request is for

646
00:24:00,080 --> 00:24:02,159
a response that takes longer for the

647
00:24:02,159 --> 00:24:04,720
back end to generate then this will be

648
00:24:04,720 --> 00:24:07,679
less likely to work

649
00:24:07,919 --> 00:24:08,880
so

650
00:24:08,880 --> 00:24:10,320
let's say you've confirmed your request

651
00:24:10,320 --> 00:24:13,200
tunneling how can you exploit it well

652
00:24:13,200 --> 00:24:15,919
obviously you can't attack other users

653
00:24:15,919 --> 00:24:17,600
because connections are not being reused

654
00:24:17,600 --> 00:24:20,159
but you can tunnel internal headers

655
00:24:20,159 --> 00:24:23,039
which are often used by front ends to

656
00:24:23,039 --> 00:24:25,120
do critical site functions such as

657
00:24:25,120 --> 00:24:27,120
informing the back end who you're logged

658
00:24:27,120 --> 00:24:28,640
in as

659
00:24:28,640 --> 00:24:31,039
but to exploit those you need to know

660
00:24:31,039 --> 00:24:32,559
what they're called

661
00:24:32,559 --> 00:24:34,320
and normal header leaking techniques

662
00:24:34,320 --> 00:24:37,679
don't work with request tunneling

663
00:24:37,679 --> 00:24:40,240
however if you can inject new lines in

664
00:24:40,240 --> 00:24:43,360
headers thanks to hb2 you can cause a

665
00:24:43,360 --> 00:24:45,840
different kind of desynchronization that

666
00:24:45,840 --> 00:24:48,720
lets you find out

667
00:24:50,240 --> 00:24:52,080
normal request smuggling

668
00:24:52,080 --> 00:24:53,760
confuses the front end in the back end

669
00:24:53,760 --> 00:24:54,880
it makes the front end in the back end

670
00:24:54,880 --> 00:24:56,400
disagree

671
00:24:56,400 --> 00:24:57,919
about where

672
00:24:57,919 --> 00:25:01,279
the body of the message ends

673
00:25:01,279 --> 00:25:03,440
but by putting new lines in headers you

674
00:25:03,440 --> 00:25:05,039
can cause a different kind of

675
00:25:05,039 --> 00:25:07,039
desynchronization which makes the front

676
00:25:07,039 --> 00:25:09,039
end in the back end disagree about where

677
00:25:09,039 --> 00:25:11,200
the body of the message starts

678
00:25:11,200 --> 00:25:12,640
so by doing this

679
00:25:12,640 --> 00:25:15,279
here i've effectively led to the front

680
00:25:15,279 --> 00:25:17,679
end putting the internal headers on what

681
00:25:17,679 --> 00:25:19,600
it thinks is the end of the headers but

682
00:25:19,600 --> 00:25:21,760
what the back end is going to is going

683
00:25:21,760 --> 00:25:23,840
to treat as part of this s parameter

684
00:25:23,840 --> 00:25:26,720
which is just the search parameter on

685
00:25:26,720 --> 00:25:30,080
the wordpress back end of this part of

686
00:25:30,080 --> 00:25:31,360
bitbucket

687
00:25:31,360 --> 00:25:32,240
so

688
00:25:32,240 --> 00:25:33,520
wordpress is going to tell me what i

689
00:25:33,520 --> 00:25:35,679
search for right and it's going to leak

690
00:25:35,679 --> 00:25:37,279
all the internal headers

691
00:25:37,279 --> 00:25:39,120
in the process

692
00:25:39,120 --> 00:25:40,960
and i found by hitting different

693
00:25:40,960 --> 00:25:43,200
endpoints like non-wordpress ones uh it

694
00:25:43,200 --> 00:25:45,279
would leak different internal headers

695
00:25:45,279 --> 00:25:48,080
including some with secret keys uh for a

696
00:25:48,080 --> 00:25:50,720
full end-to-end case study of exploiting

697
00:25:50,720 --> 00:25:52,720
systems with internal headers check out

698
00:25:52,720 --> 00:25:55,039
the new relic example from my previous

699
00:25:55,039 --> 00:25:58,320
hp dating attacks research

700
00:25:58,320 --> 00:26:00,480
finally if the stars are aligned you

701
00:26:00,480 --> 00:26:02,960
might be able to use tunneling for cache

702
00:26:02,960 --> 00:26:04,960
poisoning so if they've got a cache and

703
00:26:04,960 --> 00:26:06,960
the head technique works and the clf

704
00:26:06,960 --> 00:26:08,559
technique works

705
00:26:08,559 --> 00:26:11,840
this is worth a try

706
00:26:11,840 --> 00:26:13,039
so

707
00:26:13,039 --> 00:26:13,840
what

708
00:26:13,840 --> 00:26:15,279
this lets you do

709
00:26:15,279 --> 00:26:17,360
what the head technique lets you do

710
00:26:17,360 --> 00:26:19,919
is mix and match response headers and

711
00:26:19,919 --> 00:26:21,039
response

712
00:26:21,039 --> 00:26:23,679
bodies so here i have chosen an initial

713
00:26:23,679 --> 00:26:25,679
set of response headers that are just

714
00:26:25,679 --> 00:26:28,480
from the 404 page and set a content type

715
00:26:28,480 --> 00:26:30,559
of text html

716
00:26:30,559 --> 00:26:32,880
and then for my nested request i've

717
00:26:32,880 --> 00:26:35,120
specified a different endpoint that just

718
00:26:35,120 --> 00:26:38,000
does a redirect that puts my query

719
00:26:38,000 --> 00:26:40,720
string into the location header without

720
00:26:40,720 --> 00:26:42,159
encoding it

721
00:26:42,159 --> 00:26:44,480
and by itself that redirect is

722
00:26:44,480 --> 00:26:46,000
completely harmless because the location

723
00:26:46,000 --> 00:26:47,679
header is not supposed to get rendered

724
00:26:47,679 --> 00:26:50,080
as html but by sticking those extra

725
00:26:50,080 --> 00:26:53,440
headers on the front i've effectively

726
00:26:53,440 --> 00:26:55,279
made that get rendered and i've gained

727
00:26:55,279 --> 00:26:57,200
arbitrary javascript execution and

728
00:26:57,200 --> 00:26:58,799
thanks to their cache i've got that

729
00:26:58,799 --> 00:27:02,000
saved and gained persistent control over

730
00:27:02,000 --> 00:27:04,480
every page on their site and for that

731
00:27:04,480 --> 00:27:07,440
plus the jury issue we saw earlier i got

732
00:27:07,440 --> 00:27:09,840
a triple their max bounty of 15k taking

733
00:27:09,840 --> 00:27:11,919
the total earned in this research to 56

734
00:27:11,919 --> 00:27:14,080
grand

735
00:27:14,080 --> 00:27:16,960
now i'm going to have a tour of some hb2

736
00:27:16,960 --> 00:27:20,320
odds and ends that you might find useful

737
00:27:20,320 --> 00:27:21,840
in hb1

738
00:27:21,840 --> 00:27:24,000
you can send duplicate headers and this

739
00:27:24,000 --> 00:27:25,679
is the basis of quite a few different

740
00:27:25,679 --> 00:27:27,120
types of attack

741
00:27:27,120 --> 00:27:29,760
but you can't send duplicate parts

742
00:27:29,760 --> 00:27:33,279
because there's only one request line

743
00:27:33,279 --> 00:27:36,240
but hb2 introduced pseudoheaders so that

744
00:27:36,240 --> 00:27:38,399
means you can send duplicate pods on

745
00:27:38,399 --> 00:27:40,960
some servers and i've verified there are

746
00:27:40,960 --> 00:27:42,799
real servers out there they do support

747
00:27:42,799 --> 00:27:44,880
duplicate paths and they vary in which

748
00:27:44,880 --> 00:27:47,120
path they use as the

749
00:27:47,120 --> 00:27:50,000
real path of the message so that could

750
00:27:50,000 --> 00:27:52,399
lead to some pretty nice access control

751
00:27:52,399 --> 00:27:53,679
bypasses

752
00:27:53,679 --> 00:27:56,720
and similarly hb2 introduced this colon

753
00:27:56,720 --> 00:27:58,799
authority pseudo header which is

754
00:27:58,799 --> 00:28:00,240
basically a replacement for the host

755
00:28:00,240 --> 00:28:02,480
header but they didn't say that you

756
00:28:02,480 --> 00:28:04,320
can't also send the host header so you

757
00:28:04,320 --> 00:28:06,720
can send some really

758
00:28:06,720 --> 00:28:09,360
ambiguous and confusing messages with h2

759
00:28:09,360 --> 00:28:11,200
that may enable some interesting host

760
00:28:11,200 --> 00:28:14,240
header attacks

761
00:28:14,240 --> 00:28:16,960
they also introduced the colon scheme

762
00:28:16,960 --> 00:28:19,760
pseudo header which in my opinion was a

763
00:28:19,760 --> 00:28:22,000
mistake the value of this pseudo header

764
00:28:22,000 --> 00:28:25,679
it's meant to be http or https

765
00:28:25,679 --> 00:28:27,120
but

766
00:28:27,120 --> 00:28:28,320
you can put whatever you like in it

767
00:28:28,320 --> 00:28:31,039
right it's a binary protocol and

768
00:28:31,039 --> 00:28:34,159
often developers just trust this value

769
00:28:34,159 --> 00:28:35,840
and so they use it for things like

770
00:28:35,840 --> 00:28:38,480
building urls so i was able to use this

771
00:28:38,480 --> 00:28:39,679
to get some

772
00:28:39,679 --> 00:28:41,279
cash poisoning on

773
00:28:41,279 --> 00:28:43,200
netlify admittedly it wasn't very high

774
00:28:43,200 --> 00:28:44,559
impact

775
00:28:44,559 --> 00:28:46,000
and on a different target they were

776
00:28:46,000 --> 00:28:48,159
using it to build a url that they would

777
00:28:48,159 --> 00:28:50,720
route the request to so you could use

778
00:28:50,720 --> 00:28:53,360
this for a limited type of server side

779
00:28:53,360 --> 00:28:56,320
request forgery

780
00:28:56,720 --> 00:28:59,679
on another site i found i could put

781
00:28:59,679 --> 00:29:00,799
colons

782
00:29:00,799 --> 00:29:03,760
in hp header names but i couldn't put

783
00:29:03,760 --> 00:29:05,679
new lines in there and this still

784
00:29:05,679 --> 00:29:07,840
enables request smuggling as long as the

785
00:29:07,840 --> 00:29:09,600
back end tolerates

786
00:29:09,600 --> 00:29:11,600
this trailing colon that you can't get

787
00:29:11,600 --> 00:29:12,399
rid of

788
00:29:12,399 --> 00:29:14,880
in the transfer and coding header

789
00:29:14,880 --> 00:29:16,880
if the back end doesn't like that then

790
00:29:16,880 --> 00:29:18,640
your next best option is probably doing

791
00:29:18,640 --> 00:29:21,279
a hosted attack because you're expected

792
00:29:21,279 --> 00:29:23,279
to have colons

793
00:29:23,279 --> 00:29:24,880
in the host header

794
00:29:24,880 --> 00:29:27,600
on one side i found yep i could use this

795
00:29:27,600 --> 00:29:30,080
to trigger request smuggling and i got

796
00:29:30,080 --> 00:29:33,279
halfway through exploitation and then i

797
00:29:33,279 --> 00:29:34,720
can't remember what happened but i got

798
00:29:34,720 --> 00:29:37,200
distracted by something else and when i

799
00:29:37,200 --> 00:29:38,480
came back

800
00:29:38,480 --> 00:29:40,720
the vulnerability had disappeared

801
00:29:40,720 --> 00:29:43,120
and the server version was reporting

802
00:29:43,120 --> 00:29:45,919
that they'd updated apache to the latest

803
00:29:45,919 --> 00:29:48,000
version so i thought oh this must be a

804
00:29:48,000 --> 00:29:50,399
patched apache vulnerability but i

805
00:29:50,399 --> 00:29:52,799
couldn't find any advisory for it so i

806
00:29:52,799 --> 00:29:54,799
thought i'll just install the old

807
00:29:54,799 --> 00:29:56,399
version maybe they accidentally patched

808
00:29:56,399 --> 00:29:58,240
it maybe i can use it for a demo or

809
00:29:58,240 --> 00:29:59,919
something

810
00:29:59,919 --> 00:30:01,760
and i installed it and i couldn't

811
00:30:01,760 --> 00:30:03,600
replicate it i have no idea what was

812
00:30:03,600 --> 00:30:05,440
going on then but because i'd installed

813
00:30:05,440 --> 00:30:07,279
it i did accidentally find a different

814
00:30:07,279 --> 00:30:09,919
vulnerability which was a zero day in

815
00:30:09,919 --> 00:30:11,919
apache it also worked on the latest

816
00:30:11,919 --> 00:30:13,520
version

817
00:30:13,520 --> 00:30:16,159
you could put spaces in the method

818
00:30:16,159 --> 00:30:17,360
pseudo header

819
00:30:17,360 --> 00:30:19,520
and so as long as the backend server

820
00:30:19,520 --> 00:30:21,919
tolerated trailing junk in the request

821
00:30:21,919 --> 00:30:24,240
line which some of them sadly do you

822
00:30:24,240 --> 00:30:26,480
could use this to do things like bypass

823
00:30:26,480 --> 00:30:29,200
block rules on front end

824
00:30:29,200 --> 00:30:31,200
servers and generally

825
00:30:31,200 --> 00:30:33,200
dance around security restrictions

826
00:30:33,200 --> 00:30:34,320
implemented

827
00:30:34,320 --> 00:30:37,440
on the front end i reported that to

828
00:30:37,440 --> 00:30:40,120
apache and they fixed it in

829
00:30:40,120 --> 00:30:42,320
2.4.49 uh you might have heard of that

830
00:30:42,320 --> 00:30:44,799
version i would not recommend installing

831
00:30:44,799 --> 00:30:47,200
it i'd go for a later version if i were

832
00:30:47,200 --> 00:30:49,279
you

833
00:30:49,279 --> 00:30:53,039
finally a few practicalities so

834
00:30:53,039 --> 00:30:54,880
one thing about hp2

835
00:30:54,880 --> 00:30:57,760
is it uses the same

836
00:30:57,760 --> 00:31:01,039
port as http one and thereby a browser

837
00:31:01,039 --> 00:31:02,960
needs to be told which protocol it

838
00:31:02,960 --> 00:31:04,880
should use so what the server is

839
00:31:04,880 --> 00:31:06,880
supposed to do is declare that it

840
00:31:06,880 --> 00:31:08,799
supports http 2

841
00:31:08,799 --> 00:31:11,200
during the tls handshake

842
00:31:11,200 --> 00:31:15,039
but some servers support hp2 and forget

843
00:31:15,039 --> 00:31:16,799
to declare it

844
00:31:16,799 --> 00:31:18,720
so that means if you take a casual

845
00:31:18,720 --> 00:31:20,240
glance at these websites you'll think

846
00:31:20,240 --> 00:31:22,320
they don't support hp2 and you'll miss

847
00:31:22,320 --> 00:31:24,880
out on all kinds of valuable attack

848
00:31:24,880 --> 00:31:26,960
surface uh but the good news is it's

849
00:31:26,960 --> 00:31:28,159
really easy

850
00:31:28,159 --> 00:31:29,039
to

851
00:31:29,039 --> 00:31:30,880
to detect this you just try and send a

852
00:31:30,880 --> 00:31:33,600
hb2 request regardless

853
00:31:33,600 --> 00:31:35,840
and you can do that with the extension

854
00:31:35,840 --> 00:31:37,840
that i've shared but scanner will do it

855
00:31:37,840 --> 00:31:39,440
for you and you can also do it just with

856
00:31:39,440 --> 00:31:42,559
curl using these command line flags

857
00:31:42,559 --> 00:31:45,519
i found a site that had that behavior

858
00:31:45,519 --> 00:31:48,799
and was vulnerable to hp2 based requests

859
00:31:48,799 --> 00:31:50,640
of request smuggling uh but there was a

860
00:31:50,640 --> 00:31:52,240
catch there which was i could only

861
00:31:52,240 --> 00:31:54,240
exploit other people that were using

862
00:31:54,240 --> 00:31:56,080
http 2

863
00:31:56,080 --> 00:31:57,440
which was nobody because they weren't

864
00:31:57,440 --> 00:32:00,399
advertising support for it

865
00:32:00,399 --> 00:32:02,240
the tooling situation

866
00:32:02,240 --> 00:32:04,880
is also a bit of a mess basically

867
00:32:04,880 --> 00:32:06,240
existing tooling

868
00:32:06,240 --> 00:32:08,320
doesn't work because libraries will

869
00:32:08,320 --> 00:32:10,480
refuse to send the kind of malformed

870
00:32:10,480 --> 00:32:13,039
requests that we need to send for these

871
00:32:13,039 --> 00:32:16,399
attacks and hb 1.1 had that issue too

872
00:32:16,399 --> 00:32:18,080
but you could fall back to using things

873
00:32:18,080 --> 00:32:20,640
like netcat and open ssl

874
00:32:20,640 --> 00:32:22,880
but because hp2 is a binary protocol

875
00:32:22,880 --> 00:32:26,640
that's wildly impractical so instead you

876
00:32:26,640 --> 00:32:30,640
need to use ml's tool hb 2 smuggle turbo

877
00:32:30,640 --> 00:32:32,960
intruder which i've made a custom open

878
00:32:32,960 --> 00:32:35,440
source hp 2 stack for

879
00:32:35,440 --> 00:32:37,600
or you can use turbo intuitive with

880
00:32:37,600 --> 00:32:39,760
burps hp2 stack which is slower but more

881
00:32:39,760 --> 00:32:41,440
reliable

882
00:32:41,440 --> 00:32:44,159
or book just corbert or the hp request

883
00:32:44,159 --> 00:32:46,320
smuggler that i've released uh if you

884
00:32:46,320 --> 00:32:47,760
don't like burp please take note you can

885
00:32:47,760 --> 00:32:50,000
use turbo intruder as a command line

886
00:32:50,000 --> 00:32:54,320
tool it doesn't actually depend on but

887
00:32:54,559 --> 00:32:56,880
as far as defense goes i think the most

888
00:32:56,880 --> 00:32:59,200
important thing is i would advise

889
00:32:59,200 --> 00:33:02,320
network architect type people not to use

890
00:33:02,320 --> 00:33:05,760
hp2 downgrading ever i would not turn on

891
00:33:05,760 --> 00:33:08,399
hb2 on your front-end server until you

892
00:33:08,399 --> 00:33:11,760
can have hp2 end to end it's just too

893
00:33:11,760 --> 00:33:13,279
dangerous

894
00:33:13,279 --> 00:33:15,120
beyond that though uh

895
00:33:15,120 --> 00:33:16,880
if you're a server vendor i'd recommend

896
00:33:16,880 --> 00:33:20,320
enforcing hp 1.1 limitations like the

897
00:33:20,320 --> 00:33:22,399
rfc tells you like not letting people

898
00:33:22,399 --> 00:33:24,320
put colons in header names or new lines

899
00:33:24,320 --> 00:33:26,080
in silly places

900
00:33:26,080 --> 00:33:28,159
and for developers

901
00:33:28,159 --> 00:33:29,840
i think over time

902
00:33:29,840 --> 00:33:31,440
you'll probably want to drop the

903
00:33:31,440 --> 00:33:33,120
assumptions that you that used to be

904
00:33:33,120 --> 00:33:36,000
valid in the world of http one for

905
00:33:36,000 --> 00:33:39,679
example it used to be safe to put a http

906
00:33:39,679 --> 00:33:42,480
header in an email header because email

907
00:33:42,480 --> 00:33:44,399
headers are terminated by the same thing

908
00:33:44,399 --> 00:33:47,039
that terminates http headers but thanks

909
00:33:47,039 --> 00:33:50,240
to hp2 that's no longer true

910
00:33:50,240 --> 00:33:52,320
and at one point in time that would have

911
00:33:52,320 --> 00:33:54,720
led to a remote an unauthorized code

912
00:33:54,720 --> 00:33:58,080
execution in wordpress i believe

913
00:33:58,080 --> 00:33:59,519
uh but not anymore

914
00:33:59,519 --> 00:34:01,519
don't worry about that uh and also the

915
00:34:01,519 --> 00:34:03,840
other thing is don't trust the scheme

916
00:34:03,840 --> 00:34:06,000
pseudo header this is a 100 user input

917
00:34:06,000 --> 00:34:08,880
it's just not safe

918
00:34:09,359 --> 00:34:11,280
there's a whole bunch of further reading

919
00:34:11,280 --> 00:34:12,960
available uh the main thing that i'd

920
00:34:12,960 --> 00:34:14,480
like to draw your attention to is

921
00:34:14,480 --> 00:34:16,960
predictably our web security academy

922
00:34:16,960 --> 00:34:20,079
where we have more explanations of these

923
00:34:20,079 --> 00:34:22,000
of these techniques in a greater level

924
00:34:22,000 --> 00:34:24,480
of depth and also interactive labs so

925
00:34:24,480 --> 00:34:26,719
you can try them out for yourself

926
00:34:26,719 --> 00:34:28,560
uh but the other stuff is there's some

927
00:34:28,560 --> 00:34:32,399
useful post exploitation stuff there too

928
00:34:32,399 --> 00:34:33,280
and

929
00:34:33,280 --> 00:34:36,399
the three key things to take away

930
00:34:36,399 --> 00:34:38,960
are the hb2 breaks assumptions at

931
00:34:38,960 --> 00:34:41,599
multiple different layers of the stack

932
00:34:41,599 --> 00:34:43,760
hb2 downgrades are

933
00:34:43,760 --> 00:34:45,520
just really hazardous and request

934
00:34:45,520 --> 00:34:47,359
tunneling in spite of being a massive

935
00:34:47,359 --> 00:34:48,399
pain

936
00:34:48,399 --> 00:34:50,480
is a genuine threat

937
00:34:50,480 --> 00:34:52,239
i'm going to take five minutes of

938
00:34:52,239 --> 00:34:54,399
questions now if you have any more after

939
00:34:54,399 --> 00:34:56,000
that feel free to come up and chat to me

940
00:34:56,000 --> 00:34:58,160
at the back or chat me an email don't

941
00:34:58,160 --> 00:35:00,240
forget to follow me on twitter thank you

942
00:35:00,240 --> 00:35:03,319
for listening

943
00:35:08,010 --> 00:35:11,159
[Music]

