1
00:00:00,860 --> 00:00:08,960
[Music]

2
00:00:08,960 --> 00:00:11,440
good morning everybody i'm dario nizi

3
00:00:11,440 --> 00:00:13,040
and today i'm going to talk about my

4
00:00:13,040 --> 00:00:15,120
latest work lost in the loader the many

5
00:00:15,120 --> 00:00:17,680
phases of the pe file format a work that

6
00:00:17,680 --> 00:00:19,520
i conducted with mariano graziano and

7
00:00:19,520 --> 00:00:21,600
janik fradantoni from cisco dallas and

8
00:00:21,600 --> 00:00:23,600
david balzarotti from eurekom which is

9
00:00:23,600 --> 00:00:25,920
also my home institution

10
00:00:25,920 --> 00:00:27,920
as the title may suggest today we are

11
00:00:27,920 --> 00:00:29,840
going to talk extensively about the pdf

12
00:00:29,840 --> 00:00:31,679
file format so i think it's worth to

13
00:00:31,679 --> 00:00:34,559
give a little bit of background about it

14
00:00:34,559 --> 00:00:36,880
the p-file format is this de facto

15
00:00:36,880 --> 00:00:39,040
standard for programs in windows and it

16
00:00:39,040 --> 00:00:42,719
is based on the old microsoft dos mz and

17
00:00:42,719 --> 00:00:45,520
the coff file formats

18
00:00:45,520 --> 00:00:48,480
the p5 format defines the headers which

19
00:00:48,480 --> 00:00:50,480
are data structure the two data

20
00:00:50,480 --> 00:00:52,640
structures that we find at the beginning

21
00:00:52,640 --> 00:00:54,559
of each program for windows

22
00:00:54,559 --> 00:00:56,960
in fact each program starts with the mz

23
00:00:56,960 --> 00:00:58,800
header which is there only for

24
00:00:58,800 --> 00:01:01,199
compatibility reasons nowadays it's only

25
00:01:01,199 --> 00:01:03,120
used to locate in memory the starting

26
00:01:03,120 --> 00:01:06,080
offset of the cff header this other

27
00:01:06,080 --> 00:01:08,320
header contains generic informations

28
00:01:08,320 --> 00:01:09,280
about

29
00:01:09,280 --> 00:01:10,880
the program itself such as the

30
00:01:10,880 --> 00:01:13,920
instruction set for which it is compiled

31
00:01:13,920 --> 00:01:16,479
and the file whether it is a standalone

32
00:01:16,479 --> 00:01:17,920
executables

33
00:01:17,920 --> 00:01:18,960
or

34
00:01:18,960 --> 00:01:20,720
dynamically linked

35
00:01:20,720 --> 00:01:22,159
library

36
00:01:22,159 --> 00:01:24,320
after this uff header we find the

37
00:01:24,320 --> 00:01:26,640
optional header whose name may actually

38
00:01:26,640 --> 00:01:28,560
sound a little bit misleading because

39
00:01:28,560 --> 00:01:30,400
this header actually contains vital

40
00:01:30,400 --> 00:01:32,799
information without which the operating

41
00:01:32,799 --> 00:01:34,799
system would not know how to load the

42
00:01:34,799 --> 00:01:37,119
program in memory correctly

43
00:01:37,119 --> 00:01:39,280
such information are for example the

44
00:01:39,280 --> 00:01:42,079
entry point which is the address of the

45
00:01:42,079 --> 00:01:44,159
first instruction in the program

46
00:01:44,159 --> 00:01:46,640
the section and file alignment the base

47
00:01:46,640 --> 00:01:49,040
address at which the program prefers to

48
00:01:49,040 --> 00:01:51,680
be loaded and the data directories which

49
00:01:51,680 --> 00:01:53,920
have specific rules roles

50
00:01:53,920 --> 00:01:56,880
which play specific roles in loading the

51
00:01:56,880 --> 00:01:59,759
file in memory such as the import table

52
00:01:59,759 --> 00:02:01,680
the export table relocations and

53
00:02:01,680 --> 00:02:03,600
certificate table

54
00:02:03,600 --> 00:02:05,360
after the optional header we find the

55
00:02:05,360 --> 00:02:06,719
section table

56
00:02:06,719 --> 00:02:09,280
which defines the program's memory image

57
00:02:09,280 --> 00:02:11,120
which means which

58
00:02:11,120 --> 00:02:13,200
represents how the program looks like

59
00:02:13,200 --> 00:02:15,280
once it's loaded in memory each entry in

60
00:02:15,280 --> 00:02:17,840
the section table defines a section

61
00:02:17,840 --> 00:02:20,080
which is a contiguous and homogeneous

62
00:02:20,080 --> 00:02:21,760
portion of memory that shares the same

63
00:02:21,760 --> 00:02:24,640
permission level in terms of read write

64
00:02:24,640 --> 00:02:26,560
and execution

65
00:02:26,560 --> 00:02:28,640
each section has its own starting

66
00:02:28,640 --> 00:02:31,760
address and size in memory its own

67
00:02:31,760 --> 00:02:34,480
offset and size within the file

68
00:02:34,480 --> 00:02:36,879
the p5 format supports up to 2 to the

69
00:02:36,879 --> 00:02:39,280
16th power sections because 16 is the

70
00:02:39,280 --> 00:02:41,680
number of bits in the number of sections

71
00:02:41,680 --> 00:02:45,599
field in the coff header

72
00:02:45,599 --> 00:02:47,840
now while we were studying the p

73
00:02:47,840 --> 00:02:49,680
ecosystem we found

74
00:02:49,680 --> 00:02:51,599
two interesting things

75
00:02:51,599 --> 00:02:53,280
the first is that there is not really a

76
00:02:53,280 --> 00:02:55,200
reference implementation for how to

77
00:02:55,200 --> 00:02:58,000
parse correctly the pe file format and

78
00:02:58,000 --> 00:02:59,840
the second observation that we made was

79
00:02:59,840 --> 00:03:02,560
that the specifications or do they make

80
00:03:02,560 --> 00:03:05,360
a very good job in defining the headers

81
00:03:05,360 --> 00:03:07,360
and their their structure

82
00:03:07,360 --> 00:03:08,800
and their field and their possible

83
00:03:08,800 --> 00:03:10,720
values for each field they are not

84
00:03:10,720 --> 00:03:13,280
really comprehensive they do not tell

85
00:03:13,280 --> 00:03:15,680
what it is to be considered a valid p

86
00:03:15,680 --> 00:03:17,840
file or an embodied one

87
00:03:17,840 --> 00:03:19,680
or at least they don't do it in all the

88
00:03:19,680 --> 00:03:22,000
possible circumstances

89
00:03:22,000 --> 00:03:23,280
now when you take these two things

90
00:03:23,280 --> 00:03:25,760
together some problems may start arising

91
00:03:25,760 --> 00:03:27,280
for example the fact that there is no

92
00:03:27,280 --> 00:03:29,120
really a reference implementation means

93
00:03:29,120 --> 00:03:30,319
that

94
00:03:30,319 --> 00:03:32,080
we're implementing the same logic over

95
00:03:32,080 --> 00:03:34,159
and over again is the de facto rule for

96
00:03:34,159 --> 00:03:35,760
the pe ecosystem

97
00:03:35,760 --> 00:03:37,680
while the fact that these specifications

98
00:03:37,680 --> 00:03:39,840
are not comprehensive enough

99
00:03:39,840 --> 00:03:41,920
means that a lot of room is left for

100
00:03:41,920 --> 00:03:43,680
implementation choices

101
00:03:43,680 --> 00:03:44,959
when you combine these two things

102
00:03:44,959 --> 00:03:47,120
together you end up with discrepancies

103
00:03:47,120 --> 00:03:49,920
which are slight differences in how two

104
00:03:49,920 --> 00:03:52,879
pieces of software handle the same file

105
00:03:52,879 --> 00:03:56,080
as given as an input

106
00:03:56,080 --> 00:03:58,080
but are these discrepancies really a

107
00:03:58,080 --> 00:04:00,959
problem what are the implications of p

108
00:04:00,959 --> 00:04:03,280
discrepancies well let's try let's try

109
00:04:03,280 --> 00:04:05,680
to make a case for the severity of this

110
00:04:05,680 --> 00:04:08,400
problem by means of two examples

111
00:04:08,400 --> 00:04:09,920
first

112
00:04:09,920 --> 00:04:11,680
imagine that you have a program that

113
00:04:11,680 --> 00:04:14,000
runs under windows 7 but not under

114
00:04:14,000 --> 00:04:15,280
windows 10.

115
00:04:15,280 --> 00:04:17,279
well these of course already break

116
00:04:17,279 --> 00:04:18,880
backward compatibility which is

117
00:04:18,880 --> 00:04:21,120
something for which microsoft has spent

118
00:04:21,120 --> 00:04:23,040
a lot of development efforts to maintain

119
00:04:23,040 --> 00:04:25,120
throughout the versions

120
00:04:25,120 --> 00:04:27,199
but it's even worse if you have a

121
00:04:27,199 --> 00:04:29,759
dynamic analysis sandbox which runs

122
00:04:29,759 --> 00:04:31,040
windows 10

123
00:04:31,040 --> 00:04:32,800
well suppose that you want to analyze

124
00:04:32,800 --> 00:04:34,479
this program because you suspect it's

125
00:04:34,479 --> 00:04:37,199
malicious well your analysis sandbox

126
00:04:37,199 --> 00:04:40,560
simply cannot run it cannot analyze this

127
00:04:40,560 --> 00:04:42,560
program because it's only only runs

128
00:04:42,560 --> 00:04:44,880
under windows 7.

129
00:04:44,880 --> 00:04:46,800
another example take your favorite

130
00:04:46,800 --> 00:04:48,880
reverse engineering tool and imagine

131
00:04:48,880 --> 00:04:50,720
that for this program it gives you the

132
00:04:50,720 --> 00:04:51,919
wrong mapping

133
00:04:51,919 --> 00:04:54,320
now imagine that you are already working

134
00:04:54,320 --> 00:04:56,720
on reverse engineering this this

135
00:04:56,720 --> 00:04:57,759
program

136
00:04:57,759 --> 00:05:00,560
only to find out six hours later that

137
00:05:00,560 --> 00:05:01,759
your

138
00:05:01,759 --> 00:05:04,639
the mapping was wrong basically you for

139
00:05:04,639 --> 00:05:06,479
six hours of your day

140
00:05:06,479 --> 00:05:09,360
you were just staring at ghosts

141
00:05:09,360 --> 00:05:11,120
this is even worse if the reverse

142
00:05:11,120 --> 00:05:13,440
engineering tool is used as a

143
00:05:13,440 --> 00:05:15,680
part of a steadicam static analysis

144
00:05:15,680 --> 00:05:18,320
pipeline basically each other analysis

145
00:05:18,320 --> 00:05:20,639
which rely on the wrong on this wrong

146
00:05:20,639 --> 00:05:24,560
mapping may be biased as a result as you

147
00:05:24,560 --> 00:05:27,520
consider as you can already see

148
00:05:27,520 --> 00:05:29,440
the p discrepancies are

149
00:05:29,440 --> 00:05:31,840
problematic especially in adversarial

150
00:05:31,840 --> 00:05:33,840
settings like malware analysis and

151
00:05:33,840 --> 00:05:36,080
malware detection both static and

152
00:05:36,080 --> 00:05:39,680
dynamic approaches can be evaded using p

153
00:05:39,680 --> 00:05:41,680
discrepancies and even

154
00:05:41,680 --> 00:05:43,360
endpoint protection software can be

155
00:05:43,360 --> 00:05:45,759
bypassed you know through p

156
00:05:45,759 --> 00:05:47,520
discrepancies

157
00:05:47,520 --> 00:05:48,880
for example

158
00:05:48,880 --> 00:05:50,880
just a few weeks ago the google threat

159
00:05:50,880 --> 00:05:52,880
analysis group discovered malware

160
00:05:52,880 --> 00:05:55,680
families that were exploiting exactly

161
00:05:55,680 --> 00:05:58,479
something like this

162
00:05:58,479 --> 00:06:00,639
in particular they were exploiting how

163
00:06:00,639 --> 00:06:03,600
the operating system and openssl

164
00:06:03,600 --> 00:06:08,080
parse the certificate table in a pe file

165
00:06:08,080 --> 00:06:10,800
since openssl is used in a lot of

166
00:06:10,800 --> 00:06:12,319
detection tools

167
00:06:12,319 --> 00:06:15,440
this malware family was able to

168
00:06:15,440 --> 00:06:18,160
completely bypass the detection by these

169
00:06:18,160 --> 00:06:19,199
tools

170
00:06:19,199 --> 00:06:21,360
while still being able to run

171
00:06:21,360 --> 00:06:24,000
under windows

172
00:06:24,000 --> 00:06:26,400
now our work is by no means the first

173
00:06:26,400 --> 00:06:28,800
one to take of the problem of p

174
00:06:28,800 --> 00:06:31,120
discrepancies but all these other works

175
00:06:31,120 --> 00:06:32,479
that when published or have been

176
00:06:32,479 --> 00:06:34,720
conducted before only scratched the

177
00:06:34,720 --> 00:06:36,880
surface of the problem in our opinion

178
00:06:36,880 --> 00:06:38,800
they only documented single-edge cases

179
00:06:38,800 --> 00:06:41,280
and nobody really did a systematic study

180
00:06:41,280 --> 00:06:42,490
of this problem

181
00:06:42,490 --> 00:06:43,759
[Music]

182
00:06:43,759 --> 00:06:46,160
and that's exactly what we did in our

183
00:06:46,160 --> 00:06:48,720
work we provide a systematic approach to

184
00:06:48,720 --> 00:06:51,680
find discrepancies in the pe54 in the pa

185
00:06:51,680 --> 00:06:52,960
system

186
00:06:52,960 --> 00:06:54,800
let's have a look to the big picture of

187
00:06:54,800 --> 00:06:56,319
our work

188
00:06:56,319 --> 00:06:58,319
we start with some software that we want

189
00:06:58,319 --> 00:07:00,080
to compare

190
00:07:00,080 --> 00:07:02,479
we reverse engineer it to

191
00:07:02,479 --> 00:07:05,520
model their behavior especially how they

192
00:07:05,520 --> 00:07:08,080
parse the pe file format

193
00:07:08,080 --> 00:07:10,400
and then we feed these models to our

194
00:07:10,400 --> 00:07:13,120
analysis framework which can operate in

195
00:07:13,120 --> 00:07:15,039
two modes

196
00:07:15,039 --> 00:07:17,199
the first one is validation mode which

197
00:07:17,199 --> 00:07:20,639
given an unknown p file and the model is

198
00:07:20,639 --> 00:07:23,280
able to tell us whether this unknown p

199
00:07:23,280 --> 00:07:26,000
file is valid or not according to the

200
00:07:26,000 --> 00:07:27,919
original software without running the

201
00:07:27,919 --> 00:07:30,560
software itself

202
00:07:30,560 --> 00:07:32,400
the second mode of operation of our

203
00:07:32,400 --> 00:07:34,560
analysis framework is generation mode

204
00:07:34,560 --> 00:07:37,280
which given the models can create

205
00:07:37,280 --> 00:07:39,919
automatically valid test cases which are

206
00:07:39,919 --> 00:07:42,080
files that the original software would

207
00:07:42,080 --> 00:07:44,960
consider as valid the generation mode is

208
00:07:44,960 --> 00:07:46,879
actually more powerful than that it can

209
00:07:46,879 --> 00:07:49,599
also create differential test cases

210
00:07:49,599 --> 00:07:52,319
which are files that are valid according

211
00:07:52,319 --> 00:07:53,759
to one of the

212
00:07:53,759 --> 00:07:55,840
original software but invalid for

213
00:07:55,840 --> 00:07:58,639
another one

214
00:07:58,639 --> 00:08:00,720
all right let's now give a

215
00:08:00,720 --> 00:08:02,800
more in-depth look of the constraints

216
00:08:02,800 --> 00:08:05,680
modeling phase of our work

217
00:08:05,680 --> 00:08:08,560
in this phase we want to collect as much

218
00:08:08,560 --> 00:08:10,080
knowledge as possible about the

219
00:08:10,080 --> 00:08:12,160
operations that the original software

220
00:08:12,160 --> 00:08:15,440
performs on p files given as an input

221
00:08:15,440 --> 00:08:17,919
through their parsing routines

222
00:08:17,919 --> 00:08:20,400
while we were performing this phase we

223
00:08:20,400 --> 00:08:21,919
realized that there are three types of

224
00:08:21,919 --> 00:08:24,400
operations that software usually perform

225
00:08:24,400 --> 00:08:26,240
on the input files and those are

226
00:08:26,240 --> 00:08:28,240
structural checks in which the software

227
00:08:28,240 --> 00:08:30,319
validates the file from a structural

228
00:08:30,319 --> 00:08:32,080
point of view

229
00:08:32,080 --> 00:08:33,760
for example they check that all the

230
00:08:33,760 --> 00:08:35,839
mandatory headers are within the file

231
00:08:35,839 --> 00:08:38,320
that the magic numbers match and

232
00:08:38,320 --> 00:08:40,880
everything on this line then we have

233
00:08:40,880 --> 00:08:42,799
compliance checks operations in which

234
00:08:42,799 --> 00:08:45,279
the software validate the program from

235
00:08:45,279 --> 00:08:47,760
an operational point of view for example

236
00:08:47,760 --> 00:08:49,680
the operating system may want to check

237
00:08:49,680 --> 00:08:52,000
that the instruction set architecture

238
00:08:52,000 --> 00:08:54,080
of the program matches the one of the

239
00:08:54,080 --> 00:08:56,800
machine onto which is about to run

240
00:08:56,800 --> 00:08:58,640
the third type of operation are memory

241
00:08:58,640 --> 00:09:00,640
mapping in which either the program is

242
00:09:00,640 --> 00:09:02,640
loaded in memory as in the case of the

243
00:09:02,640 --> 00:09:04,320
windows program router

244
00:09:04,320 --> 00:09:06,959
or the tool create an abstract

245
00:09:06,959 --> 00:09:08,959
representation of how the program looks

246
00:09:08,959 --> 00:09:10,880
like when it's loaded in memory such as

247
00:09:10,880 --> 00:09:13,440
in the case of reverse engineering tools

248
00:09:13,440 --> 00:09:15,440
now it's important to highlight that all

249
00:09:15,440 --> 00:09:18,160
these three types of operation can be

250
00:09:18,160 --> 00:09:19,839
somehow deconstructed in a set of

251
00:09:19,839 --> 00:09:22,959
constraints on the original input

252
00:09:22,959 --> 00:09:25,040
in order to

253
00:09:25,040 --> 00:09:26,480
easily

254
00:09:26,480 --> 00:09:29,360
encode these constraints we created a

255
00:09:29,360 --> 00:09:32,240
language a custom language

256
00:09:32,240 --> 00:09:34,560
we have different type of statements in

257
00:09:34,560 --> 00:09:36,560
this language and each of them try to

258
00:09:36,560 --> 00:09:38,959
solve one problem that may arise during

259
00:09:38,959 --> 00:09:41,040
the reverse engineering phase

260
00:09:41,040 --> 00:09:43,040
the first type of statement is input

261
00:09:43,040 --> 00:09:45,680
declaration statement

262
00:09:45,680 --> 00:09:47,760
let's have a look to what we try to

263
00:09:47,760 --> 00:09:50,560
solve with input declaration statements

264
00:09:50,560 --> 00:09:53,279
here we have the original program that

265
00:09:53,279 --> 00:09:56,080
reads the input file from an external

266
00:09:56,080 --> 00:09:57,200
source

267
00:09:57,200 --> 00:09:59,360
in our language we model this with an

268
00:09:59,360 --> 00:10:01,360
input declaration statement in which we

269
00:10:01,360 --> 00:10:03,440
create a

270
00:10:03,440 --> 00:10:05,600
symbol of a symbolic variable in this

271
00:10:05,600 --> 00:10:08,079
case we call it input file that we then

272
00:10:08,079 --> 00:10:11,200
can use in our model

273
00:10:11,200 --> 00:10:13,040
the second type of statement is symbol

274
00:10:13,040 --> 00:10:14,800
definition statement

275
00:10:14,800 --> 00:10:17,519
with which we create new variables with

276
00:10:17,519 --> 00:10:21,360
mnemonic names whose values are

277
00:10:21,360 --> 00:10:23,920
asset are given by a set of mathematical

278
00:10:23,920 --> 00:10:27,120
operations on the input file

279
00:10:27,120 --> 00:10:28,880
in the original program for example we

280
00:10:28,880 --> 00:10:31,519
have that the original program we is

281
00:10:31,519 --> 00:10:34,800
creating a new uh variable called mz

282
00:10:34,800 --> 00:10:36,079
header

283
00:10:36,079 --> 00:10:38,399
that is taken directly from the input

284
00:10:38,399 --> 00:10:41,279
file we model this in our language by

285
00:10:41,279 --> 00:10:43,040
introducing a symbol declaration

286
00:10:43,040 --> 00:10:46,079
statement you see we have the mz header

287
00:10:46,079 --> 00:10:49,200
to which we assign the um a value which

288
00:10:49,200 --> 00:10:50,640
is computed

289
00:10:50,640 --> 00:10:53,360
using the original input file as an

290
00:10:53,360 --> 00:10:55,760
input

291
00:10:56,160 --> 00:10:58,480
the third type of statement is our

292
00:10:58,480 --> 00:11:00,480
predicates predicates are boolean

293
00:11:00,480 --> 00:11:02,480
formulas that can evaluate either to

294
00:11:02,480 --> 00:11:05,440
true or false and these predicates can

295
00:11:05,440 --> 00:11:06,720
either be

296
00:11:06,720 --> 00:11:09,440
terminal or non-terminal

297
00:11:09,440 --> 00:11:11,600
terminal statements

298
00:11:11,600 --> 00:11:14,720
try to model those constraints that must

299
00:11:14,720 --> 00:11:16,880
be met by the original file in order to

300
00:11:16,880 --> 00:11:18,160
be considered

301
00:11:18,160 --> 00:11:19,600
valid

302
00:11:19,600 --> 00:11:21,839
for example in the original program here

303
00:11:21,839 --> 00:11:24,160
we see that it's it is trying it is

304
00:11:24,160 --> 00:11:26,160
checking that the magic number in the mz

305
00:11:26,160 --> 00:11:29,040
header is exactly m that

306
00:11:29,040 --> 00:11:31,200
we can model this in our language by

307
00:11:31,200 --> 00:11:33,600
introducing two terminal constraints you

308
00:11:33,600 --> 00:11:35,760
see the term keyword at the end of the

309
00:11:35,760 --> 00:11:37,760
statements is what

310
00:11:37,760 --> 00:11:43,079
is what defined a predicate as terminal

311
00:11:44,160 --> 00:11:46,399
then we have non-terminal predicates in

312
00:11:46,399 --> 00:11:49,279
our language and these are very useful

313
00:11:49,279 --> 00:11:51,120
as preconditions for conditional

314
00:11:51,120 --> 00:11:53,200
statements any type of statements in our

315
00:11:53,200 --> 00:11:55,440
language can be conditional and the

316
00:11:55,440 --> 00:11:57,760
peculiarity of conditional statements is

317
00:11:57,760 --> 00:11:59,760
that they are only executed if their

318
00:11:59,760 --> 00:12:02,800
precondition is true

319
00:12:02,800 --> 00:12:05,040
for example in the original program here

320
00:12:05,040 --> 00:12:06,320
we have that

321
00:12:06,320 --> 00:12:07,839
the software is checking that the

322
00:12:07,839 --> 00:12:09,360
section alignment

323
00:12:09,360 --> 00:12:12,240
is greater than a certain value if this

324
00:12:12,240 --> 00:12:13,760
is the case it will perform some

325
00:12:13,760 --> 00:12:16,160
operation operations and at a certain

326
00:12:16,160 --> 00:12:17,680
point it will check that the number of

327
00:12:17,680 --> 00:12:18,560
section

328
00:12:18,560 --> 00:12:21,360
is equal to zero if that's the case the

329
00:12:21,360 --> 00:12:23,760
file is considered invalid we can model

330
00:12:23,760 --> 00:12:25,600
this in our language by first

331
00:12:25,600 --> 00:12:28,240
introducing a non-terminal

332
00:12:28,240 --> 00:12:29,360
predicate

333
00:12:29,360 --> 00:12:32,000
see that there is no term keyword at the

334
00:12:32,000 --> 00:12:33,519
end of the statement

335
00:12:33,519 --> 00:12:36,399
and then a terminal statement which is

336
00:12:36,399 --> 00:12:38,160
also conditional

337
00:12:38,160 --> 00:12:39,839
in which we check that the number of

338
00:12:39,839 --> 00:12:43,680
section is not equal to zero

339
00:12:43,680 --> 00:12:46,240
in our language we also model we also

340
00:12:46,240 --> 00:12:48,880
support loops which came really handy to

341
00:12:48,880 --> 00:12:51,120
handle those constraints that the

342
00:12:51,120 --> 00:12:52,880
original software

343
00:12:52,880 --> 00:12:54,399
enforce on

344
00:12:54,399 --> 00:12:57,120
each entry of a table like structure

345
00:12:57,120 --> 00:12:59,680
such as the section table

346
00:12:59,680 --> 00:13:03,200
we also support structured types and

347
00:13:03,200 --> 00:13:04,800
the cool thing of our

348
00:13:04,800 --> 00:13:06,720
language is that you can define your

349
00:13:06,720 --> 00:13:09,680
structure types using c like

350
00:13:09,680 --> 00:13:11,839
syntax

351
00:13:11,839 --> 00:13:13,680
all right let's now give a look to our

352
00:13:13,680 --> 00:13:15,360
analysis framework starting from the

353
00:13:15,360 --> 00:13:17,360
validation mode

354
00:13:17,360 --> 00:13:19,200
in validation mode we want to determine

355
00:13:19,200 --> 00:13:21,839
whether an input file is valid according

356
00:13:21,839 --> 00:13:23,440
to a model or not

357
00:13:23,440 --> 00:13:25,440
and we can do that by means of the

358
00:13:25,440 --> 00:13:27,440
procedural interpretation

359
00:13:27,440 --> 00:13:28,480
technique

360
00:13:28,480 --> 00:13:30,079
that consists in evaluating each

361
00:13:30,079 --> 00:13:32,880
statement of the model using the data

362
00:13:32,880 --> 00:13:34,120
from the input file

363
00:13:34,120 --> 00:13:35,519
[Music]

364
00:13:35,519 --> 00:13:37,600
the file is then considered

365
00:13:37,600 --> 00:13:39,600
valid if all the terminal statements in

366
00:13:39,600 --> 00:13:42,160
the model are true and invalid if even

367
00:13:42,160 --> 00:13:46,720
one of those is evaluated to be false

368
00:13:46,720 --> 00:13:49,040
now let's move on to the generation mode

369
00:13:49,040 --> 00:13:51,199
generation mode is more complex than the

370
00:13:51,199 --> 00:13:53,519
validation mode in fact we start from

371
00:13:53,519 --> 00:13:55,199
some models but we cannot really

372
00:13:55,199 --> 00:13:57,519
generate files directly from our model

373
00:13:57,519 --> 00:13:59,680
so we first need to translate them into

374
00:13:59,680 --> 00:14:01,360
something onto which we can work

375
00:14:01,360 --> 00:14:03,519
mathematically and we do that by

376
00:14:03,519 --> 00:14:06,639
translating models into smt problems

377
00:14:06,639 --> 00:14:09,760
the smt problems are then fed to the z3

378
00:14:09,760 --> 00:14:13,839
backend which is based on the sm1d z3

379
00:14:13,839 --> 00:14:14,839
smt

380
00:14:14,839 --> 00:14:17,680
solver that the tip that the three

381
00:14:17,680 --> 00:14:20,399
backend can perform a lot of tasks for

382
00:14:20,399 --> 00:14:22,320
example test case generation

383
00:14:22,320 --> 00:14:24,399
differential analysis differences

384
00:14:24,399 --> 00:14:26,720
enumeration and corner case generation

385
00:14:26,720 --> 00:14:28,800
let's have a look to them but first

386
00:14:28,800 --> 00:14:30,959
let's have a look to the translation

387
00:14:30,959 --> 00:14:34,959
phase between models and smt problems

388
00:14:34,959 --> 00:14:36,720
translation phase is based on the

389
00:14:36,720 --> 00:14:38,560
equivalence between each type of

390
00:14:38,560 --> 00:14:41,440
statement in our language and smt

391
00:14:41,440 --> 00:14:43,120
problems

392
00:14:43,120 --> 00:14:44,880
and

393
00:14:44,880 --> 00:14:47,920
statements in an smt uh problem

394
00:14:47,920 --> 00:14:49,680
input degradation statements are

395
00:14:49,680 --> 00:14:52,000
translated into new and constraints bit

396
00:14:52,000 --> 00:14:53,440
vector

397
00:14:53,440 --> 00:14:55,279
symbol and predicates become new

398
00:14:55,279 --> 00:14:57,279
mathematical formulas to which we give

399
00:14:57,279 --> 00:14:59,199
mnemonic names

400
00:14:59,199 --> 00:15:01,760
we handle loops by unrolling them up to

401
00:15:01,760 --> 00:15:04,160
a certain number of iterations

402
00:15:04,160 --> 00:15:06,800
and we translate structured types

403
00:15:06,800 --> 00:15:09,680
into offsets and slices in the original

404
00:15:09,680 --> 00:15:11,519
bit bit vector

405
00:15:11,519 --> 00:15:13,279
once the translation is

406
00:15:13,279 --> 00:15:15,360
finished we take all the

407
00:15:15,360 --> 00:15:17,279
terminal predicates and we combine them

408
00:15:17,279 --> 00:15:19,839
together in logic conjunction this

409
00:15:19,839 --> 00:15:22,720
creates the statement that the smt

410
00:15:22,720 --> 00:15:24,959
solver needs to assert in order to solve

411
00:15:24,959 --> 00:15:27,040
the problem now it's important to

412
00:15:27,040 --> 00:15:29,600
highlight that the solutions of an smt

413
00:15:29,600 --> 00:15:31,120
problem

414
00:15:31,120 --> 00:15:33,839
created in this way are p files that are

415
00:15:33,839 --> 00:15:35,759
valid according to the model so they

416
00:15:35,759 --> 00:15:39,279
respect all the terminal predicates

417
00:15:39,279 --> 00:15:41,680
all right but how can we use these smt

418
00:15:41,680 --> 00:15:44,320
problems for creating differential test

419
00:15:44,320 --> 00:15:47,120
cases suppose that we have two models

420
00:15:47,120 --> 00:15:48,959
that for which we want to create

421
00:15:48,959 --> 00:15:51,040
differential test cases we take the

422
00:15:51,040 --> 00:15:53,120
first one we translate it into its

423
00:15:53,120 --> 00:15:55,680
formula we do the same for the second

424
00:15:55,680 --> 00:15:56,800
model

425
00:15:56,800 --> 00:15:58,240
then we take the two formulas and we

426
00:15:58,240 --> 00:16:00,079
apply this um

427
00:16:00,079 --> 00:16:02,560
logic operation take the first we do a

428
00:16:02,560 --> 00:16:04,560
logic and with the negated version of

429
00:16:04,560 --> 00:16:06,079
the second formula

430
00:16:06,079 --> 00:16:08,720
this gives us a second smt problem

431
00:16:08,720 --> 00:16:10,959
which solutions are

432
00:16:10,959 --> 00:16:12,720
files that respect all the terminal

433
00:16:12,720 --> 00:16:15,600
constraints of the first problem but

434
00:16:15,600 --> 00:16:17,199
they break at least one of the

435
00:16:17,199 --> 00:16:19,600
constraints of the second problem

436
00:16:19,600 --> 00:16:21,680
actually our analysis framework is also

437
00:16:21,680 --> 00:16:24,240
able to tell us automatically which are

438
00:16:24,240 --> 00:16:26,160
the broken constraints in the second

439
00:16:26,160 --> 00:16:28,240
model

440
00:16:28,240 --> 00:16:30,399
this came really handy for

441
00:16:30,399 --> 00:16:31,680
when we were implementing the

442
00:16:31,680 --> 00:16:33,120
differences in enumeration technique

443
00:16:33,120 --> 00:16:35,040
with which we want to find all the

444
00:16:35,040 --> 00:16:37,360
differences between two models

445
00:16:37,360 --> 00:16:39,759
this is a heuristic iterative approach

446
00:16:39,759 --> 00:16:41,759
in which for each iteration we solve an

447
00:16:41,759 --> 00:16:43,920
smt problem that asserts some of the

448
00:16:43,920 --> 00:16:45,680
previously negated constraints in the

449
00:16:45,680 --> 00:16:49,199
second model this drives the smt solver

450
00:16:49,199 --> 00:16:50,800
to find new ways

451
00:16:50,800 --> 00:16:52,639
and new discrepancies between the two

452
00:16:52,639 --> 00:16:55,120
models

453
00:16:55,360 --> 00:16:56,959
in our analysis framework we also

454
00:16:56,959 --> 00:16:58,800
implemented the corner case generation

455
00:16:58,800 --> 00:16:59,839
technique

456
00:16:59,839 --> 00:17:02,160
by which we create as many samples as

457
00:17:02,160 --> 00:17:04,319
possible that are actually also

458
00:17:04,319 --> 00:17:06,160
structurally different

459
00:17:06,160 --> 00:17:08,799
to achieve that we leverage the

460
00:17:08,799 --> 00:17:11,679
non-trivial statements in our models

461
00:17:11,679 --> 00:17:13,679
for each iteration in fact we try to

462
00:17:13,679 --> 00:17:16,240
assert different combinations of

463
00:17:16,240 --> 00:17:20,319
non-terminal statements these result in

464
00:17:20,319 --> 00:17:22,000
files that are structurally different

465
00:17:22,000 --> 00:17:23,359
because the

466
00:17:23,359 --> 00:17:25,520
original software would would use

467
00:17:25,520 --> 00:17:28,000
different path in the in its code in

468
00:17:28,000 --> 00:17:31,120
order to validate them

469
00:17:31,440 --> 00:17:33,360
our analysis framework is also able to

470
00:17:33,360 --> 00:17:38,240
generate samples that have customized um

471
00:17:38,240 --> 00:17:40,000
customize the code

472
00:17:40,000 --> 00:17:43,120
in um once it's loaded in memory

473
00:17:43,120 --> 00:17:45,520
we do so by adding constraints to the

474
00:17:45,520 --> 00:17:46,960
section content

475
00:17:46,960 --> 00:17:49,440
of the original sample

476
00:17:49,440 --> 00:17:51,600
and we're actually able to create

477
00:17:51,600 --> 00:17:53,919
samples that execute valid code with

478
00:17:53,919 --> 00:17:56,640
this technique even an hello world

479
00:17:56,640 --> 00:17:57,480
sample

480
00:17:57,480 --> 00:17:58,799
[Music]

481
00:17:58,799 --> 00:18:00,960
all right let's have a look to some

482
00:18:00,960 --> 00:18:04,160
results and findings of our work

483
00:18:04,160 --> 00:18:06,960
to begin with we modeled this software

484
00:18:06,960 --> 00:18:10,160
and we compared these these uh software

485
00:18:10,160 --> 00:18:11,520
artifacts

486
00:18:11,520 --> 00:18:14,559
the windows program loader versions xp 7

487
00:18:14,559 --> 00:18:16,640
and 10 both the kernel space and the

488
00:18:16,640 --> 00:18:18,480
user space component

489
00:18:18,480 --> 00:18:21,679
we modeled claim of v specifically its p

490
00:18:21,679 --> 00:18:25,200
parsing format specific signature engine

491
00:18:25,200 --> 00:18:28,000
vardari 2 specifically how it handled

492
00:18:28,000 --> 00:18:30,799
the memory mapping operations and yara

493
00:18:30,799 --> 00:18:32,810
in particular its p module

494
00:18:32,810 --> 00:18:34,320
[Music]

495
00:18:34,320 --> 00:18:36,160
our tool actually found discrepancies

496
00:18:36,160 --> 00:18:37,679
even between different versions of

497
00:18:37,679 --> 00:18:39,200
windows

498
00:18:39,200 --> 00:18:41,520
we found five of them in particular now

499
00:18:41,520 --> 00:18:43,440
i don't have the time to go into details

500
00:18:43,440 --> 00:18:45,520
of all of them or just mention one

501
00:18:45,520 --> 00:18:48,480
briefly which i like the most and it's

502
00:18:48,480 --> 00:18:50,320
uh the one about the relocations so

503
00:18:50,320 --> 00:18:53,039
basically windows xp and 7 allows

504
00:18:53,039 --> 00:18:56,720
executables to use any type of

505
00:18:56,720 --> 00:18:57,520
um

506
00:18:57,520 --> 00:19:00,799
architecture specific relocations even

507
00:19:00,799 --> 00:19:03,280
though even if these are not actually

508
00:19:03,280 --> 00:19:04,799
supported by the

509
00:19:04,799 --> 00:19:06,240
architecture on which the program is

510
00:19:06,240 --> 00:19:08,240
about to run for example in windows xp

511
00:19:08,240 --> 00:19:11,039
and n7 you can use mip-specific

512
00:19:11,039 --> 00:19:12,720
relocations even if you are running

513
00:19:12,720 --> 00:19:13,919
under intel

514
00:19:13,919 --> 00:19:16,240
executables that do this are discarded

515
00:19:16,240 --> 00:19:19,679
by windows 10 as invalid

516
00:19:19,679 --> 00:19:21,520
our tool also found discrepancies

517
00:19:21,520 --> 00:19:23,520
between windows and claim of b

518
00:19:23,520 --> 00:19:25,520
we found three of them in particular

519
00:19:25,520 --> 00:19:27,679
again i don't have the time to explain

520
00:19:27,679 --> 00:19:29,840
all of them uh we'll just mention one

521
00:19:29,840 --> 00:19:32,799
which is we will see it's important in

522
00:19:32,799 --> 00:19:35,120
uh in a moment it's about the number of

523
00:19:35,120 --> 00:19:37,440
sections claim of the expects the file

524
00:19:37,440 --> 00:19:39,600
to have at most 96 sections while

525
00:19:39,600 --> 00:19:41,280
windows does not really have this

526
00:19:41,280 --> 00:19:42,480
constraint

527
00:19:42,480 --> 00:19:44,320
all these three discrepancies were

528
00:19:44,320 --> 00:19:46,000
acknowledged by the developers of claim

529
00:19:46,000 --> 00:19:48,240
of vs bugs and they are working on some

530
00:19:48,240 --> 00:19:50,160
fixes

531
00:19:50,160 --> 00:19:52,240
we also run a differential analysis

532
00:19:52,240 --> 00:19:54,320
between the memory mapping operations of

533
00:19:54,320 --> 00:19:56,559
all this software and we found one edge

534
00:19:56,559 --> 00:19:58,799
case that all the tools we analyzed

535
00:19:58,799 --> 00:20:00,080
handled

536
00:20:00,080 --> 00:20:02,080
incorrectly in particular when the

537
00:20:02,080 --> 00:20:04,080
section alignment is smaller than the

538
00:20:04,080 --> 00:20:05,440
page size

539
00:20:05,440 --> 00:20:07,600
executables with these characteristics

540
00:20:07,600 --> 00:20:09,760
are mapped by windows directly in memory

541
00:20:09,760 --> 00:20:11,840
as they are completely disregarding

542
00:20:11,840 --> 00:20:13,840
their section table

543
00:20:13,840 --> 00:20:16,559
radari guarantee nfv on the other hand

544
00:20:16,559 --> 00:20:18,559
still infer the mapping of these

545
00:20:18,559 --> 00:20:22,000
programs using the section table

546
00:20:22,000 --> 00:20:23,600
we could not find any documentation

547
00:20:23,600 --> 00:20:25,360
about this behavior so we were not

548
00:20:25,360 --> 00:20:28,159
really surprised that the tools got this

549
00:20:28,159 --> 00:20:29,760
wrong

550
00:20:29,760 --> 00:20:32,159
so i've looked to one notable test case

551
00:20:32,159 --> 00:20:34,720
that was created by comparing the memory

552
00:20:34,720 --> 00:20:36,960
mapping operations of windows and radar

553
00:20:36,960 --> 00:20:39,120
in particular

554
00:20:39,120 --> 00:20:41,120
this is the optional letter of this test

555
00:20:41,120 --> 00:20:42,960
case as you can see the section

556
00:20:42,960 --> 00:20:45,919
alignment is four so it's smaller than

557
00:20:45,919 --> 00:20:47,679
the the

558
00:20:47,679 --> 00:20:49,600
the page size

559
00:20:49,600 --> 00:20:52,159
the entry point is at this address which

560
00:20:52,159 --> 00:20:54,799
means that the test case will execute

561
00:20:54,799 --> 00:20:57,280
these two instructions which are

562
00:20:57,280 --> 00:21:02,080
basically just return 0 in in c

563
00:21:02,080 --> 00:21:05,360
this test case also have a one section

564
00:21:05,360 --> 00:21:07,600
which start at this address

565
00:21:07,600 --> 00:21:09,760
now you can notice that the section

566
00:21:09,760 --> 00:21:12,400
table and the optional letter overlaps

567
00:21:12,400 --> 00:21:15,039
our analysis framework actually

568
00:21:15,039 --> 00:21:16,720
loves to do

569
00:21:16,720 --> 00:21:18,480
things like this that you don't really

570
00:21:18,480 --> 00:21:21,600
find in normal executables

571
00:21:21,600 --> 00:21:23,600
now when you run this test case in

572
00:21:23,600 --> 00:21:24,799
windows

573
00:21:24,799 --> 00:21:26,720
you have something like this so as you

574
00:21:26,720 --> 00:21:28,880
can see these are the very same bytes

575
00:21:28,880 --> 00:21:30,720
that we saw before because the pro the

576
00:21:30,720 --> 00:21:32,960
program is mapped in memory as it is and

577
00:21:32,960 --> 00:21:34,799
in the last line we can see that it's

578
00:21:34,799 --> 00:21:37,039
already executing the instruction the

579
00:21:37,039 --> 00:21:39,679
first instruction that we um with which

580
00:21:39,679 --> 00:21:41,039
we

581
00:21:41,039 --> 00:21:43,200
customized the

582
00:21:43,200 --> 00:21:45,039
text code

583
00:21:45,039 --> 00:21:46,960
when you open this in radari on the

584
00:21:46,960 --> 00:21:49,200
other hand you find this

585
00:21:49,200 --> 00:21:51,200
so radar is not able at all

586
00:21:51,200 --> 00:21:53,440
to find anything once the program is

587
00:21:53,440 --> 00:21:54,240
loaded in memory

588
00:21:54,240 --> 00:21:56,320
[Music]

589
00:21:56,320 --> 00:21:58,080
all right we found these discrepancies

590
00:21:58,080 --> 00:22:00,400
and we asked ourselves is it is there

591
00:22:00,400 --> 00:22:01,280
any

592
00:22:01,280 --> 00:22:04,159
way to find out whether malware outdoors

593
00:22:04,159 --> 00:22:06,000
are already knowledgeable about them and

594
00:22:06,000 --> 00:22:08,240
if they are already um

595
00:22:08,240 --> 00:22:10,400
exploiting them in the wild to answer

596
00:22:10,400 --> 00:22:13,120
this question we run a

597
00:22:13,120 --> 00:22:14,960
virustotal live hunt

598
00:22:14,960 --> 00:22:16,720
for which we created yara rules that

599
00:22:16,720 --> 00:22:18,720
match all the discrepancies we

600
00:22:18,720 --> 00:22:19,840
discovered

601
00:22:19,840 --> 00:22:21,520
in our work except one of the

602
00:22:21,520 --> 00:22:24,080
relocations due to technical limitations

603
00:22:24,080 --> 00:22:25,120
of vr

604
00:22:25,120 --> 00:22:27,760
we run this campaign from the 7th to the

605
00:22:27,760 --> 00:22:29,840
19th of october and we estimate to have

606
00:22:29,840 --> 00:22:31,919
scanned something around 5 million

607
00:22:31,919 --> 00:22:35,280
samples during this period

608
00:22:35,360 --> 00:22:37,919
now we were reported with we were

609
00:22:37,919 --> 00:22:41,200
prompted with 467 samples that match at

610
00:22:41,200 --> 00:22:44,640
least one of the yara roots we provided

611
00:22:44,640 --> 00:22:46,960
and it's important to highlight that

612
00:22:46,960 --> 00:22:48,799
all the rules that we provided measure

613
00:22:48,799 --> 00:22:51,280
at least one sample

614
00:22:51,280 --> 00:22:54,080
the most prominent about the

615
00:22:54,080 --> 00:22:56,000
discrepancy seems to be the one about

616
00:22:56,000 --> 00:22:59,039
the section alignment with 301 samples

617
00:22:59,039 --> 00:23:00,799
matching this may trigger different

618
00:23:00,799 --> 00:23:03,679
mappings in the software

619
00:23:03,679 --> 00:23:06,159
the second most prominent discrepancy

620
00:23:06,159 --> 00:23:09,520
seems to be the one about the 96 96

621
00:23:09,520 --> 00:23:12,880
sections for claim of v with 77 samples

622
00:23:12,880 --> 00:23:16,720
matching the corresponding error rule

623
00:23:16,720 --> 00:23:18,720
we actually analyzed some of them

624
00:23:18,720 --> 00:23:19,760
manually

625
00:23:19,760 --> 00:23:22,240
and we discovered that they had 97

626
00:23:22,240 --> 00:23:25,360
sections exactly which you know

627
00:23:25,360 --> 00:23:27,440
to us seems that it was probably done on

628
00:23:27,440 --> 00:23:30,000
purpose

629
00:23:30,080 --> 00:23:32,480
all right let's now give a few more

630
00:23:32,480 --> 00:23:36,080
words and a few takeaways from our work

631
00:23:36,080 --> 00:23:37,679
so i believe that

632
00:23:37,679 --> 00:23:39,440
the most important lesson that we

633
00:23:39,440 --> 00:23:41,200
learned during our work is that there is

634
00:23:41,200 --> 00:23:43,679
not really one way to enter the vp file

635
00:23:43,679 --> 00:23:45,440
format and even if you want to consider

636
00:23:45,440 --> 00:23:48,000
windows as the reference implementation

637
00:23:48,000 --> 00:23:50,080
of how to parse the pa file format then

638
00:23:50,080 --> 00:23:52,159
you should also specify which version of

639
00:23:52,159 --> 00:23:54,480
windows you take as a

640
00:23:54,480 --> 00:23:56,240
reference implementation because as we

641
00:23:56,240 --> 00:23:58,640
saw all of them have small quirks and

642
00:23:58,640 --> 00:24:00,799
small edge cases that they handle

643
00:24:00,799 --> 00:24:03,120
differently

644
00:24:03,120 --> 00:24:05,200
we believe that we need more clear and

645
00:24:05,200 --> 00:24:07,200
more formal specification for the pe

646
00:24:07,200 --> 00:24:09,840
file format and we also need a publicly

647
00:24:09,840 --> 00:24:11,679
available reference implementation but

648
00:24:11,679 --> 00:24:13,679
this of course takes time so in the

649
00:24:13,679 --> 00:24:16,320
meantime we advise developers of

650
00:24:16,320 --> 00:24:18,640
security tools to model more than one

651
00:24:18,640 --> 00:24:20,880
version of the windows loader possibly

652
00:24:20,880 --> 00:24:22,880
asking the user

653
00:24:22,880 --> 00:24:25,440
which one to employ for their analysis

654
00:24:25,440 --> 00:24:26,490
for their analysis

655
00:24:26,490 --> 00:24:28,000
[Music]

656
00:24:28,000 --> 00:24:29,360
we believe that our language and

657
00:24:29,360 --> 00:24:31,600
framework is the reverse engineering

658
00:24:31,600 --> 00:24:33,760
effort to build these models and that's

659
00:24:33,760 --> 00:24:36,159
the reason for which we um release

660
00:24:36,159 --> 00:24:38,080
everything as open source both the

661
00:24:38,080 --> 00:24:40,159
framework and the models you can check

662
00:24:40,159 --> 00:24:42,880
it out our github repository

663
00:24:42,880 --> 00:24:45,279
all right with that being said my talk

664
00:24:45,279 --> 00:24:46,799
is concluded so i

665
00:24:46,799 --> 00:24:49,440
will gladly answer your questions if you

666
00:24:49,440 --> 00:24:51,460
happen to have any

667
00:24:51,460 --> 00:25:01,089
[Music]

668
00:25:01,600 --> 00:25:03,678
you

