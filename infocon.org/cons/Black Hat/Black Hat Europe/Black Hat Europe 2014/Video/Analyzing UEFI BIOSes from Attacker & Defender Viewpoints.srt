1
00:00:00,190 --> 00:00:04,299
morning everyone times the rock over and
this was work done with my colleagues

2
00:00:04,299 --> 00:00:04,690
here

3
00:00:04,690 --> 00:00:08,660
John Korean Sam so little bit about us

4
00:00:08,660 --> 00:00:12,960
her we're from the MITRE Corporation
we're trusted computing researchers we

5
00:00:12,960 --> 00:00:13,650
basically

6
00:00:13,650 --> 00:00:17,570
our focus is figuring out how we can
make security software that is in crap

7
00:00:17,570 --> 00:00:18,430
and doesn't just

8
00:00:18,430 --> 00:00:21,820
you know have attacker lied to you and
give you a false sense of security

9
00:00:21,820 --> 00:00:24,900
unfortunately basically everything out
there right now is crap

10
00:00:24,900 --> 00:00:28,109
so charm mitre itself if

11
00:00:28,109 --> 00:00:31,279
you probably haven't heard of us because
we're not for profit weirdo make

12
00:00:31,279 --> 00:00:33,170
commercial products and things like that

13
00:00:33,170 --> 00:00:37,680
where research and development center
works for the US government so basically

14
00:00:37,680 --> 00:00:40,489
it's supposed to be a neutral and Eddie
that's you know giving advice

15
00:00:40,489 --> 00:00:43,920
government as opposed to being a
for-profit contractor which is always

16
00:00:43,920 --> 00:00:45,620
giving advice on their own best interest

17
00:00:45,620 --> 00:00:50,500
so if you've heard later if it would
only be first things probably like CV

18
00:00:50,500 --> 00:00:55,059
sticks taxi some standards like that but
even then you probably don't think mitre

19
00:00:55,059 --> 00:00:56,160
CV it's just

20
00:00:56,160 --> 00:01:00,719
CV and might has been around for quite a
while since back in the ARPANET days

21
00:01:00,719 --> 00:01:05,890
so we've been doing a lot of talks over
the last year where

22
00:01:05,890 --> 00:01:09,250
we've been to return by us apart we've
been showing that

23
00:01:09,250 --> 00:01:12,460
as you would expect when people don't
understand and don't look at this

24
00:01:12,460 --> 00:01:13,220
technology

25
00:01:13,220 --> 00:01:16,310
it's riddled with holes so

26
00:01:16,310 --> 00:01:19,509
throughout the last year I'm as we've
been you know describing

27
00:01:19,509 --> 00:01:24,280
exploitable memory conditions in the
BIOS as you've been describing the fact

28
00:01:24,280 --> 00:01:24,619
that

29
00:01:24,619 --> 00:01:28,780
most biases are just a straight up
misconfigured to the bus pender does not

30
00:01:28,780 --> 00:01:31,890
even set the access control bit so
anyone can come along the right to it

31
00:01:31,890 --> 00:01:34,420
we've been basically saying fat

32
00:01:34,420 --> 00:01:38,150
modern UEFI BIOS is are sort of a
double-edged sword

33
00:01:38,150 --> 00:01:42,759
because they help us as defenders the
help us understand the system much more

34
00:01:42,759 --> 00:01:44,780
than was the case with legacy by ASO's

35
00:01:44,780 --> 00:01:47,880
but also at the same time this helps a

36
00:01:47,880 --> 00:01:51,920
attacker understand it in an attacker
can reverse engineer it get to the exact

37
00:01:51,920 --> 00:01:53,420
place that they need to compromise

38
00:01:53,420 --> 00:01:58,360
how much easier so this talk is
basically going to be justification that

39
00:01:58,360 --> 00:02:00,320
we're going to go through you if I a bit

40
00:02:00,320 --> 00:02:03,719
we're going to say okay right here
that's good for us the defenders right

41
00:02:03,719 --> 00:02:05,490
there that's bad for us as defenders

42
00:02:05,490 --> 00:02:09,390
10 so thats that's what this talk is
about

43
00:02:09,390 --> 00:02:13,900
I'm also we've put out tools like to
permit costs which was sort of the first

44
00:02:13,900 --> 00:02:17,140
tool that you can use actually go out
and evaluate your BIOS find out whether

45
00:02:17,140 --> 00:02:18,010
you're vulnerable

46
00:02:18,010 --> 00:02:22,079
don't the BIOS try to integrity check at
that kind of thing and so this will give

47
00:02:22,079 --> 00:02:23,920
you a little bit more context for

48
00:02:23,920 --> 00:02:27,010
if you use copper necklace we have to
practice hasn't

49
00:02:27,010 --> 00:02:30,280
as a script along with it where you can
integrity check you can say here's a

50
00:02:30,280 --> 00:02:33,439
clean copy of the BIOS that it may be
extracted from a BIOS update

51
00:02:33,439 --> 00:02:36,989
here's my bios do they differ if so

52
00:02:36,989 --> 00:02:41,760
yes the well then the if what how do I
understand that and so

53
00:02:41,760 --> 00:02:45,510
that's the other thing that is the point
in this talk to put it all out there

54
00:02:45,510 --> 00:02:49,180
and it's all good well for us to put it
all out there that says hey look you can

55
00:02:49,180 --> 00:02:50,359
now integrity check your BIOS

56
00:02:50,359 --> 00:02:54,239
but the reality is that if you find an
integrity violation or suspected

57
00:02:54,239 --> 00:02:55,400
integrity violation

58
00:02:55,400 --> 00:02:58,819
you're probably not going to know how to
evaluate and find out whether

59
00:02:58,819 --> 00:03:02,909
false-positive so got this is trying to
give you a little bit more

60
00:03:02,909 --> 00:03:07,269
context about that reality it takes much
more than

61
00:03:07,269 --> 00:03:10,659
a single hours worth of discussion to
understand it but

62
00:03:10,659 --> 00:03:13,609
you know we're always willing to to
check to find out whether we have false

63
00:03:13,609 --> 00:03:16,739
positives in Herne our tool so if you
find something that's wrong you don't

64
00:03:16,739 --> 00:03:18,209
understand it you can let us know

65
00:03:18,209 --> 00:03:22,079
alternatively we have an awful two days
with the training on this where

66
00:03:22,079 --> 00:03:26,049
basically we explain okay here's how you
analyze the BIOS to understand you know

67
00:03:26,049 --> 00:03:27,599
here's where the changes made

68
00:03:27,599 --> 00:03:32,620
and and understand it better so this is
basically a whirlwind tour

69
00:03:32,620 --> 00:03:35,889
%uh that so BIOS meaning

70
00:03:35,889 --> 00:03:40,310
legacy BIOS is dead on live you if I
right so it should be a theoretically

71
00:03:40,310 --> 00:03:41,319
dead because

72
00:03:41,319 --> 00:03:45,989
um it's at least dead or dying because
it should be aging out everywhere

73
00:03:45,989 --> 00:03:46,609
because

74
00:03:46,609 --> 00:03:50,669
Microsoft required anything that's going
to ship that has the windows 8 sticker

75
00:03:50,669 --> 00:03:51,069
on it

76
00:03:51,069 --> 00:03:54,389
tres most of your PC is there's very few
things that are

77
00:03:54,389 --> 00:03:58,159
shipping to be Linux Pacific fucked up
relax I suppose

78
00:03:58,159 --> 00:04:01,650
I everything that shipped with Windows 8
requires

79
00:04:01,650 --> 00:04:04,889
UEFI secure boot right near probably
maybe

80
00:04:04,889 --> 00:04:08,310
sure that the stalk you may be familiar
with some other controversy around know

81
00:04:08,310 --> 00:04:09,709
whether secure boot is a

82
00:04:09,709 --> 00:04:13,540
evil conspiracy to destroy the nixon
like you ought to be ashamed

83
00:04:13,540 --> 00:04:18,459
I don't think it is but 0 you can have
that opinion if you are

84
00:04:18,459 --> 00:04:22,560
so theoretically legacy BIOS should be
going away because basically everything

85
00:04:22,560 --> 00:04:25,840
all the vendors are incentivized but
they have to have you if I they have to

86
00:04:25,840 --> 00:04:26,620
have secure boot

87
00:04:26,620 --> 00:04:29,980
in order to actually ship their systems
for Windows 8 this as

88
00:04:29,980 --> 00:04:32,980
but in reality I there's

89
00:04:32,980 --> 00:04:37,919
elements in this which will never die so
at the very beginning a few if I

90
00:04:37,919 --> 00:04:41,490
I'll show the whole who obligatory
diagram in a little bit but at the very

91
00:04:41,490 --> 00:04:42,760
beginning with you if i

92
00:04:42,760 --> 00:04:46,550
it looks exactly the same as bile sits
hand coded assembly

93
00:04:46,550 --> 00:04:50,169
that's a specific to the hardware and
it's required to you know

94
00:04:50,169 --> 00:04:53,930
initialize the hardware as fast as
possible later on once you get past that

95
00:04:53,930 --> 00:04:57,080
stage then you can build up your nice
abstraction layers and you can have

96
00:04:57,080 --> 00:05:01,580
all the niceties you if I but but if you
have a change

97
00:05:01,580 --> 00:05:05,680
that occurs sort of they'll be one file
typically that'll be called the sack

98
00:05:05,680 --> 00:05:09,580
core the security core that's the
encoder some we think so

99
00:05:09,580 --> 00:05:13,570
what I'm saying here is if you go out
news capron case and you do by a stiff

100
00:05:13,570 --> 00:05:14,660
and you find 0

101
00:05:14,660 --> 00:05:17,440
the changes in the sack or I do
understand that well unfortunately

102
00:05:17,440 --> 00:05:19,750
that's a big bobber Pencoed assembly

103
00:05:19,750 --> 00:05:24,010
usually using a lot of PCI access
accessing an approach that you don't

104
00:05:24,010 --> 00:05:25,220
necessarily understand

105
00:05:25,220 --> 00:05:28,560
and so unfortunately that sort of a
lives on

106
00:05:28,560 --> 00:05:31,690
that's the harder and that sort of the
hardest job to analyze

107
00:05:31,690 --> 00:05:35,630
but basically we're gonna talk about all
the call the new interesting

108
00:05:35,630 --> 00:05:40,430
you ship it here so you if I had legacy
BIOS

109
00:05:40,430 --> 00:05:44,740
basically share to common traits so the
entry vector meaning the very first

110
00:05:44,740 --> 00:05:47,810
CPU instruction that CPU ever consumes

111
00:05:47,810 --> 00:05:51,680
that's going to be at the same place on
the flash chip so it

112
00:05:51,680 --> 00:05:55,220
the way the hardware initializes that
reset it always maps to

113
00:05:55,220 --> 00:06:00,560
address ffffff 0 so 4 gigabytes -16
that's always the

114
00:06:00,560 --> 00:06:03,800
memory address where the Cebu try to
access and

115
00:06:03,800 --> 00:06:08,510
the memory hardware at reset is
redirecting that memory access to the

116
00:06:08,510 --> 00:06:10,320
SPI flash chip

117
00:06:10,320 --> 00:06:14,880
so little flash chip down on the SPI bus
so they all start from the same place

118
00:06:14,880 --> 00:06:16,650
and the initial goal and

119
00:06:16,650 --> 00:06:20,080
the overall goal is really it's all
about you know initializing the hardware

120
00:06:20,080 --> 00:06:20,810
it's really

121
00:06:20,810 --> 00:06:25,450
its climbing its getting you to a state
where you can pass off to bootloader

122
00:06:25,450 --> 00:06:27,729
pass off to an operating system
hypervisor

123
00:06:27,729 --> 00:06:30,409
try to get everything initialize he
could have

124
00:06:30,409 --> 00:06:34,639
you know keyboard input video output the

125
00:06:34,639 --> 00:06:37,759
the big difference though the big
difference is that legacy BIOS it was

126
00:06:37,759 --> 00:06:40,429
this big giant proprietary blah boast of

127
00:06:40,429 --> 00:06:44,709
added that plus a whole bunch of other
things you if I is much nicer because

128
00:06:44,709 --> 00:06:46,629
it's now documented that we have a spec

129
00:06:46,629 --> 00:06:50,369
we can understand what the coach trying
to do and trying to understand

130
00:06:50,369 --> 00:06:54,459
did behaving in accordance with that
speck so

131
00:06:54,459 --> 00:06:59,339
also the you if I had as a reference
implementation which is open source and

132
00:06:59,339 --> 00:07:03,129
are available um and so basically
there's a single

133
00:07:03,129 --> 00:07:06,429
reference implementation which Intel put
out there and says hey guys this is how

134
00:07:06,429 --> 00:07:09,860
you're basically supposed to build
something that conforms to the UEFI spec

135
00:07:09,860 --> 00:07:13,819
and then the a.m. eyes Phoenix and to
know inside that the world

136
00:07:13,819 --> 00:07:17,419
they go customize that at their value
add so that they can try to get

137
00:07:17,419 --> 00:07:20,569
other people to buy it because if they
didn't add anything to it and people

138
00:07:20,569 --> 00:07:22,579
would just start from the reference
implementation right

139
00:07:22,579 --> 00:07:26,919
so they out although and gooey niceties
and that kind of stuff

140
00:07:26,919 --> 00:07:30,149
and they sell it to the Dells HP's win
over the world and

141
00:07:30,149 --> 00:07:33,359
the Dells HP's win over the world may go
customize it further

142
00:07:33,359 --> 00:07:38,289
but there's some core initial open
source thing that you can evaluate we

143
00:07:38,289 --> 00:07:42,479
that at Black Hat USA this year we
showed where Corey went and spent a

144
00:07:42,479 --> 00:07:44,439
couple weeks looking at the open source
referring

145
00:07:44,439 --> 00:07:47,809
reference implementation and within a
couple weeks he was able to find you

146
00:07:47,809 --> 00:07:50,239
know to exploitable memory commissions
which then

147
00:07:50,239 --> 00:07:53,259
as I was saying these propagate out all
those other

148
00:07:53,259 --> 00:07:57,259
biases so the point is we can evaluate
the security

149
00:07:57,259 --> 00:08:00,839
much much more readily than we could
with legacy buses

150
00:08:00,839 --> 00:08:04,409
so I've been using the term but I'll
expanded now

151
00:08:04,409 --> 00:08:07,899
if I stands for unified extensible
firmware interface

152
00:08:07,899 --> 00:08:11,779
it was something that originally Intel
made when that they were trying to get

153
00:08:11,779 --> 00:08:13,369
rid of legacy support and

154
00:08:13,369 --> 00:08:16,669
we're all to blame for x86 still having

155
00:08:16,669 --> 00:08:19,879
no legacy thirty years worth of Crofton
it

156
00:08:19,879 --> 00:08:24,139
Intel tried to make a teeny in Maine on
backwards compatible 64-bit architecture

157
00:08:24,139 --> 00:08:25,329
and everyone said net

158
00:08:25,329 --> 00:08:28,629
to 1810 my existing applications to run

159
00:08:28,629 --> 00:08:31,879
so now we have you know 64-bit legacy
Croft

160
00:08:31,879 --> 00:08:36,579
Intel made this you if I reference imply
made this you if I spec when they were

161
00:08:36,579 --> 00:08:39,110
trying to make the I 10 a.m. by us and
they recognized

162
00:08:39,110 --> 00:08:43,470
look we can do all of the legacy stuff
we don't want to do all the legacy stuff

163
00:08:43,470 --> 00:08:46,860
we've had to do for thirty years on the
x86 architecture let's build up

164
00:08:46,860 --> 00:08:48,390
something that's a little nicer

165
00:08:48,390 --> 00:08:52,040
a little more generic and they're trying
to have something that would work for

166
00:08:52,040 --> 00:08:53,780
x86 as well as I tenia

167
00:08:53,780 --> 00:08:57,540
and really can work for peanuts or any
architecture

168
00:08:57,540 --> 00:09:02,220
but but that was originally if I became
you if I when they

169
00:09:02,220 --> 00:09:06,590
finally got by an from everybody hand
they it was no longer just Intel doing

170
00:09:06,590 --> 00:09:08,910
it but they had the UEFI forum which was

171
00:09:08,910 --> 00:09:12,430
watch other companies that bought in and
%uh started doing things with it

172
00:09:12,430 --> 00:09:16,500
so no although there is a

173
00:09:16,500 --> 00:09:20,730
I'm although there is this nice pure you
if I world a lot of the machines that

174
00:09:20,730 --> 00:09:24,770
probably you have unless you bought in
the last couple years they they often

175
00:09:24,770 --> 00:09:25,650
have this thing

176
00:09:25,650 --> 00:09:28,440
built and then there's this you know
backwards compatibility mechanism called

177
00:09:28,440 --> 00:09:30,120
the compatibility support module

178
00:09:30,120 --> 00:09:34,750
and what this is is that basically the
overall system is you if I but

179
00:09:34,750 --> 00:09:38,580
then there's this big globs legacy miles
in there so that you can basically just

180
00:09:38,580 --> 00:09:39,110
run

181
00:09:39,110 --> 00:09:43,140
everything without having the changed
everything so cut

182
00:09:43,140 --> 00:09:47,200
CSM is the is a sorta backwards
compatibility its

183
00:09:47,200 --> 00:09:50,060
it's mostly going away at this point
like if you buy anything new it

184
00:09:50,060 --> 00:09:53,290
hopefully shouldn't be using CSM it
should be sorta pure you if I

185
00:09:53,290 --> 00:09:57,760
but but that's always still occur cause
for concern for a security problems

186
00:09:57,760 --> 00:10:02,130
but the one really interesting property
of you if i four

187
00:10:02,130 --> 00:10:05,430
attackers is that it's getting really
really big

188
00:10:05,430 --> 00:10:09,550
so and actually I don't think I mention
it anywhere else will mention it here

189
00:10:09,550 --> 00:10:12,570
it's also written in high-level
languages

190
00:10:12,570 --> 00:10:15,900
it's written in C I don't think they
support c plus plus but

191
00:10:15,900 --> 00:10:20,010
you've got C code building up this
reference implantation

192
00:10:20,010 --> 00:10:24,590
that is sort of getting giant its 8
twelve sixteen megabytes on a given

193
00:10:24,590 --> 00:10:25,470
flash chip

194
00:10:25,470 --> 00:10:28,590
um and so you know big

195
00:10:28,590 --> 00:10:32,290
high-level language code lots of
opportunities for

196
00:10:32,290 --> 00:10:39,290
I'll typical buffer overflows and so
forth

197
00:10:40,550 --> 00:10:43,830
now if you're not the kinda person who
enjoys reading thousands and thousands

198
00:10:43,830 --> 00:10:45,700
of pages aspects we are we

199
00:10:45,700 --> 00:10:49,250
you know we like doing that that's how
we find stuff that nobody else finds

200
00:10:49,250 --> 00:10:52,510
so if you don't like to do that this is
a good starting point

201
00:10:52,510 --> 00:10:55,840
conference in summer from Intel has you
know he's

202
00:10:55,840 --> 00:10:59,900
integral to the you if I effort and he's
made a book that is basically a

203
00:10:59,900 --> 00:11:00,990
high-level overview

204
00:11:00,990 --> 00:11:05,060
but if you wanna jump right in you can
go download all the specifications

205
00:11:05,060 --> 00:11:09,000
so this is what we're gonna sorta be
working our way through today

206
00:11:09,000 --> 00:11:12,870
a this is everybody who does

207
00:11:12,870 --> 00:11:17,000
buy stocks these days has to put up the
picture this is Intel's sort of fun

208
00:11:17,000 --> 00:11:21,390
description of how emotionally you if I
works you start at the very beginning

209
00:11:21,390 --> 00:11:22,960
security facing

210
00:11:22,960 --> 00:11:27,020
theoretically that's for security is but
in reality that's not when you have

211
00:11:27,020 --> 00:11:30,460
pre if I initialization so you've got
the well

212
00:11:30,460 --> 00:11:33,930
I won't go thru mo will hit them each in
turn so there's

213
00:11:33,930 --> 00:11:37,530
seven phases notionally but in reality
they're not all IOU's

214
00:11:37,530 --> 00:11:41,180
but we're gonna start a little bit lower
than that

215
00:11:41,180 --> 00:11:44,650
and so we're going to start sort of what
things look like on the hardware the

216
00:11:44,650 --> 00:11:45,110
state's

217
00:11:45,110 --> 00:11:49,740
okay so

218
00:11:49,740 --> 00:11:52,910
legacy BIOS you have the SPI flash chip
or

219
00:11:52,910 --> 00:11:56,760
the Intel firmware hub on things
typically older and 2007

220
00:11:56,760 --> 00:12:00,790
and this is basically if you if you
think about your computer architecture

221
00:12:00,790 --> 00:12:03,540
you may be familiar with you may be
heard the term you know Northbridge

222
00:12:03,540 --> 00:12:04,310
Southbridge

223
00:12:04,310 --> 00:12:09,040
to have a CPU he had North Bridge which
handled high-speed proposed menu to

224
00:12:09,040 --> 00:12:11,100
South Bridge which handled slow-speed
purples

225
00:12:11,100 --> 00:12:15,700
the SPI flash chip is hanging off the
South Bridge modern systems the

226
00:12:15,700 --> 00:12:18,770
trucks in the North Bridge in going into
the CPU and

227
00:12:18,770 --> 00:12:22,730
other stuff has gone into South Bridge
now there's just sort of CPU and

228
00:12:22,730 --> 00:12:23,930
platform controller hub

229
00:12:23,930 --> 00:12:27,070
and the flash chip things off the
platform controller hub no

230
00:12:27,070 --> 00:12:31,330
so the legacy by us was basically a big
proprietary blob as I was saying each

231
00:12:31,330 --> 00:12:34,100
vendor had for their own proprietary
formats which

232
00:12:34,100 --> 00:12:37,339
would typically have to be
reverse-engineered I

233
00:12:37,339 --> 00:12:41,740
typically have to be reverse engineered
and people online wouldn't reverse

234
00:12:41,740 --> 00:12:45,089
engineered for various reasons when they
put up tools in order to

235
00:12:45,089 --> 00:12:49,800
in order to a break these things apart
this order for you know analogous to

236
00:12:49,800 --> 00:12:53,000
right this is a bad old days and if you
saw the for word on re:

237
00:12:53,000 --> 00:12:55,660
talk yesterday but still the world they
live in they've got all these

238
00:12:55,660 --> 00:12:56,630
proprietary

239
00:12:56,630 --> 00:13:00,220
compressed unpacked sort of things and
if you go back up

240
00:13:00,220 --> 00:13:03,860
a more than you know six years seven
years this is what you'll still see on

241
00:13:03,860 --> 00:13:05,000
x86 systems

242
00:13:05,000 --> 00:13:09,519
amend typically they were they look like
packed file which means you had

243
00:13:09,519 --> 00:13:13,230
in order to save space on the SPI flash
chip always the vendors were trying to

244
00:13:13,230 --> 00:13:14,310
you know say pinch

245
00:13:14,310 --> 00:13:17,420
pinch a fraction of a penny times
million to machines means

246
00:13:17,420 --> 00:13:21,800
actual money saved so they would use the
smallest possible flash chip may have a

247
00:13:21,800 --> 00:13:22,300
little

248
00:13:22,300 --> 00:13:25,610
a decompression routine at the beginning
so you call into the decompression

249
00:13:25,610 --> 00:13:27,910
routine and expense stuff out into RAM

250
00:13:27,910 --> 00:13:32,980
once RAM is available and that's weird

251
00:13:32,980 --> 00:13:36,560
so nowadays um SPI flash chips

252
00:13:36,560 --> 00:13:39,899
Intel mandates that you have certain
kick I'm

253
00:13:39,899 --> 00:13:45,390
you have certain be are not behaviors
characteristics of flash chips like they

254
00:13:45,390 --> 00:13:47,050
must be able to be rewritten

255
00:13:47,050 --> 00:13:50,510
supply conder dozen times or something
like that so they have certain

256
00:13:50,510 --> 00:13:52,190
requirements that they put on flash
chips

257
00:13:52,190 --> 00:13:55,270
and they require that they support and
this

258
00:13:55,270 --> 00:13:59,470
this notion of a flash descriptor
question scripture is sort of a data

259
00:13:59,470 --> 00:14:01,970
structure that put at the the front of
the flash chip

260
00:14:01,970 --> 00:14:05,959
and that then describes specific regions
within the flash chip so

261
00:14:05,959 --> 00:14:09,250
Gigabit Ethernet region that has sort of
configuration information for Gigabit

262
00:14:09,250 --> 00:14:09,850
Ethernet

263
00:14:09,850 --> 00:14:13,910
platform data that has miscellaneous
stuff management engine if you've heard

264
00:14:13,910 --> 00:14:17,060
of AMT active management technology may
be hurt if the

265
00:14:17,060 --> 00:14:20,180
the talk about attacking that you know
many years ago

266
00:14:20,180 --> 00:14:24,149
that contains information there that is
consumed by

267
00:14:24,149 --> 00:14:27,890
the management engine and then UEFI BIOS
a region

268
00:14:27,890 --> 00:14:31,630
there's sort of a bias region described
by this that's where the actual content

269
00:14:31,630 --> 00:14:33,630
we care about that we want to analyze
our

270
00:14:33,630 --> 00:14:38,240
from so the flesh descriptor can create
new region so this will probably

271
00:14:38,240 --> 00:14:39,560
increase in the future

272
00:14:39,560 --> 00:14:43,850
but for the time being that's what's
there alright

273
00:14:43,850 --> 00:14:46,790
I don't know why I used animations I
think I copied from previous lies in the

274
00:14:46,790 --> 00:14:48,790
use and emissions

275
00:14:48,790 --> 00:14:52,650
so um with what we care about here
within the

276
00:14:52,650 --> 00:14:57,020
by a surgeon in the UEFI BIOS it's going
to be organized according to

277
00:14:57,020 --> 00:15:01,780
for more volumes so what this turns into
is that we have a nice well-defined

278
00:15:01,780 --> 00:15:05,330
well format and firmware file system
ultimately so

279
00:15:05,330 --> 00:15:09,760
I'll spec lays out that there's quite a
quote for more devices which may be real

280
00:15:09,760 --> 00:15:10,600
or physical

281
00:15:10,600 --> 00:15:13,990
the firmware devices are broken into for
more volumes which can be nested

282
00:15:13,990 --> 00:15:16,090
speaking out for more volumes were thin
volumes

283
00:15:16,090 --> 00:15:19,820
I sometimes think I'm the volumes kind
of like folders and then there's going

284
00:15:19,820 --> 00:15:22,860
to be a whole bunch of files from this
folder in there may be a compressed

285
00:15:22,860 --> 00:15:26,620
folder within a folder um

286
00:15:26,620 --> 00:15:30,690
I and and oftentimes we see will will
cover the phases in a second but

287
00:15:30,690 --> 00:15:34,090
just so you know oftentimes will see the
folders or a broken up that

288
00:15:34,090 --> 00:15:38,260
all of the files that run in one phase
both the boot are in one folder and all

289
00:15:38,260 --> 00:15:40,540
the files and another phase are in a
different folder

290
00:15:40,540 --> 00:15:45,320
but ultimately the base unit is a flash
file and so these flash files you know

291
00:15:45,320 --> 00:15:47,230
it has some well-defined structure has

292
00:15:47,230 --> 00:15:50,420
well-defined you know ways that we can
find it parses

293
00:15:50,420 --> 00:15:55,310
but within each file the there are then
actually separate sections

294
00:15:55,310 --> 00:15:58,290
and that's the part that we ultimately
care about those that's the real file

295
00:15:58,290 --> 00:15:59,370
that we care about because

296
00:15:59,370 --> 00:16:02,730
a given section will be for instance I'm

297
00:16:02,730 --> 00:16:05,850
that was called the dependency
expression meaning like yours the other

298
00:16:05,850 --> 00:16:08,150
stuff that needs to load before this
file loads

299
00:16:08,150 --> 00:16:11,850
or a given section will be an actual
portable excusable file

300
00:16:11,850 --> 00:16:15,470
so as I said right here um

301
00:16:15,470 --> 00:16:19,390
I when we did all the way down into this
firmware file system

302
00:16:19,390 --> 00:16:22,960
we find that the different sections can
either be portable excludable former

303
00:16:22,960 --> 00:16:27,740
where they can beatrice excusable format
so PE if you know Windows you know

304
00:16:27,740 --> 00:16:31,380
PE is basically Windows excusable format
likes of former

305
00:16:31,380 --> 00:16:36,390
and TE is the exact same thing but they
basically just collapsed and the

306
00:16:36,390 --> 00:16:40,110
the headers so you know here's the thing
where

307
00:16:40,110 --> 00:16:44,950
both the guy in the bag I say hey how
interesting my bios uses quote-unquote

308
00:16:44,950 --> 00:16:46,940
Windows executors both

309
00:16:46,940 --> 00:16:50,910
right I know how to analyze those so I
as a defender know how to analyze those

310
00:16:50,910 --> 00:16:52,310
if someone modifies them

311
00:16:52,310 --> 00:16:55,680
and eyes an attacker know how to break
them apart analyze them Interbrand

312
00:16:55,680 --> 00:16:58,750
ida and and figure out where I need him
a

313
00:16:58,750 --> 00:17:02,490
insert my hoax or what have you so

314
00:17:02,490 --> 00:17:05,610
there's basically three options that you
have right now for from your filesystem

315
00:17:05,610 --> 00:17:06,550
parsing

316
00:17:06,550 --> 00:17:09,920
there's if I poll which is the thing
that we currently use within

317
00:17:09,920 --> 00:17:13,250
copernicus is a extra scripts but

318
00:17:13,250 --> 00:17:16,300
because this was something that was just
sort of put up by student was the first

319
00:17:16,300 --> 00:17:19,200
one and it was you know at the time that
we started doing this it was

320
00:17:19,200 --> 00:17:22,890
and what was available we didn't have to
we didn't want to make our own certainly

321
00:17:22,890 --> 00:17:24,150
could have but why not use

322
00:17:24,150 --> 00:17:28,160
someone else's code that's out there but
this is not maintained over time and

323
00:17:28,160 --> 00:17:28,950
we've been sort of

324
00:17:28,950 --> 00:17:32,460
getting tired of hiking in the
additional support and fixes and so

325
00:17:32,460 --> 00:17:35,990
forth so the other tools are you if I
tool which also

326
00:17:35,990 --> 00:17:39,640
this is a nice I do anything that will
see in a second here and then

327
00:17:39,640 --> 00:17:43,400
there's a thing called you if I extract
which will basically pull out all of the

328
00:17:43,400 --> 00:17:44,810
files from them off to your

329
00:17:44,810 --> 00:17:48,370
tear filesystem and then there's you if
I from our parser

330
00:17:48,370 --> 00:17:51,970
which was another thing that is being
maintained in being

331
00:17:51,970 --> 00:17:55,150
actively update and and all see that a
little bit later to

332
00:17:55,150 --> 00:17:58,280
so will come back to this later as

333
00:17:58,280 --> 00:18:02,060
as we determine whether we have enough
time but this is basically what you'd

334
00:18:02,060 --> 00:18:04,610
see in you if I too will you go you
don't pay

335
00:18:04,610 --> 00:18:08,040
for more filing hear something to pray
to stumps out something you extract from

336
00:18:08,040 --> 00:18:09,260
a BIOS update file

337
00:18:09,260 --> 00:18:13,100
you don't fit in here it'll slice apart
and say here's the different regions

338
00:18:13,100 --> 00:18:14,770
that the flash descriptor defines

339
00:18:14,770 --> 00:18:18,670
there within the bias region you can
actually expand that out and you can see

340
00:18:18,670 --> 00:18:19,950
all the individual files

341
00:18:19,950 --> 00:18:22,360
cell will like I said we'll come back to
that

342
00:18:22,360 --> 00:18:26,010
but for now this is just to say okay
there's a an easy way to start getting

343
00:18:26,010 --> 00:18:27,850
information out of the cell files

344
00:18:27,850 --> 00:18:30,890
so from both the attacker

345
00:18:30,890 --> 00:18:34,120
and defenders perspective right
standardization is a good thing

346
00:18:34,120 --> 00:18:37,570
right so standardization help the
attacker find that

347
00:18:37,570 --> 00:18:42,320
okay well I can now analyze all bio says
for all vendors and a nice easy way

348
00:18:42,320 --> 00:18:45,620
and that also helps us though as a
defender right so we can now have

349
00:18:45,620 --> 00:18:47,570
generic integrity checking software

350
00:18:47,570 --> 00:18:51,040
breaks everything apart the same way I
and and

351
00:18:51,040 --> 00:18:55,810
gives us more semantically meaningful
information about

352
00:18:55,810 --> 00:18:58,630
okay what was and I don't let just
telling you hey there's three bites

353
00:18:58,630 --> 00:19:00,810
different at offset 2004 and

354
00:19:00,810 --> 00:19:04,060
57 I tell you that within the dot tech
section

355
00:19:04,060 --> 00:19:07,930
a portable executable file that's called
nopee I initialize memory

356
00:19:07,930 --> 00:19:11,900
that is where we find you know i three
by changing table tried to jump

357
00:19:11,900 --> 00:19:13,980
instruction right so

358
00:19:13,980 --> 00:19:17,060
so it works for against just have the
standardization

359
00:19:17,060 --> 00:19:21,550
right but but the real question is who
chose to move faster attackers and

360
00:19:21,550 --> 00:19:22,490
defenders Ryan

361
00:19:22,490 --> 00:19:26,190
field

362
00:19:26,190 --> 00:19:30,200
so

363
00:19:30,200 --> 00:19:34,180
the sec fazer security face is the very
first

364
00:19:34,180 --> 00:19:37,510
notional phase this is a binary blob
love

365
00:19:37,510 --> 00:19:40,640
hardware specific code needs to get the
system

366
00:19:40,640 --> 00:19:44,580
up and running as fast as possible in
just pass off to the a PI faced

367
00:19:44,580 --> 00:19:47,740
notional you can see here it says pre
verifier

368
00:19:47,740 --> 00:19:52,020
hopefully that's somewhat readable pre
verifier should theoretically be

369
00:19:52,020 --> 00:19:55,690
the corridor trust for measurement there
should be an ability from within this

370
00:19:55,690 --> 00:19:56,230
code

371
00:19:56,230 --> 00:20:00,110
to measure the rest of your BIOS and you
know confirm well you're not even bother

372
00:20:00,110 --> 00:20:01,710
with confirm just get a measurement

373
00:20:01,710 --> 00:20:05,210
and store after some trustworthy
location like TPM so that

374
00:20:05,210 --> 00:20:08,920
you can actually say something about is
this code look like I expected to see

375
00:20:08,920 --> 00:20:11,940
to look in reality um

376
00:20:11,940 --> 00:20:16,720
a last year black and we did a talk
talking about you know how these static

377
00:20:16,720 --> 00:20:19,050
route to transfer measurements for a
fundamentally broken

378
00:20:19,050 --> 00:20:23,180
but but there's additional technology
that's going to be coming into place in

379
00:20:23,180 --> 00:20:23,770
that war

380
00:20:23,770 --> 00:20:28,100
improve that but notionally they had
this idea of the sex phases where the

381
00:20:28,100 --> 00:20:30,210
most important security stuff goes down

382
00:20:30,210 --> 00:20:34,590
obviously if you compromise the system
this early if you compromise at the very

383
00:20:34,590 --> 00:20:35,559
beginning if you tomorrow

384
00:20:35,559 --> 00:20:39,249
by the very first instruction that the
CPU ever executes than you

385
00:20:39,249 --> 00:20:42,370
are in you know the most trustworthy
position you can modify

386
00:20:42,370 --> 00:20:46,169
manipulate and make the system lion for
everything else that happens thereafter

387
00:20:46,169 --> 00:20:49,269
but the security phase

388
00:20:49,269 --> 00:20:53,610
hit executes from a flash chips are
actually is like living in the flesh out

389
00:20:53,610 --> 00:20:55,029
there is no RAM initialized

390
00:20:55,029 --> 00:20:58,879
and then it moves along and that's what
I one per

391
00:20:58,879 --> 00:21:03,509
thought I had some where the security
phases and misnomer in reality all the

392
00:21:03,509 --> 00:21:07,360
%um security critical things the
verification of digital signatures the

393
00:21:07,360 --> 00:21:09,289
measurement up for the BIOS

394
00:21:09,289 --> 00:21:12,889
on actual real platforms they don't
actually match that name

395
00:21:12,889 --> 00:21:16,840
they do it much later and that means an
attacker coming in earlier

396
00:21:16,840 --> 00:21:19,960
will always win um

397
00:21:19,960 --> 00:21:24,279
I yep that's where it should go over
that some you know is it's a good thing

398
00:21:24,279 --> 00:21:28,029
purifies another one have many great
examples of how things can be

399
00:21:28,029 --> 00:21:29,389
architecturally correct

400
00:21:29,389 --> 00:21:34,179
and implementation incorrect right so
it's all good to say oh well I see that

401
00:21:34,179 --> 00:21:36,470
they're doing the right thing in the
architecture must be okay

402
00:21:36,470 --> 00:21:40,100
right that's why we have to go in and
actually evaluate things so a

403
00:21:40,100 --> 00:21:41,929
miscellaneous point which i don't wanna

404
00:21:41,929 --> 00:21:45,490
who dwell on too long is just that when
you're building up the system there's

405
00:21:45,490 --> 00:21:46,840
multiple paths that

406
00:21:46,840 --> 00:21:50,320
that this will take depending on the
sleep state it wasn't so if you just

407
00:21:50,320 --> 00:21:51,360
reboot the system

408
00:21:51,360 --> 00:21:55,490
here you know coming from and of stating
you're going to go in

409
00:21:55,490 --> 00:21:59,529
important point which will and the only
reason I mention this

410
00:21:59,529 --> 00:22:03,340
is that which there for a reason
described here is that

411
00:22:03,340 --> 00:22:07,080
there's different when you when you want
to explore the potential for

412
00:22:07,080 --> 00:22:10,389
vulnerabilities on the bio she have to
explore that there's different code past

413
00:22:10,389 --> 00:22:13,100
that'll go down depending on whether you
just went to sleep and woke up for you

414
00:22:13,100 --> 00:22:15,629
want to hibernate you woke up are you
coming from a cold boot

415
00:22:15,629 --> 00:22:19,029
and so the sleep states there

416
00:22:19,029 --> 00:22:22,190
ACPI sleep states um but

417
00:22:22,190 --> 00:22:26,879
as I said they go to different difranco
paths so what we've found in what we'll

418
00:22:26,879 --> 00:22:28,580
be talking about later in the year

419
00:22:28,580 --> 00:22:31,340
we've got a we've got a whole bunch of
all abilities we've already described a

420
00:22:31,340 --> 00:22:33,559
collision on abilities that are still in
for

421
00:22:33,559 --> 00:22:38,100
disclosure we're having the vendors fix
them we found situations where

422
00:22:38,100 --> 00:22:41,169
I you may have a system into practice
may say

423
00:22:41,169 --> 00:22:44,669
0 this system is currently locked its
configured correctly it's protected

424
00:22:44,669 --> 00:22:45,820
that's good

425
00:22:45,820 --> 00:22:49,360
but then you put the system to sleep and
you wake the system up and

426
00:22:49,360 --> 00:22:53,350
the BIOS does not do the right thing
upon wake and it doesn't lock things

427
00:22:53,350 --> 00:22:54,830
down that got on Sat

428
00:22:54,830 --> 00:22:58,640
as a consequence asleep and that means
then you know all it takes is one sleep

429
00:22:58,640 --> 00:23:00,830
in one way can you back to the normal
system which

430
00:23:00,830 --> 00:23:04,420
hun laptops is you know pretty
guaranteed to happen

431
00:23:04,420 --> 00:23:07,820
pretty quickly rent so we'll be talking
about that

432
00:23:07,820 --> 00:23:11,080
later on later in the year comments 0
actually there was a

433
00:23:11,080 --> 00:23:14,580
specific issue and I'll machines that
they patched quite a while back like

434
00:23:14,580 --> 00:23:15,700
last december we just

435
00:23:15,700 --> 00:23:19,140
haven't got around to to the problem is
its

436
00:23:19,140 --> 00:23:22,230
it's not a full conference talk with a
fresh it's just a went to sleep

437
00:23:22,230 --> 00:23:25,340
came up its its got its horrible no

438
00:23:25,340 --> 00:23:29,070
so wherefore adding that in combining
that with some other problems too

439
00:23:29,070 --> 00:23:33,270
to get it to be a full conference talk
with information so

440
00:23:33,270 --> 00:23:37,870
um teletype reparation up a sec phase is
responsible for is configuring the CPU

441
00:23:37,870 --> 00:23:38,930
for cash as RAM

442
00:23:38,930 --> 00:23:42,370
this makes it so that even though the
Rams not actually set up yet

443
00:23:42,370 --> 00:23:45,900
by the time you get into the next phase
the PI phase you can actually have

444
00:23:45,900 --> 00:23:49,210
see code executing in the

445
00:23:49,210 --> 00:23:53,010
in the PI face because if you don't have
a stack if you don't have this ability

446
00:23:53,010 --> 00:23:54,340
to push in pop

447
00:23:54,340 --> 00:23:57,860
then you can expect that normal compiler
generated code will actually work that's

448
00:23:57,860 --> 00:24:00,040
why sec phases Hanko to assembly whether

449
00:24:00,040 --> 00:24:03,960
doing their best to never you know try
to use were you know memory or temporary

450
00:24:03,960 --> 00:24:04,470
space

451
00:24:04,470 --> 00:24:07,750
but once caches RAM is initialized then
you can have fun

452
00:24:07,750 --> 00:24:11,370
compiler generated code running and

453
00:24:11,370 --> 00:24:14,400
then it you know has two activate the
the main CPU

454
00:24:14,400 --> 00:24:17,960
so forth so originally

455
00:24:17,960 --> 00:24:21,440
so in the the full version of this we
would go down like everything and talk

456
00:24:21,440 --> 00:24:22,660
about all the stuff but

457
00:24:22,660 --> 00:24:26,800
but this is just too to speak to you
there's a there's a place in 2008 paper

458
00:24:26,800 --> 00:24:29,920
out there were they talking about
reducing platform boot I'm so

459
00:24:29,920 --> 00:24:33,090
you may know that going along with her
windows 8 secure we are also

460
00:24:33,090 --> 00:24:35,770
requirements such as you must you know
for you must put

461
00:24:35,770 --> 00:24:40,250
this fast well if you put requirements
on the vendors that they must move fast

462
00:24:40,250 --> 00:24:41,810
in the most beautiful early

463
00:24:41,810 --> 00:24:46,050
there they're probably gonna the boot
fast one is the easy one to achieve it

464
00:24:46,050 --> 00:24:47,850
at the expense of the boot securely

465
00:24:47,850 --> 00:24:49,500
help

466
00:24:49,500 --> 00:24:52,570
so this just to say that if you're
interested in that kind of thing there's

467
00:24:52,570 --> 00:24:53,440
a nice Intel

468
00:24:53,440 --> 00:24:56,590
pic white paper out there that you can
look at for reducing

469
00:24:56,590 --> 00:25:01,690
good times that talks through all of the
this can also be used to understand like

470
00:25:01,690 --> 00:25:02,280
what

471
00:25:02,280 --> 00:25:05,690
the bio says there may be doing in each
phase you can say well maybe the vendor

472
00:25:05,690 --> 00:25:07,670
was trying to implement this and they
were

473
00:25:07,670 --> 00:25:10,650
you know this is why the microcode
update is right here this is why the

474
00:25:10,650 --> 00:25:12,160
caches RM is right here

475
00:25:12,160 --> 00:25:15,870
but ultimately when a sec faces down

476
00:25:15,870 --> 00:25:19,400
this is where the niceties of
standardization comes in

477
00:25:19,400 --> 00:25:24,010
there's going to be some hand off to PI
so it's initialized everything its got

478
00:25:24,010 --> 00:25:27,550
a sec faces responsibility is taken care
of and it will now

479
00:25:27,550 --> 00:25:32,460
collect information which it'll pass to
PI that information includes things like

480
00:25:32,460 --> 00:25:36,390
top information about the operating
environment such as where the temporary

481
00:25:36,390 --> 00:25:39,410
RAM is like how much cash israel has it
actually initialized

482
00:25:39,410 --> 00:25:43,540
location of the temporary stack location
of the boot for more volume so this is

483
00:25:43,540 --> 00:25:44,270
basically

484
00:25:44,270 --> 00:25:47,700
a for more volume as we were discussing
before on the flash chip and its tell

485
00:25:47,700 --> 00:25:49,750
you here's the offset to the firmware
volume

486
00:25:49,750 --> 00:25:54,010
so that you can start decompressing or
no just pulling in parsing

487
00:25:54,010 --> 00:25:58,180
the information in order to boot all at
the PE I've Face coat

488
00:25:58,180 --> 00:26:03,390
and her

489
00:26:03,390 --> 00:26:07,980
yeah I'll Lister yeah thats and probably
shouldn't even talk to you

490
00:26:07,980 --> 00:26:11,780
so on the PI face their pre

491
00:26:11,780 --> 00:26:16,100
if I face this a lot of work goes on
here but then ultimately much more work

492
00:26:16,100 --> 00:26:17,310
will go on in the taxi fares

493
00:26:17,310 --> 00:26:20,560
so its job is to initialize permanent
memory so this is where you actually

494
00:26:20,560 --> 00:26:24,250
initialize RAM and you actually get the
system into what you would think I was a

495
00:26:24,250 --> 00:26:24,990
normal

496
00:26:24,990 --> 00:26:28,750
running stay it also then you know what
that initializes memory it has to pass

497
00:26:28,750 --> 00:26:31,800
that off to the next phase and say here
you go next phase you can just assume

498
00:26:31,800 --> 00:26:33,290
that RAM is initialized

499
00:26:33,290 --> 00:26:38,130
it describes there's a a variety of hand
of block serve

500
00:26:38,130 --> 00:26:42,260
Afghan meta data that I must pass on to
the next phase and

501
00:26:42,260 --> 00:26:46,570
and ultimately yeah and its job is to
you once it has executed all the PI

502
00:26:46,570 --> 00:26:48,790
phase hardware initializing modules

503
00:26:48,790 --> 00:26:52,490
then was everything's complete it will
go ahead and pass the next phase

504
00:26:52,490 --> 00:26:56,040
so in the PI phase we have this notion

505
00:26:56,040 --> 00:27:00,379
up im pre if I initialization modules

506
00:27:00,379 --> 00:27:04,950
so panels are the types of things we're
now we've got portable excludable files

507
00:27:04,950 --> 00:27:08,559
well-defined things on some systems
there P e's on some system there TE's

508
00:27:08,559 --> 00:27:13,450
but they're basically this nice modular
format where different chunks

509
00:27:13,450 --> 00:27:16,940
have code handle initialization have
different hardware and

510
00:27:16,940 --> 00:27:21,240
also very interestingly they have a
well-defined structure where

511
00:27:21,240 --> 00:27:26,279
they I'm they create to basically API's
for each other

512
00:27:26,279 --> 00:27:29,309
so they say I'ma p.m. that handles

513
00:27:29,309 --> 00:27:32,769
no status reporting information so I
handle

514
00:27:32,769 --> 00:27:36,639
like writing to a console auger I handle
writing to the flasher dialoguing type

515
00:27:36,639 --> 00:27:36,960
thing

516
00:27:36,960 --> 00:27:41,600
I'm going to register a PIM 2 p.m.
interface and now anyone who wants to

517
00:27:41,600 --> 00:27:42,460
log stuff

518
00:27:42,460 --> 00:27:46,470
they can look up my p.m. 2 p.m.
interface and they can go ahead and call

519
00:27:46,470 --> 00:27:47,600
into me and so

520
00:27:47,600 --> 00:27:51,059
although the a although the binaries are

521
00:27:51,059 --> 00:27:55,059
your portable external files they don't
work the same way as like deals on

522
00:27:55,059 --> 00:27:57,570
Windows they don't like imported the
allow that kind of thing

523
00:27:57,570 --> 00:28:01,570
what they do is they have this
well-defined interface the pink

524
00:28:01,570 --> 00:28:05,269
pp eyes where you look up things that
you care about so when you're writing

525
00:28:05,269 --> 00:28:06,240
the code you say

526
00:28:06,240 --> 00:28:10,289
at some point I'm going to need to call
into this interface that's defined in

527
00:28:10,289 --> 00:28:12,169
the UEFI specification for

528
00:28:12,169 --> 00:28:15,980
here is how I find that the logging code
right so I just to look up

529
00:28:15,980 --> 00:28:19,080
logging code I get back a pointer and
now I have a

530
00:28:19,080 --> 00:28:22,210
data structure that I can use to call
function pointers with an echo

531
00:28:22,210 --> 00:28:26,100
so this is going to be a.m. sorta
interesting and

532
00:28:26,100 --> 00:28:29,860
an analogous thing will happen in the
next phase so

533
00:28:29,860 --> 00:28:33,919
there's the registration the PPIs
there's a PI dispatcher so this is the

534
00:28:33,919 --> 00:28:37,299
thing which is basically going to chew
through the firmware file system it's

535
00:28:37,299 --> 00:28:38,230
gonna say okay

536
00:28:38,230 --> 00:28:42,309
I see that there's a dependency
expression NEC expression says

537
00:28:42,309 --> 00:28:46,139
I can't load this module until these
five other modules are loaded so again

538
00:28:46,139 --> 00:28:49,770
doesn't work exactly the same way that
like an importer dress table

539
00:28:49,770 --> 00:28:53,460
poor names table that kinda stuff in
Windows would work there's these files

540
00:28:53,460 --> 00:28:56,520
on the firmware file system that says
here's the prereq for this file

541
00:28:56,520 --> 00:29:00,650
you the dispatcher must go off and put
all these things and run them and now

542
00:29:00,650 --> 00:29:04,220
you can load this so the dispatcher
asked and the logic for them

543
00:29:04,220 --> 00:29:07,970
home and she know it handles the
firmware volumes and

544
00:29:07,970 --> 00:29:11,620
services such as so this is where
there's some core services

545
00:29:11,620 --> 00:29:14,630
within the PI phase such a so that

546
00:29:14,630 --> 00:29:18,850
each I'm so that each p.m. can have an
expectation that it can

547
00:29:18,850 --> 00:29:22,190
find other ppl as it can find other for
more volumes

548
00:29:22,190 --> 00:29:25,210
so this this again is where

549
00:29:25,210 --> 00:29:29,900
so if I pick up the pace will will get
to see at the very end where

550
00:29:29,900 --> 00:29:33,970
I'll you know how code actually uses the
sort of tables but

551
00:29:33,970 --> 00:29:38,090
um this is a data structure that you can
assume like if your reverse engineering

552
00:29:38,090 --> 00:29:38,680
the code

553
00:29:38,680 --> 00:29:42,780
you can say I will expect that this data
structure will be passed into the main

554
00:29:42,780 --> 00:29:47,140
function are given pin module and so
when I see it off said it when I see it

555
00:29:47,140 --> 00:29:47,860
doing you know

556
00:29:47,860 --> 00:29:51,330
pointer arithmetic and I said going okay
this pointer plus

557
00:29:51,330 --> 00:29:55,270
32 okay now I know that that's whatever
it is

558
00:29:55,270 --> 00:29:58,970
plus 32 anode probably be reinstall PPR

559
00:29:58,970 --> 00:30:02,860
so you can start easily figuring out
this mythic meaning

560
00:30:02,860 --> 00:30:07,280
love I'm you know the code sexy
utilization of ocean porous because what

561
00:30:07,280 --> 00:30:08,170
I'll tell you is that

562
00:30:08,170 --> 00:30:12,460
when when you're looking at the code for
these things it looks very much like c

563
00:30:12,460 --> 00:30:14,500
plus plus code and I mean that in the
most

564
00:30:14,500 --> 00:30:18,700
annoying way so see first post code you
know virtual functions things like that

565
00:30:18,700 --> 00:30:20,400
in direction calls through

566
00:30:20,400 --> 00:30:24,440
calls through function pointer tables
that makes it hard to follow control

567
00:30:24,440 --> 00:30:26,410
flow that makes it difficult to

568
00:30:26,410 --> 00:30:29,910
see you know it cross references on a
given function and see everywhere that

569
00:30:29,910 --> 00:30:30,440
it's used

570
00:30:30,440 --> 00:30:33,470
so that sort of interaction is used
extremely much

571
00:30:33,470 --> 00:30:36,590
in all of the PI phases you're always
going to see things

572
00:30:36,590 --> 00:30:39,950
referencing through the sort a function
pointer tables but

573
00:30:39,950 --> 00:30:43,850
at the end of the day with you know some
appropriate you serve

574
00:30:43,850 --> 00:30:47,440
above idea importing of data structures
you can actually

575
00:30:47,440 --> 00:30:48,009
I

576
00:30:48,009 --> 00:30:50,999
it can actually lead to making very
semantically rich

577
00:30:50,999 --> 00:30:56,720
yup silicone so this is how I should
think I'm the PI phase it starts off

578
00:30:56,720 --> 00:31:00,559
you got the dispatcher and then it used
for all of these pins on the firmware

579
00:31:00,559 --> 00:31:01,399
file system

580
00:31:01,399 --> 00:31:04,989
the polls each of them in excuse the
entry point figures out what the

581
00:31:04,989 --> 00:31:06,129
dependencies are

582
00:31:06,129 --> 00:31:11,029
and and does this nice series ultimately
once it's done with all the payments

583
00:31:11,029 --> 00:31:13,169
then it's responsible for finding the

584
00:31:13,169 --> 00:31:17,389
Dixie I P L initial program load rpm so
this is a PM

585
00:31:17,389 --> 00:31:20,849
but it's only job is to kick off the
next phase that the Dixie face

586
00:31:20,849 --> 00:31:27,769
so and let's get that interest time you
can read it later

587
00:31:27,769 --> 00:31:31,669
so um head of blocks then

588
00:31:31,669 --> 00:31:35,539
as the PI dispatcher finds the

589
00:31:35,539 --> 00:31:40,159
the Dixie I P L its job is to take these
hand of blocks well define data

590
00:31:40,159 --> 00:31:40,769
structures

591
00:31:40,769 --> 00:31:44,149
past them into the next phase and then
I'm

592
00:31:44,149 --> 00:31:46,809
the Dixie phase will know where the
memory is it all know where the firmware

593
00:31:46,809 --> 00:31:47,590
volumes are

594
00:31:47,590 --> 00:31:52,619
and so forth so the Dixie phase is
honestly the most interesting face most

595
00:31:52,619 --> 00:31:53,639
the time because

596
00:31:53,639 --> 00:31:57,509
the lot of the stuff that goes on in the
the pin faces just hardware

597
00:31:57,509 --> 00:31:58,899
initialization it's pretty

598
00:31:58,899 --> 00:32:03,059
I wrote it's just you know if you have
this particular chipset you initialize

599
00:32:03,059 --> 00:32:03,759
in this way

600
00:32:03,759 --> 00:32:07,609
the Dixie phases where all the
interesting sorted for secure boot

601
00:32:07,609 --> 00:32:10,320
things and to set up a system management
mode

602
00:32:10,320 --> 00:32:14,759
all of the I love a good juicy bits are
here so

603
00:32:14,759 --> 00:32:19,119
from a high level view it works in a
very the dispatcher within

604
00:32:19,119 --> 00:32:23,460
up Dixie works the same way as the PI
face so

605
00:32:23,460 --> 00:32:27,690
there's sort of 11 mappings between they
just you know at a high level the

606
00:32:27,690 --> 00:32:29,509
structuring of the Dixie Faizan

607
00:32:29,509 --> 00:32:34,830
PI fazer the same so where is indeed NP
I we had Pimms these PI modules

608
00:32:34,830 --> 00:32:40,009
in Dixie phase they're called XE drivers
PI dispatchers just like that exceed its

609
00:32:40,009 --> 00:32:41,249
dispatcher just

610
00:32:41,249 --> 00:32:44,919
goes through the firmware file system in
fines all the things and load them in

611
00:32:44,919 --> 00:32:47,499
order appropriate according to the
dependency expressions

612
00:32:47,499 --> 00:32:52,369
the PP eyes these p.m. 2 p.m. interface
is a way that you register

613
00:32:52,369 --> 00:32:55,999
for other code to be able to find you
and executing invoke your code

614
00:32:55,999 --> 00:33:00,190
that's called a protocol in the Dixie
face if we talk about a Dixie protocol

615
00:33:00,190 --> 00:33:01,260
were saying here's some Co

616
00:33:01,260 --> 00:33:05,730
that I've registered and I let people
look it up and let people calling and

617
00:33:05,730 --> 00:33:06,810
then just like the

618
00:33:06,810 --> 00:33:11,630
the sack or Dave data to PI PI gives
this world find a to the Hobbs

619
00:33:11,630 --> 00:33:16,810
to I'm to the sexy face so if you take
that exact picture and you fill in

620
00:33:16,810 --> 00:33:20,640
Dixie 4 p.m. and dick CIPO for

621
00:33:20,640 --> 00:33:24,940
boo phase up it'll be the exact same
thing

622
00:33:24,940 --> 00:33:27,950
so I was saying that basically um

623
00:33:27,950 --> 00:33:32,870
the there's all these function pointer
tables which are used I guess I didn't

624
00:33:32,870 --> 00:33:37,160
highlight the the red ones last time but
the ones that we sort of care about from

625
00:33:37,160 --> 00:33:39,980
a security perspective and honestly
that's probably not that visible on

626
00:33:39,980 --> 00:33:40,570
their you there

627
00:33:40,570 --> 00:33:43,880
doors we care about our things like
trust and

628
00:33:43,880 --> 00:33:47,100
process for more volume so there's this

629
00:33:47,100 --> 00:33:49,930
there's this data structure the Dixie
service today structure it's going to be

630
00:33:49,930 --> 00:33:50,960
passed into

631
00:33:50,960 --> 00:33:54,470
the main both the Dixie phase code and
it's going to then

632
00:33:54,470 --> 00:33:58,890
that raises going to use these a this
function pointers in order to call

633
00:33:58,890 --> 00:34:02,360
the sort of core Dixie services the
trust phase

634
00:34:02,360 --> 00:34:05,380
also a process for more volume that's
basically

635
00:34:05,380 --> 00:34:08,940
if I'm a taxi driver I'm going to you
know call process for more volume in

636
00:34:08,940 --> 00:34:09,780
order to find

637
00:34:09,780 --> 00:34:12,580
another from where volume in order to
find some other code that I want to load

638
00:34:12,580 --> 00:34:13,169
potentially

639
00:34:13,169 --> 00:34:16,820
and that processing potentially you know
this is just

640
00:34:16,820 --> 00:34:20,240
stuff which is implemented by the Dixie
core processing you know any time

641
00:34:20,240 --> 00:34:20,669
there's

642
00:34:20,669 --> 00:34:26,169
parsing there's a potential for a
exploitable memory conditions parsing

643
00:34:26,169 --> 00:34:30,669
miss mishaps and so that's you know one
obvious place where %uh vulnerabilities

644
00:34:30,669 --> 00:34:31,210
could happen

645
00:34:31,210 --> 00:34:34,500
these are the things they're just you
know I O space memory space access type

646
00:34:34,500 --> 00:34:34,870
thing

647
00:34:34,870 --> 00:34:38,300
and then trust trust is kinda
interesting because it basically says

648
00:34:38,300 --> 00:34:42,050
I'm going to mark this for more volumes
were three information I'm going to mark

649
00:34:42,050 --> 00:34:43,500
this excusable then unloaded

650
00:34:43,500 --> 00:34:46,889
loading as trustworthy and then I can go
ahead and run that

651
00:34:46,889 --> 00:34:50,139
so fundamentally if I me know you if I
rootkit

652
00:34:50,139 --> 00:34:53,419
I can just you know go ahead and hook
into something and call trust on and

653
00:34:53,419 --> 00:34:54,389
then it's going to

654
00:34:54,389 --> 00:34:58,120
just bypass any other additional
additional checks gonna

655
00:34:58,120 --> 00:35:02,710
bypassing the church X and so forth in
addition to the Dixie services table

656
00:35:02,710 --> 00:35:03,920
there's going to be a whole lot of

657
00:35:03,920 --> 00:35:07,640
a function pointers for use within this
past Thursday Dixie services table

658
00:35:07,640 --> 00:35:09,200
there's the boot services table

659
00:35:09,200 --> 00:35:13,230
this has then the install protocol
interface reinstall protocol interface

660
00:35:13,230 --> 00:35:14,420
on install

661
00:35:14,420 --> 00:35:18,650
a protocol these are the things where if
I wanted to say that someone else should

662
00:35:18,650 --> 00:35:21,119
be able to call into my code I will call
install

663
00:35:21,119 --> 00:35:24,579
protocol interface and then someone else
will

664
00:35:24,579 --> 00:35:29,420
a where is it there should be a lookup

665
00:35:29,420 --> 00:35:33,210
lo que protocol somewhere don't think I
highlighted it

666
00:35:33,210 --> 00:35:37,700
but the National Register notify its all
restaurant was interesting because you

667
00:35:37,700 --> 00:35:38,230
can say

668
00:35:38,230 --> 00:35:41,770
I know that I'm going to me this
protocol and call me back whenever you

669
00:35:41,770 --> 00:35:43,119
get around to loading a

670
00:35:43,119 --> 00:35:46,230
Dixie driver that that actually
implements that so you can have call

671
00:35:46,230 --> 00:35:47,040
backs where

672
00:35:47,040 --> 00:35:50,099
later on it it invokes your code once
the

673
00:35:50,099 --> 00:35:53,960
prerequisite code is actually starter
loan imagine start image those are

674
00:35:53,960 --> 00:35:55,609
basically image in this context

675
00:35:55,609 --> 00:35:59,559
is no portable external files this is
loading

676
00:35:59,559 --> 00:36:03,140
actual execute herbal colon so that
starting up to

677
00:36:03,140 --> 00:36:06,910
and open protocol is call into something
else area

678
00:36:06,910 --> 00:36:10,210
lo que perk up so three pages worth a
fortune quarters just in a booth

679
00:36:10,210 --> 00:36:11,200
services table

680
00:36:11,200 --> 00:36:15,540
but something more interesting than
others and finally then there's some

681
00:36:15,540 --> 00:36:18,510
even more function pointers that
available but this one is especially

682
00:36:18,510 --> 00:36:19,549
interesting

683
00:36:19,549 --> 00:36:23,710
because our in a way that was admitted
again

684
00:36:23,710 --> 00:36:27,119
runtime: services table it's something
that

685
00:36:27,119 --> 00:36:30,849
the Dixie phase has access to but this
is something that persists into the

686
00:36:30,849 --> 00:36:32,559
wrong time %uh the operating system

687
00:36:32,559 --> 00:36:36,160
so it's set up during the Dixie face
there's going to be some core Dixie

688
00:36:36,160 --> 00:36:37,569
driver that handles the

689
00:36:37,569 --> 00:36:42,619
I'm handles the back behind the scenes
code for each of these function pointers

690
00:36:42,619 --> 00:36:48,760
but whereas those other tables boot
services table and Dixie services table

691
00:36:48,760 --> 00:36:51,780
those things are sorta gonna go away
once you get past the bootloader they're

692
00:36:51,780 --> 00:36:52,220
sort of

693
00:36:52,220 --> 00:36:56,599
for buyouts use only and then they're
gonna be recycle their memories can be

694
00:36:56,599 --> 00:36:58,540
recycled when we get past the bootloader

695
00:36:58,540 --> 00:37:01,740
to run time: services table sort of
sticks around forever

696
00:37:01,740 --> 00:37:05,740
and this is meant to be some from this
is meant to be sort of an interface

697
00:37:05,740 --> 00:37:09,799
from which the operating system can call
into code that was provided it

698
00:37:09,799 --> 00:37:15,380
to it by the by the from work and so
this is a potential place where

699
00:37:15,380 --> 00:37:18,490
sort of less privileged coda

700
00:37:18,490 --> 00:37:23,390
an operating system can pass information
for processing to more privileged code

701
00:37:23,390 --> 00:37:27,290
the firmware we called for more
privileged because it sets up things

702
00:37:27,290 --> 00:37:27,790
like system

703
00:37:27,790 --> 00:37:32,120
measure mode which can exist behind the
scenes for ever so

704
00:37:32,120 --> 00:37:35,150
from a black at this year we had shown
how

705
00:37:35,150 --> 00:37:39,770
from from Windows 8 it exposes this
runtime services so

706
00:37:39,770 --> 00:37:43,260
although it's called something else
really you're calling it an API which is

707
00:37:43,260 --> 00:37:44,050
really just a

708
00:37:44,050 --> 00:37:47,750
a front and to set variable and update
capsule

709
00:37:47,750 --> 00:37:50,920
so utilizing these

710
00:37:50,920 --> 00:37:54,180
the ability to call into this function
pointers we can sort of stage

711
00:37:54,180 --> 00:37:58,040
information which the BIOS is going to
consuming process upon Expo

712
00:37:58,040 --> 00:38:01,220
and we'd found these exploitable
conditions where

713
00:38:01,220 --> 00:38:05,720
I we could create this update capsule
that has to do with BIOS updates

714
00:38:05,720 --> 00:38:06,670
essentially so

715
00:38:06,670 --> 00:38:10,120
we can create a fake BIOS update for
love non signs but

716
00:38:10,120 --> 00:38:14,300
memory corrupting information create a
fake update reboot the system the bio

717
00:38:14,300 --> 00:38:15,870
says oh I see that you for

718
00:38:15,870 --> 00:38:19,450
you've part you staged a BIOS update for
me I think I'll go ahead and parse that

719
00:38:19,450 --> 00:38:22,580
and then ultimately in the in the
process a person that it'll

720
00:38:22,580 --> 00:38:27,410
a choke and die and the attack roll game
code execution at the very beginning at

721
00:38:27,410 --> 00:38:28,160
the system to

722
00:38:28,160 --> 00:38:31,860
for the set virtual address map is

723
00:38:31,860 --> 00:38:35,370
cervical you know it interesting for
people like me who do with memory

724
00:38:35,370 --> 00:38:36,440
management things like that

725
00:38:36,440 --> 00:38:40,190
basically like the runtime services
table is sort of left around

726
00:38:40,190 --> 00:38:43,970
but they don't really have relocations
per se

727
00:38:43,970 --> 00:38:47,270
in the same way that normal public
schools are relocations and Windows

728
00:38:47,270 --> 00:38:51,460
so when you first want to access runtime
services table from an operating system

729
00:38:51,460 --> 00:38:54,760
you just sort of scanned through memory
find the table based on the signature

730
00:38:54,760 --> 00:38:58,420
hey what you find that you call into
this set virtual address map and then

731
00:38:58,420 --> 00:39:02,340
it's going to sort of do relocations on
wherever the bio stock this in memory

732
00:39:02,340 --> 00:39:06,720
you the operating system or you the
attacker have mapped to this into memory

733
00:39:06,720 --> 00:39:08,550
at some location you're telling the code

734
00:39:08,550 --> 00:39:12,400
have matching a member at this location
to fix yourself up for me for that

735
00:39:12,400 --> 00:39:13,060
policy here

736
00:39:13,060 --> 00:39:17,810
hardcore in constant turmoil at the
right location so and then

737
00:39:17,810 --> 00:39:21,790
even beyond the exploitable update and
there are other things were just the

738
00:39:21,790 --> 00:39:25,180
ability to access you if I for more
variables has a

739
00:39:25,180 --> 00:39:30,809
has allowed for bypassing set variable
if you may be heard of those cases where

740
00:39:30,809 --> 00:39:33,730
you know they were blaming latex at the
time but really it's a firmware problem

741
00:39:33,730 --> 00:39:34,670
but they were saying

742
00:39:34,670 --> 00:39:37,760
you know people in exon the Samsung
laptop it will

743
00:39:37,760 --> 00:39:40,950
brick your system right I was a case
where basically

744
00:39:40,950 --> 00:39:44,730
I'm the latex was using

745
00:39:44,730 --> 00:39:49,420
the you if I non-volatile variables in
order to save logging information at

746
00:39:49,420 --> 00:39:52,319
some point we just sort of exhaust the
space available for

747
00:39:52,319 --> 00:39:56,020
variables and so they were using a set
variable in just filling it with long

748
00:39:56,020 --> 00:39:56,770
information

749
00:39:56,770 --> 00:39:59,770
and then eventually a a biocide choked

750
00:39:59,770 --> 00:40:03,510
the the Samsung or eventually there is a
Lenovo example as well

751
00:40:03,510 --> 00:40:07,609
last just choked on too many variables
from minute refused to do

752
00:40:07,609 --> 00:40:13,160
so in terms over relative magnitude of
Pimms versus Dixie drivers

753
00:40:13,160 --> 00:40:16,290
you can use these for more parsing tools

754
00:40:16,290 --> 00:40:21,400
and you can see that you know if if
there's 65 pins there's 279

755
00:40:21,400 --> 00:40:24,890
a 678 taxi drivers so there's many many
more

756
00:40:24,890 --> 00:40:28,500
taxi drivers they're all like
registering these protocols and talking

757
00:40:28,500 --> 00:40:30,190
amongst themselves and

758
00:40:30,190 --> 00:40:33,630
you know implementing in a potentially
pretty high level things

759
00:40:33,630 --> 00:40:36,690
on will we'll see here at the end again
if I

760
00:40:36,690 --> 00:40:40,549
move faster will see like the names on
some things from which you can't order

761
00:40:40,549 --> 00:40:43,720
in for that they're doing pretty high
level things to do in graphical things

762
00:40:43,720 --> 00:40:44,329
they're doing

763
00:40:44,329 --> 00:40:47,890
there's I don't think there's going to
be a name specifically that you can

764
00:40:47,890 --> 00:40:51,359
call to that but I know that HP at one
point had this

765
00:40:51,359 --> 00:40:55,559
value-add to to allow you to check your
Outlook mail from

766
00:40:55,559 --> 00:40:59,430
the BIOS so like you know goes Splashtop
operating systems where they said look

767
00:40:59,430 --> 00:41:02,339
takes one second to boot and then
they've got like a browser and you've

768
00:41:02,339 --> 00:41:02,700
got

769
00:41:02,700 --> 00:41:06,770
your email and everything else right so
so that's good from sort of a usability

770
00:41:06,770 --> 00:41:08,220
perspective right you can

771
00:41:08,220 --> 00:41:12,630
group to just something quick but that
means there's all that sorta code being

772
00:41:12,630 --> 00:41:14,319
implemented out by us level

773
00:41:14,319 --> 00:41:17,440
up tough problems can be there

774
00:41:17,440 --> 00:41:22,569
so um I've already made reference to the
UEFI non-volatile very both

775
00:41:22,569 --> 00:41:26,059
I'm just and waved over them for until
now because

776
00:41:26,059 --> 00:41:31,230
um basically in your legacy bio says you
have this notion of CMOS her

777
00:41:31,230 --> 00:41:34,849
NVRAM non-volatile RAM that's already
configuration information but that was a

778
00:41:34,849 --> 00:41:36,640
pretty firm has a very limited

779
00:41:36,640 --> 00:41:36,950
amo

780
00:41:36,950 --> 00:41:40,740
space that by spenders would total bit
there in second trick information

781
00:41:40,740 --> 00:41:44,300
in UEFI you have this well-defined

782
00:41:44,300 --> 00:41:48,430
um will data structures cologne
following variables:

783
00:41:48,430 --> 00:41:51,800
and these are stored actually on the
flash chip so there's gonna be some

784
00:41:51,800 --> 00:41:55,100
amount of code in the flesh up and then
there's going to be this data is not all

785
00:41:55,100 --> 00:41:56,100
variables on

786
00:41:56,100 --> 00:42:00,020
flash chip and those are used for
configuration information

787
00:42:00,020 --> 00:42:03,590
already spoke to that Samsung Lenovo
case where

788
00:42:03,590 --> 00:42:07,750
theoretically just fill up the variables
and you can break the system

789
00:42:07,750 --> 00:42:10,760
home and then also there was

790
00:42:10,760 --> 00:42:14,410
there was a these exploitable conditions
in the past

791
00:42:14,410 --> 00:42:19,690
a was so P I'm a touch the variables a
little bit for instance with this

792
00:42:19,690 --> 00:42:22,820
speak my last update was checking for
the presents were born variable and when

793
00:42:22,820 --> 00:42:25,300
it found it then it and start invoking
last update:

794
00:42:25,300 --> 00:42:28,820
but but typically it's the Dixie face
later which utilize them

795
00:42:28,820 --> 00:42:32,220
so this is just to say what sort of
attributes

796
00:42:32,220 --> 00:42:35,970
unfollow variable can have it all fun
inspect so

797
00:42:35,970 --> 00:42:39,370
non-volatile obviously they can all they
can be

798
00:42:39,370 --> 00:42:42,550
they can be volatile but we care about
non-violence

799
00:42:42,550 --> 00:42:46,890
both services access means that it will
be accessed up through boot and that

800
00:42:46,890 --> 00:42:50,540
it shouldn't be accessed thereafter
runtime: access this is the one that we

801
00:42:50,540 --> 00:42:51,120
sort of

802
00:42:51,120 --> 00:42:54,740
care about a lot this means that it's
going to be accessible

803
00:42:54,740 --> 00:42:58,090
later on when the operating systems
running from within that runtime:

804
00:42:58,090 --> 00:42:59,050
services table

805
00:42:59,050 --> 00:43:03,140
hardware record not that interesting
authenticator write access this is

806
00:43:03,140 --> 00:43:04,230
something that not

807
00:43:04,230 --> 00:43:07,800
this and the time based authentication
these are things where it makes it much

808
00:43:07,800 --> 00:43:08,840
stronger than

809
00:43:08,840 --> 00:43:12,570
in the bad old days with CMOS with CMOS
anyone who's colonel can just go to put

810
00:43:12,570 --> 00:43:14,310
all the bits one-third
reverse-engineered

811
00:43:14,310 --> 00:43:17,780
with authenticated non-volatile
variables

812
00:43:17,780 --> 00:43:22,020
they actually have digital signatures
well they don't have their signatures on

813
00:43:22,020 --> 00:43:22,320
them

814
00:43:22,320 --> 00:43:27,010
the gatekeeper the code which implements
the reading and writing to the variables

815
00:43:27,010 --> 00:43:30,230
it will make it so that you cannot write
to this variable

816
00:43:30,230 --> 00:43:35,410
unless you have provided me a digital
signature that actually is signed by the

817
00:43:35,410 --> 00:43:39,160
key of the platform manufacturer signed
by another key that you betta den

818
00:43:39,160 --> 00:43:43,560
um and so it makes it so that anything
that's important can be stored in these

819
00:43:43,560 --> 00:43:45,300
variables and lock down so that

820
00:43:45,300 --> 00:43:49,340
it can't be manipulated by an attacker

821
00:43:49,340 --> 00:43:51,650
um and yeah

822
00:43:51,650 --> 00:43:54,660
so if something's

823
00:43:54,660 --> 00:43:58,240
both runtime: an authenticated that's
you know where you would put your

824
00:43:58,240 --> 00:44:01,980
typical security information but if you
see wrong time and not authenticated

825
00:44:01,980 --> 00:44:05,810
that means it's open to attack a
manipulation and so in the case of the

826
00:44:05,810 --> 00:44:10,640
set a variable stuff this was something
where I just said that the gatekeeper

827
00:44:10,640 --> 00:44:14,420
is the one who does the you know if
you're okay with this is assigned

828
00:44:14,420 --> 00:44:17,400
variable so someone has to check the
digital signatures like who's gonna

829
00:44:17,400 --> 00:44:17,960
check that

830
00:44:17,960 --> 00:44:21,540
well for most implementations that
someone like system ensures modes when

831
00:44:21,540 --> 00:44:23,500
you're calling into the runtime services
table

832
00:44:23,500 --> 00:44:26,950
that shouting into system management
mode code which is in a protected by

833
00:44:26,950 --> 00:44:27,590
virtue

834
00:44:27,590 --> 00:44:32,980
just being in system and remote but then
if you have a misconfigured buy a house

835
00:44:32,980 --> 00:44:34,890
where anyone can writes the flash chip

836
00:44:34,890 --> 00:44:38,310
that means you can completely do an
end-run around the

837
00:44:38,310 --> 00:44:41,710
the gatekeeper their authenticator of
these variables

838
00:44:41,710 --> 00:44:45,410
and are consequently you can just modify
stuff however you want and that was this

839
00:44:45,410 --> 00:44:49,120
up this chart is art attack that we and
presented earlier in the year

840
00:44:49,120 --> 00:44:52,800
so almost to the interesting

841
00:44:52,800 --> 00:44:56,070
things about the the most the

842
00:44:56,070 --> 00:44:59,600
interesting not all variables most
important authenticated non-volatile

843
00:44:59,600 --> 00:45:00,210
variables

844
00:45:00,210 --> 00:45:03,950
are the keys so the key storage in this
was sort of where the

845
00:45:03,950 --> 00:45:08,370
controversy with the Linux things comes
from their part for manufacturers who

846
00:45:08,370 --> 00:45:09,130
are shipping

847
00:45:09,130 --> 00:45:12,410
Windows 8 certified things they're
obviously going to have

848
00:45:12,410 --> 00:45:15,930
Microsoft Windows 8 key in the I in the

849
00:45:15,930 --> 00:45:21,070
in the within the BIOS as one of the
sickies it'll typically

850
00:45:21,070 --> 00:45:24,570
typically be the platform can so

851
00:45:24,570 --> 00:45:28,370
you've got these notions keys that
platform key there's key exchange scheme

852
00:45:28,370 --> 00:45:31,500
there's signature database information
database so we'll start at the bottom

853
00:45:31,500 --> 00:45:33,730
for been database this is a blacklist

854
00:45:33,730 --> 00:45:37,050
I love you if I modules which have been
found to you know potentially upon

855
00:45:37,050 --> 00:45:39,180
abilities and so they can and a black
list and say

856
00:45:39,180 --> 00:45:43,270
don't ever let that signature database
there's a waitlist where

857
00:45:43,270 --> 00:45:46,810
you can just not even have to care about
keying and you can just say I want to

858
00:45:46,810 --> 00:45:48,060
put a whitelist entry in

859
00:45:48,060 --> 00:45:52,740
for my you know bootloader or whatever
and then you can just put a system so

860
00:45:52,740 --> 00:45:56,150
the whole notion that you know you're
somehow being locked out of your Linex

861
00:45:56,150 --> 00:45:59,520
it was as simple as adding a waitlist
key for a boy who are you didn't even

862
00:45:59,520 --> 00:46:00,200
have to do that

863
00:46:00,200 --> 00:46:03,170
whole thing with you know signing with
the Microsoft hear anything like that

864
00:46:03,170 --> 00:46:04,730
they chose to do that

865
00:46:04,730 --> 00:46:08,880
because they were going for the easiest
most least painful way

866
00:46:08,880 --> 00:46:12,240
in order to make make the system but so

867
00:46:12,240 --> 00:46:16,450
but then you know in reality most buses
they're going to give you an ability to

868
00:46:16,450 --> 00:46:18,280
go in at whatever keys you once a week

869
00:46:18,280 --> 00:46:21,500
you they could have said oh you're going
to add a third or key you're gonna at a

870
00:46:21,500 --> 00:46:22,270
red hat ke

871
00:46:22,270 --> 00:46:25,540
but as if you go back and read the the
articles about that

872
00:46:25,540 --> 00:46:28,500
they're saying we evaluated many
different ways are doing this and we

873
00:46:28,500 --> 00:46:30,680
decided that just signing with Microsoft
key

874
00:46:30,680 --> 00:46:34,540
was the least pain for everyone but it
is absolutely possible that they could

875
00:46:34,540 --> 00:46:36,570
have just done it many other ways where

876
00:46:36,570 --> 00:46:42,250
just manually had to you know said a key
for instant russia's I suppose I should

877
00:46:42,250 --> 00:46:42,839
say it well

878
00:46:42,839 --> 00:46:46,170
I should I'll say it later everyone
bottom

879
00:46:46,170 --> 00:46:49,280
but these these kids themselves their
authenticated variables there

880
00:46:49,280 --> 00:46:52,599
they're sorta written into the flash at
manufacturing time there

881
00:46:52,599 --> 00:46:55,980
sign they were they're marked as
authenticated so that you're not

882
00:46:55,980 --> 00:46:58,900
supposed to be able to touch it unless
you actually are so you know

883
00:46:58,900 --> 00:47:02,320
doing the update with Adele key but
again if you can get around

884
00:47:02,320 --> 00:47:07,670
the signature requirements you can
obviously got my father to

885
00:47:07,670 --> 00:47:09,999
do

886
00:47:09,999 --> 00:47:12,359
I could have already said that

887
00:47:12,359 --> 00:47:15,680
1 miscellaneous thing although we
haven't talk about here

888
00:47:15,680 --> 00:47:18,749
there are other protection mechanisms
within the BIOS things like protected

889
00:47:18,749 --> 00:47:20,799
range registered for the chips that can
say

890
00:47:20,799 --> 00:47:24,019
this region of the flash chip is not
writeable and no one should ever be able

891
00:47:24,019 --> 00:47:24,650
to touch in

892
00:47:24,650 --> 00:47:28,789
the thing is those protecting those
other protection mechanisms can never

893
00:47:28,789 --> 00:47:29,460
really be

894
00:47:29,460 --> 00:47:33,259
applied to the you if I know involve
enables the the variables are always

895
00:47:33,259 --> 00:47:34,210
sort of going to be

896
00:47:34,210 --> 00:47:37,720
a little bit vulnerable more honorable
thing not the code itself

897
00:47:37,720 --> 00:47:41,150
because they can't be marked as pure non
writeable

898
00:47:41,150 --> 00:47:45,079
because if their runtime access variable
they need to be a reliable on the fly

899
00:47:45,079 --> 00:47:48,329
so that's sort of an architectural thing
where I

900
00:47:48,329 --> 00:47:52,400
we can potentially get around it I
already mentioned so

901
00:47:52,400 --> 00:47:55,880
dick scene system as remote or best
friends forever

902
00:47:55,880 --> 00:48:01,099
um system and remote is the most
privileged execution domain

903
00:48:01,099 --> 00:48:05,869
on x86 system I wish I would've put in
sort of a Intel manual picture

904
00:48:05,869 --> 00:48:09,630
but I'm just to remind people or

905
00:48:09,630 --> 00:48:13,099
to inform people who are aware of it
right you have your typical Cebu it

906
00:48:13,099 --> 00:48:15,690
reboots into real mode real motive is

907
00:48:15,690 --> 00:48:18,940
your Platt no protections dos

908
00:48:18,940 --> 00:48:22,829
sorta load anybody can access anything
eventually an operating system

909
00:48:22,829 --> 00:48:25,799
your bootloader moves you into
protective overprotective mode gives you

910
00:48:25,799 --> 00:48:26,210
your

911
00:48:26,210 --> 00:48:29,359
ring 0 your ring 3 gives you paging and
things like that

912
00:48:29,359 --> 00:48:33,029
off to the side there's this notion I
love up

913
00:48:33,029 --> 00:48:36,900
system measure mode and it's the biases
responsibility to put code in to a

914
00:48:36,900 --> 00:48:38,960
location that's called system management
RAM

915
00:48:38,960 --> 00:48:43,150
and then it's going to lock down that
ramp so that basically SMM code

916
00:48:43,150 --> 00:48:47,079
can execute without interference from an
operating system and it sorta execute

917
00:48:47,079 --> 00:48:47,650
upon

918
00:48:47,650 --> 00:48:51,630
just management interrupt so Dixie phase
is the one who's responsible for

919
00:48:51,630 --> 00:48:52,269
actually

920
00:48:52,269 --> 00:48:55,309
instantiating SMM code as some code I

921
00:48:55,309 --> 00:48:59,489
I should put it on here should put a
nice little a people attacker SMM

922
00:48:59,489 --> 00:49:03,739
is almost always to the attackers
benefit over

923
00:49:03,739 --> 00:49:07,390
the defenders benefit because it's an
architectural place you know

924
00:49:07,390 --> 00:49:11,670
think the way it was put is Intel
created SMM to allow for confidentiality

925
00:49:11,670 --> 00:49:14,660
and integrity in those sound like good
things that are nice right

926
00:49:14,660 --> 00:49:17,829
but unfortunately it's not your
confidentiality integrity it's the

927
00:49:17,829 --> 00:49:20,750
platform manufacturers confidentiality
and integrity

928
00:49:20,750 --> 00:49:25,570
so just the way it works is you the
platform manufacture the bias maker they

929
00:49:25,570 --> 00:49:26,570
put code in there

930
00:49:26,570 --> 00:49:29,720
and the Mako gets locked down gets to
run in the background for ever and you

931
00:49:29,720 --> 00:49:31,700
don't get to ever inspected at runtime

932
00:49:31,700 --> 00:49:35,180
so asylum is sort of the ultimate place
to hide

933
00:49:35,180 --> 00:49:38,950
if you look at a black hat like at USA
talk from earlier in the year we showed

934
00:49:38,950 --> 00:49:40,730
you know we just said here's a
proof-of-concept

935
00:49:40,730 --> 00:49:44,160
here's a flag in the ground shares in
SMM attacker here's what they could look

936
00:49:44,160 --> 00:49:44,670
like

937
00:49:44,670 --> 00:49:47,700
and you know security vendors can't find
this then they shouldn't

938
00:49:47,700 --> 00:49:50,980
pretend to be giving a security so SMM a
sort of the

939
00:49:50,980 --> 00:49:54,550
it in the Dixie face so if you break
into the system at the Dixie phase or

940
00:49:54,550 --> 00:49:55,480
before and then

941
00:49:55,480 --> 00:49:58,990
you should be able to compromise as a
man have this code

942
00:49:58,990 --> 00:50:02,540
that invisible running in the background
capable of supporting everything forever

943
00:50:02,540 --> 00:50:06,570
right now both

944
00:50:06,570 --> 00:50:09,640
to boot device selection phase this is
just the sort of very a

945
00:50:09,640 --> 00:50:15,170
short short of intermediate phase it's
going to be a single txt file so when

946
00:50:15,170 --> 00:50:19,050
Dixie passes after the BDS phase it's
going to be some file that

947
00:50:19,050 --> 00:50:22,850
handles selection of are going to boot
from a CD year gonna move from a hard

948
00:50:22,850 --> 00:50:23,500
drive

949
00:50:23,500 --> 00:50:26,810
bootloader the kind of thing and

950
00:50:26,810 --> 00:50:30,350
insides are gonna go for next know it
should be sort of

951
00:50:30,350 --> 00:50:33,640
if this is a boot manager if this is
determining where we're going to boot it

952
00:50:33,640 --> 00:50:34,750
should be clear that

953
00:50:34,750 --> 00:50:39,180
basically by this time a boot file
system access and

954
00:50:39,180 --> 00:50:42,440
you know potentially network access if
your gonna do a network boot

955
00:50:42,440 --> 00:50:45,730
are all set up and so the Dixie face has
created all of these

956
00:50:45,730 --> 00:50:49,260
is nice interface is these abilities all
these obstruction layers

957
00:50:49,260 --> 00:50:52,760
for the BDS doesn't have to know how to
access no

958
00:50:52,760 --> 00:50:56,480
fat verses and tear NTFS or anything
else

959
00:50:56,480 --> 00:51:01,880
this you if i interface get set up and
it is allows you to just call into

960
00:51:01,880 --> 00:51:05,680
I'm call into API's which handle all the
obstruction for you and that's why

961
00:51:05,680 --> 00:51:06,820
they're so many Dixie

962
00:51:06,820 --> 00:51:10,910
drivers they're supposed to set
everything up for eventually the butler

963
00:51:10,910 --> 00:51:14,610
for the one thing I want to highlight in
the picture here is that when we talk

964
00:51:14,610 --> 00:51:17,050
about you if I and it sort of hidden in
this picture

965
00:51:17,050 --> 00:51:21,280
the unified interface is basically a
thing for the bootloader and you know

966
00:51:21,280 --> 00:51:22,790
this other stuff for the next phase

967
00:51:22,790 --> 00:51:26,850
this is the interface by which stuff can
call in

968
00:51:26,850 --> 00:51:30,829
and have all these obstructions pre-made
for it

969
00:51:30,829 --> 00:51:33,919
and the runtime interfaces down here as
well and that will persist forever

970
00:51:33,919 --> 00:51:34,849
where's the

971
00:51:34,849 --> 00:51:39,609
you if i interface will go away
eventually first dip

972
00:51:39,609 --> 00:51:43,009
so trendy load phase this is kinda
interesting because

973
00:51:43,009 --> 00:51:46,179
arm you can have transient OS

974
00:51:46,179 --> 00:51:50,569
absent applications running and so this
is one thing that potentially works well

975
00:51:50,569 --> 00:51:51,819
for us as a security

976
00:51:51,819 --> 00:51:56,239
as a defender you can say okay well I'm
going to do my system and I'm going to

977
00:51:56,239 --> 00:51:59,209
start up an application that actually
you know checks reads into the you if i

978
00:51:59,209 --> 00:51:59,829
interface

979
00:51:59,829 --> 00:52:03,749
does evaluations whether or not though
system calls are hooked on that kind of

980
00:52:03,749 --> 00:52:04,069
thing

981
00:52:04,069 --> 00:52:07,299
arm but even at this phase we have

982
00:52:07,299 --> 00:52:11,549
it to denies unsigned applications so if
you want to do this you either have to

983
00:52:11,549 --> 00:52:13,009
wait list your applications

984
00:52:13,009 --> 00:52:16,719
where you have to sign it with what his
platform keys console

985
00:52:16,719 --> 00:52:20,679
there had been you're extremely lame
talks about you look at me I'm a UEFI

986
00:52:20,679 --> 00:52:21,329
boot kit

987
00:52:21,329 --> 00:52:25,239
except one of the main reasons unifies
even being used as because I've secure

988
00:52:25,239 --> 00:52:27,019
boot pit stop things that are unsigned

989
00:52:27,019 --> 00:52:30,589
yes you can make a bouquet if that
signature verification is off

990
00:52:30,589 --> 00:52:35,869
but that sort of his stupid so there'd
been very stalks there been

991
00:52:35,869 --> 00:52:39,059
typical boot kit third bindle kids
running from you if I

992
00:52:39,059 --> 00:52:44,199
I'll from option runs and things like
that and if this is the general point to

993
00:52:44,199 --> 00:52:45,519
boot kit we know that like

994
00:52:45,519 --> 00:52:49,309
there's a standard methodology for big
kids they start early in the system

995
00:52:49,309 --> 00:52:52,249
but really they can't just live there
they have to sort a bounce their way

996
00:52:52,249 --> 00:52:56,139
down into operating systems corrupted
data structures turn of security that

997
00:52:56,139 --> 00:52:56,759
kind of thing

998
00:52:56,759 --> 00:53:00,199
that's the sort of standard methodology
and you know

999
00:53:00,199 --> 00:53:04,659
this trip transient application North
Africa OS absent application

1000
00:53:04,659 --> 00:53:09,029
gives us this ability that we can run
security tools early pre boot

1001
00:53:09,029 --> 00:53:13,159
Intl evaluate and assess something about
to the you if I

1002
00:53:13,159 --> 00:53:16,769
interface as well as the operating
system now this doesn't help us at all

1003
00:53:16,769 --> 00:53:20,139
the tact as a member attackers and
things like that but it does help us to

1004
00:53:20,139 --> 00:53:20,899
techno

1005
00:53:20,899 --> 00:53:23,929
trivial typical a function pointer
hooking

1006
00:53:23,929 --> 00:53:27,869
your typical rootkit type techniques

1007
00:53:27,869 --> 00:53:30,410
alright then there's the runtime phase
and basically im

1008
00:53:30,410 --> 00:53:34,510
at some point when the bootloader is
done it's going to call exit food

1009
00:53:34,510 --> 00:53:35,290
services

1010
00:53:35,290 --> 00:53:39,200
that's an API within the you if I
suspect you call that API and it

1011
00:53:39,200 --> 00:53:42,390
basically says okay anything that is not
marked as runtime

1012
00:53:42,390 --> 00:53:46,570
accessible memory will now be recycled
thrown away and only the runtime

1013
00:53:46,570 --> 00:53:47,700
interface should

1014
00:53:47,700 --> 00:53:50,760
should maintain then there's a

1015
00:53:50,760 --> 00:53:54,079
afterlife race which in reality is one
of those things where they specify they

1016
00:53:54,079 --> 00:53:56,030
say maybe someone will use the someday

1017
00:53:56,030 --> 00:53:59,230
but as far as we know right now
nothing's using it notionally you could

1018
00:53:59,230 --> 00:54:01,690
think a bit like the system's going to
go down you would like to have a

1019
00:54:01,690 --> 00:54:03,040
graceful way to maybe

1020
00:54:03,040 --> 00:54:07,730
clean up some information that the BIOS
stored in memory alright so where to

1021
00:54:07,730 --> 00:54:09,240
secure will come into all this

1022
00:54:09,240 --> 00:54:12,690
I'm just but through all those phases
quick so

1023
00:54:12,690 --> 00:54:16,079
secure boots job is to basically make it
so that I'm

1024
00:54:16,079 --> 00:54:20,700
you know you Yahoo why did Microsoft
require secure right

1025
00:54:20,700 --> 00:54:25,160
well because Microsoft is having their
lunch eaten by having both kids

1026
00:54:25,160 --> 00:54:28,800
which can turn off all the security
right it should be obvious that like

1027
00:54:28,800 --> 00:54:32,300
there's no architectural way that you
can protect any operating system Windows

1028
00:54:32,300 --> 00:54:33,740
or Linux or Mac

1029
00:54:33,740 --> 00:54:37,220
unless you have some security pre-book
workers if the bootloader

1030
00:54:37,220 --> 00:54:40,579
successful the boiler can be overwritten
you can compromise anything in the

1031
00:54:40,579 --> 00:54:41,440
operating system

1032
00:54:41,440 --> 00:54:45,359
writes what they're trying to do is pull
back the security to earlier make it so

1033
00:54:45,359 --> 00:54:47,560
that if you want to attack and you have
to go

1034
00:54:47,560 --> 00:54:51,180
as deep as possible and turn we know
that most attackers don't do that

1035
00:54:51,180 --> 00:54:55,220
so the point is to pull the signature
checking back so that

1036
00:54:55,220 --> 00:54:58,670
you can say this is the bootloader than
expected to run and this is the firmware

1037
00:54:58,670 --> 00:54:59,859
that expected to run

1038
00:54:59,859 --> 00:55:02,890
and so I'm going to reuse some Intel

1039
00:55:02,890 --> 00:55:06,359
group lines because I think they show
that the best way

1040
00:55:06,359 --> 00:55:09,670
so the first thing is that

1041
00:55:09,670 --> 00:55:14,300
for more signing its evaluated typically
unfortunately it's a value-added knots

1042
00:55:14,300 --> 00:55:16,079
or about every Boone up by hardware

1043
00:55:16,079 --> 00:55:19,980
not in sort of a architecturally secure
way it's a value added at the time that

1044
00:55:19,980 --> 00:55:22,230
you're about to write something to the
flash chip

1045
00:55:22,230 --> 00:55:25,470
so maybe the existing bias checks it or
heaven forbid

1046
00:55:25,470 --> 00:55:29,530
just you know and application within the
operating system checks in some vendors

1047
00:55:29,530 --> 00:55:30,090
have done that

1048
00:55:30,090 --> 00:55:34,060
at some point but the idea would be the
existing biases their

1049
00:55:34,060 --> 00:55:37,350
it was written it was unknown clean
version at the time it left the plate

1050
00:55:37,350 --> 00:55:41,980
the by a spender checks the digital
signature on an update that's about to

1051
00:55:41,980 --> 00:55:44,760
be written to the flash chips and then
it just left the entire thing onto the

1052
00:55:44,760 --> 00:55:45,480
flash chip

1053
00:55:45,480 --> 00:55:50,070
other thing here is if you can get onto
the question because there will be no

1054
00:55:50,070 --> 00:55:50,900
subsequent

1055
00:55:50,900 --> 00:55:55,080
checks that means you can you know
always subvert the secure boot

1056
00:55:55,080 --> 00:55:58,230
right from the very beginning because it
doesn't check it every time just checked

1057
00:55:58,230 --> 00:55:59,570
that at the time that it's written

1058
00:55:59,570 --> 00:56:04,500
so you know angel here would say well
you know that's unnecessary performance

1059
00:56:04,500 --> 00:56:06,370
optimization that kind of thing but

1060
00:56:06,370 --> 00:56:11,150
tell it is what it is so then once you
have this

1061
00:56:11,150 --> 00:56:14,740
notionally just presume to trusted
content for the flash chip

1062
00:56:14,740 --> 00:56:18,590
that code can then actually check if you
have other applications other

1063
00:56:18,590 --> 00:56:19,500
bootloaders

1064
00:56:19,500 --> 00:56:22,720
other you know option runs that are
signed you can check the digital

1065
00:56:22,720 --> 00:56:24,710
signatures on those each time so that

1066
00:56:24,710 --> 00:56:28,040
these things coming in from left
trustworthy sources can actually be

1067
00:56:28,040 --> 00:56:29,030
evaluated to

1068
00:56:29,030 --> 00:56:32,980
to determine whether or not there
manipulated and ultimately Windows 8

1069
00:56:32,980 --> 00:56:33,790
secure boot

1070
00:56:33,790 --> 00:56:36,840
nests on top of you if I and the then
start

1071
00:56:36,840 --> 00:56:40,230
you know checking their operating system
loader itself so the

1072
00:56:40,230 --> 00:56:43,830
you if I boot loader is checked by sort
of the the bias itself but then the

1073
00:56:43,830 --> 00:56:45,370
bootloader has been checked it's been

1074
00:56:45,370 --> 00:56:48,650
confirmed to be signed and then it can
pass to an operating sys

1075
00:56:48,650 --> 00:56:52,530
system specific bootloader alright

1076
00:56:52,530 --> 00:56:57,460
so the good thing about secure boot is
that as I said it sort of the only way

1077
00:56:57,460 --> 00:57:01,300
that you you have to pull the security
checks back to an earlier phase in order

1078
00:57:01,300 --> 00:57:03,270
to not have the operating systems P just

1079
00:57:03,270 --> 00:57:07,390
architecturally sober double but this
works in attackers benefit as well

1080
00:57:07,390 --> 00:57:08,320
because

1081
00:57:08,320 --> 00:57:11,560
um you're going to assume that the BIOS
is secure

1082
00:57:11,560 --> 00:57:14,800
and then you're going to say well secure
boot protecting me and then I don't need

1083
00:57:14,800 --> 00:57:16,160
to go check my by Osram

1084
00:57:16,160 --> 00:57:19,500
so like I from running a little late but

1085
00:57:19,500 --> 00:57:23,770
fast enough that I can show you
something real here so now we're going

1086
00:57:23,770 --> 00:57:24,460
to

1087
00:57:24,460 --> 00:57:28,310
pullback look at some of the type of
information that's that's a and

1088
00:57:28,310 --> 00:57:32,160
that's put on the firmware file system
and you know give you a sense for now

1089
00:57:32,160 --> 00:57:32,970
that we know

1090
00:57:32,970 --> 00:57:34,599
these phases and what's in them

1091
00:57:34,599 --> 00:57:37,819
that kind of thing I'm know we can

1092
00:57:37,819 --> 00:57:41,430
see what kinda stuff is all mixed
together here in the flash chip

1093
00:57:41,430 --> 00:57:48,430
bias analysis for the detection advanced
system to version that's our project

1094
00:57:49,440 --> 00:57:52,920
I was gonna pick

1095
00:57:52,920 --> 00:57:56,880
a random BIOS and that's what happens
when you pick random bus this

1096
00:57:56,880 --> 00:58:03,739
mostly whether it works though nope
think the x1 works

1097
00:58:03,739 --> 00:58:10,450
no

1098
00:58:10,450 --> 00:58:14,670
alright so I'm in a zoo means that
things will actually be visible to you

1099
00:58:14,670 --> 00:58:18,410
but right this is some examples above

1100
00:58:18,410 --> 00:58:22,900
what kinda stuff we see down at the bus
level just if I'm attacker I'm a

1101
00:58:22,900 --> 00:58:23,550
defender

1102
00:58:23,550 --> 00:58:29,010
way which one is 10 ago sorry for the
pixelation but there's our dicks remains

1103
00:58:29,010 --> 00:58:30,910
that's gonna be the first Co that
actually execute

1104
00:58:30,910 --> 00:58:35,170
then we have things like system runtime
Dixie SystemVerilog Dixie

1105
00:58:35,170 --> 00:58:40,550
clash verify SMM okay if I'm an attacker
and I want to server SMM maybe if I

1106
00:58:40,550 --> 00:58:43,020
subvert the flash verify SMM I'm going
to

1107
00:58:43,020 --> 00:58:46,210
just for free be able to get in there
CMOS access Rex

1108
00:58:46,210 --> 00:58:50,050
as a man CMOS access from Dixie %uh
system variable

1109
00:58:50,050 --> 00:58:53,310
from SMM but I counters so

1110
00:58:53,310 --> 00:58:57,460
basically if I'm attacker I go through
here and I say okay what am I trying to

1111
00:58:57,460 --> 00:58:58,850
attack today USB

1112
00:58:58,850 --> 00:59:02,850
network access keyboard controller and I
just have these nice

1113
00:59:02,850 --> 00:59:06,550
well named human-readable names where I
can sort of get

1114
00:59:06,550 --> 00:59:10,020
a shortcut to access whatever I want to
compromise

1115
00:59:10,020 --> 00:59:13,200
but this works for us as defenders
because when we go out and we do you

1116
00:59:13,200 --> 00:59:13,540
know

1117
00:59:13,540 --> 00:59:17,550
slice the spice apart do hashing on each
of these for my clean version in my

1118
00:59:17,550 --> 00:59:18,390
dirty version

1119
00:59:18,390 --> 00:59:22,450
I'm I can tell you specifically that you
know you had a modification in here

1120
00:59:22,450 --> 00:59:26,310
I can pull out the specific portable
excusable file and I can partially

1121
00:59:26,310 --> 00:59:27,540
tatters and I can

1122
00:59:27,540 --> 00:59:31,740
I get additional information so

1123
00:59:31,740 --> 00:59:35,710
as expected to be going lower but um

1124
00:59:35,710 --> 00:59:39,150
war couple last things sub-zero diyo

1125
00:59:39,150 --> 00:59:42,890
I'm not promoting gonna bother for full
screen it in cuz I feel like it's gonna

1126
00:59:42,890 --> 00:59:43,340
crash

1127
00:59:43,340 --> 00:59:46,720
sub-zero to i/o is a website

1128
00:59:46,720 --> 00:59:50,210
where Ted Reed has taken his you if I
for more parser

1129
00:59:50,210 --> 00:59:53,900
and he's made it I like this sometimes
when I'm on a machine where

1130
00:59:53,900 --> 00:59:57,500
I do want to install the paper I'm
prerequisite to get everything compiled

1131
00:59:57,500 --> 01:00:01,290
I just like throw up for something into
subzero that I O and that'll actually

1132
01:00:01,290 --> 01:00:02,340
parse the BIOS

1133
01:00:02,340 --> 01:00:06,390
it'll pull out some other metadata and
as irv a couple days ago

1134
01:00:06,390 --> 01:00:09,790
he's also started taking the matter can
purchase output about whether or not

1135
01:00:09,790 --> 01:00:11,040
your biases notable

1136
01:00:11,040 --> 01:00:14,800
and he's put that up there as well so
basically we're

1137
01:00:14,800 --> 01:00:17,650
we're starting to work with them on the
Site and its gonna be basically way to

1138
01:00:17,650 --> 01:00:20,990
crowdsource a determination of okay with
a hundred different people have

1139
01:00:20,990 --> 01:00:21,810
submitted a

1140
01:00:21,810 --> 01:00:25,590
you know Lenovo x1 carbon at basra
vision 2.56

1141
01:00:25,590 --> 01:00:30,120
there can say well 99 if those guys said
that

1142
01:00:30,120 --> 01:00:33,770
the hash for this particular thing was
this particular value but

1143
01:00:33,770 --> 01:00:37,490
one person is an old iron one person has
a different hashed and everybody else

1144
01:00:37,490 --> 01:00:37,960
also

1145
01:00:37,960 --> 01:00:41,590
we can start you know pulling some
notion of what's good and what's bad

1146
01:00:41,590 --> 01:00:45,220
so you can go check out that site
sub-zero that I O

1147
01:00:45,220 --> 01:00:48,780
it has the ability to produce reports up
there as well

1148
01:00:48,780 --> 01:00:53,210
in the next day or two will be taking
will be reborn link apprentice with a

1149
01:00:53,210 --> 01:00:56,280
little script where you run to purchase
a dumpster by also tells you you know

1150
01:00:56,280 --> 01:00:57,280
you're gonna wear not

1151
01:00:57,280 --> 01:01:00,540
which can also just the had a little
script that awesome it up so we can

1152
01:01:00,540 --> 01:01:01,090
start

1153
01:01:01,090 --> 01:01:04,400
getting that crowdsource notion up for
by a screen or not

1154
01:01:04,400 --> 01:01:08,780
what sub-zero doubt I O can't do right
now is the bio stuffed up I which comes

1155
01:01:08,780 --> 01:01:11,310
with practice the actual integrity
checking up here's a

1156
01:01:11,310 --> 01:01:16,090
clean version here's a 30 version they
still have to do that manually

1157
01:01:16,090 --> 01:01:20,420
and I figured I wouldn't have enough
time for this but

1158
01:01:20,420 --> 01:01:24,940
if you go grab the slide later you can
look at a fifteen minute video where I'm

1159
01:01:24,940 --> 01:01:27,760
sort of going through the process and
saying here's my clean version is one

1160
01:01:27,760 --> 01:01:28,360
dirty version

1161
01:01:28,360 --> 01:01:32,280
run by a staff hey there's a change let
me look at the raw change in by its let

1162
01:01:32,280 --> 01:01:34,810
me pull the to ePub files parliament I
to

1163
01:01:34,810 --> 01:01:39,170
a you know analyze them and most
importantly use those data structures

1164
01:01:39,170 --> 01:01:41,680
that exist and are already well
understood from

1165
01:01:41,680 --> 01:01:45,990
the you if I spec very very nice
capability with an idea to import

1166
01:01:45,990 --> 01:01:49,880
header files just standard C header
files and then apply those data

1167
01:01:49,880 --> 01:01:50,970
structures to

1168
01:01:50,970 --> 01:01:55,340
the BIOS and then that makes its that
when you use I X rays in order to

1169
01:01:55,340 --> 01:01:58,520
decompile stuff it makes for very human
readable code

1170
01:01:58,520 --> 01:02:03,570
for some value human readable so in
conclusion how what you decide who the

1171
01:02:03,570 --> 01:02:08,090
with the angel is and who the victim is
here but the angel said unto him

1172
01:02:08,090 --> 01:02:11,670
you if I said it to him stop hitting
yourself stop hitting yourself

1173
01:02:11,670 --> 01:02:17,110
so you if I brings a improvements for
Bhutan security

1174
01:02:17,110 --> 01:02:22,030
so that I you have some ability art
actually to actually get rid of

1175
01:02:22,030 --> 01:02:25,400
I'm these booth level attackers who are
just completely subverting

1176
01:02:25,400 --> 01:02:29,060
operating systems otherwise um think a
purchase

1177
01:02:29,060 --> 01:02:33,040
has made it so that we have a too low
its freely available you can use corn

1178
01:02:33,040 --> 01:02:33,990
download it run it

1179
01:02:33,990 --> 01:02:38,390
you can start having some notion that
whether or not your system is notable

1180
01:02:38,390 --> 01:02:42,090
because for many years people would do
by us attack talks inmates a

1181
01:02:42,090 --> 01:02:46,120
well as some members vote a belief this
bit is not set and you ask them what are

1182
01:02:46,120 --> 01:02:49,630
you gonna release a tool that checks
that bit so like I know whether or not

1183
01:02:49,630 --> 01:02:52,120
they say no no that's so easy you just
do it yourself

1184
01:02:52,120 --> 01:02:56,300
welcome prick is now has combined all
the information that is currently known

1185
01:02:56,300 --> 01:02:59,660
about bias water bill is whether they're
exploitable vulnerabilities or whether

1186
01:02:59,660 --> 01:03:01,150
they're just miss configurations

1187
01:03:01,150 --> 01:03:05,690
and it gives us this ability to dump the
BIOS compared against other things so

1188
01:03:05,690 --> 01:03:08,940
we know actually have this my
standardize way if we tried to do this

1189
01:03:08,940 --> 01:03:10,160
for the legacy by SS

1190
01:03:10,160 --> 01:03:13,800
we would run into this whole quagmire of
how do we decompress I love the random

1191
01:03:13,800 --> 01:03:14,380
formats

1192
01:03:14,380 --> 01:03:17,530
so that's why it only supports you
refine your stuff for now

1193
01:03:17,530 --> 01:03:20,720
bone and that's going to be a

1194
01:03:20,720 --> 01:03:24,200
so with that I'll take any questions

1195
01:03:24,200 --> 01:03:27,890
out to the side have two words let
people get to reflect Speaker I saw the

1196
01:03:27,890 --> 01:03:28,970
next talk earlier

1197
01:03:28,970 --> 01:03:32,950
so I i think you should check out a
false talk next but

1198
01:03:32,950 --> 01:03:39,950
they what else you're free to go thanks

1199
01:03:42,940 --> 01:03:43,190
up

