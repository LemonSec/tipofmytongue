1
00:00:01,180 --> 00:00:14,719
[Music]

2
00:00:16,239 --> 00:00:17,680
hello everyone

3
00:00:17,680 --> 00:00:20,720
welcome to our talk i'm leo

4
00:00:20,720 --> 00:00:23,760
from tungsten security shower lab

5
00:00:23,760 --> 00:00:27,119
now i am my colleague user kai will

6
00:00:27,119 --> 00:00:29,760
share our research on different behavior

7
00:00:29,760 --> 00:00:31,359
optimizations

8
00:00:31,359 --> 00:00:34,480
in lvm

9
00:00:35,280 --> 00:00:38,079
we are researchers from tencent security

10
00:00:38,079 --> 00:00:39,360
shelf lab

11
00:00:39,360 --> 00:00:42,000
to better understand the right landscape

12
00:00:42,000 --> 00:00:42,879
and protect

13
00:00:42,879 --> 00:00:46,559
our user data and infrastructure our lab

14
00:00:46,559 --> 00:00:47,039
focus

15
00:00:47,039 --> 00:00:50,239
on applied research in both software and

16
00:00:50,239 --> 00:00:51,600
software

17
00:00:51,600 --> 00:00:56,840
this work is conducted by usakai the way

18
00:00:56,840 --> 00:00:59,840
myanmar all of us are members of

19
00:00:59,840 --> 00:01:02,079
foundational security search team

20
00:01:02,079 --> 00:01:05,920
intensive security shangri-la

21
00:01:06,159 --> 00:01:10,159
okay let's start here is a quiz

22
00:01:10,159 --> 00:01:12,479
the read function cause the internal

23
00:01:12,479 --> 00:01:13,439
rate function

24
00:01:13,439 --> 00:01:17,758
to get the content of the internal array

25
00:01:17,840 --> 00:01:20,640
there is an array bond check in function

26
00:01:20,640 --> 00:01:22,880
internal read

27
00:01:22,880 --> 00:01:26,000
a known point will be returned if

28
00:01:26,000 --> 00:01:28,880
the bond check failed but the rate

29
00:01:28,880 --> 00:01:29,600
function

30
00:01:29,600 --> 00:01:32,240
doesn't check the return value of

31
00:01:32,240 --> 00:01:34,320
internal rate function

32
00:01:34,320 --> 00:01:37,280
it should trigger a non-point reference

33
00:01:37,280 --> 00:01:38,799
on event behavior

34
00:01:38,799 --> 00:01:42,799
if we try to read out about

35
00:01:43,200 --> 00:01:46,479
now we compiled a program with clan

36
00:01:46,479 --> 00:01:49,680
and they crashed as expected

37
00:01:49,680 --> 00:01:52,399
however if we compile the same program

38
00:01:52,399 --> 00:01:52,799
with

39
00:01:52,799 --> 00:01:56,240
high optimization level

40
00:01:56,240 --> 00:02:01,759
surprisingly the program will not crash

41
00:02:01,920 --> 00:02:04,960
and were even offered an auto boundary

42
00:02:04,960 --> 00:02:09,119
result what happened

43
00:02:09,119 --> 00:02:11,840
to better understand it let's enter a

44
00:02:11,840 --> 00:02:12,400
world

45
00:02:12,400 --> 00:02:15,599
of undefined behavior and see the magic

46
00:02:15,599 --> 00:02:18,560
of airbn

47
00:02:20,640 --> 00:02:23,360
era's talk we will first introduce

48
00:02:23,360 --> 00:02:24,239
backgrounds

49
00:02:24,239 --> 00:02:27,520
of undefined behavior in rvn

50
00:02:27,520 --> 00:02:30,640
then we will discuss how to detect

51
00:02:30,640 --> 00:02:33,680
uneven behavior and analyze and

52
00:02:33,680 --> 00:02:36,959
analyze some of the bugs we found

53
00:02:36,959 --> 00:02:39,840
we will demonstrate our exploit on

54
00:02:39,840 --> 00:02:40,800
chromium

55
00:02:40,800 --> 00:02:43,200
using a non-pointy reference undefined

56
00:02:43,200 --> 00:02:44,720
behavior bug

57
00:02:44,720 --> 00:02:47,440
at last we'll give our suggestions and

58
00:02:47,440 --> 00:02:51,200
make a conclusion

59
00:02:51,200 --> 00:02:54,239
what's undefined behavior according to

60
00:02:54,239 --> 00:02:55,680
the c standard

61
00:02:55,680 --> 00:02:59,280
its behavior upon use of non-portable

62
00:02:59,280 --> 00:03:02,640
or inaudible program construct or

63
00:03:02,640 --> 00:03:06,720
uranium state the standard imposes

64
00:03:06,720 --> 00:03:11,200
no requirements for undefined behavior

65
00:03:11,519 --> 00:03:14,480
the c and c plus class has a lots of

66
00:03:14,480 --> 00:03:16,480
unifying behavior

67
00:03:16,480 --> 00:03:19,519
true hunger 211 different behaviors

68
00:03:19,519 --> 00:03:23,599
appear in c 17 standard

69
00:03:23,599 --> 00:03:26,239
and more new undefined behaviors will be

70
00:03:26,239 --> 00:03:27,519
added

71
00:03:27,519 --> 00:03:32,239
in the near future

72
00:03:32,239 --> 00:03:35,280
here are some common undefined behaviors

73
00:03:35,280 --> 00:03:38,319
such as non-pointed reference

74
00:03:38,319 --> 00:03:41,360
divided by zero array index

75
00:03:41,360 --> 00:03:45,360
other boundary excess oversized shift

76
00:03:45,360 --> 00:03:48,480
initialized usage spine injury

77
00:03:48,480 --> 00:03:52,720
flow most of them are typical security

78
00:03:52,720 --> 00:03:55,200
issues

79
00:03:56,080 --> 00:04:00,319
what is lvm airbn is a popular

80
00:04:00,319 --> 00:04:03,760
compiler infrastructure it provides

81
00:04:03,760 --> 00:04:07,040
look language independent and

82
00:04:07,040 --> 00:04:10,360
talking independent intermediate per

83
00:04:10,360 --> 00:04:13,200
representations it gives us

84
00:04:13,200 --> 00:04:16,040
high quality libraries including

85
00:04:16,040 --> 00:04:18,000
optimizations

86
00:04:18,000 --> 00:04:21,040
analysis code generators

87
00:04:21,040 --> 00:04:24,800
profiling and debugging

88
00:04:24,800 --> 00:04:27,280
most of us may be more familiar with

89
00:04:27,280 --> 00:04:28,800
their support

90
00:04:28,800 --> 00:04:32,160
some project products such as clan

91
00:04:32,160 --> 00:04:35,360
the lvm nation compiler it

92
00:04:35,360 --> 00:04:38,320
builds a large number of products

93
00:04:38,320 --> 00:04:40,240
including chromium

94
00:04:40,240 --> 00:04:45,680
firefox android framework and rs kernel

95
00:04:46,080 --> 00:04:49,360
the rvm also has undefined behaviors

96
00:04:49,360 --> 00:04:52,160
they form into three categories first of

97
00:04:52,160 --> 00:04:52,800
them

98
00:04:52,800 --> 00:04:55,360
are true undefined behavior it

99
00:04:55,360 --> 00:04:56,160
represents

100
00:04:56,160 --> 00:04:59,360
serious errors like dividing by zero or

101
00:04:59,360 --> 00:05:01,840
illegal memory access

102
00:05:01,840 --> 00:05:04,800
the second are called on depth they

103
00:05:04,800 --> 00:05:07,120
usually come from initialized

104
00:05:07,120 --> 00:05:11,039
value a third kind of poison

105
00:05:11,039 --> 00:05:13,360
they are introduced by compilers

106
00:05:13,360 --> 00:05:14,960
themselves

107
00:05:14,960 --> 00:05:17,440
they are used to support speculative

108
00:05:17,440 --> 00:05:19,520
executions

109
00:05:19,520 --> 00:05:22,639
we will discuss on finding true

110
00:05:22,639 --> 00:05:24,160
undefined behaviors

111
00:05:24,160 --> 00:05:26,960
in a speech

112
00:05:28,000 --> 00:05:31,120
what's the consequence of executing

113
00:05:31,120 --> 00:05:34,639
undefined behavior actually

114
00:05:34,639 --> 00:05:38,240
anything is possible

115
00:05:38,240 --> 00:05:41,120
maybe nothing wrong happens the program

116
00:05:41,120 --> 00:05:41,840
works as

117
00:05:41,840 --> 00:05:46,560
expected or it may fail to compile

118
00:05:46,560 --> 00:05:50,320
or can output an unpredictable

119
00:05:50,320 --> 00:05:53,600
or nonsensical result

120
00:05:53,600 --> 00:05:57,520
or even it will crash

121
00:06:00,319 --> 00:06:03,120
sometimes crash means a security

122
00:06:03,120 --> 00:06:05,039
probability occurs

123
00:06:05,039 --> 00:06:08,319
for example undefined behavior such as

124
00:06:08,319 --> 00:06:11,440
array index outbound error will

125
00:06:11,440 --> 00:06:15,919
be to memory corrections directory

126
00:06:15,919 --> 00:06:18,840
a normal console sequence thread is more

127
00:06:18,840 --> 00:06:21,199
hidden sending chats

128
00:06:21,199 --> 00:06:23,680
may be removed if it contains

129
00:06:23,680 --> 00:06:26,000
undifferent behavioral code

130
00:06:26,000 --> 00:06:29,120
so we need to find ways to detect

131
00:06:29,120 --> 00:06:32,400
the undefined behavior

132
00:06:33,759 --> 00:06:38,479
next part we'll discuss the detections

133
00:06:40,080 --> 00:06:43,840
existing detections methods can be

134
00:06:43,840 --> 00:06:46,800
classified into two categories

135
00:06:46,800 --> 00:06:51,680
static analysis under dynamic analysis

136
00:06:51,840 --> 00:06:54,960
dynamic analysis are usually fuzzy

137
00:06:54,960 --> 00:06:58,240
various standard titles help a lot

138
00:06:58,240 --> 00:07:00,840
for instance undefined behavior

139
00:07:00,840 --> 00:07:02,960
sanitizer can detect

140
00:07:02,960 --> 00:07:06,400
shift errors sent into flow

141
00:07:06,400 --> 00:07:10,000
non-point the reference and so on

142
00:07:10,000 --> 00:07:12,880
address and titles can detect other

143
00:07:12,880 --> 00:07:13,919
bound excess

144
00:07:13,919 --> 00:07:17,199
memory corrections memories and titles

145
00:07:17,199 --> 00:07:18,080
can detect

146
00:07:18,080 --> 00:07:21,599
initialized usage

147
00:07:22,080 --> 00:07:25,759
but these tools require appropriate

148
00:07:25,759 --> 00:07:30,880
test cases to trigger a box

149
00:07:30,880 --> 00:07:34,080
as presidential analysis compilers will

150
00:07:34,080 --> 00:07:35,360
output warnings

151
00:07:35,360 --> 00:07:38,560
for definite undefined behavior with

152
00:07:38,560 --> 00:07:40,000
double error flag

153
00:07:40,000 --> 00:07:42,240
we can stop compiling when undefined

154
00:07:42,240 --> 00:07:45,039
behavior has been detected

155
00:07:45,039 --> 00:07:48,240
static analysis trolls like cleanstack

156
00:07:48,240 --> 00:07:49,440
and allies

157
00:07:49,440 --> 00:07:52,639
and coverity has a lot of checkers

158
00:07:52,639 --> 00:07:58,160
to scan the specific undefined behavior

159
00:07:58,160 --> 00:08:01,599
but these tools only detect a fraction

160
00:08:01,599 --> 00:08:04,560
of undefined behavior and they don't

161
00:08:04,560 --> 00:08:05,039
make

162
00:08:05,039 --> 00:08:08,240
the best use of compilers analysis

163
00:08:08,240 --> 00:08:12,560
on programs

164
00:08:12,560 --> 00:08:15,599
is there any simple but effective way

165
00:08:15,599 --> 00:08:19,680
to detect undefined behavior

166
00:08:20,319 --> 00:08:24,080
let's come back to quiz for inspiration

167
00:08:24,080 --> 00:08:28,319
i december look executable and fine

168
00:08:28,319 --> 00:08:31,520
there are no bunch of branches

169
00:08:31,520 --> 00:08:34,799
in functioning at all

170
00:08:34,958 --> 00:08:38,000
the outdoor read value has

171
00:08:38,000 --> 00:08:41,519
already been fetched we are still very

172
00:08:41,519 --> 00:08:42,559
confused

173
00:08:42,559 --> 00:08:45,279
what happened

174
00:08:46,000 --> 00:08:48,760
we dumped the lvm intermediate

175
00:08:48,760 --> 00:08:50,000
representations

176
00:08:50,000 --> 00:08:53,440
to take a deep look we found the above

177
00:08:53,440 --> 00:08:54,000
checking

178
00:08:54,000 --> 00:08:57,120
instruction is missing in function read

179
00:08:57,120 --> 00:08:59,839
even before it is in line to function

180
00:08:59,839 --> 00:09:02,160
main

181
00:09:02,320 --> 00:09:05,760
so we should focus on function read

182
00:09:05,760 --> 00:09:09,519
after comparing oil of the two

183
00:09:09,519 --> 00:09:12,800
different optimization process

184
00:09:12,800 --> 00:09:16,399
with front line the bond checking

185
00:09:16,399 --> 00:09:19,760
instructions are removed in optimization

186
00:09:19,760 --> 00:09:20,560
path

187
00:09:20,560 --> 00:09:25,599
called combining redundant instructions

188
00:09:26,720 --> 00:09:30,480
this path is used to remove redundant

189
00:09:30,480 --> 00:09:33,360
instructions

190
00:09:33,519 --> 00:09:36,800
when loading address which comes from

191
00:09:36,800 --> 00:09:40,560
a select instruction the non-point

192
00:09:40,560 --> 00:09:44,239
branch will be abandoned

193
00:09:44,640 --> 00:09:48,080
rpm from the list undefined behavior bar

194
00:09:48,080 --> 00:09:51,519
when analyzing the program

195
00:09:51,519 --> 00:09:54,800
but they don't tell you

196
00:09:55,920 --> 00:10:00,240
let's simply fold it what's the words

197
00:10:00,240 --> 00:10:04,000
an outer bound excess vulnerability

198
00:10:04,000 --> 00:10:08,880
appears due to less optimizations

199
00:10:10,399 --> 00:10:13,920
what do we learn from the quiz the key

200
00:10:13,920 --> 00:10:15,360
point is

201
00:10:15,360 --> 00:10:20,160
the mvm actually the undefined behavior

202
00:10:20,160 --> 00:10:23,120
but they don't just don't tell the

203
00:10:23,120 --> 00:10:25,040
programmers

204
00:10:25,040 --> 00:10:28,160
they tend to optimize ultima only find

205
00:10:28,160 --> 00:10:30,640
behavior called themselves

206
00:10:30,640 --> 00:10:33,040
and sometimes even create security

207
00:10:33,040 --> 00:10:36,000
vulnerabilities

208
00:10:36,880 --> 00:10:39,920
since erie is capable to find

209
00:10:39,920 --> 00:10:43,120
lots of unfair behavior why not

210
00:10:43,120 --> 00:10:47,839
just use its fundings

211
00:10:48,560 --> 00:10:51,200
let's go back to the combined redundant

212
00:10:51,200 --> 00:10:54,720
instruction optimization parts

213
00:10:54,720 --> 00:10:57,760
we can add hooks here so that we can

214
00:10:57,760 --> 00:10:58,320
check

215
00:10:58,320 --> 00:11:02,720
we only five behavior happens

216
00:11:03,120 --> 00:11:06,480
we can use local clan to compile the

217
00:11:06,480 --> 00:11:09,920
program and find the undefined behavior

218
00:11:09,920 --> 00:11:12,320
box

219
00:11:12,320 --> 00:11:15,360
you can try to mean that this detection

220
00:11:15,360 --> 00:11:17,200
is a little limited

221
00:11:17,200 --> 00:11:21,360
as only a non-point reference in select

222
00:11:21,360 --> 00:11:24,959
instruction can be found

223
00:11:25,760 --> 00:11:29,279
so we should add more hooks is a little

224
00:11:29,279 --> 00:11:29,680
bit

225
00:11:29,680 --> 00:11:31,959
challenging to locate where to do

226
00:11:31,959 --> 00:11:34,000
instrumentations

227
00:11:34,000 --> 00:11:37,040
lvm has a large code base of

228
00:11:37,040 --> 00:11:41,680
over 6 million lines

229
00:11:41,839 --> 00:11:44,720
it's hard to read them all another

230
00:11:44,720 --> 00:11:46,079
problem is that

231
00:11:46,079 --> 00:11:48,160
the different kinds of undefined

232
00:11:48,160 --> 00:11:50,880
behavior are mixed up together

233
00:11:50,880 --> 00:11:53,279
we have to distinguish the true

234
00:11:53,279 --> 00:11:54,720
undefined behavior

235
00:11:54,720 --> 00:11:59,600
that has securities with impact

236
00:12:03,040 --> 00:12:06,800
our method is to combine sorcery

237
00:12:06,800 --> 00:12:10,160
with manual experiments

238
00:12:10,160 --> 00:12:13,279
we focus on finding undefined behavior

239
00:12:13,279 --> 00:12:16,160
that has secrets thread it can be

240
00:12:16,160 --> 00:12:17,200
divided into

241
00:12:17,200 --> 00:12:22,839
two categories the first kind of box

242
00:12:22,839 --> 00:12:24,720
appears when

243
00:12:24,720 --> 00:12:27,120
program schematics are changed

244
00:12:27,120 --> 00:12:28,639
incorrectly

245
00:12:28,639 --> 00:12:31,920
the second kind are securing verbiage

246
00:12:31,920 --> 00:12:34,719
themselves

247
00:12:35,040 --> 00:12:39,519
we start with the first case

248
00:12:39,519 --> 00:12:42,959
inspired by the previous increase

249
00:12:42,959 --> 00:12:47,200
we first focus on select instructions

250
00:12:47,200 --> 00:12:50,240
these are some cosmetics where

251
00:12:50,240 --> 00:12:52,959
undefined behavior will be folded in

252
00:12:52,959 --> 00:12:55,680
select instructions

253
00:12:55,680 --> 00:12:58,399
listing optimizations will change the

254
00:12:58,399 --> 00:13:00,000
control flow graph

255
00:13:00,000 --> 00:13:04,160
by removing undefined behavioral

256
00:13:04,839 --> 00:13:06,639
instructions

257
00:13:06,639 --> 00:13:09,920
branch instruction is similar to select

258
00:13:09,920 --> 00:13:13,360
instruction if a branch contains

259
00:13:13,360 --> 00:13:17,120
undefined behavior it will be removed

260
00:13:17,120 --> 00:13:19,360
if a deleting branch is used for

261
00:13:19,360 --> 00:13:20,720
extension check

262
00:13:20,720 --> 00:13:24,560
it will lead to your security box

263
00:13:24,959 --> 00:13:27,680
another approach is to find undefined

264
00:13:27,680 --> 00:13:28,880
behavior but

265
00:13:28,880 --> 00:13:31,279
that are security vulnerabilities than

266
00:13:31,279 --> 00:13:33,120
sales

267
00:13:33,120 --> 00:13:36,560
you first think of a reindeer

268
00:13:36,560 --> 00:13:39,760
underground box

269
00:13:40,000 --> 00:13:43,680
they have powerful but they need to

270
00:13:43,680 --> 00:13:46,959
precise a static analysis and a hard

271
00:13:46,959 --> 00:13:50,560
model we can choose other appropriate

272
00:13:50,560 --> 00:13:54,320
type of undefined behavior such as

273
00:13:54,320 --> 00:13:59,120
individual flow and uninitialized usage

274
00:13:59,120 --> 00:14:01,519
it will have difficulties in locating

275
00:14:01,519 --> 00:14:03,920
events on different behavior handling

276
00:14:03,920 --> 00:14:05,120
code

277
00:14:05,120 --> 00:14:08,000
we can write one of the vulnerable test

278
00:14:08,000 --> 00:14:09,040
cases

279
00:14:09,040 --> 00:14:14,079
to help us understand ovm's code

280
00:14:15,120 --> 00:14:19,040
for example in function test

281
00:14:19,040 --> 00:14:23,360
we write an integral flow station check

282
00:14:23,360 --> 00:14:25,920
while the comparison cont contains

283
00:14:25,920 --> 00:14:27,920
undefined behavior

284
00:14:27,920 --> 00:14:31,199
if clan compile it in default

285
00:14:31,199 --> 00:14:32,880
configuration

286
00:14:32,880 --> 00:14:36,480
the sentence check works

287
00:14:37,199 --> 00:14:40,399
but in a higher occupation optimization

288
00:14:40,399 --> 00:14:41,760
level

289
00:14:41,760 --> 00:14:44,079
the control flow graph of the program

290
00:14:44,079 --> 00:14:46,880
has changed

291
00:14:46,880 --> 00:14:51,199
the integral flow will be removed

292
00:14:52,480 --> 00:14:56,800
how does this happen in rpm

293
00:14:56,800 --> 00:15:00,320
when x plus y will be

294
00:15:00,320 --> 00:15:03,199
integral flow undefined behavior the

295
00:15:03,199 --> 00:15:04,639
comparison between

296
00:15:04,639 --> 00:15:08,880
x plus y and

297
00:15:08,880 --> 00:15:12,959
x can be simplified to

298
00:15:12,959 --> 00:15:17,519
comparisons between y and zero

299
00:15:17,519 --> 00:15:20,639
if we added instrumentation here we can

300
00:15:20,639 --> 00:15:21,440
find

301
00:15:21,440 --> 00:15:27,040
potential integral flow bugs

302
00:15:27,040 --> 00:15:31,439
this is a normal initial flowcast

303
00:15:31,759 --> 00:15:35,279
the function test will compute the shift

304
00:15:35,279 --> 00:15:38,880
results of inputs in constants

305
00:15:38,880 --> 00:15:42,079
logical result should be zero when the

306
00:15:42,079 --> 00:15:43,040
input is there

307
00:15:43,040 --> 00:15:47,599
x and y are both zero

308
00:15:48,880 --> 00:15:51,519
but if we perform level three

309
00:15:51,519 --> 00:15:53,360
optimizations

310
00:15:53,360 --> 00:15:57,519
the output is nonzero

311
00:15:58,720 --> 00:16:02,880
if we observe the program more carefully

312
00:16:02,880 --> 00:16:06,639
we will find there is this an oversized

313
00:16:06,639 --> 00:16:09,839
shift undefined behavior

314
00:16:11,440 --> 00:16:14,240
we can check binary operations of on

315
00:16:14,240 --> 00:16:15,199
depth

316
00:16:15,199 --> 00:16:19,759
to find the potential overflow

317
00:16:19,759 --> 00:16:23,120
in addition the arithmetic operations

318
00:16:23,120 --> 00:16:26,160
based on depth sometimes returns

319
00:16:26,160 --> 00:16:29,759
abnormal values and it may cause

320
00:16:29,759 --> 00:16:37,680
on the basis too

321
00:16:37,680 --> 00:16:40,959
we can use the similar method to find

322
00:16:40,959 --> 00:16:44,800
our vm's handling code instrumentation

323
00:16:44,800 --> 00:16:48,480
here help us find unplanned behavior

324
00:16:48,480 --> 00:16:52,639
folded in binary instructions

325
00:16:55,680 --> 00:16:58,880
after sharing our detection method

326
00:16:58,880 --> 00:17:02,000
you may wonder the false positive rate

327
00:17:02,000 --> 00:17:04,400
of the log

328
00:17:04,400 --> 00:17:07,679
we can automatically filter false

329
00:17:07,679 --> 00:17:08,959
positives

330
00:17:08,959 --> 00:17:12,240
brought by poison undefined behavior

331
00:17:12,240 --> 00:17:15,199
and select the cases where we can

332
00:17:15,199 --> 00:17:16,480
control input

333
00:17:16,480 --> 00:17:19,280
to trigger the ongoing behavior side

334
00:17:19,280 --> 00:17:21,839
effect

335
00:17:21,839 --> 00:17:24,959
then most of the output should be the

336
00:17:24,959 --> 00:17:29,839
true undefined behavior we anticipate

337
00:17:31,600 --> 00:17:34,880
okay let me sum up our detection

338
00:17:34,880 --> 00:17:36,240
approach

339
00:17:36,240 --> 00:17:39,919
first we dig into our vm internals

340
00:17:39,919 --> 00:17:43,200
to figure out lvm's undefined behavior

341
00:17:43,200 --> 00:17:47,280
handling code and add instrumentations

342
00:17:47,280 --> 00:17:50,480
to lock the undefined behavior

343
00:17:50,480 --> 00:17:54,799
invert found by rpm then

344
00:17:54,799 --> 00:17:58,000
we can use hooked clan to compile

345
00:17:58,000 --> 00:18:01,840
programs to scan the undefined behavior

346
00:18:01,840 --> 00:18:03,280
box

347
00:18:03,280 --> 00:18:06,400
after filtering false positives we can

348
00:18:06,400 --> 00:18:07,200
start

349
00:18:07,200 --> 00:18:10,000
to construct proper concept to trigger

350
00:18:10,000 --> 00:18:12,480
the bugs

351
00:18:12,480 --> 00:18:14,960
we have to use all tools to scan

352
00:18:14,960 --> 00:18:17,440
chromium and under frameworks

353
00:18:17,440 --> 00:18:20,640
and for lots of bugs

354
00:18:20,640 --> 00:18:23,679
now i will hand it over to the

355
00:18:23,679 --> 00:18:29,840
hero share the detection result with us

356
00:18:31,200 --> 00:18:34,480
third i will analyze several typical

357
00:18:34,480 --> 00:18:38,720
vulnerabilities from biology

358
00:18:40,240 --> 00:18:43,840
cve 20204 file 2

359
00:18:43,840 --> 00:18:47,440
is about in live dfi

360
00:18:47,440 --> 00:18:52,000
which is the library to add psii file

361
00:18:52,000 --> 00:18:55,039
in this function it will check

362
00:18:55,039 --> 00:18:58,559
whether the set of variable e plus size

363
00:18:58,559 --> 00:18:59,919
of a final shot

364
00:18:59,919 --> 00:19:03,360
would overflow the check works well

365
00:19:03,360 --> 00:19:06,640
in multiple wires but lrvm

366
00:19:06,640 --> 00:19:10,320
thinks it is a defined behavior it will

367
00:19:10,320 --> 00:19:12,400
be simplified to our comparison

368
00:19:12,400 --> 00:19:14,559
between find out a fan shot on the

369
00:19:14,559 --> 00:19:15,919
vehicle

370
00:19:15,919 --> 00:19:19,120
which is always true

371
00:19:19,120 --> 00:19:21,919
as a result the pharmacy check is

372
00:19:21,919 --> 00:19:23,440
removed

373
00:19:23,440 --> 00:19:26,480
and it gave rise to hip overflow in

374
00:19:26,480 --> 00:19:29,760
memory cooking function

375
00:19:31,120 --> 00:19:34,880
this theory is not an isolated

376
00:19:34,880 --> 00:19:37,440
there are many similar history effects

377
00:19:37,440 --> 00:19:39,520
in the same library

378
00:19:39,520 --> 00:19:43,600
as shown in figure the root task of this

379
00:19:43,600 --> 00:19:44,080
cv

380
00:19:44,080 --> 00:19:47,679
is conducting sanity check

381
00:19:47,679 --> 00:19:51,360
and define behavioral code llvm

382
00:19:51,360 --> 00:19:54,559
will remove them as a result

383
00:19:54,559 --> 00:19:57,280
none of the effective affinity checks

384
00:19:57,280 --> 00:19:57,919
will take

385
00:19:57,919 --> 00:20:00,320
effect

386
00:20:02,000 --> 00:20:05,679
photoshop using any fun behavior to do

387
00:20:05,679 --> 00:20:07,120
sanity check

388
00:20:07,120 --> 00:20:10,640
set to be a popular programming paradigm

389
00:20:10,640 --> 00:20:12,080
on the works while many of the

390
00:20:12,080 --> 00:20:13,679
competitors

391
00:20:13,679 --> 00:20:16,000
but they need two vulnerabilities in

392
00:20:16,000 --> 00:20:17,120
modern family of

393
00:20:17,120 --> 00:20:20,559
mind commanders thanks a lot

394
00:20:20,559 --> 00:20:23,600
more importantly this old library

395
00:20:23,600 --> 00:20:26,720
labs are few weather deals

396
00:20:26,720 --> 00:20:30,720
for instance live exi was first released

397
00:20:30,720 --> 00:20:32,880
in 2002

398
00:20:32,880 --> 00:20:36,080
but is still integrated in android media

399
00:20:36,080 --> 00:20:36,720
from work

400
00:20:36,720 --> 00:20:38,960
now

401
00:20:40,799 --> 00:20:44,000
okay let's here these are called team

402
00:20:44,000 --> 00:20:44,559
leaders

403
00:20:44,559 --> 00:20:46,640
here a popular open source

404
00:20:46,640 --> 00:20:48,720
two-dimensional graphic

405
00:20:48,720 --> 00:20:52,080
level here is the integer overflow in

406
00:20:52,080 --> 00:20:54,720
multiplication

407
00:20:54,720 --> 00:20:57,120
we found this part in transient content

408
00:20:57,120 --> 00:20:57,919
the volume

409
00:20:57,919 --> 00:21:01,840
of undefined behavior the overflow the

410
00:21:01,840 --> 00:21:02,320
set

411
00:21:02,320 --> 00:21:05,760
is used to allocate password which leads

412
00:21:05,760 --> 00:21:10,080
to a hit buffer overflow availability

413
00:21:12,240 --> 00:21:15,600
roomba one zero seven one three 1 1

414
00:21:15,600 --> 00:21:18,960
is also is here it is similar to the

415
00:21:18,960 --> 00:21:20,080
fifth

416
00:21:20,080 --> 00:21:22,240
the set function is the return value of

417
00:21:22,240 --> 00:21:23,919
the internal graph function

418
00:21:23,919 --> 00:21:27,679
to do an r operation the internal gas

419
00:21:27,679 --> 00:21:29,039
function

420
00:21:29,039 --> 00:21:31,120
a non-pointer will be returned into the

421
00:21:31,120 --> 00:21:33,600
bottle check file

422
00:21:33,600 --> 00:21:35,919
non-pointer directions is the undefined

423
00:21:35,919 --> 00:21:38,000
behavior

424
00:21:38,000 --> 00:21:41,120
lrvm will remove the watch so that the

425
00:21:41,120 --> 00:21:41,520
check

426
00:21:41,520 --> 00:21:44,880
will take effect we can cause a lot of

427
00:21:44,880 --> 00:21:45,760
impact

428
00:21:45,760 --> 00:21:49,679
to trigger an auto spawn right

429
00:21:53,480 --> 00:21:55,200
groombap107638 silence

430
00:21:55,200 --> 00:21:58,320
is in blink the rendering engine useful

431
00:21:58,320 --> 00:22:00,240
by premium

432
00:22:00,240 --> 00:22:03,039
is a conjunction of a jl camera query

433
00:22:03,039 --> 00:22:04,720
est

434
00:22:04,720 --> 00:22:07,600
it will use the return value observer

435
00:22:07,600 --> 00:22:08,480
function

436
00:22:08,480 --> 00:22:12,640
to target document function in canvas

437
00:22:12,640 --> 00:22:13,600
function

438
00:22:13,600 --> 00:22:16,480
it will check the host type for design

439
00:22:16,480 --> 00:22:18,320
to return non-pointer

440
00:22:18,320 --> 00:22:21,520
or cut the host to html

441
00:22:21,520 --> 00:22:26,080
convert alignment and return its address

442
00:22:26,080 --> 00:22:28,320
call from now pointer is a defined

443
00:22:28,320 --> 00:22:30,400
behavior

444
00:22:30,400 --> 00:22:33,600
llvm will remove the branch so that we

445
00:22:33,600 --> 00:22:34,559
can confuse

446
00:22:34,559 --> 00:22:38,840
or screen canvas with html thermos

447
00:22:38,840 --> 00:22:40,640
alignment

448
00:22:40,640 --> 00:22:42,720
to diamond treated the experience the

449
00:22:42,720 --> 00:22:45,600
life of undivided behavior

450
00:22:45,600 --> 00:22:48,720
we select one of those vulnerabilities

451
00:22:48,720 --> 00:22:53,440
to run on flight we successfully achieve

452
00:22:53,440 --> 00:22:57,520
remote code exclusion on chrome browser

453
00:22:57,520 --> 00:23:01,440
with a single undefined behavior

454
00:23:04,559 --> 00:23:07,760
this is phone back 1 076

455
00:23:07,760 --> 00:23:10,640
three phase five shared in the previous

456
00:23:10,640 --> 00:23:12,159
slide

457
00:23:12,159 --> 00:23:15,200
an offspring canvas is incorrectly

458
00:23:15,200 --> 00:23:19,200
passed to html terms alignment

459
00:23:19,200 --> 00:23:21,280
here is the desirable port of this

460
00:23:21,280 --> 00:23:23,520
function

461
00:23:23,520 --> 00:23:27,440
once object is html current limit

462
00:23:27,440 --> 00:23:32,480
rx minus 9 0 refers to its mic

463
00:23:32,480 --> 00:23:36,159
the screen canvas is smaller than html

464
00:23:36,159 --> 00:23:38,799
terminal alignment when the type of

465
00:23:38,799 --> 00:23:40,640
confusion occurs

466
00:23:40,640 --> 00:23:43,760
rx minus 900 will skip it

467
00:23:43,760 --> 00:23:47,360
and pointing to the memory foam

468
00:23:49,200 --> 00:23:52,159
after tab combine occurs thinking

469
00:23:52,159 --> 00:23:52,880
correctly

470
00:23:52,880 --> 00:23:55,120
factor value will be passed to form

471
00:23:55,120 --> 00:23:56,480
instruction

472
00:23:56,480 --> 00:24:00,159
so we can control oip

473
00:24:02,240 --> 00:24:04,960
the detailed relationship is shown on

474
00:24:04,960 --> 00:24:05,360
the

475
00:24:05,360 --> 00:24:09,600
fly to control the value of vb

476
00:24:09,600 --> 00:24:12,159
we should be able to set the value of y

477
00:24:12,159 --> 00:24:13,679
at first

478
00:24:13,679 --> 00:24:18,880
that's the job of hip function

479
00:24:18,880 --> 00:24:21,520
of green canvas is a garbage reflected

480
00:24:21,520 --> 00:24:23,600
objects in blink

481
00:24:23,600 --> 00:24:26,159
link use oil plant magnitude of

482
00:24:26,159 --> 00:24:28,400
implanted objects

483
00:24:28,400 --> 00:24:31,919
in oil paint objects are divided into

484
00:24:31,919 --> 00:24:34,159
four categories

485
00:24:34,159 --> 00:24:36,799
they go to different batteries depending

486
00:24:36,799 --> 00:24:39,039
on your size

487
00:24:39,039 --> 00:24:41,600
the screen canvas is located in the

488
00:24:41,600 --> 00:24:46,720
normal page areas

489
00:24:46,720 --> 00:24:50,400
the size of of string canvas is c0

490
00:24:50,400 --> 00:24:53,440
so we have to find objects located at

491
00:24:53,440 --> 00:24:55,120
the 64

492
00:24:55,120 --> 00:24:58,960
to 128 bytes but hit

493
00:24:58,960 --> 00:25:03,120
smallmouth analysis another requirement

494
00:25:03,120 --> 00:25:07,678
if the value of y can be controlled

495
00:25:09,120 --> 00:25:12,960
how to fund it we can use color2l to

496
00:25:12,960 --> 00:25:14,080
find objects

497
00:25:14,080 --> 00:25:17,520
located in the red membrane track

498
00:25:17,520 --> 00:25:20,240
then we have to review the source code

499
00:25:20,240 --> 00:25:21,440
to confirm

500
00:25:21,440 --> 00:25:23,679
whether the value of white white can be

501
00:25:23,679 --> 00:25:26,159
controlled

502
00:25:27,520 --> 00:25:30,559
fortunately we found the idb

503
00:25:30,559 --> 00:25:33,840
open db request object that made

504
00:25:33,840 --> 00:25:37,679
this requirement the version number of

505
00:25:37,679 --> 00:25:38,640
the object

506
00:25:38,640 --> 00:25:41,279
is at the right division assembly

507
00:25:41,279 --> 00:25:43,600
controlled

508
00:25:43,600 --> 00:25:47,360
when we specifically occupy the memory

509
00:25:47,360 --> 00:25:50,799
the ras radiator can be successfully

510
00:25:50,799 --> 00:25:54,640
controlled but to control rip

511
00:25:54,640 --> 00:25:59,520
we still need to mix the heat layout

512
00:25:59,520 --> 00:26:03,919
we can try to inspire the 32-bit tool

513
00:26:03,919 --> 00:26:07,360
32-bit room has a smaller memory address

514
00:26:07,360 --> 00:26:08,880
space

515
00:26:08,880 --> 00:26:11,840
if great technique can make it easier to

516
00:26:11,840 --> 00:26:14,799
control eip

517
00:26:16,640 --> 00:26:19,840
the idb open db requests objects

518
00:26:19,840 --> 00:26:24,240
under 32 bit no longer with our request

519
00:26:24,240 --> 00:26:26,559
we need to find the new filterable

520
00:26:26,559 --> 00:26:27,279
object

521
00:26:27,279 --> 00:26:33,679
in 32-bit cool using the theme13 method

522
00:26:33,679 --> 00:26:38,080
response of live audio contact object

523
00:26:38,080 --> 00:26:41,279
the last number of the object is either

524
00:26:41,279 --> 00:26:45,679
the red position and can be controlled

525
00:26:45,679 --> 00:26:48,320
but the one offline audio contact is

526
00:26:48,320 --> 00:26:49,919
created

527
00:26:49,919 --> 00:26:52,480
another audio handler object will be

528
00:26:52,480 --> 00:26:53,279
created

529
00:26:53,279 --> 00:26:57,279
with conjunction the following graph

530
00:26:57,279 --> 00:27:00,400
should memory layout

531
00:27:00,400 --> 00:27:04,840
audio handler is a terrorism object

532
00:27:04,840 --> 00:27:07,840
called

533
00:27:14,000 --> 00:27:17,600
so we can create an object

534
00:27:17,600 --> 00:27:20,320
of the same site as offline audio

535
00:27:20,320 --> 00:27:21,440
content

536
00:27:21,440 --> 00:27:25,440
next to also screen convert

537
00:27:25,440 --> 00:27:28,799
phrase and now this memory is managed

538
00:27:28,799 --> 00:27:32,320
by the free list create

539
00:27:32,320 --> 00:27:35,440
offline audio content it will use the

540
00:27:35,440 --> 00:27:36,720
previously

541
00:27:36,720 --> 00:27:39,600
phrased memory

542
00:27:40,880 --> 00:27:43,520
we found the media theme object with the

543
00:27:43,520 --> 00:27:43,919
same

544
00:27:43,919 --> 00:27:48,399
site as offline audio context

545
00:27:48,399 --> 00:27:51,440
after his function we can successfully

546
00:27:51,440 --> 00:27:52,480
control the value

547
00:27:52,480 --> 00:27:56,159
of eax reduction

548
00:27:57,440 --> 00:28:00,159
after that we can use his drive

549
00:28:00,159 --> 00:28:00,799
technique

550
00:28:00,799 --> 00:28:04,960
to control eip the object are drive

551
00:28:04,960 --> 00:28:08,399
under 32 bit extreme

552
00:28:08,399 --> 00:28:11,360
the spread structure is shown as in the

553
00:28:11,360 --> 00:28:13,039
figure

554
00:28:13,039 --> 00:28:16,799
after traveling the what the relative

555
00:28:16,799 --> 00:28:21,279
the value of rx reactor will be sleeve

556
00:28:21,279 --> 00:28:24,000
then it will be dereferenced and go back

557
00:28:24,000 --> 00:28:26,159
to slip

558
00:28:26,159 --> 00:28:29,200
so that we can smoothly change the ip

559
00:28:29,200 --> 00:28:32,880
whatever value we want next step

560
00:28:32,880 --> 00:28:36,960
is to do rop but it needs another but

561
00:28:36,960 --> 00:28:41,200
to leave base address of promote.data

562
00:28:41,200 --> 00:28:44,240
can we find our approach to a field code

563
00:28:44,240 --> 00:28:47,039
in memory without help of equality

564
00:28:47,039 --> 00:28:49,919
vulnerabilities

565
00:28:50,720 --> 00:28:53,679
g8 is varying certain ones just

566
00:28:53,679 --> 00:28:54,559
protection

567
00:28:54,559 --> 00:28:58,240
of aslr and eup by exploiting

568
00:28:58,240 --> 00:29:01,919
the behavior of just in time convention

569
00:29:01,919 --> 00:29:05,440
the purpose of git is to produce a few

570
00:29:05,440 --> 00:29:06,960
volumes

571
00:29:06,960 --> 00:29:09,840
the input program typically contains

572
00:29:09,840 --> 00:29:11,200
numerous

573
00:29:11,200 --> 00:29:14,799
content values that can be uranically

574
00:29:14,799 --> 00:29:18,240
difficult as code

575
00:29:19,520 --> 00:29:23,360
for example we write such a piece of js

576
00:29:23,360 --> 00:29:25,120
code

577
00:29:25,120 --> 00:29:28,320
when it is compiled into assembly called

578
00:29:28,320 --> 00:29:32,960
ign it will look like this

579
00:29:32,960 --> 00:29:36,720
if we jump to git code without fact

580
00:29:36,720 --> 00:29:40,399
the code will become weird some of the

581
00:29:40,399 --> 00:29:41,440
dates will be

582
00:29:41,440 --> 00:29:44,880
filled with f code this means that we

583
00:29:44,880 --> 00:29:47,200
can control the activities code

584
00:29:47,200 --> 00:29:50,399
by changing the date

585
00:29:51,600 --> 00:29:54,240
now let's make some changes to the

586
00:29:54,240 --> 00:29:57,200
original df code

587
00:29:57,200 --> 00:29:59,840
you can see the generated assembly code

588
00:29:59,840 --> 00:30:02,720
is as follows

589
00:30:03,039 --> 00:30:06,840
after we add our site to this code

590
00:30:06,840 --> 00:30:10,000
a8 and the three five are merged into

591
00:30:10,000 --> 00:30:14,000
a al-35 structure

592
00:30:14,000 --> 00:30:16,880
the following three nine zero is treated

593
00:30:16,880 --> 00:30:17,919
as three knob

594
00:30:17,919 --> 00:30:21,440
instructions this means

595
00:30:21,440 --> 00:30:24,320
that three bytes in every file fast can

596
00:30:24,320 --> 00:30:27,360
be used in coding structure

597
00:30:27,360 --> 00:30:29,200
we can use those instructions to

598
00:30:29,200 --> 00:30:31,600
construct a child code

599
00:30:31,600 --> 00:30:34,799
in this way our shell code is

600
00:30:34,799 --> 00:30:38,399
located at the curfew memory area

601
00:30:38,399 --> 00:30:41,440
it has created saturated constructs into

602
00:30:41,440 --> 00:30:42,559
the memory

603
00:30:42,559 --> 00:30:45,200
and changes the eip radiator to the

604
00:30:45,200 --> 00:30:46,320
address

605
00:30:46,320 --> 00:30:51,840
then we can expose our gel tool

606
00:30:52,480 --> 00:30:55,919
there are many tricks in git screen

607
00:30:55,919 --> 00:30:58,640
be careful of the encoding of s4

608
00:30:58,640 --> 00:31:00,320
operation

609
00:31:00,320 --> 00:31:04,399
xor ex instructions only need one bite

610
00:31:04,399 --> 00:31:07,440
it's a perfect guide

611
00:31:07,440 --> 00:31:10,640
as all other relief curves only

612
00:31:10,640 --> 00:31:13,840
two bites but can't be used as shell

613
00:31:13,840 --> 00:31:15,360
coat

614
00:31:15,360 --> 00:31:17,919
we can change the format of xor

615
00:31:17,919 --> 00:31:18,720
statements

616
00:31:18,720 --> 00:31:23,039
to select the suitable widget

617
00:31:25,039 --> 00:31:27,679
here are the dynamo weights by the probe

618
00:31:27,679 --> 00:31:30,559
of table version

619
00:31:30,840 --> 00:31:33,840
79.

620
00:32:01,440 --> 00:32:03,760
we successfully appealed a unified

621
00:32:03,760 --> 00:32:04,960
behavior path

622
00:32:04,960 --> 00:32:09,039
to achieve remote productivity

623
00:32:11,600 --> 00:32:14,720
finally its conclusions

624
00:32:14,720 --> 00:32:17,600
firstly we have some suggestions for

625
00:32:17,600 --> 00:32:18,799
programmer

626
00:32:18,799 --> 00:32:21,200
to understand and defend behavior and

627
00:32:21,200 --> 00:32:24,640
residents and defend behavior

628
00:32:24,640 --> 00:32:27,679
for compiler developers to provide

629
00:32:27,679 --> 00:32:30,080
more accurate and useful undefined

630
00:32:30,080 --> 00:32:31,679
behavioral warnings

631
00:32:31,679 --> 00:32:35,840
to programmers for fund hunters

632
00:32:35,840 --> 00:32:37,679
you've got more useful and defined

633
00:32:37,679 --> 00:32:39,039
behavioral informed

634
00:32:39,039 --> 00:32:43,519
from camaro

635
00:32:43,519 --> 00:32:46,960
in this talk firstly we illustrate

636
00:32:46,960 --> 00:32:50,000
how to utilize competitors ability

637
00:32:50,000 --> 00:32:53,360
to fund unifying behavior paths

638
00:32:53,360 --> 00:32:56,320
then we find several birthday parts

639
00:32:56,320 --> 00:32:58,799
captured by a different behavior

640
00:32:58,799 --> 00:33:01,360
finally sharing anyone's room

641
00:33:01,360 --> 00:33:02,480
exploration

642
00:33:02,480 --> 00:33:04,960
techniques

643
00:33:07,279 --> 00:33:09,120
special sense to feel medio and

644
00:33:09,120 --> 00:33:12,080
electronics

645
00:33:13,480 --> 00:33:16,480
thanks

