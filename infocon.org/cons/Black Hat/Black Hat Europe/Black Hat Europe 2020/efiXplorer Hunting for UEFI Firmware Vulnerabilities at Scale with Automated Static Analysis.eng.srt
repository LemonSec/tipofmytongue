1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:15,759 --> 00:00:16,720
hello everyone

3
00:00:16,720 --> 00:00:19,840
my name is alex matrosov and today i

4
00:00:19,840 --> 00:00:21,840
will be representing the efi explorer

5
00:00:21,840 --> 00:00:22,640
team

6
00:00:22,640 --> 00:00:25,760
uh which is actually andrei igor

7
00:00:25,760 --> 00:00:28,560
and philip and today andrew and me will

8
00:00:28,560 --> 00:00:29,439
be presenting

9
00:00:29,439 --> 00:00:31,840
our research which we did a couple of

10
00:00:31,840 --> 00:00:32,800
months before

11
00:00:32,800 --> 00:00:36,160
this conference so basically

12
00:00:36,160 --> 00:00:39,680
uh our talk is about hunting for ufi

13
00:00:39,680 --> 00:00:41,680
firm vulnerabilities at scale

14
00:00:41,680 --> 00:00:44,800
with automated static analysis we try to

15
00:00:44,800 --> 00:00:46,079
provide the tool

16
00:00:46,079 --> 00:00:49,120
which is powerful enough to find the

17
00:00:49,120 --> 00:00:50,239
vulnerability

18
00:00:50,239 --> 00:00:52,800
potential vulnerability patterns with

19
00:00:52,800 --> 00:00:54,239
static analysis

20
00:00:54,239 --> 00:00:57,520
in collaboration with idapro and x-rays

21
00:00:57,520 --> 00:01:01,039
so in the past uh i am

22
00:01:01,039 --> 00:01:03,440
already present with eugene radionov

23
00:01:03,440 --> 00:01:06,080
gabriel barbosa and rodrigo branco

24
00:01:06,080 --> 00:01:09,360
uh the research uh about distribution

25
00:01:09,360 --> 00:01:10,320
distribution

26
00:01:10,320 --> 00:01:12,080
uh distributing reconstruction of

27
00:01:12,080 --> 00:01:13,920
high-level intermediate representation

28
00:01:13,920 --> 00:01:16,080
for large-scale malware analysis

29
00:01:16,080 --> 00:01:19,600
we did uh mower analysis at scale and

30
00:01:19,600 --> 00:01:21,920
we analyzed the patterns which has been

31
00:01:21,920 --> 00:01:23,119
reconstructed

32
00:01:23,119 --> 00:01:26,560
from hex raysde compiler and ida pro

33
00:01:26,560 --> 00:01:29,280
it's been presented in 2015 and we

34
00:01:29,280 --> 00:01:30,400
learned it a lot

35
00:01:30,400 --> 00:01:34,479
how we can scale ida for the analysis

36
00:01:34,479 --> 00:01:37,600
in this research actually we'll be

37
00:01:37,600 --> 00:01:39,920
focused on vulnerability research and

38
00:01:39,920 --> 00:01:42,240
how we can scale the plug-in

39
00:01:42,240 --> 00:01:45,759
based uh on ida pro and

40
00:01:45,759 --> 00:01:49,360
hex-raysd compiler to gain uh

41
00:01:49,360 --> 00:01:52,320
some power of the static analysis to

42
00:01:52,320 --> 00:01:53,439
reconstruct

43
00:01:53,439 --> 00:01:55,600
uh interesting vulnerability patterns

44
00:01:55,600 --> 00:01:57,119
which we'll talk about

45
00:01:57,119 --> 00:02:00,320
today so we will start with

46
00:02:00,320 --> 00:02:03,200
motivation and how our automated

47
00:02:03,200 --> 00:02:05,439
vulnerability search is working

48
00:02:05,439 --> 00:02:08,800
uh where we cover the methodology and

49
00:02:08,800 --> 00:02:11,440
few very common vulnerability patterns

50
00:02:11,440 --> 00:02:11,840
like

51
00:02:11,840 --> 00:02:14,879
smm cloud get variable and get variable

52
00:02:14,879 --> 00:02:15,200
for

53
00:02:15,200 --> 00:02:19,120
smm and not really frequently

54
00:02:19,120 --> 00:02:22,080
discussed get variable inside the

55
00:02:22,080 --> 00:02:25,920
platform utilization stage

56
00:02:25,920 --> 00:02:28,560
and in the end we will demonstrate the

57
00:02:28,560 --> 00:02:29,760
statistics

58
00:02:29,760 --> 00:02:32,800
by vendor and actually all the

59
00:02:32,800 --> 00:02:36,160
images we analyzed in this research been

60
00:02:36,160 --> 00:02:39,360
pretty recently released in this year

61
00:02:39,360 --> 00:02:41,519
and of course we have a lot of plans to

62
00:02:41,519 --> 00:02:43,280
continue this research

63
00:02:43,280 --> 00:02:46,239
and develop new functionality for efi

64
00:02:46,239 --> 00:02:48,800
explorer

65
00:02:48,959 --> 00:02:51,200
so let's start what is actually a file

66
00:02:51,200 --> 00:02:53,120
explorer if i explore

67
00:02:53,120 --> 00:02:56,720
it is a ida pro plugin which is helping

68
00:02:56,720 --> 00:03:00,319
to reconstruct uh ufi related

69
00:03:00,319 --> 00:03:03,120
data structures and interfaces if you

70
00:03:03,120 --> 00:03:04,560
look on this slide

71
00:03:04,560 --> 00:03:07,680
you can clearly see it is some

72
00:03:07,680 --> 00:03:10,959
complex type like a structure

73
00:03:10,959 --> 00:03:14,400
but it's unknown for this environment

74
00:03:14,400 --> 00:03:17,040
and it's why it is not recognized

75
00:03:17,040 --> 00:03:21,200
by this disassembly listing

76
00:03:21,200 --> 00:03:24,879
but as example with gidra

77
00:03:24,879 --> 00:03:27,680
you have plugins like efi seek or the

78
00:03:27,680 --> 00:03:28,879
firmware utils

79
00:03:28,879 --> 00:03:32,959
which is add to local type database

80
00:03:32,959 --> 00:03:35,680
sometimes related to uefi environment

81
00:03:35,680 --> 00:03:36,879
it's create

82
00:03:36,879 --> 00:03:40,480
much more understandable

83
00:03:40,480 --> 00:03:43,360
and useful uh analysis and

84
00:03:43,360 --> 00:03:44,560
reconstruction

85
00:03:44,560 --> 00:03:48,159
for ufi binaries

86
00:03:48,159 --> 00:03:51,599
but we want to create not only

87
00:03:51,599 --> 00:03:54,720
a helper for reconstructing ufi

88
00:03:54,720 --> 00:03:57,280
binaries we want to create environment

89
00:03:57,280 --> 00:03:58,319
which will be

90
00:03:58,319 --> 00:04:01,599
powerful enough to simplify reverse

91
00:04:01,599 --> 00:04:02,239
engineering

92
00:04:02,239 --> 00:04:06,480
work for who you fire ecosystem

93
00:04:06,480 --> 00:04:09,680
basically uh efi explorer have 3k

94
00:04:09,680 --> 00:04:12,239
component it's efi analyzer which is

95
00:04:12,239 --> 00:04:14,480
simplifying reconstruction of ufi

96
00:04:14,480 --> 00:04:18,079
specific types and protocols

97
00:04:18,079 --> 00:04:21,440
and we have uh efi loader which is

98
00:04:21,440 --> 00:04:22,800
actually unified

99
00:04:22,800 --> 00:04:26,479
loader for full image

100
00:04:26,479 --> 00:04:29,919
of firmware it's loading to entire

101
00:04:29,919 --> 00:04:33,040
idb and basically uh

102
00:04:33,040 --> 00:04:36,560
you can analyze with a single idb

103
00:04:36,560 --> 00:04:39,280
that all firmware drivers contain in

104
00:04:39,280 --> 00:04:40,840
this

105
00:04:40,840 --> 00:04:44,240
image which is very helpful and

106
00:04:44,240 --> 00:04:47,360
uh much more powerful to analyze

107
00:04:47,360 --> 00:04:50,479
and devel reveal the cross-reference

108
00:04:50,479 --> 00:04:52,560
between these drivers

109
00:04:52,560 --> 00:04:54,880
and of course finding common types of

110
00:04:54,880 --> 00:04:56,720
vulnerabilities

111
00:04:56,720 --> 00:05:00,240
it's very cool and we implement some

112
00:05:00,240 --> 00:05:03,120
static pattern analyzers for particular

113
00:05:03,120 --> 00:05:06,000
vulnerability classes and have a lot of

114
00:05:06,000 --> 00:05:08,720
uh interesting ideas how we can improve

115
00:05:08,720 --> 00:05:09,199
it

116
00:05:09,199 --> 00:05:12,400
with a power of hexaze microcode and

117
00:05:12,400 --> 00:05:15,120
intermediate representation like c trees

118
00:05:15,120 --> 00:05:16,800
especially for the data flow

119
00:05:16,800 --> 00:05:19,360
reconstruction

120
00:05:19,360 --> 00:05:22,400
so uh on this uh decompiler listing you

121
00:05:22,400 --> 00:05:23,840
can see

122
00:05:23,840 --> 00:05:27,039
how cooperation between x-rays and efi

123
00:05:27,039 --> 00:05:28,560
explorer works

124
00:05:28,560 --> 00:05:32,560
and actually this looks like

125
00:05:32,560 --> 00:05:35,600
a real source code file because it's

126
00:05:35,600 --> 00:05:36,560
very readable

127
00:05:36,560 --> 00:05:39,120
most of the types is reconstructed and

128
00:05:39,120 --> 00:05:40,400
you have you have

129
00:05:40,400 --> 00:05:43,440
a lot of hints about this flow what is

130
00:05:43,440 --> 00:05:46,719
actually going on there

131
00:05:46,880 --> 00:05:51,199
but um as example uh

132
00:05:51,199 --> 00:05:53,919
efi explorer can fight automatically at

133
00:05:53,919 --> 00:05:55,759
software semi handlers

134
00:05:55,759 --> 00:05:59,199
um and without uh efi

135
00:05:59,199 --> 00:06:02,240
explorer uh

136
00:06:02,240 --> 00:06:05,600
on on the hexaysd compiler stage as

137
00:06:05,600 --> 00:06:07,440
clearly we can see on the left side of

138
00:06:07,440 --> 00:06:10,080
the slide it is a red deck decompiler

139
00:06:10,080 --> 00:06:12,479
which is doesn't collaborate with the

140
00:06:12,479 --> 00:06:13,520
local types

141
00:06:13,520 --> 00:06:16,960
databases inside the idb and clearly

142
00:06:16,960 --> 00:06:17,680
it's

143
00:06:17,680 --> 00:06:20,800
not understandable listing and not

144
00:06:20,800 --> 00:06:22,000
annotated enough

145
00:06:22,000 --> 00:06:25,840
to make it readable it's actually why we

146
00:06:25,840 --> 00:06:29,120
highly recommend uh to collaborate with

147
00:06:29,120 --> 00:06:32,479
uh x-rays uh with uh either pro

148
00:06:32,479 --> 00:06:33,680
reconstructed

149
00:06:33,680 --> 00:06:36,319
assem an annotated assembly x-ray sd

150
00:06:36,319 --> 00:06:37,680
compiler because

151
00:06:37,680 --> 00:06:40,080
it is actually might make create much

152
00:06:40,080 --> 00:06:41,360
more readable

153
00:06:41,360 --> 00:06:44,000
listings on the the compilot flow but of

154
00:06:44,000 --> 00:06:45,039
course remember

155
00:06:45,039 --> 00:06:48,160
to look on actual assembly code because

156
00:06:48,160 --> 00:06:48,720
without

157
00:06:48,720 --> 00:06:51,199
understanding assembly it's hard to spot

158
00:06:51,199 --> 00:06:54,880
the mistakes in the compilation

159
00:06:54,880 --> 00:06:58,240
so uh how it started so you find eliza

160
00:06:58,240 --> 00:06:58,880
was

161
00:06:58,880 --> 00:07:02,720
not i would not say simple but much

162
00:07:02,720 --> 00:07:05,919
much more simpler than we have in

163
00:07:05,919 --> 00:07:07,360
nowadays because

164
00:07:07,360 --> 00:07:10,000
we add a lot of functionality for uh

165
00:07:10,000 --> 00:07:12,160
platform initialization stage which is

166
00:07:12,160 --> 00:07:13,120
not very

167
00:07:13,120 --> 00:07:17,120
uh don't have a lot of coverage on other

168
00:07:17,120 --> 00:07:18,160
plugins

169
00:07:18,160 --> 00:07:22,000
uh we have uh we added some

170
00:07:22,000 --> 00:07:24,160
vulnerability patterns recognition we

171
00:07:24,160 --> 00:07:25,280
added a lot of

172
00:07:25,280 --> 00:07:28,400
uh additional um

173
00:07:28,400 --> 00:07:31,919
additional uh heuristics and

174
00:07:31,919 --> 00:07:35,520
as example for smi handlers and for cpu

175
00:07:35,520 --> 00:07:37,120
state detection for

176
00:07:37,120 --> 00:07:41,759
uh smm clouds and much more

177
00:07:41,759 --> 00:07:44,800
so uh actually in september we got a

178
00:07:44,800 --> 00:07:45,280
fourth

179
00:07:45,280 --> 00:07:48,720
third prize uh of the x-rays uh plug-in

180
00:07:48,720 --> 00:07:49,360
contest

181
00:07:49,360 --> 00:07:52,720
and thanks x-rays to uh support of

182
00:07:52,720 --> 00:07:56,160
uh our potential

183
00:07:56,160 --> 00:07:59,520
and uh usefulness of efi explorer

184
00:07:59,520 --> 00:08:00,319
plug-in

185
00:08:00,319 --> 00:08:02,479
uh we're very proud of this honor

186
00:08:02,479 --> 00:08:03,759
because if i explore

187
00:08:03,759 --> 00:08:05,840
it's pretty young project it just

188
00:08:05,840 --> 00:08:07,919
started on the beginning of this year

189
00:08:07,919 --> 00:08:10,879
and uh get a lot of traction and we get

190
00:08:10,879 --> 00:08:11,520
a lot of

191
00:08:11,520 --> 00:08:13,680
feedback from researchers who are using

192
00:08:13,680 --> 00:08:14,610
it daily

193
00:08:14,610 --> 00:08:15,680
[Music]

194
00:08:15,680 --> 00:08:18,720
so what is actually motivation for this

195
00:08:18,720 --> 00:08:20,160
particular presentation

196
00:08:20,160 --> 00:08:24,240
and research behind so uh think about

197
00:08:24,240 --> 00:08:26,879
we have the hardware uh threat modeling

198
00:08:26,879 --> 00:08:29,039
firmware threat modeling and operating

199
00:08:29,039 --> 00:08:30,639
system thread modeling

200
00:08:30,639 --> 00:08:32,320
most of these thread models is

201
00:08:32,320 --> 00:08:34,080
disconnected from each other

202
00:08:34,080 --> 00:08:37,919
and basically as boot uh process going

203
00:08:37,919 --> 00:08:41,679
uh to the high um high level stacks on

204
00:08:41,679 --> 00:08:43,519
the operating system level

205
00:08:43,519 --> 00:08:45,920
then we gain much more signals for

206
00:08:45,920 --> 00:08:48,080
threat intelligence forensics

207
00:08:48,080 --> 00:08:51,360
and actually uh threat detection but

208
00:08:51,360 --> 00:08:54,399
if you go down to the stack it's much

209
00:08:54,399 --> 00:08:55,279
less

210
00:08:55,279 --> 00:08:59,360
signals is exist and actually produced

211
00:08:59,360 --> 00:09:02,240
so we have clearly lack of threat intel

212
00:09:02,240 --> 00:09:03,279
and forensics

213
00:09:03,279 --> 00:09:06,160
on the firmware level and threat and

214
00:09:06,160 --> 00:09:07,279
hardware

215
00:09:07,279 --> 00:09:11,440
level so in our research we try to fill

216
00:09:11,440 --> 00:09:12,080
the gap

217
00:09:12,080 --> 00:09:16,000
on the firmware level and give forensic

218
00:09:16,000 --> 00:09:19,600
and threat analysts very useful tool

219
00:09:19,600 --> 00:09:22,160
for simplifying research and save a lot

220
00:09:22,160 --> 00:09:24,560
of time

221
00:09:24,720 --> 00:09:27,760
okay and uh it's a good example

222
00:09:27,760 --> 00:09:31,200
actually from the firmware side it is

223
00:09:31,200 --> 00:09:34,560
a non-volatile memory actually

224
00:09:34,560 --> 00:09:37,040
if you're not familiar with ufi firmware

225
00:09:37,040 --> 00:09:38,000
it has a

226
00:09:38,000 --> 00:09:40,640
nvram storage for variables which is

227
00:09:40,640 --> 00:09:41,279
actually

228
00:09:41,279 --> 00:09:44,399
very powerful configuration data storage

229
00:09:44,399 --> 00:09:48,399
with a lot of information inside

230
00:09:48,399 --> 00:09:51,519
but also it's frequently used

231
00:09:51,519 --> 00:09:54,399
by operating system and hardware vendors

232
00:09:54,399 --> 00:09:56,320
to store

233
00:09:56,320 --> 00:10:00,160
very weird stuff by the way but also we

234
00:10:00,160 --> 00:10:04,079
know some cases where in vram variables

235
00:10:04,079 --> 00:10:05,120
being abused

236
00:10:05,120 --> 00:10:08,399
by firmware implants so okay

237
00:10:08,399 --> 00:10:11,920
and this uh picture actually demonstrate

238
00:10:11,920 --> 00:10:15,519
how boot flow transform access

239
00:10:15,519 --> 00:10:18,160
to environment variables access as

240
00:10:18,160 --> 00:10:19,760
example from

241
00:10:19,760 --> 00:10:22,720
platform initialization stage we have

242
00:10:22,720 --> 00:10:25,279
access to the firmware uh to the nvram

243
00:10:25,279 --> 00:10:28,480
storage and it's not actually split

244
00:10:28,480 --> 00:10:32,079
between level of access

245
00:10:32,079 --> 00:10:34,160
compared to the dixie phase where we

246
00:10:34,160 --> 00:10:35,519
have the interfaces

247
00:10:35,519 --> 00:10:38,560
uh for system management mode and

248
00:10:38,560 --> 00:10:42,000
uh for the dixie for the normal dxc

249
00:10:42,000 --> 00:10:44,800
and it's separated uh for with a

250
00:10:44,800 --> 00:10:47,040
different access privileges

251
00:10:47,040 --> 00:10:49,120
and of course we have operating system

252
00:10:49,120 --> 00:10:50,640
interfaces to get

253
00:10:50,640 --> 00:10:53,760
uh enumerate uh the firmware uh

254
00:10:53,760 --> 00:10:54,560
variables

255
00:10:54,560 --> 00:10:58,160
uh environ variables and actually

256
00:10:58,160 --> 00:11:01,279
these uh direct memory access uh

257
00:11:01,279 --> 00:11:04,480
you have enough power to basically

258
00:11:04,480 --> 00:11:07,120
avoid uh native operating system

259
00:11:07,120 --> 00:11:08,160
interface

260
00:11:08,160 --> 00:11:11,519
and uh understand what actually uh

261
00:11:11,519 --> 00:11:15,040
is missing or a hidden from

262
00:11:15,040 --> 00:11:17,440
operating system native interface

263
00:11:17,440 --> 00:11:18,720
because sometimes

264
00:11:18,720 --> 00:11:21,920
uh microsoft and some other vendors try

265
00:11:21,920 --> 00:11:23,760
to hide the variables

266
00:11:23,760 --> 00:11:26,959
accessible from native apis

267
00:11:26,959 --> 00:11:30,320
okay let's talk about environment as a

268
00:11:30,320 --> 00:11:31,279
persistent

269
00:11:31,279 --> 00:11:34,079
uh storage actually inveram variables

270
00:11:34,079 --> 00:11:35,600
have a two different

271
00:11:35,600 --> 00:11:38,399
types it is a runtime storage when it's

272
00:11:38,399 --> 00:11:39,040
stored

273
00:11:39,040 --> 00:11:42,720
you and accessible during um

274
00:11:42,720 --> 00:11:46,000
during operating system work and

275
00:11:46,000 --> 00:11:50,000
it's only accessible after

276
00:11:50,000 --> 00:11:52,959
operating after the system only when the

277
00:11:52,959 --> 00:11:54,079
system is running

278
00:11:54,079 --> 00:11:56,160
but we have a persistent storage on the

279
00:11:56,160 --> 00:11:57,279
spy flash

280
00:11:57,279 --> 00:12:00,079
where the variables is stored and it

281
00:12:00,079 --> 00:12:03,120
survives actually array board

282
00:12:03,120 --> 00:12:05,839
so uh in this storage we have enough

283
00:12:05,839 --> 00:12:06,720
variables

284
00:12:06,720 --> 00:12:10,000
which is create some dangerous uh attack

285
00:12:10,000 --> 00:12:13,519
surface and what is interesting

286
00:12:13,519 --> 00:12:16,320
these regions uh with environment

287
00:12:16,320 --> 00:12:17,600
persistent storage

288
00:12:17,600 --> 00:12:20,480
doesn't covered by intel boot guard and

289
00:12:20,480 --> 00:12:23,120
can be abused by the attacker with a

290
00:12:23,120 --> 00:12:25,360
physical access which is make very

291
00:12:25,360 --> 00:12:26,720
dangerous supply chain

292
00:12:26,720 --> 00:12:29,279
attack vector and arbitrary code

293
00:12:29,279 --> 00:12:30,320
execution

294
00:12:30,320 --> 00:12:32,880
over the get variable it's quite common

295
00:12:32,880 --> 00:12:33,760
and attack

296
00:12:33,760 --> 00:12:36,079
attacker can modify persistent

297
00:12:36,079 --> 00:12:37,680
environment storage variable

298
00:12:37,680 --> 00:12:41,519
to install fileless dxe smm or pi

299
00:12:41,519 --> 00:12:44,560
implant which is based on some shell

300
00:12:44,560 --> 00:12:45,600
code

301
00:12:45,600 --> 00:12:49,440
and not feasible on

302
00:12:49,440 --> 00:12:52,560
the driver driver level or

303
00:12:52,560 --> 00:12:56,000
basically it's hard to spot

304
00:12:56,000 --> 00:13:00,000
uh during execution or even sometimes

305
00:13:00,000 --> 00:13:03,440
runtime forensics so

306
00:13:03,440 --> 00:13:06,959
most security solutions inspect only ufi

307
00:13:06,959 --> 00:13:09,839
drivers but doesn't look on persistent

308
00:13:09,839 --> 00:13:11,040
nvram storage

309
00:13:11,040 --> 00:13:12,880
which is create a lot of interesting

310
00:13:12,880 --> 00:13:16,160
possibilities for the attacker

311
00:13:16,160 --> 00:13:20,880
as example uh platform length

312
00:13:20,880 --> 00:13:24,240
variable is quite common case because

313
00:13:24,240 --> 00:13:25,440
it's edk

314
00:13:25,440 --> 00:13:29,040
uh normal variable for uh language

315
00:13:29,040 --> 00:13:32,399
uh uh in like for choosing the language

316
00:13:32,399 --> 00:13:34,880
for the platform and

317
00:13:34,880 --> 00:13:37,120
on this screenshot we can see the issue

318
00:13:37,120 --> 00:13:38,079
where it's

319
00:13:38,079 --> 00:13:42,320
basically the size is now but

320
00:13:42,320 --> 00:13:45,360
we can control this size and platform

321
00:13:45,360 --> 00:13:47,680
variable is actually also can controlled

322
00:13:47,680 --> 00:13:48,320
by

323
00:13:48,320 --> 00:13:51,279
by the attacker we'll talk about this

324
00:13:51,279 --> 00:13:52,800
vectors a bit further

325
00:13:52,800 --> 00:13:55,199
and andrew will be covered with a lot of

326
00:13:55,199 --> 00:13:57,839
additional details

327
00:13:57,839 --> 00:14:01,120
also i want to shoot out to

328
00:14:01,120 --> 00:14:03,760
the researchers which is make some

329
00:14:03,760 --> 00:14:05,120
research about

330
00:14:05,120 --> 00:14:07,519
uh make uh environment runtime

331
00:14:07,519 --> 00:14:08,720
persistence

332
00:14:08,720 --> 00:14:12,320
not in spice uh storage but uh

333
00:14:12,320 --> 00:14:16,160
persistence enough for uh hiding from a

334
00:14:16,160 --> 00:14:20,800
modern edr solution and endpoints

335
00:14:20,800 --> 00:14:23,279
so pay attention on these links it's

336
00:14:23,279 --> 00:14:25,279
quite cool research there

337
00:14:25,279 --> 00:14:27,920
but also in vram persistent storage with

338
00:14:27,920 --> 00:14:29,680
the physical access to the target

339
00:14:29,680 --> 00:14:30,160
machine

340
00:14:30,160 --> 00:14:33,519
will was mention it in say

341
00:14:33,519 --> 00:14:36,639
vault 7 leaks before which is mean this

342
00:14:36,639 --> 00:14:38,480
vector is known for years

343
00:14:38,480 --> 00:14:40,600
and already abused

344
00:14:40,600 --> 00:14:42,639
[Music]

345
00:14:42,639 --> 00:14:44,800
very interesting work actually also will

346
00:14:44,800 --> 00:14:46,000
be

347
00:14:46,000 --> 00:14:48,320
discussed on this conference in uh

348
00:14:48,320 --> 00:14:49,760
arsenal session

349
00:14:49,760 --> 00:14:52,720
uh pay attention on e5 files because

350
00:14:52,720 --> 00:14:55,120
collaboration between e5 us

351
00:14:55,120 --> 00:14:59,360
and efi explorer it's very powerful

352
00:14:59,360 --> 00:15:02,560
and it's actually can used for

353
00:15:02,560 --> 00:15:06,000
a e5 fast can used for proof

354
00:15:06,000 --> 00:15:09,279
the findings potential findings found by

355
00:15:09,279 --> 00:15:12,880
efi explorer

356
00:15:12,880 --> 00:15:15,519
but if you talk about the fuzzing think

357
00:15:15,519 --> 00:15:18,399
about limitation of black box fuzzing

358
00:15:18,399 --> 00:15:21,360
of a file basically we have a code

359
00:15:21,360 --> 00:15:22,079
coverage

360
00:15:22,079 --> 00:15:26,160
based on feedback loop with a very

361
00:15:26,160 --> 00:15:28,800
limited static corpus and of course

362
00:15:28,800 --> 00:15:31,839
random input mutations

363
00:15:31,839 --> 00:15:34,160
having only initial knowledge and may

364
00:15:34,160 --> 00:15:35,120
need extra

365
00:15:35,120 --> 00:15:37,680
reverse engineering work to create more

366
00:15:37,680 --> 00:15:40,000
precise and violet corpus which

367
00:15:40,000 --> 00:15:43,120
is actually can be covered by efi

368
00:15:43,120 --> 00:15:44,000
explorer

369
00:15:44,000 --> 00:15:47,199
and platform simulation like cmx with

370
00:15:47,199 --> 00:15:49,440
combination of symbolic execution

371
00:15:49,440 --> 00:15:52,720
can fill this gap and provide

372
00:15:52,720 --> 00:15:56,000
more feedback loop and test coverage in

373
00:15:56,000 --> 00:15:57,519
general

374
00:15:57,519 --> 00:16:01,440
so i think um excite project from intel

375
00:16:01,440 --> 00:16:04,320
where i contribute in the previous years

376
00:16:04,320 --> 00:16:07,040
was very useful in this case

377
00:16:07,040 --> 00:16:09,519
and of course efi explorer can provide

378
00:16:09,519 --> 00:16:10,079
some

379
00:16:10,079 --> 00:16:11,839
coverage and helping with corpus

380
00:16:11,839 --> 00:16:15,759
generation for potential targets

381
00:16:16,959 --> 00:16:20,399
okay and few words about disclosure

382
00:16:20,399 --> 00:16:22,560
we have ongoing disclosure with with

383
00:16:22,560 --> 00:16:23,519
intel

384
00:16:23,519 --> 00:16:25,519
where nvidia offensive research is

385
00:16:25,519 --> 00:16:27,440
covered multiple vulnerabilities with

386
00:16:27,440 --> 00:16:28,240
get

387
00:16:28,240 --> 00:16:31,279
variable on different different levels

388
00:16:31,279 --> 00:16:34,320
but it's taken a while and

389
00:16:34,320 --> 00:16:37,519
this disclosure date will be something

390
00:16:37,519 --> 00:16:41,519
in april 2020 and i hope soon

391
00:16:41,519 --> 00:16:44,240
we can discuss more broadly these issues

392
00:16:44,240 --> 00:16:47,680
maybe on the next bloodhead

393
00:16:48,480 --> 00:16:50,240
thank you and i think andrew it's your

394
00:16:50,240 --> 00:16:52,639
turn continues this presentation

395
00:16:52,639 --> 00:16:55,920
thank you very much hello my name is

396
00:16:55,920 --> 00:16:57,600
andrei and i will talk about efi

397
00:16:57,600 --> 00:16:58,320
explorer

398
00:16:58,320 --> 00:17:00,079
and its automated vulnerability charge

399
00:17:00,079 --> 00:17:01,440
capability

400
00:17:01,440 --> 00:17:03,519
and how we do it to make sure that it

401
00:17:03,519 --> 00:17:04,559
works

402
00:17:04,559 --> 00:17:08,160
well at scale and how we make sure

403
00:17:08,160 --> 00:17:11,199
that our methodology is kind of sound to

404
00:17:11,199 --> 00:17:14,079
the best of what we can do

405
00:17:14,079 --> 00:17:16,160
first let's talk about the data sets and

406
00:17:16,160 --> 00:17:18,480
type of data we collected we have

407
00:17:18,480 --> 00:17:22,160
uh ice rock about 400 of firmware images

408
00:17:22,160 --> 00:17:23,280
we have associated

409
00:17:23,280 --> 00:17:26,160
a little bit more close to 1000 from our

410
00:17:26,160 --> 00:17:26,959
images

411
00:17:26,959 --> 00:17:29,600
and we have lino about 84 from our

412
00:17:29,600 --> 00:17:31,120
images total

413
00:17:31,120 --> 00:17:33,840
all of them were released in 2020 which

414
00:17:33,840 --> 00:17:34,320
means

415
00:17:34,320 --> 00:17:36,720
that if we find the security issues

416
00:17:36,720 --> 00:17:37,840
there

417
00:17:37,840 --> 00:17:40,720
it's likely valid and it exists and it's

418
00:17:40,720 --> 00:17:41,919
pretty much of a concern

419
00:17:41,919 --> 00:17:46,640
for for users which rely on that product

420
00:17:46,640 --> 00:17:48,320
we use three types of measurements in

421
00:17:48,320 --> 00:17:50,320
order to understand how well is ufi

422
00:17:50,320 --> 00:17:53,520
explorer is doing its job

423
00:17:53,520 --> 00:17:55,520
first we measured object recognition

424
00:17:55,520 --> 00:17:57,360
such as boot services and runtime

425
00:17:57,360 --> 00:17:58,480
services

426
00:17:58,480 --> 00:18:00,240
if you want to get more information

427
00:18:00,240 --> 00:18:01,840
about how we

428
00:18:01,840 --> 00:18:06,080
measured basically um that

429
00:18:06,080 --> 00:18:09,280
fundamental components recovery how

430
00:18:09,280 --> 00:18:11,919
well is if i explorer is doing its kind

431
00:18:11,919 --> 00:18:12,320
of

432
00:18:12,320 --> 00:18:14,960
baseline things you can take a look at

433
00:18:14,960 --> 00:18:16,640
our echo party presentation

434
00:18:16,640 --> 00:18:19,120
let us know if you have any feedback

435
00:18:19,120 --> 00:18:20,080
reach out to us

436
00:18:20,080 --> 00:18:23,120
and feel free to

437
00:18:23,120 --> 00:18:25,840
investigate and inspect it if you want

438
00:18:25,840 --> 00:18:27,760
to get additional

439
00:18:27,760 --> 00:18:30,320
information about our measurements this

440
00:18:30,320 --> 00:18:31,919
part is unfortunately

441
00:18:31,919 --> 00:18:33,280
a little bit out of scope of this

442
00:18:33,280 --> 00:18:36,320
research two things at the bottom

443
00:18:36,320 --> 00:18:38,880
are in scope of the research measuring

444
00:18:38,880 --> 00:18:40,720
attack surface and running automated

445
00:18:40,720 --> 00:18:43,679
vulnerability scanners

446
00:18:43,679 --> 00:18:45,760
we will present those numbers later and

447
00:18:45,760 --> 00:18:47,760
this is what we collected for

448
00:18:47,760 --> 00:18:49,919
all of the vendors and this is what we

449
00:18:49,919 --> 00:18:51,280
collected per

450
00:18:51,280 --> 00:18:55,039
face per boot per boot face such as

451
00:18:55,039 --> 00:18:59,120
dc smm and platform initiation

452
00:18:59,120 --> 00:19:02,480
now let's talk about each vulnerability

453
00:19:02,480 --> 00:19:05,919
pattern we start from smm call out

454
00:19:05,919 --> 00:19:08,160
this is a well-known attack vector it's

455
00:19:08,160 --> 00:19:10,000
well known for years

456
00:19:10,000 --> 00:19:13,120
and um it unfortunately retains

457
00:19:13,120 --> 00:19:16,720
its significant place in the security

458
00:19:16,720 --> 00:19:20,080
oh that's it's well known unfortunately

459
00:19:20,080 --> 00:19:21,600
oh hopefully depending on

460
00:19:21,600 --> 00:19:24,799
your point of view to understand what it

461
00:19:24,799 --> 00:19:25,120
is

462
00:19:25,120 --> 00:19:26,960
you should know that there's my hander

463
00:19:26,960 --> 00:19:28,160
this is something

464
00:19:28,160 --> 00:19:31,840
kind of a function handler

465
00:19:31,840 --> 00:19:34,240
part of the interface communication

466
00:19:34,240 --> 00:19:36,000
interface between operating system

467
00:19:36,000 --> 00:19:39,360
and the smram and if

468
00:19:39,360 --> 00:19:42,559
a code inside smm

469
00:19:42,640 --> 00:19:46,400
run tries to dereference the

470
00:19:46,400 --> 00:19:49,600
drt pointer or gps pointer bad things

471
00:19:49,600 --> 00:19:51,600
can happen for one reason

472
00:19:51,600 --> 00:19:55,280
those tables do not guarantee to exist

473
00:19:55,280 --> 00:19:58,000
after the exit build services is called

474
00:19:58,000 --> 00:19:58,799
and

475
00:19:58,799 --> 00:20:02,880
basically this memory is under control

476
00:20:02,880 --> 00:20:05,200
of the attacker if we assume attacker

477
00:20:05,200 --> 00:20:07,600
is for example coming from an operating

478
00:20:07,600 --> 00:20:09,520
system trying to escalate privilege

479
00:20:09,520 --> 00:20:13,600
to bring -2 or whatever you call it

480
00:20:13,600 --> 00:20:16,320
if this happens then this is a

481
00:20:16,320 --> 00:20:17,520
vulnerability which

482
00:20:17,520 --> 00:20:19,600
attacker can take advantage of how do we

483
00:20:19,600 --> 00:20:21,760
find it this more important question how

484
00:20:21,760 --> 00:20:24,080
do we find it statically

485
00:20:24,080 --> 00:20:26,880
well we just iterate through all the smi

486
00:20:26,880 --> 00:20:27,520
handlers

487
00:20:27,520 --> 00:20:29,919
tries try to find all the references to

488
00:20:29,919 --> 00:20:31,360
those variables

489
00:20:31,360 --> 00:20:33,919
and once we find it we flag it for the

490
00:20:33,919 --> 00:20:36,640
manual review

491
00:20:37,120 --> 00:20:41,120
and sounds like relatively simple

492
00:20:41,120 --> 00:20:43,360
but that requires a lot of static

493
00:20:43,360 --> 00:20:46,159
analysis beforehand

494
00:20:46,159 --> 00:20:49,200
here's how the uh registration of smi

495
00:20:49,200 --> 00:20:52,000
handler is happening inside of firmware

496
00:20:52,000 --> 00:20:54,480
you can see the legit firmware

497
00:20:54,480 --> 00:20:55,360
registering as

498
00:20:55,360 --> 00:20:57,360
my handler so it's just a matter of

499
00:20:57,360 --> 00:20:59,679
calling smms of activate dispatch

500
00:20:59,679 --> 00:21:01,520
protocol and then get an interface and

501
00:21:01,520 --> 00:21:03,120
then actually call in a

502
00:21:03,120 --> 00:21:06,400
register where the source in my handler

503
00:21:06,400 --> 00:21:07,120
is just a

504
00:21:07,120 --> 00:21:10,480
argument it's a pointer to a function

505
00:21:10,480 --> 00:21:12,559
we are able to analyze those constructs

506
00:21:12,559 --> 00:21:14,640
and then extract the argument and from

507
00:21:14,640 --> 00:21:16,320
there we understand that this is

508
00:21:16,320 --> 00:21:18,640
an smile handler this thing points to a

509
00:21:18,640 --> 00:21:19,440
function

510
00:21:19,440 --> 00:21:21,840
which is a function of interest in any

511
00:21:21,840 --> 00:21:23,360
way

512
00:21:23,360 --> 00:21:25,360
this is exactly the same code but in

513
00:21:25,360 --> 00:21:26,400
decompiled form

514
00:21:26,400 --> 00:21:28,880
pretty straightforward register is my

515
00:21:28,880 --> 00:21:30,000
order

516
00:21:30,000 --> 00:21:32,240
from there we know this function is my

517
00:21:32,240 --> 00:21:34,640
handler now how we find vulnerabilities

518
00:21:34,640 --> 00:21:36,000
i would say potential security

519
00:21:36,000 --> 00:21:36,880
vulnerabilities

520
00:21:36,880 --> 00:21:39,280
there we just iteratively and

521
00:21:39,280 --> 00:21:40,400
recursively go

522
00:21:40,400 --> 00:21:41,840
through all the functions from that as

523
00:21:41,840 --> 00:21:44,000
my under and

524
00:21:44,000 --> 00:21:47,360
find references to drt or gps

525
00:21:47,360 --> 00:21:49,520
runtime services pointer or boot

526
00:21:49,520 --> 00:21:51,280
services pointer

527
00:21:51,280 --> 00:21:53,120
question is how do we know where they

528
00:21:53,120 --> 00:21:54,480
are located well

529
00:21:54,480 --> 00:21:56,559
is because efi explorer is able to

530
00:21:56,559 --> 00:21:58,320
collect them beforehand

531
00:21:58,320 --> 00:22:00,320
and we store them separately and we just

532
00:22:00,320 --> 00:22:02,880
compare whether

533
00:22:02,880 --> 00:22:04,880
these dereference is dereferencing

534
00:22:04,880 --> 00:22:06,559
actually a memory

535
00:22:06,559 --> 00:22:10,080
we know already is marked as

536
00:22:10,080 --> 00:22:13,280
gbs or team the algorithms are pretty

537
00:22:13,280 --> 00:22:13,840
similar

538
00:22:13,840 --> 00:22:16,000
[Music]

539
00:22:16,000 --> 00:22:18,000
with one additional step you can also

540
00:22:18,000 --> 00:22:19,679
get the same information for the whole

541
00:22:19,679 --> 00:22:20,240
image

542
00:22:20,240 --> 00:22:24,320
versus just for a single driver

543
00:22:24,799 --> 00:22:27,280
we we can use fix loader which

544
00:22:27,280 --> 00:22:28,720
interactively goes through all the

545
00:22:28,720 --> 00:22:30,640
drivers and does the same thing

546
00:22:30,640 --> 00:22:33,120
and from there you get sms mi handlers

547
00:22:33,120 --> 00:22:35,039
from the whole firmware

548
00:22:35,039 --> 00:22:37,280
what's new and what's interesting there

549
00:22:37,280 --> 00:22:38,480
uh compared to

550
00:22:38,480 --> 00:22:41,760
what existed before is that we do that

551
00:22:41,760 --> 00:22:44,080
statically without running firmware

552
00:22:44,080 --> 00:22:47,360
just by having a firmware damp another

553
00:22:47,360 --> 00:22:49,360
way of doing that is for example

554
00:22:49,360 --> 00:22:53,200
to find a vulnerability let's say in

555
00:22:53,200 --> 00:22:56,240
um it is my handler or in

556
00:22:56,240 --> 00:23:00,240
uh whatever and then execute code in

557
00:23:00,240 --> 00:23:03,280
uh as environment and and then take this

558
00:23:03,280 --> 00:23:04,240
and run dump

559
00:23:04,240 --> 00:23:06,400
extract it and find this in my handlers

560
00:23:06,400 --> 00:23:08,480
from from the memory

561
00:23:08,480 --> 00:23:11,360
we approach the same thing but slightly

562
00:23:11,360 --> 00:23:13,760
from a different perspective

563
00:23:13,760 --> 00:23:17,440
just we do that statically and it works

564
00:23:19,039 --> 00:23:21,440
speaking about the numbers i would say

565
00:23:21,440 --> 00:23:22,320
that

566
00:23:22,320 --> 00:23:25,360
leonardo is actually relatively

567
00:23:25,360 --> 00:23:28,880
good at a dark surface the number

568
00:23:28,880 --> 00:23:31,919
the average number of smi handler

569
00:23:31,919 --> 00:23:33,919
is my hundreds per firmware in case of

570
00:23:33,919 --> 00:23:36,000
linoa is only 20.

571
00:23:36,000 --> 00:23:38,880
but ice rock analysis are slightly

572
00:23:38,880 --> 00:23:40,080
slightly

573
00:23:40,080 --> 00:23:42,480
worse with with respect to that mandrake

574
00:23:42,480 --> 00:23:44,400
we chose and with respect to how we

575
00:23:44,400 --> 00:23:45,919
collected

576
00:23:45,919 --> 00:23:48,960
and lenovo is also relatively good with

577
00:23:48,960 --> 00:23:50,080
respect to magic

578
00:23:50,080 --> 00:23:51,919
of the number of potentially triggered

579
00:23:51,919 --> 00:23:54,320
asymmetrical laws

580
00:23:54,320 --> 00:23:56,000
however we found a few interesting

581
00:23:56,000 --> 00:24:00,159
things in our data sets

582
00:24:00,159 --> 00:24:02,880
we still work on that vulnerability it's

583
00:24:02,880 --> 00:24:04,799
in process of disclosure

584
00:24:04,799 --> 00:24:07,840
but it's a straightforward call out this

585
00:24:07,840 --> 00:24:08,480
is

586
00:24:08,480 --> 00:24:11,520
smi handler from

587
00:24:11,520 --> 00:24:14,159
from one of the firmwares it uses a read

588
00:24:14,159 --> 00:24:15,360
save state to

589
00:24:15,360 --> 00:24:18,000
read registers which are controlled by

590
00:24:18,000 --> 00:24:18,960
attacker

591
00:24:18,960 --> 00:24:20,880
and then depending on the values of the

592
00:24:20,880 --> 00:24:22,799
registers there's

593
00:24:22,799 --> 00:24:25,120
a lot of code we just skipped because

594
00:24:25,120 --> 00:24:26,400
there's a

595
00:24:26,400 --> 00:24:30,080
very very long switch statement

596
00:24:30,080 --> 00:24:33,840
and once it goes inside

597
00:24:35,760 --> 00:24:38,720
inside one of the locations depending on

598
00:24:38,720 --> 00:24:40,799
the value of v45

599
00:24:40,799 --> 00:24:43,360
it just mistakenly tries to deliver a

600
00:24:43,360 --> 00:24:44,480
grt

601
00:24:44,480 --> 00:24:46,640
it's probably god which might have been

602
00:24:46,640 --> 00:24:48,080
forgotten or

603
00:24:48,080 --> 00:24:49,919
maybe left by mistake or something like

604
00:24:49,919 --> 00:24:51,279
that

605
00:24:51,279 --> 00:24:54,559
but there's nothing great in that

606
00:24:54,559 --> 00:24:57,120
let's talk about get variable patterns

607
00:24:57,120 --> 00:24:59,600
uh we investigate this situation

608
00:24:59,600 --> 00:25:04,240
from three angles we try to understand

609
00:25:04,240 --> 00:25:07,760
get variable calls from the smm phase

610
00:25:07,760 --> 00:25:09,360
from the dixie phase and from the

611
00:25:09,360 --> 00:25:11,440
platform initialization stage

612
00:25:11,440 --> 00:25:14,320
and later we will tell how different is

613
00:25:14,320 --> 00:25:15,200
the situation

614
00:25:15,200 --> 00:25:18,320
at all of the boot stages and

615
00:25:18,320 --> 00:25:20,720
of course this attack vector and

616
00:25:20,720 --> 00:25:22,799
security vulnerability is well known for

617
00:25:22,799 --> 00:25:24,080
many years

618
00:25:24,080 --> 00:25:26,080
but we just try to investigate something

619
00:25:26,080 --> 00:25:29,440
which is which is still

620
00:25:29,440 --> 00:25:32,640
still valid still relevant and

621
00:25:32,640 --> 00:25:34,799
try to understand and infer some

622
00:25:34,799 --> 00:25:36,000
information about how

623
00:25:36,000 --> 00:25:38,799
vendors are doing

624
00:25:39,360 --> 00:25:42,559
and what is uh the state of the security

625
00:25:42,559 --> 00:25:43,039
in

626
00:25:43,039 --> 00:25:46,240
in that regard and if we try to cut it

627
00:25:46,240 --> 00:25:49,919
in that dimension so before we go to

628
00:25:49,919 --> 00:25:52,240
um the explanation of our vulnerability

629
00:25:52,240 --> 00:25:53,919
checkers let's take a look at the cat

630
00:25:53,919 --> 00:25:54,480
variable

631
00:25:54,480 --> 00:25:57,600
the variable is the standard edk2

632
00:25:57,600 --> 00:25:58,880
library code

633
00:25:58,880 --> 00:26:01,679
you can find it freely just by going to

634
00:26:01,679 --> 00:26:04,799
adk your repository

635
00:26:04,799 --> 00:26:07,840
one slight thing which might be not

636
00:26:07,840 --> 00:26:09,600
immediately obvious

637
00:26:09,600 --> 00:26:12,960
or might be misunderstood sometimes

638
00:26:12,960 --> 00:26:17,520
somewhere it is that this function takes

639
00:26:17,520 --> 00:26:19,520
a few arguments including data and data

640
00:26:19,520 --> 00:26:20,640
size

641
00:26:20,640 --> 00:26:24,159
both of them come as pointers and data

642
00:26:24,159 --> 00:26:25,600
size

643
00:26:25,600 --> 00:26:29,440
is a pointer which is updated even if

644
00:26:29,440 --> 00:26:32,400
the data is not being copied in the case

645
00:26:32,400 --> 00:26:32,799
if

646
00:26:32,799 --> 00:26:36,000
the function tries to get and we're

647
00:26:36,000 --> 00:26:38,640
unvariable and then sees that the

648
00:26:38,640 --> 00:26:41,760
environment variable is larger than the

649
00:26:41,760 --> 00:26:43,520
value of the data size which is being

650
00:26:43,520 --> 00:26:44,960
supplied as an argument

651
00:26:44,960 --> 00:26:47,919
it returns an error yes but at the same

652
00:26:47,919 --> 00:26:48,960
time it updates

653
00:26:48,960 --> 00:26:51,919
data size and that thing might not be

654
00:26:51,919 --> 00:26:53,120
immediately

655
00:26:53,120 --> 00:26:56,799
immediately clear to

656
00:26:56,799 --> 00:27:01,120
in some situations um anyway

657
00:27:01,120 --> 00:27:04,400
and using that information how do we

658
00:27:04,400 --> 00:27:06,799
find potential security vulnerabilities

659
00:27:06,799 --> 00:27:08,640
well we just started from something

660
00:27:08,640 --> 00:27:10,320
simple

661
00:27:10,320 --> 00:27:13,360
let's just try to find sequences of

662
00:27:13,360 --> 00:27:16,320
two get variables in a row which use the

663
00:27:16,320 --> 00:27:17,520
same data size

664
00:27:17,520 --> 00:27:20,159
and which is not initialized and see

665
00:27:20,159 --> 00:27:21,840
what it yields us

666
00:27:21,840 --> 00:27:24,240
and surprisingly this pattern works

667
00:27:24,240 --> 00:27:25,200
pretty well

668
00:27:25,200 --> 00:27:27,200
we were able to find a lot of

669
00:27:27,200 --> 00:27:29,760
interesting things in our

670
00:27:29,760 --> 00:27:32,559
data sets here is the output of our

671
00:27:32,559 --> 00:27:34,640
static analyzer

672
00:27:34,640 --> 00:27:38,240
you can see where the condition

673
00:27:38,240 --> 00:27:41,360
is met condition consisting of three

674
00:27:41,360 --> 00:27:42,640
different things

675
00:27:42,640 --> 00:27:45,279
when all of them together not true

676
00:27:45,279 --> 00:27:47,440
static analyzer returns a result for us

677
00:27:47,440 --> 00:27:51,039
for a later manual investigation

678
00:27:51,039 --> 00:27:52,559
this is an example of what could

679
00:27:52,559 --> 00:27:54,480
possibly happen well

680
00:27:54,480 --> 00:27:58,559
not not quite possibly sometimes

681
00:27:58,559 --> 00:28:00,000
this is what actually happens in the

682
00:28:00,000 --> 00:28:02,000
firmware like in this case

683
00:28:02,000 --> 00:28:06,240
there is a data variable straight

684
00:28:06,240 --> 00:28:09,279
statically sized data

685
00:28:09,279 --> 00:28:12,240
on a stack and there are two get

686
00:28:12,240 --> 00:28:14,080
variable calls

687
00:28:14,080 --> 00:28:17,200
one of them calls uh tries to get

688
00:28:17,200 --> 00:28:20,480
the value of the nvr variable then it

689
00:28:20,480 --> 00:28:21,520
checks that

690
00:28:21,520 --> 00:28:23,840
whether the ufi buffer too small is

691
00:28:23,840 --> 00:28:24,960
returned

692
00:28:24,960 --> 00:28:27,600
but then it never checks that the

693
00:28:27,600 --> 00:28:29,520
updated data size

694
00:28:29,520 --> 00:28:33,360
is actually is smaller than the

695
00:28:33,360 --> 00:28:37,440
actual amount of data which is

696
00:28:37,440 --> 00:28:38,960
allocated on the stack for the data

697
00:28:38,960 --> 00:28:40,880
variable if this variable

698
00:28:40,880 --> 00:28:43,679
is controlled by an attacker then this

699
00:28:43,679 --> 00:28:44,000
is

700
00:28:44,000 --> 00:28:45,840
going to be a very straightforward

701
00:28:45,840 --> 00:28:47,760
buffer overflow

702
00:28:47,760 --> 00:28:50,640
speaking of security um speaking of

703
00:28:50,640 --> 00:28:52,640
exploitation primitive this primitive is

704
00:28:52,640 --> 00:28:54,000
pretty much powerful

705
00:28:54,000 --> 00:28:58,000
because it allows tech overwrite and

706
00:28:58,000 --> 00:29:01,120
the length is controlled and the contact

707
00:29:01,120 --> 00:29:02,240
is controlled

708
00:29:02,240 --> 00:29:05,679
something which does not always happen

709
00:29:05,679 --> 00:29:07,520
and when it happens it gives a lot to an

710
00:29:07,520 --> 00:29:08,160
attacker

711
00:29:08,160 --> 00:29:09,840
[Music]

712
00:29:09,840 --> 00:29:12,960
here is what might also go wrong when

713
00:29:12,960 --> 00:29:16,320
the same data size is being used

714
00:29:16,320 --> 00:29:18,399
to retrieve the values of two different

715
00:29:18,399 --> 00:29:19,760
variable names

716
00:29:19,760 --> 00:29:23,520
and if this data size

717
00:29:23,520 --> 00:29:28,080
is not re-initialized and then if also

718
00:29:28,080 --> 00:29:31,600
there is no logic which would

719
00:29:31,600 --> 00:29:34,000
skip all the later processing and stop

720
00:29:34,000 --> 00:29:35,679
all the later get variables

721
00:29:35,679 --> 00:29:38,559
when buffer too small is returned then

722
00:29:38,559 --> 00:29:40,240
bad things can happen

723
00:29:40,240 --> 00:29:42,480
so the first call will implicitly update

724
00:29:42,480 --> 00:29:43,520
the data size

725
00:29:43,520 --> 00:29:46,240
will not do anything but the second call

726
00:29:46,240 --> 00:29:48,159
will actually do something

727
00:29:48,159 --> 00:29:51,039
um useful for an attacker and something

728
00:29:51,039 --> 00:29:51,919
dangerous for

729
00:29:51,919 --> 00:29:55,039
the end user and maybe something

730
00:29:55,039 --> 00:29:57,039
not very interesting not very exciting

731
00:29:57,039 --> 00:29:59,279
to investigate for the vendor

732
00:29:59,279 --> 00:30:02,720
i mean speaking easily there's going to

733
00:30:02,720 --> 00:30:05,679
be a security vulnerability

734
00:30:05,679 --> 00:30:08,240
if we talk about numbers i would say get

735
00:30:08,240 --> 00:30:09,919
variable

736
00:30:09,919 --> 00:30:13,919
in its initial straightforward form

737
00:30:13,919 --> 00:30:16,720
and dixie stage as a part of runtime

738
00:30:16,720 --> 00:30:17,810
services

739
00:30:17,810 --> 00:30:19,200
[Music]

740
00:30:19,200 --> 00:30:22,960
run services table speaking of that

741
00:30:22,960 --> 00:30:25,039
the attack surface is quite large i

742
00:30:25,039 --> 00:30:27,120
would say it's quite massive

743
00:30:27,120 --> 00:30:31,279
ice rock asus and we know

744
00:30:31,279 --> 00:30:33,039
has a massive number of calls in the

745
00:30:33,039 --> 00:30:34,320
dixie stage

746
00:30:34,320 --> 00:30:36,799
the lower is slightly better at the

747
00:30:36,799 --> 00:30:37,760
attack surface

748
00:30:37,760 --> 00:30:40,640
if you look at this metric but it's

749
00:30:40,640 --> 00:30:41,520
slightly

750
00:30:41,520 --> 00:30:44,240
uh worse than ice rock and asus if you

751
00:30:44,240 --> 00:30:46,080
take a look at the metric

752
00:30:46,080 --> 00:30:48,640
of a number of potential security

753
00:30:48,640 --> 00:30:50,000
vulnerabilities triggered by

754
00:30:50,000 --> 00:30:53,200
our static analyzer i'll be

755
00:30:53,200 --> 00:30:56,480
straight here that this

756
00:30:56,480 --> 00:30:59,840
this pattern of course is like any any

757
00:30:59,840 --> 00:31:00,159
of

758
00:31:00,159 --> 00:31:03,519
our buttons requiring a manual review

759
00:31:03,519 --> 00:31:06,080
so not all of them are immediately

760
00:31:06,080 --> 00:31:08,720
exploitable security vulnerabilities

761
00:31:08,720 --> 00:31:11,600
but a lot of them when we tried them

762
00:31:11,600 --> 00:31:13,039
turn out to be

763
00:31:13,039 --> 00:31:15,039
pretty straightforward security issues

764
00:31:15,039 --> 00:31:16,159
indeed

765
00:31:16,159 --> 00:31:19,840
not all but many of them

766
00:31:19,919 --> 00:31:23,039
um the example

767
00:31:23,039 --> 00:31:26,720
we show here is again straightforward

768
00:31:26,720 --> 00:31:30,000
almost textbook buffer of law this

769
00:31:30,000 --> 00:31:33,519
this code is taken from one driver which

770
00:31:33,519 --> 00:31:35,519
belongs to one of the vendors

771
00:31:35,519 --> 00:31:38,799
the data here is again stack variable

772
00:31:38,799 --> 00:31:42,159
statically sized this

773
00:31:42,159 --> 00:31:45,919
environment variable which is

774
00:31:46,399 --> 00:31:49,919
being read is platform link and the data

775
00:31:49,919 --> 00:31:50,480
size

776
00:31:50,480 --> 00:31:53,760
is being implicitly updated however

777
00:31:53,760 --> 00:31:57,760
no one checks this data size is actually

778
00:31:57,760 --> 00:32:00,640
less or equal than the number of bytes

779
00:32:00,640 --> 00:32:01,519
available

780
00:32:01,519 --> 00:32:05,039
than the size of the data on the stack

781
00:32:06,399 --> 00:32:08,640
the same situation with get variable

782
00:32:08,640 --> 00:32:10,480
happens on the smn stage

783
00:32:10,480 --> 00:32:12,399
there is a special protocol called efi

784
00:32:12,399 --> 00:32:15,200
smm variable protocol

785
00:32:15,200 --> 00:32:18,240
and it's just a matter of getting that

786
00:32:18,240 --> 00:32:18,799
protocol

787
00:32:18,799 --> 00:32:21,360
and then

788
00:32:21,919 --> 00:32:26,159
using that point of that protocol as a

789
00:32:26,159 --> 00:32:29,600
table to pointer a table to functions

790
00:32:29,600 --> 00:32:31,360
and then using some get variable

791
00:32:31,360 --> 00:32:32,960
function or other functions

792
00:32:32,960 --> 00:32:35,279
pretty straightforward additional step

793
00:32:35,279 --> 00:32:36,159
is just

794
00:32:36,159 --> 00:32:40,399
to one nested one nested step

795
00:32:40,399 --> 00:32:42,799
is to find those interfaces and to

796
00:32:42,799 --> 00:32:44,960
understand this is actually

797
00:32:44,960 --> 00:32:47,760
a cement variable protocol once we do

798
00:32:47,760 --> 00:32:48,159
that

799
00:32:48,159 --> 00:32:51,279
the algorithm of how we find and

800
00:32:51,279 --> 00:32:53,039
check that this is a potential security

801
00:32:53,039 --> 00:32:54,480
vulnerability

802
00:32:54,480 --> 00:32:56,960
is exactly the same as before just see

803
00:32:56,960 --> 00:32:59,120
that there is a sequence of two

804
00:32:59,120 --> 00:33:01,840
uh get variable calls using the same

805
00:33:01,840 --> 00:33:02,799
data size

806
00:33:02,799 --> 00:33:04,559
uh reference in the same data size

807
00:33:04,559 --> 00:33:06,880
argument which is not initialized

808
00:33:06,880 --> 00:33:10,080
and see what it yields us again this is

809
00:33:10,080 --> 00:33:13,200
the output of our static analyzer this

810
00:33:13,200 --> 00:33:14,240
is an example

811
00:33:14,240 --> 00:33:17,600
what could go wrong for example

812
00:33:17,600 --> 00:33:20,480
if there is a sequence of two calls

813
00:33:20,480 --> 00:33:21,919
which

814
00:33:21,919 --> 00:33:25,679
obtain same or different variable names

815
00:33:25,679 --> 00:33:27,679
and this data size is

816
00:33:27,679 --> 00:33:30,880
implicitly updated updated underneath by

817
00:33:30,880 --> 00:33:32,720
the edk library code

818
00:33:32,720 --> 00:33:35,120
and this behavior is not properly

819
00:33:35,120 --> 00:33:36,799
handled this results in a

820
00:33:36,799 --> 00:33:40,640
buffer or fall whether it's a

821
00:33:40,640 --> 00:33:43,679
buffer or a stack or buffer on a heap

822
00:33:43,679 --> 00:33:46,320
in this context this doesn't matter much

823
00:33:46,320 --> 00:33:47,679
but it's just

824
00:33:47,679 --> 00:33:49,840
going to cause out of bound right

825
00:33:49,840 --> 00:33:51,279
whatever

826
00:33:51,279 --> 00:33:54,080
place the data is allocated at more

827
00:33:54,080 --> 00:33:54,799
interesting

828
00:33:54,799 --> 00:33:57,840
is the statistics uh we noticed that the

829
00:33:57,840 --> 00:33:58,880
smm

830
00:33:58,880 --> 00:34:01,039
which as you remember um quite a

831
00:34:01,039 --> 00:34:02,399
privileged place

832
00:34:02,399 --> 00:34:05,279
um like thinkably you should should

833
00:34:05,279 --> 00:34:06,640
probably as a vendor should probably

834
00:34:06,640 --> 00:34:07,760
protect it

835
00:34:07,760 --> 00:34:10,079
and this is kind of from that

836
00:34:10,079 --> 00:34:11,918
perspective this is what probably

837
00:34:11,918 --> 00:34:13,280
happening because

838
00:34:13,280 --> 00:34:15,359
if we compare that with the amount of

839
00:34:15,359 --> 00:34:17,599
get variable calls on a dixie stage from

840
00:34:17,599 --> 00:34:21,119
runtime services the uh the average

841
00:34:21,119 --> 00:34:22,079
number

842
00:34:22,079 --> 00:34:25,359
that num amount of attack surface is

843
00:34:25,359 --> 00:34:26,879
quite smaller and the amount of

844
00:34:26,879 --> 00:34:28,399
potential security vulnerabilities

845
00:34:28,399 --> 00:34:29,199
triggered

846
00:34:29,199 --> 00:34:32,560
is near zero for example it's

847
00:34:32,560 --> 00:34:34,560
i think literally zero cases for ice

848
00:34:34,560 --> 00:34:36,000
rock and for

849
00:34:36,000 --> 00:34:39,119
us it's something like three cases per

850
00:34:39,119 --> 00:34:42,239
800 firmers so it's

851
00:34:42,239 --> 00:34:45,280
going to be a few

852
00:34:45,280 --> 00:34:48,320
one zero point

853
00:34:48,320 --> 00:34:51,280
i think something like that i fully know

854
00:34:51,280 --> 00:34:51,760
it's

855
00:34:51,760 --> 00:34:55,760
average number is about is about one

856
00:34:55,760 --> 00:34:58,800
one vulnerability pattern per firmware

857
00:34:58,800 --> 00:35:00,800
[Music]

858
00:35:00,800 --> 00:35:04,320
as for the results what we found this is

859
00:35:04,320 --> 00:35:07,520
a real code from the real firmware from

860
00:35:07,520 --> 00:35:09,680
the 2020

861
00:35:09,680 --> 00:35:15,280
or near that in somewhere in 2020

862
00:35:15,280 --> 00:35:19,520
um it is an um

863
00:35:19,520 --> 00:35:21,280
i think a well-known product and the

864
00:35:21,280 --> 00:35:23,280
situation happening here

865
00:35:23,280 --> 00:35:25,920
is exactly as we explained before

866
00:35:25,920 --> 00:35:27,599
there's a data size

867
00:35:27,599 --> 00:35:30,240
it is initialized once but then this

868
00:35:30,240 --> 00:35:30,880
value

869
00:35:30,880 --> 00:35:32,880
on a stack is implicitly updated with

870
00:35:32,880 --> 00:35:34,160
the first call

871
00:35:34,160 --> 00:35:38,000
and no one checks that this

872
00:35:38,190 --> 00:35:39,440
[Music]

873
00:35:39,440 --> 00:35:41,280
the situation is happening no one checks

874
00:35:41,280 --> 00:35:42,960
the data size is updated

875
00:35:42,960 --> 00:35:46,079
and the second call calls

876
00:35:46,079 --> 00:35:49,599
overflow data and data variable

877
00:35:49,599 --> 00:35:52,160
now platform incentivation stage what

878
00:35:52,160 --> 00:35:53,760
happens with the get variable and how

879
00:35:53,760 --> 00:35:55,359
get variable works

880
00:35:55,359 --> 00:35:58,880
is kind of very very similar to what we

881
00:35:58,880 --> 00:36:00,160
know

882
00:36:00,160 --> 00:36:04,320
from from the explanation before

883
00:36:04,320 --> 00:36:07,280
however this attack vector is we believe

884
00:36:07,280 --> 00:36:07,599
it's

885
00:36:07,599 --> 00:36:10,410
under slightly under research

886
00:36:10,410 --> 00:36:11,760
[Music]

887
00:36:11,760 --> 00:36:15,440
and it works very similar to smm

888
00:36:15,440 --> 00:36:17,440
there is a ppi which is also an

889
00:36:17,440 --> 00:36:19,599
interface as a developer you get that

890
00:36:19,599 --> 00:36:20,480
interface

891
00:36:20,480 --> 00:36:22,480
and then user interface to call things

892
00:36:22,480 --> 00:36:26,640
like get variable and things like that

893
00:36:26,640 --> 00:36:29,440
um again how we find the security

894
00:36:29,440 --> 00:36:31,280
vulnerability related to that

895
00:36:31,280 --> 00:36:34,560
well the hard part is to

896
00:36:34,560 --> 00:36:37,680
get all of those get variable goals by

897
00:36:37,680 --> 00:36:40,960
locating all the places where

898
00:36:40,960 --> 00:36:44,079
pii services is used to obtain that

899
00:36:44,079 --> 00:36:45,599
interface and then

900
00:36:45,599 --> 00:36:47,839
transfer that interface somewhere and

901
00:36:47,839 --> 00:36:49,839
then using that interface

902
00:36:49,839 --> 00:36:54,960
as a as a table of

903
00:36:54,960 --> 00:36:57,200
function pointers and then using that

904
00:36:57,200 --> 00:36:58,000
get variable

905
00:36:58,000 --> 00:37:00,079
function pointer just calling that

906
00:37:00,079 --> 00:37:01,920
variable

907
00:37:01,920 --> 00:37:04,480
and after that what we do is quite

908
00:37:04,480 --> 00:37:06,960
similar we just use a data size

909
00:37:06,960 --> 00:37:09,920
as a as a marker we try to find a

910
00:37:09,920 --> 00:37:11,119
sequence of two

911
00:37:11,119 --> 00:37:12,960
get variable calls in a row using the

912
00:37:12,960 --> 00:37:16,240
same data size and

913
00:37:16,880 --> 00:37:19,440
mark it as a potential security issue of

914
00:37:19,440 --> 00:37:22,320
those conditions in that

915
00:37:22,320 --> 00:37:24,800
as for the matrix situation is slightly

916
00:37:24,800 --> 00:37:26,560
more interesting

917
00:37:26,560 --> 00:37:30,480
there is a much less attack surface if

918
00:37:30,480 --> 00:37:30,720
you

919
00:37:30,720 --> 00:37:34,880
if you compare it with a dixie stage but

920
00:37:34,880 --> 00:37:37,119
if we compare that to the number of

921
00:37:37,119 --> 00:37:38,720
potential security vulnerabilities

922
00:37:38,720 --> 00:37:40,880
triggered on that dixie stage

923
00:37:40,880 --> 00:37:42,880
the numbers here and the platform

924
00:37:42,880 --> 00:37:45,119
initialization stage is actually

925
00:37:45,119 --> 00:37:48,160
larger that means that the dark surface

926
00:37:48,160 --> 00:37:51,520
might be not so large but

927
00:37:51,520 --> 00:37:54,960
there are many more potential places

928
00:37:54,960 --> 00:37:59,200
which might seem might seem to imply

929
00:37:59,200 --> 00:38:04,640
a lot of possible possible explanations

930
00:38:04,640 --> 00:38:06,320
for example it might be that security

931
00:38:06,320 --> 00:38:08,880
researchers did not actually

932
00:38:08,880 --> 00:38:12,079
uh completely look at this compared to

933
00:38:12,079 --> 00:38:14,400
how the dcrs invent stage

934
00:38:14,400 --> 00:38:17,599
was investigated maybe maybe not or

935
00:38:17,599 --> 00:38:21,680
maybe vendors did not actually

936
00:38:21,680 --> 00:38:23,359
look at this place from the security

937
00:38:23,359 --> 00:38:25,280
perspective themselves

938
00:38:25,280 --> 00:38:27,520
or maybe there is another explanation

939
00:38:27,520 --> 00:38:29,359
but this all is

940
00:38:29,359 --> 00:38:32,160
restrained and constrained with the

941
00:38:32,160 --> 00:38:32,880
metrics

942
00:38:32,880 --> 00:38:36,320
we choose and the metrics we use here

943
00:38:36,320 --> 00:38:39,119
and to how we collect those metrics of

944
00:38:39,119 --> 00:38:41,359
course

945
00:38:43,119 --> 00:38:45,760
but again talking about the results we

946
00:38:45,760 --> 00:38:47,040
were able to find

947
00:38:47,040 --> 00:38:50,320
a lot of security issues there in the

948
00:38:50,320 --> 00:38:50,880
process of

949
00:38:50,880 --> 00:38:54,079
disclosure and this is one

950
00:38:54,079 --> 00:38:57,040
one interesting example quite quite

951
00:38:57,040 --> 00:38:58,160
illustrative

952
00:38:58,160 --> 00:38:59,500
data size is

953
00:38:59,500 --> 00:39:01,680
[Music]

954
00:39:01,680 --> 00:39:04,400
a variable um allocation on the stack

955
00:39:04,400 --> 00:39:05,200
and then it

956
00:39:05,200 --> 00:39:07,599
implicitly updated after the first call

957
00:39:07,599 --> 00:39:09,040
and no one

958
00:39:09,040 --> 00:39:12,640
nothing or either nothing or nor one

959
00:39:12,640 --> 00:39:15,839
checks or

960
00:39:16,320 --> 00:39:18,480
maybe handles a situation where this

961
00:39:18,480 --> 00:39:20,320
data size is updated

962
00:39:20,320 --> 00:39:23,760
underneath implicitly and there is

963
00:39:23,760 --> 00:39:26,160
no obvious check for the air

964
00:39:26,160 --> 00:39:27,520
conditioners such as

965
00:39:27,520 --> 00:39:30,880
buffer to small in a way that

966
00:39:30,880 --> 00:39:33,920
second call to get variable

967
00:39:33,920 --> 00:39:37,920
is being executed as well regardless of

968
00:39:37,920 --> 00:39:39,670
what happens with the data size

969
00:39:39,670 --> 00:39:41,760
[Music]

970
00:39:41,760 --> 00:39:43,920
now as we researched all of those

971
00:39:43,920 --> 00:39:46,480
vectors let's talk about the

972
00:39:46,480 --> 00:39:51,680
overall stats and overall results

973
00:39:52,960 --> 00:39:56,000
so we just collected the whole table and

974
00:39:56,000 --> 00:39:59,920
this table is for the whole um

975
00:39:59,920 --> 00:40:02,960
for the for the whole

976
00:40:02,960 --> 00:40:05,359
range of all attack vectors and all the

977
00:40:05,359 --> 00:40:07,040
ways we tried to measure

978
00:40:07,040 --> 00:40:10,480
attack surface from there we see again

979
00:40:10,480 --> 00:40:13,359
that the dixie stage is uh has a massive

980
00:40:13,359 --> 00:40:14,319
attack surface

981
00:40:14,319 --> 00:40:16,079
the cement stage is kind of well

982
00:40:16,079 --> 00:40:18,400
protected and the pii stage

983
00:40:18,400 --> 00:40:21,280
is something interesting lean always is

984
00:40:21,280 --> 00:40:22,560
slightly better

985
00:40:22,560 --> 00:40:27,520
that in some ways but not in all ways

986
00:40:28,160 --> 00:40:31,520
attack surface is slightly uh slightly

987
00:40:31,520 --> 00:40:31,920
lower

988
00:40:31,920 --> 00:40:33,440
if you talk about this on my handlers

989
00:40:33,440 --> 00:40:36,319
well now but let's say

990
00:40:36,319 --> 00:40:40,000
in other aspects such as a

991
00:40:40,000 --> 00:40:43,839
number of well

992
00:40:43,839 --> 00:40:47,920
say uh number of but

993
00:40:47,920 --> 00:40:52,640
smm get variable calls uh lenovo is

994
00:40:52,640 --> 00:40:56,480
kind of a little bit a little bit worse

995
00:40:56,480 --> 00:40:59,520
in that regard but however

996
00:40:59,520 --> 00:41:01,520
this again is constrained and restrained

997
00:41:01,520 --> 00:41:04,839
to the metrics we choose and approach we

998
00:41:04,839 --> 00:41:06,560
use

999
00:41:06,560 --> 00:41:10,400
if we try to

1000
00:41:10,400 --> 00:41:12,720
summarize all of all of the results per

1001
00:41:12,720 --> 00:41:13,599
boot stage

1002
00:41:13,599 --> 00:41:17,119
the situation gets a little bit slightly

1003
00:41:17,119 --> 00:41:18,800
more clear

1004
00:41:18,800 --> 00:41:20,720
for the dixie stage there is a massive

1005
00:41:20,720 --> 00:41:22,000
attack surface and

1006
00:41:22,000 --> 00:41:25,760
there is a relatively

1007
00:41:25,760 --> 00:41:27,280
little amount of potential security

1008
00:41:27,280 --> 00:41:30,240
vulnerabilities smm which is inside

1009
00:41:30,240 --> 00:41:34,720
um important trusted boundary and in

1010
00:41:34,720 --> 00:41:39,200
kind of a place relatively privileged

1011
00:41:39,200 --> 00:41:42,560
is kind of relatively protected

1012
00:41:42,560 --> 00:41:46,640
but the pii stage is not

1013
00:41:46,640 --> 00:41:50,240
not entirely researched and seems to be

1014
00:41:50,240 --> 00:41:52,160
like a good place to dig into

1015
00:41:52,160 --> 00:41:53,600
because

1016
00:41:53,600 --> 00:41:55,280
[Music]

1017
00:41:55,280 --> 00:41:57,680
the amount of potential security

1018
00:41:57,680 --> 00:41:59,440
security vulnerability is triggered

1019
00:41:59,440 --> 00:42:02,800
with regard to get variable related to

1020
00:42:02,800 --> 00:42:04,000
its attack surface

1021
00:42:04,000 --> 00:42:06,560
is quite larger than for example a digit

1022
00:42:06,560 --> 00:42:08,160
stage

1023
00:42:08,160 --> 00:42:10,240
so the platform initialization is

1024
00:42:10,240 --> 00:42:13,680
something where i would suppose

1025
00:42:13,680 --> 00:42:15,440
we might look further in some and find

1026
00:42:15,440 --> 00:42:18,480
something something interesting

1027
00:42:18,480 --> 00:42:21,040
now let's talk about future plans all of

1028
00:42:21,040 --> 00:42:22,560
our partners have

1029
00:42:22,560 --> 00:42:25,280
one thing in common they are bound

1030
00:42:25,280 --> 00:42:26,480
pretty

1031
00:42:26,480 --> 00:42:28,800
pretty

1032
00:42:29,680 --> 00:42:32,640
pretty much to the assembler to to how

1033
00:42:32,640 --> 00:42:34,400
we find the patterns in assembler and

1034
00:42:34,400 --> 00:42:35,280
how we handle

1035
00:42:35,280 --> 00:42:38,240
um different flavors of code generation

1036
00:42:38,240 --> 00:42:39,599
we are able to do that

1037
00:42:39,599 --> 00:42:41,599
and it actually works and it works

1038
00:42:41,599 --> 00:42:43,520
pretty well if we

1039
00:42:43,520 --> 00:42:46,160
tune our heuristics very well and we do

1040
00:42:46,160 --> 00:42:47,200
that for example

1041
00:42:47,200 --> 00:42:50,400
just because for efi there are not so

1042
00:42:50,400 --> 00:42:52,079
many compilers a lot of

1043
00:42:52,079 --> 00:42:56,560
um a lot of build pipelines rely on

1044
00:42:56,560 --> 00:42:58,960
i think microsoft visual c plus plus in

1045
00:42:58,960 --> 00:43:00,720
order to get authentic code or

1046
00:43:00,720 --> 00:43:03,359
something similar to that there's no

1047
00:43:03,359 --> 00:43:06,400
such diversity in compilers and so

1048
00:43:06,400 --> 00:43:09,839
there's more um from from a statistical

1049
00:43:09,839 --> 00:43:10,480
perspective

1050
00:43:10,480 --> 00:43:14,160
more more stable

1051
00:43:14,720 --> 00:43:17,759
more stationary

1052
00:43:17,920 --> 00:43:21,040
more stationary picture uh if we if we

1053
00:43:21,040 --> 00:43:22,079
talk about

1054
00:43:22,079 --> 00:43:24,960
how what is the distribution of

1055
00:43:24,960 --> 00:43:26,319
different

1056
00:43:26,319 --> 00:43:28,240
code generations or different code

1057
00:43:28,240 --> 00:43:30,160
patterns resulting from different

1058
00:43:30,160 --> 00:43:32,240
compilers

1059
00:43:32,240 --> 00:43:35,920
but then however it presents a problem

1060
00:43:35,920 --> 00:43:37,839
and one of the problems is that we're

1061
00:43:37,839 --> 00:43:40,000
not able to

1062
00:43:40,000 --> 00:43:43,599
fully upload things we are not good at

1063
00:43:43,599 --> 00:43:46,240
and those things are understanding what

1064
00:43:46,240 --> 00:43:47,760
are the arguments of a function

1065
00:43:47,760 --> 00:43:49,760
there are so many calling conventions

1066
00:43:49,760 --> 00:43:51,119
there are

1067
00:43:51,119 --> 00:43:54,960
potentially so many architectures and

1068
00:43:54,960 --> 00:43:58,880
even even with this restrained number of

1069
00:43:58,880 --> 00:44:02,480
compiler compiler generate generation

1070
00:44:02,480 --> 00:44:03,440
options

1071
00:44:03,440 --> 00:44:05,680
there is still a lot of things we cannot

1072
00:44:05,680 --> 00:44:07,760
handle in general case

1073
00:44:07,760 --> 00:44:10,880
let us just upload it to um to the

1074
00:44:10,880 --> 00:44:12,720
disassembler and its intermediate

1075
00:44:12,720 --> 00:44:14,160
representations

1076
00:44:14,160 --> 00:44:16,000
they are built for that so it seems to

1077
00:44:16,000 --> 00:44:19,440
be a very natural next step for us

1078
00:44:19,440 --> 00:44:21,680
let's take a look at the code same code

1079
00:44:21,680 --> 00:44:22,480
which

1080
00:44:22,480 --> 00:44:24,640
on the left side looks into the assembly

1081
00:44:24,640 --> 00:44:28,720
form and the right side it looks

1082
00:44:28,960 --> 00:44:32,000
in a form of a microcode when

1083
00:44:32,000 --> 00:44:34,839
it's being translated to an intermediate

1084
00:44:34,839 --> 00:44:36,680
presentation

1085
00:44:36,680 --> 00:44:38,640
[Music]

1086
00:44:38,640 --> 00:44:42,480
and a slightly more

1087
00:44:42,480 --> 00:44:45,359
compressed form is a form of decompiler

1088
00:44:45,359 --> 00:44:47,090
you can see it on top

1089
00:44:47,090 --> 00:44:48,400
[Music]

1090
00:44:48,400 --> 00:44:50,880
what is the most important thing we get

1091
00:44:50,880 --> 00:44:51,599
for us

1092
00:44:51,599 --> 00:44:53,359
in terms of estimated vulnerability

1093
00:44:53,359 --> 00:44:54,960
finding well

1094
00:44:54,960 --> 00:44:58,000
it's arguments of a function and

1095
00:44:58,000 --> 00:44:59,680
information about the argument such as

1096
00:44:59,680 --> 00:45:02,000
length

1097
00:45:02,160 --> 00:45:05,520
types and whatever else you can find

1098
00:45:05,520 --> 00:45:08,960
once the type of uh

1099
00:45:08,960 --> 00:45:12,640
the of a table is known then the

1100
00:45:12,640 --> 00:45:14,800
all the work all the heavy lifting work

1101
00:45:14,800 --> 00:45:15,680
can be

1102
00:45:15,680 --> 00:45:19,599
can be safely uploaded to uh

1103
00:45:19,599 --> 00:45:21,520
to whatever is doing translation and

1104
00:45:21,520 --> 00:45:23,040
lifting or whatever

1105
00:45:23,040 --> 00:45:25,760
optimization on all and all of the magic

1106
00:45:25,760 --> 00:45:28,000
which is intermediate representation

1107
00:45:28,000 --> 00:45:32,079
uh doing well so and then after that

1108
00:45:32,079 --> 00:45:34,480
becomes very easy very easy to find

1109
00:45:34,480 --> 00:45:35,760
patterns like that

1110
00:45:35,760 --> 00:45:37,920
and to write more expressive and more

1111
00:45:37,920 --> 00:45:39,359
powerful patterns

1112
00:45:39,359 --> 00:45:42,640
and uh basically

1113
00:45:42,640 --> 00:45:45,359
do not work too much trying to find

1114
00:45:45,359 --> 00:45:46,240
workarounds

1115
00:45:46,240 --> 00:45:49,359
uh on compiler optimizations

1116
00:45:49,359 --> 00:45:52,640
and blowout specifics

1117
00:45:52,720 --> 00:45:56,000
um you can take a look at how c3s look

1118
00:45:56,000 --> 00:45:57,280
like

1119
00:45:57,280 --> 00:45:59,119
on the right for on the right side you

1120
00:45:59,119 --> 00:46:01,119
can see how abstract syntax tree looks

1121
00:46:01,119 --> 00:46:02,400
like

1122
00:46:02,400 --> 00:46:04,640
basically it's one one of the standard

1123
00:46:04,640 --> 00:46:06,720
things not very much different from how

1124
00:46:06,720 --> 00:46:07,440
you would

1125
00:46:07,440 --> 00:46:10,319
expect abstract syntax tree to look like

1126
00:46:10,319 --> 00:46:11,200
there's a block

1127
00:46:11,200 --> 00:46:13,359
block by an expression expression has an

1128
00:46:13,359 --> 00:46:15,119
assignment and an assignment

1129
00:46:15,119 --> 00:46:18,400
has two nodes data size and some value

1130
00:46:18,400 --> 00:46:21,839
this form x-rays c3s is a

1131
00:46:21,839 --> 00:46:24,640
more high-level representation and it's

1132
00:46:24,640 --> 00:46:25,359
very good

1133
00:46:25,359 --> 00:46:27,920
at data flow analysis which means it's

1134
00:46:27,920 --> 00:46:28,560
very good

1135
00:46:28,560 --> 00:46:31,680
at finding when a particular value is

1136
00:46:31,680 --> 00:46:34,160
assigned to a particular

1137
00:46:34,160 --> 00:46:36,560
variable for example but it's of course

1138
00:46:36,560 --> 00:46:39,200
much more useful to

1139
00:46:39,200 --> 00:46:41,280
too many other problems as well this is

1140
00:46:41,280 --> 00:46:43,680
just an example

1141
00:46:43,680 --> 00:46:46,800
hex-ray c3s is not the only

1142
00:46:46,800 --> 00:46:49,359
way of

1143
00:46:50,560 --> 00:46:53,359
representing a code in intermediate form

1144
00:46:53,359 --> 00:46:55,359
there is also a microcode level

1145
00:46:55,359 --> 00:46:56,960
which has been shown in the previous

1146
00:46:56,960 --> 00:46:58,800
slide this is

1147
00:46:58,800 --> 00:47:03,760
a more low level more i would say

1148
00:47:03,839 --> 00:47:05,680
more intermediary intermediate

1149
00:47:05,680 --> 00:47:07,359
representation something in the middle

1150
00:47:07,359 --> 00:47:07,760
between

1151
00:47:07,760 --> 00:47:11,040
x-ray c3s and the pure assembly

1152
00:47:11,040 --> 00:47:13,599
it is very good in a way that it it

1153
00:47:13,599 --> 00:47:14,800
doesn't go

1154
00:47:14,800 --> 00:47:18,000
that long to do a lot of optimizations

1155
00:47:18,000 --> 00:47:22,880
and trying to extract

1156
00:47:23,440 --> 00:47:25,920
what x-ray c3 is doing it's more

1157
00:47:25,920 --> 00:47:27,520
deterministic and it

1158
00:47:27,520 --> 00:47:30,880
works very well for uh semantical

1159
00:47:30,880 --> 00:47:33,760
things for algorithmic things but a

1160
00:47:33,760 --> 00:47:34,800
little bit

1161
00:47:34,800 --> 00:47:38,220
less for the data flow analysis

1162
00:47:38,220 --> 00:47:39,680
[Music]

1163
00:47:39,680 --> 00:47:44,240
now let's finally go to our conclusions

1164
00:47:44,240 --> 00:47:47,839
what we want to say is that for firmware

1165
00:47:47,839 --> 00:47:51,200
and uefi in particular static analysis

1166
00:47:51,200 --> 00:47:54,160
works and the static analysis is based

1167
00:47:54,160 --> 00:47:54,640
on

1168
00:47:54,640 --> 00:47:57,920
a bunch of well-tuned and

1169
00:47:57,920 --> 00:47:59,440
well-understood heuristics

1170
00:47:59,440 --> 00:48:02,079
and of course it's also based on a deep

1171
00:48:02,079 --> 00:48:02,800
understanding

1172
00:48:02,800 --> 00:48:07,119
of how firmware works as well

1173
00:48:07,119 --> 00:48:09,520
and those well-tuned heuristics work

1174
00:48:09,520 --> 00:48:11,599
surprisingly well for recovery of

1175
00:48:11,599 --> 00:48:13,440
important structures such as function

1176
00:48:13,440 --> 00:48:14,240
calls and

1177
00:48:14,240 --> 00:48:16,800
grt variables where they're allocated or

1178
00:48:16,800 --> 00:48:18,000
referenced

1179
00:48:18,000 --> 00:48:19,920
but that's something we already know

1180
00:48:19,920 --> 00:48:22,640
what we know now in this research is

1181
00:48:22,640 --> 00:48:24,800
that it actually works pretty well for

1182
00:48:24,800 --> 00:48:26,160
also automated attack surface

1183
00:48:26,160 --> 00:48:27,359
measurement

1184
00:48:27,359 --> 00:48:29,359
and it works pretty well for finding

1185
00:48:29,359 --> 00:48:31,280
potential security vulnerabilities

1186
00:48:31,280 --> 00:48:33,599
which also result in real security

1187
00:48:33,599 --> 00:48:34,640
vulnerabilities

1188
00:48:34,640 --> 00:48:36,960
so it's good at assimilated vault

1189
00:48:36,960 --> 00:48:38,960
hunting

1190
00:48:38,960 --> 00:48:40,960
another point we want to make is that

1191
00:48:40,960 --> 00:48:42,480
firmware vendors

1192
00:48:42,480 --> 00:48:45,839
probably if we make some assumption

1193
00:48:45,839 --> 00:48:48,559
that they did it they probably did well

1194
00:48:48,559 --> 00:48:51,040
on attack surface reduction

1195
00:48:51,040 --> 00:48:54,079
or maybe we can just say that attack

1196
00:48:54,079 --> 00:48:54,720
surface

1197
00:48:54,720 --> 00:48:58,480
is kind of not not terrible

1198
00:48:58,480 --> 00:49:02,319
in some cases but still however

1199
00:49:02,319 --> 00:49:05,200
well-known uh attack vectors well known

1200
00:49:05,200 --> 00:49:06,000
for years

1201
00:49:06,000 --> 00:49:08,880
and uh well understood for many many

1202
00:49:08,880 --> 00:49:09,359
years

1203
00:49:09,359 --> 00:49:11,839
they still exist and there's still a

1204
00:49:11,839 --> 00:49:14,880
little bit of a concern in 2020 even

1205
00:49:14,880 --> 00:49:18,559
for some vendors which are not

1206
00:49:18,559 --> 00:49:21,599
which are considered to be

1207
00:49:21,599 --> 00:49:25,760
uh good on providing quality products

1208
00:49:25,760 --> 00:49:30,400
in a way but it depends on

1209
00:49:30,400 --> 00:49:32,720
who you compare it to uh those vectors

1210
00:49:32,720 --> 00:49:33,920
are um

1211
00:49:33,920 --> 00:49:37,440
the smi uh

1212
00:49:37,440 --> 00:49:39,920
uh callouts uh well-known attack vectors

1213
00:49:39,920 --> 00:49:41,520
and get variable

1214
00:49:41,520 --> 00:49:43,920
various ways of misusing get variables

1215
00:49:43,920 --> 00:49:45,119
from a dixie stage from

1216
00:49:45,119 --> 00:49:48,480
smm stage and from a platform

1217
00:49:48,480 --> 00:49:51,520
insanitation stage

1218
00:49:51,839 --> 00:49:55,440
from there we want to say that we

1219
00:49:55,440 --> 00:49:58,400
despite the fact that we built a thing

1220
00:49:58,400 --> 00:49:59,680
which works

1221
00:49:59,680 --> 00:50:03,440
and we give it to security researchers

1222
00:50:03,440 --> 00:50:06,960
we as a community still need more

1223
00:50:06,960 --> 00:50:10,160
more tools like that and tools

1224
00:50:10,160 --> 00:50:12,240
other than that which would help ufi

1225
00:50:12,240 --> 00:50:14,559
security as a whole

1226
00:50:14,559 --> 00:50:17,520
uh we would need open usable and working

1227
00:50:17,520 --> 00:50:19,040
instrument for ufi

1228
00:50:19,040 --> 00:50:23,119
there is always lack of good instrument

1229
00:50:23,119 --> 00:50:26,559
for that for that space i would suggest

1230
00:50:26,559 --> 00:50:30,079
that a lot of tools would would be quite

1231
00:50:30,079 --> 00:50:32,240
useful for vulnerability research for

1232
00:50:32,240 --> 00:50:33,920
reverse engineering for automation of

1233
00:50:33,920 --> 00:50:35,920
those tasks forensics and for data

1234
00:50:35,920 --> 00:50:37,119
science

1235
00:50:37,119 --> 00:50:38,800
there are still a lot of open problems

1236
00:50:38,800 --> 00:50:40,319
there and there's still

1237
00:50:40,319 --> 00:50:43,200
much less instrument to investigate and

1238
00:50:43,200 --> 00:50:45,200
to inspect what's actually in there

1239
00:50:45,200 --> 00:50:46,800
and what's hidden there what's hidden

1240
00:50:46,800 --> 00:50:49,200
there by the attackers what's hidden

1241
00:50:49,200 --> 00:50:50,880
there by threat actors what's hidden

1242
00:50:50,880 --> 00:50:51,280
there

1243
00:50:51,280 --> 00:50:54,559
by vendors and what's hidden there

1244
00:50:54,559 --> 00:50:57,920
by whoever else we just didn't know

1245
00:50:57,920 --> 00:51:01,119
and from there when we have tools and

1246
00:51:01,119 --> 00:51:03,359
instruments when we have more of that

1247
00:51:03,359 --> 00:51:05,599
it's about right time for a much broader

1248
00:51:05,599 --> 00:51:07,599
audience to take a look at the problem

1249
00:51:07,599 --> 00:51:10,079
of potential uefa implants

1250
00:51:10,079 --> 00:51:12,880
i would say potential because actually

1251
00:51:12,880 --> 00:51:15,599
no one knows what's there

1252
00:51:15,599 --> 00:51:18,319
and it's about right time to take a look

1253
00:51:18,319 --> 00:51:20,480
and try to answer this question

1254
00:51:20,480 --> 00:51:22,160
because it's just interesting to know

1255
00:51:22,160 --> 00:51:23,920
what's what's in there

1256
00:51:23,920 --> 00:51:28,559
what implants might be there who knows

1257
00:51:30,400 --> 00:51:32,160
this is all thank you for your attention

1258
00:51:32,160 --> 00:51:36,240
and stay safe

