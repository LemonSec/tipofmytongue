1
00:00:01,180 --> 00:00:14,719
[Music]

2
00:00:15,920 --> 00:00:16,880
hello everyone

3
00:00:16,880 --> 00:00:19,520
welcome to my presentation today my

4
00:00:19,520 --> 00:00:21,520
topic is related to

5
00:00:21,520 --> 00:00:24,080
the apple bluetooth subsystem the title

6
00:00:24,080 --> 00:00:24,560
is

7
00:00:24,560 --> 00:00:27,119
attacking io bluetooth spamming hci and

8
00:00:27,119 --> 00:00:30,400
vendor-specific commands

9
00:00:30,400 --> 00:00:33,120
my name is wong from dd research america

10
00:00:33,120 --> 00:00:34,800
i can be reached through this email

11
00:00:34,800 --> 00:00:37,279
address

12
00:00:38,079 --> 00:00:41,040
in the first part of the presentation we

13
00:00:41,040 --> 00:00:42,640
will focus on the design

14
00:00:42,640 --> 00:00:45,760
and implementation of bluetooth hci on

15
00:00:45,760 --> 00:00:48,800
different platforms

16
00:00:49,280 --> 00:00:51,840
the first question we may have is what

17
00:00:51,840 --> 00:00:52,800
is hci

18
00:00:52,800 --> 00:00:55,920
of the bluetooth system basically

19
00:00:55,920 --> 00:00:58,079
people define the operating system side

20
00:00:58,079 --> 00:00:59,440
as the host

21
00:00:59,440 --> 00:01:01,840
and the firmware assigned as the

22
00:01:01,840 --> 00:01:02,960
controller

23
00:01:02,960 --> 00:01:05,438
then the software interface between the

24
00:01:05,438 --> 00:01:07,200
host and the controller is called

25
00:01:07,200 --> 00:01:10,880
hci from the hardware perspective

26
00:01:10,880 --> 00:01:12,720
the physical connection can be for

27
00:01:12,720 --> 00:01:16,400
example the uart interface

28
00:01:16,880 --> 00:01:19,840
the following is a more detailed diagram

29
00:01:19,840 --> 00:01:21,439
the blue part

30
00:01:21,439 --> 00:01:25,200
here is the hcs stack

31
00:01:25,200 --> 00:01:27,520
which includes components such as

32
00:01:27,520 --> 00:01:30,079
demands and the drivers

33
00:01:30,079 --> 00:01:33,600
the red part is the hci firmware

34
00:01:33,600 --> 00:01:36,400
or we can call it the controller the

35
00:01:36,400 --> 00:01:37,680
yellow arrow is

36
00:01:37,680 --> 00:01:41,200
hci which is a bridge connecting the two

37
00:01:41,200 --> 00:01:42,880
parts

38
00:01:42,880 --> 00:01:46,960
for daemons hci provides a

39
00:01:46,960 --> 00:01:50,079
unifying command method access bluetooth

40
00:01:50,079 --> 00:01:54,000
hardware features

41
00:01:54,000 --> 00:01:56,719
next question we may have is how many

42
00:01:56,719 --> 00:01:58,399
commands does hci

43
00:01:58,399 --> 00:02:03,040
bluetooth hss part the answer is a lot

44
00:02:03,040 --> 00:02:06,079
and they are divided into many groups it

45
00:02:06,079 --> 00:02:08,080
is worth mentioning that

46
00:02:08,080 --> 00:02:10,479
there is a group dedicated to

47
00:02:10,479 --> 00:02:12,480
vendor-specific commands

48
00:02:12,480 --> 00:02:16,319
or we can call it vsc for short

49
00:02:16,319 --> 00:02:19,920
if we search for vsc on the internet

50
00:02:19,920 --> 00:02:22,720
we can quickly find documents similar to

51
00:02:22,720 --> 00:02:23,760
the following

52
00:02:23,760 --> 00:02:28,560
this document is from texas instruments

53
00:02:28,640 --> 00:02:31,680
but i have to point out that

54
00:02:31,680 --> 00:02:34,720
holding a small number of bluetooth

55
00:02:34,720 --> 00:02:37,440
vendor-specific commands are documented

56
00:02:37,440 --> 00:02:39,680
for most of them we cannot find

57
00:02:39,680 --> 00:02:44,400
references at all another thing is that

58
00:02:44,400 --> 00:02:46,720
the meaning of vses on different

59
00:02:46,720 --> 00:02:48,080
hardware

60
00:02:48,080 --> 00:02:51,280
may be different even if their op codes

61
00:02:51,280 --> 00:02:52,720
are the same

62
00:02:52,720 --> 00:02:55,280
for example for the command whose op

63
00:02:55,280 --> 00:02:55,760
code

64
00:02:55,760 --> 00:02:59,680
is fc0a

65
00:02:59,680 --> 00:03:02,080
they have completely different meaning

66
00:03:02,080 --> 00:03:03,040
on the

67
00:03:03,040 --> 00:03:07,760
ti and broadcom platform

68
00:03:09,280 --> 00:03:11,680
and let's take an example to learn the

69
00:03:11,680 --> 00:03:14,400
hci command of bluetooth

70
00:03:14,400 --> 00:03:16,879
in the link control group the number one

71
00:03:16,879 --> 00:03:17,840
command is

72
00:03:17,840 --> 00:03:21,680
inquiry we can find its definition

73
00:03:21,680 --> 00:03:23,920
in the latest version of the bluetooth

74
00:03:23,920 --> 00:03:26,640
official menu

75
00:03:27,120 --> 00:03:29,680
according to the menu inquiry must

76
00:03:29,680 --> 00:03:30,959
include

77
00:03:30,959 --> 00:03:34,480
lab inquiry length

78
00:03:34,480 --> 00:03:38,000
and the number of responses

79
00:03:38,080 --> 00:03:42,000
the menu also defines the cracked

80
00:03:42,000 --> 00:03:47,360
value range for input for example for

81
00:03:47,360 --> 00:03:50,560
inquiry lens input should be

82
00:03:50,560 --> 00:03:55,120
from 1 to 30 in hex

83
00:03:55,120 --> 00:03:58,840
if you submit an incorrect input it will

84
00:03:58,840 --> 00:04:02,319
theoretically be rejected by hci

85
00:04:02,319 --> 00:04:05,280
or controller

86
00:04:06,400 --> 00:04:08,959
with the basic concept of inquiry

87
00:04:08,959 --> 00:04:09,760
command

88
00:04:09,760 --> 00:04:12,000
let's take a look at how each operating

89
00:04:12,000 --> 00:04:14,080
system implemented

90
00:04:14,080 --> 00:04:16,238
i chose three different operating

91
00:04:16,238 --> 00:04:17,358
systems

92
00:04:17,358 --> 00:04:20,478
lightweight bluetooth linux kernel and

93
00:04:20,478 --> 00:04:25,199
macos kernel lightweight bluetooth is

94
00:04:25,199 --> 00:04:28,080
representatively implementation of

95
00:04:28,080 --> 00:04:28,960
bluetooth

96
00:04:28,960 --> 00:04:32,320
protocol stack and we often see such

97
00:04:32,320 --> 00:04:35,040
lightweight implementations in iot

98
00:04:35,040 --> 00:04:36,000
devices

99
00:04:36,000 --> 00:04:39,720
or iot environments lice

100
00:04:39,720 --> 00:04:43,199
731 to 738

101
00:04:43,199 --> 00:04:46,720
of the code are the construction of the

102
00:04:46,720 --> 00:04:50,320
inquiry command we can see that

103
00:04:50,320 --> 00:04:54,479
this this code is constructing

104
00:04:54,479 --> 00:04:57,919
lab inquiry lens and the number of

105
00:04:57,919 --> 00:05:02,160
responses almost a bite by byte

106
00:05:02,160 --> 00:05:04,320
personally i don't like this kind of

107
00:05:04,320 --> 00:05:06,320
handmade code very much

108
00:05:06,320 --> 00:05:08,960
they are not easy to maintain and

109
00:05:08,960 --> 00:05:10,880
sometimes not easy to

110
00:05:10,880 --> 00:05:13,440
understand

111
00:05:14,720 --> 00:05:17,120
when it comes to the linux kernel it

112
00:05:17,120 --> 00:05:18,479
becomes clear

113
00:05:18,479 --> 00:05:21,520
almost all commands are defined as data

114
00:05:21,520 --> 00:05:22,560
structures

115
00:05:22,560 --> 00:05:27,680
which can be found in the header file

116
00:05:28,160 --> 00:05:31,440
the third example is our protagonist

117
00:05:31,440 --> 00:05:32,560
today

118
00:05:32,560 --> 00:05:35,120
the mac os io bluetooth family kernel

119
00:05:35,120 --> 00:05:36,560
extension

120
00:05:36,560 --> 00:05:40,560
when i first located the function io

121
00:05:40,560 --> 00:05:44,320
bluetooth hci inquiry i saw some

122
00:05:44,320 --> 00:05:47,440
strange strings with the

123
00:05:47,440 --> 00:05:51,199
deepening of reverse engineering i found

124
00:05:51,199 --> 00:05:54,240
a large number of such strings

125
00:05:54,240 --> 00:05:57,520
which appear in almost every bluetooth

126
00:05:57,520 --> 00:06:00,479
hcl handler

127
00:06:02,319 --> 00:06:05,520
curiosity draw me to summarize these

128
00:06:05,520 --> 00:06:06,720
strings

129
00:06:06,720 --> 00:06:09,840
and i found that they could actually be

130
00:06:09,840 --> 00:06:13,199
regarded as indicators to

131
00:06:13,199 --> 00:06:16,240
guide the functions pack data list and

132
00:06:16,240 --> 00:06:20,080
unpack the list the indicator for

133
00:06:20,080 --> 00:06:25,199
bluetooth hci inquiry is hbtb

134
00:06:25,199 --> 00:06:28,720
h means two bytes and b means one byte

135
00:06:28,720 --> 00:06:31,759
they represent the op code and

136
00:06:31,759 --> 00:06:35,840
body size of the hci request

137
00:06:35,919 --> 00:06:39,039
tbb corresponds to lap

138
00:06:39,039 --> 00:06:41,520
lab inquiry length and number of

139
00:06:41,520 --> 00:06:43,280
responses in the menu

140
00:06:43,280 --> 00:06:47,039
so we can easily deduce that t means

141
00:06:47,039 --> 00:06:49,840
three bytes

142
00:06:51,280 --> 00:06:53,759
now we can summarize three different

143
00:06:53,759 --> 00:06:55,360
operating systems

144
00:06:55,360 --> 00:06:59,039
the implementation of iot related hci

145
00:06:59,039 --> 00:07:02,160
represented by lwbt is the

146
00:07:02,160 --> 00:07:05,199
simplest and the design of

147
00:07:05,199 --> 00:07:08,240
mac os io bluetooth family is the most

148
00:07:08,240 --> 00:07:12,080
complicated i think apple can patent

149
00:07:12,080 --> 00:07:13,840
their hci requests to construction

150
00:07:13,840 --> 00:07:15,759
process maybe

151
00:07:15,759 --> 00:07:19,199
second complex design

152
00:07:19,199 --> 00:07:22,160
often means more attack surface and

153
00:07:22,160 --> 00:07:24,080
please also keep in mind

154
00:07:24,080 --> 00:07:26,479
if the design and the implementation are

155
00:07:26,479 --> 00:07:27,680
too simple

156
00:07:27,680 --> 00:07:30,720
it usually doesn't mean security we will

157
00:07:30,720 --> 00:07:31,360
discuss it

158
00:07:31,360 --> 00:07:33,840
later on

159
00:07:34,560 --> 00:07:38,160
in the next part we will try our best

160
00:07:38,160 --> 00:07:44,240
to dive into io bluetooth family to be

161
00:07:44,240 --> 00:07:44,960
honest

162
00:07:44,960 --> 00:07:48,639
when i started this research project i

163
00:07:48,639 --> 00:07:51,280
didn't expect that i could find the

164
00:07:51,280 --> 00:07:52,560
security problems

165
00:07:52,560 --> 00:07:56,319
of bluetooth at first i just want to

166
00:07:56,319 --> 00:07:57,039
learn

167
00:07:57,039 --> 00:08:01,360
about the bluetooth subsystem of mac os

168
00:08:01,360 --> 00:08:05,680
for this i read the documentation

169
00:08:05,680 --> 00:08:08,720
write a lot of source code and

170
00:08:08,720 --> 00:08:11,199
even reverse engineered the bluetooth

171
00:08:11,199 --> 00:08:12,879
kernel extensions

172
00:08:12,879 --> 00:08:17,280
however if we in turn to take the

173
00:08:17,280 --> 00:08:20,720
previous work as a starting point

174
00:08:20,720 --> 00:08:23,440
and continue this research seriously

175
00:08:23,440 --> 00:08:25,919
where should we start

176
00:08:25,919 --> 00:08:28,479
for me i think i still need some more

177
00:08:28,479 --> 00:08:30,560
tours

178
00:08:30,560 --> 00:08:33,120
for example sniffer i need sniffer i

179
00:08:33,120 --> 00:08:35,039
need fuzzer

180
00:08:35,039 --> 00:08:38,000
i need the code coverage masters for

181
00:08:38,000 --> 00:08:40,080
close the source driver

182
00:08:40,080 --> 00:08:43,839
and the kernel address sanitizer

183
00:08:44,720 --> 00:08:48,240
then we need to do attack surface

184
00:08:48,240 --> 00:08:49,760
assessment

185
00:08:49,760 --> 00:08:52,320
after reverse engineering i found that

186
00:08:52,320 --> 00:08:53,360
there are at least

187
00:08:53,360 --> 00:08:57,040
two attack surfaces that we must

188
00:08:57,040 --> 00:08:59,439
consider

189
00:09:00,160 --> 00:09:03,519
simple dispatch wl is responsible for

190
00:09:03,519 --> 00:09:07,200
managing the data floor from daemons

191
00:09:07,200 --> 00:09:11,360
to the hci while the function

192
00:09:11,360 --> 00:09:14,320
process event data wl is in charge of

193
00:09:14,320 --> 00:09:14,880
the

194
00:09:14,880 --> 00:09:17,920
state machine from the controller

195
00:09:17,920 --> 00:09:22,320
back to the host

196
00:09:22,320 --> 00:09:25,279
and three years ago in order to learn

197
00:09:25,279 --> 00:09:26,399
mac os

198
00:09:26,399 --> 00:09:29,600
i wrote a kernel extension which

199
00:09:29,600 --> 00:09:32,640
integrated file operate file operation

200
00:09:32,640 --> 00:09:33,760
monitoring

201
00:09:33,760 --> 00:09:36,640
dynamic library and the network traffic

202
00:09:36,640 --> 00:09:37,839
monitoring

203
00:09:37,839 --> 00:09:41,040
manager access control policy filtering

204
00:09:41,040 --> 00:09:43,279
kernel extension firewall and other

205
00:09:43,279 --> 00:09:44,240
features

206
00:09:44,240 --> 00:09:47,680
the project called chemo also includes

207
00:09:47,680 --> 00:09:50,480
a kernel inline hook engine which can

208
00:09:50,480 --> 00:09:50,880
hook

209
00:09:50,880 --> 00:09:53,920
almost any kernel function you want the

210
00:09:53,920 --> 00:09:55,760
source code of the project can be found

211
00:09:55,760 --> 00:09:57,040
on github

212
00:09:57,040 --> 00:10:00,560
in the last year i practiced the mac os

213
00:10:00,560 --> 00:10:02,640
ipc communication monitoring based on

214
00:10:02,640 --> 00:10:04,079
this project

215
00:10:04,079 --> 00:10:07,680
it can filter x pc ipc communication

216
00:10:07,680 --> 00:10:08,640
between

217
00:10:08,640 --> 00:10:11,839
processes and here is a link to

218
00:10:11,839 --> 00:10:16,079
blackhead usa arsenal and in order to

219
00:10:16,079 --> 00:10:19,120
learn more about the architecture and

220
00:10:19,120 --> 00:10:19,440
the

221
00:10:19,440 --> 00:10:22,720
attack surface of mac os bluetooth

222
00:10:22,720 --> 00:10:26,399
subsystem i wrote several sniffers

223
00:10:26,399 --> 00:10:29,440
based on chemo

224
00:10:30,959 --> 00:10:34,480
this screenshot is one of them it can

225
00:10:34,480 --> 00:10:37,920
intercept all hci requests sent to the

226
00:10:37,920 --> 00:10:39,120
controller

227
00:10:39,120 --> 00:10:42,000
because k-monk has pre and post callback

228
00:10:42,000 --> 00:10:43,279
capabilities

229
00:10:43,279 --> 00:10:48,000
i can parse out the input parameters

230
00:10:48,000 --> 00:10:52,800
core processor like bluetooth d

231
00:10:52,800 --> 00:10:54,959
and other useful information in the pre

232
00:10:54,959 --> 00:10:56,560
callback handler

233
00:10:56,560 --> 00:11:00,160
and i can also print or modify

234
00:11:00,160 --> 00:11:02,640
the return data of the target function

235
00:11:02,640 --> 00:11:03,760
in the post

236
00:11:03,760 --> 00:11:07,120
callback handler by

237
00:11:07,120 --> 00:11:10,320
analysing the log we can find some

238
00:11:10,320 --> 00:11:11,839
interesting details

239
00:11:11,839 --> 00:11:15,040
of the bluetooth operation on mac os

240
00:11:15,040 --> 00:11:19,439
platform first of all

241
00:11:20,160 --> 00:11:23,360
every specific operation is

242
00:11:23,360 --> 00:11:27,040
accompanied by crate and the delete

243
00:11:27,040 --> 00:11:29,120
operation

244
00:11:29,120 --> 00:11:31,040
this is very similar to the file

245
00:11:31,040 --> 00:11:32,720
operation

246
00:11:32,720 --> 00:11:35,920
file open and close handle operations

247
00:11:35,920 --> 00:11:39,519
on windows platform between

248
00:11:39,519 --> 00:11:42,880
create and delete is a specific

249
00:11:42,880 --> 00:11:46,079
hci request

250
00:11:47,200 --> 00:11:50,320
and i have a demo of the sniffer project

251
00:11:50,320 --> 00:11:57,839
please let me play the video

252
00:11:59,040 --> 00:12:03,279
let me first clean all kimon locks

253
00:12:03,680 --> 00:12:06,880
then i will turn on air job

254
00:12:06,880 --> 00:12:09,600
it will trigger sharing the and the

255
00:12:09,600 --> 00:12:10,079
bluetooth

256
00:12:10,079 --> 00:12:13,040
these operations

257
00:12:14,320 --> 00:12:17,040
okay yeah

258
00:12:17,920 --> 00:12:20,320
then we can say a large number of

259
00:12:20,320 --> 00:12:21,120
bluetooth

260
00:12:21,120 --> 00:12:24,160
hci requests

261
00:12:24,160 --> 00:12:27,440
let's take the first group the first

262
00:12:27,440 --> 00:12:31,600
group as an example first there is a

263
00:12:31,600 --> 00:12:34,880
create operation and then

264
00:12:34,880 --> 00:12:38,320
is a row command row window specific

265
00:12:38,320 --> 00:12:38,959
command

266
00:12:38,959 --> 00:12:42,320
from process bluetooth

267
00:12:42,320 --> 00:12:45,760
d and then is a

268
00:12:45,760 --> 00:12:49,200
delete operation so compared with other

269
00:12:49,200 --> 00:12:51,440
hci sniffers

270
00:12:51,440 --> 00:12:55,680
on based sniffer can capture and display

271
00:12:55,680 --> 00:13:01,199
the details of this car sequences

272
00:13:04,839 --> 00:13:06,880
okay

273
00:13:06,880 --> 00:13:09,600
and in order to deepen our understanding

274
00:13:09,600 --> 00:13:11,519
of the hci commands

275
00:13:11,519 --> 00:13:15,040
we need to do some more practice

276
00:13:15,040 --> 00:13:18,720
next i'd like to refer an article

277
00:13:18,720 --> 00:13:21,760
called hanking i o bluetooth which will

278
00:13:21,760 --> 00:13:22,480
be mentioned

279
00:13:22,480 --> 00:13:26,399
trials in today's presentation

280
00:13:26,399 --> 00:13:29,920
this article explains how to write a

281
00:13:29,920 --> 00:13:32,800
user mode program to communicate with

282
00:13:32,800 --> 00:13:33,440
the

283
00:13:33,440 --> 00:13:36,880
bluetooth daemon and driver and finally

284
00:13:36,880 --> 00:13:40,480
meet the requirements such as modifying

285
00:13:40,480 --> 00:13:41,279
the

286
00:13:41,279 --> 00:13:45,040
local name as shown on the left

287
00:13:45,040 --> 00:13:48,639
here the author

288
00:13:48,639 --> 00:13:51,279
wants to change the bluetooth local name

289
00:13:51,279 --> 00:13:51,839
to

290
00:13:51,839 --> 00:13:54,560
cda

291
00:13:56,959 --> 00:13:59,519
with the knowledge learned by using

292
00:13:59,519 --> 00:14:01,120
keymount based sniver

293
00:14:01,120 --> 00:14:04,480
this requirement is is easy to us

294
00:14:04,480 --> 00:14:07,920
to achieve we only need to

295
00:14:07,920 --> 00:14:11,519
implement the calling process from

296
00:14:11,519 --> 00:14:14,720
one crit hci crate

297
00:14:14,720 --> 00:14:17,600
and then read local name change log name

298
00:14:17,600 --> 00:14:17,920
and

299
00:14:17,920 --> 00:14:21,839
then delete so we can have a

300
00:14:21,839 --> 00:14:24,160
command line tool like the one on the

301
00:14:24,160 --> 00:14:26,399
right

302
00:14:28,399 --> 00:14:31,199
in the next step we need to deepen our

303
00:14:31,199 --> 00:14:31,920
understanding

304
00:14:31,920 --> 00:14:34,959
of vendor-specific commands render

305
00:14:34,959 --> 00:14:36,720
specific commands on mac os

306
00:14:36,720 --> 00:14:40,399
can be divided into two types

307
00:14:40,399 --> 00:14:44,639
the first is the building vs

308
00:14:44,639 --> 00:14:48,000
reverse engineering shows that

309
00:14:48,000 --> 00:14:50,720
these commands have corresponding

310
00:14:50,720 --> 00:14:51,760
handlers

311
00:14:51,760 --> 00:14:54,800
and indicators

312
00:14:55,760 --> 00:14:59,360
but more vendor-specific commands come

313
00:14:59,360 --> 00:15:02,639
in the form of raw data for example

314
00:15:02,639 --> 00:15:06,399
as shown in the screenshot

315
00:15:06,399 --> 00:15:09,680
of hci sniffer

316
00:15:09,680 --> 00:15:12,720
it's your command in the in the format

317
00:15:12,720 --> 00:15:15,440
of document

318
00:15:16,000 --> 00:15:19,120
at this year's blackhead usa arsenal

319
00:15:19,120 --> 00:15:22,399
i shared some tools that uses the

320
00:15:22,399 --> 00:15:25,519
raw vendor-specific commands they can

321
00:15:25,519 --> 00:15:26,160
communicate

322
00:15:26,160 --> 00:15:29,600
directly with the controller among

323
00:15:29,600 --> 00:15:33,839
them some commands are very variable

324
00:15:33,839 --> 00:15:36,959
they can even read and write ramp

325
00:15:36,959 --> 00:15:40,480
data of the firmware

326
00:15:40,480 --> 00:15:43,360
and here is a link

327
00:15:45,680 --> 00:15:49,519
okay so our next goal is fuzzing

328
00:15:49,519 --> 00:15:52,240
because we have sniffers we can quickly

329
00:15:52,240 --> 00:15:53,759
convert them to

330
00:15:53,759 --> 00:15:56,800
passive buzzer that is that is because

331
00:15:56,800 --> 00:15:58,160
we can do bit flipping

332
00:15:58,160 --> 00:16:01,759
of input parameter easily and we have

333
00:16:01,759 --> 00:16:04,959
implement some tools that can

334
00:16:04,959 --> 00:16:08,000
send for example raw

335
00:16:08,000 --> 00:16:10,720
when a specific command to controller

336
00:16:10,720 --> 00:16:12,240
which can also be

337
00:16:12,240 --> 00:16:16,000
transformed into active fuzzers

338
00:16:16,000 --> 00:16:18,880
in practice in practice i found that

339
00:16:18,880 --> 00:16:19,839
combining

340
00:16:19,839 --> 00:16:22,399
the two fuzzing method often has better

341
00:16:22,399 --> 00:16:24,720
results

342
00:16:24,720 --> 00:16:26,639
and by the way since we have chemo in

343
00:16:26,639 --> 00:16:29,199
hand we can use the

344
00:16:29,199 --> 00:16:32,639
inline hook based method

345
00:16:32,639 --> 00:16:36,720
to perform basic code coverage analysis

346
00:16:36,720 --> 00:16:40,480
against closed source drivers

347
00:16:42,959 --> 00:16:45,279
let's see how my further works on mac os

348
00:16:45,279 --> 00:16:47,360
bixer let me play

349
00:16:47,360 --> 00:16:49,950
the video

350
00:16:49,950 --> 00:16:52,160
[Music]

351
00:16:52,160 --> 00:16:54,880
as a target machine when i made this

352
00:16:54,880 --> 00:16:55,759
video

353
00:16:55,759 --> 00:16:58,399
the operating system was the latest

354
00:16:58,399 --> 00:17:01,360
macos mixer

355
00:17:01,680 --> 00:17:04,720
let me draw my browser and yeah after a

356
00:17:04,720 --> 00:17:06,000
few seconds the

357
00:17:06,000 --> 00:17:09,359
system crashed

358
00:17:10,000 --> 00:17:12,799
it's already crashed

359
00:17:15,710 --> 00:17:16,839
[Music]

360
00:17:16,839 --> 00:17:19,839
okay

361
00:17:23,039 --> 00:17:26,640
yeah through all kinds of efforts we

362
00:17:26,640 --> 00:17:27,520
have gone

363
00:17:27,520 --> 00:17:30,720
a long way compared with simply

364
00:17:30,720 --> 00:17:34,240
reading documents and codes we already

365
00:17:34,240 --> 00:17:35,200
have our own

366
00:17:35,200 --> 00:17:39,120
sniffers and the fuzzer

367
00:17:39,120 --> 00:17:42,640
we even implement several

368
00:17:42,640 --> 00:17:45,360
implements simple code coverage tool and

369
00:17:45,360 --> 00:17:47,440
the kernel address sanitizer for

370
00:17:47,440 --> 00:17:49,760
close the source driver they are not

371
00:17:49,760 --> 00:17:50,640
perfect

372
00:17:50,640 --> 00:17:54,799
but as we will see in the next

373
00:17:54,799 --> 00:18:01,280
capture they do perform well

374
00:18:01,280 --> 00:18:03,360
the next capture is mainly about

375
00:18:03,360 --> 00:18:05,919
vulnerability case study

376
00:18:05,919 --> 00:18:07,919
i will share with you some details of

377
00:18:07,919 --> 00:18:09,600
the latest macos

378
00:18:09,600 --> 00:18:12,559
bluetooth kernel vulnerabilities and

379
00:18:12,559 --> 00:18:13,600
what i have learned

380
00:18:13,600 --> 00:18:16,159
from them

381
00:18:18,000 --> 00:18:21,520
since hci is open to low privileged

382
00:18:21,520 --> 00:18:25,520
processes the infosec community has

383
00:18:25,520 --> 00:18:26,480
always been

384
00:18:26,480 --> 00:18:29,039
concerned about the security impact of

385
00:18:29,039 --> 00:18:29,760
this

386
00:18:29,760 --> 00:18:32,799
interface in recent years

387
00:18:32,799 --> 00:18:36,000
binary auditing and fuzzing against

388
00:18:36,000 --> 00:18:38,880
drivers such as io bluetooth family have

389
00:18:38,880 --> 00:18:40,240
never stopped

390
00:18:40,240 --> 00:18:42,880
we can also approve this from the output

391
00:18:42,880 --> 00:18:44,000
of

392
00:18:44,000 --> 00:18:48,320
error pro hexary the routing

393
00:18:48,320 --> 00:18:51,360
io business hci user client

394
00:18:51,360 --> 00:18:54,960
valid parameters has expanded from

395
00:18:54,960 --> 00:18:59,679
300 lies of code on macos highest sierra

396
00:18:59,679 --> 00:19:06,720
to more than 3000 lies on macos catalina

397
00:19:07,679 --> 00:19:11,600
so that means hunt vulnerability is not

398
00:19:11,600 --> 00:19:12,720
that easy

399
00:19:12,720 --> 00:19:17,120
however with the help of fuzzer's

400
00:19:17,120 --> 00:19:20,080
k-mount-based code coverage method and

401
00:19:20,080 --> 00:19:21,679
the kernel address sanitizer

402
00:19:21,679 --> 00:19:24,720
solution i did the

403
00:19:24,720 --> 00:19:27,840
i did find some security problems in the

404
00:19:27,840 --> 00:19:30,640
latest mac os and i so far i reported

405
00:19:30,640 --> 00:19:31,200
the

406
00:19:31,200 --> 00:19:34,400
23 vulnerabilities to apple

407
00:19:34,400 --> 00:19:38,960
um and their types include

408
00:19:38,960 --> 00:19:41,520
uninitialized memory derivatives kernel

409
00:19:41,520 --> 00:19:43,200
information disclosure

410
00:19:43,200 --> 00:19:46,720
heap data autobahn access arbitrary

411
00:19:46,720 --> 00:19:49,200
memory access double free use of the

412
00:19:49,200 --> 00:19:50,240
free cost by

413
00:19:50,240 --> 00:19:53,760
risk condition and one more thing

414
00:19:53,760 --> 00:19:55,600
security update turning turning number

415
00:19:55,600 --> 00:19:59,120
two can be bypassed

416
00:20:00,000 --> 00:20:01,760
here is the cv id and the patch

417
00:20:01,760 --> 00:20:04,320
information

418
00:20:05,200 --> 00:20:07,440
the first vulnerability i want to share

419
00:20:07,440 --> 00:20:09,760
with you is related to

420
00:20:09,760 --> 00:20:13,600
autobahn's reading of kernel hip data

421
00:20:13,600 --> 00:20:16,240
i have i have give i have given two

422
00:20:16,240 --> 00:20:17,440
cases for

423
00:20:17,440 --> 00:20:22,440
this type the cv id is

424
00:20:22,440 --> 00:20:26,880
3907 and 3908

425
00:20:32,400 --> 00:20:35,280
in the kernel address sanitizer's panic

426
00:20:35,280 --> 00:20:36,000
lock

427
00:20:36,000 --> 00:20:39,840
we can see that for vulnerability 20 20

428
00:20:39,840 --> 00:20:43,840
39 7 our actual input lens is only one

429
00:20:43,840 --> 00:20:44,799
byte

430
00:20:44,799 --> 00:20:46,720
and the wonderful function will read

431
00:20:46,720 --> 00:20:48,480
about 200

432
00:20:48,480 --> 00:20:53,120
bytes out of bonds to hci request

433
00:20:53,120 --> 00:20:56,480
and here we can see

434
00:20:56,480 --> 00:20:59,840
a lot of database tag

435
00:20:59,840 --> 00:21:02,240
they are all created by my kernel

436
00:21:02,240 --> 00:21:03,600
address sanitizer

437
00:21:03,600 --> 00:21:06,559
and the call stack is

438
00:21:07,280 --> 00:21:09,760
is this

439
00:21:09,790 --> 00:21:12,920
[Music]

440
00:21:13,520 --> 00:21:17,520
hci request method

441
00:21:18,960 --> 00:21:21,440
a similar situation also exists in

442
00:21:21,440 --> 00:21:22,000
function

443
00:21:22,000 --> 00:21:25,520
hci write start link key

444
00:21:25,520 --> 00:21:29,200
this handle this handler mistakenly

445
00:21:29,200 --> 00:21:31,679
trust the user input

446
00:21:31,679 --> 00:21:37,440
and the situation is the same

447
00:21:38,240 --> 00:21:41,039
so in summary this type of vulnerability

448
00:21:41,039 --> 00:21:41,520
is

449
00:21:41,520 --> 00:21:44,480
straightforward and easy to fix the

450
00:21:44,480 --> 00:21:45,520
wonderbolt handler

451
00:21:45,520 --> 00:21:48,720
lack the necessary verification for

452
00:21:48,720 --> 00:21:52,240
user mode input parameters and

453
00:21:52,240 --> 00:21:55,360
with kernel address analyzers help

454
00:21:55,360 --> 00:21:59,440
such vulnerabilities are easy to hunt

455
00:21:59,440 --> 00:22:01,690
we have several more cases

456
00:22:01,690 --> 00:22:04,809
[Music]

457
00:22:05,360 --> 00:22:08,240
the second vulnerabilities cv id is

458
00:22:08,240 --> 00:22:09,440
turning 10

459
00:22:09,440 --> 00:22:12,640
39 12. it was fixed

460
00:22:12,640 --> 00:22:16,240
in june this year

461
00:22:17,440 --> 00:22:21,280
this is an autobahn access vulnerability

462
00:22:21,280 --> 00:22:24,840
and i listed list listed separately

463
00:22:24,840 --> 00:22:26,080
because

464
00:22:26,080 --> 00:22:29,280
as far as i know this is the third time

465
00:22:29,280 --> 00:22:30,480
this function

466
00:22:30,480 --> 00:22:34,400
has been found vulnerable the first time

467
00:22:34,400 --> 00:22:37,600
the vulnerability was disclosed

468
00:22:37,600 --> 00:22:41,520
in 2014

469
00:22:41,520 --> 00:22:45,200
that means six years ago and

470
00:22:45,200 --> 00:22:47,840
in the in the link below is a poc for

471
00:22:47,840 --> 00:22:50,959
the vulnerability

472
00:22:52,080 --> 00:22:55,840
and then in 2015

473
00:22:55,840 --> 00:22:59,039
a vulnerability named 20

474
00:22:59,039 --> 00:23:02,480
2015 3787

475
00:23:02,480 --> 00:23:05,360
showed that the function was once again

476
00:23:05,360 --> 00:23:07,440
found to be vulnerable

477
00:23:07,440 --> 00:23:09,280
the call stack triggered by the

478
00:23:09,280 --> 00:23:10,640
vulnerability is shown

479
00:23:10,640 --> 00:23:14,159
in the figure below

480
00:23:14,640 --> 00:23:18,080
and five years later when i was auditing

481
00:23:18,080 --> 00:23:19,280
this function

482
00:23:19,280 --> 00:23:22,400
i found that it still lacks

483
00:23:22,400 --> 00:23:26,159
if effective boundary checking

484
00:23:26,159 --> 00:23:29,760
when the input is malicious magical

485
00:23:29,760 --> 00:23:30,559
number

486
00:23:30,559 --> 00:23:33,200
the handler will auto bond access and

487
00:23:33,200 --> 00:23:34,840
the

488
00:23:34,840 --> 00:23:37,760
panic

489
00:23:37,760 --> 00:23:40,080
in fact vulnerabilities are found

490
00:23:40,080 --> 00:23:41,520
repeatedly for some

491
00:23:41,520 --> 00:23:44,480
complex functions another interesting

492
00:23:44,480 --> 00:23:45,840
case is 2020

493
00:23:45,840 --> 00:23:50,000
9834 it's a wi-fi vulnerability

494
00:23:50,000 --> 00:23:52,720
i discovered this year this wonderful

495
00:23:52,720 --> 00:23:53,360
function

496
00:23:53,360 --> 00:23:58,320
was attacked 30 years ago

497
00:23:58,320 --> 00:24:01,919
so for such complex functions

498
00:24:01,919 --> 00:24:04,960
it is better to have complete test

499
00:24:04,960 --> 00:24:08,960
cases to ensure that all branch

500
00:24:08,960 --> 00:24:11,840
can be covered

501
00:24:14,080 --> 00:24:18,000
case number three the 79 cv id

502
00:24:18,000 --> 00:24:22,000
for of the third vulnerability is

503
00:24:22,000 --> 00:24:25,120
20 20 99 29

504
00:24:25,120 --> 00:24:29,439
which is fixed in september this year

505
00:24:30,799 --> 00:24:32,960
the reason i noticed this one

506
00:24:32,960 --> 00:24:35,679
variability is because i found that

507
00:24:35,679 --> 00:24:39,520
the indicator of function hci enhanced

508
00:24:39,520 --> 00:24:42,080
except a synchronized connection request

509
00:24:42,080 --> 00:24:43,679
has changed

510
00:24:43,679 --> 00:24:46,640
on the high sierra platform the

511
00:24:46,640 --> 00:24:47,919
indicator is

512
00:24:47,919 --> 00:24:51,600
this one but on macos catalina

513
00:24:51,600 --> 00:24:53,360
the indicator of the function has

514
00:24:53,360 --> 00:24:54,799
changed to

515
00:24:54,799 --> 00:24:58,000
well to to this this string contains

516
00:24:58,000 --> 00:25:01,840
several percentage characters

517
00:25:01,840 --> 00:25:05,120
and i have no idea about the percentage

518
00:25:05,120 --> 00:25:07,600
character

519
00:25:12,320 --> 00:25:15,440
so this change has brought me many

520
00:25:15,440 --> 00:25:16,480
questions

521
00:25:16,480 --> 00:25:20,960
for example um we will need to introduce

522
00:25:20,960 --> 00:25:25,039
compatibility issues and

523
00:25:25,039 --> 00:25:27,679
what is the main meaning of the

524
00:25:27,679 --> 00:25:29,360
percentage character

525
00:25:29,360 --> 00:25:31,440
and whether are there other new

526
00:25:31,440 --> 00:25:33,760
characters introduced

527
00:25:33,760 --> 00:25:36,880
um i have no idea that at a time after

528
00:25:36,880 --> 00:25:37,360
reverse

529
00:25:37,360 --> 00:25:41,279
engineering i found that percentage

530
00:25:41,279 --> 00:25:45,760
means that the pack and unpack

531
00:25:45,760 --> 00:25:49,120
routine need to read five bytes

532
00:25:49,120 --> 00:25:52,480
of the data from the input address

533
00:25:52,480 --> 00:25:55,279
but the problem is that the address can

534
00:25:55,279 --> 00:25:56,400
be controlled by

535
00:25:56,400 --> 00:25:59,039
user mode

536
00:25:59,840 --> 00:26:03,120
so the following panic log is the

537
00:26:03,120 --> 00:26:06,960
result of setting input address to

538
00:26:06,960 --> 00:26:10,080
that coffee that beef

539
00:26:10,480 --> 00:26:14,240
there are many interesting use uses

540
00:26:14,240 --> 00:26:17,360
for this feature such as

541
00:26:17,360 --> 00:26:20,799
building a more efficient low hammer

542
00:26:20,799 --> 00:26:24,320
based on this vulnerability

543
00:26:24,320 --> 00:26:27,279
and we can have a try

544
00:26:29,520 --> 00:26:32,559
next i searched for for

545
00:26:32,559 --> 00:26:36,000
apple sdks this is another case

546
00:26:36,000 --> 00:26:38,559
where i found useful information from

547
00:26:38,559 --> 00:26:40,720
the sdk

548
00:26:40,720 --> 00:26:43,200
in the bluetooth header file the

549
00:26:43,200 --> 00:26:44,799
indicator

550
00:26:44,799 --> 00:26:47,840
input that can be accepted by the

551
00:26:47,840 --> 00:26:51,279
pack and unpack function is defined in

552
00:26:51,279 --> 00:26:52,559
detail

553
00:26:52,559 --> 00:26:55,600
a percentage is actually the

554
00:26:55,600 --> 00:26:59,120
shift key of the number five

555
00:26:59,120 --> 00:27:02,559
which represents the reverse

556
00:27:02,559 --> 00:27:06,480
processing of the data input by the user

557
00:27:06,480 --> 00:27:10,240
so all the questions about indicators

558
00:27:10,240 --> 00:27:12,260
have answers here

559
00:27:12,260 --> 00:27:14,960
[Music]

560
00:27:14,960 --> 00:27:18,320
as a conclusion i want to

561
00:27:18,320 --> 00:27:21,360
print out the change

562
00:27:21,360 --> 00:27:24,720
of indicator actually means that

563
00:27:24,720 --> 00:27:27,919
the function of the controller

564
00:27:27,919 --> 00:27:32,320
has changed and the new features

565
00:27:32,320 --> 00:27:35,360
or changes always mean new attack

566
00:27:35,360 --> 00:27:37,440
surfaces

567
00:27:37,440 --> 00:27:40,559
um so which are worthy

568
00:27:40,559 --> 00:27:44,320
of our exploration

569
00:27:44,320 --> 00:27:48,240
and by the way uh reverse engineering

570
00:27:48,240 --> 00:27:51,600
plus apple sdk usually means a better

571
00:27:51,600 --> 00:27:53,918
life

572
00:27:56,399 --> 00:28:00,159
the first vulnerability is related to

573
00:28:00,159 --> 00:28:04,320
vendor-specific command let's start with

574
00:28:04,320 --> 00:28:07,279
lwbt

575
00:28:07,360 --> 00:28:11,039
i found many interesting comments

576
00:28:11,039 --> 00:28:14,399
when reading the lwbt source code

577
00:28:14,399 --> 00:28:18,080
the comments show that the ulcer

578
00:28:18,080 --> 00:28:21,840
does not seem to be very clear about

579
00:28:21,840 --> 00:28:25,200
how to handle the bluetooth event state

580
00:28:25,200 --> 00:28:26,559
machine

581
00:28:26,559 --> 00:28:29,679
and how to write

582
00:28:29,679 --> 00:28:34,640
exception exception handling correctly

583
00:28:35,840 --> 00:28:38,880
it should be said that this situation

584
00:28:38,880 --> 00:28:42,559
is not uncommon

585
00:28:42,559 --> 00:28:45,520
it's remind me that bluetooth event

586
00:28:45,520 --> 00:28:46,960
handling functions

587
00:28:46,960 --> 00:28:50,080
are worth of attention

588
00:28:50,080 --> 00:28:53,039
on the mac os platform the name of this

589
00:28:53,039 --> 00:28:53,520
function

590
00:28:53,520 --> 00:28:59,039
is process even the data wl

591
00:28:59,039 --> 00:29:02,240
and for which i wrote fuzzer

592
00:29:02,240 --> 00:29:06,960
and the sniffer specifically for it

593
00:29:07,600 --> 00:29:11,200
and this with the further research

594
00:29:11,200 --> 00:29:14,240
i noticed a raw command

595
00:29:14,240 --> 00:29:17,840
with opcode fce9

596
00:29:17,840 --> 00:29:21,679
which is not actually documented

597
00:29:21,679 --> 00:29:25,520
this command will cause the kernel event

598
00:29:25,520 --> 00:29:26,000
handler

599
00:29:26,000 --> 00:29:29,679
to crash and this is the screenshot

600
00:29:29,679 --> 00:29:32,320
at the time

601
00:29:35,279 --> 00:29:40,200
so this case reminds me that

602
00:29:40,200 --> 00:29:43,679
undocumented commands and

603
00:29:43,679 --> 00:29:46,960
non-standard hci implementations

604
00:29:46,960 --> 00:29:51,360
can lead to domino

605
00:29:52,840 --> 00:29:55,840
effect

606
00:29:57,360 --> 00:30:00,399
case number five the fifth case

607
00:30:00,399 --> 00:30:03,440
is is an uninitialized

608
00:30:03,440 --> 00:30:05,919
memory dereference vulnerability which

609
00:30:05,919 --> 00:30:07,360
is also the

610
00:30:07,360 --> 00:30:11,760
first bluetooth vulnerability i found

611
00:30:14,640 --> 00:30:16,159
the process of discovering this

612
00:30:16,159 --> 00:30:18,640
vulnerability is very interesting

613
00:30:18,640 --> 00:30:21,760
it took me less than 20 minutes

614
00:30:21,760 --> 00:30:24,720
to find it and 20 minutes ago i just

615
00:30:24,720 --> 00:30:25,840
decided to

616
00:30:25,840 --> 00:30:28,960
open the edit pro to reverse

617
00:30:28,960 --> 00:30:31,520
bluetooth kernel extension so this

618
00:30:31,520 --> 00:30:32,799
vulnerability give me

619
00:30:32,799 --> 00:30:36,399
a great confidence um

620
00:30:36,399 --> 00:30:38,559
i i can fund this vulnerability not

621
00:30:38,559 --> 00:30:40,880
because i'm lucky

622
00:30:40,880 --> 00:30:44,480
now because i'm good at kernel reverse

623
00:30:44,480 --> 00:30:47,840
engineering but because i have made

624
00:30:47,840 --> 00:30:52,639
similar mistakes a few years ago

625
00:30:53,679 --> 00:30:55,760
the pattern of this vulnerability is

626
00:30:55,760 --> 00:30:57,519
like this

627
00:30:57,519 --> 00:31:02,159
say if someone writes a lot

628
00:31:02,159 --> 00:31:05,200
conditions in an if statement

629
00:31:05,200 --> 00:31:07,360
so what what situation need to be

630
00:31:07,360 --> 00:31:09,120
covered in the

631
00:31:09,120 --> 00:31:12,559
else branch to me for for this case i

632
00:31:12,559 --> 00:31:14,640
don't know i prefer to

633
00:31:14,640 --> 00:31:18,080
rewrite this code

634
00:31:18,080 --> 00:31:21,200
and let's simplify the problem the

635
00:31:21,200 --> 00:31:24,559
this this question um

636
00:31:24,559 --> 00:31:27,919
if there are only two conditions

637
00:31:27,919 --> 00:31:31,279
uh like condition a is true and

638
00:31:31,279 --> 00:31:32,399
condition b

639
00:31:32,399 --> 00:31:36,000
is also true we need to discuss

640
00:31:36,000 --> 00:31:40,399
three cases uh in the else branch

641
00:31:40,399 --> 00:31:44,320
which is uh a is not true but b is true

642
00:31:44,320 --> 00:31:47,600
and a is

643
00:31:47,600 --> 00:31:51,200
true b is not true and a and b

644
00:31:51,200 --> 00:31:54,480
they are both not true so

645
00:31:54,480 --> 00:31:57,440
if we ignore these corner cases they are

646
00:31:57,440 --> 00:31:58,080
likely

647
00:31:58,080 --> 00:32:01,840
to lead potential problems

648
00:32:02,559 --> 00:32:06,159
so now let's look at the

649
00:32:06,159 --> 00:32:09,039
wonder real vulnerability of the mac os

650
00:32:09,039 --> 00:32:10,559
kernel

651
00:32:10,559 --> 00:32:15,840
the if branch here has two conditions

652
00:32:16,240 --> 00:32:18,880
the number one is the number one

653
00:32:18,880 --> 00:32:20,000
condition is

654
00:32:20,000 --> 00:32:23,679
the kernel must allocate

655
00:32:23,679 --> 00:32:27,519
a heap block successfully and

656
00:32:27,519 --> 00:32:30,559
number two is the the user input

657
00:32:30,559 --> 00:32:35,519
buffer is not empty okay

658
00:32:37,360 --> 00:32:40,559
according to our previous analysis

659
00:32:40,559 --> 00:32:43,600
the else branch should cover all

660
00:32:43,600 --> 00:32:46,880
uh three corner cases um

661
00:32:46,880 --> 00:32:51,519
but what about the the actual situation

662
00:32:51,519 --> 00:32:54,840
yeah we can see here the else branch has

663
00:32:54,840 --> 00:32:57,840
nothing

664
00:32:59,760 --> 00:33:03,279
this means that attacker can bypass

665
00:33:03,279 --> 00:33:06,880
or skip the initialization process of

666
00:33:06,880 --> 00:33:08,320
the

667
00:33:08,320 --> 00:33:10,960
function validate parameters by holding

668
00:33:10,960 --> 00:33:12,080
providing the

669
00:33:12,080 --> 00:33:16,960
input lens and this uninitialized buffer

670
00:33:16,960 --> 00:33:22,159
are then parsed to all hci handlers

671
00:33:23,679 --> 00:33:28,159
so um this vulnerability has been hidden

672
00:33:28,159 --> 00:33:31,919
in plant side for a long time and

673
00:33:31,919 --> 00:33:34,000
some traditional fuzzing methods are

674
00:33:34,000 --> 00:33:36,840
difficult to find this type of

675
00:33:36,840 --> 00:33:39,600
vulnerability and one more thing

676
00:33:39,600 --> 00:33:42,880
is i i

677
00:33:42,880 --> 00:33:46,159
agree with linux coding style do one

678
00:33:46,159 --> 00:33:46,799
thing and

679
00:33:46,799 --> 00:33:49,600
do that well

680
00:33:50,799 --> 00:33:54,480
okay the last one the last case

681
00:33:54,480 --> 00:33:56,720
um also represents a class of

682
00:33:56,720 --> 00:33:57,840
vulnerability

683
00:33:57,840 --> 00:34:03,199
that took two patch days to fix

684
00:34:03,760 --> 00:34:06,399
the story can start with the call stack

685
00:34:06,399 --> 00:34:08,159
in the article

686
00:34:08,159 --> 00:34:11,040
hanking i o bluetooth when i first saw

687
00:34:11,040 --> 00:34:13,440
the call stack

688
00:34:13,440 --> 00:34:17,918
the odin words i could say was wow

689
00:34:17,918 --> 00:34:20,960
with the deepening deepening of the

690
00:34:20,960 --> 00:34:21,918
research

691
00:34:21,918 --> 00:34:25,119
i found that it contained a lot of

692
00:34:25,119 --> 00:34:27,440
useful information

693
00:34:27,440 --> 00:34:32,159
in this english cod stack in short

694
00:34:32,159 --> 00:34:36,639
after entering hci the entry is

695
00:34:36,639 --> 00:34:40,800
simple this here simple dispatch wl

696
00:34:40,800 --> 00:34:44,000
and the exit is i o bluetooth hci

697
00:34:44,000 --> 00:34:45,599
request to start

698
00:34:45,599 --> 00:34:48,960
after request to start the request

699
00:34:48,960 --> 00:34:52,239
will be inserted into

700
00:34:52,239 --> 00:34:55,679
a queue and then send to the controller

701
00:34:55,679 --> 00:34:58,560
through the uart interface my question

702
00:34:58,560 --> 00:35:00,720
is

703
00:35:00,960 --> 00:35:04,079
how to protect the data structure in a

704
00:35:04,079 --> 00:35:07,599
multiple thread development

705
00:35:08,720 --> 00:35:12,240
the answer is the command command gate

706
00:35:12,240 --> 00:35:13,280
mechanism

707
00:35:13,280 --> 00:35:15,839
which holds the lock when entering the

708
00:35:15,839 --> 00:35:16,640
command gate

709
00:35:16,640 --> 00:35:19,839
and release the lock when the command

710
00:35:19,839 --> 00:35:21,280
sleep is caught

711
00:35:21,280 --> 00:35:24,400
so please note that we cannot hold the

712
00:35:24,400 --> 00:35:26,800
lock during sleep

713
00:35:26,800 --> 00:35:31,839
otherwise it means deadlock

714
00:35:34,560 --> 00:35:38,079
then a new problem comes after

715
00:35:38,079 --> 00:35:40,720
command sleep the request is not

716
00:35:40,720 --> 00:35:41,839
completed by

717
00:35:41,839 --> 00:35:44,960
the bluetooth controller so again

718
00:35:44,960 --> 00:35:47,760
how to ensure the bluetooth related data

719
00:35:47,760 --> 00:35:49,040
structure are safe

720
00:35:49,040 --> 00:35:51,920
in this window

721
00:35:52,160 --> 00:35:54,320
unfortunately the mac os bluetooth

722
00:35:54,320 --> 00:35:55,920
kernel developers

723
00:35:55,920 --> 00:35:59,839
didn't consider this situation

724
00:36:00,320 --> 00:36:02,800
and this design issue is very similar to

725
00:36:02,800 --> 00:36:03,599
the

726
00:36:03,599 --> 00:36:06,720
windows wings 32k user mode callback

727
00:36:06,720 --> 00:36:10,400
issue and due to the the

728
00:36:10,400 --> 00:36:14,160
limited time i could not discuss it here

729
00:36:14,160 --> 00:36:17,839
um here is a link i

730
00:36:17,839 --> 00:36:21,760
i i have

731
00:36:21,760 --> 00:36:24,079
explored this kind of vulnerability

732
00:36:24,079 --> 00:36:25,520
several years ago

733
00:36:25,520 --> 00:36:29,119
and it's very interesting

734
00:36:29,839 --> 00:36:32,079
so here is the panning log of this

735
00:36:32,079 --> 00:36:34,880
vulnerability

736
00:36:35,119 --> 00:36:38,839
it's a user after three or double free

737
00:36:38,839 --> 00:36:41,200
issue

738
00:36:41,200 --> 00:36:44,400
so as a previous one vulnerability

739
00:36:44,400 --> 00:36:48,400
like 20 20 99 28

740
00:36:48,400 --> 00:36:50,400
have been hidden in plant side for a

741
00:36:50,400 --> 00:36:52,560
long time and the factor

742
00:36:52,560 --> 00:36:56,720
all os bluetooth hci handlers

743
00:36:56,720 --> 00:37:00,240
um yeah so and

744
00:37:00,240 --> 00:37:02,800
and again this kind of vulnerability is

745
00:37:02,800 --> 00:37:03,520
very

746
00:37:03,520 --> 00:37:08,000
uh it's hard to find by traditional

747
00:37:08,000 --> 00:37:12,240
fuzzer okay the last part

748
00:37:12,240 --> 00:37:15,359
take takeaways

749
00:37:16,480 --> 00:37:18,880
the first one from the perspective of

750
00:37:18,880 --> 00:37:21,359
vulnerability research

751
00:37:21,359 --> 00:37:24,880
i want to say with the with this

752
00:37:24,880 --> 00:37:27,520
research as a startup starting point i

753
00:37:27,520 --> 00:37:30,000
believe we can do more

754
00:37:30,000 --> 00:37:33,680
and from the perspective of engineering

755
00:37:33,680 --> 00:37:36,400
i would say with the help of kmon

756
00:37:36,400 --> 00:37:37,280
project

757
00:37:37,280 --> 00:37:41,119
i believe we can do better

758
00:37:41,520 --> 00:37:44,000
okay thank you thank you very much thank

759
00:37:44,000 --> 00:37:45,640
you for your time

760
00:37:45,640 --> 00:37:48,640
bye

