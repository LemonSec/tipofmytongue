1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:15,839 --> 00:00:17,600
hi everybody welcome to our session on

3
00:00:17,600 --> 00:00:19,760
how embedded tcpap stacks with critical

4
00:00:19,760 --> 00:00:21,439
vulnerabilities i'm daniel de santos a

5
00:00:21,439 --> 00:00:23,199
research manager for scout

6
00:00:23,199 --> 00:00:24,880
and today i'm joined by stanislav de

7
00:00:24,880 --> 00:00:27,119
chavsky a security researcher at forscap

8
00:00:27,119 --> 00:00:28,480
we would also like to thank our

9
00:00:28,480 --> 00:00:30,800
co-authors jos vazos and amin henry

10
00:00:30,800 --> 00:00:33,120
for the work and we would like to say

11
00:00:33,120 --> 00:00:35,040
that at first gout research labs we

12
00:00:35,040 --> 00:00:36,559
analyze the security implications of

13
00:00:36,559 --> 00:00:38,879
hyper connectivity and itot convergence

14
00:00:38,879 --> 00:00:40,800
and other trends such as iot

15
00:00:40,800 --> 00:00:43,600
emergence in enterprise networks uh

16
00:00:43,600 --> 00:00:45,280
today we'll be talking about project

17
00:00:45,280 --> 00:00:46,000
memoria

18
00:00:46,000 --> 00:00:49,120
which is a large-scale study of uh tcp

19
00:00:49,120 --> 00:00:50,399
stack vulnerabilities

20
00:00:50,399 --> 00:00:53,680
we'll then drill down into amnesia 33

21
00:00:53,680 --> 00:00:55,760
which is our first study published under

22
00:00:55,760 --> 00:00:56,879
project memoria that deals with

23
00:00:56,879 --> 00:00:58,640
vulnerabilities and open source ccpip

24
00:00:58,640 --> 00:00:59,359
stacks

25
00:00:59,359 --> 00:01:00,719
we'll do an analysis of these

26
00:01:00,719 --> 00:01:01,920
vulnerabilities talk about the

27
00:01:01,920 --> 00:01:03,600
consequences of these vulnerabilities

28
00:01:03,600 --> 00:01:04,319
and then

29
00:01:04,319 --> 00:01:06,320
finally discuss a little bit what comes

30
00:01:06,320 --> 00:01:07,920
next in our research

31
00:01:07,920 --> 00:01:10,479
so let's talk about project memoria so

32
00:01:10,479 --> 00:01:12,080
the goal of project memory is to have a

33
00:01:12,080 --> 00:01:14,240
large study of embedded tcp stack

34
00:01:14,240 --> 00:01:15,920
security we want to understand why

35
00:01:15,920 --> 00:01:16,880
they're vulnerable how they're

36
00:01:16,880 --> 00:01:18,720
vulnerable and what we can do about it

37
00:01:18,720 --> 00:01:20,320
the idea is to have a quantitative and

38
00:01:20,320 --> 00:01:22,640
qualitative study so that we not only

39
00:01:22,640 --> 00:01:24,479
look at security vulnerabilities across

40
00:01:24,479 --> 00:01:26,080
many stacks but we drill down

41
00:01:26,080 --> 00:01:28,640
into components that are more prone to

42
00:01:28,640 --> 00:01:30,079
vulnerabilities to understand

43
00:01:30,079 --> 00:01:32,560
also the exploitability and other uh

44
00:01:32,560 --> 00:01:35,439
nuances of vulnerabilities in tcp stacks

45
00:01:35,439 --> 00:01:37,119
this project will be done by first-cloud

46
00:01:37,119 --> 00:01:40,079
research labs and other collaborators

47
00:01:40,079 --> 00:01:42,640
and we would like to say that the

48
00:01:42,640 --> 00:01:44,000
motivation behind

49
00:01:44,000 --> 00:01:46,479
uh this project is that we used to see

50
00:01:46,479 --> 00:01:48,799
several vulnerabilities in tcp stack

51
00:01:48,799 --> 00:01:50,880
especially in general purpose tcp stacks

52
00:01:50,880 --> 00:01:52,880
in the late 90s and early 2000s you can

53
00:01:52,880 --> 00:01:55,119
think of things like the ping of death

54
00:01:55,119 --> 00:01:57,759
wing nuke vulnerabilities affecting

55
00:01:57,759 --> 00:01:59,600
windows linux and so on

56
00:01:59,600 --> 00:02:03,520
but nowadays we see this rise of

57
00:02:03,520 --> 00:02:07,040
embedded devices and the iot world and

58
00:02:07,040 --> 00:02:09,280
just scaling up to billions of devices

59
00:02:09,280 --> 00:02:10,160
nowadays

60
00:02:10,160 --> 00:02:13,840
and we see that um tcpap stack

61
00:02:13,840 --> 00:02:15,599
vulnerabilities are making a resurgence

62
00:02:15,599 --> 00:02:17,040
because they are used across many of

63
00:02:17,040 --> 00:02:18,160
these devices

64
00:02:18,160 --> 00:02:20,560
we saw in the past two years uh research

65
00:02:20,560 --> 00:02:21,360
such as

66
00:02:21,360 --> 00:02:23,680
ripple 20 and urgent 11 that highlighted

67
00:02:23,680 --> 00:02:25,040
this risk

68
00:02:25,040 --> 00:02:27,200
and to start talking a little bit about

69
00:02:27,200 --> 00:02:28,319
this kind of risk

70
00:02:28,319 --> 00:02:30,160
uh we need to understand a bit about the

71
00:02:30,160 --> 00:02:32,800
embedded systems supply chain right so

72
00:02:32,800 --> 00:02:36,080
embedded devices and iot devices

73
00:02:36,080 --> 00:02:38,480
have several hardware and software

74
00:02:38,480 --> 00:02:40,000
components that are basically mixed

75
00:02:40,000 --> 00:02:40,640
produced by

76
00:02:40,640 --> 00:02:42,879
different vendors and mixed and matched

77
00:02:42,879 --> 00:02:44,959
to form a device that ends up

78
00:02:44,959 --> 00:02:47,920
in in an enterprise network and we have

79
00:02:47,920 --> 00:02:50,160
components such as microcontroller units

80
00:02:50,160 --> 00:02:52,319
systems on a chip we have connectivity

81
00:02:52,319 --> 00:02:53,920
components we have applications such as

82
00:02:53,920 --> 00:02:55,760
library demons platforms and so on

83
00:02:55,760 --> 00:02:57,840
and at several steps in this supply

84
00:02:57,840 --> 00:03:00,959
chain there might be a tcpap stack

85
00:03:00,959 --> 00:03:04,080
that is that is introduced in a device

86
00:03:04,080 --> 00:03:07,280
right so one of the reasons why

87
00:03:07,280 --> 00:03:09,519
looking into tcp stacks is interesting

88
00:03:09,519 --> 00:03:10,640
is because of this

89
00:03:10,640 --> 00:03:13,760
uh need to understand

90
00:03:13,760 --> 00:03:17,440
where they are uh in a device and how a

91
00:03:17,440 --> 00:03:18,159
vulnerability

92
00:03:18,159 --> 00:03:21,120
in one tcpap stack uh high up in the

93
00:03:21,120 --> 00:03:22,000
device in

94
00:03:22,000 --> 00:03:24,560
a supply chain ends up trickling down

95
00:03:24,560 --> 00:03:25,920
into devices but

96
00:03:25,920 --> 00:03:27,680
there are other reasons why we want to

97
00:03:27,680 --> 00:03:29,440
target protocol stack so i already

98
00:03:29,440 --> 00:03:31,040
mentioned the wide deployment right an

99
00:03:31,040 --> 00:03:32,799
effective vulnerability is trickled down

100
00:03:32,799 --> 00:03:34,799
to many vendors but also the fact that

101
00:03:34,799 --> 00:03:36,400
there is an absence of a software bill

102
00:03:36,400 --> 00:03:37,920
of materials so that vulnerabilities

103
00:03:37,920 --> 00:03:38,480
that are

104
00:03:38,480 --> 00:03:40,400
fixed in a course stack might just never

105
00:03:40,400 --> 00:03:41,599
make it to all

106
00:03:41,599 --> 00:03:44,879
uh and firmer because of not just

107
00:03:44,879 --> 00:03:46,720
the supply chain being long but also

108
00:03:46,720 --> 00:03:48,799
sometimes being obscured

109
00:03:48,799 --> 00:03:52,319
um there is in in tcp stacks there's

110
00:03:52,319 --> 00:03:53,599
always a good chance of finding

111
00:03:53,599 --> 00:03:55,519
exploitable bugs because they

112
00:03:55,519 --> 00:03:58,239
tend to be written in low level code in

113
00:03:58,239 --> 00:03:58,959
in memory

114
00:03:58,959 --> 00:04:01,360
safe languages such as cnc plus plus

115
00:04:01,360 --> 00:04:02,239
they are

116
00:04:02,239 --> 00:04:04,879
often uh old code bases that were

117
00:04:04,879 --> 00:04:07,120
written several decades ago

118
00:04:07,120 --> 00:04:09,760
and they involve complex parsing and

119
00:04:09,760 --> 00:04:11,360
state machines and so on which are

120
00:04:11,360 --> 00:04:12,959
difficult to get right

121
00:04:12,959 --> 00:04:16,000
um not just finding exploitable bugs is

122
00:04:16,000 --> 00:04:18,079
is is easier but it's interesting that

123
00:04:18,079 --> 00:04:19,279
they are also uh

124
00:04:19,279 --> 00:04:22,320
often externally exposed components uh

125
00:04:22,320 --> 00:04:24,400
they often run as privileged and low

126
00:04:24,400 --> 00:04:26,240
level components uh when there is an

127
00:04:26,240 --> 00:04:27,840
operating system sometimes there isn't

128
00:04:27,840 --> 00:04:30,320
even an operating system and the stack

129
00:04:30,320 --> 00:04:32,400
runs on a flat memory model

130
00:04:32,400 --> 00:04:34,880
so basically dispatching issues plus the

131
00:04:34,880 --> 00:04:36,160
long life spans

132
00:04:36,160 --> 00:04:38,240
of uh the devices that are affected by

133
00:04:38,240 --> 00:04:40,160
vulnerabilities kinds of vulnerabilities

134
00:04:40,160 --> 00:04:41,680
and the broad trickle down that we

135
00:04:41,680 --> 00:04:43,840
mentioned above lead to a high

136
00:04:43,840 --> 00:04:45,919
vulnerability lifespan and difficulty in

137
00:04:45,919 --> 00:04:48,160
eradicating these vulnerabilities which

138
00:04:48,160 --> 00:04:50,240
ultimately ultimately translate to a

139
00:04:50,240 --> 00:04:51,360
high attacker

140
00:04:51,360 --> 00:04:54,720
return on investment and now to

141
00:04:54,720 --> 00:04:56,479
drill down into the details of amnesia

142
00:04:56,479 --> 00:04:58,320
33 i would like to give the floor to

143
00:04:58,320 --> 00:05:00,400
stanislav

144
00:05:00,400 --> 00:05:02,320
hello everyone thank you very much for

145
00:05:02,320 --> 00:05:04,880
joining my name is stanislav and i will

146
00:05:04,880 --> 00:05:07,810
tell you more about the amnesia 33 study

147
00:05:07,810 --> 00:05:09,120
[Music]

148
00:05:09,120 --> 00:05:11,919
as daniel mentioned the tcp stacks are

149
00:05:11,919 --> 00:05:13,840
the key for the connectivity of embedded

150
00:05:13,840 --> 00:05:14,560
systems

151
00:05:14,560 --> 00:05:17,680
and different iot devices but there are

152
00:05:17,680 --> 00:05:18,160
still

153
00:05:18,160 --> 00:05:20,479
quite a lot of popular implementations

154
00:05:20,479 --> 00:05:22,479
of these tcp stacks

155
00:05:22,479 --> 00:05:24,720
that were not previously examined for

156
00:05:24,720 --> 00:05:26,160
example microsoft's

157
00:05:26,160 --> 00:05:29,440
nedex niche stack and the nucleus net

158
00:05:29,440 --> 00:05:31,520
supported by siemens

159
00:05:31,520 --> 00:05:33,280
therefore i would like to present to you

160
00:05:33,280 --> 00:05:35,199
our first study into this topic

161
00:05:35,199 --> 00:05:38,639
called amnesia 33. the study aims

162
00:05:38,639 --> 00:05:41,280
specifically at open source tcpap stacks

163
00:05:41,280 --> 00:05:43,280
and we chose to explore open source

164
00:05:43,280 --> 00:05:45,039
targets in particular

165
00:05:45,039 --> 00:05:48,160
uh because for example according to this

166
00:05:48,160 --> 00:05:50,800
2019 embedded market study

167
00:05:50,800 --> 00:05:52,800
most of the embedded projects reuse the

168
00:05:52,800 --> 00:05:53,840
source code

169
00:05:53,840 --> 00:05:56,400
which also includes open source and a

170
00:05:56,400 --> 00:05:57,199
bit more than

171
00:05:57,199 --> 00:06:00,400
half of these projects are using

172
00:06:00,400 --> 00:06:02,720
open source real-time operating systems

173
00:06:02,720 --> 00:06:04,960
and these are typically bundled with an

174
00:06:04,960 --> 00:06:06,080
open source implementation

175
00:06:06,080 --> 00:06:09,680
of a tcpap stack and also despite

176
00:06:09,680 --> 00:06:12,160
this growth in popularity the security

177
00:06:12,160 --> 00:06:13,680
and privacy in these projects

178
00:06:13,680 --> 00:06:16,020
will still remain as an afterthought

179
00:06:16,020 --> 00:06:17,759
[Music]

180
00:06:17,759 --> 00:06:19,280
we have broken down the research

181
00:06:19,280 --> 00:06:21,440
activities from amnesia into several

182
00:06:21,440 --> 00:06:22,240
phases

183
00:06:22,240 --> 00:06:24,800
and i will use them as my outline for

184
00:06:24,800 --> 00:06:26,240
the rest of this talk

185
00:06:26,240 --> 00:06:28,319
i will now explain each phase in more

186
00:06:28,319 --> 00:06:30,960
detail to you

187
00:06:30,960 --> 00:06:32,560
we started with the analysis of the

188
00:06:32,560 --> 00:06:34,319
existing vulnerabilities in different

189
00:06:34,319 --> 00:06:36,960
stacks and we also studied related

190
00:06:36,960 --> 00:06:39,280
write-ups and research reports as we

191
00:06:39,280 --> 00:06:40,560
immediately noticed

192
00:06:40,560 --> 00:06:42,240
apart from some of the recent studies

193
00:06:42,240 --> 00:06:44,160
there are not so many vulnerabilities

194
00:06:44,160 --> 00:06:47,280
disclosed for tcpap stacks even for

195
00:06:47,280 --> 00:06:50,720
very popular stacks used for for decades

196
00:06:50,720 --> 00:06:52,639
and while one might think that this is

197
00:06:52,639 --> 00:06:54,560
simply because these stacks are robust

198
00:06:54,560 --> 00:06:56,400
it could also indicate the lack of

199
00:06:56,400 --> 00:06:59,440
public security assessment

200
00:06:59,440 --> 00:07:02,400
so we started also with studying prior

201
00:07:02,400 --> 00:07:04,400
vulnerabilities in more detail

202
00:07:04,400 --> 00:07:07,440
and we were inspired by the taxonomy of

203
00:07:07,440 --> 00:07:09,039
anti-patterns introduced

204
00:07:09,039 --> 00:07:11,919
in in the paper called the seven turrets

205
00:07:11,919 --> 00:07:13,120
of babel

206
00:07:13,120 --> 00:07:15,360
which was written by falcon muhammad and

207
00:07:15,360 --> 00:07:17,199
his colleagues

208
00:07:17,199 --> 00:07:20,080
some of these anti-partners directly

209
00:07:20,080 --> 00:07:22,080
apply to the historical vulnerabilities

210
00:07:22,080 --> 00:07:23,280
we have seen in

211
00:07:23,280 --> 00:07:26,560
tcp stacks and for example some of them

212
00:07:26,560 --> 00:07:27,759
are

213
00:07:27,759 --> 00:07:30,000
permissive parsing when there's no

214
00:07:30,000 --> 00:07:31,759
validation of the data that is coming

215
00:07:31,759 --> 00:07:33,759
from a network packet

216
00:07:33,759 --> 00:07:35,840
there is also variant of this called

217
00:07:35,840 --> 00:07:37,360
shotgun parsing when

218
00:07:37,360 --> 00:07:40,240
a processing validation code is mixed

219
00:07:40,240 --> 00:07:41,199
together

220
00:07:41,199 --> 00:07:43,840
and instead of doing validation first

221
00:07:43,840 --> 00:07:46,639
and then processing second

222
00:07:46,639 --> 00:07:49,680
also more generally there was general

223
00:07:49,680 --> 00:07:51,360
absence of bounce checks

224
00:07:51,360 --> 00:07:54,000
and also we we saw that there were a lot

225
00:07:54,000 --> 00:07:54,560
of

226
00:07:54,560 --> 00:07:58,000
integer wrap around issues and there's

227
00:07:58,000 --> 00:07:59,759
was also quite some number of state

228
00:07:59,759 --> 00:08:01,520
confusion bugs

229
00:08:01,520 --> 00:08:03,599
like the the absence of proper requests

230
00:08:03,599 --> 00:08:05,360
and reply matching

231
00:08:05,360 --> 00:08:07,360
another interesting pointer for us was

232
00:08:07,360 --> 00:08:08,400
the fact

233
00:08:08,400 --> 00:08:11,039
that they may be unclear and conflicting

234
00:08:11,039 --> 00:08:13,039
design documentation

235
00:08:13,039 --> 00:08:15,280
has been used to develop these tcpap

236
00:08:15,280 --> 00:08:16,560
stacks

237
00:08:16,560 --> 00:08:19,280
and also that describe various protocols

238
00:08:19,280 --> 00:08:20,240
these documents

239
00:08:20,240 --> 00:08:22,720
are called the rfc documents and for

240
00:08:22,720 --> 00:08:23,599
instance

241
00:08:23,599 --> 00:08:26,800
the tcp urgent pointer that was not

242
00:08:26,800 --> 00:08:27,680
properly

243
00:08:27,680 --> 00:08:29,919
defined and one of these rses has been

244
00:08:29,919 --> 00:08:31,919
already the source of implementation

245
00:08:31,919 --> 00:08:34,880
errors in the past

246
00:08:35,279 --> 00:08:37,200
to select the appropriate targets for

247
00:08:37,200 --> 00:08:38,799
our study we focus

248
00:08:38,799 --> 00:08:41,839
on on stacks that have been used by

249
00:08:41,839 --> 00:08:44,399
popular real-time operating systems and

250
00:08:44,399 --> 00:08:45,839
we also consider

251
00:08:45,839 --> 00:08:48,160
the potential numbers of devices that

252
00:08:48,160 --> 00:08:49,360
are using a stack

253
00:08:49,360 --> 00:08:52,240
that we could find online to briefly

254
00:08:52,240 --> 00:08:55,839
introduce you to these stacks

255
00:08:55,839 --> 00:08:58,399
we started with lwip that is very

256
00:08:58,399 --> 00:08:59,440
popular

257
00:08:59,440 --> 00:09:02,320
and it's also a part of uh freertos

258
00:09:02,320 --> 00:09:03,600
operating system

259
00:09:03,600 --> 00:09:06,480
and also it has been used in many other

260
00:09:06,480 --> 00:09:08,480
embedded projects

261
00:09:08,480 --> 00:09:11,760
the micro ip stack is also developed by

262
00:09:11,760 --> 00:09:14,720
by the same author that developed lwp

263
00:09:14,720 --> 00:09:15,600
initially and

264
00:09:15,600 --> 00:09:18,160
it was designed to be even lighter than

265
00:09:18,160 --> 00:09:20,320
than lwip

266
00:09:20,320 --> 00:09:22,480
currently it is a part of the cantiki os

267
00:09:22,480 --> 00:09:23,760
project and

268
00:09:23,760 --> 00:09:25,839
it is a quite popular base for

269
00:09:25,839 --> 00:09:28,399
commercial and non-commercial forks

270
00:09:28,399 --> 00:09:31,920
uh the net tcpap stack is currently used

271
00:09:31,920 --> 00:09:33,040
by the nato s

272
00:09:33,040 --> 00:09:35,920
and is also in active development now

273
00:09:35,920 --> 00:09:36,399
and

274
00:09:36,399 --> 00:09:38,880
also the rest of the the rest of the

275
00:09:38,880 --> 00:09:40,800
stocks mentioned here are

276
00:09:40,800 --> 00:09:42,959
the commercial stocks made public some

277
00:09:42,959 --> 00:09:44,320
years ago

278
00:09:44,320 --> 00:09:46,880
and they they remain quite popular to

279
00:09:46,880 --> 00:09:48,720
this day

280
00:09:48,720 --> 00:09:50,240
when know that other researchers

281
00:09:50,240 --> 00:09:52,000
researchers looked at some of them in

282
00:09:52,000 --> 00:09:52,640
the past

283
00:09:52,640 --> 00:09:55,120
and these stacks have been found has

284
00:09:55,120 --> 00:09:57,760
been around for a very long time

285
00:09:57,760 --> 00:09:59,839
but this actually implies that there

286
00:09:59,839 --> 00:10:01,600
could be many versions of these stacks

287
00:10:01,600 --> 00:10:02,320
running on

288
00:10:02,320 --> 00:10:04,880
different different devices that are

289
00:10:04,880 --> 00:10:05,839
considered

290
00:10:05,839 --> 00:10:08,320
end of life by vendors if especially if

291
00:10:08,320 --> 00:10:11,680
they're running some old versions

292
00:10:11,680 --> 00:10:14,240
for looking for the vulnerabilities in

293
00:10:14,240 --> 00:10:15,360
these stacks

294
00:10:15,360 --> 00:10:17,200
we use the combination of dynamic and

295
00:10:17,200 --> 00:10:19,040
static analysis

296
00:10:19,040 --> 00:10:21,600
we first set up a fuzzing infrastructure

297
00:10:21,600 --> 00:10:22,079
using

298
00:10:22,079 --> 00:10:25,360
the leapfaster tool and we used whitebox

299
00:10:25,360 --> 00:10:28,480
code coverage metric as our guide we

300
00:10:28,480 --> 00:10:30,160
could actually find a number of

301
00:10:30,160 --> 00:10:32,560
vulnerabilities in this way however

302
00:10:32,560 --> 00:10:35,120
there were some complications in setting

303
00:10:35,120 --> 00:10:36,640
it up for more embedded

304
00:10:36,640 --> 00:10:39,120
for some of the embedded targets

305
00:10:39,120 --> 00:10:40,880
moreover it might be quite challenging

306
00:10:40,880 --> 00:10:42,480
to achieve the full testing coverage

307
00:10:42,480 --> 00:10:44,160
with this approach

308
00:10:44,160 --> 00:10:45,920
simply because when the fuzzer is used

309
00:10:45,920 --> 00:10:48,320
out of the box it might be not maybe not

310
00:10:48,320 --> 00:10:49,600
as efficient

311
00:10:49,600 --> 00:10:51,279
and the reason for that is that some

312
00:10:51,279 --> 00:10:53,920
protocols require stateful fuzzing

313
00:10:53,920 --> 00:10:56,720
and they also need more advanced means

314
00:10:56,720 --> 00:10:57,120
for

315
00:10:57,120 --> 00:10:59,200
computing checksum and passing through

316
00:10:59,200 --> 00:11:00,720
them

317
00:11:00,720 --> 00:11:03,040
we also used a static analysis tool

318
00:11:03,040 --> 00:11:04,240
called yeon

319
00:11:04,240 --> 00:11:06,640
developed initially by fabian yamaguchi

320
00:11:06,640 --> 00:11:07,519
and we

321
00:11:07,519 --> 00:11:09,440
would like to thank gabriela cherby who

322
00:11:09,440 --> 00:11:12,320
helped us to set it up

323
00:11:12,320 --> 00:11:14,800
for this specifically we encoded some of

324
00:11:14,800 --> 00:11:16,800
the anti-patterns i mentioned earlier

325
00:11:16,800 --> 00:11:20,320
in the form of code search queries and

326
00:11:20,320 --> 00:11:23,440
still as with any uh static analysis

327
00:11:23,440 --> 00:11:25,120
though there were sometimes

328
00:11:25,120 --> 00:11:28,160
high false positive rates

329
00:11:28,160 --> 00:11:30,959
because some of the vulnerabilities in

330
00:11:30,959 --> 00:11:33,440
tcpap stacks are quite implementation

331
00:11:33,440 --> 00:11:34,160
specific

332
00:11:34,160 --> 00:11:38,160
and they need to be adjusted for that

333
00:11:38,160 --> 00:11:40,480
finally we also performed a lot of

334
00:11:40,480 --> 00:11:42,399
manual code inspections to explore the

335
00:11:42,399 --> 00:11:44,320
points of interest that we haven't

336
00:11:44,320 --> 00:11:47,010
covered with any of these tools before

337
00:11:47,010 --> 00:11:48,720
[Music]

338
00:11:48,720 --> 00:11:51,040
so i would like to continue with first

339
00:11:51,040 --> 00:11:53,040
the positive results

340
00:11:53,040 --> 00:11:54,880
for example we could not find any

341
00:11:54,880 --> 00:11:56,399
vulnerabilities in

342
00:11:56,399 --> 00:11:59,279
three of our targets which are lwip

343
00:11:59,279 --> 00:12:01,839
cyclone tcp and microc

344
00:12:01,839 --> 00:12:03,760
these stocks in general did not exhibit

345
00:12:03,760 --> 00:12:06,000
any problematic code and the patterns

346
00:12:06,000 --> 00:12:06,880
that we

347
00:12:06,880 --> 00:12:09,600
we have been looking for and for example

348
00:12:09,600 --> 00:12:11,440
they have the proper bond checks in

349
00:12:11,440 --> 00:12:11,839
place

350
00:12:11,839 --> 00:12:14,880
and usually they in general have quite

351
00:12:14,880 --> 00:12:15,680
robust

352
00:12:15,680 --> 00:12:18,639
robust parsing code we also found that

353
00:12:18,639 --> 00:12:20,399
these tags are actively developed and

354
00:12:20,399 --> 00:12:21,200
supported

355
00:12:21,200 --> 00:12:23,920
and when for example we conducted these

356
00:12:23,920 --> 00:12:26,079
projects for some other issues they were

357
00:12:26,079 --> 00:12:28,959
quite responsive

358
00:12:29,360 --> 00:12:31,920
for stocks however from the ones that we

359
00:12:31,920 --> 00:12:32,720
analyzed

360
00:12:32,720 --> 00:12:34,639
were vulnerable according to our

361
00:12:34,639 --> 00:12:35,760
assessment and

362
00:12:35,760 --> 00:12:39,120
in total we found 33 vulnerabilities

363
00:12:39,120 --> 00:12:41,440
with the top affected components that

364
00:12:41,440 --> 00:12:42,800
are dns

365
00:12:42,800 --> 00:12:47,040
ipv6 and ipv4 tcp and icmp

366
00:12:47,040 --> 00:12:48,399
the potential impact of these

367
00:12:48,399 --> 00:12:50,880
vulnerabilities ranges from

368
00:12:50,880 --> 00:12:53,760
different kinds of denial of service to

369
00:12:53,760 --> 00:12:54,800
information leak

370
00:12:54,800 --> 00:12:57,920
and remote code execution we also found

371
00:12:57,920 --> 00:13:00,000
a few state confusion bugs

372
00:13:00,000 --> 00:13:02,840
like dns cache poisoning

373
00:13:02,840 --> 00:13:04,480
[Music]

374
00:13:04,480 --> 00:13:06,560
now i will provide some more detailed

375
00:13:06,560 --> 00:13:09,360
analysis of our findings

376
00:13:09,360 --> 00:13:11,360
uh here i would like to show you how the

377
00:13:11,360 --> 00:13:13,519
initial vulnerabilities compare to the

378
00:13:13,519 --> 00:13:14,639
previous studies

379
00:13:14,639 --> 00:13:17,200
and on the picture you can see the

380
00:13:17,200 --> 00:13:19,200
ratios between our findings and the

381
00:13:19,200 --> 00:13:22,320
previous work done by other researchers

382
00:13:22,320 --> 00:13:24,639
it is worth to mention that we found

383
00:13:24,639 --> 00:13:25,360
quite

384
00:13:25,360 --> 00:13:27,680
a few vulnerabilities in the transport

385
00:13:27,680 --> 00:13:28,880
and the network layers

386
00:13:28,880 --> 00:13:30,240
and these vulnerabilities are

387
00:13:30,240 --> 00:13:32,079
specifically interesting because

388
00:13:32,079 --> 00:13:34,399
most of them are independent of a user

389
00:13:34,399 --> 00:13:35,760
application

390
00:13:35,760 --> 00:13:38,560
that runs on top of them and also target

391
00:13:38,560 --> 00:13:39,760
device

392
00:13:39,760 --> 00:13:41,600
that is vulnerable doesn't need to have

393
00:13:41,600 --> 00:13:43,440
any open pores for triggering these

394
00:13:43,440 --> 00:13:45,199
vulnerabilities

395
00:13:45,199 --> 00:13:46,720
at the same time it seems that the

396
00:13:46,720 --> 00:13:48,880
overall complexity of a protocol remains

397
00:13:48,880 --> 00:13:50,240
a good indicator of potential

398
00:13:50,240 --> 00:13:51,839
vulnerabilities

399
00:13:51,839 --> 00:13:54,000
here you can see that we found quite a

400
00:13:54,000 --> 00:13:55,680
lot of vulnerabilities in dns

401
00:13:55,680 --> 00:13:58,399
applications

402
00:13:58,480 --> 00:14:00,480
if we break our findings down by

403
00:14:00,480 --> 00:14:02,000
vulnerability types

404
00:14:02,000 --> 00:14:04,880
we mostly get the following ones so we

405
00:14:04,880 --> 00:14:06,800
start with the out of bounds read and

406
00:14:06,800 --> 00:14:07,519
write

407
00:14:07,519 --> 00:14:09,760
where attackers control length and

408
00:14:09,760 --> 00:14:12,000
offset fields of network packets

409
00:14:12,000 --> 00:14:14,079
and these offsets might influence memory

410
00:14:14,079 --> 00:14:15,519
related operations

411
00:14:15,519 --> 00:14:18,880
then it follows by quite a number of

412
00:14:18,880 --> 00:14:20,240
integer overflows

413
00:14:20,240 --> 00:14:22,399
where different network packets are

414
00:14:22,399 --> 00:14:24,639
incorporated into assignments and

415
00:14:24,639 --> 00:14:28,560
bars and arithmetic and there is also

416
00:14:28,560 --> 00:14:30,880
some number of state confusion bugs and

417
00:14:30,880 --> 00:14:32,560
these bugs are not related to memory

418
00:14:32,560 --> 00:14:33,920
issues directly but

419
00:14:33,920 --> 00:14:36,639
they can facilitate the exploitation of

420
00:14:36,639 --> 00:14:39,199
other issues in the stacks

421
00:14:39,199 --> 00:14:41,360
next i would like to to make just a few

422
00:14:41,360 --> 00:14:42,639
examples of

423
00:14:42,639 --> 00:14:44,160
of the vulnerabilities that we have

424
00:14:44,160 --> 00:14:47,040
found in this work

425
00:14:47,040 --> 00:14:49,120
on this slide you can see the bytes that

426
00:14:49,120 --> 00:14:51,920
correspond to icmpv6 echo request

427
00:14:51,920 --> 00:14:55,519
and the corresponding reply packet

428
00:14:55,519 --> 00:14:58,079
specifically here i highlighted the icmp

429
00:14:58,079 --> 00:14:59,440
headers that start

430
00:14:59,440 --> 00:15:01,760
from the hex value of 80 for echo

431
00:15:01,760 --> 00:15:02,720
request and

432
00:15:02,720 --> 00:15:05,760
81 is for the reply and then there is a

433
00:15:05,760 --> 00:15:06,880
code byte

434
00:15:06,880 --> 00:15:10,000
two bytes checksum two identifier bytes

435
00:15:10,000 --> 00:15:11,519
and the two bytes that represent the

436
00:15:11,519 --> 00:15:13,199
sequence number

437
00:15:13,199 --> 00:15:14,880
uh while these eight bytes are the

438
00:15:14,880 --> 00:15:16,639
minimum amount of bytes that an

439
00:15:16,639 --> 00:15:19,680
icmp payload should have which is

440
00:15:19,680 --> 00:15:21,040
exactly the header

441
00:15:21,040 --> 00:15:24,000
some tcp stacks that we analyzed will

442
00:15:24,000 --> 00:15:25,920
interpret any sequence of byte that

443
00:15:25,920 --> 00:15:28,720
starts with 80 and they will think it's

444
00:15:28,720 --> 00:15:28,959
an

445
00:15:28,959 --> 00:15:32,720
echo request so for instance

446
00:15:32,720 --> 00:15:34,320
the way they implement that is that when

447
00:15:34,320 --> 00:15:35,920
processing a request

448
00:15:35,920 --> 00:15:37,839
and preparing a reply they just change

449
00:15:37,839 --> 00:15:39,680
the first byte of the header and the

450
00:15:39,680 --> 00:15:42,000
checksum and the acmp payload and then

451
00:15:42,000 --> 00:15:43,519
they just send the rest of the packet

452
00:15:43,519 --> 00:15:45,680
back

453
00:15:45,680 --> 00:15:47,759
here is an example of one of the

454
00:15:47,759 --> 00:15:49,279
vulnerable implementations

455
00:15:49,279 --> 00:15:52,720
and it's the bike of the cpip stack

456
00:15:52,720 --> 00:15:54,800
this is the function that will take an

457
00:15:54,800 --> 00:15:56,959
icmpf a request pocket and prepare a

458
00:15:56,959 --> 00:15:57,759
reply

459
00:15:57,759 --> 00:16:00,720
that will be sent later on on the line

460
00:16:00,720 --> 00:16:01,680
68

461
00:16:01,680 --> 00:16:03,440
the memory for the reply packet is

462
00:16:03,440 --> 00:16:05,600
allocated and it will be the size of the

463
00:16:05,600 --> 00:16:06,240
data

464
00:16:06,240 --> 00:16:09,279
sent in the echo packet

465
00:16:09,279 --> 00:16:10,959
some properties of the echo packet are

466
00:16:10,959 --> 00:16:13,120
copied over into reply the next lines

467
00:16:13,120 --> 00:16:16,560
and on the line 84 the data payload of

468
00:16:16,560 --> 00:16:18,560
the echo message will be copied into the

469
00:16:18,560 --> 00:16:19,519
reply

470
00:16:19,519 --> 00:16:22,639
using the mem copy function

471
00:16:22,639 --> 00:16:25,279
here it is explicitly assumed that the

472
00:16:25,279 --> 00:16:26,399
minimum size of

473
00:16:26,399 --> 00:16:29,440
an echo message is at least 8 bytes you

474
00:16:29,440 --> 00:16:30,320
can see this

475
00:16:30,320 --> 00:16:32,480
quite lengthy constant in the third

476
00:16:32,480 --> 00:16:33,519
argument of the

477
00:16:33,519 --> 00:16:36,480
memcopic goal but unfortunately there

478
00:16:36,480 --> 00:16:37,440
are no checks

479
00:16:37,440 --> 00:16:40,959
to validate that so if we send an echo

480
00:16:40,959 --> 00:16:42,320
message that is only

481
00:16:42,320 --> 00:16:45,600
that has only a header and for example

482
00:16:45,600 --> 00:16:46,399
it consists

483
00:16:46,399 --> 00:16:48,880
only of three bytes the arithmetic

484
00:16:48,880 --> 00:16:50,720
operation and the mem copy code will

485
00:16:50,720 --> 00:16:51,920
overflow

486
00:16:51,920 --> 00:16:54,000
and the size of the copy will become a

487
00:16:54,000 --> 00:16:55,839
large positive value

488
00:16:55,839 --> 00:16:58,959
therefore in this way after when

489
00:16:58,959 --> 00:17:00,880
executing the num copy operation

490
00:17:00,880 --> 00:17:02,959
we'll attempt to copy more bytes into

491
00:17:02,959 --> 00:17:05,039
reply than we have actually allocated

492
00:17:05,039 --> 00:17:05,919
previously

493
00:17:05,919 --> 00:17:08,329
and therefore we will write out of bonds

494
00:17:08,329 --> 00:17:10,000
[Music]

495
00:17:10,000 --> 00:17:12,240
next i'd like to demonstrate uh some of

496
00:17:12,240 --> 00:17:14,319
the vulnerability anti-patterns that we

497
00:17:14,319 --> 00:17:16,160
haven't seen in the prior work

498
00:17:16,160 --> 00:17:18,000
and there are more implementation

499
00:17:18,000 --> 00:17:21,520
specific and are related to parsing ipv6

500
00:17:21,520 --> 00:17:23,280
extension headers and

501
00:17:23,280 --> 00:17:26,880
processing domain names in dns packets

502
00:17:26,880 --> 00:17:29,280
in case of extension headers we saw that

503
00:17:29,280 --> 00:17:30,480
their lengths

504
00:17:30,480 --> 00:17:32,240
and also the length of options within

505
00:17:32,240 --> 00:17:34,480
them might be not validated

506
00:17:34,480 --> 00:17:37,039
and for dns pockets we saw issues with

507
00:17:37,039 --> 00:17:37,919
not

508
00:17:37,919 --> 00:17:39,919
checking the length of a domain name as

509
00:17:39,919 --> 00:17:41,360
well as not checking whether it was

510
00:17:41,360 --> 00:17:43,040
properly null terminated

511
00:17:43,040 --> 00:17:44,559
[Music]

512
00:17:44,559 --> 00:17:46,480
the next example that i would like to

513
00:17:46,480 --> 00:17:48,400
show to you is about

514
00:17:48,400 --> 00:17:51,200
the destination options extension header

515
00:17:51,200 --> 00:17:51,919
which is

516
00:17:51,919 --> 00:17:54,240
an ipv6 header used for setting packet

517
00:17:54,240 --> 00:17:56,240
delivery parameters

518
00:17:56,240 --> 00:17:58,799
it consists of the next header the

519
00:17:58,799 --> 00:18:00,080
header extension length

520
00:18:00,080 --> 00:18:03,360
fields and a field the variable length

521
00:18:03,360 --> 00:18:04,240
field

522
00:18:04,240 --> 00:18:06,720
is called options and the options field

523
00:18:06,720 --> 00:18:07,919
itself consists

524
00:18:07,919 --> 00:18:11,039
of type length and the data fields

525
00:18:11,039 --> 00:18:14,320
in general ipvc ipv6 packets

526
00:18:14,320 --> 00:18:15,919
can have combinations of different

527
00:18:15,919 --> 00:18:18,640
extension headers with different time

528
00:18:18,640 --> 00:18:20,640
different kinds of options that you can

529
00:18:20,640 --> 00:18:22,000
nest into them

530
00:18:22,000 --> 00:18:24,480
and here on this picture below you can

531
00:18:24,480 --> 00:18:25,039
see

532
00:18:25,039 --> 00:18:29,600
the generic structure of these headers

533
00:18:29,600 --> 00:18:31,520
here on this slide is vulnerable

534
00:18:31,520 --> 00:18:33,520
function from pico2cp

535
00:18:33,520 --> 00:18:35,919
and the purpose of the function is to

536
00:18:35,919 --> 00:18:38,320
parse the destination options extension

537
00:18:38,320 --> 00:18:39,200
header

538
00:18:39,200 --> 00:18:42,240
and the nested options

539
00:18:42,240 --> 00:18:44,720
so the function first sets a pointer to

540
00:18:44,720 --> 00:18:45,919
the first byte of the

541
00:18:45,919 --> 00:18:48,880
first option found in the header and

542
00:18:48,880 --> 00:18:50,559
then it gets the total length of the

543
00:18:50,559 --> 00:18:53,039
extension header itself

544
00:18:53,039 --> 00:18:55,360
next the function parses every option in

545
00:18:55,360 --> 00:18:57,200
the loop until it reaches the end of the

546
00:18:57,200 --> 00:18:58,240
options

547
00:18:58,240 --> 00:19:01,200
uh here on the in the line 9 it reads

548
00:19:01,200 --> 00:19:03,360
the length of an individual option

549
00:19:03,360 --> 00:19:06,720
before it iterates and at the end

550
00:19:06,720 --> 00:19:09,039
at the end of each iteration the parsing

551
00:19:09,039 --> 00:19:10,160
loop jumps over

552
00:19:10,160 --> 00:19:12,720
to the next option using the length byte

553
00:19:12,720 --> 00:19:16,320
of the previous option as an offset

554
00:19:16,320 --> 00:19:17,760
there are several problems with this

555
00:19:17,760 --> 00:19:20,160
implementation and the first one is that

556
00:19:20,160 --> 00:19:22,160
the attackers may control the length of

557
00:19:22,160 --> 00:19:24,240
an individual option because it is just

558
00:19:24,240 --> 00:19:25,200
set in the header

559
00:19:25,200 --> 00:19:28,559
and it's not validated uh because of

560
00:19:28,559 --> 00:19:29,919
that they explicitly

561
00:19:29,919 --> 00:19:32,240
and implicitly control the variable that

562
00:19:32,240 --> 00:19:34,880
holds the total length of the header

563
00:19:34,880 --> 00:19:37,440
and with that they can implicitly

564
00:19:37,440 --> 00:19:39,360
control the pointer that jumps

565
00:19:39,360 --> 00:19:41,760
over the different options in the header

566
00:19:41,760 --> 00:19:43,039
[Music]

567
00:19:43,039 --> 00:19:45,440
so with this degree of control attackers

568
00:19:45,440 --> 00:19:47,520
can either shift the option pointer to

569
00:19:47,520 --> 00:19:48,240
some

570
00:19:48,240 --> 00:19:50,480
and map memory by providing large values

571
00:19:50,480 --> 00:19:51,520
to option length

572
00:19:51,520 --> 00:19:54,400
or alternatively they can make this loop

573
00:19:54,400 --> 00:19:56,240
to iterate infinitely by

574
00:19:56,240 --> 00:19:58,320
making the length of one of the options

575
00:19:58,320 --> 00:19:59,280
to be zero

576
00:19:59,280 --> 00:20:02,400
and they can do that through the integer

577
00:20:02,400 --> 00:20:04,799
overflow that can happen during the

578
00:20:04,799 --> 00:20:08,080
assignment at line nine

579
00:20:08,559 --> 00:20:11,360
uh the final example i'd like to show is

580
00:20:11,360 --> 00:20:13,840
a vulnerable function from the nut net

581
00:20:13,840 --> 00:20:15,840
and this function has some issues with

582
00:20:15,840 --> 00:20:18,559
parsing dns domain names

583
00:20:18,559 --> 00:20:20,480
first i would like to briefly illustrate

584
00:20:20,480 --> 00:20:22,880
to you how a dns response record looks

585
00:20:22,880 --> 00:20:24,720
like you can see it on the

586
00:20:24,720 --> 00:20:27,760
left upper corner of the slide so this

587
00:20:27,760 --> 00:20:29,760
record contains a sequence of byte that

588
00:20:29,760 --> 00:20:30,799
corresponds

589
00:20:30,799 --> 00:20:33,440
to a domain name that has been requested

590
00:20:33,440 --> 00:20:34,000
and

591
00:20:34,000 --> 00:20:36,960
it follows with the domain type class

592
00:20:36,960 --> 00:20:38,640
time to leave and the resource that the

593
00:20:38,640 --> 00:20:39,919
length bytes

594
00:20:39,919 --> 00:20:41,440
and then there are the bytes that

595
00:20:41,440 --> 00:20:43,120
correspond to the resource data

596
00:20:43,120 --> 00:20:45,760
for example it could be an ip address

597
00:20:45,760 --> 00:20:47,120
that corresponds to

598
00:20:47,120 --> 00:20:50,559
the domain name in question a domain

599
00:20:50,559 --> 00:20:52,880
name itself is a byte sequence that

600
00:20:52,880 --> 00:20:55,360
consists of domain labels where each

601
00:20:55,360 --> 00:20:57,039
label starts with a byte

602
00:20:57,039 --> 00:20:59,600
that indicates the length of a label and

603
00:20:59,600 --> 00:21:01,280
then it is followed by the label

604
00:21:01,280 --> 00:21:02,559
characters

605
00:21:02,559 --> 00:21:04,799
a domain name also must end with a node

606
00:21:04,799 --> 00:21:06,320
byte explicitly that

607
00:21:06,320 --> 00:21:09,520
indicates where it actually ends

608
00:21:09,520 --> 00:21:11,039
on the right you can see the vulnerable

609
00:21:11,039 --> 00:21:13,280
function from not net as i mentioned

610
00:21:13,280 --> 00:21:15,600
and this function parses individual

611
00:21:15,600 --> 00:21:18,400
domain names from a dns response packet

612
00:21:18,400 --> 00:21:20,480
and it tries to combine two things so

613
00:21:20,480 --> 00:21:23,200
first it returns the total length of the

614
00:21:23,200 --> 00:21:24,480
parse domain name

615
00:21:24,480 --> 00:21:26,000
which is then used by some other

616
00:21:26,000 --> 00:21:27,679
functions as an offset

617
00:21:27,679 --> 00:21:29,440
and it also copies the domain name

618
00:21:29,440 --> 00:21:30,880
itself

619
00:21:30,880 --> 00:21:32,880
that it parses into a separate buffer

620
00:21:32,880 --> 00:21:36,320
that it allocates in this function

621
00:21:36,320 --> 00:21:38,080
before parsing the name the function

622
00:21:38,080 --> 00:21:40,320
will first de-allocate the domain name

623
00:21:40,320 --> 00:21:40,880
buffer

624
00:21:40,880 --> 00:21:43,200
if it contains some previously allocated

625
00:21:43,200 --> 00:21:44,159
domain name

626
00:21:44,159 --> 00:21:45,919
and then it will allocate space for the

627
00:21:45,919 --> 00:21:48,320
new name based on the domain

628
00:21:48,320 --> 00:21:51,360
name length provided in the packet the

629
00:21:51,360 --> 00:21:52,240
total

630
00:21:52,240 --> 00:21:54,080
length of the domain name is obtained by

631
00:21:54,080 --> 00:21:56,400
using the astroland function

632
00:21:56,400 --> 00:22:00,640
on the line 182 as you can see

633
00:22:00,640 --> 00:22:02,159
the code will then iterate over

634
00:22:02,159 --> 00:22:03,919
individual labels and copy their

635
00:22:03,919 --> 00:22:05,840
contents into the allocated buffer

636
00:22:05,840 --> 00:22:09,520
byte by byte the problem here is that

637
00:22:09,520 --> 00:22:11,520
the aster length function

638
00:22:11,520 --> 00:22:13,520
explicitly assumes that the sequence of

639
00:22:13,520 --> 00:22:15,679
characters is not terminated

640
00:22:15,679 --> 00:22:17,520
and there are no checks where whether

641
00:22:17,520 --> 00:22:19,120
the combined lengths of individual

642
00:22:19,120 --> 00:22:20,799
labels correspond to the length of the

643
00:22:20,799 --> 00:22:22,640
domain name

644
00:22:22,640 --> 00:22:24,559
this allows attackers to explicitly

645
00:22:24,559 --> 00:22:27,039
control the allocation of the buffer

646
00:22:27,039 --> 00:22:29,440
for example they might set the null byte

647
00:22:29,440 --> 00:22:30,400
at a particular

648
00:22:30,400 --> 00:22:33,039
offset within a dns packet and at the

649
00:22:33,039 --> 00:22:33,919
same time

650
00:22:33,919 --> 00:22:36,320
the attackers may control how many bytes

651
00:22:36,320 --> 00:22:37,919
will be written into it

652
00:22:37,919 --> 00:22:40,559
so they can specify uh arbitrary label

653
00:22:40,559 --> 00:22:41,039
length

654
00:22:41,039 --> 00:22:44,400
and and do that with this offsets

655
00:22:44,400 --> 00:22:46,640
this is essentially a classical heap

656
00:22:46,640 --> 00:22:48,240
buffer overflow

657
00:22:48,240 --> 00:22:50,559
for example here on the left you can see

658
00:22:50,559 --> 00:22:52,640
that the label length byte

659
00:22:52,640 --> 00:22:56,400
that says the label is 176 by

660
00:22:56,400 --> 00:23:00,720
bytes long we inserted here however a

661
00:23:00,720 --> 00:23:01,919
fake null byte that

662
00:23:01,919 --> 00:23:04,880
is about only 80 bytes this means that

663
00:23:04,880 --> 00:23:08,159
we will attempt to write 176 bytes into

664
00:23:08,159 --> 00:23:09,360
the buffer that is just

665
00:23:09,360 --> 00:23:13,200
80 bytes long we managed to exploit

666
00:23:13,200 --> 00:23:15,360
this vulnerability by creating a

667
00:23:15,360 --> 00:23:18,240
malicious dns server that replies

668
00:23:18,240 --> 00:23:21,600
to to the requests from a vulnerable.net

669
00:23:21,600 --> 00:23:23,039
dns client

670
00:23:23,039 --> 00:23:25,600
in this example a malicious dns response

671
00:23:25,600 --> 00:23:26,480
contains

672
00:23:26,480 --> 00:23:28,799
two answer records here i would like

673
00:23:28,799 --> 00:23:29,679
just to

674
00:23:29,679 --> 00:23:32,240
provide a high level overview and the

675
00:23:32,240 --> 00:23:34,159
detailed exploitation write-up will be

676
00:23:34,159 --> 00:23:36,320
coming soon

677
00:23:36,320 --> 00:23:38,640
the specifics are that the nato s has a

678
00:23:38,640 --> 00:23:40,159
simple hip allocator

679
00:23:40,159 --> 00:23:43,440
which maintains singly linked free chunk

680
00:23:43,440 --> 00:23:43,919
list

681
00:23:43,919 --> 00:23:46,240
and it has a deterministic best fit

682
00:23:46,240 --> 00:23:47,919
algorithm

683
00:23:47,919 --> 00:23:50,159
moreover there are some very simple

684
00:23:50,159 --> 00:23:52,480
optional hip guards

685
00:23:52,480 --> 00:23:54,799
so basically it will just surround the

686
00:23:54,799 --> 00:23:57,120
heat metadata of an allocated chunk with

687
00:23:57,120 --> 00:23:57,520
the

688
00:23:57,520 --> 00:24:01,440
dead beef bites it is therefore

689
00:24:01,440 --> 00:24:03,760
possible to shape the heap in a certain

690
00:24:03,760 --> 00:24:04,480
way

691
00:24:04,480 --> 00:24:07,520
and we will first set the domain name of

692
00:24:07,520 --> 00:24:09,760
the first dns sensor that we send

693
00:24:09,760 --> 00:24:12,400
to a certain size to ensure that it is

694
00:24:12,400 --> 00:24:14,400
allocated at a certain position on the

695
00:24:14,400 --> 00:24:15,760
hip

696
00:24:15,760 --> 00:24:18,000
then the date of the first response is

697
00:24:18,000 --> 00:24:19,919
also set to a certain size

698
00:24:19,919 --> 00:24:21,840
so that we can allocate it right after

699
00:24:21,840 --> 00:24:24,000
the the first domain name

700
00:24:24,000 --> 00:24:26,480
and there also after these two allocated

701
00:24:26,480 --> 00:24:27,440
chunks

702
00:24:27,440 --> 00:24:28,880
there should be a free chunk in the

703
00:24:28,880 --> 00:24:31,279
memory

704
00:24:31,360 --> 00:24:33,520
uh the domain name in the second answer

705
00:24:33,520 --> 00:24:34,400
record

706
00:24:34,400 --> 00:24:36,480
will be actually the malicious one and

707
00:24:36,480 --> 00:24:38,080
we set it to the same size

708
00:24:38,080 --> 00:24:41,120
of the first domain name so that the

709
00:24:41,120 --> 00:24:43,360
memory allocation algorithm allocates

710
00:24:43,360 --> 00:24:44,320
the second name

711
00:24:44,320 --> 00:24:46,640
in the same chunk where the first was

712
00:24:46,640 --> 00:24:47,760
one

713
00:24:47,760 --> 00:24:50,880
sorry where the first one was allocated

714
00:24:50,880 --> 00:24:53,360
the bytes we provide in the second name

715
00:24:53,360 --> 00:24:55,279
will actually cause an overflow so

716
00:24:55,279 --> 00:24:57,200
then we override the next couple of

717
00:24:57,200 --> 00:24:59,360
chunks corrupting the metadata of the

718
00:24:59,360 --> 00:25:00,960
free chunk as well

719
00:25:00,960 --> 00:25:04,159
and this will currently work because

720
00:25:04,159 --> 00:25:05,840
there are no memory protections

721
00:25:05,840 --> 00:25:07,919
on the target that that that we were

722
00:25:07,919 --> 00:25:09,039
using

723
00:25:09,039 --> 00:25:11,679
and in this way we overwrite the pointer

724
00:25:11,679 --> 00:25:13,600
to the next recharge so that it points

725
00:25:13,600 --> 00:25:15,520
to a local variable on the stack

726
00:25:15,520 --> 00:25:17,360
which we would like to use on an offset

727
00:25:17,360 --> 00:25:19,120
for writing

728
00:25:19,120 --> 00:25:21,200
when the chart that chunk that will hold

729
00:25:21,200 --> 00:25:23,120
the data for the second indents

730
00:25:23,120 --> 00:25:26,640
answer gets allocated the next pointer

731
00:25:26,640 --> 00:25:28,080
of the free chunk already point

732
00:25:28,080 --> 00:25:30,720
somewhere into the stack frame

733
00:25:30,720 --> 00:25:32,400
and this is where the newly allocated

734
00:25:32,400 --> 00:25:34,799
data will be actually written

735
00:25:34,799 --> 00:25:37,120
therefore whatever we specify in the

736
00:25:37,120 --> 00:25:38,799
data of the second answer will be

737
00:25:38,799 --> 00:25:40,000
written into the

738
00:25:40,000 --> 00:25:42,480
that stack frame offset and it will

739
00:25:42,480 --> 00:25:44,240
allow us eventually to hijack the

740
00:25:44,240 --> 00:25:45,360
control from

741
00:25:45,360 --> 00:25:47,919
the control flow so in this way we can

742
00:25:47,919 --> 00:25:49,200
also then create

743
00:25:49,200 --> 00:25:52,880
uh the rock chain uh and then redirect

744
00:25:52,880 --> 00:25:54,880
the the execution to the show code of

745
00:25:54,880 --> 00:25:57,840
our choice

746
00:25:58,240 --> 00:26:00,960
here we have developed this proof of

747
00:26:00,960 --> 00:26:02,080
concept against

748
00:26:02,080 --> 00:26:04,720
the latest version of the nato s and for

749
00:26:04,720 --> 00:26:07,200
that we used the ethernet 5 development

750
00:26:07,200 --> 00:26:08,159
board

751
00:26:08,159 --> 00:26:10,320
as you can see here the payload simply

752
00:26:10,320 --> 00:26:12,640
prints string over uart

753
00:26:12,640 --> 00:26:14,480
but we can't do much more like

754
00:26:14,480 --> 00:26:15,919
manipulating uh

755
00:26:15,919 --> 00:26:18,240
inputs and outputs we can extract

756
00:26:18,240 --> 00:26:20,159
cryptographic key material or

757
00:26:20,159 --> 00:26:22,320
interact with other buses available on

758
00:26:22,320 --> 00:26:25,200
the device

759
00:26:25,200 --> 00:26:27,120
the main lesson learned actually after

760
00:26:27,120 --> 00:26:28,240
this

761
00:26:28,240 --> 00:26:31,200
was that for embedded systems there is a

762
00:26:31,200 --> 00:26:32,720
big difference between

763
00:26:32,720 --> 00:26:34,480
the perceived potential impact of

764
00:26:34,480 --> 00:26:35,840
vulnerability

765
00:26:35,840 --> 00:26:38,559
and the actual impact and exploitability

766
00:26:38,559 --> 00:26:41,039
against a particular target

767
00:26:41,039 --> 00:26:42,960
there are many moving parts that can

768
00:26:42,960 --> 00:26:44,960
actually dramatically change these

769
00:26:44,960 --> 00:26:45,679
factors

770
00:26:45,679 --> 00:26:47,840
and i would like to mention some of them

771
00:26:47,840 --> 00:26:49,120
the first one is the

772
00:26:49,120 --> 00:26:51,520
configuration of the stock itself

773
00:26:51,520 --> 00:26:53,440
because some components and features may

774
00:26:53,440 --> 00:26:54,880
be disabled

775
00:26:54,880 --> 00:26:56,640
network buffers that we are trying to

776
00:26:56,640 --> 00:26:58,640
overflow may have different sizes on

777
00:26:58,640 --> 00:27:00,000
different devices

778
00:27:00,000 --> 00:27:02,240
and also they might be using different

779
00:27:02,240 --> 00:27:04,400
memory memory allocators and

780
00:27:04,400 --> 00:27:07,760
and so on the network and

781
00:27:07,760 --> 00:27:10,159
hardware drive drivers configuration

782
00:27:10,159 --> 00:27:12,400
also play a significant role because

783
00:27:12,400 --> 00:27:14,480
some of the stacks may be configured to

784
00:27:14,480 --> 00:27:16,720
offload validation and filtering

785
00:27:16,720 --> 00:27:20,480
of network packets to them also the

786
00:27:20,480 --> 00:27:23,440
target platform um on which the tcp

787
00:27:23,440 --> 00:27:24,399
stack runs

788
00:27:24,399 --> 00:27:27,440
has a significant impact so the things

789
00:27:27,440 --> 00:27:28,159
like

790
00:27:28,159 --> 00:27:30,080
memory protection support whether it's

791
00:27:30,080 --> 00:27:31,760
enabled or disabled

792
00:27:31,760 --> 00:27:34,960
different built-in security features or

793
00:27:34,960 --> 00:27:37,200
a specific way in which defaults are

794
00:27:37,200 --> 00:27:38,000
handled

795
00:27:38,000 --> 00:27:40,559
within the device also the presence of

796
00:27:40,559 --> 00:27:42,320
watchdog timers

797
00:27:42,320 --> 00:27:45,520
plays quite a big role in this there is

798
00:27:45,520 --> 00:27:47,520
also a big difference between cases when

799
00:27:47,520 --> 00:27:49,679
a tcpap stack runs as a part of

800
00:27:49,679 --> 00:27:51,360
real-time operating system

801
00:27:51,360 --> 00:27:55,840
or it runs just on a bare metal setup

802
00:27:55,840 --> 00:27:57,600
to quickly illustrate these points i'd

803
00:27:57,600 --> 00:27:59,600
like to show you two small examples

804
00:27:59,600 --> 00:28:01,279
the potential impact of the

805
00:28:01,279 --> 00:28:02,799
vulnerability on the left

806
00:28:02,799 --> 00:28:04,799
is denial of service that can be

807
00:28:04,799 --> 00:28:06,320
triggered

808
00:28:06,320 --> 00:28:08,159
when reading out of bonds within the

809
00:28:08,159 --> 00:28:10,399
checksum calculation function

810
00:28:10,399 --> 00:28:12,799
but to actually achieve this impact that

811
00:28:12,799 --> 00:28:15,039
the target device must not offload the

812
00:28:15,039 --> 00:28:19,440
some calculation to any other driver

813
00:28:19,440 --> 00:28:21,760
exactly this function has must be called

814
00:28:21,760 --> 00:28:23,760
a memory protection unit here

815
00:28:23,760 --> 00:28:26,880
must be also enabled and it also depends

816
00:28:26,880 --> 00:28:28,320
on how the memory related

817
00:28:28,320 --> 00:28:31,600
faults are handled for example in some

818
00:28:31,600 --> 00:28:32,640
ways it might

819
00:28:32,640 --> 00:28:35,440
just hun indefinitely or the device can

820
00:28:35,440 --> 00:28:36,080
be reset

821
00:28:36,080 --> 00:28:39,120
after a while the example on the right

822
00:28:39,120 --> 00:28:40,960
is a vulnerability that can lead to an

823
00:28:40,960 --> 00:28:43,039
infinite loop when parsing

824
00:28:43,039 --> 00:28:45,679
no from tcp options in this case

825
00:28:45,679 --> 00:28:47,520
depending on a task scheduler

826
00:28:47,520 --> 00:28:49,440
the entire system may hang causing a

827
00:28:49,440 --> 00:28:50,559
denial of service

828
00:28:50,559 --> 00:28:53,039
and if no watchdog timer is present the

829
00:28:53,039 --> 00:28:55,520
system will hang indefinitely

830
00:28:55,520 --> 00:28:57,440
otherwise if there is a watchdog timer

831
00:28:57,440 --> 00:28:59,279
however only the network

832
00:28:59,279 --> 00:29:01,520
functionality might be affected by the

833
00:29:01,520 --> 00:29:02,720
exploitation

834
00:29:02,720 --> 00:29:04,640
and the system itself might be reset

835
00:29:04,640 --> 00:29:07,279
after some time

836
00:29:07,279 --> 00:29:09,120
thank you very much and i would like to

837
00:29:09,120 --> 00:29:12,000
give floor to daniel

838
00:29:12,000 --> 00:29:13,679
so thank you stanislav for giving us so

839
00:29:13,679 --> 00:29:15,600
many details into the vulnerabilities

840
00:29:15,600 --> 00:29:16,880
that we found and

841
00:29:16,880 --> 00:29:18,720
insights into vulnerabilities in tcpap

842
00:29:18,720 --> 00:29:20,480
stacks in general but now i'd like to

843
00:29:20,480 --> 00:29:22,000
talk about the consequences of these

844
00:29:22,000 --> 00:29:23,679
types of vulnerabilities so

845
00:29:23,679 --> 00:29:26,000
the first challenge that we have with

846
00:29:26,000 --> 00:29:27,600
tcpap's site vulnerabilities is to

847
00:29:27,600 --> 00:29:29,039
identify

848
00:29:29,039 --> 00:29:31,360
affected systems in this research we use

849
00:29:31,360 --> 00:29:32,399
three data sources

850
00:29:32,399 --> 00:29:34,320
including documentation of devices that

851
00:29:34,320 --> 00:29:35,840
we found online online

852
00:29:35,840 --> 00:29:37,760
instances of devices using tools such as

853
00:29:37,760 --> 00:29:40,080
showdown and fingerprints on proprietary

854
00:29:40,080 --> 00:29:42,080
repository which we call the device

855
00:29:42,080 --> 00:29:43,919
cloud within for scout

856
00:29:43,919 --> 00:29:46,960
that allowed us to identify close to 150

857
00:29:46,960 --> 00:29:49,200
potentially affected vendors

858
00:29:49,200 --> 00:29:52,559
and these vendors produce devices such

859
00:29:52,559 --> 00:29:52,960
as

860
00:29:52,960 --> 00:29:54,960
embedded components systems on a chip

861
00:29:54,960 --> 00:29:56,559
connectivity modules and so on and

862
00:29:56,559 --> 00:29:58,159
network and office devices such as

863
00:29:58,159 --> 00:29:59,840
printers routers

864
00:29:59,840 --> 00:30:02,320
consumer iot devices such as smart plugs

865
00:30:02,320 --> 00:30:03,120
and sensors

866
00:30:03,120 --> 00:30:05,120
and ot devices that are used in building

867
00:30:05,120 --> 00:30:06,799
automation sensors and

868
00:30:06,799 --> 00:30:08,000
building automation systems and

869
00:30:08,000 --> 00:30:10,960
industrial control systems um

870
00:30:10,960 --> 00:30:13,200
these many of these vulnerabilities

871
00:30:13,200 --> 00:30:14,720
affect these components that are high up

872
00:30:14,720 --> 00:30:16,640
in the supply chain such as the socs

873
00:30:16,640 --> 00:30:17,440
that we mentioned

874
00:30:17,440 --> 00:30:18,880
and then trickle down to many different

875
00:30:18,880 --> 00:30:20,799
vendors and verticals right so that

876
00:30:20,799 --> 00:30:22,399
that's why it's difficult to identify

877
00:30:22,399 --> 00:30:24,240
idea devices that are that are actually

878
00:30:24,240 --> 00:30:25,279
affected

879
00:30:25,279 --> 00:30:28,640
um we know that popular components and

880
00:30:28,640 --> 00:30:30,080
devices such as the wi-fi

881
00:30:30,080 --> 00:30:31,679
sucks network switches are shipped into

882
00:30:31,679 --> 00:30:33,600
millions but other devices

883
00:30:33,600 --> 00:30:35,679
such as rtus and ot devices are much

884
00:30:35,679 --> 00:30:36,880
harder to estimate

885
00:30:36,880 --> 00:30:38,159
so it's difficult to know the actual

886
00:30:38,159 --> 00:30:41,919
number of devices that are out there

887
00:30:42,320 --> 00:30:44,880
another issue with tcp stack

888
00:30:44,880 --> 00:30:46,640
vulnerabilities is actual patching right

889
00:30:46,640 --> 00:30:47,919
so for instance we identified

890
00:30:47,919 --> 00:30:49,440
vulnerabilities on a tcp

891
00:30:49,440 --> 00:30:51,279
stack that is produced and maintained by

892
00:30:51,279 --> 00:30:52,480
a vendor a

893
00:30:52,480 --> 00:30:54,960
but that ends up in an operating system

894
00:30:54,960 --> 00:30:55,520
that is

895
00:30:55,520 --> 00:30:57,279
produced by another vendor and then

896
00:30:57,279 --> 00:30:59,039
embedded into a network management card

897
00:30:59,039 --> 00:31:00,159
of another vendor

898
00:31:00,159 --> 00:31:03,120
and then finally that is part of a ups

899
00:31:03,120 --> 00:31:05,679
that is sold to an end user by a fourth

900
00:31:05,679 --> 00:31:06,559
vendor

901
00:31:06,559 --> 00:31:08,720
and uh the vulnerabilities that were

902
00:31:08,720 --> 00:31:09,679
identified

903
00:31:09,679 --> 00:31:12,799
in the tcpap stack never actually were

904
00:31:12,799 --> 00:31:14,640
never actually patched

905
00:31:14,640 --> 00:31:16,720
uh in the ups because basically the

906
00:31:16,720 --> 00:31:18,000
operating system vendor

907
00:31:18,000 --> 00:31:21,120
is now out of business so there is a

908
00:31:21,120 --> 00:31:22,960
broken link in the supply chain which

909
00:31:22,960 --> 00:31:25,120
means that the end user will not get the

910
00:31:25,120 --> 00:31:26,159
proper patches

911
00:31:26,159 --> 00:31:29,200
for these vulnerabilities uh

912
00:31:29,200 --> 00:31:32,799
so this is just an example uh that

913
00:31:32,799 --> 00:31:36,159
highlights a more a broader issue

914
00:31:36,159 --> 00:31:37,840
which is the fact that vulnerable code

915
00:31:37,840 --> 00:31:40,159
spreads widely especially in open source

916
00:31:40,159 --> 00:31:41,760
projects that we dealt with

917
00:31:41,760 --> 00:31:44,880
uh for amnesia 33 many of those start by

918
00:31:44,880 --> 00:31:45,840
forking

919
00:31:45,840 --> 00:31:47,600
code and then evolve independently

920
00:31:47,600 --> 00:31:49,679
sometimes only single components

921
00:31:49,679 --> 00:31:52,320
of another project are used and then

922
00:31:52,320 --> 00:31:54,000
different versions of the stack might be

923
00:31:54,000 --> 00:31:55,440
forked into different projects so we

924
00:31:55,440 --> 00:31:56,720
have a tree there

925
00:31:56,720 --> 00:31:59,200
that shows the example of micro ip which

926
00:31:59,200 --> 00:32:00,080
is used by

927
00:32:00,080 --> 00:32:02,399
operating systems such as contiki uh and

928
00:32:02,399 --> 00:32:04,320
attacks and other projects such as open

929
00:32:04,320 --> 00:32:05,440
ice cozy and

930
00:32:05,440 --> 00:32:08,320
some d-link firmware but the fact is

931
00:32:08,320 --> 00:32:11,039
that different versions of them are

932
00:32:11,039 --> 00:32:14,480
vulnerable in different ways and

933
00:32:14,480 --> 00:32:16,720
the fixes are also uh being done

934
00:32:16,720 --> 00:32:17,600
differently but

935
00:32:17,600 --> 00:32:19,519
and and that's what i want to discuss uh

936
00:32:19,519 --> 00:32:20,880
in this slide is who is actually

937
00:32:20,880 --> 00:32:22,640
responsible for fixes right

938
00:32:22,640 --> 00:32:24,159
we disclosed these vulnerabilities to

939
00:32:24,159 --> 00:32:26,000
coordinating agencies such as the search

940
00:32:26,000 --> 00:32:27,440
cc and ics cert

941
00:32:27,440 --> 00:32:28,880
they got the help of other security

942
00:32:28,880 --> 00:32:30,960
teams and agencies and so on but despite

943
00:32:30,960 --> 00:32:33,120
all this effort no official patches

944
00:32:33,120 --> 00:32:35,120
were produced for some of the original

945
00:32:35,120 --> 00:32:37,360
projects such as micro ip and contiki

946
00:32:37,360 --> 00:32:39,279
which led to vendors implementing their

947
00:32:39,279 --> 00:32:40,640
own patches which means that there's

948
00:32:40,640 --> 00:32:42,320
more code fragmentation

949
00:32:42,320 --> 00:32:44,240
and that all of these issues will need

950
00:32:44,240 --> 00:32:46,320
to trickle down to oems product vendors

951
00:32:46,320 --> 00:32:48,000
and end users which as we saw in the

952
00:32:48,000 --> 00:32:49,679
previous slide it's not always an easy

953
00:32:49,679 --> 00:32:50,799
task

954
00:32:50,799 --> 00:32:54,559
um but not just identifying and patching

955
00:32:54,559 --> 00:32:57,840
this devices is is complicated but there

956
00:32:57,840 --> 00:32:59,440
is also the aggravating factor that

957
00:32:59,440 --> 00:33:01,600
there are new attack scenarios that are

958
00:33:01,600 --> 00:33:03,919
enabled by these uh these types of

959
00:33:03,919 --> 00:33:05,600
vulnerabilities right so nowadays

960
00:33:05,600 --> 00:33:07,440
there's this wide range of devices that

961
00:33:07,440 --> 00:33:08,559
are vulnerable

962
00:33:08,559 --> 00:33:10,559
and several of them communicate

963
00:33:10,559 --> 00:33:12,640
externally for instance with dns servers

964
00:33:12,640 --> 00:33:14,000
we saw how dns

965
00:33:14,000 --> 00:33:17,120
uh is is a an error prone component

966
00:33:17,120 --> 00:33:20,640
that is of high value for for attackers

967
00:33:20,640 --> 00:33:24,159
and uh this basically means that

968
00:33:24,159 --> 00:33:26,080
several locations within an organization

969
00:33:26,080 --> 00:33:28,080
now here we illustrate retail branch

970
00:33:28,080 --> 00:33:29,840
enterprise hq and substation are

971
00:33:29,840 --> 00:33:33,519
vulnerable right and it might be that

972
00:33:33,679 --> 00:33:36,240
an attacker uses the dns vulnerabilities

973
00:33:36,240 --> 00:33:37,279
for initial access

974
00:33:37,279 --> 00:33:39,279
and moves laterally from one part of the

975
00:33:39,279 --> 00:33:40,720
organization to the next

976
00:33:40,720 --> 00:33:43,360
and in the end causes an impact in in

977
00:33:43,360 --> 00:33:44,399
his or her

978
00:33:44,399 --> 00:33:46,960
uh final target uh all of that using

979
00:33:46,960 --> 00:33:49,919
vulnerabilities in tcp stacks so

980
00:33:49,919 --> 00:33:51,600
the key takeaways from from this

981
00:33:51,600 --> 00:33:54,080
research are that tcpap stacks are

982
00:33:54,080 --> 00:33:55,360
vulnerable across the board

983
00:33:55,360 --> 00:33:56,960
there are some resilient stacks but the

984
00:33:56,960 --> 00:33:59,600
rule of thumb is that we find many bugs

985
00:33:59,600 --> 00:34:01,919
upon a closed inspection uh these

986
00:34:01,919 --> 00:34:03,840
vulnerabilities arise from well-known

987
00:34:03,840 --> 00:34:06,080
bad software development practices there

988
00:34:06,080 --> 00:34:07,760
are bugs in several components but they

989
00:34:07,760 --> 00:34:09,119
tend to correlate with protocol

990
00:34:09,119 --> 00:34:10,159
complexity

991
00:34:10,159 --> 00:34:12,079
the iot risk management is very

992
00:34:12,079 --> 00:34:14,000
difficult because these vulnerabilities

993
00:34:14,000 --> 00:34:15,520
affect hundreds of vendors and millions

994
00:34:15,520 --> 00:34:16,879
of devices

995
00:34:16,879 --> 00:34:18,719
the exploitability is highly device

996
00:34:18,719 --> 00:34:20,800
specific and this complex supply chains

997
00:34:20,800 --> 00:34:22,639
make it challenging to determine so to

998
00:34:22,639 --> 00:34:23,839
identify

999
00:34:23,839 --> 00:34:26,239
vulnerable devices and to patch and

1000
00:34:26,239 --> 00:34:27,918
eradicate those vulnerabilities

1001
00:34:27,918 --> 00:34:30,399
but there is something that can be done

1002
00:34:30,399 --> 00:34:31,839
on a more hopeful

1003
00:34:31,839 --> 00:34:34,560
tone we all know that it's difficult to

1004
00:34:34,560 --> 00:34:36,239
identify the devices on the network that

1005
00:34:36,239 --> 00:34:37,839
are vulnerable because that requires

1006
00:34:37,839 --> 00:34:39,599
some specific knowledge some accurate

1007
00:34:39,599 --> 00:34:41,280
fingerprinting and that patching

1008
00:34:41,280 --> 00:34:43,199
sometimes may be impossible because the

1009
00:34:43,199 --> 00:34:44,960
vendors may not know or not patch or

1010
00:34:44,960 --> 00:34:46,320
even be out of business

1011
00:34:46,320 --> 00:34:47,359
but there are some specific

1012
00:34:47,359 --> 00:34:49,119
recommendations that can be done to

1013
00:34:49,119 --> 00:34:50,879
mitigate these issues right so

1014
00:34:50,879 --> 00:34:53,280
disabling or blocking ipv6 traffic when

1015
00:34:53,280 --> 00:34:54,800
it's not needed for instance because

1016
00:34:54,800 --> 00:34:55,679
several

1017
00:34:55,679 --> 00:34:57,920
as we saw several ipv6 implementations

1018
00:34:57,920 --> 00:34:59,280
are vulnerable

1019
00:34:59,280 --> 00:35:02,079
and often they are not uh used within

1020
00:35:02,079 --> 00:35:03,359
enterprise networks so

1021
00:35:03,359 --> 00:35:05,359
there's no reason why this this traffic

1022
00:35:05,359 --> 00:35:06,560
should be allowed

1023
00:35:06,560 --> 00:35:09,440
relying on internal dns servers for uh

1024
00:35:09,440 --> 00:35:11,200
critical devices

1025
00:35:11,200 --> 00:35:12,720
monitoring the network for anomalous

1026
00:35:12,720 --> 00:35:14,800
packets and basically segmenting the

1027
00:35:14,800 --> 00:35:16,400
network to avoid

1028
00:35:16,400 --> 00:35:18,320
that critical devices are used as an

1029
00:35:18,320 --> 00:35:20,160
early entry point

1030
00:35:20,160 --> 00:35:23,520
as as the target of an attack or even as

1031
00:35:23,520 --> 00:35:25,040
a pivot point within the network for

1032
00:35:25,040 --> 00:35:28,000
lateral movement um

1033
00:35:28,000 --> 00:35:30,079
but we also want to talk about what

1034
00:35:30,079 --> 00:35:31,760
comes next in this research and what we

1035
00:35:31,760 --> 00:35:33,280
want to do in the future

1036
00:35:33,280 --> 00:35:35,359
so we see vulnerabilities resulting from

1037
00:35:35,359 --> 00:35:36,880
protocol complexity and external

1038
00:35:36,880 --> 00:35:38,960
dependencies in multiple stacks

1039
00:35:38,960 --> 00:35:41,119
we already have vulnerabilities in six

1040
00:35:41,119 --> 00:35:43,119
stacks from one case of this type of

1041
00:35:43,119 --> 00:35:44,000
vulnerability

1042
00:35:44,000 --> 00:35:45,839
and we have severes in eight stacks for

1043
00:35:45,839 --> 00:35:47,200
another case of this type of

1044
00:35:47,200 --> 00:35:49,440
ability both cases are reminiscent of

1045
00:35:49,440 --> 00:35:52,079
issues seen in the 90s and early 2000s

1046
00:35:52,079 --> 00:35:53,760
uh we also see vulnerabilities in

1047
00:35:53,760 --> 00:35:55,359
popular close source stacks that are

1048
00:35:55,359 --> 00:35:57,040
used in several critical devices we

1049
00:35:57,040 --> 00:35:59,119
already have eight cvs for two

1050
00:35:59,119 --> 00:36:01,760
stacks there and we just see that

1051
00:36:01,760 --> 00:36:03,359
popular stacks tend to be highly

1052
00:36:03,359 --> 00:36:05,440
vulnerable non-robust and known rfc

1053
00:36:05,440 --> 00:36:06,560
compliant

1054
00:36:06,560 --> 00:36:09,119
and we basically are going through a

1055
00:36:09,119 --> 00:36:11,040
proper and coordinated vulnerability

1056
00:36:11,040 --> 00:36:11,760
disclosure

1057
00:36:11,760 --> 00:36:13,280
for all of those issues and we want to

1058
00:36:13,280 --> 00:36:15,680
present them as soon as possible

1059
00:36:15,680 --> 00:36:17,920
um we also would like to discuss the

1060
00:36:17,920 --> 00:36:20,000
current disclosure process and how to

1061
00:36:20,000 --> 00:36:22,160
scale it to the iot supply chain because

1062
00:36:22,160 --> 00:36:23,200
as we saw

1063
00:36:23,200 --> 00:36:25,839
uh that's really challenging nowadays

1064
00:36:25,839 --> 00:36:26,880
and we would like to

1065
00:36:26,880 --> 00:36:28,400
expand on recommendations about

1066
00:36:28,400 --> 00:36:30,160
mitigation um for

1067
00:36:30,160 --> 00:36:33,760
other stacks or um for other issues that

1068
00:36:33,760 --> 00:36:35,440
we find in the future

1069
00:36:35,440 --> 00:36:36,640
that's it thank you so much for

1070
00:36:36,640 --> 00:36:38,320
listening to us and i would like to take

1071
00:36:38,320 --> 00:36:39,200
some questions

1072
00:36:39,200 --> 00:36:41,839
thank you very much

