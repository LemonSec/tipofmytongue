1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:16,640 --> 00:00:17,440
hi everyone

3
00:00:17,440 --> 00:00:20,480
uh thank you for joining our talk uh we

4
00:00:20,480 --> 00:00:22,640
are happy today to share our notes on

5
00:00:22,640 --> 00:00:24,000
the exploitation of

6
00:00:24,000 --> 00:00:26,000
zero day webkit vulnerabilities on the

7
00:00:26,000 --> 00:00:28,800
playstation 4.

8
00:00:29,119 --> 00:00:32,640
uh here is the outline of the talk after

9
00:00:32,640 --> 00:00:34,559
a brief introduction we'll present the

10
00:00:34,559 --> 00:00:36,719
ps4 attack surface as well as the

11
00:00:36,719 --> 00:00:39,520
previous research in this field

12
00:00:39,520 --> 00:00:42,399
then represent our bug and the

13
00:00:42,399 --> 00:00:44,079
exploitation of that particular bug

14
00:00:44,079 --> 00:00:45,760
requires a deep understanding of the

15
00:00:45,760 --> 00:00:47,200
primary heap allocator

16
00:00:47,200 --> 00:00:50,079
so we'll present how fast malloc works

17
00:00:50,079 --> 00:00:50,559
uh

18
00:00:50,559 --> 00:00:52,559
then we'll present our exploitation

19
00:00:52,559 --> 00:00:54,559
strategy and give a little demo

20
00:00:54,559 --> 00:00:56,719
and finally we'll conclude this talk and

21
00:00:56,719 --> 00:00:58,079
present what we planned

22
00:00:58,079 --> 00:01:02,640
next uh before we start

23
00:01:02,640 --> 00:01:05,519
let us introduce ourselves a meditating

24
00:01:05,519 --> 00:01:08,320
and i will give this talk with contamir

25
00:01:08,320 --> 00:01:10,400
we are both security researcher at syn

26
00:01:10,400 --> 00:01:12,080
active an office security

27
00:01:12,080 --> 00:01:15,680
company based in france and we are both

28
00:01:15,680 --> 00:01:17,680
part of the reverse engineering team

29
00:01:17,680 --> 00:01:21,840
working mainly on vulnerability research

30
00:01:21,920 --> 00:01:25,119
okay this is important please note that

31
00:01:25,119 --> 00:01:28,320
we do not this occur that this research

32
00:01:28,320 --> 00:01:30,560
is done purely for educational purpose

33
00:01:30,560 --> 00:01:31,920
and we do not

34
00:01:31,920 --> 00:01:34,320
help support or endorse by any means to

35
00:01:34,320 --> 00:01:37,360
break the copyright law

36
00:01:37,920 --> 00:01:41,520
okay now how all of this started um

37
00:01:41,520 --> 00:01:43,840
our internal fuzzer have reported a

38
00:01:43,840 --> 00:01:44,960
webkit bug

39
00:01:44,960 --> 00:01:46,960
and we decided to give it a try on a

40
00:01:46,960 --> 00:01:49,520
device like the ps4

41
00:01:49,520 --> 00:01:51,280
why that because despite an active

42
00:01:51,280 --> 00:01:52,840
console hacking

43
00:01:52,840 --> 00:01:55,520
community there is only few public

44
00:01:55,520 --> 00:01:56,799
exploits

45
00:01:56,799 --> 00:01:58,799
and we want to know how hard is it to

46
00:01:58,799 --> 00:02:00,960
exploit such a vulnerability on device

47
00:02:00,960 --> 00:02:02,479
like the ps4

48
00:02:02,479 --> 00:02:05,840
so the main goal the main goal of the

49
00:02:05,840 --> 00:02:06,719
tour today

50
00:02:06,719 --> 00:02:08,479
is to give a work through on the

51
00:02:08,479 --> 00:02:10,318
exploitation of a

52
00:02:10,318 --> 00:02:12,480
zero day webkit vulnerability on the

53
00:02:12,480 --> 00:02:15,280
playstation 4.

54
00:02:15,520 --> 00:02:17,040
okay now let's move to the attack

55
00:02:17,040 --> 00:02:19,760
surface part

56
00:02:19,920 --> 00:02:22,879
here the browser is probably the most

57
00:02:22,879 --> 00:02:24,480
common entry point that's what we

58
00:02:24,480 --> 00:02:27,760
did we can also attack the ps4 through

59
00:02:27,760 --> 00:02:29,680
game saves

60
00:02:29,680 --> 00:02:31,680
or decide to attack directly the camera

61
00:02:31,680 --> 00:02:34,480
which is actually freebsd camera

62
00:02:34,480 --> 00:02:37,120
for example one can attack the usb the

63
00:02:37,120 --> 00:02:37,680
usb

64
00:02:37,680 --> 00:02:41,120
wi-fi or the bluetooth stack

65
00:02:41,120 --> 00:02:44,080
now if we consider attacking a userland

66
00:02:44,080 --> 00:02:44,959
process

67
00:02:44,959 --> 00:02:47,040
a typical exploit chain combines a

68
00:02:47,040 --> 00:02:48,480
webkit exploit

69
00:02:48,480 --> 00:02:50,480
to get code execution in the context of

70
00:02:50,480 --> 00:02:52,560
the render process

71
00:02:52,560 --> 00:02:55,280
then find a way to bypass the sandbox

72
00:02:55,280 --> 00:02:58,239
and run a kernel exploit

73
00:02:58,239 --> 00:03:00,800
now as well as we say the ps4 browser is

74
00:03:00,800 --> 00:03:01,280
based

75
00:03:01,280 --> 00:03:04,959
on webkits and the renderer process is

76
00:03:04,959 --> 00:03:06,879
unboxed

77
00:03:06,879 --> 00:03:08,800
there is no jit which means that it

78
00:03:08,800 --> 00:03:10,800
could be a little bit harder to get

79
00:03:10,800 --> 00:03:13,120
code execution however there is no

80
00:03:13,120 --> 00:03:14,720
modern mitigation like

81
00:03:14,720 --> 00:03:16,800
giga cage or the randomization of

82
00:03:16,800 --> 00:03:18,000
structure id

83
00:03:18,000 --> 00:03:20,159
which means that it could be easier to

84
00:03:20,159 --> 00:03:22,239
set up to set up a primitive like the

85
00:03:22,239 --> 00:03:24,799
fake arch primitive

86
00:03:24,799 --> 00:03:28,159
slr is enabled however it is either weak

87
00:03:28,159 --> 00:03:30,959
or partial this is at least true on

88
00:03:30,959 --> 00:03:33,680
version six

89
00:03:33,680 --> 00:03:35,840
and the most annoying point there is no

90
00:03:35,840 --> 00:03:38,239
debug

91
00:03:38,640 --> 00:03:41,440
okay now there have been a couple of

92
00:03:41,440 --> 00:03:43,120
webkit vulnerabilities that have been

93
00:03:43,120 --> 00:03:45,200
successfully exploited in the past

94
00:03:45,200 --> 00:03:47,920
the first one presented here is the last

95
00:03:47,920 --> 00:03:49,680
known public exploit

96
00:03:49,680 --> 00:03:51,519
it is also known as the bad hoist

97
00:03:51,519 --> 00:03:53,200
exploit

98
00:03:53,200 --> 00:03:55,280
it exploits a vulnerability found by

99
00:03:55,280 --> 00:03:57,519
loki heart from project zero

100
00:03:57,519 --> 00:04:00,720
and they exploit

101
00:04:00,720 --> 00:04:02,319
and this vulnerability has been

102
00:04:02,319 --> 00:04:05,680
exploited by fire 30.

103
00:04:05,680 --> 00:04:07,280
the exploit provides read write

104
00:04:07,280 --> 00:04:09,360
primitives and works on firmware up to

105
00:04:09,360 --> 00:04:11,360
672

106
00:04:11,360 --> 00:04:13,040
another vulnerability found by loki

107
00:04:13,040 --> 00:04:17,839
heart have been exploited by spec to dev

108
00:04:17,839 --> 00:04:21,120
this one provides also read write

109
00:04:21,120 --> 00:04:22,240
primitives

110
00:04:22,240 --> 00:04:25,600
and works on firmware up to 620 and

111
00:04:25,600 --> 00:04:27,600
for all the firmware there is a couple

112
00:04:27,600 --> 00:04:28,880
of you know

113
00:04:28,880 --> 00:04:32,000
of exploit found by a couple of

114
00:04:32,000 --> 00:04:34,000
exploited by qwerty spected advanced

115
00:04:34,000 --> 00:04:36,400
seaters

116
00:04:36,400 --> 00:04:38,800
okay now regarding kernel exploit

117
00:04:38,800 --> 00:04:40,240
regarding canon exploit

118
00:04:40,240 --> 00:04:41,759
the last released one has been reported

119
00:04:41,759 --> 00:04:43,600
by the flow

120
00:04:43,600 --> 00:04:47,040
uh uh the bug

121
00:04:47,040 --> 00:04:49,120
the exploit provides street right

122
00:04:49,120 --> 00:04:50,720
primitives in the corner

123
00:04:50,720 --> 00:04:52,560
one interesting point is that it is

124
00:04:52,560 --> 00:04:55,440
reachable from the webkit sandbox

125
00:04:55,440 --> 00:04:59,759
and this bug is present in firmware 702

126
00:04:59,759 --> 00:05:03,680
and also on firmware 6 and recently this

127
00:05:03,680 --> 00:05:05,039
bug has been combined

128
00:05:05,039 --> 00:05:08,080
with the batteries exploit to get a full

129
00:05:08,080 --> 00:05:09,039
chain on

130
00:05:09,039 --> 00:05:12,320
firmware 6 and finally there is

131
00:05:12,320 --> 00:05:15,280
some few vulnerabilities in bpf that

132
00:05:15,280 --> 00:05:17,520
have been

133
00:05:17,520 --> 00:05:21,359
discovered and exploited by qwerty

134
00:05:21,520 --> 00:05:23,520
they work on firmware this exploits work

135
00:05:23,520 --> 00:05:25,199
on firmware up to 507

136
00:05:25,199 --> 00:05:26,960
and we strongly encourage the audience

137
00:05:26,960 --> 00:05:28,320
to read the excellent writer by

138
00:05:28,320 --> 00:05:30,800
spectrodev

139
00:05:30,800 --> 00:05:34,240
okay now let's talk about the bug

140
00:05:34,240 --> 00:05:36,240
the bug is present in the webkit domain

141
00:05:36,240 --> 00:05:38,160
giant

142
00:05:38,160 --> 00:05:40,479
it has been triggered by our internal

143
00:05:40,479 --> 00:05:42,080
further

144
00:05:42,080 --> 00:05:45,360
and this bug impacts all ps4 firmware

145
00:05:45,360 --> 00:05:49,039
and ps vita as well we have reported

146
00:05:49,039 --> 00:05:49,840
this bug to

147
00:05:49,840 --> 00:05:51,759
sony through their bug bounty program

148
00:05:51,759 --> 00:05:53,520
and now and now this vulnerability is

149
00:05:53,520 --> 00:05:56,720
fixed on version eight

150
00:05:56,720 --> 00:05:59,919
uh this vulnerability is present

151
00:05:59,919 --> 00:06:02,880
in the build bible tree method called on

152
00:06:02,880 --> 00:06:03,600
some

153
00:06:03,600 --> 00:06:06,960
validation message instance and

154
00:06:06,960 --> 00:06:09,680
this function makes at some point a call

155
00:06:09,680 --> 00:06:10,800
to update the layout

156
00:06:10,800 --> 00:06:13,039
during which all user registered gs

157
00:06:13,039 --> 00:06:15,120
handler are executed

158
00:06:15,120 --> 00:06:18,479
now if we destroy the validation message

159
00:06:18,479 --> 00:06:19,039
instance

160
00:06:19,039 --> 00:06:21,680
during a gs callback this could lead to

161
00:06:21,680 --> 00:06:23,440
use after free situation when getting

162
00:06:23,440 --> 00:06:24,000
back to

163
00:06:24,000 --> 00:06:27,300
a brilliant record

164
00:06:27,300 --> 00:06:28,639
[Music]

165
00:06:28,639 --> 00:06:30,720
actually the webkit developer have

166
00:06:30,720 --> 00:06:32,720
identified that problem may arise while

167
00:06:32,720 --> 00:06:34,960
updating the style or the layout

168
00:06:34,960 --> 00:06:37,759
however they failed to fix this bug

169
00:06:37,759 --> 00:06:38,960
properly due to

170
00:06:38,960 --> 00:06:41,360
an extra difference while making a weak

171
00:06:41,360 --> 00:06:42,400
pointer

172
00:06:42,400 --> 00:06:45,680
which means that we can still destroy

173
00:06:45,680 --> 00:06:47,520
the validation message instance during a

174
00:06:47,520 --> 00:06:50,000
layout update

175
00:06:50,000 --> 00:06:52,400
and here is the actual fix after

176
00:06:52,400 --> 00:06:53,840
reporting the validity

177
00:06:53,840 --> 00:06:57,680
after reporting the the bug

178
00:06:57,680 --> 00:07:00,720
now they do not allow anymore to update

179
00:07:00,720 --> 00:07:01,440
the layout

180
00:07:01,440 --> 00:07:04,960
in the virtual record

181
00:07:05,919 --> 00:07:09,039
okay now let's see the vulnerable path

182
00:07:09,039 --> 00:07:11,919
we can instantiate a validation message

183
00:07:11,919 --> 00:07:13,759
object by making a call to report

184
00:07:13,759 --> 00:07:16,960
validity on some html input field

185
00:07:16,960 --> 00:07:21,039
we register on that input field some gs

186
00:07:21,039 --> 00:07:23,680
some gs handler for example we can

187
00:07:23,680 --> 00:07:24,240
define

188
00:07:24,240 --> 00:07:26,960
a gs handler that is executed whenever

189
00:07:26,960 --> 00:07:28,400
the focus is set on that

190
00:07:28,400 --> 00:07:32,560
input field and then this

191
00:07:32,560 --> 00:07:34,479
function report validity will also fire

192
00:07:34,479 --> 00:07:35,759
up a timer to call

193
00:07:35,759 --> 00:07:38,160
our vulnerable function the build bible

194
00:07:38,160 --> 00:07:39,199
tree

195
00:07:39,199 --> 00:07:41,840
and if we set the focus on our input

196
00:07:41,840 --> 00:07:44,240
field before timer expiration

197
00:07:44,240 --> 00:07:47,120
then build bubble 3 will make a call to

198
00:07:47,120 --> 00:07:48,560
update the layout and

199
00:07:48,560 --> 00:07:53,199
update layout will call our gs callback

200
00:07:53,199 --> 00:07:55,280
now if we destroy in this gs callback

201
00:07:55,280 --> 00:07:56,879
the validation message instance then

202
00:07:56,879 --> 00:07:58,240
this could lead to use after free

203
00:07:58,240 --> 00:08:01,360
situation when getting back to blueberry

204
00:08:01,360 --> 00:08:04,960
now if we manage somehow to survive to

205
00:08:04,960 --> 00:08:07,199
early crashes due to

206
00:08:07,199 --> 00:08:10,639
access to unvalid validation message

207
00:08:10,639 --> 00:08:11,599
fields

208
00:08:11,599 --> 00:08:13,599
we can end up by calling this function

209
00:08:13,599 --> 00:08:15,120
delayed bubble tree

210
00:08:15,120 --> 00:08:17,680
after some timer expiration and this

211
00:08:17,680 --> 00:08:19,120
function the label tree

212
00:08:19,120 --> 00:08:20,960
will destroy again the validation

213
00:08:20,960 --> 00:08:23,919
message nonsense

214
00:08:23,919 --> 00:08:25,520
okay now let's see how we can trigger

215
00:08:25,520 --> 00:08:27,759
this bug the first step

216
00:08:27,759 --> 00:08:31,199
is to register a gs event

217
00:08:31,199 --> 00:08:34,399
on some input text field then

218
00:08:34,399 --> 00:08:37,279
the second step is to call report

219
00:08:37,279 --> 00:08:38,080
validity

220
00:08:38,080 --> 00:08:41,279
on to call report validity on our

221
00:08:41,279 --> 00:08:44,720
input text field report validity will

222
00:08:44,720 --> 00:08:46,399
instantiate our target object the

223
00:08:46,399 --> 00:08:48,240
validation message object

224
00:08:48,240 --> 00:08:51,440
and then we in our gs handler we will

225
00:08:51,440 --> 00:08:52,480
simply define

226
00:08:52,480 --> 00:08:54,640
uh we'll simply destroy the validation

227
00:08:54,640 --> 00:08:57,439
message instance

228
00:08:57,680 --> 00:08:59,839
and then when the breathability will be

229
00:08:59,839 --> 00:09:01,279
called it will make a call to update the

230
00:09:01,279 --> 00:09:01,920
layout

231
00:09:01,920 --> 00:09:04,320
and which in turn will call our gs

232
00:09:04,320 --> 00:09:05,519
callback

233
00:09:05,519 --> 00:09:08,080
we run that code but it didn't crash

234
00:09:08,080 --> 00:09:09,680
actually

235
00:09:09,680 --> 00:09:12,720
the report validity methods sets the

236
00:09:12,720 --> 00:09:14,800
focus on our input field which

237
00:09:14,800 --> 00:09:18,160
triggers our gs callback too early

238
00:09:18,160 --> 00:09:20,480
so in our second attempt we decided to

239
00:09:20,480 --> 00:09:22,800
use two input fields input one and

240
00:09:22,800 --> 00:09:26,000
input two on the first input we register

241
00:09:26,000 --> 00:09:27,040
a gs handler

242
00:09:27,040 --> 00:09:29,839
handler one that will simply set the

243
00:09:29,839 --> 00:09:31,680
focus elsewhere

244
00:09:31,680 --> 00:09:33,760
then we make a call to report validity

245
00:09:33,760 --> 00:09:37,040
that will instantiate our target object

246
00:09:37,040 --> 00:09:38,720
report validity will set the focus on

247
00:09:38,720 --> 00:09:41,120
input one our handler one is executed it

248
00:09:41,120 --> 00:09:42,880
will set the folks elsewhere for example

249
00:09:42,880 --> 00:09:43,120
on

250
00:09:43,120 --> 00:09:46,320
input two and then before

251
00:09:46,320 --> 00:09:49,279
uh timer expiration that is before

252
00:09:49,279 --> 00:09:50,080
google tree

253
00:09:50,080 --> 00:09:52,160
build bubble tree code is executed we

254
00:09:52,160 --> 00:09:54,720
register a new handler

255
00:09:54,720 --> 00:09:57,040
that uh on input one that will destroy

256
00:09:57,040 --> 00:09:59,040
the validation message instance

257
00:09:59,040 --> 00:10:01,360
then when then when will builder tree

258
00:10:01,360 --> 00:10:02,079
code

259
00:10:02,079 --> 00:10:04,959
then when buildable3 method is called it

260
00:10:04,959 --> 00:10:06,959
will make a call to update the layout

261
00:10:06,959 --> 00:10:10,079
and run our js callback and destroy

262
00:10:10,079 --> 00:10:13,040
uh our validation message instance and

263
00:10:13,040 --> 00:10:14,640
we run that code and

264
00:10:14,640 --> 00:10:19,200
it actually crashes the ps4 browse

265
00:10:19,200 --> 00:10:22,160
and here is what looks like the ps4 when

266
00:10:22,160 --> 00:10:25,199
the browser crashes

267
00:10:25,519 --> 00:10:29,120
okay now all we get are crushes

268
00:10:29,120 --> 00:10:30,880
and we do not have the building

269
00:10:30,880 --> 00:10:32,880
capabilities on the playstation 4.

270
00:10:32,880 --> 00:10:34,880
so to overcome these limitations we have

271
00:10:34,880 --> 00:10:35,920
two options

272
00:10:35,920 --> 00:10:38,959
option one is to set up a debugging

273
00:10:38,959 --> 00:10:41,040
environment as close as possible to the

274
00:10:41,040 --> 00:10:41,600
free

275
00:10:41,600 --> 00:10:44,560
to the ps4 uh environment that is

276
00:10:44,560 --> 00:10:46,560
installing a freebsd box

277
00:10:46,560 --> 00:10:49,040
and compile webkit from sources

278
00:10:49,040 --> 00:10:50,079
downloaded from

279
00:10:50,079 --> 00:10:53,600
playstation website this is helpful but

280
00:10:53,600 --> 00:10:54,399
sometimes

281
00:10:54,399 --> 00:10:56,399
working exploit on our environment does

282
00:10:56,399 --> 00:10:58,560
not mean that it will work on the ps4 so

283
00:10:58,560 --> 00:11:00,000
clearly here we need more

284
00:11:00,000 --> 00:11:03,519
debugging so we decided to use option

285
00:11:03,519 --> 00:11:04,720
two

286
00:11:04,720 --> 00:11:07,680
and debug our zero day using a one day

287
00:11:07,680 --> 00:11:09,440
and for that purpose we used the bat

288
00:11:09,440 --> 00:11:10,399
hoist exploit

289
00:11:10,399 --> 00:11:13,120
by fire 30 because it provides useful

290
00:11:13,120 --> 00:11:14,240
primitives

291
00:11:14,240 --> 00:11:16,320
like the read write primitives but also

292
00:11:16,320 --> 00:11:18,480
the classical added thereof and fake off

293
00:11:18,480 --> 00:11:20,320
primitive

294
00:11:20,320 --> 00:11:22,480
however the bad hoist exploits works

295
00:11:22,480 --> 00:11:24,880
only on firmware 6

296
00:11:24,880 --> 00:11:27,120
and sometimes running the batteries

297
00:11:27,120 --> 00:11:28,000
exploited

298
00:11:28,000 --> 00:11:30,800
prior to our exploit adds some noise on

299
00:11:30,800 --> 00:11:32,800
heap shaping

300
00:11:32,800 --> 00:11:34,320
and finally by the host exploit is not

301
00:11:34,320 --> 00:11:38,000
rearable but all of this is fine

302
00:11:39,040 --> 00:11:42,880
okay now let's see the vulnerable object

303
00:11:42,880 --> 00:11:44,640
the validation message object

304
00:11:44,640 --> 00:11:47,120
this object is instantiated by making a

305
00:11:47,120 --> 00:11:48,959
call to report validity

306
00:11:48,959 --> 00:11:51,279
it is mainly accessed by the vulnerable

307
00:11:51,279 --> 00:11:52,800
function buildable tree

308
00:11:52,800 --> 00:11:54,959
and it is finally destroyed by the

309
00:11:54,959 --> 00:11:57,279
delayed bible tree

310
00:11:57,279 --> 00:11:59,760
the validation message object is fast

311
00:11:59,760 --> 00:12:00,880
mallocked

312
00:12:00,880 --> 00:12:03,440
and is made of the following fields the

313
00:12:03,440 --> 00:12:04,320
yellow one

314
00:12:04,320 --> 00:12:07,440
are instantiated or gets reinstantiated

315
00:12:07,440 --> 00:12:10,240
after a layout update and the rest of

316
00:12:10,240 --> 00:12:10,959
the fields

317
00:12:10,959 --> 00:12:12,880
now the green one are accessed after a

318
00:12:12,880 --> 00:12:14,079
layout update

319
00:12:14,079 --> 00:12:16,720
and they point to some html element

320
00:12:16,720 --> 00:12:19,120
instance

321
00:12:19,120 --> 00:12:22,160
now what is the situation

322
00:12:22,160 --> 00:12:24,399
after destroying the validation message

323
00:12:24,399 --> 00:12:27,200
instance in our gs callback

324
00:12:27,200 --> 00:12:29,760
we have um when getting back to blue

325
00:12:29,760 --> 00:12:31,120
bubble g code

326
00:12:31,120 --> 00:12:34,320
after uh after calling our

327
00:12:34,320 --> 00:12:37,360
gs handler we have to use after three

328
00:12:37,360 --> 00:12:41,120
this and m element are freed most of the

329
00:12:41,120 --> 00:12:43,279
fields are set to new pointer

330
00:12:43,279 --> 00:12:46,959
and m element is deleted but we still

331
00:12:46,959 --> 00:12:49,920
get a reference on it

332
00:12:50,480 --> 00:12:52,880
the situation is that we crash on the

333
00:12:52,880 --> 00:12:54,560
first virtual call on

334
00:12:54,560 --> 00:12:56,800
am bubble when getting back to blueberry

335
00:12:56,800 --> 00:12:57,920
code

336
00:12:57,920 --> 00:13:00,800
and this situation is not really good so

337
00:13:00,800 --> 00:13:02,399
to exploit this vulnerability

338
00:13:02,399 --> 00:13:04,880
we need either a memory leak or find a

339
00:13:04,880 --> 00:13:05,839
way to bypass

340
00:13:05,839 --> 00:13:09,360
slr and it turns out that

341
00:13:09,360 --> 00:13:12,240
we can bypass slr uh by just keep

342
00:13:12,240 --> 00:13:13,440
spraying

343
00:13:13,440 --> 00:13:16,800
some object if we spray some a couple of

344
00:13:16,800 --> 00:13:17,600
objects

345
00:13:17,600 --> 00:13:19,839
they are they end up allocated at some

346
00:13:19,839 --> 00:13:21,200
predictable location

347
00:13:21,200 --> 00:13:23,120
and here in our tests spraying two

348
00:13:23,120 --> 00:13:24,959
megabyte is enough to predict some

349
00:13:24,959 --> 00:13:28,079
heap address however this require a

350
00:13:28,079 --> 00:13:29,920
prior knowledge on the memory mapping

351
00:13:29,920 --> 00:13:33,360
and this work

352
00:13:33,360 --> 00:13:35,279
that's what we have on firmware uh on

353
00:13:35,279 --> 00:13:37,200
firmware six thanks to the bad voice

354
00:13:37,200 --> 00:13:38,560
exploit

355
00:13:38,560 --> 00:13:41,279
and this may work on version seven we

356
00:13:41,279 --> 00:13:42,000
will discuss

357
00:13:42,000 --> 00:13:45,120
this late okay

358
00:13:45,120 --> 00:13:48,560
now how we can survive to uh

359
00:13:48,560 --> 00:13:51,760
to to an early crash the first step is

360
00:13:51,760 --> 00:13:55,040
to spray a couple of html elements

361
00:13:55,040 --> 00:13:57,519
uh and by doing that they end up

362
00:13:57,519 --> 00:14:00,160
allocated at some predictable location

363
00:14:00,160 --> 00:14:01,680
then we shape the heap so that we can

364
00:14:01,680 --> 00:14:03,279
reuse our target object

365
00:14:03,279 --> 00:14:06,079
and fix the m bubble and m element value

366
00:14:06,079 --> 00:14:07,920
so that they point to the address that

367
00:14:07,920 --> 00:14:09,279
we predicted

368
00:14:09,279 --> 00:14:13,120
so this way we can we can survive to

369
00:14:13,120 --> 00:14:16,800
to to the early crash now if we survive

370
00:14:16,800 --> 00:14:19,040
to that crash

371
00:14:19,040 --> 00:14:20,639
we end up by calling this function

372
00:14:20,639 --> 00:14:22,639
delayed level 3 after some time or

373
00:14:22,639 --> 00:14:23,760
expiration

374
00:14:23,760 --> 00:14:27,040
and this function will set

375
00:14:27,040 --> 00:14:29,199
to null pointer most of the fields of

376
00:14:29,199 --> 00:14:30,800
the valley most of the validation

377
00:14:30,800 --> 00:14:32,320
message fields

378
00:14:32,320 --> 00:14:34,959
and the new pointer assignment on drift

379
00:14:34,959 --> 00:14:35,839
counted classes

380
00:14:35,839 --> 00:14:39,199
is is overloaded and

381
00:14:39,199 --> 00:14:42,560
results in in a rifcount decrement

382
00:14:42,560 --> 00:14:45,199
this means that if we can uh if we

383
00:14:45,199 --> 00:14:47,199
manage to reuse our target object

384
00:14:47,199 --> 00:14:48,240
properly

385
00:14:48,240 --> 00:14:51,680
we end up by we can we we have

386
00:14:51,680 --> 00:14:54,560
uh a rifcount decrement on multiple

387
00:14:54,560 --> 00:14:55,680
controlled

388
00:14:55,680 --> 00:14:57,680
validation message fields which means

389
00:14:57,680 --> 00:14:59,360
that we can turn

390
00:14:59,360 --> 00:15:02,720
our initial use after free into an

391
00:15:02,720 --> 00:15:04,399
arbitrary decrement and this is

392
00:15:04,399 --> 00:15:06,000
exploitable

393
00:15:06,000 --> 00:15:09,440
now the exploit requires

394
00:15:09,440 --> 00:15:11,440
multiple heap shaping and spraying

395
00:15:11,440 --> 00:15:14,480
stages and in order to be able to reuse

396
00:15:14,480 --> 00:15:16,560
our target object we need to know how

397
00:15:16,560 --> 00:15:19,599
fast malloc works

398
00:15:20,720 --> 00:15:22,399
now that we know which primitive device

399
00:15:22,399 --> 00:15:24,959
gave us we must find a way to reuse the

400
00:15:24,959 --> 00:15:27,199
validation research object

401
00:15:27,199 --> 00:15:29,120
this part talk about the first product

402
00:15:29,120 --> 00:15:30,240
allocator

403
00:15:30,240 --> 00:15:32,320
that is the one used to allocate a

404
00:15:32,320 --> 00:15:33,600
validation research

405
00:15:33,600 --> 00:15:38,160
object webkit as many allocator

406
00:15:38,160 --> 00:15:41,199
first monarch is the standard allocator

407
00:15:41,199 --> 00:15:44,320
it is used by many webkit components

408
00:15:44,320 --> 00:15:47,519
easily is used by determining its

409
00:15:47,519 --> 00:15:48,720
purpose is to sort

410
00:15:48,720 --> 00:15:51,440
each allocation using their types to

411
00:15:51,440 --> 00:15:52,000
allocate

412
00:15:52,000 --> 00:15:53,440
to mitigate the use autophagy

413
00:15:53,440 --> 00:15:55,600
vulnerability

414
00:15:55,600 --> 00:15:58,800
the garbage collector is used by the

415
00:15:58,800 --> 00:16:00,560
javascript engine to locate

416
00:16:00,560 --> 00:16:03,839
javascript object isosoft space is also

417
00:16:03,839 --> 00:16:04,880
used

418
00:16:04,880 --> 00:16:08,000
by the javascript engine it is very

419
00:16:08,000 --> 00:16:09,040
similar to

420
00:16:09,040 --> 00:16:13,680
easily but it is used for a few objects

421
00:16:13,680 --> 00:16:17,040
and the gkh is used to prevent outbound

422
00:16:17,040 --> 00:16:17,920
read and write

423
00:16:17,920 --> 00:16:21,120
and specific object for example

424
00:16:21,120 --> 00:16:24,880
the backing buffer of the arrow buffer

425
00:16:24,880 --> 00:16:27,920
used this this allocator but

426
00:16:27,920 --> 00:16:31,040
when the gauge is disabled

427
00:16:31,040 --> 00:16:35,519
the allocated object uses first molecule

428
00:16:35,519 --> 00:16:38,800
and this garch is disabled on heavy

429
00:16:38,800 --> 00:16:41,920
ps4 systems

430
00:16:42,160 --> 00:16:45,759
webkit has four important structure

431
00:16:45,759 --> 00:16:48,720
the top one is the ipad it is made of

432
00:16:48,720 --> 00:16:49,680
chunks

433
00:16:49,680 --> 00:16:53,040
chunks is split into pages a page

434
00:16:53,040 --> 00:16:55,759
has a size of 4 kilobyte and it is

435
00:16:55,759 --> 00:16:57,920
divided into lines

436
00:16:57,920 --> 00:17:00,320
and the line is the most important

437
00:17:00,320 --> 00:17:00,959
object

438
00:17:00,959 --> 00:17:03,680
for us because it is the one that all

439
00:17:03,680 --> 00:17:06,000
the objects

440
00:17:06,000 --> 00:17:09,119
an important point is that

441
00:17:09,119 --> 00:17:13,119
lines are sorted into a page

442
00:17:13,119 --> 00:17:17,039
using the object size so this means

443
00:17:17,039 --> 00:17:20,400
that um we cannot have

444
00:17:20,400 --> 00:17:23,520
two objects that have a different size

445
00:17:23,520 --> 00:17:27,039
into the same line and this means that

446
00:17:27,039 --> 00:17:30,080
if we want to use our validation message

447
00:17:30,080 --> 00:17:34,400
object we must use an object that has

448
00:17:34,400 --> 00:17:36,960
the difference the that has the same

449
00:17:36,960 --> 00:17:40,480
size and validation message

450
00:17:40,960 --> 00:17:43,360
first malloc is a very is a very basic

451
00:17:43,360 --> 00:17:44,880
bumper locator

452
00:17:44,880 --> 00:17:48,080
it has a fast pass and a slow pass the

453
00:17:48,080 --> 00:17:48,799
fastpass

454
00:17:48,799 --> 00:17:52,720
just uses a bump to

455
00:17:52,720 --> 00:17:55,760
store each object and when an allocation

456
00:17:55,760 --> 00:17:57,280
request is made

457
00:17:57,280 --> 00:18:00,960
it just pop an object from developer

458
00:18:00,960 --> 00:18:04,080
but when the bump is empty then first

459
00:18:04,080 --> 00:18:04,640
parallel

460
00:18:04,640 --> 00:18:08,080
uses the slow pass this low pass is a

461
00:18:08,080 --> 00:18:11,360
bit more complex than the first person

462
00:18:11,360 --> 00:18:14,720
its goal is to refill the allocator

463
00:18:14,720 --> 00:18:18,960
to do so it will use several methods

464
00:18:18,960 --> 00:18:22,000
for example it will this low pass will

465
00:18:22,000 --> 00:18:22,400
look

466
00:18:22,400 --> 00:18:26,320
in many caches if there are objects

467
00:18:26,320 --> 00:18:26,960
available

468
00:18:26,960 --> 00:18:30,320
to refill the allocator and if

469
00:18:30,320 --> 00:18:33,120
this cache are empty then fast manner

470
00:18:33,120 --> 00:18:34,000
can

471
00:18:34,000 --> 00:18:38,559
will look on specific in specific pages

472
00:18:38,559 --> 00:18:41,600
if some lines are released and if they

473
00:18:41,600 --> 00:18:42,080
are

474
00:18:42,080 --> 00:18:43,919
first moloch will use this line to

475
00:18:43,919 --> 00:18:46,160
refill the allocator

476
00:18:46,160 --> 00:18:49,280
at the end of this pass first molokai

477
00:18:49,280 --> 00:18:53,600
has a full bomb elevator

478
00:18:53,600 --> 00:18:57,200
a full

479
00:18:57,200 --> 00:18:59,840
when an object is released it is pushed

480
00:18:59,840 --> 00:19:00,240
in

481
00:19:00,240 --> 00:19:03,440
a dedicated vector that is named m

482
00:19:03,440 --> 00:19:06,720
and square object log this vector

483
00:19:06,720 --> 00:19:10,000
is not made immediately available

484
00:19:10,000 --> 00:19:12,880
because it is processed only when it's

485
00:19:12,880 --> 00:19:14,000
when it reaches

486
00:19:14,000 --> 00:19:17,039
its maximum capacity

487
00:19:17,039 --> 00:19:21,120
chunks pages and lines are recounted

488
00:19:21,120 --> 00:19:23,919
this means that they are released only

489
00:19:23,919 --> 00:19:24,559
when

490
00:19:24,559 --> 00:19:27,760
uh their account is equal to zero

491
00:19:27,760 --> 00:19:30,880
so a very important point is that if we

492
00:19:30,880 --> 00:19:32,720
want to reuse our

493
00:19:32,720 --> 00:19:36,400
validation message object it must be

494
00:19:36,400 --> 00:19:39,520
on a line where each objects are

495
00:19:39,520 --> 00:19:40,160
released

496
00:19:40,160 --> 00:19:45,679
otherwise the line won't be reduced

497
00:19:46,160 --> 00:19:49,140
we can now start the exploitation part

498
00:19:49,140 --> 00:19:51,200
[Music]

499
00:19:51,200 --> 00:19:55,280
as uh using the previous information

500
00:19:55,280 --> 00:19:58,480
we know that we must control the full

501
00:19:58,480 --> 00:19:59,280
line

502
00:19:59,280 --> 00:20:03,360
where validation message is allocated

503
00:20:03,360 --> 00:20:07,280
in order to reuse it to do so

504
00:20:07,280 --> 00:20:10,559
we will we will allocate object that has

505
00:20:10,559 --> 00:20:12,720
the same size than validation message

506
00:20:12,720 --> 00:20:15,520
around data

507
00:20:15,840 --> 00:20:18,080
before we will allocate them before and

508
00:20:18,080 --> 00:20:19,200
after allocating

509
00:20:19,200 --> 00:20:22,159
a validation message we will end up with

510
00:20:22,159 --> 00:20:25,919
the following year memory layout

511
00:20:25,919 --> 00:20:29,360
then we can we can release that the

512
00:20:29,360 --> 00:20:30,240
object

513
00:20:30,240 --> 00:20:33,120
that allocated before and after

514
00:20:33,120 --> 00:20:34,640
obligation message

515
00:20:34,640 --> 00:20:37,679
and the validation message itself this

516
00:20:37,679 --> 00:20:38,320
will

517
00:20:38,320 --> 00:20:41,120
release the associated line and cached

518
00:20:41,120 --> 00:20:43,600
the page

519
00:20:44,240 --> 00:20:47,760
at the end we can now spray definer

520
00:20:47,760 --> 00:20:48,960
object that will

521
00:20:48,960 --> 00:20:53,039
reuse a validation message

522
00:20:53,280 --> 00:20:56,400
we chose to use the debugging buffer of

523
00:20:56,400 --> 00:20:57,919
the ibfr

524
00:20:57,919 --> 00:21:01,200
widely subjected because first

525
00:21:01,200 --> 00:21:04,480
it allowed to to do an allocation

526
00:21:04,480 --> 00:21:07,600
using an arbitrary size and

527
00:21:07,600 --> 00:21:10,960
we can read and write every byte of

528
00:21:10,960 --> 00:21:14,320
these objects at the end

529
00:21:14,320 --> 00:21:16,799
we have two references that point to the

530
00:21:16,799 --> 00:21:17,840
same memory

531
00:21:17,840 --> 00:21:21,360
area the first one is the validation

532
00:21:21,360 --> 00:21:22,559
message one

533
00:21:22,559 --> 00:21:24,880
and the second one is the error buffer

534
00:21:24,880 --> 00:21:26,110
contents

535
00:21:26,110 --> 00:21:27,840
[Music]

536
00:21:27,840 --> 00:21:31,120
as medici said previously a free field

537
00:21:31,120 --> 00:21:33,919
of validation message are allocated

538
00:21:33,919 --> 00:21:34,720
after

539
00:21:34,720 --> 00:21:37,840
using the object so using our

540
00:21:37,840 --> 00:21:40,640
buffer we can read their value and get

541
00:21:40,640 --> 00:21:41,440
an initial

542
00:21:41,440 --> 00:21:45,200
memory look two of these fields

543
00:21:45,200 --> 00:21:48,159
are allocated using our pointer

544
00:21:48,159 --> 00:21:49,039
allocated

545
00:21:49,039 --> 00:21:52,400
using either eep but they are not

546
00:21:52,400 --> 00:21:54,320
important for us

547
00:21:54,320 --> 00:21:57,520
but the third one the timer one

548
00:21:57,520 --> 00:22:00,320
is allocated is a pointer located using

549
00:22:00,320 --> 00:22:01,360
fast molecule

550
00:22:01,360 --> 00:22:04,640
and this one is interesting and we will

551
00:22:04,640 --> 00:22:08,000
reuse it later to guess the address of

552
00:22:08,000 --> 00:22:11,039
first monocult

553
00:22:11,440 --> 00:22:13,360
we can now trigger the arbitrary

554
00:22:13,360 --> 00:22:14,640
recommend primitive

555
00:22:14,640 --> 00:22:18,240
we can do it usually using our arbitrary

556
00:22:18,240 --> 00:22:22,240
our buffer reference by just

557
00:22:22,240 --> 00:22:26,799
writing into uh into the backing buffer

558
00:22:26,799 --> 00:22:29,360
for example we can corrupt the pointer

559
00:22:29,360 --> 00:22:30,000
of

560
00:22:30,000 --> 00:22:33,039
ammon oscar message heading and

561
00:22:33,039 --> 00:22:36,879
when this printer will be released

562
00:22:36,960 --> 00:22:41,679
the the ref count

563
00:22:41,679 --> 00:22:43,679
derive count at this point will be a

564
00:22:43,679 --> 00:22:45,760
decrement

565
00:22:45,760 --> 00:22:48,880
to our strategy to exploit this

566
00:22:48,880 --> 00:22:52,320
primitive is to decrement

567
00:22:52,320 --> 00:22:56,080
a length in memory in order to enlarge

568
00:22:56,080 --> 00:22:59,200
a data buffer and

569
00:22:59,200 --> 00:23:01,919
get a better primitive like relative

570
00:23:01,919 --> 00:23:04,559
read and write

571
00:23:05,840 --> 00:23:10,400
to summarize our exploit strategy

572
00:23:10,400 --> 00:23:12,960
we will first we will figure one first

573
00:23:12,960 --> 00:23:13,760
time

574
00:23:13,760 --> 00:23:16,880
the vulnerability and

575
00:23:16,880 --> 00:23:19,840
use the arbitrary decrement to get a

576
00:23:19,840 --> 00:23:20,480
first

577
00:23:20,480 --> 00:23:23,200
relatively primitive we will use this

578
00:23:23,200 --> 00:23:24,159
primitive

579
00:23:24,159 --> 00:23:27,120
to find the address of better objects in

580
00:23:27,120 --> 00:23:28,159
memory

581
00:23:28,159 --> 00:23:31,039
then we can use one more time our

582
00:23:31,039 --> 00:23:32,640
vulnerability and the arbitrary

583
00:23:32,640 --> 00:23:33,840
decrement

584
00:23:33,840 --> 00:23:36,960
to get a better alternative distinctive

585
00:23:36,960 --> 00:23:39,520
is the relatively inviter

586
00:23:39,520 --> 00:23:42,720
and with relatively right

587
00:23:42,720 --> 00:23:45,520
we can achieve arbitrary read and write

588
00:23:45,520 --> 00:23:50,880
and get code execution

589
00:23:50,880 --> 00:23:54,080
the goal of the relatively primitive

590
00:23:54,080 --> 00:23:57,039
is to leak the address of jesus are

591
00:23:57,039 --> 00:23:58,640
before you

592
00:23:58,640 --> 00:24:01,760
yesterday for you is an interesting

593
00:24:01,760 --> 00:24:02,840
object

594
00:24:02,840 --> 00:24:06,320
because first it has a landfill field

595
00:24:06,320 --> 00:24:09,200
and it allows to read and write

596
00:24:09,200 --> 00:24:10,960
arbitrary data

597
00:24:10,960 --> 00:24:14,080
so if we can

598
00:24:14,400 --> 00:24:17,120
if we can overwrite the length of field

599
00:24:17,120 --> 00:24:17,600
then

600
00:24:17,600 --> 00:24:21,679
we can then write arbitrary data

601
00:24:21,679 --> 00:24:26,799
beyond the limit of the data buffer

602
00:24:26,799 --> 00:24:29,279
to get the relative read primitive we

603
00:24:29,279 --> 00:24:29,840
will use

604
00:24:29,840 --> 00:24:32,480
another object that is named string

605
00:24:32,480 --> 00:24:33,679
importer

606
00:24:33,679 --> 00:24:36,159
string import is the string

607
00:24:36,159 --> 00:24:37,679
representation

608
00:24:37,679 --> 00:24:40,559
is the representation of the string in

609
00:24:40,559 --> 00:24:42,240
javascript

610
00:24:42,240 --> 00:24:45,360
in just script string are

611
00:24:45,360 --> 00:24:48,640
immutable this means that we can

612
00:24:48,640 --> 00:24:51,919
read in the data buffer

613
00:24:51,919 --> 00:24:56,640
but we cannot write we cannot write data

614
00:24:56,640 --> 00:24:59,120
and also string poly is interesting

615
00:24:59,120 --> 00:25:00,480
because it has a length

616
00:25:00,480 --> 00:25:03,600
filled and it is a fast melody

617
00:25:03,600 --> 00:25:06,720
so we can usually find it using

618
00:25:06,720 --> 00:25:10,080
our timer leak so

619
00:25:10,080 --> 00:25:12,640
to override the length we will spray

620
00:25:12,640 --> 00:25:13,679
string impul

621
00:25:13,679 --> 00:25:17,200
that are the same size than our timer

622
00:25:17,200 --> 00:25:19,440
leak

623
00:25:19,919 --> 00:25:22,640
we will spray them around the timer

624
00:25:22,640 --> 00:25:23,679
object

625
00:25:23,679 --> 00:25:26,320
using our arbitrary decrement we will

626
00:25:26,320 --> 00:25:26,960
overwrite

627
00:25:26,960 --> 00:25:30,240
the length of the field and

628
00:25:30,240 --> 00:25:34,000
thanks to that we can read beyond

629
00:25:34,000 --> 00:25:38,080
the limit of the string buffer

630
00:25:39,760 --> 00:25:43,039
how to leak here's a viewpoint

631
00:25:43,039 --> 00:25:46,640
it is important to know that dom objects

632
00:25:46,640 --> 00:25:49,760
and js objects use two different

633
00:25:49,760 --> 00:25:53,840
locators so we cannot access

634
00:25:53,840 --> 00:25:57,200
to to djs subjects using our relative

635
00:25:57,200 --> 00:25:59,200
read in first molecule

636
00:25:59,200 --> 00:26:02,000
but a javascript ability in that is

637
00:26:02,000 --> 00:26:02,919
named

638
00:26:02,919 --> 00:26:05,840
object.define properties allow

639
00:26:05,840 --> 00:26:09,679
to allocate two objects a vector

640
00:26:09,679 --> 00:26:13,039
and a marked argument before

641
00:26:13,039 --> 00:26:15,679
both objects are allocated on first one

642
00:26:15,679 --> 00:26:16,480
okay and

643
00:26:16,480 --> 00:26:19,760
they allow to push javascript

644
00:26:19,760 --> 00:26:25,840
object reference on the first molecule

645
00:26:26,159 --> 00:26:28,960
so using our relative reader we can

646
00:26:28,960 --> 00:26:30,000
usually

647
00:26:30,000 --> 00:26:32,400
find this pointer to do that we will

648
00:26:32,400 --> 00:26:34,000
allocate a multiple

649
00:26:34,000 --> 00:26:37,039
yes array before you

650
00:26:37,039 --> 00:26:40,000
yes review then we will purchase the

651
00:26:40,000 --> 00:26:40,720
reference

652
00:26:40,720 --> 00:26:44,000
on first molecule if using object.define

653
00:26:44,000 --> 00:26:45,200
properties

654
00:26:45,200 --> 00:26:47,840
and then we can scan the ip using our

655
00:26:47,840 --> 00:26:49,120
relative grid

656
00:26:49,120 --> 00:26:53,840
and find this printer

657
00:26:54,320 --> 00:26:57,600
to summarize we have an arbitrary

658
00:26:57,600 --> 00:27:01,120
command and we have a gsi buffer view

659
00:27:01,120 --> 00:27:01,760
leak

660
00:27:01,760 --> 00:27:05,200
we can now get a relative read android

661
00:27:05,200 --> 00:27:06,400
printer

662
00:27:06,400 --> 00:27:08,960
we will just run the exploit again use

663
00:27:08,960 --> 00:27:10,320
the arbitrary decrement

664
00:27:10,320 --> 00:27:13,760
on the leaked gsi buffer view rs

665
00:27:13,760 --> 00:27:16,960
enlarge the length of the field of the

666
00:27:16,960 --> 00:27:20,159
gsi buffer view and this allows

667
00:27:20,159 --> 00:27:23,679
us to read and write beyond the limit of

668
00:27:23,679 --> 00:27:26,559
the data buffer

669
00:27:29,039 --> 00:27:33,520
so now using a relatively light

670
00:27:33,520 --> 00:27:36,159
we can achieve arbitrary read and write

671
00:27:36,159 --> 00:27:37,440
we will use

672
00:27:37,440 --> 00:27:40,880
another gsr buffer view

673
00:27:40,880 --> 00:27:44,399
gsr buffer view has a vector field

674
00:27:44,399 --> 00:27:47,360
that represents a data buffer where we

675
00:27:47,360 --> 00:27:48,159
can

676
00:27:48,159 --> 00:27:51,120
read and write so using our arbit our

677
00:27:51,120 --> 00:27:52,799
relative read and write

678
00:27:52,799 --> 00:27:55,890
we will just overwrite the

679
00:27:55,890 --> 00:27:57,120
[Music]

680
00:27:57,120 --> 00:28:00,240
the the pointer rd vector

681
00:28:00,240 --> 00:28:03,360
and using this we can

682
00:28:03,360 --> 00:28:06,880
read and write at arbitrary

683
00:28:06,880 --> 00:28:09,919
arbitrary address

684
00:28:11,360 --> 00:28:15,840
and on ps4 we cannot allocate rwx memory

685
00:28:15,840 --> 00:28:17,200
pages

686
00:28:17,200 --> 00:28:19,760
but we can control the instruction

687
00:28:19,760 --> 00:28:21,360
pointer

688
00:28:21,360 --> 00:28:24,720
for example we can just leak an html

689
00:28:24,720 --> 00:28:25,760
element

690
00:28:25,760 --> 00:28:29,360
object override its available pointer

691
00:28:29,360 --> 00:28:32,559
and call the associated dgs method

692
00:28:32,559 --> 00:28:34,159
that will trigger the other return

693
00:28:34,159 --> 00:28:36,080
pointer

694
00:28:36,080 --> 00:28:38,640
and then we can implement the next

695
00:28:38,640 --> 00:28:39,440
stages

696
00:28:39,440 --> 00:28:42,559
using color user most of

697
00:28:42,559 --> 00:28:45,039
the previous ps4 jabra i can use this

698
00:28:45,039 --> 00:28:45,750
method

699
00:28:45,750 --> 00:28:47,039
[Music]

700
00:28:47,039 --> 00:28:59,840
so this is time for a demo

701
00:29:06,720 --> 00:29:11,279
so the exploit took about 11 seconds

702
00:29:11,279 --> 00:29:15,520
to reach arbitrary read and write

703
00:29:22,240 --> 00:29:25,120
and at this moment we reach arbitrarily

704
00:29:25,120 --> 00:29:27,440
read and write and we can start

705
00:29:27,440 --> 00:29:32,080
to implement the next stages

706
00:29:37,279 --> 00:29:40,559
so to conclude the exploit works

707
00:29:40,559 --> 00:29:43,840
on version of version

708
00:29:43,840 --> 00:29:47,360
6 of place for firmware

709
00:29:47,360 --> 00:29:49,760
the exploit code is available on this

710
00:29:49,760 --> 00:29:51,919
inactive github

711
00:29:51,919 --> 00:29:54,640
the exploit is not really stable and it

712
00:29:54,640 --> 00:29:55,039
took

713
00:29:55,039 --> 00:29:57,919
about 11 seconds to reach arbitrary

714
00:29:57,919 --> 00:29:59,039
device

715
00:29:59,039 --> 00:30:02,240
but the reliability could be improved by

716
00:30:02,240 --> 00:30:03,360
for example

717
00:30:03,360 --> 00:30:06,480
improving the asl brute force

718
00:30:06,480 --> 00:30:09,520
step and we can also find a bit

719
00:30:09,520 --> 00:30:12,399
a better exploitation path that avoid

720
00:30:12,399 --> 00:30:16,080
triggering two times the vulnerability

721
00:30:16,080 --> 00:30:19,279
we tried uh parting this

722
00:30:19,279 --> 00:30:23,200
exploit on version 7 of the ps4

723
00:30:23,200 --> 00:30:25,760
firmwares but we did not succeed

724
00:30:25,760 --> 00:30:29,440
the asl bypass did not work

725
00:30:29,440 --> 00:30:34,000
on this firmware version

726
00:30:34,000 --> 00:30:37,840
and we only get questions but we tried

727
00:30:37,840 --> 00:30:41,679
to to breakfast the asl

728
00:30:41,679 --> 00:30:44,640
using a raspberry pi the goal was to

729
00:30:44,640 --> 00:30:45,600
guess the address

730
00:30:45,600 --> 00:30:49,360
of a spread html element and

731
00:30:49,360 --> 00:30:52,320
the raspberry p was used to emulate to

732
00:30:52,320 --> 00:30:53,840
emulate a keyboard

733
00:30:53,840 --> 00:30:57,360
and we load the page every five seconds

734
00:30:57,360 --> 00:30:59,840
after a crash but we did not get any

735
00:30:59,840 --> 00:31:01,650
results so far

736
00:31:01,650 --> 00:31:02,720
[Music]

737
00:31:02,720 --> 00:31:05,519
thanks to senective for letting us do

738
00:31:05,519 --> 00:31:06,399
the research

739
00:31:06,399 --> 00:31:08,799
thanks to our colleague for all the help

740
00:31:08,799 --> 00:31:10,559
while developing the exploit

741
00:31:10,559 --> 00:31:13,360
thanks to black hat for the great event

742
00:31:13,360 --> 00:31:15,679
and thank you for your attention

743
00:31:15,679 --> 00:31:19,840
do you have any questions

