1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:15,679 --> 00:00:17,039
good morning everyone

3
00:00:17,039 --> 00:00:20,880
i'm gonna have kim and i really delight

4
00:00:20,880 --> 00:00:24,560
to have this presentation to talk about

5
00:00:24,560 --> 00:00:27,920
a new hope there are one last chance to

6
00:00:27,920 --> 00:00:31,840
save your ssd data

7
00:00:33,680 --> 00:00:36,320
we are mainly engaged in business

8
00:00:36,320 --> 00:00:37,120
related

9
00:00:37,120 --> 00:00:41,200
to embedded devices we analyze

10
00:00:41,200 --> 00:00:45,280
the security grid of embedded device

11
00:00:45,280 --> 00:00:48,320
reports unknown vulnerabilities and

12
00:00:48,320 --> 00:00:50,719
support count measure

13
00:00:50,719 --> 00:00:53,520
in particular we focus on reverse

14
00:00:53,520 --> 00:00:55,840
engineering and side channel analysis

15
00:00:55,840 --> 00:00:56,559
for

16
00:00:56,559 --> 00:00:59,760
embedded device recently we

17
00:00:59,760 --> 00:01:02,960
are also doing business related to

18
00:01:02,960 --> 00:01:06,320
intellectual property rights using

19
00:01:06,320 --> 00:01:09,520
labour's engineering

20
00:01:10,000 --> 00:01:13,280
today we will explain the result of

21
00:01:13,280 --> 00:01:16,000
conducting research to find out the

22
00:01:16,000 --> 00:01:17,119
truths

23
00:01:17,119 --> 00:01:21,840
for the ssd data recovery

24
00:01:23,200 --> 00:01:25,680
there are several design limitations to

25
00:01:25,680 --> 00:01:26,799
the way

26
00:01:26,799 --> 00:01:30,079
ssd derives a computer

27
00:01:30,079 --> 00:01:34,159
existing types of pledge memory allows

28
00:01:34,159 --> 00:01:37,439
a limited number of rights of

29
00:01:37,439 --> 00:01:38,320
preparation

30
00:01:38,320 --> 00:01:41,600
people they wear out rather than

31
00:01:41,600 --> 00:01:44,960
reusing existing blocks

32
00:01:44,960 --> 00:01:48,640
of memory modern ssd drivers use

33
00:01:48,640 --> 00:01:51,920
smart wear leveling technology that

34
00:01:51,920 --> 00:01:54,960
writes data stored

35
00:01:54,960 --> 00:01:58,320
in one block to another when

36
00:01:58,320 --> 00:02:02,320
it is modified then block containing

37
00:02:02,320 --> 00:02:05,280
potentially sensitive information are

38
00:02:05,280 --> 00:02:06,399
scattered

39
00:02:06,399 --> 00:02:10,000
throughout the memory chips

40
00:02:10,000 --> 00:02:13,680
the further increase the usable life

41
00:02:13,680 --> 00:02:17,040
and improve the availability of ssd

42
00:02:17,040 --> 00:02:17,840
drives

43
00:02:17,840 --> 00:02:21,280
manufacturer installed flash chip take

44
00:02:21,280 --> 00:02:24,319
that can store up to

45
00:02:24,319 --> 00:02:27,599
25 percent more data than

46
00:02:27,599 --> 00:02:30,720
their capacity area this

47
00:02:30,720 --> 00:02:34,319
extra capacity cannot be handled

48
00:02:34,319 --> 00:02:37,360
through the operating system or

49
00:02:37,360 --> 00:02:40,400
any other reasonable means

50
00:02:40,400 --> 00:02:43,760
because of this data on

51
00:02:43,760 --> 00:02:47,280
ssd drives cannot be safely

52
00:02:47,280 --> 00:02:50,400
erased through conventional means

53
00:02:50,400 --> 00:02:53,519
as required by some government

54
00:02:53,519 --> 00:02:56,560
and military standards

55
00:02:56,560 --> 00:02:59,920
to solve this problem some

56
00:02:59,920 --> 00:03:03,280
ssd manufacturers have implemented

57
00:03:03,280 --> 00:03:06,640
the extension to the ata

58
00:03:06,640 --> 00:03:10,720
ansi specification to safely

59
00:03:10,720 --> 00:03:13,920
destroy the information stored on all

60
00:03:13,920 --> 00:03:17,040
flash chips unlike

61
00:03:17,040 --> 00:03:20,400
software based tools the ata secure

62
00:03:20,400 --> 00:03:21,599
erase command

63
00:03:21,599 --> 00:03:24,959
instruct the built-in ssd controller

64
00:03:24,959 --> 00:03:28,920
that support the command to

65
00:03:28,920 --> 00:03:33,280
electronically erase all about all blood

66
00:03:33,280 --> 00:03:37,040
on our press chip in the drive

67
00:03:37,040 --> 00:03:40,400
however it is difficult for us

68
00:03:40,400 --> 00:03:44,840
to grasp the truth about the internal

69
00:03:44,840 --> 00:03:50,000
working of ssd from outside

70
00:03:50,400 --> 00:03:54,000
it is frustrating and forensics

71
00:03:54,000 --> 00:03:56,879
that raise the information cannot be

72
00:03:56,879 --> 00:03:57,360
really

73
00:03:57,360 --> 00:04:00,720
reliably recovered

74
00:04:00,720 --> 00:04:04,080
with we are available at the beginning

75
00:04:04,080 --> 00:04:07,840
of each write operation a previously

76
00:04:07,840 --> 00:04:10,799
unused block of data

77
00:04:10,799 --> 00:04:14,400
is used to make extensive use

78
00:04:14,400 --> 00:04:17,519
of the drive storage capacity

79
00:04:17,519 --> 00:04:21,440
repeatedly writing to the same field

80
00:04:21,440 --> 00:04:25,040
will cause the entire contents of the

81
00:04:25,040 --> 00:04:28,240
ssd drive to become turkey

82
00:04:28,240 --> 00:04:32,160
and the right speed will be

83
00:04:32,160 --> 00:04:35,520
much slower than usual resulting in

84
00:04:35,520 --> 00:04:40,560
significant performance degradation

85
00:04:40,560 --> 00:04:43,520
this happens because the fleshy

86
00:04:43,520 --> 00:04:44,800
technology

87
00:04:44,800 --> 00:04:48,479
technology used used in

88
00:04:48,479 --> 00:04:52,560
ssd drive requires that controller it is

89
00:04:52,560 --> 00:04:53,919
blocked

90
00:04:53,919 --> 00:04:57,919
before for pointing a write operation

91
00:04:57,919 --> 00:05:01,120
this property is unique to storage

92
00:05:01,120 --> 00:05:02,800
device based on

93
00:05:02,800 --> 00:05:06,880
fresh technology and is very different

94
00:05:06,880 --> 00:05:10,560
from how traditional magnetic tangible

95
00:05:10,560 --> 00:05:11,520
meteor

96
00:05:11,520 --> 00:05:14,639
handles right requested

97
00:05:14,639 --> 00:05:17,680
since the process the erasing

98
00:05:17,680 --> 00:05:20,720
previously occupied block tend

99
00:05:20,720 --> 00:05:24,160
to be much slow compared

100
00:05:24,160 --> 00:05:28,400
to race and rise

101
00:05:28,479 --> 00:05:32,479
ssd driver full of

102
00:05:32,479 --> 00:05:36,000
dirty block record requires significant

103
00:05:36,000 --> 00:05:37,199
time to

104
00:05:37,199 --> 00:05:40,400
write even a single block

105
00:05:40,400 --> 00:05:43,520
of data because there are

106
00:05:43,520 --> 00:05:47,919
no empty blocks because of this

107
00:05:47,919 --> 00:05:51,440
ssd manufacturer design process that

108
00:05:51,440 --> 00:05:54,800
does guppy's collection and clears dirty

109
00:05:54,800 --> 00:05:56,080
block

110
00:05:56,080 --> 00:05:59,840
in the background and make them

111
00:05:59,840 --> 00:06:06,400
available again for fast right operation

112
00:06:06,400 --> 00:06:08,960
the problem with the copies collection

113
00:06:08,960 --> 00:06:09,759
is that

114
00:06:09,759 --> 00:06:13,680
the drive and controllers that don't

115
00:06:13,680 --> 00:06:17,199
know exactly what block

116
00:06:17,199 --> 00:06:20,639
perhaps the operating system fields or

117
00:06:20,639 --> 00:06:24,319
system structure actually occupied

118
00:06:24,319 --> 00:06:28,000
which block no longer

119
00:06:28,000 --> 00:06:31,919
being used and adjusted.t

120
00:06:31,919 --> 00:06:35,520
blocks the control can dis

121
00:06:35,520 --> 00:06:39,039
display blocks that have been

122
00:06:39,039 --> 00:06:43,280
remapped to other block as part of the

123
00:06:43,280 --> 00:06:46,639
wear labeling process but this

124
00:06:46,639 --> 00:06:51,440
information slow down the drive process

125
00:06:51,440 --> 00:06:54,639
which is usually filled with dirty

126
00:06:54,639 --> 00:06:55,919
blocks

127
00:06:55,919 --> 00:06:59,759
during normal use of the drive involved

128
00:06:59,759 --> 00:07:03,120
in creation to solve

129
00:07:03,120 --> 00:07:06,800
this problem ssd designers

130
00:07:06,800 --> 00:07:09,840
have developed an interface that

131
00:07:09,840 --> 00:07:12,960
allow oppressed operating system to

132
00:07:12,960 --> 00:07:16,160
inform the controller that

133
00:07:16,160 --> 00:07:19,919
certain block no longer being

134
00:07:19,919 --> 00:07:23,520
used through the trim command

135
00:07:23,520 --> 00:07:25,919
this allows the internal garbage

136
00:07:25,919 --> 00:07:26,880
collection

137
00:07:26,880 --> 00:07:30,400
to electronically raise the contents

138
00:07:30,400 --> 00:07:34,400
of the of this blog to prepare

139
00:07:34,400 --> 00:07:38,000
for future right block of data

140
00:07:38,000 --> 00:07:41,199
processed by the garbage collector

141
00:07:41,199 --> 00:07:45,280
physically erased it however

142
00:07:45,280 --> 00:07:48,400
this also cannot be verified outside of

143
00:07:48,400 --> 00:07:51,758
the ssd

144
00:07:53,440 --> 00:07:56,800
in fact there are not many ways

145
00:07:56,800 --> 00:08:00,879
to perform ssd forensics

146
00:08:00,879 --> 00:08:04,479
the information on the ssd controller

147
00:08:04,479 --> 00:08:08,000
and the internal libraries of the ssd

148
00:08:08,000 --> 00:08:11,440
are not disclosed and for

149
00:08:11,440 --> 00:08:15,120
this reason development development

150
00:08:15,120 --> 00:08:18,240
of ssd2 forensic tools

151
00:08:18,240 --> 00:08:22,639
is sufficient insufficient

152
00:08:22,879 --> 00:08:26,000
therefore we took the challenge for

153
00:08:26,000 --> 00:08:29,759
the ssd forensics first

154
00:08:29,759 --> 00:08:33,760
it is to build an environment that

155
00:08:33,760 --> 00:08:38,799
can analyze the latest commercial ssds

156
00:08:38,799 --> 00:08:41,919
this should enable dynamic as

157
00:08:41,919 --> 00:08:45,279
a as well as static analysis

158
00:08:45,279 --> 00:08:48,720
in the formula code

159
00:08:48,720 --> 00:08:52,080
through the analysis environment

160
00:08:52,080 --> 00:08:56,000
the dedicated algorithm for the process

161
00:08:56,000 --> 00:08:59,440
of writing reading and raising

162
00:08:59,440 --> 00:09:02,880
interval internal data by the

163
00:09:02,880 --> 00:09:06,800
ssd must be able to analyze

164
00:09:06,800 --> 00:09:10,000
based on this we collected

165
00:09:10,000 --> 00:09:13,279
the entire data of the ssd

166
00:09:13,279 --> 00:09:16,959
and identified the situational

167
00:09:16,959 --> 00:09:17,839
conditions

168
00:09:17,839 --> 00:09:22,000
for recovering data

169
00:09:22,000 --> 00:09:25,360
details assess the analysis process

170
00:09:25,360 --> 00:09:29,440
and contents explained by

171
00:09:29,440 --> 00:09:33,200
senior research sinjuli

172
00:09:34,640 --> 00:09:37,040
thank you now i'm going to start by

173
00:09:37,040 --> 00:09:39,519
showing access for my reversing

174
00:09:39,519 --> 00:09:42,000
hi i'm sun jun lee senior researcher of

175
00:09:42,000 --> 00:09:43,279
ascent works

176
00:09:43,279 --> 00:09:46,560
i'm very honored talk today i'm going to

177
00:09:46,560 --> 00:09:48,000
spread this talk about

178
00:09:48,000 --> 00:09:51,360
ss formal reversing into three sections

179
00:09:51,360 --> 00:09:53,120
first i'll explain background

180
00:09:53,120 --> 00:09:54,959
information shortly

181
00:09:54,959 --> 00:09:57,920
about ssd hardware architecture and

182
00:09:57,920 --> 00:09:59,839
security encoder

183
00:09:59,839 --> 00:10:02,480
second thing is asset format reversing

184
00:10:02,480 --> 00:10:04,160
focused on how to access

185
00:10:04,160 --> 00:10:07,200
your physical block data but also it

186
00:10:07,200 --> 00:10:07,600
gives

187
00:10:07,600 --> 00:10:09,519
prior knowledge which is needed to

188
00:10:09,519 --> 00:10:11,200
restore operating data on

189
00:10:11,200 --> 00:10:14,399
ssd finally i can show you

190
00:10:14,399 --> 00:10:16,880
how can recover the overwritten data if

191
00:10:16,880 --> 00:10:18,640
there is hardware-based ridiculous

192
00:10:18,640 --> 00:10:21,120
encoder

193
00:10:21,920 --> 00:10:24,480
before we get into that i'd like to

194
00:10:24,480 --> 00:10:25,120
explain

195
00:10:25,120 --> 00:10:28,399
why commercial access delivering is hard

196
00:10:28,399 --> 00:10:31,120
access manufacturers and their control

197
00:10:31,120 --> 00:10:32,560
manufacturers

198
00:10:32,560 --> 00:10:34,640
don't want to open their information to

199
00:10:34,640 --> 00:10:36,880
protect their technologies

200
00:10:36,880 --> 00:10:39,920
so data shed is marked confidential and

201
00:10:39,920 --> 00:10:41,760
usually only given out after

202
00:10:41,760 --> 00:10:45,040
nda is signed and also they might be

203
00:10:45,040 --> 00:10:47,680
concerned about misuse by bad guys

204
00:10:47,680 --> 00:10:51,279
and end users anyway they appear to

205
00:10:51,279 --> 00:10:53,519
protect the privacy of their users

206
00:10:53,519 --> 00:10:55,440
so they have the opposite side of

207
00:10:55,440 --> 00:11:00,160
reverse engineer

208
00:11:00,160 --> 00:11:01,920
let's look at the commercial access

209
00:11:01,920 --> 00:11:03,279
architecture

210
00:11:03,279 --> 00:11:06,000
the abscesses are equipped with several

211
00:11:06,000 --> 00:11:08,399
raw power embedded processors such as

212
00:11:08,399 --> 00:11:09,920
arm and arc

213
00:11:09,920 --> 00:11:12,000
generally mid-range access delay

214
00:11:12,000 --> 00:11:14,000
controller out of automatically

215
00:11:14,000 --> 00:11:17,600
architecture to maximize io parallelism

216
00:11:17,600 --> 00:11:20,560
so if they should support more channels

217
00:11:20,560 --> 00:11:22,480
control might be made of four cores

218
00:11:22,480 --> 00:11:23,600
ether

219
00:11:23,600 --> 00:11:25,519
are those single core base control

220
00:11:25,519 --> 00:11:27,600
contain or middleware only in a single

221
00:11:27,600 --> 00:11:28,560
core

222
00:11:28,560 --> 00:11:31,440
in vertical based control master core

223
00:11:31,440 --> 00:11:32,399
only work in

224
00:11:32,399 --> 00:11:35,440
host interface and slab core only work

225
00:11:35,440 --> 00:11:37,120
in fresh translation

226
00:11:37,120 --> 00:11:40,240
and fresh interface the master core

227
00:11:40,240 --> 00:11:42,800
and slap core each have their own data

228
00:11:42,800 --> 00:11:44,160
memory

229
00:11:44,160 --> 00:11:47,120
using the ipc the master core and the

230
00:11:47,120 --> 00:11:48,079
slave course

231
00:11:48,079 --> 00:11:50,240
can transfer data over shadow memory

232
00:11:50,240 --> 00:11:52,800
transport

233
00:11:54,639 --> 00:11:57,440
and also important part of this is the

234
00:11:57,440 --> 00:11:59,600
host interface logic

235
00:11:59,600 --> 00:12:02,480
which is integrated with secret encoder

236
00:12:02,480 --> 00:12:04,240
they usually use asx

237
00:12:04,240 --> 00:12:06,720
tests the full data inclusion on

238
00:12:06,720 --> 00:12:07,920
ancestors

239
00:12:07,920 --> 00:12:09,760
can eventually ensure the security of

240
00:12:09,760 --> 00:12:11,600
confidential data

241
00:12:11,600 --> 00:12:13,680
this achieves the goal of each block

242
00:12:13,680 --> 00:12:15,680
producing unique ciphertext

243
00:12:15,680 --> 00:12:18,480
given identical plane text as you can

244
00:12:18,480 --> 00:12:19,120
see

245
00:12:19,120 --> 00:12:22,079
the block inclusion key is altered per

246
00:12:22,079 --> 00:12:22,959
aba

247
00:12:22,959 --> 00:12:24,880
making the inclusion very difficult to

248
00:12:24,880 --> 00:12:27,200
break

249
00:12:30,160 --> 00:12:31,839
here is rough diagram about

250
00:12:31,839 --> 00:12:34,079
hardware-based security encoder

251
00:12:34,079 --> 00:12:37,360
let me show you guys this badge pattern

252
00:12:37,360 --> 00:12:40,399
when if we read the file from ssd

253
00:12:40,399 --> 00:12:42,480
but the access control can handle it

254
00:12:42,480 --> 00:12:44,639
only with the encrypted data

255
00:12:44,639 --> 00:12:46,880
until ssd control through the data into

256
00:12:46,880 --> 00:12:48,399
their host

257
00:12:48,399 --> 00:12:50,880
anyway it is not possible to observe the

258
00:12:50,880 --> 00:12:52,720
encryption process itself

259
00:12:52,720 --> 00:12:54,320
meaning the user cannot see that

260
00:12:54,320 --> 00:12:56,160
encrypted data as our

261
00:12:56,160 --> 00:12:58,480
data that is read will already have been

262
00:12:58,480 --> 00:12:59,680
decreated

263
00:12:59,680 --> 00:13:04,160
because it is built in hardware engine

264
00:13:04,880 --> 00:13:07,279
but there are still entry type control

265
00:13:07,279 --> 00:13:09,200
have no crypto engine

266
00:13:09,200 --> 00:13:12,160
and the low cost assets manufacturers

267
00:13:12,160 --> 00:13:13,760
will see generally

268
00:13:13,760 --> 00:13:16,880
they have a release the assets until now

269
00:13:16,880 --> 00:13:19,200
tend to put this controller for economic

270
00:13:19,200 --> 00:13:20,560
regions

271
00:13:20,560 --> 00:13:23,920
but the most of meter and assets support

272
00:13:23,920 --> 00:13:26,560
how they are built in crypto engine

273
00:13:26,560 --> 00:13:28,560
so the manufacturer tops the

274
00:13:28,560 --> 00:13:30,880
controller's ability to encrypt data

275
00:13:30,880 --> 00:13:31,760
with a

276
00:13:31,760 --> 00:13:35,440
aes algorithm anyway our research

277
00:13:35,440 --> 00:13:37,839
our liberal engineering process could be

278
00:13:37,839 --> 00:13:41,360
applied to these two types

279
00:13:41,360 --> 00:13:43,519
well now let's get down to details of

280
00:13:43,519 --> 00:13:45,279
assets from a reversing

281
00:13:45,279 --> 00:13:47,120
in this chapter we'll show you how to

282
00:13:47,120 --> 00:13:49,120
access your physical block data

283
00:13:49,120 --> 00:13:51,120
based on from a reversing on commercial

284
00:13:51,120 --> 00:13:52,399
ssd

285
00:13:52,399 --> 00:13:54,480
although we talk about one model in this

286
00:13:54,480 --> 00:13:56,959
time we would also like to show our

287
00:13:56,959 --> 00:13:58,560
reversing approaches

288
00:13:58,560 --> 00:14:01,600
not be confined to specific ssd then

289
00:14:01,600 --> 00:14:03,199
based on our analysis

290
00:14:03,199 --> 00:14:05,279
we'll be demonstrating our demo which

291
00:14:05,279 --> 00:14:07,440
can access our physical block data

292
00:14:07,440 --> 00:14:10,880
using pva manipulation

293
00:14:11,360 --> 00:14:13,279
please take a look this diagram to

294
00:14:13,279 --> 00:14:15,040
comprehensive understand the lead

295
00:14:15,040 --> 00:14:17,120
sequence based on our target

296
00:14:17,120 --> 00:14:19,040
as you can see there are three main

297
00:14:19,040 --> 00:14:21,279
components in ss formula

298
00:14:21,279 --> 00:14:23,360
so we should find where the three

299
00:14:23,360 --> 00:14:25,040
components are in the formula

300
00:14:25,040 --> 00:14:28,240
based on dynamic analysis the first we

301
00:14:28,240 --> 00:14:30,800
should define host interface layer part

302
00:14:30,800 --> 00:14:33,839
where the data comes in and out from at

303
00:14:33,839 --> 00:14:35,519
interface logic

304
00:14:35,519 --> 00:14:38,480
second is fresh translation layer it is

305
00:14:38,480 --> 00:14:39,440
considered as

306
00:14:39,440 --> 00:14:41,760
highlight part of the controller the

307
00:14:41,760 --> 00:14:42,720
last thing is

308
00:14:42,720 --> 00:14:44,959
flash interface layer which is

309
00:14:44,959 --> 00:14:47,680
communicate with fresh chip physically

310
00:14:47,680 --> 00:14:49,920
after this right we'll show you this

311
00:14:49,920 --> 00:14:50,800
component

312
00:14:50,800 --> 00:14:52,720
and some details what you found from

313
00:14:52,720 --> 00:14:56,800
analysis in our target ssd

314
00:14:57,040 --> 00:14:59,519
it is the first area where stored in the

315
00:14:59,519 --> 00:15:01,360
asset control memory from

316
00:15:01,360 --> 00:15:04,480
the host interface hardware logic when

317
00:15:04,480 --> 00:15:07,120
you send 80 commands to ssd

318
00:15:07,120 --> 00:15:09,680
and also it is important area that tells

319
00:15:09,680 --> 00:15:11,839
where the at command start

320
00:15:11,839 --> 00:15:14,320
and where to start analyzing the access

321
00:15:14,320 --> 00:15:15,519
formula

322
00:15:15,519 --> 00:15:18,320
as you can see in this buffer we can

323
00:15:18,320 --> 00:15:18,639
check

324
00:15:18,639 --> 00:15:22,160
at command requested iba and their ranks

325
00:15:22,160 --> 00:15:26,000
which we sent we'll step into code

326
00:15:26,000 --> 00:15:28,560
line by line after finding out at

327
00:15:28,560 --> 00:15:30,000
command buffer

328
00:15:30,000 --> 00:15:32,720
in the code lines rate 80 commanders

329
00:15:32,720 --> 00:15:35,120
table can handle the 80 command which is

330
00:15:35,120 --> 00:15:36,079
sent

331
00:15:36,079 --> 00:15:38,800
look at the right side this is the table

332
00:15:38,800 --> 00:15:39,519
which is

333
00:15:39,519 --> 00:15:42,079
indirect record by 80 command handler

334
00:15:42,079 --> 00:15:42,800
function

335
00:15:42,800 --> 00:15:45,759
what defined we can see supported 880

336
00:15:45,759 --> 00:15:46,320
command

337
00:15:46,320 --> 00:15:48,959
in this table such as read and write

338
00:15:48,959 --> 00:15:49,920
command

339
00:15:49,920 --> 00:15:54,720
from erase and update format and so on

340
00:15:54,720 --> 00:15:57,360
you can see certain code line which can

341
00:15:57,360 --> 00:15:57,920
lead

342
00:15:57,920 --> 00:15:59,920
data from then the flash chip when the

343
00:15:59,920 --> 00:16:02,320
r1 register stores to certain memory

344
00:16:02,320 --> 00:16:03,759
address

345
00:16:03,759 --> 00:16:06,240
the the address is actually flash chip

346
00:16:06,240 --> 00:16:07,120
channel buffer

347
00:16:07,120 --> 00:16:10,160
and this command is enable signal i will

348
00:16:10,160 --> 00:16:11,600
talk about later

349
00:16:11,600 --> 00:16:14,720
anyway after this run we can check the

350
00:16:14,720 --> 00:16:15,759
new multiples

351
00:16:15,759 --> 00:16:18,399
of sector size which was updated to

352
00:16:18,399 --> 00:16:20,480
flash data buffer

353
00:16:20,480 --> 00:16:22,959
if the target has hardware-based hold

354
00:16:22,959 --> 00:16:23,680
encryption

355
00:16:23,680 --> 00:16:26,079
to encrypt every data we need to

356
00:16:26,079 --> 00:16:28,079
cross-check to make sure

357
00:16:28,079 --> 00:16:30,160
if the data is actually read from

358
00:16:30,160 --> 00:16:31,279
flagship

359
00:16:31,279 --> 00:16:33,839
so we pick up any plain text data and

360
00:16:33,839 --> 00:16:36,079
write this data to ssd

361
00:16:36,079 --> 00:16:39,040
and we already know the the right buffer

362
00:16:39,040 --> 00:16:39,839
address

363
00:16:39,839 --> 00:16:42,399
where the ciphertext get in so we can

364
00:16:42,399 --> 00:16:44,160
check whether the ciphertext

365
00:16:44,160 --> 00:16:46,160
and our readout data before from then

366
00:16:46,160 --> 00:16:48,639
the fresh chip are same or not

367
00:16:48,639 --> 00:16:50,639
finally we can be sure that this is

368
00:16:50,639 --> 00:16:54,160
fresh data buffer address

369
00:16:54,560 --> 00:16:56,639
since then final process of reading

370
00:16:56,639 --> 00:16:58,480
sequence is about sending the

371
00:16:58,480 --> 00:17:00,480
data read from then the fresh chip to

372
00:17:00,480 --> 00:17:02,320
host it can also

373
00:17:02,320 --> 00:17:04,720
show certain code line which stores

374
00:17:04,720 --> 00:17:06,640
always high bit to certain memory

375
00:17:06,640 --> 00:17:07,760
address

376
00:17:07,760 --> 00:17:10,640
only after this run we can show data in

377
00:17:10,640 --> 00:17:11,359
host

378
00:17:11,359 --> 00:17:14,880
read buffer on pc if the assets

379
00:17:14,880 --> 00:17:17,599
have secretaries we can get plain text

380
00:17:17,599 --> 00:17:18,000
data

381
00:17:18,000 --> 00:17:20,400
which is decrypted by hardware security

382
00:17:20,400 --> 00:17:21,199
decoder

383
00:17:21,199 --> 00:17:24,319
as you can see although we have no idea

384
00:17:24,319 --> 00:17:27,599
about the logic asx test generate

385
00:17:27,599 --> 00:17:30,240
the block encryption key is ordered per

386
00:17:30,240 --> 00:17:31,120
aba

387
00:17:31,120 --> 00:17:33,440
to decrypt the ciphertext properly we

388
00:17:33,440 --> 00:17:34,559
should already send

389
00:17:34,559 --> 00:17:36,960
a b a corresponding to each ciphertext

390
00:17:36,960 --> 00:17:38,080
controller

391
00:17:38,080 --> 00:17:41,600
only then we've got a match

392
00:17:41,919 --> 00:17:44,160
from now on i'm going to talk about

393
00:17:44,160 --> 00:17:46,240
critical components in the assets

394
00:17:46,240 --> 00:17:47,360
formula

395
00:17:47,360 --> 00:17:49,840
they are fresh translation layer and

396
00:17:49,840 --> 00:17:51,440
fresh interface layer

397
00:17:51,440 --> 00:17:53,919
to get data from our prescript block on

398
00:17:53,919 --> 00:17:56,640
ssd we should exactly know how to make

399
00:17:56,640 --> 00:17:59,520
pbas and send the then the fresh command

400
00:17:59,520 --> 00:18:01,120
into channel buffer

401
00:18:01,120 --> 00:18:03,360
so first we obtain more details about

402
00:18:03,360 --> 00:18:06,799
translation mechanism over at aba to apn

403
00:18:06,799 --> 00:18:10,240
and apn to pba in target format and we

404
00:18:10,240 --> 00:18:10,799
figure

405
00:18:10,799 --> 00:18:13,360
figure out where flash chip channel

406
00:18:13,360 --> 00:18:14,000
buffer

407
00:18:14,000 --> 00:18:16,240
and what their update function to know

408
00:18:16,240 --> 00:18:18,720
how to send the nand fresh command

409
00:18:18,720 --> 00:18:20,799
then we able to inject the nand flash

410
00:18:20,799 --> 00:18:22,240
command to this buffer

411
00:18:22,240 --> 00:18:26,320
to get the data from our physical block

412
00:18:26,640 --> 00:18:29,280
we need to know about ltp first to

413
00:18:29,280 --> 00:18:30,880
maintain organization

414
00:18:30,880 --> 00:18:33,120
the controller used mapping table to

415
00:18:33,120 --> 00:18:35,520
remap the lba to pba

416
00:18:35,520 --> 00:18:38,640
this is atp map generally

417
00:18:38,640 --> 00:18:41,600
in vertical control each slab core has

418
00:18:41,600 --> 00:18:42,000
own

419
00:18:42,000 --> 00:18:44,880
ltp tables on each channel from what we

420
00:18:44,880 --> 00:18:45,280
found

421
00:18:45,280 --> 00:18:47,919
out from our target controller a channel

422
00:18:47,919 --> 00:18:50,320
supported controller have their own each

423
00:18:50,320 --> 00:18:53,520
attribute table we could also check

424
00:18:53,520 --> 00:18:55,520
these tables are stored in nand flash

425
00:18:55,520 --> 00:18:56,720
chip actually

426
00:18:56,720 --> 00:18:59,120
so whenever power up the controller

427
00:18:59,120 --> 00:19:01,679
wrote these tables to their data memory

428
00:19:01,679 --> 00:19:04,000
if we can access our physical block we

429
00:19:04,000 --> 00:19:05,760
can also handle order or

430
00:19:05,760 --> 00:19:08,840
the atp map tables stored in flash chip

431
00:19:08,840 --> 00:19:11,280
directory

432
00:19:11,280 --> 00:19:14,160
this is the this is right show a pn to

433
00:19:14,160 --> 00:19:17,600
pba translation part on our target ssd

434
00:19:17,600 --> 00:19:20,240
the rpm values refer to each element

435
00:19:20,240 --> 00:19:20,880
which are in

436
00:19:20,880 --> 00:19:23,919
entire tables generally the length of

437
00:19:23,919 --> 00:19:26,320
rpm value is decided by

438
00:19:26,320 --> 00:19:29,120
access mapping algorithm and capacity

439
00:19:29,120 --> 00:19:30,160
and flash chip

440
00:19:30,160 --> 00:19:33,280
is adapted by ss prime manufacturer so

441
00:19:33,280 --> 00:19:35,360
we need to know how the appn is

442
00:19:35,360 --> 00:19:36,799
organized

443
00:19:36,799 --> 00:19:39,200
we just found scattered pba calculation

444
00:19:39,200 --> 00:19:40,480
code in firmware

445
00:19:40,480 --> 00:19:43,120
we built into the one logical expression

446
00:19:43,120 --> 00:19:45,280
is is easy to understand

447
00:19:45,280 --> 00:19:49,520
so you can see three piece pbas

448
00:19:49,520 --> 00:19:51,520
and then we should know exactly what

449
00:19:51,520 --> 00:19:53,840
they are actually another fresh die

450
00:19:53,840 --> 00:19:56,160
is comprised of planes which contain

451
00:19:56,160 --> 00:19:56,880
props

452
00:19:56,880 --> 00:19:58,960
which contain pages which contain

453
00:19:58,960 --> 00:20:01,200
individual set of data

454
00:20:01,200 --> 00:20:03,760
although we do not get to come across a

455
00:20:03,760 --> 00:20:06,880
confidential data set just in from

456
00:20:06,880 --> 00:20:09,520
the size of their bit pva one is blocked

457
00:20:09,520 --> 00:20:12,080
and page address feature concatenate

458
00:20:12,080 --> 00:20:13,200
with one

459
00:20:13,200 --> 00:20:16,080
so part of seven which is pb1 indicate

460
00:20:16,080 --> 00:20:19,360
page address so they contain 828 pages

461
00:20:19,360 --> 00:20:20,559
in a product

462
00:20:20,559 --> 00:20:22,960
and the part of certain beach in pba one

463
00:20:22,960 --> 00:20:25,720
are blocked addressed so they contain

464
00:20:25,720 --> 00:20:28,400
8192 blocks on plane

465
00:20:28,400 --> 00:20:30,400
we are not sure whether it is way number

466
00:20:30,400 --> 00:20:32,159
from pb2 and pbs3

467
00:20:32,159 --> 00:20:35,200
in this quadrant based on rn flash

468
00:20:35,200 --> 00:20:35,679
command

469
00:20:35,679 --> 00:20:39,120
analysis which i talked later pbs3 is

470
00:20:39,120 --> 00:20:41,360
most probably plain address

471
00:20:41,360 --> 00:20:44,640
so the other one is pb to indicate a way

472
00:20:44,640 --> 00:20:46,960
number

473
00:20:47,280 --> 00:20:49,679
on a side note and also you can see

474
00:20:49,679 --> 00:20:51,840
reserve the block count on translation

475
00:20:51,840 --> 00:20:52,400
part

476
00:20:52,400 --> 00:20:55,520
in our formal analysis the way to make

477
00:20:55,520 --> 00:20:58,640
private prohibited area in the ssd

478
00:20:58,640 --> 00:21:00,559
is just to grab the reserved block

479
00:21:00,559 --> 00:21:02,000
number in ftl

480
00:21:02,000 --> 00:21:04,320
so user cannot access these graphs by

481
00:21:04,320 --> 00:21:05,520
factory setting

482
00:21:05,520 --> 00:21:08,880
in some cases the as key

483
00:21:08,880 --> 00:21:11,039
already generated by factory which is

484
00:21:11,039 --> 00:21:12,880
then stored in and the flash chip

485
00:21:12,880 --> 00:21:15,840
and is only known by direct itself for

486
00:21:15,840 --> 00:21:17,840
lack of time i will not delete that

487
00:21:17,840 --> 00:21:18,480
details

488
00:21:18,480 --> 00:21:22,240
in this talk go back to the topic the

489
00:21:22,240 --> 00:21:24,480
next step we need to find the absolute

490
00:21:24,480 --> 00:21:26,960
address of flash chip channel buffer

491
00:21:26,960 --> 00:21:29,440
if we know the address we can use this

492
00:21:29,440 --> 00:21:30,080
address

493
00:21:30,080 --> 00:21:33,120
to send an end fresh command this memory

494
00:21:33,120 --> 00:21:35,919
area show flash channel's buffer address

495
00:21:35,919 --> 00:21:36,799
what defined

496
00:21:36,799 --> 00:21:38,400
there are four channels in the slave

497
00:21:38,400 --> 00:21:41,360
core and you can see that there are a

498
00:21:41,360 --> 00:21:43,440
bunch of interesting data divided into

499
00:21:43,440 --> 00:21:45,840
two parts in one channel

500
00:21:45,840 --> 00:21:48,559
the upper part command is linked with

501
00:21:48,559 --> 00:21:51,280
parameters such as fresh addresses

502
00:21:51,280 --> 00:21:53,760
and the other one is primary command

503
00:21:53,760 --> 00:21:55,919
which are a parameter to be best

504
00:21:55,919 --> 00:21:58,559
to flash ship that's right i'm gonna

505
00:21:58,559 --> 00:22:00,080
show more details about

506
00:22:00,080 --> 00:22:03,039
this what it is

507
00:22:03,360 --> 00:22:06,240
the ssd arcade absolute address for

508
00:22:06,240 --> 00:22:07,120
flash command

509
00:22:07,120 --> 00:22:09,679
transfer it seems like waiting room or

510
00:22:09,679 --> 00:22:11,840
data bus for connecting with their flash

511
00:22:11,840 --> 00:22:12,640
chips

512
00:22:12,640 --> 00:22:15,679
so in this channel buffer their trigger

513
00:22:15,679 --> 00:22:17,760
signal which can start the commands to

514
00:22:17,760 --> 00:22:19,520
enable nand flash tube

515
00:22:19,520 --> 00:22:21,840
so you can see the pbas which are

516
00:22:21,840 --> 00:22:23,600
derived from the lpn to

517
00:22:23,600 --> 00:22:26,080
pba calculation part and there are

518
00:22:26,080 --> 00:22:26,720
comments

519
00:22:26,720 --> 00:22:28,880
let in no direction according to read or

520
00:22:28,880 --> 00:22:30,000
write command

521
00:22:30,000 --> 00:22:32,960
and read the buffer address this is

522
00:22:32,960 --> 00:22:34,480
letting know where will be

523
00:22:34,480 --> 00:22:36,960
stored on control memory after reader

524
00:22:36,960 --> 00:22:38,559
from then the flagship

525
00:22:38,559 --> 00:22:41,039
so when after they complete the command

526
00:22:41,039 --> 00:22:42,080
read our data

527
00:22:42,080 --> 00:22:46,000
in data memory others

528
00:22:47,200 --> 00:22:49,679
this is demo which demonstrates access

529
00:22:49,679 --> 00:22:51,760
to physical block on ssd

530
00:22:51,760 --> 00:22:54,799
using pbm manipulation even if it is

531
00:22:54,799 --> 00:22:56,480
securely raised

532
00:22:56,480 --> 00:22:58,880
before the test we do secure areas for

533
00:22:58,880 --> 00:22:59,679
crane

534
00:22:59,679 --> 00:23:02,240
and write arbitrary data on horse space

535
00:23:02,240 --> 00:23:03,360
lb0 to

536
00:23:03,360 --> 00:23:06,640
end of lba there are eight

537
00:23:06,640 --> 00:23:09,600
ltp map tables and you can see our atmo

538
00:23:09,600 --> 00:23:10,400
maps are

539
00:23:10,400 --> 00:23:14,080
updated with new lpn

540
00:23:18,400 --> 00:23:21,039
now this time we rewrite secure erase

541
00:23:21,039 --> 00:23:22,720
command

542
00:23:22,720 --> 00:23:26,559
and it will soon complete the command

543
00:23:27,200 --> 00:23:30,480
then you can see also changed ltp

544
00:23:30,480 --> 00:23:33,360
map it just changed with or high bit

545
00:23:33,360 --> 00:23:34,840
barrier on

546
00:23:34,840 --> 00:23:38,000
maps it means embarrassed or

547
00:23:38,000 --> 00:23:42,000
factory industrialized fpn

548
00:23:47,600 --> 00:23:50,799
so if after ssd fully erased by security

549
00:23:50,799 --> 00:23:53,120
rays

550
00:23:53,760 --> 00:23:56,720
you can not get access to fresh chip in

551
00:23:56,720 --> 00:23:57,760
normally because

552
00:23:57,760 --> 00:24:01,840
it cut off physical route to go fresh

553
00:24:02,840 --> 00:24:05,840
chips

554
00:24:11,440 --> 00:24:14,080
even in such a situation our two know

555
00:24:14,080 --> 00:24:16,640
where the flash chip channels refer is

556
00:24:16,640 --> 00:24:19,760
and how to put the pb elements so we

557
00:24:19,760 --> 00:24:22,080
able to get our physical block data in

558
00:24:22,080 --> 00:24:25,039
nand flash chips

559
00:24:26,000 --> 00:24:28,559
you can see the file data file which is

560
00:24:28,559 --> 00:24:29,120
gathered

561
00:24:29,120 --> 00:24:33,840
by our tool

562
00:24:44,000 --> 00:24:46,400
so what can we do with it in

563
00:24:46,400 --> 00:24:48,320
non-security encoding mode there

564
00:24:48,320 --> 00:24:51,200
it i didn't find unique pb block data

565
00:24:51,200 --> 00:24:52,960
not found in the lba

566
00:24:52,960 --> 00:24:56,799
so it all get our plain text data fresh

567
00:24:56,799 --> 00:25:00,080
second is it is used as forensic tool

568
00:25:00,080 --> 00:25:02,000
i think forensic guide need to image

569
00:25:02,000 --> 00:25:04,960
which based on physical address on ssd

570
00:25:04,960 --> 00:25:07,039
furthermore it is non-destructive you

571
00:25:07,039 --> 00:25:08,180
know

572
00:25:08,180 --> 00:25:09,360
[Music]

573
00:25:09,360 --> 00:25:12,080
if ssd have security including it is

574
00:25:12,080 --> 00:25:13,679
used as verifying of

575
00:25:13,679 --> 00:25:17,120
secure erase or data wiping tools

576
00:25:17,120 --> 00:25:19,120
in commercial accesses when default

577
00:25:19,120 --> 00:25:20,480
erased

578
00:25:20,480 --> 00:25:23,520
with securities the controller cannot

579
00:25:23,520 --> 00:25:25,520
remove the lba to pba

580
00:25:25,520 --> 00:25:27,520
because they cut off physical route to

581
00:25:27,520 --> 00:25:29,279
go fresh chips

582
00:25:29,279 --> 00:25:32,400
however it can make possible to get data

583
00:25:32,400 --> 00:25:34,320
in such a prohibited area in the fresh

584
00:25:34,320 --> 00:25:34,960
chips

585
00:25:34,960 --> 00:25:37,520
so we can verify whether access to steel

586
00:25:37,520 --> 00:25:39,679
leaves sensitive data or not

587
00:25:39,679 --> 00:25:42,640
and also we have taco before about how

588
00:25:42,640 --> 00:25:43,520
assets

589
00:25:43,520 --> 00:25:46,159
manufacturer control reserve physical

590
00:25:46,159 --> 00:25:47,520
block in ftl

591
00:25:47,520 --> 00:25:49,440
we think that there may be critical

592
00:25:49,440 --> 00:25:52,799
information in this area

593
00:25:53,760 --> 00:25:55,679
in this chapter we will show you how can

594
00:25:55,679 --> 00:25:57,600
we recover the operating data if there

595
00:25:57,600 --> 00:25:59,679
is hardware-based security in order in

596
00:25:59,679 --> 00:26:02,320
ssds

597
00:26:02,320 --> 00:26:04,640
this illustration shows what happens on

598
00:26:04,640 --> 00:26:07,760
ssds when operating to the same apa

599
00:26:07,760 --> 00:26:10,080
this could be the case by mistake on

600
00:26:10,080 --> 00:26:10,960
purpose such as

601
00:26:10,960 --> 00:26:13,279
ransomware where you can see the old

602
00:26:13,279 --> 00:26:15,840
data that is already stored in fresh

603
00:26:15,840 --> 00:26:18,000
and their physical data have a unique

604
00:26:18,000 --> 00:26:19,360
rpm value to tell

605
00:26:19,360 --> 00:26:23,120
control where they're stored in flash

606
00:26:23,360 --> 00:26:25,440
then if we override your data to the

607
00:26:25,440 --> 00:26:27,679
same apa the new lpm value will be

608
00:26:27,679 --> 00:26:28,559
generated by

609
00:26:28,559 --> 00:26:31,200
ftl component and the component try to

610
00:26:31,200 --> 00:26:33,200
overwrite new lpn to the edge

611
00:26:33,200 --> 00:26:37,679
table the old airplane is operating with

612
00:26:37,679 --> 00:26:38,000
the new

613
00:26:38,000 --> 00:26:41,200
rpm barrier on ltp table then controller

614
00:26:41,200 --> 00:26:43,360
no longer know where the old physical

615
00:26:43,360 --> 00:26:44,960
data on flash chip

616
00:26:44,960 --> 00:26:47,039
so we cannot get the data before the

617
00:26:47,039 --> 00:26:49,919
overwrite occurred

618
00:26:50,400 --> 00:26:53,120
as you can see ssd controller just cut

619
00:26:53,120 --> 00:26:54,400
off their physical route

620
00:26:54,400 --> 00:26:57,440
and the data still arrive if we can

621
00:26:57,440 --> 00:26:59,679
access our physical block on flash chip

622
00:26:59,679 --> 00:27:02,000
so we'll be able to get previous data

623
00:27:02,000 --> 00:27:03,279
before written

624
00:27:03,279 --> 00:27:05,919
however if the target has hardware-based

625
00:27:05,919 --> 00:27:06,559
horiz

626
00:27:06,559 --> 00:27:09,039
encryption to encrypt every data

627
00:27:09,039 --> 00:27:10,720
although data still arrives

628
00:27:10,720 --> 00:27:15,520
we can get only usually encrypted data

629
00:27:15,600 --> 00:27:18,240
however we still have one last chance if

630
00:27:18,240 --> 00:27:20,240
we can figure out old apn

631
00:27:20,240 --> 00:27:22,880
from the current rpm we can get plain

632
00:27:22,880 --> 00:27:24,399
text data

633
00:27:24,399 --> 00:27:26,720
it means that we should send aba

634
00:27:26,720 --> 00:27:28,240
corresponding to the

635
00:27:28,240 --> 00:27:31,039
encrypted block to access control and

636
00:27:31,039 --> 00:27:33,520
then it would be decrypted properly

637
00:27:33,520 --> 00:27:36,320
however it is hard to know aba

638
00:27:36,320 --> 00:27:37,279
corresponding to

639
00:27:37,279 --> 00:27:40,640
the given rpm because apn do not contain

640
00:27:40,640 --> 00:27:43,120
any information about aba

641
00:27:43,120 --> 00:27:45,760
is the same question about finding lba

642
00:27:45,760 --> 00:27:46,840
corresponding to

643
00:27:46,840 --> 00:27:49,840
ciphertext however at least for

644
00:27:49,840 --> 00:27:52,240
operating situation we can get plain

645
00:27:52,240 --> 00:27:52,880
text

646
00:27:52,880 --> 00:27:56,720
to eg even if you don't know master key

647
00:27:56,720 --> 00:27:59,200
since it is easy to know about aba from

648
00:27:59,200 --> 00:28:00,559
current lpn

649
00:28:00,559 --> 00:28:03,279
so if we can reconstruct api from

650
00:28:03,279 --> 00:28:04,559
current ipm

651
00:28:04,559 --> 00:28:06,559
the cipher text can be decrypted

652
00:28:06,559 --> 00:28:08,559
naturally with control

653
00:28:08,559 --> 00:28:11,440
anyway the challenge is to find what all

654
00:28:11,440 --> 00:28:12,480
the ipn

655
00:28:12,480 --> 00:28:16,640
is to reconstruct old apn

656
00:28:16,640 --> 00:28:18,880
we should know how the target assets

657
00:28:18,880 --> 00:28:21,520
select the block number when we operate

658
00:28:21,520 --> 00:28:23,919
and then we also need to know how page

659
00:28:23,919 --> 00:28:26,320
number is changed according to the

660
00:28:26,320 --> 00:28:30,000
overwriting when we write data to in our

661
00:28:30,000 --> 00:28:33,039
target ssd we figure out that flash

662
00:28:33,039 --> 00:28:34,640
translation logic has

663
00:28:34,640 --> 00:28:36,720
block agent table which block has been

664
00:28:36,720 --> 00:28:39,919
used many times to decide block number

665
00:28:39,919 --> 00:28:42,640
the simple diagram on the left it shows

666
00:28:42,640 --> 00:28:44,000
block agent table and

667
00:28:44,000 --> 00:28:47,279
how they work so if we write data

668
00:28:47,279 --> 00:28:49,600
after the component calculate average of

669
00:28:49,600 --> 00:28:51,679
agent count on the table

670
00:28:51,679 --> 00:28:53,679
and search the smaller value than

671
00:28:53,679 --> 00:28:54,799
average count

672
00:28:54,799 --> 00:28:57,520
to search rest free country used block

673
00:28:57,520 --> 00:28:58,080
finally

674
00:28:58,080 --> 00:29:01,279
the block number is stored on atp table

675
00:29:01,279 --> 00:29:03,919
and after if the blocks are not used it

676
00:29:03,919 --> 00:29:07,200
is stored in their tail

677
00:29:08,159 --> 00:29:11,360
now this time about page number if an

678
00:29:11,360 --> 00:29:14,399
application right 5 to the same apa this

679
00:29:14,399 --> 00:29:16,399
is also changed depending on the number

680
00:29:16,399 --> 00:29:17,600
of occurrences of

681
00:29:17,600 --> 00:29:21,279
right on same api look at the diagram on

682
00:29:21,279 --> 00:29:21,840
the left

683
00:29:21,840 --> 00:29:24,000
when you operate the same apa you can

684
00:29:24,000 --> 00:29:25,679
see the page changes following the

685
00:29:25,679 --> 00:29:26,000
number

686
00:29:26,000 --> 00:29:29,120
of right count here in lpn as i said

687
00:29:29,120 --> 00:29:30,320
before

688
00:29:30,320 --> 00:29:33,279
the lower 7 bit is offset value which

689
00:29:33,279 --> 00:29:34,960
indicates page

690
00:29:34,960 --> 00:29:37,840
especially you can see only the opposite

691
00:29:37,840 --> 00:29:38,399
value

692
00:29:38,399 --> 00:29:40,000
increase depending on the number of

693
00:29:40,000 --> 00:29:42,320
overwriting in the same apa

694
00:29:42,320 --> 00:29:44,960
as only offset barrier is increases

695
00:29:44,960 --> 00:29:47,200
depending on the number of overwriting

696
00:29:47,200 --> 00:29:50,080
so you can also see only the page is

697
00:29:50,080 --> 00:29:50,480
just

698
00:29:50,480 --> 00:29:54,720
moved and newly written

699
00:29:54,720 --> 00:29:57,440
where is this default feature of ssd

700
00:29:57,440 --> 00:30:00,320
using the brown level mapping algorithm

701
00:30:00,320 --> 00:30:02,559
when after overwriting occurs the

702
00:30:02,559 --> 00:30:03,760
original page

703
00:30:03,760 --> 00:30:06,559
is marked as stair and there is no

704
00:30:06,559 --> 00:30:07,360
choice

705
00:30:07,360 --> 00:30:10,720
but to review the cities because

706
00:30:10,720 --> 00:30:13,360
erasing cannot be processed per page it

707
00:30:13,360 --> 00:30:15,120
is done by block size

708
00:30:15,120 --> 00:30:17,760
therefore the gc function generally

709
00:30:17,760 --> 00:30:19,600
erases all the pages

710
00:30:19,600 --> 00:30:22,320
together at once furthermore to extend

711
00:30:22,320 --> 00:30:23,840
the access derived span

712
00:30:23,840 --> 00:30:26,480
assets tend to avoid aggressive bit

713
00:30:26,480 --> 00:30:28,640
until there is not enough space

714
00:30:28,640 --> 00:30:31,679
so we have still time to undo we can

715
00:30:31,679 --> 00:30:36,559
expect the data will remain

716
00:30:36,559 --> 00:30:39,039
before our demonstration i will briefly

717
00:30:39,039 --> 00:30:41,200
explain its ransomware which is among

718
00:30:41,200 --> 00:30:44,000
the very worst digester

719
00:30:44,000 --> 00:30:46,880
the key here is also how to find the

720
00:30:46,880 --> 00:30:49,039
original data before overwritten occurs

721
00:30:49,039 --> 00:30:50,399
in ssd

722
00:30:50,399 --> 00:30:52,799
from a file system activity view based

723
00:30:52,799 --> 00:30:54,640
on how it encrypts data

724
00:30:54,640 --> 00:30:56,640
ransomware can be divided into two

725
00:30:56,640 --> 00:30:58,000
groups overwrite or

726
00:30:58,000 --> 00:31:01,120
copy copy based ransomware their

727
00:31:01,120 --> 00:31:03,200
increment data is stored on free of a

728
00:31:03,200 --> 00:31:03,919
receptor

729
00:31:03,919 --> 00:31:06,960
in other words copy and delete in this

730
00:31:06,960 --> 00:31:07,760
case

731
00:31:07,760 --> 00:31:10,000
it is possible to recover some original

732
00:31:10,000 --> 00:31:11,760
data with the conventional

733
00:31:11,760 --> 00:31:14,880
data recovery tools however overwrite

734
00:31:14,880 --> 00:31:15,440
type

735
00:31:15,440 --> 00:31:17,760
that encrypted data is stored on same

736
00:31:17,760 --> 00:31:19,039
physical sectors so

737
00:31:19,039 --> 00:31:20,880
it is impossible to recover with the

738
00:31:20,880 --> 00:31:23,279
true because the ssd use

739
00:31:23,279 --> 00:31:25,600
other physical block when the ransom may

740
00:31:25,600 --> 00:31:26,720
write an identical

741
00:31:26,720 --> 00:31:29,360
api with encrypted data since then

742
00:31:29,360 --> 00:31:29,760
update

743
00:31:29,760 --> 00:31:32,480
new lpn so original data can lost their

744
00:31:32,480 --> 00:31:33,440
physical route

745
00:31:33,440 --> 00:31:35,679
so we should open their physical route

746
00:31:35,679 --> 00:31:37,760
by old fpl restoration

747
00:31:37,760 --> 00:31:40,320
in next slide we will show you how about

748
00:31:40,320 --> 00:31:46,399
our steps for operating data restoration

749
00:31:46,399 --> 00:31:49,120
these are our steps for data restoration

750
00:31:49,120 --> 00:31:51,039
first step is that we should get

751
00:31:51,039 --> 00:31:52,960
ava from the file while we hope to

752
00:31:52,960 --> 00:31:55,519
recover if you use commercial disk

753
00:31:55,519 --> 00:31:56,240
editor

754
00:31:56,240 --> 00:31:59,600
such as winihex which calls sector is

755
00:31:59,600 --> 00:32:02,720
rba in terms of the hard disk drive yes

756
00:32:02,720 --> 00:32:04,880
it is very easy to find out

757
00:32:04,880 --> 00:32:08,480
second step is that we should get apn

758
00:32:08,480 --> 00:32:11,600
corresponding to aba first

759
00:32:11,600 --> 00:32:13,360
third step is just recovering all the

760
00:32:13,360 --> 00:32:15,360
apn using our script

761
00:32:15,360 --> 00:32:17,440
we deduce all the api from the current

762
00:32:17,440 --> 00:32:18,559
rpm based on

763
00:32:18,559 --> 00:32:21,360
aging table and their write count and we

764
00:32:21,360 --> 00:32:23,360
filled candidates with likely to have

765
00:32:23,360 --> 00:32:25,840
been used

766
00:32:27,279 --> 00:32:29,679
final steps we replace current airplane

767
00:32:29,679 --> 00:32:31,440
with candidate rpms

768
00:32:31,440 --> 00:32:34,480
and then we read again this file and

769
00:32:34,480 --> 00:32:37,919
it will be decrypted with original apa

770
00:32:37,919 --> 00:32:40,320
if that file is not the file we are

771
00:32:40,320 --> 00:32:41,440
looking for

772
00:32:41,440 --> 00:32:44,320
in this case we retire retry attempts to

773
00:32:44,320 --> 00:32:44,880
replace

774
00:32:44,880 --> 00:32:48,159
apn with the other candidate apps

775
00:32:48,159 --> 00:32:50,799
probably we can find the fire what we

776
00:32:50,799 --> 00:32:53,039
send

777
00:32:53,840 --> 00:32:56,000
here is simple demo which demonstrates

778
00:32:56,000 --> 00:33:00,240
overwritten data restoration of a file

779
00:33:01,600 --> 00:33:04,480
firstly we format the target access with

780
00:33:04,480 --> 00:33:07,279
ntfs

781
00:33:08,080 --> 00:33:12,000
in the d drive we make a test file which

782
00:33:12,000 --> 00:33:16,080
will be de-encrypted by ransomware

783
00:33:16,640 --> 00:33:25,840
we write something that's text for demo

784
00:33:26,880 --> 00:33:29,919
and save the file

785
00:33:31,279 --> 00:33:33,919
and we get fba from the file using win

786
00:33:33,919 --> 00:33:36,240
hex

787
00:33:37,600 --> 00:33:39,840
so you can see physical sector in terms

788
00:33:39,840 --> 00:33:40,880
of a hard disk

789
00:33:40,880 --> 00:33:44,240
drive this is av in ssd view and you can

790
00:33:44,240 --> 00:33:47,200
see file content

791
00:33:48,320 --> 00:33:51,360
let me just increase file with overwrite

792
00:33:51,360 --> 00:33:54,880
type ransomware simulator

793
00:33:54,880 --> 00:33:57,840
and then you can see plain text data

794
00:33:57,840 --> 00:33:59,120
before encrypt

795
00:33:59,120 --> 00:34:07,039
and encrypted text

796
00:34:07,039 --> 00:34:09,679
and this is rpm value which is we have

797
00:34:09,679 --> 00:34:12,720
to restorator

798
00:34:18,960 --> 00:34:21,440
and after ransomware overwrite to same

799
00:34:21,440 --> 00:34:22,239
api

800
00:34:22,239 --> 00:34:25,280
same file and it is done you can see

801
00:34:25,280 --> 00:34:27,119
changed rpm value

802
00:34:27,119 --> 00:34:29,839
of the file

803
00:34:33,520 --> 00:34:36,399
and after we get their old apn to doing

804
00:34:36,399 --> 00:34:38,638
so

805
00:34:39,280 --> 00:34:41,119
we filled candidates which right could

806
00:34:41,119 --> 00:34:42,800
have been used you can see

807
00:34:42,800 --> 00:34:46,839
the previous rpm value among our old apn

808
00:34:46,839 --> 00:34:49,839
candidate

809
00:34:54,159 --> 00:34:57,119
we just read the file you can see

810
00:34:57,119 --> 00:35:00,480
encrypted data yet

811
00:35:00,560 --> 00:35:03,359
and on the right you can see also apn of

812
00:35:03,359 --> 00:35:06,319
encrypted data

813
00:35:12,560 --> 00:35:15,200
final step we should we should replace

814
00:35:15,200 --> 00:35:18,960
current fpm with old apn

815
00:35:19,839 --> 00:35:31,839
what you got before

816
00:35:37,520 --> 00:35:41,520
and then we read again this file

817
00:35:41,839 --> 00:35:43,839
you can see the file previous data

818
00:35:43,839 --> 00:35:45,839
before ransomware occurred

819
00:35:45,839 --> 00:35:49,839
and it is decrypted properly

820
00:35:56,480 --> 00:35:59,520
what is next we work on the

821
00:35:59,520 --> 00:36:02,560
analysis for various vendors as they are

822
00:36:02,560 --> 00:36:03,920
now in progress

823
00:36:03,920 --> 00:36:06,400
so we have a plan that the work will

824
00:36:06,400 --> 00:36:08,000
also be expanded to

825
00:36:08,000 --> 00:36:10,839
cover as much as possible to the other

826
00:36:10,839 --> 00:36:12,400
ssds

827
00:36:12,400 --> 00:36:15,119
and the and the usage of nvme type is

828
00:36:15,119 --> 00:36:16,240
increasing

829
00:36:16,240 --> 00:36:19,440
it is worse applying to nbme type for

830
00:36:19,440 --> 00:36:20,800
future

831
00:36:20,800 --> 00:36:23,359
for enhance our tool we need to more

832
00:36:23,359 --> 00:36:25,040
study state-of-the-art

833
00:36:25,040 --> 00:36:28,079
access asset technologies and we are

834
00:36:28,079 --> 00:36:30,320
preparing security evaluation tool for

835
00:36:30,320 --> 00:36:31,119
access this

836
00:36:31,119 --> 00:36:34,079
such as commercial wiping tools or

837
00:36:34,079 --> 00:36:36,320
manufacture security command

838
00:36:36,320 --> 00:36:40,240
verifying tool

839
00:36:40,240 --> 00:36:42,800
for the for the other access to security

840
00:36:42,800 --> 00:36:44,880
variation we work on commercial access

841
00:36:44,880 --> 00:36:47,359
the aes key extraction used using side

842
00:36:47,359 --> 00:36:48,320
channel attack

843
00:36:48,320 --> 00:36:50,720
as you know conventional forensic tools

844
00:36:50,720 --> 00:36:52,960
still focused on hard disk drive

845
00:36:52,960 --> 00:36:56,079
so in the future we should to go our

846
00:36:56,079 --> 00:36:58,160
tours mainly need to focus on the

847
00:36:58,160 --> 00:36:59,440
forensic tool for

848
00:36:59,440 --> 00:37:02,880
ancestors so we are looking for out

849
00:37:02,880 --> 00:37:05,839
for their religion and also i think that

850
00:37:05,839 --> 00:37:06,560
further

851
00:37:06,560 --> 00:37:08,720
study about the relation between french

852
00:37:08,720 --> 00:37:11,040
translation layer and security is needed

853
00:37:11,040 --> 00:37:13,839
in this area

854
00:37:14,560 --> 00:37:16,320
thank you for your attention if you have

855
00:37:16,320 --> 00:37:19,000
any question please send me mail thank

856
00:37:19,000 --> 00:37:22,000
you

