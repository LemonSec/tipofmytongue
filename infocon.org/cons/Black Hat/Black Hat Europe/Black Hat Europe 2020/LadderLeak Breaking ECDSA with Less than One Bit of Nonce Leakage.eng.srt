1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:16,239 --> 00:00:17,119
hi everyone

3
00:00:17,119 --> 00:00:19,119
i'm diego again from wahoo's university

4
00:00:19,119 --> 00:00:20,960
and i'm here to present leatherlick

5
00:00:20,960 --> 00:00:23,119
our latest attack against ecds8

6
00:00:23,119 --> 00:00:25,119
signatures using less than one bit of

7
00:00:25,119 --> 00:00:26,560
nose leakage

8
00:00:26,560 --> 00:00:28,160
this work has already appeared at the

9
00:00:28,160 --> 00:00:29,920
ccs conference this year and it's

10
00:00:29,920 --> 00:00:31,439
available on new print

11
00:00:31,439 --> 00:00:33,280
it's a collaboration with a filipino

12
00:00:33,280 --> 00:00:35,360
vice university of components in brazil

13
00:00:35,360 --> 00:00:37,360
akiga takahashi from all's university in

14
00:00:37,360 --> 00:00:40,320
denmark meditebushi from entity in japan

15
00:00:40,320 --> 00:00:42,239
and yuvo vyagam from university of

16
00:00:42,239 --> 00:00:44,640
adelaide in australia

17
00:00:44,640 --> 00:00:46,879
in this talk i will describe new attacks

18
00:00:46,879 --> 00:00:48,960
exploiting randomness leakage and bias

19
00:00:48,960 --> 00:00:50,320
from ecdsa type

20
00:00:50,320 --> 00:00:52,480
signature schemes based on newly

21
00:00:52,480 --> 00:00:54,559
discovered vulnerabilities in ecdsa

22
00:00:54,559 --> 00:00:56,719
implementations contained in the openssl

23
00:00:56,719 --> 00:00:59,359
and relic cryptographic libraries

24
00:00:59,359 --> 00:01:01,039
these vulnerabilities have led to

25
00:01:01,039 --> 00:01:02,559
theoretical improvements to the attack

26
00:01:02,559 --> 00:01:04,239
framework based on solving the hidden

27
00:01:04,239 --> 00:01:05,760
number problem

28
00:01:05,760 --> 00:01:07,840
in the first part of the attack i will

29
00:01:07,840 --> 00:01:09,280
of the talk i will explain how to

30
00:01:09,280 --> 00:01:11,200
acquire sidechainer information

31
00:01:11,200 --> 00:01:13,119
in the second part of the talk akiga

32
00:01:13,119 --> 00:01:14,799
will explain how to exploit sidechain

33
00:01:14,799 --> 00:01:17,520
information to recover the secret key

34
00:01:17,520 --> 00:01:18,880
but let's first start with some

35
00:01:18,880 --> 00:01:22,720
background on attacking ecdsa nonces

36
00:01:22,720 --> 00:01:25,200
ecdsa and schnorr signatures are among

37
00:01:25,200 --> 00:01:27,119
the most popular signature schemes rely

38
00:01:27,119 --> 00:01:28,400
on the hardness of the discrete

39
00:01:28,400 --> 00:01:29,600
logarithmic problem

40
00:01:29,600 --> 00:01:32,240
for security modern instantiations of

41
00:01:32,240 --> 00:01:33,600
the signature schemes

42
00:01:33,600 --> 00:01:36,479
use elliptic curves for efficiency in

43
00:01:36,479 --> 00:01:38,240
both of them the signing operation

44
00:01:38,240 --> 00:01:40,159
involves a random value k

45
00:01:40,159 --> 00:01:42,159
sometimes called unknowns to randomize

46
00:01:42,159 --> 00:01:43,759
the signatures

47
00:01:43,759 --> 00:01:45,680
calling this value announce is a major

48
00:01:45,680 --> 00:01:47,200
understatement because it needs to

49
00:01:47,200 --> 00:01:49,200
remain secret or well protected for a

50
00:01:49,200 --> 00:01:50,720
long amount of time

51
00:01:50,720 --> 00:01:52,560
otherwise this the security of the

52
00:01:52,560 --> 00:01:54,079
signatory scheme is completely

53
00:01:54,079 --> 00:01:55,759
undermined

54
00:01:55,759 --> 00:01:57,520
let's assume a scenario where alice and

55
00:01:57,520 --> 00:01:58,880
bob want to exchange

56
00:01:58,880 --> 00:02:01,439
digital signatures so alice generates a

57
00:02:01,439 --> 00:02:02,240
private key

58
00:02:02,240 --> 00:02:04,240
and sends the public her public key to

59
00:02:04,240 --> 00:02:06,719
bob for verifying signatures

60
00:02:06,719 --> 00:02:09,440
when alice wants to sign a message she

61
00:02:09,440 --> 00:02:10,959
generates unknowns

62
00:02:10,959 --> 00:02:12,959
and combines the nodes with the message

63
00:02:12,959 --> 00:02:14,000
and the private key

64
00:02:14,000 --> 00:02:15,920
to compute the signature that can be

65
00:02:15,920 --> 00:02:17,440
sent by to bob

66
00:02:17,440 --> 00:02:20,640
for purification what's interesting

67
00:02:20,640 --> 00:02:22,239
about the signature scheme is that the

68
00:02:22,239 --> 00:02:24,879
signing equation relates public values

69
00:02:24,879 --> 00:02:26,879
coming from the signatures to the two

70
00:02:26,879 --> 00:02:29,040
unknowns the private key

71
00:02:29,040 --> 00:02:31,920
and the nodes this means that if the

72
00:02:31,920 --> 00:02:34,160
nodes leaks or is exposed somehow

73
00:02:34,160 --> 00:02:35,840
this gives information to compute the

74
00:02:35,840 --> 00:02:37,280
private key directly

75
00:02:37,280 --> 00:02:39,360
in particular if two signatures are

76
00:02:39,360 --> 00:02:41,200
computed over different messages and

77
00:02:41,200 --> 00:02:43,519
using the same nodes

78
00:02:43,519 --> 00:02:46,480
this can also be used to compute the

79
00:02:46,480 --> 00:02:50,080
private key

80
00:02:50,080 --> 00:02:53,280
but these are extreme cases for example

81
00:02:53,280 --> 00:02:54,640
we could have the case that due to

82
00:02:54,640 --> 00:02:56,080
implementation error or

83
00:02:56,080 --> 00:02:57,599
malfunction in the random number

84
00:02:57,599 --> 00:02:59,280
generator some bits

85
00:02:59,280 --> 00:03:02,319
of the nodes are fixed or perhaps an

86
00:03:02,319 --> 00:03:04,239
adversary is able to obtain leakage

87
00:03:04,239 --> 00:03:05,760
correlated with those bits

88
00:03:05,760 --> 00:03:08,239
with high probability in this case the

89
00:03:08,239 --> 00:03:10,159
adversary could collect many signatures

90
00:03:10,159 --> 00:03:12,800
computed by alice under her private key

91
00:03:12,800 --> 00:03:14,480
and solve the hidden number problem to

92
00:03:14,480 --> 00:03:16,959
compute this private key

93
00:03:16,959 --> 00:03:18,640
randomness failure is not only of

94
00:03:18,640 --> 00:03:20,480
academic interest and can actually

95
00:03:20,480 --> 00:03:21,200
manifest

96
00:03:21,200 --> 00:03:23,599
many different ways in the real world

97
00:03:23,599 --> 00:03:25,280
perhaps due to a poorly designed or

98
00:03:25,280 --> 00:03:27,200
implemented random number generator

99
00:03:27,200 --> 00:03:29,680
or maybe the initial state of the random

100
00:03:29,680 --> 00:03:31,599
number generator was predictable

101
00:03:31,599 --> 00:03:34,000
like a timestamp or perhaps a virtual

102
00:03:34,000 --> 00:03:35,920
machine resets to a previous snapshot

103
00:03:35,920 --> 00:03:36,480
version

104
00:03:36,480 --> 00:03:38,000
and then repeats the internal state of

105
00:03:38,000 --> 00:03:40,480
the random number generator producing

106
00:03:40,480 --> 00:03:42,319
the same nodes for two different

107
00:03:42,319 --> 00:03:43,519
signatures

108
00:03:43,519 --> 00:03:46,080
in the context of this talk i worry

109
00:03:46,080 --> 00:03:46,799
about

110
00:03:46,799 --> 00:03:48,239
side channel leakage in which the

111
00:03:48,239 --> 00:03:50,080
attacker is able to obtain information

112
00:03:50,080 --> 00:03:52,879
correlated with bits of the nodes

113
00:03:52,879 --> 00:03:54,640
one high profile case of randomness

114
00:03:54,640 --> 00:03:56,400
failure in practice was the playstation

115
00:03:56,400 --> 00:03:57,120
3

116
00:03:57,120 --> 00:03:59,439
when sony used the same nodes to sign

117
00:03:59,439 --> 00:04:00,319
many games

118
00:04:00,319 --> 00:04:02,159
and this allowed the homebrew community

119
00:04:02,159 --> 00:04:04,400
to compute the signing key from just two

120
00:04:04,400 --> 00:04:06,159
different legit made games

121
00:04:06,159 --> 00:04:08,720
and then be able to authorize software

122
00:04:08,720 --> 00:04:11,280
to run on the platform

123
00:04:11,280 --> 00:04:13,439
there are many other cases involving

124
00:04:13,439 --> 00:04:15,360
bitcoin wallets and voting machines

125
00:04:15,360 --> 00:04:17,440
where randomness failure

126
00:04:17,440 --> 00:04:18,880
completely broken the security

127
00:04:18,880 --> 00:04:23,280
properties imposed on those systems

128
00:04:23,759 --> 00:04:25,520
our contributions in this talk are

129
00:04:25,520 --> 00:04:27,440
three-fold the first one

130
00:04:27,440 --> 00:04:28,960
is a novel class of cache attacks

131
00:04:28,960 --> 00:04:31,520
against ecdsc implemented in openssl

132
00:04:31,520 --> 00:04:34,639
versions 102u and 110l

133
00:04:34,639 --> 00:04:36,400
and also the research oriented

134
00:04:36,400 --> 00:04:38,560
cryptographic library called relic

135
00:04:38,560 --> 00:04:42,800
version 0.4 there are many

136
00:04:42,800 --> 00:04:44,479
sets of parameters affected by this

137
00:04:44,479 --> 00:04:46,400
vulnerability essentially

138
00:04:46,400 --> 00:04:48,080
any curve in which the group order is

139
00:04:48,080 --> 00:04:49,680
just below a power of 2

140
00:04:49,680 --> 00:04:51,440
could be affected if the implementation

141
00:04:51,440 --> 00:04:53,520
is variable as well

142
00:04:53,520 --> 00:04:56,000
this includes many curves standardized

143
00:04:56,000 --> 00:04:58,240
by nist and defined it over prime fields

144
00:04:58,240 --> 00:05:00,080
and also curves defined over binary

145
00:05:00,080 --> 00:05:01,919
fields also the

146
00:05:01,919 --> 00:05:03,919
sum of the curves standardizing in the

147
00:05:03,919 --> 00:05:06,080
older seg standard

148
00:05:06,080 --> 00:05:09,360
could be affected in particular

149
00:05:09,360 --> 00:05:13,600
the bitcoin curve sec p256 k1

150
00:05:13,600 --> 00:05:15,759
in the initial version of our work we

151
00:05:15,759 --> 00:05:18,479
had the impression that curve p256

152
00:05:18,479 --> 00:05:21,039
as implemented in openssl was affected

153
00:05:21,039 --> 00:05:23,199
but later we found out that openssl has

154
00:05:23,199 --> 00:05:24,320
custom code

155
00:05:24,320 --> 00:05:26,240
to implement arithmetic on that curve

156
00:05:26,240 --> 00:05:28,240
that's not vulnerable

157
00:05:28,240 --> 00:05:30,080
it's hard to know exactly what products

158
00:05:30,080 --> 00:05:31,680
are affected by leatherlick

159
00:05:31,680 --> 00:05:34,479
but we could search over github and find

160
00:05:34,479 --> 00:05:36,080
that several projects

161
00:05:36,080 --> 00:05:38,479
bumped the library version of openssl in

162
00:05:38,479 --> 00:05:40,160
their build systems

163
00:05:40,160 --> 00:05:43,039
this means that they at least included

164
00:05:43,039 --> 00:05:44,400
versions of the library that were

165
00:05:44,400 --> 00:05:44,960
affected

166
00:05:44,960 --> 00:05:47,199
but we cannot claim that this could be

167
00:05:47,199 --> 00:05:49,120
exploited under some realistic threat

168
00:05:49,120 --> 00:05:51,759
model against those products

169
00:05:51,759 --> 00:05:54,000
the second contribution of our work is

170
00:05:54,000 --> 00:05:55,759
theoretical improvements to

171
00:05:55,759 --> 00:05:58,160
attacks based on fourier analysis to

172
00:05:58,160 --> 00:05:59,759
solve the hidden number problem

173
00:05:59,759 --> 00:06:01,759
that significantly reduces the amount of

174
00:06:01,759 --> 00:06:03,440
input data or the number of signatures

175
00:06:03,440 --> 00:06:04,720
to be effective

176
00:06:04,720 --> 00:06:06,479
this allows the attack to be feasible

177
00:06:06,479 --> 00:06:08,960
given less than one bit of non-speed

178
00:06:08,960 --> 00:06:11,039
bias leakage per signature which means

179
00:06:11,039 --> 00:06:12,960
that the attacker is able to obtain one

180
00:06:12,960 --> 00:06:14,080
bit of the nonce

181
00:06:14,080 --> 00:06:16,240
with less than a hundred percent success

182
00:06:16,240 --> 00:06:17,919
probability

183
00:06:17,919 --> 00:06:20,400
so then less than one bit of bias in

184
00:06:20,400 --> 00:06:21,680
average

185
00:06:21,680 --> 00:06:23,600
we implemented a full secret key

186
00:06:23,600 --> 00:06:25,680
recovery attack against openssl

187
00:06:25,680 --> 00:06:28,560
over two sets of parameters a binary

188
00:06:28,560 --> 00:06:29,440
curve over

189
00:06:29,440 --> 00:06:32,000
a smaller field and a prime curve over

190
00:06:32,000 --> 00:06:35,440
field p192

191
00:06:35,440 --> 00:06:37,120
now let's move to some background on

192
00:06:37,120 --> 00:06:39,360
curve based cryptography

193
00:06:39,360 --> 00:06:42,000
elliptic curves are sets of solutions x

194
00:06:42,000 --> 00:06:44,400
and y to a curve equation

195
00:06:44,400 --> 00:06:46,319
and they come equipped with a geometric

196
00:06:46,319 --> 00:06:48,960
operation that defines a group law

197
00:06:48,960 --> 00:06:51,280
called point addition when you want to

198
00:06:51,280 --> 00:06:52,080
add points p

199
00:06:52,080 --> 00:06:54,560
and q especially on this curve that's

200
00:06:54,560 --> 00:06:56,479
defined on the real numbers so the curve

201
00:06:56,479 --> 00:06:56,800
is

202
00:06:56,800 --> 00:06:59,759
is continuous we can trace a line

203
00:06:59,759 --> 00:07:01,440
passive through p and q

204
00:07:01,440 --> 00:07:04,319
and reflect the interception between the

205
00:07:04,319 --> 00:07:06,080
line and the curve across the x

206
00:07:06,080 --> 00:07:09,280
axis to get the result if the point is

207
00:07:09,280 --> 00:07:10,240
being doubled

208
00:07:10,240 --> 00:07:12,720
we take the tangent line instead and

209
00:07:12,720 --> 00:07:14,880
this allows us to compute r

210
00:07:14,880 --> 00:07:18,160
in the same way for cryptographic

211
00:07:18,160 --> 00:07:18,800
interest

212
00:07:18,800 --> 00:07:20,479
we take curves defined over finite

213
00:07:20,479 --> 00:07:22,319
fields such that the discrete logarithm

214
00:07:22,319 --> 00:07:24,800
problem is hard

215
00:07:24,800 --> 00:07:26,479
what's interesting is that the same

216
00:07:26,479 --> 00:07:28,479
geometric

217
00:07:28,479 --> 00:07:31,120
intuition gives us a group law an

218
00:07:31,120 --> 00:07:33,440
operation that defines a group

219
00:07:33,440 --> 00:07:36,240
in practice usually chosen to have prime

220
00:07:36,240 --> 00:07:36,800
order

221
00:07:36,800 --> 00:07:38,639
with the point at infinity serving as

222
00:07:38,639 --> 00:07:40,479
the identity element

223
00:07:40,479 --> 00:07:42,720
efficient implementations will not

224
00:07:42,720 --> 00:07:44,160
represent the points in a fine

225
00:07:44,160 --> 00:07:45,599
coordinates x and y

226
00:07:45,599 --> 00:07:48,639
because computing the slope of this line

227
00:07:48,639 --> 00:07:50,720
requires to compute a field diversion or

228
00:07:50,720 --> 00:07:52,080
division that's computationally

229
00:07:52,080 --> 00:07:53,360
expensive

230
00:07:53,360 --> 00:07:55,680
so actual efficient implementations we

231
00:07:55,680 --> 00:07:57,199
use a projective coordinate system

232
00:07:57,199 --> 00:07:58,080
instead

233
00:07:58,080 --> 00:08:00,560
in which the slope of the line is

234
00:08:00,560 --> 00:08:02,479
accumulated across multiple operations

235
00:08:02,479 --> 00:08:05,199
and resolve it only at the end

236
00:08:05,199 --> 00:08:07,840
in this representation a point is

237
00:08:07,840 --> 00:08:09,520
represented using coordinates

238
00:08:09,520 --> 00:08:11,840
x y and z such that the x and y

239
00:08:11,840 --> 00:08:13,840
coordinates are weighted by some power

240
00:08:13,840 --> 00:08:16,159
of z

241
00:08:18,080 --> 00:08:20,240
when elliptic curves are used to

242
00:08:20,240 --> 00:08:21,919
instantiate

243
00:08:21,919 --> 00:08:24,080
cryptographic protocols one operation

244
00:08:24,080 --> 00:08:25,039
becomes critical

245
00:08:25,039 --> 00:08:27,599
the so-called scalar multiplication

246
00:08:27,599 --> 00:08:28,400
scale of

247
00:08:28,400 --> 00:08:30,639
multiplication amounts to add the point

248
00:08:30,639 --> 00:08:34,240
g to itself a secret number of times

249
00:08:34,240 --> 00:08:35,919
it is indeed critical for both

250
00:08:35,919 --> 00:08:38,719
performance of ecc crypto systems

251
00:08:38,719 --> 00:08:42,080
and their security let's take a look at

252
00:08:42,080 --> 00:08:44,159
the ecdsa signature generation for an

253
00:08:44,159 --> 00:08:45,120
example

254
00:08:45,120 --> 00:08:48,399
so ecdsa signing takes a private key

255
00:08:48,399 --> 00:08:51,200
a message a group order a base point and

256
00:08:51,200 --> 00:08:52,800
a hash function as inputs and it

257
00:08:52,800 --> 00:08:54,720
computes a valid signature

258
00:08:54,720 --> 00:08:57,519
it starts by generating the nodes k

259
00:08:57,519 --> 00:08:59,519
that's then multiplied by the base point

260
00:08:59,519 --> 00:09:00,800
g

261
00:09:00,800 --> 00:09:04,320
to produce a point r this

262
00:09:04,320 --> 00:09:06,320
point r is then used at the remaining

263
00:09:06,320 --> 00:09:08,000
part steps of the signature

264
00:09:08,000 --> 00:09:10,399
to to compute the pair of values that

265
00:09:10,399 --> 00:09:13,920
are produced as output

266
00:09:14,000 --> 00:09:15,760
this operation here is actually

267
00:09:15,760 --> 00:09:17,120
sensitive because

268
00:09:17,120 --> 00:09:18,959
if there is any leakage about the nodes

269
00:09:18,959 --> 00:09:21,279
k this can be used by an attacker to

270
00:09:21,279 --> 00:09:22,080
obtain information

271
00:09:22,080 --> 00:09:25,519
about the signing key if one is worried

272
00:09:25,519 --> 00:09:27,760
in particular about timing attacks

273
00:09:27,760 --> 00:09:29,440
in which the adversary monitors the

274
00:09:29,440 --> 00:09:31,279
execution time of intermediate steps of

275
00:09:31,279 --> 00:09:32,399
the computation to

276
00:09:32,399 --> 00:09:36,080
to obtain information about k a

277
00:09:36,080 --> 00:09:38,000
counter measure is to implement this

278
00:09:38,000 --> 00:09:39,920
operation in constant time such that the

279
00:09:39,920 --> 00:09:41,600
execution time doesn't depend

280
00:09:41,600 --> 00:09:44,959
on the bit pattern of k this is very

281
00:09:44,959 --> 00:09:47,120
challenging on modern cpus because they

282
00:09:47,120 --> 00:09:48,640
have because they have instructions like

283
00:09:48,640 --> 00:09:50,480
c flush that can reveal secrets through

284
00:09:50,480 --> 00:09:52,720
cache data eviction

285
00:09:52,720 --> 00:09:54,720
when programs share a library in memory

286
00:09:54,720 --> 00:09:56,240
a flash and reload attack becomes

287
00:09:56,240 --> 00:09:57,200
possible

288
00:09:57,200 --> 00:09:59,200
so assume that there are a victim and

289
00:09:59,200 --> 00:10:00,560
attacker programs running

290
00:10:00,560 --> 00:10:03,600
at the same time and the

291
00:10:03,600 --> 00:10:05,600
attacker program is willing to know if

292
00:10:05,600 --> 00:10:08,079
the memory a certain memory access is

293
00:10:08,079 --> 00:10:09,920
being performed or not by the victims

294
00:10:09,920 --> 00:10:11,600
program

295
00:10:11,600 --> 00:10:14,079
so for that to happen the attacker

296
00:10:14,079 --> 00:10:15,680
flushes that memory address

297
00:10:15,680 --> 00:10:17,920
and then waits certain number of cycles

298
00:10:17,920 --> 00:10:20,240
that we call the slot

299
00:10:20,240 --> 00:10:23,200
before it reloads that address to cache

300
00:10:23,200 --> 00:10:24,800
memory again

301
00:10:24,800 --> 00:10:26,800
if the reload step takes a long time

302
00:10:26,800 --> 00:10:28,959
this means that the victim

303
00:10:28,959 --> 00:10:32,160
process did not read that memory access

304
00:10:32,160 --> 00:10:35,519
however if the reload step takes a short

305
00:10:35,519 --> 00:10:37,279
amount of time this means that the

306
00:10:37,279 --> 00:10:38,399
victims process

307
00:10:38,399 --> 00:10:40,720
actually read that memory access and the

308
00:10:40,720 --> 00:10:42,000
adversary can

309
00:10:42,000 --> 00:10:43,680
use this information to distinguish

310
00:10:43,680 --> 00:10:45,680
between the two cases

311
00:10:45,680 --> 00:10:48,720
notice however that this attack is not

312
00:10:48,720 --> 00:10:49,760
deterministic

313
00:10:49,760 --> 00:10:50,880
in the sense that there could be

314
00:10:50,880 --> 00:10:53,839
overlaps between the memory access and

315
00:10:53,839 --> 00:10:55,279
the reload part

316
00:10:55,279 --> 00:10:58,480
or some other cases in which it could be

317
00:10:58,480 --> 00:10:59,920
confusing for the attacker to

318
00:10:59,920 --> 00:11:03,200
distinguish between the two cases

319
00:11:03,200 --> 00:11:04,880
that's why the attacker here is not

320
00:11:04,880 --> 00:11:07,120
assumed to obtain a

321
00:11:07,120 --> 00:11:10,560
100 success probability but the attacker

322
00:11:10,560 --> 00:11:11,920
will try to choose

323
00:11:11,920 --> 00:11:14,160
parameters that are that maximize the

324
00:11:14,160 --> 00:11:15,360
success probability

325
00:11:15,360 --> 00:11:17,760
and we actually achieve over 99

326
00:11:17,760 --> 00:11:18,560
probability

327
00:11:18,560 --> 00:11:21,279
in our cases

328
00:11:22,640 --> 00:11:24,399
when implementing scalar multiplication

329
00:11:24,399 --> 00:11:25,920
in constant time the montgomery ladder

330
00:11:25,920 --> 00:11:28,399
algorithm is a prime candidate it takes

331
00:11:28,399 --> 00:11:30,000
a point p osps

332
00:11:30,000 --> 00:11:32,720
input defined by a pair of affine

333
00:11:32,720 --> 00:11:34,160
coordinates x and y

334
00:11:34,160 --> 00:11:36,720
and the bit pattern of the nodes k as

335
00:11:36,720 --> 00:11:37,760
additional input

336
00:11:37,760 --> 00:11:39,600
and it computes this kilo multiplication

337
00:11:39,600 --> 00:11:42,160
of k times p

338
00:11:42,160 --> 00:11:43,680
it works by initializing two

339
00:11:43,680 --> 00:11:46,240
accumulators r0 and r1

340
00:11:46,240 --> 00:11:49,200
that are evaluated using the group law

341
00:11:49,200 --> 00:11:50,959
then it scans

342
00:11:50,959 --> 00:11:53,120
the bits of the scalar from left to

343
00:11:53,120 --> 00:11:54,399
right and

344
00:11:54,399 --> 00:11:56,800
performs some group law operations

345
00:11:56,800 --> 00:11:58,639
depending on the key bit

346
00:11:58,639 --> 00:12:02,000
this algorithm benefits constant time

347
00:12:02,000 --> 00:12:03,680
implementations because no matter

348
00:12:03,680 --> 00:12:05,519
the value of the key bit the same number

349
00:12:05,519 --> 00:12:07,120
of group operations

350
00:12:07,120 --> 00:12:10,320
is called notice however

351
00:12:10,320 --> 00:12:13,200
that for a constant time implementation

352
00:12:13,200 --> 00:12:13,760
to be

353
00:12:13,760 --> 00:12:15,839
performed we need to be careful about

354
00:12:15,839 --> 00:12:17,440
the order in which the

355
00:12:17,440 --> 00:12:21,920
points are input and our output in this

356
00:12:21,920 --> 00:12:24,480
instantiations are or disinvocations of

357
00:12:24,480 --> 00:12:27,120
the group law

358
00:12:27,200 --> 00:12:30,000
another problem with this attack as it's

359
00:12:30,000 --> 00:12:31,440
presented here is the number of

360
00:12:31,440 --> 00:12:32,959
durations of the loop

361
00:12:32,959 --> 00:12:35,680
that is that vary with the magnitude of

362
00:12:35,680 --> 00:12:36,240
k

363
00:12:36,240 --> 00:12:39,360
so we need to find a way to fix this

364
00:12:39,360 --> 00:12:42,480
number of iterations as well

365
00:12:42,480 --> 00:12:45,360
so a more realistic version of or a more

366
00:12:45,360 --> 00:12:48,240
protected version of this implementation

367
00:12:48,240 --> 00:12:51,760
can be seen in this slide first of all

368
00:12:51,760 --> 00:12:55,360
before the scalar k is used a multiple

369
00:12:55,360 --> 00:12:56,000
of the

370
00:12:56,000 --> 00:12:58,800
group order is added to produce a

371
00:12:58,800 --> 00:12:59,920
related scalar k

372
00:12:59,920 --> 00:13:02,480
prime that has fixed length which allows

373
00:13:02,480 --> 00:13:03,600
us to fix

374
00:13:03,600 --> 00:13:05,680
the number of iterations of the loop as

375
00:13:05,680 --> 00:13:06,720
well

376
00:13:06,720 --> 00:13:09,839
what's interesting here is that

377
00:13:09,839 --> 00:13:12,240
the way we add multiples of the group

378
00:13:12,240 --> 00:13:14,399
order preserves the most significant bit

379
00:13:14,399 --> 00:13:14,880
of k

380
00:13:14,880 --> 00:13:16,720
in the second most significant bit of k

381
00:13:16,720 --> 00:13:19,040
prime

382
00:13:19,200 --> 00:13:21,200
also we need to be careful about the

383
00:13:21,200 --> 00:13:22,560
branches inside the loop

384
00:13:22,560 --> 00:13:24,320
because there could be branch prediction

385
00:13:24,320 --> 00:13:26,800
or other marker architecture features

386
00:13:26,800 --> 00:13:28,399
that leak information about the branch

387
00:13:28,399 --> 00:13:30,480
being taken or not

388
00:13:30,480 --> 00:13:32,320
so actually we can replace the branches

389
00:13:32,320 --> 00:13:33,839
with a conditional swap

390
00:13:33,839 --> 00:13:36,639
operation that will swap r0 and r1

391
00:13:36,639 --> 00:13:37,200
without

392
00:13:37,200 --> 00:13:40,399
branches depending on the bit of k prime

393
00:13:40,399 --> 00:13:42,160
being processed in this iteration of the

394
00:13:42,160 --> 00:13:44,399
loop

395
00:13:44,480 --> 00:13:46,320
typically this conditional swap

396
00:13:46,320 --> 00:13:48,240
operation is performed in assembly to

397
00:13:48,240 --> 00:13:51,040
prevent interference from the compiler

398
00:13:51,040 --> 00:13:53,360
now what remains for this implementation

399
00:13:53,360 --> 00:13:55,120
to be constant time is a careful

400
00:13:55,120 --> 00:13:58,320
implementation of the group law

401
00:13:58,320 --> 00:14:00,240
ladder leak is a vulnerability exactly

402
00:14:00,240 --> 00:14:03,199
on that part of the algorithm

403
00:14:03,199 --> 00:14:06,160
so and if you consider for example that

404
00:14:06,160 --> 00:14:07,600
r0

405
00:14:07,600 --> 00:14:09,680
takes points p in a fine coordinates and

406
00:14:09,680 --> 00:14:11,279
r1 computes

407
00:14:11,279 --> 00:14:13,760
two times p in projective coordinates

408
00:14:13,760 --> 00:14:16,240
there is a source of leakage on the

409
00:14:16,240 --> 00:14:18,000
first iteration of the loop if the group

410
00:14:18,000 --> 00:14:20,079
law implementation is not careful

411
00:14:20,079 --> 00:14:22,399
this is what actually inspires the logo

412
00:14:22,399 --> 00:14:23,360
we assigned

413
00:14:23,360 --> 00:14:26,800
to this vulnerability for example

414
00:14:26,800 --> 00:14:29,360
if the value r1 here can be

415
00:14:29,360 --> 00:14:32,000
distinguished by an attacker as being

416
00:14:32,000 --> 00:14:34,160
stored in a fine coordinates this leaks

417
00:14:34,160 --> 00:14:35,519
information about the points being

418
00:14:35,519 --> 00:14:37,120
swapped or not which further leaks

419
00:14:37,120 --> 00:14:38,240
information about

420
00:14:38,240 --> 00:14:40,800
a bit of the scalar the same observation

421
00:14:40,800 --> 00:14:41,680
applies

422
00:14:41,680 --> 00:14:43,839
to the point edition here that might

423
00:14:43,839 --> 00:14:46,079
take r1 in either projective or fine

424
00:14:46,079 --> 00:14:47,760
coordinates

425
00:14:47,760 --> 00:14:50,240
if the attacker is able to observe these

426
00:14:50,240 --> 00:14:51,440
differences on the first

427
00:14:51,440 --> 00:14:54,399
iteration of the loop it can actually

428
00:14:54,399 --> 00:14:55,120
split

429
00:14:55,120 --> 00:14:58,000
a large number of signatures in two sets

430
00:14:58,000 --> 00:14:59,040
which are

431
00:14:59,040 --> 00:15:01,040
from the attacker's perspective biased

432
00:15:01,040 --> 00:15:03,199
because they shared the same topic

433
00:15:03,199 --> 00:15:06,800
in the scalar or in the gnomes

434
00:15:08,399 --> 00:15:10,480
our experimental setup involved two

435
00:15:10,480 --> 00:15:12,880
broadwell cpus running at different

436
00:15:12,880 --> 00:15:16,160
of clock frequencies but both with turbo

437
00:15:16,160 --> 00:15:18,079
boost disabled for reducing noise in the

438
00:15:18,079 --> 00:15:19,519
measurements

439
00:15:19,519 --> 00:15:21,519
the binaries were executed in userland

440
00:15:21,519 --> 00:15:23,760
runtime without requiring any privileges

441
00:15:23,760 --> 00:15:25,839
and openssl was built using the default

442
00:15:25,839 --> 00:15:26,880
configuration

443
00:15:26,880 --> 00:15:29,759
with debugging symbols enabled for a

444
00:15:29,759 --> 00:15:32,480
slightly more convenient attack

445
00:15:32,480 --> 00:15:35,279
in terms of tooling we used the fr trace

446
00:15:35,279 --> 00:15:37,279
binary from domestic sidechain analysis

447
00:15:37,279 --> 00:15:38,320
toolkit

448
00:15:38,320 --> 00:15:40,240
which allows us to run flush and reload

449
00:15:40,240 --> 00:15:42,720
attacks we configured the slot to be

450
00:15:42,720 --> 00:15:44,959
5000 cycles which was enough for high

451
00:15:44,959 --> 00:15:46,079
precision

452
00:15:46,079 --> 00:15:48,880
we also used the other idle cores in our

453
00:15:48,880 --> 00:15:50,880
platforms to perform a performance

454
00:15:50,880 --> 00:15:52,079
degradation

455
00:15:52,079 --> 00:15:54,079
attack in which they evict code from

456
00:15:54,079 --> 00:15:55,839
cache to penalize performance

457
00:15:55,839 --> 00:15:58,320
and amplify timing differences between

458
00:15:58,320 --> 00:16:00,720
um these different cases we observed

459
00:16:00,720 --> 00:16:03,680
on the previous slide so let's

460
00:16:03,680 --> 00:16:04,959
illustrate

461
00:16:04,959 --> 00:16:07,519
this attack by examining how openssl

462
00:16:07,519 --> 00:16:10,000
implements arithmetic on prime curves

463
00:16:10,000 --> 00:16:12,320
in this particular case the adverse area

464
00:16:12,320 --> 00:16:14,560
will try to find out if point r1

465
00:16:14,560 --> 00:16:16,079
inside the first iteration of the

466
00:16:16,079 --> 00:16:18,240
montgomery ladder is stored in a fine

467
00:16:18,240 --> 00:16:18,880
coordinates

468
00:16:18,880 --> 00:16:21,279
which leaks in from during the point

469
00:16:21,279 --> 00:16:22,079
doubling

470
00:16:22,079 --> 00:16:24,079
operation which leaks information about

471
00:16:24,079 --> 00:16:25,519
a bit of the

472
00:16:25,519 --> 00:16:28,639
scalar openssl um

473
00:16:28,639 --> 00:16:30,639
actually optimizes for the case when

474
00:16:30,639 --> 00:16:32,560
point r1 is in a fine coordinates

475
00:16:32,560 --> 00:16:36,160
by performing just a buffer copy when

476
00:16:36,160 --> 00:16:37,040
the coordinate c

477
00:16:37,040 --> 00:16:39,040
is one otherwise it computes a full

478
00:16:39,040 --> 00:16:40,160
field multiplication

479
00:16:40,160 --> 00:16:44,240
using the coordinates so the attacker

480
00:16:44,240 --> 00:16:46,720
starts two probes on two different parts

481
00:16:46,720 --> 00:16:48,240
of the code and measure

482
00:16:48,240 --> 00:16:50,240
measures the time it takes for reaching

483
00:16:50,240 --> 00:16:52,160
each of these probes

484
00:16:52,160 --> 00:16:54,800
and by measuring the time from the first

485
00:16:54,800 --> 00:16:56,800
to the second probe it tries to infer

486
00:16:56,800 --> 00:16:58,480
what type of computation happened

487
00:16:58,480 --> 00:17:02,320
in between observe that the performance

488
00:17:02,320 --> 00:17:03,199
difference between

489
00:17:03,199 --> 00:17:05,199
this line and this line is not very high

490
00:17:05,199 --> 00:17:06,799
but actually a performance degradation

491
00:17:06,799 --> 00:17:08,319
attack can amplify the difference to

492
00:17:08,319 --> 00:17:09,359
around

493
00:17:09,359 --> 00:17:12,319
15 000 cycles which corresponds to three

494
00:17:12,319 --> 00:17:13,679
slots

495
00:17:13,679 --> 00:17:15,760
so as a result the attacker is able to

496
00:17:15,760 --> 00:17:17,599
mount a flush and reload attack that

497
00:17:17,599 --> 00:17:19,839
detects if pn copy is called

498
00:17:19,839 --> 00:17:21,599
which means that the z coordinate of the

499
00:17:21,599 --> 00:17:23,280
point is one which means that the point

500
00:17:23,280 --> 00:17:24,640
is in a fine coordinates

501
00:17:24,640 --> 00:17:27,439
which leaks a bit of the scalar and this

502
00:17:27,439 --> 00:17:29,360
in our particular case this was possible

503
00:17:29,360 --> 00:17:30,000
with

504
00:17:30,000 --> 00:17:33,440
larger than 99 precision

505
00:17:33,440 --> 00:17:36,320
let's take a look at the memory traces

506
00:17:36,320 --> 00:17:37,760
for illustration

507
00:17:37,760 --> 00:17:40,240
so in these graphs the y-axis has the

508
00:17:40,240 --> 00:17:42,720
excess memory access time in cycles

509
00:17:42,720 --> 00:17:45,120
and um the threshold we use for a cache

510
00:17:45,120 --> 00:17:46,080
hit was

511
00:17:46,080 --> 00:17:48,320
a hundred cycles so anything below the

512
00:17:48,320 --> 00:17:51,760
red line is considered to be a cache hit

513
00:17:51,760 --> 00:17:53,600
so the adversary monitors the scalar

514
00:17:53,600 --> 00:17:55,840
multiplication and he observes two point

515
00:17:55,840 --> 00:17:58,080
doubly xenon coordinates

516
00:17:58,080 --> 00:17:59,280
in the case that the second most

517
00:17:59,280 --> 00:18:01,360
significant bit is zero the first one is

518
00:18:01,360 --> 00:18:03,120
for initializing the accumulator

519
00:18:03,120 --> 00:18:05,919
r1 outside of the loop the second one is

520
00:18:05,919 --> 00:18:06,880
related to

521
00:18:06,880 --> 00:18:08,559
the first point doubling in the loop

522
00:18:08,559 --> 00:18:09,919
when r1 is

523
00:18:09,919 --> 00:18:15,120
still in a fine coordinates

524
00:18:15,120 --> 00:18:17,919
observe that uh in this case here the

525
00:18:17,919 --> 00:18:19,679
time it takes for computing a point

526
00:18:19,679 --> 00:18:20,400
doubling

527
00:18:20,400 --> 00:18:23,120
is basically dominated by the call to bn

528
00:18:23,120 --> 00:18:23,679
copy

529
00:18:23,679 --> 00:18:25,520
so we see a difference of three time

530
00:18:25,520 --> 00:18:27,919
slots uh in this

531
00:18:27,919 --> 00:18:30,240
trace here and the same pattern cannot

532
00:18:30,240 --> 00:18:31,360
be observed

533
00:18:31,360 --> 00:18:34,320
on the case when the second most simple

534
00:18:34,320 --> 00:18:34,640
bit

535
00:18:34,640 --> 00:18:38,000
of this killer is one because no

536
00:18:38,000 --> 00:18:40,640
doublings of enough coordinates were

537
00:18:40,640 --> 00:18:44,000
performed inside the main loop

538
00:18:44,559 --> 00:18:46,799
we can also take a look at how the same

539
00:18:46,799 --> 00:18:48,480
a similar attack can be mounted against

540
00:18:48,480 --> 00:18:50,720
binary curves so now the attacker

541
00:18:50,720 --> 00:18:53,760
tries to detect if point r1 is

542
00:18:53,760 --> 00:18:55,520
represented in projective coordinates

543
00:18:55,520 --> 00:18:57,200
during point addition

544
00:18:57,200 --> 00:18:59,120
the formula for point addition starts by

545
00:18:59,120 --> 00:19:00,880
multiplying the x coordinate of one

546
00:19:00,880 --> 00:19:02,640
accumulator by the z coordinate of the

547
00:19:02,640 --> 00:19:03,919
other

548
00:19:03,919 --> 00:19:06,400
if r1 is in projective coordinates this

549
00:19:06,400 --> 00:19:08,240
means that the z2 value here will be

550
00:19:08,240 --> 00:19:09,120
non-trivial

551
00:19:09,120 --> 00:19:10,799
and this field multiplication will be

552
00:19:10,799 --> 00:19:12,640
full so it will be more expensive than

553
00:19:12,640 --> 00:19:13,679
the case when

554
00:19:13,679 --> 00:19:16,880
z2 is trivial and has value one

555
00:19:16,880 --> 00:19:19,440
so the adversary will try to monitor the

556
00:19:19,440 --> 00:19:19,919
time

557
00:19:19,919 --> 00:19:21,600
between these two consecutive field

558
00:19:21,600 --> 00:19:23,919
multiplications to figure out if this

559
00:19:23,919 --> 00:19:26,880
value here is non-trivial

560
00:19:26,880 --> 00:19:28,799
again the timing difference at first is

561
00:19:28,799 --> 00:19:30,400
not very large but the performance

562
00:19:30,400 --> 00:19:32,240
degradation can amplify the difference

563
00:19:32,240 --> 00:19:33,840
to 100 000 cycles

564
00:19:33,840 --> 00:19:35,919
corresponding to 20 slots of flush and

565
00:19:35,919 --> 00:19:36,960
reload attack

566
00:19:36,960 --> 00:19:38,720
which allows the attacker to detect if

567
00:19:38,720 --> 00:19:41,039
the z2 value here is trivial with larger

568
00:19:41,039 --> 00:19:42,160
than 99

569
00:19:42,160 --> 00:19:46,000
precision so again the memory traces

570
00:19:46,000 --> 00:19:49,280
illustrate the attack so um

571
00:19:49,280 --> 00:19:52,080
we can observe that when the second most

572
00:19:52,080 --> 00:19:53,600
significant bit is one

573
00:19:53,600 --> 00:19:55,200
the first field multiplication will take

574
00:19:55,200 --> 00:19:56,559
a long time so the second field

575
00:19:56,559 --> 00:19:58,400
multiplication only starts

576
00:19:58,400 --> 00:20:02,400
20 slots later this pattern is not

577
00:20:02,400 --> 00:20:04,080
observable when the second most

578
00:20:04,080 --> 00:20:06,080
synthetic bit of the scalar is zero

579
00:20:06,080 --> 00:20:08,880
and the first field multiplication is

580
00:20:08,880 --> 00:20:09,520
fast

581
00:20:09,520 --> 00:20:11,600
and finishes quickly and is then

582
00:20:11,600 --> 00:20:12,720
followed by the second field

583
00:20:12,720 --> 00:20:13,760
multiplication

584
00:20:13,760 --> 00:20:17,280
because the z coordinate of the

585
00:20:17,280 --> 00:20:19,679
second input to point addition was 1

586
00:20:19,679 --> 00:20:20,880
which led to a faster field

587
00:20:20,880 --> 00:20:23,600
multiplication

588
00:20:24,000 --> 00:20:25,600
there are many software counter measures

589
00:20:25,600 --> 00:20:27,520
that can be used to protect

590
00:20:27,520 --> 00:20:29,360
implementations against this attack

591
00:20:29,360 --> 00:20:31,200
we list here at least three possible

592
00:20:31,200 --> 00:20:34,159
fixes the first and most natural one is

593
00:20:34,159 --> 00:20:35,679
randomizing the z coordinates at the

594
00:20:35,679 --> 00:20:37,919
beginning of scalar multiplications

595
00:20:37,919 --> 00:20:39,919
such that there are no trivial values

596
00:20:39,919 --> 00:20:41,600
for z being operated inside

597
00:20:41,600 --> 00:20:44,400
the main loop second one is implementing

598
00:20:44,400 --> 00:20:45,919
the group law in constant time for

599
00:20:45,919 --> 00:20:48,159
example using complete edition formulas

600
00:20:48,159 --> 00:20:50,080
without branches or corner cases but

601
00:20:50,080 --> 00:20:51,200
this imposes

602
00:20:51,200 --> 00:20:53,919
a performance penalty the third

603
00:20:53,919 --> 00:20:55,280
possibility is implementing the

604
00:20:55,280 --> 00:20:56,559
montgomery ladder of

605
00:20:56,559 --> 00:20:59,039
over cos the arithmetic to not handle

606
00:20:59,039 --> 00:21:01,360
z-coordinates directly

607
00:21:01,360 --> 00:21:03,200
we reported our vulnerabilities to open

608
00:21:03,200 --> 00:21:05,600
ssl in december last year and they were

609
00:21:05,600 --> 00:21:07,440
ultimately fixed in april

610
00:21:07,440 --> 00:21:09,039
this year with the first country

611
00:21:09,039 --> 00:21:11,840
measured applied

612
00:21:12,320 --> 00:21:14,159
the main takeaways of this part of the

613
00:21:14,159 --> 00:21:16,159
talk are that securely implementing

614
00:21:16,159 --> 00:21:17,760
cryptographic algorithms that are

615
00:21:17,760 --> 00:21:18,400
brittle

616
00:21:18,400 --> 00:21:20,880
is still very hard many things can go

617
00:21:20,880 --> 00:21:21,520
wrong

618
00:21:21,520 --> 00:21:24,720
in very subtle ways in particular

619
00:21:24,720 --> 00:21:26,559
it's important to not underestimate

620
00:21:26,559 --> 00:21:28,320
small timing leakage coming from

621
00:21:28,320 --> 00:21:30,240
insecure implementations because an

622
00:21:30,240 --> 00:21:32,159
attacker may be able to find a way to

623
00:21:32,159 --> 00:21:33,840
exploit those and recover

624
00:21:33,840 --> 00:21:36,799
a long-term private key in a more

625
00:21:36,799 --> 00:21:38,240
operational

626
00:21:38,240 --> 00:21:40,880
manner we recommend everyone to upgrade

627
00:21:40,880 --> 00:21:44,960
to openssl version 1.1.1 or version 3.0

628
00:21:44,960 --> 00:21:46,240
when it's available

629
00:21:46,240 --> 00:21:48,960
as soon as possible the development

630
00:21:48,960 --> 00:21:51,280
community behind openssl has made

631
00:21:51,280 --> 00:21:53,440
a wonderful effort to improve the code

632
00:21:53,440 --> 00:21:55,360
base and its implementation security

633
00:21:55,360 --> 00:21:56,400
since heartbleed

634
00:21:56,400 --> 00:21:58,320
and should we should all benefit from

635
00:21:58,320 --> 00:22:00,480
that effort

636
00:22:00,480 --> 00:22:03,600
now akira continues the talk by

637
00:22:03,600 --> 00:22:06,080
explaining how the private keys can be

638
00:22:06,080 --> 00:22:08,240
computed from biased signatures

639
00:22:08,240 --> 00:22:10,320
using a solution of the hidden number

640
00:22:10,320 --> 00:22:11,520
problem

641
00:22:11,520 --> 00:22:14,080
thanks diego so hello everyone my name

642
00:22:14,080 --> 00:22:15,200
is akira takashi

643
00:22:15,200 --> 00:22:17,440
i'm currently a phd student at austin

644
00:22:17,440 --> 00:22:18,880
university in denmark

645
00:22:18,880 --> 00:22:20,799
so in this part i'm going to discuss how

646
00:22:20,799 --> 00:22:23,760
to exploit the ecdsnos leakage that we

647
00:22:23,760 --> 00:22:24,320
obtain

648
00:22:24,320 --> 00:22:25,840
from ladder league vulnerable

649
00:22:25,840 --> 00:22:27,919
implementations

650
00:22:27,919 --> 00:22:30,240
so here's the overview so the goal of

651
00:22:30,240 --> 00:22:32,559
the second part is to recover the ecdsa

652
00:22:32,559 --> 00:22:33,760
secret signing key

653
00:22:33,760 --> 00:22:35,760
by solving the so-called hidden number

654
00:22:35,760 --> 00:22:38,640
problem which i'm going to define soon

655
00:22:38,640 --> 00:22:40,640
so our attack essentially follows

656
00:22:40,640 --> 00:22:42,320
fourier analysis based attack

657
00:22:42,320 --> 00:22:44,960
which was originally divided developed

658
00:22:44,960 --> 00:22:46,640
by blah blah

659
00:22:46,640 --> 00:22:48,799
so this attack method allows us to

660
00:22:48,799 --> 00:22:50,240
recover the secret key

661
00:22:50,240 --> 00:22:52,000
using only one bit of knowledge

662
00:22:52,000 --> 00:22:54,240
information per signature

663
00:22:54,240 --> 00:22:56,640
also in order to exploit the practical

664
00:22:56,640 --> 00:22:58,000
leakage information

665
00:22:58,000 --> 00:23:00,640
our analysis also considers side channel

666
00:23:00,640 --> 00:23:03,520
attackers miss detection of those speeds

667
00:23:03,520 --> 00:23:05,520
i want to remark that the techniques

668
00:23:05,520 --> 00:23:06,640
that i present here

669
00:23:06,640 --> 00:23:09,360
in principle applied to other sources of

670
00:23:09,360 --> 00:23:11,120
bias or leakage

671
00:23:11,120 --> 00:23:12,880
that are independent of ladder leak

672
00:23:12,880 --> 00:23:15,679
vulnerability

673
00:23:15,760 --> 00:23:17,280
so let's define the hidden number

674
00:23:17,280 --> 00:23:19,840
problem so in the hidden number problem

675
00:23:19,840 --> 00:23:21,760
the attacker is given the pairs

676
00:23:21,760 --> 00:23:24,880
h and z that satisfy this modular

677
00:23:24,880 --> 00:23:26,159
equation

678
00:23:26,159 --> 00:23:28,559
also the attacker is given the most

679
00:23:28,559 --> 00:23:30,159
significant bit information

680
00:23:30,159 --> 00:23:32,880
of a node's k and then the goal is to

681
00:23:32,880 --> 00:23:34,159
recover the secret key

682
00:23:34,159 --> 00:23:37,200
sk so here even though the equation

683
00:23:37,200 --> 00:23:39,840
doesn't look like a ecdsa signature

684
00:23:39,840 --> 00:23:41,679
actually once you obtain a ucdc

685
00:23:41,679 --> 00:23:43,360
signature you can easily

686
00:23:43,360 --> 00:23:45,760
convert the signature into an instance

687
00:23:45,760 --> 00:23:47,120
of the hidden number problem

688
00:23:47,120 --> 00:23:50,799
like this so why do we study the hidden

689
00:23:50,799 --> 00:23:52,720
number problem

690
00:23:52,720 --> 00:23:54,240
so actually the hidden number problem

691
00:23:54,240 --> 00:23:56,799
has been around for more than 20 years

692
00:23:56,799 --> 00:23:58,960
and the fundamental attack method was

693
00:23:58,960 --> 00:24:00,320
already developed in

694
00:24:00,320 --> 00:24:03,279
late 90s the first one is called lattice

695
00:24:03,279 --> 00:24:04,320
attack

696
00:24:04,320 --> 00:24:07,679
originally proposed by how great graham

697
00:24:07,679 --> 00:24:08,720
and smart

698
00:24:08,720 --> 00:24:10,960
and soon after that blah blah announced

699
00:24:10,960 --> 00:24:12,880
a completely different attack method

700
00:24:12,880 --> 00:24:15,919
called fourier analysis base attack

701
00:24:15,919 --> 00:24:18,799
which we studied in detail in this work

702
00:24:18,799 --> 00:24:20,799
so since the proposal of this attack

703
00:24:20,799 --> 00:24:21,520
method

704
00:24:21,520 --> 00:24:23,760
there have been a bunch of real-world

705
00:24:23,760 --> 00:24:25,039
vulnerabilities

706
00:24:25,039 --> 00:24:28,000
that rely on the hidden number problem

707
00:24:28,000 --> 00:24:28,960
for example

708
00:24:28,960 --> 00:24:31,039
even looking at the last few years we

709
00:24:31,039 --> 00:24:32,480
have seen many

710
00:24:32,480 --> 00:24:35,520
vulnerabilities including cash quote bot

711
00:24:35,520 --> 00:24:36,080
smash

712
00:24:36,080 --> 00:24:38,960
return of hidden number problem tpm fail

713
00:24:38,960 --> 00:24:40,080
minerva

714
00:24:40,080 --> 00:24:42,799
the java attack and raccoon attack all

715
00:24:42,799 --> 00:24:44,000
these vulnerabilities

716
00:24:44,000 --> 00:24:46,159
essentially rely on the same hidden

717
00:24:46,159 --> 00:24:47,120
number problem

718
00:24:47,120 --> 00:24:48,960
so concretely by solving the hidden

719
00:24:48,960 --> 00:24:51,679
number problem the attacker can

720
00:24:51,679 --> 00:24:54,799
steal the secret ecdsa key or

721
00:24:54,799 --> 00:24:56,320
in the case of raccoon attack the

722
00:24:56,320 --> 00:24:58,320
attacker can still

723
00:24:58,320 --> 00:25:02,000
share a dv helmet key shared secret key

724
00:25:02,000 --> 00:25:04,240
of the diffie-hellman key exchange

725
00:25:04,240 --> 00:25:06,080
so this is why it's very important to

726
00:25:06,080 --> 00:25:08,000
study the hidden number problem

727
00:25:08,000 --> 00:25:10,480
and to evaluate the concrete attack cost

728
00:25:10,480 --> 00:25:13,200
in the hidden number problem

729
00:25:13,200 --> 00:25:15,360
so as i mentioned there have been

730
00:25:15,360 --> 00:25:17,520
essentially two different approaches

731
00:25:17,520 --> 00:25:19,600
to the hidden number problem the first

732
00:25:19,600 --> 00:25:21,200
one is called lattice attack which is

733
00:25:21,200 --> 00:25:22,400
more famous

734
00:25:22,400 --> 00:25:24,480
so the lattice attack is known to work

735
00:25:24,480 --> 00:25:26,159
very efficiently

736
00:25:26,159 --> 00:25:28,559
if you have relatively large amount of

737
00:25:28,559 --> 00:25:30,799
bias or leakage information

738
00:25:30,799 --> 00:25:32,720
however if the amount of leakage

739
00:25:32,720 --> 00:25:34,640
information is quite small

740
00:25:34,640 --> 00:25:37,600
like one bit then essentially a lattice

741
00:25:37,600 --> 00:25:39,200
attack doesn't work

742
00:25:39,200 --> 00:25:41,919
so in such a case the other approach

743
00:25:41,919 --> 00:25:43,279
called fully analysis

744
00:25:43,279 --> 00:25:45,679
is known to work more effectively

745
00:25:45,679 --> 00:25:47,520
however the measure of bottleneck of

746
00:25:47,520 --> 00:25:48,720
this approach is that

747
00:25:48,720 --> 00:25:52,640
it requires too much data complexity

748
00:25:52,640 --> 00:25:56,000
so of course the main natural question

749
00:25:56,000 --> 00:25:58,159
is that can we reduce the data

750
00:25:58,159 --> 00:25:59,200
complexity of

751
00:25:59,200 --> 00:26:02,400
fourier analysis based attack also we

752
00:26:02,400 --> 00:26:04,799
were interested in how far we can go

753
00:26:04,799 --> 00:26:06,960
so more concretely can we attack even

754
00:26:06,960 --> 00:26:08,960
less than one bit of noise leakage

755
00:26:08,960 --> 00:26:10,480
so here less than one bit of nose

756
00:26:10,480 --> 00:26:12,480
leakage means that the most significant

757
00:26:12,480 --> 00:26:13,520
bit information

758
00:26:13,520 --> 00:26:15,440
is only leaked with probability less

759
00:26:15,440 --> 00:26:16,960
than one

760
00:26:16,960 --> 00:26:19,360
and finally we wanted to know whether

761
00:26:19,360 --> 00:26:20,159
there is such a

762
00:26:20,159 --> 00:26:23,279
small leakage coming from practical

763
00:26:23,279 --> 00:26:26,480
ecdsa implementations in this work we

764
00:26:26,480 --> 00:26:26,880
answer

765
00:26:26,880 --> 00:26:30,400
these questions in the positive

766
00:26:30,559 --> 00:26:33,039
so as a result we managed to set some

767
00:26:33,039 --> 00:26:34,640
new records

768
00:26:34,640 --> 00:26:36,320
of the solutions to the hidden number

769
00:26:36,320 --> 00:26:38,559
problem here's a comparison with the

770
00:26:38,559 --> 00:26:39,840
previous work

771
00:26:39,840 --> 00:26:41,919
so as you can see in this table we

772
00:26:41,919 --> 00:26:44,320
essentially solved all these four cases

773
00:26:44,320 --> 00:26:47,679
in the case of 160 bit hnp compared to

774
00:26:47,679 --> 00:26:49,679
the compared to the previous method

775
00:26:49,679 --> 00:26:52,960
our attack required fewer fewer input

776
00:26:52,960 --> 00:26:54,320
signatures

777
00:26:54,320 --> 00:26:56,559
to complete the entire secret key

778
00:26:56,559 --> 00:26:58,320
recovery

779
00:26:58,320 --> 00:27:00,400
also to the best of our knowledge there

780
00:27:00,400 --> 00:27:02,159
have been no attack records

781
00:27:02,159 --> 00:27:05,200
against a 192 bit agent b

782
00:27:05,200 --> 00:27:09,760
so here we set the two new records

783
00:27:10,080 --> 00:27:11,760
so now i'm going to give you a technical

784
00:27:11,760 --> 00:27:13,600
overview of brian baja's

785
00:27:13,600 --> 00:27:16,240
fully analysis based attack so the

786
00:27:16,240 --> 00:27:18,320
attack consists of two phases

787
00:27:18,320 --> 00:27:21,039
the first phases is to quantify the bias

788
00:27:21,039 --> 00:27:22,559
of nodes k

789
00:27:22,559 --> 00:27:25,120
so here we define some bias function

790
00:27:25,120 --> 00:27:25,760
such that

791
00:27:25,760 --> 00:27:28,320
it outputs something close to zero if

792
00:27:28,320 --> 00:27:29,039
the node's k

793
00:27:29,039 --> 00:27:31,120
is uniform in integers modulus of the

794
00:27:31,120 --> 00:27:32,559
group order

795
00:27:32,559 --> 00:27:34,240
on the other hand this bias function

796
00:27:34,240 --> 00:27:35,919
should be uh

797
00:27:35,919 --> 00:27:38,320
should be something close to one if k is

798
00:27:38,320 --> 00:27:38,960
biased

799
00:27:38,960 --> 00:27:42,640
in zq so here our first contribution is

800
00:27:42,640 --> 00:27:44,880
that we analyze the behavior of this

801
00:27:44,880 --> 00:27:47,200
of this bias function when the most

802
00:27:47,200 --> 00:27:48,000
significant bit

803
00:27:48,000 --> 00:27:50,799
of k is biased with probability less

804
00:27:50,799 --> 00:27:52,799
than one

805
00:27:52,799 --> 00:27:55,200
then the second step is to find a find

806
00:27:55,200 --> 00:27:56,720
the candidate secret key

807
00:27:56,720 --> 00:27:58,559
which leads to the peak of this bias

808
00:27:58,559 --> 00:28:01,120
function in practice this is carried out

809
00:28:01,120 --> 00:28:02,559
by computing

810
00:28:02,559 --> 00:28:05,760
fast fourier transform also

811
00:28:05,760 --> 00:28:07,919
even though i do not discuss in detail

812
00:28:07,919 --> 00:28:09,679
there's actually a critical intermediate

813
00:28:09,679 --> 00:28:10,240
step

814
00:28:10,240 --> 00:28:13,279
called collision search of integers h so

815
00:28:13,279 --> 00:28:13,600
this

816
00:28:13,600 --> 00:28:16,320
step is important in order to detect the

817
00:28:16,320 --> 00:28:17,279
bias peak

818
00:28:17,279 --> 00:28:19,760
correctly and efficiently and actually

819
00:28:19,760 --> 00:28:21,520
our second contribution is that

820
00:28:21,520 --> 00:28:23,600
we establish the unified time memory

821
00:28:23,600 --> 00:28:24,640
data trade-offs

822
00:28:24,640 --> 00:28:26,720
by applying a well-known algorithm in

823
00:28:26,720 --> 00:28:30,320
the symmetric key a cryptology

824
00:28:30,320 --> 00:28:33,520
so now let's define a bias function so

825
00:28:33,520 --> 00:28:35,360
the bias function can be essentially

826
00:28:35,360 --> 00:28:36,640
defined in the form of

827
00:28:36,640 --> 00:28:40,000
discrete fourier transform so to get the

828
00:28:40,000 --> 00:28:40,720
intuition

829
00:28:40,720 --> 00:28:43,200
it's always better to imagine a complex

830
00:28:43,200 --> 00:28:46,320
plane and a unit circle on it

831
00:28:46,320 --> 00:28:49,200
so for example if the noise k is

832
00:28:49,200 --> 00:28:51,039
uniformly distributed

833
00:28:51,039 --> 00:28:54,399
then we can imagine some corresponding

834
00:28:54,399 --> 00:28:56,080
vectors

835
00:28:56,080 --> 00:28:58,799
to those nodes and those vectors are

836
00:28:58,799 --> 00:29:00,480
uniformly distributed

837
00:29:00,480 --> 00:29:03,360
in the complex plane then if you take

838
00:29:03,360 --> 00:29:04,880
the sum of those vectors

839
00:29:04,880 --> 00:29:07,600
we can expect that the resulting sum is

840
00:29:07,600 --> 00:29:09,440
quite small

841
00:29:09,440 --> 00:29:12,240
on the other hand let's think about the

842
00:29:12,240 --> 00:29:13,440
biased cases

843
00:29:13,440 --> 00:29:15,760
so for example if the most string and

844
00:29:15,760 --> 00:29:17,200
bit of noise k

845
00:29:17,200 --> 00:29:20,320
is zero then we can imagine that

846
00:29:20,320 --> 00:29:23,200
the the those corresponding vectors are

847
00:29:23,200 --> 00:29:24,399
concentrated

848
00:29:24,399 --> 00:29:27,120
in the upper half of the unit circle so

849
00:29:27,120 --> 00:29:27,840
in this case

850
00:29:27,840 --> 00:29:29,440
we can expect that the sum of those

851
00:29:29,440 --> 00:29:31,520
vectors are much larger

852
00:29:31,520 --> 00:29:34,000
so this is how we can quantify the bias

853
00:29:34,000 --> 00:29:34,960
of nodes

854
00:29:34,960 --> 00:29:38,960
and also this is how we detect a bias

855
00:29:38,960 --> 00:29:42,720
whether it is applicable

856
00:29:43,039 --> 00:29:46,000
so in practice we have to consider some

857
00:29:46,000 --> 00:29:47,919
erroneous leakage information

858
00:29:47,919 --> 00:29:50,960
so let's begin with the easiest example

859
00:29:50,960 --> 00:29:53,200
so of course in an ideal case if the

860
00:29:53,200 --> 00:29:54,000
attacker

861
00:29:54,000 --> 00:29:56,240
knows the most most significant bit of

862
00:29:56,240 --> 00:29:58,480
nos k with probability 1

863
00:29:58,480 --> 00:30:00,559
then the attacker can collect the

864
00:30:00,559 --> 00:30:02,480
completely biased signatures

865
00:30:02,480 --> 00:30:05,360
like this however in practice attacker

866
00:30:05,360 --> 00:30:06,159
sometimes

867
00:30:06,159 --> 00:30:09,279
makes mistakes so the traces sometimes

868
00:30:09,279 --> 00:30:13,279
contain errors like this so in this case

869
00:30:13,279 --> 00:30:15,360
uh the erroneous leakage information

870
00:30:15,360 --> 00:30:17,760
affects the bias function

871
00:30:17,760 --> 00:30:21,600
so this is why we we analyze the

872
00:30:21,600 --> 00:30:24,000
behavior of bias function under the

873
00:30:24,000 --> 00:30:24,880
mis-detection

874
00:30:24,880 --> 00:30:27,840
of the non-speeds and more concretely we

875
00:30:27,840 --> 00:30:28,799
can estimate

876
00:30:28,799 --> 00:30:31,440
the absolute value of the bias function

877
00:30:31,440 --> 00:30:34,080
by this form

878
00:30:34,559 --> 00:30:37,440
moreover we gave a detailed trade of

879
00:30:37,440 --> 00:30:38,159
studies

880
00:30:38,159 --> 00:30:41,200
in the complexity of the attack so here

881
00:30:41,200 --> 00:30:43,279
once you fix the curve parameter

882
00:30:43,279 --> 00:30:45,520
and the amount of available leakage

883
00:30:45,520 --> 00:30:46,559
information

884
00:30:46,559 --> 00:30:49,600
you can draw these trade-off graphs so

885
00:30:49,600 --> 00:30:50,320
these

886
00:30:50,320 --> 00:30:53,039
trade-off curves essentially mean that

887
00:30:53,039 --> 00:30:54,480
if you can spend more time on

888
00:30:54,480 --> 00:30:57,600
attack then you require much less input

889
00:30:57,600 --> 00:30:58,320
signatures

890
00:30:58,320 --> 00:31:00,320
to carry to complete the entire key

891
00:31:00,320 --> 00:31:01,840
recovery

892
00:31:01,840 --> 00:31:05,279
and vice versa so

893
00:31:05,279 --> 00:31:07,200
so this is why if the attacker can

894
00:31:07,200 --> 00:31:08,960
carefully choose the point

895
00:31:08,960 --> 00:31:12,320
on this trade of curve then data can can

896
00:31:12,320 --> 00:31:14,480
always find the optimal balance between

897
00:31:14,480 --> 00:31:17,600
time and data complexities

898
00:31:17,600 --> 00:31:19,760
also even though i focused on one bit

899
00:31:19,760 --> 00:31:20,799
leakage case

900
00:31:20,799 --> 00:31:24,399
in the paper we also gave analysis

901
00:31:24,399 --> 00:31:27,600
for even more general two or three bit

902
00:31:27,600 --> 00:31:28,880
leakage cases

903
00:31:28,880 --> 00:31:30,720
and we actually showed that much smaller

904
00:31:30,720 --> 00:31:32,640
amount of signatures are needed

905
00:31:32,640 --> 00:31:36,799
to attack two or three bit leakage cases

906
00:31:37,360 --> 00:31:39,840
and after analysis we implemented the

907
00:31:39,840 --> 00:31:40,880
entire attack

908
00:31:40,880 --> 00:31:44,000
and show that indeed the key recovery

909
00:31:44,000 --> 00:31:45,279
attack works

910
00:31:45,279 --> 00:31:48,799
so in the case of p192 the attack was

911
00:31:48,799 --> 00:31:49,679
made possible

912
00:31:49,679 --> 00:31:53,360
by executing our highly optimized pilot

913
00:31:53,360 --> 00:31:56,559
implementation in aws ec2

914
00:31:56,559 --> 00:31:58,799
and the entire attack completed in a

915
00:31:58,799 --> 00:32:00,960
reasonable amount of time

916
00:32:00,960 --> 00:32:04,320
also in this attack experiment we

917
00:32:04,320 --> 00:32:07,039
confirmed that the attacker even works

918
00:32:07,039 --> 00:32:07,600
under

919
00:32:07,600 --> 00:32:11,039
some errors by using a bit more

920
00:32:11,039 --> 00:32:12,000
signatures

921
00:32:12,000 --> 00:32:15,559
than the non-errored case in the case of

922
00:32:15,559 --> 00:32:18,960
163-bit curve and the attack complexity

923
00:32:18,960 --> 00:32:21,600
was actually much more modest so in

924
00:32:21,600 --> 00:32:22,480
principle

925
00:32:22,480 --> 00:32:24,720
you could imbue execute the entire

926
00:32:24,720 --> 00:32:25,880
attack against

927
00:32:25,880 --> 00:32:30,880
163-bit case in a small laptop

928
00:32:31,279 --> 00:32:33,360
so the main takeaways of the second part

929
00:32:33,360 --> 00:32:34,880
are as follows

930
00:32:34,880 --> 00:32:38,320
so as we show ac dslr nonce is extremely

931
00:32:38,320 --> 00:32:40,960
sensitive and especially even less than

932
00:32:40,960 --> 00:32:42,399
one bit of noise leakage

933
00:32:42,399 --> 00:32:45,679
per signature is exploitable

934
00:32:45,679 --> 00:32:47,200
and even though the hidden number

935
00:32:47,200 --> 00:32:49,519
program is too old

936
00:32:49,519 --> 00:32:51,760
this is still relevant nowadays because

937
00:32:51,760 --> 00:32:53,279
there have been a bunch of other

938
00:32:53,279 --> 00:32:55,039
vulnerabilities discovered by other

939
00:32:55,039 --> 00:32:56,399
people

940
00:32:56,399 --> 00:32:59,120
so we can expect that in the near future

941
00:32:59,120 --> 00:33:00,159
there might be

942
00:33:00,159 --> 00:33:02,880
some other vulnerability that stems from

943
00:33:02,880 --> 00:33:03,600
the nonce

944
00:33:03,600 --> 00:33:07,600
leakage of ect ecdsa

945
00:33:07,679 --> 00:33:10,000
and after the analysis we got multiple

946
00:33:10,000 --> 00:33:12,080
interesting open questions

947
00:33:12,080 --> 00:33:14,720
so of course we want to know whether

948
00:33:14,720 --> 00:33:16,080
it's possible to further

949
00:33:16,080 --> 00:33:19,600
improve time data trade-offs so in our

950
00:33:19,600 --> 00:33:20,399
analysis

951
00:33:20,399 --> 00:33:22,320
even though we managed to attack one bit

952
00:33:22,320 --> 00:33:24,320
leakage still it required

953
00:33:24,320 --> 00:33:27,600
at least millions of signatures so of

954
00:33:27,600 --> 00:33:28,080
course

955
00:33:28,080 --> 00:33:31,120
if you can find more

956
00:33:31,120 --> 00:33:33,360
efficient algorithm that gives better

957
00:33:33,360 --> 00:33:34,640
trade-off curves

958
00:33:34,640 --> 00:33:37,039
then we might be able to reduce further

959
00:33:37,039 --> 00:33:38,960
reduce the input data complexity

960
00:33:38,960 --> 00:33:42,000
of blahimba's attack also we'd like to

961
00:33:42,000 --> 00:33:43,840
know whether there are other social

962
00:33:43,840 --> 00:33:46,559
sources of small leakage that allows an

963
00:33:46,559 --> 00:33:47,760
attacker to learn

964
00:33:47,760 --> 00:33:50,880
2 or 3-bit leakage under some errors

965
00:33:50,880 --> 00:33:53,120
so we expect that in these cases

966
00:33:53,120 --> 00:33:54,559
blackheadpass attack

967
00:33:54,559 --> 00:33:57,760
works very effectively

968
00:33:57,760 --> 00:33:59,200
so thank you very much for your

969
00:33:59,200 --> 00:34:01,360
attention if you have any questions

970
00:34:01,360 --> 00:34:04,159
we are happy to answer also if you are

971
00:34:04,159 --> 00:34:07,440
interested in more details you can find

972
00:34:07,440 --> 00:34:13,359
our paper in this url

