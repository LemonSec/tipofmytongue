1
00:00:00,030 --> 00:00:06,029
good morning everyone the topic today is

2
00:00:03,030 --> 00:00:12,690
how to survive the hardware-assisted

3
00:00:06,029 --> 00:00:17,910
control flow integrity enforcement let's

4
00:00:12,690 --> 00:00:20,970
first introduce ourselves our co-worker

5
00:00:17,910 --> 00:00:24,359
Pinson is unable to come therefore we'll

6
00:00:20,970 --> 00:00:28,169
just introduced him first ping son is a

7
00:00:24,359 --> 00:00:31,650
senior secure researcher he leads McAfee

8
00:00:28,170 --> 00:00:33,989
IPS research team he has extensive

9
00:00:31,650 --> 00:00:37,019
experience in knowledge --is in

10
00:00:33,989 --> 00:00:41,459
operating systems information security

11
00:00:37,020 --> 00:00:45,469
especially in advanced vulnerability

12
00:00:41,460 --> 00:00:48,750
research and exploitation techniques

13
00:00:45,469 --> 00:00:52,190
along with rootkit detection firmware

14
00:00:48,750 --> 00:00:55,260
security and virtualization technologies

15
00:00:52,190 --> 00:00:58,500
ping has been a regular researcher for

16
00:00:55,260 --> 00:01:02,968
many security conferences such as

17
00:00:58,500 --> 00:01:05,820
blackhat and accounts a quest hello I'm

18
00:01:02,969 --> 00:01:08,549
Jenny I am a security researcher of X

19
00:01:05,820 --> 00:01:11,039
future now I mainly focus on

20
00:01:08,549 --> 00:01:13,860
vulnerability research specialized in

21
00:01:11,040 --> 00:01:17,909
the vulnerability a legacy and

22
00:01:13,860 --> 00:01:20,670
exploitation I especially have a focus

23
00:01:17,909 --> 00:01:26,759
on browser vulnerabilities and Windows

24
00:01:20,670 --> 00:01:30,450
platform my name is Zhang Chu I received

25
00:01:26,759 --> 00:01:32,670
my PhD from Duke University currently

26
00:01:30,450 --> 00:01:35,490
I'm the head of the security research

27
00:01:32,670 --> 00:01:40,159
team for McAfee network security

28
00:01:35,490 --> 00:01:40,158
business unit my focus is mainly on

29
00:01:40,460 --> 00:01:47,880
research and innovation for intrusion

30
00:01:43,560 --> 00:01:49,590
prevention my team focus is on the

31
00:01:47,880 --> 00:01:53,280
security of vulnerability research

32
00:01:49,590 --> 00:01:56,430
malware ADP detection and upon a

33
00:01:53,280 --> 00:01:59,369
detection also my team feeds the

34
00:01:56,430 --> 00:02:02,700
security contents into multiple McAfee

35
00:01:59,369 --> 00:02:10,110
products as well as McAfee global threat

36
00:02:02,700 --> 00:02:13,800
intelligence now here is the agenda our

37
00:02:10,110 --> 00:02:17,780
topic is how to survive the hot war

38
00:02:13,800 --> 00:02:21,330
assisted CET the control flow

39
00:02:17,780 --> 00:02:23,670
enforcement technology so we would like

40
00:02:21,330 --> 00:02:27,180
to start from a little bit of history

41
00:02:23,670 --> 00:02:31,049
where we described aha sulfur solution

42
00:02:27,180 --> 00:02:33,420
first for the control flow integrity

43
00:02:31,050 --> 00:02:37,370
enforcement and then based on that we'll

44
00:02:33,420 --> 00:02:40,859
introduce Intel's new feature for that

45
00:02:37,370 --> 00:02:45,330
control flow enforcement technology CET

46
00:02:40,860 --> 00:02:49,040
and then well followed by the Intel

47
00:02:45,330 --> 00:02:52,320
implementation Windows 10 for the CET

48
00:02:49,040 --> 00:02:55,500
after that we'll talk about how to

49
00:02:52,320 --> 00:02:58,109
attack those especially for the control

50
00:02:55,500 --> 00:03:01,620
flow hijacking and arbitrary code

51
00:02:58,110 --> 00:03:05,130
execution Windows 10 with the city

52
00:03:01,620 --> 00:03:11,550
enabled and then we'll conclude and have

53
00:03:05,130 --> 00:03:14,070
the Q&A first of all let's talk about

54
00:03:11,550 --> 00:03:18,770
the software based solution the software

55
00:03:14,070 --> 00:03:18,769
based control flow integrity enforcement

56
00:03:19,400 --> 00:03:25,709
we know if we want to attack the control

57
00:03:22,950 --> 00:03:29,160
flow there are two ways to do it from

58
00:03:25,709 --> 00:03:33,390
the front edge from the front edge one

59
00:03:29,160 --> 00:03:36,770
and any indirect wait if we can control

60
00:03:33,390 --> 00:03:40,799
the target address then we'll be able to

61
00:03:36,770 --> 00:03:43,290
change the call flow so that this call

62
00:03:40,800 --> 00:03:45,720
will go to the direction that we want

63
00:03:43,290 --> 00:03:48,299
and we'll land on the target address

64
00:03:45,720 --> 00:03:52,739
that we provide this is the front edge

65
00:03:48,300 --> 00:03:55,770
and from the back edge obviously when

66
00:03:52,739 --> 00:03:58,739
alcohol returns it will return to the

67
00:03:55,770 --> 00:04:00,959
call the original address that the

68
00:03:58,739 --> 00:04:04,860
return address has been on the data step

69
00:04:00,959 --> 00:04:07,140
but if we have a way to change that so

70
00:04:04,860 --> 00:04:10,019
that when the call returns it will

71
00:04:07,140 --> 00:04:13,140
return to the address that we provided

72
00:04:10,019 --> 00:04:15,360
then pretty much we also hijacked the

73
00:04:13,140 --> 00:04:18,180
control flow to any arbitrary location

74
00:04:15,360 --> 00:04:21,299
we want for the code execution those are

75
00:04:18,180 --> 00:04:23,910
the two ways of doing the control flow

76
00:04:21,298 --> 00:04:27,378
hijacking therefore for the software

77
00:04:23,910 --> 00:04:31,289
approach Microsoft has came up with

78
00:04:27,379 --> 00:04:36,509
two solutions one is called the control

79
00:04:31,289 --> 00:04:40,590
flow guard this is to detect the front

80
00:04:36,509 --> 00:04:44,759
and hijacking the basic idea is as

81
00:04:40,590 --> 00:04:49,039
follows let's look at the program on

82
00:04:44,759 --> 00:04:52,830
this side on this side if we see here

83
00:04:49,039 --> 00:04:54,960
there's a function pointer and then we

84
00:04:52,830 --> 00:05:00,750
assign this function pointer to this

85
00:04:54,960 --> 00:05:03,270
object so in this function bar then we

86
00:05:00,750 --> 00:05:07,319
make the indirect call to the function

87
00:05:03,270 --> 00:05:10,650
pointer that we assigned to this is the

88
00:05:07,319 --> 00:05:13,259
original code but if when the CFG is

89
00:05:10,650 --> 00:05:16,440
enabled then compiler will be able to

90
00:05:13,259 --> 00:05:21,180
add instrumented instructions what it is

91
00:05:16,440 --> 00:05:25,800
added is here the card check icon so

92
00:05:21,180 --> 00:05:28,430
what this does is that for any indirect

93
00:05:25,800 --> 00:05:33,060
call there's a target address and

94
00:05:28,430 --> 00:05:36,419
Microsoft wants to enforce a check for

95
00:05:33,060 --> 00:05:38,460
the validity of that target address what

96
00:05:36,419 --> 00:05:41,698
that means is that when a problem is

97
00:05:38,460 --> 00:05:44,609
being compiled or the valid destinations

98
00:05:41,699 --> 00:05:48,930
of those calling targets are listed so

99
00:05:44,610 --> 00:05:52,259
that there will be a bitmap to simplify

100
00:05:48,930 --> 00:05:55,680
which address is a valid address and

101
00:05:52,259 --> 00:05:58,560
then one that program is loaded and

102
00:05:55,680 --> 00:06:00,719
obviously those are addresses the

103
00:05:58,560 --> 00:06:03,599
virtual address will be mapped so also

104
00:06:00,719 --> 00:06:07,289
then those map app will now become a

105
00:06:03,599 --> 00:06:10,590
valid be map to indicate which are the

106
00:06:07,289 --> 00:06:15,330
valid target addresses so when each core

107
00:06:10,590 --> 00:06:20,270
is actually made here then before that

108
00:06:15,330 --> 00:06:22,830
Microsoft uses this the guard check icon

109
00:06:20,270 --> 00:06:26,219
to check whether or not this court

110
00:06:22,830 --> 00:06:28,680
target is innocent knowing bitmap one

111
00:06:26,219 --> 00:06:34,110
that is successful then this call will

112
00:06:28,680 --> 00:06:37,169
be our in the rec hall will be allowed

113
00:06:34,110 --> 00:06:39,719
to continue otherwise if it's not valid

114
00:06:37,169 --> 00:06:40,529
target then obviously for example if we

115
00:06:39,719 --> 00:06:44,009
are jumping

116
00:06:40,529 --> 00:06:45,869
into arbitrary location then that target

117
00:06:44,009 --> 00:06:48,419
address is not a valid target then

118
00:06:45,869 --> 00:06:53,789
obviously Microsoft will fill this

119
00:06:48,419 --> 00:06:58,229
process so that's the basic idea for the

120
00:06:53,789 --> 00:07:03,359
CFG this is used to address the front

121
00:06:58,229 --> 00:07:05,969
edge control flow hijacking but there

122
00:07:03,359 --> 00:07:08,758
has been multiple ways to bypass this

123
00:07:05,969 --> 00:07:16,729
and then if you guys are interested in

124
00:07:08,759 --> 00:07:20,549
this then you can look at the Microsoft

125
00:07:16,729 --> 00:07:23,969
mitigation bypass bounty pages and from

126
00:07:20,549 --> 00:07:27,899
that for CFG Microsoft listed a lot of

127
00:07:23,969 --> 00:07:30,359
the known witness of CFG along with what

128
00:07:27,899 --> 00:07:34,229
they think are the out of scope attack

129
00:07:30,359 --> 00:07:37,349
vectors so all those are useful in

130
00:07:34,229 --> 00:07:40,649
bypassing CFG so later we'll show so

131
00:07:37,349 --> 00:07:44,729
some of those even with the CDT enabled

132
00:07:40,649 --> 00:07:47,099
are still valid that's for the front

133
00:07:44,729 --> 00:07:49,919
edge then for the back edge Microsoft

134
00:07:47,099 --> 00:07:54,319
implemented what they caught the return

135
00:07:49,919 --> 00:07:59,659
flow guard the idea is also very simple

136
00:07:54,319 --> 00:08:03,299
one a function call is made we know that

137
00:07:59,659 --> 00:08:06,569
the attorney address is on the stack is

138
00:08:03,299 --> 00:08:10,318
on the data stack and attackers will try

139
00:08:06,569 --> 00:08:14,119
to modify that return address so that I

140
00:08:10,319 --> 00:08:17,909
can hijack the control flow but what if

141
00:08:14,119 --> 00:08:21,089
we have a separate stack which also has

142
00:08:17,909 --> 00:08:23,308
a copy of the return address and then

143
00:08:21,089 --> 00:08:27,799
when the real return happens operating

144
00:08:23,309 --> 00:08:30,899
system we'll be able to compare the

145
00:08:27,799 --> 00:08:33,568
stored return address on this shadow

146
00:08:30,899 --> 00:08:37,110
stack along with the return address on

147
00:08:33,568 --> 00:08:41,009
the data stack if those two matches then

148
00:08:37,110 --> 00:08:45,240
obviously the the real return address on

149
00:08:41,009 --> 00:08:47,879
the data stack is the return address so

150
00:08:45,240 --> 00:08:52,170
that's the basic idea in order to do

151
00:08:47,879 --> 00:08:53,660
that also there has to be some operating

152
00:08:52,170 --> 00:08:58,560
system changes

153
00:08:53,660 --> 00:09:01,620
if you look at the cult here before the

154
00:08:58,560 --> 00:09:04,170
call is actually made and proceed when

155
00:09:01,620 --> 00:09:07,230
we made the call but before the real

156
00:09:04,170 --> 00:09:09,899
call proceeds then there's some cold

157
00:09:07,230 --> 00:09:13,890
before and there some code after what

158
00:09:09,899 --> 00:09:16,740
this does is that we see RSV is the

159
00:09:13,890 --> 00:09:20,279
current stack pointer it points to the

160
00:09:16,740 --> 00:09:24,779
return address of the current call so we

161
00:09:20,279 --> 00:09:30,300
move that we copy that into this FS RSP

162
00:09:24,779 --> 00:09:32,790
which points to the shadow stack which

163
00:09:30,300 --> 00:09:33,420
means we're copying the real return

164
00:09:32,790 --> 00:09:35,779
address

165
00:09:33,420 --> 00:09:38,699
currently we know into the shadow stack

166
00:09:35,779 --> 00:09:41,910
and then after the original code

167
00:09:38,700 --> 00:09:43,950
executes before we return then we'll see

168
00:09:41,910 --> 00:09:48,810
we're doing a comparison which is the

169
00:09:43,950 --> 00:09:50,730
reverse process we take the copy of the

170
00:09:48,810 --> 00:09:52,529
return address on the shadow stack and

171
00:09:50,730 --> 00:09:56,220
compared with the real return address

172
00:09:52,529 --> 00:10:00,390
that is how this is implemented which is

173
00:09:56,220 --> 00:10:02,910
the return flow guard but there are two

174
00:10:00,390 --> 00:10:07,560
things that we have to notice the first

175
00:10:02,910 --> 00:10:10,290
thing is store of this return address

176
00:10:07,560 --> 00:10:14,660
and the comparison of those return

177
00:10:10,290 --> 00:10:17,250
address those are not atomic operations

178
00:10:14,660 --> 00:10:20,640
because they're at the beginning of this

179
00:10:17,250 --> 00:10:26,130
call and at the end of this call so in

180
00:10:20,640 --> 00:10:30,899
the middle after the RSP is stored on to

181
00:10:26,130 --> 00:10:34,200
the shadow stack then if we have a way

182
00:10:30,899 --> 00:10:36,870
to change the shadow stack content to

183
00:10:34,200 --> 00:10:39,240
change the return address on the shadow

184
00:10:36,870 --> 00:10:42,480
stack then obviously we can change it to

185
00:10:39,240 --> 00:10:45,540
whatever we we want to use and now again

186
00:10:42,480 --> 00:10:47,820
that we can corrupt the data stack for

187
00:10:45,540 --> 00:10:50,819
the return address the same address that

188
00:10:47,820 --> 00:10:53,820
we want to return to will be copied on

189
00:10:50,820 --> 00:10:55,680
both the the real data stack and the

190
00:10:53,820 --> 00:10:58,769
shadow stack that is the first

191
00:10:55,680 --> 00:11:02,760
assumption but that's not easy to do

192
00:10:58,769 --> 00:11:06,540
because one Microsoft implements the so

193
00:11:02,760 --> 00:11:10,800
called the SIA rfg the return flow card

194
00:11:06,540 --> 00:11:13,829
then one assumption is this is put into

195
00:11:10,800 --> 00:11:16,219
a location nobody knows which means we

196
00:11:13,830 --> 00:11:18,480
don't know the base address for this

197
00:11:16,220 --> 00:11:21,870
shadow stack they'll sell first hurdle

198
00:11:18,480 --> 00:11:23,670
stack that's a good assumption but in

199
00:11:21,870 --> 00:11:26,190
reality everything is still in the

200
00:11:23,670 --> 00:11:28,979
memory so there are ways to find out

201
00:11:26,190 --> 00:11:30,870
where this base address is as soon as we

202
00:11:28,980 --> 00:11:34,560
get that base address of this shadow

203
00:11:30,870 --> 00:11:36,810
stack then we will be able to see where

204
00:11:34,560 --> 00:11:39,510
the real return address we want to

205
00:11:36,810 --> 00:11:43,739
change to is and then if we have a

206
00:11:39,510 --> 00:11:46,620
arbitrary read and write exploitation to

207
00:11:43,740 --> 00:11:49,440
get read and write now we'll be able to

208
00:11:46,620 --> 00:11:52,290
change the memory so then that can be

209
00:11:49,440 --> 00:11:55,650
broken that's the basic idea so if you

210
00:11:52,290 --> 00:12:04,339
are interested then pretty much this

211
00:11:55,650 --> 00:12:07,020
talk has the detail so now we know that

212
00:12:04,340 --> 00:12:08,940
we have software solutions to tackle

213
00:12:07,020 --> 00:12:12,390
both the front edge and the back edge

214
00:12:08,940 --> 00:12:14,670
control flow hijacking but those

215
00:12:12,390 --> 00:12:16,650
software solutions don't really work as

216
00:12:14,670 --> 00:12:19,290
they're designed there are still

217
00:12:16,650 --> 00:12:23,250
possibility to bypass them therefore

218
00:12:19,290 --> 00:12:25,380
Intel decides that such solutions to be

219
00:12:23,250 --> 00:12:29,190
should be implemented into the hardware

220
00:12:25,380 --> 00:12:37,730
into CPU this is where the control flow

221
00:12:29,190 --> 00:12:40,730
enforcement technology CET came okay so

222
00:12:37,730 --> 00:12:43,620
Intel implemented this so it will be

223
00:12:40,730 --> 00:12:46,920
come out as the hardware feature for the

224
00:12:43,620 --> 00:12:49,830
new processor families the basic idea as

225
00:12:46,920 --> 00:12:53,430
we said is to prevent control flow

226
00:12:49,830 --> 00:12:56,010
hijacking there are two capabilities as

227
00:12:53,430 --> 00:12:58,620
we're already said first of all there's

228
00:12:56,010 --> 00:13:01,290
a friend and friend edge control flow

229
00:12:58,620 --> 00:13:06,390
hijacking and there's a back edge for

230
00:13:01,290 --> 00:13:14,060
the front edge what it is being done

231
00:13:06,390 --> 00:13:18,890
here is Intel introduced the so called

232
00:13:14,060 --> 00:13:22,969
indirect branch tracking so that one odd

233
00:13:18,890 --> 00:13:27,170
in direct cause may then it wants to

234
00:13:22,970 --> 00:13:30,410
compare the the address and also for the

235
00:13:27,170 --> 00:13:33,260
package then we have this shadow stack

236
00:13:30,410 --> 00:13:42,050
concept already that is implemented into

237
00:13:33,260 --> 00:13:44,930
the hardware now so now we know there

238
00:13:42,050 --> 00:13:47,050
are two of those capabilities let's dive

239
00:13:44,930 --> 00:13:50,239
into the details so that we understand

240
00:13:47,050 --> 00:13:53,020
what exactly is being done here and how

241
00:13:50,240 --> 00:13:57,350
those can be used to prevent hijacking

242
00:13:53,020 --> 00:14:00,020
first of all let's look at the shadows

243
00:13:57,350 --> 00:14:01,910
that concept as we know for the we

244
00:14:00,020 --> 00:14:04,610
already described for the cell first

245
00:14:01,910 --> 00:14:09,469
evolution you have the data stack and

246
00:14:04,610 --> 00:14:11,630
then you have shadows stack here we have

247
00:14:09,470 --> 00:14:17,050
the same concept but the difference is

248
00:14:11,630 --> 00:14:22,400
that this shadow stack now is only

249
00:14:17,050 --> 00:14:25,370
available operated by a hardware and

250
00:14:22,400 --> 00:14:29,829
also it's only available to be changed

251
00:14:25,370 --> 00:14:32,000
and modified through certain

252
00:14:29,830 --> 00:14:34,520
instructions which is not a normal

253
00:14:32,000 --> 00:14:37,340
instruction special instructions are

254
00:14:34,520 --> 00:14:42,650
introduced but the basic idea is still

255
00:14:37,340 --> 00:14:44,930
the same one any choice made the return

256
00:14:42,650 --> 00:14:48,459
address first of all it must be on the

257
00:14:44,930 --> 00:14:53,329
data stack and then we'll copy that into

258
00:14:48,460 --> 00:14:58,760
this shadow stack so one the call

259
00:14:53,330 --> 00:15:01,370
returns then CPU will check the return

260
00:14:58,760 --> 00:15:03,680
address on the data stack compared with

261
00:15:01,370 --> 00:15:08,120
the return address of the shadow stack

262
00:15:03,680 --> 00:15:10,339
if they don't match which means that the

263
00:15:08,120 --> 00:15:14,150
data stack return address is now

264
00:15:10,340 --> 00:15:16,520
corrupted now we have a mismatch so at

265
00:15:14,150 --> 00:15:19,310
this point operating system will throw

266
00:15:16,520 --> 00:15:22,370
an exception which is called control

267
00:15:19,310 --> 00:15:25,489
production exception and it will give

268
00:15:22,370 --> 00:15:29,170
you different reasons of why this failed

269
00:15:25,490 --> 00:15:29,170
so that's the basic idea

270
00:15:29,790 --> 00:15:39,150
now this uh IBT

271
00:15:33,960 --> 00:15:42,540
the indirect branch checking here is

272
00:15:39,150 --> 00:15:45,750
also the basic idea let us look at the

273
00:15:42,540 --> 00:15:48,540
problem on the left what we're doing

274
00:15:45,750 --> 00:15:51,150
here is we're doing assignment for a

275
00:15:48,540 --> 00:15:53,310
function pointer and then we're making a

276
00:15:51,150 --> 00:15:56,939
indirect cost through a function pointer

277
00:15:53,310 --> 00:16:00,109
and then one this is compiled the

278
00:15:56,940 --> 00:16:03,990
compiler will add other instrumentation

279
00:16:00,110 --> 00:16:07,470
instructions into the binary code so

280
00:16:03,990 --> 00:16:10,230
what are added are what is called n

281
00:16:07,470 --> 00:16:13,230
branch instructions those are the n

282
00:16:10,230 --> 00:16:16,170
branch so this n branch is at the

283
00:16:13,230 --> 00:16:20,550
beginning and then right when we get

284
00:16:16,170 --> 00:16:23,490
into this this indirect call it has a

285
00:16:20,550 --> 00:16:28,079
second and branch those two comes as a

286
00:16:23,490 --> 00:16:33,170
pair that's V Z that's easy to see so

287
00:16:28,080 --> 00:16:36,990
now how does the CPU work in this case

288
00:16:33,170 --> 00:16:39,180
CPU oh by yourself it maintains a small

289
00:16:36,990 --> 00:16:41,760
state machine this state machine has

290
00:16:39,180 --> 00:16:44,969
only two states the first state is idle

291
00:16:41,760 --> 00:16:49,080
state the second state is the wait for n

292
00:16:44,970 --> 00:16:53,120
branch state 1 we have the code

293
00:16:49,080 --> 00:16:56,520
execution we see the first n branch

294
00:16:53,120 --> 00:16:59,550
instruction and then the CPU gets from

295
00:16:56,520 --> 00:17:01,980
the idle state into this wait for n

296
00:16:59,550 --> 00:17:04,948
branch states at this moment he knows

297
00:17:01,980 --> 00:17:10,260
that a function in the rec hall will be

298
00:17:04,949 --> 00:17:14,280
made and then obviously as soon as it

299
00:17:10,260 --> 00:17:17,810
gets into this indirect go into the

300
00:17:14,280 --> 00:17:21,569
function then it expects the second

301
00:17:17,810 --> 00:17:25,290
matching and branch instruction so one

302
00:17:21,569 --> 00:17:28,679
is sees this instruction then CPU will

303
00:17:25,290 --> 00:17:31,770
change his state from and the wait for n

304
00:17:28,680 --> 00:17:35,340
branch to idle which means now we're

305
00:17:31,770 --> 00:17:38,510
seeing a koi is made and then this call

306
00:17:35,340 --> 00:17:41,280
is actually made to the valid

307
00:17:38,510 --> 00:17:43,519
destination that we're checking so

308
00:17:41,280 --> 00:17:48,480
that's the basic idea of this

309
00:17:43,519 --> 00:17:51,029
but let's see what if the attacker is

310
00:17:48,480 --> 00:17:53,450
able to hijack the target address and

311
00:17:51,029 --> 00:17:57,630
redirect this to some other location

312
00:17:53,450 --> 00:18:03,389
let's assume in this case RDX contains

313
00:17:57,630 --> 00:18:07,200
the address that this call wants to call

314
00:18:03,389 --> 00:18:10,949
- but let's say if we are the attacker

315
00:18:07,200 --> 00:18:12,990
and we are able to modify this RDX the

316
00:18:10,950 --> 00:18:15,419
value of it so that we jump to some

317
00:18:12,990 --> 00:18:19,049
other places in this case for simplicity

318
00:18:15,419 --> 00:18:24,450
let's assume that we are able to jump

319
00:18:19,049 --> 00:18:27,299
into in the middle of this function call

320
00:18:24,450 --> 00:18:31,169
somewhere in the middle and then

321
00:18:27,299 --> 00:18:34,019
obviously when it comes to hear what CPU

322
00:18:31,169 --> 00:18:36,210
expects is another and branch but when

323
00:18:34,019 --> 00:18:39,779
it comes to here the instructor is not

324
00:18:36,210 --> 00:18:41,750
and branch then obviously CPU knows that

325
00:18:39,779 --> 00:18:44,940
something goes wrong because we're not

326
00:18:41,750 --> 00:18:47,279
going into the target address that has

327
00:18:44,940 --> 00:18:51,779
the end branch the other end branch has

328
00:18:47,279 --> 00:18:56,120
a pair right so that's how the problem

329
00:18:51,779 --> 00:18:58,769
happens and then now since CPU

330
00:18:56,120 --> 00:19:01,979
identifies there there's a mismatch and

331
00:18:58,769 --> 00:19:06,419
there's a hijacking in place then we'll

332
00:19:01,980 --> 00:19:09,870
throw another control protection its

333
00:19:06,419 --> 00:19:18,740
exception with different unbranched as a

334
00:19:09,870 --> 00:19:18,739
error reason that is how this IBT works

335
00:19:24,410 --> 00:19:31,650
in order to use those then new

336
00:19:29,130 --> 00:19:34,170
instructions were introduced for example

337
00:19:31,650 --> 00:19:37,170
for shadow stack management there's a

338
00:19:34,170 --> 00:19:40,080
bunch of new instructions if we want to

339
00:19:37,170 --> 00:19:44,160
increase the shadows stack pointer then

340
00:19:40,080 --> 00:19:46,710
this Inc SSB is used if we want to read

341
00:19:44,160 --> 00:19:50,730
the shadow stack pointer then this RVs

342
00:19:46,710 --> 00:19:53,070
SP is used and also there's a other two

343
00:19:50,730 --> 00:19:56,400
pairs of the instructions which are very

344
00:19:53,070 --> 00:19:58,139
interesting as we know different

345
00:19:56,400 --> 00:20:00,870
programs different processes different

346
00:19:58,140 --> 00:20:03,780
acts are running at the same time on CPU

347
00:20:00,870 --> 00:20:06,689
so each of those will have its own

348
00:20:03,780 --> 00:20:09,750
shadow stack so one the task switches

349
00:20:06,690 --> 00:20:13,830
now we have to switch to a new shadow

350
00:20:09,750 --> 00:20:17,370
stack those saved rivers ssp and restore

351
00:20:13,830 --> 00:20:20,250
as as we are used for the channel stack

352
00:20:17,370 --> 00:20:23,219
switching purposes so that it can switch

353
00:20:20,250 --> 00:20:27,750
a new shadow stack that can be used for

354
00:20:23,220 --> 00:20:31,470
the new task and then to write to the

355
00:20:27,750 --> 00:20:34,320
shadow stack there's this WR s s and W R

356
00:20:31,470 --> 00:20:37,830
Us has the second one we can write to it

357
00:20:34,320 --> 00:20:40,470
in the user mode and then obviously we

358
00:20:37,830 --> 00:20:47,790
can set the shadow stack to be busy and

359
00:20:40,470 --> 00:20:51,510
also we can also clear the visit tag we

360
00:20:47,790 --> 00:20:54,059
just described a little bit of there's a

361
00:20:51,510 --> 00:20:57,929
shadow stack switch so this is a very

362
00:20:54,059 --> 00:21:01,230
interesting operation as we know because

363
00:20:57,929 --> 00:21:03,179
we need to switch back and forth between

364
00:21:01,230 --> 00:21:05,790
different shadow sacks with because

365
00:21:03,179 --> 00:21:07,950
different processes and the tasks are

366
00:21:05,790 --> 00:21:18,780
running so this is how it is done

367
00:21:07,950 --> 00:21:22,020
through the through the current shadow

368
00:21:18,780 --> 00:21:28,110
stack and the new shadow stack now let's

369
00:21:22,020 --> 00:21:31,679
look at this first of all we have the

370
00:21:28,110 --> 00:21:34,760
current shadow stack here and then we

371
00:21:31,679 --> 00:21:36,360
are using restore shadows restore SSP

372
00:21:34,760 --> 00:21:38,879
given and add

373
00:21:36,360 --> 00:21:41,850
this is where the new shadows are we

374
00:21:38,880 --> 00:21:45,240
want to switch to so as we see a point

375
00:21:41,850 --> 00:21:49,590
so here at this location it has a what

376
00:21:45,240 --> 00:21:51,990
they call the shadow stack restore token

377
00:21:49,590 --> 00:21:55,110
and this restore cook and this bit is

378
00:21:51,990 --> 00:21:58,130
zero and this part contains the address

379
00:21:55,110 --> 00:22:02,209
when this token was created that means

380
00:21:58,130 --> 00:22:06,570
when this was created at that moment

381
00:22:02,210 --> 00:22:09,149
this is the shadow step pointer so what

382
00:22:06,570 --> 00:22:13,250
we're doing here is that replace this by

383
00:22:09,149 --> 00:22:16,110
a previous shuttle stack token now we're

384
00:22:13,250 --> 00:22:20,340
because we need to go back to here so

385
00:22:16,110 --> 00:22:24,240
since we the current SSP is point two

386
00:22:20,340 --> 00:22:26,580
pointing to 0 X 1 0 0 then we copy the

387
00:22:24,240 --> 00:22:31,559
address to here and then this one marks

388
00:22:26,580 --> 00:22:38,000
it as previous SSB token so now this is

389
00:22:31,559 --> 00:22:42,149
created and now we can see since this is

390
00:22:38,000 --> 00:22:47,880
created then this previous SSP token is

391
00:22:42,149 --> 00:22:52,229
in place now we want to do the store we

392
00:22:47,880 --> 00:22:56,760
want to have the the previous shadow

393
00:22:52,230 --> 00:22:59,159
stack to have this shadow stack token so

394
00:22:56,760 --> 00:23:02,250
that we know we are able to go back to

395
00:22:59,159 --> 00:23:06,659
this district 1 when this is done or

396
00:23:02,250 --> 00:23:11,130
some other shadow stack after the use of

397
00:23:06,659 --> 00:23:14,850
it and then we put this which contains

398
00:23:11,130 --> 00:23:21,149
the address of the previous shuttle

399
00:23:14,850 --> 00:23:23,699
stack which is here and then this is the

400
00:23:21,149 --> 00:23:27,260
address and then this 0 means is the

401
00:23:23,700 --> 00:23:31,789
Sherrill stack restored token and then

402
00:23:27,260 --> 00:23:38,639
after that is done so we will be able to

403
00:23:31,789 --> 00:23:40,889
have a new have a new oh this is the

404
00:23:38,639 --> 00:23:42,479
original this is our read sorry this is

405
00:23:40,889 --> 00:23:44,908
our return or shuttle stack restore

406
00:23:42,480 --> 00:23:47,309
token so now we

407
00:23:44,909 --> 00:23:50,340
put the previous set of stacked token to

408
00:23:47,309 --> 00:23:55,529
it and then after that is done then we

409
00:23:50,340 --> 00:23:58,499
popped the SSP now SSP points to the new

410
00:23:55,529 --> 00:24:02,190
shadow stack on top of it so that can be

411
00:23:58,499 --> 00:24:05,729
used now this will be able to use for

412
00:24:02,190 --> 00:24:10,979
the new shadow stack so that is how

413
00:24:05,729 --> 00:24:13,440
switch happens obviously for the any new

414
00:24:10,979 --> 00:24:18,179
CPU features there will be registered

415
00:24:13,440 --> 00:24:22,320
that we can use to store all those for

416
00:24:18,179 --> 00:24:25,889
operation there are CR 4 dot CET that we

417
00:24:22,320 --> 00:24:28,889
use for the master enable bits and then

418
00:24:25,889 --> 00:24:31,408
there's a bunch of MSR the model

419
00:24:28,889 --> 00:24:37,408
specific register that we use to operate

420
00:24:31,409 --> 00:24:41,090
for those now let's look at the

421
00:24:37,409 --> 00:24:44,369
operating system implementation of it

422
00:24:41,090 --> 00:24:46,889
for Windows 10 in order to implement

423
00:24:44,369 --> 00:24:51,330
this it has to make a lot of changes the

424
00:24:46,889 --> 00:24:56,099
first change it makes is introduced a

425
00:24:51,330 --> 00:24:57,989
lot of the enhancement for a lot of

426
00:24:56,099 --> 00:25:01,019
those operations for example thread

427
00:24:57,989 --> 00:25:03,799
creation and termination fiber equation

428
00:25:01,019 --> 00:25:07,859
termination and T continue and gas read

429
00:25:03,799 --> 00:25:11,749
context and an exception a minder

430
00:25:07,859 --> 00:25:14,309
control protection for paid handling and

431
00:25:11,749 --> 00:25:16,889
page fault handling a user mode

432
00:25:14,309 --> 00:25:20,129
callbacks all those needs to be enhanced

433
00:25:16,889 --> 00:25:23,609
so that they can deal with this a new

434
00:25:20,129 --> 00:25:25,559
feature but then one thing that we want

435
00:25:23,609 --> 00:25:29,580
to notice is that for the latest Windows

436
00:25:25,559 --> 00:25:31,499
10 Windows 10 insider preview 19 h1 it

437
00:25:29,580 --> 00:25:34,918
doesn't really support the IBT

438
00:25:31,499 --> 00:25:39,799
we're suspecting that because Microsoft

439
00:25:34,919 --> 00:25:42,989
already have the our rfg in place so to

440
00:25:39,799 --> 00:25:45,408
get rid of rfg to fully implement this

441
00:25:42,989 --> 00:25:50,849
IBT it may takes a lot of time therefore

442
00:25:45,409 --> 00:25:53,099
it probably is deferred now let's look

443
00:25:50,849 --> 00:25:56,730
at the deal of the also enhancement that

444
00:25:53,099 --> 00:26:00,760
we want to add to those

445
00:25:56,730 --> 00:26:07,330
some of the functions that is their gene

446
00:26:00,760 --> 00:26:10,120
will give you to detail now you guys

447
00:26:07,330 --> 00:26:14,080
know some special instructor and how did

448
00:26:10,120 --> 00:26:16,719
inhale do with a shadow stack and next I

449
00:26:14,080 --> 00:26:19,960
will combine some special function in

450
00:26:16,720 --> 00:26:25,860
fiber to tell you how Microsoft added

451
00:26:19,960 --> 00:26:29,410
into function actually because it seems

452
00:26:25,860 --> 00:26:32,530
thread creations we can send the shadows

453
00:26:29,410 --> 00:26:34,900
decoration so we need to focus on the

454
00:26:32,530 --> 00:26:37,300
fiber actually this ready is most

455
00:26:34,900 --> 00:26:40,690
important but the creation should be

456
00:26:37,300 --> 00:26:44,620
same the first day is a function you can

457
00:26:40,690 --> 00:26:49,210
see is a PSP start up user fiber shadow

458
00:26:44,620 --> 00:26:51,820
stack this is a function which responds

459
00:26:49,210 --> 00:26:55,570
for the shadows a shot at creation and

460
00:26:51,820 --> 00:26:58,540
to switch and you can see there are

461
00:26:55,570 --> 00:27:02,950
serious a first function in the dress of

462
00:26:58,540 --> 00:27:06,280
a p84 is for one it name is PSP reserved

463
00:27:02,950 --> 00:27:10,600
and commit user shadow stack actually

464
00:27:06,280 --> 00:27:14,230
this function aim to create read only

465
00:27:10,600 --> 00:27:16,240
paid protection shadow stack page and it

466
00:27:14,230 --> 00:27:20,670
also considered for the shadows that

467
00:27:16,240 --> 00:27:24,550
extend it will return the address and

468
00:27:20,670 --> 00:27:28,840
next it will check if it is a success

469
00:27:24,550 --> 00:27:34,480
and you can see here from the address a

470
00:27:28,840 --> 00:27:38,560
p8 for 5 month it the instruction is sub

471
00:27:34,480 --> 00:27:43,000
rx-8 the target is a shadow stack

472
00:27:38,560 --> 00:27:48,220
pointer it will give first Q word on the

473
00:27:43,000 --> 00:27:52,330
shadows to export him and he adhere at

474
00:27:48,220 --> 00:27:56,070
the address of a p8 for Wi-Fi it will

475
00:27:52,330 --> 00:27:59,439
move a function pointer in this place

476
00:27:56,070 --> 00:28:01,780
actually the sweat switch and fiber

477
00:27:59,440 --> 00:28:06,160
switch will always begin with a special

478
00:28:01,780 --> 00:28:07,970
function here the fibers is a detail RTL

479
00:28:06,160 --> 00:28:12,350
user favor start

480
00:28:07,970 --> 00:28:15,700
when the fibers red has been added the

481
00:28:12,350 --> 00:28:20,030
function will begin with this function

482
00:28:15,700 --> 00:28:21,980
the interaction this instruction will

483
00:28:20,030 --> 00:28:25,850
move the pointer into shadow stack so

484
00:28:21,980 --> 00:28:30,320
that when the fibers thread be shadowed

485
00:28:25,850 --> 00:28:32,480
and return the instruction will check if

486
00:28:30,320 --> 00:28:35,840
the function pointer will match the

487
00:28:32,480 --> 00:28:39,260
shadow stack and it will use the special

488
00:28:35,840 --> 00:28:44,720
instruction WR USS why is the pointer

489
00:28:39,260 --> 00:28:47,900
into the create a shadow stack and this

490
00:28:44,720 --> 00:28:52,010
is the rest part of a PSP start up user

491
00:28:47,900 --> 00:28:58,460
fiber shadow stack and you can see just

492
00:28:52,010 --> 00:29:02,800
like a last page it also use special

493
00:28:58,460 --> 00:29:06,500
instruction WR USS but this time he just

494
00:29:02,800 --> 00:29:08,780
white restore token on the second D word

495
00:29:06,500 --> 00:29:12,800
and the shadow stack bottom so the first

496
00:29:08,780 --> 00:29:16,120
is pointer of random user fabrica the

497
00:29:12,800 --> 00:29:20,240
second is a shadow stack restore Hawken

498
00:29:16,120 --> 00:29:26,239
it can be used for the switch contacts

499
00:29:20,240 --> 00:29:29,360
later and the next is another function

500
00:29:26,240 --> 00:29:33,440
which name is switch fabric context it

501
00:29:29,360 --> 00:29:35,810
will shadows a new create fiber and the

502
00:29:33,440 --> 00:29:41,450
CPU and RAM begin with

503
00:29:35,810 --> 00:29:45,169
ngel torrent random user fiber start it

504
00:29:41,450 --> 00:29:50,570
can do the three things the first is it

505
00:29:45,170 --> 00:29:56,300
will as address of nursery 295 it will

506
00:29:50,570 --> 00:30:01,100
come higher therapy twist pointer at RC

507
00:29:56,300 --> 00:30:04,450
X plus 5 to 8 it will check if the

508
00:30:01,100 --> 00:30:09,530
shadow stack is exist if it is if it is

509
00:30:04,450 --> 00:30:13,360
exist it will use another spiritual

510
00:30:09,530 --> 00:30:17,540
instruction like RTS SP it will read the

511
00:30:13,360 --> 00:30:18,860
pointer of the shadow stack and you can

512
00:30:17,540 --> 00:30:22,220
see the

513
00:30:18,860 --> 00:30:27,620
fire of special instruction at address

514
00:30:22,220 --> 00:30:30,200
of nursery to ad to restore shadow stack

515
00:30:27,620 --> 00:30:35,149
pointer and sip reverse shadow style

516
00:30:30,200 --> 00:30:37,910
pointer because currently the serie -

517
00:30:35,150 --> 00:30:41,090
shadow sects shadow stack of a thread

518
00:30:37,910 --> 00:30:44,410
who will create the new fiber and the

519
00:30:41,090 --> 00:30:48,070
another shadow stack is curing to create

520
00:30:44,410 --> 00:30:52,130
fibers so it need to do add a switch and

521
00:30:48,070 --> 00:30:57,770
at the end the function also moved to

522
00:30:52,130 --> 00:31:00,169
the pointer of a beginning function RTL

523
00:30:57,770 --> 00:31:04,040
user fiber set it will move to the data

524
00:31:00,169 --> 00:31:07,040
stack so that when the function used

525
00:31:04,040 --> 00:31:09,590
read the shadow stack pointer will match

526
00:31:07,040 --> 00:31:14,559
the data stack pointer so that it will

527
00:31:09,590 --> 00:31:18,379
not reach the say P exception this is

528
00:31:14,559 --> 00:31:25,000
logic of switch and shadow stack

529
00:31:18,380 --> 00:31:29,030
creation next part and is about the

530
00:31:25,000 --> 00:31:39,410
control flow hijackings idea and from

531
00:31:29,030 --> 00:31:42,020
will talk the brief so will now we

532
00:31:39,410 --> 00:31:44,150
talked about the software solution for

533
00:31:42,020 --> 00:31:46,970
control flow hijacking and we talked

534
00:31:44,150 --> 00:31:50,380
about Intel's Traverse solution for

535
00:31:46,970 --> 00:31:55,480
hijacking and then we talked about

536
00:31:50,380 --> 00:31:59,210
Windows 10 implementation for the CET

537
00:31:55,480 --> 00:32:03,340
enhancement and then gene used example

538
00:31:59,210 --> 00:32:06,890
of fiber the creation and also switch

539
00:32:03,340 --> 00:32:09,980
for those to describe what are the

540
00:32:06,890 --> 00:32:12,559
changes the operators must must make to

541
00:32:09,980 --> 00:32:16,010
use those special instructions provided

542
00:32:12,559 --> 00:32:19,280
to do all the enhancement in order to

543
00:32:16,010 --> 00:32:23,530
use the city now let's continue let's

544
00:32:19,280 --> 00:32:23,530
continue into how we can break it

545
00:32:25,630 --> 00:32:33,160
first of all we believe shadow sac CT

546
00:32:31,299 --> 00:32:34,960
shadows stack itself it defeats the

547
00:32:33,160 --> 00:32:37,570
friend of the package control flow

548
00:32:34,960 --> 00:32:42,730
hijacking wired the return address

549
00:32:37,570 --> 00:32:45,580
overwrite as we know the way how it does

550
00:32:42,730 --> 00:32:50,380
is through hardware and then also at

551
00:32:45,580 --> 00:32:52,809
this moment because only a certain set

552
00:32:50,380 --> 00:32:55,900
of the instructions can be used to

553
00:32:52,809 --> 00:32:58,480
modify the content on the shuttle stack

554
00:32:55,900 --> 00:33:01,720
and to make changes so it's not possible

555
00:32:58,480 --> 00:33:04,539
for arbitrary Unicode to make make

556
00:33:01,720 --> 00:33:07,440
arbitrary changes to those therefore the

557
00:33:04,539 --> 00:33:10,179
shadow stack by itself is very secure

558
00:33:07,440 --> 00:33:13,510
therefore it's not possible for anybody

559
00:33:10,179 --> 00:33:15,490
to temper the content on the shadow

560
00:33:13,510 --> 00:33:19,690
stack because it's a hardware assisted

561
00:33:15,490 --> 00:33:22,419
solution so now the return address

562
00:33:19,690 --> 00:33:28,020
overwrite as we used to use it's no

563
00:33:22,419 --> 00:33:32,350
longer pretty much impossible second

564
00:33:28,020 --> 00:33:35,168
shadow stack together with AC g + CI g

565
00:33:32,350 --> 00:33:38,860
AC t-- a sense for arbitrary called card

566
00:33:35,169 --> 00:33:41,950
CI g sent for the code integrity card

567
00:33:38,860 --> 00:33:44,168
nose make the code arbitrary code

568
00:33:41,950 --> 00:33:46,600
execution even more difficult why is

569
00:33:44,169 --> 00:33:50,169
that well first of all shadows stack

570
00:33:46,600 --> 00:33:53,469
pretty much it defeats rob shellcode we

571
00:33:50,169 --> 00:33:57,309
cannot jump arbitrarily anymore and then

572
00:33:53,470 --> 00:33:59,830
as we know AC g the purpose of it is to

573
00:33:57,309 --> 00:34:02,649
be able to load only the knowing code

574
00:33:59,830 --> 00:34:06,070
into the memory for execution and CI g

575
00:34:02,650 --> 00:34:08,109
is that if we can load knowing code then

576
00:34:06,070 --> 00:34:11,679
we have to make sure when the code is

577
00:34:08,109 --> 00:34:14,560
loaded it cannot be changed now when

578
00:34:11,679 --> 00:34:18,820
those things work together which means

579
00:34:14,560 --> 00:34:22,210
that we cannot arbitrarily load any code

580
00:34:18,820 --> 00:34:24,940
and change any pages in the memory for

581
00:34:22,210 --> 00:34:27,460
execution and then even if some code is

582
00:34:24,940 --> 00:34:29,710
loaded then it's not possible for any

583
00:34:27,460 --> 00:34:33,369
third party code to be loaded and

584
00:34:29,710 --> 00:34:36,580
especially those called modifies the

585
00:34:33,369 --> 00:34:38,340
memory and make it as a new executable

586
00:34:36,580 --> 00:34:42,120
so no

587
00:34:38,340 --> 00:34:45,000
are pretty much no longer possible but

588
00:34:42,120 --> 00:34:49,650
that being said as we said in the

589
00:34:45,000 --> 00:34:52,969
previous section the indirect branch

590
00:34:49,650 --> 00:34:56,580
tracking which is a hardware solution

591
00:34:52,969 --> 00:34:59,359
for CET is not implemented in the

592
00:34:56,580 --> 00:35:02,310
current Windows 10 implementation

593
00:34:59,360 --> 00:35:08,520
therefore a Windows 10 currently still

594
00:35:02,310 --> 00:35:11,460
heavily relies on the CFG for the front

595
00:35:08,520 --> 00:35:15,270
edge control for hijacking we know CFG

596
00:35:11,460 --> 00:35:18,030
is possible to by passive those being

597
00:35:15,270 --> 00:35:22,050
said a lot of the assumptions made here

598
00:35:18,030 --> 00:35:26,130
are is that we need show called in order

599
00:35:22,050 --> 00:35:29,790
to have all the things work but in

600
00:35:26,130 --> 00:35:32,550
reality that's not really necessary one

601
00:35:29,790 --> 00:35:35,100
talk we gave which is the shell codes

602
00:35:32,550 --> 00:35:38,040
are for the 99% if you are interested

603
00:35:35,100 --> 00:35:41,250
you can read that talk what we proposed

604
00:35:38,040 --> 00:35:44,150
here is that we don't have to have the

605
00:35:41,250 --> 00:35:46,350
shell code we can go through the

606
00:35:44,150 --> 00:35:48,860
scripting engine in this case the

607
00:35:46,350 --> 00:35:50,670
example we use is a JavaScript engine

608
00:35:48,860 --> 00:35:53,630
everything can be done through

609
00:35:50,670 --> 00:35:55,070
JavaScript and we will achieve the same

610
00:35:53,630 --> 00:35:58,320
results

611
00:35:55,070 --> 00:36:01,380
so pretty much we achieved our create a

612
00:35:58,320 --> 00:36:04,260
solution that is a shell code free

613
00:36:01,380 --> 00:36:10,950
because we're doing everything shoot

614
00:36:04,260 --> 00:36:15,110
JavaScript so that being said now since

615
00:36:10,950 --> 00:36:19,259
were using javascript a lot of those say

616
00:36:15,110 --> 00:36:21,360
ICGC IG those are no longer a barrier

617
00:36:19,260 --> 00:36:23,850
for us because we don't we don't really

618
00:36:21,360 --> 00:36:27,590
rely on an arbitrary shell code to be

619
00:36:23,850 --> 00:36:32,009
executed we do in the JavaScript layer

620
00:36:27,590 --> 00:36:34,620
so now the only thing we want to bypass

621
00:36:32,010 --> 00:36:37,820
is how to bypass either the shadow stack

622
00:36:34,620 --> 00:36:37,819
or the CFG

623
00:36:40,250 --> 00:36:48,950
now we understand what is possible let's

624
00:36:43,369 --> 00:36:52,099
look at the attack vector we believe the

625
00:36:48,950 --> 00:36:54,609
following attack vectors are still valid

626
00:36:52,099 --> 00:36:59,030
and possible given the current

627
00:36:54,609 --> 00:37:00,790
implementation on Windows 10 for CET but

628
00:36:59,030 --> 00:37:04,190
for the first two called replacement

629
00:37:00,790 --> 00:37:07,700
attack and counter fate a break Iranian

630
00:37:04,190 --> 00:37:10,160
programming attack those two are off

631
00:37:07,700 --> 00:37:12,950
topic so will not touch those we'll

632
00:37:10,160 --> 00:37:15,890
focus on the last three data only

633
00:37:12,950 --> 00:37:19,180
corruption function pointer hijacking

634
00:37:15,890 --> 00:37:22,339
through race condition attack and threat

635
00:37:19,180 --> 00:37:28,549
contacts hijacking by abusing anti

636
00:37:22,340 --> 00:37:31,550
continue mechanism now Jim will give all

637
00:37:28,550 --> 00:37:33,710
the details and examples of each of

638
00:37:31,550 --> 00:37:38,390
those attack vector how they can be

639
00:37:33,710 --> 00:37:45,320
attacked and along with the screenshot

640
00:37:38,390 --> 00:37:48,500
of the results okay let's begin as the

641
00:37:45,320 --> 00:37:51,170
data only corruption you probably know

642
00:37:48,500 --> 00:37:54,320
about the data only attack we can use

643
00:37:51,170 --> 00:37:57,410
high court here and abilities to gain

644
00:37:54,320 --> 00:38:00,380
the arbitrator tries red and white after

645
00:37:57,410 --> 00:38:03,290
we got this capabilities we can use this

646
00:38:00,380 --> 00:38:07,130
to change some key key point data in

647
00:38:03,290 --> 00:38:11,300
some structure and it can resulting in

648
00:38:07,130 --> 00:38:15,230
the Hydra hijacking control flow and now

649
00:38:11,300 --> 00:38:18,339
the CD ends say every protection only

650
00:38:15,230 --> 00:38:22,010
protects the integrity of control flow

651
00:38:18,339 --> 00:38:24,799
but now the integrity of data so we can

652
00:38:22,010 --> 00:38:28,240
corrupt in our programs critical data

653
00:38:24,800 --> 00:38:32,750
and it can lead the control flow hijack

654
00:38:28,240 --> 00:38:36,560
there is a case CFG bypass by abusing in

655
00:38:32,750 --> 00:38:39,290
detail order work mechanism this issues

656
00:38:36,560 --> 00:38:43,220
is still exist in the windows inside

657
00:38:39,290 --> 00:38:46,300
preview 19 h1 and you can read this link

658
00:38:43,220 --> 00:38:51,759
to see how the loader work work

659
00:38:46,300 --> 00:38:53,839
basically this is a demo screen shot

660
00:38:51,760 --> 00:38:56,690
basically

661
00:38:53,839 --> 00:39:00,440
we buy the high quality even abilities

662
00:38:56,690 --> 00:39:02,509
we freak loader work structures and we

663
00:39:00,440 --> 00:39:06,140
insert it into the top hole increased

664
00:39:02,509 --> 00:39:09,109
and a loader worker naturally can change

665
00:39:06,140 --> 00:39:09,739
the memory protection so you can see as

666
00:39:09,109 --> 00:39:14,660
the rest

667
00:39:09,739 --> 00:39:17,779
this is address or function RPC rt4 it's

668
00:39:14,660 --> 00:39:21,399
a safety check we change the protection

669
00:39:17,779 --> 00:39:24,380
of this memory so original memory is

670
00:39:21,400 --> 00:39:27,890
paid read and now it's people read and

671
00:39:24,380 --> 00:39:30,979
white or we can just either return or

672
00:39:27,890 --> 00:39:33,710
returned value equal to 1 and this safe

673
00:39:30,979 --> 00:39:36,589
check will be bypassed and then we can

674
00:39:33,710 --> 00:39:39,950
combine with JavaScript engine drum has

675
00:39:36,589 --> 00:39:42,440
mentioned that we can use the RPC module

676
00:39:39,950 --> 00:39:46,328
to call any function we want in just

677
00:39:42,440 --> 00:39:50,029
quick level I think is Alcon way to

678
00:39:46,329 --> 00:39:54,680
hijack the control flow in the left you

679
00:39:50,029 --> 00:39:59,359
can see by recalling some windows API we

680
00:39:54,680 --> 00:40:02,299
can cause current process PB it was to

681
00:39:59,359 --> 00:40:07,940
say two three seven four eight who say

682
00:40:02,299 --> 00:40:11,599
zero zero zero and next let's see some

683
00:40:07,940 --> 00:40:15,729
harder is about function pointer

684
00:40:11,599 --> 00:40:19,400
hijacking Zoo risk condition attack

685
00:40:15,729 --> 00:40:22,038
because some have mentioned due to the

686
00:40:19,400 --> 00:40:24,200
lake of hardware base for the edge

687
00:40:22,039 --> 00:40:28,369
control flow enforcement

688
00:40:24,200 --> 00:40:31,519
gibt and memory target address of

689
00:40:28,369 --> 00:40:34,460
indirect call and the indirect ramp is

690
00:40:31,519 --> 00:40:37,848
still susceptible to the risk condition

691
00:40:34,460 --> 00:40:43,130
attack there are two case the first case

692
00:40:37,849 --> 00:40:45,589
is exception an exception handler and a

693
00:40:43,130 --> 00:40:48,170
weakened dollar hijacking through the

694
00:40:45,589 --> 00:40:51,769
risk condition attack the root cause of

695
00:40:48,170 --> 00:40:54,380
this the same and the second case is

696
00:40:51,769 --> 00:40:56,450
frame consolidation and when the

697
00:40:54,380 --> 00:40:59,299
callback routine hijack service

698
00:40:56,450 --> 00:41:02,710
condition attack actually the two parter

699
00:40:59,299 --> 00:41:06,309
also happens in the exception handler

700
00:41:02,710 --> 00:41:06,309
let's see the first

701
00:41:06,470 --> 00:41:14,250
the pack was found in the function named

702
00:41:10,590 --> 00:41:17,130
random dispatcher exception and Wrentham

703
00:41:14,250 --> 00:41:20,430
execute handle or exception

704
00:41:17,130 --> 00:41:24,119
this one is functional who do the really

705
00:41:20,430 --> 00:41:27,480
work and the another function is runtime

706
00:41:24,119 --> 00:41:30,960
on with the X and our TRP execute

707
00:41:27,480 --> 00:41:35,400
handler for Unwin function this for

708
00:41:30,960 --> 00:41:38,160
function in the entire module this this

709
00:41:35,400 --> 00:41:43,560
function can be exploited to achieve the

710
00:41:38,160 --> 00:41:46,618
control flow hijack so the root reason

711
00:41:43,560 --> 00:41:50,340
is that the handler is first saved on

712
00:41:46,619 --> 00:41:53,730
the stack before it gets executed so if

713
00:41:50,340 --> 00:41:57,119
you can find a small time window between

714
00:41:53,730 --> 00:42:00,660
the stack store and handle or invocation

715
00:41:57,119 --> 00:42:05,580
it will have a possible to make a recent

716
00:42:00,660 --> 00:42:10,440
condition attack so the basic idea is we

717
00:42:05,580 --> 00:42:13,590
will call a function who have the which

718
00:42:10,440 --> 00:42:16,380
have the problems a lot of time and it

719
00:42:13,590 --> 00:42:21,090
will trigger the exception again again

720
00:42:16,380 --> 00:42:23,700
so it in the in the function level it

721
00:42:21,090 --> 00:42:27,270
will call the function which have back

722
00:42:23,700 --> 00:42:29,970
again again so we can create a another

723
00:42:27,270 --> 00:42:31,740
thread in this thread we can achieve the

724
00:42:29,970 --> 00:42:35,970
risk condition act hack to modify the

725
00:42:31,740 --> 00:42:41,129
value in the original stress data in the

726
00:42:35,970 --> 00:42:44,520
stack and by the way the exception and I

727
00:42:41,130 --> 00:42:47,340
mean handle seems to come from certain

728
00:42:44,520 --> 00:42:51,300
trust place actually it should come from

729
00:42:47,340 --> 00:42:54,720
the mr data of a piece section so there

730
00:42:51,300 --> 00:42:56,580
is no any safety check against them it

731
00:42:54,720 --> 00:43:02,430
will make the risk condition attack

732
00:42:56,580 --> 00:43:05,310
easier okay let's see the code this is a

733
00:43:02,430 --> 00:43:07,589
function in the case one eye only shows

734
00:43:05,310 --> 00:43:10,720
Unwin the handle or hydrating because

735
00:43:07,590 --> 00:43:13,360
exception is a same as it

736
00:43:10,720 --> 00:43:16,629
you can see there a lot of right code

737
00:43:13,360 --> 00:43:21,610
actually this is a time window for the

738
00:43:16,630 --> 00:43:24,550
risk condition attack so the red

739
00:43:21,610 --> 00:43:27,250
function the function in the left is art

740
00:43:24,550 --> 00:43:31,240
here and windy X and the function the

741
00:43:27,250 --> 00:43:34,900
right is our TRP executed a handler for

742
00:43:31,240 --> 00:43:38,080
and wind this function will be called as

743
00:43:34,900 --> 00:43:43,210
the dress or four six one six five here

744
00:43:38,080 --> 00:43:47,080
and finally the run Hampi execute the

745
00:43:43,210 --> 00:43:51,370
function will call our x directly that

746
00:43:47,080 --> 00:43:56,860
is in handler but you can see the areas

747
00:43:51,370 --> 00:44:00,759
come from our night has 38 and this this

748
00:43:56,860 --> 00:44:05,500
pointer come from the RB P plus 1 C 0

749
00:44:00,760 --> 00:44:08,620
plus variable we can control so we can

750
00:44:05,500 --> 00:44:14,050
use this condition by changing this

751
00:44:08,620 --> 00:44:16,779
value to hijack the control flow and the

752
00:44:14,050 --> 00:44:20,800
red box give us a lot of time to achieve

753
00:44:16,780 --> 00:44:25,030
this risk condition it's more easy

754
00:44:20,800 --> 00:44:28,390
because it have no staff check next

755
00:44:25,030 --> 00:44:31,210
let's see the harder the frame

756
00:44:28,390 --> 00:44:35,400
consolidation and when this function is

757
00:44:31,210 --> 00:44:40,560
also a part of exception dispatcher and

758
00:44:35,400 --> 00:44:43,860
it's also is a risk condition back and

759
00:44:40,560 --> 00:44:46,690
differ from the and when the handler

760
00:44:43,860 --> 00:44:50,740
this consolidation have a callback

761
00:44:46,690 --> 00:44:54,250
routine you can see the function handler

762
00:44:50,740 --> 00:44:58,600
comes from structure exception record to

763
00:44:54,250 --> 00:45:01,270
exception information 0 this handler is

764
00:44:58,600 --> 00:45:01,960
valid by a safety check before making

765
00:45:01,270 --> 00:45:05,320
this call

766
00:45:01,960 --> 00:45:07,260
and now release there is also small

767
00:45:05,320 --> 00:45:11,590
window of the time between the first

768
00:45:07,260 --> 00:45:14,920
exception code check in the 70 you can

769
00:45:11,590 --> 00:45:17,030
see in the runtime and e^x later and the

770
00:45:14,920 --> 00:45:20,359
second exception code

771
00:45:17,030 --> 00:45:22,940
to check for the final execution the

772
00:45:20,359 --> 00:45:26,779
execution is in the function are say

773
00:45:22,940 --> 00:45:29,210
firm consolidation during this time we

774
00:45:26,780 --> 00:45:33,830
can find the exception records and the

775
00:45:29,210 --> 00:45:37,940
stack that we can use a risk condition

776
00:45:33,830 --> 00:45:43,430
attack to change this value let's see

777
00:45:37,940 --> 00:45:47,540
the code is Li complex the left is art

778
00:45:43,430 --> 00:45:51,169
here and windy X and the right is art

779
00:45:47,540 --> 00:45:55,759
here or restore contacts this function

780
00:45:51,170 --> 00:46:01,609
will be called as here that dress 6-3 p

781
00:45:55,760 --> 00:46:04,070
0 and the the left the right the red

782
00:46:01,609 --> 00:46:07,640
code is a first exception Chad called

783
00:46:04,070 --> 00:46:12,440
for savage II the safety check is at the

784
00:46:07,640 --> 00:46:19,549
left bottom address six seven to eight

785
00:46:12,440 --> 00:46:22,599
it will be called adhere the zero as

786
00:46:19,550 --> 00:46:27,500
compared with the exception code to the

787
00:46:22,599 --> 00:46:29,920
value eight a lot of 0:29 and if match

788
00:46:27,500 --> 00:46:35,089
it will jump to the safety check and

789
00:46:29,920 --> 00:46:37,040
then it will jump to six three ninety is

790
00:46:35,089 --> 00:46:41,720
here it will call another functional

791
00:46:37,040 --> 00:46:45,980
odor control flow card first and finally

792
00:46:41,720 --> 00:46:49,640
it will do some check and prepare for

793
00:46:45,980 --> 00:46:51,950
the parameter and go here to call

794
00:46:49,640 --> 00:46:54,799
another function random card very the

795
00:46:51,950 --> 00:46:58,098
stack pointer or finally the well called

796
00:46:54,800 --> 00:47:02,980
the second exception code to check the

797
00:46:58,099 --> 00:47:06,349
right function RTL restore contacts and

798
00:47:02,980 --> 00:47:08,690
you can see at the end of the second

799
00:47:06,349 --> 00:47:13,880
exception jacket the function will color

800
00:47:08,690 --> 00:47:19,040
acts directly so this is a pointer or

801
00:47:13,880 --> 00:47:22,869
from the structure like this so even the

802
00:47:19,040 --> 00:47:26,509
first exception check has a self G

803
00:47:22,869 --> 00:47:28,490
loader value the user call target we

804
00:47:26,510 --> 00:47:31,920
still have enough time to

805
00:47:28,490 --> 00:47:36,810
do the risk condition after it finished

806
00:47:31,920 --> 00:47:43,609
the job until the function finally

807
00:47:36,810 --> 00:47:47,160
called the re axe let's see the last

808
00:47:43,609 --> 00:47:50,430
threat contacts hijacking Bob using anti

809
00:47:47,160 --> 00:47:53,279
continuous system call and she continued

810
00:47:50,430 --> 00:47:56,368
is a special function it can change the

811
00:47:53,280 --> 00:47:59,010
curing the Stratus contacts the threat

812
00:47:56,369 --> 00:48:02,720
Comcast contain a lot all four CPU

813
00:47:59,010 --> 00:48:06,840
register include our IP re ax r ZX and

814
00:48:02,720 --> 00:48:09,980
SATA contacts change occurs in the

815
00:48:06,840 --> 00:48:13,320
kernel space so all the users GFI

816
00:48:09,980 --> 00:48:17,400
enforcements cannot we all became in

817
00:48:13,320 --> 00:48:20,430
relative so as I mentioned in the

818
00:48:17,400 --> 00:48:24,720
continue will take the contest at is

819
00:48:20,430 --> 00:48:27,480
argument in the memory and anti continue

820
00:48:24,720 --> 00:48:29,939
in kernel we are not valid the most

821
00:48:27,480 --> 00:48:35,540
member of contacts but except for the

822
00:48:29,940 --> 00:48:39,030
RSP and CD act state by the way serious

823
00:48:35,540 --> 00:48:42,779
some explanation for the special

824
00:48:39,030 --> 00:48:46,470
function ke verify contacts activate CTU

825
00:48:42,780 --> 00:48:49,619
you can fund control flow and

826
00:48:46,470 --> 00:48:54,600
explanation or a slide of a publication

827
00:48:49,619 --> 00:48:57,810
about the Safety Act state function this

828
00:48:54,600 --> 00:49:01,259
function aim to prevent that hacker to

829
00:48:57,810 --> 00:49:07,109
change the contacts but used some

830
00:49:01,260 --> 00:49:09,300
instruction like ax restore and but post

831
00:49:07,109 --> 00:49:11,400
factor makes a straight content by

832
00:49:09,300 --> 00:49:13,980
dragging through the risk condition

833
00:49:11,400 --> 00:49:17,700
access possible so it's also a risk

834
00:49:13,980 --> 00:49:21,330
condition attack there are also two case

835
00:49:17,700 --> 00:49:23,970
the first is the contacts hijacking in

836
00:49:21,330 --> 00:49:25,770
stressed user mode initialization it's

837
00:49:23,970 --> 00:49:27,180
about the function name the lower

838
00:49:25,770 --> 00:49:29,880
initialize the trunk

839
00:49:27,180 --> 00:49:33,180
mr. Rahman mr. bean how do this topic

840
00:49:29,880 --> 00:49:38,280
you can refer from the link and now I

841
00:49:33,180 --> 00:49:40,759
will show the second case we want to

842
00:49:38,280 --> 00:49:44,260
hijack the thread compacts

843
00:49:40,760 --> 00:49:47,870
in the exception and wind process the

844
00:49:44,260 --> 00:49:53,630
function Hallberg name is art here I'll

845
00:49:47,870 --> 00:49:59,000
restore context you have seen let's see

846
00:49:53,630 --> 00:50:05,810
the code is a little complex the code

847
00:49:59,000 --> 00:50:09,320
name is I should have back and we can

848
00:50:05,810 --> 00:50:11,390
see adhere the at the top of right you

849
00:50:09,320 --> 00:50:15,830
can see the function will call DW

850
00:50:11,390 --> 00:50:18,440
continue the DW continue is until anemia

851
00:50:15,830 --> 00:50:22,870
internally called DW continues it will

852
00:50:18,440 --> 00:50:26,930
change the thread contacts in kernel and

853
00:50:22,870 --> 00:50:32,120
the contacts record is as a parameter

854
00:50:26,930 --> 00:50:34,220
come from the RCX but the place memory

855
00:50:32,120 --> 00:50:38,089
holds this context record is on the

856
00:50:34,220 --> 00:50:41,839
stack so in this case it will have a

857
00:50:38,090 --> 00:50:45,080
very long time window to do the risk

858
00:50:41,840 --> 00:50:48,100
condition it will check if it's

859
00:50:45,080 --> 00:50:51,830
exception called will match this and

860
00:50:48,100 --> 00:50:54,890
according the different exceptional

861
00:50:51,830 --> 00:50:57,170
record to match different contacts

862
00:50:54,890 --> 00:51:00,400
restore method so you can see as a right

863
00:50:57,170 --> 00:51:03,350
by using and continuous it's code to

864
00:51:00,400 --> 00:51:06,800
restore contacts and you saw you can

865
00:51:03,350 --> 00:51:11,150
also do the fast contact restore or just

866
00:51:06,800 --> 00:51:13,970
used special instruction ex restore but

867
00:51:11,150 --> 00:51:17,060
this function need to check with ke

868
00:51:13,970 --> 00:51:21,319
verify contacts I mentioned and there

869
00:51:17,060 --> 00:51:23,960
are a lot of way to do the contacts

870
00:51:21,320 --> 00:51:28,070
restore and finally it will jump to our

871
00:51:23,960 --> 00:51:31,790
say firm consolidation so such a long

872
00:51:28,070 --> 00:51:34,520
time window you can also use risk

873
00:51:31,790 --> 00:51:41,320
condition attack to change contacts

874
00:51:34,520 --> 00:51:45,980
record and stack this is screenshot demo

875
00:51:41,320 --> 00:51:48,640
let me explain it and register you can

876
00:51:45,980 --> 00:51:51,530
see the dip

877
00:51:48,640 --> 00:51:55,700
the Parker rubric has the function

878
00:51:51,530 --> 00:51:58,220
kernel32 is this a value name this is a

879
00:51:55,700 --> 00:52:01,430
hijacked control Florentino control

880
00:51:58,220 --> 00:52:04,850
fellow cannot jump here by changing the

881
00:52:01,430 --> 00:52:08,710
are IP into street contacts we changed

882
00:52:04,850 --> 00:52:13,040
at address of this and we also fake

883
00:52:08,710 --> 00:52:17,810
object as our sex value but if we want

884
00:52:13,040 --> 00:52:22,490
to use the anti continue hijacking you

885
00:52:17,810 --> 00:52:27,140
should also to change the value of RP p

886
00:52:22,490 --> 00:52:30,350
and RSP i mentioned it's cannot change

887
00:52:27,140 --> 00:52:33,410
the RSP value at random but you can

888
00:52:30,350 --> 00:52:37,750
change the value at the bottom of RSP it

889
00:52:33,410 --> 00:52:41,240
should match the return address or

890
00:52:37,750 --> 00:52:45,380
random restore context functions parent

891
00:52:41,240 --> 00:52:48,049
function so when the function finally

892
00:52:45,380 --> 00:52:50,780
returns it will also match the return

893
00:52:48,050 --> 00:52:54,430
address in data second the shadow stack

894
00:52:50,780 --> 00:52:57,530
you must keep the function pointer

895
00:52:54,430 --> 00:53:03,379
matches otherwise it will also raise

896
00:52:57,530 --> 00:53:07,420
exception that's all of the data of the

897
00:53:03,380 --> 00:53:07,420
hijacking control flow idea

898
00:53:12,160 --> 00:53:19,129
okay we just show different ways that we

899
00:53:16,160 --> 00:53:22,040
can still make control flow hijacking

900
00:53:19,130 --> 00:53:24,619
possible and didn't already described

901
00:53:22,040 --> 00:53:28,058
several scenarios in shock tolls are

902
00:53:24,619 --> 00:53:32,540
addressing different possibilities

903
00:53:28,059 --> 00:53:37,099
now let's conclude this talk first of

904
00:53:32,540 --> 00:53:39,740
all we believe that CET our solution is

905
00:53:37,099 --> 00:53:43,520
definitely the direction to go because

906
00:53:39,740 --> 00:53:45,979
to start with we already seen that the

907
00:53:43,520 --> 00:53:48,800
software based solution is not adequate

908
00:53:45,980 --> 00:53:51,050
is in it's good but it's not adequate

909
00:53:48,800 --> 00:53:54,250
because there are still ways to bypass

910
00:53:51,050 --> 00:53:58,460
those software solutions and then

911
00:53:54,250 --> 00:54:02,750
regarding the two functions provided by

912
00:53:58,460 --> 00:54:05,690
CET PCT shadow stack is a good

913
00:54:02,750 --> 00:54:08,329
supplement to CFG and it makes the

914
00:54:05,690 --> 00:54:09,109
control flow hijacking an arbitrary code

915
00:54:08,329 --> 00:54:12,890
execution

916
00:54:09,109 --> 00:54:15,558
more difficult and by itself shadow

917
00:54:12,890 --> 00:54:18,140
stack can also successfully block the

918
00:54:15,559 --> 00:54:21,140
control flow hijacking wired the return

919
00:54:18,140 --> 00:54:28,779
address overwrite and therefore the Rob

920
00:54:21,140 --> 00:54:33,440
and also Rob based attacks so by design

921
00:54:28,780 --> 00:54:39,170
it successfully achieved those but

922
00:54:33,440 --> 00:54:44,270
however even with the however based

923
00:54:39,170 --> 00:54:47,240
CT in place then other type of control

924
00:54:44,270 --> 00:54:50,390
flow hijacking is still possible gingers

925
00:54:47,240 --> 00:54:54,229
show that for the data only attack and

926
00:54:50,390 --> 00:54:57,140
also anti continue then we still can use

927
00:54:54,230 --> 00:55:02,390
those to bypass the control flow

928
00:54:57,140 --> 00:55:05,118
hijacking protection because especially

929
00:55:02,390 --> 00:55:08,509
let's say for example for the data only

930
00:55:05,119 --> 00:55:11,329
attack we're not relying on hijacking

931
00:55:08,510 --> 00:55:13,670
the control flow itself or relying on

932
00:55:11,329 --> 00:55:16,430
changing some of the data which will

933
00:55:13,670 --> 00:55:20,450
influence different control flow

934
00:55:16,430 --> 00:55:22,940
transition so those are the key for the

935
00:55:20,450 --> 00:55:23,660
successful even with hardware solution

936
00:55:22,940 --> 00:55:27,920
in place

937
00:55:23,660 --> 00:55:32,299
such scenario is still possible but that

938
00:55:27,920 --> 00:55:36,080
being said is that it is possible to

939
00:55:32,300 --> 00:55:38,870
still hijack the control flow but then

940
00:55:36,080 --> 00:55:43,190
after we hijack the control flow we have

941
00:55:38,870 --> 00:55:46,580
to make a way of doing something else to

942
00:55:43,190 --> 00:55:50,960
run the arbitrary code then with city in

943
00:55:46,580 --> 00:55:53,509
place arbitrary code execution after the

944
00:55:50,960 --> 00:55:55,540
control flow hijacking is becoming

945
00:55:53,510 --> 00:55:59,690
extremely difficult if not impossible

946
00:55:55,540 --> 00:56:01,400
that that means the city is still very

947
00:55:59,690 --> 00:56:05,600
strong in terms of providing the

948
00:56:01,400 --> 00:56:09,410
protection the third point we want to

949
00:56:05,600 --> 00:56:12,710
make is that compared to the

950
00:56:09,410 --> 00:56:14,839
hardware-based the IB teat indirect

951
00:56:12,710 --> 00:56:17,690
branch tracking the current sulfur

952
00:56:14,840 --> 00:56:22,550
solution on Windows 10 is still not

953
00:56:17,690 --> 00:56:26,870
adequate because the CFG is still by

954
00:56:22,550 --> 00:56:29,840
possible then last but not least is that

955
00:56:26,870 --> 00:56:33,560
as we see a lot of the data or there

956
00:56:29,840 --> 00:56:36,020
were touching or were modifying are in

957
00:56:33,560 --> 00:56:38,720
the users the process space those are

958
00:56:36,020 --> 00:56:41,810
the critical data that can influence the

959
00:56:38,720 --> 00:56:46,310
execution of the processes and threats

960
00:56:41,810 --> 00:56:50,029
whatever the entity we want to to say so

961
00:56:46,310 --> 00:56:52,370
therefore it's very critical that some

962
00:56:50,030 --> 00:56:56,480
of those meaningful data are moved out

963
00:56:52,370 --> 00:56:58,430
of the process space that way the

964
00:56:56,480 --> 00:57:00,860
critical data that can influence the

965
00:56:58,430 --> 00:57:03,950
execution of the process of threats are

966
00:57:00,860 --> 00:57:06,290
no longer accessible within the same

967
00:57:03,950 --> 00:57:10,819
process even you have different stress

968
00:57:06,290 --> 00:57:12,680
running as we see for the risk condition

969
00:57:10,820 --> 00:57:15,110
attack we can ruin a different stroke

970
00:57:12,680 --> 00:57:17,540
within the same process which will be

971
00:57:15,110 --> 00:57:19,610
able to modify the data within the same

972
00:57:17,540 --> 00:57:22,040
process if that process that data is

973
00:57:19,610 --> 00:57:25,370
outside this process space then

974
00:57:22,040 --> 00:57:27,560
obviously that is no longer possible so

975
00:57:25,370 --> 00:57:33,799
that that is one of the things that we

976
00:57:27,560 --> 00:57:36,710
think ultimately will make this data

977
00:57:33,800 --> 00:57:40,620
only attack more difficult

978
00:57:36,710 --> 00:57:46,650
that pretty much conclude the talk today

979
00:57:40,620 --> 00:57:49,259
and now we'll start the Q&A so after

980
00:57:46,650 --> 00:57:51,930
this session if you have any questions

981
00:57:49,260 --> 00:57:54,780
or you want the further discussion

982
00:57:51,930 --> 00:57:59,160
please email us so we have all the

983
00:57:54,780 --> 00:58:02,640
emails listed here and also at the end

984
00:57:59,160 --> 00:58:05,520
we would like to thank nsrc because we

985
00:58:02,640 --> 00:58:07,980
reported the problem and they helped

986
00:58:05,520 --> 00:58:11,730
analyze and confirm those problems in a

987
00:58:07,980 --> 00:58:14,580
very timely manner moreover we would

988
00:58:11,730 --> 00:58:17,250
like to thank our team the McAfee IPS

989
00:58:14,580 --> 00:58:21,029
research team for all the help and all

990
00:58:17,250 --> 00:58:24,680
the support so now it's the time for Q&A

991
00:58:21,030 --> 00:58:24,680
any questions

992
00:58:38,430 --> 00:58:51,490
we used a city neighbor hover but for

993
00:58:46,060 --> 00:58:56,230
for the debugging purpose because a lot

994
00:58:51,490 --> 00:58:58,209
of the the current say Ida Pro it

995
00:58:56,230 --> 00:59:00,369
doesn't really fully support all of all

996
00:58:58,210 --> 00:59:02,410
of those new instructions so we have to

997
00:59:00,369 --> 00:59:04,329
make some our own tricks in order to

998
00:59:02,410 --> 00:59:06,279
make all those thing work so that we can

999
00:59:04,329 --> 00:59:09,940
show you like the code we show you

1000
00:59:06,280 --> 00:59:12,970
actually is not directly from the

1001
00:59:09,940 --> 00:59:16,960
existing debugger is we have to make

1002
00:59:12,970 --> 00:59:19,709
some changes for those any other

1003
00:59:16,960 --> 00:59:19,710
questions

1004
00:59:27,779 --> 00:59:36,960
JIT called where are the giantic on what

1005
00:59:34,000 --> 00:59:36,960
would put in me

1006
00:59:53,940 --> 01:00:03,839
you probably means i PT tricking for the

1007
00:59:57,710 --> 01:00:07,260
treaty code actually the IPTS are same

1008
01:00:03,839 --> 01:00:08,640
as surgery but the difference is autumn

1009
01:00:07,260 --> 01:00:12,869
instruction and as ER is a

1010
01:00:08,640 --> 01:00:16,470
software-based so this behavior is

1011
01:00:12,869 --> 01:00:19,559
happening after the compiler so the JIT

1012
01:00:16,470 --> 01:00:23,339
is a compiler dynamic so it I think it

1013
01:00:19,559 --> 01:00:26,460
will not have a BT but due to the

1014
01:00:23,339 --> 01:00:29,279
situation currently there's no any abaca

1015
01:00:26,460 --> 01:00:39,480
support in Windows 10 so it's hard to

1016
01:00:29,280 --> 01:00:44,220
judge basically the IPT will have also a

1017
01:00:39,480 --> 01:00:47,069
bitmap dresser like a 70 but it's also

1018
01:00:44,220 --> 01:00:50,930
hard to charge because the currently

1019
01:00:47,069 --> 01:00:50,930
here we don't see any code of the IPT

1020
01:00:52,430 --> 01:00:59,069
[Music]

1021
01:00:55,380 --> 01:00:59,069
so I know that

1022
01:01:07,250 --> 01:01:18,650
so so

1023
01:01:33,500 --> 01:01:48,480
because I'm just the father actually we

1024
01:01:45,480 --> 01:01:51,330
choose theta only at HACC and the risk

1025
01:01:48,480 --> 01:01:54,560
condition attack is based on we have a

1026
01:01:51,330 --> 01:01:57,869
language just like JavaScript it came to

1027
01:01:54,560 --> 01:02:00,240
the first days it can provide us a high

1028
01:01:57,869 --> 01:02:03,150
quality run abilities so it can to

1029
01:02:00,240 --> 01:02:06,868
modify the data in the stack and the

1030
01:02:03,150 --> 01:02:09,320
second is the place there's a

1031
01:02:06,869 --> 01:02:15,140
vulnerability stipends just like the

1032
01:02:09,320 --> 01:02:18,270
exception dispatch oh we will white

1033
01:02:15,140 --> 01:02:21,930
function how problems on purpose so it

1034
01:02:18,270 --> 01:02:24,150
will trigger the exception again again

1035
01:02:21,930 --> 01:02:26,450
and that's which will guarantee a time

1036
01:02:24,150 --> 01:02:30,180
we can change the data on the stack

1037
01:02:26,450 --> 01:02:33,270
because I have no any experience with

1038
01:02:30,180 --> 01:02:37,910
the mobile so I don't know if we thank

1039
01:02:33,270 --> 01:02:37,910
you okay any other questions

1040
01:03:03,470 --> 01:03:11,939
yeah but but in general that the cold we

1041
01:03:09,090 --> 01:03:22,530
showed right that the N branch is right

1042
01:03:11,940 --> 01:03:25,170
within the function cord itself so no

1043
01:03:22,530 --> 01:03:26,460
the the instrumented code and branch is

1044
01:03:25,170 --> 01:03:29,250
inserted by the compiler

1045
01:03:26,460 --> 01:03:33,090
but then CP selphie runs a very small

1046
01:03:29,250 --> 01:03:36,810
state machine but yeah but as you know

1047
01:03:33,090 --> 01:03:39,480
when the call is made and right it will

1048
01:03:36,810 --> 01:03:54,600
the first instruction is that that n

1049
01:03:39,480 --> 01:03:56,430
branch pretty much yeah I think that the

1050
01:03:54,600 --> 01:03:58,410
transfers data is first solo probably we

1051
01:03:56,430 --> 01:04:01,009
can we can talk offline for this

1052
01:03:58,410 --> 01:04:01,009
question yes

1053
01:04:13,880 --> 01:04:25,180
the CFI check you mean the CFG check

1054
01:04:28,240 --> 01:04:35,930
very so yeah so that's a good question

1055
01:04:31,400 --> 01:04:39,190
for the forest condition obviously you

1056
01:04:35,930 --> 01:04:42,710
have to have ways to prevent the

1057
01:04:39,190 --> 01:04:44,900
exception from failing the process there

1058
01:04:42,710 --> 01:04:51,680
are tricks that we have to do so it's

1059
01:04:44,900 --> 01:04:53,960
not described here tricks tricks yes so

1060
01:04:51,680 --> 01:05:01,390
you have to do something with the

1061
01:04:53,960 --> 01:05:01,390
exception of another yeah

1062
01:05:05,410 --> 01:05:12,259
okay yeah thank you all then

1063
01:05:09,140 --> 01:05:12,259
[Applause]

