1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:08,840 --> 00:00:12,000
Cruz and my name is Eric Kraft we're

4
00:00:12,000 --> 00:00:13,980
from guards University of Technology and

5
00:00:13,980 --> 00:00:16,980
the talk was originally submitted also

6
00:00:16,980 --> 00:00:18,779
by Martin schwarzer who cannot be here

7
00:00:18,779 --> 00:00:22,380
because of another appointment and I

8
00:00:22,380 --> 00:00:24,720
thought because I mean you are still a

9
00:00:24,720 --> 00:00:26,760
student Martin a student and I'm a

10
00:00:26,760 --> 00:00:28,140
professor I thought I should wear a

11
00:00:28,140 --> 00:00:30,420
jacket now so that I look a bit more

12
00:00:30,420 --> 00:00:33,420
professional the last time I spoke at

13
00:00:33,420 --> 00:00:35,160
blackhead actually I was a blackhead

14
00:00:35,160 --> 00:00:37,380
Keynotes because not not this year but

15
00:00:37,380 --> 00:00:40,219
at blackhead Asia I think it was in 2020

16
00:00:40,219 --> 00:00:44,780
so I I think that's already

17
00:00:44,780 --> 00:00:47,219
a nice thing to be here also in person

18
00:00:47,219 --> 00:00:49,860
because that was virtual so I'm really

19
00:00:49,860 --> 00:00:52,200
happy to be here

20
00:00:52,200 --> 00:00:56,420
so today we are going to talk about

21
00:00:57,000 --> 00:00:59,160
I don't see the slides yet but it shows

22
00:00:59,160 --> 00:01:02,000
a video stream of us

23
00:01:02,879 --> 00:01:04,920
I have to

24
00:01:04,920 --> 00:01:08,960
Recon check the laptop

25
00:01:09,119 --> 00:01:11,640
let's check the laptop something is not

26
00:01:11,640 --> 00:01:15,439
there on the laptop but this can happen

27
00:01:19,560 --> 00:01:22,080
that's better almost almost perfect

28
00:01:22,080 --> 00:01:24,299
right yeah

29
00:01:24,299 --> 00:01:25,860
nice

30
00:01:25,860 --> 00:01:28,680
okay so we are going to talk about

31
00:01:28,680 --> 00:01:30,840
remote memory deduplication attacks and

32
00:01:30,840 --> 00:01:32,939
remote memory data application attacks

33
00:01:32,939 --> 00:01:34,799
um memory data application has been a

34
00:01:34,799 --> 00:01:38,340
topic for a long time already and

35
00:01:38,340 --> 00:01:41,100
and I know what this bug is yeah I had

36
00:01:41,100 --> 00:01:42,840
this

37
00:01:42,840 --> 00:01:45,740
um let me just

38
00:01:52,500 --> 00:01:55,500
yes now it's back now it should stay

39
00:01:55,500 --> 00:01:56,820
okay

40
00:01:56,820 --> 00:01:58,380
um so remote memory deduplication

41
00:01:58,380 --> 00:02:00,360
attacks um they have been

42
00:02:00,360 --> 00:02:01,860
um yeah that's actually the remote part

43
00:02:01,860 --> 00:02:03,600
is the new part married application

44
00:02:03,600 --> 00:02:06,060
attacks have been around for a long time

45
00:02:06,060 --> 00:02:09,360
um and in this talk we will focus on the

46
00:02:09,360 --> 00:02:11,038
remote scenario

47
00:02:11,038 --> 00:02:13,680
why do we do that because more and more

48
00:02:13,680 --> 00:02:16,500
services are hosted in the cloud or on

49
00:02:16,500 --> 00:02:18,360
remote systems that we use all the time

50
00:02:18,360 --> 00:02:21,660
and they store our secrets yes exactly

51
00:02:21,660 --> 00:02:24,239
so what the providers try to do is they

52
00:02:24,239 --> 00:02:26,220
try to isolate the secrets using

53
00:02:26,220 --> 00:02:28,739
virtualization or similar techniques but

54
00:02:28,739 --> 00:02:30,120
still they share the underlying Hardware

55
00:02:30,120 --> 00:02:32,459
to improve utilization

56
00:02:32,459 --> 00:02:34,620
so and because of that because of the

57
00:02:34,620 --> 00:02:36,720
shared hardware there are yeah multiple

58
00:02:36,720 --> 00:02:39,300
side channels that you can exploit both

59
00:02:39,300 --> 00:02:40,980
in hard and software so for example in

60
00:02:40,980 --> 00:02:42,360
Hardware you could have a cache attack

61
00:02:42,360 --> 00:02:44,519
like Prime and probe or in software like

62
00:02:44,519 --> 00:02:45,840
we present today memory related

63
00:02:45,840 --> 00:02:47,700
application attacks

64
00:02:47,700 --> 00:02:50,340
and another thing is that the network

65
00:02:50,340 --> 00:02:52,080
throughput is increasing and increasing

66
00:02:52,080 --> 00:02:53,700
and the latencies get more stable so

67
00:02:53,700 --> 00:02:56,760
that makes a remote attack more easier

68
00:02:56,760 --> 00:02:58,680
to achieve yeah that's actually a big

69
00:02:58,680 --> 00:03:00,780
problem now because previously we had

70
00:03:00,780 --> 00:03:02,879
these attacks maybe on the same machine

71
00:03:02,879 --> 00:03:04,620
where you had the attacker and the

72
00:03:04,620 --> 00:03:05,879
victim on the same machine but in

73
00:03:05,879 --> 00:03:07,680
different containers or virtual machines

74
00:03:07,680 --> 00:03:12,060
yes or Yeah official attacks running in

75
00:03:12,060 --> 00:03:14,459
a pro setup in JavaScript exactly yeah

76
00:03:14,459 --> 00:03:18,239
or what we look at now on the network so

77
00:03:18,239 --> 00:03:20,099
we want to attack a system where we

78
00:03:20,099 --> 00:03:23,700
don't run a single line of code

79
00:03:23,700 --> 00:03:25,560
the other system is not under our

80
00:03:25,560 --> 00:03:27,720
control we just send Network requests

81
00:03:27,720 --> 00:03:29,519
there and we still want to leak all the

82
00:03:29,519 --> 00:03:31,860
secrets do you think that's possible oh

83
00:03:31,860 --> 00:03:33,480
it sounds it sounds really strange and

84
00:03:33,480 --> 00:03:36,000
nobody unrated yet so yeah yeah but

85
00:03:36,000 --> 00:03:38,580
probably it worked we got a cve so let's

86
00:03:38,580 --> 00:03:39,659
continue

87
00:03:39,659 --> 00:03:41,459
um memory did application

88
00:03:41,459 --> 00:03:43,860
um why do we why do we want to talk

89
00:03:43,860 --> 00:03:45,120
about this

90
00:03:45,120 --> 00:03:47,640
um memory deed application was disabled

91
00:03:47,640 --> 00:03:49,260
after the first wave of memory

92
00:03:49,260 --> 00:03:51,720
deduplication attacks Linux disabled it

93
00:03:51,720 --> 00:03:53,819
Windows disabled it and then later on

94
00:03:53,819 --> 00:03:57,000
they realized oh but we could re-enable

95
00:03:57,000 --> 00:04:00,360
it if we add some security around it

96
00:04:00,360 --> 00:04:03,120
and today it is also used still in

97
00:04:03,120 --> 00:04:04,920
Virtual machines we have also talked

98
00:04:04,920 --> 00:04:07,920
with providers there and the current

99
00:04:07,920 --> 00:04:10,260
mitigation there what is the current

100
00:04:10,260 --> 00:04:12,299
mitigation current mitigation just

101
00:04:12,299 --> 00:04:14,700
prevents it between security domains but

102
00:04:14,700 --> 00:04:16,440
not inside the security domain so they

103
00:04:16,440 --> 00:04:18,298
don't consider a local attacker in the

104
00:04:18,298 --> 00:04:20,519
in their thread a remote remote deck in

105
00:04:20,519 --> 00:04:22,320
the thread model exactly so the data

106
00:04:22,320 --> 00:04:24,900
application still works within the same

107
00:04:24,900 --> 00:04:27,300
security domain right because you say oh

108
00:04:27,300 --> 00:04:29,220
they the pages belong to the same

109
00:04:29,220 --> 00:04:31,199
security domain shouldn't hurt to

110
00:04:31,199 --> 00:04:33,780
de-duplicate them but can we maybe

111
00:04:33,780 --> 00:04:36,960
exploit that across the internet and

112
00:04:36,960 --> 00:04:39,180
that's the big question of this talk but

113
00:04:39,180 --> 00:04:41,160
before let's take a step back and talk

114
00:04:41,160 --> 00:04:43,440
about how memory did application works

115
00:04:43,440 --> 00:04:45,479
so we see here setup we see on the left

116
00:04:45,479 --> 00:04:47,759
side there is the attacker process the

117
00:04:47,759 --> 00:04:49,199
virtual address space of the attacker

118
00:04:49,199 --> 00:04:50,699
process on the right side there's the

119
00:04:50,699 --> 00:04:52,080
virtual address space of the victim

120
00:04:52,080 --> 00:04:54,360
process and Below you see the shared

121
00:04:54,360 --> 00:04:56,639
physical address space and you see some

122
00:04:56,639 --> 00:04:58,259
pages that are color coded and the

123
00:04:58,259 --> 00:04:59,699
colors stand for the contents of the

124
00:04:59,699 --> 00:05:01,860
pages so the pages with the same color

125
00:05:01,860 --> 00:05:03,479
have the same content

126
00:05:03,479 --> 00:05:06,600
and what can now happen is you see you

127
00:05:06,600 --> 00:05:08,160
see of course every virtual page is

128
00:05:08,160 --> 00:05:09,960
mapped to a physical page and that's um

129
00:05:09,960 --> 00:05:12,320
yeah Illustrated with the stashed line

130
00:05:12,320 --> 00:05:15,000
and what now can happen is that the

131
00:05:15,000 --> 00:05:17,040
Decker creates a page with the same

132
00:05:17,040 --> 00:05:18,240
content

133
00:05:18,240 --> 00:05:20,940
like here now he has also created the

134
00:05:20,940 --> 00:05:23,220
page with the blue content let's say and

135
00:05:23,220 --> 00:05:25,740
then on a operating system with memory

136
00:05:25,740 --> 00:05:28,139
data application from time to time a

137
00:05:28,139 --> 00:05:29,940
kernel thread will start scanning the

138
00:05:29,940 --> 00:05:32,759
physical address space so for example he

139
00:05:32,759 --> 00:05:34,919
compares the first page to the other

140
00:05:34,919 --> 00:05:36,780
pages and as long as they don't match

141
00:05:36,780 --> 00:05:38,400
nothing will happen and he will just

142
00:05:38,400 --> 00:05:40,740
continue scanning but if he comes to a

143
00:05:40,740 --> 00:05:42,960
page where the content matches he will

144
00:05:42,960 --> 00:05:45,780
match these two pages by um modifying

145
00:05:45,780 --> 00:05:47,639
the mapping so they point to one of them

146
00:05:47,639 --> 00:05:50,340
and set them to copy on right so they

147
00:05:50,340 --> 00:05:52,860
are this page is then read only and has

148
00:05:52,860 --> 00:05:55,500
the and has the same physical physical

149
00:05:55,500 --> 00:05:58,440
address like shown here yeah and this

150
00:05:58,440 --> 00:06:01,560
also gives us a perfect Oracle to tell

151
00:06:01,560 --> 00:06:04,080
whether the victim has a page with

152
00:06:04,080 --> 00:06:07,800
exactly that content somewhere in memory

153
00:06:07,800 --> 00:06:10,320
so what can we do there we can now you

154
00:06:10,320 --> 00:06:12,539
set a copy on right semantics that we

155
00:06:12,539 --> 00:06:14,580
have here we can exploit those we can

156
00:06:14,580 --> 00:06:17,520
time how long it takes to write to this

157
00:06:17,520 --> 00:06:21,240
page exactly and then we learn well the

158
00:06:21,240 --> 00:06:22,979
operating system has to copy this back

159
00:06:22,979 --> 00:06:25,740
and then we learn oh this was a slow

160
00:06:25,740 --> 00:06:28,020
ride access this page was deduplicated

161
00:06:28,020 --> 00:06:30,180
so what we do here is we measure all the

162
00:06:30,180 --> 00:06:33,479
time this Delta between end and start

163
00:06:33,479 --> 00:06:35,160
for the right access

164
00:06:35,160 --> 00:06:38,160
and this tells us whether the page was

165
00:06:38,160 --> 00:06:41,039
copy on right or not but maybe we should

166
00:06:41,039 --> 00:06:43,319
have a look at the timings here how how

167
00:06:43,319 --> 00:06:46,080
far are they really apart yes so let's

168
00:06:46,080 --> 00:06:47,819
first look at the local timings because

169
00:06:47,819 --> 00:06:49,860
we don't want to start with the network

170
00:06:49,860 --> 00:06:52,800
yet so what we see here locally you see

171
00:06:52,800 --> 00:06:55,319
the blue the blue and pages are not copy

172
00:06:55,319 --> 00:06:57,600
and write marked and the red ones are

173
00:06:57,600 --> 00:06:59,699
copy and write exists and you see it's

174
00:06:59,699 --> 00:07:01,800
easily distinguishable locally so there

175
00:07:01,800 --> 00:07:04,259
is a microsecond between those two a gap

176
00:07:04,259 --> 00:07:05,759
where there's really nothing in between

177
00:07:05,759 --> 00:07:08,220
so that's very easy to do so you really

178
00:07:08,220 --> 00:07:10,259
see this this small bar down there

179
00:07:10,259 --> 00:07:12,720
that's the the non-copy and write case

180
00:07:12,720 --> 00:07:14,880
it's a small blue blue yeah so this is

181
00:07:14,880 --> 00:07:17,280
very very easy to distinguish I think I

182
00:07:17,280 --> 00:07:19,380
can give that to a first semester yeah

183
00:07:19,380 --> 00:07:21,539
everybody can do that yeah

184
00:07:21,539 --> 00:07:24,660
so how does our attack then work across

185
00:07:24,660 --> 00:07:26,539
the network because we we can't create

186
00:07:26,539 --> 00:07:30,840
pages in the victim domain can we yeah

187
00:07:30,840 --> 00:07:32,880
you can if the victim domain runs the

188
00:07:32,880 --> 00:07:35,160
server a server application that allows

189
00:07:35,160 --> 00:07:37,680
you to do such things so in our setup we

190
00:07:37,680 --> 00:07:39,479
have the attacker now separated by a

191
00:07:39,479 --> 00:07:41,460
network from the victim so he has no

192
00:07:41,460 --> 00:07:43,380
chance to execute any code locally he

193
00:07:43,380 --> 00:07:46,080
can just use the apis that are offered

194
00:07:46,080 --> 00:07:48,300
to the outside and what you see in the

195
00:07:48,300 --> 00:07:50,400
top this is the physical memory of the

196
00:07:50,400 --> 00:07:52,800
victim and there is a two pages and

197
00:07:52,800 --> 00:07:54,599
let's say the attacker wants to know if

198
00:07:54,599 --> 00:07:57,120
page a is in memory for example he wants

199
00:07:57,120 --> 00:07:58,919
to fingerprint the library and then

200
00:07:58,919 --> 00:08:01,199
takes a and this is a unique page of

201
00:08:01,199 --> 00:08:03,419
this library and he wants to use

202
00:08:03,419 --> 00:08:05,520
exploited to know if this library is in

203
00:08:05,520 --> 00:08:06,419
the memory

204
00:08:06,419 --> 00:08:08,819
so what the decadent needs to do and

205
00:08:08,819 --> 00:08:10,259
what the victim needs to offer is

206
00:08:10,259 --> 00:08:12,960
firstly the deck has to be able to send

207
00:08:12,960 --> 00:08:15,780
the data the page to the victim and the

208
00:08:15,780 --> 00:08:17,580
victim has to store it page aligned in

209
00:08:17,580 --> 00:08:18,720
in the memory

210
00:08:18,720 --> 00:08:21,120
and also keep it there

211
00:08:21,120 --> 00:08:24,300
the second second thing is

212
00:08:24,300 --> 00:08:25,860
that

213
00:08:25,860 --> 00:08:28,199
the then after some time the data

214
00:08:28,199 --> 00:08:29,819
application will run and the two pages

215
00:08:29,819 --> 00:08:32,099
are merged and marked copy on right yeah

216
00:08:32,099 --> 00:08:34,200
so in this case then A and B would be

217
00:08:34,200 --> 00:08:36,240
deduplicated within the same security

218
00:08:36,240 --> 00:08:38,880
domain right yes exactly

219
00:08:38,880 --> 00:08:42,240
so why is that a security problem now

220
00:08:42,240 --> 00:08:45,480
yeah it's if if the attacker is also

221
00:08:45,480 --> 00:08:47,279
able to basically overwrite the same

222
00:08:47,279 --> 00:08:49,620
page then he will see a timing

223
00:08:49,620 --> 00:08:51,839
difference you mean in place in place

224
00:08:51,839 --> 00:08:54,660
with an update operation exactly ah but

225
00:08:54,660 --> 00:08:56,880
there might be an update operation yeah

226
00:08:56,880 --> 00:08:59,760
sure many web apis offer such things so

227
00:08:59,760 --> 00:09:03,060
that's really bad so that means that the

228
00:09:03,060 --> 00:09:06,480
victim will now write to page B again

229
00:09:06,480 --> 00:09:08,940
will update it and this triggers copy on

230
00:09:08,940 --> 00:09:09,600
right

231
00:09:09,600 --> 00:09:12,779
and this can be measured by the attacker

232
00:09:12,779 --> 00:09:15,000
yes yeah but sure you have the network

233
00:09:15,000 --> 00:09:17,040
noise but you just do it more often than

234
00:09:17,040 --> 00:09:19,200
anything yeah yeah but but this will not

235
00:09:19,200 --> 00:09:21,180
work over the Internet over a realistic

236
00:09:21,180 --> 00:09:22,920
setup over the Internet this cannot work

237
00:09:22,920 --> 00:09:25,019
this is like the difference in Nanos

238
00:09:25,019 --> 00:09:27,540
we're the nanoseconds yeah cannot work

239
00:09:27,540 --> 00:09:29,220
yeah we will see

240
00:09:29,220 --> 00:09:31,680
so did you try that out yes we'd write

241
00:09:31,680 --> 00:09:36,319
it out yeah oh and don't you remember

242
00:09:36,860 --> 00:09:39,899
yeah so yes we tried it out on the on a

243
00:09:39,899 --> 00:09:41,940
remote server over 14 hops over the

244
00:09:41,940 --> 00:09:43,500
Internet

245
00:09:43,500 --> 00:09:45,120
um yeah so we have a very high latency

246
00:09:45,120 --> 00:09:46,200
there

247
00:09:46,200 --> 00:09:48,959
um and we detect a KVM setup uh on a

248
00:09:48,959 --> 00:09:52,140
Ubuntu or Ubuntu virtual machine and KVM

249
00:09:52,140 --> 00:09:54,120
um and there we had a service running

250
00:09:54,120 --> 00:09:56,940
just off the shelf engine engine x with

251
00:09:56,940 --> 00:09:59,339
PHP with memcache d and with myosql

252
00:09:59,339 --> 00:10:00,540
installed

253
00:10:00,540 --> 00:10:04,140
um and then we also used uh Pi shark to

254
00:10:04,140 --> 00:10:07,700
capture the web request exactly yeah

255
00:10:07,700 --> 00:10:10,740
but still the 14 hops across the

256
00:10:10,740 --> 00:10:12,000
internet this will have latency

257
00:10:12,000 --> 00:10:13,980
variation in the range of milliseconds

258
00:10:13,980 --> 00:10:15,899
how can that possibly work

259
00:10:15,899 --> 00:10:17,760
yeah and that's one of the problems so

260
00:10:17,760 --> 00:10:20,519
you would need many many requests to to

261
00:10:20,519 --> 00:10:22,500
be able to distinguish it with this

262
00:10:22,500 --> 00:10:25,140
setup so one thing you need to do is you

263
00:10:25,140 --> 00:10:26,640
have to amplify this you have to make

264
00:10:26,640 --> 00:10:29,700
multiple how excesses during one remote

265
00:10:29,700 --> 00:10:31,620
request to see the difference more

266
00:10:31,620 --> 00:10:34,200
easily so that the time becomes less and

267
00:10:34,200 --> 00:10:37,080
it's more realistic setup so what we do

268
00:10:37,080 --> 00:10:38,700
we use amplification across the internet

269
00:10:38,700 --> 00:10:40,620
and like I said you basically just

270
00:10:40,620 --> 00:10:42,720
increase the amount of pages you

271
00:10:42,720 --> 00:10:44,700
override that are marked with copy and

272
00:10:44,700 --> 00:10:46,680
right for fingerprinting libraries this

273
00:10:46,680 --> 00:10:48,420
is easy to do you just take multiple

274
00:10:48,420 --> 00:10:50,339
unique pages from the Library store it

275
00:10:50,339 --> 00:10:52,560
in the in the server and then overwrite

276
00:10:52,560 --> 00:10:55,140
them at once with one request

277
00:10:55,140 --> 00:10:59,100
so and for a cover Channel you can also

278
00:10:59,100 --> 00:11:01,500
just you can just amplify it by storing

279
00:11:01,500 --> 00:11:03,360
more and you can also transmit multiple

280
00:11:03,360 --> 00:11:06,540
bytes in parallel by just storing more

281
00:11:06,540 --> 00:11:09,060
and we did we did the request of async

282
00:11:09,060 --> 00:11:11,040
IO because it's faster than doing

283
00:11:11,040 --> 00:11:13,680
sequential requests and then we reach

284
00:11:13,680 --> 00:11:16,680
the cover Channel which has around 35

285
00:11:16,680 --> 00:11:18,360
bytes per hour

286
00:11:18,360 --> 00:11:21,300
well actually 34 bytes per hour

287
00:11:21,300 --> 00:11:23,399
how fast is that in comparison to other

288
00:11:23,399 --> 00:11:24,480
channels

289
00:11:24,480 --> 00:11:28,019
so not very fast right now if you look

290
00:11:28,019 --> 00:11:30,000
at remote channels it's it's not bad

291
00:11:30,000 --> 00:11:33,120
okay so take a look at remote channels

292
00:11:33,120 --> 00:11:37,140
then so here we have some of the covert

293
00:11:37,140 --> 00:11:39,240
channels that we had so far with PhD

294
00:11:39,240 --> 00:11:41,519
duplication and if we take a look there

295
00:11:41,519 --> 00:11:43,320
then you see that some of them were

296
00:11:43,320 --> 00:11:46,260
already remote but usually that meant

297
00:11:46,260 --> 00:11:48,079
that they were running in a remote

298
00:11:48,079 --> 00:11:51,120
controlled environment like a browser or

299
00:11:51,120 --> 00:11:55,500
a cross VM or again the browser and that

300
00:11:55,500 --> 00:11:57,660
means there was still code running

301
00:11:57,660 --> 00:12:00,240
locally on that machine

302
00:12:00,240 --> 00:12:02,519
so that's different in our attack where

303
00:12:02,519 --> 00:12:04,079
we don't run a single line of

304
00:12:04,079 --> 00:12:05,820
attacker-controlled code on that machine

305
00:12:05,820 --> 00:12:08,160
so we have no local execution of

306
00:12:08,160 --> 00:12:11,399
whatever type and we still are able to

307
00:12:11,399 --> 00:12:16,920
leak quite a lot of data over an hour

308
00:12:16,920 --> 00:12:18,839
yeah so maybe

309
00:12:18,839 --> 00:12:20,640
um yeah maybe let's also mention here we

310
00:12:20,640 --> 00:12:22,560
can mount different attacks here it says

311
00:12:22,560 --> 00:12:24,480
bytewise leakage case allow brick and

312
00:12:24,480 --> 00:12:26,820
fingerprinting maybe we can go through

313
00:12:26,820 --> 00:12:29,760
these attacks also but before we do that

314
00:12:29,760 --> 00:12:31,920
we should pinpoint what are the

315
00:12:31,920 --> 00:12:35,160
challenges to mount these attacks

316
00:12:35,160 --> 00:12:37,980
the challenge the first challenge is to

317
00:12:37,980 --> 00:12:40,440
amplify the latency yes Eric just

318
00:12:40,440 --> 00:12:41,760
explained

319
00:12:41,760 --> 00:12:43,980
um and the Second Challenge we also

320
00:12:43,980 --> 00:12:46,380
mentioned already we need to trigger and

321
00:12:46,380 --> 00:12:48,899
observe those copy on right page Folds

322
00:12:48,899 --> 00:12:51,420
while not sharing any memory with the

323
00:12:51,420 --> 00:12:52,860
attacker domain

324
00:12:52,860 --> 00:12:55,440
yes exactly and the last the last

325
00:12:55,440 --> 00:12:57,000
challenge that is not really necessary

326
00:12:57,000 --> 00:12:58,800
for fingerprinting or cover channel for

327
00:12:58,800 --> 00:13:01,560
example is to find remote Buffs that not

328
00:13:01,560 --> 00:13:03,180
only allow you to store the state in a

329
00:13:03,180 --> 00:13:05,639
page length way so but also to change

330
00:13:05,639 --> 00:13:07,680
the alignment of the of the data you

331
00:13:07,680 --> 00:13:09,420
want to leak and this gives you then

332
00:13:09,420 --> 00:13:11,339
more powerful attacks like bitewise

333
00:13:11,339 --> 00:13:13,980
leakage of data from from a database

334
00:13:13,980 --> 00:13:15,899
so can we take a look at the first

335
00:13:15,899 --> 00:13:18,360
challenge maybe do you have any data for

336
00:13:18,360 --> 00:13:20,220
that how well that works yes we

337
00:13:20,220 --> 00:13:22,980
collected a plot which shows basically

338
00:13:22,980 --> 00:13:24,180
if you increase the number of

339
00:13:24,180 --> 00:13:26,880
deduplicated pages the time increases

340
00:13:26,880 --> 00:13:28,440
linearly with that

341
00:13:28,440 --> 00:13:30,240
so that's very nice so you can just

342
00:13:30,240 --> 00:13:32,579
increase the number of data of pages

343
00:13:32,579 --> 00:13:35,279
that are deduplicated and then you get a

344
00:13:35,279 --> 00:13:37,680
nice simplifications out of there and

345
00:13:37,680 --> 00:13:39,300
this scales linearly so you can

346
00:13:39,300 --> 00:13:41,160
basically scale it to any number of

347
00:13:41,160 --> 00:13:43,200
microseconds or even milliseconds that

348
00:13:43,200 --> 00:13:45,300
you need yes for your measurement okay

349
00:13:45,300 --> 00:13:48,120
so that sounds bad but there are two

350
00:13:48,120 --> 00:13:49,860
more challenges maybe we figure out we

351
00:13:49,860 --> 00:13:51,660
can't solve them and then we're good

352
00:13:51,660 --> 00:13:55,500
right so um let's let's try the Second

353
00:13:55,500 --> 00:13:57,600
Challenge so how do you trigger those

354
00:13:57,600 --> 00:13:59,220
copy and write page faults without

355
00:13:59,220 --> 00:14:01,560
shared memory so there are multiple

356
00:14:01,560 --> 00:14:03,720
possibilities some websites of a file

357
00:14:03,720 --> 00:14:06,180
upload and files are buffered in the

358
00:14:06,180 --> 00:14:07,680
page cache which is part of the physical

359
00:14:07,680 --> 00:14:10,019
memory and if there is also an overwrite

360
00:14:10,019 --> 00:14:12,060
operation offered then you can already

361
00:14:12,060 --> 00:14:16,019
use this as a as a possible solution

362
00:14:16,019 --> 00:14:18,839
and we tried this with for instance with

363
00:14:18,839 --> 00:14:22,019
memcache yes data will be cached in Ram

364
00:14:22,019 --> 00:14:25,680
so it's not written back to disk and the

365
00:14:25,680 --> 00:14:28,620
attacker can update or overwrite the

366
00:14:28,620 --> 00:14:30,300
uploaded data and with that trigger

367
00:14:30,300 --> 00:14:32,279
those page Folds

368
00:14:32,279 --> 00:14:34,500
well again the question how well does

369
00:14:34,500 --> 00:14:37,079
that work exactly if you combine that

370
00:14:37,079 --> 00:14:38,880
with the amplification we have another

371
00:14:38,880 --> 00:14:40,920
plot for that

372
00:14:40,920 --> 00:14:43,980
and here you can see how the accuracy

373
00:14:43,980 --> 00:14:46,560
goes up with the number of requests that

374
00:14:46,560 --> 00:14:48,779
you make and also for different

375
00:14:48,779 --> 00:14:51,300
amplification factors yes and there are

376
00:14:51,300 --> 00:14:52,680
some very sweet spots so you don't want

377
00:14:52,680 --> 00:14:54,660
to send too much requests and you don't

378
00:14:54,660 --> 00:14:56,360
want it to have too much

379
00:14:56,360 --> 00:14:58,920
amplification because it also makes you

380
00:14:58,920 --> 00:15:00,959
have to send more data but there is a

381
00:15:00,959 --> 00:15:02,339
spot where you have a sensible

382
00:15:02,339 --> 00:15:05,519
amplifications like 8 or 16 and the

383
00:15:05,519 --> 00:15:08,220
still low number of requests and with a

384
00:15:08,220 --> 00:15:11,399
high accuracy but here you see it still

385
00:15:11,399 --> 00:15:13,440
says local network I haven't still

386
00:15:13,440 --> 00:15:15,839
haven't seen a network internet based

387
00:15:15,839 --> 00:15:18,420
attack here so maybe this will follow

388
00:15:18,420 --> 00:15:20,880
later let's also talk about the

389
00:15:20,880 --> 00:15:23,699
fingerprinting case we can fingerprint a

390
00:15:23,699 --> 00:15:27,120
system now by uploading memory

391
00:15:27,120 --> 00:15:30,480
so if we do that for instance upload a

392
00:15:30,480 --> 00:15:32,940
page that also appears in some specific

393
00:15:32,940 --> 00:15:35,940
binary version then of course our Oracle

394
00:15:35,940 --> 00:15:38,160
tells us whether the server is running

395
00:15:38,160 --> 00:15:40,740
that specific binary version

396
00:15:40,740 --> 00:15:42,360
maybe that could also be useful

397
00:15:42,360 --> 00:15:44,399
information and there again we use

398
00:15:44,399 --> 00:15:46,860
memcache D to store and replace the data

399
00:15:46,860 --> 00:15:49,800
and then we can think about that there's

400
00:15:49,800 --> 00:15:52,380
one more challenge with memcachd so it

401
00:15:52,380 --> 00:15:54,779
stores the the items are stored in

402
00:15:54,779 --> 00:15:56,459
blocks of one megabyte and you don't

403
00:15:56,459 --> 00:15:58,139
really know which alignment the items

404
00:15:58,139 --> 00:16:00,300
use the attacker stores has in there but

405
00:16:00,300 --> 00:16:01,800
you can pre-compute it and then

406
00:16:01,800 --> 00:16:05,040
basically just store the uh these the

407
00:16:05,040 --> 00:16:06,920
attacker Control Data with all possible

408
00:16:06,920 --> 00:16:10,620
alignments and then you you have always

409
00:16:10,620 --> 00:16:12,839
wanted get C duplicated

410
00:16:12,839 --> 00:16:14,399
yeah

411
00:16:14,399 --> 00:16:15,720
um so

412
00:16:15,720 --> 00:16:18,600
um also a problem here might be this

413
00:16:18,600 --> 00:16:20,880
free list

414
00:16:20,880 --> 00:16:22,139
yes

415
00:16:22,139 --> 00:16:24,360
so you cannot really directly overwrite

416
00:16:24,360 --> 00:16:27,120
data but you have to if you overwrite it

417
00:16:27,120 --> 00:16:28,440
send another request and it comes on

418
00:16:28,440 --> 00:16:30,000
your free list and then you have to send

419
00:16:30,000 --> 00:16:31,560
another request that then finally

420
00:16:31,560 --> 00:16:33,660
overwrites it yeah so basically somebody

421
00:16:33,660 --> 00:16:36,000
could interfere with this so it's sort

422
00:16:36,000 --> 00:16:37,680
of a race condition yeah exactly but

423
00:16:37,680 --> 00:16:39,600
it's do a bit so let's take a look at

424
00:16:39,600 --> 00:16:41,519
how well this works the fingerprinting

425
00:16:41,519 --> 00:16:44,100
over local I guess it's over local area

426
00:16:44,100 --> 00:16:46,320
network again yeah first of course okay

427
00:16:46,320 --> 00:16:48,600
so here you can see it

428
00:16:48,600 --> 00:16:51,120
um and you see that a timing histogram

429
00:16:51,120 --> 00:16:53,519
here for the non-copy on write case so

430
00:16:53,519 --> 00:16:55,500
where the attacker didn't guess

431
00:16:55,500 --> 00:16:56,779
correctly

432
00:16:56,779 --> 00:16:59,940
and the number of requests that you that

433
00:16:59,940 --> 00:17:03,000
you have on the y-axis and here the copy

434
00:17:03,000 --> 00:17:04,380
on right case

435
00:17:04,380 --> 00:17:06,780
yes so this is the case where the

436
00:17:06,780 --> 00:17:09,959
attacker found a page that exists like

437
00:17:09,959 --> 00:17:12,359
this on the system so we can clearly

438
00:17:12,359 --> 00:17:14,400
distinguish those two cases based on the

439
00:17:14,400 --> 00:17:17,040
histograms but what about the internet

440
00:17:17,040 --> 00:17:19,319
yeah let's take a look at it so as

441
00:17:19,319 --> 00:17:21,240
before we have the non-copy and write

442
00:17:21,240 --> 00:17:22,260
case

443
00:17:22,260 --> 00:17:24,839
and you need more requests here yeah

444
00:17:24,839 --> 00:17:27,299
that's the first thing you you see you

445
00:17:27,299 --> 00:17:29,640
already need more requests and also the

446
00:17:29,640 --> 00:17:31,500
timing is larger of course

447
00:17:31,500 --> 00:17:34,679
but then let's look also at the Cow case

448
00:17:34,679 --> 00:17:37,020
and yeah I mean still you can

449
00:17:37,020 --> 00:17:39,179
distinguish it it's not so nice but

450
00:17:39,179 --> 00:17:41,220
still possible it has more noise but

451
00:17:41,220 --> 00:17:43,500
it's still possible yeah okay but that's

452
00:17:43,500 --> 00:17:45,179
only fingerprinting that's not a real

453
00:17:45,179 --> 00:17:46,980
good attack yet can you do something

454
00:17:46,980 --> 00:17:49,559
like Breaking kslr remotely without

455
00:17:49,559 --> 00:17:51,360
running a single line of code on that

456
00:17:51,360 --> 00:17:55,080
system yes okay and let's do that so we

457
00:17:55,080 --> 00:17:56,460
want to break case that are in remote

458
00:17:56,460 --> 00:18:00,299
VMS and what is the idea there so the

459
00:18:00,299 --> 00:18:03,120
idea is you search pages in the in the

460
00:18:03,120 --> 00:18:05,820
kernel text that are static except some

461
00:18:05,820 --> 00:18:08,580
point to the context itself and then you

462
00:18:08,580 --> 00:18:11,400
basically only have to try all 512

463
00:18:11,400 --> 00:18:13,260
different possibilities the kernel decks

464
00:18:13,260 --> 00:18:15,900
can get from the from the aslr

465
00:18:15,900 --> 00:18:18,539
and so that's a page that contains

466
00:18:18,539 --> 00:18:20,700
basically all predictable data and just

467
00:18:20,700 --> 00:18:21,980
these yeah

468
00:18:21,980 --> 00:18:25,080
yeah okay yeah so you have only two

469
00:18:25,080 --> 00:18:26,880
guess the pointer different pointer

470
00:18:26,880 --> 00:18:29,400
possibility possibilities and yeah then

471
00:18:29,400 --> 00:18:31,320
you have it but I can parallel that

472
00:18:31,320 --> 00:18:33,600
rather than parallel exactly you can

473
00:18:33,600 --> 00:18:36,299
just upload your 512 cases then

474
00:18:36,299 --> 00:18:38,460
overwrite them and see who which one has

475
00:18:38,460 --> 00:18:40,320
the largest time you may have to repeat

476
00:18:40,320 --> 00:18:42,000
this a few times because of the noises

477
00:18:42,000 --> 00:18:44,340
we saw but then you have this okay so

478
00:18:44,340 --> 00:18:46,080
this attack will be very slow it will

479
00:18:46,080 --> 00:18:48,419
take ages then I guess so the attacker

480
00:18:48,419 --> 00:18:50,760
uploads some data triggers the page

481
00:18:50,760 --> 00:18:53,400
faults and that's it so so how well does

482
00:18:53,400 --> 00:18:54,600
it work

483
00:18:54,600 --> 00:18:57,720
works very well I would say but

484
00:18:57,720 --> 00:19:00,000
let's see let's look at at the picture

485
00:19:00,000 --> 00:19:02,520
so I guess everybody can see which is

486
00:19:02,520 --> 00:19:04,799
the right kernel offset here it's not

487
00:19:04,799 --> 00:19:07,200
too complicated yeah so the one at the

488
00:19:07,200 --> 00:19:09,000
on the left where the timing is high

489
00:19:09,000 --> 00:19:10,740
yeah where we clearly got a copy on

490
00:19:10,740 --> 00:19:13,080
right uh fault

491
00:19:13,080 --> 00:19:13,679
um

492
00:19:13,679 --> 00:19:15,539
yeah and overall there's a time this

493
00:19:15,539 --> 00:19:17,940
this attack also is very very fast if

494
00:19:17,940 --> 00:19:20,760
you uh seconds minutes minutes low four

495
00:19:20,760 --> 00:19:23,520
minutes so it's yeah really nice so this

496
00:19:23,520 --> 00:19:25,080
is really nice

497
00:19:25,080 --> 00:19:27,299
um but then we have a third Challenge

498
00:19:27,299 --> 00:19:29,700
and this one is tricky to really leak

499
00:19:29,700 --> 00:19:32,280
data bite by bite

500
00:19:32,280 --> 00:19:35,039
and there we focused on a setup with

501
00:19:35,039 --> 00:19:36,720
nodp

502
00:19:36,720 --> 00:19:39,299
um a database management system for

503
00:19:39,299 --> 00:19:42,000
instance used in MySQL mariadp

504
00:19:42,000 --> 00:19:45,120
um so what do we exploit there in nodp

505
00:19:45,120 --> 00:19:48,000
so innov has an optimization it's called

506
00:19:48,000 --> 00:19:51,840
reorganization it is used if the free

507
00:19:51,840 --> 00:19:54,179
space is too fragmented into index page

508
00:19:54,179 --> 00:19:56,700
that a new record would fit in there and

509
00:19:56,700 --> 00:19:59,039
then it basically rebuilds this page by

510
00:19:59,039 --> 00:20:01,140
inserting all all records again in The

511
00:20:01,140 --> 00:20:03,120
Logical order and then inserting the

512
00:20:03,120 --> 00:20:05,460
updated record and then the deck can

513
00:20:05,460 --> 00:20:07,799
exploit this optimization to basically

514
00:20:07,799 --> 00:20:11,100
control the alignment of a secret record

515
00:20:11,100 --> 00:20:12,480
and

516
00:20:12,480 --> 00:20:16,220
yeah foreign

517
00:20:18,740 --> 00:20:22,740
method because we didn't with innodb did

518
00:20:22,740 --> 00:20:24,960
not work because of some inner inner

519
00:20:24,960 --> 00:20:27,419
problems in OTP with the storing yeah

520
00:20:27,419 --> 00:20:28,980
but it's still fine yeah it's still fine

521
00:20:28,980 --> 00:20:30,780
I mean you can use anything for leaking

522
00:20:30,780 --> 00:20:33,299
that you want yes yeah

523
00:20:33,299 --> 00:20:35,280
so in ODB

524
00:20:35,280 --> 00:20:36,960
maybe we go a bit more into the

525
00:20:36,960 --> 00:20:41,039
technical technical details there so

526
00:20:41,039 --> 00:20:43,020
that we talk a bit about the innodb

527
00:20:43,020 --> 00:20:45,240
records that we exploit them

528
00:20:45,240 --> 00:20:47,220
so what do they look like so they have

529
00:20:47,220 --> 00:20:49,140
some headers some footer what is the

530
00:20:49,140 --> 00:20:50,940
interesting part of this innodb record

531
00:20:50,940 --> 00:20:52,799
so the thing is you know the V stores

532
00:20:52,799 --> 00:20:54,419
record in this index features which are

533
00:20:54,419 --> 00:20:56,700
610 kilobytes 16 kilobytes large and as

534
00:20:56,700 --> 00:20:57,720
you said there's some head and some

535
00:20:57,720 --> 00:20:59,220
footer but we don't care about that in

536
00:20:59,220 --> 00:21:01,679
between there are the actual records and

537
00:21:01,679 --> 00:21:03,600
what we see here we have one record Rd

538
00:21:03,600 --> 00:21:06,000
that's the the record the attacker wants

539
00:21:06,000 --> 00:21:08,520
to leak and before we have to attack a

540
00:21:08,520 --> 00:21:10,200
control records so the attacker has to

541
00:21:10,200 --> 00:21:12,059
before insert these two records but it

542
00:21:12,059 --> 00:21:13,380
does not really matter if there's a gap

543
00:21:13,380 --> 00:21:15,720
between them and the secret record this

544
00:21:15,720 --> 00:21:17,940
just have to be before there

545
00:21:17,940 --> 00:21:20,039
and what also what you also see at the

546
00:21:20,039 --> 00:21:21,480
end is the trailing free space so always

547
00:21:21,480 --> 00:21:23,100
when you update and record I want to

548
00:21:23,100 --> 00:21:25,740
insert a new record then into the B

549
00:21:25,740 --> 00:21:27,539
tries to insert it into the three space

550
00:21:27,539 --> 00:21:29,880
except it is it is smaller than before

551
00:21:29,880 --> 00:21:32,159
then it does it in place but in every

552
00:21:32,159 --> 00:21:34,500
other case it tries to insert it there

553
00:21:34,500 --> 00:21:37,380
okay so that means you can somehow place

554
00:21:37,380 --> 00:21:40,260
the victim data right next to your data

555
00:21:40,260 --> 00:21:42,240
or even in between

556
00:21:42,240 --> 00:21:44,820
yes and that's also what the attack does

557
00:21:44,820 --> 00:21:48,780
then so we place this data in between

558
00:21:48,780 --> 00:21:51,780
yeah yeah exactly but I mean by updating

559
00:21:51,780 --> 00:21:53,640
the records the Decker can

560
00:21:53,640 --> 00:21:56,940
can get this reorganization running and

561
00:21:56,940 --> 00:21:58,740
then it what happens is that it

562
00:21:58,740 --> 00:22:00,720
reorganizes the page and then you have

563
00:22:00,720 --> 00:22:02,400
your alignment record before the target

564
00:22:02,400 --> 00:22:03,419
somewhere

565
00:22:03,419 --> 00:22:06,179
and by changing the the size of this

566
00:22:06,179 --> 00:22:07,919
alignment record you can move move

567
00:22:07,919 --> 00:22:09,780
around move it around and change its

568
00:22:09,780 --> 00:22:12,840
alignment yeah that's right

569
00:22:12,840 --> 00:22:16,080
um so we maybe we go a step further I

570
00:22:16,080 --> 00:22:18,000
mean at the end then we have this reset

571
00:22:18,000 --> 00:22:19,880
State and then we can repeat the attack

572
00:22:19,880 --> 00:22:22,679
after that but let's go one step further

573
00:22:22,679 --> 00:22:24,960
and uh think about the the bigger

574
00:22:24,960 --> 00:22:26,659
picture of how this attack on these

575
00:22:26,659 --> 00:22:31,500
innodb records then works so in this

576
00:22:31,500 --> 00:22:34,440
setup we have an innodb page that we

577
00:22:34,440 --> 00:22:36,659
want to leak where we have a set of

578
00:22:36,659 --> 00:22:39,480
known data and at the end you see this

579
00:22:39,480 --> 00:22:42,539
Illustrated with the S that's the first

580
00:22:42,539 --> 00:22:45,120
byte of the secret

581
00:22:45,120 --> 00:22:47,760
and now what we do with memcache d

582
00:22:47,760 --> 00:22:50,220
we send a lot of requests to memcache D

583
00:22:50,220 --> 00:22:55,740
and create the 256 possible solutions

584
00:22:55,740 --> 00:22:57,440
for this original

585
00:22:57,440 --> 00:23:00,299
256 possible characters that could be

586
00:23:00,299 --> 00:23:02,460
the secret exactly

587
00:23:02,460 --> 00:23:05,159
so on the flow of the deck is then first

588
00:23:05,159 --> 00:23:06,960
use this reorganization trick to shift

589
00:23:06,960 --> 00:23:09,600
the secret byte into the into the innodb

590
00:23:09,600 --> 00:23:12,299
page so you have only the known data and

591
00:23:12,299 --> 00:23:15,299
this secret byte and you store the gases

592
00:23:15,299 --> 00:23:19,440
like done inside in maincash the 256 and

593
00:23:19,440 --> 00:23:22,140
then you basically just wait for the

594
00:23:22,140 --> 00:23:24,360
application so the operating system will

595
00:23:24,360 --> 00:23:26,220
then run the kernel thread then after

596
00:23:26,220 --> 00:23:28,740
some point it will be done and what you

597
00:23:28,740 --> 00:23:31,020
then see is that exactly the byte with

598
00:23:31,020 --> 00:23:32,520
the correct secret case will be

599
00:23:32,520 --> 00:23:34,620
duplicated while the others are not

600
00:23:34,620 --> 00:23:38,039
deduplicated yeah exactly but then doing

601
00:23:38,039 --> 00:23:39,600
that a single time is not enough right

602
00:23:39,600 --> 00:23:42,600
no it's not enough so and also we want

603
00:23:42,600 --> 00:23:45,360
to leak more than just one byte yes so

604
00:23:45,360 --> 00:23:47,820
what do we do I mean now we learned the

605
00:23:47,820 --> 00:23:51,179
secret byte yeah so we have more known

606
00:23:51,179 --> 00:23:53,520
data exactly and what you then can do is

607
00:23:53,520 --> 00:23:55,740
just again do this to this

608
00:23:55,740 --> 00:23:58,260
reorganization to shift the next Python

609
00:23:58,260 --> 00:24:00,659
and then you continue and continue until

610
00:24:00,659 --> 00:24:02,820
you have your whole secret leaked and

611
00:24:02,820 --> 00:24:04,320
that means you can read all the memory

612
00:24:04,320 --> 00:24:06,780
contents there buy it buy buy it yes

613
00:24:06,780 --> 00:24:08,760
without running a single line of

614
00:24:08,760 --> 00:24:11,280
attacker control code on that system it

615
00:24:11,280 --> 00:24:13,740
just uses the offered apis that's that's

616
00:24:13,740 --> 00:24:15,960
pretty bad yeah we should do something

617
00:24:15,960 --> 00:24:17,640
against that but maybe let's further

618
00:24:17,640 --> 00:24:19,020
talk about the attack before we talk

619
00:24:19,020 --> 00:24:21,720
about possible mitigations yeah so one

620
00:24:21,720 --> 00:24:24,299
thing we did not have yet seen is we

621
00:24:24,299 --> 00:24:26,100
didn't have an amplification though we

622
00:24:26,100 --> 00:24:28,679
just had this one index page and it's

623
00:24:28,679 --> 00:24:30,360
like I said before you would need many

624
00:24:30,360 --> 00:24:32,340
many many requests to then can

625
00:24:32,340 --> 00:24:33,600
distinguish it and that's not very

626
00:24:33,600 --> 00:24:35,280
interesting because the deck gets very

627
00:24:35,280 --> 00:24:37,740
very slow so we also use another trick

628
00:24:37,740 --> 00:24:40,280
to still have this this amplification

629
00:24:40,280 --> 00:24:43,740
and so what it looks like if you change

630
00:24:43,740 --> 00:24:45,840
the alignment you the the bytes you use

631
00:24:45,840 --> 00:24:47,460
for the alignment you can change for

632
00:24:47,460 --> 00:24:49,080
example here it's a

633
00:24:49,080 --> 00:24:52,380
and in memcache like before like it was

634
00:24:52,380 --> 00:24:54,179
before you would have then this a

635
00:24:54,179 --> 00:24:56,640
alignment byte and all the attacker

636
00:24:56,640 --> 00:24:58,380
guesses yeah and they would then be

637
00:24:58,380 --> 00:25:00,720
reduplicating the right uh prediction

638
00:25:00,720 --> 00:25:02,340
exactly like if you like you showed

639
00:25:02,340 --> 00:25:04,080
before that is basically the same case

640
00:25:04,080 --> 00:25:06,179
but how do you amplify it then if I

641
00:25:06,179 --> 00:25:07,799
create further pages with the same

642
00:25:07,799 --> 00:25:10,020
content they will all be duplicated with

643
00:25:10,020 --> 00:25:11,760
the same page yes

644
00:25:11,760 --> 00:25:14,400
and there's one trick you can use

645
00:25:14,400 --> 00:25:16,559
so you basically change this alignment

646
00:25:16,559 --> 00:25:17,600
byte

647
00:25:17,600 --> 00:25:19,919
okay that's waiting for the application

648
00:25:19,919 --> 00:25:22,799
if we saw this already before so let's

649
00:25:22,799 --> 00:25:24,840
skip that but you can for example change

650
00:25:24,840 --> 00:25:27,059
the amplification byte now we have a b

651
00:25:27,059 --> 00:25:30,480
here any memcache you basically store as

652
00:25:30,480 --> 00:25:32,279
many different alignment bytes as you

653
00:25:32,279 --> 00:25:34,740
want to have amplification ah so that

654
00:25:34,740 --> 00:25:37,140
means now when you start the attack now

655
00:25:37,140 --> 00:25:39,419
the correct page from the first row

656
00:25:39,419 --> 00:25:42,600
would still be deduplicated but you

657
00:25:42,600 --> 00:25:45,419
change the inner DB page now so this

658
00:25:45,419 --> 00:25:47,159
gets the copy and write fault but you're

659
00:25:47,159 --> 00:25:48,779
not interested in that one in the timing

660
00:25:48,779 --> 00:25:50,340
yeah I mean I don't care about what is

661
00:25:50,340 --> 00:25:52,620
needed to be but now you have a second

662
00:25:52,620 --> 00:25:54,539
page with the bees you can create

663
00:25:54,539 --> 00:25:57,419
further memcache D page exactly and

664
00:25:57,419 --> 00:25:59,039
again the one with the right secret

665
00:25:59,039 --> 00:26:00,840
guessability duplicate it and that's how

666
00:26:00,840 --> 00:26:02,880
you then again get some deep application

667
00:26:02,880 --> 00:26:05,700
uh amplification as before very nice and

668
00:26:05,700 --> 00:26:07,140
then you do this with an amplification

669
00:26:07,140 --> 00:26:08,700
factor of I don't know here in this

670
00:26:08,700 --> 00:26:12,360
example 26 and you would sum up over all

671
00:26:12,360 --> 00:26:15,299
the columns 256 columns and for one of

672
00:26:15,299 --> 00:26:17,100
them you would now have a highly

673
00:26:17,100 --> 00:26:19,620
Amplified tight Peak yeah ah very nice

674
00:26:19,620 --> 00:26:22,860
okay so this is a yeah very nice attack

675
00:26:22,860 --> 00:26:24,240
here

676
00:26:24,240 --> 00:26:26,159
um so

677
00:26:26,159 --> 00:26:28,919
yeah so we we will store this

678
00:26:28,919 --> 00:26:30,120
information then and then we have

679
00:26:30,120 --> 00:26:32,460
recovered that byte and then the overall

680
00:26:32,460 --> 00:26:34,860
attack works like in the overview

681
00:26:34,860 --> 00:26:37,500
um but how do we how do we stop that

682
00:26:37,500 --> 00:26:39,779
because now this looks a bit dangerous

683
00:26:39,779 --> 00:26:41,880
how do we stop these attacks

684
00:26:41,880 --> 00:26:43,740
that there are multiple possibilities so

685
00:26:43,740 --> 00:26:45,419
the first the easiest one is obviously

686
00:26:45,419 --> 00:26:46,980
let's just say let's disable memory

687
00:26:46,980 --> 00:26:50,640
duplication but that's maybe not a good

688
00:26:50,640 --> 00:26:53,100
answer because memory D duplication can

689
00:26:53,100 --> 00:26:55,500
save a lot of memory it can even save

690
00:26:55,500 --> 00:26:58,559
power consumption in some cases

691
00:26:58,559 --> 00:27:01,320
um so I don't think we will see this

692
00:27:01,320 --> 00:27:04,860
disabled no that would be like you said

693
00:27:04,860 --> 00:27:08,159
a waste of resources yes

694
00:27:08,159 --> 00:27:10,260
so what else can we do

695
00:27:10,260 --> 00:27:12,299
um there are other mitigations yes for

696
00:27:12,299 --> 00:27:14,100
instance Fusion

697
00:27:14,100 --> 00:27:17,039
yep Fusion basically embrace the same

698
00:27:17,039 --> 00:27:19,320
behavior for writing to regular pages

699
00:27:19,320 --> 00:27:20,940
and copy and write pages so you

700
00:27:20,940 --> 00:27:23,220
basically only see the higher timing and

701
00:27:23,220 --> 00:27:25,380
that of course then doesn't allow you

702
00:27:25,380 --> 00:27:27,539
anymore to see a timing difference yeah

703
00:27:27,539 --> 00:27:28,919
but they also have been further

704
00:27:28,919 --> 00:27:31,320
proposals in the academic Community for

705
00:27:31,320 --> 00:27:35,340
instance to only de-duplicate zero pages

706
00:27:35,340 --> 00:27:37,740
right yes but does that make sense are

707
00:27:37,740 --> 00:27:40,140
there so many zero pages

708
00:27:40,140 --> 00:27:43,980
yeah certain workloads zero Pages make

709
00:27:43,980 --> 00:27:47,039
up a lot of of the of the content and

710
00:27:47,039 --> 00:27:49,559
yeah okay that means you can still gain

711
00:27:49,559 --> 00:27:51,419
efficiency there yeah

712
00:27:51,419 --> 00:27:52,919
um but maybe you can also do something

713
00:27:52,919 --> 00:27:54,059
else

714
00:27:54,059 --> 00:27:56,159
um maybe we can detect the attack on a

715
00:27:56,159 --> 00:27:57,539
network layer because you're sending a

716
00:27:57,539 --> 00:27:59,460
lot of packets so we can just detect

717
00:27:59,460 --> 00:28:03,240
that right yes of course yeah

718
00:28:03,240 --> 00:28:06,900
or if we would encrypt or encode pages

719
00:28:06,900 --> 00:28:10,320
with a random salt or with a key then

720
00:28:10,320 --> 00:28:11,760
also they couldn't be de-duplicated

721
00:28:11,760 --> 00:28:13,860
anymore but that would boil down to the

722
00:28:13,860 --> 00:28:15,779
same problem then we are disabling

723
00:28:15,779 --> 00:28:17,820
memory lead application or if the key

724
00:28:17,820 --> 00:28:19,860
and the salt

725
00:28:19,860 --> 00:28:21,779
um are only specific to the security

726
00:28:21,779 --> 00:28:23,520
domain then they would still allow the

727
00:28:23,520 --> 00:28:24,539
same attack

728
00:28:24,539 --> 00:28:27,179
um we definitely evaluated uh some of

729
00:28:27,179 --> 00:28:29,700
these mitigations and one of them is a

730
00:28:29,700 --> 00:28:32,340
fusion that we looked at and here you

731
00:28:32,340 --> 00:28:34,500
can see the timing differences when

732
00:28:34,500 --> 00:28:36,299
Fusion is enabled

733
00:28:36,299 --> 00:28:39,000
yeah and what does it look like when we

734
00:28:39,000 --> 00:28:40,740
disable Fusion

735
00:28:40,740 --> 00:28:43,140
like this then we can still clearly see

736
00:28:43,140 --> 00:28:45,720
the kernel offset in our case on our

737
00:28:45,720 --> 00:28:48,179
break yes okay

738
00:28:48,179 --> 00:28:50,460
so we see there are mitigations to this

739
00:28:50,460 --> 00:28:51,720
attack

740
00:28:51,720 --> 00:28:55,020
um that don't sacrifice the

741
00:28:55,020 --> 00:28:57,960
um entire efficiency of the system and

742
00:28:57,960 --> 00:28:59,940
maybe that's also already the point

743
00:28:59,940 --> 00:29:03,000
where we get to the conclusion

744
00:29:03,000 --> 00:29:03,900
um

745
00:29:03,900 --> 00:29:06,659
some just maybe also here to mention

746
00:29:06,659 --> 00:29:08,460
um the remote attack got a new cve that

747
00:29:08,460 --> 00:29:11,520
was in 2021 and

748
00:29:11,520 --> 00:29:14,520
um we were able to mount multiple

749
00:29:14,520 --> 00:29:17,460
different attacks the first one was a

750
00:29:17,460 --> 00:29:19,919
remote fingerprinting of libraries or

751
00:29:19,919 --> 00:29:22,740
executables on the system

752
00:29:22,740 --> 00:29:24,120
the second one

753
00:29:24,120 --> 00:29:26,580
and the second one was the kslr brick we

754
00:29:26,580 --> 00:29:29,059
saw that managed to

755
00:29:29,059 --> 00:29:31,320
work in under four minutes so that's

756
00:29:31,320 --> 00:29:33,659
very nice over the Internet it needs to

757
00:29:33,659 --> 00:29:36,240
emphasize I think yeah I always hear

758
00:29:36,240 --> 00:29:38,279
this argument yeah kslr is broken anyway

759
00:29:38,279 --> 00:29:40,919
if you already have code execution on

760
00:29:40,919 --> 00:29:42,480
the system but if you don't have code

761
00:29:42,480 --> 00:29:44,760
execution on the system

762
00:29:44,760 --> 00:29:47,520
then still a case outbreak is quite

763
00:29:47,520 --> 00:29:49,320
valuable so

764
00:29:49,320 --> 00:29:51,480
um or can be depending on what your

765
00:29:51,480 --> 00:29:55,080
attack Vector is so the third attack

766
00:29:55,080 --> 00:29:57,299
then was the leakage of the database

767
00:29:57,299 --> 00:30:00,179
records bite by bite exploiting this

768
00:30:00,179 --> 00:30:04,799
reorganization in nodb and finally we

769
00:30:04,799 --> 00:30:06,899
have been working with redhead there and

770
00:30:06,899 --> 00:30:08,700
they have developed a probabilistic

771
00:30:08,700 --> 00:30:11,700
mitigation as opt-in for the Linux

772
00:30:11,700 --> 00:30:14,159
question that's not main main in the

773
00:30:14,159 --> 00:30:15,720
mainline kernel yet

774
00:30:15,720 --> 00:30:19,380
um it's just a request for comments yeah

775
00:30:19,380 --> 00:30:20,940
so far

776
00:30:20,940 --> 00:30:23,520
okay and with that we are at the end of

777
00:30:23,520 --> 00:30:26,220
our talk and uh we would be happy to

778
00:30:26,220 --> 00:30:29,600
take your questions thank you

779
00:30:29,800 --> 00:30:32,869
[Music]

780
00:30:36,710 --> 00:30:39,799
[Music]

