1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:09,270 --> 00:00:12,330
[Music]

4
00:00:20,359 --> 00:00:24,180
about the windows common log file system

5
00:00:24,180 --> 00:00:27,060
our topic name is the next generation of

6
00:00:27,060 --> 00:00:29,519
Windows exploitation attacking the

7
00:00:29,519 --> 00:00:32,479
common log file system

8
00:00:34,559 --> 00:00:38,059
recording in progress

9
00:00:38,940 --> 00:00:42,239
this is our self-introduction we are

10
00:00:42,239 --> 00:00:44,219
security researchers from qihu

11
00:00:44,219 --> 00:00:46,739
vulnerability Research Institute and

12
00:00:46,739 --> 00:00:48,480
here is our Twitter

13
00:00:48,480 --> 00:00:50,640
we are currently main focused on the

14
00:00:50,640 --> 00:00:54,079
Windows platform bar County

15
00:00:59,399 --> 00:01:02,579
here is our agenda I will introduce some

16
00:01:02,579 --> 00:01:04,920
background knowledge about common log

17
00:01:04,920 --> 00:01:07,740
file system then I will share how we

18
00:01:07,740 --> 00:01:10,140
fast these targets and I will pick two

19
00:01:10,140 --> 00:01:15,020
classic cases for vulnerability analyze

20
00:01:15,020 --> 00:01:18,360
will show you how we used a new method

21
00:01:18,360 --> 00:01:22,880
to exploit the TFO cup vulnerability

22
00:01:26,820 --> 00:01:29,420
first what is common log file system

23
00:01:29,420 --> 00:01:33,600
this content is expired from msdn

24
00:01:33,600 --> 00:01:35,700
the common log file system is a new

25
00:01:35,700 --> 00:01:38,280
locking mechanism introduced by Windows

26
00:01:38,280 --> 00:01:41,280
Vista which is responsible for providing

27
00:01:41,280 --> 00:01:43,860
a high performance Universal log file

28
00:01:43,860 --> 00:01:46,439
subsystem that dedicate his silent

29
00:01:46,439 --> 00:01:47,939
applications can use

30
00:01:47,939 --> 00:01:50,340
multiple silence can share to optimize

31
00:01:50,340 --> 00:01:51,780
log axis

32
00:01:51,780 --> 00:01:54,420
any user mode application that needs

33
00:01:54,420 --> 00:01:56,700
login or recovery support can use common

34
00:01:56,700 --> 00:01:59,600
log file system

35
00:02:03,240 --> 00:02:06,180
we can create or open a log file with

36
00:02:06,180 --> 00:02:08,459
the create log file function

37
00:02:08,459 --> 00:02:11,459
the log can be dedicated or multiplexed

38
00:02:11,459 --> 00:02:15,000
and that depends on the log file name

39
00:02:15,000 --> 00:02:17,640
you can use the closed handle function

40
00:02:17,640 --> 00:02:20,220
to close the log

41
00:02:20,220 --> 00:02:22,860
we can get the function of the Operation

42
00:02:22,860 --> 00:02:26,640
Log by curing msdn or we can get the

43
00:02:26,640 --> 00:02:29,340
optical by reversing the clfs system

44
00:02:29,340 --> 00:02:31,640
driver

45
00:02:36,599 --> 00:02:39,180
before starting our research we checked

46
00:02:39,180 --> 00:02:41,280
out some great resources from Alice

47
00:02:41,280 --> 00:02:45,180
Eunice could collab and Cisco tellers

48
00:02:45,180 --> 00:02:47,280
their research can give us a faster

49
00:02:47,280 --> 00:02:51,360
understanding of this new attack surface

50
00:02:51,360 --> 00:02:54,080
foreign

51
00:02:57,440 --> 00:03:00,239
research we can summarize the following

52
00:03:00,239 --> 00:03:01,980
two attack surface

53
00:03:01,980 --> 00:03:04,500
first is log file parsing vulnerability

54
00:03:04,500 --> 00:03:08,940
in clf system driver and second is error

55
00:03:08,940 --> 00:03:10,680
handling of vial code vulnerability in

56
00:03:10,680 --> 00:03:14,239
clfs system driver

57
00:03:18,599 --> 00:03:21,480
so we did research on the blf file

58
00:03:21,480 --> 00:03:22,680
format

59
00:03:22,680 --> 00:03:25,620
this is a structure of a base log file

60
00:03:25,620 --> 00:03:28,140
and we can find the location of the

61
00:03:28,140 --> 00:03:32,359
structure in the pretty blf file

62
00:03:38,580 --> 00:03:40,860
after analyzing the file format we

63
00:03:40,860 --> 00:03:43,799
consider how to pass it the desired idea

64
00:03:43,799 --> 00:03:46,620
of our files is very simple just create

65
00:03:46,620 --> 00:03:49,560
a log random log file data by structure

66
00:03:49,560 --> 00:03:53,540
and the parts log file data

67
00:03:57,420 --> 00:04:00,420
first we need to create a log which can

68
00:04:00,420 --> 00:04:02,459
be achieved through the create log file

69
00:04:02,459 --> 00:04:04,500
function mentioned earlier

70
00:04:04,500 --> 00:04:07,319
and log files are divided into dedicated

71
00:04:07,319 --> 00:04:11,040
log file and Multiplex the log file

72
00:04:11,040 --> 00:04:13,080
there are also some functions for

73
00:04:13,080 --> 00:04:15,299
container operations in the log

74
00:04:15,299 --> 00:04:17,820
so we can also choose whether to add a

75
00:04:17,820 --> 00:04:20,659
container or not

76
00:04:26,940 --> 00:04:30,240
by reverse the coeff system driver we

77
00:04:30,240 --> 00:04:32,400
can find that there is a CRC check

78
00:04:32,400 --> 00:04:35,820
whenever the blf file is parsed

79
00:04:35,820 --> 00:04:38,880
the following is a studio code

80
00:04:38,880 --> 00:04:41,400
so we need to bypass this check before

81
00:04:41,400 --> 00:04:45,198
random file data

82
00:04:53,880 --> 00:04:57,600
reverse the comfs system driver we can

83
00:04:57,600 --> 00:04:59,820
find that some functions starting with

84
00:04:59,820 --> 00:05:03,180
gate and acquire will read data from the

85
00:05:03,180 --> 00:05:07,139
blf file such as get baselog record get

86
00:05:07,139 --> 00:05:09,740
control record acquirement data block

87
00:05:09,740 --> 00:05:12,240
acquired Trace content

88
00:05:12,240 --> 00:05:15,540
and so on so when mailing randomized

89
00:05:15,540 --> 00:05:18,800
this structure when fighting

90
00:05:22,380 --> 00:05:27,680
this structure is reversed by in Ida

91
00:05:31,800 --> 00:05:34,320
after random log file data we need to

92
00:05:34,320 --> 00:05:37,400
call some functions to parse the log

93
00:05:37,400 --> 00:05:41,699
we can know from msdn that there are the

94
00:05:41,699 --> 00:05:44,100
following types of functions

95
00:05:44,100 --> 00:05:47,699
long storage record chance reservation

96
00:05:47,699 --> 00:05:51,300
log achieve and restore there are also

97
00:05:51,300 --> 00:05:54,120
some types of operation functions can be

98
00:05:54,120 --> 00:05:57,840
found in msdn or reverse inclfa system

99
00:05:57,840 --> 00:05:58,979
driver

100
00:05:58,979 --> 00:06:01,560
so I don't list them all here

101
00:06:01,560 --> 00:06:04,800
in summary our firstly our father

102
00:06:04,800 --> 00:06:07,979
created a blf file of a random type

103
00:06:07,979 --> 00:06:11,900
secondly randomize the blf file in the

104
00:06:11,900 --> 00:06:14,880
content according to the structure we

105
00:06:14,880 --> 00:06:16,380
mentioned earlier

106
00:06:16,380 --> 00:06:19,919
the way bypass the CRC check and finally

107
00:06:19,919 --> 00:06:22,500
call some functions to read the file

108
00:06:22,500 --> 00:06:25,819
content for operation

109
00:06:32,220 --> 00:06:34,740
after fasting for a while we got some

110
00:06:34,740 --> 00:06:36,300
crashes

111
00:06:36,300 --> 00:06:39,300
I will analyze two of them

112
00:06:39,300 --> 00:06:41,819
the first vulnerability is related to

113
00:06:41,819 --> 00:06:45,360
the clfs control record structure which

114
00:06:45,360 --> 00:06:50,940
is located at the bla file offset 0x70

115
00:06:51,000 --> 00:06:54,000
we can find the three Fields e extension

116
00:06:54,000 --> 00:06:56,520
State I extension block and I flash

117
00:06:56,520 --> 00:06:58,979
block according to the offset in the

118
00:06:58,979 --> 00:07:03,539
clfs control record structure

119
00:07:03,539 --> 00:07:06,240
this Rift fields are marked in the Red

120
00:07:06,240 --> 00:07:08,400
Blocks here

121
00:07:08,400 --> 00:07:10,620
each extension State Fields identifies

122
00:07:10,620 --> 00:07:13,620
the current extension State for the file

123
00:07:13,620 --> 00:07:16,500
in this case we see it's true which

124
00:07:16,500 --> 00:07:20,819
means clfs extend State flash block

125
00:07:20,819 --> 00:07:23,639
setting Institute is for the program to

126
00:07:23,639 --> 00:07:25,860
reach the vulnerable function shift

127
00:07:25,860 --> 00:07:29,539
Manta data block described

128
00:07:29,699 --> 00:07:32,340
I extension block field identifies the

129
00:07:32,340 --> 00:07:35,400
index of the block being extended in

130
00:07:35,400 --> 00:07:38,759
this case we say 824

131
00:07:38,759 --> 00:07:41,460
I flash block fails identifies the block

132
00:07:41,460 --> 00:07:43,139
being flashed

133
00:07:43,139 --> 00:07:47,419
in this case we say it's 3.

134
00:07:51,620 --> 00:07:54,660
the root cause of the vulnerability is

135
00:07:54,660 --> 00:07:56,819
that when the shift metadata block

136
00:07:56,819 --> 00:08:00,300
descriptor function Parts the blf file

137
00:08:00,300 --> 00:08:02,580
the eye extension block and I flash

138
00:08:02,580 --> 00:08:04,759
block fields are not well checked

139
00:08:04,759 --> 00:08:07,979
resulting in a specially constructed blf

140
00:08:07,979 --> 00:08:10,259
file that can lead to an out-of-bound

141
00:08:10,259 --> 00:08:12,060
vulnerability

142
00:08:12,060 --> 00:08:14,520
and you can see a Autobox variability

143
00:08:14,520 --> 00:08:17,340
will occur here when I flash block is

144
00:08:17,340 --> 00:08:20,479
used as index

145
00:08:21,720 --> 00:08:24,539
which submit this vulnerability to msrc

146
00:08:24,539 --> 00:08:27,930
and obtain cve 2022-21916

147
00:08:27,930 --> 00:08:31,110
[Music]

148
00:08:44,520 --> 00:08:47,540
the second vulnerability appears in the

149
00:08:47,540 --> 00:08:51,420
clfs log FCB physical overflow reversal

150
00:08:51,420 --> 00:08:52,440
function

151
00:08:52,440 --> 00:08:55,380
this function is mainly related to the

152
00:08:55,380 --> 00:08:57,600
owner page operation

153
00:08:57,600 --> 00:09:00,720
the cclfa space file High Watermark

154
00:09:00,720 --> 00:09:03,360
sanitizing function

155
00:09:03,360 --> 00:09:06,300
obtains the silent ID in the BLM file

156
00:09:06,300 --> 00:09:08,820
and the silent ID is obtained by

157
00:09:08,820 --> 00:09:11,220
subtracting one from the same next item

158
00:09:11,220 --> 00:09:14,220
fields in the clf space record header

159
00:09:14,220 --> 00:09:15,180
structure

160
00:09:15,180 --> 00:09:19,200
we can still modify it in the bof file

161
00:09:19,200 --> 00:09:21,560
when it is modified to a special value

162
00:09:21,560 --> 00:09:24,540
it will be used as a wrong index

163
00:09:24,540 --> 00:09:28,740
resulting in an autobus vulnerability

164
00:09:28,740 --> 00:09:31,680
the picture here is the same next silent

165
00:09:31,680 --> 00:09:34,640
we found in the file

166
00:09:41,580 --> 00:09:44,040
an overflow occurs when the silent ID is

167
00:09:44,040 --> 00:09:47,939
greater than 0x70.

168
00:09:58,560 --> 00:10:01,380
in summary this is a pro overflow

169
00:10:01,380 --> 00:10:04,040
vulnerability with a page Pro size of

170
00:10:04,040 --> 00:10:08,720
0x1000 which writes clfs Als in value

171
00:10:08,720 --> 00:10:11,820
and the old owner page data to the head

172
00:10:11,820 --> 00:10:13,560
of the next pool

173
00:10:13,560 --> 00:10:15,959
next my colleague Ling zhangi will

174
00:10:15,959 --> 00:10:18,360
introduce how we use new method to

175
00:10:18,360 --> 00:10:21,500
exploit this vulnerability

176
00:10:33,480 --> 00:10:36,240
hello everyone my name is Lee Shawnee

177
00:10:36,240 --> 00:10:39,240
last let me introduce our Universal

178
00:10:39,240 --> 00:10:41,339
message for the Windows page the pro

179
00:10:41,339 --> 00:10:44,160
overflow exploitation

180
00:10:44,160 --> 00:10:47,040
uh currently low and windows patch the

181
00:10:47,040 --> 00:10:49,740
pro overflow exploitation methods are as

182
00:10:49,740 --> 00:10:50,760
followed

183
00:10:50,760 --> 00:10:54,720
one is the wnf by overflow crafting the

184
00:10:54,720 --> 00:10:59,579
status of WF limits the structure we can

185
00:10:59,579 --> 00:11:02,100
we can achieve logo or restricted

186
00:11:02,100 --> 00:11:04,860
actually address really on Direct

187
00:11:04,860 --> 00:11:07,740
the other is the link name the password

188
00:11:07,740 --> 00:11:11,700
by overflow corrupting the link point of

189
00:11:11,700 --> 00:11:14,820
paper attribute structure we can only

190
00:11:14,820 --> 00:11:17,399
achieve level of arbitrary

191
00:11:17,399 --> 00:11:20,720
address reader

192
00:11:21,959 --> 00:11:25,260
you know exploit the teaching of the wnf

193
00:11:25,260 --> 00:11:27,839
had some limitations

194
00:11:27,839 --> 00:11:31,740
the set of the WF let me instance is

195
00:11:31,740 --> 00:11:37,140
zero X C 0 or 0x detail

196
00:11:37,140 --> 00:11:41,399
this vulnerability is a probability with

197
00:11:41,399 --> 00:11:45,980
the product with the appendix process of

198
00:11:45,980 --> 00:11:51,000
0x1000 so we cannot allocated the WF let

199
00:11:51,000 --> 00:11:55,260
me test structure with a set of 0x1000

200
00:11:55,260 --> 00:11:57,240
[Music]

201
00:11:57,240 --> 00:12:00,899
so we can only we can only overflow the

202
00:12:00,899 --> 00:12:04,740
WF data data structure of the set 0x

203
00:12:04,740 --> 00:12:06,600
1000

204
00:12:06,600 --> 00:12:10,459
by overflowing the allocate yourself

205
00:12:10,459 --> 00:12:13,740
allocate yourself of the download house

206
00:12:13,740 --> 00:12:18,440
data data structure we can reach an auto

207
00:12:18,480 --> 00:12:21,720
bounce rate in the maximum range of

208
00:12:21,720 --> 00:12:23,640
0x

209
00:12:23,640 --> 00:12:25,920
1000 set

210
00:12:25,920 --> 00:12:28,920
right

211
00:12:31,140 --> 00:12:34,820
so we also need to find a

212
00:12:34,820 --> 00:12:38,700
0x1000 set patch the pro structure and

213
00:12:38,700 --> 00:12:41,640
then overflow some of its fields to

214
00:12:41,640 --> 00:12:43,680
achieve a goal of the arbitrary address

215
00:12:43,680 --> 00:12:46,099
right

216
00:12:47,660 --> 00:12:51,720
I found a good exploiter

217
00:12:51,720 --> 00:12:55,920
structure in the windows AR PC

218
00:12:55,920 --> 00:13:00,980
by overflow corrupting the handles

219
00:13:00,980 --> 00:13:06,240
on the table structure foreign

220
00:13:14,779 --> 00:13:17,820
table structure

221
00:13:17,820 --> 00:13:21,500
a result lab can be created by coin

222
00:13:21,500 --> 00:13:25,200
ntlpc Creator resource resolve function

223
00:13:25,200 --> 00:13:29,220
whenever a blob is created the erpc and

224
00:13:29,220 --> 00:13:31,820
the 100 tables and entry function well

225
00:13:31,820 --> 00:13:35,040
be coded to register address or the

226
00:13:35,040 --> 00:13:37,440
created block to the 100th of the hand

227
00:13:37,440 --> 00:13:38,940
table

228
00:13:38,940 --> 00:13:42,480
the most important part of erpc kind of

229
00:13:42,480 --> 00:13:46,760
table structure is the 100 fields

230
00:13:50,459 --> 00:13:54,360
when the arpc port is created

231
00:13:54,360 --> 00:13:57,800
the arpc initial line to the 100 table

232
00:13:57,800 --> 00:14:00,660
function is according to initial at the

233
00:14:00,660 --> 00:14:02,279
final table

234
00:14:02,279 --> 00:14:05,700
the hand is the applied poor with the

235
00:14:05,700 --> 00:14:07,560
initial size of

236
00:14:07,560 --> 00:14:10,139
0x80

237
00:14:10,139 --> 00:14:13,260
which Stories the address of The Blob

238
00:14:13,260 --> 00:14:14,399
structure

239
00:14:14,399 --> 00:14:18,000
has more problems are created the set of

240
00:14:18,000 --> 00:14:20,760
100 doubles

241
00:14:20,760 --> 00:14:26,899
and the set of 100 is where is available

242
00:14:31,260 --> 00:14:36,060
by overflow corrupting the klpc

243
00:14:36,060 --> 00:14:37,160
results

244
00:14:37,160 --> 00:14:41,100
point of the 100th structure we can

245
00:14:41,100 --> 00:14:45,680
construct a fake resolved lab

246
00:14:46,019 --> 00:14:49,139
under the kalpc results structure

247
00:14:49,139 --> 00:14:52,160
storage the

248
00:14:52,680 --> 00:14:56,760
stories or messaging

249
00:14:57,120 --> 00:15:00,660
so we can continue to Constructor uh

250
00:15:00,660 --> 00:15:05,040
fake area PC messages structure

251
00:15:05,040 --> 00:15:09,360
and uh when you call collect NTA offices

252
00:15:09,360 --> 00:15:12,240
and wait and receive report function to

253
00:15:12,240 --> 00:15:14,160
send a message

254
00:15:14,160 --> 00:15:17,880
it will address the data passages

255
00:15:17,880 --> 00:15:21,660
in better use to address pointed to

256
00:15:21,660 --> 00:15:24,839
better exchanging buffer in the klpc

257
00:15:24,839 --> 00:15:26,699
messages structure

258
00:15:26,699 --> 00:15:29,699
we can use it to achieve arbitrary

259
00:15:29,699 --> 00:15:32,579
address rate that

260
00:15:32,579 --> 00:15:36,300
and when you call anterior pieces and

261
00:15:36,300 --> 00:15:38,160
with a referral point

262
00:15:38,160 --> 00:15:41,880
water function to receive a message

263
00:15:41,880 --> 00:15:44,220
it will read the data at the address

264
00:15:44,220 --> 00:15:47,579
point in the barrier extension buffer in

265
00:15:47,579 --> 00:15:50,040
the clear PC message structure we can

266
00:15:50,040 --> 00:15:55,579
use it to achieve arbitrary object rate

267
00:15:58,199 --> 00:16:01,740
under the whole process of achieving the

268
00:16:01,740 --> 00:16:04,079
goal of arbitrary address delete and

269
00:16:04,079 --> 00:16:07,320
address it as follows

270
00:16:07,320 --> 00:16:12,000
first by overflow crafting the kmpc

271
00:16:12,000 --> 00:16:13,760
results

272
00:16:13,760 --> 00:16:17,160
point of the Android structure we can

273
00:16:17,160 --> 00:16:21,720
construct our fake result block

274
00:16:21,720 --> 00:16:25,380
the klpc results structure

275
00:16:25,380 --> 00:16:28,320
stories or dress or a message

276
00:16:28,320 --> 00:16:31,320
so we can continue to construct of

277
00:16:31,320 --> 00:16:33,540
physical erpc

278
00:16:33,540 --> 00:16:36,000
message structure

279
00:16:36,000 --> 00:16:39,320
and again we can achieve a goal of

280
00:16:39,320 --> 00:16:43,500
arbitrary address read and write so uh

281
00:16:43,500 --> 00:16:46,139
extension buffer field under the

282
00:16:46,139 --> 00:16:49,079
extension buffers set field in the key

283
00:16:49,079 --> 00:16:50,579
of his image

284
00:16:50,579 --> 00:16:53,339
this structure

285
00:16:53,339 --> 00:16:57,420
and the last my colleague will continue

286
00:16:57,420 --> 00:16:58,800
to

287
00:16:58,800 --> 00:17:01,440
introduce how to exploit this

288
00:17:01,440 --> 00:17:04,160
vulnerability

289
00:17:13,559 --> 00:17:17,699
uh color area let me introduce how to

290
00:17:17,699 --> 00:17:20,400
combat wnf under our PC

291
00:17:20,400 --> 00:17:22,679
and finally I should have laser

292
00:17:22,679 --> 00:17:24,119
escalation

293
00:17:24,119 --> 00:17:26,520
first of all we can call the anti-update

294
00:17:26,520 --> 00:17:28,199
wnf state

295
00:17:28,199 --> 00:17:31,520
to spray a lot of

296
00:17:31,520 --> 00:17:33,919
0x1000.wx structures

297
00:17:33,919 --> 00:17:37,740
and then make sure they are land in

298
00:17:37,740 --> 00:17:40,039
memory

299
00:17:42,120 --> 00:17:45,960
then we need to call the NT delete WF

300
00:17:45,960 --> 00:17:49,020
state name function creating a lot of

301
00:17:49,020 --> 00:17:52,520
memory holes

302
00:17:55,919 --> 00:17:58,559
in the third step we need to create the

303
00:17:58,559 --> 00:17:59,820
owner page

304
00:17:59,820 --> 00:18:03,059
which is the vulnerable pool block

305
00:18:03,059 --> 00:18:06,419
we only need to call create log file

306
00:18:06,419 --> 00:18:10,740
but if you will dedicated brf file it

307
00:18:10,740 --> 00:18:13,380
will not call the Overflow referral

308
00:18:13,380 --> 00:18:17,820
you need to create a spatial bra here I

309
00:18:17,820 --> 00:18:20,700
will briefly set is to create or

310
00:18:20,700 --> 00:18:22,980
Multiplex the log file

311
00:18:22,980 --> 00:18:27,120
then you need to write a lot of recalls

312
00:18:27,120 --> 00:18:30,419
to the container

313
00:18:30,419 --> 00:18:32,880
when the lens of the button content

314
00:18:32,880 --> 00:18:34,380
access

315
00:18:34,380 --> 00:18:37,380
0x75000.

316
00:18:38,580 --> 00:18:41,280
uh it will automatically generate a

317
00:18:41,280 --> 00:18:42,720
honor page

318
00:18:42,720 --> 00:18:47,280
next you open the brf through create log

319
00:18:47,280 --> 00:18:48,360
file

320
00:18:48,360 --> 00:18:53,000
and it will cause the Overflow referral

321
00:18:53,220 --> 00:18:58,559
uh okay back to the exfoliation part

322
00:18:58,559 --> 00:19:01,080
when the Overflow referral is called

323
00:19:01,080 --> 00:19:04,200
the function will do a out of bus byte

324
00:19:04,200 --> 00:19:07,919
to the owner owner page pool

325
00:19:07,919 --> 00:19:12,120
which will workflow the WF

326
00:19:12,120 --> 00:19:14,520
as can be saved from the picture on the

327
00:19:14,520 --> 00:19:15,900
on the right

328
00:19:15,900 --> 00:19:18,900
before the Overflow of WF the value of

329
00:19:18,900 --> 00:19:20,760
Dublin f is normal

330
00:19:20,760 --> 00:19:24,419
after overflow the allocated side of WF

331
00:19:24,419 --> 00:19:26,179
is overflowed to

332
00:19:26,179 --> 00:19:29,580
0x4 I5

333
00:19:29,580 --> 00:19:33,960
and the header is overflowed to zero

334
00:19:33,960 --> 00:19:36,900
but this does not affect the normal work

335
00:19:36,900 --> 00:19:39,799
of WF

336
00:19:41,640 --> 00:19:44,940
then we need to create handles

337
00:19:44,940 --> 00:19:46,980
where accurate handles

338
00:19:46,980 --> 00:19:52,679
because the block side of WF is 0x1000

339
00:19:52,679 --> 00:19:55,620
and it's out of bounds right side the

340
00:19:55,620 --> 00:19:58,559
limit is also 0x 1000

341
00:19:58,559 --> 00:20:01,500
not counting the direct turn header

342
00:20:01,500 --> 00:20:04,020
structure at the beginning of the WF

343
00:20:04,020 --> 00:20:07,320
structure it will start waiting from the

344
00:20:07,320 --> 00:20:10,380
offside of 0x20

345
00:20:10,380 --> 00:20:14,179
so we can only write the next block

346
00:20:14,179 --> 00:20:18,240
interprets of lengths Direction

347
00:20:18,240 --> 00:20:19,620
foreign

348
00:20:19,620 --> 00:20:24,360
so we need a point to access in the

349
00:20:24,360 --> 00:20:28,320
first 16 beds of the structure of the

350
00:20:28,320 --> 00:20:30,240
next block

351
00:20:30,240 --> 00:20:33,360
so that we can automate the pointer

352
00:20:33,360 --> 00:20:37,200
through WF to a chill actually read and

353
00:20:37,200 --> 00:20:38,880
write

354
00:20:38,880 --> 00:20:42,240
so we found the structure of handles

355
00:20:42,240 --> 00:20:44,580
all numbers of this structure are

356
00:20:44,580 --> 00:20:46,740
Pointers

357
00:20:46,740 --> 00:20:49,020
you can see the picture

358
00:20:49,020 --> 00:20:53,220
uh the size of the pool is controllable

359
00:20:53,220 --> 00:20:59,460
so we allocate handles of size 0x1000 to

360
00:20:59,460 --> 00:21:03,260
the whole of WF

361
00:21:05,520 --> 00:21:09,900
we call anti-update WF State date to

362
00:21:09,900 --> 00:21:12,539
overflow the WF block

363
00:21:12,539 --> 00:21:15,059
you can see the position marked by the

364
00:21:15,059 --> 00:21:16,140
blue box

365
00:21:16,140 --> 00:21:19,200
we always the first point remember of

366
00:21:19,200 --> 00:21:23,340
handles with the user modes addressed

367
00:21:23,340 --> 00:21:27,480
which is the air PC result structure we

368
00:21:27,480 --> 00:21:30,740
fixed in user mode

369
00:21:33,419 --> 00:21:36,720
here is an introduction to the air PC

370
00:21:36,720 --> 00:21:38,460
structures

371
00:21:38,460 --> 00:21:40,860
under key code

372
00:21:40,860 --> 00:21:43,799
we can see that the structure of RPG

373
00:21:43,799 --> 00:21:47,039
Reserve is very simple

374
00:21:47,039 --> 00:21:50,640
we need to fix a message structure at

375
00:21:50,640 --> 00:21:54,179
offsite 0x18

376
00:21:54,179 --> 00:21:56,580
with overflow handles

377
00:21:56,580 --> 00:22:00,539
called ntrp seasoned with resale port

378
00:22:00,539 --> 00:22:04,940
then or fake address will be referenced

379
00:22:04,940 --> 00:22:09,840
in the Erp the lookup message function

380
00:22:09,840 --> 00:22:11,039
which

381
00:22:11,039 --> 00:22:15,240
will find a big address in handle table

382
00:22:15,240 --> 00:22:18,799
through message ID

383
00:22:20,580 --> 00:22:25,020
then the RPC reference blocked by handle

384
00:22:25,020 --> 00:22:27,000
function will return

385
00:22:27,000 --> 00:22:29,340
fake Reserve structure

386
00:22:29,340 --> 00:22:31,860
whose message number is also the

387
00:22:31,860 --> 00:22:36,620
structure we fixed in user mode

388
00:22:40,620 --> 00:22:43,919
here is an introduction to the key part

389
00:22:43,919 --> 00:22:45,539
of

390
00:22:45,539 --> 00:22:49,260
faking the LPS in method structure

391
00:22:49,260 --> 00:22:51,720
we need to match the token address to

392
00:22:51,720 --> 00:22:55,860
the 0x0 offset of the structure

393
00:22:55,860 --> 00:22:59,100
so the extension buffer actually posts

394
00:22:59,100 --> 00:23:01,200
the token address

395
00:23:01,200 --> 00:23:03,960
how to leak the token address we can

396
00:23:03,960 --> 00:23:07,380
call NT query system information

397
00:23:07,380 --> 00:23:11,640
which is already a open technology so I

398
00:23:11,640 --> 00:23:14,960
won't go into details

399
00:23:16,980 --> 00:23:21,600
finally we can call NT Erp system with

400
00:23:21,600 --> 00:23:24,960
result code to write the message content

401
00:23:24,960 --> 00:23:28,500
to the Erp support

402
00:23:28,500 --> 00:23:31,559
and eventually it will go to error PC

403
00:23:31,559 --> 00:23:34,140
capture message data save

404
00:23:34,140 --> 00:23:37,860
and the advanced content that a user can

405
00:23:37,860 --> 00:23:41,760
control into the extension buffer point

406
00:23:41,760 --> 00:23:45,179
which points to the Token address as you

407
00:23:45,179 --> 00:23:47,880
can see in the red picture

408
00:23:47,880 --> 00:23:50,640
the Privileges of the token has been

409
00:23:50,640 --> 00:23:53,120
automated to

410
00:23:53,120 --> 00:23:56,959
160x I5

411
00:23:59,880 --> 00:24:02,700
finally we achieved elevation of

412
00:24:02,700 --> 00:24:03,960
privilege

413
00:24:03,960 --> 00:24:07,620
using proc exp to build the permissions

414
00:24:07,620 --> 00:24:12,419
of the XP process

415
00:24:12,419 --> 00:24:15,780
we have obtained the C debug privilege

416
00:24:15,780 --> 00:24:19,200
permissions a permission and then we

417
00:24:19,200 --> 00:24:20,580
inject

418
00:24:20,580 --> 00:24:24,600
show code into the open logon process

419
00:24:24,600 --> 00:24:28,980
and finally open a CMD process with

420
00:24:28,980 --> 00:24:31,940
system permissions

421
00:24:32,580 --> 00:24:37,039
here is the demo video we recorded

422
00:24:44,280 --> 00:24:46,879
foreign

423
00:25:13,760 --> 00:25:17,159
we will talk about why this structure

424
00:25:17,159 --> 00:25:19,679
are Universal

425
00:25:19,679 --> 00:25:22,679
we have involved three structures in

426
00:25:22,679 --> 00:25:23,580
turtle

427
00:25:23,580 --> 00:25:28,500
namely WF handles and message

428
00:25:28,500 --> 00:25:31,200
they all have one feature

429
00:25:31,200 --> 00:25:32,580
that is

430
00:25:32,580 --> 00:25:36,299
they can be controlled inside

431
00:25:36,299 --> 00:25:39,419
after our test they can be adapted to

432
00:25:39,419 --> 00:25:44,100
the matching range is the minimal 0x 30

433
00:25:44,100 --> 00:25:47,159
and the maximum 0x

434
00:25:47,159 --> 00:25:51,000
11 000 or more

435
00:25:51,000 --> 00:25:53,460
under this Ray structure can be used

436
00:25:53,460 --> 00:25:56,940
along origin combination

437
00:25:56,940 --> 00:25:59,640
according to our tests all three

438
00:25:59,640 --> 00:26:03,919
structures are available in settings

439
00:26:03,919 --> 00:26:07,260
0x32 Terex 1000

440
00:26:07,260 --> 00:26:10,220
handles and message can be used over

441
00:26:10,220 --> 00:26:14,460
greater than 0x1000.

442
00:26:17,179 --> 00:26:21,000
greater than 0x 11000 can be used

443
00:26:21,000 --> 00:26:23,900
handles

444
00:26:27,360 --> 00:26:30,840
the three structures are described in

445
00:26:30,840 --> 00:26:32,700
detail below

446
00:26:32,700 --> 00:26:37,020
first introduce WF it says range from

447
00:26:37,020 --> 00:26:40,679
the 0x30 to 0x1000

448
00:26:40,679 --> 00:26:44,580
and it has a limit of one's Terrace 1000

449
00:26:44,580 --> 00:26:48,860
for a lot of bounds right rights

450
00:26:48,860 --> 00:26:52,260
but this is enough to adapt to a large

451
00:26:52,260 --> 00:26:56,240
number of poor flow vulnerabilities

452
00:26:56,240 --> 00:26:59,700
we only need to modify the size of the

453
00:26:59,700 --> 00:27:04,140
allocated sides of the WF structure

454
00:27:04,140 --> 00:27:08,940
throat overflow or for poor flow or out

455
00:27:08,940 --> 00:27:12,840
of Bounce light to use WF to perform out

456
00:27:12,840 --> 00:27:14,760
of Bounce light

457
00:27:14,760 --> 00:27:17,159
and modify the data side

458
00:27:17,159 --> 00:27:21,440
to achieve Autobots read

459
00:27:24,480 --> 00:27:27,659
then the handle structure matches the

460
00:27:27,659 --> 00:27:29,580
range 0x

461
00:27:29,580 --> 00:27:32,940
Knight to wherever a lot

462
00:27:32,940 --> 00:27:37,620
there is a rule for handles that is the

463
00:27:37,620 --> 00:27:41,460
size is still x 80 at the beginning

464
00:27:41,460 --> 00:27:45,419
plus the poor header is 0x90 then

465
00:27:45,419 --> 00:27:49,559
directs 80 multiplied by 2 equals 0x

466
00:27:49,559 --> 00:27:51,419
100.

467
00:27:51,419 --> 00:27:56,480
10 multiplied by 2 and so on

468
00:27:56,580 --> 00:27:59,820
therefore it is necessary to observe

469
00:27:59,820 --> 00:28:02,940
whether to use the block size match when

470
00:28:02,940 --> 00:28:05,480
adapting

471
00:28:05,760 --> 00:28:09,900
the yields of handles is very flexible

472
00:28:09,900 --> 00:28:13,679
even if you write a invalid value to the

473
00:28:13,679 --> 00:28:17,220
handles there is a still chance to use

474
00:28:17,220 --> 00:28:19,860
it successfully

475
00:28:19,860 --> 00:28:21,539
because

476
00:28:21,539 --> 00:28:24,900
you can call the virtual logic to map

477
00:28:24,900 --> 00:28:27,960
this involid value to a user mode

478
00:28:27,960 --> 00:28:29,880
address

479
00:28:29,880 --> 00:28:35,900
and then you can fix your PC result

480
00:28:36,240 --> 00:28:39,419
at this step use it was basically

481
00:28:39,419 --> 00:28:42,080
successful

482
00:28:46,320 --> 00:28:49,200
the last is the message structure it

483
00:28:49,200 --> 00:28:51,799
matches in the range 0x

484
00:28:51,799 --> 00:28:55,200
160 to 0x 11

485
00:28:55,200 --> 00:28:57,720
000 we can OverWatch the extension

486
00:28:57,720 --> 00:29:00,600
buffer of the message into a token or

487
00:29:00,600 --> 00:29:03,120
other address through the Overflow or

488
00:29:03,120 --> 00:29:05,820
auto advance lighting and the third call

489
00:29:05,820 --> 00:29:08,159
the anti-air position rate Reserve

490
00:29:08,159 --> 00:29:11,820
function to over to that to a new

491
00:29:11,820 --> 00:29:14,059
address

492
00:29:14,100 --> 00:29:16,320
Fair passing vulnerability similar to

493
00:29:16,320 --> 00:29:18,840
CRF is still a good attack surface to

494
00:29:18,840 --> 00:29:22,320
this day evil evolving medications on

495
00:29:22,320 --> 00:29:24,659
Windows making explorers harder and

496
00:29:24,659 --> 00:29:26,940
harder

497
00:29:26,940 --> 00:29:29,460
here are the links to our references

498
00:29:29,460 --> 00:29:31,980
thank you for zero contributions

499
00:29:31,980 --> 00:29:34,880
contributions

500
00:29:35,410 --> 00:29:38,479
[Music]

501
00:29:42,320 --> 00:29:45,409
[Music]

