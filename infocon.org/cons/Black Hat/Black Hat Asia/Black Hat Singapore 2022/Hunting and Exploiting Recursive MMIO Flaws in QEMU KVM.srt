1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:08,960 --> 00:00:12,179
Welcome to our presentation it's called

4
00:00:12,179 --> 00:00:14,639
Hong Ting and the exploding recursive

5
00:00:14,639 --> 00:00:18,480
MMO flows in cumu and KVM in this talk

6
00:00:18,480 --> 00:00:20,820
we will share our security research on

7
00:00:20,820 --> 00:00:24,060
Kumi on KVM a hypervisor widely used in

8
00:00:24,060 --> 00:00:27,000
cloud computing and analyze the root

9
00:00:27,000 --> 00:00:29,099
cause and the common consequences of

10
00:00:29,099 --> 00:00:32,220
recursive mmlo thus disclosing a new

11
00:00:32,220 --> 00:00:34,820
attack service

12
00:00:34,920 --> 00:00:38,880
so who we are my name is and now I am a

13
00:00:38,880 --> 00:00:40,920
graduate student at the Harvey Institute

14
00:00:40,920 --> 00:00:43,920
of Technology coding is a PhD candidate

15
00:00:43,920 --> 00:00:46,680
at Trojan University all research errors

16
00:00:46,680 --> 00:00:49,020
include system security and default

17
00:00:49,020 --> 00:00:51,500
testing

18
00:00:54,480 --> 00:00:56,820
this is the outline of our talk

19
00:00:56,820 --> 00:00:59,879
I will try to finish it in 20 minutes so

20
00:00:59,879 --> 00:01:02,160
we can have some time for Q a

21
00:01:02,160 --> 00:01:04,199
first let's give some backgrounds about

22
00:01:04,199 --> 00:01:07,518
kumu and KVM

23
00:01:08,760 --> 00:01:11,700
KVM is a Linux kernel module that makes

24
00:01:11,700 --> 00:01:14,820
Linux behave like type 1 hypervisor it

25
00:01:14,820 --> 00:01:16,560
can prove that the hardware access to

26
00:01:16,560 --> 00:01:19,500
the virtualization to user Space Program

27
00:01:19,500 --> 00:01:22,259
is an emulated program which provides

28
00:01:22,259 --> 00:01:24,479
virtualization of an entire machine to

29
00:01:24,479 --> 00:01:26,759
run guest OS

30
00:01:26,759 --> 00:01:28,860
this figure illustrates the high-level

31
00:01:28,860 --> 00:01:31,680
architecture view of KVM with qmu

32
00:01:31,680 --> 00:01:33,659
the virtual machine and the cumul right

33
00:01:33,659 --> 00:01:36,780
in separate threads with the help of KVM

34
00:01:36,780 --> 00:01:39,720
the guest OS can execute the most of its

35
00:01:39,720 --> 00:01:40,860
instructions

36
00:01:40,860 --> 00:01:43,680
but directly on the whole CPU but when

37
00:01:43,680 --> 00:01:46,020
it tries privileged operations like for

38
00:01:46,020 --> 00:01:48,600
the map IO or memory mapped IO the

39
00:01:48,600 --> 00:01:51,780
workshop into KVM the KVM will decide

40
00:01:51,780 --> 00:01:54,780
how to handle those VM access most of

41
00:01:54,780 --> 00:01:57,299
the time KVM will return to kumu and

42
00:01:57,299 --> 00:01:59,640
tell it why the VM exits

43
00:01:59,640 --> 00:02:01,500
premium will then emanate the

44
00:02:01,500 --> 00:02:04,460
corresponding devices

45
00:02:05,880 --> 00:02:09,179
so what is recursive MMO and what are

46
00:02:09,179 --> 00:02:11,959
the root causes

47
00:02:14,060 --> 00:02:17,160
mmio is I managed by intercepting the

48
00:02:17,160 --> 00:02:19,620
memory exercise and the dma is usually

49
00:02:19,620 --> 00:02:21,980
implemented by user space memory copy

50
00:02:21,980 --> 00:02:24,720
additionally a virtual device can see an

51
00:02:24,720 --> 00:02:27,319
excise memory regions of other devices

52
00:02:27,319 --> 00:02:30,420
including the system RAM and Imam

53
00:02:30,420 --> 00:02:33,060
regions since the gas OS can control the

54
00:02:33,060 --> 00:02:36,180
Desolation address of dma

55
00:02:36,180 --> 00:02:38,580
we need to set a destination to overlap

56
00:02:38,580 --> 00:02:41,580
with mm Origins the relative IO hundreds

57
00:02:41,580 --> 00:02:43,019
will be called during the data

58
00:02:43,019 --> 00:02:44,099
transmission

59
00:02:44,099 --> 00:02:46,920
however when the rights to MMO operation

60
00:02:46,920 --> 00:02:50,220
forms a loop it will cause problems the

61
00:02:50,220 --> 00:02:52,560
Imam 100 are triggered by the dma may

62
00:02:52,560 --> 00:02:54,480
have side effects on the device that

63
00:02:54,480 --> 00:02:57,120
launch the dma so when the control flow

64
00:02:57,120 --> 00:02:59,459
returns to the device bad things may

65
00:02:59,459 --> 00:03:00,420
happen

66
00:03:00,420 --> 00:03:02,580
for example for the show in the figure

67
00:03:02,580 --> 00:03:05,640
we set a device asdma deceleration to

68
00:03:05,640 --> 00:03:07,560
its own reset register

69
00:03:07,560 --> 00:03:11,159
we it rise to the regulator is internal

70
00:03:11,159 --> 00:03:13,800
data structure will be freed after the

71
00:03:13,800 --> 00:03:16,860
recital routine returns since the io has

72
00:03:16,860 --> 00:03:19,319
not been completed the free data

73
00:03:19,319 --> 00:03:21,540
structure will be used thus triggering a

74
00:03:21,540 --> 00:03:24,379
uef exception

75
00:03:26,640 --> 00:03:29,159
this phenomenon offers a known as the

76
00:03:29,159 --> 00:03:32,280
forms of recursion for example we can

77
00:03:32,280 --> 00:03:34,800
also create an indirect recursion

78
00:03:34,800 --> 00:03:37,440
device a called the imamo Handler of

79
00:03:37,440 --> 00:03:40,560
device B through dma triggers the dma

80
00:03:40,560 --> 00:03:43,019
operation of B and the B will then

81
00:03:43,019 --> 00:03:46,819
trigger the Imam 100 of a

82
00:03:49,200 --> 00:03:52,080
from a big picture the incomplete

83
00:03:52,080 --> 00:03:55,080
isolation between dma and the MMO is the

84
00:03:55,080 --> 00:03:58,200
underlying cause of recursive MMO flows

85
00:03:58,200 --> 00:04:00,180
different CPU to device communication

86
00:04:00,180 --> 00:04:03,900
methods such as MMO and the pmio should

87
00:04:03,900 --> 00:04:06,659
not affect the dma because by definition

88
00:04:06,659 --> 00:04:09,659
dma is a memory to device communication

89
00:04:09,659 --> 00:04:14,000
method that by pass the CPU

90
00:04:14,780 --> 00:04:18,120
so in essence recursive MMO flows

91
00:04:18,120 --> 00:04:20,279
violated the constancy of device State

92
00:04:20,279 --> 00:04:21,839
machine translation

93
00:04:21,839 --> 00:04:24,240
therefore depending on the design and

94
00:04:24,240 --> 00:04:26,220
the implementation of different devices

95
00:04:26,220 --> 00:04:29,400
the harm is also different we give three

96
00:04:29,400 --> 00:04:31,620
common consequences here

97
00:04:31,620 --> 00:04:33,780
the most harmful possible vulnerability

98
00:04:33,780 --> 00:04:36,960
is the user for free and it's usually

99
00:04:36,960 --> 00:04:40,020
caused by a pardon run to MMO reset

100
00:04:40,020 --> 00:04:43,199
register free device internal data use

101
00:04:43,199 --> 00:04:44,699
free data

102
00:04:44,699 --> 00:04:47,759
if an attacker can occupy the release

103
00:04:47,759 --> 00:04:50,699
data between free and use it's possible

104
00:04:50,699 --> 00:04:54,020
to escape the virtual machine

105
00:04:54,360 --> 00:04:57,240
in some devices structures like data

106
00:04:57,240 --> 00:04:59,880
transfer size and data index are stored

107
00:04:59,880 --> 00:05:02,580
in the device's global buffer under this

108
00:05:02,580 --> 00:05:04,680
data can only checked before being used

109
00:05:04,680 --> 00:05:07,919
so attackers can launch dma to the IMO

110
00:05:07,919 --> 00:05:10,919
register that can modify this data done

111
00:05:10,919 --> 00:05:13,139
an out-of-bound exercise situation will

112
00:05:13,139 --> 00:05:14,400
happen later

113
00:05:14,400 --> 00:05:16,139
attackers May achieve information

114
00:05:16,139 --> 00:05:20,240
leakage or control flow hijacking

115
00:05:20,540 --> 00:05:23,639
finally the device May launch dma to the

116
00:05:23,639 --> 00:05:25,860
MMO register that will trigger the same

117
00:05:25,860 --> 00:05:28,740
dma action thus forming an endless

118
00:05:28,740 --> 00:05:31,320
recursive call the type attackers can

119
00:05:31,320 --> 00:05:35,479
use this photo to crash the hypervisor

120
00:05:36,440 --> 00:05:39,720
besides cumu we did some experiments on

121
00:05:39,720 --> 00:05:42,360
the Oracle which box and it seems also

122
00:05:42,360 --> 00:05:43,380
affected

123
00:05:43,380 --> 00:05:45,539
we believe that similar results can be

124
00:05:45,539 --> 00:05:47,759
achieved inside the guest OS

125
00:05:47,759 --> 00:05:49,320
uh

126
00:05:49,320 --> 00:05:52,080
we leave it as a future work to a

127
00:05:52,080 --> 00:05:53,639
research project box and other

128
00:05:53,639 --> 00:05:56,400
hypervisors you can read our white paper

129
00:05:56,400 --> 00:05:59,359
for more details

130
00:05:59,639 --> 00:06:02,039
next we will explain how to make the

131
00:06:02,039 --> 00:06:04,080
hunting and the exploitation process

132
00:06:04,080 --> 00:06:07,880
automatically with code ql

133
00:06:07,919 --> 00:06:10,139
there are two common paths to trigger

134
00:06:10,139 --> 00:06:13,919
the recursive mmio from MMO 100 to our

135
00:06:13,919 --> 00:06:16,440
other mm Handler or from a bottom half

136
00:06:16,440 --> 00:06:20,039
or timer callback to our MMA Handler to

137
00:06:20,039 --> 00:06:21,900
automatically found those paths in

138
00:06:21,900 --> 00:06:24,419
Virtual devices with code QR we first

139
00:06:24,419 --> 00:06:26,520
need to do to describe the

140
00:06:26,520 --> 00:06:29,039
characteristic of the imamo monitors and

141
00:06:29,039 --> 00:06:32,599
the pH timer callbacks

142
00:06:33,380 --> 00:06:37,080
also for the MMO handlers is defined in

143
00:06:37,080 --> 00:06:40,520
structured memory region oops

144
00:06:40,919 --> 00:06:43,979
so we can search each device's memory

145
00:06:43,979 --> 00:06:46,500
region Oaks object and gets the MMO

146
00:06:46,500 --> 00:06:49,620
handles here we all miss the MMO read

147
00:06:49,620 --> 00:06:51,840
handlers since most of them cannot

148
00:06:51,840 --> 00:06:54,380
trigger dma

149
00:06:54,380 --> 00:06:57,479
for bottom halves on the timers they are

150
00:06:57,479 --> 00:07:00,000
created by coding cumu pH and u4 at the

151
00:07:00,000 --> 00:07:02,400
timer doing less and the callbacks are

152
00:07:02,400 --> 00:07:04,020
passed over the first and the second

153
00:07:04,020 --> 00:07:06,600
parameters so we can search those two

154
00:07:06,600 --> 00:07:08,880
functions in each device to get the ph

155
00:07:08,880 --> 00:07:12,199
and the timers callback

156
00:07:13,020 --> 00:07:15,419
the last functions we need to know are

157
00:07:15,419 --> 00:07:17,880
the right to physical address apis which

158
00:07:17,880 --> 00:07:20,759
implemented which implement dma

159
00:07:20,759 --> 00:07:23,580
according to cumul's documentation there

160
00:07:23,580 --> 00:07:26,460
are a lot of such functions like DM

161
00:07:26,460 --> 00:07:29,639
memory rights psidma rights dma buffer

162
00:07:29,639 --> 00:07:30,300
read

163
00:07:30,300 --> 00:07:33,360
Etc actually the Oracle to address space

164
00:07:33,360 --> 00:07:35,639
right in the end

165
00:07:35,639 --> 00:07:37,919
so we can just search those functions

166
00:07:37,919 --> 00:07:40,020
for right to physical address sketches

167
00:07:40,020 --> 00:07:42,419
to improve the performance researching

168
00:07:42,419 --> 00:07:44,759
will hard code those functions in code

169
00:07:44,759 --> 00:07:47,539
QR queries

170
00:07:48,740 --> 00:07:51,840
then we can use the pathgraph module in

171
00:07:51,840 --> 00:07:53,940
code clearl to find all the possible

172
00:07:53,940 --> 00:07:56,699
recursive paths we need to Define our

173
00:07:56,699 --> 00:07:59,940
own LG's query predicate which is the

174
00:07:59,940 --> 00:08:02,819
core relationship under nodes which is

175
00:08:02,819 --> 00:08:05,400
arbitrary functions finally we can

176
00:08:05,400 --> 00:08:07,979
Leverage The transitive disclosures in

177
00:08:07,979 --> 00:08:11,359
colloquial to do the search

178
00:08:12,020 --> 00:08:15,300
for example there is a path from Imam

179
00:08:15,300 --> 00:08:18,419
100 to psydma right in the bigger real

180
00:08:18,419 --> 00:08:20,719
device

181
00:08:21,979 --> 00:08:24,300
we said there are three common

182
00:08:24,300 --> 00:08:26,759
consequences caused by recursive MMO

183
00:08:26,759 --> 00:08:29,879
flows user after 3 out of bonds exercise

184
00:08:29,879 --> 00:08:33,659
and earning scoring since UFC is usually

185
00:08:33,659 --> 00:08:36,659
easier to explore we only focus on this

186
00:08:36,659 --> 00:08:39,719
kind of vulnerability here to find all

187
00:08:39,719 --> 00:08:42,240
the possible UL flows we need to know

188
00:08:42,240 --> 00:08:44,820
the possible path from MMO right Handler

189
00:08:44,820 --> 00:08:46,740
to a reset function call

190
00:08:46,740 --> 00:08:49,260
similar to proper squares we can use

191
00:08:49,260 --> 00:08:52,939
codequel to do this quickly

192
00:08:53,100 --> 00:08:55,680
for example we can find a path from an

193
00:08:55,680 --> 00:08:57,779
animal right Handler to a reset function

194
00:08:57,779 --> 00:09:01,939
in the ehci controller

195
00:09:02,060 --> 00:09:05,519
now we know three types of paths

196
00:09:05,519 --> 00:09:08,459
from MMO calendar to dma right from pH

197
00:09:08,459 --> 00:09:11,580
timer callback to dma right and from ml

198
00:09:11,580 --> 00:09:13,740
right Handler to divide device reset

199
00:09:13,740 --> 00:09:14,580
function

200
00:09:14,580 --> 00:09:17,040
to find the devices which may have UF

201
00:09:17,040 --> 00:09:20,279
flows caused by direct recursive MMO we

202
00:09:20,279 --> 00:09:22,320
can calculate the intersections of those

203
00:09:22,320 --> 00:09:25,080
paths manually for example if there are

204
00:09:25,080 --> 00:09:27,240
type 1 on the type 3 path in device a

205
00:09:27,240 --> 00:09:31,820
then device a may have UF flows

206
00:09:33,920 --> 00:09:37,380
to explore the UF vulnerabilities we

207
00:09:37,380 --> 00:09:39,540
have to find The malloc Primitives which

208
00:09:39,540 --> 00:09:41,640
can occupy the free chunk the phone is

209
00:09:41,640 --> 00:09:42,480
used

210
00:09:42,480 --> 00:09:45,360
there are two possible ways first off

211
00:09:45,360 --> 00:09:47,580
the control flow returns from the MMO

212
00:09:47,580 --> 00:09:50,160
reset Handler a manlock that allocates

213
00:09:50,160 --> 00:09:52,560
chunks the same size of the free chunk

214
00:09:52,560 --> 00:09:54,660
will be called however after some

215
00:09:54,660 --> 00:09:57,060
reviews we think it's hard to find such

216
00:09:57,060 --> 00:09:59,940
Primitives in vulnerable devices

217
00:09:59,940 --> 00:10:02,700
second instead of coding Matlock in the

218
00:10:02,700 --> 00:10:04,980
same device we can write to our other

219
00:10:04,980 --> 00:10:07,620
devices MMO region in which a chunk will

220
00:10:07,620 --> 00:10:09,899
be allocated that will return to the

221
00:10:09,899 --> 00:10:11,880
vulnerable device to use the freed but

222
00:10:11,880 --> 00:10:15,300
occupied chunk since scat-gather dma is

223
00:10:15,300 --> 00:10:17,279
common it's easy to find vulnerable

224
00:10:17,279 --> 00:10:19,740
devices that perform multiple dma right

225
00:10:19,740 --> 00:10:24,380
operations so we choose this method

226
00:10:25,080 --> 00:10:27,720
so our new goal is to find a malloc that

227
00:10:27,720 --> 00:10:30,420
can be triggered by an animal rights and

228
00:10:30,420 --> 00:10:32,820
the guest can control the content of the

229
00:10:32,820 --> 00:10:35,700
allocated chunk it's best that the size

230
00:10:35,700 --> 00:10:37,800
of this chunk is also be controlled

231
00:10:37,800 --> 00:10:40,860
based on past experience we get this

232
00:10:40,860 --> 00:10:42,120
primitive has the following

233
00:10:42,120 --> 00:10:43,620
characteristics

234
00:10:43,620 --> 00:10:46,079
first there should be a freebie from the

235
00:10:46,079 --> 00:10:48,480
allocated call otherwise the guests can

236
00:10:48,480 --> 00:10:50,519
keep allocating chunks and crush the

237
00:10:50,519 --> 00:10:51,959
hypervisor

238
00:10:51,959 --> 00:10:54,480
two data structures are usually used for

239
00:10:54,480 --> 00:10:56,700
data Trends transfer between guest and

240
00:10:56,700 --> 00:10:57,480
host

241
00:10:57,480 --> 00:11:00,839
linked list and are released to get site

242
00:11:00,839 --> 00:11:03,420
control chunks we focus on Aries which

243
00:11:03,420 --> 00:11:05,399
are composed of multiple constant size

244
00:11:05,399 --> 00:11:06,540
units

245
00:11:06,540 --> 00:11:08,880
third there should be a read from gas

246
00:11:08,880 --> 00:11:11,399
action after the metal core so we can

247
00:11:11,399 --> 00:11:13,320
control the content of the allocated

248
00:11:13,320 --> 00:11:14,279
chunk

249
00:11:14,279 --> 00:11:17,459
last the parameter of 3 with from guest

250
00:11:17,459 --> 00:11:19,800
and the return value of malloc should be

251
00:11:19,800 --> 00:11:22,579
the same pointer

252
00:11:23,880 --> 00:11:26,399
then we can find the multiple free

253
00:11:26,399 --> 00:11:28,860
network pairs here we discuss a

254
00:11:28,860 --> 00:11:32,959
primitive in the Intel HDA device

255
00:11:35,519 --> 00:11:37,800
these three Matlock pair is in the

256
00:11:37,800 --> 00:11:40,019
function that gets the buffer descriptor

257
00:11:40,019 --> 00:11:42,060
list from the guest OS

258
00:11:42,060 --> 00:11:44,579
the guest OS can read arbitrary content

259
00:11:44,579 --> 00:11:45,839
to the list

260
00:11:45,839 --> 00:11:48,120
this route here is triggered by setting

261
00:11:48,120 --> 00:11:50,459
the ramp bit in hda's stream control

262
00:11:50,459 --> 00:11:54,300
registers moreover the lvi variable is

263
00:11:54,300 --> 00:11:56,399
also controlled by the guest so by

264
00:11:56,399 --> 00:11:58,560
quoting this routine the guests can

265
00:11:58,560 --> 00:12:01,140
allocate any chunk size multiple of 60

266
00:12:01,140 --> 00:12:02,820
bytes

267
00:12:02,820 --> 00:12:05,579
finally there are eight streams in the

268
00:12:05,579 --> 00:12:07,320
HDA device

269
00:12:07,320 --> 00:12:09,600
which means the guest can cause several

270
00:12:09,600 --> 00:12:11,760
free and allocated Primitives in one

271
00:12:11,760 --> 00:12:15,180
scattered dma operation so this is also

272
00:12:15,180 --> 00:12:17,459
a perfect primitive to construct the hip

273
00:12:17,459 --> 00:12:19,939
function

274
00:12:21,560 --> 00:12:24,660
using the code queries we find the

275
00:12:24,660 --> 00:12:27,120
multiple bugs here we will share two

276
00:12:27,120 --> 00:12:30,560
exportable water pages

277
00:12:31,019 --> 00:12:34,860
the first one is a UF vulnerability in

278
00:12:34,860 --> 00:12:37,800
the nvme device DMV functions can be

279
00:12:37,800 --> 00:12:39,720
called without check if the Desolation

280
00:12:39,720 --> 00:12:42,600
region is overlapped with devices MMO

281
00:12:42,600 --> 00:12:45,839
region which result in recursive MMO

282
00:12:45,839 --> 00:12:48,480
what makes this flow easy to export is

283
00:12:48,480 --> 00:12:51,120
after the result finished the nvme

284
00:12:51,120 --> 00:12:53,700
include red completion will be called in

285
00:12:53,700 --> 00:12:56,880
which cq's timer is set to fire 500

286
00:12:56,880 --> 00:12:58,380
nanoseconds later

287
00:12:58,380 --> 00:13:01,440
however the timer is freed in the reset

288
00:13:01,440 --> 00:13:03,779
routine since there is a callback

289
00:13:03,779 --> 00:13:06,120
pointer in the timer the guest can

290
00:13:06,120 --> 00:13:09,000
hijack rip directly if he can occupy the

291
00:13:09,000 --> 00:13:11,540
free timer

292
00:13:12,139 --> 00:13:15,000
the second one is a stack Overflow bug

293
00:13:15,000 --> 00:13:17,880
in the nvme device we found it we're

294
00:13:17,880 --> 00:13:20,639
reviewing the private UF bug it's a

295
00:13:20,639 --> 00:13:22,860
total recursive MMO flow but can be

296
00:13:22,860 --> 00:13:24,480
helpful later

297
00:13:24,480 --> 00:13:27,180
this function transfers device log to

298
00:13:27,180 --> 00:13:30,000
the guest OS the guest OS controls the

299
00:13:30,000 --> 00:13:33,000
variable off if it is bigger than 4K an

300
00:13:33,000 --> 00:13:34,920
integer underflow will happen and the

301
00:13:34,920 --> 00:13:37,380
transline will be set to buffen which is

302
00:13:37,380 --> 00:13:39,120
also partially controlled by the guest

303
00:13:39,120 --> 00:13:42,420
thus leading to stack overflow even

304
00:13:42,420 --> 00:13:44,639
worse since off can be set to Any number

305
00:13:44,639 --> 00:13:47,459
greater than or equal to 4K the PTR

306
00:13:47,459 --> 00:13:50,160
parameter of nvme c2h can be set to

307
00:13:50,160 --> 00:13:52,920
arbitrary address resulting in arbitrary

308
00:13:52,920 --> 00:13:55,560
memory read from the host to the guest

309
00:13:55,560 --> 00:13:58,740
last the unless this buffer is used as a

310
00:13:58,740 --> 00:14:00,779
source data of dma operations later

311
00:14:00,779 --> 00:14:04,680
which can trigger the previous UF bug so

312
00:14:04,680 --> 00:14:06,720
we can make the source data of the dma

313
00:14:06,720 --> 00:14:09,420
operation from an arbitrary address like

314
00:14:09,420 --> 00:14:13,160
the gas Ram we controlled

315
00:14:14,720 --> 00:14:17,700
diverging these two vulnerabilities now

316
00:14:17,700 --> 00:14:20,579
we will discuss how to export those

317
00:14:20,579 --> 00:14:23,220
those bugs and demonstrate a VM Escape

318
00:14:23,220 --> 00:14:25,940
in the end

319
00:14:26,639 --> 00:14:29,700
was mentioned before we go to recursive

320
00:14:29,700 --> 00:14:32,940
MMO flow triggered by dma that calls uef

321
00:14:32,940 --> 00:14:35,639
and the free structure contains a timer

322
00:14:35,639 --> 00:14:36,899
pointer

323
00:14:36,899 --> 00:14:38,940
by the way go to arbitrary memory read

324
00:14:38,940 --> 00:14:41,579
flow which can be used to bypass eslr

325
00:14:41,579 --> 00:14:44,000
and leak the gas Ram address

326
00:14:44,000 --> 00:14:46,740
there is a powerful Network primitive in

327
00:14:46,740 --> 00:14:48,540
the HDA device

328
00:14:48,540 --> 00:14:50,699
so our plan is following

329
00:14:50,699 --> 00:14:53,279
in the gas OS we construct a fixed timer

330
00:14:53,279 --> 00:14:55,980
and prepare a buffer for the MMO write

331
00:14:55,980 --> 00:14:57,660
operations later

332
00:14:57,660 --> 00:15:00,240
by leveraging the arbitrary read flow we

333
00:15:00,240 --> 00:15:03,260
can leak or sorry

334
00:15:04,740 --> 00:15:06,839
by leveraging the arbitrary reader flow

335
00:15:06,839 --> 00:15:09,779
we can leak the address of system at PLT

336
00:15:09,779 --> 00:15:12,480
and the address of the gas Ram

337
00:15:12,480 --> 00:15:14,579
since the content of the animal right

338
00:15:14,579 --> 00:15:17,220
operations in the UL flow is from the

339
00:15:17,220 --> 00:15:19,680
buffer of the arbitrary reader flow we

340
00:15:19,680 --> 00:15:21,899
make the source data of imamo Rights

341
00:15:21,899 --> 00:15:23,940
from the buffer we constructed in step

342
00:15:23,940 --> 00:15:25,260
1.

343
00:15:25,260 --> 00:15:27,300
by leveraging those two flows we

344
00:15:27,300 --> 00:15:30,180
launched together dma operations to nvme

345
00:15:30,180 --> 00:15:33,660
MMO region and the first Imam right is

346
00:15:33,660 --> 00:15:35,839
to trigger the Matlock in HDA device

347
00:15:35,839 --> 00:15:38,880
allocating three chunks the same size of

348
00:15:38,880 --> 00:15:41,399
the cumulus timer thus cleaning the T

349
00:15:41,399 --> 00:15:44,660
cache of the main thread

350
00:15:44,880 --> 00:15:47,760
in the same dma context the second

351
00:15:47,760 --> 00:15:50,459
recursive MMO writes is to the reset

352
00:15:50,459 --> 00:15:53,279
register of nvme controller releasing

353
00:15:53,279 --> 00:15:55,680
the CQ structure

354
00:15:55,680 --> 00:15:58,440
in the same dma context the last imma

355
00:15:58,440 --> 00:16:00,420
move right is to trigger another malloc

356
00:16:00,420 --> 00:16:03,420
in the HDA device thus occupying the

357
00:16:03,420 --> 00:16:04,339
free

358
00:16:04,339 --> 00:16:07,860
CQ structure and the timer pointer in CQ

359
00:16:07,860 --> 00:16:10,079
now points to the fake timer we

360
00:16:10,079 --> 00:16:12,420
constructed in step 1.

361
00:16:12,420 --> 00:16:14,940
wind timer model is correlated the

362
00:16:14,940 --> 00:16:16,680
Callback in the fake timer will be

363
00:16:16,680 --> 00:16:19,199
called since we control the Callback and

364
00:16:19,199 --> 00:16:21,839
its parameters a control flow hijack can

365
00:16:21,839 --> 00:16:24,380
be achieved

366
00:16:25,459 --> 00:16:28,560
clear we briefly give some explanations

367
00:16:28,560 --> 00:16:31,380
or you can view the white paper for more

368
00:16:31,380 --> 00:16:32,399
details

369
00:16:32,399 --> 00:16:35,339
in cumul a memory region backed by host

370
00:16:35,339 --> 00:16:37,620
mapping memory will have a corresponding

371
00:16:37,620 --> 00:16:40,440
pointer in the hip so if we can pick the

372
00:16:40,440 --> 00:16:42,540
address of the Heap and search through

373
00:16:42,540 --> 00:16:46,440
it we can get the guest Ram address

374
00:16:46,440 --> 00:16:48,720
luckily after some reviews on the stack

375
00:16:48,720 --> 00:16:51,360
we found a stable pointer that points to

376
00:16:51,360 --> 00:16:54,120
a variable in the Heap and this value is

377
00:16:54,120 --> 00:16:56,639
always below the gas ramp pointer so

378
00:16:56,639 --> 00:16:58,860
instead of getting the Base address of

379
00:16:58,860 --> 00:17:01,139
the Heap we can just search start from

380
00:17:01,139 --> 00:17:03,300
this pointer

381
00:17:03,300 --> 00:17:06,000
the next problem is how to find the Rams

382
00:17:06,000 --> 00:17:07,319
pointer on the hip

383
00:17:07,319 --> 00:17:09,839
we observe that the virtual address of

384
00:17:09,839 --> 00:17:13,199
RAM is always aligned to 14 megabytes

385
00:17:13,199 --> 00:17:15,480
when we set the gas Ram size of 2

386
00:17:15,480 --> 00:17:18,119
gigabytes and there is a stable pointer

387
00:17:18,119 --> 00:17:20,099
on the stack that points to a mapped

388
00:17:20,099 --> 00:17:22,619
memory region whose High address is the

389
00:17:22,619 --> 00:17:24,480
same as Ram's address

390
00:17:24,480 --> 00:17:27,359
last considering that only 48-bit

391
00:17:27,359 --> 00:17:30,120
addresses are available we can design

392
00:17:30,120 --> 00:17:32,340
three patterns on the search on the Heap

393
00:17:32,340 --> 00:17:35,100
in units of a device finally got the

394
00:17:35,100 --> 00:17:37,620
address of the gas Ram

395
00:17:37,620 --> 00:17:40,140
the right figure shows the process to

396
00:17:40,140 --> 00:17:43,100
leak the ram address

397
00:17:45,900 --> 00:17:48,539
when we trigger recursive MMO flows in

398
00:17:48,539 --> 00:17:52,140
the nvme device The dma Source data is

399
00:17:52,140 --> 00:17:54,780
described by a structure called PRP

400
00:17:54,780 --> 00:17:57,960
a PRP entry is a 64-bit memory physical

401
00:17:57,960 --> 00:18:00,660
address divided into two parts

402
00:18:00,660 --> 00:18:02,580
page starter address and the page

403
00:18:02,580 --> 00:18:04,080
offsite

404
00:18:04,080 --> 00:18:07,559
there are two PRP registers prp1 points

405
00:18:07,559 --> 00:18:10,320
to a page PRP to pull into a PRP list

406
00:18:10,320 --> 00:18:13,799
which contains a list of PRP entries

407
00:18:13,799 --> 00:18:15,900
this figure illustrates the PRP

408
00:18:15,900 --> 00:18:18,600
structure we use

409
00:18:18,600 --> 00:18:20,880
but which side we should trigger three

410
00:18:20,880 --> 00:18:23,100
discrete MMO rights

411
00:18:23,100 --> 00:18:25,919
so we need the three PRP entries to

412
00:18:25,919 --> 00:18:28,559
clear the tcash occupy the free timer

413
00:18:28,559 --> 00:18:30,660
and the corrupts of the timer with gas

414
00:18:30,660 --> 00:18:32,340
Ram content

415
00:18:32,340 --> 00:18:34,679
thus excluding arbitrary code on the

416
00:18:34,679 --> 00:18:37,620
host OS the reason that we must clean

417
00:18:37,620 --> 00:18:40,260
the tcash is that we found if the

418
00:18:40,260 --> 00:18:42,600
current stress T cash is for the

419
00:18:42,600 --> 00:18:44,520
allocator will pull the free chunk back

420
00:18:44,520 --> 00:18:46,320
to the thread in which the chunk is

421
00:18:46,320 --> 00:18:47,340
allocated

422
00:18:47,340 --> 00:18:49,740
this will prevent us from occupying the

423
00:18:49,740 --> 00:18:52,460
field chunk

424
00:18:53,580 --> 00:18:55,860
in this demonstration we will make the

425
00:18:55,860 --> 00:18:58,140
timers go back pointing to a system at

426
00:18:58,140 --> 00:19:00,960
the PLT under the first parameter point

427
00:19:00,960 --> 00:19:03,780
to the norm calculator stream

428
00:19:03,780 --> 00:19:08,059
so a calculator will pop out on the host

429
00:19:31,580 --> 00:19:36,260
so how to fix those flows

430
00:19:36,860 --> 00:19:39,840
there are two typical medications the

431
00:19:39,840 --> 00:19:42,299
first medication is to add busy Flags in

432
00:19:42,299 --> 00:19:45,360
every device when we enter the MMO or pH

433
00:19:45,360 --> 00:19:48,179
timer callback the busy flag is set and

434
00:19:48,179 --> 00:19:50,460
with the eye operation is completed the

435
00:19:50,460 --> 00:19:52,320
busy flag is on set

436
00:19:52,320 --> 00:19:54,780
if the PC flag is set when we enter the

437
00:19:54,780 --> 00:19:57,360
device an area will be reported

438
00:19:57,360 --> 00:20:00,059
the disadvantage is that we need to add

439
00:20:00,059 --> 00:20:01,980
code in different locations for

440
00:20:01,980 --> 00:20:03,600
different devices

441
00:20:03,600 --> 00:20:05,940
the left part of this figure illustrates

442
00:20:05,940 --> 00:20:08,660
the design of this solution

443
00:20:08,660 --> 00:20:11,160
the second medication is to put the

444
00:20:11,160 --> 00:20:14,100
checks on the bus by idolizing the data

445
00:20:14,100 --> 00:20:16,380
acceleration address on the bus the

446
00:20:16,380 --> 00:20:19,080
excise that can generate a loop is

447
00:20:19,080 --> 00:20:21,720
prevented however now we need to record

448
00:20:21,720 --> 00:20:24,240
all the devices that can be accessed

449
00:20:24,240 --> 00:20:28,440
under release the records wins over

450
00:20:28,440 --> 00:20:30,720
the right part of this figure shows the

451
00:20:30,720 --> 00:20:32,960
design of this solution

452
00:20:32,960 --> 00:20:36,059
the community adopted a hybrid solution

453
00:20:36,059 --> 00:20:38,520
which puts the checks on the box and

454
00:20:38,520 --> 00:20:40,620
leaves the device to decide whether to a

455
00:20:40,620 --> 00:20:43,020
load right into a long run area

456
00:20:43,020 --> 00:20:45,480
you can't you can view the links for

457
00:20:45,480 --> 00:20:47,840
more information

458
00:20:49,500 --> 00:20:51,600
finally would like to share some

459
00:20:51,600 --> 00:20:53,640
thoughts about bug hunting and the open

460
00:20:53,640 --> 00:20:56,240
source security

461
00:20:57,980 --> 00:21:00,840
first this design flow has a large

462
00:21:00,840 --> 00:21:03,179
impact and should be fixed as soon as

463
00:21:03,179 --> 00:21:04,860
possible

464
00:21:04,860 --> 00:21:08,520
second this flow exists in qmail for at

465
00:21:08,520 --> 00:21:10,860
least 10 years or more than one year

466
00:21:10,860 --> 00:21:12,720
just considering the large-scale

467
00:21:12,720 --> 00:21:14,160
appearance

468
00:21:14,160 --> 00:21:16,740
for this box all communication is public

469
00:21:16,740 --> 00:21:19,320
except the one we use to achieve VM

470
00:21:19,320 --> 00:21:20,160
Escape

471
00:21:20,160 --> 00:21:23,039
so if you are a malicious hiker a fast

472
00:21:23,039 --> 00:21:25,200
way to attack an open source software

473
00:21:25,200 --> 00:21:27,059
might be checking its bug tracker

474
00:21:27,059 --> 00:21:29,039
instead of finding vulnerability by

475
00:21:29,039 --> 00:21:30,539
yourself

476
00:21:30,539 --> 00:21:33,840
last we auditing the hypervisors we

477
00:21:33,840 --> 00:21:35,640
should pay attention to the different

478
00:21:35,640 --> 00:21:37,980
behaviors between virtualization

479
00:21:37,980 --> 00:21:42,020
software and the real Hardware

480
00:21:42,860 --> 00:21:45,720
we will release the white paper and the

481
00:21:45,720 --> 00:21:48,120
VM escape code on GitHub a week later

482
00:21:48,120 --> 00:21:51,299
you can find a lot of details there

483
00:21:51,299 --> 00:21:55,679
and that's all thanks for listening uh

484
00:21:55,679 --> 00:21:59,960
I think I we have some minutes for Q a

485
00:22:00,890 --> 00:22:03,959
[Music]

486
00:22:07,800 --> 00:22:10,450
[Music]

