1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:09,080 --> 00:00:12,240
thank you to be here for this talk hello

4
00:00:12,240 --> 00:00:14,099
also to the people that are watching

5
00:00:14,099 --> 00:00:16,100
this talk remotely

6
00:00:16,100 --> 00:00:19,800
so I'm Roman Tomas I'm security engineer

7
00:00:19,800 --> 00:00:22,560
at UL where I perform security

8
00:00:22,560 --> 00:00:26,720
evaluation on mobile banking app

9
00:00:26,720 --> 00:00:31,320
and I enjoy dealing with reverse

10
00:00:31,320 --> 00:00:34,140
engineering and obfuscation mostly for

11
00:00:34,140 --> 00:00:36,960
our Mobile in mobile application and I'm

12
00:00:36,960 --> 00:00:40,079
also the author of leaf which is

13
00:00:40,079 --> 00:00:43,079
library that can be used to manipulate

14
00:00:43,079 --> 00:00:45,840
the executable formats but today I will

15
00:00:45,840 --> 00:00:49,020
I will talk about Swift net which is a

16
00:00:49,020 --> 00:00:52,260
component developed by Google to check

17
00:00:52,260 --> 00:00:55,379
the Integrity of the device Android

18
00:00:55,379 --> 00:00:56,820
device

19
00:00:56,820 --> 00:00:59,879
and basically they need to de-wrap that

20
00:00:59,879 --> 00:01:01,699
because on Android

21
00:01:01,699 --> 00:01:05,339
you can access to the root privileged

22
00:01:05,339 --> 00:01:08,460
quite easily compared to iOS where you

23
00:01:08,460 --> 00:01:11,220
have to somehow find a vulnerability to

24
00:01:11,220 --> 00:01:14,159
have a Jailbreak on Android the system

25
00:01:14,159 --> 00:01:17,520
unable to get root as long as you

26
00:01:17,520 --> 00:01:21,479
disable some security feature like the

27
00:01:21,479 --> 00:01:24,020
bootloaders of secure boot

28
00:01:24,020 --> 00:01:28,799
so it brings some concern about for

29
00:01:28,799 --> 00:01:32,340
developer about knowing whether they are

30
00:01:32,340 --> 00:01:34,799
running their application on a trusted

31
00:01:34,799 --> 00:01:36,000
environment

32
00:01:36,000 --> 00:01:39,180
and that's why Google developed its own

33
00:01:39,180 --> 00:01:42,540
solution named safety net which aim at

34
00:01:42,540 --> 00:01:46,560
checking the Integrity of the device so

35
00:01:46,560 --> 00:01:49,079
when we talk about integrity we talk

36
00:01:49,079 --> 00:01:51,899
about detecting whether the device has

37
00:01:51,899 --> 00:01:56,759
been rooted whether the the system is a

38
00:01:56,759 --> 00:01:59,520
custom firmware or even if it's an

39
00:01:59,520 --> 00:02:01,439
emulator

40
00:02:01,439 --> 00:02:03,840
and basically when you are a developer

41
00:02:03,840 --> 00:02:06,719
you might want to know if you can trust

42
00:02:06,719 --> 00:02:09,179
the device on which the application will

43
00:02:09,179 --> 00:02:12,480
run because for instance for the video

44
00:02:12,480 --> 00:02:15,239
game industry they don't want to run

45
00:02:15,239 --> 00:02:18,180
their game on a device that has been

46
00:02:18,180 --> 00:02:21,300
rooted because maybe it could enable to

47
00:02:21,300 --> 00:02:23,840
easily cheat the application

48
00:02:23,840 --> 00:02:28,080
also in the bank industry they they are

49
00:02:28,080 --> 00:02:31,440
not allowed to run the banking app on a

50
00:02:31,440 --> 00:02:33,060
device that has been rooted for instance

51
00:02:33,060 --> 00:02:35,599
and it's not about

52
00:02:35,599 --> 00:02:38,640
whether the developer would support the

53
00:02:38,640 --> 00:02:40,680
device or not it's a certification that

54
00:02:40,680 --> 00:02:42,900
said you can't run the application on a

55
00:02:42,900 --> 00:02:45,300
rooted device so that's why they create

56
00:02:45,300 --> 00:02:48,120
a safety net to check the Integrity of

57
00:02:48,120 --> 00:02:50,160
the Android device because it's easy to

58
00:02:50,160 --> 00:02:52,200
get food on Android device

59
00:02:52,200 --> 00:02:55,500
so from a developer point of view you

60
00:02:55,500 --> 00:02:57,480
have basically to provide two

61
00:02:57,480 --> 00:03:01,440
information uh one is the API key of

62
00:03:01,440 --> 00:03:04,739
safety net which is used to identify the

63
00:03:04,739 --> 00:03:07,920
developer and the other parameter is a

64
00:03:07,920 --> 00:03:10,920
numps which is used basically to avoid

65
00:03:10,920 --> 00:03:14,340
some kind of attack like replay attack

66
00:03:14,340 --> 00:03:16,980
and when the developer provides these

67
00:03:16,980 --> 00:03:19,080
two information it will get the result

68
00:03:19,080 --> 00:03:22,739
of the safety net attestation to one

69
00:03:22,739 --> 00:03:25,200
callback I mean to call back if there is

70
00:03:25,200 --> 00:03:28,200
a failure but mostly one in the case

71
00:03:28,200 --> 00:03:31,500
where it's a success and safety net will

72
00:03:31,500 --> 00:03:33,959
provide information about whether the

73
00:03:33,959 --> 00:03:38,640
device can be considered as safe or not

74
00:03:38,640 --> 00:03:42,540
so why doing this torque uh at bracket

75
00:03:42,540 --> 00:03:46,019
Asia so because basically in 2017 there

76
00:03:46,019 --> 00:03:47,879
were already a torque at black at Europe

77
00:03:47,879 --> 00:03:50,519
about safety net and Colleen and John

78
00:03:50,519 --> 00:03:54,180
presented some uh inner work of how

79
00:03:54,180 --> 00:03:57,060
safety net is designed and they

80
00:03:57,060 --> 00:03:59,220
mentioned also a component Droid guard

81
00:03:59,220 --> 00:04:01,980
but they did not explain a lot about how

82
00:04:01,980 --> 00:04:04,519
it is used and how it works

83
00:04:04,519 --> 00:04:08,819
and by the time there were also magisk

84
00:04:08,819 --> 00:04:11,519
which is the routing solution for

85
00:04:11,519 --> 00:04:14,400
Android and that enabled to easily

86
00:04:14,400 --> 00:04:16,918
bypass theft net so it's very well

87
00:04:16,918 --> 00:04:19,260
designed and they they find some tricks

88
00:04:19,260 --> 00:04:22,260
to basically enable to bypass theft net

89
00:04:22,260 --> 00:04:26,040
like just by enabler a setting in the in

90
00:04:26,040 --> 00:04:28,380
the in the application so it's very easy

91
00:04:28,380 --> 00:04:31,259
to actually it was actually very easy to

92
00:04:31,259 --> 00:04:34,199
to bypass the net thanks to Magics and

93
00:04:34,199 --> 00:04:35,639
Magic sky

94
00:04:35,639 --> 00:04:39,060
and Google did some improvement because

95
00:04:39,060 --> 00:04:41,880
of this routing solution where basically

96
00:04:41,880 --> 00:04:42,860
they

97
00:04:42,860 --> 00:04:45,300
improved that net with some kind of

98
00:04:45,300 --> 00:04:48,320
Hardware attestation which

99
00:04:48,320 --> 00:04:51,300
leverage some Hardware feature of the

100
00:04:51,300 --> 00:04:54,479
device uh to know whether the bootloader

101
00:04:54,479 --> 00:04:56,580
has been unlocked or not which is which

102
00:04:56,580 --> 00:05:01,040
can be a sign of a rooted device

103
00:05:01,040 --> 00:05:02,639
and

104
00:05:02,639 --> 00:05:05,520
um safety net will will provide two flag

105
00:05:05,520 --> 00:05:07,740
basically to determine whether the

106
00:05:07,740 --> 00:05:10,800
devices is safe or not the fourth one is

107
00:05:10,800 --> 00:05:12,720
basic integrity and the second one is

108
00:05:12,720 --> 00:05:15,540
the CTF profile match here are the

109
00:05:15,540 --> 00:05:17,460
descriptions that are available on the

110
00:05:17,460 --> 00:05:21,120
Google Website but basically the basic

111
00:05:21,120 --> 00:05:23,699
Integrity check will determine whether

112
00:05:23,699 --> 00:05:25,680
the device is rooted if it's an emulator

113
00:05:25,680 --> 00:05:29,580
and if there are some presence of API

114
00:05:29,580 --> 00:05:32,160
hooking like Freda and on the other end

115
00:05:32,160 --> 00:05:35,460
CTF CTS profile match will do the same

116
00:05:35,460 --> 00:05:38,280
more or less the same check as basic

117
00:05:38,280 --> 00:05:41,160
Integrity but it will also detect if

118
00:05:41,160 --> 00:05:44,400
your workloader is unlocked which is one

119
00:05:44,400 --> 00:05:47,400
step to get food on an Android device

120
00:05:47,400 --> 00:05:50,639
but the important Point here is that CTF

121
00:05:50,639 --> 00:05:53,580
profile match will be set to false if

122
00:05:53,580 --> 00:05:56,039
the device did not pass the Google

123
00:05:56,039 --> 00:05:59,100
certification so it can bring some full

124
00:05:59,100 --> 00:06:03,120
positive uh in the attestation

125
00:06:03,120 --> 00:06:07,320
and back in January of this year the

126
00:06:07,320 --> 00:06:10,979
main developer of magisk join Google and

127
00:06:10,979 --> 00:06:14,820
because of some conflict of interest I

128
00:06:14,820 --> 00:06:17,699
guess he decided to remove Magic's guide

129
00:06:17,699 --> 00:06:22,500
from the release 24. so now in the

130
00:06:22,500 --> 00:06:24,360
latest version of magic there is no

131
00:06:24,360 --> 00:06:27,680
magic Island we can't use it to bypass

132
00:06:27,680 --> 00:06:31,319
the the root detection of 30 net and

133
00:06:31,319 --> 00:06:34,259
other rasp solution

134
00:06:34,259 --> 00:06:38,520
so now if we go back to the snippet that

135
00:06:38,520 --> 00:06:40,560
show how to use a safety net from a

136
00:06:40,560 --> 00:06:42,720
developer point of view now from a

137
00:06:42,720 --> 00:06:44,180
system perspective

138
00:06:44,180 --> 00:06:48,419
a safety net the developer will will

139
00:06:48,419 --> 00:06:51,539
trigger a safety net request through the

140
00:06:51,539 --> 00:06:54,180
safety net SDK that takes place in the

141
00:06:54,180 --> 00:06:57,240
blue area

142
00:06:57,240 --> 00:07:01,620
the safety net SDK will will craft a

143
00:07:01,620 --> 00:07:03,120
message that will contain basic

144
00:07:03,120 --> 00:07:05,160
information about the application that

145
00:07:05,160 --> 00:07:09,060
ask for the request it will forward this

146
00:07:09,060 --> 00:07:12,780
information through an intent to DMS car

147
00:07:12,780 --> 00:07:16,680
GMS car on Android is is a component

148
00:07:16,680 --> 00:07:20,099
that contains all the Google logic uh on

149
00:07:20,099 --> 00:07:23,520
the device this component GMS score will

150
00:07:23,520 --> 00:07:26,340
perform some very classical root check

151
00:07:26,340 --> 00:07:29,699
on the device so if we check if for

152
00:07:29,699 --> 00:07:32,960
instance the Su binary is present

153
00:07:32,960 --> 00:07:36,120
and it will start also to create a

154
00:07:36,120 --> 00:07:38,099
protobuf message that will contain the

155
00:07:38,099 --> 00:07:41,099
information about the Integrity of the

156
00:07:41,099 --> 00:07:41,880
device

157
00:07:41,880 --> 00:07:45,180
then GMS score will call Droid guard

158
00:07:45,180 --> 00:07:48,660
which is another component that runs in

159
00:07:48,660 --> 00:07:51,259
another process but that is very close

160
00:07:51,259 --> 00:07:55,020
in terms of communication I would say to

161
00:07:55,020 --> 00:07:58,139
a GMS Curve droidguard will perform the

162
00:07:58,139 --> 00:08:00,900
AV check to determine whether your

163
00:08:00,900 --> 00:08:04,319
device is is safe or not I mean if the

164
00:08:04,319 --> 00:08:05,880
device has been rooted if it's an

165
00:08:05,880 --> 00:08:08,460
emulator and so on so most of the check

166
00:08:08,460 --> 00:08:11,639
of setting net are done through Droid

167
00:08:11,639 --> 00:08:15,240
gel then Droid guard will send the razor

168
00:08:15,240 --> 00:08:18,479
to GMS curve that would throw up the the

169
00:08:18,479 --> 00:08:20,940
information to the Google backend and

170
00:08:20,940 --> 00:08:23,280
the Google backend will decide which

171
00:08:23,280 --> 00:08:26,580
flag to set to false or true

172
00:08:26,580 --> 00:08:31,080
so here is uh the protobuf message that

173
00:08:31,080 --> 00:08:33,059
is created by

174
00:08:33,059 --> 00:08:39,179
um by GMS score so in The Orange Box you

175
00:08:39,179 --> 00:08:41,339
have the basic information about the

176
00:08:41,339 --> 00:08:44,580
application that ask for the attestation

177
00:08:44,580 --> 00:08:48,240
you have also uh some information about

178
00:08:48,240 --> 00:08:49,560
the

179
00:08:49,560 --> 00:08:54,420
small and easy checkfruit and else LC

180
00:08:54,420 --> 00:08:57,540
Linux status so here it's just about

181
00:08:57,540 --> 00:09:00,779
Java check so it's not obfuscated it's I

182
00:09:00,779 --> 00:09:04,200
mean you have to reverse the GMS APK but

183
00:09:04,200 --> 00:09:07,080
it's very straightforward to notify and

184
00:09:07,080 --> 00:09:09,720
on the other end uh Droid guard the

185
00:09:09,720 --> 00:09:12,600
result of Joy gut will be happen to this

186
00:09:12,600 --> 00:09:13,399
message

187
00:09:13,399 --> 00:09:17,040
and will it contains some a blob of data

188
00:09:17,040 --> 00:09:19,740
which looks like a blob of data that it

189
00:09:19,740 --> 00:09:22,019
actually contains a lot of information

190
00:09:22,019 --> 00:09:24,959
about the statues of the device

191
00:09:24,959 --> 00:09:27,720
this protograph message is sent to the

192
00:09:27,720 --> 00:09:30,360
Google backend that will do some

193
00:09:30,360 --> 00:09:33,180
computation to determine the results of

194
00:09:33,180 --> 00:09:35,279
the safety net request

195
00:09:35,279 --> 00:09:39,000
so the goal of this talk is mostly to

196
00:09:39,000 --> 00:09:42,540
present Droid guard which is a heavy

197
00:09:42,540 --> 00:09:44,880
model that contain different kind of

198
00:09:44,880 --> 00:09:47,160
different layer of obfuscation

199
00:09:47,160 --> 00:09:49,380
and in particular the normal of this

200
00:09:49,380 --> 00:09:51,120
talk is not to present a new technique

201
00:09:51,120 --> 00:09:54,360
to bypassive net because it's not a verb

202
00:09:54,360 --> 00:09:56,100
proportion just to provide a description

203
00:09:56,100 --> 00:09:59,160
of how it works

204
00:09:59,160 --> 00:10:02,100
so the question now is

205
00:10:02,100 --> 00:10:05,820
how this value generated through Joy

206
00:10:05,820 --> 00:10:08,459
guard is actually generated and what

207
00:10:08,459 --> 00:10:11,820
kind of information it contains

208
00:10:11,820 --> 00:10:15,200
so as I said quickly uh just before

209
00:10:15,200 --> 00:10:18,680
Droid Garner run in a different process

210
00:10:18,680 --> 00:10:21,720
than GMS score so the name of the

211
00:10:21,720 --> 00:10:25,680
process is com Android Google GMS

212
00:10:25,680 --> 00:10:29,580
unstable and it's associated with an APK

213
00:10:29,580 --> 00:10:35,040
that is located in the data partition of

214
00:10:35,040 --> 00:10:37,040
the of the application

215
00:10:37,040 --> 00:10:39,779
actually this APK is dynamically

216
00:10:39,779 --> 00:10:41,700
downloaded from the Google server so

217
00:10:41,700 --> 00:10:43,500
it's not an APK that is already

218
00:10:43,500 --> 00:10:45,839
installed on the system it's an APK that

219
00:10:45,839 --> 00:10:48,660
is updated every two weeks and that

220
00:10:48,660 --> 00:10:52,260
contain a small Java layer and a native

221
00:10:52,260 --> 00:10:55,320
Library written in C plus plus that

222
00:10:55,320 --> 00:10:59,120
Implement somehow a VM

223
00:10:59,120 --> 00:11:03,600
and this VM is heavily obfuscated with

224
00:11:03,600 --> 00:11:05,339
different kind of different layers that

225
00:11:05,339 --> 00:11:08,279
I will describe a bit later and it

226
00:11:08,279 --> 00:11:11,220
contained all the logic of the the

227
00:11:11,220 --> 00:11:12,899
drawing card

228
00:11:12,899 --> 00:11:16,140
so just to summarize a bit of the the

229
00:11:16,140 --> 00:11:20,279
process of Joy guard so first GMS score

230
00:11:20,279 --> 00:11:23,459
will trigger an event that will start

231
00:11:23,459 --> 00:11:27,779
Droid guard then drill guard will run uh

232
00:11:27,779 --> 00:11:31,640
the bike provided by the Java layer so

233
00:11:31,640 --> 00:11:35,640
as I said Droid guard Implement a VM and

234
00:11:35,640 --> 00:11:37,860
to use the VM you have to provide a

235
00:11:37,860 --> 00:11:40,620
bytecode and this bytecode is actually

236
00:11:40,620 --> 00:11:44,220
downloaded for each other station

237
00:11:44,220 --> 00:11:47,399
so Droid guard starts with the Java

238
00:11:47,399 --> 00:11:50,399
layer that you just choose to bridge uh

239
00:11:50,399 --> 00:11:53,100
with a native layer that is located in

240
00:11:53,100 --> 00:11:55,019
the native Library this native library

241
00:11:55,019 --> 00:11:59,640
is obfuscated with MDA with on CD

242
00:11:59,640 --> 00:12:01,459
burgundy hooking

243
00:12:01,459 --> 00:12:04,680
all the buffer on Kodi I mean you have

244
00:12:04,680 --> 00:12:07,079
different kind of layer of obscation

245
00:12:07,079 --> 00:12:10,019
Droid guard also download the bytecode

246
00:12:10,019 --> 00:12:12,420
for each attestation which means that

247
00:12:12,420 --> 00:12:16,860
each time the developer asks for an

248
00:12:16,860 --> 00:12:19,200
attestation Droid guard will download a

249
00:12:19,200 --> 00:12:22,800
dedicated bytecode for the site station

250
00:12:22,800 --> 00:12:25,920
so remember you have this APK that is

251
00:12:25,920 --> 00:12:28,380
updated every two weeks

252
00:12:28,380 --> 00:12:31,320
and the bytecode running through this VM

253
00:12:31,320 --> 00:12:33,959
is downloaded each time

254
00:12:33,959 --> 00:12:36,839
for each attestation and of course there

255
00:12:36,839 --> 00:12:39,120
are some small modification for each

256
00:12:39,120 --> 00:12:42,240
bytecode which can be difficult to

257
00:12:42,240 --> 00:12:44,700
analyze because first when you reverse

258
00:12:44,700 --> 00:12:47,040
the APK you have to be somehow quick

259
00:12:47,040 --> 00:12:49,860
because every two weeks it change I mean

260
00:12:49,860 --> 00:12:52,079
some part of the VM change and the

261
00:12:52,079 --> 00:12:55,139
bytecode is downloaded each time then

262
00:12:55,139 --> 00:12:58,380
the bad gun sorry the bite could run

263
00:12:58,380 --> 00:13:00,240
through the VM

264
00:13:00,240 --> 00:13:02,220
the bite cut contain actually all the

265
00:13:02,220 --> 00:13:04,800
check to determine if it's an emulator

266
00:13:04,800 --> 00:13:07,920
if it's uh if the device is rooted if

267
00:13:07,920 --> 00:13:10,920
there are some uh hint about hooking

268
00:13:10,920 --> 00:13:13,079
from Rock and sun

269
00:13:13,079 --> 00:13:16,320
it will also generate the token name

270
00:13:16,320 --> 00:13:19,500
Droid guard this token will be sent back

271
00:13:19,500 --> 00:13:23,700
to the Droid guard main class uh in the

272
00:13:23,700 --> 00:13:27,540
the APK and then it will be sent to GMS

273
00:13:27,540 --> 00:13:29,639
score that will add this value to the

274
00:13:29,639 --> 00:13:31,320
product message and that will be

275
00:13:31,320 --> 00:13:33,240
eventually sent

276
00:13:33,240 --> 00:13:36,720
to the Google backend

277
00:13:36,720 --> 00:13:39,300
so if we want to understand how certain

278
00:13:39,300 --> 00:13:41,160
Network we basically need to understand

279
00:13:41,160 --> 00:13:44,940
how the VM is designed and how the byte

280
00:13:44,940 --> 00:13:46,980
code what kind of info what kind of

281
00:13:46,980 --> 00:13:50,220
action are done through this bytecode so

282
00:13:50,220 --> 00:13:54,300
is a 40 minute turns and it's outlined a

283
00:13:54,300 --> 00:13:56,279
month of research so I will just

284
00:13:56,279 --> 00:13:58,920
describe some feature of the VM and you

285
00:13:58,920 --> 00:14:00,980
can find more details in the white paper

286
00:14:00,980 --> 00:14:05,120
so basically the VM is designed with a

287
00:14:05,120 --> 00:14:10,500
256 registers that can contain a typed

288
00:14:10,500 --> 00:14:13,320
value I mean register it's a virtual

289
00:14:13,320 --> 00:14:15,000
register so it's basically a simple

290
00:14:15,000 --> 00:14:17,100
Express structure that contains a type

291
00:14:17,100 --> 00:14:20,040
and a value and the type can be a

292
00:14:20,040 --> 00:14:22,920
pointer can be a double can be a gni

293
00:14:22,920 --> 00:14:26,519
object it can be also a string and so on

294
00:14:26,519 --> 00:14:30,899
and uh for each new version of uh Droid

295
00:14:30,899 --> 00:14:34,740
guard they are changing the layout of

296
00:14:34,740 --> 00:14:37,620
Android ID of this register which means

297
00:14:37,620 --> 00:14:39,120
that basically if you manage to be

298
00:14:39,120 --> 00:14:41,940
notify that in the version a of droid

299
00:14:41,940 --> 00:14:45,380
guard an integer is associated with one

300
00:14:45,380 --> 00:14:50,220
or three in the next version the integer

301
00:14:50,220 --> 00:14:53,399
type will be associated with one

302
00:14:53,399 --> 00:14:55,079
so that's one of the challenge when

303
00:14:55,079 --> 00:14:57,600
reverse engineering Droid

304
00:14:57,600 --> 00:15:01,019
here is an example that perform a right

305
00:15:01,019 --> 00:15:04,139
operation in the VM so basically here is

306
00:15:04,139 --> 00:15:07,079
the the function that we just write a

307
00:15:07,079 --> 00:15:10,800
value uh in the VM register so on the

308
00:15:10,800 --> 00:15:11,639
top

309
00:15:11,639 --> 00:15:15,360
you have a mixed Boolean arithmetic

310
00:15:15,360 --> 00:15:17,519
expression which is used basically to

311
00:15:17,519 --> 00:15:20,459
encode or to decode a register value

312
00:15:20,459 --> 00:15:23,220
because in the joygard VM all the value

313
00:15:23,220 --> 00:15:25,860
of the register are encoded which means

314
00:15:25,860 --> 00:15:29,160
that if somehow you manage to dump all

315
00:15:29,160 --> 00:15:31,740
the register value you won't be able to

316
00:15:31,740 --> 00:15:34,019
see what their what value they are

317
00:15:34,019 --> 00:15:35,820
actually because all the value are

318
00:15:35,820 --> 00:15:38,760
encoded and they are encoded through MBA

319
00:15:38,760 --> 00:15:41,579
and the MBA are changing every two weeks

320
00:15:41,579 --> 00:15:44,579
because of the VM update so here you

321
00:15:44,579 --> 00:15:47,760
have the decoding part of the the

322
00:15:47,760 --> 00:15:51,120
register value then here you have uh

323
00:15:51,120 --> 00:15:54,420
basically the STD string Destructor

324
00:15:54,420 --> 00:15:57,420
because as I said Droid guard is written

325
00:15:57,420 --> 00:15:59,540
in simplest groups and there are some

326
00:15:59,540 --> 00:16:02,160
optimizations that are done through STD

327
00:16:02,160 --> 00:16:05,579
string and here it's the aligning of the

328
00:16:05,579 --> 00:16:08,820
destructor of STD string here you have

329
00:16:08,820 --> 00:16:12,060
on the right hand side Diablo education

330
00:16:12,060 --> 00:16:14,399
of your dni object because basically

331
00:16:14,399 --> 00:16:17,459
when you want to write a value in a

332
00:16:17,459 --> 00:16:19,680
register of the VM you have to

333
00:16:19,680 --> 00:16:22,380
disallocate the previous value

334
00:16:22,380 --> 00:16:24,959
so here they are safely removing the

335
00:16:24,959 --> 00:16:28,320
produce value and then on the bottom you

336
00:16:28,320 --> 00:16:30,779
have a MBA that will encode the actual

337
00:16:30,779 --> 00:16:33,180
value so here just to give you an idea

338
00:16:33,180 --> 00:16:34,440
of how

339
00:16:34,440 --> 00:16:37,740
it can looks like to reverse engineering

340
00:16:37,740 --> 00:16:40,560
so basically in the drawing Gap VM you

341
00:16:40,560 --> 00:16:43,860
have a dedicated Handler that can be

342
00:16:43,860 --> 00:16:45,800
used to perform Cisco to perform

343
00:16:45,800 --> 00:16:49,259
arithmetical operation to perform gni

344
00:16:49,259 --> 00:16:52,440
called and so on and here is a basic

345
00:16:52,440 --> 00:16:55,620
block that will initialize the the

346
00:16:55,620 --> 00:16:57,720
different Handler so basically they are

347
00:16:57,720 --> 00:17:02,399
storing a pointer into the VM object

348
00:17:02,399 --> 00:17:05,459
so now regarding the execution of the by

349
00:17:05,459 --> 00:17:09,720
code you have basically a sequence of VM

350
00:17:09,720 --> 00:17:12,599
Handler that are used to perform some

351
00:17:12,599 --> 00:17:15,240
computation or some check on the device

352
00:17:15,240 --> 00:17:19,919
so the first Handler is used to read the

353
00:17:19,919 --> 00:17:23,160
for instance a register then you will

354
00:17:23,160 --> 00:17:25,740
you will reserve the symbol that is

355
00:17:25,740 --> 00:17:28,679
associated with a buffer clock get time

356
00:17:28,679 --> 00:17:31,620
and so on and basically all the sequence

357
00:17:31,620 --> 00:17:36,480
is used to detect uh whether the device

358
00:17:36,480 --> 00:17:40,140
is sorry whether the application is

359
00:17:40,140 --> 00:17:42,240
under debugging because basically you

360
00:17:42,240 --> 00:17:44,580
can compute the time between you the

361
00:17:44,580 --> 00:17:47,160
first call to clock get time and the

362
00:17:47,160 --> 00:17:49,080
second call to block date time you can

363
00:17:49,080 --> 00:17:51,360
determine whether it takes too much time

364
00:17:51,360 --> 00:17:54,000
on it so here you have a sequence of

365
00:17:54,000 --> 00:17:55,860
Handler and you have the same for

366
00:17:55,860 --> 00:17:58,020
instance with the cooking or to detect

367
00:17:58,020 --> 00:18:02,840
to detect a root on the device

368
00:18:02,840 --> 00:18:08,039
now about what kind of check are done to

369
00:18:08,039 --> 00:18:09,740
detect food

370
00:18:09,740 --> 00:18:12,960
so once we manage somehow to identify

371
00:18:12,960 --> 00:18:15,960
the different Handler and we notify uh

372
00:18:15,960 --> 00:18:19,559
how the byte code Works within the VM we

373
00:18:19,559 --> 00:18:22,559
can try to Analyze This bytecode

374
00:18:22,559 --> 00:18:24,960
so here is an example of

375
00:18:24,960 --> 00:18:29,100
a sequence of of the die cut so actually

376
00:18:29,100 --> 00:18:31,380
it's just a representation it's

377
00:18:31,380 --> 00:18:33,600
I mean it's from reverse engineering

378
00:18:33,600 --> 00:18:36,000
Dynamic analysis and so on but basically

379
00:18:36,000 --> 00:18:37,740
there is an example where they are

380
00:18:37,740 --> 00:18:41,280
checking whether the data local x-bin

381
00:18:41,280 --> 00:18:44,880
exists so first they are calling the

382
00:18:44,880 --> 00:18:49,200
read buffer VM Handler that decode the

383
00:18:49,200 --> 00:18:52,380
string data local xbin and then they are

384
00:18:52,380 --> 00:18:55,559
calling the cool function Handler that

385
00:18:55,559 --> 00:18:58,039
will be used to perform a ciscal

386
00:18:58,039 --> 00:19:01,020
associated with f access at so actually

387
00:19:01,020 --> 00:19:04,679
F access at is not hard coded in the in

388
00:19:04,679 --> 00:19:08,880
the in the VM it's just a result of the

389
00:19:08,880 --> 00:19:11,179
execution of the bytecode

390
00:19:11,179 --> 00:19:14,700
so among the different Czech to detect

391
00:19:14,700 --> 00:19:17,280
uh if it's a rooted device we have the

392
00:19:17,280 --> 00:19:19,740
classical one so data locality and PS3

393
00:19:19,740 --> 00:19:22,620
and so on so nothing very fancy I will

394
00:19:22,620 --> 00:19:26,280
say on this point uh same you have some

395
00:19:26,280 --> 00:19:29,940
system property check so did just some

396
00:19:29,940 --> 00:19:32,900
yeah some strings that can notify

397
00:19:32,900 --> 00:19:36,179
and basically to determine whether there

398
00:19:36,179 --> 00:19:39,720
are some presence of a happy eye looking

399
00:19:39,720 --> 00:19:42,720
they are checking if some libraries are

400
00:19:42,720 --> 00:19:45,240
present in the memory space of a Droid

401
00:19:45,240 --> 00:19:47,340
gout so here is an example where they

402
00:19:47,340 --> 00:19:50,418
are the checking if

403
00:19:50,539 --> 00:19:53,700
they expose is present

404
00:19:53,700 --> 00:19:56,400
so you have the same for free that I

405
00:19:56,400 --> 00:20:00,179
learned for lips and organ and so on

406
00:20:00,179 --> 00:20:02,580
the interesting point that I found when

407
00:20:02,580 --> 00:20:04,440
reverse engineering this die cut is that

408
00:20:04,440 --> 00:20:06,240
basically they are also able to detect

409
00:20:06,240 --> 00:20:10,020
uh whether the device has been infected

410
00:20:10,020 --> 00:20:12,240
with Pegasus so there is some kind of

411
00:20:12,240 --> 00:20:15,299
iuc to detect if there are some presence

412
00:20:15,299 --> 00:20:18,480
of pages which is can be quite rare

413
00:20:18,480 --> 00:20:21,240
because it's not like the normal way of

414
00:20:21,240 --> 00:20:23,039
rooting your device but they are able to

415
00:20:23,039 --> 00:20:24,780
detect it

416
00:20:24,780 --> 00:20:27,660
in addition to this check they are doing

417
00:20:27,660 --> 00:20:30,240
some kind of telemetry to collect

418
00:20:30,240 --> 00:20:32,640
information about the device and about

419
00:20:32,640 --> 00:20:35,160
the environment and to send this

420
00:20:35,160 --> 00:20:36,900
information to the Google backend that

421
00:20:36,900 --> 00:20:40,320
will perform some Advent check and based

422
00:20:40,320 --> 00:20:42,840
on this information so it's a kind of

423
00:20:42,840 --> 00:20:45,059
trade-off to find between

424
00:20:45,059 --> 00:20:47,580
checking if for instance this Library

425
00:20:47,580 --> 00:20:49,799
are present during the execution where

426
00:20:49,799 --> 00:20:52,320
you get basically a Boolean value true

427
00:20:52,320 --> 00:20:55,400
or false and collecting information

428
00:20:55,400 --> 00:20:59,460
about the environment of the device so

429
00:20:59,460 --> 00:21:01,140
they are collecting information about

430
00:21:01,140 --> 00:21:06,240
for instance the zygote process they are

431
00:21:06,240 --> 00:21:08,460
collecting information about the system

432
00:21:08,460 --> 00:21:11,840
properties related to the bootloader

433
00:21:11,840 --> 00:21:13,980
they are also collecting information

434
00:21:13,980 --> 00:21:16,919
about kernel info and so on but they

435
00:21:16,919 --> 00:21:18,900
need to find a trade-off between

436
00:21:18,900 --> 00:21:22,500
collecting everything which can be which

437
00:21:22,500 --> 00:21:25,620
can cause a lot of data to send and

438
00:21:25,620 --> 00:21:28,020
doing Boolean checked that can be

439
00:21:28,020 --> 00:21:31,020
somehow easy to bypass because basically

440
00:21:31,020 --> 00:21:32,820
if you manage to bypass the c-score

441
00:21:32,820 --> 00:21:35,760
that's that's done so here you don't

442
00:21:35,760 --> 00:21:38,760
know actually how it is really used

443
00:21:38,760 --> 00:21:41,640
in the Google backend which is near mine

444
00:21:41,640 --> 00:21:44,760
the basic integrity and the CTS profile

445
00:21:44,760 --> 00:21:46,020
match

446
00:21:46,020 --> 00:21:49,520
so here is another list of information

447
00:21:49,520 --> 00:21:52,679
on the top here you have also the

448
00:21:52,679 --> 00:21:55,320
certificate chain that is used to

449
00:21:55,320 --> 00:21:57,780
perform the hardware attestation so the

450
00:21:57,780 --> 00:21:59,880
hardware decision is not something very

451
00:21:59,880 --> 00:22:03,360
magic in that net it's come from a

452
00:22:03,360 --> 00:22:06,559
public API that developer can also use

453
00:22:06,559 --> 00:22:09,840
and they are basically sending the world

454
00:22:09,840 --> 00:22:13,080
certificate certification chain to the

455
00:22:13,080 --> 00:22:15,480
Google backend that check that the chain

456
00:22:15,480 --> 00:22:18,419
is is valid and has not been corrupted

457
00:22:18,419 --> 00:22:20,640
and that helps the bootloader is log or

458
00:22:20,640 --> 00:22:21,539
not

459
00:22:21,539 --> 00:22:24,720
uh so to summarize uh Droid guard

460
00:22:24,720 --> 00:22:27,659
collect different information about the

461
00:22:27,659 --> 00:22:30,740
device by running a dedicated bytecode

462
00:22:30,740 --> 00:22:34,500
uh in a VM that is updated every two

463
00:22:34,500 --> 00:22:39,480
weeks and this final token is compiled

464
00:22:39,480 --> 00:22:42,600
from Boolean check that verify whether

465
00:22:42,600 --> 00:22:45,720
this file is present or not or if the

466
00:22:45,720 --> 00:22:48,360
library is present in memory or not and

467
00:22:48,360 --> 00:22:51,059
from Telemetry data

468
00:22:51,059 --> 00:22:54,360
that basically are a collection of

469
00:22:54,360 --> 00:22:57,120
information about the device and you

470
00:22:57,120 --> 00:22:59,820
don't know exactly how it is used by the

471
00:22:59,820 --> 00:23:01,039
Google backend

472
00:23:01,039 --> 00:23:05,039
to to to check the Integrity of the

473
00:23:05,039 --> 00:23:05,940
device

474
00:23:05,940 --> 00:23:08,120
foreign

475
00:23:08,280 --> 00:23:11,960
actually safety net and

476
00:23:11,960 --> 00:23:14,480
use a design

477
00:23:14,480 --> 00:23:19,200
on a VM and a bygone but actually Google

478
00:23:19,200 --> 00:23:22,080
use this design to run different kind of

479
00:23:22,080 --> 00:23:25,620
backgrounds so when I analyze the safety

480
00:23:25,620 --> 00:23:29,039
net I was focused on a byte code that

481
00:23:29,039 --> 00:23:31,260
aim at checking the Integrity of the

482
00:23:31,260 --> 00:23:35,580
device but they are also able to run a

483
00:23:35,580 --> 00:23:38,100
dedicated by God for instance to check

484
00:23:38,100 --> 00:23:41,340
during the device enrollment with your

485
00:23:41,340 --> 00:23:44,640
Google account whether you are a bot or

486
00:23:44,640 --> 00:23:47,159
not for instance and there are there are

487
00:23:47,159 --> 00:23:49,320
different byte code dedicated for

488
00:23:49,320 --> 00:23:52,799
different action on the device so Droid

489
00:23:52,799 --> 00:23:56,760
guard provide all the design to run

490
00:23:56,760 --> 00:23:59,940
Google back Google by code on your

491
00:23:59,940 --> 00:24:01,740
device

492
00:24:01,740 --> 00:24:04,799
with different layer of obfuscation

493
00:24:04,799 --> 00:24:08,580
now when one question is how much uh

494
00:24:08,580 --> 00:24:10,620
what is the cost for it of this kind of

495
00:24:10,620 --> 00:24:13,320
reverse engineering so definitely is

496
00:24:13,320 --> 00:24:15,900
very difficult and I took several months

497
00:24:15,900 --> 00:24:18,059
to it so I won't say it's very easy and

498
00:24:18,059 --> 00:24:20,700
it's just a matter of two days no it

499
00:24:20,700 --> 00:24:22,679
takes months and you have to deal with

500
00:24:22,679 --> 00:24:24,419
the update you have to deal with

501
00:24:24,419 --> 00:24:27,120
different layer of application so it's

502
00:24:27,120 --> 00:24:30,620
not very easy and so I had to develop

503
00:24:30,620 --> 00:24:33,960
some tools to do that I also use a

504
00:24:33,960 --> 00:24:37,679
pre-bit tool like like qbdl for

505
00:24:37,679 --> 00:24:43,159
simplifying the the MBR also use msint

506
00:24:43,159 --> 00:24:46,380
that that is very efficient for

507
00:24:46,380 --> 00:24:49,740
simplifying the MDA uh and I also

508
00:24:49,740 --> 00:24:51,840
developed some dedicated tool for

509
00:24:51,840 --> 00:24:54,000
instance to uh do some kind of code

510
00:24:54,000 --> 00:24:56,520
lifting so instead of reverse

511
00:24:56,520 --> 00:24:59,159
engineering a complex function

512
00:24:59,159 --> 00:25:02,039
I just extract the piece of code that I

513
00:25:02,039 --> 00:25:04,320
were interesting and I just run it

514
00:25:04,320 --> 00:25:07,980
outside of dry garden doing so I was not

515
00:25:07,980 --> 00:25:10,799
uh I did not have to reverse every

516
00:25:10,799 --> 00:25:12,720
instruction basically I just have to run

517
00:25:12,720 --> 00:25:15,960
the quite piece of code

518
00:25:15,960 --> 00:25:19,799
so in terms of how many days weeks or

519
00:25:19,799 --> 00:25:22,740
months it takes so I'm I did that on my

520
00:25:22,740 --> 00:25:24,900
spare time during weekend and quite

521
00:25:24,900 --> 00:25:28,020
early in the morning but if I would have

522
00:25:28,020 --> 00:25:31,919
to give a number of weeks I would say

523
00:25:31,919 --> 00:25:34,679
that just to get an overview of the VM

524
00:25:34,679 --> 00:25:37,980
and to be able to to to

525
00:25:37,980 --> 00:25:41,279
to play with the buy card it took me

526
00:25:41,279 --> 00:25:44,279
more or less five weeks and on the top

527
00:25:44,279 --> 00:25:46,500
of that you can add two weeks for

528
00:25:46,500 --> 00:25:49,279
developing your tool set

529
00:25:49,279 --> 00:25:52,760
and then once you have everything ready

530
00:25:52,760 --> 00:25:57,179
in the end uh I managed to reverse a new

531
00:25:57,179 --> 00:26:01,880
version of the VM in a couple of hours

532
00:26:02,960 --> 00:26:04,500
so

533
00:26:04,500 --> 00:26:06,419
safety net is well designed well

534
00:26:06,419 --> 00:26:09,620
protected and it's difficult to reverse

535
00:26:09,620 --> 00:26:13,740
but I manage to bypass the basic

536
00:26:13,740 --> 00:26:17,720
integrative flag without my disk hide

537
00:26:17,720 --> 00:26:20,520
regarding the CTF profile it involves

538
00:26:20,520 --> 00:26:23,340
the bootloader statues and it's out it

539
00:26:23,340 --> 00:26:26,220
was out of scope of my research

540
00:26:26,220 --> 00:26:30,179
but uh now what are the limit of the

541
00:26:30,179 --> 00:26:32,520
design of this net

542
00:26:32,520 --> 00:26:36,720
first off the Droid guard run in a

543
00:26:36,720 --> 00:26:38,880
dedicated process

544
00:26:38,880 --> 00:26:42,080
that is different from the application

545
00:26:42,080 --> 00:26:45,299
that ask for the request

546
00:26:45,299 --> 00:26:48,059
which means that when they are saying

547
00:26:48,059 --> 00:26:51,360
that they are able to detect a happy eye

548
00:26:51,360 --> 00:26:54,840
hooking that's true but that's only true

549
00:26:54,840 --> 00:26:58,200
in the process of droid guard they are

550
00:26:58,200 --> 00:27:01,799
not able to detect for instance if an

551
00:27:01,799 --> 00:27:04,919
attacker is running Freda in the hub

552
00:27:04,919 --> 00:27:08,940
developer so all the check are done in a

553
00:27:08,940 --> 00:27:11,760
dedicated process that is different from

554
00:27:11,760 --> 00:27:15,000
the original process of the of the

555
00:27:15,000 --> 00:27:16,799
application

556
00:27:16,799 --> 00:27:18,480
that's why

557
00:27:18,480 --> 00:27:21,659
when you are enabling enabling the magic

558
00:27:21,659 --> 00:27:25,559
ID you just have to Target Two processed

559
00:27:25,559 --> 00:27:28,140
by passive net the first one is GMS car

560
00:27:28,140 --> 00:27:31,919
and the second one is the one that ends

561
00:27:31,919 --> 00:27:34,200
with unstable and that is actually drag

562
00:27:34,200 --> 00:27:36,600
out and that's these two process that

563
00:27:36,600 --> 00:27:38,700
needs to be targeted because actually

564
00:27:38,700 --> 00:27:41,460
Droid guard does not check the Integrity

565
00:27:41,460 --> 00:27:44,400
of the original process they are doing

566
00:27:44,400 --> 00:27:47,220
all the check within the dedicated

567
00:27:47,220 --> 00:27:50,779
process associated with dwayegar

568
00:27:50,779 --> 00:27:54,120
so just uh there are some kind of Easter

569
00:27:54,120 --> 00:27:56,279
eggs when you are reverse engineering

570
00:27:56,279 --> 00:27:59,820
the the bike card which are associated

571
00:27:59,820 --> 00:28:01,620
with Drury guard hello and you have

572
00:28:01,620 --> 00:28:05,400
fancy message but basically if you are

573
00:28:05,400 --> 00:28:09,240
the ID after the email is unique so it

574
00:28:09,240 --> 00:28:11,940
means that each time you are running the

575
00:28:11,940 --> 00:28:13,500
bytecode there are the different email

576
00:28:13,500 --> 00:28:16,620
address which means that they will be

577
00:28:16,620 --> 00:28:19,679
able to notify your device when you send

578
00:28:19,679 --> 00:28:23,520
an email to this address so that's why I

579
00:28:23,520 --> 00:28:26,580
actually did not send an email to this

580
00:28:26,580 --> 00:28:29,700
other resume even though I I contacted

581
00:28:29,700 --> 00:28:32,400
Google to to share this different

582
00:28:32,400 --> 00:28:34,980
research

583
00:28:34,980 --> 00:28:36,840
last World about the hardware

584
00:28:36,840 --> 00:28:40,320
attestation so actually as I said at the

585
00:28:40,320 --> 00:28:42,900
beginning Google introduced Hardware

586
00:28:42,900 --> 00:28:45,919
decision to to to

587
00:28:45,919 --> 00:28:49,380
improve uh the way of how setting

588
00:28:49,380 --> 00:28:52,380
Network because basically otherwise it

589
00:28:52,380 --> 00:28:54,480
can be more or less easy to bypass and

590
00:28:54,480 --> 00:28:57,419
actually automatic station is nothing uh

591
00:28:57,419 --> 00:29:00,120
so it's not something magic it's just

592
00:29:00,120 --> 00:29:04,200
this kind of code that is running

593
00:29:04,200 --> 00:29:07,260
through the different Handler of the VM

594
00:29:07,260 --> 00:29:10,520
but in the end the important point is

595
00:29:10,520 --> 00:29:14,159
key star get certification which return

596
00:29:14,159 --> 00:29:18,539
a certification that is likely signed by

597
00:29:18,539 --> 00:29:21,659
a trusted component and more precisely

598
00:29:21,659 --> 00:29:24,480
true Zone that contains the status of

599
00:29:24,480 --> 00:29:26,220
the bootloader so the statues of the

600
00:29:26,220 --> 00:29:29,340
book reader is signed on the hardware

601
00:29:29,340 --> 00:29:33,360
part and is actually collected through

602
00:29:33,360 --> 00:29:36,299
get certification that is a part of the

603
00:29:36,299 --> 00:29:38,220
Telemetry data

604
00:29:38,220 --> 00:29:41,039
so thank you for your attention I

605
00:29:41,039 --> 00:29:43,980
uploaded some samples of the VM and the

606
00:29:43,980 --> 00:29:47,940
bytecode on gay Tab and now I would be

607
00:29:47,940 --> 00:29:50,399
very happy to to answer your question if

608
00:29:50,399 --> 00:29:54,199
you have some thank you

609
00:29:54,230 --> 00:29:57,299
[Music]

610
00:30:01,140 --> 00:30:04,229
[Music]

