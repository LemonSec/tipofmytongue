1
00:00:01,740 --> 00:00:04,810
[Music]

2
00:00:09,120 --> 00:00:10,559
hello everyone

3
00:00:10,559 --> 00:00:12,400
welcome to our talk

4
00:00:12,400 --> 00:00:15,200
this is leo wu from battle security

5
00:00:15,200 --> 00:00:17,119
in this talk i will talk about our

6
00:00:17,119 --> 00:00:20,560
research about the android ion driver we

7
00:00:20,560 --> 00:00:23,600
found a series of vulnerabilities in an

8
00:00:23,600 --> 00:00:25,680
android ion driver

9
00:00:25,680 --> 00:00:28,080
and they're just like hayden mines in

10
00:00:28,080 --> 00:00:29,119
ion

11
00:00:29,119 --> 00:00:31,359
and we named the series of vulnerability

12
00:00:31,359 --> 00:00:32,800
explosion

13
00:00:32,800 --> 00:00:36,559
in this talk we will dive into explosion

14
00:00:36,559 --> 00:00:38,719
the research is finished by me and my

15
00:00:38,719 --> 00:00:42,160
colleagues sri li and tim xia

16
00:00:42,160 --> 00:00:45,200
and here are some introductions about us

17
00:00:45,200 --> 00:00:47,680
i am interested in enjoying linux bug

18
00:00:47,680 --> 00:00:49,760
hunting and exploit

19
00:00:49,760 --> 00:00:52,480
i found over 200 vulnerabilities in the

20
00:00:52,480 --> 00:00:55,120
last two years and i am top one in

21
00:00:55,120 --> 00:00:57,280
android chipsets security program and

22
00:00:57,280 --> 00:00:59,199
the media tech mobile

23
00:00:59,199 --> 00:01:02,320
security program she only is interested

24
00:01:02,320 --> 00:01:04,799
in android analytics linux kernel

25
00:01:04,799 --> 00:01:07,680
accounting and he's the author of one

26
00:01:07,680 --> 00:01:10,000
click root master and so on

27
00:01:10,000 --> 00:01:12,320
tim sha is a staff security researcher

28
00:01:12,320 --> 00:01:13,520
at batu

29
00:01:13,520 --> 00:01:16,400
and he is also a previous pacsafe sec

30
00:01:16,400 --> 00:01:19,920
and hitb speaker

31
00:01:20,640 --> 00:01:22,159
let's get start

32
00:01:22,159 --> 00:01:25,200
here is the agenda of our talk first of

33
00:01:25,200 --> 00:01:27,759
all i will introduce ion about what it

34
00:01:27,759 --> 00:01:31,119
is used for and why we research about it

35
00:01:31,119 --> 00:01:34,240
second i will show some basic use of ion

36
00:01:34,240 --> 00:01:37,119
and then i will dive into the explosion

37
00:01:37,119 --> 00:01:39,520
and talk about how we found

38
00:01:39,520 --> 00:01:42,640
those vulnerabilities after that i will

39
00:01:42,640 --> 00:01:45,439
make some reflections on explosion

40
00:01:45,439 --> 00:01:49,119
at last i will discuss the future work

41
00:01:49,119 --> 00:01:53,439
so let's have a look at the what is ion

42
00:01:53,439 --> 00:01:56,159
io is a general generalized memory pro

43
00:01:56,159 --> 00:01:59,200
manager introduced by google to address

44
00:01:59,200 --> 00:02:01,600
the issue of fragmented memory

45
00:02:01,600 --> 00:02:04,320
management interfaces across different

46
00:02:04,320 --> 00:02:06,159
android devices

47
00:02:06,159 --> 00:02:08,800
at the very beginning there are many

48
00:02:08,800 --> 00:02:12,480
drivers enjoyed doing the similar memory

49
00:02:12,480 --> 00:02:14,000
allocation work

50
00:02:14,000 --> 00:02:16,879
for example some some of them are used

51
00:02:16,879 --> 00:02:19,760
to allocate physically physically

52
00:02:19,760 --> 00:02:22,400
contiguous memory buffers where others

53
00:02:22,400 --> 00:02:24,959
are used to allocate non-contiguous

54
00:02:24,959 --> 00:02:26,400
memory buffers

55
00:02:26,400 --> 00:02:27,840
google noticed

56
00:02:27,840 --> 00:02:30,160
this fragmented memory allocation

57
00:02:30,160 --> 00:02:33,440
components and introduced ion

58
00:02:33,440 --> 00:02:36,080
ion centralized all kinds of memory

59
00:02:36,080 --> 00:02:37,760
allocation needs

60
00:02:37,760 --> 00:02:40,160
in ion there are many different memory

61
00:02:40,160 --> 00:02:41,360
pools

62
00:02:41,360 --> 00:02:44,319
each memory pool is called ion heap

63
00:02:44,319 --> 00:02:46,959
and every ion heap can be used to

64
00:02:46,959 --> 00:02:49,200
allocate a specific kind of memory

65
00:02:49,200 --> 00:02:51,920
buffer for example

66
00:02:51,920 --> 00:02:55,120
the ion heap system is used to allocate

67
00:02:55,120 --> 00:02:58,720
memory buffer based on the vim lock and

68
00:02:58,720 --> 00:02:59,599
also

69
00:02:59,599 --> 00:03:02,560
vendors can use ir interfaces to add

70
00:03:02,560 --> 00:03:05,519
their own custom ion heap to allocate

71
00:03:05,519 --> 00:03:06,959
any special

72
00:03:06,959 --> 00:03:10,319
memory buffer they need

73
00:03:11,200 --> 00:03:14,400
except for the functionality of ion

74
00:03:14,400 --> 00:03:16,959
there are some other features of ion

75
00:03:16,959 --> 00:03:19,680
that interest us a lot

76
00:03:19,680 --> 00:03:23,040
first ion is a common android driver so

77
00:03:23,040 --> 00:03:25,200
any vulnerability

78
00:03:25,200 --> 00:03:28,640
in it can affect many android devices

79
00:03:28,640 --> 00:03:31,599
although ion started to be replaced with

80
00:03:31,599 --> 00:03:35,120
dma buff in android 12. millions of

81
00:03:35,120 --> 00:03:37,519
devices still use ion

82
00:03:37,519 --> 00:03:40,239
and will and it and it will survive for

83
00:03:40,239 --> 00:03:42,480
a long time due to the

84
00:03:42,480 --> 00:03:45,280
fragmentation of android

85
00:03:45,280 --> 00:03:46,640
second

86
00:03:46,640 --> 00:03:49,599
the ion device can be accessed by on

87
00:03:49,599 --> 00:03:50,799
trust apps

88
00:03:50,799 --> 00:03:54,159
making it a perfect exploitation target

89
00:03:54,159 --> 00:03:58,480
just like the binder device

90
00:03:59,200 --> 00:04:02,159
third as i mentioned ion is a memory

91
00:04:02,159 --> 00:04:05,280
management component vulnerabilities in

92
00:04:05,280 --> 00:04:08,319
memory memory management components are

93
00:04:08,319 --> 00:04:11,599
proven to be dangerous such as the dirty

94
00:04:11,599 --> 00:04:13,120
call

95
00:04:13,120 --> 00:04:17,040
at last ion went over multiple refactors

96
00:04:17,040 --> 00:04:18,478
from upstream

97
00:04:18,478 --> 00:04:22,000
around 2012 the first version of ion

98
00:04:22,000 --> 00:04:25,199
known as legacy ion was introduced and

99
00:04:25,199 --> 00:04:28,320
in 2017 the first refactor to iron

100
00:04:28,320 --> 00:04:32,639
happened after that in 2019 the second

101
00:04:32,639 --> 00:04:34,960
refactor to iron happened

102
00:04:34,960 --> 00:04:38,800
in 2021 ion started to be replaced with

103
00:04:38,800 --> 00:04:43,840
dma buff hips in android android 12

104
00:04:43,840 --> 00:04:44,880
so we

105
00:04:44,880 --> 00:04:47,600
started to think about why there are

106
00:04:47,600 --> 00:04:50,639
multiple refactors and why ion ends up

107
00:04:50,639 --> 00:04:54,160
with a removal in android kernels

108
00:04:54,160 --> 00:04:56,720
maybe there are some insecurity issues

109
00:04:56,720 --> 00:04:59,040
in it

110
00:04:59,520 --> 00:05:02,000
after a long time of bug hunting we have

111
00:05:02,000 --> 00:05:05,440
found over 40 vulnerabilities in ion

112
00:05:05,440 --> 00:05:07,759
which we named explosion

113
00:05:07,759 --> 00:05:11,840
and millions of devices are affected

114
00:05:13,840 --> 00:05:16,160
before diving into explosion let's have

115
00:05:16,160 --> 00:05:19,039
a look at the use of lexi ion

116
00:05:19,039 --> 00:05:20,880
this can help us understand the

117
00:05:20,880 --> 00:05:24,000
vulnerabilities in explosion later and

118
00:05:24,000 --> 00:05:26,240
because the lexi ion is the first

119
00:05:26,240 --> 00:05:29,440
version of ion it shows us a complete

120
00:05:29,440 --> 00:05:33,840
design and implementation of ion

121
00:05:34,400 --> 00:05:36,960
so let's have a look at the use of ion

122
00:05:36,960 --> 00:05:40,080
first of all we can use ion to allocate

123
00:05:40,080 --> 00:05:42,720
memory buffers from user space

124
00:05:42,720 --> 00:05:44,720
and then

125
00:05:44,720 --> 00:05:47,280
for for for a user process it can open

126
00:05:47,280 --> 00:05:50,320
the ion device and then it will get a

127
00:05:50,320 --> 00:05:54,479
client fd after this we can use the ion

128
00:05:54,479 --> 00:05:57,280
lock command to allocate a memory buffer

129
00:05:57,280 --> 00:06:00,479
with cisco io control

130
00:06:00,479 --> 00:06:02,960
this operation will trigger ion to

131
00:06:02,960 --> 00:06:04,000
create

132
00:06:04,000 --> 00:06:07,360
an ion hand object and ion buffer object

133
00:06:07,360 --> 00:06:10,080
will be associated with this ion hand

134
00:06:10,080 --> 00:06:11,199
object

135
00:06:11,199 --> 00:06:14,639
and this ion buffer object object

136
00:06:14,639 --> 00:06:17,680
represents the memory buffer allocated

137
00:06:17,680 --> 00:06:19,759
for the user process

138
00:06:19,759 --> 00:06:22,960
the io handle id will be copied into the

139
00:06:22,960 --> 00:06:24,319
user process

140
00:06:24,319 --> 00:06:26,400
with this ion handle id

141
00:06:26,400 --> 00:06:28,319
the user process can do further

142
00:06:28,319 --> 00:06:32,560
operations to the memory buffer

143
00:06:32,880 --> 00:06:35,680
also a user process can free the memory

144
00:06:35,680 --> 00:06:38,240
buffer from user space this can be

145
00:06:38,240 --> 00:06:41,759
finished with uh an ionfree command we

146
00:06:41,759 --> 00:06:44,319
only need to pass the ir handle id to

147
00:06:44,319 --> 00:06:47,600
the ion driver and then all these kernel

148
00:06:47,600 --> 00:06:49,120
objects and

149
00:06:49,120 --> 00:06:53,120
the memory buffer will be released

150
00:06:53,280 --> 00:06:55,600
and buffer sharing is a really important

151
00:06:55,600 --> 00:06:58,160
feature of ion we can map a memory

152
00:06:58,160 --> 00:06:59,840
buffer into both

153
00:06:59,840 --> 00:07:02,720
user space and kernel space with ion

154
00:07:02,720 --> 00:07:05,599
to finish that we can use the ion share

155
00:07:05,599 --> 00:07:08,960
command to send a buffer sharing request

156
00:07:08,960 --> 00:07:10,160
to ion

157
00:07:10,160 --> 00:07:13,759
and ion will create a dme buff object to

158
00:07:13,759 --> 00:07:15,680
associate with the

159
00:07:15,680 --> 00:07:16,960
ion buffer

160
00:07:16,960 --> 00:07:18,400
and the

161
00:07:18,400 --> 00:07:20,720
and the fd of this

162
00:07:20,720 --> 00:07:23,680
dm buff object will be exported to the

163
00:07:23,680 --> 00:07:25,520
user space

164
00:07:25,520 --> 00:07:28,080
and then the user process can map the

165
00:07:28,080 --> 00:07:30,800
memory buffer into user space

166
00:07:30,800 --> 00:07:34,240
space by mapping the then buff fd and

167
00:07:34,240 --> 00:07:37,520
also we can use a few apis to map the

168
00:07:37,520 --> 00:07:40,880
memory buffer into kernel space

169
00:07:40,880 --> 00:07:43,440
after these operations kernel space and

170
00:07:43,440 --> 00:07:45,919
user space will share this same memory

171
00:07:45,919 --> 00:07:48,318
buffer

172
00:07:50,240 --> 00:07:52,880
and also the ion driver is a base driver

173
00:07:52,880 --> 00:07:55,840
which can be used by kernel drivers

174
00:07:55,840 --> 00:07:57,919
drivers in kernel space can allocate

175
00:07:57,919 --> 00:08:01,199
memory buffers with api ion lock and

176
00:08:01,199 --> 00:08:03,199
they can also free memory buffers with

177
00:08:03,199 --> 00:08:05,840
api ion-free

178
00:08:05,840 --> 00:08:09,199
there there is also an api ir map kernel

179
00:08:09,199 --> 00:08:12,000
to map a memory buffer into kernel space

180
00:08:12,000 --> 00:08:14,639
we need to note that the virtual address

181
00:08:14,639 --> 00:08:17,599
of the memory buffer will be cached in

182
00:08:17,599 --> 00:08:20,879
the i arm but for object to accelerate

183
00:08:20,879 --> 00:08:22,560
the map operation

184
00:08:22,560 --> 00:08:26,000
and api ion map kernel is used to unmap

185
00:08:26,000 --> 00:08:28,560
the memory buffer from kernel

186
00:08:28,560 --> 00:08:31,280
kernel space

187
00:08:31,599 --> 00:08:34,080
so for now we have know some basic use

188
00:08:34,080 --> 00:08:36,799
of ion and it's time for us to dive into

189
00:08:36,799 --> 00:08:38,559
explosion

190
00:08:38,559 --> 00:08:41,519
when we decided to do bug hunting in the

191
00:08:41,519 --> 00:08:44,800
ion driver the very first question was

192
00:08:44,800 --> 00:08:47,920
where to start and how can we find bugs

193
00:08:47,920 --> 00:08:50,959
in ir more efficiently of course we can

194
00:08:50,959 --> 00:08:53,440
do the job just like the old days

195
00:08:53,440 --> 00:08:54,959
but

196
00:08:54,959 --> 00:08:56,959
what is the most

197
00:08:56,959 --> 00:08:59,760
no what is the best weight for us

198
00:08:59,760 --> 00:09:02,800
after we know more and more about ion

199
00:09:02,800 --> 00:09:05,279
we found that ion is very different from

200
00:09:05,279 --> 00:09:07,680
those regular drivers

201
00:09:07,680 --> 00:09:11,440
there are a few characteristics of it

202
00:09:11,440 --> 00:09:13,839
so we thought that maybe we should do

203
00:09:13,839 --> 00:09:16,279
targeted bug hunting for each

204
00:09:16,279 --> 00:09:18,720
characteristic of ion

205
00:09:18,720 --> 00:09:21,040
because we can use some targeted methods

206
00:09:21,040 --> 00:09:21,760
to

207
00:09:21,760 --> 00:09:24,480
guide our bug counting which could be

208
00:09:24,480 --> 00:09:26,160
more efficient

209
00:09:26,160 --> 00:09:28,480
and the final result proves that our

210
00:09:28,480 --> 00:09:31,680
strategy is correct

211
00:09:33,040 --> 00:09:35,399
so far we have found four

212
00:09:35,399 --> 00:09:38,640
characteristics of ion each one of them

213
00:09:38,640 --> 00:09:39,440
can

214
00:09:39,440 --> 00:09:41,920
can be a perspective for us to do the

215
00:09:41,920 --> 00:09:44,959
target targeted by counting the first

216
00:09:44,959 --> 00:09:48,080
characteristic is that ion is a base

217
00:09:48,080 --> 00:09:50,399
driver used by vendors

218
00:09:50,399 --> 00:09:53,360
the second one is the customization of

219
00:09:53,360 --> 00:09:55,839
ion the third one is vendors

220
00:09:55,839 --> 00:09:59,519
modification modification to ion

221
00:09:59,519 --> 00:10:01,600
and the last one is the buffer sharing

222
00:10:01,600 --> 00:10:03,440
feature of ion

223
00:10:03,440 --> 00:10:04,720
so far

224
00:10:04,720 --> 00:10:07,200
we have found the vulnerabilities buried

225
00:10:07,200 --> 00:10:11,720
in these four characteristics

226
00:10:12,800 --> 00:10:15,360
and all these vulnerabilities formed

227
00:10:15,360 --> 00:10:18,360
explosion

228
00:10:19,279 --> 00:10:21,440
so in the following sections i will

229
00:10:21,440 --> 00:10:24,000
discuss these four characteristics of

230
00:10:24,000 --> 00:10:26,399
ion and talk about how we found

231
00:10:26,399 --> 00:10:29,120
vulnerabilities in each of them some

232
00:10:29,120 --> 00:10:31,440
typical vulnerabilities will be detailed

233
00:10:31,440 --> 00:10:33,839
too

234
00:10:35,760 --> 00:10:38,720
here is the architecture of legacy ion

235
00:10:38,720 --> 00:10:40,079
as you can see

236
00:10:40,079 --> 00:10:43,920
the ion driver is here

237
00:10:44,839 --> 00:10:48,399
and and there are many interfaces for

238
00:10:48,399 --> 00:10:49,839
user space

239
00:10:49,839 --> 00:10:52,079
uh you know and the user's process can

240
00:10:52,079 --> 00:10:55,440
call these interfaces through cisco like

241
00:10:55,440 --> 00:10:58,760
io control

242
00:11:00,000 --> 00:11:03,279
the first characteristic of ion is that

243
00:11:03,279 --> 00:11:05,760
ion is the base driver used by vendor

244
00:11:05,760 --> 00:11:07,040
drivers

245
00:11:07,040 --> 00:11:09,600
there are many ion interfaces

246
00:11:09,600 --> 00:11:12,240
of four kernel space such as ion lock

247
00:11:12,240 --> 00:11:15,920
ion 3 ir map kernel and so on

248
00:11:15,920 --> 00:11:18,160
these interfaces can be used by vendor

249
00:11:18,160 --> 00:11:22,240
drivers to finish their work

250
00:11:23,440 --> 00:11:26,720
the second characteristic of ion is the

251
00:11:26,720 --> 00:11:28,800
customization of ion

252
00:11:28,800 --> 00:11:32,079
ion provides the interface for vendors

253
00:11:32,079 --> 00:11:34,880
to add their own custom io hip

254
00:11:34,880 --> 00:11:37,680
and also ion provides the

255
00:11:37,680 --> 00:11:39,920
interface for vendors to add their

256
00:11:39,920 --> 00:11:42,800
custom ion io control commands to

257
00:11:42,800 --> 00:11:44,800
operate our memory buffers

258
00:11:44,800 --> 00:11:47,200
as a result there will be many

259
00:11:47,200 --> 00:11:52,160
customizations added by vendors to ion

260
00:11:52,320 --> 00:11:55,040
the third the third characteristic of

261
00:11:55,040 --> 00:11:58,399
ion is the vendor's motive modifications

262
00:11:58,399 --> 00:11:59,920
to ion core

263
00:11:59,920 --> 00:12:02,560
ion core is developed and maintained

264
00:12:02,560 --> 00:12:03,760
upstream

265
00:12:03,760 --> 00:12:04,800
usually

266
00:12:04,800 --> 00:12:07,600
vendors just use the interfaces of ion

267
00:12:07,600 --> 00:12:11,120
core to do their work but actually we

268
00:12:11,120 --> 00:12:13,760
found that many vendors would modif

269
00:12:13,760 --> 00:12:17,120
modify ion core for some purpose such as

270
00:12:17,120 --> 00:12:20,079
debug debugging

271
00:12:20,959 --> 00:12:23,440
the last characteristic is the buffer

272
00:12:23,440 --> 00:12:26,320
sharing feature of ion a memory buffer

273
00:12:26,320 --> 00:12:28,560
can be mapped into kernel space and user

274
00:12:28,560 --> 00:12:30,639
space at the same time

275
00:12:30,639 --> 00:12:32,399
this could be a really interesting

276
00:12:32,399 --> 00:12:34,320
feature because several kinds of

277
00:12:34,320 --> 00:12:37,360
vulnerabilities have been found in such

278
00:12:37,360 --> 00:12:39,040
features

279
00:12:39,040 --> 00:12:41,519
after the overview of these four

280
00:12:41,519 --> 00:12:43,279
characteristics

281
00:12:43,279 --> 00:12:45,680
let's get into each of them and i will

282
00:12:45,680 --> 00:12:48,560
disclose some bug counting methods and

283
00:12:48,560 --> 00:12:51,519
some some vulnerabilities related to

284
00:12:51,519 --> 00:12:55,000
each characteristic

285
00:12:55,680 --> 00:12:58,320
first of all we know that ion is a base

286
00:12:58,320 --> 00:13:00,480
driver used by vendor drivers

287
00:13:00,480 --> 00:13:02,720
there are many ion core interfaces

288
00:13:02,720 --> 00:13:04,839
provided for the

289
00:13:04,839 --> 00:13:08,560
kernel and we found that ion core

290
00:13:08,560 --> 00:13:11,519
interfaces are widely used in the

291
00:13:11,519 --> 00:13:14,560
vendor drivers including camera drivers

292
00:13:14,560 --> 00:13:17,120
video drivers and many other vendor

293
00:13:17,120 --> 00:13:18,959
special drivers

294
00:13:18,959 --> 00:13:21,360
when we try to handbox in this

295
00:13:21,360 --> 00:13:22,880
characteristic

296
00:13:22,880 --> 00:13:27,279
there are two aspects to be considered

297
00:13:27,839 --> 00:13:30,399
the first aspect is that there could be

298
00:13:30,399 --> 00:13:32,839
vulnerabilities in iron core

299
00:13:32,839 --> 00:13:34,959
interfaces this this kind of

300
00:13:34,959 --> 00:13:37,040
vulnerability could affect all vendor

301
00:13:37,040 --> 00:13:38,240
drivers

302
00:13:38,240 --> 00:13:41,200
the second aspect is that vendor drivers

303
00:13:41,200 --> 00:13:43,839
might misuse ion core interfaces

304
00:13:43,839 --> 00:13:46,079
resulting in some

305
00:13:46,079 --> 00:13:49,079
vulnerabilities

306
00:13:49,760 --> 00:13:50,639
so

307
00:13:50,639 --> 00:13:53,519
according to these aspects we analyzed

308
00:13:53,519 --> 00:13:56,720
the design and implementation of all ion

309
00:13:56,720 --> 00:13:59,199
core apis for kernel space and their

310
00:13:59,199 --> 00:14:02,000
correct usage for vendor drivers we also

311
00:14:02,000 --> 00:14:04,639
checked the code of many vendor drivers

312
00:14:04,639 --> 00:14:08,800
to say if they use the apis correctly

313
00:14:08,800 --> 00:14:11,199
and we finally found some typical

314
00:14:11,199 --> 00:14:13,040
vulnerabilities there are two

315
00:14:13,040 --> 00:14:17,120
vulnerabilities from ion core which are

316
00:14:17,120 --> 00:14:20,040
cve 2021

317
00:14:20,040 --> 00:14:24,120
0929 and cve 2021

318
00:14:24,120 --> 00:14:26,000
39714

319
00:14:26,000 --> 00:14:27,760
there is a vulnerability caused by

320
00:14:27,760 --> 00:14:31,199
vendor drivers misuse of ion core apis

321
00:14:31,199 --> 00:14:35,479
which is cv 2022-20110

322
00:14:37,440 --> 00:14:41,720
let's have have a look at the cve 2021

323
00:14:41,720 --> 00:14:45,199
0929 and seventy two thousand twenty two

324
00:14:45,199 --> 00:14:48,959
two zero one one zero

325
00:14:49,360 --> 00:14:51,839
uh c two thousand twenty one zero nine

326
00:14:51,839 --> 00:14:54,639
tonight uh will affect ion version one

327
00:14:54,639 --> 00:14:57,199
two and three the root cause of it is

328
00:14:57,199 --> 00:15:01,519
that ion co exposed an api to user space

329
00:15:01,519 --> 00:15:03,519
which it shouldn't be

330
00:15:03,519 --> 00:15:05,680
a use after free issue would be

331
00:15:05,680 --> 00:15:08,399
introduced into vendor drivers

332
00:15:08,399 --> 00:15:11,760
by our ion core in a specific use

333
00:15:11,760 --> 00:15:14,399
scenario

334
00:15:15,760 --> 00:15:18,560
here is an ion use

335
00:15:18,560 --> 00:15:20,959
scenario that can be seen in many vendor

336
00:15:20,959 --> 00:15:22,079
drivers

337
00:15:22,079 --> 00:15:24,959
in the user space it can create a dma

338
00:15:24,959 --> 00:15:28,560
buff fd with ion and this dma buff fd

339
00:15:28,560 --> 00:15:31,120
will be passed to the vendor driver

340
00:15:31,120 --> 00:15:33,600
through the syscalls like i o control

341
00:15:33,600 --> 00:15:36,079
and then the vendor driver will create

342
00:15:36,079 --> 00:15:38,959
an i o handle object by importing the

343
00:15:38,959 --> 00:15:42,160
dma buff fd after that the function io

344
00:15:42,160 --> 00:15:44,639
map kernel will be called to map the

345
00:15:44,639 --> 00:15:46,000
memory buffer

346
00:15:46,000 --> 00:15:49,360
represented by the i o handle into

347
00:15:49,360 --> 00:15:50,639
kernel space

348
00:15:50,639 --> 00:15:52,480
the kernel virtual address will be

349
00:15:52,480 --> 00:15:55,600
returned from function io map kernel

350
00:15:55,600 --> 00:15:58,240
the vendor driver would reference the

351
00:15:58,240 --> 00:16:00,880
kernovator address to do some work like

352
00:16:00,880 --> 00:16:05,279
writing data into the virtual address

353
00:16:05,600 --> 00:16:08,480
this use scenario is simple but

354
00:16:08,480 --> 00:16:10,880
we started looking in when we started

355
00:16:10,880 --> 00:16:13,440
looking to the interfaces provided by

356
00:16:13,440 --> 00:16:16,399
the dme buff fd

357
00:16:16,399 --> 00:16:20,320
we found something interesting

358
00:16:20,560 --> 00:16:23,279
there is a command in the i o control of

359
00:16:23,279 --> 00:16:24,800
dma buff fd

360
00:16:24,800 --> 00:16:27,680
which is a sync command used to do

361
00:16:27,680 --> 00:16:29,519
memory sync operations

362
00:16:29,519 --> 00:16:32,320
but we found that with this command we

363
00:16:32,320 --> 00:16:35,440
can unmap the kernel virtual address

364
00:16:35,440 --> 00:16:38,240
mapped by the function iomap kernel as

365
00:16:38,240 --> 00:16:40,000
you can see here

366
00:16:40,000 --> 00:16:42,560
the virtual address gets unmapped in the

367
00:16:42,560 --> 00:16:45,199
kernel space

368
00:16:45,360 --> 00:16:49,199
as a result i use f3 would happen in a

369
00:16:49,199 --> 00:16:50,959
risk condition like this

370
00:16:50,959 --> 00:16:52,720
you can manage to unmap the kernel

371
00:16:52,720 --> 00:16:54,800
virtual address right before the vendor

372
00:16:54,800 --> 00:16:57,519
driver is going to reference it

373
00:16:57,519 --> 00:16:59,839
this will definitely cause the use of

374
00:16:59,839 --> 00:17:01,680
free

375
00:17:01,680 --> 00:17:04,079
the most interesting point of this

376
00:17:04,079 --> 00:17:06,880
vulnerability is that you cannot trigger

377
00:17:06,880 --> 00:17:09,679
it in ion core it can only be triggered

378
00:17:09,679 --> 00:17:12,880
in the in the specific use scenario of

379
00:17:12,880 --> 00:17:14,559
vendor drivers

380
00:17:14,559 --> 00:17:16,480
this makes it a really typical

381
00:17:16,480 --> 00:17:19,919
vulnerability introduced by ion core but

382
00:17:19,919 --> 00:17:23,360
affects vendor drivers

383
00:17:24,799 --> 00:17:27,720
cve 2021 22

384
00:17:27,720 --> 00:17:30,880
20110 is a vulnerability affecting a

385
00:17:30,880 --> 00:17:35,120
vendor's devices with ion version 1.

386
00:17:35,120 --> 00:17:37,280
the root cause of it is the misuse of

387
00:17:37,280 --> 00:17:40,720
ion core api by a vendor driver a use

388
00:17:40,720 --> 00:17:43,280
after free will happen by triggering the

389
00:17:43,280 --> 00:17:45,600
issue

390
00:17:45,679 --> 00:17:48,160
as we know that iomap kernel is used to

391
00:17:48,160 --> 00:17:51,039
map the memory buffer into kernel space

392
00:17:51,039 --> 00:17:52,640
the kernel over to address will be

393
00:17:52,640 --> 00:17:55,919
cached in the the draw field of the ion

394
00:17:55,919 --> 00:17:57,840
buffer object

395
00:17:57,840 --> 00:18:00,480
there is also a reference count field

396
00:18:00,480 --> 00:18:03,280
k-map count for the v address field

397
00:18:03,280 --> 00:18:06,160
we can see that during the map operation

398
00:18:06,160 --> 00:18:08,960
in this function both v a drawer and

399
00:18:08,960 --> 00:18:12,880
keymap count are protected by two

400
00:18:12,880 --> 00:18:15,520
by two mutex locks

401
00:18:15,520 --> 00:18:18,080
this can prevent issues from happening

402
00:18:18,080 --> 00:18:20,640
in a risk condition

403
00:18:20,640 --> 00:18:23,600
the vita draw of ion buffer is an

404
00:18:23,600 --> 00:18:26,240
internal data of ion so if vendor

405
00:18:26,240 --> 00:18:28,480
drivers want to get the virtual address

406
00:18:28,480 --> 00:18:30,720
of a memory buffer they should call the

407
00:18:30,720 --> 00:18:33,200
function io map kernel instead of

408
00:18:33,200 --> 00:18:35,600
accessing the address field of ion

409
00:18:35,600 --> 00:18:38,720
buffer directly because that would cause

410
00:18:38,720 --> 00:18:43,840
the uef in a risk condition

411
00:18:44,400 --> 00:18:48,080
in a driver of offender a we found that

412
00:18:48,080 --> 00:18:50,559
it's accessing the via draw and keymap

413
00:18:50,559 --> 00:18:52,000
count field of

414
00:18:52,000 --> 00:18:55,120
ion buffer object directly without

415
00:18:55,120 --> 00:18:58,240
taking the mutex locks

416
00:18:58,240 --> 00:19:00,960
this would cause use after three in a

417
00:19:00,960 --> 00:19:04,080
risk condition like this

418
00:19:04,080 --> 00:19:06,720
as you can see in thread a

419
00:19:06,720 --> 00:19:09,600
right after it has gotten the

420
00:19:09,600 --> 00:19:12,559
kernel virtual address from the v a draw

421
00:19:12,559 --> 00:19:15,600
of ion buffer konova trade this kernel

422
00:19:15,600 --> 00:19:18,080
virtual address can be unmapped um

423
00:19:18,080 --> 00:19:20,799
unmapped in thread b with the function

424
00:19:20,799 --> 00:19:23,919
iron map kernel and then one thread a

425
00:19:23,919 --> 00:19:26,400
reference says the kernel thread virtual

426
00:19:26,400 --> 00:19:30,240
address the uaf would happen

427
00:19:30,240 --> 00:19:32,640
this vulnerability is a typical one

428
00:19:32,640 --> 00:19:35,440
caused by vendor drivers misuse of ion

429
00:19:35,440 --> 00:19:38,679
core api

430
00:19:39,679 --> 00:19:42,080
let's have a look at the customization

431
00:19:42,080 --> 00:19:45,440
of ion ion provides several interfaces

432
00:19:45,440 --> 00:19:49,039
for vendors to do customizations so we

433
00:19:49,039 --> 00:19:51,360
were wondering could there be some

434
00:19:51,360 --> 00:19:53,600
security issues in the customization

435
00:19:53,600 --> 00:19:55,840
code

436
00:19:56,960 --> 00:19:59,679
vendors can use the function ion device

437
00:19:59,679 --> 00:20:02,720
add heap to add their custom custom i or

438
00:20:02,720 --> 00:20:06,400
hip every ion heap must implement its

439
00:20:06,400 --> 00:20:09,440
iron hip operations our hip operations

440
00:20:09,440 --> 00:20:12,400
contains the functions used for memory

441
00:20:12,400 --> 00:20:14,080
allocation free

442
00:20:14,080 --> 00:20:15,679
and map map

443
00:20:15,679 --> 00:20:19,200
operations and so on vendors need to

444
00:20:19,200 --> 00:20:21,200
implement these functions for their

445
00:20:21,200 --> 00:20:23,280
custom iohip

446
00:20:23,280 --> 00:20:25,200
and also

447
00:20:25,200 --> 00:20:28,000
vendors can add custom i o control

448
00:20:28,000 --> 00:20:30,720
commands for their

449
00:20:30,720 --> 00:20:34,520
own buffer operations

450
00:20:34,640 --> 00:20:37,120
we found that most vendors would add

451
00:20:37,120 --> 00:20:39,760
their own customer ir hips and most

452
00:20:39,760 --> 00:20:41,919
vendors would add a custom

453
00:20:41,919 --> 00:20:44,320
io control commands such as vendor a and

454
00:20:44,320 --> 00:20:45,440
vendor b

455
00:20:45,440 --> 00:20:47,200
as you can see

456
00:20:47,200 --> 00:20:49,440
these two vendors add their own io

457
00:20:49,440 --> 00:20:53,760
control i o control commands

458
00:20:53,840 --> 00:20:56,960
in android ecosystem the customization

459
00:20:56,960 --> 00:20:59,760
is proven to be more vulnerable

460
00:20:59,760 --> 00:21:01,679
so they might be one of the

461
00:21:01,679 --> 00:21:04,080
vulnerabilities in the customizations of

462
00:21:04,080 --> 00:21:06,559
ion

463
00:21:07,120 --> 00:21:09,360
so after a long time of bug hunting in

464
00:21:09,360 --> 00:21:12,080
the customizations of ion we found

465
00:21:12,080 --> 00:21:14,320
dozens of vulnerabilities

466
00:21:14,320 --> 00:21:17,360
many of them can be used to do privilege

467
00:21:17,360 --> 00:21:18,799
escalation

468
00:21:18,799 --> 00:21:21,520
all the vulnerabilities in this page had

469
00:21:21,520 --> 00:21:25,120
already been fixed by vendors

470
00:21:26,720 --> 00:21:30,000
vendors modification to ion core is an

471
00:21:30,000 --> 00:21:32,880
important characteristic of ion we know

472
00:21:32,880 --> 00:21:35,520
that ion core is a maintained upstream

473
00:21:35,520 --> 00:21:38,559
and vendors should not modify the ion

474
00:21:38,559 --> 00:21:41,600
core but the truth is that some vendors

475
00:21:41,600 --> 00:21:45,840
are doing more modifications to ion core

476
00:21:46,080 --> 00:21:48,960
for example we found that vendor a adds

477
00:21:48,960 --> 00:21:51,440
some commands into the orig original

478
00:21:51,440 --> 00:21:54,320
function io ion control and vendor b

479
00:21:54,320 --> 00:21:57,679
adds some debug code into the original

480
00:21:57,679 --> 00:22:01,039
interface ion unlock

481
00:22:02,480 --> 00:22:04,799
all these modifications might introduce

482
00:22:04,799 --> 00:22:06,000
issues

483
00:22:06,000 --> 00:22:08,480
there are two aspects we need to pay

484
00:22:08,480 --> 00:22:09,679
attention to

485
00:22:09,679 --> 00:22:12,320
the first aspect is that vulnerable

486
00:22:12,320 --> 00:22:15,200
modifications can introduce can

487
00:22:15,200 --> 00:22:17,520
introduce new vulnerabilities into ion

488
00:22:17,520 --> 00:22:18,640
core

489
00:22:18,640 --> 00:22:21,280
the second aspect is that code much

490
00:22:21,280 --> 00:22:24,080
conflict conflicts can happen due to the

491
00:22:24,080 --> 00:22:26,799
modifications the missing patch might

492
00:22:26,799 --> 00:22:29,760
cause the no vulnerabilities not fixed

493
00:22:29,760 --> 00:22:31,919
and the wrong patch might introduce some

494
00:22:31,919 --> 00:22:35,280
new vulnerabilities

495
00:22:37,200 --> 00:22:39,760
according to the assumption we analyzed

496
00:22:39,760 --> 00:22:42,559
the modifications made by many vendors

497
00:22:42,559 --> 00:22:45,919
and also they investigated dozens of no

498
00:22:45,919 --> 00:22:48,480
issues of ion and checked if they are

499
00:22:48,480 --> 00:22:52,880
fixed well in the downstream up vendors

500
00:22:52,880 --> 00:22:55,120
and it turned out that our assumption

501
00:22:55,120 --> 00:22:57,360
was correct and we found a few

502
00:22:57,360 --> 00:22:59,039
vulnerabilities

503
00:22:59,039 --> 00:23:01,440
there is a vulnerability introduced by a

504
00:23:01,440 --> 00:23:03,600
vendor due to the vulnerable

505
00:23:03,600 --> 00:23:05,200
modifications

506
00:23:05,200 --> 00:23:09,159
which is cv 2021 2021.0422

507
00:23:10,000 --> 00:23:12,240
and there are two vulnerabilities due to

508
00:23:12,240 --> 00:23:13,919
the missing patch and two

509
00:23:13,919 --> 00:23:16,559
vulnerabilities due to the one patch

510
00:23:16,559 --> 00:23:20,720
let's have a look at the city 2021

511
00:23:20,720 --> 00:23:23,200
319

512
00:23:23,200 --> 00:23:26,159
to understand how the vulnerabilities

513
00:23:26,159 --> 00:23:28,960
get introduced because of the missing

514
00:23:28,960 --> 00:23:31,280
patch

515
00:23:31,840 --> 00:23:33,120
the vulnerable

516
00:23:33,120 --> 00:23:35,360
this vulnerability affects our vendors

517
00:23:35,360 --> 00:23:38,960
devices with ion version 1. the root

518
00:23:38,960 --> 00:23:41,440
cause of it is that the patch of a no

519
00:23:41,440 --> 00:23:42,880
issue is missing

520
00:23:42,880 --> 00:23:45,120
and this results in a

521
00:23:45,120 --> 00:23:48,320
use after free issue

522
00:23:49,120 --> 00:23:51,600
let's have a look at this known issue it

523
00:23:51,600 --> 00:23:55,200
happens at the ion 3 ion control command

524
00:23:55,200 --> 00:23:57,039
as we already know

525
00:23:57,039 --> 00:23:59,600
with ion 3 command we can manage to

526
00:23:59,600 --> 00:24:02,799
release an ion handle object

527
00:24:02,799 --> 00:24:05,360
but to it

528
00:24:05,760 --> 00:24:08,960
but with this word of ion 3

529
00:24:08,960 --> 00:24:11,520
if we try to call ionfree command in you

530
00:24:11,520 --> 00:24:14,480
the space can continuously we will

531
00:24:14,480 --> 00:24:16,559
release ion handle object to matter how

532
00:24:16,559 --> 00:24:18,880
many time it has been

533
00:24:18,880 --> 00:24:22,080
referenced by others to be more specific

534
00:24:22,080 --> 00:24:24,159
the iron handle object in kernel space

535
00:24:24,159 --> 00:24:26,720
can be released at any time from user

536
00:24:26,720 --> 00:24:29,120
space

537
00:24:31,679 --> 00:24:34,559
as a result a use of free issue would

538
00:24:34,559 --> 00:24:36,799
happen in many places where the ir hand

539
00:24:36,799 --> 00:24:40,080
object gets used for example the the use

540
00:24:40,080 --> 00:24:42,320
after we use after free issue will

541
00:24:42,320 --> 00:24:43,200
happen

542
00:24:43,200 --> 00:24:44,840
in the ion lock

543
00:24:44,840 --> 00:24:47,679
command like you can see

544
00:24:47,679 --> 00:24:49,039
what else

545
00:24:49,039 --> 00:24:50,799
quite a few

546
00:24:50,799 --> 00:24:53,039
uaf would happen in vendors

547
00:24:53,039 --> 00:24:55,919
customizations if the i o handle gets

548
00:24:55,919 --> 00:24:58,720
used there

549
00:24:59,520 --> 00:25:01,760
actually the issue has been assigned

550
00:25:01,760 --> 00:25:04,480
cvid in 2017.

551
00:25:04,480 --> 00:25:06,799
here is the patch for it

552
00:25:06,799 --> 00:25:09,279
but the effect is although five years

553
00:25:09,279 --> 00:25:11,760
have have passed away a patch for this

554
00:25:11,760 --> 00:25:13,760
vulnerability has not been applied in

555
00:25:13,760 --> 00:25:16,480
many android kernel branches

556
00:25:16,480 --> 00:25:18,320
including some android common kernel

557
00:25:18,320 --> 00:25:20,720
branches upstream kernel branches and

558
00:25:20,720 --> 00:25:23,760
also some vendors kernel branches

559
00:25:23,760 --> 00:25:26,320
this this issue is a typical one due to

560
00:25:26,320 --> 00:25:29,840
the missing patch

561
00:25:31,679 --> 00:25:34,880
let's see the last characteristic of ion

562
00:25:34,880 --> 00:25:36,880
which is the buffer sharing feature of

563
00:25:36,880 --> 00:25:39,279
ion

564
00:25:39,919 --> 00:25:41,039
actually

565
00:25:41,039 --> 00:25:43,279
the buffer sharing feature of ion is a

566
00:25:43,279 --> 00:25:46,240
really attractive characteristic that

567
00:25:46,240 --> 00:25:49,200
has been researched by several security

568
00:25:49,200 --> 00:25:50,240
teams

569
00:25:50,240 --> 00:25:53,440
for example there is a paper android ion

570
00:25:53,440 --> 00:25:54,400
hazard

571
00:25:54,400 --> 00:25:56,320
and two kinds of vulnerabilities

572
00:25:56,320 --> 00:25:59,919
introduced by iom buffer sharing are

573
00:25:59,919 --> 00:26:03,279
revealed in this paper

574
00:26:03,360 --> 00:26:06,480
and also in another in another blog

575
00:26:06,480 --> 00:26:08,640
written by the researcher from google

576
00:26:08,640 --> 00:26:11,039
project zero the double fetch

577
00:26:11,039 --> 00:26:13,440
vulnerability introduced by buffer

578
00:26:13,440 --> 00:26:16,159
sharing of ion is revealed

579
00:26:16,159 --> 00:26:18,240
and the double fetch

580
00:26:18,240 --> 00:26:20,240
double fetch is like this

581
00:26:20,240 --> 00:26:22,400
in kernel space the memory buffer will

582
00:26:22,400 --> 00:26:24,799
be fetched fetched twice

583
00:26:24,799 --> 00:26:27,120
the first fetch is for the checking

584
00:26:27,120 --> 00:26:29,679
operation to make sure the data in the

585
00:26:29,679 --> 00:26:31,760
memory buffer is valid

586
00:26:31,760 --> 00:26:34,159
and for the second fetch the data in the

587
00:26:34,159 --> 00:26:36,320
memory buffer will be used

588
00:26:36,320 --> 00:26:38,559
and but because the memory buffer is

589
00:26:38,559 --> 00:26:40,400
shared between user space and kernel

590
00:26:40,400 --> 00:26:41,520
space

591
00:26:41,520 --> 00:26:44,480
the user process can do some malicious

592
00:26:44,480 --> 00:26:46,799
updates to the memory buffer

593
00:26:46,799 --> 00:26:49,039
and this will make the checks in the

594
00:26:49,039 --> 00:26:51,200
first fetch invalid

595
00:26:51,200 --> 00:26:54,480
and issues might happen when kernel

596
00:26:54,480 --> 00:26:59,039
uses the data in the memory buffer

597
00:26:59,279 --> 00:27:01,440
according to the pattern of the double

598
00:27:01,440 --> 00:27:04,640
fetch issue we found three more

599
00:27:04,640 --> 00:27:08,000
but double fetch issues a vendor's apu

600
00:27:08,000 --> 00:27:09,200
driver

601
00:27:09,200 --> 00:27:11,440
and

602
00:27:11,679 --> 00:27:15,760
here is a question we can think about

603
00:27:16,400 --> 00:27:18,720
is i own the only component that has the

604
00:27:18,720 --> 00:27:21,760
buffer sharing feature maybe we can find

605
00:27:21,760 --> 00:27:23,600
find more double fetch issues in the

606
00:27:23,600 --> 00:27:26,320
buffer sharing feature of other

607
00:27:26,320 --> 00:27:27,840
components

608
00:27:27,840 --> 00:27:33,720
such as the dma buff dma buff subsystem

609
00:27:35,760 --> 00:27:37,600
after all these discussions about

610
00:27:37,600 --> 00:27:39,200
characteristics

611
00:27:39,200 --> 00:27:41,760
and the vulnerabilities buried in each

612
00:27:41,760 --> 00:27:44,320
of them it's time for us to see what we

613
00:27:44,320 --> 00:27:46,840
can do with exploit

614
00:27:46,840 --> 00:27:48,480
explosion

615
00:27:48,480 --> 00:27:51,600
we succeeded in getting root of android

616
00:27:51,600 --> 00:27:54,159
devices with one vulnerability in

617
00:27:54,159 --> 00:27:56,399
explosion

618
00:27:56,399 --> 00:28:01,039
and we bypassed the ksrr and disabled

619
00:28:01,039 --> 00:28:02,640
the s linux

620
00:28:02,640 --> 00:28:05,440
this can be finished from any untrusted

621
00:28:05,440 --> 00:28:10,640
app with no additional privilege needed

622
00:28:10,640 --> 00:28:11,919
and actually

623
00:28:11,919 --> 00:28:14,799
there are few other vulnerabilities in

624
00:28:14,799 --> 00:28:17,520
explosion we can also use to finish pre

625
00:28:17,520 --> 00:28:19,840
village escalation

626
00:28:19,840 --> 00:28:21,200
and the

627
00:28:21,200 --> 00:28:26,080
exploit video is here if you want to see

628
00:28:27,279 --> 00:28:29,840
let's make some reflections on explosion

629
00:28:29,840 --> 00:28:32,240
we already knew that ion has went over

630
00:28:32,240 --> 00:28:35,360
quite a few effectors from upstream so

631
00:28:35,360 --> 00:28:37,679
in some way ion keeps

632
00:28:37,679 --> 00:28:40,080
improving in many aspects

633
00:28:40,080 --> 00:28:42,640
and the first version of ion which is

634
00:28:42,640 --> 00:28:45,919
legacy ion has been used since around

635
00:28:45,919 --> 00:28:49,039
2012 and now many android devices are

636
00:28:49,039 --> 00:28:50,960
still using it

637
00:28:50,960 --> 00:28:52,880
there are many bug fixes and

638
00:28:52,880 --> 00:28:56,880
optimizations from time to time

639
00:28:56,880 --> 00:29:01,840
and then in 2017 ion gets refactored

640
00:29:01,840 --> 00:29:04,880
ion clients and handles are removed some

641
00:29:04,880 --> 00:29:07,840
i o control commands are removed too

642
00:29:07,840 --> 00:29:09,919
this makes ion more brief

643
00:29:09,919 --> 00:29:13,600
which brings more security

644
00:29:13,600 --> 00:29:15,679
in 2019

645
00:29:15,679 --> 00:29:18,000
in order to adapt ion to

646
00:29:18,000 --> 00:29:21,120
generic kernel image ion

647
00:29:21,120 --> 00:29:24,840
android common kernel version

648
00:29:24,840 --> 00:29:27,960
5.4 introduced a framework for

649
00:29:27,960 --> 00:29:31,679
modularizing vendor custom io hips while

650
00:29:31,679 --> 00:29:34,399
keeping the ion core built in to be more

651
00:29:34,399 --> 00:29:37,520
specific the ion core becomes a part of

652
00:29:37,520 --> 00:29:41,600
the gki image and vendors cannot do any

653
00:29:41,600 --> 00:29:44,880
modification to ion core anymore

654
00:29:44,880 --> 00:29:47,440
so this will be definitely so this will

655
00:29:47,440 --> 00:29:50,080
definitely get rid of vulnerabilities

656
00:29:50,080 --> 00:29:52,880
caused by the missing patch the wrong

657
00:29:52,880 --> 00:29:55,919
patch or vulnerable modifications from

658
00:29:55,919 --> 00:29:58,320
vendors

659
00:29:59,679 --> 00:30:02,159
after two years ion started to get

660
00:30:02,159 --> 00:30:05,440
replaced with dma buff heaps in some

661
00:30:05,440 --> 00:30:08,559
devices of android 12. according to the

662
00:30:08,559 --> 00:30:11,760
official statements from google dme buff

663
00:30:11,760 --> 00:30:12,960
heaps have

664
00:30:12,960 --> 00:30:16,640
have some advantages in security

665
00:30:16,640 --> 00:30:21,120
abs stability and standardization

666
00:30:21,120 --> 00:30:23,600
however we have noticed that millions of

667
00:30:23,600 --> 00:30:26,159
devices are still using android version

668
00:30:26,159 --> 00:30:29,840
version 11 10 or even older android

669
00:30:29,840 --> 00:30:30,880
versions

670
00:30:30,880 --> 00:30:32,799
lots of work still needs to be done by

671
00:30:32,799 --> 00:30:37,840
vendors to make sure ion is not attacked

672
00:30:40,159 --> 00:30:43,440
so here are some suggestions for vendors

673
00:30:43,440 --> 00:30:44,320
first

674
00:30:44,320 --> 00:30:46,640
vendors should apply the ref

675
00:30:46,640 --> 00:30:49,600
apply the refactors as soon as possible

676
00:30:49,600 --> 00:30:52,640
we make this suggestion for a reason as

677
00:30:52,640 --> 00:30:55,039
mentioned io has been refactored

678
00:30:55,039 --> 00:30:59,360
upstream since in its kernel of 4.12

679
00:30:59,360 --> 00:31:02,399
which makes ir more brief but we noticed

680
00:31:02,399 --> 00:31:04,880
that some vendors didn't apply this

681
00:31:04,880 --> 00:31:07,640
refactor even in their

682
00:31:07,640 --> 00:31:09,760
4.14 kernels

683
00:31:09,760 --> 00:31:12,000
this can be dangerous because the older

684
00:31:12,000 --> 00:31:14,480
version may not be maintained well by

685
00:31:14,480 --> 00:31:17,440
the upstream community

686
00:31:17,440 --> 00:31:18,640
second

687
00:31:18,640 --> 00:31:20,640
vendors should apply the patch quickly

688
00:31:20,640 --> 00:31:23,120
and carefully sometimes patching

689
00:31:23,120 --> 00:31:26,159
vulnerability is not that simple

690
00:31:26,159 --> 00:31:28,480
especially when some code has been

691
00:31:28,480 --> 00:31:31,200
modified modified by vendors

692
00:31:31,200 --> 00:31:33,760
code merging conflicts can happen

693
00:31:33,760 --> 00:31:36,320
third vendors might must understand the

694
00:31:36,320 --> 00:31:38,080
ion apis well

695
00:31:38,080 --> 00:31:41,120
this can help vendors get rid of some

696
00:31:41,120 --> 00:31:43,519
api use issues

697
00:31:43,519 --> 00:31:46,000
at last vendors should be careful when

698
00:31:46,000 --> 00:31:48,720
they do customizations to ion

699
00:31:48,720 --> 00:31:51,600
because the customization is always

700
00:31:51,600 --> 00:31:55,360
attractive for bug hunters

701
00:31:57,120 --> 00:31:59,519
it's time for us to discuss the future

702
00:31:59,519 --> 00:32:00,480
work

703
00:32:00,480 --> 00:32:03,519
we know that ion has been replaced with

704
00:32:03,519 --> 00:32:06,559
dma buff hips in some devices and of

705
00:32:06,559 --> 00:32:10,720
android 12. so are the dmv dma buff hips

706
00:32:10,720 --> 00:32:12,480
secure

707
00:32:12,480 --> 00:32:15,679
we found that dme buff is uh is very

708
00:32:15,679 --> 00:32:17,519
similar to ion

709
00:32:17,519 --> 00:32:18,880
first of all

710
00:32:18,880 --> 00:32:22,399
dma buff component is also a base driver

711
00:32:22,399 --> 00:32:24,399
used by kernel drivers

712
00:32:24,399 --> 00:32:26,640
uh this is just like ion

713
00:32:26,640 --> 00:32:29,519
they are also customization

714
00:32:29,519 --> 00:32:31,760
interfaces in dma buff

715
00:32:31,760 --> 00:32:34,880
vendors can use this interface to do

716
00:32:34,880 --> 00:32:36,159
their

717
00:32:36,159 --> 00:32:38,399
custom customizations

718
00:32:38,399 --> 00:32:41,120
and buffer sharing is also a feature of

719
00:32:41,120 --> 00:32:45,200
dma buff our next so our next step is to

720
00:32:45,200 --> 00:32:48,320
to use the bug hunting methods we used

721
00:32:48,320 --> 00:32:52,159
in ion to do some more research on the

722
00:32:52,159 --> 00:32:54,960
dma buff component to say

723
00:32:54,960 --> 00:32:58,880
if there are issues in it

724
00:32:59,679 --> 00:33:00,799
well uh

725
00:33:00,799 --> 00:33:04,159
thanks to cheng foo ball mo infant

726
00:33:04,159 --> 00:33:05,519
chu fang young

727
00:33:05,519 --> 00:33:09,200
lin wu and haiko for helping me with my

728
00:33:09,200 --> 00:33:12,720
slides and they just make made great

729
00:33:12,720 --> 00:33:15,360
suggestions

730
00:33:16,240 --> 00:33:18,720
and by the way because of the limited

731
00:33:18,720 --> 00:33:22,320
time i have put the details of other ion

732
00:33:22,320 --> 00:33:24,399
vulnerabilities we have found

733
00:33:24,399 --> 00:33:27,519
in the supplement part supplement

734
00:33:27,519 --> 00:33:30,720
supplement part of the slides you can

735
00:33:30,720 --> 00:33:34,559
read them if you are interested

736
00:33:35,600 --> 00:33:37,519
and

737
00:33:37,519 --> 00:33:39,120
now i will take

738
00:33:39,120 --> 00:33:43,158
questions from the audience

739
00:33:43,420 --> 00:33:46,489
[Music]

740
00:33:50,340 --> 00:33:53,419
[Music]

