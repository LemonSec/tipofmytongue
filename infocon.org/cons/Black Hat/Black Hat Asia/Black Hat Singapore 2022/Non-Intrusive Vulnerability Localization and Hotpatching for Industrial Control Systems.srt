1
00:00:01,740 --> 00:00:04,810
[Music]

2
00:00:08,320 --> 00:00:12,000
hello hi welcome um

3
00:00:12,000 --> 00:00:13,920
sorry it's probably got it was the worst

4
00:00:13,920 --> 00:00:16,000
time for my internet to get stuck uh

5
00:00:16,000 --> 00:00:17,520
it's a very good start this presentation

6
00:00:17,520 --> 00:00:20,800
welcome everyone to our talk um my name

7
00:00:20,800 --> 00:00:22,720
is michals magnetakos

8
00:00:22,720 --> 00:00:24,400
i'm associate professor with new york

9
00:00:24,400 --> 00:00:27,519
university in abu dhabi i do work in

10
00:00:27,519 --> 00:00:29,199
industrial social security as you see

11
00:00:29,199 --> 00:00:31,920
from this talk and joining me is uh

12
00:00:31,920 --> 00:00:33,600
santa rasput

13
00:00:33,600 --> 00:00:35,840
uh who's a currently phd candidate with

14
00:00:35,840 --> 00:00:38,480
nyu uh working actually the masters of

15
00:00:38,480 --> 00:00:40,719
this project and i'm just here doing

16
00:00:40,719 --> 00:00:42,800
introduction taking credit but uh

17
00:00:42,800 --> 00:00:44,960
prasant is the main

18
00:00:44,960 --> 00:00:47,440
person who has done all this work

19
00:00:47,440 --> 00:00:51,039
so uh coming back to the the talk today

20
00:00:51,039 --> 00:00:53,920
the title is non-intrusive localization

21
00:00:53,920 --> 00:00:56,559
and hot passing in the control systems

22
00:00:56,559 --> 00:00:58,559
so the first thing we need to do is to

23
00:00:58,559 --> 00:01:00,320
to properly define what is interesting

24
00:01:00,320 --> 00:01:02,480
control system and i do assume that many

25
00:01:02,480 --> 00:01:04,159
of you already know what it is so i'll

26
00:01:04,159 --> 00:01:06,720
be very brief in discussing that so the

27
00:01:06,720 --> 00:01:09,360
name says industrial control systems are

28
00:01:09,360 --> 00:01:11,119
systems that typically control

29
00:01:11,119 --> 00:01:13,040
industrial processes so you can think of

30
00:01:13,040 --> 00:01:15,280
them as computers regular computers that

31
00:01:15,280 --> 00:01:17,920
are pretty that are hard and not as

32
00:01:17,920 --> 00:01:20,080
regular as what we have in front of us

33
00:01:20,080 --> 00:01:22,960
um and they're employed in in conditions

34
00:01:22,960 --> 00:01:25,520
with harsh environments right uh like

35
00:01:25,520 --> 00:01:27,200
increased temperatures electromagnetic

36
00:01:27,200 --> 00:01:28,479
interference

37
00:01:28,479 --> 00:01:29,759
uh so

38
00:01:29,759 --> 00:01:31,280
you may have heard the 10 plc

39
00:01:31,280 --> 00:01:33,360
programming velocity controller we see a

40
00:01:33,360 --> 00:01:35,920
few of this today scada and so on and so

41
00:01:35,920 --> 00:01:38,880
forth so these systems appear

42
00:01:38,880 --> 00:01:41,200
a lot in critical infrastructure you may

43
00:01:41,200 --> 00:01:43,600
have heard the term smart grid

44
00:01:43,600 --> 00:01:46,000
that's the smart part implies that we

45
00:01:46,000 --> 00:01:48,000
have those small computers

46
00:01:48,000 --> 00:01:51,360
that can be used in order to

47
00:01:51,360 --> 00:01:54,079
improve performance improve automation

48
00:01:54,079 --> 00:01:56,079
um

49
00:01:56,079 --> 00:01:57,439
many many things that you can do with

50
00:01:57,439 --> 00:02:00,079
that right so what in the past was uh

51
00:02:00,079 --> 00:02:02,640
pulitz electromechanical now we have

52
00:02:02,640 --> 00:02:06,000
smart devices uh doing that

53
00:02:06,000 --> 00:02:08,560
so uh in terms of

54
00:02:08,560 --> 00:02:11,599
smartness what i'm trying to say is that

55
00:02:11,599 --> 00:02:14,560
we have more and more digitization we

56
00:02:14,560 --> 00:02:18,160
have what we have seen as industry 4.0

57
00:02:18,160 --> 00:02:21,200
uh integrating automation and data many

58
00:02:21,200 --> 00:02:23,120
of the decision or the control systems

59
00:02:23,120 --> 00:02:26,480
are being taken by the system themselves

60
00:02:26,480 --> 00:02:29,440
and the human is the human factor uh has

61
00:02:29,440 --> 00:02:30,959
limited input in the process so it's

62
00:02:30,959 --> 00:02:32,560
much more automated

63
00:02:32,560 --> 00:02:35,760
but this smartness comes from having

64
00:02:35,760 --> 00:02:39,280
smart computers and smart computers or

65
00:02:39,280 --> 00:02:41,120
computers right imply

66
00:02:41,120 --> 00:02:42,400
something like a regular operating

67
00:02:42,400 --> 00:02:44,560
system for example so nowadays we see a

68
00:02:44,560 --> 00:02:48,160
lot of modern ics with regular general

69
00:02:48,160 --> 00:02:50,239
purpose operating systems so when you

70
00:02:50,239 --> 00:02:52,400
have an operating system uh that's

71
00:02:52,400 --> 00:02:53,760
regular like linux right with a

72
00:02:53,760 --> 00:02:55,360
real-time patch

73
00:02:55,360 --> 00:02:57,680
then you have um

74
00:02:57,680 --> 00:03:00,640
functionality that is amazing for a user

75
00:03:00,640 --> 00:03:03,040
such as ftp as a state access and so on

76
00:03:03,040 --> 00:03:05,440
and so forth but at the same time

77
00:03:05,440 --> 00:03:07,440
anything that is a problem in the ap

78
00:03:07,440 --> 00:03:10,400
world like out of bounds in the rights

79
00:03:10,400 --> 00:03:12,000
um

80
00:03:12,000 --> 00:03:14,560
buffer overflows now can be used in the

81
00:03:14,560 --> 00:03:16,400
in the ot world in the person technology

82
00:03:16,400 --> 00:03:19,280
world or ics so and this is why we're

83
00:03:19,280 --> 00:03:21,120
here right that's why we're trying to to

84
00:03:21,120 --> 00:03:22,239
see and do

85
00:03:22,239 --> 00:03:24,640
uh trying to protect the

86
00:03:24,640 --> 00:03:28,000
plcs the systems against um

87
00:03:28,000 --> 00:03:29,440
regular attacks

88
00:03:29,440 --> 00:03:31,519
and the problem is is exaggerated

89
00:03:31,519 --> 00:03:33,519
because those systems are not typically

90
00:03:33,519 --> 00:03:35,680
updated right we don't really upgrade

91
00:03:35,680 --> 00:03:37,840
the firmware it's hard to have a proper

92
00:03:37,840 --> 00:03:41,040
patching mechanism uh so many of these

93
00:03:41,040 --> 00:03:44,159
devices have outdated firmware so any id

94
00:03:44,159 --> 00:03:47,040
threat from the past like even block for

95
00:03:47,040 --> 00:03:49,680
day that we saw the availability right i

96
00:03:49,680 --> 00:03:51,599
mean they will take years for many of

97
00:03:51,599 --> 00:03:53,599
these devices to get past

98
00:03:53,599 --> 00:03:56,000
uh so many of them can be exploited but

99
00:03:56,000 --> 00:03:57,519
of course what saves the systems

100
00:03:57,519 --> 00:04:00,319
currently is the fact that there's

101
00:04:00,319 --> 00:04:02,480
limited access to that but once you're

102
00:04:02,480 --> 00:04:05,519
in the it side you try to jump to the ot

103
00:04:05,519 --> 00:04:08,159
and then you have you can get access to

104
00:04:08,159 --> 00:04:10,000
that at the same time we don't design ss

105
00:04:10,000 --> 00:04:12,000
for security so vulnerabilities can

106
00:04:12,000 --> 00:04:14,799
affect the runtime and we cannot just

107
00:04:14,799 --> 00:04:17,040
install an antivirus to that right uh

108
00:04:17,040 --> 00:04:18,560
the device have limited computational

109
00:04:18,560 --> 00:04:21,358
power so we're trying to see

110
00:04:21,358 --> 00:04:23,199
better ways to defense and defend

111
00:04:23,199 --> 00:04:24,880
against our stretch

112
00:04:24,880 --> 00:04:25,600
so

113
00:04:25,600 --> 00:04:27,440
what we're trying to do here is that you

114
00:04:27,440 --> 00:04:29,919
know we say we cannot patch right well

115
00:04:29,919 --> 00:04:31,040
um

116
00:04:31,040 --> 00:04:32,639
there are reasons you cannot pass but

117
00:04:32,639 --> 00:04:35,199
you cannot just avoid uh not i mean

118
00:04:35,199 --> 00:04:37,120
avoid passing so what you're trying to

119
00:04:37,120 --> 00:04:40,080
say here is yes you just have pets

120
00:04:40,080 --> 00:04:42,960
and passing may mean restarting that's

121
00:04:42,960 --> 00:04:44,560
something we don't like either so in

122
00:04:44,560 --> 00:04:47,120
this talk we focus on hot patching so

123
00:04:47,120 --> 00:04:48,800
how do you actually fix vulnerabilities

124
00:04:48,800 --> 00:04:51,680
without restarting uh and prasan will

125
00:04:51,680 --> 00:04:53,600
give you a few more details about that

126
00:04:53,600 --> 00:04:55,600
but let me also briefly

127
00:04:55,600 --> 00:04:58,479
before we dive into the details of

128
00:04:58,479 --> 00:04:59,520
um

129
00:04:59,520 --> 00:05:00,960
of hot patching that we'll do in this

130
00:05:00,960 --> 00:05:03,120
talk a little bit information about the

131
00:05:03,120 --> 00:05:04,880
runtime itself and what we'll be

132
00:05:04,880 --> 00:05:07,680
focusing on so we'll talk about plcs

133
00:05:07,680 --> 00:05:09,360
modern plc is typically regular

134
00:05:09,360 --> 00:05:11,360
computers with a runtime on top like a

135
00:05:11,360 --> 00:05:13,039
virtual machine you can think of it as a

136
00:05:13,039 --> 00:05:14,320
virtual machine

137
00:05:14,320 --> 00:05:17,280
that it's like a process that reads

138
00:05:17,280 --> 00:05:19,360
from the sensor computes does some

139
00:05:19,360 --> 00:05:22,560
actuation and then does the scan cycle

140
00:05:22,560 --> 00:05:25,039
again and again in this scan cycle you

141
00:05:25,039 --> 00:05:27,120
can think of it again as another process

142
00:05:27,120 --> 00:05:29,280
in the operating system in this iec

143
00:05:29,280 --> 00:05:30,479
application

144
00:05:30,479 --> 00:05:33,039
uh and this application shares the

145
00:05:33,039 --> 00:05:35,360
process memory with a runtime so on the

146
00:05:35,360 --> 00:05:37,280
right side you see

147
00:05:37,280 --> 00:05:39,600
our hardware layer cpu and then the

148
00:05:39,600 --> 00:05:40,639
linux operating system with the

149
00:05:40,639 --> 00:05:42,639
real-time patch and then the contest

150
00:05:42,639 --> 00:05:44,800
runtime but you know enough with the

151
00:05:44,800 --> 00:05:46,479
boring stuff i think this is now time

152
00:05:46,479 --> 00:05:48,479
for prasant to take over and show you a

153
00:05:48,479 --> 00:05:50,880
demo of what we're trying to say here

154
00:05:50,880 --> 00:05:52,720
prasan the floor is yours

155
00:05:52,720 --> 00:05:54,720
thanks mahalis so before we go into the

156
00:05:54,720 --> 00:05:56,479
details of the batching let us try to

157
00:05:56,479 --> 00:05:59,840
motivate the problem with uh an example

158
00:05:59,840 --> 00:06:01,680
so we have

159
00:06:01,680 --> 00:06:03,520
an experiment set up here where we have

160
00:06:03,520 --> 00:06:06,720
a msf designation plant model working in

161
00:06:06,720 --> 00:06:09,039
simulink which is regularly sending

162
00:06:09,039 --> 00:06:12,000
inputs sensor inputs to the plc which in

163
00:06:12,000 --> 00:06:14,800
our case is fargo pfc100 so as you can

164
00:06:14,800 --> 00:06:16,560
see here the inputs and outputs are

165
00:06:16,560 --> 00:06:19,199
being updated regularly

166
00:06:19,199 --> 00:06:22,319
so for simulating an attack we uh

167
00:06:22,319 --> 00:06:24,240
we create a function here which we can

168
00:06:24,240 --> 00:06:26,000
enable with a single bit

169
00:06:26,000 --> 00:06:28,800
uh now upon enabling it at the hundredth

170
00:06:28,800 --> 00:06:31,280
operation cycle the attack will actually

171
00:06:31,280 --> 00:06:33,919
send a signal which in this case is just

172
00:06:33,919 --> 00:06:36,960
the temporary size to the plc and the

173
00:06:36,960 --> 00:06:40,160
plc will then execute a specific if loop

174
00:06:40,160 --> 00:06:41,919
let us not focus on the attack but look

175
00:06:41,919 --> 00:06:43,440
at the impact of the attack because

176
00:06:43,440 --> 00:06:44,639
that's the main point that we want to

177
00:06:44,639 --> 00:06:46,400
make here so

178
00:06:46,400 --> 00:06:48,319
the iec application or the control

179
00:06:48,319 --> 00:06:50,880
application will write a non-zero value

180
00:06:50,880 --> 00:06:53,199
at a specific offset on the stack in our

181
00:06:53,199 --> 00:06:54,960
case it's four six four nine so let's

182
00:06:54,960 --> 00:06:55,919
see what

183
00:06:55,919 --> 00:06:58,960
exactly happens when when when that

184
00:06:58,960 --> 00:07:00,880
that occurs

185
00:07:00,880 --> 00:07:02,880
so when we fast forward

186
00:07:02,880 --> 00:07:05,840
we see that as soon as the attack hits

187
00:07:05,840 --> 00:07:08,000
the

188
00:07:08,000 --> 00:07:11,039
okay as soon as the attack hits the ic

189
00:07:11,039 --> 00:07:13,599
application stops updating the input and

190
00:07:13,599 --> 00:07:14,720
output

191
00:07:14,720 --> 00:07:18,160
so why does this exactly happen

192
00:07:18,160 --> 00:07:21,680
so uh we uh did an attack where we

193
00:07:21,680 --> 00:07:23,520
overwrote some important information on

194
00:07:23,520 --> 00:07:25,840
the correspondent time stack how did we

195
00:07:25,840 --> 00:07:27,840
do that we use pointers in structure

196
00:07:27,840 --> 00:07:31,120
text the static checks on the propriety

197
00:07:31,120 --> 00:07:33,280
compiler are not the best so you can

198
00:07:33,280 --> 00:07:34,880
easily do stuff like that in structure

199
00:07:34,880 --> 00:07:36,720
text and the impact is that we

200
00:07:36,720 --> 00:07:38,720
completely skipped the execution of the

201
00:07:38,720 --> 00:07:40,639
control application and that's why the

202
00:07:40,639 --> 00:07:42,160
inputs and outputs were not being

203
00:07:42,160 --> 00:07:44,560
updated so why does this happen

204
00:07:44,560 --> 00:07:47,440
this is the disassembly of

205
00:07:47,440 --> 00:07:49,520
assembly of a function that is executed

206
00:07:49,520 --> 00:07:52,639
before plc prg you can imagine plc prg

207
00:07:52,639 --> 00:07:54,240
to be a function just similar to the

208
00:07:54,240 --> 00:07:56,479
main function in c so it's executed

209
00:07:56,479 --> 00:07:58,720
first this function is executed before

210
00:07:58,720 --> 00:08:00,800
that so it is somewhere between the

211
00:08:00,800 --> 00:08:02,080
runtime and

212
00:08:02,080 --> 00:08:04,479
the control application so you can see

213
00:08:04,479 --> 00:08:06,639
the stack pointer is passed to r10

214
00:08:06,639 --> 00:08:09,039
register you get some address from the

215
00:08:09,039 --> 00:08:11,680
stack store it in r6 then you get some

216
00:08:11,680 --> 00:08:13,039
value from

217
00:08:13,039 --> 00:08:16,319
the r6 registers with an offset and you

218
00:08:16,319 --> 00:08:19,440
store it in r4 and compare it with zero

219
00:08:19,440 --> 00:08:22,000
so if this value is indeed zero then the

220
00:08:22,000 --> 00:08:25,599
execution will go to plc prg however if

221
00:08:25,599 --> 00:08:27,680
it is not zero

222
00:08:27,680 --> 00:08:30,080
then it branches to another location and

223
00:08:30,080 --> 00:08:31,840
it just returns

224
00:08:31,840 --> 00:08:34,719
so why is this attack possible because

225
00:08:34,719 --> 00:08:37,039
the currency run time passes the control

226
00:08:37,039 --> 00:08:39,200
to the control application or the ic

227
00:08:39,200 --> 00:08:40,799
application in this case

228
00:08:40,799 --> 00:08:42,719
so any vulnerability in the ic

229
00:08:42,719 --> 00:08:44,880
application can be utilized to

230
00:08:44,880 --> 00:08:46,640
manipulate the stack of code assist

231
00:08:46,640 --> 00:08:48,480
control and

232
00:08:48,480 --> 00:08:50,320
any vulnerability in the ic application

233
00:08:50,320 --> 00:08:52,480
can then have an impact on the runtime

234
00:08:52,480 --> 00:08:54,480
itself and that is exactly what we did

235
00:08:54,480 --> 00:08:56,240
so there is a need to batch the

236
00:08:56,240 --> 00:08:58,160
vulnerabilities in the ic application

237
00:08:58,160 --> 00:08:59,760
itself which hasn't been done in

238
00:08:59,760 --> 00:09:01,440
literature because most of the work has

239
00:09:01,440 --> 00:09:03,120
been focused on hot patching the runtime

240
00:09:03,120 --> 00:09:04,320
itself

241
00:09:04,320 --> 00:09:06,880
so for hot patching we assume that there

242
00:09:06,880 --> 00:09:09,600
is a test plc which has the same uh

243
00:09:09,600 --> 00:09:11,519
variant of code as runtime running on it

244
00:09:11,519 --> 00:09:12,800
with the same

245
00:09:12,800 --> 00:09:15,519
iec project with an exploit input loaded

246
00:09:15,519 --> 00:09:18,560
to it then we extract application state

247
00:09:18,560 --> 00:09:20,880
from it to a path server application

248
00:09:20,880 --> 00:09:23,040
state in our case consists of hex terms

249
00:09:23,040 --> 00:09:26,080
of courses runtime ise application

250
00:09:26,080 --> 00:09:28,720
shared libraries such as libsy libm and

251
00:09:28,720 --> 00:09:30,240
certain register estimates most

252
00:09:30,240 --> 00:09:31,440
important

253
00:09:31,440 --> 00:09:33,040
are the program counter and stack

254
00:09:33,040 --> 00:09:34,320
pointer

255
00:09:34,320 --> 00:09:35,920
then we reused everything in anger

256
00:09:35,920 --> 00:09:38,800
execute it try to locate vulnerabilities

257
00:09:38,800 --> 00:09:41,120
then we calculate offsets in anger get

258
00:09:41,120 --> 00:09:43,120
the live base address from deployed plc

259
00:09:43,120 --> 00:09:44,560
generate a patch

260
00:09:44,560 --> 00:09:46,560
this patch is then sent to local path

261
00:09:46,560 --> 00:09:48,800
server which communicates with the lcm

262
00:09:48,800 --> 00:09:51,120
patcher which is the part that actually

263
00:09:51,120 --> 00:09:53,680
does patching of uh the iec application

264
00:09:53,680 --> 00:09:56,640
running in the codesys runtime

265
00:09:56,640 --> 00:09:58,160
so the two import there are two

266
00:09:58,160 --> 00:09:59,680
important questions that we need to ask

267
00:09:59,680 --> 00:10:01,839
for hot patching the first one is where

268
00:10:01,839 --> 00:10:04,959
exactly do we need to patch so most of

269
00:10:04,959 --> 00:10:07,120
the vulnerabilities in iec applications

270
00:10:07,120 --> 00:10:09,200
manifest themselves in the imported

271
00:10:09,200 --> 00:10:10,959
shared functions

272
00:10:10,959 --> 00:10:13,440
so patching at that specific location

273
00:10:13,440 --> 00:10:15,200
means that we are essentially patching

274
00:10:15,200 --> 00:10:17,839
the runtime however those functions

275
00:10:17,839 --> 00:10:20,079
might also be used uh somewhere else in

276
00:10:20,079 --> 00:10:23,040
uh in the program so there is no way to

277
00:10:23,040 --> 00:10:25,680
guarantee correctness so that is why uh

278
00:10:25,680 --> 00:10:28,720
what we want to do is patch closest uh

279
00:10:28,720 --> 00:10:30,800
to the ic application itself somewhere

280
00:10:30,800 --> 00:10:32,560
in the boundary between

281
00:10:32,560 --> 00:10:35,040
the ic application and the

282
00:10:35,040 --> 00:10:36,480
the runtime part

283
00:10:36,480 --> 00:10:37,440
so

284
00:10:37,440 --> 00:10:39,360
for that for localizing the

285
00:10:39,360 --> 00:10:41,440
vulnerability we create a data

286
00:10:41,440 --> 00:10:43,040
dependence graph

287
00:10:43,040 --> 00:10:45,440
when we execute it in angle so as the

288
00:10:45,440 --> 00:10:47,040
execution happens we create certain

289
00:10:47,040 --> 00:10:49,839
nodes for instance instruction nodes for

290
00:10:49,839 --> 00:10:52,000
instructions which can be stored which

291
00:10:52,000 --> 00:10:53,680
writes to certain memory location

292
00:10:53,680 --> 00:10:56,240
represented by memory nodes these memory

293
00:10:56,240 --> 00:10:58,160
nodes might be read by other instruction

294
00:10:58,160 --> 00:11:00,160
load instructions again represented by

295
00:11:00,160 --> 00:11:02,079
instruction nodes so this is a very

296
00:11:02,079 --> 00:11:04,240
common structure in codices because

297
00:11:04,240 --> 00:11:06,640
functions and choruses pass parameters

298
00:11:06,640 --> 00:11:08,800
to each other using memory locations

299
00:11:08,800 --> 00:11:11,120
the loaded memory locations in registers

300
00:11:11,120 --> 00:11:12,800
might be manipulated which are

301
00:11:12,800 --> 00:11:15,279
represented by transition nodes and once

302
00:11:15,279 --> 00:11:19,040
we locate the vulnerability in uh

303
00:11:19,040 --> 00:11:21,360
during execution in anger then we can

304
00:11:21,360 --> 00:11:23,519
traverse back on this graph and figure

305
00:11:23,519 --> 00:11:25,519
out exactly where we need to patch and

306
00:11:25,519 --> 00:11:26,720
in this case

307
00:11:26,720 --> 00:11:28,560
it is this memory location

308
00:11:28,560 --> 00:11:30,160
which is at the boundary of the ise

309
00:11:30,160 --> 00:11:32,640
application and the runtime library

310
00:11:32,640 --> 00:11:34,079
the second important question that we

311
00:11:34,079 --> 00:11:36,959
need to ask is how we patch it because

312
00:11:36,959 --> 00:11:38,880
we have to insert our path somewhere and

313
00:11:38,880 --> 00:11:40,880
change the execution flow but before

314
00:11:40,880 --> 00:11:43,040
talking about that let us look at how

315
00:11:43,040 --> 00:11:45,519
a normal branching happens in in case of

316
00:11:45,519 --> 00:11:47,680
these iec applications for

317
00:11:47,680 --> 00:11:49,760
currencies control working on vargo pfc

318
00:11:49,760 --> 00:11:50,800
100

319
00:11:50,800 --> 00:11:53,360
so after every function there is a base

320
00:11:53,360 --> 00:11:56,320
address to the jump table or more aptly

321
00:11:56,320 --> 00:11:58,240
the address table

322
00:11:58,240 --> 00:12:00,399
then it loads the address of the

323
00:12:00,399 --> 00:12:02,160
function where it needs to

324
00:12:02,160 --> 00:12:04,320
where it needs to jump to from that

325
00:12:04,320 --> 00:12:06,639
address table using this second load

326
00:12:06,639 --> 00:12:08,160
instruction and then it changes the

327
00:12:08,160 --> 00:12:10,399
program counter so that it can

328
00:12:10,399 --> 00:12:12,880
change the execution and go to the next

329
00:12:12,880 --> 00:12:13,920
function

330
00:12:13,920 --> 00:12:14,290
so we

331
00:12:14,290 --> 00:12:15,519
[Music]

332
00:12:15,519 --> 00:12:17,279
so for us there are three important

333
00:12:17,279 --> 00:12:18,720
parts in the patch first one is the

334
00:12:18,720 --> 00:12:21,120
patch itself next is the address of the

335
00:12:21,120 --> 00:12:23,600
patch and the third one is the hook

336
00:12:23,600 --> 00:12:25,920
that changes the execution flow so our

337
00:12:25,920 --> 00:12:27,920
hook is actually

338
00:12:27,920 --> 00:12:30,160
changing this second load instruction

339
00:12:30,160 --> 00:12:33,040
and adding our own offset to it so we

340
00:12:33,040 --> 00:12:35,440
find an empty location in the jump table

341
00:12:35,440 --> 00:12:37,360
we write the address of our patch to

342
00:12:37,360 --> 00:12:38,560
that location

343
00:12:38,560 --> 00:12:41,040
we change the offset here related to the

344
00:12:41,040 --> 00:12:43,040
base address of the jump table

345
00:12:43,040 --> 00:12:45,600
such that instead of getting the address

346
00:12:45,600 --> 00:12:47,279
of the next function we get the address

347
00:12:47,279 --> 00:12:49,120
of the patch in the second load

348
00:12:49,120 --> 00:12:52,000
instruction then we can uh jump to the

349
00:12:52,000 --> 00:12:54,320
patch the patch will manipulate and

350
00:12:54,320 --> 00:12:56,079
change the memory uh

351
00:12:56,079 --> 00:12:58,800
memory value at that location fix it

352
00:12:58,800 --> 00:13:00,880
and then we can uh restore the execution

353
00:13:00,880 --> 00:13:02,720
flow and then we can go to the actual

354
00:13:02,720 --> 00:13:04,560
function that we need to execute but

355
00:13:04,560 --> 00:13:07,600
this is how we patch um in case of the

356
00:13:07,600 --> 00:13:10,959
ise application input this v3

357
00:13:10,959 --> 00:13:14,480
so next let us look at some demos of

358
00:13:14,480 --> 00:13:16,800
patching certain vulnerabilities we

359
00:13:16,800 --> 00:13:18,160
consider top four out of five

360
00:13:18,160 --> 00:13:20,880
vulnerabilities from common

361
00:13:20,880 --> 00:13:23,519
weakness enumeration index

362
00:13:23,519 --> 00:13:25,760
we won't be discussing improper

363
00:13:25,760 --> 00:13:27,760
input validation because improper input

364
00:13:27,760 --> 00:13:29,839
validation in our data set eventually

365
00:13:29,839 --> 00:13:31,920
leads to auto bombs right so this covers

366
00:13:31,920 --> 00:13:33,519
both of them

367
00:13:33,519 --> 00:13:35,680
these kind of vulnerabilities manifest

368
00:13:35,680 --> 00:13:37,279
themselves because

369
00:13:37,279 --> 00:13:39,120
no like most commonly because of missing

370
00:13:39,120 --> 00:13:41,760
bomb checks in the imported functions

371
00:13:41,760 --> 00:13:43,600
an adversary can override smaller

372
00:13:43,600 --> 00:13:45,519
buffers so

373
00:13:45,519 --> 00:13:47,519
essentially overwriting certain return

374
00:13:47,519 --> 00:13:49,760
addresses on the shared stack which

375
00:13:49,760 --> 00:13:51,519
might mess with the control flow leading

376
00:13:51,519 --> 00:13:53,839
to denial of service and most of the

377
00:13:53,839 --> 00:13:54,800
times

378
00:13:54,800 --> 00:13:57,040
this scan the effects of this can spill

379
00:13:57,040 --> 00:13:59,600
over to the runtime itself and the

380
00:13:59,600 --> 00:14:03,760
runtime need might need to be rebooted

381
00:14:03,760 --> 00:14:04,800
so

382
00:14:04,800 --> 00:14:06,480
now let us look at the experiment setup

383
00:14:06,480 --> 00:14:07,360
for this

384
00:14:07,360 --> 00:14:09,040
again we have a hardware in the loop

385
00:14:09,040 --> 00:14:12,240
setup where we have the msf desalination

386
00:14:12,240 --> 00:14:15,040
plant model working in matlab simulink

387
00:14:15,040 --> 00:14:17,839
which is talking continuously to our plc

388
00:14:17,839 --> 00:14:21,440
avo pfc100 it is sending two uh it

389
00:14:21,440 --> 00:14:23,519
descending four inputs uh first one is

390
00:14:23,519 --> 00:14:26,000
the distillate flow rate which is the

391
00:14:26,000 --> 00:14:27,120
output

392
00:14:27,120 --> 00:14:29,120
of the desalination plant and the

393
00:14:29,120 --> 00:14:31,440
initial brine temperature tb0 and the

394
00:14:31,440 --> 00:14:35,760
corresponding sizes to the uh plc in

395
00:14:35,760 --> 00:14:37,360
in question

396
00:14:37,360 --> 00:14:39,360
so

397
00:14:39,360 --> 00:14:41,680
in this case we again have the same

398
00:14:41,680 --> 00:14:44,399
function for simulating the attack

399
00:14:44,399 --> 00:14:45,199
which

400
00:14:45,199 --> 00:14:47,920
when enabled uh at the 100th operation

401
00:14:47,920 --> 00:14:50,000
cycle it will send a malicious

402
00:14:50,000 --> 00:14:50,880
size

403
00:14:50,880 --> 00:14:53,600
uh to the plc

404
00:14:53,600 --> 00:14:56,240
and what exactly happens on the plc side

405
00:14:56,240 --> 00:14:58,480
is that once it gets an input it scales

406
00:14:58,480 --> 00:14:59,199
it

407
00:14:59,199 --> 00:15:01,760
it adds the sizes together in this case

408
00:15:01,760 --> 00:15:03,839
it's the array size variable

409
00:15:03,839 --> 00:15:05,440
uh this is sent to the second function

410
00:15:05,440 --> 00:15:07,440
which is first pid this is a cascaded

411
00:15:07,440 --> 00:15:09,360
pid setup in the same

412
00:15:09,360 --> 00:15:12,800
plc so you can see uh here we use mem

413
00:15:12,800 --> 00:15:15,680
cpy uh which is vulnerable to autobahn's

414
00:15:15,680 --> 00:15:16,480
right

415
00:15:16,480 --> 00:15:19,120
for copying the variables the parameters

416
00:15:19,120 --> 00:15:20,320
sent from

417
00:15:20,320 --> 00:15:22,360
plc prg to the second function

418
00:15:22,360 --> 00:15:23,680
[Music]

419
00:15:23,680 --> 00:15:26,000
if the array size is more than what is

420
00:15:26,000 --> 00:15:28,000
expected by the program then it will

421
00:15:28,000 --> 00:15:29,519
override

422
00:15:29,519 --> 00:15:31,839
the stack itself the contents of the

423
00:15:31,839 --> 00:15:32,880
stack

424
00:15:32,880 --> 00:15:35,920
however uh there can be two types of

425
00:15:35,920 --> 00:15:38,320
effect of outer bounce right

426
00:15:38,320 --> 00:15:40,639
for instance the effects of this

427
00:15:40,639 --> 00:15:43,600
vulnerability can be limited to the ic

428
00:15:43,600 --> 00:15:45,680
application itself what i mean by that

429
00:15:45,680 --> 00:15:47,519
it might only crash the control

430
00:15:47,519 --> 00:15:49,920
application but it might not impact the

431
00:15:49,920 --> 00:15:51,920
running of the runtime

432
00:15:51,920 --> 00:15:54,079
however the effects of this

433
00:15:54,079 --> 00:15:56,000
vulnerability can also spill over to the

434
00:15:56,000 --> 00:15:58,480
runtime as well where it might crash the

435
00:15:58,480 --> 00:16:00,639
runtime and there might be a need to

436
00:16:00,639 --> 00:16:03,279
reboot the complete plc

437
00:16:03,279 --> 00:16:04,880
so these two cases are handled

438
00:16:04,880 --> 00:16:06,399
differently

439
00:16:06,399 --> 00:16:08,000
for detecting the first case which is

440
00:16:08,000 --> 00:16:10,160
the ic application we

441
00:16:10,160 --> 00:16:12,639
run the clean uh

442
00:16:12,639 --> 00:16:14,320
we run the instance of the

443
00:16:14,320 --> 00:16:15,279
of the

444
00:16:15,279 --> 00:16:17,680
of this ic application with clean inputs

445
00:16:17,680 --> 00:16:20,320
we gathered the information then we come

446
00:16:20,320 --> 00:16:22,480
when then we gather the right offsets on

447
00:16:22,480 --> 00:16:24,720
the uh stack frames and compare it with

448
00:16:24,720 --> 00:16:27,120
the example of uh

449
00:16:27,120 --> 00:16:28,959
of when the same program is run with

450
00:16:28,959 --> 00:16:32,079
exploit input any deviations in this can

451
00:16:32,079 --> 00:16:34,480
tell you about the vulnerability the

452
00:16:34,480 --> 00:16:36,240
second instance is when it impacts the

453
00:16:36,240 --> 00:16:38,480
codex's runtime in that scenario what we

454
00:16:38,480 --> 00:16:40,720
can do is we can directly use uh the

455
00:16:40,720 --> 00:16:42,399
breakpoint functionality provided by

456
00:16:42,399 --> 00:16:45,279
anger execution engine to detect if that

457
00:16:45,279 --> 00:16:47,600
specific rule is being violated or not

458
00:16:47,600 --> 00:16:50,399
if the mem if the stack part of the code

459
00:16:50,399 --> 00:16:53,199
is runtime is being overwritten or not

460
00:16:53,199 --> 00:16:55,199
so in this case uh we

461
00:16:55,199 --> 00:16:56,560
are going to

462
00:16:56,560 --> 00:16:58,399
look at the second

463
00:16:58,399 --> 00:17:00,800
uh setup which is uh impacting the code

464
00:17:00,800 --> 00:17:02,560
resist runtime so when we start

465
00:17:02,560 --> 00:17:05,520
executing uh the msf designation plant

466
00:17:05,520 --> 00:17:06,400
model

467
00:17:06,400 --> 00:17:08,160
in a normal scenario the distillate

468
00:17:08,160 --> 00:17:10,119
output will remain somewhere close to

469
00:17:10,119 --> 00:17:12,480
19.18 ton per minute

470
00:17:12,480 --> 00:17:15,199
however when

471
00:17:15,199 --> 00:17:17,280
when the attack is enabled and the

472
00:17:17,280 --> 00:17:21,280
execution hits the 100th operation cycle

473
00:17:21,280 --> 00:17:23,839
the malicious size of 200 will be sent

474
00:17:23,839 --> 00:17:24,720
which

475
00:17:24,720 --> 00:17:26,240
will lead to an out of bound

476
00:17:26,240 --> 00:17:28,960
vulnerability crashing the runtime so in

477
00:17:28,960 --> 00:17:31,200
this scenario the ic application stops

478
00:17:31,200 --> 00:17:33,840
responding it stops regulating the steam

479
00:17:33,840 --> 00:17:36,720
flow rate into the uh brian heater such

480
00:17:36,720 --> 00:17:38,880
that the distillate output decreases and

481
00:17:38,880 --> 00:17:41,520
it keeps on decreasing

482
00:17:41,520 --> 00:17:43,200
so for patching this

483
00:17:43,200 --> 00:17:45,440
we first gather execution state of clean

484
00:17:45,440 --> 00:17:46,880
sample

485
00:17:46,880 --> 00:17:49,039
which essentially means that the

486
00:17:49,039 --> 00:17:51,360
running of the ic application with

487
00:17:51,360 --> 00:17:53,840
normal inputs

488
00:17:53,840 --> 00:17:55,520
so

489
00:17:55,520 --> 00:17:57,200
we have a local path server working on

490
00:17:57,200 --> 00:17:58,799
the test plc

491
00:17:58,799 --> 00:18:01,440
the script the framework talks

492
00:18:01,440 --> 00:18:03,520
with this local path server gets some

493
00:18:03,520 --> 00:18:05,440
important information and then as

494
00:18:05,440 --> 00:18:07,760
explained in step one start getting the

495
00:18:07,760 --> 00:18:09,360
hex dumps

496
00:18:09,360 --> 00:18:11,679
after getting the hex dump it

497
00:18:11,679 --> 00:18:15,440
starts uh rehosting everything in anger

498
00:18:15,440 --> 00:18:18,080
and then starts executing everything

499
00:18:18,080 --> 00:18:19,520
so in this case there won't be any

500
00:18:19,520 --> 00:18:21,200
vulnerability because this is a clean

501
00:18:21,200 --> 00:18:23,280
sample however if

502
00:18:23,280 --> 00:18:24,960
it retrieves all the intra stack frames

503
00:18:24,960 --> 00:18:27,280
right which can be compared later on

504
00:18:27,280 --> 00:18:29,520
with the execution state off and

505
00:18:29,520 --> 00:18:31,360
of the ic application with an exploit

506
00:18:31,360 --> 00:18:33,840
input so next we feed the exploit input

507
00:18:33,840 --> 00:18:35,840
which you can get using frameworks such

508
00:18:35,840 --> 00:18:38,720
as iss first

509
00:18:39,200 --> 00:18:40,480
so

510
00:18:40,480 --> 00:18:42,880
we do the same thing we again gather all

511
00:18:42,880 --> 00:18:45,360
the execution state however in this case

512
00:18:45,360 --> 00:18:46,559
and now

513
00:18:46,559 --> 00:18:47,280
the

514
00:18:47,280 --> 00:18:49,200
outer bounds right rule will be

515
00:18:49,200 --> 00:18:51,600
triggered

516
00:18:53,200 --> 00:18:55,679
it's executing it in anger okay as you

517
00:18:55,679 --> 00:18:57,760
can see it detected the vulnerability

518
00:18:57,760 --> 00:19:00,640
then using data dependence graph it it

519
00:19:00,640 --> 00:19:02,559
started from a node in the graph

520
00:19:02,559 --> 00:19:04,640
traverse backward and figure out exactly

521
00:19:04,640 --> 00:19:06,559
where it needed to patch again as you

522
00:19:06,559 --> 00:19:08,400
can see this is a stored instruction so

523
00:19:08,400 --> 00:19:10,160
it is patching a memory location which

524
00:19:10,160 --> 00:19:12,080
is being altered by this store

525
00:19:12,080 --> 00:19:13,120
instruction

526
00:19:13,120 --> 00:19:15,600
so in our case we are patching between

527
00:19:15,600 --> 00:19:18,400
the mem cpy and

528
00:19:18,400 --> 00:19:20,559
the call to the mem cpy right so the mem

529
00:19:20,559 --> 00:19:22,160
cpy actually

530
00:19:22,160 --> 00:19:25,360
expects an input of size

531
00:19:25,360 --> 00:19:26,160
now

532
00:19:26,160 --> 00:19:28,080
let us look at this so it is expecting

533
00:19:28,080 --> 00:19:30,000
an input of array size into the size of

534
00:19:30,000 --> 00:19:32,799
l real which in our case is comes out to

535
00:19:32,799 --> 00:19:34,799
be 24 so unlike

536
00:19:34,799 --> 00:19:36,559
just the array size we have to actually

537
00:19:36,559 --> 00:19:40,559
specify 24 as the new new size which is

538
00:19:40,559 --> 00:19:42,320
to be written in the patch

539
00:19:42,320 --> 00:19:45,440
so after that the patch is written and

540
00:19:45,440 --> 00:19:47,600
as you can see once we start executing

541
00:19:47,600 --> 00:19:49,440
it again

542
00:19:49,440 --> 00:19:51,679
at the 100th operation cycle we will see

543
00:19:51,679 --> 00:19:53,520
the 200

544
00:19:53,520 --> 00:19:55,280
size being sent to

545
00:19:55,280 --> 00:19:57,440
the plc however it won't cause a crash

546
00:19:57,440 --> 00:19:59,520
in this scenario it just keeps executing

547
00:19:59,520 --> 00:20:03,200
because the patch is already installed

548
00:20:03,440 --> 00:20:04,720
okay

549
00:20:04,720 --> 00:20:06,960
next vulnerability is out of bound speed

550
00:20:06,960 --> 00:20:09,679
uh it manifests in the same way as uh

551
00:20:09,679 --> 00:20:12,000
auto bombs right using uh because of

552
00:20:12,000 --> 00:20:14,080
missing bound checks can leak secrets

553
00:20:14,080 --> 00:20:16,160
but it does not crash the runtime

554
00:20:16,160 --> 00:20:18,320
unlike the outer bombs right

555
00:20:18,320 --> 00:20:19,760
in this case we don't have a hardware in

556
00:20:19,760 --> 00:20:21,360
the loop setup we directly put the

557
00:20:21,360 --> 00:20:23,600
inputs that the plc receives in the

558
00:20:23,600 --> 00:20:25,520
program itself

559
00:20:25,520 --> 00:20:26,480
uh

560
00:20:26,480 --> 00:20:29,039
the important thing to note here is that

561
00:20:29,039 --> 00:20:32,000
we are using pcpy as a function to copy

562
00:20:32,000 --> 00:20:34,480
the parameters send from plc prg to the

563
00:20:34,480 --> 00:20:36,159
second function

564
00:20:36,159 --> 00:20:37,679
two important parameters with this

565
00:20:37,679 --> 00:20:38,960
function are the

566
00:20:38,960 --> 00:20:40,720
bit offset which

567
00:20:40,720 --> 00:20:42,320
which essentially means

568
00:20:42,320 --> 00:20:43,919
the bit from which you have to start

569
00:20:43,919 --> 00:20:44,799
reading

570
00:20:44,799 --> 00:20:46,480
and how much you have to read is the

571
00:20:46,480 --> 00:20:48,640
fourth parameter which is the size so in

572
00:20:48,640 --> 00:20:50,000
this example the adversary is

573
00:20:50,000 --> 00:20:51,919
manipulating the bit offset for causing

574
00:20:51,919 --> 00:20:54,400
outer bound speed

575
00:20:54,400 --> 00:20:55,679
so it

576
00:20:55,679 --> 00:20:58,240
executes the

577
00:20:58,240 --> 00:20:59,200
the

578
00:20:59,200 --> 00:21:02,080
patching works in the same way first we

579
00:21:02,080 --> 00:21:03,760
gathered the execution state of clean

580
00:21:03,760 --> 00:21:05,280
samples

581
00:21:05,280 --> 00:21:06,320
and

582
00:21:06,320 --> 00:21:08,159
which is which is the same which is not

583
00:21:08,159 --> 00:21:10,559
interesting uh let us move to the second

584
00:21:10,559 --> 00:21:11,679
part

585
00:21:11,679 --> 00:21:13,600
okay now it's gathering execution state

586
00:21:13,600 --> 00:21:15,840
uh of the ic application when the

587
00:21:15,840 --> 00:21:19,439
exploit input is fed to it

588
00:21:20,720 --> 00:21:21,760
after

589
00:21:21,760 --> 00:21:24,559
after getting all the input it is

590
00:21:24,559 --> 00:21:26,400
so it is now uh

591
00:21:26,400 --> 00:21:28,000
rehosting everything in anger it should

592
00:21:28,000 --> 00:21:30,400
be noted that for patching as as i

593
00:21:30,400 --> 00:21:32,480
mentioned before we need two things we

594
00:21:32,480 --> 00:21:35,200
have an lcm patcher so i inserted that

595
00:21:35,200 --> 00:21:37,919
lq module first and then i

596
00:21:37,919 --> 00:21:39,840
i have the local patch server in the

597
00:21:39,840 --> 00:21:42,080
deploy mode so that it can talk with the

598
00:21:42,080 --> 00:21:45,440
lkm patcher here

599
00:21:45,440 --> 00:21:48,320
so it's it's executing the ic

600
00:21:48,320 --> 00:21:51,120
application in anger now the output here

601
00:21:51,120 --> 00:21:52,559
is a little different from the previous

602
00:21:52,559 --> 00:21:54,559
ones we have two possible places where

603
00:21:54,559 --> 00:21:57,600
it can patch this is because uh fit cpi

604
00:21:57,600 --> 00:21:59,200
function in this scenario takes two

605
00:21:59,200 --> 00:22:01,280
important inputs which can cause this

606
00:22:01,280 --> 00:22:04,320
issue first one is the bit offset and

607
00:22:04,320 --> 00:22:06,400
the second one is the size in this case

608
00:22:06,400 --> 00:22:09,360
clearly the index 0 which is p 3 v 0

609
00:22:09,360 --> 00:22:11,919
value which corresponds to 46 000 that

610
00:22:11,919 --> 00:22:13,520
is the exploit input in this scenario is

611
00:22:13,520 --> 00:22:15,840
the issue so we figure out where exactly

612
00:22:15,840 --> 00:22:17,679
we need to patch in memory we calculate

613
00:22:17,679 --> 00:22:18,799
the offset

614
00:22:18,799 --> 00:22:21,200
the user can specify uh which specific

615
00:22:21,200 --> 00:22:23,919
index in this scenario it will be zero

616
00:22:23,919 --> 00:22:27,840
the value should be zero as well

617
00:22:27,840 --> 00:22:30,640
and then it can be patched

618
00:22:30,640 --> 00:22:32,720
however uh before going to the next one

619
00:22:32,720 --> 00:22:34,720
i want to talk about something so as i

620
00:22:34,720 --> 00:22:35,760
mentioned there are three important

621
00:22:35,760 --> 00:22:37,600
things with the patch first one is the

622
00:22:37,600 --> 00:22:40,000
hook in this case the hook is the load

623
00:22:40,000 --> 00:22:41,039
instruction

624
00:22:41,039 --> 00:22:43,360
the original load instruction was

625
00:22:43,360 --> 00:22:45,919
without any offset but we added an

626
00:22:45,919 --> 00:22:48,480
offset of hex 28 so that it points to

627
00:22:48,480 --> 00:22:52,240
our own patch code and then we then the

628
00:22:52,240 --> 00:22:54,960
execution goes to our patch we actually

629
00:22:54,960 --> 00:22:56,559
found an empty location in the jump

630
00:22:56,559 --> 00:22:57,760
table and that is where we wrote the

631
00:22:57,760 --> 00:22:59,360
address of our patch so that is how we

632
00:22:59,360 --> 00:23:02,159
change the execution flow

633
00:23:02,159 --> 00:23:04,880
okay finally the last one which is os

634
00:23:04,880 --> 00:23:06,960
command injection

635
00:23:06,960 --> 00:23:09,039
in this this is a little different from

636
00:23:09,039 --> 00:23:11,280
other vulnerabilities because

637
00:23:11,280 --> 00:23:13,840
uh we need to change the execution flow

638
00:23:13,840 --> 00:23:15,679
so that it goes to the payload that is

639
00:23:15,679 --> 00:23:17,760
being sent by the adversary it can be

640
00:23:17,760 --> 00:23:19,360
done in two ways you can either

641
00:23:19,360 --> 00:23:20,960
overwrite return address on the stack

642
00:23:20,960 --> 00:23:24,640
itself but that is a little finicky so

643
00:23:24,640 --> 00:23:27,120
in our text examples we override the

644
00:23:27,120 --> 00:23:28,720
next function address in the address

645
00:23:28,720 --> 00:23:30,799
table

646
00:23:30,799 --> 00:23:33,280
so that the execution flow actually goes

647
00:23:33,280 --> 00:23:35,120
to the malicious payload instead of

648
00:23:35,120 --> 00:23:37,200
going to the next function itself

649
00:23:37,200 --> 00:23:39,200
so in this scenario uh so in all the

650
00:23:39,200 --> 00:23:40,720
previous examples we were actually

651
00:23:40,720 --> 00:23:41,919
patching the

652
00:23:41,919 --> 00:23:44,000
cause of the

653
00:23:44,000 --> 00:23:46,000
of the attack rather than the effect but

654
00:23:46,000 --> 00:23:48,080
in this case we'll be catching the

655
00:23:48,080 --> 00:23:50,559
effect what i mean by that is

656
00:23:50,559 --> 00:23:52,159
we won't be patching the malicious

657
00:23:52,159 --> 00:23:53,760
offset which has been sent by the

658
00:23:53,760 --> 00:23:56,320
adversary which leads to overwriting and

659
00:23:56,320 --> 00:23:58,080
addressing the jump table or the address

660
00:23:58,080 --> 00:24:00,799
table but instead we'll be fixing the

661
00:24:00,799 --> 00:24:02,559
malicious payload address that has

662
00:24:02,559 --> 00:24:04,720
already been addressed that has already

663
00:24:04,720 --> 00:24:08,480
been inserted into the jump table

664
00:24:08,480 --> 00:24:09,600
so

665
00:24:09,600 --> 00:24:10,960
again

666
00:24:10,960 --> 00:24:13,039
let us look at the example again in this

667
00:24:13,039 --> 00:24:14,720
scenario we don't have a hardware in the

668
00:24:14,720 --> 00:24:16,480
loop setup but the inputs are directly

669
00:24:16,480 --> 00:24:18,000
provided

670
00:24:18,000 --> 00:24:20,480
in the program itself we have a payload

671
00:24:20,480 --> 00:24:23,279
which is just executing a simple syscall

672
00:24:23,279 --> 00:24:25,200
for creating directory

673
00:24:25,200 --> 00:24:26,799
we have an offset of zero this is a

674
00:24:26,799 --> 00:24:29,039
clean example but this offset can be

675
00:24:29,039 --> 00:24:31,360
manipulated by the adversary if

676
00:24:31,360 --> 00:24:34,559
this is received over the sensor

677
00:24:34,559 --> 00:24:36,880
and an adversary can then use that

678
00:24:36,880 --> 00:24:38,640
manipulated value to overwrite an

679
00:24:38,640 --> 00:24:40,640
address overwrite the address of the

680
00:24:40,640 --> 00:24:41,520
code

681
00:24:41,520 --> 00:24:44,000
function in the address table so once

682
00:24:44,000 --> 00:24:46,240
the execution reaches this point instead

683
00:24:46,240 --> 00:24:48,080
of executing this code it will actually

684
00:24:48,080 --> 00:24:51,120
execute the it will actually execute the

685
00:24:51,120 --> 00:24:54,399
uh payload itself

686
00:24:55,039 --> 00:24:56,880
for this uh we

687
00:24:56,880 --> 00:24:59,279
okay uh i should mention that

688
00:24:59,279 --> 00:25:01,120
codesys runtime actually runs in the

689
00:25:01,120 --> 00:25:03,760
user space and on linux it actually

690
00:25:03,760 --> 00:25:05,840
utilizes uh some functions from the

691
00:25:05,840 --> 00:25:08,240
shared libraries such as lipsc and libm

692
00:25:08,240 --> 00:25:09,600
so the framework also provides

693
00:25:09,600 --> 00:25:10,960
functionality to

694
00:25:10,960 --> 00:25:12,320
get the

695
00:25:12,320 --> 00:25:14,960
to get the hex dumps of these uh

696
00:25:14,960 --> 00:25:16,880
these files

697
00:25:16,880 --> 00:25:19,600
of these uh

698
00:25:19,600 --> 00:25:20,559
okay

699
00:25:20,559 --> 00:25:22,559
so next we run the

700
00:25:22,559 --> 00:25:24,400
ic application we

701
00:25:24,400 --> 00:25:27,679
gathered the clean inputs because

702
00:25:27,679 --> 00:25:29,840
as i mentioned before the adversary can

703
00:25:29,840 --> 00:25:32,000
also override the return addresses on

704
00:25:32,000 --> 00:25:33,760
the stack which can be detected by

705
00:25:33,760 --> 00:25:37,520
comparing the clean and the unsafe input

706
00:25:37,520 --> 00:25:38,960
stack

707
00:25:38,960 --> 00:25:40,960
right the offsets that are written on

708
00:25:40,960 --> 00:25:44,080
the stack but again this is not

709
00:25:44,080 --> 00:25:46,240
important yes the next step is patching

710
00:25:46,240 --> 00:25:47,200
with the

711
00:25:47,200 --> 00:25:49,360
exploit input in which we again capture

712
00:25:49,360 --> 00:25:52,559
the state of execution

713
00:25:52,559 --> 00:25:54,720
then we start executing it in anger we

714
00:25:54,720 --> 00:25:57,440
do host hpas start executing it and

715
00:25:57,440 --> 00:26:00,080
anger unlike previous examples in this

716
00:26:00,080 --> 00:26:02,880
case uh there is no input required by

717
00:26:02,880 --> 00:26:03,919
the user

718
00:26:03,919 --> 00:26:05,440
this is because

719
00:26:05,440 --> 00:26:07,520
what we'll be fixing is the address on

720
00:26:07,520 --> 00:26:09,200
on the jump table and the user won't

721
00:26:09,200 --> 00:26:11,200
know this address so everything is

722
00:26:11,200 --> 00:26:12,799
calculated by

723
00:26:12,799 --> 00:26:14,159
from the angular instance so we

724
00:26:14,159 --> 00:26:16,240
calculate all the offsets then get the

725
00:26:16,240 --> 00:26:19,120
live base address from the

726
00:26:19,120 --> 00:26:20,880
the local path server working on the

727
00:26:20,880 --> 00:26:23,279
deployed plc and then we figure out the

728
00:26:23,279 --> 00:26:25,360
final address that needs to be

729
00:26:25,360 --> 00:26:27,279
uh overwritten and what has to be

730
00:26:27,279 --> 00:26:28,640
written there

731
00:26:28,640 --> 00:26:30,000
directly so

732
00:26:30,000 --> 00:26:32,000
everything in this specific example is

733
00:26:32,000 --> 00:26:34,880
done automatically

734
00:26:36,840 --> 00:26:38,559
forward

735
00:26:38,559 --> 00:26:41,039
so in this case uh it detected the

736
00:26:41,039 --> 00:26:43,440
the exploit input which was the offset

737
00:26:43,440 --> 00:26:45,600
so you can see uh the

738
00:26:45,600 --> 00:26:48,159
the framework talks with the uh for

739
00:26:48,159 --> 00:26:50,000
talks with the local patch server in bit

740
00:26:50,000 --> 00:26:52,000
string and then the local patch server

741
00:26:52,000 --> 00:26:53,760
talks with the lca apache also in

742
00:26:53,760 --> 00:26:56,240
bitstream so every all the communication

743
00:26:56,240 --> 00:26:58,240
is done in bitstring the local patch

744
00:26:58,240 --> 00:26:59,440
server

745
00:26:59,440 --> 00:27:01,520
is implemented both in we have

746
00:27:01,520 --> 00:27:04,240
implementation both in python and nc as

747
00:27:04,240 --> 00:27:06,240
well

748
00:27:06,240 --> 00:27:08,640
for patching we have an lk apache but

749
00:27:08,640 --> 00:27:11,120
also we have implemented a similar

750
00:27:11,120 --> 00:27:13,440
patching strategy with jtag

751
00:27:13,440 --> 00:27:14,480
so

752
00:27:14,480 --> 00:27:16,159
it can be used anything can be

753
00:27:16,159 --> 00:27:19,120
configured and used together

754
00:27:19,120 --> 00:27:21,520
finally we also have a debug mode where

755
00:27:21,520 --> 00:27:23,919
an user can patch the

756
00:27:23,919 --> 00:27:26,720
the test plc and then extract all the

757
00:27:26,720 --> 00:27:28,720
execution state and check if the rules

758
00:27:28,720 --> 00:27:30,640
are being triggered again in in the

759
00:27:30,640 --> 00:27:33,039
framework itself so it is

760
00:27:33,039 --> 00:27:35,039
something like a debug mode

761
00:27:35,039 --> 00:27:36,080
so

762
00:27:36,080 --> 00:27:37,840
that's it for the demos uh back to you

763
00:27:37,840 --> 00:27:40,399
mihalys

764
00:27:41,679 --> 00:27:43,679
thank you prasant

765
00:27:43,679 --> 00:27:45,760
so in order to quickly conclude and have

766
00:27:45,760 --> 00:27:48,400
a few say a few minutes for questions uh

767
00:27:48,400 --> 00:27:51,039
some limitations uh we tested mostly on

768
00:27:51,039 --> 00:27:53,600
on wagon the bigger born black

769
00:27:53,600 --> 00:27:56,240
but adding hot passing to other devices

770
00:27:56,240 --> 00:27:57,919
requires some modification manual

771
00:27:57,919 --> 00:28:00,080
modification and some slide changes the

772
00:28:00,080 --> 00:28:02,640
parts itself based on the platform that

773
00:28:02,640 --> 00:28:04,720
is being targeted so because of the

774
00:28:04,720 --> 00:28:07,360
offset sayings on different devices so

775
00:28:07,360 --> 00:28:10,000
for this to be adapted to some more uh

776
00:28:10,000 --> 00:28:11,440
plc's we need to do some more

777
00:28:11,440 --> 00:28:13,120
modification but it should be easy just

778
00:28:13,120 --> 00:28:15,200
a manual tweaking here and there

779
00:28:15,200 --> 00:28:17,760
uh so to conclude uh what we showed is

780
00:28:17,760 --> 00:28:20,159
that you know having a sharp stack

781
00:28:20,159 --> 00:28:22,080
allows control over runtimes if so you

782
00:28:22,080 --> 00:28:24,240
have a vulnerability application then

783
00:28:24,240 --> 00:28:25,919
you can get full access to the system

784
00:28:25,919 --> 00:28:28,240
and that can have devastating effects so

785
00:28:28,240 --> 00:28:29,600
in order to avoid that without

786
00:28:29,600 --> 00:28:32,159
restarting your plc what we saw in this

787
00:28:32,159 --> 00:28:35,440
talk is a way to hot patch those ic

788
00:28:35,440 --> 00:28:37,200
those variable ic applications running

789
00:28:37,200 --> 00:28:39,440
in potassius using alkane patches so

790
00:28:39,440 --> 00:28:41,279
without you don't need to restart

791
00:28:41,279 --> 00:28:43,120
so this concludes our talk thank you

792
00:28:43,120 --> 00:28:45,600
very much for attending and we have a

793
00:28:45,600 --> 00:28:49,480
minute or so for questions

794
00:28:49,530 --> 00:28:52,599
[Music]

795
00:28:56,440 --> 00:28:59,529
[Music]

