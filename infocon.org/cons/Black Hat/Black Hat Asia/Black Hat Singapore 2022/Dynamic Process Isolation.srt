1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:15,680 --> 00:00:18,660
University of Technology today we will

4
00:00:18,660 --> 00:00:21,000
present you Dynamic process isolation

5
00:00:21,000 --> 00:00:23,580
and during the talk we will talk a lot

6
00:00:23,580 --> 00:00:26,160
about cloudflare workers that's a good

7
00:00:26,160 --> 00:00:27,960
keyword so what actually are Cloud for

8
00:00:27,960 --> 00:00:29,760
workers cloudflow workers are an edge

9
00:00:29,760 --> 00:00:32,098
Computing system one of the best and

10
00:00:32,098 --> 00:00:34,079
basically the deploy servers in between

11
00:00:34,079 --> 00:00:37,559
your your origin server and the clients

12
00:00:37,559 --> 00:00:40,020
so the idea of a network is to intercept

13
00:00:40,020 --> 00:00:42,660
your HTTP requests and modify them that

14
00:00:42,660 --> 00:00:44,940
can be used to basically run statistics

15
00:00:44,940 --> 00:00:47,399
or in common use case is to would be to

16
00:00:47,399 --> 00:00:49,860
insert ads into the actual body of the

17
00:00:49,860 --> 00:00:51,059
requests

18
00:00:51,059 --> 00:00:54,059
since this is a high performing system

19
00:00:54,059 --> 00:00:56,579
or server they redeploy there's a data

20
00:00:56,579 --> 00:00:59,280
deploy so-called in-process isolation

21
00:00:59,280 --> 00:01:00,780
what's the difference in between

22
00:01:00,780 --> 00:01:02,460
in-process isolation and classical

23
00:01:02,460 --> 00:01:05,459
isolation is that we remove the overhead

24
00:01:05,459 --> 00:01:07,740
of classical virtualization by putting

25
00:01:07,740 --> 00:01:11,040
every worker into the same process

26
00:01:11,040 --> 00:01:14,640
wait a minute are you saying that you

27
00:01:14,640 --> 00:01:17,040
basically ship like every single work in

28
00:01:17,040 --> 00:01:19,140
the same process and every single users

29
00:01:19,140 --> 00:01:21,840
runs is called like in the same process

30
00:01:21,840 --> 00:01:25,320
exactly but wait wait wait

31
00:01:25,320 --> 00:01:27,659
is this vulnerable to Specter I mean

32
00:01:27,659 --> 00:01:30,900
this it's like classy case no we have

33
00:01:30,900 --> 00:01:32,520
some some preconditions there we

34
00:01:32,520 --> 00:01:34,140
deserved all the local timers so you

35
00:01:34,140 --> 00:01:35,939
don't have a chance to measure time and

36
00:01:35,939 --> 00:01:38,400
furthermore we also will limit the

37
00:01:38,400 --> 00:01:40,500
requests you can send the sub-request

38
00:01:40,500 --> 00:01:42,000
you can send and also the memory you

39
00:01:42,000 --> 00:01:44,880
have available from each worker but if

40
00:01:44,880 --> 00:01:46,799
you were right and there would be a

41
00:01:46,799 --> 00:01:48,780
specter attack possible on our system we

42
00:01:48,780 --> 00:01:50,880
would need a low overhead solution in

43
00:01:50,880 --> 00:01:51,899
order to keep up with the high

44
00:01:51,899 --> 00:01:54,000
performance scores of our system I'm I'm

45
00:01:54,000 --> 00:01:56,579
not convinced I would say like do you

46
00:01:56,579 --> 00:01:58,920
know how Specter Works

47
00:01:58,920 --> 00:02:00,659
um no but maybe you can tell me yeah no

48
00:02:00,659 --> 00:02:02,759
we should start from scratch I mean it's

49
00:02:02,759 --> 00:02:04,920
okay let's start from like caches like

50
00:02:04,920 --> 00:02:07,320
super simple 101 stuff like

51
00:02:07,320 --> 00:02:09,239
like you know caches like they are like

52
00:02:09,239 --> 00:02:11,459
on all CPUs and they are like basically

53
00:02:11,459 --> 00:02:13,319
a fast way to access memory so every

54
00:02:13,319 --> 00:02:15,720
time you access memory for example you

55
00:02:15,720 --> 00:02:17,220
will try to load something and if it's

56
00:02:17,220 --> 00:02:19,319
not in the cache we will have cache Miss

57
00:02:19,319 --> 00:02:21,480
then goes to the ROM and we will have a

58
00:02:21,480 --> 00:02:23,940
request to the drum that will try to

59
00:02:23,940 --> 00:02:25,920
load the data in the cache once the data

60
00:02:25,920 --> 00:02:28,560
is loaded then you have a cacheet so in

61
00:02:28,560 --> 00:02:30,780
the second access for example it will be

62
00:02:30,780 --> 00:02:33,480
like a lot faster since access is the

63
00:02:33,480 --> 00:02:35,640
realm you will have like a slow access

64
00:02:35,640 --> 00:02:38,040
time and like accessing the cache

65
00:02:38,040 --> 00:02:39,720
directly since the cache is loaded you

66
00:02:39,720 --> 00:02:42,300
will have a fast access time okay okay I

67
00:02:42,300 --> 00:02:44,519
understand what caches are but this is

68
00:02:44,519 --> 00:02:46,080
not an attack what can I do with I know

69
00:02:46,080 --> 00:02:48,000
I know I know like one thing for a time

70
00:02:48,000 --> 00:02:51,660
oh but let's try to like go a bit like

71
00:02:51,660 --> 00:02:53,459
step by step with let's talk about Flash

72
00:02:53,459 --> 00:02:55,920
and reload so let's assume that I am a

73
00:02:55,920 --> 00:02:57,780
Tucker and I have some kind of shared

74
00:02:57,780 --> 00:02:59,760
memory with you as a big theme okay

75
00:02:59,760 --> 00:03:01,440
what's your memory is it like shared

76
00:03:01,440 --> 00:03:02,819
libraries load into the same process

77
00:03:02,819 --> 00:03:04,800
like yeah something like that yeah any

78
00:03:04,800 --> 00:03:06,060
kind of sharing memory that is like

79
00:03:06,060 --> 00:03:08,160
anything yes any kind of physical page

80
00:03:08,160 --> 00:03:11,159
that is like sharp between us okay

81
00:03:11,159 --> 00:03:12,840
so let's assume like we have some

82
00:03:12,840 --> 00:03:15,420
sharing memory that we both access and I

83
00:03:15,420 --> 00:03:16,860
want to invest something about your

84
00:03:16,860 --> 00:03:20,280
behavior so as an attacker I can flush

85
00:03:20,280 --> 00:03:22,440
the memory so that it will not more be

86
00:03:22,440 --> 00:03:25,019
in the cache okay yes so once the memory

87
00:03:25,019 --> 00:03:27,360
is flushed then okay the victim runs and

88
00:03:27,360 --> 00:03:29,940
maybe the victim accesses the like cache

89
00:03:29,940 --> 00:03:32,159
line in the memory and lots again that

90
00:03:32,159 --> 00:03:35,040
in the cache and then if I access that I

91
00:03:35,040 --> 00:03:37,739
can like kind of infer based on the like

92
00:03:37,739 --> 00:03:40,440
access time if they beat him access that

93
00:03:40,440 --> 00:03:42,959
or not so that I can infer some behavior

94
00:03:42,959 --> 00:03:44,280
of the victim

95
00:03:44,280 --> 00:03:47,340
okay that sounds cool but I still don't

96
00:03:47,340 --> 00:03:49,019
get what this has to do with speculation

97
00:03:49,019 --> 00:03:51,120
it's just yeah a memory access and the

98
00:03:51,120 --> 00:03:52,560
classic location used in a different way

99
00:03:52,560 --> 00:03:55,080
okay I see you you want Specter yes sure

100
00:03:55,080 --> 00:03:57,900
this is Specter okay wait so this is

101
00:03:57,900 --> 00:04:00,180
Vector so let me let me rephrase let me

102
00:04:00,180 --> 00:04:02,220
let me look at it so we see here a

103
00:04:02,220 --> 00:04:04,799
branch with an I assume out of bounds

104
00:04:04,799 --> 00:04:07,379
access and we have some index

105
00:04:07,379 --> 00:04:10,260
which goes into a data array which we

106
00:04:10,260 --> 00:04:11,879
then transform in some sort of lookup

107
00:04:11,879 --> 00:04:14,340
table Yeah we have clearly like two just

108
00:04:14,340 --> 00:04:16,199
two assumptions in this called snippet

109
00:04:16,199 --> 00:04:18,899
we as an attacker can control the index

110
00:04:18,899 --> 00:04:20,940
where the data is like accessed

111
00:04:20,940 --> 00:04:23,520
obviously the the data is like accessed

112
00:04:23,520 --> 00:04:25,620
with some checks so like there's a check

113
00:04:25,620 --> 00:04:27,419
that checks okay is the index inbound or

114
00:04:27,419 --> 00:04:28,860
out of bound and then this is an

115
00:04:28,860 --> 00:04:31,259
assumption is that okay then the victim

116
00:04:31,259 --> 00:04:33,600
code will like use the index in some way

117
00:04:33,600 --> 00:04:35,639
and here we are like simplifying a lot

118
00:04:35,639 --> 00:04:37,740
with like showing like the victim just

119
00:04:37,740 --> 00:04:40,860
accesses like any kind of shared memory

120
00:04:40,860 --> 00:04:43,320
like indexing with the data value so

121
00:04:43,320 --> 00:04:45,360
here Lut stands for like lookup table

122
00:04:45,360 --> 00:04:47,580
and it's just a way to like model this

123
00:04:47,580 --> 00:04:49,020
Behavior and the lookup table is the

124
00:04:49,020 --> 00:04:50,699
shared thing you mentioned exactly that

125
00:04:50,699 --> 00:04:52,020
ah okay

126
00:04:52,020 --> 00:04:54,000
so I know you want some more details on

127
00:04:54,000 --> 00:04:56,759
that so let's look at like how it works

128
00:04:56,759 --> 00:04:59,580
so we have like our local table that's

129
00:04:59,580 --> 00:05:02,460
the share memory and like for example we

130
00:05:02,460 --> 00:05:04,199
have some victim data like the green one

131
00:05:04,199 --> 00:05:06,479
is the black data that the victim should

132
00:05:06,479 --> 00:05:09,660
use and the red one is the data that we

133
00:05:09,660 --> 00:05:11,220
are not supposed to access as a victim

134
00:05:11,220 --> 00:05:13,320
since it like should be secret data

135
00:05:13,320 --> 00:05:15,180
exactly but but I can see there just the

136
00:05:15,180 --> 00:05:16,800
index with smaller than four so

137
00:05:16,800 --> 00:05:18,360
basically you can't access the key the

138
00:05:18,360 --> 00:05:20,759
secret data there yes so we have a check

139
00:05:20,759 --> 00:05:23,100
that's like should prevent like the

140
00:05:23,100 --> 00:05:25,440
secret data from being accessed but in

141
00:05:25,440 --> 00:05:27,240
like modern CPU there is this thing

142
00:05:27,240 --> 00:05:30,060
called speculation and basically a CPU

143
00:05:30,060 --> 00:05:32,100
tries to predict where like a branch

144
00:05:32,100 --> 00:05:34,740
will go to like optimize stuff and like

145
00:05:34,740 --> 00:05:37,199
being faster while executing so what

146
00:05:37,199 --> 00:05:39,960
happens when when you execute okay the

147
00:05:39,960 --> 00:05:41,460
first time like the CPU will know

148
00:05:41,460 --> 00:05:43,199
nothing so the speculation like doesn't

149
00:05:43,199 --> 00:05:46,259
matter here but then like after it gets

150
00:05:46,259 --> 00:05:47,820
where where is the right direction of

151
00:05:47,820 --> 00:05:50,520
the branch the CPU will like start

152
00:05:50,520 --> 00:05:51,960
understanding that okay this branches

153
00:05:51,960 --> 00:05:54,780
likely taken so we will execute our code

154
00:05:54,780 --> 00:05:57,180
and we will be reference like both the

155
00:05:57,180 --> 00:06:00,000
data and also there like lookup access

156
00:06:00,000 --> 00:06:02,820
and we will load the cache line there

157
00:06:02,820 --> 00:06:04,800
so what happens after we will continue

158
00:06:04,800 --> 00:06:07,259
like our our code and the CPU will

159
00:06:07,259 --> 00:06:09,240
continue speculating and executing the

160
00:06:09,240 --> 00:06:11,160
right side of the branch and then

161
00:06:11,160 --> 00:06:13,860
afterwards we the CPU will like be

162
00:06:13,860 --> 00:06:16,800
really like sure really confident that

163
00:06:16,800 --> 00:06:18,720
the branch is going to be taken

164
00:06:18,720 --> 00:06:21,300
so what happens like when the index is

165
00:06:21,300 --> 00:06:23,340
four it should report it's like the

166
00:06:23,340 --> 00:06:25,199
index check is still there so we should

167
00:06:25,199 --> 00:06:27,780
not access any secret data but the CPU

168
00:06:27,780 --> 00:06:30,240
will think that data is Success so we'll

169
00:06:30,240 --> 00:06:33,060
access K and then okay we'll continue

170
00:06:33,060 --> 00:06:34,860
accessing with the loot access and then

171
00:06:34,860 --> 00:06:37,020
load the k cache line here but what but

172
00:06:37,020 --> 00:06:38,699
wait wait wait that's not how to be used

173
00:06:38,699 --> 00:06:40,139
work you will never see the access

174
00:06:40,139 --> 00:06:41,340
because it's reverted because

175
00:06:41,340 --> 00:06:43,319
speculation can be reverted in CPUs yeah

176
00:06:43,319 --> 00:06:46,259
so speculation is reverted but not the

177
00:06:46,259 --> 00:06:48,539
effect in the cache line

178
00:06:48,539 --> 00:06:50,280
so the question will stay there and the

179
00:06:50,280 --> 00:06:52,500
attacker can observe that and then I can

180
00:06:52,500 --> 00:06:53,580
use the technique short in the beginning

181
00:06:53,580 --> 00:06:55,979
exactly sure if the line is in the cache

182
00:06:55,979 --> 00:06:59,960
exactly okay okay

183
00:07:00,180 --> 00:07:02,100
so

184
00:07:02,100 --> 00:07:03,900
this is not the whole Specter like

185
00:07:03,900 --> 00:07:06,720
Spectrum we want but actually I looked a

186
00:07:06,720 --> 00:07:07,979
bit into it and there are some

187
00:07:07,979 --> 00:07:09,660
mitigations against this Vector checks

188
00:07:09,660 --> 00:07:11,460
there are different levels so we have

189
00:07:11,460 --> 00:07:13,319
application level defenses which are

190
00:07:13,319 --> 00:07:15,360
basically newly added instructions you

191
00:07:15,360 --> 00:07:17,340
can add to your code in order to stop

192
00:07:17,340 --> 00:07:19,380
speculating if you add them near your

193
00:07:19,380 --> 00:07:21,660
branch you will stop the speculation of

194
00:07:21,660 --> 00:07:23,699
the branch furthermore there are also

195
00:07:23,699 --> 00:07:25,259
like system level mitigations where you

196
00:07:25,259 --> 00:07:27,240
have like operating system trying to

197
00:07:27,240 --> 00:07:29,340
clear the prediction state after a

198
00:07:29,340 --> 00:07:31,680
process which like a contact switch and

199
00:07:31,680 --> 00:07:33,419
finally in a perfect world we would have

200
00:07:33,419 --> 00:07:34,979
Hardware mitigations where we don't need

201
00:07:34,979 --> 00:07:37,080
to care about Specter at all

202
00:07:37,080 --> 00:07:41,340
okay I see that but like all of this

203
00:07:41,340 --> 00:07:43,139
mitigation have nothing to do with

204
00:07:43,139 --> 00:07:44,819
something that is in the same process

205
00:07:44,819 --> 00:07:46,259
you're basically saying okay if you're

206
00:07:46,259 --> 00:07:48,000
isolated we can mitigate that but we're

207
00:07:48,000 --> 00:07:49,740
running the same process so like what's

208
00:07:49,740 --> 00:07:51,720
the point of all this I see your point I

209
00:07:51,720 --> 00:07:53,460
see your point but we thought about it

210
00:07:53,460 --> 00:07:55,440
we first of all we freeze the execution

211
00:07:55,440 --> 00:07:57,360
time during the work execution so you

212
00:07:57,360 --> 00:07:58,440
don't have a timing primitive

213
00:07:58,440 --> 00:08:00,660
furthermore you have no native code you

214
00:08:00,660 --> 00:08:02,340
can't flush and reload basically because

215
00:08:02,340 --> 00:08:04,020
you're just mounted JavaScript

216
00:08:04,020 --> 00:08:06,360
and then we also don't allow for shared

217
00:08:06,360 --> 00:08:07,919
memories so we don't have these lookup

218
00:08:07,919 --> 00:08:09,599
tables anywhere in the cloudflare

219
00:08:09,599 --> 00:08:12,000
environment and finally we do not allow

220
00:08:12,000 --> 00:08:13,680
for multi-threading so you can't build

221
00:08:13,680 --> 00:08:15,479
like accounting thread that artificially

222
00:08:15,479 --> 00:08:16,740
makes a timer

223
00:08:16,740 --> 00:08:19,080
so you're basically saying that I cannot

224
00:08:19,080 --> 00:08:20,879
like measure timing while I'm executing

225
00:08:20,879 --> 00:08:22,860
yes you can't measure it so you can't

226
00:08:22,860 --> 00:08:24,240
leave no I don't think that's true

227
00:08:24,240 --> 00:08:26,580
that's that's not true like follow me

228
00:08:26,580 --> 00:08:28,680
follow me so we are saying okay we are

229
00:08:28,680 --> 00:08:30,660
in the same process I'm an attacker and

230
00:08:30,660 --> 00:08:32,339
like you're a victim and I won't like

231
00:08:32,339 --> 00:08:35,880
like leave the like the memory from you

232
00:08:35,880 --> 00:08:38,219
so just assume that I can like accent

233
00:08:38,219 --> 00:08:41,159
like transiently like victim data I

234
00:08:41,159 --> 00:08:42,599
still don't just assume that helps me

235
00:08:42,599 --> 00:08:45,000
okay I cannot measure time but what if I

236
00:08:45,000 --> 00:08:47,279
like ask for time so let's assume I have

237
00:08:47,279 --> 00:08:49,320
like a third party where either I can

238
00:08:49,320 --> 00:08:50,820
ask for time but okay you could say like

239
00:08:50,820 --> 00:08:52,920
you can block that or like whatever but

240
00:08:52,920 --> 00:08:54,600
what if I just send requests to the

241
00:08:54,600 --> 00:08:56,940
party and that party case did that for

242
00:08:56,940 --> 00:08:59,339
me and then tells me like okay this is

243
00:08:59,339 --> 00:09:01,640
like fast this is low

244
00:09:01,640 --> 00:09:04,320
waiting that we have like a third party

245
00:09:04,320 --> 00:09:06,000
server measuring the time and that

246
00:09:06,000 --> 00:09:07,980
third-party servers to distinguish a

247
00:09:07,980 --> 00:09:09,720
single cache hit from a single cache

248
00:09:09,720 --> 00:09:11,839
Miss

249
00:09:12,380 --> 00:09:15,720
yeah but I'm not saying this I don't

250
00:09:15,720 --> 00:09:17,820
want to distinguish a cash mistake that

251
00:09:17,820 --> 00:09:19,440
would be like super noisy super hard

252
00:09:19,440 --> 00:09:21,540
that's the idea right no we have this

253
00:09:21,540 --> 00:09:24,540
thing called amplification so we can

254
00:09:24,540 --> 00:09:27,180
like literally amplify the sign the

255
00:09:27,180 --> 00:09:28,800
signals that we want to measure so that

256
00:09:28,800 --> 00:09:31,019
we measure something that is much more

257
00:09:31,019 --> 00:09:34,320
like lasting in time so for example like

258
00:09:34,320 --> 00:09:36,779
I can give like an example we can okay

259
00:09:36,779 --> 00:09:38,580
you say I can measure a cache it but if

260
00:09:38,580 --> 00:09:39,959
I just measure I don't know one other

261
00:09:39,959 --> 00:09:41,640
cash sheet or cash misses they are much

262
00:09:41,640 --> 00:09:43,620
different but wait but wait cache lines

263
00:09:43,620 --> 00:09:45,240
are limited so you have no you cannot

264
00:09:45,240 --> 00:09:47,399
scale it originally yeah that that's why

265
00:09:47,399 --> 00:09:49,260
we have a second Point second way to do

266
00:09:49,260 --> 00:09:51,060
that let's assume that I want to measure

267
00:09:51,060 --> 00:09:53,459
something what if I just repeat that

268
00:09:53,459 --> 00:09:55,920
something like n times so let's let's

269
00:09:55,920 --> 00:09:58,860
have a like like a like simple look at

270
00:09:58,860 --> 00:10:00,420
the code that's simplified or busy

271
00:10:00,420 --> 00:10:01,980
button yeah let's assume okay we have

272
00:10:01,980 --> 00:10:04,500
like two cache lines on Cache line a and

273
00:10:04,500 --> 00:10:05,760
a cash line B

274
00:10:05,760 --> 00:10:08,220
so I want to lick like this secret bit

275
00:10:08,220 --> 00:10:10,440
and okay let's assume that both of those

276
00:10:10,440 --> 00:10:12,420
sketch lines are not loaded into memory

277
00:10:12,420 --> 00:10:15,720
so what if the okay transiently like

278
00:10:15,720 --> 00:10:17,700
excuse factor and I have some transient

279
00:10:17,700 --> 00:10:19,800
execution where transiently I can like

280
00:10:19,800 --> 00:10:22,320
either access A or B with the if

281
00:10:22,320 --> 00:10:24,360
statement so let's assume that secret

282
00:10:24,360 --> 00:10:26,399
bits for example is one

283
00:10:26,399 --> 00:10:28,500
we will have this if statement that will

284
00:10:28,500 --> 00:10:30,660
execute transiently and we will access

285
00:10:30,660 --> 00:10:32,640
the cache line a so we will have a cache

286
00:10:32,640 --> 00:10:33,720
Miss

287
00:10:33,720 --> 00:10:35,700
and then like for example Transit

288
00:10:35,700 --> 00:10:38,580
execution like dies so after that we

289
00:10:38,580 --> 00:10:40,620
will have like an access a in that is

290
00:10:40,620 --> 00:10:42,779
architectural but since we already

291
00:10:42,779 --> 00:10:45,060
loaded the cache line a in memory that

292
00:10:45,060 --> 00:10:47,700
access will be fast so we will have like

293
00:10:47,700 --> 00:10:50,100
as low access and then a faster like in

294
00:10:50,100 --> 00:10:51,360
the beginning with the cache yes yeah

295
00:10:51,360 --> 00:10:53,880
but in the second case let's assume that

296
00:10:53,880 --> 00:10:56,220
instead single bit is zero

297
00:10:56,220 --> 00:10:58,980
so we will take the S Branch we will

298
00:10:58,980 --> 00:11:01,320
like read from every beer so we will

299
00:11:01,320 --> 00:11:03,600
have slow access and then after that we

300
00:11:03,600 --> 00:11:05,579
will have another slow access due to the

301
00:11:05,579 --> 00:11:08,940
architectural reads of the line a so in

302
00:11:08,940 --> 00:11:11,279
every Loop iteration we will have like

303
00:11:11,279 --> 00:11:15,120
either one or two slow accesses okay I

304
00:11:15,120 --> 00:11:17,100
get that but how can what get what do

305
00:11:17,100 --> 00:11:20,339
you get out of it yeah so you can like

306
00:11:20,339 --> 00:11:23,160
execute that multiple times so if in One

307
00:11:23,160 --> 00:11:24,480
Direction we have either one or two

308
00:11:24,480 --> 00:11:26,700
accesses then in any iteration you will

309
00:11:26,700 --> 00:11:30,540
have either n or 2N slow accesses and if

310
00:11:30,540 --> 00:11:33,540
you scale n to like a big number you can

311
00:11:33,540 --> 00:11:34,920
like increase the attack almost

312
00:11:34,920 --> 00:11:36,600
arbitrarily like up to milliseconds

313
00:11:36,600 --> 00:11:38,579
timing differences so that you can

314
00:11:38,579 --> 00:11:41,899
observe like

315
00:11:43,880 --> 00:11:45,959
primitive where you can amplify the

316
00:11:45,959 --> 00:11:47,760
latency but still we're running in

317
00:11:47,760 --> 00:11:49,980
JavaScript JavaScript JavaScript has no

318
00:11:49,980 --> 00:11:52,140
native code execution so you how do you

319
00:11:52,140 --> 00:11:54,120
either flush and reload the memory

320
00:11:54,120 --> 00:11:55,079
because you don't have flush

321
00:11:55,079 --> 00:11:56,640
instructions or anything like that we

322
00:11:56,640 --> 00:11:58,380
also don't allow timing Primitives so

323
00:11:58,380 --> 00:12:00,540
you can't even build a which eviction

324
00:12:00,540 --> 00:12:03,000
sets with that so what do you do I see

325
00:12:03,000 --> 00:12:04,860
your point but you you don't need to

326
00:12:04,860 --> 00:12:07,380
like have such precise timing primitive

327
00:12:07,380 --> 00:12:09,120
like just to a big memory like for

328
00:12:09,120 --> 00:12:11,220
example we just can like iterate over

329
00:12:11,220 --> 00:12:13,019
huge arrays to like evict the whole

330
00:12:13,019 --> 00:12:15,959
caches like with like just iteration

331
00:12:15,959 --> 00:12:19,260
iterating with huge arrays so

332
00:12:19,260 --> 00:12:21,779
um yeah yeah okay but still if you look

333
00:12:21,779 --> 00:12:23,459
at Java Java is a highly optimized and

334
00:12:23,459 --> 00:12:26,220
de-optimized languages language so it

335
00:12:26,220 --> 00:12:28,019
has assumption variables it uses to

336
00:12:28,019 --> 00:12:29,880
optimize it but if these assumptions are

337
00:12:29,880 --> 00:12:32,459
broken then it's de-optimized again so

338
00:12:32,459 --> 00:12:34,079
how could you cope with that

339
00:12:34,079 --> 00:12:36,720
okay you're saying okay the JavaScript

340
00:12:36,720 --> 00:12:38,760
engine V8 in this case that's the engine

341
00:12:38,760 --> 00:12:41,399
that cloudflare uses like observe the

342
00:12:41,399 --> 00:12:44,279
code like breaking invariants but we can

343
00:12:44,279 --> 00:12:46,380
just like execute our attack behind a

344
00:12:46,380 --> 00:12:48,060
mispredictable branch so that the

345
00:12:48,060 --> 00:12:49,920
JavaScript engine actually will not

346
00:12:49,920 --> 00:12:52,200
observe our code breaking those

347
00:12:52,200 --> 00:12:54,120
invariants

348
00:12:54,120 --> 00:12:57,000
okay yeah furthermore we can just avoid

349
00:12:57,000 --> 00:12:59,459
like nasty optimization like in lining

350
00:12:59,459 --> 00:13:01,500
that will ruin like our brand predictor

351
00:13:01,500 --> 00:13:03,360
says by using like huge functions that

352
00:13:03,360 --> 00:13:06,000
are just not in line or like I think

353
00:13:06,000 --> 00:13:07,560
like big functions that are not fully

354
00:13:07,560 --> 00:13:09,600
optimized by the JavaScript engine

355
00:13:09,600 --> 00:13:11,279
okay so I see that you have some

356
00:13:11,279 --> 00:13:12,959
countermeasures against this complex

357
00:13:12,959 --> 00:13:14,040
thing of optimization and

358
00:13:14,040 --> 00:13:16,500
de-optimization but but still Java

359
00:13:16,500 --> 00:13:18,480
JavaScript objects are indexed by 32

360
00:13:18,480 --> 00:13:21,060
bits how can you ever access a 64-bit

361
00:13:21,060 --> 00:13:23,100
address in order to attack your worker

362
00:13:23,100 --> 00:13:25,740
in the same process I see okay so

363
00:13:25,740 --> 00:13:27,540
JavaScript has this thing called like

364
00:13:27,540 --> 00:13:29,700
pointer compression in V8 where they

365
00:13:29,700 --> 00:13:31,320
basically try to save memory like

366
00:13:31,320 --> 00:13:32,820
representing pointer with three little

367
00:13:32,820 --> 00:13:36,660
bits so almost every object has this but

368
00:13:36,660 --> 00:13:39,660
the keyword is almost oh not all the

369
00:13:39,660 --> 00:13:42,899
objects have like just 32-bit pointers

370
00:13:42,899 --> 00:13:44,339
there are some objects for example array

371
00:13:44,339 --> 00:13:47,459
buffers that have by Design have to be

372
00:13:47,459 --> 00:13:50,639
able to store 64-bit information so that

373
00:13:50,639 --> 00:13:52,560
we can just like Leverage those objects

374
00:13:52,560 --> 00:13:54,959
to like index the memory with 64-bit

375
00:13:54,959 --> 00:13:57,660
pointers so that we can use them and

376
00:13:57,660 --> 00:14:01,380
moreover we can like like confuse like

377
00:14:01,380 --> 00:14:02,820
Branch predictor on the types of those

378
00:14:02,820 --> 00:14:04,620
objects to create a speculative type

379
00:14:04,620 --> 00:14:07,320
confusion and like leak from memory

380
00:14:07,320 --> 00:14:10,139
so that sounds highly complex can you

381
00:14:10,139 --> 00:14:12,839
give us more details yeah yeah I see

382
00:14:12,839 --> 00:14:15,540
that I see that but let's like let's

383
00:14:15,540 --> 00:14:17,579
have a look on like how javascript's

384
00:14:17,579 --> 00:14:19,500
internal implementation works okay what

385
00:14:19,500 --> 00:14:21,600
do what do we see so yeah here you see

386
00:14:21,600 --> 00:14:23,579
like a simple object like for example

387
00:14:23,579 --> 00:14:25,079
let's assume that we have an object with

388
00:14:25,079 --> 00:14:27,420
an integer and a pointer to like an area

389
00:14:27,420 --> 00:14:28,800
buffer

390
00:14:28,800 --> 00:14:31,920
so how is that like uh laid up in memory

391
00:14:31,920 --> 00:14:33,959
we will have the JavaScript object and

392
00:14:33,959 --> 00:14:35,700
like with the winter and the pointer

393
00:14:35,700 --> 00:14:37,980
this pointer is this the 64-bit point no

394
00:14:37,980 --> 00:14:40,560
this is still a pointer to a JavaScript

395
00:14:40,560 --> 00:14:43,139
object that is 32 bits and this pointer

396
00:14:43,139 --> 00:14:45,320
will point to the array buffer object

397
00:14:45,320 --> 00:14:49,139
that contains itself the 64-bit point so

398
00:14:49,139 --> 00:14:51,000
that's the point that we want to that

399
00:14:51,000 --> 00:14:52,980
second one is the point that the target

400
00:14:52,980 --> 00:14:55,320
so the second pointer is the pointer

401
00:14:55,320 --> 00:14:57,060
that is the reference to

402
00:14:57,060 --> 00:14:59,760
when you go to access the 64-bit memory

403
00:14:59,760 --> 00:15:02,040
so we are live actually two memory

404
00:15:02,040 --> 00:15:04,260
references when you do like obj that

405
00:15:04,260 --> 00:15:06,480
pointer of zero

406
00:15:06,480 --> 00:15:08,339
so now let's assume that we have a

407
00:15:08,339 --> 00:15:09,480
second object

408
00:15:09,480 --> 00:15:11,940
this second object will be really really

409
00:15:11,940 --> 00:15:15,120
similar with the first object type

410
00:15:15,120 --> 00:15:16,800
we will have a lucky integer and all the

411
00:15:16,800 --> 00:15:19,380
other fields will be the same Fields but

412
00:15:19,380 --> 00:15:21,440
this second object will have an integer

413
00:15:21,440 --> 00:15:24,240
instead of the like array buffer pointer

414
00:15:24,240 --> 00:15:26,699
and with this integer we can literally

415
00:15:26,699 --> 00:15:29,339
control this stereo base value and with

416
00:15:29,339 --> 00:15:31,260
this integer what if we just make it

417
00:15:31,260 --> 00:15:33,660
point to any chunk of memory that we

418
00:15:33,660 --> 00:15:36,899
control to create a fake array buffer so

419
00:15:36,899 --> 00:15:39,000
that in the fake red buffer we will have

420
00:15:39,000 --> 00:15:40,740
the target address that we want to the

421
00:15:40,740 --> 00:15:42,060
reference

422
00:15:42,060 --> 00:15:44,160
and with these two steps the reference

423
00:15:44,160 --> 00:15:46,620
we can access any Target memory that we

424
00:15:46,620 --> 00:15:49,079
want okay I think I got the idea but

425
00:15:49,079 --> 00:15:50,760
still these are two different types of

426
00:15:50,760 --> 00:15:52,740
object JavaScript keeps track of which

427
00:15:52,740 --> 00:15:54,779
type of object it is in some kind of

428
00:15:54,779 --> 00:15:57,180
some sort of meta information so yes how

429
00:15:57,180 --> 00:15:59,040
would you confuse them like type what

430
00:15:59,040 --> 00:16:01,260
type of how JavaScript can check that

431
00:16:01,260 --> 00:16:04,139
with a branch

432
00:16:04,139 --> 00:16:06,420
we have a branch here so basically this

433
00:16:06,420 --> 00:16:08,100
branch is similar to the branch we saw

434
00:16:08,100 --> 00:16:09,360
in the beginning by the Specter Tech

435
00:16:09,360 --> 00:16:11,880
yeah we just don't mispredict on the

436
00:16:11,880 --> 00:16:14,699
bound check but who is mispredict on the

437
00:16:14,699 --> 00:16:16,980
type checking so with just different

438
00:16:16,980 --> 00:16:20,040
misprediction but just a branch

439
00:16:20,040 --> 00:16:22,740
okay well well that sounds again highly

440
00:16:22,740 --> 00:16:24,779
complex I don't think that can work have

441
00:16:24,779 --> 00:16:26,579
you any have to write that out can you

442
00:16:26,579 --> 00:16:27,779
show me something like that we have a

443
00:16:27,779 --> 00:16:29,579
cool demo

444
00:16:29,579 --> 00:16:31,980
so here we are like at the beginning of

445
00:16:31,980 --> 00:16:34,620
the attack our attack has to build the

446
00:16:34,620 --> 00:16:37,259
fake object primitive and then after

447
00:16:37,259 --> 00:16:39,180
having to build the fake object

448
00:16:39,180 --> 00:16:42,000
primitive it can then leak memory on the

449
00:16:42,000 --> 00:16:44,820
64 bit other space and here for example

450
00:16:44,820 --> 00:16:46,800
we lick some strings from the binary so

451
00:16:46,800 --> 00:16:49,380
so wait wait wait so you are within

452
00:16:49,380 --> 00:16:51,180
JavaScript you have an attack primitive

453
00:16:51,180 --> 00:16:53,339
that can leak strings from Rift in my

454
00:16:53,339 --> 00:16:55,980
binary yes from any binaries running d8

455
00:16:55,980 --> 00:16:57,959
or like Chrome or anyone

456
00:16:57,959 --> 00:17:00,540
okay that sounds dangerous

457
00:17:00,540 --> 00:17:02,759
yes so basically with this attack we are

458
00:17:02,759 --> 00:17:04,619
able to leak like remotely over the

459
00:17:04,619 --> 00:17:07,859
network 120 bits per hour so that means

460
00:17:07,859 --> 00:17:10,859
that in the like average and defaults

461
00:17:10,859 --> 00:17:12,839
like cloudflare worker run times of 30

462
00:17:12,839 --> 00:17:15,059
seconds with that leak at least like one

463
00:17:15,059 --> 00:17:17,819
bit of like v-thim data just by using

464
00:17:17,819 --> 00:17:19,859
that this particular type confusion to

465
00:17:19,859 --> 00:17:22,140
look from like the whole memory okay

466
00:17:22,140 --> 00:17:23,640
that sounds that sounds really bad it's

467
00:17:23,640 --> 00:17:25,619
a bit bad so I have to think about how

468
00:17:25,619 --> 00:17:27,540
to mitigate that maybe you stick with me

469
00:17:27,540 --> 00:17:29,340
so again you told me in the beginning

470
00:17:29,340 --> 00:17:31,020
that you have this attack worker and

471
00:17:31,020 --> 00:17:33,179
this Vector process and

472
00:17:33,179 --> 00:17:35,340
what if I what if I place some sort of

473
00:17:35,340 --> 00:17:37,919
detector in here that basically observes

474
00:17:37,919 --> 00:17:40,980
each worker of the system and if not

475
00:17:40,980 --> 00:17:42,660
somebody like you tries to make a

476
00:17:42,660 --> 00:17:45,120
transient access to a victim process I

477
00:17:45,120 --> 00:17:47,700
simply detect it and then isolate the

478
00:17:47,700 --> 00:17:50,760
attacker into its own process basically

479
00:17:50,760 --> 00:17:52,559
its own virtual address space and then I

480
00:17:52,559 --> 00:17:54,539
can use the Specter mitigations from the

481
00:17:54,539 --> 00:17:56,460
beginning

482
00:17:56,460 --> 00:17:59,520
okay that seems cool and seems like if

483
00:17:59,520 --> 00:18:01,260
you say like that it should work but I

484
00:18:01,260 --> 00:18:02,460
have so many questions in my mind like

485
00:18:02,460 --> 00:18:05,880
this is super complex for example how do

486
00:18:05,880 --> 00:18:07,860
you even observe like the stuff that

487
00:18:07,860 --> 00:18:10,740
every single Runner is doing like that's

488
00:18:10,740 --> 00:18:11,820
actually a really good question

489
00:18:11,820 --> 00:18:14,220
fortunately CPUs modern CPUs have

490
00:18:14,220 --> 00:18:15,900
something built in like it's called

491
00:18:15,900 --> 00:18:18,059
performance monitoring counters these

492
00:18:18,059 --> 00:18:20,340
are counters they are 64-bit wide which

493
00:18:20,340 --> 00:18:22,440
count micro architecture events so you

494
00:18:22,440 --> 00:18:24,000
can think of a micro head external event

495
00:18:24,000 --> 00:18:26,520
like Branch misses

496
00:18:26,520 --> 00:18:28,799
so is the branch misses like the branch

497
00:18:28,799 --> 00:18:31,559
I speculate on to like exactly so

498
00:18:31,559 --> 00:18:33,179
basically dismiss speculation where you

499
00:18:33,179 --> 00:18:34,260
have to understand this transient window

500
00:18:34,260 --> 00:18:37,080
and for instance if we take a comparison

501
00:18:37,080 --> 00:18:39,059
between a production system and an

502
00:18:39,059 --> 00:18:41,039
attack we can see that the branch misses

503
00:18:41,039 --> 00:18:43,500
are actually highly different between

504
00:18:43,500 --> 00:18:45,539
the production system and attack so you

505
00:18:45,539 --> 00:18:46,799
can clearly see on the left and the

506
00:18:46,799 --> 00:18:48,720
histogram that we can simply separate

507
00:18:48,720 --> 00:18:51,419
them by a threshold furthermore we also

508
00:18:51,419 --> 00:18:53,640
could use like Branch accesses and

509
00:18:53,640 --> 00:18:55,260
similar to Branch misses and normal

510
00:18:55,260 --> 00:18:58,500
program a normal program running would

511
00:18:58,500 --> 00:19:00,539
have much more Branch accesses than a

512
00:19:00,539 --> 00:19:03,000
techer because it's highly really small

513
00:19:03,000 --> 00:19:05,580
in its size wait but like what if I have

514
00:19:05,580 --> 00:19:07,380
like huge code base that is running like

515
00:19:07,380 --> 00:19:09,780
this book that's again a good point we

516
00:19:09,780 --> 00:19:11,880
need to normalize them by code executed

517
00:19:11,880 --> 00:19:14,820
otherwise a bigger program would for

518
00:19:14,820 --> 00:19:16,679
instance have more Branch accesses and

519
00:19:16,679 --> 00:19:18,240
more Branch misses so we need to

520
00:19:18,240 --> 00:19:20,880
normalize them okay that seems okay but

521
00:19:20,880 --> 00:19:22,919
okay I know this like performance

522
00:19:22,919 --> 00:19:24,900
monitor encounters they are super slow

523
00:19:24,900 --> 00:19:26,700
what's the overhead of like such a

524
00:19:26,700 --> 00:19:28,559
solution like yes that's actually true

525
00:19:28,559 --> 00:19:30,299
there are different interfaces you can

526
00:19:30,299 --> 00:19:31,860
use to query these performance counters

527
00:19:31,860 --> 00:19:33,299
and all of them have different

528
00:19:33,299 --> 00:19:35,039
performance implications

529
00:19:35,039 --> 00:19:36,720
um in the end we use the last one the

530
00:19:36,720 --> 00:19:38,580
rdpmc instruction that's an instruction

531
00:19:38,580 --> 00:19:40,200
you can actually use in the user space

532
00:19:40,200 --> 00:19:41,940
if the kernel is configured correctly

533
00:19:41,940 --> 00:19:44,039
and overall we l value edited on the

534
00:19:44,039 --> 00:19:45,539
cloudflare system with real production

535
00:19:45,539 --> 00:19:47,100
loads and it showed only a two percent

536
00:19:47,100 --> 00:19:49,740
performance hit it's still a hit but

537
00:19:49,740 --> 00:19:51,900
it's acceptable for the environment yeah

538
00:19:51,900 --> 00:19:54,000
that seems reasonable I would say but

539
00:19:54,000 --> 00:19:55,320
okay but

540
00:19:55,320 --> 00:19:57,900
does it work do you literally like

541
00:19:57,900 --> 00:20:00,120
detective attacks like that's that's a

542
00:20:00,120 --> 00:20:02,460
bit more complex I would say because you

543
00:20:02,460 --> 00:20:03,780
have a trade-off between the detection

544
00:20:03,780 --> 00:20:06,419
and the leakage rate okay so on the left

545
00:20:06,419 --> 00:20:08,340
we see a new an image where we see on

546
00:20:08,340 --> 00:20:11,100
the top and attacker and the left is at

547
00:20:11,100 --> 00:20:13,260
the most left sample in this Trace is

548
00:20:13,260 --> 00:20:14,580
basically the attack you showed in

549
00:20:14,580 --> 00:20:18,120
beginning with the one at 128 120 bit

550
00:20:18,120 --> 00:20:19,980
leakage per hour

551
00:20:19,980 --> 00:20:22,140
and you can see in the bottom what the

552
00:20:22,140 --> 00:20:23,640
detection does so if you use a simple

553
00:20:23,640 --> 00:20:26,100
threshold the attack is immediately

554
00:20:26,100 --> 00:20:28,380
detected since the value for the counter

555
00:20:28,380 --> 00:20:30,840
is Way Beyond the threshold yeah that

556
00:20:30,840 --> 00:20:32,760
seems really high but what if I just I

557
00:20:32,760 --> 00:20:35,700
don't know slow down my leakage rate so

558
00:20:35,700 --> 00:20:38,100
just do a lower amount of branches so

559
00:20:38,100 --> 00:20:40,440
you mean you reduce your throughput from

560
00:20:40,440 --> 00:20:41,880
the attacker's point of view to get

561
00:20:41,880 --> 00:20:43,620
below the threshold and yeah and then I

562
00:20:43,620 --> 00:20:45,419
trick the detection like yes that's

563
00:20:45,419 --> 00:20:47,039
actually what what's the graph showing

564
00:20:47,039 --> 00:20:49,140
is that how you can reduce your leakage

565
00:20:49,140 --> 00:20:51,720
rate from the 120 bit per hour to get to

566
00:20:51,720 --> 00:20:54,900
try to get below that threshold however

567
00:20:54,900 --> 00:20:56,160
um the threshold the detection actually

568
00:20:56,160 --> 00:20:58,500
works so good that if you reduce the

569
00:20:58,500 --> 00:20:59,880
leakage rate to get below the deduction

570
00:20:59,880 --> 00:21:02,220
rate the attack is invisible because you

571
00:21:02,220 --> 00:21:04,500
only have a 30 second

572
00:21:04,500 --> 00:21:06,600
um for the second execution window where

573
00:21:06,600 --> 00:21:10,260
you no longer can exploit this leakage

574
00:21:10,260 --> 00:21:12,419
so overall I have to say that this

575
00:21:12,419 --> 00:21:13,860
defense gives a strong reduction of

576
00:21:13,860 --> 00:21:15,660
leakage rate and makes these attacks

577
00:21:15,660 --> 00:21:17,340
basically infeasible

578
00:21:17,340 --> 00:21:19,260
okay that makes sense but we are still

579
00:21:19,260 --> 00:21:20,760
talking about like

580
00:21:20,760 --> 00:21:23,340
a elephant so like do you just randomly

581
00:21:23,340 --> 00:21:25,440
isolate something if there is a false

582
00:21:25,440 --> 00:21:27,840
policy like how many false positives do

583
00:21:27,840 --> 00:21:29,159
you have like qualified right yes yes

584
00:21:29,159 --> 00:21:31,380
this was also concerned so basically we

585
00:21:31,380 --> 00:21:33,960
try to evaluate this attack and defense

586
00:21:33,960 --> 00:21:37,200
more defense on the CPUs used in the

587
00:21:37,200 --> 00:21:39,240
production systems and we can see that

588
00:21:39,240 --> 00:21:40,980
based on the different counter values we

589
00:21:40,980 --> 00:21:43,140
get more or less false positives like we

590
00:21:43,140 --> 00:21:44,820
expect some programs have more cash

591
00:21:44,820 --> 00:21:46,980
accesses some have more Branch misses or

592
00:21:46,980 --> 00:21:48,659
something like that however for a

593
00:21:48,659 --> 00:21:51,720
threshold of about 40K we get a low

594
00:21:51,720 --> 00:21:54,539
Force positive rate about around

595
00:21:54,539 --> 00:21:55,559
um one percent

596
00:21:55,559 --> 00:21:57,600
so this is again acceptable since we

597
00:21:57,600 --> 00:21:59,400
don't pay for false positives it's just

598
00:21:59,400 --> 00:22:01,260
in performance impact we wrongly

599
00:22:01,260 --> 00:22:03,360
isolated them the program still works

600
00:22:03,360 --> 00:22:04,080
fine

601
00:22:04,080 --> 00:22:07,020
that's cool okay that works but okay

602
00:22:07,020 --> 00:22:09,659
we're basically saying that like you you

603
00:22:09,659 --> 00:22:12,000
know normalize about the code I execute

604
00:22:12,000 --> 00:22:16,679
that yes but what if I try like to trick

605
00:22:16,679 --> 00:22:19,440
this thresh that you have like

606
00:22:19,440 --> 00:22:22,700
for example what if I just

607
00:22:24,919 --> 00:22:27,900
increase the like denominator of your

608
00:22:27,900 --> 00:22:29,760
formula with the ideal B accesses and

609
00:22:29,760 --> 00:22:31,980
then just reduce your like your

610
00:22:31,980 --> 00:22:33,659
threshold like and then it will be low

611
00:22:33,659 --> 00:22:36,120
so let me recap that so you're trying to

612
00:22:36,120 --> 00:22:38,940
say that if we basically get the number

613
00:22:38,940 --> 00:22:41,340
of code executed up to General

614
00:22:41,340 --> 00:22:43,380
normalization then over effectively got

615
00:22:43,380 --> 00:22:45,419
below refreshold yes that's a really

616
00:22:45,419 --> 00:22:47,520
good idea um we evaluated that in native

617
00:22:47,520 --> 00:22:49,440
code as you see on the left there we

618
00:22:49,440 --> 00:22:51,419
added native code pages in between the

619
00:22:51,419 --> 00:22:54,260
attack and we can see that we see an uh

620
00:22:54,260 --> 00:22:56,820
reduction of the actual threshold Factor

621
00:22:56,820 --> 00:22:59,880
after we added around 90 pages keep in

622
00:22:59,880 --> 00:23:01,799
mind that these are native code pages

623
00:23:01,799 --> 00:23:03,900
and that's the reason why it's not

624
00:23:03,900 --> 00:23:06,000
working in JavaScript because JavaScript

625
00:23:06,000 --> 00:23:09,360
won't compile these large codes samples

626
00:23:09,360 --> 00:23:11,159
into optimized code it's just

627
00:23:11,159 --> 00:23:13,260
interpreting it so in order to your Tech

628
00:23:13,260 --> 00:23:15,659
to work it must be compiled in order to

629
00:23:15,659 --> 00:23:17,220
get this musically there's this

630
00:23:17,220 --> 00:23:19,620
speculation out of it yeah so you

631
00:23:19,620 --> 00:23:21,120
basically break the attack actually

632
00:23:21,120 --> 00:23:24,120
sense so I guess I'm solid now so let's

633
00:23:24,120 --> 00:23:26,760
build it I accept that so overall how is

634
00:23:26,760 --> 00:23:28,080
this implemented in the cloudflare

635
00:23:28,080 --> 00:23:30,480
ecosystem we can see on this build on

636
00:23:30,480 --> 00:23:32,580
this on this picture a short um

637
00:23:32,580 --> 00:23:35,039
uh systematic overview of the system we

638
00:23:35,039 --> 00:23:36,240
can see in the left side we have this

639
00:23:36,240 --> 00:23:38,100
inbound HTTP proxy which basically

640
00:23:38,100 --> 00:23:40,620
accepts HTTP requests we have done some

641
00:23:40,620 --> 00:23:42,600
scheduling and routing and these for

642
00:23:42,600 --> 00:23:44,460
eight isolates how they are called are

643
00:23:44,460 --> 00:23:46,260
basically the workers running in one

644
00:23:46,260 --> 00:23:48,960
process after the HTTP packet is

645
00:23:48,960 --> 00:23:50,940
unprocessed we pass it forward to the

646
00:23:50,940 --> 00:23:52,860
outgoing proxy and pass it to whichever

647
00:23:52,860 --> 00:23:55,140
destination the packet should go

648
00:23:55,140 --> 00:23:57,539
if you don't detect a malicious worker

649
00:23:57,539 --> 00:23:59,880
we can simply isolate that into its own

650
00:23:59,880 --> 00:24:03,240
process sandbox which is on isolate and

651
00:24:03,240 --> 00:24:05,039
communicate with an IPC connection into

652
00:24:05,039 --> 00:24:07,860
process communication and deploy these

653
00:24:07,860 --> 00:24:10,140
process isolations as they help against

654
00:24:10,140 --> 00:24:11,700
vector

655
00:24:11,700 --> 00:24:14,400
yes so overall this brings us already to

656
00:24:14,400 --> 00:24:16,860
our conclusion so we have shown you that

657
00:24:16,860 --> 00:24:18,960
remote Vector checks where possible on

658
00:24:18,960 --> 00:24:21,600
cloudflare in the cloudflare edge worker

659
00:24:21,600 --> 00:24:23,940
systems however we

660
00:24:23,940 --> 00:24:26,340
we developed a mitigation that does not

661
00:24:26,340 --> 00:24:29,340
only work against V8 against Vector V1

662
00:24:29,340 --> 00:24:31,559
as we've shown you but against all these

663
00:24:31,559 --> 00:24:32,820
Vector variants

664
00:24:32,820 --> 00:24:35,340
finally this was also a collaboration

665
00:24:35,340 --> 00:24:37,020
with cloudflare so this is actually

666
00:24:37,020 --> 00:24:39,179
deployed in a production system and it

667
00:24:39,179 --> 00:24:42,240
resulted in a scientific paper and the

668
00:24:42,240 --> 00:24:44,360
QR code is actually linking to the paper

669
00:24:44,360 --> 00:24:46,620
yeah it works

670
00:24:46,620 --> 00:24:49,860
yeah so thank you everyone and if you

671
00:24:49,860 --> 00:24:51,659
have any question we will be happy to

672
00:24:51,659 --> 00:24:54,020
take them

673
00:25:01,610 --> 00:25:04,689
[Music]

