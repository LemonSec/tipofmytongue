1
00:00:01,740 --> 00:00:04,810
[Music]

2
00:00:08,160 --> 00:00:09,920
hello uh

3
00:00:09,920 --> 00:00:12,559
today i'm going to talk about zooming

4
00:00:12,559 --> 00:00:17,480
zero to attack zero knowledge proof

5
00:00:18,240 --> 00:00:20,480
so you know a lot of people come to the

6
00:00:20,480 --> 00:00:22,560
zero knowledge proof talk and then you

7
00:00:22,560 --> 00:00:25,359
know after the talk you learn zero

8
00:00:25,359 --> 00:00:29,199
they don't know anything about um

9
00:00:29,199 --> 00:00:32,800
what the speaker was talking about

10
00:00:32,800 --> 00:00:36,079
so so so my goal is pretty simple

11
00:00:36,079 --> 00:00:37,440
um

12
00:00:37,440 --> 00:00:38,960
you know like after the talk you will

13
00:00:38,960 --> 00:00:41,040
learn non-zero knowledge

14
00:00:41,040 --> 00:00:44,640
and the second goal was to have some fun

15
00:00:44,640 --> 00:00:47,840
with the number zero

16
00:00:48,079 --> 00:00:50,079
so you know like in the last few years

17
00:00:50,079 --> 00:00:50,960
uh

18
00:00:50,960 --> 00:00:53,760
there are a lot of algorithms in general

19
00:00:53,760 --> 00:00:56,559
knowledge proof and they are deployed in

20
00:00:56,559 --> 00:00:57,760
multiple

21
00:00:57,760 --> 00:00:59,280
blockchains

22
00:00:59,280 --> 00:01:03,600
and uh that development was so fast that

23
00:01:03,600 --> 00:01:05,840
they used a lot of technologies

24
00:01:05,840 --> 00:01:08,640
that you know like just just to explain

25
00:01:08,640 --> 00:01:12,640
the basic tech a semester

26
00:01:12,640 --> 00:01:15,119
so that's the reason why

27
00:01:15,119 --> 00:01:18,640
i in this talk i just try to to give you

28
00:01:18,640 --> 00:01:19,600
very

29
00:01:19,600 --> 00:01:21,600
informal

30
00:01:21,600 --> 00:01:22,799
techniques

31
00:01:22,799 --> 00:01:25,119
and ideas so that you can learn about

32
00:01:25,119 --> 00:01:27,920
their knowledge proof yourself

33
00:01:27,920 --> 00:01:29,200
later

34
00:01:29,200 --> 00:01:30,720
um so

35
00:01:30,720 --> 00:01:33,119
you know but um

36
00:01:33,119 --> 00:01:35,680
but i hope that you you uh

37
00:01:35,680 --> 00:01:37,439
you can see you know some basic and

38
00:01:37,439 --> 00:01:38,960
fundamental

39
00:01:38,960 --> 00:01:42,479
um fundamental idea in zero knowledge

40
00:01:42,479 --> 00:01:44,798
proof

41
00:01:48,399 --> 00:01:49,200
okay

42
00:01:49,200 --> 00:01:51,520
so and then i will talk about like how

43
00:01:51,520 --> 00:01:53,920
the theories

44
00:01:53,920 --> 00:01:57,360
guide attack directions and later on uh

45
00:01:57,360 --> 00:02:00,159
i i will explain like why the attack

46
00:02:00,159 --> 00:02:03,600
work in practice

47
00:02:03,600 --> 00:02:04,479
okay

48
00:02:04,479 --> 00:02:07,119
so so i i will have to explain to you a

49
00:02:07,119 --> 00:02:08,560
lot of

50
00:02:08,560 --> 00:02:11,280
a lot of you know basic concept

51
00:02:11,280 --> 00:02:15,360
and so i will go pretty fast but the the

52
00:02:15,360 --> 00:02:18,239
the main thing is we will not try to

53
00:02:18,239 --> 00:02:20,560
understand in depth instead we are

54
00:02:20,560 --> 00:02:22,480
trying to understand the intuition

55
00:02:22,480 --> 00:02:25,360
between different concepts so that you

56
00:02:25,360 --> 00:02:27,200
know when we read complicated and

57
00:02:27,200 --> 00:02:29,599
complex paper we have a better idea

58
00:02:29,599 --> 00:02:32,239
what's going on because you know network

59
00:02:32,239 --> 00:02:35,200
is super super complicated so for a lift

60
00:02:35,200 --> 00:02:36,800
curve if you

61
00:02:36,800 --> 00:02:39,280
you never

62
00:02:39,280 --> 00:02:41,040
deal with elliptical before the

63
00:02:41,040 --> 00:02:43,120
elliptical is just the blue line and

64
00:02:43,120 --> 00:02:45,680
then uh in elliptic curve there

65
00:02:45,680 --> 00:02:47,760
it's very amazing that the addition

66
00:02:47,760 --> 00:02:50,080
operation is defined between two points

67
00:02:50,080 --> 00:02:52,400
basically you when you you have two

68
00:02:52,400 --> 00:02:55,519
points p and q you can add them together

69
00:02:55,519 --> 00:02:56,319
so

70
00:02:56,319 --> 00:02:58,959
the red line p and q cut the blue line

71
00:02:58,959 --> 00:03:01,200
at the point r prime and then its

72
00:03:01,200 --> 00:03:05,120
symmetry is the sum of p and q

73
00:03:05,120 --> 00:03:07,599
you know and we we don't actually need

74
00:03:07,599 --> 00:03:10,560
to understand how the addition work what

75
00:03:10,560 --> 00:03:14,319
we actually can is the the the points in

76
00:03:14,319 --> 00:03:17,120
elliptic curve forms a group what it

77
00:03:17,120 --> 00:03:19,280
means is the addition operation is

78
00:03:19,280 --> 00:03:22,000
defined and it has a zero point

79
00:03:22,000 --> 00:03:24,080
when you add a zero point to any point

80
00:03:24,080 --> 00:03:26,800
you get back the original point

81
00:03:26,800 --> 00:03:31,959
and in our elliptic curve we will

82
00:03:33,280 --> 00:03:36,000
excuse me

83
00:03:36,959 --> 00:03:39,360
in our electric curve uh we were to

84
00:03:39,360 --> 00:03:42,480
basically choose uh to a base pawn that

85
00:03:42,480 --> 00:03:45,440
a fixed pawn that is defined in advance

86
00:03:45,440 --> 00:03:47,680
and everyone know what what it is

87
00:03:47,680 --> 00:03:50,400
and if you add that pawn q time then you

88
00:03:50,400 --> 00:03:53,519
get back zero so q is called the order

89
00:03:53,519 --> 00:03:54,959
of the point

90
00:03:54,959 --> 00:03:56,000
okay

91
00:03:56,000 --> 00:03:59,519
so one very special property of uh zero

92
00:03:59,519 --> 00:04:01,760
point is whenever you multiply that

93
00:04:01,760 --> 00:04:04,799
point with any point then you get back

94
00:04:04,799 --> 00:04:08,159
zero and then we'll use this property in

95
00:04:08,159 --> 00:04:11,040
in our attack

96
00:04:11,680 --> 00:04:14,720
next we will talk about pairing

97
00:04:14,720 --> 00:04:17,839
you know pairing has a lot of you know

98
00:04:17,839 --> 00:04:20,798
deep math and we for the purpose of this

99
00:04:20,798 --> 00:04:23,919
talk we don't really care like how uh

100
00:04:23,919 --> 00:04:25,919
pairing computation work

101
00:04:25,919 --> 00:04:27,759
and the formal definition

102
00:04:27,759 --> 00:04:30,800
what we care is you know like it maps uh

103
00:04:30,800 --> 00:04:33,759
two points on a curve to to a finite

104
00:04:33,759 --> 00:04:35,840
field or to a number

105
00:04:35,840 --> 00:04:38,639
and it can map two points on two

106
00:04:38,639 --> 00:04:42,080
different curve two number as well you

107
00:04:42,080 --> 00:04:44,560
know one one trick that i learned how to

108
00:04:44,560 --> 00:04:45,680
deal with

109
00:04:45,680 --> 00:04:48,560
complicated math is to not to learn it

110
00:04:48,560 --> 00:04:51,120
instead we just learn its property and

111
00:04:51,120 --> 00:04:53,199
this property is pretty simple it has

112
00:04:53,199 --> 00:04:56,320
very nice property so if the pairing of

113
00:04:56,320 --> 00:04:58,400
p plus q with r

114
00:04:58,400 --> 00:05:01,120
is the product of p and r

115
00:05:01,120 --> 00:05:02,960
and q and r right

116
00:05:02,960 --> 00:05:07,120
and uh the pairing of a ap and bq equals

117
00:05:07,120 --> 00:05:09,520
to the pairing of p and q

118
00:05:09,520 --> 00:05:10,639
uh two

119
00:05:10,639 --> 00:05:15,120
to two to the power of uh a times b

120
00:05:15,120 --> 00:05:16,400
so

121
00:05:16,400 --> 00:05:19,039
if you look at the top line what you see

122
00:05:19,039 --> 00:05:21,440
is we can basically move the coefficient

123
00:05:21,440 --> 00:05:24,400
a b around when we can move it to the

124
00:05:24,400 --> 00:05:27,360
exponent we can move it to the first

125
00:05:27,360 --> 00:05:30,400
component or we can move it uh splitted

126
00:05:30,400 --> 00:05:32,560
them in two different ways

127
00:05:32,560 --> 00:05:35,199
so one nice property about pairing that

128
00:05:35,199 --> 00:05:37,759
we actually use in the in the prong

129
00:05:37,759 --> 00:05:38,880
broker

130
00:05:38,880 --> 00:05:41,600
is it helps checking multiplication

131
00:05:41,600 --> 00:05:43,680
relations and then we'll come back to

132
00:05:43,680 --> 00:05:45,039
that later

133
00:05:45,039 --> 00:05:47,360
uh before moving on one very special

134
00:05:47,360 --> 00:05:50,160
property of pairing is when you pair

135
00:05:50,160 --> 00:05:53,199
zero points with any point you get back

136
00:05:53,199 --> 00:05:54,160
one

137
00:05:54,160 --> 00:05:57,840
and and we will use this observation uh

138
00:05:57,840 --> 00:05:58,880
again

139
00:05:58,880 --> 00:06:02,400
in in the attack section

140
00:06:03,759 --> 00:06:07,120
um you know like now i will introduce a

141
00:06:07,120 --> 00:06:08,960
little bit more about zero knowledge

142
00:06:08,960 --> 00:06:11,120
proof so it's general knowledge proof

143
00:06:11,120 --> 00:06:14,000
has a lot of terminal terminologies

144
00:06:14,000 --> 00:06:16,160
maybe jargon as well

145
00:06:16,160 --> 00:06:18,720
and and to explain them that they're

146
00:06:18,720 --> 00:06:20,560
basically two ways to explain them one

147
00:06:20,560 --> 00:06:22,960
is you start with some definition

148
00:06:22,960 --> 00:06:24,639
formal definitions

149
00:06:24,639 --> 00:06:27,520
and and and then try to give some you

150
00:06:27,520 --> 00:06:30,800
know examples i i would prefer going

151
00:06:30,800 --> 00:06:33,600
from the concrete example first try to

152
00:06:33,600 --> 00:06:35,840
see like what's going on understand the

153
00:06:35,840 --> 00:06:38,880
core and basic protocol and then

154
00:06:38,880 --> 00:06:40,880
and then use that as framework to

155
00:06:40,880 --> 00:06:43,520
understand the general definitions and

156
00:06:43,520 --> 00:06:45,120
how things work

157
00:06:45,120 --> 00:06:46,479
so

158
00:06:46,479 --> 00:06:48,639
so let's start with with very simple

159
00:06:48,639 --> 00:06:51,759
protocol it's called snow protocol um

160
00:06:51,759 --> 00:06:52,720
this this

161
00:06:52,720 --> 00:06:54,960
it plays a very important role in snarl

162
00:06:54,960 --> 00:06:59,120
signature and with digital signature

163
00:06:59,120 --> 00:07:03,199
so so so it's very really important and

164
00:07:03,199 --> 00:07:06,479
it it serves the basic for many little

165
00:07:06,479 --> 00:07:07,759
protocols

166
00:07:07,759 --> 00:07:10,639
uh so this is the problem right the

167
00:07:10,639 --> 00:07:12,080
approver

168
00:07:12,080 --> 00:07:14,160
and the verifier talks with each other

169
00:07:14,160 --> 00:07:17,440
the approval has the private key smart w

170
00:07:17,440 --> 00:07:19,830
and it has a public key

171
00:07:19,830 --> 00:07:20,960
[Music]

172
00:07:20,960 --> 00:07:22,000
a big

173
00:07:22,000 --> 00:07:23,120
w

174
00:07:23,120 --> 00:07:25,759
and the approval wants to

175
00:07:25,759 --> 00:07:28,479
to convince the verifier that it knows

176
00:07:28,479 --> 00:07:30,720
the private key without revealing any

177
00:07:30,720 --> 00:07:32,400
information about

178
00:07:32,400 --> 00:07:35,120
the private key right it sounds very

179
00:07:35,120 --> 00:07:38,400
amazing right you convince someone

180
00:07:38,400 --> 00:07:40,800
that you know something without actually

181
00:07:40,800 --> 00:07:43,280
revealing it right and

182
00:07:43,280 --> 00:07:45,520
and and this that kind of like the magic

183
00:07:45,520 --> 00:07:48,000
of uh zero knowledge proof

184
00:07:48,000 --> 00:07:50,000
and in this protocol

185
00:07:50,000 --> 00:07:50,800
uh

186
00:07:50,800 --> 00:07:53,280
it basically consists of three steps

187
00:07:53,280 --> 00:07:55,759
and the first one is the the approvals

188
00:07:55,759 --> 00:07:58,720
generate a random are a small r

189
00:07:58,720 --> 00:07:59,520
and

190
00:07:59,520 --> 00:08:02,560
and and it will send r time g to the

191
00:08:02,560 --> 00:08:05,520
verifier the val the verifier will

192
00:08:05,520 --> 00:08:07,280
generate a random c

193
00:08:07,280 --> 00:08:09,120
and then it will

194
00:08:09,120 --> 00:08:11,120
it will send it to the approver

195
00:08:11,120 --> 00:08:14,400
the approval compute z equals to r plus

196
00:08:14,400 --> 00:08:19,199
c time w and then z to the verifier okay

197
00:08:19,199 --> 00:08:20,639
um

198
00:08:20,639 --> 00:08:23,440
before moving on one note is you know my

199
00:08:23,440 --> 00:08:24,560
goal

200
00:08:24,560 --> 00:08:26,879
is you know to uh

201
00:08:26,879 --> 00:08:29,520
to talk about a basic and because this

202
00:08:29,520 --> 00:08:32,000
talk is kind of like math heavy so if

203
00:08:32,000 --> 00:08:33,440
you can understand

204
00:08:33,440 --> 00:08:36,080
around like 25 of the talk in the first

205
00:08:36,080 --> 00:08:39,679
time that's already a success so

206
00:08:39,679 --> 00:08:42,000
the slide will be uploaded

207
00:08:42,000 --> 00:08:44,159
so that you can watch it later

208
00:08:44,159 --> 00:08:45,200
um

209
00:08:45,200 --> 00:08:47,440
so so you know the verifier checks some

210
00:08:47,440 --> 00:08:50,320
equation right z times g equals to r

211
00:08:50,320 --> 00:08:52,959
plus c times w

212
00:08:52,959 --> 00:08:56,399
and and you know if you try it now uh if

213
00:08:56,399 --> 00:08:58,399
the approval and the verifier are honest

214
00:08:58,399 --> 00:09:01,040
then you know the equation is satisfied

215
00:09:01,040 --> 00:09:04,080
there's nothing special about this

216
00:09:04,080 --> 00:09:06,560
the the the special

217
00:09:06,560 --> 00:09:07,360
thing

218
00:09:07,360 --> 00:09:09,680
happens somewhere else so the first

219
00:09:09,680 --> 00:09:11,600
thing first you know

220
00:09:11,600 --> 00:09:13,920
um

221
00:09:13,920 --> 00:09:16,320
why does the prover

222
00:09:16,320 --> 00:09:18,959
does it leak anything about the private

223
00:09:18,959 --> 00:09:21,600
key uh w right

224
00:09:21,600 --> 00:09:24,320
so so this this um

225
00:09:24,320 --> 00:09:26,880
this protocol use a very common trick in

226
00:09:26,880 --> 00:09:28,480
zero knowledge proof

227
00:09:28,480 --> 00:09:30,720
basically it is it do the masking

228
00:09:30,720 --> 00:09:33,519
technique uh it's very simple right to

229
00:09:33,519 --> 00:09:35,120
to hide a number

230
00:09:35,120 --> 00:09:37,920
you just generate another number random

231
00:09:37,920 --> 00:09:40,080
another number and add them together and

232
00:09:40,080 --> 00:09:42,240
yes you send the addition you send the

233
00:09:42,240 --> 00:09:43,279
sum

234
00:09:43,279 --> 00:09:45,760
right so in this case

235
00:09:45,760 --> 00:09:49,760
because c times w is

236
00:09:49,760 --> 00:09:52,800
is related to private key right so the

237
00:09:52,800 --> 00:09:55,360
the approval want to hide that value so

238
00:09:55,360 --> 00:09:58,160
it re it generate a random number r

239
00:09:58,160 --> 00:10:00,480
so because r is random

240
00:10:00,480 --> 00:10:03,680
no matter what c times w is the sum is

241
00:10:03,680 --> 00:10:05,920
random so that's why you see like in the

242
00:10:05,920 --> 00:10:08,480
first step generate a random

243
00:10:08,480 --> 00:10:11,600
it goes to mass out

244
00:10:11,600 --> 00:10:13,680
what c times w

245
00:10:13,680 --> 00:10:16,880
so basically this protocol you know like

246
00:10:16,880 --> 00:10:19,120
doesn't leak any information about the

247
00:10:19,120 --> 00:10:21,839
private kw

248
00:10:21,839 --> 00:10:24,000
uh the hard part is

249
00:10:24,000 --> 00:10:26,959
how is the verified verifier convinced

250
00:10:26,959 --> 00:10:29,839
that the the proven knows w

251
00:10:29,839 --> 00:10:32,079
and this is this is this is one of the

252
00:10:32,079 --> 00:10:35,440
most uh confusing definition

253
00:10:35,440 --> 00:10:36,160
in

254
00:10:36,160 --> 00:10:38,640
in zero knowledge proof the f if it's

255
00:10:38,640 --> 00:10:40,720
the first time you deal with it

256
00:10:40,720 --> 00:10:41,680
uh

257
00:10:41,680 --> 00:10:44,240
you will see that oh it is very strange

258
00:10:44,240 --> 00:10:46,320
so so i will goes a little bit slow on

259
00:10:46,320 --> 00:10:49,360
this so think about approval is a is a

260
00:10:49,360 --> 00:10:52,000
process in the computer right

261
00:10:52,000 --> 00:10:54,880
so if if the verifier communicate and

262
00:10:54,880 --> 00:10:56,959
interact with approval

263
00:10:56,959 --> 00:11:00,240
and process and somehow you know by you

264
00:11:00,240 --> 00:11:03,680
know torturing the approver or assets to

265
00:11:03,680 --> 00:11:07,279
uh do random stuff or you know clone it

266
00:11:07,279 --> 00:11:08,640
whatever

267
00:11:08,640 --> 00:11:11,120
as long as in the end the verifier can

268
00:11:11,120 --> 00:11:12,560
extract the private key then the

269
00:11:12,560 --> 00:11:14,480
verifier

270
00:11:14,480 --> 00:11:16,320
is convinced that approval must have

271
00:11:16,320 --> 00:11:17,200
known

272
00:11:17,200 --> 00:11:19,920
the private key right otherwise where

273
00:11:19,920 --> 00:11:22,480
does the private key come from so if the

274
00:11:22,480 --> 00:11:24,880
prover doesn't know the private key then

275
00:11:24,880 --> 00:11:27,120
no matter what the verifier does it can

276
00:11:27,120 --> 00:11:28,560
extract the private key right because it

277
00:11:28,560 --> 00:11:32,160
doesn't exist in the approval process

278
00:11:32,160 --> 00:11:34,000
so the

279
00:11:34,000 --> 00:11:35,600
in in

280
00:11:35,600 --> 00:11:38,640
in practice or in reality what they do

281
00:11:38,640 --> 00:11:41,440
is they they ask the approver

282
00:11:41,440 --> 00:11:42,480
to keep

283
00:11:42,480 --> 00:11:46,000
to keep the random r unchanged and then

284
00:11:46,000 --> 00:11:47,839
the verify will send two different

285
00:11:47,839 --> 00:11:49,839
values c and c prime

286
00:11:49,839 --> 00:11:52,160
and then the the the approval will do

287
00:11:52,160 --> 00:11:54,240
the same thing you know compute z equal

288
00:11:54,240 --> 00:11:55,760
to r plus

289
00:11:55,760 --> 00:11:57,279
w c

290
00:11:57,279 --> 00:12:02,079
and z prime equal to r plus w c prime

291
00:12:02,079 --> 00:12:04,480
and if you write down the equations and

292
00:12:04,480 --> 00:12:06,720
then you can see that it's very easy to

293
00:12:06,720 --> 00:12:09,760
compute w it's actually equal to z minus

294
00:12:09,760 --> 00:12:13,120
z prime z prime divided by c minus c

295
00:12:13,120 --> 00:12:13,920
prime

296
00:12:13,920 --> 00:12:14,880
so

297
00:12:14,880 --> 00:12:17,920
it means that there is a way for the

298
00:12:17,920 --> 00:12:19,839
verify extract

299
00:12:19,839 --> 00:12:22,480
the approval by interacting with it

300
00:12:22,480 --> 00:12:25,600
right so now the verifier is convinced

301
00:12:25,600 --> 00:12:28,160
that the approval actually know uh the

302
00:12:28,160 --> 00:12:30,399
private key

303
00:12:30,399 --> 00:12:31,279
okay

304
00:12:31,279 --> 00:12:33,200
so you know the protocol

305
00:12:33,200 --> 00:12:35,920
that i described is

306
00:12:35,920 --> 00:12:38,079
interactive right but in practice you

307
00:12:38,079 --> 00:12:40,240
know interactive protocol has a few

308
00:12:40,240 --> 00:12:42,560
drawbacks first of all it requires the

309
00:12:42,560 --> 00:12:44,240
approval and the verifier to be

310
00:12:44,240 --> 00:12:47,200
synchronized and second or second you

311
00:12:47,200 --> 00:12:48,639
know

312
00:12:48,639 --> 00:12:51,920
it only happens with one prover and one

313
00:12:51,920 --> 00:12:55,040
verifier in practice you want to create

314
00:12:55,040 --> 00:12:56,480
a proof

315
00:12:56,480 --> 00:13:00,320
and then multiple verifier will verify

316
00:13:00,320 --> 00:13:03,120
later at any time they want

317
00:13:03,120 --> 00:13:04,720
so

318
00:13:04,720 --> 00:13:07,279
so what we actually want is a

319
00:13:07,279 --> 00:13:09,760
non-interactive protocol

320
00:13:09,760 --> 00:13:13,040
uh but how do how do we transform from a

321
00:13:13,040 --> 00:13:15,839
interactive one to a non-interactive

322
00:13:15,839 --> 00:13:17,040
protocol

323
00:13:17,040 --> 00:13:18,160
and

324
00:13:18,160 --> 00:13:20,639
the the procedure that helps us

325
00:13:20,639 --> 00:13:23,120
achieving that goal is called fiat

326
00:13:23,120 --> 00:13:25,680
chemical transform and you will hear

327
00:13:25,680 --> 00:13:29,519
this word a lot like in any protocol

328
00:13:29,519 --> 00:13:31,120
in zero knowledge proof you will hear

329
00:13:31,120 --> 00:13:33,440
the word okay let's use fiasco mere

330
00:13:33,440 --> 00:13:36,560
transform what it means is just

331
00:13:36,560 --> 00:13:40,720
uh a known procedure to transform

332
00:13:40,720 --> 00:13:43,519
an interactive protocol to a

333
00:13:43,519 --> 00:13:45,120
non-interactive one

334
00:13:45,120 --> 00:13:47,760
and it's actually pretty simple so

335
00:13:47,760 --> 00:13:51,680
instead of the verifier send the random

336
00:13:51,680 --> 00:13:53,920
c to the approver the proverb just

337
00:13:53,920 --> 00:13:57,279
compute c it's itself using hash

338
00:13:57,279 --> 00:13:59,639
function it has

339
00:13:59,639 --> 00:14:01,360
everything

340
00:14:01,360 --> 00:14:03,279
in the public domain

341
00:14:03,279 --> 00:14:05,920
and everything in the public

342
00:14:05,920 --> 00:14:08,000
communication with between the approver

343
00:14:08,000 --> 00:14:10,800
and the verifier

344
00:14:10,800 --> 00:14:15,040
and the hash function has some property

345
00:14:15,040 --> 00:14:17,279
that you know allows us

346
00:14:17,279 --> 00:14:18,240
uh

347
00:14:18,240 --> 00:14:19,839
the approval so that the approval cannot

348
00:14:19,839 --> 00:14:22,000
control c because if the proof will

349
00:14:22,000 --> 00:14:24,560
change the input then the proof can't

350
00:14:24,560 --> 00:14:26,720
control the output

351
00:14:26,720 --> 00:14:29,120
so basically if the approval can't

352
00:14:29,120 --> 00:14:31,279
control the input and the output at the

353
00:14:31,279 --> 00:14:33,760
same time and you know that property is

354
00:14:33,760 --> 00:14:34,880
kind

355
00:14:34,880 --> 00:14:37,120
called random oracle model we're not

356
00:14:37,120 --> 00:14:40,320
going to discuss this but

357
00:14:40,320 --> 00:14:43,279
what we've learned is okay we can

358
00:14:43,279 --> 00:14:44,880
compute the hash

359
00:14:44,880 --> 00:14:48,240
of the transcript basically the public

360
00:14:48,240 --> 00:14:50,399
input of everything

361
00:14:50,399 --> 00:14:52,320
and then that it will be the challenge

362
00:14:52,320 --> 00:14:54,800
from the verifier to the approval

363
00:14:54,800 --> 00:14:57,360
and it's called yesterday transform

364
00:14:57,360 --> 00:15:00,160
okay so now we learn a concrete protocol

365
00:15:00,160 --> 00:15:01,920
now i will show you

366
00:15:01,920 --> 00:15:05,120
uh the general terminology that you will

367
00:15:05,120 --> 00:15:07,519
that hopefully you will understand more

368
00:15:07,519 --> 00:15:08,959
when you read

369
00:15:08,959 --> 00:15:11,440
papers in zero knowledge proof

370
00:15:11,440 --> 00:15:14,079
so in cryptography instead of using the

371
00:15:14,079 --> 00:15:17,040
word proof we use the word argument

372
00:15:17,040 --> 00:15:19,360
so argument just mean that you know the

373
00:15:19,360 --> 00:15:21,120
protocol is secure based on

374
00:15:21,120 --> 00:15:22,800
computational assumption for instance

375
00:15:22,800 --> 00:15:26,079
the hardness of the street log problem

376
00:15:26,079 --> 00:15:27,839
and

377
00:15:27,839 --> 00:15:30,480
in general

378
00:15:31,600 --> 00:15:33,120
the approval wants to convey the

379
00:15:33,120 --> 00:15:35,920
verifier that certain statement is true

380
00:15:35,920 --> 00:15:38,000
for instance f of

381
00:15:38,000 --> 00:15:39,760
x

382
00:15:39,760 --> 00:15:43,120
and w equals to y where x is the public

383
00:15:43,120 --> 00:15:44,160
input

384
00:15:44,160 --> 00:15:47,519
w is the private input or the witness

385
00:15:47,519 --> 00:15:50,399
and y is the supposed

386
00:15:50,399 --> 00:15:51,440
public

387
00:15:51,440 --> 00:15:52,959
output

388
00:15:52,959 --> 00:15:55,600
in our protocol you know we have x is

389
00:15:55,600 --> 00:15:56,560
empty

390
00:15:56,560 --> 00:15:58,160
and w

391
00:15:58,160 --> 00:16:02,320
is w and the function f of x and w

392
00:16:02,320 --> 00:16:05,199
is equal to w times g

393
00:16:05,199 --> 00:16:07,360
and the proof is just

394
00:16:07,360 --> 00:16:10,079
r and z

395
00:16:11,839 --> 00:16:12,959
okay

396
00:16:12,959 --> 00:16:15,600
so so if the approval convince the

397
00:16:15,600 --> 00:16:18,079
verifier that it knows w then we say

398
00:16:18,079 --> 00:16:20,880
that is an argument of knowledge

399
00:16:20,880 --> 00:16:23,279
i i'm just saying the same thing but in

400
00:16:23,279 --> 00:16:26,079
in more general terms okay so

401
00:16:26,079 --> 00:16:28,880
and if the verifier only learns that the

402
00:16:28,880 --> 00:16:30,720
statement is correct without learning

403
00:16:30,720 --> 00:16:32,880
any information about the witness then

404
00:16:32,880 --> 00:16:35,519
we call it zero knowledge okay

405
00:16:35,519 --> 00:16:37,199
and uh

406
00:16:37,199 --> 00:16:39,519
there there will be more a few more

407
00:16:39,519 --> 00:16:41,720
terminology not stand for

408
00:16:41,720 --> 00:16:44,880
non-interactive argument of knowledge

409
00:16:44,880 --> 00:16:47,440
and snark is succinct

410
00:16:47,440 --> 00:16:48,480
not

411
00:16:48,480 --> 00:16:51,040
it is exactly the same it's not but it's

412
00:16:51,040 --> 00:16:53,040
the proof is short and sometimes there's

413
00:16:53,040 --> 00:16:55,600
some requirement for the verifier to to

414
00:16:55,600 --> 00:16:56,720
be fast

415
00:16:56,720 --> 00:17:00,880
and zika snark is their knowledge stock

416
00:17:01,360 --> 00:17:04,000
now we will talk about a snack software

417
00:17:04,000 --> 00:17:05,039
system

418
00:17:05,039 --> 00:17:06,880
you know like for nowadays zero

419
00:17:06,880 --> 00:17:09,039
knowledge proof can uh can prove

420
00:17:09,039 --> 00:17:11,679
arbitrary computations so it's not just

421
00:17:11,679 --> 00:17:14,720
you know concrete statement like uh

422
00:17:14,720 --> 00:17:16,839
like small protocol it can prove

423
00:17:16,839 --> 00:17:18,959
arbitrary statement

424
00:17:18,959 --> 00:17:21,039
so it's fairly complicated it's called

425
00:17:21,039 --> 00:17:23,839
it consists of multiple systems so you

426
00:17:23,839 --> 00:17:25,520
can write zero knowledge proof in a

427
00:17:25,520 --> 00:17:27,919
high-level programming language and then

428
00:17:27,919 --> 00:17:29,760
there will be a compiler that compiles

429
00:17:29,760 --> 00:17:32,080
this arithmetic circuit and then there's

430
00:17:32,080 --> 00:17:34,960
some transformation to polynomial and

431
00:17:34,960 --> 00:17:37,200
then the snark

432
00:17:37,200 --> 00:17:39,760
or zika scenario will work on polynomial

433
00:17:39,760 --> 00:17:41,039
equations

434
00:17:41,039 --> 00:17:42,160
so

435
00:17:42,160 --> 00:17:43,520
you're not supposed to understand

436
00:17:43,520 --> 00:17:46,799
anything on this line the only important

437
00:17:46,799 --> 00:17:49,919
thing that that you should remember

438
00:17:49,919 --> 00:17:52,160
in this slide is

439
00:17:52,160 --> 00:17:53,520
it first

440
00:17:53,520 --> 00:17:56,720
transforms to polynomials and polynomial

441
00:17:56,720 --> 00:18:00,000
is is the most important thing in the

442
00:18:00,000 --> 00:18:01,919
modern technology of zero knowledge

443
00:18:01,919 --> 00:18:02,799
proof

444
00:18:02,799 --> 00:18:04,960
in basically every single zero knowledge

445
00:18:04,960 --> 00:18:07,679
proof you have to deal with polynomials

446
00:18:07,679 --> 00:18:09,919
and it's it's

447
00:18:09,919 --> 00:18:12,880
the solution to all things is also

448
00:18:12,880 --> 00:18:14,960
polynomials you deal with it all the

449
00:18:14,960 --> 00:18:18,160
time and it's very amazing like why such

450
00:18:18,160 --> 00:18:20,559
a simple thing like polynomial is such

451
00:18:20,559 --> 00:18:21,760
powerful

452
00:18:21,760 --> 00:18:24,799
that it helps solve all kinds of issues

453
00:18:24,799 --> 00:18:27,840
in zero knowledge proof

454
00:18:27,840 --> 00:18:29,440
i will talk briefly about circuit a

455
00:18:29,440 --> 00:18:31,919
little bit so so that it will help you

456
00:18:31,919 --> 00:18:32,960
um

457
00:18:32,960 --> 00:18:35,520
understand the paper uh when you read it

458
00:18:35,520 --> 00:18:36,640
yourself

459
00:18:36,640 --> 00:18:38,720
so basically you know like the circuit

460
00:18:38,720 --> 00:18:39,360
is

461
00:18:39,360 --> 00:18:42,880
in our case we have only the two

462
00:18:42,880 --> 00:18:44,400
two gate two kind of gates the

463
00:18:44,400 --> 00:18:46,559
multiplication and addition

464
00:18:46,559 --> 00:18:49,440
so basically if uh you know like

465
00:18:49,440 --> 00:18:52,400
multiplication and addition is enough to

466
00:18:52,400 --> 00:18:53,120
to

467
00:18:53,120 --> 00:18:56,400
for arbitra is to complete it means that

468
00:18:56,400 --> 00:18:58,880
you can do all kind of

469
00:18:58,880 --> 00:19:02,080
operation just using uh addition and

470
00:19:02,080 --> 00:19:03,840
multiplications

471
00:19:03,840 --> 00:19:05,760
so um

472
00:19:05,760 --> 00:19:08,400
the multiplication is called gate it has

473
00:19:08,400 --> 00:19:11,120
two input the left input the right input

474
00:19:11,120 --> 00:19:13,200
and then it has an output right

475
00:19:13,200 --> 00:19:15,760
and it's a constant you can write it

476
00:19:15,760 --> 00:19:19,039
okay the the output equals to the

477
00:19:19,039 --> 00:19:20,720
the left uh

478
00:19:20,720 --> 00:19:22,400
multiplied

479
00:19:22,400 --> 00:19:23,679
by the right

480
00:19:23,679 --> 00:19:26,000
and and that's that's a constraint

481
00:19:26,000 --> 00:19:27,360
um

482
00:19:27,360 --> 00:19:30,080
but if you pay attention there

483
00:19:30,080 --> 00:19:32,160
if you look at the the figure on the

484
00:19:32,160 --> 00:19:35,360
left hand side you can see that the

485
00:19:35,360 --> 00:19:36,160
the

486
00:19:36,160 --> 00:19:38,480
the left input of the multiplication

487
00:19:38,480 --> 00:19:41,760
gate equals to the left input of the

488
00:19:41,760 --> 00:19:43,679
addition gate right

489
00:19:43,679 --> 00:19:46,559
so and this is called a copy constraint

490
00:19:46,559 --> 00:19:48,400
is a different kind of constraint that

491
00:19:48,400 --> 00:19:51,760
we have to enforce using polynomial

492
00:19:51,760 --> 00:19:53,760
all right

493
00:19:53,760 --> 00:19:56,400
so we we've learned i hope that

494
00:19:56,400 --> 00:19:58,000
[Applause]

495
00:19:58,000 --> 00:19:59,919
you will remember that polynomial is the

496
00:19:59,919 --> 00:20:01,760
most important thing in general

497
00:20:01,760 --> 00:20:04,080
knowledge proof so now i will tell you a

498
00:20:04,080 --> 00:20:07,280
few a few terminology and few polynomial

499
00:20:07,280 --> 00:20:09,760
tricks uh that will help you read all

500
00:20:09,760 --> 00:20:11,440
the papers as well

501
00:20:11,440 --> 00:20:13,520
so

502
00:20:13,520 --> 00:20:15,600
let's talk about polymer polynomial

503
00:20:15,600 --> 00:20:18,240
commitment assuming that you have some

504
00:20:18,240 --> 00:20:21,520
polynomial ppmx

505
00:20:21,520 --> 00:20:23,760
so in many uh

506
00:20:23,760 --> 00:20:26,080
zkp or snark

507
00:20:26,080 --> 00:20:28,559
uh it the protocol often consists of a

508
00:20:28,559 --> 00:20:30,799
few phases the first phase is often

509
00:20:30,799 --> 00:20:32,000
commitment

510
00:20:32,000 --> 00:20:34,159
basically commit just mean that you know

511
00:20:34,159 --> 00:20:36,159
like you have some value

512
00:20:36,159 --> 00:20:39,360
uh you commit to it so that later on you

513
00:20:39,360 --> 00:20:40,799
can't change this

514
00:20:40,799 --> 00:20:43,200
right it's combining that probably

515
00:20:43,200 --> 00:20:45,039
property that you can't change later is

516
00:20:45,039 --> 00:20:47,440
combining but it also has another

517
00:20:47,440 --> 00:20:50,080
property called hiding in a sense that

518
00:20:50,080 --> 00:20:52,080
the commitment doesn't review of the

519
00:20:52,080 --> 00:20:54,080
value that you commuted

520
00:20:54,080 --> 00:20:55,280
okay

521
00:20:55,280 --> 00:20:57,919
and in in a special case of polynomial

522
00:20:57,919 --> 00:21:00,720
commitment then we we don't commit to

523
00:21:00,720 --> 00:21:03,360
value we commit to a polynomial

524
00:21:03,360 --> 00:21:06,320
and then in the in the later phase you

525
00:21:06,320 --> 00:21:08,320
will have a proof

526
00:21:08,320 --> 00:21:10,640
uh such that the

527
00:21:10,640 --> 00:21:13,440
the evaluation of the protocol at z

528
00:21:13,440 --> 00:21:15,520
equals to y

529
00:21:15,520 --> 00:21:17,200
okay that's that's that's called

530
00:21:17,200 --> 00:21:19,120
polynomial commitment

531
00:21:19,120 --> 00:21:21,120
and then there is uh some

532
00:21:21,120 --> 00:21:24,159
cool properties um in polynomial that

533
00:21:24,159 --> 00:21:28,240
that is used all the time in in zkp

534
00:21:28,240 --> 00:21:30,480
uh so let's say you have a polynomial

535
00:21:30,480 --> 00:21:32,480
over a finite field

536
00:21:32,480 --> 00:21:33,840
for for people who don't know what

537
00:21:33,840 --> 00:21:36,000
finite field is find if you you can

538
00:21:36,000 --> 00:21:36,960
think of it

539
00:21:36,960 --> 00:21:39,360
modulo or prime number

540
00:21:39,360 --> 00:21:43,360
and uh a polynomial of the degree d

541
00:21:43,360 --> 00:21:46,000
has at most d root right it doesn't have

542
00:21:46,000 --> 00:21:49,039
more than negative that's very basic uh

543
00:21:49,039 --> 00:21:49,919
uh

544
00:21:49,919 --> 00:21:51,600
in in the math book

545
00:21:51,600 --> 00:21:52,960
um

546
00:21:52,960 --> 00:21:54,320
and typically you know when people

547
00:21:54,320 --> 00:21:56,640
talking about you know two polynomials

548
00:21:56,640 --> 00:21:59,039
equal to each other then basically you

549
00:21:59,039 --> 00:22:00,159
know their

550
00:22:00,159 --> 00:22:02,320
their difference is zero right is the

551
00:22:02,320 --> 00:22:05,520
same thing just different language okay

552
00:22:05,520 --> 00:22:06,960
um

553
00:22:06,960 --> 00:22:09,120
but you know like how how can the

554
00:22:09,120 --> 00:22:11,200
approval convince the verifier that two

555
00:22:11,200 --> 00:22:13,840
polynomials equal to each other by using

556
00:22:13,840 --> 00:22:16,320
only one challenge from the verifier so

557
00:22:16,320 --> 00:22:18,559
the way it works is to verify you know

558
00:22:18,559 --> 00:22:20,720
send a random z

559
00:22:20,720 --> 00:22:23,679
uh to the approver and if the verifier

560
00:22:23,679 --> 00:22:26,159
is convinced that

561
00:22:26,159 --> 00:22:27,600
p of

562
00:22:27,600 --> 00:22:29,440
z equal to zero

563
00:22:29,440 --> 00:22:30,320
then

564
00:22:30,320 --> 00:22:33,600
then the verifier knows that f of x

565
00:22:33,600 --> 00:22:38,159
equal to g of x would have probability

566
00:22:38,159 --> 00:22:41,360
why because you know the the polynomial

567
00:22:41,360 --> 00:22:42,880
p of x

568
00:22:42,880 --> 00:22:44,720
has at most d root

569
00:22:44,720 --> 00:22:48,240
and if you send a a very huge number z

570
00:22:48,240 --> 00:22:50,720
the chance that z is one of the root is

571
00:22:50,720 --> 00:22:53,200
in negligible right so

572
00:22:53,200 --> 00:22:55,280
so if if the

573
00:22:55,280 --> 00:22:57,840
evaluation of that polynomial equals to

574
00:22:57,840 --> 00:22:58,720
zero

575
00:22:58,720 --> 00:23:00,880
then the

576
00:23:00,880 --> 00:23:03,840
the verifier is convinced that oh

577
00:23:03,840 --> 00:23:06,799
it's likely that two polynomials equal

578
00:23:06,799 --> 00:23:09,520
everywhere

579
00:23:09,520 --> 00:23:12,240
okay another trick is you know

580
00:23:12,240 --> 00:23:15,840
is is this so the the difference between

581
00:23:15,840 --> 00:23:17,679
p of x and p of z

582
00:23:17,679 --> 00:23:21,360
is divisible by x minus z what it means

583
00:23:21,360 --> 00:23:25,200
is there is another polynomial uh h of x

584
00:23:25,200 --> 00:23:28,240
such that h of x times x minus z equal

585
00:23:28,240 --> 00:23:29,600
to p of x

586
00:23:29,600 --> 00:23:30,480
minus

587
00:23:30,480 --> 00:23:31,919
p of z

588
00:23:31,919 --> 00:23:34,320
and you know

589
00:23:34,320 --> 00:23:37,200
here here i will give you a hint here

590
00:23:37,200 --> 00:23:38,240
that you know to check the

591
00:23:38,240 --> 00:23:40,720
multiplication relations

592
00:23:40,720 --> 00:23:42,080
uh

593
00:23:42,080 --> 00:23:46,240
uh h of x times x minus z equal to p of

594
00:23:46,240 --> 00:23:48,799
x minus p of z we can use pairing so

595
00:23:48,799 --> 00:23:51,840
that's exactly the reason why a pair is

596
00:23:51,840 --> 00:23:54,159
used it's used to check the

597
00:23:54,159 --> 00:23:57,840
multiplication relations

598
00:23:58,000 --> 00:23:58,960
okay

599
00:23:58,960 --> 00:24:01,919
so now now i can talk about the protocol

600
00:24:01,919 --> 00:24:04,159
itself but i won't go into detail the

601
00:24:04,159 --> 00:24:06,480
the clock is very very complicated

602
00:24:06,480 --> 00:24:09,360
so the the plonk is just the name of the

603
00:24:09,360 --> 00:24:11,760
protocol and it actually there are

604
00:24:11,760 --> 00:24:13,760
knowledge succinct non-interactive

605
00:24:13,760 --> 00:24:16,240
argument of knowledge it use fiesta

606
00:24:16,240 --> 00:24:19,360
media transform to transfer

607
00:24:19,360 --> 00:24:21,360
to transform not

608
00:24:21,360 --> 00:24:22,880
interactive protocol to a

609
00:24:22,880 --> 00:24:24,480
non-interactive one

610
00:24:24,480 --> 00:24:26,240
and it has pairing

611
00:24:26,240 --> 00:24:28,400
and it used polynomial commitment

612
00:24:28,400 --> 00:24:30,320
basically it used everything that i've

613
00:24:30,320 --> 00:24:34,240
just described but the detail is

614
00:24:34,240 --> 00:24:36,320
is complicated because you know it has a

615
00:24:36,320 --> 00:24:38,320
lot of optimization

616
00:24:38,320 --> 00:24:40,080
uh so that it can be deployed in

617
00:24:40,080 --> 00:24:42,640
practice and it uses a lot of tricks as

618
00:24:42,640 --> 00:24:43,600
well

619
00:24:43,600 --> 00:24:46,000
so it won't have time to describe it

620
00:24:46,000 --> 00:24:48,000
here

621
00:24:48,000 --> 00:24:49,200
okay

622
00:24:49,200 --> 00:24:50,240
um

623
00:24:50,240 --> 00:24:53,039
so so in the plonk um one special

624
00:24:53,039 --> 00:24:56,400
notation is it it use pairing but the

625
00:24:56,400 --> 00:24:58,080
pairing actually

626
00:24:58,080 --> 00:25:00,400
maps two points

627
00:25:00,400 --> 00:25:03,520
in two elliptic curve to a finite field

628
00:25:03,520 --> 00:25:06,159
and let's say g1 is the

629
00:25:06,159 --> 00:25:08,400
the base pawn on the first car and g2 is

630
00:25:08,400 --> 00:25:10,720
the base pawn of the second curve

631
00:25:10,720 --> 00:25:12,960
and plung your special notation

632
00:25:12,960 --> 00:25:15,840
basically x brackets one

633
00:25:15,840 --> 00:25:18,960
equals to x times g one and x bracket

634
00:25:18,960 --> 00:25:22,400
two equal to x times g two okay

635
00:25:22,400 --> 00:25:24,400
so you know as a security engineer when

636
00:25:24,400 --> 00:25:26,000
we look at this

637
00:25:26,000 --> 00:25:28,240
you know the first thing we think oh how

638
00:25:28,240 --> 00:25:30,880
can i manipulate this right so basically

639
00:25:30,880 --> 00:25:32,720
the the

640
00:25:32,720 --> 00:25:33,760
the x

641
00:25:33,760 --> 00:25:36,320
given x times g one the attacker doesn't

642
00:25:36,320 --> 00:25:39,039
know x because they

643
00:25:39,039 --> 00:25:41,679
it has to break the street log problem

644
00:25:41,679 --> 00:25:44,640
but the attacker can manipulate it value

645
00:25:44,640 --> 00:25:48,240
it can modify it can modify that value

646
00:25:48,240 --> 00:25:50,320
and we will use this observation in the

647
00:25:50,320 --> 00:25:52,640
attack as well

648
00:25:52,640 --> 00:25:53,760
okay

649
00:25:53,760 --> 00:25:56,159
so here here is the block verifier you

650
00:25:56,159 --> 00:26:00,080
know look at the equations yeah i i just

651
00:26:00,080 --> 00:26:02,559
just give you the last equation but

652
00:26:02,559 --> 00:26:04,559
there are a lot of symbols here right it

653
00:26:04,559 --> 00:26:05,760
looks scary

654
00:26:05,760 --> 00:26:08,960
and basically it computes a pairing two

655
00:26:08,960 --> 00:26:12,400
pairings and it check whether the result

656
00:26:12,400 --> 00:26:14,960
equals to one

657
00:26:14,960 --> 00:26:17,360
and you know as an attacker you know

658
00:26:17,360 --> 00:26:19,279
when we look at this the first question

659
00:26:19,279 --> 00:26:21,919
is hey which parameters that attacker

660
00:26:21,919 --> 00:26:24,640
can manipulate and which what is the

661
00:26:24,640 --> 00:26:27,279
least effort to manipulate parameters

662
00:26:27,279 --> 00:26:28,000
right

663
00:26:28,000 --> 00:26:29,919
because yeah we are lazy we don't want

664
00:26:29,919 --> 00:26:32,480
to spend all day you know

665
00:26:32,480 --> 00:26:35,039
uh or attack a very difficult point we

666
00:26:35,039 --> 00:26:39,039
want to find the weakest point

667
00:26:39,039 --> 00:26:42,080
um so let me give you a little bit brief

668
00:26:42,080 --> 00:26:45,039
the depression of of the attacker

669
00:26:45,039 --> 00:26:46,799
thoughts you know like from the

670
00:26:46,799 --> 00:26:48,480
theoretical point of view

671
00:26:48,480 --> 00:26:51,600
so so from from from the formulas then

672
00:26:51,600 --> 00:26:53,039
you know like

673
00:26:53,039 --> 00:26:57,120
w z and w u z omega under attacker

674
00:26:57,120 --> 00:26:58,240
control

675
00:26:58,240 --> 00:27:00,960
so but the attacker doesn't know the the

676
00:27:00,960 --> 00:27:03,600
value but attacker can modify it yeah so

677
00:27:03,600 --> 00:27:06,640
we can use that observation later and

678
00:27:06,640 --> 00:27:10,400
you is the the the hash of transcript so

679
00:27:10,400 --> 00:27:12,559
it's basically the fiasco must transform

680
00:27:12,559 --> 00:27:14,720
so it's outside of attacker control it's

681
00:27:14,720 --> 00:27:15,919
basically

682
00:27:15,919 --> 00:27:18,400
um the tackle can't do anything about it

683
00:27:18,400 --> 00:27:19,200
well

684
00:27:19,200 --> 00:27:21,600
if there's some bug in the fiasco

685
00:27:21,600 --> 00:27:24,640
transformer yes but in general no

686
00:27:24,640 --> 00:27:27,279
x is a secret that no one knows

687
00:27:27,279 --> 00:27:28,799
in our case that

688
00:27:28,799 --> 00:27:30,159
even the approval and the verifier

689
00:27:30,159 --> 00:27:32,480
doesn't know what x is

690
00:27:32,480 --> 00:27:34,960
and f you know is computed by a verify

691
00:27:34,960 --> 00:27:38,080
by in a very complicated process so so

692
00:27:38,080 --> 00:27:40,080
we ignore it it's complicated we don't

693
00:27:40,080 --> 00:27:40,880
care

694
00:27:40,880 --> 00:27:43,840
we only want to attack the weakest point

695
00:27:43,840 --> 00:27:48,720
okay so w z and w z omega are natural

696
00:27:48,720 --> 00:27:50,960
attack targets okay

697
00:27:50,960 --> 00:27:52,880
uh you know to simply simplify the

698
00:27:52,880 --> 00:27:56,240
notation at just the nodes p1

699
00:27:56,240 --> 00:27:58,000
is the first component of the first

700
00:27:58,000 --> 00:27:58,960
pairing

701
00:27:58,960 --> 00:28:01,600
p0 is the first component of for the

702
00:28:01,600 --> 00:28:04,640
second pairing and then we want to check

703
00:28:04,640 --> 00:28:05,919
the the

704
00:28:05,919 --> 00:28:09,120
product of two pairing equals to one

705
00:28:09,120 --> 00:28:12,000
okay so now is the attack

706
00:28:12,000 --> 00:28:14,000
so the tech is pretty simple you know

707
00:28:14,000 --> 00:28:16,399
the hardest part of this talk is to

708
00:28:16,399 --> 00:28:18,399
understand the protocol the attack where

709
00:28:18,399 --> 00:28:20,640
the cell is not complicated at all

710
00:28:20,640 --> 00:28:21,679
so

711
00:28:21,679 --> 00:28:24,480
what i did was to use you know like

712
00:28:24,480 --> 00:28:26,559
let's try um

713
00:28:26,559 --> 00:28:29,360
double z equal to zero and the

714
00:28:29,360 --> 00:28:32,399
w z omega equals to zero

715
00:28:32,399 --> 00:28:34,240
so basically and then you know p one

716
00:28:34,240 --> 00:28:37,520
equal to zero plus u times zero it

717
00:28:37,520 --> 00:28:39,039
equals zero right

718
00:28:39,039 --> 00:28:41,039
so what it means is we neutralize the

719
00:28:41,039 --> 00:28:43,360
row of fiesta transform

720
00:28:43,360 --> 00:28:44,559
so u

721
00:28:44,559 --> 00:28:46,480
doesn't mean anything anymore

722
00:28:46,480 --> 00:28:49,679
we will have we will always have p1

723
00:28:49,679 --> 00:28:52,399
equals to zero and that's amazing right

724
00:28:52,399 --> 00:28:55,120
because you know multiple leading uh

725
00:28:55,120 --> 00:28:57,600
fiasco transform is pretty difficult but

726
00:28:57,600 --> 00:28:59,120
with zero points

727
00:28:59,120 --> 00:29:03,279
we get zero it is it's simple

728
00:29:03,279 --> 00:29:06,480
and then you know the pairing of p1 with

729
00:29:06,480 --> 00:29:07,279
x

730
00:29:07,279 --> 00:29:08,320
is

731
00:29:08,320 --> 00:29:10,399
one because the pairing of zero with

732
00:29:10,399 --> 00:29:11,679
anything is

733
00:29:11,679 --> 00:29:12,720
is 1

734
00:29:12,720 --> 00:29:13,919
okay

735
00:29:13,919 --> 00:29:16,799
but if you plug in

736
00:29:16,799 --> 00:29:18,320
p0

737
00:29:18,320 --> 00:29:20,640
you will see that oh we simplified it

738
00:29:20,640 --> 00:29:22,559
yeah we simplify it

739
00:29:22,559 --> 00:29:26,399
and then the end result is f1 minus e

740
00:29:26,399 --> 00:29:28,399
but it's not it's not zero

741
00:29:28,399 --> 00:29:30,880
unfortunately yeah

742
00:29:30,880 --> 00:29:32,960
so the pairing is not one so the

743
00:29:32,960 --> 00:29:34,799
equation doesn't hold

744
00:29:34,799 --> 00:29:36,480
right

745
00:29:36,480 --> 00:29:38,480
so okay so

746
00:29:38,480 --> 00:29:40,640
the question does the attack work

747
00:29:40,640 --> 00:29:43,039
and the answer

748
00:29:43,039 --> 00:29:44,640
no it doesn't work

749
00:29:44,640 --> 00:29:47,279
in theory only if practice is a

750
00:29:47,279 --> 00:29:48,960
different story

751
00:29:48,960 --> 00:29:51,200
okay

752
00:29:51,440 --> 00:29:53,200
so in practice

753
00:29:53,200 --> 00:29:54,559
um

754
00:29:54,559 --> 00:29:57,039
you know when i look at this uh

755
00:29:57,039 --> 00:29:58,880
i i you know

756
00:29:58,880 --> 00:30:00,399
i

757
00:30:00,399 --> 00:30:02,720
i think like theory is cool but i don't

758
00:30:02,720 --> 00:30:05,679
really believe in theory right

759
00:30:05,679 --> 00:30:07,279
uh

760
00:30:07,279 --> 00:30:10,480
i have to try it out so i just send zero

761
00:30:10,480 --> 00:30:12,640
zero to the verifier and see what

762
00:30:12,640 --> 00:30:13,600
happens

763
00:30:13,600 --> 00:30:16,240
and the verify compute the products of

764
00:30:16,240 --> 00:30:18,880
two pairing and it's one and they accept

765
00:30:18,880 --> 00:30:20,799
the proof

766
00:30:20,799 --> 00:30:24,159
this is amazing i i was so surprised

767
00:30:24,159 --> 00:30:27,520
and then you know like um

768
00:30:27,600 --> 00:30:30,720
before talking about why it happened i

769
00:30:30,720 --> 00:30:33,200
want to talk about the consequence first

770
00:30:33,200 --> 00:30:35,120
so the consequences the approval can

771
00:30:35,120 --> 00:30:38,880
force proof for any incorrect statement

772
00:30:38,880 --> 00:30:41,120
that that's that's really critical the

773
00:30:41,120 --> 00:30:42,960
second consequence is

774
00:30:42,960 --> 00:30:44,799
even if the proofer doesn't know

775
00:30:44,799 --> 00:30:46,399
anything about the private or the

776
00:30:46,399 --> 00:30:47,600
witness

777
00:30:47,600 --> 00:30:51,039
uh the the verifier is convinced that

778
00:30:51,039 --> 00:30:53,520
the prover actually knows

779
00:30:53,520 --> 00:30:55,120
the witness

780
00:30:55,120 --> 00:30:58,799
yeah so so so this this this attack is

781
00:30:58,799 --> 00:31:00,640
devastating

782
00:31:00,640 --> 00:31:02,080
basically it

783
00:31:02,080 --> 00:31:04,799
it caused the xeno zero knowledge proof

784
00:31:04,799 --> 00:31:07,919
becomes useless

785
00:31:07,919 --> 00:31:08,799
okay

786
00:31:08,799 --> 00:31:09,840
so

787
00:31:09,840 --> 00:31:13,279
when when i dig into it uh

788
00:31:13,279 --> 00:31:15,760
i i found out that it actually falls

789
00:31:15,760 --> 00:31:17,520
through a chain of perfectly aligned

790
00:31:17,520 --> 00:31:20,159
software cracks that i never seen in my

791
00:31:20,159 --> 00:31:22,720
life although i i've been doing

792
00:31:22,720 --> 00:31:25,440
you know crypt analysis for a long time

793
00:31:25,440 --> 00:31:28,080
and uh i i will show you like how it

794
00:31:28,080 --> 00:31:29,120
actually

795
00:31:29,120 --> 00:31:31,440
works

796
00:31:31,440 --> 00:31:34,240
uh before i continue i have to to talk a

797
00:31:34,240 --> 00:31:36,240
little bit about you know different

798
00:31:36,240 --> 00:31:37,679
a little bit more details on

799
00:31:37,679 --> 00:31:39,360
implementation because now we're talking

800
00:31:39,360 --> 00:31:42,320
about code vulnerabilities so you know

801
00:31:42,320 --> 00:31:46,320
like the first one is on elliptical

802
00:31:46,320 --> 00:31:48,240
points has different representation

803
00:31:48,240 --> 00:31:49,519
depends on

804
00:31:49,519 --> 00:31:50,480
on

805
00:31:50,480 --> 00:31:53,679
on at what stage you're processing it so

806
00:31:53,679 --> 00:31:56,159
you know the the the first one is by

807
00:31:56,159 --> 00:31:58,799
array right when you send a point on on

808
00:31:58,799 --> 00:32:02,720
the while you saw it it's just by array

809
00:32:02,720 --> 00:32:05,039
and you know in some other when you

810
00:32:05,039 --> 00:32:07,519
actually process this then it may be in

811
00:32:07,519 --> 00:32:10,159
the if i find coordinate basically it

812
00:32:10,159 --> 00:32:12,399
has x and y coordinate

813
00:32:12,399 --> 00:32:14,240
but sometimes you know for optimization

814
00:32:14,240 --> 00:32:16,399
purpose people actually use protective

815
00:32:16,399 --> 00:32:18,399
coordinate

816
00:32:18,399 --> 00:32:19,760
and uh

817
00:32:19,760 --> 00:32:22,559
in it x y and z

818
00:32:22,559 --> 00:32:23,360
um

819
00:32:23,360 --> 00:32:24,399
okay

820
00:32:24,399 --> 00:32:25,679
so the attack

821
00:32:25,679 --> 00:32:28,960
so what what what what is the attack

822
00:32:28,960 --> 00:32:32,799
uh in in a concrete term so what i did

823
00:32:32,799 --> 00:32:35,519
was really simple i i actually

824
00:32:35,519 --> 00:32:37,200
it's not a really infinity point or

825
00:32:37,200 --> 00:32:39,919
anything i actually sent a zero byte

826
00:32:39,919 --> 00:32:42,880
so everything is zero there there is no

827
00:32:42,880 --> 00:32:44,799
encoding or anything it's just zero by

828
00:32:44,799 --> 00:32:47,360
it just it just zero out

829
00:32:47,360 --> 00:32:49,120
the whole array

830
00:32:49,120 --> 00:32:51,519
and send it to the verifier and the

831
00:32:51,519 --> 00:32:53,840
verifier accepted

832
00:32:53,840 --> 00:32:56,720
but the root call is fairly complicated

833
00:32:56,720 --> 00:32:58,880
okay so the first the first the fourth

834
00:32:58,880 --> 00:33:01,120
vulnerabilities right so the first thing

835
00:33:01,120 --> 00:33:02,720
to verify i always does is to check

836
00:33:02,720 --> 00:33:04,080
whether the point is on the curve it's

837
00:33:04,080 --> 00:33:05,919
kind of like basic stuff

838
00:33:05,919 --> 00:33:07,760
and then this zero point doesn't satisfy

839
00:33:07,760 --> 00:33:10,880
any equation so it's not on a curve

840
00:33:10,880 --> 00:33:12,960
but the the amazing thing is the

841
00:33:12,960 --> 00:33:15,279
verifier doesn't stop immediately it

842
00:33:15,279 --> 00:33:18,559
only excluded in some computations

843
00:33:18,559 --> 00:33:21,200
but it includes in the final computation

844
00:33:21,200 --> 00:33:23,279
which has pairing with the allowance

845
00:33:23,279 --> 00:33:24,480
attack to work

846
00:33:24,480 --> 00:33:26,559
so you know if the verifier stopped

847
00:33:26,559 --> 00:33:28,399
immediately the attack would fail but it

848
00:33:28,399 --> 00:33:29,679
doesn't stop

849
00:33:29,679 --> 00:33:31,519
okay

850
00:33:31,519 --> 00:33:34,000
the second vulnerability is you know

851
00:33:34,000 --> 00:33:36,320
like on elliptical the author of the

852
00:33:36,320 --> 00:33:38,960
code actually knows the danger of the

853
00:33:38,960 --> 00:33:40,480
infinitive point

854
00:33:40,480 --> 00:33:43,519
so the code actually check uh

855
00:33:43,519 --> 00:33:46,880
where the the point is infinitive right

856
00:33:46,880 --> 00:33:49,120
they they have a check

857
00:33:49,120 --> 00:33:50,000
so

858
00:33:50,000 --> 00:33:51,760
but the way it check whether it is

859
00:33:51,760 --> 00:33:53,840
infinitive it check the most significant

860
00:33:53,840 --> 00:33:54,799
bit

861
00:33:54,799 --> 00:33:56,480
of the point

862
00:33:56,480 --> 00:33:58,240
but in our input the most significant

863
00:33:58,240 --> 00:34:00,720
bit is zero so it's not infinitive so it

864
00:34:00,720 --> 00:34:01,919
bypass

865
00:34:01,919 --> 00:34:02,640
the

866
00:34:02,640 --> 00:34:06,320
the infinity check

867
00:34:06,320 --> 00:34:07,360
okay

868
00:34:07,360 --> 00:34:08,159
so

869
00:34:08,159 --> 00:34:10,000
and then you know like in in some

870
00:34:10,000 --> 00:34:11,280
computation

871
00:34:11,280 --> 00:34:13,760
on elliptical you have to do uh

872
00:34:13,760 --> 00:34:15,440
division as well

873
00:34:15,440 --> 00:34:18,320
uh in the finite field as well

874
00:34:18,320 --> 00:34:21,440
and you know like basically

875
00:34:21,440 --> 00:34:24,399
uh the the inverse of the zero mod p

876
00:34:24,399 --> 00:34:26,879
shouldn't exist right it in theory it

877
00:34:26,879 --> 00:34:28,320
doesn't exist

878
00:34:28,320 --> 00:34:31,359
because uh the inverse benefit of x by

879
00:34:31,359 --> 00:34:33,280
definition is y

880
00:34:33,280 --> 00:34:35,440
such that x time y equal one

881
00:34:35,440 --> 00:34:36,960
mod p

882
00:34:36,960 --> 00:34:40,000
but there's no such y so that y times

883
00:34:40,000 --> 00:34:42,560
zero equals one more p

884
00:34:42,560 --> 00:34:45,760
um but you know like also like the chord

885
00:34:45,760 --> 00:34:47,040
use

886
00:34:47,040 --> 00:34:48,800
our little theorem

887
00:34:48,800 --> 00:34:52,399
basically to compute inverse of x it it

888
00:34:52,399 --> 00:34:55,280
raised to the power of p minus one

889
00:34:55,280 --> 00:34:56,480
mod p

890
00:34:56,480 --> 00:34:59,839
and the if the code zero then zero to

891
00:34:59,839 --> 00:35:01,760
the p minus one actually

892
00:35:01,760 --> 00:35:03,359
is actually zero

893
00:35:03,359 --> 00:35:06,000
so the inverse of zero is zero

894
00:35:06,000 --> 00:35:07,680
so

895
00:35:07,680 --> 00:35:10,640
so so the the code doesn't say that oh

896
00:35:10,640 --> 00:35:12,320
it's wrong or anything it just is to

897
00:35:12,320 --> 00:35:14,800
compute the inverse of zero and and it's

898
00:35:14,800 --> 00:35:16,720
output zero and it's fine it continues

899
00:35:16,720 --> 00:35:20,400
the computation there's no exception

900
00:35:20,400 --> 00:35:23,359
uh furthermore you know like um

901
00:35:23,359 --> 00:35:25,040
in some of the steps

902
00:35:25,040 --> 00:35:26,000
um

903
00:35:26,000 --> 00:35:27,920
you know sometimes you are in affine

904
00:35:27,920 --> 00:35:30,000
coordinates all the time you are in

905
00:35:30,000 --> 00:35:32,880
projectile coordinates so they they you

906
00:35:32,880 --> 00:35:34,400
bash normalize

907
00:35:34,400 --> 00:35:36,640
and here it has another bug that it

908
00:35:36,640 --> 00:35:40,720
turns if one of the points is zero

909
00:35:40,720 --> 00:35:43,119
then it will turn the whole array to

910
00:35:43,119 --> 00:35:44,400
become zero

911
00:35:44,400 --> 00:35:46,320
and we will show you this this is the

912
00:35:46,320 --> 00:35:47,119
the

913
00:35:47,119 --> 00:35:49,359
the core example so if you look at this

914
00:35:49,359 --> 00:35:53,119
the the point p zero is not zero p one

915
00:35:53,119 --> 00:35:54,240
is zero

916
00:35:54,240 --> 00:35:56,800
but after batch normalization

917
00:35:56,800 --> 00:35:58,560
everything becomes zero

918
00:35:58,560 --> 00:36:00,800
right and

919
00:36:00,800 --> 00:36:02,560
what it means is

920
00:36:02,560 --> 00:36:03,440
uh

921
00:36:03,440 --> 00:36:07,200
in the end you have p1 and p0 is zero

922
00:36:07,200 --> 00:36:09,119
here's the amazing thing

923
00:36:09,119 --> 00:36:11,599
uh p1 is is not on the curve and it's

924
00:36:11,599 --> 00:36:14,079
not infinitive so the by by definition

925
00:36:14,079 --> 00:36:16,160
the pairing shouldn't equal to one

926
00:36:16,160 --> 00:36:18,720
but the code the pairing code actually

927
00:36:18,720 --> 00:36:21,359
computed and it equals to one

928
00:36:21,359 --> 00:36:24,560
so so that it bypassed everything

929
00:36:24,560 --> 00:36:26,640
so so you know like

930
00:36:26,640 --> 00:36:28,480
the the attack is so simple that they

931
00:36:28,480 --> 00:36:29,440
don't

932
00:36:29,440 --> 00:36:32,079
even bother to do a demo because you

933
00:36:32,079 --> 00:36:33,760
just zero out the array and then the

934
00:36:33,760 --> 00:36:36,320
verifier just accept everything

935
00:36:36,320 --> 00:36:37,680
um

936
00:36:37,680 --> 00:36:40,720
thanks for your uh attention

937
00:36:40,720 --> 00:36:42,880
if you have any questions please let me

938
00:36:42,880 --> 00:36:45,880
know

939
00:36:52,820 --> 00:36:55,909
[Music]

