1
00:00:01,740 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:15,139 --> 00:00:17,460
who is working for Samsung research and

4
00:00:17,460 --> 00:00:19,740
Samsung Mobile Security today I'll be

5
00:00:19,740 --> 00:00:22,080
talking about taking Corner hardening to

6
00:00:22,080 --> 00:00:24,539
the next level

7
00:00:24,539 --> 00:00:26,699
so let's begin with a brief introduction

8
00:00:26,699 --> 00:00:29,820
of today's talk we'll focus on how to

9
00:00:29,820 --> 00:00:33,360
secure today's OS colors particularly we

10
00:00:33,360 --> 00:00:37,079
focused on two well-story defenses CFI

11
00:00:37,079 --> 00:00:40,620
and uaf defense and how to take both of

12
00:00:40,620 --> 00:00:43,399
them to the next level

13
00:00:43,399 --> 00:00:46,980
this is an overview of CFI we only need

14
00:00:46,980 --> 00:00:50,100
to read Corner CFI that

15
00:00:50,100 --> 00:00:52,320
they utilize on point and authentication

16
00:00:52,320 --> 00:00:54,480
that is the latest security feature

17
00:00:54,480 --> 00:00:56,039
unpleasant

18
00:00:56,039 --> 00:00:58,920
and I first introduced what the problems

19
00:00:58,920 --> 00:01:01,680
are in more detail by then by

20
00:01:01,680 --> 00:01:03,180
demystifying the state-of-the-art

21
00:01:03,180 --> 00:01:06,060
solutions including iOS connection fi

22
00:01:06,060 --> 00:01:08,640
and then I introduce our new approach

23
00:01:08,640 --> 00:01:12,420
called KL there's an academic paper plan

24
00:01:12,420 --> 00:01:16,979
to appear at using security this year

25
00:01:16,979 --> 00:01:20,400
and as for our second topic uaf I first

26
00:01:20,400 --> 00:01:23,700
explain on existing approaches and why

27
00:01:23,700 --> 00:01:26,759
they are not scalable up to us corners

28
00:01:26,759 --> 00:01:29,280
and then I'll introduce our new approach

29
00:01:29,280 --> 00:01:31,920
called Big this is another accounting

30
00:01:31,920 --> 00:01:34,320
paper that is published at S Plus this

31
00:01:34,320 --> 00:01:36,559
year

32
00:01:36,659 --> 00:01:39,659
so let's move on to the first topic I'm

33
00:01:39,659 --> 00:01:42,780
pointer authentication based chronic CFI

34
00:01:42,780 --> 00:01:45,420
I will give you a brief information for

35
00:01:45,420 --> 00:01:47,040
background

36
00:01:47,040 --> 00:01:50,399
so step by and to inverse indirect

37
00:01:50,399 --> 00:01:53,520
branches jump to only valid destinations

38
00:01:53,520 --> 00:01:56,820
for example we have three functions here

39
00:01:56,820 --> 00:02:00,299
and in original CFI this function

40
00:02:00,299 --> 00:02:03,420
pointer is only allowed to go their

41
00:02:03,420 --> 00:02:06,420
function entries so we can say that a

42
00:02:06,420 --> 00:02:10,860
loud Target is 3 in original CFI

43
00:02:10,860 --> 00:02:12,780
and if you take into account the

44
00:02:12,780 --> 00:02:14,760
function pointer type which is known as

45
00:02:14,760 --> 00:02:18,000
type base fi fptr function pointer is

46
00:02:18,000 --> 00:02:20,580
not allowed to go function three because

47
00:02:20,580 --> 00:02:23,940
the type of function three void ins is

48
00:02:23,940 --> 00:02:26,340
not different from it's different from

49
00:02:26,340 --> 00:02:29,099
the function point of type in

50
00:02:29,099 --> 00:02:32,099
so allow Targets in type basic fi

51
00:02:32,099 --> 00:02:34,980
decreases by one compared to original

52
00:02:34,980 --> 00:02:37,319
xfi

53
00:02:37,319 --> 00:02:39,780
so with this simple comparison between

54
00:02:39,780 --> 00:02:42,780
original and type based CFI you can you

55
00:02:42,780 --> 00:02:44,640
can get to know two things

56
00:02:44,640 --> 00:02:47,580
first lower low targets means a strong

57
00:02:47,580 --> 00:02:48,720
security

58
00:02:48,720 --> 00:02:51,959
and context is a key to lower allowed

59
00:02:51,959 --> 00:02:54,900
targets this means that if we use

60
00:02:54,900 --> 00:02:58,019
another value as a context other than

61
00:02:58,019 --> 00:03:00,599
function point of type allow targets can

62
00:03:00,599 --> 00:03:03,540
get even lowered

63
00:03:03,540 --> 00:03:07,019
so this is how type base CFI can be

64
00:03:07,019 --> 00:03:09,239
implemented on top of OnPoint

65
00:03:09,239 --> 00:03:11,819
authentication when generating a

66
00:03:11,819 --> 00:03:14,580
function pointer there's a newly added

67
00:03:14,580 --> 00:03:17,819
instruction Tech IA executed this

68
00:03:17,819 --> 00:03:21,120
instruction takes as input a pointer and

69
00:03:21,120 --> 00:03:24,659
a context that can be hash of the

70
00:03:24,659 --> 00:03:27,180
function point of time in type base cf5

71
00:03:27,180 --> 00:03:29,099
this instruction goes through a

72
00:03:29,099 --> 00:03:31,500
lightweight block Cipher named Karma

73
00:03:31,500 --> 00:03:34,860
inside Hardware which signs the given

74
00:03:34,860 --> 00:03:37,560
pointer with the given context and key

75
00:03:37,560 --> 00:03:40,620
that serves as a secret

76
00:03:40,620 --> 00:03:43,560
and his outcome looked like a pointer

77
00:03:43,560 --> 00:03:45,959
that contains methodly authentication

78
00:03:45,959 --> 00:03:46,860
code

79
00:03:46,860 --> 00:03:49,560
this code is called pack pointer

80
00:03:49,560 --> 00:03:51,060
authentication code

81
00:03:51,060 --> 00:03:53,819
and this pack will be stored in the

82
00:03:53,819 --> 00:03:56,760
unmute speech of a pointer like this we

83
00:03:56,760 --> 00:03:58,200
call this pointer

84
00:03:58,200 --> 00:04:01,080
assign the pointer

85
00:04:01,080 --> 00:04:03,840
and then with the sound pointer is used

86
00:04:03,840 --> 00:04:06,239
there is another new instruction named

87
00:04:06,239 --> 00:04:10,140
autia which authenticates the sign

88
00:04:10,140 --> 00:04:13,080
pointer with the given context

89
00:04:13,080 --> 00:04:17,279
if both of context and key match the

90
00:04:17,279 --> 00:04:19,738
pack in the onion speed will be released

91
00:04:19,738 --> 00:04:22,380
towards to the original bit

92
00:04:22,380 --> 00:04:25,320
what you call low pointer so this low

93
00:04:25,320 --> 00:04:27,479
pointer is can be used without any

94
00:04:27,479 --> 00:04:29,699
trouble

95
00:04:29,699 --> 00:04:32,580
okay let's see what happens if a context

96
00:04:32,580 --> 00:04:34,139
mismatch occurs

97
00:04:34,139 --> 00:04:37,380
this case represents when attack happens

98
00:04:37,380 --> 00:04:40,680
it signs with the type of voidance

99
00:04:40,680 --> 00:04:45,660
but authenticates it with intent

100
00:04:45,660 --> 00:04:48,300
so in this case the pack in the audio

101
00:04:48,300 --> 00:04:51,300
speeds will transform into an

102
00:04:51,300 --> 00:04:53,220
unpredictable one that is completely

103
00:04:53,220 --> 00:04:56,100
different from the original bit

104
00:04:56,100 --> 00:04:59,400
so a system goes down when this abnormal

105
00:04:59,400 --> 00:05:01,199
pointer is used

106
00:05:01,199 --> 00:05:04,860
so this is how um PA detects pointer

107
00:05:04,860 --> 00:05:09,320
modifications and guarantees security

108
00:05:09,900 --> 00:05:12,960
okay let's see the first pain point the

109
00:05:12,960 --> 00:05:15,419
current currency of our systems have a

110
00:05:15,419 --> 00:05:18,560
low Set Fire Security

111
00:05:18,720 --> 00:05:21,660
as I mentioned earlier what context to

112
00:05:21,660 --> 00:05:25,139
use you directly relate to security and

113
00:05:25,139 --> 00:05:28,139
comparability of CFI system so we use

114
00:05:28,139 --> 00:05:31,080
two factors as a basis to evaluate how

115
00:05:31,080 --> 00:05:33,120
good our context is

116
00:05:33,120 --> 00:05:37,259
first a more unique context is a more

117
00:05:37,259 --> 00:05:40,139
secure CFR system will be

118
00:05:40,139 --> 00:05:44,280
second context is invariance it likely

119
00:05:44,280 --> 00:05:46,860
has no compatibility issue

120
00:05:46,860 --> 00:05:50,520
so building a secure and reliable CFO

121
00:05:50,520 --> 00:05:53,160
Econo system it comes down to a problem

122
00:05:53,160 --> 00:05:55,800
of figuring out the best context in

123
00:05:55,800 --> 00:05:59,840
considering these two aspects

124
00:06:00,120 --> 00:06:02,580
the most widely adopted kind of sapphire

125
00:06:02,580 --> 00:06:06,360
is a type A CFI we discussed earlier

126
00:06:06,360 --> 00:06:08,880
slide we can make the original guess on

127
00:06:08,880 --> 00:06:11,280
Y in considering its context the

128
00:06:11,280 --> 00:06:12,960
function pointer type

129
00:06:12,960 --> 00:06:15,600
actually the function pointer type is

130
00:06:15,600 --> 00:06:18,120
not that much unique because there are

131
00:06:18,120 --> 00:06:20,460
lots of function pointers that share the

132
00:06:20,460 --> 00:06:21,479
same type

133
00:06:21,479 --> 00:06:23,880
so several attacks have demonstrated it

134
00:06:23,880 --> 00:06:25,440
can be broken

135
00:06:25,440 --> 00:06:28,740
but it is totally invariant because the

136
00:06:28,740 --> 00:06:30,479
function point of time can be determined

137
00:06:30,479 --> 00:06:33,060
at builds time and is guaranteed not

138
00:06:33,060 --> 00:06:35,699
being modified a long time

139
00:06:35,699 --> 00:06:39,240
so it has no compatibility issue

140
00:06:39,240 --> 00:06:41,600
since many of commodity or scanners

141
00:06:41,600 --> 00:06:45,120
prioritize compatibility over security

142
00:06:45,120 --> 00:06:50,419
is understandable to go for type A CFI

143
00:06:50,580 --> 00:06:53,160
okay iOS connect CFI goes one step

144
00:06:53,160 --> 00:06:56,340
further by using a better context as you

145
00:06:56,340 --> 00:06:58,919
know iOS color is made of different

146
00:06:58,919 --> 00:07:02,400
languages they use a better context for

147
00:07:02,400 --> 00:07:05,639
C plus plus and Objective C but not for

148
00:07:05,639 --> 00:07:06,600
C

149
00:07:06,600 --> 00:07:09,600
this is why iOS currency Sapphire is not

150
00:07:09,600 --> 00:07:12,660
directly applicable to other C based

151
00:07:12,660 --> 00:07:16,020
oscanner such as Linux or previously

152
00:07:16,020 --> 00:07:18,240
I will detail why they do nothing

153
00:07:18,240 --> 00:07:22,099
perceived function pointers later

154
00:07:22,740 --> 00:07:26,160
okay let's look at how iOS CFI protect C

155
00:07:26,160 --> 00:07:28,020
plus plus function pointers V table

156
00:07:28,020 --> 00:07:29,479
entries

157
00:07:29,479 --> 00:07:32,300
interestingly they use a combination of

158
00:07:32,300 --> 00:07:36,060
State Dynamic and static context storage

159
00:07:36,060 --> 00:07:39,120
address and hash of function name

160
00:07:39,120 --> 00:07:42,900
for example we have a obja of Class A

161
00:07:42,900 --> 00:07:46,500
which is located at a00 address

162
00:07:46,500 --> 00:07:49,500
and function one there is one of member

163
00:07:49,500 --> 00:07:53,280
functions is signed with 800 search

164
00:07:53,280 --> 00:07:56,699
address and hash of function name as a

165
00:07:56,699 --> 00:07:58,440
context

166
00:07:58,440 --> 00:08:02,479
so function 2 does likewise

167
00:08:03,120 --> 00:08:06,660
okay let's evaluate how this context

168
00:08:06,660 --> 00:08:08,039
is good

169
00:08:08,039 --> 00:08:10,080
in the two aspects that I mentioned

170
00:08:10,080 --> 00:08:12,599
earlier the first hash of function name

171
00:08:12,599 --> 00:08:15,300
is unique within a class

172
00:08:15,300 --> 00:08:18,180
so sine the function two pointer cannot

173
00:08:18,180 --> 00:08:20,580
be used for function one

174
00:08:20,580 --> 00:08:22,319
and vice versa

175
00:08:22,319 --> 00:08:25,860
and but and this is invariant because uh

176
00:08:25,860 --> 00:08:29,180
it is a static value so it looks perfect

177
00:08:29,180 --> 00:08:32,880
but second storage address is also

178
00:08:32,880 --> 00:08:35,219
unique within an address system

179
00:08:35,219 --> 00:08:38,520
so sine the function pointer at a02

180
00:08:38,520 --> 00:08:41,700
address cannot be used for another

181
00:08:41,700 --> 00:08:43,500
address

182
00:08:43,500 --> 00:08:46,380
but this is not invariance because a

183
00:08:46,380 --> 00:08:47,820
certain address

184
00:08:47,820 --> 00:08:50,640
can be freed and reallocated to another

185
00:08:50,640 --> 00:08:52,320
object

186
00:08:52,320 --> 00:08:54,660
so you may remember that I mentioned

187
00:08:54,660 --> 00:08:57,240
using not invariant value as a context

188
00:08:57,240 --> 00:09:00,360
may cause a compatibility issue

189
00:09:00,360 --> 00:09:02,459
so I will show you what problem could

190
00:09:02,459 --> 00:09:06,420
come up in reality in next slide

191
00:09:06,420 --> 00:09:09,600
actually a problem can arise when it

192
00:09:09,600 --> 00:09:12,660
comes to protecting C function pointers

193
00:09:12,660 --> 00:09:15,360
here we have a simple function that

194
00:09:15,360 --> 00:09:17,040
contains mem copy

195
00:09:17,040 --> 00:09:20,279
and there are two pointers of struct obj

196
00:09:20,279 --> 00:09:23,040
destination and servers and their

197
00:09:23,040 --> 00:09:25,140
function pointers are signed with

198
00:09:25,140 --> 00:09:29,540
corresponding storage address as context

199
00:09:29,700 --> 00:09:32,640
and then after mem copy destinations

200
00:09:32,640 --> 00:09:34,920
function pointer will be identical to

201
00:09:34,920 --> 00:09:37,260
search this function pointer that is

202
00:09:37,260 --> 00:09:41,940
signed with sources storage address

203
00:09:41,940 --> 00:09:44,220
finally when destination's function

204
00:09:44,220 --> 00:09:46,200
pointer is used

205
00:09:46,200 --> 00:09:48,480
of course it takes the destination

206
00:09:48,480 --> 00:09:51,420
storage address as context but obviously

207
00:09:51,420 --> 00:09:54,420
there will be context mismatch occurring

208
00:09:54,420 --> 00:09:56,580
Because the actual destinations function

209
00:09:56,580 --> 00:09:59,339
pointer is signed with sources storage

210
00:09:59,339 --> 00:10:00,540
address

211
00:10:00,540 --> 00:10:04,019
basically this is because a context a

212
00:10:04,019 --> 00:10:06,660
storage address is not copied along with

213
00:10:06,660 --> 00:10:09,779
a function pointer in mem copy

214
00:10:09,779 --> 00:10:12,060
okay with this example we can get to

215
00:10:12,060 --> 00:10:14,640
know that a dynamic context would trade

216
00:10:14,640 --> 00:10:16,800
compatibility in memory related

217
00:10:16,800 --> 00:10:18,320
functions

218
00:10:18,320 --> 00:10:21,899
that are very commonplace in OS colors

219
00:10:21,899 --> 00:10:25,019
so this is why iOS decided to leave C

220
00:10:25,019 --> 00:10:29,000
function pointers on protected

221
00:10:29,640 --> 00:10:32,339
okay here is the takeaways user of

222
00:10:32,339 --> 00:10:35,399
steady context solely is not as secure

223
00:10:35,399 --> 00:10:38,880
so iOS uses a combination of dynamic and

224
00:10:38,880 --> 00:10:41,220
static context which promises a better

225
00:10:41,220 --> 00:10:42,660
security

226
00:10:42,660 --> 00:10:45,060
the use of dynamic context is likely

227
00:10:45,060 --> 00:10:48,300
prone to compatibility issues especially

228
00:10:48,300 --> 00:10:52,380
in c-based OS colors Linux for example

229
00:10:52,380 --> 00:10:55,380
so the next thing we have to do is to

230
00:10:55,380 --> 00:10:57,660
figure out the new context to improve

231
00:10:57,660 --> 00:11:02,180
security while preserving compatibility

232
00:11:03,000 --> 00:11:05,700
okay to this end we propose a new

233
00:11:05,700 --> 00:11:08,519
combination of context

234
00:11:08,519 --> 00:11:11,579
we newly proposed a combination of two

235
00:11:11,579 --> 00:11:14,640
study contexts and two dynamic contexts

236
00:11:14,640 --> 00:11:17,820
among among other things obj bind plays

237
00:11:17,820 --> 00:11:20,339
the most crucial role in our system so I

238
00:11:20,339 --> 00:11:21,720
focused on

239
00:11:21,720 --> 00:11:24,720
describing what obj bind is and its

240
00:11:24,720 --> 00:11:27,260
implication

241
00:11:27,740 --> 00:11:30,959
first our Baseline concept is identical

242
00:11:30,959 --> 00:11:35,100
to develop type A CFI in this example of

243
00:11:35,100 --> 00:11:39,779
swap II action in Linux to sign Handler

244
00:11:39,779 --> 00:11:43,440
we take is type II candle t as the first

245
00:11:43,440 --> 00:11:45,920
context

246
00:11:46,560 --> 00:11:49,019
on top of that we use the type of an

247
00:11:49,019 --> 00:11:51,180
object struct II Connection in this

248
00:11:51,180 --> 00:11:53,880
example which contains

249
00:11:53,880 --> 00:11:55,980
a Target function pointer

250
00:11:55,980 --> 00:11:58,680
this can enhance cfy Precision a lot

251
00:11:58,680 --> 00:12:01,320
because lots of function pointer in OS

252
00:12:01,320 --> 00:12:03,959
planners are used along with this object

253
00:12:03,959 --> 00:12:09,560
type as you can see in function one

254
00:12:10,500 --> 00:12:12,720
okay next this is the dynamic context

255
00:12:12,720 --> 00:12:15,420
what you call obj point it Blends a

256
00:12:15,420 --> 00:12:18,180
certain build value into a context what

257
00:12:18,180 --> 00:12:20,940
field to use is up to Developers

258
00:12:20,940 --> 00:12:23,459
for example if we choose the name field

259
00:12:23,459 --> 00:12:26,579
for obj bind the field value the address

260
00:12:26,579 --> 00:12:31,980
of o1 will be taken and used in signing

261
00:12:31,980 --> 00:12:33,360
instruction

262
00:12:33,360 --> 00:12:35,459
so finally these three different

263
00:12:35,459 --> 00:12:38,040
contexts are going to be securely mixed

264
00:12:38,040 --> 00:12:41,719
and used in signing instruction

265
00:12:42,480 --> 00:12:45,060
okay so far I've been saying about what

266
00:12:45,060 --> 00:12:49,560
obj bind is not why obj bind is good and

267
00:12:49,560 --> 00:12:52,079
how you can solve the problem iOS Corner

268
00:12:52,079 --> 00:12:53,339
CFI has

269
00:12:53,339 --> 00:12:56,220
so from this slide I'll talk about what

270
00:12:56,220 --> 00:12:58,680
motivates the need of J buying any

271
00:12:58,680 --> 00:13:00,000
simplification

272
00:13:00,000 --> 00:13:03,779
to highlight the benefit from obj buying

273
00:13:03,779 --> 00:13:07,200
actually doing our research ongoing we

274
00:13:07,200 --> 00:13:09,360
found several OS design patterns

275
00:13:09,360 --> 00:13:11,760
beneficial for CFI system

276
00:13:11,760 --> 00:13:15,540
that is a lot of struct Has a Field that

277
00:13:15,540 --> 00:13:18,300
is unique as well as invariant

278
00:13:18,300 --> 00:13:22,980
obj bond is meant to Target such a field

279
00:13:22,980 --> 00:13:25,560
so I'll explain on why obj bind is

280
00:13:25,560 --> 00:13:29,519
unique for example the name field

281
00:13:29,519 --> 00:13:32,220
in II collection most likely differently

282
00:13:32,220 --> 00:13:35,700
initialized for different codes

283
00:13:35,700 --> 00:13:38,700
function wants that o1 to the name field

284
00:13:38,700 --> 00:13:41,519
but another function most likely sets

285
00:13:41,519 --> 00:13:44,220
another value to the same field

286
00:13:44,220 --> 00:13:47,279
in other words this name field serves as

287
00:13:47,279 --> 00:13:49,200
a unique identifier for different

288
00:13:49,200 --> 00:13:52,500
instances of the same object type

289
00:13:52,500 --> 00:13:55,860
so the signed Handler of name one name

290
00:13:55,860 --> 00:13:59,160
or one cannot be used for the signed

291
00:13:59,160 --> 00:14:02,700
pointer of o2 name

292
00:14:02,700 --> 00:14:04,920
so we found this this very common

293
00:14:04,920 --> 00:14:07,740
pattern shared across from Linux to

294
00:14:07,740 --> 00:14:10,500
previously

295
00:14:10,500 --> 00:14:13,680
so next obj bind is invariance

296
00:14:13,680 --> 00:14:16,519
a unique third you know you know object

297
00:14:16,519 --> 00:14:19,760
is most likely defined as constant value

298
00:14:19,760 --> 00:14:23,100
there is a symbol for invariant

299
00:14:23,100 --> 00:14:25,560
so this is initialized at the time of

300
00:14:25,560 --> 00:14:27,839
object creation and it's not changed

301
00:14:27,839 --> 00:14:29,339
until it's free

302
00:14:29,339 --> 00:14:31,860
so we can say that it's easy to maintain

303
00:14:31,860 --> 00:14:34,260
and it's not involved in compatibility

304
00:14:34,260 --> 00:14:35,639
issues

305
00:14:35,639 --> 00:14:39,180
because if it's not invariance value we

306
00:14:39,180 --> 00:14:40,800
have to resign a function pointer

307
00:14:40,800 --> 00:14:44,220
whenever the field value changes

308
00:14:44,220 --> 00:14:47,160
but with this kind of invariant field we

309
00:14:47,160 --> 00:14:48,779
don't need to care about such a

310
00:14:48,779 --> 00:14:51,380
resigning

311
00:14:51,420 --> 00:14:54,620
okay lastly let's visit the map

312
00:14:54,620 --> 00:14:57,720
problematic main copy example but with

313
00:14:57,720 --> 00:14:59,100
obj bind

314
00:14:59,100 --> 00:15:01,320
we have a similar code it has two

315
00:15:01,320 --> 00:15:03,600
pointers destination and Source but

316
00:15:03,600 --> 00:15:06,120
their handlers are assigned with

317
00:15:06,120 --> 00:15:09,839
corresponding name field as context of

318
00:15:09,839 --> 00:15:11,399
course they have different names

319
00:15:11,399 --> 00:15:14,220
destination and source

320
00:15:14,220 --> 00:15:17,339
okay after mem copy destinations Handler

321
00:15:17,339 --> 00:15:20,279
will be identical to sources Handler

322
00:15:20,279 --> 00:15:24,439
that is signed with sources name

323
00:15:24,959 --> 00:15:27,000
and finally when this nation's Handler

324
00:15:27,000 --> 00:15:29,940
is used it takes the destination's name

325
00:15:29,940 --> 00:15:33,240
that is identical to sources name as a

326
00:15:33,240 --> 00:15:35,880
context so there will be no context

327
00:15:35,880 --> 00:15:37,860
mismatch and no compatibility

328
00:15:37,860 --> 00:15:40,860
compatibility issue happening this is

329
00:15:40,860 --> 00:15:41,940
because

330
00:15:41,940 --> 00:15:45,240
a context the main field is copied along

331
00:15:45,240 --> 00:15:48,240
with an Associated Handler in mem copy

332
00:15:48,240 --> 00:15:49,199
function

333
00:15:49,199 --> 00:15:52,560
in conclusion obj bind can enhance step

334
00:15:52,560 --> 00:15:54,540
by Precision while still being

335
00:15:54,540 --> 00:15:59,300
compatible to them copy functions

336
00:15:59,459 --> 00:16:01,860
well let's see the security enhancement

337
00:16:01,860 --> 00:16:05,459
of our method we applied our solution to

338
00:16:05,459 --> 00:16:09,660
Linux and also part obj bind to 87

339
00:16:09,660 --> 00:16:12,300
Strokes that are used the most

340
00:16:12,300 --> 00:16:15,779
throughout the windows not the parts

341
00:16:15,779 --> 00:16:18,899
is a PA based type-based CFR

342
00:16:18,899 --> 00:16:20,220
implementation that comes from an

343
00:16:20,220 --> 00:16:23,399
Academia and for comparison we counted

344
00:16:23,399 --> 00:16:25,680
the number of indirect costs that share

345
00:16:25,680 --> 00:16:27,360
the same context

346
00:16:27,360 --> 00:16:30,480
if uh if it's shared for less than five

347
00:16:30,480 --> 00:16:32,820
places we treat this secure

348
00:16:32,820 --> 00:16:35,399
and if it's shared for more than 100

349
00:16:35,399 --> 00:16:38,220
indirect calls we treat this insecure

350
00:16:38,220 --> 00:16:41,759
and this percent indicates how much each

351
00:16:41,759 --> 00:16:42,740
case

352
00:16:42,740 --> 00:16:46,259
accounts for of all context

353
00:16:46,259 --> 00:16:48,779
okay you can see parts has the smallest

354
00:16:48,779 --> 00:16:52,040
number of secure contexts is because

355
00:16:52,040 --> 00:16:54,480
Paris is the only thing that doesn't use

356
00:16:54,480 --> 00:16:56,040
a dynamic context

357
00:16:56,040 --> 00:17:00,000
and iOS shows a decent number of secure

358
00:17:00,000 --> 00:17:02,160
context because it uses a storage

359
00:17:02,160 --> 00:17:03,480
address

360
00:17:03,480 --> 00:17:06,660
as a context but at least for large

361
00:17:06,660 --> 00:17:09,599
Arctic surface that has 6 000 indirect

362
00:17:09,599 --> 00:17:12,059
costs sharing the same context

363
00:17:12,059 --> 00:17:15,299
because they use the same context for

364
00:17:15,299 --> 00:17:17,760
all C function pointers

365
00:17:17,760 --> 00:17:21,839
but with KL most of contacts are not

366
00:17:21,839 --> 00:17:25,020
shared in more than five places and zero

367
00:17:25,020 --> 00:17:28,679
percent in insecure context

368
00:17:28,679 --> 00:17:31,740
okay for performance evaluation we made

369
00:17:31,740 --> 00:17:34,799
a PA enabled when else they can be

370
00:17:34,799 --> 00:17:37,740
running on amount shape or apple and

371
00:17:37,740 --> 00:17:40,380
install these Linux into the latest mini

372
00:17:40,380 --> 00:17:41,940
the support

373
00:17:41,940 --> 00:17:43,020
um PA

374
00:17:43,020 --> 00:17:46,799
as a result we observe from seven three

375
00:17:46,799 --> 00:17:50,480
to seven percent in post

376
00:17:51,600 --> 00:17:54,059
okay let's sum up this section A

377
00:17:54,059 --> 00:17:57,059
currency fi can make use of os design

378
00:17:57,059 --> 00:18:00,120
patterns to enhance CFI security without

379
00:18:00,120 --> 00:18:02,700
compatibility issues

380
00:18:02,700 --> 00:18:05,820
so but to be honest use of good context

381
00:18:05,820 --> 00:18:08,880
is not the only thing needed to build a

382
00:18:08,880 --> 00:18:11,220
secure kind of CFI system there are

383
00:18:11,220 --> 00:18:13,980
other things that must be addressed but

384
00:18:13,980 --> 00:18:16,020
were not discussed today

385
00:18:16,020 --> 00:18:18,780
to check them all I recommend you read

386
00:18:18,780 --> 00:18:21,559
our full paper

387
00:18:22,140 --> 00:18:24,720
okay let's move on to the next pain

388
00:18:24,720 --> 00:18:27,240
point in the previous section uh we

389
00:18:27,240 --> 00:18:29,760
discussed on a matter of chronic CFI

390
00:18:29,760 --> 00:18:32,340
rather than on PA itself

391
00:18:32,340 --> 00:18:34,919
in this session I will focus on a

392
00:18:34,919 --> 00:18:38,460
security problem of um PA itself that is

393
00:18:38,460 --> 00:18:41,039
a complex compiler Behavior can

394
00:18:41,039 --> 00:18:43,559
introduce solid bugs that are hard to

395
00:18:43,559 --> 00:18:45,720
detect

396
00:18:45,720 --> 00:18:49,320
this is a pipeline producing PA enabled

397
00:18:49,320 --> 00:18:51,480
kernel the this rectangle on the middle

398
00:18:51,480 --> 00:18:53,640
of the slide represents a modern

399
00:18:53,640 --> 00:18:55,740
parallel framework at every VM for

400
00:18:55,740 --> 00:18:56,520
example

401
00:18:56,520 --> 00:18:58,860
and this framework takes color code AS

402
00:18:58,860 --> 00:19:01,200
input and it goes through three

403
00:19:01,200 --> 00:19:03,480
different phases front-end IR

404
00:19:03,480 --> 00:19:05,880
intermediate representation layer and

405
00:19:05,880 --> 00:19:07,740
I'm 64 backend

406
00:19:07,740 --> 00:19:10,020
if you want to add a new function into

407
00:19:10,020 --> 00:19:12,960
this core compiler framework the most

408
00:19:12,960 --> 00:19:16,080
common way is to write your own path or

409
00:19:16,080 --> 00:19:18,600
write your own compiler plugin and

410
00:19:18,600 --> 00:19:22,440
attach it to the IR layer like this

411
00:19:22,440 --> 00:19:26,280
so PA pass here means a compiler plugin

412
00:19:26,280 --> 00:19:28,860
that inserts Security checks for on

413
00:19:28,860 --> 00:19:31,820
pointer Authentication

414
00:19:32,340 --> 00:19:35,700
okay let's see an ideal flow of how

415
00:19:35,700 --> 00:19:39,120
compiler how color binary is produced we

416
00:19:39,120 --> 00:19:41,640
have a simple C code generating a

417
00:19:41,640 --> 00:19:44,220
function pointer to function two

418
00:19:44,220 --> 00:19:47,100
and it breaks into two IR instructions

419
00:19:47,100 --> 00:19:50,700
that this IR layer can recognize and our

420
00:19:50,700 --> 00:19:54,419
play pass takes this as input

421
00:19:54,419 --> 00:19:57,720
and our our pass interposes a signing

422
00:19:57,720 --> 00:20:00,620
instruction between these two

423
00:20:00,620 --> 00:20:06,000
so finally it transforms into I'm 64

424
00:20:06,000 --> 00:20:09,360
assembly by going through um 64 backend

425
00:20:09,360 --> 00:20:12,539
in an ideal situation as you can see the

426
00:20:12,539 --> 00:20:15,960
II code perfectly matched with the finer

427
00:20:15,960 --> 00:20:18,620
kind of binary

428
00:20:18,780 --> 00:20:22,140
but in reality the IR code RPA pass

429
00:20:22,140 --> 00:20:24,900
produced it would pass through other

430
00:20:24,900 --> 00:20:27,299
compiler passes that are out of our

431
00:20:27,299 --> 00:20:28,620
hands

432
00:20:28,620 --> 00:20:31,080
which result in an undesirable color

433
00:20:31,080 --> 00:20:33,539
binary for example there will be

434
00:20:33,539 --> 00:20:36,059
unexpected instructions between what we

435
00:20:36,059 --> 00:20:37,380
intend

436
00:20:37,380 --> 00:20:40,559
customers here and it can be any form of

437
00:20:40,559 --> 00:20:42,360
instructions

438
00:20:42,360 --> 00:20:45,000
let's look at why and how it will be

439
00:20:45,000 --> 00:20:47,280
problematic let me clarify our swap

440
00:20:47,280 --> 00:20:49,679
model first we assume attackers can

441
00:20:49,679 --> 00:20:52,500
corrupt memory but not registers

442
00:20:52,500 --> 00:20:55,700
in this secure sequence

443
00:20:55,700 --> 00:20:59,340
L1 loss the address of function 2 into

444
00:20:59,340 --> 00:21:01,100
X1 register

445
00:21:01,100 --> 00:21:05,220
and but actual never spills onto memory

446
00:21:05,220 --> 00:21:08,400
and install it onto memory as a side

447
00:21:08,400 --> 00:21:10,020
form always

448
00:21:10,020 --> 00:21:13,200
so we can say for sure is secure

449
00:21:13,200 --> 00:21:15,960
in our slave model

450
00:21:15,960 --> 00:21:18,900
okay but in reality there are three more

451
00:21:18,900 --> 00:21:22,500
instructions can be added

452
00:21:22,500 --> 00:21:24,600
for example due to a complex compiler

453
00:21:24,600 --> 00:21:27,299
behavior from F2 to Apple

454
00:21:27,299 --> 00:21:29,880
L2 stores the low pointer which is the

455
00:21:29,880 --> 00:21:31,380
stack memory

456
00:21:31,380 --> 00:21:34,799
and assume uh stand vulnerability exists

457
00:21:34,799 --> 00:21:37,860
in H3 then attackers can put an

458
00:21:37,860 --> 00:21:40,380
arbitrary pointer onto the stack memory

459
00:21:40,380 --> 00:21:45,179
and then A4 and L5 would load and assign

460
00:21:45,179 --> 00:21:47,159
the attacker chosen pointer

461
00:21:47,159 --> 00:21:50,039
by exploring this sequence attackers can

462
00:21:50,039 --> 00:21:52,860
make an arbitrarily signed pointer this

463
00:21:52,860 --> 00:21:56,760
sequence is called signing Oracle

464
00:21:56,760 --> 00:21:59,039
okay here is the takeaway small and

465
00:21:59,039 --> 00:22:01,620
compiler framers are so complicated that

466
00:22:01,620 --> 00:22:03,720
Solid box can arise

467
00:22:03,720 --> 00:22:06,539
and attackers can this um CF file

468
00:22:06,539 --> 00:22:10,200
defenses by exploring such blocks

469
00:22:10,200 --> 00:22:12,720
okay to solve this problem we propose

470
00:22:12,720 --> 00:22:16,260
what we call static validator

471
00:22:16,260 --> 00:22:19,440
we Define four principles that the final

472
00:22:19,440 --> 00:22:21,960
current binary must respect for security

473
00:22:21,960 --> 00:22:24,299
this validator attacks these four

474
00:22:24,299 --> 00:22:26,640
principles by performing a binary level

475
00:22:26,640 --> 00:22:28,860
static analysis on a whole kind of

476
00:22:28,860 --> 00:22:31,380
binary but in the scope of interrupt

477
00:22:31,380 --> 00:22:33,960
function we ran this validator on three

478
00:22:33,960 --> 00:22:36,720
different kind of binaries iOS and Linux

479
00:22:36,720 --> 00:22:38,580
compiled by parts

480
00:22:38,580 --> 00:22:43,340
and Linux compiled by our PA pass

481
00:22:43,500 --> 00:22:46,020
there are four principles we predefined

482
00:22:46,020 --> 00:22:48,539
I'll explain on each of them in next

483
00:22:48,539 --> 00:22:50,840
slide

484
00:22:51,360 --> 00:22:53,880
okay before looking at the first example

485
00:22:53,880 --> 00:22:55,260
of violation

486
00:22:55,260 --> 00:22:57,900
I'd like to explain on a template used

487
00:22:57,900 --> 00:23:00,960
in saying about violations we found you

488
00:23:00,960 --> 00:23:03,659
can see a secure sequence on the left

489
00:23:03,659 --> 00:23:04,679
slide

490
00:23:04,679 --> 00:23:07,440
and an insecure sequence on the right

491
00:23:07,440 --> 00:23:09,360
side

492
00:23:09,360 --> 00:23:11,820
which is an actual violation we found

493
00:23:11,820 --> 00:23:15,299
well first case is a case of absence of

494
00:23:15,299 --> 00:23:16,980
PA instructions

495
00:23:16,980 --> 00:23:20,340
this function takes extra register of

496
00:23:20,340 --> 00:23:24,539
this is a pointer and and loads a

497
00:23:24,539 --> 00:23:26,340
function pointer from the given pointer

498
00:23:26,340 --> 00:23:28,679
and authenticate and uses the function

499
00:23:28,679 --> 00:23:32,039
pointer this is the secure sequence but

500
00:23:32,039 --> 00:23:34,799
in the real binary we have several cases

501
00:23:34,799 --> 00:23:38,039
that have no authentication instructions

502
00:23:38,039 --> 00:23:40,799
so we were suspecting that this is an

503
00:23:40,799 --> 00:23:44,900
implementation bug of compiler past

504
00:23:44,940 --> 00:23:47,400
next one is the simple function that

505
00:23:47,400 --> 00:23:49,919
calls a function pointer pass through a

506
00:23:49,919 --> 00:23:53,520
function parameter so this takes

507
00:23:53,520 --> 00:23:56,460
as input a function assigned function

508
00:23:56,460 --> 00:23:58,559
pointer and authenticates the function

509
00:23:58,559 --> 00:24:01,919
pointer and uses the function pointer

510
00:24:01,919 --> 00:24:04,260
but in the real binary there was a spill

511
00:24:04,260 --> 00:24:05,700
to the step memory

512
00:24:05,700 --> 00:24:08,220
and L2 and immediately after

513
00:24:08,220 --> 00:24:10,080
Authentication

514
00:24:10,080 --> 00:24:12,179
as I mentioned earlier after

515
00:24:12,179 --> 00:24:14,520
authentication X2 register will

516
00:24:14,520 --> 00:24:18,780
transform into the low pointer so A2

517
00:24:18,780 --> 00:24:21,059
stores the low pointer onto the stack

518
00:24:21,059 --> 00:24:22,200
memory

519
00:24:22,200 --> 00:24:25,140
then by corrupting the pointer on stack

520
00:24:25,140 --> 00:24:27,960
attackers can make it jump to anywhere

521
00:24:27,960 --> 00:24:30,659
from nfo

522
00:24:30,659 --> 00:24:33,419
this is what we call Toc tou problem

523
00:24:33,419 --> 00:24:36,659
Primal check and time of use because the

524
00:24:36,659 --> 00:24:40,679
point of check L1 is not adjacent to the

525
00:24:40,679 --> 00:24:44,059
point of use F4

526
00:24:44,100 --> 00:24:47,100
okay this example is a secure signing

527
00:24:47,100 --> 00:24:51,299
code that loads address into x21

528
00:24:51,299 --> 00:24:55,320
register and signs it in place

529
00:24:55,320 --> 00:24:58,380
but in the rear binary an address to be

530
00:24:58,380 --> 00:25:01,620
signed comes from the X2 register that

531
00:25:01,620 --> 00:25:03,780
is one of function parameters

532
00:25:03,780 --> 00:25:06,240
this means that if attackers can control

533
00:25:06,240 --> 00:25:08,940
this function parameter they can make an

534
00:25:08,940 --> 00:25:11,460
arbitrary signed pointer by using this

535
00:25:11,460 --> 00:25:12,600
sequence

536
00:25:12,600 --> 00:25:16,860
this is an instance of signing Oracle

537
00:25:16,860 --> 00:25:18,780
okay let's see one more example of

538
00:25:18,780 --> 00:25:21,179
signing Oracle there was a function

539
00:25:21,179 --> 00:25:23,400
called intervened

540
00:25:23,400 --> 00:25:25,860
between these two instructions

541
00:25:25,860 --> 00:25:28,500
okay it seems no problem at the first

542
00:25:28,500 --> 00:25:31,140
glance but it's definitely problematic

543
00:25:31,140 --> 00:25:34,559
because there are a lot of instructions

544
00:25:34,559 --> 00:25:38,480
to execute in the Quality Function

545
00:25:38,640 --> 00:25:42,059
I will go in more detail and one and one

546
00:25:42,059 --> 00:25:45,179
here loads an address into X20 to

547
00:25:45,179 --> 00:25:47,700
register that is uh that is one of

548
00:25:47,700 --> 00:25:50,039
poorly saved register in arm6 for

549
00:25:50,039 --> 00:25:52,080
architecture this is the key

550
00:25:52,080 --> 00:25:55,140
then the correlate function is first to

551
00:25:55,140 --> 00:25:57,360
store The Exchange to register the

552
00:25:57,360 --> 00:25:59,580
quality save register onto the stack

553
00:25:59,580 --> 00:26:02,880
memory because this is what the Quality

554
00:26:02,880 --> 00:26:04,799
Function has to do in the view of

555
00:26:04,799 --> 00:26:07,620
compiler and CPU architecture

556
00:26:07,620 --> 00:26:11,120
so this example also forced into

557
00:26:11,120 --> 00:26:14,700
assigning Oracle problem

558
00:26:14,700 --> 00:26:18,000
okay we found several violations on all

559
00:26:18,000 --> 00:26:20,640
of those binaries but it's worth noting

560
00:26:20,640 --> 00:26:23,340
that violation does not mean explodable

561
00:26:23,340 --> 00:26:25,220
because there are many variables

562
00:26:25,220 --> 00:26:28,740
involved in exploitation for example

563
00:26:28,740 --> 00:26:31,679
the inter function binary analysis that

564
00:26:31,679 --> 00:26:34,760
is out of scope for now

565
00:26:34,880 --> 00:26:38,880
okay here is takeaways we should uh we

566
00:26:38,880 --> 00:26:40,740
should trust a binary level validator

567
00:26:40,740 --> 00:26:43,919
instead of a complex compiler

568
00:26:43,919 --> 00:26:46,559
and we believe a major event expander

569
00:26:46,559 --> 00:26:48,720
can incorporate this validator into

570
00:26:48,720 --> 00:26:51,240
current development life cycle

571
00:26:51,240 --> 00:26:54,240
to make sure their color release is

572
00:26:54,240 --> 00:26:57,380
completely secure

573
00:26:58,440 --> 00:27:01,500
okay let's move on to the next topic use

574
00:27:01,500 --> 00:27:04,080
a complete difference

575
00:27:04,080 --> 00:27:06,480
okay the main problem here is that no

576
00:27:06,480 --> 00:27:09,120
one cares about counter uaf defenses

577
00:27:09,120 --> 00:27:11,220
okay this is mainly because of two

578
00:27:11,220 --> 00:27:14,279
things first West corner is huge in size

579
00:27:14,279 --> 00:27:17,580
and second corner is most in most cases

580
00:27:17,580 --> 00:27:19,740
the lowest level software

581
00:27:19,740 --> 00:27:22,380
that is not managed by another software

582
00:27:22,380 --> 00:27:24,600
in more devs

583
00:27:24,600 --> 00:27:26,820
so to understand what the problems are

584
00:27:26,820 --> 00:27:29,520
in more detail we will go over existing

585
00:27:29,520 --> 00:27:32,640
approaches and why they are not scalable

586
00:27:32,640 --> 00:27:35,400
up to OS colors

587
00:27:35,400 --> 00:27:37,500
so first approach is called pointer

588
00:27:37,500 --> 00:27:39,480
invalidation which aims to make no

589
00:27:39,480 --> 00:27:42,299
dangling pooner by precisely tracking

590
00:27:42,299 --> 00:27:44,640
the reference count of object

591
00:27:44,640 --> 00:27:47,220
C plus plus has a mechanism known as

592
00:27:47,220 --> 00:27:50,340
smart pointer this is similar to IC and

593
00:27:50,340 --> 00:27:52,400
Arc in lust

594
00:27:52,400 --> 00:27:55,080
and this can be realized by a special

595
00:27:55,080 --> 00:27:57,840
class shared PTR for example if

596
00:27:57,840 --> 00:28:00,179
developers called a pointer as a smart

597
00:28:00,179 --> 00:28:03,120
pointer is reference count gets recorded

598
00:28:03,120 --> 00:28:04,620
as one

599
00:28:04,620 --> 00:28:07,620
and when a pointer copy happens the

600
00:28:07,620 --> 00:28:10,320
reference count will increase this by

601
00:28:10,320 --> 00:28:11,760
one

602
00:28:11,760 --> 00:28:14,400
and when this function ends the

603
00:28:14,400 --> 00:28:17,039
reference count will drop to zero and

604
00:28:17,039 --> 00:28:18,659
naturally the object will be

605
00:28:18,659 --> 00:28:20,580
de-allocated because there is no

606
00:28:20,580 --> 00:28:23,640
reference to the object as you can see

607
00:28:23,640 --> 00:28:25,980
there is no possibility for dangling

608
00:28:25,980 --> 00:28:28,679
pointer but the thing is to take

609
00:28:28,679 --> 00:28:31,500
advantages of this approach developers

610
00:28:31,500 --> 00:28:34,740
have to turn all pointers into smart

611
00:28:34,740 --> 00:28:37,559
pointers which is unrealistic in terms

612
00:28:37,559 --> 00:28:40,200
of engineering approach

613
00:28:40,200 --> 00:28:42,480
to tackle this problem researchers

614
00:28:42,480 --> 00:28:45,179
propose an automatic solution they

615
00:28:45,179 --> 00:28:47,640
designed a new compiler tasks that

616
00:28:47,640 --> 00:28:50,279
analyze source code and interposes on

617
00:28:50,279 --> 00:28:53,460
all memory allocations and 0.0 copy

618
00:28:53,460 --> 00:28:54,840
operations

619
00:28:54,840 --> 00:28:57,720
to automatically manage reference counts

620
00:28:57,720 --> 00:29:01,799
without having to use Smart pointers

621
00:29:01,799 --> 00:29:04,860
however this automation comes from comes

622
00:29:04,860 --> 00:29:07,919
with a new problem for example we have a

623
00:29:07,919 --> 00:29:10,679
testing operation here from pointer to

624
00:29:10,679 --> 00:29:12,600
integer

625
00:29:12,600 --> 00:29:15,120
okay how should we deal with it

626
00:29:15,120 --> 00:29:17,460
this is an obvious polar copy operation

627
00:29:17,460 --> 00:29:19,980
in some sense but it's not in other

628
00:29:19,980 --> 00:29:21,299
sense

629
00:29:21,299 --> 00:29:24,059
actually increment account or not

630
00:29:24,059 --> 00:29:26,520
it's hard to determine which which one

631
00:29:26,520 --> 00:29:27,899
is correct Behavior

632
00:29:27,899 --> 00:29:30,120
because it depends on application

633
00:29:30,120 --> 00:29:32,220
specific semantics

634
00:29:32,220 --> 00:29:34,620
this wouldn't be a big problem in user

635
00:29:34,620 --> 00:29:37,200
space application because Developers

636
00:29:37,200 --> 00:29:40,320
can find all of such cases and fix them

637
00:29:40,320 --> 00:29:42,899
by hand manually but this is only a

638
00:29:42,899 --> 00:29:46,520
realistic way in OS colors because

639
00:29:46,520 --> 00:29:50,039
are huge inside

640
00:29:50,039 --> 00:29:52,679
second approach is to Simply never allow

641
00:29:52,679 --> 00:29:54,059
reallocation

642
00:29:54,059 --> 00:29:56,340
some of you may think this doesn't make

643
00:29:56,340 --> 00:29:59,340
sense but it does in practice for user

644
00:29:59,340 --> 00:30:01,980
space application due to the large size

645
00:30:01,980 --> 00:30:04,020
of virtual memory six forward to be

646
00:30:04,020 --> 00:30:05,220
reserved

647
00:30:05,220 --> 00:30:08,159
but when it comes to OS colors this

648
00:30:08,159 --> 00:30:11,039
wouldn't work because a current memory

649
00:30:11,039 --> 00:30:13,799
or location directly takes up a part of

650
00:30:13,799 --> 00:30:15,779
physical memory that is much smaller

651
00:30:15,779 --> 00:30:17,820
than a virtual memory

652
00:30:17,820 --> 00:30:19,440
so this brings

653
00:30:19,440 --> 00:30:21,419
um out of memory issues very quickly

654
00:30:21,419 --> 00:30:23,460
this is mainly because of the fact that

655
00:30:23,460 --> 00:30:26,340
OS content memory is not managed by

656
00:30:26,340 --> 00:30:29,340
anyone in more devs

657
00:30:29,340 --> 00:30:31,919
so last one is called access validation

658
00:30:31,919 --> 00:30:35,039
that checks if a pointer the reference

659
00:30:35,039 --> 00:30:38,700
is valid in this approach when memory

660
00:30:38,700 --> 00:30:40,980
allocation happens it generates random

661
00:30:40,980 --> 00:30:44,880
ID and this ID is given to two different

662
00:30:44,880 --> 00:30:46,380
places

663
00:30:46,380 --> 00:30:49,500
first this is going to be stored in the

664
00:30:49,500 --> 00:30:51,539
all new speech of a pointer as ampere

665
00:30:51,539 --> 00:30:54,600
does we call this point outside ID

666
00:30:54,600 --> 00:30:57,419
and second this is stored in a separate

667
00:30:57,419 --> 00:31:00,059
table that is kind of key value storage

668
00:31:00,059 --> 00:31:03,720
where K is object address and value is

669
00:31:03,720 --> 00:31:05,100
random ID

670
00:31:05,100 --> 00:31:07,500
recall this object side ID

671
00:31:07,500 --> 00:31:10,380
so finally when a pointer is referenced

672
00:31:10,380 --> 00:31:15,860
it Compares if the two IDs are same

673
00:31:16,440 --> 00:31:18,899
the problem is every pointer we

674
00:31:18,899 --> 00:31:21,179
reference demands additional memory

675
00:31:21,179 --> 00:31:24,120
accesses to locate and read object site

676
00:31:24,120 --> 00:31:26,360
ID

677
00:31:26,820 --> 00:31:28,740
typically three additional memory

678
00:31:28,740 --> 00:31:31,679
accesses needed so it brings on

679
00:31:31,679 --> 00:31:33,720
substantial performance over here this

680
00:31:33,720 --> 00:31:36,179
is because the implementation of this

681
00:31:36,179 --> 00:31:38,880
mapping table looks like a multi-level

682
00:31:38,880 --> 00:31:42,000
page table where the level is three in

683
00:31:42,000 --> 00:31:43,520
general

684
00:31:43,520 --> 00:31:46,559
okay so far we got to know why they're

685
00:31:46,559 --> 00:31:49,919
not scalable up to Oscars of of these

686
00:31:49,919 --> 00:31:52,320
three approaches we decided to go and

687
00:31:52,320 --> 00:31:54,539
optimize the access validation approach

688
00:31:54,539 --> 00:31:57,120
because we believe there is still room

689
00:31:57,120 --> 00:32:01,020
for optimization in that approach

690
00:32:01,020 --> 00:32:03,720
so it's time to explain on what you did

691
00:32:03,720 --> 00:32:07,200
to optimize access validation approach

692
00:32:07,200 --> 00:32:10,260
so our objective is to have only one

693
00:32:10,260 --> 00:32:13,020
memory access needed to obtain an object

694
00:32:13,020 --> 00:32:15,200
ID

695
00:32:15,240 --> 00:32:17,880
so I'd like to introduce the first

696
00:32:17,880 --> 00:32:20,460
attempt we did which ended in Failure

697
00:32:20,460 --> 00:32:23,940
actually we kept the point aside ID as

698
00:32:23,940 --> 00:32:24,899
it is

699
00:32:24,899 --> 00:32:28,799
but we moved the object side ID to the

700
00:32:28,799 --> 00:32:31,380
start of the object instead of

701
00:32:31,380 --> 00:32:34,820
maintaining a separate table

702
00:32:35,460 --> 00:32:38,220
in this setting when this pointer is

703
00:32:38,220 --> 00:32:41,940
accessed the pointer -8 always points to

704
00:32:41,940 --> 00:32:46,559
the start of the object object ID

705
00:32:46,559 --> 00:32:49,200
so you can see everything can be done in

706
00:32:49,200 --> 00:32:51,980
just one memory access

707
00:32:52,140 --> 00:32:54,659
there was another problem occurring in

708
00:32:54,659 --> 00:32:56,159
either lookup for the middle of a

709
00:32:56,159 --> 00:32:58,799
pointer okay say that we have another

710
00:32:58,799 --> 00:33:01,980
pointer let's get P2 that gets the

711
00:33:01,980 --> 00:33:04,020
middle of this object

712
00:33:04,020 --> 00:33:06,960
and when this middle pointer is accessed

713
00:33:06,960 --> 00:33:10,500
the pointer minus a will still point to

714
00:33:10,500 --> 00:33:13,019
the middle of this object

715
00:33:13,019 --> 00:33:15,360
which result in an incorrect ideal

716
00:33:15,360 --> 00:33:16,320
lookup

717
00:33:16,320 --> 00:33:19,019
so the next thing we need to do is to

718
00:33:19,019 --> 00:33:21,779
get around this problem

719
00:33:21,779 --> 00:33:24,419
okay we came up with base identifier to

720
00:33:24,419 --> 00:33:27,480
reserve this issue before the random ID

721
00:33:27,480 --> 00:33:29,820
was the only thing the prices in a

722
00:33:29,820 --> 00:33:33,419
unused page but we divided it into two

723
00:33:33,419 --> 00:33:35,460
different parts based identifier and

724
00:33:35,460 --> 00:33:39,179
random ID and dedicate KB to chip base

725
00:33:39,179 --> 00:33:41,399
identifier to hold information for

726
00:33:41,399 --> 00:33:44,840
locating object ID

727
00:33:44,960 --> 00:33:47,460
before we're getting into how it works

728
00:33:47,460 --> 00:33:49,500
all together I'd like to explain two

729
00:33:49,500 --> 00:33:52,559
assumptions necessary in our system we

730
00:33:52,559 --> 00:33:55,140
have a focusable region this is our

731
00:33:55,140 --> 00:33:57,240
first assumption every object is

732
00:33:57,240 --> 00:33:59,360
remitted up to four kilobytes in size

733
00:33:59,360 --> 00:34:03,120
and this region is divided into multiple

734
00:34:03,120 --> 00:34:06,899
slots where each slot is 64 bytes in

735
00:34:06,899 --> 00:34:09,899
size this is our second assumption that

736
00:34:09,899 --> 00:34:12,960
is every object is aligned with 64 bytes

737
00:34:12,960 --> 00:34:16,560
and base identifier is put to use to

738
00:34:16,560 --> 00:34:19,679
certain slot index

739
00:34:19,679 --> 00:34:22,139
so of course such size limitation can be

740
00:34:22,139 --> 00:34:25,879
adjusted for the need of Developers

741
00:34:25,879 --> 00:34:28,980
but there is a one trade-off in these

742
00:34:28,980 --> 00:34:31,379
two assumptions let's take

743
00:34:31,379 --> 00:34:33,899
another memory alignment for assumption

744
00:34:33,899 --> 00:34:37,500
two and see what happens now we take 60

745
00:34:37,500 --> 00:34:41,219
bytes alignment instead of 64 byte

746
00:34:41,219 --> 00:34:43,440
it can bring a less memory over here to

747
00:34:43,440 --> 00:34:46,080
our system but consequently there will

748
00:34:46,080 --> 00:34:49,139
be more number of slots demanding a

749
00:34:49,139 --> 00:34:51,899
larger bit of Base identifier

750
00:34:51,899 --> 00:34:54,480
8 bit to be exact

751
00:34:54,480 --> 00:34:56,879
then the capacity of random ID will

752
00:34:56,879 --> 00:34:59,760
decrease by 2 bit accordingly because we

753
00:34:59,760 --> 00:35:02,280
have only 16 bit to accommodate both

754
00:35:02,280 --> 00:35:05,160
space identifier and random ID as a

755
00:35:05,160 --> 00:35:08,240
result it gets a lower security because

756
00:35:08,240 --> 00:35:11,280
the random ID indicates a security

757
00:35:11,280 --> 00:35:13,320
entropy

758
00:35:13,320 --> 00:35:16,440
so in our system developers have to take

759
00:35:16,440 --> 00:35:20,220
a responsibility of figuring figuring

760
00:35:20,220 --> 00:35:23,579
a configuring this trade-off

761
00:35:23,579 --> 00:35:25,619
based upon their need

762
00:35:25,619 --> 00:35:28,320
anyway we recommend using photo byte and

763
00:35:28,320 --> 00:35:31,260
64 bytes by default

764
00:35:31,260 --> 00:35:33,839
okay let's see an actual example of how

765
00:35:33,839 --> 00:35:36,300
it works all together suppose that this

766
00:35:36,300 --> 00:35:39,960
is 90 bytes allocation and we first

767
00:35:39,960 --> 00:35:43,920
Force this location 64 bytes aligned so

768
00:35:43,920 --> 00:35:47,940
we assign 128 bytes for this allocation

769
00:35:47,940 --> 00:35:50,940
and put the start slot number four in

770
00:35:50,940 --> 00:35:52,560
base identifier

771
00:35:52,560 --> 00:35:57,740
this is where the object ID is located

772
00:35:57,900 --> 00:36:01,560
okay next it gets the middle pointer as

773
00:36:01,560 --> 00:36:02,480
you can see

774
00:36:02,480 --> 00:36:06,480
bi is still preserved but why why

775
00:36:06,480 --> 00:36:11,359
pointers altered to point to the middle

776
00:36:11,640 --> 00:36:14,220
finally when this middle pointer is

777
00:36:14,220 --> 00:36:17,820
accessed we try to locate the object ID

778
00:36:17,820 --> 00:36:20,940
by using both base identifier and

779
00:36:20,940 --> 00:36:22,380
pointer

780
00:36:22,380 --> 00:36:26,300
refers to masking with

781
00:36:26,300 --> 00:36:29,400
first video masking the pointer we focus

782
00:36:29,400 --> 00:36:31,700
by this maximum size in our assumption

783
00:36:31,700 --> 00:36:35,339
and its outcome would be slot zero

784
00:36:35,339 --> 00:36:36,420
address

785
00:36:36,420 --> 00:36:39,359
and then we add a multiplication of 64

786
00:36:39,359 --> 00:36:42,540
and the base identifier of 4 this is

787
00:36:42,540 --> 00:36:45,060
slight index as a result we can obtain

788
00:36:45,060 --> 00:36:48,839
the location of object ID correctly

789
00:36:48,839 --> 00:36:50,640
there is no additional memory access

790
00:36:50,640 --> 00:36:53,940
needed in locating object ID

791
00:36:53,940 --> 00:36:55,680
everything can be done in just one

792
00:36:55,680 --> 00:36:58,220
memory access

793
00:36:58,980 --> 00:37:02,160
okay we evaluate our Solution on two

794
00:37:02,160 --> 00:37:05,160
different colors Ubuntu and Android on

795
00:37:05,160 --> 00:37:09,359
two different CPUs x86 and I'm 64. they

796
00:37:09,359 --> 00:37:12,780
are imposed an overhead of around 20

797
00:37:12,780 --> 00:37:14,420
percent

798
00:37:14,420 --> 00:37:17,280
to be honest but to be honest many of

799
00:37:17,280 --> 00:37:20,640
you many of you may still think 20 is

800
00:37:20,640 --> 00:37:24,000
still high in real world system so we

801
00:37:24,000 --> 00:37:26,820
also developed a performance first

802
00:37:26,820 --> 00:37:30,119
variant using On Top Bike ignore feature

803
00:37:30,119 --> 00:37:32,640
with this with this way uh its

804
00:37:32,640 --> 00:37:35,820
performance reduces down to one or two

805
00:37:35,820 --> 00:37:38,640
percent overhead but its security gets

806
00:37:38,640 --> 00:37:41,099
lowered alongside let's be not able to

807
00:37:41,099 --> 00:37:43,380
inspect the middle pointer

808
00:37:43,380 --> 00:37:47,220
so in this setting we are only able to

809
00:37:47,220 --> 00:37:51,140
the start pointer of an object

810
00:37:53,280 --> 00:37:56,820
okay my presentation ended I can take

811
00:37:56,820 --> 00:38:00,480
any questions from audience now okay

812
00:38:00,480 --> 00:38:02,520
thanks for attending by

813
00:38:02,520 --> 00:38:04,200
my my session and if you have any

814
00:38:04,200 --> 00:38:06,540
question please contact me on Swap card

815
00:38:06,540 --> 00:38:09,720
or email please thank you thank you

816
00:38:09,720 --> 00:38:11,899
everyone

817
00:38:12,690 --> 00:38:15,749
[Music]

818
00:38:19,610 --> 00:38:22,689
[Music]

