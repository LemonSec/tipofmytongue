1
00:00:01,130 --> 00:00:14,690
[Music]

2
00:00:16,160 --> 00:00:18,960
hello everyone welcome i'm going to talk

3
00:00:18,960 --> 00:00:21,760
about mac os security today i will

4
00:00:21,760 --> 00:00:24,720
reveal two vulnerabilities i have found

5
00:00:24,720 --> 00:00:27,920
and show how to defeat mac os use either

6
00:00:27,920 --> 00:00:31,599
of the two roundness my name is dorju

7
00:00:31,599 --> 00:00:34,320
fan a security researcher from ad

8
00:00:34,320 --> 00:00:37,680
security lab i started learning mac os

9
00:00:37,680 --> 00:00:39,840
security from about

10
00:00:39,840 --> 00:00:42,960
the second half of the year 2019 to be

11
00:00:42,960 --> 00:00:46,000
honest i'm almost a newcomer in this

12
00:00:46,000 --> 00:00:48,800
field on october 10th

13
00:00:48,800 --> 00:00:51,920
and 2019 i submitted my first

14
00:00:51,920 --> 00:00:55,039
vulnerability to ample it was fixed on

15
00:00:55,039 --> 00:00:57,520
december 10th then

16
00:00:57,520 --> 00:01:00,879
i especially poster posted a twitter

17
00:01:00,879 --> 00:01:03,840
market and this is the first time i

18
00:01:03,840 --> 00:01:06,720
participated in a security conference as

19
00:01:06,720 --> 00:01:09,600
a speaker thank you for attending my

20
00:01:09,600 --> 00:01:11,040
talk

21
00:01:11,040 --> 00:01:13,600
there are three keywords in my talk

22
00:01:13,600 --> 00:01:17,119
extended file attribute compatibility

23
00:01:17,119 --> 00:01:19,280
and defeating mac os

24
00:01:19,280 --> 00:01:22,479
that's the agenda of my talk today and

25
00:01:22,479 --> 00:01:25,920
what is extended file attribute this is

26
00:01:25,920 --> 00:01:29,360
a concept in file system falsies term is

27
00:01:29,360 --> 00:01:32,320
a huge subject i will not discuss the

28
00:01:32,320 --> 00:01:35,280
details of file system today i will

29
00:01:35,280 --> 00:01:36,960
focus on the one

30
00:01:36,960 --> 00:01:39,920
level part the implementation of

31
00:01:39,920 --> 00:01:43,360
extended file attribute for bravity i

32
00:01:43,360 --> 00:01:46,720
will use x attr extended attribute or

33
00:01:46,720 --> 00:01:49,040
just attribute

34
00:01:49,040 --> 00:01:51,680
instead of extended file attribute in

35
00:01:51,680 --> 00:01:54,159
the remainder of the talk they are both

36
00:01:54,159 --> 00:01:56,960
the same thing

37
00:01:57,759 --> 00:02:00,719
about extended attribute

38
00:02:00,719 --> 00:02:03,280
let's see an example we usually use

39
00:02:03,280 --> 00:02:05,680
finder to manage our files there are

40
00:02:05,680 --> 00:02:07,840
many interesting features in finer for

41
00:02:07,840 --> 00:02:10,800
example for text in finder you can mark

42
00:02:10,800 --> 00:02:13,520
a file with a color tag you can assign

43
00:02:13,520 --> 00:02:16,000
right tag to a file and a green tag to

44
00:02:16,000 --> 00:02:18,879
another file you can also customize some

45
00:02:18,879 --> 00:02:21,599
text tags by yourself shown in the

46
00:02:21,599 --> 00:02:24,560
figure then if you try to sort a group

47
00:02:24,560 --> 00:02:27,599
files by tags files with the theme tags

48
00:02:27,599 --> 00:02:30,080
were grouped together this is more in

49
00:02:30,080 --> 00:02:32,400
line with your personal preferences than

50
00:02:32,400 --> 00:02:35,120
sorting by file name

51
00:02:35,120 --> 00:02:38,000
this feature seems to be powerful how to

52
00:02:38,000 --> 00:02:39,440
implement it

53
00:02:39,440 --> 00:02:42,560
for normal users file consists of file

54
00:02:42,560 --> 00:02:45,760
name and its contents but from the

55
00:02:45,760 --> 00:02:48,720
perspective of file system files have a

56
00:02:48,720 --> 00:02:52,319
rich meaning beside file name and data

57
00:02:52,319 --> 00:02:54,879
it also contains other attributes such

58
00:02:54,879 --> 00:02:58,080
as file size success time and owner and

59
00:02:58,080 --> 00:03:00,800
also there are some advanced attributes

60
00:03:00,800 --> 00:03:03,840
for example failed text obviously they

61
00:03:03,840 --> 00:03:06,959
can't be stored in file content file

62
00:03:06,959 --> 00:03:09,920
system allocates new storage speeds for

63
00:03:09,920 --> 00:03:13,200
them called extended file and views but

64
00:03:13,200 --> 00:03:15,120
how to view and operate

65
00:03:15,120 --> 00:03:17,519
extended attributes

66
00:03:17,519 --> 00:03:20,400
well mac os provides several commands to

67
00:03:20,400 --> 00:03:26,159
do this for example mdrs and xatr

68
00:03:26,159 --> 00:03:29,760
let's use the xatr command to check the

69
00:03:29,760 --> 00:03:31,360
file and

70
00:03:31,360 --> 00:03:34,879
marked with a red tag before we can find

71
00:03:34,879 --> 00:03:37,599
that there is an attribute named item

72
00:03:37,599 --> 00:03:41,120
user text and notice that the attribute

73
00:03:41,120 --> 00:03:44,560
content has a bp list header which looks

74
00:03:44,560 --> 00:03:47,760
much like a plister file we can dump the

75
00:03:47,760 --> 00:03:51,599
content into a humanly readable xml file

76
00:03:51,599 --> 00:03:53,760
through following clause you can find a

77
00:03:53,760 --> 00:03:57,840
screen with the content red6 in xml okay

78
00:03:57,840 --> 00:04:00,080
that's the reason and the finder will

79
00:04:00,080 --> 00:04:02,480
display a red marker next to the file

80
00:04:02,480 --> 00:04:04,879
based on this information

81
00:04:04,879 --> 00:04:05,680
so

82
00:04:05,680 --> 00:04:09,760
how exactly is attr implemented after

83
00:04:09,760 --> 00:04:12,080
all every feature in the system should

84
00:04:12,080 --> 00:04:14,400
be implemented by code

85
00:04:14,400 --> 00:04:17,680
the answer is mac os provides a series

86
00:04:17,680 --> 00:04:22,000
of xetr system cores such as get and set

87
00:04:22,000 --> 00:04:24,400
x attr

88
00:04:24,400 --> 00:04:26,960
we can use the following code to test

89
00:04:26,960 --> 00:04:30,479
whether it is the same as the result

90
00:04:30,479 --> 00:04:33,759
set an attribute name the item user tag

91
00:04:33,759 --> 00:04:36,320
to the file to make finder things then

92
00:04:36,320 --> 00:04:39,680
the file is marked with a red tag i just

93
00:04:39,680 --> 00:04:43,120
reuse the x attr content dumpster from

94
00:04:43,120 --> 00:04:46,320
the previous thread tagged file and then

95
00:04:46,320 --> 00:04:49,120
assign this piece of binary data to the

96
00:04:49,120 --> 00:04:53,520
file through the set x80 car cisco

97
00:04:53,520 --> 00:04:57,360
it turns out that yes we can indeed get

98
00:04:57,360 --> 00:04:59,280
a file with a red mark

99
00:04:59,280 --> 00:05:03,680
so the set x attr cisco works

100
00:05:03,680 --> 00:05:07,600
okay i noticed that mac os supports many

101
00:05:07,600 --> 00:05:09,680
falsies term for mass

102
00:05:09,680 --> 00:05:12,720
refer to the disk utility application

103
00:05:12,720 --> 00:05:17,280
you can see hfs plus and apfs

104
00:05:17,280 --> 00:05:19,680
these two are apple's private file

105
00:05:19,680 --> 00:05:20,960
system

106
00:05:20,960 --> 00:05:24,000
there is no doubt that the support x

107
00:05:24,000 --> 00:05:25,280
attr

108
00:05:25,280 --> 00:05:27,680
but i noticed that there are other

109
00:05:27,680 --> 00:05:29,759
fellow systems

110
00:05:29,759 --> 00:05:35,919
fat and ex fat to these support xetr2

111
00:05:35,919 --> 00:05:40,160
i created a disk image formatted with

112
00:05:40,160 --> 00:05:44,560
fan32 then mounted the image and create

113
00:05:44,560 --> 00:05:47,199
create tagged files in it

114
00:05:47,199 --> 00:05:48,960
and successful

115
00:05:48,960 --> 00:05:52,800
color tag has had appeared the answer is

116
00:05:52,800 --> 00:05:54,080
yes

117
00:05:54,080 --> 00:05:57,360
however fat is a very old file system

118
00:05:57,360 --> 00:05:59,759
which only provides basic file

119
00:05:59,759 --> 00:06:01,840
management functions

120
00:06:01,840 --> 00:06:05,360
intuition tells me that xatr is a

121
00:06:05,360 --> 00:06:08,319
different natalie not supported there

122
00:06:08,319 --> 00:06:13,440
must be some black magic behind it

123
00:06:13,520 --> 00:06:17,840
fortunately xnew the macos kernel is

124
00:06:17,840 --> 00:06:20,720
open source so we can analyze how the

125
00:06:20,720 --> 00:06:24,240
fan file system supports x attr and the

126
00:06:24,240 --> 00:06:27,840
code level x attr 6 chords are

127
00:06:27,840 --> 00:06:30,560
implemented in the following c

128
00:06:30,560 --> 00:06:34,880
source file 3 fsx attr dot c

129
00:06:34,880 --> 00:06:37,680
when we call set x attr all the

130
00:06:37,680 --> 00:06:40,880
arguments will be passed to v n o p set

131
00:06:40,880 --> 00:06:44,400
x attr each file system driver will

132
00:06:44,400 --> 00:06:47,120
register a callback function in reload

133
00:06:47,120 --> 00:06:51,759
operation that is the vmop for epfs the

134
00:06:51,759 --> 00:06:55,440
corresponding vlp will do the red set

135
00:06:55,440 --> 00:06:59,919
xctr operation but for fat fast term the

136
00:06:59,919 --> 00:07:02,880
callback function just returns an error

137
00:07:02,880 --> 00:07:05,680
which is error not support indicating

138
00:07:05,680 --> 00:07:09,599
that the xatr feature is not supported

139
00:07:09,599 --> 00:07:13,199
and then the following code path will be

140
00:07:13,199 --> 00:07:16,080
executed a function name the default set

141
00:07:16,080 --> 00:07:19,440
xctr is called

142
00:07:19,440 --> 00:07:22,319
by reading the code i found that

143
00:07:22,319 --> 00:07:25,280
for filesy terms that don't support xctr

144
00:07:25,280 --> 00:07:28,800
natively like that apple uses

145
00:07:28,800 --> 00:07:31,840
extra hidden file prefixed with dot

146
00:07:31,840 --> 00:07:34,880
underscore to simulate xctr

147
00:07:34,880 --> 00:07:37,759
that's where attributes data store in

148
00:07:37,759 --> 00:07:39,759
fact their system

149
00:07:39,759 --> 00:07:42,960
anyway we can now conclude that the

150
00:07:42,960 --> 00:07:46,000
fanfares term itself doesn't support

151
00:07:46,000 --> 00:07:49,199
xctr but apple introduces ample double

152
00:07:49,199 --> 00:07:52,720
file which implements a compatible layer

153
00:07:52,720 --> 00:07:55,599
why should i put these a containable

154
00:07:55,599 --> 00:07:58,720
layer i guess that this may be due to

155
00:07:58,720 --> 00:08:01,360
user experience considerations

156
00:08:01,360 --> 00:08:04,400
users may be confused if some features

157
00:08:04,400 --> 00:08:05,599
are as

158
00:08:05,599 --> 00:08:10,000
unsupported on other file system

159
00:08:10,000 --> 00:08:12,960
well use a regular fail in user speeds

160
00:08:12,960 --> 00:08:16,639
to simulate xctr that means fail passing

161
00:08:16,639 --> 00:08:18,000
in kernel

162
00:08:18,000 --> 00:08:20,319
fell passing is actual

163
00:08:20,319 --> 00:08:23,120
uh actually a difficult thing there are

164
00:08:23,120 --> 00:08:26,720
thousands of cvs all about file parsing

165
00:08:26,720 --> 00:08:31,599
for example doc pdf image audio there

166
00:08:31,599 --> 00:08:34,399
have been many cvs in history

167
00:08:34,399 --> 00:08:36,799
the input double file also

168
00:08:36,799 --> 00:08:39,279
follows a certain valve format and

169
00:08:39,279 --> 00:08:41,519
requires file parsing

170
00:08:41,519 --> 00:08:43,760
their vulnerabilities in it

171
00:08:43,760 --> 00:08:46,480
and the format of the ample double file

172
00:08:46,480 --> 00:08:48,880
is very simple it mainly stores key

173
00:08:48,880 --> 00:08:50,480
value pairs

174
00:08:50,480 --> 00:08:52,800
through the fail format is simple there

175
00:08:52,800 --> 00:08:55,920
is still a chance to find some flaws in

176
00:08:55,920 --> 00:08:58,000
its implementation

177
00:08:58,000 --> 00:09:01,120
fast testing is an effective way to find

178
00:09:01,120 --> 00:09:02,080
the

179
00:09:02,080 --> 00:09:04,959
failed passing vulnerabilities but ample

180
00:09:04,959 --> 00:09:07,600
double file parsing is processed in

181
00:09:07,600 --> 00:09:10,560
kernel we must customize unique fuzzing

182
00:09:10,560 --> 00:09:12,240
tool to do this

183
00:09:12,240 --> 00:09:14,480
which will take a lot of time

184
00:09:14,480 --> 00:09:16,880
and because the file format is

185
00:09:16,880 --> 00:09:19,600
relatively simple it's pausing code that

186
00:09:19,600 --> 00:09:22,399
is a few hundred lines of code so i

187
00:09:22,399 --> 00:09:26,399
chose code audit which is sufficient

188
00:09:26,399 --> 00:09:29,120
and the layout of amp.double file is

189
00:09:29,120 --> 00:09:30,720
shown in right

190
00:09:30,720 --> 00:09:33,200
several types of data are stored in

191
00:09:33,200 --> 00:09:34,480
sequence

192
00:09:34,480 --> 00:09:37,279
first is apple double header then

193
00:09:37,279 --> 00:09:40,160
extended attribute header then the

194
00:09:40,160 --> 00:09:42,240
attribute keys and finally attribute

195
00:09:42,240 --> 00:09:43,279
values

196
00:09:43,279 --> 00:09:45,440
when i did the code audit i saw this

197
00:09:45,440 --> 00:09:48,880
function check and swap attribute header

198
00:09:48,880 --> 00:09:49,839
it is

199
00:09:49,839 --> 00:09:52,320
responsible for verifying the apple

200
00:09:52,320 --> 00:09:54,880
double file confirm whether the file

201
00:09:54,880 --> 00:09:58,160
structure is legal and this for loop is

202
00:09:58,160 --> 00:10:00,880
used to check if the stoichi value pair

203
00:10:00,880 --> 00:10:03,680
is in the wallet detail area

204
00:10:03,680 --> 00:10:06,720
but look at this line marked in red it

205
00:10:06,720 --> 00:10:10,240
does two things add offset and length to

206
00:10:10,240 --> 00:10:13,440
see if there is an integer overflow and

207
00:10:13,440 --> 00:10:16,480
check the end of attribute data and see

208
00:10:16,480 --> 00:10:19,839
if it exceeds the end of the data area

209
00:10:19,839 --> 00:10:22,720
however this code doesn't check the

210
00:10:22,720 --> 00:10:24,399
offset itself

211
00:10:24,399 --> 00:10:27,760
it must be located in the valid only the

212
00:10:27,760 --> 00:10:30,800
data area too then it is between data

213
00:10:30,800 --> 00:10:33,680
start and the data end specified by the

214
00:10:33,680 --> 00:10:34,959
header

215
00:10:34,959 --> 00:10:38,000
when offset is less than data start

216
00:10:38,000 --> 00:10:41,040
attribute data will overlap with

217
00:10:41,040 --> 00:10:43,600
the previous data structure

218
00:10:43,600 --> 00:10:46,640
such as structural double header or

219
00:10:46,640 --> 00:10:49,839
structure attr header

220
00:10:49,839 --> 00:10:52,880
this is not a big problem when getting

221
00:10:52,880 --> 00:10:57,440
x8 ttr with x80 car at most there is

222
00:10:57,440 --> 00:11:00,160
some unexpected detail from the fair

223
00:11:00,160 --> 00:11:03,839
header however when colleen said xctr to

224
00:11:03,839 --> 00:11:06,880
cell attribute here comes the problem

225
00:11:06,880 --> 00:11:10,399
it is equivalent to a red operation and

226
00:11:10,399 --> 00:11:13,040
all these overlapping data structures

227
00:11:13,040 --> 00:11:14,560
can be modified

228
00:11:14,560 --> 00:11:17,120
this is the vulnerability i

229
00:11:17,120 --> 00:11:20,399
want to talk about the vulnerability in

230
00:11:20,399 --> 00:11:22,480
extended attributes

231
00:11:22,480 --> 00:11:24,800
a master taker advantage of this

232
00:11:24,800 --> 00:11:27,680
corruption to do some useful things

233
00:11:27,680 --> 00:11:31,040
such as arbitrary memory read and write

234
00:11:31,040 --> 00:11:34,480
controlling pc registers and so on

235
00:11:34,480 --> 00:11:37,760
and then i started to read code search

236
00:11:37,760 --> 00:11:39,920
all the code related to these two

237
00:11:39,920 --> 00:11:43,040
headers to see if there are any useful

238
00:11:43,040 --> 00:11:46,160
side effects of course i'm lucky enough

239
00:11:46,160 --> 00:11:49,920
i found something very useful

240
00:11:49,920 --> 00:11:51,760
first i found

241
00:11:51,760 --> 00:11:55,200
this piece of code when set x80 car

242
00:11:55,200 --> 00:11:58,639
operation is completed the corresponding

243
00:11:58,639 --> 00:12:01,920
trend date will be sealed to the xctr

244
00:12:01,920 --> 00:12:02,800
file

245
00:12:02,800 --> 00:12:06,079
the same operation is completed by red

246
00:12:06,079 --> 00:12:08,000
x8 ttr input

247
00:12:08,000 --> 00:12:10,639
before writing the file back to disk the

248
00:12:10,639 --> 00:12:13,839
file size will be recalculated

249
00:12:13,839 --> 00:12:17,200
because the new xct cr is ended or

250
00:12:17,200 --> 00:12:20,639
longer xctr is said the file size may

251
00:12:20,639 --> 00:12:21,920
change

252
00:12:21,920 --> 00:12:25,040
the new file says is calculated by data

253
00:12:25,040 --> 00:12:27,519
start plus data length

254
00:12:27,519 --> 00:12:29,920
referring to the previous speech these

255
00:12:29,920 --> 00:12:32,240
two fields are within the coverage of

256
00:12:32,240 --> 00:12:35,360
the illegal entry of site

257
00:12:35,360 --> 00:12:38,160
i can't change any of them to increase

258
00:12:38,160 --> 00:12:41,440
the stat of file increase the size for

259
00:12:41,440 --> 00:12:46,720
example to 64 megabytes or 64 mb

260
00:12:46,720 --> 00:12:49,760
red x80 info will follow our

261
00:12:49,760 --> 00:12:52,959
instructions and related the same amount

262
00:12:52,959 --> 00:12:55,360
of memory to the file

263
00:12:55,360 --> 00:12:58,160
the problem is in fact sample double

264
00:12:58,160 --> 00:13:00,800
file in the memory generally only

265
00:13:00,800 --> 00:13:02,160
analogies

266
00:13:02,160 --> 00:13:05,040
64 kilobytes of memory

267
00:13:05,040 --> 00:13:07,600
the red file operation is actually

268
00:13:07,600 --> 00:13:10,160
equivalent to a memory copy

269
00:13:10,160 --> 00:13:14,480
if we asked if we asked her to seal 64

270
00:13:14,480 --> 00:13:16,399
mb and then

271
00:13:16,399 --> 00:13:18,639
the wanted length is greater than the

272
00:13:18,639 --> 00:13:20,440
real length

273
00:13:20,440 --> 00:13:24,079
outbound read occurs the contents of the

274
00:13:24,079 --> 00:13:27,680
memory after x80 car info page will be

275
00:13:27,680 --> 00:13:29,920
faithfully sealed to the ample double

276
00:13:29,920 --> 00:13:30,800
file

277
00:13:30,800 --> 00:13:32,800
and this file of course

278
00:13:32,800 --> 00:13:35,519
is readable and readable by the user

279
00:13:35,519 --> 00:13:38,720
space so we can use this to

280
00:13:38,720 --> 00:13:43,040
to disclose kernel memory information

281
00:13:43,040 --> 00:13:45,360
here at downplay

282
00:13:45,360 --> 00:13:50,639
64 mb of kernel memory to xctr file

283
00:13:50,639 --> 00:13:54,000
and display them in hexadecimal the

284
00:13:54,000 --> 00:13:57,360
green mark is an illegal offset at first

285
00:13:57,360 --> 00:13:59,839
pointing to the data start field effect

286
00:13:59,839 --> 00:14:00,800
header

287
00:14:00,800 --> 00:14:04,240
which can be achieved by tampering with

288
00:14:04,240 --> 00:14:07,839
the dot underscore prefixed fctr file in

289
00:14:07,839 --> 00:14:11,560
user space data bias starting from

290
00:14:11,560 --> 00:14:16,480
564 kb or hex one zero zero zero zero is

291
00:14:16,480 --> 00:14:20,079
the kernel memory we read out of bounds

292
00:14:20,079 --> 00:14:23,199
so what can we do with the ob raid

293
00:14:23,199 --> 00:14:27,120
everybody knows that modern kernels aslr

294
00:14:27,120 --> 00:14:29,279
protection is enabled

295
00:14:29,279 --> 00:14:32,639
that is a great space layer randomized

296
00:14:32,639 --> 00:14:35,600
we can use the memory disclosure to

297
00:14:35,600 --> 00:14:38,399
inspect chronometer layout useful to

298
00:14:38,399 --> 00:14:41,519
bypass aslr

299
00:14:41,519 --> 00:14:46,720
actually i put a ipc key message after

300
00:14:46,720 --> 00:14:50,079
xhtr info page in advance

301
00:14:50,079 --> 00:14:52,160
referring to the definition of a key

302
00:14:52,160 --> 00:14:53,360
message

303
00:14:53,360 --> 00:14:56,079
when there is only one key message both

304
00:14:56,079 --> 00:14:59,199
preview and the next pointer point to

305
00:14:59,199 --> 00:15:00,480
itself

306
00:15:00,480 --> 00:15:02,880
which is the first address of this key

307
00:15:02,880 --> 00:15:03,920
message

308
00:15:03,920 --> 00:15:06,720
through this trick we can calculate our

309
00:15:06,720 --> 00:15:09,360
location kernel so

310
00:15:09,360 --> 00:15:12,880
now aslr is not a problem just have to

311
00:15:12,880 --> 00:15:13,760
mention

312
00:15:13,760 --> 00:15:17,040
self-location by ipc key message comment

313
00:15:17,040 --> 00:15:19,839
exploit teaching technique is dead in

314
00:15:19,839 --> 00:15:22,959
the latest version of kernel

315
00:15:22,959 --> 00:15:26,639
okay now we have all be read but this is

316
00:15:26,639 --> 00:15:29,040
not enough for kernel privileged

317
00:15:29,040 --> 00:15:30,800
exclusion

318
00:15:30,800 --> 00:15:32,320
usually we

319
00:15:32,320 --> 00:15:35,839
need an arbitrary kernel memory right to

320
00:15:35,839 --> 00:15:38,560
achieve this goal this is the most

321
00:15:38,560 --> 00:15:41,279
challenging point of this vulnerability

322
00:15:41,279 --> 00:15:43,759
i will explain in detail

323
00:15:43,759 --> 00:15:46,560
since i can now control the data in the

324
00:15:46,560 --> 00:15:49,199
two headers i continue to look at the

325
00:15:49,199 --> 00:15:52,720
code and check if there are other useful

326
00:15:52,720 --> 00:15:55,360
side effects and noticed the fully

327
00:15:55,360 --> 00:15:56,399
encode

328
00:15:56,399 --> 00:15:59,920
before and after write xatari input file

329
00:15:59,920 --> 00:16:02,399
there is a slab 80 header operation

330
00:16:02,399 --> 00:16:04,800
respectively this function does

331
00:16:04,800 --> 00:16:07,279
something relatively simple to

332
00:16:07,279 --> 00:16:09,839
perform a civil region or some integers

333
00:16:09,839 --> 00:16:11,120
in the header

334
00:16:11,120 --> 00:16:13,600
that is the converting battle order of

335
00:16:13,600 --> 00:16:15,040
some interiors

336
00:16:15,040 --> 00:16:18,480
and what is there a sample reason there

337
00:16:18,480 --> 00:16:21,360
and this is because apple double files

338
00:16:21,360 --> 00:16:25,120
are stored in big endian order and x86

339
00:16:25,120 --> 00:16:28,399
is a little ending cpu so the data in

340
00:16:28,399 --> 00:16:31,600
the memory here is inconsistent with the

341
00:16:31,600 --> 00:16:33,920
bad order in the file

342
00:16:33,920 --> 00:16:37,279
data or integers cannot be written

343
00:16:37,279 --> 00:16:40,320
directly to the file back order conv

344
00:16:40,320 --> 00:16:43,759
conversion is required so before writing

345
00:16:43,759 --> 00:16:46,560
the file there is a swap ad

346
00:16:46,560 --> 00:16:49,839
header operation to do this back to this

347
00:16:49,839 --> 00:16:52,720
function there is a for loop the loop

348
00:16:52,720 --> 00:16:55,600
count comes from the header and we can

349
00:16:55,600 --> 00:16:57,360
modify the data in the header

350
00:16:57,360 --> 00:17:00,480
arbitrarily so we can control the loop

351
00:17:00,480 --> 00:17:03,759
count of the for loop next we can turn

352
00:17:03,759 --> 00:17:06,319
the loop count into a very large number

353
00:17:06,319 --> 00:17:08,559
such as 1 million and

354
00:17:08,559 --> 00:17:11,439
the for loop will be continuously

355
00:17:11,439 --> 00:17:14,640
and then we get an outer bounds

356
00:17:14,640 --> 00:17:17,599
however this is not and it will be right

357
00:17:17,599 --> 00:17:22,160
it is just an ob slam

358
00:17:22,160 --> 00:17:25,359
what can ob slam do

359
00:17:25,359 --> 00:17:29,120
fair i must introduce the ob temp stamp

360
00:17:29,120 --> 00:17:31,760
vulnerability by brandon

361
00:17:31,760 --> 00:17:35,679
brandon proves that even an ob red

362
00:17:35,679 --> 00:17:38,480
that cannot control memory content

363
00:17:38,480 --> 00:17:41,120
precisely can also finish as a

364
00:17:41,120 --> 00:17:43,039
successful attack

365
00:17:43,039 --> 00:17:46,960
similarly the ob slab cannot precisely

366
00:17:46,960 --> 00:17:49,679
control the memory content too but i

367
00:17:49,679 --> 00:17:51,679
will use brandon's

368
00:17:51,679 --> 00:17:54,720
technique to complete the

369
00:17:54,720 --> 00:17:58,240
exploit if you select an integer as the

370
00:17:58,240 --> 00:18:01,520
slab a d header did

371
00:18:01,520 --> 00:18:04,080
but still interpret the integer in

372
00:18:04,080 --> 00:18:06,799
little ending the value of the integer

373
00:18:06,799 --> 00:18:08,799
will change

374
00:18:08,799 --> 00:18:12,799
so if you can make a number bigger

375
00:18:12,799 --> 00:18:16,240
or smaller for example x123 to hex the

376
00:18:16,240 --> 00:18:19,520
4321 becomes a bigger value and that's

377
00:18:19,520 --> 00:18:23,120
enough i will make a rpc key message

378
00:18:23,120 --> 00:18:28,120
bigger than its original size

379
00:18:29,360 --> 00:18:32,799
first i place a key message after the x8

380
00:18:32,799 --> 00:18:36,880
ttr info memory page this key message is

381
00:18:36,880 --> 00:18:39,600
the target of our ob

382
00:18:39,600 --> 00:18:42,880
slab and the field in the first of the

383
00:18:42,880 --> 00:18:46,320
key message header is rkm says which is

384
00:18:46,320 --> 00:18:50,320
an unsigned inter 32 because key message

385
00:18:50,320 --> 00:18:53,679
has a variable length this field is used

386
00:18:53,679 --> 00:18:57,280
to record the length of a key message

387
00:18:57,280 --> 00:19:00,000
then it is going to be released the the

388
00:19:00,000 --> 00:19:02,559
allocated memory is free according to

389
00:19:02,559 --> 00:19:05,520
the to this ikm site

390
00:19:05,520 --> 00:19:09,120
if we use ob slab operation to make this

391
00:19:09,120 --> 00:19:10,480
field bigger

392
00:19:10,480 --> 00:19:11,919
and such as

393
00:19:11,919 --> 00:19:14,480
hex one two three four to hex four three

394
00:19:14,480 --> 00:19:17,919
two one then if we release this

395
00:19:17,919 --> 00:19:20,160
key message we will

396
00:19:20,160 --> 00:19:22,160
actually release more memory than

397
00:19:22,160 --> 00:19:23,520
expected

398
00:19:23,520 --> 00:19:26,400
and the other key object following this

399
00:19:26,400 --> 00:19:28,000
key message

400
00:19:28,000 --> 00:19:31,440
i put an ol post here will be released

401
00:19:31,440 --> 00:19:32,960
together

402
00:19:32,960 --> 00:19:35,840
but the reference to the following key

403
00:19:35,840 --> 00:19:39,039
object is still here we can still use

404
00:19:39,039 --> 00:19:41,039
the release the object

405
00:19:41,039 --> 00:19:44,320
that is we get use outer free

406
00:19:44,320 --> 00:19:47,200
finally we can convert the ob swap

407
00:19:47,200 --> 00:19:50,400
vulnerability to a very useful type of

408
00:19:50,400 --> 00:19:52,880
vulnerability

409
00:19:52,880 --> 00:19:56,000
however in the process of my research

410
00:19:56,000 --> 00:19:59,520
when the peer was overlooked the ob slam

411
00:19:59,520 --> 00:20:03,039
operation continuously slammed

412
00:20:03,039 --> 00:20:07,120
12 bytes or three unions enter time

413
00:20:07,120 --> 00:20:09,600
and the starting position is not aligned

414
00:20:09,600 --> 00:20:13,280
to four bytes therefore we cannot swap

415
00:20:13,280 --> 00:20:16,080
only the ikm cell field

416
00:20:16,080 --> 00:20:17,200
in fact

417
00:20:17,200 --> 00:20:19,120
what we get is a 10 byte 10-bit

418
00:20:19,120 --> 00:20:21,200
out-of-bound slab

419
00:20:21,200 --> 00:20:22,799
marked in green

420
00:20:22,799 --> 00:20:25,600
i got more side effects than

421
00:20:25,600 --> 00:20:29,280
i originally expected and the worst

422
00:20:29,280 --> 00:20:32,240
thing is that this study

423
00:20:32,240 --> 00:20:35,679
effects harmful to my exploit

424
00:20:35,679 --> 00:20:38,159
let's see this figure the first three

425
00:20:38,159 --> 00:20:41,200
fields of ipc key message

426
00:20:41,200 --> 00:20:44,159
and akim says i can't friends and i

427
00:20:44,159 --> 00:20:47,520
can't next a craft

428
00:20:47,520 --> 00:20:51,280
especially the lower two bytes of rtm

429
00:20:51,280 --> 00:20:52,400
next

430
00:20:52,400 --> 00:20:56,159
come from rkm flats i can next a very

431
00:20:56,159 --> 00:20:58,559
important pointer

432
00:20:58,559 --> 00:21:01,440
which is crafted and

433
00:21:01,440 --> 00:21:03,679
everything is messed up

434
00:21:03,679 --> 00:21:06,159
of course we can still control the size

435
00:21:06,159 --> 00:21:07,440
of all

436
00:21:07,440 --> 00:21:10,240
rpm sets and trigger the over free

437
00:21:10,240 --> 00:21:12,880
operation successfully but the kernel

438
00:21:12,880 --> 00:21:15,760
panic immediately

439
00:21:15,760 --> 00:21:18,480
according to the panic information i

440
00:21:18,480 --> 00:21:20,960
found the following code the kernel will

441
00:21:20,960 --> 00:21:24,559
do some text before reading key message

442
00:21:24,559 --> 00:21:27,360
we must ensure that i can next is

443
00:21:27,360 --> 00:21:28,480
worried

444
00:21:28,480 --> 00:21:32,000
trouble comes then after another and let

445
00:21:32,000 --> 00:21:36,000
us observe the result of ob slam again

446
00:21:36,000 --> 00:21:37,440
the higher

447
00:21:37,440 --> 00:21:38,880
16 bit

448
00:21:38,880 --> 00:21:42,960
of ikm flags cover the lower 16 bit of

449
00:21:42,960 --> 00:21:47,039
the rtm next pointer in most cases the

450
00:21:47,039 --> 00:21:51,200
higher bits of rkm flags are zeros so it

451
00:21:51,200 --> 00:21:55,039
can be approximated that the lower

452
00:21:55,039 --> 00:21:59,440
16 bits of rpm next are cleared to zero

453
00:21:59,440 --> 00:22:00,240
so

454
00:22:00,240 --> 00:22:03,440
how do we avoid this panic consider such

455
00:22:03,440 --> 00:22:07,120
a situation if key message is allocated

456
00:22:07,120 --> 00:22:10,640
at address line to 64 kb

457
00:22:10,640 --> 00:22:12,400
for example address

458
00:22:12,400 --> 00:22:14,960
hex one two three four zero zero zero

459
00:22:14,960 --> 00:22:16,480
zero

460
00:22:16,480 --> 00:22:19,919
thanks to rpm next point

461
00:22:19,919 --> 00:22:24,240
to key message itself a key and next

462
00:22:24,240 --> 00:22:27,440
pointer equals hex one two three four

463
00:22:27,440 --> 00:22:29,919
zero zero zero zero two

464
00:22:29,919 --> 00:22:31,919
that is the lower

465
00:22:31,919 --> 00:22:35,360
16 bits of the rpm next pointer are

466
00:22:35,360 --> 00:22:39,039
zeros and this time even if ob slam

467
00:22:39,039 --> 00:22:42,320
clears its lower base to zero it is

468
00:22:42,320 --> 00:22:44,880
still a volley the pointer

469
00:22:44,880 --> 00:22:47,440
because its lower bits are originally

470
00:22:47,440 --> 00:22:49,360
zero so

471
00:22:49,360 --> 00:22:51,840
that harmful cell effects can be

472
00:22:51,840 --> 00:22:53,120
eliminated

473
00:22:53,120 --> 00:22:57,840
and we can get a perfect uaf

474
00:22:58,960 --> 00:23:02,320
to achieve this allocate rpc key message

475
00:23:02,320 --> 00:23:05,679
a 64 kb line address

476
00:23:05,679 --> 00:23:08,320
which ends with four zeros i must

477
00:23:08,320 --> 00:23:10,559
control the layout of the kernel heap

478
00:23:10,559 --> 00:23:13,440
precisely i do the following work note

479
00:23:13,440 --> 00:23:15,600
that all these operations are performed

480
00:23:15,600 --> 00:23:18,480
in kernel map no zoom memory and because

481
00:23:18,480 --> 00:23:21,360
ob slam occurs in a kernel map and it's

482
00:23:21,360 --> 00:23:25,280
on a x86 cpu memory range

483
00:23:25,280 --> 00:23:28,559
the memory page is

484
00:23:28,640 --> 00:23:33,039
4kb i allocate many key messages with 17

485
00:23:33,039 --> 00:23:36,480
pd styles continuously which means that

486
00:23:36,480 --> 00:23:39,520
besides our key message is hex eleven

487
00:23:39,520 --> 00:23:41,840
zero zero zero

488
00:23:41,840 --> 00:23:44,640
uh what's the advantage of doing this is

489
00:23:44,640 --> 00:23:47,520
that the address of these key messages

490
00:23:47,520 --> 00:23:51,440
will increase sequentially well we only

491
00:23:51,440 --> 00:23:55,200
care about the changes in the lower 16

492
00:23:55,200 --> 00:23:58,000
bits their addresses are hex

493
00:23:58,000 --> 00:24:01,120
one zero zero zero two zero zero zero

494
00:24:01,120 --> 00:24:04,720
three zero zero zero and so on okay i

495
00:24:04,720 --> 00:24:08,880
can get a 64 lined key message marked in

496
00:24:08,880 --> 00:24:10,240
red

497
00:24:10,240 --> 00:24:12,960
remember what we mentioned in the ob

498
00:24:12,960 --> 00:24:14,240
read part

499
00:24:14,240 --> 00:24:16,720
i can read a large amount of memory

500
00:24:16,720 --> 00:24:21,120
after x80 info is written to user speeds

501
00:24:21,120 --> 00:24:24,480
so i can clearly know which key message

502
00:24:24,480 --> 00:24:25,200
is

503
00:24:25,200 --> 00:24:28,320
i want and then i will split up the key

504
00:24:28,320 --> 00:24:30,559
messages and show

505
00:24:30,559 --> 00:24:32,320
in the figure below

506
00:24:32,320 --> 00:24:34,640
to the field pd that i want

507
00:24:34,640 --> 00:24:38,159
i need to release three continuously

508
00:24:38,159 --> 00:24:41,600
key message starting from four zeros and

509
00:24:41,600 --> 00:24:45,200
then we allocate four memory blocks

510
00:24:45,200 --> 00:24:49,120
one 16 page block of the two eight page

511
00:24:49,120 --> 00:24:50,159
blocks

512
00:24:50,159 --> 00:24:52,880
the rest of the memory is merged into

513
00:24:52,880 --> 00:24:56,960
the next turkey message a 19 page block

514
00:24:56,960 --> 00:25:00,480
which is no specific effect just fills

515
00:25:00,480 --> 00:25:02,400
up the memory hole

516
00:25:02,400 --> 00:25:05,520
this 16 piece memory block is reserved

517
00:25:05,520 --> 00:25:10,000
for xctr info it is lined up to 64 kb

518
00:25:10,000 --> 00:25:10,960
now

519
00:25:10,960 --> 00:25:12,080
next

520
00:25:12,080 --> 00:25:15,120
8 page memory block will also be aligned

521
00:25:15,120 --> 00:25:17,200
to 64 kb

522
00:25:17,200 --> 00:25:20,640
put a key message as this location which

523
00:25:20,640 --> 00:25:23,200
is the candidate object and will be

524
00:25:23,200 --> 00:25:25,520
corrupted by ob slam

525
00:25:25,520 --> 00:25:28,320
and then in the next eight page memory

526
00:25:28,320 --> 00:25:32,320
block i put a ol post piece which is our

527
00:25:32,320 --> 00:25:34,240
over free target

528
00:25:34,240 --> 00:25:36,320
after these operations

529
00:25:36,320 --> 00:25:41,760
i will make the i can set from 32 kb to

530
00:25:41,760 --> 00:25:46,559
46 kb through ob swap and then release

531
00:25:46,559 --> 00:25:50,320
the crafty the key message now we get a

532
00:25:50,320 --> 00:25:54,880
perfect uaf on ol post page

533
00:25:54,880 --> 00:25:57,919
in fact we still have another problem

534
00:25:57,919 --> 00:26:01,440
and here again another new problem uh

535
00:26:01,440 --> 00:26:04,559
look at this code again and i find that

536
00:26:04,559 --> 00:26:08,240
after the xctr file received there is a

537
00:26:08,240 --> 00:26:10,799
slapback operation immediately the

538
00:26:10,799 --> 00:26:13,520
memory will be restored to its previous

539
00:26:13,520 --> 00:26:15,200
little indian state

540
00:26:15,200 --> 00:26:17,919
in other words our free operation must

541
00:26:17,919 --> 00:26:21,200
occur during the reference leave

542
00:26:21,200 --> 00:26:22,559
maybe

543
00:26:22,559 --> 00:26:25,200
we can do this with the risk condition

544
00:26:25,200 --> 00:26:27,360
let's create the two threads the first

545
00:26:27,360 --> 00:26:31,520
thread performs set x etc and ob slab

546
00:26:31,520 --> 00:26:34,320
things and the second thread reads for

547
00:26:34,320 --> 00:26:37,120
the right moment and destroys the key

548
00:26:37,120 --> 00:26:39,679
message ie trigger

549
00:26:39,679 --> 00:26:40,880
for free

550
00:26:40,880 --> 00:26:44,320
it must be done during the red file

551
00:26:44,320 --> 00:26:47,440
steve there is a problem here we have no

552
00:26:47,440 --> 00:26:50,880
way to detect when ob slam has occurred

553
00:26:50,880 --> 00:26:54,159
and then does it end and so it is not

554
00:26:54,159 --> 00:26:57,520
easy to determine when to destroy the

555
00:26:57,520 --> 00:27:01,120
key message as this currently costs

556
00:27:01,120 --> 00:27:04,400
only a few microseconds so the suitable

557
00:27:04,400 --> 00:27:06,480
time window is very small

558
00:27:06,480 --> 00:27:08,720
then what should we do

559
00:27:08,720 --> 00:27:12,320
fortunately red file is an io operation

560
00:27:12,320 --> 00:27:14,960
which is very very time consuming

561
00:27:14,960 --> 00:27:18,480
moreover we can control the size of the

562
00:27:18,480 --> 00:27:20,399
xetr file

563
00:27:20,399 --> 00:27:24,240
so i choose to seal 64 megabytes of

564
00:27:24,240 --> 00:27:27,760
memory to the xctr file then

565
00:27:27,760 --> 00:27:31,600
the set x8 tdrs is called it will expand

566
00:27:31,600 --> 00:27:35,279
to tens of milliseconds in this way our

567
00:27:35,279 --> 00:27:38,240
time window is relatively sufficient

568
00:27:38,240 --> 00:27:39,760
the strategy

569
00:27:39,760 --> 00:27:43,440
is as follows first calculated the time

570
00:27:43,440 --> 00:27:45,200
required to dump

571
00:27:45,200 --> 00:27:47,039
to downpour

572
00:27:47,039 --> 00:27:51,600
64 mb of memory in ob read state second

573
00:27:51,600 --> 00:27:53,039
launch a second

574
00:27:53,039 --> 00:27:57,600
64 mb dump and do the ob slam event

575
00:27:57,600 --> 00:28:00,399
third of the time destroy the key

576
00:28:00,399 --> 00:28:03,279
message in other thread then all three

577
00:28:03,279 --> 00:28:07,679
is made and this time we said it x80

578
00:28:07,679 --> 00:28:11,520
thread is still busy writing xctr fail

579
00:28:11,520 --> 00:28:15,200
and everything happens to sunny

580
00:28:15,200 --> 00:28:18,559
okay now that all the problems have been

581
00:28:18,559 --> 00:28:19,600
solved

582
00:28:19,600 --> 00:28:23,120
we can put these steps together

583
00:28:23,120 --> 00:28:26,799
and to perform a complete exploit i

584
00:28:26,799 --> 00:28:31,760
split the exploit strategy to

585
00:28:31,760 --> 00:28:33,760
is the main exploit

586
00:28:33,760 --> 00:28:36,960
and part 2 is post exploit i will not

587
00:28:36,960 --> 00:28:39,840
discuss the details of the exploit

588
00:28:39,840 --> 00:28:42,640
process you can find the exploit code

589
00:28:42,640 --> 00:28:45,360
you might have the link is given in the

590
00:28:45,360 --> 00:28:47,760
bottom left corner of the piece

591
00:28:47,760 --> 00:28:50,799
and now we have the arbitrary

592
00:28:50,799 --> 00:28:53,120
kernel redress ability

593
00:28:53,120 --> 00:28:54,080
or

594
00:28:54,080 --> 00:28:57,919
however in the latest os trp0 is no

595
00:28:57,919 --> 00:29:00,000
longer accessible

596
00:29:00,000 --> 00:29:03,279
but anyway we have many ways to achieve

597
00:29:03,279 --> 00:29:06,320
arbitrary kernel right that is not a

598
00:29:06,320 --> 00:29:08,799
problem what we need most is a

599
00:29:08,799 --> 00:29:13,520
vulnerability as a starting point

600
00:29:13,520 --> 00:29:16,640
now let's talk about key er qc since

601
00:29:16,640 --> 00:29:18,240
this is a

602
00:29:18,240 --> 00:29:22,000
x86 cpu there is no protection such as

603
00:29:22,000 --> 00:29:25,120
back so find a suitable kernel object

604
00:29:25,120 --> 00:29:27,840
and the forge vertical function then

605
00:29:27,840 --> 00:29:30,159
trigger the vertical function from user

606
00:29:30,159 --> 00:29:32,320
mode you can choose

607
00:29:32,320 --> 00:29:36,320
kernel code execution i will not expand

608
00:29:36,320 --> 00:29:38,880
it here and in most cases you can

609
00:29:38,880 --> 00:29:43,360
already escalate to root by arbitrary

610
00:29:43,360 --> 00:29:46,320
rewrite usually this is enough

611
00:29:46,320 --> 00:29:49,679
only some special scenarios we need to

612
00:29:49,679 --> 00:29:53,520
call the kernel functions so k yeah pc

613
00:29:53,520 --> 00:29:56,320
is not that important as brandon

614
00:29:56,320 --> 00:29:58,720
mentioned before

615
00:29:58,720 --> 00:30:01,679
compared to mac os many people are more

616
00:30:01,679 --> 00:30:05,039
concerned about ios after all ios has

617
00:30:05,039 --> 00:30:07,840
larger number of users and the usage of

618
00:30:07,840 --> 00:30:11,360
the device is always limited unlike mac

619
00:30:11,360 --> 00:30:13,760
you can't get root permissions through

620
00:30:13,760 --> 00:30:16,960
normal operations people need to

621
00:30:16,960 --> 00:30:19,520
exploit to take full control of their

622
00:30:19,520 --> 00:30:22,399
iphones and then let's talk about

623
00:30:22,399 --> 00:30:26,159
the impact of this vulnerability on ios

624
00:30:26,159 --> 00:30:29,039
the conclusion is that ios is not

625
00:30:29,039 --> 00:30:30,399
affected

626
00:30:30,399 --> 00:30:34,480
although ios and macos share the same

627
00:30:34,480 --> 00:30:37,200
kernel code there are still differences

628
00:30:37,200 --> 00:30:40,320
in implementation ios

629
00:30:40,320 --> 00:30:42,399
has commented

630
00:30:42,399 --> 00:30:47,039
out the xetr compatible code

631
00:30:47,039 --> 00:30:50,480
ios has introduced a new

632
00:30:50,480 --> 00:30:54,960
mechanism to support the files app

633
00:30:54,960 --> 00:30:59,919
finder on iphone that is user fs user fs

634
00:30:59,919 --> 00:31:03,120
implements the support of external file

635
00:31:03,120 --> 00:31:05,200
term user speech

636
00:31:05,200 --> 00:31:08,399
when you plug in a flash drive to iphone

637
00:31:08,399 --> 00:31:11,519
the corresponding fs plugin will be

638
00:31:11,519 --> 00:31:15,200
loaded but the code of fantasy term has

639
00:31:15,200 --> 00:31:18,399
been refactored anyway i can't trigger a

640
00:31:18,399 --> 00:31:23,440
crash of fat or ex-fan plug-in so ios is

641
00:31:23,440 --> 00:31:26,799
not affected by this issue moreover this

642
00:31:26,799 --> 00:31:28,320
is also a good

643
00:31:28,320 --> 00:31:31,360
exploit mitigation you can't attack

644
00:31:31,360 --> 00:31:34,320
the kernel directly from pharisee term

645
00:31:34,320 --> 00:31:36,559
anymore in ios

646
00:31:36,559 --> 00:31:38,960
suppose you can successfully launch an

647
00:31:38,960 --> 00:31:41,519
attack you only obtain the permissions

648
00:31:41,519 --> 00:31:44,480
of a normal process but you still can't

649
00:31:44,480 --> 00:31:47,600
obtain the kernel permissions

650
00:31:47,600 --> 00:31:50,000
now remember that the vulnerability i

651
00:31:50,000 --> 00:31:51,760
posted on twitter

652
00:31:51,760 --> 00:31:54,880
this vulnerability has been fixed in

653
00:31:54,880 --> 00:32:00,720
2019 in macos canada 10 15 2 and

654
00:32:00,720 --> 00:32:03,760
it's already a bit old it's probably it

655
00:32:03,760 --> 00:32:06,240
provides the ability to read and write

656
00:32:06,240 --> 00:32:10,080
32 bytes in arbitrary aggressive but the

657
00:32:10,080 --> 00:32:14,399
grass can only be located after the xctr

658
00:32:14,399 --> 00:32:16,480
info page

659
00:32:16,480 --> 00:32:20,159
so it is a perfect vulnerability and i

660
00:32:20,159 --> 00:32:24,880
will explain the vulnerability briefly

661
00:32:24,880 --> 00:32:28,960
function default set x80 again let's

662
00:32:28,960 --> 00:32:31,760
take a look at this piece of code

663
00:32:31,760 --> 00:32:34,640
there is a special attribute in x80 ttr

664
00:32:34,640 --> 00:32:37,360
file named finder info

665
00:32:37,360 --> 00:32:40,399
then replacing this attribute it jumps

666
00:32:40,399 --> 00:32:42,480
to the following code

667
00:32:42,480 --> 00:32:46,399
which allowed the users to sell 32 bytes

668
00:32:46,399 --> 00:32:49,120
of data for this attribute

669
00:32:49,120 --> 00:32:52,320
the issue is that address offset final

670
00:32:52,320 --> 00:32:55,440
info also comes from

671
00:32:55,440 --> 00:32:59,679
the x attr file and there is no check if

672
00:32:59,679 --> 00:33:02,080
it is uh only the range

673
00:33:02,080 --> 00:33:06,240
when this value is greater than 64 kb

674
00:33:06,240 --> 00:33:09,519
outer bonds occurs and we can control

675
00:33:09,519 --> 00:33:13,679
all the ob red bytes written to kernel

676
00:33:13,679 --> 00:33:16,640
in fact if you read this attribute by

677
00:33:16,640 --> 00:33:20,080
get xe ttr04 you can get an out of

678
00:33:20,080 --> 00:33:23,519
bounds read but it doesn't matter the ob

679
00:33:23,519 --> 00:33:27,039
right is enough for the exploitation

680
00:33:27,039 --> 00:33:30,000
unlike the previous vulnerability this

681
00:33:30,000 --> 00:33:33,440
one doesn't have as many limitations and

682
00:33:33,440 --> 00:33:37,279
it is a perfect vulnerability and is

683
00:33:37,279 --> 00:33:40,320
teaching process is simple you just need

684
00:33:40,320 --> 00:33:43,600
to lay out the memory correctly and then

685
00:33:43,600 --> 00:33:46,640
craft the key message and afford a lot a

686
00:33:46,640 --> 00:33:48,000
larger lens

687
00:33:48,000 --> 00:33:51,039
then destroy this key message maker over

688
00:33:51,039 --> 00:33:54,480
free the over free target is o airport

689
00:33:54,480 --> 00:33:56,480
and os data

690
00:33:56,480 --> 00:33:59,679
the os data object serves to disclose

691
00:33:59,679 --> 00:34:02,799
kernel memory and then as before you can

692
00:34:02,799 --> 00:34:05,120
build a tlp 0

693
00:34:05,120 --> 00:34:08,719
done i will not discuss the details of

694
00:34:08,719 --> 00:34:12,079
the exploit process you can find the

695
00:34:12,079 --> 00:34:15,040
exploit code in my github the link is

696
00:34:15,040 --> 00:34:19,040
given in the bottom left corner

697
00:34:19,119 --> 00:34:22,000
about this vulnerability there is a very

698
00:34:22,000 --> 00:34:23,839
interesting thing

699
00:34:23,839 --> 00:34:28,000
you can put a malicious xctr file

700
00:34:28,000 --> 00:34:31,119
on a flash drive then plug in this flash

701
00:34:31,119 --> 00:34:34,960
drive in to a mac macos computer

702
00:34:34,960 --> 00:34:36,159
i will

703
00:34:36,159 --> 00:34:38,320
panic immediately

704
00:34:38,320 --> 00:34:40,800
displaying a multi-language screen of

705
00:34:40,800 --> 00:34:44,239
death analyzing the crash logs i found

706
00:34:44,239 --> 00:34:49,599
it was caused by get xctr or ob read

707
00:34:49,599 --> 00:34:52,320
which is probably because the finder

708
00:34:52,320 --> 00:34:56,159
automatically passed the xctr file

709
00:34:56,159 --> 00:34:59,359
and this could be not lead to arbitrary

710
00:34:59,359 --> 00:35:00,280
code

711
00:35:00,280 --> 00:35:04,160
execution but it's funny it's a zero

712
00:35:04,160 --> 00:35:07,040
click panic

713
00:35:07,200 --> 00:35:10,079
although few people noticed that the

714
00:35:10,079 --> 00:35:12,960
file c term is also an effective attack

715
00:35:12,960 --> 00:35:16,000
surface to the kernel this type of

716
00:35:16,000 --> 00:35:19,920
vulnerability does exist and is powerful

717
00:35:19,920 --> 00:35:22,720
such as the demands i should today

718
00:35:22,720 --> 00:35:24,560
therefore when designing and

719
00:35:24,560 --> 00:35:27,440
implementing a file system need to be

720
00:35:27,440 --> 00:35:30,640
very careful any flaws in it may cause

721
00:35:30,640 --> 00:35:32,960
serious impacts

722
00:35:32,960 --> 00:35:36,480
what's more the meaning of xc ttr is

723
00:35:36,480 --> 00:35:39,359
interpreted by different programs for

724
00:35:39,359 --> 00:35:42,079
example finder uses tense

725
00:35:42,079 --> 00:35:45,440
a child tools near the process xa ttr

726
00:35:45,440 --> 00:35:48,720
and the gamekeeper also relies on x80tr

727
00:35:48,720 --> 00:35:51,839
to decide something this all involves

728
00:35:51,839 --> 00:35:55,760
the path in xctr which is a new attack

729
00:35:55,760 --> 00:35:58,560
surface it is possible to attack these

730
00:35:58,560 --> 00:36:01,280
softwares through xctr

731
00:36:01,280 --> 00:36:06,160
finally ios user fs is a good exploit in

732
00:36:06,160 --> 00:36:08,879
indication

733
00:36:09,040 --> 00:36:11,280
thank you for watching that's all of my

734
00:36:11,280 --> 00:36:13,680
talk today you can find all the beauty

735
00:36:13,680 --> 00:36:16,640
code on my github and you can contact me

736
00:36:16,640 --> 00:36:21,319
by this email thank you

