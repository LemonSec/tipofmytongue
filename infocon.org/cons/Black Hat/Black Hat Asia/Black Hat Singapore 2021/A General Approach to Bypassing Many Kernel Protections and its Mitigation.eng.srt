1
00:00:01,180 --> 00:00:14,719
[Music]

2
00:00:16,560 --> 00:00:19,279
hello everyone i'm very happy to be with

3
00:00:19,279 --> 00:00:22,240
you virtually today my name is rishi

4
00:00:22,240 --> 00:00:25,199
chen a phd student from pennsylvania

5
00:00:25,199 --> 00:00:28,720
state university you can call me lewis

6
00:00:28,720 --> 00:00:31,119
in this talk i'd like to share with you

7
00:00:31,119 --> 00:00:33,920
some outcomes of my recent research work

8
00:00:33,920 --> 00:00:36,800
with my lab mate temple and my advisor

9
00:00:36,800 --> 00:00:38,160
xinhu

10
00:00:38,160 --> 00:00:40,160
this talk is about an exploitation

11
00:00:40,160 --> 00:00:42,239
approach which can bypass many

12
00:00:42,239 --> 00:00:44,719
protections in os kernel

13
00:00:44,719 --> 00:00:47,120
many blackhead talks will describe how

14
00:00:47,120 --> 00:00:49,440
to find new vulnerabilities for new

15
00:00:49,440 --> 00:00:51,280
exploitation tricks

16
00:00:51,280 --> 00:00:53,840
however in this presentation i'm going

17
00:00:53,840 --> 00:00:56,719
to review an exploitation approach that

18
00:00:56,719 --> 00:00:59,600
has existed for almost a decade we

19
00:00:59,600 --> 00:01:02,160
demonstrate that this attack is not only

20
00:01:02,160 --> 00:01:04,640
severe but also general

21
00:01:04,640 --> 00:01:07,360
thus we propose our mitigation design to

22
00:01:07,360 --> 00:01:09,600
deal with this attack

23
00:01:09,600 --> 00:01:11,680
this presentation is organized as

24
00:01:11,680 --> 00:01:12,720
follows

25
00:01:12,720 --> 00:01:14,960
first i will introduce several kernel

26
00:01:14,960 --> 00:01:17,759
protections that are going to bypass as

27
00:01:17,759 --> 00:01:20,320
well as some conservative data we want

28
00:01:20,320 --> 00:01:21,280
to leak

29
00:01:21,280 --> 00:01:24,000
second i will describe the exploitation

30
00:01:24,000 --> 00:01:26,880
approach using two examples

31
00:01:26,880 --> 00:01:29,119
one for linux kernel and another is for

32
00:01:29,119 --> 00:01:30,640
windows kernel

33
00:01:30,640 --> 00:01:32,880
followed by this i will show how we

34
00:01:32,880 --> 00:01:35,200
track diagnostic objects in the kernel

35
00:01:35,200 --> 00:01:36,560
codebase

36
00:01:36,560 --> 00:01:39,119
elastic objects is the key in this

37
00:01:39,119 --> 00:01:42,320
attack i will display the severity of

38
00:01:42,320 --> 00:01:44,720
this exploitation approach and the

39
00:01:44,720 --> 00:01:46,799
reason why we need to study the

40
00:01:46,799 --> 00:01:49,280
generality of this attack

41
00:01:49,280 --> 00:01:51,600
after this i will describe the way we

42
00:01:51,600 --> 00:01:53,759
use to study the generality and the

43
00:01:53,759 --> 00:01:55,840
outcome of the study

44
00:01:55,840 --> 00:01:58,000
finally i will go through several kernel

45
00:01:58,000 --> 00:02:00,079
mitigations that seem to be able to

46
00:02:00,079 --> 00:02:02,560
circumvent the attack by the fail in the

47
00:02:02,560 --> 00:02:04,159
real world

48
00:02:04,159 --> 00:02:06,399
therefore we propose a mitigation which

49
00:02:06,399 --> 00:02:08,800
is simple but effective

50
00:02:08,800 --> 00:02:10,878
this presentation takes about

51
00:02:10,878 --> 00:02:12,800
14 minutes for

52
00:02:12,800 --> 00:02:15,680
30 pages if you have any questions feel

53
00:02:15,680 --> 00:02:19,040
free to ask and also i paste my content

54
00:02:19,040 --> 00:02:22,080
and paste my contact at the last page of

55
00:02:22,080 --> 00:02:24,480
the slide in case you don't have chance

56
00:02:24,480 --> 00:02:26,080
to ask questions

57
00:02:26,080 --> 00:02:28,160
i hope you can enjoy the presentation

58
00:02:28,160 --> 00:02:30,560
and send me your comments so that we can

59
00:02:30,560 --> 00:02:34,160
first advance our research

60
00:02:34,560 --> 00:02:36,800
first things first i will describe

61
00:02:36,800 --> 00:02:38,959
several kernel protections that i plan

62
00:02:38,959 --> 00:02:40,319
to bypass

63
00:02:40,319 --> 00:02:42,640
the first protection is that canary

64
00:02:42,640 --> 00:02:44,800
which is pretty standard protection in

65
00:02:44,800 --> 00:02:48,560
linux freebsd xnu and windows kernel

66
00:02:48,560 --> 00:02:50,879
the idea is quite simple when having a

67
00:02:50,879 --> 00:02:53,440
stack of buffer overflow the anniversary

68
00:02:53,440 --> 00:02:56,560
can overwrite the return address in

69
00:02:56,560 --> 00:02:59,040
current stack frame later when the

70
00:02:59,040 --> 00:03:01,440
function returns the kernel execution is

71
00:03:01,440 --> 00:03:04,239
directed to the malicious address to

72
00:03:04,239 --> 00:03:06,480
protect this override during the

73
00:03:06,480 --> 00:03:09,040
prologue the kernel places the stack

74
00:03:09,040 --> 00:03:11,280
nary which is several bytes of random

75
00:03:11,280 --> 00:03:13,920
value right below the written address

76
00:03:13,920 --> 00:03:15,680
and odbp

77
00:03:15,680 --> 00:03:17,920
during the epilogue the current test is

78
00:03:17,920 --> 00:03:20,560
the canary on stack against the distal

79
00:03:20,560 --> 00:03:23,599
one to see if any corruptions happened

80
00:03:23,599 --> 00:03:26,000
if stack buffer overflow is triggered

81
00:03:26,000 --> 00:03:28,480
the stack canary is tempered

82
00:03:28,480 --> 00:03:30,799
thus when the kernel finds a mismatch

83
00:03:30,799 --> 00:03:33,200
between the canary on stack and the

84
00:03:33,200 --> 00:03:35,760
start one this means stack corruption

85
00:03:35,760 --> 00:03:38,080
has happened and the return address is

86
00:03:38,080 --> 00:03:40,400
no longer trustworthy

87
00:03:40,400 --> 00:03:43,120
to bypass this mitigation the diversity

88
00:03:43,120 --> 00:03:46,879
either uses brute force method or rely

89
00:03:46,879 --> 00:03:49,200
relies on information leaking

90
00:03:49,200 --> 00:03:51,120
the bluetooth force method is to guess a

91
00:03:51,120 --> 00:03:54,319
canary by by bat byte which reduces the

92
00:03:54,319 --> 00:03:56,040
complexity from

93
00:03:56,040 --> 00:04:00,720
6464 over 2 to 8 over 2 on a big o

94
00:04:00,720 --> 00:04:02,959
information leaking is another approach

95
00:04:02,959 --> 00:04:04,799
in which the adversary can leak the

96
00:04:04,799 --> 00:04:06,959
canary to use a space

97
00:04:06,959 --> 00:04:09,439
in this presentation i will show how we

98
00:04:09,439 --> 00:04:11,920
can obtain a leaking primitive from a

99
00:04:11,920 --> 00:04:14,319
limited right primitive to expose the

100
00:04:14,319 --> 00:04:16,000
stack canary

101
00:04:16,000 --> 00:04:17,839
there are many other protections of the

102
00:04:17,839 --> 00:04:20,880
similar goal for example the arm pack

103
00:04:20,880 --> 00:04:22,400
and the k-stack overflow from

104
00:04:22,400 --> 00:04:23,840
geosecurity

105
00:04:23,840 --> 00:04:25,680
as they rely on specific hardware

106
00:04:25,680 --> 00:04:27,600
features or are not adopted by the

107
00:04:27,600 --> 00:04:30,080
mainline kernel we don't elaborate on

108
00:04:30,080 --> 00:04:33,440
them in this presentation

109
00:04:33,440 --> 00:04:35,680
the second projection on stack i want to

110
00:04:35,680 --> 00:04:38,639
introduce is config initial stack all

111
00:04:38,639 --> 00:04:41,280
and a config gcc plugin stack stack

112
00:04:41,280 --> 00:04:42,240
league

113
00:04:42,240 --> 00:04:44,240
both mitigations are responsible for

114
00:04:44,240 --> 00:04:46,400
poisoning the kernel stack at the end of

115
00:04:46,400 --> 00:04:47,840
system call

116
00:04:47,840 --> 00:04:50,240
the kernel is buggy as we all know

117
00:04:50,240 --> 00:04:52,800
one type of the bug is uninitialized

118
00:04:52,800 --> 00:04:53,680
stack

119
00:04:53,680 --> 00:04:56,400
the adversary can exploit the type of

120
00:04:56,400 --> 00:04:59,199
this type of bug using stack spray

121
00:04:59,199 --> 00:05:01,199
when the machine enters the current mode

122
00:05:01,199 --> 00:05:03,520
the kernel stack is used to store local

123
00:05:03,520 --> 00:05:04,720
variables

124
00:05:04,720 --> 00:05:06,320
some of the local variables can be

125
00:05:06,320 --> 00:05:08,479
sensitive for example keys for encrypt

126
00:05:08,479 --> 00:05:11,680
for encryption the anniversary can use a

127
00:05:11,680 --> 00:05:14,320
system call to store the incentive data

128
00:05:14,320 --> 00:05:17,120
on kernel stack and then he or she can

129
00:05:17,120 --> 00:05:19,840
use another system call to trigger the

130
00:05:19,840 --> 00:05:22,160
uninitialized checkbox

131
00:05:22,160 --> 00:05:24,800
as part of the stack is uninitialized

132
00:05:24,800 --> 00:05:26,960
the sensitive data is not erased from

133
00:05:26,960 --> 00:05:28,160
the stack

134
00:05:28,160 --> 00:05:30,880
later on when part of the stack is

135
00:05:30,880 --> 00:05:33,280
copied to user space the incentive data

136
00:05:33,280 --> 00:05:34,880
is leaked

137
00:05:34,880 --> 00:05:36,720
last year a stack-based information

138
00:05:36,720 --> 00:05:40,000
leaking in a2 mp of bluetooth is

139
00:05:40,000 --> 00:05:41,759
discovered basically practicing

140
00:05:41,759 --> 00:05:44,160
practicing this idea

141
00:05:44,160 --> 00:05:46,160
to circumvent this leaking there have

142
00:05:46,160 --> 00:05:48,240
been proposed many protections for

143
00:05:48,240 --> 00:05:50,720
example randomize the base address of

144
00:05:50,720 --> 00:05:53,120
kernel stack so that the two system

145
00:05:53,120 --> 00:05:55,120
calls are not using the same memory

146
00:05:55,120 --> 00:05:56,319
region

147
00:05:56,319 --> 00:05:58,160
the two protections are mentioned up

148
00:05:58,160 --> 00:06:00,720
here for another approach which is to

149
00:06:00,720 --> 00:06:03,039
poison the constant at the end of system

150
00:06:03,039 --> 00:06:04,319
call

151
00:06:04,319 --> 00:06:06,400
since a sensitive data is erased the

152
00:06:06,400 --> 00:06:08,800
advisory cannot use the

153
00:06:08,800 --> 00:06:11,039
uninitialized stack bug in a second

154
00:06:11,039 --> 00:06:13,120
system called leak data

155
00:06:13,120 --> 00:06:14,400
the difference between the two

156
00:06:14,400 --> 00:06:16,880
mitigations are that the former is

157
00:06:16,880 --> 00:06:19,440
implemented in gcc plugin and the latter

158
00:06:19,440 --> 00:06:21,759
is in chrono codebase

159
00:06:21,759 --> 00:06:23,680
and also the former poison the whole

160
00:06:23,680 --> 00:06:26,000
stack and the lateral only eraser stack

161
00:06:26,000 --> 00:06:28,240
region that has been used in this system

162
00:06:28,240 --> 00:06:30,080
call

163
00:06:30,080 --> 00:06:32,720
no matter which mitigations you used

164
00:06:32,720 --> 00:06:35,199
both have the limitation that it only

165
00:06:35,199 --> 00:06:38,240
works for multi-system core stack attack

166
00:06:38,240 --> 00:06:39,280
because

167
00:06:39,280 --> 00:06:41,360
poisoning happens at the end of system

168
00:06:41,360 --> 00:06:42,319
call

169
00:06:42,319 --> 00:06:44,800
if adversary can read the data before

170
00:06:44,800 --> 00:06:47,120
returning back to user space information

171
00:06:47,120 --> 00:06:49,360
leaking is still doable

172
00:06:49,360 --> 00:06:51,199
in the exploitation approach i'm going

173
00:06:51,199 --> 00:06:53,759
to describe in this presentation a limit

174
00:06:53,759 --> 00:06:55,919
the right primitive on current heap can

175
00:06:55,919 --> 00:06:58,720
be used to leak the data on stack in one

176
00:06:58,720 --> 00:07:00,960
system call that you not using in

177
00:07:00,960 --> 00:07:04,318
unusualized stack bug

178
00:07:04,479 --> 00:07:06,639
on slab slab allocator one of the

179
00:07:06,639 --> 00:07:09,520
protections is config slab furious

180
00:07:09,520 --> 00:07:10,560
hardened

181
00:07:10,560 --> 00:07:12,720
this protection introduced includes

182
00:07:12,720 --> 00:07:15,039
three patches and i showed them diagram

183
00:07:15,039 --> 00:07:17,759
of one patch on the slide

184
00:07:17,759 --> 00:07:20,000
the three slots in slab allocator are

185
00:07:20,000 --> 00:07:22,720
chained using a singly linked list the

186
00:07:22,720 --> 00:07:25,280
head of the list is named free list

187
00:07:25,280 --> 00:07:27,919
when a slot is in three status the first

188
00:07:27,919 --> 00:07:30,319
eight bytes are used to store the edges

189
00:07:30,319 --> 00:07:32,880
of the next slot in the list this is

190
00:07:32,880 --> 00:07:36,080
situation before the patch is applied

191
00:07:36,080 --> 00:07:38,400
after the patch is applied the first 8

192
00:07:38,400 --> 00:07:41,360
bytes of the fluid slot stores xor

193
00:07:41,360 --> 00:07:44,400
result of first the address of nexus

194
00:07:44,400 --> 00:07:46,319
slot which is short

195
00:07:46,319 --> 00:07:49,759
363 in the diagram second address of the

196
00:07:49,759 --> 00:07:52,400
free list head and third the random

197
00:07:52,400 --> 00:07:53,840
number

198
00:07:53,840 --> 00:07:56,000
without the patch the adversary can

199
00:07:56,000 --> 00:07:58,319
forge a fake address using hip buffer

200
00:07:58,319 --> 00:08:00,879
overflow and misleads the kernel to

201
00:08:00,879 --> 00:08:03,199
return the memory region indicated by

202
00:08:03,199 --> 00:08:06,000
the fake address in the next allocation

203
00:08:06,000 --> 00:08:08,960
this allows adversary to temper the data

204
00:08:08,960 --> 00:08:11,039
stored in the fake address

205
00:08:11,039 --> 00:08:13,280
however with this patch the kernel will

206
00:08:13,280 --> 00:08:15,440
calculate the address of next freight

207
00:08:15,440 --> 00:08:18,160
slot by reversing xor

208
00:08:18,160 --> 00:08:20,319
by reversing xor's data in the first

209
00:08:20,319 --> 00:08:21,599
eight bytes

210
00:08:21,599 --> 00:08:23,759
even if the adversary can forge the data

211
00:08:23,759 --> 00:08:25,680
using heap of buffer overflow the

212
00:08:25,680 --> 00:08:28,080
calculated address is not what the

213
00:08:28,080 --> 00:08:29,360
address wants

214
00:08:29,360 --> 00:08:31,840
this is because the random number is

215
00:08:31,840 --> 00:08:34,399
involved in the calculation

216
00:08:34,399 --> 00:08:36,958
according to one study early last year

217
00:08:36,958 --> 00:08:39,519
the entropy of the hardening is very low

218
00:08:39,519 --> 00:08:43,200
and thus forging an address is possible

219
00:08:43,200 --> 00:08:45,279
as complement in the exploitation

220
00:08:45,279 --> 00:08:46,959
approach i will describe in this

221
00:08:46,959 --> 00:08:49,839
presentation the first eight bytes of

222
00:08:49,839 --> 00:08:52,320
xor can be leaked with the limited right

223
00:08:52,320 --> 00:08:54,480
primitive on kernel heap

224
00:08:54,480 --> 00:08:56,880
the leakage eight bytes can then be used

225
00:08:56,880 --> 00:08:58,320
for forging

226
00:08:58,320 --> 00:09:00,720
i caused eight bytes as hip cookie in

227
00:09:00,720 --> 00:09:02,720
the following slides

228
00:09:02,720 --> 00:09:05,200
due to this weakness weakness the use

229
00:09:05,200 --> 00:09:07,120
the kernel has further hardened the key

230
00:09:07,120 --> 00:09:09,720
cookie design after version

231
00:09:09,720 --> 00:09:13,040
5.6.4 similar ideas also adopted in

232
00:09:13,040 --> 00:09:13,920
excel

233
00:09:13,920 --> 00:09:18,079
xnu using a different implementation

234
00:09:18,560 --> 00:09:20,959
another protection on slab's lab is a

235
00:09:20,959 --> 00:09:24,880
pair of initial analog and initial r3

236
00:09:24,880 --> 00:09:26,560
these two mitigations show some

237
00:09:26,560 --> 00:09:28,880
similarities with the stack poisoning

238
00:09:28,880 --> 00:09:31,680
we've discussed in the previous slides

239
00:09:31,680 --> 00:09:34,080
like kernel stack the heap object

240
00:09:34,080 --> 00:09:36,560
included scientific data like function

241
00:09:36,560 --> 00:09:39,360
pointer and keys for encryption

242
00:09:39,360 --> 00:09:41,440
without the protection the content in

243
00:09:41,440 --> 00:09:44,320
the heap object is left unchanged after

244
00:09:44,320 --> 00:09:46,800
the object is freed

245
00:09:46,800 --> 00:09:49,279
later when the slot holding object is

246
00:09:49,279 --> 00:09:51,600
recycled for the following allocations

247
00:09:51,600 --> 00:09:54,320
the advisory can use an uninitialized

248
00:09:54,320 --> 00:09:56,640
heap bug to leak the data

249
00:09:56,640 --> 00:09:58,640
to this end the two mitigations are

250
00:09:58,640 --> 00:10:01,279
responsible for reserving out the heap

251
00:10:01,279 --> 00:10:03,279
object at the time of freeing and

252
00:10:03,279 --> 00:10:05,680
reallocation respectively

253
00:10:05,680 --> 00:10:08,240
as such the sensitive data is removed

254
00:10:08,240 --> 00:10:11,600
and legal data is all zeroed out

255
00:10:11,600 --> 00:10:14,079
the two protections work for use of the

256
00:10:14,079 --> 00:10:15,760
free exploitation and double free

257
00:10:15,760 --> 00:10:18,399
exploitation because the two types of

258
00:10:18,399 --> 00:10:20,640
vulnerability needed to reason about

259
00:10:20,640 --> 00:10:22,720
freeing and reallocation

260
00:10:22,720 --> 00:10:25,360
however when the key object is in use

261
00:10:25,360 --> 00:10:27,600
the sensitive data is stored on kernel

262
00:10:27,600 --> 00:10:28,720
heap

263
00:10:28,720 --> 00:10:30,399
this gave us the chance to reach the

264
00:10:30,399 --> 00:10:32,800
sensitive data in the hip object using

265
00:10:32,800 --> 00:10:34,959
the leak primitive obtained from limited

266
00:10:34,959 --> 00:10:36,320
right primitive

267
00:10:36,320 --> 00:10:40,480
i will elaborate on this later

268
00:10:40,720 --> 00:10:42,640
the next protection i want to describe

269
00:10:42,640 --> 00:10:45,680
is k-a-s-r colon address space layout

270
00:10:45,680 --> 00:10:48,880
randomization on a slide i show part of

271
00:10:48,880 --> 00:10:50,800
the color memory layout

272
00:10:50,800 --> 00:10:53,040
with this protection the loaded colony

273
00:10:53,040 --> 00:10:55,760
text image could be anywhere from a to

274
00:10:55,760 --> 00:10:57,680
zero to schedule zero as long as it

275
00:10:57,680 --> 00:11:00,560
complies with alignment policy

276
00:11:00,560 --> 00:11:02,480
loaded and column modules could be

277
00:11:02,480 --> 00:11:05,839
anywhere from set to 0 to say to 0 to 4

278
00:11:05,839 --> 00:11:08,640
to 0 as long as it complies with

279
00:11:08,640 --> 00:11:10,640
alignment policy 2.

280
00:11:10,640 --> 00:11:13,600
this is the situation of x64 and other

281
00:11:13,600 --> 00:11:15,839
architectures are similar

282
00:11:15,839 --> 00:11:19,519
kasr is adopted in xnu and windows

283
00:11:19,519 --> 00:11:22,160
this protection works because it's very

284
00:11:22,160 --> 00:11:24,880
hard for those exploitation approaches

285
00:11:24,880 --> 00:11:27,440
to reliably jump to the target code if

286
00:11:27,440 --> 00:11:28,720
they want to execute current

287
00:11:28,720 --> 00:11:31,360
instructions for managers ago

288
00:11:31,360 --> 00:11:34,000
to defeat this protection the commonly

289
00:11:34,000 --> 00:11:36,320
commonly used approach is to leak the

290
00:11:36,320 --> 00:11:38,800
address of a global variable or function

291
00:11:38,800 --> 00:11:40,880
point or function

292
00:11:40,880 --> 00:11:42,880
then the adversary can calculate the

293
00:11:42,880 --> 00:11:45,680
base address of loaded current image or

294
00:11:45,680 --> 00:11:47,600
module through offset

295
00:11:47,600 --> 00:11:50,399
that's why i say in the previous slides

296
00:11:50,399 --> 00:11:52,240
the return address and the function

297
00:11:52,240 --> 00:11:54,639
pointer are sensitive data because they

298
00:11:54,639 --> 00:11:57,360
store their address or functions

299
00:11:57,360 --> 00:12:00,000
once their value is leakage kasr can be

300
00:12:00,000 --> 00:12:02,560
bypassed this is the first shortcoming

301
00:12:02,560 --> 00:12:04,399
of kscr

302
00:12:04,399 --> 00:12:06,480
another shortcoming is low entropy

303
00:12:06,480 --> 00:12:08,639
because there are only so many locations

304
00:12:08,639 --> 00:12:10,240
a current conflicting

305
00:12:10,240 --> 00:12:12,240
someone thinks attacker can guess the

306
00:12:12,240 --> 00:12:15,120
base address without too much trouble

307
00:12:15,120 --> 00:12:18,800
as such kslr in function in kslr in

308
00:12:18,800 --> 00:12:20,320
functional

309
00:12:20,320 --> 00:12:22,480
granularity is proposed

310
00:12:22,480 --> 00:12:24,639
i cannot go into details of this new

311
00:12:24,639 --> 00:12:26,079
protection because it's still in

312
00:12:26,079 --> 00:12:28,880
development the main idea is to

313
00:12:28,880 --> 00:12:30,880
randomize address or functions when

314
00:12:30,880 --> 00:12:32,880
loading the current image

315
00:12:32,880 --> 00:12:34,639
the entropy is much higher in this

316
00:12:34,639 --> 00:12:37,440
granularity and one leaking is far away

317
00:12:37,440 --> 00:12:39,839
from being enough to defeat this fine

318
00:12:39,839 --> 00:12:43,120
granularity protection

319
00:12:43,839 --> 00:12:46,079
apart from protections which rely on

320
00:12:46,079 --> 00:12:48,480
hiding sensitive data on this page i

321
00:12:48,480 --> 00:12:50,720
list the two types of synthetic data

322
00:12:50,720 --> 00:12:52,639
that can be leakaged from corner from

323
00:12:52,639 --> 00:12:56,880
kernel according to andrew's exploit

324
00:12:56,880 --> 00:13:00,000
the first is the content of the file

325
00:13:00,000 --> 00:13:03,120
etc shadow in the key ring demo

326
00:13:03,120 --> 00:13:05,279
this file stores a hashed value of the

327
00:13:05,279 --> 00:13:06,880
user's passwords

328
00:13:06,880 --> 00:13:09,360
the adversary can use hash collision to

329
00:13:09,360 --> 00:13:11,680
reverse engineer the hashed value and

330
00:13:11,680 --> 00:13:13,519
obtain the password

331
00:13:13,519 --> 00:13:15,920
the earner of this file is root and the

332
00:13:15,920 --> 00:13:17,519
group is shadow

333
00:13:17,519 --> 00:13:20,000
with a leak primitive advisory can scan

334
00:13:20,000 --> 00:13:22,079
physical memory to search for the

335
00:13:22,079 --> 00:13:24,399
pattern because the first entry of the

336
00:13:24,399 --> 00:13:27,040
file is always for root and

337
00:13:27,040 --> 00:13:30,000
loaded to the beginning of the page

338
00:13:30,000 --> 00:13:33,120
the second is interrupt descriptor table

339
00:13:33,120 --> 00:13:35,440
when interrupt happens the kernel will

340
00:13:35,440 --> 00:13:37,360
jump to the interrupt procedure for

341
00:13:37,360 --> 00:13:38,639
further process

342
00:13:38,639 --> 00:13:40,959
the offset to the procedural entry is

343
00:13:40,959 --> 00:13:42,639
stopped in the table

344
00:13:42,639 --> 00:13:45,360
if the adversary can leak offset he or

345
00:13:45,360 --> 00:13:47,680
she can calculate the base edges of

346
00:13:47,680 --> 00:13:51,519
loaded kernel image and thus bypass kslr

347
00:13:51,519 --> 00:13:53,600
there are many other types of sensitive

348
00:13:53,600 --> 00:13:55,839
data in kernel due to the time limit i

349
00:13:55,839 --> 00:13:58,160
cannot enumerate them and i'm happy to

350
00:13:58,160 --> 00:14:00,240
learn more if you know know more about

351
00:14:00,240 --> 00:14:02,639
them

352
00:14:02,639 --> 00:14:04,399
the exploitation approach i want to

353
00:14:04,399 --> 00:14:07,680
describe today is not a new attack it is

354
00:14:07,680 --> 00:14:10,959
used in pong2 on 2017

355
00:14:10,959 --> 00:14:14,680
for cve 2017-7184

356
00:14:15,279 --> 00:14:16,800
in the exploitation of this

357
00:14:16,800 --> 00:14:19,199
vulnerability the attacker uses a

358
00:14:19,199 --> 00:14:21,760
flexible structure named transform the

359
00:14:21,760 --> 00:14:23,920
play state esn

360
00:14:23,920 --> 00:14:26,399
as shown in the diagram on the slide

361
00:14:26,399 --> 00:14:29,120
this structure has two fields one field

362
00:14:29,120 --> 00:14:31,519
is build map length which is an integer

363
00:14:31,519 --> 00:14:33,519
and another it is bin map which is a

364
00:14:33,519 --> 00:14:34,639
buffer

365
00:14:34,639 --> 00:14:36,800
the length of a build map is determined

366
00:14:36,800 --> 00:14:38,959
dynamically and indicated by bitmap

367
00:14:38,959 --> 00:14:40,000
length

368
00:14:40,000 --> 00:14:42,560
when kernel uses a structure it obtained

369
00:14:42,560 --> 00:14:46,079
the length beta map from bitmap length

370
00:14:46,079 --> 00:14:48,240
to do the exploitation the attacker

371
00:14:48,240 --> 00:14:50,480
performs hip feng shui and places

372
00:14:50,480 --> 00:14:53,440
transform replace steady esn right after

373
00:14:53,440 --> 00:14:55,360
the vulnerable object

374
00:14:55,360 --> 00:14:57,279
then the tackle triggers the keep above

375
00:14:57,279 --> 00:15:00,320
overflow to overwrite bitmap length

376
00:15:00,320 --> 00:15:02,959
the bitmap lens is enlarged and the mix

377
00:15:02,959 --> 00:15:05,440
leads the kernel to believe the size of

378
00:15:05,440 --> 00:15:09,040
bin map is larger than actual size

379
00:15:09,040 --> 00:15:11,920
later when retrieve receive messages

380
00:15:11,920 --> 00:15:14,000
system call comes the content in the

381
00:15:14,000 --> 00:15:16,880
bitmap is copied to the user space while

382
00:15:16,880 --> 00:15:19,040
narrowing the put function

383
00:15:19,040 --> 00:15:21,839
since the bitmap length is enlarged the

384
00:15:21,839 --> 00:15:24,320
heap region after the bitmap is also

385
00:15:24,320 --> 00:15:27,120
copied out causing an overread

386
00:15:27,120 --> 00:15:30,079
the attacker places a 5 structure after

387
00:15:30,079 --> 00:15:31,199
bitmap

388
00:15:31,199 --> 00:15:32,720
the file structure has a function

389
00:15:32,720 --> 00:15:35,759
pointer field named fop which points to

390
00:15:35,759 --> 00:15:39,680
a static variable ext4 file operations

391
00:15:39,680 --> 00:15:41,360
by leaking the value value of the

392
00:15:41,360 --> 00:15:44,000
function pointer the attacker knows the

393
00:15:44,000 --> 00:15:46,560
address of a static variable and then

394
00:15:46,560 --> 00:15:48,639
calculates the base edges of loaded

395
00:15:48,639 --> 00:15:51,680
current image for bypass kscr

396
00:15:51,680 --> 00:15:54,320
the flexible object has two advantages

397
00:15:54,320 --> 00:15:55,839
in exploitation

398
00:15:55,839 --> 00:15:58,560
one is its ability to dig data another

399
00:15:58,560 --> 00:16:01,279
is the size of object can be determined

400
00:16:01,279 --> 00:16:02,880
dynamically

401
00:16:02,880 --> 00:16:04,639
so it can be allocated to several

402
00:16:04,639 --> 00:16:06,959
general caches to be paired with

403
00:16:06,959 --> 00:16:10,959
vulnerable object and victim object

404
00:16:10,959 --> 00:16:13,519
the same attack is observed in linux

405
00:16:13,519 --> 00:16:15,680
windows kernel exploitation

406
00:16:15,680 --> 00:16:18,079
the example on the slide is a one from a

407
00:16:18,079 --> 00:16:21,199
previous blackhead asia talk by u1

408
00:16:21,199 --> 00:16:23,680
in this exploitation the attack code

409
00:16:23,680 --> 00:16:25,680
uses the use of the free

410
00:16:25,680 --> 00:16:29,040
tag pro plot list to override c entries

411
00:16:29,040 --> 00:16:32,079
and i first three fields in the zombie

412
00:16:32,079 --> 00:16:34,000
tag prop list

413
00:16:34,000 --> 00:16:36,160
tag prob list happens to be an elastic

414
00:16:36,160 --> 00:16:38,079
structure similar to the one in the

415
00:16:38,079 --> 00:16:39,759
previous slide

416
00:16:39,759 --> 00:16:42,639
c entries the lens field and i first

417
00:16:42,639 --> 00:16:45,040
free is a flexible buffer

418
00:16:45,040 --> 00:16:46,959
after corrupting c entries and the

419
00:16:46,959 --> 00:16:50,399
iphone's free fields the taco continues

420
00:16:50,399 --> 00:16:53,759
to the right attack wnd object to obtain

421
00:16:53,759 --> 00:16:55,839
arbitrary read and write

422
00:16:55,839 --> 00:16:58,720
from this example we know that elastic

423
00:16:58,720 --> 00:17:01,440
object attack is not specific to linux

424
00:17:01,440 --> 00:17:04,000
but also other os kernels because the

425
00:17:04,000 --> 00:17:06,880
implementation of elastic objects follow

426
00:17:06,880 --> 00:17:09,679
similar patterns

427
00:17:09,679 --> 00:17:12,079
before we describe what else we can do

428
00:17:12,079 --> 00:17:14,959
using elastic objects we investigate its

429
00:17:14,959 --> 00:17:17,119
implementation patterns

430
00:17:17,119 --> 00:17:18,959
on the slide i should display three

431
00:17:18,959 --> 00:17:21,039
other ways of implementing elastic

432
00:17:21,039 --> 00:17:23,760
objects the first way is to have a large

433
00:17:23,760 --> 00:17:25,760
buffer defined in the middle of a data

434
00:17:25,760 --> 00:17:26,799
object

435
00:17:26,799 --> 00:17:28,960
the length field within that object

436
00:17:28,960 --> 00:17:31,760
indicates actual buffer size or more

437
00:17:31,760 --> 00:17:34,559
precisely speaking the actual about

438
00:17:34,559 --> 00:17:37,520
actual bytes used for storing data

439
00:17:37,520 --> 00:17:39,280
at the time of defining the actual

440
00:17:39,280 --> 00:17:42,160
number of bytes used for storing data

441
00:17:42,160 --> 00:17:44,080
chrono typically examines the length

442
00:17:44,080 --> 00:17:46,559
field and ensures it doesn't go beyond

443
00:17:46,559 --> 00:17:49,200
the boundary of the large buffer

444
00:17:49,200 --> 00:17:51,679
however we discover that the kernel

445
00:17:51,679 --> 00:17:54,400
doesn't always enforce this check at the

446
00:17:54,400 --> 00:17:57,280
time of reading data from that buffer

447
00:17:57,280 --> 00:18:00,400
as such it eases and tackles ability to

448
00:18:00,400 --> 00:18:02,640
manipulate the length field and thus

449
00:18:02,640 --> 00:18:05,039
construct a buffer overread

450
00:18:05,039 --> 00:18:07,200
in the second and third way the eq

451
00:18:07,200 --> 00:18:09,440
implementations do not enclose the lens

452
00:18:09,440 --> 00:18:11,440
field and the flexible buffer in the

453
00:18:11,440 --> 00:18:14,400
same kernel object instead they place

454
00:18:14,400 --> 00:18:16,640
the lens field and the flexible buffer

455
00:18:16,640 --> 00:18:19,120
in two individual cone objects

456
00:18:19,120 --> 00:18:21,280
the difference in that the second

457
00:18:21,280 --> 00:18:23,760
implementation contains an explicit

458
00:18:23,760 --> 00:18:26,240
reference to the flexible buffer while

459
00:18:26,240 --> 00:18:28,320
the third implementation references the

460
00:18:28,320 --> 00:18:30,400
flexible buffer through a third

461
00:18:30,400 --> 00:18:34,000
intermediate kernel object

462
00:18:34,720 --> 00:18:36,640
now let's see what we can do using

463
00:18:36,640 --> 00:18:38,320
elastic objects

464
00:18:38,320 --> 00:18:40,559
the assumption of this attack is that

465
00:18:40,559 --> 00:18:42,160
we've already obtained the right

466
00:18:42,160 --> 00:18:43,840
primitive on kernel heap

467
00:18:43,840 --> 00:18:46,160
we use that right primitive to tempo the

468
00:18:46,160 --> 00:18:49,120
lens field as well as the point of field

469
00:18:49,120 --> 00:18:50,000
later

470
00:18:50,000 --> 00:18:52,480
the value of lens field is propagated to

471
00:18:52,480 --> 00:18:56,000
the size argument of copy user function

472
00:18:56,000 --> 00:18:58,559
copy user function has three arguments

473
00:18:58,559 --> 00:19:00,880
the first argument is destination

474
00:19:00,880 --> 00:19:03,840
indicating where the data is copied to

475
00:19:03,840 --> 00:19:06,559
the second argument is source which

476
00:19:06,559 --> 00:19:09,200
indicates where the data is copied from

477
00:19:09,200 --> 00:19:11,360
the third argument is size which

478
00:19:11,360 --> 00:19:13,360
represents how many bytes of data to

479
00:19:13,360 --> 00:19:14,640
copy

480
00:19:14,640 --> 00:19:16,720
now we've already controlled the size

481
00:19:16,720 --> 00:19:18,000
argument

482
00:19:18,000 --> 00:19:20,080
on the right side of the slide i show

483
00:19:20,080 --> 00:19:22,559
three situations where the source could

484
00:19:22,559 --> 00:19:25,840
come from the first situation is the

485
00:19:25,840 --> 00:19:28,080
soft argument is the address of corner

486
00:19:28,080 --> 00:19:29,039
stack

487
00:19:29,039 --> 00:19:31,520
in this situation if we enlarge the size

488
00:19:31,520 --> 00:19:33,919
value using the right primitive we can

489
00:19:33,919 --> 00:19:35,919
over read the kernel stack and leak the

490
00:19:35,919 --> 00:19:38,400
stack canary and return address to user

491
00:19:38,400 --> 00:19:40,240
space

492
00:19:40,240 --> 00:19:42,320
the second situation is a source

493
00:19:42,320 --> 00:19:44,960
argument in the address of conor heap

494
00:19:44,960 --> 00:19:46,960
we can ever read the corner heap to

495
00:19:46,960 --> 00:19:49,120
disclose function pointer and keep

496
00:19:49,120 --> 00:19:50,960
cookie

497
00:19:50,960 --> 00:19:52,880
the third situation is the source

498
00:19:52,880 --> 00:19:55,039
argument is from the point of field in

499
00:19:55,039 --> 00:19:58,080
elastic object and is also tempered by

500
00:19:58,080 --> 00:20:01,280
the adversary using the right primitive

501
00:20:01,280 --> 00:20:03,600
in this situation we can make the source

502
00:20:03,600 --> 00:20:06,559
argument to be any current address as

503
00:20:06,559 --> 00:20:09,280
such we can leak sensitive data like etc

504
00:20:09,280 --> 00:20:11,919
shadow or interrupt descriptor table

505
00:20:11,919 --> 00:20:15,679
which we mentioned in the previous slide

506
00:20:15,679 --> 00:20:18,480
the severity of this attack is obvious

507
00:20:18,480 --> 00:20:20,480
if the adversary has limited the right

508
00:20:20,480 --> 00:20:22,720
primitive on current heap by triggering

509
00:20:22,720 --> 00:20:25,280
the vulnerabilities like slab outer

510
00:20:25,280 --> 00:20:27,280
bound right use of the free and a double

511
00:20:27,280 --> 00:20:29,760
free he or she can transfer this right

512
00:20:29,760 --> 00:20:32,799
primitive to obtain a leak primitive

513
00:20:32,799 --> 00:20:35,280
this capability enables adversary to

514
00:20:35,280 --> 00:20:37,600
leak stationary written address

515
00:20:37,600 --> 00:20:40,480
encrypted heap cookies function pointer

516
00:20:40,480 --> 00:20:43,120
etc shadow interrupts descriptor table

517
00:20:43,120 --> 00:20:45,440
and many other scientific data

518
00:20:45,440 --> 00:20:47,760
with recent data in hand it becomes

519
00:20:47,760 --> 00:20:49,919
easier for the tackle to perform

520
00:20:49,919 --> 00:20:53,440
following exploitation steps

521
00:20:53,440 --> 00:20:56,000
regarding generality of this attack it's

522
00:20:56,000 --> 00:20:58,000
unknown unfortunately

523
00:20:58,000 --> 00:21:00,240
first we don't know what else channel

524
00:21:00,240 --> 00:21:03,440
functions in kernel like copy to user

525
00:21:03,440 --> 00:21:05,679
can provide us with the ability to

526
00:21:05,679 --> 00:21:07,520
communicate between kernel space and

527
00:21:07,520 --> 00:21:09,679
user space

528
00:21:09,679 --> 00:21:12,080
second how many elastic structures and

529
00:21:12,080 --> 00:21:13,840
objects are there in the kernel code

530
00:21:13,840 --> 00:21:14,720
base

531
00:21:14,720 --> 00:21:16,799
if we only have two or three it's very

532
00:21:16,799 --> 00:21:19,360
hard to it's very hard to cover most

533
00:21:19,360 --> 00:21:20,799
slab caches

534
00:21:20,799 --> 00:21:22,880
let alone to say pairing them with

535
00:21:22,880 --> 00:21:24,799
vulnerability

536
00:21:24,799 --> 00:21:26,880
the third question is even if we have

537
00:21:26,880 --> 00:21:29,280
enough elastic structures it doesn't

538
00:21:29,280 --> 00:21:31,360
mean the lens field and the point of

539
00:21:31,360 --> 00:21:33,440
field of them can be propagated to the

540
00:21:33,440 --> 00:21:34,960
channel functions

541
00:21:34,960 --> 00:21:37,679
without this guarantee the adversary can

542
00:21:37,679 --> 00:21:40,240
hardly control the size argument as well

543
00:21:40,240 --> 00:21:42,080
as a source argument

544
00:21:42,080 --> 00:21:44,720
the last question giving a vulnerability

545
00:21:44,720 --> 00:21:46,559
does it provide us with the right

546
00:21:46,559 --> 00:21:48,799
primitive to override the length field

547
00:21:48,799 --> 00:21:50,960
and the point of field it's possible

548
00:21:50,960 --> 00:21:53,120
that most vulnerabilities don't have

549
00:21:53,120 --> 00:21:55,840
that strong capability

550
00:21:55,840 --> 00:21:57,919
however general relative problem is of

551
00:21:57,919 --> 00:22:00,720
vital importance because it is related

552
00:22:00,720 --> 00:22:02,880
to the question that do we need to pay

553
00:22:02,880 --> 00:22:05,039
attention to this attack and do we need

554
00:22:05,039 --> 00:22:07,840
to make need a new mitigation

555
00:22:07,840 --> 00:22:10,400
if the attack is very ad hoc i don't see

556
00:22:10,400 --> 00:22:13,200
any necessity to build a new mitigation

557
00:22:13,200 --> 00:22:16,159
probably simple patching is enough

558
00:22:16,159 --> 00:22:18,960
as such our research work many focuses

559
00:22:18,960 --> 00:22:20,720
on studying the generality of this

560
00:22:20,720 --> 00:22:21,840
attack

561
00:22:21,840 --> 00:22:23,919
we define generality from two

562
00:22:23,919 --> 00:22:25,280
perspectives

563
00:22:25,280 --> 00:22:27,440
first if there are enough number of

564
00:22:27,440 --> 00:22:30,159
elastic objects in the kernel and second

565
00:22:30,159 --> 00:22:32,960
can most vulnerabilities provide us with

566
00:22:32,960 --> 00:22:36,159
the capability to make use of elastic

567
00:22:36,159 --> 00:22:39,799
object for exploitation

568
00:22:40,000 --> 00:22:42,480
first things first we identify some

569
00:22:42,480 --> 00:22:44,880
channel functions in the kernel and list

570
00:22:44,880 --> 00:22:46,880
them on the slide

571
00:22:46,880 --> 00:22:50,720
we group them into three categories

572
00:22:52,559 --> 00:22:55,120
the first one is memory access api which

573
00:22:55,120 --> 00:22:57,520
is copy to user the second one is

574
00:22:57,520 --> 00:23:00,000
specific to net link socket which is a

575
00:23:00,000 --> 00:23:02,320
networking between kernel space and user

576
00:23:02,320 --> 00:23:03,520
space

577
00:23:03,520 --> 00:23:05,600
to use this functionality requires

578
00:23:05,600 --> 00:23:08,080
network and administration capability

579
00:23:08,080 --> 00:23:09,919
which is grant which can be granted in

580
00:23:09,919 --> 00:23:12,640
the user space username space

581
00:23:12,640 --> 00:23:14,640
so you don't worry about like you don't

582
00:23:14,640 --> 00:23:17,360
have the capability to use this socket

583
00:23:17,360 --> 00:23:19,440
uh for exploitation

584
00:23:19,440 --> 00:23:21,360
take that uh take the net link input

585
00:23:21,360 --> 00:23:23,120
function as example

586
00:23:23,120 --> 00:23:25,120
attribute length which is highlight

587
00:23:25,120 --> 00:23:27,360
highlighted with underlying

588
00:23:27,360 --> 00:23:30,000
is a size argument and a data which is

589
00:23:30,000 --> 00:23:33,039
in both the source argument

590
00:23:33,039 --> 00:23:35,440
the third one is general networking for

591
00:23:35,440 --> 00:23:38,799
example skb put data in which lengthy is

592
00:23:38,799 --> 00:23:40,799
a science argument and a data is a

593
00:23:40,799 --> 00:23:42,559
source argument

594
00:23:42,559 --> 00:23:44,000
some channel functions are the

595
00:23:44,000 --> 00:23:46,159
combination of two functions for example

596
00:23:46,159 --> 00:23:48,559
in netlink the return value of

597
00:23:48,559 --> 00:23:50,640
netiquette message data the source

598
00:23:50,640 --> 00:23:53,039
argument which is later used in memory

599
00:23:53,039 --> 00:23:54,480
copy function

600
00:23:54,480 --> 00:23:56,880
the size argument is count in memory

601
00:23:56,880 --> 00:23:58,159
copy

602
00:23:58,159 --> 00:24:00,240
no matter what the function prototypes

603
00:24:00,240 --> 00:24:02,640
are all of all of them have a source

604
00:24:02,640 --> 00:24:05,039
argument and a size argument

605
00:24:05,039 --> 00:24:07,440
our analysis begins from these channel

606
00:24:07,440 --> 00:24:09,840
functions

607
00:24:10,320 --> 00:24:13,120
the first step in our static analysis is

608
00:24:13,120 --> 00:24:16,400
to identify the leaking angle which is

609
00:24:16,400 --> 00:24:18,320
which is invoking to channel functions

610
00:24:18,320 --> 00:24:20,159
in the code base

611
00:24:20,159 --> 00:24:22,880
i use red to represent source argument

612
00:24:22,880 --> 00:24:25,120
and a green for a size argument in the

613
00:24:25,120 --> 00:24:26,480
channel function

614
00:24:26,480 --> 00:24:28,559
the first step is to check where is the

615
00:24:28,559 --> 00:24:29,679
lens flow

616
00:24:29,679 --> 00:24:31,840
in the diagram the lens is from a

617
00:24:31,840 --> 00:24:34,799
structural variable named u payload its

618
00:24:34,799 --> 00:24:37,360
type is user key payload

619
00:24:37,360 --> 00:24:39,360
the third step is to check where is the

620
00:24:39,360 --> 00:24:40,480
size from

621
00:24:40,480 --> 00:24:42,960
in the diagram the source is the return

622
00:24:42,960 --> 00:24:45,440
value of key malloc the type of the

623
00:24:45,440 --> 00:24:48,000
source is user key payload 2.

624
00:24:48,000 --> 00:24:50,080
we can clearly see that

625
00:24:50,080 --> 00:24:52,080
the source and the length are both from

626
00:24:52,080 --> 00:24:54,000
the same structure type

627
00:24:54,000 --> 00:24:55,679
besides we can learn that this

628
00:24:55,679 --> 00:24:58,080
structural variable is on heap because

629
00:24:58,080 --> 00:25:00,480
it is generated through allocation

630
00:25:00,480 --> 00:25:02,720
what's more user key payload is a

631
00:25:02,720 --> 00:25:04,960
standard flexible structure because its

632
00:25:04,960 --> 00:25:07,600
size is a constant plus variable

633
00:25:07,600 --> 00:25:09,840
the offset of the length field and the

634
00:25:09,840 --> 00:25:12,960
flexible buffer can also be tracked up

635
00:25:12,960 --> 00:25:15,520
through above analysis we can learn that

636
00:25:15,520 --> 00:25:17,200
we can learn which slab cache is

637
00:25:17,200 --> 00:25:19,679
responsible for holding the object

638
00:25:19,679 --> 00:25:22,640
so the user key payload is exactly the

639
00:25:22,640 --> 00:25:24,320
elastic structure that we are searching

640
00:25:24,320 --> 00:25:26,240
for

641
00:25:26,240 --> 00:25:28,400
the last step of the analysis is to

642
00:25:28,400 --> 00:25:30,559
collapse the constraints along the path

643
00:25:30,559 --> 00:25:33,360
from the ankle retrievals to anchor the

644
00:25:33,360 --> 00:25:34,880
leaks data

645
00:25:34,880 --> 00:25:37,360
we do this examination because we want

646
00:25:37,360 --> 00:25:39,919
to see whether the kernel enforces the

647
00:25:39,919 --> 00:25:42,720
checking of lens fields if the if the

648
00:25:42,720 --> 00:25:44,799
kind of thing says hey the length cannot

649
00:25:44,799 --> 00:25:46,640
be too large the leaking property

650
00:25:46,640 --> 00:25:48,000
doesn't work

651
00:25:48,000 --> 00:25:50,240
in example on the slides the current

652
00:25:50,240 --> 00:25:52,480
only ensures that a user can show the

653
00:25:52,480 --> 00:25:53,679
parameter

654
00:25:53,679 --> 00:25:55,440
buffer length is larger than the data

655
00:25:55,440 --> 00:25:56,320
length

656
00:25:56,320 --> 00:25:57,919
therefore this checking doesn't

657
00:25:57,919 --> 00:26:01,279
influence the data leaking

658
00:26:01,679 --> 00:26:04,240
finally we obtain a record for each

659
00:26:04,240 --> 00:26:06,799
identified elastic structure we know the

660
00:26:06,799 --> 00:26:09,600
structure name the cache holdings object

661
00:26:09,600 --> 00:26:12,080
the offset of length field allocation

662
00:26:12,080 --> 00:26:14,640
sites leaking sites as well as what

663
00:26:14,640 --> 00:26:17,440
types of sensitive data can be leaked

664
00:26:17,440 --> 00:26:20,080
in total the static analysis tracks down

665
00:26:20,080 --> 00:26:22,240
49 elastic structures in default

666
00:26:22,240 --> 00:26:23,520
configuration

667
00:26:23,520 --> 00:26:25,600
we use kernel fuzzing and manual

668
00:26:25,600 --> 00:26:29,760
analysis confirmed 38 of them

669
00:26:29,760 --> 00:26:32,559
we list these structures here in a table

670
00:26:32,559 --> 00:26:35,520
the first column represents which case

671
00:26:35,520 --> 00:26:37,840
the object can reside in the second

672
00:26:37,840 --> 00:26:40,559
column the structure name the third is

673
00:26:40,559 --> 00:26:42,880
the offset of length field and pointer

674
00:26:42,880 --> 00:26:43,840
field

675
00:26:43,840 --> 00:26:45,919
the fourth is what scientific data can

676
00:26:45,919 --> 00:26:47,039
be leaked

677
00:26:47,039 --> 00:26:49,440
the fifth is the privilege required to

678
00:26:49,440 --> 00:26:52,080
operate the object and the last column

679
00:26:52,080 --> 00:26:53,919
is the path constraint

680
00:26:53,919 --> 00:26:56,559
to sum up most general caches are

681
00:26:56,559 --> 00:26:59,360
covered by our identified structures

682
00:26:59,360 --> 00:27:03,120
note that the number 36 and 38 are for

683
00:27:03,120 --> 00:27:05,840
structures not objects if we count the

684
00:27:05,840 --> 00:27:08,000
number of objects and the program sites

685
00:27:08,000 --> 00:27:10,559
that are used objects the statics can be

686
00:27:10,559 --> 00:27:11,840
thousands

687
00:27:11,840 --> 00:27:14,159
from this perspective the elastic

688
00:27:14,159 --> 00:27:18,799
objects are pervasive in kernel codebase

689
00:27:18,880 --> 00:27:21,760
we used 31 vulnerabilities to examine

690
00:27:21,760 --> 00:27:24,640
what we can do using elastic objects the

691
00:27:24,640 --> 00:27:26,480
results show that

692
00:27:26,480 --> 00:27:29,840
23 vulnerabilities is enabled with kscr

693
00:27:29,840 --> 00:27:32,720
bypassing and heap cookies leaking

694
00:27:32,720 --> 00:27:35,440
12 of them can leak stationary and five

695
00:27:35,440 --> 00:27:38,559
of them and perform actual read

696
00:27:38,559 --> 00:27:40,799
thus we want to join the conclusion that

697
00:27:40,799 --> 00:27:43,360
elastic object attack is general in

698
00:27:43,360 --> 00:27:46,240
linux kernel

699
00:27:46,320 --> 00:27:48,080
how about other operating systems

700
00:27:48,080 --> 00:27:49,120
kernels

701
00:27:49,120 --> 00:27:52,000
in xmu the static analysis tracks down

702
00:27:52,000 --> 00:27:55,840
16 structures in freebst

703
00:27:55,840 --> 00:28:00,480
and i mean freebsd we have 12 structures

704
00:28:00,480 --> 00:28:03,919
we use in total nine cves in freebsd and

705
00:28:03,919 --> 00:28:05,039
xnu

706
00:28:05,039 --> 00:28:07,919
five of them can bypass kslr four of

707
00:28:07,919 --> 00:28:10,480
them they keep cookies because freebsd

708
00:28:10,480 --> 00:28:12,880
doesn't have keep cookie three of them

709
00:28:12,880 --> 00:28:15,120
can perform arbitrary read

710
00:28:15,120 --> 00:28:17,520
it assumes elastic object attack is an

711
00:28:17,520 --> 00:28:19,840
issue not only in linux but also in

712
00:28:19,840 --> 00:28:23,360
freebsd and xmu

713
00:28:23,360 --> 00:28:26,240
someone may ask that we can use elastic

714
00:28:26,240 --> 00:28:28,320
object for leaking because the kernel

715
00:28:28,320 --> 00:28:30,320
data can be copied from kernel space to

716
00:28:30,320 --> 00:28:32,640
user space via channel functions like

717
00:28:32,640 --> 00:28:34,080
copy to user

718
00:28:34,080 --> 00:28:36,720
is it possible that we use elastic

719
00:28:36,720 --> 00:28:38,799
object for arbitrary writing using

720
00:28:38,799 --> 00:28:41,200
functions that copy data from user space

721
00:28:41,200 --> 00:28:42,799
to kernel space

722
00:28:42,799 --> 00:28:45,360
to answer this question i i add copy

723
00:28:45,360 --> 00:28:46,960
from user function to our static

724
00:28:46,960 --> 00:28:49,279
analysis and found three candidate

725
00:28:49,279 --> 00:28:50,399
structures

726
00:28:50,399 --> 00:28:53,200
the first is io vector a commonly used

727
00:28:53,200 --> 00:28:56,000
one however this structure is enforced

728
00:28:56,000 --> 00:28:59,120
with lens checking the two others are

729
00:28:59,120 --> 00:29:02,240
dmio control and fd table

730
00:29:02,240 --> 00:29:04,720
to overwrite requires data rays and the

731
00:29:04,720 --> 00:29:06,720
time windows is very small

732
00:29:06,720 --> 00:29:08,880
it's impractical to use them for

733
00:29:08,880 --> 00:29:10,399
arbitrary writing

734
00:29:10,399 --> 00:29:12,799
i want to emphasize that this study is

735
00:29:12,799 --> 00:29:14,880
limited because i don't include other

736
00:29:14,880 --> 00:29:17,760
functions in fact i know some exploits

737
00:29:17,760 --> 00:29:20,720
use elastic object to realize actually

738
00:29:20,720 --> 00:29:21,520
right

739
00:29:21,520 --> 00:29:24,159
i plan to leave it as my future work

740
00:29:24,159 --> 00:29:26,799
since we've released our code i also

741
00:29:26,799 --> 00:29:28,720
invite you to do some contribution if

742
00:29:28,720 --> 00:29:31,520
you are interested

743
00:29:32,399 --> 00:29:34,480
there are several mitigations in linux

744
00:29:34,480 --> 00:29:36,880
kernel that seems effective to prevent

745
00:29:36,880 --> 00:29:39,200
this elastic object attack

746
00:29:39,200 --> 00:29:41,039
the first potential mitigation is

747
00:29:41,039 --> 00:29:43,120
freeless to randomization

748
00:29:43,120 --> 00:29:45,600
without this mitigation the freed slots

749
00:29:45,600 --> 00:29:48,080
are chained in the list linearly

750
00:29:48,080 --> 00:29:50,080
this means the freed slots are

751
00:29:50,080 --> 00:29:51,919
physically continuous

752
00:29:51,919 --> 00:29:54,000
with this feature the adversary can

753
00:29:54,000 --> 00:29:56,399
predict the slab layout and perform

754
00:29:56,399 --> 00:29:58,480
stable hip function

755
00:29:58,480 --> 00:30:01,039
with this mitigation the three slots are

756
00:30:01,039 --> 00:30:04,399
shuffled when corners create a slab cast

757
00:30:04,399 --> 00:30:06,399
thus the order of three slots are

758
00:30:06,399 --> 00:30:09,039
randomized in this way the adversary

759
00:30:09,039 --> 00:30:11,600
cannot predict the kernel of predictive

760
00:30:11,600 --> 00:30:14,240
slab layout and it's harder for their

761
00:30:14,240 --> 00:30:16,799
hiroshi to exploit slab out of bound

762
00:30:16,799 --> 00:30:18,720
right vulnerability

763
00:30:18,720 --> 00:30:21,279
the limitations of these mitigations at

764
00:30:21,279 --> 00:30:24,000
first it has no effects on use of the

765
00:30:24,000 --> 00:30:26,720
free double free exploitation this is

766
00:30:26,720 --> 00:30:27,679
because

767
00:30:27,679 --> 00:30:29,840
the exploitation of these two bytes

768
00:30:29,840 --> 00:30:32,000
these two types doesn't require to

769
00:30:32,000 --> 00:30:33,840
predict slab layout

770
00:30:33,840 --> 00:30:35,919
and second there are many bypassing

771
00:30:35,919 --> 00:30:38,320
techniques against this mitigation for

772
00:30:38,320 --> 00:30:39,360
example

773
00:30:39,360 --> 00:30:42,080
groom which is to first allocate a bunch

774
00:30:42,080 --> 00:30:44,240
of placeholder objects and victim

775
00:30:44,240 --> 00:30:46,080
objects to the current heap the

776
00:30:46,080 --> 00:30:48,480
anniversary frees the placeholder

777
00:30:48,480 --> 00:30:51,039
objects and leaves holes on heap

778
00:30:51,039 --> 00:30:53,279
after this he or she can allocate the

779
00:30:53,279 --> 00:30:55,600
vulnerable object to the hose to perform

780
00:30:55,600 --> 00:30:57,039
hip function

781
00:30:57,039 --> 00:30:58,880
another technique to bypass the

782
00:30:58,880 --> 00:31:01,279
freelance randomization is the freelance

783
00:31:01,279 --> 00:31:03,600
reversal due to the time limit i will

784
00:31:03,600 --> 00:31:05,760
not elaborate on them in this

785
00:31:05,760 --> 00:31:07,840
presentation and more details can be

786
00:31:07,840 --> 00:31:10,639
found online

787
00:31:10,880 --> 00:31:13,760
the second potential mitigation is a

788
00:31:13,760 --> 00:31:16,799
config gcc plugin random structure this

789
00:31:16,799 --> 00:31:19,039
mitigation tries to randomize the order

790
00:31:19,039 --> 00:31:21,039
of fields in a structure under the

791
00:31:21,039 --> 00:31:22,720
compilation phase

792
00:31:22,720 --> 00:31:24,880
it prevents attackers from predicting

793
00:31:24,880 --> 00:31:27,120
the offset of scientific data within the

794
00:31:27,120 --> 00:31:28,480
structure

795
00:31:28,480 --> 00:31:30,320
take the structure on the slide as an

796
00:31:30,320 --> 00:31:32,880
example the attackers want to override

797
00:31:32,880 --> 00:31:35,279
function point of field initial to

798
00:31:35,279 --> 00:31:37,039
hijack control flow

799
00:31:37,039 --> 00:31:39,600
without the randomization the offset of

800
00:31:39,600 --> 00:31:41,840
the initial field is fixed and

801
00:31:41,840 --> 00:31:43,200
predictable

802
00:31:43,200 --> 00:31:45,519
with the randomization the initial field

803
00:31:45,519 --> 00:31:47,760
is shuffled to another order

804
00:31:47,760 --> 00:31:50,480
thus the override doesn't always work

805
00:31:50,480 --> 00:31:53,039
as such this mitigation seems a threat

806
00:31:53,039 --> 00:31:55,279
to the tackle

807
00:31:55,279 --> 00:31:57,600
however i want to say that this defense

808
00:31:57,600 --> 00:31:59,519
relies on a random seed to perform

809
00:31:59,519 --> 00:32:02,320
randomization and the protection of this

810
00:32:02,320 --> 00:32:05,440
seed is not trivial for example linux

811
00:32:05,440 --> 00:32:07,600
distributors have to expose the random

812
00:32:07,600 --> 00:32:09,919
seed to their users for building

813
00:32:09,919 --> 00:32:12,159
third-party current modules this is

814
00:32:12,159 --> 00:32:14,159
because the third-party column modules

815
00:32:14,159 --> 00:32:16,480
need to know how exactly the structure

816
00:32:16,480 --> 00:32:18,880
is defined after layout layout

817
00:32:18,880 --> 00:32:21,679
randomization for using them

818
00:32:21,679 --> 00:32:23,679
the mitigation works well in house

819
00:32:23,679 --> 00:32:25,679
building kernel if the random seed can

820
00:32:25,679 --> 00:32:28,240
be protected appropriately but for

821
00:32:28,240 --> 00:32:30,480
districts like ubentu and debian it's

822
00:32:30,480 --> 00:32:33,519
not very practical

823
00:32:34,080 --> 00:32:36,480
the last potential mitigation is config

824
00:32:36,480 --> 00:32:38,720
hardened user copy which is important

825
00:32:38,720 --> 00:32:40,880
from pax user copy

826
00:32:40,880 --> 00:32:43,600
this mitigation exam examines the size

827
00:32:43,600 --> 00:32:45,919
argument of copy to user

828
00:32:45,919 --> 00:32:48,159
if the source argument is a constant

829
00:32:48,159 --> 00:32:50,720
address this defense ensures that the

830
00:32:50,720 --> 00:32:52,960
size argument is smaller than the frame

831
00:32:52,960 --> 00:32:55,440
size only data in the current stack

832
00:32:55,440 --> 00:32:57,679
frame can be copied out

833
00:32:57,679 --> 00:32:59,600
if the source argument is called heap

834
00:32:59,600 --> 00:33:02,159
address this defense ensures that the

835
00:33:02,159 --> 00:33:04,720
size argument is smaller than the slot

836
00:33:04,720 --> 00:33:05,919
slice

837
00:33:05,919 --> 00:33:08,880
the cross slide overread is disallowed

838
00:33:08,880 --> 00:33:11,120
the similar mechanism is also used in

839
00:33:11,120 --> 00:33:12,960
xnu kernel

840
00:33:12,960 --> 00:33:14,960
while this technique can mitigate the

841
00:33:14,960 --> 00:33:17,200
threat of some elastic objects it

842
00:33:17,200 --> 00:33:19,440
suffers from two problems

843
00:33:19,440 --> 00:33:21,440
on the one hand it only enforces the

844
00:33:21,440 --> 00:33:23,760
length checking for copy to user

845
00:33:23,760 --> 00:33:25,679
other critical kernel functions for data

846
00:33:25,679 --> 00:33:28,240
transferring are not included

847
00:33:28,240 --> 00:33:30,720
on the other hand the legit lens range

848
00:33:30,720 --> 00:33:33,279
is not restricted enough the sensitive

849
00:33:33,279 --> 00:33:35,919
data can reside in a cache slot or stack

850
00:33:35,919 --> 00:33:36,799
frame

851
00:33:36,799 --> 00:33:38,799
it's still possible to leak them even

852
00:33:38,799 --> 00:33:42,320
after the mitigation is enforced

853
00:33:42,320 --> 00:33:44,480
according to our discussion in previous

854
00:33:44,480 --> 00:33:46,880
slides there are now no mitigation in

855
00:33:46,880 --> 00:33:49,440
the kernel that can perfectly neutralize

856
00:33:49,440 --> 00:33:52,320
the thread of elastic objects to this

857
00:33:52,320 --> 00:33:55,440
end we propose a new defense mechanism

858
00:33:55,440 --> 00:33:57,919
this mechanism isolates elastic objects

859
00:33:57,919 --> 00:34:00,159
that we define or that we identified

860
00:34:00,159 --> 00:34:02,559
into individual shadow caches

861
00:34:02,559 --> 00:34:05,679
to be specific we create an isolated

862
00:34:05,679 --> 00:34:07,679
shadow cache for each general cache

863
00:34:07,679 --> 00:34:09,599
during corner boot up

864
00:34:09,599 --> 00:34:11,839
using shadow caches we store elastic

865
00:34:11,839 --> 00:34:14,399
objects with the corresponding sizes for

866
00:34:14,399 --> 00:34:17,440
example the elastic objects originally

867
00:34:17,440 --> 00:34:19,918
allocated in kinematic 96 will be

868
00:34:19,918 --> 00:34:22,639
assigned in cape melon isolated isolated

869
00:34:22,639 --> 00:34:25,119
96 after the isolation mechanism is

870
00:34:25,119 --> 00:34:27,040
enabled

871
00:34:27,040 --> 00:34:29,440
to support this isolation we modified

872
00:34:29,440 --> 00:34:31,520
the kernel source code by adding one

873
00:34:31,520 --> 00:34:34,399
more flag at allocation site this flag

874
00:34:34,399 --> 00:34:36,480
specifies that the object to be

875
00:34:36,480 --> 00:34:39,040
allocated is elastic object and should

876
00:34:39,040 --> 00:34:41,918
be placed in the shadow caches

877
00:34:41,918 --> 00:34:44,239
with vein's isolation mechanism an

878
00:34:44,239 --> 00:34:46,399
adversary has little chance to leverage

879
00:34:46,399 --> 00:34:48,960
the vulnerability tied to other objects

880
00:34:48,960 --> 00:34:51,359
to manipulate length field and a point

881
00:34:51,359 --> 00:34:54,159
of field in elastic objects

882
00:34:54,159 --> 00:34:56,639
besides the common heap spray objects

883
00:34:56,639 --> 00:34:58,240
and con objects with scientific

884
00:34:58,240 --> 00:35:00,560
information like function pointers are

885
00:35:00,560 --> 00:35:04,000
also isolated from the elastic objects

886
00:35:04,000 --> 00:35:06,480
they could not be used for hip feng shui

887
00:35:06,480 --> 00:35:08,079
and spraying

888
00:35:08,079 --> 00:35:10,400
i learned from just security that they

889
00:35:10,400 --> 00:35:12,960
have implemented more advanced isolation

890
00:35:12,960 --> 00:35:16,000
in their new defense named auto slab

891
00:35:16,000 --> 00:35:18,160
outer slab is much more aggressive in

892
00:35:18,160 --> 00:35:21,040
heap object isolation although i don't

893
00:35:21,040 --> 00:35:24,079
know more details of about auto load or

894
00:35:24,079 --> 00:35:26,720
oslab autosap i'm pretty sure that this

895
00:35:26,720 --> 00:35:29,200
security improvement is very significant

896
00:35:29,200 --> 00:35:31,839
too

897
00:35:31,839 --> 00:35:34,480
we evaluated the performance overhead of

898
00:35:34,480 --> 00:35:37,040
our proposed mitigation we use the three

899
00:35:37,040 --> 00:35:39,599
sets of benchmarks the first set is

900
00:35:39,599 --> 00:35:42,560
micro benchmarks from rm bench which

901
00:35:42,560 --> 00:35:44,560
tests the latency and the bandwidth of

902
00:35:44,560 --> 00:35:48,240
common system calls and io operations

903
00:35:48,240 --> 00:35:50,480
the second benchmark is my macro

904
00:35:50,480 --> 00:35:54,560
benchmarks from feronix test suite 9.8

905
00:35:54,560 --> 00:35:57,680
which runs five real-world applications

906
00:35:57,680 --> 00:35:59,520
to prevent the overhead from being

907
00:35:59,520 --> 00:36:01,440
hidden behind the sophisticated kernel

908
00:36:01,440 --> 00:36:04,480
execution we specifically designed the

909
00:36:04,480 --> 00:36:07,200
third set benchmark to stress test the

910
00:36:07,200 --> 00:36:09,920
impact of our mitigation approach

911
00:36:09,920 --> 00:36:13,200
this set of customized benchmarks use

912
00:36:13,200 --> 00:36:15,520
the system core sequences to reach

913
00:36:15,520 --> 00:36:17,440
elastic object allocation and the

914
00:36:17,440 --> 00:36:20,560
corresponding data leakage intensively

915
00:36:20,560 --> 00:36:22,400
overall we could observe that the

916
00:36:22,400 --> 00:36:24,960
performance overhead is negligible with

917
00:36:24,960 --> 00:36:27,440
a performance with average performance

918
00:36:27,440 --> 00:36:29,119
job less than one

919
00:36:29,119 --> 00:36:31,599
percent

920
00:36:32,320 --> 00:36:35,280
we also evaluate the security of our

921
00:36:35,280 --> 00:36:37,119
security improvement of our proposed

922
00:36:37,119 --> 00:36:40,079
mitigation approach by using the 31

923
00:36:40,079 --> 00:36:42,400
vulnerabilities that were used to study

924
00:36:42,400 --> 00:36:45,280
the generality of elastic object attack

925
00:36:45,280 --> 00:36:48,079
for most vulnerabilities we cannot find

926
00:36:48,079 --> 00:36:50,160
elastic objects that can be used for

927
00:36:50,160 --> 00:36:52,800
exploitation it is because elastic

928
00:36:52,800 --> 00:36:54,640
objects and the vulnerable objects are

929
00:36:54,640 --> 00:36:56,400
mostly different

930
00:36:56,400 --> 00:36:59,040
they are isolated into two different

931
00:36:59,040 --> 00:37:00,480
caches

932
00:37:00,480 --> 00:37:02,480
there is no longer no longer a

933
00:37:02,480 --> 00:37:04,240
possibility to

934
00:37:04,240 --> 00:37:06,560
to use a vulnerable object to manipulate

935
00:37:06,560 --> 00:37:09,599
the length field of an elastic object

936
00:37:09,599 --> 00:37:15,599
for vulnerable objects in cv 2017 71 84

937
00:37:15,599 --> 00:37:19,079
and cv 2017-17053

938
00:37:20,000 --> 00:37:22,160
there are elastic objects allocated in

939
00:37:22,160 --> 00:37:23,920
shadow caches

940
00:37:23,920 --> 00:37:26,000
technically they can be leveraged to

941
00:37:26,000 --> 00:37:28,640
override data in isolated caches and

942
00:37:28,640 --> 00:37:30,640
thus manipulate the length field of

943
00:37:30,640 --> 00:37:33,280
elastic object for data disclosure

944
00:37:33,280 --> 00:37:35,520
however we argue that even this

945
00:37:35,520 --> 00:37:38,160
situation exists our mitigation still

946
00:37:38,160 --> 00:37:40,960
raises the bar because disclosed data is

947
00:37:40,960 --> 00:37:43,280
not likely to be useful for bypassing

948
00:37:43,280 --> 00:37:45,200
kernel mitigation

949
00:37:45,200 --> 00:37:47,359
taking the practice of circumventing

950
00:37:47,359 --> 00:37:50,960
kslr using cve

951
00:37:52,680 --> 00:37:55,200
2017-13056-553 as an example to use a

952
00:37:55,200 --> 00:37:57,520
vulnerable object to reveal a

953
00:37:57,520 --> 00:37:59,599
kernel-based address in addition to

954
00:37:59,599 --> 00:38:01,760
leveraging the elastic object an

955
00:38:01,760 --> 00:38:04,000
attacker usually has to identify a

956
00:38:04,000 --> 00:38:06,800
general object that encloses a function

957
00:38:06,800 --> 00:38:08,240
pointer

958
00:38:08,240 --> 00:38:09,920
then the attacker needs to place the

959
00:38:09,920 --> 00:38:12,720
object in the same isolated patch

960
00:38:12,720 --> 00:38:14,720
however due to the general due to the

961
00:38:14,720 --> 00:38:17,200
isolation between general object an

962
00:38:17,200 --> 00:38:20,800
elastic object such an object such an

963
00:38:20,800 --> 00:38:23,599
object such a general object is no

964
00:38:23,599 --> 00:38:28,160
longer available for this isolated cache

965
00:38:28,160 --> 00:38:30,640
in addition to the defense we proposed

966
00:38:30,640 --> 00:38:33,440
there are not

967
00:38:45,680 --> 00:38:47,760
when available kernel discloses data in

968
00:38:47,760 --> 00:38:48,560
an

969
00:38:48,560 --> 00:38:51,200
in a flexible buffer at any leaking

970
00:38:51,200 --> 00:38:53,680
angle we could check whether the amount

971
00:38:53,680 --> 00:38:56,400
of the data migrated to the user space

972
00:38:56,400 --> 00:38:59,599
is within a legit range

973
00:38:59,599 --> 00:39:01,440
since the construction of shadow memory

974
00:39:01,440 --> 00:39:03,680
is inevitably introduces memory and

975
00:39:03,680 --> 00:39:06,160
performance overhead the key challenge

976
00:39:06,160 --> 00:39:08,240
of this solution is to develop a

977
00:39:08,240 --> 00:39:10,720
lightweight method to minimize overhead

978
00:39:10,720 --> 00:39:13,040
in a systematic method

979
00:39:13,040 --> 00:39:15,200
another possible solution is to design a

980
00:39:15,200 --> 00:39:17,760
mechanism to enable the integrity check

981
00:39:17,760 --> 00:39:19,839
for the data in length field

982
00:39:19,839 --> 00:39:22,240
we introduce a checksum field when the

983
00:39:22,240 --> 00:39:24,560
kernel allocates a corresponding object

984
00:39:24,560 --> 00:39:27,200
and initialize its length field we could

985
00:39:27,200 --> 00:39:29,520
encrypt the length value and start it in

986
00:39:29,520 --> 00:39:31,839
the checksum field accordingly

987
00:39:31,839 --> 00:39:33,599
with this design at the time of

988
00:39:33,599 --> 00:39:36,000
disclosing data in the flexible buffer

989
00:39:36,000 --> 00:39:38,400
to be to the userland the kernel could

990
00:39:38,400 --> 00:39:41,920
easily retrieve and examine the checksum

991
00:39:41,920 --> 00:39:44,240
the key challenge of implementing this

992
00:39:44,240 --> 00:39:47,359
idea is to ensure that addition of the

993
00:39:47,359 --> 00:39:49,680
checksum field will not influence the

994
00:39:49,680 --> 00:39:51,839
usability of the kernel

995
00:39:51,839 --> 00:39:53,520
some elastic data structures are

996
00:39:53,520 --> 00:39:55,520
designed for protocols which have

997
00:39:55,520 --> 00:39:57,599
specific formats

998
00:39:57,599 --> 00:40:00,240
after allocating objects in these types

999
00:40:00,240 --> 00:40:02,320
the kernel references the data through

1000
00:40:02,320 --> 00:40:04,319
corresponding offsets

1001
00:40:04,319 --> 00:40:06,560
if introducing additional field into

1002
00:40:06,560 --> 00:40:09,520
such objects one has to ensure that the

1003
00:40:09,520 --> 00:40:11,760
newly added checksum field does not

1004
00:40:11,760 --> 00:40:16,319
incur in current data reference

1005
00:40:16,560 --> 00:40:18,480
i summarize the take away of the

1006
00:40:18,480 --> 00:40:21,040
presentation as follows first using

1007
00:40:21,040 --> 00:40:24,079
elastic object for leaking is a severe

1008
00:40:24,079 --> 00:40:26,160
and general approach to bypassing

1009
00:40:26,160 --> 00:40:28,560
protections in kernel second new

1010
00:40:28,560 --> 00:40:31,359
mitigations are needed in linux freebst

1011
00:40:31,359 --> 00:40:34,000
and xnu to prevent elastic in object

1012
00:40:34,000 --> 00:40:35,040
attack

1013
00:40:35,040 --> 00:40:37,920
we evaluate our proposed mitigation and

1014
00:40:37,920 --> 00:40:40,400
showcase that its performance overhead

1015
00:40:40,400 --> 00:40:43,040
is negligible while security improvement

1016
00:40:43,040 --> 00:40:44,480
is clear

1017
00:40:44,480 --> 00:40:47,280
finally it seems that elastic object

1018
00:40:47,280 --> 00:40:49,280
attack for arbitrary writing is less

1019
00:40:49,280 --> 00:40:52,079
general but more study is required to

1020
00:40:52,079 --> 00:40:54,880
confirm this claim

1021
00:40:54,880 --> 00:40:56,560
thanks for listening and thank you very

1022
00:40:56,560 --> 00:40:58,880
much for having me here if you want to

1023
00:40:58,880 --> 00:41:01,200
know more about me and my other projects

1024
00:41:01,200 --> 00:41:02,960
or you don't have chance to ask

1025
00:41:02,960 --> 00:41:05,680
questions in this session feel free to

1026
00:41:05,680 --> 00:41:08,240
follow me on twitter contact me using

1027
00:41:08,240 --> 00:41:10,720
email and check my personal page

1028
00:41:10,720 --> 00:41:13,040
we've released the code on github and

1029
00:41:13,040 --> 00:41:18,200
welcome your contribution thank you all

