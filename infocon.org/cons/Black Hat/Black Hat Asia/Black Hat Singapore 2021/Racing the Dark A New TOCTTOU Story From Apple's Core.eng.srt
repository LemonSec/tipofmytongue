1
00:00:01,180 --> 00:00:15,180
[Music]

2
00:00:16,640 --> 00:00:18,400
hello everyone welcome to my

3
00:00:18,400 --> 00:00:19,760
presentation

4
00:00:19,760 --> 00:00:22,320
my topic today is related to operating

5
00:00:22,320 --> 00:00:25,760
system kernel memory access mapping

6
00:00:25,760 --> 00:00:26,800
parsing

7
00:00:26,800 --> 00:00:30,080
and risk condition issues the title is

8
00:00:30,080 --> 00:00:31,519
reaching the dark

9
00:00:31,519 --> 00:00:35,520
a new talk to a story from apple's call

10
00:00:35,520 --> 00:00:37,600
talk tall is short for

11
00:00:37,600 --> 00:00:40,399
time of check to time of use

12
00:00:40,399 --> 00:00:45,160
it's kind of risk condition issue

13
00:00:45,360 --> 00:00:46,879
my name is

14
00:00:46,879 --> 00:00:48,800
i can be reached through this email

15
00:00:48,800 --> 00:00:50,960
address

16
00:00:50,960 --> 00:00:53,680
this research is a third kernel security

17
00:00:53,680 --> 00:00:57,520
research project i made public in 2020

18
00:00:57,520 --> 00:01:00,239
the first two projects are related to

19
00:01:00,239 --> 00:01:03,760
the bluetooth and the wi-fi subsystems

20
00:01:03,760 --> 00:01:07,600
of mac os and ios

21
00:01:08,080 --> 00:01:10,840
today's content can be divided into four

22
00:01:10,840 --> 00:01:13,840
parts background knowledge and the

23
00:01:13,840 --> 00:01:15,759
tactile vulnerability

24
00:01:15,759 --> 00:01:17,680
project chemo

25
00:01:17,680 --> 00:01:20,159
kernel vulnerability case studies and

26
00:01:20,159 --> 00:01:21,360
the end

27
00:01:21,360 --> 00:01:24,000
in the first part of the presentation

28
00:01:24,000 --> 00:01:26,000
we will focus on the background

29
00:01:26,000 --> 00:01:28,720
knowledge of user mode memory access

30
00:01:28,720 --> 00:01:30,159
and the kernel risk condition

31
00:01:30,159 --> 00:01:31,600
vulnerability

32
00:01:31,600 --> 00:01:34,720
so let's start

33
00:01:35,040 --> 00:01:37,840
when developing operating system kernels

34
00:01:37,840 --> 00:01:39,600
and drivers

35
00:01:39,600 --> 00:01:41,680
functions related to

36
00:01:41,680 --> 00:01:44,799
user data mapping accessing parsing are

37
00:01:44,799 --> 00:01:47,040
often found vulnerable

38
00:01:47,040 --> 00:01:50,240
in order to solve this type of problem

39
00:01:50,240 --> 00:01:53,680
almost every system defines

40
00:01:53,680 --> 00:01:56,000
standard operating rules when touching

41
00:01:56,000 --> 00:01:58,240
our trusted user input

42
00:01:58,240 --> 00:01:59,680
in this section

43
00:01:59,680 --> 00:02:02,960
i will list the user mode memory access

44
00:02:02,960 --> 00:02:04,000
message

45
00:02:04,000 --> 00:02:05,920
of android linux

46
00:02:05,920 --> 00:02:09,440
windows and mac os ios platforms

47
00:02:09,440 --> 00:02:12,640
as well as some real world vulnerability

48
00:02:12,640 --> 00:02:13,680
cases

49
00:02:13,680 --> 00:02:16,480
so let's start one by one case by case

50
00:02:16,480 --> 00:02:19,519
from easy to hard

51
00:02:20,160 --> 00:02:23,680
the first platform is android linux

52
00:02:23,680 --> 00:02:25,360
in my opinion

53
00:02:25,360 --> 00:02:27,760
the linux kernel api document

54
00:02:27,760 --> 00:02:30,080
is worth reading

55
00:02:30,080 --> 00:02:33,200
the first capital of the document is

56
00:02:33,200 --> 00:02:36,560
named memory management in linux in

57
00:02:36,560 --> 00:02:37,440
which

58
00:02:37,440 --> 00:02:40,720
user space memory access describes

59
00:02:40,720 --> 00:02:43,599
in detail the api set that should be

60
00:02:43,599 --> 00:02:47,599
used when accessing untrusted memory

61
00:02:47,599 --> 00:02:50,640
for example the well-known functions

62
00:02:50,640 --> 00:02:52,959
copy from user and

63
00:02:52,959 --> 00:02:54,720
copy to user

64
00:02:54,720 --> 00:02:57,680
their explanations can be found in the

65
00:02:57,680 --> 00:02:59,599
links below

66
00:02:59,599 --> 00:03:03,920
if this if this rules are violated when

67
00:03:03,920 --> 00:03:05,840
accessing user data

68
00:03:05,840 --> 00:03:08,640
the vulnerable function will at least

69
00:03:08,640 --> 00:03:11,840
introduce a local privilege escalation

70
00:03:11,840 --> 00:03:15,599
vulnerability into the kernel

71
00:03:16,640 --> 00:03:19,680
the simplest but the real cases real

72
00:03:19,680 --> 00:03:22,400
case is as follows

73
00:03:22,400 --> 00:03:25,519
i found this vulnerability when i was

74
00:03:25,519 --> 00:03:27,680
working on mobile security research

75
00:03:27,680 --> 00:03:29,599
seven years ago

76
00:03:29,599 --> 00:03:31,840
we can still find the leaked source code

77
00:03:31,840 --> 00:03:33,519
on github

78
00:03:33,519 --> 00:03:36,560
this vulnerability is located in the

79
00:03:36,560 --> 00:03:39,440
media tag sd card driver

80
00:03:39,440 --> 00:03:41,840
due to lack of restrictions

81
00:03:41,840 --> 00:03:45,760
user mode processes can open and operate

82
00:03:45,760 --> 00:03:48,400
this driver

83
00:03:48,400 --> 00:03:50,319
through auditing

84
00:03:50,319 --> 00:03:52,000
the leaked source code

85
00:03:52,000 --> 00:03:55,200
we can find that almost every io control

86
00:03:55,200 --> 00:03:58,560
handler of the driver has problems

87
00:03:58,560 --> 00:03:59,760
for example

88
00:03:59,760 --> 00:04:03,040
in line 9 94

89
00:04:03,040 --> 00:04:05,760
the function copy from user mistakenly

90
00:04:05,760 --> 00:04:10,239
trust trust trusted the length of input

91
00:04:10,239 --> 00:04:12,720
the size of the buffer on the local

92
00:04:12,720 --> 00:04:16,079
stack is only 25 bytes and such a copy

93
00:04:16,079 --> 00:04:19,519
means that stack based buffer floor

94
00:04:19,519 --> 00:04:20,959
in general

95
00:04:20,959 --> 00:04:22,320
this

96
00:04:22,320 --> 00:04:25,680
vulnerability gives you a chance to be

97
00:04:25,680 --> 00:04:27,120
guard

98
00:04:27,120 --> 00:04:28,400
of course

99
00:04:28,400 --> 00:04:31,759
all of this is based on the fact that

100
00:04:31,759 --> 00:04:34,240
seven years ago there was basically no

101
00:04:34,240 --> 00:04:38,960
mitigation mechanism for mobile phones

102
00:04:40,000 --> 00:04:43,440
but this simple exploit took me a lot of

103
00:04:43,440 --> 00:04:44,479
time

104
00:04:44,479 --> 00:04:45,600
at first

105
00:04:45,600 --> 00:04:46,960
i found that

106
00:04:46,960 --> 00:04:49,280
no matter what i tried

107
00:04:49,280 --> 00:04:52,560
i could only get my phone restarted

108
00:04:52,560 --> 00:04:53,440
so

109
00:04:53,440 --> 00:04:55,440
i had to re-exam

110
00:04:55,440 --> 00:04:58,240
the last written instruction of the

111
00:04:58,240 --> 00:05:00,479
vulnerable function

112
00:05:00,479 --> 00:05:03,039
without the help of kernel debugger

113
00:05:03,039 --> 00:05:05,520
i guess the one by one about the

114
00:05:05,520 --> 00:05:06,880
possibility

115
00:05:06,880 --> 00:05:10,639
of overwriting the registers

116
00:05:10,639 --> 00:05:14,000
destroying the blue register like r4 or

117
00:05:14,000 --> 00:05:17,120
r5 may cause the call function caller

118
00:05:17,120 --> 00:05:19,520
function to crash

119
00:05:19,520 --> 00:05:22,320
because the value in this register may

120
00:05:22,320 --> 00:05:24,960
be the base address

121
00:05:24,960 --> 00:05:27,280
of an object for example

122
00:05:27,280 --> 00:05:29,120
and we cannot just

123
00:05:29,120 --> 00:05:30,479
rewrite it

124
00:05:30,479 --> 00:05:34,320
this drawing the green pc register means

125
00:05:34,320 --> 00:05:35,919
we need to

126
00:05:35,919 --> 00:05:39,039
figure out where to put the shell code

127
00:05:39,039 --> 00:05:41,680
the good news is that security features

128
00:05:41,680 --> 00:05:45,120
such as pxen were basically not enabled

129
00:05:45,120 --> 00:05:47,520
on mobile phones in

130
00:05:47,520 --> 00:05:49,919
2018

131
00:05:49,919 --> 00:05:53,600
with the deepening of the analysis i

132
00:05:53,600 --> 00:05:55,520
found that

133
00:05:55,520 --> 00:05:58,720
the red sp register is a key to the

134
00:05:58,720 --> 00:06:03,280
problem i broke the sp address before

135
00:06:03,280 --> 00:06:06,000
handling the return address

136
00:06:06,000 --> 00:06:09,199
so so why why is the sp register so

137
00:06:09,199 --> 00:06:11,680
critical

138
00:06:12,880 --> 00:06:16,319
the answer is related to current threat

139
00:06:16,319 --> 00:06:18,720
in order to improve speed

140
00:06:18,720 --> 00:06:21,280
each operating system uses the simplest

141
00:06:21,280 --> 00:06:24,240
method to locate the current threat

142
00:06:24,240 --> 00:06:25,360
structure

143
00:06:25,360 --> 00:06:27,280
for example the windows kernel

144
00:06:27,280 --> 00:06:30,000
determines current thread based on the

145
00:06:30,000 --> 00:06:33,440
fixed offset of the fs register

146
00:06:33,440 --> 00:06:37,360
while in the linux kernel version 2.6

147
00:06:37,360 --> 00:06:40,319
current thread is located with the help

148
00:06:40,319 --> 00:06:42,720
of the sp register

149
00:06:42,720 --> 00:06:44,000
therefore

150
00:06:44,000 --> 00:06:45,600
once the

151
00:06:45,600 --> 00:06:49,280
stack overflow crops the sp register

152
00:06:49,280 --> 00:06:52,560
it will cause serious problems during

153
00:06:52,560 --> 00:06:54,880
context switching

154
00:06:54,880 --> 00:06:59,360
that's why i have to turn off interrupts

155
00:06:59,360 --> 00:07:03,160
in the shell code first

156
00:07:03,759 --> 00:07:06,639
the next question is

157
00:07:06,639 --> 00:07:09,120
where we should return

158
00:07:09,120 --> 00:07:11,440
where we should return to after the

159
00:07:11,440 --> 00:07:13,599
shell code is executed

160
00:07:13,599 --> 00:07:15,919
the problem is not difficult for us i

161
00:07:15,919 --> 00:07:17,199
think

162
00:07:17,199 --> 00:07:19,680
we need to search the code segment

163
00:07:19,680 --> 00:07:22,400
find the return address of the br

164
00:07:22,400 --> 00:07:25,440
instruction and then redirect the

165
00:07:25,440 --> 00:07:26,880
execution flow

166
00:07:26,880 --> 00:07:27,759
to

167
00:07:27,759 --> 00:07:31,199
of the exploit to that location

168
00:07:31,199 --> 00:07:32,400
in this way

169
00:07:32,400 --> 00:07:37,440
our code can be executed stably

170
00:07:38,479 --> 00:07:41,280
the following figure shows the complete

171
00:07:41,280 --> 00:07:42,639
process of

172
00:07:42,639 --> 00:07:44,720
vulnerability exploitation

173
00:07:44,720 --> 00:07:47,440
first of all we need to select the

174
00:07:47,440 --> 00:07:51,039
appropriate value of r4 r5 and other

175
00:07:51,039 --> 00:07:54,400
registers and select the appropriate

176
00:07:54,400 --> 00:07:57,280
address to place shellcode

177
00:07:57,280 --> 00:08:00,080
once the shell code is executed we need

178
00:08:00,080 --> 00:08:02,879
to turn off system interrupts at the

179
00:08:02,879 --> 00:08:04,000
first time

180
00:08:04,000 --> 00:08:06,720
and then search the double linked

181
00:08:06,720 --> 00:08:08,319
process list to

182
00:08:08,319 --> 00:08:11,199
find our own task structure

183
00:08:11,199 --> 00:08:15,360
by locating the correct sp offset

184
00:08:15,360 --> 00:08:18,160
through signature search for example we

185
00:08:18,160 --> 00:08:21,919
can restore the sp register

186
00:08:21,919 --> 00:08:22,720
then

187
00:08:22,720 --> 00:08:25,199
we can re-enable the

188
00:08:25,199 --> 00:08:28,240
interruption and complete the process of

189
00:08:28,240 --> 00:08:30,160
escalation

190
00:08:30,160 --> 00:08:32,880
the last step we need to search the

191
00:08:32,880 --> 00:08:35,919
correct return address and exit

192
00:08:35,919 --> 00:08:38,080
by the way we don't have the kernel

193
00:08:38,080 --> 00:08:40,958
debugger and we cannot print out

194
00:08:40,958 --> 00:08:43,839
debugging information because this will

195
00:08:43,839 --> 00:08:47,440
cause contextual switching

196
00:08:48,320 --> 00:08:49,120
so

197
00:08:49,120 --> 00:08:51,680
this page contains a seven years old

198
00:08:51,680 --> 00:08:54,800
screenshot of a successful eop privilege

199
00:08:54,800 --> 00:08:57,040
escalation to avoid trouble

200
00:08:57,040 --> 00:09:01,279
i removed the name of mobile phone brand

201
00:09:01,279 --> 00:09:04,080
the vulnerability is actually caused by

202
00:09:04,080 --> 00:09:07,120
third party vendors sd card driver

203
00:09:07,120 --> 00:09:09,760
this vulnerability affected many mobile

204
00:09:09,760 --> 00:09:11,279
phone brands

205
00:09:11,279 --> 00:09:13,279
at that time including

206
00:09:13,279 --> 00:09:17,839
samsung xiaomi huawei and so on

207
00:09:17,839 --> 00:09:20,880
in the third part of this presentation

208
00:09:20,880 --> 00:09:24,320
we will see other vulnerability cases

209
00:09:24,320 --> 00:09:26,160
caused by

210
00:09:26,160 --> 00:09:27,279
graphics

211
00:09:27,279 --> 00:09:30,240
card supplier

212
00:09:31,279 --> 00:09:36,160
as a summary of the android linux part

213
00:09:36,160 --> 00:09:37,040
i

214
00:09:37,040 --> 00:09:40,080
would like to make a few points

215
00:09:40,080 --> 00:09:43,519
number one all input is harmful

216
00:09:43,519 --> 00:09:46,399
for the vulnerability mentioned earlier

217
00:09:46,399 --> 00:09:49,120
i think every kernel programmer

218
00:09:49,120 --> 00:09:52,000
should try his or her best to avoid

219
00:09:52,000 --> 00:09:54,480
making such mistakes

220
00:09:54,480 --> 00:09:55,760
number two

221
00:09:55,760 --> 00:09:58,720
stack-based buffalo floor exploit

222
00:09:58,720 --> 00:10:00,080
explain

223
00:10:00,080 --> 00:10:02,800
exploitation in real world

224
00:10:02,800 --> 00:10:05,680
is not as simple as in books especially

225
00:10:05,680 --> 00:10:09,680
when you don't have a kernel debugger

226
00:10:09,680 --> 00:10:12,480
number three you may be wondering

227
00:10:12,480 --> 00:10:15,120
do stack overflow vulnerabilities still

228
00:10:15,120 --> 00:10:17,839
make sense today

229
00:10:17,839 --> 00:10:20,399
i would like to give two examples on

230
00:10:20,399 --> 00:10:21,760
this topic

231
00:10:21,760 --> 00:10:24,399
the the first one comes from the

232
00:10:24,399 --> 00:10:27,920
presentation of pangu team um

233
00:10:27,920 --> 00:10:30,839
at blackhead usa in

234
00:10:30,839 --> 00:10:34,240
2019 the title is towards discovering

235
00:10:34,240 --> 00:10:36,720
remote code execution vulnerabilities in

236
00:10:36,720 --> 00:10:38,320
apple this time

237
00:10:38,320 --> 00:10:42,079
on page 101 of the slides tla discovered

238
00:10:42,079 --> 00:10:45,600
some cases of stack of floor caused by

239
00:10:45,600 --> 00:10:47,519
the compilers

240
00:10:47,519 --> 00:10:51,120
incorrect in session of stack canary on

241
00:10:51,120 --> 00:10:53,760
arm platform the second example comes

242
00:10:53,760 --> 00:10:56,959
from my presentation at blackhead usa

243
00:10:56,959 --> 00:10:58,240
last year

244
00:10:58,240 --> 00:11:01,480
the title is diving to apple

245
00:11:01,480 --> 00:11:05,440
io80211 family version 2. i found a case

246
00:11:05,440 --> 00:11:09,120
where the compiler did not insert the

247
00:11:09,120 --> 00:11:11,040
stack canary

248
00:11:11,040 --> 00:11:13,360
for the target wonderful function

249
00:11:13,360 --> 00:11:16,160
the id is cve 2020

250
00:11:16,160 --> 00:11:18,320
98.99

251
00:11:18,320 --> 00:11:19,920
i think after reading these

252
00:11:19,920 --> 00:11:21,600
presentations you may have some

253
00:11:21,600 --> 00:11:24,320
different ideas about stack-based buffer

254
00:11:24,320 --> 00:11:26,560
floor

255
00:11:26,560 --> 00:11:29,920
the next platform is the windows kernel

256
00:11:29,920 --> 00:11:31,920
i would like to share some more

257
00:11:31,920 --> 00:11:34,000
interesting cases with you

258
00:11:34,000 --> 00:11:35,360
first of all

259
00:11:35,360 --> 00:11:38,160
there is a slide called common

260
00:11:38,160 --> 00:11:39,760
coding errors

261
00:11:39,760 --> 00:11:41,519
that is worth reading

262
00:11:41,519 --> 00:11:42,959
it contains

263
00:11:42,959 --> 00:11:45,519
most of the common kernel programming

264
00:11:45,519 --> 00:11:49,279
errors and the solutions

265
00:11:49,279 --> 00:11:52,639
as a part of the user data processing

266
00:11:52,639 --> 00:11:54,320
rules

267
00:11:54,320 --> 00:11:56,880
routines such as prop for read and

268
00:11:56,880 --> 00:11:59,519
proper write are apis

269
00:11:59,519 --> 00:12:01,600
that we must use

270
00:12:01,600 --> 00:12:04,160
their explanations can be found in the

271
00:12:04,160 --> 00:12:06,240
links below

272
00:12:06,240 --> 00:12:07,519
similarly

273
00:12:07,519 --> 00:12:08,639
if

274
00:12:08,639 --> 00:12:10,399
this rules

275
00:12:10,399 --> 00:12:13,440
are violated when accessing user data

276
00:12:13,440 --> 00:12:15,600
the vulnerable function will at least

277
00:12:15,600 --> 00:12:18,959
introduce a log privilege escalation

278
00:12:18,959 --> 00:12:23,239
vulnerability into the kernel

279
00:12:24,079 --> 00:12:24,959
in

280
00:12:24,959 --> 00:12:27,200
uh 2012

281
00:12:27,200 --> 00:12:30,000
i mentioned an interesting feature

282
00:12:30,000 --> 00:12:31,000
in the

283
00:12:31,000 --> 00:12:35,279
132k fund engine in my found

284
00:12:35,279 --> 00:12:38,480
security related presentation at the

285
00:12:38,480 --> 00:12:42,399
c-scan 360 conference

286
00:12:42,399 --> 00:12:44,480
for efficiency reasons

287
00:12:44,480 --> 00:12:46,959
phone file will not be copied into

288
00:12:46,959 --> 00:12:49,279
kernel mode

289
00:12:49,279 --> 00:12:50,639
so how

290
00:12:50,639 --> 00:12:53,600
does the kernel scalar engine access

291
00:12:53,600 --> 00:12:56,639
this data located in user space

292
00:12:56,639 --> 00:12:58,800
the answer is that

293
00:12:58,800 --> 00:13:01,200
the engine will access and manipulate

294
00:13:01,200 --> 00:13:03,200
this data directly

295
00:13:03,200 --> 00:13:05,760
in the figure we can see that the return

296
00:13:05,760 --> 00:13:07,839
value of the rooting

297
00:13:07,839 --> 00:13:11,120
uh p way get pointer callback

298
00:13:11,120 --> 00:13:15,760
um is a user mode address with lens of

299
00:13:15,760 --> 00:13:17,360
four e8

300
00:13:17,360 --> 00:13:19,680
and the the the

301
00:13:19,680 --> 00:13:24,240
address here is a user space address

302
00:13:24,240 --> 00:13:26,000
and all

303
00:13:26,000 --> 00:13:28,480
subsequent parsing operations are based

304
00:13:28,480 --> 00:13:30,800
on this user mode address

305
00:13:30,800 --> 00:13:32,480
so in my opinion

306
00:13:32,480 --> 00:13:35,279
this design and the implementation give

307
00:13:35,279 --> 00:13:36,320
total

308
00:13:36,320 --> 00:13:38,880
or risk condition vulnerability a large

309
00:13:38,880 --> 00:13:41,600
living space

310
00:13:41,920 --> 00:13:43,600
a year after

311
00:13:43,600 --> 00:13:47,279
juror from google project zero released

312
00:13:47,279 --> 00:13:49,920
his box palm on github

313
00:13:49,920 --> 00:13:51,600
this amazing tool

314
00:13:51,600 --> 00:13:54,399
found a large number of kernel double

315
00:13:54,399 --> 00:13:58,160
fetch and risk condition vulnerabilities

316
00:13:58,160 --> 00:13:59,600
some of this

317
00:13:59,600 --> 00:14:02,399
recourse can still be found on google

318
00:14:02,399 --> 00:14:04,240
docs today

319
00:14:04,240 --> 00:14:06,320
the box phone can

320
00:14:06,320 --> 00:14:08,800
record or access actions

321
00:14:08,800 --> 00:14:11,920
of the kernel to user mode data

322
00:14:11,920 --> 00:14:14,480
and vulnerability types like double

323
00:14:14,480 --> 00:14:15,360
fetch

324
00:14:15,360 --> 00:14:19,440
will have no well to hide

325
00:14:21,120 --> 00:14:22,000
then

326
00:14:22,000 --> 00:14:24,399
juror 10 turned

327
00:14:24,399 --> 00:14:27,360
his research direction to the

328
00:14:27,360 --> 00:14:31,120
132k from the engine and again his tour

329
00:14:31,120 --> 00:14:32,959
found a large number of

330
00:14:32,959 --> 00:14:35,920
double fetch and tactile vulnerabilities

331
00:14:35,920 --> 00:14:38,959
i listed some of his blog here

332
00:14:38,959 --> 00:14:41,680
if you are interested in font security

333
00:14:41,680 --> 00:14:45,760
this blog should not be missed

334
00:14:45,760 --> 00:14:48,079
this excellent studies

335
00:14:48,079 --> 00:14:52,000
keep me thinking what else can i do

336
00:14:52,000 --> 00:14:56,560
in general there are only two ways left

337
00:14:56,560 --> 00:14:59,760
the first way is to improve the code

338
00:14:59,760 --> 00:15:02,160
coverage rate during vulnerability

339
00:15:02,160 --> 00:15:03,279
hunting

340
00:15:03,279 --> 00:15:05,360
and maybe i can find

341
00:15:05,360 --> 00:15:07,440
some missed cases

342
00:15:07,440 --> 00:15:10,480
and yes i i did

343
00:15:10,560 --> 00:15:12,480
the other way is that

344
00:15:12,480 --> 00:15:15,360
i must try to find some new

345
00:15:15,360 --> 00:15:18,639
vulnerability patterns

346
00:15:18,720 --> 00:15:21,680
so i shared my approach in the blackhead

347
00:15:21,680 --> 00:15:24,160
usa 2014

348
00:15:24,160 --> 00:15:26,240
my slides can be downloaded in the first

349
00:15:26,240 --> 00:15:28,959
link here

350
00:15:31,440 --> 00:15:34,800
in short i mainly did two things

351
00:15:34,800 --> 00:15:38,240
i compiled the fund scale engine in the

352
00:15:38,240 --> 00:15:40,000
kernel of the leaked windows entity

353
00:15:40,000 --> 00:15:42,160
source code yes it can be

354
00:15:42,160 --> 00:15:43,360
compiled

355
00:15:43,360 --> 00:15:45,279
i compiled

356
00:15:45,279 --> 00:15:48,720
actually recompiled all project codes

357
00:15:48,720 --> 00:15:51,680
into a static library in user mode

358
00:15:51,680 --> 00:15:54,880
then i wrote a corresponding application

359
00:15:54,880 --> 00:15:56,639
to drive it to work

360
00:15:56,639 --> 00:15:57,839
and then

361
00:15:57,839 --> 00:16:01,279
i uploaded the project to github

362
00:16:01,279 --> 00:16:04,800
because i recompiled repackaged the

363
00:16:04,800 --> 00:16:06,320
source code

364
00:16:06,320 --> 00:16:09,199
my slides should not be put on the

365
00:16:09,199 --> 00:16:12,160
official website of black hat

366
00:16:12,160 --> 00:16:14,560
but i think the the whole process is

367
00:16:14,560 --> 00:16:15,839
very interesting

368
00:16:15,839 --> 00:16:17,120
for example

369
00:16:17,120 --> 00:16:18,880
on the left

370
00:16:18,880 --> 00:16:21,920
um i can get all the symbols of the

371
00:16:21,920 --> 00:16:23,120
fountain engine

372
00:16:23,120 --> 00:16:25,120
and i can also see

373
00:16:25,120 --> 00:16:27,440
how each gleef is

374
00:16:27,440 --> 00:16:30,399
rendered in pixels

375
00:16:30,399 --> 00:16:33,360
it's very interesting

376
00:16:33,680 --> 00:16:37,279
the second thing is that i did fund find

377
00:16:37,279 --> 00:16:41,199
a new type of vulnerability it's id cve

378
00:16:41,199 --> 00:16:43,759
2014

379
00:16:43,759 --> 00:16:46,639
1819

380
00:16:46,639 --> 00:16:48,959
because the fund engine introduced a

381
00:16:48,959 --> 00:16:52,560
catching mechanism in windows xp i found

382
00:16:52,560 --> 00:16:54,560
that the logic of many kernel routings

383
00:16:54,560 --> 00:16:56,399
has become

384
00:16:56,399 --> 00:16:57,279
first

385
00:16:57,279 --> 00:16:59,680
go to query the font cache

386
00:16:59,680 --> 00:17:02,560
here we can call it the first fetch

387
00:17:02,560 --> 00:17:05,439
and then the kernel buffer is

388
00:17:05,439 --> 00:17:06,720
a lock it

389
00:17:06,720 --> 00:17:10,079
according to the size of first query

390
00:17:10,079 --> 00:17:11,199
next

391
00:17:11,199 --> 00:17:13,520
access to user mode data

392
00:17:13,520 --> 00:17:17,039
to to initialize the kernel buffer which

393
00:17:17,039 --> 00:17:19,919
we can call the second fetch here

394
00:17:19,919 --> 00:17:21,199
as you can

395
00:17:21,199 --> 00:17:22,240
imagine

396
00:17:22,240 --> 00:17:25,199
there is a huge time window

397
00:17:25,199 --> 00:17:26,799
here

398
00:17:26,799 --> 00:17:29,440
adding inconsistency between the first

399
00:17:29,440 --> 00:17:32,000
batch and the second batch will result

400
00:17:32,000 --> 00:17:34,880
in heap of the bond access

401
00:17:34,880 --> 00:17:38,240
this vulnerability pattern can perfectly

402
00:17:38,240 --> 00:17:41,280
avoid box pawn scanning because there is

403
00:17:41,280 --> 00:17:43,600
only one user mode

404
00:17:43,600 --> 00:17:45,520
read or fetch

405
00:17:45,520 --> 00:17:49,280
in the entire process

406
00:17:49,919 --> 00:17:53,679
as a summary i want to say again that

407
00:17:53,679 --> 00:17:57,360
all input is harmful

408
00:17:57,360 --> 00:18:00,480
and the new features or changes always

409
00:18:00,480 --> 00:18:03,200
means new attack surfaces

410
00:18:03,200 --> 00:18:04,559
the phone cache

411
00:18:04,559 --> 00:18:07,039
introduces new tactile vulnerability to

412
00:18:07,039 --> 00:18:09,120
the kernel

413
00:18:09,120 --> 00:18:11,200
this non-traditional double fetch

414
00:18:11,200 --> 00:18:12,640
vulnerabilities

415
00:18:12,640 --> 00:18:16,000
are difficult to capture

416
00:18:16,000 --> 00:18:19,360
the third platform is the mac os ios

417
00:18:19,360 --> 00:18:20,480
kernel

418
00:18:20,480 --> 00:18:23,600
on mac os ios platform the situation

419
00:18:23,600 --> 00:18:25,919
becomes a little more complicated

420
00:18:25,919 --> 00:18:27,520
functions like

421
00:18:27,520 --> 00:18:28,559
io

422
00:18:28,559 --> 00:18:31,360
connect method can automatically handle

423
00:18:31,360 --> 00:18:34,720
user input for the kernel and extensions

424
00:18:34,720 --> 00:18:37,679
while bsd functions such as copying and

425
00:18:37,679 --> 00:18:39,280
the copy alt

426
00:18:39,280 --> 00:18:42,400
provides sports support for

427
00:18:42,400 --> 00:18:44,000
many operations

428
00:18:44,000 --> 00:18:47,600
in the link above is a document called

429
00:18:47,600 --> 00:18:49,679
kernel programming guide

430
00:18:49,679 --> 00:18:52,000
also some of the contained in the

431
00:18:52,000 --> 00:18:54,799
document is out of date but i

432
00:18:54,799 --> 00:18:55,679
still

433
00:18:55,679 --> 00:18:58,480
recommend kernel developers to

434
00:18:58,480 --> 00:19:02,240
read it as a reference

435
00:19:04,000 --> 00:19:07,919
for the more commonly used iocate

436
00:19:07,919 --> 00:19:10,640
functions i have list

437
00:19:10,640 --> 00:19:13,600
listed some links such as io connect

438
00:19:13,600 --> 00:19:15,280
core method

439
00:19:15,280 --> 00:19:18,160
inside inside the io connect column

440
00:19:18,160 --> 00:19:20,000
method function

441
00:19:20,000 --> 00:19:22,880
many code branches are related to the

442
00:19:22,880 --> 00:19:25,280
class io memory

443
00:19:25,280 --> 00:19:26,799
descriptor

444
00:19:26,799 --> 00:19:29,840
so i also listed the i o memory

445
00:19:29,840 --> 00:19:31,200
descriptor

446
00:19:31,200 --> 00:19:34,480
documentation below

447
00:19:35,200 --> 00:19:38,799
next i would like to refer a blog post

448
00:19:38,799 --> 00:19:40,080
by

449
00:19:40,080 --> 00:19:41,120
king lab

450
00:19:41,120 --> 00:19:43,600
tencent security

451
00:19:43,600 --> 00:19:46,640
this four years old blog explains in

452
00:19:46,640 --> 00:19:49,280
detail a vulnerability pattern related

453
00:19:49,280 --> 00:19:51,520
to memory mapping in the

454
00:19:51,520 --> 00:19:54,320
macos ios kernel the idea of the

455
00:19:54,320 --> 00:19:57,480
vulnerabilities include cbe

456
00:19:57,480 --> 00:19:59,200
2016

457
00:19:59,200 --> 00:20:03,840
17 6 20 24 and 25

458
00:20:03,840 --> 00:20:07,039
regarding the topic of memory related

459
00:20:07,039 --> 00:20:10,880
vulnerabilities embio has a blog in

460
00:20:10,880 --> 00:20:14,000
2019 that i have to mention

461
00:20:14,000 --> 00:20:15,679
if you are interested

462
00:20:15,679 --> 00:20:19,440
this article is also worth reading

463
00:20:19,440 --> 00:20:23,360
today due to the limited time i have to

464
00:20:23,360 --> 00:20:26,080
limit the discussion to the first

465
00:20:26,080 --> 00:20:29,039
king labs blog

466
00:20:30,320 --> 00:20:33,600
for friends who have not read this blog

467
00:20:33,600 --> 00:20:35,760
i will use the simplest

468
00:20:35,760 --> 00:20:38,080
words to summarize the root cause of

469
00:20:38,080 --> 00:20:40,559
this tactile vulnerabilities

470
00:20:40,559 --> 00:20:41,840
inside the

471
00:20:41,840 --> 00:20:44,400
io connector call method function the

472
00:20:44,400 --> 00:20:47,919
user mode input will be processed if the

473
00:20:47,919 --> 00:20:50,799
input user data size is less than one

474
00:20:50,799 --> 00:20:51,760
page

475
00:20:51,760 --> 00:20:54,400
this function will use memory copy to

476
00:20:54,400 --> 00:20:57,600
copy all the data into

477
00:20:57,600 --> 00:20:58,880
the kernel

478
00:20:58,880 --> 00:21:01,360
the problem is that if the input data is

479
00:21:01,360 --> 00:21:03,600
larger than one page

480
00:21:03,600 --> 00:21:07,360
io connect call method will create a

481
00:21:07,360 --> 00:21:10,640
memory descript descriptor to describe

482
00:21:10,640 --> 00:21:14,080
the target data

483
00:21:14,080 --> 00:21:16,400
and at that time

484
00:21:16,400 --> 00:21:18,880
the user process still has right

485
00:21:18,880 --> 00:21:20,000
permission

486
00:21:20,000 --> 00:21:21,919
to the map the data

487
00:21:21,919 --> 00:21:24,240
so let's think about it what does the

488
00:21:24,240 --> 00:21:27,760
right permission mean here

489
00:21:28,159 --> 00:21:29,360
it means

490
00:21:29,360 --> 00:21:31,120
talk to attack

491
00:21:31,120 --> 00:21:33,919
so in this block other also gives

492
00:21:33,919 --> 00:21:36,080
apple's fixed solution

493
00:21:36,080 --> 00:21:39,840
which seems to be related to the vm copy

494
00:21:39,840 --> 00:21:42,240
vm underscore copy flag

495
00:21:42,240 --> 00:21:44,320
if you are interested you can read the

496
00:21:44,320 --> 00:21:47,919
then source code on github

497
00:21:47,919 --> 00:21:49,280
as a

498
00:21:49,280 --> 00:21:52,159
summary of this section and the and the

499
00:21:52,159 --> 00:21:54,080
the first part

500
00:21:54,080 --> 00:21:56,080
i would like to say

501
00:21:56,080 --> 00:21:57,440
penny penny penny

502
00:21:57,440 --> 00:22:00,799
all inputs are potentially harmful

503
00:22:00,799 --> 00:22:02,480
one more thing is that

504
00:22:02,480 --> 00:22:04,159
um

505
00:22:04,159 --> 00:22:07,039
does the security update

506
00:22:07,039 --> 00:22:10,080
really work i i mean this one

507
00:22:10,080 --> 00:22:14,720
the mac mac os one can it cover all uh

508
00:22:14,720 --> 00:22:16,480
corner cases

509
00:22:16,480 --> 00:22:18,159
i don't think so

510
00:22:18,159 --> 00:22:20,960
we will see that

511
00:22:22,159 --> 00:22:26,000
um after seeing this you might say that

512
00:22:26,000 --> 00:22:27,919
these cases are not the latest

513
00:22:27,919 --> 00:22:30,159
vulnerability they are just some end

514
00:22:30,159 --> 00:22:32,240
days not one day

515
00:22:32,240 --> 00:22:34,640
nor zero day

516
00:22:34,640 --> 00:22:35,919
i would say

517
00:22:35,919 --> 00:22:38,320
if we want to find

518
00:22:38,320 --> 00:22:41,120
more interesting warner vulnerabilities

519
00:22:41,120 --> 00:22:45,200
we must have have powerful tools in hand

520
00:22:45,200 --> 00:22:46,320
here i

521
00:22:46,320 --> 00:22:49,840
would like to introduce kaimong to you

522
00:22:49,840 --> 00:22:51,919
in this chapter

523
00:22:51,919 --> 00:22:53,280
i will explain

524
00:22:53,280 --> 00:22:56,559
what kmong is and what problem can't

525
00:22:56,559 --> 00:22:58,720
solve

526
00:22:58,720 --> 00:23:02,080
chemo is an open source pre and post

527
00:23:02,080 --> 00:23:04,720
callback based framework for mac os

528
00:23:04,720 --> 00:23:06,960
kernel monitoring its source code can be

529
00:23:06,960 --> 00:23:10,240
found on github

530
00:23:11,039 --> 00:23:13,280
kimono includes many useful features

531
00:23:13,280 --> 00:23:14,880
like

532
00:23:14,880 --> 00:23:17,600
file process

533
00:23:17,600 --> 00:23:20,000
network traffic monitoring dynamic

534
00:23:20,000 --> 00:23:21,919
library and current extension monitoring

535
00:23:21,919 --> 00:23:24,080
and blocking management access control

536
00:23:24,080 --> 00:23:26,240
policy filtering and so on

537
00:23:26,240 --> 00:23:29,840
in addition kimono also integrates a

538
00:23:29,840 --> 00:23:31,520
kernel in hook engine

539
00:23:31,520 --> 00:23:34,400
through which we can hook almost any

540
00:23:34,400 --> 00:23:37,840
kernel function we want

541
00:23:38,000 --> 00:23:39,200
some of the

542
00:23:39,200 --> 00:23:42,159
above functions are not that easy to

543
00:23:42,159 --> 00:23:44,000
implement

544
00:23:44,000 --> 00:23:45,200
for example

545
00:23:45,200 --> 00:23:47,760
for file and process money operation

546
00:23:47,760 --> 00:23:50,240
monitoring k-month's solution is based

547
00:23:50,240 --> 00:23:52,720
on the kiosk kpis

548
00:23:52,720 --> 00:23:55,840
but the chaos has many limitations

549
00:23:55,840 --> 00:23:58,400
for file operating the kiosk callback

550
00:23:58,400 --> 00:24:01,200
cannot distinguish whether the operation

551
00:24:01,200 --> 00:24:05,760
is create new or open existing

552
00:24:05,760 --> 00:24:08,960
for process creation the chaos callback

553
00:24:08,960 --> 00:24:10,480
cannot get the

554
00:24:10,480 --> 00:24:12,559
command-line parameters

555
00:24:12,559 --> 00:24:13,600
this is

556
00:24:13,600 --> 00:24:17,039
unacceptable for kernel monitoring

557
00:24:17,039 --> 00:24:20,799
but all of this can be easily solved

558
00:24:20,799 --> 00:24:23,840
this screenshot is to locate the command

559
00:24:23,840 --> 00:24:26,320
line information by searching call

560
00:24:26,320 --> 00:24:28,799
stacks

561
00:24:29,120 --> 00:24:31,520
another interesting topic is related to

562
00:24:31,520 --> 00:24:34,000
mandatory access control policy

563
00:24:34,000 --> 00:24:36,559
the security implementation of mac os

564
00:24:36,559 --> 00:24:37,760
ios

565
00:24:37,760 --> 00:24:40,799
almost all relies on the

566
00:24:40,799 --> 00:24:43,440
manager access control mechanism so

567
00:24:43,440 --> 00:24:46,080
is it possible for us to dump the

568
00:24:46,080 --> 00:24:47,360
kernel's

569
00:24:47,360 --> 00:24:49,440
msa list

570
00:24:49,440 --> 00:24:50,400
a

571
00:24:50,400 --> 00:24:52,640
potential

572
00:24:52,640 --> 00:24:56,080
issue of these requirements is how to

573
00:24:56,080 --> 00:24:57,240
obtain

574
00:24:57,240 --> 00:24:58,840
unexported

575
00:24:58,840 --> 00:25:00,720
logs and

576
00:25:00,720 --> 00:25:03,919
access kernel data structure safely

577
00:25:03,919 --> 00:25:06,880
such challenges cannot stop us after

578
00:25:06,880 --> 00:25:07,760
reading

579
00:25:07,760 --> 00:25:10,799
the kernel source code i found that

580
00:25:10,799 --> 00:25:13,360
there are two callback opportunities for

581
00:25:13,360 --> 00:25:16,559
the third party between the code that

582
00:25:16,559 --> 00:25:18,799
obtained the mutex log

583
00:25:18,799 --> 00:25:22,240
this means that i can safely and dump a

584
00:25:22,240 --> 00:25:24,240
safely access and dump

585
00:25:24,240 --> 00:25:26,960
mac related data structures in the

586
00:25:26,960 --> 00:25:29,840
callback functions

587
00:25:29,840 --> 00:25:32,480
for for kernel english hook engine it

588
00:25:32,480 --> 00:25:36,159
will insert pre and post callbacks for

589
00:25:36,159 --> 00:25:37,840
the target function

590
00:25:37,840 --> 00:25:40,000
in the pre-callback handler we can

591
00:25:40,000 --> 00:25:43,200
filter the input parameters and in the

592
00:25:43,200 --> 00:25:45,840
post callback handler we can modify the

593
00:25:45,840 --> 00:25:47,520
return

594
00:25:47,520 --> 00:25:51,440
return value of the function

595
00:25:51,919 --> 00:25:53,760
this screenshot is an application of

596
00:25:53,760 --> 00:25:55,760
k-mong kerneling like hook engine i

597
00:25:55,760 --> 00:25:57,919
hooked up functions related to kernel

598
00:25:57,919 --> 00:26:00,400
extension loading downloading

599
00:26:00,400 --> 00:26:02,240
you can see that i

600
00:26:02,240 --> 00:26:04,559
passed and filtered the input parameters

601
00:26:04,559 --> 00:26:06,480
of the function in the pre-callback

602
00:26:06,480 --> 00:26:08,159
handler and

603
00:26:08,159 --> 00:26:10,159
i can even patch the target kernel

604
00:26:10,159 --> 00:26:12,640
extension

605
00:26:13,120 --> 00:26:14,080
with the

606
00:26:14,080 --> 00:26:16,799
power force part of chemo

607
00:26:16,799 --> 00:26:17,600
i

608
00:26:17,600 --> 00:26:19,039
built

609
00:26:19,039 --> 00:26:21,919
many sniffers and flooding tours last

610
00:26:21,919 --> 00:26:24,720
year i published the two research

611
00:26:24,720 --> 00:26:26,640
projects

612
00:26:26,640 --> 00:26:29,679
one related to bluetooth security and

613
00:26:29,679 --> 00:26:32,400
the other related to wifi security they

614
00:26:32,400 --> 00:26:34,559
were presented at blackhead usa and

615
00:26:34,559 --> 00:26:37,679
blackhat europe conferences

616
00:26:37,679 --> 00:26:39,600
this is a

617
00:26:39,600 --> 00:26:42,879
request the sniffer for

618
00:26:43,240 --> 00:26:45,360
io80211 family

619
00:26:45,360 --> 00:26:47,520
we can see that the

620
00:26:47,520 --> 00:26:49,919
the kernel receives a large amount of

621
00:26:49,919 --> 00:26:52,799
user data from the daemons such as

622
00:26:52,799 --> 00:26:54,799
airport d

623
00:26:54,799 --> 00:26:57,039
airport is very important to

624
00:26:57,039 --> 00:27:00,080
you the user mode daemon

625
00:27:00,080 --> 00:27:02,720
of wi-fi subsystem

626
00:27:02,720 --> 00:27:04,840
some of the requests the data

627
00:27:04,840 --> 00:27:06,559
contains

628
00:27:06,559 --> 00:27:09,279
complex formats

629
00:27:09,279 --> 00:27:11,600
and i have reported about

630
00:27:11,600 --> 00:27:13,840
18 kernel vulnerabilities

631
00:27:13,840 --> 00:27:17,279
some of which have been fixed

632
00:27:17,279 --> 00:27:20,320
and this is a sniffer for i o bluetooth

633
00:27:20,320 --> 00:27:22,960
family hci requests

634
00:27:22,960 --> 00:27:25,279
we can also see that the kernel receives

635
00:27:25,279 --> 00:27:27,120
a large amount of user data from the

636
00:27:27,120 --> 00:27:29,840
daemon bluetooth d

637
00:27:29,840 --> 00:27:32,559
more complicated is that

638
00:27:32,559 --> 00:27:35,600
third parties can customize their own

639
00:27:35,600 --> 00:27:39,120
vendor commands and most of all most of

640
00:27:39,120 --> 00:27:43,440
these commands are not documented

641
00:27:43,440 --> 00:27:45,120
i have reported about

642
00:27:45,120 --> 00:27:48,080
23 kernel vulnerabilities

643
00:27:48,080 --> 00:27:50,399
vulnerabilities last year and some of

644
00:27:50,399 --> 00:27:53,360
which have been fixed

645
00:27:53,440 --> 00:27:55,840
with the help of k-mong i hooked up

646
00:27:55,840 --> 00:27:57,919
almost all kernel mapping related

647
00:27:57,919 --> 00:28:00,159
functions

648
00:28:00,159 --> 00:28:02,480
this engineering practice

649
00:28:02,480 --> 00:28:04,159
practice have

650
00:28:04,159 --> 00:28:06,480
given me a better understanding of the

651
00:28:06,480 --> 00:28:08,640
implementation of kernel mapping

652
00:28:08,640 --> 00:28:09,440
and

653
00:28:09,440 --> 00:28:12,399
this sniffers can be easily transformed

654
00:28:12,399 --> 00:28:14,240
into fuzzing tools

655
00:28:14,240 --> 00:28:17,760
and in addition um last year i also

656
00:28:17,760 --> 00:28:20,080
implemented a simple kernel address

657
00:28:20,080 --> 00:28:22,159
sanitizer

658
00:28:22,159 --> 00:28:24,480
it's still not perfect but

659
00:28:24,480 --> 00:28:27,120
it does work

660
00:28:27,600 --> 00:28:30,880
yeah the next part is the latest kernel

661
00:28:30,880 --> 00:28:34,320
tactile vulnerability case studies

662
00:28:34,320 --> 00:28:36,080
last november

663
00:28:36,080 --> 00:28:39,120
apple fixed at least the two gpu

664
00:28:39,120 --> 00:28:41,840
graphics card vulnerabilities that i

665
00:28:41,840 --> 00:28:43,679
submitted

666
00:28:43,679 --> 00:28:44,480
but

667
00:28:44,480 --> 00:28:47,919
i only got one cv id at the moment

668
00:28:47,919 --> 00:28:51,440
the id is 3 20 20 2 7

669
00:28:51,440 --> 00:28:54,640
9 1 4

670
00:28:54,640 --> 00:28:56,240
and the pattern

671
00:28:56,240 --> 00:28:59,440
of this vulnerability looks like this

672
00:28:59,440 --> 00:29:03,200
the driver trusts the user mode input by

673
00:29:03,200 --> 00:29:04,320
mistake

674
00:29:04,320 --> 00:29:06,399
and the fatal thing is that

675
00:29:06,399 --> 00:29:10,320
um this input is directly related to the

676
00:29:10,320 --> 00:29:12,799
number of kernel loops

677
00:29:12,799 --> 00:29:14,880
so such code means

678
00:29:14,880 --> 00:29:19,440
heap outbound access read and write

679
00:29:20,159 --> 00:29:23,360
so in summary it seems that

680
00:29:23,360 --> 00:29:26,080
the root cause of the vulnerability is

681
00:29:26,080 --> 00:29:30,720
related to is related to the lack of

682
00:29:30,720 --> 00:29:33,919
effective input validation and this type

683
00:29:33,919 --> 00:29:36,320
of vulnerability can be easily captured

684
00:29:36,320 --> 00:29:39,200
by kernel address sanitizer and you will

685
00:29:39,200 --> 00:29:44,720
see why i used the words it seems that

686
00:29:45,440 --> 00:29:46,240
next

687
00:29:46,240 --> 00:29:48,559
let's look at the the patch for this

688
00:29:48,559 --> 00:29:50,080
vulnerability

689
00:29:50,080 --> 00:29:51,120
um

690
00:29:51,120 --> 00:29:53,760
it is not complicated the number of

691
00:29:53,760 --> 00:29:55,279
loops is

692
00:29:55,279 --> 00:29:59,679
limited to a fixed value here

693
00:30:00,799 --> 00:30:04,080
before the the loop starts

694
00:30:04,080 --> 00:30:05,360
this time

695
00:30:05,360 --> 00:30:08,640
everything looks fine but let's think

696
00:30:08,640 --> 00:30:09,919
about it

697
00:30:09,919 --> 00:30:13,360
more carefully

698
00:30:14,480 --> 00:30:16,399
there are

699
00:30:16,399 --> 00:30:17,520
there is

700
00:30:17,520 --> 00:30:19,919
there are two questions i

701
00:30:19,919 --> 00:30:22,399
leave to you

702
00:30:22,399 --> 00:30:25,840
is it possible for us to bypass the

703
00:30:25,840 --> 00:30:30,240
security update 20 20 20 007 and

704
00:30:30,240 --> 00:30:33,520
re-trigger the vulnerability

705
00:30:33,520 --> 00:30:34,480
and

706
00:30:34,480 --> 00:30:35,600
also

707
00:30:35,600 --> 00:30:37,679
input buffer is on the

708
00:30:37,679 --> 00:30:39,039
kernel heap

709
00:30:39,039 --> 00:30:43,440
is it possible to raise against it from

710
00:30:43,440 --> 00:30:46,559
for example user mode

711
00:30:46,880 --> 00:30:48,880
the answer is yes

712
00:30:48,880 --> 00:30:52,240
i have a demo for for this

713
00:30:54,399 --> 00:30:56,639
okay

714
00:30:59,600 --> 00:31:01,919
yeah today is

715
00:31:01,919 --> 00:31:03,360
the march

716
00:31:03,360 --> 00:31:05,279
uh 29th

717
00:31:05,279 --> 00:31:07,840
it's already monday yeah today's monday

718
00:31:07,840 --> 00:31:09,360
and

719
00:31:09,360 --> 00:31:13,039
the latest version of mac os

720
00:31:13,039 --> 00:31:15,279
bixer is

721
00:31:15,279 --> 00:31:16,840
is

722
00:31:16,840 --> 00:31:21,840
11.3 beta 5 and the build number is 20e

723
00:31:21,840 --> 00:31:24,840
5217a

724
00:31:33,600 --> 00:31:36,000
yeah and the the kernel version is the

725
00:31:36,000 --> 00:31:38,480
latest one

726
00:31:38,480 --> 00:31:40,559
please allow me

727
00:31:40,559 --> 00:31:45,960
wrong my poc my tour

728
00:31:47,200 --> 00:31:50,159
then we can see that after a few seconds

729
00:31:50,159 --> 00:31:51,679
yeah we can see that the operating

730
00:31:51,679 --> 00:31:54,960
system has crashed

731
00:31:57,519 --> 00:32:00,720
yeah i actually prepared two versions of

732
00:32:00,720 --> 00:32:04,240
the slides the current version and the

733
00:32:04,240 --> 00:32:07,519
more complicated version since apple has

734
00:32:07,519 --> 00:32:10,159
not fixed the this serious

735
00:32:10,159 --> 00:32:12,399
vulnerabilities i cannot share the

736
00:32:12,399 --> 00:32:14,950
details with you yet

737
00:32:14,950 --> 00:32:18,009
[Music]

738
00:32:18,320 --> 00:32:20,640
here is a summary of the

739
00:32:20,640 --> 00:32:22,880
of patch bypass

740
00:32:22,880 --> 00:32:25,440
as the vulnerability has not been fixed

741
00:32:25,440 --> 00:32:27,440
please forgive me

742
00:32:27,440 --> 00:32:29,760
for not disclosing the details of the

743
00:32:29,760 --> 00:32:31,760
vulnerabilities

744
00:32:31,760 --> 00:32:36,320
i i will write a blog blog post

745
00:32:36,320 --> 00:32:38,559
after

746
00:32:38,559 --> 00:32:40,640
the patch released

747
00:32:40,640 --> 00:32:43,519
um tactile vulnerabilities such as cbe

748
00:32:43,519 --> 00:32:46,240
2020-27914

749
00:32:46,240 --> 00:32:48,080
have been hidden in plant site for a

750
00:32:48,080 --> 00:32:49,440
long time

751
00:32:49,440 --> 00:32:51,360
and even after i submitted the

752
00:32:51,360 --> 00:32:53,279
vulnerabilities

753
00:32:53,279 --> 00:32:57,840
they were not correctly identified by

754
00:32:57,919 --> 00:33:00,559
by by the developers

755
00:33:00,559 --> 00:33:06,000
this leads to the patch can be bypassed

756
00:33:06,960 --> 00:33:08,240
okay

757
00:33:08,240 --> 00:33:10,000
the end

758
00:33:10,000 --> 00:33:12,720
last part

759
00:33:13,200 --> 00:33:16,240
from the perspective of security

760
00:33:16,240 --> 00:33:18,000
research um

761
00:33:18,000 --> 00:33:19,039
i

762
00:33:19,039 --> 00:33:20,559
i would say

763
00:33:20,559 --> 00:33:23,840
uh the first one vulnerabilities like

764
00:33:23,840 --> 00:33:25,200
2020

765
00:33:25,200 --> 00:33:26,720
279

766
00:33:26,720 --> 00:33:30,000
uh 1 4 and 279

767
00:33:30,000 --> 00:33:31,919
36

768
00:33:31,919 --> 00:33:33,440
have been hidden in planetside for a

769
00:33:33,440 --> 00:33:36,320
long time they remind us to re-examine

770
00:33:36,320 --> 00:33:37,039
the

771
00:33:37,039 --> 00:33:39,440
the kernel memory mapping mechanism of

772
00:33:39,440 --> 00:33:41,519
mac os and ios

773
00:33:41,519 --> 00:33:42,640
and the

774
00:33:42,640 --> 00:33:44,799
number two sometimes the security patch

775
00:33:44,799 --> 00:33:47,919
can be bypassed yeah um

776
00:33:47,919 --> 00:33:49,600
in the

777
00:33:49,600 --> 00:33:50,960
um

778
00:33:50,960 --> 00:33:55,120
in the black hat europe

779
00:33:55,440 --> 00:33:58,399
presentation i i presented

780
00:33:58,399 --> 00:33:59,279
i

781
00:33:59,279 --> 00:34:01,279
i have another example

782
00:34:01,279 --> 00:34:02,159
it's a

783
00:34:02,159 --> 00:34:03,519
bluetooth

784
00:34:03,519 --> 00:34:05,840
hci

785
00:34:05,840 --> 00:34:08,960
subsystem example i can bypass the

786
00:34:08,960 --> 00:34:10,639
the patch

787
00:34:10,639 --> 00:34:12,800
so understanding the implementation of

788
00:34:12,800 --> 00:34:15,520
paths is often helpful for for

789
00:34:15,520 --> 00:34:17,280
vulnerability research

790
00:34:17,280 --> 00:34:18,800
and

791
00:34:18,800 --> 00:34:21,520
with this research as a new starting

792
00:34:21,520 --> 00:34:26,079
point i believe we can do more

793
00:34:26,159 --> 00:34:27,040
and

794
00:34:27,040 --> 00:34:28,879
from the perspective of security

795
00:34:28,879 --> 00:34:30,719
engineering

796
00:34:30,719 --> 00:34:33,199
i would say

797
00:34:33,199 --> 00:34:36,000
with the help of cayman project

798
00:34:36,000 --> 00:34:40,560
i believe we can do better

799
00:34:40,639 --> 00:34:42,560
yeah thank you thank you very much thank

800
00:34:42,560 --> 00:34:43,839
you for your time

801
00:34:43,839 --> 00:34:46,839
bye

802
00:34:48,560 --> 00:34:50,639
you

