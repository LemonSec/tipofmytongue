1
00:00:01,130 --> 00:00:14,700
[Music]

2
00:00:16,480 --> 00:00:18,240
welcome everybody to our session on the

3
00:00:18,240 --> 00:00:19,600
cost of complexity different

4
00:00:19,600 --> 00:00:21,119
vulnerabilities while implementing the

5
00:00:21,119 --> 00:00:23,519
same rfc the session will be presented

6
00:00:23,519 --> 00:00:25,039
by myself daniel dos santos from

7
00:00:25,039 --> 00:00:26,960
forskout research labs and shlomi

8
00:00:26,960 --> 00:00:28,880
obermann from jsof

9
00:00:28,880 --> 00:00:31,279
so before we start who we are so this is

10
00:00:31,279 --> 00:00:33,440
a collaborative research effort between

11
00:00:33,440 --> 00:00:35,520
four scout and jsof and although it's

12
00:00:35,520 --> 00:00:38,000
presented today by myself and by shlami

13
00:00:38,000 --> 00:00:39,920
there were several other people involved

14
00:00:39,920 --> 00:00:41,280
in this research and we would just like

15
00:00:41,280 --> 00:00:44,399
to acknowledge them here from both sides

16
00:00:44,399 --> 00:00:45,280
so

17
00:00:45,280 --> 00:00:47,120
a quick outline of this presentation

18
00:00:47,120 --> 00:00:48,719
right um

19
00:00:48,719 --> 00:00:50,399
i will go give an introduction of what

20
00:00:50,399 --> 00:00:52,719
this research was all about uh what

21
00:00:52,719 --> 00:00:54,480
we're calling name wreck a set of new

22
00:00:54,480 --> 00:00:56,480
vulnerabilities that basically break

23
00:00:56,480 --> 00:00:59,840
some dns client-side implementations

24
00:00:59,840 --> 00:01:01,520
what are the impacts of these

25
00:01:01,520 --> 00:01:02,960
vulnerabilities

26
00:01:02,960 --> 00:01:05,519
what kind of mitigation actions can we

27
00:01:05,519 --> 00:01:08,400
take to actually fix dns implementations

28
00:01:08,400 --> 00:01:10,960
in the future now and in the future and

29
00:01:10,960 --> 00:01:12,720
a little bit of a conclusion and main

30
00:01:12,720 --> 00:01:15,040
takeaways from this research so let's go

31
00:01:15,040 --> 00:01:16,960
to the introduction so

32
00:01:16,960 --> 00:01:18,640
this research is part of what we've been

33
00:01:18,640 --> 00:01:20,799
calling project memoria uh project

34
00:01:20,799 --> 00:01:22,560
memorial is a large study of embedded

35
00:01:22,560 --> 00:01:25,680
tcp stack security uh we really want to

36
00:01:25,680 --> 00:01:27,280
understand why are they vulnerable how

37
00:01:27,280 --> 00:01:28,720
are they vulnerable and actually what

38
00:01:28,720 --> 00:01:30,320
the cyber security community can do

39
00:01:30,320 --> 00:01:31,520
about it

40
00:01:31,520 --> 00:01:33,040
this is an initiative that is led by

41
00:01:33,040 --> 00:01:34,720
four scout research labs with several

42
00:01:34,720 --> 00:01:36,880
collaborations including jsofthen and

43
00:01:36,880 --> 00:01:39,119
others

44
00:01:39,119 --> 00:01:40,880
in previous research that was done in

45
00:01:40,880 --> 00:01:43,119
tcp stacks we had examples such as

46
00:01:43,119 --> 00:01:45,680
ripple 20 a set of 19 vulnerabilities on

47
00:01:45,680 --> 00:01:48,159
the track to cpip stack that revealed

48
00:01:48,159 --> 00:01:50,159
massive supply chain effects in terms of

49
00:01:50,159 --> 00:01:52,399
vendors and affected devices then we had

50
00:01:52,399 --> 00:01:55,200
amnesia 33 that was done at four scout

51
00:01:55,200 --> 00:01:58,240
research labs that um revealed a set of

52
00:01:58,240 --> 00:02:00,320
33 vulnerabilities on four open source

53
00:02:00,320 --> 00:02:01,920
stacks and kind of continued the

54
00:02:01,920 --> 00:02:04,719
momentum and the trend of tcpap stack

55
00:02:04,719 --> 00:02:07,520
vulnerabilities showing that the similar

56
00:02:07,520 --> 00:02:09,679
supply chain effects found in closed

57
00:02:09,679 --> 00:02:11,440
source code are also

58
00:02:11,440 --> 00:02:14,160
found in open source stacks

59
00:02:14,160 --> 00:02:16,879
and more recently uh in february of this

60
00:02:16,879 --> 00:02:18,080
year

61
00:02:18,080 --> 00:02:20,720
we released number jack a set of nine

62
00:02:20,720 --> 00:02:22,480
vulnerabilities that are actually

63
00:02:22,480 --> 00:02:24,720
related to predictable uh tcp initial

64
00:02:24,720 --> 00:02:27,440
sequence numbers in nine different tcp

65
00:02:27,440 --> 00:02:29,599
stacks so this previous body of work

66
00:02:29,599 --> 00:02:32,640
really shows the fact that by now we

67
00:02:32,640 --> 00:02:34,959
know that tcp stacks have several

68
00:02:34,959 --> 00:02:37,040
vulnerabilities and it's not

69
00:02:37,040 --> 00:02:40,000
a surprise when new vulnerabilities come

70
00:02:40,000 --> 00:02:41,920
out but they have

71
00:02:41,920 --> 00:02:45,120
very interesting nuances and it's it's

72
00:02:45,120 --> 00:02:47,519
uh you can always learn new things when

73
00:02:47,519 --> 00:02:50,640
you look more closely at gcpap stacks

74
00:02:50,640 --> 00:02:53,040
you can find vulnerabilities from

75
00:02:53,040 --> 00:02:55,120
that were known in the past such as

76
00:02:55,120 --> 00:02:57,120
number jack predicted by a sense is an

77
00:02:57,120 --> 00:02:58,879
issue that has been going on for for 20

78
00:02:58,879 --> 00:03:00,239
years

79
00:03:00,239 --> 00:03:01,599
you can also find new types of

80
00:03:01,599 --> 00:03:03,200
vulnerabilities and you basically find a

81
00:03:03,200 --> 00:03:05,760
mix of all of that right and this is

82
00:03:05,760 --> 00:03:08,400
very important because of the current

83
00:03:08,400 --> 00:03:11,200
iot scenario that we have nowadays where

84
00:03:11,200 --> 00:03:12,879
there are billions and billions of

85
00:03:12,879 --> 00:03:15,599
devices being deployed out there uh from

86
00:03:15,599 --> 00:03:18,640
seven different vendors uh and and all

87
00:03:18,640 --> 00:03:22,080
of those use code that we all know that

88
00:03:22,080 --> 00:03:23,599
in the end you know the code that runs

89
00:03:23,599 --> 00:03:25,360
in about the devices

90
00:03:25,360 --> 00:03:28,640
uh might not be the most secure ever and

91
00:03:28,640 --> 00:03:30,319
it's it

92
00:03:30,319 --> 00:03:32,480
tends to be very very old code right

93
00:03:32,480 --> 00:03:35,599
this is what uh previous research has

94
00:03:35,599 --> 00:03:38,319
has shown and uh it's kind of a

95
00:03:38,319 --> 00:03:40,159
motivation for for this work that we're

96
00:03:40,159 --> 00:03:41,599
talking about today

97
00:03:41,599 --> 00:03:43,760
so why did we decide to look more

98
00:03:43,760 --> 00:03:45,440
closely at dns

99
00:03:45,440 --> 00:03:47,680
so dns is the most affected tcp

100
00:03:47,680 --> 00:03:49,680
component in previous research so in

101
00:03:49,680 --> 00:03:53,360
ripple 20 the the most critical um

102
00:03:53,360 --> 00:03:56,239
vulnerability that led to an rce was cv

103
00:03:56,239 --> 00:03:58,879
2020 11901

104
00:03:58,879 --> 00:04:00,799
on the track gcpap stack which was

105
00:04:00,799 --> 00:04:03,360
related to dns and a specific feature of

106
00:04:03,360 --> 00:04:04,720
dns that we will be discussing

107
00:04:04,720 --> 00:04:07,040
throughout this presentation

108
00:04:07,040 --> 00:04:10,959
and then in amnesia 33 15 out of the 33

109
00:04:10,959 --> 00:04:13,280
cves that we found were actually on dns

110
00:04:13,280 --> 00:04:16,160
clients and three of those um

111
00:04:16,160 --> 00:04:18,238
were potential rc's

112
00:04:18,238 --> 00:04:20,798
so if if you look at the the image this

113
00:04:20,798 --> 00:04:23,040
on the on the left hand side of this uh

114
00:04:23,040 --> 00:04:25,759
presentation you can see that dns is by

115
00:04:25,759 --> 00:04:28,720
far the most affected component uh in in

116
00:04:28,720 --> 00:04:31,440
previous research in tcpap stack

117
00:04:31,440 --> 00:04:33,360
and another interesting point is that

118
00:04:33,360 --> 00:04:35,040
protocol complexity is a good

119
00:04:35,040 --> 00:04:36,960
predictable vulnerabilities

120
00:04:36,960 --> 00:04:39,040
there are other major findings on dns we

121
00:04:39,040 --> 00:04:40,800
all know that dns is a complex protocol

122
00:04:40,800 --> 00:04:42,240
and we'll go into some of the specific

123
00:04:42,240 --> 00:04:44,960
complexities in this presentation but

124
00:04:44,960 --> 00:04:48,639
it it tends to be a good um

125
00:04:48,639 --> 00:04:51,120
predictor of uh new vulnerabilities

126
00:04:51,120 --> 00:04:52,880
right so for instance very recently

127
00:04:52,880 --> 00:04:55,199
there was a work of jsof that reviewed a

128
00:04:55,199 --> 00:04:57,919
set of seven cvs on the dns mask

129
00:04:57,919 --> 00:05:01,120
uh dns forwarder uh that was called dns

130
00:05:01,120 --> 00:05:03,520
spook but also at the end of last year

131
00:05:03,520 --> 00:05:05,840
uh we had vulnerabilities such as sigrad

132
00:05:05,840 --> 00:05:08,320
we had said dns we all know about uh

133
00:05:08,320 --> 00:05:10,479
francis the kaminsky attack and and

134
00:05:10,479 --> 00:05:12,320
there are several major vulnerabilities

135
00:05:12,320 --> 00:05:14,320
on dns that

136
00:05:14,320 --> 00:05:17,280
actually uh really increase the attack

137
00:05:17,280 --> 00:05:19,600
surface of devices because dns is

138
00:05:19,600 --> 00:05:22,720
typically uh externally accessible uh so

139
00:05:22,720 --> 00:05:26,080
usually the uh devices request

140
00:05:26,080 --> 00:05:28,639
um domain names from from external uh

141
00:05:28,639 --> 00:05:31,840
servers and that means that there is a

142
00:05:31,840 --> 00:05:33,919
potential for remote exploitation of

143
00:05:33,919 --> 00:05:36,639
those of those devices

144
00:05:36,639 --> 00:05:38,960
so let's talk quickly about what dns

145
00:05:38,960 --> 00:05:41,360
actually is right so dns is a protocol

146
00:05:41,360 --> 00:05:43,840
in a system that allows um

147
00:05:43,840 --> 00:05:46,240
system devices on the internet to map

148
00:05:46,240 --> 00:05:48,080
between domain names and actual ip

149
00:05:48,080 --> 00:05:51,199
addresses so basically a client resolves

150
00:05:51,199 --> 00:05:54,320
a name such as example.com by querying a

151
00:05:54,320 --> 00:05:56,960
specific dns server

152
00:05:56,960 --> 00:05:58,960
and the dns server then looks up the

153
00:05:58,960 --> 00:06:00,800
name and returns a response we all know

154
00:06:00,800 --> 00:06:02,639
that dns is hierarchical and then there

155
00:06:02,639 --> 00:06:04,400
are recursive queries and all of that

156
00:06:04,400 --> 00:06:05,919
we're not going into these details

157
00:06:05,919 --> 00:06:08,000
because it's not really uh relevant in

158
00:06:08,000 --> 00:06:09,440
this presentation right let's let's

159
00:06:09,440 --> 00:06:11,840
stick to the basics here

160
00:06:11,840 --> 00:06:14,080
um so how it

161
00:06:14,080 --> 00:06:17,039
how are just dns uh requests and replies

162
00:06:17,039 --> 00:06:19,680
encoded uh in actual network packets

163
00:06:19,680 --> 00:06:22,880
right so domain names such as

164
00:06:22,880 --> 00:06:26,000
example.com are sequences of labels and

165
00:06:26,000 --> 00:06:28,319
each label is preset preceded by a

166
00:06:28,319 --> 00:06:30,000
length byte right so you can see in the

167
00:06:30,000 --> 00:06:32,000
example there that there's a length byte

168
00:06:32,000 --> 00:06:34,240
uh that has the value of three and then

169
00:06:34,240 --> 00:06:36,639
three uh actual

170
00:06:36,639 --> 00:06:39,280
characters www then the length seven

171
00:06:39,280 --> 00:06:41,120
then the characters for example then the

172
00:06:41,120 --> 00:06:43,120
length three and then the the the

173
00:06:43,120 --> 00:06:44,800
characters for com

174
00:06:44,800 --> 00:06:46,240
um

175
00:06:46,240 --> 00:06:49,599
and there is a clever mechanism of

176
00:06:49,599 --> 00:06:52,160
compression in dns but we will explore

177
00:06:52,160 --> 00:06:55,360
it more in details uh later on but this

178
00:06:55,360 --> 00:06:57,599
mechanism allows um

179
00:06:57,599 --> 00:07:00,160
implementations to replace sequences of

180
00:07:00,160 --> 00:07:02,319
labels with pointers to prior occurrence

181
00:07:02,319 --> 00:07:04,319
of the same sequence so for instance if

182
00:07:04,319 --> 00:07:08,520
you have uh www.gmail.comsmtp.gmail.com

183
00:07:10,000 --> 00:07:11,440
uh you can

184
00:07:11,440 --> 00:07:15,280
you don't have to to do gmail.com um

185
00:07:15,280 --> 00:07:16,880
twice right you don't need to repeat

186
00:07:16,880 --> 00:07:19,199
that in in a network packet in response

187
00:07:19,199 --> 00:07:21,520
you can basically point back to the pack

188
00:07:21,520 --> 00:07:24,080
to the place uh the offset in the packet

189
00:07:24,080 --> 00:07:26,800
where the uh the previous occurrence of

190
00:07:26,800 --> 00:07:29,199
gmail.com was um

191
00:07:29,199 --> 00:07:31,039
this pointer is encoded actually in two

192
00:07:31,039 --> 00:07:32,960
bytes so there's a

193
00:07:32,960 --> 00:07:36,240
first two bits uh set to to one so one

194
00:07:36,240 --> 00:07:38,319
one and then the actual encoding of the

195
00:07:38,319 --> 00:07:39,919
offset in the in the packet where you

196
00:07:39,919 --> 00:07:42,400
want this to to point to this message

197
00:07:42,400 --> 00:07:45,120
compression is used not just in dns but

198
00:07:45,120 --> 00:07:48,240
also in dhcp in multicast dns ipv6

199
00:07:48,240 --> 00:07:51,039
router advertisement and basically

200
00:07:51,039 --> 00:07:53,120
several other protocols in in internet

201
00:07:53,120 --> 00:07:55,919
specifications

202
00:07:55,919 --> 00:07:58,639
interestingly enough this compression

203
00:07:58,639 --> 00:08:00,160
mechanism has

204
00:08:00,160 --> 00:08:02,879
led to 20 years of known vulnerabilities

205
00:08:02,879 --> 00:08:04,240
and actually even before this

206
00:08:04,240 --> 00:08:06,160
vulnerability started popping up or more

207
00:08:06,160 --> 00:08:08,240
or less at the same time as they started

208
00:08:08,240 --> 00:08:10,240
popping up there were some comments

209
00:08:10,240 --> 00:08:12,879
already about the issues with dns

210
00:08:12,879 --> 00:08:15,039
compression right so one

211
00:08:15,039 --> 00:08:17,039
one comment from dj bernstein around

212
00:08:17,039 --> 00:08:18,800
2001

213
00:08:18,800 --> 00:08:20,639
is that the problem with dns compression

214
00:08:20,639 --> 00:08:22,479
is the amount of code required to parse

215
00:08:22,479 --> 00:08:24,000
it as you saw in the previous slide it's

216
00:08:24,000 --> 00:08:26,319
not really an easy mechanism to

217
00:08:26,319 --> 00:08:28,720
implement so to reliably locate all

218
00:08:28,720 --> 00:08:30,720
these names take some some work some

219
00:08:30,720 --> 00:08:34,000
actual quote that would be unnecessary

220
00:08:34,000 --> 00:08:36,399
uh for for dns implementations otherwise

221
00:08:36,399 --> 00:08:38,640
right and and there could have been

222
00:08:38,640 --> 00:08:40,479
other types of implementations of

223
00:08:40,479 --> 00:08:42,799
compression but in any case this this is

224
00:08:42,799 --> 00:08:45,600
what we have uh for more than 20 years

225
00:08:45,600 --> 00:08:47,600
in the dns system

226
00:08:47,600 --> 00:08:49,760
and if you look at

227
00:08:49,760 --> 00:08:51,360
examples of vulnerabilities that were

228
00:08:51,360 --> 00:08:53,600
found in this previous 20 years you can

229
00:08:53,600 --> 00:08:56,560
really see that it affects from specific

230
00:08:56,560 --> 00:09:00,560
devices such as a cisco iphone there um

231
00:09:00,560 --> 00:09:01,920
to

232
00:09:01,920 --> 00:09:04,399
known networking tools such as tcp dump

233
00:09:04,399 --> 00:09:07,519
and ethereal to actually media players

234
00:09:07,519 --> 00:09:08,959
like vlc

235
00:09:08,959 --> 00:09:09,920
two

236
00:09:09,920 --> 00:09:13,200
more recently tcp stacks that we

237
00:09:13,200 --> 00:09:15,279
uh examined in previous research such as

238
00:09:15,279 --> 00:09:17,920
ripple 20 and amnesia 33 right and you

239
00:09:17,920 --> 00:09:20,000
can see that there's an increasing trend

240
00:09:20,000 --> 00:09:22,640
of these vulnerabilities we saw a few um

241
00:09:22,640 --> 00:09:25,680
at the early 2000s but then only in the

242
00:09:25,680 --> 00:09:28,320
previous year there are more than than

243
00:09:28,320 --> 00:09:30,880
actually five examples there um and of

244
00:09:30,880 --> 00:09:31,839
course there are also other

245
00:09:31,839 --> 00:09:32,880
vulnerabilities that we're not

246
00:09:32,880 --> 00:09:34,560
mentioning here uh because they don't

247
00:09:34,560 --> 00:09:36,880
have cpes because they affect other diff

248
00:09:36,880 --> 00:09:38,399
kinds of products and so on so we just

249
00:09:38,399 --> 00:09:40,720
really want to say that this is a

250
00:09:40,720 --> 00:09:44,000
widespread uh problem

251
00:09:44,000 --> 00:09:46,560
um and that leads us to actually name

252
00:09:46,560 --> 00:09:47,760
rack which is this new set of

253
00:09:47,760 --> 00:09:49,519
vulnerabilities that we found and to

254
00:09:49,519 --> 00:09:51,120
discuss this set of vulnerabilities and

255
00:09:51,120 --> 00:09:52,880
the technicalities behind them i will

256
00:09:52,880 --> 00:09:56,240
now hand it over to shlomi and um i will

257
00:09:56,240 --> 00:09:58,080
pick it back i'll pick the presentation

258
00:09:58,080 --> 00:09:59,920
back after uh shlomi gives us these

259
00:09:59,920 --> 00:10:01,920
details and to talk about the impact of

260
00:10:01,920 --> 00:10:04,560
the vulnerability so thank you

261
00:10:04,560 --> 00:10:07,680
thank you danielle i'll now discuss um a

262
00:10:07,680 --> 00:10:09,440
little bit about what vulnerabilities we

263
00:10:09,440 --> 00:10:11,920
were trying to find uh in the name wreck

264
00:10:11,920 --> 00:10:14,320
research and what vulnerabilities we

265
00:10:14,320 --> 00:10:15,760
ended up finding

266
00:10:15,760 --> 00:10:18,320
so the goal of the research was to find

267
00:10:18,320 --> 00:10:20,959
issues with dns compression

268
00:10:20,959 --> 00:10:24,640
a specific rfc made to save space in dns

269
00:10:24,640 --> 00:10:26,240
response packets

270
00:10:26,240 --> 00:10:27,040
the

271
00:10:27,040 --> 00:10:28,959
motivation for this was

272
00:10:28,959 --> 00:10:31,040
issues that we saw in ripple 20 and

273
00:10:31,040 --> 00:10:32,640
amnesia 33

274
00:10:32,640 --> 00:10:34,959
research and the fact that we saw that

275
00:10:34,959 --> 00:10:35,680
the

276
00:10:35,680 --> 00:10:37,279
code was quite complex the logic was

277
00:10:37,279 --> 00:10:38,880
quite complex

278
00:10:38,880 --> 00:10:40,800
and

279
00:10:40,800 --> 00:10:42,480
the different implementations found

280
00:10:42,480 --> 00:10:46,560
different ways to interpret the rfc um

281
00:10:46,560 --> 00:10:48,240
so we quickly knew we had good

282
00:10:48,240 --> 00:10:50,240
potentials uh for

283
00:10:50,240 --> 00:10:52,160
um remote contribution vulnerabilities

284
00:10:52,160 --> 00:10:54,800
and for vulnerabilities in general

285
00:10:54,800 --> 00:10:56,640
we also saw that some stacks don't

286
00:10:56,640 --> 00:10:58,320
implement compression which is a way to

287
00:10:58,320 --> 00:10:59,519
avoid these

288
00:10:59,519 --> 00:11:01,519
vulnerabilities but of course only

289
00:11:01,519 --> 00:11:02,640
allows

290
00:11:02,640 --> 00:11:05,200
partial functionality

291
00:11:05,200 --> 00:11:08,399
we wanted to have a varied selection of

292
00:11:08,399 --> 00:11:10,240
different stacks we didn't want to have

293
00:11:10,240 --> 00:11:12,240
different stacks of the same type or

294
00:11:12,240 --> 00:11:14,480
originating from the same sources and so

295
00:11:14,480 --> 00:11:17,120
it shows um both

296
00:11:17,120 --> 00:11:19,120
stacks meant for embedded devices

297
00:11:19,120 --> 00:11:21,279
general purpose computing stacks open

298
00:11:21,279 --> 00:11:23,440
source closed stock source

299
00:11:23,440 --> 00:11:25,760
new stacks older stacks so that we have

300
00:11:25,760 --> 00:11:27,519
a very wide view

301
00:11:27,519 --> 00:11:28,880
of

302
00:11:28,880 --> 00:11:31,800
implementations of the same code

303
00:11:31,800 --> 00:11:34,320
[Music]

304
00:11:34,320 --> 00:11:36,880
our first results were a little bit

305
00:11:36,880 --> 00:11:38,720
underwhelming

306
00:11:38,720 --> 00:11:39,839
we found

307
00:11:39,839 --> 00:11:42,000
some stacks that were not vulnerable we

308
00:11:42,000 --> 00:11:44,000
found some vulnerabilities in the nordic

309
00:11:44,000 --> 00:11:45,519
sdk

310
00:11:45,519 --> 00:11:46,880
which is quite popular in embedded

311
00:11:46,880 --> 00:11:48,000
devices

312
00:11:48,000 --> 00:11:49,839
when we approached them they replied

313
00:11:49,839 --> 00:11:51,200
very quickly said that this is

314
00:11:51,200 --> 00:11:54,480
experimental code and that

315
00:11:54,480 --> 00:11:55,920
the vulnerabilities had already been

316
00:11:55,920 --> 00:11:58,000
fixed in production code uh this is code

317
00:11:58,000 --> 00:11:59,920
that we found online so it was published

318
00:11:59,920 --> 00:12:02,160
we'll discuss uh we'll discuss this uh

319
00:12:02,160 --> 00:12:03,760
later on in in

320
00:12:03,760 --> 00:12:05,279
in the talk

321
00:12:05,279 --> 00:12:08,399
um as we continued our research um

322
00:12:08,399 --> 00:12:09,680
we did find

323
00:12:09,680 --> 00:12:12,399
vulnerabilities in uh pretty prominent

324
00:12:12,399 --> 00:12:13,279
uh

325
00:12:13,279 --> 00:12:15,360
pretty prominent

326
00:12:15,360 --> 00:12:16,480
stacks

327
00:12:16,480 --> 00:12:18,800
we also found a lot of issues

328
00:12:18,800 --> 00:12:21,120
that were of different types but in the

329
00:12:21,120 --> 00:12:22,240
same area

330
00:12:22,240 --> 00:12:24,240
specifically in nucleus net we found

331
00:12:24,240 --> 00:12:26,000
quite a few issues uh quite a few

332
00:12:26,000 --> 00:12:28,320
anti-patterns and um we'll discuss the

333
00:12:28,320 --> 00:12:30,480
different anti-patterns that we found um

334
00:12:30,480 --> 00:12:32,000
we decided to

335
00:12:32,000 --> 00:12:33,519
document them and discuss them for

336
00:12:33,519 --> 00:12:36,480
better implementation of this rfc uh in

337
00:12:36,480 --> 00:12:39,040
freebsd we found uh a vulnerability in

338
00:12:39,040 --> 00:12:41,279
the dhcp client uh we didn't look at the

339
00:12:41,279 --> 00:12:43,279
dns client though i think uh someone may

340
00:12:43,279 --> 00:12:45,279
have looked at it at a later date

341
00:12:45,279 --> 00:12:46,160
um

342
00:12:46,160 --> 00:12:49,519
we found uh in an old version of vxworks

343
00:12:49,519 --> 00:12:51,279
an end-of-life version of vxwork we

344
00:12:51,279 --> 00:12:53,680
found

345
00:12:53,680 --> 00:12:55,279
stack overflow

346
00:12:55,279 --> 00:12:57,360
we later discovered that this stack

347
00:12:57,360 --> 00:12:58,880
overflow was already

348
00:12:58,880 --> 00:13:02,160
found and documented by researchers from

349
00:13:02,160 --> 00:13:04,480
exodus intelligent

350
00:13:04,480 --> 00:13:08,000
at the time the vulnerability the vxwork

351
00:13:08,000 --> 00:13:09,519
stack that the vulnerabilities were in

352
00:13:09,519 --> 00:13:11,120
was already end of life

353
00:13:11,120 --> 00:13:13,440
um so we do know that this vulnerability

354
00:13:13,440 --> 00:13:15,839
had been fixed in the latest versions of

355
00:13:15,839 --> 00:13:18,320
vxworks but we're not quite sure of the

356
00:13:18,320 --> 00:13:20,639
uh the status in different versions

357
00:13:20,639 --> 00:13:23,040
we'll discuss this uh in the impact at

358
00:13:23,040 --> 00:13:26,079
the time there was no cv assigned um we

359
00:13:26,079 --> 00:13:29,360
we recently uh signed a cve uh for this

360
00:13:29,360 --> 00:13:31,760
vulnerability um and we found a

361
00:13:31,760 --> 00:13:34,800
vulnerability in the net x

362
00:13:34,800 --> 00:13:37,600
stack uh the the stack of thread x

363
00:13:37,600 --> 00:13:39,600
operating system uh currently maintained

364
00:13:39,600 --> 00:13:42,079
by microsoft um this is a vulnerability

365
00:13:42,079 --> 00:13:44,480
that could lead to a denial of servers

366
00:13:44,480 --> 00:13:46,240
maybe a remote code execution it would

367
00:13:46,240 --> 00:13:47,519
be quite hard

368
00:13:47,519 --> 00:13:49,360
to exploit

369
00:13:49,360 --> 00:13:51,839
unfortunately microsoft did attempt to

370
00:13:51,839 --> 00:13:54,639
fix this vulnerability but decided not

371
00:13:54,639 --> 00:13:56,800
to assign a cve and not to document the

372
00:13:56,800 --> 00:13:59,199
vulnerability in any way

373
00:13:59,199 --> 00:14:01,440
they cited

374
00:14:01,440 --> 00:14:03,519
very low impact to the vulnerability

375
00:14:03,519 --> 00:14:05,440
though we're not sure exactly what the

376
00:14:05,440 --> 00:14:06,560
uh

377
00:14:06,560 --> 00:14:09,360
the meaning or the reason uh for that is

378
00:14:09,360 --> 00:14:11,199
um let's talk a little bit about the

379
00:14:11,199 --> 00:14:12,800
different types of vulnerabilities that

380
00:14:12,800 --> 00:14:16,000
we found specifically in uh nucleus net

381
00:14:16,000 --> 00:14:16,880
so

382
00:14:16,880 --> 00:14:18,880
the first type of vulnerability we found

383
00:14:18,880 --> 00:14:19,760
is

384
00:14:19,760 --> 00:14:22,160
lack of transaction id and port id

385
00:14:22,160 --> 00:14:24,399
validation and randomization so the

386
00:14:24,399 --> 00:14:26,720
integrity of dns the matching

387
00:14:26,720 --> 00:14:28,560
between requests sent and responses

388
00:14:28,560 --> 00:14:29,680
received

389
00:14:29,680 --> 00:14:31,120
the way that we know that we received

390
00:14:31,120 --> 00:14:32,480
response from

391
00:14:32,480 --> 00:14:35,680
the right server is through

392
00:14:35,680 --> 00:14:37,680
these two random numbers a random port

393
00:14:37,680 --> 00:14:39,680
id and a random transaction id these

394
00:14:39,680 --> 00:14:41,680
should both be randomized and they

395
00:14:41,680 --> 00:14:43,519
should be verified when we receive the

396
00:14:43,519 --> 00:14:44,720
response

397
00:14:44,720 --> 00:14:46,560
it's not a very robust mechanism but it

398
00:14:46,560 --> 00:14:47,519
gives us

399
00:14:47,519 --> 00:14:48,560
some

400
00:14:48,560 --> 00:14:50,320
level of integrity

401
00:14:50,320 --> 00:14:53,040
unfortunately we found that this was

402
00:14:53,040 --> 00:14:55,040
misimplemented in the case of nucleus

403
00:14:55,040 --> 00:14:56,240
net

404
00:14:56,240 --> 00:14:57,920
we saw that they were both very very

405
00:14:57,920 --> 00:15:00,240
easy to guess um

406
00:15:00,240 --> 00:15:02,480
we saw very very low entropy

407
00:15:02,480 --> 00:15:05,199
and we saw this vulnerability in a few

408
00:15:05,199 --> 00:15:06,240
other

409
00:15:06,240 --> 00:15:08,079
stacks as well

410
00:15:08,079 --> 00:15:10,240
this type of vulnerability

411
00:15:10,240 --> 00:15:12,320
is not a memory corruption vulnerability

412
00:15:12,320 --> 00:15:13,120
but

413
00:15:13,120 --> 00:15:14,399
it could be combined with other

414
00:15:14,399 --> 00:15:16,079
vulnerabilities to make the other

415
00:15:16,079 --> 00:15:18,959
vulnerabilities easier uh to exploit so

416
00:15:18,959 --> 00:15:20,480
it will allow us

417
00:15:20,480 --> 00:15:22,399
uh to exploit dns client-side

418
00:15:22,399 --> 00:15:24,480
vulnerabilities without being the

419
00:15:24,480 --> 00:15:25,760
legitimate

420
00:15:25,760 --> 00:15:27,839
server making them a power multiplier

421
00:15:27,839 --> 00:15:29,360
making other

422
00:15:29,360 --> 00:15:30,880
vulnerabilities

423
00:15:30,880 --> 00:15:33,120
combined with this vulnerability more

424
00:15:33,120 --> 00:15:35,199
potent

425
00:15:35,199 --> 00:15:38,160
another issue that we found is a lack of

426
00:15:38,160 --> 00:15:39,360
label length

427
00:15:39,360 --> 00:15:41,360
and name length validation so different

428
00:15:41,360 --> 00:15:42,959
type of issues

429
00:15:42,959 --> 00:15:45,680
both with misimplantation of the rfc as

430
00:15:45,680 --> 00:15:47,360
well as

431
00:15:47,360 --> 00:15:49,920
misallocation of buffer sizes so

432
00:15:49,920 --> 00:15:52,240
different memory corruptions that arose

433
00:15:52,240 --> 00:15:56,079
from the very basic functionality of

434
00:15:56,079 --> 00:15:57,600
label lengths and

435
00:15:57,600 --> 00:16:00,160
domain lengths

436
00:16:00,160 --> 00:16:03,120
leading to different memory corruptions

437
00:16:03,120 --> 00:16:04,800
another issue that we found a sort of

438
00:16:04,800 --> 00:16:07,360
more gentle issue is

439
00:16:07,360 --> 00:16:09,920
no validation of the termination

440
00:16:09,920 --> 00:16:12,000
of the domain length which should end

441
00:16:12,000 --> 00:16:14,320
with a null byte representing a zero

442
00:16:14,320 --> 00:16:15,519
length

443
00:16:15,519 --> 00:16:17,199
domain label

444
00:16:17,199 --> 00:16:19,839
in the case of nucleus net this led to

445
00:16:19,839 --> 00:16:20,839
an off by

446
00:16:20,839 --> 00:16:24,639
one readout of bounce

447
00:16:25,680 --> 00:16:27,920
another type of issue we found is in the

448
00:16:27,920 --> 00:16:30,240
parsing of the header of

449
00:16:30,240 --> 00:16:32,079
the dns

450
00:16:32,079 --> 00:16:33,199
response

451
00:16:33,199 --> 00:16:35,199
the header contains

452
00:16:35,199 --> 00:16:37,360
counts for different types of

453
00:16:37,360 --> 00:16:39,040
resource records

454
00:16:39,040 --> 00:16:40,720
and we found that there is not

455
00:16:40,720 --> 00:16:43,680
sufficient validation of the

456
00:16:43,680 --> 00:16:45,680
that the count specified in the header

457
00:16:45,680 --> 00:16:47,839
actually exists in the packet leading to

458
00:16:47,839 --> 00:16:49,680
different types of

459
00:16:49,680 --> 00:16:51,759
mostly read out of bound

460
00:16:51,759 --> 00:16:53,440
vulnerabilities

461
00:16:53,440 --> 00:16:56,560
from this inconsistency and the lack of

462
00:16:56,560 --> 00:16:58,560
validation

463
00:16:58,560 --> 00:17:00,639
and of course the vulnerabilities that

464
00:17:00,639 --> 00:17:02,639
we were looking for dns compression

465
00:17:02,639 --> 00:17:05,919
vulnerabilities so dns compression is a

466
00:17:05,919 --> 00:17:09,520
way to reduce the size of dns packet

467
00:17:09,520 --> 00:17:10,720
responses

468
00:17:10,720 --> 00:17:14,000
the way this is done is it reuses parts

469
00:17:14,000 --> 00:17:15,599
or complete

470
00:17:15,599 --> 00:17:17,679
domain names as parts of other domain

471
00:17:17,679 --> 00:17:18,400
names

472
00:17:18,400 --> 00:17:20,079
so

473
00:17:20,079 --> 00:17:23,400
if for example i want to specify

474
00:17:23,400 --> 00:17:25,119
www.domain.com but i've already

475
00:17:25,119 --> 00:17:26,480
specified

476
00:17:26,480 --> 00:17:28,000
dot com in a different place so i've

477
00:17:28,000 --> 00:17:29,600
already specified domain.com in a

478
00:17:29,600 --> 00:17:31,679
different place i can reference that

479
00:17:31,679 --> 00:17:33,120
previous

480
00:17:33,120 --> 00:17:36,480
domain length domain name and use that

481
00:17:36,480 --> 00:17:38,559
um without

482
00:17:38,559 --> 00:17:40,480
repeating the same

483
00:17:40,480 --> 00:17:44,000
same string again and again

484
00:17:44,000 --> 00:17:46,480
this is used to save space uh and it

485
00:17:46,480 --> 00:17:48,480
turns out it's quite uh tricky to

486
00:17:48,480 --> 00:17:49,440
implement

487
00:17:49,440 --> 00:17:51,360
um the way it's implemented is we have a

488
00:17:51,360 --> 00:17:54,960
special marker um a byte that starts

489
00:17:54,960 --> 00:17:56,400
with uh two

490
00:17:56,400 --> 00:17:57,679
uh

491
00:17:57,679 --> 00:18:01,919
two uh bits that are 1-1 turned on and a

492
00:18:01,919 --> 00:18:03,840
reference to a previous location a

493
00:18:03,840 --> 00:18:05,760
previous domain name

494
00:18:05,760 --> 00:18:08,720
in the packet in the response packet

495
00:18:08,720 --> 00:18:10,720
in order for this to to work the

496
00:18:10,720 --> 00:18:12,960
location must be a previous location it

497
00:18:12,960 --> 00:18:15,600
must be a valid location and

498
00:18:15,600 --> 00:18:17,520
we must make sure that we're not

499
00:18:17,520 --> 00:18:18,880
following the same

500
00:18:18,880 --> 00:18:21,360
reference the same compression pointer

501
00:18:21,360 --> 00:18:23,360
this is the name of the reference

502
00:18:23,360 --> 00:18:24,880
we mustn't follow the same compression

503
00:18:24,880 --> 00:18:27,120
pointer twice we also must make sure

504
00:18:27,120 --> 00:18:28,880
that we're calculating the name of the

505
00:18:28,880 --> 00:18:31,280
decompressed or uncompressed

506
00:18:31,280 --> 00:18:33,600
domain length correctly

507
00:18:33,600 --> 00:18:35,120
if we're going to allocate space for

508
00:18:35,120 --> 00:18:37,760
this and we found issues with all of

509
00:18:37,760 --> 00:18:38,960
these

510
00:18:38,960 --> 00:18:41,200
things that must happen in order for the

511
00:18:41,200 --> 00:18:44,080
implementation to be correct so

512
00:18:44,080 --> 00:18:45,440
in some cases we found that the

513
00:18:45,440 --> 00:18:47,600
compression pointer can bond forward

514
00:18:47,600 --> 00:18:50,240
leading to different types of issues

515
00:18:50,240 --> 00:18:52,160
readout of bounds

516
00:18:52,160 --> 00:18:54,640
miscalculation of the sizes denial of

517
00:18:54,640 --> 00:18:55,679
service

518
00:18:55,679 --> 00:18:57,600
in some cases we saw that the

519
00:18:57,600 --> 00:18:58,880
compression pointer doesn't have to

520
00:18:58,880 --> 00:19:02,799
point to a valid previous domain length

521
00:19:02,799 --> 00:19:04,080
which could lead to the fact that the

522
00:19:04,080 --> 00:19:06,160
domain length would when followed would

523
00:19:06,160 --> 00:19:07,120
actually

524
00:19:07,120 --> 00:19:09,520
reach a point in the packet that is

525
00:19:09,520 --> 00:19:12,080
after the compression pointer

526
00:19:12,080 --> 00:19:14,160
we found that we could nest uh

527
00:19:14,160 --> 00:19:16,160
compression pointers leading to

528
00:19:16,160 --> 00:19:17,840
large sizes

529
00:19:17,840 --> 00:19:19,600
which could in some cases lead to

530
00:19:19,600 --> 00:19:23,520
miscalculation of the uncompressed size

531
00:19:23,520 --> 00:19:25,280
in some cases just

532
00:19:25,280 --> 00:19:27,120
regular miscalculation of the

533
00:19:27,120 --> 00:19:32,000
uncompressed size so we saw that this um

534
00:19:32,000 --> 00:19:34,000
this part of the

535
00:19:34,000 --> 00:19:36,160
of the protocol was difficult to

536
00:19:36,160 --> 00:19:37,360
implement and

537
00:19:37,360 --> 00:19:38,559
resulted in quite a lot of

538
00:19:38,559 --> 00:19:40,160
vulnerabilities in the stacks that we

539
00:19:40,160 --> 00:19:42,080
looked at we later found out that there

540
00:19:42,080 --> 00:19:44,559
are also a lot of vulnerabilities uh

541
00:19:44,559 --> 00:19:46,799
found in in previous years in stacks

542
00:19:46,799 --> 00:19:47,760
that we

543
00:19:47,760 --> 00:19:49,919
did not uh did not look at

544
00:19:49,919 --> 00:19:50,799
some

545
00:19:50,799 --> 00:19:53,039
examples freebsd

546
00:19:53,039 --> 00:19:57,440
vxworks ipnet threadxnetics nucleus

547
00:19:57,440 --> 00:19:59,919
as well as other stacks in the ripple 20

548
00:19:59,919 --> 00:20:02,559
amnesia 33 vulnerabilities that are

549
00:20:02,559 --> 00:20:03,280
of

550
00:20:03,280 --> 00:20:05,440
this class

551
00:20:05,440 --> 00:20:06,960
it's important to mention that

552
00:20:06,960 --> 00:20:09,760
oftentimes when a uh an ip stack has

553
00:20:09,760 --> 00:20:11,679
several different vulnerabilities these

554
00:20:11,679 --> 00:20:13,520
can be combined to create a stronger

555
00:20:13,520 --> 00:20:16,159
exploit or make the exploitation easier

556
00:20:16,159 --> 00:20:19,120
in the example nucleus net

557
00:20:19,120 --> 00:20:20,960
the fact that you can both craft a very

558
00:20:20,960 --> 00:20:23,600
large dns response uh which is not a

559
00:20:23,600 --> 00:20:26,960
vulnerability per se but is um in contra

560
00:20:26,960 --> 00:20:29,280
it is not correct according to the rfc

561
00:20:29,280 --> 00:20:31,600
uh the fact that you can create a memory

562
00:20:31,600 --> 00:20:33,600
corruption and write out of bounds and

563
00:20:33,600 --> 00:20:35,120
the fact that it is easy to guess

564
00:20:35,120 --> 00:20:37,840
transaction id and poor id uh mean that

565
00:20:37,840 --> 00:20:39,039
it is quite

566
00:20:39,039 --> 00:20:41,840
uh it is easier to exploit vulnerable

567
00:20:41,840 --> 00:20:43,919
these three vulnerabilities together

568
00:20:43,919 --> 00:20:46,000
then exploit each of them separately to

569
00:20:46,000 --> 00:20:48,159
receive to to achieve a remote code

570
00:20:48,159 --> 00:20:50,559
execution um and there'll be more

571
00:20:50,559 --> 00:20:51,919
details about this

572
00:20:51,919 --> 00:20:53,760
published

573
00:20:53,760 --> 00:20:55,520
in the new report

574
00:20:55,520 --> 00:20:59,039
i'll now hand the mic over back to

575
00:20:59,039 --> 00:21:00,960
daniel to discuss the impact of these

576
00:21:00,960 --> 00:21:04,559
vulnerabilities in the real world

577
00:21:04,559 --> 00:21:06,240
thanks swami for giving us all the

578
00:21:06,240 --> 00:21:08,240
details on the vulnerabilities that we

579
00:21:08,240 --> 00:21:09,919
found and now let's talk a little bit

580
00:21:09,919 --> 00:21:12,000
about their impact

581
00:21:12,000 --> 00:21:14,159
so first let's discuss

582
00:21:14,159 --> 00:21:16,240
effect devices right what what is

583
00:21:16,240 --> 00:21:17,760
actually vulnerable so we all know that

584
00:21:17,760 --> 00:21:19,440
understanding in fact vendors and

585
00:21:19,440 --> 00:21:22,559
devices um when we are talking about tcp

586
00:21:22,559 --> 00:21:24,480
stack vulnerabilities is very difficult

587
00:21:24,480 --> 00:21:26,159
because this stacks uh so basically

588
00:21:26,159 --> 00:21:28,080
these code bases are reused multiple

589
00:21:28,080 --> 00:21:30,000
times in many ways right we discussed

590
00:21:30,000 --> 00:21:32,080
that at length during ripple 20 and

591
00:21:32,080 --> 00:21:34,480
amnesia 33 for instance

592
00:21:34,480 --> 00:21:37,679
and we know that um it's not easy to to

593
00:21:37,679 --> 00:21:39,840
know which actual devices on a network

594
00:21:39,840 --> 00:21:42,240
or out there in the real world

595
00:21:42,240 --> 00:21:43,679
have the vulnerable versions of these

596
00:21:43,679 --> 00:21:44,640
stacks

597
00:21:44,640 --> 00:21:46,480
uh so here we are not discussing

598
00:21:46,480 --> 00:21:48,320
specific affected vendors or specific

599
00:21:48,320 --> 00:21:50,080
affected device models we just want to

600
00:21:50,080 --> 00:21:53,039
give us an idea of the scale and the

601
00:21:53,039 --> 00:21:55,440
reach of this type of vulnerability

602
00:21:55,440 --> 00:21:57,120
so for instance we know that freebsd

603
00:21:57,120 --> 00:21:59,440
whose dhcp client was found vulnerable

604
00:21:59,440 --> 00:22:01,280
is very popular in of course web and

605
00:22:01,280 --> 00:22:03,360
storage servers but it's also the basis

606
00:22:03,360 --> 00:22:05,360
of several popular appliances and other

607
00:22:05,360 --> 00:22:07,679
software right like open source projects

608
00:22:07,679 --> 00:22:08,400
for

609
00:22:08,400 --> 00:22:10,720
uh firewalls or for network attached

610
00:22:10,720 --> 00:22:12,720
storage

611
00:22:12,720 --> 00:22:14,000
devices

612
00:22:14,000 --> 00:22:15,760
and there are certainly millions of

613
00:22:15,760 --> 00:22:17,200
those out there

614
00:22:17,200 --> 00:22:19,679
we know that the nucleus rtos that runs

615
00:22:19,679 --> 00:22:21,520
nucleus net by default the threat acts

616
00:22:21,520 --> 00:22:23,520
operating system which runs the net x

617
00:22:23,520 --> 00:22:25,360
stack by default and the vx works

618
00:22:25,360 --> 00:22:27,600
operating system that runs ipnet have

619
00:22:27,600 --> 00:22:29,120
been used for decades in critical

620
00:22:29,120 --> 00:22:31,120
systems right and and and below there i

621
00:22:31,120 --> 00:22:32,480
have a few

622
00:22:32,480 --> 00:22:34,960
images a few examples of where those

623
00:22:34,960 --> 00:22:38,400
devices typically are uh deployed so all

624
00:22:38,400 --> 00:22:39,600
together we know that there are more

625
00:22:39,600 --> 00:22:42,060
than 10 billion deployments of those um

626
00:22:42,060 --> 00:22:43,200
[Music]

627
00:22:43,200 --> 00:22:45,200
operating systems or those stacks out

628
00:22:45,200 --> 00:22:46,159
there

629
00:22:46,159 --> 00:22:48,320
uh and we do know that not all os

630
00:22:48,320 --> 00:22:50,400
deployments use the default stack not

631
00:22:50,400 --> 00:22:52,640
all of them have a dns or dhcp client

632
00:22:52,640 --> 00:22:54,720
enable and even not every version of

633
00:22:54,720 --> 00:22:56,159
these

634
00:22:56,159 --> 00:22:57,840
clients are vulnerable but if you think

635
00:22:57,840 --> 00:22:59,440
about this 10 billion deployments that i

636
00:22:59,440 --> 00:23:01,600
mentioned and if you think about 1

637
00:23:01,600 --> 00:23:03,679
of those is already 100 million devices

638
00:23:03,679 --> 00:23:05,280
out there you can have an idea of the

639
00:23:05,280 --> 00:23:08,880
scale of this this type of vulnerability

640
00:23:08,880 --> 00:23:11,520
so again this highlights supply chain

641
00:23:11,520 --> 00:23:13,440
issues that we already discussed in

642
00:23:13,440 --> 00:23:15,280
previous research right this is another

643
00:23:15,280 --> 00:23:16,559
example of an abilities that trickle

644
00:23:16,559 --> 00:23:18,159
down the supply chain and that's why you

645
00:23:18,159 --> 00:23:20,720
have so many affected devices because of

646
00:23:20,720 --> 00:23:23,039
popular components

647
00:23:23,039 --> 00:23:25,520
that are embedded in these devices right

648
00:23:25,520 --> 00:23:28,240
popular software and hardware components

649
00:23:28,240 --> 00:23:30,080
so if we think of two illustrative

650
00:23:30,080 --> 00:23:32,080
issues in this research specifically we

651
00:23:32,080 --> 00:23:34,320
you can think back to the ip nat uh

652
00:23:34,320 --> 00:23:36,880
slash vxworks 6.6

653
00:23:36,880 --> 00:23:38,559
issue that was mentioned by salami

654
00:23:38,559 --> 00:23:40,240
during the vulnerabilities so that was a

655
00:23:40,240 --> 00:23:42,000
vulnerability that was originally found

656
00:23:42,000 --> 00:23:46,080
in 2016 but we found it again this year

657
00:23:46,080 --> 00:23:48,000
and we know that it was silently patched

658
00:23:48,000 --> 00:23:52,080
now it's been issued the cv 2016

659
00:23:52,080 --> 00:23:54,080
uh 2009

660
00:23:54,080 --> 00:23:56,559
uh id but before there was no idea for

661
00:23:56,559 --> 00:23:59,600
it right so we we we couldn't track this

662
00:23:59,600 --> 00:24:01,520
this vulnerability properly and we know

663
00:24:01,520 --> 00:24:03,039
that it has been fixing at least some

664
00:24:03,039 --> 00:24:05,279
devices that that mentioned this

665
00:24:05,279 --> 00:24:06,799
vulnerability specific so they were

666
00:24:06,799 --> 00:24:09,039
notified by by the vendor but we don't

667
00:24:09,039 --> 00:24:10,960
know actually which devices have have

668
00:24:10,960 --> 00:24:14,240
not been uh be patched and this actually

669
00:24:14,240 --> 00:24:16,320
affects a version of vxworks that is

670
00:24:16,320 --> 00:24:18,080
currently unsupported but we know that

671
00:24:18,080 --> 00:24:19,760
there are several examples of currently

672
00:24:19,760 --> 00:24:22,480
supported uh devices of firmware and

673
00:24:22,480 --> 00:24:25,039
currently supported devices that runs at

674
00:24:25,039 --> 00:24:27,600
vxworks even five which is uh 20 years

675
00:24:27,600 --> 00:24:28,960
old right

676
00:24:28,960 --> 00:24:31,360
and we haven't checked where this

677
00:24:31,360 --> 00:24:33,600
vulnerability is still active or not

678
00:24:33,600 --> 00:24:35,120
there could be patches via extended

679
00:24:35,120 --> 00:24:36,640
support for these older versions of

680
00:24:36,640 --> 00:24:40,080
vxworks but you you can have an idea of

681
00:24:40,080 --> 00:24:41,360
um

682
00:24:41,360 --> 00:24:44,000
the the reach and the difficulty in

683
00:24:44,000 --> 00:24:46,000
understanding affected devices uh with

684
00:24:46,000 --> 00:24:49,120
these 30-part third-party components

685
00:24:49,120 --> 00:24:51,600
the second issue that we have is

686
00:24:51,600 --> 00:24:53,600
the nordic sdk that shlami mentioned

687
00:24:53,600 --> 00:24:56,400
that we found the vulnerability and the

688
00:24:56,400 --> 00:24:57,760
vendor mentioned that that was not

689
00:24:57,760 --> 00:24:59,600
production software it was demonstration

690
00:24:59,600 --> 00:25:02,159
code experimental code sorry uh in the

691
00:25:02,159 --> 00:25:04,240
sdk and so on but we know that

692
00:25:04,240 --> 00:25:05,760
developers tend to use this type of

693
00:25:05,760 --> 00:25:08,159
demonstrations or or or experimental

694
00:25:08,159 --> 00:25:11,039
code or so on uh from sdks uh in

695
00:25:11,039 --> 00:25:12,880
production devices right we we have a

696
00:25:12,880 --> 00:25:14,559
couple of examples there of scientific

697
00:25:14,559 --> 00:25:16,240
papers mentioning

698
00:25:16,240 --> 00:25:18,960
how uh example vulnerable example code

699
00:25:18,960 --> 00:25:21,440
turns out in in web applications or in c

700
00:25:21,440 --> 00:25:22,960
plus plus applications and we know that

701
00:25:22,960 --> 00:25:23,679
for

702
00:25:23,679 --> 00:25:25,520
embedded devices the similar issue

703
00:25:25,520 --> 00:25:28,159
happens so again think of the fact that

704
00:25:28,159 --> 00:25:30,240
once verbal code is out there it tends

705
00:25:30,240 --> 00:25:32,720
to spread

706
00:25:32,720 --> 00:25:34,240
and this leads to different types of

707
00:25:34,240 --> 00:25:35,679
impact

708
00:25:35,679 --> 00:25:37,520
uh depending on the devices that

709
00:25:37,520 --> 00:25:39,840
actually employ this um

710
00:25:39,840 --> 00:25:43,120
this code right so if you think of the

711
00:25:43,120 --> 00:25:44,480
both sides of the coin there the

712
00:25:44,480 --> 00:25:46,480
exploitation and the patching part we

713
00:25:46,480 --> 00:25:48,080
know that free of this freebsd for

714
00:25:48,080 --> 00:25:49,919
instance is a modern operating system

715
00:25:49,919 --> 00:25:52,320
that has uh sandboxing has uh

716
00:25:52,320 --> 00:25:54,320
exploit mitigation

717
00:25:54,320 --> 00:25:56,960
and it's typically uh much more

718
00:25:56,960 --> 00:25:59,279
difficult to to to exploit than a

719
00:25:59,279 --> 00:26:01,760
typical uh embedded device

720
00:26:01,760 --> 00:26:02,960
uh

721
00:26:02,960 --> 00:26:05,520
that runs on constrained hardware that

722
00:26:05,520 --> 00:26:07,520
has barely any memory protection which

723
00:26:07,520 --> 00:26:09,200
is basically the case of the other

724
00:26:09,200 --> 00:26:11,120
stacks right so we can see the these

725
00:26:11,120 --> 00:26:13,360
issues spreading from the it to the iot

726
00:26:13,360 --> 00:26:14,400
and ot

727
00:26:14,400 --> 00:26:16,480
environment and the exploitation

728
00:26:16,480 --> 00:26:18,720
advances are definitely different there

729
00:26:18,720 --> 00:26:20,640
but if you think of patching as well we

730
00:26:20,640 --> 00:26:23,360
know that for freebst that often runs in

731
00:26:23,360 --> 00:26:25,039
ig servers that are much easier to

732
00:26:25,039 --> 00:26:26,720
identify on the network to patch

733
00:26:26,720 --> 00:26:29,679
centrally if you have ssh manage the

734
00:26:29,679 --> 00:26:31,360
servers or devices you have high

735
00:26:31,360 --> 00:26:33,279
availability for instance where one can

736
00:26:33,279 --> 00:26:35,200
be taken offline and the other instance

737
00:26:35,200 --> 00:26:37,279
will take over which

738
00:26:37,279 --> 00:26:40,080
is just not the case in in iot and ot

739
00:26:40,080 --> 00:26:41,679
devices right so

740
00:26:41,679 --> 00:26:43,279
there's other stacks they tend to run on

741
00:26:43,279 --> 00:26:45,360
very specific firmware mission critical

742
00:26:45,360 --> 00:26:47,440
devices that cannot be taken offline you

743
00:26:47,440 --> 00:26:49,279
have to wait for patches to trickle down

744
00:26:49,279 --> 00:26:51,200
the supply chain from from the stack

745
00:26:51,200 --> 00:26:53,120
maintainer to possibly an operating

746
00:26:53,120 --> 00:26:55,679
system vendor to in the end uh the

747
00:26:55,679 --> 00:26:59,039
actual device vendor um and that takes

748
00:26:59,039 --> 00:27:02,000
time and takes a lot of effort

749
00:27:02,000 --> 00:27:04,799
uh so if we discuss the mitigation uh

750
00:27:04,799 --> 00:27:06,400
differences that we that we started

751
00:27:06,400 --> 00:27:08,320
looking at and how we can move forward

752
00:27:08,320 --> 00:27:10,880
in terms of mitigating these issues uh

753
00:27:10,880 --> 00:27:13,200
from both the developer point of view

754
00:27:13,200 --> 00:27:15,440
and the network operating operator point

755
00:27:15,440 --> 00:27:16,559
of view

756
00:27:16,559 --> 00:27:18,320
we want to highlight for

757
00:27:18,320 --> 00:27:19,760
um

758
00:27:19,760 --> 00:27:21,279
for instance is there of how we can

759
00:27:21,279 --> 00:27:23,600
mitigate these issues in the future

760
00:27:23,600 --> 00:27:25,200
so we we want to discuss better

761
00:27:25,200 --> 00:27:27,120
documentation and static analysis for

762
00:27:27,120 --> 00:27:29,039
developers and device fingerprinting and

763
00:27:29,039 --> 00:27:30,399
intrusion detection for network

764
00:27:30,399 --> 00:27:32,240
operators

765
00:27:32,240 --> 00:27:35,200
so on the side of the developers um we

766
00:27:35,200 --> 00:27:36,799
really wanted to highlight the issue of

767
00:27:36,799 --> 00:27:38,640
better documentation because we know

768
00:27:38,640 --> 00:27:40,080
that specification and security

769
00:27:40,080 --> 00:27:42,000
information is scratched scattered

770
00:27:42,000 --> 00:27:44,320
across rfcs and that's not j not just

771
00:27:44,320 --> 00:27:47,200
for dns but for several uh internet

772
00:27:47,200 --> 00:27:48,399
protocols right

773
00:27:48,399 --> 00:27:50,480
and unfortunately we have seen again in

774
00:27:50,480 --> 00:27:52,080
previous research and we have confirmed

775
00:27:52,080 --> 00:27:53,679
in this research that

776
00:27:53,679 --> 00:27:56,880
these rfcs are often complex ambiguous

777
00:27:56,880 --> 00:27:59,440
or sometimes outdated um

778
00:27:59,440 --> 00:28:01,760
there is this leads to drastic security

779
00:28:01,760 --> 00:28:04,559
effects right so if we look at two

780
00:28:04,559 --> 00:28:06,799
instances of rfcs that are related to

781
00:28:06,799 --> 00:28:08,480
dns phrases you see that there's this

782
00:28:08,480 --> 00:28:11,120
dns prox implementation guidelines that

783
00:28:11,120 --> 00:28:14,000
mentions um some

784
00:28:14,000 --> 00:28:15,279
issues with

785
00:28:15,279 --> 00:28:17,520
dns compression and compression pointers

786
00:28:17,520 --> 00:28:19,039
and valid compression pointers that may

787
00:28:19,039 --> 00:28:21,360
be dropped um but they don't don't

788
00:28:21,360 --> 00:28:23,279
mention all of the issues that that we

789
00:28:23,279 --> 00:28:25,360
found uh they also mentioned the other

790
00:28:25,360 --> 00:28:28,320
empty pattern about incorrect counts and

791
00:28:28,320 --> 00:28:29,120
they

792
00:28:29,120 --> 00:28:30,960
these issues are mentioned in rfc that

793
00:28:30,960 --> 00:28:34,320
is not the dns specification rfc itself

794
00:28:34,320 --> 00:28:37,520
right so it may be that uh uh um a

795
00:28:37,520 --> 00:28:40,240
developer implementing the the the dns

796
00:28:40,240 --> 00:28:42,480
client will just not find this this

797
00:28:42,480 --> 00:28:44,399
exact specification

798
00:28:44,399 --> 00:28:45,440
and also

799
00:28:45,440 --> 00:28:46,399
uh

800
00:28:46,399 --> 00:28:48,240
this uh specification mentions that

801
00:28:48,240 --> 00:28:50,080
these packets may be dropped but doesn't

802
00:28:50,080 --> 00:28:52,480
alert you the security issues that these

803
00:28:52,480 --> 00:28:55,760
uh packets bring and that they probably

804
00:28:55,760 --> 00:28:57,679
must be dropped right not not just that

805
00:28:57,679 --> 00:29:00,399
they may be dropped in some cases but

806
00:29:00,399 --> 00:29:02,240
they really should be dropped to avoid

807
00:29:02,240 --> 00:29:04,240
security issues

808
00:29:04,240 --> 00:29:06,640
on the other hand uh the second example

809
00:29:06,640 --> 00:29:09,200
there is is a is an rfc that actually

810
00:29:09,200 --> 00:29:11,840
never uh made it past the draft stage it

811
00:29:11,840 --> 00:29:13,840
was about a new compression scheme for

812
00:29:13,840 --> 00:29:17,440
for dns but uh yeah didn't get approved

813
00:29:17,440 --> 00:29:19,760
and there is a section on security

814
00:29:19,760 --> 00:29:21,840
considerations that talks about blindly

815
00:29:21,840 --> 00:29:23,760
following compression pointers and how

816
00:29:23,760 --> 00:29:26,159
dangerous that is and so on but again

817
00:29:26,159 --> 00:29:27,600
this is something that didn't really

818
00:29:27,600 --> 00:29:31,520
become a standard right and this uh

819
00:29:31,520 --> 00:29:33,120
is

820
00:29:33,120 --> 00:29:35,520
a problem because again it it the

821
00:29:35,520 --> 00:29:37,440
information is scattered and it's not

822
00:29:37,440 --> 00:29:39,440
really um

823
00:29:39,440 --> 00:29:41,520
not really centralized to where to find

824
00:29:41,520 --> 00:29:43,919
it so we actually took it to ourselves

825
00:29:43,919 --> 00:29:46,399
to write an information rfc draft about

826
00:29:46,399 --> 00:29:48,320
these identified identity patterns and

827
00:29:48,320 --> 00:29:51,200
and how to avoid them for uh for for

828
00:29:51,200 --> 00:29:53,679
future developments we submitted that to

829
00:29:53,679 --> 00:29:56,480
the ietf and we are making it available

830
00:29:56,480 --> 00:29:59,120
on our github as well

831
00:29:59,120 --> 00:30:00,720
in terms of static analysis we know the

832
00:30:00,720 --> 00:30:02,640
developers need tools to readily spot

833
00:30:02,640 --> 00:30:04,960
potential bugs so we created some code

834
00:30:04,960 --> 00:30:06,799
to identify these entry patterns and

835
00:30:06,799 --> 00:30:08,480
specifically the dns compression entry

836
00:30:08,480 --> 00:30:09,919
pattern

837
00:30:09,919 --> 00:30:12,159
using yarn which is an open source

838
00:30:12,159 --> 00:30:13,840
framework

839
00:30:13,840 --> 00:30:16,640
for code querying for uh cnc plus plus

840
00:30:16,640 --> 00:30:19,440
implementations so we developed a plugin

841
00:30:19,440 --> 00:30:21,200
on top of this

842
00:30:21,200 --> 00:30:22,960
on this framework and it can be

843
00:30:22,960 --> 00:30:25,600
downloaded on our uh github

844
00:30:25,600 --> 00:30:27,279
webpage that is displayed there on the

845
00:30:27,279 --> 00:30:29,840
on the slides and uh those screenshots

846
00:30:29,840 --> 00:30:31,840
show a little bit of how the query works

847
00:30:31,840 --> 00:30:34,159
uh and and what is the output of a

848
00:30:34,159 --> 00:30:35,520
potentially

849
00:30:35,520 --> 00:30:38,240
vulnerable piece of code in a tcpap

850
00:30:38,240 --> 00:30:40,240
stack

851
00:30:40,240 --> 00:30:41,840
in terms of device fingerprinting as

852
00:30:41,840 --> 00:30:43,679
well we know that embedded stacks

853
00:30:43,679 --> 00:30:45,440
typically have implementation quirks

854
00:30:45,440 --> 00:30:47,520
that are often useful for stack

855
00:30:47,520 --> 00:30:49,440
fingerprinting right more specifically

856
00:30:49,440 --> 00:30:51,440
icmp replies for instance and tcp

857
00:30:51,440 --> 00:30:53,679
options as well they are prime examples

858
00:30:53,679 --> 00:30:56,000
of how things are implemented sometimes

859
00:30:56,000 --> 00:30:57,679
not um

860
00:30:57,679 --> 00:31:00,399
according to to two rfcs or in

861
00:31:00,399 --> 00:31:02,000
slightly different ways in the case of

862
00:31:02,000 --> 00:31:04,640
tcp options and that can be used for

863
00:31:04,640 --> 00:31:06,559
precise and accurate fingerprinting of

864
00:31:06,559 --> 00:31:08,720
stacks and most importantly this

865
00:31:08,720 --> 00:31:10,320
accurate fingerprinting is really what

866
00:31:10,320 --> 00:31:12,240
enables other mitigation such as a

867
00:31:12,240 --> 00:31:13,919
patching rate you can only patch

868
00:31:13,919 --> 00:31:15,360
something that you know is vulnerable

869
00:31:15,360 --> 00:31:17,600
and segmentation uh in terms of

870
00:31:17,600 --> 00:31:20,480
isolating devices in your network so we

871
00:31:20,480 --> 00:31:22,320
have updated our project memorial

872
00:31:22,320 --> 00:31:24,320
detector which is an open source tool to

873
00:31:24,320 --> 00:31:26,640
detect uh tcpap stacks running on a

874
00:31:26,640 --> 00:31:29,679
device with information that is specific

875
00:31:29,679 --> 00:31:30,799
to

876
00:31:30,799 --> 00:31:33,039
to the stacks that are on a part of this

877
00:31:33,039 --> 00:31:35,360
research and we will continue to to to

878
00:31:35,360 --> 00:31:37,679
maintain these two with stacks not just

879
00:31:37,679 --> 00:31:39,279
that are vulnerable within product

880
00:31:39,279 --> 00:31:41,360
project memorial but also other stacks

881
00:31:41,360 --> 00:31:43,440
that we we have knowledge about

882
00:31:43,440 --> 00:31:44,720
um

883
00:31:44,720 --> 00:31:46,880
if we talk about intrusion detection and

884
00:31:46,880 --> 00:31:49,600
exploit detection rules we know that we

885
00:31:49,600 --> 00:31:51,679
can basically turn the entry patterns we

886
00:31:51,679 --> 00:31:53,440
found on the vulnerability examples into

887
00:31:53,440 --> 00:31:57,120
rules for um dropping packets right or

888
00:31:57,120 --> 00:31:59,039
at least alerting to their presence if

889
00:31:59,039 --> 00:32:01,120
you're running on a

890
00:32:01,120 --> 00:32:03,120
highly critical environment such as

891
00:32:03,120 --> 00:32:04,640
operational technology and industrial

892
00:32:04,640 --> 00:32:06,720
control systems or medical devices where

893
00:32:06,720 --> 00:32:09,600
dropping packets might be uh problematic

894
00:32:09,600 --> 00:32:12,080
so if we look at the the main entry

895
00:32:12,080 --> 00:32:13,840
patterns that we identified so invalid

896
00:32:13,840 --> 00:32:16,080
domain name labels uh invalid domain

897
00:32:16,080 --> 00:32:18,000
names um

898
00:32:18,000 --> 00:32:19,919
and resource date lands invalid

899
00:32:19,919 --> 00:32:21,919
compression pointers and record counts

900
00:32:21,919 --> 00:32:24,159
basically all of those can become rules

901
00:32:24,159 --> 00:32:26,000
for intrusion detection systems right

902
00:32:26,000 --> 00:32:27,600
and i'm not going to read all of the

903
00:32:27,600 --> 00:32:29,440
specific rules there but this is a

904
00:32:29,440 --> 00:32:31,519
pretty comprehensive list of rules that

905
00:32:31,519 --> 00:32:33,279
if implemented on intrusion detection

906
00:32:33,279 --> 00:32:35,600
system allows you to not just detect

907
00:32:35,600 --> 00:32:37,039
exploitation of the vulnerabilities that

908
00:32:37,039 --> 00:32:39,519
we did find but also others and many

909
00:32:39,519 --> 00:32:41,279
others that might appear in the future

910
00:32:41,279 --> 00:32:43,120
because they follow the same empty

911
00:32:43,120 --> 00:32:45,600
patterns

912
00:32:45,679 --> 00:32:47,519
and also for intrusion detection we are

913
00:32:47,519 --> 00:32:48,960
making available

914
00:32:48,960 --> 00:32:51,679
uh a set of escape piece scripts and and

915
00:32:51,679 --> 00:32:54,000
pcaps with malicious packets

916
00:32:54,000 --> 00:32:54,960
that

917
00:32:54,960 --> 00:32:57,919
allow you to test that uh intrusion

918
00:32:57,919 --> 00:32:59,600
detection rules are actually capturing

919
00:32:59,600 --> 00:33:02,080
the the proper packets this is available

920
00:33:02,080 --> 00:33:03,840
under requests it's not uh publicly

921
00:33:03,840 --> 00:33:05,600
available on github but we can share it

922
00:33:05,600 --> 00:33:07,840
with whoever is interested

923
00:33:07,840 --> 00:33:11,440
so moving on to the conclusion right um

924
00:33:11,440 --> 00:33:13,279
we know that rfc miss implementation is

925
00:33:13,279 --> 00:33:15,200
a common cause of vulnerabilities in tcp

926
00:33:15,200 --> 00:33:16,240
stacks

927
00:33:16,240 --> 00:33:18,080
because they are often complex ambiguous

928
00:33:18,080 --> 00:33:20,720
outdated and this leads to the fact that

929
00:33:20,720 --> 00:33:23,120
dns clients have several vulnerabilities

930
00:33:23,120 --> 00:33:25,760
so message compression stands out it's a

931
00:33:25,760 --> 00:33:28,159
very common uh anti-pattern and it often

932
00:33:28,159 --> 00:33:30,799
leads to rc and and we we really uh

933
00:33:30,799 --> 00:33:32,880
showed with this research that

934
00:33:32,880 --> 00:33:34,960
it's it's out there in tcpap stacks but

935
00:33:34,960 --> 00:33:36,880
we do expect it to be out there in many

936
00:33:36,880 --> 00:33:38,640
other products as well

937
00:33:38,640 --> 00:33:40,399
not implementing support for compression

938
00:33:40,399 --> 00:33:41,760
on the other hand seems to be an

939
00:33:41,760 --> 00:33:43,840
effective mitigation against this type

940
00:33:43,840 --> 00:33:45,519
of an ability of course you're limiting

941
00:33:45,519 --> 00:33:47,840
functionality but

942
00:33:47,840 --> 00:33:49,279
there is an interesting discussion there

943
00:33:49,279 --> 00:33:50,720
that if the bandwidth saving that

944
00:33:50,720 --> 00:33:53,120
associated to compression is is

945
00:33:53,120 --> 00:33:54,960
basically almost meaningless nowadays

946
00:33:54,960 --> 00:33:56,399
for several devices that have fast

947
00:33:56,399 --> 00:33:57,760
connectivity

948
00:33:57,760 --> 00:34:00,960
um this type of feature might just

949
00:34:00,960 --> 00:34:02,799
introduce more problems than it solves

950
00:34:02,799 --> 00:34:04,480
right so you as a developer might think

951
00:34:04,480 --> 00:34:07,360
of just not enabling it

952
00:34:07,360 --> 00:34:10,079
um and dns clients they seem to be

953
00:34:10,079 --> 00:34:12,079
tested less rigorously than service for

954
00:34:12,079 --> 00:34:14,239
security we mentioned several uh

955
00:34:14,239 --> 00:34:16,000
variabilities on servers that we found

956
00:34:16,000 --> 00:34:17,440
at the beginning of the

957
00:34:17,440 --> 00:34:19,199
or that that were found by other people

958
00:34:19,199 --> 00:34:20,639
but we listed at the beginning of this

959
00:34:20,639 --> 00:34:22,719
of this research but it seems that

960
00:34:22,719 --> 00:34:25,679
client um clients uh are are less

961
00:34:25,679 --> 00:34:27,520
rigorously tested because they

962
00:34:27,520 --> 00:34:29,199
communicated with a limited set of

963
00:34:29,199 --> 00:34:30,719
servers they may be prone to

964
00:34:30,719 --> 00:34:32,480
vulnerabilities being detected later in

965
00:34:32,480 --> 00:34:34,960
their development stage uh

966
00:34:34,960 --> 00:34:37,440
just because they they they follow a

967
00:34:37,440 --> 00:34:38,800
different model than the service right

968
00:34:38,800 --> 00:34:41,280
they talk to usually trusted servers

969
00:34:41,280 --> 00:34:44,239
rather than untrusted clients um

970
00:34:44,239 --> 00:34:46,480
not only for the tcpap stacks these

971
00:34:46,480 --> 00:34:49,119
issues uh turned up into vulnerabilities

972
00:34:49,119 --> 00:34:50,879
but every dns implementation out there

973
00:34:50,879 --> 00:34:52,639
should be tested right so we're talking

974
00:34:52,639 --> 00:34:55,119
firewalls ideas packet detectors

975
00:34:55,119 --> 00:34:57,119
forwarders and basically any sort of

976
00:34:57,119 --> 00:34:58,560
software that

977
00:34:58,560 --> 00:35:00,839
that parses dns

978
00:35:00,839 --> 00:35:02,560
packets

979
00:35:02,560 --> 00:35:04,880
if we talk about key takeaways of this

980
00:35:04,880 --> 00:35:07,359
research dns complexity leads to

981
00:35:07,359 --> 00:35:08,640
critical vulnerabilities not just the

982
00:35:08,640 --> 00:35:10,480
complexity of our rfcs but the end the

983
00:35:10,480 --> 00:35:12,640
protocol itself right 50 of what we

984
00:35:12,640 --> 00:35:14,320
analyzed is vulnerable to this specific

985
00:35:14,320 --> 00:35:16,720
compression and pattern that means that

986
00:35:16,720 --> 00:35:18,079
other implementations are probably

987
00:35:18,079 --> 00:35:20,480
vulnerable as i just mentioned

988
00:35:20,480 --> 00:35:22,480
the fact that we looked at tcpap stacks

989
00:35:22,480 --> 00:35:24,079
amplifies really the problem because

990
00:35:24,079 --> 00:35:25,680
this vulnerable code was millions of

991
00:35:25,680 --> 00:35:28,560
devices but other types of products

992
00:35:28,560 --> 00:35:30,960
might as well uh be vulnerable and and

993
00:35:30,960 --> 00:35:33,119
be vulnerable at a large scale but there

994
00:35:33,119 --> 00:35:35,200
are several steps uh to mitigate this

995
00:35:35,200 --> 00:35:36,800
problem right we are releasing with this

996
00:35:36,800 --> 00:35:38,079
research this report about

997
00:35:38,079 --> 00:35:39,520
vulnerabilities and anti-patterns the

998
00:35:39,520 --> 00:35:41,920
draft information rfc the open source

999
00:35:41,920 --> 00:35:44,000
static analysis queries the open source

1000
00:35:44,000 --> 00:35:45,280
fingerprinting of stacks and the

1001
00:35:45,280 --> 00:35:47,359
malicious speak apps they can all be

1002
00:35:47,359 --> 00:35:49,040
obtained

1003
00:35:49,040 --> 00:35:51,599
either on github or website or directly

1004
00:35:51,599 --> 00:35:54,240
by contacting us and we hope that this

1005
00:35:54,240 --> 00:35:56,640
means that we can mitigate dns based

1006
00:35:56,640 --> 00:35:58,800
vulnerabilities and eradicate in the

1007
00:35:58,800 --> 00:36:00,000
future

1008
00:36:00,000 --> 00:36:01,520
so thank you very much that's what i had

1009
00:36:01,520 --> 00:36:03,839
to present today uh we're open for

1010
00:36:03,839 --> 00:36:06,560
questions but please if you would like

1011
00:36:06,560 --> 00:36:08,720
to know more about this other research

1012
00:36:08,720 --> 00:36:10,800
that we're doing as well contact us or

1013
00:36:10,800 --> 00:36:12,880
follow us on social media and we'll be

1014
00:36:12,880 --> 00:36:17,560
glad to connect thank you very much

