1
00:00:01,130 --> 00:00:13,678
[Music]

2
00:00:13,679 --> 00:00:15,280
welcome everyone to our presentation

3
00:00:15,280 --> 00:00:17,520
today called enter sandbox before we

4
00:00:17,520 --> 00:00:18,560
start with the content of our

5
00:00:18,560 --> 00:00:20,320
presentation let us briefly introduce

6
00:00:20,320 --> 00:00:22,720
ourselves my name is claudio canella i'm

7
00:00:22,720 --> 00:00:24,720
a phd candidate at guards university of

8
00:00:24,720 --> 00:00:26,880
technology if you ever want to reach out

9
00:00:26,880 --> 00:00:29,039
to me ask some questions

10
00:00:29,039 --> 00:00:30,960
feel free to do so on twitter or simply

11
00:00:30,960 --> 00:00:33,120
send me an email hi so

12
00:00:33,120 --> 00:00:35,840
my name is matthew weiner i'm a

13
00:00:35,840 --> 00:00:37,920
i was a phd at carter university of

14
00:00:37,920 --> 00:00:39,600
technology as well when conducting this

15
00:00:39,600 --> 00:00:41,920
research and now i'm a hardware design

16
00:00:41,920 --> 00:00:44,320
engineer at nxp semiconductors so if you

17
00:00:44,320 --> 00:00:46,000
want to reach me have a look at my

18
00:00:46,000 --> 00:00:47,200
homepage and you find the contact

19
00:00:47,200 --> 00:00:49,840
information there

20
00:00:50,559 --> 00:00:52,960
hi my name is michael schwarz i'm a

21
00:00:52,960 --> 00:00:55,039
faculty at cisco helmholtz center for

22
00:00:55,039 --> 00:00:56,879
information security

23
00:00:56,879 --> 00:00:58,559
also if you have some questions feel

24
00:00:58,559 --> 00:01:00,719
free to always reach out to me on

25
00:01:00,719 --> 00:01:04,239
twitter via mail or ask questions after

26
00:01:04,239 --> 00:01:06,240
our talk

27
00:01:06,240 --> 00:01:09,200
so what is this talk about

28
00:01:09,200 --> 00:01:11,040
we already know that memory safety

29
00:01:11,040 --> 00:01:14,159
vulnerabilities they are quite common so

30
00:01:14,159 --> 00:01:16,640
everything is quite buggy we have

31
00:01:16,640 --> 00:01:19,360
vulnerabilities everywhere

32
00:01:19,360 --> 00:01:21,360
and there's this nice technique of

33
00:01:21,360 --> 00:01:24,400
sandboxing that helps in limiting the

34
00:01:24,400 --> 00:01:26,640
impact of vulnerabilities that's

35
00:01:26,640 --> 00:01:29,119
something that we really

36
00:01:29,119 --> 00:01:31,520
want to use in all these applications

37
00:01:31,520 --> 00:01:33,840
that could have bugs and are a target

38
00:01:33,840 --> 00:01:36,240
for exploitation like browsers for

39
00:01:36,240 --> 00:01:38,079
example

40
00:01:38,079 --> 00:01:40,400
and if we are on linux there's already a

41
00:01:40,400 --> 00:01:44,240
nice technique the segcomp filters

42
00:01:44,240 --> 00:01:45,680
and they allow us

43
00:01:45,680 --> 00:01:48,000
to sandbox an application so that they

44
00:01:48,000 --> 00:01:52,240
only have limited access to system codes

45
00:01:52,240 --> 00:01:53,200
but

46
00:01:53,200 --> 00:01:55,600
this is still something we'd have to do

47
00:01:55,600 --> 00:01:56,719
manually

48
00:01:56,719 --> 00:02:00,159
so the question is can we automate that

49
00:02:00,159 --> 00:02:02,399
can we get sandboxing in more

50
00:02:02,399 --> 00:02:05,840
applications than we have right now

51
00:02:05,840 --> 00:02:09,038
a few months ago

52
00:02:09,038 --> 00:02:10,318
so i was

53
00:02:10,318 --> 00:02:11,360
coding

54
00:02:11,360 --> 00:02:13,440
a little application i needed a small

55
00:02:13,440 --> 00:02:16,720
application to copy some files around

56
00:02:16,720 --> 00:02:19,120
and i wrote that in my favorite language

57
00:02:19,120 --> 00:02:21,120
in c

58
00:02:21,120 --> 00:02:23,680
of course i know if i write applications

59
00:02:23,680 --> 00:02:26,560
in memory unsafe languages like c

60
00:02:26,560 --> 00:02:27,840
it's easy

61
00:02:27,840 --> 00:02:30,640
to make some mistakes to introduce bugs

62
00:02:30,640 --> 00:02:33,760
maybe even exploitable bugs

63
00:02:33,760 --> 00:02:36,319
and that this is quite common we can see

64
00:02:36,319 --> 00:02:38,800
that here for example

65
00:02:38,800 --> 00:02:40,000
in this plot

66
00:02:40,000 --> 00:02:43,200
so i looked at all these cves

67
00:02:43,200 --> 00:02:46,640
regarding memory safety vulnerabilities

68
00:02:46,640 --> 00:02:48,720
things that were exploited in native

69
00:02:48,720 --> 00:02:50,400
applications

70
00:02:50,400 --> 00:02:51,920
and we see

71
00:02:51,920 --> 00:02:54,400
we have quite a lot of them and these

72
00:02:54,400 --> 00:02:57,599
are only the known ones that received an

73
00:02:57,599 --> 00:02:59,040
identifier

74
00:02:59,040 --> 00:03:01,440
i don't want to make this graph any

75
00:03:01,440 --> 00:03:02,720
steeper

76
00:03:02,720 --> 00:03:05,519
so i'd like to not have any

77
00:03:05,519 --> 00:03:08,319
vulnerabilities in my code

78
00:03:08,319 --> 00:03:09,120
so

79
00:03:09,120 --> 00:03:11,280
your application sounds to be perfect

80
00:03:11,280 --> 00:03:14,000
for seccomp so let me briefly introduce

81
00:03:14,000 --> 00:03:16,560
what seccomp is with seccomp we have

82
00:03:16,560 --> 00:03:18,159
this application like for instance in

83
00:03:18,159 --> 00:03:20,560
your case your application for copying

84
00:03:20,560 --> 00:03:23,200
files and typically it just wants to

85
00:03:23,200 --> 00:03:24,959
perform some system calls to perform its

86
00:03:24,959 --> 00:03:26,480
task so

87
00:03:26,480 --> 00:03:28,720
you identify the system calls that your

88
00:03:28,720 --> 00:03:29,920
application

89
00:03:29,920 --> 00:03:32,799
does or does need and it installs the

90
00:03:32,799 --> 00:03:36,080
filters in the kernel so it just says if

91
00:03:36,080 --> 00:03:38,080
you get an open system call please allow

92
00:03:38,080 --> 00:03:38,879
it

93
00:03:38,879 --> 00:03:41,280
so we get the system call then after the

94
00:03:41,280 --> 00:03:42,959
filters have been installed the

95
00:03:42,959 --> 00:03:44,480
application performs for instance this

96
00:03:44,480 --> 00:03:47,920
open system call the operating system

97
00:03:47,920 --> 00:03:49,760
the linux kernel checks within the

98
00:03:49,760 --> 00:03:52,560
filters if the system call is allowed if

99
00:03:52,560 --> 00:03:54,159
it is not it is simply going to

100
00:03:54,159 --> 00:03:56,400
terminate your application

101
00:03:56,400 --> 00:03:58,000
because it might have been exploited in

102
00:03:58,000 --> 00:04:01,439
some way or form and if it's allowed

103
00:04:01,439 --> 00:04:02,159
then

104
00:04:02,159 --> 00:04:04,319
simply if we allowed or the system call

105
00:04:04,319 --> 00:04:08,239
is executed and we return

106
00:04:08,239 --> 00:04:12,080
that indeed sounds fascinating

107
00:04:12,080 --> 00:04:15,519
so from the basic idea i get it

108
00:04:15,519 --> 00:04:16,639
but

109
00:04:16,639 --> 00:04:18,720
i just seriously audio so i looked at

110
00:04:18,720 --> 00:04:21,120
that so he explained it so nicely and i

111
00:04:21,120 --> 00:04:23,360
felt like that's a plug-in solution i

112
00:04:23,360 --> 00:04:26,720
just put it into my application

113
00:04:26,720 --> 00:04:28,479
but then i found some tutorials and it

114
00:04:28,479 --> 00:04:30,560
looks like that

115
00:04:30,560 --> 00:04:32,080
so that looks

116
00:04:32,080 --> 00:04:35,120
nothing like c code or anything i know

117
00:04:35,120 --> 00:04:37,199
that looks more like some

118
00:04:37,199 --> 00:04:39,440
type of pseudo assembly stitched

119
00:04:39,440 --> 00:04:43,360
together using c macros and it's

120
00:04:43,360 --> 00:04:45,120
horrible to read

121
00:04:45,120 --> 00:04:48,400
and even worse to write that so

122
00:04:48,400 --> 00:04:50,479
i don't know so it sounds cool

123
00:04:50,479 --> 00:04:51,280
but

124
00:04:51,280 --> 00:04:53,199
i have no idea how i should come up with

125
00:04:53,199 --> 00:04:55,280
things like that i mean it might work

126
00:04:55,280 --> 00:04:57,360
for a simple hello world application

127
00:04:57,360 --> 00:04:59,199
but for anything larger

128
00:04:59,199 --> 00:05:00,560
i don't know

129
00:05:00,560 --> 00:05:02,880
well yes that's because that you use the

130
00:05:02,880 --> 00:05:05,759
bpf filters directly the filters are

131
00:05:05,759 --> 00:05:07,840
expressed in this language called ppf

132
00:05:07,840 --> 00:05:10,160
and it's really complicated but why not

133
00:05:10,160 --> 00:05:13,120
just use lipsec comp it's more or less

134
00:05:13,120 --> 00:05:14,960
an rb it does everything for you in the

135
00:05:14,960 --> 00:05:17,120
background and it's really nice you have

136
00:05:17,120 --> 00:05:19,120
these functions you can just create a

137
00:05:19,120 --> 00:05:21,840
context you call second rule add with

138
00:05:21,840 --> 00:05:23,600
the number of the system call or name of

139
00:05:23,600 --> 00:05:26,320
the system call that you want to perform

140
00:05:26,320 --> 00:05:28,720
and it's done so why not just use that

141
00:05:28,720 --> 00:05:31,680
it's a lot more easier

142
00:05:31,759 --> 00:05:34,160
okay that indeed sounds a bit more

143
00:05:34,160 --> 00:05:35,759
practical so

144
00:05:35,759 --> 00:05:39,360
i looked that up i looked at lipsec comp

145
00:05:39,360 --> 00:05:40,479
and

146
00:05:40,479 --> 00:05:41,440
yes

147
00:05:41,440 --> 00:05:43,680
you are kind of right

148
00:05:43,680 --> 00:05:46,000
so it definitely looks easier than what

149
00:05:46,000 --> 00:05:48,960
i tried to do before that's now actual c

150
00:05:48,960 --> 00:05:51,360
code with some functions

151
00:05:51,360 --> 00:05:54,080
but still it doesn't look very nice and

152
00:05:54,080 --> 00:05:56,479
it looks super complicated and i had to

153
00:05:56,479 --> 00:05:58,960
look up many things in there so we have

154
00:05:58,960 --> 00:06:02,000
something like the rt secret dern or

155
00:06:02,000 --> 00:06:03,440
exit group

156
00:06:03,440 --> 00:06:04,960
open ad like

157
00:06:04,960 --> 00:06:08,080
why did i need all of that i mean

158
00:06:08,080 --> 00:06:10,160
i don't really know but if i didn't add

159
00:06:10,160 --> 00:06:12,560
that it crashed so

160
00:06:12,560 --> 00:06:15,360
it must be necessary

161
00:06:15,360 --> 00:06:16,240
and

162
00:06:16,240 --> 00:06:18,000
after a bit of research i figured out

163
00:06:18,000 --> 00:06:20,240
like these are the syscalls that are

164
00:06:20,240 --> 00:06:22,880
internally used by the code by the c

165
00:06:22,880 --> 00:06:23,840
code

166
00:06:23,840 --> 00:06:26,720
and i have to figure out which syscalls

167
00:06:26,720 --> 00:06:28,479
my application uses

168
00:06:28,479 --> 00:06:29,360
but

169
00:06:29,360 --> 00:06:31,360
how would i know that as a simple

170
00:06:31,360 --> 00:06:32,560
developer

171
00:06:32,560 --> 00:06:34,880
so i have cc functions

172
00:06:34,880 --> 00:06:37,360
how can i map them to the syscalls that

173
00:06:37,360 --> 00:06:39,280
they actually use

174
00:06:39,280 --> 00:06:40,400
and

175
00:06:40,400 --> 00:06:43,120
i would have to do that for the entire

176
00:06:43,120 --> 00:06:44,560
code base

177
00:06:44,560 --> 00:06:47,600
so again for hello world that's fine

178
00:06:47,600 --> 00:06:49,680
but if i have a large application with

179
00:06:49,680 --> 00:06:52,800
thousands of lines of codes and multiple

180
00:06:52,800 --> 00:06:54,080
files

181
00:06:54,080 --> 00:06:55,919
doing that for all the c functions

182
00:06:55,919 --> 00:06:59,280
checking which cisco they use

183
00:06:59,280 --> 00:07:02,319
does that really sound feasible to you i

184
00:07:02,319 --> 00:07:04,960
know it doesn't to me

185
00:07:04,960 --> 00:07:06,080
and then again

186
00:07:06,080 --> 00:07:08,000
typically i use some third party

187
00:07:08,000 --> 00:07:11,120
libraries and have a lot of code again

188
00:07:11,120 --> 00:07:12,160
so

189
00:07:12,160 --> 00:07:14,400
i would also have to do that for all the

190
00:07:14,400 --> 00:07:18,479
third party libraries really

191
00:07:18,560 --> 00:07:20,319
you're right we need to do something

192
00:07:20,319 --> 00:07:22,560
about it so maybe we can come up with a

193
00:07:22,560 --> 00:07:24,479
solution for that

194
00:07:24,479 --> 00:07:27,520
months of research and engineering later

195
00:07:27,520 --> 00:07:29,520
we came up with this solution that we

196
00:07:29,520 --> 00:07:32,000
call chestnut and chestnut is more or

197
00:07:32,000 --> 00:07:34,319
less a two-phase approach so in the

198
00:07:34,319 --> 00:07:36,639
first phase we have this we call it p1

199
00:07:36,639 --> 00:07:39,039
we have the static analysis and it's

200
00:07:39,039 --> 00:07:41,360
more as what you said we have to we take

201
00:07:41,360 --> 00:07:43,440
the source code of an application we use

202
00:07:43,440 --> 00:07:45,919
our tool that we call source alizer

203
00:07:45,919 --> 00:07:48,160
it performs some analysis and at the end

204
00:07:48,160 --> 00:07:50,080
it tells us what are the system calls

205
00:07:50,080 --> 00:07:52,000
that it's the application is going to

206
00:07:52,000 --> 00:07:53,120
execute

207
00:07:53,120 --> 00:07:55,360
and in the other case maybe we just want

208
00:07:55,360 --> 00:07:57,120
to we don't have the source code

209
00:07:57,120 --> 00:07:59,759
available and we only have the binaries

210
00:07:59,759 --> 00:08:02,160
so we also have a solution for that

211
00:08:02,160 --> 00:08:05,120
we use our binary we use our tool called

212
00:08:05,120 --> 00:08:08,080
binalyzer and we again get this

213
00:08:08,080 --> 00:08:10,400
these annotated files

214
00:08:10,400 --> 00:08:11,680
but

215
00:08:11,680 --> 00:08:13,919
this might not work entirely because

216
00:08:13,919 --> 00:08:16,080
static analysis does have its problems

217
00:08:16,080 --> 00:08:18,479
so we have this optional second phase

218
00:08:18,479 --> 00:08:21,039
called the dynamic refinement phase

219
00:08:21,039 --> 00:08:23,840
where we have a third part of our tool

220
00:08:23,840 --> 00:08:25,440
called finalizer

221
00:08:25,440 --> 00:08:29,120
and with this dynamic analyzer

222
00:08:29,120 --> 00:08:31,360
we can simply do some runtime

223
00:08:31,360 --> 00:08:33,760
tracing of system calls and we can

224
00:08:33,760 --> 00:08:36,719
refine the system calls that we find

225
00:08:36,719 --> 00:08:39,279
and we get again these annotated binary

226
00:08:39,279 --> 00:08:41,440
files that we can then use another tool

227
00:08:41,440 --> 00:08:43,519
called either chestnut patcher to

228
00:08:43,519 --> 00:08:45,839
generate a sandbox binary or chestnut

229
00:08:45,839 --> 00:08:47,040
generator

230
00:08:47,040 --> 00:08:49,760
that generates us a wrapped binary

231
00:08:49,760 --> 00:08:52,080
but that's a lot of information for just

232
00:08:52,080 --> 00:08:53,680
this one slide so

233
00:08:53,680 --> 00:08:54,560
maybe

234
00:08:54,560 --> 00:08:56,560
let's take a look a closer look at all

235
00:08:56,560 --> 00:08:58,800
of these components individually

236
00:08:58,800 --> 00:09:01,200
let's start with the first part uh

237
00:09:01,200 --> 00:09:03,920
source eliza as i said we have these

238
00:09:03,920 --> 00:09:05,839
source files like for instance you're

239
00:09:05,839 --> 00:09:07,680
copying files

240
00:09:07,680 --> 00:09:09,200
code

241
00:09:09,200 --> 00:09:10,800
we simply pass it

242
00:09:10,800 --> 00:09:13,600
through our extended compiler we extract

243
00:09:13,600 --> 00:09:15,680
the system call number there

244
00:09:15,680 --> 00:09:17,519
then we need to build up some call graph

245
00:09:17,519 --> 00:09:19,040
we need to know which function calls

246
00:09:19,040 --> 00:09:21,200
which so that we can extract the correct

247
00:09:21,200 --> 00:09:23,680
system cause in the final binary

248
00:09:23,680 --> 00:09:25,040
after this

249
00:09:25,040 --> 00:09:27,200
we take the the object file that we have

250
00:09:27,200 --> 00:09:29,519
we annotate it with the call graph that

251
00:09:29,519 --> 00:09:31,120
we found and the system calls that we

252
00:09:31,120 --> 00:09:32,720
found within this

253
00:09:32,720 --> 00:09:34,320
this single file

254
00:09:34,320 --> 00:09:36,640
then we combine it in the linker with

255
00:09:36,640 --> 00:09:39,519
the additional libraries that we have

256
00:09:39,519 --> 00:09:42,000
and we flatten this call graph we get

257
00:09:42,000 --> 00:09:44,000
the system call numbers out there for

258
00:09:44,000 --> 00:09:47,600
the whole binary that we actually need

259
00:09:47,600 --> 00:09:49,519
and we generate this annotated

260
00:09:49,519 --> 00:09:52,000
executable and once we run it we're

261
00:09:52,000 --> 00:09:54,000
simply going to install the filters

262
00:09:54,000 --> 00:09:56,240
sounds nice right you just need

263
00:09:56,240 --> 00:09:58,160
to use our extended compiler that we

264
00:09:58,160 --> 00:10:00,240
provide and your application is

265
00:10:00,240 --> 00:10:02,160
sandboxed do you even know how

266
00:10:02,160 --> 00:10:04,480
challenging it is in practice i mean

267
00:10:04,480 --> 00:10:06,480
you make it sound really simple

268
00:10:06,480 --> 00:10:07,920
no i don't know

269
00:10:07,920 --> 00:10:10,640
okay so um let me show you how this all

270
00:10:10,640 --> 00:10:11,920
works

271
00:10:11,920 --> 00:10:14,160
with the help of one example so we take

272
00:10:14,160 --> 00:10:15,839
the most important program in computer

273
00:10:15,839 --> 00:10:16,720
science

274
00:10:16,720 --> 00:10:18,959
everyone knows it hello world

275
00:10:18,959 --> 00:10:21,839
and the challenge or that we have that

276
00:10:21,839 --> 00:10:24,160
we want what we want to achieve is we

277
00:10:24,160 --> 00:10:26,720
want to sandbox this application

278
00:10:26,720 --> 00:10:27,920
and

279
00:10:27,920 --> 00:10:30,000
you nicely explained we put it into the

280
00:10:30,000 --> 00:10:31,279
compiler

281
00:10:31,279 --> 00:10:34,000
and he does all the work and we're done

282
00:10:34,000 --> 00:10:36,560
but if we really try and try it and look

283
00:10:36,560 --> 00:10:38,880
at what the compiler actually sees it's

284
00:10:38,880 --> 00:10:40,880
not that simple because when you compile

285
00:10:40,880 --> 00:10:42,640
this program everything the compiler

286
00:10:42,640 --> 00:10:45,519
sees is a call to a function called put

287
00:10:45,519 --> 00:10:47,279
string

288
00:10:47,279 --> 00:10:48,880
the compiler has no idea what this

289
00:10:48,880 --> 00:10:51,120
function is where it has been defined

290
00:10:51,120 --> 00:10:53,200
what it does internally and he doesn't

291
00:10:53,200 --> 00:10:54,160
care

292
00:10:54,160 --> 00:10:56,000
he only looks at one translation unit at

293
00:10:56,000 --> 00:10:57,279
a time

294
00:10:57,279 --> 00:10:59,120
so we can manually look up this

295
00:10:59,120 --> 00:11:01,120
bootstring function we find it in our c

296
00:11:01,120 --> 00:11:02,720
library implementation looks something

297
00:11:02,720 --> 00:11:04,959
like that

298
00:11:04,959 --> 00:11:07,120
yeah on the first glance it's still

299
00:11:07,120 --> 00:11:09,519
really complicated we have we see some

300
00:11:09,519 --> 00:11:12,560
function calls some macros there

301
00:11:12,560 --> 00:11:14,320
yeah and when we can let the compiler do

302
00:11:14,320 --> 00:11:17,440
its work we see internally put string

303
00:11:17,440 --> 00:11:19,279
calls for other functions

304
00:11:19,279 --> 00:11:21,200
but again nobody knows what these

305
00:11:21,200 --> 00:11:22,959
functions are to

306
00:11:22,959 --> 00:11:26,320
and yeah the compiler doesn't care

307
00:11:26,320 --> 00:11:28,959
so one thing which we do in our tool in

308
00:11:28,959 --> 00:11:31,440
sourcalizer is that we extract all this

309
00:11:31,440 --> 00:11:33,519
local information each translation unit

310
00:11:33,519 --> 00:11:36,320
only knows about the code it contains

311
00:11:36,320 --> 00:11:38,800
and uh what other functions it calls and

312
00:11:38,800 --> 00:11:40,800
what we do here is we serialize this

313
00:11:40,800 --> 00:11:42,880
information in this case we simply pick

314
00:11:42,880 --> 00:11:43,920
json

315
00:11:43,920 --> 00:11:45,760
and we embed this

316
00:11:45,760 --> 00:11:48,079
json into a node in the resulting object

317
00:11:48,079 --> 00:11:50,639
file so we can use elf

318
00:11:50,639 --> 00:11:52,959
elf nodes there and just add arbitrary

319
00:11:52,959 --> 00:11:54,720
information

320
00:11:54,720 --> 00:11:57,760
in the second step the linker which

321
00:11:57,760 --> 00:11:59,360
has the task of combining all these

322
00:11:59,360 --> 00:12:00,720
object files

323
00:12:00,720 --> 00:12:02,720
loads also this new node edit node

324
00:12:02,720 --> 00:12:03,680
sections

325
00:12:03,680 --> 00:12:05,130
and uses this

326
00:12:05,130 --> 00:12:06,399
[Music]

327
00:12:06,399 --> 00:12:09,120
information fragments to recombine all

328
00:12:09,120 --> 00:12:11,600
this information and construct a

329
00:12:11,600 --> 00:12:14,079
constitutional a counterflow graph or in

330
00:12:14,079 --> 00:12:16,560
this case a call graph

331
00:12:16,560 --> 00:12:18,560
so when you look at the slides here we

332
00:12:18,560 --> 00:12:21,279
see main calls put string put string

333
00:12:21,279 --> 00:12:23,600
calls for other functions the one which

334
00:12:23,600 --> 00:12:26,800
is important is f put string

335
00:12:26,800 --> 00:12:28,880
if we follow this path further we find

336
00:12:28,880 --> 00:12:32,160
that this internally calls f write

337
00:12:32,160 --> 00:12:33,920
and f write again calls a few other

338
00:12:33,920 --> 00:12:36,240
functions but we still have no idea

339
00:12:36,240 --> 00:12:38,000
where the actual syscalls are we haven't

340
00:12:38,000 --> 00:12:39,440
seen them here

341
00:12:39,440 --> 00:12:42,560
the challenge is that f rat doesn't do a

342
00:12:42,560 --> 00:12:44,320
direct call to the

343
00:12:44,320 --> 00:12:46,240
next functions but an indirect function

344
00:12:46,240 --> 00:12:48,639
call and again

345
00:12:48,639 --> 00:12:51,600
we cannot be sure which functions there

346
00:12:51,600 --> 00:12:53,040
are called there

347
00:12:53,040 --> 00:12:55,440
and what we do here is

348
00:12:55,440 --> 00:12:57,519
we utilize again the compiler the

349
00:12:57,519 --> 00:12:59,600
compiler knows which

350
00:12:59,600 --> 00:13:01,279
signatures

351
00:13:01,279 --> 00:13:03,920
are called so what arguments the

352
00:13:03,920 --> 00:13:06,560
function get and what type they have

353
00:13:06,560 --> 00:13:08,720
and uh by collecting all the information

354
00:13:08,720 --> 00:13:10,160
which we have again

355
00:13:10,160 --> 00:13:11,839
we find that

356
00:13:11,839 --> 00:13:13,680
he has to call in this case standard

357
00:13:13,680 --> 00:13:15,760
outright and in standard outright we

358
00:13:15,760 --> 00:13:18,160
really have the cisco so calling cisco

359
00:13:18,160 --> 00:13:19,279
16

360
00:13:19,279 --> 00:13:22,399
for an io control and syscall 20 in the

361
00:13:22,399 --> 00:13:25,760
standard ao write is the write operation

362
00:13:25,760 --> 00:13:27,200
all which is left then is to back

363
00:13:27,200 --> 00:13:29,440
propagate this information up the call

364
00:13:29,440 --> 00:13:31,519
graph and then we know what this is

365
00:13:31,519 --> 00:13:33,680
called main users

366
00:13:33,680 --> 00:13:36,800
so to summarize the key aspects that

367
00:13:36,800 --> 00:13:39,360
socializer uses are

368
00:13:39,360 --> 00:13:40,320
that

369
00:13:40,320 --> 00:13:42,320
we use each tool

370
00:13:42,320 --> 00:13:44,000
for what it's best at we use the

371
00:13:44,000 --> 00:13:46,240
compiler for extracting information

372
00:13:46,240 --> 00:13:48,160
he has access to like the syscalls and

373
00:13:48,160 --> 00:13:50,959
function names and signatures

374
00:13:50,959 --> 00:13:52,880
we emit all this stuff into the object

375
00:13:52,880 --> 00:13:54,800
file and then recombine it in the call

376
00:13:54,800 --> 00:13:57,600
graph into a call graph as part of the

377
00:13:57,600 --> 00:13:59,519
linker additionally we use link time

378
00:13:59,519 --> 00:14:01,600
garbage collection to reduce the number

379
00:14:01,600 --> 00:14:02,800
of reachable

380
00:14:02,800 --> 00:14:03,920
functions

381
00:14:03,920 --> 00:14:06,160
which helps with this indirect function

382
00:14:06,160 --> 00:14:08,320
call handling and

383
00:14:08,320 --> 00:14:10,240
the function called signature heuristic

384
00:14:10,240 --> 00:14:12,800
which i mentioned before to figure out

385
00:14:12,800 --> 00:14:15,360
which functions are called indirectly

386
00:14:15,360 --> 00:14:17,360
and the result of that is that no time

387
00:14:17,360 --> 00:14:19,199
consuming whole program analysis is

388
00:14:19,199 --> 00:14:21,040
needed so we can

389
00:14:21,040 --> 00:14:22,240
do this all

390
00:14:22,240 --> 00:14:24,079
much faster than our previous related

391
00:14:24,079 --> 00:14:24,959
work

392
00:14:24,959 --> 00:14:26,800
i think that's a very interesting idea

393
00:14:26,800 --> 00:14:28,240
but the question that pretty much

394
00:14:28,240 --> 00:14:30,320
everyone is asking themselves is does

395
00:14:30,320 --> 00:14:32,480
this really work or is it just working

396
00:14:32,480 --> 00:14:34,000
for like a small example like hello

397
00:14:34,000 --> 00:14:36,959
world uh yeah so i was expecting that of

398
00:14:36,959 --> 00:14:38,959
course you are always um

399
00:14:38,959 --> 00:14:42,160
quite skeptical with this stuff so yeah

400
00:14:42,160 --> 00:14:45,040
we tried that of course and as an

401
00:14:45,040 --> 00:14:47,680
example we also tried it on ffmpeg so

402
00:14:47,680 --> 00:14:49,839
you have all this video encoding stuff

403
00:14:49,839 --> 00:14:52,800
in there you have parsers

404
00:14:52,800 --> 00:14:54,880
a lot of potential uh

405
00:14:54,880 --> 00:14:56,720
vulnerable spaces where vulnerabilities

406
00:14:56,720 --> 00:14:59,360
would be bad and we compiled it with our

407
00:14:59,360 --> 00:15:01,600
source analyzer tool and got the sandbox

408
00:15:01,600 --> 00:15:03,040
binary

409
00:15:03,040 --> 00:15:04,720
we have a quick video here which shows

410
00:15:04,720 --> 00:15:06,880
when we start this application

411
00:15:06,880 --> 00:15:08,639
first we look at what this calls were

412
00:15:08,639 --> 00:15:11,760
found in this case 63 cisco's very

413
00:15:11,760 --> 00:15:13,680
extracted

414
00:15:13,680 --> 00:15:15,440
and when we start the application with a

415
00:15:15,440 --> 00:15:18,399
debug flag we again print

416
00:15:18,399 --> 00:15:21,360
what syscalls have been found which we

417
00:15:21,360 --> 00:15:22,959
are used for setting up the second

418
00:15:22,959 --> 00:15:23,920
filters

419
00:15:23,920 --> 00:15:25,760
and yeah the application simply runs

420
00:15:25,760 --> 00:15:29,199
that's really nice resize so i have to

421
00:15:29,199 --> 00:15:30,800
say i use that

422
00:15:30,800 --> 00:15:33,600
on my simple application and it still

423
00:15:33,600 --> 00:15:36,240
works flawlessly so it seems it

424
00:15:36,240 --> 00:15:39,279
perfectly sandboxed that but i'm still

425
00:15:39,279 --> 00:15:41,440
not fully satisfied

426
00:15:41,440 --> 00:15:42,959
so i have this

427
00:15:42,959 --> 00:15:45,600
old software lying around here

428
00:15:45,600 --> 00:15:48,560
that looks a bit shady i'm not sure how

429
00:15:48,560 --> 00:15:50,079
secure it is

430
00:15:50,079 --> 00:15:53,360
maybe it even has backdoors or something

431
00:15:53,360 --> 00:15:54,399
and

432
00:15:54,399 --> 00:15:56,480
i can't really tell because i don't have

433
00:15:56,480 --> 00:15:58,399
the source code i only have this binary

434
00:15:58,399 --> 00:16:01,920
here i would like to also sandbox that

435
00:16:01,920 --> 00:16:04,880
to make it a bit more secure at least at

436
00:16:04,880 --> 00:16:05,680
least

437
00:16:05,680 --> 00:16:06,959
so

438
00:16:06,959 --> 00:16:08,959
i can't do that with your compiler right

439
00:16:08,959 --> 00:16:10,720
it requires source code as every

440
00:16:10,720 --> 00:16:12,880
compiler so what do you do if i only

441
00:16:12,880 --> 00:16:15,199
have a binary well you obviously did not

442
00:16:15,199 --> 00:16:16,800
pay attention to what i said in the

443
00:16:16,800 --> 00:16:18,560
beginning we also have this binary

444
00:16:18,560 --> 00:16:20,160
analysis tool that allows you to do

445
00:16:20,160 --> 00:16:22,560
exactly what you want here so

446
00:16:22,560 --> 00:16:24,480
we have the spinalizer it extracts the

447
00:16:24,480 --> 00:16:26,480
system calls from existing binaries or

448
00:16:26,480 --> 00:16:27,680
libraries

449
00:16:27,680 --> 00:16:30,959
and for that it simply uses the capstone

450
00:16:30,959 --> 00:16:32,880
framework so it disassembles the binary

451
00:16:32,880 --> 00:16:34,320
so that we get all the assembly

452
00:16:34,320 --> 00:16:37,199
instructions and users so we can find

453
00:16:37,199 --> 00:16:38,639
the system calls

454
00:16:38,639 --> 00:16:41,040
there and then we use the anchor tool to

455
00:16:41,040 --> 00:16:42,959
build a call graph again and extract the

456
00:16:42,959 --> 00:16:44,720
system calls that are actually needed

457
00:16:44,720 --> 00:16:47,440
for the for the binary but claudio how

458
00:16:47,440 --> 00:16:49,199
does this work in detail i mean is

459
00:16:49,199 --> 00:16:52,160
called finding them sounds complicated

460
00:16:52,160 --> 00:16:54,320
it is a little bit complicated so let me

461
00:16:54,320 --> 00:16:56,160
briefly walk you through this so what we

462
00:16:56,160 --> 00:16:58,560
do is we rely on symbolic backwards

463
00:16:58,560 --> 00:17:00,639
execution we look through the

464
00:17:00,639 --> 00:17:02,959
disassembly binary until we find the

465
00:17:02,959 --> 00:17:05,679
system call instruction and duplica

466
00:17:05,679 --> 00:17:09,119
typically the system call is executed is

467
00:17:09,119 --> 00:17:12,319
in the rax register of

468
00:17:12,319 --> 00:17:15,679
of the cpu so you move at one point the

469
00:17:15,679 --> 00:17:18,240
request number into that register

470
00:17:18,240 --> 00:17:20,319
perform the systemcalling structure and

471
00:17:20,319 --> 00:17:22,000
the operat and the system handles the

472
00:17:22,000 --> 00:17:23,359
rest for you

473
00:17:23,359 --> 00:17:24,240
but

474
00:17:24,240 --> 00:17:26,480
we need to find this so we you we look

475
00:17:26,480 --> 00:17:28,559
for the system calling structure and

476
00:17:28,559 --> 00:17:30,559
when we find it in this case we simply

477
00:17:30,559 --> 00:17:32,720
don't know yet what is the value of our

478
00:17:32,720 --> 00:17:35,039
x so we keep the value symbolic and we

479
00:17:35,039 --> 00:17:37,200
move back up a couple instructions

480
00:17:37,200 --> 00:17:38,880
because at one point we are going to

481
00:17:38,880 --> 00:17:41,280
find this move in structure

482
00:17:41,280 --> 00:17:43,360
but in the first two lines that we look

483
00:17:43,360 --> 00:17:45,360
at we don't really find it but at one

484
00:17:45,360 --> 00:17:47,760
point we see that we have this moth ebx

485
00:17:47,760 --> 00:17:49,840
to eax register

486
00:17:49,840 --> 00:17:51,120
well that simply

487
00:17:51,120 --> 00:17:52,799
that still does not tell us what is the

488
00:17:52,799 --> 00:17:54,640
actual syscall that is executed because

489
00:17:54,640 --> 00:17:57,520
suddenly eax is ebx so we need to keep

490
00:17:57,520 --> 00:17:59,520
the value further symbolic but we now

491
00:17:59,520 --> 00:18:02,640
know that rex is equal to rbx which we

492
00:18:02,640 --> 00:18:05,120
don't know the value yet so we continue

493
00:18:05,120 --> 00:18:07,039
our search we don't learn anything else

494
00:18:07,039 --> 00:18:09,520
in the next line but at one point we'll

495
00:18:09,520 --> 00:18:11,280
see that the

496
00:18:11,280 --> 00:18:13,120
uh we see a muff instruction where the

497
00:18:13,120 --> 00:18:16,480
value 1 is moved into the bl register so

498
00:18:16,480 --> 00:18:18,640
the lower part of the

499
00:18:18,640 --> 00:18:20,720
ebx register

500
00:18:20,720 --> 00:18:23,360
so at this point we can now infer that

501
00:18:23,360 --> 00:18:26,320
rax is equals to rbx which is equals to

502
00:18:26,320 --> 00:18:28,160
1. so we know that the syst call that is

503
00:18:28,160 --> 00:18:32,240
being executed is this call number one

504
00:18:32,240 --> 00:18:33,200
and

505
00:18:33,200 --> 00:18:35,280
so help me out there do i have to do

506
00:18:35,280 --> 00:18:38,000
that manually no the system so our tool

507
00:18:38,000 --> 00:18:40,160
does all of that automatically for you

508
00:18:40,160 --> 00:18:43,280
you just give it as an input the

509
00:18:43,280 --> 00:18:45,760
uh your binary we pass the binary so

510
00:18:45,760 --> 00:18:47,919
that we find all uh the dynamic

511
00:18:47,919 --> 00:18:49,679
dependencies of it

512
00:18:49,679 --> 00:18:52,240
and it finds the system calls we built

513
00:18:52,240 --> 00:18:54,240
the call graph with anger

514
00:18:54,240 --> 00:18:55,280
and

515
00:18:55,280 --> 00:18:57,120
using this tool we can then

516
00:18:57,120 --> 00:18:58,799
get the system call mapping where we

517
00:18:58,799 --> 00:19:01,600
know for instance that the puts function

518
00:19:01,600 --> 00:19:03,120
needs right v

519
00:19:03,120 --> 00:19:05,520
um the default function is going to need

520
00:19:05,520 --> 00:19:08,320
right v sysclone and cisfutex system

521
00:19:08,320 --> 00:19:09,760
calls so all of that is done

522
00:19:09,760 --> 00:19:12,000
automatically for you

523
00:19:12,000 --> 00:19:12,880
and

524
00:19:12,880 --> 00:19:15,120
we can also show you again using a video

525
00:19:15,120 --> 00:19:16,880
how this is done for this we use the

526
00:19:16,880 --> 00:19:19,280
application radius and

527
00:19:19,280 --> 00:19:21,440
we applied our binary analysis tool to

528
00:19:21,440 --> 00:19:23,520
it and executed the test

529
00:19:23,520 --> 00:19:26,240
suite of the application and as you can

530
00:19:26,240 --> 00:19:27,280
see

531
00:19:27,280 --> 00:19:29,520
not a single one of these

532
00:19:29,520 --> 00:19:31,520
test cases fails so

533
00:19:31,520 --> 00:19:33,600
it seems like we find all the necessary

534
00:19:33,600 --> 00:19:37,600
system calls for our application

535
00:19:37,600 --> 00:19:39,679
i trusted you with that so i applied

536
00:19:39,679 --> 00:19:41,120
that to my

537
00:19:41,120 --> 00:19:42,720
legacy application that i only have a

538
00:19:42,720 --> 00:19:43,919
binary

539
00:19:43,919 --> 00:19:45,360
and

540
00:19:45,360 --> 00:19:47,039
surprisingly

541
00:19:47,039 --> 00:19:48,240
that happened

542
00:19:48,240 --> 00:19:49,200
it just

543
00:19:49,200 --> 00:19:51,520
crashed it stopped working so it doesn't

544
00:19:51,520 --> 00:19:52,960
work your

545
00:19:52,960 --> 00:19:54,799
vinylizer thingy

546
00:19:54,799 --> 00:19:56,559
destroyed the application so it's now

547
00:19:56,559 --> 00:19:58,000
completely broken

548
00:19:58,000 --> 00:19:59,520
so

549
00:19:59,520 --> 00:20:02,240
why what is happening here you explained

550
00:20:02,240 --> 00:20:04,720
it so nicely it made sense but

551
00:20:04,720 --> 00:20:06,960
apparently it doesn't work yeah

552
00:20:06,960 --> 00:20:08,960
michael i think you've found a corner

553
00:20:08,960 --> 00:20:11,440
case there which we simply cannot handle

554
00:20:11,440 --> 00:20:13,760
so i mean

555
00:20:13,760 --> 00:20:16,320
seconds second filter if you you

556
00:20:16,320 --> 00:20:18,320
configure them statically

557
00:20:18,320 --> 00:20:20,400
it's not possible to relax them anymore

558
00:20:20,400 --> 00:20:23,760
i mean that's a nice property for

559
00:20:23,760 --> 00:20:28,000
uh for having uh for ensuring that a pr

560
00:20:28,000 --> 00:20:29,360
application doesn't gain additional

561
00:20:29,360 --> 00:20:32,080
privileges but in this case um it's

562
00:20:32,080 --> 00:20:34,700
really not not ideal

563
00:20:34,700 --> 00:20:35,919
[Applause]

564
00:20:35,919 --> 00:20:38,400
so what we actually have to do here is

565
00:20:38,400 --> 00:20:40,960
we need another approach i mean second

566
00:20:40,960 --> 00:20:43,280
itself is nice if you know the static

567
00:20:43,280 --> 00:20:44,640
set

568
00:20:44,640 --> 00:20:46,880
but we need additional capabilities in

569
00:20:46,880 --> 00:20:49,120
particular something like uh

570
00:20:49,120 --> 00:20:51,360
like this like an s trace approach where

571
00:20:51,360 --> 00:20:54,320
we see all the syscalls and can decide

572
00:20:54,320 --> 00:20:56,159
during runtime if this belongs to the

573
00:20:56,159 --> 00:20:57,520
application

574
00:20:57,520 --> 00:20:59,039
or if it

575
00:20:59,039 --> 00:21:01,200
is a malicious syscall that we do not

576
00:21:01,200 --> 00:21:03,840
expect

577
00:21:04,640 --> 00:21:06,720
we have a tool for that it's called

578
00:21:06,720 --> 00:21:08,320
finalizer

579
00:21:08,320 --> 00:21:12,640
and what finalizer does is it basically

580
00:21:12,640 --> 00:21:14,880
implements this estrace approach so we

581
00:21:14,880 --> 00:21:18,159
have we have a tracy uh which is the

582
00:21:18,159 --> 00:21:20,400
application which we want to protect and

583
00:21:20,400 --> 00:21:22,400
we spawn a second process the tracer

584
00:21:22,400 --> 00:21:25,039
which monitors the syscalls of our

585
00:21:25,039 --> 00:21:26,860
target application

586
00:21:26,860 --> 00:21:28,480
[Applause]

587
00:21:28,480 --> 00:21:30,720
what now happens when the application

588
00:21:30,720 --> 00:21:32,240
makes a syscall

589
00:21:32,240 --> 00:21:34,080
the kernel automatically delegates this

590
00:21:34,080 --> 00:21:36,159
decision if the syscall is okay or not

591
00:21:36,159 --> 00:21:38,880
to our tracing application

592
00:21:38,880 --> 00:21:42,240
here we can lock the syscall we can

593
00:21:42,240 --> 00:21:44,320
theoretically decide if it's okay to do

594
00:21:44,320 --> 00:21:46,960
it or not or simply uh

595
00:21:46,960 --> 00:21:49,360
take notes and lock that the cisco took

596
00:21:49,360 --> 00:21:51,760
place and use that information for

597
00:21:51,760 --> 00:21:54,159
further refinement later on

598
00:21:54,159 --> 00:21:55,760
afterwards we

599
00:21:55,760 --> 00:21:58,240
the tracer that

600
00:21:58,240 --> 00:21:59,679
compo

601
00:21:59,679 --> 00:22:02,000
the monitoring component uh returns to

602
00:22:02,000 --> 00:22:04,559
the kernel and says okay the application

603
00:22:04,559 --> 00:22:06,320
is allowed to do the syscall and then

604
00:22:06,320 --> 00:22:10,480
the kernel performs the actual operation

605
00:22:11,520 --> 00:22:14,400
um so when we look how where we

606
00:22:14,400 --> 00:22:17,440
implemented that we basically designed a

607
00:22:17,440 --> 00:22:19,760
new small utility library look called a

608
00:22:19,760 --> 00:22:21,200
lib chestnut

609
00:22:21,200 --> 00:22:22,000
this

610
00:22:22,000 --> 00:22:23,120
library

611
00:22:23,120 --> 00:22:24,400
is

612
00:22:24,400 --> 00:22:26,559
in charge of setting up second filters

613
00:22:26,559 --> 00:22:28,960
on application start and it also

614
00:22:28,960 --> 00:22:30,720
implements this finalizer approach which

615
00:22:30,720 --> 00:22:34,000
i discussed on the previous slide

616
00:22:34,480 --> 00:22:37,120
the way it works is it registers a

617
00:22:37,120 --> 00:22:39,679
constructor basically as

618
00:22:39,679 --> 00:22:41,520
i've constructed a function like like in

619
00:22:41,520 --> 00:22:43,919
c in a c plus plus program

620
00:22:43,919 --> 00:22:46,240
but in this case in a c program

621
00:22:46,240 --> 00:22:48,480
which is automatically called on program

622
00:22:48,480 --> 00:22:50,799
startup and in this constructor we set

623
00:22:50,799 --> 00:22:53,360
up the sync up filters

624
00:22:53,360 --> 00:22:55,760
additionally source socializer which we

625
00:22:55,760 --> 00:22:57,919
introduced before uh automatically links

626
00:22:57,919 --> 00:22:59,760
to this library so all you have to do

627
00:22:59,760 --> 00:23:02,480
there is to use the uh

628
00:23:02,480 --> 00:23:04,400
the sandboxing flag and of the compiler

629
00:23:04,400 --> 00:23:06,080
and you get the completely protected

630
00:23:06,080 --> 00:23:08,799
binary at the end

631
00:23:08,799 --> 00:23:10,720
so the question here is then what about

632
00:23:10,720 --> 00:23:13,440
binalyzer in binalyzer we cannot simply

633
00:23:13,440 --> 00:23:15,760
link against it right so

634
00:23:15,760 --> 00:23:18,080
when we think back to the overview that

635
00:23:18,080 --> 00:23:20,240
i gave earlier we had these two other

636
00:23:20,240 --> 00:23:22,080
tools there chestnut patcher and

637
00:23:22,080 --> 00:23:24,720
chestnut generator so they can be used

638
00:23:24,720 --> 00:23:25,919
for this

639
00:23:25,919 --> 00:23:28,400
so chestnut patcher more or less

640
00:23:28,400 --> 00:23:30,000
uses the information that is provided

641
00:23:30,000 --> 00:23:31,520
the number of system calls that are

642
00:23:31,520 --> 00:23:33,039
being executed or that need to be

643
00:23:33,039 --> 00:23:35,840
allowed and directly patches the binary

644
00:23:35,840 --> 00:23:39,039
includes them in a node section and also

645
00:23:39,039 --> 00:23:41,679
links against a lipsec comp and lip

646
00:23:41,679 --> 00:23:44,640
chestnut so more or less you then have

647
00:23:44,640 --> 00:23:46,880
the same thing as you have with a

648
00:23:46,880 --> 00:23:48,480
socializer

649
00:23:48,480 --> 00:23:49,840
the other approach would be to use

650
00:23:49,840 --> 00:23:53,200
chestnut generator so instead of

651
00:23:53,200 --> 00:23:55,120
patching the binary

652
00:23:55,120 --> 00:23:57,600
we create like a wrapper program that

653
00:23:57,600 --> 00:23:59,919
launches that sets up all the filters

654
00:23:59,919 --> 00:24:02,960
using lipsec comp and our lip chestnut

655
00:24:02,960 --> 00:24:07,360
and then launches the binary

656
00:24:07,840 --> 00:24:12,480
okay yeah so that's pretty nice

657
00:24:12,640 --> 00:24:13,360
so

658
00:24:13,360 --> 00:24:15,520
i can apply that to all my applications

659
00:24:15,520 --> 00:24:18,880
now right yes

660
00:24:18,880 --> 00:24:22,480
okay and yes this time it really works

661
00:24:22,480 --> 00:24:23,440
so

662
00:24:23,440 --> 00:24:25,279
i have to admit i'm a bit surprised by

663
00:24:25,279 --> 00:24:29,120
that but it actually works

664
00:24:29,120 --> 00:24:31,440
but i mean still you do a lot of stuff

665
00:24:31,440 --> 00:24:33,600
you figure out syscalls

666
00:24:33,600 --> 00:24:36,000
uh you have to do static analysis some

667
00:24:36,000 --> 00:24:40,640
dynamic analysis symbolic execution

668
00:24:40,720 --> 00:24:42,080
that's a lot

669
00:24:42,080 --> 00:24:44,159
also adding all these filters

670
00:24:44,159 --> 00:24:45,039
so

671
00:24:45,039 --> 00:24:48,000
isn't it going to be super slow

672
00:24:48,000 --> 00:24:50,159
well we obviously

673
00:24:50,159 --> 00:24:52,480
put some thought into that and performed

674
00:24:52,480 --> 00:24:54,640
some evaluation of all this so we looked

675
00:24:54,640 --> 00:24:56,480
at the performance of our tools in

676
00:24:56,480 --> 00:24:58,159
extracting the system call information

677
00:24:58,159 --> 00:24:59,520
that we need

678
00:24:59,520 --> 00:25:01,039
we also evaluated the functional

679
00:25:01,039 --> 00:25:03,200
correctness so our tools actually still

680
00:25:03,200 --> 00:25:05,520
able to do what they want or what they

681
00:25:05,520 --> 00:25:06,720
need to do

682
00:25:06,720 --> 00:25:09,279
and we also looked at the security

683
00:25:09,279 --> 00:25:11,279
because in the end that's what we are

684
00:25:11,279 --> 00:25:13,440
most interested in when we use second we

685
00:25:13,440 --> 00:25:15,200
want to improve the overall security of

686
00:25:15,200 --> 00:25:16,559
the system

687
00:25:16,559 --> 00:25:19,039
and for that we looked at clients server

688
00:25:19,039 --> 00:25:21,840
and database applications and in total

689
00:25:21,840 --> 00:25:23,840
those were like 18 applications that we

690
00:25:23,840 --> 00:25:25,520
analyzed

691
00:25:25,520 --> 00:25:27,279
throughout this client server and

692
00:25:27,279 --> 00:25:29,120
database applications

693
00:25:29,120 --> 00:25:31,120
and when we look at first the

694
00:25:31,120 --> 00:25:33,440
performance of our tools

695
00:25:33,440 --> 00:25:35,840
we only provide the worst compile time

696
00:25:35,840 --> 00:25:38,159
overhead here and we observed this for

697
00:25:38,159 --> 00:25:40,400
the git application and there we

698
00:25:40,400 --> 00:25:43,600
observed an overhead of 28

699
00:25:43,600 --> 00:25:44,799
28

700
00:25:44,799 --> 00:25:47,360
sounds quite high but you know total

701
00:25:47,360 --> 00:25:50,159
that was like 19 seconds of overhead and

702
00:25:50,159 --> 00:25:51,760
it's actually quite fast when you

703
00:25:51,760 --> 00:25:53,120
compare it to

704
00:25:53,120 --> 00:25:56,158
uh concurrent work

705
00:25:56,240 --> 00:25:58,400
then for the worst binary extraction

706
00:25:58,400 --> 00:26:01,120
time we observed us for ffmpeg it's the

707
00:26:01,120 --> 00:26:02,880
largest application that we looked at i

708
00:26:02,880 --> 00:26:05,520
think the binary was like 100 megabytes

709
00:26:05,520 --> 00:26:07,679
and there it took 11 minutes to extract

710
00:26:07,679 --> 00:26:10,880
it using our analyzer

711
00:26:10,880 --> 00:26:12,960
all we discussed up till up until now is

712
00:26:12,960 --> 00:26:14,559
is basically overhead which we have at

713
00:26:14,559 --> 00:26:18,159
compile time or after

714
00:26:18,159 --> 00:26:19,679
in a pre-processing step before we

715
00:26:19,679 --> 00:26:21,679
actually launch the application

716
00:26:21,679 --> 00:26:22,960
but

717
00:26:22,960 --> 00:26:24,720
there is other overhead as well which we

718
00:26:24,720 --> 00:26:26,960
should at least mention

719
00:26:26,960 --> 00:26:30,640
in terms of runtime and especially so

720
00:26:30,640 --> 00:26:33,039
chestnut itself doesn't add anything in

721
00:26:33,039 --> 00:26:34,559
regards of overhead

722
00:26:34,559 --> 00:26:37,200
during execution but we still use

723
00:26:37,200 --> 00:26:39,360
seccomp and seccomp is

724
00:26:39,360 --> 00:26:42,080
not the fastest if we are completely

725
00:26:42,080 --> 00:26:43,039
honest

726
00:26:43,039 --> 00:26:45,200
um but there is work ongoing uh to

727
00:26:45,200 --> 00:26:47,679
improve this situation so

728
00:26:47,679 --> 00:26:49,440
it's not really in the scope of our work

729
00:26:49,440 --> 00:26:51,520
but every improvement which goes into

730
00:26:51,520 --> 00:26:54,000
seccomp which is part of the linux

731
00:26:54,000 --> 00:26:56,000
kernel itself uh

732
00:26:56,000 --> 00:26:58,000
automatically also improves

733
00:26:58,000 --> 00:26:59,760
our final solution

734
00:26:59,760 --> 00:27:02,240
which is nice i guess

735
00:27:02,240 --> 00:27:04,000
so that's great so

736
00:27:04,000 --> 00:27:05,760
now let's take a closer look at the

737
00:27:05,760 --> 00:27:08,000
functional correctness i mean that's

738
00:27:08,000 --> 00:27:10,799
after security probably one of

739
00:27:10,799 --> 00:27:12,960
developers are most interested because

740
00:27:12,960 --> 00:27:14,640
if your application doesn't work anymore

741
00:27:14,640 --> 00:27:16,799
what's the security worth

742
00:27:16,799 --> 00:27:18,240
um so

743
00:27:18,240 --> 00:27:20,320
for that we relied on the application's

744
00:27:20,320 --> 00:27:22,880
test suites for our checks

745
00:27:22,880 --> 00:27:25,039
so we were not able to test pretty much

746
00:27:25,039 --> 00:27:27,440
all of them but because they simply did

747
00:27:27,440 --> 00:27:30,559
not have test suites available but we

748
00:27:30,559 --> 00:27:34,240
used those that had some available and

749
00:27:34,240 --> 00:27:37,600
let those run and that just checked

750
00:27:37,600 --> 00:27:39,279
did these test tweets complete

751
00:27:39,279 --> 00:27:41,279
successfully because if they did not

752
00:27:41,279 --> 00:27:44,320
then we might have made a mistake

753
00:27:44,320 --> 00:27:46,559
to substantiate that we are actually

754
00:27:46,559 --> 00:27:48,000
looking at the majority of the

755
00:27:48,000 --> 00:27:50,640
application we looked at code coverage

756
00:27:50,640 --> 00:27:52,159
metrics for

757
00:27:52,159 --> 00:27:54,640
uh for the better estimation of

758
00:27:54,640 --> 00:27:56,080
of the correctness

759
00:27:56,080 --> 00:27:58,720
and there we've seen that in regards to

760
00:27:58,720 --> 00:28:01,679
line coverage we were close between 59

761
00:28:01,679 --> 00:28:05,039
and 77 percent and for function coverage

762
00:28:05,039 --> 00:28:08,240
we were able to cover between 61 and 92

763
00:28:08,240 --> 00:28:09,120
of the

764
00:28:09,120 --> 00:28:11,520
of the functions in these test suites so

765
00:28:11,520 --> 00:28:13,360
this might also be a point that we need

766
00:28:13,360 --> 00:28:15,440
better test tweets but this is outside

767
00:28:15,440 --> 00:28:17,840
the scope of our work

768
00:28:17,840 --> 00:28:19,919
what we also looked at or what we've

769
00:28:19,919 --> 00:28:22,080
seen in these tests is that we observed

770
00:28:22,080 --> 00:28:24,720
no crashes during these tests so i think

771
00:28:24,720 --> 00:28:27,120
this is nice it shows that at least for

772
00:28:27,120 --> 00:28:28,880
the main parts that are covered by the

773
00:28:28,880 --> 00:28:30,960
test suites we are able to extract

774
00:28:30,960 --> 00:28:32,960
everything that is necessary

775
00:28:32,960 --> 00:28:34,880
and additionally what we also did is we

776
00:28:34,880 --> 00:28:37,200
performed a six month long term study

777
00:28:37,200 --> 00:28:39,840
using ngn nginx hosting one of our

778
00:28:39,840 --> 00:28:42,240
websites with it and we

779
00:28:42,240 --> 00:28:44,880
observed no crashes over those six

780
00:28:44,880 --> 00:28:46,080
months

781
00:28:46,080 --> 00:28:47,919
okay so another important thing is of

782
00:28:47,919 --> 00:28:49,360
course the security you already

783
00:28:49,360 --> 00:28:51,039
mentioned it the whole point of this

784
00:28:51,039 --> 00:28:53,520
research is to improve security

785
00:28:53,520 --> 00:28:55,919
and uh what we did to figure out how

786
00:28:55,919 --> 00:28:58,000
much we improved this

787
00:28:58,000 --> 00:29:00,240
we looked at how many system calls has

788
00:29:00,240 --> 00:29:01,760
been blocked have been blocked by our

789
00:29:01,760 --> 00:29:02,720
tools

790
00:29:02,720 --> 00:29:04,799
so in particular when you look at the

791
00:29:04,799 --> 00:29:07,200
socializer approach we were able to

792
00:29:07,200 --> 00:29:10,159
block on average 87 of the syscalls

793
00:29:10,159 --> 00:29:12,720
which the linux kernel provides which is

794
00:29:12,720 --> 00:29:14,399
of course a really nice improvement

795
00:29:14,399 --> 00:29:15,440
already

796
00:29:15,440 --> 00:29:18,559
quite similarly uh by analyzer also was

797
00:29:18,559 --> 00:29:20,880
able to block 83

798
00:29:20,880 --> 00:29:23,760
of the sys calls on average which

799
00:29:23,760 --> 00:29:25,520
drastically reduces the attack surface

800
00:29:25,520 --> 00:29:27,520
of the kernel

801
00:29:27,520 --> 00:29:29,200
when we look at uh

802
00:29:29,200 --> 00:29:31,290
exec which is one particular

803
00:29:31,290 --> 00:29:32,559
[Applause]

804
00:29:32,559 --> 00:29:35,200
system call which is quite dangerous in

805
00:29:35,200 --> 00:29:37,520
in terms of security

806
00:29:37,520 --> 00:29:39,360
results were a little bit worse but

807
00:29:39,360 --> 00:29:41,600
still we were able to

808
00:29:41,600 --> 00:29:43,760
block it in nine out of our tested

809
00:29:43,760 --> 00:29:45,200
applications

810
00:29:45,200 --> 00:29:47,840
using the compiler-based approach and

811
00:29:47,840 --> 00:29:50,000
even in 14

812
00:29:50,000 --> 00:29:51,840
using vinylizer

813
00:29:51,840 --> 00:29:54,320
similarly mprotect which makes it

814
00:29:54,320 --> 00:29:55,919
possible to change the execution

815
00:29:55,919 --> 00:29:59,200
permissions of a page in memory

816
00:29:59,200 --> 00:30:01,520
we looked at that in particular and our

817
00:30:01,520 --> 00:30:03,600
socializer tool blocked this system call

818
00:30:03,600 --> 00:30:05,120
in 61

819
00:30:05,120 --> 00:30:07,279
all that is nice but what we also did is

820
00:30:07,279 --> 00:30:09,200
we looked at mitigating real world

821
00:30:09,200 --> 00:30:12,240
exploits so we looked at the meteor

822
00:30:12,240 --> 00:30:14,159
database looked for

823
00:30:14,159 --> 00:30:16,960
for cves that explicitly mentioned that

824
00:30:16,960 --> 00:30:19,360
they exploit some kernel vulnerability

825
00:30:19,360 --> 00:30:21,919
that is triggered using a system call

826
00:30:21,919 --> 00:30:24,320
and there we found 175

827
00:30:24,320 --> 00:30:26,880
uh cves that did exactly that we

828
00:30:26,880 --> 00:30:29,279
analyzed those cves we found that some

829
00:30:29,279 --> 00:30:31,279
of them there is an alternative system

830
00:30:31,279 --> 00:30:33,120
call that might also be able to exploit

831
00:30:33,120 --> 00:30:35,600
this vulnerability so we simply replace

832
00:30:35,600 --> 00:30:38,480
those with with them and got much larger

833
00:30:38,480 --> 00:30:41,919
data sets there so roughly 345

834
00:30:41,919 --> 00:30:44,880
cves in that when it comes to that

835
00:30:44,880 --> 00:30:47,039
and then we just took our applications

836
00:30:47,039 --> 00:30:49,440
all these 18s that we had we compared

837
00:30:49,440 --> 00:30:51,760
the system calls that the cve relies on

838
00:30:51,760 --> 00:30:53,600
what the exploit relies on

839
00:30:53,600 --> 00:30:55,200
cross-reference those with the system

840
00:30:55,200 --> 00:30:57,120
calls that are being allowed

841
00:30:57,120 --> 00:31:00,240
and if we block the system call then we

842
00:31:00,240 --> 00:31:01,919
consider that

843
00:31:01,919 --> 00:31:05,039
this cve to be not exploitable via this

844
00:31:05,039 --> 00:31:06,240
application

845
00:31:06,240 --> 00:31:08,640
and when we looked at the full cve so we

846
00:31:08,640 --> 00:31:10,799
can mitigate all of the variants of it

847
00:31:10,799 --> 00:31:13,919
we were able to block 64 and 62 percent

848
00:31:13,919 --> 00:31:17,360
respectively using sources and binalyzer

849
00:31:17,360 --> 00:31:19,519
and for the sub variants we were able to

850
00:31:19,519 --> 00:31:24,799
block even more so 75 and 72 percent

851
00:31:28,720 --> 00:31:32,559
okay that's pretty impressive but while

852
00:31:32,559 --> 00:31:34,880
you explained that i wasn't listening

853
00:31:34,880 --> 00:31:37,840
too much but i thought about some

854
00:31:37,840 --> 00:31:39,760
exploit technique that

855
00:31:39,760 --> 00:31:42,960
also injects those calls in existing

856
00:31:42,960 --> 00:31:45,919
applications so as thinking about return

857
00:31:45,919 --> 00:31:47,919
oriented programming where i use

858
00:31:47,919 --> 00:31:50,480
existing code in an application to

859
00:31:50,480 --> 00:31:53,039
exploit a program

860
00:31:53,039 --> 00:31:55,279
the idea is to simply

861
00:31:55,279 --> 00:31:56,880
if you have control in the application

862
00:31:56,880 --> 00:31:58,880
because you exploited it to jump to

863
00:31:58,880 --> 00:32:00,720
existing parts of the application so

864
00:32:00,720 --> 00:32:02,559
called gadgets

865
00:32:02,559 --> 00:32:05,120
that do part of the functionality and

866
00:32:05,120 --> 00:32:07,760
then return to the next gadget and so on

867
00:32:07,760 --> 00:32:09,840
and you chain them together so these

868
00:32:09,840 --> 00:32:12,000
gashes could be as simple as

869
00:32:12,000 --> 00:32:13,760
getting some value from the stack into a

870
00:32:13,760 --> 00:32:16,559
register or just

871
00:32:16,559 --> 00:32:19,200
executing a syscall

872
00:32:19,200 --> 00:32:20,240
and

873
00:32:20,240 --> 00:32:23,600
with that couldn't i still exploit your

874
00:32:23,600 --> 00:32:25,679
sandbox application

875
00:32:25,679 --> 00:32:27,039
i mean

876
00:32:27,039 --> 00:32:30,159
if i look at that in detail i'm suddenly

877
00:32:30,159 --> 00:32:32,480
using the stack pointer as the

878
00:32:32,480 --> 00:32:34,559
instruction pointer because i have the

879
00:32:34,559 --> 00:32:36,480
addresses there for all the gadgets i

880
00:32:36,480 --> 00:32:38,960
use and then i'm returning into the

881
00:32:38,960 --> 00:32:40,799
application itself i'm not loading any

882
00:32:40,799 --> 00:32:43,519
code i'm not executing anything with the

883
00:32:43,519 --> 00:32:45,440
x-axis caller i'm not using m protect

884
00:32:45,440 --> 00:32:48,080
for anything so i'm just using existing

885
00:32:48,080 --> 00:32:51,200
code jump to that return again the stack

886
00:32:51,200 --> 00:32:53,200
pointer access the instruction point to

887
00:32:53,200 --> 00:32:56,240
the next gadget i execute that return

888
00:32:56,240 --> 00:32:58,799
back execute the next one and with that

889
00:32:58,799 --> 00:33:01,919
i can build my own code out of existing

890
00:33:01,919 --> 00:33:06,880
code that can do arbitrary syscalls

891
00:33:07,039 --> 00:33:09,760
but yeah mikey that's exactly the point

892
00:33:09,760 --> 00:33:12,399
you you can make arbitrary syscalls we

893
00:33:12,399 --> 00:33:13,760
use something like returner and

894
00:33:13,760 --> 00:33:15,200
programming

895
00:33:15,200 --> 00:33:17,440
but at least in

896
00:33:17,440 --> 00:33:19,760
with the second filtering we can prevent

897
00:33:19,760 --> 00:33:21,679
it on the kernel side so if you build a

898
00:33:21,679 --> 00:33:23,519
source code that was not originally in

899
00:33:23,519 --> 00:33:24,960
the program and which

900
00:33:24,960 --> 00:33:26,960
our tools didn't find

901
00:33:26,960 --> 00:33:29,120
the application simply is terminated as

902
00:33:29,120 --> 00:33:31,600
soon as you try it this demo does pretty

903
00:33:31,600 --> 00:33:33,600
much we show here that it's actually

904
00:33:33,600 --> 00:33:35,760
sandboxed using our approach it reads

905
00:33:35,760 --> 00:33:37,840
from some file and then we start our

906
00:33:37,840 --> 00:33:40,159
attack we crash the application we find

907
00:33:40,159 --> 00:33:43,279
out okay we can have some form of buffer

908
00:33:43,279 --> 00:33:45,440
overflow there we perform a rub attack

909
00:33:45,440 --> 00:33:47,840
that tries to spawn a shell

910
00:33:47,840 --> 00:33:49,600
as we can see here with this pop-up

911
00:33:49,600 --> 00:33:51,360
simply our

912
00:33:51,360 --> 00:33:53,919
uh our system has detected this and

913
00:33:53,919 --> 00:33:56,000
asked us to clarify hey is this

914
00:33:56,000 --> 00:33:58,240
something that you actually want to do

915
00:33:58,240 --> 00:34:00,559
executing this

916
00:34:00,559 --> 00:34:02,880
okay so i think it's really the best to

917
00:34:02,880 --> 00:34:04,399
just give it a try

918
00:34:04,399 --> 00:34:06,399
all our tools

919
00:34:06,399 --> 00:34:08,000
are open source you can find it on

920
00:34:08,000 --> 00:34:10,079
github you find it under the

921
00:34:10,079 --> 00:34:13,520
url in the in the slides and it's the

922
00:34:13,520 --> 00:34:15,599
best simply to try it out yourself and

923
00:34:15,599 --> 00:34:16,560
also

924
00:34:16,560 --> 00:34:18,719
when you're already looking up stuff

925
00:34:18,719 --> 00:34:20,719
also check out our paper it contains

926
00:34:20,719 --> 00:34:22,879
much more information on how the

927
00:34:22,879 --> 00:34:24,800
techniques actually actually work

928
00:34:24,800 --> 00:34:27,599
this really reduces this overhead this

929
00:34:27,599 --> 00:34:30,239
manual analysis overhead to actually

930
00:34:30,239 --> 00:34:32,239
sandbox an application and make it

931
00:34:32,239 --> 00:34:33,280
secure

932
00:34:33,280 --> 00:34:37,119
by having this automated process

933
00:34:37,119 --> 00:34:39,359
yes so that's very nice that we should

934
00:34:39,359 --> 00:34:40,960
through this automated process we were

935
00:34:40,960 --> 00:34:42,560
basically able to show that we can

936
00:34:42,560 --> 00:34:45,440
improve the overall system security

937
00:34:45,440 --> 00:34:48,800
using no manual labor pretty much at all

938
00:34:48,800 --> 00:34:50,239
i mean you need to

939
00:34:50,239 --> 00:34:52,719
modify some make files probably

940
00:34:52,719 --> 00:34:55,119
we were also able to show the functional

941
00:34:55,119 --> 00:34:57,599
correctness using test suites showing

942
00:34:57,599 --> 00:34:59,680
that our applications using the chestnut

943
00:34:59,680 --> 00:35:01,760
sandbox approach still work

944
00:35:01,760 --> 00:35:04,320
and we were only we were also able to

945
00:35:04,320 --> 00:35:06,000
show the chestnut only has a small

946
00:35:06,000 --> 00:35:08,720
performance overhead in your everyday

947
00:35:08,720 --> 00:35:11,680
development cycle so that is something

948
00:35:11,680 --> 00:35:14,160
that should be developed further which

949
00:35:14,160 --> 00:35:17,359
can help make systems a lot more secure

950
00:35:17,359 --> 00:35:19,920
without needing a lot of experts to do

951
00:35:19,920 --> 00:35:21,040
that

952
00:35:21,040 --> 00:35:21,920
so

953
00:35:21,920 --> 00:35:24,720
thanks again all of you for being here

954
00:35:24,720 --> 00:35:28,359
for paying attention

