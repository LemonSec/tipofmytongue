1
00:00:01,180 --> 00:00:14,730
[Music]

2
00:00:16,640 --> 00:00:19,119
welcome to pre-built job chains with the

3
00:00:19,119 --> 00:00:25,279
job rocket bypassing depth without rob

4
00:00:25,599 --> 00:00:28,560
hi i'm dr bremel brisendine and i'm the

5
00:00:28,560 --> 00:00:31,439
director of the verona lab i'm also the

6
00:00:31,439 --> 00:00:33,920
creator of the job rocket

7
00:00:33,920 --> 00:00:36,239
i dabble in being an assistant professor

8
00:00:36,239 --> 00:00:38,399
of computer and cyber sciences at dakota

9
00:00:38,399 --> 00:00:40,160
state university

10
00:00:40,160 --> 00:00:41,920
my interests include software

11
00:00:41,920 --> 00:00:44,480
exploitation reverse engineering

12
00:00:44,480 --> 00:00:47,120
code reuse attacks malware analysis and

13
00:00:47,120 --> 00:00:49,760
just generally offensive security i'm

14
00:00:49,760 --> 00:00:52,399
joined by my co-speaker austin babcock

15
00:00:52,399 --> 00:00:55,120
who is a graduate student at dakota

16
00:00:55,120 --> 00:00:57,600
state university where he studies cyber

17
00:00:57,600 --> 00:01:00,559
operations and computer science austin

18
00:01:00,559 --> 00:01:04,159
is a security researcher in verona lab

19
00:01:04,159 --> 00:01:06,560
at dakota state where he works with me

20
00:01:06,560 --> 00:01:08,720
to develop a new

21
00:01:08,720 --> 00:01:11,200
shell code analysis framework funded by

22
00:01:11,200 --> 00:01:13,119
an nsa grant

23
00:01:13,119 --> 00:01:15,280
he is a contributor to the job rocket

24
00:01:15,280 --> 00:01:17,280
and so skilled

25
00:01:17,280 --> 00:01:19,119
is he a jump or into programming you

26
00:01:19,119 --> 00:01:21,680
could call him a job whisperer

27
00:01:21,680 --> 00:01:22,880
his interest includes software

28
00:01:22,880 --> 00:01:24,320
exploitation

29
00:01:24,320 --> 00:01:27,439
fuzzing hey he built his own fuzzer

30
00:01:27,439 --> 00:01:30,960
reverse engineering and bug bounties

31
00:01:30,960 --> 00:01:33,280
so what are we going to talk about today

32
00:01:33,280 --> 00:01:35,200
well we'll provide a background into

33
00:01:35,200 --> 00:01:37,119
jump oriented programming we'll

34
00:01:37,119 --> 00:01:39,360
introduce the job rocket

35
00:01:39,360 --> 00:01:41,840
we'll have a manual approach to jump

36
00:01:41,840 --> 00:01:43,439
oriented programming

37
00:01:43,439 --> 00:01:46,640
automated job change generation and

38
00:01:46,640 --> 00:01:48,399
we'll provide demos

39
00:01:48,399 --> 00:01:50,479
for both of those

40
00:01:50,479 --> 00:01:52,079
we'll touch on advanced topics like

41
00:01:52,079 --> 00:01:54,479
switching registers for dispatcher

42
00:01:54,479 --> 00:01:57,040
gadgets and functional gadgets control

43
00:01:57,040 --> 00:02:00,880
flow guard aslr and job and using job as

44
00:02:00,880 --> 00:02:02,799
another form of rob

45
00:02:02,799 --> 00:02:05,280
so let's dig into that background

46
00:02:05,280 --> 00:02:08,318
did we create jump oriented programming

47
00:02:08,318 --> 00:02:10,160
hmm let me think

48
00:02:10,160 --> 00:02:12,560
no actually we didn't it's been around

49
00:02:12,560 --> 00:02:14,400
for about a decade but the academic

50
00:02:14,400 --> 00:02:17,599
literature is very very sparse minimal

51
00:02:17,599 --> 00:02:21,280
some serious limitations for one there's

52
00:02:21,280 --> 00:02:24,480
no real dedicated tool to facilitate job

53
00:02:24,480 --> 00:02:28,000
gadget discovery before the job rocket

54
00:02:28,000 --> 00:02:29,920
and more to the point no actual

55
00:02:29,920 --> 00:02:32,959
documentation on how to actually do job

56
00:02:32,959 --> 00:02:36,000
in a real world windows environment more

57
00:02:36,000 --> 00:02:39,360
questions than answers which we resolved

58
00:02:39,360 --> 00:02:42,239
so lots of minute details that we had to

59
00:02:42,239 --> 00:02:46,800
figure out for this to even work

60
00:02:46,800 --> 00:02:49,280
we introduced the job rocket at defcon

61
00:02:49,280 --> 00:02:52,319
27 but now at black hat asia we

62
00:02:52,319 --> 00:02:55,599
introduce a refinement a novel technique

63
00:02:55,599 --> 00:02:58,560
to build a complete job chain

64
00:02:58,560 --> 00:03:00,319
to bypass depth

65
00:03:00,319 --> 00:03:04,200
purely through automation

66
00:03:04,560 --> 00:03:05,280
so

67
00:03:05,280 --> 00:03:08,000
control flow with job

68
00:03:08,000 --> 00:03:09,599
no returns

69
00:03:09,599 --> 00:03:12,000
no stack we don't use them for control

70
00:03:12,000 --> 00:03:13,680
flow instead we're going to use the jump

71
00:03:13,680 --> 00:03:16,000
and call instructions

72
00:03:16,000 --> 00:03:18,480
still we will also use the the stack but

73
00:03:18,480 --> 00:03:21,519
only for for when api calls

74
00:03:21,519 --> 00:03:22,800
pure job

75
00:03:22,800 --> 00:03:24,560
will use a dispatcher gadget and

76
00:03:24,560 --> 00:03:26,640
dispatch table as the means to direct

77
00:03:26,640 --> 00:03:29,200
control flow another style is the bring

78
00:03:29,200 --> 00:03:32,080
your own pop jump which is effectively

79
00:03:32,080 --> 00:03:34,400
rob without the rats and we'll talk

80
00:03:34,400 --> 00:03:36,560
about that later on

81
00:03:36,560 --> 00:03:38,799
so let's see job control flow on action

82
00:03:38,799 --> 00:03:40,959
we have a dispatcher and that will take

83
00:03:40,959 --> 00:03:43,840
us to a dispatch table which contains

84
00:03:43,840 --> 00:03:46,400
addresses for functional gadgets and

85
00:03:46,400 --> 00:03:48,879
those go back to the dispatcher okay so

86
00:03:48,879 --> 00:03:50,959
dispatcher goes to an address he

87
00:03:50,959 --> 00:03:52,799
dereferences it

88
00:03:52,799 --> 00:03:54,799
does the move ebx and then right on back

89
00:03:54,799 --> 00:03:56,799
to the dispatcher we advance forward

90
00:03:56,799 --> 00:03:59,760
four to our next address dereference

91
00:03:59,760 --> 00:04:02,640
do that and then back to the dispatcher

92
00:04:02,640 --> 00:04:05,040
and then this just simply repeats for

93
00:04:05,040 --> 00:04:08,480
however many gadgets that we have

94
00:04:08,480 --> 00:04:10,560
so the key elements here

95
00:04:10,560 --> 00:04:12,000
for jump oriented programming our

96
00:04:12,000 --> 00:04:13,519
dispatch table

97
00:04:13,519 --> 00:04:16,160
this contains the entries for all of our

98
00:04:16,160 --> 00:04:17,759
functional gadgets all of their

99
00:04:17,759 --> 00:04:19,040
addresses

100
00:04:19,040 --> 00:04:21,040
typically we'll put this on the heap

101
00:04:21,040 --> 00:04:23,520
although we can also do the data section

102
00:04:23,520 --> 00:04:26,000
or the stack and we'll separate these

103
00:04:26,000 --> 00:04:29,120
with uniform padding the dispatcher

104
00:04:29,120 --> 00:04:30,960
gadget allows us to move in a

105
00:04:30,960 --> 00:04:34,320
predictable fashion forwards backwards

106
00:04:34,320 --> 00:04:36,639
however you want to do it as long as

107
00:04:36,639 --> 00:04:38,240
it's predictable

108
00:04:38,240 --> 00:04:40,080
functional gadgets we can think of these

109
00:04:40,080 --> 00:04:42,160
as more similar to our traditional rob

110
00:04:42,160 --> 00:04:44,240
gadgets except they're going to

111
00:04:44,240 --> 00:04:46,880
terminate in a jump or a call yeah we

112
00:04:46,880 --> 00:04:48,320
can do calls

113
00:04:48,320 --> 00:04:50,720
on over to the register that takes us

114
00:04:50,720 --> 00:04:53,040
back to the dispatcher gadget

115
00:04:53,040 --> 00:04:55,120
and then windows apis of course we'll

116
00:04:55,120 --> 00:04:58,960
use these to do things like bypass dep

117
00:04:58,960 --> 00:05:01,759
and with that we'll let austin

118
00:05:01,759 --> 00:05:04,320
talk next so we'll take another look at

119
00:05:04,320 --> 00:05:05,919
our job control flow here we have a

120
00:05:05,919 --> 00:05:08,000
diagram similar to before however maybe

121
00:05:08,000 --> 00:05:09,840
a little bit more in depth

122
00:05:09,840 --> 00:05:11,360
we have our dispatcher gadget on the

123
00:05:11,360 --> 00:05:13,199
left we have our dispatch table in the

124
00:05:13,199 --> 00:05:14,320
middle and we have our functional

125
00:05:14,320 --> 00:05:16,560
gadgets on the right so our dispatcher

126
00:05:16,560 --> 00:05:19,120
gadget is using edi to store the address

127
00:05:19,120 --> 00:05:21,199
of our dispatch table that jump d

128
00:05:21,199 --> 00:05:23,360
reference edi is going to bring us to a

129
00:05:23,360 --> 00:05:24,960
functional gadget based on what is in

130
00:05:24,960 --> 00:05:26,639
our dispatch table

131
00:05:26,639 --> 00:05:28,960
so our functional gadget will end in a

132
00:05:28,960 --> 00:05:31,759
jump edx in this example because edx is

133
00:05:31,759 --> 00:05:33,360
holding the address of our dispatcher

134
00:05:33,360 --> 00:05:35,520
gadget once we return back around to our

135
00:05:35,520 --> 00:05:38,240
dispatcher gadget our get that will

136
00:05:38,240 --> 00:05:40,960
increment our edi register our dispatch

137
00:05:40,960 --> 00:05:43,280
tables pointer and bring us to the next

138
00:05:43,280 --> 00:05:45,759
functional gadget in the list so that's

139
00:05:45,759 --> 00:05:47,680
how our control flow for job works we

140
00:05:47,680 --> 00:05:49,759
keep on going around in this loop and

141
00:05:49,759 --> 00:05:51,840
you might notice that esp is not a part

142
00:05:51,840 --> 00:05:54,320
of this control flow at all so um this

143
00:05:54,320 --> 00:05:56,319
is a bit different from wrap or entire

144
00:05:56,319 --> 00:05:58,160
control flow is based on the stack so

145
00:05:58,160 --> 00:05:59,840
we're supplying all of our pointers in a

146
00:05:59,840 --> 00:06:01,919
row on the stack with rop and then that

147
00:06:01,919 --> 00:06:03,759
return at the end of each gadget is kind

148
00:06:03,759 --> 00:06:07,360
of the glue tying them all together

149
00:06:07,360 --> 00:06:09,360
with drop on the other hand on the stack

150
00:06:09,360 --> 00:06:11,520
still does play a role

151
00:06:11,520 --> 00:06:13,440
however it looks different because our

152
00:06:13,440 --> 00:06:16,160
control flow isn't tied to

153
00:06:16,160 --> 00:06:18,800
the stack at all so with drop we still

154
00:06:18,800 --> 00:06:20,639
can pop values we still can't push

155
00:06:20,639 --> 00:06:22,639
values and we're still using the stack

156
00:06:22,639 --> 00:06:24,880
to construct our function parameters

157
00:06:24,880 --> 00:06:26,800
however that process just looks a little

158
00:06:26,800 --> 00:06:28,639
bit different so

159
00:06:28,639 --> 00:06:30,639
with drop here we can still pop values

160
00:06:30,639 --> 00:06:33,600
pop another value and push a value

161
00:06:33,600 --> 00:06:36,319
our end goal job is to execute shellcode

162
00:06:36,319 --> 00:06:38,000
of course and we're going to need to

163
00:06:38,000 --> 00:06:40,400
deal with depth in order to do that so

164
00:06:40,400 --> 00:06:42,560
in order to defeat data execution

165
00:06:42,560 --> 00:06:44,560
prevention we will use something like

166
00:06:44,560 --> 00:06:46,720
virtual protect in order to grant

167
00:06:46,720 --> 00:06:49,039
permissions to execute shellcode and

168
00:06:49,039 --> 00:06:50,639
then job's role is setting up our

169
00:06:50,639 --> 00:06:52,880
parameters and calling that function to

170
00:06:52,880 --> 00:06:54,400
do so

171
00:06:54,400 --> 00:06:56,479
at this point i'm going to press pass

172
00:06:56,479 --> 00:06:58,400
the presentation on over to bramwell to

173
00:06:58,400 --> 00:07:00,960
introduce the drop rocket

174
00:07:00,960 --> 00:07:02,400
thank you austin

175
00:07:02,400 --> 00:07:06,000
jop rocket jump oriented programming

176
00:07:06,000 --> 00:07:08,880
reversing open cyber knowledge expert

177
00:07:08,880 --> 00:07:09,919
tool

178
00:07:09,919 --> 00:07:11,039
yes

179
00:07:11,039 --> 00:07:13,599
just by using the job rocket we are

180
00:07:13,599 --> 00:07:15,840
experts and we dedicate this to the

181
00:07:15,840 --> 00:07:18,880
memory of rocket cats who made the

182
00:07:18,880 --> 00:07:21,120
ultimate sacrifice

183
00:07:21,120 --> 00:07:22,880
we see throughout this

184
00:07:22,880 --> 00:07:27,280
presentation various images of cats

185
00:07:27,280 --> 00:07:29,120
with a flammable device strapped to

186
00:07:29,120 --> 00:07:31,520
their back and their hell bent

187
00:07:31,520 --> 00:07:34,639
and setting a castle on fire

188
00:07:34,639 --> 00:07:37,199
where this comes from is illuminated

189
00:07:37,199 --> 00:07:40,080
manuscripts from the 1300s

190
00:07:40,080 --> 00:07:42,319
that show these rocket cats trying to

191
00:07:42,319 --> 00:07:44,639
subvert the defenses

192
00:07:44,639 --> 00:07:47,120
of an otherwise very well defended

193
00:07:47,120 --> 00:07:48,800
castle

194
00:07:48,800 --> 00:07:51,280
with job rocket we want to do the same

195
00:07:51,280 --> 00:07:53,599
thing we want to subvert

196
00:07:53,599 --> 00:07:56,560
we want to provide a side door

197
00:07:56,560 --> 00:07:59,759
to rap heuristics a side door

198
00:07:59,759 --> 00:08:02,319
to when rob fails or when we just don't

199
00:08:02,319 --> 00:08:04,240
want to do rob

200
00:08:04,240 --> 00:08:06,800
so where did this come from well it grew

201
00:08:06,800 --> 00:08:09,280
out of my doctoral dissertation research

202
00:08:09,280 --> 00:08:10,840
that i conducted

203
00:08:10,840 --> 00:08:13,440
culminating in a

204
00:08:13,440 --> 00:08:14,879
rather large

205
00:08:14,879 --> 00:08:18,720
python program about 30 000 lines with

206
00:08:18,720 --> 00:08:21,280
various dependencies including capstone

207
00:08:21,280 --> 00:08:23,840
pe file etc

208
00:08:23,840 --> 00:08:26,240
and so really the job rocket is the

209
00:08:26,240 --> 00:08:29,919
first and only fully featured job gadget

210
00:08:29,919 --> 00:08:32,479
discovery tool

211
00:08:32,479 --> 00:08:34,159
we're always adding new features the

212
00:08:34,159 --> 00:08:36,479
latest and greatest is the ability to

213
00:08:36,479 --> 00:08:39,760
create a pre-built job chain to bypass

214
00:08:39,760 --> 00:08:40,958
dep

215
00:08:40,958 --> 00:08:44,480
it also empowers you to build your own

216
00:08:44,480 --> 00:08:47,440
job chain purely from scratch

217
00:08:47,440 --> 00:08:49,680
now when i started this research i

218
00:08:49,680 --> 00:08:50,480
thought

219
00:08:50,480 --> 00:08:53,440
well if i did a dynamic approach

220
00:08:53,440 --> 00:08:55,360
if i built something to integrate with

221
00:08:55,360 --> 00:08:58,959
say windebug or immunity

222
00:08:58,959 --> 00:09:01,440
that would be very easy for me to do

223
00:09:01,440 --> 00:09:04,640
too easy so i wanted to challenge myself

224
00:09:04,640 --> 00:09:07,440
and so i decided let's do static

225
00:09:07,440 --> 00:09:08,560
analysis

226
00:09:08,560 --> 00:09:10,800
so it is able to go on there and extract

227
00:09:10,800 --> 00:09:13,040
the image executable as well as all the

228
00:09:13,040 --> 00:09:16,000
modules and get those gadgets

229
00:09:16,000 --> 00:09:17,640
and when it's getting the gadgets it

230
00:09:17,640 --> 00:09:20,480
simultaneously at the same time

231
00:09:20,480 --> 00:09:23,360
is classifying them into

232
00:09:23,360 --> 00:09:26,160
categories based on operation performed

233
00:09:26,160 --> 00:09:28,640
based on register affected and literally

234
00:09:28,640 --> 00:09:30,399
there's hundreds

235
00:09:30,399 --> 00:09:32,399
of data structures used to store this

236
00:09:32,399 --> 00:09:34,480
information

237
00:09:34,480 --> 00:09:36,399
now we've mentioned the pre-built job

238
00:09:36,399 --> 00:09:38,399
chains we'll get to that later

239
00:09:38,399 --> 00:09:40,560
other new features include the ability

240
00:09:40,560 --> 00:09:43,120
to filter and exclude on bad characters

241
00:09:43,120 --> 00:09:44,959
we don't like those

242
00:09:44,959 --> 00:09:47,279
or on mitigations that we just don't

243
00:09:47,279 --> 00:09:49,040
care for

244
00:09:49,040 --> 00:09:52,240
now job rocket does provide

245
00:09:52,240 --> 00:09:54,080
significant customization when you're

246
00:09:54,080 --> 00:09:56,080
trying to initially form and find these

247
00:09:56,080 --> 00:09:59,120
gadgets so you can reduce or enlarge the

248
00:09:59,120 --> 00:10:00,560
scope

249
00:10:00,560 --> 00:10:04,000
and like any rop tool that i can imagine

250
00:10:04,000 --> 00:10:07,040
it also uses op code splitting which

251
00:10:07,040 --> 00:10:08,880
enables us to find the unintended

252
00:10:08,880 --> 00:10:10,720
instructors because

253
00:10:10,720 --> 00:10:12,800
you know unintended instructions that

254
00:10:12,800 --> 00:10:14,000
are viable

255
00:10:14,000 --> 00:10:17,120
that is one of the great features of x86

256
00:10:17,120 --> 00:10:19,839
intel architecture

257
00:10:21,680 --> 00:10:23,760
so let's look at the job rocket command

258
00:10:23,760 --> 00:10:26,240
line interface now the first thing we

259
00:10:26,240 --> 00:10:27,600
want to do is pick out the registers

260
00:10:27,600 --> 00:10:29,200
we're interested in so for if our

261
00:10:29,200 --> 00:10:32,240
functional gadget ends in jump eax then

262
00:10:32,240 --> 00:10:34,000
the rest of them will probably end and

263
00:10:34,000 --> 00:10:35,600
jump eax

264
00:10:35,600 --> 00:10:38,800
unless we decide to transition

265
00:10:38,800 --> 00:10:40,720
to say jump edx so pick out the

266
00:10:40,720 --> 00:10:43,600
registers registers that you want

267
00:10:43,600 --> 00:10:44,959
and then

268
00:10:44,959 --> 00:10:48,000
we can type g to extract those

269
00:10:48,000 --> 00:10:49,600
or if we want everything which is

270
00:10:49,600 --> 00:10:51,760
probably what i would do just do the big

271
00:10:51,760 --> 00:10:53,440
g

272
00:10:53,440 --> 00:10:56,079
and then s we can establish the scope is

273
00:10:56,079 --> 00:10:58,160
it the image executable or are we

274
00:10:58,160 --> 00:11:01,600
getting all the modules and dlls

275
00:11:01,600 --> 00:11:03,839
and if we want to extract the modules

276
00:11:03,839 --> 00:11:05,760
we'll also need to do the m which will

277
00:11:05,760 --> 00:11:08,560
do that and also get the mitigations and

278
00:11:08,560 --> 00:11:10,720
then at this point everything has been

279
00:11:10,720 --> 00:11:13,680
found it's been classified silk can now

280
00:11:13,680 --> 00:11:17,040
be instantaneously retrieved and to do

281
00:11:17,040 --> 00:11:20,079
that we'll go into our print submenu

282
00:11:20,079 --> 00:11:22,320
so first thing we want to do we want to

283
00:11:22,320 --> 00:11:24,480
use the r to specify the register of

284
00:11:24,480 --> 00:11:25,440
interest

285
00:11:25,440 --> 00:11:27,279
and then next we want to

286
00:11:27,279 --> 00:11:28,480
use the g

287
00:11:28,480 --> 00:11:31,279
to pick out which operations

288
00:11:31,279 --> 00:11:32,720
we want

289
00:11:32,720 --> 00:11:35,839
or if we want all then we can pick all

290
00:11:35,839 --> 00:11:37,200
and let's take a look here at some

291
00:11:37,200 --> 00:11:38,959
results okay so creates a directory

292
00:11:38,959 --> 00:11:41,279
called wave read and it puts all of the

293
00:11:41,279 --> 00:11:42,399
different

294
00:11:42,399 --> 00:11:45,120
files generated and they're saved based

295
00:11:45,120 --> 00:11:47,920
on operation and register affected let's

296
00:11:47,920 --> 00:11:51,600
look at one of them okay this is add ebx

297
00:11:51,600 --> 00:11:54,560
i have add bh i have

298
00:11:54,560 --> 00:11:57,760
bx i have add i have add with carry i

299
00:11:57,760 --> 00:11:59,760
have jump and of course i have call

300
00:11:59,760 --> 00:12:03,920
because remember we can also do call

301
00:12:03,920 --> 00:12:08,160
so with that i will pass it to austin

302
00:12:08,160 --> 00:12:09,440
so we're going to be taking a look at

303
00:12:09,440 --> 00:12:11,600
the manual approach of jop here and to

304
00:12:11,600 --> 00:12:13,200
demonstrate that we're going to be using

305
00:12:13,200 --> 00:12:15,279
a demo program which is a simple hash

306
00:12:15,279 --> 00:12:17,040
cracker and it contains a buffer over

307
00:12:17,040 --> 00:12:19,040
full vulnerability so we'll be looking

308
00:12:19,040 --> 00:12:21,120
at examples from that demo program and

309
00:12:21,120 --> 00:12:23,040
the exploit built around it in order to

310
00:12:23,040 --> 00:12:25,680
see some challenges associated with the

311
00:12:25,680 --> 00:12:29,200
being with the manual approach of job

312
00:12:29,200 --> 00:12:31,440
looking at a diagram of our exploit we

313
00:12:31,440 --> 00:12:33,680
have our initial buffer overflow once we

314
00:12:33,680 --> 00:12:35,519
gain control of eip we'll set up our

315
00:12:35,519 --> 00:12:37,519
registers for job and we will use our

316
00:12:37,519 --> 00:12:39,600
drop chain to get our parameters sorted

317
00:12:39,600 --> 00:12:41,839
out for virtual protect virtual protect

318
00:12:41,839 --> 00:12:43,680
will be de-referenced the pointer will

319
00:12:43,680 --> 00:12:45,360
be dereferenced and we will call that

320
00:12:45,360 --> 00:12:47,519
function in order to overcome depth and

321
00:12:47,519 --> 00:12:49,920
then we will execute our shellcode

322
00:12:49,920 --> 00:12:51,519
looking at our payload we have some

323
00:12:51,519 --> 00:12:54,079
padding until we can control eip then we

324
00:12:54,079 --> 00:12:55,839
have our job chain which sets up virtual

325
00:12:55,839 --> 00:12:57,680
protect we have our shell code which is

326
00:12:57,680 --> 00:12:59,839
a proof of concept message box and then

327
00:12:59,839 --> 00:13:01,920
we have some additional padding and our

328
00:13:01,920 --> 00:13:04,240
dispatch table

329
00:13:04,240 --> 00:13:06,240
our dispatcher gadget is this one on the

330
00:13:06,240 --> 00:13:09,279
left where we have edi reserved for use

331
00:13:09,279 --> 00:13:12,079
of our dispatch table that's the pointer

332
00:13:12,079 --> 00:13:15,279
and we have add edi 8. since we have add

333
00:13:15,279 --> 00:13:17,760
edi 8 and each pointer 2 gadgets are

334
00:13:17,760 --> 00:13:20,000
only 4 bytes we will need to add 4 bytes

335
00:13:20,000 --> 00:13:24,320
of padding in between each pointer

336
00:13:24,320 --> 00:13:26,639
when we gain control vip we want to set

337
00:13:26,639 --> 00:13:29,600
up our job control flow that register

338
00:13:29,600 --> 00:13:31,519
for our dispatcher gadget in our

339
00:13:31,519 --> 00:13:33,040
dispatch table

340
00:13:33,040 --> 00:13:35,360
in an ideal world we can use a job setup

341
00:13:35,360 --> 00:13:37,839
gadget so we are using peer drop here

342
00:13:37,839 --> 00:13:39,760
however with a drop we only have access

343
00:13:39,760 --> 00:13:41,760
to one gadget to set everything up

344
00:13:41,760 --> 00:13:43,279
because we don't have our control flow

345
00:13:43,279 --> 00:13:45,920
setup to use multiple so in a more ideal

346
00:13:45,920 --> 00:13:48,560
world we can use a series of wrap

347
00:13:48,560 --> 00:13:50,639
gadgets which do the same thing as the

348
00:13:50,639 --> 00:13:53,680
job setup gadget however with rob so

349
00:13:53,680 --> 00:13:55,760
this might be more practical and finding

350
00:13:55,760 --> 00:13:58,800
that magic drop gadget is not so easy

351
00:13:58,800 --> 00:14:00,880
with our rob setup gadget we're doing

352
00:14:00,880 --> 00:14:02,720
the exact same thing where we're loading

353
00:14:02,720 --> 00:14:05,040
an xor key and some encoded

354
00:14:05,040 --> 00:14:07,440
pointers in order to overcome bad bytes

355
00:14:07,440 --> 00:14:08,480
and then we're just getting that

356
00:14:08,480 --> 00:14:10,560
dispatcher gadget and our dispatch table

357
00:14:10,560 --> 00:14:12,560
pointer set up in our registers for our

358
00:14:12,560 --> 00:14:14,800
control flow after that we can return to

359
00:14:14,800 --> 00:14:16,480
doing job and just jump to our

360
00:14:16,480 --> 00:14:19,279
dispatcher gadget

361
00:14:19,279 --> 00:14:20,880
one thing to note is that even though

362
00:14:20,880 --> 00:14:23,040
jop is jump oriented programming we can

363
00:14:23,040 --> 00:14:25,199
use gadgets ending and call

364
00:14:25,199 --> 00:14:27,040
the call gadgets are the same thing as a

365
00:14:27,040 --> 00:14:28,959
jump gadget they just have an implicit

366
00:14:28,959 --> 00:14:30,880
push of the instruction pointer

367
00:14:30,880 --> 00:14:33,760
beforehand so in normal x86 programming

368
00:14:33,760 --> 00:14:35,600
that would allow you to return back to

369
00:14:35,600 --> 00:14:38,800
whatever instruction was next after you

370
00:14:38,800 --> 00:14:42,079
perform a function call

371
00:14:42,639 --> 00:14:44,560
for our purposes we can still use this

372
00:14:44,560 --> 00:14:46,399
call gadget however we do need to make

373
00:14:46,399 --> 00:14:48,320
sure that push isn't going to overwrite

374
00:14:48,320 --> 00:14:50,399
anything we need and then afterwards we

375
00:14:50,399 --> 00:14:52,639
can just use a pop gadget no no in order

376
00:14:52,639 --> 00:14:54,959
to repair esp

377
00:14:54,959 --> 00:14:56,720
we'll be using virtual protect in order

378
00:14:56,720 --> 00:14:59,839
to overcome depth

379
00:15:00,079 --> 00:15:01,760
as far as setting up our parameters for

380
00:15:01,760 --> 00:15:04,000
virtual protectos many of them do have

381
00:15:04,000 --> 00:15:06,320
bad bytes in them so we can't put those

382
00:15:06,320 --> 00:15:08,079
in our payload and we'll need to supply

383
00:15:08,079 --> 00:15:09,519
placeholders for these parameters

384
00:15:09,519 --> 00:15:12,000
however one parameter lpf old protect

385
00:15:12,000 --> 00:15:14,160
does not have bad bytes so we're fine to

386
00:15:14,160 --> 00:15:15,760
supply that in the payload the

387
00:15:15,760 --> 00:15:17,680
placeholders will be overwritten by job

388
00:15:17,680 --> 00:15:19,360
later they're just there to keep track

389
00:15:19,360 --> 00:15:22,079
of where we are

390
00:15:22,240 --> 00:15:24,079
we have two main methods of overriding

391
00:15:24,079 --> 00:15:26,959
placeholders push is one more realistic

392
00:15:26,959 --> 00:15:28,320
and more common

393
00:15:28,320 --> 00:15:29,680
we will need to work with the stack

394
00:15:29,680 --> 00:15:32,399
however which is a challenge and we only

395
00:15:32,399 --> 00:15:34,480
need one register for push

396
00:15:34,480 --> 00:15:36,320
for move d repointer we don't have to

397
00:15:36,320 --> 00:15:38,240
work with the stack however we do need

398
00:15:38,240 --> 00:15:40,880
two registers reserved one for the

399
00:15:40,880 --> 00:15:42,880
address to write to and then one for the

400
00:15:42,880 --> 00:15:45,120
value and registers are in short supply

401
00:15:45,120 --> 00:15:46,880
with job because we have two reserved

402
00:15:46,880 --> 00:15:50,079
for our control flow already

403
00:15:50,079 --> 00:15:52,399
looking at ex at an example of the push

404
00:15:52,399 --> 00:15:54,639
method and we can get our

405
00:15:54,639 --> 00:15:56,800
value for our parameter that we want set

406
00:15:56,800 --> 00:16:00,399
up in a register and then we pivot esp

407
00:16:00,399 --> 00:16:02,480
four bytes above the location we want to

408
00:16:02,480 --> 00:16:04,079
write to because push is going to

409
00:16:04,079 --> 00:16:06,399
overwrite to esp minus four once we

410
00:16:06,399 --> 00:16:09,519
perform our push we will do our overrate

411
00:16:09,519 --> 00:16:12,720
um looking at a generalized example here

412
00:16:12,720 --> 00:16:15,279
of how to do push for if we wanted to do

413
00:16:15,279 --> 00:16:17,680
push for every single parameter um we

414
00:16:17,680 --> 00:16:19,440
can lay out our stack like this where we

415
00:16:19,440 --> 00:16:21,600
have parameter 1 2 then three which will

416
00:16:21,600 --> 00:16:23,920
be xored of course to overcome bad bytes

417
00:16:23,920 --> 00:16:25,680
and then we have placeholder one two and

418
00:16:25,680 --> 00:16:28,000
three directly after with this layout we

419
00:16:28,000 --> 00:16:29,759
can do this method where we pop our

420
00:16:29,759 --> 00:16:32,079
first parameter off the stack xor to

421
00:16:32,079 --> 00:16:34,800
avoid bad bytes then we pivot esp four

422
00:16:34,800 --> 00:16:37,360
bytes above our placeholder because of

423
00:16:37,360 --> 00:16:39,759
that esp minus four where push is going

424
00:16:39,759 --> 00:16:42,160
to write to on one way to pivot is via

425
00:16:42,160 --> 00:16:46,000
pop gadgets which increment esp by four

426
00:16:46,000 --> 00:16:48,320
once we once we do our overwrite with

427
00:16:48,320 --> 00:16:51,040
push we pivot esp backwards to our

428
00:16:51,040 --> 00:16:53,040
parameter 2 value and then we can repeat

429
00:16:53,040 --> 00:16:56,639
the process with every parameter

430
00:16:57,759 --> 00:16:59,519
the reason that we can use the same

431
00:16:59,519 --> 00:17:01,360
offsets for our pivots is because with

432
00:17:01,360 --> 00:17:03,360
this layout the distance between each

433
00:17:03,360 --> 00:17:05,280
placeholder and each parameter is always

434
00:17:05,280 --> 00:17:08,559
the same so here parameter 1 is 0xc away

435
00:17:08,559 --> 00:17:11,280
from parameter or placeholder 1 and then

436
00:17:11,280 --> 00:17:13,039
placeholder 2 is the same distance from

437
00:17:13,039 --> 00:17:15,919
parameter 2 and so on

438
00:17:15,919 --> 00:17:17,520
i'm looking at our move dereference

439
00:17:17,520 --> 00:17:18,400
method

440
00:17:18,400 --> 00:17:20,720
once we get our gadgets or once we get

441
00:17:20,720 --> 00:17:22,720
our register set up via our gadgets we

442
00:17:22,720 --> 00:17:25,359
will need to have um

443
00:17:25,359 --> 00:17:27,599
the first dereference register being the

444
00:17:27,599 --> 00:17:29,600
address that we're writing to and then

445
00:17:29,600 --> 00:17:31,840
our second register being the value that

446
00:17:31,840 --> 00:17:34,400
we're writing so here we have evx set up

447
00:17:34,400 --> 00:17:36,320
with the address and we have ecx set up

448
00:17:36,320 --> 00:17:38,240
with our value and then once we execute

449
00:17:38,240 --> 00:17:39,840
this gadget we will overrate our

450
00:17:39,840 --> 00:17:42,320
parameter

451
00:17:42,320 --> 00:17:43,919
after setting up all of our parameters

452
00:17:43,919 --> 00:17:45,919
we're going to call our api function to

453
00:17:45,919 --> 00:17:48,559
overcome depth we will need to pivot esp

454
00:17:48,559 --> 00:17:49,679
to the beginning of all of those

455
00:17:49,679 --> 00:17:51,440
parameters to make sure we're using the

456
00:17:51,440 --> 00:17:52,880
correct values

457
00:17:52,880 --> 00:17:54,880
there's multiple ways in order to

458
00:17:54,880 --> 00:17:56,480
actually dereference the pointer and

459
00:17:56,480 --> 00:17:58,400
make the call once we're ready

460
00:17:58,400 --> 00:18:01,120
so um one way is if ebx contains the

461
00:18:01,120 --> 00:18:03,280
virtual protect pointer we can do jump d

462
00:18:03,280 --> 00:18:07,039
reference evx also you can do move evx

463
00:18:07,039 --> 00:18:09,200
dealer pointer ebx and then do a normal

464
00:18:09,200 --> 00:18:11,280
jump or we could even dereference in

465
00:18:11,280 --> 00:18:13,679
place like before and then jump or push

466
00:18:13,679 --> 00:18:16,000
to the stack and then jump to esp which

467
00:18:16,000 --> 00:18:17,440
is actually what we will do in our

468
00:18:17,440 --> 00:18:19,200
exploit

469
00:18:19,200 --> 00:18:23,120
so looking at our demo of this exploit

470
00:18:23,120 --> 00:18:26,000
we will look at immunity and see how

471
00:18:26,000 --> 00:18:29,480
this all works

472
00:18:31,520 --> 00:18:32,960
okay so we're going to start out in our

473
00:18:32,960 --> 00:18:34,799
job setup gadget here

474
00:18:34,799 --> 00:18:36,880
we have our pops with our ink

475
00:18:36,880 --> 00:18:39,520
with our xor keys so we have dispatcher

476
00:18:39,520 --> 00:18:41,600
gadget address and edx and our dispatch

477
00:18:41,600 --> 00:18:44,240
tables address and edi

478
00:18:44,240 --> 00:18:46,320
we will follow that in the dump so we

479
00:18:46,320 --> 00:18:49,120
can see our actual dispatch table

480
00:18:49,120 --> 00:18:50,799
you might notice that our setup gadget

481
00:18:50,799 --> 00:18:53,039
ends in a call so we will need to pop

482
00:18:53,039 --> 00:18:54,559
off that implicit push that we were

483
00:18:54,559 --> 00:18:56,640
talking about earlier so if you look in

484
00:18:56,640 --> 00:18:58,240
the code here we can see that this first

485
00:18:58,240 --> 00:19:00,320
pop here is just labeled pop junk

486
00:19:00,320 --> 00:19:01,760
because we don't care about that address

487
00:19:01,760 --> 00:19:03,600
at all we're just fixing our stack after

488
00:19:03,600 --> 00:19:04,720
our call

489
00:19:04,720 --> 00:19:06,880
messed it up a little bit

490
00:19:06,880 --> 00:19:09,360
so we will do our first pop and then our

491
00:19:09,360 --> 00:19:12,080
next pop will be our shell codes address

492
00:19:12,080 --> 00:19:14,320
encoded of course which will xor so we

493
00:19:14,320 --> 00:19:16,960
can see in the code we've labeled that

494
00:19:16,960 --> 00:19:19,039
that value we'll get xor to our shadow

495
00:19:19,039 --> 00:19:20,880
code's address and this address will

496
00:19:20,880 --> 00:19:22,320
actually be used for two different

497
00:19:22,320 --> 00:19:24,080
parameters one of them being the return

498
00:19:24,080 --> 00:19:26,080
address and then the next one being the

499
00:19:26,080 --> 00:19:29,919
lp address so first we'll pivot esp

500
00:19:29,919 --> 00:19:32,080
after we get our xor setup we'll pivot

501
00:19:32,080 --> 00:19:35,360
esp to our corresponding placeholder

502
00:19:35,360 --> 00:19:37,120
we're actually going to overwrite the

503
00:19:37,120 --> 00:19:38,720
return address first even though it's

504
00:19:38,720 --> 00:19:41,520
the last placeholder in order

505
00:19:41,520 --> 00:19:43,600
because the pivot backwards to the next

506
00:19:43,600 --> 00:19:44,960
um

507
00:19:44,960 --> 00:19:46,240
the next placeholder that we're going to

508
00:19:46,240 --> 00:19:48,080
use the same value for is easier that

509
00:19:48,080 --> 00:19:50,480
way so here we'll do our overwrite we

510
00:19:50,480 --> 00:19:51,600
can see in the dump we have it

511
00:19:51,600 --> 00:19:53,120
highlighted and we can see that we're

512
00:19:53,120 --> 00:19:55,840
going to overwrite that 7070 value here

513
00:19:55,840 --> 00:19:57,440
corresponding to what's highlighted in

514
00:19:57,440 --> 00:19:59,440
the dump in the bottom left once you do

515
00:19:59,440 --> 00:20:01,760
our push we will have returned we will

516
00:20:01,760 --> 00:20:03,840
have pushed our return address and then

517
00:20:03,840 --> 00:20:05,919
now we'll just pivot esp again using the

518
00:20:05,919 --> 00:20:07,520
same value we don't need to change the

519
00:20:07,520 --> 00:20:09,280
value here because we're using the same

520
00:20:09,280 --> 00:20:12,480
thing for our lp address as well

521
00:20:12,480 --> 00:20:14,159
so we'll do that overwrite and then

522
00:20:14,159 --> 00:20:15,840
following that we'll do two move

523
00:20:15,840 --> 00:20:18,320
dereference overwrites so skipping the

524
00:20:18,320 --> 00:20:20,240
register setup for the move d reference

525
00:20:20,240 --> 00:20:23,679
because there's a lot of xoring

526
00:20:23,760 --> 00:20:24,960
we will

527
00:20:24,960 --> 00:20:27,120
set up our size parameter to be written

528
00:20:27,120 --> 00:20:29,760
with ebx being the address to write to

529
00:20:29,760 --> 00:20:31,679
and the ecx being the value so we're

530
00:20:31,679 --> 00:20:34,880
writing that 250 value

531
00:20:34,880 --> 00:20:36,159
so now we've

532
00:20:36,159 --> 00:20:40,240
overwritten dw size and next we have um

533
00:20:40,240 --> 00:20:42,320
our new protect setup

534
00:20:42,320 --> 00:20:44,240
so lastly

535
00:20:44,240 --> 00:20:46,080
we're going to write that new protect

536
00:20:46,080 --> 00:20:48,960
value

537
00:20:48,960 --> 00:20:50,880
that 40 corresponds to read write

538
00:20:50,880 --> 00:20:52,880
execute now we get our virtual protect

539
00:20:52,880 --> 00:20:54,720
pointer because we have our

540
00:20:54,720 --> 00:20:56,400
parameters set up we de-reference that

541
00:20:56,400 --> 00:20:59,360
we're going to push that onto the stack

542
00:20:59,360 --> 00:21:00,960
after we push that onto the stack we'll

543
00:21:00,960 --> 00:21:03,200
do jump dwarf pointer esp to call the

544
00:21:03,200 --> 00:21:04,159
function

545
00:21:04,159 --> 00:21:05,760
immunity will show us that we have all

546
00:21:05,760 --> 00:21:07,760
of our parameters set up correctly and

547
00:21:07,760 --> 00:21:09,520
assuming everything worked correctly our

548
00:21:09,520 --> 00:21:11,919
shellcode should run

549
00:21:11,919 --> 00:21:13,640
and we can see we did it we got

550
00:21:13,640 --> 00:21:16,159
blackhat21 to display our message box

551
00:21:16,159 --> 00:21:17,600
our proof of concept and we've

552
00:21:17,600 --> 00:21:19,840
successfully performed a job in order to

553
00:21:19,840 --> 00:21:21,440
run shellcode

554
00:21:21,440 --> 00:21:22,960
at this point i'm going to pass the

555
00:21:22,960 --> 00:21:26,720
presentation back on over to bremo

556
00:21:26,720 --> 00:21:28,320
thank you austin

557
00:21:28,320 --> 00:21:32,240
automated generation of job chains

558
00:21:32,240 --> 00:21:34,080
let's dig into it

559
00:21:34,080 --> 00:21:35,840
so the manual approach that austin

560
00:21:35,840 --> 00:21:38,000
described it's kind of weird kind of

561
00:21:38,000 --> 00:21:41,280
scary kind of complex a little bit ugly

562
00:21:41,280 --> 00:21:42,080
but

563
00:21:42,080 --> 00:21:44,480
what if we could simplify job what if we

564
00:21:44,480 --> 00:21:47,520
can make it a little bit easier to do

565
00:21:47,520 --> 00:21:50,240
dare we attempt such a thing and i say

566
00:21:50,240 --> 00:21:52,240
let's just do it

567
00:21:52,240 --> 00:21:53,200
and

568
00:21:53,200 --> 00:21:54,880
so we've done so

569
00:21:54,880 --> 00:21:57,919
and we take inspiration from a tool like

570
00:21:57,919 --> 00:22:01,760
mona that can enable us to bypass dep

571
00:22:01,760 --> 00:22:04,080
with return oriented programming using

572
00:22:04,080 --> 00:22:07,440
apis like virtual protect and virtual

573
00:22:07,440 --> 00:22:08,480
alec

574
00:22:08,480 --> 00:22:10,880
so the ideal way to set up rop is we

575
00:22:10,880 --> 00:22:13,039
will take all of our parameter values

576
00:22:13,039 --> 00:22:16,240
for the win api plug it into registers

577
00:22:16,240 --> 00:22:18,080
and then push add will push them onto

578
00:22:18,080 --> 00:22:21,200
the stack in a very very specific order

579
00:22:21,200 --> 00:22:23,919
and then make the win api call

580
00:22:23,919 --> 00:22:25,679
with jop

581
00:22:25,679 --> 00:22:28,799
there is no magical push at instruction

582
00:22:28,799 --> 00:22:30,799
but instead we'll just take all of our

583
00:22:30,799 --> 00:22:32,640
parameter values in a very specific

584
00:22:32,640 --> 00:22:33,600
order

585
00:22:33,600 --> 00:22:35,679
dump them onto the stack and then use a

586
00:22:35,679 --> 00:22:38,320
series of multiple stack pivots

587
00:22:38,320 --> 00:22:40,400
to reach that location and then

588
00:22:40,400 --> 00:22:43,200
de-reference the win api call and

589
00:22:43,200 --> 00:22:45,840
from there the rest is history

590
00:22:45,840 --> 00:22:48,480
now what job rocket does is it will try

591
00:22:48,480 --> 00:22:50,320
to produce distinct

592
00:22:50,320 --> 00:22:52,960
job chains for each and every register

593
00:22:52,960 --> 00:22:55,360
because remember these registers are

594
00:22:55,360 --> 00:22:56,240
very

595
00:22:56,240 --> 00:22:57,600
conflicted

596
00:22:57,600 --> 00:22:59,440
so we have register always tied up for

597
00:22:59,440 --> 00:23:00,559
the dispatch

598
00:23:00,559 --> 00:23:02,720
table and also tied up for the

599
00:23:02,720 --> 00:23:04,559
dispatcher gadget

600
00:23:04,559 --> 00:23:07,200
so if we interfere with those registers

601
00:23:07,200 --> 00:23:09,520
it breaks the control flow and at the

602
00:23:09,520 --> 00:23:11,360
same time if you have a functional

603
00:23:11,360 --> 00:23:14,240
gadget that ends in jump eax well it's

604
00:23:14,240 --> 00:23:16,720
probably going to stay in jump eax and

605
00:23:16,720 --> 00:23:19,760
not go and end and jump ebx so there are

606
00:23:19,760 --> 00:23:22,159
lots of different possibilities in terms

607
00:23:22,159 --> 00:23:23,679
of the different

608
00:23:23,679 --> 00:23:26,559
job chains we can generate we also

609
00:23:26,559 --> 00:23:29,679
produce five variations for each

610
00:23:29,679 --> 00:23:31,360
specific register

611
00:23:31,360 --> 00:23:36,159
utilizing different stack pivot amounts

612
00:23:36,159 --> 00:23:37,039
now

613
00:23:37,039 --> 00:23:39,840
the premise behind our stock pivots is

614
00:23:39,840 --> 00:23:42,159
imagine that you have a buffer overflow

615
00:23:42,159 --> 00:23:44,080
you have an seh override whatever the

616
00:23:44,080 --> 00:23:47,200
case and you need to do a pivot

617
00:23:47,200 --> 00:23:49,440
of 5000 bytes

618
00:23:49,440 --> 00:23:51,200
to reach your your destination your

619
00:23:51,200 --> 00:23:52,559
payload

620
00:23:52,559 --> 00:23:54,559
i mean you could do that with one gadget

621
00:23:54,559 --> 00:23:57,360
if you if you found it but at the same

622
00:23:57,360 --> 00:24:00,240
time with job you can also do it with

623
00:24:00,240 --> 00:24:01,120
many

624
00:24:01,120 --> 00:24:03,360
other different stock pivots

625
00:24:03,360 --> 00:24:06,080
that jointly can allow you to reach that

626
00:24:06,080 --> 00:24:08,080
destination and then from there we just

627
00:24:08,080 --> 00:24:11,279
simply uh make the the win api call

628
00:24:11,279 --> 00:24:12,960
so let's look specifically here so we

629
00:24:12,960 --> 00:24:14,320
have esi

630
00:24:14,320 --> 00:24:16,640
and we add esi and then dereference that

631
00:24:16,640 --> 00:24:18,720
takes us to our dispatch table

632
00:24:18,720 --> 00:24:20,000
and then over here we have four

633
00:24:20,000 --> 00:24:22,080
different stack pivots equaling about

634
00:24:22,080 --> 00:24:24,880
5000 we have some our parameter values

635
00:24:24,880 --> 00:24:26,640
we have the pointer to virtual protect

636
00:24:26,640 --> 00:24:28,240
we plug that in over here with the pop

637
00:24:28,240 --> 00:24:31,039
eax we de-reference it and if we

638
00:24:31,039 --> 00:24:33,919
precisely calculate it

639
00:24:33,919 --> 00:24:36,320
with the right stack pivot amounts at

640
00:24:36,320 --> 00:24:38,559
this point in time

641
00:24:38,559 --> 00:24:40,880
it's ready everything is ready

642
00:24:40,880 --> 00:24:42,480
and it'll work

643
00:24:42,480 --> 00:24:45,440
no need for a push ad

644
00:24:45,440 --> 00:24:47,520
now specifically how the job rocket

645
00:24:47,520 --> 00:24:49,520
generates this is firstly it's going to

646
00:24:49,520 --> 00:24:51,919
try to find the dispatcher gadget

647
00:24:51,919 --> 00:24:54,799
and then calculate the necessary padding

648
00:24:54,799 --> 00:24:58,320
to place between each functional gadget

649
00:24:58,320 --> 00:25:00,240
if it doesn't find a dispatcher gadget

650
00:25:00,240 --> 00:25:02,159
it'll still produce a chain because you

651
00:25:02,159 --> 00:25:04,880
can always enlarge the scope or look for

652
00:25:04,880 --> 00:25:07,200
alternative dgs

653
00:25:07,200 --> 00:25:09,919
next it'll use two rob gadgets to load

654
00:25:09,919 --> 00:25:12,159
the dispatch table and the dispatcher

655
00:25:12,159 --> 00:25:14,240
gadget and then from there we start the

656
00:25:14,240 --> 00:25:17,760
job it'll find your win api functions

657
00:25:17,760 --> 00:25:21,440
and also calculate these stat pivots to

658
00:25:21,440 --> 00:25:24,000
match the minimum and the maximum that

659
00:25:24,000 --> 00:25:26,480
you specify for desired stack pivot

660
00:25:26,480 --> 00:25:27,760
amount

661
00:25:27,760 --> 00:25:30,640
so quick and dirty method with the job

662
00:25:30,640 --> 00:25:32,559
rocket you can clear your current

663
00:25:32,559 --> 00:25:34,400
settings go into the job chain menu and

664
00:25:34,400 --> 00:25:37,039
do the g or z and it'll it does

665
00:25:37,039 --> 00:25:38,480
everything

666
00:25:38,480 --> 00:25:39,360
now

667
00:25:39,360 --> 00:25:41,200
this is not terribly realistic because

668
00:25:41,200 --> 00:25:43,760
if you know you have a 900 byte stock

669
00:25:43,760 --> 00:25:46,799
pivot enter that 900 and it'll calculate

670
00:25:46,799 --> 00:25:50,000
it precisely that's what we want you can

671
00:25:50,000 --> 00:25:52,159
also change the number of pre-built job

672
00:25:52,159 --> 00:25:53,279
chains

673
00:25:53,279 --> 00:25:55,279
per register

674
00:25:55,279 --> 00:25:57,520
so this comes from a binary that we did

675
00:25:57,520 --> 00:26:01,120
at defcon a very very elaborate binary

676
00:26:01,120 --> 00:26:03,360
and this is the result auto generated

677
00:26:03,360 --> 00:26:04,159
and

678
00:26:04,159 --> 00:26:05,760
it pretty much works so this is virtual

679
00:26:05,760 --> 00:26:06,720
outlook

680
00:26:06,720 --> 00:26:08,880
and then we have virtual protect all we

681
00:26:08,880 --> 00:26:11,120
need to do is just plug in the stuff for

682
00:26:11,120 --> 00:26:12,960
the vulnerability and then some file

683
00:26:12,960 --> 00:26:15,440
format uh issues that are not related to

684
00:26:15,440 --> 00:26:17,039
rob or job

685
00:26:17,039 --> 00:26:19,120
but the actual job itself does work so

686
00:26:19,120 --> 00:26:21,200
let's look specifically here virtual pro

687
00:26:21,200 --> 00:26:24,320
tech we start with rob

688
00:26:24,320 --> 00:26:25,760
we're going to load edx with the

689
00:26:25,760 --> 00:26:27,600
dispatcher gadget

690
00:26:27,600 --> 00:26:29,360
and then now we are going to get our

691
00:26:29,360 --> 00:26:31,279
dispatch table onto edi and then call

692
00:26:31,279 --> 00:26:32,960
the dispatcher

693
00:26:32,960 --> 00:26:35,440
we have a stack pivot of 894 another

694
00:26:35,440 --> 00:26:36,799
stack pivot

695
00:26:36,799 --> 00:26:39,200
and then we load the pointer to virtual

696
00:26:39,200 --> 00:26:42,559
protect so now we can de-reference it

697
00:26:42,559 --> 00:26:44,480
and

698
00:26:44,480 --> 00:26:45,919
then that takes us over here let's

699
00:26:45,919 --> 00:26:47,840
bundle our gadgets

700
00:26:47,840 --> 00:26:50,720
and then here are our stack parameters

701
00:26:50,720 --> 00:26:53,679
so we can customize these to whatever we

702
00:26:53,679 --> 00:26:55,440
we may need and this gives you a good

703
00:26:55,440 --> 00:26:56,640
starting point

704
00:26:56,640 --> 00:26:58,400
and then some other stuff just that are

705
00:26:58,400 --> 00:27:00,159
useful generally in terms of getting

706
00:27:00,159 --> 00:27:02,080
your uh

707
00:27:02,080 --> 00:27:03,600
getting it built so we have a little

708
00:27:03,600 --> 00:27:05,760
drop chain we have job chain

709
00:27:05,760 --> 00:27:07,279
a vp stack

710
00:27:07,279 --> 00:27:08,640
etc

711
00:27:08,640 --> 00:27:10,640
let's see this in action here this is

712
00:27:10,640 --> 00:27:12,960
exactly what we've just been looking at

713
00:27:12,960 --> 00:27:15,760
so stack pivot of 894

714
00:27:15,760 --> 00:27:17,760
we have adding c to our with our

715
00:27:17,760 --> 00:27:18,960
dispatcher

716
00:27:18,960 --> 00:27:21,520
another stock pivot of 894

717
00:27:21,520 --> 00:27:23,279
right on back to the dispatcher adding c

718
00:27:23,279 --> 00:27:25,840
to edi then dereferencing edi

719
00:27:25,840 --> 00:27:28,320
and now we're loading uh virtual protect

720
00:27:28,320 --> 00:27:32,480
into eax the pointer another dispatcher

721
00:27:32,480 --> 00:27:34,240
okay so virtual protect we see it up

722
00:27:34,240 --> 00:27:36,159
there it's about to make that call

723
00:27:36,159 --> 00:27:38,080
and over here we have look at esp we

724
00:27:38,080 --> 00:27:40,880
have our stack parameters set up and

725
00:27:40,880 --> 00:27:42,480
we got it

726
00:27:42,480 --> 00:27:45,279
in the rocket kit got our shell code

727
00:27:45,279 --> 00:27:46,880
now that's ideal

728
00:27:46,880 --> 00:27:48,880
the reality though is

729
00:27:48,880 --> 00:27:51,600
sometimes you have to tweak your job

730
00:27:51,600 --> 00:27:53,679
but at the very least job rocket

731
00:27:53,679 --> 00:27:56,159
provides an excellent starting point

732
00:27:56,159 --> 00:27:58,159
ideal requirements well of course we

733
00:27:58,159 --> 00:28:00,320
need a dispatcher gadget

734
00:28:00,320 --> 00:28:03,919
for this to work next ideally we would

735
00:28:03,919 --> 00:28:06,960
have no bad bites however uh we can

736
00:28:06,960 --> 00:28:08,880
still work with bad bites if the gadget

737
00:28:08,880 --> 00:28:12,000
addresses do not contain them or even

738
00:28:12,000 --> 00:28:13,600
still if they do

739
00:28:13,600 --> 00:28:15,520
bad bias is not the end of the world

740
00:28:15,520 --> 00:28:17,200
because we can always change the bad

741
00:28:17,200 --> 00:28:19,360
bytes to something else one way around

742
00:28:19,360 --> 00:28:22,399
them is with this method so let's say cd

743
00:28:22,399 --> 00:28:24,240
is a bad byte well let's do the

744
00:28:24,240 --> 00:28:26,960
unassembled inside job rocket and now i

745
00:28:26,960 --> 00:28:29,679
have ca

746
00:28:29,679 --> 00:28:31,679
that may not always work so a better

747
00:28:31,679 --> 00:28:34,559
approach is exclusive or so if we have

748
00:28:34,559 --> 00:28:38,399
7x or 5 well that gives us 2 and we can

749
00:28:38,399 --> 00:28:41,760
take that 2x or 5 right on back to 7

750
00:28:41,760 --> 00:28:43,840
and we have dead code indeed code and

751
00:28:43,840 --> 00:28:46,799
gives us 400 000 the image base and we

752
00:28:46,799 --> 00:28:50,480
have our null bytes over there

753
00:28:50,480 --> 00:28:51,840
job rocket also gives you the

754
00:28:51,840 --> 00:28:54,559
functionality to simply exclude bad

755
00:28:54,559 --> 00:28:57,120
bytes however i don't recommend this

756
00:28:57,120 --> 00:28:58,720
because we can always just simply

757
00:28:58,720 --> 00:29:01,360
transform the bad bites with exclusive

758
00:29:01,360 --> 00:29:02,559
ore

759
00:29:02,559 --> 00:29:03,520
so

760
00:29:03,520 --> 00:29:05,279
if there are bad bites

761
00:29:05,279 --> 00:29:07,520
you can still do the

762
00:29:07,520 --> 00:29:10,559
uh generated chain you just simply may

763
00:29:10,559 --> 00:29:13,440
supply dummy very values instead and

764
00:29:13,440 --> 00:29:15,919
then you can go and overwrite them one

765
00:29:15,919 --> 00:29:18,399
way to do that is by sniping with the

766
00:29:18,399 --> 00:29:21,600
move dereference and that is extremely

767
00:29:21,600 --> 00:29:25,279
effective with rop or job however with

768
00:29:25,279 --> 00:29:28,640
jop that gadget is relatively rare so

769
00:29:28,640 --> 00:29:30,640
another way to do that and this is

770
00:29:30,640 --> 00:29:33,919
unique only to to jop is push

771
00:29:33,919 --> 00:29:36,080
instruction which austin explained and

772
00:29:36,080 --> 00:29:40,559
this is also a technique that he created

773
00:29:40,559 --> 00:29:42,159
so let's look here at the move d

774
00:29:42,159 --> 00:29:44,399
reference we load an xor value we have

775
00:29:44,399 --> 00:29:46,240
the xor key and then we do a

776
00:29:46,240 --> 00:29:48,880
transformation we overwrite it and then

777
00:29:48,880 --> 00:29:51,279
we increment and then we can repeat as

778
00:29:51,279 --> 00:29:54,399
many as times as we need to in order to

779
00:29:54,399 --> 00:29:56,960
overwrite all of the dummy

780
00:29:56,960 --> 00:29:58,080
variables

781
00:29:58,080 --> 00:30:00,080
of course job rocket is going to deliver

782
00:30:00,080 --> 00:30:02,320
for us it'll find those move

783
00:30:02,320 --> 00:30:05,200
dereferences if they are there to be

784
00:30:05,200 --> 00:30:08,000
found if they're not remember we can

785
00:30:08,000 --> 00:30:11,039
always do the push method instead

786
00:30:11,039 --> 00:30:14,399
so with that we will pass it on over to

787
00:30:14,399 --> 00:30:16,320
austin

788
00:30:16,320 --> 00:30:18,159
so first on our list of topics here we

789
00:30:18,159 --> 00:30:19,679
have switching registers for your

790
00:30:19,679 --> 00:30:21,679
functional and dispatcher gadgets so one

791
00:30:21,679 --> 00:30:23,440
reason we might want to switch registers

792
00:30:23,440 --> 00:30:25,200
for your dispatch gadget

793
00:30:25,200 --> 00:30:28,000
is because um if we have our gadgets

794
00:30:28,000 --> 00:30:30,159
ending in jump edx with the edx storing

795
00:30:30,159 --> 00:30:32,399
our dispatcher gadget but we have

796
00:30:32,399 --> 00:30:34,320
another gadget which we may want to use

797
00:30:34,320 --> 00:30:37,120
that ends in a jump ebx that ebx gadget

798
00:30:37,120 --> 00:30:39,360
is off limits currently because ebx will

799
00:30:39,360 --> 00:30:40,799
not bring us back around to our

800
00:30:40,799 --> 00:30:43,039
dispatcher gadget so in order to fix

801
00:30:43,039 --> 00:30:45,840
this we can perform a pop ebx popping

802
00:30:45,840 --> 00:30:47,520
that dispatcher gadget's address into

803
00:30:47,520 --> 00:30:49,919
evx and now once we perform jump ebx we

804
00:30:49,919 --> 00:30:51,919
will return to our dispatcher gadget

805
00:30:51,919 --> 00:30:54,480
allowing us to use that um that

806
00:30:54,480 --> 00:30:57,039
previously unavailable gadget

807
00:30:57,039 --> 00:30:59,039
in a similar vein when we pop a

808
00:30:59,039 --> 00:31:01,440
dispatcher gadget into ebx we can also

809
00:31:01,440 --> 00:31:04,640
switch dispatcher gadgets entirely so

810
00:31:04,640 --> 00:31:06,799
the reason to do this if we look in our

811
00:31:06,799 --> 00:31:09,279
gadget in the top right we have add edi

812
00:31:09,279 --> 00:31:12,000
8 jump viewer pointer edi so edi is

813
00:31:12,000 --> 00:31:13,519
being reserved currently for our

814
00:31:13,519 --> 00:31:15,360
dispatch table

815
00:31:15,360 --> 00:31:16,960
with our new dispatcher gadget we're

816
00:31:16,960 --> 00:31:19,919
using ebp for our dispatch table instead

817
00:31:19,919 --> 00:31:21,440
so now we can use gadgets that will

818
00:31:21,440 --> 00:31:23,200
modify edi without

819
00:31:23,200 --> 00:31:25,200
ruining our control flow so here at the

820
00:31:25,200 --> 00:31:27,440
bottom we have our example where we pop

821
00:31:27,440 --> 00:31:30,080
ebx with an alternate dispatcher gadget

822
00:31:30,080 --> 00:31:32,080
and then we can do our add edi gadget

823
00:31:32,080 --> 00:31:34,240
without ruining our control flow

824
00:31:34,240 --> 00:31:35,679
i'm switching gears here we're going to

825
00:31:35,679 --> 00:31:37,360
talk about microsoft's control flow

826
00:31:37,360 --> 00:31:39,679
guard which is a coarse grained cfi

827
00:31:39,679 --> 00:31:41,440
implementation which inserts check

828
00:31:41,440 --> 00:31:43,120
functions before indirect jumps and

829
00:31:43,120 --> 00:31:45,120
calls um this is going to attempt to

830
00:31:45,120 --> 00:31:48,159
thwart exploits similar to drop

831
00:31:48,159 --> 00:31:49,679
we do have some techniques to avoid

832
00:31:49,679 --> 00:31:51,919
control flow guard one such technique is

833
00:31:51,919 --> 00:31:53,760
op code splitting so for an example of

834
00:31:53,760 --> 00:31:56,159
that at the bottom here we can see our

835
00:31:56,159 --> 00:31:57,760
first instruction starts with the op

836
00:31:57,760 --> 00:32:01,120
codes bf89 however if we strip off that

837
00:32:01,120 --> 00:32:02,960
bf op code we get a different

838
00:32:02,960 --> 00:32:04,640
instruction which is actually a job

839
00:32:04,640 --> 00:32:07,120
gadget and this is an instance of an

840
00:32:07,120 --> 00:32:08,880
unintended instruction however it's

841
00:32:08,880 --> 00:32:10,159
still valid in

842
00:32:10,159 --> 00:32:12,480
x86 assembly and we can use this as a

843
00:32:12,480 --> 00:32:14,799
job function as a job gadget

844
00:32:14,799 --> 00:32:17,039
without um worrying about control flow

845
00:32:17,039 --> 00:32:19,200
guard

846
00:32:19,200 --> 00:32:20,880
we have some other ways to avoid control

847
00:32:20,880 --> 00:32:22,640
flow guards so

848
00:32:22,640 --> 00:32:24,480
indirect calls occurring during inline

849
00:32:24,480 --> 00:32:25,919
assembly are not going to have that

850
00:32:25,919 --> 00:32:28,000
check function inserted before of them

851
00:32:28,000 --> 00:32:29,279
before them

852
00:32:29,279 --> 00:32:31,760
we can also avoid cfg by using gadgets

853
00:32:31,760 --> 00:32:34,480
found in dlls which don't have that cfg

854
00:32:34,480 --> 00:32:37,120
protection enabled and windows 7 doesn't

855
00:32:37,120 --> 00:32:39,200
support cfg either so when running

856
00:32:39,200 --> 00:32:41,279
exploits on windows 7 we don't have to

857
00:32:41,279 --> 00:32:43,840
worry about that

858
00:32:43,919 --> 00:32:45,440
the job rocket will allow us to

859
00:32:45,440 --> 00:32:47,200
enumerate whether or not modules have

860
00:32:47,200 --> 00:32:49,679
cfg enabled and we can also filter out

861
00:32:49,679 --> 00:32:51,679
gadgets from

862
00:32:51,679 --> 00:32:54,480
cfg enabled modules however i don't

863
00:32:54,480 --> 00:32:56,000
recommend that you filter out those

864
00:32:56,000 --> 00:32:58,559
gadgets because many job gadgets can

865
00:32:58,559 --> 00:33:00,559
occur from unintended instructions via

866
00:33:00,559 --> 00:33:02,080
opcode splitting like we were talking

867
00:33:02,080 --> 00:33:04,399
before and as long as you don't execute

868
00:33:04,399 --> 00:33:06,799
the guard check function we

869
00:33:06,799 --> 00:33:10,080
can use our job gadget

870
00:33:10,080 --> 00:33:11,360
at this point i'm going to pass the

871
00:33:11,360 --> 00:33:13,279
presentation back on over to bramwell

872
00:33:13,279 --> 00:33:14,559
for one last time

873
00:33:14,559 --> 00:33:17,200
thank you austin our next technique is

874
00:33:17,200 --> 00:33:21,600
bypassing aslr with jop and let me level

875
00:33:21,600 --> 00:33:23,919
with you it's no different than doing it

876
00:33:23,919 --> 00:33:25,840
with rob so imagine that you have a

877
00:33:25,840 --> 00:33:28,480
memory disclosure with a uaf

878
00:33:28,480 --> 00:33:31,360
you have an integer budget it's part of

879
00:33:31,360 --> 00:33:34,480
a structure it displays the budget

880
00:33:34,480 --> 00:33:36,960
you free the structure and then you go

881
00:33:36,960 --> 00:33:39,679
and try to display the budget again this

882
00:33:39,679 --> 00:33:41,760
is called a use after free you're using

883
00:33:41,760 --> 00:33:43,679
it after it has been freed and it's

884
00:33:43,679 --> 00:33:46,399
going to display nonsense

885
00:33:46,399 --> 00:33:49,679
nothing useful well we can instead go

886
00:33:49,679 --> 00:33:52,640
and overwrite that allocation with a

887
00:33:52,640 --> 00:33:53,919
similarly

888
00:33:53,919 --> 00:33:56,399
similarly sized structure

889
00:33:56,399 --> 00:33:59,440
and instead of an integer at the first

890
00:33:59,440 --> 00:34:02,720
offset well maybe we'll have a function

891
00:34:02,720 --> 00:34:03,760
address

892
00:34:03,760 --> 00:34:05,200
and thus

893
00:34:05,200 --> 00:34:06,720
instead of displaying

894
00:34:06,720 --> 00:34:09,679
a random integer or nonsense we are

895
00:34:09,679 --> 00:34:13,520
leaking a function pointer and from that

896
00:34:13,520 --> 00:34:15,918
we can go and extrapolate the base

897
00:34:15,918 --> 00:34:21,359
address of the dll and this is the aslr

898
00:34:21,359 --> 00:34:24,639
bypass that we want if you do this you

899
00:34:24,639 --> 00:34:25,760
bypass

900
00:34:25,760 --> 00:34:28,560
aslr

901
00:34:28,639 --> 00:34:30,960
another technique that we can use is

902
00:34:30,960 --> 00:34:34,800
using jop is rob so if you're doing

903
00:34:34,800 --> 00:34:36,480
return oriented programming and you

904
00:34:36,480 --> 00:34:39,760
can't find the right rob gadget that you

905
00:34:39,760 --> 00:34:42,239
want one thing that you can do is

906
00:34:42,239 --> 00:34:45,440
briefly transition to job

907
00:34:45,440 --> 00:34:48,079
if you can find the equivalent job

908
00:34:48,079 --> 00:34:51,280
gadget that you want how you do that is

909
00:34:51,280 --> 00:34:54,239
you go and load a return instruction and

910
00:34:54,239 --> 00:34:57,920
that's it just threat load that into

911
00:34:57,920 --> 00:35:00,720
a register and then when you go and jump

912
00:35:00,720 --> 00:35:04,560
to the register it is then equivalent to

913
00:35:04,560 --> 00:35:07,119
a rob gadget and you don't need to mess

914
00:35:07,119 --> 00:35:10,079
around with a dispatcher gadget or a

915
00:35:10,079 --> 00:35:12,640
dispatch table you can just briefly do

916
00:35:12,640 --> 00:35:16,720
job and then return to your other rob

917
00:35:16,720 --> 00:35:18,880
now one recent innovation that we

918
00:35:18,880 --> 00:35:22,720
provided is expanding the definition of

919
00:35:22,720 --> 00:35:25,760
what constitutes a dispatcher gadget

920
00:35:25,760 --> 00:35:27,599
with rob you just assume you look for

921
00:35:27,599 --> 00:35:28,320
the

922
00:35:28,320 --> 00:35:32,560
the c3 op code and disassemble backwards

923
00:35:32,560 --> 00:35:35,040
so we do the same thing with job looking

924
00:35:35,040 --> 00:35:38,000
for particular offsets but we found that

925
00:35:38,000 --> 00:35:39,440
we're missing

926
00:35:39,440 --> 00:35:41,920
the offs the op codes for if you do a

927
00:35:41,920 --> 00:35:44,160
jump d word pointer plus or minus an

928
00:35:44,160 --> 00:35:46,480
offset because this is a valid way to do

929
00:35:46,480 --> 00:35:49,520
it so we've added those op codes and

930
00:35:49,520 --> 00:35:51,760
we've added this and other alternative

931
00:35:51,760 --> 00:35:54,320
forms of the dispatcher gadget that you

932
00:35:54,320 --> 00:35:57,440
can also read about in the white paper

933
00:35:57,440 --> 00:35:59,520
you know aslr in depth they're strong

934
00:35:59,520 --> 00:36:02,160
mitigations but we can overcome them

935
00:36:02,160 --> 00:36:05,200
with job just the same as we can with

936
00:36:05,200 --> 00:36:08,400
roth the only challenge is that with jop

937
00:36:08,400 --> 00:36:11,440
the gadgets are a lot less plentiful

938
00:36:11,440 --> 00:36:13,599
so that could be a possible

939
00:36:13,599 --> 00:36:16,000
consideration if there are not enough

940
00:36:16,000 --> 00:36:17,599
gadgets

941
00:36:17,599 --> 00:36:20,079
some final takeaways if you can find a

942
00:36:20,079 --> 00:36:23,359
dispatcher gadget don't be afraid to try

943
00:36:23,359 --> 00:36:26,880
job it may actually even be easier

944
00:36:26,880 --> 00:36:29,680
and if you are doing just exclusively

945
00:36:29,680 --> 00:36:32,880
wrap but you need a specific gadget well

946
00:36:32,880 --> 00:36:35,520
you can briefly transition to jop

947
00:36:35,520 --> 00:36:36,400
and

948
00:36:36,400 --> 00:36:39,440
expand your tax surface

949
00:36:39,440 --> 00:36:41,839
if you want to try the pure job style we

950
00:36:41,839 --> 00:36:43,680
have a couple binaries you can try we

951
00:36:43,680 --> 00:36:45,839
have an easier and a slightly harder and

952
00:36:45,839 --> 00:36:48,079
you can find those at the github or

953
00:36:48,079 --> 00:36:49,760
jobrocket.com

954
00:36:49,760 --> 00:36:52,240
and with that we welcome any and all

955
00:36:52,240 --> 00:36:55,240
questions

