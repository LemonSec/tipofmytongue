1
00:00:02,800 --> 00:00:04,640
hello everyone so thank you for

2
00:00:04,640 --> 00:00:06,080
attending to this talk

3
00:00:06,080 --> 00:00:08,240
i'm roman thomas i'm security engineer

4
00:00:08,240 --> 00:00:09,760
at quartz lab

5
00:00:09,760 --> 00:00:11,759
where i'm in the team that performs

6
00:00:11,759 --> 00:00:13,280
security assessment but

7
00:00:13,280 --> 00:00:15,519
also develop tools to automate the

8
00:00:15,519 --> 00:00:17,279
reverse engineering process

9
00:00:17,279 --> 00:00:20,240
and among this tool we develop triton

10
00:00:20,240 --> 00:00:22,800
which is a symbolic execution framework

11
00:00:22,800 --> 00:00:25,760
we also developed leaf which enabled to

12
00:00:25,760 --> 00:00:28,560
modify executable formats short as elf

13
00:00:28,560 --> 00:00:31,840
or pe and we develop qbdi

14
00:00:31,840 --> 00:00:33,520
which is a dynamic instrumentation

15
00:00:33,520 --> 00:00:35,760
framework that will be discussed

16
00:00:35,760 --> 00:00:38,879
in this presentation so this talk

17
00:00:38,879 --> 00:00:42,239
is about android obfuscation and how

18
00:00:42,239 --> 00:00:45,520
we can analyze obfuscation using dynamic

19
00:00:45,520 --> 00:00:46,480
instrumentation

20
00:00:46,480 --> 00:00:49,680
framework so obfuscation is a way to

21
00:00:49,680 --> 00:00:50,239
protect

22
00:00:50,239 --> 00:00:52,480
application asset against reverse

23
00:00:52,480 --> 00:00:53,440
engineering

24
00:00:53,440 --> 00:00:57,199
by making analyzing more difficult or at

25
00:00:57,199 --> 00:00:57,600
least

26
00:00:57,600 --> 00:01:00,879
very time consuming and obfuscation

27
00:01:00,879 --> 00:01:03,920
can protect different kind of asset so

28
00:01:03,920 --> 00:01:07,439
it can be like a function that don't

29
00:01:07,439 --> 00:01:10,560
that we don't want to be reversed it can

30
00:01:10,560 --> 00:01:11,360
be

31
00:01:11,360 --> 00:01:14,560
a file that we don't want to to extract

32
00:01:14,560 --> 00:01:16,000
from the application

33
00:01:16,000 --> 00:01:18,960
or it could be a secret such as a token

34
00:01:18,960 --> 00:01:19,360
or

35
00:01:19,360 --> 00:01:23,119
a password so to protect and to make

36
00:01:23,119 --> 00:01:24,320
obfuscation

37
00:01:24,320 --> 00:01:26,880
there are different solutions for their

38
00:01:26,880 --> 00:01:28,080
commercial one

39
00:01:28,080 --> 00:01:31,680
with arksan clockwear or apona

40
00:01:31,680 --> 00:01:34,720
some app developers also use

41
00:01:34,720 --> 00:01:37,280
in-house obfuscator which is the case

42
00:01:37,280 --> 00:01:38,799
for snapchat

43
00:01:38,799 --> 00:01:42,000
or talk and there are some open source

44
00:01:42,000 --> 00:01:47,280
projects such as old vm or egyi

45
00:01:47,600 --> 00:01:50,240
so this topic is not new and there are a

46
00:01:50,240 --> 00:01:51,840
lot of

47
00:01:51,840 --> 00:01:55,119
presentation and paper about this topic

48
00:01:55,119 --> 00:01:59,360
especially in 2014 two former colleagues

49
00:01:59,360 --> 00:02:02,000
of quarkxlab presented some work on

50
00:02:02,000 --> 00:02:02,719
attacking

51
00:02:02,719 --> 00:02:06,320
white box with using auxiliary attacks

52
00:02:06,320 --> 00:02:07,360
so it will

53
00:02:07,360 --> 00:02:10,318
basically using dynamic truss and they

54
00:02:10,318 --> 00:02:12,239
show how they manage to

55
00:02:12,239 --> 00:02:15,120
to break the white box using dynamic

56
00:02:15,120 --> 00:02:16,000
truss

57
00:02:16,000 --> 00:02:19,680
generated by intel pin

58
00:02:20,080 --> 00:02:23,200
in 2016 uh charles hermann and philip

59
00:02:23,200 --> 00:02:24,160
tohen

60
00:02:24,160 --> 00:02:26,640
presented some work also on attacking

61
00:02:26,640 --> 00:02:28,160
white box using

62
00:02:28,160 --> 00:02:30,959
dynamic truss and they show how we can

63
00:02:30,959 --> 00:02:31,599
use

64
00:02:31,599 --> 00:02:34,640
side channel attack with this truss on

65
00:02:34,640 --> 00:02:36,879
the white box to recover

66
00:02:36,879 --> 00:02:40,480
the cryptographic key and last year

67
00:02:40,480 --> 00:02:42,560
there were presentations

68
00:02:42,560 --> 00:02:44,959
on reverse and learning c plus plus code

69
00:02:44,959 --> 00:02:45,680
and how

70
00:02:45,680 --> 00:02:48,000
we can use dynamic information to

71
00:02:48,000 --> 00:02:49,200
recover

72
00:02:49,200 --> 00:02:52,400
internal structure of internal field of

73
00:02:52,400 --> 00:02:56,879
cyprus per structure from this research

74
00:02:56,879 --> 00:03:00,159
we can see that basically a dbi is

75
00:03:00,159 --> 00:03:02,800
suitable to address obfuscation because

76
00:03:02,800 --> 00:03:04,080
it provides dynamic

77
00:03:04,080 --> 00:03:07,440
information and at some how dynamic

78
00:03:07,440 --> 00:03:08,480
information

79
00:03:08,480 --> 00:03:12,400
can't lie and we'll see how

80
00:03:12,400 --> 00:03:17,840
so a dbi is a way to analyze a program

81
00:03:17,840 --> 00:03:20,400
at different level so you can analyze

82
00:03:20,400 --> 00:03:21,280
the program at

83
00:03:21,280 --> 00:03:23,200
instruction level so for instance you

84
00:03:23,200 --> 00:03:25,120
can access to all the instructions that

85
00:03:25,120 --> 00:03:26,400
are executed

86
00:03:26,400 --> 00:03:29,920
for for one execution path

87
00:03:29,920 --> 00:03:33,200
you can also access to register value

88
00:03:33,200 --> 00:03:35,760
you may also access to the basic blocks

89
00:03:35,760 --> 00:03:37,120
that are executed

90
00:03:37,120 --> 00:03:40,400
so you have different level of analysis

91
00:03:40,400 --> 00:03:44,480
over the program and while a debugger

92
00:03:44,480 --> 00:03:46,080
will insert breakpoint

93
00:03:46,080 --> 00:03:48,959
before each instruction to to have

94
00:03:48,959 --> 00:03:51,200
access to the underlying insertion

95
00:03:51,200 --> 00:03:54,080
a dbi will modify the assembly code and

96
00:03:54,080 --> 00:03:54,400
will

97
00:03:54,400 --> 00:03:56,560
execute the modify version of the

98
00:03:56,560 --> 00:03:57,439
assembly code

99
00:03:57,439 --> 00:04:00,720
so in terms of performances you are more

100
00:04:00,720 --> 00:04:02,560
efficient with the dbi than

101
00:04:02,560 --> 00:04:06,239
with the debugger and if you want to

102
00:04:06,239 --> 00:04:08,000
analyze for instance a lot a lot of

103
00:04:08,000 --> 00:04:10,159
instruction you may pay a very huge

104
00:04:10,159 --> 00:04:11,519
overhead with a db

105
00:04:11,519 --> 00:04:14,560
debugger while with a dbi it can be like

106
00:04:14,560 --> 00:04:17,120
very quick

107
00:04:17,120 --> 00:04:20,238
so there are different framework to that

108
00:04:20,238 --> 00:04:22,479
the first one is intel pin which is

109
00:04:22,479 --> 00:04:24,400
quite well known now

110
00:04:24,400 --> 00:04:29,759
and it works very well on x86 and 886.64

111
00:04:29,759 --> 00:04:33,680
you may also heard about valgrain

112
00:04:33,680 --> 00:04:37,280
which enabled to instrument code on

113
00:04:37,280 --> 00:04:40,880
the 4 architecture but i would say that

114
00:04:40,880 --> 00:04:43,199
the api is not very convenient if you

115
00:04:43,199 --> 00:04:44,880
want to select for instance

116
00:04:44,880 --> 00:04:47,360
a specific part of the program that you

117
00:04:47,360 --> 00:04:48,320
want to

118
00:04:48,320 --> 00:04:51,840
instrument there are also dina mario and

119
00:04:51,840 --> 00:04:55,280
din ins which i don't know if they

120
00:04:55,280 --> 00:04:57,919
really support liam and lm64 or at least

121
00:04:57,919 --> 00:04:59,840
the api is very uh is not

122
00:04:59,840 --> 00:05:03,360
the support is not very full and um

123
00:05:03,360 --> 00:05:06,400
we have frida which uh also enabled to

124
00:05:06,400 --> 00:05:06,880
trust

125
00:05:06,880 --> 00:05:10,560
instruction for the floor architecture

126
00:05:10,560 --> 00:05:13,600
and you can trust instruction with freda

127
00:05:13,600 --> 00:05:16,800
thanks to the stalker

128
00:05:17,039 --> 00:05:20,000
and we develop also qbdi and we'll see

129
00:05:20,000 --> 00:05:21,039
how qbi

130
00:05:21,039 --> 00:05:24,000
address different functionality from the

131
00:05:24,000 --> 00:05:25,919
previous framework that

132
00:05:25,919 --> 00:05:29,280
we mentioned so a bit of

133
00:05:29,280 --> 00:05:31,600
history of kubernetes though the project

134
00:05:31,600 --> 00:05:32,320
started

135
00:05:32,320 --> 00:05:35,840
in 2015 by charles hubbard and cedric

136
00:05:35,840 --> 00:05:37,680
tracy tessier

137
00:05:37,680 --> 00:05:41,120
in 2017 i presented the

138
00:05:41,120 --> 00:05:44,560
to the project at ccc

139
00:05:44,560 --> 00:05:48,960
and in 2019 i added the support for liam

140
00:05:48,960 --> 00:05:49,199
and

141
00:05:49,199 --> 00:05:53,039
liam 60 frauds and in the next few

142
00:05:53,039 --> 00:05:54,320
months

143
00:05:54,320 --> 00:05:56,639
paul one of my colleagues presented some

144
00:05:56,639 --> 00:05:57,600
work on

145
00:05:57,600 --> 00:06:01,120
using qbi to perform fuzzing with

146
00:06:01,120 --> 00:06:04,880
umphres in 2020 we started to

147
00:06:04,880 --> 00:06:07,840
integrate some tool with qbdi such as

148
00:06:07,840 --> 00:06:08,479
frida

149
00:06:08,479 --> 00:06:11,680
or binary ninja

150
00:06:12,240 --> 00:06:15,120
so qpdi were created by charles hubbard

151
00:06:15,120 --> 00:06:15,919
and cedric

152
00:06:15,919 --> 00:06:18,560
tessier which are two reverse engineers

153
00:06:18,560 --> 00:06:20,080
with a strong background in

154
00:06:20,080 --> 00:06:23,039
obfuscation especially charles hubbard

155
00:06:23,039 --> 00:06:25,039
was one of the quarter of

156
00:06:25,039 --> 00:06:28,160
the paper about attacking whitebox this

157
00:06:28,160 --> 00:06:28,479
is

158
00:06:28,479 --> 00:06:30,720
why there are some functionality in

159
00:06:30,720 --> 00:06:32,560
qbdi's that

160
00:06:32,560 --> 00:06:35,440
that aim to target this kind of

161
00:06:35,440 --> 00:06:36,319
protection

162
00:06:36,319 --> 00:06:40,400
and we'll see this functionality

163
00:06:40,400 --> 00:06:43,600
the the tool is based on llvm

164
00:06:43,600 --> 00:06:46,160
for llvm where is very very handy

165
00:06:46,160 --> 00:06:46,960
because you have

166
00:06:46,960 --> 00:06:49,039
a disassembler you have also an

167
00:06:49,039 --> 00:06:50,800
assembler and you have an

168
00:06:50,800 --> 00:06:54,160
interface through llvmc inst

169
00:06:54,160 --> 00:06:57,280
over the instruction regardless

170
00:06:57,280 --> 00:06:59,280
the architecture so it means that you

171
00:06:59,280 --> 00:07:01,360
can access to the semantic of an

172
00:07:01,360 --> 00:07:04,639
instruction thanks to the abstract layer

173
00:07:04,639 --> 00:07:05,199
so

174
00:07:05,199 --> 00:07:09,120
for instance if you want to perform some

175
00:07:09,120 --> 00:07:12,639
i would say modification on a call

176
00:07:12,639 --> 00:07:15,759
you can just query the mpins interface

177
00:07:15,759 --> 00:07:18,880
and there you will have some information

178
00:07:18,880 --> 00:07:22,800
independently from the architecture

179
00:07:22,800 --> 00:07:25,960
so the public version supports x86 and

180
00:07:25,960 --> 00:07:27,280
x8664

181
00:07:27,280 --> 00:07:30,720
in the private branch we have the ram

182
00:07:30,720 --> 00:07:33,759
and the rm64 support you may

183
00:07:33,759 --> 00:07:36,800
also find some piece of code about

184
00:07:36,800 --> 00:07:39,599
lm support in the public branch so it

185
00:07:39,599 --> 00:07:40,080
works

186
00:07:40,080 --> 00:07:42,720
quite well for non-thumb instruction but

187
00:07:42,720 --> 00:07:45,280
for firm and thumb too it can be like

188
00:07:45,280 --> 00:07:48,240
tricky to work also the project is

189
00:07:48,240 --> 00:07:49,360
available on

190
00:07:49,360 --> 00:07:51,199
guide top so feel free to check it if

191
00:07:51,199 --> 00:07:54,240
you are interested in

192
00:07:54,319 --> 00:07:57,039
so let's consider this piece of code for

193
00:07:57,039 --> 00:07:58,879
here you have a basic block that you

194
00:07:58,879 --> 00:07:59,680
want

195
00:07:59,680 --> 00:08:03,280
to analyze so with qbdi we will set up

196
00:08:03,280 --> 00:08:05,520
some callback before

197
00:08:05,520 --> 00:08:08,319
before all the instructions by using the

198
00:08:08,319 --> 00:08:09,039
add

199
00:08:09,039 --> 00:08:12,560
callback method doing so will set up

200
00:08:12,560 --> 00:08:15,599
some callbacks that will process

201
00:08:15,599 --> 00:08:17,520
the instruction and for instance you can

202
00:08:17,520 --> 00:08:19,919
analyze the register within

203
00:08:19,919 --> 00:08:23,599
this callback and from a logical point

204
00:08:23,599 --> 00:08:24,240
of view

205
00:08:24,240 --> 00:08:27,360
it gives you this figure so here is the

206
00:08:27,360 --> 00:08:29,199
original code and here you have your

207
00:08:29,199 --> 00:08:31,199
callback in which you can

208
00:08:31,199 --> 00:08:33,599
read the register modify the register

209
00:08:33,599 --> 00:08:34,799
skip the instruction

210
00:08:34,799 --> 00:08:39,039
and so on but obfuscator

211
00:08:39,039 --> 00:08:41,760
are likely to add noisy instruction so

212
00:08:41,760 --> 00:08:42,719
for instance

213
00:08:42,719 --> 00:08:46,080
if they are doing some computation

214
00:08:46,080 --> 00:08:48,240
that are not in the original code it

215
00:08:48,240 --> 00:08:49,680
will add a lot of

216
00:08:49,680 --> 00:08:51,040
instructions that are not really

217
00:08:51,040 --> 00:08:52,839
relevant to understand the function

218
00:08:52,839 --> 00:08:55,839
logic also if you try to instrument

219
00:08:55,839 --> 00:08:58,480
all the instruction you can pay a very

220
00:08:58,480 --> 00:08:59,680
huge overhead

221
00:08:59,680 --> 00:09:02,959
because um if the skater add

222
00:09:02,959 --> 00:09:04,800
new instructions so it means that you

223
00:09:04,800 --> 00:09:06,800
will have to instrument and to switch

224
00:09:06,800 --> 00:09:07,519
between

225
00:09:07,519 --> 00:09:10,399
the original code and your callback a

226
00:09:10,399 --> 00:09:12,000
lot of time

227
00:09:12,000 --> 00:09:15,120
so we need to be a bit smart if you want

228
00:09:15,120 --> 00:09:16,240
to scale

229
00:09:16,240 --> 00:09:19,839
with a dbi so this is why there is some

230
00:09:19,839 --> 00:09:22,399
functionality in qdis that enable to

231
00:09:22,399 --> 00:09:23,200
select

232
00:09:23,200 --> 00:09:26,560
a subset of instruction to instrument

233
00:09:26,560 --> 00:09:29,120
so for instance you can say i'm only

234
00:09:29,120 --> 00:09:29,839
interested

235
00:09:29,839 --> 00:09:32,880
in instrumenting branching section or

236
00:09:32,880 --> 00:09:33,200
i'm

237
00:09:33,200 --> 00:09:36,160
only interested in instrumenting memory

238
00:09:36,160 --> 00:09:37,200
access instruction

239
00:09:37,200 --> 00:09:40,880
or cisco and so on and doing so

240
00:09:40,880 --> 00:09:44,080
so with this api you can say okay so

241
00:09:44,080 --> 00:09:46,160
let's set up a callback on the syscall

242
00:09:46,160 --> 00:09:48,080
let's set up a callback on the call

243
00:09:48,080 --> 00:09:48,880
instruction

244
00:09:48,880 --> 00:09:51,680
and let's set up a callback on memory

245
00:09:51,680 --> 00:09:52,160
read

246
00:09:52,160 --> 00:09:54,480
or write access you can also select

247
00:09:54,480 --> 00:09:56,880
memory read if you are if you want or

248
00:09:56,880 --> 00:09:58,399
memory write

249
00:09:58,399 --> 00:10:01,839
and then you will only have callback

250
00:10:01,839 --> 00:10:04,079
before the instruction you select

251
00:10:04,079 --> 00:10:06,000
through the api

252
00:10:06,000 --> 00:10:08,480
and you don't pay for the overhead for

253
00:10:08,480 --> 00:10:11,600
the other instruction

254
00:10:12,320 --> 00:10:14,560
in addition qbi have interesting

255
00:10:14,560 --> 00:10:17,200
functionality that enable to resolve

256
00:10:17,200 --> 00:10:20,079
the effective memory address of

257
00:10:20,079 --> 00:10:21,120
instruction

258
00:10:21,120 --> 00:10:24,160
so for instance if you have a load

259
00:10:24,160 --> 00:10:27,360
r0 from r5 you have an

260
00:10:27,360 --> 00:10:31,839
api to automatically know the value of

261
00:10:31,839 --> 00:10:35,200
but if you have for instance l1

262
00:10:35,200 --> 00:10:38,240
and r6 it will automatically compute

263
00:10:38,240 --> 00:10:42,079
the value of l1 plus r6 and this is done

264
00:10:42,079 --> 00:10:44,480
in the you know in the api so you have

265
00:10:44,480 --> 00:10:45,680
an abstraction

266
00:10:45,680 --> 00:10:48,320
over this computation especially if you

267
00:10:48,320 --> 00:10:50,320
are for instance this kind of memory

268
00:10:50,320 --> 00:10:51,040
access

269
00:10:51,040 --> 00:10:54,000
it can be like quite tricky to compute

270
00:10:54,000 --> 00:10:55,519
so here you just

271
00:10:55,519 --> 00:10:58,160
have to access to the access address

272
00:10:58,160 --> 00:11:00,640
attribute of the memory access structure

273
00:11:00,640 --> 00:11:03,760
and you get the computation for free

274
00:11:03,760 --> 00:11:05,680
you can also access to the effective

275
00:11:05,680 --> 00:11:08,000
value that is read or written

276
00:11:08,000 --> 00:11:10,480
through the value attribute so here for

277
00:11:10,480 --> 00:11:12,160
instance you get the value of

278
00:11:12,160 --> 00:11:16,240
r2 and you get the value of lvo plus

279
00:11:16,240 --> 00:11:18,800
1 8.

280
00:11:19,680 --> 00:11:21,760
we have the same mechanism for branch

281
00:11:21,760 --> 00:11:23,680
instruction for blx

282
00:11:23,680 --> 00:11:29,200
bl for lim or bl and blr for lm64

283
00:11:29,200 --> 00:11:31,360
and basically if for instance you want

284
00:11:31,360 --> 00:11:32,640
to know the value of

285
00:11:32,640 --> 00:11:35,760
r2 associated with this branch

286
00:11:35,760 --> 00:11:38,480
you can just access to this value

287
00:11:38,480 --> 00:11:39,440
through the

288
00:11:39,440 --> 00:11:43,120
inschool access and back and then here

289
00:11:43,120 --> 00:11:44,240
you have the effective value

290
00:11:44,240 --> 00:11:47,000
this is quite i would say simple for

291
00:11:47,000 --> 00:11:48,560
lm64 but for

292
00:11:48,560 --> 00:11:51,279
llm you have some tricky computation

293
00:11:51,279 --> 00:11:52,079
because of

294
00:11:52,079 --> 00:11:55,680
the thumb mode and some alignment

295
00:11:55,680 --> 00:11:58,959
computation so here for instance for

296
00:11:58,959 --> 00:12:01,279
lim instruction it will automatically

297
00:12:01,279 --> 00:12:02,560
compute

298
00:12:02,560 --> 00:12:06,000
the value with the thumb

299
00:12:06,000 --> 00:12:10,240
bit also another issue and

300
00:12:10,240 --> 00:12:13,519
another problem with dbi is how you

301
00:12:13,519 --> 00:12:14,800
manage to trust

302
00:12:14,800 --> 00:12:17,519
malloc or how you emblem malloc and

303
00:12:17,519 --> 00:12:19,120
external function

304
00:12:19,120 --> 00:12:23,200
when you trust code so one of the issue

305
00:12:23,200 --> 00:12:25,920
with malloc for instance is that

306
00:12:25,920 --> 00:12:28,560
malloc may share some global variable

307
00:12:28,560 --> 00:12:29,440
with

308
00:12:29,440 --> 00:12:32,399
qpdi so qbi use malloc so if your code

309
00:12:32,399 --> 00:12:33,279
that you trust

310
00:12:33,279 --> 00:12:35,920
use malloc and that malloc is trust by

311
00:12:35,920 --> 00:12:36,800
qbi

312
00:12:36,800 --> 00:12:40,079
you have like you can have an issue

313
00:12:40,079 --> 00:12:43,120
and intel pin for instance choose to

314
00:12:43,120 --> 00:12:45,600
provide their own implementation of

315
00:12:45,600 --> 00:12:47,839
malloc printf and phone so that there is

316
00:12:47,839 --> 00:12:50,000
no conflict between qpdi

317
00:12:50,000 --> 00:12:53,200
within the dbi sorry and the instrument

318
00:12:53,200 --> 00:12:54,079
it's got

319
00:12:54,079 --> 00:12:57,120
also in android application

320
00:12:57,120 --> 00:13:00,240
you can have ac you can have a function

321
00:13:00,240 --> 00:13:02,959
that use gni which are basically

322
00:13:02,959 --> 00:13:05,279
functions that makes a bridge between

323
00:13:05,279 --> 00:13:08,639
native code and java code and you don't

324
00:13:08,639 --> 00:13:10,880
want necessarily to trust distinction

325
00:13:10,880 --> 00:13:12,800
because you know the behavior of malloc

326
00:13:12,800 --> 00:13:15,120
madok is allocating a buffer so

327
00:13:15,120 --> 00:13:18,240
you you don't want necessarily to trust

328
00:13:18,240 --> 00:13:21,440
this in these functions

329
00:13:21,440 --> 00:13:24,480
so there is a way in qbdi to process

330
00:13:24,480 --> 00:13:25,360
this function

331
00:13:25,360 --> 00:13:27,760
by stopping the instrumentation process

332
00:13:27,760 --> 00:13:28,800
when there is

333
00:13:28,800 --> 00:13:31,920
an external call then we leave the

334
00:13:31,920 --> 00:13:32,639
function

335
00:13:32,639 --> 00:13:35,600
to execute their own code without

336
00:13:35,600 --> 00:13:36,480
instrumentation

337
00:13:36,480 --> 00:13:39,839
so we are quite blunt about what the

338
00:13:39,839 --> 00:13:41,120
code is executed but

339
00:13:41,120 --> 00:13:43,120
as we know that is malloc we know the

340
00:13:43,120 --> 00:13:44,720
behavior of malloc

341
00:13:44,720 --> 00:13:48,240
and qbi also changed the return value of

342
00:13:48,240 --> 00:13:50,720
the return address of the function so

343
00:13:50,720 --> 00:13:52,240
that we can catch

344
00:13:52,240 --> 00:13:56,399
when the function returns

345
00:13:56,639 --> 00:13:59,040
so this diagram summarizes a bit of the

346
00:13:59,040 --> 00:13:59,920
process

347
00:13:59,920 --> 00:14:02,959
when there is an external call so here

348
00:14:02,959 --> 00:14:05,360
at some point in the instrumented code

349
00:14:05,360 --> 00:14:07,040
we have a branch

350
00:14:07,040 --> 00:14:10,880
to malloc so here qbi is able to detect

351
00:14:10,880 --> 00:14:11,440
that

352
00:14:11,440 --> 00:14:15,279
the absolute address of the branch

353
00:14:15,279 --> 00:14:18,160
is not in the part of the instrumentated

354
00:14:18,160 --> 00:14:18,959
range

355
00:14:18,959 --> 00:14:21,920
so we don't want to instrument the code

356
00:14:21,920 --> 00:14:23,120
at this address

357
00:14:23,120 --> 00:14:26,480
for qbi we just say i'm stopping the

358
00:14:26,480 --> 00:14:30,720
instrumentation by triggering this event

359
00:14:30,720 --> 00:14:33,920
since we are in the process we can

360
00:14:33,920 --> 00:14:36,320
detect we can resolve the base address

361
00:14:36,320 --> 00:14:37,519
associated with

362
00:14:37,519 --> 00:14:40,720
this absolute address so as we are we

363
00:14:40,720 --> 00:14:42,560
have access to the memory layout of the

364
00:14:42,560 --> 00:14:43,199
process

365
00:14:43,199 --> 00:14:46,720
we can also resolve the library in which

366
00:14:46,720 --> 00:14:49,360
this address is located so we have both

367
00:14:49,360 --> 00:14:51,760
the library and the base address

368
00:14:51,760 --> 00:14:54,800
so we can have the symbol offset

369
00:14:54,800 --> 00:14:57,760
so here is the offset of the symbol

370
00:14:57,760 --> 00:14:59,440
within the library and using

371
00:14:59,440 --> 00:15:02,240
an elf parser we can have access to the

372
00:15:02,240 --> 00:15:03,199
effective

373
00:15:03,199 --> 00:15:06,160
symbols associated with the offset and

374
00:15:06,160 --> 00:15:06,480
then

375
00:15:06,480 --> 00:15:09,519
we can see that this absolute address is

376
00:15:09,519 --> 00:15:11,839
associated with malloc

377
00:15:11,839 --> 00:15:14,240
then we have the code that is executed

378
00:15:14,240 --> 00:15:15,040
and when

379
00:15:15,040 --> 00:15:18,399
the code when the function finish

380
00:15:18,399 --> 00:15:21,440
qbi changed the return address so that

381
00:15:21,440 --> 00:15:24,000
is able to detect when the function

382
00:15:24,000 --> 00:15:25,040
finished

383
00:15:25,040 --> 00:15:27,680
and will trigger another event that is

384
00:15:27,680 --> 00:15:29,360
exact transfer return

385
00:15:29,360 --> 00:15:31,920
and we'll resume the instrumentation

386
00:15:31,920 --> 00:15:33,519
until this point

387
00:15:33,519 --> 00:15:36,399
and then we'll do the same mechanism so

388
00:15:36,399 --> 00:15:37,120
with the

389
00:15:37,120 --> 00:15:39,920
exact broker you are able to trust

390
00:15:39,920 --> 00:15:41,279
external call and

391
00:15:41,279 --> 00:15:44,639
if the external code is done to a

392
00:15:44,639 --> 00:15:45,440
library

393
00:15:45,440 --> 00:15:47,519
you may also resolve the symbol

394
00:15:47,519 --> 00:15:51,120
associated with the external code

395
00:15:51,120 --> 00:15:53,199
regarding gni function we can use the

396
00:15:53,199 --> 00:15:55,279
same mechanism so gni function

397
00:15:55,279 --> 00:15:58,959
is located in a structure so it's

398
00:15:58,959 --> 00:16:02,320
basically a structure of pointer and

399
00:16:02,320 --> 00:16:04,959
this structure is usually stored in the

400
00:16:04,959 --> 00:16:05,600
dni

401
00:16:05,600 --> 00:16:08,959
of variable so if you have access to

402
00:16:08,959 --> 00:16:10,160
this

403
00:16:10,160 --> 00:16:13,519
variable you may compare the external

404
00:16:13,519 --> 00:16:14,160
address

405
00:16:14,160 --> 00:16:17,120
against one of the function within the

406
00:16:17,120 --> 00:16:18,079
structure

407
00:16:18,079 --> 00:16:21,839
so if here your absolute address

408
00:16:21,839 --> 00:16:24,320
match for instance find class you can

409
00:16:24,320 --> 00:16:25,440
process

410
00:16:25,440 --> 00:16:29,839
the parameter uh in a dedicated callback

411
00:16:29,839 --> 00:16:32,560
so here is an example that is typically

412
00:16:32,560 --> 00:16:33,120
used

413
00:16:33,120 --> 00:16:36,079
by gni function when calling generic

414
00:16:36,079 --> 00:16:37,920
function

415
00:16:37,920 --> 00:16:41,120
so first it loads the address of the

416
00:16:41,120 --> 00:16:43,440
find class into r2 but you don't know

417
00:16:43,440 --> 00:16:45,279
that is find class

418
00:16:45,279 --> 00:16:47,600
then there is a blx r2 which is a call

419
00:16:47,600 --> 00:16:49,360
to an external function

420
00:16:49,360 --> 00:16:51,519
so the exact broker detect that there is

421
00:16:51,519 --> 00:16:53,600
an external call

422
00:16:53,600 --> 00:16:55,759
from this point you can convert this

423
00:16:55,759 --> 00:16:56,959
address into

424
00:16:56,959 --> 00:16:59,920
a symbol because find class you can

425
00:16:59,920 --> 00:17:01,360
resolve fine class

426
00:17:01,360 --> 00:17:03,680
thanks to the un variable and you can

427
00:17:03,680 --> 00:17:04,640
process

428
00:17:04,640 --> 00:17:07,679
the parameter then it's the find class

429
00:17:07,679 --> 00:17:10,319
function is executed the executor

430
00:17:10,319 --> 00:17:10,959
detects

431
00:17:10,959 --> 00:17:13,760
that the function finished and you can

432
00:17:13,760 --> 00:17:15,119
do the same

433
00:17:15,119 --> 00:17:17,439
analysis when the function returns

434
00:17:17,439 --> 00:17:18,240
especially

435
00:17:18,240 --> 00:17:23,039
you can find some analyzer return value

436
00:17:23,679 --> 00:17:26,959
and doing so you can have prey and post

437
00:17:26,959 --> 00:17:30,000
callback over the external function

438
00:17:30,000 --> 00:17:32,880
which enable to analyze the parameter of

439
00:17:32,880 --> 00:17:35,280
the function and the return value

440
00:17:35,280 --> 00:17:37,520
and this approach is quite interesting

441
00:17:37,520 --> 00:17:39,200
because if you are using

442
00:17:39,200 --> 00:17:42,880
hooking you must know beforehand

443
00:17:42,880 --> 00:17:45,760
which function you want to hook but here

444
00:17:45,760 --> 00:17:47,280
we don't know beforehand

445
00:17:47,280 --> 00:17:50,640
which function will be hooked we just

446
00:17:50,640 --> 00:17:52,640
see that there is an external call and

447
00:17:52,640 --> 00:17:54,160
then we resolve

448
00:17:54,160 --> 00:18:00,080
the external call into a symbol

449
00:18:00,080 --> 00:18:03,679
and if we take st land for instance

450
00:18:03,679 --> 00:18:06,640
we have a branch to so here it's uh plt

451
00:18:06,640 --> 00:18:07,140
got

452
00:18:07,140 --> 00:18:08,400
[Music]

453
00:18:08,400 --> 00:18:12,160
code we have a branch to this register

454
00:18:12,160 --> 00:18:14,880
then there is a exact broker we convert

455
00:18:14,880 --> 00:18:16,400
this absolute address

456
00:18:16,400 --> 00:18:18,880
into a symbol then we process the

457
00:18:18,880 --> 00:18:20,000
parameter

458
00:18:20,000 --> 00:18:21,919
then the function is executed in the

459
00:18:21,919 --> 00:18:24,240
leipzig then the exact broker

460
00:18:24,240 --> 00:18:26,160
detects that the function finished and

461
00:18:26,160 --> 00:18:29,039
so on

462
00:18:29,039 --> 00:18:31,919
so to summarize qbi provides some

463
00:18:31,919 --> 00:18:33,120
primitive

464
00:18:33,120 --> 00:18:35,600
to instrument code so among this

465
00:18:35,600 --> 00:18:36,240
primitive

466
00:18:36,240 --> 00:18:38,559
we you can generate instruction truss

467
00:18:38,559 --> 00:18:39,600
which is at

468
00:18:39,600 --> 00:18:43,200
some time it's you need to have the

469
00:18:43,200 --> 00:18:45,840
information about all the instruction

470
00:18:45,840 --> 00:18:47,360
but you can also have

471
00:18:47,360 --> 00:18:49,440
memory trust if you are only interested

472
00:18:49,440 --> 00:18:50,799
in memory access

473
00:18:50,799 --> 00:18:52,960
or you can have cisco truss or you can

474
00:18:52,960 --> 00:18:55,039
have internal code truss or

475
00:18:55,039 --> 00:18:58,480
external library called truss so

476
00:18:58,480 --> 00:19:02,880
this is what could be qdi provide

477
00:19:02,880 --> 00:19:05,360
and when you have to analyze obfuscated

478
00:19:05,360 --> 00:19:06,720
code you can use

479
00:19:06,720 --> 00:19:09,679
one or you can combine this primitive

480
00:19:09,679 --> 00:19:12,160
and now we'll see how we can combine

481
00:19:12,160 --> 00:19:16,080
this primitive to analyze obfuscated

482
00:19:16,080 --> 00:19:18,320
code

483
00:19:18,400 --> 00:19:21,200
so one of the first configurations that

484
00:19:21,200 --> 00:19:22,480
we can use

485
00:19:22,480 --> 00:19:25,679
to to address obfuscated code

486
00:19:25,679 --> 00:19:28,720
is to set up a cisco callback because uh

487
00:19:28,720 --> 00:19:29,120
at

488
00:19:29,120 --> 00:19:32,559
sometimes uh obfuscator try to inline

489
00:19:32,559 --> 00:19:35,760
a cisco function so that you can do for

490
00:19:35,760 --> 00:19:37,200
instance hooking

491
00:19:37,200 --> 00:19:40,240
but since you are since uh you have qbi

492
00:19:40,240 --> 00:19:40,880
you can

493
00:19:40,880 --> 00:19:44,320
have callback on cisco and it's okay

494
00:19:44,320 --> 00:19:47,360
you can also set up the xz broker so

495
00:19:47,360 --> 00:19:48,000
that you get

496
00:19:48,000 --> 00:19:51,120
an external call trust which is like um

497
00:19:51,120 --> 00:19:53,600
s trace but for all the external

498
00:19:53,600 --> 00:19:54,400
functions

499
00:19:54,400 --> 00:19:57,760
which is quite convenient and

500
00:19:57,760 --> 00:20:00,799
you can resolve the external call into a

501
00:20:00,799 --> 00:20:01,440
symbol

502
00:20:01,440 --> 00:20:04,480
and process the parameter and the return

503
00:20:04,480 --> 00:20:06,240
value into dedicated

504
00:20:06,240 --> 00:20:11,039
callback and you get a call class

505
00:20:11,039 --> 00:20:14,559
so here is an example so in this case of

506
00:20:14,559 --> 00:20:18,080
protected code we have the airtool

507
00:20:18,080 --> 00:20:19,120
register

508
00:20:19,120 --> 00:20:21,520
that is set by loading a value from the

509
00:20:21,520 --> 00:20:22,240
stack

510
00:20:22,240 --> 00:20:25,919
and then we have a blx r2 and if you try

511
00:20:25,919 --> 00:20:27,840
statically to reverse

512
00:20:27,840 --> 00:20:30,400
and to resolve the effective value of r2

513
00:20:30,400 --> 00:20:31,280
it can be very

514
00:20:31,280 --> 00:20:33,200
complicated because it's coming from the

515
00:20:33,200 --> 00:20:34,960
stack and you need to track

516
00:20:34,960 --> 00:20:38,320
what the value at this offset contain

517
00:20:38,320 --> 00:20:39,679
and so on

518
00:20:39,679 --> 00:20:42,559
but dynamically you just have to set up

519
00:20:42,559 --> 00:20:43,520
a callback

520
00:20:43,520 --> 00:20:46,720
before blx r2 and

521
00:20:46,720 --> 00:20:49,520
thanks to the abstraction in qbi you can

522
00:20:49,520 --> 00:20:51,039
just query for

523
00:20:51,039 --> 00:20:53,760
the call address and then you get the

524
00:20:53,760 --> 00:20:54,559
effective

525
00:20:54,559 --> 00:20:57,600
address being called which is

526
00:20:57,600 --> 00:21:01,280
here in this case in the text segment

527
00:21:01,280 --> 00:21:05,280
so this is the kind of the kind of

528
00:21:05,280 --> 00:21:10,480
way to to resolve indirect code

529
00:21:10,480 --> 00:21:12,880
another interesting configuration is to

530
00:21:12,880 --> 00:21:13,600
set up

531
00:21:13,600 --> 00:21:16,880
pray and post call callback

532
00:21:16,880 --> 00:21:20,240
and within the call to record only the

533
00:21:20,240 --> 00:21:21,200
byte memory

534
00:21:21,200 --> 00:21:25,520
access that are printable this is quite

535
00:21:25,520 --> 00:21:28,159
interesting because we can in this

536
00:21:28,159 --> 00:21:29,679
configuration detect

537
00:21:29,679 --> 00:21:32,799
functions that are decoding or encoding

538
00:21:32,799 --> 00:21:36,000
strings if we take this

539
00:21:36,000 --> 00:21:39,200
example so here you have a callback with

540
00:21:39,200 --> 00:21:39,919
qbdr

541
00:21:39,919 --> 00:21:42,400
before this call and you have a callback

542
00:21:42,400 --> 00:21:44,240
after this call

543
00:21:44,240 --> 00:21:46,880
within the call you will record only

544
00:21:46,880 --> 00:21:48,000
memory access

545
00:21:48,000 --> 00:21:51,039
that are done on a byte

546
00:21:51,039 --> 00:21:54,159
so here there is a loading byte

547
00:21:54,159 --> 00:21:56,159
they are doing some computation and they

548
00:21:56,159 --> 00:21:58,559
are writing byte

549
00:21:58,559 --> 00:22:01,760
this is a pattern that you can find

550
00:22:01,760 --> 00:22:04,240
in decoding string function because

551
00:22:04,240 --> 00:22:05,120
usually

552
00:22:05,120 --> 00:22:08,960
obfuscator must be able to decode

553
00:22:08,960 --> 00:22:12,000
any string and one way is to load a byte

554
00:22:12,000 --> 00:22:14,159
from a buffer to decode the byte and to

555
00:22:14,159 --> 00:22:15,200
write the byte

556
00:22:15,200 --> 00:22:17,520
into another buffer that will contain

557
00:22:17,520 --> 00:22:19,280
the plain string

558
00:22:19,280 --> 00:22:21,760
and if we have at the beginning this

559
00:22:21,760 --> 00:22:23,200
kind of

560
00:22:23,200 --> 00:22:26,480
input that is loaded

561
00:22:26,480 --> 00:22:29,760
here we'll find some decoded string

562
00:22:29,760 --> 00:22:32,640
because here at some point the program

563
00:22:32,640 --> 00:22:33,120
needs

564
00:22:33,120 --> 00:22:36,240
the plain string so at some point we'll

565
00:22:36,240 --> 00:22:38,480
find the clear string

566
00:22:38,480 --> 00:22:41,600
into a buffer and within and using

567
00:22:41,600 --> 00:22:45,679
the memory access callback you can

568
00:22:45,679 --> 00:22:49,200
find this this string

569
00:22:49,280 --> 00:22:52,159
here is another example where we have a

570
00:22:52,159 --> 00:22:52,880
buffer

571
00:22:52,880 --> 00:22:56,159
here that is decoded using

572
00:22:56,159 --> 00:23:00,720
this algorithm so this algorithm is

573
00:23:00,720 --> 00:23:02,799
we can reverse this algorithm we'll see

574
00:23:02,799 --> 00:23:03,760
just after

575
00:23:03,760 --> 00:23:05,600
but let's say that it's very very

576
00:23:05,600 --> 00:23:07,120
complicated and it's

577
00:23:07,120 --> 00:23:10,480
too much complicated to be reversed

578
00:23:10,480 --> 00:23:13,360
here we just record the byte memory

579
00:23:13,360 --> 00:23:14,720
access so we can see that

580
00:23:14,720 --> 00:23:18,159
is reading this byte which is which are

581
00:23:18,159 --> 00:23:21,120
this uh this byte but only the printable

582
00:23:21,120 --> 00:23:22,320
character

583
00:23:22,320 --> 00:23:24,799
and we can see that within this function

584
00:23:24,799 --> 00:23:26,080
they are writing

585
00:23:26,080 --> 00:23:28,159
def so get qm so it's basically a

586
00:23:28,159 --> 00:23:31,600
function a string that is involved in

587
00:23:31,600 --> 00:23:34,400
emulator detection then here we can see

588
00:23:34,400 --> 00:23:36,000
also that we have a cisco that is

589
00:23:36,000 --> 00:23:37,520
detected with qbi

590
00:23:37,520 --> 00:23:40,000
and just by looking at the dynamic truss

591
00:23:40,000 --> 00:23:40,799
we

592
00:23:40,799 --> 00:23:43,840
can avoid to reverse this algorithm we

593
00:23:43,840 --> 00:23:45,760
just have access to the memory buffer

594
00:23:45,760 --> 00:23:47,200
that is read and written

595
00:23:47,200 --> 00:23:50,480
and here we can clearly see the string

596
00:23:50,480 --> 00:23:54,159
uh that are decoded but if you want to

597
00:23:54,159 --> 00:23:55,840
reverse statically the

598
00:23:55,840 --> 00:23:59,440
the function uh the you can have a

599
00:23:59,440 --> 00:24:01,360
python script that is doing basically

600
00:24:01,360 --> 00:24:02,080
the same thing

601
00:24:02,080 --> 00:24:04,480
so we can confirm that we effectively

602
00:24:04,480 --> 00:24:06,640
manage to reverse

603
00:24:06,640 --> 00:24:11,120
the the the decoding function

604
00:24:11,600 --> 00:24:14,720
another interesting configuration is to

605
00:24:14,720 --> 00:24:15,200
track

606
00:24:15,200 --> 00:24:18,880
memory access such as a malloc or calloc

607
00:24:18,880 --> 00:24:21,120
or if you are in c plus plus operator on

608
00:24:21,120 --> 00:24:22,240
you

609
00:24:22,240 --> 00:24:25,840
we can also track memory map

610
00:24:25,840 --> 00:24:28,880
functions such as m map and when a

611
00:24:28,880 --> 00:24:32,320
code tried to dynamically allocate code

612
00:24:32,320 --> 00:24:34,320
you can have a callback over this

613
00:24:34,320 --> 00:24:36,720
function and automatically update

614
00:24:36,720 --> 00:24:40,240
the instrumentated range of qdi so that

615
00:24:40,240 --> 00:24:42,960
the new code that is allocated will be

616
00:24:42,960 --> 00:24:44,799
instrumented

617
00:24:44,799 --> 00:24:46,960
and when there is a free function that

618
00:24:46,960 --> 00:24:48,000
is called

619
00:24:48,000 --> 00:24:51,600
by the program since you manage to

620
00:24:51,600 --> 00:24:54,320
to intercept the malloc and all the

621
00:24:54,320 --> 00:24:54,960
dynamic

622
00:24:54,960 --> 00:24:58,080
memory buffer allocation you

623
00:24:58,080 --> 00:25:01,200
you know the size of the buffer that is

624
00:25:01,200 --> 00:25:04,080
they are located at the end so you can

625
00:25:04,080 --> 00:25:04,960
print

626
00:25:04,960 --> 00:25:07,760
the buffer being free and we'll see an

627
00:25:07,760 --> 00:25:08,480
example

628
00:25:08,480 --> 00:25:12,400
right now so here is a piece of code on

629
00:25:12,400 --> 00:25:13,760
map so when

630
00:25:13,760 --> 00:25:16,720
the opposite code tried to dynamically

631
00:25:16,720 --> 00:25:17,360
allocate

632
00:25:17,360 --> 00:25:21,120
code we can just

633
00:25:21,120 --> 00:25:24,240
take the parameters and

634
00:25:24,240 --> 00:25:27,360
in the qbi api webinar we have a

635
00:25:27,360 --> 00:25:28,080
function that

636
00:25:28,080 --> 00:25:30,960
enable to automatically update the

637
00:25:30,960 --> 00:25:32,480
instrumentated range

638
00:25:32,480 --> 00:25:35,279
and here we just say now i want to

639
00:25:35,279 --> 00:25:36,159
instrument

640
00:25:36,159 --> 00:25:39,520
the code that is dynamically allocated

641
00:25:39,520 --> 00:25:43,200
through a map and here we have the api

642
00:25:43,200 --> 00:25:45,919
with the exact broker so if you want to

643
00:25:45,919 --> 00:25:48,400
take a look

644
00:25:48,559 --> 00:25:51,679
and here is what kind of output

645
00:25:51,679 --> 00:25:54,799
you can have with this configuration so

646
00:25:54,799 --> 00:25:56,000
here we can see that

647
00:25:56,000 --> 00:26:00,480
the code is allo is is calling a map

648
00:26:00,480 --> 00:26:02,720
and here we have the address of map

649
00:26:02,720 --> 00:26:04,480
since we instrument the code

650
00:26:04,480 --> 00:26:07,600
we can automatically update qdi to

651
00:26:07,600 --> 00:26:08,960
instrument this new

652
00:26:08,960 --> 00:26:13,120
range of code and

653
00:26:13,120 --> 00:26:15,039
and here we can see that we have a m

654
00:26:15,039 --> 00:26:16,720
protect that is

655
00:26:16,720 --> 00:26:20,159
setting the protect execute flag

656
00:26:20,159 --> 00:26:23,520
on the new instrument in it range

657
00:26:23,520 --> 00:26:26,480
and at the end we have the an m map

658
00:26:26,480 --> 00:26:27,120
function

659
00:26:27,120 --> 00:26:31,039
so here you get this kind of output

660
00:26:31,039 --> 00:26:34,960
with with this setup

661
00:26:34,960 --> 00:26:38,240
now i'll go through a real use case

662
00:26:38,240 --> 00:26:41,760
and some example of using qbdi

663
00:26:41,760 --> 00:26:44,799
on android application

664
00:26:44,799 --> 00:26:47,919
so for this example i took two

665
00:26:47,919 --> 00:26:49,440
obfuscators which are

666
00:26:49,440 --> 00:26:52,720
blue and green the first

667
00:26:52,720 --> 00:26:55,760
example will be about gni onload

668
00:26:55,760 --> 00:26:59,679
so in java you can declare

669
00:26:59,679 --> 00:27:02,480
native function so that the

670
00:27:02,480 --> 00:27:04,320
implementation of this function

671
00:27:04,320 --> 00:27:08,000
is located in a native library so here

672
00:27:08,000 --> 00:27:10,480
if you want to understand the behavior

673
00:27:10,480 --> 00:27:11,200
of the function

674
00:27:11,200 --> 00:27:14,400
a you need to first find the library in

675
00:27:14,400 --> 00:27:15,279
which

676
00:27:15,279 --> 00:27:17,760
a is implemented and then you need to

677
00:27:17,760 --> 00:27:20,720
reverse assembly code

678
00:27:20,720 --> 00:27:24,640
so this is the output the control flow

679
00:27:24,640 --> 00:27:25,600
graph of the

680
00:27:25,600 --> 00:27:29,039
library associated with the gni function

681
00:27:29,039 --> 00:27:31,600
you can notice that you only have one

682
00:27:31,600 --> 00:27:32,480
export

683
00:27:32,480 --> 00:27:34,880
which is gni onload and we'll see that

684
00:27:34,880 --> 00:27:36,799
jnio node is basically

685
00:27:36,799 --> 00:27:38,640
the function that is doing the

686
00:27:38,640 --> 00:27:40,000
resolution between

687
00:27:40,000 --> 00:27:43,440
the declaration in java and the offset

688
00:27:43,440 --> 00:27:46,960
in the library and here is the cfg which

689
00:27:46,960 --> 00:27:48,000
is

690
00:27:48,000 --> 00:27:50,159
obfuscated so it's using control flow

691
00:27:50,159 --> 00:27:51,120
flattening

692
00:27:51,120 --> 00:27:53,679
and if you want to understand how this

693
00:27:53,679 --> 00:27:56,159
sequence of busy balance is executed

694
00:27:56,159 --> 00:28:00,080
it can be like very very painful

695
00:28:00,320 --> 00:28:03,360
so in the gni unload function

696
00:28:03,360 --> 00:28:06,159
you have one specific gni function which

697
00:28:06,159 --> 00:28:06,559
is

698
00:28:06,559 --> 00:28:09,120
register native and the purpose of

699
00:28:09,120 --> 00:28:10,640
traditional native

700
00:28:10,640 --> 00:28:14,399
it's to map it's to bind an offset

701
00:28:14,399 --> 00:28:17,440
in the library with the declaration in

702
00:28:17,440 --> 00:28:18,480
java

703
00:28:18,480 --> 00:28:21,200
so by calling register native you have a

704
00:28:21,200 --> 00:28:22,720
bridge between

705
00:28:22,720 --> 00:28:26,000
the native implementation and the java

706
00:28:26,000 --> 00:28:26,960
declaration

707
00:28:26,960 --> 00:28:28,960
so when the java code will call the

708
00:28:28,960 --> 00:28:30,000
function a

709
00:28:30,000 --> 00:28:32,880
it will actually code the function at

710
00:28:32,880 --> 00:28:35,520
this location in the library

711
00:28:35,520 --> 00:28:39,120
so at some point if you manage to catch

712
00:28:39,120 --> 00:28:42,399
register native you can automatically

713
00:28:42,399 --> 00:28:43,200
resolve

714
00:28:43,200 --> 00:28:46,320
the offset of the function within the

715
00:28:46,320 --> 00:28:48,880
library

716
00:28:48,880 --> 00:28:51,600
so using qbi and the exec broker it's

717
00:28:51,600 --> 00:28:53,520
quite straightforward because

718
00:28:53,520 --> 00:28:55,679
at some point there will be an external

719
00:28:55,679 --> 00:28:56,720
call

720
00:28:56,720 --> 00:28:58,640
and because there is an external call

721
00:28:58,640 --> 00:29:00,320
you can use the exact broker

722
00:29:00,320 --> 00:29:03,760
to resolve the function the address into

723
00:29:03,760 --> 00:29:04,559
a thimble

724
00:29:04,559 --> 00:29:07,200
and as you may know that it's registered

725
00:29:07,200 --> 00:29:07,919
native

726
00:29:07,919 --> 00:29:10,640
you can inspect the second parameter

727
00:29:10,640 --> 00:29:12,559
that contain the

728
00:29:12,559 --> 00:29:14,799
mapping between the function and the

729
00:29:14,799 --> 00:29:15,679
offset

730
00:29:15,679 --> 00:29:18,159
and then you have access to the offset

731
00:29:18,159 --> 00:29:19,039
of the library

732
00:29:19,039 --> 00:29:22,960
so here you can just go through this

733
00:29:22,960 --> 00:29:26,399
function and then continue the analysis

734
00:29:26,399 --> 00:29:28,720
since you you managed to resolve the

735
00:29:28,720 --> 00:29:31,039
offset

736
00:29:31,039 --> 00:29:34,320
so here is the basic block involved in

737
00:29:34,320 --> 00:29:35,919
register native

738
00:29:35,919 --> 00:29:38,960
we can see here that regis

739
00:29:38,960 --> 00:29:42,799
native it is done at this address

740
00:29:42,799 --> 00:29:46,000
and we can see that this address is

741
00:29:46,000 --> 00:29:46,960
actually here

742
00:29:46,960 --> 00:29:50,480
so we can see that it's blx r5 we don't

743
00:29:50,480 --> 00:29:52,080
really care about

744
00:29:52,080 --> 00:29:54,960
what is the value of f5 we just know

745
00:29:54,960 --> 00:29:55,360
that

746
00:29:55,360 --> 00:29:57,520
it's an external call and here

747
00:29:57,520 --> 00:29:59,200
statically it could be like very

748
00:29:59,200 --> 00:30:01,200
complicated and tricky to resolve

749
00:30:01,200 --> 00:30:03,840
f5 for that yeah it's very

750
00:30:03,840 --> 00:30:06,640
straightforward

751
00:30:06,640 --> 00:30:09,919
and here is another view of the same

752
00:30:09,919 --> 00:30:13,200
dna load function

753
00:30:13,200 --> 00:30:15,679
if you are interesting in the full

754
00:30:15,679 --> 00:30:17,360
demonstration

755
00:30:17,360 --> 00:30:20,240
of the dynamic charge generated by qbi

756
00:30:20,240 --> 00:30:20,960
you can check

757
00:30:20,960 --> 00:30:23,840
this video

758
00:30:24,159 --> 00:30:27,120
so now let's move to another example

759
00:30:27,120 --> 00:30:29,279
which involves video game protection

760
00:30:29,279 --> 00:30:32,559
so in a video game you have similar

761
00:30:32,559 --> 00:30:35,039
threads that desktop game so

762
00:30:35,039 --> 00:30:37,279
basically you may want to modify the

763
00:30:37,279 --> 00:30:38,320
memory human

764
00:30:38,320 --> 00:30:41,679
wants to dynamically modify the behavior

765
00:30:41,679 --> 00:30:42,720
of the game

766
00:30:42,720 --> 00:30:46,000
and one of the well known tune tool to

767
00:30:46,000 --> 00:30:46,559
do that

768
00:30:46,559 --> 00:30:49,919
is frida because the api is very very

769
00:30:49,919 --> 00:30:50,480
simple

770
00:30:50,480 --> 00:30:53,520
it works very well and fun so

771
00:30:53,520 --> 00:30:56,480
one of the protections that are provided

772
00:30:56,480 --> 00:30:58,720
by obfuscator is also a way to detect

773
00:30:58,720 --> 00:31:00,320
frida or at least to

774
00:31:00,320 --> 00:31:03,440
try to to make freedom not run

775
00:31:03,440 --> 00:31:05,120
and one of the video games that we

776
00:31:05,120 --> 00:31:07,440
analyze implement

777
00:31:07,440 --> 00:31:09,760
3d detection which are based on

778
00:31:09,760 --> 00:31:10,799
detecting

779
00:31:10,799 --> 00:31:15,200
tcp power and because we don't want

780
00:31:15,200 --> 00:31:17,919
to have the protection within a single

781
00:31:17,919 --> 00:31:18,640
function

782
00:31:18,640 --> 00:31:22,080
that could be like hooked with frida and

783
00:31:22,080 --> 00:31:26,000
change they inline all the instruction

784
00:31:26,000 --> 00:31:28,480
through cisco that are involved in the

785
00:31:28,480 --> 00:31:30,320
detection

786
00:31:30,320 --> 00:31:33,679
but thanks to qbi we can trust cisco

787
00:31:33,679 --> 00:31:36,880
so we can identify where are the cisco

788
00:31:36,880 --> 00:31:39,519
and we'll see how we can remove the

789
00:31:39,519 --> 00:31:41,440
protection

790
00:31:41,440 --> 00:31:44,240
so here is an example of truss that you

791
00:31:44,240 --> 00:31:45,519
get with qbdi

792
00:31:45,519 --> 00:31:48,880
and you can see that you have a syscall

793
00:31:48,880 --> 00:31:51,360
at this address so it's trying to open a

794
00:31:51,360 --> 00:31:52,240
socket

795
00:31:52,240 --> 00:31:54,480
then they are doing some bind

796
00:31:54,480 --> 00:31:56,480
functionality to try to open on a

797
00:31:56,480 --> 00:31:57,840
specific bar which is

798
00:31:57,840 --> 00:32:00,640
the free dapper and then if he tried to

799
00:32:00,640 --> 00:32:01,039
make

800
00:32:01,039 --> 00:32:04,000
if he managed to open the socket it will

801
00:32:04,000 --> 00:32:05,279
crush the game

802
00:32:05,279 --> 00:32:08,559
and basically one of the weakest of the

803
00:32:08,559 --> 00:32:09,919
protection is that

804
00:32:09,919 --> 00:32:12,720
when frida were running the crowd the

805
00:32:12,720 --> 00:32:15,360
application the game were crashing

806
00:32:15,360 --> 00:32:18,159
and because it was crashing we got a

807
00:32:18,159 --> 00:32:19,440
stuck trace

808
00:32:19,440 --> 00:32:22,080
and using the stack trace we can

809
00:32:22,080 --> 00:32:23,039
identify

810
00:32:23,039 --> 00:32:25,679
which function crashed and then we can

811
00:32:25,679 --> 00:32:28,080
say okay with qbi we want to trust this

812
00:32:28,080 --> 00:32:30,080
function to see what is the issue

813
00:32:30,080 --> 00:32:34,399
and then we get this kind of output

814
00:32:34,399 --> 00:32:36,399
so here is the static code associated

815
00:32:36,399 --> 00:32:38,159
with the function

816
00:32:38,159 --> 00:32:41,360
so we can see that we have the cisco

817
00:32:41,360 --> 00:32:46,000
at this address which is fine

818
00:32:46,000 --> 00:32:49,360
and now that we managed to identify

819
00:32:49,360 --> 00:32:52,799
the syscall we can use leaf to patch

820
00:32:52,799 --> 00:32:55,919
the c school with the value minus 1

821
00:32:55,919 --> 00:32:56,960
which

822
00:32:56,960 --> 00:33:00,640
stands for an error so since we managed

823
00:33:00,640 --> 00:33:03,200
we notified the cisco we can just remove

824
00:33:03,200 --> 00:33:08,480
this cisco with a wrong value

825
00:33:08,480 --> 00:33:11,760
and now we just have the cisco

826
00:33:11,760 --> 00:33:15,840
and we return -1

827
00:33:16,159 --> 00:33:19,200
with the modification

828
00:33:19,679 --> 00:33:22,640
and at the end we were we managed to to

829
00:33:22,640 --> 00:33:24,720
execute the game with frida

830
00:33:24,720 --> 00:33:27,120
without issue one of the limitation of

831
00:33:27,120 --> 00:33:27,840
this

832
00:33:27,840 --> 00:33:30,320
approach is that you need to identify

833
00:33:30,320 --> 00:33:32,000
all the cisco

834
00:33:32,000 --> 00:33:35,440
and since you are only generate a truss

835
00:33:35,440 --> 00:33:39,279
for one execution path you may not cover

836
00:33:39,279 --> 00:33:42,559
all the syscall so you need to

837
00:33:42,559 --> 00:33:47,039
find a way to have a very good coverage

838
00:33:47,039 --> 00:33:50,559
over the execution path

839
00:33:50,960 --> 00:33:54,880
another example is within a mdm

840
00:33:54,880 --> 00:33:58,240
solution so a mdm money

841
00:33:58,240 --> 00:34:01,440
solution aims to provide

842
00:34:01,440 --> 00:34:04,480
a control over a set of devices that are

843
00:34:04,480 --> 00:34:05,200
deployed

844
00:34:05,200 --> 00:34:08,320
within a company and basically there is

845
00:34:08,320 --> 00:34:08,960
a

846
00:34:08,960 --> 00:34:11,199
admin user that is able to control for

847
00:34:11,199 --> 00:34:12,560
instance which package

848
00:34:12,560 --> 00:34:14,480
are allowed to be installed on the

849
00:34:14,480 --> 00:34:16,800
device which are not answered

850
00:34:16,800 --> 00:34:20,000
and one of the feature that

851
00:34:20,000 --> 00:34:23,040
are in this solution is to be able to

852
00:34:23,040 --> 00:34:23,760
detect

853
00:34:23,760 --> 00:34:27,440
if the device is rooted or jailbroken

854
00:34:27,440 --> 00:34:29,440
because if the device for instance is

855
00:34:29,440 --> 00:34:31,839
rooted it's quite straightforward to

856
00:34:31,839 --> 00:34:33,760
bypass all the protection

857
00:34:33,760 --> 00:34:36,399
so this is one of the key point in this

858
00:34:36,399 --> 00:34:38,480
part in this solution

859
00:34:38,480 --> 00:34:41,040
if you want to if they want to be

860
00:34:41,040 --> 00:34:41,760
working

861
00:34:41,760 --> 00:34:44,800
quite well but

862
00:34:44,800 --> 00:34:47,359
if you want to detect that a device is

863
00:34:47,359 --> 00:34:48,320
rooted

864
00:34:48,320 --> 00:34:51,440
you need to interact at some point with

865
00:34:51,440 --> 00:34:53,119
the system

866
00:34:53,119 --> 00:34:55,440
and since you are not able to link

867
00:34:55,440 --> 00:34:56,879
statically the leipzig

868
00:34:56,879 --> 00:35:00,400
in android you must call

869
00:35:00,400 --> 00:35:03,200
external function and even though the

870
00:35:03,200 --> 00:35:04,560
original parameter

871
00:35:04,560 --> 00:35:06,320
are protected or the string are

872
00:35:06,320 --> 00:35:07,920
protected and done

873
00:35:07,920 --> 00:35:11,040
at some point the external curl must be

874
00:35:11,040 --> 00:35:11,599
done

875
00:35:11,599 --> 00:35:16,240
with original strings

876
00:35:16,240 --> 00:35:18,720
the solutions that we analyzed were

877
00:35:18,720 --> 00:35:20,800
written in c plus plus

878
00:35:20,800 --> 00:35:23,920
and the world were protected by the

879
00:35:23,920 --> 00:35:26,560
second obscure

880
00:35:26,560 --> 00:35:29,599
and one tricky point is c plus plus

881
00:35:29,599 --> 00:35:33,440
is that you can have implicit destructor

882
00:35:33,440 --> 00:35:35,920
so let's consider this piece of code

883
00:35:35,920 --> 00:35:36,480
here

884
00:35:36,480 --> 00:35:38,480
you have a string object within the

885
00:35:38,480 --> 00:35:40,560
check root function

886
00:35:40,560 --> 00:35:42,640
here you get a reference over all the

887
00:35:42,640 --> 00:35:44,000
character located

888
00:35:44,000 --> 00:35:46,880
in string you are decoding the string

889
00:35:46,880 --> 00:35:47,440
with

890
00:35:47,440 --> 00:35:50,960
aux operation and here at the end

891
00:35:50,960 --> 00:35:54,640
you have a free memory you delete

892
00:35:54,640 --> 00:35:57,680
the buffer allocated with string

893
00:35:57,680 --> 00:36:00,079
but you don't need to write this piece

894
00:36:00,079 --> 00:36:02,079
of code it's a compiler that

895
00:36:02,079 --> 00:36:05,680
automatically generate this call

896
00:36:05,680 --> 00:36:08,640
and because you are deleting a buffer at

897
00:36:08,640 --> 00:36:09,520
the end

898
00:36:09,520 --> 00:36:13,119
your string variable contain

899
00:36:13,119 --> 00:36:16,480
the plain string and with qbdi

900
00:36:16,480 --> 00:36:19,680
you are able to detect when the

901
00:36:19,680 --> 00:36:22,800
string object is allocated and you are

902
00:36:22,800 --> 00:36:23,280
also

903
00:36:23,280 --> 00:36:25,760
able to detect when there is an external

904
00:36:25,760 --> 00:36:27,440
call to operator delayed

905
00:36:27,440 --> 00:36:29,760
and you can just look at what the buffer

906
00:36:29,760 --> 00:36:31,920
contain since you are able to

907
00:36:31,920 --> 00:36:34,240
know the size of the buffer and when it

908
00:36:34,240 --> 00:36:36,640
is delayed

909
00:36:36,640 --> 00:36:39,760
and then you get this kind of output

910
00:36:39,760 --> 00:36:42,320
and here you have all the check that are

911
00:36:42,320 --> 00:36:44,320
done by the mdn within this function

912
00:36:44,320 --> 00:36:45,200
which would be like

913
00:36:45,200 --> 00:36:47,599
very painful to analyze but just by

914
00:36:47,599 --> 00:36:48,800
looking at

915
00:36:48,800 --> 00:36:52,320
the delayed operator and looking at the

916
00:36:52,320 --> 00:36:53,200
buffer you

917
00:36:53,200 --> 00:36:56,000
may know how the root detection is

918
00:36:56,000 --> 00:36:57,040
performed

919
00:36:57,040 --> 00:37:00,480
then you may want to notify where they

920
00:37:00,480 --> 00:37:02,000
are already used and so on but

921
00:37:02,000 --> 00:37:06,800
at least you know what kind of check are

922
00:37:06,839 --> 00:37:08,000
not

923
00:37:08,000 --> 00:37:10,240
i won't go through the detail of the

924
00:37:10,240 --> 00:37:11,280
android packer

925
00:37:11,280 --> 00:37:14,000
but we published a blog post about the

926
00:37:14,000 --> 00:37:15,680
reverse engineering of

927
00:37:15,680 --> 00:37:18,480
a packer as well as the code to

928
00:37:18,480 --> 00:37:20,079
automatically

929
00:37:20,079 --> 00:37:22,800
unpack the packer and if you are

930
00:37:22,800 --> 00:37:23,599
interested

931
00:37:23,599 --> 00:37:26,800
in how we did that with cubedi you can

932
00:37:26,800 --> 00:37:28,240
also check this

933
00:37:28,240 --> 00:37:32,400
formant demo so three point to keep in

934
00:37:32,400 --> 00:37:33,200
mind when

935
00:37:33,200 --> 00:37:36,320
you deal with uh obfuscation

936
00:37:36,320 --> 00:37:39,440
first the obfuscator can break

937
00:37:39,440 --> 00:37:42,000
all the program semantic it means that

938
00:37:42,000 --> 00:37:42,720
if

939
00:37:42,720 --> 00:37:46,079
the original code performs this call

940
00:37:46,079 --> 00:37:48,880
you may have a cisco at the end if there

941
00:37:48,880 --> 00:37:50,560
is some external call

942
00:37:50,560 --> 00:37:53,040
the parameter of the external call can't

943
00:37:53,040 --> 00:37:54,880
be obfuscated for instance you can't

944
00:37:54,880 --> 00:37:56,000
obfuscate

945
00:37:56,000 --> 00:37:59,280
the string going through stln

946
00:37:59,280 --> 00:38:02,560
you can't obfuscate the buffer allocated

947
00:38:02,560 --> 00:38:05,839
with malloc i mean you can't obfuscate

948
00:38:05,839 --> 00:38:07,040
the size of the

949
00:38:07,040 --> 00:38:08,960
the buffer allocated with malloc and

950
00:38:08,960 --> 00:38:10,720
phone

951
00:38:10,720 --> 00:38:14,000
a dbi unable to recover

952
00:38:14,000 --> 00:38:17,119
some of the original semantic of the

953
00:38:17,119 --> 00:38:18,160
program but

954
00:38:18,160 --> 00:38:21,280
it only provides primitive and you need

955
00:38:21,280 --> 00:38:23,520
to use this primitive to

956
00:38:23,520 --> 00:38:26,800
set up what you want to analyze

957
00:38:26,800 --> 00:38:28,960
so for instance if your code is dealing

958
00:38:28,960 --> 00:38:31,200
with memory access you may want to have

959
00:38:31,200 --> 00:38:32,720
a to set up

960
00:38:32,720 --> 00:38:34,560
memory access callback or if you know

961
00:38:34,560 --> 00:38:35,839
that it's

962
00:38:35,839 --> 00:38:39,280
just about executing getting an external

963
00:38:39,280 --> 00:38:40,640
code trust you may just

964
00:38:40,640 --> 00:38:43,359
want to use the exact broker so it

965
00:38:43,359 --> 00:38:44,160
depends on

966
00:38:44,160 --> 00:38:47,599
what you want to reverse also one of the

967
00:38:47,599 --> 00:38:48,240
drawback

968
00:38:48,240 --> 00:38:51,599
of the commercial obfuscator is that

969
00:38:51,599 --> 00:38:53,200
usually the people that develop

970
00:38:53,200 --> 00:38:55,680
obfuscator are very talented

971
00:38:55,680 --> 00:38:58,480
in their field and the developers are

972
00:38:58,480 --> 00:39:00,560
very talented to develop

973
00:39:00,560 --> 00:39:03,680
but sometimes developer may not know

974
00:39:03,680 --> 00:39:04,320
very well

975
00:39:04,320 --> 00:39:08,240
how to use specific obfuscation passes

976
00:39:08,240 --> 00:39:11,359
and it can be like quite tricky because

977
00:39:11,359 --> 00:39:13,440
for instance if you don't on correct

978
00:39:13,440 --> 00:39:15,359
string it's quite straightforward to

979
00:39:15,359 --> 00:39:16,079
identify

980
00:39:16,079 --> 00:39:19,599
the what is the purpose of function

981
00:39:19,599 --> 00:39:24,079
and so on also i would like to thanks

982
00:39:24,079 --> 00:39:26,320
charles hubbard and sedek tracy because

983
00:39:26,320 --> 00:39:29,040
they are the original after of qdi

984
00:39:29,040 --> 00:39:32,480
and i was i would not be able to make

985
00:39:32,480 --> 00:39:33,280
this code

986
00:39:33,280 --> 00:39:36,640
without their initial work

987
00:39:36,640 --> 00:39:39,520
also thanks to the llvm community

988
00:39:39,520 --> 00:39:40,720
because

989
00:39:40,720 --> 00:39:43,760
the llvm framework is widely used uh in

990
00:39:43,760 --> 00:39:45,119
the security field

991
00:39:45,119 --> 00:39:46,720
so we have already can remain from

992
00:39:46,720 --> 00:39:50,000
tradeoff bits uh qdi we have also arriba

993
00:39:50,000 --> 00:39:53,359
that will use with triton to recover uh

994
00:39:53,359 --> 00:39:55,520
some kind of observation also we have

995
00:39:55,520 --> 00:39:58,160
redec from avast and ole vm and

996
00:39:58,160 --> 00:40:01,520
most of the obfuscator now thanks to my

997
00:40:01,520 --> 00:40:02,160
colleague

998
00:40:02,160 --> 00:40:05,760
and corsa because i work in a very

999
00:40:05,760 --> 00:40:08,079
interesting environment in which i can

1000
00:40:08,079 --> 00:40:09,280
do this kind of work

1001
00:40:09,280 --> 00:40:11,520
and to explore this kind of topic so

1002
00:40:11,520 --> 00:40:12,880
thanks to them

1003
00:40:12,880 --> 00:40:15,119
and thank you for your attention and now

1004
00:40:15,119 --> 00:40:17,280
if you are questioned

1005
00:40:17,280 --> 00:40:21,760
i'm free thank you

