1
00:00:00,150 --> 00:00:09,969
[Music]

2
00:00:10,719 --> 00:00:11,360
so

3
00:00:11,360 --> 00:00:14,920
this talks about static binary injection

4
00:00:14,920 --> 00:00:18,240
and in the talk we introduced

5
00:00:18,240 --> 00:00:21,680
our new tune name red bike which is an

6
00:00:21,680 --> 00:00:23,439
advanced tool for static binary

7
00:00:23,439 --> 00:00:25,840
injection

8
00:00:26,800 --> 00:00:29,279
okay so this work has been done by a

9
00:00:29,279 --> 00:00:30,560
team of two people

10
00:00:30,560 --> 00:00:33,760
michael speaker and me and my name is

11
00:00:33,760 --> 00:00:36,239
i'm working in nanyang technological

12
00:00:36,239 --> 00:00:38,160
university of singapore

13
00:00:38,160 --> 00:00:40,640
and in the last few years my research

14
00:00:40,640 --> 00:00:43,600
focused mostly on binary analysis

15
00:00:43,600 --> 00:00:47,600
and i'm the founder and the maintainer

16
00:00:47,600 --> 00:00:49,120
few

17
00:00:49,120 --> 00:00:52,079
open reversing framework like capstone

18
00:00:52,079 --> 00:00:52,960
disassembler

19
00:00:52,960 --> 00:00:58,239
unicorn emulator and keystone assembler

20
00:00:58,239 --> 00:01:01,680
okay michael speaker is domington and

21
00:01:01,680 --> 00:01:04,879
he's a researcher at a science tech he

22
00:01:04,879 --> 00:01:08,080
is interested in fasting and exploits

23
00:01:08,080 --> 00:01:12,080
tony is a member of a baby phd at ctft

24
00:01:12,080 --> 00:01:15,520
and he gave many talks at axon d2

25
00:01:15,520 --> 00:01:19,280
blackhead usa in blackhead asia

26
00:01:20,720 --> 00:01:24,240
so in this talk we first introduced

27
00:01:24,240 --> 00:01:27,520
briefly the background on static binary

28
00:01:27,520 --> 00:01:28,640
injection

29
00:01:28,640 --> 00:01:31,840
and after that we show how we develop

30
00:01:31,840 --> 00:01:36,079
a new tool name replied and

31
00:01:36,079 --> 00:01:39,040
we present the mythology breadback and

32
00:01:39,040 --> 00:01:40,560
the implementation

33
00:01:40,560 --> 00:01:42,720
so you can see how redback supports

34
00:01:42,720 --> 00:01:43,920
different file

35
00:01:43,920 --> 00:01:47,759
formats like match all erf and windows b

36
00:01:47,759 --> 00:01:48,880
files

37
00:01:48,880 --> 00:01:51,439
we have some demos in our talk and

38
00:01:51,439 --> 00:01:52,880
finally we have

39
00:01:52,880 --> 00:01:55,839
conclusion

40
00:01:56,960 --> 00:01:58,719
ok let's talk about static binary

41
00:01:58,719 --> 00:02:00,079
injection

42
00:02:00,079 --> 00:02:02,079
static binary initiation is a technique

43
00:02:02,079 --> 00:02:04,320
to physically patch

44
00:02:04,320 --> 00:02:07,759
extern external binary into executable

45
00:02:07,759 --> 00:02:08,720
file

46
00:02:08,720 --> 00:02:12,080
so at the beginning we have an original

47
00:02:12,080 --> 00:02:15,440
executable file and some external binary

48
00:02:15,440 --> 00:02:19,599
we inject the external binary

49
00:02:19,599 --> 00:02:22,720
into the original executable file and at

50
00:02:22,720 --> 00:02:23,360
the output

51
00:02:23,360 --> 00:02:26,640
we have the new apple xk21 file which

52
00:02:26,640 --> 00:02:29,840
includes all the original executable

53
00:02:29,840 --> 00:02:32,400
and also injected binary so you can see

54
00:02:32,400 --> 00:02:34,319
that the output

55
00:02:34,319 --> 00:02:36,560
the size output files bigger than the

56
00:02:36,560 --> 00:02:38,160
original

57
00:02:38,160 --> 00:02:42,000
executable file the two

58
00:02:42,000 --> 00:02:44,080
there are two main cab binaries to

59
00:02:44,080 --> 00:02:45,360
inject the first one

60
00:02:45,360 --> 00:02:48,640
pressing pawn is shellcode so you can

61
00:02:48,640 --> 00:02:52,239
inject shellcode into our executable

62
00:02:52,239 --> 00:02:53,040
file

63
00:02:53,040 --> 00:02:55,920
and you can see that because circuit is

64
00:02:55,920 --> 00:02:57,519
very simple

65
00:02:57,519 --> 00:03:00,720
it's very easy to develop a tool to

66
00:03:00,720 --> 00:03:02,879
inject shellcode

67
00:03:02,879 --> 00:03:05,680
into the executable file but on the

68
00:03:05,680 --> 00:03:07,040
other hand you can see that

69
00:03:07,040 --> 00:03:10,239
because shellcode is mainly written in

70
00:03:10,239 --> 00:03:13,200
low-level assembly language so it's very

71
00:03:13,200 --> 00:03:14,159
expensive

72
00:03:14,159 --> 00:03:17,040
to develop and maintain conflicted

73
00:03:17,040 --> 00:03:20,159
complicated circle

74
00:03:20,720 --> 00:03:23,760
so this second type binary to inject is

75
00:03:23,760 --> 00:03:25,680
totally different we call that

76
00:03:25,680 --> 00:03:27,200
high-level binary

77
00:03:27,200 --> 00:03:30,319
so we have some source code written

78
00:03:30,319 --> 00:03:33,360
in high-level language like c or c

79
00:03:33,360 --> 00:03:36,720
plus plus and revision and other output

80
00:03:36,720 --> 00:03:37,200
we have

81
00:03:37,200 --> 00:03:41,599
high level high level binary and

82
00:03:41,599 --> 00:03:45,360
static manipulation can inject this cap

83
00:03:45,360 --> 00:03:49,280
hollywood binary into the sdk21 file

84
00:03:49,280 --> 00:03:52,159
and you can see that

85
00:03:52,400 --> 00:03:54,720
on one hand it's easy to view to

86
00:03:54,720 --> 00:03:56,480
maintain

87
00:03:56,480 --> 00:03:58,840
this cap binary because it has source

88
00:03:58,840 --> 00:04:01,760
code but on the other hand

89
00:04:01,760 --> 00:04:04,879
the this car binary is very complicated

90
00:04:04,879 --> 00:04:08,599
so it's much much harder to build

91
00:04:08,599 --> 00:04:12,640
initialization tool for that and

92
00:04:12,640 --> 00:04:16,238
this talk is mainly about

93
00:04:16,238 --> 00:04:19,680
how to view an advanced tool to inject

94
00:04:19,680 --> 00:04:21,358
high level binary

95
00:04:21,358 --> 00:04:25,758
into executable file

96
00:04:27,360 --> 00:04:29,759
so there are many good reasons why you

97
00:04:29,759 --> 00:04:32,160
want static binary injection

98
00:04:32,160 --> 00:04:35,919
so you can add inject code into

99
00:04:35,919 --> 00:04:39,440
one program to add new features or

100
00:04:39,440 --> 00:04:42,639
you can inject a code

101
00:04:42,639 --> 00:04:45,600
into the program to absorb the target

102
00:04:45,600 --> 00:04:46,240
behavior

103
00:04:46,240 --> 00:04:49,840
at runtime and static binary injection

104
00:04:49,840 --> 00:04:50,960
has many

105
00:04:50,960 --> 00:04:53,680
applications first one is persistent

106
00:04:53,680 --> 00:04:54,880
infection

107
00:04:54,880 --> 00:04:56,880
because this is what on the mayor want

108
00:04:56,880 --> 00:04:58,560
to do

109
00:04:58,560 --> 00:05:01,120
executable packer or particular also

110
00:05:01,120 --> 00:05:02,240
need to

111
00:05:02,240 --> 00:05:05,840
inject and modify the program

112
00:05:05,840 --> 00:05:07,680
and finally static binary

113
00:05:07,680 --> 00:05:09,919
instrumentation also want to physically

114
00:05:09,919 --> 00:05:11,600
patch the program to

115
00:05:11,600 --> 00:05:14,800
change to inject the code into the

116
00:05:14,800 --> 00:05:17,199
program

117
00:05:18,080 --> 00:05:20,080
static binary injection has many

118
00:05:20,080 --> 00:05:21,680
advantages

119
00:05:21,680 --> 00:05:23,600
first one it offer much better

120
00:05:23,600 --> 00:05:25,600
performance compared to dynamic

121
00:05:25,600 --> 00:05:29,199
binary instrumentation you can easily

122
00:05:29,199 --> 00:05:31,680
instrument early system code like

123
00:05:31,680 --> 00:05:32,479
firmware

124
00:05:32,479 --> 00:05:36,160
bootloader os kernel and also

125
00:05:36,160 --> 00:05:38,720
static binary injection give you much

126
00:05:38,720 --> 00:05:40,800
better control on the location where you

127
00:05:40,800 --> 00:05:43,199
inject the code into the program and

128
00:05:43,199 --> 00:05:44,320
finally

129
00:05:44,320 --> 00:05:46,479
in some special cases like embedded

130
00:05:46,479 --> 00:05:47,759
system

131
00:05:47,759 --> 00:05:50,840
static binary injection is the only

132
00:05:50,840 --> 00:05:53,840
solution

133
00:05:54,080 --> 00:05:57,280
okay looking at some existing tools

134
00:05:57,280 --> 00:06:00,240
you can see that most stones nowadays

135
00:06:00,240 --> 00:06:02,560
they can only inject shipping charcoal

136
00:06:02,560 --> 00:06:07,680
but not high level binary they are

137
00:06:07,680 --> 00:06:10,240
they always only work on some limited

138
00:06:10,240 --> 00:06:11,280
platforms

139
00:06:11,280 --> 00:06:13,520
and they also limited on the five

140
00:06:13,520 --> 00:06:15,520
formats they can support

141
00:06:15,520 --> 00:06:17,280
so we think that we need a new better

142
00:06:17,280 --> 00:06:18,639
tool

143
00:06:18,639 --> 00:06:21,199
for static manual injection that can

144
00:06:21,199 --> 00:06:23,520
inject high-level binary files

145
00:06:23,520 --> 00:06:27,520
view from c or c plus plus

146
00:06:27,520 --> 00:06:30,880
this tool should work on own cap

147
00:06:30,880 --> 00:06:34,560
os like windows mac os linux and so on

148
00:06:34,560 --> 00:06:37,759
and finally it should support

149
00:06:37,759 --> 00:06:40,800
all popular executable formats

150
00:06:40,800 --> 00:06:44,960
like windows pe module and erf

151
00:06:46,319 --> 00:06:48,639
so the result of this research is a tool

152
00:06:48,639 --> 00:06:51,120
named redpack which is an advanced tool

153
00:06:51,120 --> 00:06:53,680
for static binary injection

154
00:06:53,680 --> 00:06:55,680
replica can inject high level object

155
00:06:55,680 --> 00:06:57,280
files will form c

156
00:06:57,280 --> 00:07:01,039
c plus first into x executable file

157
00:07:01,039 --> 00:07:03,360
that means you can inject windows dll

158
00:07:03,360 --> 00:07:04,960
into excel files

159
00:07:04,960 --> 00:07:07,759
you can inject daily files into match or

160
00:07:07,759 --> 00:07:09,120
executable

161
00:07:09,120 --> 00:07:13,039
we can also inject dot sr files into elf

162
00:07:13,039 --> 00:07:16,080
executable red bike

163
00:07:16,080 --> 00:07:19,360
run on all popular os like windows

164
00:07:19,360 --> 00:07:24,000
mac os linux bsd and red bike support

165
00:07:24,000 --> 00:07:27,520
all the popular firefox like pe micro

166
00:07:27,520 --> 00:07:30,240
and erf

167
00:07:30,240 --> 00:07:34,000
so how we did it so the general ideas

168
00:07:34,000 --> 00:07:37,199
is when we inject code into the

169
00:07:37,199 --> 00:07:38,560
executable file

170
00:07:38,560 --> 00:07:42,080
we leave the code and data section of

171
00:07:42,080 --> 00:07:44,160
the original file is the same place

172
00:07:44,160 --> 00:07:48,479
we do not move code or data around

173
00:07:49,599 --> 00:07:53,599
to contain the new object binary

174
00:07:53,599 --> 00:07:57,120
in the batch file we expand the original

175
00:07:57,120 --> 00:07:59,840
executable file by adding some new

176
00:07:59,840 --> 00:08:00,960
sections

177
00:08:00,960 --> 00:08:03,120
and after that we copy the content from

178
00:08:03,120 --> 00:08:04,400
the object file

179
00:08:04,400 --> 00:08:07,599
to the new sections and because

180
00:08:07,599 --> 00:08:10,879
the object binary will form c c plus

181
00:08:10,879 --> 00:08:14,639
c is mainly for dynamic linker

182
00:08:14,639 --> 00:08:18,080
but not ready for execution so

183
00:08:18,080 --> 00:08:21,280
the new content injected into the output

184
00:08:21,280 --> 00:08:23,759
file need to be relocated

185
00:08:23,759 --> 00:08:25,840
so they can run properly in the new

186
00:08:25,840 --> 00:08:28,159
place

187
00:08:28,560 --> 00:08:32,000
so red pack has

188
00:08:32,000 --> 00:08:34,320
two main challenges the first challenge

189
00:08:34,320 --> 00:08:36,240
is to add new sections

190
00:08:36,240 --> 00:08:39,200
because we need to append new section

191
00:08:39,200 --> 00:08:41,039
but

192
00:08:41,039 --> 00:08:44,240
this activity can break

193
00:08:44,240 --> 00:08:46,959
while such an executive information so

194
00:08:46,959 --> 00:08:48,720
we need to be sure to have a correct

195
00:08:48,720 --> 00:08:50,720
tool to correct on the section alignment

196
00:08:50,720 --> 00:08:51,279
and size

197
00:08:51,279 --> 00:08:54,880
after injection after that we need to

198
00:08:54,880 --> 00:08:55,279
fix

199
00:08:55,279 --> 00:08:58,959
metadata output executable file

200
00:08:58,959 --> 00:09:02,160
to make the whole file legal so we can

201
00:09:02,160 --> 00:09:04,080
run properly

202
00:09:04,080 --> 00:09:07,920
on the system so in this steps you need

203
00:09:07,920 --> 00:09:08,560
to fix

204
00:09:08,560 --> 00:09:10,640
many things in the file headers like

205
00:09:10,640 --> 00:09:13,200
size the total size

206
00:09:13,200 --> 00:09:15,360
the new number of sections the new

207
00:09:15,360 --> 00:09:16,800
checksum

208
00:09:16,800 --> 00:09:19,279
and sometimes we might need to even to

209
00:09:19,279 --> 00:09:20,959
create a new file headers

210
00:09:20,959 --> 00:09:23,279
and new section headers to keep the new

211
00:09:23,279 --> 00:09:25,680
content

212
00:09:25,839 --> 00:09:29,040
the second challenge is relocation so

213
00:09:29,040 --> 00:09:30,959
remember that we

214
00:09:30,959 --> 00:09:33,519
patch the object binary into the target

215
00:09:33,519 --> 00:09:34,640
binary

216
00:09:34,640 --> 00:09:38,560
so we need to relocate the object binary

217
00:09:38,560 --> 00:09:40,640
in the new place

218
00:09:40,640 --> 00:09:44,160
so just few areas we follow we need to

219
00:09:44,160 --> 00:09:44,560
keep

220
00:09:44,560 --> 00:09:46,560
the distance between the code and data

221
00:09:46,560 --> 00:09:47,760
session

222
00:09:47,760 --> 00:09:51,279
in the object binary intact

223
00:09:51,279 --> 00:09:53,920
so because they can still refer each

224
00:09:53,920 --> 00:09:55,600
other

225
00:09:55,600 --> 00:09:58,399
and basically a red pack need to develop

226
00:09:58,399 --> 00:09:58,720
a

227
00:09:58,720 --> 00:10:01,279
special gap static linker to link the

228
00:10:01,279 --> 00:10:02,240
injected

229
00:10:02,240 --> 00:10:05,279
object file with existing

230
00:10:05,279 --> 00:10:08,800
executable binary in the original file

231
00:10:08,800 --> 00:10:11,360
and fabric need to change the metadata

232
00:10:11,360 --> 00:10:12,399
of the

233
00:10:12,399 --> 00:10:14,800
object binary in the new place so the

234
00:10:14,800 --> 00:10:16,160
system dynamical

235
00:10:16,160 --> 00:10:20,880
is aware of the new digital content

236
00:10:20,880 --> 00:10:24,000
and finally we need to avoid patching

237
00:10:24,000 --> 00:10:25,279
any code or data

238
00:10:25,279 --> 00:10:29,360
but only modify the file media metadata

239
00:10:29,360 --> 00:10:31,360
like import function relocation and so

240
00:10:31,360 --> 00:10:33,839
on

241
00:10:34,640 --> 00:10:36,640
okay so now my code speaker will take

242
00:10:36,640 --> 00:10:37,680
over and

243
00:10:37,680 --> 00:10:40,800
he'll show you how he can how right back

244
00:10:40,800 --> 00:10:41,200
and

245
00:10:41,200 --> 00:10:44,480
support macho file format hi

246
00:10:44,480 --> 00:10:47,600
i'm don so now i want to show how

247
00:10:47,600 --> 00:10:51,200
i static inject into much of i and elf

248
00:10:51,200 --> 00:10:54,160
file format first let's take a look at

249
00:10:54,160 --> 00:10:56,320
the much old file format

250
00:10:56,320 --> 00:10:59,200
this kind of file has a header which

251
00:10:59,200 --> 00:11:00,240
includes

252
00:11:00,240 --> 00:11:03,760
magic number cpu type substitute type

253
00:11:03,760 --> 00:11:06,160
number of block commands and total size

254
00:11:06,160 --> 00:11:08,160
upload command

255
00:11:08,160 --> 00:11:11,839
the flux in header also brings some

256
00:11:11,839 --> 00:11:15,839
special bit like mh pi

257
00:11:15,839 --> 00:11:20,480
and mh no hypno execution

258
00:11:20,480 --> 00:11:23,200
then log command padding zone and data

259
00:11:23,200 --> 00:11:24,560
come

260
00:11:24,560 --> 00:11:27,600
low command is a type of handle

261
00:11:27,600 --> 00:11:30,800
that contains information of segments

262
00:11:30,800 --> 00:11:35,360
like text data etc

263
00:11:35,360 --> 00:11:38,480
among other segments lc segment

264
00:11:38,480 --> 00:11:42,079
is noticeable that it guides the loader

265
00:11:42,079 --> 00:11:45,360
to load binary onto memory based

266
00:11:45,360 --> 00:11:48,560
on file size 5 set vmsi

267
00:11:48,560 --> 00:11:51,760
vm address initial protection and max

268
00:11:51,760 --> 00:11:54,319
protection

269
00:11:55,360 --> 00:11:57,600
talking about the challenge when i add

270
00:11:57,600 --> 00:11:58,560
new segments

271
00:11:58,560 --> 00:12:02,320
or sessions i create two new segments

272
00:12:02,320 --> 00:12:06,320
rb text and ib data by putting segments

273
00:12:06,320 --> 00:12:07,120
header

274
00:12:07,120 --> 00:12:10,720
on padding zone and fix some numbers

275
00:12:10,720 --> 00:12:14,160
then i clone all the desired sections

276
00:12:14,160 --> 00:12:14,959
header

277
00:12:14,959 --> 00:12:17,839
append them to these segments and place

278
00:12:17,839 --> 00:12:18,639
their content

279
00:12:18,639 --> 00:12:22,320
at the end of the file however

280
00:12:22,320 --> 00:12:26,320
this can only work for mac os mojave

281
00:12:26,320 --> 00:12:30,399
or older versions so

282
00:12:30,399 --> 00:12:35,920
as you can see here is the new binary

283
00:12:36,839 --> 00:12:39,279
format

284
00:12:39,279 --> 00:12:42,880
next next challenge i have to face

285
00:12:42,880 --> 00:12:46,160
is relocation i chose

286
00:12:46,160 --> 00:12:49,440
to inject a dynamic library to target

287
00:12:49,440 --> 00:12:52,959
binary because every object inside the

288
00:12:52,959 --> 00:12:56,079
library has been relocated

289
00:12:56,079 --> 00:13:00,160
however global pointer are seen offset

290
00:13:00,160 --> 00:13:04,079
not addresses and index of leave system

291
00:13:04,079 --> 00:13:06,079
dot dilap

292
00:13:06,079 --> 00:13:08,240
library may be different from the target

293
00:13:08,240 --> 00:13:09,920
binary

294
00:13:09,920 --> 00:13:12,720
of course and stuff need to be fixed

295
00:13:12,720 --> 00:13:15,120
also

296
00:13:15,200 --> 00:13:18,240
so i take the advantage of dynamic

297
00:13:18,240 --> 00:13:19,040
linker

298
00:13:19,040 --> 00:13:22,399
to handle new contents

299
00:13:23,040 --> 00:13:25,519
the dynamic linker is defined in load

300
00:13:25,519 --> 00:13:26,560
dilingual

301
00:13:26,560 --> 00:13:29,680
load command and there are two types of

302
00:13:29,680 --> 00:13:30,639
symbols

303
00:13:30,639 --> 00:13:35,040
lazy and non-lazy simulpointer design

304
00:13:35,040 --> 00:13:38,880
a die syntax diy symptom low command

305
00:13:38,880 --> 00:13:42,399
store information about offset size and

306
00:13:42,399 --> 00:13:43,600
some kind of

307
00:13:43,600 --> 00:13:48,320
numbers this example here called the

308
00:13:48,320 --> 00:13:50,399
product function

309
00:13:50,399 --> 00:13:53,199
at the beginning the pull s is not

310
00:13:53,199 --> 00:13:54,560
located inside the

311
00:13:54,560 --> 00:13:57,279
binary and it will be bound when the

312
00:13:57,279 --> 00:13:59,680
first score is made

313
00:13:59,680 --> 00:14:03,360
instead pulled holds a pointer point to

314
00:14:03,360 --> 00:14:06,240
stop extraction

315
00:14:06,240 --> 00:14:09,920
that stop call direct the diyld

316
00:14:09,920 --> 00:14:12,560
to find the address to a relevant

317
00:14:12,560 --> 00:14:13,760
function

318
00:14:13,760 --> 00:14:19,439
then it overrides on original pointer

319
00:14:20,079 --> 00:14:23,920
you can see the illustration here

320
00:14:25,199 --> 00:14:28,720
as a segment we need to pay extension

321
00:14:28,720 --> 00:14:33,600
link edit and dll dyld info only

322
00:14:33,600 --> 00:14:36,800
the link edit hosts of course and some

323
00:14:36,800 --> 00:14:38,240
other information

324
00:14:38,240 --> 00:14:41,839
meanwhile dyld informally contains

325
00:14:41,839 --> 00:14:45,120
rebates and binding information

326
00:14:45,120 --> 00:14:48,399
our code actually is a single byte and

327
00:14:48,399 --> 00:14:53,120
encode by you unsigned

328
00:14:53,120 --> 00:14:56,639
you left 128.

329
00:14:56,639 --> 00:14:58,959
the buy by opcode is used to look up

330
00:14:58,959 --> 00:15:00,000
external function

331
00:15:00,000 --> 00:15:03,120
and the rebase of code is used to deal

332
00:15:03,120 --> 00:15:03,680
with

333
00:15:03,680 --> 00:15:07,600
aslr for example

334
00:15:07,600 --> 00:15:11,120
this image so how a sequence of rebase

335
00:15:11,120 --> 00:15:11,680
of opcode

336
00:15:11,680 --> 00:15:16,560
should run firstly is set the type to 1

337
00:15:16,560 --> 00:15:19,920
as a pointer type then

338
00:15:19,920 --> 00:15:22,480
set the current segment index to pulse

339
00:15:22,480 --> 00:15:23,440
pointer

340
00:15:23,440 --> 00:15:27,040
on nanolegacy symbol pointer section

341
00:15:27,040 --> 00:15:29,920
and finally it performs the release one

342
00:15:29,920 --> 00:15:32,160
time

343
00:15:32,160 --> 00:15:35,920
the same extra for binding of code

344
00:15:35,920 --> 00:15:39,360
it finds the location of press set the

345
00:15:39,360 --> 00:15:41,120
index of leave system

346
00:15:41,120 --> 00:15:44,000
restring as name of symbol and then buy

347
00:15:44,000 --> 00:15:45,360
and write the result

348
00:15:45,360 --> 00:15:48,160
to location

349
00:15:48,480 --> 00:15:51,519
so now i have enough abilities

350
00:15:51,519 --> 00:15:55,519
to control the dyld to do what i want

351
00:15:55,519 --> 00:15:58,399
for pointer relocation i clone the

352
00:15:58,399 --> 00:16:00,399
original revised or code

353
00:16:00,399 --> 00:16:04,079
to the end of link edit segment then

354
00:16:04,079 --> 00:16:07,440
append that leaves of code

355
00:16:07,440 --> 00:16:10,079
i also need to fix some information on

356
00:16:10,079 --> 00:16:10,800
segments

357
00:16:10,800 --> 00:16:14,639
header and i not only do the same for

358
00:16:14,639 --> 00:16:15,680
binding of code

359
00:16:15,680 --> 00:16:19,440
but also fix lift systems index

360
00:16:19,440 --> 00:16:24,560
and stack index when pushing arguments

361
00:16:25,120 --> 00:16:29,519
here is a new link edit layout

362
00:16:32,720 --> 00:16:35,440
and here is a sample code to

363
00:16:35,440 --> 00:16:37,040
demonstration

364
00:16:37,040 --> 00:16:39,199
on the left hand side is the target

365
00:16:39,199 --> 00:16:40,320
binary and

366
00:16:40,320 --> 00:16:42,639
on the right hand side is dynamic

367
00:16:42,639 --> 00:16:44,320
library

368
00:16:44,320 --> 00:16:47,279
and now i will inject library to this

369
00:16:47,279 --> 00:16:49,759
binary

370
00:16:49,839 --> 00:16:54,560
first i pass the library to my tool

371
00:16:55,600 --> 00:17:01,120
my second argument is on original binary

372
00:17:01,120 --> 00:17:05,679
then is the the output

373
00:17:05,679 --> 00:17:09,520
after i run you can see the change in

374
00:17:09,520 --> 00:17:12,559
size about binary

375
00:17:12,559 --> 00:17:14,799
meanwhile the new one still remain all

376
00:17:14,799 --> 00:17:15,760
the feature

377
00:17:15,760 --> 00:17:19,839
of the r1

378
00:17:20,559 --> 00:17:24,319
next i would like to discuss about

379
00:17:24,319 --> 00:17:27,439
f5 elf f5

380
00:17:27,439 --> 00:17:30,720
the format has or some headers

381
00:17:30,720 --> 00:17:34,160
symbol table and dynamic simultaneous

382
00:17:34,160 --> 00:17:37,600
in elf f5 segments are also used

383
00:17:37,600 --> 00:17:40,400
to map from file to virtual address

384
00:17:40,400 --> 00:17:42,400
space

385
00:17:42,400 --> 00:17:45,600
there are some sections such as that

386
00:17:45,600 --> 00:17:46,160
data

387
00:17:46,160 --> 00:17:50,320
etc and in order to add new segment

388
00:17:50,320 --> 00:17:53,440
i try to append new data to segments

389
00:17:53,440 --> 00:17:54,480
later

390
00:17:54,480 --> 00:17:58,000
then fix metadata on segments header

391
00:17:58,000 --> 00:18:02,320
or add new segments header if necessary

392
00:18:02,320 --> 00:18:05,360
however there is not

393
00:18:05,360 --> 00:18:09,039
enough space of padding to insert new

394
00:18:09,039 --> 00:18:10,400
header

395
00:18:10,400 --> 00:18:13,919
furthermore some sections are dependent

396
00:18:13,919 --> 00:18:14,240
on

397
00:18:14,240 --> 00:18:17,440
other sections for example there are

398
00:18:17,440 --> 00:18:18,799
many pointers

399
00:18:18,799 --> 00:18:21,679
which point to that text section are

400
00:18:21,679 --> 00:18:22,320
strong

401
00:18:22,320 --> 00:18:25,840
in symbol and dynamic simultaneous

402
00:18:25,840 --> 00:18:29,520
therefore to make it right i create a

403
00:18:29,520 --> 00:18:31,039
kind of graph

404
00:18:31,039 --> 00:18:33,360
of dependencies that if i change the

405
00:18:33,360 --> 00:18:34,880
value of no node

406
00:18:34,880 --> 00:18:39,840
its labels automatically

407
00:18:41,360 --> 00:18:43,840
sorry its neighbor will automatically be

408
00:18:43,840 --> 00:18:44,960
updated

409
00:18:44,960 --> 00:18:48,640
so the new layout look like this

410
00:18:53,520 --> 00:18:56,880
regarding about relocation is simple to

411
00:18:56,880 --> 00:18:58,480
patch the internal data

412
00:18:58,480 --> 00:19:01,840
like relative or global data

413
00:19:01,840 --> 00:19:05,440
to be fixed with new segment then i

414
00:19:05,440 --> 00:19:07,760
leverage the dynamic linker to import

415
00:19:07,760 --> 00:19:09,360
new function

416
00:19:09,360 --> 00:19:12,400
the dynamic linker is defined in dot

417
00:19:12,400 --> 00:19:16,080
interp section it set up

418
00:19:16,080 --> 00:19:19,120
environments based on information of

419
00:19:19,120 --> 00:19:22,799
dynamic sections the linker is a method

420
00:19:22,799 --> 00:19:25,760
called lazy linking to resolve function

421
00:19:25,760 --> 00:19:27,760
reference

422
00:19:27,760 --> 00:19:31,039
with support from dot god and dot plt

423
00:19:31,039 --> 00:19:34,320
sections the program here called

424
00:19:34,320 --> 00:19:37,120
put function

425
00:19:37,360 --> 00:19:41,120
which point do dot got entry of purchase

426
00:19:41,120 --> 00:19:44,720
to its dot plt at low time

427
00:19:44,720 --> 00:19:47,679
after the purest coin is made at the

428
00:19:47,679 --> 00:19:48,799
first time

429
00:19:48,799 --> 00:19:52,160
the p not plt yes control resource

430
00:19:52,160 --> 00:19:52,720
symbol

431
00:19:52,720 --> 00:19:55,760
and then linker will update the dot code

432
00:19:55,760 --> 00:19:56,320
entry

433
00:19:56,320 --> 00:19:59,520
to hold the final value to be used for

434
00:19:59,520 --> 00:20:00,080
future

435
00:20:00,080 --> 00:20:03,679
calls this is how

436
00:20:03,679 --> 00:20:06,159
an entry in dynamics symbol table looks

437
00:20:06,159 --> 00:20:07,039
like

438
00:20:07,039 --> 00:20:09,840
it use the index of symbol on the table

439
00:20:09,840 --> 00:20:10,400
dot

440
00:20:10,400 --> 00:20:14,480
related plt to pass to the

441
00:20:14,480 --> 00:20:17,760
runtime resolve function

442
00:20:20,480 --> 00:20:23,200
the source announce is quite easy we

443
00:20:23,200 --> 00:20:26,000
just add new entry to some sections

444
00:20:26,000 --> 00:20:29,280
and then news and add new search string

445
00:20:29,280 --> 00:20:32,159
and add new string of the symbol name to

446
00:20:32,159 --> 00:20:32,840
string

447
00:20:32,840 --> 00:20:36,080
table of course we have to patch

448
00:20:36,080 --> 00:20:39,440
some value and fix some indexes also

449
00:20:39,440 --> 00:20:42,559
however because we modify offset of

450
00:20:42,559 --> 00:20:43,520
sections

451
00:20:43,520 --> 00:20:46,559
so the binary should be a pie

452
00:20:46,559 --> 00:20:50,000
type to remain the structure here's my

453
00:20:50,000 --> 00:20:51,360
demonstration for

454
00:20:51,360 --> 00:20:54,640
elf f5 format like

455
00:20:54,640 --> 00:20:56,960
what i have done with much of file i

456
00:20:56,960 --> 00:20:58,880
passed the library

457
00:20:58,880 --> 00:21:02,559
and the other original file to my tone

458
00:21:02,559 --> 00:21:06,879
then i run my tool check check

459
00:21:07,200 --> 00:21:10,000
check inside

460
00:21:10,320 --> 00:21:14,840
run the unoriginal one and run the final

461
00:21:14,840 --> 00:21:16,720
one

462
00:21:16,720 --> 00:21:18,880
next method queen will continue our

463
00:21:18,880 --> 00:21:20,880
presentation

464
00:21:20,880 --> 00:21:23,520
okay so now let's see how redback can

465
00:21:23,520 --> 00:21:24,080
inject

466
00:21:24,080 --> 00:21:27,120
into the windows program

467
00:21:27,120 --> 00:21:30,799
so windows program has a format name pe

468
00:21:30,799 --> 00:21:34,320
and have pe format for 32-bit

469
00:21:34,320 --> 00:21:37,440
binary we have pe plus

470
00:21:37,440 --> 00:21:41,520
for 64-bit binary and we have two main

471
00:21:41,520 --> 00:21:42,840
gap

472
00:21:42,840 --> 00:21:45,760
executable binary in windows the first

473
00:21:45,760 --> 00:21:47,840
one is drill which is for

474
00:21:47,840 --> 00:21:51,280
dynamic library and the url material can

475
00:21:51,280 --> 00:21:53,919
depends on many other device

476
00:21:53,919 --> 00:21:56,720
the second very important card binaries

477
00:21:56,720 --> 00:21:57,120
is

478
00:21:57,120 --> 00:22:00,400
excel files which is for program and

479
00:22:00,400 --> 00:22:03,360
one excel file can depends on many other

480
00:22:03,360 --> 00:22:04,720
dll files

481
00:22:04,720 --> 00:22:08,000
so the target of a great mac is

482
00:22:08,000 --> 00:22:11,039
we want to inject dll files into the

483
00:22:11,039 --> 00:22:12,400
excel files

484
00:22:12,400 --> 00:22:15,600
so as output we have a new output excel

485
00:22:15,600 --> 00:22:16,240
file

486
00:22:16,240 --> 00:22:18,640
that includes all the original excel

487
00:22:18,640 --> 00:22:22,799
files and also injected delay files

488
00:22:23,280 --> 00:22:27,200
okay so windows have its own

489
00:22:27,200 --> 00:22:30,320
dynamic loader linker and

490
00:22:30,320 --> 00:22:33,919
we must understand very well how the

491
00:22:33,919 --> 00:22:37,039
loader and linker in windows work so

492
00:22:37,039 --> 00:22:40,080
we can make that back to

493
00:22:40,080 --> 00:22:43,039
be compatible with all the process so

494
00:22:43,039 --> 00:22:45,280
the output binary can be

495
00:22:45,280 --> 00:22:50,158
properly run on windows system

496
00:22:50,799 --> 00:22:53,679
so p file format is actually very

497
00:22:53,679 --> 00:22:54,559
complicated

498
00:22:54,559 --> 00:22:57,520
and we do not have enough time here so i

499
00:22:57,520 --> 00:22:58,000
just

500
00:22:58,000 --> 00:23:01,600
mentioned some important points

501
00:23:01,600 --> 00:23:05,200
so b files has a header name

502
00:23:05,200 --> 00:23:09,120
empty header tell you

503
00:23:09,120 --> 00:23:11,120
more about other headers like fire

504
00:23:11,120 --> 00:23:14,639
headers and optional headers

505
00:23:15,280 --> 00:23:17,039
fire headers has some important

506
00:23:17,039 --> 00:23:19,679
important information like the number of

507
00:23:19,679 --> 00:23:23,039
sections and the type option and headers

508
00:23:23,039 --> 00:23:26,000
so we can locate the where the ocean and

509
00:23:26,000 --> 00:23:27,440
header start in the memory

510
00:23:27,440 --> 00:23:30,000
on the disk

511
00:23:30,640 --> 00:23:33,679
after the finder is optional header and

512
00:23:33,679 --> 00:23:34,720
this header has

513
00:23:34,720 --> 00:23:37,200
many important information like the

514
00:23:37,200 --> 00:23:39,200
ngpoi

515
00:23:39,200 --> 00:23:42,960
the base of the files in the memory

516
00:23:42,960 --> 00:23:46,159
section alignment file alignment the

517
00:23:46,159 --> 00:23:46,559
size

518
00:23:46,559 --> 00:23:50,720
emits files in the memory the checksum

519
00:23:50,720 --> 00:23:52,880
and just one important structure name

520
00:23:52,880 --> 00:23:56,000
data directory

521
00:23:56,240 --> 00:23:59,200
which is very important structure

522
00:23:59,200 --> 00:24:00,000
because it

523
00:24:00,000 --> 00:24:03,600
points to many important metadata

524
00:24:03,600 --> 00:24:06,799
pe file and

525
00:24:06,799 --> 00:24:09,919
data d3 actually

526
00:24:09,919 --> 00:24:13,520
contain many other directory

527
00:24:13,520 --> 00:24:17,120
so we have directory for export

528
00:24:17,120 --> 00:24:19,520
export function we have data for import

529
00:24:19,520 --> 00:24:22,159
function regulatory for

530
00:24:22,159 --> 00:24:26,159
relocation table directory for

531
00:24:26,159 --> 00:24:29,760
import address table and so on

532
00:24:30,559 --> 00:24:33,279
so 1p file can have many section and

533
00:24:33,279 --> 00:24:33,600
each

534
00:24:33,600 --> 00:24:36,400
section have one section header and each

535
00:24:36,400 --> 00:24:38,480
section header point you

536
00:24:38,480 --> 00:24:41,520
to the location of the section in the

537
00:24:41,520 --> 00:24:42,480
memory

538
00:24:42,480 --> 00:24:47,440
the size

539
00:24:47,440 --> 00:24:50,640
and uh we have

540
00:24:50,640 --> 00:24:54,000
some very important entries

541
00:24:54,000 --> 00:24:57,520
in the directory entries that one is

542
00:24:57,520 --> 00:25:02,640
import and which tell you how to

543
00:25:02,640 --> 00:25:05,200
tell which tells the system loader and

544
00:25:05,200 --> 00:25:06,000
linker

545
00:25:06,000 --> 00:25:09,600
how to locate the

546
00:25:09,600 --> 00:25:13,039
derails that this program depend on

547
00:25:13,039 --> 00:25:16,159
and which function the program needs to

548
00:25:16,159 --> 00:25:16,720
load on

549
00:25:16,720 --> 00:25:19,279
into the memory to make the program run

550
00:25:19,279 --> 00:25:20,960
properly

551
00:25:20,960 --> 00:25:24,159
so have import descriptor you have 10

552
00:25:24,159 --> 00:25:24,880
data

553
00:25:24,880 --> 00:25:28,000
which tell us where to locate

554
00:25:28,000 --> 00:25:31,039
the imported function from each dll

555
00:25:31,039 --> 00:25:34,480
on list and in the memory

556
00:25:36,480 --> 00:25:39,200
so we see that red mic need to add a new

557
00:25:39,200 --> 00:25:39,840
section

558
00:25:39,840 --> 00:25:42,880
into two for the injection

559
00:25:42,880 --> 00:25:46,880
so to create a new section we

560
00:25:46,880 --> 00:25:49,440
append a section new section at the end

561
00:25:49,440 --> 00:25:50,480
of the

562
00:25:50,480 --> 00:25:53,520
original program and after that we need

563
00:25:53,520 --> 00:25:54,960
to analyze them

564
00:25:54,960 --> 00:25:59,760
so they can be recognized by the system

565
00:25:59,760 --> 00:26:02,320
so the site resolution need to fit the

566
00:26:02,320 --> 00:26:04,159
injected object file

567
00:26:04,159 --> 00:26:06,400
so we need to adjust the virtual size

568
00:26:06,400 --> 00:26:09,279
the size operator

569
00:26:09,279 --> 00:26:13,200
and we need to align the session

570
00:26:13,200 --> 00:26:17,600
as well in the memory and actually

571
00:26:17,600 --> 00:26:19,760
we need to append not only one but

572
00:26:19,760 --> 00:26:20,720
probably many

573
00:26:20,720 --> 00:26:24,240
sections like session for program

574
00:26:24,240 --> 00:26:27,360
for code for data for read-only data

575
00:26:27,360 --> 00:26:31,279
for imported data and for relocation

576
00:26:31,279 --> 00:26:34,559
so after after we append the new section

577
00:26:34,559 --> 00:26:37,520
we need to fix the b header so we need

578
00:26:37,520 --> 00:26:39,679
to fix the size of total headers

579
00:26:39,679 --> 00:26:43,760
you need to fix the size of total image

580
00:26:43,760 --> 00:26:47,039
need to fix the size total code in the

581
00:26:47,039 --> 00:26:48,000
program

582
00:26:48,000 --> 00:26:49,679
and finally you need to pump up the

583
00:26:49,679 --> 00:26:53,360
number of sections

584
00:26:53,360 --> 00:26:56,559
so after we add the new section

585
00:26:56,559 --> 00:27:00,559
we copy the object

586
00:27:00,960 --> 00:27:04,400
binary from the draft files into the new

587
00:27:04,400 --> 00:27:05,679
sections

588
00:27:05,679 --> 00:27:08,240
and there's one important thing to do we

589
00:27:08,240 --> 00:27:08,720
need to

590
00:27:08,720 --> 00:27:12,480
relocate them so each

591
00:27:12,480 --> 00:27:16,320
xj file has one relocation section

592
00:27:16,320 --> 00:27:19,600
named reload and also the object files

593
00:27:19,600 --> 00:27:20,320
urls

594
00:27:20,320 --> 00:27:24,000
also have its own reload dot relocations

595
00:27:24,000 --> 00:27:27,039
however as a output program

596
00:27:27,039 --> 00:27:29,279
windows only recognize only one

597
00:27:29,279 --> 00:27:30,080
relocation

598
00:27:30,080 --> 00:27:33,279
relocation section so

599
00:27:33,279 --> 00:27:35,840
we have to do some checks here so we

600
00:27:35,840 --> 00:27:36,320
open

601
00:27:36,320 --> 00:27:39,360
a new big section for relocation

602
00:27:39,360 --> 00:27:42,720
and after that we copy the dot

603
00:27:42,720 --> 00:27:45,200
reload section of the target of the

604
00:27:45,200 --> 00:27:46,559
original program

605
00:27:46,559 --> 00:27:50,080
and also the dot relog section of the

606
00:27:50,080 --> 00:27:52,960
dll files there and after that you need

607
00:27:52,960 --> 00:27:55,039
to relocate them

608
00:27:55,039 --> 00:27:58,880
and finally you need to fix the ng

609
00:27:58,880 --> 00:28:02,399
in the directory directory for this new

610
00:28:02,399 --> 00:28:06,080
reload reload reconstruction

611
00:28:06,080 --> 00:28:10,000
and beside the relocation section

612
00:28:10,000 --> 00:28:12,240
we have to repeat the same process for

613
00:28:12,240 --> 00:28:13,200
important

614
00:28:13,200 --> 00:28:17,520
table so because uh one extra file only

615
00:28:17,520 --> 00:28:17,919
allow

616
00:28:17,919 --> 00:28:20,960
one import directory so we also need to

617
00:28:20,960 --> 00:28:24,000
append a new which section for import

618
00:28:24,000 --> 00:28:27,440
uh import tables

619
00:28:27,440 --> 00:28:31,840
so we do the same thing very similar

620
00:28:32,799 --> 00:28:36,799
okay so one thing you

621
00:28:36,799 --> 00:28:38,640
need to pay attention is that because

622
00:28:38,640 --> 00:28:41,760
the code in the new

623
00:28:41,760 --> 00:28:44,960
the code coming from the dll files need

624
00:28:44,960 --> 00:28:45,679
to

625
00:28:45,679 --> 00:28:48,559
be execute need to be executed at

626
00:28:48,559 --> 00:28:49,440
runtime

627
00:28:49,440 --> 00:28:52,320
and the code there can refer to the

628
00:28:52,320 --> 00:28:54,960
other imported function or variables

629
00:28:54,960 --> 00:28:57,520
so we need to have some relocation for

630
00:28:57,520 --> 00:28:59,279
imported function azure

631
00:28:59,279 --> 00:29:02,399
so to do this we need to add

632
00:29:02,399 --> 00:29:05,440
new entries for a imported function

633
00:29:05,440 --> 00:29:08,559
in the injected object files and reply

634
00:29:08,559 --> 00:29:10,399
actually append a new data session for

635
00:29:10,399 --> 00:29:11,520
imported function

636
00:29:11,520 --> 00:29:14,320
and after that it copies the imported

637
00:29:14,320 --> 00:29:14,799
entry

638
00:29:14,799 --> 00:29:17,679
from the target program and also we need

639
00:29:17,679 --> 00:29:19,520
to copy the imported entity from the

640
00:29:19,520 --> 00:29:20,480
object files

641
00:29:20,480 --> 00:29:24,080
onto the new entries in the

642
00:29:24,080 --> 00:29:27,200
new input sections

643
00:29:27,200 --> 00:29:30,559
and finally repack need to fix import a

644
00:29:30,559 --> 00:29:31,279
rest table

645
00:29:31,279 --> 00:29:34,640
of the injected entries so the program

646
00:29:34,640 --> 00:29:38,399
the final program can run properly

647
00:29:38,960 --> 00:29:42,399
so we have a very short demo for red mac

648
00:29:42,399 --> 00:29:45,120
so you can see how redback can inject

649
00:29:45,120 --> 00:29:47,200
dual files into the

650
00:29:47,200 --> 00:29:49,840
xfiles

651
00:29:50,320 --> 00:29:53,760
so in this demo we have a very simple

652
00:29:53,760 --> 00:29:55,360
program named hello one

653
00:29:55,360 --> 00:29:57,440
and you can see here this hello one does

654
00:29:57,440 --> 00:29:59,039
nothing but just print

655
00:29:59,039 --> 00:30:02,000
hell you want to do to do this to them

656
00:30:02,000 --> 00:30:04,320
to the console

657
00:30:04,320 --> 00:30:07,520
and we have another source code for dll

658
00:30:07,520 --> 00:30:08,480
files

659
00:30:08,480 --> 00:30:12,480
and this dfl actually also very simple

660
00:30:12,480 --> 00:30:13,679
it does nothing but

661
00:30:13,679 --> 00:30:17,039
print injected to the to the

662
00:30:17,039 --> 00:30:20,080
monitor and it exit so we

663
00:30:20,080 --> 00:30:23,919
want to inject this injection files

664
00:30:23,919 --> 00:30:27,279
into the hello world file

665
00:30:27,760 --> 00:30:31,520
so we build the heron file and

666
00:30:31,520 --> 00:30:34,159
inject the true files into some binaries

667
00:30:34,159 --> 00:30:36,159
and you can see here

668
00:30:36,159 --> 00:30:39,200
so the we build the hello dossier

669
00:30:39,200 --> 00:30:42,720
and we have the hello one 64 dot exe

670
00:30:42,720 --> 00:30:43,760
file

671
00:30:43,760 --> 00:30:46,960
and we view injection dot c

672
00:30:46,960 --> 00:30:50,559
to inject you dll

673
00:30:50,559 --> 00:30:53,679
now we want to inject this injection

674
00:30:53,679 --> 00:30:58,240
city turkey well into insect 62

675
00:30:58,240 --> 00:31:01,679
director so first i can

676
00:31:01,679 --> 00:31:05,039
and run the hello one so you can see

677
00:31:05,039 --> 00:31:08,240
what it does so the hellon

678
00:31:08,240 --> 00:31:10,880
60. files done nothing but just print

679
00:31:10,880 --> 00:31:13,440
out hello onto the monitor

680
00:31:13,440 --> 00:31:17,120
and now i run right back

681
00:31:17,120 --> 00:31:19,918
so my tune

682
00:31:20,559 --> 00:31:23,600
will take one input

683
00:31:23,600 --> 00:31:27,279
which is the dl file as a first argument

684
00:31:27,279 --> 00:31:30,480
and after that the second argument is a

685
00:31:30,480 --> 00:31:32,799
name of the excel files that we want to

686
00:31:32,799 --> 00:31:33,840
inject into

687
00:31:33,840 --> 00:31:36,320
and the final argument of redback is the

688
00:31:36,320 --> 00:31:38,480
name of the output file which is

689
00:31:38,480 --> 00:31:43,760
hello1 minus rbi.j

690
00:31:43,760 --> 00:31:47,840
so i run this command

691
00:31:53,840 --> 00:31:57,039
yeah you can see that redtac takes the

692
00:31:57,039 --> 00:31:57,760
insect

693
00:31:57,760 --> 00:32:00,960
62 dot url

694
00:32:00,960 --> 00:32:04,399
and inject the text section dot

695
00:32:04,399 --> 00:32:08,320
our data session dot

696
00:32:08,320 --> 00:32:11,440
data session dot identification

697
00:32:11,440 --> 00:32:14,799
into halo164.exe and as

698
00:32:14,799 --> 00:32:18,320
output it generates the new

699
00:32:18,320 --> 00:32:21,679
excel files name hello one 64 minus

700
00:32:21,679 --> 00:32:23,279
rp.exe

701
00:32:23,279 --> 00:32:26,720
and now let's try to run this

702
00:32:26,720 --> 00:32:30,240
new batch file

703
00:32:31,360 --> 00:32:34,639
so you can see that you have the new

704
00:32:34,960 --> 00:32:38,080
file here and

705
00:32:38,080 --> 00:32:40,880
this one is already has a injected dll

706
00:32:40,880 --> 00:32:42,000
file inside

707
00:32:42,000 --> 00:32:44,960
so let me run this

708
00:32:46,880 --> 00:32:51,360
hello one ct minus rb.exe

709
00:32:51,600 --> 00:32:54,240
so you see that now the injected file

710
00:32:54,240 --> 00:32:55,600
the batch file

711
00:32:55,600 --> 00:32:58,720
just print out issued as output and exit

712
00:32:58,720 --> 00:33:00,080
which is totally different from the

713
00:33:00,080 --> 00:33:02,879
original value

714
00:33:06,960 --> 00:33:08,840
okay that's it and here come my

715
00:33:08,840 --> 00:33:10,960
conclusion red black is

716
00:33:10,960 --> 00:33:13,440
an advanced tune for static binary

717
00:33:13,440 --> 00:33:14,480
injection

718
00:33:14,480 --> 00:33:16,799
it can inject high level binaries object

719
00:33:16,799 --> 00:33:17,519
files

720
00:33:17,519 --> 00:33:20,559
view from high level language like c

721
00:33:20,559 --> 00:33:24,880
or c plus plus and it works on many

722
00:33:24,880 --> 00:33:29,360
os like windows mac os linux bsd

723
00:33:29,360 --> 00:33:32,080
and it supports multiple executable

724
00:33:32,080 --> 00:33:32,640
formats

725
00:33:32,640 --> 00:33:36,880
like windows b match o or ef

726
00:33:36,880 --> 00:33:39,519
and we are going to release right back

727
00:33:39,519 --> 00:33:41,760
with the full source code to

728
00:33:41,760 --> 00:33:44,480
the internet to the public after our

729
00:33:44,480 --> 00:33:44,880
talk

730
00:33:44,880 --> 00:33:47,919
and you can check our website

731
00:33:47,919 --> 00:33:50,880
rao x dot io right back for release

732
00:33:50,880 --> 00:33:54,240
announcement thank you

733
00:33:54,399 --> 00:33:57,799
and now come the question in answer

734
00:33:57,799 --> 00:34:00,799
session

