1
00:00:02,159 --> 00:00:03,760
hi everyone welcome to my talk

2
00:00:03,760 --> 00:00:05,600
walking your dog in multiple forests

3
00:00:05,600 --> 00:00:07,200
breaking 80 trust boundaries through

4
00:00:07,200 --> 00:00:08,800
gabriel's vulnerabilities

5
00:00:08,800 --> 00:00:10,559
my name is joking malma and today i will

6
00:00:10,559 --> 00:00:12,480
be talking about some interesting camera

7
00:00:12,480 --> 00:00:13,200
stuff

8
00:00:13,200 --> 00:00:15,200
first bit about me i'm der kyon i live

9
00:00:15,200 --> 00:00:17,119
in the netherlands i do a combination of

10
00:00:17,119 --> 00:00:18,720
hacking right teaming and researching at

11
00:00:18,720 --> 00:00:19,680
voxite

12
00:00:19,680 --> 00:00:21,920
and i also like to write tools usually

13
00:00:21,920 --> 00:00:24,320
focused on active directory or azure id

14
00:00:24,320 --> 00:00:26,960
and i write about those on my blog or

15
00:00:26,960 --> 00:00:28,560
tweet about it on my twitter account so

16
00:00:28,560 --> 00:00:29,760
if you're interested

17
00:00:29,760 --> 00:00:32,399
definitely do check that out what i'll

18
00:00:32,399 --> 00:00:34,079
be talking about today is

19
00:00:34,079 --> 00:00:36,480
cabrals and especially focused on forest

20
00:00:36,480 --> 00:00:37,360
trusts

21
00:00:37,360 --> 00:00:39,360
so we start with a quick overview of how

22
00:00:39,360 --> 00:00:41,280
kerose works across domains

23
00:00:41,280 --> 00:00:43,520
then we move to forest and domain trusts

24
00:00:43,520 --> 00:00:45,440
what they mean and what they do

25
00:00:45,440 --> 00:00:47,200
looking at trust transitivity and what

26
00:00:47,200 --> 00:00:49,280
exactly transitivity is

27
00:00:49,280 --> 00:00:51,360
breaking forest trust is the conclusion

28
00:00:51,360 --> 00:00:52,800
where we

29
00:00:52,800 --> 00:00:54,640
can dive into the technical details of

30
00:00:54,640 --> 00:00:56,320
the whole attack path that

31
00:00:56,320 --> 00:00:59,920
i developed so let's have a simple

32
00:00:59,920 --> 00:01:00,879
reminder

33
00:01:00,879 --> 00:01:03,680
of the camera's terminology the most

34
00:01:03,680 --> 00:01:04,239
important

35
00:01:04,239 --> 00:01:05,680
thing is that camera is all about

36
00:01:05,680 --> 00:01:08,000
tickets so the first is a tgt or a

37
00:01:08,000 --> 00:01:09,439
ticket granting ticket

38
00:01:09,439 --> 00:01:11,280
which is given by the domain controller

39
00:01:11,280 --> 00:01:13,040
to an authenticated user

40
00:01:13,040 --> 00:01:16,240
they prove that they are the user by

41
00:01:16,240 --> 00:01:16,799
sending

42
00:01:16,799 --> 00:01:19,360
along their the password and then the dc

43
00:01:19,360 --> 00:01:20,799
gives back a ticket granting tickets

44
00:01:20,799 --> 00:01:22,799
that they can use to request other cargo

45
00:01:22,799 --> 00:01:24,159
tickets

46
00:01:24,159 --> 00:01:26,080
one such ticket that they can request is

47
00:01:26,080 --> 00:01:27,280
a service ticket

48
00:01:27,280 --> 00:01:28,799
and a service ticket can be used to

49
00:01:28,799 --> 00:01:30,479
authenticate against services that

50
00:01:30,479 --> 00:01:32,159
accept cabros authentication

51
00:01:32,159 --> 00:01:35,439
for example file servers or web servers

52
00:01:35,439 --> 00:01:38,400
an important component of the det and

53
00:01:38,400 --> 00:01:38,720
also

54
00:01:38,720 --> 00:01:40,799
the service ticket is the privilege

55
00:01:40,799 --> 00:01:42,159
attribute certificate or

56
00:01:42,159 --> 00:01:45,280
back this is a

57
00:01:45,280 --> 00:01:47,680
piece of data that basically describes

58
00:01:47,680 --> 00:01:49,360
all the rights and

59
00:01:49,360 --> 00:01:51,840
groups that the user is in so it

60
00:01:51,840 --> 00:01:54,720
contains a lot of security identifiers

61
00:01:54,720 --> 00:01:56,640
which are basically the unique ids

62
00:01:56,640 --> 00:01:58,079
within a given domain

63
00:01:58,079 --> 00:02:01,119
of groups and users and

64
00:02:01,119 --> 00:02:02,880
these tell the server that you're

65
00:02:02,880 --> 00:02:04,240
authenticating to

66
00:02:04,240 --> 00:02:06,000
which groups you're in without it having

67
00:02:06,000 --> 00:02:07,360
to query the domain controller

68
00:02:07,360 --> 00:02:08,399
separately

69
00:02:08,399 --> 00:02:09,919
and we'll be seeing a lot of these

70
00:02:09,919 --> 00:02:11,680
security identifiers throughout this

71
00:02:11,680 --> 00:02:12,319
talk so

72
00:02:12,319 --> 00:02:14,319
keep them in mind and there's an example

73
00:02:14,319 --> 00:02:16,080
of how a security identifier looks

74
00:02:16,080 --> 00:02:19,280
on the bottom of the slide some really

75
00:02:19,280 --> 00:02:20,080
important

76
00:02:20,080 --> 00:02:22,080
points about care bros keros is

77
00:02:22,080 --> 00:02:23,200
decentralized

78
00:02:23,200 --> 00:02:25,599
so the dc doesn't keep track of all the

79
00:02:25,599 --> 00:02:26,480
details

80
00:02:26,480 --> 00:02:29,280
that it gave to people but the tickets

81
00:02:29,280 --> 00:02:30,239
themselves are

82
00:02:30,239 --> 00:02:33,280
proof that it is a legitimate ticket

83
00:02:33,280 --> 00:02:36,239
by by being encrypted with the passwords

84
00:02:36,239 --> 00:02:38,160
that only the domain troll knows

85
00:02:38,160 --> 00:02:40,160
so the trust in kerberos is based on

86
00:02:40,160 --> 00:02:41,280
cryptography

87
00:02:41,280 --> 00:02:44,000
and we'll see how that works like this

88
00:02:44,000 --> 00:02:45,120
and before

89
00:02:45,120 --> 00:02:47,280
we dive into it i just want to do a

90
00:02:47,280 --> 00:02:48,800
quick show of how the

91
00:02:48,800 --> 00:02:53,200
um the keras authentication work

92
00:02:53,840 --> 00:02:57,920
so if we look at a common example the

93
00:02:57,920 --> 00:02:59,360
client that wants to attend the gate to

94
00:02:59,360 --> 00:03:01,120
a server

95
00:03:01,120 --> 00:03:04,239
first the client will talk to the dc

96
00:03:04,239 --> 00:03:07,120
when it logs in and it will say hey i'm

97
00:03:07,120 --> 00:03:08,400
a client

98
00:03:08,400 --> 00:03:10,080
please give me a ticket granting ticket

99
00:03:10,080 --> 00:03:11,840
and then it proves that it's actually

100
00:03:11,840 --> 00:03:13,680
who it says this by

101
00:03:13,680 --> 00:03:16,239
encrypting the request with the password

102
00:03:16,239 --> 00:03:18,400
so the ndc knows that the client

103
00:03:18,400 --> 00:03:20,400
is who says it is and it gives the

104
00:03:20,400 --> 00:03:23,680
client a ticket granted ticket

105
00:03:23,680 --> 00:03:26,799
then later on the client can the client

106
00:03:26,799 --> 00:03:29,120
can send this ged back to the server

107
00:03:29,120 --> 00:03:31,440
and actually request a service ticket

108
00:03:31,440 --> 00:03:33,040
and the service ticket

109
00:03:33,040 --> 00:03:35,519
they can use to log in on the server and

110
00:03:35,519 --> 00:03:37,760
the dc knows that the tgt is legitimate

111
00:03:37,760 --> 00:03:39,360
because it's encrypted with the password

112
00:03:39,360 --> 00:03:41,120
of the kbt account

113
00:03:41,120 --> 00:03:42,480
this is only known by the domain

114
00:03:42,480 --> 00:03:44,879
controllers and that's how it knows

115
00:03:44,879 --> 00:03:46,720
that the ticket is legitimate because

116
00:03:46,720 --> 00:03:48,319
it's encrypted with something that's

117
00:03:48,319 --> 00:03:51,280
only doing so it's supposed to know so

118
00:03:51,280 --> 00:03:52,239
the main controller

119
00:03:52,239 --> 00:03:56,319
then gives back a service ticket or sd

120
00:03:56,319 --> 00:03:58,400
and this service ticket is no longer

121
00:03:58,400 --> 00:04:00,640
encrypted with the

122
00:04:00,640 --> 00:04:03,360
the password of the kbtg account but

123
00:04:03,360 --> 00:04:04,720
it's now encrypted with the password of

124
00:04:04,720 --> 00:04:07,200
the service account

125
00:04:07,200 --> 00:04:09,680
so the service account in this case can

126
00:04:09,680 --> 00:04:10,720
be the account

127
00:04:10,720 --> 00:04:13,840
that's used that's the computer account

128
00:04:13,840 --> 00:04:14,959
on the server

129
00:04:14,959 --> 00:04:16,880
and if we send this service ticket to

130
00:04:16,880 --> 00:04:18,959
the server the server can trust that

131
00:04:18,959 --> 00:04:20,560
it's valid because it's encrypted with

132
00:04:20,560 --> 00:04:21,040
its own

133
00:04:21,040 --> 00:04:22,880
passwords so only that server can

134
00:04:22,880 --> 00:04:25,199
encrypt it and by being able to decrypt

135
00:04:25,199 --> 00:04:25,520
it

136
00:04:25,520 --> 00:04:29,440
it's kind of proven that the server

137
00:04:29,440 --> 00:04:31,040
the user got the tickets from the

138
00:04:31,040 --> 00:04:32,800
legitimate domain network because only

139
00:04:32,800 --> 00:04:34,560
the main guitar is supposed to know

140
00:04:34,560 --> 00:04:36,000
the password of the account on the

141
00:04:36,000 --> 00:04:38,400
server

142
00:04:41,040 --> 00:04:43,280
and some important points that i just

143
00:04:43,280 --> 00:04:44,160
mentioned

144
00:04:44,160 --> 00:04:46,320
and the link controller press the td

145
00:04:46,320 --> 00:04:48,240
because it's encrypted with its password

146
00:04:48,240 --> 00:04:50,320
and the service trustee service ticket

147
00:04:50,320 --> 00:04:51,759
because it's encrypted with its own

148
00:04:51,759 --> 00:04:53,280
password

149
00:04:53,280 --> 00:04:56,800
now most times i said um in most cases

150
00:04:56,800 --> 00:04:57,680
only the

151
00:04:57,680 --> 00:05:00,000
dc will know the passwords and there are

152
00:05:00,000 --> 00:05:01,680
some common attacks and backers

153
00:05:01,680 --> 00:05:04,000
that abuse this so if your id is

154
00:05:04,000 --> 00:05:05,199
compromised

155
00:05:05,199 --> 00:05:06,800
attacker can dump the password and then

156
00:05:06,800 --> 00:05:08,560
create their own tickets these are

157
00:05:08,560 --> 00:05:09,600
called golden tickets

158
00:05:09,600 --> 00:05:11,440
you can basically create a ticket that

159
00:05:11,440 --> 00:05:14,240
contains any information that you want

160
00:05:14,240 --> 00:05:16,320
if you compromise the service passwords

161
00:05:16,320 --> 00:05:18,639
you can create silver tickets which are

162
00:05:18,639 --> 00:05:20,320
quite similar but in this case they're

163
00:05:20,320 --> 00:05:21,520
encrypted with the password of the

164
00:05:21,520 --> 00:05:23,039
service that you're attending

165
00:05:23,039 --> 00:05:26,479
so these are called silver tickets

166
00:05:28,160 --> 00:05:30,080
now what we're talking about today is

167
00:05:30,080 --> 00:05:31,199
trusts and

168
00:05:31,199 --> 00:05:34,240
especially forest trust a forest stress

169
00:05:34,240 --> 00:05:36,000
is different from a domain trust

170
00:05:36,000 --> 00:05:37,680
on the left we see a forest with two

171
00:05:37,680 --> 00:05:39,280
domains first a

172
00:05:39,280 --> 00:05:42,240
and subdomain and in in this forest the

173
00:05:42,240 --> 00:05:44,160
domains trust each other but all domains

174
00:05:44,160 --> 00:05:45,600
are equal and if you compromise one

175
00:05:45,600 --> 00:05:46,160
domain

176
00:05:46,160 --> 00:05:48,240
you can basically and use the legitimate

177
00:05:48,240 --> 00:05:49,600
functionality to

178
00:05:49,600 --> 00:05:52,400
compromise the whole forest first on the

179
00:05:52,400 --> 00:05:54,000
other hand is supposed to

180
00:05:54,000 --> 00:05:56,160
be a security boundary and you're not

181
00:05:56,160 --> 00:05:57,840
supposed to be able to

182
00:05:57,840 --> 00:06:01,039
go from first a to force b

183
00:06:01,039 --> 00:06:04,319
in by default however the truss is

184
00:06:04,319 --> 00:06:06,319
usually set up to allow people to

185
00:06:06,319 --> 00:06:08,080
authenticate from first a

186
00:06:08,080 --> 00:06:10,160
into first b so if someone is actually

187
00:06:10,160 --> 00:06:11,680
given permissions in force b

188
00:06:11,680 --> 00:06:16,479
then well that's intended so it's not a

189
00:06:18,840 --> 00:06:20,560
vulnerability

190
00:06:20,560 --> 00:06:22,080
let's have a look at how kerberos

191
00:06:22,080 --> 00:06:26,400
authentication looks across trusts

192
00:06:28,400 --> 00:06:31,520
so in this case we have two parts we

193
00:06:31,520 --> 00:06:32,240
have force a

194
00:06:32,240 --> 00:06:34,800
and force b and once again we are client

195
00:06:34,800 --> 00:06:35,680
enforced a

196
00:06:35,680 --> 00:06:38,319
but we want to reach the server in first

197
00:06:38,319 --> 00:06:39,280
b

198
00:06:39,280 --> 00:06:41,759
what client a will do is we'll simply

199
00:06:41,759 --> 00:06:42,400
ask

200
00:06:42,400 --> 00:06:44,800
the domain controller hey i want to

201
00:06:44,800 --> 00:06:45,840
authenticate

202
00:06:45,840 --> 00:06:49,440
in force b on server b

203
00:06:49,440 --> 00:06:51,199
and the client doesn't know that in a

204
00:06:51,199 --> 00:06:52,800
different forest but basically it's

205
00:06:52,800 --> 00:06:54,240
asked the domain controller

206
00:06:54,240 --> 00:06:56,960
and the domain and sensitivity along the

207
00:06:56,960 --> 00:06:57,840
domain controller

208
00:06:57,840 --> 00:07:02,800
would then send a special tt

209
00:07:02,800 --> 00:07:06,080
which is atgt that is that belongs to

210
00:07:06,080 --> 00:07:08,400
forest a

211
00:07:08,400 --> 00:07:12,319
but is in fact assigned with a crust key

212
00:07:12,319 --> 00:07:14,880
that is part of forest b so when there

213
00:07:14,880 --> 00:07:15,520
there's a

214
00:07:15,520 --> 00:07:17,759
forest trust set up a trust key is

215
00:07:17,759 --> 00:07:18,720
exchanged

216
00:07:18,720 --> 00:07:20,319
and both sides have this key in

217
00:07:20,319 --> 00:07:21,919
possession and that they can exchange

218
00:07:21,919 --> 00:07:23,840
scarborough tickets and they know it's

219
00:07:23,840 --> 00:07:25,840
a legitimate ticket because it's signed

220
00:07:25,840 --> 00:07:27,919
by the trust key

221
00:07:27,919 --> 00:07:31,039
so the client can use this inter-realm

222
00:07:31,039 --> 00:07:33,120
tdt as we call it

223
00:07:33,120 --> 00:07:36,160
to request a service ticket in 4xb

224
00:07:36,160 --> 00:07:38,000
and the dcm4sb would then check the

225
00:07:38,000 --> 00:07:39,280
ticket and it will

226
00:07:39,280 --> 00:07:42,880
send back a service ticket

227
00:07:43,280 --> 00:07:45,280
which the client can use to authenticate

228
00:07:45,280 --> 00:07:47,039
to server b

229
00:07:47,039 --> 00:07:49,440
now there is one additional point i

230
00:07:49,440 --> 00:07:50,560
wrote a small

231
00:07:50,560 --> 00:07:53,759
filter here because there is a part

232
00:07:53,759 --> 00:07:55,919
called sid filtering

233
00:07:55,919 --> 00:07:57,599
and what it means is that you cannot

234
00:07:57,599 --> 00:08:00,800
simply put anything in the ticket

235
00:08:00,800 --> 00:08:02,560
when you exchange it in a different

236
00:08:02,560 --> 00:08:05,199
forest because what we said before is

237
00:08:05,199 --> 00:08:06,800
that we assume there is a boundary

238
00:08:06,800 --> 00:08:08,160
between these forests

239
00:08:08,160 --> 00:08:11,360
and you're not supposed to simply if you

240
00:08:11,360 --> 00:08:12,639
compromise first a

241
00:08:12,639 --> 00:08:14,080
you're not supposed to simply create

242
00:08:14,080 --> 00:08:16,080
your gdt which can say

243
00:08:16,080 --> 00:08:18,160
that you have for example a high roll a

244
00:08:18,160 --> 00:08:20,240
domain admin in force b

245
00:08:20,240 --> 00:08:22,960
so force b actually checks the ticket

246
00:08:22,960 --> 00:08:24,160
that send along

247
00:08:24,160 --> 00:08:26,080
and it filters out all the security

248
00:08:26,080 --> 00:08:28,720
identifiers that it doesn't know about

249
00:08:28,720 --> 00:08:32,000
so in most cases you can pretend any

250
00:08:32,000 --> 00:08:34,080
you are any user in force a but you

251
00:08:34,080 --> 00:08:35,039
can't pretend

252
00:08:35,039 --> 00:08:37,120
that you're a user in force b using the

253
00:08:37,120 --> 00:08:41,839
interrupt ticket

254
00:08:44,720 --> 00:08:47,360
before we continue i just want to so

255
00:08:47,360 --> 00:08:49,360
quickly highlight some previous work

256
00:08:49,360 --> 00:08:51,040
uh willen lee did some really nice work

257
00:08:51,040 --> 00:08:53,200
on breaking forest trust last year

258
00:08:53,200 --> 00:08:55,279
this was built on camera delegation and

259
00:08:55,279 --> 00:08:56,880
that's very technical and we won't have

260
00:08:56,880 --> 00:08:58,160
time to go into it but if you're

261
00:08:58,160 --> 00:08:59,519
interested in this

262
00:08:59,519 --> 00:09:01,200
definitely read out their blog on the

263
00:09:01,200 --> 00:09:04,000
link below this was fixed in 2019

264
00:09:04,000 --> 00:09:07,200
so once after it was fixed it was no

265
00:09:07,200 --> 00:09:09,440
longer possible to break forest trust

266
00:09:09,440 --> 00:09:11,600
which is why i decided to research a new

267
00:09:11,600 --> 00:09:13,440
way

268
00:09:13,440 --> 00:09:15,839
now before we start we have to go with

269
00:09:15,839 --> 00:09:17,200
some assumptions

270
00:09:17,200 --> 00:09:19,839
so we assume that we have compromised

271
00:09:19,839 --> 00:09:20,640
first a

272
00:09:20,640 --> 00:09:23,120
someway and that anything in forest a is

273
00:09:23,120 --> 00:09:24,399
under our control

274
00:09:24,399 --> 00:09:26,800
so anything that's on the domain

275
00:09:26,800 --> 00:09:28,240
controller on the server

276
00:09:28,240 --> 00:09:29,920
or anything that's exchanged between

277
00:09:29,920 --> 00:09:31,760
force a and b that's something we can

278
00:09:31,760 --> 00:09:34,240
influence

279
00:09:35,440 --> 00:09:38,240
and we also um assume that anything that

280
00:09:38,240 --> 00:09:38,880
is actually

281
00:09:38,880 --> 00:09:40,959
transferred can be modified we also

282
00:09:40,959 --> 00:09:42,399
don't issue any non-default

283
00:09:42,399 --> 00:09:43,360
configuration

284
00:09:43,360 --> 00:09:45,279
or custom setup that's made by the

285
00:09:45,279 --> 00:09:46,480
organization

286
00:09:46,480 --> 00:09:48,240
because if permissions are explicitly

287
00:09:48,240 --> 00:09:49,519
granted that's obviously not the

288
00:09:49,519 --> 00:09:52,320
vulnerability

289
00:09:52,640 --> 00:09:54,480
so let's leave some questions what

290
00:09:54,480 --> 00:09:55,920
information is actually exchanged

291
00:09:55,920 --> 00:09:57,200
between the two first

292
00:09:57,200 --> 00:09:59,120
and can we modify this information in a

293
00:09:59,120 --> 00:10:04,320
way that gains us an advantage to start

294
00:10:04,320 --> 00:10:05,519
us off we need to look at

295
00:10:05,519 --> 00:10:08,800
trust transitivity and some people

296
00:10:08,800 --> 00:10:11,680
wonder like if there is a three forest

297
00:10:11,680 --> 00:10:12,399
and

298
00:10:12,399 --> 00:10:14,720
both forest a and forest b trust each

299
00:10:14,720 --> 00:10:16,399
other and force b and force three terms

300
00:10:16,399 --> 00:10:17,200
to each other

301
00:10:17,200 --> 00:10:19,680
does that mean that force a implicitly

302
00:10:19,680 --> 00:10:20,320
dressed for

303
00:10:20,320 --> 00:10:24,240
c well short answer

304
00:10:24,240 --> 00:10:26,800
no that's not true so for forest

305
00:10:26,800 --> 00:10:28,320
transitive thrusts

306
00:10:28,320 --> 00:10:30,320
which is a thrust between two forests

307
00:10:30,320 --> 00:10:31,519
both forests actually

308
00:10:31,519 --> 00:10:33,920
keep a list of domains and security

309
00:10:33,920 --> 00:10:35,600
identifiers that are present in the

310
00:10:35,600 --> 00:10:37,279
other forest

311
00:10:37,279 --> 00:10:39,040
and only the security identifiers that

312
00:10:39,040 --> 00:10:40,640
are on that specific list

313
00:10:40,640 --> 00:10:43,920
will pass the sit filtering so if

314
00:10:43,920 --> 00:10:45,680
so first a doesn't have any thrust with

315
00:10:45,680 --> 00:10:47,760
first c and it doesn't even know it

316
00:10:47,760 --> 00:10:48,399
exists

317
00:10:48,399 --> 00:10:51,040
so if a ticket would somehow arrive uh

318
00:10:51,040 --> 00:10:52,240
from forest c

319
00:10:52,240 --> 00:10:54,160
uh we would contain a lot of security

320
00:10:54,160 --> 00:10:56,160
identifiers that are in forest c and

321
00:10:56,160 --> 00:10:57,279
force a would be like

322
00:10:57,279 --> 00:10:58,959
no you're not on the list i don't know

323
00:10:58,959 --> 00:11:00,959
what forrest is so it would completely

324
00:11:00,959 --> 00:11:02,880
drop the ticket

325
00:11:02,880 --> 00:11:04,800
so even though trusts aren't called

326
00:11:04,800 --> 00:11:07,440
transitive it doesn't just mean that

327
00:11:07,440 --> 00:11:09,760
you can hop over trusts without doing

328
00:11:09,760 --> 00:11:12,160
anything

329
00:11:13,519 --> 00:11:15,519
now we let's have a look at how these

330
00:11:15,519 --> 00:11:17,440
trusts um

331
00:11:17,440 --> 00:11:19,360
work and how the data is stored and how

332
00:11:19,360 --> 00:11:20,560
the list of

333
00:11:20,560 --> 00:11:24,000
um of trusted domains is kept

334
00:11:24,000 --> 00:11:26,160
so if we look in the in the active

335
00:11:26,160 --> 00:11:28,000
directory users in computers

336
00:11:28,000 --> 00:11:30,399
there is a object which trusts the

337
00:11:30,399 --> 00:11:31,760
domain object

338
00:11:31,760 --> 00:11:34,720
and it has the name of forest a so this

339
00:11:34,720 --> 00:11:36,240
object has a property

340
00:11:36,240 --> 00:11:39,120
called the msgs trust forest trust info

341
00:11:39,120 --> 00:11:42,240
which is binary property containing

342
00:11:42,240 --> 00:11:45,360
data on the on the trust

343
00:11:45,360 --> 00:11:47,839
we can decode this data it's documented

344
00:11:47,839 --> 00:11:49,680
so i wrote a small python script

345
00:11:49,680 --> 00:11:52,720
which uses structures from msadts

346
00:11:52,720 --> 00:11:55,040
and basically you see that in this

347
00:11:55,040 --> 00:11:56,560
record it contains

348
00:11:56,560 --> 00:12:00,760
two pieces of data first is the

349
00:12:00,760 --> 00:12:02,639
forestay.kbt.cloud

350
00:12:02,639 --> 00:12:04,480
root domain which has a security

351
00:12:04,480 --> 00:12:06,880
identifier and it also has the subdomain

352
00:12:06,880 --> 00:12:08,000
which has a different security

353
00:12:08,000 --> 00:12:09,120
identifier

354
00:12:09,120 --> 00:12:10,720
so both these domains are stored in the

355
00:12:10,720 --> 00:12:13,040
force crystal info and any other domains

356
00:12:13,040 --> 00:12:14,880
or other security identifiers won't pass

357
00:12:14,880 --> 00:12:17,839
through the sit filter

358
00:12:18,639 --> 00:12:20,079
so this means looking back to this

359
00:12:20,079 --> 00:12:22,240
picture that we can go from force a to

360
00:12:22,240 --> 00:12:22,959
first b

361
00:12:22,959 --> 00:12:26,160
but we can only put sids in our ticket

362
00:12:26,160 --> 00:12:28,399
that are trusted by forest b and that

363
00:12:28,399 --> 00:12:30,959
are on the list

364
00:12:31,440 --> 00:12:33,839
now i wondered suppose a new subdomain

365
00:12:33,839 --> 00:12:35,519
is other than forest a

366
00:12:35,519 --> 00:12:37,920
does forest b automatically learn that

367
00:12:37,920 --> 00:12:38,959
this new

368
00:12:38,959 --> 00:12:41,120
domain exists would it automatically

369
00:12:41,120 --> 00:12:42,000
trust it

370
00:12:42,000 --> 00:12:44,720
and how is it even communicated how will

371
00:12:44,720 --> 00:12:45,279
force b

372
00:12:45,279 --> 00:12:48,959
find out that a new domain is added

373
00:12:48,959 --> 00:12:50,959
so i put it to the test and just said

374
00:12:50,959 --> 00:12:52,560
some monitoring and logging

375
00:12:52,560 --> 00:12:54,320
and wireshark to see if there was any

376
00:12:54,320 --> 00:12:55,760
network traffic

377
00:12:55,760 --> 00:12:59,279
and i added a new subdomain to first aid

378
00:12:59,279 --> 00:13:01,360
and as it turns out uh the the main

379
00:13:01,360 --> 00:13:02,480
controller of force b

380
00:13:02,480 --> 00:13:04,480
queries d to main control of force a

381
00:13:04,480 --> 00:13:06,480
about every 24 hours

382
00:13:06,480 --> 00:13:08,720
choose the net logon protocol and use

383
00:13:08,720 --> 00:13:09,519
the netar

384
00:13:09,519 --> 00:13:12,399
get forest trust information operation

385
00:13:12,399 --> 00:13:14,079
which it can use to

386
00:13:14,079 --> 00:13:17,680
get a list of all the domains in the

387
00:13:17,680 --> 00:13:20,639
in the other forest it then uses the

388
00:13:20,639 --> 00:13:21,600
trust account

389
00:13:21,600 --> 00:13:24,639
which is the same trust account that's

390
00:13:24,639 --> 00:13:26,399
which the password is used to sign the

391
00:13:26,399 --> 00:13:28,639
tickets it uses that account to

392
00:13:28,639 --> 00:13:30,560
authenticate the network on protocol has

393
00:13:30,560 --> 00:13:31,839
a specific property

394
00:13:31,839 --> 00:13:32,880
and you can say that you're

395
00:13:32,880 --> 00:13:35,200
authenticating with a trust account and

396
00:13:35,200 --> 00:13:35,920
so you

397
00:13:35,920 --> 00:13:37,760
so it can know that it's actually the

398
00:13:37,760 --> 00:13:40,320
other forest authenticating

399
00:13:40,320 --> 00:13:43,120
and even new forest if a new subdomain

400
00:13:43,120 --> 00:13:44,720
is added in the forest

401
00:13:44,720 --> 00:13:47,440
they are automatically added to the msds

402
00:13:47,440 --> 00:13:49,519
trust for a stressed info property of

403
00:13:49,519 --> 00:13:51,680
the trusted domain object

404
00:13:51,680 --> 00:13:53,839
so a new domain will automatically get

405
00:13:53,839 --> 00:13:54,959
added to the list

406
00:13:54,959 --> 00:13:56,880
and users from the new domain can also

407
00:13:56,880 --> 00:14:00,480
log in in forest b

408
00:14:01,199 --> 00:14:03,600
i wanted to see how the netlogong call

409
00:14:03,600 --> 00:14:04,399
works

410
00:14:04,399 --> 00:14:07,360
so i um wrote my own script that used

411
00:14:07,360 --> 00:14:09,199
the network on protocol

412
00:14:09,199 --> 00:14:11,040
but but to authenticate i first had to

413
00:14:11,040 --> 00:14:12,320
dump the

414
00:14:12,320 --> 00:14:14,000
first keys so you can do it with payment

415
00:14:14,000 --> 00:14:16,399
cuts you notice there are two

416
00:14:16,399 --> 00:14:19,120
thrust keys one for the incoming cursive

417
00:14:19,120 --> 00:14:20,480
one for the outgoing trust

418
00:14:20,480 --> 00:14:22,720
because it's a bi-directional thrust and

419
00:14:22,720 --> 00:14:24,480
we see that the clear decks passwords

420
00:14:24,480 --> 00:14:25,519
are the same

421
00:14:25,519 --> 00:14:27,360
that's only because the thrust is new

422
00:14:27,360 --> 00:14:30,240
and after 30 days both force will

423
00:14:30,240 --> 00:14:32,639
on their own rotate these passwords and

424
00:14:32,639 --> 00:14:35,360
it will no longer be the same

425
00:14:35,360 --> 00:14:39,199
so the md4 or the hd4 hmac for kerberos

426
00:14:39,199 --> 00:14:41,839
which is the well-known nth is also the

427
00:14:41,839 --> 00:14:42,480
same

428
00:14:42,480 --> 00:14:45,279
because it's not salted but the aes keys

429
00:14:45,279 --> 00:14:46,639
they do contain assault

430
00:14:46,639 --> 00:14:48,320
so these are not identical for the

431
00:14:48,320 --> 00:14:49,839
incoming and outgoing trust which is

432
00:14:49,839 --> 00:14:51,279
something you have to keep in mind when

433
00:14:51,279 --> 00:14:52,079
you're

434
00:14:52,079 --> 00:14:53,680
forging your own trust tickets that you

435
00:14:53,680 --> 00:14:56,399
use the right key

436
00:14:56,399 --> 00:14:59,279
so using this trust um tickets or this

437
00:14:59,279 --> 00:14:59,680
just

438
00:14:59,680 --> 00:15:02,880
password sorry and um actually using a

439
00:15:02,880 --> 00:15:05,920
tool get trust info.pi that is based on

440
00:15:05,920 --> 00:15:07,040
impact

441
00:15:07,040 --> 00:15:08,720
and i authenticated to the domain

442
00:15:08,720 --> 00:15:10,399
controller and looked up

443
00:15:10,399 --> 00:15:14,079
the um the first trust info

444
00:15:14,079 --> 00:15:15,519
in the same way that the u-main

445
00:15:15,519 --> 00:15:18,399
telephone force b will do that

446
00:15:18,399 --> 00:15:21,600
so you can see that it sends that net

447
00:15:21,600 --> 00:15:22,560
logon

448
00:15:22,560 --> 00:15:25,360
request and it will get using the

449
00:15:25,360 --> 00:15:26,720
password of the trust

450
00:15:26,720 --> 00:15:28,320
and it will get back a list with

451
00:15:28,320 --> 00:15:29,920
security identifiers

452
00:15:29,920 --> 00:15:33,120
so in this case we see that the security

453
00:15:33,120 --> 00:15:34,399
identifier for the

454
00:15:34,399 --> 00:15:37,199
subdomain ends in its last block on two

455
00:15:37,199 --> 00:15:40,880
to one

456
00:15:40,880 --> 00:15:43,519
so now that we have this information in

457
00:15:43,519 --> 00:15:44,800
theory we could add

458
00:15:44,800 --> 00:15:46,720
new domain sits on the other side of the

459
00:15:46,720 --> 00:15:48,000
trust

460
00:15:48,000 --> 00:15:50,720
so if we add a new subdomain and we

461
00:15:50,720 --> 00:15:52,560
assume we control all information

462
00:15:52,560 --> 00:15:54,000
we could use a custom security

463
00:15:54,000 --> 00:15:57,759
identifier and add that to the trusslist

464
00:15:57,759 --> 00:16:00,079
however this is really useful because we

465
00:16:00,079 --> 00:16:02,639
cannot use any existing domain in 4sb

466
00:16:02,639 --> 00:16:04,720
because 4hb knows which domains are in

467
00:16:04,720 --> 00:16:06,880
its own domain and it will not accept

468
00:16:06,880 --> 00:16:09,440
new new security identifiers

469
00:16:09,440 --> 00:16:12,240
that are in its own domain or any or any

470
00:16:12,240 --> 00:16:14,399
other trusted forest

471
00:16:14,399 --> 00:16:16,880
so you can't use any security identifier

472
00:16:16,880 --> 00:16:17,519
that force b

473
00:16:17,519 --> 00:16:20,480
is already aware of

474
00:16:21,279 --> 00:16:24,079
so i really started digging into into

475
00:16:24,079 --> 00:16:25,920
this and couldn't really find a way

476
00:16:25,920 --> 00:16:28,079
um except when i started digging into

477
00:16:28,079 --> 00:16:30,560
what is really a domain

478
00:16:30,560 --> 00:16:32,959
and you can figure that out by asking a

479
00:16:32,959 --> 00:16:34,079
domain joint

480
00:16:34,079 --> 00:16:36,320
computer or server how many domains do

481
00:16:36,320 --> 00:16:37,680
you trust

482
00:16:37,680 --> 00:16:39,920
and where you would expect it to say i

483
00:16:39,920 --> 00:16:41,120
trust only one

484
00:16:41,120 --> 00:16:43,120
the ad the active directory i'm joined

485
00:16:43,120 --> 00:16:44,959
to it will tell you that it just

486
00:16:44,959 --> 00:16:47,360
trusts two domains the active directory

487
00:16:47,360 --> 00:16:48,560
domain that is joined to

488
00:16:48,560 --> 00:16:50,320
but also its local domain which is

489
00:16:50,320 --> 00:16:52,399
stored in the in the registry and in the

490
00:16:52,399 --> 00:16:52,880
sam

491
00:16:52,880 --> 00:16:56,480
partition and this local domain also has

492
00:16:56,480 --> 00:16:57,839
a domain sit

493
00:16:57,839 --> 00:17:01,519
and it has relative security identifiers

494
00:17:01,519 --> 00:17:03,680
a well-known one is the 500 account

495
00:17:03,680 --> 00:17:05,280
which is the built-in administrator

496
00:17:05,280 --> 00:17:05,919
account

497
00:17:05,919 --> 00:17:07,679
but you can also have other local users

498
00:17:07,679 --> 00:17:08,959
which will have their own

499
00:17:08,959 --> 00:17:10,959
security identifiers but they all have

500
00:17:10,959 --> 00:17:13,839
the domain prefix of this local domain

501
00:17:13,839 --> 00:17:17,199
on that server or computer

502
00:17:17,199 --> 00:17:19,599
an active directory is not aware of all

503
00:17:19,599 --> 00:17:21,599
the security identifiers of each member

504
00:17:21,599 --> 00:17:24,000
computer

505
00:17:24,000 --> 00:17:27,359
and i wondered how much does a computer

506
00:17:27,359 --> 00:17:30,320
really trust its domain

507
00:17:30,320 --> 00:17:33,200
so if we send it a service ticket that

508
00:17:33,200 --> 00:17:34,880
is encrypted with its passwords

509
00:17:34,880 --> 00:17:37,440
would it blindly accept that and as an

510
00:17:37,440 --> 00:17:40,080
experiment i created two service tickets

511
00:17:40,080 --> 00:17:42,400
so i created a fake service ticket with

512
00:17:42,400 --> 00:17:44,000
the security identifiers of

513
00:17:44,000 --> 00:17:46,320
a user without any special privileges

514
00:17:46,320 --> 00:17:47,760
which normally shouldn't be able to do

515
00:17:47,760 --> 00:17:50,320
much on that machine except authenticate

516
00:17:50,320 --> 00:17:51,760
and i also created a service ticket

517
00:17:51,760 --> 00:17:54,480
where i included the local domain set of

518
00:17:54,480 --> 00:17:57,919
this of the server nd500 account for the

519
00:17:57,919 --> 00:18:00,000
local administrator as an extra security

520
00:18:00,000 --> 00:18:02,480
identifier

521
00:18:02,480 --> 00:18:04,799
so let's see what it does first we

522
00:18:04,799 --> 00:18:05,840
create

523
00:18:05,840 --> 00:18:08,080
a silver ticket you can do this using

524
00:18:08,080 --> 00:18:10,240
the impactor.py

525
00:18:10,240 --> 00:18:11,679
it's one of the examples that is

526
00:18:11,679 --> 00:18:13,760
included and we just have to supply all

527
00:18:13,760 --> 00:18:14,000
the

528
00:18:14,000 --> 00:18:16,640
information in this case i use the aes

529
00:18:16,640 --> 00:18:18,400
key of the computer account

530
00:18:18,400 --> 00:18:20,559
because this is test and i just wanted

531
00:18:20,559 --> 00:18:24,240
to see if the computer accepted it

532
00:18:24,400 --> 00:18:26,000
so this user is not in any special

533
00:18:26,000 --> 00:18:28,080
groups and as expected

534
00:18:28,080 --> 00:18:30,240
we get an access denied error because it

535
00:18:30,240 --> 00:18:32,320
can authenticate but it doesn't have

536
00:18:32,320 --> 00:18:34,480
any rights on the server it's just a

537
00:18:34,480 --> 00:18:35,760
normal domain user

538
00:18:35,760 --> 00:18:38,320
and we cannot do anything with it so if

539
00:18:38,320 --> 00:18:41,120
we connect over smb we try to list the c

540
00:18:41,120 --> 00:18:44,080
c drive which is limited to admin only

541
00:18:44,080 --> 00:18:45,200
we get access denied

542
00:18:45,200 --> 00:18:48,640
as expected now we create a new silver

543
00:18:48,640 --> 00:18:49,679
ticket

544
00:18:49,679 --> 00:18:52,080
and this time the user is also only part

545
00:18:52,080 --> 00:18:53,120
of the main users

546
00:18:53,120 --> 00:18:54,640
so it's not a special user it's not a

547
00:18:54,640 --> 00:18:56,160
domain admin but we add

548
00:18:56,160 --> 00:18:58,720
extra security identifier to the fake

549
00:18:58,720 --> 00:19:00,559
ticket that we created

550
00:19:00,559 --> 00:19:02,640
and this security identifier contains

551
00:19:02,640 --> 00:19:03,760
the local domain

552
00:19:03,760 --> 00:19:06,880
and the 500 user accounts so it

553
00:19:06,880 --> 00:19:08,080
basically says that

554
00:19:08,080 --> 00:19:10,720
we are also the local administrator on

555
00:19:10,720 --> 00:19:12,720
that computer

556
00:19:12,720 --> 00:19:14,880
i mentioned am i surprised this worked

557
00:19:14,880 --> 00:19:16,480
so we can pretend

558
00:19:16,480 --> 00:19:18,880
that we are the local administrator user

559
00:19:18,880 --> 00:19:19,919
on this computer

560
00:19:19,919 --> 00:19:23,200
and we can actually use the c drive so

561
00:19:23,200 --> 00:19:26,720
the computer accepts that that we are

562
00:19:26,720 --> 00:19:28,240
the administrator user

563
00:19:28,240 --> 00:19:30,320
even though this directory shouldn't be

564
00:19:30,320 --> 00:19:32,080
managing that administrator user

565
00:19:32,080 --> 00:19:34,160
and it definitely shouldn't be ending up

566
00:19:34,160 --> 00:19:38,080
in kerberos tickets

567
00:19:38,080 --> 00:19:39,840
so active directory doesn't manage the

568
00:19:39,840 --> 00:19:41,679
local domains but still

569
00:19:41,679 --> 00:19:43,840
if you use if you include one security

570
00:19:43,840 --> 00:19:45,679
identifier from the local domain then

571
00:19:45,679 --> 00:19:47,360
the computer will for some reason accept

572
00:19:47,360 --> 00:19:48,559
it

573
00:19:48,559 --> 00:19:52,080
so this is clearly an issue because we

574
00:19:52,080 --> 00:19:53,919
because active directory shouldn't be

575
00:19:53,919 --> 00:19:55,280
sending those along and the computer

576
00:19:55,280 --> 00:19:56,080
shouldn't

577
00:19:56,080 --> 00:19:58,480
blindly trust these service tickets even

578
00:19:58,480 --> 00:19:59,600
if it contains

579
00:19:59,600 --> 00:20:01,280
a security identifier that's not from

580
00:20:01,280 --> 00:20:03,280
active directory

581
00:20:03,280 --> 00:20:04,799
and we see that local admin access is

582
00:20:04,799 --> 00:20:06,720
granted when either you

583
00:20:06,720 --> 00:20:08,799
pretend that the ticket is from the

584
00:20:08,799 --> 00:20:10,080
local domain

585
00:20:10,080 --> 00:20:13,120
while the local domain doesn't have a

586
00:20:13,120 --> 00:20:14,880
domain controller so it doesn't even use

587
00:20:14,880 --> 00:20:16,640
kerberos but you can also include it as

588
00:20:16,640 --> 00:20:18,400
an extra sit so these are two different

589
00:20:18,400 --> 00:20:19,600
ways to

590
00:20:19,600 --> 00:20:22,240
get an admin access fun fact this also

591
00:20:22,240 --> 00:20:23,760
works when a local admin account is

592
00:20:23,760 --> 00:20:24,400
disabled

593
00:20:24,400 --> 00:20:25,919
so if you add an extra security

594
00:20:25,919 --> 00:20:28,000
identifier it will completely ignore

595
00:20:28,000 --> 00:20:29,360
that this account is disabled and just

596
00:20:29,360 --> 00:20:32,479
gives you the access you want

597
00:20:33,039 --> 00:20:35,760
so using this information um we can

598
00:20:35,760 --> 00:20:38,480
design a new forest trusted deck

599
00:20:38,480 --> 00:20:40,240
and for that we'll just go back to the

600
00:20:40,240 --> 00:20:49,840
drawing board real quick

601
00:20:55,280 --> 00:20:58,080
if it wants to work

602
00:20:59,600 --> 00:21:02,799
yes so here we see the

603
00:21:02,799 --> 00:21:05,039
um the same picture we saw previously i

604
00:21:05,039 --> 00:21:06,880
just drew out the subdomain a bit more

605
00:21:06,880 --> 00:21:07,600
clear

606
00:21:07,600 --> 00:21:10,400
so we see on the left the first a with

607
00:21:10,400 --> 00:21:11,360
the subdomain

608
00:21:11,360 --> 00:21:14,960
and on the right we see first b

609
00:21:14,960 --> 00:21:18,880
now what if we pretend that there's a

610
00:21:18,880 --> 00:21:22,559
new subdomain so it's in red

611
00:21:22,559 --> 00:21:25,200
and this new subdomain has the same

612
00:21:25,200 --> 00:21:27,039
security identifier

613
00:21:27,039 --> 00:21:32,000
as a server in this forest

614
00:21:32,159 --> 00:21:34,880
so first b will automatically query this

615
00:21:34,880 --> 00:21:35,840
information

616
00:21:35,840 --> 00:21:38,240
every 24 hours and then actually it will

617
00:21:38,240 --> 00:21:40,559
get back to data that there's a new

618
00:21:40,559 --> 00:21:43,520
that there's a new domain having the

619
00:21:43,520 --> 00:21:45,440
security identifier of the

620
00:21:45,440 --> 00:21:48,159
server because forest b is not aware of

621
00:21:48,159 --> 00:21:50,000
all the local domains and all the local

622
00:21:50,000 --> 00:21:52,159
security identifiers that are in

623
00:21:52,159 --> 00:21:55,679
the uh in its own domain it will accept

624
00:21:55,679 --> 00:21:56,159
this

625
00:21:56,159 --> 00:21:59,600
and it will add the security identifier

626
00:21:59,600 --> 00:22:00,240
of the

627
00:22:00,240 --> 00:22:02,720
server that is actually in force b will

628
00:22:02,720 --> 00:22:03,840
add it to the list

629
00:22:03,840 --> 00:22:06,080
of security identifiers that accepted

630
00:22:06,080 --> 00:22:13,760
that is accepted from forest a

631
00:22:13,760 --> 00:22:15,520
so there are a few missing pieces for

632
00:22:15,520 --> 00:22:17,760
this um first we need to convert

633
00:22:17,760 --> 00:22:20,080
the theory of spoofing a domain into

634
00:22:20,080 --> 00:22:22,400
practice and figure out how that works

635
00:22:22,400 --> 00:22:24,640
and of course we also need to somehow

636
00:22:24,640 --> 00:22:26,320
obtain the local sit

637
00:22:26,320 --> 00:22:28,400
of this victim computer that we want to

638
00:22:28,400 --> 00:22:30,400
compromise because this is not something

639
00:22:30,400 --> 00:22:32,080
that you can guess and it's not

640
00:22:32,080 --> 00:22:33,360
something you can query from active

641
00:22:33,360 --> 00:22:34,799
directory because active directory

642
00:22:34,799 --> 00:22:36,240
doesn't actually know

643
00:22:36,240 --> 00:22:39,919
these local sets so let's start with

644
00:22:39,919 --> 00:22:40,640
that

645
00:22:40,640 --> 00:22:43,200
we can obtain the local sets on all the

646
00:22:43,200 --> 00:22:45,520
windows versions using somewhere rpc

647
00:22:45,520 --> 00:22:47,520
which is also how bloodhound queries

648
00:22:47,520 --> 00:22:50,159
local groups in the domain

649
00:22:50,159 --> 00:22:52,320
but for versions that are newer than

650
00:22:52,320 --> 00:22:53,360
windows 10

651
00:22:53,360 --> 00:22:56,559
1607 or for server 2019 this is actually

652
00:22:56,559 --> 00:22:57,679
not going to work

653
00:22:57,679 --> 00:22:59,360
because you need admin access and if you

654
00:22:59,360 --> 00:23:01,600
already have access admin access then

655
00:23:01,600 --> 00:23:02,880
what's the point of still doing the

656
00:23:02,880 --> 00:23:05,440
attack but there's another api that we

657
00:23:05,440 --> 00:23:06,320
can use

658
00:23:06,320 --> 00:23:09,280
so we can use this function over rpc

659
00:23:09,280 --> 00:23:09,679
from

660
00:23:09,679 --> 00:23:12,559
mslset which is the lookup names

661
00:23:12,559 --> 00:23:13,280
function

662
00:23:13,280 --> 00:23:15,520
which translates a security principle

663
00:23:15,520 --> 00:23:17,919
name to their sit form

664
00:23:17,919 --> 00:23:19,600
so if we know the security principle

665
00:23:19,600 --> 00:23:21,360
name which is the hostname

666
00:23:21,360 --> 00:23:23,600
of the computer we can ask it to

667
00:23:23,600 --> 00:23:24,880
translate this to the security

668
00:23:24,880 --> 00:23:27,120
identifier

669
00:23:27,120 --> 00:23:30,159
this is great i also wrote a small

670
00:23:30,159 --> 00:23:31,120
script

671
00:23:31,120 --> 00:23:34,240
using impact again and

672
00:23:34,240 --> 00:23:37,039
using that we can use the user from

673
00:23:37,039 --> 00:23:38,000
forest a

674
00:23:38,000 --> 00:23:39,840
and authenticate to the server on forest

675
00:23:39,840 --> 00:23:41,520
b that can do that because there is a

676
00:23:41,520 --> 00:23:42,640
trust in place

677
00:23:42,640 --> 00:23:45,679
and we can query the local sit

678
00:23:45,679 --> 00:23:47,039
which doesn't require any admin

679
00:23:47,039 --> 00:23:49,120
privileges

680
00:23:49,120 --> 00:23:51,200
so now we know the local set of this

681
00:23:51,200 --> 00:23:54,640
server that we want to compromise

682
00:23:55,440 --> 00:23:58,640
now we actually need to spoof a domain

683
00:23:58,640 --> 00:24:01,360
there are multiple ways to do that the

684
00:24:01,360 --> 00:24:02,400
first one would be

685
00:24:02,400 --> 00:24:04,240
to actually add a new sub domain to

686
00:24:04,240 --> 00:24:06,480
forest a we would promote a member

687
00:24:06,480 --> 00:24:08,320
server and somehow we needed to we would

688
00:24:08,320 --> 00:24:09,440
need to make sure

689
00:24:09,440 --> 00:24:11,760
that the security identifier that's

690
00:24:11,760 --> 00:24:13,360
generated for this new domain

691
00:24:13,360 --> 00:24:15,360
ac security attempt is the same as the

692
00:24:15,360 --> 00:24:16,960
security identifier that we want to

693
00:24:16,960 --> 00:24:18,640
attack

694
00:24:18,640 --> 00:24:20,880
a second way would be to actually modify

695
00:24:20,880 --> 00:24:22,080
the forest structure

696
00:24:22,080 --> 00:24:25,120
via ldap or via dc shadow and other

697
00:24:25,120 --> 00:24:26,400
required objects

698
00:24:26,400 --> 00:24:29,039
that that would represent the subdomain

699
00:24:29,039 --> 00:24:30,240
so we could kind of fool

700
00:24:30,240 --> 00:24:32,400
the domain controller into thinking that

701
00:24:32,400 --> 00:24:33,919
has more sub domains than it actually

702
00:24:33,919 --> 00:24:34,559
has

703
00:24:34,559 --> 00:24:37,520
this is kind of hard

704
00:24:38,080 --> 00:24:40,480
a way that's less invasive is to

705
00:24:40,480 --> 00:24:42,159
actually hook lcs when the

706
00:24:42,159 --> 00:24:44,400
net r get the first trust information

707
00:24:44,400 --> 00:24:46,640
request is processed and actually

708
00:24:46,640 --> 00:24:48,559
are the block containing the data for an

709
00:24:48,559 --> 00:24:51,279
extra domain

710
00:24:51,600 --> 00:24:53,279
but it is also not that easy there

711
00:24:53,279 --> 00:24:55,039
turned out to be a lot of functions

712
00:24:55,039 --> 00:24:56,640
so in the end the option i went for is

713
00:24:56,640 --> 00:24:58,080
just to hook lcs

714
00:24:58,080 --> 00:25:01,279
and and intercept the netark at first

715
00:25:01,279 --> 00:25:02,720
trust information call

716
00:25:02,720 --> 00:25:04,559
and replace the security identifier of

717
00:25:04,559 --> 00:25:05,760
an existing domain

718
00:25:05,760 --> 00:25:09,679
with the target security identifier

719
00:25:10,640 --> 00:25:12,400
now of course these are not actually

720
00:25:12,400 --> 00:25:14,480
easy methods so it took me a lot of time

721
00:25:14,480 --> 00:25:15,840
to actually figure this out

722
00:25:15,840 --> 00:25:17,200
and there was quite some reversion

723
00:25:17,200 --> 00:25:19,120
involved as well but i'll

724
00:25:19,120 --> 00:25:22,480
log you to the process first you need to

725
00:25:22,480 --> 00:25:25,279
somehow debug lss which is a tricky

726
00:25:25,279 --> 00:25:25,760
thing

727
00:25:25,760 --> 00:25:27,600
because if you crash it then your pc

728
00:25:27,600 --> 00:25:28,880
basically reboots and you can start

729
00:25:28,880 --> 00:25:30,240
again

730
00:25:30,240 --> 00:25:32,799
but once you finally got it working um

731
00:25:32,799 --> 00:25:33,440
you can

732
00:25:33,440 --> 00:25:35,440
place a break place a breakpoint on the

733
00:25:35,440 --> 00:25:37,120
netark at first trust the information

734
00:25:37,120 --> 00:25:37,679
call

735
00:25:37,679 --> 00:25:39,360
and basically just step through the

736
00:25:39,360 --> 00:25:41,120
functions that are called and see what

737
00:25:41,120 --> 00:25:43,200
happens under the hood

738
00:25:43,200 --> 00:25:45,279
and at some point i ended up in the

739
00:25:45,279 --> 00:25:47,039
function which actually builds

740
00:25:47,039 --> 00:25:50,320
the the resulting data blocks of the

741
00:25:50,320 --> 00:25:53,120
rpc call

742
00:25:53,360 --> 00:25:55,919
and at some point in that function there

743
00:25:55,919 --> 00:25:58,080
is there is a function which

744
00:25:58,080 --> 00:25:59,600
calculates the length of the security

745
00:25:59,600 --> 00:26:01,919
identifier this is a very

746
00:26:01,919 --> 00:26:03,840
straightforward function to hook because

747
00:26:03,840 --> 00:26:05,360
that's just one argument which is the

748
00:26:05,360 --> 00:26:06,559
security identifier

749
00:26:06,559 --> 00:26:09,360
so we know for sure that at the moment

750
00:26:09,360 --> 00:26:10,080
that this

751
00:26:10,080 --> 00:26:12,400
function is called that issue that the

752
00:26:12,400 --> 00:26:14,640
first argument

753
00:26:14,640 --> 00:26:16,640
will will point to the security

754
00:26:16,640 --> 00:26:19,200
identifier of the forest

755
00:26:19,200 --> 00:26:21,279
and because it's the third argument uh

756
00:26:21,279 --> 00:26:22,400
in exit c4

757
00:26:22,400 --> 00:26:24,559
that's stored as a pointer in the rc-x

758
00:26:24,559 --> 00:26:26,159
register

759
00:26:26,159 --> 00:26:29,520
and if we look at the heap we see that

760
00:26:29,520 --> 00:26:32,080
the security identifier is stored there

761
00:26:32,080 --> 00:26:34,400
and it's pointed to by rcx

762
00:26:34,400 --> 00:26:36,320
you well you have to believe me on this

763
00:26:36,320 --> 00:26:37,679
that this is actually the security

764
00:26:37,679 --> 00:26:39,919
identifier

765
00:26:39,919 --> 00:26:43,200
now what you can do is obviously attach

766
00:26:43,200 --> 00:26:44,880
the debugger to elsa's wait for the

767
00:26:44,880 --> 00:26:47,039
calls to come in and then manually

768
00:26:47,039 --> 00:26:49,039
intercept it replace the memory but it's

769
00:26:49,039 --> 00:26:50,240
kind of tedious

770
00:26:50,240 --> 00:26:51,600
and you really have to get the timing

771
00:26:51,600 --> 00:26:53,279
right because at some point rpc will

772
00:26:53,279 --> 00:26:54,559
just time out and it will

773
00:26:54,559 --> 00:26:57,840
do nothing basically so what i did

774
00:26:57,840 --> 00:27:01,200
is i automated thing and i used friday

775
00:27:01,200 --> 00:27:04,720
so what i actually did was intercept the

776
00:27:04,720 --> 00:27:06,960
rtl length hit function which is

777
00:27:06,960 --> 00:27:08,960
imported from nt dll

778
00:27:08,960 --> 00:27:11,440
and once once this function is called i

779
00:27:11,440 --> 00:27:12,320
look if it

780
00:27:12,320 --> 00:27:14,159
if the return address of the function

781
00:27:14,159 --> 00:27:16,240
call is returning to the place

782
00:27:16,240 --> 00:27:19,760
in lsadp which is where the the function

783
00:27:19,760 --> 00:27:21,360
that we were previously looking at

784
00:27:21,360 --> 00:27:24,399
returns so if it's if this address

785
00:27:24,399 --> 00:27:26,640
matches then i know it's called from

786
00:27:26,640 --> 00:27:29,760
a place in the in in lss where the

787
00:27:29,760 --> 00:27:31,840
block is built and we can just replace

788
00:27:31,840 --> 00:27:33,919
the sid that we're looking for with the

789
00:27:33,919 --> 00:27:37,120
seat that we want to replace

790
00:27:38,559 --> 00:27:40,559
let's see this in action so remember

791
00:27:40,559 --> 00:27:42,240
that before we queried

792
00:27:42,240 --> 00:27:45,279
um the net log on call and we saw that

793
00:27:45,279 --> 00:27:47,360
this this of course the software

794
00:27:47,360 --> 00:27:48,960
was returned

795
00:27:48,960 --> 00:27:51,120
now we run friday and we basically

796
00:27:51,120 --> 00:27:53,279
intercept the security identifier when

797
00:27:53,279 --> 00:27:54,320
it's queried

798
00:27:54,320 --> 00:27:56,799
so if we run these this tool again we

799
00:27:56,799 --> 00:27:57,919
see that this time

800
00:27:57,919 --> 00:28:00,399
a completely different city's returned

801
00:28:00,399 --> 00:28:02,080
which also happens to be

802
00:28:02,080 --> 00:28:03,919
the set of the workstation that we want

803
00:28:03,919 --> 00:28:05,120
to attack

804
00:28:05,120 --> 00:28:07,200
so now we can actually intercept that

805
00:28:07,200 --> 00:28:09,120
call and make sure that when force b

806
00:28:09,120 --> 00:28:11,919
queries first a that this security

807
00:28:11,919 --> 00:28:15,120
identifier will be different

808
00:28:15,279 --> 00:28:18,080
and now we have to wait 24 hours or we

809
00:28:18,080 --> 00:28:19,760
can speed up the process a bit

810
00:28:19,760 --> 00:28:23,279
and there's actually a way to force this

811
00:28:23,279 --> 00:28:24,080
to query

812
00:28:24,080 --> 00:28:26,000
so if you go to the trust properties and

813
00:28:26,000 --> 00:28:29,360
then you save the present details

814
00:28:29,360 --> 00:28:32,000
then it will will perform the query as

815
00:28:32,000 --> 00:28:34,399
well and then it will also update it

816
00:28:34,399 --> 00:28:36,159
of course it doesn't work in real life

817
00:28:36,159 --> 00:28:37,600
because this would require require

818
00:28:37,600 --> 00:28:38,799
access to force b

819
00:28:38,799 --> 00:28:41,279
but to demonstrate it it's it's just to

820
00:28:41,279 --> 00:28:44,000
make it a bit easier

821
00:28:44,000 --> 00:28:45,600
if we look at the forest trust info

822
00:28:45,600 --> 00:28:47,840
again we see that now the security

823
00:28:47,840 --> 00:28:48,799
identifier

824
00:28:48,799 --> 00:28:51,840
is different from before and we see that

825
00:28:51,840 --> 00:28:54,000
sub.forest a certainly has the same

826
00:28:54,000 --> 00:28:56,240
security identifier that we queried

827
00:28:56,240 --> 00:28:57,760
from the workstation that we wanted to

828
00:28:57,760 --> 00:29:00,960
attack so here you see the local sit

829
00:29:00,960 --> 00:29:03,520
from forest b server now matches the sit

830
00:29:03,520 --> 00:29:04,080
that for

831
00:29:04,080 --> 00:29:08,158
the things that our subdomain has

832
00:29:08,320 --> 00:29:10,000
now here's where it gets a little more

833
00:29:10,000 --> 00:29:12,240
complicated so now we're going to create

834
00:29:12,240 --> 00:29:13,039
our own

835
00:29:13,039 --> 00:29:16,399
inter-realm ticket granting tickets

836
00:29:16,399 --> 00:29:19,120
what you do here is that you create a

837
00:29:19,120 --> 00:29:20,000
tgt

838
00:29:20,000 --> 00:29:22,159
and you sign it with the trust key and

839
00:29:22,159 --> 00:29:23,360
you add the

840
00:29:23,360 --> 00:29:27,039
extra security identifier of the local

841
00:29:27,039 --> 00:29:31,760
domain that we want to attack to the tt

842
00:29:31,760 --> 00:29:34,799
and this is interrupted so it's it's

843
00:29:34,799 --> 00:29:36,480
originating from first a

844
00:29:36,480 --> 00:29:40,080
and it'll be sent to forest b

845
00:29:40,080 --> 00:29:42,960
now we use that to ask for a service

846
00:29:42,960 --> 00:29:44,399
ticket

847
00:29:44,399 --> 00:29:46,799
enforce b and we specify the target

848
00:29:46,799 --> 00:29:48,960
domain we specify the

849
00:29:48,960 --> 00:29:51,120
originating domain this is also custom

850
00:29:51,120 --> 00:29:52,480
script that i

851
00:29:52,480 --> 00:29:54,880
changed a bit so i can see what's

852
00:29:54,880 --> 00:29:56,240
actually returned in the ticket and

853
00:29:56,240 --> 00:29:58,000
verified it works

854
00:29:58,000 --> 00:30:01,200
and we request access to the sifs spn

855
00:30:01,200 --> 00:30:03,919
which is used for smp to request a

856
00:30:03,919 --> 00:30:07,440
service ticket to talk to smb on server

857
00:30:07,440 --> 00:30:11,279
server b and if we

858
00:30:11,279 --> 00:30:14,480
decrypt the resulting service ticket

859
00:30:14,480 --> 00:30:16,240
and you see all these values from the

860
00:30:16,240 --> 00:30:17,760
sit from the

861
00:30:17,760 --> 00:30:20,320
front pack and you see that in extra

862
00:30:20,320 --> 00:30:21,039
sits

863
00:30:21,039 --> 00:30:24,640
the the sit that we inserted it passes

864
00:30:24,640 --> 00:30:27,200
so far b considers it valid and we have

865
00:30:27,200 --> 00:30:29,279
now an extra security identifier in our

866
00:30:29,279 --> 00:30:30,320
list

867
00:30:30,320 --> 00:30:33,039
which um which should allow us to log in

868
00:30:33,039 --> 00:30:35,039
on the server

869
00:30:35,039 --> 00:30:38,799
so let's test this we give the ticket to

870
00:30:38,799 --> 00:30:40,240
smp client

871
00:30:40,240 --> 00:30:43,200
we make it connect to the first d server

872
00:30:43,200 --> 00:30:45,279
and we see that indeed we can request

873
00:30:45,279 --> 00:30:46,799
now the c drive as if we were an

874
00:30:46,799 --> 00:30:48,720
administrator

875
00:30:48,720 --> 00:30:51,600
so now we complete successfully used

876
00:30:51,600 --> 00:30:53,279
only our axes in forest a

877
00:30:53,279 --> 00:30:56,000
to compromise a server in force b now

878
00:30:56,000 --> 00:30:57,120
this only works

879
00:30:57,120 --> 00:31:00,159
on a on a domain only works on member

880
00:31:00,159 --> 00:31:00,799
servers

881
00:31:00,799 --> 00:31:02,159
not on the main controllers because

882
00:31:02,159 --> 00:31:04,000
these don't have a local

883
00:31:04,000 --> 00:31:05,919
domain but still there are probably

884
00:31:05,919 --> 00:31:08,080
plenty of high value servers

885
00:31:08,080 --> 00:31:09,600
in force b as well that we want to

886
00:31:09,600 --> 00:31:11,840
compromise

887
00:31:11,840 --> 00:31:14,960
now list is using impact you can also do

888
00:31:14,960 --> 00:31:18,320
this using mimikatz and ko that also

889
00:31:18,320 --> 00:31:21,039
makes it easy to do the windows

890
00:31:21,039 --> 00:31:23,279
so first using mimikatz we create the

891
00:31:23,279 --> 00:31:24,320
golden ticket

892
00:31:24,320 --> 00:31:26,640
we specify the same parameters as before

893
00:31:26,640 --> 00:31:29,360
so the local security identifier and the

894
00:31:29,360 --> 00:31:33,120
aes trust key then i start a new

895
00:31:33,120 --> 00:31:36,320
session using renass which is just a

896
00:31:36,320 --> 00:31:38,159
clean way to start a new session without

897
00:31:38,159 --> 00:31:39,039
any existing

898
00:31:39,039 --> 00:31:42,159
carroll tickets in memory and we start

899
00:31:42,159 --> 00:31:45,600
kakeo and kakeo contains

900
00:31:45,600 --> 00:31:49,120
a lot more kerberos tools than that

901
00:31:49,120 --> 00:31:51,120
mimikatz does you can also use rubios

902
00:31:51,120 --> 00:31:53,039
which is a g-sharp rewrite

903
00:31:53,039 --> 00:31:55,360
but in this case we're using ko and we

904
00:31:55,360 --> 00:31:56,240
actually

905
00:31:56,240 --> 00:31:58,799
instructed to request a service ticket

906
00:31:58,799 --> 00:31:59,760
in first b

907
00:31:59,760 --> 00:32:02,960
and to submit that in our session

908
00:32:02,960 --> 00:32:05,519
so now we can list the ticket and we see

909
00:32:05,519 --> 00:32:07,039
that

910
00:32:07,039 --> 00:32:09,039
that we have the ticket in memory and

911
00:32:09,039 --> 00:32:10,880
even with a fake username

912
00:32:10,880 --> 00:32:12,960
we can actually list the c drive so that

913
00:32:12,960 --> 00:32:14,960
means that we successfully reproduce the

914
00:32:14,960 --> 00:32:15,840
same thing here

915
00:32:15,840 --> 00:32:17,519
and we are actually now an administrator

916
00:32:17,519 --> 00:32:20,240
on forest b

917
00:32:22,720 --> 00:32:24,960
just a few notes about this attack so it

918
00:32:24,960 --> 00:32:26,640
can be used to compromise any

919
00:32:26,640 --> 00:32:28,480
non-domain controller in a trusting

920
00:32:28,480 --> 00:32:30,720
forest it does work with the one-way

921
00:32:30,720 --> 00:32:31,760
trust

922
00:32:31,760 --> 00:32:33,600
but you will need one account in the

923
00:32:33,600 --> 00:32:34,960
other trust to

924
00:32:34,960 --> 00:32:36,960
actually query the local security

925
00:32:36,960 --> 00:32:38,159
identifier because you have to

926
00:32:38,159 --> 00:32:40,720
obtain that somehow it doesn't work

927
00:32:40,720 --> 00:32:42,320
against the thrust direction

928
00:32:42,320 --> 00:32:45,519
so if you have a one-way trust which is

929
00:32:45,519 --> 00:32:47,440
outgoing which means that you trust the

930
00:32:47,440 --> 00:32:48,640
other domain

931
00:32:48,640 --> 00:32:49,840
and not the other way around then you

932
00:32:49,840 --> 00:32:52,959
cannot perform this attack

933
00:32:53,200 --> 00:32:56,559
i disclosed it to msrc in october 2019

934
00:32:56,559 --> 00:32:59,200
and because it was quite a complex batch

935
00:32:59,200 --> 00:32:59,679
day

936
00:32:59,679 --> 00:33:02,640
we agreed on february 2020 as a batching

937
00:33:02,640 --> 00:33:03,200
date

938
00:33:03,200 --> 00:33:05,600
and they released a patch in february on

939
00:33:05,600 --> 00:33:06,480
past tuesday

940
00:33:06,480 --> 00:33:09,679
and assigned six cve2020665

941
00:33:09,679 --> 00:33:11,760
one away from 666 which would have been

942
00:33:11,760 --> 00:33:13,519
cool

943
00:33:13,519 --> 00:33:15,600
so this is actually fixed and if you pat

944
00:33:15,600 --> 00:33:16,960
your servers

945
00:33:16,960 --> 00:33:18,399
then you don't have to worry about this

946
00:33:18,399 --> 00:33:21,120
attack anymore

947
00:33:21,360 --> 00:33:23,919
some general conclusions even though

948
00:33:23,919 --> 00:33:25,279
trust is

949
00:33:25,279 --> 00:33:27,600
sometimes or sometimes not recognized as

950
00:33:27,600 --> 00:33:28,880
a security boundary

951
00:33:28,880 --> 00:33:31,600
a trust still implies that you trust the

952
00:33:31,600 --> 00:33:32,640
other side

953
00:33:32,640 --> 00:33:35,279
so if the other side gets compromised

954
00:33:35,279 --> 00:33:36,720
then something you trust gets

955
00:33:36,720 --> 00:33:37,760
compromised and

956
00:33:37,760 --> 00:33:40,000
you cannot just assume that because it's

957
00:33:40,000 --> 00:33:42,000
trust that you cannot move

958
00:33:42,000 --> 00:33:45,679
over interest and what we see so here

959
00:33:45,679 --> 00:33:48,080
is that this does require some network

960
00:33:48,080 --> 00:33:48,960
access

961
00:33:48,960 --> 00:33:52,399
for to domain controllers and to servers

962
00:33:52,399 --> 00:33:53,919
and if you have good firewalling and

963
00:33:53,919 --> 00:33:56,240
network segmentation

964
00:33:56,240 --> 00:33:58,640
on top of your trusts and strict

965
00:33:58,640 --> 00:33:59,519
settings that

966
00:33:59,519 --> 00:34:01,039
would prevent against this attack as

967
00:34:01,039 --> 00:34:02,880
well

968
00:34:02,880 --> 00:34:04,960
and even though extended transitivity is

969
00:34:04,960 --> 00:34:07,039
not a thing so we couldn't go from first

970
00:34:07,039 --> 00:34:09,199
a to first c directly

971
00:34:09,199 --> 00:34:11,199
if you compromise one thrust at a time

972
00:34:11,199 --> 00:34:13,199
you can still hop over so in this case

973
00:34:13,199 --> 00:34:14,639
we could reproduce

974
00:34:14,639 --> 00:34:17,040
this exactly we did against force b we

975
00:34:17,040 --> 00:34:18,000
could also

976
00:34:18,000 --> 00:34:19,599
extend that to first c after

977
00:34:19,599 --> 00:34:21,520
compromising force b

978
00:34:21,520 --> 00:34:23,520
so if you have multiple trusts then this

979
00:34:23,520 --> 00:34:27,520
chain of compromise can really get long

980
00:34:28,000 --> 00:34:30,480
some acknowledgements of course this

981
00:34:30,480 --> 00:34:32,239
research built forts on a lot of other

982
00:34:32,239 --> 00:34:33,359
people's work

983
00:34:33,359 --> 00:34:35,440
especially those who also like to dig

984
00:34:35,440 --> 00:34:37,359
into gerald's technicalities

985
00:34:37,359 --> 00:34:40,239
and those who like to work tools and

986
00:34:40,239 --> 00:34:41,440
tutorials

987
00:34:41,440 --> 00:34:44,399
so thanks a lot to them as well and to

988
00:34:44,399 --> 00:34:45,918
conclude

989
00:34:45,918 --> 00:34:48,639
i did upload my scripts on my github so

990
00:34:48,639 --> 00:34:50,320
if you want to reproduce this

991
00:34:50,320 --> 00:34:52,480
yourself as well you can look at the

992
00:34:52,480 --> 00:34:54,639
forest rust tools repository

993
00:34:54,639 --> 00:34:56,639
questions are welcome you can add ask

994
00:34:56,639 --> 00:34:59,040
them here live in the comments or

995
00:34:59,040 --> 00:35:01,200
via dm on twitter later and i'll do my

996
00:35:01,200 --> 00:35:02,560
best to answer them

997
00:35:02,560 --> 00:35:04,480
thank you for listening and i hope you

998
00:35:04,480 --> 00:35:07,160
learned something new and fun

999
00:35:07,160 --> 00:35:10,160
bye

