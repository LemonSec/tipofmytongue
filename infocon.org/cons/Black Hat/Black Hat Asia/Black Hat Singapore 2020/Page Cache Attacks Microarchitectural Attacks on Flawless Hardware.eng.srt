1
00:00:01,680 --> 00:00:03,760
hello and welcome to our

2
00:00:03,760 --> 00:00:05,440
talk page cash attacks micro

3
00:00:05,440 --> 00:00:07,200
architectural attacks on flawless

4
00:00:07,200 --> 00:00:08,240
hardware

5
00:00:08,240 --> 00:00:11,120
uh this is a talk with trishita tiwari

6
00:00:11,120 --> 00:00:13,120
mikhail schwarz and eric croft

7
00:00:13,120 --> 00:00:16,239
and me daniel goose so let's start right

8
00:00:16,239 --> 00:00:16,720
away

9
00:00:16,720 --> 00:00:19,760
so we want to talk about uh the micro

10
00:00:19,760 --> 00:00:20,800
architecture today

11
00:00:20,800 --> 00:00:22,720
micro architectural components are

12
00:00:22,720 --> 00:00:24,160
components of the processor

13
00:00:24,160 --> 00:00:26,080
which are not defined in the

14
00:00:26,080 --> 00:00:27,199
architecture

15
00:00:27,199 --> 00:00:30,080
but they still exist and they still are

16
00:00:30,080 --> 00:00:31,519
different and behave differently

17
00:00:31,519 --> 00:00:33,200
depending on the processor

18
00:00:33,200 --> 00:00:35,040
so you can have for instance different

19
00:00:35,040 --> 00:00:37,600
caches buffers in different cpus

20
00:00:37,600 --> 00:00:39,600
uh you can have predictors and all of

21
00:00:39,600 --> 00:00:41,600
these micro architectural elements

22
00:00:41,600 --> 00:00:43,440
they have a behavior that you can

23
00:00:43,440 --> 00:00:45,280
observe but they are not

24
00:00:45,280 --> 00:00:47,840
documented or at least their their exact

25
00:00:47,840 --> 00:00:49,600
behavior is not documented in the

26
00:00:49,600 --> 00:00:52,239
architecture specification so this is

27
00:00:52,239 --> 00:00:53,840
meant to be transparent for the

28
00:00:53,840 --> 00:00:55,280
programmer

29
00:00:55,280 --> 00:00:57,120
but the timing optimizations for

30
00:00:57,120 --> 00:00:59,440
instance they will then lead to cycle

31
00:00:59,440 --> 00:01:02,800
leakage that all sounds a bit

32
00:01:02,800 --> 00:01:05,119
abstract right maybe we should right go

33
00:01:05,119 --> 00:01:06,320
into some example

34
00:01:06,320 --> 00:01:08,799
like a cpu cache something that many

35
00:01:08,799 --> 00:01:10,479
people will already know

36
00:01:10,479 --> 00:01:13,119
so if i like a cpu cache for example

37
00:01:13,119 --> 00:01:14,720
like here in the middle and i have a

38
00:01:14,720 --> 00:01:16,400
short code snippet on the left that

39
00:01:16,400 --> 00:01:18,080
accesses one variable

40
00:01:18,080 --> 00:01:21,119
twice in a row so at first time i do

41
00:01:21,119 --> 00:01:21,840
that

42
00:01:21,840 --> 00:01:23,920
this variable is not cached so i've

43
00:01:23,920 --> 00:01:25,439
never used that before

44
00:01:25,439 --> 00:01:27,759
and it has to be somewhere in the dram

45
00:01:27,759 --> 00:01:30,000
so this request has to go to the dram

46
00:01:30,000 --> 00:01:32,400
in the main memory and search for this

47
00:01:32,400 --> 00:01:33,119
variable

48
00:01:33,119 --> 00:01:36,079
this sounds very slow yes that sounds

49
00:01:36,079 --> 00:01:36,560
slow

50
00:01:36,560 --> 00:01:38,400
i have to wait for the respawns of the

51
00:01:38,400 --> 00:01:40,880
memory and then it will be

52
00:01:40,880 --> 00:01:43,360
as you said before put into the cache

53
00:01:43,360 --> 00:01:44,960
transparently

54
00:01:44,960 --> 00:01:47,600
and the next time i use this variable

55
00:01:47,600 --> 00:01:49,280
and it's already in the cache because

56
00:01:49,280 --> 00:01:51,200
i've recently used it

57
00:01:51,200 --> 00:01:53,759
then i can take it directly this copy

58
00:01:53,759 --> 00:01:54,880
from the cache

59
00:01:54,880 --> 00:01:58,000
and use that one and as you said going

60
00:01:58,000 --> 00:01:59,200
to the main memory

61
00:01:59,200 --> 00:02:02,320
this is really slow but if it's in the

62
00:02:02,320 --> 00:02:03,119
cache

63
00:02:03,119 --> 00:02:06,479
then it's much much faster and we can

64
00:02:06,479 --> 00:02:06,960
really

65
00:02:06,960 --> 00:02:09,598
measure that this is really great so if

66
00:02:09,598 --> 00:02:10,239
we get

67
00:02:10,239 --> 00:02:13,360
much faster cpus just by adding a cache

68
00:02:13,360 --> 00:02:15,040
then we can save a lot of time and

69
00:02:15,040 --> 00:02:16,959
energy so let's take a look at the

70
00:02:16,959 --> 00:02:18,319
histogram here

71
00:02:18,319 --> 00:02:20,800
um if you look at this histogram this is

72
00:02:20,800 --> 00:02:22,239
a log scale histogram

73
00:02:22,239 --> 00:02:24,640
right and you can see that literally all

74
00:02:24,640 --> 00:02:25,680
the excesses

75
00:02:25,680 --> 00:02:29,680
are here around in this case

76
00:02:29,680 --> 00:02:32,480
below 80 cpu cycles and you can see that

77
00:02:32,480 --> 00:02:34,319
virtually all the excesses

78
00:02:34,319 --> 00:02:37,519
are here so this is a a

79
00:02:37,519 --> 00:02:40,560
lot of time that we can save here

80
00:02:40,560 --> 00:02:42,080
because if you compare this with the

81
00:02:42,080 --> 00:02:42,560
cash

82
00:02:42,560 --> 00:02:45,599
misses they are all very very slow so

83
00:02:45,599 --> 00:02:47,120
you can see the timing here

84
00:02:47,120 --> 00:02:51,920
is always above these maybe 200 cycles

85
00:02:51,920 --> 00:02:53,760
see that's what i told you it's much

86
00:02:53,760 --> 00:02:55,840
faster if something is in the cache and

87
00:02:55,840 --> 00:02:57,120
you can really see that

88
00:02:57,120 --> 00:02:59,280
when measuring the axis times this

89
00:02:59,280 --> 00:03:00,800
sounds like a really cool

90
00:03:00,800 --> 00:03:03,519
thing but why would that be relevant for

91
00:03:03,519 --> 00:03:04,480
our talk about

92
00:03:04,480 --> 00:03:08,080
page cash attacks it turns out

93
00:03:08,080 --> 00:03:10,640
you can build a text with that with the

94
00:03:10,640 --> 00:03:12,080
simple timing difference

95
00:03:12,080 --> 00:03:15,519
you can already attack some applications

96
00:03:15,519 --> 00:03:18,159
let's see for example in this setup here

97
00:03:18,159 --> 00:03:18,879
with an

98
00:03:18,879 --> 00:03:20,800
attacker application we have a victim

99
00:03:20,800 --> 00:03:22,879
application and we have some shared

100
00:03:22,879 --> 00:03:23,440
memory

101
00:03:23,440 --> 00:03:25,680
and of course this transparent cache

102
00:03:25,680 --> 00:03:28,000
that we have in every cpu

103
00:03:28,000 --> 00:03:31,519
now if the attacker or the victim access

104
00:03:31,519 --> 00:03:33,440
to shared memory doesn't matter who does

105
00:03:33,440 --> 00:03:33,920
it

106
00:03:33,920 --> 00:03:36,159
it ends up being in the cache

107
00:03:36,159 --> 00:03:37,360
transparently

108
00:03:37,360 --> 00:03:39,440
no one does anything actively darius

109
00:03:39,440 --> 00:03:41,599
just ends up there

110
00:03:41,599 --> 00:03:44,159
now if the attacker flushes something

111
00:03:44,159 --> 00:03:45,840
from the cache so removes it from the

112
00:03:45,840 --> 00:03:48,000
cache removes this copy

113
00:03:48,000 --> 00:03:51,200
then it's also gone for both an attacker

114
00:03:51,200 --> 00:03:53,760
and a victim application so an attacker

115
00:03:53,760 --> 00:03:55,280
can do that

116
00:03:55,280 --> 00:03:57,840
and then wait for the victim and the

117
00:03:57,840 --> 00:03:59,040
victim now

118
00:03:59,040 --> 00:04:01,680
might access some shared data again the

119
00:04:01,680 --> 00:04:02,640
shared data

120
00:04:02,640 --> 00:04:06,000
might be some library like the lib c

121
00:04:06,000 --> 00:04:09,760
or some keystroke library that handles

122
00:04:09,760 --> 00:04:10,640
keys or

123
00:04:10,640 --> 00:04:12,879
whatever some shared library some shared

124
00:04:12,879 --> 00:04:15,360
memory but this doesn't really sound

125
00:04:15,360 --> 00:04:17,839
very dangerous right

126
00:04:17,839 --> 00:04:20,560
yes but think about that so when the

127
00:04:20,560 --> 00:04:22,240
victim accesses that

128
00:04:22,240 --> 00:04:23,919
it's again in the cache the shared

129
00:04:23,919 --> 00:04:26,560
memory and now the attacker can also

130
00:04:26,560 --> 00:04:27,199
access it

131
00:04:27,199 --> 00:04:30,240
it's shared so the attacker can see

132
00:04:30,240 --> 00:04:31,919
whether it's in the cache or not by

133
00:04:31,919 --> 00:04:33,759
measuring the access time

134
00:04:33,759 --> 00:04:36,639
so then the attacker learns whether the

135
00:04:36,639 --> 00:04:37,199
victim

136
00:04:37,199 --> 00:04:39,360
accessed some data or did not access

137
00:04:39,360 --> 00:04:41,759
some data so that's some information

138
00:04:41,759 --> 00:04:44,320
that you might not want to share with

139
00:04:44,320 --> 00:04:45,600
any other application

140
00:04:45,600 --> 00:04:48,240
if you are an application so this sounds

141
00:04:48,240 --> 00:04:50,479
like a very simple attack but in many

142
00:04:50,479 --> 00:04:51,040
cases

143
00:04:51,040 --> 00:04:53,759
the um attacker will not have shared

144
00:04:53,759 --> 00:04:55,919
memory with the victim right

145
00:04:55,919 --> 00:04:59,120
so what can we do then

146
00:04:59,120 --> 00:05:01,120
so it turns out this is not the only

147
00:05:01,120 --> 00:05:02,240
attack

148
00:05:02,240 --> 00:05:04,560
there's a different attack that's quite

149
00:05:04,560 --> 00:05:06,639
similar it also uses the cache it also

150
00:05:06,639 --> 00:05:08,240
uses his timing differences

151
00:05:08,240 --> 00:05:11,199
but does not rely on shared memory so in

152
00:05:11,199 --> 00:05:12,880
this case the attacker

153
00:05:12,880 --> 00:05:16,720
simply fills the cache with its own data

154
00:05:16,720 --> 00:05:19,520
and then waits if the victim now

155
00:05:19,520 --> 00:05:21,440
accesses some data that falls into that

156
00:05:21,440 --> 00:05:22,880
same cache set

157
00:05:22,880 --> 00:05:24,720
then there is no space no empty space

158
00:05:24,720 --> 00:05:27,039
for that and some data of the

159
00:05:27,039 --> 00:05:29,120
decker has to be evicted it's not in the

160
00:05:29,120 --> 00:05:31,199
cache anymore but replaced by the

161
00:05:31,199 --> 00:05:32,880
victim's data

162
00:05:32,880 --> 00:05:36,400
now if the attacker again

163
00:05:36,400 --> 00:05:39,440
fills the cache with its data the data

164
00:05:39,440 --> 00:05:40,880
that's already in there that will be

165
00:05:40,880 --> 00:05:41,360
fast

166
00:05:41,360 --> 00:05:43,840
it's a cache hit but if it was replaced

167
00:05:43,840 --> 00:05:45,360
it has to fetch that from the main

168
00:05:45,360 --> 00:05:46,240
memory again

169
00:05:46,240 --> 00:05:48,720
put it into the cache and this will be

170
00:05:48,720 --> 00:05:49,440
slow

171
00:05:49,440 --> 00:05:51,919
so overall we see a bit of a slowdown

172
00:05:51,919 --> 00:05:53,039
when doing that

173
00:05:53,039 --> 00:05:55,199
so it's a similar attack to the previous

174
00:05:55,199 --> 00:05:57,680
one and you don't need shared memory

175
00:05:57,680 --> 00:06:00,160
so this is really nice but can you

176
00:06:00,160 --> 00:06:01,039
actually

177
00:06:01,039 --> 00:06:03,360
leak information with that i mean there

178
00:06:03,360 --> 00:06:05,120
are not that many cache sets

179
00:06:05,120 --> 00:06:07,120
and there may be tons of noise in a

180
00:06:07,120 --> 00:06:09,360
system right

181
00:06:09,360 --> 00:06:11,360
so maybe we'll start with an easier

182
00:06:11,360 --> 00:06:13,680
example didn't you do something with

183
00:06:13,680 --> 00:06:16,800
flush and reload and keys recently

184
00:06:16,800 --> 00:06:18,560
oh yeah i think we did something there

185
00:06:18,560 --> 00:06:20,000
but i have a very very bad

186
00:06:20,000 --> 00:06:23,360
memory so let's take a look at maybe

187
00:06:23,360 --> 00:06:24,639
this plot here

188
00:06:24,639 --> 00:06:27,120
so here we perform flush reload on

189
00:06:27,120 --> 00:06:28,319
keystrokes

190
00:06:28,319 --> 00:06:31,759
and we just measured when the library

191
00:06:31,759 --> 00:06:34,240
has some activity and whenever it has

192
00:06:34,240 --> 00:06:35,280
some activity

193
00:06:35,280 --> 00:06:38,479
we printed this and we plotted this in

194
00:06:38,479 --> 00:06:41,680
this graph here and you can see

195
00:06:41,680 --> 00:06:44,639
clearly the ground truth is illustrated

196
00:06:44,639 --> 00:06:46,080
here with the green dots

197
00:06:46,080 --> 00:06:49,440
you can clearly see that um you can see

198
00:06:49,440 --> 00:06:52,400
the keystrokes in this trace just based

199
00:06:52,400 --> 00:06:53,120
on

200
00:06:53,120 --> 00:06:56,479
the side channel attack so this is

201
00:06:56,479 --> 00:06:59,599
flash and reload and it does not really

202
00:06:59,599 --> 00:07:01,759
reveal the actual key but it has a

203
00:07:01,759 --> 00:07:04,400
timing difference between the keystrokes

204
00:07:04,400 --> 00:07:05,120
here

205
00:07:05,120 --> 00:07:08,240
and this you can use to actually

206
00:07:08,240 --> 00:07:12,080
leak data for instance by using machine

207
00:07:12,080 --> 00:07:13,520
learning and learning what the

208
00:07:13,520 --> 00:07:16,800
inter keystroke timings are

209
00:07:16,800 --> 00:07:19,280
okay but hopefully my password is not in

210
00:07:19,280 --> 00:07:20,479
a dictionary

211
00:07:20,479 --> 00:07:22,960
not a word a normal word so you will

212
00:07:22,960 --> 00:07:24,080
have distinct

213
00:07:24,080 --> 00:07:25,440
movements if you think about the

214
00:07:25,440 --> 00:07:27,039
keyboard you have movements from one

215
00:07:27,039 --> 00:07:28,160
letter to the other

216
00:07:28,160 --> 00:07:30,080
so there will be distinct movements from

217
00:07:30,080 --> 00:07:31,520
one letter to the other

218
00:07:31,520 --> 00:07:34,240
um that have different timing and based

219
00:07:34,240 --> 00:07:36,160
on that you will be able to infer

220
00:07:36,160 --> 00:07:40,000
some of the keys okay i can believe that

221
00:07:40,000 --> 00:07:42,639
but do we also have some stronger

222
00:07:42,639 --> 00:07:43,360
attacks

223
00:07:43,360 --> 00:07:45,280
i think we have some stronger attacks

224
00:07:45,280 --> 00:07:47,440
and if i recall it correctly you even

225
00:07:47,440 --> 00:07:48,800
published some of those

226
00:07:48,800 --> 00:07:50,879
and you're even going to give another

227
00:07:50,879 --> 00:07:53,280
asia talk about one of these

228
00:07:53,280 --> 00:07:56,800
oh yes true true now i remember

229
00:07:56,800 --> 00:07:59,280
so one of them was meltdown for instance

230
00:07:59,280 --> 00:08:00,319
but we also had

231
00:08:00,319 --> 00:08:03,360
uh foreshadow we had um zombies the

232
00:08:03,360 --> 00:08:04,479
zombie load right

233
00:08:04,479 --> 00:08:06,960
yes zombie load that's what i'm talking

234
00:08:06,960 --> 00:08:08,400
about in this talk

235
00:08:08,400 --> 00:08:10,479
no no you're not in the zombie talk yet

236
00:08:10,479 --> 00:08:12,800
okay

237
00:08:14,560 --> 00:08:16,639
yeah right thanks for reminding me okay

238
00:08:16,639 --> 00:08:18,479
and then spectre we also have specter

239
00:08:18,479 --> 00:08:20,240
and inspector is also a very interesting

240
00:08:20,240 --> 00:08:22,160
attack but we don't have time to go into

241
00:08:22,160 --> 00:08:23,120
the details of

242
00:08:23,120 --> 00:08:25,440
these all and also we wanted to talk

243
00:08:25,440 --> 00:08:26,240
more about

244
00:08:26,240 --> 00:08:29,360
the page cache attacks right

245
00:08:29,360 --> 00:08:31,440
yes we just wanted to have some examples

246
00:08:31,440 --> 00:08:33,839
here on what you can do with this

247
00:08:33,839 --> 00:08:36,159
small timing differences in the micro

248
00:08:36,159 --> 00:08:37,679
architecture

249
00:08:37,679 --> 00:08:39,599
so let's talk a bit about

250
00:08:39,599 --> 00:08:41,279
countermeasures for these attacks

251
00:08:41,279 --> 00:08:41,919
because

252
00:08:41,919 --> 00:08:44,320
this is also an interesting property

253
00:08:44,320 --> 00:08:46,399
because these are attacks that we mount

254
00:08:46,399 --> 00:08:49,600
from software that exploit a problem in

255
00:08:49,600 --> 00:08:50,959
the hardware

256
00:08:50,959 --> 00:08:53,760
and then leak the data again to the

257
00:08:53,760 --> 00:08:55,360
software-based attacker

258
00:08:55,360 --> 00:08:58,399
so this crosses the layers somehow

259
00:08:58,399 --> 00:09:00,480
and this makes it difficult to mitigate

260
00:09:00,480 --> 00:09:02,640
these attacks properly

261
00:09:02,640 --> 00:09:06,240
can we even do that it depends so for

262
00:09:06,240 --> 00:09:08,480
processors that are already shipped you

263
00:09:08,480 --> 00:09:10,480
can't really fix them right

264
00:09:10,480 --> 00:09:14,480
i mean i can hand you a soldering iron

265
00:09:14,560 --> 00:09:17,439
good luck with that

266
00:09:18,959 --> 00:09:21,519
and of course you can work around the

267
00:09:21,519 --> 00:09:22,080
problem

268
00:09:22,080 --> 00:09:23,680
for instance we did that with the kaiser

269
00:09:23,680 --> 00:09:26,720
patch which is now in linux as kpti but

270
00:09:26,720 --> 00:09:28,720
also the other operating systems all

271
00:09:28,720 --> 00:09:31,839
adopted this and this just adds more

272
00:09:31,839 --> 00:09:34,959
software level isolation and makes

273
00:09:34,959 --> 00:09:37,440
exploitation harder but it doesn't

274
00:09:37,440 --> 00:09:38,720
fundamentally

275
00:09:38,720 --> 00:09:42,000
solve or fix the problem it only works

276
00:09:42,000 --> 00:09:45,040
around the problem

277
00:09:46,160 --> 00:09:49,680
yeah and then it's it's very difficult

278
00:09:49,680 --> 00:09:50,000
to

279
00:09:50,000 --> 00:09:53,200
to fix these for instance for

280
00:09:53,200 --> 00:09:56,240
for caches um we talked about the cache

281
00:09:56,240 --> 00:09:57,839
timing effects right

282
00:09:57,839 --> 00:10:00,240
yeah you don't want to fix that yes

283
00:10:00,240 --> 00:10:02,480
because we want the performance there

284
00:10:02,480 --> 00:10:05,680
so it's not very easy to fix that

285
00:10:05,680 --> 00:10:08,079
no one wants to give up caches yes for

286
00:10:08,079 --> 00:10:09,760
spectra it would be predictions you

287
00:10:09,760 --> 00:10:10,480
don't want to

288
00:10:10,480 --> 00:10:14,880
give up predictions on what to do next

289
00:10:15,040 --> 00:10:19,279
so we are only fixing the symptoms and

290
00:10:19,279 --> 00:10:21,920
that's of course not very good and we

291
00:10:21,920 --> 00:10:23,600
have to get better at that

292
00:10:23,600 --> 00:10:26,959
but maybe in a few years we will know

293
00:10:26,959 --> 00:10:28,480
how to fix these problems more

294
00:10:28,480 --> 00:10:30,079
fundamentally

295
00:10:30,079 --> 00:10:33,279
yes that sounds like we would need a new

296
00:10:33,279 --> 00:10:35,920
design for that yeah maybe we will need

297
00:10:35,920 --> 00:10:36,640
that

298
00:10:36,640 --> 00:10:39,839
um yes

299
00:10:39,839 --> 00:10:43,120
but what if we assume that

300
00:10:43,120 --> 00:10:46,640
we are in a parallel universe okay

301
00:10:46,640 --> 00:10:49,279
and hardware is not that complex and and

302
00:10:49,279 --> 00:10:50,880
hardware is fine

303
00:10:50,880 --> 00:10:54,160
okay what about softwares and

304
00:10:54,160 --> 00:10:58,160
side channels so

305
00:10:58,160 --> 00:10:59,760
we don't have any hardware side channels

306
00:10:59,760 --> 00:11:01,200
now everything is fixed we're in a

307
00:11:01,200 --> 00:11:03,440
parallel universe we're in the future

308
00:11:03,440 --> 00:11:06,480
we had the greatest minds coming up with

309
00:11:06,480 --> 00:11:07,120
hardware

310
00:11:07,120 --> 00:11:09,040
designs that are not vulnerable anymore

311
00:11:09,040 --> 00:11:10,399
that would be great i mean

312
00:11:10,399 --> 00:11:13,440
then we would be um we would be

313
00:11:13,440 --> 00:11:15,360
uh all fine because the problem would

314
00:11:15,360 --> 00:11:17,040
not exist anymore

315
00:11:17,040 --> 00:11:20,640
right i think so perfect okay

316
00:11:20,640 --> 00:11:22,640
so this is great and with that we are at

317
00:11:22,640 --> 00:11:23,920
the end of our talk

318
00:11:23,920 --> 00:11:29,200
right thanks for your attention um

319
00:11:29,200 --> 00:11:30,959
we have so much more to talk about what

320
00:11:30,959 --> 00:11:33,519
about the software side channels that we

321
00:11:33,519 --> 00:11:35,680
just discussed about but the micro

322
00:11:35,680 --> 00:11:37,920
market microarchitecture doesn't exist

323
00:11:37,920 --> 00:11:39,360
on the software level right

324
00:11:39,360 --> 00:11:43,839
this is the hardware thing

325
00:11:43,920 --> 00:11:46,480
well but there are parallels between the

326
00:11:46,480 --> 00:11:49,360
hardware and the software for example

327
00:11:49,360 --> 00:11:52,480
if you see there's the isa extensions

328
00:11:52,480 --> 00:11:53,279
and the private

329
00:11:53,279 --> 00:11:55,440
in the operating system is non-standard

330
00:11:55,440 --> 00:11:56,480
system calls

331
00:11:56,480 --> 00:11:59,600
similarly hardware caches have software

332
00:11:59,600 --> 00:12:00,720
caches as

333
00:12:00,720 --> 00:12:03,279
their parallel and the hardware

334
00:12:03,279 --> 00:12:05,920
prefactor has the software professor

335
00:12:05,920 --> 00:12:08,160
so that would mean hardware and software

336
00:12:08,160 --> 00:12:09,120
is basically

337
00:12:09,120 --> 00:12:11,200
the same with respect to situational

338
00:12:11,200 --> 00:12:13,120
tanks

339
00:12:13,120 --> 00:12:16,079
maybe so maybe what we could do is like

340
00:12:16,079 --> 00:12:17,760
apply some of the principles from

341
00:12:17,760 --> 00:12:21,200
hardware side channels to software uh

342
00:12:21,200 --> 00:12:24,560
attacks and

343
00:12:24,560 --> 00:12:27,760
now we can discuss our hardware agnostic

344
00:12:27,760 --> 00:12:29,519
side channel

345
00:12:29,519 --> 00:12:33,360
through the operating system page cache

346
00:12:34,079 --> 00:12:36,480
so this side channel has a temporal

347
00:12:36,480 --> 00:12:38,000
resolution of about

348
00:12:38,000 --> 00:12:41,839
2 microseconds which leads to

349
00:12:41,839 --> 00:12:44,480
up to 6.7 measurements per second on

350
00:12:44,480 --> 00:12:45,040
linux

351
00:12:45,040 --> 00:12:49,200
and 466 nanoseconds which is about 233

352
00:12:49,200 --> 00:12:50,399
measurements per second

353
00:12:50,399 --> 00:12:53,680
on windows and a spatial resolution

354
00:12:53,680 --> 00:12:55,519
since it's a page cache attack it's

355
00:12:55,519 --> 00:12:57,519
about it's one page which is four

356
00:12:57,519 --> 00:12:59,120
kilobytes

357
00:12:59,120 --> 00:13:02,240
and we can do very very different types

358
00:13:02,240 --> 00:13:03,920
of attacks through this so

359
00:13:03,920 --> 00:13:06,560
php random number generator attacks ui

360
00:13:06,560 --> 00:13:08,160
re-wrestling attacks

361
00:13:08,160 --> 00:13:11,040
breaking aslr keystroke timing attacks

362
00:13:11,040 --> 00:13:13,040
you name it covert channels we have it

363
00:13:13,040 --> 00:13:13,440
all

364
00:13:13,440 --> 00:13:15,519
so now let's talk about what the page

365
00:13:15,519 --> 00:13:16,800
cache is

366
00:13:16,800 --> 00:13:18,959
so the pagecache is basically a software

367
00:13:18,959 --> 00:13:21,600
cache managed by the operating system

368
00:13:21,600 --> 00:13:24,720
and its main purpose is to buffer all

369
00:13:24,720 --> 00:13:26,880
buffer file pages in physical memory so

370
00:13:26,880 --> 00:13:29,040
that their future accesses to them are

371
00:13:29,040 --> 00:13:30,240
faster

372
00:13:30,240 --> 00:13:32,800
in an earlier world all file pages would

373
00:13:32,800 --> 00:13:34,560
be in the page cache so that every

374
00:13:34,560 --> 00:13:37,360
access to it is fast but in reality

375
00:13:37,360 --> 00:13:39,040
you're limited by the amount of your

376
00:13:39,040 --> 00:13:40,959
physical memory

377
00:13:40,959 --> 00:13:43,920
nowadays all major operating systems so

378
00:13:43,920 --> 00:13:46,160
linux windows and mac

379
00:13:46,160 --> 00:13:49,680
implement a page cache and

380
00:13:49,680 --> 00:13:51,279
now that we know where the page hash is

381
00:13:51,279 --> 00:13:53,440
let's look at a simple simple example

382
00:13:53,440 --> 00:13:53,839
how

383
00:13:53,839 --> 00:13:56,800
we could exploit it

384
00:13:58,800 --> 00:14:01,120
okay so let's now talk about a

385
00:14:01,120 --> 00:14:02,079
simplified page

386
00:14:02,079 --> 00:14:05,920
cache attack um over here we have

387
00:14:05,920 --> 00:14:08,959
um a victim um and then on

388
00:14:08,959 --> 00:14:12,240
the side we have an attacker and uh

389
00:14:12,240 --> 00:14:14,079
we have the operating system kind of in

390
00:14:14,079 --> 00:14:16,000
the middle so

391
00:14:16,000 --> 00:14:19,519
um what the victim does is it

392
00:14:19,519 --> 00:14:22,000
reads a page the first time you read a

393
00:14:22,000 --> 00:14:23,120
page obviously

394
00:14:23,120 --> 00:14:26,240
it will be a cache misc so

395
00:14:26,240 --> 00:14:29,120
um the operating system will go and have

396
00:14:29,120 --> 00:14:31,040
to fetch that page from

397
00:14:31,040 --> 00:14:35,120
disk and then any subsequent accesses to

398
00:14:35,120 --> 00:14:38,399
that page will be from the page cache

399
00:14:38,399 --> 00:14:41,760
so now that page is in ram

400
00:14:41,760 --> 00:14:44,880
and now if the attacker accesses that

401
00:14:44,880 --> 00:14:45,680
same page

402
00:14:45,680 --> 00:14:48,079
the access time should be very fast

403
00:14:48,079 --> 00:14:50,720
because that page is already in ram

404
00:14:50,720 --> 00:14:54,160
um how and and what you have to do next

405
00:14:54,160 --> 00:14:55,120
is

406
00:14:55,120 --> 00:14:57,440
now that the attacker has already like

407
00:14:57,440 --> 00:14:59,199
accessed this page and the attacker

408
00:14:59,199 --> 00:15:01,279
knows that the victim accessed this page

409
00:15:01,279 --> 00:15:02,240
because

410
00:15:02,240 --> 00:15:05,440
of like seeing the past access time now

411
00:15:05,440 --> 00:15:07,279
we want to evict that page out of the

412
00:15:07,279 --> 00:15:09,519
page cache so we can repeat this process

413
00:15:09,519 --> 00:15:11,680
and see when the next time the victim

414
00:15:11,680 --> 00:15:13,040
brings that same page again

415
00:15:13,040 --> 00:15:16,160
so to do this eviction we basically

416
00:15:16,160 --> 00:15:19,519
access a bunch of other pages

417
00:15:19,519 --> 00:15:22,320
that will eventually get rid of the

418
00:15:22,320 --> 00:15:23,760
target page

419
00:15:23,760 --> 00:15:26,959
that the attacker wants to bit and so

420
00:15:26,959 --> 00:15:30,480
now we have that target page evicted and

421
00:15:30,480 --> 00:15:33,680
again so if the victim accesses the page

422
00:15:33,680 --> 00:15:34,240
again

423
00:15:34,240 --> 00:15:36,320
uh it will again be fetched from disk

424
00:15:36,320 --> 00:15:38,160
and then it will be stored in cache

425
00:15:38,160 --> 00:15:39,519
again

426
00:15:39,519 --> 00:15:42,000
and so this way the attacker can

427
00:15:42,000 --> 00:15:44,320
basically just spy on the victim by just

428
00:15:44,320 --> 00:15:47,360
measuring the access times of uh

429
00:15:47,360 --> 00:15:50,639
shared pages so now that

430
00:15:50,639 --> 00:15:53,120
we know what the how an attack could

431
00:15:53,120 --> 00:15:55,199
look like let's look at the first big

432
00:15:55,199 --> 00:15:56,320
building block

433
00:15:56,320 --> 00:15:58,880
observing the page cache state state so

434
00:15:58,880 --> 00:16:01,199
the first idea is like in this example

435
00:16:01,199 --> 00:16:04,880
you just measure the access time but

436
00:16:04,880 --> 00:16:06,959
the problem with this is that if you

437
00:16:06,959 --> 00:16:08,079
access it

438
00:16:08,079 --> 00:16:09,920
you always load it into the cache and

439
00:16:09,920 --> 00:16:12,399
therefore you destroy the current state

440
00:16:12,399 --> 00:16:14,000
of the cache

441
00:16:14,000 --> 00:16:17,360
and this means even if other process or

442
00:16:17,360 --> 00:16:19,920
a victim didn't access the page you

443
00:16:19,920 --> 00:16:21,600
still have

444
00:16:21,600 --> 00:16:24,720
still have it in the cache and because

445
00:16:24,720 --> 00:16:26,720
of that you also have to evict it again

446
00:16:26,720 --> 00:16:29,440
so that you can monitor future accesses

447
00:16:29,440 --> 00:16:31,120
and that means that your

448
00:16:31,120 --> 00:16:33,680
average resolution in time decreases

449
00:16:33,680 --> 00:16:35,680
which is unfortunate

450
00:16:35,680 --> 00:16:38,800
but luckily the os develop

451
00:16:38,800 --> 00:16:40,639
developers came to our rescue and have

452
00:16:40,639 --> 00:16:42,880
provided nice apis to do that

453
00:16:42,880 --> 00:16:46,000
so for example on linux it's called

454
00:16:46,000 --> 00:16:48,240
min core and it basically takes a

455
00:16:48,240 --> 00:16:49,680
virtual page range

456
00:16:49,680 --> 00:16:51,279
and gives you back the information if

457
00:16:51,279 --> 00:16:53,920
this page is buffered in the page cache

458
00:16:53,920 --> 00:16:56,320
on windows there is a similar api called

459
00:16:56,320 --> 00:16:58,079
query working set

460
00:16:58,079 --> 00:17:01,120
a x and it basically also tells you for

461
00:17:01,120 --> 00:17:03,199
a virtual page range

462
00:17:03,199 --> 00:17:05,439
information about this pages so if it's

463
00:17:05,439 --> 00:17:07,599
in the working set how many process it

464
00:17:07,599 --> 00:17:10,480
processes use it and so on and with this

465
00:17:10,480 --> 00:17:12,319
information you can also deduce

466
00:17:12,319 --> 00:17:14,880
if it's used by multiple working sets or

467
00:17:14,880 --> 00:17:16,000
if it's um

468
00:17:16,000 --> 00:17:20,240
in some working set and

469
00:17:20,240 --> 00:17:22,799
um these things are non-destructive so

470
00:17:22,799 --> 00:17:24,559
they don't buffer it and therefore we

471
00:17:24,559 --> 00:17:26,079
get a higher average

472
00:17:26,079 --> 00:17:28,319
resolution because in the case a victim

473
00:17:28,319 --> 00:17:30,240
didn't access the page

474
00:17:30,240 --> 00:17:33,919
we don't have to evict it again and yeah

475
00:17:33,919 --> 00:17:35,440
then we go to the next big building

476
00:17:35,440 --> 00:17:39,440
block um the eviction

477
00:17:40,640 --> 00:17:43,280
awesome so the second part of this

478
00:17:43,280 --> 00:17:44,480
attack

479
00:17:44,480 --> 00:17:47,840
is to reset the page cache to evict the

480
00:17:47,840 --> 00:17:50,320
target pages that the attacker wants to

481
00:17:50,320 --> 00:17:51,200
observe

482
00:17:51,200 --> 00:17:53,760
and obviously this is necessary because

483
00:17:53,760 --> 00:17:55,840
we want to be able to detect multiple

484
00:17:55,840 --> 00:17:57,919
accesses to the same page so

485
00:17:57,919 --> 00:17:59,520
we want to get rid of the page so that

486
00:17:59,520 --> 00:18:01,280
the next time the victim accesses you

487
00:18:01,280 --> 00:18:03,200
can repeat this process

488
00:18:03,200 --> 00:18:05,120
and see precisely when the victim

489
00:18:05,120 --> 00:18:06,240
accessed this page

490
00:18:06,240 --> 00:18:09,679
again um so this is essentially the

491
00:18:09,679 --> 00:18:11,600
bottleneck of the site channel

492
00:18:11,600 --> 00:18:15,200
um because eviction is slow um

493
00:18:15,200 --> 00:18:18,480
and so the ideal strategy depends on the

494
00:18:18,480 --> 00:18:21,440
memory management implementation and

495
00:18:21,440 --> 00:18:22,400
there are differences

496
00:18:22,400 --> 00:18:24,640
in page replacement policies across

497
00:18:24,640 --> 00:18:26,640
different systems

498
00:18:26,640 --> 00:18:29,039
for linux you have a global clock pro

499
00:18:29,039 --> 00:18:30,960
like algorithm

500
00:18:30,960 --> 00:18:32,799
but for windows you have a different

501
00:18:32,799 --> 00:18:35,200
kind of uh replacement process where you

502
00:18:35,200 --> 00:18:35,919
have a per

503
00:18:35,919 --> 00:18:38,559
process working set with an aging

504
00:18:38,559 --> 00:18:40,480
algorithm

505
00:18:40,480 --> 00:18:42,559
and as these page replacements

506
00:18:42,559 --> 00:18:44,240
algorithms are different also our

507
00:18:44,240 --> 00:18:45,440
approaches are different

508
00:18:45,440 --> 00:18:47,440
and so now let's start with the linux

509
00:18:47,440 --> 00:18:48,480
approach

510
00:18:48,480 --> 00:18:50,640
so in linux it's basic the basic header

511
00:18:50,640 --> 00:18:52,320
is the same as in our example

512
00:18:52,320 --> 00:18:55,120
we just access new unique pages until

513
00:18:55,120 --> 00:18:56,000
the target page

514
00:18:56,000 --> 00:18:57,919
is replaced and therefore our basic

515
00:18:57,919 --> 00:18:59,919
eviction set is just a large memory

516
00:18:59,919 --> 00:19:01,360
mapped file

517
00:19:01,360 --> 00:19:03,679
and because that's then still quite slow

518
00:19:03,679 --> 00:19:06,160
because the page cast can grow very big

519
00:19:06,160 --> 00:19:08,480
and it basically can grow as long as you

520
00:19:08,480 --> 00:19:10,240
have available physical memory

521
00:19:10,240 --> 00:19:12,320
we have developed some optimizations for

522
00:19:12,320 --> 00:19:15,760
it so the first optimization is

523
00:19:15,760 --> 00:19:18,240
to add pages and do this x to this

524
00:19:18,240 --> 00:19:19,760
eviction set which are already in the

525
00:19:19,760 --> 00:19:21,039
page cache so

526
00:19:21,039 --> 00:19:24,240
basically we keep the approximation of

527
00:19:24,240 --> 00:19:26,160
the current working set active

528
00:19:26,160 --> 00:19:28,559
and that means it is less probable that

529
00:19:28,559 --> 00:19:30,480
other pages than the target page are

530
00:19:30,480 --> 00:19:31,440
evicted

531
00:19:31,440 --> 00:19:33,760
and that helps us with the with flow

532
00:19:33,760 --> 00:19:35,520
erection times and the system is more

533
00:19:35,520 --> 00:19:37,520
stable because pages that are used are

534
00:19:37,520 --> 00:19:40,640
that likely kicked out and the second

535
00:19:40,640 --> 00:19:42,320
optimization is

536
00:19:42,320 --> 00:19:44,880
filling the um the memory with anonymous

537
00:19:44,880 --> 00:19:46,080
dirty pages

538
00:19:46,080 --> 00:19:48,799
and by that we gained that anonymous

539
00:19:48,799 --> 00:19:50,320
dirty pages are there

540
00:19:50,320 --> 00:19:51,919
basically the last candidates for

541
00:19:51,919 --> 00:19:53,360
eviction and

542
00:19:53,360 --> 00:19:55,200
even more so if you have swapping

543
00:19:55,200 --> 00:19:57,919
disabled they can't be evicted

544
00:19:57,919 --> 00:20:00,640
and therefore this practically reduces

545
00:20:00,640 --> 00:20:01,840
the size of the

546
00:20:01,840 --> 00:20:04,559
a weak stable page cache and that means

547
00:20:04,559 --> 00:20:06,000
we have less possible eviction

548
00:20:06,000 --> 00:20:08,320
candidates and that means we are faster

549
00:20:08,320 --> 00:20:11,520
at in the eviction and

550
00:20:11,520 --> 00:20:14,000
yeah with all these optimizations we get

551
00:20:14,000 --> 00:20:15,880
to an average run time around

552
00:20:15,880 --> 00:20:19,039
149 milliseconds depending on how

553
00:20:19,039 --> 00:20:21,039
the optimizations are configured you can

554
00:20:21,039 --> 00:20:22,720
also get lower but then you have more

555
00:20:22,720 --> 00:20:25,440
cpu utilization and it's not so stealthy

556
00:20:25,440 --> 00:20:26,400
anymore

557
00:20:26,400 --> 00:20:28,400
and after seeing this linux approaches

558
00:20:28,400 --> 00:20:32,080
let's look at the windows you want

559
00:20:32,080 --> 00:20:35,600
okay so on the windows side a page cache

560
00:20:35,600 --> 00:20:36,240
eviction

561
00:20:36,240 --> 00:20:39,200
basically means the target page is

562
00:20:39,200 --> 00:20:40,159
dropped out of

563
00:20:40,159 --> 00:20:43,360
all of the working sets um and so

564
00:20:43,360 --> 00:20:45,280
the previous approach will be kind of

565
00:20:45,280 --> 00:20:46,880
slow and

566
00:20:46,880 --> 00:20:49,360
the optimizations we use for windows are

567
00:20:49,360 --> 00:20:49,919
to

568
00:20:49,919 --> 00:20:52,480
increase the working set size and the

569
00:20:52,480 --> 00:20:53,760
memory pressure

570
00:20:53,760 --> 00:20:56,240
and this leads to self-eviction of the

571
00:20:56,240 --> 00:20:56,799
page

572
00:20:56,799 --> 00:20:59,919
and it's it's less than um

573
00:20:59,919 --> 00:21:04,400
two seconds um you can also evict page

574
00:21:04,400 --> 00:21:06,000
in any other processes

575
00:21:06,000 --> 00:21:08,960
uh by set process working set size you

576
00:21:08,960 --> 00:21:09,520
can

577
00:21:09,520 --> 00:21:12,559
limit the working set size and induce

578
00:21:12,559 --> 00:21:13,280
eviction

579
00:21:13,280 --> 00:21:16,640
in another process if you want to um

580
00:21:16,640 --> 00:21:20,000
and this is for processes with the same

581
00:21:20,000 --> 00:21:21,120
integrity level

582
00:21:21,120 --> 00:21:23,200
as the attacker so it won't work with a

583
00:21:23,200 --> 00:21:25,520
process a victim process that's more

584
00:21:25,520 --> 00:21:26,400
privileged

585
00:21:26,400 --> 00:21:30,240
than the attackers and

586
00:21:30,240 --> 00:21:33,600
evicting pages in your own working set

587
00:21:33,600 --> 00:21:36,640
uh is done by virtual unlock

588
00:21:36,640 --> 00:21:40,559
uh which gives around 7.69 microseconds

589
00:21:40,559 --> 00:21:44,000
uh of latency so

590
00:21:44,000 --> 00:21:46,480
why is this doing this this is basically

591
00:21:46,480 --> 00:21:49,840
not a documented feature

592
00:21:50,159 --> 00:21:54,640
uh so let's um come to the first example

593
00:21:54,640 --> 00:21:56,559
of of our side channel how can you use

594
00:21:56,559 --> 00:21:57,039
it

595
00:21:57,039 --> 00:21:59,280
and the first simple thing you can do is

596
00:21:59,280 --> 00:22:01,280
just talking over the side channel

597
00:22:01,280 --> 00:22:04,559
so basically chatting over files

598
00:22:04,559 --> 00:22:06,960
and this is done by using a shared file

599
00:22:06,960 --> 00:22:08,400
as information carrier

600
00:22:08,400 --> 00:22:10,960
and then you encode the message bits as

601
00:22:10,960 --> 00:22:13,280
file page presence in the page cache

602
00:22:13,280 --> 00:22:14,960
so for example you say the page is

603
00:22:14,960 --> 00:22:17,039
present in the page cache it's a one the

604
00:22:17,039 --> 00:22:19,039
page is not present it's a zero

605
00:22:19,039 --> 00:22:21,919
and some pages you have to reserve for

606
00:22:21,919 --> 00:22:23,679
transmission control so you say yeah for

607
00:22:23,679 --> 00:22:25,360
example acknowledged or

608
00:22:25,360 --> 00:22:28,640
ready to send and such things and

609
00:22:28,640 --> 00:22:30,240
there are quite a few different

610
00:22:30,240 --> 00:22:32,159
implementation approaches

611
00:22:32,159 --> 00:22:34,799
and if you have a look on on them we see

612
00:22:34,799 --> 00:22:35,679
for example

613
00:22:35,679 --> 00:22:37,520
that the linux if we do it like in the

614
00:22:37,520 --> 00:22:38,960
side channel so if this

615
00:22:38,960 --> 00:22:41,120
eviction approach we explained and used

616
00:22:41,120 --> 00:22:43,440
minkow observation we get a speed

617
00:22:43,440 --> 00:22:46,960
about around 20.20 kilobytes

618
00:22:46,960 --> 00:22:49,120
and if you use m advice and postxf

619
00:22:49,120 --> 00:22:51,280
advice which is only possible if they

620
00:22:51,280 --> 00:22:54,320
at their case the sole user of the file

621
00:22:54,320 --> 00:22:59,520
then we can get 81.16 kilobytes a second

622
00:22:59,520 --> 00:23:02,480
and on windows we use this process

623
00:23:02,480 --> 00:23:04,000
working set direction with virtual

624
00:23:04,000 --> 00:23:04,559
unlock

625
00:23:04,559 --> 00:23:07,600
and query working set 8x

626
00:23:07,600 --> 00:23:09,600
for monitoring the account so basically

627
00:23:09,600 --> 00:23:11,520
the attacker and the reader maps it

628
00:23:11,520 --> 00:23:13,280
and if they then see a move in the share

629
00:23:13,280 --> 00:23:14,559
count they know

630
00:23:14,559 --> 00:23:17,280
some the reader has flashed it from the

631
00:23:17,280 --> 00:23:18,559
working set or

632
00:23:18,559 --> 00:23:22,240
vice versa and with this you can get

633
00:23:22,240 --> 00:23:25,280
a speed of around 100.11 kilobytes

634
00:23:25,280 --> 00:23:29,039
per second and all these approaches have

635
00:23:29,039 --> 00:23:30,640
in common that they have a very low bit

636
00:23:30,640 --> 00:23:31,600
error rate

637
00:23:31,600 --> 00:23:33,280
as long as no other application

638
00:23:33,280 --> 00:23:34,880
pressures the system memory

639
00:23:34,880 --> 00:23:36,880
so you can can get down to very low

640
00:23:36,880 --> 00:23:38,240
numbers here

641
00:23:38,240 --> 00:23:41,360
and the next example we have is a

642
00:23:41,360 --> 00:23:43,840
is an attack on the php random number

643
00:23:43,840 --> 00:23:46,480
generator

644
00:23:47,279 --> 00:23:50,000
awesome so now let's talk about our

645
00:23:50,000 --> 00:23:51,600
second attack which is the

646
00:23:51,600 --> 00:23:55,600
php pseudorandom number generator attack

647
00:23:55,600 --> 00:23:58,559
um so here the victim process basically

648
00:23:58,559 --> 00:23:59,200
seeds

649
00:23:59,200 --> 00:24:02,240
uh their um pseudorandom number

650
00:24:02,240 --> 00:24:04,240
generator with uh

651
00:24:04,240 --> 00:24:06,320
the system time and it uses the micro

652
00:24:06,320 --> 00:24:07,600
time function

653
00:24:07,600 --> 00:24:10,799
um which is used in some frameworks and

654
00:24:10,799 --> 00:24:12,320
the micro time function essentially

655
00:24:12,320 --> 00:24:14,000
returns the unix timestamp

656
00:24:14,000 --> 00:24:17,039
in microseconds and

657
00:24:17,039 --> 00:24:20,159
um unfortunately this

658
00:24:20,159 --> 00:24:23,039
uh seating is used for some cryptograph

659
00:24:23,039 --> 00:24:25,039
cryptographic operations which is not

660
00:24:25,039 --> 00:24:27,360
ideal because um it just makes the

661
00:24:27,360 --> 00:24:28,400
system weaker

662
00:24:28,400 --> 00:24:31,200
uh because the time is kind of guessable

663
00:24:31,200 --> 00:24:33,679
and what we do here with the page cash

664
00:24:33,679 --> 00:24:34,240
attack

665
00:24:34,240 --> 00:24:38,080
is we try to detect um the

666
00:24:38,080 --> 00:24:41,360
use of the micro time uh call

667
00:24:41,360 --> 00:24:44,480
so we can get exactly when that call was

668
00:24:44,480 --> 00:24:45,360
used so

669
00:24:45,360 --> 00:24:48,080
through that we can infer um the system

670
00:24:48,080 --> 00:24:49,679
time that was returned by

671
00:24:49,679 --> 00:24:52,000
microtime if we can detect when

672
00:24:52,000 --> 00:24:53,760
microtime was called

673
00:24:53,760 --> 00:24:57,200
um so this makes the seed recoverable

674
00:24:57,200 --> 00:25:00,240
and uh what we do is we look for

675
00:25:00,240 --> 00:25:03,440
the zip micro time call which is on

676
00:25:03,440 --> 00:25:06,559
page 781 of the uh

677
00:25:06,559 --> 00:25:09,760
executable that is our target

678
00:25:09,760 --> 00:25:13,279
um and it depends uh

679
00:25:13,279 --> 00:25:15,279
on different build environment settings

680
00:25:15,279 --> 00:25:18,679
for this particular attack we use php

681
00:25:18,679 --> 00:25:20,240
7.3.5

682
00:25:20,240 --> 00:25:23,039
and the average detection accuracy was

683
00:25:23,039 --> 00:25:23,600
within

684
00:25:23,600 --> 00:25:25,840
one millisecond which is pretty good and

685
00:25:25,840 --> 00:25:27,279
so the seat was

686
00:25:27,279 --> 00:25:30,000
very easily recovered as we will now

687
00:25:30,000 --> 00:25:31,520
show

688
00:25:31,520 --> 00:25:33,840
now let's look at the live demo of this

689
00:25:33,840 --> 00:25:35,919
attack so on the left side you see the

690
00:25:35,919 --> 00:25:37,279
bhb my faq

691
00:25:37,279 --> 00:25:40,559
um framework which uses this microtime

692
00:25:40,559 --> 00:25:42,400
call to generate the password

693
00:25:42,400 --> 00:25:45,039
and on the right side you see the deck

694
00:25:45,039 --> 00:25:46,000
window

695
00:25:46,000 --> 00:25:48,880
and now what i do is i request a new

696
00:25:48,880 --> 00:25:50,159
password

697
00:25:50,159 --> 00:25:53,600
and by doing that i enter my credentials

698
00:25:53,600 --> 00:25:56,960
and then i send it and then this call to

699
00:25:56,960 --> 00:25:58,159
the microtime function

700
00:25:58,159 --> 00:26:01,520
is detected by the attack and

701
00:26:01,520 --> 00:26:03,600
then we can basically recover the

702
00:26:03,600 --> 00:26:05,679
approximate timestamp which was returned

703
00:26:05,679 --> 00:26:06,720
by microtime

704
00:26:06,720 --> 00:26:08,480
and using this information we can use

705
00:26:08,480 --> 00:26:10,559
the same algorithm as the page users for

706
00:26:10,559 --> 00:26:12,080
creating passwords

707
00:26:12,080 --> 00:26:15,279
and then create the passwords by ourself

708
00:26:15,279 --> 00:26:19,840
and as you can see the ideal password

709
00:26:19,840 --> 00:26:22,000
is so the from the recovered timestamp

710
00:26:22,000 --> 00:26:24,159
is not that far away from the real

711
00:26:24,159 --> 00:26:27,120
password created by the page it's around

712
00:26:27,120 --> 00:26:29,600
11 positions away so that it's

713
00:26:29,600 --> 00:26:32,719
quite a good result

714
00:26:36,720 --> 00:26:38,960
all right so the previous two attacks

715
00:26:38,960 --> 00:26:40,559
were really good now let's talk about

716
00:26:40,559 --> 00:26:41,600
our third attack

717
00:26:41,600 --> 00:26:44,640
which is the ui redressing attacks

718
00:26:44,640 --> 00:26:47,520
so this attack is all about uh

719
00:26:47,520 --> 00:26:49,679
overlaying fake windows on top of

720
00:26:49,679 --> 00:26:51,919
real windows uh to trick the user into

721
00:26:51,919 --> 00:26:53,919
typing in sensitive information

722
00:26:53,919 --> 00:26:56,640
so let's see how we can do that so what

723
00:26:56,640 --> 00:26:58,559
the first thing we need to do is we need

724
00:26:58,559 --> 00:26:58,960
to

725
00:26:58,960 --> 00:27:00,720
detect the opening of an interesting

726
00:27:00,720 --> 00:27:02,080
window

727
00:27:02,080 --> 00:27:04,880
so authentication windows are a very

728
00:27:04,880 --> 00:27:06,480
good example for this

729
00:27:06,480 --> 00:27:09,679
um and as soon as this happens as soon

730
00:27:09,679 --> 00:27:10,159
as you

731
00:27:10,159 --> 00:27:13,600
detect that uh the the interesting

732
00:27:13,600 --> 00:27:15,760
window is open you overlay that window

733
00:27:15,760 --> 00:27:17,200
with the fake window and

734
00:27:17,200 --> 00:27:18,799
trick the user into entering their

735
00:27:18,799 --> 00:27:20,880
information there so this would be like

736
00:27:20,880 --> 00:27:22,960
a password that's entered into the fake

737
00:27:22,960 --> 00:27:25,039
authentication window

738
00:27:25,039 --> 00:27:28,080
and so how do we detect uh

739
00:27:28,080 --> 00:27:30,399
when this interesting window is open so

740
00:27:30,399 --> 00:27:32,320
we use the site channel essentially the

741
00:27:32,320 --> 00:27:33,760
page hash side channel

742
00:27:33,760 --> 00:27:36,559
as a trigger so the attacker detects

743
00:27:36,559 --> 00:27:37,760
when that page

744
00:27:37,760 --> 00:27:40,960
uh for the uh original window so the

745
00:27:40,960 --> 00:27:42,799
real window is accessed and as soon as

746
00:27:42,799 --> 00:27:44,159
that's accessed

747
00:27:44,159 --> 00:27:46,240
the attacker triggers their own attack

748
00:27:46,240 --> 00:27:47,440
and

749
00:27:47,440 --> 00:27:51,679
releases their own fake window on top of

750
00:27:51,679 --> 00:27:53,919
the real window and so this provides a

751
00:27:53,919 --> 00:27:55,440
very low latency

752
00:27:55,440 --> 00:27:59,120
um and hardly noticeable attack

753
00:27:59,120 --> 00:28:01,440
because it's very fast you can detect

754
00:28:01,440 --> 00:28:02,880
this very quickly

755
00:28:02,880 --> 00:28:05,520
and overlay your fake window and we

756
00:28:05,520 --> 00:28:06,320
tested this

757
00:28:06,320 --> 00:28:08,799
with a root authentication window on

758
00:28:08,799 --> 00:28:11,679
ubuntu 16.04

759
00:28:11,679 --> 00:28:13,600
and the page in question that the

760
00:28:13,600 --> 00:28:15,919
attacker had to detect was page 6

761
00:28:15,919 --> 00:28:19,039
of this

762
00:28:19,039 --> 00:28:21,039
library file essentially and so we'll

763
00:28:21,039 --> 00:28:22,399
show a demo

764
00:28:22,399 --> 00:28:26,559
of how this whole process works

765
00:28:26,559 --> 00:28:29,120
you see that i have the update dialog of

766
00:28:29,120 --> 00:28:31,600
ubuntu 16.04 open

767
00:28:31,600 --> 00:28:33,520
and if i now start an update a root

768
00:28:33,520 --> 00:28:35,120
authentication window spawns

769
00:28:35,120 --> 00:28:36,559
and this is detected by the deck and

770
00:28:36,559 --> 00:28:38,640
overlapped by a fake one and you saw it

771
00:28:38,640 --> 00:28:40,240
it was a fake window now below is the

772
00:28:40,240 --> 00:28:42,399
real window and we basically

773
00:28:42,399 --> 00:28:44,559
stole the password from the user by this

774
00:28:44,559 --> 00:28:46,240
and you can hardly know this is because

775
00:28:46,240 --> 00:28:48,559
latency

776
00:28:48,559 --> 00:28:52,000
so after we saw all these examples

777
00:28:52,000 --> 00:28:54,480
um did we did it had any impact was

778
00:28:54,480 --> 00:28:56,640
somebody interested in this attack

779
00:28:56,640 --> 00:29:00,000
oh interest there was so much interest

780
00:29:00,000 --> 00:29:01,039
in this i remember

781
00:29:01,039 --> 00:29:03,440
all of the press coverage that we got

782
00:29:03,440 --> 00:29:05,679
because of this attack and uh

783
00:29:05,679 --> 00:29:08,080
um actually that's a good segue now

784
00:29:08,080 --> 00:29:10,080
actually let's talk about the impact

785
00:29:10,080 --> 00:29:13,760
um that this um attack had so

786
00:29:13,760 --> 00:29:16,320
this attack was basically identified as

787
00:29:16,320 --> 00:29:16,799
cb

788
00:29:16,799 --> 00:29:20,799
2019 5489 and it generated as i said

789
00:29:20,799 --> 00:29:24,559
tons of press um and both linux and

790
00:29:24,559 --> 00:29:26,000
windows

791
00:29:26,000 --> 00:29:27,840
deployed a lot of counter measures to

792
00:29:27,840 --> 00:29:29,440
prevent this attack

793
00:29:29,440 --> 00:29:34,640
and there were patches everywhere

794
00:29:34,640 --> 00:29:37,520
patches batches patches so let's start

795
00:29:37,520 --> 00:29:38,399
with windows

796
00:29:38,399 --> 00:29:41,679
and what they did is they uh raised the

797
00:29:41,679 --> 00:29:43,919
privilege for querying working set aax

798
00:29:43,919 --> 00:29:45,360
on other processes

799
00:29:45,360 --> 00:29:48,240
and that basically mean means you can't

800
00:29:48,240 --> 00:29:48,720
make

801
00:29:48,720 --> 00:29:51,360
non-destructive probing of a different

802
00:29:51,360 --> 00:29:52,720
working set

803
00:29:52,720 --> 00:29:56,320
and they also hit

804
00:29:56,320 --> 00:29:57,760
did hide the share count for

805
00:29:57,760 --> 00:29:59,840
unprivileged users because of this

806
00:29:59,840 --> 00:30:01,200
information you can also

807
00:30:01,200 --> 00:30:04,240
indirectly probe if a

808
00:30:04,240 --> 00:30:08,080
page is used by a different working set

809
00:30:08,080 --> 00:30:12,000
and therefore non-destructive

810
00:30:12,000 --> 00:30:14,000
growing is not no more possible for

811
00:30:14,000 --> 00:30:16,240
higher integrity processes

812
00:30:16,240 --> 00:30:18,960
and this basically makes their deck a

813
00:30:18,960 --> 00:30:19,520
lot

814
00:30:19,520 --> 00:30:21,760
a lot weaker because you only can attack

815
00:30:21,760 --> 00:30:22,720
processes

816
00:30:22,720 --> 00:30:25,200
within the same user which is also

817
00:30:25,200 --> 00:30:26,559
interesting but it's

818
00:30:26,559 --> 00:30:28,640
it's much worse if you add that higher

819
00:30:28,640 --> 00:30:29,919
integrity processes like the

820
00:30:29,919 --> 00:30:31,679
administrators process or something like

821
00:30:31,679 --> 00:30:32,799
that

822
00:30:32,799 --> 00:30:35,919
and yeah that only holds true if kyrie

823
00:30:35,919 --> 00:30:38,000
working said ax is the only possible

824
00:30:38,000 --> 00:30:38,640
leakage

825
00:30:38,640 --> 00:30:42,000
source which that doesn't has to be the

826
00:30:42,000 --> 00:30:43,679
case as we see on the next slide for

827
00:30:43,679 --> 00:30:45,279
linux

828
00:30:45,279 --> 00:30:48,240
and yeah the eviction in itself is

829
00:30:48,240 --> 00:30:49,440
already a lot harder

830
00:30:49,440 --> 00:30:51,600
on windows because of this working set

831
00:30:51,600 --> 00:30:53,200
approach they have

832
00:30:53,200 --> 00:30:55,760
and yeah then let's move on with the

833
00:30:55,760 --> 00:30:57,600
linux countermeasures

834
00:30:57,600 --> 00:31:00,720
so now let's talk about what people did

835
00:31:00,720 --> 00:31:01,360
on the

836
00:31:01,360 --> 00:31:03,760
linux site so the first thing that they

837
00:31:03,760 --> 00:31:05,279
fixed on the linux side

838
00:31:05,279 --> 00:31:07,279
was fixing the min core system call

839
00:31:07,279 --> 00:31:09,200
which essentially is what was used to

840
00:31:09,200 --> 00:31:10,480
spy on these

841
00:31:10,480 --> 00:31:13,279
pages in the page cache so now after the

842
00:31:13,279 --> 00:31:14,320
fixes

843
00:31:14,320 --> 00:31:17,760
mincor only reveals information on

844
00:31:17,760 --> 00:31:21,120
writable pages so this means that if the

845
00:31:21,120 --> 00:31:21,919
attacker

846
00:31:21,919 --> 00:31:24,559
has only read permissions to a page it

847
00:31:24,559 --> 00:31:25,919
can no longer use

848
00:31:25,919 --> 00:31:28,880
mint core to spy on that page because of

849
00:31:28,880 --> 00:31:30,840
the patch made to the mint core system

850
00:31:30,840 --> 00:31:33,039
call and so

851
00:31:33,039 --> 00:31:35,760
read-only files are excluded so all the

852
00:31:35,760 --> 00:31:36,960
shared libraries

853
00:31:36,960 --> 00:31:39,200
it's executables and basically a lot of

854
00:31:39,200 --> 00:31:41,039
stuff that would be of interest to the

855
00:31:41,039 --> 00:31:41,919
attacker

856
00:31:41,919 --> 00:31:44,159
is now no longer accessible through

857
00:31:44,159 --> 00:31:45,519
midcore

858
00:31:45,519 --> 00:31:48,640
and this was merged with the release of

859
00:31:48,640 --> 00:31:52,720
the kernel version 5.1.4

860
00:31:52,720 --> 00:31:55,519
and so is non-destructive probing no

861
00:31:55,519 --> 00:31:57,760
longer possible

862
00:31:57,760 --> 00:32:01,840
let's see actually no because pre-advice

863
00:32:01,840 --> 00:32:04,320
2 which is another system called used

864
00:32:04,320 --> 00:32:05,200
with the our

865
00:32:05,200 --> 00:32:08,799
rwf no wait flag leaks the exactly same

866
00:32:08,799 --> 00:32:11,519
information um that meant core leaked

867
00:32:11,519 --> 00:32:12,399
and so

868
00:32:12,399 --> 00:32:15,840
that's not fixed yet um

869
00:32:15,840 --> 00:32:18,720
and this basically shows how hard it is

870
00:32:18,720 --> 00:32:19,440
to fix

871
00:32:19,440 --> 00:32:21,760
uh an issue like this because there's a

872
00:32:21,760 --> 00:32:23,600
lot of different ways that you can get

873
00:32:23,600 --> 00:32:24,559
the same

874
00:32:24,559 --> 00:32:27,600
information out um as an attacker so if

875
00:32:27,600 --> 00:32:29,919
you it's like whack-a-mole so you

876
00:32:29,919 --> 00:32:31,600
fix one thing and then there's this

877
00:32:31,600 --> 00:32:33,279
other thing that you also need to fix

878
00:32:33,279 --> 00:32:35,919
so yeah it's it's it's not easy to fix a

879
00:32:35,919 --> 00:32:38,240
vulnerability like this

880
00:32:38,240 --> 00:32:41,440
yes but the thing is also we want

881
00:32:41,440 --> 00:32:43,679
performance optimization so we want to

882
00:32:43,679 --> 00:32:45,679
keep them we don't want to fix all these

883
00:32:45,679 --> 00:32:46,399
things

884
00:32:46,399 --> 00:32:49,840
that could be abused for attacks because

885
00:32:49,840 --> 00:32:52,960
we might lease lose performance again

886
00:32:52,960 --> 00:32:55,840
so many of these things we see here they

887
00:32:55,840 --> 00:32:57,519
show side channel leakage on the one

888
00:32:57,519 --> 00:32:58,480
side yes

889
00:32:58,480 --> 00:33:00,720
but they are also intended behavior for

890
00:33:00,720 --> 00:33:02,559
performance optimizations

891
00:33:02,559 --> 00:33:04,960
so that's really really difficult to

892
00:33:04,960 --> 00:33:06,159
find this trade-off

893
00:33:06,159 --> 00:33:10,159
between security and performance

894
00:33:10,159 --> 00:33:13,279
and every optimization that we have

895
00:33:13,279 --> 00:33:15,760
being in hardware built-in software has

896
00:33:15,760 --> 00:33:16,880
this potential

897
00:33:16,880 --> 00:33:19,360
side channel if you optimize something

898
00:33:19,360 --> 00:33:21,200
for performance

899
00:33:21,200 --> 00:33:24,080
so this does not look very good right so

900
00:33:24,080 --> 00:33:26,240
this means that we won't get rid of side

901
00:33:26,240 --> 00:33:27,360
channels because we

902
00:33:27,360 --> 00:33:31,760
want to have the performance advantage

903
00:33:32,480 --> 00:33:34,240
and with more and more optimizations

904
00:33:34,240 --> 00:33:36,480
that we now add in our software and

905
00:33:36,480 --> 00:33:37,279
hardware

906
00:33:37,279 --> 00:33:39,919
to keep up the the performance and

907
00:33:39,919 --> 00:33:42,480
improve the performance year by year

908
00:33:42,480 --> 00:33:44,240
that means we add more and more side

909
00:33:44,240 --> 00:33:45,840
channels and that means we will have

910
00:33:45,840 --> 00:33:48,399
more and more leakage

911
00:33:48,399 --> 00:33:51,679
so what we see here is what we asked

912
00:33:51,679 --> 00:33:52,640
initially

913
00:33:52,640 --> 00:33:55,200
the micro architecture in software there

914
00:33:55,200 --> 00:33:57,200
is actually something like a micro

915
00:33:57,200 --> 00:33:59,440
architecture of the operating system

916
00:33:59,440 --> 00:34:02,159
and here we presented attacks on this

917
00:34:02,159 --> 00:34:03,840
micro architecture

918
00:34:03,840 --> 00:34:06,799
and we can expect more attacks on the

919
00:34:06,799 --> 00:34:08,800
operating system micro architecture

920
00:34:08,800 --> 00:34:13,040
in the future so um

921
00:34:13,040 --> 00:34:16,239
conclusion is abstractions eventually

922
00:34:16,239 --> 00:34:17,599
lead to side channels

923
00:34:17,599 --> 00:34:20,879
it's an inevitable byproduct of these

924
00:34:20,879 --> 00:34:24,800
abstractions and we saw that software

925
00:34:24,800 --> 00:34:26,719
cache decks are very similar to hardware

926
00:34:26,719 --> 00:34:29,439
cache attacks

927
00:34:30,239 --> 00:34:32,639
and finding counter measures is

928
00:34:32,639 --> 00:34:35,119
extremely devilishly difficult for these

929
00:34:35,119 --> 00:34:37,520
attacks

930
00:34:37,679 --> 00:34:40,239
with that we would like to thank you um

931
00:34:40,239 --> 00:34:41,599
there were a lot of other people

932
00:34:41,599 --> 00:34:42,719
involved with

933
00:34:42,719 --> 00:34:45,918
this work so please check out our paper

934
00:34:45,918 --> 00:34:47,119
and of course we have to also

935
00:34:47,119 --> 00:34:49,119
acknowledge a lot of people that helped

936
00:34:49,119 --> 00:34:49,440
us

937
00:34:49,440 --> 00:34:51,679
and companies that helped us with

938
00:34:51,679 --> 00:34:53,359
funding this research

939
00:34:53,359 --> 00:34:55,359
um and with that we would like to

940
00:34:55,359 --> 00:34:57,040
conclude our talk thank you for

941
00:34:57,040 --> 00:34:58,640
listening and if you have any questions

942
00:34:58,640 --> 00:35:00,400
we would really like to answer them now

943
00:35:00,400 --> 00:35:01,599
in the q a

944
00:35:01,599 --> 00:35:04,560
where we are awakening

945
00:35:04,800 --> 00:35:14,000
now it's over

