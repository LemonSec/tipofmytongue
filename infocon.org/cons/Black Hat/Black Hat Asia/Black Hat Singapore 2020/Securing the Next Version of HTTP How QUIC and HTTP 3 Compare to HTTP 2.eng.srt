1
00:00:02,560 --> 00:00:03,520
good morning

2
00:00:03,520 --> 00:00:05,440
my name is nick harper and i will be

3
00:00:05,440 --> 00:00:07,680
presenting on the security aspects

4
00:00:07,680 --> 00:00:11,679
of http 3 and quick i've been working on

5
00:00:11,679 --> 00:00:13,360
implementing quick at google for the

6
00:00:13,360 --> 00:00:14,880
past few years

7
00:00:14,880 --> 00:00:16,800
and i also participate in standardizing

8
00:00:16,800 --> 00:00:19,840
the protocol at the ietf

9
00:00:19,840 --> 00:00:21,920
quik is a new general purpose transport

10
00:00:21,920 --> 00:00:22,880
protocol

11
00:00:22,880 --> 00:00:24,880
it is always encrypted and provides

12
00:00:24,880 --> 00:00:26,800
multiple streams of application data in

13
00:00:26,800 --> 00:00:28,080
the same connection

14
00:00:28,080 --> 00:00:30,080
with packet loss on one stream not

15
00:00:30,080 --> 00:00:33,040
affecting other streams

16
00:00:33,040 --> 00:00:36,160
http 3 is an application protocol built

17
00:00:36,160 --> 00:00:36,880
on quick

18
00:00:36,880 --> 00:00:40,239
that provides http semantics its feature

19
00:00:40,239 --> 00:00:40,640
set

20
00:00:40,640 --> 00:00:43,200
is practically identical to that of http

21
00:00:43,200 --> 00:00:45,039
2.

22
00:00:45,039 --> 00:00:47,840
the purpose of quick and http 3 is to

23
00:00:47,840 --> 00:00:51,840
improve performance compared to http 2.

24
00:00:51,840 --> 00:00:53,920
over the course of this talk i will show

25
00:00:53,920 --> 00:00:56,719
how the protocol stack for http 3

26
00:00:56,719 --> 00:00:59,440
differs from http 2 and examine in

27
00:00:59,440 --> 00:01:01,120
detail many of the features

28
00:01:01,120 --> 00:01:04,159
that are moved into the quick protocol i

29
00:01:04,159 --> 00:01:06,080
will also explore security related

30
00:01:06,080 --> 00:01:07,600
mechanisms used in quick

31
00:01:07,600 --> 00:01:10,840
throughout the lifetime of a quick

32
00:01:10,840 --> 00:01:12,560
connection

33
00:01:12,560 --> 00:01:15,360
let's start by looking at how the http 2

34
00:01:15,360 --> 00:01:16,479
protocol stack

35
00:01:16,479 --> 00:01:19,520
differs from http 3.

36
00:01:19,520 --> 00:01:21,840
at the bottom of both protocol stacks we

37
00:01:21,840 --> 00:01:22,720
have ip

38
00:01:22,720 --> 00:01:24,880
which transmits messages between two

39
00:01:24,880 --> 00:01:27,840
addresses on the internet

40
00:01:27,840 --> 00:01:30,799
the next layer up in the http 2 protocol

41
00:01:30,799 --> 00:01:31,280
stack

42
00:01:31,280 --> 00:01:34,640
is tcp tcp provides an in-order

43
00:01:34,640 --> 00:01:36,720
reliable byte stream and allows the

44
00:01:36,720 --> 00:01:37,680
operating system

45
00:01:37,680 --> 00:01:39,759
to dispatch incoming connections to

46
00:01:39,759 --> 00:01:40,799
different processes

47
00:01:40,799 --> 00:01:43,920
based on port numbers

48
00:01:44,159 --> 00:01:46,720
tls runs on top of an in-order reliable

49
00:01:46,720 --> 00:01:47,439
byte stream

50
00:01:47,439 --> 00:01:49,920
such as the one provided by tcp and it

51
00:01:49,920 --> 00:01:51,600
provides that same abstraction to the

52
00:01:51,600 --> 00:01:52,799
level above it

53
00:01:52,799 --> 00:01:55,520
but tls adds confidentiality and

54
00:01:55,520 --> 00:01:58,960
integrity to its messages

55
00:01:58,960 --> 00:02:02,560
http 2 sits on top of this whole stack

56
00:02:02,560 --> 00:02:04,159
and it provides a way to multiplex

57
00:02:04,159 --> 00:02:07,520
streams on a single connection

58
00:02:07,520 --> 00:02:10,479
in http 3 all of the functionality that

59
00:02:10,479 --> 00:02:11,520
i just described

60
00:02:11,520 --> 00:02:15,120
is moved into the quick protocol

61
00:02:16,560 --> 00:02:19,280
let's start by examining the transport

62
00:02:19,280 --> 00:02:20,000
handshake

63
00:02:20,000 --> 00:02:23,120
in quick and how that compares to a tcp

64
00:02:23,120 --> 00:02:25,680
handshake

65
00:02:26,640 --> 00:02:29,440
in this packet trace we have a client on

66
00:02:29,440 --> 00:02:30,080
the left

67
00:02:30,080 --> 00:02:32,400
which initiates a quick connection and a

68
00:02:32,400 --> 00:02:36,959
server on the right

69
00:02:36,959 --> 00:02:39,680
in a tcp three-way handshake when the

70
00:02:39,680 --> 00:02:42,080
client receives a synack from the server

71
00:02:42,080 --> 00:02:43,920
it can verify that it had to be in

72
00:02:43,920 --> 00:02:46,080
response to its sin

73
00:02:46,080 --> 00:02:48,319
likewise when the server receives the

74
00:02:48,319 --> 00:02:50,000
first act from the client

75
00:02:50,000 --> 00:02:52,800
it can verify that it was in response to

76
00:02:52,800 --> 00:02:55,040
the

77
00:02:57,440 --> 00:02:59,040
likewise when the server receives the

78
00:02:59,040 --> 00:03:00,959
first act from the client it can verify

79
00:03:00,959 --> 00:03:02,159
that it was in response

80
00:03:02,159 --> 00:03:04,319
to the server's synack and since the

81
00:03:04,319 --> 00:03:06,319
synack was sent to the source ip address

82
00:03:06,319 --> 00:03:07,519
in the syn packet

83
00:03:07,519 --> 00:03:09,360
the client is able to send and receive

84
00:03:09,360 --> 00:03:12,400
packets at that address

85
00:03:12,400 --> 00:03:14,480
in the quick handshake we have similar

86
00:03:14,480 --> 00:03:15,599
confirmation

87
00:03:15,599 --> 00:03:18,480
that the client is able to send and

88
00:03:18,480 --> 00:03:21,760
receive packets at its source ip address

89
00:03:21,760 --> 00:03:23,440
the client can verify that the server's

90
00:03:23,440 --> 00:03:24,879
tls handshake messages

91
00:03:24,879 --> 00:03:26,799
are in response to the client's tls

92
00:03:26,799 --> 00:03:28,000
client hello

93
00:03:28,000 --> 00:03:29,920
and the server can verify that the

94
00:03:29,920 --> 00:03:32,239
client's cls finished message is in

95
00:03:32,239 --> 00:03:35,360
response to the same tls connection

96
00:03:35,360 --> 00:03:37,680
just like how the tcp synap message was

97
00:03:37,680 --> 00:03:40,080
sent to the client's source ip address

98
00:03:40,080 --> 00:03:42,080
in quick the server's tls handshake

99
00:03:42,080 --> 00:03:43,840
messages were sent to the client's ip

100
00:03:43,840 --> 00:03:44,480
address

101
00:03:44,480 --> 00:03:46,319
and getting the tls finished message

102
00:03:46,319 --> 00:03:48,560
proves that the client controls that ip

103
00:03:48,560 --> 00:03:50,959
address

104
00:03:52,560 --> 00:03:55,439
in tcp the server's synack message is

105
00:03:55,439 --> 00:03:57,120
sent without knowing if the sender of

106
00:03:57,120 --> 00:03:59,120
the sim controls the source ip address

107
00:03:59,120 --> 00:04:00,879
from the syn packet

108
00:04:00,879 --> 00:04:02,480
if the client spoofs the source ip

109
00:04:02,480 --> 00:04:04,720
address of its in packet it can get the

110
00:04:04,720 --> 00:04:05,360
server

111
00:04:05,360 --> 00:04:09,439
to send a syn ack to another endpoint

112
00:04:09,439 --> 00:04:10,959
before the client's ip address is

113
00:04:10,959 --> 00:04:13,040
validated a hypothetical protocol

114
00:04:13,040 --> 00:04:14,560
running on top of ip

115
00:04:14,560 --> 00:04:16,320
might allow a client to send a small

116
00:04:16,320 --> 00:04:18,639
packet with a spoofed source ip address

117
00:04:18,639 --> 00:04:19,440
to a server

118
00:04:19,440 --> 00:04:21,440
that would result in a large packet

119
00:04:21,440 --> 00:04:23,440
being sent by the server

120
00:04:23,440 --> 00:04:25,520
to the victim in an attempt to dos the

121
00:04:25,520 --> 00:04:26,720
victim

122
00:04:26,720 --> 00:04:28,560
this attack is only useful if the

123
00:04:28,560 --> 00:04:30,240
server's packet is noticeably larger

124
00:04:30,240 --> 00:04:31,680
than the client's packet

125
00:04:31,680 --> 00:04:33,280
since otherwise the client could send

126
00:04:33,280 --> 00:04:35,600
traffic directly to the victim

127
00:04:35,600 --> 00:04:38,160
in tcp this attack isn't a concern

128
00:04:38,160 --> 00:04:40,160
because the syn and synack packets

129
00:04:40,160 --> 00:04:44,320
are both small and roughly the same size

130
00:04:44,320 --> 00:04:46,560
in quick both the client's initial

131
00:04:46,560 --> 00:04:48,479
packet and the server's first flight of

132
00:04:48,479 --> 00:04:50,720
packets are much larger than a tcp syn

133
00:04:50,720 --> 00:04:51,600
or synap

134
00:04:51,600 --> 00:04:54,479
packet to avoid this amplification

135
00:04:54,479 --> 00:04:55,040
attack

136
00:04:55,040 --> 00:04:57,360
quick imposes a limit on how much data

137
00:04:57,360 --> 00:04:58,560
the server can send

138
00:04:58,560 --> 00:05:00,639
before the client's address has been

139
00:05:00,639 --> 00:05:02,639
validated

140
00:05:02,639 --> 00:05:04,880
the server is limited to sending three

141
00:05:04,880 --> 00:05:06,160
times the amount of data

142
00:05:06,160 --> 00:05:08,639
that was in the client's packet the

143
00:05:08,639 --> 00:05:09,360
client can

144
00:05:09,360 --> 00:05:11,840
expand its initial packet by adding

145
00:05:11,840 --> 00:05:12,400
padding

146
00:05:12,400 --> 00:05:14,080
to allow the server to have a larger

147
00:05:14,080 --> 00:05:16,080
response

148
00:05:16,080 --> 00:05:18,320
however if the server needs to send more

149
00:05:18,320 --> 00:05:20,000
data in the handshake than fits under

150
00:05:20,000 --> 00:05:21,759
the amplification attack limit

151
00:05:21,759 --> 00:05:24,320
the server can explicitly request

152
00:05:24,320 --> 00:05:25,680
address validation

153
00:05:25,680 --> 00:05:29,199
at the cost of one round trip

154
00:05:29,199 --> 00:05:31,600
the server does this by sending a retry

155
00:05:31,600 --> 00:05:32,240
packet

156
00:05:32,240 --> 00:05:33,680
which contains only an address

157
00:05:33,680 --> 00:05:35,840
validation token

158
00:05:35,840 --> 00:05:38,000
the client puts this token in the header

159
00:05:38,000 --> 00:05:40,000
of its next initial packet

160
00:05:40,000 --> 00:05:43,039
and echoing it back to the server proves

161
00:05:43,039 --> 00:05:44,800
the client controls its source ip

162
00:05:44,800 --> 00:05:46,560
address

163
00:05:46,560 --> 00:05:48,639
at this point since the address has been

164
00:05:48,639 --> 00:05:50,479
validated there are no limits to the

165
00:05:50,479 --> 00:05:52,240
size of the server's tls handshake

166
00:05:52,240 --> 00:05:54,720
messages

167
00:05:56,000 --> 00:05:57,919
this retry token can also be used to

168
00:05:57,919 --> 00:05:59,280
mitigate kwik's equivalent

169
00:05:59,280 --> 00:06:03,280
of a tcp syn flood upon receipt of a tls

170
00:06:03,280 --> 00:06:04,080
client hello

171
00:06:04,080 --> 00:06:05,919
the server has to maintain state for the

172
00:06:05,919 --> 00:06:07,199
quick connection

173
00:06:07,199 --> 00:06:09,280
if an attacker floods the server with

174
00:06:09,280 --> 00:06:10,560
client initial packets

175
00:06:10,560 --> 00:06:12,720
the server has to store state for each

176
00:06:12,720 --> 00:06:14,880
of these connections

177
00:06:14,880 --> 00:06:17,600
at the cost of one round trip the server

178
00:06:17,600 --> 00:06:20,080
can defer the cost of creating this

179
00:06:20,080 --> 00:06:22,560
state until after address validation

180
00:06:22,560 --> 00:06:24,319
it does this by sending a retry packet

181
00:06:24,319 --> 00:06:26,960
to the client

182
00:06:27,440 --> 00:06:29,759
deferring the cost of creating state is

183
00:06:29,759 --> 00:06:32,000
done by encrypting all of the state

184
00:06:32,000 --> 00:06:34,160
the client's connection id its source ip

185
00:06:34,160 --> 00:06:35,280
address and port

186
00:06:35,280 --> 00:06:36,720
and any other state the server might

187
00:06:36,720 --> 00:06:38,400
need in the retry token

188
00:06:38,400 --> 00:06:40,000
that way no state apart from the

189
00:06:40,000 --> 00:06:41,680
encryption key for the retry token

190
00:06:41,680 --> 00:06:48,720
is needed on the server

191
00:06:48,720 --> 00:06:51,680
in the tcp handshake sorry in the

192
00:06:51,680 --> 00:06:52,880
transport handshake

193
00:06:52,880 --> 00:06:55,680
in addition to confirming that the

194
00:06:55,680 --> 00:06:58,800
client controls its source ip address

195
00:06:58,800 --> 00:07:01,440
additional transport connection

196
00:07:01,440 --> 00:07:02,400
properties

197
00:07:02,400 --> 00:07:05,759
are established this includes

198
00:07:05,759 --> 00:07:09,759
flow control limits and other properties

199
00:07:09,759 --> 00:07:12,800
in tcp these are advertised in the tcp

200
00:07:12,800 --> 00:07:13,759
header

201
00:07:13,759 --> 00:07:15,280
in quick these limits and other

202
00:07:15,280 --> 00:07:17,360
connection properties are advertised

203
00:07:17,360 --> 00:07:19,039
in the transport parameters tls

204
00:07:19,039 --> 00:07:21,360
extension

205
00:07:21,360 --> 00:07:23,919
unlike tcp where a network intermediary

206
00:07:23,919 --> 00:07:25,919
can alter the tcp header

207
00:07:25,919 --> 00:07:27,440
the transport parameters are

208
00:07:27,440 --> 00:07:29,680
authenticated by the tls handshake

209
00:07:29,680 --> 00:07:31,360
and encrypted in the server-to-client

210
00:07:31,360 --> 00:07:33,280
direction

211
00:07:33,280 --> 00:07:35,199
in either direction an attacker cannot

212
00:07:35,199 --> 00:07:36,800
tamper with the contents of the

213
00:07:36,800 --> 00:07:37,919
transport parameters

214
00:07:37,919 --> 00:07:39,919
without causing the tls handshake and

215
00:07:39,919 --> 00:07:41,520
thus the quick connection

216
00:07:41,520 --> 00:07:45,840
to fail

217
00:07:46,160 --> 00:07:48,560
now let's look in a little more detail

218
00:07:48,560 --> 00:07:50,080
how these packets appear

219
00:07:50,080 --> 00:07:53,440
on the wire quick packets

220
00:07:53,440 --> 00:07:55,440
regardless of what version of quick have

221
00:07:55,440 --> 00:07:58,080
either a long header or a short header

222
00:07:58,080 --> 00:08:00,080
long header packets are used during

223
00:08:00,080 --> 00:08:01,599
connection establishment

224
00:08:01,599 --> 00:08:03,199
and the short header packets are used

225
00:08:03,199 --> 00:08:06,000
once the handshake is complete

226
00:08:06,000 --> 00:08:08,160
the first bit in the packet header

227
00:08:08,160 --> 00:08:10,720
indicates whether the header form

228
00:08:10,720 --> 00:08:13,120
which header form is in use a 1

229
00:08:13,120 --> 00:08:14,400
indicates a long header

230
00:08:14,400 --> 00:08:17,440
and a 0 indicates a short header

231
00:08:17,440 --> 00:08:19,440
long headers include the connection ids

232
00:08:19,440 --> 00:08:21,360
of both the sender and the receiver

233
00:08:21,360 --> 00:08:23,199
while short headers only include the

234
00:08:23,199 --> 00:08:26,639
receiver's connection id

235
00:08:26,639 --> 00:08:28,080
for the rest of this talk i will be

236
00:08:28,080 --> 00:08:30,160
focusing on quick version one

237
00:08:30,160 --> 00:08:32,479
the packet formats for those versions

238
00:08:32,479 --> 00:08:34,240
have a little more details than

239
00:08:34,240 --> 00:08:36,399
described on this slide this slide shows

240
00:08:36,399 --> 00:08:37,599
what is in

241
00:08:37,599 --> 00:08:39,679
a quick packet header for any version of

242
00:08:39,679 --> 00:08:41,838
quick

243
00:08:42,479 --> 00:08:44,320
i've mentioned on this slide and in

244
00:08:44,320 --> 00:08:46,800
previous slides quick connection ids

245
00:08:46,800 --> 00:08:48,560
so let's look at how those work in a

246
00:08:48,560 --> 00:08:51,359
little more detail

247
00:08:51,519 --> 00:08:53,680
quick uses connection ids to identify a

248
00:08:53,680 --> 00:08:55,519
connection instead of using the five

249
00:08:55,519 --> 00:08:56,080
tuple

250
00:08:56,080 --> 00:08:59,040
of ip protocol source and destination ip

251
00:08:59,040 --> 00:08:59,760
addresses

252
00:08:59,760 --> 00:09:02,160
and udp sort and destin source and

253
00:09:02,160 --> 00:09:04,480
destination ports

254
00:09:04,480 --> 00:09:06,560
connection ids are variable length

255
00:09:06,560 --> 00:09:08,000
ranging from 0 to 20

256
00:09:08,000 --> 00:09:11,279
bytes each endpoint chooses its own

257
00:09:11,279 --> 00:09:12,240
connection ids

258
00:09:12,240 --> 00:09:14,959
and advertises those to its peer an

259
00:09:14,959 --> 00:09:16,399
endpoint can have multiple connection

260
00:09:16,399 --> 00:09:16,959
ids

261
00:09:16,959 --> 00:09:19,680
for a single connection multiple

262
00:09:19,680 --> 00:09:21,600
connection ids are provided for a single

263
00:09:21,600 --> 00:09:22,320
connection

264
00:09:22,320 --> 00:09:24,320
so that each network path used for a

265
00:09:24,320 --> 00:09:25,920
connection can use a different

266
00:09:25,920 --> 00:09:37,839
connection id

267
00:09:38,959 --> 00:09:41,040
an endpoint needs to be able to route a

268
00:09:41,040 --> 00:09:42,959
packet based on its connection id

269
00:09:42,959 --> 00:09:45,680
to the correct quick connection and the

270
00:09:45,680 --> 00:09:47,600
connection id should appear random to an

271
00:09:47,600 --> 00:09:50,240
external observer

272
00:09:50,240 --> 00:09:52,240
load balancers can use connection ids to

273
00:09:52,240 --> 00:09:54,240
route packets to specific servers

274
00:09:54,240 --> 00:09:55,920
assuming that there is cooperation and

275
00:09:55,920 --> 00:09:58,000
coordination between the server fleet

276
00:09:58,000 --> 00:09:59,519
and the load balancer sitting in front

277
00:09:59,519 --> 00:10:01,440
of that fleet

278
00:10:01,440 --> 00:10:04,160
cooperation is required because servers

279
00:10:04,160 --> 00:10:05,440
issue connection ids

280
00:10:05,440 --> 00:10:06,959
and load balancers need to process

281
00:10:06,959 --> 00:10:08,880
enough of that connection id to route it

282
00:10:08,880 --> 00:10:10,720
back to the server

283
00:10:10,720 --> 00:10:12,480
there is a draft in progress that

284
00:10:12,480 --> 00:10:14,079
describes multiple ways that load

285
00:10:14,079 --> 00:10:16,560
balancers and servers can cooperate

286
00:10:16,560 --> 00:10:18,959
the suggested way at a high level is

287
00:10:18,959 --> 00:10:20,000
that the

288
00:10:20,000 --> 00:10:21,920
servers and the load balancer share a

289
00:10:21,920 --> 00:10:23,360
key and

290
00:10:23,360 --> 00:10:25,839
encrypt a connection id the plain text

291
00:10:25,839 --> 00:10:27,279
of that would contain

292
00:10:27,279 --> 00:10:30,640
a server id and a section for

293
00:10:30,640 --> 00:10:32,240
to identify that connection on the

294
00:10:32,240 --> 00:10:34,399
server and then the encrypted connection

295
00:10:34,399 --> 00:10:34,800
id

296
00:10:34,800 --> 00:10:37,680
is put on the wire

297
00:10:38,240 --> 00:10:40,399
if connection ids do not appear random

298
00:10:40,399 --> 00:10:41,920
to an external observer

299
00:10:41,920 --> 00:10:44,399
there are two possible attacks the first

300
00:10:44,399 --> 00:10:46,720
attack is the privacy leakage

301
00:10:46,720 --> 00:10:49,120
if an observer can tell whether two

302
00:10:49,120 --> 00:10:50,800
connection ids belong to the same

303
00:10:50,800 --> 00:10:51,760
connection

304
00:10:51,760 --> 00:10:53,519
it can look at traffic flows on

305
00:10:53,519 --> 00:10:54,800
different five tuples

306
00:10:54,800 --> 00:10:58,000
and correlate connections uh as being

307
00:10:58,000 --> 00:11:00,399
the same connection

308
00:11:00,399 --> 00:11:01,839
the second attack involves load

309
00:11:01,839 --> 00:11:03,519
balancers

310
00:11:03,519 --> 00:11:05,200
if an attacker can generate many

311
00:11:05,200 --> 00:11:07,360
connection ids that the load balancer

312
00:11:07,360 --> 00:11:08,000
will map

313
00:11:08,000 --> 00:11:10,480
to the same server the attacker can

314
00:11:10,480 --> 00:11:12,079
bypass the load balancer

315
00:11:12,079 --> 00:11:14,079
to mount a denial of service attack on

316
00:11:14,079 --> 00:11:15,360
the specific server

317
00:11:15,360 --> 00:11:18,560
behind the load balancer

318
00:11:21,360 --> 00:11:22,959
now that we've looked at the transport

319
00:11:22,959 --> 00:11:24,800
handshake and connection ids

320
00:11:24,800 --> 00:11:26,800
let's look at how the crypto transport

321
00:11:26,800 --> 00:11:28,399
let's look at how the crypto handshake

322
00:11:28,399 --> 00:11:31,279
works in quick

323
00:11:34,560 --> 00:11:37,839
so to start off the crypto handshake in

324
00:11:37,839 --> 00:11:38,560
quick

325
00:11:38,560 --> 00:11:43,839
is the tls 1.3 handshake

326
00:11:44,560 --> 00:11:47,519
when run over tcp tls provides a record

327
00:11:47,519 --> 00:11:48,880
layer which handles multiplexing

328
00:11:48,880 --> 00:11:50,639
handshake and application data on the

329
00:11:50,639 --> 00:11:51,680
same connection

330
00:11:51,680 --> 00:11:53,519
this record layer also handles

331
00:11:53,519 --> 00:11:55,200
encrypting the data sent on the

332
00:11:55,200 --> 00:11:56,880
connection

333
00:11:56,880 --> 00:11:58,959
tls assumes that it is run on an inorder

334
00:11:58,959 --> 00:12:00,720
reliable byte stream

335
00:12:00,720 --> 00:12:03,519
in quick the tls record layer isn't used

336
00:12:03,519 --> 00:12:04,079
instead

337
00:12:04,079 --> 00:12:06,079
quick has its own record layer to handle

338
00:12:06,079 --> 00:12:08,800
encrypting packets

339
00:12:08,800 --> 00:12:10,639
the tls handshake still depends on its

340
00:12:10,639 --> 00:12:12,480
handshake messages being delivered in

341
00:12:12,480 --> 00:12:15,600
order and reliably

342
00:12:15,920 --> 00:12:19,200
the use of tls 1.3 in quick

343
00:12:19,200 --> 00:12:21,920
its handshake relies on quick transport

344
00:12:21,920 --> 00:12:22,639
features

345
00:12:22,639 --> 00:12:24,880
handling reordering and re-transmission

346
00:12:24,880 --> 00:12:26,480
of packets containing the crypto

347
00:12:26,480 --> 00:12:28,160
handshake

348
00:12:28,160 --> 00:12:30,800
so on this slide we see that the tls

349
00:12:30,800 --> 00:12:32,720
handshake messages are in

350
00:12:32,720 --> 00:12:35,360
quick crypto frames and if a packet gets

351
00:12:35,360 --> 00:12:36,079
lost

352
00:12:36,079 --> 00:12:38,160
quick will retransmit that crypto frame

353
00:12:38,160 --> 00:12:40,560
in a future packet

354
00:12:40,560 --> 00:12:42,560
the crypto handshake in addition to

355
00:12:42,560 --> 00:12:44,480
establishing crypto parameters for the

356
00:12:44,480 --> 00:12:45,279
connection

357
00:12:45,279 --> 00:12:48,399
and keys to use uh also carries the

358
00:12:48,399 --> 00:12:49,760
transport parameters

359
00:12:49,760 --> 00:12:51,200
for the connection as i mentioned

360
00:12:51,200 --> 00:12:53,600
earlier

361
00:12:53,600 --> 00:12:56,959
the crypto handshake also contains the

362
00:12:56,959 --> 00:12:59,600
alpn for the connection the application

363
00:12:59,600 --> 00:13:01,440
layer protocol negotiation tag

364
00:13:01,440 --> 00:13:07,839
so this would be for example http 3.

365
00:13:10,000 --> 00:13:12,720
so tls provides keys too quick to use

366
00:13:12,720 --> 00:13:14,160
for record layer encryption

367
00:13:14,160 --> 00:13:16,000
but quick handles that record layer

368
00:13:16,000 --> 00:13:18,000
encryption itself

369
00:13:18,000 --> 00:13:19,680
the encryption key is used for a quick

370
00:13:19,680 --> 00:13:21,440
packet are determined by the type of

371
00:13:21,440 --> 00:13:22,480
packet

372
00:13:22,480 --> 00:13:24,720
handshake packets in quick use handshake

373
00:13:24,720 --> 00:13:26,160
keys from tls

374
00:13:26,160 --> 00:13:29,279
zero rtt quick packets use zero rtt keys

375
00:13:29,279 --> 00:13:30,399
from tls

376
00:13:30,399 --> 00:13:32,720
and short header packets in quick use

377
00:13:32,720 --> 00:13:35,360
application data keys from tls

378
00:13:35,360 --> 00:13:37,519
the application data keys used to

379
00:13:37,519 --> 00:13:39,120
protect short header packets

380
00:13:39,120 --> 00:13:42,480
provide forward secrecy

381
00:13:43,600 --> 00:13:46,639
the tls 1.3 key schedule drives traffic

382
00:13:46,639 --> 00:13:48,800
secrets for each encryption level

383
00:13:48,800 --> 00:13:51,600
which maps to a quick packet type a

384
00:13:51,600 --> 00:13:53,120
single traffic secret

385
00:13:53,120 --> 00:13:54,959
at each encryption level is used to

386
00:13:54,959 --> 00:13:56,720
derive multiple secrets

387
00:13:56,720 --> 00:13:58,880
including encryption keys and ivs for

388
00:13:58,880 --> 00:14:00,880
both sending and receiving

389
00:14:00,880 --> 00:14:03,839
by each endpoint

390
00:14:05,680 --> 00:14:07,920
let's look in a little more detail how

391
00:14:07,920 --> 00:14:08,880
quick

392
00:14:08,880 --> 00:14:10,560
record protection or record layer

393
00:14:10,560 --> 00:14:17,839
encryption works for quick v1

394
00:14:22,720 --> 00:14:26,000
in quick every packet is encrypted

395
00:14:26,000 --> 00:14:30,079
using an aed mode of encryption and

396
00:14:30,079 --> 00:14:31,440
every packet in quick

397
00:14:31,440 --> 00:14:33,519
has a packet header which contains a

398
00:14:33,519 --> 00:14:35,839
packet number and a payload

399
00:14:35,839 --> 00:14:38,320
let's look at how these elements of a

400
00:14:38,320 --> 00:14:39,120
quick packet

401
00:14:39,120 --> 00:14:42,839
map to the inputs of the aad encryption

402
00:14:42,839 --> 00:14:44,079
function

403
00:14:44,079 --> 00:14:47,279
the aead encryption function takes four

404
00:14:47,279 --> 00:14:48,560
inputs

405
00:14:48,560 --> 00:14:53,120
k the key n a nonce

406
00:14:53,120 --> 00:14:57,199
p the plain text and a associated data

407
00:14:57,199 --> 00:15:01,279
and outputs a ciphertext c

408
00:15:01,600 --> 00:15:03,120
when encrypting a packet at some

409
00:15:03,120 --> 00:15:05,760
encryption level we have a key and an iv

410
00:15:05,760 --> 00:15:07,360
that are derived for that encryption

411
00:15:07,360 --> 00:15:08,959
level

412
00:15:08,959 --> 00:15:12,720
we use that key as the key k for the aad

413
00:15:12,720 --> 00:15:13,839
operation

414
00:15:13,839 --> 00:15:17,040
the nonce is derived from the iv and the

415
00:15:17,040 --> 00:15:18,639
packet number for the packet being

416
00:15:18,639 --> 00:15:20,160
encrypted

417
00:15:20,160 --> 00:15:22,160
the plain text is the payload of the

418
00:15:22,160 --> 00:15:24,399
packet and the associated data is the

419
00:15:24,399 --> 00:15:26,320
packet header

420
00:15:26,320 --> 00:15:29,600
the ciphertext output c is then

421
00:15:29,600 --> 00:15:31,680
transmitted on the wire in place of the

422
00:15:31,680 --> 00:15:34,320
plaintext p

423
00:15:34,320 --> 00:15:36,240
this provides confidentiality and

424
00:15:36,240 --> 00:15:38,720
integrity for the packet payload

425
00:15:38,720 --> 00:15:40,480
it also provides integrity for the

426
00:15:40,480 --> 00:15:42,320
entire packet since the

427
00:15:42,320 --> 00:15:46,160
header is used as the associated data

428
00:15:46,160 --> 00:15:48,079
because of this integrity guarantee

429
00:15:48,079 --> 00:15:49,680
quick packets cannot have their headers

430
00:15:49,680 --> 00:15:51,519
modified by network intermediaries

431
00:15:51,519 --> 00:15:53,680
unlike tcp packets where headers are

432
00:15:53,680 --> 00:15:55,360
often processed and modified by

433
00:15:55,360 --> 00:15:58,240
intermediaries

434
00:15:58,240 --> 00:16:00,480
in the example on this slide we see the

435
00:16:00,480 --> 00:16:02,880
start of a packet on the first line

436
00:16:02,880 --> 00:16:06,079
the first byte colored in red is

437
00:16:06,079 --> 00:16:08,079
identifies whether the packet is a long

438
00:16:08,079 --> 00:16:09,839
or short header and a few of the bits in

439
00:16:09,839 --> 00:16:10,160
there

440
00:16:10,160 --> 00:16:13,040
are used for additional purposes next

441
00:16:13,040 --> 00:16:13,920
this packet

442
00:16:13,920 --> 00:16:16,160
header has a connection id highlighted

443
00:16:16,160 --> 00:16:17,839
in yellow the length of the connection

444
00:16:17,839 --> 00:16:18,560
id

445
00:16:18,560 --> 00:16:23,040
is known by the receiver ahead of time

446
00:16:23,040 --> 00:16:24,959
finally the packet header contains a

447
00:16:24,959 --> 00:16:27,040
packet number in this case the packet

448
00:16:27,040 --> 00:16:27,759
number

449
00:16:27,759 --> 00:16:30,720
is one byte long some of the lower bits

450
00:16:30,720 --> 00:16:31,279
in

451
00:16:31,279 --> 00:16:33,759
the first byte of the packet header

452
00:16:33,759 --> 00:16:34,320
indicate

453
00:16:34,320 --> 00:16:37,360
the length of the packet number and then

454
00:16:37,360 --> 00:16:38,959
finally we have the plain text for the

455
00:16:38,959 --> 00:16:41,359
packet

456
00:16:41,519 --> 00:16:44,959
the second line shows how the plain text

457
00:16:44,959 --> 00:16:47,120
of the packet payload is replaced by the

458
00:16:47,120 --> 00:16:49,199
ciphertext that was output from the aad

459
00:16:49,199 --> 00:16:51,839
function

460
00:16:52,240 --> 00:16:54,800
after this encryption has been done

461
00:16:54,800 --> 00:16:56,160
there is an additional step

462
00:16:56,160 --> 00:16:59,199
done to encrypt the packet number in the

463
00:16:59,199 --> 00:16:59,839
header

464
00:16:59,839 --> 00:17:03,600
and some of the bits in the first byte

465
00:17:03,600 --> 00:17:06,799
of the packet header

466
00:17:06,959 --> 00:17:09,039
during the key derivations step where we

467
00:17:09,039 --> 00:17:10,880
got the key and iv to use

468
00:17:10,880 --> 00:17:12,720
there is a third secret that was derived

469
00:17:12,720 --> 00:17:16,160
which is the header protection key

470
00:17:16,160 --> 00:17:18,319
this header protection key is used to

471
00:17:18,319 --> 00:17:20,640
perform a single encryption operation

472
00:17:20,640 --> 00:17:23,359
it takes as input 16 bytes that are

473
00:17:23,359 --> 00:17:23,919
sampled

474
00:17:23,919 --> 00:17:25,760
from the encrypted ciphertext of the

475
00:17:25,760 --> 00:17:28,319
packet and outputs a mask

476
00:17:28,319 --> 00:17:29,919
this mask is shown on the third line of

477
00:17:29,919 --> 00:17:31,679
this example

478
00:17:31,679 --> 00:17:34,160
and the mask is xored with certain bits

479
00:17:34,160 --> 00:17:35,200
of the packet header

480
00:17:35,200 --> 00:17:38,000
to result in the encrypted packet header

481
00:17:38,000 --> 00:17:40,400
we can see in this example

482
00:17:40,400 --> 00:17:43,280
that the last five bits of the first

483
00:17:43,280 --> 00:17:43,840
byte

484
00:17:43,840 --> 00:17:47,760
are of the mask are xored with the

485
00:17:47,760 --> 00:17:49,600
first byte of the packet header this

486
00:17:49,600 --> 00:17:50,960
obscures the length

487
00:17:50,960 --> 00:17:55,600
of the packet number in the header

488
00:17:55,600 --> 00:17:59,200
and then the rest of the mask is used to

489
00:17:59,200 --> 00:18:01,679
x4 with the packet number to encrypt the

490
00:18:01,679 --> 00:18:04,320
packet number

491
00:18:04,559 --> 00:18:07,919
the final line on this slide shows what

492
00:18:07,919 --> 00:18:10,080
the packet that actually gets sent on

493
00:18:10,080 --> 00:18:11,440
the wire looks like

494
00:18:11,440 --> 00:18:13,520
after the encryption and header

495
00:18:13,520 --> 00:18:16,639
protection are applied

496
00:18:18,160 --> 00:18:20,080
to decrypt a quick packet these

497
00:18:20,080 --> 00:18:22,799
operations are applied in reverse

498
00:18:22,799 --> 00:18:25,520
first the header protection mask is

499
00:18:25,520 --> 00:18:26,559
computed

500
00:18:26,559 --> 00:18:29,760
and then xord with the same

501
00:18:29,760 --> 00:18:33,120
bit pattern to decrypt the header then

502
00:18:33,120 --> 00:18:36,480
once the packet number is decrypted well

503
00:18:36,480 --> 00:18:40,160
the receiver can know the knots to use

504
00:18:40,160 --> 00:18:44,080
and can run the aead open function

505
00:18:44,080 --> 00:18:48,080
to get the plain text or the aad decrypt

506
00:18:48,080 --> 00:18:51,120
operation could fail

507
00:18:51,679 --> 00:18:53,280
if an endpoint receives a packet that

508
00:18:53,280 --> 00:18:56,240
fails to decrypt the packet is discarded

509
00:18:56,240 --> 00:18:57,760
this prevents an attacker from being

510
00:18:57,760 --> 00:18:59,600
able to inject packets into a quick

511
00:18:59,600 --> 00:19:02,080
connection

512
00:19:03,039 --> 00:19:05,120
when short header packets are used the

513
00:19:05,120 --> 00:19:06,799
only parts of the packet header that are

514
00:19:06,799 --> 00:19:07,760
in the clear

515
00:19:07,760 --> 00:19:10,320
are the three bits at the beginning of

516
00:19:10,320 --> 00:19:12,000
the packet

517
00:19:12,000 --> 00:19:14,480
and the connection id everything else is

518
00:19:14,480 --> 00:19:15,600
encrypted

519
00:19:15,600 --> 00:19:18,240
this example has a short packet header

520
00:19:18,240 --> 00:19:19,520
so the three bits

521
00:19:19,520 --> 00:19:21,760
in the first byte of the packet header

522
00:19:21,760 --> 00:19:22,720
are in the clear

523
00:19:22,720 --> 00:19:24,720
the connection id is in the clear but

524
00:19:24,720 --> 00:19:26,320
everything else in the packet

525
00:19:26,320 --> 00:19:29,120
is encrypted

526
00:19:31,679 --> 00:19:34,480
when using quix record layer encryption

527
00:19:34,480 --> 00:19:36,080
there are a few considerations regarding

528
00:19:36,080 --> 00:19:38,480
multiple encryption levels

529
00:19:38,480 --> 00:19:40,799
the first is that initial packets are

530
00:19:40,799 --> 00:19:42,880
protected with obfuscation keys

531
00:19:42,880 --> 00:19:45,840
these are derived from the connection id

532
00:19:45,840 --> 00:19:47,200
and

533
00:19:47,200 --> 00:19:49,280
the quick version which means that

534
00:19:49,280 --> 00:19:50,880
anyone can derive

535
00:19:50,880 --> 00:19:54,799
these keys once initial encryption keys

536
00:19:54,799 --> 00:19:55,520
aren't needed

537
00:19:55,520 --> 00:19:57,520
these keys should be discarded to

538
00:19:57,520 --> 00:19:59,120
prevent an attacker from injecting

539
00:19:59,120 --> 00:19:59,760
packets

540
00:19:59,760 --> 00:20:02,080
at the encryption initial at the initial

541
00:20:02,080 --> 00:20:04,799
encryption level

542
00:20:05,679 --> 00:20:08,159
also each type of frame in quick can

543
00:20:08,159 --> 00:20:09,840
only be sent and received at certain

544
00:20:09,840 --> 00:20:11,600
encryption levels

545
00:20:11,600 --> 00:20:14,000
for example most frames that are sent in

546
00:20:14,000 --> 00:20:15,840
zero rtt packets can't be sent

547
00:20:15,840 --> 00:20:18,240
in handshake packets in particular if a

548
00:20:18,240 --> 00:20:20,720
client mistakenly sends a stream frame

549
00:20:20,720 --> 00:20:22,480
and a handshake packet there could be a

550
00:20:22,480 --> 00:20:24,240
loss of confidentiality

551
00:20:24,240 --> 00:20:25,440
if the client is not able to

552
00:20:25,440 --> 00:20:28,400
authenticate the server

553
00:20:28,480 --> 00:20:30,240
so endpoints should make sure that they

554
00:20:30,240 --> 00:20:32,159
only send frames at the correct

555
00:20:32,159 --> 00:20:34,480
encryption levels

556
00:20:34,480 --> 00:20:36,159
in addition to ensuring that frames are

557
00:20:36,159 --> 00:20:38,080
written at the correct encryption levels

558
00:20:38,080 --> 00:20:39,679
implementations should also check that

559
00:20:39,679 --> 00:20:41,760
incoming frames it reads were sent at

560
00:20:41,760 --> 00:20:43,600
the correct encryption levels

561
00:20:43,600 --> 00:20:46,159
for example a server should not accept

562
00:20:46,159 --> 00:20:48,159
an initial packet that contains a stream

563
00:20:48,159 --> 00:20:50,480
frame

564
00:20:53,840 --> 00:20:55,760
now that we understand how the transport

565
00:20:55,760 --> 00:20:57,120
and crypto handshakes

566
00:20:57,120 --> 00:20:59,120
work in quick and how quick encrypts

567
00:20:59,120 --> 00:21:01,200
data let's take a look at some of the

568
00:21:01,200 --> 00:21:02,000
other details

569
00:21:02,000 --> 00:21:17,840
of the quick transport

570
00:21:19,039 --> 00:21:21,200
the payload of a quick packet is made up

571
00:21:21,200 --> 00:21:22,960
of a series of frames

572
00:21:22,960 --> 00:21:24,880
a quick frame starts with an indicator

573
00:21:24,880 --> 00:21:26,480
of what type of frame it is

574
00:21:26,480 --> 00:21:28,240
but otherwise frames are not

575
00:21:28,240 --> 00:21:29,520
self-describing

576
00:21:29,520 --> 00:21:31,520
we've already seen examples of two types

577
00:21:31,520 --> 00:21:33,360
of frames on previous slides

578
00:21:33,360 --> 00:21:36,159
crypto frames and ack frames and i've

579
00:21:36,159 --> 00:21:37,039
also mentioned

580
00:21:37,039 --> 00:21:39,760
stream frames

581
00:21:41,440 --> 00:21:44,080
so application data in quick is carried

582
00:21:44,080 --> 00:21:45,440
in stream frames

583
00:21:45,440 --> 00:21:47,919
a stream is lightweight abstraction for

584
00:21:47,919 --> 00:21:50,159
a reliable in-order byte stream

585
00:21:50,159 --> 00:21:52,480
and it is identified by a stream id

586
00:21:52,480 --> 00:21:54,240
which is a 62-bit integer

587
00:21:54,240 --> 00:21:56,320
that is unique across all streams on

588
00:21:56,320 --> 00:21:59,840
that particular connection

589
00:22:00,400 --> 00:22:02,080
one of the responsibilities of a

590
00:22:02,080 --> 00:22:03,760
transport protocol like quick

591
00:22:03,760 --> 00:22:06,880
is managing flow control kwik has an

592
00:22:06,880 --> 00:22:08,559
overall flow control limit for a

593
00:22:08,559 --> 00:22:09,440
connection

594
00:22:09,440 --> 00:22:12,000
it also has flow control per stream and

595
00:22:12,000 --> 00:22:13,760
flow control for the number of streams

596
00:22:13,760 --> 00:22:15,600
that can be open at a time

597
00:22:15,600 --> 00:22:17,360
these limits are initially set in

598
00:22:17,360 --> 00:22:19,039
transport parameters

599
00:22:19,039 --> 00:22:20,640
during the connection they are updated

600
00:22:20,640 --> 00:22:23,120
via max data max stream data

601
00:22:23,120 --> 00:22:26,960
and max streams frames unlike tcp

602
00:22:26,960 --> 00:22:28,559
where flow control is in the clear in

603
00:22:28,559 --> 00:22:30,000
the tcp header

604
00:22:30,000 --> 00:22:31,679
these frames are all part of the packet

605
00:22:31,679 --> 00:22:33,679
payload and thus they are encrypted

606
00:22:33,679 --> 00:22:37,120
and not visible on the network

607
00:22:38,400 --> 00:22:40,240
receipt of quick packets is acknowledged

608
00:22:40,240 --> 00:22:41,440
in ack frames

609
00:22:41,440 --> 00:22:43,280
which again is information protected in

610
00:22:43,280 --> 00:22:45,120
the packet payload instead of in clear

611
00:22:45,120 --> 00:22:48,320
text like in tcp

612
00:22:48,559 --> 00:22:50,720
when data is lost and re-transmitted in

613
00:22:50,720 --> 00:22:52,640
quick it is re-transmitted in new

614
00:22:52,640 --> 00:22:53,600
packets

615
00:22:53,600 --> 00:22:56,240
unlike tcp packet numbers or sequence

616
00:22:56,240 --> 00:22:56,720
numbers

617
00:22:56,720 --> 00:22:59,760
are not reused

618
00:23:00,000 --> 00:23:01,840
when a quick connection starts using a

619
00:23:01,840 --> 00:23:03,919
new network path the new network path

620
00:23:03,919 --> 00:23:06,080
must be validated before use

621
00:23:06,080 --> 00:23:08,480
an endpoint does this by sending a path

622
00:23:08,480 --> 00:23:09,440
challenge frame

623
00:23:09,440 --> 00:23:11,200
and then waiting for a path response

624
00:23:11,200 --> 00:23:13,440
frame

625
00:23:15,520 --> 00:23:17,360
i'll now talk about some implementation

626
00:23:17,360 --> 00:23:19,760
considerations that could have security

627
00:23:19,760 --> 00:23:21,280
impacts

628
00:23:21,280 --> 00:23:23,600
the first one regards flow control if an

629
00:23:23,600 --> 00:23:24,559
endpoint

630
00:23:24,559 --> 00:23:26,480
advertises flow control limits but never

631
00:23:26,480 --> 00:23:28,080
enforces them from the peer

632
00:23:28,080 --> 00:23:30,000
then the peer could flood the endpoint

633
00:23:30,000 --> 00:23:33,679
with data leading to resource exhaustion

634
00:23:33,679 --> 00:23:36,240
if an endpoint does not do path

635
00:23:36,240 --> 00:23:38,960
validation before using a new path

636
00:23:38,960 --> 00:23:41,039
then its peer could cause that endpoint

637
00:23:41,039 --> 00:23:42,080
to flood a victim

638
00:23:42,080 --> 00:23:44,720
with traffic

639
00:23:45,520 --> 00:23:51,279
for http 2 there is a cve cve 2019-9517

640
00:23:51,279 --> 00:23:53,360
which was a bug in implementations and

641
00:23:53,360 --> 00:23:54,640
deployments

642
00:23:54,640 --> 00:23:56,480
where a malicious endpoint could

643
00:23:56,480 --> 00:23:58,720
advertise a large flow control window at

644
00:23:58,720 --> 00:24:00,480
the http 2 layer

645
00:24:00,480 --> 00:24:02,400
but at the tcp layer it would close the

646
00:24:02,400 --> 00:24:03,679
flow control window

647
00:24:03,679 --> 00:24:06,000
this would result in the victim thinking

648
00:24:06,000 --> 00:24:07,919
at the http 2 layer they can send a

649
00:24:07,919 --> 00:24:09,039
large amount of data

650
00:24:09,039 --> 00:24:12,000
but at the tcp layer it can't and then a

651
00:24:12,000 --> 00:24:13,520
large amount of data would be buffered

652
00:24:13,520 --> 00:24:18,080
in the http 2 layer in http 3

653
00:24:18,080 --> 00:24:19,840
both the per stream and per connection

654
00:24:19,840 --> 00:24:21,360
flow control happens

655
00:24:21,360 --> 00:24:24,000
in the same context in the quick layer

656
00:24:24,000 --> 00:24:24,559
so

657
00:24:24,559 --> 00:24:27,520
a quick implementation can simply apply

658
00:24:27,520 --> 00:24:28,240
the minimum

659
00:24:28,240 --> 00:24:30,159
of the two flow control limits for the

660
00:24:30,159 --> 00:24:31,679
per connection flow control limit and

661
00:24:31,679 --> 00:24:32,000
the per

662
00:24:32,000 --> 00:24:34,240
stream flow control limit and thus avoid

663
00:24:34,240 --> 00:24:35,600
the extra data buffering

664
00:24:35,600 --> 00:24:37,120
where it thinks it can send more data

665
00:24:37,120 --> 00:24:40,080
than it actually can

666
00:24:41,840 --> 00:24:43,440
when this cve was reported there were

667
00:24:43,440 --> 00:24:45,840
multiple other cves reported affecting

668
00:24:45,840 --> 00:24:47,120
http 2.

669
00:24:47,120 --> 00:24:49,600
the key takeaway from all of these cves

670
00:24:49,600 --> 00:24:51,120
is that an endpoint's peer

671
00:24:51,120 --> 00:24:53,039
shouldn't be able to cause the endpoint

672
00:24:53,039 --> 00:24:54,799
to use unbounded memory

673
00:24:54,799 --> 00:24:57,039
many of the mitigations for those other

674
00:24:57,039 --> 00:24:58,720
issues apply to quick

675
00:24:58,720 --> 00:25:01,840
as well

676
00:25:04,799 --> 00:25:06,720
so far when examining how a quick

677
00:25:06,720 --> 00:25:08,000
connection gets established

678
00:25:08,000 --> 00:25:10,400
we've looked at fresh connections now

679
00:25:10,400 --> 00:25:12,480
let's look at how quick handles resuming

680
00:25:12,480 --> 00:25:13,760
connections

681
00:25:13,760 --> 00:25:15,520
including one of quick's biggest

682
00:25:15,520 --> 00:25:18,240
features which is how it allows a client

683
00:25:18,240 --> 00:25:20,320
to establish a connection with zero

684
00:25:20,320 --> 00:25:21,600
round trip time

685
00:25:21,600 --> 00:25:24,799
or zero rtt

686
00:25:27,600 --> 00:25:30,000
on a fresh connection a quick server has

687
00:25:30,000 --> 00:25:31,600
the option of waiting an additional

688
00:25:31,600 --> 00:25:32,480
round trip

689
00:25:32,480 --> 00:25:34,400
to validate the client's source ip

690
00:25:34,400 --> 00:25:37,200
address before continuing the handshake

691
00:25:37,200 --> 00:25:38,799
it does this by sending an address

692
00:25:38,799 --> 00:25:42,000
validation token in a retry packet

693
00:25:42,000 --> 00:25:43,520
a server can also send an address

694
00:25:43,520 --> 00:25:45,440
validation token to a client

695
00:25:45,440 --> 00:25:47,919
in a new token frame this token can be

696
00:25:47,919 --> 00:25:49,039
used by the client

697
00:25:49,039 --> 00:25:51,200
on a future connection to prove that it

698
00:25:51,200 --> 00:25:54,159
controls its source ip address

699
00:25:54,159 --> 00:25:55,760
you can think of this as being very

700
00:25:55,760 --> 00:25:58,480
similar to a tcp fast open cookie

701
00:25:58,480 --> 00:26:01,440
which allows zero rtt a tcp connection

702
00:26:01,440 --> 00:26:04,159
establishment

703
00:26:05,120 --> 00:26:06,559
when a server generates address

704
00:26:06,559 --> 00:26:08,720
validation tokens whether they are in a

705
00:26:08,720 --> 00:26:09,600
new token frame

706
00:26:09,600 --> 00:26:11,840
or in a retry packet the server must

707
00:26:11,840 --> 00:26:14,159
ensure that an attacker cannot forge

708
00:26:14,159 --> 00:26:15,840
these tokens

709
00:26:15,840 --> 00:26:17,919
if an attacker can forge an address

710
00:26:17,919 --> 00:26:19,120
validation token

711
00:26:19,120 --> 00:26:20,400
the server is vulnerable to

712
00:26:20,400 --> 00:26:24,559
participating in an amplification attack

713
00:26:24,559 --> 00:26:26,480
an endpoint could receive an unbounded

714
00:26:26,480 --> 00:26:28,000
number of new token frames

715
00:26:28,000 --> 00:26:30,240
from its pier it should limit how many

716
00:26:30,240 --> 00:26:31,760
tokens it stores

717
00:26:31,760 --> 00:26:34,400
and if it receives more tokens than it

718
00:26:34,400 --> 00:26:36,400
has room for it should discard old ones

719
00:26:36,400 --> 00:26:38,400
to avoid storing an unbounded number of

720
00:26:38,400 --> 00:26:40,799
tokens

721
00:26:42,960 --> 00:26:44,480
the other aspect of being able to

722
00:26:44,480 --> 00:26:46,000
establish a zero rtt

723
00:26:46,000 --> 00:26:47,840
quick connection involves the tls

724
00:26:47,840 --> 00:26:49,279
handshake

725
00:26:49,279 --> 00:26:52,159
tls 1.3 has a zero rtt resumption

726
00:26:52,159 --> 00:26:52,880
feature which

727
00:26:52,880 --> 00:26:55,520
quick also uses this works by having the

728
00:26:55,520 --> 00:26:57,360
server send a new session ticket

729
00:26:57,360 --> 00:26:59,120
to the client after the tls handshake

730
00:26:59,120 --> 00:27:01,600
completes and the client uses that new

731
00:27:01,600 --> 00:27:02,400
session ticket

732
00:27:02,400 --> 00:27:04,720
to perform zero rtt resumption on a

733
00:27:04,720 --> 00:27:07,200
future connection

734
00:27:07,200 --> 00:27:08,960
effectively the way this works is that

735
00:27:08,960 --> 00:27:10,880
both parties remember a shared secret

736
00:27:10,880 --> 00:27:12,000
from one connection

737
00:27:12,000 --> 00:27:14,320
and use that secret to derive keys that

738
00:27:14,320 --> 00:27:16,799
the client can use to send zero rtt data

739
00:27:16,799 --> 00:27:19,679
on a new connection

740
00:27:19,840 --> 00:27:21,840
let's look at the start of a zero rtt

741
00:27:21,840 --> 00:27:23,440
handshake

742
00:27:23,440 --> 00:27:26,880
this diagram shows what the packet flow

743
00:27:26,880 --> 00:27:29,600
for a zero rtt connection looks like

744
00:27:29,600 --> 00:27:31,919
the client includes a retry token t in

745
00:27:31,919 --> 00:27:33,760
its initial packet for the server to use

746
00:27:33,760 --> 00:27:35,679
for address validation

747
00:27:35,679 --> 00:27:37,279
the client receives this token on a

748
00:27:37,279 --> 00:27:38,799
previous connection and

749
00:27:38,799 --> 00:27:40,640
is assuming that it has the same source

750
00:27:40,640 --> 00:27:43,520
ip address from that previous connection

751
00:27:43,520 --> 00:27:45,600
if the server notices that the client is

752
00:27:45,600 --> 00:27:48,080
on a different source ip address the

753
00:27:48,080 --> 00:27:50,159
server can discard that token and either

754
00:27:50,159 --> 00:27:51,600
perform address validation

755
00:27:51,600 --> 00:27:53,039
or assume that the address is not

756
00:27:53,039 --> 00:27:54,960
validated and handled this

757
00:27:54,960 --> 00:27:57,520
like it would in a 1rtt connection with

758
00:27:57,520 --> 00:28:00,880
amplification attack limits

759
00:28:00,880 --> 00:28:02,880
in this initial packet the client sends

760
00:28:02,880 --> 00:28:04,159
a tls client hello

761
00:28:04,159 --> 00:28:06,640
to resume a tls connection it includes

762
00:28:06,640 --> 00:28:08,640
the early data tls extension

763
00:28:08,640 --> 00:28:12,399
which indicates that the client

764
00:28:12,399 --> 00:28:15,440
will be sending zero rtt data the client

765
00:28:15,440 --> 00:28:16,080
can then send

766
00:28:16,080 --> 00:28:18,559
zero rtt quick packets containing stream

767
00:28:18,559 --> 00:28:20,240
frames with application data

768
00:28:20,240 --> 00:28:21,760
and these packets are encrypted using

769
00:28:21,760 --> 00:28:23,279
the zero rtt keys

770
00:28:23,279 --> 00:28:26,480
derived from tls these keys are known

771
00:28:26,480 --> 00:28:27,039
only

772
00:28:27,039 --> 00:28:30,960
to the client and the server

773
00:28:30,960 --> 00:28:32,799
there are two caveats to be aware of

774
00:28:32,799 --> 00:28:35,360
when using zero rtt data

775
00:28:35,360 --> 00:28:37,520
the first is that data sent under zero

776
00:28:37,520 --> 00:28:38,399
rtt keys

777
00:28:38,399 --> 00:28:41,919
is not forward secret the endpoints must

778
00:28:41,919 --> 00:28:43,440
wait until the handshake

779
00:28:43,440 --> 00:28:46,080
is complete to be able to send data with

780
00:28:46,080 --> 00:28:48,960
forward secrecy

781
00:28:49,039 --> 00:28:51,840
a separate issue is that zero rtt data

782
00:28:51,840 --> 00:28:53,679
can be replayed by an attacker

783
00:28:53,679 --> 00:28:56,840
as if it were the beginning of a new

784
00:28:56,840 --> 00:28:58,080
connection

785
00:28:58,080 --> 00:29:01,600
example a zero rtt

786
00:29:01,600 --> 00:29:04,240
packet from a client might contain an

787
00:29:04,240 --> 00:29:05,840
http request

788
00:29:05,840 --> 00:29:07,840
an attacker can observe these initial

789
00:29:07,840 --> 00:29:09,760
packets and then send them to the server

790
00:29:09,760 --> 00:29:10,799
a second time

791
00:29:10,799 --> 00:29:12,480
the server at this point has no way of

792
00:29:12,480 --> 00:29:14,480
knowing did those packets come from a

793
00:29:14,480 --> 00:29:15,279
live client

794
00:29:15,279 --> 00:29:17,279
or did those come from an attacker who

795
00:29:17,279 --> 00:29:19,120
has replayed them

796
00:29:19,120 --> 00:29:22,000
whatever processing that the server does

797
00:29:22,000 --> 00:29:22,720
with the

798
00:29:22,720 --> 00:29:24,960
data in the zero rtt packet it needs to

799
00:29:24,960 --> 00:29:26,000
be aware that

800
00:29:26,000 --> 00:29:29,200
it might receive it multiple times for

801
00:29:29,200 --> 00:29:30,960
example in http

802
00:29:30,960 --> 00:29:33,360
it is recommended that only safe http

803
00:29:33,360 --> 00:29:34,000
methods

804
00:29:34,000 --> 00:29:36,159
like get head or options are used in

805
00:29:36,159 --> 00:29:37,679
zero rtd data

806
00:29:37,679 --> 00:29:40,799
ultimately it is up to the protocol and

807
00:29:40,799 --> 00:29:43,600
the server to decide what data in zero

808
00:29:43,600 --> 00:29:45,039
rtt is acceptable

809
00:29:45,039 --> 00:29:47,279
and what data it will wait until the

810
00:29:47,279 --> 00:29:48,480
handshake is confirmed

811
00:29:48,480 --> 00:29:52,559
to process the caveats here that i've

812
00:29:52,559 --> 00:29:55,039
described for using zero rtt data

813
00:29:55,039 --> 00:29:57,200
in quick are the same ones for using

814
00:29:57,200 --> 00:29:59,760
zero rtt data in tls 1.3

815
00:29:59,760 --> 00:30:09,840
over tcp

816
00:30:14,000 --> 00:30:15,919
so we have now looked at how quick

817
00:30:15,919 --> 00:30:17,679
connections get established

818
00:30:17,679 --> 00:30:19,679
how they can be resumed and do some of

819
00:30:19,679 --> 00:30:20,960
what happens when a quick

820
00:30:20,960 --> 00:30:23,520
connection is running now let's talk

821
00:30:23,520 --> 00:30:25,679
about how a connection is terminated

822
00:30:25,679 --> 00:30:27,440
and how an attacker might use those

823
00:30:27,440 --> 00:30:29,600
mechanisms to close a connection it

824
00:30:29,600 --> 00:30:37,840
does not control

825
00:30:38,640 --> 00:30:40,240
the easiest way to close a quick

826
00:30:40,240 --> 00:30:42,240
connection is by sending

827
00:30:42,240 --> 00:30:44,320
a connection close frame to terminate

828
00:30:44,320 --> 00:30:46,480
the connection immediately

829
00:30:46,480 --> 00:30:48,159
remember that since quick frames are

830
00:30:48,159 --> 00:30:50,080
part of the protected payload an

831
00:30:50,080 --> 00:30:51,919
on-path attacker can't inject a

832
00:30:51,919 --> 00:30:53,919
connection close on a connection when

833
00:30:53,919 --> 00:30:56,159
the handshake has been confirmed

834
00:30:56,159 --> 00:30:58,000
an attacker can only inject connection

835
00:30:58,000 --> 00:30:59,279
closed frames if

836
00:30:59,279 --> 00:31:01,440
the endpoint is still receiving initial

837
00:31:01,440 --> 00:31:03,600
packets

838
00:31:03,600 --> 00:31:05,600
a connection can also be closed by idle

839
00:31:05,600 --> 00:31:06,720
timeout

840
00:31:06,720 --> 00:31:08,720
if an endpoint receives no new packets

841
00:31:08,720 --> 00:31:10,559
after a determined amount of time

842
00:31:10,559 --> 00:31:12,480
it silently closes the connection and

843
00:31:12,480 --> 00:31:15,440
discards its connection state

844
00:31:15,440 --> 00:31:17,919
an onpath network attacker could drop

845
00:31:17,919 --> 00:31:19,760
all packets for a connection

846
00:31:19,760 --> 00:31:21,279
there is nothing the transport protocol

847
00:31:21,279 --> 00:31:22,799
can do to mitigate this type of

848
00:31:22,799 --> 00:31:24,000
connection close

849
00:31:24,000 --> 00:31:26,240
besides moving the connection to a

850
00:31:26,240 --> 00:31:28,799
different path

851
00:31:29,600 --> 00:31:31,760
the last way a connection can be closed

852
00:31:31,760 --> 00:31:33,919
is via stateless reset

853
00:31:33,919 --> 00:31:36,159
if an endpoint loses connection state

854
00:31:36,159 --> 00:31:37,679
for example because the endpoint just

855
00:31:37,679 --> 00:31:38,559
restarted

856
00:31:38,559 --> 00:31:40,720
it may still be receiving packets for a

857
00:31:40,720 --> 00:31:42,960
connection to previously established

858
00:31:42,960 --> 00:31:44,640
since the endpoint no longer has the

859
00:31:44,640 --> 00:31:46,480
encryption keys for that connection

860
00:31:46,480 --> 00:31:48,559
it wants some way to signal to its peer

861
00:31:48,559 --> 00:31:51,200
that the connection is closed

862
00:31:51,200 --> 00:31:53,279
this is to save time waiting for the

863
00:31:53,279 --> 00:31:54,320
connection to timeout

864
00:31:54,320 --> 00:31:56,320
and to save bandwidth and processing

865
00:31:56,320 --> 00:31:57,840
while the pier is flooding

866
00:31:57,840 --> 00:32:01,840
this endpoint with packets

867
00:32:05,279 --> 00:32:07,279
the endpoint can signal this connection

868
00:32:07,279 --> 00:32:10,080
close with a stateless reset packet

869
00:32:10,080 --> 00:32:12,080
earlier in the connection when the

870
00:32:12,080 --> 00:32:13,840
endpoint provided its peer with its

871
00:32:13,840 --> 00:32:14,960
connection id

872
00:32:14,960 --> 00:32:16,720
the endpoint also provided a stateless

873
00:32:16,720 --> 00:32:18,320
reset token

874
00:32:18,320 --> 00:32:20,480
if the peer sees that stateless reset

875
00:32:20,480 --> 00:32:22,080
token in the future

876
00:32:22,080 --> 00:32:23,760
it knows that the endpoint is closing

877
00:32:23,760 --> 00:32:25,919
the connection

878
00:32:25,919 --> 00:32:27,760
an endpoint constructs the stateless

879
00:32:27,760 --> 00:32:30,159
reset token by using some global

880
00:32:30,159 --> 00:32:32,480
not per connection state so that it can

881
00:32:32,480 --> 00:32:34,080
deterministically derive

882
00:32:34,080 --> 00:32:35,919
the token from the connection id of the

883
00:32:35,919 --> 00:32:37,440
incoming packet

884
00:32:37,440 --> 00:32:40,080
for example this can be done by using a

885
00:32:40,080 --> 00:32:40,799
secret key

886
00:32:40,799 --> 00:32:42,640
on the server that persists through this

887
00:32:42,640 --> 00:32:45,519
restart and then computing an hmac or an

888
00:32:45,519 --> 00:32:46,399
hkdf

889
00:32:46,399 --> 00:32:48,080
of the connection id of the incoming

890
00:32:48,080 --> 00:32:49,919
packet

891
00:32:49,919 --> 00:32:51,840
it is important that whatever mechanism

892
00:32:51,840 --> 00:32:53,120
is used here

893
00:32:53,120 --> 00:32:55,440
keeps this key secret because if an

894
00:32:55,440 --> 00:32:57,120
attacker

895
00:32:57,120 --> 00:32:59,120
gets a hold of that secret it can

896
00:32:59,120 --> 00:33:00,880
compute stateless reset tokens

897
00:33:00,880 --> 00:33:03,039
for any connection and inject those and

898
00:33:03,039 --> 00:33:06,480
close connections it's not a part of

899
00:33:07,440 --> 00:33:09,120
this concludes our exploration of the

900
00:33:09,120 --> 00:33:11,679
http 3 protocol stack and its security

901
00:33:11,679 --> 00:33:14,080
features

902
00:33:14,159 --> 00:33:17,360
in summary the http 3 protocol stack

903
00:33:17,360 --> 00:33:19,039
has the same security features and

904
00:33:19,039 --> 00:33:22,799
properties as the http 2 protocol stack

905
00:33:22,799 --> 00:33:24,559
most of the functionality has been moved

906
00:33:24,559 --> 00:33:26,880
into the quick protocol

907
00:33:26,880 --> 00:33:29,840
http 3's use of quick provides improved

908
00:33:29,840 --> 00:33:32,559
performance compared to http 2.

909
00:33:32,559 --> 00:33:34,000
kwik's use of encryption and

910
00:33:34,000 --> 00:33:36,000
authentication prevents the network from

911
00:33:36,000 --> 00:33:37,360
modifying transport connection

912
00:33:37,360 --> 00:33:39,360
properties

913
00:33:39,360 --> 00:33:41,440
this encryption and authentication also

914
00:33:41,440 --> 00:33:43,519
improves privacy compared to tcp

915
00:33:43,519 --> 00:33:45,600
by making the connection id the only

916
00:33:45,600 --> 00:33:47,279
unencrypted part of the packet

917
00:33:47,279 --> 00:33:49,039
this also benefits future protocol

918
00:33:49,039 --> 00:33:51,279
development

919
00:33:51,279 --> 00:33:52,960
thank you for watching my talk and i

920
00:33:52,960 --> 00:33:58,720
will take any questions now

