1
00:00:02,240 --> 00:00:04,160
good morning welcome to our talk

2
00:00:04,160 --> 00:00:06,799
3d wrap you against your host is gage or

3
00:00:06,799 --> 00:00:09,120
humor carrier and we're tired or device

4
00:00:09,120 --> 00:00:11,280
we came from college of cyber security

5
00:00:11,280 --> 00:00:14,160
genon university china

6
00:00:14,160 --> 00:00:16,800
first let me introduce myself my english

7
00:00:16,800 --> 00:00:17,840
name is matthew

8
00:00:17,840 --> 00:00:20,880
i'm a graduate student of jinan

9
00:00:20,880 --> 00:00:23,840
university my supervisor is professor

10
00:00:23,840 --> 00:00:24,640
jim mung

11
00:00:24,640 --> 00:00:27,359
i'm interested in virtualization

12
00:00:27,359 --> 00:00:29,519
security and iot security

13
00:00:29,519 --> 00:00:32,238
i'm enthusiastic about cdf and gaming as

14
00:00:32,238 --> 00:00:33,360
a former leader

15
00:00:33,360 --> 00:00:37,280
of our university cdfd at this point

16
00:00:37,280 --> 00:00:39,600
i just finished my intern at tanzan

17
00:00:39,600 --> 00:00:40,559
canada

18
00:00:40,559 --> 00:00:43,600
i participate in the team aoe

19
00:00:43,600 --> 00:00:45,840
in that coincidence that we won the

20
00:00:45,840 --> 00:00:47,440
champion for this year

21
00:00:47,440 --> 00:00:51,520
you can find me on twitter with this id

22
00:00:51,520 --> 00:00:53,920
this is the agenda of our talk i will

23
00:00:53,920 --> 00:00:56,000
first introduce some research background

24
00:00:56,000 --> 00:00:58,480
about cumulative and virtual gpu

25
00:00:58,480 --> 00:01:00,559
then i will share some experience about

26
00:01:00,559 --> 00:01:02,559
building an embedded buzzer for

27
00:01:02,559 --> 00:01:03,920
third-party library

28
00:01:03,920 --> 00:01:06,479
this method is not limited to words

29
00:01:06,479 --> 00:01:08,159
virtualization scenario

30
00:01:08,159 --> 00:01:11,119
you can apply this design pattern and on

31
00:01:11,119 --> 00:01:12,479
any other targets

32
00:01:12,479 --> 00:01:15,439
search i will reveal how to employ a hip

33
00:01:15,439 --> 00:01:16,880
over for vulnerability

34
00:01:16,880 --> 00:01:19,040
and deliver a full gas to the hose is

35
00:01:19,040 --> 00:01:21,280
poison para virtualization

36
00:01:21,280 --> 00:01:23,840
device and last i will show you a demo

37
00:01:23,840 --> 00:01:27,119
of our exploits and conclude the talk

38
00:01:27,119 --> 00:01:30,400
so why do we chose cumulating research

39
00:01:30,400 --> 00:01:31,200
targets

40
00:01:31,200 --> 00:01:34,960
we noticed as cloud computing becoming a

41
00:01:34,960 --> 00:01:37,439
crucial business for many companies

42
00:01:37,439 --> 00:01:39,920
vendors are paying our great money on

43
00:01:39,920 --> 00:01:41,040
securing their

44
00:01:41,040 --> 00:01:43,439
virtualization products microsoft

45
00:01:43,439 --> 00:01:45,280
launched the hybrid web volunteer

46
00:01:45,280 --> 00:01:45,920
program

47
00:01:45,920 --> 00:01:49,280
offering up to 215 thousand dollars

48
00:01:49,280 --> 00:01:52,240
for and guests to host estate exports

49
00:01:52,240 --> 00:01:54,799
and vm category has become one of the

50
00:01:54,799 --> 00:01:57,280
most valuable targets or more cars

51
00:01:57,280 --> 00:01:59,280
hacking competition like ponchon and

52
00:01:59,280 --> 00:02:00,320
temple cup

53
00:02:00,320 --> 00:02:03,360
for example in temple cup happens at

54
00:02:03,360 --> 00:02:04,000
last

55
00:02:04,000 --> 00:02:07,600
november accumul kvm gets to host his

56
00:02:07,600 --> 00:02:09,440
voice was aborted 80

57
00:02:09,440 --> 00:02:12,400
000 this encouraged many security

58
00:02:12,400 --> 00:02:14,480
researchers to put their energy on

59
00:02:14,480 --> 00:02:16,800
virtualization security research

60
00:02:16,800 --> 00:02:19,680
many great talks on this topic came out

61
00:02:19,680 --> 00:02:21,040
on top

62
00:02:21,040 --> 00:02:24,400
converse live backhand authentic coin

63
00:02:24,400 --> 00:02:25,440
maintenance

64
00:02:25,440 --> 00:02:27,520
we believe this trade will last for a

65
00:02:27,520 --> 00:02:29,200
long time and we definitely

66
00:02:29,200 --> 00:02:32,400
want to join the party we consider cubia

67
00:02:32,400 --> 00:02:34,800
as a good starting point because it is

68
00:02:34,800 --> 00:02:36,959
open source and it has many similar

69
00:02:36,959 --> 00:02:38,800
designs with other virtualization

70
00:02:38,800 --> 00:02:40,640
products

71
00:02:40,640 --> 00:02:44,400
inspired by period previous research

72
00:02:44,400 --> 00:02:46,560
we found an interesting target website

73
00:02:46,560 --> 00:02:49,519
old real title is a parallel virtualized

74
00:02:49,519 --> 00:02:52,000
model to improve io performance in

75
00:02:52,000 --> 00:02:54,160
traditional virtualization models

76
00:02:54,160 --> 00:02:57,200
full emulation devices are widely used

77
00:02:57,200 --> 00:02:59,280
the hypervisor will take care of

78
00:02:59,280 --> 00:03:01,519
hardware emulation and the gas machine

79
00:03:01,519 --> 00:03:04,000
has no clue about it is running in

80
00:03:04,000 --> 00:03:05,440
virtualization

81
00:03:05,440 --> 00:03:07,680
environments so it doesn't need any

82
00:03:07,680 --> 00:03:09,840
modification on gas machine for this

83
00:03:09,840 --> 00:03:10,720
mode

84
00:03:10,720 --> 00:03:13,120
though full emulation is flexible it

85
00:03:13,120 --> 00:03:14,159
suffered from pool

86
00:03:14,159 --> 00:03:17,040
performance so parallel virtualization

87
00:03:17,040 --> 00:03:18,239
was proposed

88
00:03:18,239 --> 00:03:20,720
and worked i o is the most popular

89
00:03:20,720 --> 00:03:22,480
standard of this kind

90
00:03:22,480 --> 00:03:25,519
a dedicated driver will be installed on

91
00:03:25,519 --> 00:03:26,560
gas machine as

92
00:03:26,560 --> 00:03:29,519
phone end and qmil provides an interface

93
00:03:29,519 --> 00:03:30,480
as packet

94
00:03:30,480 --> 00:03:32,879
a rim buffer based communication channel

95
00:03:32,879 --> 00:03:35,120
is set up between guest and host

96
00:03:35,120 --> 00:03:37,920
when there is an io operation request on

97
00:03:37,920 --> 00:03:38,480
guest

98
00:03:38,480 --> 00:03:40,560
it will forward to the host machine

99
00:03:40,560 --> 00:03:42,239
through world tie or channel

100
00:03:42,239 --> 00:03:44,239
so that the host can use hardware

101
00:03:44,239 --> 00:03:46,959
resources to present the i o requests

102
00:03:46,959 --> 00:03:50,239
for now many words i o devices have been

103
00:03:50,239 --> 00:03:52,799
supported by cubo for example there is

104
00:03:52,799 --> 00:03:55,200
words io net pci for networking

105
00:03:55,200 --> 00:03:58,720
where i o scsi pci for storage verti

106
00:03:58,720 --> 00:04:02,080
or bloom for dynamic memory reject

107
00:04:02,080 --> 00:04:05,360
adjustment with tile gpu for

108
00:04:05,360 --> 00:04:08,560
graphic acceleration among all this

109
00:04:08,560 --> 00:04:09,680
device

110
00:04:09,680 --> 00:04:12,720
vertical gpu intrigues the most

111
00:04:12,720 --> 00:04:14,720
it is an important attack service

112
00:04:14,720 --> 00:04:16,000
discussed in the talk

113
00:04:16,000 --> 00:04:18,478
did into cumulative security on cancer

114
00:04:18,478 --> 00:04:22,479
west 2017 by jio 316 gear team

115
00:04:22,479 --> 00:04:25,280
this module aims at acceleration 3d

116
00:04:25,280 --> 00:04:27,840
rendering performance for gas machine

117
00:04:27,840 --> 00:04:30,479
if you want to play a 3d video game or

118
00:04:30,479 --> 00:04:32,639
in the guest machine you probably want

119
00:04:32,639 --> 00:04:33,840
to train it out

120
00:04:33,840 --> 00:04:36,160
a serve party library virtual renderer

121
00:04:36,160 --> 00:04:36,960
is used

122
00:04:36,960 --> 00:04:40,160
in the back end in short which io gpu

123
00:04:40,160 --> 00:04:42,000
backend accepts graphic rendering

124
00:04:42,000 --> 00:04:45,120
commands from the gas machine and import

125
00:04:45,120 --> 00:04:48,080
versus our renderer apis to assess them

126
00:04:48,080 --> 00:04:48,479
with

127
00:04:48,479 --> 00:04:51,360
hardware gpu computing advantage before

128
00:04:51,360 --> 00:04:52,560
hunting for bugs

129
00:04:52,560 --> 00:04:54,479
we did some background research we've

130
00:04:54,479 --> 00:04:56,880
seen the first public

131
00:04:56,880 --> 00:05:00,160
qmill guest to hold exports on

132
00:05:00,160 --> 00:05:04,160
usa 2011 it utilizes

133
00:05:04,160 --> 00:05:07,039
vulnerability in pirs4 power management

134
00:05:07,039 --> 00:05:09,199
in relation calls from commute

135
00:05:09,199 --> 00:05:12,000
many successful exploits came out during

136
00:05:12,000 --> 00:05:12,960
last decades

137
00:05:12,960 --> 00:05:16,880
most of them targeted on full emulated

138
00:05:16,880 --> 00:05:20,400
devices for example the network emulated

139
00:05:20,400 --> 00:05:22,400
module cost leaks

140
00:05:22,400 --> 00:05:24,320
there were two successful exploits for

141
00:05:24,320 --> 00:05:26,000
this module in last year

142
00:05:26,000 --> 00:05:28,800
vulnerabilities has also discovered in

143
00:05:28,800 --> 00:05:32,440
versailles device for example cve 2019

144
00:05:32,440 --> 00:05:33,759
1.835

145
00:05:33,759 --> 00:05:36,720
in we host net kernel modules but

146
00:05:36,720 --> 00:05:39,840
there's no public is poised for it

147
00:05:39,840 --> 00:05:41,919
when we first approached the source code

148
00:05:41,919 --> 00:05:43,600
of our geo renderer

149
00:05:43,600 --> 00:05:45,919
we found there is already a faster

150
00:05:45,919 --> 00:05:46,720
camera

151
00:05:46,720 --> 00:05:48,960
with the response tree and probably

152
00:05:48,960 --> 00:05:50,479
running as somewhere

153
00:05:50,479 --> 00:05:53,039
this is kind of disappointing because a

154
00:05:53,039 --> 00:05:55,360
well-written boxer kill bugs

155
00:05:55,360 --> 00:05:57,600
that means we are less likely to pass

156
00:05:57,600 --> 00:05:58,960
out some good bugs

157
00:05:58,960 --> 00:06:01,120
on the other hand it is also a good

158
00:06:01,120 --> 00:06:02,400
opportunity

159
00:06:02,400 --> 00:06:04,639
we can modify the faucet and save our

160
00:06:04,639 --> 00:06:07,360
time to build a new one on the ground up

161
00:06:07,360 --> 00:06:09,759
so let's look at how the original fossil

162
00:06:09,759 --> 00:06:12,319
was implemented

163
00:06:12,319 --> 00:06:16,240
it was based on lip faster simply

164
00:06:16,240 --> 00:06:18,880
set up objects and be mutated data to

165
00:06:18,880 --> 00:06:20,240
the target function

166
00:06:20,240 --> 00:06:22,560
then clean up the environment this

167
00:06:22,560 --> 00:06:25,280
submits cmd function accepts both data

168
00:06:25,280 --> 00:06:28,560
decoding and perform corresponding

169
00:06:28,560 --> 00:06:32,560
commands we compile the clusters and run

170
00:06:32,560 --> 00:06:33,600
it for about

171
00:06:33,600 --> 00:06:36,000
it turns out this original buzzer is far

172
00:06:36,000 --> 00:06:37,039
from mature

173
00:06:37,039 --> 00:06:39,360
its efficiency is pulled the coverage

174
00:06:39,360 --> 00:06:40,800
goes very slow

175
00:06:40,800 --> 00:06:43,520
its courage is poor even with sufficient

176
00:06:43,520 --> 00:06:43,919
time

177
00:06:43,919 --> 00:06:46,840
large portion of codes remain

178
00:06:46,840 --> 00:06:49,199
unexploited

179
00:06:49,199 --> 00:06:51,680
so we dig into the code to see the

180
00:06:51,680 --> 00:06:52,319
reasons

181
00:06:52,319 --> 00:06:55,039
and see if we can improve it the target

182
00:06:55,039 --> 00:06:57,280
functions of this cmd will call this

183
00:06:57,280 --> 00:06:59,199
vram decodebox function

184
00:06:59,199 --> 00:07:01,919
which contains 45 subcomments each

185
00:07:01,919 --> 00:07:03,759
follows its own syntax

186
00:07:03,759 --> 00:07:06,319
if the data does not follow the syntax

187
00:07:06,319 --> 00:07:07,759
decoder will drop it

188
00:07:07,759 --> 00:07:10,319
so randomly fit mutation does not work

189
00:07:10,319 --> 00:07:11,280
well

190
00:07:11,280 --> 00:07:14,240
most of mutated data are dropped leading

191
00:07:14,240 --> 00:07:16,720
to the poor efficiency

192
00:07:16,720 --> 00:07:19,199
the pool coverage can be attributed to

193
00:07:19,199 --> 00:07:20,240
two reasons

194
00:07:20,240 --> 00:07:23,360
there are 24 commands supported as apis

195
00:07:23,360 --> 00:07:25,759
many of them can be triggered from guest

196
00:07:25,759 --> 00:07:26,400
machine

197
00:07:26,400 --> 00:07:28,800
but only this one function is taken to

198
00:07:28,800 --> 00:07:30,800
consider of browsing

199
00:07:30,800 --> 00:07:33,360
among 45 sub comments or lost lights

200
00:07:33,360 --> 00:07:35,280
there are some dependencies

201
00:07:35,280 --> 00:07:37,520
for example there is a comment for

202
00:07:37,520 --> 00:07:38,560
creating object

203
00:07:38,560 --> 00:07:40,880
binding objects destroy objects

204
00:07:40,880 --> 00:07:43,120
obviously you cannot destroy an object

205
00:07:43,120 --> 00:07:44,479
before created

206
00:07:44,479 --> 00:07:46,400
so submitting one command for each

207
00:07:46,400 --> 00:07:50,159
parsing iteration is not enough

208
00:07:50,800 --> 00:07:53,199
to adjust these two problems and in the

209
00:07:53,199 --> 00:07:54,319
hope of finding

210
00:07:54,319 --> 00:07:57,039
more box we apply the idea of structure

211
00:07:57,039 --> 00:07:58,240
aware project

212
00:07:58,240 --> 00:08:00,720
google has an elaborated document on

213
00:08:00,720 --> 00:08:01,680
this topic

214
00:08:01,680 --> 00:08:03,759
also matt billingson from project zero

215
00:08:03,759 --> 00:08:05,759
presented a great talk on authenticon

216
00:08:05,759 --> 00:08:06,879
2019

217
00:08:06,879 --> 00:08:08,879
and we have jonathan maisman on backhand

218
00:08:08,879 --> 00:08:11,199
usa 19 sharing some knowledge about

219
00:08:11,199 --> 00:08:12,400
these techniques

220
00:08:12,400 --> 00:08:15,680
many gray bugs are fined by disposing

221
00:08:15,680 --> 00:08:16,479
techniques

222
00:08:16,479 --> 00:08:19,039
so i highly recommend you to take a look

223
00:08:19,039 --> 00:08:20,479
at these materials

224
00:08:20,479 --> 00:08:22,720
the idea of structure available fuzzing

225
00:08:22,720 --> 00:08:23,520
is simple

226
00:08:23,520 --> 00:08:25,599
while traditional mutation generates

227
00:08:25,599 --> 00:08:27,520
arbitrary random benefits for

228
00:08:27,520 --> 00:08:30,479
input samples which mostly are discarded

229
00:08:30,479 --> 00:08:31,039
by the

230
00:08:31,039 --> 00:08:32,880
target function we want to provide

231
00:08:32,880 --> 00:08:35,200
structural information for the mutator

232
00:08:35,200 --> 00:08:38,159
so it can mutate based on some rules

233
00:08:38,159 --> 00:08:39,679
generating more valuable

234
00:08:39,679 --> 00:08:42,479
samples one of practical methods to

235
00:08:42,479 --> 00:08:44,640
apply structure of wear forcing is to

236
00:08:44,640 --> 00:08:45,040
use

237
00:08:45,040 --> 00:08:48,240
lip product mutated lipo it leverage

238
00:08:48,240 --> 00:08:48,880
protocol

239
00:08:48,880 --> 00:08:51,279
buffer language to define structural

240
00:08:51,279 --> 00:08:52,160
information

241
00:08:52,160 --> 00:08:55,120
let's see an example here say we want to

242
00:08:55,120 --> 00:08:56,640
pass one of the

243
00:08:56,640 --> 00:08:59,279
subcomments call virtual renderer

244
00:08:59,279 --> 00:09:00,480
resource creates

245
00:09:00,480 --> 00:09:02,720
we can locate the arguments intercepts

246
00:09:02,720 --> 00:09:04,959
and transfer them into the protocol

247
00:09:04,959 --> 00:09:05,519
buffer

248
00:09:05,519 --> 00:09:08,800
formats this is trivial simply given the

249
00:09:08,800 --> 00:09:10,959
variable language correct states time is

250
00:09:10,959 --> 00:09:11,680
enough

251
00:09:11,680 --> 00:09:13,920
the lead protobuf mutation then reform

252
00:09:13,920 --> 00:09:14,880
the polar buff

253
00:09:14,880 --> 00:09:17,760
definition and mutate the arguments

254
00:09:17,760 --> 00:09:19,920
based on it

255
00:09:19,920 --> 00:09:22,959
integrating this into the puzzle is also

256
00:09:22,959 --> 00:09:23,519
easy

257
00:09:23,519 --> 00:09:27,360
the protobuf mutator provides the

258
00:09:27,360 --> 00:09:31,360
convenience macro to help rotating over

259
00:09:31,360 --> 00:09:34,800
product buff objects we change the

260
00:09:34,800 --> 00:09:37,120
leaf faster entry function with this and

261
00:09:37,120 --> 00:09:38,480
its arguments

262
00:09:38,480 --> 00:09:42,880
is the total object we have defined it

263
00:09:42,880 --> 00:09:45,519
as we mentioned before we want to submit

264
00:09:45,519 --> 00:09:48,080
massive comments in one person iteration

265
00:09:48,080 --> 00:09:50,640
that we call it accession and we want to

266
00:09:50,640 --> 00:09:51,200
mutate

267
00:09:51,200 --> 00:09:53,760
not only the arguments of each comments

268
00:09:53,760 --> 00:09:55,519
but also different combination of

269
00:09:55,519 --> 00:09:56,720
calling series

270
00:09:56,720 --> 00:09:58,800
so we define your session object like

271
00:09:58,800 --> 00:10:00,399
this it contains

272
00:10:00,399 --> 00:10:02,959
multiple comments and each comment is a

273
00:10:02,959 --> 00:10:04,160
product of

274
00:10:04,160 --> 00:10:06,720
objects contains its own argument

275
00:10:06,720 --> 00:10:09,360
definition

276
00:10:09,839 --> 00:10:12,160
for the setup and teardown it remains to

277
00:10:12,160 --> 00:10:14,399
be exactly the same as the original

278
00:10:14,399 --> 00:10:16,079
facet

279
00:10:16,079 --> 00:10:18,560
but we change the invoking logic the new

280
00:10:18,560 --> 00:10:19,279
version

281
00:10:19,279 --> 00:10:21,680
distributes comments according to its

282
00:10:21,680 --> 00:10:24,399
types it extract the mutated arguments

283
00:10:24,399 --> 00:10:27,680
and feed them to corresponding avr

284
00:10:27,680 --> 00:10:30,240
and it is good to go we first adapt a

285
00:10:30,240 --> 00:10:32,480
few comments to the faucet and get it

286
00:10:32,480 --> 00:10:33,440
wrong

287
00:10:33,440 --> 00:10:35,600
meanwhile we're adding more comments for

288
00:10:35,600 --> 00:10:37,360
it and we can see the coverage

289
00:10:37,360 --> 00:10:39,839
increase much faster than the original

290
00:10:39,839 --> 00:10:40,800
boxes

291
00:10:40,800 --> 00:10:42,720
actually it is becoming faster and

292
00:10:42,720 --> 00:10:44,320
faster as we add

293
00:10:44,320 --> 00:10:46,800
more comments to it we developed the

294
00:10:46,800 --> 00:10:49,600
faster on the vm of vmware workstation

295
00:10:49,600 --> 00:10:53,440
it runs at around 30 executions a second

296
00:10:53,440 --> 00:10:56,000
then we deploy it on a desktop with

297
00:10:56,000 --> 00:10:56,560
intro

298
00:10:56,560 --> 00:10:59,760
i5 7500 gts

299
00:10:59,760 --> 00:11:03,760
ti and get around 315 executions

300
00:11:03,760 --> 00:11:06,560
per second this is because some comments

301
00:11:06,560 --> 00:11:08,800
are preceded with graphic rendering

302
00:11:08,800 --> 00:11:09,600
operation

303
00:11:09,600 --> 00:11:12,320
with biometro gpu these commands can be

304
00:11:12,320 --> 00:11:13,440
processed

305
00:11:13,440 --> 00:11:16,800
much faster more than 300 execution per

306
00:11:16,800 --> 00:11:18,240
second sounds not bad

307
00:11:18,240 --> 00:11:21,440
and it is for one thread our

308
00:11:21,440 --> 00:11:23,920
on our machine with focal hdac it can

309
00:11:23,920 --> 00:11:26,399
have over 2k execution per second

310
00:11:26,399 --> 00:11:28,640
but we want to get a decent box in

311
00:11:28,640 --> 00:11:29,920
limited time

312
00:11:29,920 --> 00:11:32,320
instead of waiting some bugs came out we

313
00:11:32,320 --> 00:11:34,000
try to make it run faster

314
00:11:34,000 --> 00:11:36,959
we use it to call you profound tools it

315
00:11:36,959 --> 00:11:39,200
is a performance analysis tools as

316
00:11:39,200 --> 00:11:40,560
provided by google

317
00:11:40,560 --> 00:11:43,360
we linked the binary with gp found to

318
00:11:43,360 --> 00:11:44,160
his library

319
00:11:44,160 --> 00:11:46,320
so he can collect him founding data and

320
00:11:46,320 --> 00:11:48,000
generating choreographed

321
00:11:48,000 --> 00:11:50,720
the first commands here will run our

322
00:11:50,720 --> 00:11:52,399
faucet for 60 seconds

323
00:11:52,399 --> 00:11:55,040
and generate profoundly data called

324
00:11:55,040 --> 00:11:56,240
periph.out

325
00:11:56,240 --> 00:11:58,320
the second command will generate a call

326
00:11:58,320 --> 00:12:00,720
graph based on the profound data

327
00:12:00,720 --> 00:12:03,200
you can see the complicated core graph

328
00:12:03,200 --> 00:12:04,880
on the right

329
00:12:04,880 --> 00:12:07,040
then we look at the chord graph closely

330
00:12:07,040 --> 00:12:08,839
the second eye on this block

331
00:12:08,839 --> 00:12:10,959
indicates the execution time of this

332
00:12:10,959 --> 00:12:13,120
function over the whole running time

333
00:12:13,120 --> 00:12:15,200
the last line on this block indicates

334
00:12:15,200 --> 00:12:17,440
the execution time of this function and

335
00:12:17,440 --> 00:12:20,079
its sub function over the whole run time

336
00:12:20,079 --> 00:12:21,600
and we can see the rear

337
00:12:21,600 --> 00:12:24,160
renderer in it this individualization

338
00:12:24,160 --> 00:12:27,600
function occupies 71.7

339
00:12:27,600 --> 00:12:30,959
60 1.7 of execution time for the target

340
00:12:30,959 --> 00:12:31,760
function

341
00:12:31,760 --> 00:12:34,560
virtual renderer summary cmd only occupy

342
00:12:34,560 --> 00:12:35,920
0.9 of

343
00:12:35,920 --> 00:12:39,120
cpu time if you want run faster we can

344
00:12:39,120 --> 00:12:41,760
reduce the vram renderer in each course

345
00:12:41,760 --> 00:12:43,120
or even in limited

346
00:12:43,120 --> 00:12:45,079
step so it saves time on

347
00:12:45,079 --> 00:12:47,120
individualization and can spend more

348
00:12:47,120 --> 00:12:48,560
time on the function that we're

349
00:12:48,560 --> 00:12:51,279
interested in

350
00:12:51,279 --> 00:12:54,000
to do this we look at the apis provided

351
00:12:54,000 --> 00:12:55,600
by the target library

352
00:12:55,600 --> 00:12:57,680
and see one entry called virtual

353
00:12:57,680 --> 00:12:59,360
renderer reset

354
00:12:59,360 --> 00:13:02,079
in original buzzer we set up the render

355
00:13:02,079 --> 00:13:02,399
at

356
00:13:02,399 --> 00:13:05,440
each iteration and clean up at the app

357
00:13:05,440 --> 00:13:07,519
instead we can set up just once and

358
00:13:07,519 --> 00:13:09,279
reset at the end

359
00:13:09,279 --> 00:13:11,839
this saves massive operation of our main

360
00:13:11,839 --> 00:13:13,040
locks and freeze

361
00:13:13,040 --> 00:13:15,760
to enable this we can replace the clean

362
00:13:15,760 --> 00:13:18,000
up function with this reset one

363
00:13:18,000 --> 00:13:20,399
and move the initialization function to

364
00:13:20,399 --> 00:13:21,920
the global setup functions

365
00:13:21,920 --> 00:13:24,880
which will which only executed in first

366
00:13:24,880 --> 00:13:26,800
iteration

367
00:13:26,800 --> 00:13:29,040
it turns out this multiplication works

368
00:13:29,040 --> 00:13:30,480
surprisingly well

369
00:13:30,480 --> 00:13:33,600
we finally get around 1

370
00:13:33,600 --> 00:13:36,320
per second per code which is about five

371
00:13:36,320 --> 00:13:38,880
times faster than the default password

372
00:13:38,880 --> 00:13:41,120
the conclusion is that manual game free

373
00:13:41,120 --> 00:13:42,880
operations are expect

374
00:13:42,880 --> 00:13:45,760
expensive especially with the address

375
00:13:45,760 --> 00:13:47,360
sanitizer enabled

376
00:13:47,360 --> 00:13:49,920
we can use the gpu file tool to identify

377
00:13:49,920 --> 00:13:51,360
time consuming function

378
00:13:51,360 --> 00:13:53,199
and try to replace it with something

379
00:13:53,199 --> 00:13:55,680
else finally we can run this fuzzy

380
00:13:55,680 --> 00:13:57,040
competently

381
00:13:57,040 --> 00:13:59,279
the first part came out in less than 30

382
00:13:59,279 --> 00:14:01,360
minutes and the one we used

383
00:14:01,360 --> 00:14:04,560
is poi is found in 48 hours

384
00:14:04,560 --> 00:14:07,040
so let's see what we got from deposit we

385
00:14:07,040 --> 00:14:08,959
found a couple of serious bugs

386
00:14:08,959 --> 00:14:11,120
but due to the limits of time i will

387
00:14:11,120 --> 00:14:13,279
only show two typical ones here

388
00:14:13,279 --> 00:14:15,519
the first is a now pointed reference

389
00:14:15,519 --> 00:14:16,720
vulnerability

390
00:14:16,720 --> 00:14:19,120
it happens at the create assembler view

391
00:14:19,120 --> 00:14:20,320
commands

392
00:14:20,320 --> 00:14:23,360
when users can specify

393
00:14:23,360 --> 00:14:26,480
pi format the python s argument was

394
00:14:26,480 --> 00:14:28,160
passed to utilize format

395
00:14:28,160 --> 00:14:31,199
description function but inside it the

396
00:14:31,199 --> 00:14:34,320
error handling was wrong if it received

397
00:14:34,320 --> 00:14:34,639
an

398
00:14:34,639 --> 00:14:38,079
invade format value say part format

399
00:14:38,079 --> 00:14:41,360
count it will return now pointed

400
00:14:41,360 --> 00:14:43,120
then the now pointer the reference

401
00:14:43,120 --> 00:14:44,880
occurs and pressure process

402
00:14:44,880 --> 00:14:47,839
this box is unlikely to its voice that

403
00:14:47,839 --> 00:14:48,880
can cause a

404
00:14:48,880 --> 00:14:53,120
dos on the hypervisor the second box was

405
00:14:53,120 --> 00:14:54,959
the one we used to construct the

406
00:14:54,959 --> 00:14:59,839
exports cve 20191

407
00:15:00,160 --> 00:15:04,240
this is a ship based buffer overflow bug

408
00:15:04,240 --> 00:15:06,639
we have this resource create comments

409
00:15:06,639 --> 00:15:08,639
all arguments can be controlled

410
00:15:08,639 --> 00:15:11,519
from the guest machine when the bind

411
00:15:11,519 --> 00:15:12,079
argument

412
00:15:12,079 --> 00:15:15,040
is set to virtual bind custom we can

413
00:15:15,040 --> 00:15:18,639
control the size of buffer allocation

414
00:15:18,639 --> 00:15:20,720
and we have this resource in live write

415
00:15:20,720 --> 00:15:22,800
commands as its name suggested

416
00:15:22,800 --> 00:15:25,199
we can write content to the resource

417
00:15:25,199 --> 00:15:27,440
buffer it first look up the target

418
00:15:27,440 --> 00:15:28,240
results by

419
00:15:28,240 --> 00:15:30,880
its handle id and perform boundary

420
00:15:30,880 --> 00:15:31,600
checks

421
00:15:31,600 --> 00:15:34,079
if the checks parts the content will be

422
00:15:34,079 --> 00:15:36,320
written into the resource buffer

423
00:15:36,320 --> 00:15:40,079
however the crash from further tells us

424
00:15:40,079 --> 00:15:42,000
that these two boundary tracks can be

425
00:15:42,000 --> 00:15:43,920
bypassed

426
00:15:43,920 --> 00:15:46,079
to help you understand this box i will

427
00:15:46,079 --> 00:15:47,680
use some graph

428
00:15:47,680 --> 00:15:49,839
first we send and create resource

429
00:15:49,839 --> 00:15:52,240
commands creating a buffer of size of

430
00:15:52,240 --> 00:15:53,680
tent

431
00:15:53,680 --> 00:15:56,079
then we send a resource in line write

432
00:15:56,079 --> 00:15:56,720
our

433
00:15:56,720 --> 00:15:59,839
commands with the data of 100 ace but we

434
00:15:59,839 --> 00:16:00,880
change the w

435
00:16:00,880 --> 00:16:05,199
argument of this command to 0x800

436
00:16:05,199 --> 00:16:07,759
this will make all 100s rise to the

437
00:16:07,759 --> 00:16:09,920
resource buffer which is clearly a

438
00:16:09,920 --> 00:16:11,360
buffer overflows

439
00:16:11,360 --> 00:16:13,519
this is actually an individual overall

440
00:16:13,519 --> 00:16:16,519
problem the code will consider the

441
00:16:16,519 --> 00:16:19,600
0x8000 as a negative number and then

442
00:16:19,600 --> 00:16:22,320
bypass the boundary checks

443
00:16:22,320 --> 00:16:24,320
let's talk about the exploits

444
00:16:24,320 --> 00:16:26,800
developments

445
00:16:26,800 --> 00:16:28,480
another option for using leaf

446
00:16:28,480 --> 00:16:30,720
protobuffer neutral is you can easily

447
00:16:30,720 --> 00:16:33,680
dump the arguments that leads to a crash

448
00:16:33,680 --> 00:16:35,839
and we can control a poc from the

449
00:16:35,839 --> 00:16:37,040
crashdowns easily

450
00:16:37,040 --> 00:16:39,519
just filling the arguments and invoke

451
00:16:39,519 --> 00:16:40,959
the information api

452
00:16:40,959 --> 00:16:44,399
is enough the gas to host exports

453
00:16:44,399 --> 00:16:46,160
require us to trigger this for

454
00:16:46,160 --> 00:16:49,040
the guest machine that means we should

455
00:16:49,040 --> 00:16:50,959
figure out how to involve the

456
00:16:50,959 --> 00:16:53,120
vulnerable apis form inside the gas

457
00:16:53,120 --> 00:16:55,360
machine as you can see from the graph

458
00:16:55,360 --> 00:16:58,399
our target is in dps red color and we

459
00:16:58,399 --> 00:17:00,800
need to reach here from the gas side

460
00:17:00,800 --> 00:17:03,360
now we have two options the first is to

461
00:17:03,360 --> 00:17:04,160
build the

462
00:17:04,160 --> 00:17:06,880
exploits from the used lens it is easy

463
00:17:06,880 --> 00:17:07,760
for debugging

464
00:17:07,760 --> 00:17:10,079
easy to ship the explorer and launch an

465
00:17:10,079 --> 00:17:10,799
attack

466
00:17:10,799 --> 00:17:13,439
but it involves more expat layer the

467
00:17:13,439 --> 00:17:14,799
second is to build the

468
00:17:14,799 --> 00:17:17,280
exploits as a kernel module it involves

469
00:17:17,280 --> 00:17:18,720
fewer abstract layers

470
00:17:18,720 --> 00:17:20,959
but it is difficult to debug and some

471
00:17:20,959 --> 00:17:23,199
latest version of linux requires

472
00:17:23,199 --> 00:17:25,919
the signature to load the kernel module

473
00:17:25,919 --> 00:17:26,799
we definitely

474
00:17:26,799 --> 00:17:29,600
don't want that so we chose the first

475
00:17:29,600 --> 00:17:30,080
one

476
00:17:30,080 --> 00:17:32,080
here's a larger picture of the stack

477
00:17:32,080 --> 00:17:34,799
making out all interfaces in blue color

478
00:17:34,799 --> 00:17:37,200
let's start from the bottom we have the

479
00:17:37,200 --> 00:17:38,960
virtual renderer api

480
00:17:38,960 --> 00:17:41,440
which is also our target the back-end

481
00:17:41,440 --> 00:17:43,600
module calls these apis to access

482
00:17:43,600 --> 00:17:44,960
rendering tasks

483
00:17:44,960 --> 00:17:46,960
and between the phone and back end we

484
00:17:46,960 --> 00:17:49,360
have website or api this is the bridge

485
00:17:49,360 --> 00:17:51,120
between gas and host

486
00:17:51,120 --> 00:17:53,120
inside the gas we need to submit the

487
00:17:53,120 --> 00:17:54,880
comments from new zealand to

488
00:17:54,880 --> 00:17:57,520
kernel but what interface is involved

489
00:17:57,520 --> 00:17:59,120
here

490
00:17:59,120 --> 00:18:02,320
after some research we found a library

491
00:18:02,320 --> 00:18:03,600
called liberty or app

492
00:18:03,600 --> 00:18:05,840
it provides a useless interface to

493
00:18:05,840 --> 00:18:07,039
interact with

494
00:18:07,039 --> 00:18:10,080
graphic cards then our problem is

495
00:18:10,080 --> 00:18:12,799
finding the apis from lib drm which is

496
00:18:12,799 --> 00:18:15,600
corresponding to the vulnerable apis of

497
00:18:15,600 --> 00:18:20,240
virtual api or virtual renderer api

498
00:18:20,240 --> 00:18:22,400
it turned out they can be triggered by

499
00:18:22,400 --> 00:18:24,400
io control with specific

500
00:18:24,400 --> 00:18:27,840
command types then we can construct the

501
00:18:27,840 --> 00:18:28,480
poc

502
00:18:28,480 --> 00:18:31,760
for guest machine first open a graphic

503
00:18:31,760 --> 00:18:33,919
call fd and then simply use

504
00:18:33,919 --> 00:18:37,280
drm io control to submit the commands

505
00:18:37,280 --> 00:18:39,120
with magician arguments

506
00:18:39,120 --> 00:18:41,600
when we compile this and run it inside a

507
00:18:41,600 --> 00:18:44,480
gas machine with words i or gpu setting

508
00:18:44,480 --> 00:18:47,280
the qmil process on the host machine

509
00:18:47,280 --> 00:18:47,840
will crash

510
00:18:47,840 --> 00:18:51,600
immediately now we have a ship overflow

511
00:18:51,600 --> 00:18:53,919
poc with almost no constraints

512
00:18:53,919 --> 00:18:57,120
we can write our tree data with any size

513
00:18:57,120 --> 00:18:59,919
this is a powerful attack cryptic the

514
00:18:59,919 --> 00:19:01,840
several question we need to solve to

515
00:19:01,840 --> 00:19:04,080
reach a guest to host is gate

516
00:19:04,080 --> 00:19:06,160
the first question is what content we

517
00:19:06,160 --> 00:19:07,600
want to overwrite

518
00:19:07,600 --> 00:19:10,960
that's we need to bypass aslr

519
00:19:10,960 --> 00:19:14,080
because of address layout randomization

520
00:19:14,080 --> 00:19:17,039
the memory layout is random on each boot

521
00:19:17,039 --> 00:19:18,960
and information leakage is the most

522
00:19:18,960 --> 00:19:21,919
common method to bypass the mitigation

523
00:19:21,919 --> 00:19:24,559
we tried hard and spent plenty of time

524
00:19:24,559 --> 00:19:25,760
on this problem

525
00:19:25,760 --> 00:19:28,799
so this is considered to be the most

526
00:19:28,799 --> 00:19:32,720
challenging part in this research

527
00:19:33,679 --> 00:19:36,400
again let's analyze from the stack we

528
00:19:36,400 --> 00:19:38,000
see the word title api

529
00:19:38,000 --> 00:19:40,400
is the bridge between host and guest so

530
00:19:40,400 --> 00:19:42,720
our first idea is to auditing this

531
00:19:42,720 --> 00:19:45,440
interface we audit every website or

532
00:19:45,440 --> 00:19:47,200
output function on the backend

533
00:19:47,200 --> 00:19:50,080
but did not catch any box then we expand

534
00:19:50,080 --> 00:19:50,960
the scope to

535
00:19:50,960 --> 00:19:54,240
reverse io device for example

536
00:19:54,240 --> 00:19:57,360
we words ions pci words i

537
00:19:57,360 --> 00:20:00,880
o sc si pci and so on but still no

538
00:20:00,880 --> 00:20:02,640
foundation

539
00:20:02,640 --> 00:20:04,960
next step seems to be further a standard

540
00:20:04,960 --> 00:20:07,520
scope to other traditional device driver

541
00:20:07,520 --> 00:20:09,600
or commute to look for information

542
00:20:09,600 --> 00:20:10,640
leakage

543
00:20:10,640 --> 00:20:13,440
but then i thought wait is it worthwhile

544
00:20:13,440 --> 00:20:15,200
the only communication channel between

545
00:20:15,200 --> 00:20:15,760
gas and

546
00:20:15,760 --> 00:20:19,919
host the answer is no we found a slice

547
00:20:19,919 --> 00:20:20,880
from world

548
00:20:20,880 --> 00:20:24,480
gl renderer developer on x.o developers

549
00:20:24,480 --> 00:20:26,400
conference 2018

550
00:20:26,400 --> 00:20:29,200
he illustrated the process of rendering

551
00:20:29,200 --> 00:20:30,240
resources

552
00:20:30,240 --> 00:20:32,880
this workflow indicates the resources is

553
00:20:32,880 --> 00:20:33,679
transferred

554
00:20:33,679 --> 00:20:35,919
through some memory mapping and if we

555
00:20:35,919 --> 00:20:38,080
want we can look for some an

556
00:20:38,080 --> 00:20:40,960
initialized issue on second step maybe

557
00:20:40,960 --> 00:20:42,480
we can transfer some variable

558
00:20:42,480 --> 00:20:44,880
information to the guest

559
00:20:44,880 --> 00:20:47,039
and let's look back for resource queries

560
00:20:47,039 --> 00:20:48,240
function when

561
00:20:48,240 --> 00:20:51,520
locating the buffer for resources it use

562
00:20:51,520 --> 00:20:53,200
manual function without any

563
00:20:53,200 --> 00:20:55,120
initialization

564
00:20:55,120 --> 00:20:58,400
that means some buffer may contain level

565
00:20:58,400 --> 00:21:01,520
pointers inside with this knowledge we

566
00:21:01,520 --> 00:21:03,440
can update the picture

567
00:21:03,440 --> 00:21:06,880
besides the virtual api we have a

568
00:21:06,880 --> 00:21:09,200
back-end storage mechanism between the

569
00:21:09,200 --> 00:21:10,000
gas memory

570
00:21:10,000 --> 00:21:12,240
and the host resource buffer you can

571
00:21:12,240 --> 00:21:13,600
consider this is

572
00:21:13,600 --> 00:21:16,559
this as a special kind of memory mapping

573
00:21:16,559 --> 00:21:18,640
and we went through the code to find the

574
00:21:18,640 --> 00:21:20,799
correct commands to connect the

575
00:21:20,799 --> 00:21:23,679
resource buffer to the guest and request

576
00:21:23,679 --> 00:21:25,520
the transfer

577
00:21:25,520 --> 00:21:28,000
then we can use some heap manipulation

578
00:21:28,000 --> 00:21:28,720
technique to

579
00:21:28,720 --> 00:21:32,000
leave the address we want

580
00:21:32,000 --> 00:21:35,200
the first thing to link is a virtual

581
00:21:35,200 --> 00:21:36,960
renderer library objects

582
00:21:36,960 --> 00:21:39,120
we found this interesting structure

583
00:21:39,120 --> 00:21:40,000
called

584
00:21:40,000 --> 00:21:43,120
utilize hash table in the size of 0x 20

585
00:21:43,120 --> 00:21:43,919
parts

586
00:21:43,919 --> 00:21:47,360
it contains some function pointers for

587
00:21:47,360 --> 00:21:50,000
virtual renderer library and we want to

588
00:21:50,000 --> 00:21:52,400
read that memory from the guest site

589
00:21:52,400 --> 00:21:54,559
first we spread these objects over the

590
00:21:54,559 --> 00:21:55,600
heap with

591
00:21:55,600 --> 00:21:58,960
create subcontext second we destroy

592
00:21:58,960 --> 00:22:01,679
all the subcontents and this hash tables

593
00:22:01,679 --> 00:22:02,159
just

594
00:22:02,159 --> 00:22:05,600
located where we free to in the

595
00:22:05,600 --> 00:22:07,679
in the pd manual implementation of

596
00:22:07,679 --> 00:22:08,640
geolipsey

597
00:22:08,640 --> 00:22:10,960
this buffer will goes to t cache veins

598
00:22:10,960 --> 00:22:12,320
and phosphates

599
00:22:12,320 --> 00:22:14,720
third we allocate resource with buffer

600
00:22:14,720 --> 00:22:17,600
of 0s20 size so the resource buffer can

601
00:22:17,600 --> 00:22:20,240
occupy utilize hash table buffer we just

602
00:22:20,240 --> 00:22:21,039
print

603
00:22:21,039 --> 00:22:22,880
then we transfer the host resource

604
00:22:22,880 --> 00:22:24,799
buffer back to guest machine

605
00:22:24,799 --> 00:22:26,720
and finally we can read the compare

606
00:22:26,720 --> 00:22:29,600
function pointers on the magic memory of

607
00:22:29,600 --> 00:22:32,559
our guest machine

608
00:22:34,640 --> 00:22:36,799
we also want to link a lipsy address

609
00:22:36,799 --> 00:22:38,240
this is even simpler

610
00:22:38,240 --> 00:22:40,720
we can just locate some resource buffer

611
00:22:40,720 --> 00:22:42,960
lodging off sage or s1000

612
00:22:42,960 --> 00:22:45,200
libsy will allocate such a large buffer

613
00:22:45,200 --> 00:22:46,159
from the

614
00:22:46,159 --> 00:22:48,559
unsalted banks which contains the

615
00:22:48,559 --> 00:22:51,120
pointers to the lipsy address

616
00:22:51,120 --> 00:22:53,360
and we transfer this buffer back to

617
00:22:53,360 --> 00:22:54,720
guest and read out the

618
00:22:54,720 --> 00:22:58,000
lmc address done

619
00:22:59,600 --> 00:23:02,400
so the first problem solved the second

620
00:23:02,400 --> 00:23:04,159
is where we want to overwrite the

621
00:23:04,159 --> 00:23:05,200
exploitation of

622
00:23:05,200 --> 00:23:08,480
hip overflow usually usually requires

623
00:23:08,480 --> 00:23:11,679
some heat layout manipulation techniques

624
00:23:11,679 --> 00:23:14,960
so we can all write something useful

625
00:23:14,960 --> 00:23:17,600
we first use heap square interface to

626
00:23:17,600 --> 00:23:20,000
throw a number of vram resource

627
00:23:20,000 --> 00:23:22,799
object on the hip and observe the heat

628
00:23:22,799 --> 00:23:24,080
layer like this

629
00:23:24,080 --> 00:23:26,640
first is the vram resource object with

630
00:23:26,640 --> 00:23:27,520
id of x

631
00:23:27,520 --> 00:23:29,919
then counts is upper and we have a

632
00:23:29,919 --> 00:23:31,120
series of

633
00:23:31,120 --> 00:23:33,440
small objects of zero expanded size

634
00:23:33,440 --> 00:23:36,159
which is some hash table related

635
00:23:36,159 --> 00:23:38,880
structure of our resource index helping

636
00:23:38,880 --> 00:23:40,960
to look up the resource object which is

637
00:23:40,960 --> 00:23:41,679
id

638
00:23:41,679 --> 00:23:44,559
that is the vram resource with ids

639
00:23:44,559 --> 00:23:45,200
password

640
00:23:45,200 --> 00:23:48,880
and his buffer when we saw this layout

641
00:23:48,880 --> 00:23:50,080
and attack

642
00:23:50,080 --> 00:23:53,279
tanks came out we can overflow the

643
00:23:53,279 --> 00:23:54,000
buffer of

644
00:23:54,000 --> 00:23:57,360
resource with id x and all right the

645
00:23:57,360 --> 00:23:59,760
content inside resource x plus ones

646
00:23:59,760 --> 00:24:02,159
if we override the buffer pointer to

647
00:24:02,159 --> 00:24:03,039
somewhere else

648
00:24:03,039 --> 00:24:04,960
then we can perform another transfer in

649
00:24:04,960 --> 00:24:06,880
line write operation on resource

650
00:24:06,880 --> 00:24:08,880
x plus one and get an arbitrary right

651
00:24:08,880 --> 00:24:10,000
primitive

652
00:24:10,000 --> 00:24:12,400
but this will ruin the hash table

653
00:24:12,400 --> 00:24:14,880
structures below

654
00:24:14,880 --> 00:24:18,080
resource x buffer but that's okay it's

655
00:24:18,080 --> 00:24:20,159
because they are only used to

656
00:24:20,159 --> 00:24:23,039
locate the resource x and we don't need

657
00:24:23,039 --> 00:24:24,799
to touch it anymore

658
00:24:24,799 --> 00:24:28,879
when we have an aperture right primitive

659
00:24:29,760 --> 00:24:33,200
we've turned a hip buffer over into an

660
00:24:33,200 --> 00:24:35,679
arbitrary right next we need to hydrate

661
00:24:35,679 --> 00:24:38,880
the control flow

662
00:24:39,039 --> 00:24:40,960
what we want is a writeable global

663
00:24:40,960 --> 00:24:42,720
pointer in virtual render

664
00:24:42,720 --> 00:24:45,360
and we can trigger it free we found this

665
00:24:45,360 --> 00:24:46,080
call resource

666
00:24:46,080 --> 00:24:48,159
and reference function this function

667
00:24:48,159 --> 00:24:49,520
will be called on each

668
00:24:49,520 --> 00:24:52,640
destroy resource operation so we can use

669
00:24:52,640 --> 00:24:54,480
arbitrary right to write this pointer

670
00:24:54,480 --> 00:24:56,720
with system function from the lipstick

671
00:24:56,720 --> 00:24:59,360
and set the highlights of x 1 resource

672
00:24:59,360 --> 00:25:02,159
to arbitrary comments we want to execute

673
00:25:02,159 --> 00:25:04,320
for example the comments to product

674
00:25:04,320 --> 00:25:05,520
calculator

675
00:25:05,520 --> 00:25:07,600
and last we perform a destroy resource

676
00:25:07,600 --> 00:25:09,200
operation and the comments will be

677
00:25:09,200 --> 00:25:11,600
executed

678
00:25:11,600 --> 00:25:13,440
here's the whole picture of our

679
00:25:13,440 --> 00:25:16,240
exploitation

680
00:25:18,640 --> 00:25:22,159
now let's see a demo of this

681
00:25:26,840 --> 00:25:29,840
exploitation

682
00:25:39,279 --> 00:25:43,840
we start the virtual machine now

683
00:26:04,240 --> 00:26:07,200
we copy our exports into the virtual

684
00:26:07,200 --> 00:26:08,000
machine

685
00:26:08,000 --> 00:26:11,840
and as i change it

686
00:26:18,720 --> 00:26:22,480
now we'll sql os point

687
00:26:23,600 --> 00:26:26,720
and the calculator will pop up on the

688
00:26:26,720 --> 00:26:39,840
host machine

689
00:26:41,840 --> 00:26:44,320
and last here's some takeaway for our

690
00:26:44,320 --> 00:26:45,600
talk

691
00:26:45,600 --> 00:26:48,559
the first reforming a common foster to

692
00:26:48,559 --> 00:26:49,600
structure aware

693
00:26:49,600 --> 00:26:51,679
for third party library requires many

694
00:26:51,679 --> 00:26:54,240
many works but totally worth it

695
00:26:54,240 --> 00:26:56,640
and we talked about how to babysitting a

696
00:26:56,640 --> 00:26:57,279
business

697
00:26:57,279 --> 00:26:59,440
usually teacher is brought more core and

698
00:26:59,440 --> 00:27:00,799
run faster

699
00:27:00,799 --> 00:27:03,120
and virtual device and drivers are good

700
00:27:03,120 --> 00:27:05,760
pages to a humble box to control gas to

701
00:27:05,760 --> 00:27:08,240
host escape exports especially the

702
00:27:08,240 --> 00:27:11,760
graphic proceeding module

703
00:27:11,760 --> 00:27:13,840
the parallel virtualization also points

704
00:27:13,840 --> 00:27:14,880
to such attack

705
00:27:14,880 --> 00:27:16,720
especially when it involves circuit

706
00:27:16,720 --> 00:27:18,960
libraries

707
00:27:18,960 --> 00:27:25,039
so this is the end of our talk thank you

