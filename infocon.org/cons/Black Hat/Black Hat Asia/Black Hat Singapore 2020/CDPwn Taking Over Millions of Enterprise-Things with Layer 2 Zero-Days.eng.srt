1
00:00:00,880 --> 00:00:03,199
hi there my name is ben serry i'm the vp

2
00:00:03,199 --> 00:00:04,799
of research at armis

3
00:00:04,799 --> 00:00:07,200
and today with me i have a barack haddad

4
00:00:07,200 --> 00:00:09,920
hi marachi is a researcher on my team

5
00:00:09,920 --> 00:00:12,080
today we're going to talk about city

6
00:00:12,080 --> 00:00:14,000
pawn silly pawn is a set of rsc

7
00:00:14,000 --> 00:00:15,679
vulnerabilities that we've discovered in

8
00:00:15,679 --> 00:00:16,640
cisco's

9
00:00:16,640 --> 00:00:19,680
cdp protocol and these affect a wide

10
00:00:19,680 --> 00:00:21,119
array of cisco's devices

11
00:00:21,119 --> 00:00:23,920
switches routers but also iphones and ib

12
00:00:23,920 --> 00:00:25,199
cameras

13
00:00:25,199 --> 00:00:27,199
an estimated tens of millions of devices

14
00:00:27,199 --> 00:00:28,240
were affected by

15
00:00:28,240 --> 00:00:31,199
these vulnerabilities they can be used

16
00:00:31,199 --> 00:00:32,320
to break

17
00:00:32,320 --> 00:00:34,399
network segmentation but also take over

18
00:00:34,399 --> 00:00:35,600
enterprise iot

19
00:00:35,600 --> 00:00:39,040
devices such as iphones and ip cameras

20
00:00:39,040 --> 00:00:40,399
we'll get to how this can be done in a

21
00:00:40,399 --> 00:00:42,000
minute but first let me tell you a bit

22
00:00:42,000 --> 00:00:43,760
about ourselves

23
00:00:43,760 --> 00:00:46,000
the company we both work at armis is an

24
00:00:46,000 --> 00:00:48,160
enterprise iot security company

25
00:00:48,160 --> 00:00:50,399
and that mean means that we deal with

26
00:00:50,399 --> 00:00:52,559
iot devices and unmanaged devices in

27
00:00:52,559 --> 00:00:53,920
various environments

28
00:00:53,920 --> 00:00:55,600
incorporates in medical facilities and

29
00:00:55,600 --> 00:00:57,360
also in manufacturing

30
00:00:57,360 --> 00:00:59,520
part of our job is to study and research

31
00:00:59,520 --> 00:01:01,199
the infrastructure that is there

32
00:01:01,199 --> 00:01:04,080
to limit devices to a defined segment so

33
00:01:04,080 --> 00:01:04,959
this research

34
00:01:04,959 --> 00:01:07,280
set out to discover the risks to network

35
00:01:07,280 --> 00:01:08,560
infrastructure

36
00:01:08,560 --> 00:01:10,799
that may enable an unmanaged device to

37
00:01:10,799 --> 00:01:12,000
target it

38
00:01:12,000 --> 00:01:14,799
and break network segmentation gaining

39
00:01:14,799 --> 00:01:16,400
access to more critical parts of the

40
00:01:16,400 --> 00:01:18,799
network

41
00:01:20,560 --> 00:01:22,560
right so this is our agenda for this

42
00:01:22,560 --> 00:01:23,840
talk

43
00:01:23,840 --> 00:01:25,759
we'll begin with what is cd pawn what

44
00:01:25,759 --> 00:01:27,360
did we actually find

45
00:01:27,360 --> 00:01:29,200
the severity of the vulnerabilities and

46
00:01:29,200 --> 00:01:31,200
which devices they affect

47
00:01:31,200 --> 00:01:32,640
then we're going to discuss the history

48
00:01:32,640 --> 00:01:35,040
of vlan hopping

49
00:01:35,040 --> 00:01:37,360
as i mentioned part of why we looked at

50
00:01:37,360 --> 00:01:39,119
this in the first place is to understand

51
00:01:39,119 --> 00:01:40,000
network segmentation

52
00:01:40,000 --> 00:01:42,399
better to understand whether it's secure

53
00:01:42,399 --> 00:01:43,759
and whether we can poke

54
00:01:43,759 --> 00:01:46,079
holes in it so we want to cover the

55
00:01:46,079 --> 00:01:47,920
history of wheel and hopping techniques

56
00:01:47,920 --> 00:01:49,600
how are attackers doing this what are

57
00:01:49,600 --> 00:01:51,600
the known techniques and what silly pawn

58
00:01:51,600 --> 00:01:53,360
adds to the equation

59
00:01:53,360 --> 00:01:55,759
then we will discuss the attack surface

60
00:01:55,759 --> 00:01:57,840
of proprietary layer 2 protocols

61
00:01:57,840 --> 00:01:59,840
that constitute a large attack surface

62
00:01:59,840 --> 00:02:01,360
in network appliances

63
00:02:01,360 --> 00:02:03,040
cdp is one example of a proprietary

64
00:02:03,040 --> 00:02:05,119
layer 2 protocol from cisco that is used

65
00:02:05,119 --> 00:02:06,479
by almost every device that

66
00:02:06,479 --> 00:02:08,479
cisco manufactures but there are

67
00:02:08,479 --> 00:02:10,560
actually additional protocols

68
00:02:10,560 --> 00:02:12,400
this research started from looking in

69
00:02:12,400 --> 00:02:14,000
vulnerabilities that were already

70
00:02:14,000 --> 00:02:14,720
patched

71
00:02:14,720 --> 00:02:18,080
what is called one days and analyzing

72
00:02:18,080 --> 00:02:20,400
the patches for for them we looked at

73
00:02:20,400 --> 00:02:22,239
cisco disclosures in various literature

74
00:02:22,239 --> 00:02:23,440
protocols

75
00:02:23,440 --> 00:02:25,599
and understood the underlying bugs that

76
00:02:25,599 --> 00:02:27,360
were fixed and formed there continued

77
00:02:27,360 --> 00:02:28,319
the research and found

78
00:02:28,319 --> 00:02:29,920
new vulnerabilities although the

79
00:02:29,920 --> 00:02:32,000
affected devices are embedded devices

80
00:02:32,000 --> 00:02:32,640
that

81
00:02:32,640 --> 00:02:36,000
use very little mitigation aclr is

82
00:02:36,000 --> 00:02:38,080
used and so overcoming it when

83
00:02:38,080 --> 00:02:40,000
exploiting these rc's

84
00:02:40,000 --> 00:02:41,840
was not trivial and we will discuss the

85
00:02:41,840 --> 00:02:44,319
technique we developed to bypass a slr

86
00:02:44,319 --> 00:02:45,840
that is a very effective for these

87
00:02:45,840 --> 00:02:48,640
mobilities that we call polyrop

88
00:02:48,640 --> 00:02:50,319
we'll end with some takeaways on the

89
00:02:50,319 --> 00:02:51,760
implication of this research to the

90
00:02:51,760 --> 00:02:53,200
security of networks

91
00:02:53,200 --> 00:02:55,120
and enterprise-grade iphones and ip

92
00:02:55,120 --> 00:02:57,280
cameras and show a demo on how we manage

93
00:02:57,280 --> 00:02:58,640
to exploit the directories on the

94
00:02:58,640 --> 00:03:01,440
affected devices

95
00:03:01,599 --> 00:03:03,280
so to begin in high level what is

96
00:03:03,280 --> 00:03:04,720
silipon it

97
00:03:04,720 --> 00:03:08,000
is five vulnerabilities

98
00:03:08,000 --> 00:03:10,239
uh four remote execution vulnerabilities

99
00:03:10,239 --> 00:03:11,920
and one denial of service

100
00:03:11,920 --> 00:03:13,920
availability it is it is in the

101
00:03:13,920 --> 00:03:16,000
implementation of cisco's cdp protocol

102
00:03:16,000 --> 00:03:17,760
and it affects a wide range of cisco's

103
00:03:17,760 --> 00:03:18,640
devices like

104
00:03:18,640 --> 00:03:20,879
steady switches routers iphones and ip

105
00:03:20,879 --> 00:03:22,000
cameras

106
00:03:22,000 --> 00:03:24,319
and an estimate number of around tens of

107
00:03:24,319 --> 00:03:27,200
millions of devices affected

108
00:03:27,200 --> 00:03:29,519
all these devices here were affected

109
00:03:29,519 --> 00:03:31,280
from nexus switches which are the newest

110
00:03:31,280 --> 00:03:32,799
line of cisco switches

111
00:03:32,799 --> 00:03:36,319
to cisco irs xr routers cisco firepower

112
00:03:36,319 --> 00:03:36,959
firewalls

113
00:03:36,959 --> 00:03:38,640
and the entire line of current cisco

114
00:03:38,640 --> 00:03:40,959
iphones and this

115
00:03:40,959 --> 00:03:45,120
8000 series of cisco ip cameras

116
00:03:45,120 --> 00:03:46,959
these devices are used everywhere and

117
00:03:46,959 --> 00:03:49,040
the cisco iphone specifically are the

118
00:03:49,040 --> 00:03:51,360
most prevalent iphones in the market

119
00:03:51,360 --> 00:03:53,599
cisco advertises that 95 percent of

120
00:03:53,599 --> 00:03:55,120
fortune 500 companies

121
00:03:55,120 --> 00:03:58,560
use their iphone solutions in fact

122
00:03:58,560 --> 00:04:01,120
they are used by the government in

123
00:04:01,120 --> 00:04:02,560
corporates

124
00:04:02,560 --> 00:04:04,239
in the white house specifically you can

125
00:04:04,239 --> 00:04:06,560
you can find them

126
00:04:06,560 --> 00:04:09,280
in the situation room on the resolute

127
00:04:09,280 --> 00:04:09,920
desk

128
00:04:09,920 --> 00:04:12,840
and throughout the white house staff

129
00:04:12,840 --> 00:04:15,680
rooms

130
00:04:15,680 --> 00:04:18,399
yeah so yes they are really prevalent

131
00:04:18,399 --> 00:04:19,839
but they are actually not the main focus

132
00:04:19,839 --> 00:04:21,918
of this research

133
00:04:21,918 --> 00:04:23,520
as i mentioned our initial goal was to

134
00:04:23,520 --> 00:04:25,120
see how vlan hopping was done in the

135
00:04:25,120 --> 00:04:26,479
past and whether it can still be

136
00:04:26,479 --> 00:04:28,000
achieved today using additional

137
00:04:28,000 --> 00:04:31,600
vulnerabilities so

138
00:04:31,600 --> 00:04:34,160
so to understand vlan hopping techniques

139
00:04:34,160 --> 00:04:35,600
let's discuss for a minute

140
00:04:35,600 --> 00:04:38,720
vlans and how network segments

141
00:04:38,720 --> 00:04:41,680
work this is a simple design of a

142
00:04:41,680 --> 00:04:42,080
network

143
00:04:42,080 --> 00:04:44,080
diagram and the best practice of how

144
00:04:44,080 --> 00:04:46,240
networks needs to be connected today

145
00:04:46,240 --> 00:04:48,080
you will separate your devices based on

146
00:04:48,080 --> 00:04:49,840
trust level and type of device

147
00:04:49,840 --> 00:04:51,440
so you might have one segment for

148
00:04:51,440 --> 00:04:53,040
low-grade iot devices that you don't

149
00:04:53,040 --> 00:04:54,320
trust at all

150
00:04:54,320 --> 00:04:55,759
they connect to the internet but you

151
00:04:55,759 --> 00:04:57,440
really don't want them interacting

152
00:04:57,440 --> 00:04:59,600
with anything on your network and then

153
00:04:59,600 --> 00:05:01,600
you'd have a corporate segment for

154
00:05:01,600 --> 00:05:03,680
for all your corporate assets your

155
00:05:03,680 --> 00:05:05,600
computer your computers and

156
00:05:05,600 --> 00:05:08,639
and and whatnot and so your network will

157
00:05:08,639 --> 00:05:10,160
be split according to these

158
00:05:10,160 --> 00:05:11,840
segments in order to prevent devices

159
00:05:11,840 --> 00:05:13,440
from low level trust

160
00:05:13,440 --> 00:05:15,280
talking to devices with the hard lever

161
00:05:15,280 --> 00:05:16,479
trust

162
00:05:16,479 --> 00:05:18,080
so if an attacker were to compromise a

163
00:05:18,080 --> 00:05:19,680
device inside the iot segment for

164
00:05:19,680 --> 00:05:20,400
example

165
00:05:20,400 --> 00:05:22,479
he could interact with other iot devices

166
00:05:22,479 --> 00:05:24,080
but he can't by design

167
00:05:24,080 --> 00:05:25,440
talk with devices in the corporate

168
00:05:25,440 --> 00:05:27,680
network or other parts of the network

169
00:05:27,680 --> 00:05:30,400
for that matter so this is the power of

170
00:05:30,400 --> 00:05:32,080
network segmentation why it should be

171
00:05:32,080 --> 00:05:34,400
used

172
00:05:34,639 --> 00:05:36,720
and what are the techniques that existed

173
00:05:36,720 --> 00:05:38,000
in the past or maybe

174
00:05:38,000 --> 00:05:41,199
still exist today uh that can challenge

175
00:05:41,199 --> 00:05:44,479
this strategy uh double vlan tagging

176
00:05:44,479 --> 00:05:46,400
is a very old technique in certain

177
00:05:46,400 --> 00:05:47,680
circumstance circumstances

178
00:05:47,680 --> 00:05:50,240
it still works today it takes advantage

179
00:05:50,240 --> 00:05:52,720
of a simple flaw in how vlans work

180
00:05:52,720 --> 00:05:54,880
each network has what is called an atv

181
00:05:54,880 --> 00:05:56,880
lan and it is the idea of the vlan of

182
00:05:56,880 --> 00:05:58,720
any traffic that doesn't have a vlan

183
00:05:58,720 --> 00:05:59,759
header

184
00:05:59,759 --> 00:06:01,840
the native villa number one is a special

185
00:06:01,840 --> 00:06:03,840
case of native vlan

186
00:06:03,840 --> 00:06:05,680
in which untagged traffic in a trunk

187
00:06:05,680 --> 00:06:08,080
port is considered to be

188
00:06:08,080 --> 00:06:10,639
in vlan number one in the native villain

189
00:06:10,639 --> 00:06:12,319
and unfortunately in active vlan number

190
00:06:12,319 --> 00:06:12,639
one

191
00:06:12,639 --> 00:06:14,800
is the default native villain and so in

192
00:06:14,800 --> 00:06:15,759
a normal network

193
00:06:15,759 --> 00:06:17,280
when you have an attacker connected to a

194
00:06:17,280 --> 00:06:19,280
switch through an access port

195
00:06:19,280 --> 00:06:22,000
in the native vlan he can send packets

196
00:06:22,000 --> 00:06:23,600
without a vlan header

197
00:06:23,600 --> 00:06:25,199
and then in the trunk port between the

198
00:06:25,199 --> 00:06:26,639
switches the packets will also be

199
00:06:26,639 --> 00:06:29,759
without any vlan header

200
00:06:30,160 --> 00:06:31,520
the switching also supports

201
00:06:31,520 --> 00:06:33,360
encapsulating a vlan header from an

202
00:06:33,360 --> 00:06:36,080
access port if the used vlan id is the

203
00:06:36,080 --> 00:06:37,840
native villain of the network number one

204
00:06:37,840 --> 00:06:40,240
for example

205
00:06:40,240 --> 00:06:42,160
so the double vlan tagging attack simply

206
00:06:42,160 --> 00:06:43,759
works by an attacker putting two vlan

207
00:06:43,759 --> 00:06:44,639
headers

208
00:06:44,639 --> 00:06:47,039
on packets the outer one on a native

209
00:06:47,039 --> 00:06:49,120
line and then the inner one

210
00:06:49,120 --> 00:06:51,280
a target vlan id he'd like to be routed

211
00:06:51,280 --> 00:06:52,240
to

212
00:06:52,240 --> 00:06:54,080
the switch will decapitate the outer

213
00:06:54,080 --> 00:06:56,080
header and on

214
00:06:56,080 --> 00:06:58,479
and on on the trunk port the packet will

215
00:06:58,479 --> 00:07:00,160
contain the target vlan

216
00:07:00,160 --> 00:07:02,080
so this is a very simple technique it

217
00:07:02,080 --> 00:07:04,240
works but it has limitations

218
00:07:04,240 --> 00:07:05,680
so first of all you can only send

219
00:07:05,680 --> 00:07:07,280
packets one way you can't receive

220
00:07:07,280 --> 00:07:09,280
targets back from the target vlan

221
00:07:09,280 --> 00:07:11,199
it's also very simple to fix this cisco

222
00:07:11,199 --> 00:07:12,560
recommends customers

223
00:07:12,560 --> 00:07:15,120
not to use native vlan number one and

224
00:07:15,120 --> 00:07:17,360
then this problem doesn't exist

225
00:07:17,360 --> 00:07:19,199
but in certain cases when switched

226
00:07:19,199 --> 00:07:20,639
configurations are not ideal this can

227
00:07:20,639 --> 00:07:23,120
still occur

228
00:07:23,120 --> 00:07:25,360
a second logical flaw to do villain

229
00:07:25,360 --> 00:07:27,280
hopping is by abusing dtp

230
00:07:27,280 --> 00:07:30,319
btp the cisco propriety particle called

231
00:07:30,319 --> 00:07:31,919
the dynamic trunking protocol

232
00:07:31,919 --> 00:07:33,840
this protocol is a simple one it's just

233
00:07:33,840 --> 00:07:35,199
there to enable that on the

234
00:07:35,199 --> 00:07:37,840
configuration of switch ports parts of a

235
00:07:37,840 --> 00:07:39,440
switch will either be in access mode or

236
00:07:39,440 --> 00:07:40,479
trunk mode

237
00:07:40,479 --> 00:07:42,400
but dtp enables the port to change to

238
00:07:42,400 --> 00:07:43,759
change its mode

239
00:07:43,759 --> 00:07:46,720
dynamically from an access mode to trunk

240
00:07:46,720 --> 00:07:48,000
mode

241
00:07:48,000 --> 00:07:52,000
by negotiating over the dp packets

242
00:07:52,000 --> 00:07:54,479
so if dtp is not turned off an attacker

243
00:07:54,479 --> 00:07:56,240
can simply send a dtp packet to the

244
00:07:56,240 --> 00:07:56,879
switch

245
00:07:56,879 --> 00:07:59,039
that says to the switch change the mode

246
00:07:59,039 --> 00:08:00,879
of my port from access port to

247
00:08:00,879 --> 00:08:04,879
trunk port one that once the port is in

248
00:08:04,879 --> 00:08:06,319
trunk mode the attacker can

249
00:08:06,319 --> 00:08:08,000
natively send and receive packets from

250
00:08:08,000 --> 00:08:09,759
any vlan

251
00:08:09,759 --> 00:08:11,840
so this this just abuses the feature in

252
00:08:11,840 --> 00:08:13,919
cisco switches that allows these virtual

253
00:08:13,919 --> 00:08:15,039
devices

254
00:08:15,039 --> 00:08:16,639
to change their ports mode from access

255
00:08:16,639 --> 00:08:18,720
trunk to from accessport

256
00:08:18,720 --> 00:08:21,680
to trunk port and here a very simple

257
00:08:21,680 --> 00:08:22,800
solution from cisco is

258
00:08:22,800 --> 00:08:25,199
to turn off ddp at least on any port

259
00:08:25,199 --> 00:08:26,560
that is connected to a non-trusted

260
00:08:26,560 --> 00:08:28,960
device

261
00:08:30,319 --> 00:08:33,279
okay so what happens if dtp and double

262
00:08:33,279 --> 00:08:35,039
wheel attacking can't be used what can

263
00:08:35,039 --> 00:08:36,640
attackers still do

264
00:08:36,640 --> 00:08:38,240
they can look for vulnerabilities in

265
00:08:38,240 --> 00:08:40,320
whatever layer 2 particles are parsed

266
00:08:40,320 --> 00:08:43,360
by the code inside uh the switch

267
00:08:43,360 --> 00:08:46,399
even in access ports and silly pawn is

268
00:08:46,399 --> 00:08:46,880
exactly

269
00:08:46,880 --> 00:08:48,880
this vulnerabilities in this exact

270
00:08:48,880 --> 00:08:50,240
attack surface

271
00:08:50,240 --> 00:08:51,760
if an attacker has something like

272
00:08:51,760 --> 00:08:54,000
cd-pawn how could he use

273
00:08:54,000 --> 00:08:57,200
it so let's take this for example

274
00:08:57,200 --> 00:08:59,120
he had an attacker has gained control

275
00:08:59,120 --> 00:09:00,560
over an iot device

276
00:09:00,560 --> 00:09:02,959
in the iot segment he can send

277
00:09:02,959 --> 00:09:05,040
maliciously crafted cdp packets

278
00:09:05,040 --> 00:09:07,200
that will be parsed by the core switch

279
00:09:07,200 --> 00:09:09,040
and if a vulnerability exists there

280
00:09:09,040 --> 00:09:10,959
that might that might lead to code

281
00:09:10,959 --> 00:09:12,720
execution on the core switch

282
00:09:12,720 --> 00:09:14,160
and from the switch he obviously he

283
00:09:14,160 --> 00:09:15,680
obviously has access to the entire

284
00:09:15,680 --> 00:09:16,560
network

285
00:09:16,560 --> 00:09:19,440
including all of its vlans a core switch

286
00:09:19,440 --> 00:09:20,640
is a very strong position for an

287
00:09:20,640 --> 00:09:22,640
attacker to control he can accelerate

288
00:09:22,640 --> 00:09:24,240
data from the switch he can listen in

289
00:09:24,240 --> 00:09:26,399
on any network traffic that traverses

290
00:09:26,399 --> 00:09:27,440
through the switch

291
00:09:27,440 --> 00:09:28,800
and he can carry out many in the middle

292
00:09:28,800 --> 00:09:31,360
attacks so other than vlan hopping

293
00:09:31,360 --> 00:09:33,040
which is where we started it is

294
00:09:33,040 --> 00:09:34,480
important to understand that attacking a

295
00:09:34,480 --> 00:09:35,279
switch can be

296
00:09:35,279 --> 00:09:39,360
a gold mine of its own to attackers

297
00:09:40,080 --> 00:09:43,680
as i mentioned before dtp

298
00:09:43,680 --> 00:09:48,000
is a layer 2 protocol that is used

299
00:09:48,000 --> 00:09:51,040
that had these logical flaws that allow

300
00:09:51,040 --> 00:09:51,839
you to move from an

301
00:09:51,839 --> 00:09:54,080
access port to a transport but there are

302
00:09:54,080 --> 00:09:54,959
actually many

303
00:09:54,959 --> 00:09:57,040
more of these air to protocols that are

304
00:09:57,040 --> 00:09:59,120
used by network appliances

305
00:09:59,120 --> 00:10:01,600
by switches and routers the orange ones

306
00:10:01,600 --> 00:10:02,240
here are

307
00:10:02,240 --> 00:10:05,519
cisco proprietary particles but cisco is

308
00:10:05,519 --> 00:10:07,120
the de facto standard in network

309
00:10:07,120 --> 00:10:09,360
appliances so an attacker can consider

310
00:10:09,360 --> 00:10:10,800
all of these protocols as a

311
00:10:10,800 --> 00:10:12,480
potential attack surface for him to try

312
00:10:12,480 --> 00:10:15,120
and poke at

313
00:10:16,800 --> 00:10:20,320
okay so now uh barack will talk about

314
00:10:20,320 --> 00:10:23,680
the research that we've done

315
00:10:23,680 --> 00:10:26,560
analyzing cisco security advisories and

316
00:10:26,560 --> 00:10:28,160
layer 2 protocols and how this

317
00:10:28,160 --> 00:10:31,120
led us eventually to the video that

318
00:10:31,120 --> 00:10:33,839
we've discovered

319
00:10:36,640 --> 00:10:39,279
hi so we wanted to find the most

320
00:10:39,279 --> 00:10:41,040
vulnerable parts of the layer to attack

321
00:10:41,040 --> 00:10:41,680
surface

322
00:10:41,680 --> 00:10:43,519
so we started by looking at one days

323
00:10:43,519 --> 00:10:44,880
from cisco's website

324
00:10:44,880 --> 00:10:47,040
both of these advisories seem like they

325
00:10:47,040 --> 00:10:48,160
could lead

326
00:10:48,160 --> 00:10:51,600
to some remote code execution

327
00:10:52,240 --> 00:10:53,760
both of these advisories are about

328
00:10:53,760 --> 00:10:56,000
discovery protocols also the protocols

329
00:10:56,000 --> 00:10:58,079
are enabled by default and terminated

330
00:10:58,079 --> 00:11:01,279
by the nearest switch cdp and ndp are

331
00:11:01,279 --> 00:11:02,800
discovery protocols the main

332
00:11:02,800 --> 00:11:04,880
functionality is for devices to find one

333
00:11:04,880 --> 00:11:06,160
another in the network

334
00:11:06,160 --> 00:11:08,079
they walk away devices simply simply

335
00:11:08,079 --> 00:11:09,760
sending advertisement packets

336
00:11:09,760 --> 00:11:12,480
to a designated mac address every device

337
00:11:12,480 --> 00:11:13,839
that listens to these

338
00:11:13,839 --> 00:11:16,000
advertisement packets records them and

339
00:11:16,000 --> 00:11:18,399
will not follow them down the line

340
00:11:18,399 --> 00:11:20,720
cdp the cisco discovery protocol

341
00:11:20,720 --> 00:11:22,480
supports some advanced features like a

342
00:11:22,480 --> 00:11:22,880
voip

343
00:11:22,880 --> 00:11:24,959
and dedicated vlan and power over

344
00:11:24,959 --> 00:11:26,320
ethernet negotiation

345
00:11:26,320 --> 00:11:28,399
which allows the voip phones to request

346
00:11:28,399 --> 00:11:29,680
specific power required

347
00:11:29,680 --> 00:11:32,000
requirements from the switch that's why

348
00:11:32,000 --> 00:11:33,200
cisco voice phones

349
00:11:33,200 --> 00:11:36,320
don't have a cdp shutdown function

350
00:11:36,320 --> 00:11:37,839
it will hurt the functionality of the

351
00:11:37,839 --> 00:11:40,320
device

352
00:11:40,480 --> 00:11:42,800
we saw this lldp one day in a cisco

353
00:11:42,800 --> 00:11:44,160
security advisory

354
00:11:44,160 --> 00:11:46,800
and thought we may be able to exploit it

355
00:11:46,800 --> 00:11:49,200
and the only technical data was that

356
00:11:49,200 --> 00:11:51,200
the vulnerability exists due to improper

357
00:11:51,200 --> 00:11:53,120
level handling of malformed lldp

358
00:11:53,120 --> 00:11:53,839
messages

359
00:11:53,839 --> 00:11:56,240
not much not much to start from so we

360
00:11:56,240 --> 00:11:58,079
compared the firmware before and after

361
00:11:58,079 --> 00:11:58,720
the patch

362
00:11:58,720 --> 00:12:00,560
and looked for changes in the lldp

363
00:12:00,560 --> 00:12:03,440
passing functions

364
00:12:03,440 --> 00:12:06,079
we used the afra as a diffic tool one of

365
00:12:06,079 --> 00:12:07,200
its handy features

366
00:12:07,200 --> 00:12:09,200
is the comparison of branches if

367
00:12:09,200 --> 00:12:13,040
statements between matching functions

368
00:12:13,040 --> 00:12:15,519
the lldp process tlv function changed

369
00:12:15,519 --> 00:12:16,399
quite a bit

370
00:12:16,399 --> 00:12:18,560
in green you can see the changes the

371
00:12:18,560 --> 00:12:20,720
function uses a switch case to pass

372
00:12:20,720 --> 00:12:23,839
htlv tv is a type length value structure

373
00:12:23,839 --> 00:12:25,040
and for each tlv

374
00:12:25,040 --> 00:12:28,800
there are different length restrictions

375
00:12:28,800 --> 00:12:31,519
as you can see there were many missing

376
00:12:31,519 --> 00:12:32,320
length checks

377
00:12:32,320 --> 00:12:33,839
we could easily develop a denial of

378
00:12:33,839 --> 00:12:35,760
service attack using this but we were

379
00:12:35,760 --> 00:12:37,519
unable to make a remote code execution

380
00:12:37,519 --> 00:12:39,360
out of it so we continued our research

381
00:12:39,360 --> 00:12:41,680
to cdp

382
00:12:41,680 --> 00:12:43,760
dcve says the vulnerability exists

383
00:12:43,760 --> 00:12:46,240
because of insufficiently validated cdp

384
00:12:46,240 --> 00:12:47,279
packet headers

385
00:12:47,279 --> 00:12:50,160
just like with the lldp1day there is not

386
00:12:50,160 --> 00:12:52,240
much information in this cve but

387
00:12:52,240 --> 00:12:54,639
they do say that it's a buffer overflow

388
00:12:54,639 --> 00:12:56,320
and that it could allow arbitrary code

389
00:12:56,320 --> 00:12:57,360
execution

390
00:12:57,360 --> 00:13:01,040
so let's examine the cdp protocol

391
00:13:01,040 --> 00:13:03,600
looking at the addresses dlv we see

392
00:13:03,600 --> 00:13:05,360
there are a lot of lengths and some of

393
00:13:05,360 --> 00:13:07,040
them doesn't even make sense

394
00:13:07,040 --> 00:13:09,120
the tlv length is two bytes but the

395
00:13:09,120 --> 00:13:10,800
number of addresses is a four bytes

396
00:13:10,800 --> 00:13:11,360
field

397
00:13:11,360 --> 00:13:13,760
besides that we have two more landfills

398
00:13:13,760 --> 00:13:14,880
for each address

399
00:13:14,880 --> 00:13:17,839
great for vulnerability research we

400
00:13:17,839 --> 00:13:19,760
tried overflowing each length and the

401
00:13:19,760 --> 00:13:21,120
device didn't crash

402
00:13:21,120 --> 00:13:24,160
so we took a look at the actual code

403
00:13:24,160 --> 00:13:26,160
we found an interesting state confusion

404
00:13:26,160 --> 00:13:27,839
that leads to a memory corruption

405
00:13:27,839 --> 00:13:29,680
by sending a legitimate packet and a

406
00:13:29,680 --> 00:13:31,440
malicious one right after it

407
00:13:31,440 --> 00:13:33,279
on the right you can see the code that

408
00:13:33,279 --> 00:13:34,800
handles this field

409
00:13:34,800 --> 00:13:36,880
it tries to make sure that the address

410
00:13:36,880 --> 00:13:38,639
length matches the protocol type

411
00:13:38,639 --> 00:13:41,519
so that ipv4 will have a 4 byte address

412
00:13:41,519 --> 00:13:44,000
and ipv6 will have a 16 byte address

413
00:13:44,000 --> 00:13:46,079
an address blob is allocated for each

414
00:13:46,079 --> 00:13:48,240
device when the first lp packet arrives

415
00:13:48,240 --> 00:13:50,160
and it is being updated for every new

416
00:13:50,160 --> 00:13:51,440
cpu packet

417
00:13:51,440 --> 00:13:54,240
address len and protocol type are tackle

418
00:13:54,240 --> 00:13:55,120
controlled

419
00:13:55,120 --> 00:13:56,959
so the first packet is a legitimate

420
00:13:56,959 --> 00:13:59,440
rpv41 it sets the protocol type

421
00:13:59,440 --> 00:14:01,839
in the address blob to ipv4 and the

422
00:14:01,839 --> 00:14:02,560
address lan

423
00:14:02,560 --> 00:14:05,440
to 4. on the next packet the attacker

424
00:14:05,440 --> 00:14:07,199
sets the protocol type to an invalid

425
00:14:07,199 --> 00:14:07,680
value

426
00:14:07,680 --> 00:14:10,240
neither ipv4 nor ipv6 and sets the

427
00:14:10,240 --> 00:14:11,120
length to

428
00:14:11,120 --> 00:14:13,440
max unsigned short and since the

429
00:14:13,440 --> 00:14:15,199
protocol type is invalid

430
00:14:15,199 --> 00:14:17,120
both if statements in the beginning of

431
00:14:17,120 --> 00:14:18,720
the function are not taken

432
00:14:18,720 --> 00:14:22,480
and the protocol type stays ipv4 next

433
00:14:22,480 --> 00:14:24,240
and it's the one from the previous

434
00:14:24,240 --> 00:14:25,760
packet next

435
00:14:25,760 --> 00:14:28,079
when we get to the last if statement we

436
00:14:28,079 --> 00:14:30,480
now get to copy as much as we want

437
00:14:30,480 --> 00:14:32,560
to the address blob which is only 32

438
00:14:32,560 --> 00:14:35,119
bytes long

439
00:14:35,600 --> 00:14:37,680
we are now convinced that cdp is a good

440
00:14:37,680 --> 00:14:39,760
target and that boundary checks

441
00:14:39,760 --> 00:14:42,399
are an issue in this pulsar zero days

442
00:14:42,399 --> 00:14:44,160
are closer than ever

443
00:14:44,160 --> 00:14:48,160
so it's time to sit upon all the things

444
00:14:48,399 --> 00:14:50,880
so this first zero day we're going to

445
00:14:50,880 --> 00:14:52,160
talk about is actually

446
00:14:52,160 --> 00:14:55,120
in the same tlv as the previous one day

447
00:14:55,120 --> 00:14:56,240
it impacts a white

448
00:14:56,240 --> 00:14:58,079
a wide variety of cisco switches and

449
00:14:58,079 --> 00:15:00,160
routers and you will shortly see

450
00:15:00,160 --> 00:15:02,240
it deals with faulty length checks

451
00:15:02,240 --> 00:15:04,079
specifically the number of addresses

452
00:15:04,079 --> 00:15:07,120
which is a 4 byte long length

453
00:15:07,120 --> 00:15:09,040
that's weird because the tlv length is

454
00:15:09,040 --> 00:15:11,279
represented with 2 with only 2 bytes

455
00:15:11,279 --> 00:15:13,600
so it's impossible to fit that amount of

456
00:15:13,600 --> 00:15:15,600
addresses in the cdp packet

457
00:15:15,600 --> 00:15:17,760
in the next few slides we will show you

458
00:15:17,760 --> 00:15:19,440
we'll see how different code bases

459
00:15:19,440 --> 00:15:23,600
struggled with these multiple lan fields

460
00:15:23,680 --> 00:15:25,600
the first vulnerable codebase is the one

461
00:15:25,600 --> 00:15:28,000
found in the ios xr based product

462
00:15:28,000 --> 00:15:29,680
which mentioned which mainly includes

463
00:15:29,680 --> 00:15:31,440
routers notice that

464
00:15:31,440 --> 00:15:33,600
there is a malloc with a user controlled

465
00:15:33,600 --> 00:15:36,000
size there is also a length check but

466
00:15:36,000 --> 00:15:38,079
the size that is checked is not

467
00:15:38,079 --> 00:15:40,800
the one that is being allocated and both

468
00:15:40,800 --> 00:15:42,320
are vulnerable to classic integer

469
00:15:42,320 --> 00:15:43,279
overflows

470
00:15:43,279 --> 00:15:45,040
if we can find a number that will

471
00:15:45,040 --> 00:15:47,120
overflow to a to a small number

472
00:15:47,120 --> 00:15:49,360
in the first check and a large number uh

473
00:15:49,360 --> 00:15:51,040
when the allocation occurred

474
00:15:51,040 --> 00:15:53,360
occurs we can exhaust the device's

475
00:15:53,360 --> 00:15:55,839
memory

476
00:15:56,639 --> 00:15:59,199
let's take max unsigned in divided by 5

477
00:15:59,199 --> 00:16:01,360
rounded up

478
00:16:01,360 --> 00:16:03,279
after the multiplication and overflow we

479
00:16:03,279 --> 00:16:04,720
end up with a small size

480
00:16:04,720 --> 00:16:08,079
by passing the length check but

481
00:16:08,079 --> 00:16:09,920
we end up trying to allocate three

482
00:16:09,920 --> 00:16:12,000
gigabytes causing the malloc to fail

483
00:16:12,000 --> 00:16:14,639
instead of a deny of service

484
00:16:14,639 --> 00:16:17,279
now we'll try to take the same size but

485
00:16:17,279 --> 00:16:18,240
times four

486
00:16:18,240 --> 00:16:19,600
causing another overflow in the

487
00:16:19,600 --> 00:16:22,240
allocation size

488
00:16:22,240 --> 00:16:24,079
we still get a small enough size for the

489
00:16:24,079 --> 00:16:26,000
length

490
00:16:26,000 --> 00:16:29,240
and now we're trying to allocate only

491
00:16:29,240 --> 00:16:30,959
820 megabytes

492
00:16:30,959 --> 00:16:33,040
and the allocation succeeds do that a

493
00:16:33,040 --> 00:16:34,959
few times and the device crashes

494
00:16:34,959 --> 00:16:36,800
send these packets every 10 seconds and

495
00:16:36,800 --> 00:16:39,600
you put the router in a bootloop

496
00:16:39,600 --> 00:16:42,720
the next code base is the one of nxos

497
00:16:42,720 --> 00:16:44,560
that code is used in many of cisco

498
00:16:44,560 --> 00:16:46,320
switches and specifically the nexus

499
00:16:46,320 --> 00:16:46,959
series

500
00:16:46,959 --> 00:16:49,920
and xos is linux based and the chosen

501
00:16:49,920 --> 00:16:50,880
parsing implement

502
00:16:50,880 --> 00:16:52,800
implementation is a one where each

503
00:16:52,800 --> 00:16:53,920
protocol parcel

504
00:16:53,920 --> 00:16:56,639
has its own process in this code base

505
00:16:56,639 --> 00:16:58,560
the second if will allocate the new

506
00:16:58,560 --> 00:17:00,240
value if it's bigger than the old value

507
00:17:00,240 --> 00:17:01,920
so we can just ignore it

508
00:17:01,920 --> 00:17:04,640
and the first if looks like some kind of

509
00:17:04,640 --> 00:17:06,000
overflow check but

510
00:17:06,000 --> 00:17:09,439
faulty one multiplying number of

511
00:17:09,439 --> 00:17:10,799
addresses by 32

512
00:17:10,799 --> 00:17:12,480
is the same as shifting the value by

513
00:17:12,480 --> 00:17:13,839
five bits left

514
00:17:13,839 --> 00:17:16,400
so to pass the first if statement we

515
00:17:16,400 --> 00:17:18,160
just need the first

516
00:17:18,160 --> 00:17:20,480
five bits to be smaller than the next

517
00:17:20,480 --> 00:17:21,439
five ones

518
00:17:21,439 --> 00:17:23,599
using this an attacker can allocate any

519
00:17:23,599 --> 00:17:24,640
number of bytes

520
00:17:24,640 --> 00:17:27,599
and easily crash the cdp process on nxos

521
00:17:27,599 --> 00:17:29,840
the cdp process is restarted

522
00:17:29,840 --> 00:17:31,679
when it crashes but if there are more

523
00:17:31,679 --> 00:17:34,080
than 3 crashes in the same 5 minutes

524
00:17:34,080 --> 00:17:36,400
the entire switch reboots an attacker

525
00:17:36,400 --> 00:17:38,080
could boot loop the device by

526
00:17:38,080 --> 00:17:40,320
broadcasting cdp messages every couple

527
00:17:40,320 --> 00:17:42,880
of seconds

528
00:17:42,880 --> 00:17:45,039
the next geoday we'll talk about affects

529
00:17:45,039 --> 00:17:46,400
the same nxos

530
00:17:46,400 --> 00:17:48,799
based devices it is in the power request

531
00:17:48,799 --> 00:17:49,440
tlv

532
00:17:49,440 --> 00:17:51,760
and it is a simple stack overflow funny

533
00:17:51,760 --> 00:17:52,799
to me to mention

534
00:17:52,799 --> 00:17:55,840
this bug works even if the switch has no

535
00:17:55,840 --> 00:17:58,480
poe power over ethernet support because

536
00:17:58,480 --> 00:18:00,480
the passing code is still there

537
00:18:00,480 --> 00:18:03,039
we successfully exploited this zero day

538
00:18:03,039 --> 00:18:05,120
due to no stack canaries and low entropy

539
00:18:05,120 --> 00:18:05,760
aslr

540
00:18:05,760 --> 00:18:08,160
we will talk about how we bypassed the

541
00:18:08,160 --> 00:18:09,280
slr in a minute

542
00:18:09,280 --> 00:18:11,360
besides the stack overflow there is a

543
00:18:11,360 --> 00:18:13,039
rightward well primitive

544
00:18:13,039 --> 00:18:16,400
which we will also demonstrate

545
00:18:16,960 --> 00:18:20,640
okay so temp is a stack buffer of fixed

546
00:18:20,640 --> 00:18:21,440
length

547
00:18:21,440 --> 00:18:23,600
the while loop copies data from the cdp

548
00:18:23,600 --> 00:18:25,440
packet to that buffer with no length

549
00:18:25,440 --> 00:18:26,640
checks whatsoever

550
00:18:26,640 --> 00:18:29,679
besides that a1 is also pointer on the

551
00:18:29,679 --> 00:18:30,240
stack

552
00:18:30,240 --> 00:18:32,160
and the payload is written to an offset

553
00:18:32,160 --> 00:18:33,440
of it so

554
00:18:33,440 --> 00:18:36,160
when we overwrite a1 we get a

555
00:18:36,160 --> 00:18:38,320
lightweight primitive as well

556
00:18:38,320 --> 00:18:40,799
it means we have both a stack overflow

557
00:18:40,799 --> 00:18:42,480
and a lightweight well primitive

558
00:18:42,480 --> 00:18:44,640
in the same exploit packet let's see how

559
00:18:44,640 --> 00:18:47,600
we can leverage that

560
00:18:47,679 --> 00:18:49,440
before digging in let's explore the

561
00:18:49,440 --> 00:18:51,039
mitigations

562
00:18:51,039 --> 00:18:53,520
the only mitigation in these devices are

563
00:18:53,520 --> 00:18:56,080
nxbits and 32-bit aslr

564
00:18:56,080 --> 00:18:58,080
since the cdp process is a 32-bit

565
00:18:58,080 --> 00:19:00,960
process for 32-bit linux aslr is

566
00:19:00,960 --> 00:19:02,320
randomizing just

567
00:19:02,320 --> 00:19:04,960
one byte of the address and it's not the

568
00:19:04,960 --> 00:19:06,320
most significant one

569
00:19:06,320 --> 00:19:08,559
so the distance between two adjacent slr

570
00:19:08,559 --> 00:19:10,960
options is only four kilobytes

571
00:19:10,960 --> 00:19:13,320
multiply that by the number of options

572
00:19:13,320 --> 00:19:14,720
256

573
00:19:14,720 --> 00:19:16,480
and you get one megabyte top distance

574
00:19:16,480 --> 00:19:18,400
between two asl options

575
00:19:18,400 --> 00:19:21,039
it means that if some code section is

576
00:19:21,039 --> 00:19:22,400
bigger than one megabyte

577
00:19:22,400 --> 00:19:24,480
an attacker can choose an address that

578
00:19:24,480 --> 00:19:25,679
is guaranteed to have

579
00:19:25,679 --> 00:19:28,000
some code in it for any slr option

580
00:19:28,000 --> 00:19:29,039
besides that

581
00:19:29,039 --> 00:19:31,679
the entire memory map has the same asl

582
00:19:31,679 --> 00:19:32,240
shift

583
00:19:32,240 --> 00:19:34,160
and shared objects are only 4 kilobytes

584
00:19:34,160 --> 00:19:38,559
apart which also helps dealing with aslr

585
00:19:38,559 --> 00:19:41,039
we dub the term polyrop for the

586
00:19:41,039 --> 00:19:43,679
technique of slr based switch case

587
00:19:43,679 --> 00:19:46,000
the concept is to find one absolute

588
00:19:46,000 --> 00:19:47,840
address that triggers different drop

589
00:19:47,840 --> 00:19:48,559
gadgets

590
00:19:48,559 --> 00:19:50,799
based on the current aslog option and

591
00:19:50,799 --> 00:19:52,720
build a lock chain that works for more

592
00:19:52,720 --> 00:19:54,480
than one slr option without

593
00:19:54,480 --> 00:19:57,280
the need for infolex using this we can

594
00:19:57,280 --> 00:19:59,440
shorten the slr boot first time

595
00:19:59,440 --> 00:20:00,960
and exploit the device in minutes

596
00:20:00,960 --> 00:20:03,840
instead of days

597
00:20:03,840 --> 00:20:06,559
the other start it was defined to find

598
00:20:06,559 --> 00:20:07,200
in this

599
00:20:07,200 --> 00:20:09,520
poly option is the multi gadget an

600
00:20:09,520 --> 00:20:11,600
address that triggers a different gadget

601
00:20:11,600 --> 00:20:13,919
for every slr option we are going to

602
00:20:13,919 --> 00:20:15,600
demonstrate a multi gadget that works

603
00:20:15,600 --> 00:20:15,919
for

604
00:20:15,919 --> 00:20:18,640
three slr options in green you can see

605
00:20:18,640 --> 00:20:20,000
we highlighted the byte that

606
00:20:20,000 --> 00:20:22,559
sl shifts as you can see the addresses

607
00:20:22,559 --> 00:20:24,000
are the same except for

608
00:20:24,000 --> 00:20:26,720
that byte so we can put one of these

609
00:20:26,720 --> 00:20:28,400
addresses and let aslr

610
00:20:28,400 --> 00:20:31,840
choose the proper gadget for us

611
00:20:31,840 --> 00:20:33,840
it is another representation every

612
00:20:33,840 --> 00:20:34,960
column represents

613
00:20:34,960 --> 00:20:37,520
represents the memory space of one slr

614
00:20:37,520 --> 00:20:38,080
option

615
00:20:38,080 --> 00:20:40,559
and the multi-gadget is the address

616
00:20:40,559 --> 00:20:42,000
we're going to jump to

617
00:20:42,000 --> 00:20:44,080
at the beginning of our blockchain you

618
00:20:44,080 --> 00:20:46,159
can see that in sl option 1

619
00:20:46,159 --> 00:20:48,559
the multi-gadget address triggers gadget

620
00:20:48,559 --> 00:20:50,159
a in slr option 2

621
00:20:50,159 --> 00:20:52,880
it triggers gadget b and in slr option 3

622
00:20:52,880 --> 00:20:56,000
it triggers gadget c

623
00:20:56,000 --> 00:20:58,640
so let's take the three addresses and

624
00:20:58,640 --> 00:20:59,440
check the

625
00:20:59,440 --> 00:21:03,120
hypothesis with actual numbers for slr

626
00:21:03,120 --> 00:21:03,919
option 0

627
00:21:03,919 --> 00:21:06,880
the addresses stay the same for sll

628
00:21:06,880 --> 00:21:07,760
option 8

629
00:21:07,760 --> 00:21:09,600
the addresses are shifted and now

630
00:21:09,600 --> 00:21:11,039
another gadget falls

631
00:21:11,039 --> 00:21:15,679
on address 6f314 for slot option 45

632
00:21:15,679 --> 00:21:17,760
the addresses are shifted again and

633
00:21:17,760 --> 00:21:19,919
another gadget is moved to the same

634
00:21:19,919 --> 00:21:23,200
6f address and bingo by jumping to

635
00:21:23,200 --> 00:21:24,799
address 6f 314

636
00:21:24,799 --> 00:21:26,400
we are guaranteed that one of the

637
00:21:26,400 --> 00:21:28,159
gadgets will be activated

638
00:21:28,159 --> 00:21:30,159
each row shows the location of the

639
00:21:30,159 --> 00:21:32,240
gadgets for a specific aslr option

640
00:21:32,240 --> 00:21:34,400
and you can see that each row has some

641
00:21:34,400 --> 00:21:35,880
gadget in the address

642
00:21:35,880 --> 00:21:40,480
6f314 looking back at this gadget

643
00:21:40,480 --> 00:21:43,520
gadget a pops and returns gadget b

644
00:21:43,520 --> 00:21:45,679
pops and returns and double pops and

645
00:21:45,679 --> 00:21:47,760
returns and gadget c

646
00:21:47,760 --> 00:21:50,799
gets 32 bytes off the stack and returned

647
00:21:50,799 --> 00:21:53,039
that means that for every aslog option

648
00:21:53,039 --> 00:21:53,840
the drop chain

649
00:21:53,840 --> 00:21:56,840
is pivoted and pivoted into a different

650
00:21:56,840 --> 00:21:58,799
address

651
00:21:58,799 --> 00:22:01,520
looking at the rope chain flow the

652
00:22:01,520 --> 00:22:02,320
multi-gadget

653
00:22:02,320 --> 00:22:04,320
acts as a switch case and splits the

654
00:22:04,320 --> 00:22:06,320
option to an individual option

655
00:22:06,320 --> 00:22:09,520
for each slr option in order to have

656
00:22:09,520 --> 00:22:10,559
enough space

657
00:22:10,559 --> 00:22:12,880
for each slr option we needed to space

658
00:22:12,880 --> 00:22:14,320
out the rope chains

659
00:22:14,320 --> 00:22:17,120
for this purpose we use stacked keeping

660
00:22:17,120 --> 00:22:18,559
stack skipping gadgets

661
00:22:18,559 --> 00:22:20,400
stack skipping gadgets are the gargets

662
00:22:20,400 --> 00:22:22,480
that add to the stack pointer but don't

663
00:22:22,480 --> 00:22:23,600
write to

664
00:22:23,600 --> 00:22:26,159
the process memory using stack skipping

665
00:22:26,159 --> 00:22:26,720
gadgets

666
00:22:26,720 --> 00:22:29,280
we can give each rock chain enough space

667
00:22:29,280 --> 00:22:31,200
to install execution and execute our

668
00:22:31,200 --> 00:22:31,919
shellcode

669
00:22:31,919 --> 00:22:33,600
so we just need to find some stacks

670
00:22:33,600 --> 00:22:36,000
keepers

671
00:22:37,520 --> 00:22:40,960
just a second okay um these are a few

672
00:22:40,960 --> 00:22:42,559
stack skipper examples

673
00:22:42,559 --> 00:22:44,880
the only uh changer they only change

674
00:22:44,880 --> 00:22:45,600
registers

675
00:22:45,600 --> 00:22:47,280
and the stack address but don't touch

676
00:22:47,280 --> 00:22:48,640
any actual memory

677
00:22:48,640 --> 00:22:52,080
the first one on the left pops 244 bytes

678
00:22:52,080 --> 00:22:54,799
and returns the second one 36 and the

679
00:22:54,799 --> 00:22:56,720
last one 640.

680
00:22:56,720 --> 00:22:58,960
we are no longer limited by slr so we

681
00:22:58,960 --> 00:23:00,799
made a script that automatically finds

682
00:23:00,799 --> 00:23:04,400
a stack skipping gadgets and found these

683
00:23:04,400 --> 00:23:07,039
every line in this dictionary maps

684
00:23:07,039 --> 00:23:08,400
between a skipping length

685
00:23:08,400 --> 00:23:11,760
and a rope gadget address so

686
00:23:11,760 --> 00:23:14,400
a quick recap the multi gadgets place

687
00:23:14,400 --> 00:23:15,120
the rope

688
00:23:15,120 --> 00:23:16,960
to multiple paths because it triggers a

689
00:23:16,960 --> 00:23:19,280
different gadget for every slr option

690
00:23:19,280 --> 00:23:21,520
the stack skippers space out the rope

691
00:23:21,520 --> 00:23:23,520
chains so that they have enough space

692
00:23:23,520 --> 00:23:24,720
for the shell code

693
00:23:24,720 --> 00:23:26,720
and now we just need to write the shell

694
00:23:26,720 --> 00:23:29,200
code as if there is no slr and relocate

695
00:23:29,200 --> 00:23:31,039
the addresses for every srl option

696
00:23:31,039 --> 00:23:33,360
object

697
00:23:33,600 --> 00:23:36,000
using this method we were able to make

698
00:23:36,000 --> 00:23:37,679
one rope chain that works for

699
00:23:37,679 --> 00:23:40,080
15 slr options including execution

700
00:23:40,080 --> 00:23:41,039
restoration

701
00:23:41,039 --> 00:23:42,960
this reduced the exploitation time from

702
00:23:42,960 --> 00:23:44,400
about seven hours

703
00:23:44,400 --> 00:23:46,960
to a half an hour and was a lot of fun

704
00:23:46,960 --> 00:23:47,919
to develop

705
00:23:47,919 --> 00:23:50,640
in the picture you can see a remote a

706
00:23:50,640 --> 00:23:52,480
wood shell that we were able to trigger

707
00:23:52,480 --> 00:23:55,679
using this exploitation

708
00:23:56,000 --> 00:23:59,600
so now we'll demonstrate this code

709
00:23:59,600 --> 00:24:02,159
exploitation by takeover a cisco nexus

710
00:24:02,159 --> 00:24:02,960
switch

711
00:24:02,960 --> 00:24:04,880
and on the right you see a laptop on the

712
00:24:04,880 --> 00:24:06,960
network on the internal network

713
00:24:06,960 --> 00:24:09,840
and the cisco switch on the bottom and

714
00:24:09,840 --> 00:24:11,039
on the left you can see the hacker

715
00:24:11,039 --> 00:24:12,080
terminal

716
00:24:12,080 --> 00:24:14,480
and now it tries to get the secret data

717
00:24:14,480 --> 00:24:15,840
and he can't because it's not

718
00:24:15,840 --> 00:24:18,400
in the correct villain so he sniffs the

719
00:24:18,400 --> 00:24:19,840
cdp packets

720
00:24:19,840 --> 00:24:22,880
and inside the cdp packets he knows you

721
00:24:22,880 --> 00:24:24,080
see the data from

722
00:24:24,080 --> 00:24:27,200
which port is connected to the switch so

723
00:24:27,200 --> 00:24:30,080
now he can change settings for his own

724
00:24:30,080 --> 00:24:31,200
port when he gets

725
00:24:31,200 --> 00:24:34,320
code execution now the attacker

726
00:24:34,320 --> 00:24:38,640
starts the attack sends the payload

727
00:24:38,640 --> 00:24:42,880
until he gets an aslr bypass

728
00:24:44,000 --> 00:24:47,039
successfully executed and now he adds a

729
00:24:47,039 --> 00:24:48,799
user to the switch

730
00:24:48,799 --> 00:24:52,240
and adds a management ip for the switch

731
00:24:52,240 --> 00:24:54,240
in the same vlan as the vm is currently

732
00:24:54,240 --> 00:24:54,930
connected to

733
00:24:54,930 --> 00:24:58,080
[Music]

734
00:24:58,080 --> 00:25:01,840
and connects the switch

735
00:25:05,679 --> 00:25:07,760
okay so now he is connected to the

736
00:25:07,760 --> 00:25:09,600
switch he can execute

737
00:25:09,600 --> 00:25:13,120
a root shell and do whatever he wants so

738
00:25:13,120 --> 00:25:16,480
he checks the villains and he sees he's

739
00:25:16,480 --> 00:25:18,080
connected to the guest villain

740
00:25:18,080 --> 00:25:21,039
and the it network is on the super

741
00:25:21,039 --> 00:25:22,000
secret villain

742
00:25:22,000 --> 00:25:24,799
so it just changes the villain of the

743
00:25:24,799 --> 00:25:25,520
attacker

744
00:25:25,520 --> 00:25:30,400
to the one of the super secret villain

745
00:25:33,440 --> 00:25:35,520
and when it's connected to the super

746
00:25:35,520 --> 00:25:36,960
secret wheel you can

747
00:25:36,960 --> 00:25:39,520
get the secret data and actually

748
00:25:39,520 --> 00:25:43,840
exfiltrate it out

749
00:25:44,159 --> 00:25:46,400
okay

750
00:25:50,240 --> 00:25:52,480
cool so the last video day we'll talk

751
00:25:52,480 --> 00:25:54,559
about effects multiple models

752
00:25:54,559 --> 00:25:57,520
of cisco voip phones it is also a simple

753
00:25:57,520 --> 00:25:58,480
stack overflow

754
00:25:58,480 --> 00:26:00,480
using a mem copy with no length

755
00:26:00,480 --> 00:26:01,919
validation

756
00:26:01,919 --> 00:26:04,720
like nx os the cdp passing process runs

757
00:26:04,720 --> 00:26:05,919
with loot privileges

758
00:26:05,919 --> 00:26:08,000
meaning that an attacker gains full

759
00:26:08,000 --> 00:26:09,919
control over a device after exploiting

760
00:26:09,919 --> 00:26:12,720
this vulnerability

761
00:26:12,720 --> 00:26:15,200
as mentioned before cp is sent with a

762
00:26:15,200 --> 00:26:17,919
special multicast mac address

763
00:26:17,919 --> 00:26:20,000
assuming it's all cisco switches when a

764
00:26:20,000 --> 00:26:22,320
cdp packet is being sent correctly it is

765
00:26:22,320 --> 00:26:24,400
parsed in the neighbor's switch

766
00:26:24,400 --> 00:26:26,240
and it's not being forward the switch

767
00:26:26,240 --> 00:26:28,080
discards it because

768
00:26:28,080 --> 00:26:31,360
it assumes the packet is destined for

769
00:26:31,360 --> 00:26:33,840
the switch

770
00:26:33,919 --> 00:26:36,960
when a malformed packet one with an

771
00:26:36,960 --> 00:26:38,080
incorrect mac address

772
00:26:38,080 --> 00:26:40,480
is being sent the enabling switch will

773
00:26:40,480 --> 00:26:41,520
pass it on

774
00:26:41,520 --> 00:26:43,520
since it's not being identified as a cv

775
00:26:43,520 --> 00:26:45,840
packet

776
00:26:45,840 --> 00:26:48,640
if a packet is sent with a unicast or

777
00:26:48,640 --> 00:26:49,840
broadcast address

778
00:26:49,840 --> 00:26:51,760
it will be forwarded but not passed by

779
00:26:51,760 --> 00:26:53,200
the switch at all

780
00:26:53,200 --> 00:26:54,880
on the way to the target we found

781
00:26:54,880 --> 00:26:56,320
another block in this line

782
00:26:56,320 --> 00:26:59,360
of void phones it doesn't check the mac

783
00:26:59,360 --> 00:27:01,440
address when it parses cdp packets

784
00:27:01,440 --> 00:27:03,679
meaning that the malphone packet will be

785
00:27:03,679 --> 00:27:06,159
parsed as if it was a legitimate one

786
00:27:06,159 --> 00:27:08,799
this expands the possible attack targets

787
00:27:08,799 --> 00:27:10,880
to all of the cisco voice phones in the

788
00:27:10,880 --> 00:27:13,039
current plan

789
00:27:13,039 --> 00:27:14,880
to demonstrate this bug we can take a

790
00:27:14,880 --> 00:27:16,400
look at this graph

791
00:27:16,400 --> 00:27:18,799
showing the flow of a cdp packet inside

792
00:27:18,799 --> 00:27:20,960
the void phone the main things to look

793
00:27:20,960 --> 00:27:22,799
at to look at are the red part

794
00:27:22,799 --> 00:27:24,320
which is the function containing the

795
00:27:24,320 --> 00:27:25,840
stack overflow vulnerability

796
00:27:25,840 --> 00:27:27,919
and the green part which is the function

797
00:27:27,919 --> 00:27:31,360
in charge of packet validation

798
00:27:31,679 --> 00:27:33,360
it is the function that validates the

799
00:27:33,360 --> 00:27:35,279
cdp packet as we can see

800
00:27:35,279 --> 00:27:37,039
the only validation of the ethernet

801
00:27:37,039 --> 00:27:39,520
adder is of the source mac address and

802
00:27:39,520 --> 00:27:40,960
not the destination mac

803
00:27:40,960 --> 00:27:42,960
this means that any destination mac can

804
00:27:42,960 --> 00:27:44,720
be used including including

805
00:27:44,720 --> 00:27:47,600
unicast and broadcast once again this

806
00:27:47,600 --> 00:27:49,440
enables the attacker to attack any

807
00:27:49,440 --> 00:27:50,399
target in his

808
00:27:50,399 --> 00:27:53,279
in his local land

809
00:27:53,600 --> 00:27:55,840
as we've said these voips can be found

810
00:27:55,840 --> 00:27:57,360
in imposing places

811
00:27:57,360 --> 00:27:59,039
let's take a closer look at the

812
00:27:59,039 --> 00:28:01,520
exploitation process

813
00:28:01,520 --> 00:28:04,240
this iphone runs a linux system with

814
00:28:04,240 --> 00:28:04,960
busybox

815
00:28:04,960 --> 00:28:08,000
on a 32-bit arm processor it has aslr

816
00:28:08,000 --> 00:28:10,799
and nxbit on as we've seen before linux

817
00:28:10,799 --> 00:28:13,600
32-bit aslr randomizes only one byte

818
00:28:13,600 --> 00:28:15,279
with the top memory distance of one

819
00:28:15,279 --> 00:28:18,640
megabyte between two ace vlog options

820
00:28:18,640 --> 00:28:21,360
we will try polyrop for this offer to

821
00:28:21,360 --> 00:28:22,480
exploit but there are

822
00:28:22,480 --> 00:28:24,960
a few differences we need to consider

823
00:28:24,960 --> 00:28:27,360
first the addresses in arm are aligned

824
00:28:27,360 --> 00:28:29,120
it means that we can choose an address

825
00:28:29,120 --> 00:28:31,200
that will give a valid op code for all

826
00:28:31,200 --> 00:28:32,240
slr options

827
00:28:32,240 --> 00:28:35,600
second in r we also have the thumb mode

828
00:28:35,600 --> 00:28:38,159
as another alignment option if we look

829
00:28:38,159 --> 00:28:39,440
back at our x

830
00:28:39,440 --> 00:28:42,559
86 exploit the addresses are unaligned

831
00:28:42,559 --> 00:28:44,480
so we may not have a valid code for

832
00:28:44,480 --> 00:28:45,919
every slr option

833
00:28:45,919 --> 00:28:47,679
but we have more addresses to choose

834
00:28:47,679 --> 00:28:50,240
from in general it sounds like polyrop

835
00:28:50,240 --> 00:28:52,799
should be easier for this architect

836
00:28:52,799 --> 00:28:55,440
architecture

837
00:28:55,840 --> 00:28:58,559
our first attempt at rm32 polygroup is

838
00:28:58,559 --> 00:29:00,080
all about branching

839
00:29:00,080 --> 00:29:01,440
looking at the epilogue of the

840
00:29:01,440 --> 00:29:03,440
vulnerable function we see that the

841
00:29:03,440 --> 00:29:04,480
function ends with

842
00:29:04,480 --> 00:29:07,760
a pop of registers the stack pointer

843
00:29:07,760 --> 00:29:10,480
and the pc this is actually very bad

844
00:29:10,480 --> 00:29:11,440
since the stack

845
00:29:11,440 --> 00:29:13,520
is also as allowed meaning we can

846
00:29:13,520 --> 00:29:15,360
execute only one rope gadget

847
00:29:15,360 --> 00:29:17,600
because we don't know where the stack is

848
00:29:17,600 --> 00:29:19,279
but what can we do with just one drop

849
00:29:19,279 --> 00:29:21,679
gadget

850
00:29:21,679 --> 00:29:24,159
we thought of this idea we use that one

851
00:29:24,159 --> 00:29:26,240
gadget to branch to a register

852
00:29:26,240 --> 00:29:28,159
hopefully a different register for every

853
00:29:28,159 --> 00:29:29,360
slr option

854
00:29:29,360 --> 00:29:31,120
since we also overwrite the stack

855
00:29:31,120 --> 00:29:33,039
pointer the address we are going to

856
00:29:33,039 --> 00:29:34,000
branch to

857
00:29:34,000 --> 00:29:35,760
is the start function of the parsing

858
00:29:35,760 --> 00:29:37,679
thread essentially restarting the

859
00:29:37,679 --> 00:29:38,720
current thread

860
00:29:38,720 --> 00:29:41,120
but this time with a known stack address

861
00:29:41,120 --> 00:29:42,799
now that we know the stack address we

862
00:29:42,799 --> 00:29:44,480
can resend the exploit

863
00:29:44,480 --> 00:29:46,720
but this time with a longer polygroup

864
00:29:46,720 --> 00:29:50,480
since the stack address is known

865
00:29:50,799 --> 00:29:53,039
we found this branching multicartrid

866
00:29:53,039 --> 00:29:54,559
same as before the only difference

867
00:29:54,559 --> 00:29:55,679
between these gadgets

868
00:29:55,679 --> 00:29:58,080
at this gadget addresses is the byte

869
00:29:58,080 --> 00:29:59,520
that slr randomizes

870
00:29:59,520 --> 00:30:01,760
but each gadget branches to a different

871
00:30:01,760 --> 00:30:02,799
register making

872
00:30:02,799 --> 00:30:05,360
a great multi-gadget the first gadget

873
00:30:05,360 --> 00:30:06,960
branches to register seven

874
00:30:06,960 --> 00:30:08,880
the second one to register 4 and the

875
00:30:08,880 --> 00:30:12,559
third one to register 12.

876
00:30:12,559 --> 00:30:15,200
to sound this poly up attempt we use the

877
00:30:15,200 --> 00:30:17,360
multi gadget to branch to register

878
00:30:17,360 --> 00:30:19,919
a different register for each slr option

879
00:30:19,919 --> 00:30:21,679
the function we branch to

880
00:30:21,679 --> 00:30:23,919
is the thread start function and stack

881
00:30:23,919 --> 00:30:25,279
address is shifted

882
00:30:25,279 --> 00:30:27,520
to an absolute address now that we know

883
00:30:27,520 --> 00:30:28,559
the stack address

884
00:30:28,559 --> 00:30:30,640
we send another packet with a full poly

885
00:30:30,640 --> 00:30:32,799
option

886
00:30:32,799 --> 00:30:35,039
the main flaw of this method is that we

887
00:30:35,039 --> 00:30:36,799
are limited by the amount of popped

888
00:30:36,799 --> 00:30:37,520
registers

889
00:30:37,520 --> 00:30:39,360
and in reality we found an exploit that

890
00:30:39,360 --> 00:30:42,000
works only for five unique options

891
00:30:42,000 --> 00:30:46,080
hence polyurop m32 version two

892
00:30:46,080 --> 00:30:48,880
this time we use the same cv but don't

893
00:30:48,880 --> 00:30:51,360
overwrite the stack pointer or the pc

894
00:30:51,360 --> 00:30:53,279
we found that just by overwriting the

895
00:30:53,279 --> 00:30:55,440
registers with the correct values we get

896
00:30:55,440 --> 00:30:56,080
a relative

897
00:30:56,080 --> 00:30:58,640
right what well primitive and in the

898
00:30:58,640 --> 00:31:00,240
wise words of sar amar

899
00:31:00,240 --> 00:31:01,840
some people say that all you need is

900
00:31:01,840 --> 00:31:03,840
love this is a lie all you need is a

901
00:31:03,840 --> 00:31:05,679
relatively write primitive

902
00:31:05,679 --> 00:31:07,760
we are going to use the relative right

903
00:31:07,760 --> 00:31:08,799
in order to

904
00:31:08,799 --> 00:31:11,360
spray stack pivots that's not a stack

905
00:31:11,360 --> 00:31:11,840
spray

906
00:31:11,840 --> 00:31:14,399
we are literally going to spray stacks

907
00:31:14,399 --> 00:31:15,600
after we spray

908
00:31:15,600 --> 00:31:17,840
our relative stacks we will jump to an

909
00:31:17,840 --> 00:31:19,120
absolute address

910
00:31:19,120 --> 00:31:21,519
and let slr choose the correct stack for

911
00:31:21,519 --> 00:31:22,559
us

912
00:31:22,559 --> 00:31:24,399
we are going to explain this in more

913
00:31:24,399 --> 00:31:26,719
detail

914
00:31:28,240 --> 00:31:30,320
okay each column in the slide

915
00:31:30,320 --> 00:31:31,760
illustrates the memory space

916
00:31:31,760 --> 00:31:33,840
of the cdp process for a specific slr

917
00:31:33,840 --> 00:31:35,679
option and the three of the three

918
00:31:35,679 --> 00:31:37,600
options are four kilobytes apart

919
00:31:37,600 --> 00:31:39,919
in orange we have the absolute address

920
00:31:39,919 --> 00:31:41,200
of our new stack

921
00:31:41,200 --> 00:31:43,840
that's where we want our our opt chain

922
00:31:43,840 --> 00:31:46,799
to be

923
00:31:46,799 --> 00:31:48,640
we use the relative right primitive to

924
00:31:48,640 --> 00:31:51,039
write the drop chain for slr option 1.

925
00:31:51,039 --> 00:31:53,120
for slr option 1 it falls right on the

926
00:31:53,120 --> 00:31:54,559
address of the new stack

927
00:31:54,559 --> 00:31:57,279
for slr option 2 it's 4 kilobytes away

928
00:31:57,279 --> 00:31:59,440
and for slr option 3 it's 8 kilobytes

929
00:31:59,440 --> 00:32:01,519
away

930
00:32:01,519 --> 00:32:03,519
so we use the relative right to write

931
00:32:03,519 --> 00:32:05,440
the drop chain of slr option 2.

932
00:32:05,440 --> 00:32:07,679
since it's relative the drop chain for

933
00:32:07,679 --> 00:32:09,600
slot option 1 is untouched

934
00:32:09,600 --> 00:32:11,760
and now option 2 has the correct sll

935
00:32:11,760 --> 00:32:14,799
option in the correct place

936
00:32:14,799 --> 00:32:16,720
we use the relative right again this

937
00:32:16,720 --> 00:32:18,960
time writing the op chain for slr option

938
00:32:18,960 --> 00:32:19,840
3.

939
00:32:19,840 --> 00:32:22,559
now all we need to do is to overwrite

940
00:32:22,559 --> 00:32:23,840
the stack

941
00:32:23,840 --> 00:32:25,519
with the absolute address of the new

942
00:32:25,519 --> 00:32:27,760
stack that's the orange line

943
00:32:27,760 --> 00:32:29,519
and let aslr choose the correct drop

944
00:32:29,519 --> 00:32:31,919
chain for us

945
00:32:31,919 --> 00:32:34,720
to sum this up we now have an exploit

946
00:32:34,720 --> 00:32:36,799
that works for all asl options

947
00:32:36,799 --> 00:32:38,960
without crashing the device even once we

948
00:32:38,960 --> 00:32:42,559
just send 256 packets let's write the

949
00:32:42,559 --> 00:32:43,120
relative

950
00:32:43,120 --> 00:32:45,600
op chains one for each slr option and

951
00:32:45,600 --> 00:32:47,840
one packet that pivots the stack

952
00:32:47,840 --> 00:32:50,880
since this can be sent over multicast

953
00:32:50,880 --> 00:32:53,120
an attacker can use this to sit upon all

954
00:32:53,120 --> 00:32:54,559
cisco voips

955
00:32:54,559 --> 00:32:57,120
on the network in just one go we would

956
00:32:57,120 --> 00:32:57,919
like to mention

957
00:32:57,919 --> 00:32:59,760
that this polylop technique works for

958
00:32:59,760 --> 00:33:02,399
any exploitation of 32-bit aslr

959
00:33:02,399 --> 00:33:04,480
when the attacker has a relative right

960
00:33:04,480 --> 00:33:06,159
and a stack pivot primitive

961
00:33:06,159 --> 00:33:07,919
so we made a write paper for the

962
00:33:07,919 --> 00:33:09,360
specific technique

963
00:33:09,360 --> 00:33:11,200
and now i will pass the print the

964
00:33:11,200 --> 00:33:12,960
presentation to ben we'll show some

965
00:33:12,960 --> 00:33:16,320
demos of this exploitation

966
00:33:17,519 --> 00:33:20,240
okay so as barack mentioned we managed

967
00:33:20,240 --> 00:33:20,640
to

968
00:33:20,640 --> 00:33:24,000
exploit this with the bypass

969
00:33:24,000 --> 00:33:27,120
of the aslr um and we're gonna show a

970
00:33:27,120 --> 00:33:28,240
demo of this

971
00:33:28,240 --> 00:33:31,120
but first uh when we come to exploiting

972
00:33:31,120 --> 00:33:31,760
a voip

973
00:33:31,760 --> 00:33:34,159
phone uh we need to think what can we do

974
00:33:34,159 --> 00:33:35,279
with a voip phone

975
00:33:35,279 --> 00:33:38,320
and obviously uh first of all it's a

976
00:33:38,320 --> 00:33:39,760
phone so it contains

977
00:33:39,760 --> 00:33:43,760
audio of calls but it also has a screen

978
00:33:43,760 --> 00:33:46,480
and it has a keypad so actually the next

979
00:33:46,480 --> 00:33:46,799
step

980
00:33:46,799 --> 00:33:51,600
is we want to run doom on it

981
00:33:51,600 --> 00:33:54,000
so let's say let's see how this is done

982
00:33:54,000 --> 00:33:57,039
in this next demo

983
00:34:00,480 --> 00:34:02,640
okay so on the left we have the hacker

984
00:34:02,640 --> 00:34:04,559
terminal and on the bottom left we'll

985
00:34:04,559 --> 00:34:07,200
see the audio recording

986
00:34:07,200 --> 00:34:10,159
of whatever the hacker is recording on

987
00:34:10,159 --> 00:34:11,520
the phone

988
00:34:11,520 --> 00:34:15,199
um there is a phone call taking place or

989
00:34:15,199 --> 00:34:16,800
is this there is something to record and

990
00:34:16,800 --> 00:34:17,839
then the attack

991
00:34:17,839 --> 00:34:21,520
starts we send this unicast

992
00:34:21,520 --> 00:34:24,639
exploit in this example uh and we can

993
00:34:24,639 --> 00:34:25,440
also see

994
00:34:25,440 --> 00:34:27,760
that the the attacker is able to blink

995
00:34:27,760 --> 00:34:28,960
the leds

996
00:34:28,960 --> 00:34:32,639
and record the ongoing call upload it

997
00:34:32,639 --> 00:34:35,679
back to his machine

998
00:34:35,679 --> 00:34:37,918
and then we will see that he is able to

999
00:34:37,918 --> 00:34:39,199
listen in on

1000
00:34:39,199 --> 00:34:41,839
the conversation

1001
00:34:44,000 --> 00:34:47,119
and now the fun part so we take over the

1002
00:34:47,119 --> 00:34:48,239
screen of the device

1003
00:34:48,239 --> 00:34:51,599
we upload doom to it and we start the

1004
00:34:51,599 --> 00:34:52,159
doom

1005
00:34:52,159 --> 00:34:55,919
game and now we can see

1006
00:34:56,000 --> 00:34:58,160
the skills of whatever whoever is

1007
00:34:58,160 --> 00:35:03,839
playing down here

1008
00:35:11,280 --> 00:35:14,000
um okay lastly we can see that selling

1009
00:35:14,000 --> 00:35:16,640
this broadcast cp packet will crash all

1010
00:35:16,640 --> 00:35:18,560
of these devices simultaneously

1011
00:35:18,560 --> 00:35:22,320
uh we didn't show those here but um

1012
00:35:22,320 --> 00:35:24,480
using the same exploits that we started

1013
00:35:24,480 --> 00:35:25,920
with we can also

1014
00:35:25,920 --> 00:35:29,359
do this broadcast aslr bypass integ

1015
00:35:29,359 --> 00:35:30,800
take over all of these voips

1016
00:35:30,800 --> 00:35:33,359
simultaneously

1017
00:35:33,359 --> 00:35:36,880
okay um so

1018
00:35:36,880 --> 00:35:39,599
another thing to know that a couple of

1019
00:35:39,599 --> 00:35:40,240
months after

1020
00:35:40,240 --> 00:35:43,760
we we published this research

1021
00:35:43,760 --> 00:35:47,119
there were a few other cvs that were

1022
00:35:47,119 --> 00:35:49,040
discovered in cdp

1023
00:35:49,040 --> 00:35:50,880
and this is something that happens from

1024
00:35:50,880 --> 00:35:52,400
time to time one

1025
00:35:52,400 --> 00:35:53,920
researcher comes in finds

1026
00:35:53,920 --> 00:35:55,599
vulnerabilities and this

1027
00:35:55,599 --> 00:35:57,359
marks the way to other researchers there

1028
00:35:57,359 --> 00:35:59,760
is a potential here for vulnerabilities

1029
00:35:59,760 --> 00:36:04,640
um and so we this is this brings us to

1030
00:36:04,640 --> 00:36:08,560
the takeaways from this talk that

1031
00:36:08,560 --> 00:36:10,640
the purpose of this research as i said

1032
00:36:10,640 --> 00:36:12,560
in the beginning was to tackle

1033
00:36:12,560 --> 00:36:15,520
network segmentation and as we saw it

1034
00:36:15,520 --> 00:36:17,440
isn't bulletproof

1035
00:36:17,440 --> 00:36:19,040
vulnerabilities can be found in it we

1036
00:36:19,040 --> 00:36:20,640
found five of these

1037
00:36:20,640 --> 00:36:22,960
and then four more found a couple of

1038
00:36:22,960 --> 00:36:24,640
months later in cdp

1039
00:36:24,640 --> 00:36:27,119
and the attack surface is quite large so

1040
00:36:27,119 --> 00:36:28,160
there may be other

1041
00:36:28,160 --> 00:36:32,079
vulnerabilities that exist here um

1042
00:36:32,079 --> 00:36:35,119
second um laser layer two particles are

1043
00:36:35,119 --> 00:36:35,440
an

1044
00:36:35,440 --> 00:36:37,760
untapped attack surface the fact that we

1045
00:36:37,760 --> 00:36:38,960
found five voltages

1046
00:36:38,960 --> 00:36:41,440
um and then four more were found a

1047
00:36:41,440 --> 00:36:42,720
couple of months later

1048
00:36:42,720 --> 00:36:45,520
it seems that this attack surface is

1049
00:36:45,520 --> 00:36:46,720
ripe and there are

1050
00:36:46,720 --> 00:36:48,320
other vulnerabilities that may be found

1051
00:36:48,320 --> 00:36:50,400
here um

1052
00:36:50,400 --> 00:36:53,200
third thing is what we saw in poliwap

1053
00:36:53,200 --> 00:36:55,520
aslr is not

1054
00:36:55,520 --> 00:36:58,800
perfect when it comes to 32 bit linux

1055
00:36:58,800 --> 00:37:02,079
and so even when mitigations are used

1056
00:37:02,079 --> 00:37:04,160
you should use them in the correct way

1057
00:37:04,160 --> 00:37:07,599
or in a very hardened way

1058
00:37:07,599 --> 00:37:09,839
and lastly but most importantly uh

1059
00:37:09,839 --> 00:37:12,000
running doom on a cisco voip is probably

1060
00:37:12,000 --> 00:37:13,760
the best use of a conference room and we

1061
00:37:13,760 --> 00:37:15,760
really recommend it

1062
00:37:15,760 --> 00:37:17,520
and we some have some time for questions

1063
00:37:17,520 --> 00:37:19,200
now and

1064
00:37:19,200 --> 00:37:21,760
we'd be happy to to take your questions

1065
00:37:21,760 --> 00:37:25,280
thank you

