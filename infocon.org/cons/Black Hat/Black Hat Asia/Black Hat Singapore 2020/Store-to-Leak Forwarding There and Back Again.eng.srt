1
00:00:00,799 --> 00:00:02,800
so welcome everyone to our presentation

2
00:00:02,800 --> 00:00:03,760
today

3
00:00:03,760 --> 00:00:05,440
we are going to present star to league

4
00:00:05,440 --> 00:00:07,440
forwarding there and back again

5
00:00:07,440 --> 00:00:09,920
um my name is claudio canella i'm a phd

6
00:00:09,920 --> 00:00:11,120
student at guards university of

7
00:00:11,120 --> 00:00:11,920
technology

8
00:00:11,920 --> 00:00:13,679
you can also find me on twitter or send

9
00:00:13,679 --> 00:00:16,640
me an email if you have any questions

10
00:00:16,640 --> 00:00:18,720
my name is lucas gina i'm also a ph.d

11
00:00:18,720 --> 00:00:19,840
student in graz

12
00:00:19,840 --> 00:00:21,439
don't be thrown off by the shirt some

13
00:00:21,439 --> 00:00:23,519
below this later you're exactly where

14
00:00:23,519 --> 00:00:24,480
you're meant to be

15
00:00:24,480 --> 00:00:26,800
and my name is michael schwarz i'm a

16
00:00:26,800 --> 00:00:27,760
faculty at

17
00:00:27,760 --> 00:00:29,599
sisbe helmholtz center for information

18
00:00:29,599 --> 00:00:30,880
security

19
00:00:30,880 --> 00:00:33,600
and you can reach all of us on twitter

20
00:00:33,600 --> 00:00:36,239
via email if you have any more questions

21
00:00:36,239 --> 00:00:39,600
more than you could ask after this talk

22
00:00:39,600 --> 00:00:42,800
so what is this talk about

23
00:00:42,800 --> 00:00:46,079
so we want to figure out in this talk

24
00:00:46,079 --> 00:00:48,399
how stores and loads are handled on

25
00:00:48,399 --> 00:00:50,160
modern micro architectures

26
00:00:50,160 --> 00:00:52,239
what happens if we load a value from a

27
00:00:52,239 --> 00:00:54,239
location where we previously

28
00:00:54,239 --> 00:00:56,719
stored some value we also want to look

29
00:00:56,719 --> 00:00:58,719
at the meltdown mitigations

30
00:00:58,719 --> 00:01:01,120
and see what they changed in this store

31
00:01:01,120 --> 00:01:01,760
and load

32
00:01:01,760 --> 00:01:05,119
path in the micro architecture and see

33
00:01:05,119 --> 00:01:07,119
whether we can figure out some new

34
00:01:07,119 --> 00:01:08,479
mechanisms from that

35
00:01:08,479 --> 00:01:11,840
that allows for some new

36
00:01:11,840 --> 00:01:14,000
and of course we also want to mitigate

37
00:01:14,000 --> 00:01:15,520
those attacks that we find

38
00:01:15,520 --> 00:01:18,080
so we'll also talk about some clever

39
00:01:18,080 --> 00:01:21,039
mitigations here

40
00:01:21,759 --> 00:01:23,840
okay so first we need a bit of

41
00:01:23,840 --> 00:01:25,040
background

42
00:01:25,040 --> 00:01:26,799
so the manual model you can have as a

43
00:01:26,799 --> 00:01:28,159
programmer from the cpu

44
00:01:28,159 --> 00:01:31,280
is fairly simple so instructions are

45
00:01:31,280 --> 00:01:33,119
executed in program order just as you

46
00:01:33,119 --> 00:01:35,280
expect just as you write them down

47
00:01:35,280 --> 00:01:37,360
the pipeline stalls when the stage is

48
00:01:37,360 --> 00:01:38,799
not ready

49
00:01:38,799 --> 00:01:41,040
and if data isn't available we also have

50
00:01:41,040 --> 00:01:42,399
to wait

51
00:01:42,399 --> 00:01:45,600
so this can look something like this

52
00:01:45,600 --> 00:01:48,640
where we first fetch into the l1

53
00:01:48,640 --> 00:01:50,159
instruction cache

54
00:01:50,159 --> 00:01:53,200
we decode the instructions then we

55
00:01:53,200 --> 00:01:54,799
execute them

56
00:01:54,799 --> 00:01:58,000
if necessary we access that we perform

57
00:01:58,000 --> 00:01:59,680
accesses to memory

58
00:01:59,680 --> 00:02:02,240
and finally we write back into the

59
00:02:02,240 --> 00:02:05,119
architectural register file

60
00:02:05,119 --> 00:02:07,040
i always thought that microarchitectures

61
00:02:07,040 --> 00:02:08,160
are much more complex

62
00:02:08,160 --> 00:02:11,360
than that well that is a very simple

63
00:02:11,360 --> 00:02:13,120
micro architecture

64
00:02:13,120 --> 00:02:15,840
and in general in modern architectures

65
00:02:15,840 --> 00:02:17,280
you want more performance

66
00:02:17,280 --> 00:02:20,319
and more performance means super scalar

67
00:02:20,319 --> 00:02:22,640
and superscalar means that we do loads

68
00:02:22,640 --> 00:02:24,560
of things in parallel

69
00:02:24,560 --> 00:02:26,560
so the question here is if we don't have

70
00:02:26,560 --> 00:02:28,239
a dependency between

71
00:02:28,239 --> 00:02:30,640
different instructions and we have many

72
00:02:30,640 --> 00:02:32,480
execution ports available

73
00:02:32,480 --> 00:02:33,760
why don't we do loads of things in

74
00:02:33,760 --> 00:02:35,519
parallel

75
00:02:35,519 --> 00:02:39,440
so we execute them in whatever order is

76
00:02:39,440 --> 00:02:42,640
is convenient and supports are available

77
00:02:42,640 --> 00:02:45,200
and importantly we retire them in the

78
00:02:45,200 --> 00:02:46,959
order that they're in the program

79
00:02:46,959 --> 00:02:48,480
so from the outside from programmer's

80
00:02:48,480 --> 00:02:51,519
view everything still stays the same

81
00:02:51,519 --> 00:02:54,959
so now an interesting situation is when

82
00:02:54,959 --> 00:02:56,239
a fault happens

83
00:02:56,239 --> 00:02:59,440
and there are already newer instructions

84
00:02:59,440 --> 00:03:01,120
in flight that are already calculating

85
00:03:01,120 --> 00:03:03,519
on data what do we do with them

86
00:03:03,519 --> 00:03:06,640
so for this the processor tracks

87
00:03:06,640 --> 00:03:08,319
the architectural changes that

88
00:03:08,319 --> 00:03:09,840
instructions would make

89
00:03:09,840 --> 00:03:12,400
and if there is a fault it undoes the

90
00:03:12,400 --> 00:03:14,400
out-of-order effects

91
00:03:14,400 --> 00:03:16,840
and we then call those instructions

92
00:03:16,840 --> 00:03:18,319
transient

93
00:03:18,319 --> 00:03:22,159
that's pretty smart yeah it is

94
00:03:22,159 --> 00:03:23,760
and those transient instructions don't

95
00:03:23,760 --> 00:03:25,280
leave any architectural trace

96
00:03:25,280 --> 00:03:28,560
they're basically gone so at this point

97
00:03:28,560 --> 00:03:30,239
you might wonder

98
00:03:30,239 --> 00:03:32,480
if they don't if they're undone if they

99
00:03:32,480 --> 00:03:34,560
don't leave any trace

100
00:03:34,560 --> 00:03:36,239
what are they even for what's the point

101
00:03:36,239 --> 00:03:37,920
of them or what can we do with them

102
00:03:37,920 --> 00:03:40,720
more as an attacker and so i said

103
00:03:40,720 --> 00:03:42,080
remember i said

104
00:03:42,080 --> 00:03:44,080
the processor tracks the architectural

105
00:03:44,080 --> 00:03:46,000
changes and reverts those

106
00:03:46,000 --> 00:03:49,360
it does not track microarchitectural

107
00:03:49,360 --> 00:03:54,080
changes so we can encode data

108
00:03:54,080 --> 00:03:56,159
that we calculate during uh transient

109
00:03:56,159 --> 00:03:57,280
execution

110
00:03:57,280 --> 00:04:00,640
into a microarchitectural state

111
00:04:00,640 --> 00:04:01,680
do you have an example for

112
00:04:01,680 --> 00:04:03,599
microarchitectural state yes i don't

113
00:04:03,599 --> 00:04:04,799
know what you're talking about

114
00:04:04,799 --> 00:04:06,959
yes i do one of those stateful

115
00:04:06,959 --> 00:04:09,040
microarchitectural elements

116
00:04:09,040 --> 00:04:12,400
is the cache that's a simple way

117
00:04:12,400 --> 00:04:15,519
and so ah the state in the cache is

118
00:04:15,519 --> 00:04:18,478
if a cache line is present or not and so

119
00:04:18,478 --> 00:04:20,478
let's have a look at an example

120
00:04:20,478 --> 00:04:22,639
we access a variable and try to load it

121
00:04:22,639 --> 00:04:24,080
into a register

122
00:04:24,080 --> 00:04:26,000
and so the first time we try this the

123
00:04:26,000 --> 00:04:28,800
cpu will have a miss and it will have to

124
00:04:28,800 --> 00:04:29,919
load from ram

125
00:04:29,919 --> 00:04:32,160
we'll get a response and it will be

126
00:04:32,160 --> 00:04:33,600
cached at that point

127
00:04:33,600 --> 00:04:36,639
and the next time we try this slow yeah

128
00:04:36,639 --> 00:04:38,960
and the next time we try this we get a

129
00:04:38,960 --> 00:04:40,840
cache hit

130
00:04:40,840 --> 00:04:43,759
and that'll be much faster

131
00:04:43,759 --> 00:04:47,280
so the dramax is very slow the non-drm

132
00:04:47,280 --> 00:04:48,240
the cached access

133
00:04:48,240 --> 00:04:50,960
no surprise here it's much faster and

134
00:04:50,960 --> 00:04:52,160
this difference is

135
00:04:52,160 --> 00:04:55,440
very very clear and we can determine

136
00:04:55,440 --> 00:04:57,360
this with high reliability

137
00:04:57,360 --> 00:04:59,040
so in the future of this talk when we

138
00:04:59,040 --> 00:05:01,919
talk about transient

139
00:05:01,919 --> 00:05:05,039
transient instructions and their effects

140
00:05:05,039 --> 00:05:07,199
this is how we generally see them

141
00:05:07,199 --> 00:05:08,560
architecturally how we

142
00:05:08,560 --> 00:05:10,320
make use of them we encode them in the

143
00:05:10,320 --> 00:05:12,639
cache

144
00:05:12,880 --> 00:05:15,680
so when we look when we look at the how

145
00:05:15,680 --> 00:05:17,120
core is made up we've talked a bit about

146
00:05:17,120 --> 00:05:19,280
the execution engine the front end

147
00:05:19,280 --> 00:05:22,720
so what's left is the memory subsystem

148
00:05:22,720 --> 00:05:24,800
and so here first we have a load buffer

149
00:05:24,800 --> 00:05:25,759
and the store buffer

150
00:05:25,759 --> 00:05:27,199
connected to the load ports and the

151
00:05:27,199 --> 00:05:29,759
store ports in the execution engine

152
00:05:29,759 --> 00:05:31,680
as a next level we have the l1 data

153
00:05:31,680 --> 00:05:33,520
cache with a

154
00:05:33,520 --> 00:05:36,720
tlb and light field buffer with a second

155
00:05:36,720 --> 00:05:38,000
level with the l2 cache

156
00:05:38,000 --> 00:05:40,880
and another tlb and then off core we

157
00:05:40,880 --> 00:05:42,080
have the l3 cache

158
00:05:42,080 --> 00:05:44,320
and the ram finally and so these three

159
00:05:44,320 --> 00:05:46,639
caches are what we can use as just that

160
00:05:46,639 --> 00:05:49,680
to encode our transient uh our transient

161
00:05:49,680 --> 00:05:51,280
data

162
00:05:51,280 --> 00:05:56,000
so wow that that looks complicated

163
00:05:56,000 --> 00:05:58,960
yeah so why don't you tell us a bit more

164
00:05:58,960 --> 00:06:01,039
about the store buffer

165
00:06:01,039 --> 00:06:04,080
okay so let's see what actually happens

166
00:06:04,080 --> 00:06:07,199
if we have some data stores and data

167
00:06:07,199 --> 00:06:08,240
loads

168
00:06:08,240 --> 00:06:10,160
that we are executing that has to go

169
00:06:10,160 --> 00:06:11,919
through all this machinery you just

170
00:06:11,919 --> 00:06:13,520
explained before

171
00:06:13,520 --> 00:06:16,720
so if we move some data to the memory

172
00:06:16,720 --> 00:06:19,199
so if we store some data then what

173
00:06:19,199 --> 00:06:20,960
happens is that in the execution

174
00:06:20,960 --> 00:06:23,680
unit we have the store operation it has

175
00:06:23,680 --> 00:06:25,759
to store some data and for that it uses

176
00:06:25,759 --> 00:06:26,720
the store buffer

177
00:06:26,720 --> 00:06:29,199
the store buffer helps that it does not

178
00:06:29,199 --> 00:06:31,039
have to wait for the store to actually

179
00:06:31,039 --> 00:06:31,680
complete

180
00:06:31,680 --> 00:06:33,840
it just throws it in there and then the

181
00:06:33,840 --> 00:06:34,960
store buffer handles

182
00:06:34,960 --> 00:06:38,080
the rest of it and the store buffer

183
00:06:38,080 --> 00:06:40,880
then can go to the l1 store the data in

184
00:06:40,880 --> 00:06:43,440
the l1 if there's space in l1

185
00:06:43,440 --> 00:06:45,919
and in the meantime the execution unit

186
00:06:45,919 --> 00:06:46,960
can already

187
00:06:46,960 --> 00:06:48,720
continue with some other instruction

188
00:06:48,720 --> 00:06:50,720
you've said that before with this out of

189
00:06:50,720 --> 00:06:52,880
order execution

190
00:06:52,880 --> 00:06:56,080
so now we do something maybe stupid

191
00:06:56,080 --> 00:06:58,880
we write some data to memory and then

192
00:06:58,880 --> 00:07:00,479
immediately afterwards

193
00:07:00,479 --> 00:07:02,479
we read from this memory address the

194
00:07:02,479 --> 00:07:04,240
data back that we just wrote

195
00:07:04,240 --> 00:07:06,720
we of course know what this data is but

196
00:07:06,720 --> 00:07:09,039
what does the cpu do

197
00:07:09,039 --> 00:07:12,160
so the cpu for loading a data it uses

198
00:07:12,160 --> 00:07:14,800
this low data part in the execution unit

199
00:07:14,800 --> 00:07:17,360
and it uses a load buffer where it also

200
00:07:17,360 --> 00:07:19,039
has a kind of a queue

201
00:07:19,039 --> 00:07:22,000
which stores what values to load and it

202
00:07:22,000 --> 00:07:23,199
knows this address

203
00:07:23,199 --> 00:07:25,919
it has to load that and usually it would

204
00:07:25,919 --> 00:07:26,639
go

205
00:07:26,639 --> 00:07:29,520
to the l1 memory check that l1 memory is

206
00:07:29,520 --> 00:07:30,000
this data

207
00:07:30,000 --> 00:07:32,800
there if there's a hit then retrieve it

208
00:07:32,800 --> 00:07:34,800
otherwise go to the l2 l3

209
00:07:34,800 --> 00:07:38,000
or dram but the thing is

210
00:07:38,000 --> 00:07:41,039
cpus are quite smart nowadays

211
00:07:41,039 --> 00:07:44,879
so what this additionally does it checks

212
00:07:44,879 --> 00:07:48,160
whether somebody some address was

213
00:07:48,160 --> 00:07:48,720
already

214
00:07:48,720 --> 00:07:51,039
stored before some data stored to the

215
00:07:51,039 --> 00:07:52,800
same address so if there's a match

216
00:07:52,800 --> 00:07:54,639
between the store address and the

217
00:07:54,639 --> 00:07:56,160
address that we load

218
00:07:56,160 --> 00:07:58,240
we can do a shortcut we don't have to

219
00:07:58,240 --> 00:07:59,440
wait for the memory

220
00:07:59,440 --> 00:08:01,759
so we directly take it from the store

221
00:08:01,759 --> 00:08:02,479
buffer

222
00:08:02,479 --> 00:08:05,039
and do the store to load forwarding to

223
00:08:05,039 --> 00:08:06,080
this load

224
00:08:06,080 --> 00:08:09,360
so this is a lot faster so we have this

225
00:08:09,360 --> 00:08:11,759
this data that goes there into the

226
00:08:11,759 --> 00:08:13,440
execution unit memory substance

227
00:08:13,440 --> 00:08:16,240
subsystem and then back again before it

228
00:08:16,240 --> 00:08:16,560
even

229
00:08:16,560 --> 00:08:19,759
reaches the memory subsystem that the l1

230
00:08:19,759 --> 00:08:23,840
or l2 so this makes it a lot faster

231
00:08:23,840 --> 00:08:26,400
and is a nice optimization that we have

232
00:08:26,400 --> 00:08:28,720
in modern cpus

233
00:08:28,720 --> 00:08:31,840
of course we can optimize that further

234
00:08:31,840 --> 00:08:33,839
so we don't have to check for a full

235
00:08:33,839 --> 00:08:36,399
match we can optimize that even

236
00:08:36,399 --> 00:08:40,000
more so we can do something like a

237
00:08:40,000 --> 00:08:41,839
normal comparison

238
00:08:41,839 --> 00:08:44,240
and if it's true we do the forwarding

239
00:08:44,240 --> 00:08:45,120
and this can be

240
00:08:45,120 --> 00:08:49,040
okay so it's true positive everything

241
00:08:49,040 --> 00:08:51,040
happens as it should we only forward the

242
00:08:51,040 --> 00:08:53,360
things that actually match

243
00:08:53,360 --> 00:08:55,839
maybe we also have some errors in the

244
00:08:55,839 --> 00:08:57,519
comparison there because things go

245
00:08:57,519 --> 00:08:58,720
really fast

246
00:08:58,720 --> 00:09:00,800
and we might have other stores and loads

247
00:09:00,800 --> 00:09:02,160
in between

248
00:09:02,160 --> 00:09:04,640
so maybe we also have some true

249
00:09:04,640 --> 00:09:06,000
negatives

250
00:09:06,000 --> 00:09:09,600
where we don't have some uh

251
00:09:09,600 --> 00:09:12,320
something there and we're also not we're

252
00:09:12,320 --> 00:09:13,519
not matching anything

253
00:09:13,519 --> 00:09:14,959
we're not forwarding anything this is

254
00:09:14,959 --> 00:09:18,080
also fine that's true negatives

255
00:09:18,080 --> 00:09:20,880
and this is basically all true positives

256
00:09:20,880 --> 00:09:22,560
and true negatives that we

257
00:09:22,560 --> 00:09:25,839
exploit in this talk here wait a second

258
00:09:25,839 --> 00:09:27,519
that sounds familiar isn't there a

259
00:09:27,519 --> 00:09:29,440
second attack that does

260
00:09:29,440 --> 00:09:32,800
exactly the same isn't there fallout

261
00:09:32,800 --> 00:09:35,440
yes because these are not the only two

262
00:09:35,440 --> 00:09:37,040
cases in the store buffer

263
00:09:37,040 --> 00:09:40,080
we can also have some let's say kind of

264
00:09:40,080 --> 00:09:42,720
errors or optimizations in there

265
00:09:42,720 --> 00:09:45,839
like false positives so we have

266
00:09:45,839 --> 00:09:48,560
addresses that are actually not the same

267
00:09:48,560 --> 00:09:50,720
but the data is forwarded

268
00:09:50,720 --> 00:09:54,080
so this one is exploited in fallout

269
00:09:54,080 --> 00:09:57,760
but already fixed in modern cpus

270
00:09:57,760 --> 00:10:00,080
and then also the other direction like

271
00:10:00,080 --> 00:10:01,279
false negatives

272
00:10:01,279 --> 00:10:03,120
the address is actually the same it

273
00:10:03,120 --> 00:10:04,880
should forward the data

274
00:10:04,880 --> 00:10:07,760
but it doesn't do so and this effect is

275
00:10:07,760 --> 00:10:08,480
exploited

276
00:10:08,480 --> 00:10:11,600
inspector stl

277
00:10:11,600 --> 00:10:15,279
so all these store buffer magic in there

278
00:10:15,279 --> 00:10:17,440
are optimizations for the transient

279
00:10:17,440 --> 00:10:18,480
execution

280
00:10:18,480 --> 00:10:20,959
so for the parts we don't see if this

281
00:10:20,959 --> 00:10:22,560
optimization is wrong

282
00:10:22,560 --> 00:10:25,920
architecturally we don't care because

283
00:10:25,920 --> 00:10:27,920
everything is undone as luke has

284
00:10:27,920 --> 00:10:30,719
explained before

285
00:10:30,959 --> 00:10:34,480
so we will never see that and our attack

286
00:10:34,480 --> 00:10:35,360
here

287
00:10:35,360 --> 00:10:37,920
just relies on the store buffer to do

288
00:10:37,920 --> 00:10:38,720
everything

289
00:10:38,720 --> 00:10:41,440
correctly so correct matching correct

290
00:10:41,440 --> 00:10:42,320
forwarding

291
00:10:42,320 --> 00:10:46,160
on the same addresses

292
00:10:46,160 --> 00:10:48,240
interesting part here that we are going

293
00:10:48,240 --> 00:10:49,680
to exploit

294
00:10:49,680 --> 00:10:53,279
is that stores can only be forwarded

295
00:10:53,279 --> 00:10:56,480
if we store something to a valid address

296
00:10:56,480 --> 00:10:58,800
of course that sounds kind of intuitive

297
00:10:58,800 --> 00:11:00,320
we can't store somewhere

298
00:11:00,320 --> 00:11:03,120
that's not a valid location so this is

299
00:11:03,120 --> 00:11:04,079
also described

300
00:11:04,079 --> 00:11:06,880
in the intel manual so it says like the

301
00:11:06,880 --> 00:11:08,560
store execution phase

302
00:11:08,560 --> 00:11:10,399
it fills the store buffer with linear

303
00:11:10,399 --> 00:11:12,320
and physical address and data

304
00:11:12,320 --> 00:11:15,040
and one store address and data are known

305
00:11:15,040 --> 00:11:16,160
the store data

306
00:11:16,160 --> 00:11:18,000
can be forwarded to the following load

307
00:11:18,000 --> 00:11:19,760
operations that need it

308
00:11:19,760 --> 00:11:22,160
so if everything is known then we can

309
00:11:22,160 --> 00:11:22,880
forward

310
00:11:22,880 --> 00:11:26,959
this data to them to the load

311
00:11:26,959 --> 00:11:29,519
and what does it mean with valid and

312
00:11:29,519 --> 00:11:30,480
invalid

313
00:11:30,480 --> 00:11:32,800
a virtual address that has an actual

314
00:11:32,800 --> 00:11:34,480
physical backing to it

315
00:11:34,480 --> 00:11:37,279
so we have some data page where we can

316
00:11:37,279 --> 00:11:38,720
really write to it

317
00:11:38,720 --> 00:11:41,760
then this is a valid address and then we

318
00:11:41,760 --> 00:11:42,399
can

319
00:11:42,399 --> 00:11:45,440
use that the interesting thing that we

320
00:11:45,440 --> 00:11:47,600
already know from meltdown

321
00:11:47,600 --> 00:11:50,800
is that permission checks on intel cpus

322
00:11:50,800 --> 00:11:54,079
are a bit lazy and they're not done

323
00:11:54,079 --> 00:11:56,480
up front but at some point in between

324
00:11:56,480 --> 00:11:58,399
when we already do that

325
00:11:58,399 --> 00:12:00,240
so that's what that was exploited in a

326
00:12:00,240 --> 00:12:02,480
meltdown attack

327
00:12:02,480 --> 00:12:06,079
and we want to exploit the same thing

328
00:12:06,079 --> 00:12:07,839
what happens with distort load

329
00:12:07,839 --> 00:12:10,560
forwarding when we store some data to an

330
00:12:10,560 --> 00:12:11,120
address

331
00:12:11,120 --> 00:12:14,959
and then read it back but this address

332
00:12:14,959 --> 00:12:17,839
is inaccessible so it's still valid

333
00:12:17,839 --> 00:12:19,760
there's a physical page behind it

334
00:12:19,760 --> 00:12:21,839
but maybe it belongs to the kernel so we

335
00:12:21,839 --> 00:12:23,200
couldn't access it

336
00:12:23,200 --> 00:12:26,800
does this mechanism still trigger

337
00:12:26,800 --> 00:12:29,839
so let's try it's not that difficult we

338
00:12:29,839 --> 00:12:31,120
write some value

339
00:12:31,120 --> 00:12:33,600
onto our kernel address that of course

340
00:12:33,600 --> 00:12:36,160
gives us a fault segmentation fault

341
00:12:36,160 --> 00:12:39,200
but out of order execution instructions

342
00:12:39,200 --> 00:12:41,040
are still executed

343
00:12:41,040 --> 00:12:43,680
so in this out of order execution we

344
00:12:43,680 --> 00:12:44,160
read

345
00:12:44,160 --> 00:12:46,480
the same address back and code it in the

346
00:12:46,480 --> 00:12:49,120
cache as lucas explained before

347
00:12:49,120 --> 00:12:52,720
and see if we get the same value back

348
00:12:52,720 --> 00:12:56,079
if so we know that the store to load

349
00:12:56,079 --> 00:12:58,079
forwarding that's actually working

350
00:12:58,079 --> 00:13:00,800
although there was a fault so that's

351
00:13:00,800 --> 00:13:01,839
nice no but

352
00:13:01,839 --> 00:13:03,360
what does that get us what can we do

353
00:13:03,360 --> 00:13:05,200
with this

354
00:13:05,200 --> 00:13:08,079
that's a good question i bet you've

355
00:13:08,079 --> 00:13:09,200
heard about

356
00:13:09,200 --> 00:13:11,920
address-based layout randomization

357
00:13:11,920 --> 00:13:13,440
especially in the kernel

358
00:13:13,440 --> 00:13:15,279
we have that so we randomize all the

359
00:13:15,279 --> 00:13:17,040
parts in the kernel the modules

360
00:13:17,040 --> 00:13:19,760
and the kernel image and every time we

361
00:13:19,760 --> 00:13:20,399
put

362
00:13:20,399 --> 00:13:21,839
it's at a different location so the

363
00:13:21,839 --> 00:13:23,519
modules that are different locations the

364
00:13:23,519 --> 00:13:24,800
kernel image this is a different

365
00:13:24,800 --> 00:13:25,839
location

366
00:13:25,839 --> 00:13:28,560
so we don't know where the kernel is and

367
00:13:28,560 --> 00:13:29,600
so we can't

368
00:13:29,600 --> 00:13:31,839
mount reliable attacks on the kernel

369
00:13:31,839 --> 00:13:32,959
because we don't

370
00:13:32,959 --> 00:13:36,079
know where this the image and the data

371
00:13:36,079 --> 00:13:38,959
is located

372
00:13:38,959 --> 00:13:42,000
okay but with this like this explanation

373
00:13:42,000 --> 00:13:42,880
i can

374
00:13:42,880 --> 00:13:44,959
i think i know what your attack is that

375
00:13:44,959 --> 00:13:45,920
you want to do

376
00:13:45,920 --> 00:13:48,639
so i think it's called data bound we can

377
00:13:48,639 --> 00:13:50,240
see here we have again a memory

378
00:13:50,240 --> 00:13:51,760
subsystem with the store buffer and the

379
00:13:51,760 --> 00:13:53,680
load buffer we have a little bit of code

380
00:13:53,680 --> 00:13:54,639
and the blue

381
00:13:54,639 --> 00:13:56,880
square here indicates the location of

382
00:13:56,880 --> 00:13:57,680
the kernel

383
00:13:57,680 --> 00:14:01,040
within memory and mem here is just an

384
00:14:01,040 --> 00:14:02,639
array where we store

385
00:14:02,639 --> 00:14:05,839
data and if we time this right now

386
00:14:05,839 --> 00:14:08,320
using the primitive that lucas told us

387
00:14:08,320 --> 00:14:09,120
then

388
00:14:09,120 --> 00:14:10,880
we just see the timing is always the

389
00:14:10,880 --> 00:14:12,639
same because we need to fetch it from

390
00:14:12,639 --> 00:14:16,800
dram right so now what we do with this

391
00:14:16,800 --> 00:14:18,800
stored load forwarding logic is we

392
00:14:18,800 --> 00:14:21,360
simply write to a kernel address

393
00:14:21,360 --> 00:14:24,079
some value in our case the value x and

394
00:14:24,079 --> 00:14:25,680
later on dereference it

395
00:14:25,680 --> 00:14:27,600
use the value that we get back from the

396
00:14:27,600 --> 00:14:28,720
kernel address

397
00:14:28,720 --> 00:14:31,360
as an index to our memory and then we

398
00:14:31,360 --> 00:14:32,639
should observe

399
00:14:32,639 --> 00:14:36,160
this x if distorted load forging logic

400
00:14:36,160 --> 00:14:38,880
works so let us try this so in the

401
00:14:38,880 --> 00:14:40,160
beginning there is nothing met

402
00:14:40,160 --> 00:14:43,040
so as michel said we cannot write this

403
00:14:43,040 --> 00:14:45,760
there's no store buffer entry for this

404
00:14:45,760 --> 00:14:48,399
so we don't find anything we can repeat

405
00:14:48,399 --> 00:14:48,800
this

406
00:14:48,800 --> 00:14:52,320
and we never get a value back but now

407
00:14:52,320 --> 00:14:53,920
we find the location where the kernel is

408
00:14:53,920 --> 00:14:55,600
actually met and

409
00:14:55,600 --> 00:14:58,560
suddenly we can write to this address we

410
00:14:58,560 --> 00:14:59,440
get a stop of

411
00:14:59,440 --> 00:15:01,440
entry when we load then from this

412
00:15:01,440 --> 00:15:03,920
address we get distorted load forwarding

413
00:15:03,920 --> 00:15:04,480
effect

414
00:15:04,480 --> 00:15:06,480
we get it into the load buffer and the

415
00:15:06,480 --> 00:15:07,920
data is forwarded

416
00:15:07,920 --> 00:15:10,800
and used in subsequent instructions for

417
00:15:10,800 --> 00:15:12,320
the access to mem

418
00:15:12,320 --> 00:15:14,800
and if we then use our primitive again

419
00:15:14,800 --> 00:15:16,399
we can suddenly see that the

420
00:15:16,399 --> 00:15:19,519
axis time for x is much slower and

421
00:15:19,519 --> 00:15:20,079
slower

422
00:15:20,079 --> 00:15:21,839
and we know that there is something met

423
00:15:21,839 --> 00:15:23,519
our kernel is there

424
00:15:23,519 --> 00:15:26,000
so the question then is what if an

425
00:15:26,000 --> 00:15:27,040
address is valid

426
00:15:27,040 --> 00:15:29,360
but unknown so we know it has a physical

427
00:15:29,360 --> 00:15:30,399
backing

428
00:15:30,399 --> 00:15:33,120
but it's maybe not in we don't know the

429
00:15:33,120 --> 00:15:34,959
physical address yet because it has not

430
00:15:34,959 --> 00:15:37,040
been used recently

431
00:15:37,040 --> 00:15:40,480
so what if we simply repeat data bounds

432
00:15:40,480 --> 00:15:41,920
we can see here if we have unmapped

433
00:15:41,920 --> 00:15:43,839
regions we have

434
00:15:43,839 --> 00:15:46,639
mapped regions as well if we get our

435
00:15:46,639 --> 00:15:47,120
data

436
00:15:47,120 --> 00:15:49,440
and in the first try of data bounds so

437
00:15:49,440 --> 00:15:50,959
it's forwarded on the first try

438
00:15:50,959 --> 00:15:53,199
we know that this in the dlb so it has

439
00:15:53,199 --> 00:15:54,560
been recently used

440
00:15:54,560 --> 00:15:57,839
because we know the physical address if

441
00:15:57,839 --> 00:16:00,160
we get it on the second try we know it's

442
00:16:00,160 --> 00:16:02,959
valid but it's not in the dlb

443
00:16:02,959 --> 00:16:05,759
and in the final case we don't get any

444
00:16:05,759 --> 00:16:08,320
forwarding no matter how often we try it

445
00:16:08,320 --> 00:16:10,639
then we can infer that this address is

446
00:16:10,639 --> 00:16:13,360
unmapped it's not valid

447
00:16:13,360 --> 00:16:16,480
that's a nice observation claudio but i

448
00:16:16,480 --> 00:16:18,160
don't think it has any security

449
00:16:18,160 --> 00:16:19,680
implications i mean

450
00:16:19,680 --> 00:16:21,920
what are you going to do that we already

451
00:16:21,920 --> 00:16:23,920
broke kslr

452
00:16:23,920 --> 00:16:25,519
what are going with that additional

453
00:16:25,519 --> 00:16:27,759
information no i think we can do

454
00:16:27,759 --> 00:16:28,639
something i think

455
00:16:28,639 --> 00:16:31,120
there's an attack primitive here and all

456
00:16:31,120 --> 00:16:33,120
good attack primitives need a name

457
00:16:33,120 --> 00:16:34,320
so i think we're going to call it fetch

458
00:16:34,320 --> 00:16:37,360
and bounce so now we aren't agnostic of

459
00:16:37,360 --> 00:16:38,800
a tlb anymore

460
00:16:38,800 --> 00:16:41,519
we know it's there and we use it so in

461
00:16:41,519 --> 00:16:42,160
this case

462
00:16:42,160 --> 00:16:45,279
we see four kernel pages that are all

463
00:16:45,279 --> 00:16:46,399
mapped

464
00:16:46,399 --> 00:16:48,000
and now what we're gonna do is we're

465
00:16:48,000 --> 00:16:49,839
gonna do it again but

466
00:16:49,839 --> 00:16:51,440
with fetch and bounce we only access

467
00:16:51,440 --> 00:16:53,839
once each we don't repeat

468
00:16:53,839 --> 00:16:55,199
and so when we do this for the first

469
00:16:55,199 --> 00:16:57,680
address we can see that we got a lookup

470
00:16:57,680 --> 00:16:58,560
in a tlb

471
00:16:58,560 --> 00:17:00,959
there's nothing there and so when we try

472
00:17:00,959 --> 00:17:01,600
to store

473
00:17:01,600 --> 00:17:04,160
we can't get a valid store buffer entry

474
00:17:04,160 --> 00:17:06,640
and so we also can't get forwarding

475
00:17:06,640 --> 00:17:08,799
and so now there's a tlb entry but it's

476
00:17:08,799 --> 00:17:09,679
already too late

477
00:17:09,679 --> 00:17:11,919
we've moved on to the next address and

478
00:17:11,919 --> 00:17:13,039
the same thing here

479
00:17:13,039 --> 00:17:16,559
tlb is entry empty there's no entry

480
00:17:16,559 --> 00:17:18,720
again we don't get a store-bought entry

481
00:17:18,720 --> 00:17:19,919
so now but for his

482
00:17:19,919 --> 00:17:22,799
third and uh third address there is

483
00:17:22,799 --> 00:17:23,760
already a tlb

484
00:17:23,760 --> 00:17:26,720
entry and so when we try it now we get a

485
00:17:26,720 --> 00:17:27,199
sob of

486
00:17:27,199 --> 00:17:30,000
entry we get forwarding and in our next

487
00:17:30,000 --> 00:17:30,640
address

488
00:17:30,640 --> 00:17:33,200
we get the x back and so now what we've

489
00:17:33,200 --> 00:17:33,679
learned

490
00:17:33,679 --> 00:17:36,240
is that there that recently this page

491
00:17:36,240 --> 00:17:38,960
was actually used by the kernel

492
00:17:38,960 --> 00:17:40,960
and so that's a new attack primitive

493
00:17:40,960 --> 00:17:42,880
here for the last page again it's not

494
00:17:42,880 --> 00:17:46,880
mapped and so we get nothing back

495
00:17:46,880 --> 00:17:49,919
okay so what can we do with this we can

496
00:17:49,919 --> 00:17:51,440
observe kernel activity

497
00:17:51,440 --> 00:17:53,120
and more specifically for example

498
00:17:53,120 --> 00:17:54,880
something like the modules

499
00:17:54,880 --> 00:17:57,600
we can check which module is used and

500
00:17:57,600 --> 00:18:00,400
which code page in it is used so as an

501
00:18:00,400 --> 00:18:01,120
example

502
00:18:01,120 --> 00:18:03,760
we use a bluetooth module and maybe we

503
00:18:03,760 --> 00:18:05,039
connect our phone to it

504
00:18:05,039 --> 00:18:07,440
and play some music and then we can

505
00:18:07,440 --> 00:18:08,720
detect

506
00:18:08,720 --> 00:18:12,160
when there is some activity here

507
00:18:13,200 --> 00:18:16,480
okay so does that really work it does

508
00:18:16,480 --> 00:18:17,760
really work or is that just

509
00:18:17,760 --> 00:18:20,080
theory it seems a little bit far-fetched

510
00:18:20,080 --> 00:18:22,000
so can you show us that this works

511
00:18:22,000 --> 00:18:22,880
because i don't

512
00:18:22,880 --> 00:18:26,000
okay okay okay all right

513
00:18:26,000 --> 00:18:28,160
let's let's go into detail a bit more so

514
00:18:28,160 --> 00:18:29,120
the first step

515
00:18:29,120 --> 00:18:30,400
first thing you have to solve is we

516
00:18:30,400 --> 00:18:31,760
don't actually know where the modules

517
00:18:31,760 --> 00:18:32,240
are

518
00:18:32,240 --> 00:18:35,280
because they're also hidden by kslr and

519
00:18:35,280 --> 00:18:36,640
so

520
00:18:36,640 --> 00:18:38,640
unlike the kernel we might be able to

521
00:18:38,640 --> 00:18:39,760
find them but we need to

522
00:18:39,760 --> 00:18:42,240
do some more to identify them and so

523
00:18:42,240 --> 00:18:43,520
what we do is here

524
00:18:43,520 --> 00:18:47,520
in this demo we scan the entire

525
00:18:47,520 --> 00:18:48,960
module address space as you can see

526
00:18:48,960 --> 00:18:50,559
that's very quick we

527
00:18:50,559 --> 00:18:53,600
identify contiguous pages of memory and

528
00:18:53,600 --> 00:18:54,160
we can

529
00:18:54,160 --> 00:18:57,280
infer that those are modules

530
00:18:57,280 --> 00:18:58,799
and we can read the size of the module

531
00:18:58,799 --> 00:19:01,200
with that and so now we can match

532
00:19:01,200 --> 00:19:03,760
unique sizes to modules with unique

533
00:19:03,760 --> 00:19:04,799
sizes

534
00:19:04,799 --> 00:19:06,799
so here we've identified three we're

535
00:19:06,799 --> 00:19:08,799
going to check in proc modules

536
00:19:08,799 --> 00:19:10,799
if the addresses are correct so we're

537
00:19:10,799 --> 00:19:13,200
going to check for bluetooth

538
00:19:13,200 --> 00:19:16,000
that looks correct we're going to check

539
00:19:16,000 --> 00:19:16,480
for the

540
00:19:16,480 --> 00:19:19,120
wi-fi module that we tried to identify

541
00:19:19,120 --> 00:19:21,039
that looks good as well

542
00:19:21,039 --> 00:19:22,960
and lastly the thunderbolt module we

543
00:19:22,960 --> 00:19:25,120
also correctly identified

544
00:19:25,120 --> 00:19:28,480
and you can also see that the font sizes

545
00:19:28,480 --> 00:19:28,880
match

546
00:19:28,880 --> 00:19:30,880
because of sizes again are how we

547
00:19:30,880 --> 00:19:32,240
identify the modules

548
00:19:32,240 --> 00:19:33,840
so this doesn't work for modules of the

549
00:19:33,840 --> 00:19:35,679
same size

550
00:19:35,679 --> 00:19:38,320
so that's the first step we know where

551
00:19:38,320 --> 00:19:39,520
our target module is

552
00:19:39,520 --> 00:19:41,840
in this case the bluetooth module so

553
00:19:41,840 --> 00:19:43,440
what you've basically shown us now is

554
00:19:43,440 --> 00:19:43,760
that

555
00:19:43,760 --> 00:19:46,240
this is data bound this is data bounce

556
00:19:46,240 --> 00:19:47,600
right this is later bounce you still

557
00:19:47,600 --> 00:19:48,320
haven't shown us

558
00:19:48,320 --> 00:19:50,799
that fetching bounce works correct let's

559
00:19:50,799 --> 00:19:52,080
use faction bonds with this

560
00:19:52,080 --> 00:19:54,240
now we know where the module is we know

561
00:19:54,240 --> 00:19:55,360
an address let's say

562
00:19:55,360 --> 00:19:56,880
some page in a bluetooth module we want

563
00:19:56,880 --> 00:19:58,880
to attack and so now what we're going to

564
00:19:58,880 --> 00:20:00,480
do is we're going to sample

565
00:20:00,480 --> 00:20:02,240
uh we're going to sample with fetch and

566
00:20:02,240 --> 00:20:05,120
bounce this page in a bluetooth module

567
00:20:05,120 --> 00:20:07,760
then we're gonna clear the tlb for this

568
00:20:07,760 --> 00:20:08,799
core because they're

569
00:20:08,799 --> 00:20:11,120
the tlbs are per core and not shared

570
00:20:11,120 --> 00:20:12,799
then we're gonna jump to the next core

571
00:20:12,799 --> 00:20:14,080
and do the same thing

572
00:20:14,080 --> 00:20:15,360
and so with this we move through the

573
00:20:15,360 --> 00:20:17,600
cores in order and give the bluetooth

574
00:20:17,600 --> 00:20:19,360
module time to work and then we sample

575
00:20:19,360 --> 00:20:20,640
again

576
00:20:20,640 --> 00:20:22,240
and so this is what it looks like in

577
00:20:22,240 --> 00:20:24,480
action

578
00:20:24,799 --> 00:20:28,000
we get hit rate

579
00:20:28,000 --> 00:20:29,919
and you can see as soon as we hit play

580
00:20:29,919 --> 00:20:31,760
on the right in the phone

581
00:20:31,760 --> 00:20:35,120
we get correctly identified once

582
00:20:35,120 --> 00:20:36,480
and so for the bluetooth module

583
00:20:36,480 --> 00:20:38,320
something we've noticed is that there is

584
00:20:38,320 --> 00:20:40,720
some after activity

585
00:20:40,720 --> 00:20:42,960
so now we get zeros again we're gonna

586
00:20:42,960 --> 00:20:45,280
start

587
00:20:45,520 --> 00:20:47,679
and we get a very sharp identification

588
00:20:47,679 --> 00:20:48,640
here again

589
00:20:48,640 --> 00:20:51,200
so you can see right now we have about

590
00:20:51,200 --> 00:20:53,520
one percent of detection

591
00:20:53,520 --> 00:20:56,240
which is because of that's how often we

592
00:20:56,240 --> 00:20:57,760
sample

593
00:20:57,760 --> 00:20:59,919
so again you can see that there's the

594
00:20:59,919 --> 00:21:02,000
temporary resolution for first detection

595
00:21:02,000 --> 00:21:04,480
is fairly good in this case we just

596
00:21:04,480 --> 00:21:05,520
don't

597
00:21:05,520 --> 00:21:08,559
do this very often and

598
00:21:08,559 --> 00:21:11,679
you can see it is all very stable and

599
00:21:11,679 --> 00:21:14,400
in general from the from the music you

600
00:21:14,400 --> 00:21:14,720
get

601
00:21:14,720 --> 00:21:17,039
this is a very important plc this is

602
00:21:17,039 --> 00:21:19,760
very dramatic

603
00:21:20,080 --> 00:21:24,639
right so

604
00:21:24,720 --> 00:21:27,600
it works okay yeah i believe all right

605
00:21:27,600 --> 00:21:30,159
we can do something with that that's a

606
00:21:30,159 --> 00:21:31,120
great demo

607
00:21:31,120 --> 00:21:33,760
thanks so thanks we have something else

608
00:21:33,760 --> 00:21:34,640
as well though

609
00:21:34,640 --> 00:21:36,400
another variant but for this we're going

610
00:21:36,400 --> 00:21:38,559
to have to go a bit back in time

611
00:21:38,559 --> 00:21:40,320
and mikhail is going to tell you a bit

612
00:21:40,320 --> 00:21:42,000
more about that

613
00:21:42,000 --> 00:21:44,080
exactly i was just thinking so you

614
00:21:44,080 --> 00:21:46,080
talked about out of order transient

615
00:21:46,080 --> 00:21:47,919
executions and stuff

616
00:21:47,919 --> 00:21:51,200
what if we actually combine that with

617
00:21:51,200 --> 00:21:53,120
another transient execution attack that

618
00:21:53,120 --> 00:21:55,200
we know spectre

619
00:21:55,200 --> 00:21:58,000
so if you test short recap for spectre

620
00:21:58,000 --> 00:21:58,960
it's about

621
00:21:58,960 --> 00:22:01,600
um the variant one is about bounce and

622
00:22:01,600 --> 00:22:02,080
and

623
00:22:02,080 --> 00:22:04,880
predicting uh bounds of accesses and if

624
00:22:04,880 --> 00:22:05,919
the cpu

625
00:22:05,919 --> 00:22:08,159
predicts that something is in bounds if

626
00:22:08,159 --> 00:22:09,919
you do an imbalance check

627
00:22:09,919 --> 00:22:11,600
then everything is faster because it was

628
00:22:11,600 --> 00:22:13,200
predicted correctly

629
00:22:13,200 --> 00:22:14,960
um if the miss if there was a

630
00:22:14,960 --> 00:22:16,480
misprediction it might be a bit slower

631
00:22:16,480 --> 00:22:18,320
but it's still okay

632
00:22:18,320 --> 00:22:20,320
if it predicts it's not in bounce and is

633
00:22:20,320 --> 00:22:22,159
actually not in bounce it's also fine

634
00:22:22,159 --> 00:22:24,799
the prediction was correct but yes one

635
00:22:24,799 --> 00:22:26,320
corner case

636
00:22:26,320 --> 00:22:28,159
that is actually exploitable the

637
00:22:28,159 --> 00:22:31,120
spectral attack so if the cpu predicts

638
00:22:31,120 --> 00:22:34,480
that something is in bounds but it's not

639
00:22:34,480 --> 00:22:35,840
inbounds

640
00:22:35,840 --> 00:22:38,480
so that means we can transiently access

641
00:22:38,480 --> 00:22:39,760
data out of bounds

642
00:22:39,760 --> 00:22:41,919
of an array and if you look at the

643
00:22:41,919 --> 00:22:44,000
simple if condition here that checks

644
00:22:44,000 --> 00:22:46,000
whether an index a given index

645
00:22:46,000 --> 00:22:48,720
is smaller than four and then x is an

646
00:22:48,720 --> 00:22:49,919
array that has

647
00:22:49,919 --> 00:22:51,919
four elements and after this array

648
00:22:51,919 --> 00:22:53,679
there's some secret data in memory

649
00:22:53,679 --> 00:22:55,840
that we shouldn't be able to access

650
00:22:55,840 --> 00:22:56,720
architecturally

651
00:22:56,720 --> 00:22:58,640
because we have this bounce check here

652
00:22:58,640 --> 00:23:00,240
in the if condition

653
00:23:00,240 --> 00:23:03,280
and uses this data here as an index for

654
00:23:03,280 --> 00:23:03,530
some

655
00:23:03,530 --> 00:23:04,720
[Music]

656
00:23:04,720 --> 00:23:06,960
memory for example a font file here to

657
00:23:06,960 --> 00:23:08,240
do pretty printing

658
00:23:08,240 --> 00:23:10,720
of this letter that we get from the

659
00:23:10,720 --> 00:23:12,000
array

660
00:23:12,000 --> 00:23:13,919
so if we look at that the first time the

661
00:23:13,919 --> 00:23:16,720
cpu has no idea if this condition will

662
00:23:16,720 --> 00:23:17,760
be true or not

663
00:23:17,760 --> 00:23:19,520
it speculates something maybe it

664
00:23:19,520 --> 00:23:21,600
speculates for it's wrong

665
00:23:21,600 --> 00:23:24,880
okay nothing happens then if we actually

666
00:23:24,880 --> 00:23:26,640
execute that on the cpu

667
00:23:26,640 --> 00:23:28,960
the cpu sees oh this condition was

668
00:23:28,960 --> 00:23:29,919
actually true

669
00:23:29,919 --> 00:23:32,400
because 0 is smaller than 4 and it loads

670
00:23:32,400 --> 00:23:33,520
the first value

671
00:23:33,520 --> 00:23:36,240
from memory it uses that to index this

672
00:23:36,240 --> 00:23:38,159
font file that we have here

673
00:23:38,159 --> 00:23:41,120
and all of that is put transparently

674
00:23:41,120 --> 00:23:43,279
into the cache

675
00:23:43,279 --> 00:23:45,520
and the next execution we have the next

676
00:23:45,520 --> 00:23:46,640
index

677
00:23:46,640 --> 00:23:48,480
one is smaller than four the cpu is like

678
00:23:48,480 --> 00:23:50,000
oh it was smaller before

679
00:23:50,000 --> 00:23:52,400
it was true before so let's speculate

680
00:23:52,400 --> 00:23:53,440
that it's also

681
00:23:53,440 --> 00:23:55,919
true now it speculates that it has to

682
00:23:55,919 --> 00:23:56,799
get the

683
00:23:56,799 --> 00:23:59,440
data from memory it does that looks it

684
00:23:59,440 --> 00:24:00,720
up in this font file

685
00:24:00,720 --> 00:24:03,279
everything is put in the cache and when

686
00:24:03,279 --> 00:24:03,760
it actually

687
00:24:03,760 --> 00:24:06,320
executes then architecturally it sees oh

688
00:24:06,320 --> 00:24:07,520
my prediction was correct

689
00:24:07,520 --> 00:24:09,520
everything is fine nothing has to be

690
00:24:09,520 --> 00:24:11,039
undone perfect

691
00:24:11,039 --> 00:24:13,360
super fast and it continues like that

692
00:24:13,360 --> 00:24:15,120
for the next index and for the next

693
00:24:15,120 --> 00:24:16,000
index

694
00:24:16,000 --> 00:24:18,159
and then we get to index four and four

695
00:24:18,159 --> 00:24:20,240
is not smaller than four

696
00:24:20,240 --> 00:24:22,559
but the cpu is like yeah it was always

697
00:24:22,559 --> 00:24:23,760
through this condition

698
00:24:23,760 --> 00:24:26,480
will be true as well this time so it

699
00:24:26,480 --> 00:24:27,200
starts

700
00:24:27,200 --> 00:24:29,279
fetching memory that's actually out of

701
00:24:29,279 --> 00:24:30,400
bounds of the array

702
00:24:30,400 --> 00:24:32,880
so it shouldn't be accessible and takes

703
00:24:32,880 --> 00:24:33,600
that

704
00:24:33,600 --> 00:24:35,600
looks it up in the font file puts it

705
00:24:35,600 --> 00:24:36,960
into the cache

706
00:24:36,960 --> 00:24:39,679
and there we have our problem we have

707
00:24:39,679 --> 00:24:41,039
something in the cache

708
00:24:41,039 --> 00:24:43,360
that correlates to the secret data in

709
00:24:43,360 --> 00:24:45,200
memory that we are not supposed

710
00:24:45,200 --> 00:24:49,039
to access and as lucas said before

711
00:24:49,039 --> 00:24:52,240
we have this attacks that can measure

712
00:24:52,240 --> 00:24:53,279
the timings

713
00:24:53,279 --> 00:24:55,840
and also audio exploited that and we can

714
00:24:55,840 --> 00:24:57,120
see that from the cache

715
00:24:57,120 --> 00:25:00,400
and infer the secrets from that

716
00:25:00,400 --> 00:25:03,520
and now we could also combine that with

717
00:25:03,520 --> 00:25:05,760
our fetch and bounce method so if we

718
00:25:05,760 --> 00:25:06,799
have this

719
00:25:06,799 --> 00:25:10,159
bounce check here this condition and

720
00:25:10,159 --> 00:25:13,679
then we could access something based on

721
00:25:13,679 --> 00:25:15,200
this index here

722
00:25:15,200 --> 00:25:17,600
then it's not only put into the cache

723
00:25:17,600 --> 00:25:19,919
but also into the tlb

724
00:25:19,919 --> 00:25:23,600
so then we can use fetch and pounds

725
00:25:23,600 --> 00:25:25,840
to iterate over the memory instead of

726
00:25:25,840 --> 00:25:27,039
doing a cache attack

727
00:25:27,039 --> 00:25:29,360
we're doing a tlb attack with fetch and

728
00:25:29,360 --> 00:25:30,320
bounce

729
00:25:30,320 --> 00:25:33,279
and we can infer that secret from the

730
00:25:33,279 --> 00:25:34,000
tlb

731
00:25:34,000 --> 00:25:36,960
when it was a tlp hit or not so whether

732
00:25:36,960 --> 00:25:38,000
fetch and bounce

733
00:25:38,000 --> 00:25:41,600
succeeded at the first try or not

734
00:25:41,600 --> 00:25:43,760
that's very interesting but i remember

735
00:25:43,760 --> 00:25:45,200
there was specter and wasn't there

736
00:25:45,200 --> 00:25:47,200
another vulnerability as well

737
00:25:47,200 --> 00:25:49,440
that's i don't know it sounded really

738
00:25:49,440 --> 00:25:51,600
scary something like nuclear stuff

739
00:25:51,600 --> 00:25:54,240
something like that ah you mean meltdown

740
00:25:54,240 --> 00:25:55,120
yes

741
00:25:55,120 --> 00:25:58,159
meltdown was also at the same time but

742
00:25:58,159 --> 00:25:59,600
it's a different attack

743
00:25:59,600 --> 00:26:01,919
so this exploits the the permission

744
00:26:01,919 --> 00:26:04,000
check that we also exploit here

745
00:26:04,000 --> 00:26:06,720
uh with data bounds so that permissions

746
00:26:06,720 --> 00:26:08,320
are checked later on

747
00:26:08,320 --> 00:26:10,240
and with that it was possible to

748
00:26:10,240 --> 00:26:12,480
basically read the entire memory

749
00:26:12,480 --> 00:26:14,880
because even inaccessible memory could

750
00:26:14,880 --> 00:26:16,559
be accessed transiently

751
00:26:16,559 --> 00:26:19,279
encoded somewhere and then restored with

752
00:26:19,279 --> 00:26:21,039
a side channel attack

753
00:26:21,039 --> 00:26:22,880
and as the kernel maps all physical

754
00:26:22,880 --> 00:26:24,480
memory basically

755
00:26:24,480 --> 00:26:26,640
we can read arbitrary memory with

756
00:26:26,640 --> 00:26:28,000
meltdown so

757
00:26:28,000 --> 00:26:31,039
yes you're right super scary yeah but i

758
00:26:31,039 --> 00:26:31,520
mean

759
00:26:31,520 --> 00:26:33,919
we know it's scary but how do you fix

760
00:26:33,919 --> 00:26:34,960
this i remember that

761
00:26:34,960 --> 00:26:37,760
it was like this huge performance impact

762
00:26:37,760 --> 00:26:38,320
so

763
00:26:38,320 --> 00:26:40,159
isn't there a smarter way to fix this

764
00:26:40,159 --> 00:26:41,600
right so

765
00:26:41,600 --> 00:26:44,559
we know intel did fix it but we don't

766
00:26:44,559 --> 00:26:45,440
really know how

767
00:26:45,440 --> 00:26:47,679
right so let's reverse engineer this

768
00:26:47,679 --> 00:26:49,120
let's see

769
00:26:49,120 --> 00:26:50,799
we make a few assumptions here so

770
00:26:50,799 --> 00:26:52,400
starting the cpu we think

771
00:26:52,400 --> 00:26:55,760
might be a bit costly and it might also

772
00:26:55,760 --> 00:26:57,120
require some re-engineering of the

773
00:26:57,120 --> 00:26:58,159
pipeline

774
00:26:58,159 --> 00:26:59,600
and we know that these mitigations were

775
00:26:59,600 --> 00:27:01,600
rolled out fairly quickly

776
00:27:01,600 --> 00:27:05,039
so let's make a guess here let's say

777
00:27:05,039 --> 00:27:07,760
data is just zeroed out on a load if

778
00:27:07,760 --> 00:27:08,960
that load falls

779
00:27:08,960 --> 00:27:11,760
but the load still happens so we can

780
00:27:11,760 --> 00:27:13,200
test this hypothesis

781
00:27:13,200 --> 00:27:16,080
so first we just do meltdown and

782
00:27:16,080 --> 00:27:17,919
meltdown unsurprisingly on mitigated

783
00:27:17,919 --> 00:27:19,120
cpus now returns

784
00:27:19,120 --> 00:27:22,000
zero and not the data anymore so that's

785
00:27:22,000 --> 00:27:22,640
that's good

786
00:27:22,640 --> 00:27:25,760
mission accomplished right so

787
00:27:25,760 --> 00:27:27,600
we confirm our hypothesis of how this

788
00:27:27,600 --> 00:27:30,559
works with some performance counters

789
00:27:30,559 --> 00:27:33,440
so first we look at memory stalls and we

790
00:27:33,440 --> 00:27:34,159
compare

791
00:27:34,159 --> 00:27:36,960
intel cpus that are vulnerable that are

792
00:27:36,960 --> 00:27:39,520
mitigated and an amd cpu

793
00:27:39,520 --> 00:27:41,039
and so what we can see is that on a

794
00:27:41,039 --> 00:27:44,480
vulnerable cpu and on a mitigated cpu

795
00:27:44,480 --> 00:27:47,120
for user and kernel accesses there is

796
00:27:47,120 --> 00:27:47,679
the same

797
00:27:47,679 --> 00:27:50,799
percentage of stalls that is not a

798
00:27:50,799 --> 00:27:52,159
hundred percent like it is for

799
00:27:52,159 --> 00:27:53,279
non-present

800
00:27:53,279 --> 00:27:55,600
and on an unaffected cpu such as an amd

801
00:27:55,600 --> 00:27:56,480
cpu

802
00:27:56,480 --> 00:27:58,240
we see that non-present pages and

803
00:27:58,240 --> 00:28:02,240
current pages both stall 100 of the time

804
00:28:02,240 --> 00:28:04,399
so we can look at a second counter the

805
00:28:04,399 --> 00:28:07,120
issued micro-ops on the load ports

806
00:28:07,120 --> 00:28:09,520
and again here we can see that with and

807
00:28:09,520 --> 00:28:10,320
without

808
00:28:10,320 --> 00:28:13,440
mitigations user and kernel

809
00:28:13,440 --> 00:28:15,760
address accesses have the same number of

810
00:28:15,760 --> 00:28:17,200
microbes issued

811
00:28:17,200 --> 00:28:19,039
and that again points towards our

812
00:28:19,039 --> 00:28:20,640
conclusion

813
00:28:20,640 --> 00:28:22,000
that loads still happen in the

814
00:28:22,000 --> 00:28:24,640
background they just zeroed out

815
00:28:24,640 --> 00:28:27,120
and so just to be sure we tried a third

816
00:28:27,120 --> 00:28:28,159
measure

817
00:28:28,159 --> 00:28:29,679
that is when we have an access that

818
00:28:29,679 --> 00:28:31,279
misses the l1

819
00:28:31,279 --> 00:28:33,520
we measure this uh we look at this

820
00:28:33,520 --> 00:28:35,360
mispending cycles counter

821
00:28:35,360 --> 00:28:37,600
and again we see that between

822
00:28:37,600 --> 00:28:40,080
unmitigated and mitigated cpus

823
00:28:40,080 --> 00:28:42,399
the ratio of user and kernel accesses is

824
00:28:42,399 --> 00:28:44,880
exactly the same so again

825
00:28:44,880 --> 00:28:47,200
this leads us to the conclusion it's

826
00:28:47,200 --> 00:28:48,399
just zeroed out the

827
00:28:48,399 --> 00:28:51,200
load happens in the background anyways

828
00:28:51,200 --> 00:28:51,679
so

829
00:28:51,679 --> 00:28:54,000
that's very nice but when i see this i

830
00:28:54,000 --> 00:28:55,600
immediately think that

831
00:28:55,600 --> 00:28:56,880
can we use the hardware based

832
00:28:56,880 --> 00:28:58,640
mitigations for an attack because it

833
00:28:58,640 --> 00:29:00,320
sounds like we can do that

834
00:29:00,320 --> 00:29:03,120
why don't you build one well we've seen

835
00:29:03,120 --> 00:29:04,880
already ksl outbreaks we've seen data

836
00:29:04,880 --> 00:29:06,480
bounce which was such an

837
00:29:06,480 --> 00:29:08,960
attack and when we've looked at these

838
00:29:08,960 --> 00:29:10,080
mitigations we

839
00:29:10,080 --> 00:29:12,799
thought okay we find another one let's

840
00:29:12,799 --> 00:29:14,480
call it echelod which is a very fast and

841
00:29:14,480 --> 00:29:16,320
reliable case law break

842
00:29:16,320 --> 00:29:18,880
and it again simply encodes the return

843
00:29:18,880 --> 00:29:19,440
value

844
00:29:19,440 --> 00:29:21,279
when we access it simply like a meltdown

845
00:29:21,279 --> 00:29:22,960
attack in the cache

846
00:29:22,960 --> 00:29:25,360
and actually load for instance it can't

847
00:29:25,360 --> 00:29:26,559
be summarized with

848
00:29:26,559 --> 00:29:30,000
this very short sample of code it's more

849
00:29:30,000 --> 00:29:31,600
or less a memory access

850
00:29:31,600 --> 00:29:33,760
encoding data that we load from the

851
00:29:33,760 --> 00:29:35,200
kernel edge that looks almost the same

852
00:29:35,200 --> 00:29:36,240
as before so

853
00:29:36,240 --> 00:29:37,600
yeah but different now but it's a little

854
00:29:37,600 --> 00:29:38,880
bit different because what you hear

855
00:29:38,880 --> 00:29:40,000
exploit now is that

856
00:29:40,000 --> 00:29:41,840
we exploit this stalling behavior when

857
00:29:41,840 --> 00:29:43,440
the cpu

858
00:29:43,440 --> 00:29:46,159
uh when the cpu tries to access the

859
00:29:46,159 --> 00:29:47,760
memory that is not

860
00:29:47,760 --> 00:29:50,880
backed by physical memory so we can

861
00:29:50,880 --> 00:29:52,559
change this kernel address and we never

862
00:29:52,559 --> 00:29:53,760
find

863
00:29:53,760 --> 00:29:56,559
we always stall but at one point we get

864
00:29:56,559 --> 00:29:57,600
to this location

865
00:29:57,600 --> 00:30:00,159
where the kernel is actually placed and

866
00:30:00,159 --> 00:30:01,120
now we see

867
00:30:01,120 --> 00:30:03,039
the effect that these mitigations have

868
00:30:03,039 --> 00:30:05,760
because now we have a faulting load

869
00:30:05,760 --> 00:30:09,520
and we get a zero back so we know now

870
00:30:09,520 --> 00:30:12,480
where the kernel is placed nice right

871
00:30:12,480 --> 00:30:13,520
that's pretty cool

872
00:30:13,520 --> 00:30:16,320
but the question then is always what's

873
00:30:16,320 --> 00:30:17,440
the performance of issue

874
00:30:17,440 --> 00:30:18,880
right because that's what we care about

875
00:30:18,880 --> 00:30:20,320
in the end we want numbers we want speed

876
00:30:20,320 --> 00:30:21,039
yes

877
00:30:21,039 --> 00:30:24,159
and we evaluate it on several cpus with

878
00:30:24,159 --> 00:30:26,000
mitigations without mitigation because

879
00:30:26,000 --> 00:30:27,679
it also works on those without

880
00:30:27,679 --> 00:30:28,799
mitigations because

881
00:30:28,799 --> 00:30:32,799
then it's simply meltdown and

882
00:30:32,799 --> 00:30:34,399
we also tried it because we have 14

883
00:30:34,399 --> 00:30:36,640
loads so we need to somehow

884
00:30:36,640 --> 00:30:39,440
prevent our program from dying we place

885
00:30:39,440 --> 00:30:39,919
the

886
00:30:39,919 --> 00:30:42,799
faulting load within speculation within

887
00:30:42,799 --> 00:30:44,960
tsx which is an intel feature

888
00:30:44,960 --> 00:30:46,960
or simply by using a segfault handling

889
00:30:46,960 --> 00:30:48,480
and as we can see

890
00:30:48,480 --> 00:30:52,000
it is very fast on the i9 i9

891
00:30:52,000 --> 00:30:55,039
with dsx we have like 29 microseconds

892
00:30:55,039 --> 00:30:57,760
and a perfect accuracy with an f score

893
00:30:57,760 --> 00:30:58,159
of

894
00:30:58,159 --> 00:31:01,519
one so we are very reliable and very

895
00:31:01,519 --> 00:31:03,360
fast even faster than previous state of

896
00:31:03,360 --> 00:31:04,960
the art

897
00:31:04,960 --> 00:31:08,240
and for the other cpus with speculation

898
00:31:08,240 --> 00:31:09,760
we sometimes see that it's not

899
00:31:09,760 --> 00:31:11,679
completely perfect but this is more or

900
00:31:11,679 --> 00:31:13,440
less because

901
00:31:13,440 --> 00:31:15,919
inducing speculation doesn't work always

902
00:31:15,919 --> 00:31:16,960
reliable

903
00:31:16,960 --> 00:31:18,880
so this might be the explanation for

904
00:31:18,880 --> 00:31:20,159
that

905
00:31:20,159 --> 00:31:22,640
what we were also able to do is we were

906
00:31:22,640 --> 00:31:24,000
able to show that these

907
00:31:24,000 --> 00:31:26,399
that this attack works in sgx and we can

908
00:31:26,399 --> 00:31:28,960
also use it in javascript

909
00:31:28,960 --> 00:31:32,559
so now in the beginning we talked about

910
00:31:32,559 --> 00:31:33,279
that

911
00:31:33,279 --> 00:31:34,960
we not only want to attack something but

912
00:31:34,960 --> 00:31:36,399
we also want to defend against these

913
00:31:36,399 --> 00:31:37,200
attacks

914
00:31:37,200 --> 00:31:40,080
and we need softwork around for that and

915
00:31:40,080 --> 00:31:41,679
we don't just want to mitigate

916
00:31:41,679 --> 00:31:43,919
data bounce or actual load we also want

917
00:31:43,919 --> 00:31:45,200
to mitigate

918
00:31:45,200 --> 00:31:47,039
other attacks that have been designed

919
00:31:47,039 --> 00:31:48,799
previously and so

920
00:31:48,799 --> 00:31:51,039
in order to do so we need to come up

921
00:31:51,039 --> 00:31:52,000
with what

922
00:31:52,000 --> 00:31:54,559
are these attacks exploiting so we

923
00:31:54,559 --> 00:31:55,279
looked at the

924
00:31:55,279 --> 00:31:57,120
at all of them and we discovered that

925
00:31:57,120 --> 00:31:59,519
they all exploit timing differences

926
00:31:59,519 --> 00:32:02,399
between mapped and unmapped pages like

927
00:32:02,399 --> 00:32:02,960
we saw

928
00:32:02,960 --> 00:32:05,679
just now with echoload and data bonds

929
00:32:05,679 --> 00:32:08,000
for instance as well

930
00:32:08,000 --> 00:32:09,440
there have been has been another attack

931
00:32:09,440 --> 00:32:11,919
that simply differentiates the kernel

932
00:32:11,919 --> 00:32:14,559
based on the different page size it uses

933
00:32:14,559 --> 00:32:15,440
and

934
00:32:15,440 --> 00:32:17,279
there's another one that can

935
00:32:17,279 --> 00:32:18,720
differentiate the timing difference

936
00:32:18,720 --> 00:32:20,880
between executable and non-executable

937
00:32:20,880 --> 00:32:21,679
pages

938
00:32:21,679 --> 00:32:23,360
so if you want to prevent all of these

939
00:32:23,360 --> 00:32:25,200
attacks what we need to do

940
00:32:25,200 --> 00:32:27,519
is we need to mitigate all of these

941
00:32:27,519 --> 00:32:29,360
attack vectors

942
00:32:29,360 --> 00:32:32,399
so our mitigation is called flare it

943
00:32:32,399 --> 00:32:34,960
stands for fake load address response

944
00:32:34,960 --> 00:32:37,039
and we can see here the current linux

945
00:32:37,039 --> 00:32:38,960
design without flare in place

946
00:32:38,960 --> 00:32:41,120
and we have the beginning of the kernel

947
00:32:41,120 --> 00:32:43,200
is somewhere

948
00:32:43,200 --> 00:32:46,000
somewhere randomly placed with kslr and

949
00:32:46,000 --> 00:32:47,120
the code section n

950
00:32:47,120 --> 00:32:49,760
is directly followed by the data section

951
00:32:49,760 --> 00:32:50,240
so

952
00:32:50,240 --> 00:32:53,519
code is obviously mapped

953
00:32:53,519 --> 00:32:56,559
using executable pages and the data

954
00:32:56,559 --> 00:32:58,480
section without

955
00:32:58,480 --> 00:33:00,080
so we need to prevent this in the first

956
00:33:00,080 --> 00:33:02,320
step let's take the

957
00:33:02,320 --> 00:33:04,559
look at the mapped and unmet pages we

958
00:33:04,559 --> 00:33:06,080
simply fill out

959
00:33:06,080 --> 00:33:07,519
all positions where the kernel can be

960
00:33:07,519 --> 00:33:10,000
met quick and easy solution right of

961
00:33:10,000 --> 00:33:10,640
course

962
00:33:10,640 --> 00:33:12,559
and we're done now right and more or

963
00:33:12,559 --> 00:33:13,679
less so we

964
00:33:13,679 --> 00:33:15,279
we fixed the data bounce and actually

965
00:33:15,279 --> 00:33:16,880
load for instance but others are still

966
00:33:16,880 --> 00:33:18,640
problematic so in this step what we also

967
00:33:18,640 --> 00:33:20,159
need to do is we need to ensure

968
00:33:20,159 --> 00:33:22,960
that all of them use the same page size

969
00:33:22,960 --> 00:33:23,360
so

970
00:33:23,360 --> 00:33:25,120
all of them use four kilobyte pages for

971
00:33:25,120 --> 00:33:27,760
instance in the next step we mitigate

972
00:33:27,760 --> 00:33:29,120
the difference between executable

973
00:33:29,120 --> 00:33:30,559
non-executable pages

974
00:33:30,559 --> 00:33:32,559
so we simply split the range for the

975
00:33:32,559 --> 00:33:33,919
kernel place

976
00:33:33,919 --> 00:33:36,399
executable code in the first half and

977
00:33:36,399 --> 00:33:38,399
non-executable in the second half

978
00:33:38,399 --> 00:33:40,720
so the switch now is always at the

979
00:33:40,720 --> 00:33:42,240
predefined location that the attacker

980
00:33:42,240 --> 00:33:43,440
already knows

981
00:33:43,440 --> 00:33:46,559
so with this simple fix we've fixed

982
00:33:46,559 --> 00:33:49,840
all of them so how does this now look we

983
00:33:49,840 --> 00:33:51,440
should for instance perform flare

984
00:33:51,440 --> 00:33:53,440
we've seen this before but now

985
00:33:53,440 --> 00:33:54,559
everything is mapped

986
00:33:54,559 --> 00:33:56,960
and we always get zero back so that's

987
00:33:56,960 --> 00:33:58,000
echo load right

988
00:33:58,000 --> 00:34:01,039
that's actually no right

989
00:34:01,039 --> 00:34:03,279
so when we take another look at all the

990
00:34:03,279 --> 00:34:04,480
other attacks

991
00:34:04,480 --> 00:34:07,760
we have seen actual already before uh

992
00:34:07,760 --> 00:34:09,359
prefetch this is the one that was able

993
00:34:09,359 --> 00:34:11,440
to differentiate the

994
00:34:11,440 --> 00:34:13,199
different page sizes we can see here

995
00:34:13,199 --> 00:34:15,599
unmapped one gigabyte four kilobyte and

996
00:34:15,599 --> 00:34:17,199
two megabyte pages

997
00:34:17,199 --> 00:34:18,839
with flare there's nothing in there

998
00:34:18,839 --> 00:34:20,639
anymore

999
00:34:20,639 --> 00:34:22,879
databands we've already seen that one

1000
00:34:22,879 --> 00:34:24,800
also not differentiable

1001
00:34:24,800 --> 00:34:26,960
the double page fault simply tries to

1002
00:34:26,960 --> 00:34:28,399
access something twice

1003
00:34:28,399 --> 00:34:29,599
and measure the timing difference

1004
00:34:29,599 --> 00:34:31,918
because if it's mapped the second axis

1005
00:34:31,918 --> 00:34:33,280
will be fast

1006
00:34:33,280 --> 00:34:36,560
also not possible anymore dr k improved

1007
00:34:36,560 --> 00:34:40,320
the double page fault by using tsx

1008
00:34:40,320 --> 00:34:43,199
so we also don't see it there anymore

1009
00:34:43,199 --> 00:34:44,480
and fallout

1010
00:34:44,480 --> 00:34:46,239
is also hidden and we had already

1011
00:34:46,239 --> 00:34:48,560
discussed the difference between fallout

1012
00:34:48,560 --> 00:34:51,119
so we also implemented this as a proof

1013
00:34:51,119 --> 00:34:51,839
of concept

1014
00:34:51,839 --> 00:34:54,960
which you can find on our github page

1015
00:34:54,960 --> 00:34:57,520
check it out we don't take any

1016
00:34:57,520 --> 00:34:59,200
guarantees that it works

1017
00:34:59,200 --> 00:35:02,880
flawlessly but in my practice system

1018
00:35:02,880 --> 00:35:05,200
i never have probably won't never

1019
00:35:05,200 --> 00:35:07,280
happened to me so

1020
00:35:07,280 --> 00:35:11,040
yes all right so what

1021
00:35:11,040 --> 00:35:14,839
do we take from that so we see again

1022
00:35:14,839 --> 00:35:17,680
optimizations whatever they are in a

1023
00:35:17,680 --> 00:35:19,119
micro architecture

1024
00:35:19,119 --> 00:35:22,320
they introduce security problems

1025
00:35:22,320 --> 00:35:25,520
and sometimes these mitigations

1026
00:35:25,520 --> 00:35:27,440
can fix the main problem but this can

1027
00:35:27,440 --> 00:35:28,640
still be some edge cases that are

1028
00:35:28,640 --> 00:35:31,040
overlooked and are still exploitable

1029
00:35:31,040 --> 00:35:33,599
and we've seen that once again just like

1030
00:35:33,599 --> 00:35:34,400
with meltdown

1031
00:35:34,400 --> 00:35:37,200
we require software mitigations to

1032
00:35:37,200 --> 00:35:39,200
prevent these edge cases

1033
00:35:39,200 --> 00:35:41,839
with that we are more or less finished

1034
00:35:41,839 --> 00:35:44,240
with our presentation and

1035
00:35:44,240 --> 00:35:46,960
we hope you enjoyed it and we are

1036
00:35:46,960 --> 00:35:48,320
looking forward to any questions that

1037
00:35:48,320 --> 00:35:50,240
you have

1038
00:35:50,240 --> 00:35:55,919
thanks for your attention

