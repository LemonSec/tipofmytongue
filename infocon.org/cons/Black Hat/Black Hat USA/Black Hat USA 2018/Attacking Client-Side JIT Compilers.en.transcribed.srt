1
00:00:00,030 --> 00:00:05,060
<font color="#E5E5E5">all right thank you so yeah for the next</font>

2
00:00:02,730 --> 00:00:08,389
47<font color="#CCCCCC"> minutes I'll be talking about</font>

3
00:00:05,060 --> 00:00:11,190
<font color="#E5E5E5">just-in-time compilers</font><font color="#CCCCCC"> for JavaScript</font>

4
00:00:08,389 --> 00:00:12,690
<font color="#CCCCCC">mainly how they work and</font><font color="#E5E5E5"> what kind of</font>

5
00:00:11,190 --> 00:00:15,649
<font color="#E5E5E5">box you can find there</font>

6
00:00:12,690 --> 00:00:19,220
we'll start with let<font color="#E5E5E5"> me turn this on</font>

7
00:00:15,650 --> 00:00:22,920
yeah<font color="#CCCCCC"> we'll start</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> a short overview</font>

8
00:00:19,220 --> 00:00:24,359
<font color="#E5E5E5">how the JavaScript engine look like yes</font>

9
00:00:22,920 --> 00:00:25,949
these are<font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of the main components</font>

10
00:00:24,359 --> 00:00:30,359
you'll need to make<font color="#E5E5E5"> a JavaScript engine</font>

11
00:00:25,949 --> 00:00:32,430
first we have the parser that<font color="#E5E5E5"> basically</font>

12
00:00:30,359 --> 00:00:36,120
<font color="#E5E5E5">takes your JavaScript code as textual</font>

13
00:00:32,430 --> 00:00:37,890
representation<font color="#E5E5E5"> and</font><font color="#CCCCCC"> converted to byte</font>

14
00:00:36,120 --> 00:00:39,930
<font color="#CCCCCC">code usually that custom byte code for</font>

15
00:00:37,890 --> 00:00:42,870
the engine so<font color="#CCCCCC"> that</font><font color="#E5E5E5"> kind of a bytecode</font>

16
00:00:39,930 --> 00:00:46,140
compiler if<font color="#E5E5E5"> you</font><font color="#CCCCCC"> watch next</font>

17
00:00:42,870 --> 00:00:48,480
we have an<font color="#E5E5E5"> interpreter and or a JIT</font>

18
00:00:46,140 --> 00:00:50,940
compiler which basically consumes this

19
00:00:48,480 --> 00:00:53,750
bytecode<font color="#E5E5E5"> and some</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> executed right so</font>

20
00:00:50,940 --> 00:00:56,160
the interpreter<font color="#E5E5E5"> interpreter can just</font>

21
00:00:53,750 --> 00:00:57,809
execute the code<font color="#CCCCCC"> directly the JIT</font>

22
00:00:56,160 --> 00:01:01,440
compiler first converted to machine code

23
00:00:57,809 --> 00:01:03,599
<font color="#CCCCCC">then runs your machine code so while</font>

24
00:01:01,440 --> 00:01:05,929
this code runs<font color="#E5E5E5"> it interacts with what I</font>

25
00:01:03,600 --> 00:01:08,159
call<font color="#CCCCCC"> the</font><font color="#E5E5E5"> runtime which essentially</font>

26
00:01:05,930 --> 00:01:11,520
<font color="#E5E5E5">defined various data structures</font><font color="#CCCCCC"> like</font>

27
00:01:08,159 --> 00:01:14,250
values<font color="#E5E5E5"> objects and so on</font><font color="#CCCCCC"> and it provides</font>

28
00:01:11,520 --> 00:01:16,890
a bunch of building functions<font color="#E5E5E5"> objects</font>

29
00:01:14,250 --> 00:01:19,290
etc and finally<font color="#E5E5E5"> we have the garbage</font>

30
00:01:16,890 --> 00:01:21,360
collector<font color="#E5E5E5"> so</font><font color="#CCCCCC"> JavaScript is garbage</font>

31
00:01:19,290 --> 00:01:22,740
collected language meaning<font color="#E5E5E5"> the</font>

32
00:01:21,360 --> 00:01:24,929
programmer doesn't need to take care of

33
00:01:22,740 --> 00:01:27,839
free memory so the garbage collector

34
00:01:24,930 --> 00:01:29,880
does that so with that here's what<font color="#E5E5E5"> we'll</font>

35
00:01:27,840 --> 00:01:32,400
talk about today we'll start with some

36
00:01:29,880 --> 00:01:34,920
introduction or some background on the

37
00:01:32,400 --> 00:01:37,950
runtime how it works mainly<font color="#E5E5E5"> we'll talk</font>

38
00:01:34,920 --> 00:01:39,720
about<font color="#CCCCCC"> JavaScript values and objects then</font>

39
00:01:37,950 --> 00:01:41,130
we'll talk<font color="#E5E5E5"> about</font><font color="#CCCCCC"> gee compiler internodes</font>

40
00:01:39,720 --> 00:01:43,829
how they work<font color="#CCCCCC"> how they</font><font color="#E5E5E5"> convert</font>

41
00:01:41,130 --> 00:01:45,869
<font color="#CCCCCC">JavaScript</font><font color="#E5E5E5"> to machine code</font><font color="#CCCCCC"> then we'll</font>

42
00:01:43,829 --> 00:01:47,520
talk<font color="#E5E5E5"> about</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> text surface what kind of</font>

43
00:01:45,869 --> 00:01:50,220
parts<font color="#E5E5E5"> you can find there and how to</font>

44
00:01:47,520 --> 00:01:53,429
exploit them a bit<font color="#E5E5E5"> and finally we'll</font>

45
00:01:50,220 --> 00:01:56,130
talk<font color="#E5E5E5"> about one</font><font color="#CCCCCC"> specific bug in WebKit</font>

46
00:01:53,430 --> 00:01:58,920
which<font color="#E5E5E5"> I use for counter on this year all</font>

47
00:01:56,130 --> 00:02:02,000
right<font color="#E5E5E5"> start with</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> runtime and</font>

48
00:01:58,920 --> 00:02:04,140
<font color="#E5E5E5">actually start with JavaScript values so</font>

49
00:02:02,000 --> 00:02:06,270
<font color="#CCCCCC">javascript is what is called the</font>

50
00:02:04,140 --> 00:02:09,179
<font color="#CCCCCC">dynamically typed language that means</font>

51
00:02:06,270 --> 00:02:11,790
that for example variables or properties

52
00:02:09,179 --> 00:02:13,349
they can essentially change type so if

53
00:02:11,790 --> 00:02:13,950
you look<font color="#E5E5E5"> at these concepts here you'll</font>

54
00:02:13,349 --> 00:02:15,988
see

55
00:02:13,950 --> 00:02:18,329
<font color="#E5E5E5">this variable</font><font color="#CCCCCC"> a its first a number 10</font>

56
00:02:15,989 --> 00:02:21,450
it's a string<font color="#CCCCCC"> at</font><font color="#E5E5E5"> an</font><font color="#CCCCCC"> object that's</font><font color="#E5E5E5"> all</font>

57
00:02:18,330 --> 00:02:24,030
fine<font color="#E5E5E5"> for</font><font color="#CCCCCC"> the engine that means that it</font>

58
00:02:21,450 --> 00:02:27,420
<font color="#E5E5E5">has to store type information</font><font color="#CCCCCC"> together</font>

59
00:02:24,030 --> 00:02:29,330
<font color="#CCCCCC">with</font><font color="#E5E5E5"> this value information and then the</font>

60
00:02:27,420 --> 00:02:32,130
challenge here<font color="#CCCCCC"> is to</font><font color="#E5E5E5"> do this efficiently</font>

61
00:02:29,330 --> 00:02:35,400
<font color="#CCCCCC">and</font><font color="#E5E5E5"> usually the solution ends up being</font>

62
00:02:32,130 --> 00:02:37,859
some clever<font color="#E5E5E5"> hex that managed to store</font>

63
00:02:35,400 --> 00:02:40,799
both type and value information<font color="#CCCCCC"> in eight</font>

64
00:02:37,860 --> 00:02:43,830
bytes<font color="#CCCCCC"> there's two of those favored hex</font>

65
00:02:40,799 --> 00:02:45,599
basically one<font color="#CCCCCC"> is called non boxing and</font>

66
00:02:43,830 --> 00:02:47,160
there's<font color="#E5E5E5"> this pointer tagging for this</font>

67
00:02:45,599 --> 00:02:50,429
talk we'll<font color="#CCCCCC"> talk about pointer tagging</font>

68
00:02:47,160 --> 00:02:53,790
just because it's a bit simpler<font color="#CCCCCC"> actually</font>

69
00:02:50,430 --> 00:02:57,630
we will use<font color="#CCCCCC"> the schema from v8</font><font color="#E5E5E5"> chromium</font>

70
00:02:53,790 --> 00:03:00,959
<font color="#E5E5E5">engine so in v8 JavaScript is basically</font>

71
00:02:57,630 --> 00:03:04,109
and an 8 byte<font color="#CCCCCC"> number or</font><font color="#E5E5E5"> 8 byte value</font>

72
00:03:00,959 --> 00:03:07,019
assuming 64-bit architecture

73
00:03:04,110 --> 00:03:09,540
now if the least significant bit if that

74
00:03:07,019 --> 00:03:11,760
is cleared if that is 0 then this thing

75
00:03:09,540 --> 00:03:13,920
<font color="#E5E5E5">is a number or a small integer they call</font>

76
00:03:11,760 --> 00:03:17,010
it so that's what you see on<font color="#CCCCCC"> the left</font>

77
00:03:13,920 --> 00:03:20,760
<font color="#E5E5E5">here you</font><font color="#CCCCCC"> see that these</font><font color="#E5E5E5"> significant bit</font>

78
00:03:17,010 --> 00:03:22,980
is 0<font color="#E5E5E5"> and then the halo 2 32 bit payload</font>

79
00:03:20,760 --> 00:03:25,819
is stored in the upper 32 bits<font color="#CCCCCC"> so this</font>

80
00:03:22,980 --> 00:03:29,518
value<font color="#E5E5E5"> if you see that in an engine in v8</font>

81
00:03:25,819 --> 00:03:32,220
<font color="#CCCCCC">represents the number hex 42</font><font color="#E5E5E5"> on the</font>

82
00:03:29,519 --> 00:03:34,230
<font color="#CCCCCC">other hand if the least significant bit</font>

83
00:03:32,220 --> 00:03:36,389
<font color="#CCCCCC">of that</font><font color="#E5E5E5"> is set then you have a pointer</font>

84
00:03:34,230 --> 00:03:38,790
and that's pointing to some object<font color="#CCCCCC"> and</font>

85
00:03:36,389 --> 00:03:40,739
then at<font color="#E5E5E5"> that location there will be more</font>

86
00:03:38,790 --> 00:03:43,138
type information<font color="#CCCCCC"> so you can see here on</font>

87
00:03:40,739 --> 00:03:44,760
the right side<font color="#E5E5E5"> that</font><font color="#CCCCCC"> where you have some</font>

88
00:03:43,139 --> 00:03:48,030
one bit<font color="#E5E5E5"> set so it's pointing to some</font>

89
00:03:44,760 --> 00:03:50,310
kind of object<font color="#CCCCCC"> all</font><font color="#E5E5E5"> right so speaking of</font>

90
00:03:48,030 --> 00:03:51,930
objects that's the next data structure

91
00:03:50,310 --> 00:03:54,959
we'll look at so the question here<font color="#CCCCCC"> is</font>

92
00:03:51,930 --> 00:03:57,329
<font color="#CCCCCC">how to represent</font><font color="#E5E5E5"> objects efficiently for</font>

93
00:03:54,959 --> 00:03:58,950
us<font color="#E5E5E5"> an object is basically just</font><font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of a</font>

94
00:03:57,329 --> 00:04:01,889
<font color="#E5E5E5">collection of key value pairs</font>

95
00:03:58,950 --> 00:04:05,518
<font color="#E5E5E5">key is being strings</font><font color="#CCCCCC"> and various being</font>

96
00:04:01,889 --> 00:04:06,870
<font color="#CCCCCC">JavaScript values so if you wanted</font><font color="#E5E5E5"> to</font>

97
00:04:05,519 --> 00:04:08,519
store that<font color="#E5E5E5"> maybe the first thing it</font>

98
00:04:06,870 --> 00:04:13,139
<font color="#E5E5E5">could come up with</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> just make a hash</font>

99
00:04:08,519 --> 00:04:14,849
map that<font color="#CCCCCC"> map's strings to values yeah</font>

100
00:04:13,139 --> 00:04:18,180
<font color="#E5E5E5">that's quite</font><font color="#CCCCCC"> simple but it's</font><font color="#E5E5E5"> not what</font>

101
00:04:14,849 --> 00:04:20,219
happens so in<font color="#E5E5E5"> reality</font><font color="#CCCCCC"> and of the major</font>

102
00:04:18,180 --> 00:04:22,800
engines right<font color="#E5E5E5"> now what they do is</font>

103
00:04:20,220 --> 00:04:26,099
essentially<font color="#E5E5E5"> they separate property name</font>

104
00:04:22,800 --> 00:04:27,780
<font color="#CCCCCC">information from value information and</font>

105
00:04:26,099 --> 00:04:29,820
then they have this

106
00:04:27,780 --> 00:04:32,309
object<font color="#E5E5E5"> that</font><font color="#CCCCCC"> I'll just</font><font color="#E5E5E5"> call shape for</font>

107
00:04:29,820 --> 00:04:35,310
this talk<font color="#CCCCCC"> this shape object essentially</font>

108
00:04:32,310 --> 00:04:37,320
<font color="#E5E5E5">swords the property names</font><font color="#CCCCCC"> so let's look</font>

109
00:04:35,310 --> 00:04:40,620
at that<font color="#E5E5E5"> again this is the object we want</font>

110
00:04:37,320 --> 00:04:42,960
<font color="#CCCCCC">to represent</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> X&Y properties and</font>

111
00:04:40,620 --> 00:04:45,630
<font color="#CCCCCC">instead of you know having</font><font color="#E5E5E5"> this object</font>

112
00:04:42,960 --> 00:04:49,200
store with<font color="#E5E5E5"> hash map mapping strings</font><font color="#CCCCCC"> to</font>

113
00:04:45,630 --> 00:04:51,330
values<font color="#E5E5E5"> instead we have the object which</font>

114
00:04:49,200 --> 00:04:54,320
<font color="#E5E5E5">points to its shape so</font><font color="#CCCCCC"> that's a separate</font>

115
00:04:51,330 --> 00:04:57,510
object<font color="#E5E5E5"> now this shape essentially Maps</font>

116
00:04:54,320 --> 00:05:00,120
property names to integers and these

117
00:04:57,510 --> 00:05:02,159
integers<font color="#E5E5E5"> they are being used as indices</font>

118
00:05:00,120 --> 00:05:04,950
<font color="#E5E5E5">and to</font><font color="#CCCCCC"> basically a dynamically</font>

119
00:05:02,160 --> 00:05:07,590
dynamically size array of pages

120
00:05:04,950 --> 00:05:09,300
associated<font color="#E5E5E5"> with every object</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so</font>

121
00:05:07,590 --> 00:05:11,820
let's say you<font color="#E5E5E5"> wanted to look up the</font>

122
00:05:09,300 --> 00:05:14,490
property<font color="#E5E5E5"> X on this object</font><font color="#CCCCCC"> what you would</font>

123
00:05:11,820 --> 00:05:16,260
do is first<font color="#E5E5E5"> go to the shape then you</font>

124
00:05:14,490 --> 00:05:18,780
could see that property<font color="#CCCCCC"> X</font>

125
00:05:16,260 --> 00:05:20,520
distorted slot<font color="#CCCCCC"> 0</font><font color="#E5E5E5"> then you go back to the</font>

126
00:05:18,780 --> 00:05:23,159
object<font color="#E5E5E5"> go to the slots array and then</font>

127
00:05:20,520 --> 00:05:23,900
you find the value 41 so that's how it

128
00:05:23,160 --> 00:05:27,060
works

129
00:05:23,900 --> 00:05:28,650
so you're probably wondering<font color="#E5E5E5"> why why are</font>

130
00:05:27,060 --> 00:05:30,090
they<font color="#E5E5E5"> doing</font><font color="#CCCCCC"> that what the benefit here</font>

131
00:05:28,650 --> 00:05:32,760
let me<font color="#E5E5E5"> show</font><font color="#CCCCCC"> you an example</font>

132
00:05:30,090 --> 00:05:35,190
<font color="#CCCCCC">so again we have the same object X&Y</font>

133
00:05:32,760 --> 00:05:38,370
<font color="#E5E5E5">properties now if we create another</font>

134
00:05:35,190 --> 00:05:41,969
<font color="#CCCCCC">object</font><font color="#E5E5E5"> that similar in the sense that it</font>

135
00:05:38,370 --> 00:05:43,919
also has X&Y properties<font color="#E5E5E5"> now</font><font color="#CCCCCC"> suddenly</font>

136
00:05:41,970 --> 00:05:46,650
those two object they are<font color="#E5E5E5"> able</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> share</font>

137
00:05:43,919 --> 00:05:49,500
the same shape so there's no redundancy

138
00:05:46,650 --> 00:05:51,719
essentially right so that's<font color="#E5E5E5"> the main</font>

139
00:05:49,500 --> 00:05:53,850
benefit here that these shapes they can

140
00:05:51,720 --> 00:05:57,060
be shared<font color="#CCCCCC"> so this they can use to</font>

141
00:05:53,850 --> 00:05:58,650
<font color="#E5E5E5">conserve memory basically yeah and they</font>

142
00:05:57,060 --> 00:06:01,950
<font color="#E5E5E5">are shared between similar objects</font>

143
00:05:58,650 --> 00:06:03,570
essentially so the next<font color="#E5E5E5"> question</font><font color="#CCCCCC"> is well</font>

144
00:06:01,950 --> 00:06:07,020
what happens<font color="#CCCCCC"> if you</font><font color="#E5E5E5"> change one of those</font>

145
00:06:03,570 --> 00:06:10,520
objects<font color="#E5E5E5"> so for</font><font color="#CCCCCC"> example here if you</font><font color="#E5E5E5"> add a</font>

146
00:06:07,020 --> 00:06:12,659
third property<font color="#E5E5E5"> to the first object now</font>

147
00:06:10,520 --> 00:06:14,849
those<font color="#CCCCCC"> two objects they can't really</font>

148
00:06:12,660 --> 00:06:17,130
<font color="#E5E5E5">share the same set shares this shape</font>

149
00:06:14,850 --> 00:06:18,720
anymore because<font color="#E5E5E5"> the second object</font>

150
00:06:17,130 --> 00:06:20,820
<font color="#E5E5E5">doesn't have</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> property</font><font color="#CCCCCC"> so in this</font>

151
00:06:18,720 --> 00:06:21,510
case well we have to separate<font color="#E5E5E5"> those</font>

152
00:06:20,820 --> 00:06:23,880
shapes again

153
00:06:21,510 --> 00:06:27,810
now there's<font color="#E5E5E5"> two one has three</font><font color="#CCCCCC"> property</font>

154
00:06:23,880 --> 00:06:29,969
<font color="#CCCCCC">if the other has two the one important</font>

155
00:06:27,810 --> 00:06:31,710
property here is that shapes are

156
00:06:29,970 --> 00:06:33,780
essentially immutable that's<font color="#E5E5E5"> following</font>

157
00:06:31,710 --> 00:06:39,060
from the from the fact that they are

158
00:06:33,780 --> 00:06:41,159
shared yeah so then next thing<font color="#E5E5E5"> if we</font>

159
00:06:39,060 --> 00:06:42,110
were<font color="#E5E5E5"> to add this third property</font><font color="#CCCCCC"> also</font><font color="#E5E5E5"> to</font>

160
00:06:41,159 --> 00:06:43,840
the second

161
00:06:42,110 --> 00:06:46,610
then again they can share the shape

162
00:06:43,840 --> 00:06:48,859
<font color="#CCCCCC">there's some clever mechanisms that make</font>

163
00:06:46,610 --> 00:06:50,720
this work efficiently<font color="#E5E5E5"> but this is</font>

164
00:06:48,860 --> 00:06:54,950
essentially<font color="#E5E5E5"> how</font><font color="#CCCCCC"> it works</font><font color="#E5E5E5"> what what</font>

165
00:06:50,720 --> 00:06:57,169
happens<font color="#CCCCCC"> so yeah if you look at any</font>

166
00:06:54,950 --> 00:07:00,050
<font color="#CCCCCC">optimator for engines right now and see</font>

167
00:06:57,169 --> 00:07:01,490
<font color="#E5E5E5">if how they implement objects what you</font>

168
00:07:00,050 --> 00:07:03,740
would find<font color="#E5E5E5"> is essentially that all of</font>

169
00:07:01,490 --> 00:07:05,990
them have reference to<font color="#E5E5E5"> this shape object</font>

170
00:07:03,740 --> 00:07:08,060
<font color="#CCCCCC">and that's called differently in all</font>

171
00:07:05,990 --> 00:07:09,850
engines so in<font color="#E5E5E5"> Firefox it's actually -</font>

172
00:07:08,060 --> 00:07:11,540
it's called<font color="#CCCCCC"> shape and the group object</font>

173
00:07:09,850 --> 00:07:13,700
<font color="#CCCCCC">in v8</font>

174
00:07:11,540 --> 00:07:15,770
<font color="#CCCCCC">it's called map</font><font color="#E5E5E5"> in WebKit it's called</font>

175
00:07:13,700 --> 00:07:17,750
structure<font color="#CCCCCC"> and an edge it's called type</font>

176
00:07:15,770 --> 00:07:19,940
but they all do the same<font color="#E5E5E5"> thing they</font><font color="#CCCCCC"> are</font>

177
00:07:17,750 --> 00:07:22,580
shared and immutable<font color="#CCCCCC"> that's the two</font>

178
00:07:19,940 --> 00:07:24,230
important properties<font color="#E5E5E5"> and they fully</font>

179
00:07:22,580 --> 00:07:26,450
describe the object they tell you which

180
00:07:24,230 --> 00:07:30,350
properties it<font color="#CCCCCC"> has where they are stored</font>

181
00:07:26,450 --> 00:07:32,000
what prototype it has<font color="#CCCCCC"> etc</font><font color="#E5E5E5"> then you have</font>

182
00:07:30,350 --> 00:07:34,700
<font color="#E5E5E5">these property slots and usually you</font>

183
00:07:32,000 --> 00:07:36,290
have a<font color="#E5E5E5"> few property slots stored in line</font>

184
00:07:34,700 --> 00:07:40,039
so a<font color="#E5E5E5"> fixed number of in line property</font>

185
00:07:36,290 --> 00:07:41,750
slots<font color="#CCCCCC"> and</font><font color="#E5E5E5"> then you have an out of line</font>

186
00:07:40,040 --> 00:07:43,610
yeah appointed to an out of<font color="#CCCCCC"> line</font>

187
00:07:41,750 --> 00:07:47,120
property slots area that's dynamically

188
00:07:43,610 --> 00:07:50,450
<font color="#E5E5E5">sized where our properties are stored</font>

189
00:07:47,120 --> 00:07:52,640
<font color="#CCCCCC">that don't fit in</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> inline slots so</font>

190
00:07:50,450 --> 00:07:56,719
then the other<font color="#E5E5E5"> thing</font><font color="#CCCCCC"> you have is usually</font>

191
00:07:52,640 --> 00:07:58,159
a buffer<font color="#E5E5E5"> for element storage</font><font color="#CCCCCC"> that's just</font>

192
00:07:56,720 --> 00:08:00,470
due to<font color="#E5E5E5"> the fact</font><font color="#CCCCCC"> that in JavaScript you</font>

193
00:07:58,160 --> 00:08:02,810
<font color="#CCCCCC">can kind of use</font><font color="#E5E5E5"> every object as an area</font>

194
00:08:00,470 --> 00:08:05,060
so they also<font color="#E5E5E5"> have this</font><font color="#CCCCCC"> having a storage</font>

195
00:08:02,810 --> 00:08:07,400
essentially and then you might<font color="#CCCCCC"> have</font>

196
00:08:05,060 --> 00:08:08,330
<font color="#CCCCCC">additional</font><font color="#E5E5E5"> type specific fields so for</font>

197
00:08:07,400 --> 00:08:12,049
example if you have a<font color="#CCCCCC"> regular expression</font>

198
00:08:08,330 --> 00:08:14,109
object or a typed<font color="#E5E5E5"> array object you would</font>

199
00:08:12,050 --> 00:08:16,340
<font color="#E5E5E5">have more data fields in</font><font color="#CCCCCC"> these objects</font>

200
00:08:14,110 --> 00:08:21,080
but these are the main ones the first

201
00:08:16,340 --> 00:08:23,270
vote for all right<font color="#E5E5E5"> so the next</font><font color="#CCCCCC"> thing</font>

202
00:08:21,080 --> 00:08:25,310
<font color="#CCCCCC">we'll talk about</font><font color="#E5E5E5"> is my</font><font color="#CCCCCC"> TD JIT compilers</font>

203
00:08:23,270 --> 00:08:27,200
how they work for<font color="#E5E5E5"> JavaScript so we do</font>

204
00:08:25,310 --> 00:08:30,590
kind of a 10 to 15 minutes tutorial<font color="#E5E5E5"> on</font>

205
00:08:27,200 --> 00:08:32,479
how to compile JavaScript<font color="#CCCCCC"> but first</font>

206
00:08:30,590 --> 00:08:35,689
let's start with<font color="#E5E5E5"> some motivation why do</font>

207
00:08:32,479 --> 00:08:37,520
we want charge it compilers<font color="#CCCCCC"> we</font><font color="#E5E5E5"> all</font>

208
00:08:35,690 --> 00:08:39,349
already<font color="#E5E5E5"> have those interpreters which</font>

209
00:08:37,520 --> 00:08:41,929
can just run our code so what's the

210
00:08:39,349 --> 00:08:44,570
benefit of just-in-time compilers<font color="#E5E5E5"> well</font>

211
00:08:41,929 --> 00:08:47,420
it's probably<font color="#E5E5E5"> quite obvious its code</font>

212
00:08:44,570 --> 00:08:49,370
speed<font color="#CCCCCC"> if you have this optimizing JIT</font>

213
00:08:47,420 --> 00:08:51,939
compiler it's probably running<font color="#E5E5E5"> much</font>

214
00:08:49,370 --> 00:08:56,190
faster<font color="#CCCCCC"> than interpreting your code</font>

215
00:08:51,940 --> 00:08:59,610
<font color="#E5E5E5">however</font><font color="#CCCCCC"> there's some drawbacks also so</font>

216
00:08:56,190 --> 00:09:02,190
one is that the the<font color="#CCCCCC"> startup time of an</font>

217
00:08:59,610 --> 00:09:03,690
interpreter is probably much lower so it

218
00:09:02,190 --> 00:09:05,670
can<font color="#E5E5E5"> just start executing the code</font>

219
00:09:03,690 --> 00:09:08,730
<font color="#CCCCCC">immediately after the bytecode</font><font color="#E5E5E5"> compiler</font>

220
00:09:05,670 --> 00:09:11,729
<font color="#CCCCCC">finishes vs JIT compiler it has to do</font>

221
00:09:08,730 --> 00:09:14,190
this expensive<font color="#CCCCCC"> optimization etc so it</font>

222
00:09:11,730 --> 00:09:17,610
takes a lot longer to to start executing

223
00:09:14,190 --> 00:09:20,880
code<font color="#CCCCCC"> kind of the</font><font color="#E5E5E5"> same with memory the</font>

224
00:09:17,610 --> 00:09:24,900
the interpreters probably using left

225
00:09:20,880 --> 00:09:27,360
memory<font color="#CCCCCC"> then the JIT compiler as such</font>

226
00:09:24,900 --> 00:09:30,120
what what all the major engines engines

227
00:09:27,360 --> 00:09:32,610
do right now is a<font color="#CCCCCC"> half essentially a</font>

228
00:09:30,120 --> 00:09:36,000
multi<font color="#CCCCCC"> tier architecture</font><font color="#E5E5E5"> where they start</font>

229
00:09:32,610 --> 00:09:38,040
running code in the interpreter<font color="#CCCCCC"> then</font>

230
00:09:36,000 --> 00:09:39,870
they monitor how many times<font color="#CCCCCC"> the function</font>

231
00:09:38,040 --> 00:09:41,310
<font color="#E5E5E5">has</font><font color="#CCCCCC"> been called and at some point they</font>

232
00:09:39,870 --> 00:09:43,170
determine<font color="#E5E5E5"> okay this function has</font><font color="#CCCCCC"> been</font>

233
00:09:41,310 --> 00:09:45,900
called a<font color="#E5E5E5"> lot of times</font><font color="#CCCCCC"> it's probably</font>

234
00:09:43,170 --> 00:09:47,699
worth optimizing that<font color="#E5E5E5"> then they put that</font>

235
00:09:45,900 --> 00:09:49,680
through their JIT compiler produces

236
00:09:47,700 --> 00:09:52,500
<font color="#E5E5E5">optimized code and once that's done they</font>

237
00:09:49,680 --> 00:09:54,839
switch to<font color="#CCCCCC"> the machine code so this</font><font color="#E5E5E5"> is</font>

238
00:09:52,500 --> 00:09:57,360
how it works<font color="#CCCCCC"> all right so let's talk</font>

239
00:09:54,840 --> 00:09:59,160
<font color="#CCCCCC">about how</font><font color="#E5E5E5"> to compile JavaScript here's</font>

240
00:09:57,360 --> 00:10:02,460
the<font color="#E5E5E5"> small function</font><font color="#CCCCCC"> javascript functions</font>

241
00:09:59,160 --> 00:10:04,500
<font color="#E5E5E5">just adding two arguments</font><font color="#CCCCCC"> together yeah</font>

242
00:10:02,460 --> 00:10:08,310
how<font color="#E5E5E5"> would you compare this to machine</font>

243
00:10:04,500 --> 00:10:10,440
code<font color="#E5E5E5"> this seems hard right it mainly</font>

244
00:10:08,310 --> 00:10:13,739
<font color="#E5E5E5">seems hard because we have no idea about</font>

245
00:10:10,440 --> 00:10:15,960
types of<font color="#E5E5E5"> the parameters so a and</font><font color="#CCCCCC"> B</font><font color="#E5E5E5"> they</font>

246
00:10:13,740 --> 00:10:17,610
could be numbers but they could also be

247
00:10:15,960 --> 00:10:19,950
strings they could be<font color="#E5E5E5"> objects whatever</font>

248
00:10:17,610 --> 00:10:21,870
<font color="#E5E5E5">we don't really know and this makes</font>

249
00:10:19,950 --> 00:10:23,880
makes it hard to<font color="#E5E5E5"> produce machine code</font>

250
00:10:21,870 --> 00:10:26,370
here<font color="#E5E5E5"> so the the plus operating in</font>

251
00:10:23,880 --> 00:10:28,470
JavaScript it's quite complex<font color="#CCCCCC"> if you</font>

252
00:10:26,370 --> 00:10:31,680
look at the specification<font color="#E5E5E5"> this is the</font>

253
00:10:28,470 --> 00:10:33,300
<font color="#CCCCCC">pseudocode for adding</font><font color="#E5E5E5"> something in</font>

254
00:10:31,680 --> 00:10:35,489
<font color="#CCCCCC">javascript right and all these blue</font>

255
00:10:33,300 --> 00:10:37,589
functions are essentially subroutine so

256
00:10:35,490 --> 00:10:39,930
it's<font color="#E5E5E5"> really complicated and you wouldn't</font>

257
00:10:37,590 --> 00:10:42,720
want<font color="#CCCCCC"> to omit this as machine code all</font>

258
00:10:39,930 --> 00:10:46,109
the<font color="#CCCCCC"> time so that's okay another example</font>

259
00:10:42,720 --> 00:10:48,830
<font color="#CCCCCC">here's another function that just</font>

260
00:10:46,110 --> 00:10:52,500
fetches a property from from an object

261
00:10:48,830 --> 00:10:54,630
<font color="#CCCCCC">again this seems hard</font><font color="#E5E5E5"> to make machine</font>

262
00:10:52,500 --> 00:10:57,660
code for<font color="#CCCCCC"> this same reason we don't</font><font color="#E5E5E5"> know</font>

263
00:10:54,630 --> 00:10:59,370
<font color="#E5E5E5">the type of oh and in particularly we</font>

264
00:10:57,660 --> 00:11:01,079
don't know its shape<font color="#E5E5E5"> so we have no idea</font>

265
00:10:59,370 --> 00:11:03,120
where this property's been<font color="#E5E5E5"> stored</font><font color="#CCCCCC"> could</font>

266
00:11:01,080 --> 00:11:05,190
be anywhere

267
00:11:03,120 --> 00:11:07,800
so what it<font color="#CCCCCC"> means is essentially</font><font color="#E5E5E5"> that the</font>

268
00:11:05,190 --> 00:11:09,329
main major challenge here of JIT

269
00:11:07,800 --> 00:11:11,579
compiling these languages<font color="#CCCCCC"> the</font>

270
00:11:09,329 --> 00:11:14,248
<font color="#E5E5E5">using type information right so that</font>

271
00:11:11,579 --> 00:11:16,859
will be this<font color="#CCCCCC"> song</font><font color="#E5E5E5"> so let's just assume</font>

272
00:11:14,249 --> 00:11:18,989
<font color="#CCCCCC">that</font><font color="#E5E5E5"> for some reason we we had type</font>

273
00:11:16,860 --> 00:11:21,569
<font color="#CCCCCC">information so maybe we had kind of a</font>

274
00:11:18,989 --> 00:11:24,119
<font color="#E5E5E5">JavaScript dialect</font><font color="#CCCCCC"> that the</font><font color="#E5E5E5"> strictly</font>

275
00:11:21,569 --> 00:11:26,849
typed and it tells<font color="#E5E5E5"> us</font><font color="#CCCCCC"> that a NPR Smiths</font>

276
00:11:24,119 --> 00:11:29,220
<font color="#CCCCCC">are</font><font color="#E5E5E5"> these small integers in</font><font color="#CCCCCC"> the 8th</font><font color="#E5E5E5"> can</font>

277
00:11:26,850 --> 00:11:31,559
we produce machine code now turns out we

278
00:11:29,220 --> 00:11:33,720
can<font color="#CCCCCC"> it's that's quite easy actually</font>

279
00:11:31,559 --> 00:11:37,110
we know the<font color="#CCCCCC"> in-memory representation of</font>

280
00:11:33,720 --> 00:11:38,639
<font color="#E5E5E5">Smith's it's just tag pointers again</font><font color="#CCCCCC"> we</font>

281
00:11:37,110 --> 00:11:40,589
can<font color="#E5E5E5"> just add them together in this</font>

282
00:11:38,639 --> 00:11:42,540
<font color="#CCCCCC">representation right so there's machine</font>

283
00:11:40,589 --> 00:11:46,100
instruction you can<font color="#E5E5E5"> use to add registers</font>

284
00:11:42,540 --> 00:11:48,839
so that's quite<font color="#E5E5E5"> easy</font><font color="#CCCCCC"> there's one catch</font>

285
00:11:46,100 --> 00:11:51,899
<font color="#CCCCCC">because in JavaScript there's no integer</font>

286
00:11:48,839 --> 00:11:54,029
<font color="#E5E5E5">overflow essentially so the engine here</font>

287
00:11:51,899 --> 00:11:57,540
has to do what is<font color="#E5E5E5"> called a bailout if</font>

288
00:11:54,029 --> 00:11:58,889
this addition overflows<font color="#CCCCCC"> what it has to</font>

289
00:11:57,540 --> 00:12:02,368
do is essentially go back to the

290
00:11:58,889 --> 00:12:03,869
interpreter<font color="#CCCCCC"> so that the bailout it bails</font>

291
00:12:02,369 --> 00:12:05,579
out to the interpreter and<font color="#CCCCCC"> that</font>

292
00:12:03,869 --> 00:12:08,639
interpreter what it would do in this

293
00:12:05,579 --> 00:12:11,279
case<font color="#CCCCCC"> is convert the arguments</font><font color="#E5E5E5"> to double</font>

294
00:12:08,639 --> 00:12:12,389
it<font color="#E5E5E5"> and then</font><font color="#CCCCCC"> do double addition right</font><font color="#E5E5E5"> but</font>

295
00:12:11,279 --> 00:12:13,889
this<font color="#CCCCCC"> bailout mechanism is quite</font>

296
00:12:12,389 --> 00:12:18,389
important we will see it a few<font color="#CCCCCC"> more</font>

297
00:12:13,889 --> 00:12:20,220
times<font color="#E5E5E5"> right so obviously</font><font color="#CCCCCC"> what we don't</font>

298
00:12:18,389 --> 00:12:23,669
<font color="#E5E5E5">have strictly typed language so we don't</font>

299
00:12:20,220 --> 00:12:25,829
have type information<font color="#E5E5E5"> what we have is or</font>

300
00:12:23,669 --> 00:12:28,559
what<font color="#CCCCCC"> we can have is type information</font>

301
00:12:25,829 --> 00:12:30,868
<font color="#CCCCCC">from</font><font color="#E5E5E5"> previous executions so remember I</font>

302
00:12:28,559 --> 00:12:32,910
<font color="#CCCCCC">said that right now</font><font color="#E5E5E5"> when you run</font>

303
00:12:30,869 --> 00:12:35,459
<font color="#E5E5E5">JavaScript in an engine it first runs it</font>

304
00:12:32,910 --> 00:12:37,199
in the interpreter and only after<font color="#E5E5E5"> some</font>

305
00:12:35,459 --> 00:12:39,569
time it goes<font color="#E5E5E5"> to the JIT compiler so by</font>

306
00:12:37,199 --> 00:12:41,549
the<font color="#E5E5E5"> time</font><font color="#CCCCCC"> we want to</font><font color="#E5E5E5"> compile</font><font color="#CCCCCC"> we do have</font>

307
00:12:39,569 --> 00:12:43,589
type information<font color="#CCCCCC"> from previous run so we</font>

308
00:12:41,549 --> 00:12:46,799
can just keep track of<font color="#E5E5E5"> all the types we</font>

309
00:12:43,589 --> 00:12:49,429
<font color="#E5E5E5">see for</font><font color="#CCCCCC"> every variable so how does</font><font color="#E5E5E5"> this</font>

310
00:12:46,799 --> 00:12:51,809
help us well what we<font color="#E5E5E5"> can do is speculate</font>

311
00:12:49,429 --> 00:12:54,600
<font color="#CCCCCC">then in the future</font><font color="#E5E5E5"> we will see the same</font>

312
00:12:51,809 --> 00:12:55,829
types and this is really the main main

313
00:12:54,600 --> 00:12:58,949
trick here and this is where the name

314
00:12:55,829 --> 00:13:00,508
speculative JIT comes from so<font color="#E5E5E5"> its look</font>

315
00:12:58,949 --> 00:13:02,910
at an example<font color="#CCCCCC"> again here's our add</font>

316
00:13:00,509 --> 00:13:04,709
function<font color="#E5E5E5"> and let's say we</font><font color="#CCCCCC"> we keep track</font>

317
00:13:02,910 --> 00:13:06,959
of<font color="#E5E5E5"> it while it runs in the interpreter</font>

318
00:13:04,709 --> 00:13:09,149
and<font color="#E5E5E5"> this is what we see it's always</font>

319
00:13:06,959 --> 00:13:12,929
being<font color="#E5E5E5"> called with</font><font color="#CCCCCC"> smiths</font><font color="#E5E5E5"> as arguments</font>

320
00:13:09,149 --> 00:13:15,360
<font color="#CCCCCC">okay so at</font><font color="#E5E5E5"> this point when we compile we</font>

321
00:13:12,929 --> 00:13:18,569
speculate<font color="#E5E5E5"> Ted also</font><font color="#CCCCCC"> in the</font><font color="#E5E5E5"> future we will</font>

322
00:13:15,360 --> 00:13:21,629
<font color="#E5E5E5">see sneeze as arguments for this</font>

323
00:13:18,569 --> 00:13:22,949
<font color="#CCCCCC">function so how does this help us right</font>

324
00:13:21,629 --> 00:13:24,779
<font color="#E5E5E5">so now we have we</font>

325
00:13:22,950 --> 00:13:28,110
we have type speculations<font color="#CCCCCC"> for all</font>

326
00:13:24,779 --> 00:13:30,750
variables<font color="#E5E5E5"> what can we do now</font><font color="#CCCCCC"> the trick</font>

327
00:13:28,110 --> 00:13:34,589
is to use<font color="#E5E5E5"> so-called speculation guards</font>

328
00:13:30,750 --> 00:13:37,410
<font color="#E5E5E5">and these are just kind of small pieces</font>

329
00:13:34,589 --> 00:13:39,600
<font color="#CCCCCC">of machine code</font><font color="#E5E5E5"> they ensure</font><font color="#CCCCCC"> that our</font>

330
00:13:37,410 --> 00:13:41,670
speculation still holds at<font color="#E5E5E5"> runtime</font><font color="#CCCCCC"> so</font>

331
00:13:39,600 --> 00:13:44,250
there they are<font color="#CCCCCC"> they come</font><font color="#E5E5E5"> in different</font>

332
00:13:41,670 --> 00:13:46,079
flavors<font color="#E5E5E5"> here's two of them on the right</font>

333
00:13:44,250 --> 00:13:49,800
side you<font color="#CCCCCC"> see a semi guard so that just</font>

334
00:13:46,079 --> 00:13:51,449
<font color="#E5E5E5">makes sure</font><font color="#CCCCCC"> that some variables is me as</font>

335
00:13:49,800 --> 00:13:54,060
we expected so it's checking<font color="#E5E5E5"> this least</font>

336
00:13:51,449 --> 00:13:57,120
significant bit here and if<font color="#E5E5E5"> not it plays</font>

337
00:13:54,060 --> 00:13:59,550
out again<font color="#E5E5E5"> bailout mechanism on the left</font>

338
00:13:57,120 --> 00:14:01,889
<font color="#CCCCCC">side you</font><font color="#E5E5E5"> see a shape guard which makes</font>

339
00:13:59,550 --> 00:14:04,949
sure<font color="#CCCCCC"> that</font><font color="#E5E5E5"> some object has the</font><font color="#CCCCCC"> expected</font>

340
00:14:01,889 --> 00:14:06,570
shape<font color="#E5E5E5"> what it</font><font color="#CCCCCC"> does is just</font><font color="#E5E5E5"> fetch the</font>

341
00:14:04,949 --> 00:14:08,339
shape<font color="#E5E5E5"> pointer from</font><font color="#CCCCCC"> the object compared</font>

342
00:14:06,570 --> 00:14:10,230
to constant<font color="#E5E5E5"> and this works because</font>

343
00:14:08,339 --> 00:14:14,360
shapes are shared and immutable<font color="#CCCCCC"> so</font>

344
00:14:10,230 --> 00:14:17,100
that's why they<font color="#CCCCCC"> are yeah</font><font color="#E5E5E5"> how this works</font>

345
00:14:14,360 --> 00:14:18,720
<font color="#CCCCCC">so it's not good an example again here's</font>

346
00:14:17,100 --> 00:14:21,000
<font color="#E5E5E5">the other function the function that</font>

347
00:14:18,720 --> 00:14:23,250
<font color="#CCCCCC">fetches a property</font><font color="#E5E5E5"> let's say we</font>

348
00:14:21,000 --> 00:14:25,829
<font color="#CCCCCC">speculated all will always be an object</font>

349
00:14:23,250 --> 00:14:27,360
of a specific shape<font color="#E5E5E5"> and then this is</font>

350
00:14:25,829 --> 00:14:29,640
what we could<font color="#E5E5E5"> generate as machine code</font>

351
00:14:27,360 --> 00:14:31,320
<font color="#E5E5E5">so first we have to</font><font color="#CCCCCC"> make sure that</font>

352
00:14:29,640 --> 00:14:33,120
always notice me so we need to have the

353
00:14:31,320 --> 00:14:35,610
inverse me guard that<font color="#CCCCCC"> makes</font><font color="#E5E5E5"> sure it's an</font>

354
00:14:33,120 --> 00:14:38,220
object<font color="#E5E5E5"> again checking the least</font>

355
00:14:35,610 --> 00:14:40,260
significant bit<font color="#CCCCCC"> then we have shape card</font>

356
00:14:38,220 --> 00:14:42,779
<font color="#E5E5E5">that makes sure we have the</font><font color="#CCCCCC"> expected</font>

357
00:14:40,260 --> 00:14:45,750
shape and then at that point<font color="#CCCCCC"> if both of</font>

358
00:14:42,779 --> 00:14:47,160
<font color="#E5E5E5">these cards run through we have type</font>

359
00:14:45,750 --> 00:14:49,140
<font color="#E5E5E5">information we know the shape of this</font>

360
00:14:47,160 --> 00:14:51,480
object<font color="#CCCCCC"> and we can</font><font color="#E5E5E5"> just directly load</font>

361
00:14:49,140 --> 00:14:53,880
this property<font color="#E5E5E5"> from the object so in this</font>

362
00:14:51,480 --> 00:14:55,589
case<font color="#E5E5E5"> maybe property B is stored in an</font>

363
00:14:53,880 --> 00:14:58,800
inline slot so we can just dereference

364
00:14:55,589 --> 00:15:00,510
the pointer basically yeah<font color="#E5E5E5"> what that</font>

365
00:14:58,800 --> 00:15:01,949
means is that essentially<font color="#E5E5E5"> this</font>

366
00:15:00,510 --> 00:15:03,689
speculation guard<font color="#E5E5E5"> they give us type</font>

367
00:15:01,949 --> 00:15:05,640
information<font color="#CCCCCC"> back so that's</font><font color="#E5E5E5"> the main</font>

368
00:15:03,690 --> 00:15:08,940
trick for dealing<font color="#CCCCCC"> with</font><font color="#E5E5E5"> missing type</font>

369
00:15:05,640 --> 00:15:11,370
information<font color="#CCCCCC"> so let's look at kind of a</font>

370
00:15:08,940 --> 00:15:13,500
typical JIT compiler pipeline this is

371
00:15:11,370 --> 00:15:15,269
what you would<font color="#E5E5E5"> see</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> few yeah where'd</font>

372
00:15:13,500 --> 00:15:17,519
you go through the code<font color="#E5E5E5"> basically so</font>

373
00:15:15,269 --> 00:15:20,790
<font color="#E5E5E5">always right now it always starts from</font>

374
00:15:17,519 --> 00:15:23,360
<font color="#CCCCCC">byte code</font><font color="#E5E5E5"> plus value profiles</font><font color="#CCCCCC"> that's not</font>

375
00:15:20,790 --> 00:15:26,310
necessarily like that<font color="#E5E5E5"> so we</font><font color="#CCCCCC"> ate used to</font>

376
00:15:23,360 --> 00:15:28,829
see the the abstract<font color="#E5E5E5"> syntax tree in its</font>

377
00:15:26,310 --> 00:15:31,619
JIT compiler<font color="#E5E5E5"> but right now our engines</font>

378
00:15:28,829 --> 00:15:33,089
say they start from<font color="#E5E5E5"> the byte code</font><font color="#CCCCCC"> then</font>

379
00:15:31,620 --> 00:15:36,089
they convert this<font color="#E5E5E5"> byte code to their own</font>

380
00:15:33,089 --> 00:15:36,750
custom intermediate language<font color="#E5E5E5"> which they</font>

381
00:15:36,089 --> 00:15:38,220
do we can

382
00:15:36,750 --> 00:15:40,530
<font color="#CCCCCC">while the</font><font color="#E5E5E5"> bytecode isn't really there</font>

383
00:15:38,220 --> 00:15:42,420
for<font color="#E5E5E5"> optimizing so they</font><font color="#CCCCCC"> converted</font><font color="#E5E5E5"> to a</font>

384
00:15:40,530 --> 00:15:45,510
<font color="#E5E5E5">different form that's better suited</font><font color="#CCCCCC"> for</font>

385
00:15:42,420 --> 00:15:47,490
optimizing<font color="#E5E5E5"> the code later on</font><font color="#CCCCCC"> then they</font>

386
00:15:45,510 --> 00:15:50,189
do this typing or specializing where

387
00:15:47,490 --> 00:15:52,170
they apply<font color="#E5E5E5"> those</font><font color="#CCCCCC"> right where they look</font>

388
00:15:50,190 --> 00:15:54,870
at those<font color="#E5E5E5"> value profiles to the type</font>

389
00:15:52,170 --> 00:15:56,760
speculations<font color="#E5E5E5"> insert type cards and then</font>

390
00:15:54,870 --> 00:15:58,800
they end up<font color="#E5E5E5"> with this graph or usually</font>

391
00:15:56,760 --> 00:16:01,140
graph based intermediate language<font color="#E5E5E5"> plus</font>

392
00:15:58,800 --> 00:16:03,380
runtime guards<font color="#E5E5E5"> and at this point we</font>

393
00:16:01,140 --> 00:16:05,220
basically<font color="#E5E5E5"> have type information</font>

394
00:16:03,380 --> 00:16:08,160
<font color="#CCCCCC">afterward it kind of looks like</font><font color="#E5E5E5"> a</font>

395
00:16:05,220 --> 00:16:10,590
classic<font color="#E5E5E5"> compiler for like C++ or Java</font>

396
00:16:08,160 --> 00:16:14,370
maybe so they<font color="#E5E5E5"> run a bunch of optimizers</font>

397
00:16:10,590 --> 00:16:15,780
to produce<font color="#E5E5E5"> better faster code they end</font>

398
00:16:14,370 --> 00:16:17,730
up with this optimized intermediate

399
00:16:15,780 --> 00:16:19,380
language<font color="#E5E5E5"> then they have to lower that to</font>

400
00:16:17,730 --> 00:16:21,170
<font color="#E5E5E5">machine code so that's called lowering</font>

401
00:16:19,380 --> 00:16:23,550
selecting machine instructions

402
00:16:21,170 --> 00:16:27,990
<font color="#E5E5E5">allocating registers and so on and then</font>

403
00:16:23,550 --> 00:16:30,270
<font color="#E5E5E5">we end up with machine code so let's sum</font>

404
00:16:27,990 --> 00:16:32,370
<font color="#CCCCCC">this up what we've seen</font><font color="#E5E5E5"> is that major</font>

405
00:16:30,270 --> 00:16:35,069
challenge of JIT compilers<font color="#E5E5E5"> is missing</font>

406
00:16:32,370 --> 00:16:37,080
type information<font color="#E5E5E5"> solution is to first</font>

407
00:16:35,070 --> 00:16:40,230
observe runtime behavior<font color="#CCCCCC"> keep track of</font>

408
00:16:37,080 --> 00:16:42,990
types<font color="#E5E5E5"> then speculate</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> we will see</font>

409
00:16:40,230 --> 00:16:44,820
the same types in the future<font color="#CCCCCC"> gaagh these</font>

410
00:16:42,990 --> 00:16:47,730
<font color="#CCCCCC">speculations with these runtime cards</font>

411
00:16:44,820 --> 00:16:50,400
and then basically<font color="#CCCCCC"> optimize and</font><font color="#E5E5E5"> emit</font>

412
00:16:47,730 --> 00:16:52,380
machine code<font color="#CCCCCC"> if you want to take a look</font>

413
00:16:50,400 --> 00:16:54,510
<font color="#E5E5E5">at this</font><font color="#CCCCCC"> there's</font><font color="#E5E5E5"> a really cool tool from</font>

414
00:16:52,380 --> 00:16:58,260
eh developers it's called<font color="#CCCCCC"> turbo lighter</font>

415
00:16:54,510 --> 00:17:00,330
<font color="#E5E5E5">what it does is basically render their</font>

416
00:16:58,260 --> 00:17:03,780
intermediate<font color="#E5E5E5"> graph based language in a</font>

417
00:17:00,330 --> 00:17:05,670
nice<font color="#CCCCCC"> web base UI</font><font color="#E5E5E5"> so that's what I did</font>

418
00:17:03,780 --> 00:17:08,189
here<font color="#E5E5E5"> I just kind of compiled this</font>

419
00:17:05,670 --> 00:17:09,540
function foo in v8<font color="#CCCCCC"> took a look at this</font>

420
00:17:08,189 --> 00:17:12,720
<font color="#E5E5E5">graph and what you see here</font><font color="#CCCCCC"> is</font>

421
00:17:09,540 --> 00:17:15,359
essentially<font color="#E5E5E5"> data flow graph so parameter</font>

422
00:17:12,720 --> 00:17:17,400
<font color="#CCCCCC">one that's</font><font color="#E5E5E5"> oh it flows into a check heap</font>

423
00:17:15,359 --> 00:17:21,270
object<font color="#CCCCCC"> no that's</font><font color="#E5E5E5"> making sure</font><font color="#CCCCCC"> that it's</font>

424
00:17:17,400 --> 00:17:23,430
me if it<font color="#E5E5E5"> is then it</font><font color="#CCCCCC"> plays</font><font color="#E5E5E5"> out</font><font color="#CCCCCC"> next it</font>

425
00:17:21,270 --> 00:17:24,750
flows into this check<font color="#E5E5E5"> maps</font><font color="#CCCCCC"> node so</font>

426
00:17:23,430 --> 00:17:27,510
that's making<font color="#CCCCCC"> sure it's having the</font>

427
00:17:24,750 --> 00:17:30,450
expected shapes or remember<font color="#E5E5E5"> shape is</font>

428
00:17:27,510 --> 00:17:33,090
called map in<font color="#E5E5E5"> v8 and after these two</font>

429
00:17:30,450 --> 00:17:36,450
checks<font color="#CCCCCC"> it knows the exact type of</font><font color="#E5E5E5"> the</font>

430
00:17:33,090 --> 00:17:42,000
parameter<font color="#CCCCCC"> so it can</font><font color="#E5E5E5"> just load this field</font>

431
00:17:36,450 --> 00:17:44,310
from<font color="#CCCCCC"> upset 24 in this case right</font><font color="#E5E5E5"> so yeah</font>

432
00:17:42,000 --> 00:17:46,350
now we have<font color="#E5E5E5"> kind of a basic idea</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> how</font>

433
00:17:44,310 --> 00:17:48,700
these compilers work so let's talk<font color="#CCCCCC"> about</font>

434
00:17:46,350 --> 00:17:51,530
<font color="#E5E5E5">a tank surface</font>

435
00:17:48,700 --> 00:17:53,000
so here I made<font color="#CCCCCC"> this is my list of kind</font>

436
00:17:51,530 --> 00:17:56,059
of<font color="#CCCCCC"> bug categories</font><font color="#E5E5E5"> that I want to talk</font>

437
00:17:53,000 --> 00:17:58,550
about<font color="#E5E5E5"> in this talk</font><font color="#CCCCCC"> the list is sorted</font>

438
00:17:56,059 --> 00:18:00,110
from basically<font color="#E5E5E5"> classic bugs that don't</font>

439
00:17:58,550 --> 00:18:02,780
<font color="#E5E5E5">really have anything</font><font color="#CCCCCC"> to do with JIT</font>

440
00:18:00,110 --> 00:18:05,149
compilers<font color="#CCCCCC"> to very</font><font color="#E5E5E5"> specific box that you</font>

441
00:18:02,780 --> 00:18:06,740
can<font color="#E5E5E5"> only find there right so the first</font>

442
00:18:05,150 --> 00:18:09,740
<font color="#E5E5E5">one</font><font color="#CCCCCC"> is memory corruption in the compiler</font>

443
00:18:06,740 --> 00:18:11,450
<font color="#E5E5E5">that's kind of obvious because</font><font color="#CCCCCC"> these</font>

444
00:18:09,740 --> 00:18:13,760
compilers<font color="#E5E5E5"> are written in C or C++</font>

445
00:18:11,450 --> 00:18:15,830
<font color="#E5E5E5">actually so they can have all these</font>

446
00:18:13,760 --> 00:18:18,500
standard box right overflows you<font color="#CCCCCC"> dr.</font>

447
00:18:15,830 --> 00:18:20,330
<font color="#CCCCCC">trees etc</font><font color="#E5E5E5"> so it's really not specific to</font>

448
00:18:18,500 --> 00:18:23,630
JIT compilers at all<font color="#CCCCCC"> and we</font><font color="#E5E5E5"> actually</font>

449
00:18:20,330 --> 00:18:26,240
won't talk about<font color="#E5E5E5"> them any further</font><font color="#CCCCCC"> the</font>

450
00:18:23,630 --> 00:18:28,040
next<font color="#CCCCCC"> two</font><font color="#E5E5E5"> categories here are bugs in the</font>

451
00:18:26,240 --> 00:18:29,780
<font color="#E5E5E5">lowering phase where it converts to</font>

452
00:18:28,040 --> 00:18:32,300
<font color="#CCCCCC">machine code so we'll talk about that</font><font color="#E5E5E5"> a</font>

453
00:18:29,780 --> 00:18:34,730
bit<font color="#CCCCCC"> if there's time at the end</font><font color="#E5E5E5"> I</font><font color="#CCCCCC"> can</font>

454
00:18:32,300 --> 00:18:37,100
show<font color="#CCCCCC"> some example a box</font><font color="#E5E5E5"> of mine for for</font>

455
00:18:34,730 --> 00:18:39,980
these two<font color="#CCCCCC"> categories if not then you can</font>

456
00:18:37,100 --> 00:18:42,919
find them on<font color="#CCCCCC"> the slides afterwards so</font>

457
00:18:39,980 --> 00:18:44,450
then the biggest<font color="#E5E5E5"> part at the biggest</font>

458
00:18:42,920 --> 00:18:46,160
categories<font color="#CCCCCC"> that I want to talk about</font>

459
00:18:44,450 --> 00:18:48,679
it's incorrect optimizations<font color="#CCCCCC"> so we'll</font>

460
00:18:46,160 --> 00:18:50,059
<font color="#E5E5E5">spend a lot of time there and then at</font>

461
00:18:48,679 --> 00:18:52,070
the end I'll talk about<font color="#CCCCCC"> everything that</font>

462
00:18:50,059 --> 00:18:56,090
I didn't talk about<font color="#E5E5E5"> because not</font><font color="#CCCCCC"> enough</font>

463
00:18:52,070 --> 00:18:59,330
time<font color="#E5E5E5"> just</font><font color="#CCCCCC"> very briefly yeah you can also</font>

464
00:18:56,090 --> 00:19:01,399
divide this like this<font color="#E5E5E5"> so basically the</font>

465
00:18:59,330 --> 00:19:03,740
memory corruption box they would create

466
00:19:01,400 --> 00:19:05,600
<font color="#E5E5E5">a compile time right because the</font>

467
00:19:03,740 --> 00:19:08,780
compiler<font color="#E5E5E5"> itself has a memory corruption</font>

468
00:19:05,600 --> 00:19:10,250
<font color="#CCCCCC">bug versus all the others they only</font>

469
00:19:08,780 --> 00:19:12,500
crash at run time while they they

470
00:19:10,250 --> 00:19:14,630
produce<font color="#CCCCCC"> for the conditions at runtime</font>

471
00:19:12,500 --> 00:19:17,179
<font color="#CCCCCC">right</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> they're</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> bit more interesting</font>

472
00:19:14,630 --> 00:19:20,900
<font color="#CCCCCC">I think so</font><font color="#E5E5E5"> let's start with the first</font>

473
00:19:17,179 --> 00:19:23,240
<font color="#E5E5E5">one that's the slow path handlers so if</font>

474
00:19:20,900 --> 00:19:25,580
you look at basically this<font color="#E5E5E5"> lower ring</font>

475
00:19:23,240 --> 00:19:28,520
code where they convert from their own

476
00:19:25,580 --> 00:19:31,010
intermediate language<font color="#E5E5E5"> to machine code</font><font color="#CCCCCC"> it</font>

477
00:19:28,520 --> 00:19:32,900
<font color="#E5E5E5">usually looks like like this where they</font>

478
00:19:31,010 --> 00:19:35,000
just have<font color="#CCCCCC"> one function for every</font>

479
00:19:32,900 --> 00:19:36,770
operation<font color="#E5E5E5"> or every instruction in the</font>

480
00:19:35,000 --> 00:19:38,230
intermediate<font color="#CCCCCC"> language and this function</font>

481
00:19:36,770 --> 00:19:40,820
<font color="#E5E5E5">is responsible for</font><font color="#CCCCCC"> turning that</font>

482
00:19:38,230 --> 00:19:44,210
<font color="#E5E5E5">operation into machine code</font><font color="#CCCCCC"> so here's</font>

483
00:19:40,820 --> 00:19:47,000
one one example<font color="#E5E5E5"> yeah</font>

484
00:19:44,210 --> 00:19:50,030
what it might look like<font color="#E5E5E5"> usually then</font>

485
00:19:47,000 --> 00:19:55,190
there's a few different cases<font color="#CCCCCC"> so there's</font>

486
00:19:50,030 --> 00:19:56,570
one case or<font color="#E5E5E5"> a few cases where they know</font>

487
00:19:55,190 --> 00:19:58,370
the type<font color="#CCCCCC"> information and the type</font>

488
00:19:56,570 --> 00:20:00,050
information<font color="#E5E5E5"> is so that they can</font>

489
00:19:58,370 --> 00:20:01,809
specialize essentially so it's kind of

490
00:20:00,050 --> 00:20:04,269
the<font color="#CCCCCC"> Fastpass so</font><font color="#E5E5E5"> let's</font>

491
00:20:01,809 --> 00:20:06,629
<font color="#CCCCCC">he wanted</font><font color="#E5E5E5"> to compile an addition</font>

492
00:20:04,269 --> 00:20:09,729
operation<font color="#CCCCCC"> and you knew that</font><font color="#E5E5E5"> your your</font>

493
00:20:06,629 --> 00:20:11,109
incoming arguments are always<font color="#E5E5E5"> Smith so</font>

494
00:20:09,729 --> 00:20:13,299
in that case you can<font color="#CCCCCC"> just submit machine</font>

495
00:20:11,109 --> 00:20:15,850
code as we saw it but<font color="#E5E5E5"> then there's the</font>

496
00:20:13,299 --> 00:20:17,679
other<font color="#E5E5E5"> case where maybe all you know</font><font color="#CCCCCC"> that</font>

497
00:20:15,850 --> 00:20:20,379
the<font color="#E5E5E5"> argument could be an object or could</font>

498
00:20:17,679 --> 00:20:23,350
be a string or<font color="#CCCCCC"> whatever and in that</font><font color="#E5E5E5"> case</font>

499
00:20:20,379 --> 00:20:24,699
you don't really want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> omit this whole</font>

500
00:20:23,350 --> 00:20:26,619
<font color="#CCCCCC">pseudocode that we looked at</font><font color="#E5E5E5"> right that</font>

501
00:20:24,700 --> 00:20:29,499
<font color="#E5E5E5">was kind of a big list so what you would</font>

502
00:20:26,619 --> 00:20:31,539
do is just<font color="#E5E5E5"> kind of</font><font color="#CCCCCC"> emit a call to a</font>

503
00:20:29,499 --> 00:20:34,690
runtime function to a C++ function that

504
00:20:31,539 --> 00:20:37,239
<font color="#E5E5E5">then implements this big plus operation</font>

505
00:20:34,690 --> 00:20:39,340
<font color="#E5E5E5">here right</font><font color="#CCCCCC"> so the takeaway here is</font>

506
00:20:37,239 --> 00:20:41,559
essentially<font color="#E5E5E5"> that this function that's</font>

507
00:20:39,340 --> 00:20:44,349
being called this low pass operation<font color="#CCCCCC"> XYZ</font>

508
00:20:41,559 --> 00:20:46,389
in this code here that's just<font color="#E5E5E5"> kind of a</font>

509
00:20:44,349 --> 00:20:47,710
<font color="#E5E5E5">built-in</font><font color="#CCCCCC"> function like all the other</font>

510
00:20:46,389 --> 00:20:50,228
buildings<font color="#E5E5E5"> in</font><font color="#CCCCCC"> this engine that's</font><font color="#E5E5E5"> a</font>

511
00:20:47,710 --> 00:20:52,210
function<font color="#CCCCCC"> that's implementing in C++ it</font>

512
00:20:50,229 --> 00:20:54,820
takes JavaScript<font color="#CCCCCC"> they use</font><font color="#E5E5E5"> does something</font>

513
00:20:52,210 --> 00:20:57,190
return to JavaScript value so you can

514
00:20:54,820 --> 00:21:01,389
just audit it like all those kind<font color="#E5E5E5"> of</font>

515
00:20:57,190 --> 00:21:03,299
classic JavaScript engine<font color="#E5E5E5"> bugs right so</font>

516
00:21:01,389 --> 00:21:06,219
then<font color="#E5E5E5"> let's look at the other paths here</font>

517
00:21:03,299 --> 00:21:08,679
let's say we<font color="#CCCCCC"> can</font><font color="#E5E5E5"> specialize because we</font>

518
00:21:06,220 --> 00:21:10,779
know that the arguments are<font color="#CCCCCC"> maybe quite</font>

519
00:21:08,679 --> 00:21:14,529
favorable they are only<font color="#E5E5E5"> always integers</font>

520
00:21:10,779 --> 00:21:16,450
maybe<font color="#E5E5E5"> so in this case this is this is</font>

521
00:21:14,529 --> 00:21:19,840
somewhat what you would see in these

522
00:21:16,450 --> 00:21:21,999
<font color="#E5E5E5">these engines in the code what they do</font>

523
00:21:19,840 --> 00:21:24,639
is usually<font color="#E5E5E5"> kind of allocate a register</font>

524
00:21:21,999 --> 00:21:26,289
maybe for the results<font color="#CCCCCC"> then emits a</font>

525
00:21:24,639 --> 00:21:29,099
<font color="#E5E5E5">machine code to perform</font><font color="#CCCCCC"> the operation in</font>

526
00:21:26,289 --> 00:21:30,340
<font color="#E5E5E5">this case like an integer multiplication</font>

527
00:21:29,099 --> 00:21:32,379
yeah

528
00:21:30,340 --> 00:21:34,689
jump<font color="#E5E5E5"> if overflow in this case is also</font>

529
00:21:32,379 --> 00:21:37,418
required<font color="#E5E5E5"> and then they set the result</font>

530
00:21:34,690 --> 00:21:41,769
right so yeah it's<font color="#E5E5E5"> really just a code</font>

531
00:21:37,419 --> 00:21:43,479
generator<font color="#E5E5E5"> that emits machine code so</font>

532
00:21:41,769 --> 00:21:45,809
yeah what could<font color="#CCCCCC"> it what could go wrong</font>

533
00:21:43,479 --> 00:21:47,859
<font color="#E5E5E5">with</font><font color="#CCCCCC"> this what what</font><font color="#E5E5E5"> could happen</font>

534
00:21:45,809 --> 00:21:49,299
essentially this isn't too<font color="#CCCCCC"> different</font>

535
00:21:47,859 --> 00:21:51,449
from<font color="#CCCCCC"> the</font><font color="#E5E5E5"> previous one right so the</font>

536
00:21:49,299 --> 00:21:54,429
previous<font color="#CCCCCC"> example though it was C++ code</font>

537
00:21:51,450 --> 00:21:56,769
that's doing<font color="#E5E5E5"> something now this is C++</font>

538
00:21:54,429 --> 00:21:58,989
code that produces machine code that

539
00:21:56,769 --> 00:22:00,789
<font color="#E5E5E5">then does</font><font color="#CCCCCC"> something right</font><font color="#E5E5E5"> so you could</font>

540
00:21:58,989 --> 00:22:04,509
essentially<font color="#E5E5E5"> have all the same box in</font>

541
00:22:00,789 --> 00:22:06,309
this and in code<font color="#CCCCCC"> like this one thing</font>

542
00:22:04,509 --> 00:22:08,109
that<font color="#E5E5E5"> happened a few</font><font color="#CCCCCC"> times is missing</font>

543
00:22:06,309 --> 00:22:11,619
integer overflow checks right so this<font color="#CCCCCC"> is</font>

544
00:22:08,109 --> 00:22:13,899
always a problem<font color="#CCCCCC"> you can do the same</font>

545
00:22:11,619 --> 00:22:15,189
<font color="#CCCCCC">bugs with this kind of</font><font color="#E5E5E5"> code there's some</font>

546
00:22:13,899 --> 00:22:16,419
other stuff so<font color="#E5E5E5"> for example you</font>

547
00:22:15,190 --> 00:22:19,660
see here it has<font color="#CCCCCC"> to do register a</font>

548
00:22:16,420 --> 00:22:21,190
<font color="#CCCCCC">location that might</font><font color="#E5E5E5"> be tricky so</font><font color="#CCCCCC"> they're</font>

549
00:22:19,660 --> 00:22:23,050
<font color="#CCCCCC">in some box with register allocation</font>

550
00:22:21,190 --> 00:22:26,950
here that you<font color="#E5E5E5"> wouldn't have in the C++</font>

551
00:22:23,050 --> 00:22:29,560
<font color="#CCCCCC">code</font><font color="#E5E5E5"> but really it's it's yeah kind of</font>

552
00:22:26,950 --> 00:22:33,010
<font color="#E5E5E5">to the same kind of JavaScript engine</font>

553
00:22:29,560 --> 00:22:34,629
box that you will find elsewhere<font color="#CCCCCC"> so</font>

554
00:22:33,010 --> 00:22:36,310
let's now talk about<font color="#CCCCCC"> optimization so</font>

555
00:22:34,630 --> 00:22:39,280
this is the biggest chapter that I want

556
00:22:36,310 --> 00:22:41,950
to<font color="#E5E5E5"> talk about</font><font color="#CCCCCC"> incorrect optimizations so</font>

557
00:22:39,280 --> 00:22:43,420
<font color="#CCCCCC">what is an optimization first it's</font>

558
00:22:41,950 --> 00:22:46,150
basically a transformation<font color="#E5E5E5"> of code that</font>

559
00:22:43,420 --> 00:22:48,100
<font color="#E5E5E5">is not required for correctness but</font>

560
00:22:46,150 --> 00:22:50,740
<font color="#E5E5E5">improved speed right so here's a simple</font>

561
00:22:48,100 --> 00:22:52,959
<font color="#CCCCCC">example we have</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> function here</font>

562
00:22:50,740 --> 00:22:55,690
circumference computes circumference of

563
00:22:52,960 --> 00:22:57,880
<font color="#CCCCCC">a</font><font color="#E5E5E5"> circle</font><font color="#CCCCCC"> and in</font><font color="#E5E5E5"> this case a compiler</font>

564
00:22:55,690 --> 00:23:00,520
could notice that this<font color="#CCCCCC"> expression 2</font>

565
00:22:57,880 --> 00:23:02,470
times<font color="#E5E5E5"> pi is actually constant so it</font>

566
00:23:00,520 --> 00:23:05,020
could just<font color="#CCCCCC"> pre</font><font color="#E5E5E5"> compute that at compile</font>

567
00:23:02,470 --> 00:23:07,240
time<font color="#E5E5E5"> and yeah insert that constant here</font>

568
00:23:05,020 --> 00:23:08,980
<font color="#E5E5E5">and save a multiplication at runtime</font><font color="#CCCCCC"> so</font>

569
00:23:07,240 --> 00:23:11,170
that's<font color="#E5E5E5"> called constant folding it's very</font>

570
00:23:08,980 --> 00:23:13,390
basic<font color="#CCCCCC"> optimization and there's a bunch</font>

571
00:23:11,170 --> 00:23:15,270
<font color="#CCCCCC">of others</font><font color="#E5E5E5"> should look at those</font><font color="#CCCCCC"> compilers</font>

572
00:23:13,390 --> 00:23:17,890
<font color="#CCCCCC">a huge</font><font color="#E5E5E5"> list of optimizations they do</font>

573
00:23:15,270 --> 00:23:19,660
<font color="#E5E5E5">some of them are quite complex quite</font>

574
00:23:17,890 --> 00:23:21,990
dangerous of that goes wrong<font color="#CCCCCC"> that</font>

575
00:23:19,660 --> 00:23:25,660
usually results in pretty nice bugs<font color="#E5E5E5"> and</font>

576
00:23:21,990 --> 00:23:27,130
<font color="#E5E5E5">you will talk about two of those so the</font>

577
00:23:25,660 --> 00:23:28,870
first one is parts check elimination

578
00:23:27,130 --> 00:23:30,490
<font color="#E5E5E5">right it sounds pretty dangerous already</font>

579
00:23:28,870 --> 00:23:32,860
so that's yeah it is

580
00:23:30,490 --> 00:23:34,060
turns out the<font color="#E5E5E5"> other three diamonds the</font>

581
00:23:32,860 --> 00:23:36,669
elimination<font color="#E5E5E5"> that we'll talk about later</font>

582
00:23:34,060 --> 00:23:41,080
<font color="#E5E5E5">so</font><font color="#CCCCCC"> let's talk about bounds checking</font>

583
00:23:36,670 --> 00:23:42,880
first here's<font color="#E5E5E5"> some code what what it does</font>

584
00:23:41,080 --> 00:23:45,460
is just<font color="#E5E5E5"> a function</font><font color="#CCCCCC"> that you give an</font>

585
00:23:42,880 --> 00:23:49,180
index it fetches<font color="#CCCCCC"> 13x</font><font color="#E5E5E5"> from an area from a</font>

586
00:23:45,460 --> 00:23:50,800
global array<font color="#CCCCCC"> if you compile that in</font>

587
00:23:49,180 --> 00:23:52,440
<font color="#CCCCCC">bieed and you again look at this</font><font color="#E5E5E5"> code</font>

588
00:23:50,800 --> 00:23:54,820
<font color="#E5E5E5">graph here this is what you would see</font>

589
00:23:52,440 --> 00:23:57,490
<font color="#E5E5E5">again</font><font color="#CCCCCC"> the data flow graphs or has</font><font color="#E5E5E5"> this</font>

590
00:23:54,820 --> 00:23:59,169
parameter<font color="#CCCCCC"> one the index it flows into</font>

591
00:23:57,490 --> 00:24:02,470
this check<font color="#CCCCCC"> bounced node and this makes</font>

592
00:23:59,170 --> 00:24:05,890
sure<font color="#CCCCCC"> that I is between zero and</font><font color="#E5E5E5"> 4095</font>

593
00:24:02,470 --> 00:24:08,320
if it's not again<font color="#E5E5E5"> bailout</font><font color="#CCCCCC"> dimittis then</font>

594
00:24:05,890 --> 00:24:10,990
<font color="#E5E5E5">okay that's</font><font color="#CCCCCC"> inbound so we can just index</font>

595
00:24:08,320 --> 00:24:12,669
into this<font color="#E5E5E5"> array so that's our good</font><font color="#CCCCCC"> and</font>

596
00:24:10,990 --> 00:24:16,330
we need to check here because I could<font color="#E5E5E5"> be</font>

597
00:24:12,670 --> 00:24:18,820
yeah arbitrarily large so let's say I

598
00:24:16,330 --> 00:24:21,669
added another<font color="#E5E5E5"> statement here</font><font color="#CCCCCC"> in this</font>

599
00:24:18,820 --> 00:24:25,389
<font color="#E5E5E5">case what I'm doing is just ending the</font>

600
00:24:21,670 --> 00:24:26,980
index was hex<font color="#CCCCCC"> ffff and in this case the</font>

601
00:24:25,390 --> 00:24:28,280
<font color="#CCCCCC">boss check isn't</font><font color="#E5E5E5"> really required right</font>

602
00:24:26,980 --> 00:24:30,950
because

603
00:24:28,280 --> 00:24:36,500
the output<font color="#E5E5E5"> of this</font><font color="#CCCCCC"> and operation must be</font>

604
00:24:30,950 --> 00:24:38,750
<font color="#E5E5E5">between zero and hex FFF so this is the</font>

605
00:24:36,500 --> 00:24:41,420
goal of<font color="#CCCCCC"> elimination essentially figure</font>

606
00:24:38,750 --> 00:24:44,450
out what our checks are redundant<font color="#E5E5E5"> or</font>

607
00:24:41,420 --> 00:24:46,310
aren't required<font color="#CCCCCC"> the idea is to perform</font>

608
00:24:44,450 --> 00:24:48,620
what is<font color="#CCCCCC"> called range analysis so</font>

609
00:24:46,310 --> 00:24:50,780
essentially track all the possible value

610
00:24:48,620 --> 00:24:53,600
ranges of integers<font color="#E5E5E5"> in the in the</font>

611
00:24:50,780 --> 00:24:55,520
intermediate code<font color="#CCCCCC"> and then if it can</font>

612
00:24:53,600 --> 00:24:57,290
prove<font color="#E5E5E5"> that an index will always be in</font>

613
00:24:55,520 --> 00:24:59,350
<font color="#CCCCCC">bound so it knows the range of the index</font>

614
00:24:57,290 --> 00:25:02,240
it knows the range of the array length

615
00:24:59,350 --> 00:25:04,850
<font color="#E5E5E5">so if the biggest index is always</font><font color="#CCCCCC"> left</font>

616
00:25:02,240 --> 00:25:07,490
in the least area length and it can

617
00:25:04,850 --> 00:25:10,010
eliminate the<font color="#CCCCCC"> powers check so we can</font>

618
00:25:07,490 --> 00:25:13,580
kind of see that here again<font color="#E5E5E5"> the Scout</font>

619
00:25:10,010 --> 00:25:16,040
craft<font color="#E5E5E5"> for the speed of code so what you</font>

620
00:25:13,580 --> 00:25:18,830
see is that parameter<font color="#CCCCCC"> one it floats</font><font color="#E5E5E5"> into</font>

621
00:25:16,040 --> 00:25:21,889
this<font color="#E5E5E5"> bitwise</font><font color="#CCCCCC"> N</font><font color="#E5E5E5"> and the compiler at this</font>

622
00:25:18,830 --> 00:25:24,199
point it figured out that the output of

623
00:25:21,890 --> 00:25:27,860
this<font color="#CCCCCC"> speed wise and must always be</font>

624
00:25:24,200 --> 00:25:30,410
between<font color="#E5E5E5"> zero and 4095</font><font color="#CCCCCC"> so later when</font><font color="#E5E5E5"> it</font>

625
00:25:27,860 --> 00:25:32,120
lowers this code to machine code<font color="#E5E5E5"> it</font>

626
00:25:30,410 --> 00:25:33,590
realizes that the check<font color="#E5E5E5"> bounced no</font>

627
00:25:32,120 --> 00:25:36,320
<font color="#E5E5E5">that's</font><font color="#CCCCCC"> actually</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> required because the</font>

628
00:25:33,590 --> 00:25:38,600
<font color="#E5E5E5">input</font><font color="#CCCCCC"> is already in that</font><font color="#E5E5E5"> range so we'll</font>

629
00:25:36,320 --> 00:25:42,530
just eliminate the<font color="#E5E5E5"> bounce check at that</font>

630
00:25:38,600 --> 00:25:44,719
point<font color="#E5E5E5"> basically all right so what could</font>

631
00:25:42,530 --> 00:25:47,629
<font color="#E5E5E5">go wrong with this</font><font color="#CCCCCC"> well quite a few</font>

632
00:25:44,720 --> 00:25:50,360
things<font color="#E5E5E5"> basically every</font><font color="#CCCCCC"> time you have</font>

633
00:25:47,630 --> 00:25:52,100
<font color="#CCCCCC">kind of a discrepancy between</font><font color="#E5E5E5"> the value</font>

634
00:25:50,360 --> 00:25:55,250
range<font color="#E5E5E5"> is computed by the compiler and</font>

635
00:25:52,100 --> 00:25:56,600
the<font color="#E5E5E5"> actual value range</font><font color="#CCCCCC"> that's a</font><font color="#E5E5E5"> buck for</font>

636
00:25:55,250 --> 00:25:58,790
this<font color="#CCCCCC"> pulse check elimination</font>

637
00:25:56,600 --> 00:26:01,429
so why would<font color="#CCCCCC"> that happen there's a few</font>

638
00:25:58,790 --> 00:26:04,760
reasons one<font color="#E5E5E5"> is due</font><font color="#CCCCCC"> to integer related</font>

639
00:26:01,430 --> 00:26:06,320
problems so integers are hard yeah we

640
00:26:04,760 --> 00:26:08,240
kind<font color="#E5E5E5"> of all know this or</font><font color="#CCCCCC"> there's sinus</font>

641
00:26:06,320 --> 00:26:10,909
issues there's overflow problems and

642
00:26:08,240 --> 00:26:14,270
this range analysis is<font color="#CCCCCC"> here has</font><font color="#E5E5E5"> track</font>

643
00:26:10,910 --> 00:26:16,370
integers has to<font color="#E5E5E5"> really do a lot of on</font>

644
00:26:14,270 --> 00:26:18,889
integers so it might run into any of

645
00:26:16,370 --> 00:26:21,469
<font color="#E5E5E5">these standard integer related problems</font>

646
00:26:18,890 --> 00:26:24,050
the other<font color="#E5E5E5"> source of</font><font color="#CCCCCC"> Parts is essentially</font>

647
00:26:21,470 --> 00:26:26,360
incorrect<font color="#E5E5E5"> emulation of this compiler</font>

648
00:26:24,050 --> 00:26:27,950
<font color="#E5E5E5">intermediate language so remember the</font>

649
00:26:26,360 --> 00:26:30,229
previous<font color="#E5E5E5"> slide where I had this</font><font color="#CCCCCC"> bitwise</font>

650
00:26:27,950 --> 00:26:32,150
<font color="#CCCCCC">and</font><font color="#E5E5E5"> the compiler essentially had to</font>

651
00:26:30,230 --> 00:26:34,340
emulate this bitwise and to figure<font color="#E5E5E5"> out</font>

652
00:26:32,150 --> 00:26:37,110
that the result would always be between

653
00:26:34,340 --> 00:26:39,240
<font color="#CCCCCC">0 and 4095</font>

654
00:26:37,110 --> 00:26:40,949
<font color="#CCCCCC">no bid wise and it's simple that's</font><font color="#E5E5E5"> quite</font>

655
00:26:39,240 --> 00:26:43,170
easy<font color="#CCCCCC"> to emulate</font><font color="#E5E5E5"> but there's a few others</font>

656
00:26:40,950 --> 00:26:45,120
it might<font color="#E5E5E5"> be</font><font color="#CCCCCC"> a bit more tricky and that's</font>

657
00:26:43,170 --> 00:26:48,270
a<font color="#E5E5E5"> really cool bug</font><font color="#CCCCCC"> I like from</font><font color="#E5E5E5"> a good</font>

658
00:26:45,120 --> 00:26:50,340
<font color="#E5E5E5">friend of mine</font><font color="#CCCCCC"> Stefan found NVH and</font>

659
00:26:48,270 --> 00:26:52,020
that's what we look at<font color="#E5E5E5"> now so there's</font>

660
00:26:50,340 --> 00:26:54,809
this<font color="#E5E5E5"> function called string</font><font color="#CCCCCC"> dot last</font>

661
00:26:52,020 --> 00:26:56,400
index<font color="#E5E5E5"> off</font><font color="#CCCCCC"> you can call on a string</font><font color="#E5E5E5"> what</font>

662
00:26:54,809 --> 00:26:59,428
it does is to<font color="#CCCCCC"> give it a search failure</font>

663
00:26:56,400 --> 00:27:01,590
and it tells<font color="#E5E5E5"> you the last index where is</font>

664
00:26:59,429 --> 00:27:03,000
this search value occurs in the string

665
00:27:01,590 --> 00:27:04,409
so you<font color="#E5E5E5"> might be</font><font color="#CCCCCC"> searching for character</font>

666
00:27:03,000 --> 00:27:07,559
or whatever

667
00:27:04,410 --> 00:27:10,429
now the<font color="#CCCCCC"> v8 engine it put</font><font color="#E5E5E5"> what it try to</font>

668
00:27:07,559 --> 00:27:13,370
do is essentially<font color="#CCCCCC"> inline this</font><font color="#E5E5E5"> this call</font>

669
00:27:10,429 --> 00:27:16,290
to this function<font color="#E5E5E5"> and it would try to</font>

670
00:27:13,370 --> 00:27:19,439
predict the<font color="#CCCCCC"> the</font><font color="#E5E5E5"> output value of that</font>

671
00:27:16,290 --> 00:27:21,590
call so lastly<font color="#CCCCCC"> next off what it can</font>

672
00:27:19,440 --> 00:27:24,450
return is essentially negative<font color="#CCCCCC"> 1 in case</font>

673
00:27:21,590 --> 00:27:27,059
this search<font color="#E5E5E5"> value isn't</font><font color="#CCCCCC"> found or it</font>

674
00:27:24,450 --> 00:27:29,220
gives<font color="#E5E5E5"> you an index so what they saw</font><font color="#CCCCCC"> they</font>

675
00:27:27,059 --> 00:27:31,049
said well the the<font color="#CCCCCC"> return value of</font><font color="#E5E5E5"> this</font>

676
00:27:29,220 --> 00:27:33,450
call it must be an integer between

677
00:27:31,049 --> 00:27:36,360
<font color="#E5E5E5">negative 1 and the maximum</font><font color="#CCCCCC"> length of the</font>

678
00:27:33,450 --> 00:27:38,309
<font color="#E5E5E5">string</font><font color="#CCCCCC"> minus 1 right because it's an</font>

679
00:27:36,360 --> 00:27:41,909
index<font color="#CCCCCC"> so</font><font color="#E5E5E5"> it's left and must be less than</font>

680
00:27:38,309 --> 00:27:43,860
<font color="#CCCCCC">the links or so they thought because if</font>

681
00:27:41,910 --> 00:27:46,200
you look at the documentation there's

682
00:27:43,860 --> 00:27:48,780
this one sentence<font color="#CCCCCC"> that</font><font color="#E5E5E5"> said that an</font>

683
00:27:46,200 --> 00:27:50,790
<font color="#E5E5E5">empty string search value will match at</font>

684
00:27:48,780 --> 00:27:52,889
any index<font color="#CCCCCC"> between 0</font><font color="#E5E5E5"> and the length of</font>

685
00:27:50,790 --> 00:27:55,799
<font color="#E5E5E5">the string so</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> can see that here in</font>

686
00:27:52,890 --> 00:27:57,570
this code snippet<font color="#CCCCCC"> there's the string of</font>

687
00:27:55,799 --> 00:28:00,090
<font color="#CCCCCC">thanks for if I search for the last</font>

688
00:27:57,570 --> 00:28:03,120
<font color="#E5E5E5">index of the string empty string it</font>

689
00:28:00,090 --> 00:28:05,850
<font color="#E5E5E5">actually gives me</font><font color="#CCCCCC"> 4 right</font><font color="#E5E5E5"> what it means</font>

690
00:28:03,120 --> 00:28:08,879
is<font color="#E5E5E5"> that this range of</font><font color="#CCCCCC"> this type</font><font color="#E5E5E5"> or code</font>

691
00:28:05,850 --> 00:28:10,889
here that determined try to<font color="#E5E5E5"> determine</font>

692
00:28:08,880 --> 00:28:13,530
<font color="#E5E5E5">the output range is off by one so</font>

693
00:28:10,890 --> 00:28:16,260
actually<font color="#E5E5E5"> this call can also return</font>

694
00:28:13,530 --> 00:28:18,299
string<font color="#CCCCCC"> not max</font><font color="#E5E5E5"> links so how</font><font color="#CCCCCC"> can you</font>

695
00:28:16,260 --> 00:28:21,960
<font color="#E5E5E5">exploit this this is essentially the</font>

696
00:28:18,299 --> 00:28:24,450
<font color="#E5E5E5">pseudocode that you would need so you</font>

697
00:28:21,960 --> 00:28:26,220
start with<font color="#E5E5E5"> this string of maximum</font>

698
00:28:24,450 --> 00:28:28,500
lengths in this function that's being

699
00:28:26,220 --> 00:28:30,720
compiled<font color="#E5E5E5"> then you do last in makes off</font>

700
00:28:28,500 --> 00:28:32,250
with<font color="#CCCCCC"> an</font><font color="#E5E5E5"> empty string at that point the</font>

701
00:28:30,720 --> 00:28:34,380
compiler syncs the output will<font color="#E5E5E5"> be</font>

702
00:28:32,250 --> 00:28:36,270
between negative 1 and the<font color="#E5E5E5"> maximum</font>

703
00:28:34,380 --> 00:28:38,070
length minus<font color="#E5E5E5"> 1 but it can actually be</font>

704
00:28:36,270 --> 00:28:40,260
between<font color="#E5E5E5"> negative 1 and maximum</font><font color="#CCCCCC"> lengths</font>

705
00:28:38,070 --> 00:28:42,750
so then you add<font color="#CCCCCC"> one just to get rid of</font>

706
00:28:40,260 --> 00:28:44,850
the negative<font color="#E5E5E5"> 1 so again the compiler</font>

707
00:28:42,750 --> 00:28:46,740
<font color="#E5E5E5">sings is between 0 and</font><font color="#CCCCCC"> max lines it can</font>

708
00:28:44,850 --> 00:28:49,980
<font color="#E5E5E5">actually be between 0 and makes things</font>

709
00:28:46,740 --> 00:28:50,600
plus 1<font color="#CCCCCC"> then you use it</font><font color="#E5E5E5"> for an index into</font>

710
00:28:49,980 --> 00:28:53,299
<font color="#E5E5E5">an array</font>

711
00:28:50,600 --> 00:28:55,610
of this<font color="#CCCCCC"> max Ling's plus</font><font color="#E5E5E5"> one science at</font>

712
00:28:53,299 --> 00:28:58,850
that<font color="#CCCCCC"> point the compiler sings well</font>

713
00:28:55,610 --> 00:29:00,139
<font color="#E5E5E5">okay</font><font color="#CCCCCC"> the index is always in balance I</font>

714
00:28:58,850 --> 00:29:03,289
can<font color="#CCCCCC"> just eliminate the bounce check</font>

715
00:29:00,140 --> 00:29:04,669
reality we get out of<font color="#E5E5E5"> bounds</font><font color="#CCCCCC"> access and</font>

716
00:29:03,289 --> 00:29:06,140
if you play around<font color="#E5E5E5"> with it you can</font>

717
00:29:04,669 --> 00:29:07,820
basically get arbitrary<font color="#E5E5E5"> out-of-bounds</font>

718
00:29:06,140 --> 00:29:11,150
<font color="#CCCCCC">access</font><font color="#E5E5E5"> so if you interested</font><font color="#CCCCCC"> I encourage</font>

719
00:29:07,820 --> 00:29:13,370
<font color="#CCCCCC">you to</font><font color="#E5E5E5"> just read</font><font color="#CCCCCC"> the report by</font><font color="#E5E5E5"> Stefan it</font>

720
00:29:11,150 --> 00:29:15,950
contains a full RC exploit for this

721
00:29:13,370 --> 00:29:17,330
<font color="#CCCCCC">packet there's a few more example</font><font color="#E5E5E5"> where</font>

722
00:29:15,950 --> 00:29:19,910
this have happened<font color="#CCCCCC"> so there's some</font>

723
00:29:17,330 --> 00:29:23,780
Firefox box from<font color="#E5E5E5"> a few years ago there's</font>

724
00:29:19,910 --> 00:29:25,610
<font color="#CCCCCC">true blog post</font><font color="#E5E5E5"> by</font><font color="#CCCCCC"> GDI about similar bugs</font>

725
00:29:23,780 --> 00:29:29,330
and then project<font color="#E5E5E5"> also found some of</font>

726
00:29:25,610 --> 00:29:31,250
those<font color="#CCCCCC"> alright</font><font color="#E5E5E5"> so let's talk about the</font>

727
00:29:29,330 --> 00:29:33,740
other optimization<font color="#E5E5E5"> this is redundancy</font>

728
00:29:31,250 --> 00:29:35,990
elimination<font color="#E5E5E5"> first question is well what</font>

729
00:29:33,740 --> 00:29:38,120
<font color="#CCCCCC">is redundancy in this case</font><font color="#E5E5E5"> so let's say</font>

730
00:29:35,990 --> 00:29:41,480
we have this<font color="#CCCCCC"> function that's fetching</font>

731
00:29:38,120 --> 00:29:43,428
two properties<font color="#E5E5E5"> adding them together</font><font color="#CCCCCC"> if</font>

732
00:29:41,480 --> 00:29:45,350
she compiled it's just like in with the

733
00:29:43,429 --> 00:29:47,330
schema we've seen you might end up with

734
00:29:45,350 --> 00:29:50,270
code like this<font color="#E5E5E5"> where it first does the</font>

735
00:29:47,330 --> 00:29:51,770
<font color="#CCCCCC">swee guard and the shaped are then fetch</font>

736
00:29:50,270 --> 00:29:53,690
<font color="#CCCCCC">it's the first</font><font color="#E5E5E5"> property and then it</font>

737
00:29:51,770 --> 00:29:56,120
again does<font color="#CCCCCC"> its me guard shape guard</font>

738
00:29:53,690 --> 00:29:58,610
fetches the second property well in this

739
00:29:56,120 --> 00:30:01,158
case obviously<font color="#E5E5E5"> the second set of guards</font>

740
00:29:58,610 --> 00:30:03,168
is redundant<font color="#E5E5E5"> right there's no way the</font>

741
00:30:01,159 --> 00:30:06,650
<font color="#E5E5E5">shape can change or the think enter into</font>

742
00:30:03,169 --> 00:30:09,140
an integer<font color="#E5E5E5"> in between so in this case</font>

743
00:30:06,650 --> 00:30:12,320
what we want<font color="#E5E5E5"> is this code right the</font>

744
00:30:09,140 --> 00:30:14,659
<font color="#E5E5E5">second set of cards removed so how would</font>

745
00:30:12,320 --> 00:30:16,879
<font color="#E5E5E5">you do this essentially the idea is to</font>

746
00:30:14,659 --> 00:30:19,070
determine duplicate cards on the same

747
00:30:16,880 --> 00:30:22,250
control flow pass and then just keep<font color="#E5E5E5"> the</font>

748
00:30:19,070 --> 00:30:24,860
first one sounds<font color="#E5E5E5"> quite simple</font><font color="#CCCCCC"> it's</font>

749
00:30:22,250 --> 00:30:27,860
actually tricky<font color="#E5E5E5"> because you also need to</font>

750
00:30:24,860 --> 00:30:29,510
<font color="#E5E5E5">keep track</font><font color="#CCCCCC"> of side effects</font><font color="#E5E5E5"> so what is a</font>

751
00:30:27,860 --> 00:30:33,199
side effect well<font color="#E5E5E5"> essentially calling</font>

752
00:30:29,510 --> 00:30:34,700
arbitrary<font color="#E5E5E5"> JavaScript is a side effect</font><font color="#CCCCCC"> so</font>

753
00:30:33,200 --> 00:30:36,679
let's look at<font color="#E5E5E5"> this function</font><font color="#CCCCCC"> here this</font><font color="#E5E5E5"> is</font>

754
00:30:34,700 --> 00:30:38,630
essentially<font color="#E5E5E5"> the previous one just now</font>

755
00:30:36,679 --> 00:30:41,330
I'm doing<font color="#E5E5E5"> a function calling between</font>

756
00:30:38,630 --> 00:30:43,429
<font color="#E5E5E5">calling some JavaScript let's say we did</font>

757
00:30:41,330 --> 00:30:46,309
our redundancy<font color="#E5E5E5"> elimination and this is</font>

758
00:30:43,429 --> 00:30:48,380
what we came up<font color="#CCCCCC"> with first</font><font color="#E5E5E5"> set of cards</font>

759
00:30:46,309 --> 00:30:50,750
<font color="#E5E5E5">then the call to this argument function</font>

760
00:30:48,380 --> 00:30:53,630
<font color="#E5E5E5">here and then no more guards</font><font color="#CCCCCC"> and</font>

761
00:30:50,750 --> 00:30:56,870
<font color="#E5E5E5">directly the property fetch is this</font>

762
00:30:53,630 --> 00:30:58,580
correct<font color="#E5E5E5"> well here's one case where it's</font>

763
00:30:56,870 --> 00:31:01,790
<font color="#CCCCCC">not let's say our callback what it does</font>

764
00:30:58,580 --> 00:31:02,929
is delete the property<font color="#E5E5E5"> B in this case</font>

765
00:31:01,790 --> 00:31:04,670
<font color="#E5E5E5">it's the</font><font color="#CCCCCC"> same</font>

766
00:31:02,930 --> 00:31:07,400
has<font color="#E5E5E5"> changed right as a result of a side</font>

767
00:31:04,670 --> 00:31:09,470
<font color="#E5E5E5">effect so so this axis here</font>

768
00:31:07,400 --> 00:31:12,280
it cannot<font color="#CCCCCC"> be safe we remove this</font>

769
00:31:09,470 --> 00:31:14,360
property<font color="#E5E5E5"> be this this can't be good</font>

770
00:31:12,280 --> 00:31:16,910
so in this case we have to keep<font color="#CCCCCC"> the</font>

771
00:31:14,360 --> 00:31:19,010
shape<font color="#E5E5E5"> guard essentially the second so</font>

772
00:31:16,910 --> 00:31:20,210
that's what you have<font color="#CCCCCC"> to do if if you</font>

773
00:31:19,010 --> 00:31:22,250
realize there's<font color="#E5E5E5"> a</font><font color="#CCCCCC"> side that's a</font>

774
00:31:20,210 --> 00:31:25,820
potential side effect here you have to

775
00:31:22,250 --> 00:31:27,620
keep the<font color="#E5E5E5"> following shape guards right so</font>

776
00:31:25,820 --> 00:31:29,720
this requires<font color="#CCCCCC"> the engine to essentially</font>

777
00:31:27,620 --> 00:31:33,110
be<font color="#CCCCCC"> able</font><font color="#E5E5E5"> to precisely model our side</font>

778
00:31:29,720 --> 00:31:35,570
effects of all the operations in<font color="#E5E5E5"> it</font>

779
00:31:33,110 --> 00:31:36,649
intermediate<font color="#CCCCCC"> language</font><font color="#E5E5E5"> and this is hard</font>

780
00:31:35,570 --> 00:31:38,300
so<font color="#E5E5E5"> javascript</font>

781
00:31:36,650 --> 00:31:40,460
is full of these<font color="#CCCCCC"> callbacks they're</font>

782
00:31:38,300 --> 00:31:42,379
everywhere they've<font color="#E5E5E5"> been a</font><font color="#CCCCCC"> big</font><font color="#E5E5E5"> source of</font>

783
00:31:40,460 --> 00:31:44,900
<font color="#E5E5E5">parts or for for the last years</font>

784
00:31:42,380 --> 00:31:49,400
essentially<font color="#E5E5E5"> and they continue to be yeah</font>

785
00:31:44,900 --> 00:31:50,750
<font color="#CCCCCC">it stores</font><font color="#E5E5E5"> the parts in this</font><font color="#CCCCCC"> case here so</font>

786
00:31:49,400 --> 00:31:53,180
it's not about exploitation how could

787
00:31:50,750 --> 00:31:56,180
you exploit a bug like this for<font color="#E5E5E5"> that we</font>

788
00:31:53,180 --> 00:31:58,220
need<font color="#E5E5E5"> to talk a bit</font><font color="#CCCCCC"> about arrays in</font>

789
00:31:56,180 --> 00:32:00,190
JavaScript<font color="#CCCCCC"> so let's just do</font><font color="#E5E5E5"> this very</font>

790
00:31:58,220 --> 00:32:02,300
quickly here so areas are kind of

791
00:32:00,190 --> 00:32:04,940
commonly<font color="#E5E5E5"> used</font><font color="#CCCCCC"> data structures so the</font>

792
00:32:02,300 --> 00:32:06,649
<font color="#CCCCCC">engine tries to optimize</font><font color="#E5E5E5"> for them let's</font>

793
00:32:04,940 --> 00:32:09,950
say we have an<font color="#E5E5E5"> area</font><font color="#CCCCCC"> that only</font><font color="#E5E5E5"> stores</font>

794
00:32:06,650 --> 00:32:11,990
doubles like in this<font color="#E5E5E5"> case here</font><font color="#CCCCCC"> in that</font>

795
00:32:09,950 --> 00:32:14,510
<font color="#E5E5E5">case the engine would realize okay this</font>

796
00:32:11,990 --> 00:32:17,990
<font color="#E5E5E5">is only storing doubles so it would try</font>

797
00:32:14,510 --> 00:32:19,700
<font color="#CCCCCC">to store these dis values as actual</font>

798
00:32:17,990 --> 00:32:21,440
doubles and<font color="#CCCCCC"> not</font><font color="#E5E5E5"> as JavaScript</font><font color="#CCCCCC"> pages</font>

799
00:32:19,700 --> 00:32:24,140
which are a bit<font color="#CCCCCC"> more expensive because</font>

800
00:32:21,440 --> 00:32:25,820
they use more memory<font color="#E5E5E5"> so if you look at</font>

801
00:32:24,140 --> 00:32:27,290
the<font color="#E5E5E5"> backing storage of this area in a</font>

802
00:32:25,820 --> 00:32:30,169
debugger maybe you would see that it

803
00:32:27,290 --> 00:32:31,879
just<font color="#E5E5E5"> stores</font><font color="#CCCCCC"> through</font><font color="#E5E5E5"> our doubles and this</font>

804
00:32:30,170 --> 00:32:35,450
information<font color="#CCCCCC"> is also stored</font><font color="#E5E5E5"> in the shape</font>

805
00:32:31,880 --> 00:32:38,690
so here for this<font color="#E5E5E5"> array the shape tells</font>

806
00:32:35,450 --> 00:32:39,980
us that<font color="#E5E5E5"> it's storing unboxed doubles so</font>

807
00:32:38,690 --> 00:32:42,080
that<font color="#E5E5E5"> brings up the question well what</font>

808
00:32:39,980 --> 00:32:45,710
<font color="#E5E5E5">happens if we store something that's not</font>

809
00:32:42,080 --> 00:32:48,199
<font color="#E5E5E5">a double in such an area and well what</font>

810
00:32:45,710 --> 00:32:49,490
happens so first before<font color="#E5E5E5"> that we all only</font>

811
00:32:48,200 --> 00:32:51,290
have<font color="#E5E5E5"> these unboxed tablets in our</font>

812
00:32:49,490 --> 00:32:53,240
<font color="#CCCCCC">banking</font><font color="#E5E5E5"> storage</font><font color="#CCCCCC"> now we put an object</font>

813
00:32:51,290 --> 00:32:55,310
<font color="#E5E5E5">there so now the engine has to go ahead</font>

814
00:32:53,240 --> 00:32:57,470
and basically<font color="#E5E5E5"> convert all these tablets</font>

815
00:32:55,310 --> 00:33:00,770
<font color="#CCCCCC">to</font><font color="#E5E5E5"> JavaScript values and then insert</font>

816
00:32:57,470 --> 00:33:03,290
this this object here so if you<font color="#E5E5E5"> look at</font>

817
00:33:00,770 --> 00:33:05,180
<font color="#E5E5E5">maybe the the last elementary in this</font>

818
00:33:03,290 --> 00:33:07,790
area<font color="#E5E5E5"> you would see it's pointing</font>

819
00:33:05,180 --> 00:33:09,440
<font color="#CCCCCC">somewhere and that somewhere if</font><font color="#E5E5E5"> you look</font>

820
00:33:07,790 --> 00:33:11,960
there<font color="#E5E5E5"> you will find</font><font color="#CCCCCC"> this tablet value</font>

821
00:33:09,440 --> 00:33:13,670
again<font color="#E5E5E5"> so yeah you can already tell why</font>

822
00:33:11,960 --> 00:33:15,690
the<font color="#E5E5E5"> engine tries</font><font color="#CCCCCC"> to optimize</font><font color="#E5E5E5"> because</font>

823
00:33:13,670 --> 00:33:17,400
<font color="#E5E5E5">JavaScript values</font>

824
00:33:15,690 --> 00:33:18,840
and if it's<font color="#E5E5E5"> torrid</font><font color="#CCCCCC"> em as JavaScript</font>

825
00:33:17,400 --> 00:33:22,920
<font color="#CCCCCC">values it will take three times as</font><font color="#E5E5E5"> much</font>

826
00:33:18,840 --> 00:33:25,020
<font color="#E5E5E5">memory as if it's towards an unboxed but</font>

827
00:33:22,920 --> 00:33:28,800
<font color="#CCCCCC">okay so how can we</font><font color="#E5E5E5"> use this to exploit</font>

828
00:33:25,020 --> 00:33:30,600
these redundancy problems<font color="#E5E5E5"> so this is</font>

829
00:33:28,800 --> 00:33:32,790
kind of<font color="#E5E5E5"> the pseudocode for such a</font><font color="#CCCCCC"> bug</font>

830
00:33:30,600 --> 00:33:36,540
where<font color="#CCCCCC"> you have an unexpected call back</font>

831
00:33:32,790 --> 00:33:38,580
somewhere<font color="#E5E5E5"> in between your your</font><font color="#CCCCCC"> dude code</font>

832
00:33:36,540 --> 00:33:40,290
that you're compiling<font color="#E5E5E5"> and then</font>

833
00:33:38,580 --> 00:33:42,149
<font color="#E5E5E5">essentially the exploit looks like this</font>

834
00:33:40,290 --> 00:33:45,870
so you first<font color="#E5E5E5"> optimize your function to</font>

835
00:33:42,150 --> 00:33:47,340
work on areas<font color="#E5E5E5"> with unbox doubles so in</font>

836
00:33:45,870 --> 00:33:48,719
<font color="#E5E5E5">this case is this for loop here</font><font color="#CCCCCC"> to</font>

837
00:33:47,340 --> 00:33:51,540
always<font color="#E5E5E5"> calling it with an unlockable</font>

838
00:33:48,720 --> 00:33:52,950
<font color="#E5E5E5">array</font><font color="#CCCCCC"> then you call</font><font color="#E5E5E5"> it again</font><font color="#CCCCCC"> and this</font>

839
00:33:51,540 --> 00:33:56,129
time in this call<font color="#E5E5E5"> they</font><font color="#CCCCCC"> could transition</font>

840
00:33:52,950 --> 00:33:57,960
<font color="#E5E5E5">the area to now store objects and then</font>

841
00:33:56,130 --> 00:34:00,570
if the function with this<font color="#E5E5E5"> callback</font>

842
00:33:57,960 --> 00:34:02,550
returns<font color="#E5E5E5"> the JIT code essentially it's</font>

843
00:34:00,570 --> 00:34:04,409
<font color="#CCCCCC">the things that</font><font color="#E5E5E5"> the array is storing</font>

844
00:34:02,550 --> 00:34:06,210
unbox doubles but it's now storing

845
00:34:04,410 --> 00:34:08,820
pointers so in this case what it would

846
00:34:06,210 --> 00:34:10,679
do is basically fetch this this pointer

847
00:34:08,820 --> 00:34:12,419
treated<font color="#CCCCCC"> that treated as a double and</font>

848
00:34:10,679 --> 00:34:13,918
give it<font color="#CCCCCC"> back</font><font color="#E5E5E5"> to you so you would get</font>

849
00:34:12,418 --> 00:34:15,870
this<font color="#E5E5E5"> weird-looking double which is</font>

850
00:34:13,918 --> 00:34:19,379
essentially the address of this<font color="#CCCCCC"> object</font>

851
00:34:15,870 --> 00:34:20,790
in memory<font color="#E5E5E5"> so that's an info leak so we</font>

852
00:34:19,380 --> 00:34:24,600
get a type confusion that's basically

853
00:34:20,790 --> 00:34:25,650
what we achieve here this part<font color="#E5E5E5"> we've</font>

854
00:34:24,600 --> 00:34:27,719
<font color="#E5E5E5">seen it a few times</font>

855
00:34:25,650 --> 00:34:30,000
<font color="#E5E5E5">again VD is written a blog</font><font color="#CCCCCC"> post</font><font color="#E5E5E5"> about it</font>

856
00:34:27,719 --> 00:34:32,909
<font color="#E5E5E5">project here</font><font color="#CCCCCC"> also found some box</font><font color="#E5E5E5"> and</font>

857
00:34:30,000 --> 00:34:34,800
then<font color="#E5E5E5"> there's this my CD from WebKit</font>

858
00:34:32,909 --> 00:34:38,819
which<font color="#E5E5E5"> I used for</font><font color="#CCCCCC"> pendulum and</font><font color="#E5E5E5"> that's</font>

859
00:34:34,800 --> 00:34:41,419
what we'll talk about<font color="#CCCCCC"> no right so this</font>

860
00:34:38,820 --> 00:34:44,340
<font color="#E5E5E5">was a JavaScript code the WebKit engine</font>

861
00:34:41,418 --> 00:34:46,589
<font color="#E5E5E5">they also using a graph based in treated</font>

862
00:34:44,340 --> 00:34:48,090
language they also do this precise

863
00:34:46,590 --> 00:34:50,160
modeling of side effects because<font color="#CCCCCC"> they</font>

864
00:34:48,090 --> 00:34:52,140
want to<font color="#CCCCCC"> be redundancy</font><font color="#E5E5E5"> elimination in</font>

865
00:34:50,159 --> 00:34:54,239
their case there's this class called

866
00:34:52,139 --> 00:34:56,520
abstract interpreter<font color="#E5E5E5"> which is</font>

867
00:34:54,239 --> 00:34:58,709
<font color="#CCCCCC">responsible for</font><font color="#E5E5E5"> doing just</font><font color="#CCCCCC"> that it's</font>

868
00:34:56,520 --> 00:35:00,840
tracking all kinds of<font color="#E5E5E5"> read</font><font color="#CCCCCC"> Riots to</font>

869
00:34:58,710 --> 00:35:03,480
stack heap and so on<font color="#CCCCCC"> and it's making</font>

870
00:35:00,840 --> 00:35:06,240
<font color="#CCCCCC">sure yeah it's tracking essentially side</font>

871
00:35:03,480 --> 00:35:08,700
<font color="#E5E5E5">of things right</font><font color="#CCCCCC"> if you look</font><font color="#E5E5E5"> at this</font>

872
00:35:06,240 --> 00:35:11,040
abstract interpreter<font color="#CCCCCC"> it's essentially a</font>

873
00:35:08,700 --> 00:35:13,140
huge switch case statement that for

874
00:35:11,040 --> 00:35:15,660
every operation in the intermediate

875
00:35:13,140 --> 00:35:18,930
language<font color="#E5E5E5"> knows what side effects</font><font color="#CCCCCC"> it's</font>

876
00:35:15,660 --> 00:35:21,120
<font color="#CCCCCC">have it has</font><font color="#E5E5E5"> in case it has side effects</font>

877
00:35:18,930 --> 00:35:22,529
<font color="#CCCCCC">like a call instruction</font><font color="#E5E5E5"> it's calling</font>

878
00:35:21,120 --> 00:35:25,830
<font color="#E5E5E5">this clobber world function which</font>

879
00:35:22,530 --> 00:35:26,250
basically<font color="#E5E5E5"> says that while this has side</font>

880
00:35:25,830 --> 00:35:28,140
effects

881
00:35:26,250 --> 00:35:29,590
throw<font color="#CCCCCC"> away all type information</font><font color="#E5E5E5"> and keep</font>

882
00:35:28,140 --> 00:35:33,400
following<font color="#CCCCCC"> shape</font><font color="#E5E5E5"> darts</font>

883
00:35:29,590 --> 00:35:36,160
right<font color="#E5E5E5"> so if we look for some</font><font color="#CCCCCC"> other code</font>

884
00:35:33,400 --> 00:35:38,440
here<font color="#CCCCCC"> there's one operation</font><font color="#E5E5E5"> that's called</font>

885
00:35:36,160 --> 00:35:41,920
create this what it does is basically

886
00:35:38,440 --> 00:35:44,560
during<font color="#E5E5E5"> construction</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> allocates the</font>

887
00:35:41,920 --> 00:35:46,180
<font color="#E5E5E5">objects</font><font color="#CCCCCC"> that's being</font><font color="#E5E5E5"> constructed and if</font>

888
00:35:44,560 --> 00:35:47,950
you look at this code in the<font color="#E5E5E5"> abstract</font>

889
00:35:46,180 --> 00:35:49,990
interpreter here<font color="#E5E5E5"> you can tell it it</font>

890
00:35:47,950 --> 00:35:52,330
doesn't call a<font color="#CCCCCC"> clobber world</font><font color="#E5E5E5"> so it's</font>

891
00:35:49,990 --> 00:35:55,149
assuming that this operation is in fact

892
00:35:52,330 --> 00:35:57,130
<font color="#CCCCCC">side effect for</font><font color="#E5E5E5"> you right well it turns</font>

893
00:35:55,150 --> 00:36:01,450
out<font color="#E5E5E5"> it's not and that's exactly the</font><font color="#CCCCCC"> bug</font>

894
00:35:57,130 --> 00:36:02,920
<font color="#E5E5E5">I exploited</font><font color="#CCCCCC"> so create this it can</font>

895
00:36:01,450 --> 00:36:06,609
<font color="#E5E5E5">actually call</font><font color="#CCCCCC"> JavaScript the reason is</font>

896
00:36:02,920 --> 00:36:08,620
<font color="#CCCCCC">very JavaScript specific essentially</font>

897
00:36:06,610 --> 00:36:10,750
when you construct<font color="#E5E5E5"> an object the engine</font>

898
00:36:08,620 --> 00:36:13,180
has to<font color="#E5E5E5"> fetch the property from the</font>

899
00:36:10,750 --> 00:36:14,770
constructor and fetching a property in

900
00:36:13,180 --> 00:36:16,569
JavaScript that's something that you can

901
00:36:14,770 --> 00:36:18,690
intercept<font color="#E5E5E5"> for example with the</font>

902
00:36:16,570 --> 00:36:20,800
properties<font color="#CCCCCC"> of proxies just kind</font><font color="#E5E5E5"> of a</font>

903
00:36:18,690 --> 00:36:22,510
tool that<font color="#E5E5E5"> you have</font><font color="#CCCCCC"> in JavaScript to</font>

904
00:36:20,800 --> 00:36:25,540
intercept<font color="#E5E5E5"> all these standard operations</font>

905
00:36:22,510 --> 00:36:27,430
on objects<font color="#CCCCCC"> so here's kind</font><font color="#E5E5E5"> of my pseudo</font>

906
00:36:25,540 --> 00:36:29,800
code you<font color="#CCCCCC"> have to this function C which</font>

907
00:36:27,430 --> 00:36:31,839
is the constructor then<font color="#CCCCCC"> I put a proxy</font>

908
00:36:29,800 --> 00:36:34,120
around it<font color="#CCCCCC"> that intercepts property</font><font color="#E5E5E5"> loads</font>

909
00:36:31,840 --> 00:36:38,050
<font color="#E5E5E5">and then I'm calling</font><font color="#CCCCCC"> it as a constructor</font>

910
00:36:34,120 --> 00:36:40,240
now it's creating this this<font color="#E5E5E5"> object that</font>

911
00:36:38,050 --> 00:36:42,010
<font color="#E5E5E5">it's constructing and at that point it's</font>

912
00:36:40,240 --> 00:36:44,680
running arbitrary JavaScript<font color="#E5E5E5"> because I'm</font>

913
00:36:42,010 --> 00:36:46,420
intercepting<font color="#E5E5E5"> property loads so that's</font>

914
00:36:44,680 --> 00:36:49,089
really the<font color="#E5E5E5"> unexpected callback</font><font color="#CCCCCC"> in our</font>

915
00:36:46,420 --> 00:36:52,540
<font color="#E5E5E5">example so let's look at what happens</font>

916
00:36:49,090 --> 00:36:54,790
<font color="#E5E5E5">now this is the function we</font><font color="#CCCCCC"> want</font><font color="#E5E5E5"> to</font>

917
00:36:52,540 --> 00:36:59,020
<font color="#E5E5E5">optimize</font><font color="#CCCCCC"> the first thing it does</font><font color="#E5E5E5"> is this</font>

918
00:36:54,790 --> 00:37:00,279
graph building phase yeah this is how it

919
00:36:59,020 --> 00:37:02,170
<font color="#E5E5E5">would look like in</font><font color="#CCCCCC"> the their</font>

920
00:37:00,280 --> 00:37:04,510
<font color="#CCCCCC">intermediate language</font><font color="#E5E5E5"> first to create</font>

921
00:37:02,170 --> 00:37:06,100
this operation then shape<font color="#CCCCCC"> card</font><font color="#E5E5E5"> or it's</font>

922
00:37:04,510 --> 00:37:09,430
<font color="#CCCCCC">actually called</font><font color="#E5E5E5"> structure check in</font>

923
00:37:06,100 --> 00:37:11,350
JavaScript core because yes shapes are

924
00:37:09,430 --> 00:37:13,410
<font color="#CCCCCC">called structures then it's loading</font><font color="#E5E5E5"> the</font>

925
00:37:11,350 --> 00:37:15,580
element<font color="#E5E5E5"> and storing it on the object</font>

926
00:37:13,410 --> 00:37:17,710
next<font color="#CCCCCC"> thing it does something</font><font color="#E5E5E5"> called</font>

927
00:37:15,580 --> 00:37:19,960
check hoisting which is an optimization

928
00:37:17,710 --> 00:37:22,180
where it tries to<font color="#E5E5E5"> move these</font><font color="#CCCCCC"> structure</font>

929
00:37:19,960 --> 00:37:23,440
checks<font color="#E5E5E5"> as far up as it can so</font><font color="#CCCCCC"> it's</font>

930
00:37:22,180 --> 00:37:25,240
<font color="#CCCCCC">actually duplicating the structures</font>

931
00:37:23,440 --> 00:37:26,830
check and putting it at<font color="#E5E5E5"> first thing in</font>

932
00:37:25,240 --> 00:37:29,080
the function<font color="#E5E5E5"> and then it's doing</font>

933
00:37:26,830 --> 00:37:31,299
redundancy elimination<font color="#E5E5E5"> and at this point</font>

934
00:37:29,080 --> 00:37:33,549
<font color="#CCCCCC">it's removing the second structure check</font>

935
00:37:31,300 --> 00:37:36,670
because<font color="#E5E5E5"> it's assuming that creates is a</font>

936
00:37:33,550 --> 00:37:39,760
side-effect free so what we end<font color="#E5E5E5"> up with</font>

937
00:37:36,670 --> 00:37:41,770
is this<font color="#E5E5E5"> operation which can have side</font>

938
00:37:39,760 --> 00:37:42,860
effects<font color="#CCCCCC"> it can</font><font color="#E5E5E5"> call JavaScript and then</font>

939
00:37:41,770 --> 00:37:44,720
there's an

940
00:37:42,860 --> 00:37:46,430
unguarded<font color="#CCCCCC"> access to this area</font>

941
00:37:44,720 --> 00:37:50,509
<font color="#E5E5E5">essentially and this is exactly the</font>

942
00:37:46,430 --> 00:37:51,890
condition we can<font color="#E5E5E5"> exploit</font><font color="#CCCCCC"> so for this we</font>

943
00:37:50,510 --> 00:37:53,180
can<font color="#CCCCCC"> just view</font><font color="#E5E5E5"> it the same trick that</font><font color="#CCCCCC"> I</font>

944
00:37:51,890 --> 00:37:56,600
showed<font color="#E5E5E5"> previously with the array</font>

945
00:37:53,180 --> 00:37:58,790
confusion stuff<font color="#CCCCCC"> and confuse doubles and</font>

946
00:37:56,600 --> 00:38:00,799
<font color="#E5E5E5">JavaScript</font><font color="#CCCCCC"> menus from</font><font color="#E5E5E5"> there we get these</font>

947
00:37:58,790 --> 00:38:03,170
<font color="#E5E5E5">two primitives address often fake object</font>

948
00:38:00,800 --> 00:38:05,150
<font color="#E5E5E5">that I already used two years ago for</font>

949
00:38:03,170 --> 00:38:07,910
for another<font color="#E5E5E5"> exploit basically you can</font>

950
00:38:05,150 --> 00:38:10,070
read up<font color="#E5E5E5"> later</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> interested here and</font>

951
00:38:07,910 --> 00:38:11,450
from<font color="#E5E5E5"> there it's really easy or</font><font color="#CCCCCC"> just to</font>

952
00:38:10,070 --> 00:38:14,120
be<font color="#CCCCCC"> really easy it's basically take a</font>

953
00:38:11,450 --> 00:38:16,730
type array<font color="#E5E5E5"> as you get arbitrary right</font>

954
00:38:14,120 --> 00:38:22,250
that way<font color="#E5E5E5"> and then you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> just run shell</font>

955
00:38:16,730 --> 00:38:24,380
<font color="#E5E5E5">code basically yeah so this is kind of</font>

956
00:38:22,250 --> 00:38:26,060
the proof<font color="#CCCCCC"> of</font><font color="#E5E5E5"> concept for this book it's</font>

957
00:38:24,380 --> 00:38:30,200
a bit more complicated so<font color="#E5E5E5"> I'm not</font><font color="#CCCCCC"> gonna</font>

958
00:38:26,060 --> 00:38:32,090
<font color="#E5E5E5">go through</font><font color="#CCCCCC"> all of this code right</font><font color="#E5E5E5"> now</font><font color="#CCCCCC"> if</font>

959
00:38:30,200 --> 00:38:33,740
you ran this on the vulnerable<font color="#E5E5E5"> version</font>

960
00:38:32,090 --> 00:38:36,350
it would<font color="#CCCCCC"> crashes for</font><font color="#E5E5E5"> one for</font><font color="#CCCCCC"> one for</font><font color="#E5E5E5"> one</font>

961
00:38:33,740 --> 00:38:37,819
<font color="#CCCCCC">for one because there's this weird</font>

962
00:38:36,350 --> 00:38:42,080
<font color="#E5E5E5">double value that you</font><font color="#CCCCCC"> have at the bottom</font>

963
00:38:37,820 --> 00:38:44,000
here<font color="#CCCCCC"> if you're interested I</font><font color="#E5E5E5"> will push my</font>

964
00:38:42,080 --> 00:38:49,730
commented exploit to get up so you can

965
00:38:44,000 --> 00:38:51,530
take<font color="#CCCCCC"> a look and we'll do a demo right so</font>

966
00:38:49,730 --> 00:38:54,530
what you will now see<font color="#CCCCCC"> that basically my</font>

967
00:38:51,530 --> 00:38:56,780
<font color="#E5E5E5">full</font><font color="#CCCCCC"> count your</font><font color="#E5E5E5"> own chain so it has the</font>

968
00:38:54,530 --> 00:38:59,090
web PRC which gets this code<font color="#CCCCCC"> executes in</font>

969
00:38:56,780 --> 00:39:00,830
the renderer<font color="#CCCCCC"> and that's according</font><font color="#E5E5E5"> this</font>

970
00:38:59,090 --> 00:39:02,630
part but<font color="#CCCCCC"> only this one</font><font color="#E5E5E5"> so this one is</font>

971
00:39:00,830 --> 00:39:05,600
quite<font color="#E5E5E5"> powerful it allows us</font><font color="#CCCCCC"> to bypass</font>

972
00:39:02,630 --> 00:39:07,970
<font color="#CCCCCC">our</font><font color="#E5E5E5"> mitigations</font><font color="#CCCCCC"> and then there's two</font>

973
00:39:05,600 --> 00:39:10,040
<font color="#CCCCCC">more boxes one one logic</font><font color="#E5E5E5"> Park in Mac OS</font>

974
00:39:07,970 --> 00:39:11,600
that gets me out of<font color="#CCCCCC"> the sandbox and then</font>

975
00:39:10,040 --> 00:39:14,810
there's another logic<font color="#CCCCCC"> park that I used</font>

976
00:39:11,600 --> 00:39:16,390
to escalate from user<font color="#E5E5E5"> to root and then</font>

977
00:39:14,810 --> 00:39:19,040
<font color="#E5E5E5">root to Karl because that's kind of a</font>

978
00:39:16,390 --> 00:39:21,920
additional security<font color="#E5E5E5"> boundary and Mac OS</font>

979
00:39:19,040 --> 00:39:25,580
I guess right<font color="#E5E5E5"> so let's see this in</font>

980
00:39:21,920 --> 00:39:29,090
action<font color="#CCCCCC"> so there's the calculator popping</font>

981
00:39:25,580 --> 00:39:32,120
up mandatory calculator<font color="#E5E5E5"> and here we can</font>

982
00:39:29,090 --> 00:39:34,100
see this is<font color="#CCCCCC"> K X Ted so</font><font color="#E5E5E5"> it's showing the</font>

983
00:39:32,120 --> 00:39:37,100
list<font color="#E5E5E5"> of loaded kernel modules and this</font>

984
00:39:34,100 --> 00:39:39,410
is my own<font color="#E5E5E5"> kernel module that I loaded</font>

985
00:39:37,100 --> 00:39:41,120
<font color="#E5E5E5">into the counter without a developer</font>

986
00:39:39,410 --> 00:39:43,910
certificate so it's not not signed in

987
00:39:41,120 --> 00:39:46,970
<font color="#CCCCCC">anyway</font><font color="#E5E5E5"> right so</font><font color="#CCCCCC"> this is the full chain</font>

988
00:39:43,910 --> 00:39:49,490
gives us goes from browsing to web page

989
00:39:46,970 --> 00:39:52,580
to<font color="#E5E5E5"> kernel code execution kind of</font><font color="#CCCCCC"> yeah</font>

990
00:39:49,490 --> 00:39:53,899
just<font color="#CCCCCC"> a few seconds</font><font color="#E5E5E5"> and it's super</font>

991
00:39:52,580 --> 00:39:56,569
reliable<font color="#E5E5E5"> because it's basically just</font>

992
00:39:53,900 --> 00:40:00,620
logic<font color="#CCCCCC"> box the whole</font><font color="#E5E5E5"> way</font>

993
00:39:56,570 --> 00:40:03,200
<font color="#CCCCCC">all right so that brings us</font><font color="#E5E5E5"> to the end</font>

994
00:40:00,620 --> 00:40:06,109
<font color="#E5E5E5">obviously we haven't covered everything</font>

995
00:40:03,200 --> 00:40:08,790
<font color="#CCCCCC">so there's a lot more to</font><font color="#E5E5E5"> these compilers</font>

996
00:40:06,110 --> 00:40:11,100
<font color="#CCCCCC">there's</font><font color="#E5E5E5"> this planar mechanism which I</font>

997
00:40:08,790 --> 00:40:14,190
only touched on it's quite complex

998
00:40:11,100 --> 00:40:15,810
<font color="#CCCCCC">actually to just</font><font color="#E5E5E5"> at some point in the</font>

999
00:40:14,190 --> 00:40:18,570
<font color="#CCCCCC">function go back to the interpreter and</font>

1000
00:40:15,810 --> 00:40:21,660
continue executing code there<font color="#E5E5E5"> so there</font>

1001
00:40:18,570 --> 00:40:23,280
is some<font color="#E5E5E5"> potential</font><font color="#CCCCCC"> for box there there's</font>

1002
00:40:21,660 --> 00:40:26,549
some other mechanisms like on<font color="#CCCCCC"> stack</font>

1003
00:40:23,280 --> 00:40:30,810
replacement<font color="#E5E5E5"> where basically the engine</font>

1004
00:40:26,550 --> 00:40:32,250
<font color="#E5E5E5">can also switch to the JIT code while</font>

1005
00:40:30,810 --> 00:40:33,690
<font color="#E5E5E5">running</font><font color="#CCCCCC"> the function</font><font color="#E5E5E5"> so let's say you</font>

1006
00:40:32,250 --> 00:40:36,240
have a function<font color="#CCCCCC"> that has a while loop</font>

1007
00:40:33,690 --> 00:40:38,220
that's running<font color="#E5E5E5"> very long</font><font color="#CCCCCC"> at some point</font>

1008
00:40:36,240 --> 00:40:40,500
the JIT compiler could compile this the

1009
00:40:38,220 --> 00:40:44,009
whole fashion<font color="#E5E5E5"> and then just switch</font><font color="#CCCCCC"> to</font>

1010
00:40:40,500 --> 00:40:45,270
<font color="#E5E5E5">the JIT code from</font><font color="#CCCCCC"> one loop iteration to</font>

1011
00:40:44,010 --> 00:40:47,790
the next<font color="#E5E5E5"> so</font><font color="#CCCCCC"> they're faulted quite a</font>

1012
00:40:45,270 --> 00:40:49,200
complex mechanism<font color="#E5E5E5"> there's register</font>

1013
00:40:47,790 --> 00:40:49,620
allocation which we haven't<font color="#E5E5E5"> talked about</font>

1014
00:40:49,200 --> 00:40:52,770
<font color="#E5E5E5">at all</font>

1015
00:40:49,620 --> 00:40:55,560
also in<font color="#E5E5E5"> nine caches inline caches is</font>

1016
00:40:52,770 --> 00:40:57,680
essentially kind of<font color="#E5E5E5"> a something</font><font color="#CCCCCC"> in</font>

1017
00:40:55,560 --> 00:41:02,100
<font color="#E5E5E5">between the interpreter and the</font>

1018
00:40:57,680 --> 00:41:03,870
speculative and<font color="#E5E5E5"> optimizing it</font><font color="#CCCCCC"> but I have</font>

1019
00:41:02,100 --> 00:41:07,049
some<font color="#E5E5E5"> references</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the next slide if</font><font color="#CCCCCC"> you</font>

1020
00:41:03,870 --> 00:41:09,750
have<font color="#E5E5E5"> two or next slides where you can</font>

1021
00:41:07,050 --> 00:41:11,910
read up<font color="#E5E5E5"> if you're interested and of</font>

1022
00:41:09,750 --> 00:41:14,430
course all of these are<font color="#CCCCCC"> quite complex</font>

1023
00:41:11,910 --> 00:41:18,000
<font color="#E5E5E5">there's potential for box there so enjoy</font>

1024
00:41:14,430 --> 00:41:19,890
finding them I guess cool<font color="#CCCCCC"> that brings us</font>

1025
00:41:18,000 --> 00:41:22,620
to the end so here's my summary<font color="#E5E5E5"> what</font>

1026
00:41:19,890 --> 00:41:24,720
have you seen<font color="#E5E5E5"> essentially we saw the</font>

1027
00:41:22,620 --> 00:41:26,700
type speculation and<font color="#CCCCCC"> runtime guards make</font>

1028
00:41:24,720 --> 00:41:29,220
up for<font color="#E5E5E5"> missing type information due to</font>

1029
00:41:26,700 --> 00:41:32,899
dynamic typing we've seen a lot of

1030
00:41:29,220 --> 00:41:36,689
<font color="#E5E5E5">complex mechanisms lots of optimizations</font>

1031
00:41:32,900 --> 00:41:39,690
<font color="#E5E5E5">potential for bugs right very complex</font>

1032
00:41:36,690 --> 00:41:42,540
code bases<font color="#CCCCCC"> we've also seen very powerful</font>

1033
00:41:39,690 --> 00:41:45,330
bugs<font color="#E5E5E5"> so it's it's not uncommon</font><font color="#CCCCCC"> that one</font>

1034
00:41:42,540 --> 00:41:48,930
bug is<font color="#E5E5E5"> really enough to bypass all</font>

1035
00:41:45,330 --> 00:41:52,200
mitigations<font color="#CCCCCC"> in in a super reliable</font>

1036
00:41:48,930 --> 00:41:53,460
manner and super quickly<font color="#E5E5E5"> and the whole</font>

1037
00:41:52,200 --> 00:41:55,460
thing is<font color="#CCCCCC"> also again kind of this</font>

1038
00:41:53,460 --> 00:41:58,980
<font color="#E5E5E5">performance versus security trade-off</font>

1039
00:41:55,460 --> 00:42:00,750
<font color="#CCCCCC">right now the engines they all go for</font>

1040
00:41:58,980 --> 00:42:04,410
performance right they<font color="#E5E5E5"> want to do</font><font color="#CCCCCC"> these</font>

1041
00:42:00,750 --> 00:42:07,590
very complex<font color="#CCCCCC"> optimization to produce</font><font color="#E5E5E5"> as</font>

1042
00:42:04,410 --> 00:42:09,160
fast code as<font color="#E5E5E5"> possible</font><font color="#CCCCCC"> which results in</font>

1043
00:42:07,590 --> 00:42:10,900
complex code

1044
00:42:09,160 --> 00:42:14,828
potentially for<font color="#E5E5E5"> security bugs right so</font>

1045
00:42:10,900 --> 00:42:16,690
nothing<font color="#CCCCCC"> really</font><font color="#E5E5E5"> new</font><font color="#CCCCCC"> and as I said there's</font>

1046
00:42:14,829 --> 00:42:20,680
some<font color="#E5E5E5"> further reference is just a list of</font>

1047
00:42:16,690 --> 00:42:22,119
kind<font color="#CCCCCC"> of</font><font color="#E5E5E5"> interesting</font><font color="#CCCCCC"> articles the site</font>

1048
00:42:20,680 --> 00:42:24,848
will<font color="#CCCCCC"> be published so you can take a look</font>

1049
00:42:22,119 --> 00:42:25,950
<font color="#E5E5E5">now</font><font color="#CCCCCC"> and with that Thanks</font>

1050
00:42:24,849 --> 00:42:29,100
thanks<font color="#E5E5E5"> for listening</font>

1051
00:42:25,950 --> 00:42:29,100
[Applause]

1052
00:42:29,580 --> 00:42:35,439
[Music]

1053
00:42:32,340 --> 00:42:35,439
[Applause]

