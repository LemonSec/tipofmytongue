1
00:00:00,030 --> 00:00:07,400
and<font color="#E5E5E5"> without further ado Michael Schwartz</font>

2
00:00:02,990 --> 00:00:07,400
<font color="#E5E5E5">Daniel gross and more it's live</font>

3
00:00:08,900 --> 00:00:15,780
hi and welcome to<font color="#CCCCCC"> a talk meltem basics</font>

4
00:00:13,740 --> 00:00:19,080
details consequences where we talk about

5
00:00:15,780 --> 00:00:20,660
<font color="#CCCCCC">one of</font><font color="#E5E5E5"> the infamous cpu vulnerabilities</font>

6
00:00:19,080 --> 00:00:24,060
of January

7
00:00:20,660 --> 00:00:26,220
my name is<font color="#CCCCCC"> Marc lip I'm a PhD student at</font>

8
00:00:24,060 --> 00:00:28,590
<font color="#CCCCCC">cards University of Technology you can</font>

9
00:00:26,220 --> 00:00:31,519
<font color="#E5E5E5">find me on Twitter</font><font color="#CCCCCC"> write me an email</font><font color="#E5E5E5"> or</font>

10
00:00:28,590 --> 00:00:31,519
talk<font color="#E5E5E5"> to me later on</font>

11
00:00:32,270 --> 00:00:37,530
my name is<font color="#CCCCCC"> Micah Schwartz I'm also a PhD</font>

12
00:00:35,070 --> 00:00:39,629
student<font color="#CCCCCC"> at the same University in class</font>

13
00:00:37,530 --> 00:00:42,000
<font color="#CCCCCC">I'm also on Twitter I can write me an</font>

14
00:00:39,629 --> 00:00:43,290
email<font color="#CCCCCC"> talk to me afterwards I'll be here</font>

15
00:00:42,000 --> 00:00:46,289
<font color="#E5E5E5">for the rest of the conference</font><font color="#CCCCCC"> and DEF</font>

16
00:00:43,290 --> 00:00:48,059
<font color="#CCCCCC">CON</font><font color="#E5E5E5"> and my name is</font><font color="#CCCCCC"> Danny</font><font color="#E5E5E5"> goose I'm a</font>

17
00:00:46,289 --> 00:00:49,710
postdoc at<font color="#E5E5E5"> cards University of</font>

18
00:00:48,059 --> 00:00:53,099
Technology and you can also reach me

19
00:00:49,710 --> 00:00:56,219
<font color="#E5E5E5">online</font><font color="#CCCCCC"> we also had a lot of other</font><font color="#E5E5E5"> people</font>

20
00:00:53,100 --> 00:00:58,520
who contributed to<font color="#E5E5E5"> this work</font><font color="#CCCCCC"> under spoke</font>

21
00:00:56,219 --> 00:01:01,379
Tanya Jenkins<font color="#CCCCCC"> Vanna has Mike Hamburg</font>

22
00:00:58,520 --> 00:01:03,660
young horn<font color="#CCCCCC"> poll coach Stefan monger</font>

23
00:01:01,379 --> 00:01:06,270
<font color="#E5E5E5">Thomas pressure and your violin we're</font>

24
00:01:03,660 --> 00:01:08,850
not here but this was a<font color="#E5E5E5"> great</font>

25
00:01:06,270 --> 00:01:10,470
<font color="#E5E5E5">collaboration</font><font color="#CCCCCC"> with them</font><font color="#E5E5E5"> and yeah we're</font>

26
00:01:08,850 --> 00:01:13,619
looking<font color="#CCCCCC"> forward</font><font color="#E5E5E5"> to working</font><font color="#CCCCCC"> with them in</font>

27
00:01:10,470 --> 00:01:15,689
the<font color="#E5E5E5"> future yeah so let's dive into it</font>

28
00:01:13,619 --> 00:01:17,790
<font color="#E5E5E5">and we start right off with reading</font>

29
00:01:15,689 --> 00:01:19,830
<font color="#E5E5E5">journal memory from user space</font><font color="#CCCCCC"> because</font>

30
00:01:17,790 --> 00:01:22,080
that's pretty<font color="#CCCCCC"> straightforward</font><font color="#E5E5E5"> right</font>

31
00:01:19,830 --> 00:01:24,179
<font color="#E5E5E5">Michael right so we have our virtual</font>

32
00:01:22,080 --> 00:01:26,490
address space in our application<font color="#CCCCCC"> we have</font>

33
00:01:24,180 --> 00:01:27,630
our user space addresses all map there

34
00:01:26,490 --> 00:01:29,970
we have<font color="#CCCCCC"> the column</font><font color="#E5E5E5"> mapped in our</font>

35
00:01:27,630 --> 00:01:32,789
application<font color="#CCCCCC"> so why not read something</font>

36
00:01:29,970 --> 00:01:35,130
<font color="#CCCCCC">that lies in the car</font><font color="#E5E5E5"> yeah why not</font>

37
00:01:32,790 --> 00:01:37,020
so we just pick an address<font color="#E5E5E5"> like the</font>

38
00:01:35,130 --> 00:01:40,350
Linux<font color="#CCCCCC"> spinner</font><font color="#E5E5E5"> get the address from that</font>

39
00:01:37,020 --> 00:01:43,500
<font color="#E5E5E5">and since every</font><font color="#CCCCCC"> one of us know see</font><font color="#E5E5E5"> we</font>

40
00:01:40,350 --> 00:01:45,839
can do some simple<font color="#E5E5E5"> pointer magic use the</font>

41
00:01:43,500 --> 00:01:48,509
address<font color="#CCCCCC"> passed it to in character</font>

42
00:01:45,840 --> 00:01:51,329
pointer dereference it and then we can

43
00:01:48,509 --> 00:01:53,909
just print out the<font color="#E5E5E5"> character located at</font>

44
00:01:51,329 --> 00:01:56,880
this address<font color="#CCCCCC"> so this</font><font color="#E5E5E5"> sounds really</font><font color="#CCCCCC"> easy</font>

45
00:01:53,909 --> 00:01:59,780
so let me<font color="#E5E5E5"> try this</font><font color="#CCCCCC"> I'd compile your code</font>

46
00:01:56,880 --> 00:02:01,679
<font color="#E5E5E5">I run your code see what's happening and</font>

47
00:01:59,780 --> 00:02:02,490
it doesn't<font color="#E5E5E5"> seem to be that</font>

48
00:02:01,680 --> 00:02:04,710
<font color="#E5E5E5">straightforward</font>

49
00:02:02,490 --> 00:02:06,658
<font color="#CCCCCC">it's seg faults when I thought</font><font color="#E5E5E5"> yeah</font>

50
00:02:04,710 --> 00:02:08,910
<font color="#E5E5E5">that's not really</font><font color="#CCCCCC"> surprising</font>

51
00:02:06,659 --> 00:02:11,099
you can't just access<font color="#E5E5E5"> kernel addresses</font>

52
00:02:08,910 --> 00:02:12,880
<font color="#E5E5E5">it's working as intended</font><font color="#CCCCCC"> current</font>

53
00:02:11,099 --> 00:02:16,209
addresses are<font color="#CCCCCC"> not accessible</font>

54
00:02:12,880 --> 00:02:18,250
and that's how it's supposed to<font color="#E5E5E5"> be</font><font color="#CCCCCC"> any</font>

55
00:02:16,210 --> 00:02:21,150
invalid<font color="#CCCCCC"> excess will throw an exception</font>

56
00:02:18,250 --> 00:02:23,950
<font color="#E5E5E5">and it will lead to</font><font color="#CCCCCC"> a segmentation fault</font>

57
00:02:21,150 --> 00:02:26,170
<font color="#E5E5E5">yeah but there's not an issue because</font>

58
00:02:23,950 --> 00:02:28,839
<font color="#E5E5E5">whenever you have</font><font color="#CCCCCC"> an exception you just</font>

59
00:02:26,170 --> 00:02:30,579
catch<font color="#CCCCCC"> it</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> then continue your code</font><font color="#E5E5E5"> so</font>

60
00:02:28,840 --> 00:02:32,770
that's pretty easy<font color="#CCCCCC"> we just</font><font color="#E5E5E5"> install a</font>

61
00:02:30,580 --> 00:02:35,260
<font color="#E5E5E5">signal handler so whenever this</font>

62
00:02:32,770 --> 00:02:37,750
<font color="#E5E5E5">segmentation fault occurs we jump back</font>

63
00:02:35,260 --> 00:02:39,760
and continue<font color="#E5E5E5"> our next instruction is</font>

64
00:02:37,750 --> 00:02:40,330
that<font color="#CCCCCC"> all is that</font><font color="#E5E5E5"> how you always</font><font color="#CCCCCC"> deal</font>

65
00:02:39,760 --> 00:02:42,340
with errors

66
00:02:40,330 --> 00:02:44,080
yeah<font color="#CCCCCC"> that's what you're supposed to do</font>

67
00:02:42,340 --> 00:02:50,890
right<font color="#CCCCCC"> and then we can just read the</font>

68
00:02:44,080 --> 00:02:54,880
value<font color="#CCCCCC"> I don't</font><font color="#E5E5E5"> think that's how it</font><font color="#CCCCCC"> works</font>

69
00:02:50,890 --> 00:02:57,730
Moyes really so I tried that<font color="#CCCCCC"> and</font><font color="#E5E5E5"> still I</font>

70
00:02:54,880 --> 00:03:00,310
get no<font color="#CCCCCC"> crown memory there</font><font color="#E5E5E5"> okay maybe</font>

71
00:02:57,730 --> 00:03:02,859
this privilege check actually<font color="#E5E5E5"> seems to</font>

72
00:03:00,310 --> 00:03:07,120
<font color="#E5E5E5">work and we cannot just access stuff</font>

73
00:03:02,860 --> 00:03:08,590
from the kernel<font color="#E5E5E5"> and it doesn't seem to</font>

74
00:03:07,120 --> 00:03:11,230
be<font color="#CCCCCC"> that straightforward</font><font color="#E5E5E5"> as you thought</font>

75
00:03:08,590 --> 00:03:13,150
it is<font color="#E5E5E5"> okay so maybe we</font><font color="#CCCCCC"> should</font><font color="#E5E5E5"> get go</font>

76
00:03:11,230 --> 00:03:16,299
back to the start<font color="#E5E5E5"> maybe we should go</font>

77
00:03:13,150 --> 00:03:19,570
<font color="#CCCCCC">back</font><font color="#E5E5E5"> to operating systems 101 back to</font>

78
00:03:16,300 --> 00:03:20,920
the basics<font color="#CCCCCC"> and there it looks like this</font>

79
00:03:19,570 --> 00:03:23,350
we have the<font color="#CCCCCC"> user space we have</font><font color="#E5E5E5"> the</font>

80
00:03:20,920 --> 00:03:26,350
kernel<font color="#CCCCCC"> space and they are isolated</font><font color="#E5E5E5"> from</font>

81
00:03:23,350 --> 00:03:28,030
<font color="#CCCCCC">each other the user space can't just</font>

82
00:03:26,350 --> 00:03:30,940
access the kernel space<font color="#E5E5E5"> and this</font>

83
00:03:28,030 --> 00:03:34,480
isolation<font color="#E5E5E5"> is a combination of hardware</font>

84
00:03:30,940 --> 00:03:40,180
<font color="#CCCCCC">and software and user applications can't</font>

85
00:03:34,480 --> 00:03:43,620
just pass by<font color="#E5E5E5"> the bypass this isolation</font>

86
00:03:40,180 --> 00:03:46,720
<font color="#CCCCCC">it's a huge wall that can't easily be</font>

87
00:03:43,620 --> 00:03:49,180
crossed<font color="#CCCCCC"> and there's also a fundamental</font>

88
00:03:46,720 --> 00:03:52,600
concept of all the modern<font color="#E5E5E5"> operating</font>

89
00:03:49,180 --> 00:03:55,030
<font color="#CCCCCC">systems and systems we use</font><font color="#E5E5E5"> so we have</font>

90
00:03:52,600 --> 00:03:56,890
<font color="#E5E5E5">this virtual address space with</font><font color="#CCCCCC"> just</font>

91
00:03:55,030 --> 00:03:58,810
virtual<font color="#E5E5E5"> addresses we usually call them</font>

92
00:03:56,890 --> 00:04:00,160
just<font color="#E5E5E5"> addresses because we have no idea</font>

93
00:03:58,810 --> 00:04:03,460
<font color="#CCCCCC">about physical addresses when writing</font>

94
00:04:00,160 --> 00:04:05,380
programs and the<font color="#E5E5E5"> CPU helps us with this</font>

95
00:04:03,460 --> 00:04:07,540
virtual<font color="#CCCCCC"> address space to isolate our</font>

96
00:04:05,380 --> 00:04:11,140
process<font color="#E5E5E5"> from all the other process</font>

97
00:04:07,540 --> 00:04:13,060
running<font color="#E5E5E5"> on</font><font color="#CCCCCC"> this computer</font><font color="#E5E5E5"> and then we</font>

98
00:04:11,140 --> 00:04:15,579
have this<font color="#CCCCCC"> physical memory and the</font>

99
00:04:13,060 --> 00:04:18,190
<font color="#E5E5E5">operating system manages that and there</font>

100
00:04:15,580 --> 00:04:20,710
<font color="#E5E5E5">is this mapping that the CPU uses to</font>

101
00:04:18,190 --> 00:04:25,020
translate virtual<font color="#E5E5E5"> addresses to the</font>

102
00:04:20,709 --> 00:04:28,310
<font color="#E5E5E5">action</font><font color="#CCCCCC"> physical address frame and</font>

103
00:04:25,020 --> 00:04:30,690
this technique is our<font color="#E5E5E5"> version address</font>

104
00:04:28,310 --> 00:04:33,960
<font color="#CCCCCC">techniques we have page tables for that</font>

105
00:04:30,690 --> 00:04:36,419
we have a lot<font color="#CCCCCC"> of</font><font color="#E5E5E5"> tables in memory</font><font color="#CCCCCC"> the</font>

106
00:04:33,960 --> 00:04:39,060
virtual address<font color="#CCCCCC"> is</font><font color="#E5E5E5"> used by the CPU to</font>

107
00:04:36,419 --> 00:04:41,159
index this table so split into<font color="#CCCCCC"> multiple</font>

108
00:04:39,060 --> 00:04:45,030
parts<font color="#E5E5E5"> use this illnesses</font><font color="#CCCCCC"> to this page</font>

109
00:04:41,160 --> 00:04:47,430
tables<font color="#CCCCCC"> multi-level structure and at the</font>

110
00:04:45,030 --> 00:04:49,409
last<font color="#E5E5E5"> page table</font><font color="#CCCCCC"> then we have a page</font>

111
00:04:47,430 --> 00:04:52,470
<font color="#E5E5E5">table entry that actually</font><font color="#CCCCCC"> maps</font><font color="#E5E5E5"> the</font>

112
00:04:49,410 --> 00:04:54,840
physical page to this<font color="#E5E5E5"> virtual address</font>

113
00:04:52,470 --> 00:04:56,400
and now we can zoom<font color="#CCCCCC"> in to</font><font color="#E5E5E5"> this page</font>

114
00:04:54,840 --> 00:04:57,568
<font color="#E5E5E5">table entry</font><font color="#CCCCCC"> because it's quite</font>

115
00:04:56,400 --> 00:04:59,489
interesting what's in there

116
00:04:57,569 --> 00:05:01,199
yeah and if we<font color="#E5E5E5"> look at this different</font>

117
00:04:59,490 --> 00:05:02,819
<font color="#E5E5E5">bits here we have the present bit right</font>

118
00:05:01,199 --> 00:05:05,130
<font color="#CCCCCC">of a bit user space accessible</font><font color="#E5E5E5"> right</font>

119
00:05:02,819 --> 00:05:06,690
through uncatchable reference dirty<font color="#E5E5E5"> size</font>

120
00:05:05,130 --> 00:05:08,669
with<font color="#E5E5E5"> global bit and the non-executable</font>

121
00:05:06,690 --> 00:05:10,380
<font color="#E5E5E5">bit some ignored bits and the physical</font>

122
00:05:08,669 --> 00:05:12,330
page<font color="#CCCCCC"> number but the most interesting</font>

123
00:05:10,380 --> 00:05:14,969
<font color="#CCCCCC">part for us here is the user space</font>

124
00:05:12,330 --> 00:05:18,659
accessible<font color="#CCCCCC"> bit because this defines that</font>

125
00:05:14,970 --> 00:05:21,270
an address<font color="#E5E5E5"> cannot be accessed by a user</font>

126
00:05:18,659 --> 00:05:23,310
space<font color="#E5E5E5"> program if this bit is not set</font><font color="#CCCCCC"> it</font>

127
00:05:21,270 --> 00:05:26,370
cannot be<font color="#CCCCCC"> accessed and this should</font><font color="#E5E5E5"> be</font>

128
00:05:23,310 --> 00:05:27,800
set for all kernel addresses<font color="#E5E5E5"> yeah but in</font>

129
00:05:26,370 --> 00:05:29,880
addition<font color="#E5E5E5"> what we</font><font color="#CCCCCC"> need to know is that</font>

130
00:05:27,800 --> 00:05:32,490
typically<font color="#E5E5E5"> the kernel is mapped into</font>

131
00:05:29,880 --> 00:05:34,710
<font color="#E5E5E5">every address space and in addition we</font>

132
00:05:32,490 --> 00:05:37,020
have<font color="#CCCCCC"> the direct physical map which maps</font>

133
00:05:34,710 --> 00:05:40,520
<font color="#E5E5E5">the entire physical memory also</font><font color="#CCCCCC"> in the</font>

134
00:05:37,020 --> 00:05:43,799
<font color="#CCCCCC">Chrome so as we can see in this picture</font>

135
00:05:40,520 --> 00:05:47,008
there's two virtual addresses mapping to

136
00:05:43,800 --> 00:05:49,320
the same<font color="#E5E5E5"> physical memory so maybe we can</font>

137
00:05:47,009 --> 00:05:52,770
<font color="#CCCCCC">use those addresses to read the memory</font>

138
00:05:49,320 --> 00:05:56,219
<font color="#E5E5E5">from so to summarize when we want load</font>

139
00:05:52,770 --> 00:05:58,590
an address we come to the permission

140
00:05:56,219 --> 00:06:01,740
<font color="#E5E5E5">track and either we have the permission</font>

141
00:05:58,590 --> 00:06:04,919
<font color="#CCCCCC">to load the data</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> we are fine then we</font>

142
00:06:01,740 --> 00:06:06,870
get loaded<font color="#E5E5E5"> data and can use it or the</font>

143
00:06:04,919 --> 00:06:10,948
permission check fails<font color="#E5E5E5"> and then we</font>

144
00:06:06,870 --> 00:06:12,960
simply crash<font color="#E5E5E5"> but that's what we see on</font>

145
00:06:10,949 --> 00:06:16,259
<font color="#E5E5E5">the architectural level</font><font color="#CCCCCC"> but there are</font>

146
00:06:12,960 --> 00:06:19,580
other attacks which allow<font color="#CCCCCC"> us to see and</font>

147
00:06:16,259 --> 00:06:22,110
observe<font color="#E5E5E5"> things that we wouldn't do</font>

148
00:06:19,580 --> 00:06:23,400
<font color="#E5E5E5">intentionally and these</font><font color="#CCCCCC"> attacks are</font>

149
00:06:22,110 --> 00:06:28,440
called<font color="#CCCCCC"> so-called</font><font color="#E5E5E5"> side-channel attacks</font>

150
00:06:23,400 --> 00:06:30,359
<font color="#E5E5E5">and so safe software infrastructure if</font>

151
00:06:28,440 --> 00:06:33,000
we have programs which do not contain

152
00:06:30,360 --> 00:06:35,370
<font color="#E5E5E5">any bug this does not mean necessary</font>

153
00:06:33,000 --> 00:06:37,190
<font color="#E5E5E5">that the</font><font color="#CCCCCC"> execution of</font><font color="#E5E5E5"> those programs on</font>

154
00:06:35,370 --> 00:06:41,450
our<font color="#E5E5E5"> CPUs are safe</font>

155
00:06:37,190 --> 00:06:45,050
because<font color="#E5E5E5"> information itself can leak from</font>

156
00:06:41,450 --> 00:06:48,590
<font color="#CCCCCC">the underlying hardware and those sites</font>

157
00:06:45,050 --> 00:06:51,050
<font color="#E5E5E5">on</font><font color="#CCCCCC"> EDX</font><font color="#E5E5E5"> then exploit this unintentional</font>

158
00:06:48,590 --> 00:06:53,719
information leakage by<font color="#E5E5E5"> observing those</font>

159
00:06:51,050 --> 00:06:55,490
side effects<font color="#CCCCCC"> and this for instance</font><font color="#E5E5E5"> could</font>

160
00:06:53,720 --> 00:06:59,090
be the power<font color="#E5E5E5"> consumption of the device</font>

161
00:06:55,490 --> 00:07:01,850
<font color="#CCCCCC">so depending on</font><font color="#E5E5E5"> the key that is used</font><font color="#CCCCCC"> the</font>

162
00:06:59,090 --> 00:07:05,390
<font color="#E5E5E5">device needs more power if it processes</font>

163
00:07:01,850 --> 00:07:08,990
a<font color="#CCCCCC"> 0 or a 1</font><font color="#E5E5E5"> or the overall</font><font color="#CCCCCC"> execution time</font>

164
00:07:05,390 --> 00:07:12,500
<font color="#E5E5E5">of the algorithm can allow us</font><font color="#CCCCCC"> to observe</font>

165
00:07:08,990 --> 00:07:15,620
the secret<font color="#E5E5E5"> that is processed in addition</font>

166
00:07:12,500 --> 00:07:18,860
we have those CPU caches<font color="#E5E5E5"> and maybe those</font>

167
00:07:15,620 --> 00:07:21,380
can also be<font color="#E5E5E5"> exploited</font><font color="#CCCCCC"> I think the CPU</font>

168
00:07:18,860 --> 00:07:23,780
<font color="#E5E5E5">caches are an interesting topic</font><font color="#CCCCCC"> so let's</font>

169
00:07:21,380 --> 00:07:26,210
talk a bit<font color="#CCCCCC"> more about caches and and</font>

170
00:07:23,780 --> 00:07:28,549
<font color="#CCCCCC">texts</font><font color="#E5E5E5"> with them so if you look at</font><font color="#CCCCCC"> a</font>

171
00:07:26,210 --> 00:07:31,400
simple program on the<font color="#E5E5E5"> left side simple C</font>

172
00:07:28,550 --> 00:07:33,380
code<font color="#E5E5E5"> just outputs two variables and then</font>

173
00:07:31,400 --> 00:07:36,650
we<font color="#CCCCCC"> have our CPU in the middle and</font><font color="#E5E5E5"> our T</font>

174
00:07:33,380 --> 00:07:39,290
<font color="#E5E5E5">Ram and the program has</font><font color="#CCCCCC"> to output a</font>

175
00:07:36,650 --> 00:07:41,750
value<font color="#E5E5E5"> like the variable</font><font color="#CCCCCC"> I here what</font>

176
00:07:39,290 --> 00:07:44,840
happens we have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> get the value somehow</font>

177
00:07:41,750 --> 00:07:47,420
<font color="#E5E5E5">so first</font><font color="#CCCCCC"> it tries to locate</font><font color="#E5E5E5"> this value</font>

178
00:07:44,840 --> 00:07:49,690
inside<font color="#E5E5E5"> the processor in the cache which</font>

179
00:07:47,420 --> 00:07:52,190
is<font color="#CCCCCC"> a really fast</font><font color="#E5E5E5"> memory inside the CPU</font>

180
00:07:49,690 --> 00:07:54,710
if it's not there<font color="#E5E5E5"> because</font><font color="#CCCCCC"> it was never</font>

181
00:07:52,190 --> 00:07:57,770
<font color="#E5E5E5">used before it has to be requested from</font>

182
00:07:54,710 --> 00:08:00,349
<font color="#CCCCCC">the DRAM and it has to</font><font color="#E5E5E5"> be read from the</font>

183
00:07:57,770 --> 00:08:03,409
memory the memory<font color="#CCCCCC"> then answers our</font>

184
00:08:00,350 --> 00:08:05,930
request<font color="#CCCCCC"> for this value responds with the</font>

185
00:08:03,410 --> 00:08:08,930
value and it goes again back<font color="#CCCCCC"> to the CPU</font>

186
00:08:05,930 --> 00:08:10,970
<font color="#E5E5E5">is stored there in the CPU cache so if</font>

187
00:08:08,930 --> 00:08:14,930
<font color="#E5E5E5">we need it again then it will be faster</font>

188
00:08:10,970 --> 00:08:17,150
and then we can use<font color="#E5E5E5"> it for the second</font>

189
00:08:14,930 --> 00:08:19,940
access to this variable<font color="#E5E5E5"> we see it's</font>

190
00:08:17,150 --> 00:08:22,010
<font color="#E5E5E5">already in the CPU cache because we used</font>

191
00:08:19,940 --> 00:08:25,190
it before<font color="#E5E5E5"> it's stored there</font><font color="#CCCCCC"> for future</font>

192
00:08:22,010 --> 00:08:27,919
access<font color="#E5E5E5"> until it gets evicted by a lot of</font>

193
00:08:25,190 --> 00:08:30,260
<font color="#CCCCCC">other data</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> have a cache hit there</font>

194
00:08:27,919 --> 00:08:33,289
we can read it<font color="#CCCCCC"> directly from</font><font color="#E5E5E5"> the CPU</font>

195
00:08:30,260 --> 00:08:36,468
cache and there's no<font color="#CCCCCC"> DRM</font><font color="#E5E5E5"> access involved</font>

196
00:08:33,289 --> 00:08:39,500
so this is a lot<font color="#E5E5E5"> faster than this</font><font color="#CCCCCC"> Didius</font>

197
00:08:36,469 --> 00:08:41,240
process of requesting it<font color="#CCCCCC"> from the trm</font>

198
00:08:39,500 --> 00:08:44,320
<font color="#E5E5E5">and waiting for</font><font color="#CCCCCC"> the theorem which is a</font>

199
00:08:41,240 --> 00:08:46,930
really<font color="#E5E5E5"> slow memory and this</font>

200
00:08:44,320 --> 00:08:50,130
makes our programs run a lot<font color="#CCCCCC"> faster</font><font color="#E5E5E5"> and</font>

201
00:08:46,930 --> 00:08:52,959
<font color="#CCCCCC">we can even measure</font><font color="#E5E5E5"> that if we have some</font>

202
00:08:50,130 --> 00:08:56,800
measurement methods to measure really

203
00:08:52,959 --> 00:08:59,859
<font color="#E5E5E5">small timings like we have on most of</font>

204
00:08:56,800 --> 00:09:01,750
the CPUs<font color="#E5E5E5"> nowadays then we can really</font>

205
00:08:59,860 --> 00:09:04,720
<font color="#E5E5E5">distinguish whether such a memory access</font>

206
00:09:01,750 --> 00:09:07,480
<font color="#E5E5E5">comes from the cache</font><font color="#CCCCCC"> or has to</font><font color="#E5E5E5"> be served</font>

207
00:09:04,720 --> 00:09:11,170
<font color="#E5E5E5">from the DRAM but in</font><font color="#CCCCCC"> Si have these</font>

208
00:09:07,480 --> 00:09:13,120
differences<font color="#E5E5E5"> here we can probably exploit</font>

209
00:09:11,170 --> 00:09:15,849
that<font color="#E5E5E5"> in an attack</font><font color="#CCCCCC"> right how will you do</font>

210
00:09:13,120 --> 00:09:17,560
that<font color="#CCCCCC"> I would think of this situation</font>

211
00:09:15,850 --> 00:09:19,300
<font color="#E5E5E5">here we have an attacker program a</font>

212
00:09:17,560 --> 00:09:21,399
victim program and they use<font color="#E5E5E5"> some shared</font>

213
00:09:19,300 --> 00:09:23,589
memory some shared library and this

214
00:09:21,399 --> 00:09:25,360
shared library is one<font color="#E5E5E5"> memory location in</font>

215
00:09:23,589 --> 00:09:28,000
there is cached<font color="#E5E5E5"> it's cached for both and</font>

216
00:09:25,360 --> 00:09:30,850
if the attacker now continuously flushes

217
00:09:28,000 --> 00:09:32,889
this memory location<font color="#CCCCCC"> it will be</font><font color="#E5E5E5"> not in a</font>

218
00:09:30,850 --> 00:09:36,790
cache anymore<font color="#E5E5E5"> and only if the victim</font>

219
00:09:32,889 --> 00:09:38,800
accesses this memory location<font color="#E5E5E5"> then it's</font>

220
00:09:36,790 --> 00:09:41,829
in the cache again<font color="#CCCCCC"> and the attacker will</font>

221
00:09:38,800 --> 00:09:45,189
also frequently<font color="#CCCCCC"> reacts s this location</font>

222
00:09:41,829 --> 00:09:47,229
and when the attacker observes<font color="#CCCCCC"> a fast</font>

223
00:09:45,190 --> 00:09:49,480
memory access the attacker learns that

224
00:09:47,230 --> 00:09:51,339
the victim has accessed this variable in

225
00:09:49,480 --> 00:09:54,910
the meantime<font color="#E5E5E5"> and if the attacker</font>

226
00:09:51,339 --> 00:09:56,319
observes<font color="#CCCCCC"> low</font><font color="#E5E5E5"> slow access time then the</font>

227
00:09:54,910 --> 00:09:59,620
attacker learns that the victim probably

228
00:09:56,319 --> 00:10:02,229
<font color="#E5E5E5">did not access it</font><font color="#CCCCCC"> so we can see whether</font>

229
00:09:59,620 --> 00:10:06,399
someone has accessed some specific data

230
00:10:02,230 --> 00:10:09,940
element exactly<font color="#E5E5E5"> great so this is pretty</font>

231
00:10:06,399 --> 00:10:12,430
low level already so when we think about

232
00:10:09,940 --> 00:10:15,010
programs we have a certain architecture

233
00:10:12,430 --> 00:10:17,019
we have<font color="#E5E5E5"> an instruction set and the</font>

234
00:10:15,010 --> 00:10:19,240
instruction set<font color="#CCCCCC"> is just an abstract</font>

235
00:10:17,019 --> 00:10:22,420
model<font color="#E5E5E5"> of our computer that</font><font color="#CCCCCC"> we use it</font>

236
00:10:19,240 --> 00:10:25,779
could be either x86<font color="#E5E5E5"> arm v8 for instance</font>

237
00:10:22,420 --> 00:10:28,000
or spark<font color="#E5E5E5"> and it serves as an interface</font>

238
00:10:25,779 --> 00:10:30,569
<font color="#CCCCCC">between the hardware that we're using</font>

239
00:10:28,000 --> 00:10:33,760
and<font color="#E5E5E5"> the software</font><font color="#CCCCCC"> that we are writing</font><font color="#E5E5E5"> and</font>

240
00:10:30,569 --> 00:10:36,069
when we talk about microarchitecture<font color="#E5E5E5"> we</font>

241
00:10:33,760 --> 00:10:39,459
talk<font color="#CCCCCC"> about the</font><font color="#E5E5E5"> actual implementation of</font>

242
00:10:36,069 --> 00:10:41,589
the<font color="#CCCCCC"> instruction set</font><font color="#E5E5E5"> and as we know we</font>

243
00:10:39,459 --> 00:10:43,050
have many<font color="#E5E5E5"> different CPUs therefore we</font>

244
00:10:41,589 --> 00:10:45,459
have also many different

245
00:10:43,050 --> 00:10:48,550
microarchitectures like AMD<font color="#CCCCCC"> rising</font><font color="#E5E5E5"> or</font>

246
00:10:45,459 --> 00:10:53,529
the intel core<font color="#E5E5E5"> CPUs or the intricacy on</font>

247
00:10:48,550 --> 00:10:56,680
GPUs<font color="#E5E5E5"> and so on so if you now think back</font>

248
00:10:53,529 --> 00:10:58,749
of computer architecture 101<font color="#CCCCCC"> how does</font><font color="#E5E5E5"> it</font>

249
00:10:56,680 --> 00:11:01,508
<font color="#E5E5E5">actually work if you have a program what</font>

250
00:10:58,749 --> 00:11:04,240
does<font color="#E5E5E5"> the CPU do and then we have this</font>

251
00:11:01,509 --> 00:11:06,870
pipeline<font color="#E5E5E5"> there where we have to multiple</font>

252
00:11:04,240 --> 00:11:09,610
<font color="#E5E5E5">stages and first we fetch an instruction</font>

253
00:11:06,870 --> 00:11:12,069
<font color="#CCCCCC">into the instruction cache</font><font color="#E5E5E5"> then we</font>

254
00:11:09,610 --> 00:11:14,800
decode this instruction<font color="#E5E5E5"> execute the</font>

255
00:11:12,069 --> 00:11:18,399
instruction in<font color="#CCCCCC"> the execution unit and we</font>

256
00:11:14,800 --> 00:11:22,059
can<font color="#E5E5E5"> do memory accesses and update the</font>

257
00:11:18,399 --> 00:11:25,209
architectural register files<font color="#E5E5E5"> and we can</font>

258
00:11:22,059 --> 00:11:27,040
do that in a pipeline<font color="#E5E5E5"> so if we are done</font>

259
00:11:25,209 --> 00:11:29,589
<font color="#E5E5E5">with the first</font><font color="#CCCCCC"> step of the fetch step of</font>

260
00:11:27,040 --> 00:11:31,569
one instruction<font color="#CCCCCC"> we can already get to</font>

261
00:11:29,589 --> 00:11:33,339
the<font color="#E5E5E5"> next instruction and fetch the next</font>

262
00:11:31,569 --> 00:11:36,399
instruction so<font color="#E5E5E5"> we can pipeline that</font>

263
00:11:33,339 --> 00:11:38,079
thing and that makes<font color="#E5E5E5"> our program core a</font>

264
00:11:36,399 --> 00:11:40,930
bit faster<font color="#CCCCCC"> because we don't have</font><font color="#E5E5E5"> to wait</font>

265
00:11:38,079 --> 00:11:44,920
for<font color="#CCCCCC"> one execution</font><font color="#E5E5E5"> to be finished when</font><font color="#CCCCCC"> we</font>

266
00:11:40,930 --> 00:11:48,579
start the next<font color="#E5E5E5"> instruction but all</font>

267
00:11:44,920 --> 00:11:50,800
instructions are executed<font color="#E5E5E5"> in order so in</font>

268
00:11:48,579 --> 00:11:54,248
the<font color="#E5E5E5"> same order</font><font color="#CCCCCC"> as they appear in our</font>

269
00:11:50,800 --> 00:11:56,378
program<font color="#CCCCCC"> and if we have some</font><font color="#E5E5E5"> dependencies</font>

270
00:11:54,249 --> 00:11:58,629
that<font color="#CCCCCC"> we cannot fulfill</font><font color="#E5E5E5"> in the execution</font>

271
00:11:56,379 --> 00:12:00,670
<font color="#E5E5E5">then we have to stall there and wait</font>

272
00:11:58,629 --> 00:12:03,430
until<font color="#E5E5E5"> the dependency is resolved for</font>

273
00:12:00,670 --> 00:12:06,459
this instruction<font color="#E5E5E5"> so it can continue and</font>

274
00:12:03,430 --> 00:12:09,189
if data is<font color="#E5E5E5"> not cached</font><font color="#CCCCCC"> we need to wait</font>

275
00:12:06,459 --> 00:12:10,809
for<font color="#CCCCCC"> a dram until it's in</font><font color="#E5E5E5"> the cache but</font>

276
00:12:09,189 --> 00:12:12,730
if you think<font color="#CCCCCC"> about this program</font><font color="#E5E5E5"> for</font>

277
00:12:10,809 --> 00:12:15,309
instance<font color="#E5E5E5"> here there are many things you</font>

278
00:12:12,730 --> 00:12:17,170
can<font color="#E5E5E5"> paralyze here and some have</font>

279
00:12:15,309 --> 00:12:20,620
dependencies<font color="#CCCCCC"> so it would be</font><font color="#E5E5E5"> very clever</font>

280
00:12:17,170 --> 00:12:22,599
<font color="#E5E5E5">to paralyze these steps and only run</font><font color="#CCCCCC"> the</font>

281
00:12:20,620 --> 00:12:25,959
parts<font color="#CCCCCC"> that depend on</font><font color="#E5E5E5"> previous</font>

282
00:12:22,600 --> 00:12:29,470
computations at a later point<font color="#E5E5E5"> right yeah</font>

283
00:12:25,959 --> 00:12:30,910
<font color="#E5E5E5">so not only does</font><font color="#CCCCCC"> the compiler change the</font>

284
00:12:29,470 --> 00:12:33,069
sequence<font color="#CCCCCC"> of the instructions</font><font color="#E5E5E5"> that are</font>

285
00:12:30,910 --> 00:12:35,529
executed also the CPU<font color="#E5E5E5"> itself can</font>

286
00:12:33,069 --> 00:12:37,870
optimize<font color="#CCCCCC"> that</font><font color="#E5E5E5"> and when</font><font color="#CCCCCC"> we have such a</font>

287
00:12:35,529 --> 00:12:40,870
<font color="#E5E5E5">CPU who does that we</font><font color="#CCCCCC"> talked</font><font color="#E5E5E5"> about out of</font>

288
00:12:37,870 --> 00:12:42,759
order executions<font color="#CCCCCC"> so</font><font color="#E5E5E5"> we now have two</font>

289
00:12:40,870 --> 00:12:44,529
sides the<font color="#CCCCCC"> front end</font><font color="#E5E5E5"> on the top and the</font>

290
00:12:42,759 --> 00:12:46,750
back<font color="#CCCCCC"> end on the bottom and the</font>

291
00:12:44,529 --> 00:12:48,610
instructions are fetched and decoded in

292
00:12:46,750 --> 00:12:50,920
the front end<font color="#E5E5E5"> and then they are</font>

293
00:12:48,610 --> 00:12:54,040
dispatched into<font color="#E5E5E5"> the back end</font><font color="#CCCCCC"> and there</font>

294
00:12:50,920 --> 00:12:57,729
we have multiple execution units that

295
00:12:54,040 --> 00:12:59,860
<font color="#E5E5E5">then process those instructions this</font>

296
00:12:57,730 --> 00:13:04,059
means that we can<font color="#E5E5E5"> now execute</font>

297
00:12:59,860 --> 00:13:05,980
instructions out of order<font color="#CCCCCC"> and they just</font>

298
00:13:04,059 --> 00:13:06,469
now need<font color="#CCCCCC"> to wait until</font><font color="#E5E5E5"> the dependencies</font>

299
00:13:05,980 --> 00:13:08,180
are ready

300
00:13:06,470 --> 00:13:11,480
if they do<font color="#E5E5E5"> not have a dependency you can</font>

301
00:13:08,180 --> 00:13:13,910
execute them right<font color="#E5E5E5"> away</font><font color="#CCCCCC"> so this means</font>

302
00:13:11,480 --> 00:13:16,430
that in your<font color="#CCCCCC"> program you can have</font>

303
00:13:13,910 --> 00:13:18,620
<font color="#E5E5E5">instructions that would occur later but</font>

304
00:13:16,430 --> 00:13:21,800
I executed<font color="#CCCCCC"> before other instructions</font>

305
00:13:18,620 --> 00:13:24,440
<font color="#E5E5E5">because the execution unit has time to</font>

306
00:13:21,800 --> 00:13:26,300
work on<font color="#E5E5E5"> that instruction but the most</font>

307
00:13:24,440 --> 00:13:28,700
important thing is<font color="#CCCCCC"> that</font><font color="#E5E5E5"> those</font>

308
00:13:26,300 --> 00:13:30,650
instructions are then retired in<font color="#E5E5E5"> order</font>

309
00:13:28,700 --> 00:13:32,630
because<font color="#E5E5E5"> otherwise the program</font><font color="#CCCCCC"> would do</font>

310
00:13:30,650 --> 00:13:35,199
something different<font color="#E5E5E5"> what the programmer</font>

311
00:13:32,630 --> 00:13:38,060
did not<font color="#CCCCCC"> intend the program to do and</font>

312
00:13:35,200 --> 00:13:38,840
only<font color="#E5E5E5"> then when this instruction is</font>

313
00:13:38,060 --> 00:13:41,540
retired

314
00:13:38,840 --> 00:13:45,260
the architectural<font color="#E5E5E5"> state becomes visible</font>

315
00:13:41,540 --> 00:13:47,750
<font color="#E5E5E5">and when an</font><font color="#CCCCCC"> exception occurs</font><font color="#E5E5E5"> they are</font>

316
00:13:45,260 --> 00:13:50,180
checked during<font color="#E5E5E5"> the retirement and then</font>

317
00:13:47,750 --> 00:13:52,670
the pipeline can<font color="#E5E5E5"> be flushed and the</font><font color="#CCCCCC"> CPU</font>

318
00:13:50,180 --> 00:13:54,709
can recover from a same state<font color="#E5E5E5"> that it</font>

319
00:13:52,670 --> 00:13:57,500
had before<font color="#E5E5E5"> so although this is called</font>

320
00:13:54,710 --> 00:13:59,540
out of<font color="#E5E5E5"> order this yes architectural II</font>

321
00:13:57,500 --> 00:14:00,920
it looks like everything<font color="#CCCCCC"> is executed yes</font>

322
00:13:59,540 --> 00:14:03,469
<font color="#E5E5E5">because</font><font color="#CCCCCC"> it's happening</font><font color="#E5E5E5"> on the</font>

323
00:14:00,920 --> 00:14:05,150
microarchitecture level so on the

324
00:14:03,470 --> 00:14:07,460
architecture level<font color="#E5E5E5"> everything is the</font>

325
00:14:05,150 --> 00:14:11,689
same<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> just</font><font color="#E5E5E5"> don't know how the CPU</font>

326
00:14:07,460 --> 00:14:15,320
is built but since the<font color="#E5E5E5"> state only</font>

327
00:14:11,690 --> 00:14:16,750
<font color="#E5E5E5">becomes visible architecture</font><font color="#CCCCCC"> Li what</font>

328
00:14:15,320 --> 00:14:20,510
does this mean on the microarchitecture

329
00:14:16,750 --> 00:14:22,610
level so I have a good idea<font color="#CCCCCC"> we can</font>

330
00:14:20,510 --> 00:14:25,160
change the code<font color="#E5E5E5"> from earlier to my new</font>

331
00:14:22,610 --> 00:14:26,630
code<font color="#CCCCCC"> because I'm good at programming</font><font color="#E5E5E5"> we</font>

332
00:14:25,160 --> 00:14:29,089
start right off with<font color="#CCCCCC"> a null pointer</font>

333
00:14:26,630 --> 00:14:31,670
dereference wait wait wait what what<font color="#CCCCCC"> I</font>

334
00:14:29,090 --> 00:14:34,700
are<font color="#E5E5E5"> trying to do here</font><font color="#CCCCCC"> yeah</font><font color="#E5E5E5"> so first I'm</font>

335
00:14:31,670 --> 00:14:36,829
<font color="#CCCCCC">just</font><font color="#E5E5E5"> referencing</font><font color="#CCCCCC"> yet with zero why is</font>

336
00:14:34,700 --> 00:14:38,960
<font color="#E5E5E5">there even a volatile in there yeah</font>

337
00:14:36,830 --> 00:14:40,820
because when<font color="#E5E5E5"> I wrote the code the</font>

338
00:14:38,960 --> 00:14:44,210
compiler<font color="#E5E5E5"> said this statement has no</font>

339
00:14:40,820 --> 00:14:46,010
effect so it would optimize the code

340
00:14:44,210 --> 00:14:47,360
away<font color="#E5E5E5"> so you really want to</font><font color="#CCCCCC"> have a null</font>

341
00:14:46,010 --> 00:14:50,300
pointer there which precious your

342
00:14:47,360 --> 00:14:53,450
<font color="#E5E5E5">program</font><font color="#CCCCCC"> yeah why not</font><font color="#E5E5E5"> make sense at least</font>

343
00:14:50,300 --> 00:14:55,339
<font color="#CCCCCC">to</font><font color="#E5E5E5"> me so my static code analysis not</font>

344
00:14:53,450 --> 00:14:57,200
<font color="#E5E5E5">happy with that does he have a null</font>

345
00:14:55,340 --> 00:14:58,940
pointer<font color="#E5E5E5"> yeah who cares about code</font>

346
00:14:57,200 --> 00:15:01,280
<font color="#E5E5E5">analyzers</font><font color="#CCCCCC"> there are so many false</font>

347
00:14:58,940 --> 00:15:03,290
positive like in this<font color="#CCCCCC"> example so at</font>

348
00:15:01,280 --> 00:15:06,410
<font color="#CCCCCC">first we dereferencing the</font><font color="#E5E5E5"> null pointer</font>

349
00:15:03,290 --> 00:15:13,219
and then we just access<font color="#E5E5E5"> an index of an</font>

350
00:15:06,410 --> 00:15:15,980
<font color="#E5E5E5">array okay so it crashes</font><font color="#CCCCCC"> okay you can</font>

351
00:15:13,220 --> 00:15:17,810
just<font color="#CCCCCC"> catch the segmentation</font><font color="#E5E5E5"> fault and if</font>

352
00:15:15,980 --> 00:15:18,950
we look at<font color="#E5E5E5"> the flash and</font><font color="#CCCCCC"> reload attack</font>

353
00:15:17,810 --> 00:15:22,010
that<font color="#E5E5E5"> Daniel described there</font>

354
00:15:18,950 --> 00:15:23,990
<font color="#CCCCCC">we can now just</font><font color="#E5E5E5"> iterate with the flash</font>

355
00:15:22,010 --> 00:15:26,990
<font color="#E5E5E5">and reload attack over the entire array</font>

356
00:15:23,990 --> 00:15:30,830
and boom<font color="#E5E5E5"> you have a cache hit</font>

357
00:15:26,990 --> 00:15:32,690
so<font color="#CCCCCC"> you're unreachable code line which</font>

358
00:15:30,830 --> 00:15:35,330
comes after<font color="#CCCCCC"> the null pointer which</font>

359
00:15:32,690 --> 00:15:37,970
should<font color="#CCCCCC"> crash the program immediately was</font>

360
00:15:35,330 --> 00:15:40,880
actually executed<font color="#CCCCCC"> yeah it's all see</font><font color="#E5E5E5"> that</font>

361
00:15:37,970 --> 00:15:44,150
by using<font color="#CCCCCC"> volatile it has an effect and</font>

362
00:15:40,880 --> 00:15:46,850
<font color="#CCCCCC">we</font><font color="#E5E5E5"> can see that in the cache so</font><font color="#CCCCCC"> they</font>

363
00:15:44,150 --> 00:15:48,740
<font color="#CCCCCC">accept an exception was too late maybe</font>

364
00:15:46,850 --> 00:15:50,690
so it's something<font color="#CCCCCC"> although it should</font>

365
00:15:48,740 --> 00:15:52,610
have crashed already so that's

366
00:15:50,690 --> 00:15:54,550
<font color="#CCCCCC">interesting that</font><font color="#E5E5E5"> means that out of all</font>

367
00:15:52,610 --> 00:15:57,550
the executed instructions<font color="#E5E5E5"> leave</font>

368
00:15:54,550 --> 00:16:01,400
<font color="#CCCCCC">microarchitecture traces and that can be</font>

369
00:15:57,550 --> 00:16:03,319
some state<font color="#E5E5E5"> of the cache it can be other</font>

370
00:16:01,400 --> 00:16:05,120
Mike from architectural elements that

371
00:16:03,320 --> 00:16:09,250
are brought<font color="#E5E5E5"> in to a different state but</font>

372
00:16:05,120 --> 00:16:12,320
it can also<font color="#CCCCCC"> be some concurrency effect</font>

373
00:16:09,250 --> 00:16:13,940
<font color="#E5E5E5">we give a name to such instructions we</font>

374
00:16:12,320 --> 00:16:16,940
call them transient instructions because

375
00:16:13,940 --> 00:16:18,920
<font color="#E5E5E5">we somehow execute them but then we've</font>

376
00:16:16,940 --> 00:16:23,510
managed before<font color="#CCCCCC"> they are actually</font>

377
00:16:18,920 --> 00:16:26,089
architectural II made<font color="#E5E5E5"> visible so we can</font>

378
00:16:23,510 --> 00:16:29,630
through micro architectural side

379
00:16:26,090 --> 00:16:33,920
channels then observe the execution of

380
00:16:29,630 --> 00:16:36,740
these transient instructions we found on

381
00:16:33,920 --> 00:16:38,270
December<font color="#E5E5E5"> 3rd</font><font color="#CCCCCC"> we were</font><font color="#E5E5E5"> quite busy</font><font color="#CCCCCC"> around</font>

382
00:16:36,740 --> 00:16:39,890
<font color="#E5E5E5">the time we were because</font><font color="#CCCCCC"> we were still</font>

383
00:16:38,270 --> 00:16:42,800
<font color="#E5E5E5">busy with the research on the other</font>

384
00:16:39,890 --> 00:16:45,410
<font color="#E5E5E5">black</font><font color="#CCCCCC"> hair talk we had earlier</font><font color="#E5E5E5"> by that</font>

385
00:16:42,800 --> 00:16:47,750
time but on<font color="#CCCCCC"> December</font><font color="#E5E5E5"> 3rd we decided</font><font color="#CCCCCC"> ok</font>

386
00:16:45,410 --> 00:16:50,480
we<font color="#CCCCCC"> should probably prioritize this</font><font color="#E5E5E5"> and</font>

387
00:16:47,750 --> 00:16:52,850
look at<font color="#E5E5E5"> this now and then we looked at</font>

388
00:16:50,480 --> 00:16:54,710
<font color="#E5E5E5">this independently and all three of us</font>

389
00:16:52,850 --> 00:16:57,770
came up with an<font color="#CCCCCC"> implementation of the</font>

390
00:16:54,710 --> 00:17:01,910
<font color="#E5E5E5">mate</font><font color="#CCCCCC"> on attack</font><font color="#E5E5E5"> and we discovered that it</font>

391
00:16:57,770 --> 00:17:03,770
<font color="#E5E5E5">actually worked so the only thing that</font>

392
00:17:01,910 --> 00:17:05,869
we need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> change from my code example</font>

393
00:17:03,770 --> 00:17:08,150
earlier is if you<font color="#E5E5E5"> remember the first</font>

394
00:17:05,869 --> 00:17:10,429
example that<font color="#E5E5E5"> we had we just</font><font color="#CCCCCC"> used</font><font color="#E5E5E5"> the</font>

395
00:17:08,150 --> 00:17:13,490
address from the kernel<font color="#E5E5E5"> and dereferences</font>

396
00:17:10,430 --> 00:17:17,150
<font color="#E5E5E5">it but this time instead</font><font color="#CCCCCC"> of using printf</font>

397
00:17:13,490 --> 00:17:19,400
<font color="#E5E5E5">we just access the array at the index</font>

398
00:17:17,150 --> 00:17:23,959
represented<font color="#CCCCCC"> padded</font><font color="#E5E5E5"> bytes</font><font color="#CCCCCC"> that we just</font>

399
00:17:19,400 --> 00:17:26,810
read<font color="#E5E5E5"> and then we do the same</font><font color="#CCCCCC"> flush and</font>

400
00:17:23,959 --> 00:17:29,480
reload attack again as earlier mounted

401
00:17:26,810 --> 00:17:31,159
<font color="#E5E5E5">over the entire array and check if there</font>

402
00:17:29,480 --> 00:17:33,710
is<font color="#CCCCCC"> a part of the array</font><font color="#E5E5E5"> that is</font>

403
00:17:31,160 --> 00:17:36,260
<font color="#CCCCCC">cashed so you say just adding another</font>

404
00:17:33,710 --> 00:17:39,950
<font color="#CCCCCC">layer</font><font color="#E5E5E5"> of indirection</font><font color="#CCCCCC"> again solves all</font>

405
00:17:36,260 --> 00:17:41,740
the problems<font color="#E5E5E5"> like all the time</font><font color="#CCCCCC"> I do</font><font color="#E5E5E5"> okay</font>

406
00:17:39,950 --> 00:17:46,310
so let's try<font color="#E5E5E5"> that</font>

407
00:17:41,740 --> 00:17:49,640
Wow so I did<font color="#E5E5E5"> that and I got a cache hit</font>

408
00:17:46,310 --> 00:17:52,970
<font color="#CCCCCC">you know exactly</font><font color="#E5E5E5"> at this index of the</font>

409
00:17:49,640 --> 00:17:55,310
value at the address<font color="#CCCCCC"> I dereference</font><font color="#E5E5E5"> so</font>

410
00:17:52,970 --> 00:17:58,160
the index<font color="#E5E5E5"> of the cache</font><font color="#CCCCCC"> it actually</font>

411
00:17:55,310 --> 00:18:01,639
revealed<font color="#CCCCCC"> the value that store</font><font color="#E5E5E5"> there in</font>

412
00:17:58,160 --> 00:18:04,460
the kernel memory<font color="#E5E5E5"> so</font><font color="#CCCCCC"> termination check</font>

413
00:18:01,640 --> 00:18:09,140
was<font color="#CCCCCC"> not fast enough</font><font color="#E5E5E5"> it sounds like you</font>

414
00:18:04,460 --> 00:18:12,080
<font color="#E5E5E5">planned this is meltdown Melton is using</font>

415
00:18:09,140 --> 00:18:17,360
out of order<font color="#CCCCCC"> execution</font><font color="#E5E5E5"> to read data from</font>

416
00:18:12,080 --> 00:18:20,210
<font color="#E5E5E5">any address the index of the cache</font><font color="#CCCCCC"> hit</font>

417
00:18:17,360 --> 00:18:21,740
<font color="#E5E5E5">reveals what data we read because we</font>

418
00:18:20,210 --> 00:18:23,810
<font color="#E5E5E5">encode it through this cache</font>

419
00:18:21,740 --> 00:18:26,660
side-channel<font color="#CCCCCC"> to</font><font color="#E5E5E5"> transmit it from the</font>

420
00:18:23,810 --> 00:18:29,149
olive<font color="#E5E5E5"> oyl execution realm to the normal</font>

421
00:18:26,660 --> 00:18:31,730
<font color="#CCCCCC">world</font><font color="#E5E5E5"> the permission check is not fast</font>

422
00:18:29,150 --> 00:18:33,500
enough<font color="#E5E5E5"> in some cases and the entirely</font>

423
00:18:31,730 --> 00:18:35,630
physical<font color="#E5E5E5"> entire physical memory is</font>

424
00:18:33,500 --> 00:18:39,260
<font color="#E5E5E5">typically accessible through the kernel</font>

425
00:18:35,630 --> 00:18:42,170
space and we reported this<font color="#CCCCCC"> to</font><font color="#E5E5E5"> Intel on</font>

426
00:18:39,260 --> 00:18:45,110
December 4<font color="#CCCCCC"> and then continued working in</font>

427
00:18:42,170 --> 00:18:48,290
<font color="#E5E5E5">this direction and one of the first</font>

428
00:18:45,110 --> 00:18:52,550
things that<font color="#E5E5E5"> I wrote on December</font><font color="#CCCCCC"> 3rd they</font>

429
00:18:48,290 --> 00:18:54,620
<font color="#E5E5E5">was still I wrote a tool to dump just</font>

430
00:18:52,550 --> 00:18:59,210
arbitrary<font color="#E5E5E5"> memory locations dump and dump</font>

431
00:18:54,620 --> 00:19:02,780
<font color="#E5E5E5">Mary and yeah</font><font color="#CCCCCC"> Karl Mary all over the</font>

432
00:18:59,210 --> 00:19:05,480
terminal so we also<font color="#E5E5E5"> brought a demo of</font>

433
00:19:02,780 --> 00:19:08,240
this with us we just<font color="#CCCCCC"> stopped at</font><font color="#E5E5E5"> a</font>

434
00:19:05,480 --> 00:19:11,450
<font color="#E5E5E5">certain address and dump the memory and</font>

435
00:19:08,240 --> 00:19:14,480
in this<font color="#E5E5E5"> example the</font><font color="#CCCCCC"> address is located</font>

436
00:19:11,450 --> 00:19:17,180
at the position<font color="#CCCCCC"> in memory where there is</font>

437
00:19:14,480 --> 00:19:18,860
a log stored for<font color="#E5E5E5"> the descriptions of the</font>

438
00:19:17,180 --> 00:19:21,770
package manager<font color="#CCCCCC"> installed on the system</font>

439
00:19:18,860 --> 00:19:22,820
<font color="#CCCCCC">and we just tamp it</font><font color="#E5E5E5"> if there would be a</font>

440
00:19:21,770 --> 00:19:24,470
key<font color="#E5E5E5"> stored in the air</font>

441
00:19:22,820 --> 00:19:26,810
we could also<font color="#CCCCCC"> lick the key</font><font color="#E5E5E5"> so</font>

442
00:19:24,470 --> 00:19:30,290
<font color="#CCCCCC">independently</font><font color="#E5E5E5"> on what's written there we</font>

443
00:19:26,810 --> 00:19:33,080
can dump it<font color="#E5E5E5"> but with the code that</font><font color="#CCCCCC"> you</font>

444
00:19:30,290 --> 00:19:35,000
showed<font color="#CCCCCC"> before we can only read a single</font>

445
00:19:33,080 --> 00:19:37,100
<font color="#E5E5E5">character and</font><font color="#CCCCCC"> then do the flash reload</font>

446
00:19:35,000 --> 00:19:38,429
<font color="#CCCCCC">but it crashes immediately because it's</font>

447
00:19:37,100 --> 00:19:40,799
still an exception<font color="#E5E5E5"> that</font>

448
00:19:38,429 --> 00:19:42,509
has to be<font color="#E5E5E5"> handled so how do you prevent</font>

449
00:19:40,799 --> 00:19:45,629
the crash then to dump the<font color="#E5E5E5"> whole</font><font color="#CCCCCC"> memory</font>

450
00:19:42,509 --> 00:19:47,429
so like in the beginning<font color="#CCCCCC"> I said</font><font color="#E5E5E5"> when</font>

451
00:19:45,629 --> 00:19:49,320
there is an exception<font color="#CCCCCC"> you just catch the</font>

452
00:19:47,429 --> 00:19:51,450
exception<font color="#CCCCCC"> so we can just do fault</font>

453
00:19:49,320 --> 00:19:54,389
handling to catch the exception<font color="#CCCCCC"> jump</font>

454
00:19:51,450 --> 00:19:57,059
back and try again<font color="#CCCCCC"> in addition we can</font>

455
00:19:54,389 --> 00:19:59,549
<font color="#CCCCCC">also do</font><font color="#E5E5E5"> fault suppression by using</font>

456
00:19:57,059 --> 00:20:02,158
include<font color="#CCCCCC"> tsx which we'll see</font><font color="#E5E5E5"> pretty soon</font>

457
00:19:59,549 --> 00:20:04,289
<font color="#E5E5E5">yeah when we got in touch with Paul</font>

458
00:20:02,159 --> 00:20:06,929
culture through inter interconnected

459
00:20:04,289 --> 00:20:08,940
<font color="#CCCCCC">earth with us with</font><font color="#E5E5E5"> polyculture</font><font color="#CCCCCC"> he told</font>

460
00:20:06,929 --> 00:20:11,700
us<font color="#CCCCCC"> that he founds</font><font color="#E5E5E5"> something he called</font>

461
00:20:08,940 --> 00:20:14,580
<font color="#CCCCCC">spectra</font><font color="#E5E5E5"> and then we thought</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> yeah we</font>

462
00:20:11,700 --> 00:20:16,350
can also use this to suppress<font color="#E5E5E5"> faults</font>

463
00:20:14,580 --> 00:20:18,449
<font color="#CCCCCC">right yes event</font><font color="#E5E5E5"> fault</font><font color="#CCCCCC"> yes so with</font>

464
00:20:16,350 --> 00:20:20,459
speculative execution<font color="#CCCCCC"> we can also</font>

465
00:20:18,450 --> 00:20:22,769
prevent<font color="#CCCCCC"> the fault in the first</font><font color="#E5E5E5"> place</font>

466
00:20:20,460 --> 00:20:24,929
so let's talk about<font color="#E5E5E5"> this version with</font>

467
00:20:22,769 --> 00:20:28,440
<font color="#CCCCCC">TSX because I think</font><font color="#E5E5E5"> that's one of the</font>

468
00:20:24,929 --> 00:20:29,669
<font color="#E5E5E5">most beautiful versions of meltdown TSX</font>

469
00:20:28,440 --> 00:20:31,980
is a really<font color="#E5E5E5"> cool feature</font>

470
00:20:29,669 --> 00:20:35,429
<font color="#E5E5E5">it was designed</font><font color="#CCCCCC"> by ental to replace</font>

471
00:20:31,980 --> 00:20:37,159
locking in certain scenarios<font color="#CCCCCC"> but we used</font>

472
00:20:35,429 --> 00:20:39,690
it for<font color="#CCCCCC"> a lot of</font><font color="#E5E5E5"> different</font><font color="#CCCCCC"> things already</font>

473
00:20:37,159 --> 00:20:42,149
because it has a<font color="#E5E5E5"> really</font><font color="#CCCCCC"> cool side effect</font>

474
00:20:39,690 --> 00:20:44,669
of suppressing exceptions it just

475
00:20:42,149 --> 00:20:46,168
started transaction and<font color="#E5E5E5"> to stuff</font>

476
00:20:44,669 --> 00:20:48,480
whatever you want to do and you can do

477
00:20:46,169 --> 00:20:50,519
illegal stuff<font color="#E5E5E5"> in it like</font><font color="#CCCCCC"> dereference a</font>

478
00:20:48,480 --> 00:20:52,980
<font color="#CCCCCC">coil</font><font color="#E5E5E5"> memory address</font><font color="#CCCCCC"> which would</font><font color="#E5E5E5"> normally</font>

479
00:20:50,519 --> 00:20:54,809
throw an exception but<font color="#CCCCCC"> the</font><font color="#E5E5E5"> tsx</font>

480
00:20:52,980 --> 00:20:57,779
transaction<font color="#CCCCCC"> just</font><font color="#E5E5E5"> reports there and</font>

481
00:20:54,809 --> 00:21:00,869
doesn't<font color="#CCCCCC"> crash the application so we can</font>

482
00:20:57,779 --> 00:21:04,350
simply start<font color="#E5E5E5"> a TSX transaction before</font><font color="#CCCCCC"> we</font>

483
00:21:00,869 --> 00:21:06,059
do<font color="#CCCCCC"> all this meltdown magic</font><font color="#E5E5E5"> the</font>

484
00:21:04,350 --> 00:21:09,090
transaction will<font color="#CCCCCC"> abort</font><font color="#E5E5E5"> but that's fine</font>

485
00:21:06,059 --> 00:21:10,649
the program does not<font color="#E5E5E5"> crash</font><font color="#CCCCCC"> and we get</font>

486
00:21:09,090 --> 00:21:13,799
the memory and we can do<font color="#E5E5E5"> that in a loop</font>

487
00:21:10,649 --> 00:21:16,018
<font color="#E5E5E5">and dump the whole memory with that yeah</font>

488
00:21:13,799 --> 00:21:17,639
and<font color="#E5E5E5"> every</font><font color="#CCCCCC"> might</font><font color="#E5E5E5"> way yeah because</font><font color="#CCCCCC"> we</font>

489
00:21:16,019 --> 00:21:22,169
don't have<font color="#E5E5E5"> to handle exceptions like in</font>

490
00:21:17,639 --> 00:21:25,139
<font color="#E5E5E5">a exception handling case yes also</font><font color="#CCCCCC"> we</font>

491
00:21:22,169 --> 00:21:27,240
can use<font color="#CCCCCC"> asset speculative execution</font><font color="#E5E5E5"> to</font>

492
00:21:25,139 --> 00:21:29,668
prevent the exception to occur in the

493
00:21:27,240 --> 00:21:31,950
<font color="#E5E5E5">first place so in this example we have</font>

494
00:21:29,669 --> 00:21:35,309
<font color="#CCCCCC">the speculate variable which is just</font>

495
00:21:31,950 --> 00:21:38,730
random<font color="#E5E5E5"> modulo 2 and then depending on</font>

496
00:21:35,309 --> 00:21:40,619
<font color="#E5E5E5">the value written in there we choose an</font>

497
00:21:38,730 --> 00:21:43,889
address which is<font color="#E5E5E5"> either a valid</font><font color="#CCCCCC"> address</font>

498
00:21:40,619 --> 00:21:46,408
or the inaccessible kernel address then

499
00:21:43,889 --> 00:21:48,779
we have the if condition and<font color="#E5E5E5"> depending</font>

500
00:21:46,409 --> 00:21:51,160
<font color="#E5E5E5">on what the value</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> we either try to</font>

501
00:21:48,779 --> 00:21:53,200
read from the village position on

502
00:21:51,160 --> 00:21:55,000
but by<font color="#CCCCCC"> Miss draining the branch</font>

503
00:21:53,200 --> 00:21:58,030
predictor<font color="#E5E5E5"> who does not know at this</font>

504
00:21:55,000 --> 00:22:00,610
place<font color="#CCCCCC"> okay do I go into that condition</font>

505
00:21:58,030 --> 00:22:03,310
<font color="#CCCCCC">or not because it hasn't read the</font>

506
00:22:00,610 --> 00:22:06,129
<font color="#E5E5E5">variable speculate yet it will at some</font>

507
00:22:03,310 --> 00:22:10,030
point<font color="#CCCCCC"> try to</font><font color="#E5E5E5"> read the kernel address and</font>

508
00:22:06,130 --> 00:22:12,790
then use the value to load the address

509
00:22:10,030 --> 00:22:14,440
stored<font color="#E5E5E5"> and the index of the array and</font>

510
00:22:12,790 --> 00:22:19,389
then<font color="#CCCCCC"> we have the flash and reload again</font>

511
00:22:14,440 --> 00:22:21,880
<font color="#CCCCCC">and then we can also leak the memory we</font>

512
00:22:19,390 --> 00:22:25,480
can<font color="#E5E5E5"> even improve the performance by a</font>

513
00:22:21,880 --> 00:22:28,050
really nice trick<font color="#E5E5E5"> by adding an</font>

514
00:22:25,480 --> 00:22:30,610
additional<font color="#CCCCCC"> nine pointer dereference a</font>

515
00:22:28,050 --> 00:22:33,159
null<font color="#E5E5E5"> pointer</font><font color="#CCCCCC"> I really really like</font><font color="#E5E5E5"> our</font>

516
00:22:30,610 --> 00:22:37,000
null pointer so we learn to love them

517
00:22:33,160 --> 00:22:38,800
during the development so in our code<font color="#E5E5E5"> we</font>

518
00:22:37,000 --> 00:22:40,510
just<font color="#CCCCCC"> add a null pointer dereference</font>

519
00:22:38,800 --> 00:22:42,460
before we dereference the<font color="#CCCCCC"> current</font>

520
00:22:40,510 --> 00:22:46,120
address or more illegal<font color="#CCCCCC"> stuff in our</font>

521
00:22:42,460 --> 00:22:48,220
application<font color="#E5E5E5"> and this is really cool</font>

522
00:22:46,120 --> 00:22:52,000
<font color="#E5E5E5">because it it makes the take a lot</font>

523
00:22:48,220 --> 00:22:54,730
faster and more<font color="#CCCCCC"> stable</font><font color="#E5E5E5"> because</font>

524
00:22:52,000 --> 00:22:57,040
<font color="#E5E5E5">apparently that</font><font color="#CCCCCC"> the null pointer blocks</font>

525
00:22:54,730 --> 00:23:01,420
some exception handling and we<font color="#CCCCCC"> have more</font>

526
00:22:57,040 --> 00:23:04,690
time to<font color="#E5E5E5"> actually leak this value so this</font>

527
00:23:01,420 --> 00:23:07,180
<font color="#E5E5E5">is all very nice</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> you can only leak</font>

528
00:23:04,690 --> 00:23:10,900
data that is in<font color="#E5E5E5"> level one cache right</font>

529
00:23:07,180 --> 00:23:13,930
<font color="#E5E5E5">not anything else what if I told you</font>

530
00:23:10,900 --> 00:23:19,930
<font color="#E5E5E5">that you can leak the entire memory</font>

531
00:23:13,930 --> 00:23:22,990
contents with my<font color="#CCCCCC"> town</font><font color="#E5E5E5"> okay so what we</font>

532
00:23:19,930 --> 00:23:24,460
saw in<font color="#CCCCCC"> january and also</font><font color="#E5E5E5"> before that</font><font color="#CCCCCC"> we</font>

533
00:23:22,990 --> 00:23:26,350
had a lot<font color="#CCCCCC"> of trouble convincing other</font>

534
00:23:24,460 --> 00:23:28,900
people<font color="#CCCCCC"> that we can actually</font><font color="#E5E5E5"> read data</font>

535
00:23:26,350 --> 00:23:30,909
that is not in the level<font color="#CCCCCC"> 1 cache it was</font>

536
00:23:28,900 --> 00:23:32,410
assumed that<font color="#E5E5E5"> you can only leak data is</font>

537
00:23:30,910 --> 00:23:34,720
stored<font color="#E5E5E5"> in the level 1 cache this was</font>

538
00:23:32,410 --> 00:23:38,170
<font color="#E5E5E5">also what google</font><font color="#CCCCCC"> yuen-han from google</font>

539
00:23:34,720 --> 00:23:41,740
<font color="#E5E5E5">project zero reported and we tried a</font><font color="#CCCCCC"> lot</font>

540
00:23:38,170 --> 00:23:45,430
of<font color="#E5E5E5"> things</font><font color="#CCCCCC"> and yeah</font><font color="#E5E5E5"> for example we</font>

541
00:23:41,740 --> 00:23:48,760
experimented<font color="#E5E5E5"> by forcing the meltdown</font>

542
00:23:45,430 --> 00:23:50,710
attack to one processor core and then on

543
00:23:48,760 --> 00:23:52,990
a different<font color="#E5E5E5"> core we had the secret in</font>

544
00:23:50,710 --> 00:23:55,050
the application<font color="#E5E5E5"> so they can</font><font color="#CCCCCC"> share the</font>

545
00:23:52,990 --> 00:23:57,440
<font color="#CCCCCC">ladder first</font><font color="#E5E5E5"> level cache</font><font color="#CCCCCC"> that one cache</font>

546
00:23:55,050 --> 00:23:59,659
<font color="#CCCCCC">only the last level cache</font>

547
00:23:57,440 --> 00:24:02,180
and we were still able to<font color="#E5E5E5"> leak the</font>

548
00:23:59,660 --> 00:24:04,370
secret so it can't be<font color="#CCCCCC"> the case with the</font>

549
00:24:02,180 --> 00:24:05,990
l1 it also works<font color="#E5E5E5"> with</font><font color="#CCCCCC"> the l3 cache we</font>

550
00:24:04,370 --> 00:24:09,010
also made sure that<font color="#E5E5E5"> it's never in the l1</font>

551
00:24:05,990 --> 00:24:12,230
by constantly<font color="#CCCCCC"> flushing the secret and</font>

552
00:24:09,010 --> 00:24:15,620
still we were able<font color="#CCCCCC"> to Lee get it it took</font>

553
00:24:12,230 --> 00:24:18,470
a bit longer<font color="#CCCCCC"> so it was not</font><font color="#E5E5E5"> that fast in</font>

554
00:24:15,620 --> 00:24:21,139
leaking the values but still<font color="#E5E5E5"> we were</font>

555
00:24:18,470 --> 00:24:23,390
able<font color="#E5E5E5"> to leak when you Stella also in a</font>

556
00:24:21,140 --> 00:24:27,500
level<font color="#CCCCCC"> 3 cache</font><font color="#E5E5E5"> and of course</font><font color="#CCCCCC"> was in</font><font color="#E5E5E5"> a</font>

557
00:24:23,390 --> 00:24:30,290
level 2 cache<font color="#E5E5E5"> and during this Melton</font>

558
00:24:27,500 --> 00:24:34,760
would even get the values<font color="#E5E5E5"> into the level</font>

559
00:24:30,290 --> 00:24:38,000
1 cache for<font color="#E5E5E5"> us in some cases but we can</font>

560
00:24:34,760 --> 00:24:41,510
also get got one step further by<font color="#CCCCCC"> using</font>

561
00:24:38,000 --> 00:24:43,910
<font color="#E5E5E5">uncatchable memory so we mark pages in</font>

562
00:24:41,510 --> 00:24:46,180
the page table as uncatchable<font color="#E5E5E5"> and this</font>

563
00:24:43,910 --> 00:24:49,970
means that every read or write operation

564
00:24:46,180 --> 00:24:52,610
will go<font color="#CCCCCC"> directly</font><font color="#E5E5E5"> to the DRAM so it will</font>

565
00:24:49,970 --> 00:24:54,320
bypass<font color="#CCCCCC"> the cache</font><font color="#E5E5E5"> entirely so we make</font>

566
00:24:52,610 --> 00:24:56,149
<font color="#CCCCCC">sure it's not in the level</font><font color="#E5E5E5"> 1 level 2 or</font>

567
00:24:54,320 --> 00:25:00,409
level 3 cache it won't be stored in the

568
00:24:56,150 --> 00:25:03,590
cache at all<font color="#E5E5E5"> and if the attacker is</font><font color="#CCCCCC"> able</font>

569
00:25:00,410 --> 00:25:06,320
<font color="#CCCCCC">to do a legitimate load of this value by</font>

570
00:25:03,590 --> 00:25:09,590
either issuing a<font color="#E5E5E5"> sis call that then uses</font>

571
00:25:06,320 --> 00:25:13,970
<font color="#E5E5E5">this value on the same CPU core the data</font>

572
00:25:09,590 --> 00:25:15,740
still can't believe so we think that

573
00:25:13,970 --> 00:25:17,510
Melton might read<font color="#CCCCCC"> the value directly</font>

574
00:25:15,740 --> 00:25:21,140
<font color="#E5E5E5">from one of the fill buffers in this</font>

575
00:25:17,510 --> 00:25:24,500
scenario<font color="#E5E5E5"> because they are shared between</font>

576
00:25:21,140 --> 00:25:28,370
threads running<font color="#E5E5E5"> on the same core so one</font>

577
00:25:24,500 --> 00:25:32,020
high profit<font color="#E5E5E5"> can attack the other one so</font>

578
00:25:28,370 --> 00:25:35,479
you<font color="#CCCCCC"> can dump</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> entire memory</font><font color="#E5E5E5"> but it's</font>

579
00:25:32,020 --> 00:25:38,240
horribly slow right<font color="#E5E5E5"> yeah but why would</font>

580
00:25:35,480 --> 00:25:40,460
<font color="#E5E5E5">you all want to leak the entire memory</font>

581
00:25:38,240 --> 00:25:42,890
you have a lot of<font color="#E5E5E5"> that you just want to</font>

582
00:25:40,460 --> 00:25:46,820
<font color="#CCCCCC">leak secrets</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> don't want and lick</font>

583
00:25:42,890 --> 00:25:49,640
everything<font color="#E5E5E5"> just find something</font><font color="#CCCCCC"> that</font>

584
00:25:46,820 --> 00:25:51,620
<font color="#CCCCCC">you're interested</font><font color="#E5E5E5"> in leaking and do a</font>

585
00:25:49,640 --> 00:25:54,020
<font color="#CCCCCC">targeted attack</font><font color="#E5E5E5"> using meltdown not the</font>

586
00:25:51,620 --> 00:25:56,300
entire memory<font color="#CCCCCC"> term but something like</font>

587
00:25:54,020 --> 00:25:59,120
say for example<font color="#E5E5E5"> you use hard disk</font>

588
00:25:56,300 --> 00:26:02,210
encryption right and use this very crypt

589
00:25:59,120 --> 00:26:05,510
<font color="#E5E5E5">open source tool for disk</font><font color="#CCCCCC"> encryption</font><font color="#E5E5E5"> and</font>

590
00:26:02,210 --> 00:26:06,660
is a software<font color="#E5E5E5"> tool so it at some point</font>

591
00:26:05,510 --> 00:26:08,610
<font color="#CCCCCC">it stores</font>

592
00:26:06,660 --> 00:26:12,150
the key of your<font color="#E5E5E5"> hard disk inside the</font>

593
00:26:08,610 --> 00:26:14,219
memory and if I have that<font color="#CCCCCC"> key</font><font color="#E5E5E5"> then I can</font>

594
00:26:12,150 --> 00:26:16,710
get your laptop<font color="#E5E5E5"> decrypt your hard disk</font>

595
00:26:14,220 --> 00:26:19,050
<font color="#E5E5E5">and get all your interesting research</font>

596
00:26:16,710 --> 00:26:22,890
projects<font color="#E5E5E5"> but it would not be practically</font>

597
00:26:19,050 --> 00:26:27,300
<font color="#E5E5E5">to search for that key right it's just</font><font color="#CCCCCC"> a</font>

598
00:26:22,890 --> 00:26:30,960
<font color="#E5E5E5">small application and we can</font><font color="#CCCCCC"> find out</font>

599
00:26:27,300 --> 00:26:35,909
where<font color="#CCCCCC"> he is</font><font color="#E5E5E5"> so we actually did the demo</font>

600
00:26:30,960 --> 00:26:38,670
on<font color="#E5E5E5"> that so on the right you see a shell</font>

601
00:26:35,910 --> 00:26:41,790
<font color="#E5E5E5">by user called the victim and he starts</font>

602
00:26:38,670 --> 00:26:44,310
<font color="#E5E5E5">the veracrypt application of the recent</font>

603
00:26:41,790 --> 00:26:46,379
version that you<font color="#CCCCCC"> can download today</font><font color="#E5E5E5"> then</font>

604
00:26:44,310 --> 00:26:48,990
he will<font color="#E5E5E5"> create a new encrypted partition</font>

605
00:26:46,380 --> 00:26:50,610
<font color="#E5E5E5">stored on the system so you pass the</font>

606
00:26:48,990 --> 00:26:53,220
password which should be stored<font color="#E5E5E5"> the</font>

607
00:26:50,610 --> 00:26:55,379
encryption algorithm<font color="#E5E5E5"> decides and then</font>

608
00:26:53,220 --> 00:26:57,750
<font color="#E5E5E5">you enter your super secret</font><font color="#CCCCCC"> password so</font>

609
00:26:55,380 --> 00:27:00,810
<font color="#E5E5E5">that no one can read your data that</font>

610
00:26:57,750 --> 00:27:02,940
you're storing in there<font color="#E5E5E5"> so we do that we</font>

611
00:27:00,810 --> 00:27:05,190
generate some<font color="#E5E5E5"> random key by moving the</font>

612
00:27:02,940 --> 00:27:07,530
mouse<font color="#E5E5E5"> and</font><font color="#CCCCCC"> we just speed it up the video</font>

613
00:27:05,190 --> 00:27:11,910
<font color="#E5E5E5">because otherwise the video would take</font>

614
00:27:07,530 --> 00:27:14,160
ages<font color="#CCCCCC"> to present after that the victim is</font>

615
00:27:11,910 --> 00:27:16,860
<font color="#CCCCCC">going to mount a volume so he needs</font><font color="#E5E5E5"> to</font>

616
00:27:14,160 --> 00:27:19,110
enter the<font color="#E5E5E5"> password again and then the</font>

617
00:27:16,860 --> 00:27:22,379
volume will be mounted and<font color="#CCCCCC"> he can use it</font>

618
00:27:19,110 --> 00:27:25,199
on<font color="#E5E5E5"> the</font><font color="#CCCCCC"> filesystem</font><font color="#E5E5E5"> what the victim is</font>

619
00:27:22,380 --> 00:27:27,810
going<font color="#CCCCCC"> to do then he will open</font><font color="#E5E5E5"> the volume</font>

620
00:27:25,200 --> 00:27:34,170
<font color="#CCCCCC">that</font><font color="#E5E5E5"> is mounted in the file explorer and</font>

621
00:27:27,810 --> 00:27:36,060
move his secret files in there now they

622
00:27:34,170 --> 00:27:41,160
are stored on<font color="#CCCCCC"> the encrypted volume</font><font color="#E5E5E5"> and</font>

623
00:27:36,060 --> 00:27:44,340
no one else can read it until<font color="#E5E5E5"> we start</font>

624
00:27:41,160 --> 00:27:45,390
our exploit on the<font color="#CCCCCC"> Left</font><font color="#E5E5E5"> shell so we have</font>

625
00:27:44,340 --> 00:27:49,500
the attacker user

626
00:27:45,390 --> 00:27:52,500
he has no sudo privileges<font color="#E5E5E5"> and he will</font>

627
00:27:49,500 --> 00:27:55,230
run he will<font color="#E5E5E5"> create a report and</font>

628
00:27:52,500 --> 00:27:57,060
<font color="#E5E5E5">directory</font><font color="#CCCCCC"> at first</font><font color="#E5E5E5"> where no files are in</font>

629
00:27:55,230 --> 00:28:00,000
there<font color="#E5E5E5"> and then he's going to run how I</font>

630
00:27:57,060 --> 00:28:00,300
exploit what he exploited<font color="#CCCCCC"> us it checks</font>

631
00:28:00,000 --> 00:28:02,280
for

632
00:28:00,300 --> 00:28:04,260
<font color="#E5E5E5">offsets depending on the kernel version</font>

633
00:28:02,280 --> 00:28:07,770
that is used and then it's going<font color="#E5E5E5"> to</font>

634
00:28:04,260 --> 00:28:10,379
<font color="#E5E5E5">break case law because</font><font color="#CCCCCC"> KLR is active</font><font color="#E5E5E5"> on</font>

635
00:28:07,770 --> 00:28:12,240
the system we<font color="#CCCCCC"> need to first break it so</font>

636
00:28:10,380 --> 00:28:15,120
that we can find the correct address of

637
00:28:12,240 --> 00:28:17,370
our identity mapping then there is a

638
00:28:15,120 --> 00:28:18,939
desk struct that<font color="#CCCCCC"> we see later on</font><font color="#E5E5E5"> where</font>

639
00:28:17,370 --> 00:28:21,969
we can<font color="#E5E5E5"> go through a list</font>

640
00:28:18,940 --> 00:28:25,480
the process which we want to<font color="#E5E5E5"> attack so</font>

641
00:28:21,970 --> 00:28:27,820
<font color="#E5E5E5">we do this then we can read either the</font>

642
00:28:25,480 --> 00:28:29,980
entire memory of this process<font color="#E5E5E5"> or if</font>

643
00:28:27,820 --> 00:28:32,590
there is<font color="#CCCCCC"> no</font><font color="#E5E5E5"> ASL are active we can read</font>

644
00:28:29,980 --> 00:28:35,620
the key directly<font color="#CCCCCC"> then we</font><font color="#E5E5E5"> just</font><font color="#CCCCCC"> use this</font>

645
00:28:32,590 --> 00:28:37,780
key<font color="#CCCCCC"> to decrypt the</font><font color="#E5E5E5"> volume and mount it</font>

646
00:28:35,620 --> 00:28:40,659
using a tool<font color="#E5E5E5"> or expected to the file</font>

647
00:28:37,780 --> 00:28:42,760
<font color="#E5E5E5">system</font><font color="#CCCCCC"> and now we have the files stored</font>

648
00:28:40,660 --> 00:28:45,010
in the<font color="#E5E5E5"> encrypted volume by stealing the</font>

649
00:28:42,760 --> 00:28:47,920
key with<font color="#CCCCCC"> melton and we can look</font><font color="#E5E5E5"> at them</font>

650
00:28:45,010 --> 00:28:50,500
<font color="#E5E5E5">for instance we can now get the credit</font>

651
00:28:47,920 --> 00:28:52,840
card<font color="#CCCCCC"> pin or watch the video that is</font>

652
00:28:50,500 --> 00:28:55,720
stored in<font color="#CCCCCC"> there</font><font color="#E5E5E5"> why did you show my</font>

653
00:28:52,840 --> 00:28:57,760
credit card<font color="#CCCCCC"> PIN in the video and</font>

654
00:28:55,720 --> 00:29:00,730
<font color="#E5E5E5">actually this is</font><font color="#CCCCCC"> the video</font><font color="#E5E5E5"> of our</font>

655
00:28:57,760 --> 00:29:06,010
<font color="#CCCCCC">blackheads best song phony submission</font>

656
00:29:00,730 --> 00:29:08,500
<font color="#E5E5E5">last year using</font><font color="#CCCCCC"> male</font><font color="#E5E5E5"> town we can we</font>

657
00:29:06,010 --> 00:29:11,320
targeted next<font color="#E5E5E5"> as well</font><font color="#CCCCCC"> target something</font>

658
00:29:08,500 --> 00:29:13,600
<font color="#E5E5E5">very specific</font><font color="#CCCCCC"> we have seen we have to T</font>

659
00:29:11,320 --> 00:29:16,179
<font color="#E5E5E5">randomized case</font><font color="#CCCCCC"> lar</font><font color="#E5E5E5"> to access the</font>

660
00:29:13,600 --> 00:29:19,149
internal<font color="#E5E5E5"> internal structures but this is</font>

661
00:29:16,180 --> 00:29:20,950
<font color="#E5E5E5">actually pretty easy because</font><font color="#CCCCCC"> we have</font>

662
00:29:19,150 --> 00:29:22,780
known values inside<font color="#E5E5E5"> the kernel for</font>

663
00:29:20,950 --> 00:29:26,230
example a<font color="#E5E5E5"> version string a</font><font color="#CCCCCC"> Linux</font><font color="#E5E5E5"> spanner</font>

664
00:29:22,780 --> 00:29:28,590
<font color="#E5E5E5">and we know the default address</font><font color="#CCCCCC"> reg</font><font color="#E5E5E5"> is</font>

665
00:29:26,230 --> 00:29:31,480
located for every<font color="#CCCCCC"> kernel version and</font>

666
00:29:28,590 --> 00:29:32,590
then we only have<font color="#CCCCCC"> a really small entropy</font>

667
00:29:31,480 --> 00:29:35,800
for the kernel address space layout

668
00:29:32,590 --> 00:29:37,840
randomization<font color="#CCCCCC"> just a few bits</font><font color="#E5E5E5"> so there</font>

669
00:29:35,800 --> 00:29:40,240
<font color="#E5E5E5">are only 64 possible randomization</font>

670
00:29:37,840 --> 00:29:42,970
offsets<font color="#CCCCCC"> and we just</font><font color="#E5E5E5"> fry them</font><font color="#CCCCCC"> read</font><font color="#E5E5E5"> the</font>

671
00:29:40,240 --> 00:29:44,530
value there and if we<font color="#CCCCCC"> found it then</font><font color="#E5E5E5"> we</font>

672
00:29:42,970 --> 00:29:48,130
can't be<font color="#E5E5E5"> random eyes all the addresses</font>

673
00:29:44,530 --> 00:29:51,730
<font color="#CCCCCC">and work as if we don't</font><font color="#E5E5E5"> have any case</font>

674
00:29:48,130 --> 00:29:54,670
they are active yes and the next thing

675
00:29:51,730 --> 00:29:58,360
like I said<font color="#E5E5E5"> the Linux kernel manages all</font>

676
00:29:54,670 --> 00:29:59,920
processes in a list and the head of the

677
00:29:58,360 --> 00:30:02,649
<font color="#CCCCCC">list is stored</font><font color="#E5E5E5"> in the init task</font>

678
00:29:59,920 --> 00:30:04,720
structure<font color="#E5E5E5"> and the location of this it's</font>

679
00:30:02,650 --> 00:30:06,490
at a fixed offset<font color="#E5E5E5"> depending on the build</font>

680
00:30:04,720 --> 00:30:08,380
kernel version and if you know the

681
00:30:06,490 --> 00:30:10,210
kernel version of the<font color="#E5E5E5"> distribution</font><font color="#CCCCCC"> you</font>

682
00:30:08,380 --> 00:30:11,890
<font color="#E5E5E5">know exactly where</font><font color="#CCCCCC"> it is because</font><font color="#E5E5E5"> it</font>

683
00:30:10,210 --> 00:30:15,310
doesn't<font color="#CCCCCC"> change</font><font color="#E5E5E5"> for every user of this</font>

684
00:30:11,890 --> 00:30:17,980
<font color="#CCCCCC">distribution and each task list</font>

685
00:30:15,310 --> 00:30:21,460
<font color="#E5E5E5">structure itself contains the pointer to</font>

686
00:30:17,980 --> 00:30:24,190
the<font color="#E5E5E5"> next entry of this containing the</font>

687
00:30:21,460 --> 00:30:27,840
process ID the name and also<font color="#CCCCCC"> the root of</font>

688
00:30:24,190 --> 00:30:27,840
the<font color="#CCCCCC"> multi-page table</font>

689
00:30:28,669 --> 00:30:35,600
and<font color="#CCCCCC"> okay so what we</font><font color="#E5E5E5"> want to do is we</font>

690
00:30:32,929 --> 00:30:37,609
want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> resolve virtual addresses to</font>

691
00:30:35,600 --> 00:30:40,369
physical addresses<font color="#CCCCCC"> using the paging</font>

692
00:30:37,609 --> 00:30:42,739
structures so<font color="#E5E5E5"> that we can</font><font color="#CCCCCC"> actually add</font>

693
00:30:40,369 --> 00:30:44,749
<font color="#E5E5E5">this physical address to the identity</font>

694
00:30:42,739 --> 00:30:47,330
mapping offset to<font color="#CCCCCC"> the direct physical</font>

695
00:30:44,749 --> 00:30:48,649
<font color="#CCCCCC">map offset and then read the values</font><font color="#E5E5E5"> from</font>

696
00:30:47,330 --> 00:30:50,720
there and we can do that by just

697
00:30:48,649 --> 00:30:53,119
<font color="#CCCCCC">iterating over the paging structures of</font>

698
00:30:50,720 --> 00:30:55,190
<font color="#E5E5E5">this process and then dump the</font>

699
00:30:53,119 --> 00:30:57,259
corresponding pages<font color="#E5E5E5"> they might be in a</font>

700
00:30:55,190 --> 00:30:59,570
randomized order but they are<font color="#E5E5E5"> four</font>

701
00:30:57,259 --> 00:31:01,789
kilobyte<font color="#E5E5E5"> blocks</font><font color="#CCCCCC"> easy to combine</font><font color="#E5E5E5"> them and</font>

702
00:30:59,570 --> 00:31:05,389
we know how<font color="#E5E5E5"> to combine them from the</font>

703
00:31:01,789 --> 00:31:07,100
paging structures<font color="#E5E5E5"> the location in other</font>

704
00:31:05,389 --> 00:31:08,959
cases the location of the key might be

705
00:31:07,100 --> 00:31:10,969
known if it's at a fixed address for

706
00:31:08,960 --> 00:31:13,100
<font color="#CCCCCC">instance because ASL is disabled</font><font color="#E5E5E5"> and</font>

707
00:31:10,970 --> 00:31:15,710
then we can of course directly<font color="#E5E5E5"> just dump</font>

708
00:31:13,100 --> 00:31:17,840
the key<font color="#E5E5E5"> yes and then you know there is a</font>

709
00:31:15,710 --> 00:31:20,210
key<font color="#E5E5E5"> in this memory dump then you can use</font>

710
00:31:17,840 --> 00:31:22,820
a tool like<font color="#E5E5E5"> a es key finds</font><font color="#CCCCCC"> 2 X 2 key</font>

711
00:31:20,210 --> 00:31:24,559
from<font color="#CCCCCC"> the entire memory</font><font color="#E5E5E5"> dump then you can</font>

712
00:31:22,820 --> 00:31:27,340
use for<font color="#CCCCCC"> instance</font><font color="#E5E5E5"> in our demo</font><font color="#CCCCCC"> pie</font>

713
00:31:24,559 --> 00:31:32,149
<font color="#E5E5E5">TrueCrypt to decrypt the disk image and</font>

714
00:31:27,340 --> 00:31:34,459
extract the data but what's important to

715
00:31:32,149 --> 00:31:37,129
say<font color="#CCCCCC"> here that this doesn't</font><font color="#E5E5E5"> affect</font><font color="#CCCCCC"> only</font>

716
00:31:34,460 --> 00:31:41,119
veracrypt<font color="#E5E5E5"> this</font><font color="#CCCCCC"> affects every application</font>

717
00:31:37,129 --> 00:31:42,769
that<font color="#CCCCCC"> stores</font><font color="#E5E5E5"> the secret in DRAM the</font>

718
00:31:41,119 --> 00:31:45,439
question now<font color="#E5E5E5"> is who is affected</font><font color="#CCCCCC"> right</font>

719
00:31:42,769 --> 00:31:50,269
which processors are actually affected

720
00:31:45,440 --> 00:31:55,220
and it's not<font color="#E5E5E5"> only Intel so Intel CPUs</font>

721
00:31:50,269 --> 00:31:58,970
most of them are affected<font color="#CCCCCC"> back from many</font>

722
00:31:55,220 --> 00:32:01,489
years<font color="#E5E5E5"> ago except for some smaller CPUs</font>

723
00:31:58,970 --> 00:32:03,919
like some atoms<font color="#CCCCCC"> they're</font><font color="#E5E5E5"> not affected for</font>

724
00:32:01,489 --> 00:32:06,139
<font color="#CCCCCC">a empty empty</font><font color="#E5E5E5"> they seem not to be</font>

725
00:32:03,919 --> 00:32:07,820
affected at least<font color="#E5E5E5"> we couldn't</font><font color="#CCCCCC"> mound a</font>

726
00:32:06,139 --> 00:32:11,119
meltdown<font color="#E5E5E5"> attack there and we haven't</font>

727
00:32:07,820 --> 00:32:12,879
<font color="#CCCCCC">heard</font><font color="#E5E5E5"> of anyone being successful in</font>

728
00:32:11,119 --> 00:32:17,209
<font color="#E5E5E5">mountain email tone attack on</font><font color="#CCCCCC"> AMT</font>

729
00:32:12,879 --> 00:32:19,699
computers<font color="#CCCCCC"> forearm</font><font color="#E5E5E5"> there are</font><font color="#CCCCCC"> smartphones</font>

730
00:32:17,210 --> 00:32:23,119
<font color="#E5E5E5">and there's even one affected in the</font>

731
00:32:19,700 --> 00:32:26,119
<font color="#CCCCCC">high-end</font><font color="#E5E5E5"> smartphones the cortex</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> 75</font>

732
00:32:23,119 --> 00:32:28,789
that<font color="#E5E5E5"> was published in January as well by</font>

733
00:32:26,119 --> 00:32:31,999
<font color="#CCCCCC">arm</font><font color="#E5E5E5"> so this one is affected core you</font><font color="#CCCCCC"> can</font>

734
00:32:28,789 --> 00:32:34,429
also mount meltdown<font color="#E5E5E5"> on this core and</font><font color="#CCCCCC"> for</font>

735
00:32:31,999 --> 00:32:37,639
all other<font color="#E5E5E5"> windows like IBM they have</font>

736
00:32:34,429 --> 00:32:39,919
affected architectures<font color="#CCCCCC"> like the</font><font color="#E5E5E5"> power</font>

737
00:32:37,639 --> 00:32:41,809
<font color="#E5E5E5">architecture power</font><font color="#CCCCCC"> eight power nine</font><font color="#E5E5E5"> you</font>

738
00:32:39,919 --> 00:32:42,150
<font color="#E5E5E5">can also mount melt on</font><font color="#CCCCCC"> attack there so</font>

739
00:32:41,809 --> 00:32:45,930
it's

740
00:32:42,150 --> 00:32:48,660
just<font color="#CCCCCC"> into its many CPU when there's many</font>

741
00:32:45,930 --> 00:32:52,260
<font color="#E5E5E5">CPU models that are actually affected</font><font color="#CCCCCC"> by</font>

742
00:32:48,660 --> 00:32:54,990
this<font color="#E5E5E5"> back there Apple CPUs are also</font>

743
00:32:52,260 --> 00:32:57,780
affected<font color="#E5E5E5"> they said that all</font><font color="#CCCCCC"> of their Mac</font>

744
00:32:54,990 --> 00:33:01,290
and iOS devices<font color="#E5E5E5"> are affected by the</font>

745
00:32:57,780 --> 00:33:04,980
meltdown<font color="#CCCCCC"> bug so this is the list that</font>

746
00:33:01,290 --> 00:33:06,600
was online in January where all those

747
00:33:04,980 --> 00:33:09,360
manufacturers said yeah this<font color="#E5E5E5"> our</font>

748
00:33:06,600 --> 00:33:12,300
affected CPUs<font color="#E5E5E5"> but in the end they also</font>

749
00:33:09,360 --> 00:33:15,750
<font color="#CCCCCC">added CPU manufacturers</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> instance</font>

750
00:33:12,300 --> 00:33:18,960
<font color="#E5E5E5">Samsung with the galaxy s7 introduced</font>

751
00:33:15,750 --> 00:33:20,940
the<font color="#E5E5E5"> Mongoose m1 CPU architecture which</font>

752
00:33:18,960 --> 00:33:24,270
has<font color="#E5E5E5"> some interesting properties</font><font color="#CCCCCC"> and it</font>

753
00:33:20,940 --> 00:33:28,530
was its first custom CPU design in the

754
00:33:24,270 --> 00:33:31,830
Exynos<font color="#CCCCCC"> eight ahktar SOC s</font><font color="#E5E5E5"> and it has a</font>

755
00:33:28,530 --> 00:33:34,170
perceptron<font color="#E5E5E5"> branch prediction a fall out</font>

756
00:33:31,830 --> 00:33:37,590
<font color="#CCCCCC">of order instruction execution including</font>

757
00:33:34,170 --> 00:33:40,920
<font color="#CCCCCC">fall out</font><font color="#E5E5E5"> of order loads and stores what</font>

758
00:33:37,590 --> 00:33:43,500
could this possibly mean<font color="#E5E5E5"> we can try to</font>

759
00:33:40,920 --> 00:33:45,210
mount<font color="#E5E5E5"> meltdown there so on the right we</font>

760
00:33:43,500 --> 00:33:46,890
<font color="#CCCCCC">have a root</font><font color="#E5E5E5"> well because we want</font><font color="#CCCCCC"> to</font>

761
00:33:45,210 --> 00:33:48,630
<font color="#CCCCCC">obtain</font><font color="#E5E5E5"> the physical address</font><font color="#CCCCCC"> so we</font>

762
00:33:46,890 --> 00:33:50,520
<font color="#E5E5E5">cheated there a bit but that's</font><font color="#CCCCCC"> okay</font>

763
00:33:48,630 --> 00:33:53,610
<font color="#CCCCCC">because</font><font color="#E5E5E5"> on the Left we have a normal</font>

764
00:33:50,520 --> 00:33:55,260
shell as user<font color="#E5E5E5"> on the right which start</font>

765
00:33:53,610 --> 00:33:57,270
our secret application which has<font color="#CCCCCC"> a</font>

766
00:33:55,260 --> 00:34:00,120
string contained printing out the

767
00:33:57,270 --> 00:34:02,730
address<font color="#E5E5E5"> that</font><font color="#CCCCCC"> we then use in the normal</font>

768
00:34:00,120 --> 00:34:04,709
user application and as<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> see</font><font color="#E5E5E5"> using</font>

769
00:34:02,730 --> 00:34:08,600
the identity mapping<font color="#CCCCCC"> we can instantly</font>

770
00:34:04,710 --> 00:34:12,720
dump<font color="#CCCCCC"> the address stored there but</font>

771
00:34:08,600 --> 00:34:16,350
luckily<font color="#E5E5E5"> Samsung fixed it already so if</font>

772
00:34:12,719 --> 00:34:19,469
you have the<font color="#CCCCCC"> latest update you are good</font>

773
00:34:16,350 --> 00:34:23,639
<font color="#E5E5E5">to go</font><font color="#CCCCCC"> and meltdown is fixed but</font><font color="#E5E5E5"> the</font>

774
00:34:19,469 --> 00:34:26,158
<font color="#CCCCCC">latest update was published last</font><font color="#E5E5E5"> month</font>

775
00:34:23,639 --> 00:34:30,210
<font color="#CCCCCC">so that's</font><font color="#E5E5E5"> what yeah</font><font color="#CCCCCC"> I've took them</font><font color="#E5E5E5"> quite</font>

776
00:34:26,159 --> 00:34:31,740
some time<font color="#CCCCCC"> to actually</font><font color="#E5E5E5"> fix it so in the</font>

777
00:34:30,210 --> 00:34:33,960
end<font color="#E5E5E5"> there are different CPU</font>

778
00:34:31,739 --> 00:34:36,750
manufacturers as well as well that are

779
00:34:33,960 --> 00:34:40,740
also affected and we need to evaluate

780
00:34:36,750 --> 00:34:43,320
the attack on other CPUs<font color="#E5E5E5"> of course as</font>

781
00:34:40,739 --> 00:34:46,649
well yeah yeah and also we need to

782
00:34:43,320 --> 00:34:48,330
<font color="#CCCCCC">notify</font><font color="#E5E5E5"> the users and custom rom</font>

783
00:34:46,649 --> 00:34:51,630
developers<font color="#E5E5E5"> you also have the problem</font>

784
00:34:48,330 --> 00:34:54,179
<font color="#CCCCCC">that</font><font color="#E5E5E5"> if they if if</font><font color="#CCCCCC"> Samsung</font><font color="#E5E5E5"> catches it in</font>

785
00:34:51,630 --> 00:34:54,470
their<font color="#E5E5E5"> operating system maybe custom</font><font color="#CCCCCC"> ROM</font>

786
00:34:54,179 --> 00:34:56,240
<font color="#CCCCCC">did</font>

787
00:34:54,469 --> 00:34:58,848
of us<font color="#E5E5E5"> don't know about this if this is</font>

788
00:34:56,239 --> 00:35:00,589
<font color="#CCCCCC">not publicly</font><font color="#E5E5E5"> documented</font><font color="#CCCCCC"> right</font><font color="#E5E5E5"> so it's</font>

789
00:34:58,849 --> 00:35:03,160
really important<font color="#CCCCCC"> that we publicly</font>

790
00:35:00,590 --> 00:35:06,980
document which processors are affected

791
00:35:03,160 --> 00:35:08,690
<font color="#E5E5E5">okay so we have a problem</font><font color="#CCCCCC"> now</font><font color="#E5E5E5"> because we</font>

792
00:35:06,980 --> 00:35:11,930
can't store a secret anymore in theorem

793
00:35:08,690 --> 00:35:13,730
<font color="#E5E5E5">can we at least</font><font color="#CCCCCC"> saw secrets in registers</font>

794
00:35:11,930 --> 00:35:15,710
short registers must be safe

795
00:35:13,730 --> 00:35:19,760
yeah<font color="#CCCCCC"> it</font><font color="#E5E5E5"> doesn't attack registers right</font>

796
00:35:15,710 --> 00:35:22,340
so with January<font color="#CCCCCC"> arm also found a closely</font>

797
00:35:19,760 --> 00:35:24,530
<font color="#CCCCCC">related</font><font color="#E5E5E5"> meltdown variant where you could</font>

798
00:35:22,340 --> 00:35:27,200
read system<font color="#CCCCCC"> registers</font><font color="#E5E5E5"> that are usually</font>

799
00:35:24,530 --> 00:35:30,290
<font color="#E5E5E5">not accessible in the current exception</font>

800
00:35:27,200 --> 00:35:34,368
level your program is<font color="#CCCCCC"> running affected</font>

801
00:35:30,290 --> 00:35:38,930
is the<font color="#E5E5E5"> cortex a15 the cortex a</font><font color="#CCCCCC"> 57 and a</font>

802
00:35:34,369 --> 00:35:41,540
<font color="#CCCCCC">72 and</font><font color="#E5E5E5"> the impact of this is that you</font>

803
00:35:38,930 --> 00:35:43,279
could break case a lot right away or if

804
00:35:41,540 --> 00:35:45,619
you<font color="#CCCCCC"> use point authentication for</font>

805
00:35:43,280 --> 00:35:47,750
instance the key would also be stored in

806
00:35:45,619 --> 00:35:50,930
a register<font color="#CCCCCC"> and</font><font color="#E5E5E5"> you could leave the key</font>

807
00:35:47,750 --> 00:35:55,730
with<font color="#E5E5E5"> that also</font><font color="#CCCCCC"> we brought a demo with</font>

808
00:35:50,930 --> 00:35:57,470
you<font color="#E5E5E5"> on the Samsung Galaxy s6</font><font color="#CCCCCC"> and when we</font>

809
00:35:55,730 --> 00:35:59,450
run our<font color="#CCCCCC"> attack there we can see that</font>

810
00:35:57,470 --> 00:36:01,430
<font color="#CCCCCC">immediately we can dump all the</font>

811
00:35:59,450 --> 00:36:03,618
registers of different privilege levels

812
00:36:01,430 --> 00:36:10,940
that<font color="#E5E5E5"> our user space application usually</font>

813
00:36:03,619 --> 00:36:13,730
has no<font color="#E5E5E5"> access to okay so who is</font><font color="#CCCCCC"> affected</font>

814
00:36:10,940 --> 00:36:17,480
<font color="#CCCCCC">by</font><font color="#E5E5E5"> this variant</font><font color="#CCCCCC"> intel is affected</font><font color="#E5E5E5"> we</font>

815
00:36:13,730 --> 00:36:20,420
heard first<font color="#E5E5E5"> rumors about that in January</font>

816
00:36:17,480 --> 00:36:24,290
but<font color="#E5E5E5"> inter publicly disclosed this in May</font>

817
00:36:20,420 --> 00:36:26,960
May 21st<font color="#CCCCCC"> they in their disclosure they</font>

818
00:36:24,290 --> 00:36:29,690
said that almost<font color="#E5E5E5"> every CPU is affected</font>

819
00:36:26,960 --> 00:36:35,119
and<font color="#CCCCCC"> they</font><font color="#E5E5E5"> called it rocks rogue system</font>

820
00:36:29,690 --> 00:36:38,570
<font color="#E5E5E5">register read yeah we talked about</font>

821
00:36:35,119 --> 00:36:41,000
<font color="#CCCCCC">Melton now</font><font color="#E5E5E5"> is meltdown a sectional</font>

822
00:36:38,570 --> 00:36:42,619
attack it<font color="#CCCCCC"> runs as a side channel attack</font>

823
00:36:41,000 --> 00:36:45,890
<font color="#E5E5E5">I think</font><font color="#CCCCCC"> it's not a side channel attack</font>

824
00:36:42,619 --> 00:36:47,869
and I'm very<font color="#CCCCCC"> certain about</font><font color="#E5E5E5"> that because</font>

825
00:36:45,890 --> 00:36:50,810
<font color="#E5E5E5">for</font><font color="#CCCCCC"> a side</font><font color="#E5E5E5"> channel attack you would have</font>

826
00:36:47,869 --> 00:36:52,970
to use a side channel<font color="#E5E5E5"> to read some</font>

827
00:36:50,810 --> 00:36:55,820
secret value<font color="#E5E5E5"> and we read the</font><font color="#CCCCCC"> data</font>

828
00:36:52,970 --> 00:36:58,368
<font color="#E5E5E5">directly we directly access it it does</font>

829
00:36:55,820 --> 00:37:00,740
<font color="#E5E5E5">not really work any more directly we</font>

830
00:36:58,369 --> 00:37:02,780
just dereference<font color="#CCCCCC"> a pointer and read the</font>

831
00:37:00,740 --> 00:37:06,140
value into<font color="#CCCCCC"> a register how can</font><font color="#E5E5E5"> it be any</font>

832
00:37:02,780 --> 00:37:06,920
<font color="#CCCCCC">more directly ok we then use a</font><font color="#E5E5E5"> side</font>

833
00:37:06,140 --> 00:37:09,529
<font color="#CCCCCC">channel</font>

834
00:37:06,920 --> 00:37:11,599
for transmission from<font color="#CCCCCC"> one realm to the</font>

835
00:37:09,529 --> 00:37:13,130
<font color="#E5E5E5">other but just</font><font color="#CCCCCC"> because</font><font color="#E5E5E5"> we use a side</font>

836
00:37:11,599 --> 00:37:14,960
channel<font color="#E5E5E5"> somewhere in the process</font><font color="#CCCCCC"> does</font>

837
00:37:13,130 --> 00:37:17,750
<font color="#CCCCCC">not make the entire</font><font color="#E5E5E5"> thing</font><font color="#CCCCCC"> the side</font>

838
00:37:14,960 --> 00:37:19,430
channel<font color="#E5E5E5"> attack if you</font><font color="#CCCCCC"> have some</font><font color="#E5E5E5"> malware</font>

839
00:37:17,750 --> 00:37:21,950
running on an air-gapped system and

840
00:37:19,430 --> 00:37:24,618
transmit the data to<font color="#CCCCCC"> the outside</font><font color="#E5E5E5"> through</font>

841
00:37:21,950 --> 00:37:26,899
some fancy<font color="#E5E5E5"> channel</font><font color="#CCCCCC"> it does not make</font><font color="#E5E5E5"> the</font>

842
00:37:24,619 --> 00:37:28,670
<font color="#E5E5E5">entire attack</font><font color="#CCCCCC"> a side</font><font color="#E5E5E5"> channel attack a</font>

843
00:37:26,900 --> 00:37:32,890
side channel<font color="#E5E5E5"> attack means that it's much</font>

844
00:37:28,670 --> 00:37:35,269
<font color="#CCCCCC">more passive</font><font color="#E5E5E5"> the victim is not actively</font>

845
00:37:32,890 --> 00:37:36,680
manipulated in<font color="#CCCCCC"> some way okay</font><font color="#E5E5E5"> but if it's</font>

846
00:37:35,269 --> 00:37:40,368
not<font color="#CCCCCC"> a side channel attack is it a</font>

847
00:37:36,680 --> 00:37:43,328
speculative execution<font color="#E5E5E5"> at least yeah okay</font>

848
00:37:40,369 --> 00:37:46,250
so<font color="#E5E5E5"> we often heard</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> marathon is</font>

849
00:37:43,329 --> 00:37:47,920
speculating beyond faulting instructions

850
00:37:46,250 --> 00:37:50,450
and<font color="#E5E5E5"> that's not speculative</font><font color="#CCCCCC"> execution</font>

851
00:37:47,920 --> 00:37:53,180
<font color="#CCCCCC">that's just out of</font><font color="#E5E5E5"> order</font><font color="#CCCCCC"> execution we're</font>

852
00:37:50,450 --> 00:37:55,578
already running<font color="#E5E5E5"> instructions out of</font><font color="#CCCCCC"> aura</font>

853
00:37:53,180 --> 00:37:58,460
that follow after<font color="#CCCCCC"> the current</font>

854
00:37:55,579 --> 00:38:01,490
<font color="#CCCCCC">instruction but even if you if you say</font>

855
00:37:58,460 --> 00:38:03,740
<font color="#E5E5E5">okay I still want to want to call that</font>

856
00:38:01,490 --> 00:38:06,049
speculative execution<font color="#E5E5E5"> fine but</font>

857
00:38:03,740 --> 00:38:08,629
speculating beyond faulting instructions

858
00:38:06,049 --> 00:38:11,000
it's not even the<font color="#E5E5E5"> actual problem AMD</font>

859
00:38:08,630 --> 00:38:12,410
does that and they are not affected it's

860
00:38:11,000 --> 00:38:14,750
not the problem<font color="#CCCCCC"> that anyone is</font>

861
00:38:12,410 --> 00:38:16,759
speculating beyond faulting instructions

862
00:38:14,750 --> 00:38:20,059
here<font color="#CCCCCC"> the problem is</font><font color="#E5E5E5"> that we</font><font color="#CCCCCC"> are fetching</font>

863
00:38:16,759 --> 00:38:23,779
<font color="#E5E5E5">and using real values for instructions</font>

864
00:38:20,059 --> 00:38:25,519
after<font color="#CCCCCC"> we are after we are</font><font color="#E5E5E5"> having a</font>

865
00:38:23,779 --> 00:38:30,400
faulting instructions so the problem is

866
00:38:25,519 --> 00:38:30,399
fetching<font color="#E5E5E5"> and using the real values here</font>

867
00:38:31,720 --> 00:38:35,720
<font color="#E5E5E5">okay we should fix that</font>

868
00:38:34,160 --> 00:38:38,808
I guess<font color="#E5E5E5"> because there's a really really</font>

869
00:38:35,720 --> 00:38:42,259
<font color="#CCCCCC">bad</font><font color="#E5E5E5"> problem here so we should find out</font>

870
00:38:38,809 --> 00:38:44,089
how to<font color="#E5E5E5"> fix that the problem here is in</font>

871
00:38:42,259 --> 00:38:47,150
<font color="#E5E5E5">hardware so the problem is rooted in</font>

872
00:38:44,089 --> 00:38:49,160
hardware<font color="#E5E5E5"> so ultimately we should fix</font>

873
00:38:47,150 --> 00:38:51,170
that<font color="#CCCCCC"> in</font><font color="#E5E5E5"> hardware</font><font color="#CCCCCC"> it's a race condition</font>

874
00:38:49,160 --> 00:38:54,259
between the<font color="#E5E5E5"> memory fetch and the</font>

875
00:38:51,170 --> 00:38:59,269
<font color="#E5E5E5">permission check and we have to fix</font><font color="#CCCCCC"> that</font>

876
00:38:54,259 --> 00:39:01,519
in hardware<font color="#E5E5E5"> and we can also do a hard</font>

877
00:38:59,269 --> 00:39:04,578
split of<font color="#CCCCCC"> the user space and the kernel</font>

878
00:39:01,519 --> 00:39:06,799
space so<font color="#CCCCCC"> that was already designed</font><font color="#E5E5E5"> for</font>

879
00:39:04,579 --> 00:39:10,640
<font color="#E5E5E5">harm</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> I guess no operating system</font>

880
00:39:06,799 --> 00:39:12,288
<font color="#CCCCCC">used it before</font><font color="#E5E5E5"> so that the kernel space</font>

881
00:39:10,640 --> 00:39:13,430
<font color="#E5E5E5">is not even there if you run in user</font>

882
00:39:12,289 --> 00:39:15,950
space

883
00:39:13,430 --> 00:39:18,080
fixing the hardware it's a long-term

884
00:39:15,950 --> 00:39:19,100
<font color="#E5E5E5">solution we cannot just replace all the</font>

885
00:39:18,080 --> 00:39:21,680
CPUs right away

886
00:39:19,100 --> 00:39:23,509
so<font color="#E5E5E5"> we needed a short-term solution</font><font color="#CCCCCC"> yeah</font>

887
00:39:21,680 --> 00:39:26,870
we need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> find something</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> software</font>

888
00:39:23,510 --> 00:39:29,390
and the problem<font color="#E5E5E5"> are the kernel addresses</font>

889
00:39:26,870 --> 00:39:33,380
<font color="#E5E5E5">Carl addresses are there in user space</font>

890
00:39:29,390 --> 00:39:35,710
<font color="#E5E5E5">and we can't just take those kernel</font>

891
00:39:33,380 --> 00:39:38,360
addresses we don't need<font color="#CCCCCC"> them usually</font><font color="#E5E5E5"> and</font>

892
00:39:35,710 --> 00:39:40,880
remove them if<font color="#CCCCCC"> you run in user</font><font color="#E5E5E5"> space</font><font color="#CCCCCC"> we</font>

893
00:39:38,360 --> 00:39:42,350
don't<font color="#E5E5E5"> need kernel addresses we don't we</font>

894
00:39:40,880 --> 00:39:44,060
cannot<font color="#E5E5E5"> access the column we don't need</font>

895
00:39:42,350 --> 00:39:46,069
to<font color="#CCCCCC"> call it there</font><font color="#E5E5E5"> the problem here is</font>

896
00:39:44,060 --> 00:39:48,950
that the<font color="#E5E5E5"> user space accessible check is</font>

897
00:39:46,070 --> 00:39:51,380
<font color="#E5E5E5">not reliable in hardware so our idea was</font>

898
00:39:48,950 --> 00:39:53,870
we just<font color="#E5E5E5"> unmapped the entire kernel in</font>

899
00:39:51,380 --> 00:39:55,520
user space<font color="#E5E5E5"> and then the kernel addresses</font>

900
00:39:53,870 --> 00:39:57,350
are no longer present<font color="#CCCCCC"> and if they are</font>

901
00:39:55,520 --> 00:39:59,150
<font color="#E5E5E5">not present then you can't translate</font>

902
00:39:57,350 --> 00:40:01,970
them to<font color="#E5E5E5"> any physical address so you</font>

903
00:39:59,150 --> 00:40:04,970
can't run the attack if you think back

904
00:40:01,970 --> 00:40:06,890
<font color="#CCCCCC">of</font><font color="#E5E5E5"> our operating system illustration we</font>

905
00:40:04,970 --> 00:40:08,839
would switch from<font color="#CCCCCC"> this view to a</font>

906
00:40:06,890 --> 00:40:11,330
separate kind<font color="#E5E5E5"> of view</font><font color="#CCCCCC"> and a user view</font>

907
00:40:08,840 --> 00:40:13,820
and now the user<font color="#E5E5E5"> can run the attack so</font>

908
00:40:11,330 --> 00:40:16,130
the user can<font color="#E5E5E5"> run through the wall but</font>

909
00:40:13,820 --> 00:40:18,470
there's nothing behind it so<font color="#CCCCCC"> the user</font>

910
00:40:16,130 --> 00:40:21,500
can't gain anything from it<font color="#E5E5E5"> yeah so</font>

911
00:40:18,470 --> 00:40:25,549
<font color="#E5E5E5">actually we</font><font color="#CCCCCC"> publish Kaiser</font><font color="#E5E5E5"> in May 2007</font>

912
00:40:21,500 --> 00:40:27,080
team but not to mitigate meltdown<font color="#E5E5E5"> but to</font>

913
00:40:25,550 --> 00:40:29,270
mitigate other side channel attacks

914
00:40:27,080 --> 00:40:33,290
because<font color="#CCCCCC"> Melton was not known until</font><font color="#E5E5E5"> then</font>

915
00:40:29,270 --> 00:40:38,390
and inadvertently and luckily<font color="#E5E5E5"> to us it</font>

916
00:40:33,290 --> 00:40:40,460
also defeats meltdown we introduced<font color="#E5E5E5"> a</font>

917
00:40:38,390 --> 00:40:46,609
POC implementation the Linux kernel

918
00:40:40,460 --> 00:40:49,640
which we also uploaded in May and yeah

919
00:40:46,610 --> 00:40:52,580
it<font color="#E5E5E5"> was not that easy</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> just</font><font color="#CCCCCC"> our</font>

920
00:40:49,640 --> 00:40:55,310
mounting the complete curl<font color="#E5E5E5"> every space</font>

921
00:40:52,580 --> 00:40:57,650
is not possible<font color="#E5E5E5"> the architecture still</font>

922
00:40:55,310 --> 00:40:59,900
requires some parts of the<font color="#E5E5E5"> kernel to be</font>

923
00:40:57,650 --> 00:41:01,610
present<font color="#E5E5E5"> like interrupt descriptor tables</font>

924
00:40:59,900 --> 00:41:04,190
<font color="#E5E5E5">if we have an interrupt in user space</font>

925
00:41:01,610 --> 00:41:06,380
<font color="#E5E5E5">for example</font><font color="#CCCCCC"> because we move the mouse or</font>

926
00:41:04,190 --> 00:41:08,080
enter stuff on the keyboard<font color="#E5E5E5"> we still</font>

927
00:41:06,380 --> 00:41:11,420
need something mapped<font color="#E5E5E5"> in the kernel so</font>

928
00:41:08,080 --> 00:41:13,160
context different things<font color="#E5E5E5"> stuff for</font>

929
00:41:11,420 --> 00:41:16,070
context switches we still needs a few

930
00:41:13,160 --> 00:41:18,290
<font color="#CCCCCC">parts of the color by mapped in the user</font>

931
00:41:16,070 --> 00:41:19,970
<font color="#E5E5E5">space also in addition</font><font color="#CCCCCC"> when we want to</font>

932
00:41:18,290 --> 00:41:21,680
switch<font color="#E5E5E5"> to the</font><font color="#CCCCCC"> other address space we</font>

933
00:41:19,970 --> 00:41:23,870
need to know the physical location of

934
00:41:21,680 --> 00:41:24,859
<font color="#CCCCCC">that</font><font color="#E5E5E5"> so we need to update the ca3</font>

935
00:41:23,870 --> 00:41:26,868
register we

936
00:41:24,859 --> 00:41:29,630
this address in<font color="#E5E5E5"> this address has</font><font color="#CCCCCC"> also to</font>

937
00:41:26,869 --> 00:41:33,140
<font color="#CCCCCC">be stored somewhere</font><font color="#E5E5E5"> and how</font><font color="#CCCCCC"> can we do</font>

938
00:41:29,630 --> 00:41:36,049
this efficiently<font color="#CCCCCC"> so instead of one page</font>

939
00:41:33,140 --> 00:41:38,538
global directory we now use<font color="#CCCCCC"> two</font><font color="#E5E5E5"> there</font>

940
00:41:36,049 --> 00:41:42,259
are<font color="#CCCCCC"> eight K</font><font color="#E5E5E5"> in size and also</font><font color="#CCCCCC"> 8 K aligned</font>

941
00:41:38,539 --> 00:41:44,900
and then we can do a nice trick we can

942
00:41:42,259 --> 00:41:48,170
<font color="#CCCCCC">just flip the twelfth bit of the pointer</font>

943
00:41:44,900 --> 00:41:50,839
to switch between those half and

944
00:41:48,170 --> 00:41:53,299
therefore off with those mappings<font color="#CCCCCC"> so as</font>

945
00:41:50,839 --> 00:41:57,230
<font color="#E5E5E5">you can</font><font color="#CCCCCC"> see on the illustration at the</font>

946
00:41:53,299 --> 00:42:01,119
bottom we just<font color="#E5E5E5"> flip one bit then we use</font>

947
00:41:57,230 --> 00:42:03,799
<font color="#E5E5E5">the another offset which is our other</font>

948
00:42:01,119 --> 00:42:06,410
address space and then we can continue

949
00:42:03,799 --> 00:42:07,910
<font color="#CCCCCC">and therefore</font><font color="#E5E5E5"> we do not need to store</font>

950
00:42:06,410 --> 00:42:10,730
the<font color="#E5E5E5"> address somewhere else which would</font>

951
00:42:07,910 --> 00:42:12,799
need<font color="#E5E5E5"> to translate and then store in the</font>

952
00:42:10,730 --> 00:42:15,559
<font color="#CCCCCC">CFU register we can just use the value</font>

953
00:42:12,799 --> 00:42:17,180
already<font color="#E5E5E5"> stored there flip a bit and then</font>

954
00:42:15,559 --> 00:42:19,970
change the address<font color="#E5E5E5"> space and this is</font>

955
00:42:17,180 --> 00:42:23,569
pretty nice so<font color="#CCCCCC"> inter and</font><font color="#E5E5E5"> other is</font>

956
00:42:19,970 --> 00:42:25,759
improved over our<font color="#CCCCCC"> Kaiser patch</font><font color="#E5E5E5"> starting</font>

957
00:42:23,569 --> 00:42:29,538
from May we already got first feedback

958
00:42:25,759 --> 00:42:31,670
<font color="#E5E5E5">in May and later on we got also emails</font>

959
00:42:29,539 --> 00:42:34,190
from Intel asking us specific things

960
00:42:31,670 --> 00:42:37,309
about<font color="#E5E5E5"> the Kaiser patch and then finally</font>

961
00:42:34,190 --> 00:42:39,829
notifying us that they developed a

962
00:42:37,309 --> 00:42:42,589
larger patch set which actually makes

963
00:42:39,829 --> 00:42:44,269
this practical for the<font color="#CCCCCC"> Linux kernel it</font>

964
00:42:42,589 --> 00:42:47,150
was later on<font color="#E5E5E5"> merged into</font><font color="#CCCCCC"> the Linux</font>

965
00:42:44,269 --> 00:42:49,308
<font color="#CCCCCC">kernel</font><font color="#E5E5E5"> as kpti because they didn't like</font>

966
00:42:47,150 --> 00:42:51,739
<font color="#E5E5E5">the name</font><font color="#CCCCCC"> either</font><font color="#E5E5E5"> for some reason</font><font color="#CCCCCC"> funds</font>

967
00:42:49,309 --> 00:42:54,259
like Kaiser<font color="#E5E5E5"> in German is</font><font color="#CCCCCC"> the name of the</font>

968
00:42:51,739 --> 00:42:57,349
largest<font color="#CCCCCC"> penguin the emperor penguin</font><font color="#E5E5E5"> but</font>

969
00:42:54,259 --> 00:43:00,579
<font color="#CCCCCC">i think they were</font><font color="#E5E5E5"> not aware</font><font color="#CCCCCC"> of that so</font>

970
00:42:57,349 --> 00:43:03,829
there were also patches for<font color="#E5E5E5"> armed 64</font><font color="#CCCCCC"> and</font>

971
00:43:00,579 --> 00:43:05,900
it's not only<font color="#E5E5E5"> in</font><font color="#CCCCCC"> linux</font><font color="#E5E5E5"> it's of course</font>

972
00:43:03,829 --> 00:43:08,359
<font color="#CCCCCC">you</font><font color="#E5E5E5"> know</font><font color="#CCCCCC"> atom major operating systems as</font>

973
00:43:05,900 --> 00:43:12,380
well for example<font color="#CCCCCC"> apple released updates</font>

974
00:43:08,359 --> 00:43:13,880
already<font color="#E5E5E5"> in december i think and they had</font>

975
00:43:12,380 --> 00:43:15,769
an<font color="#CCCCCC"> option</font><font color="#E5E5E5"> that was that things similar</font>

976
00:43:13,880 --> 00:43:18,109
<font color="#CCCCCC">before i'm</font><font color="#E5E5E5"> 32 bits yeah</font>

977
00:43:15,769 --> 00:43:20,029
<font color="#CCCCCC">where i</font><font color="#E5E5E5"> was doing</font><font color="#CCCCCC"> rather the opposite</font>

978
00:43:18,109 --> 00:43:21,859
yeah they they<font color="#E5E5E5"> didn't unmapped the</font>

979
00:43:20,029 --> 00:43:22,549
kernel in user space but the user space

980
00:43:21,859 --> 00:43:24,970
in kernel

981
00:43:22,549 --> 00:43:27,140
so that mitigated different attacks and

982
00:43:24,970 --> 00:43:30,439
after this<font color="#CCCCCC"> update they also had the</font>

983
00:43:27,140 --> 00:43:32,808
other<font color="#E5E5E5"> way around</font><font color="#CCCCCC"> so that</font><font color="#E5E5E5"> protections in</font>

984
00:43:30,440 --> 00:43:34,700
both directions<font color="#E5E5E5"> and of course windows</font>

985
00:43:32,809 --> 00:43:35,569
also<font color="#E5E5E5"> has a mitigation which they call</font>

986
00:43:34,700 --> 00:43:37,698
<font color="#E5E5E5">converge</font>

987
00:43:35,569 --> 00:43:39,799
<font color="#E5E5E5">address shadow and it's their</font>

988
00:43:37,699 --> 00:43:44,479
implementation<font color="#E5E5E5"> to mitigate</font><font color="#CCCCCC"> meltdown on</font>

989
00:43:39,799 --> 00:43:46,369
<font color="#CCCCCC">Windows so introducing such a</font>

990
00:43:44,479 --> 00:43:49,009
fundamental change into an<font color="#E5E5E5"> operating</font>

991
00:43:46,369 --> 00:43:51,410
system is extremely<font color="#CCCCCC"> challenging</font><font color="#E5E5E5"> our</font>

992
00:43:49,009 --> 00:43:55,519
proof of concept had many bugs<font color="#CCCCCC"> it</font>

993
00:43:51,410 --> 00:43:57,229
crashed very frequently<font color="#CCCCCC"> and why</font><font color="#E5E5E5"> yeah we</font>

994
00:43:55,519 --> 00:43:59,769
were very<font color="#CCCCCC"> lucky that that we got the</font>

995
00:43:57,229 --> 00:44:02,689
<font color="#CCCCCC">feedback from the Linux community</font>

996
00:43:59,769 --> 00:44:04,430
<font color="#CCCCCC">because we were really unexperienced in</font>

997
00:44:02,690 --> 00:44:06,529
writing larger kernel patch and we had a

998
00:44:04,430 --> 00:44:08,629
lot of more time because<font color="#CCCCCC"> at this point</font>

999
00:44:06,529 --> 00:44:10,849
<font color="#CCCCCC">meltdown wasn't known so we didn't</font><font color="#E5E5E5"> have</font>

1000
00:44:08,630 --> 00:44:13,069
<font color="#E5E5E5">any stress</font><font color="#CCCCCC"> in developing this patch and</font>

1001
00:44:10,849 --> 00:44:15,890
we were also<font color="#E5E5E5"> quite lucky in hindsight</font>

1002
00:44:13,069 --> 00:44:18,019
<font color="#CCCCCC">that we had this patch ready already a</font>

1003
00:44:15,890 --> 00:44:20,538
<font color="#E5E5E5">few months before we needed it so even</font>

1004
00:44:18,019 --> 00:44:23,569
major<font color="#E5E5E5"> operating system vendors with</font>

1005
00:44:20,539 --> 00:44:25,430
really good programmers made some

1006
00:44:23,569 --> 00:44:28,339
mistakes in implementing this<font color="#E5E5E5"> patch at</font>

1007
00:44:25,430 --> 00:44:30,558
first so in the Microsoft version<font color="#E5E5E5"> it has</font>

1008
00:44:28,339 --> 00:44:32,509
<font color="#CCCCCC">a small mistake</font><font color="#E5E5E5"> in there where they made</font>

1009
00:44:30,559 --> 00:44:36,440
the page table entries<font color="#E5E5E5"> user space</font>

1010
00:44:32,509 --> 00:44:38,539
accessible so from side<font color="#E5E5E5"> channel attack</font>

1011
00:44:36,440 --> 00:44:40,880
or<font color="#E5E5E5"> not a</font><font color="#CCCCCC"> side</font><font color="#E5E5E5"> genetic butters using a</font>

1012
00:44:38,539 --> 00:44:43,699
side channel<font color="#E5E5E5"> to leak values from the</font>

1013
00:44:40,880 --> 00:44:45,979
<font color="#CCCCCC">coddle they generated a real exploitable</font>

1014
00:44:43,699 --> 00:44:49,039
<font color="#CCCCCC">Park where</font><font color="#E5E5E5"> you can read and write values</font>

1015
00:44:45,979 --> 00:44:52,368
<font color="#E5E5E5">anywhere</font><font color="#CCCCCC"> on the whole</font><font color="#E5E5E5"> system so this was</font>

1016
00:44:49,039 --> 00:44:54,769
the<font color="#E5E5E5"> total meltdown</font><font color="#CCCCCC"> back in the meltdown</font>

1017
00:44:52,369 --> 00:44:55,369
patch for Windows for<font color="#CCCCCC"> example so what</font>

1018
00:44:54,769 --> 00:44:59,598
now

1019
00:44:55,369 --> 00:45:01,059
how can we go on<font color="#E5E5E5"> from here</font><font color="#CCCCCC"> we expect</font>

1020
00:44:59,599 --> 00:45:03,469
<font color="#E5E5E5">that there will be more attacks</font>

1021
00:45:01,059 --> 00:45:05,150
<font color="#E5E5E5">exploiting performance optimizations we</font>

1022
00:45:03,469 --> 00:45:07,430
are<font color="#E5E5E5"> already seeing new variants for</font>

1023
00:45:05,150 --> 00:45:10,670
instance of Spectre and meltdown popping

1024
00:45:07,430 --> 00:45:12,348
up frequently<font color="#E5E5E5"> and I think that this will</font>

1025
00:45:10,670 --> 00:45:15,109
<font color="#E5E5E5">be even more frequently in the</font><font color="#CCCCCC"> near</font>

1026
00:45:12,349 --> 00:45:17,749
future<font color="#E5E5E5"> this gives us a unique chance now</font>

1027
00:45:15,109 --> 00:45:20,598
to<font color="#E5E5E5"> rethink our process of designs</font>

1028
00:45:17,749 --> 00:45:22,759
<font color="#CCCCCC">right now we're always optimized for</font>

1029
00:45:20,599 --> 00:45:24,680
performance a lot<font color="#E5E5E5"> of performance but</font>

1030
00:45:22,759 --> 00:45:27,619
maybe we<font color="#CCCCCC"> have to also</font><font color="#E5E5E5"> take into account</font>

1031
00:45:24,680 --> 00:45:30,499
<font color="#E5E5E5">the security</font><font color="#CCCCCC"> and find trade-offs between</font>

1032
00:45:27,619 --> 00:45:32,630
security<font color="#E5E5E5"> and</font><font color="#CCCCCC"> performance</font><font color="#E5E5E5"> for new designs</font>

1033
00:45:30,499 --> 00:45:35,180
designs that<font color="#CCCCCC"> are</font><font color="#E5E5E5"> better in terms of</font>

1034
00:45:32,630 --> 00:45:36,769
security<font color="#E5E5E5"> and grow</font><font color="#CCCCCC"> up like other fields</font>

1035
00:45:35,180 --> 00:45:39,649
did like<font color="#CCCCCC"> it was the same in</font><font color="#E5E5E5"> the car</font>

1036
00:45:36,769 --> 00:45:41,839
<font color="#E5E5E5">industry we didn't get fast and faster</font>

1037
00:45:39,650 --> 00:45:46,099
cars<font color="#E5E5E5"> all</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> time but at some point they</font>

1038
00:45:41,839 --> 00:45:48,739
also<font color="#E5E5E5"> made the cars safer than before so</font>

1039
00:45:46,099 --> 00:45:50,720
last but not<font color="#E5E5E5"> least we published our</font>

1040
00:45:48,739 --> 00:45:52,940
proof of concept<font color="#CCCCCC"> implementation of the</font>

1041
00:45:50,720 --> 00:45:55,399
Melton<font color="#CCCCCC"> otech</font><font color="#E5E5E5"> on github you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> download</font>

1042
00:45:52,940 --> 00:45:57,979
it there<font color="#E5E5E5"> compile it and try it on your</font>

1043
00:45:55,400 --> 00:46:00,589
machine<font color="#E5E5E5"> yourself hopefully your machine</font>

1044
00:45:57,979 --> 00:46:02,899
is<font color="#CCCCCC"> already best</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> you need to disable</font>

1045
00:46:00,589 --> 00:46:05,269
<font color="#E5E5E5">the</font><font color="#CCCCCC"> mitigations to test it</font><font color="#E5E5E5"> we will also</font>

1046
00:46:02,900 --> 00:46:08,569
<font color="#CCCCCC">add new code there that we just showed</font>

1047
00:46:05,269 --> 00:46:11,479
here<font color="#E5E5E5"> in the presentation</font><font color="#CCCCCC"> so to conclude</font>

1048
00:46:08,569 --> 00:46:13,970
our talk in the end<font color="#CCCCCC"> we</font><font color="#E5E5E5"> underestimated</font><font color="#CCCCCC"> my</font>

1049
00:46:11,479 --> 00:46:17,058
<font color="#CCCCCC">craft today microarchitecture detects</font>

1050
00:46:13,970 --> 00:46:19,038
<font color="#E5E5E5">for a long long time and with</font><font color="#CCCCCC"> Melton we</font>

1051
00:46:17,059 --> 00:46:21,619
exploit performance optimizations that

1052
00:46:19,039 --> 00:46:24,049
<font color="#E5E5E5">allow us to</font><font color="#CCCCCC"> leak arbitrary memory</font><font color="#E5E5E5"> which</font>

1053
00:46:21,619 --> 00:46:25,789
<font color="#CCCCCC">is a huge problem the countermeasures</font>

1054
00:46:24,049 --> 00:46:28,009
that<font color="#CCCCCC"> we've seen come with a</font><font color="#E5E5E5"> huge</font>

1055
00:46:25,789 --> 00:46:30,410
<font color="#E5E5E5">performance impact so we need better</font>

1056
00:46:28,009 --> 00:46:32,329
solutions<font color="#E5E5E5"> and therefore we need to find</font>

1057
00:46:30,410 --> 00:46:34,989
<font color="#CCCCCC">the trade-off</font><font color="#E5E5E5"> between security and</font>

1058
00:46:32,329 --> 00:46:38,180
<font color="#CCCCCC">performance because we cannot</font><font color="#E5E5E5"> have both</font>

1059
00:46:34,989 --> 00:46:40,190
<font color="#E5E5E5">apparently at the same time thank you</font>

1060
00:46:38,180 --> 00:46:42,140
<font color="#CCCCCC">for your attention if you have any</font>

1061
00:46:40,190 --> 00:46:44,400
questions feel<font color="#E5E5E5"> free to ask or come</font><font color="#CCCCCC"> to</font>

1062
00:46:42,140 --> 00:46:47,529
the Q&A afterwards<font color="#CCCCCC"> thank</font><font color="#E5E5E5"> you</font>

1063
00:46:44,400 --> 00:46:47,530
[Applause]

