1
00:00:00,030 --> 00:00:06,270
thank you yeah we<font color="#E5E5E5"> are going to talk</font>

2
00:00:02,460 --> 00:00:06,899
<font color="#CCCCCC">about</font><font color="#E5E5E5"> Roja marry tax and first about</font>

3
00:00:06,270 --> 00:00:08,639
ourselves

4
00:00:06,899 --> 00:00:10,200
my name is<font color="#CCCCCC"> Tanya goose I'm currently a</font>

5
00:00:08,639 --> 00:00:11,730
postdoc at<font color="#CCCCCC"> God's University of</font>

6
00:00:10,200 --> 00:00:13,349
Technology and you can reach me via

7
00:00:11,730 --> 00:00:15,630
Twitter<font color="#CCCCCC"> or email</font>

8
00:00:13,349 --> 00:00:17,460
my name is<font color="#CCCCCC"> Maude flip I'm a PhD student</font>

9
00:00:15,630 --> 00:00:19,590
at<font color="#CCCCCC"> the</font><font color="#E5E5E5"> same Institute in the same office</font>

10
00:00:17,460 --> 00:00:21,449
<font color="#CCCCCC">you can also reach me on</font><font color="#E5E5E5"> Twitter write</font>

11
00:00:19,590 --> 00:00:24,720
me an email<font color="#E5E5E5"> or come to talk</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> us later</font>

12
00:00:21,449 --> 00:00:26,279
<font color="#E5E5E5">on we also will</font><font color="#CCCCCC"> be at DEFCON and my name</font>

13
00:00:24,720 --> 00:00:29,340
is<font color="#E5E5E5"> Michael Schwartz I'm also a PhD</font>

14
00:00:26,279 --> 00:00:30,929
student<font color="#E5E5E5"> same office same University also</font>

15
00:00:29,340 --> 00:00:33,300
on Twitter<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> also drop me an</font>

16
00:00:30,929 --> 00:00:33,899
email<font color="#E5E5E5"> talk to us we are here the rest of</font>

17
00:00:33,300 --> 00:00:36,419
the conference

18
00:00:33,899 --> 00:00:39,149
of course it's<font color="#E5E5E5"> not just</font><font color="#CCCCCC"> only</font><font color="#E5E5E5"> as free</font>

19
00:00:36,420 --> 00:00:40,649
<font color="#E5E5E5">there's a whole research team that did a</font>

20
00:00:39,149 --> 00:00:43,290
<font color="#CCCCCC">lot of the work here what we are</font><font color="#E5E5E5"> going</font>

21
00:00:40,649 --> 00:00:45,539
<font color="#CCCCCC">to present consisting of</font><font color="#E5E5E5"> Clementi movies</font>

22
00:00:43,290 --> 00:00:48,390
daniel ganc<font color="#E5E5E5"> in</font><font color="#CCCCCC"> unis your finger Lucas up</font>

23
00:00:45,539 --> 00:00:50,460
Lucas dumpster music at<font color="#CCCCCC"> Edessa Agassiz</font>

24
00:00:48,390 --> 00:00:52,070
<font color="#CCCCCC">olio kapkan alley Wolfgang</font><font color="#E5E5E5"> Shahi and</font>

25
00:00:50,460 --> 00:00:55,440
<font color="#CCCCCC">Yvonne</font><font color="#E5E5E5"> yellow</font>

26
00:00:52,070 --> 00:00:57,059
okay let's start directly into the topic

27
00:00:55,440 --> 00:01:01,230
<font color="#E5E5E5">we are talking about</font><font color="#CCCCCC"> Roe hammer</font><font color="#E5E5E5"> today</font>

28
00:00:57,059 --> 00:01:04,378
it's a<font color="#CCCCCC"> fault in DRAM modules</font><font color="#E5E5E5"> so we have</font>

29
00:01:01,230 --> 00:01:05,850
to talk<font color="#E5E5E5"> about</font><font color="#CCCCCC"> DRM first</font><font color="#E5E5E5"> and you might</font>

30
00:01:04,379 --> 00:01:07,340
all know<font color="#CCCCCC"> that you</font><font color="#E5E5E5"> have it</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> your</font>

31
00:01:05,850 --> 00:01:11,100
service your computer's<font color="#E5E5E5"> your</font><font color="#CCCCCC"> laptop's</font>

32
00:01:07,340 --> 00:01:13,200
this Tim your memory<font color="#E5E5E5"> and most of you</font>

33
00:01:11,100 --> 00:01:15,539
<font color="#E5E5E5">will have</font><font color="#CCCCCC"> more</font><font color="#E5E5E5"> of more than one of that</font>

34
00:01:13,200 --> 00:01:17,490
like<font color="#E5E5E5"> two dims in your computer they are</font>

35
00:01:15,540 --> 00:01:21,360
connected to<font color="#CCCCCC"> your CPU by different</font>

36
00:01:17,490 --> 00:01:23,490
channels and they also usually have two

37
00:01:21,360 --> 00:01:26,789
sides<font color="#CCCCCC"> front</font><font color="#E5E5E5"> side and the back side and</font>

38
00:01:23,490 --> 00:01:28,860
we call them ranks and if we<font color="#CCCCCC"> zoom</font><font color="#E5E5E5"> into</font>

39
00:01:26,790 --> 00:01:31,890
<font color="#E5E5E5">that bit more with a lot of chips on</font>

40
00:01:28,860 --> 00:01:34,020
<font color="#E5E5E5">those things on both sides and those</font>

41
00:01:31,890 --> 00:01:36,990
chips then consists of multiple banks

42
00:01:34,020 --> 00:01:41,429
and in these banks<font color="#CCCCCC"> we can find some rows</font>

43
00:01:36,990 --> 00:01:43,169
<font color="#E5E5E5">a lot of rows and also a row buffer we</font>

44
00:01:41,430 --> 00:01:44,939
will talk about the row buffer and more

45
00:01:43,170 --> 00:01:48,540
detail later<font color="#E5E5E5"> because it's a really</font>

46
00:01:44,939 --> 00:01:51,809
important part<font color="#E5E5E5"> for row hammering right</font>

47
00:01:48,540 --> 00:01:54,479
now we're focusing<font color="#E5E5E5"> on the</font><font color="#CCCCCC"> rows and on</font>

48
00:01:51,810 --> 00:01:57,270
the rows<font color="#E5E5E5"> such a row consists of multiple</font>

49
00:01:54,479 --> 00:01:59,729
cells the cells are the actual bits that

50
00:01:57,270 --> 00:02:02,610
are<font color="#E5E5E5"> stored in memory every cell</font>

51
00:01:59,729 --> 00:02:05,000
represents one bit and it consists of

52
00:02:02,610 --> 00:02:07,469
one<font color="#E5E5E5"> capacitor and one transistor</font><font color="#CCCCCC"> and</font>

53
00:02:05,000 --> 00:02:10,709
this is where the<font color="#E5E5E5"> data is actually</font>

54
00:02:07,469 --> 00:02:12,630
stored by<font color="#CCCCCC"> ADA</font><font color="#E5E5E5"> charging the capacitor or</font>

55
00:02:10,709 --> 00:02:14,400
having it<font color="#E5E5E5"> not charged</font>

56
00:02:12,630 --> 00:02:17,010
<font color="#E5E5E5">okay this sounds all very complicated</font>

57
00:02:14,400 --> 00:02:18,990
<font color="#E5E5E5">maybe we start with a</font><font color="#CCCCCC"> simpler</font><font color="#E5E5E5"> case where</font>

58
00:02:17,010 --> 00:02:20,940
the<font color="#CCCCCC"> CPU wants to</font><font color="#E5E5E5"> access one row what</font>

59
00:02:18,990 --> 00:02:23,910
happens then<font color="#E5E5E5"> so if you want to access</font>

60
00:02:20,940 --> 00:02:27,120
data<font color="#E5E5E5"> we can't do that by twice and erm</font>

61
00:02:23,910 --> 00:02:30,810
<font color="#CCCCCC">we</font><font color="#E5E5E5"> always have to</font><font color="#CCCCCC"> access one row</font><font color="#E5E5E5"> and we</font>

62
00:02:27,120 --> 00:02:32,580
have to read one row<font color="#E5E5E5"> so first of all we</font>

63
00:02:30,810 --> 00:02:34,500
have to activate the<font color="#CCCCCC"> row we want</font><font color="#E5E5E5"> to read</font>

64
00:02:32,580 --> 00:02:37,560
where the data is stored<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we want to</font>

65
00:02:34,500 --> 00:02:40,110
retrieve<font color="#E5E5E5"> and so the memory row is</font>

66
00:02:37,560 --> 00:02:42,900
activated there then it's copied into

67
00:02:40,110 --> 00:02:46,080
the<font color="#E5E5E5"> row buffer so whole row</font><font color="#CCCCCC"> is copied</font>

68
00:02:42,900 --> 00:02:48,450
into this buffer<font color="#E5E5E5"> and only the contents</font>

69
00:02:46,080 --> 00:02:50,820
of<font color="#E5E5E5"> the buffer can be</font><font color="#CCCCCC"> actually read by</font>

70
00:02:48,450 --> 00:02:52,799
the CPU<font color="#CCCCCC"> and it's returned to the CPU</font>

71
00:02:50,820 --> 00:02:55,470
<font color="#CCCCCC">okay that sounds really slow actually</font>

72
00:02:52,800 --> 00:02:57,720
<font color="#CCCCCC">and what happens if the CPU now wants</font><font color="#E5E5E5"> to</font>

73
00:02:55,470 --> 00:03:00,270
access another<font color="#E5E5E5"> row then we do the same</font>

74
00:02:57,720 --> 00:03:02,940
thing again<font color="#CCCCCC"> so we want to access a</font>

75
00:03:00,270 --> 00:03:05,310
different<font color="#CCCCCC"> row</font><font color="#E5E5E5"> we have to again activate</font>

76
00:03:02,940 --> 00:03:07,500
that row first<font color="#CCCCCC"> then we have something</font>

77
00:03:05,310 --> 00:03:09,120
<font color="#CCCCCC">different in a row buffer</font><font color="#E5E5E5"> we have to</font>

78
00:03:07,500 --> 00:03:12,330
overwrite the<font color="#E5E5E5"> row buffer with the new</font>

79
00:03:09,120 --> 00:03:14,460
row<font color="#CCCCCC"> if we change the content before</font><font color="#E5E5E5"> we</font>

80
00:03:12,330 --> 00:03:17,070
even have to write<font color="#CCCCCC"> back the Dro buffer</font>

81
00:03:14,460 --> 00:03:18,780
to<font color="#CCCCCC"> the old row</font><font color="#E5E5E5"> before that then you have</font>

82
00:03:17,070 --> 00:03:23,100
this new row in the row buffer and we

83
00:03:18,780 --> 00:03:25,620
<font color="#CCCCCC">can</font><font color="#E5E5E5"> return this value to the CPU</font><font color="#CCCCCC"> so this</font>

84
00:03:23,100 --> 00:03:27,299
is this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> quite slow a little bit so</font>

85
00:03:25,620 --> 00:03:29,460
it's always slow is there a case that is

86
00:03:27,300 --> 00:03:31,920
fast for instance if we<font color="#E5E5E5"> access the same</font>

87
00:03:29,460 --> 00:03:33,600
row again and we don't have<font color="#CCCCCC"> a</font><font color="#E5E5E5"> conflict</font>

88
00:03:31,920 --> 00:03:36,329
so that's a lot better<font color="#E5E5E5"> for performance</font>

89
00:03:33,600 --> 00:03:38,549
<font color="#E5E5E5">and if we want to</font><font color="#CCCCCC"> access state that it's</font>

90
00:03:36,330 --> 00:03:41,010
in<font color="#E5E5E5"> the same row then this rows</font><font color="#CCCCCC"> are in</font>

91
00:03:38,550 --> 00:03:43,830
the row buffer and we<font color="#E5E5E5"> don't have to copy</font>

92
00:03:41,010 --> 00:03:46,290
anything<font color="#E5E5E5"> and we can directly return the</font>

93
00:03:43,830 --> 00:03:48,630
content of the row buffer to<font color="#CCCCCC"> the CPU so</font>

94
00:03:46,290 --> 00:03:50,880
this is fast this is a row hit we hit

95
00:03:48,630 --> 00:03:51,660
the same row again<font color="#E5E5E5"> and this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> actually</font>

96
00:03:50,880 --> 00:03:55,049
pretty fast

97
00:03:51,660 --> 00:03:56,730
so what you're saying<font color="#E5E5E5"> basically the row</font>

98
00:03:55,050 --> 00:04:00,150
buffer is a cache<font color="#CCCCCC"> where</font><font color="#E5E5E5"> you can store</font>

99
00:03:56,730 --> 00:04:02,489
one row and cache it and if you now<font color="#CCCCCC"> have</font>

100
00:04:00,150 --> 00:04:04,920
access to a high resolution timer<font color="#E5E5E5"> what</font>

101
00:04:02,490 --> 00:04:08,070
you can do you can<font color="#CCCCCC"> actually time how</font>

102
00:04:04,920 --> 00:04:10,530
long<font color="#E5E5E5"> it takes</font><font color="#CCCCCC"> to load the address and we</font>

103
00:04:08,070 --> 00:04:12,959
<font color="#E5E5E5">can distinguish the cases where we</font><font color="#CCCCCC"> have</font>

104
00:04:10,530 --> 00:04:15,660
a row hit and a row conflict as<font color="#E5E5E5"> we can</font>

105
00:04:12,960 --> 00:04:18,060
see on<font color="#E5E5E5"> this plot so we</font><font color="#CCCCCC"> can easily</font><font color="#E5E5E5"> find a</font>

106
00:04:15,660 --> 00:04:20,040
threshold<font color="#CCCCCC"> in between</font><font color="#E5E5E5"> which allows us to</font>

107
00:04:18,060 --> 00:04:23,640
<font color="#E5E5E5">distinguish between row hits and row</font>

108
00:04:20,040 --> 00:04:26,580
conflicts yes and as measure I said

109
00:04:23,640 --> 00:04:30,690
before<font color="#E5E5E5"> these cells</font><font color="#CCCCCC"> consists of capacity</font>

110
00:04:26,580 --> 00:04:32,729
and<font color="#CCCCCC"> capacitor is discharged over time if</font>

111
00:04:30,690 --> 00:04:35,310
they<font color="#CCCCCC"> discharged</font><font color="#E5E5E5"> over time we have to</font>

112
00:04:32,729 --> 00:04:38,610
refresh them frequently<font color="#E5E5E5"> and this is also</font>

113
00:04:35,310 --> 00:04:40,590
what happens in<font color="#CCCCCC"> DRAM</font><font color="#E5E5E5"> all the time but so</font>

114
00:04:38,610 --> 00:04:42,539
if you want<font color="#E5E5E5"> to read this row and we</font>

115
00:04:40,590 --> 00:04:44,849
copied to the row buffer<font color="#E5E5E5"> we actually</font>

116
00:04:42,539 --> 00:04:46,560
destroy<font color="#E5E5E5"> the content of the row because</font>

117
00:04:44,849 --> 00:04:48,960
we<font color="#CCCCCC"> discharged all</font><font color="#E5E5E5"> the capacitors</font><font color="#CCCCCC"> to</font>

118
00:04:46,560 --> 00:04:50,720
measure them<font color="#CCCCCC"> there also other effect</font>

119
00:04:48,960 --> 00:04:53,219
yeah that's a<font color="#CCCCCC"> problem there because</font>

120
00:04:50,720 --> 00:04:55,710
everything is so small<font color="#E5E5E5"> in there already</font>

121
00:04:53,220 --> 00:04:58,770
that<font color="#E5E5E5"> we</font><font color="#CCCCCC"> also</font><font color="#E5E5E5"> discharge neighboring</font>

122
00:04:55,710 --> 00:05:00,570
capacitors there<font color="#CCCCCC"> okay that's a bit of a</font>

123
00:04:58,770 --> 00:05:03,240
problem<font color="#E5E5E5"> right and if we</font><font color="#CCCCCC"> do</font><font color="#E5E5E5"> that often</font>

124
00:05:00,570 --> 00:05:05,669
enough<font color="#E5E5E5"> if we do that often</font><font color="#CCCCCC"> enough and</font>

125
00:05:03,240 --> 00:05:08,699
the contents are not refreshed<font color="#CCCCCC"> fast</font>

126
00:05:05,669 --> 00:05:10,680
<font color="#CCCCCC">enough then</font><font color="#E5E5E5"> suddenly we have bit flips</font>

127
00:05:08,699 --> 00:05:12,900
and we get<font color="#CCCCCC"> different contents</font><font color="#E5E5E5"> in</font>

128
00:05:10,680 --> 00:05:16,470
neighboring row rows<font color="#E5E5E5"> that we can't even</font>

129
00:05:12,900 --> 00:05:18,599
<font color="#E5E5E5">access</font><font color="#CCCCCC"> okay this sounds</font><font color="#E5E5E5"> quite bad</font><font color="#CCCCCC"> but</font>

130
00:05:16,470 --> 00:05:20,580
let's see how widespread this issue

131
00:05:18,599 --> 00:05:24,240
<font color="#CCCCCC">actually is maybe</font><font color="#E5E5E5"> this only</font><font color="#CCCCCC"> effects</font>

132
00:05:20,580 --> 00:05:26,880
<font color="#E5E5E5">something like below average substandard</font>

133
00:05:24,240 --> 00:05:28,199
<font color="#E5E5E5">DRAM modules that we that sell off the</font>

134
00:05:26,880 --> 00:05:31,889
truck somewhere<font color="#E5E5E5"> or something I don't</font>

135
00:05:28,199 --> 00:05:35,009
<font color="#E5E5E5">know</font><font color="#CCCCCC"> let's talk</font><font color="#E5E5E5"> about ddr3 and ddr4 here</font>

136
00:05:31,889 --> 00:05:36,870
of course it also<font color="#CCCCCC"> effects</font><font color="#E5E5E5"> ddr2</font><font color="#CCCCCC"> we also</font>

137
00:05:35,009 --> 00:05:40,320
saw a bit flips on<font color="#E5E5E5"> LPD do what you want</font>

138
00:05:36,870 --> 00:05:44,250
anymore<font color="#CCCCCC"> yes that's</font><font color="#E5E5E5"> true old but for ddr3</font>

139
00:05:40,320 --> 00:05:44,669
<font color="#E5E5E5">there's a study that showed from 2014</font>

140
00:05:44,250 --> 00:05:47,400
<font color="#CCCCCC">kemerall</font>

141
00:05:44,669 --> 00:05:51,659
showed<font color="#E5E5E5"> that 85% of the modules they had</font>

142
00:05:47,400 --> 00:05:54,630
were affected<font color="#E5E5E5"> and see later on 2015 see</font>

143
00:05:51,659 --> 00:05:56,400
<font color="#E5E5E5">bond and</font><font color="#CCCCCC"> julian</font><font color="#E5E5E5"> showed that</font><font color="#CCCCCC"> 52% of</font><font color="#E5E5E5"> the</font>

144
00:05:54,630 --> 00:05:58,830
modules they had were affected to their

145
00:05:56,400 --> 00:06:02,370
specific<font color="#E5E5E5"> hammering method that they used</font>

146
00:05:58,830 --> 00:06:04,859
<font color="#CCCCCC">in software for ddr4</font><font color="#E5E5E5"> people first</font>

147
00:06:02,370 --> 00:06:06,630
<font color="#CCCCCC">believe</font><font color="#E5E5E5"> yeah this is safe you can't flip</font>

148
00:06:04,860 --> 00:06:09,690
it's there<font color="#E5E5E5"> because that's also what the</font>

149
00:06:06,630 --> 00:06:10,289
vendors claimed but we tried it<font color="#E5E5E5"> and it</font>

150
00:06:09,690 --> 00:06:14,070
works

151
00:06:10,289 --> 00:06:16,919
we showed<font color="#E5E5E5"> bit flips on ddr4 in 2016</font>

152
00:06:14,070 --> 00:06:18,990
also there was<font color="#E5E5E5"> a paper</font><font color="#CCCCCC"> that had a small</font>

153
00:06:16,919 --> 00:06:22,380
<font color="#E5E5E5">prevalence study with 12 modules and</font>

154
00:06:18,990 --> 00:06:24,930
<font color="#CCCCCC">there</font><font color="#E5E5E5"> eight modules were affected</font><font color="#CCCCCC"> came</font>

155
00:06:22,380 --> 00:06:27,659
<font color="#CCCCCC">at all</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> the original paper</font><font color="#E5E5E5"> also</font><font color="#CCCCCC"> had a</font>

156
00:06:24,930 --> 00:06:30,780
correlation<font color="#CCCCCC"> to the manufacturing date</font><font color="#E5E5E5"> of</font>

157
00:06:27,659 --> 00:06:32,759
the module<font color="#E5E5E5"> so they showed</font><font color="#CCCCCC"> that this</font>

158
00:06:30,780 --> 00:06:35,789
seems to<font color="#CCCCCC"> be correlated with</font><font color="#E5E5E5"> the</font>

159
00:06:32,759 --> 00:06:39,330
manufacturing<font color="#E5E5E5"> date so yeah it flips</font>

160
00:06:35,789 --> 00:06:42,509
everywhere<font color="#CCCCCC"> ok</font>

161
00:06:39,330 --> 00:06:46,020
what do we<font color="#E5E5E5"> need to induce</font><font color="#CCCCCC"> row hammer</font><font color="#E5E5E5"> bit</font>

162
00:06:42,509 --> 00:06:48,090
flips we want to reach<font color="#E5E5E5"> the</font><font color="#CCCCCC"> DRM</font><font color="#E5E5E5"> so we</font>

163
00:06:46,020 --> 00:06:51,060
need to have<font color="#CCCCCC"> uncashed memory accesses we</font>

164
00:06:48,090 --> 00:06:53,039
need to<font color="#CCCCCC"> bypass the cache somehow this</font>

165
00:06:51,060 --> 00:06:54,780
also has to<font color="#CCCCCC"> be fast and this</font><font color="#E5E5E5"> is a</font>

166
00:06:53,039 --> 00:06:56,789
problem<font color="#CCCCCC"> because uncashed memory accesses</font>

167
00:06:54,780 --> 00:06:59,039
are much slower<font color="#CCCCCC"> than cached accesses and</font>

168
00:06:56,789 --> 00:07:01,050
now we want to<font color="#E5E5E5"> be fast so</font><font color="#CCCCCC"> that we are</font>

169
00:06:59,039 --> 00:07:03,780
faster than the<font color="#E5E5E5"> next drawer refresh and</font>

170
00:07:01,050 --> 00:07:06,960
we also need<font color="#E5E5E5"> to target the</font><font color="#CCCCCC"> accesses so</font>

171
00:07:03,780 --> 00:07:11,460
<font color="#CCCCCC">we need to access</font><font color="#E5E5E5"> the correct rows that</font>

172
00:07:06,960 --> 00:07:13,799
trigger such bit flips so the question

173
00:07:11,460 --> 00:07:15,780
arises how do we get enough<font color="#E5E5E5"> on cache</font>

174
00:07:13,800 --> 00:07:17,699
<font color="#E5E5E5">accesses because we have</font><font color="#CCCCCC"> two CPU cache</font>

175
00:07:15,780 --> 00:07:19,409
and whenever we load some<font color="#CCCCCC"> data</font><font color="#E5E5E5"> it's</font>

176
00:07:17,699 --> 00:07:21,599
<font color="#E5E5E5">stored in the cache and it remains in</font>

177
00:07:19,409 --> 00:07:23,699
<font color="#CCCCCC">the</font><font color="#E5E5E5"> cache for subsequent</font><font color="#CCCCCC"> accesses so</font>

178
00:07:21,599 --> 00:07:26,370
that those accesses are pretty<font color="#E5E5E5"> fast and</font>

179
00:07:23,699 --> 00:07:28,800
makes our systems very fast<font color="#CCCCCC"> that we have</font>

180
00:07:26,370 --> 00:07:31,319
them nowadays<font color="#E5E5E5"> so we have different</font>

181
00:07:28,800 --> 00:07:33,180
methods<font color="#CCCCCC"> that we can use to</font><font color="#E5E5E5"> remove data</font>

182
00:07:31,319 --> 00:07:35,419
from the cache<font color="#E5E5E5"> so that</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> next axis</font>

183
00:07:33,180 --> 00:07:37,919
will be<font color="#CCCCCC"> loaded</font><font color="#E5E5E5"> from</font><font color="#CCCCCC"> the main</font><font color="#E5E5E5"> memory and</font>

184
00:07:35,419 --> 00:07:40,020
<font color="#E5E5E5">the first thing is the CL flash</font>

185
00:07:37,919 --> 00:07:41,938
instruction and this instruction was

186
00:07:40,020 --> 00:07:43,650
also proposed in the original paper<font color="#E5E5E5"> and</font>

187
00:07:41,939 --> 00:07:45,659
it's an unprivileged instruction that

188
00:07:43,650 --> 00:07:48,929
<font color="#E5E5E5">you can use to just remove the address</font>

189
00:07:45,659 --> 00:07:51,180
from the cache<font color="#E5E5E5"> in 2015 we then showed</font>

190
00:07:48,930 --> 00:07:53,490
that we can also do this with cache

191
00:07:51,180 --> 00:07:56,639
eviction even from JavaScript<font color="#E5E5E5"> you might</font>

192
00:07:53,490 --> 00:07:58,889
remember the name<font color="#CCCCCC"> row</font><font color="#E5E5E5"> Hema Jas</font><font color="#CCCCCC"> because</font>

193
00:07:56,639 --> 00:08:00,599
of course at<font color="#E5E5E5"> some point the cache is too</font>

194
00:07:58,889 --> 00:08:02,759
small and whenever we<font color="#E5E5E5"> load more and</font>

195
00:08:00,599 --> 00:08:04,710
<font color="#CCCCCC">commentator at some point</font><font color="#E5E5E5"> the CPU needs</font>

196
00:08:02,759 --> 00:08:06,810
to decide what it needs<font color="#E5E5E5"> to evict from</font>

197
00:08:04,710 --> 00:08:08,750
the cache<font color="#E5E5E5"> so the next time we accesses</font>

198
00:08:06,810 --> 00:08:11,460
it will be loaded<font color="#CCCCCC"> from the DRAM again</font>

199
00:08:08,750 --> 00:08:13,560
what we also<font color="#E5E5E5"> can do is to use</font><font color="#CCCCCC"> non</font>

200
00:08:11,460 --> 00:08:16,229
<font color="#CCCCCC">temporal accesses which do</font><font color="#E5E5E5"> not get</font>

201
00:08:13,560 --> 00:08:18,210
stored in the cache at all or what we

202
00:08:16,229 --> 00:08:22,229
have<font color="#E5E5E5"> seen we can also use a sham cache</font>

203
00:08:18,210 --> 00:08:24,060
memory<font color="#E5E5E5"> s from the</font><font color="#CCCCCC"> vin</font><font color="#E5E5E5"> showed us on the</font>

204
00:08:22,229 --> 00:08:26,940
<font color="#CCCCCC">android system where they had</font><font color="#E5E5E5"> bit flips</font>

205
00:08:24,060 --> 00:08:28,710
on mobile devices<font color="#CCCCCC"> yes i'm cache memory</font>

206
00:08:26,940 --> 00:08:30,810
sounds really unsafe<font color="#CCCCCC"> because we don't</font>

207
00:08:28,710 --> 00:08:34,279
need cash eviction<font color="#CCCCCC"> then</font><font color="#E5E5E5"> so now we can</font>

208
00:08:30,810 --> 00:08:37,380
<font color="#CCCCCC">have pit flips but how do we</font><font color="#E5E5E5"> target</font>

209
00:08:34,279 --> 00:08:39,719
accesses<font color="#E5E5E5"> Michael yeah so we usually</font>

210
00:08:37,380 --> 00:08:41,099
<font color="#E5E5E5">don't know about anything about the</font>

211
00:08:39,719 --> 00:08:43,219
<font color="#CCCCCC">addresses and</font><font color="#E5E5E5"> where they are actually</font>

212
00:08:41,099 --> 00:08:48,020
stored<font color="#CCCCCC"> in which were a row of the DRAM</font>

213
00:08:43,219 --> 00:08:51,839
<font color="#CCCCCC">but luckily in 2016</font><font color="#E5E5E5"> at blackhat Europe</font>

214
00:08:48,020 --> 00:08:53,130
and as<font color="#CCCCCC"> Forgan</font><font color="#E5E5E5"> I presented such an attack</font>

215
00:08:51,839 --> 00:08:55,529
<font color="#CCCCCC">drama</font>

216
00:08:53,130 --> 00:08:58,620
which allowed us<font color="#E5E5E5"> to really get a good</font>

217
00:08:55,529 --> 00:09:01,470
picture of<font color="#E5E5E5"> how the data is stored in the</font>

218
00:08:58,620 --> 00:09:03,620
DRAM and which address maps to which

219
00:09:01,470 --> 00:09:07,410
part of the<font color="#E5E5E5"> DRM and how do we target</font>

220
00:09:03,620 --> 00:09:11,790
specific<font color="#CCCCCC"> roles in the DRM</font><font color="#E5E5E5"> for our</font><font color="#CCCCCC"> omi</font>

221
00:09:07,410 --> 00:09:14,819
attack<font color="#CCCCCC"> ok so what</font><font color="#E5E5E5"> you're saying is now</font>

222
00:09:11,790 --> 00:09:16,769
we<font color="#E5E5E5"> can induce random bit flips</font><font color="#CCCCCC"> right</font>

223
00:09:14,819 --> 00:09:19,139
random bit flips that what we all heard

224
00:09:16,769 --> 00:09:21,750
about<font color="#CCCCCC"> roarhammer it's random bit flips</font>

225
00:09:19,139 --> 00:09:24,779
<font color="#E5E5E5">and here the question is if it's random</font>

226
00:09:21,750 --> 00:09:26,550
<font color="#E5E5E5">bit flips can't we this useless in some</font>

227
00:09:24,779 --> 00:09:28,980
fancy ways true randomness is really

228
00:09:26,550 --> 00:09:31,560
expensive right<font color="#E5E5E5"> and it turns out this is</font>

229
00:09:28,980 --> 00:09:34,019
<font color="#CCCCCC">not true randomness they are not random</font>

230
00:09:31,560 --> 00:09:36,719
if you hammer the same locations again

231
00:09:34,019 --> 00:09:40,500
<font color="#E5E5E5">you will get the same bit flip pattern</font>

232
00:09:36,720 --> 00:09:42,630
<font color="#E5E5E5">it's highly reproducible so what you can</font>

233
00:09:40,500 --> 00:09:45,180
do is you<font color="#E5E5E5"> can think of a data structure</font>

234
00:09:42,630 --> 00:09:47,130
<font color="#CCCCCC">that you want to modify</font><font color="#E5E5E5"> and think about</font>

235
00:09:45,180 --> 00:09:50,370
the bit position that you<font color="#E5E5E5"> want to change</font>

236
00:09:47,130 --> 00:09:53,339
<font color="#CCCCCC">and then you scan the</font><font color="#E5E5E5"> entire memory for</font>

237
00:09:50,370 --> 00:09:55,139
bit flips<font color="#E5E5E5"> at the right offset and then</font>

238
00:09:53,339 --> 00:09:58,769
try to move<font color="#E5E5E5"> your data structure there</font>

239
00:09:55,139 --> 00:10:00,810
<font color="#E5E5E5">for instance by spraying and then you</font>

240
00:09:58,769 --> 00:10:02,579
can trigger the bit flip again and you

241
00:10:00,810 --> 00:10:04,829
<font color="#E5E5E5">have changed exactly</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> right bit to</font>

242
00:10:02,579 --> 00:10:06,089
<font color="#E5E5E5">exactly the right value and can do</font>

243
00:10:04,829 --> 00:10:09,000
whatever you want with it

244
00:10:06,089 --> 00:10:11,550
yes<font color="#E5E5E5"> in addition you can also build</font><font color="#CCCCCC"> a</font>

245
00:10:09,000 --> 00:10:14,750
<font color="#CCCCCC">path with it because it's</font><font color="#E5E5E5"> not random</font><font color="#CCCCCC"> you</font>

246
00:10:11,550 --> 00:10:14,750
cannot<font color="#E5E5E5"> build</font><font color="#CCCCCC"> a random number generator</font>

247
00:10:15,560 --> 00:10:22,560
<font color="#CCCCCC">ok so when</font><font color="#E5E5E5"> we have bit flips now Daniel</font>

248
00:10:20,850 --> 00:10:26,339
what can we do with<font color="#E5E5E5"> them so it's just</font>

249
00:10:22,560 --> 00:10:28,619
<font color="#E5E5E5">one simple bit any ideas about what</font><font color="#CCCCCC"> to</font>

250
00:10:26,339 --> 00:10:30,620
<font color="#E5E5E5">actually exploit with that in 2015</font>

251
00:10:28,620 --> 00:10:33,329
<font color="#CCCCCC">Seabourn and julian showed that we can</font>

252
00:10:30,620 --> 00:10:35,610
modify<font color="#E5E5E5"> op codes because opcodes have</font>

253
00:10:33,329 --> 00:10:39,719
variable<font color="#CCCCCC"> length</font><font color="#E5E5E5"> and you might have a</font>

254
00:10:35,610 --> 00:10:42,689
<font color="#CCCCCC">Cisco instruction in included</font><font color="#E5E5E5"> in a</font>

255
00:10:39,720 --> 00:10:44,399
longer opcode<font color="#CCCCCC"> so you have a long opcode</font>

256
00:10:42,689 --> 00:10:46,439
and<font color="#E5E5E5"> part of the</font><font color="#CCCCCC"> opcode</font><font color="#E5E5E5"> could be</font>

257
00:10:44,399 --> 00:10:49,110
interpreted as a Cisco but usually

258
00:10:46,439 --> 00:10:51,630
because in<font color="#CCCCCC"> Chrome NaCl or something you</font>

259
00:10:49,110 --> 00:10:54,029
would<font color="#E5E5E5"> have sanitization running you</font>

260
00:10:51,630 --> 00:10:56,939
could not jump to<font color="#E5E5E5"> this</font><font color="#CCCCCC"> dis aligned</font>

261
00:10:54,029 --> 00:10:58,829
memory address<font color="#E5E5E5"> and what you can do now</font>

262
00:10:56,939 --> 00:11:00,599
is<font color="#CCCCCC"> you can induce a bit flip at the</font>

263
00:10:58,829 --> 00:11:03,380
<font color="#E5E5E5">right</font><font color="#CCCCCC"> offset and then</font><font color="#E5E5E5"> you can jump to</font>

264
00:11:00,600 --> 00:11:05,830
this<font color="#CCCCCC"> this</font><font color="#E5E5E5"> aligned memory location and</font>

265
00:11:03,380 --> 00:11:09,020
performance is called

266
00:11:05,830 --> 00:11:13,850
yeah<font color="#E5E5E5"> they showed</font><font color="#CCCCCC"> that you can</font><font color="#E5E5E5"> exploit</font>

267
00:11:09,020 --> 00:11:17,150
<font color="#E5E5E5">the chrome NaCl sandbox with that but</font>

268
00:11:13,850 --> 00:11:20,150
what do<font color="#E5E5E5"> we do if we</font><font color="#CCCCCC"> want to have a more</font>

269
00:11:17,150 --> 00:11:25,360
generic exploit for<font color="#E5E5E5"> instance get access</font>

270
00:11:20,150 --> 00:11:27,770
to ring<font color="#E5E5E5"> zero</font><font color="#CCCCCC"> and there we can attack</font>

271
00:11:25,360 --> 00:11:30,680
data structures<font color="#CCCCCC"> that belong to the</font>

272
00:11:27,770 --> 00:11:32,180
<font color="#E5E5E5">kernel for instance the page tables if</font>

273
00:11:30,680 --> 00:11:34,969
you think<font color="#E5E5E5"> about the page tables we</font><font color="#CCCCCC"> have</font>

274
00:11:32,180 --> 00:11:37,250
here the present bit<font color="#E5E5E5"> the right of the</font>

275
00:11:34,970 --> 00:11:39,950
right<font color="#E5E5E5"> access user space access right</font>

276
00:11:37,250 --> 00:11:41,270
through<font color="#CCCCCC"> uncashed reference dirty the</font>

277
00:11:39,950 --> 00:11:43,400
size with the global bit and the

278
00:11:41,270 --> 00:11:45,140
non-executable bit and we<font color="#E5E5E5"> have addition</font>

279
00:11:43,400 --> 00:11:49,430
we have<font color="#E5E5E5"> some bits that</font><font color="#CCCCCC"> are not</font><font color="#E5E5E5"> even used</font>

280
00:11:45,140 --> 00:11:52,220
there<font color="#E5E5E5"> yes and the large red part does</font>

281
00:11:49,430 --> 00:11:56,689
anyone know what this part represent

282
00:11:52,220 --> 00:12:00,140
<font color="#E5E5E5">represents the page number</font><font color="#CCCCCC"> it's the</font><font color="#E5E5E5"> page</font>

283
00:11:56,690 --> 00:12:03,680
number<font color="#E5E5E5"> and if we flip a bit in there</font>

284
00:12:00,140 --> 00:12:08,810
<font color="#E5E5E5">then the mapping from</font><font color="#CCCCCC"> virtual</font><font color="#E5E5E5"> address to</font>

285
00:12:03,680 --> 00:12:11,449
<font color="#CCCCCC">a physical address changes luckily page</font>

286
00:12:08,810 --> 00:12:14,599
tables are organized in 512 such entries

287
00:12:11,450 --> 00:12:17,150
in<font color="#CCCCCC"> 1 4</font><font color="#E5E5E5"> kilobyte page so most of the data</font>

288
00:12:14,600 --> 00:12:19,730
on this<font color="#CCCCCC"> 4</font><font color="#E5E5E5"> kilobyte page will consist of</font>

289
00:12:17,150 --> 00:12:21,829
physical page numbers so<font color="#CCCCCC"> maybe we should</font>

290
00:12:19,730 --> 00:12:23,230
<font color="#CCCCCC">learn a bit more about page tables</font><font color="#E5E5E5"> yeah</font>

291
00:12:21,830 --> 00:12:25,850
if you look<font color="#E5E5E5"> at the page tables is a</font>

292
00:12:23,230 --> 00:12:28,700
really fundamental concept of virtual

293
00:12:25,850 --> 00:12:30,800
<font color="#CCCCCC">memory nowadays</font><font color="#E5E5E5"> so in our programs we</font>

294
00:12:28,700 --> 00:12:32,390
have our virtual<font color="#E5E5E5"> addresses we call them</font>

295
00:12:30,800 --> 00:12:33,979
usually<font color="#E5E5E5"> just addresses</font><font color="#CCCCCC"> because we are</font>

296
00:12:32,390 --> 00:12:37,189
<font color="#E5E5E5">never in touch with physically addresses</font>

297
00:12:33,980 --> 00:12:38,990
and<font color="#E5E5E5"> they somehow map to some part of the</font>

298
00:12:37,190 --> 00:12:40,760
<font color="#CCCCCC">physical memory the data as we stored</font>

299
00:12:38,990 --> 00:12:42,920
somewhere<font color="#E5E5E5"> and then we have</font><font color="#CCCCCC"> this page</font>

300
00:12:40,760 --> 00:12:45,260
table<font color="#CCCCCC"> entries and hole paging structure</font>

301
00:12:42,920 --> 00:12:48,620
behind<font color="#E5E5E5"> them and they then actually map</font>

302
00:12:45,260 --> 00:12:52,819
this virtual address<font color="#CCCCCC"> to one physical</font>

303
00:12:48,620 --> 00:12:55,160
address and the interesting<font color="#CCCCCC"> thing</font><font color="#E5E5E5"> is so</font>

304
00:12:52,820 --> 00:12:57,800
they can<font color="#CCCCCC"> map page</font><font color="#E5E5E5"> length we</font><font color="#CCCCCC"> can map any</font>

305
00:12:55,160 --> 00:13:00,469
<font color="#E5E5E5">user page or</font><font color="#CCCCCC"> Karl page</font><font color="#E5E5E5"> and the cool</font>

306
00:12:57,800 --> 00:13:02,870
<font color="#CCCCCC">thing is</font><font color="#E5E5E5"> if we</font><font color="#CCCCCC"> modify this page</font><font color="#E5E5E5"> table</font>

307
00:13:00,470 --> 00:13:05,060
entry as<font color="#CCCCCC"> daniel said we can make it map</font>

308
00:13:02,870 --> 00:13:07,340
<font color="#E5E5E5">a different physical page so we could</font>

309
00:13:05,060 --> 00:13:09,760
map any page<font color="#CCCCCC"> that we have</font><font color="#E5E5E5"> in memory and</font>

310
00:13:07,340 --> 00:13:14,000
<font color="#E5E5E5">then accesses using this virtual address</font>

311
00:13:09,760 --> 00:13:18,110
<font color="#E5E5E5">so then we could map some kernel pages</font>

312
00:13:14,000 --> 00:13:19,160
or<font color="#E5E5E5"> other page tables or some other user</font>

313
00:13:18,110 --> 00:13:23,060
pages

314
00:13:19,160 --> 00:13:25,490
and this is realized so no<font color="#CCCCCC"> saint</font>

315
00:13:23,060 --> 00:13:28,189
operating<font color="#E5E5E5"> system would allow</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> okay</font>

316
00:13:25,490 --> 00:13:30,440
so what we can<font color="#CCCCCC"> do here is we can first</font>

317
00:13:28,190 --> 00:13:32,150
scan for the bit flips as we said at

318
00:13:30,440 --> 00:13:33,680
<font color="#E5E5E5">some point we will find a location</font><font color="#CCCCCC"> where</font>

319
00:13:32,150 --> 00:13:36,560
<font color="#CCCCCC">we have the right bit flip in this</font><font color="#E5E5E5"> four</font>

320
00:13:33,680 --> 00:13:40,069
kilobyte<font color="#E5E5E5"> page and then we release this</font>

321
00:13:36,560 --> 00:13:41,810
page we free this page and spray the

322
00:13:40,070 --> 00:13:44,420
entire<font color="#CCCCCC"> memory fill the</font><font color="#E5E5E5"> entire memory</font>

323
00:13:41,810 --> 00:13:46,189
with page tables including<font color="#E5E5E5"> this memory</font>

324
00:13:44,420 --> 00:13:49,490
<font color="#CCCCCC">location and then</font><font color="#E5E5E5"> we will get to this</font>

325
00:13:46,190 --> 00:13:51,560
picture<font color="#CCCCCC"> here</font><font color="#E5E5E5"> so what happens now if</font><font color="#CCCCCC"> we</font>

326
00:13:49,490 --> 00:13:53,030
trigger the<font color="#CCCCCC"> same bit flip on the victim</font>

327
00:13:51,560 --> 00:13:55,790
page that we had earlier and released

328
00:13:53,030 --> 00:13:59,000
with a high chance<font color="#CCCCCC"> we flip a bit in the</font>

329
00:13:55,790 --> 00:14:01,250
page number which now points directly<font color="#E5E5E5"> to</font>

330
00:13:59,000 --> 00:14:04,610
one<font color="#CCCCCC"> of our</font><font color="#E5E5E5"> page tables that we control</font>

331
00:14:01,250 --> 00:14:06,500
<font color="#E5E5E5">and what can we do with</font><font color="#CCCCCC"> that micro</font><font color="#E5E5E5"> now</font>

332
00:14:04,610 --> 00:14:09,410
we control everything<font color="#E5E5E5"> right now we have</font>

333
00:14:06,500 --> 00:14:11,870
<font color="#E5E5E5">right access to</font><font color="#CCCCCC"> a page table so this</font><font color="#E5E5E5"> is</font>

334
00:14:09,410 --> 00:14:14,089
<font color="#E5E5E5">realize we can map anything read</font>

335
00:14:11,870 --> 00:14:17,410
anything<font color="#E5E5E5"> writes to everything</font><font color="#CCCCCC"> so we just</font>

336
00:14:14,090 --> 00:14:20,600
<font color="#E5E5E5">simply scan for bit flips</font><font color="#CCCCCC"> exhaust met</font>

337
00:14:17,410 --> 00:14:23,240
memory<font color="#E5E5E5"> to have a lot of</font><font color="#CCCCCC"> page tables in</font>

338
00:14:20,600 --> 00:14:24,620
the memory<font color="#E5E5E5"> and then flip one bit one</font>

339
00:14:23,240 --> 00:14:26,750
page table will point to a different

340
00:14:24,620 --> 00:14:29,510
<font color="#CCCCCC">page table we can</font><font color="#E5E5E5"> rewrite the page table</font>

341
00:14:26,750 --> 00:14:31,520
entry and we have full access<font color="#CCCCCC"> aright</font><font color="#E5E5E5"> I</font>

342
00:14:29,510 --> 00:14:34,700
read anything<font color="#E5E5E5"> right anywhere primitive</font>

343
00:14:31,520 --> 00:14:36,560
on our computer<font color="#CCCCCC"> okay really</font><font color="#E5E5E5"> nice so</font>

344
00:14:34,700 --> 00:14:39,170
these were the<font color="#E5E5E5"> basics about the row</font>

345
00:14:36,560 --> 00:14:41,810
hammer attack<font color="#E5E5E5"> this is all 2015 and</font>

346
00:14:39,170 --> 00:14:47,990
earlier but then there were also<font color="#E5E5E5"> other</font>

347
00:14:41,810 --> 00:14:51,109
attacks for<font color="#E5E5E5"> instance</font><font color="#CCCCCC"> yeah so</font><font color="#E5E5E5"> this this</font>

348
00:14:47,990 --> 00:14:52,970
first idea<font color="#E5E5E5"> was from 2015</font><font color="#CCCCCC"> and it was also</font>

349
00:14:51,110 --> 00:14:55,250
<font color="#E5E5E5">reused later on in other words we used</font>

350
00:14:52,970 --> 00:14:57,140
it<font color="#E5E5E5"> in raw hamachi is it was also used in</font>

351
00:14:55,250 --> 00:15:02,180
one bit flips<font color="#E5E5E5"> one cloud flops and then</font>

352
00:14:57,140 --> 00:15:04,790
in the drama<font color="#E5E5E5"> exploit as well</font><font color="#CCCCCC"> okay so we</font>

353
00:15:02,180 --> 00:15:07,310
can flip<font color="#E5E5E5"> bits and the interesting</font><font color="#CCCCCC"> thing</font>

354
00:15:04,790 --> 00:15:10,670
<font color="#E5E5E5">is we can only flip bits in page tables</font>

355
00:15:07,310 --> 00:15:12,589
if a lot of more possibilities<font color="#E5E5E5"> when we</font>

356
00:15:10,670 --> 00:15:15,439
have bit flips we can modify binary

357
00:15:12,590 --> 00:15:18,080
pages have different code credential

358
00:15:15,440 --> 00:15:20,570
structs we can corrupt<font color="#E5E5E5"> keys or</font>

359
00:15:18,080 --> 00:15:23,030
signatures so basic fault attacks we

360
00:15:20,570 --> 00:15:25,310
know we can modify certificates to point

361
00:15:23,030 --> 00:15:27,650
to<font color="#E5E5E5"> different stuff or make them valid</font>

362
00:15:25,310 --> 00:15:29,449
again<font color="#E5E5E5"> you can flip configuration files</font>

363
00:15:27,650 --> 00:15:31,490
<font color="#E5E5E5">because we usually have some</font><font color="#CCCCCC"> binary</font>

364
00:15:29,450 --> 00:15:32,870
configurations in there to<font color="#CCCCCC"> enable or</font>

365
00:15:31,490 --> 00:15:34,190
disable something

366
00:15:32,870 --> 00:15:37,010
so there<font color="#E5E5E5"> are many many possibilities</font>

367
00:15:34,190 --> 00:15:40,310
<font color="#CCCCCC">with just</font><font color="#E5E5E5"> one simple bit flip that we</font>

368
00:15:37,010 --> 00:15:41,960
can induce<font color="#E5E5E5"> with brohamer yeah and paid</font>

369
00:15:40,310 --> 00:15:48,650
pages are pretty unique

370
00:15:41,960 --> 00:15:51,350
they have<font color="#CCCCCC"> 32,768 bits</font><font color="#E5E5E5"> they are</font><font color="#CCCCCC"> usually</font>

371
00:15:48,650 --> 00:15:53,839
<font color="#CCCCCC">not identical by coincidence and this</font>

372
00:15:51,350 --> 00:15:56,450
brings us to<font color="#CCCCCC"> the</font><font color="#E5E5E5"> next point</font><font color="#CCCCCC"> paid seed</font>

373
00:15:53,839 --> 00:16:00,200
application<font color="#E5E5E5"> this was exploited in</font>

374
00:15:56,450 --> 00:16:01,279
several attacks<font color="#E5E5E5"> by music and they also</font>

375
00:16:00,200 --> 00:16:02,990
scan for<font color="#CCCCCC"> bid flips</font>

376
00:16:01,279 --> 00:16:05,089
they find<font color="#E5E5E5"> a location</font><font color="#CCCCCC"> where</font><font color="#E5E5E5"> they have a</font>

377
00:16:02,990 --> 00:16:07,610
bit flip and they have another page that

378
00:16:05,089 --> 00:16:09,680
<font color="#CCCCCC">they want</font><font color="#E5E5E5"> to relocate there so that they</font>

379
00:16:07,610 --> 00:16:13,160
can induce<font color="#CCCCCC"> the bit flip on this page and</font>

380
00:16:09,680 --> 00:16:15,979
they do this by storing<font color="#E5E5E5"> the same content</font>

381
00:16:13,160 --> 00:16:18,529
<font color="#E5E5E5">on</font><font color="#CCCCCC"> this vulnerable page</font><font color="#E5E5E5"> and then waiting</font>

382
00:16:15,980 --> 00:16:20,600
for<font color="#CCCCCC"> deduplication</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> deduplication</font>

383
00:16:18,529 --> 00:16:23,120
hopefully will be<font color="#E5E5E5"> replicate in the right</font>

384
00:16:20,600 --> 00:16:25,100
direction<font color="#E5E5E5"> and if it does then we can</font>

385
00:16:23,120 --> 00:16:28,390
induce<font color="#CCCCCC"> the bit flip on</font><font color="#E5E5E5"> this page</font><font color="#CCCCCC"> that we</font>

386
00:16:25,100 --> 00:16:35,210
actually<font color="#E5E5E5"> should</font><font color="#CCCCCC"> not</font><font color="#E5E5E5"> be able to write</font><font color="#CCCCCC"> to</font>

387
00:16:28,390 --> 00:16:38,300
yeah<font color="#E5E5E5"> so what can</font><font color="#CCCCCC"> we do now with careful</font>

388
00:16:35,210 --> 00:16:40,430
flips again<font color="#E5E5E5"> then we place the content</font>

389
00:16:38,300 --> 00:16:42,490
<font color="#CCCCCC">that we want to do to placate so that</font>

390
00:16:40,430 --> 00:16:45,410
the<font color="#E5E5E5"> bit flip can be exploited in the end</font>

391
00:16:42,490 --> 00:16:51,350
we perform the<font color="#E5E5E5"> bit change</font><font color="#CCCCCC"> through</font><font color="#E5E5E5"> our</font><font color="#CCCCCC"> om</font>

392
00:16:45,410 --> 00:16:54,620
<font color="#E5E5E5">attack and profit yeah this is</font><font color="#CCCCCC"> also an</font>

393
00:16:51,350 --> 00:16:56,360
idea<font color="#E5E5E5"> and it's from 2016 and also</font><font color="#CCCCCC"> with</font>

394
00:16:54,620 --> 00:16:58,459
those bit flips we can do a lot of

395
00:16:56,360 --> 00:17:00,950
<font color="#E5E5E5">interesting stuff by flipping pointers</font>

396
00:16:58,459 --> 00:17:04,730
pointing to<font color="#CCCCCC"> different objects or and</font>

397
00:17:00,950 --> 00:17:06,709
corrupt keys<font color="#CCCCCC"> make the user install</font>

398
00:17:04,730 --> 00:17:09,679
updates from<font color="#E5E5E5"> untrusted sources by</font>

399
00:17:06,709 --> 00:17:12,140
modifying<font color="#E5E5E5"> their update file so there are</font>

400
00:17:09,679 --> 00:17:16,220
also quite interesting ideas they have

401
00:17:12,140 --> 00:17:17,959
<font color="#CCCCCC">already been done</font><font color="#E5E5E5"> before that so</font>

402
00:17:16,220 --> 00:17:20,360
apparently<font color="#E5E5E5"> we have a real problem</font>

403
00:17:17,959 --> 00:17:22,610
<font color="#E5E5E5">because we can just</font><font color="#CCCCCC"> induce pit flips to</font>

404
00:17:20,359 --> 00:17:25,250
get root privileges<font color="#E5E5E5"> corrupt something</font>

405
00:17:22,609 --> 00:17:27,290
different can<font color="#E5E5E5"> we mitigate that they were</font>

406
00:17:25,250 --> 00:17:30,230
of<font color="#CCCCCC"> course different</font><font color="#E5E5E5"> proposes to mitigate</font>

407
00:17:27,290 --> 00:17:32,020
that<font color="#CCCCCC"> so we can distinguish between we</font>

408
00:17:30,230 --> 00:17:34,520
<font color="#E5E5E5">can detect it we can prevent it</font>

409
00:17:32,020 --> 00:17:36,920
<font color="#E5E5E5">Prevention's usually better than</font><font color="#CCCCCC"> that we</font>

410
00:17:34,520 --> 00:17:39,590
<font color="#CCCCCC">can do all the</font><font color="#E5E5E5"> stuff either in software</font>

411
00:17:36,920 --> 00:17:42,500
<font color="#E5E5E5">or in</font><font color="#CCCCCC"> Hardware</font><font color="#E5E5E5"> where</font><font color="#CCCCCC"> software's</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> us</font>

412
00:17:39,590 --> 00:17:44,990
easier<font color="#E5E5E5"> and then we can talk</font><font color="#CCCCCC"> about short</font>

413
00:17:42,500 --> 00:17:46,520
<font color="#CCCCCC">term solution quick fixes</font><font color="#E5E5E5"> that fix it</font>

414
00:17:44,990 --> 00:17:48,260
for some time

415
00:17:46,520 --> 00:17:49,670
<font color="#CCCCCC">long-term</font><font color="#E5E5E5"> solutions which are</font><font color="#CCCCCC"> they're</font>

416
00:17:48,260 --> 00:17:52,310
<font color="#E5E5E5">really good solutions that we then</font>

417
00:17:49,670 --> 00:17:54,850
should apply<font color="#E5E5E5"> so can we talk</font><font color="#CCCCCC"> about some</font>

418
00:17:52,310 --> 00:17:57,260
<font color="#E5E5E5">of them yes</font><font color="#CCCCCC"> so there</font><font color="#E5E5E5"> are also some</font>

419
00:17:54,850 --> 00:17:58,909
solutions<font color="#E5E5E5"> that maybe do not work the</font>

420
00:17:57,260 --> 00:18:00,740
<font color="#CCCCCC">first that comes in</font><font color="#E5E5E5"> mind when we</font><font color="#CCCCCC"> look</font><font color="#E5E5E5"> at</font>

421
00:17:58,910 --> 00:18:03,170
the earlier slides<font color="#CCCCCC"> we just use seal</font>

422
00:18:00,740 --> 00:18:05,480
<font color="#CCCCCC">flush to kick something</font><font color="#E5E5E5"> out of the cache</font>

423
00:18:03,170 --> 00:18:07,910
<font color="#CCCCCC">but</font><font color="#E5E5E5"> yeah</font><font color="#CCCCCC"> just forbids dissing structure</font>

424
00:18:05,480 --> 00:18:10,160
<font color="#E5E5E5">right we can use</font><font color="#CCCCCC"> Rohan right</font><font color="#E5E5E5"> yes instead</font>

425
00:18:07,910 --> 00:18:12,920
the<font color="#E5E5E5"> election approach where we don't</font>

426
00:18:10,160 --> 00:18:13,580
need<font color="#E5E5E5"> CL flush and it works just as</font><font color="#CCCCCC"> well</font>

427
00:18:12,920 --> 00:18:16,850
<font color="#E5E5E5">right</font>

428
00:18:13,580 --> 00:18:18,860
<font color="#CCCCCC">oh</font><font color="#E5E5E5"> you also said that during the</font><font color="#CCCCCC"> refresh</font>

429
00:18:16,850 --> 00:18:21,080
<font color="#CCCCCC">interval we can trigger the bit flip so</font>

430
00:18:18,860 --> 00:18:23,149
we just increase the refresh rate so

431
00:18:21,080 --> 00:18:25,070
<font color="#E5E5E5">that the content gets updated</font><font color="#CCCCCC"> early</font><font color="#E5E5E5"> yeah</font>

432
00:18:23,150 --> 00:18:27,680
<font color="#E5E5E5">so you cannot induce a bit flip yeah but</font>

433
00:18:25,070 --> 00:18:30,139
that also<font color="#E5E5E5"> does not work in 2014</font><font color="#CCCCCC"> Kamath</font><font color="#E5E5E5"> I</font>

434
00:18:27,680 --> 00:18:31,490
already showed that<font color="#E5E5E5"> on some modules they</font>

435
00:18:30,140 --> 00:18:34,040
have they<font color="#E5E5E5"> would have to increase the</font>

436
00:18:31,490 --> 00:18:36,530
refresh rate by<font color="#CCCCCC"> factor seven and this</font>

437
00:18:34,040 --> 00:18:38,690
would significantly reduce<font color="#E5E5E5"> the</font>

438
00:18:36,530 --> 00:18:42,220
performance<font color="#CCCCCC"> of the</font><font color="#E5E5E5"> DRAM modules</font><font color="#CCCCCC"> so this</font>

439
00:18:38,690 --> 00:18:45,650
is not also<font color="#E5E5E5"> not really</font><font color="#CCCCCC"> a good solution</font>

440
00:18:42,220 --> 00:18:49,630
<font color="#E5E5E5">there was an American implemented by</font>

441
00:18:45,650 --> 00:18:51,770
most or by<font color="#E5E5E5"> many BIOS vendors where they</font>

442
00:18:49,630 --> 00:18:55,460
doubled the refresh rate but this

443
00:18:51,770 --> 00:18:57,770
effectively brings<font color="#E5E5E5"> little I will try</font><font color="#CCCCCC"> to</font>

444
00:18:55,460 --> 00:19:00,440
have it implement it on on<font color="#CCCCCC"> Hardware</font>

445
00:18:57,770 --> 00:19:02,810
level<font color="#E5E5E5"> like use error correcting codes in</font>

446
00:19:00,440 --> 00:19:04,160
<font color="#E5E5E5">theorem ECC Ram</font><font color="#CCCCCC"> that should be a lot</font>

447
00:19:02,810 --> 00:19:06,320
better<font color="#CCCCCC"> because they</font><font color="#E5E5E5"> are designed</font><font color="#CCCCCC"> to</font>

448
00:19:04,160 --> 00:19:08,900
prevent exactly<font color="#E5E5E5"> that that's correct</font>

449
00:19:06,320 --> 00:19:11,240
but there is no standard<font color="#E5E5E5"> for event</font>

450
00:19:08,900 --> 00:19:16,100
reporting for ECC memory<font color="#E5E5E5"> and that's</font>

451
00:19:11,240 --> 00:19:19,220
quite bad because there was in 2016 a

452
00:19:16,100 --> 00:19:21,320
study<font color="#CCCCCC"> that found that</font><font color="#E5E5E5"> some servers count</font>

453
00:19:19,220 --> 00:19:23,570
the ECC<font color="#CCCCCC"> Eros and only if they reach a</font>

454
00:19:21,320 --> 00:19:26,210
certain<font color="#E5E5E5"> threshold the errors would be</font>

455
00:19:23,570 --> 00:19:27,850
reported<font color="#CCCCCC"> for instance</font><font color="#E5E5E5"> 100 bit flips per</font>

456
00:19:26,210 --> 00:19:30,680
hour<font color="#E5E5E5"> only if it goes beyond that</font>

457
00:19:27,850 --> 00:19:34,490
<font color="#E5E5E5">threshold</font><font color="#CCCCCC"> they would be reported</font><font color="#E5E5E5"> and in</font>

458
00:19:30,680 --> 00:19:36,800
some cases even the OS was never

459
00:19:34,490 --> 00:19:38,900
informed about errors<font color="#E5E5E5"> not even on</font>

460
00:19:36,800 --> 00:19:40,700
corrected errors and this<font color="#E5E5E5"> is quite bad</font>

461
00:19:38,900 --> 00:19:45,890
if the system<font color="#E5E5E5"> continues running</font><font color="#CCCCCC"> although</font>

462
00:19:40,700 --> 00:19:48,130
it has ECC memory<font color="#E5E5E5"> so there are also some</font>

463
00:19:45,890 --> 00:19:51,170
other solutions<font color="#CCCCCC"> that we have in hardware</font>

464
00:19:48,130 --> 00:19:53,330
so the<font color="#E5E5E5"> original ideas were proposed in</font>

465
00:19:51,170 --> 00:19:55,700
the<font color="#CCCCCC"> commit all paper that showed that we</font>

466
00:19:53,330 --> 00:19:57,590
have those bit flips so an easy approach

467
00:19:55,700 --> 00:19:59,990
is we<font color="#E5E5E5"> just make better tear em chips</font>

468
00:19:57,590 --> 00:20:03,350
that<font color="#CCCCCC"> are not prone to bit flips at all</font>

469
00:19:59,990 --> 00:20:05,540
or we use ECC like Daniel described now

470
00:20:03,350 --> 00:20:07,610
<font color="#E5E5E5">or</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> just increase the refresh rate but</font>

471
00:20:05,540 --> 00:20:11,240
all of that is not sufficient<font color="#E5E5E5"> ECC</font><font color="#CCCCCC"> is a</font>

472
00:20:07,610 --> 00:20:13,340
good way<font color="#E5E5E5"> to go in addition we could</font>

473
00:20:11,240 --> 00:20:15,530
after<font color="#E5E5E5"> manufacture and check if there are</font>

474
00:20:13,340 --> 00:20:17,899
any<font color="#CCCCCC"> cells</font><font color="#E5E5E5"> that are vulnerable</font><font color="#CCCCCC"> to the</font>

475
00:20:15,530 --> 00:20:20,149
roham attack and try<font color="#CCCCCC"> to remap them or</font>

476
00:20:17,900 --> 00:20:23,060
retire them so that they<font color="#CCCCCC"> are not used or</font>

477
00:20:20,150 --> 00:20:26,300
we can identify<font color="#CCCCCC"> Hemet</font><font color="#E5E5E5"> rows at runtime</font>

478
00:20:23,060 --> 00:20:29,929
<font color="#E5E5E5">and try to refresh them automatically so</font>

479
00:20:26,300 --> 00:20:32,120
that<font color="#CCCCCC"> you cannot induce any bit</font><font color="#E5E5E5"> but all</font>

480
00:20:29,930 --> 00:20:34,370
of those are<font color="#CCCCCC"> in Hardware</font><font color="#E5E5E5"> they're either</font>

481
00:20:32,120 --> 00:20:36,679
expensive there's a performance overhead

482
00:20:34,370 --> 00:20:38,629
that comes with them<font color="#CCCCCC"> also we increase</font>

483
00:20:36,680 --> 00:20:40,430
the<font color="#E5E5E5"> power consumption</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> for instance</font>

484
00:20:38,630 --> 00:20:42,170
on mobile devices<font color="#E5E5E5"> we do not want to do</font>

485
00:20:40,430 --> 00:20:44,450
<font color="#E5E5E5">that because we want</font><font color="#CCCCCC"> our phones to last</font>

486
00:20:42,170 --> 00:20:45,770
long<font color="#E5E5E5"> but</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> the only proposal</font>

487
00:20:44,450 --> 00:20:48,920
still there were a lot of<font color="#E5E5E5"> proposals</font>

488
00:20:45,770 --> 00:20:51,620
afterwards<font color="#E5E5E5"> researchers trying to prevent</font>

489
00:20:48,920 --> 00:20:53,300
<font color="#E5E5E5">the</font><font color="#CCCCCC"> Rehema effect for example the</font><font color="#E5E5E5"> power</font>

490
00:20:51,620 --> 00:20:57,739
<font color="#E5E5E5">the probabilistic adjacent</font><font color="#CCCCCC"> row</font>

491
00:20:53,300 --> 00:21:00,320
activation where this<font color="#E5E5E5"> was also</font><font color="#CCCCCC"> in the</font>

492
00:20:57,740 --> 00:21:02,690
<font color="#CCCCCC">original paper still so every time a row</font>

493
00:21:00,320 --> 00:21:05,720
is closed<font color="#E5E5E5"> we open</font><font color="#CCCCCC"> with a certain</font>

494
00:21:02,690 --> 00:21:08,150
probability<font color="#E5E5E5"> and adjacent row so if we</font>

495
00:21:05,720 --> 00:21:10,760
<font color="#E5E5E5">have a and we have</font><font color="#CCCCCC"> a lot of row closings</font>

496
00:21:08,150 --> 00:21:13,040
and we refresh the neighboring rows more

497
00:21:10,760 --> 00:21:14,930
often and<font color="#E5E5E5"> that</font><font color="#CCCCCC"> should help us to also</font>

498
00:21:13,040 --> 00:21:17,480
refresh them and prevent<font color="#CCCCCC"> the row hema</font>

499
00:21:14,930 --> 00:21:20,540
effect<font color="#E5E5E5"> this is quite</font><font color="#CCCCCC"> easy to</font><font color="#E5E5E5"> implement</font>

500
00:21:17,480 --> 00:21:23,690
<font color="#E5E5E5">in hardware and doesn't have a huge</font>

501
00:21:20,540 --> 00:21:26,930
overhead and can give<font color="#CCCCCC"> give quite good</font>

502
00:21:23,690 --> 00:21:29,030
<font color="#CCCCCC">result so it's okay but only as long as</font>

503
00:21:26,930 --> 00:21:31,220
<font color="#CCCCCC">we can only</font><font color="#E5E5E5"> induce</font><font color="#CCCCCC"> bit flips in adjacent</font>

504
00:21:29,030 --> 00:21:33,790
rows right if this<font color="#CCCCCC"> yes</font><font color="#E5E5E5"> not true then we</font>

505
00:21:31,220 --> 00:21:37,670
<font color="#E5E5E5">have a problem</font><font color="#CCCCCC"> there was also a similar</font>

506
00:21:33,790 --> 00:21:39,860
technique I would<font color="#CCCCCC"> say it's a bit similar</font>

507
00:21:37,670 --> 00:21:41,660
its target<font color="#E5E5E5"> raw refresh and</font><font color="#CCCCCC"> pewter target</font>

508
00:21:39,860 --> 00:21:43,879
<font color="#CCCCCC">row refresh and</font><font color="#E5E5E5"> this pretty much worked</font>

509
00:21:41,660 --> 00:21:45,980
like this<font color="#E5E5E5"> you hammer to memory locations</font>

510
00:21:43,880 --> 00:21:49,010
<font color="#E5E5E5">to different rows and you</font><font color="#CCCCCC"> have a counter</font>

511
00:21:45,980 --> 00:21:52,610
<font color="#CCCCCC">per row now and</font><font color="#E5E5E5"> this is just incremented</font>

512
00:21:49,010 --> 00:21:55,250
<font color="#CCCCCC">as you access memory locations and if</font>

513
00:21:52,610 --> 00:21:58,699
the counter reaches a certain threshold

514
00:21:55,250 --> 00:22:01,370
<font color="#E5E5E5">the current the corresponding row is</font>

515
00:21:58,700 --> 00:22:05,300
refreshed so you can see it here now

516
00:22:01,370 --> 00:22:06,590
it's refreshed yeah sounds<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> if you</font>

517
00:22:05,300 --> 00:22:08,510
have bit fits in there chasing<font color="#E5E5E5"> throws</font>

518
00:22:06,590 --> 00:22:08,840
but what if the bit flips are somewhere

519
00:22:08,510 --> 00:22:12,320
<font color="#CCCCCC">else</font>

520
00:22:08,840 --> 00:22:13,520
so we tried that<font color="#E5E5E5"> with your are active on</font>

521
00:22:12,320 --> 00:22:15,530
<font color="#E5E5E5">our system</font>

522
00:22:13,520 --> 00:22:17,120
and we<font color="#E5E5E5"> get a lot</font><font color="#CCCCCC"> less bit flips because</font>

523
00:22:15,530 --> 00:22:19,370
<font color="#E5E5E5">we didn't have</font><font color="#CCCCCC"> bid flips in a chase and</font>

524
00:22:17,120 --> 00:22:21,709
rolls anymore<font color="#E5E5E5"> but a few rows apart we</font>

525
00:22:19,370 --> 00:22:22,280
still had<font color="#CCCCCC"> bid flip so that might not be</font>

526
00:22:21,710 --> 00:22:23,720
sufficient

527
00:22:22,280 --> 00:22:25,700
I think the attacker is not<font color="#E5E5E5"> allowed to</font>

528
00:22:23,720 --> 00:22:28,640
<font color="#CCCCCC">do</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> as all</font><font color="#E5E5E5"> of the</font><font color="#CCCCCC"> fred</font><font color="#E5E5E5"> model</font><font color="#CCCCCC"> i guess</font>

529
00:22:25,700 --> 00:22:31,429
but okay let's go for the<font color="#CCCCCC"> note hammer</font>

530
00:22:28,640 --> 00:22:34,210
kernel module<font color="#E5E5E5"> that was an</font><font color="#CCCCCC"> idea from the</font>

531
00:22:31,429 --> 00:22:37,550
<font color="#CCCCCC">Linux kernel mailing list in 2016 and</font>

532
00:22:34,210 --> 00:22:39,700
here the<font color="#CCCCCC"> idea was similar as with TR but</font>

533
00:22:37,550 --> 00:22:42,050
it's purely<font color="#E5E5E5"> in software quite nice so</font>

534
00:22:39,700 --> 00:22:44,210
<font color="#CCCCCC">basically</font><font color="#E5E5E5"> a refresh rate</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> 8</font>

535
00:22:42,050 --> 00:22:46,428
milliseconds would prevent draw him on

536
00:22:44,210 --> 00:22:49,040
most<font color="#CCCCCC"> systems that what we what we</font><font color="#E5E5E5"> heard</font>

537
00:22:46,429 --> 00:22:51,500
before<font color="#E5E5E5"> factor 7 above the current</font>

538
00:22:49,040 --> 00:22:53,840
refresh rate<font color="#CCCCCC"> is fine</font><font color="#E5E5E5"> so factor 8 is also</font>

539
00:22:51,500 --> 00:22:56,990
fine<font color="#E5E5E5"> and we use performance counters to</font>

540
00:22:53,840 --> 00:23:00,740
measure the number<font color="#E5E5E5"> of cache misses</font><font color="#CCCCCC"> / 64</font>

541
00:22:56,990 --> 00:23:04,429
millisecond interval and if this reaches

542
00:23:00,740 --> 00:23:07,970
a<font color="#E5E5E5"> certain value namely 1/8 of</font><font color="#CCCCCC"> the</font>

543
00:23:04,429 --> 00:23:09,950
maximum then we wait for a<font color="#E5E5E5"> refresh and</font>

544
00:23:07,970 --> 00:23:11,960
block<font color="#E5E5E5"> any operation we don't schedule</font>

545
00:23:09,950 --> 00:23:14,179
anything on the processor<font color="#E5E5E5"> anymore until</font>

546
00:23:11,960 --> 00:23:16,640
<font color="#CCCCCC">the 64 milliseconds</font><font color="#E5E5E5"> password basically</font>

547
00:23:14,179 --> 00:23:18,770
<font color="#CCCCCC">halt the whole system</font><font color="#E5E5E5"> yes</font><font color="#CCCCCC"> okay that</font>

548
00:23:16,640 --> 00:23:21,350
sounds<font color="#E5E5E5"> good right but the problem</font><font color="#CCCCCC"> is now</font>

549
00:23:18,770 --> 00:23:24,410
if we have<font color="#E5E5E5"> different excesses here then</font>

550
00:23:21,350 --> 00:23:25,909
we also reach this threshold because<font color="#E5E5E5"> the</font>

551
00:23:24,410 --> 00:23:27,200
<font color="#E5E5E5">performance counter cannot really</font>

552
00:23:25,910 --> 00:23:30,260
distinguish between all<font color="#E5E5E5"> the different</font>

553
00:23:27,200 --> 00:23:32,809
<font color="#CCCCCC">rows and then again we wait for a</font>

554
00:23:30,260 --> 00:23:34,940
refresh<font color="#E5E5E5"> although this was not necessary</font>

555
00:23:32,809 --> 00:23:38,330
at all<font color="#CCCCCC"> so have you thought</font><font color="#E5E5E5"> about the</font>

556
00:23:34,940 --> 00:23:40,010
performance this sounds<font color="#E5E5E5"> pretty stupid to</font>

557
00:23:38,330 --> 00:23:43,460
me yeah you hold the<font color="#E5E5E5"> system the entire</font>

558
00:23:40,010 --> 00:23:46,340
time yeah and in<font color="#E5E5E5"> addition what we've</font>

559
00:23:43,460 --> 00:23:49,130
seen lately<font color="#E5E5E5"> with GPU chrome spawning</font>

560
00:23:46,340 --> 00:23:51,230
unit paper or with the remote<font color="#CCCCCC"> quorum</font>

561
00:23:49,130 --> 00:23:53,960
attacks either fro<font color="#CCCCCC"> hema using a DMA</font>

562
00:23:51,230 --> 00:23:56,300
based<font color="#CCCCCC"> network accounts or our net hammer</font>

563
00:23:53,960 --> 00:23:59,000
paper which uses commodity<font color="#CCCCCC"> Hardware to</font>

564
00:23:56,300 --> 00:24:01,820
induce remote bit flips<font color="#E5E5E5"> we do not care</font>

565
00:23:59,000 --> 00:24:04,790
about<font color="#E5E5E5"> that at all so maybe we don't want</font>

566
00:24:01,820 --> 00:24:06,020
to dynamically<font color="#E5E5E5"> see the row</font><font color="#CCCCCC"> am i attack</font>

567
00:24:04,790 --> 00:24:08,659
and then stop<font color="#E5E5E5"> it</font>

568
00:24:06,020 --> 00:24:10,730
but we want to do some binary analysis

569
00:24:08,660 --> 00:24:12,710
there<font color="#E5E5E5"> the exploits we do the same thing</font>

570
00:24:10,730 --> 00:24:14,990
as<font color="#E5E5E5"> antivirus programs we analyze the</font>

571
00:24:12,710 --> 00:24:16,280
binary and if they have suspicious code

572
00:24:14,990 --> 00:24:19,070
in there like this<font color="#E5E5E5"> your Flash</font>

573
00:24:16,280 --> 00:24:21,830
instruction who uses that<font color="#E5E5E5"> or early</font><font color="#CCCCCC"> dlc</font>

574
00:24:19,070 --> 00:24:23,570
or<font color="#E5E5E5"> fences then we can flag that and</font>

575
00:24:21,830 --> 00:24:26,210
detect the<font color="#E5E5E5"> row hema attack with</font><font color="#CCCCCC"> that so</font>

576
00:24:23,570 --> 00:24:27,750
you you<font color="#CCCCCC"> ask</font><font color="#E5E5E5"> the attacker to compile the</font>

577
00:24:26,210 --> 00:24:30,090
attack with<font color="#CCCCCC"> your comp</font>

578
00:24:27,750 --> 00:24:31,830
so that the attacker<font color="#E5E5E5"> learns you cannot</font>

579
00:24:30,090 --> 00:24:34,679
run this code<font color="#CCCCCC"> I</font><font color="#E5E5E5"> can also do it in an</font>

580
00:24:31,830 --> 00:24:36,540
anti-virus program<font color="#CCCCCC"> okay okay</font><font color="#E5E5E5"> but I just</font>

581
00:24:34,680 --> 00:24:38,130
said you also<font color="#E5E5E5"> have those remote attacks</font>

582
00:24:36,540 --> 00:24:44,070
so I don't care<font color="#CCCCCC"> about the code on your</font>

583
00:24:38,130 --> 00:24:45,690
<font color="#E5E5E5">system at all okay then maybe then we</font>

584
00:24:44,070 --> 00:24:47,850
<font color="#E5E5E5">might want</font><font color="#CCCCCC"> to go</font><font color="#E5E5E5"> back to the performance</font>

585
00:24:45,690 --> 00:24:50,430
counters<font color="#E5E5E5"> and detect the row</font><font color="#CCCCCC"> hema attack</font>

586
00:24:47,850 --> 00:24:53,879
and if we have a lot of<font color="#E5E5E5"> cache misses</font>

587
00:24:50,430 --> 00:24:56,010
<font color="#E5E5E5">then we activate neighbor rows so</font>

588
00:24:53,880 --> 00:24:59,790
similar thing<font color="#CCCCCC"> is</font><font color="#E5E5E5"> stuff in</font><font color="#CCCCCC"> Hardware part</font>

589
00:24:56,010 --> 00:25:02,670
in<font color="#E5E5E5"> software</font><font color="#CCCCCC"> ok this</font><font color="#E5E5E5"> was also from 2016</font>

590
00:24:59,790 --> 00:25:05,070
but what if performance<font color="#E5E5E5"> counters do not</font>

591
00:25:02,670 --> 00:25:07,430
work why<font color="#CCCCCC"> would they not work because we</font>

592
00:25:05,070 --> 00:25:10,230
run our attack in SGX and STX

593
00:25:07,430 --> 00:25:12,090
<font color="#E5E5E5">performance counters are not reflected</font>

594
00:25:10,230 --> 00:25:13,740
in<font color="#CCCCCC"> the normal world performance</font><font color="#E5E5E5"> counters</font>

595
00:25:12,090 --> 00:25:16,230
<font color="#CCCCCC">but</font><font color="#E5E5E5"> you shouldn't do bad things nest</font>

596
00:25:13,740 --> 00:25:17,820
checks yeah<font color="#E5E5E5"> it's also not</font><font color="#CCCCCC"> in the</font><font color="#E5E5E5"> fret</font>

597
00:25:16,230 --> 00:25:21,060
<font color="#CCCCCC">you're not allowed to do this right yeah</font>

598
00:25:17,820 --> 00:25:24,000
<font color="#CCCCCC">ok so</font><font color="#E5E5E5"> we come</font><font color="#CCCCCC"> back</font><font color="#E5E5E5"> to some</font><font color="#CCCCCC"> Hardware</font>

599
00:25:21,060 --> 00:25:26,460
ideas that we have<font color="#E5E5E5"> so what if during</font>

600
00:25:24,000 --> 00:25:28,410
boot with scan the entire<font color="#E5E5E5"> memory check</font>

601
00:25:26,460 --> 00:25:31,020
those locations where<font color="#CCCCCC"> we can induce bit</font>

602
00:25:28,410 --> 00:25:33,240
flips<font color="#E5E5E5"> and just block them so that you</font>

603
00:25:31,020 --> 00:25:35,550
cannot use them at all<font color="#CCCCCC"> yeah this was</font>

604
00:25:33,240 --> 00:25:38,220
proposed in 2017 yeah<font color="#CCCCCC"> they're</font><font color="#E5E5E5"> also</font>

605
00:25:35,550 --> 00:25:40,200
<font color="#E5E5E5">proposed to isolate security domains so</font>

606
00:25:38,220 --> 00:25:42,420
the kernel is not<font color="#E5E5E5"> next to use</font><font color="#CCCCCC"> the space</font>

607
00:25:40,200 --> 00:25:44,820
so we don't have any page tables in our

608
00:25:42,420 --> 00:25:47,010
reach for the<font color="#E5E5E5"> romantic mm-hmm so this</font>

609
00:25:44,820 --> 00:25:50,370
<font color="#E5E5E5">will look like</font><font color="#CCCCCC"> this so either we disable</font>

610
00:25:47,010 --> 00:25:53,490
memory or we leave gaps between the

611
00:25:50,370 --> 00:25:56,280
different<font color="#CCCCCC"> security domains right</font><font color="#E5E5E5"> the</font>

612
00:25:53,490 --> 00:25:59,220
problem here is if<font color="#CCCCCC"> we use big head there</font>

613
00:25:56,280 --> 00:26:01,470
<font color="#E5E5E5">are multiple studies</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> find that 95</font>

614
00:25:59,220 --> 00:26:03,540
percent<font color="#CCCCCC"> or more of your</font><font color="#E5E5E5"> drm might be</font>

615
00:26:01,470 --> 00:26:05,910
blocked and unusable<font color="#CCCCCC"> so this is</font><font color="#E5E5E5"> not</font>

616
00:26:03,540 --> 00:26:10,590
<font color="#E5E5E5">really practical a memory overhead of 95</font>

617
00:26:05,910 --> 00:26:13,110
<font color="#E5E5E5">percent</font><font color="#CCCCCC"> I don't know</font><font color="#E5E5E5"> why do i why do I</font>

618
00:26:10,590 --> 00:26:17,250
pay so much<font color="#CCCCCC"> for my memory if I can't use</font>

619
00:26:13,110 --> 00:26:20,189
95<font color="#E5E5E5"> percent that sounds odd</font><font color="#CCCCCC"> and also for</font>

620
00:26:17,250 --> 00:26:22,020
G<font color="#CCCCCC"> ked what about pages that are shared</font>

621
00:26:20,190 --> 00:26:23,520
between different<font color="#E5E5E5"> security domains</font>

622
00:26:22,020 --> 00:26:24,389
shared libraries are<font color="#E5E5E5"> there no shared</font>

623
00:26:23,520 --> 00:26:27,629
libraries anymore

624
00:26:24,390 --> 00:26:29,910
what about non kernel pages because<font color="#CCCCCC"> G</font>

625
00:26:27,630 --> 00:26:31,200
<font color="#CCCCCC">cap was mostly about kernel to user</font>

626
00:26:29,910 --> 00:26:34,890
space isolation

627
00:26:31,200 --> 00:26:37,740
what about non kernel pages<font color="#E5E5E5"> so this is</font>

628
00:26:34,890 --> 00:26:40,440
all not covered here<font color="#CCCCCC"> how far do you move</font>

629
00:26:37,740 --> 00:26:41,290
them<font color="#E5E5E5"> apart</font><font color="#CCCCCC"> anyways yes</font><font color="#E5E5E5"> because</font><font color="#CCCCCC"> we don't</font>

630
00:26:40,440 --> 00:26:42,750
know what the<font color="#E5E5E5"> maximum</font>

631
00:26:41,290 --> 00:26:45,220
is the maximum distance<font color="#E5E5E5"> between</font>

632
00:26:42,750 --> 00:26:48,790
<font color="#E5E5E5">hammering location and</font><font color="#CCCCCC"> bid</font><font color="#E5E5E5"> Phillip</font>

633
00:26:45,220 --> 00:26:53,620
location<font color="#E5E5E5"> we observe cases of more than a</font>

634
00:26:48,790 --> 00:26:56,110
<font color="#E5E5E5">dros apart so this is easily above</font><font color="#CCCCCC"> one</font>

635
00:26:53,620 --> 00:26:58,899
or<font color="#CCCCCC"> two megabytes it</font><font color="#E5E5E5"> was a similar space</font>

636
00:26:56,110 --> 00:27:01,179
<font color="#E5E5E5">approach with isolating EMA buffers in</font>

637
00:26:58,900 --> 00:27:01,870
physical memory<font color="#E5E5E5"> so that</font><font color="#CCCCCC"> we can't hammer</font>

638
00:27:01,180 --> 00:27:04,540
<font color="#CCCCCC">with them</font>

639
00:27:01,870 --> 00:27:08,459
but again we have<font color="#CCCCCC"> the same problem right</font>

640
00:27:04,540 --> 00:27:12,310
yeah and<font color="#E5E5E5"> moved him apart</font><font color="#CCCCCC"> how far sorry</font>

641
00:27:08,460 --> 00:27:14,170
<font color="#CCCCCC">how far apart should we go then</font><font color="#E5E5E5"> then we</font>

642
00:27:12,310 --> 00:27:18,340
also looked at performance counters we

643
00:27:14,170 --> 00:27:23,830
did that in 2016<font color="#CCCCCC"> unless</font><font color="#E5E5E5"> fork</font><font color="#CCCCCC"> together</font>

644
00:27:18,340 --> 00:27:25,810
<font color="#CCCCCC">with Herod looked at that in 2015</font><font color="#E5E5E5"> there</font>

645
00:27:23,830 --> 00:27:31,360
<font color="#E5E5E5">was also</font><font color="#CCCCCC"> other</font><font color="#E5E5E5"> another paper by Matthias</font>

646
00:27:25,810 --> 00:27:33,220
pie in 2016 and<font color="#E5E5E5"> you can observe that</font>

647
00:27:31,360 --> 00:27:35,530
<font color="#CCCCCC">there is a row hammer attack going</font><font color="#E5E5E5"> on</font>

648
00:27:33,220 --> 00:27:37,960
but it's very difficult<font color="#CCCCCC"> to find</font>

649
00:27:35,530 --> 00:27:40,720
<font color="#CCCCCC">something which has no false positives</font>

650
00:27:37,960 --> 00:27:43,960
<font color="#E5E5E5">and false positives are really bad if</font>

651
00:27:40,720 --> 00:27:45,760
it's about its<font color="#E5E5E5"> detection of attacks but</font>

652
00:27:43,960 --> 00:27:47,500
what if you have the case<font color="#E5E5E5"> that your</font>

653
00:27:45,760 --> 00:27:49,210
<font color="#E5E5E5">performance counters do not get updated</font>

654
00:27:47,500 --> 00:27:50,800
<font color="#E5E5E5">at all yes</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> gets again a problem</font>

655
00:27:49,210 --> 00:27:52,390
<font color="#CCCCCC">because you put the attack in an</font><font color="#E5E5E5"> S</font>

656
00:27:50,800 --> 00:27:54,159
<font color="#E5E5E5">Jackson glaive and the performance</font>

657
00:27:52,390 --> 00:27:56,080
counters are not<font color="#E5E5E5"> updated so I can hide</font>

658
00:27:54,160 --> 00:27:58,000
the attack<font color="#CCCCCC"> on the counter measure yeah</font>

659
00:27:56,080 --> 00:27:59,409
so so far we have<font color="#E5E5E5"> seen a lot</font><font color="#CCCCCC"> of counter</font>

660
00:27:58,000 --> 00:28:01,540
measures that<font color="#E5E5E5"> we are proposed some of</font>

661
00:27:59,410 --> 00:28:04,060
them are existing in<font color="#CCCCCC"> real world</font>

662
00:28:01,540 --> 00:28:07,649
applications<font color="#E5E5E5"> some are more theoretic and</font>

663
00:28:04,060 --> 00:28:09,970
they all use different<font color="#E5E5E5"> kinds of</font>

664
00:28:07,650 --> 00:28:13,570
techniques to<font color="#E5E5E5"> detect</font><font color="#CCCCCC"> either by analysis</font>

665
00:28:09,970 --> 00:28:16,030
static or dynamic<font color="#E5E5E5"> or in Hardware stuff</font>

666
00:28:13,570 --> 00:28:19,570
or software<font color="#E5E5E5"> countermeasures to</font><font color="#CCCCCC"> try to</font>

667
00:28:16,030 --> 00:28:21,820
prevent or detect so we have a huge

668
00:28:19,570 --> 00:28:24,399
range<font color="#E5E5E5"> of all those</font><font color="#CCCCCC"> countermeasures to</font>

669
00:28:21,820 --> 00:28:28,240
<font color="#E5E5E5">try to prevent the</font><font color="#CCCCCC"> Rehema attack so we</font>

670
00:28:24,400 --> 00:28:31,420
<font color="#E5E5E5">are safe yeah but they all assume the</font>

671
00:28:28,240 --> 00:28:35,920
draw hammer works the way we<font color="#CCCCCC"> thought it</font>

672
00:28:31,420 --> 00:28:38,790
works by hammering two or more rows so

673
00:28:35,920 --> 00:28:45,070
we have what if we have<font color="#E5E5E5"> something else</font>

674
00:28:38,790 --> 00:28:47,889
<font color="#E5E5E5">yeah actually</font><font color="#CCCCCC"> so there</font><font color="#E5E5E5"> are two different</font>

675
00:28:45,070 --> 00:28:49,149
hammering techniques we know that<font color="#E5E5E5"> there</font>

676
00:28:47,890 --> 00:28:51,160
<font color="#CCCCCC">are two different hammering hammering</font>

677
00:28:49,150 --> 00:28:54,250
techniques<font color="#E5E5E5"> the first is you have</font><font color="#CCCCCC"> a one</font>

678
00:28:51,160 --> 00:28:54,940
row and other rows<font color="#E5E5E5"> in the same Bank and</font>

679
00:28:54,250 --> 00:28:56,590
then<font color="#E5E5E5"> you will get</font>

680
00:28:54,940 --> 00:28:59,770
<font color="#CCCCCC">trip somewhere</font><font color="#E5E5E5"> the second is you hammer</font>

681
00:28:56,590 --> 00:29:02,260
<font color="#E5E5E5">to different roles in the same Bank yeah</font>

682
00:28:59,770 --> 00:29:04,840
I know that's all<font color="#CCCCCC"> I</font><font color="#E5E5E5"> already did that</font><font color="#CCCCCC"> so</font>

683
00:29:02,260 --> 00:29:06,670
I choose one row<font color="#E5E5E5"> and then I activate it</font>

684
00:29:04,840 --> 00:29:08,439
and another random<font color="#E5E5E5"> row and again</font><font color="#CCCCCC"> this</font>

685
00:29:06,670 --> 00:29:10,600
row and<font color="#E5E5E5"> the random row and this row and</font>

686
00:29:08,440 --> 00:29:13,540
at some point I get a bit flip next to

687
00:29:10,600 --> 00:29:15,129
the one row<font color="#CCCCCC"> I activate most often yeah</font>

688
00:29:13,540 --> 00:29:17,320
<font color="#CCCCCC">but we can do much better than</font><font color="#E5E5E5"> that</font>

689
00:29:15,130 --> 00:29:20,140
<font color="#CCCCCC">because instead of hammering just one</font>

690
00:29:17,320 --> 00:29:23,560
<font color="#CCCCCC">world we sandwich our target row and</font>

691
00:29:20,140 --> 00:29:25,750
<font color="#CCCCCC">hema</font><font color="#E5E5E5"> to neighboring rows and we get bit</font>

692
00:29:23,560 --> 00:29:30,429
flips much more reliable and<font color="#E5E5E5"> much faster</font>

693
00:29:25,750 --> 00:29:32,980
<font color="#E5E5E5">yeah hammering two rows okay we will go</font>

694
00:29:30,430 --> 00:29:34,450
for<font color="#CCCCCC"> one location hammering there are</font>

695
00:29:32,980 --> 00:29:36,550
actually three<font color="#CCCCCC"> different hammering</font>

696
00:29:34,450 --> 00:29:39,040
techniques now we can hammer<font color="#E5E5E5"> only one</font>

697
00:29:36,550 --> 00:29:41,320
row next to victim row and it works like

698
00:29:39,040 --> 00:29:43,810
that<font color="#CCCCCC"> we</font><font color="#E5E5E5"> access one row we access it</font>

699
00:29:41,320 --> 00:29:47,500
again<font color="#E5E5E5"> we access it again and it works</font>

700
00:29:43,810 --> 00:29:50,290
great<font color="#CCCCCC"> bit flips so we have a demo here</font>

701
00:29:47,500 --> 00:29:55,000
this is one location hammering<font color="#CCCCCC"> on a</font>

702
00:29:50,290 --> 00:29:57,070
<font color="#E5E5E5">skylake i7 system and you can see</font><font color="#CCCCCC"> we are</font>

703
00:29:55,000 --> 00:29:58,810
hammering<font color="#E5E5E5"> a bit here and then after</font><font color="#CCCCCC"> a</font>

704
00:29:57,070 --> 00:30:01,750
while<font color="#CCCCCC"> we are</font><font color="#E5E5E5"> scanning for bit flips and</font>

705
00:29:58,810 --> 00:30:04,510
<font color="#CCCCCC">oh a lot</font><font color="#E5E5E5"> of this you know if ddr4 yeah</font>

706
00:30:01,750 --> 00:30:05,950
<font color="#CCCCCC">that's</font><font color="#E5E5E5"> video</font><font color="#CCCCCC"> 4 and with TRR</font><font color="#E5E5E5"> no that's</font>

707
00:30:04,510 --> 00:30:08,260
without<font color="#E5E5E5"> the tear out</font><font color="#CCCCCC"> your are yeah</font>

708
00:30:05,950 --> 00:30:11,830
without yeah<font color="#CCCCCC"> we still</font><font color="#E5E5E5"> get a lot of lips</font>

709
00:30:08,260 --> 00:30:13,660
<font color="#E5E5E5">just by accessing</font><font color="#CCCCCC"> one senior oh</font><font color="#E5E5E5"> why does</font>

710
00:30:11,830 --> 00:30:15,189
that work<font color="#E5E5E5"> yeah it doesn't make any</font><font color="#CCCCCC"> sense</font>

711
00:30:13,660 --> 00:30:17,890
because<font color="#E5E5E5"> as we said we have the row</font>

712
00:30:15,190 --> 00:30:20,500
buffer which serves as a cache<font color="#E5E5E5"> but in</font>

713
00:30:17,890 --> 00:30:22,450
addition<font color="#E5E5E5"> what</font><font color="#CCCCCC"> we have so-called memory</font>

714
00:30:20,500 --> 00:30:24,430
controller policies because at some

715
00:30:22,450 --> 00:30:26,530
<font color="#CCCCCC">point the controller needs</font><font color="#E5E5E5"> to decide if</font>

716
00:30:24,430 --> 00:30:28,990
it needs to<font color="#E5E5E5"> close the row or keep it</font>

717
00:30:26,530 --> 00:30:33,250
open<font color="#CCCCCC"> so the open page policy says we</font>

718
00:30:28,990 --> 00:30:35,650
keep the<font color="#CCCCCC"> role open and buffered yeah</font><font color="#E5E5E5"> so</font>

719
00:30:33,250 --> 00:30:38,230
that means<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> will have a low</font>

720
00:30:35,650 --> 00:30:40,480
<font color="#CCCCCC">latency for subsequent</font><font color="#E5E5E5"> accesses to the</font>

721
00:30:38,230 --> 00:30:42,580
<font color="#E5E5E5">same row and the high latency for</font>

722
00:30:40,480 --> 00:30:43,840
<font color="#CCCCCC">excesses to other rows right that was</font>

723
00:30:42,580 --> 00:30:46,300
<font color="#E5E5E5">the case</font><font color="#CCCCCC"> that we observed in the</font>

724
00:30:43,840 --> 00:30:48,129
beginning yes<font color="#E5E5E5"> yes we also have the</font>

725
00:30:46,300 --> 00:30:50,830
<font color="#CCCCCC">closed page policy where we just</font>

726
00:30:48,130 --> 00:30:53,500
immediately<font color="#CCCCCC"> close a row and prepare to</font>

727
00:30:50,830 --> 00:30:56,320
<font color="#CCCCCC">open</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> next world ok this sounds like</font>

728
00:30:53,500 --> 00:30:59,920
<font color="#E5E5E5">it would have a medium latency for XSS</font>

729
00:30:56,320 --> 00:31:02,500
to any<font color="#CCCCCC"> role right and</font><font color="#E5E5E5"> why do why would</font>

730
00:30:59,920 --> 00:31:05,350
<font color="#E5E5E5">we use</font><font color="#CCCCCC"> that yet depending</font><font color="#E5E5E5"> on the policy</font>

731
00:31:02,500 --> 00:31:07,690
that we use we<font color="#E5E5E5"> can either save memory</font>

732
00:31:05,350 --> 00:31:08,530
power<font color="#E5E5E5"> consumption or include increase</font>

733
00:31:07,690 --> 00:31:10,330
the<font color="#E5E5E5"> performance</font>

734
00:31:08,530 --> 00:31:12,790
the<font color="#E5E5E5"> Ovilus system</font><font color="#CCCCCC"> so we also have</font>

735
00:31:10,330 --> 00:31:15,040
adaptive policies that change depending

736
00:31:12,790 --> 00:31:17,800
<font color="#E5E5E5">on the</font><font color="#CCCCCC"> usage patterns</font><font color="#E5E5E5"> in the</font><font color="#CCCCCC"> DRM and</font>

737
00:31:15,040 --> 00:31:21,550
<font color="#E5E5E5">particularly on multi-core systems the</font>

738
00:31:17,800 --> 00:31:23,440
performance of<font color="#E5E5E5"> closed draw policies or</font>

739
00:31:21,550 --> 00:31:26,290
adaptive policies is much better<font color="#E5E5E5"> so</font>

740
00:31:23,440 --> 00:31:28,180
where<font color="#E5E5E5"> can we find which policy now we</font>

741
00:31:26,290 --> 00:31:30,490
can test<font color="#E5E5E5"> that we can run a side channel</font>

742
00:31:28,180 --> 00:31:33,460
attack again and<font color="#E5E5E5"> measure which policy is</font>

743
00:31:30,490 --> 00:31:36,220
used but first to sum it up<font color="#E5E5E5"> when we have</font>

744
00:31:33,460 --> 00:31:38,470
a policy<font color="#CCCCCC"> that preemptively closes a row</font>

745
00:31:36,220 --> 00:31:41,980
<font color="#CCCCCC">this</font><font color="#E5E5E5"> would</font><font color="#CCCCCC"> allow one location hammering</font>

746
00:31:38,470 --> 00:31:44,650
<font color="#E5E5E5">and we found</font><font color="#CCCCCC"> closed page policies mainly</font>

747
00:31:41,980 --> 00:31:47,800
on desktop computers<font color="#CCCCCC"> and on</font><font color="#E5E5E5"> mobile</font>

748
00:31:44,650 --> 00:31:50,050
devices<font color="#E5E5E5"> they seem to use in the open</font>

749
00:31:47,800 --> 00:31:51,580
page policy most<font color="#E5E5E5"> of the time so</font><font color="#CCCCCC"> the</font>

750
00:31:50,050 --> 00:31:52,990
question then<font color="#CCCCCC"> is how</font><font color="#E5E5E5"> well does one</font>

751
00:31:51,580 --> 00:31:55,389
location hammering perform and it

752
00:31:52,990 --> 00:31:57,940
performs worse than double-sided of

753
00:31:55,390 --> 00:32:00,190
course<font color="#CCCCCC"> double-sided is the best it</font>

754
00:31:57,940 --> 00:32:03,760
performs worse than single sided<font color="#E5E5E5"> but</font>

755
00:32:00,190 --> 00:32:06,400
still<font color="#E5E5E5"> we get a very nice distribution of</font>

756
00:32:03,760 --> 00:32:09,010
bit flips across the<font color="#E5E5E5"> four kilobyte range</font>

757
00:32:06,400 --> 00:32:11,950
this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> a four kilobyte page</font><font color="#E5E5E5"> split</font><font color="#CCCCCC"> up</font>

758
00:32:09,010 --> 00:32:14,050
into lines every dot there represents

759
00:32:11,950 --> 00:32:16,960
one bit offset<font color="#E5E5E5"> in the four kilobyte page</font>

760
00:32:14,050 --> 00:32:18,460
and the distribution of zero to one

761
00:32:16,960 --> 00:32:20,740
flips and<font color="#E5E5E5"> one to zero flips they are</font>

762
00:32:18,460 --> 00:32:23,590
illustrated in<font color="#E5E5E5"> red and blue you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> see</font>

763
00:32:20,740 --> 00:32:26,740
<font color="#CCCCCC">that they are approximately</font><font color="#E5E5E5"> 50/50 in all</font>

764
00:32:23,590 --> 00:32:30,280
cases and in the case<font color="#E5E5E5"> of double-sided</font>

765
00:32:26,740 --> 00:32:32,200
<font color="#E5E5E5">hammering after eight hours we had</font><font color="#CCCCCC"> 77%</font>

766
00:32:30,280 --> 00:32:34,720
<font color="#CCCCCC">of the bit offsets covered with single</font>

767
00:32:32,200 --> 00:32:38,010
<font color="#CCCCCC">sided a bit more with one location</font><font color="#E5E5E5"> a bit</font>

768
00:32:34,720 --> 00:32:40,690
less half half as many not a bit less

769
00:32:38,010 --> 00:32:42,580
<font color="#E5E5E5">okay but in the end with all those</font>

770
00:32:40,690 --> 00:32:44,800
<font color="#CCCCCC">counter measures that we've seen</font><font color="#E5E5E5"> like</font>

771
00:32:42,580 --> 00:32:47,620
with<font color="#CCCCCC"> P ket</font><font color="#E5E5E5"> and cheek at where we</font>

772
00:32:44,800 --> 00:32:50,139
separate<font color="#CCCCCC"> the memory other security</font>

773
00:32:47,620 --> 00:32:52,750
domains we cannot target<font color="#CCCCCC"> journal pages</font>

774
00:32:50,140 --> 00:32:54,730
anymore<font color="#E5E5E5"> right what else</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> we attack we</font>

775
00:32:52,750 --> 00:32:57,760
could do up code<font color="#E5E5E5"> flipping so this is a</font>

776
00:32:54,730 --> 00:32:59,320
really cool<font color="#E5E5E5"> thing many applications that</font>

777
00:32:57,760 --> 00:33:01,180
<font color="#CCCCCC">we have running</font><font color="#E5E5E5"> on our computer are</font>

778
00:32:59,320 --> 00:33:04,210
performing actions this route<font color="#E5E5E5"> anyway</font>

779
00:33:01,180 --> 00:33:07,450
think for example<font color="#E5E5E5"> the ping command</font><font color="#CCCCCC"> or</font>

780
00:33:04,210 --> 00:33:09,700
<font color="#CCCCCC">the mount command</font><font color="#E5E5E5"> or explicitly the sudo</font>

781
00:33:07,450 --> 00:33:11,050
command<font color="#CCCCCC"> they</font><font color="#E5E5E5"> perform actions as root and</font>

782
00:33:09,700 --> 00:33:14,860
the sudo command

783
00:33:11,050 --> 00:33:18,460
asked for<font color="#CCCCCC"> a password but</font><font color="#E5E5E5"> what if we can</font>

784
00:33:14,860 --> 00:33:21,219
patch<font color="#E5E5E5"> that some way out so we targeted a</font>

785
00:33:18,460 --> 00:33:21,850
<font color="#E5E5E5">pseudo binary and try to flip something</font>

786
00:33:21,220 --> 00:33:24,880
<font color="#E5E5E5">in there</font>

787
00:33:21,850 --> 00:33:27,310
and the<font color="#E5E5E5"> really nice thing</font><font color="#CCCCCC"> about the x86</font>

788
00:33:24,880 --> 00:33:29,410
<font color="#E5E5E5">instructions they are so dense so if you</font>

789
00:33:27,310 --> 00:33:32,470
look at the one instruction<font color="#CCCCCC"> and you flip</font>

790
00:33:29,410 --> 00:33:34,630
bits in this instruction then we in most

791
00:33:32,470 --> 00:33:36,190
cases we get<font color="#E5E5E5"> a different instruction not</font>

792
00:33:34,630 --> 00:33:40,090
<font color="#E5E5E5">an invalid instruction but a different</font>

793
00:33:36,190 --> 00:33:40,510
<font color="#E5E5E5">instruction so we</font><font color="#CCCCCC"> have here a jumbo the</font>

794
00:33:40,090 --> 00:33:42,340
jump

795
00:33:40,510 --> 00:33:44,110
equal for the<font color="#CCCCCC"> password check yeah that's</font>

796
00:33:42,340 --> 00:33:46,540
the trap<font color="#CCCCCC"> equal so we check the password</font>

797
00:33:44,110 --> 00:33:48,459
<font color="#E5E5E5">and then jump equal and we do this stuff</font>

798
00:33:46,540 --> 00:33:50,470
<font color="#E5E5E5">and then your whole</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> CPU window</font><font color="#CCCCCC"> dia</font>

799
00:33:48,460 --> 00:33:51,850
<font color="#E5E5E5">flip there I</font><font color="#CCCCCC"> hold the privilege</font>

800
00:33:50,470 --> 00:33:54,220
<font color="#CCCCCC">instruction but there are more</font>

801
00:33:51,850 --> 00:33:57,040
instructions I can get an X or I push

802
00:33:54,220 --> 00:33:59,980
some prefix for other instructions<font color="#E5E5E5"> champ</font>

803
00:33:57,040 --> 00:34:03,639
lower champ overflow champ below or

804
00:33:59,980 --> 00:34:05,740
equal<font color="#E5E5E5"> or champ not equal so we can</font>

805
00:34:03,640 --> 00:34:07,810
invert the logic so it's really<font color="#E5E5E5"> nice</font>

806
00:34:05,740 --> 00:34:09,639
<font color="#CCCCCC">that all the instructions</font><font color="#E5E5E5"> the champ</font>

807
00:34:07,810 --> 00:34:12,159
instructions are grouped together so

808
00:34:09,639 --> 00:34:13,900
<font color="#E5E5E5">flipping one bit gives you in many cases</font>

809
00:34:12,159 --> 00:34:16,600
a different champ instruction with a

810
00:34:13,900 --> 00:34:17,470
different logic<font color="#E5E5E5"> but that's not all that</font>

811
00:34:16,600 --> 00:34:21,420
<font color="#CCCCCC">we can</font><font color="#E5E5E5"> target</font>

812
00:34:17,469 --> 00:34:25,029
so besides conditional jumps we can also

813
00:34:21,420 --> 00:34:27,520
flip comparisons<font color="#CCCCCC"> in general or operands</font>

814
00:34:25,030 --> 00:34:30,730
<font color="#E5E5E5">in the comparisons we can change which</font>

815
00:34:27,520 --> 00:34:33,040
addresses<font color="#E5E5E5"> we load or store or during the</font>

816
00:34:30,730 --> 00:34:34,540
address calculation we<font color="#CCCCCC"> can change some</font>

817
00:34:33,040 --> 00:34:38,110
constants and then<font color="#E5E5E5"> use another address</font>

818
00:34:34,540 --> 00:34:41,529
<font color="#CCCCCC">if the value did load and by manually</font>

819
00:34:38,110 --> 00:34:43,960
analyzing<font color="#E5E5E5"> one pseudo binary we found</font><font color="#CCCCCC"> 29</font>

820
00:34:41,530 --> 00:34:46,440
possible bit flip locations where<font color="#CCCCCC"> we</font>

821
00:34:43,960 --> 00:34:49,120
could circumvent the password check and

822
00:34:46,440 --> 00:34:51,429
run a command is<font color="#CCCCCC"> route but there are</font>

823
00:34:49,120 --> 00:34:54,850
many more to find yes this was many

824
00:34:51,429 --> 00:34:58,450
other analyzes<font color="#E5E5E5"> okay the question</font><font color="#CCCCCC"> now is</font>

825
00:34:54,850 --> 00:35:01,750
<font color="#E5E5E5">if we want to target virtual pages like</font>

826
00:34:58,450 --> 00:35:03,819
binary pages how how do we get them<font color="#CCCCCC"> to</font>

827
00:35:01,750 --> 00:35:06,700
the<font color="#CCCCCC"> right</font><font color="#E5E5E5"> target physically okay we need</font>

828
00:35:03,820 --> 00:35:08,890
a new technique<font color="#CCCCCC"> for</font><font color="#E5E5E5"> that it's not</font><font color="#CCCCCC"> that</font>

829
00:35:06,700 --> 00:35:12,100
straightforward<font color="#CCCCCC"> because we cannot simply</font>

830
00:35:08,890 --> 00:35:14,080
spray our binary over the memory<font color="#E5E5E5"> binary</font>

831
00:35:12,100 --> 00:35:17,410
<font color="#E5E5E5">is only loaded once in memory and then</font>

832
00:35:14,080 --> 00:35:19,509
<font color="#E5E5E5">it stays in memory and this is</font><font color="#CCCCCC"> in some</font>

833
00:35:17,410 --> 00:35:22,299
cash<font color="#E5E5E5"> in operating system patient page</font>

834
00:35:19,510 --> 00:35:23,890
cache<font color="#CCCCCC"> and only if</font><font color="#E5E5E5"> this page page cache</font>

835
00:35:22,300 --> 00:35:26,590
is<font color="#CCCCCC"> full because</font><font color="#E5E5E5"> we execute</font><font color="#CCCCCC"> other</font>

836
00:35:23,890 --> 00:35:27,370
<font color="#E5E5E5">binaries</font><font color="#CCCCCC"> that it goes away and sudden</font>

837
00:35:26,590 --> 00:35:30,730
<font color="#E5E5E5">the memory anymore</font>

838
00:35:27,370 --> 00:35:32,470
otherwise it stays in memory<font color="#E5E5E5"> okay so if</font>

839
00:35:30,730 --> 00:35:35,150
a binary<font color="#E5E5E5"> is loaded to</font><font color="#CCCCCC"> the first time</font>

840
00:35:32,470 --> 00:35:39,259
into the page cache it stays there

841
00:35:35,150 --> 00:35:42,410
and if we evicted<font color="#CCCCCC"> if the</font><font color="#E5E5E5"> page cache is</font>

842
00:35:39,259 --> 00:35:43,940
full<font color="#E5E5E5"> it will be loaded to</font><font color="#CCCCCC"> a new location</font>

843
00:35:42,410 --> 00:35:46,490
it's<font color="#CCCCCC"> abuse right</font>

844
00:35:43,940 --> 00:35:50,150
<font color="#E5E5E5">it's huge yes we we can't just evict the</font>

845
00:35:46,490 --> 00:35:52,129
page cache right<font color="#E5E5E5"> so yes</font><font color="#CCCCCC"> Mary wailing so</font>

846
00:35:50,150 --> 00:35:53,809
basically we<font color="#E5E5E5"> want to relocate the page</font>

847
00:35:52,130 --> 00:35:55,490
and hit it at the<font color="#CCCCCC"> right time when it's</font>

848
00:35:53,809 --> 00:35:56,059
sitting<font color="#CCCCCC"> at the right</font><font color="#E5E5E5"> location</font><font color="#CCCCCC"> how does</font>

849
00:35:55,490 --> 00:35:58,189
<font color="#CCCCCC">it</font><font color="#E5E5E5"> work</font>

850
00:35:56,059 --> 00:36:01,190
so we have<font color="#CCCCCC"> our binary here in in green</font>

851
00:35:58,190 --> 00:36:03,490
and our<font color="#E5E5E5"> target location</font><font color="#CCCCCC"> and then we can</font>

852
00:36:01,190 --> 00:36:06,259
pick the page cache by filling it with

853
00:36:03,490 --> 00:36:08,180
binaries until our<font color="#CCCCCC"> binary</font><font color="#E5E5E5"> is gone and we</font>

854
00:36:06,259 --> 00:36:09,170
reload our<font color="#CCCCCC"> binary it's</font><font color="#E5E5E5"> will be</font><font color="#CCCCCC"> at a</font>

855
00:36:08,180 --> 00:36:11,799
different<font color="#CCCCCC"> location</font>

856
00:36:09,170 --> 00:36:14,749
we can't evict it and access<font color="#CCCCCC"> the binary</font>

857
00:36:11,799 --> 00:36:16,819
until finally at<font color="#E5E5E5"> some point our binary</font>

858
00:36:14,749 --> 00:36:18,919
<font color="#E5E5E5">is exactly at the location we want it to</font>

859
00:36:16,819 --> 00:36:21,499
be so<font color="#CCCCCC"> we can introduce our bit flips in</font>

860
00:36:18,920 --> 00:36:24,799
<font color="#CCCCCC">the binary</font><font color="#E5E5E5"> okay but do we</font><font color="#CCCCCC"> really reach</font>

861
00:36:21,499 --> 00:36:26,689
all the physical pages<font color="#E5E5E5"> yes don't we get</font>

862
00:36:24,799 --> 00:36:29,210
just the same<font color="#E5E5E5"> physical page all over</font>

863
00:36:26,690 --> 00:36:32,359
again<font color="#E5E5E5"> in fact we are not as</font><font color="#CCCCCC"> you can see</font>

864
00:36:29,210 --> 00:36:35,779
on this graph<font color="#CCCCCC"> so whenever</font><font color="#E5E5E5"> we get a new</font>

865
00:36:32,359 --> 00:36:37,940
physical address<font color="#E5E5E5"> for</font><font color="#CCCCCC"> our page with a</font>

866
00:36:35,779 --> 00:36:40,369
high<font color="#CCCCCC"> chance</font><font color="#E5E5E5"> it's likely to be a new</font>

867
00:36:37,940 --> 00:36:42,470
<font color="#E5E5E5">physical location and</font><font color="#CCCCCC"> not the same as we</font>

868
00:36:40,369 --> 00:36:44,960
can see in this plot<font color="#E5E5E5"> another advantage</font>

869
00:36:42,470 --> 00:36:48,348
of this technique is<font color="#CCCCCC"> that we do</font><font color="#E5E5E5"> not</font>

870
00:36:44,960 --> 00:36:50,269
exhaust<font color="#E5E5E5"> the entire memory we use pages</font>

871
00:36:48,349 --> 00:36:53,210
<font color="#E5E5E5">that are loaded into the page cache so</font>

872
00:36:50,269 --> 00:36:54,529
they can be<font color="#E5E5E5"> evicted any at any time so</font>

873
00:36:53,210 --> 00:36:57,650
we are<font color="#E5E5E5"> not running into any out of</font>

874
00:36:54,529 --> 00:36:59,599
<font color="#E5E5E5">memory situation as in previous variants</font>

875
00:36:57,650 --> 00:37:01,309
<font color="#E5E5E5">of the row hammer attack</font><font color="#CCCCCC"> but our memory</font>

876
00:36:59,599 --> 00:37:02,839
usage<font color="#CCCCCC"> actually as reported by</font><font color="#E5E5E5"> the</font>

877
00:37:01,309 --> 00:37:04,640
operating system stays very low

878
00:37:02,839 --> 00:37:07,190
approximately at<font color="#CCCCCC"> sixty sixty-five</font>

879
00:37:04,640 --> 00:37:09,920
<font color="#CCCCCC">percent</font><font color="#E5E5E5"> if starting at sixty percent so</font>

880
00:37:07,190 --> 00:37:13,369
it stays really really low<font color="#E5E5E5"> so it's not a</font>

881
00:37:09,920 --> 00:37:15,529
problem<font color="#CCCCCC"> for</font><font color="#E5E5E5"> system stability yeah but we</font>

882
00:37:13,369 --> 00:37:18,049
can do more<font color="#CCCCCC"> for instance we can combine</font>

883
00:37:15,529 --> 00:37:20,210
row hammer<font color="#E5E5E5"> with intellect checks to get</font>

884
00:37:18,049 --> 00:37:22,880
a cheap denial of service attack<font color="#E5E5E5"> so</font>

885
00:37:20,210 --> 00:37:25,220
intellect<font color="#CCCCCC"> X is an instruction set</font>

886
00:37:22,880 --> 00:37:28,039
extensions<font color="#E5E5E5"> which gives us integrity and</font>

887
00:37:25,220 --> 00:37:30,950
confidentiality of code and data in an

888
00:37:28,039 --> 00:37:33,859
untrusted environment<font color="#E5E5E5"> and it runs with</font>

889
00:37:30,950 --> 00:37:36,169
user privileges and<font color="#E5E5E5"> is very restricted</font>

890
00:37:33,859 --> 00:37:40,098
<font color="#E5E5E5">so you cannot call any system calls in</font>

891
00:37:36,170 --> 00:37:43,430
<font color="#CCCCCC">there and programs are run</font><font color="#E5E5E5"> in so called</font>

892
00:37:40,099 --> 00:37:45,410
<font color="#E5E5E5">enclaves which is a in a certain part of</font>

893
00:37:43,430 --> 00:37:49,009
the<font color="#CCCCCC"> memory which is a protected area of</font>

894
00:37:45,410 --> 00:37:50,690
memory<font color="#CCCCCC"> called TBC yes</font><font color="#E5E5E5"> this EPC is just</font>

895
00:37:49,010 --> 00:37:53,240
in the<font color="#E5E5E5"> physical memory somewhere and</font>

896
00:37:50,690 --> 00:37:55,970
it's encrypted<font color="#CCCCCC"> and integrity checked and</font>

897
00:37:53,240 --> 00:37:58,759
the question then<font color="#CCCCCC"> of course is what</font>

898
00:37:55,970 --> 00:38:01,669
<font color="#CCCCCC">happens if a bit flips in the epc yeah</font>

899
00:37:58,760 --> 00:38:03,620
<font color="#CCCCCC">so as I said it's</font><font color="#E5E5E5"> integrity checked now</font>

900
00:38:01,670 --> 00:38:06,860
we flip<font color="#E5E5E5"> a bit so the integrity check</font>

901
00:38:03,620 --> 00:38:09,410
will fail<font color="#CCCCCC"> make sense</font><font color="#E5E5E5"> but it then locks</font>

902
00:38:06,860 --> 00:38:11,750
<font color="#E5E5E5">up the memory controller which means</font>

903
00:38:09,410 --> 00:38:15,410
that we cannot do any further memory

904
00:38:11,750 --> 00:38:18,140
access so the system halts immediately

905
00:38:15,410 --> 00:38:22,940
and we need to<font color="#E5E5E5"> manually reboot it sounds</font>

906
00:38:18,140 --> 00:38:27,529
unsafe<font color="#E5E5E5"> it is unsafe especially</font><font color="#CCCCCC"> in a</font>

907
00:38:22,940 --> 00:38:29,690
cloud environment<font color="#CCCCCC"> ok so if a malicious</font>

908
00:38:27,530 --> 00:38:32,360
<font color="#CCCCCC">in</font><font color="#E5E5E5"> place and uses a bit flip the entire</font>

909
00:38:29,690 --> 00:38:34,370
<font color="#CCCCCC">machine</font><font color="#E5E5E5"> hearts even in the cloud which</font>

910
00:38:32,360 --> 00:38:36,400
allows<font color="#E5E5E5"> us</font><font color="#CCCCCC"> to mount</font><font color="#E5E5E5"> denial of service</font>

911
00:38:34,370 --> 00:38:39,830
attacks in the cloud on co-located

912
00:38:36,400 --> 00:38:42,230
<font color="#E5E5E5">denial of services is boring that's</font><font color="#CCCCCC"> not</font>

913
00:38:39,830 --> 00:38:44,330
something<font color="#CCCCCC"> we want to do maybe just put</font>

914
00:38:42,230 --> 00:38:46,280
everything together<font color="#E5E5E5"> we have already with</font>

915
00:38:44,330 --> 00:38:48,350
<font color="#CCCCCC">sjx and the one location hammering and</font>

916
00:38:46,280 --> 00:38:51,410
<font color="#CCCCCC">opcode</font><font color="#E5E5E5"> flipping and</font><font color="#CCCCCC"> then we</font><font color="#E5E5E5"> build an</font>

917
00:38:48,350 --> 00:38:55,069
undetectable exploit<font color="#E5E5E5"> that would be cool</font>

918
00:38:51,410 --> 00:38:56,359
so for<font color="#CCCCCC"> SGX is really nice because</font><font color="#E5E5E5"> it</font>

919
00:38:55,070 --> 00:38:59,180
protects software from<font color="#E5E5E5"> malicious</font>

920
00:38:56,360 --> 00:39:01,160
environments<font color="#CCCCCC"> and we can't do</font><font color="#E5E5E5"> anything</font>

921
00:38:59,180 --> 00:39:02,930
with this thing that's<font color="#E5E5E5"> running in there</font>

922
00:39:01,160 --> 00:39:04,609
we don't<font color="#E5E5E5"> have</font><font color="#CCCCCC"> dynamic analysis we don't</font>

923
00:39:02,930 --> 00:39:06,529
have static analysis we don't have

924
00:39:04,610 --> 00:39:07,420
performance counters<font color="#E5E5E5"> so everything is</font>

925
00:39:06,530 --> 00:39:10,220
invisible

926
00:39:07,420 --> 00:39:12,770
if we now hammer from inside this

927
00:39:10,220 --> 00:39:14,779
<font color="#CCCCCC">Jackson cave</font><font color="#E5E5E5"> then we defeat all the</font>

928
00:39:12,770 --> 00:39:18,590
counter measures that were proposed<font color="#E5E5E5"> so</font>

929
00:39:14,780 --> 00:39:21,260
it protects<font color="#E5E5E5"> our exploit from from also</font>

930
00:39:18,590 --> 00:39:26,420
benign applications great idea Mike a

931
00:39:21,260 --> 00:39:28,070
great idea<font color="#E5E5E5"> ok how does it work so this</font>

932
00:39:26,420 --> 00:39:31,430
<font color="#E5E5E5">is now a demo for the</font><font color="#CCCCCC"> OP code flipping</font>

933
00:39:28,070 --> 00:39:34,670
and we can see we<font color="#CCCCCC"> are on a new Ubuntu</font>

934
00:39:31,430 --> 00:39:38,180
system<font color="#E5E5E5"> with an current</font><font color="#CCCCCC"> sudo version if</font>

935
00:39:34,670 --> 00:39:40,280
we run sudo<font color="#E5E5E5"> we can see we don't have</font>

936
00:39:38,180 --> 00:39:41,629
<font color="#E5E5E5">root privileges here it asked for</font>

937
00:39:40,280 --> 00:39:44,320
<font color="#E5E5E5">password I have no idea what the</font>

938
00:39:41,630 --> 00:39:47,360
password is so I'm starting a row<font color="#E5E5E5"> Hema</font>

939
00:39:44,320 --> 00:39:49,400
exploit here and I want<font color="#E5E5E5"> to jump this</font>

940
00:39:47,360 --> 00:39:52,340
<font color="#E5E5E5">flip this come not equal to a champ</font>

941
00:39:49,400 --> 00:39:54,500
<font color="#E5E5E5">equal in a pseudo binary we do in the</font>

942
00:39:52,340 --> 00:39:56,810
memory<font color="#CCCCCC"> way laying</font><font color="#E5E5E5"> until we have some</font>

943
00:39:54,500 --> 00:39:59,330
offset that<font color="#E5E5E5"> we can flip and this</font><font color="#CCCCCC"> memory</font>

944
00:39:56,810 --> 00:40:01,220
<font color="#CCCCCC">whaling is quite fast then we</font><font color="#E5E5E5"> we flip</font>

945
00:39:59,330 --> 00:40:02,840
the<font color="#E5E5E5"> bits there at this target location</font>

946
00:40:01,220 --> 00:40:04,939
and when we now run sudo

947
00:40:02,840 --> 00:40:06,740
<font color="#CCCCCC">it doesn't ask for password anymore and</font>

948
00:40:04,940 --> 00:40:09,020
you can just run<font color="#CCCCCC"> everything</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> rude and</font>

949
00:40:06,740 --> 00:40:11,540
<font color="#E5E5E5">the nice</font><font color="#CCCCCC"> thing is we can evict the page</font>

950
00:40:09,020 --> 00:40:14,120
cache again<font color="#CCCCCC"> and is</font><font color="#E5E5E5"> replaced</font><font color="#CCCCCC"> by the</font>

951
00:40:11,540 --> 00:40:15,950
<font color="#E5E5E5">original binary and it still works as</font>

952
00:40:14,120 --> 00:40:17,960
before and there<font color="#E5E5E5"> are no traces of the</font>

953
00:40:15,950 --> 00:40:20,750
attack here<font color="#E5E5E5"> this is a really cool</font>

954
00:40:17,960 --> 00:40:23,420
exploit what if in the<font color="#E5E5E5"> meantime I try to</font>

955
00:40:20,750 --> 00:40:24,820
<font color="#CCCCCC">login with</font><font color="#E5E5E5"> the correct password yeah it</font>

956
00:40:23,420 --> 00:40:31,250
can't log in with the correct<font color="#E5E5E5"> password</font>

957
00:40:24,820 --> 00:40:35,000
<font color="#E5E5E5">button</font><font color="#CCCCCC"> yeah okay sorry so as we see we</font>

958
00:40:31,250 --> 00:40:37,940
have<font color="#E5E5E5"> all the defense classes now</font>

959
00:40:35,000 --> 00:40:42,260
defeated we can bypass<font color="#E5E5E5"> all of them and</font>

960
00:40:37,940 --> 00:40:44,900
can mount a attack<font color="#E5E5E5"> although we have all</font>

961
00:40:42,260 --> 00:40:46,640
the<font color="#E5E5E5"> defenses installed but sorry but at</font>

962
00:40:44,900 --> 00:40:48,650
least it's a<font color="#CCCCCC"> Loki attack right so we</font>

963
00:40:46,640 --> 00:40:53,450
still<font color="#CCCCCC"> need loki code execution for all</font>

964
00:40:48,650 --> 00:40:55,820
of that so okay<font color="#CCCCCC"> okay let's just compare</font>

965
00:40:53,450 --> 00:40:57,770
some performance numbers so<font color="#CCCCCC"> for</font><font color="#E5E5E5"> row</font>

966
00:40:55,820 --> 00:41:00,020
hammer the reports were that<font color="#E5E5E5"> we need at</font>

967
00:40:57,770 --> 00:41:02,630
least something like<font color="#E5E5E5"> 43,000 hammering</font>

968
00:41:00,020 --> 00:41:05,570
attempts so 43,000<font color="#CCCCCC"> uncashed memory</font>

969
00:41:02,630 --> 00:41:09,740
<font color="#E5E5E5">accesses within 64 milliseconds that's</font>

970
00:41:05,570 --> 00:41:11,810
around<font color="#E5E5E5"> just below</font><font color="#CCCCCC"> 700,000</font><font color="#E5E5E5"> accesses per</font>

971
00:41:09,740 --> 00:41:14,600
second hmm

972
00:41:11,810 --> 00:41:17,060
while handling<font color="#E5E5E5"> network packets we</font>

973
00:41:14,600 --> 00:41:19,130
actually access memory locations<font color="#E5E5E5"> up to</font><font color="#CCCCCC"> 6</font>

974
00:41:17,060 --> 00:41:21,620
times<font color="#E5E5E5"> the same memory location up to 6</font>

975
00:41:19,130 --> 00:41:24,080
times<font color="#E5E5E5"> depending on the specific kernel</font>

976
00:41:21,620 --> 00:41:28,040
that<font color="#CCCCCC"> is used so that means if</font><font color="#E5E5E5"> we can</font>

977
00:41:24,080 --> 00:41:32,120
<font color="#E5E5E5">handle something like</font><font color="#CCCCCC"> 100 11,000 packets</font>

978
00:41:28,040 --> 00:41:33,890
per second<font color="#E5E5E5"> we could theoretically do</font>

979
00:41:32,120 --> 00:41:35,960
something there right<font color="#CCCCCC"> a network package</font>

980
00:41:33,890 --> 00:41:39,200
<font color="#E5E5E5">have at least 64 bytes so we need</font>

981
00:41:35,960 --> 00:41:42,260
<font color="#E5E5E5">something like 57 megabits per second</font>

982
00:41:39,200 --> 00:41:46,480
that sounds really unreal it's Evan

983
00:41:42,260 --> 00:41:46,480
megabits per second connection somewhere

984
00:41:46,600 --> 00:41:53,839
not<font color="#CCCCCC"> in Austria</font><font color="#E5E5E5"> but of course we have</font>

985
00:41:51,290 --> 00:41:56,090
<font color="#E5E5E5">modern and pretty fast networks so this</font>

986
00:41:53,840 --> 00:41:57,920
is not an issue at all outside<font color="#E5E5E5"> of</font>

987
00:41:56,090 --> 00:42:01,370
Austria<font color="#CCCCCC"> out to the party</font><font color="#E5E5E5"> of course</font>

988
00:41:57,920 --> 00:42:03,440
so with net<font color="#E5E5E5"> hammer we see that we can</font>

989
00:42:01,370 --> 00:42:07,970
<font color="#E5E5E5">just send many many back heads to the</font>

990
00:42:03,440 --> 00:42:10,280
system<font color="#E5E5E5"> and induce bit flips and in the</font>

991
00:42:07,970 --> 00:42:12,620
end<font color="#E5E5E5"> network stacks arm for instance of</font>

992
00:42:10,280 --> 00:42:15,830
news and cache memory which<font color="#CCCCCC"> is</font><font color="#E5E5E5"> perfect</font>

993
00:42:12,620 --> 00:42:16,609
for hammering<font color="#E5E5E5"> as we've seen or</font><font color="#CCCCCC"> intercom</font>

994
00:42:15,830 --> 00:42:18,830
<font color="#CCCCCC">ends</font>

995
00:42:16,610 --> 00:42:21,380
location technology for quality of

996
00:42:18,830 --> 00:42:24,319
<font color="#E5E5E5">service in cloud environments where you</font>

997
00:42:21,380 --> 00:42:26,840
can allocate the<font color="#CCCCCC"> cash</font><font color="#E5E5E5"> to different</font>

998
00:42:24,320 --> 00:42:30,020
tenants<font color="#E5E5E5"> so you restrict the size of the</font>

999
00:42:26,840 --> 00:42:31,700
cache and under a heavy workload<font color="#CCCCCC"> the</font>

1000
00:42:30,020 --> 00:42:34,430
virtual machine<font color="#E5E5E5"> has only for instance</font>

1001
00:42:31,700 --> 00:42:37,609
one catch way so you can evict<font color="#E5E5E5"> pretty</font>

1002
00:42:34,430 --> 00:42:40,250
pretty nicely<font color="#E5E5E5"> using this</font><font color="#CCCCCC"> technology but</font>

1003
00:42:37,610 --> 00:42:43,340
also any<font color="#CCCCCC"> other any other software that</font>

1004
00:42:40,250 --> 00:42:46,310
is used<font color="#CCCCCC"> on your system</font><font color="#E5E5E5"> any software</font><font color="#CCCCCC"> that</font>

1005
00:42:43,340 --> 00:42:49,700
uses<font color="#E5E5E5"> CL flush somewhere or non-temporal</font>

1006
00:42:46,310 --> 00:42:52,370
stores right<font color="#E5E5E5"> and uses this while</font>

1007
00:42:49,700 --> 00:42:54,710
handling network<font color="#E5E5E5"> requests any of this</font>

1008
00:42:52,370 --> 00:42:56,330
code could be<font color="#E5E5E5"> used for</font><font color="#CCCCCC"> a remote draw</font>

1009
00:42:54,710 --> 00:42:58,700
hemorrhage<font color="#E5E5E5"> so it must not be the driver</font>

1010
00:42:56,330 --> 00:43:04,130
<font color="#E5E5E5">yourself but any other application that</font>

1011
00:42:58,700 --> 00:43:07,790
<font color="#E5E5E5">uses the packet that</font><font color="#CCCCCC"> has been sent so</font>

1012
00:43:04,130 --> 00:43:10,550
how can we exploit that<font color="#E5E5E5"> we can of course</font>

1013
00:43:07,790 --> 00:43:12,770
<font color="#E5E5E5">cause to the denial of service with</font><font color="#CCCCCC"> sjx</font>

1014
00:43:10,550 --> 00:43:14,210
again<font color="#E5E5E5"> yeah we can also do denial of</font>

1015
00:43:12,770 --> 00:43:14,660
service by flipping a bit in the<font color="#E5E5E5"> file</font>

1016
00:43:14,210 --> 00:43:16,400
<font color="#E5E5E5">system</font>

1017
00:43:14,660 --> 00:43:18,259
<font color="#E5E5E5">heavens quite often if we run a net-net</font>

1018
00:43:16,400 --> 00:43:20,150
<font color="#CCCCCC">Ameritech unfortunately or a slip</font>

1019
00:43:18,260 --> 00:43:23,570
something in a DNS<font color="#CCCCCC"> server and</font><font color="#E5E5E5"> to a bit</font>

1020
00:43:20,150 --> 00:43:25,820
<font color="#CCCCCC">squating attack or in an OCSP server and</font>

1021
00:43:23,570 --> 00:43:29,990
make our invalid certificates<font color="#E5E5E5"> great</font>

1022
00:43:25,820 --> 00:43:31,880
again in making them valid again<font color="#CCCCCC"> ok we</font>

1023
00:43:29,990 --> 00:43:35,290
<font color="#E5E5E5">can also attack crypto for instance if</font>

1024
00:43:31,880 --> 00:43:38,420
<font color="#E5E5E5">we flip a bit in a private key we can</font>

1025
00:43:35,290 --> 00:43:41,450
<font color="#E5E5E5">generate a public key for</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> private</font>

1026
00:43:38,420 --> 00:43:42,830
key because it can be factorized<font color="#CCCCCC"> and</font><font color="#E5E5E5"> you</font>

1027
00:43:41,450 --> 00:43:45,410
can use this with<font color="#CCCCCC"> different services</font>

1028
00:43:42,830 --> 00:43:48,410
<font color="#CCCCCC">like</font><font color="#E5E5E5"> with github or get left where</font><font color="#CCCCCC"> your</font>

1029
00:43:45,410 --> 00:43:50,750
upload<font color="#E5E5E5"> your public key then</font><font color="#CCCCCC"> we do a bit</font>

1030
00:43:48,410 --> 00:43:53,089
<font color="#CCCCCC">of a beer calculate a new private</font><font color="#E5E5E5"> key</font>

1031
00:43:50,750 --> 00:43:55,160
and then we<font color="#E5E5E5"> can just push our malicious</font>

1032
00:43:53,090 --> 00:43:57,680
code in your<font color="#E5E5E5"> repository</font><font color="#CCCCCC"> yeah we we</font>

1033
00:43:55,160 --> 00:44:00,109
implement or several of these of these

1034
00:43:57,680 --> 00:44:02,270
<font color="#E5E5E5">attacks and from that we can do them in</font>

1035
00:44:00,110 --> 00:44:04,370
<font color="#CCCCCC">practice and as a</font><font color="#E5E5E5"> bonus we can again and</font>

1036
00:44:02,270 --> 00:44:06,410
pick the page cache and get rid of<font color="#E5E5E5"> the</font>

1037
00:44:04,370 --> 00:44:09,500
<font color="#E5E5E5">problem key and no one sees any traces</font>

1038
00:44:06,410 --> 00:44:12,100
anymore so that<font color="#CCCCCC"> avoid unfortunate if</font><font color="#E5E5E5"> I</font>

1039
00:44:09,500 --> 00:44:14,660
if so so you say<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> a commit and</font>

1040
00:44:12,100 --> 00:44:16,339
<font color="#CCCCCC">either run prove that it's not from me</font>

1041
00:44:14,660 --> 00:44:17,299
<font color="#CCCCCC">errors my commit and no one will ever</font>

1042
00:44:16,340 --> 00:44:18,860
<font color="#E5E5E5">know ok</font>

1043
00:44:17,300 --> 00:44:22,400
that's why you should find<font color="#CCCCCC"> new commits</font>

1044
00:44:18,860 --> 00:44:24,140
me<font color="#E5E5E5"> yeah some we have seen that many</font>

1045
00:44:22,400 --> 00:44:27,050
academic countermeasures were proposed

1046
00:44:24,140 --> 00:44:29,120
so far to mitigate row<font color="#E5E5E5"> hammer but we've</font>

1047
00:44:27,050 --> 00:44:30,560
also seen<font color="#CCCCCC"> that we can circumvent</font><font color="#E5E5E5"> all of</font>

1048
00:44:29,120 --> 00:44:33,380
them

1049
00:44:30,560 --> 00:44:36,259
yeah we cannot design<font color="#E5E5E5"> countermeasures in</font>

1050
00:44:33,380 --> 00:44:38,030
<font color="#E5E5E5">an effective way</font><font color="#CCCCCC"> without</font><font color="#E5E5E5"> completely</font>

1051
00:44:36,260 --> 00:44:40,310
understanding the attack first so we had

1052
00:44:38,030 --> 00:44:41,960
<font color="#CCCCCC">these wrong assumptions about this we</font>

1053
00:44:40,310 --> 00:44:45,170
need<font color="#E5E5E5"> two locations to hammer and</font><font color="#CCCCCC"> Emma</font>

1054
00:44:41,960 --> 00:44:47,930
<font color="#E5E5E5">showed that's not the case so as soon as</font>

1055
00:44:45,170 --> 00:44:49,820
we<font color="#CCCCCC"> understand the complete attack</font><font color="#E5E5E5"> then</font>

1056
00:44:47,930 --> 00:44:52,490
we might<font color="#CCCCCC"> be able to design</font><font color="#E5E5E5"> good</font>

1057
00:44:49,820 --> 00:44:55,310
countermeasures<font color="#E5E5E5"> yes because otherwise we</font>

1058
00:44:52,490 --> 00:44:58,430
just patch a concrete exploit but<font color="#E5E5E5"> do not</font>

1059
00:44:55,310 --> 00:45:01,340
solve the problem<font color="#E5E5E5"> entirely also</font>

1060
00:44:58,430 --> 00:45:03,169
<font color="#E5E5E5">something we want to talk about Apple</font>

1061
00:45:01,340 --> 00:45:05,690
had a really<font color="#E5E5E5"> really good idea of a</font>

1062
00:45:03,170 --> 00:45:06,170
device lower the refresh rate<font color="#CCCCCC"> to save</font>

1063
00:45:05,690 --> 00:45:09,680
energy

1064
00:45:06,170 --> 00:45:12,860
but<font color="#CCCCCC"> yeah</font><font color="#E5E5E5"> got to</font><font color="#CCCCCC"> get</font><font color="#E5E5E5"> some more flips but</font>

1065
00:45:09,680 --> 00:45:15,230
they just added ECC memory to the iPhone

1066
00:45:12,860 --> 00:45:17,810
so then that<font color="#E5E5E5"> your bit flips again</font><font color="#CCCCCC"> so</font>

1067
00:45:15,230 --> 00:45:19,310
they save that<font color="#E5E5E5"> I straight off</font><font color="#CCCCCC"> okay but</font>

1068
00:45:17,810 --> 00:45:21,140
yeah<font color="#E5E5E5"> that's a great</font><font color="#CCCCCC"> idea</font>

1069
00:45:19,310 --> 00:45:23,720
but this also shows<font color="#CCCCCC"> that it's an</font>

1070
00:45:21,140 --> 00:45:26,480
optimization problem<font color="#CCCCCC"> vendors</font><font color="#E5E5E5"> will always</font>

1071
00:45:23,720 --> 00:45:28,430
push towards the<font color="#E5E5E5"> boundary where they can</font>

1072
00:45:26,480 --> 00:45:30,740
push where they know<font color="#E5E5E5"> there it is still</font>

1073
00:45:28,430 --> 00:45:33,710
safe with under the current<font color="#CCCCCC"> assumptions</font>

1074
00:45:30,740 --> 00:45:36,169
right but if it was too aggressive<font color="#CCCCCC"> you</font>

1075
00:45:33,710 --> 00:45:38,600
will have bit flips in some cases<font color="#CCCCCC"> if it</font>

1076
00:45:36,170 --> 00:45:40,370
was too cautious<font color="#CCCCCC"> you will have a waste</font>

1077
00:45:38,600 --> 00:45:42,410
of energy<font color="#E5E5E5"> you will have a lower battery</font>

1078
00:45:40,370 --> 00:45:45,350
<font color="#E5E5E5">runtime so it's an optimization problem</font>

1079
00:45:42,410 --> 00:45:47,029
<font color="#CCCCCC">and also what if the</font><font color="#E5E5E5"> too aggressive</font>

1080
00:45:45,350 --> 00:45:49,670
changes<font color="#E5E5E5"> over time because someone</font>

1081
00:45:47,030 --> 00:45:52,760
figures out a new<font color="#E5E5E5"> technique</font><font color="#CCCCCC"> what if the</font>

1082
00:45:49,670 --> 00:45:56,450
attack<font color="#E5E5E5"> has become slightly better over</font>

1083
00:45:52,760 --> 00:46:00,710
time<font color="#E5E5E5"> it's difficult</font><font color="#CCCCCC"> to optimize with an</font>

1084
00:45:56,450 --> 00:46:02,779
adversary<font color="#CCCCCC"> that works against Q so what</font>

1085
00:46:00,710 --> 00:46:06,850
do<font color="#CCCCCC"> we</font><font color="#E5E5E5"> learn</font><font color="#CCCCCC"> from that</font><font color="#E5E5E5"> we have to invest</font>

1086
00:46:02,780 --> 00:46:09,260
much more<font color="#E5E5E5"> into researching attacks</font>

1087
00:46:06,850 --> 00:46:12,370
because there are still aspects of<font color="#CCCCCC"> Rho</font>

1088
00:46:09,260 --> 00:46:15,710
<font color="#CCCCCC">Emma that we do not fully understand</font>

1089
00:46:12,370 --> 00:46:17,690
<font color="#E5E5E5">however this is really a big Friant to</font>

1090
00:46:15,710 --> 00:46:20,000
design countermeasures<font color="#CCCCCC"> that</font><font color="#E5E5E5"> fully</font>

1091
00:46:17,690 --> 00:46:21,770
protect us against bit flips in<font color="#E5E5E5"> the long</font>

1092
00:46:20,000 --> 00:46:24,320
run and<font color="#E5E5E5"> you also have to keep in</font><font color="#CCCCCC"> mind if</font>

1093
00:46:21,770 --> 00:46:26,509
you add new features to<font color="#CCCCCC"> our</font><font color="#E5E5E5"> CPUs then</font>

1094
00:46:24,320 --> 00:46:28,100
there<font color="#E5E5E5"> might be new attack vectors for</font>

1095
00:46:26,510 --> 00:46:30,230
example if s checks that<font color="#E5E5E5"> we haven't</font>

1096
00:46:28,100 --> 00:46:34,700
<font color="#CCCCCC">thought of</font><font color="#E5E5E5"> okay</font>

1097
00:46:30,230 --> 00:46:36,440
and<font color="#CCCCCC"> yeah what can</font><font color="#E5E5E5"> we say about what we</font>

1098
00:46:34,700 --> 00:46:38,480
learned here<font color="#CCCCCC"> so in the end we</font>

1099
00:46:36,440 --> 00:46:39,920
underestimated side-channel<font color="#E5E5E5"> or micro</font>

1100
00:46:38,480 --> 00:46:44,030
architectural attacks for<font color="#E5E5E5"> a long long</font>

1101
00:46:39,920 --> 00:46:46,520
<font color="#E5E5E5">time</font><font color="#CCCCCC"> yes and the industry</font><font color="#E5E5E5"> and also</font>

1102
00:46:44,030 --> 00:46:49,280
the customers had other<font color="#CCCCCC"> priorities for</font><font color="#E5E5E5"> a</font>

1103
00:46:46,520 --> 00:46:51,410
long time<font color="#E5E5E5"> they wanted performance and</font>

1104
00:46:49,280 --> 00:46:53,720
not mainly security you<font color="#E5E5E5"> want performance</font>

1105
00:46:51,410 --> 00:46:55,549
<font color="#E5E5E5">first right but maybe we</font><font color="#CCCCCC"> don't</font><font color="#E5E5E5"> want</font>

1106
00:46:53,720 --> 00:46:57,140
performance<font color="#CCCCCC"> without security nowadays</font>

1107
00:46:55,550 --> 00:46:59,540
<font color="#CCCCCC">yeah and we have</font><font color="#E5E5E5"> to always</font><font color="#CCCCCC"> think</font><font color="#E5E5E5"> is a</font>

1108
00:46:57,140 --> 00:47:02,120
<font color="#E5E5E5">reliability issue only</font><font color="#CCCCCC"> a reliability</font>

1109
00:46:59,540 --> 00:47:04,910
<font color="#E5E5E5">issue or can't become a security impact</font>

1110
00:47:02,120 --> 00:47:09,020
at some point so we need<font color="#CCCCCC"> more</font><font color="#E5E5E5"> research</font>

1111
00:47:04,910 --> 00:47:11,990
<font color="#E5E5E5">to fully understand the attacks and to</font>

1112
00:47:09,020 --> 00:47:13,400
ultimately<font color="#E5E5E5"> mitigate them with that we</font>

1113
00:47:11,990 --> 00:47:24,890
would<font color="#E5E5E5"> like</font><font color="#CCCCCC"> to thank you for your</font>

1114
00:47:13,400 --> 00:47:27,320
attention so if there are any<font color="#CCCCCC"> questions</font>

1115
00:47:24,890 --> 00:47:29,060
<font color="#E5E5E5">yeah if there are any</font><font color="#CCCCCC"> questions you can</font>

1116
00:47:27,320 --> 00:47:39,760
<font color="#E5E5E5">ask</font><font color="#CCCCCC"> them right away at one of the</font>

1117
00:47:29,060 --> 00:47:43,820
<font color="#CCCCCC">microphones</font><font color="#E5E5E5"> questions in your</font>

1118
00:47:39,760 --> 00:47:45,920
presentation<font color="#CCCCCC"> you had some ddr4 and</font>

1119
00:47:43,820 --> 00:47:50,390
<font color="#CCCCCC">threes</font><font color="#E5E5E5"> that were vulnerable</font><font color="#CCCCCC"> finger</font><font color="#E5E5E5"> was</font>

1120
00:47:45,920 --> 00:47:54,020
like<font color="#CCCCCC"> 80% for ddr3 and 60% or so for</font><font color="#E5E5E5"> ddr4</font>

1121
00:47:50,390 --> 00:47:57,680
what makes a DDR<font color="#E5E5E5"> dam vulnerable and what</font>

1122
00:47:54,020 --> 00:48:00,200
makes it vulnerable<font color="#E5E5E5"> um in general</font><font color="#CCCCCC"> the</font>

1123
00:47:57,680 --> 00:48:04,399
statement about the<font color="#CCCCCC"> DIMM module being</font>

1124
00:48:00,200 --> 00:48:06,680
vulnerable<font color="#E5E5E5"> is a very it's an empiric one</font>

1125
00:48:04,400 --> 00:48:09,170
it's someone tried and was able<font color="#CCCCCC"> to find</font>

1126
00:48:06,680 --> 00:48:11,779
<font color="#CCCCCC">a bit flip so they said it</font><font color="#E5E5E5"> is vulnerable</font>

1127
00:48:09,170 --> 00:48:13,460
<font color="#CCCCCC">but</font><font color="#E5E5E5"> if you don't find any bit flip that</font>

1128
00:48:11,780 --> 00:48:16,310
<font color="#E5E5E5">does not mean that it's not</font><font color="#CCCCCC"> vulnerable</font>

1129
00:48:13,460 --> 00:48:18,380
<font color="#CCCCCC">it seems that there are differences in</font><font color="#E5E5E5"> a</font>

1130
00:48:16,310 --> 00:48:20,900
manufacturing<font color="#CCCCCC"> process even modules that</font>

1131
00:48:18,380 --> 00:48:23,030
<font color="#CCCCCC">are</font><font color="#E5E5E5"> almost identical that have the same</font>

1132
00:48:20,900 --> 00:48:25,490
serial<font color="#CCCCCC"> number</font><font color="#E5E5E5"> might have a very</font>

1133
00:48:23,030 --> 00:48:27,740
<font color="#E5E5E5">different profile in</font><font color="#CCCCCC"> terms of bit flips</font>

1134
00:48:25,490 --> 00:48:30,109
and susceptibility<font color="#E5E5E5"> to</font><font color="#CCCCCC"> the raw hammer</font>

1135
00:48:27,740 --> 00:48:32,600
attack<font color="#E5E5E5"> and all of those studies</font><font color="#CCCCCC"> that did</font>

1136
00:48:30,110 --> 00:48:35,060
not use many modules<font color="#CCCCCC"> so in the</font><font color="#E5E5E5"> end we</font>

1137
00:48:32,600 --> 00:48:38,000
need a study with many many<font color="#E5E5E5"> many</font><font color="#CCCCCC"> modules</font>

1138
00:48:35,060 --> 00:48:40,640
<font color="#CCCCCC">to really say that this</font><font color="#E5E5E5"> percentage is</font>

1139
00:48:38,000 --> 00:48:43,310
vulnerable<font color="#E5E5E5"> so you cannot say</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> one is</font>

1140
00:48:40,640 --> 00:48:45,830
cheaper<font color="#E5E5E5"> and it has more bit flips the</font>

1141
00:48:43,310 --> 00:48:47,750
other one is more expensive<font color="#E5E5E5"> we were</font>

1142
00:48:45,830 --> 00:48:52,730
actually hoping for that so we bought

1143
00:48:47,750 --> 00:48:54,830
several<font color="#E5E5E5"> achieve ddr4 modules and no we</font>

1144
00:48:52,730 --> 00:48:57,200
didn't find an obvious correlation<font color="#E5E5E5"> there</font>

1145
00:48:54,830 --> 00:49:00,770
<font color="#E5E5E5">our one is</font><font color="#CCCCCC"> four gigabytes</font>

1146
00:48:57,200 --> 00:49:03,980
so it's<font color="#E5E5E5"> less dense than</font><font color="#CCCCCC"> 16-gigabyte</font><font color="#E5E5E5"> we</font>

1147
00:49:00,770 --> 00:49:07,910
also we haven't found<font color="#E5E5E5"> anything in this</font>

1148
00:49:03,980 --> 00:49:10,280
<font color="#E5E5E5">direction yet so I guess it's more about</font>

1149
00:49:07,910 --> 00:49:12,230
in<font color="#E5E5E5"> the manufacturing process where</font>

1150
00:49:10,280 --> 00:49:14,809
exactly<font color="#E5E5E5"> if you if you have this die</font>

1151
00:49:12,230 --> 00:49:16,910
where the chips are from at<font color="#CCCCCC"> which</font>

1152
00:49:14,809 --> 00:49:18,490
position<font color="#CCCCCC"> this is and what influences is</font>

1153
00:49:16,910 --> 00:49:23,509
<font color="#CCCCCC">help during</font><font color="#E5E5E5"> the manufacturing process</font>

1154
00:49:18,490 --> 00:49:26,089
<font color="#CCCCCC">and in your experiments you said that</font>

1155
00:49:23,510 --> 00:49:31,130
the system<font color="#CCCCCC"> didn't have the targeted role</font>

1156
00:49:26,089 --> 00:49:33,529
refresh<font color="#E5E5E5"> mitigation so we had one system</font>

1157
00:49:31,130 --> 00:49:35,390
with this one active and we still had

1158
00:49:33,530 --> 00:49:37,430
some bit flips there<font color="#E5E5E5"> yeah but a lot</font><font color="#CCCCCC"> less</font>

1159
00:49:35,390 --> 00:49:39,529
and<font color="#E5E5E5"> on the other systems on most</font><font color="#CCCCCC"> systems</font>

1160
00:49:37,430 --> 00:49:41,660
<font color="#E5E5E5">it's it's not</font><font color="#CCCCCC"> available yeah was just on</font>

1161
00:49:39,530 --> 00:49:43,940
one<font color="#E5E5E5"> service system and not in the rows</font>

1162
00:49:41,660 --> 00:49:46,339
<font color="#E5E5E5">next to the target row but yes we rose</font>

1163
00:49:43,940 --> 00:49:48,109
we had<font color="#CCCCCC"> zero of bit flips in the adjacent</font>

1164
00:49:46,339 --> 00:49:50,180
rows so they are<font color="#CCCCCC"> TRR works as designed</font>

1165
00:49:48,109 --> 00:49:53,348
<font color="#CCCCCC">but it doesn't prevent rorimer text</font>

1166
00:49:50,180 --> 00:49:53,348
<font color="#E5E5E5">basically</font><font color="#CCCCCC"> that's</font><font color="#E5E5E5"> the takeaway</font>

