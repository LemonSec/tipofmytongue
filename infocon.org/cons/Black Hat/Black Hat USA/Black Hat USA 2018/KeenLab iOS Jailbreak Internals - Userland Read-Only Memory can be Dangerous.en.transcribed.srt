1
00:00:00,030 --> 00:00:06,509
<font color="#E5E5E5">okay</font><font color="#CCCCCC"> thanks Alan</font><font color="#E5E5E5"> for the introduction</font><font color="#CCCCCC"> so</font>

2
00:00:03,090 --> 00:00:08,610
today<font color="#E5E5E5"> my topic is</font><font color="#CCCCCC"> king</font><font color="#E5E5E5"> lab iOS jailbreak</font>

3
00:00:06,509 --> 00:00:11,460
internals<font color="#E5E5E5"> the userland agreed only</font>

4
00:00:08,610 --> 00:00:14,579
<font color="#E5E5E5">memory can be dangerous so</font><font color="#CCCCCC"> as many</font><font color="#E5E5E5"> of</font>

5
00:00:11,460 --> 00:00:18,660
you<font color="#E5E5E5"> noticed</font><font color="#CCCCCC"> that king lab demonstrated</font>

6
00:00:14,580 --> 00:00:22,769
iOS 10 points<font color="#E5E5E5"> 3.2 and</font><font color="#CCCCCC"> 11 beta to</font>

7
00:00:18,660 --> 00:00:25,170
jailbreak at more<font color="#E5E5E5"> SEC 2017 but the</font>

8
00:00:22,769 --> 00:00:28,348
details of the vulnerability has never

9
00:00:25,170 --> 00:00:31,890
been revealed yet<font color="#CCCCCC"> so today I would like</font>

10
00:00:28,349 --> 00:00:37,320
<font color="#CCCCCC">to take this opportunity to show the</font>

11
00:00:31,890 --> 00:00:40,829
details<font color="#CCCCCC"> of all</font><font color="#E5E5E5"> geo-print chance which</font>

12
00:00:37,320 --> 00:00:43,530
the park is<font color="#E5E5E5"> the involved so first about</font>

13
00:00:40,829 --> 00:00:45,300
myself<font color="#E5E5E5"> I'm the security researcher and</font>

14
00:00:43,530 --> 00:00:48,570
also the team leader at<font color="#E5E5E5"> Hope Tencent</font>

15
00:00:45,300 --> 00:00:51,349
<font color="#CCCCCC">King secret lab and</font><font color="#E5E5E5"> there previously</font><font color="#CCCCCC"> my</font>

16
00:00:48,570 --> 00:00:53,870
research covers on the browser

17
00:00:51,350 --> 00:00:57,480
vulnerability research<font color="#CCCCCC"> exploitation</font>

18
00:00:53,870 --> 00:01:00,570
<font color="#CCCCCC">major Leon's</font><font color="#E5E5E5"> Safari Chrome II and the</font>

19
00:00:57,480 --> 00:01:03,660
<font color="#CCCCCC">internet is prologue and now my focus</font>

20
00:01:00,570 --> 00:01:06,270
<font color="#CCCCCC">moved</font><font color="#E5E5E5"> to the Apple vulnerability</font>

21
00:01:03,660 --> 00:01:08,689
research<font color="#E5E5E5"> mainly for the same sandbox by</font>

22
00:01:06,270 --> 00:01:14,340
<font color="#CCCCCC">posse and also</font><font color="#E5E5E5"> cannot privilege</font>

23
00:01:08,689 --> 00:01:16,978
escalation<font color="#E5E5E5"> so today our agenda is like</font>

24
00:01:14,340 --> 00:01:19,920
we<font color="#E5E5E5"> will</font><font color="#CCCCCC"> firstly</font><font color="#E5E5E5"> talk about</font><font color="#CCCCCC"> the memory</font>

25
00:01:16,979 --> 00:01:24,000
protection implemented by<font color="#CCCCCC"> our modern</font><font color="#E5E5E5"> OS</font>

26
00:01:19,920 --> 00:01:26,270
this<font color="#E5E5E5"> is not very interesting topic</font>

27
00:01:24,000 --> 00:01:29,790
because<font color="#E5E5E5"> it is there for many years</font>

28
00:01:26,270 --> 00:01:32,610
<font color="#E5E5E5">next we discuss about the iOS DMA</font>

29
00:01:29,790 --> 00:01:35,970
features including the<font color="#CCCCCC"> previous</font><font color="#E5E5E5"> research</font>

30
00:01:32,610 --> 00:01:39,930
as well as<font color="#CCCCCC"> the implementation</font><font color="#E5E5E5"> of the iOS</font>

31
00:01:35,970 --> 00:01:43,530
m io<font color="#CCCCCC"> m mu protection and the next</font>

32
00:01:39,930 --> 00:01:47,310
<font color="#E5E5E5">because King lab did a lot of reversing</font>

33
00:01:43,530 --> 00:01:51,439
work on iOS<font color="#E5E5E5"> GPU notification mechanism</font>

34
00:01:47,310 --> 00:01:55,140
part<font color="#E5E5E5"> since it is not open</font><font color="#CCCCCC"> source</font><font color="#E5E5E5"> part of</font>

35
00:01:51,439 --> 00:01:58,350
iOS<font color="#E5E5E5"> kernel and there with enough</font>

36
00:01:55,140 --> 00:02:01,290
<font color="#CCCCCC">knowledge explained we will</font><font color="#E5E5E5"> finally talk</font>

37
00:01:58,350 --> 00:02:04,829
<font color="#CCCCCC">about the pack which includes two</font><font color="#E5E5E5"> of</font>

38
00:02:01,290 --> 00:02:07,860
them the first one<font color="#E5E5E5"> is in the DMA mapping</font>

39
00:02:04,829 --> 00:02:11,760
feature vulnerability and another is

40
00:02:07,860 --> 00:02:15,150
<font color="#E5E5E5">auto pound right in the</font><font color="#CCCCCC"> apple</font>

41
00:02:11,760 --> 00:02:17,939
<font color="#CCCCCC">fix tech after the vulnerability</font><font color="#E5E5E5"> has</font>

42
00:02:15,150 --> 00:02:21,510
been explained we will talk about the

43
00:02:17,939 --> 00:02:24,510
exploitation<font color="#E5E5E5"> we saw demo and then we</font>

44
00:02:21,510 --> 00:02:27,569
<font color="#E5E5E5">were concluded this talk</font><font color="#CCCCCC"> so the first</font>

45
00:02:24,510 --> 00:02:30,450
part is operating system memory

46
00:02:27,569 --> 00:02:32,488
protection overview so modern<font color="#CCCCCC"> OS</font>

47
00:02:30,450 --> 00:02:35,040
actually implements<font color="#CCCCCC"> the memory</font>

48
00:02:32,489 --> 00:02:39,090
protection at<font color="#CCCCCC"> the hardware level</font><font color="#E5E5E5"> to</font>

49
00:02:35,040 --> 00:02:41,340
<font color="#E5E5E5">mitigate</font><font color="#CCCCCC"> the non attack attacks</font><font color="#E5E5E5"> they are</font>

50
00:02:39,090 --> 00:02:43,620
introduced in different<font color="#E5E5E5"> levels for</font>

51
00:02:41,340 --> 00:02:47,760
<font color="#CCCCCC">example the translation blog entry</font>

52
00:02:43,620 --> 00:02:51,510
properties at<font color="#E5E5E5"> the MMU level so in this</font>

53
00:02:47,760 --> 00:02:55,138
part we will<font color="#E5E5E5"> they</font><font color="#CCCCCC"> introduced an external</font>

54
00:02:51,510 --> 00:02:58,170
executable bit and also the<font color="#CCCCCC"> pxn to</font>

55
00:02:55,139 --> 00:03:00,569
prevent<font color="#E5E5E5"> excusing the user land from the</font>

56
00:02:58,170 --> 00:03:04,980
kernel<font color="#E5E5E5"> side and also the AP which</font>

57
00:03:00,569 --> 00:03:07,349
indicates access<font color="#E5E5E5"> protection like the</font>

58
00:03:04,980 --> 00:03:10,679
<font color="#E5E5E5">read</font><font color="#CCCCCC"> only or</font><font color="#E5E5E5"> write only or execute only</font>

59
00:03:07,349 --> 00:03:12,810
memory and there besides that there are

60
00:03:10,680 --> 00:03:16,680
also<font color="#E5E5E5"> some of</font><font color="#CCCCCC"> the medications like the</font>

61
00:03:12,810 --> 00:03:18,150
<font color="#E5E5E5">kppa</font><font color="#CCCCCC"> mcc which is</font><font color="#E5E5E5"> also relating to the</font>

62
00:03:16,680 --> 00:03:21,299
memory protection but they are

63
00:03:18,150 --> 00:03:24,739
implemented in<font color="#CCCCCC"> maybe</font><font color="#E5E5E5"> deeper under lower</font>

64
00:03:21,299 --> 00:03:27,660
level which is<font color="#E5E5E5"> not our scope of the talk</font>

65
00:03:24,739 --> 00:03:31,079
so among those memory protection

66
00:03:27,660 --> 00:03:34,650
mechanisms<font color="#CCCCCC"> use a land</font><font color="#E5E5E5"> read only mapping</font>

67
00:03:31,079 --> 00:03:36,810
is a very<font color="#E5E5E5"> old-school approach to protect</font>

68
00:03:34,650 --> 00:03:39,959
the user<font color="#CCCCCC"> land the memory it</font><font color="#E5E5E5"> is very</font>

69
00:03:36,810 --> 00:03:43,859
easily implemented<font color="#CCCCCC"> but very effective</font>

70
00:03:39,959 --> 00:03:46,739
<font color="#E5E5E5">there</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> three major scenario of using</font>

71
00:03:43,859 --> 00:03:49,500
such<font color="#CCCCCC"> read-only</font><font color="#E5E5E5"> user land memory mappings</font>

72
00:03:46,739 --> 00:03:52,889
<font color="#E5E5E5">the first one is for example</font><font color="#CCCCCC"> the</font>

73
00:03:49,500 --> 00:03:56,730
executable memory<font color="#E5E5E5"> in iOS is only</font>

74
00:03:52,889 --> 00:03:59,250
<font color="#CCCCCC">read-only to prevent the attackers from</font>

75
00:03:56,730 --> 00:04:02,250
<font color="#E5E5E5">over writing the code at a very early</font>

76
00:03:59,250 --> 00:04:04,739
stage<font color="#CCCCCC"> of exploitation</font><font color="#E5E5E5"> and along</font><font color="#CCCCCC"> with</font>

77
00:04:02,250 --> 00:04:07,769
<font color="#CCCCCC">some other</font><font color="#E5E5E5"> medications like the code</font>

78
00:04:04,739 --> 00:04:11,430
signing enforcement<font color="#E5E5E5"> this has made the</font>

79
00:04:07,769 --> 00:04:14,010
<font color="#E5E5E5">iOS very strong in security</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font>

80
00:04:11,430 --> 00:04:17,548
second<font color="#E5E5E5"> scenario</font><font color="#CCCCCC"> is the sharing memory</font>

81
00:04:14,010 --> 00:04:20,190
<font color="#CCCCCC">the first</font><font color="#E5E5E5"> is the second one is between</font>

82
00:04:17,548 --> 00:04:22,859
process for example<font color="#CCCCCC"> two processes</font><font color="#E5E5E5"> share</font>

83
00:04:20,190 --> 00:04:25,860
one physical copy of<font color="#E5E5E5"> the memory</font>

84
00:04:22,860 --> 00:04:28,139
in a second in the sort<font color="#E5E5E5"> of scenario</font><font color="#CCCCCC"> it</font>

85
00:04:25,860 --> 00:04:32,189
is<font color="#CCCCCC"> a</font><font color="#E5E5E5"> sharing memory</font><font color="#CCCCCC"> between the kernel</font>

86
00:04:28,139 --> 00:04:35,610
under the process<font color="#CCCCCC"> memories sharing at</font>

87
00:04:32,189 --> 00:04:38,490
<font color="#E5E5E5">user land make the inter process or user</font>

88
00:04:35,610 --> 00:04:41,699
to<font color="#E5E5E5"> kernel communication more efficient</font>

89
00:04:38,490 --> 00:04:44,789
<font color="#E5E5E5">this is because you do not need to use</font>

90
00:04:41,699 --> 00:04:48,000
traditional message<font color="#E5E5E5"> sender mechanism</font>

91
00:04:44,789 --> 00:04:51,840
like the to call some<font color="#E5E5E5"> disk or to call</font>

92
00:04:48,000 --> 00:04:55,440
some trap<font color="#E5E5E5"> to send the buffer from the</font>

93
00:04:51,840 --> 00:04:58,318
user to<font color="#CCCCCC"> the kernel and there in</font><font color="#E5E5E5"> that way</font>

94
00:04:55,440 --> 00:05:01,919
the server<font color="#E5E5E5"> process or the kernel who</font>

95
00:04:58,319 --> 00:05:05,310
owns that<font color="#E5E5E5"> memory can trust the</font><font color="#CCCCCC"> map can</font>

96
00:05:01,919 --> 00:05:08,909
trust it<font color="#E5E5E5"> because he is the only</font><font color="#CCCCCC"> one who</font>

97
00:05:05,310 --> 00:05:11,340
can modify it well the<font color="#E5E5E5"> client side all</font>

98
00:05:08,909 --> 00:05:14,159
the client process<font color="#E5E5E5"> can only have the</font>

99
00:05:11,340 --> 00:05:17,909
<font color="#CCCCCC">read-only process which it is not</font>

100
00:05:14,159 --> 00:05:22,110
<font color="#CCCCCC">possible to</font><font color="#E5E5E5"> change the</font><font color="#CCCCCC"> memory then the</font>

101
00:05:17,909 --> 00:05:24,900
<font color="#CCCCCC">owner</font><font color="#E5E5E5"> process of the all the kernel can</font>

102
00:05:22,110 --> 00:05:27,690
eliminate the specific secret

103
00:05:24,900 --> 00:05:30,508
considerations such as the<font color="#E5E5E5"> boundary</font>

104
00:05:27,690 --> 00:05:34,319
check or<font color="#CCCCCC"> the time of check or time of</font>

105
00:05:30,509 --> 00:05:37,770
youth<font color="#CCCCCC"> issues so it's</font><font color="#E5E5E5"> implementation at</font>

106
00:05:34,319 --> 00:05:41,099
<font color="#E5E5E5">the MMU level is quite easy it has in</font>

107
00:05:37,770 --> 00:05:45,719
the<font color="#CCCCCC"> tbe</font><font color="#E5E5E5"> entry it introduced access</font>

108
00:05:41,099 --> 00:05:48,330
protection bit<font color="#E5E5E5"> where you can find the</font>

109
00:05:45,719 --> 00:05:51,349
specification document on the<font color="#CCCCCC"> right side</font>

110
00:05:48,330 --> 00:05:55,560
<font color="#E5E5E5">our not looking to it very detailing</font>

111
00:05:51,349 --> 00:05:58,199
under when there is a way found<font color="#E5E5E5"> to make</font>

112
00:05:55,560 --> 00:06:02,339
the mapping rightful then the<font color="#E5E5E5"> whole</font>

113
00:05:58,199 --> 00:06:07,020
<font color="#CCCCCC">touched</font><font color="#E5E5E5"> boundary of memory will</font><font color="#CCCCCC"> be</font>

114
00:06:02,339 --> 00:06:10,770
broken<font color="#E5E5E5"> but you need to make sure that</font>

115
00:06:07,020 --> 00:06:13,620
the memory<font color="#CCCCCC"> is remapped</font><font color="#E5E5E5"> into rightful</font>

116
00:06:10,770 --> 00:06:17,400
without marking them<font color="#E5E5E5"> copy-on-write</font>

117
00:06:13,620 --> 00:06:19,349
otherwise<font color="#E5E5E5"> another copy of the physical</font>

118
00:06:17,400 --> 00:06:22,289
<font color="#CCCCCC">memory will be introduced and we are not</font>

119
00:06:19,349 --> 00:06:25,800
able<font color="#CCCCCC"> to mutate the original physical</font>

120
00:06:22,289 --> 00:06:28,020
<font color="#CCCCCC">copy of another</font><font color="#E5E5E5"> mapping still under once</font>

121
00:06:25,800 --> 00:06:31,229
that is done then it can lead<font color="#CCCCCC"> to</font>

122
00:06:28,020 --> 00:06:33,889
<font color="#E5E5E5">privilege escalation</font><font color="#CCCCCC"> so in the process</font>

123
00:06:31,229 --> 00:06:36,829
<font color="#E5E5E5">to process memory sharings in there</font>

124
00:06:33,889 --> 00:06:39,769
you can lead to it can lead<font color="#E5E5E5"> to sandbox</font>

125
00:06:36,829 --> 00:06:42,679
bypass<font color="#E5E5E5"> Wow for the purple</font><font color="#CCCCCC"> processed you</font>

126
00:06:39,769 --> 00:06:45,709
<font color="#E5E5E5">kernel memory sharing scenario when you</font>

127
00:06:42,679 --> 00:06:48,018
are<font color="#CCCCCC"> able to</font><font color="#E5E5E5"> modify a read-only mapping</font>

128
00:06:45,709 --> 00:06:49,969
it is very possible<font color="#CCCCCC"> for</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> get a</font>

129
00:06:48,019 --> 00:06:54,019
kernel code<font color="#E5E5E5"> of</font><font color="#CCCCCC"> X fusion</font>

130
00:06:49,969 --> 00:06:57,799
I always<font color="#E5E5E5"> actually has its nature to</font>

131
00:06:54,019 --> 00:07:01,489
prevent such right polar mappings<font color="#CCCCCC"> at its</font>

132
00:06:57,799 --> 00:07:04,758
kernel code<font color="#E5E5E5"> you can see that once memory</font>

133
00:07:01,489 --> 00:07:07,938
is mapped to<font color="#CCCCCC"> children you through</font><font color="#E5E5E5"> the</font>

134
00:07:04,759 --> 00:07:10,939
process<font color="#E5E5E5"> using</font><font color="#CCCCCC"> read-only</font><font color="#E5E5E5"> actually it has</font>

135
00:07:07,939 --> 00:07:14,599
that<font color="#CCCCCC"> mapping has</font><font color="#E5E5E5"> a property</font><font color="#CCCCCC"> called</font><font color="#E5E5E5"> max</font>

136
00:07:10,939 --> 00:07:18,679
protection and that<font color="#E5E5E5"> max protection is</font>

137
00:07:14,599 --> 00:07:22,369
set<font color="#CCCCCC"> no no higher than rightful</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> that</font>

138
00:07:18,679 --> 00:07:24,739
when you try to remap<font color="#E5E5E5"> it as</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> read</font><font color="#CCCCCC"> and</font>

139
00:07:22,369 --> 00:07:27,639
<font color="#E5E5E5">write the kernel will reject you</font>

140
00:07:24,739 --> 00:07:31,959
immediately<font color="#CCCCCC"> but there is an</font><font color="#E5E5E5"> exception</font>

141
00:07:27,639 --> 00:07:35,419
<font color="#E5E5E5">when you you specify a copy on</font><font color="#CCCCCC"> write</font>

142
00:07:31,959 --> 00:07:38,239
protection properties it<font color="#CCCCCC"> will the</font>

143
00:07:35,419 --> 00:07:40,758
remapping<font color="#E5E5E5"> will be allowed but another</font>

144
00:07:38,239 --> 00:07:43,758
copy of the physical<font color="#E5E5E5"> memory will</font><font color="#CCCCCC"> be used</font>

145
00:07:40,759 --> 00:07:48,499
<font color="#E5E5E5">so you are still not able to modify that</font>

146
00:07:43,759 --> 00:07:51,649
original memory<font color="#E5E5E5"> and of course there is</font>

147
00:07:48,499 --> 00:07:55,429
some<font color="#E5E5E5"> historical issues</font><font color="#CCCCCC"> for example the</font>

148
00:07:51,649 --> 00:07:57,679
first one reproducer<font color="#E5E5E5"> enjoyed</font><font color="#CCCCCC"> gr the</font>

149
00:07:55,429 --> 00:08:00,828
memory<font color="#E5E5E5"> making</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> write book and</font><font color="#CCCCCC"> cause</font>

150
00:07:57,679 --> 00:08:02,989
some issues<font color="#E5E5E5"> and the second one is for on</font>

151
00:08:00,829 --> 00:08:05,959
<font color="#E5E5E5">Windows platform however you will</font><font color="#CCCCCC"> be</font>

152
00:08:02,989 --> 00:08:08,929
noticed<font color="#CCCCCC"> that on iOS platform there is no</font>

153
00:08:05,959 --> 00:08:14,899
<font color="#CCCCCC">such</font><font color="#E5E5E5"> known issues so we have to research</font>

154
00:08:08,929 --> 00:08:21,888
on our the next<font color="#E5E5E5"> part will cover the iOS</font>

155
00:08:14,899 --> 00:08:23,989
DMA features because the more stronger

156
00:08:21,889 --> 00:08:27,099
<font color="#CCCCCC">under stronger and more abundant</font>

157
00:08:23,989 --> 00:08:29,959
features provided<font color="#E5E5E5"> by modern peripheral</font>

158
00:08:27,099 --> 00:08:33,499
devices attached the to the mode mobile

159
00:08:29,959 --> 00:08:36,198
device DMA technology is introduced<font color="#CCCCCC"> to</font>

160
00:08:33,499 --> 00:08:40,009
<font color="#E5E5E5">enable the ability</font><font color="#CCCCCC"> for faster data</font>

161
00:08:36,198 --> 00:08:43,789
transfer<font color="#CCCCCC"> under interesting Lee</font><font color="#E5E5E5"> the DMA</font>

162
00:08:40,009 --> 00:08:46,640
transfer we are not involved<font color="#E5E5E5"> in a</font><font color="#CCCCCC"> cpu</font><font color="#E5E5E5"> so</font>

163
00:08:43,789 --> 00:08:50,150
that the access permission bits

164
00:08:46,640 --> 00:08:55,250
and the<font color="#E5E5E5"> virtual addresses will</font><font color="#CCCCCC"> be simply</font>

165
00:08:50,150 --> 00:08:58,520
ignored<font color="#E5E5E5"> and the next question is as</font><font color="#CCCCCC"> the</font>

166
00:08:55,250 --> 00:09:02,570
DMA transfer use<font color="#E5E5E5"> the physical address</font>

167
00:08:58,520 --> 00:09:05,090
<font color="#E5E5E5">and know if that is the case the</font><font color="#CCCCCC"> no</font>

168
00:09:02,570 --> 00:09:08,180
memory protection is involved<font color="#E5E5E5"> anymore</font>

169
00:09:05,090 --> 00:09:12,170
<font color="#E5E5E5">but definitely it is not</font><font color="#CCCCCC"> the case</font>

170
00:09:08,180 --> 00:09:14,959
why because<font color="#E5E5E5"> modern phones are first</font>

171
00:09:12,170 --> 00:09:18,319
reason is that<font color="#E5E5E5"> modern friends are 64-bit</font>

172
00:09:14,960 --> 00:09:23,240
while many of their peripheral devices

173
00:09:18,320 --> 00:09:25,990
remains 32-bit in that case address

174
00:09:23,240 --> 00:09:30,650
translation is<font color="#E5E5E5"> quite needed to trans</font>

175
00:09:25,990 --> 00:09:33,080
translate from 64-bit memory<font color="#CCCCCC"> to</font><font color="#E5E5E5"> 32-bit</font>

176
00:09:30,650 --> 00:09:36,170
memory<font color="#E5E5E5"> and there another reason is that</font>

177
00:09:33,080 --> 00:09:39,650
we have to enforce the memory protection

178
00:09:36,170 --> 00:09:43,719
for the DMA transfer also because if it

179
00:09:39,650 --> 00:09:47,240
is<font color="#CCCCCC"> not there it is not safe</font><font color="#E5E5E5"> right the</font>

180
00:09:43,720 --> 00:09:50,600
because of<font color="#E5E5E5"> this the M iommu</font><font color="#CCCCCC"> is</font>

181
00:09:47,240 --> 00:09:58,280
introduced that you perform this<font color="#CCCCCC"> job</font><font color="#E5E5E5"> io</font>

182
00:09:50,600 --> 00:10:01,730
<font color="#E5E5E5">m mu if under 30 666 bit iOS device the</font>

183
00:09:58,280 --> 00:10:03,850
<font color="#E5E5E5">concept</font><font color="#CCCCCC"> at that</font><font color="#E5E5E5"> which refers to device</font>

184
00:10:01,730 --> 00:10:06,920
<font color="#E5E5E5">address resolution table is actually</font>

185
00:10:03,850 --> 00:10:10,730
<font color="#E5E5E5">introduced and responsible to perform</font>

186
00:10:06,920 --> 00:10:14,180
such address<font color="#E5E5E5"> translation and there are</font>

187
00:10:10,730 --> 00:10:17,780
two kind of DMA one for host to device

188
00:10:14,180 --> 00:10:20,780
<font color="#E5E5E5">DMA and another for device to host the</font>

189
00:10:17,780 --> 00:10:23,480
DMA for host to<font color="#E5E5E5"> to device DMA actually</font>

190
00:10:20,780 --> 00:10:26,900
the<font color="#E5E5E5"> system physical memory is mapped</font>

191
00:10:23,480 --> 00:10:30,680
into<font color="#CCCCCC"> IO space visible by the device and</font>

192
00:10:26,900 --> 00:10:33,709
the device to host<font color="#E5E5E5"> DMA</font><font color="#CCCCCC"> it's actually</font>

193
00:10:30,680 --> 00:10:35,719
mapped the device<font color="#E5E5E5"> memory back to</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> OS</font>

194
00:10:33,710 --> 00:10:38,120
virtual memory<font color="#E5E5E5"> so that it can be</font>

195
00:10:35,720 --> 00:10:41,660
<font color="#E5E5E5">identified by</font><font color="#CCCCCC"> the operating system</font><font color="#E5E5E5"> and</font>

196
00:10:38,120 --> 00:10:45,110
<font color="#E5E5E5">in the middle 2017</font>

197
00:10:41,660 --> 00:10:48,650
Karl from Google<font color="#CCCCCC"> Protege rope</font><font color="#E5E5E5"> leverages</font>

198
00:10:45,110 --> 00:10:52,610
the EMA features on iOS to achieve the

199
00:10:48,650 --> 00:10:57,240
<font color="#CCCCCC">firmware to</font><font color="#E5E5E5"> host an attack under he</font>

200
00:10:52,610 --> 00:11:00,870
compromised the<font color="#CCCCCC"> I Wi-Fi stack first</font><font color="#E5E5E5"> and</font>

201
00:10:57,240 --> 00:11:03,930
then try to mutate<font color="#E5E5E5"> some right podium a</font>

202
00:11:00,870 --> 00:11:06,360
mapping in the<font color="#E5E5E5"> device memory and it is</font>

203
00:11:03,930 --> 00:11:10,260
<font color="#E5E5E5">also share the</font><font color="#CCCCCC"> choose our OS kernel</font>

204
00:11:06,360 --> 00:11:16,860
memory<font color="#CCCCCC"> under the OS iOS</font><font color="#E5E5E5"> thinks that</font>

205
00:11:10,260 --> 00:11:21,330
<font color="#E5E5E5">there the DMA on the</font><font color="#CCCCCC"> device is</font><font color="#E5E5E5"> possible</font>

206
00:11:16,860 --> 00:11:25,260
so it's a limited necessary boundary

207
00:11:21,330 --> 00:11:29,399
check<font color="#E5E5E5"> and finally with the</font><font color="#CCCCCC"> Wi-Fi stack</font>

208
00:11:25,260 --> 00:11:32,339
compromised<font color="#CCCCCC"> it is very</font><font color="#E5E5E5"> easy to to modify</font>

209
00:11:29,399 --> 00:11:35,279
that memory<font color="#E5E5E5"> and finally lead</font><font color="#CCCCCC"> to your</font>

210
00:11:32,339 --> 00:11:38,640
kernel code<font color="#CCCCCC"> exclusion however such</font>

211
00:11:35,279 --> 00:11:43,380
attack has some limitations<font color="#CCCCCC"> what</font><font color="#E5E5E5"> a</font>

212
00:11:38,640 --> 00:11:46,529
<font color="#E5E5E5">pervious</font><font color="#CCCCCC"> limited limitation is that such</font>

213
00:11:43,380 --> 00:11:49,649
attack<font color="#CCCCCC"> can only be performed</font><font color="#E5E5E5"> in a short</font>

214
00:11:46,529 --> 00:11:51,689
distance<font color="#E5E5E5"> that scenario because you have</font>

215
00:11:49,649 --> 00:11:54,930
to compromise the Wi-Fi stack first

216
00:11:51,690 --> 00:11:58,610
under that requires the attacker and<font color="#CCCCCC"> the</font>

217
00:11:54,930 --> 00:12:02,189
big team<font color="#E5E5E5"> in the same Wi-Fi</font><font color="#CCCCCC"> environment</font>

218
00:11:58,610 --> 00:12:04,410
<font color="#E5E5E5">is it possible for us to make</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> long</font>

219
00:12:02,190 --> 00:12:07,560
distance<font color="#E5E5E5"> for example we have a browser</font>

220
00:12:04,410 --> 00:12:10,800
exploit<font color="#E5E5E5"> we can try to launch it remotely</font>

221
00:12:07,560 --> 00:12:13,170
<font color="#E5E5E5">by the browser exploit and together with</font>

222
00:12:10,800 --> 00:12:17,189
a kernel<font color="#E5E5E5"> privilege escalation back and</font>

223
00:12:13,170 --> 00:12:21,209
of course by utilizing the DMA related

224
00:12:17,190 --> 00:12:24,510
<font color="#E5E5E5">parks</font><font color="#CCCCCC"> under that look like</font><font color="#E5E5E5"> a very crazy</font>

225
00:12:21,209 --> 00:12:26,599
idea<font color="#E5E5E5"> because the DMA features like are</font>

226
00:12:24,510 --> 00:12:30,300
kind<font color="#E5E5E5"> of very low level implementation</font>

227
00:12:26,600 --> 00:12:32,610
which<font color="#CCCCCC"> is mostly</font><font color="#E5E5E5"> performed at the kernel</font>

228
00:12:30,300 --> 00:12:35,459
level<font color="#E5E5E5"> or the device level</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> is not</font>

229
00:12:32,610 --> 00:12:39,480
exposed to chooser<font color="#E5E5E5"> you landed directly</font>

230
00:12:35,459 --> 00:12:43,619
for sure and there is it is still

231
00:12:39,480 --> 00:12:47,279
<font color="#CCCCCC">possible to</font><font color="#E5E5E5"> think of it</font><font color="#CCCCCC"> because there</font>

232
00:12:43,620 --> 00:12:51,270
might<font color="#E5E5E5"> be some incorrect user land</font><font color="#CCCCCC"> DMA</font><font color="#E5E5E5"> on</font>

233
00:12:47,279 --> 00:12:55,980
the iOS<font color="#E5E5E5"> for example it</font><font color="#CCCCCC"> on the iOS system</font>

234
00:12:51,270 --> 00:12:59,959
it has some<font color="#E5E5E5"> JPEG engine it is</font>

235
00:12:55,980 --> 00:13:02,579
<font color="#E5E5E5">responsible to</font><font color="#CCCCCC"> to accelerator the</font>

236
00:12:59,959 --> 00:13:06,060
encoding<font color="#E5E5E5"> and the decoding process and</font>

237
00:13:02,579 --> 00:13:08,849
also<font color="#E5E5E5"> in</font><font color="#CCCCCC"> another</font><font color="#E5E5E5"> scenario there is I all</font>

238
00:13:06,060 --> 00:13:11,010
surface<font color="#E5E5E5"> transform and actually it is</font>

239
00:13:08,850 --> 00:13:13,760
<font color="#E5E5E5">done by the hardware</font>

240
00:13:11,010 --> 00:13:17,189
it's called a scalar device and we were

241
00:13:13,760 --> 00:13:20,700
<font color="#E5E5E5">looking to the iOS</font><font color="#CCCCCC"> home feature</font><font color="#E5E5E5"> a little</font>

242
00:13:17,190 --> 00:13:23,010
<font color="#CCCCCC">bit under with actually</font><font color="#E5E5E5"> King labs</font>

243
00:13:20,700 --> 00:13:24,120
<font color="#E5E5E5">dependence on come to investigate their</font>

244
00:13:23,010 --> 00:13:28,410
iOS

245
00:13:24,120 --> 00:13:30,030
I also<font color="#CCCCCC"> face transform feature and before</font>

246
00:13:28,410 --> 00:13:32,910
we<font color="#E5E5E5"> study it I'd like to briefly</font>

247
00:13:30,030 --> 00:13:36,060
introduce the<font color="#CCCCCC"> iOS surface</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> the iosef</font>

248
00:13:32,910 --> 00:13:38,969
is accelerator framework some so<font color="#E5E5E5"> on the</font>

249
00:13:36,060 --> 00:13:41,819
<font color="#CCCCCC">apple what the</font><font color="#E5E5E5"> aisle surface represents</font>

250
00:13:38,970 --> 00:13:44,000
a user land buffer which is<font color="#E5E5E5"> shared with</font>

251
00:13:41,820 --> 00:13:48,150
the<font color="#E5E5E5"> kernel and the user land</font>

252
00:13:44,000 --> 00:13:51,630
<font color="#E5E5E5">applications can create a user</font><font color="#CCCCCC"> IO</font>

253
00:13:48,150 --> 00:13:53,939
<font color="#E5E5E5">surface by providing a existing user</font>

254
00:13:51,630 --> 00:13:57,420
land buffer address and its length

255
00:13:53,940 --> 00:14:00,090
so the code on the<font color="#CCCCCC"> right</font><font color="#E5E5E5"> side shows</font><font color="#CCCCCC"> the</font>

256
00:13:57,420 --> 00:14:02,520
<font color="#CCCCCC">creation process so it first gets</font><font color="#E5E5E5"> the</font>

257
00:14:00,090 --> 00:14:04,830
properties of<font color="#E5E5E5"> that user land memory and</font>

258
00:14:02,520 --> 00:14:09,150
then<font color="#E5E5E5"> Creator IO</font>

259
00:14:04,830 --> 00:14:13,290
memory descriptor with specific property

260
00:14:09,150 --> 00:14:16,199
as options so here if option<font color="#CCCCCC"> k io</font>

261
00:14:13,290 --> 00:14:19,319
<font color="#CCCCCC">direction out instead it indicates that</font>

262
00:14:16,200 --> 00:14:21,330
<font color="#E5E5E5">the user land mapping is read-only under</font>

263
00:14:19,320 --> 00:14:26,160
once the read-only mapping is a

264
00:14:21,330 --> 00:14:30,210
<font color="#CCCCCC">read/write</font><font color="#E5E5E5"> then option k io perishing</font>

265
00:14:26,160 --> 00:14:34,860
out as well as<font color="#E5E5E5"> ki out eruption in where</font>

266
00:14:30,210 --> 00:14:38,490
<font color="#CCCCCC">people step and the second framework is</font>

267
00:14:34,860 --> 00:14:41,520
the<font color="#CCCCCC"> IO surface accelerator</font><font color="#E5E5E5"> and it's a</font>

268
00:14:38,490 --> 00:14:45,480
kind of noodle and a<font color="#E5E5E5"> framework for and</font>

269
00:14:41,520 --> 00:14:48,720
it is<font color="#CCCCCC"> only existing in iOS platform and</font>

270
00:14:45,480 --> 00:14:51,660
there are two important interfaces one

271
00:14:48,720 --> 00:14:54,330
<font color="#E5E5E5">is I also</font><font color="#CCCCCC"> this accelerator create and</font>

272
00:14:51,660 --> 00:14:56,069
another is I also this accelerator

273
00:14:54,330 --> 00:14:58,710
transfer service

274
00:14:56,070 --> 00:15:01,710
the first one is responsible<font color="#CCCCCC"> for</font>

275
00:14:58,710 --> 00:15:05,150
creating<font color="#CCCCCC"> I will kill the plant</font>

276
00:15:01,710 --> 00:15:08,190
connection representing our<font color="#CCCCCC"> i/o surface</font>

277
00:15:05,150 --> 00:15:12,300
<font color="#E5E5E5">accelerator client could</font><font color="#CCCCCC"> object under</font>

278
00:15:08,190 --> 00:15:14,760
the second interface<font color="#E5E5E5"> well takes to our</font>

279
00:15:12,300 --> 00:15:16,829
old<font color="#CCCCCC"> service tap handles</font><font color="#E5E5E5"> one for the saw</font>

280
00:15:14,760 --> 00:15:18,750
Silas office and the other for<font color="#CCCCCC"> the</font>

281
00:15:16,830 --> 00:15:23,240
destination<font color="#E5E5E5"> and the</font><font color="#CCCCCC"> build a transform</font>

282
00:15:18,750 --> 00:15:25,520
and there is one typical scenario of you

283
00:15:23,240 --> 00:15:29,240
using this<font color="#CCCCCC"> remote which is</font><font color="#E5E5E5"> the screen</font>

284
00:15:25,520 --> 00:15:33,500
snapshot where you have your destination

285
00:15:29,240 --> 00:15:36,020
I also<font color="#CCCCCC"> service as receiving buffer under</font>

286
00:15:33,500 --> 00:15:38,570
the system mem<font color="#E5E5E5"> tensor</font><font color="#CCCCCC"> I also face the</font>

287
00:15:36,020 --> 00:15:41,060
<font color="#E5E5E5">photo frame buffer and</font><font color="#CCCCCC"> you make this</font>

288
00:15:38,570 --> 00:15:47,570
transfer<font color="#CCCCCC"> and you can get to a screenshot</font>

289
00:15:41,060 --> 00:15:50,390
<font color="#CCCCCC">of</font><font color="#E5E5E5"> it of your current</font><font color="#CCCCCC"> - screen and</font><font color="#E5E5E5"> here</font>

290
00:15:47,570 --> 00:15:53,630
is the low level implementation of the

291
00:15:50,390 --> 00:15:57,709
<font color="#E5E5E5">i/o surface patch accelerator so on the</font>

292
00:15:53,630 --> 00:16:02,950
top side you can see<font color="#E5E5E5"> there is a object</font>

293
00:15:57,709 --> 00:16:07,040
called<font color="#E5E5E5"> IO surface accelerator</font><font color="#CCCCCC"> plant so</font>

294
00:16:02,950 --> 00:16:10,459
<font color="#E5E5E5">under the next component is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> Apple mq</font>

295
00:16:07,040 --> 00:16:13,670
<font color="#E5E5E5">scanner CSC which is a upper level</font>

296
00:16:10,459 --> 00:16:15,969
driver<font color="#E5E5E5"> and it talks to the</font><font color="#CCCCCC"> hole</font><font color="#E5E5E5"> which</font>

297
00:16:13,670 --> 00:16:19,189
stands for<font color="#CCCCCC"> Hardware</font><font color="#E5E5E5"> of a structuring</font>

298
00:16:15,970 --> 00:16:22,130
abstract level<font color="#E5E5E5"> and the latter handles</font>

299
00:16:19,190 --> 00:16:25,490
the device<font color="#CCCCCC"> independent dependent stuff</font>

300
00:16:22,130 --> 00:16:29,770
and<font color="#E5E5E5"> the</font><font color="#CCCCCC"> provided that device independent</font>

301
00:16:25,490 --> 00:16:33,500
interface to the driver<font color="#E5E5E5"> under</font><font color="#CCCCCC"> this</font>

302
00:16:29,770 --> 00:16:36,560
device<font color="#E5E5E5"> for object also creates five</font>

303
00:16:33,500 --> 00:16:39,350
important objects which stand for<font color="#E5E5E5"> some</font>

304
00:16:36,560 --> 00:16:44,029
important registers for<font color="#E5E5E5"> that device and</font>

305
00:16:39,350 --> 00:16:47,959
<font color="#E5E5E5">that object</font><font color="#CCCCCC"> Paul also</font><font color="#E5E5E5"> maps a device</font>

306
00:16:44,029 --> 00:16:50,410
memory<font color="#E5E5E5"> from</font><font color="#CCCCCC"> the device IO space into the</font>

307
00:16:47,959 --> 00:16:55,000
<font color="#E5E5E5">kernel virtual space we</font><font color="#CCCCCC"> are DMA</font>

308
00:16:50,410 --> 00:17:00,170
represents that the<font color="#E5E5E5"> device</font><font color="#CCCCCC"> key registers</font>

309
00:16:55,000 --> 00:17:04,069
<font color="#E5E5E5">so here is the overall flow for the</font>

310
00:17:00,170 --> 00:17:07,399
transform the first is the kernel<font color="#CCCCCC"> where</font>

311
00:17:04,069 --> 00:17:10,309
<font color="#E5E5E5">validates the parameter from the unified</font>

312
00:17:07,400 --> 00:17:12,709
user land and then it<font color="#E5E5E5"> obtains the source</font>

313
00:17:10,309 --> 00:17:16,040
and the destination<font color="#E5E5E5"> IO surface address</font>

314
00:17:12,709 --> 00:17:19,880
and then it mapped the iOS<font color="#E5E5E5"> our</font><font color="#CCCCCC"> surface</font>

315
00:17:16,040 --> 00:17:23,899
buffer where DMA under then it obtains<font color="#CCCCCC"> a</font>

316
00:17:19,880 --> 00:17:26,540
mapped<font color="#E5E5E5"> address and set some buffer the</font>

317
00:17:23,900 --> 00:17:29,510
device buffer and then it has thoughts

318
00:17:26,540 --> 00:17:32,418
<font color="#E5E5E5">scalar device and after the scalar</font>

319
00:17:29,510 --> 00:17:33,720
<font color="#E5E5E5">device is started then the kernel wait</font>

320
00:17:32,419 --> 00:17:37,620
for the<font color="#E5E5E5"> interrupt</font>

321
00:17:33,720 --> 00:17:40,080
from the device to<font color="#E5E5E5"> wait for its</font>

322
00:17:37,620 --> 00:17:43,860
completeness<font color="#E5E5E5"> and after it is complete</font>

323
00:17:40,080 --> 00:17:47,070
<font color="#E5E5E5">everything is finished</font><font color="#CCCCCC"> so we are mostly</font>

324
00:17:43,860 --> 00:17:49,439
<font color="#E5E5E5">interested on the DMA mapping part and</font>

325
00:17:47,070 --> 00:17:51,779
we<font color="#E5E5E5"> are not interested</font><font color="#CCCCCC"> in other part so</font>

326
00:17:49,440 --> 00:17:55,679
this is actually bound by the function

327
00:17:51,779 --> 00:17:58,110
set map prepared<font color="#CCCCCC"> a memory descriptor</font><font color="#E5E5E5"> and</font>

328
00:17:55,679 --> 00:18:01,679
the years at function code you can see

329
00:17:58,110 --> 00:18:04,918
<font color="#CCCCCC">that a kernel object called</font><font color="#E5E5E5"> IO DMA</font>

330
00:18:01,679 --> 00:18:08,429
account created<font color="#E5E5E5"> created with a very</font>

331
00:18:04,919 --> 00:18:11,490
special IO mapper<font color="#E5E5E5"> and actually that</font>

332
00:18:08,429 --> 00:18:14,070
mapper<font color="#E5E5E5"> is the instance of ioad part</font>

333
00:18:11,490 --> 00:18:17,129
mapper<font color="#E5E5E5"> which is independent between</font>

334
00:18:14,070 --> 00:18:20,189
<font color="#E5E5E5">devices to make sure that device and the</font>

335
00:18:17,129 --> 00:18:22,469
device are separated in separated

336
00:18:20,190 --> 00:18:25,379
reading<font color="#CCCCCC"> i all space addresses so that</font>

337
00:18:22,470 --> 00:18:29,009
<font color="#E5E5E5">one can not interfere</font><font color="#CCCCCC"> another and the</font>

338
00:18:25,379 --> 00:18:32,428
using a very<font color="#E5E5E5"> basic I Oh s utility called</font>

339
00:18:29,009 --> 00:18:35,779
<font color="#E5E5E5">IO rec you can find this instance the</font>

340
00:18:32,429 --> 00:18:38,039
map<font color="#E5E5E5"> instance for the dart</font><font color="#CCCCCC"> scaler</font>

341
00:18:35,779 --> 00:18:41,460
under then the IO

342
00:18:38,039 --> 00:18:45,450
surface memory descriptive descriptor

343
00:18:41,460 --> 00:18:49,889
will be<font color="#CCCCCC"> pointed to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> i/o DMX Mountain</font>

344
00:18:45,450 --> 00:18:53,360
<font color="#E5E5E5">and the next step is to obtain mapped</font>

345
00:18:49,889 --> 00:18:57,289
i/o<font color="#E5E5E5"> surface address in the i/o space</font>

346
00:18:53,360 --> 00:19:01,110
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is done by the calling</font><font color="#CCCCCC"> the function</font>

347
00:18:57,289 --> 00:19:04,110
generate IO<font color="#E5E5E5"> VM segments after you call</font>

348
00:19:01,110 --> 00:19:07,289
this function<font color="#E5E5E5"> you obtain</font><font color="#CCCCCC"> that address</font>

349
00:19:04,110 --> 00:19:11,279
and you can<font color="#CCCCCC"> note notice</font><font color="#E5E5E5"> that this race</font>

350
00:19:07,289 --> 00:19:15,539
<font color="#E5E5E5">tree indicates the result address which</font>

351
00:19:11,279 --> 00:19:19,110
<font color="#E5E5E5">is being 32-bit and after you create the</font>

352
00:19:15,539 --> 00:19:22,169
<font color="#E5E5E5">source and the destination iOS iOS</font>

353
00:19:19,110 --> 00:19:26,870
office address in<font color="#E5E5E5"> IO space it's time</font><font color="#CCCCCC"> to</font>

354
00:19:22,169 --> 00:19:30,960
<font color="#CCCCCC">set the scalar device register</font><font color="#E5E5E5"> the key</font>

355
00:19:26,870 --> 00:19:33,989
register is for<font color="#E5E5E5"> South Texas destination</font>

356
00:19:30,960 --> 00:19:37,980
config<font color="#CCCCCC"> consume</font><font color="#E5E5E5"> this object is used that</font>

357
00:19:33,990 --> 00:19:41,639
<font color="#CCCCCC">you specify those addresses under once</font>

358
00:19:37,980 --> 00:19:46,410
do<font color="#E5E5E5"> you decide those addresses you just</font>

359
00:19:41,639 --> 00:19:51,370
changes or<font color="#E5E5E5"> you specify it so we are</font>

360
00:19:46,410 --> 00:19:54,930
giving some real value<font color="#E5E5E5"> understating to</font>

361
00:19:51,370 --> 00:19:58,689
some specific offset in that<font color="#CCCCCC"> mapped</font>

362
00:19:54,930 --> 00:20:02,170
<font color="#E5E5E5">virtual memory and after that this is</font>

363
00:19:58,690 --> 00:20:04,390
<font color="#E5E5E5">done and the final thing is</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> start to</font>

364
00:20:02,170 --> 00:20:09,670
the<font color="#E5E5E5"> scalar this is very easy you just</font>

365
00:20:04,390 --> 00:20:14,410
need<font color="#E5E5E5"> to stare to one which indicates the</font>

366
00:20:09,670 --> 00:20:17,710
<font color="#E5E5E5">power of option at the</font><font color="#CCCCCC"> offsets of 1 to 8</font>

367
00:20:14,410 --> 00:20:21,040
<font color="#E5E5E5">and there</font><font color="#CCCCCC"> after you make that value</font><font color="#E5E5E5"> to 1</font>

368
00:20:17,710 --> 00:20:24,190
the scalar device starts<font color="#E5E5E5"> it's working it</font>

369
00:20:21,040 --> 00:20:27,340
starts its work immediately<font color="#CCCCCC"> and the</font>

370
00:20:24,190 --> 00:20:29,710
final<font color="#E5E5E5"> thing is for</font><font color="#CCCCCC"> Colonel</font><font color="#E5E5E5"> to wait for</font>

371
00:20:27,340 --> 00:20:33,580
<font color="#E5E5E5">that device to finish working</font><font color="#CCCCCC"> and the</font>

372
00:20:29,710 --> 00:20:37,450
issue<font color="#CCCCCC"> interrupter event</font><font color="#E5E5E5"> to indicate that</font>

373
00:20:33,580 --> 00:20:40,389
<font color="#E5E5E5">this has been done</font><font color="#CCCCCC"> okay so the next</font><font color="#E5E5E5"> part</font>

374
00:20:37,450 --> 00:20:45,310
I will<font color="#CCCCCC"> cover for the iommu memory</font>

375
00:20:40,390 --> 00:20:48,520
protection so similar as<font color="#CCCCCC"> the system</font><font color="#E5E5E5"> mme</font>

376
00:20:45,310 --> 00:20:51,460
<font color="#E5E5E5">you page table the iowa</font><font color="#CCCCCC"> mm you also need</font>

377
00:20:48,520 --> 00:20:55,780
to have<font color="#E5E5E5"> the page table specification</font>

378
00:20:51,460 --> 00:21:00,550
however unlike<font color="#E5E5E5"> the</font><font color="#CCCCCC"> cv cpu MMU</font><font color="#E5E5E5"> the page</font>

379
00:20:55,780 --> 00:21:05,110
table document for iommu is not there<font color="#E5E5E5"> so</font>

380
00:21:00,550 --> 00:21:08,649
you<font color="#CCCCCC"> have to reverse</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> iOS</font><font color="#E5E5E5"> part code to</font>

381
00:21:05,110 --> 00:21:12,659
find<font color="#E5E5E5"> out as a specification and we did</font>

382
00:21:08,650 --> 00:21:16,330
it<font color="#CCCCCC"> also and the</font><font color="#E5E5E5"> coincidently call from</font>

383
00:21:12,660 --> 00:21:19,120
project<font color="#E5E5E5"> zero</font><font color="#CCCCCC"> google</font><font color="#E5E5E5"> project zero also he</font>

384
00:21:16,330 --> 00:21:22,510
did a similar work and here<font color="#E5E5E5"> I just put</font><font color="#CCCCCC"> a</font>

385
00:21:19,120 --> 00:21:24,790
<font color="#E5E5E5">picture or written by him on the</font><font color="#CCCCCC"> right</font>

386
00:21:22,510 --> 00:21:30,340
side you<font color="#CCCCCC"> can see</font><font color="#E5E5E5"> that it has</font><font color="#CCCCCC"> very</font>

387
00:21:24,790 --> 00:21:32,770
<font color="#E5E5E5">similar specification as CPU</font><font color="#CCCCCC"> MMU however</font>

388
00:21:30,340 --> 00:21:37,179
in his blog<font color="#E5E5E5"> he didn't mention that</font>

389
00:21:32,770 --> 00:21:40,330
<font color="#E5E5E5">whether as iommu supports</font><font color="#CCCCCC"> the memory</font>

390
00:21:37,180 --> 00:21:43,690
protection or not<font color="#E5E5E5"> so here is a piece of</font>

391
00:21:40,330 --> 00:21:47,460
<font color="#E5E5E5">his block he said it is unknown whether</font>

392
00:21:43,690 --> 00:21:50,950
it is it came facility<font color="#E5E5E5"> the user</font>

393
00:21:47,460 --> 00:21:55,240
<font color="#E5E5E5">read-only mappings</font><font color="#CCCCCC"> however</font><font color="#E5E5E5"> actually by</font>

394
00:21:50,950 --> 00:21:59,020
reversing the coding<font color="#E5E5E5"> iOS 11 we can get</font>

395
00:21:55,240 --> 00:21:59,800
to the answer<font color="#E5E5E5"> so I will be a map memory</font>

396
00:21:59,020 --> 00:22:03,550
function is

397
00:21:59,800 --> 00:22:07,899
entry<font color="#E5E5E5"> point for mapping the memory in</font><font color="#CCCCCC"> IO</font>

398
00:22:03,550 --> 00:22:12,280
<font color="#CCCCCC">space among which map options parameter</font>

399
00:22:07,900 --> 00:22:14,680
here<font color="#E5E5E5"> has included the memories</font>

400
00:22:12,280 --> 00:22:18,190
protection<font color="#E5E5E5"> bit seeing of virtual space</font>

401
00:22:14,680 --> 00:22:21,550
so here the<font color="#E5E5E5"> last repeat seeing that map</font>

402
00:22:18,190 --> 00:22:25,060
options is translated to a<font color="#CCCCCC"> Direction</font>

403
00:22:21,550 --> 00:22:27,730
value of visible by the<font color="#E5E5E5"> iommu</font><font color="#CCCCCC"> so here</font>

404
00:22:25,060 --> 00:22:30,250
for<font color="#E5E5E5"> read-only mappings it has the</font>

405
00:22:27,730 --> 00:22:32,260
<font color="#E5E5E5">direction</font><font color="#CCCCCC"> value to and the right</font><font color="#E5E5E5"> only</font>

406
00:22:30,250 --> 00:22:34,750
mapping has the value 1<font color="#CCCCCC"> and the read and</font>

407
00:22:32,260 --> 00:22:37,780
the write mapping has the value 3<font color="#CCCCCC"> we</font>

408
00:22:34,750 --> 00:22:41,440
only<font color="#CCCCCC"> needed to remember this</font><font color="#E5E5E5"> and these</font>

409
00:22:37,780 --> 00:22:45,250
<font color="#E5E5E5">of arrival finally reach the lower level</font>

410
00:22:41,440 --> 00:22:48,000
implementation part under a function for

411
00:22:45,250 --> 00:22:52,380
the<font color="#E5E5E5"> state translation is finally reached</font>

412
00:22:48,000 --> 00:22:56,500
under from the code<font color="#CCCCCC"> logic</font><font color="#E5E5E5"> here we can</font>

413
00:22:52,380 --> 00:23:03,000
clearly see<font color="#CCCCCC"> that actually the 8 and</font><font color="#E5E5E5"> the</font>

414
00:22:56,500 --> 00:23:03,000
nice bit in the<font color="#CCCCCC"> TT</font><font color="#E5E5E5"> entry</font><font color="#CCCCCC"> ap related bits</font>

415
00:23:03,210 --> 00:23:11,740
so finally we got the<font color="#E5E5E5"> access protection</font>

416
00:23:07,890 --> 00:23:16,240
specification in ki te<font color="#E5E5E5"> for iommu</font><font color="#CCCCCC"> on iOS</font>

417
00:23:11,740 --> 00:23:18,400
<font color="#E5E5E5">so here the red part is AP bits and the</font>

418
00:23:16,240 --> 00:23:21,370
arrow that will stand for read<font color="#CCCCCC"> and write</font>

419
00:23:18,400 --> 00:23:25,810
<font color="#E5E5E5">there one read only and</font><font color="#CCCCCC"> one zero right</font>

420
00:23:21,370 --> 00:23:30,070
<font color="#CCCCCC">on deck next we talk about</font><font color="#E5E5E5"> the GPU</font>

421
00:23:25,810 --> 00:23:33,250
notification mechanism under<font color="#CCCCCC"> our</font><font color="#E5E5E5"> iPhone</font>

422
00:23:30,070 --> 00:23:37,510
7 device<font color="#E5E5E5"> we found that Apple graphics</font>

423
00:23:33,250 --> 00:23:40,870
provides with<font color="#CCCCCC"> 128 channels for</font>

424
00:23:37,510 --> 00:23:44,290
concurrent processing those channels are

425
00:23:40,870 --> 00:23:46,570
have three categories<font color="#E5E5E5"> CL</font><font color="#CCCCCC"> channel GL</font>

426
00:23:44,290 --> 00:23:49,420
<font color="#CCCCCC">Channel and the GI Channel and the</font>

427
00:23:46,570 --> 00:23:52,000
kernel wraps<font color="#E5E5E5"> join instructions from</font>

428
00:23:49,420 --> 00:23:54,910
<font color="#CCCCCC">userland</font><font color="#E5E5E5"> and put them into those</font>

429
00:23:52,000 --> 00:23:58,240
<font color="#E5E5E5">channels and then kernel just wait for</font>

430
00:23:54,910 --> 00:24:01,090
the GPU<font color="#E5E5E5"> to finish processing because of</font>

431
00:23:58,240 --> 00:24:03,900
that a<font color="#E5E5E5"> well designed the notification</font>

432
00:24:01,090 --> 00:24:08,080
mechanism is very<font color="#E5E5E5"> necessary because</font>

433
00:24:03,900 --> 00:24:13,140
it'll<font color="#E5E5E5"> need</font><font color="#CCCCCC"> to support for such high high</font>

434
00:24:08,080 --> 00:24:16,139
need for concurrent processing here is a

435
00:24:13,140 --> 00:24:19,530
Bree<font color="#E5E5E5"> brief architecture of the</font>

436
00:24:16,140 --> 00:24:22,590
notification<font color="#E5E5E5"> the</font><font color="#CCCCCC"> GPU</font><font color="#E5E5E5"> task actually</font><font color="#CCCCCC"> earns</font>

437
00:24:19,530 --> 00:24:26,670
us temporary representing<font color="#E5E5E5"> our temple</font>

438
00:24:22,590 --> 00:24:30,090
status of each<font color="#CCCCCC"> channel</font><font color="#E5E5E5"> so this memory is</font>

439
00:24:26,670 --> 00:24:34,170
actually<font color="#E5E5E5"> a representation</font><font color="#CCCCCC"> of the</font><font color="#E5E5E5"> uint32</font>

440
00:24:30,090 --> 00:24:37,409
<font color="#CCCCCC">agree of</font><font color="#E5E5E5"> 100 under 28 elements each</font>

441
00:24:34,170 --> 00:24:41,460
<font color="#E5E5E5">showing the last complete instructions</font>

442
00:24:37,410 --> 00:24:44,309
step of<font color="#CCCCCC"> that channel and this stamp</font>

443
00:24:41,460 --> 00:24:47,010
<font color="#CCCCCC">array</font><font color="#E5E5E5"> memory is actually mapped not only</font>

444
00:24:44,309 --> 00:24:49,320
to the<font color="#E5E5E5"> kernel but also to the userland</font>

445
00:24:47,010 --> 00:24:54,750
<font color="#E5E5E5">and of course the</font><font color="#CCCCCC"> EULA</font><font color="#E5E5E5"> land mapping is</font>

446
00:24:49,320 --> 00:24:57,389
<font color="#E5E5E5">read-only and the kernel also maintains</font>

447
00:24:54,750 --> 00:25:01,080
a rake or the stamp<font color="#E5E5E5"> address array and</font>

448
00:24:57,390 --> 00:25:05,309
this array<font color="#E5E5E5"> is very simply constructed by</font>

449
00:25:01,080 --> 00:25:10,500
the<font color="#E5E5E5"> coder below under it</font>

450
00:25:05,309 --> 00:25:13,889
it contains address array of 128

451
00:25:10,500 --> 00:25:17,850
elements and each element represents the

452
00:25:13,890 --> 00:25:23,700
virtual address of that<font color="#E5E5E5"> mapped</font><font color="#CCCCCC"> stamp</font>

453
00:25:17,850 --> 00:25:26,760
<font color="#E5E5E5">stators kernel address under the stamp</font>

454
00:25:23,700 --> 00:25:30,120
value of each channel is incremental

455
00:25:26,760 --> 00:25:32,960
upon each of<font color="#E5E5E5"> the instruction processing</font>

456
00:25:30,120 --> 00:25:38,129
completeness<font color="#E5E5E5"> which means once the</font>

457
00:25:32,960 --> 00:25:43,710
<font color="#E5E5E5">processing is completed then the GPU we</font>

458
00:25:38,130 --> 00:25:47,760
are<font color="#CCCCCC"> update</font><font color="#E5E5E5"> that stamp value add it by 1</font>

459
00:25:43,710 --> 00:25:51,570
and the in the kernel<font color="#CCCCCC"> side</font><font color="#E5E5E5"> there is</font><font color="#CCCCCC"> also</font>

460
00:25:47,760 --> 00:25:55,770
<font color="#CCCCCC">a</font><font color="#E5E5E5"> object called IO axial event which</font>

461
00:25:51,570 --> 00:25:59,340
represents the<font color="#E5E5E5"> expected extent value</font>

462
00:25:55,770 --> 00:26:01,139
being specific channel of one or one

463
00:25:59,340 --> 00:26:05,909
group of<font color="#E5E5E5"> joying</font>

464
00:26:01,140 --> 00:26:09,240
instructions so one axial event<font color="#CCCCCC"> IO axial</font>

465
00:26:05,910 --> 00:26:12,210
event contains<font color="#CCCCCC"> eight sub events and one</font>

466
00:26:09,240 --> 00:26:15,450
sub event is<font color="#E5E5E5"> eight bytes in sites where</font>

467
00:26:12,210 --> 00:26:18,570
it's lower for pipes represents<font color="#E5E5E5"> the</font>

468
00:26:15,450 --> 00:26:21,789
channel index and the higher 4 bytes

469
00:26:18,570 --> 00:26:24,428
represents the expected

470
00:26:21,789 --> 00:26:28,658
<font color="#CCCCCC">and</font><font color="#E5E5E5"> temple you of that</font><font color="#CCCCCC"> joy</font><font color="#E5E5E5"> instruction</font>

471
00:26:24,429 --> 00:26:32,229
<font color="#E5E5E5">so to test whether a jury instruction</font>

472
00:26:28,659 --> 00:26:36,309
has been<font color="#E5E5E5"> completed or not you just need</font>

473
00:26:32,229 --> 00:26:39,879
to compare the extent<font color="#E5E5E5"> expected temper</font>

474
00:26:36,309 --> 00:26:42,820
value with the value<font color="#E5E5E5"> in</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> temporary</font>

475
00:26:39,879 --> 00:26:45,549
<font color="#E5E5E5">so here is a code it's check whether</font>

476
00:26:42,820 --> 00:26:50,830
expect a stamp<font color="#E5E5E5"> is higher than the</font>

477
00:26:45,549 --> 00:26:54,099
current last<font color="#E5E5E5"> completed in</font><font color="#CCCCCC"> stamp</font><font color="#E5E5E5"> value if</font>

478
00:26:50,830 --> 00:26:56,889
it is<font color="#E5E5E5"> higher then it continues the</font>

479
00:26:54,099 --> 00:27:00,399
waiting process in the<font color="#E5E5E5"> loop in either</font>

480
00:26:56,889 --> 00:27:03,879
loop<font color="#CCCCCC"> but if it is smaller or equal</font><font color="#E5E5E5"> it</font>

481
00:27:00,399 --> 00:27:08,139
means that<font color="#CCCCCC"> joinings instruction has</font>

482
00:27:03,879 --> 00:27:11,408
already been<font color="#E5E5E5"> finished last but not the</font>

483
00:27:08,139 --> 00:27:15,189
least<font color="#E5E5E5"> to improve the performance the</font><font color="#CCCCCC"> I</font>

484
00:27:11,409 --> 00:27:18,099
<font color="#E5E5E5">some of</font><font color="#CCCCCC"> the io axial event object are</font>

485
00:27:15,190 --> 00:27:21,909
also<font color="#E5E5E5"> mapped into the userland which is</font>

486
00:27:18,099 --> 00:27:24,299
highly related to<font color="#E5E5E5"> our part this</font><font color="#CCCCCC"> is to</font>

487
00:27:21,909 --> 00:27:27,399
make sure<font color="#CCCCCC"> that the user land</font>

488
00:27:24,299 --> 00:27:30,940
applications can understand the<font color="#E5E5E5"> status</font>

489
00:27:27,399 --> 00:27:33,518
of the current current instruction and<font color="#E5E5E5"> a</font>

490
00:27:30,940 --> 00:27:35,349
<font color="#E5E5E5">la current event</font><font color="#CCCCCC"> without</font><font color="#E5E5E5"> asking the</font>

491
00:27:33,519 --> 00:27:38,349
curve of soldier the userland

492
00:27:35,349 --> 00:27:42,309
<font color="#E5E5E5">a PP can also test whether the event had</font>

493
00:27:38,349 --> 00:27:45,549
has been<font color="#E5E5E5"> completed or</font><font color="#CCCCCC"> not okay</font><font color="#E5E5E5"> now with</font>

494
00:27:42,309 --> 00:27:48,599
almost<font color="#E5E5E5"> all the concepts we are explained</font>

495
00:27:45,549 --> 00:27:51,190
let's discuss about<font color="#E5E5E5"> the real</font>

496
00:27:48,599 --> 00:27:53,619
vulnerabilities so the first<font color="#E5E5E5"> of all</font>

497
00:27:51,190 --> 00:27:59,320
<font color="#E5E5E5">ability is quite simple and they're</font>

498
00:27:53,619 --> 00:28:03,369
obvious<font color="#CCCCCC"> is</font><font color="#E5E5E5"> 10 and the early beta of iOS</font>

499
00:27:59,320 --> 00:28:06,249
<font color="#E5E5E5">11 actually</font><font color="#CCCCCC"> the map options of the</font>

500
00:28:03,369 --> 00:28:09,699
virtual memory<font color="#E5E5E5"> is simply ignored by the</font>

501
00:28:06,249 --> 00:28:13,029
<font color="#CCCCCC">thought mapper</font><font color="#E5E5E5"> so from the code below</font>

502
00:28:09,700 --> 00:28:16,029
<font color="#E5E5E5">you</font><font color="#CCCCCC"> can see</font><font color="#E5E5E5"> that in the third code</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> OBM</font>

503
00:28:13,029 --> 00:28:19,389
a<font color="#E5E5E5"> lock there is an option called map</font>

504
00:28:16,029 --> 00:28:21,549
options which indicates<font color="#E5E5E5"> accept</font>

505
00:28:19,389 --> 00:28:25,178
<font color="#E5E5E5">protection bits of the virtual</font><font color="#CCCCCC"> memory</font>

506
00:28:21,549 --> 00:28:29,440
and this parameter<font color="#E5E5E5"> is never used later</font>

507
00:28:25,179 --> 00:28:33,170
<font color="#E5E5E5">in</font><font color="#CCCCCC"> that function</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> the lower level</font>

508
00:28:29,440 --> 00:28:36,510
implementation<font color="#CCCCCC"> when the</font>

509
00:28:33,170 --> 00:28:39,780
translation<font color="#E5E5E5"> Asia is caught you can fund</font>

510
00:28:36,510 --> 00:28:43,280
that to the<font color="#CCCCCC"> 8</font><font color="#E5E5E5"> spite and a bit and the</font>

511
00:28:39,780 --> 00:28:46,500
<font color="#CCCCCC">night bit of the tte</font><font color="#E5E5E5"> apples</font><font color="#CCCCCC"> set</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> zero</font>

512
00:28:43,280 --> 00:28:49,410
<font color="#E5E5E5">which indicates from our previous</font>

513
00:28:46,500 --> 00:28:54,420
research<font color="#CCCCCC"> their</font><font color="#E5E5E5"> own</font><font color="#CCCCCC"> vero means the read</font>

514
00:28:49,410 --> 00:28:56,370
and<font color="#E5E5E5"> write</font><font color="#CCCCCC"> it means for</font><font color="#E5E5E5"> any kind of user</font>

515
00:28:54,420 --> 00:28:59,850
land mappings<font color="#E5E5E5"> or</font><font color="#CCCCCC"> colonel at inland</font>

516
00:28:56,370 --> 00:29:03,060
mappings<font color="#E5E5E5"> once it</font><font color="#CCCCCC"> is translated and</font>

517
00:28:59,850 --> 00:29:07,500
mapped into the i/o space<font color="#E5E5E5"> it</font><font color="#CCCCCC"> is always</font>

518
00:29:03,060 --> 00:29:10,200
read on the right and the second is out

519
00:29:07,500 --> 00:29:12,780
of<font color="#CCCCCC"> point of</font><font color="#E5E5E5"> bright vulnerability so</font>

520
00:29:10,200 --> 00:29:15,360
before I talk about<font color="#E5E5E5"> it</font><font color="#CCCCCC"> I will</font><font color="#E5E5E5"> explain</font>

521
00:29:12,780 --> 00:29:17,879
the<font color="#CCCCCC"> concept of the i/o axial resource</font>

522
00:29:15,360 --> 00:29:20,520
object<font color="#CCCCCC"> actually I</font><font color="#E5E5E5"> lack sale resource</font>

523
00:29:17,880 --> 00:29:23,430
object is very similar in functionality

524
00:29:20,520 --> 00:29:26,550
as<font color="#CCCCCC"> the aisle surface object</font><font color="#E5E5E5"> except that</font>

525
00:29:23,430 --> 00:29:28,530
I will axial resource which presents a

526
00:29:26,550 --> 00:29:32,159
share the<font color="#E5E5E5"> New Zealand</font><font color="#CCCCCC"> buffer which would</font>

527
00:29:28,530 --> 00:29:35,310
be mapped into the GPU<font color="#CCCCCC"> tasks and like</font>

528
00:29:32,160 --> 00:29:38,580
the<font color="#E5E5E5"> iOS our service object we can also</font>

529
00:29:35,310 --> 00:29:41,790
create the IO IO axial resource<font color="#CCCCCC"> object</font>

530
00:29:38,580 --> 00:29:45,270
by specifying<font color="#CCCCCC"> an existing noodle and</font>

531
00:29:41,790 --> 00:29:50,450
buffer<font color="#CCCCCC"> wings are Uhland applications</font>

532
00:29:45,270 --> 00:29:54,060
under<font color="#E5E5E5"> during the initialization process</font>

533
00:29:50,450 --> 00:29:57,180
<font color="#CCCCCC">share the mapping will be created this</font>

534
00:29:54,060 --> 00:30:02,940
shared mapping is called<font color="#CCCCCC"> IO axial and</font>

535
00:29:57,180 --> 00:30:06,350
shared IO under this object<font color="#E5E5E5"> contains</font><font color="#CCCCCC"> io</font>

536
00:30:02,940 --> 00:30:09,240
<font color="#E5E5E5">axial event array with</font><font color="#CCCCCC"> 4 elements</font><font color="#E5E5E5"> with</font>

537
00:30:06,350 --> 00:30:12,810
<font color="#E5E5E5">the resource ID under its type</font>

538
00:30:09,240 --> 00:30:15,570
<font color="#CCCCCC">information under this object the whole</font>

539
00:30:12,810 --> 00:30:17,879
<font color="#E5E5E5">object is mapped</font><font color="#CCCCCC"> into</font><font color="#E5E5E5"> post noodle and</font>

540
00:30:15,570 --> 00:30:20,909
<font color="#E5E5E5">Andrew kernel and of course the noodle</font>

541
00:30:17,880 --> 00:30:23,220
and mapping is<font color="#CCCCCC"> read-only</font><font color="#E5E5E5"> and this</font>

542
00:30:20,910 --> 00:30:26,130
address will also be returned to the

543
00:30:23,220 --> 00:30:32,760
user<font color="#CCCCCC"> land application</font><font color="#E5E5E5"> so the user will</font>

544
00:30:26,130 --> 00:30:36,090
<font color="#E5E5E5">know the trace of it and the user user</font>

545
00:30:32,760 --> 00:30:39,390
<font color="#E5E5E5">application can</font><font color="#CCCCCC"> also delete the created</font>

546
00:30:36,090 --> 00:30:42,500
<font color="#CCCCCC">io</font><font color="#E5E5E5"> axial results by calling the method 1</font>

547
00:30:39,390 --> 00:30:46,050
<font color="#E5E5E5">in IO axial share</font><font color="#CCCCCC"> do you LaPlante</font>

548
00:30:42,500 --> 00:30:48,330
<font color="#CCCCCC">under after that the test event function</font>

549
00:30:46,050 --> 00:30:54,180
well<font color="#E5E5E5"> being reached under this</font><font color="#CCCCCC"> function</font>

550
00:30:48,330 --> 00:30:57,120
actually<font color="#E5E5E5"> simply checks which if each i/o</font>

551
00:30:54,180 --> 00:31:00,390
axial event<font color="#CCCCCC"> objecting IO axial</font><font color="#E5E5E5"> and</font>

552
00:30:57,120 --> 00:31:03,360
shared ro is completed or<font color="#CCCCCC"> not the coda</font>

553
00:31:00,390 --> 00:31:05,930
logic is quite simple<font color="#E5E5E5"> so first it check</font>

554
00:31:03,360 --> 00:31:10,350
whether the events expect

555
00:31:05,930 --> 00:31:13,560
<font color="#CCCCCC">stamp is lower than the current temp</font>

556
00:31:10,350 --> 00:31:17,070
<font color="#E5E5E5">maintained during</font><font color="#CCCCCC"> a object called em in</font>

557
00:31:13,560 --> 00:31:22,080
line array and if yes then it means the

558
00:31:17,070 --> 00:31:25,800
<font color="#E5E5E5">event has</font><font color="#CCCCCC"> been completed yeah and if not</font>

559
00:31:22,080 --> 00:31:28,949
then the code<font color="#CCCCCC"> tried to</font><font color="#E5E5E5"> fetch the latest</font>

560
00:31:25,800 --> 00:31:32,760
<font color="#E5E5E5">stamp of value from the device memory</font>

561
00:31:28,950 --> 00:31:37,020
which is<font color="#E5E5E5"> referred to by</font><font color="#CCCCCC"> other array</font><font color="#E5E5E5"> M</font>

562
00:31:32,760 --> 00:31:39,570
stamp<font color="#E5E5E5"> address every and the after the</font>

563
00:31:37,020 --> 00:31:44,160
latest<font color="#E5E5E5"> value has been obtained</font>

564
00:31:39,570 --> 00:31:47,610
it's a builder comparison again in to do

565
00:31:44,160 --> 00:31:50,820
the comparison again and the check<font color="#E5E5E5"> if it</font>

566
00:31:47,610 --> 00:31:53,580
<font color="#E5E5E5">is smaller or bigger under decide</font>

567
00:31:50,820 --> 00:31:59,370
whether this this event has been

568
00:31:53,580 --> 00:32:02,669
<font color="#E5E5E5">completed or</font><font color="#CCCCCC"> not it looks so very</font><font color="#E5E5E5"> good</font>

569
00:31:59,370 --> 00:32:06,959
<font color="#E5E5E5">at first glance however together with</font>

570
00:32:02,670 --> 00:32:12,510
DMA mapping<font color="#CCCCCC"> back that it is</font><font color="#E5E5E5"> possible</font>

571
00:32:06,960 --> 00:32:16,470
that we can<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can modify the channel</font>

572
00:32:12,510 --> 00:32:19,730
<font color="#E5E5E5">index here and because this this object</font>

573
00:32:16,470 --> 00:32:22,230
is created by<font color="#CCCCCC"> kernel and is not</font><font color="#E5E5E5"> possible</font>

574
00:32:19,730 --> 00:32:24,570
<font color="#CCCCCC">to</font><font color="#E5E5E5"> be mutated by the user land</font>

575
00:32:22,230 --> 00:32:27,900
applications kernel fully cut it<font color="#CCCCCC"> under</font>

576
00:32:24,570 --> 00:32:28,530
<font color="#E5E5E5">it's a talented form enough boundary</font>

577
00:32:27,900 --> 00:32:33,090
check

578
00:32:28,530 --> 00:32:36,020
so once the index is mutated to a very

579
00:32:33,090 --> 00:32:40,949
big value<font color="#E5E5E5"> then of course we will have</font>

580
00:32:36,020 --> 00:32:44,580
out<font color="#CCCCCC"> of bound read to read out the array</font>

581
00:32:40,950 --> 00:32:49,620
of the<font color="#CCCCCC"> MCM array address</font>

582
00:32:44,580 --> 00:32:54,340
and<font color="#CCCCCC"> readouts that value</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> then write</font>

583
00:32:49,620 --> 00:32:57,479
<font color="#CCCCCC">user em in line array which is OB right</font>

584
00:32:54,340 --> 00:32:57,480
[Music]

585
00:32:58,400 --> 00:33:06,500
<font color="#E5E5E5">okay so after</font><font color="#CCCCCC"> the box has been explained</font>

586
00:33:02,970 --> 00:33:09,060
let's look into the exploitation so

587
00:33:06,500 --> 00:33:11,370
<font color="#E5E5E5">exploitability of those two</font><font color="#CCCCCC"> parts</font>

588
00:33:09,060 --> 00:33:14,730
depends on<font color="#CCCCCC"> whether we</font><font color="#E5E5E5"> can control the</font>

589
00:33:11,370 --> 00:33:18,000
content for<font color="#CCCCCC"> both m in</font><font color="#E5E5E5"> an array and the M</font>

590
00:33:14,730 --> 00:33:20,340
<font color="#CCCCCC">temp</font><font color="#E5E5E5"> address array we need to control</font>

591
00:33:18,000 --> 00:33:23,340
<font color="#E5E5E5">the content of both of them it looks</font>

592
00:33:20,340 --> 00:33:26,580
<font color="#CCCCCC">like a</font><font color="#E5E5E5"> very hard task</font><font color="#CCCCCC"> this is because</font>

593
00:33:23,340 --> 00:33:28,919
that both arrays are created in<font color="#CCCCCC"> very</font>

594
00:33:26,580 --> 00:33:32,699
<font color="#CCCCCC">early stage of</font><font color="#E5E5E5"> the iOS booting process</font>

595
00:33:28,920 --> 00:33:35,460
<font color="#CCCCCC">and it looks impossible that we can put</font>

596
00:33:32,700 --> 00:33:38,550
very controlled contents<font color="#E5E5E5"> right after</font>

597
00:33:35,460 --> 00:33:42,030
them and also<font color="#E5E5E5"> the second reason is that</font>

598
00:33:38,550 --> 00:33:43,139
the<font color="#CCCCCC"> size of the element of each</font><font color="#E5E5E5"> array is</font>

599
00:33:42,030 --> 00:33:46,470
quite<font color="#E5E5E5"> different</font>

600
00:33:43,140 --> 00:33:50,730
the larger the index we specify the

601
00:33:46,470 --> 00:33:54,060
longer span that is the address<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font>

602
00:33:50,730 --> 00:33:57,930
reference array element we<font color="#CCCCCC"> have so</font>

603
00:33:54,060 --> 00:34:00,210
<font color="#CCCCCC">that's not a very</font><font color="#E5E5E5"> good news and the to</font>

604
00:33:57,930 --> 00:34:02,760
exploit this<font color="#CCCCCC"> Park the memory layout</font>

605
00:34:00,210 --> 00:34:05,550
thing is<font color="#E5E5E5"> a key factor</font><font color="#CCCCCC"> before doing</font><font color="#E5E5E5"> that</font>

606
00:34:02,760 --> 00:34:08,100
we<font color="#CCCCCC"> need to understand the some facts</font><font color="#E5E5E5"> the</font>

607
00:34:05,550 --> 00:34:13,290
first<font color="#E5E5E5"> effect is that kernel heap memory</font>

608
00:34:08,100 --> 00:34:15,029
starts at a relatively low address and a

609
00:34:13,290 --> 00:34:18,590
heap can glow<font color="#CCCCCC"> ocurro</font>

610
00:34:15,030 --> 00:34:22,470
line<font color="#CCCCCC"> ly</font><font color="#E5E5E5"> with more and more memory</font>

611
00:34:18,590 --> 00:34:26,060
allocated under<font color="#CCCCCC"> the start address</font><font color="#E5E5E5"> of the</font>

612
00:34:22,469 --> 00:34:29,730
heap differs<font color="#E5E5E5"> we</font><font color="#CCCCCC"> see in tens of megabytes</font>

613
00:34:26,060 --> 00:34:34,560
<font color="#E5E5E5">upon each put this is to</font><font color="#CCCCCC"> chooser</font><font color="#E5E5E5"> early</font>

614
00:34:29,730 --> 00:34:37,409
by random value<font color="#E5E5E5"> under also the address</font>

615
00:34:34,560 --> 00:34:40,310
<font color="#E5E5E5">of em in line array and the</font><font color="#CCCCCC"> MS temp</font>

616
00:34:37,409 --> 00:34:45,779
<font color="#E5E5E5">address array are closed with each other</font>

617
00:34:40,310 --> 00:34:49,080
<font color="#CCCCCC">and because of that</font><font color="#E5E5E5"> we can use a</font>

618
00:34:45,780 --> 00:34:52,350
relatively large<font color="#E5E5E5"> channel index along</font>

619
00:34:49,080 --> 00:34:55,429
<font color="#E5E5E5">with some technologies like kernel</font><font color="#CCCCCC"> hips</font>

620
00:34:52,350 --> 00:34:57,210
<font color="#CCCCCC">break</font><font color="#E5E5E5"> we might</font><font color="#CCCCCC"> able to increase the</font>

621
00:34:55,429 --> 00:35:00,359
possibility to

622
00:34:57,210 --> 00:35:09,089
make sure that<font color="#E5E5E5"> upon the value of post</font>

623
00:35:00,359 --> 00:35:11,880
array and our<font color="#E5E5E5"> control so</font><font color="#CCCCCC"> we definitely</font>

624
00:35:09,089 --> 00:35:14,730
<font color="#E5E5E5">need</font><font color="#CCCCCC"> a heap spray technologies and</font>

625
00:35:11,880 --> 00:35:18,000
luckily this is<font color="#CCCCCC"> not a problem</font><font color="#E5E5E5"> because it</font>

626
00:35:14,730 --> 00:35:20,550
<font color="#E5E5E5">is</font><font color="#CCCCCC"> we're all published under</font><font color="#E5E5E5"> you can</font>

627
00:35:18,000 --> 00:35:27,180
fund a lot of public articles about it

628
00:35:20,550 --> 00:35:29,760
<font color="#CCCCCC">and iPhone 7</font><font color="#E5E5E5"> under our</font><font color="#CCCCCC"> test we can spray</font>

629
00:35:27,180 --> 00:35:32,220
<font color="#CCCCCC">around</font><font color="#E5E5E5"> the 300</font><font color="#CCCCCC"> and the 15 megabytes</font>

630
00:35:29,760 --> 00:35:36,410
kernel memory<font color="#CCCCCC"> we seeing the container</font>

631
00:35:32,220 --> 00:35:40,618
<font color="#CCCCCC">sandbox applications</font><font color="#E5E5E5"> and after those two</font>

632
00:35:36,410 --> 00:35:44,549
<font color="#CCCCCC">arrays are created there are around 50</font>

633
00:35:40,619 --> 00:35:46,400
megabytes<font color="#E5E5E5"> extra kernel memory allocated</font>

634
00:35:44,550 --> 00:35:49,349
[Music]

635
00:35:46,400 --> 00:35:53,339
so what conclusion we can get at this

636
00:35:49,349 --> 00:35:55,849
stage the<font color="#CCCCCC"> first that because the</font><font color="#E5E5E5"> em in</font>

637
00:35:53,339 --> 00:36:00,060
line array element size is 24 bytes

638
00:35:55,849 --> 00:36:04,380
under<font color="#E5E5E5"> M</font><font color="#CCCCCC"> temp</font><font color="#E5E5E5"> address array element size</font>

639
00:36:00,060 --> 00:36:08,549
is 8 bytes<font color="#E5E5E5"> so if we can make</font><font color="#CCCCCC"> sure that</font>

640
00:36:04,380 --> 00:36:13,260
the index<font color="#CCCCCC"> value</font><font color="#E5E5E5"> multiplied by 24 is</font>

641
00:36:08,550 --> 00:36:16,980
smaller than 400 megabytes<font color="#CCCCCC"> under index</font>

642
00:36:13,260 --> 00:36:21,300
value multiplied by 8 is larger<font color="#E5E5E5"> than</font><font color="#CCCCCC"> 15</font>

643
00:36:16,980 --> 00:36:26,430
megabytes<font color="#E5E5E5"> then with we get the range of</font>

644
00:36:21,300 --> 00:36:29,970
index using this this range and if the

645
00:36:26,430 --> 00:36:33,299
index is<font color="#E5E5E5"> in this range we will have</font>

646
00:36:29,970 --> 00:36:36,930
higher probabilities and higher

647
00:36:33,300 --> 00:36:39,690
possibilities that<font color="#E5E5E5"> post</font><font color="#CCCCCC"> also</font><font color="#E5E5E5"> upon the</font>

648
00:36:36,930 --> 00:36:45,060
<font color="#E5E5E5">value of post array are following into</font>

649
00:36:39,690 --> 00:36:48,619
<font color="#E5E5E5">our spread data and the next issue is</font>

650
00:36:45,060 --> 00:36:51,450
you<font color="#CCCCCC"> have</font><font color="#E5E5E5"> arbitrary memory read and write</font>

651
00:36:48,619 --> 00:36:53,970
<font color="#E5E5E5">according</font><font color="#CCCCCC"> to the nature of the park the</font>

652
00:36:51,450 --> 00:36:57,359
arbitrary memory read is not<font color="#CCCCCC"> a problem</font>

653
00:36:53,970 --> 00:37:00,660
because<font color="#E5E5E5"> M</font><font color="#CCCCCC"> stamp address array element</font>

654
00:36:57,359 --> 00:37:03,450
size is 8 bytes<font color="#E5E5E5"> with arbitrary index</font>

655
00:37:00,660 --> 00:37:07,319
value<font color="#E5E5E5"> you can reach every D</font><font color="#CCCCCC"> Ward's</font>

656
00:37:03,450 --> 00:37:10,169
<font color="#E5E5E5">within each page however the higher</font><font color="#CCCCCC"> 4</font>

657
00:37:07,320 --> 00:37:13,650
bytes of code cannot be read

658
00:37:10,170 --> 00:37:17,279
but it is not necessary because we in

659
00:37:13,650 --> 00:37:20,519
usually to<font color="#CCCCCC"> make it code execution you</font>

660
00:37:17,279 --> 00:37:23,309
only needed to modify<font color="#E5E5E5"> an address lower</font>

661
00:37:20,519 --> 00:37:25,308
bytes<font color="#E5E5E5"> below</font><font color="#CCCCCC"> four bytes instead of the</font>

662
00:37:23,309 --> 00:37:28,470
<font color="#E5E5E5">high of robots</font>

663
00:37:25,309 --> 00:37:33,710
however the arbitrary memory<font color="#E5E5E5"> right is</font>

664
00:37:28,470 --> 00:37:37,890
more<font color="#E5E5E5"> tricky because there because</font>

665
00:37:33,710 --> 00:37:41,279
because the M in line array element size

666
00:37:37,890 --> 00:37:43,859
is 24 bytes<font color="#E5E5E5"> only one of its</font><font color="#CCCCCC"> D order can</font>

667
00:37:41,279 --> 00:37:47,460
be written so it introduced a very

668
00:37:43,859 --> 00:37:52,410
<font color="#E5E5E5">interesting issue can we all be right to</font>

669
00:37:47,460 --> 00:37:57,390
an arbitrary offset in<font color="#CCCCCC"> l0</font><font color="#E5E5E5"> X 4000 page</font>

670
00:37:52,410 --> 00:38:01,288
with all<font color="#E5E5E5"> B array element size only 24</font>

671
00:37:57,390 --> 00:38:04,200
<font color="#E5E5E5">part before we solve this issue we need</font>

672
00:38:01,289 --> 00:38:06,720
<font color="#E5E5E5">to understand</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> some facts the facts</font>

673
00:38:04,200 --> 00:38:10,439
the first<font color="#CCCCCC"> effects is a good news</font><font color="#E5E5E5"> thanks</font>

674
00:38:06,720 --> 00:38:13,618
to the mechanism of the iOS excellent

675
00:38:10,440 --> 00:38:17,700
you zoom a locator the base<font color="#E5E5E5"> address of M</font>

676
00:38:13,619 --> 00:38:24,480
England<font color="#E5E5E5"> array is always at offset zero X</font>

677
00:38:17,700 --> 00:38:29,788
F 0 or 0 X 2 0 F 0 because it is filled

678
00:38:24,480 --> 00:38:33,539
in<font color="#E5E5E5"> some bigger object which is 1</font><font color="#CCCCCC"> 4000</font>

679
00:38:29,789 --> 00:38:35,549
new in<font color="#E5E5E5"> Tucson the page is</font><font color="#CCCCCC"> two thousand</font>

680
00:38:33,539 --> 00:38:38,430
the insights they don't excuse on the

681
00:38:35,549 --> 00:38:42,329
insights and<font color="#CCCCCC"> the</font><font color="#E5E5E5"> similarly and stamp</font>

682
00:38:38,430 --> 00:38:45,210
<font color="#CCCCCC">addressed array is allocated with</font><font color="#E5E5E5"> 0 X</font>

683
00:38:42,329 --> 00:38:49,349
200<font color="#CCCCCC"> insights falling into the</font><font color="#E5E5E5"> catalog</font>

684
00:38:45,210 --> 00:38:52,619
<font color="#E5E5E5">dot</font><font color="#CCCCCC"> 500 thousand</font><font color="#E5E5E5"> and this address offset</font>

685
00:38:49,349 --> 00:38:56,519
we<font color="#CCCCCC"> seeing</font><font color="#E5E5E5"> the arrow X 4 thousand page</font>

686
00:38:52,619 --> 00:39:00,960
can all be the<font color="#E5E5E5"> values can all can be all</font>

687
00:38:56,519 --> 00:39:05,879
values divided<font color="#E5E5E5"> by PI 0 X 200 so this</font><font color="#CCCCCC"> is</font>

688
00:39:00,960 --> 00:39:09,839
<font color="#E5E5E5">a good news under similarly we need to</font>

689
00:39:05,880 --> 00:39:13,410
fund a fund a way to write<font color="#E5E5E5"> up III page</font>

690
00:39:09,839 --> 00:39:17,190
offset by all<font color="#CCCCCC"> B right on em in line</font>

691
00:39:13,410 --> 00:39:20,279
array and this<font color="#E5E5E5"> problem can</font><font color="#CCCCCC"> be solved</font>

692
00:39:17,190 --> 00:39:22,860
actually part by<font color="#E5E5E5"> a mathematic theory</font>

693
00:39:20,279 --> 00:39:28,620
called<font color="#E5E5E5"> the congruence sir</font>

694
00:39:22,860 --> 00:39:32,970
so because<font color="#CCCCCC"> 0 XC 0 0 0</font><font color="#E5E5E5"> is divided by PI 0</font>

695
00:39:28,620 --> 00:39:37,290
<font color="#CCCCCC">X 4,000 so o</font><font color="#E5E5E5"> int X values where</font><font color="#CCCCCC"> are the</font>

696
00:39:32,970 --> 00:39:40,500
<font color="#CCCCCC">remainder values divided</font><font color="#E5E5E5"> by 0</font><font color="#CCCCCC"> X 800 are</font>

697
00:39:37,290 --> 00:39:43,500
the<font color="#CCCCCC"> same so we can</font><font color="#E5E5E5"> always open right to</font>

698
00:39:40,500 --> 00:39:46,650
choose the same offset<font color="#E5E5E5"> in the M in line</font>

699
00:39:43,500 --> 00:39:52,890
array and the width in the factor<font color="#CCCCCC"> here</font>

700
00:39:46,650 --> 00:40:00,810
which gets a<font color="#E5E5E5"> conclusion that's given the</font>

701
00:39:52,890 --> 00:40:07,020
int<font color="#CCCCCC"> X equal to 0 except</font><font color="#E5E5E5"> to 7f 6</font><font color="#CCCCCC"> +</font><font color="#E5E5E5"> and</font>

702
00:40:00,810 --> 00:40:11,220
multiple<font color="#CCCCCC"> PI 0 X 800 so if that condition</font>

703
00:40:07,020 --> 00:40:14,130
is meet we we can always override the

704
00:40:11,220 --> 00:40:19,049
chooser first<font color="#E5E5E5"> 8 bytes in a spray the</font>

705
00:40:14,130 --> 00:40:22,110
page under the<font color="#CCCCCC"> next</font><font color="#E5E5E5"> problem is to reach</font>

706
00:40:19,050 --> 00:40:26,100
<font color="#E5E5E5">the</font><font color="#CCCCCC"> arbitrary offset within the page</font><font color="#E5E5E5"> we</font>

707
00:40:22,110 --> 00:40:30,500
sing with<font color="#E5E5E5"> M be</font><font color="#CCCCCC"> the offset of the</font><font color="#E5E5E5"> page we</font>

708
00:40:26,100 --> 00:40:35,700
just ensure<font color="#CCCCCC"> that index equals to this</font>

709
00:40:30,500 --> 00:40:37,800
under we can reach<font color="#E5E5E5"> to arbitrary offset</font>

710
00:40:35,700 --> 00:40:40,560
within the page so we<font color="#CCCCCC"> resolved this</font>

711
00:40:37,800 --> 00:40:42,600
problem<font color="#CCCCCC"> so here you don't need to</font>

712
00:40:40,560 --> 00:40:45,180
understand all<font color="#CCCCCC"> the stories of the</font>

713
00:40:42,600 --> 00:40:47,790
<font color="#E5E5E5">concurrence a lot of theory</font><font color="#CCCCCC"> but you only</font>

714
00:40:45,180 --> 00:40:48,480
need to<font color="#E5E5E5"> remember the results that our</font>

715
00:40:47,790 --> 00:40:52,640
conclusion

716
00:40:48,480 --> 00:40:58,110
so when index equals to this under it's

717
00:40:52,640 --> 00:41:01,710
<font color="#E5E5E5">missing the range of this then we can we</font>

718
00:40:58,110 --> 00:41:04,800
are<font color="#CCCCCC"> able to to overwrite arbitrary</font>

719
00:41:01,710 --> 00:41:10,980
offset in<font color="#CCCCCC"> a</font><font color="#E5E5E5"> page and at last we choose</font>

720
00:41:04,800 --> 00:41:17,070
the<font color="#CCCCCC"> value 0 X</font><font color="#E5E5E5"> 9 6 1 8 5 which</font><font color="#CCCCCC"> means it</font>

721
00:41:10,980 --> 00:41:20,970
can reach<font color="#E5E5E5"> the opposite 5 6 8 of 1 4000</font>

722
00:41:17,070 --> 00:41:26,280
page by writing this<font color="#E5E5E5"> M in line are a lot</font>

723
00:41:20,970 --> 00:41:30,319
of<font color="#CCCCCC"> punt</font><font color="#E5E5E5"> and now let's do the first</font>

724
00:41:26,280 --> 00:41:34,530
attempt of<font color="#E5E5E5"> exploitation first we try to</font>

725
00:41:30,320 --> 00:41:36,079
explore spray around<font color="#E5E5E5"> the three hundred</font>

726
00:41:34,530 --> 00:41:39,769
and fifty megabytes

727
00:41:36,079 --> 00:41:42,819
under the<font color="#CCCCCC"> logic is here the test event</font>

728
00:41:39,769 --> 00:41:47,718
function<font color="#E5E5E5"> will reach the all B values</font>

729
00:41:42,819 --> 00:41:52,009
here here<font color="#E5E5E5"> under then it's a try to try</font>

730
00:41:47,719 --> 00:41:55,459
to try to put a guest<font color="#E5E5E5"> address on to it</font>

731
00:41:52,009 --> 00:41:59,150
under refer to the value<font color="#CCCCCC"> of</font><font color="#E5E5E5"> it in slot B</font>

732
00:41:55,459 --> 00:42:02,868
we call<font color="#E5E5E5"> it have the value</font><font color="#CCCCCC"> written read</font>

733
00:41:59,150 --> 00:42:07,849
what value<font color="#CCCCCC"> to read</font><font color="#E5E5E5"> under the value that</font>

734
00:42:02,869 --> 00:42:13,249
is<font color="#CCCCCC"> red will be finally written</font><font color="#E5E5E5"> to the</font>

735
00:42:07,849 --> 00:42:19,479
slot<font color="#E5E5E5"> see at the offset 0 X 5 6 8 which</font>

736
00:42:13,249 --> 00:42:24,229
is M<font color="#E5E5E5"> in line array in my array are</font>

737
00:42:19,479 --> 00:42:27,288
written under by first attempt of the

738
00:42:24,229 --> 00:42:31,249
exploit<font color="#CCCCCC"> we then receive the</font><font color="#E5E5E5"> OMS</font>

739
00:42:27,289 --> 00:42:34,789
<font color="#CCCCCC">intricacy</font><font color="#E5E5E5"> which message</font><font color="#CCCCCC"> ate up refute</font>

740
00:42:31,249 --> 00:42:38,089
the address written field has been

741
00:42:34,789 --> 00:42:41,359
changed by checking the new value in

742
00:42:38,089 --> 00:42:43,880
that<font color="#E5E5E5"> address we can obtain two very</font>

743
00:42:41,359 --> 00:42:47,288
important piece of<font color="#E5E5E5"> information</font><font color="#CCCCCC"> the first</font>

744
00:42:43,880 --> 00:42:52,039
information is which our message is

745
00:42:47,289 --> 00:42:55,219
allocated in<font color="#E5E5E5"> slots in another state</font><font color="#CCCCCC"> on</font>

746
00:42:52,039 --> 00:42:58,660
the message important information is

747
00:42:55,219 --> 00:43:01,640
which Oh error message is in slot<font color="#CCCCCC"> peeled</font>

748
00:42:58,660 --> 00:43:05,890
<font color="#E5E5E5">because we can specify each of our</font>

749
00:43:01,640 --> 00:43:09,589
messages<font color="#E5E5E5"> via our field very unique and</font>

750
00:43:05,890 --> 00:43:12,379
asked after we<font color="#CCCCCC"> cut those information we</font>

751
00:43:09,589 --> 00:43:17,299
can perform the<font color="#E5E5E5"> second exploit to bypass</font>

752
00:43:12,380 --> 00:43:22,249
a SAR<font color="#E5E5E5"> we do it by filling a slot p with</font>

753
00:43:17,299 --> 00:43:27,670
h x GL context object and that object is

754
00:43:22,249 --> 00:43:31,009
in<font color="#CCCCCC"> Kellogg dot 8 1 9</font><font color="#E5E5E5"> 2 so it's</font><font color="#CCCCCC"> very good</font>

755
00:43:27,670 --> 00:43:34,940
you<font color="#CCCCCC"> can feel free</font><font color="#E5E5E5"> the slot P and</font><font color="#CCCCCC"> a</font>

756
00:43:31,009 --> 00:43:38,390
<font color="#E5E5E5">feeling at the same</font><font color="#CCCCCC"> address and then</font><font color="#E5E5E5"> we</font>

757
00:43:34,940 --> 00:43:42,559
change the<font color="#CCCCCC"> GA value to this which Allah</font>

758
00:43:38,390 --> 00:43:46,940
is all reaching a value<font color="#E5E5E5"> minus 0 X</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> T</font>

759
00:43:42,559 --> 00:43:48,110
because the pace address of slot<font color="#E5E5E5"> P is a</font>

760
00:43:46,940 --> 00:43:51,320
<font color="#CCCCCC">read</font>

761
00:43:48,110 --> 00:43:52,310
of the first<font color="#CCCCCC"> eight bytes</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> the object</font>

762
00:43:51,320 --> 00:43:56,270
is<font color="#CCCCCC"> vtable</font>

763
00:43:52,310 --> 00:43:59,450
address of<font color="#E5E5E5"> HX GL context object so we</font>

764
00:43:56,270 --> 00:44:02,720
exploit the part<font color="#E5E5E5"> again and finally</font><font color="#CCCCCC"> we</font>

765
00:43:59,450 --> 00:44:06,500
got<font color="#CCCCCC"> the lower four bytes of the HX GL</font>

766
00:44:02,720 --> 00:44:09,859
context of the table<font color="#E5E5E5"> and after that so</font>

767
00:44:06,500 --> 00:44:12,290
we obtain<font color="#CCCCCC"> there we bypass the ksar</font><font color="#E5E5E5"> and</font>

768
00:44:09,860 --> 00:44:14,750
the finally we we needed<font color="#CCCCCC"> a code</font>

769
00:44:12,290 --> 00:44:17,840
execution<font color="#E5E5E5"> so to get the code execution</font>

770
00:44:14,750 --> 00:44:21,380
we need to free the slot<font color="#CCCCCC"> see under</font>

771
00:44:17,840 --> 00:44:25,070
<font color="#E5E5E5">feeling with the object where it's upset</font>

772
00:44:21,380 --> 00:44:28,280
<font color="#CCCCCC">0x five six eight represents some</font>

773
00:44:25,070 --> 00:44:31,100
important object<font color="#E5E5E5"> and we found the HX GL</font>

774
00:44:28,280 --> 00:44:36,580
<font color="#E5E5E5">context is a best choice also because</font>

775
00:44:31,100 --> 00:44:40,310
it's upset five six eight represents<font color="#E5E5E5"> HX</font>

776
00:44:36,580 --> 00:44:43,279
accelerator<font color="#E5E5E5"> object by calling that user</font>

777
00:44:40,310 --> 00:44:45,560
clients method<font color="#CCCCCC"> of</font><font color="#E5E5E5"> zero we can reach the</font>

778
00:44:43,280 --> 00:44:48,740
function context<font color="#E5E5E5"> to finish and the</font>

779
00:44:45,560 --> 00:44:54,529
contest finish<font color="#E5E5E5"> will give reference that</font>

780
00:44:48,740 --> 00:44:57,319
objects five six eight<font color="#E5E5E5"> as</font><font color="#CCCCCC"> pure as a HX</font>

781
00:44:54,530 --> 00:45:01,670
<font color="#E5E5E5">accelerate object and the use it to call</font>

782
00:44:57,320 --> 00:45:04,700
<font color="#E5E5E5">its virtual functions so</font><font color="#CCCCCC"> pi exploits</font>

783
00:45:01,670 --> 00:45:08,710
<font color="#E5E5E5">that part again we are able to modify</font>

784
00:45:04,700 --> 00:45:12,589
<font color="#CCCCCC">the lower four</font><font color="#E5E5E5"> bytes of that HX</font>

785
00:45:08,710 --> 00:45:15,500
accelerate object and<font color="#E5E5E5"> modify the to any</font>

786
00:45:12,590 --> 00:45:18,500
<font color="#E5E5E5">arbitrary value and there we can consume</font>

787
00:45:15,500 --> 00:45:19,970
<font color="#CCCCCC">the content of that</font><font color="#E5E5E5"> new address so</font><font color="#CCCCCC"> that</font>

788
00:45:18,500 --> 00:45:23,210
<font color="#CCCCCC">we get PC consume</font>

789
00:45:19,970 --> 00:45:26,120
so finally I<font color="#E5E5E5"> talked</font><font color="#CCCCCC"> about the overall</font>

790
00:45:23,210 --> 00:45:28,700
exploit overflow so first we create<font color="#E5E5E5"> I or</font>

791
00:45:26,120 --> 00:45:31,609
axial resource and then we call to the

792
00:45:28,700 --> 00:45:34,520
<font color="#E5E5E5">i/o axial</font><font color="#CCCCCC"> event</font><font color="#E5E5E5"> read-only buffer we</font>

793
00:45:31,610 --> 00:45:37,700
<font color="#CCCCCC">treat</font><font color="#E5E5E5"> the first part to modify the</font><font color="#CCCCCC"> M</font>

794
00:45:34,520 --> 00:45:40,070
channel<font color="#E5E5E5"> index to a bigger value and then</font>

795
00:45:37,700 --> 00:45:43,279
we<font color="#CCCCCC"> clear prepare as a memory layout</font>

796
00:45:40,070 --> 00:45:47,180
<font color="#E5E5E5">trigger</font><font color="#CCCCCC"> pakka</font><font color="#E5E5E5"> to to obtain the index of</font>

797
00:45:43,280 --> 00:45:52,130
the slot B and the slots<font color="#E5E5E5"> root C and then</font>

798
00:45:47,180 --> 00:45:55,549
we prepare<font color="#E5E5E5"> the memory layout under two</font>

799
00:45:52,130 --> 00:45:59,789
to four ksar<font color="#CCCCCC"> par-5 has taken about a two</font>

800
00:45:55,550 --> 00:46:03,389
<font color="#E5E5E5">and obtain the vtable</font><font color="#CCCCCC"> of HX GL context</font>

801
00:45:59,789 --> 00:46:05,609
so that we<font color="#CCCCCC"> bypassed ksar and finally we</font>

802
00:46:03,389 --> 00:46:08,429
prepare the memory<font color="#CCCCCC"> Lake out again for</font>

803
00:46:05,609 --> 00:46:11,630
pay code execution<font color="#E5E5E5"> to take</font><font color="#CCCCCC"> a bug</font><font color="#E5E5E5"> to</font>

804
00:46:08,429 --> 00:46:15,959
again and the overrides the ihx

805
00:46:11,630 --> 00:46:19,289
<font color="#E5E5E5">accelerator pointer in</font><font color="#CCCCCC"> Ajax GL context</font>

806
00:46:15,959 --> 00:46:22,259
and after that we<font color="#E5E5E5"> can perform a rock</font>

807
00:46:19,289 --> 00:46:25,139
under<font color="#CCCCCC"> gets</font><font color="#E5E5E5"> the task of</font><font color="#CCCCCC"> all p IE 0</font><font color="#E5E5E5"> and</font>

808
00:46:22,259 --> 00:46:29,069
then<font color="#E5E5E5"> we perform post exploitation</font><font color="#CCCCCC"> huge</font>

809
00:46:25,139 --> 00:46:32,519
jailbreak so after that we got<font color="#E5E5E5"> such</font><font color="#CCCCCC"> task</font>

810
00:46:29,069 --> 00:46:33,209
or PID<font color="#E5E5E5"> 0 but it's only first step of the</font>

811
00:46:32,519 --> 00:46:35,968
<font color="#E5E5E5">jailbreak</font>

812
00:46:33,209 --> 00:46:38,999
we still need to<font color="#E5E5E5"> break the amfi to</font>

813
00:46:35,969 --> 00:46:41,789
remember the route ifs to read and write

814
00:46:38,999 --> 00:46:44,638
<font color="#E5E5E5">and the to perform</font><font color="#CCCCCC"> the KPG and AMCC</font>

815
00:46:41,789 --> 00:46:48,119
<font color="#E5E5E5">bypass a statue and those are very well</font>

816
00:46:44,639 --> 00:46:51,509
<font color="#E5E5E5">documented outside publicly and it's not</font>

817
00:46:48,119 --> 00:47:03,539
a scope of our talk<font color="#CCCCCC"> under we will</font><font color="#E5E5E5"> assure</font>

818
00:46:51,509 --> 00:47:05,609
<font color="#CCCCCC">a demo of the attack yeah so because of</font>

819
00:47:03,539 --> 00:47:08,819
the<font color="#CCCCCC"> time limitation</font><font color="#E5E5E5"> i will skip some</font>

820
00:47:05,609 --> 00:47:11,009
parts and the<font color="#CCCCCC"> first we we choose working</font>

821
00:47:08,819 --> 00:47:13,319
<font color="#CCCCCC">ten point three point three because I</font>

822
00:47:11,009 --> 00:47:15,389
only have this<font color="#E5E5E5"> version which can exploit</font>

823
00:47:13,319 --> 00:47:18,569
at this part actually<font color="#E5E5E5"> the park also</font>

824
00:47:15,389 --> 00:47:22,949
exists<font color="#E5E5E5"> in some early version of iOS 11</font>

825
00:47:18,569 --> 00:47:25,889
beta but I don't have the device<font color="#E5E5E5"> so we</font>

826
00:47:22,949 --> 00:47:27,869
click our<font color="#E5E5E5"> application we bypass</font><font color="#CCCCCC"> the</font>

827
00:47:25,889 --> 00:47:29,849
sandbox<font color="#E5E5E5"> actually there is no sim parks</font>

828
00:47:27,869 --> 00:47:30,869
because we exploit the kernel directory

829
00:47:29,849 --> 00:47:34,919
but are we involved

830
00:47:30,869 --> 00:47:37,589
<font color="#CCCCCC">cubox so one</font><font color="#E5E5E5"> I think</font><font color="#CCCCCC"> maybe sometimes</font><font color="#E5E5E5"> it</font>

831
00:47:34,919 --> 00:47:41,819
<font color="#E5E5E5">can also the DMA feature</font><font color="#CCCCCC"> party can also</font>

832
00:47:37,589 --> 00:47:44,519
bypass the sandbox also but here we

833
00:47:41,819 --> 00:47:48,019
don't<font color="#E5E5E5"> use it</font><font color="#CCCCCC"> we just use data to change</font>

834
00:47:44,519 --> 00:47:52,499
the index channel index

835
00:47:48,019 --> 00:47:56,549
yeah<font color="#CCCCCC"> after we bypass the</font><font color="#E5E5E5"> PP k PP then it</font>

836
00:47:52,499 --> 00:48:01,319
<font color="#E5E5E5">do a risk bring and finally we found</font>

837
00:47:56,549 --> 00:48:05,339
that<font color="#E5E5E5"> the</font><font color="#CCCCCC"> the Cydia is installed on this</font>

838
00:48:01,319 --> 00:48:07,469
machine<font color="#E5E5E5"> with European yeah but it's a</font>

839
00:48:05,339 --> 00:48:12,419
little<font color="#CCCCCC"> bit broken but</font><font color="#E5E5E5"> I think with</font>

840
00:48:07,469 --> 00:48:13,640
<font color="#CCCCCC">triple actions you can</font><font color="#E5E5E5"> make it work yeah</font>

841
00:48:12,419 --> 00:48:16,308
and<font color="#CCCCCC"> the finally you</font>

842
00:48:13,640 --> 00:48:19,910
<font color="#CCCCCC">under the corrected version of it</font><font color="#E5E5E5"> and</font>

843
00:48:16,309 --> 00:48:27,950
<font color="#CCCCCC">there</font><font color="#E5E5E5"> finally I</font><font color="#CCCCCC"> talk</font><font color="#E5E5E5"> about the</font>

844
00:48:19,910 --> 00:48:31,160
<font color="#E5E5E5">conclusion so with</font><font color="#CCCCCC"> the first</font><font color="#E5E5E5"> release of</font>

845
00:48:27,950 --> 00:48:34,939
iOS<font color="#E5E5E5"> 11 Apple actually fix the first Park</font>

846
00:48:31,160 --> 00:48:36,589
which is a<font color="#CCCCCC"> DMA</font><font color="#E5E5E5"> mapping back under</font><font color="#CCCCCC"> it is</font>

847
00:48:34,940 --> 00:48:38,930
actually<font color="#E5E5E5"> fixed by adding the</font>

848
00:48:36,589 --> 00:48:42,619
implementation<font color="#E5E5E5"> of the read-only mapping</font>

849
00:48:38,930 --> 00:48:44,328
at its<font color="#E5E5E5"> path code under however</font><font color="#CCCCCC"> there are</font>

850
00:48:42,619 --> 00:48:47,900
other Oh<font color="#E5E5E5"> be right back</font>

851
00:48:44,329 --> 00:48:51,440
remains<font color="#E5E5E5"> unfixed up till now and this is</font>

852
00:48:47,900 --> 00:48:55,339
a very good<font color="#CCCCCC"> example of how</font><font color="#E5E5E5"> secret can be</font>

853
00:48:51,440 --> 00:48:58,339
<font color="#E5E5E5">broken by</font><font color="#CCCCCC"> a very bad implementation but</font>

854
00:48:55,339 --> 00:49:01,970
<font color="#E5E5E5">with very good hardware design and it</font>

855
00:48:58,339 --> 00:49:04,009
makes possible of very complex<font color="#E5E5E5"> exploit</font>

856
00:49:01,970 --> 00:49:08,269
<font color="#CCCCCC">change to achieve that your break within</font>

857
00:49:04,010 --> 00:49:12,579
<font color="#E5E5E5">the</font><font color="#CCCCCC"> Wilderland applications at this</font>

858
00:49:08,269 --> 00:49:15,950
stage<font color="#E5E5E5"> it is still safe to say that</font>

859
00:49:12,579 --> 00:49:18,470
<font color="#E5E5E5">because with the first part fixed the</font>

860
00:49:15,950 --> 00:49:20,899
trust boundary of the user land

861
00:49:18,470 --> 00:49:24,740
<font color="#E5E5E5">read-only mapping is back so you don't</font>

862
00:49:20,900 --> 00:49:27,500
<font color="#CCCCCC">need to to fix the part too but it</font>

863
00:49:24,740 --> 00:49:31,519
brings a problem to<font color="#E5E5E5"> us should we</font>

864
00:49:27,500 --> 00:49:34,250
actually<font color="#E5E5E5"> trust the kernel user</font><font color="#CCCCCC"> userland</font>

865
00:49:31,519 --> 00:49:36,379
<font color="#E5E5E5">read-only mappings and of course</font>

866
00:49:34,250 --> 00:49:38,720
<font color="#E5E5E5">currently there is no definite answer</font>

867
00:49:36,380 --> 00:49:41,869
<font color="#E5E5E5">because I don't</font><font color="#CCCCCC"> have another way to</font>

868
00:49:38,720 --> 00:49:44,779
break that trust<font color="#E5E5E5"> boundary but at least</font>

869
00:49:41,869 --> 00:49:47,029
in this talk we demonstrated that<font color="#E5E5E5"> the</font>

870
00:49:44,779 --> 00:49:47,779
user<font color="#E5E5E5"> land read-only mapping can be</font>

871
00:49:47,029 --> 00:49:49,970
dangerous

872
00:49:47,779 --> 00:49:53,269
it is possible that in<font color="#CCCCCC"> the future</font>

873
00:49:49,970 --> 00:49:56,359
<font color="#CCCCCC">another</font><font color="#E5E5E5"> part is introduced and a break</font>

874
00:49:53,269 --> 00:49:59,149
this<font color="#CCCCCC"> trust</font><font color="#E5E5E5"> boundary boundary again</font><font color="#CCCCCC"> and</font>

875
00:49:56,359 --> 00:50:02,328
we make the whole exploit chain<font color="#CCCCCC"> walk</font>

876
00:49:59,150 --> 00:50:05,660
again<font color="#E5E5E5"> it's very</font><font color="#CCCCCC"> likely and we never know</font>

877
00:50:02,329 --> 00:50:08,950
at this<font color="#E5E5E5"> moment thanks for listening and</font>

878
00:50:05,660 --> 00:50:08,950
<font color="#E5E5E5">if you have any</font>

