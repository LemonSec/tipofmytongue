1
00:00:00,089 --> 00:00:06,870
good morning<font color="#E5E5E5"> everyone</font><font color="#CCCCCC"> my name is alpha -</font>

2
00:00:02,490 --> 00:00:10,550
<font color="#E5E5E5">oh I am</font><font color="#CCCCCC"> the CEO of X</font><font color="#E5E5E5"> rays company the</font>

3
00:00:06,870 --> 00:00:13,889
company that publishes the ida pro

4
00:00:10,550 --> 00:00:17,940
disassembler and<font color="#E5E5E5"> express the decompiler</font>

5
00:00:13,889 --> 00:00:22,020
<font color="#E5E5E5">and today we will talk</font><font color="#CCCCCC"> about the</font>

6
00:00:17,940 --> 00:00:24,750
decompile internals<font color="#E5E5E5"> the microcode this</font>

7
00:00:22,020 --> 00:00:27,390
is a<font color="#E5E5E5"> presentation outline we will</font>

8
00:00:24,750 --> 00:00:30,359
discuss the decompiler architecture<font color="#CCCCCC"> and</font>

9
00:00:27,390 --> 00:00:35,250
then we will go and check how the

10
00:00:30,359 --> 00:00:37,260
<font color="#E5E5E5">microcode is built in the</font><font color="#CCCCCC"> compiler then</font>

11
00:00:35,250 --> 00:00:39,570
<font color="#E5E5E5">they will talk about the opcodes and</font>

12
00:00:37,260 --> 00:00:42,780
operands<font color="#E5E5E5"> this is the most</font><font color="#CCCCCC"> interesting</font>

13
00:00:39,570 --> 00:00:46,350
<font color="#E5E5E5">part of the talk then once we have these</font>

14
00:00:42,780 --> 00:00:48,690
building blocks we can talk about we

15
00:00:46,350 --> 00:00:50,850
will start with stack and registers<font color="#E5E5E5"> and</font>

16
00:00:48,690 --> 00:00:54,329
then<font color="#E5E5E5"> we will talk about other parent</font>

17
00:00:50,850 --> 00:00:57,180
types and then finally what kind of

18
00:00:54,329 --> 00:01:01,949
things we can do with<font color="#E5E5E5"> the microcode it</font>

19
00:00:57,180 --> 00:01:05,580
enables data flow analysis and because

20
00:01:01,949 --> 00:01:10,048
<font color="#CCCCCC">of that many new analysis types are</font>

21
00:01:05,580 --> 00:01:13,350
possible then I will tell you about the

22
00:01:10,049 --> 00:01:15,600
availability of the microcode<font color="#E5E5E5"> and some</font>

23
00:01:13,350 --> 00:01:19,140
time for<font color="#CCCCCC"> questions and transfers</font><font color="#E5E5E5"> if we</font>

24
00:01:15,600 --> 00:01:21,929
have time I don't<font color="#CCCCCC"> know</font><font color="#E5E5E5"> I hope that</font>

25
00:01:19,140 --> 00:01:26,460
you've heard about<font color="#CCCCCC"> the</font><font color="#E5E5E5"> compiler</font>

26
00:01:21,930 --> 00:01:30,560
we have the compiler<font color="#E5E5E5"> it is existing it</font>

27
00:01:26,460 --> 00:01:30,559
<font color="#CCCCCC">has been existing since the</font><font color="#E5E5E5"> 10 years now</font>

28
00:01:30,860 --> 00:01:39,090
it is interactive fast robust and

29
00:01:35,640 --> 00:01:41,610
program of the compiler and it evolved

30
00:01:39,090 --> 00:01:45,420
over<font color="#E5E5E5"> time even in</font><font color="#CCCCCC"> the initial version</font>

31
00:01:41,610 --> 00:01:48,810
that's quite powerful<font color="#CCCCCC"> but over time</font><font color="#E5E5E5"> we</font>

32
00:01:45,420 --> 00:01:51,329
<font color="#E5E5E5">added support</font><font color="#CCCCCC"> for many many processors</font>

33
00:01:48,810 --> 00:01:54,780
so we can say<font color="#E5E5E5"> that it's a retarget of</font>

34
00:01:51,329 --> 00:02:01,589
<font color="#CCCCCC">all the compiler as you see it can</font>

35
00:01:54,780 --> 00:02:04,259
handle<font color="#CCCCCC"> 5 processors for now and you see</font>

36
00:02:01,590 --> 00:02:06,810
<font color="#E5E5E5">that it handles native code</font><font color="#CCCCCC"> it is not</font>

37
00:02:04,259 --> 00:02:10,860
<font color="#CCCCCC">any compiler that handles byte</font><font color="#E5E5E5"> code like</font>

38
00:02:06,810 --> 00:02:12,770
a Java or.net<font color="#CCCCCC"> which is also</font><font color="#E5E5E5"> possible but</font>

39
00:02:10,860 --> 00:02:16,500
<font color="#CCCCCC">we</font>

40
00:02:12,770 --> 00:02:20,760
focus it on native code<font color="#CCCCCC"> as it compiled</font>

41
00:02:16,500 --> 00:02:24,720
runs on top of<font color="#CCCCCC"> either Pro and the</font>

42
00:02:20,760 --> 00:02:27,090
internals were never really published

43
00:02:24,720 --> 00:02:30,210
<font color="#CCCCCC">shipped so if you wanted</font><font color="#E5E5E5"> to play with</font>

44
00:02:27,090 --> 00:02:34,410
the decompiler<font color="#CCCCCC"> you could do so</font><font color="#E5E5E5"> on a high</font>

45
00:02:30,210 --> 00:02:42,020
level<font color="#E5E5E5"> but the intermediate</font><font color="#CCCCCC"> language was</font>

46
00:02:34,410 --> 00:02:45,780
never documented<font color="#E5E5E5"> and this book will show</font>

47
00:02:42,020 --> 00:02:50,070
<font color="#CCCCCC">you a bit and tell</font><font color="#E5E5E5"> you about about this</font>

48
00:02:45,780 --> 00:02:55,260
<font color="#E5E5E5">the</font><font color="#CCCCCC"> micro microcode how the compiler</font>

49
00:02:50,070 --> 00:02:58,230
<font color="#E5E5E5">have six phases and</font><font color="#CCCCCC"> in my</font><font color="#E5E5E5"> opinion</font><font color="#CCCCCC"> it's</font>

50
00:02:55,260 --> 00:03:01,980
very<font color="#E5E5E5"> good very logical steps first of</font>

51
00:02:58,230 --> 00:03:07,769
all we generate microcode then we try<font color="#E5E5E5"> to</font>

52
00:03:01,980 --> 00:03:10,170
transform it<font color="#CCCCCC"> to kind of optimize it</font><font color="#E5E5E5"> yes</font>

53
00:03:07,770 --> 00:03:15,780
we<font color="#CCCCCC"> use the same optimization techniques</font>

54
00:03:10,170 --> 00:03:18,140
as compilers do we analyze<font color="#E5E5E5"> calls the</font>

55
00:03:15,780 --> 00:03:21,830
result memory references and other<font color="#E5E5E5"> stuff</font>

56
00:03:18,140 --> 00:03:26,040
then<font color="#E5E5E5"> we allocate local variables</font>

57
00:03:21,830 --> 00:03:32,610
<font color="#E5E5E5">generate a</font><font color="#CCCCCC"> so called</font><font color="#E5E5E5"> c3 c3 is something</font>

58
00:03:26,040 --> 00:03:35,850
similar to<font color="#E5E5E5"> HT</font><font color="#CCCCCC"> then be beautified because</font>

59
00:03:32,610 --> 00:03:38,220
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> the initial c3 is quite ugly</font><font color="#CCCCCC"> to</font>

60
00:03:35,850 --> 00:03:41,970
<font color="#E5E5E5">tell the truth and then</font><font color="#CCCCCC"> finally we</font><font color="#E5E5E5"> print</font>

61
00:03:38,220 --> 00:03:45,290
the c3<font color="#E5E5E5"> in a human readable form so the</font>

62
00:03:41,970 --> 00:03:49,700
user can analyze it examine it<font color="#E5E5E5"> and</font>

63
00:03:45,290 --> 00:03:52,410
improve<font color="#E5E5E5"> there are some options for that</font>

64
00:03:49,700 --> 00:03:54,660
in<font color="#E5E5E5"> this talk we will focus only on the</font>

65
00:03:52,410 --> 00:03:58,380
first<font color="#CCCCCC"> two steps if you are interested in</font>

66
00:03:54,660 --> 00:04:01,530
the<font color="#E5E5E5"> rest you</font><font color="#CCCCCC"> can check my black cap talk</font>

67
00:03:58,380 --> 00:04:02,060
I<font color="#CCCCCC"> gave a</font><font color="#E5E5E5"> black hat presentation</font><font color="#CCCCCC"> 10 years</font>

68
00:04:01,530 --> 00:04:05,459
<font color="#E5E5E5">ago</font>

69
00:04:02,060 --> 00:04:10,230
it explained in more<font color="#E5E5E5"> detail</font><font color="#CCCCCC"> all these</font>

70
00:04:05,459 --> 00:04:12,930
steps except the first<font color="#E5E5E5"> two first of all</font>

71
00:04:10,230 --> 00:04:15,768
the question is why do<font color="#E5E5E5"> we need the</font>

72
00:04:12,930 --> 00:04:18,870
microcode<font color="#E5E5E5"> and the answer is very simple</font>

73
00:04:15,769 --> 00:04:22,380
<font color="#E5E5E5">we want to get rid of the complexity of</font>

74
00:04:18,870 --> 00:04:25,889
processor instructions because all

75
00:04:22,380 --> 00:04:30,150
processors have their own special

76
00:04:25,889 --> 00:04:33,780
geosynchronous<font color="#E5E5E5"> or oddities</font><font color="#CCCCCC"> I will give</font>

77
00:04:30,150 --> 00:04:36,900
you<font color="#CCCCCC"> just a few</font><font color="#E5E5E5"> examples for example the</font>

78
00:04:33,780 --> 00:04:42,020
x86<font color="#E5E5E5"> processors have segment registers</font>

79
00:04:36,900 --> 00:04:47,188
<font color="#E5E5E5">the floating-point processor has a stack</font>

80
00:04:42,020 --> 00:04:50,659
the ARM processor has some motor dresses

81
00:04:47,189 --> 00:04:54,060
that<font color="#CCCCCC"> have the low bit set which is</font>

82
00:04:50,659 --> 00:04:56,729
ignored<font color="#E5E5E5"> by the processor because if you</font>

83
00:04:54,060 --> 00:05:01,080
have an odd<font color="#E5E5E5"> odd address like 13 for</font>

84
00:04:56,729 --> 00:05:04,318
example<font color="#E5E5E5"> the the function</font><font color="#CCCCCC"> to call</font><font color="#E5E5E5"> is</font>

85
00:05:01,080 --> 00:05:09,688
located at the<font color="#CCCCCC"> address 12 but the</font><font color="#E5E5E5"> last</font>

86
00:05:04,319 --> 00:05:12,330
bit signals to the processor<font color="#E5E5E5"> that</font><font color="#CCCCCC"> when</font>

87
00:05:09,689 --> 00:05:15,029
<font color="#E5E5E5">performing the call it should switch to</font>

88
00:05:12,330 --> 00:05:18,210
<font color="#CCCCCC">the thumb mode</font><font color="#E5E5E5"> this is</font><font color="#CCCCCC"> a very special</font>

89
00:05:15,029 --> 00:05:22,199
<font color="#CCCCCC">thing I haven't seen something similar</font>

90
00:05:18,210 --> 00:05:25,279
in any as a processor and therefore such

91
00:05:22,199 --> 00:05:30,300
a thing should<font color="#CCCCCC"> not be present in the</font>

92
00:05:25,279 --> 00:05:31,139
microcode the marker could makes the

93
00:05:30,300 --> 00:05:35,460
<font color="#E5E5E5">decompiler</font>

94
00:05:31,139 --> 00:05:38,099
portable we can you<font color="#CCCCCC"> can say that we just</font>

95
00:05:35,460 --> 00:05:41,479
need to<font color="#CCCCCC"> replace</font><font color="#E5E5E5"> the micro code generator</font>

96
00:05:38,099 --> 00:05:44,669
and we get a de compiler for a new

97
00:05:41,479 --> 00:05:48,930
processor but of course the<font color="#E5E5E5"> devil is in</font>

98
00:05:44,669 --> 00:05:53,068
details<font color="#E5E5E5"> and when I say just it's</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> just</font>

99
00:05:48,930 --> 00:05:55,500
<font color="#CCCCCC">and</font><font color="#E5E5E5"> the quotes anyway overall the</font>

100
00:05:53,069 --> 00:05:59,370
compiler<font color="#E5E5E5"> without an intermediate</font>

101
00:05:55,500 --> 00:06:02,759
language<font color="#CCCCCC"> looks like waste of time to me</font>

102
00:05:59,370 --> 00:06:05,460
because once you finish<font color="#CCCCCC"> the</font><font color="#E5E5E5"> compiler</font>

103
00:06:02,759 --> 00:06:06,449
which never happens<font color="#CCCCCC"> you will have to</font>

104
00:06:05,460 --> 00:06:09,359
redo<font color="#CCCCCC"> everything</font>

105
00:06:06,449 --> 00:06:11,099
for another processor and we don't want

106
00:06:09,360 --> 00:06:13,080
<font color="#E5E5E5">to</font><font color="#CCCCCC"> support</font><font color="#E5E5E5"> many only one processor</font>

107
00:06:11,099 --> 00:06:16,639
because<font color="#E5E5E5"> there are many many of them very</font>

108
00:06:13,080 --> 00:06:18,508
popular<font color="#E5E5E5"> now the question is is</font>

109
00:06:16,639 --> 00:06:21,029
implementing an intermediate

110
00:06:18,509 --> 00:06:26,009
<font color="#CCCCCC">representation or language a difficult</font>

111
00:06:21,029 --> 00:06:28,099
<font color="#CCCCCC">thing about local how many intermediate</font>

112
00:06:26,009 --> 00:06:31,189
languages do you know

113
00:06:28,099 --> 00:06:34,889
well there are plenty<font color="#E5E5E5"> of them in</font><font color="#CCCCCC"> fact</font>

114
00:06:31,189 --> 00:06:37,949
all all the Iranian binary needs

115
00:06:34,889 --> 00:06:40,469
intermediate language<font color="#CCCCCC"> read deck</font>

116
00:06:37,949 --> 00:06:44,129
yesterday they were<font color="#CCCCCC"> too cold to</font>

117
00:06:40,469 --> 00:06:45,990
presentations at<font color="#CCCCCC"> blackhat here</font><font color="#E5E5E5"> and they</font>

118
00:06:44,129 --> 00:06:50,569
were presenting intermediate languages

119
00:06:45,990 --> 00:06:56,400
as well<font color="#CCCCCC"> so why do we</font><font color="#E5E5E5"> need one</font><font color="#CCCCCC"> more</font>

120
00:06:50,569 --> 00:07:00,360
internal representation well<font color="#E5E5E5"> I cannot</font>

121
00:06:56,400 --> 00:07:04,198
reply this<font color="#E5E5E5"> answer maybe it would</font><font color="#CCCCCC"> be</font>

122
00:07:00,360 --> 00:07:08,099
<font color="#E5E5E5">possible</font><font color="#CCCCCC"> to use an existing one but for</font>

123
00:07:04,199 --> 00:07:10,740
us<font color="#CCCCCC"> the reason was that I started</font><font color="#E5E5E5"> to work</font>

124
00:07:08,099 --> 00:07:15,029
on the<font color="#E5E5E5"> microcode entity compiler a</font>

125
00:07:10,740 --> 00:07:16,770
really long ago it<font color="#E5E5E5"> was in 90s I don't</font>

126
00:07:15,029 --> 00:07:19,860
even remember the exact date when<font color="#E5E5E5"> I</font>

127
00:07:16,770 --> 00:07:23,188
decided to to create micro code and

128
00:07:19,860 --> 00:07:25,439
that's<font color="#E5E5E5"> the</font><font color="#CCCCCC"> main reason why fix race the</font>

129
00:07:23,189 --> 00:07:33,289
compiler has<font color="#E5E5E5"> its own intermediate</font>

130
00:07:25,439 --> 00:07:35,879
language so<font color="#E5E5E5"> I started in around 98 and</font>

131
00:07:33,289 --> 00:07:37,710
well I am<font color="#CCCCCC"> very bad with names</font>

132
00:07:35,879 --> 00:07:39,659
so I<font color="#CCCCCC"> decided it's called</font><font color="#E5E5E5"> mic record-wise</font>

133
00:07:37,710 --> 00:07:44,128
microphone because every instruction

134
00:07:39,659 --> 00:07:48,930
<font color="#E5E5E5">every processor instruction is split</font>

135
00:07:44,129 --> 00:07:51,990
into multiple micro instructions and one

136
00:07:48,930 --> 00:07:54,870
micro structure<font color="#E5E5E5"> not one thing no side</font>

137
00:07:51,990 --> 00:07:57,479
effects it's a very simple<font color="#E5E5E5"> thing</font><font color="#CCCCCC"> and</font>

138
00:07:54,870 --> 00:08:03,210
that's why<font color="#CCCCCC"> as the name microcode</font><font color="#E5E5E5"> looked</font>

139
00:07:57,479 --> 00:08:06,628
logical to me<font color="#E5E5E5"> naturally</font><font color="#CCCCCC"> it is</font><font color="#E5E5E5"> virtually</font>

140
00:08:03,210 --> 00:08:10,049
impossible<font color="#E5E5E5"> to design something from</font>

141
00:08:06,629 --> 00:08:12,089
scratch and get everything right some

142
00:08:10,050 --> 00:08:15,180
design decision<font color="#E5E5E5"> turned out to be bad</font><font color="#CCCCCC"> for</font>

143
00:08:12,089 --> 00:08:20,550
<font color="#E5E5E5">example we have a notion of a</font><font color="#CCCCCC"> visual</font>

144
00:08:15,180 --> 00:08:24,060
stack registers well<font color="#E5E5E5"> a design decision</font>

145
00:08:20,550 --> 00:08:27,300
<font color="#CCCCCC">that</font><font color="#E5E5E5"> is taken at the early stages is</font>

146
00:08:24,060 --> 00:08:30,330
really difficult to<font color="#E5E5E5"> fix later</font><font color="#CCCCCC"> because</font>

147
00:08:27,300 --> 00:08:34,190
there are many saw so much code relies

148
00:08:30,330 --> 00:08:37,078
on it on this concept and implicitly

149
00:08:34,190 --> 00:08:39,959
assumes that we have beautiful stack

150
00:08:37,078 --> 00:08:42,510
registers well<font color="#CCCCCC"> one other hand I have to</font>

151
00:08:39,958 --> 00:08:45,709
tell you that beautiful stack registers

152
00:08:42,510 --> 00:08:45,709
will disappear in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> future</font>

153
00:08:45,900 --> 00:08:51,939
microcode continues to evolve<font color="#E5E5E5"> and we</font>

154
00:08:49,330 --> 00:08:54,630
continue to<font color="#CCCCCC"> modify it</font><font color="#E5E5E5"> but once we</font>

155
00:08:51,940 --> 00:08:58,510
publish<font color="#CCCCCC"> in fact we already published it</font>

156
00:08:54,630 --> 00:09:02,170
<font color="#E5E5E5">we will not modify it anymore</font><font color="#CCCCCC"> we at</font>

157
00:08:58,510 --> 00:09:08,620
least<font color="#CCCCCC"> will try not to modify it so what</font>

158
00:09:02,170 --> 00:09:10,689
my design goals<font color="#E5E5E5"> when I decided to</font><font color="#CCCCCC"> create</font>

159
00:09:08,620 --> 00:09:14,320
<font color="#E5E5E5">micro code the first and the most</font>

160
00:09:10,690 --> 00:09:18,190
important thing is simplicity<font color="#E5E5E5"> we already</font>

161
00:09:14,320 --> 00:09:21,880
work in handling very complex things so

162
00:09:18,190 --> 00:09:26,380
the simple we make<font color="#E5E5E5"> it the easier will be</font>

163
00:09:21,880 --> 00:09:29,350
in the future<font color="#CCCCCC"> as you will see later you</font>

164
00:09:26,380 --> 00:09:32,830
<font color="#CCCCCC">will see that I failed at this</font><font color="#E5E5E5"> task but</font>

165
00:09:29,350 --> 00:09:36,130
it is because the real world<font color="#E5E5E5"> is really</font>

166
00:09:32,830 --> 00:09:38,530
complex<font color="#CCCCCC"> but anyway</font><font color="#E5E5E5"> at the beginning what</font>

167
00:09:36,130 --> 00:09:42,490
do we<font color="#E5E5E5"> have when we start from</font><font color="#CCCCCC"> scratch</font>

168
00:09:38,530 --> 00:09:44,770
we have no processor specific stuff<font color="#CCCCCC"> one</font>

169
00:09:42,490 --> 00:09:47,850
<font color="#CCCCCC">instruction one mic restriction does one</font>

170
00:09:44,770 --> 00:09:51,790
thing and<font color="#CCCCCC"> a very limited number of</font>

171
00:09:47,850 --> 00:09:54,760
instructions<font color="#E5E5E5"> there were only 45 in 99</font>

172
00:09:51,790 --> 00:09:57,870
but today we<font color="#CCCCCC"> packed</font><font color="#E5E5E5"> 72 instructional</font>

173
00:09:54,760 --> 00:10:01,710
<font color="#E5E5E5">codes</font><font color="#CCCCCC"> just because we had to support</font>

174
00:09:57,870 --> 00:10:05,410
floating-point arithmetic and other

175
00:10:01,710 --> 00:10:07,570
fancy things<font color="#E5E5E5"> in fact what is good with</font>

176
00:10:05,410 --> 00:10:13,240
the microcode that it can it<font color="#CCCCCC"> really can</font>

177
00:10:07,570 --> 00:10:14,980
handle<font color="#E5E5E5"> real-world programs and initially</font>

178
00:10:13,240 --> 00:10:17,940
we started with simple<font color="#E5E5E5"> instruction</font>

179
00:10:14,980 --> 00:10:21,910
operands<font color="#E5E5E5"> initially we had registers its</font>

180
00:10:17,940 --> 00:10:23,800
<font color="#E5E5E5">constants and memory well by memory I</font>

181
00:10:21,910 --> 00:10:26,740
mean<font color="#E5E5E5"> the global variables and stack</font>

182
00:10:23,800 --> 00:10:28,930
variables<font color="#CCCCCC"> and</font><font color="#E5E5E5"> with it I decided that we</font>

183
00:10:26,740 --> 00:10:31,690
consider only compiler generated code

184
00:10:28,930 --> 00:10:34,359
because when you talk about<font color="#E5E5E5"> handcrafted</font>

185
00:10:31,690 --> 00:10:37,870
assembler code anything<font color="#CCCCCC"> has happened</font><font color="#E5E5E5"> you</font>

186
00:10:34,360 --> 00:10:40,540
cannot trust<font color="#E5E5E5"> even a disassembly listing</font>

187
00:10:37,870 --> 00:10:44,890
<font color="#E5E5E5">not to talk</font><font color="#CCCCCC"> about micro code of the</font>

188
00:10:40,540 --> 00:10:47,920
compiler<font color="#E5E5E5"> because it is possible to to</font>

189
00:10:44,890 --> 00:10:49,710
modify things that when you<font color="#CCCCCC"> Lia read the</font>

190
00:10:47,920 --> 00:10:51,040
listing<font color="#CCCCCC"> you see lot simpler</font>

191
00:10:49,710 --> 00:10:53,540
<font color="#CCCCCC">innocent-looking</font>

192
00:10:51,040 --> 00:10:55,050
instruction like move but in fact

193
00:10:53,540 --> 00:10:57,930
[Music]

194
00:10:55,050 --> 00:11:00,839
when this<font color="#CCCCCC"> instruction is</font><font color="#E5E5E5"> executed</font><font color="#CCCCCC"> there</font>

195
00:10:57,930 --> 00:11:02,880
will be<font color="#CCCCCC"> an exception</font><font color="#E5E5E5"> Tapani and the</font>

196
00:11:00,840 --> 00:11:05,180
exception<font color="#CCCCCC"> handler will do something</font><font color="#E5E5E5"> else</font>

197
00:11:02,880 --> 00:11:08,040
<font color="#CCCCCC">not move so you read the</font><font color="#E5E5E5"> code you see</font>

198
00:11:05,180 --> 00:11:11,489
instructions<font color="#CCCCCC"> but</font><font color="#E5E5E5"> they do not mean what</font>

199
00:11:08,040 --> 00:11:14,250
they look like<font color="#E5E5E5"> another thing</font><font color="#CCCCCC"> that we</font>

200
00:11:11,490 --> 00:11:17,010
<font color="#E5E5E5">don't care</font><font color="#CCCCCC"> about the timing</font><font color="#E5E5E5"> since we</font>

201
00:11:14,250 --> 00:11:20,850
<font color="#E5E5E5">will optimize the</font><font color="#CCCCCC"> microcode and throw</font>

202
00:11:17,010 --> 00:11:23,850
away<font color="#CCCCCC"> non</font><font color="#E5E5E5"> interesting dead code then</font>

203
00:11:20,850 --> 00:11:27,030
timing<font color="#E5E5E5"> will change therefore no</font><font color="#CCCCCC"> need</font><font color="#E5E5E5"> to</font>

204
00:11:23,850 --> 00:11:30,150
<font color="#E5E5E5">even try to preserve anything the</font>

205
00:11:27,030 --> 00:11:32,910
instruction order we decided not to keep

206
00:11:30,150 --> 00:11:37,410
not to preserved it neither<font color="#E5E5E5"> it is just</font>

207
00:11:32,910 --> 00:11:38,300
impossible<font color="#E5E5E5"> in fact and order of memory</font>

208
00:11:37,410 --> 00:11:41,819
<font color="#CCCCCC">accesses</font>

209
00:11:38,300 --> 00:11:47,219
<font color="#E5E5E5">we will not</font><font color="#CCCCCC"> also will not have care</font>

210
00:11:41,820 --> 00:11:48,990
about it neither so the easiest thing<font color="#E5E5E5"> I</font>

211
00:11:47,220 --> 00:11:51,530
think<font color="#E5E5E5"> that just</font><font color="#CCCCCC"> to show you how it looks</font>

212
00:11:48,990 --> 00:11:54,600
<font color="#E5E5E5">like let's take this for instructions</font>

213
00:11:51,530 --> 00:11:58,290
very simple x86 instructions

214
00:11:54,600 --> 00:12:02,250
apparently we access memory<font color="#CCCCCC"> we read from</font>

215
00:11:58,290 --> 00:12:05,099
<font color="#E5E5E5">eb x</font><font color="#CCCCCC"> + 4</font><font color="#E5E5E5"> apparently it is a pointer</font>

216
00:12:02,250 --> 00:12:12,680
<font color="#CCCCCC">because the next thing</font><font color="#E5E5E5"> we do we read</font>

217
00:12:05,100 --> 00:12:16,440
abide<font color="#E5E5E5"> from</font><font color="#CCCCCC"> EI x + 1 then we subtract 6</font>

218
00:12:12,680 --> 00:12:19,920
<font color="#CCCCCC">261</font><font color="#E5E5E5"> and if it's 0 then we jump somewhere</font>

219
00:12:16,440 --> 00:12:23,460
<font color="#CCCCCC">else apparently</font><font color="#E5E5E5"> it is a fancy way</font><font color="#CCCCCC"> of</font>

220
00:12:19,920 --> 00:12:26,520
comparing<font color="#CCCCCC"> DL against 64 hexadecimal</font>

221
00:12:23,460 --> 00:12:28,650
let's look like how<font color="#E5E5E5"> will what will</font>

222
00:12:26,520 --> 00:12:31,920
happen what kind of<font color="#CCCCCC"> Miko</font><font color="#E5E5E5"> Mike report</font>

223
00:12:28,650 --> 00:12:36,569
will be generated for<font color="#E5E5E5"> that that's it as</font>

224
00:12:31,920 --> 00:12:42,540
you see out of<font color="#CCCCCC"> 4 instructions we got 20</font>

225
00:12:36,570 --> 00:12:45,270
instructions and on the<font color="#E5E5E5"> column just</font>

226
00:12:42,540 --> 00:12:47,939
<font color="#CCCCCC">write to the semicolon you will see the</font>

227
00:12:45,270 --> 00:12:52,290
addresses of<font color="#E5E5E5"> the original instructions</font>

228
00:12:47,940 --> 00:12:58,550
for example the instruction at FB got

229
00:12:52,290 --> 00:13:03,660
<font color="#E5E5E5">translated into 5 micro instructions and</font>

230
00:12:58,550 --> 00:13:06,430
instruction at<font color="#CCCCCC"> the</font><font color="#E5E5E5"> 501 got translated</font>

231
00:13:03,660 --> 00:13:08,709
<font color="#E5E5E5">into how many of them 7</font>

232
00:13:06,430 --> 00:13:13,589
seven -<font color="#CCCCCC"> microinstructions you see that</font>

233
00:13:08,710 --> 00:13:15,120
<font color="#E5E5E5">all</font><font color="#CCCCCC"> side-effects are spelled out</font>

234
00:13:13,590 --> 00:13:20,290
explicitly

235
00:13:15,120 --> 00:13:22,720
it's very verbose so we cannot<font color="#E5E5E5"> present</font>

236
00:13:20,290 --> 00:13:26,219
<font color="#CCCCCC">this</font><font color="#E5E5E5"> to a human being because</font><font color="#CCCCCC"> it's not</font>

237
00:13:22,720 --> 00:13:28,570
<font color="#E5E5E5">that</font><font color="#CCCCCC"> eye readable not very nice -</font><font color="#E5E5E5"> to</font>

238
00:13:26,220 --> 00:13:30,460
handle<font color="#E5E5E5"> anyway so anyway what</font><font color="#CCCCCC"> we'll do</font>

239
00:13:28,570 --> 00:13:33,250
the next<font color="#CCCCCC"> step it</font><font color="#E5E5E5"> will try to optimize it</font>

240
00:13:30,460 --> 00:13:36,520
a bit<font color="#CCCCCC"> we'll throw</font><font color="#E5E5E5"> away anything that is</font>

241
00:13:33,250 --> 00:13:39,010
not that will<font color="#E5E5E5"> be used we will remove the</font>

242
00:13:36,520 --> 00:13:41,699
dead<font color="#CCCCCC"> folds at dead code and then we end</font>

243
00:13:39,010 --> 00:13:44,050
up with<font color="#E5E5E5"> only</font><font color="#CCCCCC"> nine micro instructions</font>

244
00:13:41,700 --> 00:13:48,010
<font color="#E5E5E5">another thing that we did with micro</font>

245
00:13:44,050 --> 00:13:50,380
code is that<font color="#CCCCCC"> we forwarded propagated</font>

246
00:13:48,010 --> 00:13:52,450
some instructions<font color="#E5E5E5"> into another</font>

247
00:13:50,380 --> 00:13:55,150
instructions<font color="#E5E5E5"> take for example the very</font>

248
00:13:52,450 --> 00:13:57,730
first instruction here<font color="#CCCCCC"> it's LD X which</font>

249
00:13:55,150 --> 00:14:01,740
stands for<font color="#E5E5E5"> load from memory it loads</font>

250
00:13:57,730 --> 00:14:05,910
from<font color="#E5E5E5"> the memory and the offset is</font>

251
00:14:01,740 --> 00:14:08,380
specified<font color="#E5E5E5"> as</font><font color="#CCCCCC"> EBE X</font><font color="#E5E5E5"> plus four wishes</font><font color="#CCCCCC"> an</font>

252
00:14:05,910 --> 00:14:13,350
additional<font color="#CCCCCC"> instruction so the addition</font>

253
00:14:08,380 --> 00:14:16,420
instruction got propagated into LD X

254
00:14:13,350 --> 00:14:19,480
this kind of makes<font color="#E5E5E5"> the microcode</font>

255
00:14:16,420 --> 00:14:22,800
slightly more complex<font color="#E5E5E5"> than initially but</font>

256
00:14:19,480 --> 00:14:27,010
on the other hand<font color="#E5E5E5"> it will allow us to</font>

257
00:14:22,800 --> 00:14:29,280
<font color="#E5E5E5">represent nicely at the very end when</font>

258
00:14:27,010 --> 00:14:32,319
the the compiler will finish its work

259
00:14:29,280 --> 00:14:34,780
<font color="#E5E5E5">let's continue there will be further</font>

260
00:14:32,320 --> 00:14:37,780
<font color="#CCCCCC">microcode transformations I will not</font>

261
00:14:34,780 --> 00:14:40,900
stop at them in detail<font color="#E5E5E5"> but what we all</font>

262
00:14:37,780 --> 00:14:43,209
have we will first have three

263
00:14:40,900 --> 00:14:46,390
instructions and finally<font color="#E5E5E5"> we'll just have</font>

264
00:14:43,210 --> 00:14:47,620
one very long<font color="#E5E5E5"> micro instruction this</font>

265
00:14:46,390 --> 00:14:50,620
<font color="#E5E5E5">micro instruction does not really</font>

266
00:14:47,620 --> 00:14:53,380
deserve its<font color="#E5E5E5"> name anymore because not on</font>

267
00:14:50,620 --> 00:14:56,050
micro<font color="#E5E5E5"> it's it became very very complex</font>

268
00:14:53,380 --> 00:15:01,439
instruction but<font color="#E5E5E5"> other on the</font><font color="#CCCCCC"> other hand</font>

269
00:14:56,050 --> 00:15:07,359
it has<font color="#CCCCCC"> a very nice feature</font><font color="#E5E5E5"> of being</font>

270
00:15:01,440 --> 00:15:10,690
translatable into<font color="#E5E5E5"> C 3 so if we translate</font>

271
00:15:07,360 --> 00:15:14,770
<font color="#CCCCCC">it into</font><font color="#E5E5E5"> C 3 we will get a very nice</font><font color="#CCCCCC"> if</font>

272
00:15:10,690 --> 00:15:19,360
if RV<font color="#E5E5E5"> apparently are the initial is a</font>

273
00:15:14,770 --> 00:15:23,410
<font color="#CCCCCC">EBX</font><font color="#E5E5E5"> contained pointer</font><font color="#CCCCCC"> to it was</font><font color="#E5E5E5"> arc</font><font color="#CCCCCC"> v</font>

274
00:15:19,360 --> 00:15:31,810
<font color="#E5E5E5">then be just that if arc v1 1 is</font><font color="#CCCCCC"> equal</font>

275
00:15:23,410 --> 00:15:33,390
to<font color="#CCCCCC"> a then we do something well I'm sorry</font>

276
00:15:31,810 --> 00:15:36,250
that<font color="#E5E5E5"> reading microcode is not easy</font>

277
00:15:33,390 --> 00:15:39,370
<font color="#CCCCCC">because</font><font color="#E5E5E5"> it was</font><font color="#CCCCCC"> not one of</font><font color="#E5E5E5"> the initial</font>

278
00:15:36,250 --> 00:15:43,829
design goals<font color="#CCCCCC"> as you see all</font><font color="#E5E5E5"> operand</font>

279
00:15:39,370 --> 00:15:46,180
sizes I<font color="#E5E5E5"> explode spelt out explicitly and</font>

280
00:15:43,829 --> 00:15:52,449
well the initial<font color="#E5E5E5"> macro code was simple</font>

281
00:15:46,180 --> 00:15:55,420
but<font color="#E5E5E5"> then it became quite complex so the</font>

282
00:15:52,450 --> 00:15:59,019
<font color="#CCCCCC">translation from</font><font color="#E5E5E5"> native processor</font>

283
00:15:55,420 --> 00:16:03,490
instructions to micro instruction have

284
00:15:59,019 --> 00:16:06,370
been implemented<font color="#CCCCCC"> in</font><font color="#E5E5E5"> plain C++ for now we</font>

285
00:16:03,490 --> 00:16:08,200
don't<font color="#E5E5E5"> use any automatic code generations</font>

286
00:16:06,370 --> 00:16:11,560
<font color="#E5E5E5">or machine description to generate them</font>

287
00:16:08,200 --> 00:16:15,690
<font color="#E5E5E5">maybe it's a good idea but so far I</font>

288
00:16:11,560 --> 00:16:15,689
don't<font color="#E5E5E5"> feel that we are ready</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> that</font>

289
00:16:15,750 --> 00:16:24,640
<font color="#CCCCCC">now I</font><font color="#E5E5E5"> will</font><font color="#CCCCCC"> just go</font><font color="#E5E5E5"> quite</font><font color="#CCCCCC"> hopefully I</font>

290
00:16:21,070 --> 00:16:28,120
will go<font color="#E5E5E5"> quickly and tell you about the</font>

291
00:16:24,640 --> 00:16:30,790
possible instructions that<font color="#E5E5E5"> exist in</font>

292
00:16:28,120 --> 00:16:33,990
micro code as<font color="#E5E5E5"> you will see they are</font>

293
00:16:30,790 --> 00:16:38,829
<font color="#E5E5E5">quite straightforward</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> on to the hand</font>

294
00:16:33,990 --> 00:16:42,910
<font color="#CCCCCC">this 72 up codes</font><font color="#E5E5E5"> cover all current needs</font>

295
00:16:38,829 --> 00:16:45,540
that we have<font color="#CCCCCC"> with real-world</font><font color="#E5E5E5"> programs so</font>

296
00:16:42,910 --> 00:16:51,100
the first<font color="#E5E5E5"> group is</font><font color="#CCCCCC"> the two instructions</font>

297
00:16:45,540 --> 00:16:55,899
<font color="#E5E5E5">they just move valuable values from one</font>

298
00:16:51,100 --> 00:17:01,620
place to another<font color="#E5E5E5"> place in fact we have</font>

299
00:16:55,899 --> 00:17:05,589
here<font color="#CCCCCC"> L and R left and destination</font>

300
00:17:01,620 --> 00:17:09,130
operands<font color="#E5E5E5"> in fact all micro instructions</font>

301
00:17:05,589 --> 00:17:11,530
have three operands<font color="#E5E5E5"> left right and</font>

302
00:17:09,130 --> 00:17:14,049
destination<font color="#E5E5E5"> don't ask me why it's called</font>

303
00:17:11,530 --> 00:17:18,970
left Ryan destination but<font color="#E5E5E5"> okay this like</font>

304
00:17:14,049 --> 00:17:24,119
this here we have load constant<font color="#CCCCCC"> and move</font>

305
00:17:18,970 --> 00:17:26,470
instructions<font color="#E5E5E5"> nothing fancy to represent</font>

306
00:17:24,119 --> 00:17:31,030
<font color="#CCCCCC">real-world programs we need to be able</font>

307
00:17:26,470 --> 00:17:32,940
<font color="#E5E5E5">to work</font><font color="#CCCCCC"> these parts of instruction parts</font>

308
00:17:31,030 --> 00:17:36,908
of registers

309
00:17:32,940 --> 00:17:39,700
<font color="#E5E5E5">read or write on the one</font><font color="#CCCCCC"> byte or part of</font>

310
00:17:36,909 --> 00:17:42,669
<font color="#E5E5E5">the double</font><font color="#CCCCCC"> word</font><font color="#E5E5E5"> therefore we need to</font>

311
00:17:39,700 --> 00:17:47,260
<font color="#E5E5E5">change the operand size for that we have</font>

312
00:17:42,669 --> 00:17:51,820
four instructions<font color="#CCCCCC"> extents sign or extent</font>

313
00:17:47,260 --> 00:17:57,700
<font color="#E5E5E5">with</font><font color="#CCCCCC"> zero</font><font color="#E5E5E5"> zero field and take low or</font>

314
00:17:51,820 --> 00:18:00,370
high parts of operand<font color="#E5E5E5"> and here as in any</font>

315
00:17:57,700 --> 00:18:02,769
other instruction<font color="#E5E5E5"> the left and</font>

316
00:18:00,370 --> 00:18:05,529
destination operands can<font color="#CCCCCC"> be anything it</font>

317
00:18:02,769 --> 00:18:09,190
can be<font color="#E5E5E5"> register it can be stack it can</font>

318
00:18:05,529 --> 00:18:13,809
be<font color="#CCCCCC"> a global</font><font color="#E5E5E5"> memory or even more</font><font color="#CCCCCC"> complex</font>

319
00:18:09,190 --> 00:18:15,700
things there are only two instructions

320
00:18:13,809 --> 00:18:19,600
that work with the memory<font color="#E5E5E5"> initially we</font>

321
00:18:15,700 --> 00:18:23,649
have stored to memory<font color="#E5E5E5"> and read from</font>

322
00:18:19,600 --> 00:18:26,559
<font color="#E5E5E5">memory</font><font color="#CCCCCC"> they have they denote the memory</font>

323
00:18:23,649 --> 00:18:30,658
locations<font color="#E5E5E5"> by using a pair</font><font color="#CCCCCC"> of a selector</font>

324
00:18:26,559 --> 00:18:34,149
<font color="#E5E5E5">and offset this will allow us</font><font color="#CCCCCC"> to handle</font>

325
00:18:30,659 --> 00:18:38,130
<font color="#E5E5E5">segmented memory if there's an if if you</font>

326
00:18:34,149 --> 00:18:42,189
need to do so<font color="#E5E5E5"> so far we were using</font><font color="#CCCCCC"> only</font>

327
00:18:38,130 --> 00:18:45,070
flat<font color="#E5E5E5"> memory model so the this feature of</font>

328
00:18:42,190 --> 00:18:49,779
micro code was not<font color="#E5E5E5"> really used but it is</font>

329
00:18:45,070 --> 00:18:52,990
there<font color="#E5E5E5"> for the future we have a very</font>

330
00:18:49,779 --> 00:18:56,500
natural<font color="#E5E5E5"> and standard set of comparisons</font>

331
00:18:52,990 --> 00:18:59,710
<font color="#E5E5E5">they compare the left operand against</font>

332
00:18:56,500 --> 00:19:03,159
the right operand<font color="#E5E5E5"> and put the result in</font>

333
00:18:59,710 --> 00:19:07,200
the form<font color="#CCCCCC"> of</font><font color="#E5E5E5"> 0</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> into the</font><font color="#CCCCCC"> destination</font>

334
00:19:03,159 --> 00:19:10,840
operand<font color="#E5E5E5"> so these instructions are</font><font color="#CCCCCC"> used</font>

335
00:19:07,200 --> 00:19:16,899
mainly to generate processor condition

336
00:19:10,840 --> 00:19:19,779
codes<font color="#E5E5E5"> and the destination register is</font>

337
00:19:16,899 --> 00:19:23,860
usually something<font color="#E5E5E5"> like a carry flag</font><font color="#CCCCCC"> 0</font>

338
00:19:19,779 --> 00:19:27,010
flag and so on but we<font color="#E5E5E5"> don't really limit</font>

339
00:19:23,860 --> 00:19:31,209
them to<font color="#E5E5E5"> the</font><font color="#CCCCCC"> Preda</font><font color="#E5E5E5"> predefined set of</font>

340
00:19:27,010 --> 00:19:37,210
registers<font color="#CCCCCC"> so</font><font color="#E5E5E5"> therefore even</font><font color="#CCCCCC"> PowerPC for</font>

341
00:19:31,210 --> 00:19:40,330
example with its four sets of condition

342
00:19:37,210 --> 00:19:43,950
codes can<font color="#CCCCCC"> be handled very</font><font color="#E5E5E5"> nicely by the</font>

343
00:19:40,330 --> 00:19:46,658
microcode<font color="#E5E5E5"> then we have</font>

344
00:19:43,950 --> 00:19:53,020
natural set of arithmetic and bitwise

345
00:19:46,659 --> 00:19:56,590
operations last<font color="#CCCCCC"> thing</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> say here the</font>

346
00:19:53,020 --> 00:19:58,809
shifts we have only<font color="#CCCCCC"> three shifts</font><font color="#E5E5E5"> and no</font>

347
00:19:56,590 --> 00:20:01,209
rotations at the<font color="#E5E5E5"> rotation operator</font>

348
00:19:58,809 --> 00:20:04,450
operations we exist that initially<font color="#E5E5E5"> in</font>

349
00:20:01,210 --> 00:20:06,370
the<font color="#E5E5E5"> microcode but later we decide to</font>

350
00:20:04,450 --> 00:20:09,309
throw<font color="#E5E5E5"> them away because they turned out</font>

351
00:20:06,370 --> 00:20:12,250
<font color="#CCCCCC">to be useless we cannot represent them</font>

352
00:20:09,309 --> 00:20:17,350
nicely in in the<font color="#E5E5E5"> C language</font><font color="#CCCCCC"> and since</font>

353
00:20:12,250 --> 00:20:21,100
our target is C then<font color="#E5E5E5"> it was not really</font>

354
00:20:17,350 --> 00:20:24,459
interesting to have them now<font color="#E5E5E5"> the last</font>

355
00:20:21,100 --> 00:20:26,799
<font color="#E5E5E5">microcode can represent rotations using</font>

356
00:20:24,460 --> 00:20:32,169
a<font color="#CCCCCC"> so called</font><font color="#E5E5E5"> helper functions</font><font color="#CCCCCC"> I will show</font>

357
00:20:26,799 --> 00:20:37,620
you<font color="#E5E5E5"> later we have the following group of</font>

358
00:20:32,169 --> 00:20:41,230
very fancy<font color="#CCCCCC"> and</font><font color="#E5E5E5"> odd instructions they are</font>

359
00:20:37,620 --> 00:20:44,620
<font color="#E5E5E5">necessary to precisely track the carry</font>

360
00:20:41,230 --> 00:20:47,470
and overflow beats after arithmetic

361
00:20:44,620 --> 00:20:49,809
operations like<font color="#CCCCCC"> add</font><font color="#E5E5E5"> for example</font><font color="#CCCCCC"> we have</font>

362
00:20:47,470 --> 00:20:53,700
a pair of instructions like<font color="#CCCCCC"> add and an</font>

363
00:20:49,809 --> 00:20:58,090
<font color="#CCCCCC">ADC</font><font color="#E5E5E5"> this pair</font><font color="#CCCCCC"> is used very</font><font color="#E5E5E5"> often to</font>

364
00:20:53,700 --> 00:21:01,570
handle to implement<font color="#E5E5E5"> 64-bit operations on</font>

365
00:20:58,090 --> 00:21:05,559
the 32-bit<font color="#E5E5E5"> platforms or even to</font>

366
00:21:01,570 --> 00:21:08,918
implement 120<font color="#E5E5E5"> beta 28 bit operations on</font>

367
00:21:05,559 --> 00:21:11,020
64-bit processors and to be<font color="#CCCCCC"> able to</font>

368
00:21:08,919 --> 00:21:15,340
correct<font color="#E5E5E5"> their present things we need</font>

369
00:21:11,020 --> 00:21:17,789
these odd instructions normally they get

370
00:21:15,340 --> 00:21:23,020
<font color="#CCCCCC">eliminated during micro transformations</font>

371
00:21:17,789 --> 00:21:25,480
once we detect that<font color="#E5E5E5"> a add and</font><font color="#CCCCCC"> a DC</font><font color="#E5E5E5"> they</font>

372
00:21:23,020 --> 00:21:30,668
come in pair we<font color="#CCCCCC"> will combine them into</font>

373
00:21:25,480 --> 00:21:36,549
one<font color="#E5E5E5"> big addition instruction and</font><font color="#CCCCCC"> CF add</font>

374
00:21:30,669 --> 00:21:41,429
for<font color="#CCCCCC"> example will simply disappear</font><font color="#E5E5E5"> then</font>

375
00:21:36,549 --> 00:21:44,650
we have<font color="#E5E5E5"> control flow instructions like</font>

376
00:21:41,429 --> 00:21:47,679
<font color="#E5E5E5">indirect</font><font color="#CCCCCC"> jab</font><font color="#E5E5E5"> indirect jumps and go tools</font>

377
00:21:44,650 --> 00:21:51,789
indirect jumps normally should go away

378
00:21:47,679 --> 00:21:54,230
<font color="#CCCCCC">after some transformations if not then</font>

379
00:21:51,789 --> 00:21:58,310
it's bad luck<font color="#CCCCCC"> because</font>

380
00:21:54,230 --> 00:22:01,190
in<font color="#CCCCCC"> the language there's no</font><font color="#E5E5E5"> counterpart</font>

381
00:21:58,310 --> 00:22:04,310
there's no nice way of representing

382
00:22:01,190 --> 00:22:07,580
indirect jumps the calls<font color="#CCCCCC"> there are two</font>

383
00:22:04,310 --> 00:22:12,020
different instructions<font color="#E5E5E5"> for them direct</font>

384
00:22:07,580 --> 00:22:14,090
and indirect calls<font color="#CCCCCC"> this is a very tough</font>

385
00:22:12,020 --> 00:22:16,310
problem with the<font color="#CCCCCC"> call instructions</font>

386
00:22:14,090 --> 00:22:20,209
<font color="#E5E5E5">because</font><font color="#CCCCCC"> when we</font><font color="#E5E5E5"> have a call</font>

387
00:22:16,310 --> 00:22:22,690
native instruction<font color="#E5E5E5"> we don't know what is</font>

388
00:22:20,210 --> 00:22:26,660
the calling convention<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> don't know</font>

389
00:22:22,690 --> 00:22:29,930
<font color="#E5E5E5">with the return value and and this is</font>

390
00:22:26,660 --> 00:22:32,380
<font color="#E5E5E5">one of the biggest problems during</font>

391
00:22:29,930 --> 00:22:40,310
reverse engineer during<font color="#CCCCCC"> the compilation</font>

392
00:22:32,380 --> 00:22:42,650
<font color="#E5E5E5">to</font><font color="#CCCCCC"> determine them and if we</font><font color="#E5E5E5"> are lucky we</font>

393
00:22:40,310 --> 00:22:46,100
are<font color="#CCCCCC"> calling</font><font color="#E5E5E5"> a via we call a</font><font color="#CCCCCC"> well-known</font>

394
00:22:42,650 --> 00:22:48,170
function like closed handle<font color="#E5E5E5"> create file</font>

395
00:22:46,100 --> 00:22:51,290
<font color="#E5E5E5">then we know the</font><font color="#CCCCCC"> calling conversion</font>

396
00:22:48,170 --> 00:22:55,430
everything if not the<font color="#E5E5E5"> D compiler will</font>

397
00:22:51,290 --> 00:22:58,570
try to guess the<font color="#E5E5E5"> this information of the</font>

398
00:22:55,430 --> 00:23:02,680
calling<font color="#E5E5E5"> conventions or call arguments</font>

399
00:22:58,570 --> 00:23:06,860
and all<font color="#CCCCCC"> this</font><font color="#E5E5E5"> information will</font><font color="#CCCCCC"> be stored</font>

400
00:23:02,680 --> 00:23:09,220
in<font color="#E5E5E5"> the D operand</font><font color="#CCCCCC"> and at the</font><font color="#E5E5E5"> bottom of</font>

401
00:23:06,860 --> 00:23:14,179
the slide<font color="#CCCCCC"> you will see that</font><font color="#E5E5E5"> how we</font>

402
00:23:09,220 --> 00:23:16,960
represent<font color="#E5E5E5"> the cold instructions you see</font>

403
00:23:14,180 --> 00:23:21,100
that there's a lot<font color="#CCCCCC"> of detail here and</font>

404
00:23:16,960 --> 00:23:25,850
and this detail is enough to represent

405
00:23:21,100 --> 00:23:28,600
<font color="#E5E5E5">again all</font><font color="#CCCCCC"> real-world programs</font><font color="#E5E5E5"> but almost</font>

406
00:23:25,850 --> 00:23:32,419
all because recently as they were

407
00:23:28,600 --> 00:23:35,000
someone<font color="#E5E5E5"> complaining about</font><font color="#CCCCCC"> our</font><font color="#E5E5E5"> the</font>

408
00:23:32,420 --> 00:23:39,350
<font color="#E5E5E5">compiler not being able to handle some</font>

409
00:23:35,000 --> 00:23:45,680
rust<font color="#E5E5E5"> language constructs</font><font color="#CCCCCC"> but we will fix</font>

410
00:23:39,350 --> 00:23:49,820
<font color="#E5E5E5">that in the future the next group is the</font>

411
00:23:45,680 --> 00:23:52,460
conditional jumps group they<font color="#E5E5E5"> are similar</font>

412
00:23:49,820 --> 00:23:55,129
to<font color="#CCCCCC"> the</font><font color="#E5E5E5"> instructions</font><font color="#CCCCCC"> that generating a</font>

413
00:23:52,460 --> 00:23:58,220
kind of<font color="#E5E5E5"> processor condition codes so we</font>

414
00:23:55,130 --> 00:24:00,680
have a jump very standard set of jump

415
00:23:58,220 --> 00:24:03,920
<font color="#E5E5E5">zero jump non zero greater and so and</font><font color="#CCCCCC"> so</font>

416
00:24:00,680 --> 00:24:06,950
<font color="#E5E5E5">on</font><font color="#CCCCCC"> maybe the first and the very last</font>

417
00:24:03,920 --> 00:24:07,530
instructions<font color="#E5E5E5"> are somehow special here</font>

418
00:24:06,950 --> 00:24:12,720
it's

419
00:24:07,530 --> 00:24:16,500
conditional means<font color="#E5E5E5"> jump</font><font color="#CCCCCC"> evaluate</font><font color="#E5E5E5"> the left</font>

420
00:24:12,720 --> 00:24:19,860
operand<font color="#E5E5E5"> and if it's</font><font color="#CCCCCC"> nonzero then take</font>

421
00:24:16,500 --> 00:24:22,560
the jump to the destination<font color="#E5E5E5"> and jump</font>

422
00:24:19,860 --> 00:24:30,209
table<font color="#E5E5E5"> is used to represent the switch</font>

423
00:24:22,560 --> 00:24:32,940
idioms in the output initially we had no

424
00:24:30,210 --> 00:24:36,740
floating-point operations but since our

425
00:24:32,940 --> 00:24:41,210
<font color="#CCCCCC">goal is to</font><font color="#E5E5E5"> be able</font><font color="#CCCCCC"> to represent</font>

426
00:24:36,740 --> 00:24:45,420
<font color="#E5E5E5">real-world</font><font color="#CCCCCC"> programs</font><font color="#E5E5E5"> then we had to add</font>

427
00:24:41,210 --> 00:24:48,000
the necessary<font color="#E5E5E5"> stuff as it turns out it's</font>

428
00:24:45,420 --> 00:24:54,030
<font color="#CCCCCC">not that big you see</font><font color="#E5E5E5"> CT we just need a</font>

429
00:24:48,000 --> 00:24:57,030
few conversion instructions and<font color="#E5E5E5"> and a</font>

430
00:24:54,030 --> 00:24:59,840
few arithmetic operations for operations

431
00:24:57,030 --> 00:25:04,310
<font color="#E5E5E5">like add subtract multiply divide</font>

432
00:24:59,840 --> 00:25:09,060
negation and that's it<font color="#E5E5E5"> the rest like</font>

433
00:25:04,310 --> 00:25:11,280
built-in functions<font color="#E5E5E5"> like casinos or</font>

434
00:25:09,060 --> 00:25:14,280
<font color="#E5E5E5">logarithm and other things can be</font>

435
00:25:11,280 --> 00:25:17,550
<font color="#CCCCCC">handled using a</font><font color="#E5E5E5"> so called helper</font>

436
00:25:14,280 --> 00:25:21,899
functions<font color="#E5E5E5"> I will show you later</font>

437
00:25:17,550 --> 00:25:24,560
<font color="#E5E5E5">hopefully and finally we have some the</font>

438
00:25:21,900 --> 00:25:27,180
<font color="#E5E5E5">last group it's called</font><font color="#CCCCCC"> the miscellaneous</font>

439
00:25:24,560 --> 00:25:30,649
<font color="#E5E5E5">the most interesting instruction here I</font>

440
00:25:27,180 --> 00:25:34,080
think<font color="#E5E5E5"> that it's a external instruction</font>

441
00:25:30,650 --> 00:25:38,490
because some<font color="#CCCCCC"> processor</font><font color="#E5E5E5"> instructions</font>

442
00:25:34,080 --> 00:25:41,310
cannot<font color="#E5E5E5"> be expressive microcode take</font>

443
00:25:38,490 --> 00:25:45,780
something like<font color="#E5E5E5"> load</font><font color="#CCCCCC"> interrupt this</font>

444
00:25:41,310 --> 00:25:52,950
descriptor or system call or other

445
00:25:45,780 --> 00:25:55,740
things we don't let's say square root<font color="#E5E5E5"> we</font>

446
00:25:52,950 --> 00:25:58,820
don't have<font color="#E5E5E5"> microcode instructions for</font>

447
00:25:55,740 --> 00:26:01,920
them and they are<font color="#E5E5E5"> represented</font><font color="#CCCCCC"> either</font>

448
00:25:58,820 --> 00:26:06,060
using<font color="#E5E5E5"> so called increasing calls or</font>

449
00:26:01,920 --> 00:26:09,890
helper calls<font color="#E5E5E5"> or the external destruction</font>

450
00:26:06,060 --> 00:26:13,080
<font color="#CCCCCC">the externally micro instruction just</font>

451
00:26:09,890 --> 00:26:16,350
tells us that this<font color="#CCCCCC"> is something that</font><font color="#E5E5E5"> we</font>

452
00:26:13,080 --> 00:26:19,889
cannot express in the micro code but it

453
00:26:16,350 --> 00:26:21,389
helps us<font color="#E5E5E5"> to trace the data dependencies</font>

454
00:26:19,890 --> 00:26:26,599
so<font color="#CCCCCC"> we know for example</font>

455
00:26:21,389 --> 00:26:30,570
<font color="#CCCCCC">sample that</font><font color="#E5E5E5"> I am ill will</font><font color="#CCCCCC"> used is it ax</font>

456
00:26:26,599 --> 00:26:33,839
<font color="#CCCCCC">eh I think that it used a H resistor and</font>

457
00:26:30,570 --> 00:26:38,178
modifies<font color="#E5E5E5"> al I don't remember what AM am</font>

458
00:26:33,839 --> 00:26:42,928
does<font color="#E5E5E5"> but anyway it</font><font color="#CCCCCC"> just allows us to</font>

459
00:26:38,179 --> 00:26:46,829
trace the data dependencies<font color="#E5E5E5"> and we also</font>

460
00:26:42,929 --> 00:26:50,389
the instruction called undefined<font color="#CCCCCC"> is used</font>

461
00:26:46,829 --> 00:26:53,668
to represent<font color="#E5E5E5"> to express the fact</font><font color="#CCCCCC"> that</font>

462
00:26:50,389 --> 00:26:55,889
something is spoiled<font color="#CCCCCC"> in a way</font><font color="#E5E5E5"> that we</font>

463
00:26:53,669 --> 00:26:58,969
cannot predict<font color="#E5E5E5"> to describe</font><font color="#CCCCCC"> for example</font>

464
00:26:55,889 --> 00:27:04,589
the zero flag<font color="#E5E5E5"> after</font><font color="#CCCCCC"> multiplication is</font>

465
00:26:58,969 --> 00:27:08,099
spoiled that's<font color="#E5E5E5"> it you see that</font><font color="#CCCCCC"> it does</font>

466
00:27:04,589 --> 00:27:10,289
not<font color="#CCCCCC"> that</font><font color="#E5E5E5"> fast and we have</font><font color="#CCCCCC"> this 72</font>

467
00:27:08,099 --> 00:27:11,849
instructions<font color="#E5E5E5"> maybe it should extend it a</font>

468
00:27:10,289 --> 00:27:15,079
<font color="#CCCCCC">bit but</font><font color="#E5E5E5"> I don't</font><font color="#CCCCCC"> feel</font><font color="#E5E5E5"> the need right now</font>

469
00:27:11,849 --> 00:27:19,639
<font color="#CCCCCC">exclude</font><font color="#E5E5E5"> it looks good and I think that</font>

470
00:27:15,079 --> 00:27:21,989
we<font color="#CCCCCC"> will stay like this for a while</font><font color="#E5E5E5"> so</font>

471
00:27:19,639 --> 00:27:25,228
now let's switch<font color="#E5E5E5"> to the operands because</font>

472
00:27:21,989 --> 00:27:28,049
I discovered<font color="#E5E5E5"> discussed the instruction</font>

473
00:27:25,229 --> 00:27:35,039
<font color="#E5E5E5">of course but I did not show you what</font>

474
00:27:28,049 --> 00:27:37,289
they operate on<font color="#E5E5E5"> well if you take as</font>

475
00:27:35,039 --> 00:27:40,499
everyone knows<font color="#CCCCCC"> we initially we had only</font>

476
00:27:37,289 --> 00:27:43,379
<font color="#CCCCCC">two things numbers</font><font color="#E5E5E5"> and registers it was</font>

477
00:27:40,499 --> 00:27:45,389
very simple<font color="#CCCCCC"> because we take register we</font>

478
00:27:43,379 --> 00:27:47,579
put a value<font color="#E5E5E5"> into a register</font><font color="#CCCCCC"> we know that</font>

479
00:27:45,389 --> 00:27:50,519
it<font color="#CCCCCC"> won't go</font><font color="#E5E5E5"> away it won't disappear</font><font color="#CCCCCC"> it</font>

480
00:27:47,579 --> 00:27:53,279
won't be changed by someone else

481
00:27:50,519 --> 00:27:56,190
in other words only<font color="#CCCCCC"> direct accesses are</font>

482
00:27:53,279 --> 00:27:58,200
possible<font color="#E5E5E5"> in direct accessible as access</font>

483
00:27:56,190 --> 00:28:00,419
<font color="#E5E5E5">to registers are not possible and</font>

484
00:27:58,200 --> 00:28:03,809
therefore<font color="#E5E5E5"> it was very simple</font><font color="#CCCCCC"> to analyze</font>

485
00:28:00,419 --> 00:28:07,259
things but the reality<font color="#CCCCCC"> is much more</font>

486
00:28:03,809 --> 00:28:11,399
diverse<font color="#CCCCCC"> than that and we had</font><font color="#E5E5E5"> to add a</font>

487
00:28:07,259 --> 00:28:14,309
lot of new<font color="#CCCCCC"> operand types logically</font><font color="#E5E5E5"> we</font>

488
00:28:11,399 --> 00:28:18,449
started with stack variables then<font color="#E5E5E5"> global</font>

489
00:28:14,309 --> 00:28:20,879
<font color="#E5E5E5">variables and addresses result of</font><font color="#CCCCCC"> as</font>

490
00:28:18,450 --> 00:28:23,009
instructions<font color="#E5E5E5"> and so on and so</font><font color="#CCCCCC"> on the</font>

491
00:28:20,879 --> 00:28:25,708
<font color="#E5E5E5">list is not exhaustive here they are</font>

492
00:28:23,009 --> 00:28:28,709
much more<font color="#E5E5E5"> instruction types than the</font>

493
00:28:25,709 --> 00:28:32,820
slides<font color="#CCCCCC"> trolls</font><font color="#E5E5E5"> but anyway just</font><font color="#CCCCCC"> I will</font>

494
00:28:28,709 --> 00:28:36,900
stop on some of these operands

495
00:28:32,820 --> 00:28:39,810
then we'll<font color="#E5E5E5"> discuss what how</font><font color="#CCCCCC"> Mia</font>

496
00:28:36,900 --> 00:28:43,530
<font color="#CCCCCC">microcode</font><font color="#E5E5E5"> can be used the</font><font color="#CCCCCC"> register</font>

497
00:28:39,810 --> 00:28:50,070
operands if you<font color="#E5E5E5"> work these xe6 you know</font>

498
00:28:43,530 --> 00:28:54,270
that it<font color="#E5E5E5"> has a very funny way of funny</font>

499
00:28:50,070 --> 00:28:58,950
register set we have<font color="#CCCCCC"> EAX it has parts of</font>

500
00:28:54,270 --> 00:29:00,720
<font color="#CCCCCC">e</font><font color="#E5E5E5"> l eh and it's quite difficult to work</font>

501
00:28:58,950 --> 00:29:03,930
with<font color="#E5E5E5"> them we don't want</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> kind of</font>

502
00:29:00,720 --> 00:29:06,360
mess in the microcode therefore all<font color="#E5E5E5"> of</font>

503
00:29:03,930 --> 00:29:09,510
them are mapped to micro registers for

504
00:29:06,360 --> 00:29:13,159
example<font color="#E5E5E5"> a</font><font color="#CCCCCC"> ax is mapped into four micro</font>

505
00:29:09,510 --> 00:29:15,960
register 1 micro register is<font color="#CCCCCC"> 1 byte</font><font color="#E5E5E5"> and</font>

506
00:29:13,160 --> 00:29:18,980
this mapping<font color="#E5E5E5"> is</font><font color="#CCCCCC"> very straightforward</font>

507
00:29:15,960 --> 00:29:22,110
<font color="#E5E5E5">very simple it can be done</font>

508
00:29:18,980 --> 00:29:24,570
forward and backward<font color="#CCCCCC"> we can go</font><font color="#E5E5E5"> back from</font>

509
00:29:22,110 --> 00:29:27,419
micro registers to back to processor

510
00:29:24,570 --> 00:29:32,760
registers and it it helps to understand

511
00:29:27,420 --> 00:29:36,090
<font color="#E5E5E5">the code and usually there are more</font>

512
00:29:32,760 --> 00:29:37,980
micro registers in<font color="#E5E5E5"> the in the code than</font>

513
00:29:36,090 --> 00:29:40,709
processor<font color="#E5E5E5"> resistors</font><font color="#CCCCCC"> beacon we can</font>

514
00:29:37,980 --> 00:29:48,000
<font color="#CCCCCC">allocate them as needed when</font><font color="#E5E5E5"> we generate</font>

515
00:29:40,710 --> 00:29:50,760
<font color="#E5E5E5">the microcode once I implemented the</font>

516
00:29:48,000 --> 00:29:56,640
<font color="#CCCCCC">first very first version</font><font color="#E5E5E5"> of the</font>

517
00:29:50,760 --> 00:30:02,670
microcode<font color="#E5E5E5"> engine and added some rules to</font>

518
00:29:56,640 --> 00:30:04,170
simplify<font color="#E5E5E5"> it to</font><font color="#CCCCCC"> optimize it nature</font><font color="#E5E5E5"> well</font>

519
00:30:02,670 --> 00:30:09,510
it was natural that they work with

520
00:30:04,170 --> 00:30:13,880
registers<font color="#CCCCCC"> like for example saw</font><font color="#E5E5E5"> ax ax</font><font color="#CCCCCC"> it</font>

521
00:30:09,510 --> 00:30:18,180
is the same thing as putting<font color="#E5E5E5"> 0 into</font><font color="#CCCCCC"> e ax</font>

522
00:30:13,880 --> 00:30:23,040
<font color="#CCCCCC">and I had no logic to</font><font color="#E5E5E5"> work with the</font>

523
00:30:18,180 --> 00:30:26,660
stack variables and I was lazy<font color="#E5E5E5"> and</font>

524
00:30:23,040 --> 00:30:30,870
decide<font color="#CCCCCC"> ye not just map</font><font color="#E5E5E5"> the stack frame</font>

525
00:30:26,660 --> 00:30:34,140
to micro registers<font color="#E5E5E5"> since we have</font>

526
00:30:30,870 --> 00:30:37,290
<font color="#CCCCCC">unlimited number of micro registers we</font>

527
00:30:34,140 --> 00:30:40,200
can just consider them<font color="#CCCCCC"> as</font><font color="#E5E5E5"> the same</font><font color="#CCCCCC"> thing</font>

528
00:30:37,290 --> 00:30:42,659
as<font color="#E5E5E5"> what stack variables as micro</font>

529
00:30:40,200 --> 00:30:45,260
registers initially it helped a lot

530
00:30:42,660 --> 00:30:49,480
<font color="#E5E5E5">because I did not me</font>

531
00:30:45,260 --> 00:30:54,860
<font color="#E5E5E5">to implement</font><font color="#CCCCCC"> to improve the existing</font>

532
00:30:49,480 --> 00:31:01,450
<font color="#CCCCCC">optimization rules</font><font color="#E5E5E5"> but later it kicked</font>

533
00:30:54,860 --> 00:31:03,770
up and it it it by it bit me because

534
00:31:01,450 --> 00:31:07,070
there<font color="#E5E5E5"> were many problems with the spec</font>

535
00:31:03,770 --> 00:31:08,900
variables like<font color="#CCCCCC"> indirect indirect</font>

536
00:31:07,070 --> 00:31:12,970
references to stack to the<font color="#E5E5E5"> stack frame</font>

537
00:31:08,900 --> 00:31:15,140
and therefore aspect variable cannot be

538
00:31:12,970 --> 00:31:19,690
considered<font color="#E5E5E5"> at the same thing as a</font>

539
00:31:15,140 --> 00:31:25,610
register it can be modified<font color="#E5E5E5"> by someone</font>

540
00:31:19,690 --> 00:31:28,160
using a pointer<font color="#E5E5E5"> so</font><font color="#CCCCCC"> we had to leave this</font>

541
00:31:25,610 --> 00:31:32,479
that for<font color="#CCCCCC"> a while</font><font color="#E5E5E5"> but finally I</font><font color="#CCCCCC"> can tell</font>

542
00:31:28,160 --> 00:31:40,220
you<font color="#E5E5E5"> that we fix the problem and now this</font>

543
00:31:32,480 --> 00:31:42,500
<font color="#E5E5E5">bad design decision will go</font><font color="#CCCCCC"> away just to</font>

544
00:31:40,220 --> 00:31:46,760
explain you<font color="#E5E5E5"> in more detail where the</font>

545
00:31:42,500 --> 00:31:49,400
problem is this slide shows<font color="#E5E5E5"> the stack</font>

546
00:31:46,760 --> 00:31:55,250
frame of a typical stack frame of a

547
00:31:49,400 --> 00:31:58,880
function the red areas are<font color="#CCCCCC"> the ones that</font>

548
00:31:55,250 --> 00:32:04,180
<font color="#E5E5E5">can be modified indirectly</font><font color="#CCCCCC"> and therefore</font>

549
00:31:58,880 --> 00:32:04,180
we cannot really reason about them<font color="#E5E5E5"> and</font>

550
00:32:04,420 --> 00:32:10,430
we can we<font color="#CCCCCC"> should not consider them as</font>

551
00:32:07,100 --> 00:32:14,719
<font color="#CCCCCC">the same thing as virtual registers as</font>

552
00:32:10,430 --> 00:32:18,710
micro registers<font color="#CCCCCC"> you see that in the</font>

553
00:32:14,720 --> 00:32:21,200
<font color="#E5E5E5">middle of this diagram we see the return</font>

554
00:32:18,710 --> 00:32:25,550
address just below the<font color="#E5E5E5"> return address</font>

555
00:32:21,200 --> 00:32:30,760
this red area we have saved<font color="#CCCCCC"> written some</font>

556
00:32:25,550 --> 00:32:35,000
local<font color="#CCCCCC"> variables and</font><font color="#E5E5E5"> beneath it</font><font color="#CCCCCC"> we have</font>

557
00:32:30,760 --> 00:32:37,850
unalienable local variables<font color="#E5E5E5"> therefore</font><font color="#CCCCCC"> we</font>

558
00:32:35,000 --> 00:32:42,590
can we have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> handle this all red and</font>

559
00:32:37,850 --> 00:32:47,360
yellow areas<font color="#E5E5E5"> in a different way for yet</font>

560
00:32:42,590 --> 00:32:49,029
the yellow area we can we can reason

561
00:32:47,360 --> 00:32:52,658
about the

562
00:32:49,029 --> 00:32:57,489
the variables we<font color="#CCCCCC"> can perform</font><font color="#E5E5E5"> dataflow</font>

563
00:32:52,659 --> 00:33:00,909
analysis while for the red area<font color="#E5E5E5"> it is it</font>

564
00:32:57,489 --> 00:33:04,869
is also possible<font color="#E5E5E5"> but we have to remember</font>

565
00:33:00,909 --> 00:33:12,089
that<font color="#CCCCCC"> any value that we stored can be</font>

566
00:33:04,869 --> 00:33:15,039
modified<font color="#E5E5E5"> indirectly</font><font color="#CCCCCC"> the initial stack</font>

567
00:33:12,089 --> 00:33:17,109
registers and constants these<font color="#E5E5E5"> three</font>

568
00:33:15,039 --> 00:33:21,369
<font color="#CCCCCC">operant types they were not enough of</font>

569
00:33:17,109 --> 00:33:24,759
<font color="#CCCCCC">course</font><font color="#E5E5E5"> very soon I had to add standard</font>

570
00:33:21,369 --> 00:33:26,619
<font color="#E5E5E5">payers like EDX and</font><font color="#CCCCCC"> e^x I was again it</font>

571
00:33:24,759 --> 00:33:30,489
was<font color="#CCCCCC"> lazy to do so therefore I just</font>

572
00:33:26,619 --> 00:33:33,549
<font color="#CCCCCC">mapped a</font><font color="#E5E5E5"> e^x and EDX so that they add</font>

573
00:33:30,489 --> 00:33:38,289
<font color="#CCCCCC">just and as microwave II registers and</font>

574
00:33:33,549 --> 00:33:42,189
instead<font color="#CCCCCC"> of</font><font color="#E5E5E5"> having two separate</font><font color="#CCCCCC"> four byte</font>

575
00:33:38,289 --> 00:33:46,209
micro registers<font color="#E5E5E5"> I ended up with a big 8</font>

576
00:33:42,189 --> 00:33:48,909
byte micro register but compilers get

577
00:33:46,209 --> 00:33:52,539
better over time<font color="#E5E5E5"> and modern compilers</font>

578
00:33:48,909 --> 00:33:56,069
can can use any registers as a pair<font color="#E5E5E5"> not</font>

579
00:33:52,539 --> 00:33:58,979
<font color="#E5E5E5">only a fixed like</font><font color="#CCCCCC"> edx and TX it</font><font color="#E5E5E5"> can be</font>

580
00:33:56,069 --> 00:34:02,709
anything it can<font color="#CCCCCC"> be even</font><font color="#E5E5E5"> a stack location</font>

581
00:33:58,979 --> 00:34:05,049
<font color="#E5E5E5">plus a register so a value is stored in</font>

582
00:34:02,709 --> 00:34:08,470
two different places<font color="#E5E5E5"> the high part is</font>

583
00:34:05,049 --> 00:34:11,799
stored in the location pointed by SP

584
00:34:08,469 --> 00:34:14,049
<font color="#E5E5E5">plus 4 and the low part is stored in</font>

585
00:34:11,799 --> 00:34:17,768
<font color="#CCCCCC">register</font><font color="#E5E5E5"> and the compiler can handle it</font>

586
00:34:14,049 --> 00:34:22,089
nicely since compilers do<font color="#CCCCCC"> this kind</font><font color="#E5E5E5"> of</font>

587
00:34:17,768 --> 00:34:23,859
nasty things<font color="#CCCCCC"> to</font><font color="#E5E5E5"> us we had to introduce a</font>

588
00:34:22,089 --> 00:34:26,440
new<font color="#CCCCCC"> operant type for it so it's called</font>

589
00:34:23,859 --> 00:34:31,179
<font color="#CCCCCC">operant</font><font color="#E5E5E5"> pair it exists in consists of</font>

590
00:34:26,440 --> 00:34:33,909
tool to<font color="#CCCCCC"> hots</font><font color="#E5E5E5"> low</font><font color="#CCCCCC"> and high part and this</font>

591
00:34:31,179 --> 00:34:40,059
house can<font color="#CCCCCC"> be located</font><font color="#E5E5E5"> anywhere anyway</font>

592
00:34:33,909 --> 00:34:44,529
stack registers or global memory well in

593
00:34:40,059 --> 00:34:47,970
fact this is<font color="#CCCCCC"> not enough since we again</font>

594
00:34:44,529 --> 00:34:51,879
we want to<font color="#E5E5E5"> represent</font><font color="#CCCCCC"> real</font><font color="#E5E5E5"> world programs</font>

595
00:34:47,969 --> 00:34:54,629
it's<font color="#E5E5E5"> not we cannot we have to</font><font color="#CCCCCC"> represent</font>

596
00:34:51,879 --> 00:35:00,779
real things<font color="#E5E5E5"> that are used by compilers</font>

597
00:34:54,629 --> 00:35:05,910
with<font color="#E5E5E5"> 60 in the 64-bit world these</font>

598
00:35:00,780 --> 00:35:07,950
the ABI<font color="#CCCCCC"> that is defined</font><font color="#E5E5E5"> like</font><font color="#CCCCCC"> one one had</font>

599
00:35:05,910 --> 00:35:09,779
in the<font color="#CCCCCC"> sixty four-bit</font><font color="#E5E5E5"> walk we have a</font>

600
00:35:07,950 --> 00:35:11,689
better situation<font color="#CCCCCC"> because we don't have</font>

601
00:35:09,780 --> 00:35:14,430
nightmare of<font color="#E5E5E5"> calling conventions</font>

602
00:35:11,690 --> 00:35:17,970
<font color="#CCCCCC">everyone follows a calling conversion</font>

603
00:35:14,430 --> 00:35:22,680
that<font color="#CCCCCC"> is specified</font><font color="#E5E5E5"> in the</font><font color="#CCCCCC"> ABI well</font><font color="#E5E5E5"> there</font>

604
00:35:17,970 --> 00:35:25,740
<font color="#E5E5E5">is a slight problem there because visual</font>

605
00:35:22,680 --> 00:35:27,690
<font color="#E5E5E5">studio on Windows and</font><font color="#CCCCCC"> GNU Compiler some</font>

606
00:35:25,740 --> 00:35:30,270
<font color="#E5E5E5">Linux they use different</font><font color="#CCCCCC"> coding</font>

607
00:35:27,690 --> 00:35:33,930
conversions<font color="#E5E5E5"> but it's not a big problem</font>

608
00:35:30,270 --> 00:35:40,259
<font color="#CCCCCC">for reverse engineering</font><font color="#E5E5E5"> but this EP</font><font color="#CCCCCC"> is</font>

609
00:35:33,930 --> 00:35:44,730
they<font color="#E5E5E5"> introduced a very complex rules to</font>

610
00:35:40,260 --> 00:35:50,730
pass<font color="#E5E5E5"> structures and unions to and from</font>

611
00:35:44,730 --> 00:35:54,510
the functions<font color="#CCCCCC"> for example we have a</font>

612
00:35:50,730 --> 00:35:56,849
structure it is only<font color="#E5E5E5"> eight bytes so in</font>

613
00:35:54,510 --> 00:35:59,250
theory it can<font color="#E5E5E5"> be passed on the register</font>

614
00:35:56,849 --> 00:36:02,430
and yes that's what the compilers do

615
00:35:59,250 --> 00:36:05,220
they put<font color="#E5E5E5"> the entire structure into a</font>

616
00:36:02,430 --> 00:36:08,310
register but sometimes they do even

617
00:36:05,220 --> 00:36:11,250
nasty things the past<font color="#E5E5E5"> part of a</font>

618
00:36:08,310 --> 00:36:16,910
<font color="#E5E5E5">structure on a register and the rest on</font>

619
00:36:11,250 --> 00:36:20,099
the stack let me show you an<font color="#CCCCCC"> example</font>

620
00:36:16,910 --> 00:36:24,750
here<font color="#E5E5E5"> we have a structure it's only eight</font>

621
00:36:20,099 --> 00:36:26,880
bytes<font color="#E5E5E5"> has two parts division</font><font color="#CCCCCC"> the</font>

622
00:36:24,750 --> 00:36:28,980
division result<font color="#CCCCCC"> it's a quotient and</font>

623
00:36:26,880 --> 00:36:32,369
remainder<font color="#CCCCCC"> and we have the division</font>

624
00:36:28,980 --> 00:36:35,280
<font color="#E5E5E5">function it accepts two values and</font>

625
00:36:32,369 --> 00:36:41,359
divides them and then returns the<font color="#E5E5E5"> result</font>

626
00:36:35,280 --> 00:36:44,430
in in one register this<font color="#E5E5E5"> is a nasty thing</font>

627
00:36:41,359 --> 00:36:47,490
if you look at the assembly code<font color="#E5E5E5"> you</font>

628
00:36:44,430 --> 00:36:50,940
will see that<font color="#CCCCCC"> after</font><font color="#E5E5E5"> the call call deal</font>

629
00:36:47,490 --> 00:36:58,078
<font color="#E5E5E5">we have move sign extended double</font><font color="#CCCCCC"> word</font>

630
00:36:50,940 --> 00:37:03,480
<font color="#E5E5E5">then we shift the double</font><font color="#CCCCCC"> the quad reward</font>

631
00:36:58,079 --> 00:37:06,330
in<font color="#CCCCCC"> our ax by 32 and</font><font color="#E5E5E5"> the then we extract</font>

632
00:37:03,480 --> 00:37:11,400
<font color="#E5E5E5">the low part</font>

633
00:37:06,330 --> 00:37:12,810
the second<font color="#E5E5E5"> part to represent this in a</font>

634
00:37:11,400 --> 00:37:18,590
<font color="#E5E5E5">nice</font><font color="#CCCCCC"> way</font>

635
00:37:12,810 --> 00:37:19,770
in the output<font color="#CCCCCC"> we need to have scattered</font>

636
00:37:18,590 --> 00:37:22,460
operands

637
00:37:19,770 --> 00:37:26,400
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> control operand is no parent that</font>

638
00:37:22,460 --> 00:37:28,830
can have its<font color="#E5E5E5"> parts scattered</font><font color="#CCCCCC"> over</font>

639
00:37:26,400 --> 00:37:34,830
different<font color="#E5E5E5"> places various</font><font color="#CCCCCC"> places it can</font>

640
00:37:28,830 --> 00:37:38,520
<font color="#E5E5E5">be registers or stack so you see that is</font>

641
00:37:34,830 --> 00:37:40,560
output<font color="#CCCCCC"> is quite nice we have the result</font>

642
00:37:38,520 --> 00:37:44,520
of the<font color="#CCCCCC"> call is put into a</font><font color="#E5E5E5"> variable</font>

643
00:37:40,560 --> 00:37:49,170
called<font color="#E5E5E5"> v2 and the parent is v2 has is a</font>

644
00:37:44,520 --> 00:37:56,250
structure and it has<font color="#E5E5E5"> two fields the</font>

645
00:37:49,170 --> 00:37:58,500
quotient and remainder that<font color="#CCCCCC"> were</font><font color="#E5E5E5"> the</font>

646
00:37:56,250 --> 00:38:01,770
scattered operands<font color="#CCCCCC"> turned out to</font><font color="#E5E5E5"> be</font>

647
00:37:58,500 --> 00:38:05,310
quite a complex things and we do have

648
00:38:01,770 --> 00:38:07,740
support<font color="#E5E5E5"> for them but not everything can</font>

649
00:38:05,310 --> 00:38:15,060
be handled nicely we are working on it

650
00:38:07,740 --> 00:38:18,770
<font color="#E5E5E5">but</font><font color="#CCCCCC"> we are</font><font color="#E5E5E5"> not there yet</font><font color="#CCCCCC"> okay enough of</font>

651
00:38:15,060 --> 00:38:21,990
<font color="#CCCCCC">these minor details let's talk about</font>

652
00:38:18,770 --> 00:38:24,840
what we can do with the microcode and

653
00:38:21,990 --> 00:38:28,319
how the<font color="#E5E5E5"> ducati compiler uses the</font>

654
00:38:24,840 --> 00:38:30,000
microcode first of all the microcode<font color="#E5E5E5"> as</font>

655
00:38:28,320 --> 00:38:33,960
you see that<font color="#CCCCCC"> they generated microcode</font>

656
00:38:30,000 --> 00:38:37,770
was very verbose<font color="#CCCCCC"> and</font><font color="#E5E5E5"> then we perform the</font>

657
00:38:33,960 --> 00:38:39,990
initial pre optimization step<font color="#E5E5E5"> that use a</font>

658
00:38:37,770 --> 00:38:42,630
very simple constant<font color="#E5E5E5"> register a</font>

659
00:38:39,990 --> 00:38:48,620
propagation<font color="#E5E5E5"> algorithm</font><font color="#CCCCCC"> it's a very fast</font>

660
00:38:42,630 --> 00:38:51,300
and gets rid<font color="#E5E5E5"> of most temporary registers</font>

661
00:38:48,620 --> 00:38:57,750
reduces the microcode by<font color="#CCCCCC"> two because it</font>

662
00:38:51,300 --> 00:39:00,390
also removes unused<font color="#E5E5E5"> instructions and</font>

663
00:38:57,750 --> 00:39:04,170
then later if you use another<font color="#CCCCCC"> algorithm</font>

664
00:39:00,390 --> 00:39:07,620
that will<font color="#E5E5E5"> propagate</font>

665
00:39:04,170 --> 00:39:10,350
partial registers for example we can

666
00:39:07,620 --> 00:39:13,859
propagate<font color="#CCCCCC"> EAX into an expression that</font>

667
00:39:10,350 --> 00:39:16,710
<font color="#E5E5E5">used only part of it it can move one</font>

668
00:39:13,860 --> 00:39:17,519
instruction<font color="#CCCCCC"> to inside another it can</font>

669
00:39:16,710 --> 00:39:22,439
work with

670
00:39:17,519 --> 00:39:24,508
all kinds of operands first we do all

671
00:39:22,439 --> 00:39:28,469
these optimizations on the basic block

672
00:39:24,509 --> 00:39:31,469
level<font color="#E5E5E5"> and then we build the control flow</font>

673
00:39:28,469 --> 00:39:37,319
<font color="#CCCCCC">graph and will</font><font color="#E5E5E5"> to perform the</font><font color="#CCCCCC"> dataflow</font>

674
00:39:31,469 --> 00:39:40,859
analysis for that<font color="#CCCCCC"> the result of the of</font>

675
00:39:37,319 --> 00:39:47,999
the dataflow analysis is represented as

676
00:39:40,859 --> 00:39:51,149
<font color="#CCCCCC">use and define</font><font color="#E5E5E5"> chains so these chains</font>

677
00:39:47,999 --> 00:39:54,799
they<font color="#CCCCCC"> used F</font><font color="#E5E5E5"> information can later be</font>

678
00:39:51,149 --> 00:39:57,509
<font color="#CCCCCC">used to to do many things with the</font>

679
00:39:54,799 --> 00:39:59,699
microcode we can delete<font color="#E5E5E5"> the dead code</font>

680
00:39:57,509 --> 00:40:02,699
for<font color="#CCCCCC"> example</font><font color="#E5E5E5"> it's at the</font><font color="#CCCCCC"> beginning of</font><font color="#E5E5E5"> a</font>

681
00:39:59,699 --> 00:40:06,479
function<font color="#E5E5E5"> we put some value into</font><font color="#CCCCCC"> a</font>

682
00:40:02,699 --> 00:40:09,209
register<font color="#E5E5E5"> but this value is never used in</font>

683
00:40:06,479 --> 00:40:14,279
<font color="#CCCCCC">the function then</font><font color="#E5E5E5"> we can delete</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> from</font>

684
00:40:09,209 --> 00:40:17,399
<font color="#E5E5E5">the output we can propagate operands and</font>

685
00:40:14,279 --> 00:40:21,439
we can generate<font color="#CCCCCC"> a substance</font><font color="#E5E5E5"> let me show</font>

686
00:40:17,399 --> 00:40:25,199
you is assertions<font color="#CCCCCC"> imagine the pics</font><font color="#E5E5E5"> have</font>

687
00:40:21,439 --> 00:40:27,058
conditional jump jump<font color="#CCCCCC"> non zero</font><font color="#E5E5E5"> if he X</font>

688
00:40:25,199 --> 00:40:30,869
is not<font color="#CCCCCC"> zero then we jump to the</font><font color="#E5E5E5"> block</font>

689
00:40:27,059 --> 00:40:34,130
number<font color="#CCCCCC"> five otherwise we jump we don't</font>

690
00:40:30,869 --> 00:40:36,389
jump<font color="#CCCCCC"> we just continue to</font><font color="#E5E5E5"> the next</font><font color="#CCCCCC"> block</font>

691
00:40:34,130 --> 00:40:38,789
<font color="#E5E5E5">graphically it can be represented</font><font color="#CCCCCC"> like</font>

692
00:40:36,389 --> 00:40:44,119
<font color="#E5E5E5">this</font><font color="#CCCCCC"> we have</font><font color="#E5E5E5"> true two arrows true and</font>

693
00:40:38,789 --> 00:40:49,889
false and if we<font color="#E5E5E5"> don't jump then we can</font>

694
00:40:44,119 --> 00:40:52,709
deduce<font color="#CCCCCC"> that AIX is zero</font><font color="#E5E5E5"> since we did not</font>

695
00:40:49,889 --> 00:40:57,839
<font color="#E5E5E5">jump it is zero so what we do we</font>

696
00:40:52,709 --> 00:40:58,408
generate an artificial instruction that

697
00:40:57,839 --> 00:41:01,619
moves

698
00:40:58,409 --> 00:41:03,359
<font color="#CCCCCC">yeah x0 into X that instruction was not</font>

699
00:41:01,619 --> 00:41:07,139
present<font color="#E5E5E5"> in the native code</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> the</font>

700
00:41:03,359 --> 00:41:11,098
<font color="#E5E5E5">initial code that</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> in the input but</font>

701
00:41:07,139 --> 00:41:14,279
since we<font color="#CCCCCC"> explicitly put it there then it</font>

702
00:41:11,099 --> 00:41:17,880
can be propagated<font color="#CCCCCC"> and ei X will be</font>

703
00:41:14,279 --> 00:41:21,359
replaced<font color="#CCCCCC"> by</font><font color="#E5E5E5"> zeros in this block and</font>

704
00:41:17,880 --> 00:41:24,409
maybe in other blocks as<font color="#CCCCCC"> well so this is</font>

705
00:41:21,359 --> 00:41:31,038
a nice trick to<font color="#E5E5E5"> be able to propagate</font>

706
00:41:24,409 --> 00:41:31,039
<font color="#CCCCCC">constant values</font><font color="#E5E5E5"> over basic blocks</font>

707
00:41:31,500 --> 00:41:39,690
we have really<font color="#CCCCCC"> literally hundreds of</font>

708
00:41:35,260 --> 00:41:44,380
very small and<font color="#CCCCCC"> same optimisation rules</font>

709
00:41:39,690 --> 00:41:47,800
for example<font color="#E5E5E5"> if you have X minus y plus y</font>

710
00:41:44,380 --> 00:41:49,390
it is<font color="#CCCCCC"> the same thing</font><font color="#E5E5E5"> at X please note</font>

711
00:41:47,800 --> 00:41:51,910
<font color="#CCCCCC">that this does not depend on the</font>

712
00:41:49,390 --> 00:41:55,299
<font color="#E5E5E5">compiler we don't care if it's a</font><font color="#CCCCCC"> new</font>

713
00:41:51,910 --> 00:41:58,750
compiler or Microsoft Visual Studio<font color="#E5E5E5"> or</font>

714
00:41:55,300 --> 00:42:03,330
anything<font color="#E5E5E5"> else</font><font color="#CCCCCC"> or LLVM</font><font color="#E5E5E5"> all these rules</font>

715
00:41:58,750 --> 00:42:06,550
<font color="#CCCCCC">they work</font><font color="#E5E5E5"> regardless of the compiler and</font>

716
00:42:03,330 --> 00:42:09,150
I'm happy<font color="#CCCCCC"> to tell</font><font color="#E5E5E5"> that most although</font>

717
00:42:06,550 --> 00:42:11,890
let's say you get only<font color="#E5E5E5"> all</font>

718
00:42:09,150 --> 00:42:16,180
transformation rules that we apply<font color="#E5E5E5"> to</font>

719
00:42:11,890 --> 00:42:20,529
<font color="#E5E5E5">the microcode rules like</font><font color="#CCCCCC"> that they are</font>

720
00:42:16,180 --> 00:42:24,669
<font color="#E5E5E5">sound</font><font color="#CCCCCC"> they are</font><font color="#E5E5E5"> simple and therefore we</font>

721
00:42:20,530 --> 00:42:27,670
are quite<font color="#CCCCCC"> sure that</font><font color="#E5E5E5"> the output will</font><font color="#CCCCCC"> be</font>

722
00:42:24,670 --> 00:42:30,400
<font color="#E5E5E5">correct of course there are some places</font>

723
00:42:27,670 --> 00:42:32,230
<font color="#E5E5E5">where the</font><font color="#CCCCCC"> compiler has to guess for</font>

724
00:42:30,400 --> 00:42:34,240
example the calling conventions<font color="#E5E5E5"> the call</font>

725
00:42:32,230 --> 00:42:36,880
instruction<font color="#E5E5E5"> and there if you guess</font><font color="#CCCCCC"> it</font>

726
00:42:34,240 --> 00:42:41,080
wrongly<font color="#E5E5E5"> then the output will</font><font color="#CCCCCC"> be wrong</font>

727
00:42:36,880 --> 00:42:47,350
<font color="#E5E5E5">but this</font><font color="#CCCCCC"> is an unsolvable problem and we</font>

728
00:42:41,080 --> 00:42:50,920
just provide ways of for the user to<font color="#E5E5E5"> fix</font>

729
00:42:47,350 --> 00:42:53,319
these things<font color="#E5E5E5"> that the compiler does not</font>

730
00:42:50,920 --> 00:42:56,940
need to guess<font color="#E5E5E5"> but just</font><font color="#CCCCCC"> uses the</font>

731
00:42:53,320 --> 00:42:56,940
information<font color="#E5E5E5"> provided by the user</font>

732
00:42:57,760 --> 00:43:02,020
we have also<font color="#E5E5E5"> more complex rules for</font>

733
00:43:00,010 --> 00:43:05,380
<font color="#E5E5E5">example the</font><font color="#CCCCCC"> following rule</font><font color="#E5E5E5"> recognizes</font>

734
00:43:02,020 --> 00:43:14,130
<font color="#E5E5E5">64-bit test abstractions you see that it</font>

735
00:43:05,380 --> 00:43:17,470
<font color="#E5E5E5">is quite complex and</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> is what do I say</font>

736
00:43:14,130 --> 00:43:20,410
<font color="#E5E5E5">it is it looks complex the description</font>

737
00:43:17,470 --> 00:43:22,990
looks complex<font color="#E5E5E5"> and believe me the</font>

738
00:43:20,410 --> 00:43:29,250
<font color="#CCCCCC">implementation is complex</font><font color="#E5E5E5"> as well so we</font>

739
00:43:22,990 --> 00:43:32,410
implement such a rule in C++<font color="#CCCCCC"> and it is</font>

740
00:43:29,250 --> 00:43:35,290
big<font color="#E5E5E5"> but on the hunt it works very fast</font>

741
00:43:32,410 --> 00:43:37,720
<font color="#E5E5E5">because of that we have tons of rules</font>

742
00:43:35,290 --> 00:43:40,810
like<font color="#CCCCCC"> that and they work like little and</font>

743
00:43:37,720 --> 00:43:42,540
<font color="#E5E5E5">every rule doing it's a simple job a</font>

744
00:43:40,810 --> 00:43:45,509
simple job and

745
00:43:42,540 --> 00:43:48,300
and resolve<font color="#E5E5E5"> is for me it's bigger than</font>

746
00:43:45,510 --> 00:43:52,710
the sum of elements<font color="#E5E5E5"> it</font><font color="#CCCCCC"> is bigger and</font>

747
00:43:48,300 --> 00:43:57,710
<font color="#E5E5E5">it's it allows us</font><font color="#CCCCCC"> to provide</font><font color="#E5E5E5"> a very very</font>

748
00:43:52,710 --> 00:44:00,720
<font color="#E5E5E5">nice output very human readable output</font>

749
00:43:57,710 --> 00:44:04,100
on the other hand<font color="#E5E5E5"> one</font><font color="#CCCCCC"> more</font><font color="#E5E5E5"> thing</font><font color="#CCCCCC"> that</font>

750
00:44:00,720 --> 00:44:09,660
why our rules<font color="#E5E5E5"> are more complex because</font>

751
00:44:04,100 --> 00:44:13,440
take for example this rule<font color="#CCCCCC"> CNB 4343 it</font>

752
00:44:09,660 --> 00:44:15,990
tries to<font color="#E5E5E5"> combine two parts of</font>

753
00:44:13,440 --> 00:44:19,650
multiplication<font color="#E5E5E5"> and generate and</font><font color="#CCCCCC"> 8bit a</font>

754
00:44:15,990 --> 00:44:21,330
<font color="#E5E5E5">multiplication instruction there we have</font>

755
00:44:19,650 --> 00:44:25,590
two instructions multiply<font color="#E5E5E5"> or multiply</font>

756
00:44:21,330 --> 00:44:27,150
and<font color="#E5E5E5"> law and the</font><font color="#CCCCCC"> law instruction and</font>

757
00:44:25,590 --> 00:44:29,130
between the low and<font color="#E5E5E5"> multiply</font>

758
00:44:27,150 --> 00:44:32,340
instructions<font color="#E5E5E5"> there can be many other</font>

759
00:44:29,130 --> 00:44:36,960
instructions the only requirement is

760
00:44:32,340 --> 00:44:41,280
<font color="#CCCCCC">that they don't spoil or modify x</font><font color="#E5E5E5"> and y</font>

761
00:44:36,960 --> 00:44:45,810
the operands that that<font color="#E5E5E5"> I used in our</font>

762
00:44:41,280 --> 00:44:48,510
<font color="#E5E5E5">pattern how do we do that we don't know</font>

763
00:44:45,810 --> 00:44:52,680
Eve check what is<font color="#E5E5E5"> the next instruction</font>

764
00:44:48,510 --> 00:44:57,960
<font color="#CCCCCC">after mall</font><font color="#E5E5E5"> instead we use again we rely</font>

765
00:44:52,680 --> 00:45:02,399
on data dependencies we go and try to

766
00:44:57,960 --> 00:45:07,170
find<font color="#E5E5E5"> where the</font><font color="#CCCCCC"> law instruction is we</font>

767
00:45:02,400 --> 00:45:10,320
have also interblock rules they work on

768
00:45:07,170 --> 00:45:14,340
<font color="#CCCCCC">multiple blocks at the you see</font><font color="#E5E5E5"> that if</font>

769
00:45:10,320 --> 00:45:16,950
<font color="#E5E5E5">you have three comparisons with some</font>

770
00:45:14,340 --> 00:45:19,770
relationship between<font color="#E5E5E5"> them it can be</font>

771
00:45:16,950 --> 00:45:25,580
<font color="#E5E5E5">collapsed into</font><font color="#CCCCCC"> one simple comparison</font>

772
00:45:19,770 --> 00:45:32,580
<font color="#CCCCCC">that jump if it's lower between</font><font color="#E5E5E5"> x and y</font>

773
00:45:25,580 --> 00:45:35,400
another rule<font color="#E5E5E5"> another</font><font color="#CCCCCC"> example</font><font color="#E5E5E5"> division</font>

774
00:45:32,580 --> 00:45:39,870
<font color="#E5E5E5">pop by power sign division by power of 2</font>

775
00:45:35,400 --> 00:45:42,960
we divide<font color="#E5E5E5"> instead of division we instead</font>

776
00:45:39,870 --> 00:45:47,370
<font color="#E5E5E5">of</font><font color="#CCCCCC"> 3 blocks we</font><font color="#E5E5E5"> just make it</font><font color="#CCCCCC"> just</font><font color="#E5E5E5"> one</font>

777
00:45:42,960 --> 00:45:48,870
block<font color="#CCCCCC"> Row one instruction now all these</font>

778
00:45:47,370 --> 00:45:49,520
things I explained to<font color="#E5E5E5"> you about</font><font color="#CCCCCC"> this</font>

779
00:45:48,870 --> 00:45:55,170
rules

780
00:45:49,520 --> 00:45:57,850
<font color="#E5E5E5">microcode operands and so on what</font><font color="#CCCCCC"> is the</font>

781
00:45:55,170 --> 00:46:00,130
interesting thing for<font color="#E5E5E5"> you here the</font>

782
00:45:57,850 --> 00:46:03,100
<font color="#CCCCCC">interesting</font><font color="#E5E5E5"> thing is that you can use</font>

783
00:46:00,130 --> 00:46:06,010
all this<font color="#CCCCCC"> micro code</font><font color="#E5E5E5"> and the</font>

784
00:46:03,100 --> 00:46:09,910
transformation rules<font color="#E5E5E5"> because you can</font>

785
00:46:06,010 --> 00:46:13,440
implement<font color="#E5E5E5"> plugins that would examine</font>

786
00:46:09,910 --> 00:46:18,819
microcode find interesting<font color="#E5E5E5"> scenes and</font>

787
00:46:13,440 --> 00:46:23,140
you<font color="#CCCCCC"> can even you can even</font><font color="#E5E5E5"> improve things</font>

788
00:46:18,820 --> 00:46:25,540
by adding your<font color="#CCCCCC"> own rules</font><font color="#E5E5E5"> by hooking your</font>

789
00:46:23,140 --> 00:46:28,990
rules<font color="#E5E5E5"> to the optimization routine well</font>

790
00:46:25,540 --> 00:46:33,850
<font color="#E5E5E5">this</font><font color="#CCCCCC"> DK has some samples</font><font color="#E5E5E5"> explaining how</font>

791
00:46:28,990 --> 00:46:36,520
<font color="#CCCCCC">to do that for example we have phenom</font>

792
00:46:33,850 --> 00:46:39,580
<font color="#E5E5E5">the compiler</font><font color="#CCCCCC"> has a rule that</font><font color="#E5E5E5"> converts in</font>

793
00:46:36,520 --> 00:46:42,190
the indirect jump into<font color="#E5E5E5"> return but for</font>

794
00:46:39,580 --> 00:46:45,340
that we need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> prove that</font><font color="#CCCCCC"> LR is the</font>

795
00:46:42,190 --> 00:46:50,050
same as the<font color="#CCCCCC"> lr at the</font><font color="#E5E5E5"> beginning of the</font>

796
00:46:45,340 --> 00:46:53,740
entry point<font color="#CCCCCC"> we can do that by using the</font>

797
00:46:50,050 --> 00:46:55,330
<font color="#CCCCCC">dataflow analysis okay</font><font color="#E5E5E5"> therefore</font><font color="#CCCCCC"> I have</font>

798
00:46:53,740 --> 00:47:00,729
<font color="#E5E5E5">to tell you just a bit</font><font color="#CCCCCC"> about the</font>

799
00:46:55,330 --> 00:47:03,460
dataflow analysis<font color="#E5E5E5"> you notice that</font><font color="#CCCCCC"> to the</font>

800
00:47:00,730 --> 00:47:10,480
right all<font color="#CCCCCC"> the instructions we have U and</font>

801
00:47:03,460 --> 00:47:13,000
D lists you means<font color="#E5E5E5"> list of locations used</font>

802
00:47:10,480 --> 00:47:15,090
by the instructions and D means defined

803
00:47:13,000 --> 00:47:18,880
by the instruction and this list

804
00:47:15,090 --> 00:47:24,970
maintained<font color="#E5E5E5"> for you by the decompiler</font>

805
00:47:18,880 --> 00:47:28,810
engine and you can use them<font color="#E5E5E5"> to</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> under</font>

806
00:47:24,970 --> 00:47:31,359
in your analysis first<font color="#E5E5E5"> of all we have</font>

807
00:47:28,810 --> 00:47:35,170
this list for each instruction for<font color="#CCCCCC"> each</font>

808
00:47:31,360 --> 00:47:38,650
block<font color="#E5E5E5"> and for each block and more than</font>

809
00:47:35,170 --> 00:47:43,180
that<font color="#E5E5E5"> we</font><font color="#CCCCCC"> have even Mei and my mustn´t may</font>

810
00:47:38,650 --> 00:47:50,050
access lists for each instruction or

811
00:47:43,180 --> 00:47:53,080
block and these lists are<font color="#E5E5E5"> very very</font>

812
00:47:50,050 --> 00:47:55,780
<font color="#CCCCCC">useful</font><font color="#E5E5E5"> because they can they help us</font><font color="#CCCCCC"> to</font>

813
00:47:53,080 --> 00:47:58,990
answer<font color="#E5E5E5"> questions like is a</font><font color="#CCCCCC"> defined value</font>

814
00:47:55,780 --> 00:48:01,930
used anywhere<font color="#CCCCCC"> if</font><font color="#E5E5E5"> they are if it's used</font>

815
00:47:58,990 --> 00:48:08,160
where exactly<font color="#E5E5E5"> and so on and so on and so</font>

816
00:48:01,930 --> 00:48:11,009
on<font color="#CCCCCC"> therefore you if you use a</font><font color="#E5E5E5"> micro</font>

817
00:48:08,160 --> 00:48:17,578
you can<font color="#E5E5E5"> really answer questions like</font>

818
00:48:11,010 --> 00:48:18,990
<font color="#E5E5E5">that and therefore</font><font color="#CCCCCC"> analyze things well</font><font color="#E5E5E5"> I</font>

819
00:48:17,579 --> 00:48:25,380
think that I will skip these<font color="#E5E5E5"> slides</font>

820
00:48:18,990 --> 00:48:27,450
because<font color="#E5E5E5"> I lacked I'm sorry just a few</font>

821
00:48:25,380 --> 00:48:32,130
words about the microcode the testing

822
00:48:27,450 --> 00:48:37,379
<font color="#E5E5E5">and</font><font color="#CCCCCC"> hone we really try the microcode to</font>

823
00:48:32,130 --> 00:48:40,289
be reliable and powerful enough<font color="#E5E5E5"> to</font>

824
00:48:37,380 --> 00:48:44,520
<font color="#E5E5E5">express real-world problems therefore we</font>

825
00:48:40,289 --> 00:48:47,430
test the microcode<font color="#E5E5E5"> extensively</font><font color="#CCCCCC"> we have</font><font color="#E5E5E5"> a</font>

826
00:48:44,520 --> 00:48:50,400
small farm of<font color="#E5E5E5"> tester computers running</font>

827
00:48:47,430 --> 00:48:53,058
all the time<font color="#E5E5E5"> and checking if you have</font>

828
00:48:50,400 --> 00:48:55,890
any bugs<font color="#CCCCCC"> by the way</font><font color="#E5E5E5"> we have very little</font>

829
00:48:53,059 --> 00:48:57,869
reports about microcode<font color="#E5E5E5"> about the</font><font color="#CCCCCC"> de</font>

830
00:48:55,890 --> 00:49:00,270
<font color="#E5E5E5">compiler in general because</font><font color="#CCCCCC"> i see</font><font color="#E5E5E5"> that</font>

831
00:48:57,869 --> 00:49:04,500
it's thanks bigger to our testing

832
00:49:00,270 --> 00:49:06,569
techniques<font color="#E5E5E5"> but anyway if you find</font>

833
00:49:04,500 --> 00:49:09,119
anything<font color="#CCCCCC"> about the fishing about the</font>

834
00:49:06,569 --> 00:49:11,970
microcode<font color="#E5E5E5"> just send us a</font><font color="#CCCCCC"> message</font>

835
00:49:09,119 --> 00:49:14,400
we are happy to<font color="#E5E5E5"> fix things we really</font>

836
00:49:11,970 --> 00:49:18,270
hate the bugs<font color="#E5E5E5"> and we try</font><font color="#CCCCCC"> to get rid of</font>

837
00:49:14,400 --> 00:49:20,490
<font color="#CCCCCC">everything anyway the microcode</font><font color="#E5E5E5"> is</font>

838
00:49:18,270 --> 00:49:23,309
available the API is available<font color="#CCCCCC"> it's only</font>

839
00:49:20,490 --> 00:49:27,328
<font color="#E5E5E5">C++ for the moment but the Python will</font>

840
00:49:23,309 --> 00:49:28,740
come very<font color="#E5E5E5"> soon I think</font><font color="#CCCCCC"> that it's not</font>

841
00:49:27,329 --> 00:49:31,319
this<font color="#CCCCCC"> year's the next</font><font color="#E5E5E5"> year</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> will</font><font color="#CCCCCC"> have</font>

842
00:49:28,740 --> 00:49:33,598
the Python API<font color="#E5E5E5"> and I hope that</font><font color="#CCCCCC"> will show</font>

843
00:49:31,319 --> 00:49:35,940
<font color="#E5E5E5">you some interesting things</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> you can</font>

844
00:49:33,599 --> 00:49:39,420
<font color="#CCCCCC">do with the microcode API we will block</font>

845
00:49:35,940 --> 00:49:42,180
about it anyway if<font color="#E5E5E5"> you have any</font><font color="#CCCCCC"> remarks</font>

846
00:49:39,420 --> 00:49:47,039
so anything feedback<font color="#E5E5E5"> about</font><font color="#CCCCCC"> it just</font><font color="#E5E5E5"> send</font>

847
00:49:42,180 --> 00:49:51,240
us a message<font color="#E5E5E5"> or I think</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> I ran out</font>

848
00:49:47,039 --> 00:49:54,240
of<font color="#E5E5E5"> time</font><font color="#CCCCCC"> so before the questions will be</font>

849
00:49:51,240 --> 00:49:55,370
in<font color="#E5E5E5"> another room right</font><font color="#CCCCCC"> ok thank you</font><font color="#E5E5E5"> for</font>

850
00:49:54,240 --> 00:50:03,750
<font color="#CCCCCC">your attention</font>

851
00:49:55,370 --> 00:50:03,750
[Applause]

