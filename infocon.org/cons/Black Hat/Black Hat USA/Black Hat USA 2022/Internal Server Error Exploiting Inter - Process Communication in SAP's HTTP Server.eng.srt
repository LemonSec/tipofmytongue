1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:09,080 --> 00:00:12,179
I'm my name is Arden einar I'm a

3
00:00:12,179 --> 00:00:13,500
security researcher at the analysis

4
00:00:13,500 --> 00:00:15,780
research labs and Analysis is a company

5
00:00:15,780 --> 00:00:19,440
focused on Enterprise software security

6
00:00:19,440 --> 00:00:21,720
and among the different is enterprise

7
00:00:21,720 --> 00:00:24,240
software developers sap is probably the

8
00:00:24,240 --> 00:00:27,119
most popular one with over 400 000

9
00:00:27,119 --> 00:00:29,220
customers and that is 400 000

10
00:00:29,220 --> 00:00:31,800
installations and including ninety

11
00:00:31,800 --> 00:00:36,000
percent of Fortune 500s and sap develops

12
00:00:36,000 --> 00:00:37,980
enterprise software that is used by

13
00:00:37,980 --> 00:00:39,480
different companies to manage their

14
00:00:39,480 --> 00:00:41,280
business processes and their most

15
00:00:41,280 --> 00:00:43,680
critical assets that includes their

16
00:00:43,680 --> 00:00:46,920
operations their financials their human

17
00:00:46,920 --> 00:00:48,000
capital

18
00:00:48,000 --> 00:00:50,399
the customer relationships Supply chains

19
00:00:50,399 --> 00:00:53,520
many others and to do so they they

20
00:00:53,520 --> 00:00:55,199
provide different modules that can be

21
00:00:55,199 --> 00:00:58,020
included in the in the sap system and

22
00:00:58,020 --> 00:00:59,760
they are all based on most of them are

23
00:00:59,760 --> 00:01:02,160
all based on web services that are

24
00:01:02,160 --> 00:01:04,920
accessible through HTTP and this is true

25
00:01:04,920 --> 00:01:07,920
for both Java above and even s4hana

26
00:01:07,920 --> 00:01:09,780
which is their Flagship product

27
00:01:09,780 --> 00:01:12,900
and to expose these Services they use a

28
00:01:12,900 --> 00:01:15,299
proprietary HTTP server called internet

29
00:01:15,299 --> 00:01:17,159
communication manager

30
00:01:17,159 --> 00:01:18,720
now the internet communication manager

31
00:01:18,720 --> 00:01:21,360
or ICM is used to handle all the

32
00:01:21,360 --> 00:01:24,180
communication that is a between the sap

33
00:01:24,180 --> 00:01:26,220
system and the outside world like

34
00:01:26,220 --> 00:01:28,799
clients for example customers or

35
00:01:28,799 --> 00:01:31,560
employees but also with other SAP

36
00:01:31,560 --> 00:01:34,140
systems and with our system that can

37
00:01:34,140 --> 00:01:36,320
consume these services

38
00:01:36,320 --> 00:01:39,540
and to communicate with other with our

39
00:01:39,540 --> 00:01:41,340
clients there are different protocols

40
00:01:41,340 --> 00:01:44,159
that the ICM can can handle like before

41
00:01:44,159 --> 00:01:47,759
which is a proprietary protocol like RMI

42
00:01:47,759 --> 00:01:51,540
from java IOP SMTP and the most

43
00:01:51,540 --> 00:01:53,159
important one and the main purpose of

44
00:01:53,159 --> 00:01:56,700
the ICM is to handle HTTP and https

45
00:01:56,700 --> 00:01:59,040
and what's really interesting about the

46
00:01:59,040 --> 00:02:01,799
ICM is that it's present in all sap

47
00:02:01,799 --> 00:02:04,619
system by default so all installations

48
00:02:04,619 --> 00:02:06,540
all sap installations will have this

49
00:02:06,540 --> 00:02:09,179
this component and it will be exposed by

50
00:02:09,179 --> 00:02:11,879
default so this is part of the what is

51
00:02:11,879 --> 00:02:15,480
called sap kernel and so any system like

52
00:02:15,480 --> 00:02:17,940
Java a web dispatcher which is a load

53
00:02:17,940 --> 00:02:20,640
balancer is for Hana the cloud all are

54
00:02:20,640 --> 00:02:23,300
going to use this exact same probability

55
00:02:23,300 --> 00:02:26,040
hdb server

56
00:02:26,040 --> 00:02:28,020
of course we don't have the source code

57
00:02:28,020 --> 00:02:31,319
of this HTTP server so we have to

58
00:02:31,319 --> 00:02:32,700
reverse engineering I had to and

59
00:02:32,700 --> 00:02:36,060
understand how this system worked and

60
00:02:36,060 --> 00:02:37,500
this is probably the most important part

61
00:02:37,500 --> 00:02:39,300
of our research to understand how it

62
00:02:39,300 --> 00:02:40,860
works because then vulnerabilities are

63
00:02:40,860 --> 00:02:43,200
going to come by itself

64
00:02:43,200 --> 00:02:45,599
and so sap does not provide a lot of

65
00:02:45,599 --> 00:02:47,400
information they provide this small

66
00:02:47,400 --> 00:02:49,739
diagram that we can see in the slide but

67
00:02:49,739 --> 00:02:52,200
we are going to abstract this to make a

68
00:02:52,200 --> 00:02:55,379
to understand how this actually works

69
00:02:55,379 --> 00:02:57,540
so to abstract this and I'm going to

70
00:02:57,540 --> 00:02:59,160
abstract a lot of the internals of the

71
00:02:59,160 --> 00:03:01,140
architecture so that I can I can explain

72
00:03:01,140 --> 00:03:04,500
this in 40 minutes and I'm going to see

73
00:03:04,500 --> 00:03:06,780
the ICM as just a system that will

74
00:03:06,780 --> 00:03:09,780
receive clients a requests and responses

75
00:03:09,780 --> 00:03:12,480
and first when a client starts a TCP

76
00:03:12,480 --> 00:03:15,060
connection the ICM will create our will

77
00:03:15,060 --> 00:03:17,159
start a worker thread which is just a

78
00:03:17,159 --> 00:03:18,900
simple thread that will be assigned to

79
00:03:18,900 --> 00:03:20,580
this TCP connection to handle all the

80
00:03:20,580 --> 00:03:23,459
requests and responses to do so it will

81
00:03:23,459 --> 00:03:25,739
use an HTTP parser and also some

82
00:03:25,739 --> 00:03:28,019
internal handlers to actually try to

83
00:03:28,019 --> 00:03:29,819
resolve the request and generate the

84
00:03:29,819 --> 00:03:32,040
response and if it's not possible to do

85
00:03:32,040 --> 00:03:34,440
it inside the ICM then a different

86
00:03:34,440 --> 00:03:36,659
process which is a job organ or an above

87
00:03:36,659 --> 00:03:38,580
process will be used because in there is

88
00:03:38,580 --> 00:03:40,799
the business logic of the of the sap

89
00:03:40,799 --> 00:03:41,879
system

90
00:03:41,879 --> 00:03:43,920
so when our request arrives from the

91
00:03:43,920 --> 00:03:44,940
client

92
00:03:44,940 --> 00:03:46,920
the worker thread will try to parse it

93
00:03:46,920 --> 00:03:49,080
will try to resolve it and if it's not

94
00:03:49,080 --> 00:03:51,120
possible which is in most cases that it

95
00:03:51,120 --> 00:03:53,519
will happen that way it will send the

96
00:03:53,519 --> 00:03:55,560
the request to the Java arrival process

97
00:03:55,560 --> 00:03:58,140
through what is called a memory pipe I'm

98
00:03:58,140 --> 00:03:59,640
going to explain why submarine piping a

99
00:03:59,640 --> 00:04:02,700
minute then they work a process will

100
00:04:02,700 --> 00:04:04,799
resolve the request generate a response

101
00:04:04,799 --> 00:04:06,959
send it back to the ICM and the ICM will

102
00:04:06,959 --> 00:04:09,120
send it to the client

103
00:04:09,120 --> 00:04:12,299
so what are memory pipes well MPI is

104
00:04:12,299 --> 00:04:14,819
just how they call memory pipes it's a

105
00:04:14,819 --> 00:04:16,858
framework that is used to support the

106
00:04:16,858 --> 00:04:20,279
exchange of data between the ICM and the

107
00:04:20,279 --> 00:04:22,380
Java River process which I'm going to

108
00:04:22,380 --> 00:04:25,020
call worker process and to do so and to

109
00:04:25,020 --> 00:04:27,240
do it efficiently induce the shared

110
00:04:27,240 --> 00:04:29,759
memory to send MPI pointers that are

111
00:04:29,759 --> 00:04:32,460
just pointers to the shared memory even

112
00:04:32,460 --> 00:04:33,840
though it's called memory pipes it's

113
00:04:33,840 --> 00:04:36,840
using shared memory and when these

114
00:04:36,840 --> 00:04:39,180
memory pipes are sent or that when these

115
00:04:39,180 --> 00:04:41,460
MPI pointers are sent between the worker

116
00:04:41,460 --> 00:04:43,080
Pros we worker thread and the worker

117
00:04:43,080 --> 00:04:45,720
process they are going to be sending a

118
00:04:45,720 --> 00:04:47,820
reference to an API buffer which is just

119
00:04:47,820 --> 00:04:49,860
a buffer inside the shared memory that

120
00:04:49,860 --> 00:04:52,500
is a fixed site buffer of 65 kilobytes

121
00:04:52,500 --> 00:04:55,020
and they will be reserved and free both

122
00:04:55,020 --> 00:04:56,699
by the worker thread and by the worker

123
00:04:56,699 --> 00:05:00,600
process using an API Handler

124
00:05:00,600 --> 00:05:02,100
so let's see an example of how this

125
00:05:02,100 --> 00:05:02,940
works

126
00:05:02,940 --> 00:05:05,460
first a request will arrive to the

127
00:05:05,460 --> 00:05:07,259
inputable Handler of the worker thread

128
00:05:07,259 --> 00:05:09,900
which is just a TCP socket with an

129
00:05:09,900 --> 00:05:11,639
internal buffer for every day that

130
00:05:11,639 --> 00:05:14,040
arrives from the TCP connection and when

131
00:05:14,040 --> 00:05:16,440
the icms or the worker thread in the ICM

132
00:05:16,440 --> 00:05:18,900
is ready to handle the request

133
00:05:18,900 --> 00:05:21,960
it will read from this inputable Handler

134
00:05:21,960 --> 00:05:24,419
it will Reserve an MPI buffer in the

135
00:05:24,419 --> 00:05:26,940
shared memory using the mpa Handler

136
00:05:26,940 --> 00:05:29,220
and it will store the request there

137
00:05:29,220 --> 00:05:31,560
now it will try to resolve it it will

138
00:05:31,560 --> 00:05:33,300
pass this request it will try to resolve

139
00:05:33,300 --> 00:05:34,860
it using the internal handlers which I'm

140
00:05:34,860 --> 00:05:36,800
going to explain also later

141
00:05:36,800 --> 00:05:39,419
and if it's not possible to resolve

142
00:05:39,419 --> 00:05:41,400
their request inside the ICM it will

143
00:05:41,400 --> 00:05:42,780
forward the request to the worker

144
00:05:42,780 --> 00:05:44,940
process and this will be done by sending

145
00:05:44,940 --> 00:05:46,740
the mpia pointer

146
00:05:46,740 --> 00:05:49,020
now the Java River process will have a

147
00:05:49,020 --> 00:05:51,300
reference to this position of the shared

148
00:05:51,300 --> 00:05:53,160
memory and it will generate a response

149
00:05:53,160 --> 00:05:55,680
for this request which again will be

150
00:05:55,680 --> 00:05:58,320
placed in the shared memory by reserving

151
00:05:58,320 --> 00:06:00,180
an MPI buffer

152
00:06:00,180 --> 00:06:01,919
and the reference will be sent to the

153
00:06:01,919 --> 00:06:03,419
worker thread

154
00:06:03,419 --> 00:06:05,220
the worker thread will be able now to

155
00:06:05,220 --> 00:06:07,199
send this re this response back to the

156
00:06:07,199 --> 00:06:08,820
inputable hanger which will forward it

157
00:06:08,820 --> 00:06:10,680
to the client

158
00:06:10,680 --> 00:06:13,320
finally the MPI buffers will be freed

159
00:06:13,320 --> 00:06:17,240
and the references will be lost

160
00:06:17,820 --> 00:06:20,340
he also said that jicm will try to

161
00:06:20,340 --> 00:06:21,960
resolve the request using internal

162
00:06:21,960 --> 00:06:23,580
handlers so what are they

163
00:06:23,580 --> 00:06:26,699
well when the request is parsed the the

164
00:06:26,699 --> 00:06:28,259
parser will actually choose which

165
00:06:28,259 --> 00:06:30,419
handles should be included in a list of

166
00:06:30,419 --> 00:06:32,460
of handles that should try to be used to

167
00:06:32,460 --> 00:06:34,259
resolve the request and this is going to

168
00:06:34,259 --> 00:06:36,780
be done by looking at the URL so

169
00:06:36,780 --> 00:06:38,759
depending on this URL some of these

170
00:06:38,759 --> 00:06:40,740
handles will be included and some don't

171
00:06:40,740 --> 00:06:42,900
and what's important is that when a

172
00:06:42,900 --> 00:06:44,699
Handler is able to resolve our request

173
00:06:44,699 --> 00:06:47,460
it will just send a response back to the

174
00:06:47,460 --> 00:06:49,199
client and all the other handles will be

175
00:06:49,199 --> 00:06:51,419
deleted from this list and there is

176
00:06:51,419 --> 00:06:54,120
request response cycle will be completed

177
00:06:54,120 --> 00:06:56,340
so first we have the cache Handler is

178
00:06:56,340 --> 00:06:57,960
the first hander that will be used and

179
00:06:57,960 --> 00:06:59,400
it's always going to be included in the

180
00:06:59,400 --> 00:07:02,639
list and the Chicago will just do what

181
00:07:02,639 --> 00:07:04,440
is expected it will look in the cache

182
00:07:04,440 --> 00:07:06,840
for a store object for the URL that is

183
00:07:06,840 --> 00:07:09,120
was requested and if it fails it will

184
00:07:09,120 --> 00:07:11,819
continue if it's able to to generate a

185
00:07:11,819 --> 00:07:13,500
response out of that it will send it to

186
00:07:13,500 --> 00:07:14,639
the client

187
00:07:14,639 --> 00:07:16,500
then we have the admin Handler and the

188
00:07:16,500 --> 00:07:18,060
authentication Handler they are both

189
00:07:18,060 --> 00:07:19,680
present by default but they are only

190
00:07:19,680 --> 00:07:21,479
going to be included in list depending

191
00:07:21,479 --> 00:07:23,699
on the pattern in the URL so for the

192
00:07:23,699 --> 00:07:26,099
admin Handler is if they if the URL

193
00:07:26,099 --> 00:07:28,620
starts with the prefix a slash sap slash

194
00:07:28,620 --> 00:07:30,840
admin and for the authentication Handler

195
00:07:30,840 --> 00:07:32,520
there are some hard-coded values in the

196
00:07:32,520 --> 00:07:34,860
ICM that will be compared to and

197
00:07:34,860 --> 00:07:36,419
depending on that it will include it or

198
00:07:36,419 --> 00:07:37,740
not

199
00:07:37,740 --> 00:07:39,720
next we have the modification the file

200
00:07:39,720 --> 00:07:41,819
axis and the redirect Handler which are

201
00:07:41,819 --> 00:07:43,259
not really interesting because they are

202
00:07:43,259 --> 00:07:44,520
not present by default they need to be

203
00:07:44,520 --> 00:07:47,520
set before the sap system starts in a

204
00:07:47,520 --> 00:07:49,620
specific configuration file

205
00:07:49,620 --> 00:07:51,599
and finally we have the Java navab

206
00:07:51,599 --> 00:07:53,400
handle with just just handles that will

207
00:07:53,400 --> 00:07:55,680
be used to forward the MPI pointers to

208
00:07:55,680 --> 00:07:57,599
the specific process

209
00:07:57,599 --> 00:07:59,400
as you can see there is a specific

210
00:07:59,400 --> 00:08:01,740
function for each of the handlers there

211
00:08:01,740 --> 00:08:03,840
are also some 100 this is these are

212
00:08:03,840 --> 00:08:05,880
functions inside the ICM and there are

213
00:08:05,880 --> 00:08:07,319
also some other handles like the low

214
00:08:07,319 --> 00:08:09,599
Handler which is not quite interesting

215
00:08:09,599 --> 00:08:11,819
because it cannot generate a response so

216
00:08:11,819 --> 00:08:14,400
we are not going to see that

217
00:08:14,400 --> 00:08:17,580
so let's see an example of how the ICM

218
00:08:17,580 --> 00:08:19,259
will resolve our request using internal

219
00:08:19,259 --> 00:08:20,819
handlers

220
00:08:20,819 --> 00:08:23,280
first the request will arrive and in

221
00:08:23,280 --> 00:08:24,479
this case it's a request it's a get

222
00:08:24,479 --> 00:08:28,500
request to slash sap slash admin so when

223
00:08:28,500 --> 00:08:30,479
the ICM is ready to to handle this

224
00:08:30,479 --> 00:08:31,560
request

225
00:08:31,560 --> 00:08:34,320
it will Reserve an API buffer store the

226
00:08:34,320 --> 00:08:35,339
request there

227
00:08:35,339 --> 00:08:38,099
and then it will use the parser to

228
00:08:38,099 --> 00:08:39,479
select the handles that should be

229
00:08:39,479 --> 00:08:41,640
included of course the cache handle will

230
00:08:41,640 --> 00:08:43,380
be included in this case the admin

231
00:08:43,380 --> 00:08:47,519
Handler because of the URL prefix

232
00:08:47,519 --> 00:08:49,680
and finally the Java rebuff Handler

233
00:08:49,680 --> 00:08:52,860
which is also always included at the end

234
00:08:52,860 --> 00:08:56,279
now it will call the Cache Handler and

235
00:08:56,279 --> 00:08:58,380
in this case let's say it fails

236
00:08:58,380 --> 00:09:00,180
so now the admin handle will be called

237
00:09:00,180 --> 00:09:02,700
and again in this case let's say it's

238
00:09:02,700 --> 00:09:04,680
able to resolve the request so it will

239
00:09:04,680 --> 00:09:06,300
generate a response it will not place it

240
00:09:06,300 --> 00:09:07,680
in the short memory because it's not

241
00:09:07,680 --> 00:09:09,180
necessary to do it

242
00:09:09,180 --> 00:09:12,720
and the other handles will be deleted

243
00:09:12,720 --> 00:09:14,399
and the response will be forwarded to

244
00:09:14,399 --> 00:09:15,779
the client

245
00:09:15,779 --> 00:09:17,940
finally again the MPI buffer will be

246
00:09:17,940 --> 00:09:20,519
freed and the request response cycle

247
00:09:20,519 --> 00:09:22,620
will be completed

248
00:09:22,620 --> 00:09:25,500
but what happens when we have a request

249
00:09:25,500 --> 00:09:28,140
that is longer than that 65 kilobytes so

250
00:09:28,140 --> 00:09:29,820
as long as it's bigger than the mpie

251
00:09:29,820 --> 00:09:33,600
size the MPI buffer size sorry so again

252
00:09:33,600 --> 00:09:35,339
we are going to have some problems

253
00:09:35,339 --> 00:09:36,480
because we are going to need more than

254
00:09:36,480 --> 00:09:38,580
one buffer for this and I'm going to

255
00:09:38,580 --> 00:09:40,620
call this kind of request a long request

256
00:09:40,620 --> 00:09:42,899
even though it's not that long it's just

257
00:09:42,899 --> 00:09:45,660
like 65 kilobytes but what is going to

258
00:09:45,660 --> 00:09:48,000
happen is that when this request arrives

259
00:09:48,000 --> 00:09:51,420
for example a rigors containing in 66

260
00:09:51,420 --> 00:09:53,640
000 bytes in the body

261
00:09:53,640 --> 00:09:56,160
the worker thread will Reserve an API

262
00:09:56,160 --> 00:09:58,260
buffer and it will store the first 65

263
00:09:58,260 --> 00:09:59,820
kilobytes and this is because the

264
00:09:59,820 --> 00:10:02,100
internet handlers only need the healers

265
00:10:02,100 --> 00:10:04,500
of our request to resolve or to generate

266
00:10:04,500 --> 00:10:07,740
a response so it's the ICM expects that

267
00:10:07,740 --> 00:10:09,300
if an internal Handler is able to

268
00:10:09,300 --> 00:10:10,980
resolve the request then there is no

269
00:10:10,980 --> 00:10:15,180
body and in in sap they have the headers

270
00:10:15,180 --> 00:10:17,040
cannot be longer than 65 kilobytes

271
00:10:17,040 --> 00:10:19,019
therefore it's not necessary to store

272
00:10:19,019 --> 00:10:21,000
more than one or to reserve more than

273
00:10:21,000 --> 00:10:22,800
one MPI buffer

274
00:10:22,800 --> 00:10:25,620
now the handles will be called and in

275
00:10:25,620 --> 00:10:27,779
this case only the cache and the Java or

276
00:10:27,779 --> 00:10:29,060
above Handler

277
00:10:29,060 --> 00:10:32,519
in this case will fail and so now when

278
00:10:32,519 --> 00:10:34,800
the cash when the worker process a

279
00:10:34,800 --> 00:10:36,839
Handler is called the rest of the

280
00:10:36,839 --> 00:10:38,100
request is going to be placed in the

281
00:10:38,100 --> 00:10:40,260
share memory because the business logic

282
00:10:40,260 --> 00:10:42,360
or the the actual Java River process

283
00:10:42,360 --> 00:10:44,820
will need the body of the request

284
00:10:44,820 --> 00:10:48,300
so the ICM will reserve a new MPI buffer

285
00:10:48,300 --> 00:10:51,000
or as many as needed it will place the

286
00:10:51,000 --> 00:10:52,740
request there the rest of the request

287
00:10:52,740 --> 00:10:54,959
and it will send both references to the

288
00:10:54,959 --> 00:10:56,820
Java River process

289
00:10:56,820 --> 00:10:58,440
now the gallery or process will be able

290
00:10:58,440 --> 00:11:00,240
to generate a response again

291
00:11:00,240 --> 00:11:02,519
it will store their response in an MPI

292
00:11:02,519 --> 00:11:03,959
buffer

293
00:11:03,959 --> 00:11:05,579
it will send a reference back to the

294
00:11:05,579 --> 00:11:07,620
worker thread

295
00:11:07,620 --> 00:11:09,360
and the worker thread will now be able

296
00:11:09,360 --> 00:11:11,820
to forward the response back to the

297
00:11:11,820 --> 00:11:13,800
inputable handle which will forward it

298
00:11:13,800 --> 00:11:15,180
to the client

299
00:11:15,180 --> 00:11:17,399
and now as there were more than one

300
00:11:17,399 --> 00:11:19,620
buffer used for this request instead of

301
00:11:19,620 --> 00:11:22,019
erasing or freeing each of these buffer

302
00:11:22,019 --> 00:11:24,720
One By One The MPI free or buffer

303
00:11:24,720 --> 00:11:26,279
function is going to be called so that

304
00:11:26,279 --> 00:11:28,380
all buffers are freed and that is all

305
00:11:28,380 --> 00:11:30,240
buffers associated with the worker

306
00:11:30,240 --> 00:11:32,540
thread

307
00:11:32,760 --> 00:11:34,500
and now the references will be lost

308
00:11:34,500 --> 00:11:35,880
again

309
00:11:35,880 --> 00:11:38,940
so let's see at the first vulnerability

310
00:11:38,940 --> 00:11:42,120
so as I said the ICM is not expecting

311
00:11:42,120 --> 00:11:43,500
that an internal Handler is able to

312
00:11:43,500 --> 00:11:45,540
resolve a request with a body but what

313
00:11:45,540 --> 00:11:47,880
if we send a long request that is a

314
00:11:47,880 --> 00:11:50,459
result by an internet Handler

315
00:11:50,459 --> 00:11:53,399
again we see a request which is a get to

316
00:11:53,399 --> 00:11:56,399
slash sap slash admin and with a body of

317
00:11:56,399 --> 00:12:00,600
65 66 kilobytes

318
00:12:00,600 --> 00:12:02,940
um and so this was what it would happen

319
00:12:02,940 --> 00:12:04,740
is that the worker 3 will again reserve

320
00:12:04,740 --> 00:12:07,680
a buffer place the first 65 kilobytes in

321
00:12:07,680 --> 00:12:09,120
this buffer

322
00:12:09,120 --> 00:12:11,399
and it will call all the handlers

323
00:12:11,399 --> 00:12:13,200
the cache counter will fail

324
00:12:13,200 --> 00:12:14,940
but now the admin handle will resolve

325
00:12:14,940 --> 00:12:16,200
the request and that is something that

326
00:12:16,200 --> 00:12:19,079
the icing was not expecting to happen

327
00:12:19,079 --> 00:12:21,300
so the response will be created

328
00:12:21,300 --> 00:12:24,899
it will be forwarded to the client

329
00:12:24,899 --> 00:12:28,079
and the the counter will be will be

330
00:12:28,079 --> 00:12:30,720
deleted under of course the MPI buffer

331
00:12:30,720 --> 00:12:32,399
will be free and the request response

332
00:12:32,399 --> 00:12:34,140
cycle will be completed

333
00:12:34,140 --> 00:12:36,000
but we have more data from the previous

334
00:12:36,000 --> 00:12:38,700
request in the inputable Handler so what

335
00:12:38,700 --> 00:12:40,140
will happen is that the worker thread

336
00:12:40,140 --> 00:12:41,880
will read more because it's really

337
00:12:41,880 --> 00:12:43,620
waiting for a new request

338
00:12:43,620 --> 00:12:46,380
and it will place this request or the

339
00:12:46,380 --> 00:12:49,200
rest of the requested body in this MPI

340
00:12:49,200 --> 00:12:50,820
buffer and it will consider it as a new

341
00:12:50,820 --> 00:12:52,260
request

342
00:12:52,260 --> 00:12:54,480
so if you know something about https

343
00:12:54,480 --> 00:12:56,160
synchronization then you will know that

344
00:12:56,160 --> 00:12:58,440
this is a big vulnerability because we

345
00:12:58,440 --> 00:12:59,880
are going to be able to desynchronize

346
00:12:59,880 --> 00:13:02,579
any ICM or the communication between a

347
00:13:02,579 --> 00:13:05,160
proxy and an ICM in any case and that is

348
00:13:05,160 --> 00:13:07,019
because this request that we can see in

349
00:13:07,019 --> 00:13:08,940
the slide has nothing strange it's

350
00:13:08,940 --> 00:13:11,940
completely RFC compliant and so any

351
00:13:11,940 --> 00:13:14,279
proxy that sees this request will think

352
00:13:14,279 --> 00:13:16,620
that this is an isolated an isolated HD

353
00:13:16,620 --> 00:13:19,620
message because it's a get request to a

354
00:13:19,620 --> 00:13:23,339
normal URL and it contains a body of 65

355
00:13:23,339 --> 00:13:25,579
in this case of 65

356
00:13:25,579 --> 00:13:28,980
546 and 17 bytes which includes the

357
00:13:28,980 --> 00:13:31,200
entire body and that is also the get a

358
00:13:31,200 --> 00:13:32,940
smuggle request

359
00:13:32,940 --> 00:13:36,480
and when this reaches the ICM

360
00:13:36,480 --> 00:13:38,459
and the ICM will actually split this and

361
00:13:38,459 --> 00:13:40,740
it will consider that the last part of

362
00:13:40,740 --> 00:13:43,620
the of the body is a new request so this

363
00:13:43,620 --> 00:13:46,079
will allow us to split the request and

364
00:13:46,079 --> 00:13:48,959
actually cause a desynchronization

365
00:13:48,959 --> 00:13:50,399
now you might think that this is not

366
00:13:50,399 --> 00:13:51,779
such a critical vulnerability but

367
00:13:51,779 --> 00:13:54,060
remember we found our limited that is

368
00:13:54,060 --> 00:13:55,320
without them to get without

369
00:13:55,320 --> 00:13:57,660
authentication and that is in a

370
00:13:57,660 --> 00:13:59,639
component that is completely exposed to

371
00:13:59,639 --> 00:14:02,639
the internet in all sap by default and

372
00:14:02,639 --> 00:14:05,100
you are going to see how we can use this

373
00:14:05,100 --> 00:14:07,320
and how why this synchronization is so

374
00:14:07,320 --> 00:14:08,760
critical because I'm going to explain

375
00:14:08,760 --> 00:14:12,720
how we can use this to either still a

376
00:14:12,720 --> 00:14:15,420
user's credentials it is still session

377
00:14:15,420 --> 00:14:18,300
cookies and also modify the behavior of

378
00:14:18,300 --> 00:14:20,040
the application

379
00:14:20,040 --> 00:14:21,899
I'm going to show actually one example

380
00:14:21,899 --> 00:14:24,480
there are others I'm not able to show

381
00:14:24,480 --> 00:14:26,100
this in in this presentation you can

382
00:14:26,100 --> 00:14:28,019
read it in the white paper

383
00:14:28,019 --> 00:14:30,180
but what I'm going to show is how to

384
00:14:30,180 --> 00:14:33,540
hijack a session from a from a user and

385
00:14:33,540 --> 00:14:35,220
to do so I'm going to use the NWA

386
00:14:35,220 --> 00:14:37,260
endpoint which is also present by

387
00:14:37,260 --> 00:14:39,540
default in all saps and it's an endpoint

388
00:14:39,540 --> 00:14:41,579
that is used to redirect users to the

389
00:14:41,579 --> 00:14:42,839
login URL

390
00:14:42,839 --> 00:14:44,399
and this provides two interesting

391
00:14:44,399 --> 00:14:46,199
features

392
00:14:46,199 --> 00:14:48,720
the first one is an open redirect that

393
00:14:48,720 --> 00:14:50,880
will allow us to inject something in the

394
00:14:50,880 --> 00:14:54,000
in the array reg or in the URL actually

395
00:14:54,000 --> 00:14:55,160
in the host

396
00:14:55,160 --> 00:14:58,380
so we will be able to change anything we

397
00:14:58,380 --> 00:15:00,420
want by placing something in the host

398
00:15:00,420 --> 00:15:02,760
header of the request of course this is

399
00:15:02,760 --> 00:15:04,199
not actually a vulnerability this is a

400
00:15:04,199 --> 00:15:07,019
feature because in some normal cases we

401
00:15:07,019 --> 00:15:09,360
are not going to be able to modify this

402
00:15:09,360 --> 00:15:11,579
in addictive

403
00:15:11,579 --> 00:15:13,800
and also the other important feature is

404
00:15:13,800 --> 00:15:15,360
that we will be able to reflect

405
00:15:15,360 --> 00:15:16,920
parameters we will be able to reflect

406
00:15:16,920 --> 00:15:18,540
anything we place in the body of the

407
00:15:18,540 --> 00:15:20,279
request and in a post request and the

408
00:15:20,279 --> 00:15:21,860
query string of a get request

409
00:15:21,860 --> 00:15:25,920
in the query string of the redirect URL

410
00:15:25,920 --> 00:15:28,199
okay the as you can see the line breaks

411
00:15:28,199 --> 00:15:31,380
will be replaced with spaces

412
00:15:31,380 --> 00:15:34,980
so let's combine this NWA features and

413
00:15:34,980 --> 00:15:37,260
the the synchronization to hijack a

414
00:15:37,260 --> 00:15:40,320
victims request and a victim session

415
00:15:40,320 --> 00:15:42,120
to do so the attacker will send a

416
00:15:42,120 --> 00:15:45,240
payload which is just available to uh to

417
00:15:45,240 --> 00:15:47,760
an internal Handler or a request to an

418
00:15:47,760 --> 00:15:49,440
internet Handler that will we can that

419
00:15:49,440 --> 00:15:52,680
it will contain a smuggle request

420
00:15:52,680 --> 00:15:55,320
when this reads the ICM it will be

421
00:15:55,320 --> 00:15:57,600
splitted as we already said so

422
00:15:57,600 --> 00:16:00,360
and the first part will be resolved by

423
00:16:00,360 --> 00:16:01,920
the internal Handler and the response

424
00:16:01,920 --> 00:16:03,720
will be sent back to the attacker but

425
00:16:03,720 --> 00:16:05,760
the rest will be stored in the ICM

426
00:16:05,760 --> 00:16:08,040
because in this case the content length

427
00:16:08,040 --> 00:16:10,260
states that there should be 100 bytes in

428
00:16:10,260 --> 00:16:12,480
the body but we can choose any amount of

429
00:16:12,480 --> 00:16:14,639
light we want but as you can see there

430
00:16:14,639 --> 00:16:16,920
is no body so it will wait for more data

431
00:16:16,920 --> 00:16:18,839
also you can see this is a post request

432
00:16:18,839 --> 00:16:22,019
to NWA and with the host hitter being

433
00:16:22,019 --> 00:16:24,060
evil.com which is a host controlled by

434
00:16:24,060 --> 00:16:25,440
the attacker

435
00:16:25,440 --> 00:16:27,480
so when a victim issues a request to the

436
00:16:27,480 --> 00:16:28,500
proxy

437
00:16:28,500 --> 00:16:30,839
the proxy will forward this request and

438
00:16:30,839 --> 00:16:32,880
it will concatenate it with the with the

439
00:16:32,880 --> 00:16:35,220
previous smuggle request and it will use

440
00:16:35,220 --> 00:16:36,959
the first hundred bytes of this request

441
00:16:36,959 --> 00:16:39,180
as part of the body

442
00:16:39,180 --> 00:16:41,160
so the response that will be generated

443
00:16:41,160 --> 00:16:44,279
by the ICM will be a redirect to

444
00:16:44,279 --> 00:16:48,120
evil.com and this this redirect will

445
00:16:48,120 --> 00:16:50,519
also contain in the in the query string

446
00:16:50,519 --> 00:16:52,800
the first hundred bytes or as many as we

447
00:16:52,800 --> 00:16:55,079
want of the original request of the

448
00:16:55,079 --> 00:16:56,940
victim and this also includes the

449
00:16:56,940 --> 00:16:58,800
cookies

450
00:16:58,800 --> 00:17:00,839
so when the browser of the victim

451
00:17:00,839 --> 00:17:03,899
receives this request it will send a new

452
00:17:03,899 --> 00:17:05,880
request sorry when the victim drops will

453
00:17:05,880 --> 00:17:07,559
receive this response it will send a new

454
00:17:07,559 --> 00:17:09,480
request but in this case to evil.com

455
00:17:09,480 --> 00:17:11,099
which is a host controlled by the

456
00:17:11,099 --> 00:17:12,359
attacker

457
00:17:12,359 --> 00:17:14,880
so this request will not only contain

458
00:17:14,880 --> 00:17:17,760
what was expected from the redirect but

459
00:17:17,760 --> 00:17:19,980
also the query string will contain the

460
00:17:19,980 --> 00:17:22,319
original request of the victim including

461
00:17:22,319 --> 00:17:24,859
the cookies

462
00:17:24,900 --> 00:17:27,299
so that way we will be able to hijack

463
00:17:27,299 --> 00:17:30,240
any any victims session and the cookies

464
00:17:30,240 --> 00:17:32,820
and we will be able to actually take

465
00:17:32,820 --> 00:17:35,220
control of an application if we hijack

466
00:17:35,220 --> 00:17:38,940
for example an admin user but for each

467
00:17:38,940 --> 00:17:41,340
request that we are able to hijack we

468
00:17:41,340 --> 00:17:43,140
will be needing to we will need to send

469
00:17:43,140 --> 00:17:44,460
a new attack

470
00:17:44,460 --> 00:17:47,100
and we don't want to do it or we want to

471
00:17:47,100 --> 00:17:49,440
just send one attack and to make this

472
00:17:49,440 --> 00:17:50,880
persistent

473
00:17:50,880 --> 00:17:52,380
and what's interesting about the

474
00:17:52,380 --> 00:17:53,940
vulnerability and why it's so critical

475
00:17:53,940 --> 00:17:56,280
is that we are not using any HTTP

476
00:17:56,280 --> 00:17:59,280
headers to attack this so we actually

477
00:17:59,280 --> 00:18:01,500
don't need to inject any special or

478
00:18:01,500 --> 00:18:03,000
strange header to cause the

479
00:18:03,000 --> 00:18:04,460
synchronization

480
00:18:04,460 --> 00:18:07,559
uh so what is going to happen is we are

481
00:18:07,559 --> 00:18:09,539
going to be able to exploit this by

482
00:18:09,539 --> 00:18:12,360
using HTML forms or JavaScript as you

483
00:18:12,360 --> 00:18:14,640
can see in the slide I can create a form

484
00:18:14,640 --> 00:18:16,559
that is going to send a request to an

485
00:18:16,559 --> 00:18:19,200
sap system with a URL being starting

486
00:18:19,200 --> 00:18:21,539
with Slash sap slash admin so it will be

487
00:18:21,539 --> 00:18:23,340
handled by your internet Handler

488
00:18:23,340 --> 00:18:25,799
uh it will contain a padding that will

489
00:18:25,799 --> 00:18:28,020
make this a long request

490
00:18:28,020 --> 00:18:30,059
and at the end will contain the smuggle

491
00:18:30,059 --> 00:18:31,320
a message

492
00:18:31,320 --> 00:18:33,059
of course it's the the smartest message

493
00:18:33,059 --> 00:18:35,160
is the post request to NWA as we already

494
00:18:35,160 --> 00:18:36,000
saw

495
00:18:36,000 --> 00:18:39,360
so when a victim receives this what is

496
00:18:39,360 --> 00:18:41,220
going to happen is that the JavaScript

497
00:18:41,220 --> 00:18:43,380
that is found at the end will submit

498
00:18:43,380 --> 00:18:45,480
this this form and the attack will be

499
00:18:45,480 --> 00:18:47,520
created but in this case from the

500
00:18:47,520 --> 00:18:49,260
victims browser

501
00:18:49,260 --> 00:18:51,480
and we can also use this kind of attacks

502
00:18:51,480 --> 00:18:54,000
to uh in other in other vulnerabilities

503
00:18:54,000 --> 00:18:56,160
like the one found last year in hi proxy

504
00:18:56,160 --> 00:18:58,799
which again did not require any exchange

505
00:18:58,799 --> 00:19:02,700
or invalid HTTP header and or in any

506
00:19:02,700 --> 00:19:05,100
case a forbidden here like a host or a

507
00:19:05,100 --> 00:19:07,919
Content line heater so we will be able

508
00:19:07,919 --> 00:19:09,660
to use the same technique but in this

509
00:19:09,660 --> 00:19:12,419
case using DNS rebinding to allow the

510
00:19:12,419 --> 00:19:14,160
browser on the JavaScript to send the

511
00:19:14,160 --> 00:19:17,520
extra the extra headers

512
00:19:17,520 --> 00:19:22,039
I'm going to show now an example of this

513
00:19:31,380 --> 00:19:33,660
so in this tab we are going to see the

514
00:19:33,660 --> 00:19:34,860
victim

515
00:19:34,860 --> 00:19:37,440
and the victim is going to send a normal

516
00:19:37,440 --> 00:19:38,880
request to start page and we can see

517
00:19:38,880 --> 00:19:41,940
that the response is 200 and in this

518
00:19:41,940 --> 00:19:43,559
request it's also included the cookies

519
00:19:43,559 --> 00:19:45,780
of the victim and nothing strange is

520
00:19:45,780 --> 00:19:47,760
going on until here

521
00:19:47,760 --> 00:19:49,620
okay you can see the cookies

522
00:19:49,620 --> 00:19:51,360
but in this tab we are going to see the

523
00:19:51,360 --> 00:19:52,919
attacker which is going to send the

524
00:19:52,919 --> 00:19:54,900
payload we already saw

525
00:19:54,900 --> 00:19:57,539
this is again to slash sap slash admin

526
00:19:57,539 --> 00:19:59,280
I'm going to use slash sap slash admin

527
00:19:59,280 --> 00:20:00,960
because it's always present and he sees

528
00:20:00,960 --> 00:20:03,480
it and at the end it's going to contain

529
00:20:03,480 --> 00:20:06,440
the smuggle request

530
00:20:07,980 --> 00:20:11,400
so when this is sent to the to the ICM

531
00:20:11,400 --> 00:20:14,039
it will place the smuggle request in the

532
00:20:14,039 --> 00:20:16,080
eyes in the back end and it will wait

533
00:20:16,080 --> 00:20:18,840
for more data so when a victim sends her

534
00:20:18,840 --> 00:20:21,179
request he will receive a redirect as we

535
00:20:21,179 --> 00:20:23,760
erase off that will send him to the

536
00:20:23,760 --> 00:20:25,620
malicious domain which is controlled by

537
00:20:25,620 --> 00:20:29,400
the attacker and it will send also the

538
00:20:29,400 --> 00:20:31,799
the session cookies and everything at

539
00:20:31,799 --> 00:20:33,720
the first in this case 200 bytes of the

540
00:20:33,720 --> 00:20:36,080
request

541
00:20:38,039 --> 00:20:41,660
if we follow the erection

542
00:20:42,960 --> 00:20:44,460
what we are going to see is that the

543
00:20:44,460 --> 00:20:46,860
evil server actually received this this

544
00:20:46,860 --> 00:20:49,020
data so we already have the cookies of

545
00:20:49,020 --> 00:20:51,120
the victim but also it responded with a

546
00:20:51,120 --> 00:20:53,520
form that will continue the attack so

547
00:20:53,520 --> 00:20:55,020
now the big thing will become the

548
00:20:55,020 --> 00:20:57,000
attacker and this will create a botnet

549
00:20:57,000 --> 00:20:59,100
that will persist the attack as long as

550
00:20:59,100 --> 00:21:01,399
we want

551
00:21:09,260 --> 00:21:12,179
but after seeing this vulnerability I

552
00:21:12,179 --> 00:21:14,160
wanted to know more about the ICM so I

553
00:21:14,160 --> 00:21:15,240
started looking at the different

554
00:21:15,240 --> 00:21:17,820
features that it offers and what's

555
00:21:17,820 --> 00:21:20,100
interesting is that the ICM when it's

556
00:21:20,100 --> 00:21:21,900
configured for Java for a Java process

557
00:21:21,900 --> 00:21:24,480
will accept pipeline requests this is

558
00:21:24,480 --> 00:21:27,480
something expected from the RFC but in I

559
00:21:27,480 --> 00:21:29,580
enable this is not by default

560
00:21:29,580 --> 00:21:33,360
so this means that the ICM will allow to

561
00:21:33,360 --> 00:21:35,880
receive a concatenated request in the

562
00:21:35,880 --> 00:21:38,700
same payload and when this happens the

563
00:21:38,700 --> 00:21:41,100
worker thread will actually store both

564
00:21:41,100 --> 00:21:43,559
requests in the same API buffer

565
00:21:43,559 --> 00:21:45,780
but when the HTTP parts were recognized

566
00:21:45,780 --> 00:21:47,580
that there is an extra request it will

567
00:21:47,580 --> 00:21:49,440
reserve a new MPI buffer and it will

568
00:21:49,440 --> 00:21:52,140
place the request there so now the

569
00:21:52,140 --> 00:21:54,179
worker process will continue processing

570
00:21:54,179 --> 00:21:56,280
the the first the worker thread will

571
00:21:56,280 --> 00:21:58,080
continue processing the first request it

572
00:21:58,080 --> 00:22:00,240
will send it to a Java process

573
00:22:00,240 --> 00:22:01,740
the Java process will generate the

574
00:22:01,740 --> 00:22:03,000
response

575
00:22:03,000 --> 00:22:05,340
it will place it in the MPI buffer

576
00:22:05,340 --> 00:22:07,500
send it to the worker thread and the

577
00:22:07,500 --> 00:22:09,000
worker thread will forward this response

578
00:22:09,000 --> 00:22:10,679
back to the victim or to the client

579
00:22:10,679 --> 00:22:12,000
actually

580
00:22:12,000 --> 00:22:14,280
now the MPI buffers will be freed one by

581
00:22:14,280 --> 00:22:15,059
one

582
00:22:15,059 --> 00:22:17,100
the references will be lost and the

583
00:22:17,100 --> 00:22:19,320
request response cycle will be completed

584
00:22:19,320 --> 00:22:21,659
and now the worker third will start

585
00:22:21,659 --> 00:22:23,520
processing the next request that was

586
00:22:23,520 --> 00:22:25,559
stored in the in another MPI buffer

587
00:22:25,559 --> 00:22:29,000
because this was a pipeline request

588
00:22:30,059 --> 00:22:33,960
but what about sending uh a long request

589
00:22:33,960 --> 00:22:37,140
with a pipeline request at the end

590
00:22:37,140 --> 00:22:39,900
so let's say we send a request with this

591
00:22:39,900 --> 00:22:42,720
longer than 65 kilobytes and at the end

592
00:22:42,720 --> 00:22:45,000
we send another pipeline request

593
00:22:45,000 --> 00:22:48,000
now the worker thread will reserve a

594
00:22:48,000 --> 00:22:50,220
buffer again it will place the first 65

595
00:22:50,220 --> 00:22:51,900
kilobytes there

596
00:22:51,900 --> 00:22:53,820
the when it's ready to send it to the

597
00:22:53,820 --> 00:22:56,400
Java process we'll store the other part

598
00:22:56,400 --> 00:22:58,980
in another MPI buffer and the HTTP

599
00:22:58,980 --> 00:23:00,360
parser will recognize that there is an

600
00:23:00,360 --> 00:23:02,520
extra request so again

601
00:23:02,520 --> 00:23:04,679
it will reserve a new API buffer and it

602
00:23:04,679 --> 00:23:07,620
will place the pipeline request there

603
00:23:07,620 --> 00:23:09,659
now of course the worker thread will

604
00:23:09,659 --> 00:23:11,280
send it to the Java process the first

605
00:23:11,280 --> 00:23:13,799
two buffers it will generate a response

606
00:23:13,799 --> 00:23:16,200
place it in natural memory send it to

607
00:23:16,200 --> 00:23:17,820
the worker thread again

608
00:23:17,820 --> 00:23:19,559
and the response will be forwarded to

609
00:23:19,559 --> 00:23:22,020
the client but remember one thing when

610
00:23:22,020 --> 00:23:24,659
we send a long request the buffers are

611
00:23:24,659 --> 00:23:27,120
not free one by one instead they are

612
00:23:27,120 --> 00:23:29,100
going to be the MPI Freel buffers is

613
00:23:29,100 --> 00:23:31,620
going to be used and so all the buffers

614
00:23:31,620 --> 00:23:33,360
associated with this worker thread will

615
00:23:33,360 --> 00:23:36,960
be freed and that includes the the MPI

616
00:23:36,960 --> 00:23:38,460
buffer that was used for the pipeline

617
00:23:38,460 --> 00:23:40,080
request

618
00:23:40,080 --> 00:23:42,780
so now we have a reference to a free MPI

619
00:23:42,780 --> 00:23:43,980
buffer

620
00:23:43,980 --> 00:23:46,500
and when we try to of course the the

621
00:23:46,500 --> 00:23:48,480
reference is not lost when the MPI

622
00:23:48,480 --> 00:23:50,520
buffers are free

623
00:23:50,520 --> 00:23:52,799
and so when the worker thread sends this

624
00:23:52,799 --> 00:23:55,620
to the Java process we will see a narrow

625
00:23:55,620 --> 00:23:58,440
race because the the worker threat

626
00:23:58,440 --> 00:24:00,900
thinks that there is no buffer being

627
00:24:00,900 --> 00:24:02,400
used

628
00:24:02,400 --> 00:24:05,580
so what can we do with this well

629
00:24:05,580 --> 00:24:07,679
of course we can have a reference to our

630
00:24:07,679 --> 00:24:10,620
free MPA buffer and if another TCP

631
00:24:10,620 --> 00:24:12,600
connection another worker thread tries

632
00:24:12,600 --> 00:24:16,020
to store a request in the shared memory

633
00:24:16,020 --> 00:24:18,960
if we are lucky enough it will reserve

634
00:24:18,960 --> 00:24:21,000
the same MPI buffer that we were using

635
00:24:21,000 --> 00:24:22,860
and actually this is going to happen a

636
00:24:22,860 --> 00:24:25,140
lot because the mpa Handler actually

637
00:24:25,140 --> 00:24:27,240
allocates the free buffers in a list

638
00:24:27,240 --> 00:24:30,480
that is actually a stack even though sap

639
00:24:30,480 --> 00:24:33,059
states that this is a queue we are when

640
00:24:33,059 --> 00:24:35,760
after reverse engineering the the ICM I

641
00:24:35,760 --> 00:24:37,919
noticed that this is not a good stack so

642
00:24:37,919 --> 00:24:40,620
a free buffers are going to be used a

643
00:24:40,620 --> 00:24:44,640
lot again once over and over again so

644
00:24:44,640 --> 00:24:47,820
so the worker 32 will place the request

645
00:24:47,820 --> 00:24:51,000
there and it will modify the the buffer

646
00:24:51,000 --> 00:24:52,200
and of course we will have a different

647
00:24:52,200 --> 00:24:55,320
value inside the MPI buffer but if we

648
00:24:55,320 --> 00:24:58,080
try to get the response from this we

649
00:24:58,080 --> 00:24:59,280
will still have an error because the

650
00:24:59,280 --> 00:25:01,380
worker 31 believes that there are no

651
00:25:01,380 --> 00:25:03,120
buffers used

652
00:25:03,120 --> 00:25:06,179
so what we want is to write in in the

653
00:25:06,179 --> 00:25:09,120
same position after a big team plays his

654
00:25:09,120 --> 00:25:10,080
request

655
00:25:10,080 --> 00:25:12,659
and we are going to do it by sending an

656
00:25:12,659 --> 00:25:14,760
incomplete pipeline request so when we

657
00:25:14,760 --> 00:25:17,280
send incomplete requests the the worker

658
00:25:17,280 --> 00:25:18,600
thread waits for more data and

659
00:25:18,600 --> 00:25:19,980
incomplete requests are going to be any

660
00:25:19,980 --> 00:25:22,500
request that does not contain two line

661
00:25:22,500 --> 00:25:24,960
breaks after the heaters or that

662
00:25:24,960 --> 00:25:27,120
contains a body shorter than the message

663
00:25:27,120 --> 00:25:29,760
length healer was stated

664
00:25:29,760 --> 00:25:32,400
so when the worker thread reads A tries

665
00:25:32,400 --> 00:25:34,740
to read this this request it will it

666
00:25:34,740 --> 00:25:37,020
will parse it and it will set again will

667
00:25:37,020 --> 00:25:40,080
be said again to read mode because more

668
00:25:40,080 --> 00:25:42,600
data is required so when this data

669
00:25:42,600 --> 00:25:45,059
arrives then it will be written at the

670
00:25:45,059 --> 00:25:48,240
end of the API of the MPI buffer and it

671
00:25:48,240 --> 00:25:51,380
will be written at the position that is

672
00:25:51,380 --> 00:25:54,240
stored in the offset so each worker

673
00:25:54,240 --> 00:25:57,120
thread has an offset for each MBI buffer

674
00:25:57,120 --> 00:25:59,340
as you can see if we send first some

675
00:25:59,340 --> 00:26:01,380
data and then we send more data it will

676
00:26:01,380 --> 00:26:04,760
be placed in the same memory address

677
00:26:04,760 --> 00:26:09,120
and the offset of this buffer will be

678
00:26:09,120 --> 00:26:10,799
modified

679
00:26:10,799 --> 00:26:13,440
so again let's see an example

680
00:26:13,440 --> 00:26:15,720
we will send a request a long request

681
00:26:15,720 --> 00:26:18,120
with an extra byte which is the pipeline

682
00:26:18,120 --> 00:26:19,980
request

683
00:26:19,980 --> 00:26:21,960
it will be stored the first part it will

684
00:26:21,960 --> 00:26:23,940
be storing the MPI buffers and then the

685
00:26:23,940 --> 00:26:26,659
HTTP parser will recognize this

686
00:26:26,659 --> 00:26:29,940
and it will place the extra byte in

687
00:26:29,940 --> 00:26:31,620
another MPI buffer because it will

688
00:26:31,620 --> 00:26:34,080
believe that this is a pipeline request

689
00:26:34,080 --> 00:26:36,559
again the first part will be result

690
00:26:36,559 --> 00:26:39,120
request response will be generated will

691
00:26:39,120 --> 00:26:40,980
be placed in the shared memory forwarded

692
00:26:40,980 --> 00:26:42,900
to the worker thread and the worker

693
00:26:42,900 --> 00:26:44,880
thread will forward it to the client

694
00:26:44,880 --> 00:26:47,520
now all the buffers will be free and we

695
00:26:47,520 --> 00:26:49,200
will have the reference to this place

696
00:26:49,200 --> 00:26:51,539
but when the workers will try to parse

697
00:26:51,539 --> 00:26:54,480
this pipeline request it will stop and

698
00:26:54,480 --> 00:26:56,580
it will be set into read mode

699
00:26:56,580 --> 00:26:59,400
now if we are lucky enough a worker

700
00:26:59,400 --> 00:27:02,039
thread 2 or a client a victim will send

701
00:27:02,039 --> 00:27:04,140
his request and the worker thread will

702
00:27:04,140 --> 00:27:07,260
reserve the same MPI buffer

703
00:27:07,260 --> 00:27:09,120
and when this happens you can see the

704
00:27:09,120 --> 00:27:12,419
MPI buffer at the top the workers need 2

705
00:27:12,419 --> 00:27:14,880
will have the offset 55 because it has

706
00:27:14,880 --> 00:27:17,700
written 55 bytes the request will be

707
00:27:17,700 --> 00:27:18,840
placed there

708
00:27:18,840 --> 00:27:21,539
and if the attacker then sends a request

709
00:27:21,539 --> 00:27:23,940
or the rest of the request you will be

710
00:27:23,940 --> 00:27:25,919
able to Tamper the request that the

711
00:27:25,919 --> 00:27:27,480
victim issued

712
00:27:27,480 --> 00:27:30,120
so now when the worker 32 sends the MPI

713
00:27:30,120 --> 00:27:32,700
pointer to the Java process the job

714
00:27:32,700 --> 00:27:35,159
process will actually use the new the

715
00:27:35,159 --> 00:27:37,440
new request that was modified by the

716
00:27:37,440 --> 00:27:39,600
attacker so this will generate for

717
00:27:39,600 --> 00:27:41,640
example a malicious response will be

718
00:27:41,640 --> 00:27:43,919
placed in the MPI buffer and the worker

719
00:27:43,919 --> 00:27:46,380
thread will forward this back to the

720
00:27:46,380 --> 00:27:48,120
client

721
00:27:48,120 --> 00:27:51,360
okay so again the steps to reproduce

722
00:27:51,360 --> 00:27:53,100
this attack is the attacker needs to

723
00:27:53,100 --> 00:27:55,260
hijack an API buffer the victim will

724
00:27:55,260 --> 00:27:57,000
send a request that will be placed in

725
00:27:57,000 --> 00:27:58,799
the same MPI buffer

726
00:27:58,799 --> 00:28:00,779
the attacker will then tamper this data

727
00:28:00,779 --> 00:28:02,279
and the victim will receive the

728
00:28:02,279 --> 00:28:03,840
malicious response which in this case

729
00:28:03,840 --> 00:28:06,360
for example if we send again to start

730
00:28:06,360 --> 00:28:08,460
page as a victim in some cases we will

731
00:28:08,460 --> 00:28:11,279
receive the redirect to evil.com

732
00:28:11,279 --> 00:28:13,799
and we can use the exact same attacks in

733
00:28:13,799 --> 00:28:15,299
that in the previous example in the

734
00:28:15,299 --> 00:28:17,600
previous vulnerability and any attack of

735
00:28:17,600 --> 00:28:19,919
smuggling exploitation will be will be

736
00:28:19,919 --> 00:28:23,400
successful and also the we will not need

737
00:28:23,400 --> 00:28:25,440
a proxy because we're actually tampering

738
00:28:25,440 --> 00:28:27,299
different TCP connections so we connect

739
00:28:27,299 --> 00:28:29,520
we can make this attack even without a

740
00:28:29,520 --> 00:28:33,059
proxy but it is less reliable

741
00:28:33,059 --> 00:28:34,919
but if you see that the image you will

742
00:28:34,919 --> 00:28:36,600
notice that some of the responses does

743
00:28:36,600 --> 00:28:39,120
not contain a stethoscope and that is

744
00:28:39,120 --> 00:28:41,039
because in some cases we are not

745
00:28:41,039 --> 00:28:43,740
tampering the request a buffer but

746
00:28:43,740 --> 00:28:45,419
instead we are tampering a response

747
00:28:45,419 --> 00:28:47,520
buffer because MPI buffers are

748
00:28:47,520 --> 00:28:50,159
multi-purpose so we can use the same API

749
00:28:50,159 --> 00:28:53,039
buffer for a request and a response

750
00:28:53,039 --> 00:28:55,440
so again let's say we already have an

751
00:28:55,440 --> 00:28:57,360
API buffer hijacked

752
00:28:57,360 --> 00:29:01,020
and a request arrives from the victim

753
00:29:01,020 --> 00:29:03,720
and in this case let's say that the

754
00:29:03,720 --> 00:29:06,179
victim does not reserve the same MPI

755
00:29:06,179 --> 00:29:07,860
buffer but another one this is just a

756
00:29:07,860 --> 00:29:10,020
timing scenario depending on the time

757
00:29:10,020 --> 00:29:11,820
when we send one request and the other

758
00:29:11,820 --> 00:29:14,520
in some cases one buffer will be used

759
00:29:14,520 --> 00:29:16,500
and in some cases another

760
00:29:16,500 --> 00:29:18,840
so in this case another MPA buffer will

761
00:29:18,840 --> 00:29:20,159
use for the request

762
00:29:20,159 --> 00:29:22,559
it will be sent to the Java process and

763
00:29:22,559 --> 00:29:23,820
the job process will generate the

764
00:29:23,820 --> 00:29:25,140
response that will be placed in this

765
00:29:25,140 --> 00:29:27,480
case in the MPI buffer we have a

766
00:29:27,480 --> 00:29:28,980
hijacked

767
00:29:28,980 --> 00:29:32,159
so now the response will be placed there

768
00:29:32,159 --> 00:29:35,340
and if at any of this and if sorry and

769
00:29:35,340 --> 00:29:37,500
if at this point we are able to send

770
00:29:37,500 --> 00:29:39,120
more data

771
00:29:39,120 --> 00:29:41,340
we are going to be able to Tamper not

772
00:29:41,340 --> 00:29:43,679
the risk the request but the response

773
00:29:43,679 --> 00:29:46,080
so we will be able to place anything we

774
00:29:46,080 --> 00:29:47,820
want we will be able to write an

775
00:29:47,820 --> 00:29:49,980
arbitrary response that will be sent to

776
00:29:49,980 --> 00:29:52,380
the client

777
00:29:52,380 --> 00:29:55,919
so when the worker thread to uh sends

778
00:29:55,919 --> 00:29:57,360
before sending the request is going to

779
00:29:57,360 --> 00:29:58,919
pass the response itself sorry the

780
00:29:58,919 --> 00:30:01,080
response is going to be parsed

781
00:30:01,080 --> 00:30:03,000
it will send it to the client

782
00:30:03,000 --> 00:30:06,059
and if you notice the the MPI the API

783
00:30:06,059 --> 00:30:07,500
buffer you will see that there is an

784
00:30:07,500 --> 00:30:09,840
extra header that I included there and

785
00:30:09,840 --> 00:30:12,779
that is sap cache control here which is

786
00:30:12,779 --> 00:30:15,539
an internet healer used to to select

787
00:30:15,539 --> 00:30:17,580
which responses should be stored in the

788
00:30:17,580 --> 00:30:19,799
cachet

789
00:30:19,799 --> 00:30:22,440
so what's going to happen is that the

790
00:30:22,440 --> 00:30:24,120
cache Handler will think that this

791
00:30:24,120 --> 00:30:25,980
response should be stored in negative

792
00:30:25,980 --> 00:30:27,659
therefore

793
00:30:27,659 --> 00:30:30,179
is going to say to see what was the

794
00:30:30,179 --> 00:30:32,279
request URL and it will store the

795
00:30:32,279 --> 00:30:35,279
response for that resource

796
00:30:35,279 --> 00:30:37,860
and we can even play the role of the big

797
00:30:37,860 --> 00:30:40,320
team if we instead of sending just the

798
00:30:40,320 --> 00:30:42,000
attack we can also send a lot of

799
00:30:42,000 --> 00:30:45,360
requests to actually modify any URL we

800
00:30:45,360 --> 00:30:47,460
want so we will be able to poison any

801
00:30:47,460 --> 00:30:51,059
URL and to to create a response I will

802
00:30:51,059 --> 00:30:52,860
completely arbitrary so we can place a

803
00:30:52,860 --> 00:30:54,960
script we can place anything we want by

804
00:30:54,960 --> 00:30:58,340
using the sap cache control

805
00:31:04,020 --> 00:31:06,240
so we are going to see a demo of this

806
00:31:06,240 --> 00:31:09,179
attack and remember one thing if we are

807
00:31:09,179 --> 00:31:12,000
able to this is not reliable this is not

808
00:31:12,000 --> 00:31:13,980
really reliable we will need some some

809
00:31:13,980 --> 00:31:16,260
attempts not a lot of attempts but it's

810
00:31:16,260 --> 00:31:18,539
not going to happen in one attack but if

811
00:31:18,539 --> 00:31:20,640
we are successful for only one attack

812
00:31:20,640 --> 00:31:23,399
then this response will be stored so it

813
00:31:23,399 --> 00:31:26,100
will be persisted forever if we set a

814
00:31:26,100 --> 00:31:31,500
big sap cache control max age value

815
00:31:31,500 --> 00:31:34,260
so as you can see we send a request to

816
00:31:34,260 --> 00:31:36,840
start page and nothing strange happens

817
00:31:36,840 --> 00:31:41,360
okay we just get a normal response

818
00:31:42,539 --> 00:31:45,779
but we are going to try to focus on this

819
00:31:45,779 --> 00:31:49,640
start page URL

820
00:31:49,740 --> 00:31:51,899
so I'm going to use a small script I

821
00:31:51,899 --> 00:31:54,600
wrote in Python that is going to first

822
00:31:54,600 --> 00:31:58,140
try to hijack different API buffers

823
00:31:58,140 --> 00:32:01,320
then it will send a lot of requests to

824
00:32:01,320 --> 00:32:04,380
start page so that we are able to modify

825
00:32:04,380 --> 00:32:06,360
those responses

826
00:32:06,360 --> 00:32:09,600
and then it will try to add to Tamper

827
00:32:09,600 --> 00:32:12,299
the data of these responses so it will

828
00:32:12,299 --> 00:32:14,700
try to place the sap cache control in

829
00:32:14,700 --> 00:32:16,080
this response and also a malicious

830
00:32:16,080 --> 00:32:18,179
script

831
00:32:18,179 --> 00:32:20,279
of course we are not going to be able to

832
00:32:20,279 --> 00:32:22,380
hijack this buffer and modify the

833
00:32:22,380 --> 00:32:24,419
response in just one attempt we are

834
00:32:24,419 --> 00:32:27,299
going to need to send a lot of attacks

835
00:32:27,299 --> 00:32:30,000
actually not a lot some a few a few of

836
00:32:30,000 --> 00:32:32,120
them

837
00:32:33,779 --> 00:32:35,520
so

838
00:32:35,520 --> 00:32:38,340
as I said after one of these attacks is

839
00:32:38,340 --> 00:32:40,440
successful the money the start page will

840
00:32:40,440 --> 00:32:42,960
be modified and the the script will

841
00:32:42,960 --> 00:32:44,520
recognize this

842
00:32:44,520 --> 00:32:46,980
it will change the times to try to be

843
00:32:46,980 --> 00:32:50,100
able to do it and again as you can see

844
00:32:50,100 --> 00:32:52,679
after a few times where we were able to

845
00:32:52,679 --> 00:32:55,320
modify the start page

846
00:32:55,320 --> 00:32:57,659
so now when a big team or any client

847
00:32:57,659 --> 00:32:59,399
requests for the surprise he will

848
00:32:59,399 --> 00:33:01,380
actually receive a different response

849
00:33:01,380 --> 00:33:04,679
which is which contains a script and an

850
00:33:04,679 --> 00:33:07,760
arbitrary HTML

851
00:33:08,720 --> 00:33:17,410
[Applause]

852
00:33:20,220 --> 00:33:23,100
okay so with this we are able to modify

853
00:33:23,100 --> 00:33:24,480
anything we want from the application

854
00:33:24,480 --> 00:33:26,940
but still there is something else we can

855
00:33:26,940 --> 00:33:30,659
do and that is to try to modify or to

856
00:33:30,659 --> 00:33:33,659
try to Tamper the memory of a of the

857
00:33:33,659 --> 00:33:35,880
cache of another file and I'm going to

858
00:33:35,880 --> 00:33:39,539
show you how so I said that we we were

859
00:33:39,539 --> 00:33:41,580
going to try to modify the response just

860
00:33:41,580 --> 00:33:44,940
before the response parser is called but

861
00:33:44,940 --> 00:33:46,919
what if we try to do it after that and

862
00:33:46,919 --> 00:33:48,840
that is just a matter of lag of course

863
00:33:48,840 --> 00:33:51,360
but after sending a lot of requests and

864
00:33:51,360 --> 00:33:54,679
attacks we might be able to do it

865
00:33:54,679 --> 00:33:57,779
so if the response is not modified and

866
00:33:57,779 --> 00:33:59,279
actually the response for the request

867
00:33:59,279 --> 00:34:02,100
that the victim issued had a sap cache

868
00:34:02,100 --> 00:34:04,980
control the response of course will be

869
00:34:04,980 --> 00:34:09,320
parsed will be sent to the to the client

870
00:34:09,320 --> 00:34:12,239
will be called at this point we had we

871
00:34:12,239 --> 00:34:13,739
hadn't modified day or we hadn't

872
00:34:13,739 --> 00:34:15,599
tampered the response so the cache

873
00:34:15,599 --> 00:34:17,520
Handler will actually create a file

874
00:34:17,520 --> 00:34:20,099
because a cachet objects will be stored

875
00:34:20,099 --> 00:34:21,359
in a file

876
00:34:21,359 --> 00:34:23,099
and in this file it will place some

877
00:34:23,099 --> 00:34:25,320
special healers these headers will tell

878
00:34:25,320 --> 00:34:27,000
information about the response such as

879
00:34:27,000 --> 00:34:28,980
the length of the entire response the

880
00:34:28,980 --> 00:34:30,540
length of the body and some other

881
00:34:30,540 --> 00:34:33,239
information that is not quite important

882
00:34:33,239 --> 00:34:35,399
and if we are able to modify or to

883
00:34:35,399 --> 00:34:37,260
temper the response at this specific

884
00:34:37,260 --> 00:34:40,379
point then the cache Handler will place

885
00:34:40,379 --> 00:34:42,239
the response in this file and it will

886
00:34:42,239 --> 00:34:46,139
not match the headers that it created

887
00:34:46,139 --> 00:34:49,020
so when another client sends a request

888
00:34:49,020 --> 00:34:51,480
to the ICM and to this specific resource

889
00:34:51,480 --> 00:34:53,820
which is corrupted

890
00:34:53,820 --> 00:34:56,639
the request cash will be called it will

891
00:34:56,639 --> 00:34:58,740
find a reference in the cache

892
00:34:58,740 --> 00:35:01,260
and it will use this file to generate a

893
00:35:01,260 --> 00:35:03,119
response and this response will not be

894
00:35:03,119 --> 00:35:05,220
placed in the shared memory as we

895
00:35:05,220 --> 00:35:07,140
already saw but it will be placed in a

896
00:35:07,140 --> 00:35:09,480
hip in a hip buffer

897
00:35:09,480 --> 00:35:12,180
and the length of this buffer will be

898
00:35:12,180 --> 00:35:14,820
set using the healers so in this case it

899
00:35:14,820 --> 00:35:19,320
will be 85 kilo 85 bytes but the actual

900
00:35:19,320 --> 00:35:22,020
response was longer than x85 so we are

901
00:35:22,020 --> 00:35:24,420
going to be able to write in this buffer

902
00:35:24,420 --> 00:35:27,119
and actually obtain a heat buffer

903
00:35:27,119 --> 00:35:29,940
overflow okay and we have proven that it

904
00:35:29,940 --> 00:35:31,579
is possible to modify other data

905
00:35:31,579 --> 00:35:34,320
structures that were in the hip so that

906
00:35:34,320 --> 00:35:36,839
we can override different address

907
00:35:36,839 --> 00:35:39,359
pointers and eventually obtain remote

908
00:35:39,359 --> 00:35:41,940
execution if we are able to defeat a

909
00:35:41,940 --> 00:35:45,079
memory randomization

910
00:35:45,140 --> 00:35:49,680
so sap created two CVS for these

911
00:35:49,680 --> 00:35:51,599
vulnerabilities actually I reported some

912
00:35:51,599 --> 00:35:53,099
other vulnerabilities but these were the

913
00:35:53,099 --> 00:35:55,740
most interesting ones and the first one

914
00:35:55,740 --> 00:35:57,300
was a CBS S10

915
00:35:57,300 --> 00:35:59,940
as Ira approved it's possible to hijack

916
00:35:59,940 --> 00:36:01,980
all clients

917
00:36:01,980 --> 00:36:04,560
and the second one was an 8.1 because

918
00:36:04,560 --> 00:36:06,240
they stated that the attack complexity

919
00:36:06,240 --> 00:36:09,240
was high and the scope was unchanged we

920
00:36:09,240 --> 00:36:11,880
do not agree with that part that is what

921
00:36:11,880 --> 00:36:14,160
sap stated

922
00:36:14,160 --> 00:36:16,980
um and also this is quite critical

923
00:36:16,980 --> 00:36:19,560
because it affects all the saps in the

924
00:36:19,560 --> 00:36:22,020
world we can choose any sap and it will

925
00:36:22,020 --> 00:36:24,720
be vulnerable to both of these attacks

926
00:36:24,720 --> 00:36:27,900
and this includes Java above S4 Hana

927
00:36:27,900 --> 00:36:30,060
which is in the cloud a web dispatcher

928
00:36:30,060 --> 00:36:31,920
which is the load balancer used for most

929
00:36:31,920 --> 00:36:36,180
saps and all any any sap product

930
00:36:36,180 --> 00:36:38,160
they also released two security nodes

931
00:36:38,160 --> 00:36:40,800
and a manual workaround that can be

932
00:36:40,800 --> 00:36:42,599
implemented in both the netweaver and

933
00:36:42,599 --> 00:36:45,180
the web dispatcher and finally we are

934
00:36:45,180 --> 00:36:47,160
navsys created a detection tool that

935
00:36:47,160 --> 00:36:49,440
will allow clients to know if they are

936
00:36:49,440 --> 00:36:52,200
vulnerable to this or not

937
00:36:52,200 --> 00:36:55,759
so finally some conclusions

938
00:36:55,920 --> 00:36:58,200
um it was interesting to see that HTTP

939
00:36:58,200 --> 00:37:00,420
servers are great targets for attackers

940
00:37:00,420 --> 00:37:03,720
because not only they are exposed as we

941
00:37:03,720 --> 00:37:06,300
already know but reverse engineering one

942
00:37:06,300 --> 00:37:09,480
of these components is quite easier than

943
00:37:09,480 --> 00:37:12,180
one might think because remember the

944
00:37:12,180 --> 00:37:14,040
HTTP server must be compliant with the

945
00:37:14,040 --> 00:37:16,560
RFC so we know what the HTTP server is

946
00:37:16,560 --> 00:37:18,839
going to do we can predict what is its

947
00:37:18,839 --> 00:37:22,020
functionality and most HCB servers has

948
00:37:22,020 --> 00:37:24,480
same same functionalities and workflow

949
00:37:24,480 --> 00:37:26,339
even though the internals might be

950
00:37:26,339 --> 00:37:28,800
different and also it's really important

951
00:37:28,800 --> 00:37:30,300
to be able to recognize where the

952
00:37:30,300 --> 00:37:32,220
requests and responses are stored in the

953
00:37:32,220 --> 00:37:34,200
memory so that we know what are we what

954
00:37:34,200 --> 00:37:35,700
are we going to be able to modify and

955
00:37:35,700 --> 00:37:37,200
not

956
00:37:37,200 --> 00:37:39,660
also it was really interesting to see

957
00:37:39,660 --> 00:37:42,000
that it is possible to escalate low

958
00:37:42,000 --> 00:37:43,380
level vulnerabilities that in the past

959
00:37:43,380 --> 00:37:45,900
were not exploitable okay because for

960
00:37:45,900 --> 00:37:47,280
example in the past we were not being

961
00:37:47,280 --> 00:37:48,839
able to we are not going to be able to

962
00:37:48,839 --> 00:37:51,420
split or we are not able to exploit use

963
00:37:51,420 --> 00:37:55,440
after freeze in uh in an HTTP server but

964
00:37:55,440 --> 00:37:59,160
using this Advanced ATP techniques we

965
00:37:59,160 --> 00:38:01,500
are going to be able to of course modify

966
00:38:01,500 --> 00:38:04,020
a invalid cylinder we're going to be

967
00:38:04,020 --> 00:38:06,300
able to modify the application by using

968
00:38:06,300 --> 00:38:09,119
a attack that don't do not rely on HTTP

969
00:38:09,119 --> 00:38:11,400
headers or we are going to be able to

970
00:38:11,400 --> 00:38:14,640
bypass vpns by using DNS rebinding and

971
00:38:14,640 --> 00:38:17,280
create botnets

972
00:38:17,280 --> 00:38:20,579
and finally uh we can see that the

973
00:38:20,579 --> 00:38:22,859
isimar which was the code name for these

974
00:38:22,859 --> 00:38:24,839
vulnerabilities was really important

975
00:38:24,839 --> 00:38:26,640
what they were considered to be really

976
00:38:26,640 --> 00:38:28,020
critical they were addressed by the

977
00:38:28,020 --> 00:38:29,880
cyber security infrastructure Security

978
00:38:29,880 --> 00:38:33,960
Agency of the US and sap stated that

979
00:38:33,960 --> 00:38:36,060
these were probably the worst

980
00:38:36,060 --> 00:38:38,220
vulnerabilities in years

981
00:38:38,220 --> 00:38:40,320
and because it affected all sap

982
00:38:40,320 --> 00:38:42,900
installations and they were accessible

983
00:38:42,900 --> 00:38:45,359
through a really exposed service that

984
00:38:45,359 --> 00:38:47,820
was actually exposed in the internet in

985
00:38:47,820 --> 00:38:51,390
a lot of different companies

986
00:38:51,390 --> 00:38:53,460
[Music]

987
00:38:53,460 --> 00:38:56,460
foreign

988
00:38:58,340 --> 00:39:01,449
[Music]

