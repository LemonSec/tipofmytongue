1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:10,880 --> 00:00:14,340
security expert at Ledger my daily rule

4
00:00:14,340 --> 00:00:15,839
is to evaluate Hardware wallets against

5
00:00:15,839 --> 00:00:17,279
fault injection and search General

6
00:00:17,279 --> 00:00:19,680
attacks and today I'm going to present

7
00:00:19,680 --> 00:00:22,380
unlimited results breaking firmware

8
00:00:22,380 --> 00:00:25,740
encryption of esp32 V3 it's a joint work

9
00:00:25,740 --> 00:00:28,800
between me and Olivier rivo and Adrienne

10
00:00:28,800 --> 00:00:30,980
tier

11
00:00:31,260 --> 00:00:33,780
well why I'm going to to do this

12
00:00:33,780 --> 00:00:36,239
presentation today

13
00:00:36,239 --> 00:00:39,719
I think most of you you know esp32 it's

14
00:00:39,719 --> 00:00:42,000
a very well-known microcontroller it's a

15
00:00:42,000 --> 00:00:44,100
low power SOC

16
00:00:44,100 --> 00:00:46,559
it has been deployed in the market since

17
00:00:46,559 --> 00:00:49,500
several years and espresso actually

18
00:00:49,500 --> 00:00:52,200
announced it's selling like 100 million

19
00:00:52,200 --> 00:00:54,780
devices in the market by 2018.

20
00:00:54,780 --> 00:00:57,000
and what's very important for me is that

21
00:00:57,000 --> 00:00:59,160
it recently it has been deployed as a

22
00:00:59,160 --> 00:01:00,719
main microcontroller

23
00:01:00,719 --> 00:01:03,239
in the hardware wallet called Zed the

24
00:01:03,239 --> 00:01:05,400
vendor is block stream

25
00:01:05,400 --> 00:01:07,500
and if you are going to open the

26
00:01:07,500 --> 00:01:09,000
hardware wallet actually you are going

27
00:01:09,000 --> 00:01:13,080
to find an esp32 V3 chip and also an

28
00:01:13,080 --> 00:01:15,360
external flash memory however the

29
00:01:15,360 --> 00:01:17,580
external flash memory is used to store

30
00:01:17,580 --> 00:01:21,360
the an encrypted firmware however the

31
00:01:21,360 --> 00:01:23,220
firmware encryption key is stored in the

32
00:01:23,220 --> 00:01:25,080
esp32 V3

33
00:01:25,080 --> 00:01:27,840
so my role actually is to evaluate this

34
00:01:27,840 --> 00:01:30,119
Hardware wallet against fault injection

35
00:01:30,119 --> 00:01:32,220
and search channel attacks in order to

36
00:01:32,220 --> 00:01:35,600
extract this key

37
00:01:35,939 --> 00:01:41,340
why esp32v3 not esp32v1 for example by

38
00:01:41,340 --> 00:01:44,939
the way there is no any esp32 V2

39
00:01:44,939 --> 00:01:48,659
so regarding esp32v1 it was attacked by

40
00:01:48,659 --> 00:01:51,899
limited results in 2019

41
00:01:51,899 --> 00:01:53,700
the main idea is that they already

42
00:01:53,700 --> 00:01:55,860
attacked the secure Boot and Flash

43
00:01:55,860 --> 00:01:59,460
encryption mechanisms they used power a

44
00:01:59,460 --> 00:02:00,979
powerful injection

45
00:02:00,979 --> 00:02:04,380
using bar glitches in order to perturb

46
00:02:04,380 --> 00:02:06,719
the effuse protection bits during the

47
00:02:06,719 --> 00:02:09,840
power up and after successful forces

48
00:02:09,840 --> 00:02:13,080
they already obtained the ifuse keys the

49
00:02:13,080 --> 00:02:15,959
firmware encryption and secure boot keys

50
00:02:15,959 --> 00:02:18,180
as a reaction against this attack

51
00:02:18,180 --> 00:02:22,680
expressive announced esp32v3

52
00:02:22,680 --> 00:02:27,120
by 20 2020 and the main idea is to patch

53
00:02:27,120 --> 00:02:28,739
a

54
00:02:28,739 --> 00:02:30,900
the new version against the the attack

55
00:02:30,900 --> 00:02:32,520
of limited results

56
00:02:32,520 --> 00:02:36,239
so the new version esp32v3

57
00:02:36,239 --> 00:02:38,340
has several features

58
00:02:38,340 --> 00:02:42,239
like new secure boot they use a an RSA

59
00:02:42,239 --> 00:02:44,400
based secure boot in order to avoid

60
00:02:44,400 --> 00:02:47,160
storing any private keys inside the

61
00:02:47,160 --> 00:02:49,739
effuse and also as announced by espresso

62
00:02:49,739 --> 00:02:52,500
that the new version contains Contour

63
00:02:52,500 --> 00:02:54,300
measures against fault injection attacks

64
00:02:54,300 --> 00:02:57,980
by hardware and software

65
00:02:58,920 --> 00:03:01,019
well the outline of my presentation

66
00:03:01,019 --> 00:03:03,540
first I'm going to present the security

67
00:03:03,540 --> 00:03:06,599
feature of esp32 V3

68
00:03:06,599 --> 00:03:09,180
and also after that I'm going to to show

69
00:03:09,180 --> 00:03:11,040
you a homemade fault injection setup

70
00:03:11,040 --> 00:03:13,140
that I'm going to use it in order to

71
00:03:13,140 --> 00:03:16,800
evaluate esp32 V1 I mean to reproduce

72
00:03:16,800 --> 00:03:18,420
attack of limited results using

73
00:03:18,420 --> 00:03:20,700
electromagnetic filter injection and

74
00:03:20,700 --> 00:03:23,040
after that applying the same scenario on

75
00:03:23,040 --> 00:03:25,260
esp32v3

76
00:03:25,260 --> 00:03:28,080
and after that I'm going to discover a

77
00:03:28,080 --> 00:03:29,700
new attack path using side Channel

78
00:03:29,700 --> 00:03:32,340
attacks to break the firmware encryption

79
00:03:32,340 --> 00:03:35,220
and then I'm going to to make the attack

80
00:03:35,220 --> 00:03:37,739
practical on a hardware wallet I mean

81
00:03:37,739 --> 00:03:39,420
the jet Hardware wallet that I already

82
00:03:39,420 --> 00:03:41,940
showed previously and I'm going to

83
00:03:41,940 --> 00:03:43,680
terminate by the vendor reply and the

84
00:03:43,680 --> 00:03:45,959
conclusion

85
00:03:45,959 --> 00:03:49,799
so regarding the esp32 security features

86
00:03:49,799 --> 00:03:53,280
well esp32 has a lot of features but let

87
00:03:53,280 --> 00:03:54,959
me concentrate on the security feature

88
00:03:54,959 --> 00:03:57,599
of the chip itself so it has secure boot

89
00:03:57,599 --> 00:04:01,980
it has flash encryption and also 128

90
00:04:01,980 --> 00:04:03,959
bytes of OTP

91
00:04:03,959 --> 00:04:07,140
in order to store some secrets and also

92
00:04:07,140 --> 00:04:09,720
some crypto Hardware accelerators such

93
00:04:09,720 --> 00:04:12,379
as es RSA

94
00:04:12,379 --> 00:04:15,000
random number generators and elliptic

95
00:04:15,000 --> 00:04:17,519
curve as well you can use the ESP tool

96
00:04:17,519 --> 00:04:19,918
in order to activate the above features

97
00:04:19,918 --> 00:04:22,199
and the ESP tool it's an open source

98
00:04:22,199 --> 00:04:24,900
tool which delivered by espressive and

99
00:04:24,900 --> 00:04:27,060
you can find it online on GitHub for

100
00:04:27,060 --> 00:04:28,699
example

101
00:04:28,699 --> 00:04:31,500
well regarding the ifuse organization

102
00:04:31,500 --> 00:04:35,160
the ifus as I told you it's like 128

103
00:04:35,160 --> 00:04:38,759
bytes and it's divided into four slots

104
00:04:38,759 --> 00:04:41,460
for example the first slots the first

105
00:04:41,460 --> 00:04:43,740
slot is used and reserved for the system

106
00:04:43,740 --> 00:04:46,139
for the system purposes in order to

107
00:04:46,139 --> 00:04:48,600
store the setting of the of the chip

108
00:04:48,600 --> 00:04:50,759
itself I mean the the flash encryption

109
00:04:50,759 --> 00:04:52,680
mode the secure boot if it's activated

110
00:04:52,680 --> 00:04:54,660
or not for example and you can find

111
00:04:54,660 --> 00:04:57,240
block one and block 2 in order to store

112
00:04:57,240 --> 00:04:59,820
flash encryption keys and also the

113
00:04:59,820 --> 00:05:02,280
secure boot keys in a row and the last

114
00:05:02,280 --> 00:05:04,560
slot block 3 is used for the user

115
00:05:04,560 --> 00:05:06,120
application itself

116
00:05:06,120 --> 00:05:09,419
well let me say that it's impossible to

117
00:05:09,419 --> 00:05:11,699
to get access by the software on block

118
00:05:11,699 --> 00:05:14,060
one and block two because they are

119
00:05:14,060 --> 00:05:16,919
protected using ifuse protection bits

120
00:05:16,919 --> 00:05:18,180
which are restored in the boot ROM

121
00:05:18,180 --> 00:05:19,639
itself

122
00:05:19,639 --> 00:05:22,500
and uh the only entity which is

123
00:05:22,500 --> 00:05:24,600
responsible for reading those keys

124
00:05:24,600 --> 00:05:28,320
actually is is a hardware of esp32 that

125
00:05:28,320 --> 00:05:32,039
already use this kind of of keys during

126
00:05:32,039 --> 00:05:35,160
the power up in order to whatever to to

127
00:05:35,160 --> 00:05:37,139
perform the flash decryption or to

128
00:05:37,139 --> 00:05:40,560
perform as well as a secure boot

129
00:05:40,560 --> 00:05:43,979
well let me talk about secure Boot and

130
00:05:43,979 --> 00:05:45,780
they have two versions of secure boot

131
00:05:45,780 --> 00:05:47,699
they have secure boot version one for

132
00:05:47,699 --> 00:05:50,160
example so the main idea is that if you

133
00:05:50,160 --> 00:05:53,100
have a firmware the firmware had it has

134
00:05:53,100 --> 00:05:55,740
a good loader and the public key the

135
00:05:55,740 --> 00:05:57,660
main idea is that you have a key which

136
00:05:57,660 --> 00:05:59,940
is stored in Block 2 for example which

137
00:05:59,940 --> 00:06:01,800
is responsible for the secure Boot and

138
00:06:01,800 --> 00:06:04,620
this key is used to encrypt

139
00:06:04,620 --> 00:06:06,800
the bootloader and the public key using

140
00:06:06,800 --> 00:06:09,900
es-256 and after that the output is

141
00:06:09,900 --> 00:06:12,300
hashed using shaft 512 in order to

142
00:06:12,300 --> 00:06:15,060
generate what we call a digest and the

143
00:06:15,060 --> 00:06:18,120
digestive the digest is a store outside

144
00:06:18,120 --> 00:06:21,060
in the in the flash memory and during

145
00:06:21,060 --> 00:06:22,860
the power up the same process is

146
00:06:22,860 --> 00:06:24,960
executed

147
00:06:24,960 --> 00:06:26,699
and after that the comparison is

148
00:06:26,699 --> 00:06:29,580
performed in order to to take the

149
00:06:29,580 --> 00:06:31,560
decision to continue or not based on the

150
00:06:31,560 --> 00:06:33,840
comparison if it's correct or not

151
00:06:33,840 --> 00:06:36,060
well regarding regarding the flash

152
00:06:36,060 --> 00:06:37,259
encryption

153
00:06:37,259 --> 00:06:39,360
as I told you it's a security feature of

154
00:06:39,360 --> 00:06:41,160
esp32

155
00:06:41,160 --> 00:06:44,160
the main idea is to protect the the

156
00:06:44,160 --> 00:06:47,880
firmware which is stored outside in the

157
00:06:47,880 --> 00:06:51,060
external flash from any axis

158
00:06:51,060 --> 00:06:53,639
well as a flash encryption uses block

159
00:06:53,639 --> 00:06:57,060
one for uh for encrypting and decrypting

160
00:06:57,060 --> 00:06:58,440
the Flash content

161
00:06:58,440 --> 00:07:01,199
and in order to encrypt The Flash

162
00:07:01,199 --> 00:07:03,840
they use es decryption and in order to

163
00:07:03,840 --> 00:07:06,479
decrypt The Flash they use es encryption

164
00:07:06,479 --> 00:07:08,880
and the during the power up the flash

165
00:07:08,880 --> 00:07:11,039
decryption for example is performed

166
00:07:11,039 --> 00:07:13,440
however they use something called the

167
00:07:13,440 --> 00:07:16,139
key tweak in order to change the key

168
00:07:16,139 --> 00:07:19,080
every 32 bytes and this key tweak is

169
00:07:19,080 --> 00:07:22,500
like an address dependent so if you know

170
00:07:22,500 --> 00:07:24,240
the address you can generate the key

171
00:07:24,240 --> 00:07:26,520
tweak so at the end you will find it

172
00:07:26,520 --> 00:07:28,979
will be like a constant and it's only

173
00:07:28,979 --> 00:07:30,599
used to change the key of research to

174
00:07:30,599 --> 00:07:31,680
two bytes

175
00:07:31,680 --> 00:07:34,979
the first slot which is is manipulated

176
00:07:34,979 --> 00:07:38,160
from the flesh during the power up

177
00:07:38,160 --> 00:07:40,860
is a bootloader data which is is stored

178
00:07:40,860 --> 00:07:44,819
at address uh one key decimal hexadecim

179
00:07:44,819 --> 00:07:47,099
so you can use the following commands in

180
00:07:47,099 --> 00:07:50,699
order to activate and store uh the flash

181
00:07:50,699 --> 00:07:55,380
encryption key through the ESP tool

182
00:07:55,380 --> 00:07:58,020
theft the attack of limited results

183
00:07:58,020 --> 00:07:59,580
well

184
00:07:59,580 --> 00:08:02,220
as a concentrated on glitching the ifuse

185
00:08:02,220 --> 00:08:04,319
protection bits during the power up you

186
00:08:04,319 --> 00:08:06,419
can see here in the red the already

187
00:08:06,419 --> 00:08:08,940
register support trace the power

188
00:08:08,940 --> 00:08:10,500
consumption Trace during the power up

189
00:08:10,500 --> 00:08:14,220
and in yellow is a voltage as a voltage

190
00:08:14,220 --> 00:08:16,680
source to the to the chip itself you can

191
00:08:16,680 --> 00:08:18,960
find that during the power up they start

192
00:08:18,960 --> 00:08:21,120
to inject some glitches you can see here

193
00:08:21,120 --> 00:08:23,280
the voltage drop and this is the correct

194
00:08:23,280 --> 00:08:26,220
moment that the already glitched the

195
00:08:26,220 --> 00:08:29,160
ifuse protection bits once they already

196
00:08:29,160 --> 00:08:31,500
performed a successful fault after that

197
00:08:31,500 --> 00:08:33,240
they can execute the memory read command

198
00:08:33,240 --> 00:08:35,339
in order to dump the ifuse slots

199
00:08:35,339 --> 00:08:37,440
containing the flash encryption key and

200
00:08:37,440 --> 00:08:40,219
the secure boot

201
00:08:42,000 --> 00:08:44,580
let me talk now about the voltage

202
00:08:44,580 --> 00:08:47,180
injection setup

203
00:08:47,399 --> 00:08:51,060
why we need or why we perform uh fault

204
00:08:51,060 --> 00:08:53,880
faults so the main idea is to perturb

205
00:08:53,880 --> 00:08:55,260
the chip during the execution of

206
00:08:55,260 --> 00:08:58,320
sensitive operations for example if you

207
00:08:58,320 --> 00:09:00,300
if you have a secure boot which is

208
00:09:00,300 --> 00:09:02,120
running you can inject

209
00:09:02,120 --> 00:09:04,620
let me say electromagnetic fault

210
00:09:04,620 --> 00:09:07,260
injection or laser or pole power fault

211
00:09:07,260 --> 00:09:09,779
injection in order to bypass the the

212
00:09:09,779 --> 00:09:12,180
security or the or the signature

213
00:09:12,180 --> 00:09:14,700
verification during the execution of

214
00:09:14,700 --> 00:09:15,899
secure boot

215
00:09:15,899 --> 00:09:18,000
and also if you have an es which is

216
00:09:18,000 --> 00:09:20,519
running you can inject faults during the

217
00:09:20,519 --> 00:09:23,640
execution of the es in order to execute

218
00:09:23,640 --> 00:09:26,040
or to attack the key using a

219
00:09:26,040 --> 00:09:29,540
differential filter analysis for example

220
00:09:32,040 --> 00:09:34,620
well I'm going to concentrate in my

221
00:09:34,620 --> 00:09:36,260
evaluation about

222
00:09:36,260 --> 00:09:39,480
electromagnetic faulty injection and I'm

223
00:09:39,480 --> 00:09:42,660
going to use a homemade fault injection

224
00:09:42,660 --> 00:09:44,880
tool we call it silicon toaster in order

225
00:09:44,880 --> 00:09:47,760
to inject the electromagnetic pulses

226
00:09:47,760 --> 00:09:49,980
the main idea that you have a very high

227
00:09:49,980 --> 00:09:52,500
voltage which is stored in the caps and

228
00:09:52,500 --> 00:09:54,720
this voltage actually is applied to the

229
00:09:54,720 --> 00:09:57,500
or into the electromagnetic

230
00:09:57,500 --> 00:10:00,899
electromagnetic probe here which is like

231
00:10:00,899 --> 00:10:03,120
a coil in order to generate a current

232
00:10:03,120 --> 00:10:05,040
and the current is going to generate an

233
00:10:05,040 --> 00:10:06,779
electromagnetic field and the

234
00:10:06,779 --> 00:10:08,820
electromagnetic field is going to be in

235
00:10:08,820 --> 00:10:10,200
touch with the surface of the chip

236
00:10:10,200 --> 00:10:13,920
trying to generate or to perturb the

237
00:10:13,920 --> 00:10:16,800
chip and trying to inject faults

238
00:10:16,800 --> 00:10:19,320
the tool is able to inject faults up to

239
00:10:19,320 --> 00:10:23,220
one k volts and I'm going to use it for

240
00:10:23,220 --> 00:10:26,420
the evolution

241
00:10:26,580 --> 00:10:28,980
well in order to obtain a very stable

242
00:10:28,980 --> 00:10:32,399
setup we decided to fabricate a BCB

243
00:10:32,399 --> 00:10:34,740
so the main idea is that you have an

244
00:10:34,740 --> 00:10:39,540
esp32 here and on the top of the PCB

245
00:10:39,540 --> 00:10:41,700
and after that there's the external

246
00:10:41,700 --> 00:10:43,920
flash and we select it actually to have

247
00:10:43,920 --> 00:10:47,700
some vdd pins or eyes here in order to

248
00:10:47,700 --> 00:10:50,700
control the value of the vdt during the

249
00:10:50,700 --> 00:10:53,160
experiment and also there is an external

250
00:10:53,160 --> 00:10:55,019
oscillator here in order to control the

251
00:10:55,019 --> 00:10:57,200
clock

252
00:10:57,300 --> 00:10:59,820
well regarding the electromagnetic

253
00:10:59,820 --> 00:11:02,700
faulty injection setup so I'm using a

254
00:11:02,700 --> 00:11:04,440
silicon toaster in order to inject the

255
00:11:04,440 --> 00:11:06,600
electromagnetic pulses and also I'm

256
00:11:06,600 --> 00:11:08,779
using an oscillator here in order to

257
00:11:08,779 --> 00:11:11,940
monitor the power consumption during the

258
00:11:11,940 --> 00:11:15,899
experiment and I'm using the x y z table

259
00:11:15,899 --> 00:11:18,000
here in order to move the Probe on the

260
00:11:18,000 --> 00:11:19,680
surface of the chip

261
00:11:19,680 --> 00:11:21,959
and also I'm using a scaffold which is a

262
00:11:21,959 --> 00:11:26,239
board which is fabricated inside our

263
00:11:28,079 --> 00:11:30,600
the computer

264
00:11:30,600 --> 00:11:34,200
well the dictionary

265
00:11:34,200 --> 00:11:37,140
for the first time I'm trying to

266
00:11:37,140 --> 00:11:41,339
to prove that the ability of of of the

267
00:11:41,339 --> 00:11:42,959
electromagnetic voltage injection tool

268
00:11:42,959 --> 00:11:45,779
in order to inject successful faults so

269
00:11:45,779 --> 00:11:48,839
I'm going to first apply

270
00:11:48,839 --> 00:11:51,000
um fault injection on a glitchable

271
00:11:51,000 --> 00:11:52,920
application on a very simple application

272
00:11:52,920 --> 00:11:57,060
code on esp32v1 the only thing to do

273
00:11:57,060 --> 00:11:57,899
that

274
00:11:57,899 --> 00:12:00,779
the target actually is to is to be sure

275
00:12:00,779 --> 00:12:02,940
that the the tools that I have is

276
00:12:02,940 --> 00:12:03,959
effective

277
00:12:03,959 --> 00:12:06,660
and to keep some parameters in order to

278
00:12:06,660 --> 00:12:08,579
go for the next step so next step of

279
00:12:08,579 --> 00:12:10,320
course is to reproduce the attack of

280
00:12:10,320 --> 00:12:11,459
limited results

281
00:12:11,459 --> 00:12:14,040
and after that I'm going to follow the

282
00:12:14,040 --> 00:12:17,160
same scenario that I did on esp32v1 and

283
00:12:17,160 --> 00:12:20,339
repeat it again on esp62 V3 to see if

284
00:12:20,339 --> 00:12:23,100
there's a difference or not

285
00:12:23,100 --> 00:12:24,660
well let's talk about the

286
00:12:24,660 --> 00:12:26,279
electromagnetic fault injection on

287
00:12:26,279 --> 00:12:29,279
esp62v1

288
00:12:29,279 --> 00:12:31,500
you can see here on the left this is a

289
00:12:31,500 --> 00:12:32,760
glitchable code

290
00:12:32,760 --> 00:12:34,980
there is a loop and the main idea is to

291
00:12:34,980 --> 00:12:38,180
inject a code to

292
00:12:40,500 --> 00:12:43,139
the counter and on the same time I'm

293
00:12:43,139 --> 00:12:45,300
going to to scan the electromagnetic

294
00:12:45,300 --> 00:12:49,279
Probe on the chip surface here

295
00:12:51,360 --> 00:12:54,060
well after scanning all the chip surface

296
00:12:54,060 --> 00:12:57,959
using 500 voltage I mean the is a pulse

297
00:12:57,959 --> 00:13:00,779
value and regarding the polarity of the

298
00:13:00,779 --> 00:13:02,700
of the pulse I mean I'm injecting a

299
00:13:02,700 --> 00:13:05,339
positive polarity and I'm scanning 500

300
00:13:05,339 --> 00:13:08,100
trials per spot and the motor stable is

301
00:13:08,100 --> 00:13:12,839
like to 200 micrometer I found here

302
00:13:12,839 --> 00:13:15,660
upper on the right I found a very

303
00:13:15,660 --> 00:13:17,579
interesting Zone where I obtained

304
00:13:17,579 --> 00:13:20,279
successful faults that I was able to to

305
00:13:20,279 --> 00:13:22,079
skip from the loop so this means that

306
00:13:22,079 --> 00:13:24,300
the fault injection tool that I have is

307
00:13:24,300 --> 00:13:25,740
effective and I can obtain some

308
00:13:25,740 --> 00:13:28,440
successful faults using it so now the

309
00:13:28,440 --> 00:13:30,180
next step is to reproduce now the attack

310
00:13:30,180 --> 00:13:33,899
of limited results on esp62v1

311
00:13:33,899 --> 00:13:35,459
well

312
00:13:35,459 --> 00:13:37,620
the steps is that I followed it's like

313
00:13:37,620 --> 00:13:39,480
the first thing is that you have you

314
00:13:39,480 --> 00:13:41,519
have a firmware you encrypt you store

315
00:13:41,519 --> 00:13:44,279
the firmware encrypted and the external

316
00:13:44,279 --> 00:13:45,360
flash

317
00:13:45,360 --> 00:13:48,899
and after that you enable uh you enables

318
00:13:48,899 --> 00:13:51,660
a firmware encryption through is a

319
00:13:51,660 --> 00:13:54,240
command that I show here and after that

320
00:13:54,240 --> 00:13:55,920
I started to track the power consumption

321
00:13:55,920 --> 00:13:57,800
of the chip during

322
00:13:57,800 --> 00:14:00,779
or while the flash encryption is enabled

323
00:14:00,779 --> 00:14:02,880
I found that

324
00:14:02,880 --> 00:14:04,380
there is a very interesting early

325
00:14:04,380 --> 00:14:08,040
activity here after the power up

326
00:14:08,040 --> 00:14:10,320
that may be very interesting in order to

327
00:14:10,320 --> 00:14:12,120
shoot or to inject faults during this

328
00:14:12,120 --> 00:14:14,220
period why because I make I'm expecting

329
00:14:14,220 --> 00:14:16,459
that the if use fault the ifuse

330
00:14:16,459 --> 00:14:19,139
protection bits are manipulated during

331
00:14:19,139 --> 00:14:21,600
this this time

332
00:14:21,600 --> 00:14:24,959
well so the scenario that I use the I

333
00:14:24,959 --> 00:14:26,700
used only one single filter injection

334
00:14:26,700 --> 00:14:29,399
pulse here it's a count and after that

335
00:14:29,399 --> 00:14:30,839
I'm going to initialize the policy

336
00:14:30,839 --> 00:14:33,300
generator to to deliver like the pulse

337
00:14:33,300 --> 00:14:35,339
switch and also the offset and to

338
00:14:35,339 --> 00:14:37,620
control them and after that I'm going to

339
00:14:37,620 --> 00:14:39,180
restart the chip and the during the

340
00:14:39,180 --> 00:14:41,820
restart I'm going to inject some faults

341
00:14:41,820 --> 00:14:44,339
and in case of a successful fault after

342
00:14:44,339 --> 00:14:46,680
that I'm go I'm going to execute the

343
00:14:46,680 --> 00:14:49,139
read memory command in order to dump the

344
00:14:49,139 --> 00:14:51,560
effuse

345
00:14:52,139 --> 00:14:54,480
surface I already obtained some

346
00:14:54,480 --> 00:14:56,279
successful faults

347
00:14:56,279 --> 00:14:58,560
however I obtained two different

348
00:14:58,560 --> 00:15:01,760
successful faults here you can find

349
00:15:01,760 --> 00:15:04,260
after the experiment log for example

350
00:15:04,260 --> 00:15:07,139
here Loop Number Four you can find this

351
00:15:07,139 --> 00:15:09,060
is the correct key that that I already

352
00:15:09,060 --> 00:15:13,440
stored however in five I flipped the

353
00:15:13,440 --> 00:15:17,519
this key by only one one bit here

354
00:15:17,519 --> 00:15:19,800
why there is only one bit difference

355
00:15:19,800 --> 00:15:22,320
because there is a chance that when I

356
00:15:22,320 --> 00:15:24,240
injected the faulted during the power up

357
00:15:24,240 --> 00:15:27,660
maybe I also corrupted the the value of

358
00:15:27,660 --> 00:15:30,540
the ifus which are manipulated from from

359
00:15:30,540 --> 00:15:33,120
the chip itself so this it's not a

360
00:15:33,120 --> 00:15:35,639
permanent fault actually but it may

361
00:15:35,639 --> 00:15:38,220
happen if you if you already inject a

362
00:15:38,220 --> 00:15:40,920
fault during a certain time during its

363
00:15:40,920 --> 00:15:43,339
power up

364
00:15:43,560 --> 00:15:46,019
so I started to register the board

365
00:15:46,019 --> 00:15:48,899
traces in case of successful faults and

366
00:15:48,899 --> 00:15:50,820
here you can find this is the correct

367
00:15:50,820 --> 00:15:52,800
timing and you can find here the effect

368
00:15:52,800 --> 00:15:55,920
of the electromagnetic uh pulse during

369
00:15:55,920 --> 00:15:58,560
the power up and on the right here you

370
00:15:58,560 --> 00:16:01,199
can find the The Zone where I already

371
00:16:01,199 --> 00:16:04,939
obtained the successful Force

372
00:16:07,199 --> 00:16:11,100
evaluation so I already you injected

373
00:16:11,100 --> 00:16:13,139
successful faults in order to dump the

374
00:16:13,139 --> 00:16:15,060
ifuse reproducing the attack of limited

375
00:16:15,060 --> 00:16:16,380
results

376
00:16:16,380 --> 00:16:20,339
on asp32v1 I used only a single fault

377
00:16:20,339 --> 00:16:22,740
single fault pulse and the success rate

378
00:16:22,740 --> 00:16:26,639
was close to 0.6 percentage

379
00:16:26,639 --> 00:16:28,699
and now lets me

380
00:16:28,699 --> 00:16:31,380
pre-produce or take the same scenario on

381
00:16:31,380 --> 00:16:33,959
esp32 V3

382
00:16:33,959 --> 00:16:36,360
well let me recap the counter measures

383
00:16:36,360 --> 00:16:38,880
that has been added to uh

384
00:16:38,880 --> 00:16:43,279
to esp32 V3 so zero

385
00:16:45,300 --> 00:16:49,199
more es for example so the store only is

386
00:16:49,199 --> 00:16:51,480
public key which is not secret and safe

387
00:16:51,480 --> 00:16:54,660
uses and also the new version is hard is

388
00:16:54,660 --> 00:16:56,040
hardened against faulty injection

389
00:16:56,040 --> 00:16:58,800
attacks and software on the hardware as

390
00:16:58,800 --> 00:17:00,779
announced by expressive and also they

391
00:17:00,779 --> 00:17:02,459
added another features

392
00:17:02,459 --> 00:17:05,220
called uart disable in order to stop the

393
00:17:05,220 --> 00:17:06,660
communication with the bootstrom to

394
00:17:06,660 --> 00:17:08,280
execute this kind of read memory

395
00:17:08,280 --> 00:17:10,760
commands

396
00:17:11,220 --> 00:17:13,140
so the same scenario I have the

397
00:17:13,140 --> 00:17:15,299
glitchable application and I started to

398
00:17:15,299 --> 00:17:16,459
scan again

399
00:17:16,459 --> 00:17:19,500
esp32 V3 chip using the electromagnetic

400
00:17:19,500 --> 00:17:22,260
fault injection

401
00:17:22,260 --> 00:17:25,799
I kept the same attack parameters and I

402
00:17:25,799 --> 00:17:28,199
obtained also a successful fault I'm I

403
00:17:28,199 --> 00:17:31,559
mean trying to skip from the loop of the

404
00:17:31,559 --> 00:17:33,780
glitchable application so I was able to

405
00:17:33,780 --> 00:17:36,120
to skip successfully from this Loop and

406
00:17:36,120 --> 00:17:37,740
you can find here there is a very

407
00:17:37,740 --> 00:17:39,840
interesting Zone that I already obtained

408
00:17:39,840 --> 00:17:43,880
successful faults well this means that

409
00:17:43,880 --> 00:17:47,760
esp62v3 is not equipped with a fault

410
00:17:47,760 --> 00:17:49,980
injection counter measures like for

411
00:17:49,980 --> 00:17:51,539
example glitch detectors or something

412
00:17:51,539 --> 00:17:53,760
like that so the chip doesn't have any

413
00:17:53,760 --> 00:17:55,880
Contour measures against fault injection

414
00:17:55,880 --> 00:17:58,980
but let me now try the attack of the

415
00:17:58,980 --> 00:18:03,900
effus uh on asp32 V3

416
00:18:03,900 --> 00:18:06,179
I followed the same scenario I have a

417
00:18:06,179 --> 00:18:09,480
key I stored it in the fuses I enabled

418
00:18:09,480 --> 00:18:11,580
the firmware flash encryption and I

419
00:18:11,580 --> 00:18:13,980
stored the encrypted flash in the

420
00:18:13,980 --> 00:18:15,660
external memory

421
00:18:15,660 --> 00:18:18,179
and I started to to track the power

422
00:18:18,179 --> 00:18:20,280
consumption and I found that the power

423
00:18:20,280 --> 00:18:22,020
consumption during the power up in case

424
00:18:22,020 --> 00:18:25,380
of esp32 V3 is completely different from

425
00:18:25,380 --> 00:18:27,059
esp32 V1

426
00:18:27,059 --> 00:18:29,220
so you can see now the difference there

427
00:18:29,220 --> 00:18:32,400
there is a three uh different blocks

428
00:18:32,400 --> 00:18:34,980
which are added here

429
00:18:34,980 --> 00:18:37,140
so this means that they don't have the

430
00:18:37,140 --> 00:18:38,460
same boot ROM

431
00:18:38,460 --> 00:18:40,500
they may have some verification blocks

432
00:18:40,500 --> 00:18:42,179
which are added in order to fight

433
00:18:42,179 --> 00:18:44,760
against fault injection attacks well

434
00:18:44,760 --> 00:18:46,860
this means that I need multiple faults

435
00:18:46,860 --> 00:18:50,280
in order to perform a successful attack

436
00:18:50,280 --> 00:18:52,799
so I changed the attack scenario

437
00:18:52,799 --> 00:18:55,140
I try to randomize

438
00:18:55,140 --> 00:18:57,600
the number of faults and also I follow

439
00:18:57,600 --> 00:18:59,340
the same scenario here I initialize the

440
00:18:59,340 --> 00:19:01,559
policy generator and also I restarted

441
00:19:01,559 --> 00:19:03,360
the chip trying to inject faults during

442
00:19:03,360 --> 00:19:05,640
the power up and after that in case of a

443
00:19:05,640 --> 00:19:07,559
successful fault I already I will

444
00:19:07,559 --> 00:19:12,059
execute the if you read memory command

445
00:19:12,059 --> 00:19:15,179
I would like to stress here on not

446
00:19:15,179 --> 00:19:16,980
activating that you are disabled for the

447
00:19:16,980 --> 00:19:19,679
moment okay

448
00:19:19,679 --> 00:19:22,380
well unfortunately I have not obtained

449
00:19:22,380 --> 00:19:24,900
any successful fault the only thing that

450
00:19:24,900 --> 00:19:28,200
I obtained I obtained zeros which is the

451
00:19:28,200 --> 00:19:30,480
case that the success the fault is not

452
00:19:30,480 --> 00:19:32,760
successful or I obtained as a timeout

453
00:19:32,760 --> 00:19:35,100
why I obtained a lot of timeout that

454
00:19:35,100 --> 00:19:36,960
ship got crashed several times because

455
00:19:36,960 --> 00:19:39,120
of I injected electromagnetic faulty

456
00:19:39,120 --> 00:19:42,000
injection several pulses in a row so

457
00:19:42,000 --> 00:19:43,980
this means that the electromagnetic

458
00:19:43,980 --> 00:19:45,900
fault injection is very aggressive to

459
00:19:45,900 --> 00:19:47,940
the chip if you are injecting several

460
00:19:47,940 --> 00:19:51,059
pulses in a row try and the chip got

461
00:19:51,059 --> 00:19:53,880
crashed several times actually so for

462
00:19:53,880 --> 00:19:56,760
the moment I'm I'm like in a situation

463
00:19:56,760 --> 00:19:59,100
that okay I have a new version of the

464
00:19:59,100 --> 00:20:00,000
chip

465
00:20:00,000 --> 00:20:02,700
it seems that esp32v3 has a different

466
00:20:02,700 --> 00:20:05,160
boot drum that contains counter measures

467
00:20:05,160 --> 00:20:07,440
against fault injection attacks and

468
00:20:07,440 --> 00:20:10,100
multiple fault faults may be needed but

469
00:20:10,100 --> 00:20:12,360
unfortunately using electromagnetic

470
00:20:12,360 --> 00:20:14,940
faulty injection several pulses are very

471
00:20:14,940 --> 00:20:16,140
aggressive to this achievement I

472
00:20:16,140 --> 00:20:19,440
obtained a lot of time out so I have to

473
00:20:19,440 --> 00:20:21,000
find another attack scenario or another

474
00:20:21,000 --> 00:20:23,660
attack path

475
00:20:23,820 --> 00:20:26,520
well during the the investigation of the

476
00:20:26,520 --> 00:20:28,980
ifuse attack I started to look at the

477
00:20:28,980 --> 00:20:31,500
documents of expressive trying to find

478
00:20:31,500 --> 00:20:34,320
something different to do so I just

479
00:20:34,320 --> 00:20:36,299
found that they didn't talk about side

480
00:20:36,299 --> 00:20:38,700
Channel attacks there is no any counter

481
00:20:38,700 --> 00:20:41,400
measure so maybe if I'm going to switch

482
00:20:41,400 --> 00:20:43,500
the text scenario to side Channel

483
00:20:43,500 --> 00:20:45,419
attacks and targeting The Flash

484
00:20:45,419 --> 00:20:48,419
decryption maybe I'm going to gain

485
00:20:48,419 --> 00:20:51,299
well so it's a motivation for me to have

486
00:20:51,299 --> 00:20:53,760
a chip that which already batched

487
00:20:53,760 --> 00:20:56,340
and to find another attack scenario so

488
00:20:56,340 --> 00:20:59,039
what I'm I I have been thinking to do is

489
00:20:59,039 --> 00:21:00,960
to Target The Flash encryption

490
00:21:00,960 --> 00:21:03,840
decryption during the power up

491
00:21:03,840 --> 00:21:06,360
and after that if I will do that

492
00:21:06,360 --> 00:21:08,880
successfully I can control the flash

493
00:21:08,880 --> 00:21:11,280
content and after that I can perform

494
00:21:11,280 --> 00:21:13,320
what we call correlation power analysis

495
00:21:13,320 --> 00:21:16,080
in order to attack the flesh encryption

496
00:21:16,080 --> 00:21:18,299
or decryption key

497
00:21:18,299 --> 00:21:20,419
but before

498
00:21:20,419 --> 00:21:23,160
describing the attack in detail let me

499
00:21:23,160 --> 00:21:25,919
stress on some search channel basics

500
00:21:25,919 --> 00:21:28,140
for example like leakage detection

501
00:21:28,140 --> 00:21:30,240
so why we need leakage detection so

502
00:21:30,240 --> 00:21:32,640
assume that you have an es and the es is

503
00:21:32,640 --> 00:21:35,820
running on on on on a chip

504
00:21:35,820 --> 00:21:37,679
and the power consumption of the chip

505
00:21:37,679 --> 00:21:39,600
for example is very low and you are not

506
00:21:39,600 --> 00:21:42,419
able to identify the rounds of the es so

507
00:21:42,419 --> 00:21:44,400
it's better to perform this kind of of

508
00:21:44,400 --> 00:21:46,620
statistical tools like leakage detection

509
00:21:46,620 --> 00:21:49,559
in order to localize exactly where is

510
00:21:49,559 --> 00:21:50,820
the ES

511
00:21:50,820 --> 00:21:53,100
so we use it actually to reduce the time

512
00:21:53,100 --> 00:21:54,419
of the evaluation

513
00:21:54,419 --> 00:21:57,419
and there are several techniques in the

514
00:21:57,419 --> 00:21:59,700
literature that you can find for example

515
00:21:59,700 --> 00:22:03,059
the SNR the signal to noise ratio in icv

516
00:22:03,059 --> 00:22:05,400
or the t-test for example here I'm I'm

517
00:22:05,400 --> 00:22:07,919
going to use SNR signal to noise ratio

518
00:22:07,919 --> 00:22:11,820
that you can uh use it using the for the

519
00:22:11,820 --> 00:22:14,220
following formula here where X is the

520
00:22:14,220 --> 00:22:17,039
real trades real portraits and Y is a

521
00:22:17,039 --> 00:22:18,900
label uh

522
00:22:18,900 --> 00:22:21,600
of the value

523
00:22:21,600 --> 00:22:23,640
regarding the correlation power analysis

524
00:22:23,640 --> 00:22:25,320
it's a it's a very well known side

525
00:22:25,320 --> 00:22:26,520
Channel attack

526
00:22:26,520 --> 00:22:28,679
and the main idea is that for example if

527
00:22:28,679 --> 00:22:30,600
you have an es or you have a crypto

528
00:22:30,600 --> 00:22:32,400
operation and when you measure the power

529
00:22:32,400 --> 00:22:34,620
consumption during the execution of this

530
00:22:34,620 --> 00:22:36,840
crypto operation the power consumption

531
00:22:36,840 --> 00:22:39,059
is like a key dependent so this means

532
00:22:39,059 --> 00:22:39,780
that

533
00:22:39,780 --> 00:22:42,299
if you have an es and you are going to

534
00:22:42,299 --> 00:22:44,280
register the power consumption traces

535
00:22:44,280 --> 00:22:46,559
during the execution of this es you can

536
00:22:46,559 --> 00:22:49,020
build an offline model for example

537
00:22:49,020 --> 00:22:52,500
trying to assume all the keys if you are

538
00:22:52,500 --> 00:22:54,900
targeting one byte of the key so you are

539
00:22:54,900 --> 00:22:57,720
going to have a 256 assumptions of the

540
00:22:57,720 --> 00:22:59,400
key and after that the correct

541
00:22:59,400 --> 00:23:01,380
assumption is going to give the maximum

542
00:23:01,380 --> 00:23:04,740
correlation between the model and the

543
00:23:04,740 --> 00:23:07,380
measurement itself well after the model

544
00:23:07,380 --> 00:23:09,960
you can use several leakage leakage

545
00:23:09,960 --> 00:23:11,940
models such as Heming weight or Hamming

546
00:23:11,940 --> 00:23:13,679
distance for example and if you are

547
00:23:13,679 --> 00:23:16,440
targeting the yes we prefer we always

548
00:23:16,440 --> 00:23:19,020
prefer to perform the Hamming weight on

549
00:23:19,020 --> 00:23:21,360
the Xbox's output of the Xbox because we

550
00:23:21,360 --> 00:23:23,460
we believe that the Xbox is the most

551
00:23:23,460 --> 00:23:25,320
consuming part during the execution of

552
00:23:25,320 --> 00:23:27,419
the ES

553
00:23:27,419 --> 00:23:30,419
so China Tech setup so what I need for

554
00:23:30,419 --> 00:23:31,620
the moment I need a high-end

555
00:23:31,620 --> 00:23:33,900
oscilloscope in order to capture the

556
00:23:33,900 --> 00:23:36,360
power traces during the power up

557
00:23:36,360 --> 00:23:39,960
and also I have an esp32 chip on the top

558
00:23:39,960 --> 00:23:42,659
of scaffold board and after that I'm

559
00:23:42,659 --> 00:23:44,820
going to enable The Flash encryption

560
00:23:44,820 --> 00:23:47,100
mechanism

561
00:23:47,100 --> 00:23:49,679
let me recap again what happens during

562
00:23:49,679 --> 00:23:52,020
the flash encryption so it's used to

563
00:23:52,020 --> 00:23:54,539
protect the external memory

564
00:23:54,539 --> 00:23:56,700
and there is a key which is stored in

565
00:23:56,700 --> 00:23:59,220
Block one which is used for encrypting

566
00:23:59,220 --> 00:24:00,780
and decrypting the Flash

567
00:24:00,780 --> 00:24:03,480
and this key is tweaked every 32 bytes

568
00:24:03,480 --> 00:24:06,120
however the first address which is

569
00:24:06,120 --> 00:24:08,220
manipulated from the external flash is

570
00:24:08,220 --> 00:24:11,039
address 1K which is a bootloader which

571
00:24:11,039 --> 00:24:13,740
is stored in the external flash so this

572
00:24:13,740 --> 00:24:16,980
means that if I can control the the

573
00:24:16,980 --> 00:24:19,860
address which is uh which is like a

574
00:24:19,860 --> 00:24:21,780
bootloader it's external flash and then

575
00:24:21,780 --> 00:24:25,380
I can Target the the firmware decryption

576
00:24:25,380 --> 00:24:27,360
during the power up I can gain and I can

577
00:24:27,360 --> 00:24:31,760
perform this kind of Channel attacks

578
00:24:32,280 --> 00:24:36,179
well I started to to look at the power

579
00:24:36,179 --> 00:24:39,000
consumption during during the power up

580
00:24:39,000 --> 00:24:41,880
while the firmware encryption is is

581
00:24:41,880 --> 00:24:44,400
activated so you can find here in red

582
00:24:44,400 --> 00:24:46,679
the power consumption of the chip

583
00:24:46,679 --> 00:24:49,980
and in yellow I started to spy on the

584
00:24:49,980 --> 00:24:53,039
SPI clock of the external flash in order

585
00:24:53,039 --> 00:24:55,500
to see where the data is manipulated

586
00:24:55,500 --> 00:24:58,320
because as I told you the first slot

587
00:24:58,320 --> 00:25:00,179
which is manipulated is the bootloader

588
00:25:00,179 --> 00:25:02,880
which is stored at address 1K so you can

589
00:25:02,880 --> 00:25:05,039
see here there are two slots flash

590
00:25:05,039 --> 00:25:08,659
encryption one I mean the communication

591
00:25:08,659 --> 00:25:12,000
one and also communication too and after

592
00:25:12,000 --> 00:25:16,200
that there are two zones A and B so for

593
00:25:16,200 --> 00:25:17,520
the moment

594
00:25:17,520 --> 00:25:20,220
the first slot of the bootloader I mean

595
00:25:20,220 --> 00:25:22,100
the first 32 bytes are manipulated

596
00:25:22,100 --> 00:25:26,340
whether in a or in B zone so in order to

597
00:25:26,340 --> 00:25:30,539
know exactly where the the 32 bytes are

598
00:25:30,539 --> 00:25:33,059
manipulated I am going to perform an SNR

599
00:25:33,059 --> 00:25:36,120
on the value of the bootloader itself so

600
00:25:36,120 --> 00:25:38,640
I'm going to follow the scenario I have

601
00:25:38,640 --> 00:25:39,779
some

602
00:25:39,779 --> 00:25:42,059
some random 32 bytes for example to

603
00:25:42,059 --> 00:25:43,440
generate and after that I'm going to

604
00:25:43,440 --> 00:25:45,659
raise the Flash and write

605
00:25:45,659 --> 00:25:48,659
is a bytes on the flash at address

606
00:25:48,659 --> 00:25:51,539
one key this hexadecimal and after that

607
00:25:51,539 --> 00:25:54,120
I'm going to restart the chip and then

608
00:25:54,120 --> 00:25:57,620
capture a Power Trace

609
00:25:57,659 --> 00:26:00,059
well I started to look at Zone a for

610
00:26:00,059 --> 00:26:02,880
example and running the SNR on the on

611
00:26:02,880 --> 00:26:04,799
the bootloader values

612
00:26:04,799 --> 00:26:07,620
and it seems that the SNR curve is here

613
00:26:07,620 --> 00:26:11,100
the 32 values of the of the of the of

614
00:26:11,100 --> 00:26:13,440
the bootloader you can find here the SNR

615
00:26:13,440 --> 00:26:16,140
is very noisy so this means that

616
00:26:16,140 --> 00:26:16,799
um

617
00:26:16,799 --> 00:26:19,380
the first 32 bytes are not manipulated

618
00:26:19,380 --> 00:26:21,120
during the Zone actually

619
00:26:21,120 --> 00:26:24,299
and after that I tried to to do the same

620
00:26:24,299 --> 00:26:27,360
but around Zoom B for example so I find

621
00:26:27,360 --> 00:26:28,380
a very

622
00:26:28,380 --> 00:26:33,320
a very clear SNR here you can find a 32

623
00:26:33,320 --> 00:26:37,620
Peaks that means that the values the 32

624
00:26:37,620 --> 00:26:40,080
bytes of the bootloader are manipulated

625
00:26:40,080 --> 00:26:43,740
here in Zoom B so this means that after

626
00:26:43,740 --> 00:26:46,140
manipulating the first slot from the

627
00:26:46,140 --> 00:26:48,059
bootloader so this means that the flash

628
00:26:48,059 --> 00:26:51,480
decryption is performed just after

629
00:26:51,480 --> 00:26:53,360
in order to

630
00:26:53,360 --> 00:26:57,000
know where is the es exactly performing

631
00:26:57,000 --> 00:26:59,340
you can see that I have a 32 bytes are

632
00:26:59,340 --> 00:27:03,000
manipulated from uh from The Flash

633
00:27:03,000 --> 00:27:05,940
are divided into 16 bytes each one and

634
00:27:05,940 --> 00:27:07,559
after that there is an es which is

635
00:27:07,559 --> 00:27:10,020
running two times in order to decrypt

636
00:27:10,020 --> 00:27:12,960
The Flash so I started to

637
00:27:12,960 --> 00:27:13,620
um

638
00:27:13,620 --> 00:27:16,860
to trigger where the ciphertext of the

639
00:27:16,860 --> 00:27:19,679
first slot and the second slot is the

640
00:27:19,679 --> 00:27:21,840
ciphertext are manipulated where exactly

641
00:27:21,840 --> 00:27:24,840
so now I can see that okay I have the

642
00:27:24,840 --> 00:27:27,539
SNL on the plain text in the zoom and

643
00:27:27,539 --> 00:27:29,940
also I have for example the ciphertext

644
00:27:29,940 --> 00:27:32,100
the SNL on the ciphertext so in between

645
00:27:32,100 --> 00:27:34,260
there will be the ES

646
00:27:34,260 --> 00:27:37,320
so I targeted the SNR of the first slot

647
00:27:37,320 --> 00:27:39,480
of the ciphertext I find there are some

648
00:27:39,480 --> 00:27:43,740
bytes which are here so this means that

649
00:27:43,740 --> 00:27:47,340
the es encryption of the first slot are

650
00:27:47,340 --> 00:27:49,140
executed just before

651
00:27:49,140 --> 00:27:53,279
and also I I repeated the same to Target

652
00:27:53,279 --> 00:27:57,360
the snare of the of the last 16 bytes of

653
00:27:57,360 --> 00:27:59,039
the bootloader which is a store that

654
00:27:59,039 --> 00:28:03,179
address one key here so this means that

655
00:28:03,179 --> 00:28:05,880
before the zones there is the es which

656
00:28:05,880 --> 00:28:08,400
is executed so now I'm pretty sure about

657
00:28:08,400 --> 00:28:12,419
the es where it's manipulated I mean the

658
00:28:12,419 --> 00:28:14,880
es for example of the second part of the

659
00:28:14,880 --> 00:28:17,460
bootloader so it may be manipulated here

660
00:28:17,460 --> 00:28:19,440
actually so I can perform the side

661
00:28:19,440 --> 00:28:22,080
channel here

662
00:28:22,080 --> 00:28:23,760
well

663
00:28:23,760 --> 00:28:25,320
for the moment

664
00:28:25,320 --> 00:28:26,880
I don't have the ability to store

665
00:28:26,880 --> 00:28:29,220
several keys and change the key every

666
00:28:29,220 --> 00:28:32,400
time on the OTP because it's like on OTP

667
00:28:32,400 --> 00:28:35,880
so I won't be able to to know where the

668
00:28:35,880 --> 00:28:38,640
intermediate values of of the years are

669
00:28:38,640 --> 00:28:41,779
manipulated but in order to be sure from

670
00:28:41,779 --> 00:28:44,159
the time zone of the execution of the

671
00:28:44,159 --> 00:28:45,960
years I started to reverse the results

672
00:28:45,960 --> 00:28:48,600
of the CPA I know for example history

673
00:28:48,600 --> 00:28:51,720
and I started to

674
00:28:51,720 --> 00:28:54,240
to Target the history to run correlation

675
00:28:54,240 --> 00:28:56,340
power analysis and to see the maximum

676
00:28:56,340 --> 00:28:58,919
correlation of the Q3 for example where

677
00:28:58,919 --> 00:29:01,500
I can find the maximum Peak so if I can

678
00:29:01,500 --> 00:29:03,179
find the maximum peak of the correct key

679
00:29:03,179 --> 00:29:05,840
this means that yes this zone is the es

680
00:29:05,840 --> 00:29:09,500
where uh where's for example the second

681
00:29:09,500 --> 00:29:11,880
bootloader slot are encrypted during

682
00:29:11,880 --> 00:29:15,480
this Zoom so I found several maximum

683
00:29:15,480 --> 00:29:17,340
peaks of K3 for example the correct

684
00:29:17,340 --> 00:29:19,440
history here one

685
00:29:19,440 --> 00:29:22,260
two and three so now I'm pretty sure

686
00:29:22,260 --> 00:29:25,860
that the es is executed here but

687
00:29:25,860 --> 00:29:28,380
the problems that I have now is that I

688
00:29:28,380 --> 00:29:30,960
already okay I I managed to get 100K

689
00:29:30,960 --> 00:29:33,419
traces but using the external flash

690
00:29:33,419 --> 00:29:36,299
every time I write and erase uh there is

691
00:29:36,299 --> 00:29:38,700
The Flash writing and erasing limitation

692
00:29:38,700 --> 00:29:41,880
so I'm I'm just limited with 100K traces

693
00:29:41,880 --> 00:29:44,940
so every time I have to uh I have to

694
00:29:44,940 --> 00:29:47,159
remove the remove the Flash and solder

695
00:29:47,159 --> 00:29:49,080
another another Flash and I found there

696
00:29:49,080 --> 00:29:50,700
is uh there's a certain difference

697
00:29:50,700 --> 00:29:52,980
between the behavior because of the

698
00:29:52,980 --> 00:29:55,880
noise that that may be generated from

699
00:29:55,880 --> 00:30:00,120
changing the flesh every time so we took

700
00:30:00,120 --> 00:30:02,279
the decision actually in order to to

701
00:30:02,279 --> 00:30:04,980
make a flash emulator I mean to to store

702
00:30:04,980 --> 00:30:07,380
the 32 bytes the random 32 bytes on

703
00:30:07,380 --> 00:30:09,720
shift register on a scaffold and deliver

704
00:30:09,720 --> 00:30:12,539
it to the MCU during the power up so in

705
00:30:12,539 --> 00:30:14,220
this case I will be able to register

706
00:30:14,220 --> 00:30:17,480
unlimited traces

707
00:30:17,640 --> 00:30:20,220
well when I removed the Flash and I used

708
00:30:20,220 --> 00:30:23,039
the flash Emirate emulator I was able to

709
00:30:23,039 --> 00:30:25,559
to find and improve actually the signal

710
00:30:25,559 --> 00:30:27,659
to noise ratio of the of the power

711
00:30:27,659 --> 00:30:28,860
consumption

712
00:30:28,860 --> 00:30:30,360
and you can find here for example

713
00:30:30,360 --> 00:30:33,720
several Power traces which are uh

714
00:30:33,720 --> 00:30:36,779
which are up to to each other's and what

715
00:30:36,779 --> 00:30:38,460
I used here I used a very simple

716
00:30:38,460 --> 00:30:40,980
alignment to in order to align them to

717
00:30:40,980 --> 00:30:42,720
to be ready for performing this kind of

718
00:30:42,720 --> 00:30:45,120
correlation power analysis

719
00:30:45,120 --> 00:30:47,820
and I started to track history the

720
00:30:47,820 --> 00:30:50,460
correct history for example so I found

721
00:30:50,460 --> 00:30:52,799
here this is a maximum correlation of

722
00:30:52,799 --> 00:30:54,720
the correct key I mean Q3 you can find

723
00:30:54,720 --> 00:30:57,480
it's a it's a there's a very big

724
00:30:57,480 --> 00:30:59,039
difference between the correct key and

725
00:30:59,039 --> 00:31:01,260
other key assumptions so this means that

726
00:31:01,260 --> 00:31:03,000
I'm able to perform a correlation power

727
00:31:03,000 --> 00:31:06,059
analysis here successfully well

728
00:31:06,059 --> 00:31:08,399
regarding the model

729
00:31:08,399 --> 00:31:10,860
uh the leakage model that I used I used

730
00:31:10,860 --> 00:31:13,500
the Hamming weight for the for the first

731
00:31:13,500 --> 00:31:15,240
round and for the second round I use the

732
00:31:15,240 --> 00:31:17,460
Hamming distance between the two boxes

733
00:31:17,460 --> 00:31:19,220
of the first round and the second round

734
00:31:19,220 --> 00:31:22,919
and and actually this this kind of tweak

735
00:31:22,919 --> 00:31:26,159
to find the model of the second round it

736
00:31:26,159 --> 00:31:28,679
helped me to to attack some keys that I

737
00:31:28,679 --> 00:31:30,480
already I was not able to attack them

738
00:31:30,480 --> 00:31:33,840
using the normal Hamming weight model

739
00:31:33,840 --> 00:31:36,120
like the first round otherwise you are

740
00:31:36,120 --> 00:31:37,980
going to find three keys which are not

741
00:31:37,980 --> 00:31:40,559
very well uh

742
00:31:40,559 --> 00:31:43,020
attacked successfully so you have to do

743
00:31:43,020 --> 00:31:44,940
some Brute Force attacks for example in

744
00:31:44,940 --> 00:31:47,520
order to attack those keys

745
00:31:47,520 --> 00:31:49,980
well so now I was able to collect more

746
00:31:49,980 --> 00:31:52,820
traces I was able to for example to get

747
00:31:52,820 --> 00:31:56,760
2 million traces so I got I got like 2

748
00:31:56,760 --> 00:31:58,620
million traces I aligned with them and I

749
00:31:58,620 --> 00:32:02,279
started to uh to to perform what we call

750
00:32:02,279 --> 00:32:04,620
a key rank in order to measure the

751
00:32:04,620 --> 00:32:07,320
success of the uh of the attack I mean

752
00:32:07,320 --> 00:32:08,880
the key rank when you increase number of

753
00:32:08,880 --> 00:32:11,340
traces the correct key should goes to

754
00:32:11,340 --> 00:32:13,020
one this means this is the correct key

755
00:32:13,020 --> 00:32:16,620
and I was able to attack all the keys

756
00:32:16,620 --> 00:32:19,380
except key zero for example within like

757
00:32:19,380 --> 00:32:22,380
400k traces however if you would like to

758
00:32:22,380 --> 00:32:24,360
attack k0 and you don't like to brute

759
00:32:24,360 --> 00:32:25,860
force it you have to wait for example

760
00:32:25,860 --> 00:32:28,559
for uh two million traces in order to

761
00:32:28,559 --> 00:32:31,080
attack it successfully

762
00:32:31,080 --> 00:32:33,059
well for the moment

763
00:32:33,059 --> 00:32:34,679
I have to also

764
00:32:34,679 --> 00:32:37,880
activate the other security features of

765
00:32:37,880 --> 00:32:41,460
esp32 V3 like secure Boot and uart

766
00:32:41,460 --> 00:32:44,700
disable and for me actually this kind of

767
00:32:44,700 --> 00:32:47,220
security features are not very important

768
00:32:47,220 --> 00:32:49,980
because a secure boot is already

769
00:32:49,980 --> 00:32:51,899
executed after the flash decryption so

770
00:32:51,899 --> 00:32:55,020
the first the first operation that which

771
00:32:55,020 --> 00:32:57,360
is performed is The Flash encryption and

772
00:32:57,360 --> 00:32:59,700
also for the UR disabled here we don't

773
00:32:59,700 --> 00:33:01,320
care about you all disabled because we

774
00:33:01,320 --> 00:33:02,940
we are not communicating with the chip

775
00:33:02,940 --> 00:33:05,159
uh with the boot ROM of the chip in

776
00:33:05,159 --> 00:33:06,659
order to execute this kind of read

777
00:33:06,659 --> 00:33:10,020
memory command because I'm using uh the

778
00:33:10,020 --> 00:33:12,840
flash emulator

779
00:33:12,840 --> 00:33:15,539
so after activating all the security

780
00:33:15,539 --> 00:33:18,059
features I was able to attack all the

781
00:33:18,059 --> 00:33:19,380
keys

782
00:33:19,380 --> 00:33:21,779
all the keys of firmware encryption that

783
00:33:21,779 --> 00:33:23,700
used for firmware encryptions and 32

784
00:33:23,700 --> 00:33:26,220
bytes of the key as I told you there is

785
00:33:26,220 --> 00:33:28,440
only key zero here which is not stable

786
00:33:28,440 --> 00:33:31,799
but you have to wait for more traces up

787
00:33:31,799 --> 00:33:33,539
to one one million and a half for

788
00:33:33,539 --> 00:33:35,720
example to to get a very stable attack

789
00:33:35,720 --> 00:33:39,059
or to Brute Force risky and this is very

790
00:33:39,059 --> 00:33:40,559
easy actually

791
00:33:40,559 --> 00:33:43,740
so it was a practical attack now so I

792
00:33:43,740 --> 00:33:45,419
started to invest the attack results

793
00:33:45,419 --> 00:33:49,080
that I obtained in order to uh to attack

794
00:33:49,080 --> 00:33:51,480
the hardware wallet that I mentioned it

795
00:33:51,480 --> 00:33:53,460
at the beginning which is Jed wallet

796
00:33:53,460 --> 00:33:56,220
it's a block Stream So as I told you

797
00:33:56,220 --> 00:33:58,320
that Z is an open source and open

798
00:33:58,320 --> 00:34:00,720
Hardware wallet unfortunately it doesn't

799
00:34:00,720 --> 00:34:03,539
store the pin inside the MCU itself the

800
00:34:03,539 --> 00:34:06,720
pin is is verified on the server of

801
00:34:06,720 --> 00:34:08,639
block stream

802
00:34:08,639 --> 00:34:11,760
so the only thing that I can perform now

803
00:34:11,760 --> 00:34:14,339
is the FL the

804
00:34:14,339 --> 00:34:16,980
the external flash it has a public key

805
00:34:16,980 --> 00:34:18,839
and a private key of the user that can

806
00:34:18,839 --> 00:34:20,940
communicate with a server of block

807
00:34:20,940 --> 00:34:24,359
Stream So if I am able to uh

808
00:34:24,359 --> 00:34:26,760
if I'm able to attack the private key of

809
00:34:26,760 --> 00:34:28,500
the user this means that I can clone the

810
00:34:28,500 --> 00:34:32,359
device and inject some back doors

811
00:34:34,080 --> 00:34:36,359
so what I did actually is just to remove

812
00:34:36,359 --> 00:34:41,280
the esp32 from V3 from the from the red

813
00:34:41,280 --> 00:34:44,580
wallet and plug it inside my setup just

814
00:34:44,580 --> 00:34:46,859
solder it in on the PCB and it start to

815
00:34:46,859 --> 00:34:48,839
repeat the experiment and I was able to

816
00:34:48,839 --> 00:34:50,820
dump all the keys

817
00:34:50,820 --> 00:34:54,960
as I told you within like 400 kit races

818
00:34:54,960 --> 00:34:57,300
I have all the keys except key zero

819
00:34:57,300 --> 00:35:01,040
which can be brought forced easily

820
00:35:01,380 --> 00:35:03,780
so now you can find that this is the

821
00:35:03,780 --> 00:35:06,060
encrypted firmware of that and I use the

822
00:35:06,060 --> 00:35:07,500
keys that I already dumped by side

823
00:35:07,500 --> 00:35:10,079
Channel attack in order to decrypt and I

824
00:35:10,079 --> 00:35:11,820
was able to obtain the private key of

825
00:35:11,820 --> 00:35:13,740
the user that which is used for the

826
00:35:13,740 --> 00:35:15,060
communication with the block stream

827
00:35:15,060 --> 00:35:16,800
server

828
00:35:16,800 --> 00:35:19,020
so now I can clone the wallet I can

829
00:35:19,020 --> 00:35:20,460
inject the back door for example to

830
00:35:20,460 --> 00:35:22,320
perform transaction to substituted

831
00:35:22,320 --> 00:35:23,579
addresses

832
00:35:23,579 --> 00:35:27,380
what we call like even made attack

833
00:35:29,880 --> 00:35:32,040
let me talk about the vendor reply and

834
00:35:32,040 --> 00:35:34,500
the conclusion

835
00:35:34,500 --> 00:35:36,660
I started to communicate with espressive

836
00:35:36,660 --> 00:35:39,780
in October last year

837
00:35:39,780 --> 00:35:42,900
and we started to to talk each other

838
00:35:42,900 --> 00:35:46,140
about the counter measures and how they

839
00:35:46,140 --> 00:35:49,140
can improve the product actually and in

840
00:35:49,140 --> 00:35:51,000
may they published an a security

841
00:35:51,000 --> 00:35:53,460
advisory about the attack and the

842
00:35:53,460 --> 00:35:55,619
conclusion of the security advisory is

843
00:35:55,619 --> 00:35:57,900
that this attack is applicable to all

844
00:35:57,900 --> 00:36:00,480
esp32 chips in the market

845
00:36:00,480 --> 00:36:04,820
including esp32 V3 and period versions

846
00:36:04,820 --> 00:36:08,460
esp32 S2 C3 S3

847
00:36:08,460 --> 00:36:11,820
well and unfortunately they won't be

848
00:36:11,820 --> 00:36:13,140
able to patch this kind of

849
00:36:13,140 --> 00:36:15,060
vulnerabilities what they have to do is

850
00:36:15,060 --> 00:36:16,740
to change the Silicon

851
00:36:16,740 --> 00:36:19,079
and and actually in their security

852
00:36:19,079 --> 00:36:21,780
advisory they wrote that the future

853
00:36:21,780 --> 00:36:24,240
products of espresso food contain this

854
00:36:24,240 --> 00:36:26,099
kind of Contour measures against side

855
00:36:26,099 --> 00:36:28,820
Channel attacks

856
00:36:29,220 --> 00:36:31,859
so let me conclude

857
00:36:31,859 --> 00:36:35,400
you can see that I already presented a

858
00:36:35,400 --> 00:36:38,700
a deep Hardware evaluation for asp32 V3

859
00:36:38,700 --> 00:36:40,680
using electromagnetic filter injection

860
00:36:40,680 --> 00:36:42,900
and side Channel attacks so by

861
00:36:42,900 --> 00:36:45,300
experimental results I proved that esp32

862
00:36:45,300 --> 00:36:48,240
has a hardened boot ROM against faulty

863
00:36:48,240 --> 00:36:50,579
injection attacks

864
00:36:50,579 --> 00:36:52,619
and also

865
00:36:52,619 --> 00:36:54,960
when I found that I am not able to

866
00:36:54,960 --> 00:36:57,119
attack the trip using electromagnetic

867
00:36:57,119 --> 00:36:59,220
fault injection I changed the scenario

868
00:36:59,220 --> 00:37:00,900
the text scenario to side Channel

869
00:37:00,900 --> 00:37:03,599
attacks and I was able to dump the

870
00:37:03,599 --> 00:37:05,220
overall key which is used for the

871
00:37:05,220 --> 00:37:07,020
firmware encryption

872
00:37:07,020 --> 00:37:09,900
using like 400k traces

873
00:37:09,900 --> 00:37:12,180
and the attack is generic and works on

874
00:37:12,180 --> 00:37:15,780
all the products of espressive

875
00:37:15,780 --> 00:37:18,119
and well at the end I would like just to

876
00:37:18,119 --> 00:37:19,800
say that protecting against faulty

877
00:37:19,800 --> 00:37:21,839
injection is not sufficient and also the

878
00:37:21,839 --> 00:37:23,579
vendor should consider this kind of

879
00:37:23,579 --> 00:37:26,220
attacks and to combine them with the

880
00:37:26,220 --> 00:37:28,320
faulty injection so this means that if

881
00:37:28,320 --> 00:37:29,760
you if you are a vendor so you have to

882
00:37:29,760 --> 00:37:32,400
consider seriously combining fault

883
00:37:32,400 --> 00:37:34,260
injection inside Channel attacks counter

884
00:37:34,260 --> 00:37:36,000
measures together

885
00:37:36,000 --> 00:37:37,859
thank you very much

886
00:37:37,859 --> 00:37:40,280
foreign

887
00:37:40,280 --> 00:37:43,399
[Music]

888
00:37:47,240 --> 00:37:50,339
[Music]

