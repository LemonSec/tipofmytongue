1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,639 --> 00:00:10,620
now it is my pleasure to Welcome to the

3
00:00:10,620 --> 00:00:11,580
stage

4
00:00:11,580 --> 00:00:14,820
Ron Markovich

5
00:00:14,820 --> 00:00:19,320
and uh Gabby nicobilly

6
00:00:21,359 --> 00:00:23,779
thank you

7
00:00:23,880 --> 00:00:25,920
hi everybody

8
00:00:25,920 --> 00:00:27,840
um have you ever tried to execute and

9
00:00:27,840 --> 00:00:29,820
analyze the malware that expects to

10
00:00:29,820 --> 00:00:31,260
receive commands from a remote and

11
00:00:31,260 --> 00:00:33,660
commandment control center only to find

12
00:00:33,660 --> 00:00:35,520
out that the This Server is now

13
00:00:35,520 --> 00:00:38,940
unavailable unavailable and you don't

14
00:00:38,940 --> 00:00:40,980
have fast traffic captures of that

15
00:00:40,980 --> 00:00:43,200
malware so you don't really know the

16
00:00:43,200 --> 00:00:44,760
correct commands to fit to that malware

17
00:00:44,760 --> 00:00:46,320
in order in order to get it to start

18
00:00:46,320 --> 00:00:48,960
doing some interesting stuff well at

19
00:00:48,960 --> 00:00:50,700
that point you pretty much have only one

20
00:00:50,700 --> 00:00:54,059
option which is to statically reverse

21
00:00:54,059 --> 00:00:57,079
engineer the malware and very manually

22
00:00:57,079 --> 00:01:01,980
and this is the task that takes a a lot

23
00:01:01,980 --> 00:01:04,379
of time and effort to figure out exactly

24
00:01:04,379 --> 00:01:06,420
what is the communication protocol of

25
00:01:06,420 --> 00:01:09,240
the malware today we offer to you Pizza

26
00:01:09,240 --> 00:01:11,580
a tool that will help you automatically

27
00:01:11,580 --> 00:01:14,100
extract the communication protocol of a

28
00:01:14,100 --> 00:01:16,920
malware or any other executable directly

29
00:01:16,920 --> 00:01:20,159
from its a binary

30
00:01:20,159 --> 00:01:23,840
so first thing first

31
00:01:24,000 --> 00:01:26,520
um let's do some introductions

32
00:01:26,520 --> 00:01:29,520
run

33
00:01:29,700 --> 00:01:32,520
all right so hello everybody my name is

34
00:01:32,520 --> 00:01:34,320
Van Markovich I'm a master's student

35
00:01:34,320 --> 00:01:37,560
from the technion and all of this

36
00:01:37,560 --> 00:01:41,720
research is a part of my thesis

37
00:01:42,180 --> 00:01:44,340
and I'm gabina kibley I'm a senior

38
00:01:44,340 --> 00:01:46,460
architecture at the technion in Ron's

39
00:01:46,460 --> 00:01:48,479
supervisor I'm also a distinguished

40
00:01:48,479 --> 00:01:50,939
researcher at the radwar formerly I was

41
00:01:50,939 --> 00:01:53,280
the CTO of a national research lab at

42
00:01:53,280 --> 00:01:56,159
Rafael and visiting scholar at Stanford

43
00:01:56,159 --> 00:01:57,540
University

44
00:01:57,540 --> 00:01:59,579
and this research will not have been

45
00:01:59,579 --> 00:02:01,259
possible without our third partner

46
00:02:01,259 --> 00:02:04,979
professor of Greenberg from the technion

47
00:02:04,979 --> 00:02:08,880
okay so our agenda for today first we're

48
00:02:08,880 --> 00:02:10,739
going to talk about what is exactly

49
00:02:10,739 --> 00:02:13,080
protocol reverse engineering and why it

50
00:02:13,080 --> 00:02:15,599
is an important task

51
00:02:15,599 --> 00:02:17,879
then we'll talk about what is exactly

52
00:02:17,879 --> 00:02:20,940
pizza and show you some demo examples

53
00:02:20,940 --> 00:02:24,120
and finally we will talk about how busy

54
00:02:24,120 --> 00:02:26,099
does its magic

55
00:02:26,099 --> 00:02:28,620
okay so let's start with by motivation

56
00:02:28,620 --> 00:02:31,080
and the background

57
00:02:31,080 --> 00:02:33,300
what is exactly protocol reverse

58
00:02:33,300 --> 00:02:36,239
engineering so let's take for example uh

59
00:02:36,239 --> 00:02:38,580
an English conversation and let's say

60
00:02:38,580 --> 00:02:40,500
that you would like to learn the rules

61
00:02:40,500 --> 00:02:43,019
of the conversation in English and now

62
00:02:43,019 --> 00:02:45,060
let's assume that you don't know a word

63
00:02:45,060 --> 00:02:47,160
in English and you don't really want to

64
00:02:47,160 --> 00:02:49,200
learn English from scratch you just want

65
00:02:49,200 --> 00:02:52,620
to learn to recite the sentences at the

66
00:02:52,620 --> 00:02:54,680
correct times

67
00:02:54,680 --> 00:02:57,060
in order to be able to Converse in

68
00:02:57,060 --> 00:02:58,560
English for example you just want to

69
00:02:58,560 --> 00:03:01,200
learn that it is appropriate to start an

70
00:03:01,200 --> 00:03:03,239
English conversation with a high or a

71
00:03:03,239 --> 00:03:06,720
low and if someone asks you how are you

72
00:03:06,720 --> 00:03:08,819
one possible answer would be I'm fine

73
00:03:08,819 --> 00:03:11,580
and for example Tuesday

74
00:03:11,580 --> 00:03:14,400
okay so uh protocol reverse engineering

75
00:03:14,400 --> 00:03:16,560
is exactly just that learning the rules

76
00:03:16,560 --> 00:03:18,840
of the conversation but we learn the

77
00:03:18,840 --> 00:03:21,060
rules of the conversation not between

78
00:03:21,060 --> 00:03:23,700
two humans but between two programs and

79
00:03:23,700 --> 00:03:25,019
the rules of the conversation between

80
00:03:25,019 --> 00:03:27,659
two programs simply is called a protocol

81
00:03:27,659 --> 00:03:30,599
and this is an example of a protocol uh

82
00:03:30,599 --> 00:03:33,959
called the SMS represents States and its

83
00:03:33,959 --> 00:03:37,319
states represents the messages the the

84
00:03:37,319 --> 00:03:39,900
program expects through a receive or

85
00:03:39,900 --> 00:03:42,299
send at that at that particular state

86
00:03:42,299 --> 00:03:45,060
for example here is a partial view of

87
00:03:45,060 --> 00:03:48,659
the SFTP State machine on the server

88
00:03:48,659 --> 00:03:51,540
side and here we can learn that the

89
00:03:51,540 --> 00:03:53,819
server at the initial State expects to

90
00:03:53,819 --> 00:03:55,980
receive an allow message this is the

91
00:03:55,980 --> 00:03:57,860
alcohol receive

92
00:03:57,860 --> 00:04:01,500
and then in the next step if it should

93
00:04:01,500 --> 00:04:04,080
send the 250 okay message and then on

94
00:04:04,080 --> 00:04:05,400
the third state

95
00:04:05,400 --> 00:04:07,560
should they receive either one of the

96
00:04:07,560 --> 00:04:10,980
two messages either made from or reset

97
00:04:10,980 --> 00:04:13,620
and based on the actual messages they

98
00:04:13,620 --> 00:04:15,840
will it will receive it will transition

99
00:04:15,840 --> 00:04:19,440
then to the next state another important

100
00:04:19,440 --> 00:04:21,180
piece of information is the message

101
00:04:21,180 --> 00:04:24,419
formats uh we for example we would like

102
00:04:24,419 --> 00:04:26,340
to know that they received two messages

103
00:04:26,340 --> 00:04:29,699
actually all messages that we begin with

104
00:04:29,699 --> 00:04:32,460
the the character received and then

105
00:04:32,460 --> 00:04:34,620
white space and then two and then column

106
00:04:34,620 --> 00:04:37,139
and so on and so forth so when we say

107
00:04:37,139 --> 00:04:40,320
protocol reverse engineering of an

108
00:04:40,320 --> 00:04:43,680
executable we actually mean learning the

109
00:04:43,680 --> 00:04:45,900
protocol State machine and the protocols

110
00:04:45,900 --> 00:04:48,300
message formats as implemented by that

111
00:04:48,300 --> 00:04:49,560
executable

112
00:04:49,560 --> 00:04:51,780
okay so now that we understand what is

113
00:04:51,780 --> 00:04:53,340
exactly protocol reverse engineering

114
00:04:53,340 --> 00:04:56,520
let's talk about the why do we want to

115
00:04:56,520 --> 00:04:57,479
do this

116
00:04:57,479 --> 00:05:00,060
first motivation is finding bugs not all

117
00:05:00,060 --> 00:05:02,880
programs are created perfectly and they

118
00:05:02,880 --> 00:05:05,699
are in implementation bugs in the

119
00:05:05,699 --> 00:05:07,440
protocol you may implement the protocol

120
00:05:07,440 --> 00:05:08,759
incorrectly

121
00:05:08,759 --> 00:05:10,919
let's see an example let's say there is

122
00:05:10,919 --> 00:05:13,020
a client that speaks to the server and

123
00:05:13,020 --> 00:05:16,139
sends it some data another server we

124
00:05:16,139 --> 00:05:18,419
should we will need to stop accepting

125
00:05:18,419 --> 00:05:21,419
data after the the finished message and

126
00:05:21,419 --> 00:05:23,039
let's say there is a bug in the server

127
00:05:23,039 --> 00:05:26,880
and it will it will accept data after

128
00:05:26,880 --> 00:05:29,820
the finished message so perhaps an

129
00:05:29,820 --> 00:05:32,580
attacker May exploit this bug so

130
00:05:32,580 --> 00:05:34,979
basically we would like to uncover such

131
00:05:34,979 --> 00:05:37,979
bugs now one option would be simply do

132
00:05:37,979 --> 00:05:41,220
testing which is fine but testing

133
00:05:41,220 --> 00:05:44,280
usually will not cover each and every

134
00:05:44,280 --> 00:05:46,199
state of the protocol and all the kernel

135
00:05:46,199 --> 00:05:48,479
cases so another option might be

136
00:05:48,479 --> 00:05:50,780
protocol reverse engineering which means

137
00:05:50,780 --> 00:05:53,160
extracting the protocol State machine

138
00:05:53,160 --> 00:05:56,220
from the program and then comparing it

139
00:05:56,220 --> 00:05:57,840
to the intended protocol State machine

140
00:05:57,840 --> 00:06:00,960
and see if there are any discrepancies

141
00:06:00,960 --> 00:06:02,940
yet another motivation is finding back

142
00:06:02,940 --> 00:06:05,820
doors let's take an example that an

143
00:06:05,820 --> 00:06:07,919
attacker implanted the vector in your

144
00:06:07,919 --> 00:06:10,680
software and now using a specially

145
00:06:10,680 --> 00:06:14,060
crafted command it will gain access to a

146
00:06:14,060 --> 00:06:17,520
privileged file okay so obviously

147
00:06:17,520 --> 00:06:19,139
testing will not uncover this bug

148
00:06:19,139 --> 00:06:21,840
because simply the the special command

149
00:06:21,840 --> 00:06:25,199
is not part of the protocol right so an

150
00:06:25,199 --> 00:06:27,960
option to uncover this Vector is do

151
00:06:27,960 --> 00:06:30,600
protocol reverse engineering extract the

152
00:06:30,600 --> 00:06:32,460
community the protocol State machine

153
00:06:32,460 --> 00:06:35,100
from the program and then see if there

154
00:06:35,100 --> 00:06:36,919
are any odd

155
00:06:36,919 --> 00:06:40,758
commands that should not be there

156
00:06:40,919 --> 00:06:43,680
and it's another motivation which I

157
00:06:43,680 --> 00:06:46,020
already mentioned is analyzing a malware

158
00:06:46,020 --> 00:06:47,880
let's say you have a malware and you

159
00:06:47,880 --> 00:06:49,800
want to feed it with the correct tense

160
00:06:49,800 --> 00:06:52,199
at the correct commands in order to get

161
00:06:52,199 --> 00:06:54,960
it to do something interesting and stop

162
00:06:54,960 --> 00:06:57,840
playing with it and analyzing it so you

163
00:06:57,840 --> 00:07:00,180
would need to do you would need to know

164
00:07:00,180 --> 00:07:03,780
the the commands it is expecting and for

165
00:07:03,780 --> 00:07:05,460
that you might need to do a protocol

166
00:07:05,460 --> 00:07:07,520
reverse engineering and

167
00:07:07,520 --> 00:07:11,160
to understand which commands the malware

168
00:07:11,160 --> 00:07:13,319
expects

169
00:07:13,319 --> 00:07:16,979
so hopefully you've Now understand the

170
00:07:16,979 --> 00:07:18,720
protocol reverse engineering is also an

171
00:07:18,720 --> 00:07:21,599
important and important task but

172
00:07:21,599 --> 00:07:23,580
unfortunately for protocol reverse

173
00:07:23,580 --> 00:07:26,340
engineering is also a hard task because

174
00:07:26,340 --> 00:07:29,280
it is very manual process it's simply

175
00:07:29,280 --> 00:07:32,520
opening a reverse engineering program

176
00:07:32,520 --> 00:07:35,280
like Ida and start analyzing the actual

177
00:07:35,280 --> 00:07:37,860
binary and finding the exact

178
00:07:37,860 --> 00:07:41,400
communication protocol bit by bit it's

179
00:07:41,400 --> 00:07:43,800
very hard and time consuming and it may

180
00:07:43,800 --> 00:07:45,780
take days or even weeks depending on the

181
00:07:45,780 --> 00:07:47,819
complexity of the executable or the

182
00:07:47,819 --> 00:07:50,400
protocols actually in my last position

183
00:07:50,400 --> 00:07:52,979
at the national Resource Center I've

184
00:07:52,979 --> 00:07:55,500
seen many researchers struggle with this

185
00:07:55,500 --> 00:07:58,979
with this exact same problem and it it

186
00:07:58,979 --> 00:08:01,199
was very frustrating frustrating and it

187
00:08:01,199 --> 00:08:03,960
took them a lot of time to do their job

188
00:08:03,960 --> 00:08:05,819
and this is actually what initially

189
00:08:05,819 --> 00:08:09,180
inspired us to take on This research and

190
00:08:09,180 --> 00:08:11,280
our goal is very simple given an

191
00:08:11,280 --> 00:08:13,199
executable we would like to somehow

192
00:08:13,199 --> 00:08:15,840
magically as and it is automatically as

193
00:08:15,840 --> 00:08:18,780
possible extract the state machine

194
00:08:18,780 --> 00:08:21,240
protocol and the commands and the

195
00:08:21,240 --> 00:08:25,139
message formats from the executable

196
00:08:25,139 --> 00:08:26,699
simple enough

197
00:08:26,699 --> 00:08:29,819
and we also had some assumptions or

198
00:08:29,819 --> 00:08:31,440
known assumptions in order to do their

199
00:08:31,440 --> 00:08:34,200
researches practical as possible

200
00:08:34,200 --> 00:08:36,779
first up is that we did not assume we

201
00:08:36,779 --> 00:08:40,740
have past traffic captures meaning we

202
00:08:40,740 --> 00:08:43,099
don't even know the legitimate

203
00:08:43,099 --> 00:08:45,959
legitimate messages of the protocol this

204
00:08:45,959 --> 00:08:47,880
is like learning rules of the English

205
00:08:47,880 --> 00:08:50,880
conversation without ever hearing a word

206
00:08:50,880 --> 00:08:53,240
in English

207
00:08:53,459 --> 00:08:56,760
uh another non-assumption is that we do

208
00:08:56,760 --> 00:08:58,620
not assume we have an active protocol

209
00:08:58,620 --> 00:09:00,000
peer meaning there is a remote

210
00:09:00,000 --> 00:09:01,980
executable that will talk to our

211
00:09:01,980 --> 00:09:04,500
executable for example in the malware

212
00:09:04,500 --> 00:09:07,140
case there there the CNC server is down

213
00:09:07,140 --> 00:09:10,019
and it will not no longer communicate

214
00:09:10,019 --> 00:09:14,519
with uh the malware so in our analogy we

215
00:09:14,519 --> 00:09:17,339
only have one English speaker

216
00:09:17,339 --> 00:09:18,660
and

217
00:09:18,660 --> 00:09:20,880
we assume we do not have the source code

218
00:09:20,880 --> 00:09:23,700
for the executable we can only rely on

219
00:09:23,700 --> 00:09:26,940
the binary code and if you like in the

220
00:09:26,940 --> 00:09:30,120
uh in our analogy we would like to learn

221
00:09:30,120 --> 00:09:32,220
the rules of the English conversation by

222
00:09:32,220 --> 00:09:34,019
simply peering into the brain of the

223
00:09:34,019 --> 00:09:36,600
English speaker

224
00:09:36,600 --> 00:09:37,800
um so

225
00:09:37,800 --> 00:09:40,200
um now that you understand what our

226
00:09:40,200 --> 00:09:42,300
research is all about let's see the

227
00:09:42,300 --> 00:09:45,420
bottom line and see the tool in action

228
00:09:45,420 --> 00:09:47,899
run

229
00:09:50,459 --> 00:09:53,279
all right so uh thank you Gabby now

230
00:09:53,279 --> 00:09:54,540
don't you know what protocol reverse

231
00:09:54,540 --> 00:09:56,700
engineering is uh let's discuss the

232
00:09:56,700 --> 00:09:58,320
development of our tool and see it in

233
00:09:58,320 --> 00:10:00,120
action

234
00:10:00,120 --> 00:10:02,459
oops

235
00:10:02,459 --> 00:10:05,220
so when we first began this research we

236
00:10:05,220 --> 00:10:10,380
created a very simple toy example this

237
00:10:10,380 --> 00:10:12,600
example is basically a client that

238
00:10:12,600 --> 00:10:14,760
implements a very simple protocol in

239
00:10:14,760 --> 00:10:17,339
this protocol the client simply sends a

240
00:10:17,339 --> 00:10:19,740
login message to the server and then

241
00:10:19,740 --> 00:10:21,600
according to the response from the

242
00:10:21,600 --> 00:10:24,320
server which is either okay1 or K2

243
00:10:24,320 --> 00:10:27,180
response with either logout 1 or logout

244
00:10:27,180 --> 00:10:29,100
2. um

245
00:10:29,100 --> 00:10:32,220
we we began reverse engineering this

246
00:10:32,220 --> 00:10:35,040
client manually and then step by step we

247
00:10:35,040 --> 00:10:37,980
automated the process and this is an

248
00:10:37,980 --> 00:10:40,500
email from the very first time that our

249
00:10:40,500 --> 00:10:43,380
method could reverse engineer the

250
00:10:43,380 --> 00:10:47,660
protocol of uh of this client

251
00:10:50,700 --> 00:10:53,100
um but then we wanted to get to some

252
00:10:53,100 --> 00:10:56,579
more realistic stuff so we worked with

253
00:10:56,579 --> 00:10:59,420
the an SMTP client that we found online

254
00:10:59,420 --> 00:11:02,820
and analyzed its protocol as well and

255
00:11:02,820 --> 00:11:04,560
during that process we also developed

256
00:11:04,560 --> 00:11:06,240
several optimizations in order to

257
00:11:06,240 --> 00:11:08,880
improve the performances of our method

258
00:11:08,880 --> 00:11:11,040
and uh yeah this is an email from The

259
00:11:11,040 --> 00:11:12,839
Virtuous time that our method could

260
00:11:12,839 --> 00:11:16,079
reverse engineer the state machine of

261
00:11:16,079 --> 00:11:19,260
the SMTP client and our method could

262
00:11:19,260 --> 00:11:20,760
also reverse engineer the message

263
00:11:20,760 --> 00:11:24,420
formats for this client and all of this

264
00:11:24,420 --> 00:11:26,640
information is extracted only from the

265
00:11:26,640 --> 00:11:31,519
binary of of data CTP client

266
00:11:31,800 --> 00:11:35,279
um yeah but then kovid came and is there

267
00:11:35,279 --> 00:11:37,260
anyone in the audience who does not know

268
00:11:37,260 --> 00:11:38,940
what Zoom is today

269
00:11:38,940 --> 00:11:40,560
well

270
00:11:40,560 --> 00:11:46,140
back then uh it was not that uh familiar

271
00:11:46,140 --> 00:11:50,160
um so yeah then resume this research and

272
00:11:50,160 --> 00:11:53,640
wanted to get uh to get with to work

273
00:11:53,640 --> 00:11:56,459
with some more realistic stuff and we

274
00:11:56,459 --> 00:11:59,160
looked for a rat or malware that we can

275
00:11:59,160 --> 00:12:00,380
work with

276
00:12:00,380 --> 00:12:03,180
rat is a remote Administration tool it

277
00:12:03,180 --> 00:12:06,120
is uh it is installed by an attacker and

278
00:12:06,120 --> 00:12:07,740
then it allows him to remotely control

279
00:12:07,740 --> 00:12:09,300
the machine

280
00:12:09,300 --> 00:12:12,660
and ghost tract is an example for such

281
00:12:12,660 --> 00:12:15,300
rat it is a very famous threat

282
00:12:15,300 --> 00:12:18,899
and uh we

283
00:12:18,899 --> 00:12:21,540
we applied the we applied our method on

284
00:12:21,540 --> 00:12:26,899
this rat so let's see our tool in action

285
00:12:27,480 --> 00:12:29,220
well

286
00:12:29,220 --> 00:12:31,500
um first we identify manually in either

287
00:12:31,500 --> 00:12:34,140
the functions that send and receive

288
00:12:34,140 --> 00:12:35,000
messages

289
00:12:35,000 --> 00:12:39,240
of that binary we later discuss why this

290
00:12:39,240 --> 00:12:43,320
is important and then we we created a

291
00:12:43,320 --> 00:12:45,660
python snippet that uses our tool

292
00:12:45,660 --> 00:12:48,300
provides the information on the binary

293
00:12:48,300 --> 00:12:50,700
as well as the procedures that send and

294
00:12:50,700 --> 00:12:52,380
receive messages

295
00:12:52,380 --> 00:12:55,620
and our tool is composed with is

296
00:12:55,620 --> 00:12:58,019
composed of a server that interacts

297
00:12:58,019 --> 00:13:00,420
directly with a binary and the client

298
00:13:00,420 --> 00:13:02,820
that actually learns the state machine

299
00:13:02,820 --> 00:13:05,639
of its protocol so when we start both

300
00:13:05,639 --> 00:13:07,800
the clients in the server the learning

301
00:13:07,800 --> 00:13:09,959
uh the reverse engineering of the

302
00:13:09,959 --> 00:13:12,480
protocol occurs and as you can see the

303
00:13:12,480 --> 00:13:14,220
state machine is being learned step by

304
00:13:14,220 --> 00:13:16,620
step as well as the message types of the

305
00:13:16,620 --> 00:13:20,100
protocol as you can see to the right

306
00:13:20,100 --> 00:13:22,740
now this is a time lapse but the overall

307
00:13:22,740 --> 00:13:25,800
process process took two minutes and

308
00:13:25,800 --> 00:13:30,000
this work could take hours even days and

309
00:13:30,000 --> 00:13:35,120
our tool do do it by two minutes

310
00:13:37,019 --> 00:13:39,300
so

311
00:13:39,300 --> 00:13:41,760
so it will finish in a second

312
00:13:41,760 --> 00:13:44,639
yeah so here it is this is the final

313
00:13:44,639 --> 00:13:46,040
State machine

314
00:13:46,040 --> 00:13:50,399
of the ghost Rod protocol

315
00:13:50,399 --> 00:13:53,459
and again this process that could take

316
00:13:53,459 --> 00:13:58,980
hours even days uh took the the tool to

317
00:13:58,980 --> 00:14:00,660
perform two minutes

318
00:14:00,660 --> 00:14:01,800
so

319
00:14:01,800 --> 00:14:02,639
um

320
00:14:02,639 --> 00:14:05,040
now once we now work for the color

321
00:14:05,040 --> 00:14:06,899
versus engineering is and once we saw

322
00:14:06,899 --> 00:14:09,019
the tool in action

323
00:14:09,019 --> 00:14:13,440
I I invited Gabby to discuss the

324
00:14:13,440 --> 00:14:16,139
internals of our tool

325
00:14:16,139 --> 00:14:18,120
okay

326
00:14:18,120 --> 00:14:20,820
great okay I hope you are impressed

327
00:14:20,820 --> 00:14:24,380
right two minutes right

328
00:14:27,180 --> 00:14:28,800
of two weeks

329
00:14:28,800 --> 00:14:30,660
okay so let's see how the magic is done

330
00:14:30,660 --> 00:14:33,199
okay

331
00:14:34,079 --> 00:14:36,540
so our tool actually is composed of two

332
00:14:36,540 --> 00:14:38,880
uh components as Ron mentioned the

333
00:14:38,880 --> 00:14:42,420
client and the server or two or a

334
00:14:42,420 --> 00:14:44,699
question component and an answering

335
00:14:44,699 --> 00:14:46,500
component the client is the question

336
00:14:46,500 --> 00:14:48,420
component this is the actual component

337
00:14:48,420 --> 00:14:50,279
the learn the turns the the state

338
00:14:50,279 --> 00:14:52,860
machine it runs it but simply asking

339
00:14:52,860 --> 00:14:55,680
questions it is based on an algorithm

340
00:14:55,680 --> 00:14:57,420
algorithm called the estar algorithm

341
00:14:57,420 --> 00:15:00,260
which will I will describe there shortly

342
00:15:00,260 --> 00:15:03,660
and the the part that answers them is

343
00:15:03,660 --> 00:15:07,260
the answering the component which is

344
00:15:07,260 --> 00:15:09,000
based on the symbolic execution this is

345
00:15:09,000 --> 00:15:10,260
the server

346
00:15:10,260 --> 00:15:12,300
okay let's talk about the the question

347
00:15:12,300 --> 00:15:15,000
component there's the algorithm this is

348
00:15:15,000 --> 00:15:17,160
a an automated learning algorithm

349
00:15:17,160 --> 00:15:19,560
Loosely speaking is just an algorithm

350
00:15:19,560 --> 00:15:21,839
that turns State machines okay it is

351
00:15:21,839 --> 00:15:24,720
well established a protocol algorithm

352
00:15:24,720 --> 00:15:27,320
that was a

353
00:15:27,320 --> 00:15:31,620
presented in 1997 By Dana glueing and

354
00:15:31,620 --> 00:15:34,620
its aim is to identify an unknown

355
00:15:34,620 --> 00:15:37,560
regular set from examples of members and

356
00:15:37,560 --> 00:15:40,920
non-members in our case in an unregular

357
00:15:40,920 --> 00:15:42,899
set it's simply the set of all messages

358
00:15:42,899 --> 00:15:45,300
exchanges as permitted by the protocol

359
00:15:45,300 --> 00:15:47,699
okay which is essentially described

360
00:15:47,699 --> 00:15:50,040
using a protocols the protocol State

361
00:15:50,040 --> 00:15:52,880
machine and it runs this state Machine

362
00:15:52,880 --> 00:15:56,220
by simply finding examples of members

363
00:15:56,220 --> 00:15:58,980
and non-members of this set or in other

364
00:15:58,980 --> 00:16:02,100
words it simply asks questions of this

365
00:16:02,100 --> 00:16:03,540
type

366
00:16:03,540 --> 00:16:05,760
um is a given message exchange valued by

367
00:16:05,760 --> 00:16:08,339
the protocol yes algorithm simply asked

368
00:16:08,339 --> 00:16:11,579
over and over again such questions and

369
00:16:11,579 --> 00:16:14,040
it assumes there is someone or something

370
00:16:14,040 --> 00:16:17,760
that can answer such such a question and

371
00:16:17,760 --> 00:16:19,440
based on the the answer to these

372
00:16:19,440 --> 00:16:21,360
questions it will then construct more

373
00:16:21,360 --> 00:16:23,399
questions of this type and then it will

374
00:16:23,399 --> 00:16:25,920
learn piece by piece the the protocol

375
00:16:25,920 --> 00:16:28,399
State machine

376
00:16:28,399 --> 00:16:31,079
algorithm will now go into the details

377
00:16:31,079 --> 00:16:33,839
of it but it is very uh clever one and

378
00:16:33,839 --> 00:16:36,360
very efficient so it doesn't need to ask

379
00:16:36,360 --> 00:16:39,899
about each and every or every message

380
00:16:39,899 --> 00:16:43,980
Exchange in order to get the complete

381
00:16:43,980 --> 00:16:46,920
view of the of the state machine the

382
00:16:46,920 --> 00:16:49,380
number of questions of uh as it is it

383
00:16:49,380 --> 00:16:51,300
called as it is as they are called

384
00:16:51,300 --> 00:16:53,220
membership queries the number of

385
00:16:53,220 --> 00:16:55,980
membership queries that it will ask is

386
00:16:55,980 --> 00:16:58,380
simply polynomial in the in the number

387
00:16:58,380 --> 00:16:59,240
of

388
00:16:59,240 --> 00:17:01,920
states of the protocol

389
00:17:01,920 --> 00:17:04,140
so for example if you go back to the

390
00:17:04,140 --> 00:17:05,819
English conversation if the air star

391
00:17:05,819 --> 00:17:08,939
algorithm now like to learn protocol

392
00:17:08,939 --> 00:17:10,799
State machine of the English

393
00:17:10,799 --> 00:17:12,119
conversation the rules of the

394
00:17:12,119 --> 00:17:14,160
conversation it would simply ask

395
00:17:14,160 --> 00:17:18,480
questions of this type is uh is this

396
00:17:18,480 --> 00:17:21,540
conversation valid is saying hi and then

397
00:17:21,540 --> 00:17:23,760
receiving a low and then saying how are

398
00:17:23,760 --> 00:17:26,640
you and I'm fine is this a valid English

399
00:17:26,640 --> 00:17:28,740
conversation and again it assumed that

400
00:17:28,740 --> 00:17:30,540
something or someone can answer this

401
00:17:30,540 --> 00:17:33,120
question and the answer is it should be

402
00:17:33,120 --> 00:17:36,360
a yes and another question might be is

403
00:17:36,360 --> 00:17:38,820
this conversation valid hi hello how are

404
00:17:38,820 --> 00:17:43,080
you Tuesday and of course should be a no

405
00:17:43,080 --> 00:17:46,320
another example here is a a protocol

406
00:17:46,320 --> 00:17:49,559
where the client sends a in any message

407
00:17:49,559 --> 00:17:52,080
the server sends a startup message and

408
00:17:52,080 --> 00:17:53,760
then the server receives data and finish

409
00:17:53,760 --> 00:17:56,520
and let's say they start algorithm and I

410
00:17:56,520 --> 00:17:59,580
would like to uh learn the protocol

411
00:17:59,580 --> 00:18:01,860
State machine of that of that protocol

412
00:18:01,860 --> 00:18:04,860
so it would simply ask questions of of

413
00:18:04,860 --> 00:18:08,280
this type for example is it okay for the

414
00:18:08,280 --> 00:18:10,380
server to receive an init message and

415
00:18:10,380 --> 00:18:12,840
then send a stop message is it okay for

416
00:18:12,840 --> 00:18:14,460
the server to receive two init messages

417
00:18:14,460 --> 00:18:17,720
back to back okay this type of questions

418
00:18:17,720 --> 00:18:21,419
and based on those the answers to those

419
00:18:21,419 --> 00:18:24,919
questions it will then piece by piece

420
00:18:24,919 --> 00:18:29,720
gather the the protocol State machine

421
00:18:30,179 --> 00:18:32,760
but there is a problem here uh as I

422
00:18:32,760 --> 00:18:36,419
explained it so far have you noticed it

423
00:18:36,419 --> 00:18:38,820
um our assumption or basic assumption is

424
00:18:38,820 --> 00:18:40,320
that we do not know the legitimate

425
00:18:40,320 --> 00:18:43,080
messages of the of the protocol so how

426
00:18:43,080 --> 00:18:45,600
can the extra algorithm even ask about

427
00:18:45,600 --> 00:18:48,120
sequences of those of those messages if

428
00:18:48,120 --> 00:18:49,500
he doesn't really know the actual

429
00:18:49,500 --> 00:18:52,620
messages this is the problem so let's

430
00:18:52,620 --> 00:18:54,419
say let's say for the sake of the

431
00:18:54,419 --> 00:18:56,820
exposition of the algorithm let's say

432
00:18:56,820 --> 00:18:59,280
assume that we do know the uh the

433
00:18:59,280 --> 00:19:01,200
messages of the protocol and then we

434
00:19:01,200 --> 00:19:03,480
will relax the this assumption and show

435
00:19:03,480 --> 00:19:07,460
you how the real algorithm works

436
00:19:09,179 --> 00:19:11,880
so to sum up the uh the question part of

437
00:19:11,880 --> 00:19:14,460
the the algorithm uh the question part

438
00:19:14,460 --> 00:19:16,559
simply asks questions of the of this

439
00:19:16,559 --> 00:19:18,419
type is is a given sequence of message

440
00:19:18,419 --> 00:19:20,760
types valid for the protocol for the

441
00:19:20,760 --> 00:19:22,860
protocol a lot and it expects to receive

442
00:19:22,860 --> 00:19:25,020
either yes or no and the part that

443
00:19:25,020 --> 00:19:27,000
answers those questions is based on

444
00:19:27,000 --> 00:19:28,980
symbolic executions this is the only

445
00:19:28,980 --> 00:19:31,559
part in our product in our tool that

446
00:19:31,559 --> 00:19:33,539
interacts with the actual binary

447
00:19:33,539 --> 00:19:36,960
executable and generally speaking and

448
00:19:36,960 --> 00:19:40,280
the answering component of the symbolic

449
00:19:40,280 --> 00:19:44,100
execution simply tries to find

450
00:19:44,100 --> 00:19:47,700
um valid execution path in the

451
00:19:47,700 --> 00:19:50,220
executable that are that correspond to

452
00:19:50,220 --> 00:19:52,260
the to the message to the sequence of

453
00:19:52,260 --> 00:19:54,600
messages that was asked by the question

454
00:19:54,600 --> 00:19:57,900
component if there are valid execution

455
00:19:57,900 --> 00:20:00,240
path that correspond to the sequence of

456
00:20:00,240 --> 00:20:03,059
messages at hand then the answer should

457
00:20:03,059 --> 00:20:06,660
be yes otherwise it should be no now a

458
00:20:06,660 --> 00:20:08,880
run will deep dive into the answering

459
00:20:08,880 --> 00:20:12,559
component a symbolic execution

460
00:20:14,580 --> 00:20:16,760
all right so

461
00:20:16,760 --> 00:20:19,220
thank you Gabby again

462
00:20:19,220 --> 00:20:22,320
so let's discuss what symbolic execution

463
00:20:22,320 --> 00:20:23,419
is

464
00:20:23,419 --> 00:20:26,160
symbolic execution is a static analysis

465
00:20:26,160 --> 00:20:29,039
method it is a very powerful one but in

466
00:20:29,039 --> 00:20:32,480
our case it allows us to

467
00:20:32,700 --> 00:20:33,840
sorry

468
00:20:33,840 --> 00:20:37,260
yeah so symbolic execution in our case

469
00:20:37,260 --> 00:20:39,480
allows us to explore the executions of

470
00:20:39,480 --> 00:20:42,360
the binary that follow a given set of

471
00:20:42,360 --> 00:20:44,700
constraints

472
00:20:44,700 --> 00:20:46,679
um now when we talk about the

473
00:20:46,679 --> 00:20:48,660
constraints we mean constraints on the

474
00:20:48,660 --> 00:20:51,299
program inputs let's say for example

475
00:20:51,299 --> 00:20:54,960
here the program inputs are inserted

476
00:20:54,960 --> 00:20:58,679
into variables X and Y the inputs are A

477
00:20:58,679 --> 00:21:01,260
and B so if we want to find all

478
00:21:01,260 --> 00:21:03,480
executions that match the constraint

479
00:21:03,480 --> 00:21:05,580
that a is greater than 3 then the

480
00:21:05,580 --> 00:21:07,559
symbolic execution engine will find

481
00:21:07,559 --> 00:21:11,039
these two executions but if we also add

482
00:21:11,039 --> 00:21:14,419
a constraint that b equals to

483
00:21:14,419 --> 00:21:18,299
2789 then we are left only with this one

484
00:21:18,299 --> 00:21:20,900
execution

485
00:21:22,020 --> 00:21:23,640
um so how do we use the symbolic

486
00:21:23,640 --> 00:21:25,740
execution to actually check if a

487
00:21:25,740 --> 00:21:27,660
sequence of message types is valid for

488
00:21:27,660 --> 00:21:29,460
the protocol we analyze

489
00:21:29,460 --> 00:21:33,539
so uh let's see how we do that

490
00:21:33,539 --> 00:21:35,820
um assume we are given the sequence of

491
00:21:35,820 --> 00:21:39,840
any starting data and then the the

492
00:21:39,840 --> 00:21:42,179
program receives a message from the

493
00:21:42,179 --> 00:21:44,820
network then we add a constraint that

494
00:21:44,820 --> 00:21:47,520
this message is is of the type in it

495
00:21:47,520 --> 00:21:49,860
this way the symbolic execution will

496
00:21:49,860 --> 00:21:52,200
discard execution paths that do not

497
00:21:52,200 --> 00:21:54,960
follow this constraint and we'll only

498
00:21:54,960 --> 00:21:58,620
consider now on the true branch of the

499
00:21:58,620 --> 00:22:00,720
of the program then when the program

500
00:22:00,720 --> 00:22:05,460
sends a start message and we constraint

501
00:22:05,460 --> 00:22:09,780
the message to be start the symbolic

502
00:22:09,780 --> 00:22:13,020
execution says that the programming did

503
00:22:13,020 --> 00:22:16,260
sends a start message and resumes this

504
00:22:16,260 --> 00:22:18,840
execution path then when receive is

505
00:22:18,840 --> 00:22:22,200
called for another another time we

506
00:22:22,200 --> 00:22:24,299
constrained it to the third message

507
00:22:24,299 --> 00:22:27,000
which is receiving of data making the

508
00:22:27,000 --> 00:22:29,400
symbolic execution follow only X

509
00:22:29,400 --> 00:22:33,000
execution path where where the received

510
00:22:33,000 --> 00:22:37,500
message is actually data and this way we

511
00:22:37,500 --> 00:22:40,380
are left with execution paths that

512
00:22:40,380 --> 00:22:43,020
follows the constraints of the sequence

513
00:22:43,020 --> 00:22:45,799
of message types and we can say that

514
00:22:45,799 --> 00:22:48,240
that the sequence is valid for the

515
00:22:48,240 --> 00:22:49,080
protocol

516
00:22:49,080 --> 00:22:51,480
now let's see an example for what

517
00:22:51,480 --> 00:22:53,280
happens if the sequence is not valid in

518
00:22:53,280 --> 00:22:56,340
the protocol when the first message when

519
00:22:56,340 --> 00:22:58,260
we are asked about the sequence of

520
00:22:58,260 --> 00:23:01,260
receiving data initially and the

521
00:23:01,260 --> 00:23:03,059
symbolic execution inserts this

522
00:23:03,059 --> 00:23:06,900
constraint of the received message and

523
00:23:06,900 --> 00:23:09,419
then the true branch is discarded

524
00:23:09,419 --> 00:23:12,900
leaving us with an execution that errors

525
00:23:12,900 --> 00:23:15,260
this way we know that the execution

526
00:23:15,260 --> 00:23:18,360
there are no valid executions of the

527
00:23:18,360 --> 00:23:20,100
binary that follow the sequence of

528
00:23:20,100 --> 00:23:22,740
messages and we concluded the sequence

529
00:23:22,740 --> 00:23:25,440
is not valid

530
00:23:25,440 --> 00:23:28,200
so to formalize this assume we are given

531
00:23:28,200 --> 00:23:30,360
a sequence of message types then

532
00:23:30,360 --> 00:23:33,000
whenever a send or receive occurs in the

533
00:23:33,000 --> 00:23:34,460
program

534
00:23:34,460 --> 00:23:37,799
then we add the constraint to match this

535
00:23:37,799 --> 00:23:39,840
message to match the appropriate message

536
00:23:39,840 --> 00:23:43,940
type and therefore we uh we can actually

537
00:23:43,940 --> 00:23:48,000
illustrate this as a trimmed tree of all

538
00:23:48,000 --> 00:23:51,360
the executions when we're finally we're

539
00:23:51,360 --> 00:23:53,400
left only with executions that follow

540
00:23:53,400 --> 00:23:55,740
this sequence if in the end of this

541
00:23:55,740 --> 00:23:57,659
process we are left with at least one

542
00:23:57,659 --> 00:24:00,539
execution that is valid that follows the

543
00:24:00,539 --> 00:24:02,580
constraints then we can say that the

544
00:24:02,580 --> 00:24:05,960
sequence is valid for the protocol

545
00:24:06,799 --> 00:24:09,840
but remember we said that we constrained

546
00:24:09,840 --> 00:24:12,240
messages to the sequence we are given

547
00:24:12,240 --> 00:24:15,419
how do we do that well in order to do

548
00:24:15,419 --> 00:24:17,159
that we need to intercept the symbolic

549
00:24:17,159 --> 00:24:19,440
execution whenever send or receive

550
00:24:19,440 --> 00:24:22,020
procedures of the binary are called and

551
00:24:22,020 --> 00:24:23,880
therefore we require the use of our

552
00:24:23,880 --> 00:24:26,700
method to manually identify the

553
00:24:26,700 --> 00:24:28,740
procedures that actually send or receive

554
00:24:28,740 --> 00:24:32,700
messages and in this example uh this is

555
00:24:32,700 --> 00:24:37,380
the the SMTP example and it is the the

556
00:24:37,380 --> 00:24:41,280
SMTP right function that writes a line

557
00:24:41,280 --> 00:24:44,039
to the socket or the SMTP get line that

558
00:24:44,039 --> 00:24:46,200
reads the line from the socket and

559
00:24:46,200 --> 00:24:48,120
receives messages

560
00:24:48,120 --> 00:24:51,480
so um yeah this is a requirement from

561
00:24:51,480 --> 00:24:53,760
the user of our method

562
00:24:53,760 --> 00:24:58,380
but there is a problem still remember we

563
00:24:58,380 --> 00:25:00,120
said that we do not know in advance the

564
00:25:00,120 --> 00:25:02,460
message types of the protocol so we need

565
00:25:02,460 --> 00:25:06,320
to discover them how do we do that well

566
00:25:06,320 --> 00:25:09,679
we extend the symbolic execution part of

567
00:25:09,679 --> 00:25:12,360
our method and say that whenever a

568
00:25:12,360 --> 00:25:14,940
sequence is valid for the protocol it

569
00:25:14,940 --> 00:25:17,220
will also return a set of message types

570
00:25:17,220 --> 00:25:19,860
that can follow the sequence given

571
00:25:19,860 --> 00:25:22,440
the elster algorithm is also extended in

572
00:25:22,440 --> 00:25:25,200
order to to gather the set of message

573
00:25:25,200 --> 00:25:28,980
types step by step so the set of message

574
00:25:28,980 --> 00:25:33,659
types is actually learned on the Fly

575
00:25:33,659 --> 00:25:37,679
let's see that again in in an example

576
00:25:37,679 --> 00:25:40,140
so assume that the symbolic execution

577
00:25:40,140 --> 00:25:42,539
validated the sequence of receiving unit

578
00:25:42,539 --> 00:25:45,539
initially so we are left only with the

579
00:25:45,539 --> 00:25:49,200
true Branch here and then we wait to see

580
00:25:49,200 --> 00:25:52,620
what message types can follow the

581
00:25:52,620 --> 00:25:53,700
sequence

582
00:25:53,700 --> 00:25:57,799
so the symbolic the the program then

583
00:25:57,799 --> 00:26:01,740
sends a data message and there is a

584
00:26:01,740 --> 00:26:03,539
feature of the symbolic execution engine

585
00:26:03,539 --> 00:26:06,720
that allows us to get examples for

586
00:26:06,720 --> 00:26:10,620
values uh for for that message so what

587
00:26:10,620 --> 00:26:13,140
we do is we get examples for the message

588
00:26:13,140 --> 00:26:17,340
that can that is sent after the after

589
00:26:17,340 --> 00:26:21,120
the sequence and we'll later discuss

590
00:26:21,120 --> 00:26:23,940
what we do with those examples but let's

591
00:26:23,940 --> 00:26:26,700
see another example so if we are given

592
00:26:26,700 --> 00:26:29,400
the sequence of init and start and we

593
00:26:29,400 --> 00:26:31,919
want to to know what message types can

594
00:26:31,919 --> 00:26:33,740
follow this sequence

595
00:26:33,740 --> 00:26:37,140
well again we we are left with the with

596
00:26:37,140 --> 00:26:39,539
the execution constraint to this

597
00:26:39,539 --> 00:26:43,020
sequence and wait for another send or

598
00:26:43,020 --> 00:26:46,200
receive to happen in the program well

599
00:26:46,200 --> 00:26:48,240
the next thing that happens is that the

600
00:26:48,240 --> 00:26:51,000
program receives a message but we can't

601
00:26:51,000 --> 00:26:53,100
do what we just did with this with

602
00:26:53,100 --> 00:26:55,740
sending message said because a received

603
00:26:55,740 --> 00:26:57,900
message is symbolic value it is not

604
00:26:57,900 --> 00:27:01,980
known and the we need to to do something

605
00:27:01,980 --> 00:27:03,539
else here

606
00:27:03,539 --> 00:27:07,200
well what we do is we let the message to

607
00:27:07,200 --> 00:27:10,220
be passed uh to be passed by the program

608
00:27:10,220 --> 00:27:12,720
once the message is passed as you can

609
00:27:12,720 --> 00:27:15,140
see here in this example

610
00:27:15,140 --> 00:27:18,539
the for the program checks for some

611
00:27:18,539 --> 00:27:21,080
characteristics of the of the message

612
00:27:21,080 --> 00:27:25,500
and then the symbolic execution knows uh

613
00:27:25,500 --> 00:27:27,840
well if we are in the true branch of

614
00:27:27,840 --> 00:27:30,299
this condition the message must begin

615
00:27:30,299 --> 00:27:33,779
with uh with an Adder that identifies it

616
00:27:33,779 --> 00:27:37,320
as a data message so we actually wait

617
00:27:37,320 --> 00:27:39,960
for the message to be passed and only

618
00:27:39,960 --> 00:27:43,080
then we get examples from the symbolic

619
00:27:43,080 --> 00:27:45,779
execution engine for them for the

620
00:27:45,779 --> 00:27:48,900
possible values of the of the received

621
00:27:48,900 --> 00:27:52,200
message so it is not it is not entirely

622
00:27:52,200 --> 00:27:55,020
unknown

623
00:27:55,020 --> 00:27:59,100
but remember that we are we we get a set

624
00:27:59,100 --> 00:28:01,919
of examples for for that for uh for the

625
00:28:01,919 --> 00:28:05,220
messages uh we need to uh come up with

626
00:28:05,220 --> 00:28:07,860
the message type from those examples uh

627
00:28:07,860 --> 00:28:10,679
so there are many ways that this can be

628
00:28:10,679 --> 00:28:13,559
done but uh a simple approach that

629
00:28:13,559 --> 00:28:15,600
worked for us is to Simply find the

630
00:28:15,600 --> 00:28:18,440
common features to all the messages

631
00:28:18,440 --> 00:28:21,480
meaning the common bytes the bytes that

632
00:28:21,480 --> 00:28:24,320
are the same value for all the messages

633
00:28:24,320 --> 00:28:27,000
in the set of examples

634
00:28:27,000 --> 00:28:29,880
and um

635
00:28:29,880 --> 00:28:33,360
and this way we we use the common

636
00:28:33,360 --> 00:28:36,419
features of the messages to identify the

637
00:28:36,419 --> 00:28:38,760
message types next

638
00:28:38,760 --> 00:28:41,039
um let's see an example for that so

639
00:28:41,039 --> 00:28:43,940
assume we're given this set of examples

640
00:28:43,940 --> 00:28:48,179
and we see that the the common features

641
00:28:48,179 --> 00:28:51,179
for all of these messages is the format

642
00:28:51,179 --> 00:28:53,640
of the receipt to message which is

643
00:28:53,640 --> 00:28:57,059
received white space to colon and so on

644
00:28:57,059 --> 00:29:00,059
so forth so actually we will

645
00:29:00,059 --> 00:29:02,760
characterize the message type of receipt

646
00:29:02,760 --> 00:29:08,220
tool with the with this with this format

647
00:29:08,220 --> 00:29:11,760
so to title together we just discussed

648
00:29:11,760 --> 00:29:15,900
that our algorithm uses l-star in order

649
00:29:15,900 --> 00:29:19,320
to ask if sequences of message types are

650
00:29:19,320 --> 00:29:21,960
valid in the protocol and the symbolic

651
00:29:21,960 --> 00:29:25,260
execution first validate if a sequence

652
00:29:25,260 --> 00:29:27,600
is valid or not and if the sequence is

653
00:29:27,600 --> 00:29:29,940
valid it also provides the message types

654
00:29:29,940 --> 00:29:32,880
that can follow this sequence the Ulster

655
00:29:32,880 --> 00:29:35,940
algorithm dance then gathers the set of

656
00:29:35,940 --> 00:29:39,659
message types and and learn learns it

657
00:29:39,659 --> 00:29:42,419
step by step

658
00:29:42,419 --> 00:29:44,940
so let's see an illustrative example to

659
00:29:44,940 --> 00:29:47,279
summarize it all

660
00:29:47,279 --> 00:29:50,340
assume that the l-star algorithm asks if

661
00:29:50,340 --> 00:29:52,440
this empty sequence is valid in the

662
00:29:52,440 --> 00:29:55,799
protocol well in most protocols in

663
00:29:55,799 --> 00:29:57,720
actually in every product called The

664
00:29:57,720 --> 00:30:00,600
Empty sequence is considered valid and

665
00:30:00,600 --> 00:30:03,480
the symbolic execution will answer that

666
00:30:03,480 --> 00:30:06,179
yes this sequence is valid and a message

667
00:30:06,179 --> 00:30:07,919
the message types that can follow this

668
00:30:07,919 --> 00:30:13,080
sequence are the are receiving the init

669
00:30:13,080 --> 00:30:15,360
so in it is added to the set of message

670
00:30:15,360 --> 00:30:19,080
types and then the LST algorithm asks if

671
00:30:19,080 --> 00:30:21,720
receiving init is a valid sequence and

672
00:30:21,720 --> 00:30:24,059
the symbolic execution answers that yes

673
00:30:24,059 --> 00:30:26,340
it is a valid sequence and the message

674
00:30:26,340 --> 00:30:28,559
types that can follow this sequence are

675
00:30:28,559 --> 00:30:32,039
star data and finish then it asks if

676
00:30:32,039 --> 00:30:34,320
anything starts is a valid sequence the

677
00:30:34,320 --> 00:30:36,539
symbolic execution answers that this is

678
00:30:36,539 --> 00:30:39,020
a valid sequence and

679
00:30:39,020 --> 00:30:41,880
and the set of message types that can

680
00:30:41,880 --> 00:30:44,399
follow are already known already

681
00:30:44,399 --> 00:30:47,039
contained in the set of message types

682
00:30:47,039 --> 00:30:50,520
then it asks if receiving data initially

683
00:30:50,520 --> 00:30:53,100
is a valid sequence and the symbolic

684
00:30:53,100 --> 00:30:55,320
execution will answer that no it is not

685
00:30:55,320 --> 00:30:57,179
a valid sequence

686
00:30:57,179 --> 00:30:59,340
asking if anything data is a valid

687
00:30:59,340 --> 00:31:03,020
sequence yes it is a valid sequence and

688
00:31:03,020 --> 00:31:06,559
and again the set of message types

689
00:31:06,559 --> 00:31:10,320
reveals nothing new

690
00:31:10,320 --> 00:31:13,320
and then asking if if the sequence unit

691
00:31:13,320 --> 00:31:15,480
data and finish is valid and the

692
00:31:15,480 --> 00:31:17,700
symbolic execution answers yes this is a

693
00:31:17,700 --> 00:31:19,860
valid sequence but there is no message

694
00:31:19,860 --> 00:31:24,139
type that can follow this sequence

695
00:31:26,039 --> 00:31:28,440
all right so that's it for the internal

696
00:31:28,440 --> 00:31:30,659
for method I will now invite Gabby again

697
00:31:30,659 --> 00:31:33,899
to summarize and conclude thank you

698
00:31:33,899 --> 00:31:36,059
okay thanks Ron

699
00:31:36,059 --> 00:31:37,080
um

700
00:31:37,080 --> 00:31:40,260
so before we wrap up uh just a few uh

701
00:31:40,260 --> 00:31:42,779
indeed caveats and limitations to this

702
00:31:42,779 --> 00:31:48,179
tool as you have seen the only way for

703
00:31:48,179 --> 00:31:50,100
which our tool to interact with the

704
00:31:50,100 --> 00:31:52,919
binary executable is using the symbolic

705
00:31:52,919 --> 00:31:55,380
execution this means that our tool is as

706
00:31:55,380 --> 00:31:58,140
good or as bad as the symbolic executing

707
00:31:58,140 --> 00:32:01,799
engine we use or it uses currently PC

708
00:32:01,799 --> 00:32:04,320
only supports a single symbolic

709
00:32:04,320 --> 00:32:06,840
execution and engine called anger which

710
00:32:06,840 --> 00:32:08,179
is a fantastic

711
00:32:08,179 --> 00:32:12,140
tool it does a lot of great things

712
00:32:12,140 --> 00:32:14,760
however it does has its limitations for

713
00:32:14,760 --> 00:32:16,740
example it has some trouble supporting

714
00:32:16,740 --> 00:32:18,600
multiple threads and doesn't fully

715
00:32:18,600 --> 00:32:20,640
support the windows windows API this

716
00:32:20,640 --> 00:32:23,159
means that two and also the the pizza

717
00:32:23,159 --> 00:32:26,120
tool will have trouble

718
00:32:26,120 --> 00:32:28,100
analyzing

719
00:32:28,100 --> 00:32:31,340
executables such as analyzing such

720
00:32:31,340 --> 00:32:33,960
executables this is definitely our

721
00:32:33,960 --> 00:32:38,520
future work to expand our I have a piece

722
00:32:38,520 --> 00:32:40,980
of support and more

723
00:32:40,980 --> 00:32:43,380
symbolic execution engines to help the

724
00:32:43,380 --> 00:32:46,080
the tools support more types of

725
00:32:46,080 --> 00:32:48,779
executables

726
00:32:48,779 --> 00:32:52,620
so to summarize you've just seen a pizza

727
00:32:52,620 --> 00:32:54,360
a tool that will allow you to

728
00:32:54,360 --> 00:32:56,640
automatically extract the communication

729
00:32:56,640 --> 00:33:00,419
protocol and from an executable thereby

730
00:33:00,419 --> 00:33:03,120
dramatically increasing decreasing the

731
00:33:03,120 --> 00:33:04,980
time it takes for you to analyze the

732
00:33:04,980 --> 00:33:07,740
malware or any other executable it can

733
00:33:07,740 --> 00:33:10,860
take minutes instead of days or even

734
00:33:10,860 --> 00:33:15,299
weeks so with that I do invite you to

735
00:33:15,299 --> 00:33:18,960
download them the tool and access the

736
00:33:18,960 --> 00:33:21,179
the repo and start playing with it and

737
00:33:21,179 --> 00:33:24,559
let us know what you think

738
00:33:24,560 --> 00:33:27,679
[Music]

739
00:33:31,530 --> 00:33:34,619
[Music]

