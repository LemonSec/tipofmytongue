1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:08,179 --> 00:00:11,940
hi everyone I'm Han Yan Welcome to our

3
00:00:11,940 --> 00:00:14,580
talk broker match new attack Services of

4
00:00:14,580 --> 00:00:15,960
Bluetooth smash

5
00:00:15,960 --> 00:00:18,660
in this talk we will discuss some common

6
00:00:18,660 --> 00:00:21,300
attack surfaces and vulnerabilities of

7
00:00:21,300 --> 00:00:24,740
Bluetooth mesh technology

8
00:00:25,019 --> 00:00:28,140
first let me introduce our team we

9
00:00:28,140 --> 00:00:31,439
belong to the Baidu alt security team we

10
00:00:31,439 --> 00:00:34,200
now focus on the security of Android and

11
00:00:34,200 --> 00:00:37,260
Linux platform and our duty is to

12
00:00:37,260 --> 00:00:40,079
discover zero-day vulnerability and

13
00:00:40,079 --> 00:00:44,000
explore possible defense Solutions

14
00:00:44,040 --> 00:00:46,620
in this talk we will first introduce

15
00:00:46,620 --> 00:00:49,440
some basic concepts of Bluetooth mesh

16
00:00:49,440 --> 00:00:52,620
technology and then we will analyze the

17
00:00:52,620 --> 00:00:55,320
attack surfaces to show where to attack

18
00:00:55,320 --> 00:00:58,020
when to attack and how to attack

19
00:00:58,020 --> 00:01:01,320
and next we will introduce PR image

20
00:01:01,320 --> 00:01:04,019
further an automated fasting tool for

21
00:01:04,019 --> 00:01:07,260
Bluetooth mesh and show its effect with

22
00:01:07,260 --> 00:01:09,979
several case studies

23
00:01:09,979 --> 00:01:12,900
well let's start with the Bluetooth

24
00:01:12,900 --> 00:01:14,640
slash technology

25
00:01:14,640 --> 00:01:17,340
Bluetooth smash is also known as

26
00:01:17,340 --> 00:01:21,600
Bluetooth re mesh or VR image it is a

27
00:01:21,600 --> 00:01:23,460
wireless management working Technology

28
00:01:23,460 --> 00:01:25,380
based on bre

29
00:01:25,380 --> 00:01:27,600
a Bluetooth smash was made public by

30
00:01:27,600 --> 00:01:30,479
seek in 2017.

31
00:01:30,479 --> 00:01:33,840
and now is widely used in smart home and

32
00:01:33,840 --> 00:01:38,040
Industrial llt and other things

33
00:01:38,040 --> 00:01:40,799
we're hearing the Bluetooth smash may be

34
00:01:40,799 --> 00:01:43,200
one of the most confusing question is

35
00:01:43,200 --> 00:01:45,420
what is the difference between Bluetooth

36
00:01:45,420 --> 00:01:48,000
Smash and the Bluetooth classic or

37
00:01:48,000 --> 00:01:49,439
Bluetooth re

38
00:01:49,439 --> 00:01:52,200
we think the main difference is that

39
00:01:52,200 --> 00:01:55,079
Bluetooth classic and ble are wireless

40
00:01:55,079 --> 00:01:58,079
communication technology they are just

41
00:01:58,079 --> 00:02:01,680
like Wi-Fi well the Bluetooth smash is

42
00:02:01,680 --> 00:02:04,740
not working technology it's just like

43
00:02:04,740 --> 00:02:06,299
the TCP

44
00:02:06,299 --> 00:02:09,119
and this figure shows their protocol

45
00:02:09,119 --> 00:02:12,599
stack as we can see Bluetooth smash has

46
00:02:12,599 --> 00:02:15,360
a network layer but the other protocol

47
00:02:15,360 --> 00:02:17,959
do not

48
00:02:18,860 --> 00:02:21,720
since brutal smash is a networking

49
00:02:21,720 --> 00:02:24,060
technology Communication in Bluetooth

50
00:02:24,060 --> 00:02:27,900
mesh is no longer just point to point a

51
00:02:27,900 --> 00:02:30,860
large number of device forms a network

52
00:02:30,860 --> 00:02:34,260
and communicate with each other

53
00:02:34,260 --> 00:02:37,800
formally device in the mesh network is

54
00:02:37,800 --> 00:02:40,860
called node and you could see there are

55
00:02:40,860 --> 00:02:43,920
many types of nodes but we only need to

56
00:02:43,920 --> 00:02:46,379
focus on the based node and the Really

57
00:02:46,379 --> 00:02:49,800
node here okay let's see how the message

58
00:02:49,800 --> 00:02:52,019
flows in this network

59
00:02:52,019 --> 00:02:54,959
assuming that the node a wants to send

60
00:02:54,959 --> 00:02:58,200
some message to this node e it can just

61
00:02:58,200 --> 00:03:00,599
pass the message to the relay node queue

62
00:03:00,599 --> 00:03:02,879
and the queue will then forward the

63
00:03:02,879 --> 00:03:04,379
message to E

64
00:03:04,379 --> 00:03:07,580
in this process node a actually

65
00:03:07,580 --> 00:03:10,500
advertises the message to all the nearby

66
00:03:10,500 --> 00:03:14,519
nodes include the node B node hero and

67
00:03:14,519 --> 00:03:17,580
node p and so on but only the relay node

68
00:03:17,580 --> 00:03:19,800
Q will do the forward job

69
00:03:19,800 --> 00:03:22,739
and we call such communication mechanism

70
00:03:22,739 --> 00:03:27,200
as managed flooding

71
00:03:27,300 --> 00:03:29,760
we have figured out how message flows

72
00:03:29,760 --> 00:03:32,040
but how to represent the source and

73
00:03:32,040 --> 00:03:33,900
destination of a message

74
00:03:33,900 --> 00:03:38,099
in fact just like TCP each node in mesh

75
00:03:38,099 --> 00:03:40,560
Network high will not work address

76
00:03:40,560 --> 00:03:42,959
there are basically four types of drives

77
00:03:42,959 --> 00:03:45,239
but we can focus on two of them

78
00:03:45,239 --> 00:03:48,540
the first is unique Castle Choice it is

79
00:03:48,540 --> 00:03:51,720
an address for each individual node and

80
00:03:51,720 --> 00:03:54,299
the second is the group address it is an

81
00:03:54,299 --> 00:03:56,760
address for a group of nodes

82
00:03:56,760 --> 00:04:00,000
and in this example node B has a Unica

83
00:04:00,000 --> 00:04:03,420
suggest well node C and node D has the

84
00:04:03,420 --> 00:04:06,540
same group contrast so node a can send

85
00:04:06,540 --> 00:04:10,140
message to node B just by its unicast

86
00:04:10,140 --> 00:04:12,840
Flash and the node a can send a message

87
00:04:12,840 --> 00:04:16,260
to C and D at the same time by their

88
00:04:16,260 --> 00:04:18,620
group address

89
00:04:18,620 --> 00:04:21,000
let's further understand the Bluetooth

90
00:04:21,000 --> 00:04:24,120
smash communication from a higher level

91
00:04:24,120 --> 00:04:27,120
Bluetooth smash adopts message oriented

92
00:04:27,120 --> 00:04:29,699
communication which is also known as

93
00:04:29,699 --> 00:04:32,100
publish and subscribed

94
00:04:32,100 --> 00:04:34,740
here publish means Sending message to a

95
00:04:34,740 --> 00:04:36,180
specific address

96
00:04:36,180 --> 00:04:39,020
a node can publish message to unicast

97
00:04:39,020 --> 00:04:43,020
address on Google just well subscribe

98
00:04:43,020 --> 00:04:45,720
means start to receive message with

99
00:04:45,720 --> 00:04:48,240
specific destination address

100
00:04:48,240 --> 00:04:51,900
no one can subscribe to a group address

101
00:04:51,900 --> 00:04:55,220
we also see the example

102
00:04:55,220 --> 00:04:59,820
these slides has have subscribed to the

103
00:04:59,820 --> 00:05:03,000
Google Translation well this switch can

104
00:05:03,000 --> 00:05:05,460
publish an all message to the Google

105
00:05:05,460 --> 00:05:09,660
transportation to turn on those lights

106
00:05:09,660 --> 00:05:12,720
so in summary Bluetooth smash is a

107
00:05:12,720 --> 00:05:16,139
networking Technology based on pre and

108
00:05:16,139 --> 00:05:18,240
the nodes can communicate with each

109
00:05:18,240 --> 00:05:21,080
other in the network

110
00:05:21,300 --> 00:05:24,000
okay in the second part we will analyze

111
00:05:24,000 --> 00:05:27,120
the attack surfaces of Bluetooth smash

112
00:05:27,120 --> 00:05:30,539
or resource scope include two aspects

113
00:05:30,539 --> 00:05:33,660
the first is protocol and the second is

114
00:05:33,660 --> 00:05:35,220
wrapper application

115
00:05:35,220 --> 00:05:38,000
here the protocol means Bluetooth smash

116
00:05:38,000 --> 00:05:41,580
specification which is proposed basic

117
00:05:41,580 --> 00:05:43,979
and wrapper application means software

118
00:05:43,979 --> 00:05:46,919
framework for providing Bluetooth smash

119
00:05:46,919 --> 00:05:50,340
capabilities to up layer applications

120
00:05:50,340 --> 00:05:52,919
and further we divide the protocol into

121
00:05:52,919 --> 00:05:56,520
two key stages the first is Network view

122
00:05:56,520 --> 00:05:58,860
stage and the second is Network control

123
00:05:58,860 --> 00:06:00,539
stage

124
00:06:00,539 --> 00:06:03,479
on the other hand in this research we

125
00:06:03,479 --> 00:06:05,280
focus on software implementation

126
00:06:05,280 --> 00:06:08,280
vulnerabilities of Bluetooth smash such

127
00:06:08,280 --> 00:06:11,460
as memory corruption

128
00:06:11,460 --> 00:06:13,740
but let's start with the network

129
00:06:13,740 --> 00:06:15,360
viewport local

130
00:06:15,360 --> 00:06:18,180
Network view is a process in which new

131
00:06:18,180 --> 00:06:21,419
devices join the mesh network with the

132
00:06:21,419 --> 00:06:24,180
help of a match kit week

133
00:06:24,180 --> 00:06:26,880
formerly the network field is called

134
00:06:26,880 --> 00:06:29,880
providing it and the mesh Gateway is

135
00:06:29,880 --> 00:06:33,180
called provisioner and the new device is

136
00:06:33,180 --> 00:06:35,520
called unprovising device

137
00:06:35,520 --> 00:06:37,919
Network build protocol contains file

138
00:06:37,919 --> 00:06:40,139
procedures but we just need to know the

139
00:06:40,139 --> 00:06:41,880
overview that's okay

140
00:06:41,880 --> 00:06:45,240
and provided device for the standard

141
00:06:45,240 --> 00:06:47,940
specific Beacon to the provisioner to

142
00:06:47,940 --> 00:06:50,280
announce that that I want to join in the

143
00:06:50,280 --> 00:06:53,220
mesh Network and provide another build

144
00:06:53,220 --> 00:06:56,580
Link with the unprovising device and

145
00:06:56,580 --> 00:06:59,160
then both of them provide some necessary

146
00:06:59,160 --> 00:07:01,380
information to each other

147
00:07:01,380 --> 00:07:04,740
and here is a critical point the

148
00:07:04,740 --> 00:07:07,199
provisioner and unprovising device will

149
00:07:07,199 --> 00:07:10,259
calculate a shared key using ecthr

150
00:07:10,259 --> 00:07:13,560
algorithm and use the shared key to

151
00:07:13,560 --> 00:07:16,220
increase something for Authentication

152
00:07:16,220 --> 00:07:19,380
we should not decide the authentication

153
00:07:19,380 --> 00:07:22,580
is often based on some window specific

154
00:07:22,580 --> 00:07:26,460
parameters which means that a device of

155
00:07:26,460 --> 00:07:29,460
window a may not be able to join the

156
00:07:29,460 --> 00:07:32,520
mesh Network through a provisioner of

157
00:07:32,520 --> 00:07:34,460
window p

158
00:07:34,460 --> 00:07:37,759
and finally the provisioning style

159
00:07:37,759 --> 00:07:40,080
unprovising device will send the link

160
00:07:40,080 --> 00:07:43,440
close to the provider to end this link

161
00:07:43,440 --> 00:07:46,979
and also notice that if providing Fields

162
00:07:46,979 --> 00:07:49,319
provider can also send link close to

163
00:07:49,319 --> 00:07:52,400
unprovising device

164
00:07:53,520 --> 00:07:56,580
next we need to take a further look at

165
00:07:56,580 --> 00:07:58,919
providing a massive format

166
00:07:58,919 --> 00:08:02,880
in fact all the message used in

167
00:08:02,880 --> 00:08:06,360
providing follows these formats we can

168
00:08:06,360 --> 00:08:09,360
see the whole package is just a

169
00:08:09,360 --> 00:08:12,780
Bluetooth low energy advertising packet

170
00:08:12,780 --> 00:08:16,440
which means that the Bluetooth smash is

171
00:08:16,440 --> 00:08:18,900
actually built on top of the Bluetooth

172
00:08:18,900 --> 00:08:20,360
low energy

173
00:08:20,360 --> 00:08:24,060
and the data related to providing are

174
00:08:24,060 --> 00:08:25,280
all here

175
00:08:25,280 --> 00:08:29,639
in the generic providing pdu and

176
00:08:29,639 --> 00:08:32,580
especially in these two in the

177
00:08:32,580 --> 00:08:34,919
transaction star pdu and the transaction

178
00:08:34,919 --> 00:08:38,640
to dupu so how the mesh protocol

179
00:08:38,640 --> 00:08:41,820
implementation pass the generic

180
00:08:41,820 --> 00:08:45,200
providing pu is the key point of

181
00:08:45,200 --> 00:08:48,839
vulnerability mining

182
00:08:48,839 --> 00:08:52,440
okay let us see the time surfaces of the

183
00:08:52,440 --> 00:08:54,420
network build stage

184
00:08:54,420 --> 00:08:57,660
first we need to decide when to attack

185
00:08:57,660 --> 00:09:00,420
we think the attack should be carried

186
00:09:00,420 --> 00:09:04,380
out before the authentication because in

187
00:09:04,380 --> 00:09:07,080
these procedures no actual information

188
00:09:07,080 --> 00:09:10,920
is required so the attack is applicable

189
00:09:10,920 --> 00:09:15,560
to any Windows specific device

190
00:09:15,560 --> 00:09:18,779
and next we need to decide what to

191
00:09:18,779 --> 00:09:19,500
attack

192
00:09:19,500 --> 00:09:24,300
and after our study we found that the

193
00:09:24,300 --> 00:09:26,220
segmentation and for example the

194
00:09:26,220 --> 00:09:29,160
mechanism is a perfect Target

195
00:09:29,160 --> 00:09:32,040
the segmentation and reassembly are

196
00:09:32,040 --> 00:09:34,740
designed for transmitting extremely long

197
00:09:34,740 --> 00:09:38,880
data it is relied through these two the

198
00:09:38,880 --> 00:09:40,860
transactions started new and the

199
00:09:40,860 --> 00:09:43,019
transaction continue PU

200
00:09:43,019 --> 00:09:45,600
here the transaction star pu is the

201
00:09:45,600 --> 00:09:48,000
first segment under transaction continue

202
00:09:48,000 --> 00:09:51,060
pdu at the beginning

203
00:09:51,060 --> 00:09:54,600
we considered the cemented binary

204
00:09:54,600 --> 00:09:57,779
assembly as perfect Target because it is

205
00:09:57,779 --> 00:10:00,480
a general mechanism so that supported by

206
00:10:00,480 --> 00:10:03,120
other mesh devices I mean while

207
00:10:03,120 --> 00:10:06,600
receiving and caching segmented packet

208
00:10:06,600 --> 00:10:09,899
involved memory operation which are very

209
00:10:09,899 --> 00:10:13,019
likely to cause memory corruption

210
00:10:13,019 --> 00:10:17,339
so we can attack the segmentation and

211
00:10:17,339 --> 00:10:20,580
resembly by mutated lines related fields

212
00:10:20,580 --> 00:10:23,100
of transaction star pu and the

213
00:10:23,100 --> 00:10:26,399
transaction continue view the fields are

214
00:10:26,399 --> 00:10:30,779
icgn totalized under segment index

215
00:10:30,779 --> 00:10:33,120
and we will show are automatically

216
00:10:33,120 --> 00:10:36,980
fasting tool for this purpose later

217
00:10:38,339 --> 00:10:41,279
in summary the thread model of a network

218
00:10:41,279 --> 00:10:44,579
build attack surface are shown here the

219
00:10:44,579 --> 00:10:47,959
attacker can be either a provisioner or

220
00:10:47,959 --> 00:10:51,000
an unprovising device

221
00:10:51,000 --> 00:10:53,339
followed by the provider it can send

222
00:10:53,339 --> 00:10:56,700
amount from segmented package to victim

223
00:10:56,700 --> 00:11:00,480
and providing device after building link

224
00:11:00,480 --> 00:11:03,660
and the vulnerability will be triggered

225
00:11:03,660 --> 00:11:07,380
on waiting during its real assembly

226
00:11:07,380 --> 00:11:10,980
and similarly a tight unprovising device

227
00:11:10,980 --> 00:11:13,320
can send mail from the segmenting

228
00:11:13,320 --> 00:11:16,200
package to the victim provider after

229
00:11:16,200 --> 00:11:19,380
receiving the providing invite

230
00:11:19,380 --> 00:11:21,800
here

231
00:11:23,160 --> 00:11:24,180
okay

232
00:11:24,180 --> 00:11:26,760
next let's see the network control

233
00:11:26,760 --> 00:11:27,959
protocol

234
00:11:27,959 --> 00:11:31,079
Network control is a precise data one

235
00:11:31,079 --> 00:11:34,079
device and message to other devices

236
00:11:34,079 --> 00:11:37,380
for example a switch can send some

237
00:11:37,380 --> 00:11:40,079
message to the lights to turn on those

238
00:11:40,079 --> 00:11:43,320
lights we call it Network control

239
00:11:43,320 --> 00:11:46,140
and the network control protocol follows

240
00:11:46,140 --> 00:11:49,019
a layered architecture and they are

241
00:11:49,019 --> 00:11:50,820
totally eight layers

242
00:11:50,820 --> 00:11:53,339
here we can just focus on the network

243
00:11:53,339 --> 00:11:57,180
layer and the transport layer here

244
00:11:57,180 --> 00:11:59,820
in network layer they are network

245
00:11:59,820 --> 00:12:03,180
address including the social trans SRC

246
00:12:03,180 --> 00:12:07,339
and the destination address DST

247
00:12:07,339 --> 00:12:10,740
and in transport layer or most

248
00:12:10,740 --> 00:12:13,800
specifically in the lower transport

249
00:12:13,800 --> 00:12:17,279
layer there are Fields designed for the

250
00:12:17,279 --> 00:12:19,620
segmentation and real assembly

251
00:12:19,620 --> 00:12:22,740
well yes the network control also

252
00:12:22,740 --> 00:12:25,440
supports the segmentation and with

253
00:12:25,440 --> 00:12:28,459
assembly mechanism

254
00:12:30,300 --> 00:12:33,360
double to smash natively supports some

255
00:12:33,360 --> 00:12:36,360
security features and one of the main

256
00:12:36,360 --> 00:12:39,620
security features is the message of

257
00:12:39,620 --> 00:12:42,420
application and encryption

258
00:12:42,420 --> 00:12:45,240
in Bluetooth smash there are two keys

259
00:12:45,240 --> 00:12:48,360
for the encryption and they are known as

260
00:12:48,360 --> 00:12:51,120
Knight key and apt key

261
00:12:51,120 --> 00:12:54,180
the Knight key is used to obfuscate and

262
00:12:54,180 --> 00:12:57,180
encrypt fields of network layer here

263
00:12:57,180 --> 00:13:00,480
and the APB key is used to encrypt the

264
00:13:00,480 --> 00:13:04,139
fields of upper transport layer here

265
00:13:04,139 --> 00:13:08,040
I enhance if we have no keys we can only

266
00:13:08,040 --> 00:13:11,760
know the IBI ID at the next time I see

267
00:13:11,760 --> 00:13:16,800
here because they are in raw uh but if

268
00:13:16,800 --> 00:13:19,500
we have the net key then we can pass the

269
00:13:19,500 --> 00:13:21,959
whole much more clear and the whole

270
00:13:21,959 --> 00:13:24,720
lower transport layer

271
00:13:24,720 --> 00:13:28,680
and if we have Knight key and APB key we

272
00:13:28,680 --> 00:13:31,760
can pass the whole message

273
00:13:33,120 --> 00:13:37,019
okay next let's see the attack surfaces

274
00:13:37,019 --> 00:13:39,440
of network control stage

275
00:13:39,440 --> 00:13:42,600
similar to the network view stage we

276
00:13:42,600 --> 00:13:44,700
found that segmentation and the real

277
00:13:44,700 --> 00:13:48,360
assembly mechanism is an ideal tax

278
00:13:48,360 --> 00:13:51,480
Target in the network control stage

279
00:13:51,480 --> 00:13:54,180
in addition to the reason that it is a

280
00:13:54,180 --> 00:13:56,940
general mechanism and involves memory

281
00:13:56,940 --> 00:14:00,420
operation it is also because that the

282
00:14:00,420 --> 00:14:03,240
segmentation unreasonably occurred in

283
00:14:03,240 --> 00:14:06,680
the lower transport layer

284
00:14:07,079 --> 00:14:10,920
so that only net key is required not apt

285
00:14:10,920 --> 00:14:11,820
key

286
00:14:11,820 --> 00:14:15,240
or what is this Advantage we need to

287
00:14:15,240 --> 00:14:17,579
know that all the devices within the

288
00:14:17,579 --> 00:14:20,040
network have the same night key but

289
00:14:20,040 --> 00:14:22,500
different device may have different APB

290
00:14:22,500 --> 00:14:23,279
key

291
00:14:23,279 --> 00:14:26,040
as long as the attacker joined in the

292
00:14:26,040 --> 00:14:28,260
match Network the net key can be

293
00:14:28,260 --> 00:14:31,860
obtained it means that the attacker can

294
00:14:31,860 --> 00:14:35,160
send main Siege malware message to any

295
00:14:35,160 --> 00:14:37,760
other device

296
00:14:38,040 --> 00:14:41,040
and we can also attack segmentation and

297
00:14:41,040 --> 00:14:44,160
reassembly by mutating the last related

298
00:14:44,160 --> 00:14:49,320
fields such as this control icgo icg and

299
00:14:49,320 --> 00:14:52,940
the second time here

300
00:14:53,000 --> 00:14:55,920
well those three model of network

301
00:14:55,920 --> 00:14:58,380
control attack surface is shown like

302
00:14:58,380 --> 00:14:59,279
this

303
00:14:59,279 --> 00:15:02,160
from this right model we can see in

304
00:15:02,160 --> 00:15:05,100
Bluetooth smash the attack Vector is no

305
00:15:05,100 --> 00:15:08,220
longer limited to the adjacent

306
00:15:08,220 --> 00:15:11,639
the attacker device a can send the mail

307
00:15:11,639 --> 00:15:16,199
while segmented package to nearby with

308
00:15:16,199 --> 00:15:20,820
him the devices and it can also sent to

309
00:15:20,820 --> 00:15:21,959
remote

310
00:15:21,959 --> 00:15:25,440
with Team device D with the help of the

311
00:15:25,440 --> 00:15:28,260
relay node life

312
00:15:28,260 --> 00:15:31,139
so vulnerabilities will be triggered on

313
00:15:31,139 --> 00:15:34,760
victim during the resembly

314
00:15:36,920 --> 00:15:39,600
we have finished the attack surface

315
00:15:39,600 --> 00:15:42,959
analysis for Bluetooth my protocol and

316
00:15:42,959 --> 00:15:45,240
finally let us find out the attack

317
00:15:45,240 --> 00:15:47,699
surfaces of bluetooth smart Shopper

318
00:15:47,699 --> 00:15:49,500
application

319
00:15:49,500 --> 00:15:52,860
first we need to Define what is a

320
00:15:52,860 --> 00:15:55,199
wrapper application

321
00:15:55,199 --> 00:15:58,199
this figure shows a typical framework of

322
00:15:58,199 --> 00:16:00,660
Bluetooth Smash in Android

323
00:16:00,660 --> 00:16:03,680
the mesh capabilities are wrapped as

324
00:16:03,680 --> 00:16:07,500
airdr service provided by this process

325
00:16:07,500 --> 00:16:10,079
called the Android Bluetooth

326
00:16:10,079 --> 00:16:12,600
uh other

327
00:16:12,600 --> 00:16:15,420
Android app can utilize these

328
00:16:15,420 --> 00:16:18,959
capabilities through the airdr bundle

329
00:16:18,959 --> 00:16:22,800
for example Android app wants to send a

330
00:16:22,800 --> 00:16:26,459
message it can just call the

331
00:16:26,459 --> 00:16:28,920
corresponding interface provided by the

332
00:16:28,920 --> 00:16:32,160
main service and my service will then

333
00:16:32,160 --> 00:16:35,399
forward this call to the GI layer and

334
00:16:35,399 --> 00:16:37,800
the generator will do for this call to

335
00:16:37,800 --> 00:16:40,139
the whole layer finally to delete

336
00:16:40,139 --> 00:16:44,959
matched ISO uh well the live match.so

337
00:16:44,959 --> 00:16:48,180
will send the HCL command to Bluetooth

338
00:16:48,180 --> 00:16:53,540
chip to actually send a message out

339
00:16:53,699 --> 00:16:56,459
assume that the attacker is malware

340
00:16:56,459 --> 00:17:00,240
Android app and the attack battery is

341
00:17:00,240 --> 00:17:03,000
the malicious call then from this

342
00:17:03,000 --> 00:17:05,880
architecture we can see there are two

343
00:17:05,880 --> 00:17:07,799
main guitar surfaces

344
00:17:07,799 --> 00:17:11,880
the first we can attack the permission

345
00:17:11,880 --> 00:17:15,299
restriction of airdr service we can try

346
00:17:15,299 --> 00:17:17,160
to call the mesh service without

347
00:17:17,160 --> 00:17:20,880
Bluetooth permission and second we can

348
00:17:20,880 --> 00:17:23,880
attack the memory operation in gni and

349
00:17:23,880 --> 00:17:26,520
the whole year these two layers are

350
00:17:26,520 --> 00:17:29,660
often implemented by using C or CPP

351
00:17:29,660 --> 00:17:32,700
which are very likely to involve memory

352
00:17:32,700 --> 00:17:36,600
corruption vulnerabilities so we can try

353
00:17:36,600 --> 00:17:39,919
to call the mesh series with malformed

354
00:17:39,919 --> 00:17:43,679
parameters to see what happens

355
00:17:43,679 --> 00:17:46,260
so in conclusion permission restriction

356
00:17:46,260 --> 00:17:48,840
under memory operation are too many

357
00:17:48,840 --> 00:17:52,080
attack surfaces in wrap application and

358
00:17:52,080 --> 00:17:54,120
we will show more details in the case

359
00:17:54,120 --> 00:17:55,860
study part

360
00:17:55,860 --> 00:17:58,459
foreign

361
00:17:59,900 --> 00:18:03,480
part we will introduce BR image further

362
00:18:03,480 --> 00:18:05,940
advising 2 we designed to find the

363
00:18:05,940 --> 00:18:08,760
vulnerabilities in Bluetooth mesh

364
00:18:08,760 --> 00:18:11,039
protocol implementation

365
00:18:11,039 --> 00:18:14,280
and Oracle is too fast both Network

366
00:18:14,280 --> 00:18:17,400
build and network control stages

367
00:18:17,400 --> 00:18:21,360
so that the VRE my father is composed of

368
00:18:21,360 --> 00:18:25,799
two corresponding subsystems

369
00:18:26,520 --> 00:18:29,640
here is an overview of the network build

370
00:18:29,640 --> 00:18:31,020
further

371
00:18:31,020 --> 00:18:33,480
for fuzzing process there are several

372
00:18:33,480 --> 00:18:36,179
necessary things to do we need to

373
00:18:36,179 --> 00:18:38,940
generate test cases and we need to send

374
00:18:38,940 --> 00:18:41,580
them to the Target device and monitor

375
00:18:41,580 --> 00:18:44,160
the response from the target device to

376
00:18:44,160 --> 00:18:46,080
detect crash

377
00:18:46,080 --> 00:18:48,720
so PR image files will also follow this

378
00:18:48,720 --> 00:18:50,760
framework

379
00:18:50,760 --> 00:18:54,179
for the test case generation we Define a

380
00:18:54,179 --> 00:18:55,799
series of

381
00:18:55,799 --> 00:19:00,020
segmented package as a single test case

382
00:19:00,020 --> 00:19:04,380
like this and we generate them at once

383
00:19:04,380 --> 00:19:06,840
in each fuzzy Loop

384
00:19:06,840 --> 00:19:10,500
then our sender will first follow the

385
00:19:10,500 --> 00:19:13,200
normal providing procedure to build Link

386
00:19:13,200 --> 00:19:16,200
with the target device and when is

387
00:19:16,200 --> 00:19:19,200
father's turn to send message or sender

388
00:19:19,200 --> 00:19:22,559
will send each package of test case to

389
00:19:22,559 --> 00:19:24,360
the Target device

390
00:19:24,360 --> 00:19:27,179
meanwhile we monitor the response from

391
00:19:27,179 --> 00:19:30,240
the target device to detect crash you

392
00:19:30,240 --> 00:19:32,760
further do not receive the link closed

393
00:19:32,760 --> 00:19:36,059
from the target device which is expected

394
00:19:36,059 --> 00:19:39,840
to receive after a time interval and we

395
00:19:39,840 --> 00:19:43,260
will consider it as the crash happen

396
00:19:43,260 --> 00:19:44,100
yeah

397
00:19:44,100 --> 00:19:47,580
by the way monitoring log from serial

398
00:19:47,580 --> 00:19:51,660
Port is also a way to detect crash but

399
00:19:51,660 --> 00:19:54,900
different developer board may have

400
00:19:54,900 --> 00:19:56,580
different output

401
00:19:56,580 --> 00:19:59,820
so it may take more effort to adapt to

402
00:19:59,820 --> 00:20:02,360
each window

403
00:20:02,400 --> 00:20:06,840
so to the in the contrast the link

404
00:20:06,840 --> 00:20:09,240
closed-based crash detection method is

405
00:20:09,240 --> 00:20:12,200
small General

406
00:20:14,240 --> 00:20:18,059
and these two sequence diagrams show how

407
00:20:18,059 --> 00:20:20,280
the network build further works

408
00:20:20,280 --> 00:20:23,100
the first diagram shows the case that

409
00:20:23,100 --> 00:20:24,840
trigger vulnerability

410
00:20:24,840 --> 00:20:28,440
at first the father will generate a test

411
00:20:28,440 --> 00:20:31,440
case which is composed of several

412
00:20:31,440 --> 00:20:33,299
segmented packets

413
00:20:33,299 --> 00:20:36,140
then the father followed the normal

414
00:20:36,140 --> 00:20:39,539
providing procedure use Link with the

415
00:20:39,539 --> 00:20:40,980
target device

416
00:20:40,980 --> 00:20:44,580
and willing established the further

417
00:20:44,580 --> 00:20:47,400
start to send segmentally package as

418
00:20:47,400 --> 00:20:50,580
well as wait for the link clones

419
00:20:50,580 --> 00:20:54,179
assuming that this transport continued

420
00:20:54,179 --> 00:20:56,940
pdu triggers vulnerability causing the

421
00:20:56,940 --> 00:21:00,059
target device to crash then the target

422
00:21:00,059 --> 00:21:03,059
device will lost all the information for

423
00:21:03,059 --> 00:21:06,059
this providing session so it will never

424
00:21:06,059 --> 00:21:08,580
send link close to our father

425
00:21:08,580 --> 00:21:11,880
and we return to the father side the

426
00:21:11,880 --> 00:21:14,039
second timer has time out

427
00:21:14,039 --> 00:21:17,220
and the factor does not receive any link

428
00:21:17,220 --> 00:21:20,640
rules so the father will consider it as

429
00:21:20,640 --> 00:21:23,760
crash happen then save the crash log and

430
00:21:23,760 --> 00:21:26,480
clear time

431
00:21:26,580 --> 00:21:29,280
well the second diagram shows the case

432
00:21:29,280 --> 00:21:32,220
that not trigger One Vision

433
00:21:32,220 --> 00:21:36,720
assuming that this segmented packet is

434
00:21:36,720 --> 00:21:39,120
determined as invalid by the Target

435
00:21:39,120 --> 00:21:42,600
device and console check file under

436
00:21:42,600 --> 00:21:45,179
Target device send the link close to the

437
00:21:45,179 --> 00:21:48,059
father due to the check file then the

438
00:21:48,059 --> 00:21:50,700
father knows that this fuzzing Loop has

439
00:21:50,700 --> 00:21:54,600
failed so just reset the timer and start

440
00:21:54,600 --> 00:21:58,399
the next fast loop

441
00:21:59,460 --> 00:22:01,860
now we have established a fuzzy

442
00:22:01,860 --> 00:22:04,740
framework so the last work to do is to

443
00:22:04,740 --> 00:22:08,539
Define how to generate the test case

444
00:22:08,539 --> 00:22:12,059
uh a test case is composed of one

445
00:22:12,059 --> 00:22:15,480
transaction star pdu and a number of

446
00:22:15,480 --> 00:22:18,260
transaction continue PU

447
00:22:18,260 --> 00:22:21,480
when generating the test case we first

448
00:22:21,480 --> 00:22:25,220
randomize the package count one plus and

449
00:22:25,220 --> 00:22:27,900
and then we random

450
00:22:27,900 --> 00:22:31,380
the oxygen Total Lines data lines of the

451
00:22:31,380 --> 00:22:34,980
transaction star pu and we randomize the

452
00:22:34,980 --> 00:22:37,440
sh o data lines of the transaction

453
00:22:37,440 --> 00:22:38,940
continuity

454
00:22:38,940 --> 00:22:41,820
to form a test case

455
00:22:41,820 --> 00:22:45,960
and this is a example the father has

456
00:22:45,960 --> 00:22:48,720
generated parameters such as hydrogen

457
00:22:48,720 --> 00:22:52,080
and this test case finally calls the

458
00:22:52,080 --> 00:22:55,340
target device to crash

459
00:22:56,340 --> 00:22:59,460
okay let's move to the network control

460
00:22:59,460 --> 00:23:02,580
fuzzle Network control further is also

461
00:23:02,580 --> 00:23:05,460
composed of three main modules the test

462
00:23:05,460 --> 00:23:08,520
case generation Center receiver and the

463
00:23:08,520 --> 00:23:10,320
Crash detection

464
00:23:10,320 --> 00:23:13,799
a test case is also defined as a series

465
00:23:13,799 --> 00:23:16,860
of segmented packets

466
00:23:16,860 --> 00:23:20,220
and our father will send this cemented

467
00:23:20,220 --> 00:23:24,120
package to the Target device one by one

468
00:23:24,120 --> 00:23:27,000
on the notice that the sender will also

469
00:23:27,000 --> 00:23:29,880
send some prob package to the turkey

470
00:23:29,880 --> 00:23:32,220
device at the same time

471
00:23:32,220 --> 00:23:35,940
here the pro packets are valid segmented

472
00:23:35,940 --> 00:23:39,419
packets and they are used to detect the

473
00:23:39,419 --> 00:23:41,520
crash

474
00:23:41,520 --> 00:23:44,520
in normal case Target device will send

475
00:23:44,520 --> 00:23:47,400
sdks to the prop packets

476
00:23:47,400 --> 00:23:51,360
and SDK package contains response to

477
00:23:51,360 --> 00:23:54,299
multiple problems this is called the

478
00:23:54,299 --> 00:23:56,820
block SDK

479
00:23:56,820 --> 00:23:59,820
any further find that some institutes to

480
00:23:59,820 --> 00:24:02,880
the problems are missing then the crash

481
00:24:02,880 --> 00:24:05,400
is considered to happen

482
00:24:05,400 --> 00:24:08,700
by the way why we need the props rather

483
00:24:08,700 --> 00:24:11,220
than just monitoring the SDK to test

484
00:24:11,220 --> 00:24:13,679
case to detect crash

485
00:24:13,679 --> 00:24:16,980
uh this is because that missing SDK to

486
00:24:16,980 --> 00:24:20,340
test case may be caused by a crush but

487
00:24:20,340 --> 00:24:24,179
it may also be caused by the invalid

488
00:24:24,179 --> 00:24:26,820
package not being a set

489
00:24:26,820 --> 00:24:29,760
it is just hard to tell these two

490
00:24:29,760 --> 00:24:31,260
situation

491
00:24:31,260 --> 00:24:34,140
but for the problem missing is a key for

492
00:24:34,140 --> 00:24:36,600
prop must means crash

493
00:24:36,600 --> 00:24:40,520
so it's a battery indicator

494
00:24:41,900 --> 00:24:45,240
and these two sequence diagrams show how

495
00:24:45,240 --> 00:24:47,760
the network build further works the

496
00:24:47,760 --> 00:24:50,039
first diagram shows the case that

497
00:24:50,039 --> 00:24:51,780
trigger vulnerability

498
00:24:51,780 --> 00:24:55,380
I first father also generate a test case

499
00:24:55,380 --> 00:24:58,140
which is composed of several statement

500
00:24:58,140 --> 00:24:59,460
in the packets

501
00:24:59,460 --> 00:25:02,220
then the fight the father sent the first

502
00:25:02,220 --> 00:25:05,940
package to the Target device as well as

503
00:25:05,940 --> 00:25:08,760
the probe and we can see that the target

504
00:25:08,760 --> 00:25:11,780
device responds is key to both segmented

505
00:25:11,780 --> 00:25:16,919
and the prop that's correct and next the

506
00:25:16,919 --> 00:25:19,020
father send the second segmenting

507
00:25:19,020 --> 00:25:22,860
package but this package is not accepted

508
00:25:22,860 --> 00:25:26,279
as a Target device so no SDK to this

509
00:25:26,279 --> 00:25:27,900
package will be sent

510
00:25:27,900 --> 00:25:30,659
but we do not care that's okay

511
00:25:30,659 --> 00:25:34,500
and the father received the SDK to the

512
00:25:34,500 --> 00:25:37,860
pro so we know that the target device

513
00:25:37,860 --> 00:25:40,220
works fine

514
00:25:40,220 --> 00:25:44,100
and then the father sent the third

515
00:25:44,100 --> 00:25:47,400
segmenting package and the trigger crash

516
00:25:47,400 --> 00:25:49,440
on the target device

517
00:25:49,440 --> 00:25:52,620
a next father send prompt to the Target

518
00:25:52,620 --> 00:25:53,940
device

519
00:25:53,940 --> 00:25:57,120
and the note is the critical point

520
00:25:57,120 --> 00:25:59,940
if the mesh service on the target device

521
00:25:59,940 --> 00:26:04,020
is permanent Dot the father will find

522
00:26:04,020 --> 00:26:07,260
that the exactly to the probe is missing

523
00:26:07,260 --> 00:26:10,020
so that I know the crush has occurred

524
00:26:10,020 --> 00:26:13,020
this is the simplest case

525
00:26:13,020 --> 00:26:16,559
but even if the mesh service is not

526
00:26:16,559 --> 00:26:19,440
permanent done we can still detect the

527
00:26:19,440 --> 00:26:22,400
crash because we match class

528
00:26:22,400 --> 00:26:25,140
all the information about this

529
00:26:25,140 --> 00:26:27,360
segmentation and real sampling session

530
00:26:27,360 --> 00:26:28,860
has been lost

531
00:26:28,860 --> 00:26:32,460
so this SDK will only response to the

532
00:26:32,460 --> 00:26:35,340
last problem but missing the response to

533
00:26:35,340 --> 00:26:38,100
the first and the second part

534
00:26:38,100 --> 00:26:41,400
so if we found the missing we know that

535
00:26:41,400 --> 00:26:44,220
the mesh the service on the target

536
00:26:44,220 --> 00:26:47,159
device has crashed

537
00:26:47,159 --> 00:26:50,279
well for the case that not trigger

538
00:26:50,279 --> 00:26:53,279
vulnerability Factor will receive all

539
00:26:53,279 --> 00:26:56,100
the sdks to prompt and know that nothing

540
00:26:56,100 --> 00:26:58,459
happens

541
00:26:59,400 --> 00:27:02,279
the test case generation is similar to

542
00:27:02,279 --> 00:27:05,100
the network build we first decide how

543
00:27:05,100 --> 00:27:08,100
many segmented packets are included in a

544
00:27:08,100 --> 00:27:11,039
single test case and then we randomize

545
00:27:11,039 --> 00:27:14,700
the icg ic0 details under control

546
00:27:14,700 --> 00:27:18,120
uh these fields are related to the lines

547
00:27:18,120 --> 00:27:22,440
and here is an example the father has

548
00:27:22,440 --> 00:27:25,440
generally several concerned parameters

549
00:27:25,440 --> 00:27:28,380
and finally triggered the target device

550
00:27:28,380 --> 00:27:31,159
to crash

551
00:27:31,740 --> 00:27:35,640
okay this is the last part of our father

552
00:27:35,640 --> 00:27:39,000
we Implement our system based on the

553
00:27:39,000 --> 00:27:43,020
Nordic RF model and this module supports

554
00:27:43,020 --> 00:27:45,179
the sending and receiving of Bluetooth

555
00:27:45,179 --> 00:27:46,919
signals

556
00:27:46,919 --> 00:27:50,580
and in the aspect of software since the

557
00:27:50,580 --> 00:27:53,039
Bluetooth smash is built on top of

558
00:27:53,039 --> 00:27:56,279
Bluetooth low energy so we need to find

559
00:27:56,279 --> 00:27:59,400
out a tool that can sound raw bre

560
00:27:59,400 --> 00:28:01,200
packets first

561
00:28:01,200 --> 00:28:04,080
and here we utilize the screen tools

562
00:28:04,080 --> 00:28:05,940
driver for this purpose

563
00:28:05,940 --> 00:28:08,940
swim tools is a great open source tool

564
00:28:08,940 --> 00:28:12,360
that allows us customize the ere we are

565
00:28:12,360 --> 00:28:15,960
Tyson and thanks for their great work

566
00:28:15,960 --> 00:28:19,440
and next we implement the mesh protocol

567
00:28:19,440 --> 00:28:22,700
based on the match spec

568
00:28:22,700 --> 00:28:27,059
and this is called state that shows the

569
00:28:27,059 --> 00:28:30,900
details of network layer

570
00:28:30,900 --> 00:28:34,020
and finally we Implement our system

571
00:28:34,020 --> 00:28:38,600
based on our self-implemented protocol

572
00:28:38,900 --> 00:28:41,940
the fourth part is about our real world

573
00:28:41,940 --> 00:28:44,279
Wanna Be reminding of Bluetooth Smash

574
00:28:44,279 --> 00:28:48,299
and up to July 24 we have found a total

575
00:28:48,299 --> 00:28:51,480
of 17 issues covered eight well-known

576
00:28:51,480 --> 00:28:54,240
winners and obtained certain CPS

577
00:28:54,240 --> 00:28:57,659
and now other listed CVS have been fixed

578
00:28:57,659 --> 00:29:00,840
by windows in this part we will discuss

579
00:29:00,840 --> 00:29:03,240
the vulnerabilities in network field

580
00:29:03,240 --> 00:29:05,940
stage Network control stage and the

581
00:29:05,940 --> 00:29:08,779
router application

582
00:29:08,779 --> 00:29:11,880
the first case is an auto on right

583
00:29:11,880 --> 00:29:14,880
vulnerability in network view stage

584
00:29:14,880 --> 00:29:19,380
here we need to know two Fields the icgm

585
00:29:19,380 --> 00:29:22,860
and the total s

586
00:29:22,860 --> 00:29:26,399
and the scgm means number of segments it

587
00:29:26,399 --> 00:29:29,580
is the zero best value for example the

588
00:29:29,580 --> 00:29:32,760
icgm equals three means that the home

589
00:29:32,760 --> 00:29:35,820
message is divided into four segmented

590
00:29:35,820 --> 00:29:37,200
packets

591
00:29:37,200 --> 00:29:41,100
while the total lens means the total

592
00:29:41,100 --> 00:29:43,919
number of bytes in the whole message

593
00:29:43,919 --> 00:29:47,100
in a while it is Ice Age and the Total

594
00:29:47,100 --> 00:29:50,460
Lines should be matched for example if

595
00:29:50,460 --> 00:29:54,720
total s is 65 then the icgn should be 2

596
00:29:54,720 --> 00:29:58,980
which means that 65 bytes are divided

597
00:29:58,980 --> 00:30:02,419
into three segmented packets

598
00:30:02,419 --> 00:30:07,500
okay this is the vulnerability that the

599
00:30:07,500 --> 00:30:11,760
mesh SDK allows mismatched as it and

600
00:30:11,760 --> 00:30:15,360
total lens in the network view stage

601
00:30:15,360 --> 00:30:18,419
and in this case the attacker forced to

602
00:30:18,419 --> 00:30:20,640
send the transaction Star video to the

603
00:30:20,640 --> 00:30:24,480
victim with the Total Line 65 but with

604
00:30:24,480 --> 00:30:27,059
the oxygen 30.

605
00:30:27,059 --> 00:30:30,360
and the victim first picks up the total

606
00:30:30,360 --> 00:30:34,980
length Okay it's 35 so victim will lock

607
00:30:34,980 --> 00:30:38,880
it a 65 bytes buffer to catch all the

608
00:30:38,880 --> 00:30:42,659
segmented packets but next the weak team

609
00:30:42,659 --> 00:30:47,059
will pick up the Sigmund the oxygen

610
00:30:47,059 --> 00:30:50,640
inserted and it will consider that there

611
00:30:50,640 --> 00:30:53,520
are totally 31 practice to resume

612
00:30:53,520 --> 00:30:56,700
in fact that is incorrect

613
00:30:56,700 --> 00:31:00,240
so the attacker can just need to send to

614
00:31:00,240 --> 00:31:04,260
a male from the segmented packet who

615
00:31:04,260 --> 00:31:08,520
segmented the index is free and here

616
00:31:08,520 --> 00:31:12,059
since the 17 index free is smaller than

617
00:31:12,059 --> 00:31:13,620
the oxygen

618
00:31:13,620 --> 00:31:17,520
so this package will be catched and will

619
00:31:17,520 --> 00:31:20,039
be considered as valid

620
00:31:20,039 --> 00:31:24,120
but the segmented index 3 means that

621
00:31:24,120 --> 00:31:27,840
this is the force packet so this package

622
00:31:27,840 --> 00:31:30,299
will be catching here and the final

623
00:31:30,299 --> 00:31:33,860
release to the other one right

624
00:31:33,860 --> 00:31:37,620
uh here is the pork we first we will

625
00:31:37,620 --> 00:31:40,380
link with the victim and dance and the

626
00:31:40,380 --> 00:31:43,500
malformed segmenting package and this

627
00:31:43,500 --> 00:31:48,200
family leads to the crash of my stories

628
00:31:49,140 --> 00:31:50,159
okay

629
00:31:50,159 --> 00:31:52,740
the cycling case is an Autobahn red

630
00:31:52,740 --> 00:31:55,620
vulnerability in network control stage

631
00:31:55,620 --> 00:31:58,380
again we need to know these two Fields

632
00:31:58,380 --> 00:32:01,279
the icgn and icgo

633
00:32:01,279 --> 00:32:04,640
oxygen is also the number of segments

634
00:32:04,640 --> 00:32:08,460
and the Sho is similar to Sigmund index

635
00:32:08,460 --> 00:32:10,980
in network build protocol

636
00:32:10,980 --> 00:32:14,279
it is the offsite number indicates which

637
00:32:14,279 --> 00:32:18,059
segment the current package is

638
00:32:18,059 --> 00:32:21,740
and invalid case for a certain

639
00:32:21,740 --> 00:32:24,320
segmentation and real assembly session

640
00:32:24,320 --> 00:32:29,039
the icgm in all the segmented packets

641
00:32:29,039 --> 00:32:32,700
should be the same but in this by the

642
00:32:32,700 --> 00:32:37,380
case match SDK allows the oxygen to be

643
00:32:37,380 --> 00:32:39,360
inconsistent

644
00:32:39,360 --> 00:32:42,059
here the attacker first send the

645
00:32:42,059 --> 00:32:45,600
segmented package to the victim with the

646
00:32:45,600 --> 00:32:50,039
oxygen one under the scgo zero that's

647
00:32:50,039 --> 00:32:52,620
okay it means that there are two

648
00:32:52,620 --> 00:32:56,279
segmented packets in total and this is

649
00:32:56,279 --> 00:32:58,200
the first one

650
00:32:58,200 --> 00:33:01,320
and the victim will pick up the oxygen

651
00:33:01,320 --> 00:33:04,799
well since there are totally two packets

652
00:33:04,799 --> 00:33:08,220
to receive it's just lock it a buffer

653
00:33:08,220 --> 00:33:10,340
for this two package

654
00:33:10,340 --> 00:33:13,679
but next the attacker will send a mail

655
00:33:13,679 --> 00:33:20,159
from the package with icgn31 and sh02

656
00:33:20,159 --> 00:33:24,120
victim just to a check that the AC Joe

657
00:33:24,120 --> 00:33:28,080
here is smaller than the oxygen here and

658
00:33:28,080 --> 00:33:31,980
incorrectly consider it as the valid

659
00:33:31,980 --> 00:33:35,399
package and cache it into buffer

660
00:33:35,399 --> 00:33:40,860
uh again since the scgo is 2 this packet

661
00:33:40,860 --> 00:33:44,039
is considered as the third packet so

662
00:33:44,039 --> 00:33:46,919
this package will be cached out of bound

663
00:33:46,919 --> 00:33:52,399
and finally caused a Auto on right

664
00:33:52,980 --> 00:33:57,500
five minutes Mr Han five minutes

665
00:33:58,620 --> 00:34:01,860
we just changed the oxygen of different

666
00:34:01,860 --> 00:34:07,019
package and the first is one and the

667
00:34:07,019 --> 00:34:10,379
other are circular uh this finally leads

668
00:34:10,379 --> 00:34:13,320
to crash in Waiting device and from low

669
00:34:13,320 --> 00:34:16,440
we can see we can hijack the PC and r0

670
00:34:16,440 --> 00:34:19,739
so that this crash can lead to remote

671
00:34:19,739 --> 00:34:24,799
cubed cold ice cubes rce

672
00:34:25,020 --> 00:34:26,899
and now we are clear about the water

673
00:34:26,899 --> 00:34:30,239
abilities in mesh protocol next the

674
00:34:30,239 --> 00:34:32,040
let's see what happens in the rocket

675
00:34:32,040 --> 00:34:33,300
application

676
00:34:33,300 --> 00:34:35,699
the first vulnerability is a permission

677
00:34:35,699 --> 00:34:38,699
leak in mesh service

678
00:34:38,699 --> 00:34:42,119
it is discovered on Android platform

679
00:34:42,119 --> 00:34:44,639
although the services have some

680
00:34:44,639 --> 00:34:47,580
permission check but it treats all the

681
00:34:47,580 --> 00:34:49,619
foreground applications as per meter

682
00:34:49,619 --> 00:34:52,379
caller so that every application can

683
00:34:52,379 --> 00:34:55,020
call this service interface even they do

684
00:34:55,020 --> 00:34:57,420
not have any permission related to

685
00:34:57,420 --> 00:34:58,740
Bluetooth

686
00:34:58,740 --> 00:35:02,640
and here's the talk I trust the ABP with

687
00:35:02,640 --> 00:35:05,280
any without any permission can

688
00:35:05,280 --> 00:35:08,520
successfully call the life stories of

689
00:35:08,520 --> 00:35:11,099
course this vulnerability is an entry

690
00:35:11,099 --> 00:35:13,380
and more vulnerabilities can be

691
00:35:13,380 --> 00:35:14,880
triggered by calling the service

692
00:35:14,880 --> 00:35:18,420
interface with male formal parameters

693
00:35:18,420 --> 00:35:21,540
and here is an example this is a stack

694
00:35:21,540 --> 00:35:23,520
Overflow vulnerabilities in Bluetooth

695
00:35:23,520 --> 00:35:25,260
smash GTI

696
00:35:25,260 --> 00:35:27,960
and input touch my storage there is an

697
00:35:27,960 --> 00:35:30,359
interface that we see are array from the

698
00:35:30,359 --> 00:35:33,680
Color battery is passed from GI level

699
00:35:33,680 --> 00:35:37,859
from java layer to GI layer and copy

700
00:35:37,859 --> 00:35:40,980
into stack the vulnerability is that the

701
00:35:40,980 --> 00:35:43,320
memory copy doesn't check the lens of

702
00:35:43,320 --> 00:35:46,859
array so if user passes are overlast

703
00:35:46,859 --> 00:35:49,560
array to the interface it will cause the

704
00:35:49,560 --> 00:35:52,140
stack overflow

705
00:35:52,140 --> 00:35:53,599
foreign

706
00:35:53,599 --> 00:35:57,839
with summarize our work as follows from

707
00:35:57,839 --> 00:35:59,880
the study we know memory corruption

708
00:35:59,880 --> 00:36:02,339
vulnerabilities are very likely to occur

709
00:36:02,339 --> 00:36:05,420
in the segmentation and reassembling

710
00:36:05,420 --> 00:36:08,579
implementation and the security of

711
00:36:08,579 --> 00:36:11,280
wrapper application especially their

712
00:36:11,280 --> 00:36:13,920
permission are native also needs

713
00:36:13,920 --> 00:36:15,060
attention

714
00:36:15,060 --> 00:36:18,359
and the other listed CBE have been fixed

715
00:36:18,359 --> 00:36:19,680
by windows

716
00:36:19,680 --> 00:36:22,740
for the framework we plan to enhance our

717
00:36:22,740 --> 00:36:25,500
fighting system add feedback driven

718
00:36:25,500 --> 00:36:29,940
fasting strategy and all starting now is

719
00:36:29,940 --> 00:36:33,119
concentrate on the network layer and the

720
00:36:33,119 --> 00:36:35,820
low transport layer in the future we

721
00:36:35,820 --> 00:36:39,180
will do one or BT mining at uploads

722
00:36:39,180 --> 00:36:42,420
and also Bluetooth smash has a lot of

723
00:36:42,420 --> 00:36:46,440
interesting features such as gatd proxy

724
00:36:46,440 --> 00:36:49,800
we could explore the attack surfaces of

725
00:36:49,800 --> 00:36:52,099
jtt proxy protocol

726
00:36:52,099 --> 00:36:56,160
in the end we hope our work can help to

727
00:36:56,160 --> 00:37:00,300
improve the security of Bluetooth mesh

728
00:37:00,300 --> 00:37:02,700
thank you for listening any question

729
00:37:02,700 --> 00:37:04,920
please tell me and you can also contact

730
00:37:04,920 --> 00:37:09,440
with me on the swipe card thank you

731
00:37:09,660 --> 00:37:12,770
[Music]

732
00:37:16,099 --> 00:37:19,820
thank you

