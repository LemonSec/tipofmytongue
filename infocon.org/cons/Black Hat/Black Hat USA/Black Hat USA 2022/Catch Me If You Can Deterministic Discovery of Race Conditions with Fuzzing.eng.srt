1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,639 --> 00:00:09,840
now it's my pleasure to Welcome to the

3
00:00:09,840 --> 00:00:13,099
stage Ned Williamson

4
00:00:13,190 --> 00:00:18,180
[Applause]

5
00:00:18,180 --> 00:00:21,000
all right hello cool it's working

6
00:00:21,000 --> 00:00:22,500
uh

7
00:00:22,500 --> 00:00:23,880
without further Ado let's just get into

8
00:00:23,880 --> 00:00:26,340
it uh this talk is called catch me if

9
00:00:26,340 --> 00:00:29,160
you can uh kind of cliche someone else

10
00:00:29,160 --> 00:00:31,019
had the same phrase on one of their

11
00:00:31,019 --> 00:00:34,079
talks so sorry but uh we'll be talking

12
00:00:34,079 --> 00:00:36,540
about race condition fuzzing today so

13
00:00:36,540 --> 00:00:39,480
just a quick intro on me I've been a

14
00:00:39,480 --> 00:00:41,399
researcher at Google project zero for a

15
00:00:41,399 --> 00:00:42,800
couple years now

16
00:00:42,800 --> 00:00:44,579
I like

17
00:00:44,579 --> 00:00:47,820
uh fuzzing as my research interest and

18
00:00:47,820 --> 00:00:49,680
then low level

19
00:00:49,680 --> 00:00:52,200
security embedded systems browser IPC

20
00:00:52,200 --> 00:00:55,500
kernels as my I guess Target of my

21
00:00:55,500 --> 00:00:56,340
research

22
00:00:56,340 --> 00:01:00,059
so this talk I'll be uh

23
00:01:00,059 --> 00:01:01,680
on theme with that I'll be talking about

24
00:01:01,680 --> 00:01:04,019
research related to fuzzing and then how

25
00:01:04,019 --> 00:01:09,020
we can apply it to Kernel fuzzing on iOS

26
00:01:09,240 --> 00:01:12,180
so the thing I want to start with is

27
00:01:12,180 --> 00:01:13,740
uh you know this talk is mostly about

28
00:01:13,740 --> 00:01:16,500
addressing the problem of fuzzing for

29
00:01:16,500 --> 00:01:18,900
race conditions and more generally it's

30
00:01:18,900 --> 00:01:20,159
just about how to even deal with race

31
00:01:20,159 --> 00:01:21,299
conditions

32
00:01:21,299 --> 00:01:23,880
and someone who uses fuzzing a lot I'm

33
00:01:23,880 --> 00:01:25,320
pretty biased

34
00:01:25,320 --> 00:01:27,420
but just to introduce the problem here's

35
00:01:27,420 --> 00:01:29,880
just a small snippet I took

36
00:01:29,880 --> 00:01:33,000
of some bugs that were reported

37
00:01:33,000 --> 00:01:35,460
by my team in the past couple years and

38
00:01:35,460 --> 00:01:37,500
then a couple of these I think one of

39
00:01:37,500 --> 00:01:40,020
the the Android binder bug and dirty cow

40
00:01:40,020 --> 00:01:43,799
I just put there so uh just so you're

41
00:01:43,799 --> 00:01:44,820
familiar with maybe there's some more

42
00:01:44,820 --> 00:01:47,520
famous bugs as well but essentially

43
00:01:47,520 --> 00:01:51,000
these bugs have been

44
00:01:51,000 --> 00:01:53,280
um you know of high security criticality

45
00:01:53,280 --> 00:01:55,860
and

46
00:01:55,860 --> 00:01:57,360
really you know it's something we just

47
00:01:57,360 --> 00:01:58,619
continue to turn into and something that

48
00:01:58,619 --> 00:02:00,180
we need to address but we don't have any

49
00:02:00,180 --> 00:02:03,240
good tooling for it so

50
00:02:03,240 --> 00:02:05,040
I know I was frustrated by this and

51
00:02:05,040 --> 00:02:07,140
that's kind of over time I thought how

52
00:02:07,140 --> 00:02:09,060
can I address this and bring some

53
00:02:09,060 --> 00:02:11,000
automation to discovering these issues

54
00:02:11,000 --> 00:02:14,580
uh without relying on luck or pure human

55
00:02:14,580 --> 00:02:15,840
ingenuity

56
00:02:15,840 --> 00:02:17,220
so

57
00:02:17,220 --> 00:02:18,780
yeah this is the problem they're they're

58
00:02:18,780 --> 00:02:21,540
hard to find so we don't really have any

59
00:02:21,540 --> 00:02:24,120
better way to find them than static

60
00:02:24,120 --> 00:02:26,640
analysis or auditing which I would

61
00:02:26,640 --> 00:02:28,920
consider pretty similar and related

62
00:02:28,920 --> 00:02:32,540
so human other has to today

63
00:02:32,540 --> 00:02:35,819
realize that there's the potential for a

64
00:02:35,819 --> 00:02:38,040
race condition somewhere or at least to

65
00:02:38,040 --> 00:02:40,680
be aware of some specific pattern and

66
00:02:40,680 --> 00:02:43,440
then maybe write a static analysis

67
00:02:43,440 --> 00:02:47,340
maybe like a matcher on the syntax tree

68
00:02:47,340 --> 00:02:50,459
to find this specific case where a known

69
00:02:50,459 --> 00:02:52,800
buggy pattern occurs but we don't really

70
00:02:52,800 --> 00:02:55,940
have a nice way to find

71
00:02:55,940 --> 00:03:00,180
race condition bugs in general and maybe

72
00:03:00,180 --> 00:03:01,800
I shouldn't say in general but we just

73
00:03:01,800 --> 00:03:03,120
don't have an automated way to do this

74
00:03:03,120 --> 00:03:08,340
for bugs that we can describe the

75
00:03:08,340 --> 00:03:10,440
problem when we see it like we know when

76
00:03:10,440 --> 00:03:12,540
it crashes that there's a problem we

77
00:03:12,540 --> 00:03:14,159
don't have a way to actually search for

78
00:03:14,159 --> 00:03:16,319
those bugs without essentially knowing

79
00:03:16,319 --> 00:03:18,120
what we're looking for already so that's

80
00:03:18,120 --> 00:03:20,400
the the fundamental issue

81
00:03:20,400 --> 00:03:23,760
and fuzzing actually is generally pretty

82
00:03:23,760 --> 00:03:25,260
good at addressing this category of

83
00:03:25,260 --> 00:03:27,360
problem uh you don't necessarily need to

84
00:03:27,360 --> 00:03:29,220
know the

85
00:03:29,220 --> 00:03:31,440
form of the bug you're looking for you

86
00:03:31,440 --> 00:03:33,480
just need to know the property that

87
00:03:33,480 --> 00:03:35,580
you're trying to violate and so for

88
00:03:35,580 --> 00:03:37,620
security reasons you know mostly we look

89
00:03:37,620 --> 00:03:40,519
at memory safety as that property

90
00:03:40,519 --> 00:03:44,340
but earlier teammate Yvonne gave a talk

91
00:03:44,340 --> 00:03:47,519
on this xmpp stanza fuzzing and there he

92
00:03:47,519 --> 00:03:49,879
was trying to violate this property of

93
00:03:49,879 --> 00:03:52,379
consistency between parsers so it's not

94
00:03:52,379 --> 00:03:54,060
just memory corruption but generally

95
00:03:54,060 --> 00:03:55,980
fuzzing is pretty good at saying you

96
00:03:55,980 --> 00:03:57,599
know give me a property give me a way to

97
00:03:57,599 --> 00:03:59,040
interact with this program and I will

98
00:03:59,040 --> 00:04:01,140
try to find test cases that violate that

99
00:04:01,140 --> 00:04:03,480
property and that's actually a very nice

100
00:04:03,480 --> 00:04:06,239
thing for race conditions or timing

101
00:04:06,239 --> 00:04:08,640
issues because we might say if we see a

102
00:04:08,640 --> 00:04:10,439
use after free you know that's caused by

103
00:04:10,439 --> 00:04:11,640
a race condition we don't need to

104
00:04:11,640 --> 00:04:13,860
understand how that happened we just we

105
00:04:13,860 --> 00:04:15,900
know that fuzzing could observe it if it

106
00:04:15,900 --> 00:04:17,699
managed to trigger it but then the

107
00:04:17,699 --> 00:04:21,540
question is how do you actually fuzz so

108
00:04:21,540 --> 00:04:23,639
to actually address this problem we'll

109
00:04:23,639 --> 00:04:26,340
have to first cover how scheduling works

110
00:04:26,340 --> 00:04:29,400
and um don't worry I'm giving me an

111
00:04:29,400 --> 00:04:30,720
overview because I didn't remember how

112
00:04:30,720 --> 00:04:32,160
any of this worked when I started this

113
00:04:32,160 --> 00:04:35,759
project so this is a kind of a quick

114
00:04:35,759 --> 00:04:37,380
overview so I think that there's two

115
00:04:37,380 --> 00:04:39,479
there's a kind of an important partition

116
00:04:39,479 --> 00:04:43,020
over types of scheduling that you can do

117
00:04:43,020 --> 00:04:45,060
to kind of

118
00:04:45,060 --> 00:04:46,800
consider what we can test well and what

119
00:04:46,800 --> 00:04:47,940
we can't test well

120
00:04:47,940 --> 00:04:49,740
so what we can test well is cooperative

121
00:04:49,740 --> 00:04:51,600
scheduling and

122
00:04:51,600 --> 00:04:53,940
this is uh where I'll start with this

123
00:04:53,940 --> 00:04:56,960
little demonstration so how Cooperative

124
00:04:56,960 --> 00:04:59,580
scheduling looks is that all the threads

125
00:04:59,580 --> 00:05:01,860
are cooperating with each other they

126
00:05:01,860 --> 00:05:04,800
yield explicitly so say in this case we

127
00:05:04,800 --> 00:05:07,500
start execution in thread one

128
00:05:07,500 --> 00:05:09,300
this will continue along and at some

129
00:05:09,300 --> 00:05:12,000
point this thread says uh

130
00:05:12,000 --> 00:05:13,919
I'm ready to yield

131
00:05:13,919 --> 00:05:15,540
that goes to the scheduler and at this

132
00:05:15,540 --> 00:05:18,000
point the scheduler can decide

133
00:05:18,000 --> 00:05:19,320
okay I'm either going to switch back

134
00:05:19,320 --> 00:05:20,759
into thread one and continue or go to

135
00:05:20,759 --> 00:05:22,919
thread two in this case we'll go to

136
00:05:22,919 --> 00:05:24,300
thread two

137
00:05:24,300 --> 00:05:26,759
and execute all the way to the bottom

138
00:05:26,759 --> 00:05:29,340
there's no yield statement so then this

139
00:05:29,340 --> 00:05:30,840
thread terminates and we go back to the

140
00:05:30,840 --> 00:05:32,039
scheduler

141
00:05:32,039 --> 00:05:33,539
and then the scheduler says okay we'll

142
00:05:33,539 --> 00:05:35,039
only thread one is runnable in this

143
00:05:35,039 --> 00:05:36,840
little example and so we just go there

144
00:05:36,840 --> 00:05:38,880
and continue

145
00:05:38,880 --> 00:05:41,280
so now if we look at how primitive

146
00:05:41,280 --> 00:05:43,380
scheduling works it's actually very

147
00:05:43,380 --> 00:05:45,840
similar so we have the same example

148
00:05:45,840 --> 00:05:48,000
continue along there's some explicit

149
00:05:48,000 --> 00:05:50,160
yield maybe we're blocked on a lock

150
00:05:50,160 --> 00:05:51,900
maybe we just

151
00:05:51,900 --> 00:05:53,460
literally yield you know this is a

152
00:05:53,460 --> 00:05:55,400
assist call on some platforms

153
00:05:55,400 --> 00:05:58,220
go to the scheduler same thing happens

154
00:05:58,220 --> 00:06:00,660
but in this case at some point during

155
00:06:00,660 --> 00:06:02,639
the execution of thread 2 we get a timer

156
00:06:02,639 --> 00:06:04,800
interrupt or some other condition

157
00:06:04,800 --> 00:06:07,860
happens that preempts this thread

158
00:06:07,860 --> 00:06:09,720
and so this causes us to go back to the

159
00:06:09,720 --> 00:06:11,220
scheduler and the scheduler is faced

160
00:06:11,220 --> 00:06:13,500
with the decision again out of these two

161
00:06:13,500 --> 00:06:15,660
runnable threads which one do I run

162
00:06:15,660 --> 00:06:17,280
and here it might decide to actually

163
00:06:17,280 --> 00:06:19,139
continue with thread one

164
00:06:19,139 --> 00:06:21,780
and then resume this ends and then we

165
00:06:21,780 --> 00:06:24,840
come over to thread two so

166
00:06:24,840 --> 00:06:28,680
the important bit is that uh

167
00:06:28,680 --> 00:06:31,620
if there are assumptions about or if

168
00:06:31,620 --> 00:06:33,539
there's any safety issues or assumptions

169
00:06:33,539 --> 00:06:36,000
between the two threads that don't

170
00:06:36,000 --> 00:06:37,800
respect the fact that these preemptions

171
00:06:37,800 --> 00:06:39,720
could occur anywhere then we may have a

172
00:06:39,720 --> 00:06:42,419
bug and so we want to be able to address

173
00:06:42,419 --> 00:06:44,819
this problem with fuzzing

174
00:06:44,819 --> 00:06:47,220
now the the

175
00:06:47,220 --> 00:06:48,780
interesting bit and I guess my

176
00:06:48,780 --> 00:06:50,160
philosophy is I always try to start with

177
00:06:50,160 --> 00:06:51,960
something that I know works well and

178
00:06:51,960 --> 00:06:54,960
slowly add to it to strengthen or

179
00:06:54,960 --> 00:06:58,919
broaden what I can do so this is why I

180
00:06:58,919 --> 00:07:01,440
started with Cooperative scheduling

181
00:07:01,440 --> 00:07:03,479
you'll probably notice that these are

182
00:07:03,479 --> 00:07:05,460
essentially really similar they both

183
00:07:05,460 --> 00:07:07,860
have an execution context which is just

184
00:07:07,860 --> 00:07:10,160
a generic way of saying a thread

185
00:07:10,160 --> 00:07:11,940
they both

186
00:07:11,940 --> 00:07:14,460
can block our yield to a scheduler and

187
00:07:14,460 --> 00:07:15,660
the only difference release preemption

188
00:07:15,660 --> 00:07:17,840
just again has this additional

189
00:07:17,840 --> 00:07:21,000
property where at any point you have

190
00:07:21,000 --> 00:07:23,340
these yields that just kind of appear

191
00:07:23,340 --> 00:07:25,560
caused by interrupts or again other

192
00:07:25,560 --> 00:07:28,139
other conditions can could relate to it

193
00:07:28,139 --> 00:07:30,060
but this is a problem for fuzzing

194
00:07:30,060 --> 00:07:32,599
because this is hard to control

195
00:07:32,599 --> 00:07:35,460
and it also can lead to

196
00:07:35,460 --> 00:07:37,199
exponential blow up

197
00:07:37,199 --> 00:07:38,940
so the good news about Cooperative

198
00:07:38,940 --> 00:07:41,599
scheduling is that it is easy it

199
00:07:41,599 --> 00:07:43,800
Cooperative scheduling because it runs

200
00:07:43,800 --> 00:07:45,300
in order

201
00:07:45,300 --> 00:07:45,900
um

202
00:07:45,900 --> 00:07:47,400
if you think about that first example

203
00:07:47,400 --> 00:07:50,400
there's no random yields popping up it

204
00:07:50,400 --> 00:07:51,300
just

205
00:07:51,300 --> 00:07:53,460
it's all explicit so as long as you're

206
00:07:53,460 --> 00:07:54,900
running the program if you have a

207
00:07:54,900 --> 00:07:57,539
deterministic scheduler

208
00:07:57,539 --> 00:07:59,160
um there's no Randomness at all you can

209
00:07:59,160 --> 00:08:01,020
run the same test case over and over and

210
00:08:01,020 --> 00:08:03,240
it turns out that um this is something I

211
00:08:03,240 --> 00:08:05,759
leveraged back in 2018 when I did a

212
00:08:05,759 --> 00:08:09,840
chrome sandbox Escape exploit and

213
00:08:09,840 --> 00:08:11,220
I think at that point I was realizing

214
00:08:11,220 --> 00:08:12,240
like oh there's something kind of

215
00:08:12,240 --> 00:08:13,319
interesting here but you know maybe

216
00:08:13,319 --> 00:08:15,720
multi-threading will never be doable but

217
00:08:15,720 --> 00:08:17,280
at least

218
00:08:17,280 --> 00:08:19,560
when you have different tasks that are

219
00:08:19,560 --> 00:08:21,240
running asynchronously this kind of

220
00:08:21,240 --> 00:08:23,220
Cooperative thing uh

221
00:08:23,220 --> 00:08:24,780
there's really no issue for fuzzing

222
00:08:24,780 --> 00:08:25,800
needs

223
00:08:25,800 --> 00:08:28,259
so again when we get into preemptive

224
00:08:28,259 --> 00:08:32,820
scheduling where most programs live or a

225
00:08:32,820 --> 00:08:34,080
lot of programs live that we would like

226
00:08:34,080 --> 00:08:35,279
to fuzz

227
00:08:35,279 --> 00:08:37,320
uh this is something that's super hard

228
00:08:37,320 --> 00:08:38,820
to model like say you have multiple

229
00:08:38,820 --> 00:08:40,200
cores

230
00:08:40,200 --> 00:08:41,458
um you know threads running

231
00:08:41,458 --> 00:08:44,760
simultaneously or even a single core and

232
00:08:44,760 --> 00:08:46,560
these random preemptions and switching

233
00:08:46,560 --> 00:08:48,899
we really have no control here and even

234
00:08:48,899 --> 00:08:51,480
if we did uh

235
00:08:51,480 --> 00:08:54,899
we still have to search this exponential

236
00:08:54,899 --> 00:08:57,600
search space at every single instruction

237
00:08:57,600 --> 00:09:00,420
and again with the tools we have today

238
00:09:00,420 --> 00:09:04,140
if we even hit a bug by luck there's no

239
00:09:04,140 --> 00:09:05,820
guarantee it will reproduce so we just

240
00:09:05,820 --> 00:09:07,680
have to cross our fingers and hope maybe

241
00:09:07,680 --> 00:09:09,540
we hit something

242
00:09:09,540 --> 00:09:10,140
um

243
00:09:10,140 --> 00:09:12,360
and this has happened to me I have just

244
00:09:12,360 --> 00:09:14,459
stumbled into race condition bugs but it

245
00:09:14,459 --> 00:09:16,019
always bothered me that they weren't

246
00:09:16,019 --> 00:09:17,279
predictable

247
00:09:17,279 --> 00:09:19,140
so

248
00:09:19,140 --> 00:09:21,120
just to make a little more clear my

249
00:09:21,120 --> 00:09:24,480
initial work from 2018 and and on to

250
00:09:24,480 --> 00:09:26,880
about 2020 was that I would deal with

251
00:09:26,880 --> 00:09:29,040
this problem by converting preemptive

252
00:09:29,040 --> 00:09:31,279
targets to Cooperative targets by hand

253
00:09:31,279 --> 00:09:35,760
and so what that means is whenever I was

254
00:09:35,760 --> 00:09:38,279
fuzzing something that say had a garbage

255
00:09:38,279 --> 00:09:39,779
collecting thread in the background I

256
00:09:39,779 --> 00:09:41,459
just simply wouldn't spawn that thread I

257
00:09:41,459 --> 00:09:43,320
would just run the main thread and at

258
00:09:43,320 --> 00:09:45,839
the end I would say well let's randomly

259
00:09:45,839 --> 00:09:47,700
run garbage collection and just call

260
00:09:47,700 --> 00:09:49,260
that function but

261
00:09:49,260 --> 00:09:50,820
there would always be just one thread

262
00:09:50,820 --> 00:09:51,899
running

263
00:09:51,899 --> 00:09:54,000
and so the nice thing is this is super

264
00:09:54,000 --> 00:09:55,920
easy to implement in like a hacky way

265
00:09:55,920 --> 00:09:58,140
for different fuzzing projects

266
00:09:58,140 --> 00:10:00,959
um I used this on Android NFC because

267
00:10:00,959 --> 00:10:02,760
the threading model was simple enough I

268
00:10:02,760 --> 00:10:04,440
could just replace with with a

269
00:10:04,440 --> 00:10:06,540
Cooperative scheduler

270
00:10:06,540 --> 00:10:09,480
but the problem is on larger targets

271
00:10:09,480 --> 00:10:11,220
there are more complex real world well

272
00:10:11,220 --> 00:10:13,920
Android's real world but you know

273
00:10:13,920 --> 00:10:16,260
the rest of the world uh it gets really

274
00:10:16,260 --> 00:10:18,180
hard because

275
00:10:18,180 --> 00:10:19,500
we

276
00:10:19,500 --> 00:10:22,620
can't support blocking if you simply

277
00:10:22,620 --> 00:10:24,060
just don't spawn a thread and you don't

278
00:10:24,060 --> 00:10:26,399
do the work that Fred would have done at

279
00:10:26,399 --> 00:10:29,779
this very coarse Grant High Level we

280
00:10:29,779 --> 00:10:32,220
just have no way to handle say you you

281
00:10:32,220 --> 00:10:34,019
call some syscall that you're fuzzing

282
00:10:34,019 --> 00:10:37,680
and it blocks uh well there's no notion

283
00:10:37,680 --> 00:10:39,600
of background work like now you are the

284
00:10:39,600 --> 00:10:40,860
background work and something else has

285
00:10:40,860 --> 00:10:44,339
to happen so uh I had this idea that

286
00:10:44,339 --> 00:10:47,100
well why don't I

287
00:10:47,100 --> 00:10:49,200
at least try to create a deterministic

288
00:10:49,200 --> 00:10:52,380
Threading Library so at least

289
00:10:52,380 --> 00:10:54,959
I can spawn multiple threads they're

290
00:10:54,959 --> 00:10:56,640
really not going to be running actually

291
00:10:56,640 --> 00:10:58,560
in parallel they're all be on one CPU

292
00:10:58,560 --> 00:10:59,880
but at least I can switch between them

293
00:10:59,880 --> 00:11:01,320
and kind of get around the blocking

294
00:11:01,320 --> 00:11:03,180
problem

295
00:11:03,180 --> 00:11:04,560
um

296
00:11:04,560 --> 00:11:07,980
so to implement this I thought well okay

297
00:11:07,980 --> 00:11:09,060
let's

298
00:11:09,060 --> 00:11:11,160
do what already works we use only one

299
00:11:11,160 --> 00:11:12,140
thread

300
00:11:12,140 --> 00:11:14,279
you know we already have multi-thread

301
00:11:14,279 --> 00:11:17,640
programs running on one CPU this is a

302
00:11:17,640 --> 00:11:20,940
reasonable thing to assume for testing

303
00:11:20,940 --> 00:11:22,320
and

304
00:11:22,320 --> 00:11:24,360
we're going to need to interrupt

305
00:11:24,360 --> 00:11:26,220
anything related to scheduling and

306
00:11:26,220 --> 00:11:28,500
multiple contexts so in this case this

307
00:11:28,500 --> 00:11:30,600
is basically anything related to threads

308
00:11:30,600 --> 00:11:34,680
or sync Primitives like mutexes reader

309
00:11:34,680 --> 00:11:37,980
writer locks condition variables

310
00:11:37,980 --> 00:11:39,240
um and then we just create our own

311
00:11:39,240 --> 00:11:41,459
scheduler that kind of owns all this

312
00:11:41,459 --> 00:11:43,500
context so it will own the threads that

313
00:11:43,500 --> 00:11:45,600
exist which ones are runnable the

314
00:11:45,600 --> 00:11:48,000
mutexes and synchromatives will interact

315
00:11:48,000 --> 00:11:50,040
with the scheduler and let it know my

316
00:11:50,040 --> 00:11:51,420
thread's blocked waiting for this other

317
00:11:51,420 --> 00:11:54,000
thread to finish and so if we have these

318
00:11:54,000 --> 00:11:55,200
components

319
00:11:55,200 --> 00:11:56,040
um

320
00:11:56,040 --> 00:12:01,200
we can at least encapsulate all the uh

321
00:12:01,200 --> 00:12:03,000
things related to multi-threading and

322
00:12:03,000 --> 00:12:04,620
then we can just make this deterministic

323
00:12:04,620 --> 00:12:06,060
just for testing

324
00:12:06,060 --> 00:12:09,360
so far nothing new here uh

325
00:12:09,360 --> 00:12:13,560
but uh so uh I guess the project I began

326
00:12:13,560 --> 00:12:16,260
working on uh called concurrence but

327
00:12:16,260 --> 00:12:18,959
still kind of TBD how to name this I

328
00:12:18,959 --> 00:12:21,839
don't know but uh it's sticking uh so

329
00:12:21,839 --> 00:12:23,160
essentially what I did is I created

330
00:12:23,160 --> 00:12:24,899
these few components to help me with

331
00:12:24,899 --> 00:12:27,660
this problem uh the first is an Executor

332
00:12:27,660 --> 00:12:29,820
which essentially

333
00:12:29,820 --> 00:12:32,040
provides the sub primitive of creating

334
00:12:32,040 --> 00:12:34,680
deleting and switching between threads

335
00:12:34,680 --> 00:12:36,120
or contexts

336
00:12:36,120 --> 00:12:38,760
and then a scheduler that will look at

337
00:12:38,760 --> 00:12:39,899
these

338
00:12:39,899 --> 00:12:42,360
you know contexts that are runnable and

339
00:12:42,360 --> 00:12:43,980
say uh

340
00:12:43,980 --> 00:12:45,839
you know you spawn a bunch of threads in

341
00:12:45,839 --> 00:12:47,579
the background and then you own the

342
00:12:47,579 --> 00:12:49,320
scheduler object and you just say run a

343
00:12:49,320 --> 00:12:51,300
bunch of work for me until no threads

344
00:12:51,300 --> 00:12:52,380
are runnable

345
00:12:52,380 --> 00:12:54,899
and then this way we can spawn a bunch

346
00:12:54,899 --> 00:12:56,339
of threads in the background for a

347
00:12:56,339 --> 00:12:59,220
fuzzing job and then just run until they

348
00:12:59,220 --> 00:13:01,320
complete then do some more operations

349
00:13:01,320 --> 00:13:03,300
get some more work cubed and kind of

350
00:13:03,300 --> 00:13:05,940
keep looping so

351
00:13:05,940 --> 00:13:08,040
it's not highlighted well in the slide

352
00:13:08,040 --> 00:13:09,779
but the the second line under the

353
00:13:09,779 --> 00:13:11,040
scheduler bullet

354
00:13:11,040 --> 00:13:12,600
um randomizing the order of runnable

355
00:13:12,600 --> 00:13:15,180
tasks using fuzzer data this is really

356
00:13:15,180 --> 00:13:17,820
one of the big insights here so it's not

357
00:13:17,820 --> 00:13:19,800
just that we are

358
00:13:19,800 --> 00:13:24,240
uh or I guess back in my Chrome days uh

359
00:13:24,240 --> 00:13:26,459
when I was doing cooperative

360
00:13:26,459 --> 00:13:28,200
fuzzing one of the things I would do is

361
00:13:28,200 --> 00:13:30,720
whenever the scheduler has a choice to

362
00:13:30,720 --> 00:13:32,339
pick a

363
00:13:32,339 --> 00:13:35,399
some runnable task to run

364
00:13:35,399 --> 00:13:37,200
um I realized oh why don't we just kind

365
00:13:37,200 --> 00:13:40,500
of if we're allowed by the model of that

366
00:13:40,500 --> 00:13:43,560
executor why don't we just try randomly

367
00:13:43,560 --> 00:13:44,940
switching between them as opposed to

368
00:13:44,940 --> 00:13:46,560
just doing them in order

369
00:13:46,560 --> 00:13:50,700
and so I included that idea here so the

370
00:13:50,700 --> 00:13:52,260
scheduler not only just keeps track of

371
00:13:52,260 --> 00:13:53,579
what's runnable and switches between

372
00:13:53,579 --> 00:13:55,440
them but rather than doing them purely

373
00:13:55,440 --> 00:13:57,180
in order

374
00:13:57,180 --> 00:13:58,620
um whenever we have a choice we'll just

375
00:13:58,620 --> 00:14:00,300
pick a random task to make it runnable

376
00:14:00,300 --> 00:14:03,060
and or not make runnable but to switch

377
00:14:03,060 --> 00:14:04,980
to it

378
00:14:04,980 --> 00:14:07,200
um and again this is kind of little

379
00:14:07,200 --> 00:14:08,459
details we don't really need to go into

380
00:14:08,459 --> 00:14:10,380
annotations semantics and all this but

381
00:14:10,380 --> 00:14:13,380
essentially uh we need to support yield

382
00:14:13,380 --> 00:14:15,180
and block as fundamental ways to tell

383
00:14:15,180 --> 00:14:19,260
the scheduler which threads are runnable

384
00:14:19,260 --> 00:14:20,579
and so

385
00:14:20,579 --> 00:14:22,620
this still hasn't really addressed this

386
00:14:22,620 --> 00:14:24,720
problem of preemption and initially I

387
00:14:24,720 --> 00:14:26,579
really had no hopes of dealing with this

388
00:14:26,579 --> 00:14:28,440
problem I thought well if I can at least

389
00:14:28,440 --> 00:14:29,700
make some kind of deterministic

390
00:14:29,700 --> 00:14:31,920
scheduler then my fuzzing will be

391
00:14:31,920 --> 00:14:34,019
reproducible maybe I can mess around

392
00:14:34,019 --> 00:14:35,639
with the schedule here and there and

393
00:14:35,639 --> 00:14:37,320
find some stuff

394
00:14:37,320 --> 00:14:37,980
um

395
00:14:37,980 --> 00:14:41,579
but then I realized that uh

396
00:14:41,579 --> 00:14:44,820
preemption really is yields and so I

397
00:14:44,820 --> 00:14:46,440
didn't initially realize this in the way

398
00:14:46,440 --> 00:14:49,079
that I showed it in the beginning but if

399
00:14:49,079 --> 00:14:51,000
we already have to support blocking and

400
00:14:51,000 --> 00:14:52,260
yielding

401
00:14:52,260 --> 00:14:53,100
um

402
00:14:53,100 --> 00:14:55,260
a motivated researcher might be able to

403
00:14:55,260 --> 00:14:57,120
insert their own yields to a couple

404
00:14:57,120 --> 00:14:59,579
places so

405
00:14:59,579 --> 00:15:01,139
even though preemption's off and

406
00:15:01,139 --> 00:15:02,699
everything is

407
00:15:02,699 --> 00:15:05,519
running into a box or running one at a

408
00:15:05,519 --> 00:15:08,820
time if we yield in a couple interesting

409
00:15:08,820 --> 00:15:11,639
places maybe we can let the pleasure

410
00:15:11,639 --> 00:15:13,380
switch contacts around those areas and

411
00:15:13,380 --> 00:15:15,420
see if there's any race condition bugs

412
00:15:15,420 --> 00:15:18,779
so that is a

413
00:15:18,779 --> 00:15:20,399
I guess that's posed the question of

414
00:15:20,399 --> 00:15:22,320
like is this an idea that even makes

415
00:15:22,320 --> 00:15:25,380
sense can you turn off all random

416
00:15:25,380 --> 00:15:27,120
preemption and pick a couple places to

417
00:15:27,120 --> 00:15:29,760
do it and actually find a useful bug

418
00:15:29,760 --> 00:15:31,380
and so

419
00:15:31,380 --> 00:15:34,320
I looked at a bug that I really was

420
00:15:34,320 --> 00:15:36,240
hoping I could find I didn't try to find

421
00:15:36,240 --> 00:15:39,060
this bug but I was thinking about this

422
00:15:39,060 --> 00:15:41,399
problem back in 2020 and I saw this bug

423
00:15:41,399 --> 00:15:44,579
report come into the Android bug Bounty

424
00:15:44,579 --> 00:15:47,820
I believe and this was a user mode to

425
00:15:47,820 --> 00:15:49,860
Kernel

426
00:15:49,860 --> 00:15:52,100
um I guess rce privilege escalation

427
00:15:52,100 --> 00:15:54,720
vulnerability that I think was exploited

428
00:15:54,720 --> 00:15:57,540
and

429
00:15:57,540 --> 00:16:00,300
this relied on a race condition so I

430
00:16:00,300 --> 00:16:02,279
looked at the description of the patch

431
00:16:02,279 --> 00:16:03,779
this is straight from the Linux change

432
00:16:03,779 --> 00:16:05,100
log

433
00:16:05,100 --> 00:16:06,839
and I don't know about you but when I

434
00:16:06,839 --> 00:16:08,279
looked at this I thought oh yeah no

435
00:16:08,279 --> 00:16:10,560
definitely this is uh this is too

436
00:16:10,560 --> 00:16:14,279
complex like how can a fuzzer replicate

437
00:16:14,279 --> 00:16:16,620
this you know uh

438
00:16:16,620 --> 00:16:19,620
but then I saw the diff and I realized

439
00:16:19,620 --> 00:16:23,100
this actually looks pretty simple

440
00:16:23,100 --> 00:16:25,380
uh I I guess what I was thinking is if I

441
00:16:25,380 --> 00:16:27,240
didn't know about a bug already being

442
00:16:27,240 --> 00:16:30,660
here in in binder uh

443
00:16:30,660 --> 00:16:32,820
what annotation what yield statement

444
00:16:32,820 --> 00:16:34,920
might have I've been able to add

445
00:16:34,920 --> 00:16:36,839
and so if you look at this diff uh all

446
00:16:36,839 --> 00:16:38,279
that's happened is you had this function

447
00:16:38,279 --> 00:16:39,680
at the top where they took a lock

448
00:16:39,680 --> 00:16:42,839
dequeued some work and then unlocked and

449
00:16:42,839 --> 00:16:44,699
returned the work

450
00:16:44,699 --> 00:16:47,639
and in the patch they kind of show that

451
00:16:47,639 --> 00:16:50,699
the problem is this W type field that

452
00:16:50,699 --> 00:16:52,880
was a part of the work

453
00:16:52,880 --> 00:16:55,740
became invalid like that it seems like w

454
00:16:55,740 --> 00:16:58,560
the W variable became freed after the

455
00:16:58,560 --> 00:17:01,320
lock was released and so

456
00:17:01,320 --> 00:17:04,559
it seems like oh you only really need to

457
00:17:04,559 --> 00:17:07,380
um preempt in one place to find this bug

458
00:17:07,380 --> 00:17:09,959
or search around one preemption point

459
00:17:09,959 --> 00:17:12,359
and that's right after the unlock of

460
00:17:12,359 --> 00:17:16,559
proc uh in the first function

461
00:17:16,559 --> 00:17:19,500
so then I looked back at this

462
00:17:19,500 --> 00:17:22,439
description and realized that despite

463
00:17:22,439 --> 00:17:24,419
all the complexity where they're

464
00:17:24,419 --> 00:17:27,000
explaining how this bug came about

465
00:17:27,000 --> 00:17:28,980
all that the fuzzer would need to do to

466
00:17:28,980 --> 00:17:31,200
find this issue is to

467
00:17:31,200 --> 00:17:33,720
preempt at those two places that I had

468
00:17:33,720 --> 00:17:37,740
hypothesized where this interlock you

469
00:17:37,740 --> 00:17:39,840
can see the first bold statement

470
00:17:39,840 --> 00:17:42,120
when we release it on the next line we

471
00:17:42,120 --> 00:17:44,400
acquire in thread two so we were doing

472
00:17:44,400 --> 00:17:46,200
something and then in

473
00:17:46,200 --> 00:17:48,120
thread one we dequeued that work and

474
00:17:48,120 --> 00:17:50,220
then we switched to thread two

475
00:17:50,220 --> 00:17:52,380
thread to Freed the node that we're

476
00:17:52,380 --> 00:17:55,200
looking at and then release the lock and

477
00:17:55,200 --> 00:17:55,919
then

478
00:17:55,919 --> 00:17:57,720
third one didn't need to require it but

479
00:17:57,720 --> 00:17:59,360
it just continued running

480
00:17:59,360 --> 00:18:01,679
and so

481
00:18:01,679 --> 00:18:04,260
I realized that the the critical path is

482
00:18:04,260 --> 00:18:06,120
immediately after these two release

483
00:18:06,120 --> 00:18:09,960
releases of the inner proc lock

484
00:18:09,960 --> 00:18:13,020
so you know this is where I had a real

485
00:18:13,020 --> 00:18:14,760
insight that like you know this is a bug

486
00:18:14,760 --> 00:18:15,780
that

487
00:18:15,780 --> 00:18:18,720
is critical you know we have no tools to

488
00:18:18,720 --> 00:18:21,179
find things like this but it only takes

489
00:18:21,179 --> 00:18:23,039
one preemption and it's a preemption in

490
00:18:23,039 --> 00:18:24,840
a place that seems obvious you know you

491
00:18:24,840 --> 00:18:26,280
have a whole subsystem that's really

492
00:18:26,280 --> 00:18:28,919
important that uses a lock in like two

493
00:18:28,919 --> 00:18:31,559
places I don't think it's unreasonable

494
00:18:31,559 --> 00:18:34,440
to Guess that a security researcher

495
00:18:34,440 --> 00:18:36,360
could say well given a fuzzer that can

496
00:18:36,360 --> 00:18:38,580
handle this situation I'm going to guess

497
00:18:38,580 --> 00:18:40,679
let's preempt before and after every

498
00:18:40,679 --> 00:18:42,360
lock let's preempt maybe in a few places

499
00:18:42,360 --> 00:18:45,780
and then it really is uh quite a small

500
00:18:45,780 --> 00:18:47,460
search space to cover

501
00:18:47,460 --> 00:18:49,140
and so

502
00:18:49,140 --> 00:18:51,240
this is the Insight we really need fewer

503
00:18:51,240 --> 00:18:53,480
preemptions than we think

504
00:18:53,480 --> 00:18:55,679
and it took me a long time to understand

505
00:18:55,679 --> 00:18:58,140
what was going on here because so much

506
00:18:58,140 --> 00:18:59,400
of it was just like intuition and

507
00:18:59,400 --> 00:19:01,440
experimentation but when I talk to

508
00:19:01,440 --> 00:19:03,240
people who know more about uh

509
00:19:03,240 --> 00:19:05,280
concurrency

510
00:19:05,280 --> 00:19:08,220
um I got this really great line from the

511
00:19:08,220 --> 00:19:11,340
author of a leak sanitizer or he said

512
00:19:11,340 --> 00:19:13,980
something like Race Free programs have

513
00:19:13,980 --> 00:19:15,539
no observable Behavior differences when

514
00:19:15,539 --> 00:19:17,820
preemption occurs between sync points

515
00:19:17,820 --> 00:19:19,799
it's like what is that it just means

516
00:19:19,799 --> 00:19:24,059
that uh if the programmer got it right

517
00:19:24,059 --> 00:19:25,919
um if you only have preemptions around

518
00:19:25,919 --> 00:19:27,780
locking that's enough to kind of see

519
00:19:27,780 --> 00:19:30,480
everything that can go wrong and so

520
00:19:30,480 --> 00:19:32,340
you know don't worry too much about

521
00:19:32,340 --> 00:19:34,380
understanding this but essentially there

522
00:19:34,380 --> 00:19:36,240
is some kind of core intuition about

523
00:19:36,240 --> 00:19:38,760
like where locks are placed are around

524
00:19:38,760 --> 00:19:40,260
the areas where bugs are going to

525
00:19:40,260 --> 00:19:42,660
manifest or it's very likely so I

526
00:19:42,660 --> 00:19:44,220
thought okay that's that's probably good

527
00:19:44,220 --> 00:19:45,360
and then

528
00:19:45,360 --> 00:19:48,960
if a researcher is skeptical of that

529
00:19:48,960 --> 00:19:50,880
well they can sprinkle a few yields

530
00:19:50,880 --> 00:19:54,419
themselves elsewhere and uh no problem

531
00:19:54,419 --> 00:19:57,059
so this is where I began to actually

532
00:19:57,059 --> 00:20:00,000
implement this by extending my existing

533
00:20:00,000 --> 00:20:03,240
iOS kernel fuzzer with this new project

534
00:20:03,240 --> 00:20:07,620
so the initial sacrificer project which

535
00:20:07,620 --> 00:20:10,860
is how I call this iOS kernel pleasure

536
00:20:10,860 --> 00:20:14,220
looks like this basically I use lib

537
00:20:14,220 --> 00:20:15,840
fuzzer as the fuzzing engine you could

538
00:20:15,840 --> 00:20:18,059
really use anything but

539
00:20:18,059 --> 00:20:19,980
what lib puzzer does is it collects

540
00:20:19,980 --> 00:20:22,260
coverage and mutates test cases for you

541
00:20:22,260 --> 00:20:24,240
similar to AFL

542
00:20:24,240 --> 00:20:27,419
and the type of input that it generates

543
00:20:27,419 --> 00:20:29,460
our protobuf messages that describe

544
00:20:29,460 --> 00:20:31,919
sequences of syscalls and you know other

545
00:20:31,919 --> 00:20:34,980
related things to one one test case

546
00:20:34,980 --> 00:20:37,320
and then it feeds these inputs to this

547
00:20:37,320 --> 00:20:39,600
fuzz Target function

548
00:20:39,600 --> 00:20:43,860
and then we call into the kernel uh in

549
00:20:43,860 --> 00:20:44,880
red

550
00:20:44,880 --> 00:20:47,539
with these syscalls in order and then

551
00:20:47,539 --> 00:20:49,919
this project is actually a completely

552
00:20:49,919 --> 00:20:53,160
user-based buzzer so

553
00:20:53,160 --> 00:20:53,760
um

554
00:20:53,760 --> 00:20:55,679
if you've used something if you're not

555
00:20:55,679 --> 00:20:58,140
familiar with something like gvisor or a

556
00:20:58,140 --> 00:20:59,160
similar

557
00:20:59,160 --> 00:21:00,480
uh

558
00:21:00,480 --> 00:21:02,160
like user space based like

559
00:21:02,160 --> 00:21:04,799
containerization of of a kernel that's

560
00:21:04,799 --> 00:21:06,120
essentially what we're doing here so

561
00:21:06,120 --> 00:21:10,440
rather than using a full hypervisor we

562
00:21:10,440 --> 00:21:13,679
just kind of uh run everything in user

563
00:21:13,679 --> 00:21:16,440
space and then when so in gvisor what

564
00:21:16,440 --> 00:21:18,360
happens is when your program tries to

565
00:21:18,360 --> 00:21:20,640
make a syscall it goes into some go code

566
00:21:20,640 --> 00:21:22,440
that handles the syscall for you and you

567
00:21:22,440 --> 00:21:23,580
don't have to actually go to the kernel

568
00:21:23,580 --> 00:21:25,559
so this is pretty similar but for a

569
00:21:25,559 --> 00:21:28,740
hypervisor so in the iOS kernel tries to

570
00:21:28,740 --> 00:21:30,780
access Hardware it just gets redirected

571
00:21:30,780 --> 00:21:32,400
to this hyper call interface that's

572
00:21:32,400 --> 00:21:34,740
handled all in user space so the result

573
00:21:34,740 --> 00:21:36,600
of this is I just have this whole user

574
00:21:36,600 --> 00:21:38,520
space buzzer I wish I could talk more

575
00:21:38,520 --> 00:21:39,659
about it I'm guessing like not everyone

576
00:21:39,659 --> 00:21:42,179
here knows about this but unfortunately

577
00:21:42,179 --> 00:21:43,140
I just don't have time to go into

578
00:21:43,140 --> 00:21:45,480
details so this is the existing project

579
00:21:45,480 --> 00:21:47,100
and so to

580
00:21:47,100 --> 00:21:49,860
add deterministic threading support to

581
00:21:49,860 --> 00:21:52,679
allow me to do blocking syscalls I added

582
00:21:52,679 --> 00:21:56,159
this concurrent code base so what this

583
00:21:56,159 --> 00:21:58,080
does is I have this extra scheduler and

584
00:21:58,080 --> 00:21:59,520
executor

585
00:21:59,520 --> 00:22:02,580
and so if I want to or if the kernel

586
00:22:02,580 --> 00:22:05,460
wants to create threads internally

587
00:22:05,460 --> 00:22:08,039
those are actually captured and sent to

588
00:22:08,039 --> 00:22:10,520
this hyper call interface

589
00:22:10,520 --> 00:22:14,299
this is handled through the scheduler

590
00:22:14,299 --> 00:22:17,100
component that I talked about

591
00:22:17,100 --> 00:22:19,500
and then ultimately these kernel threads

592
00:22:19,500 --> 00:22:22,559
are just handled in user Space by my

593
00:22:22,559 --> 00:22:24,780
my new project this this deterministic

594
00:22:24,780 --> 00:22:28,320
scheduling uh but the important bit is

595
00:22:28,320 --> 00:22:30,299
that the scheduler also has access to

596
00:22:30,299 --> 00:22:31,799
the fuzzer data so on the right side

597
00:22:31,799 --> 00:22:33,539
you'll see that Arrow go up

598
00:22:33,539 --> 00:22:36,720
get random numbers so what that's uh

599
00:22:36,720 --> 00:22:38,700
demonstrating is that

600
00:22:38,700 --> 00:22:40,320
whenever the scheduler has an option

601
00:22:40,320 --> 00:22:42,240
between switching between a number of

602
00:22:42,240 --> 00:22:45,419
runnable threads it will fetch a number

603
00:22:45,419 --> 00:22:47,340
right now I mean maybe in the future

604
00:22:47,340 --> 00:22:48,780
will be smarter but now it just fetches

605
00:22:48,780 --> 00:22:52,260
like the nth give me the uh I I it'll

606
00:22:52,260 --> 00:22:54,240
say like I have 10 runnable threads give

607
00:22:54,240 --> 00:22:56,520
me a number between 1 and 10.

608
00:22:56,520 --> 00:22:58,559
and it will draw that number from the

609
00:22:58,559 --> 00:23:00,419
test case so the fuzzer can mutate that

610
00:23:00,419 --> 00:23:03,260
and then thus mutate the schedule

611
00:23:03,260 --> 00:23:05,880
so now we're fuzzing along kind of two

612
00:23:05,880 --> 00:23:08,340
axes you have

613
00:23:08,340 --> 00:23:10,500
the syscalls themselves and the data

614
00:23:10,500 --> 00:23:13,140
related to those sys calls and just the

615
00:23:13,140 --> 00:23:14,700
normal operation of

616
00:23:14,700 --> 00:23:16,860
a single thread in the kernel but now

617
00:23:16,860 --> 00:23:19,380
you have this additional axis where the

618
00:23:19,380 --> 00:23:21,360
fuzzer can mutate the schedule of a

619
00:23:21,360 --> 00:23:22,940
given test case

620
00:23:22,940 --> 00:23:25,620
and so

621
00:23:25,620 --> 00:23:27,720
just so you have a little more concrete

622
00:23:27,720 --> 00:23:29,340
idea of what this looks like this is the

623
00:23:29,340 --> 00:23:31,679
data model for the fuzzer this is just a

624
00:23:31,679 --> 00:23:33,179
Proto buff message

625
00:23:33,179 --> 00:23:36,960
so in the current instantiation or

626
00:23:36,960 --> 00:23:38,520
whatever the current version of the

627
00:23:38,520 --> 00:23:42,179
fuzzer I have three threads that each

628
00:23:42,179 --> 00:23:44,760
execute different sys calls and then

629
00:23:44,760 --> 00:23:46,140
there's simply this bytes field that

630
00:23:46,140 --> 00:23:48,600
provides the scheduler data so in each

631
00:23:48,600 --> 00:23:50,220
of these three threads

632
00:23:50,220 --> 00:23:51,720
um they are

633
00:23:51,720 --> 00:23:54,000
they get a pointer to these protobuf for

634
00:23:54,000 --> 00:23:55,799
the different commands that they handle

635
00:23:55,799 --> 00:23:57,419
from these different threads

636
00:23:57,419 --> 00:24:00,240
we start running and then the scheduler

637
00:24:00,240 --> 00:24:01,919
just says okay thread one two and three

638
00:24:01,919 --> 00:24:03,780
start out as runnable let's just run

639
00:24:03,780 --> 00:24:05,940
them they'll do some execute some sys

640
00:24:05,940 --> 00:24:07,919
calls at some point they

641
00:24:07,919 --> 00:24:10,799
uh my block yields or maybe terminate

642
00:24:10,799 --> 00:24:13,020
and So eventually if we let the

643
00:24:13,020 --> 00:24:15,360
scheduler run until it's empty uh we'll

644
00:24:15,360 --> 00:24:18,000
have run everything and the interesting

645
00:24:18,000 --> 00:24:19,679
bit is that you know if any of these

646
00:24:19,679 --> 00:24:21,299
things cause some background thread to

647
00:24:21,299 --> 00:24:25,080
be created or to run all that will all

648
00:24:25,080 --> 00:24:27,900
be interleaved and fuzzed along with the

649
00:24:27,900 --> 00:24:31,440
three sets of syscall threads and then

650
00:24:31,440 --> 00:24:34,020
Y3 originally it was two but

651
00:24:34,020 --> 00:24:37,740
I had two threads in one process and

652
00:24:37,740 --> 00:24:39,659
then I decided to add an additional

653
00:24:39,659 --> 00:24:41,159
process with another thread to catch

654
00:24:41,159 --> 00:24:44,580
like cross process race conditions

655
00:24:44,580 --> 00:24:47,220
um and you know this all sounds smart

656
00:24:47,220 --> 00:24:49,260
but uh this is what it looks like it's

657
00:24:49,260 --> 00:24:50,580
really just you know I have my little

658
00:24:50,580 --> 00:24:52,440
scheduler thing it's kind of a pretty

659
00:24:52,440 --> 00:24:57,419
simple project and then to intercept the

660
00:24:57,419 --> 00:25:01,799
mutexes in xmu in the iOS kernel uh we

661
00:25:01,799 --> 00:25:02,820
just have something that looks like this

662
00:25:02,820 --> 00:25:05,640
so I just forward these calls to my

663
00:25:05,640 --> 00:25:08,400
virtual mutex which is the one that

664
00:25:08,400 --> 00:25:11,700
works with my scheduler and handles the

665
00:25:11,700 --> 00:25:14,400
yield and block calls but then I also

666
00:25:14,400 --> 00:25:16,620
have these additional yields before and

667
00:25:16,620 --> 00:25:18,780
after like taking a lock and after

668
00:25:18,780 --> 00:25:21,960
releasing it to kind of catch these type

669
00:25:21,960 --> 00:25:23,280
of issues that I was referring to

670
00:25:23,280 --> 00:25:26,159
earlier around locking

671
00:25:26,159 --> 00:25:28,080
um so we can kind of skip over this but

672
00:25:28,080 --> 00:25:29,880
essentially yeah for each test case I

673
00:25:29,880 --> 00:25:32,760
fork a process and then create threads

674
00:25:32,760 --> 00:25:34,320
in there run and then kill the process

675
00:25:34,320 --> 00:25:35,640
and so

676
00:25:35,640 --> 00:25:36,179
um

677
00:25:36,179 --> 00:25:38,220
if things go completely awry it's all

678
00:25:38,220 --> 00:25:41,159
contained to a single process

679
00:25:41,159 --> 00:25:43,440
um so when I started running this I

680
00:25:43,440 --> 00:25:46,559
quickly ran into uh I use after freebug

681
00:25:46,559 --> 00:25:48,539
and

682
00:25:48,539 --> 00:25:50,340
it's interesting because it's in IPC

683
00:25:50,340 --> 00:25:51,539
which is an area that's pretty

684
00:25:51,539 --> 00:25:53,460
interesting lately

685
00:25:53,460 --> 00:25:55,260
and so I looked at this is the test case

686
00:25:55,260 --> 00:25:56,700
that

687
00:25:56,700 --> 00:26:00,059
the fuzzer produced and I I had no

688
00:26:00,059 --> 00:26:02,159
influence over this it's completely

689
00:26:02,159 --> 00:26:04,980
straight out of the buzzer so I don't

690
00:26:04,980 --> 00:26:06,900
know if he's zoomed in or something yeah

691
00:26:06,900 --> 00:26:09,000
so here's I have a better format of it

692
00:26:09,000 --> 00:26:10,679
but as you can see it's fairly

693
00:26:10,679 --> 00:26:11,700
structured

694
00:26:11,700 --> 00:26:13,919
but again all I did was say

695
00:26:13,919 --> 00:26:14,880
um

696
00:26:14,880 --> 00:26:17,340
hear the syscalls here's what the

697
00:26:17,340 --> 00:26:19,020
structure of the data looks like for

698
00:26:19,020 --> 00:26:20,460
mock messages

699
00:26:20,460 --> 00:26:23,039
those contain this header with these

700
00:26:23,039 --> 00:26:26,039
enums in it it has these fields that

701
00:26:26,039 --> 00:26:27,659
represent ports and so I just kind of

702
00:26:27,659 --> 00:26:30,059
made a little description and

703
00:26:30,059 --> 00:26:33,000
uh this was enough to run into this use

704
00:26:33,000 --> 00:26:35,760
after free so if we look at

705
00:26:35,760 --> 00:26:38,279
um an easier to read representation what

706
00:26:38,279 --> 00:26:40,440
happened was we had a

707
00:26:40,440 --> 00:26:42,659
in the first thread thread zero we

708
00:26:42,659 --> 00:26:44,880
created two reply ports which are kind

709
00:26:44,880 --> 00:26:47,659
of like file descriptors

710
00:26:47,659 --> 00:26:50,520
then mock message override and mock

711
00:26:50,520 --> 00:26:52,500
message are the same thing they just

712
00:26:52,500 --> 00:26:55,200
both send a message and so

713
00:26:55,200 --> 00:26:56,840
this first message

714
00:26:56,840 --> 00:27:00,000
it sends to the remote Port one a

715
00:27:00,000 --> 00:27:03,900
message from Port 2. and also receives

716
00:27:03,900 --> 00:27:05,520
so if you see under options it says send

717
00:27:05,520 --> 00:27:06,600
and receive

718
00:27:06,600 --> 00:27:10,860
and we are making a send rate uh for the

719
00:27:10,860 --> 00:27:12,960
port so if you don't know about mock

720
00:27:12,960 --> 00:27:15,059
which I don't think I even knew when I

721
00:27:15,059 --> 00:27:17,760
found this test case uh all this means

722
00:27:17,760 --> 00:27:19,380
is like uh

723
00:27:19,380 --> 00:27:20,880
when we have these reply ports we're

724
00:27:20,880 --> 00:27:22,440
allowed to receive messages on them but

725
00:27:22,440 --> 00:27:23,880
we're not allowed to send messages from

726
00:27:23,880 --> 00:27:25,320
them because

727
00:27:25,320 --> 00:27:25,919
um

728
00:27:25,919 --> 00:27:27,960
there are special reports that someone

729
00:27:27,960 --> 00:27:29,659
can reply to us with

730
00:27:29,659 --> 00:27:32,039
so what this is doing is this is

731
00:27:32,039 --> 00:27:34,500
actually in a roundabout way the fuzzer

732
00:27:34,500 --> 00:27:36,179
realized oh if I create reply ports and

733
00:27:36,179 --> 00:27:38,460
I send this message to myself I can give

734
00:27:38,460 --> 00:27:40,200
myself this additional right so a human

735
00:27:40,200 --> 00:27:41,640
would never do this they would just call

736
00:27:41,640 --> 00:27:43,679
like create a mock port and it comes

737
00:27:43,679 --> 00:27:45,659
with both rights but just to show that

738
00:27:45,659 --> 00:27:47,760
this was random the fuzzer

739
00:27:47,760 --> 00:27:50,100
just stumbled into this pattern and it

740
00:27:50,100 --> 00:27:51,720
was enough to find a bug so the real bug

741
00:27:51,720 --> 00:27:53,700
comes in these next two messages

742
00:27:53,700 --> 00:27:55,980
so in the first thread we

743
00:27:55,980 --> 00:27:58,919
are sending a message to Port 2 from

744
00:27:58,919 --> 00:28:00,299
Port 2.

745
00:28:00,299 --> 00:28:03,240
and we're copying and moving our right

746
00:28:03,240 --> 00:28:05,640
to send messages on this port and the

747
00:28:05,640 --> 00:28:07,740
message

748
00:28:07,740 --> 00:28:09,600
it's bizarre and then from the other

749
00:28:09,600 --> 00:28:11,820
thread we

750
00:28:11,820 --> 00:28:13,799
send now that we have a right to send

751
00:28:13,799 --> 00:28:16,200
from Port one we send a message from

752
00:28:16,200 --> 00:28:17,820
Port one to Port two right I don't know

753
00:28:17,820 --> 00:28:19,559
if this even makes sense but

754
00:28:19,559 --> 00:28:22,640
because we sent it here but in any case

755
00:28:22,640 --> 00:28:26,539
we create a

756
00:28:26,760 --> 00:28:28,620
let's see so we do a move receive so in

757
00:28:28,620 --> 00:28:31,140
this message we're sending to part two

758
00:28:31,140 --> 00:28:32,940
from Port one and we're moving our right

759
00:28:32,940 --> 00:28:35,820
to receive messages on Port two

760
00:28:35,820 --> 00:28:37,200
um

761
00:28:37,200 --> 00:28:39,059
I think I don't know it's confusing but

762
00:28:39,059 --> 00:28:41,100
that's that's the point right so it

763
00:28:41,100 --> 00:28:42,900
found a way to erase these uh two last

764
00:28:42,900 --> 00:28:44,520
mock messages

765
00:28:44,520 --> 00:28:48,419
and so I added a special print function

766
00:28:48,419 --> 00:28:50,940
to my project that indents based on

767
00:28:50,940 --> 00:28:52,740
which thread you're in so I just put

768
00:28:52,740 --> 00:28:54,659
some prints around all over where the

769
00:28:54,659 --> 00:28:55,860
bug was happening

770
00:28:55,860 --> 00:28:57,900
and as you can see this actually turns

771
00:28:57,900 --> 00:28:59,880
into an interleaving table like you

772
00:28:59,880 --> 00:29:03,059
would see a human ridden one and so we

773
00:29:03,059 --> 00:29:05,520
can see that mock message was called

774
00:29:05,520 --> 00:29:07,799
from thread zero and thread one

775
00:29:07,799 --> 00:29:09,240
and

776
00:29:09,240 --> 00:29:12,179
over here somehow we end up copying in

777
00:29:12,179 --> 00:29:14,400
two rights so I think that's where we

778
00:29:14,400 --> 00:29:15,659
send a message

779
00:29:15,659 --> 00:29:17,820
to a port from the same port

780
00:29:17,820 --> 00:29:21,539
and then over here where we did this

781
00:29:21,539 --> 00:29:23,760
move receive operation it drops two

782
00:29:23,760 --> 00:29:25,799
references so references go three two

783
00:29:25,799 --> 00:29:27,120
two one

784
00:29:27,120 --> 00:29:29,640
and over here we end up dropping a

785
00:29:29,640 --> 00:29:31,559
reference and freeing

786
00:29:31,559 --> 00:29:33,480
and then we end up freeing again

787
00:29:33,480 --> 00:29:35,159
so

788
00:29:35,159 --> 00:29:37,320
well this this is a real race condition

789
00:29:37,320 --> 00:29:39,419
bug it's interesting what was really

790
00:29:39,419 --> 00:29:41,279
interesting is that it reminded me of a

791
00:29:41,279 --> 00:29:44,340
bug that my teammate Ian had found about

792
00:29:44,340 --> 00:29:47,159
a month earlier and so when I looked at

793
00:29:47,159 --> 00:29:50,820
his report he uh

794
00:29:50,820 --> 00:29:53,220
explained pretty clearly what the actual

795
00:29:53,220 --> 00:29:56,460
issue was and he's

796
00:29:56,460 --> 00:29:57,960
he says that you know basically when you

797
00:29:57,960 --> 00:30:01,679
send a message to a port from a port uh

798
00:30:01,679 --> 00:30:04,860
xnu thinks well both of these are the

799
00:30:04,860 --> 00:30:07,039
same port so we can

800
00:30:07,039 --> 00:30:09,840
do some operation the first time and

801
00:30:09,840 --> 00:30:11,520
then if it fails we return if it

802
00:30:11,520 --> 00:30:14,279
succeeds we continue and it thinks well

803
00:30:14,279 --> 00:30:16,020
we already just succeeded on the same

804
00:30:16,020 --> 00:30:17,940
port there's no way that it won't just

805
00:30:17,940 --> 00:30:19,500
succeed again so they ignore the return

806
00:30:19,500 --> 00:30:22,440
value here and it turns out that

807
00:30:22,440 --> 00:30:24,480
from another thread you actually can do

808
00:30:24,480 --> 00:30:27,779
this weird move receive thing I think to

809
00:30:27,779 --> 00:30:29,880
break this assumption and so you can

810
00:30:29,880 --> 00:30:34,140
race between these two calls and

811
00:30:34,140 --> 00:30:35,940
um this makes this fail but then they

812
00:30:35,940 --> 00:30:37,200
don't realize it and then things just

813
00:30:37,200 --> 00:30:40,740
kind of go haywire and so uh this is

814
00:30:40,740 --> 00:30:43,200
Ian's handwritten message

815
00:30:43,200 --> 00:30:45,899
um that he sent to Apple and this is the

816
00:30:45,899 --> 00:30:47,399
way that they fixed it based on this

817
00:30:47,399 --> 00:30:48,360
report

818
00:30:48,360 --> 00:30:49,860
and

819
00:30:49,860 --> 00:30:51,960
um as you can see it's pretty similar I

820
00:30:51,960 --> 00:30:53,820
think he's got sending a message to

821
00:30:53,820 --> 00:30:56,940
itself or from from a port to the same

822
00:30:56,940 --> 00:30:59,820
port and then we also have this received

823
00:30:59,820 --> 00:31:01,679
right destruction with a move receive

824
00:31:01,679 --> 00:31:04,080
and he has a different way of doing it

825
00:31:04,080 --> 00:31:07,080
uh but it actually is the same bug and

826
00:31:07,080 --> 00:31:08,520
uh

827
00:31:08,520 --> 00:31:10,260
it's interesting because I I heard

828
00:31:10,260 --> 00:31:12,240
someone say that

829
00:31:12,240 --> 00:31:15,240
this bug was an example of a bug that

830
00:31:15,240 --> 00:31:16,679
you couldn't find with fuzzing and I

831
00:31:16,679 --> 00:31:18,299
would have agreed with that if

832
00:31:18,299 --> 00:31:20,100
um it hadn't just happened like that day

833
00:31:20,100 --> 00:31:22,919
that I heard someone say it so so uh not

834
00:31:22,919 --> 00:31:26,279
naming names but uh the interesting bit

835
00:31:26,279 --> 00:31:28,100
I guess is uh if you keep running it

836
00:31:28,100 --> 00:31:33,120
then on the new xnu code uh it doesn't

837
00:31:33,120 --> 00:31:35,820
stop working and so now over on the

838
00:31:35,820 --> 00:31:38,760
out of the mark message IPC world let's

839
00:31:38,760 --> 00:31:41,460
go to BSD networking

840
00:31:41,460 --> 00:31:44,720
same setup no special you know awareness

841
00:31:44,720 --> 00:31:47,100
just this trick with yielding near

842
00:31:47,100 --> 00:31:48,419
unlocks

843
00:31:48,419 --> 00:31:52,440
we end up seeing this uh other simple

844
00:31:52,440 --> 00:31:55,500
bug so in thread one we call Saka and

845
00:31:55,500 --> 00:31:57,899
set sock opt and thread two we call

846
00:31:57,899 --> 00:31:59,760
disconnect X

847
00:31:59,760 --> 00:32:01,500
and what's interesting is uh this

848
00:32:01,500 --> 00:32:03,720
actually is the same as the sock puppet

849
00:32:03,720 --> 00:32:06,480
bug I had reported a few years back same

850
00:32:06,480 --> 00:32:08,700
three sys calls it just happens that

851
00:32:08,700 --> 00:32:10,679
before this was there was a

852
00:32:10,679 --> 00:32:13,440
deterministic bug where if you

853
00:32:13,440 --> 00:32:14,580
um set some option and disconnect

854
00:32:14,580 --> 00:32:17,220
there's some use after free condition

855
00:32:17,220 --> 00:32:19,799
now there's a race between setting a

856
00:32:19,799 --> 00:32:21,659
different option called the flow divert

857
00:32:21,659 --> 00:32:23,940
token and disconnecting from another

858
00:32:23,940 --> 00:32:27,120
thread and so

859
00:32:27,120 --> 00:32:29,760
um here I transcribed it to C plus plus

860
00:32:29,760 --> 00:32:31,820
you know it's a little hard to read but

861
00:32:31,820 --> 00:32:36,059
essentially I created a socket and then

862
00:32:36,059 --> 00:32:37,440
spawn a new thread where I just

863
00:32:37,440 --> 00:32:39,600
disconnect on that socket and then from

864
00:32:39,600 --> 00:32:41,940
the first thread

865
00:32:41,940 --> 00:32:45,539
send this packet and then

866
00:32:45,539 --> 00:32:47,760
it's you know there's a news after free

867
00:32:47,760 --> 00:32:49,440
condition and the interesting thing is

868
00:32:49,440 --> 00:32:52,140
that um I had no knowledge of this

869
00:32:52,140 --> 00:32:53,460
packet format I didn't know what

870
00:32:53,460 --> 00:32:55,380
floativert was all I did was just call

871
00:32:55,380 --> 00:32:57,240
set sock opt with random data and

872
00:32:57,240 --> 00:32:59,159
coverage guide fuzzing as powerful as it

873
00:32:59,159 --> 00:33:00,240
is

874
00:33:00,240 --> 00:33:04,140
found that uh you could uh

875
00:33:04,140 --> 00:33:05,880
create this structure with this contents

876
00:33:05,880 --> 00:33:08,760
and it would get to this code path and

877
00:33:08,760 --> 00:33:11,580
then it realized that disconnecting is

878
00:33:11,580 --> 00:33:14,700
interesting and then it realized

879
00:33:14,700 --> 00:33:17,519
um just maybe by chance that oh this

880
00:33:17,519 --> 00:33:20,100
specific ordering uh uses it for free

881
00:33:20,100 --> 00:33:23,779
just starts to pop up everywhere and so

882
00:33:23,779 --> 00:33:27,179
this is the panic I got and as you can

883
00:33:27,179 --> 00:33:29,700
see this is a kernel built in February

884
00:33:29,700 --> 00:33:33,120
of 2022 so just a few months ago this is

885
00:33:33,120 --> 00:33:34,019
a

886
00:33:34,019 --> 00:33:37,260
real app sandbox to Kernel use after

887
00:33:37,260 --> 00:33:40,380
free and uh

888
00:33:40,380 --> 00:33:42,419
it was found totally deterministically

889
00:33:42,419 --> 00:33:44,340
you know I could run this test case 5000

890
00:33:44,340 --> 00:33:45,539
times it would crash in the same way

891
00:33:45,539 --> 00:33:47,519
every time it was straightforward to

892
00:33:47,519 --> 00:33:50,519
transcribe to uh

893
00:33:50,519 --> 00:33:53,279
by hand and so that's actually this bug

894
00:33:53,279 --> 00:33:56,279
on the top from my initial list is

895
00:33:56,279 --> 00:33:58,980
um you know we started out with you know

896
00:33:58,980 --> 00:34:00,299
thinking at least for me thinking this

897
00:34:00,299 --> 00:34:02,220
was impossible by the middle of it I'm

898
00:34:02,220 --> 00:34:03,659
colliding with people and then by the

899
00:34:03,659 --> 00:34:06,000
end I'm starting to find new things that

900
00:34:06,000 --> 00:34:09,918
are until now undiscovered and

901
00:34:09,918 --> 00:34:12,239
it's possible that other people were

902
00:34:12,239 --> 00:34:14,639
aware of this bug but at least as far as

903
00:34:14,639 --> 00:34:16,260
public source code and at least the

904
00:34:16,260 --> 00:34:18,000
latest iOS version at the time it was

905
00:34:18,000 --> 00:34:19,139
there

906
00:34:19,139 --> 00:34:20,280
um

907
00:34:20,280 --> 00:34:23,540
so then my question was

908
00:34:23,540 --> 00:34:27,300
what exactly did I even do what like I

909
00:34:27,300 --> 00:34:29,460
just started from what made sense to me

910
00:34:29,460 --> 00:34:30,960
and just proceeded forward and forward

911
00:34:30,960 --> 00:34:32,099
like

912
00:34:32,099 --> 00:34:34,320
how is it that no one has done this what

913
00:34:34,320 --> 00:34:35,820
what is is there anything interesting

914
00:34:35,820 --> 00:34:39,599
here am I what what am I observing so I

915
00:34:39,599 --> 00:34:41,099
talked to a lot of people I did a lot of

916
00:34:41,099 --> 00:34:42,780
research to try to understand how this

917
00:34:42,780 --> 00:34:44,699
fits into existing work

918
00:34:44,699 --> 00:34:47,159
and it turns out that it's a real small

919
00:34:47,159 --> 00:34:49,560
tweak on deterministic record and replay

920
00:34:49,560 --> 00:34:51,239
which is

921
00:34:51,239 --> 00:34:54,659
a type of research that people you know

922
00:34:54,659 --> 00:34:56,719
write papers on it's like a very broad

923
00:34:56,719 --> 00:34:59,820
space and

924
00:34:59,820 --> 00:35:01,320
uh yeah it turns out I just have a

925
00:35:01,320 --> 00:35:02,940
little twist on it that's related to

926
00:35:02,940 --> 00:35:04,980
security and fuzzing so I think a couple

927
00:35:04,980 --> 00:35:06,300
really good examples that are

928
00:35:06,300 --> 00:35:09,300
representative are the RR project which

929
00:35:09,300 --> 00:35:13,800
is a reversible debugger from Mozilla

930
00:35:13,800 --> 00:35:15,119
and you know a lot of companies have a

931
00:35:15,119 --> 00:35:16,800
reversible debugger so if you think

932
00:35:16,800 --> 00:35:19,020
about what reversible debugging is it

933
00:35:19,020 --> 00:35:21,480
means you run a test case and you

934
00:35:21,480 --> 00:35:24,119
capture all non-determinism to some file

935
00:35:24,119 --> 00:35:26,400
then when you rerun the test case you

936
00:35:26,400 --> 00:35:27,720
need to be able to replay everything

937
00:35:27,720 --> 00:35:31,140
that you observed and so

938
00:35:31,140 --> 00:35:32,060
um

939
00:35:32,060 --> 00:35:34,920
Sorry by being able to replay it this is

940
00:35:34,920 --> 00:35:36,660
how you can reverse so you're not really

941
00:35:36,660 --> 00:35:38,040
reversing you're kind of going back to

942
00:35:38,040 --> 00:35:41,460
where you were earlier and so

943
00:35:41,460 --> 00:35:44,579
if you think about it if we run a

944
00:35:44,579 --> 00:35:46,320
program to try to capture a race

945
00:35:46,320 --> 00:35:47,339
condition

946
00:35:47,339 --> 00:35:49,560
and then we output some file

947
00:35:49,560 --> 00:35:51,300
well who said that we have to

948
00:35:51,300 --> 00:35:54,420
specifically run and get that file to

949
00:35:54,420 --> 00:35:56,540
happen to be created for us why not just

950
00:35:56,540 --> 00:35:59,099
randomize this file and why not just

951
00:35:59,099 --> 00:36:00,960
create this file ourselves that's really

952
00:36:00,960 --> 00:36:04,800
the the thing that I've done here so the

953
00:36:04,800 --> 00:36:06,060
other thing that's interesting is

954
00:36:06,060 --> 00:36:08,640
Microsoft chess this is another project

955
00:36:08,640 --> 00:36:10,260
that I think

956
00:36:10,260 --> 00:36:13,320
maybe even a decade old by this point

957
00:36:13,320 --> 00:36:17,040
um and there they do actually the same

958
00:36:17,040 --> 00:36:18,720
thing I I really couldn't believe how

959
00:36:18,720 --> 00:36:20,640
similar it was you have one thread you

960
00:36:20,640 --> 00:36:22,920
replace the scheduler so you control it

961
00:36:22,920 --> 00:36:26,220
you turn off preemption and you

962
00:36:26,220 --> 00:36:28,280
um have a few sync points which are

963
00:36:28,280 --> 00:36:31,200
yields next to mutexes but the

964
00:36:31,200 --> 00:36:33,500
difference here is that they try to

965
00:36:33,500 --> 00:36:35,640
systematically enumerate all

966
00:36:35,640 --> 00:36:38,099
interleavings of a given thing so in

967
00:36:38,099 --> 00:36:40,859
that first example uh

968
00:36:40,859 --> 00:36:44,099
where I showed the binder thing they

969
00:36:44,099 --> 00:36:46,079
might say let's add a yield after this

970
00:36:46,079 --> 00:36:48,000
unlock and then we'll test every

971
00:36:48,000 --> 00:36:49,859
possible interleaving

972
00:36:49,859 --> 00:36:50,700
um

973
00:36:50,700 --> 00:36:52,800
of all the threads and all of these

974
00:36:52,800 --> 00:36:55,859
points and see if there's a bug and so

975
00:36:55,859 --> 00:36:58,079
that actually would have worked probably

976
00:36:58,079 --> 00:37:01,200
does work on a program like this but the

977
00:37:01,200 --> 00:37:02,339
problem is when you want to scale this

978
00:37:02,339 --> 00:37:06,300
to an entire kernel uh you have BSD mock

979
00:37:06,300 --> 00:37:08,520
you know you have millions of lines of

980
00:37:08,520 --> 00:37:11,160
code it's really kind of intractable to

981
00:37:11,160 --> 00:37:14,820
guess where to run things and I guess

982
00:37:14,820 --> 00:37:16,079
that's not the right way to say it like

983
00:37:16,079 --> 00:37:18,900
I'm also guessing where to preempt but

984
00:37:18,900 --> 00:37:21,780
rather than systematically testing every

985
00:37:21,780 --> 00:37:23,640
possible exponential number of

986
00:37:23,640 --> 00:37:26,040
interleavings in one specific place

987
00:37:26,040 --> 00:37:30,240
I'm just saying just here's a way to

988
00:37:30,240 --> 00:37:33,240
explore everything

989
00:37:33,240 --> 00:37:35,460
and the fuzzer can go ahead and try to

990
00:37:35,460 --> 00:37:37,920
just do it for me and so

991
00:37:37,920 --> 00:37:40,740
you know in in summary I guess the the

992
00:37:40,740 --> 00:37:42,540
two contributions I think that are

993
00:37:42,540 --> 00:37:45,240
really novel here are that we now have

994
00:37:45,240 --> 00:37:48,260
this uh we now let a fuzzer control

995
00:37:48,260 --> 00:37:51,900
interleavings and we also

996
00:37:51,900 --> 00:37:54,000
it's this this part isn't bit really new

997
00:37:54,000 --> 00:37:56,640
but we scoped down annotations and

998
00:37:56,640 --> 00:37:59,160
uh sorry we scoped down where we do the

999
00:37:59,160 --> 00:38:01,440
yields so annotations are like yielding

1000
00:38:01,440 --> 00:38:03,480
and blocking and stuff so that only

1001
00:38:03,480 --> 00:38:04,920
happens in a few places where we think

1002
00:38:04,920 --> 00:38:07,020
bugs are likely to happen

1003
00:38:07,020 --> 00:38:10,740
and again my model is sort of like Ida

1004
00:38:10,740 --> 00:38:12,920
Pro it's if the

1005
00:38:12,920 --> 00:38:15,839
researcher is competent just allow them

1006
00:38:15,839 --> 00:38:18,079
to express what they want to express so

1007
00:38:18,079 --> 00:38:20,060
as long as

1008
00:38:20,060 --> 00:38:22,440
we can give a security researcher this

1009
00:38:22,440 --> 00:38:26,040
tool and they have good hypotheses good

1010
00:38:26,040 --> 00:38:28,260
intuition about race condition bugs they

1011
00:38:28,260 --> 00:38:30,420
should be able to use it to explore on

1012
00:38:30,420 --> 00:38:33,180
their behalf to do experiments

1013
00:38:33,180 --> 00:38:36,740
and so future work in this area

1014
00:38:36,740 --> 00:38:40,200
are thus far I have not done anything to

1015
00:38:40,200 --> 00:38:41,760
inform the fuzzer about

1016
00:38:41,760 --> 00:38:43,680
these different threads so it doesn't

1017
00:38:43,680 --> 00:38:46,020
understand like

1018
00:38:46,020 --> 00:38:48,780
maybe in that binder case like oh it's

1019
00:38:48,780 --> 00:38:50,280
kind of interesting that these two

1020
00:38:50,280 --> 00:38:52,380
threads are near each other using the

1021
00:38:52,380 --> 00:38:53,820
same data and we should interleave

1022
00:38:53,820 --> 00:38:56,400
around here there's no I I honestly

1023
00:38:56,400 --> 00:38:58,500
couldn't believe that this worked at all

1024
00:38:58,500 --> 00:39:00,599
but it somehow I think what's happening

1025
00:39:00,599 --> 00:39:02,940
is uh coverage guided fuzzing just works

1026
00:39:02,940 --> 00:39:06,900
so well that random schedules are enough

1027
00:39:06,900 --> 00:39:08,040
to

1028
00:39:08,040 --> 00:39:11,640
uh find bugs and importantly

1029
00:39:11,640 --> 00:39:12,480
um

1030
00:39:12,480 --> 00:39:13,920
you know if you're randomly building a

1031
00:39:13,920 --> 00:39:16,619
test case and growing it using coverage

1032
00:39:16,619 --> 00:39:18,660
guided fuzzing it's actually pretty

1033
00:39:18,660 --> 00:39:21,060
likely you'll end up with two threads

1034
00:39:21,060 --> 00:39:22,980
doing work related to each other so the

1035
00:39:22,980 --> 00:39:24,660
fuzzer might notice like oh if I'm doing

1036
00:39:24,660 --> 00:39:25,859
stuff in this thread but in the other

1037
00:39:25,859 --> 00:39:28,380
thread I mutate and that affects This

1038
00:39:28,380 --> 00:39:30,780
Thread it maybe it deletes something

1039
00:39:30,780 --> 00:39:33,180
that I was trying to use that's sort of

1040
00:39:33,180 --> 00:39:34,380
interesting so the fuzzer's kind of

1041
00:39:34,380 --> 00:39:36,599
building this thing and along the way it

1042
00:39:36,599 --> 00:39:38,339
gets close to a state where a random

1043
00:39:38,339 --> 00:39:40,320
schedule might just trigger a specific

1044
00:39:40,320 --> 00:39:43,020
interleaving that's that's buggy

1045
00:39:43,020 --> 00:39:44,520
um and then obviously improving

1046
00:39:44,520 --> 00:39:46,980
performance productionizing this

1047
00:39:46,980 --> 00:39:50,760
but essentially I think I I have the

1048
00:39:50,760 --> 00:39:51,660
um

1049
00:39:51,660 --> 00:39:53,579
you know I had the idea I did an

1050
00:39:53,579 --> 00:39:55,920
implementation was able to replicate

1051
00:39:55,920 --> 00:39:58,800
existing work and find new bugs and so

1052
00:39:58,800 --> 00:40:01,920
um essentially ready to say that I think

1053
00:40:01,920 --> 00:40:03,720
this project succeeded as a resource

1054
00:40:03,720 --> 00:40:05,640
project and it's just a question of uh

1055
00:40:05,640 --> 00:40:10,619
shipping it so in I guess uh

1056
00:40:10,619 --> 00:40:12,780
the way that these things normally go it

1057
00:40:12,780 --> 00:40:14,940
is not ready to be shipped so uh the

1058
00:40:14,940 --> 00:40:16,800
there will be a first draft available on

1059
00:40:16,800 --> 00:40:18,660
the project serial GitHub

1060
00:40:18,660 --> 00:40:20,520
um the stock price project is already

1061
00:40:20,520 --> 00:40:22,640
open source and we'll be adding this

1062
00:40:22,640 --> 00:40:24,480
multi-threaded fuzzing

1063
00:40:24,480 --> 00:40:26,820
component to it shortly probably the

1064
00:40:26,820 --> 00:40:29,339
next week or so once we merge a few

1065
00:40:29,339 --> 00:40:32,060
final improvements

1066
00:40:32,060 --> 00:40:34,800
and I think I'm out of time so let's

1067
00:40:34,800 --> 00:40:35,880
just leave it at that but yeah basically

1068
00:40:35,880 --> 00:40:37,800
coverage guide fuzzing is amazing

1069
00:40:37,800 --> 00:40:39,960
we need to work more on concurrency and

1070
00:40:39,960 --> 00:40:42,359
not just for security we need much

1071
00:40:42,359 --> 00:40:44,220
better concurrency tooling

1072
00:40:44,220 --> 00:40:46,440
and it's not that hard I think so this

1073
00:40:46,440 --> 00:40:48,300
is kind of my takeaways

1074
00:40:48,300 --> 00:40:50,520
So yeah thank you everyone I think we're

1075
00:40:50,520 --> 00:40:51,660
out of time so probably have to do

1076
00:40:51,660 --> 00:40:54,180
questions outside but uh

1077
00:40:54,180 --> 00:40:57,060
I appreciate you coming

1078
00:40:57,060 --> 00:40:59,240
foreign

1079
00:41:03,770 --> 00:41:06,869
[Music]

