1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:06,440 --> 00:00:09,480
yep okay hi everybody thank you for

3
00:00:09,480 --> 00:00:11,760
coming today uh our presentation is

4
00:00:11,760 --> 00:00:14,820
Android universal root exploiting xpu

5
00:00:14,820 --> 00:00:15,960
drivers

6
00:00:15,960 --> 00:00:18,480
so we are showing you Richard and John

7
00:00:18,480 --> 00:00:20,880
we're all members of Google's Android

8
00:00:20,880 --> 00:00:24,060
security and privacy organization xingyu

9
00:00:24,060 --> 00:00:26,640
and myself are security engineers in the

10
00:00:26,640 --> 00:00:28,740
Android malware research team with an

11
00:00:28,740 --> 00:00:31,380
interest in detecting exploitation John

12
00:00:31,380 --> 00:00:34,620
is program manager for the apvi program

13
00:00:34,620 --> 00:00:37,320
an internal Google effort aimed at

14
00:00:37,320 --> 00:00:39,719
coordinating the finding and fixing of

15
00:00:39,719 --> 00:00:41,700
vulnerabilities

16
00:00:41,700 --> 00:00:43,680
today we're going to talk to you about

17
00:00:43,680 --> 00:00:46,260
some rooting exploits on Android we'll

18
00:00:46,260 --> 00:00:48,360
start off with an in the wild exploit

19
00:00:48,360 --> 00:00:50,579
that triggered This research and we'll

20
00:00:50,579 --> 00:00:52,500
move through some of the results of the

21
00:00:52,500 --> 00:00:54,840
internal research and then finally cover

22
00:00:54,840 --> 00:00:56,820
the Android partner vulnerability

23
00:00:56,820 --> 00:00:59,039
initiative which is how we got the

24
00:00:59,039 --> 00:01:01,860
internal findings fixed

25
00:01:01,860 --> 00:01:05,239
so a long time ago about 10 years now

26
00:01:05,239 --> 00:01:07,680
there was a series of similar

27
00:01:07,680 --> 00:01:09,420
vulnerabilities in multiple Android

28
00:01:09,420 --> 00:01:11,700
drivers the overall family was called

29
00:01:11,700 --> 00:01:15,600
Framaroot essentially owing to bugs in

30
00:01:15,600 --> 00:01:18,479
the drivers and map handlers user mode

31
00:01:18,479 --> 00:01:20,759
could create read write mappings of

32
00:01:20,759 --> 00:01:23,040
Kernel memory resulting in fairly simple

33
00:01:23,040 --> 00:01:25,500
privilege elevation this was a common

34
00:01:25,500 --> 00:01:27,420
problem at the time as you can see by

35
00:01:27,420 --> 00:01:29,340
the number of exploits listed on the

36
00:01:29,340 --> 00:01:32,159
slide but the problem was recognized and

37
00:01:32,159 --> 00:01:35,040
the situation improved

38
00:01:35,040 --> 00:01:37,200
the first more modern exploit we're

39
00:01:37,200 --> 00:01:40,320
going to talk about is mtksu

40
00:01:40,320 --> 00:01:43,320
Trend Micro published a Blog posting as

41
00:01:43,320 --> 00:01:45,600
you can see here about a piece of

42
00:01:45,600 --> 00:01:47,640
Android malware they found the main

43
00:01:47,640 --> 00:01:50,220
focus of the blog posting was the

44
00:01:50,220 --> 00:01:52,340
exploit for cve

45
00:01:52,340 --> 00:01:57,479
2019-2215 AKA bad binder but if you

46
00:01:57,479 --> 00:01:59,220
further down in the blog they also

47
00:01:59,220 --> 00:02:02,060
mentioned a second exploit mediatek Su

48
00:02:02,060 --> 00:02:04,979
Trend Micro attributed the malware to an

49
00:02:04,979 --> 00:02:08,220
apt group everybody likes an apt so we

50
00:02:08,220 --> 00:02:10,619
thought we'd take a look at it we very

51
00:02:10,619 --> 00:02:13,080
rapidly found ourselves at the XDA

52
00:02:13,080 --> 00:02:15,840
Developers forums the first release of

53
00:02:15,840 --> 00:02:19,160
mtksu supported Amazon Fire HD devices

54
00:02:19,160 --> 00:02:22,379
and this was very rapidly followed up by

55
00:02:22,379 --> 00:02:24,599
a second release supporting a much wider

56
00:02:24,599 --> 00:02:25,920
range of hardware

57
00:02:25,920 --> 00:02:27,840
uh there are still people actually

58
00:02:27,840 --> 00:02:30,540
testing this this release today on

59
00:02:30,540 --> 00:02:32,340
hardware and Reporting whether it works

60
00:02:32,340 --> 00:02:34,020
or not

61
00:02:34,020 --> 00:02:38,520
so here 's a video of mtksu running on

62
00:02:38,520 --> 00:02:40,800
one of my test devices with the minus V

63
00:02:40,800 --> 00:02:44,340
for verbose option so it'll display all

64
00:02:44,340 --> 00:02:47,580
its debug outputs and here it goes so we

65
00:02:47,580 --> 00:02:49,080
can see it's

66
00:02:49,080 --> 00:02:51,360
looked up some kernel symbols you can

67
00:02:51,360 --> 00:02:52,860
see some kernel addresses floating

68
00:02:52,860 --> 00:02:56,280
around there and then at the end uid 0

69
00:02:56,280 --> 00:02:59,879
SE Linux is permissive

70
00:02:59,879 --> 00:03:03,000
so here are the three most important

71
00:03:03,000 --> 00:03:05,760
things broken out first thing it does go

72
00:03:05,760 --> 00:03:07,739
through the kernel symbol table get the

73
00:03:07,739 --> 00:03:10,680
function names and addresses

74
00:03:10,680 --> 00:03:13,860
the next two steps the exploit looks

75
00:03:13,860 --> 00:03:15,300
through the code of a couple of

76
00:03:15,300 --> 00:03:17,040
functions actually looking for

77
00:03:17,040 --> 00:03:18,900
particular instructions

78
00:03:18,900 --> 00:03:21,239
by finding particular instructions that

79
00:03:21,239 --> 00:03:24,420
are accessing certain variables the

80
00:03:24,420 --> 00:03:26,640
exploit can get the memory addresses of

81
00:03:26,640 --> 00:03:28,560
those variables or structures together

82
00:03:28,560 --> 00:03:30,540
with the structure offsets out of the

83
00:03:30,540 --> 00:03:33,120
instructions this means it can then find

84
00:03:33,120 --> 00:03:35,280
various data that it needs to perform

85
00:03:35,280 --> 00:03:37,440
the exploit

86
00:03:37,440 --> 00:03:40,200
less hard-coded data makes the exploit

87
00:03:40,200 --> 00:03:41,420
more portable

88
00:03:41,420 --> 00:03:44,459
if you think about Android there's a

89
00:03:44,459 --> 00:03:46,680
huge variety of kernels and devices out

90
00:03:46,680 --> 00:03:48,420
there and to fragmentation and OEM

91
00:03:48,420 --> 00:03:50,940
customization so if you're trying to

92
00:03:50,940 --> 00:03:52,560
maintain hard-coded lists of

93
00:03:52,560 --> 00:03:54,900
configuration addresses that's an awful

94
00:03:54,900 --> 00:03:57,180
lot of work if the exploit can find

95
00:03:57,180 --> 00:03:59,099
stuff on its own makes it a lot more

96
00:03:59,099 --> 00:04:00,440
portable

97
00:04:00,440 --> 00:04:02,700
kingroot who some of you might remember

98
00:04:02,700 --> 00:04:05,099
used to be a big provider of Android

99
00:04:05,099 --> 00:04:06,900
routing Solutions

100
00:04:06,900 --> 00:04:09,420
they went with the hard-coded approach

101
00:04:09,420 --> 00:04:11,400
uh configuration with addresses and

102
00:04:11,400 --> 00:04:13,140
offsets Etc

103
00:04:13,140 --> 00:04:15,120
Ingle one of their exploits that we

104
00:04:15,120 --> 00:04:17,100
found actually had configuration for

105
00:04:17,100 --> 00:04:19,858
over 5 000 combinations of Android

106
00:04:19,858 --> 00:04:22,800
device and kernel and that was the

107
00:04:22,800 --> 00:04:24,360
largest one we found some of them had

108
00:04:24,360 --> 00:04:26,699
considerably fewer but that's still a

109
00:04:26,699 --> 00:04:28,860
huge amount of work to maintain empty

110
00:04:28,860 --> 00:04:31,500
KSU doesn't have that it just finds what

111
00:04:31,500 --> 00:04:33,840
it needs and goes for it

112
00:04:33,840 --> 00:04:36,720
now the exploit printed out quite a lot

113
00:04:36,720 --> 00:04:39,000
about what it was doing but it didn't

114
00:04:39,000 --> 00:04:40,919
really give many Clues as to how it was

115
00:04:40,919 --> 00:04:43,220
doing it so

116
00:04:43,220 --> 00:04:45,600
the important strings here at the top

117
00:04:45,600 --> 00:04:47,639
those are various things that are passed

118
00:04:47,639 --> 00:04:50,040
to the open Sysco however if you reverse

119
00:04:50,040 --> 00:04:52,500
engineer the binary they're not present

120
00:04:52,500 --> 00:04:54,840
the strings are obfuscated there's

121
00:04:54,840 --> 00:04:57,540
actually over 250 obfuscated strings in

122
00:04:57,540 --> 00:04:59,160
the executable and most of them aren't

123
00:04:59,160 --> 00:05:02,040
referenced these three are looked up via

124
00:05:02,040 --> 00:05:05,040
a modified djb2 hash

125
00:05:05,040 --> 00:05:07,199
um in order to then get get the

126
00:05:07,199 --> 00:05:09,180
obfuscated versions pass them to the

127
00:05:09,180 --> 00:05:10,199
Cisco

128
00:05:10,199 --> 00:05:12,479
once you've got the device nodes as here

129
00:05:12,479 --> 00:05:14,580
you can then have a look at the SE

130
00:05:14,580 --> 00:05:17,100
policy if you pull that off the device

131
00:05:17,100 --> 00:05:20,460
and as we can see here the device node

132
00:05:20,460 --> 00:05:23,280
is accessible by regular unprivileged

133
00:05:23,280 --> 00:05:25,380
Android applications

134
00:05:25,380 --> 00:05:29,220
now the driver supports an ioctal which

135
00:05:29,220 --> 00:05:32,280
essentially allows user mode to send a

136
00:05:32,280 --> 00:05:34,919
buffer of op codes from user into the

137
00:05:34,919 --> 00:05:38,520
kernel those OP codes include read move

138
00:05:38,520 --> 00:05:39,720
and write

139
00:05:39,720 --> 00:05:42,240
so essentially unprivileged user mode

140
00:05:42,240 --> 00:05:45,900
code has kernel read write capability

141
00:05:45,900 --> 00:05:48,419
F via this ioctal

142
00:05:48,419 --> 00:05:51,240
now the drive is doing exactly what it

143
00:05:51,240 --> 00:05:53,220
was designed to do it's just the design

144
00:05:53,220 --> 00:05:55,800
and configuration didn't consider that

145
00:05:55,800 --> 00:05:57,660
someone might come along later and try

146
00:05:57,660 --> 00:05:59,340
to abuse the driver for different

147
00:05:59,340 --> 00:06:01,680
purposes

148
00:06:01,680 --> 00:06:04,680
an initial fix is quite simple change SE

149
00:06:04,680 --> 00:06:05,940
policy

150
00:06:05,940 --> 00:06:08,400
take away unprivileged applications

151
00:06:08,400 --> 00:06:10,860
ability to access the well to open the

152
00:06:10,860 --> 00:06:13,080
device or issue myopters and as you can

153
00:06:13,080 --> 00:06:15,000
see the exploit fails it can't

154
00:06:15,000 --> 00:06:16,440
initialize

155
00:06:16,440 --> 00:06:19,139
and there may be pre-installed

156
00:06:19,139 --> 00:06:21,840
applications which require access to the

157
00:06:21,840 --> 00:06:23,699
device now to do what they need to do

158
00:06:23,699 --> 00:06:25,560
but you can work around that with

159
00:06:25,560 --> 00:06:27,960
further SE policy explicitly allowing

160
00:06:27,960 --> 00:06:29,660
those applications

161
00:06:29,660 --> 00:06:32,280
alternatively you could Implement an out

162
00:06:32,280 --> 00:06:35,880
of process how it exposing specific

163
00:06:35,880 --> 00:06:37,979
functionality rather than generic pass

164
00:06:37,979 --> 00:06:39,560
through to the driver

165
00:06:39,560 --> 00:06:41,819
that would have performance issues

166
00:06:41,819 --> 00:06:44,460
though so not always applicable

167
00:06:44,460 --> 00:06:46,259
compared to the earlier frama Route

168
00:06:46,259 --> 00:06:49,080
Series of exploits mtksu is more

169
00:06:49,080 --> 00:06:51,600
complicated but it has exactly the same

170
00:06:51,600 --> 00:06:55,699
end result compromise of the kernel

171
00:06:56,100 --> 00:06:58,620
we did eventually read the XDA

172
00:06:58,620 --> 00:07:01,319
Developers Forum diplomatic is the

173
00:07:01,319 --> 00:07:03,180
individual who originally found the

174
00:07:03,180 --> 00:07:06,300
mtksu vulnerability and exploited it and

175
00:07:06,300 --> 00:07:08,160
without whose work I probably wouldn't

176
00:07:08,160 --> 00:07:10,680
be standing here talking to you today

177
00:07:10,680 --> 00:07:14,220
so mtk command Q is an accelerator

178
00:07:14,220 --> 00:07:16,620
driver with an interesting vulnerability

179
00:07:16,620 --> 00:07:20,300
what about other drivers

180
00:07:20,699 --> 00:07:22,740
you drivers need to be accessible if you

181
00:07:22,740 --> 00:07:24,479
think about the Chrome renderer process

182
00:07:24,479 --> 00:07:26,759
it's running in a very restrictive

183
00:07:26,759 --> 00:07:28,979
sandbox but it needs to do Graphics

184
00:07:28,979 --> 00:07:30,479
operations

185
00:07:30,479 --> 00:07:32,819
GPU drivers are very complicated

186
00:07:32,819 --> 00:07:35,419
performance is a very important Focus

187
00:07:35,419 --> 00:07:37,919
part of this involves a lot of attention

188
00:07:37,919 --> 00:07:40,740
on mapping memory between user mode and

189
00:07:40,740 --> 00:07:43,440
kernel or GPU so it fits into a number

190
00:07:43,440 --> 00:07:45,720
of the areas we've spoken about

191
00:07:45,720 --> 00:07:48,840
and there's not that many different GPU

192
00:07:48,840 --> 00:07:51,479
manufacturers for Android

193
00:07:51,479 --> 00:07:54,740
um arm and Qualcomm we tend to see

194
00:07:54,740 --> 00:07:57,180
security reports for those on a

195
00:07:57,180 --> 00:07:59,300
reasonably regular basis

196
00:07:59,300 --> 00:08:02,759
but imagination Technologies power VR we

197
00:08:02,759 --> 00:08:04,860
couldn't find very many security reports

198
00:08:04,860 --> 00:08:05,940
on that

199
00:08:05,940 --> 00:08:08,759
if you're not familiar with power VR

200
00:08:08,759 --> 00:08:10,680
there's an awful lot of power VR

201
00:08:10,680 --> 00:08:13,740
Hardware around in various places as

202
00:08:13,740 --> 00:08:16,020
well as Android devices power VR has

203
00:08:16,020 --> 00:08:18,120
been previously used by Apple it's in

204
00:08:18,120 --> 00:08:21,240
Chromebooks TVs some desktop computers

205
00:08:21,240 --> 00:08:22,800
even drones

206
00:08:22,800 --> 00:08:26,520
so it seems like this might be a

207
00:08:26,520 --> 00:08:28,620
a suitable area for some further

208
00:08:28,620 --> 00:08:31,139
research so with that I will pass things

209
00:08:31,139 --> 00:08:33,360
over to shinyu who will tell us about

210
00:08:33,360 --> 00:08:35,640
the other research

211
00:08:35,640 --> 00:08:37,620
thank you

212
00:08:37,620 --> 00:08:40,500
so uh like Richard said there's no way

213
00:08:40,500 --> 00:08:42,839
we can restrict I'm preview the access

214
00:08:42,839 --> 00:08:46,800
to uh part of your GPU driver and uh

215
00:08:46,800 --> 00:08:49,080
probably a GPU driver exports hundreds

216
00:08:49,080 --> 00:08:52,620
of Kernel apis to user space uh career

217
00:08:52,620 --> 00:08:55,740
developers call them as a bridge apis or

218
00:08:55,740 --> 00:08:57,260
Bridge functions

219
00:08:57,260 --> 00:08:59,760
so basically there are I mean three

220
00:08:59,760 --> 00:09:01,440
steps for talking to the device driver

221
00:09:01,440 --> 00:09:03,779
like you know opening device and Electro

222
00:09:03,779 --> 00:09:07,500
and response so to be more specific a

223
00:09:07,500 --> 00:09:09,380
user space program can always use

224
00:09:09,380 --> 00:09:12,779
ioct.cisco providing a function group ID

225
00:09:12,779 --> 00:09:16,740
function ID and input up data pass to

226
00:09:16,740 --> 00:09:19,680
the device driver so device driver will

227
00:09:19,680 --> 00:09:22,500
take a look at the IDS invoke the exact

228
00:09:22,500 --> 00:09:25,500
three gpis instead result back to user

229
00:09:25,500 --> 00:09:29,040
okay so here is the overview of how the

230
00:09:29,040 --> 00:09:32,160
bridge API works so first step is to

231
00:09:32,160 --> 00:09:34,260
create current buffers and copy user

232
00:09:34,260 --> 00:09:36,120
inputs uh invoke internal kind of

233
00:09:36,120 --> 00:09:38,399
functions and then return result back to

234
00:09:38,399 --> 00:09:41,580
user unfortunately every step is buggy

235
00:09:41,580 --> 00:09:43,680
and so let's take a look at the first

236
00:09:43,680 --> 00:09:46,680
step so for example if we want to call

237
00:09:46,680 --> 00:09:49,440
the the specific Bridge apis we have to

238
00:09:49,440 --> 00:09:52,860
specify uh group ID and function IDs and

239
00:09:52,860 --> 00:09:54,839
on the right side you can see how the

240
00:09:54,839 --> 00:09:55,940
device driver

241
00:09:55,940 --> 00:10:00,480
exports hundreds of ips in this way so

242
00:10:00,480 --> 00:10:03,240
the way to calculate the buffer size is

243
00:10:03,240 --> 00:10:05,820
to naively just user input so there will

244
00:10:05,820 --> 00:10:07,800
be a very obvious integral overflow

245
00:10:07,800 --> 00:10:09,959
should happen here and which leads to

246
00:10:09,959 --> 00:10:13,380
hip Autobahn right and you will you may

247
00:10:13,380 --> 00:10:15,899
also see that device driver may have a

248
00:10:15,899 --> 00:10:17,880
lot of sending checks but they always

249
00:10:17,880 --> 00:10:19,980
checking if an unsigned integer is

250
00:10:19,980 --> 00:10:22,080
always about zero so basically is doing

251
00:10:22,080 --> 00:10:24,180
nothing okay and it also increase

252
00:10:24,180 --> 00:10:27,000
massive travel in in the GPU framework

253
00:10:27,000 --> 00:10:28,800
because all the bridge apis are

254
00:10:28,800 --> 00:10:30,360
implemented in this way so Google

255
00:10:30,360 --> 00:10:33,120
assigns several CVS for this issue but

256
00:10:33,120 --> 00:10:34,980
goodness here is that you know sometimes

257
00:10:34,980 --> 00:10:38,040
integral flow May cancel the cell let's

258
00:10:38,040 --> 00:10:40,500
say if you allocate a buffer with the

259
00:10:40,500 --> 00:10:42,420
size that is Overflow but the size of

260
00:10:42,420 --> 00:10:44,399
the mem copy is also overflow so the

261
00:10:44,399 --> 00:10:46,800
material flow here cancels each other so

262
00:10:46,800 --> 00:10:48,420
there's actually no security impact

263
00:10:48,420 --> 00:10:50,040
although the code is written in a very

264
00:10:50,040 --> 00:10:53,279
wrong way cool so let's take a look at

265
00:10:53,279 --> 00:10:56,220
the Second Step here the thermostat is

266
00:10:56,220 --> 00:10:57,839
to about invoking internal code

267
00:10:57,839 --> 00:10:59,640
functions so basically there are I mean

268
00:10:59,640 --> 00:11:02,220
three types of Kernel functions

269
00:11:02,220 --> 00:11:04,320
curriculum objects use current object

270
00:11:04,320 --> 00:11:08,700
release object okay so just say we have

271
00:11:08,700 --> 00:11:10,920
a set of setup Bridge API called act

272
00:11:10,920 --> 00:11:12,839
what it does is to create internal

273
00:11:12,839 --> 00:11:14,880
current objects use current objects for

274
00:11:14,880 --> 00:11:16,860
computations and then return handle back

275
00:11:16,860 --> 00:11:19,380
to user and handle something much pretty

276
00:11:19,380 --> 00:11:22,320
much predictable okay so if we take

277
00:11:22,320 --> 00:11:24,480
Crossbrook The Divide driver create

278
00:11:24,480 --> 00:11:26,399
object a increment the reference card

279
00:11:26,399 --> 00:11:28,380
the reference line is one and then

280
00:11:28,380 --> 00:11:30,959
incremental runs count Protect by the

281
00:11:30,959 --> 00:11:33,060
log because we are going to do something

282
00:11:33,060 --> 00:11:34,800
for internal computation and then

283
00:11:34,800 --> 00:11:36,180
documentary reference count and it's

284
00:11:36,180 --> 00:11:39,060
also protected by the log okay and we

285
00:11:39,060 --> 00:11:42,000
also have a brief set of bridge API so

286
00:11:42,000 --> 00:11:45,060
the bridge repair y does is finding an

287
00:11:45,060 --> 00:11:47,040
objects by handle provide from user

288
00:11:47,040 --> 00:11:48,720
space and decremental reference count

289
00:11:48,720 --> 00:11:51,180
okay so if the remnants deck is

290
00:11:51,180 --> 00:11:54,060
decremental zero then object a is free

291
00:11:54,060 --> 00:11:57,000
so there's a Code choice we want to see

292
00:11:57,000 --> 00:11:58,380
that you know the first row create

293
00:11:58,380 --> 00:12:00,600
object a incremental reference count and

294
00:12:00,600 --> 00:12:02,880
then counter three happens to the third

295
00:12:02,880 --> 00:12:05,640
to the single thread the second thread

296
00:12:05,640 --> 00:12:08,459
technical runs come from one or two to

297
00:12:08,459 --> 00:12:12,000
one and then do something is invoked and

298
00:12:12,000 --> 00:12:13,380
then the ace reference can't get

299
00:12:13,380 --> 00:12:15,800
documented is free everything looks fine

300
00:12:15,800 --> 00:12:18,839
however if we have a third evil thrust

301
00:12:18,839 --> 00:12:21,000
here to further decrement the reference

302
00:12:21,000 --> 00:12:24,060
count from one to zero so a object will

303
00:12:24,060 --> 00:12:25,980
be free and then connect last week

304
00:12:25,980 --> 00:12:28,380
happens the first radicals do something

305
00:12:28,380 --> 00:12:32,040
here but a is also free so because every

306
00:12:32,040 --> 00:12:34,380
bridge apis are written in this way in

307
00:12:34,380 --> 00:12:35,579
terms of this synchronization

308
00:12:35,579 --> 00:12:37,800
infrastructure so basically almost like

309
00:12:37,800 --> 00:12:40,920
a dozens of Kernel apis are vulnerable

310
00:12:40,920 --> 00:12:42,480
in this way by the user-free

311
00:12:42,480 --> 00:12:44,519
vulnerability so imagination technology

312
00:12:44,519 --> 00:12:46,800
also take a few months for fixing the

313
00:12:46,800 --> 00:12:49,079
issue because obviously you can not use

314
00:12:49,079 --> 00:12:51,000
a big lock to lock the entire work state

315
00:12:51,000 --> 00:12:53,760
otherwise we have a huge performance hit

316
00:12:53,760 --> 00:12:56,700
cool so there's a final step here is

317
00:12:56,700 --> 00:12:58,980
copy result back to user so what it

318
00:12:58,980 --> 00:13:01,200
basic does is to you know a device

319
00:13:01,200 --> 00:13:03,899
driver tries to initialize and educate

320
00:13:03,899 --> 00:13:05,880
account object copy technology data back

321
00:13:05,880 --> 00:13:07,079
to user space

322
00:13:07,079 --> 00:13:09,899
so what happens here is that you know we

323
00:13:09,899 --> 00:13:12,720
have object a and divide driver tries to

324
00:13:12,720 --> 00:13:14,519
initialize the object a by do something

325
00:13:14,519 --> 00:13:17,700
function and then it will copy a data

326
00:13:17,700 --> 00:13:19,860
back to your space so here's problem if

327
00:13:19,860 --> 00:13:22,019
do something first very early then a is

328
00:13:22,019 --> 00:13:24,660
left uninitialized so you can easily

329
00:13:24,660 --> 00:13:27,060
kind of hit pointers or bypass kernel

330
00:13:27,060 --> 00:13:29,519
Acer in this way with upper slab size

331
00:13:29,519 --> 00:13:31,380
that is a very stable way to leak all

332
00:13:31,380 --> 00:13:33,959
kinds of kind of information and we also

333
00:13:33,959 --> 00:13:35,459
have other issues like you know

334
00:13:35,459 --> 00:13:37,740
reference color flows up trees stagger

335
00:13:37,740 --> 00:13:39,779
flows user for all types of geography

336
00:13:39,779 --> 00:13:42,060
previous sales or Warcraft installed

337
00:13:42,060 --> 00:13:43,279
later

338
00:13:43,279 --> 00:13:46,019
uh so as you can see in pretty guys

339
00:13:46,019 --> 00:13:47,760
there will be lots of classical memory

340
00:13:47,760 --> 00:13:49,920
crop sharing wrist conditions but and

341
00:13:49,920 --> 00:13:52,200
these bugs are definitely exploitable to

342
00:13:52,200 --> 00:13:54,660
load any proper devices but we are not

343
00:13:54,660 --> 00:13:56,160
going to do a deep dive for how to

344
00:13:56,160 --> 00:13:58,139
export this this bugs because we have

345
00:13:58,139 --> 00:14:00,420
something much more powerful so let's

346
00:14:00,420 --> 00:14:02,279
take a look at uh the memory management

347
00:14:02,279 --> 00:14:05,100
so you know we have a CPU we have GPU

348
00:14:05,100 --> 00:14:06,660
there will be lots of map memory

349
00:14:06,660 --> 00:14:08,519
mappings happening here like CPU we

350
00:14:08,519 --> 00:14:10,260
allocate virtual Pages map to Facebook

351
00:14:10,260 --> 00:14:12,600
pages similarly GPU will also map

352
00:14:12,600 --> 00:14:15,120
virtual pages to filter pages and

353
00:14:15,120 --> 00:14:17,100
there's also something called shell

354
00:14:17,100 --> 00:14:19,500
virtual memory or svm that basically

355
00:14:19,500 --> 00:14:22,860
means the the CPU and GPU will allocate

356
00:14:22,860 --> 00:14:25,019
their own separate different virtual

357
00:14:25,019 --> 00:14:27,600
pages and map to the same physical Pages

358
00:14:27,600 --> 00:14:30,959
for data transfer so uh well let's take

359
00:14:30,959 --> 00:14:32,639
a look at how the physical feature can

360
00:14:32,639 --> 00:14:34,920
manage and how GPU establish mappings

361
00:14:34,920 --> 00:14:37,560
from with GPU virtual pages to the

362
00:14:37,560 --> 00:14:41,100
Facebook pages okay so here so here is a

363
00:14:41,100 --> 00:14:43,500
important concept here called PMR or the

364
00:14:43,500 --> 00:14:45,660
PMR stands for physical memory resources

365
00:14:45,660 --> 00:14:47,720
so the USB program

366
00:14:47,720 --> 00:14:51,959
caused a lot of apis to get a PMI handle

367
00:14:51,959 --> 00:14:54,420
so what prmi handle means is that a user

368
00:14:54,420 --> 00:14:56,639
Space Program tells the GPU driver like

369
00:14:56,639 --> 00:14:58,920
hey this is a bunch of physical memory I

370
00:14:58,920 --> 00:15:01,380
want to reserve and please give me a PMI

371
00:15:01,380 --> 00:15:04,079
handleback and later usage program can

372
00:15:04,079 --> 00:15:07,139
use can pass the pr handle for creating

373
00:15:07,139 --> 00:15:09,360
the GPU or CPU virtual memory allocation

374
00:15:09,360 --> 00:15:12,779
because we've already reserved a bunch

375
00:15:12,779 --> 00:15:15,600
of Facebook memory for memory mappings

376
00:15:15,600 --> 00:15:18,180
so you know Korean pyrama will involve

377
00:15:18,180 --> 00:15:19,980
with the layer loss arguments from the

378
00:15:19,980 --> 00:15:22,980
other space and you can always fast this

379
00:15:22,980 --> 00:15:24,959
arguments and because the arguments are

380
00:15:24,959 --> 00:15:26,940
nothing it has very well so for example

381
00:15:26,940 --> 00:15:28,440
people say hey I want to manage two

382
00:15:28,440 --> 00:15:30,420
physical pages and you'll get a cleaner

383
00:15:30,420 --> 00:15:33,600
crash for Autobahn read and similarly if

384
00:15:33,600 --> 00:15:36,060
you want to create a GPU version page

385
00:15:36,060 --> 00:15:38,940
virtual Pages you also has to pass

386
00:15:38,940 --> 00:15:42,360
really a lot of arguments here for

387
00:15:42,360 --> 00:15:45,360
example if I say oh physic the physical

388
00:15:45,360 --> 00:15:48,480
map offset is -2 then the current will

389
00:15:48,480 --> 00:15:50,519
crash because the other one read so you

390
00:15:50,519 --> 00:15:52,019
can just utilize the other boundary

391
00:15:52,019 --> 00:15:55,079
issues to make sure like that you can

392
00:15:55,079 --> 00:15:56,940
map to your object physical Pages you

393
00:15:56,940 --> 00:15:59,519
want because you have the up the read of

394
00:15:59,519 --> 00:16:03,420
the button or primitive cool so we also

395
00:16:03,420 --> 00:16:05,940
have another interesting vulnerability

396
00:16:05,940 --> 00:16:09,540
here is that you know if we want to have

397
00:16:09,540 --> 00:16:12,540
a GPU mapping so we have to operate the

398
00:16:12,540 --> 00:16:16,320
iOS MW so if we want to operate our mu

399
00:16:16,320 --> 00:16:19,139
on arm64 architecture then we should

400
00:16:19,139 --> 00:16:22,220
operate it on in and on the 640 for sure

401
00:16:22,220 --> 00:16:25,680
however there is a bridge API where we

402
00:16:25,680 --> 00:16:27,420
can tell the device driver that hey we

403
00:16:27,420 --> 00:16:29,699
are actually on beeps so the device

404
00:16:29,699 --> 00:16:33,240
driver the GPU driver will install the

405
00:16:33,240 --> 00:16:35,519
page table in Memphis first and then

406
00:16:35,519 --> 00:16:38,279
later in initialize the page tables in

407
00:16:38,279 --> 00:16:40,380
arm628 later

408
00:16:40,380 --> 00:16:42,540
as a result because we have a new

409
00:16:42,540 --> 00:16:44,639
architecture called on mips the page

410
00:16:44,639 --> 00:16:47,399
tables are corrupted and once you use

411
00:16:47,399 --> 00:16:49,380
this program called a map Cisco you can

412
00:16:49,380 --> 00:16:51,120
immediately see all kinds of interesting

413
00:16:51,120 --> 00:16:53,519
data because page tables are corrupted

414
00:16:53,519 --> 00:16:55,680
okay

415
00:16:55,680 --> 00:16:58,139
um well so let's take a look at the CPU

416
00:16:58,139 --> 00:17:01,680
site so CPU site you can allocate a

417
00:17:01,680 --> 00:17:03,540
bunch of virtual pages and map to

418
00:17:03,540 --> 00:17:06,780
physical pages so in general a user

419
00:17:06,780 --> 00:17:08,459
space program helps to reserve our

420
00:17:08,459 --> 00:17:10,679
primary handle telling the the device

421
00:17:10,679 --> 00:17:13,079
driver like hey I want map that icon I

422
00:17:13,079 --> 00:17:14,819
only have a bunch of physical Pages for

423
00:17:14,819 --> 00:17:17,579
future use and then you can pass the PML

424
00:17:17,579 --> 00:17:19,859
to the m map so the device driver will

425
00:17:19,859 --> 00:17:23,099
map the virtual Pages for you and there

426
00:17:23,099 --> 00:17:25,439
and the the default driver also has

427
00:17:25,439 --> 00:17:27,480
something called irefcon for checking

428
00:17:27,480 --> 00:17:29,580
the number of memory mappings for

429
00:17:29,580 --> 00:17:31,020
security purposes we will talk about

430
00:17:31,020 --> 00:17:33,780
later so for example if we have two

431
00:17:33,780 --> 00:17:35,160
virtual Pages mapped to the same

432
00:17:35,160 --> 00:17:37,140
physical Pages then I ref count is

433
00:17:37,140 --> 00:17:39,419
equals to three because one by default

434
00:17:39,419 --> 00:17:42,360
okay we also had to cover another

435
00:17:42,360 --> 00:17:44,520
concept here called pin memory so pin

436
00:17:44,520 --> 00:17:46,919
memory is used for data transfers from

437
00:17:46,919 --> 00:17:48,960
the device vehicles and according my

438
00:17:48,960 --> 00:17:50,700
understanding that divide driver make

439
00:17:50,700 --> 00:17:53,100
pre-allocate some physical memory for

440
00:17:53,100 --> 00:17:56,520
avoiding calls in data transfer

441
00:17:56,520 --> 00:18:00,419
so the appropriate device has Bridge API

442
00:18:00,419 --> 00:18:02,580
where you can pin the physical memory

443
00:18:02,580 --> 00:18:05,760
reserved by the PMR so once you do that

444
00:18:05,760 --> 00:18:07,620
all the fixed memory are considered as

445
00:18:07,620 --> 00:18:09,900
pin memory for data transfer and there's

446
00:18:09,900 --> 00:18:12,660
a global State here bm10 is set as Force

447
00:18:12,660 --> 00:18:15,539
for security purposes you may also have

448
00:18:15,539 --> 00:18:18,059
a you may also call another project to

449
00:18:18,059 --> 00:18:21,059
unpane the physical Pages you pinned so

450
00:18:21,059 --> 00:18:22,860
these video pages will be moved to a

451
00:18:22,860 --> 00:18:24,660
global queue for coming up later and

452
00:18:24,660 --> 00:18:26,460
then the global status being unpaid will

453
00:18:26,460 --> 00:18:27,900
be updated as true

454
00:18:27,900 --> 00:18:30,480
so you know let's say we allocate page

455
00:18:30,480 --> 00:18:34,020
ABC and then we unpain page ABC so the

456
00:18:34,020 --> 00:18:36,720
page ABC will be inserted to a global

457
00:18:36,720 --> 00:18:39,419
list so how does these Pages get freed

458
00:18:39,419 --> 00:18:42,000
in terms of that powerware device

459
00:18:42,000 --> 00:18:44,160
registered means kind of shrinker so

460
00:18:44,160 --> 00:18:47,039
shrinker is an internal covered routines

461
00:18:47,039 --> 00:18:49,200
so when the current map kind of memory

462
00:18:49,200 --> 00:18:51,780
is tight the scan object callback will

463
00:18:51,780 --> 00:18:54,240
be invoked to free all the pages in the

464
00:18:54,240 --> 00:18:57,419
global list okay so let's say if we

465
00:18:57,419 --> 00:19:00,600
allocate page ABC and we cause I'm

466
00:19:00,600 --> 00:19:03,120
paying ABC then we have Global list ABC

467
00:19:03,120 --> 00:19:06,299
right so however we can open the same

468
00:19:06,299 --> 00:19:08,340
page again so the global list will be

469
00:19:08,340 --> 00:19:11,940
ABC ABC and that result we will have a

470
00:19:11,940 --> 00:19:14,340
page number three issue so if you

471
00:19:14,340 --> 00:19:16,380
remember like I feel slides before we

472
00:19:16,380 --> 00:19:17,700
have a global stage here called

473
00:19:17,700 --> 00:19:20,400
beyondpane so this is for preventing any

474
00:19:20,400 --> 00:19:22,919
double freeze on Facebook pages but why

475
00:19:22,919 --> 00:19:25,380
it doesn't work so it turns out that

476
00:19:25,380 --> 00:19:27,539
previous search is not enabled in

477
00:19:27,539 --> 00:19:28,320
production

478
00:19:28,320 --> 00:19:31,260
it is only enabled when color static and

479
00:19:31,260 --> 00:19:33,360
Nest Checker is enabled so if someone

480
00:19:33,360 --> 00:19:35,760
tries to check if my code is secure with

481
00:19:35,760 --> 00:19:38,580
the static cone and natural Checker the

482
00:19:38,580 --> 00:19:41,400
answer will be enabled but in production

483
00:19:41,400 --> 00:19:44,960
it does nothing so this is the worst

484
00:19:44,960 --> 00:19:46,980
dv2.10220123 is about

485
00:19:46,980 --> 00:19:50,280
and if we visit the existing Security

486
00:19:50,280 --> 00:19:53,760
checks if Facebook pages are mapped into

487
00:19:53,760 --> 00:19:55,919
somewhere else like you know we have

488
00:19:55,919 --> 00:19:58,140
iref count about one so the physical

489
00:19:58,140 --> 00:20:00,600
pages are not allowed to be on pain so

490
00:20:00,600 --> 00:20:03,059
let me explain this if we call the

491
00:20:03,059 --> 00:20:04,799
following function here first of all we

492
00:20:04,799 --> 00:20:07,860
create PMI handle and we

493
00:20:07,860 --> 00:20:10,740
Chris if you virtual Pages by a map we

494
00:20:10,740 --> 00:20:13,559
cannot unpin a memory because we if we

495
00:20:13,559 --> 00:20:16,080
can do so then what happens here is that

496
00:20:16,080 --> 00:20:17,820
virtual Pages went back to the physical

497
00:20:17,820 --> 00:20:19,860
pages that will be free later by lens

498
00:20:19,860 --> 00:20:21,960
corner shrinker so that's why the

499
00:20:21,960 --> 00:20:24,419
iraq.com here to prevent some things

500
00:20:24,419 --> 00:20:25,500
happen

501
00:20:25,500 --> 00:20:27,780
however there's a certain logic bug here

502
00:20:27,780 --> 00:20:30,840
to bypass security check if we create PM

503
00:20:30,840 --> 00:20:32,660
refers and then unping the memory

504
00:20:32,660 --> 00:20:35,880
segment it will succeed because at this

505
00:20:35,880 --> 00:20:38,039
time we didn't map any memory so these

506
00:20:38,039 --> 00:20:40,500
fixed pages are already put into the

507
00:20:40,500 --> 00:20:42,660
global list for free later and then we

508
00:20:42,660 --> 00:20:45,299
can call them map to map this to map the

509
00:20:45,299 --> 00:20:47,820
to get a bunch of virtual pages so what

510
00:20:47,820 --> 00:20:49,440
happens here is that we will have a

511
00:20:49,440 --> 00:20:51,360
bunch of virtual Pages mapped to the

512
00:20:51,360 --> 00:20:53,100
physical pager that will be freed by

513
00:20:53,100 --> 00:20:56,220
news konoshinker so um

514
00:20:56,220 --> 00:20:58,200
we can effectively trigger the lens kind

515
00:20:58,200 --> 00:21:01,320
of shrinker by push in not enough memory

516
00:21:01,320 --> 00:21:03,360
pressure to lens kernel by doing this

517
00:21:03,360 --> 00:21:06,000
again and again so we will have a bunch

518
00:21:06,000 --> 00:21:07,740
of virtual Pages map to the Facebook

519
00:21:07,740 --> 00:21:10,140
pages that will be free later so this is

520
00:21:10,140 --> 00:21:14,039
what this TV 2021 3985 is about it was

521
00:21:14,039 --> 00:21:16,679
discovered in late February so it's a

522
00:21:16,679 --> 00:21:18,900
very subtle logic bug to bypass security

523
00:21:18,900 --> 00:21:21,059
check but user space program can read

524
00:21:21,059 --> 00:21:24,000
and write up to three physical pages and

525
00:21:24,000 --> 00:21:27,299
I personally call it as power grid okay

526
00:21:27,299 --> 00:21:30,600
so uh let's have a routine but there's

527
00:21:30,600 --> 00:21:33,179
one more issue here is that some devices

528
00:21:33,179 --> 00:21:36,480
don't allow you to impact on GPU device

529
00:21:36,480 --> 00:21:38,820
especially if you have device with a

530
00:21:38,820 --> 00:21:41,280
higher versions of ddk

531
00:21:41,280 --> 00:21:44,700
okay so who has a privilege to a map of

532
00:21:44,700 --> 00:21:47,039
GPU device if you check on the SMX

533
00:21:47,039 --> 00:21:50,340
policy here you can see this will be a

534
00:21:50,340 --> 00:21:53,580
bunch of users are able to map on the

535
00:21:53,580 --> 00:21:56,880
GPU devices and if you use based

536
00:21:56,880 --> 00:21:59,340
programs are really not allowed to a map

537
00:21:59,340 --> 00:22:01,740
on GPU device how does the openclipi

538
00:22:01,740 --> 00:22:05,159
works because the the svm analog apis

539
00:22:05,159 --> 00:22:07,679
will return a CPU virtual address

540
00:22:07,679 --> 00:22:11,100
allocated from the GPU driver so what I

541
00:22:11,100 --> 00:22:13,620
did in past is to take a look at the

542
00:22:13,620 --> 00:22:17,280
opencl libraries official Library it is

543
00:22:17,280 --> 00:22:19,020
actually implemented by a stereo vendor

544
00:22:19,020 --> 00:22:21,419
Library so if you are if you have a new

545
00:22:21,419 --> 00:22:23,220
detect device you can see the power

546
00:22:23,220 --> 00:22:25,380
wheel and mid attack vendor libraries

547
00:22:25,380 --> 00:22:28,320
for implementing all the opencl apis

548
00:22:28,320 --> 00:22:31,200
and by representing these vendor apis I

549
00:22:31,200 --> 00:22:33,360
visited funding so the first finding

550
00:22:33,360 --> 00:22:36,360
here is that the the user space vendor

551
00:22:36,360 --> 00:22:38,400
library has more reverse Security check

552
00:22:38,400 --> 00:22:41,340
than the kernel module and second the

553
00:22:41,340 --> 00:22:43,559
vendor Library will talk to the higher

554
00:22:43,559 --> 00:22:46,440
privilege of backhand services to a map

555
00:22:46,440 --> 00:22:50,039
a GPU driver and get the virtual virtual

556
00:22:50,039 --> 00:22:51,360
page address back

557
00:22:51,360 --> 00:22:54,120
so here the bypass of the asset Linux

558
00:22:54,120 --> 00:22:56,039
here so we have a chart process here

559
00:22:56,039 --> 00:22:59,159
because the overseer API SM analog and

560
00:22:59,159 --> 00:23:01,200
the child project here is petri's by

561
00:23:01,200 --> 00:23:03,960
parrot so when the child process tried

562
00:23:03,960 --> 00:23:06,240
to create PMR because parent process is

563
00:23:06,240 --> 00:23:08,520
able to intercept all this is called by

564
00:23:08,520 --> 00:23:11,640
p3s so we can

565
00:23:11,640 --> 00:23:15,179
so we can ask so parent process to

566
00:23:15,179 --> 00:23:16,740
hijack the control flow of the child

567
00:23:16,740 --> 00:23:19,320
process to cause AMPM PML immediately

568
00:23:19,320 --> 00:23:22,200
after PMR is created and then chart

569
00:23:22,200 --> 00:23:24,059
process will use this random libraries

570
00:23:24,059 --> 00:23:27,539
to unmap GPU drivers and get a CPU of

571
00:23:27,539 --> 00:23:30,000
virtual address back and in this way we

572
00:23:30,000 --> 00:23:32,280
can effectively bypass as a Linux and

573
00:23:32,280 --> 00:23:35,340
Trigger the problem vulnerability so the

574
00:23:35,340 --> 00:23:37,620
final part here is about how to do a

575
00:23:37,620 --> 00:23:40,400
device similar to your device by 3518

576
00:23:40,400 --> 00:23:43,260
you may also have a chance to load code

577
00:23:43,260 --> 00:23:46,080
modules but human mind probably

578
00:23:46,080 --> 00:23:48,659
something much more powerful because it

579
00:23:48,659 --> 00:23:51,840
is a paid physical page user free so

580
00:23:51,840 --> 00:23:53,880
there will be a lot of method to load a

581
00:23:53,880 --> 00:23:56,100
device by power vulnerabilities you can

582
00:23:56,100 --> 00:23:58,980
crop page tables you can crop binaries

583
00:23:58,980 --> 00:24:01,080
you can attack you know in a memory

584
00:24:01,080 --> 00:24:04,440
crafting list or traditional ways so I'm

585
00:24:04,440 --> 00:24:06,299
going to talk about our Channel surveys

586
00:24:06,299 --> 00:24:09,059
so first of all the first thing I will

587
00:24:09,059 --> 00:24:10,799
do is just about another child process

588
00:24:10,799 --> 00:24:12,720
with different names so because we can

589
00:24:12,720 --> 00:24:15,360
read a write up very newly free Facebook

590
00:24:15,360 --> 00:24:17,460
pages we can find the exact task

591
00:24:17,460 --> 00:24:19,880
structures and a script credit address

592
00:24:19,880 --> 00:24:22,860
and there we can find the victim files

593
00:24:22,860 --> 00:24:25,440
by the app underscore or write the

594
00:24:25,440 --> 00:24:27,000
private data for example we can control

595
00:24:27,000 --> 00:24:29,580
the private data of Ashman so we can use

596
00:24:29,580 --> 00:24:32,400
the ioctal calls from the Ashman to

597
00:24:32,400 --> 00:24:33,659
implement an option green right

598
00:24:33,659 --> 00:24:35,820
primitive and the next step we are going

599
00:24:35,820 --> 00:24:39,240
to do is to dump kernel image well you

600
00:24:39,240 --> 00:24:41,280
know the PMR kind of structure has a

601
00:24:41,280 --> 00:24:43,559
field called SC annotations which is

602
00:24:43,559 --> 00:24:46,440
specified by user space so we can find

603
00:24:46,440 --> 00:24:48,960
find the PMR structure where PMR

604
00:24:48,960 --> 00:24:51,240
structure contains that kernel data

605
00:24:51,240 --> 00:24:52,980
attacked read-only pointer so we can

606
00:24:52,980 --> 00:24:54,240
download a lot of Kernel informations

607
00:24:54,240 --> 00:24:56,820
and find where is the possible address

608
00:24:56,820 --> 00:24:59,940
of SMS enforcing turn it off and the

609
00:24:59,940 --> 00:25:01,740
final part here is your own right cross

610
00:25:01,740 --> 00:25:04,200
structure so one thing I want to someone

611
00:25:04,200 --> 00:25:06,059
say that because we are writing our

612
00:25:06,059 --> 00:25:07,980
right combined pages so we probably have

613
00:25:07,980 --> 00:25:10,440
just enough CPU cache for a while cool

614
00:25:10,440 --> 00:25:12,900
so here is the time that we do for

615
00:25:12,900 --> 00:25:16,140
looting our randomly 9i device it's one

616
00:25:16,140 --> 00:25:17,580
of the most popular device on this

617
00:25:17,580 --> 00:25:22,280
planet so uh let's get started

618
00:25:26,820 --> 00:25:28,919
so now let's try to create a lot of PMR

619
00:25:28,919 --> 00:25:31,740
structures find the kernel data pointers

620
00:25:31,740 --> 00:25:33,539
and then create a lot of child process

621
00:25:33,539 --> 00:25:34,820
here

622
00:25:34,820 --> 00:25:39,139
check out the credential structure

623
00:25:43,340 --> 00:25:47,100
so it may take a while and now we find

624
00:25:47,100 --> 00:25:48,900
the file structure we hijack the private

625
00:25:48,900 --> 00:25:51,240
data so we can use the Azure map for a

626
00:25:51,240 --> 00:25:53,940
pre-renal right Primitives and then we

627
00:25:53,940 --> 00:25:55,140
can dump a lot of kind of information

628
00:25:55,140 --> 00:25:57,720
for finding where the plot where the

629
00:25:57,720 --> 00:26:00,480
acid links enforcing is and then we can

630
00:26:00,480 --> 00:26:03,140
turn it off later

631
00:26:05,760 --> 00:26:08,700
and then the final step here is to get a

632
00:26:08,700 --> 00:26:11,700
loot process so the way how to work here

633
00:26:11,700 --> 00:26:13,620
is to you know search the physical

634
00:26:13,620 --> 00:26:16,380
memory fixed memory again again and try

635
00:26:16,380 --> 00:26:18,960
to find our credential file and once we

636
00:26:18,960 --> 00:26:22,679
find it we will temper all the important

637
00:26:22,679 --> 00:26:26,279
Fields like uid20 so we have a Russia it

638
00:26:26,279 --> 00:26:28,320
might take a while depends on the exact

639
00:26:28,320 --> 00:26:31,320
memory uh that it depends on situation

640
00:26:31,320 --> 00:26:33,900
of the Facebook memories like sometimes

641
00:26:33,900 --> 00:26:35,760
you may wait for a while but keep in

642
00:26:35,760 --> 00:26:37,620
mind this kind of benefit is very stable

643
00:26:37,620 --> 00:26:39,600
because you don't have to do like

644
00:26:39,600 --> 00:26:41,039
history you don't have to worry about

645
00:26:41,039 --> 00:26:43,740
KSL alignment the only thing you have

646
00:26:43,740 --> 00:26:45,659
you can do is to search memory again

647
00:26:45,659 --> 00:26:47,820
again and find the interesting kind of

648
00:26:47,820 --> 00:26:50,460
structure you want

649
00:26:50,460 --> 00:26:53,700
so basically means if you attack device

650
00:26:53,700 --> 00:26:56,279
by this vulnerability the device won't

651
00:26:56,279 --> 00:26:57,659
crash

652
00:26:57,659 --> 00:27:00,000
so in my way forward now we have

653
00:27:00,000 --> 00:27:01,679
hijacked the critical data structure and

654
00:27:01,679 --> 00:27:05,100
we have root share on redmi 9 device and

655
00:27:05,100 --> 00:27:08,100
we can control device now thank you and

656
00:27:08,100 --> 00:27:09,900
please welcome John for introducing a

657
00:27:09,900 --> 00:27:12,040
free project

658
00:27:12,040 --> 00:27:16,799
[Applause]

659
00:27:16,799 --> 00:27:19,500
thanks Junior so the vulnerability is

660
00:27:19,500 --> 00:27:21,179
that Junior and Richard discovered are

661
00:27:21,179 --> 00:27:23,279
part of a broad google-wide effort to

662
00:27:23,279 --> 00:27:25,140
make the Android ecosystem more secure

663
00:27:25,140 --> 00:27:27,240
and this includes strengthening the

664
00:27:27,240 --> 00:27:29,520
security of our third-party OEM Partners

665
00:27:29,520 --> 00:27:32,039
the way that we find informed partners

666
00:27:32,039 --> 00:27:33,779
and then publicly disclose these

667
00:27:33,779 --> 00:27:35,940
security vulnerabilities all takes place

668
00:27:35,940 --> 00:27:37,440
through this program called the Android

669
00:27:37,440 --> 00:27:40,260
partner vulnerability initiative or appy

670
00:27:40,260 --> 00:27:42,720
for sure so I'm sure you're familiar

671
00:27:42,720 --> 00:27:44,419
that Android incorporates security

672
00:27:44,419 --> 00:27:47,159
features across the entire industry and

673
00:27:47,159 --> 00:27:48,659
we always try to make sure our devices

674
00:27:48,659 --> 00:27:51,059
are really safe and secure we also hold

675
00:27:51,059 --> 00:27:53,400
developers and device manufacturers to

676
00:27:53,400 --> 00:27:55,620
these high standards as well as part of

677
00:27:55,620 --> 00:27:57,960
that effort we have a range of existing

678
00:27:57,960 --> 00:27:59,520
programs that I'm sure many of you are

679
00:27:59,520 --> 00:28:01,260
probably already familiar with one of

680
00:28:01,260 --> 00:28:02,940
them being the Google bug bunny program

681
00:28:02,940 --> 00:28:04,980
and also the Android bug binding program

682
00:28:04,980 --> 00:28:06,960
the Android partner vulnerability

683
00:28:06,960 --> 00:28:08,940
initiative adds another layer of

684
00:28:08,940 --> 00:28:10,740
security for this targeted set of

685
00:28:10,740 --> 00:28:13,260
Android oems the way it works is that

686
00:28:13,260 --> 00:28:15,840
any Google employee on any team if they

687
00:28:15,840 --> 00:28:17,340
find a vulnerability that affects a

688
00:28:17,340 --> 00:28:19,679
third-party OEM can report their finding

689
00:28:19,679 --> 00:28:22,020
through apbi where we then take that

690
00:28:22,020 --> 00:28:23,640
vulnerability perform reproduction

691
00:28:23,640 --> 00:28:25,740
identify all the effective partner

692
00:28:25,740 --> 00:28:27,779
builds and then disclose those builds

693
00:28:27,779 --> 00:28:29,820
and issues to the OEM partners that are

694
00:28:29,820 --> 00:28:31,860
affected finally we have public

695
00:28:31,860 --> 00:28:34,080
disclosure and Patch advisory so I'm not

696
00:28:34,080 --> 00:28:35,460
sure many people know about this link

697
00:28:35,460 --> 00:28:38,640
but that link on the screen is a link to

698
00:28:38,640 --> 00:28:40,380
all of our publicly disclosed issues

699
00:28:40,380 --> 00:28:42,120
through this program you should take a

700
00:28:42,120 --> 00:28:43,620
look I'm pretty sure not many people

701
00:28:43,620 --> 00:28:46,158
know about this

702
00:28:46,500 --> 00:28:48,179
so for this specific case of the power

703
00:28:48,179 --> 00:28:50,400
VR issues the process was a little bit

704
00:28:50,400 --> 00:28:52,919
more complicated the problem is that

705
00:28:52,919 --> 00:28:54,900
we're not tasked with just disclosing to

706
00:28:54,900 --> 00:28:56,940
imagination technologies that owns and

707
00:28:56,940 --> 00:28:59,100
manages power VR but there's so many

708
00:28:59,100 --> 00:29:01,620
Downstream oems that also utilize these

709
00:29:01,620 --> 00:29:03,720
drivers so what we had to do is we had

710
00:29:03,720 --> 00:29:05,159
to First disclose to imagination

711
00:29:05,159 --> 00:29:07,679
Technologies all the various cves found

712
00:29:07,679 --> 00:29:09,659
during this research and ensure that

713
00:29:09,659 --> 00:29:11,159
imagination technologies have the

714
00:29:11,159 --> 00:29:13,020
resources they need to issue patches

715
00:29:13,020 --> 00:29:15,840
then we went to all the downstream oems

716
00:29:15,840 --> 00:29:17,100
and we made sure that they had the

717
00:29:17,100 --> 00:29:18,899
patches once they were available and

718
00:29:18,899 --> 00:29:20,340
made sure they had the ability to go and

719
00:29:20,340 --> 00:29:22,559
Implement patches as well finally we

720
00:29:22,559 --> 00:29:23,940
disclosed all of these issues on our

721
00:29:23,940 --> 00:29:25,500
appy issue tracker that I mentioned

722
00:29:25,500 --> 00:29:27,600
earlier the following statement was

723
00:29:27,600 --> 00:29:29,580
provided by imagination Technologies and

724
00:29:29,580 --> 00:29:30,960
it touches on how they're looking to

725
00:29:30,960 --> 00:29:32,640
continue to engage with the appv program

726
00:29:32,640 --> 00:29:34,919
to benefit the security of the entire

727
00:29:34,919 --> 00:29:37,820
industry in the space

728
00:29:38,100 --> 00:29:39,720
I'd like to close this briefing with a

729
00:29:39,720 --> 00:29:41,760
few key takeaways for developers and

730
00:29:41,760 --> 00:29:43,919
researchers essentially the takeaways

731
00:29:43,919 --> 00:29:45,720
for driver developers comes down to two

732
00:29:45,720 --> 00:29:48,600
main things the first sanitize user

733
00:29:48,600 --> 00:29:50,640
inputs from user mode paying particular

734
00:29:50,640 --> 00:29:52,620
attention to sign and unsigned issues

735
00:29:52,620 --> 00:29:54,899
and second make sure that you're locking

736
00:29:54,899 --> 00:29:56,700
down accessible functionality to the

737
00:29:56,700 --> 00:29:58,980
minimum functionality required driver

738
00:29:58,980 --> 00:30:01,320
developers can go one step further limit

739
00:30:01,320 --> 00:30:03,179
the driver to a very clearly understood

740
00:30:03,179 --> 00:30:04,679
purpose and make sure that you're

741
00:30:04,679 --> 00:30:06,360
incorporating fuzz testing and code

742
00:30:06,360 --> 00:30:07,620
review as part of your development

743
00:30:07,620 --> 00:30:10,158
lifecycle

744
00:30:10,320 --> 00:30:12,720
for researchers memory mapping and

745
00:30:12,720 --> 00:30:14,520
visibility tends to be a reoccurring

746
00:30:14,520 --> 00:30:16,020
theme in this space there's been

747
00:30:16,020 --> 00:30:18,240
multiple cves and drivers for various

748
00:30:18,240 --> 00:30:19,919
Hardware processing units that have been

749
00:30:19,919 --> 00:30:21,120
found over the past couple of years

750
00:30:21,120 --> 00:30:22,860
outside of the findings that we've

751
00:30:22,860 --> 00:30:24,419
touched on during this talk we've

752
00:30:24,419 --> 00:30:25,980
included examples to frame a route

753
00:30:25,980 --> 00:30:28,860
Qualcomm and Samsung cves in the

754
00:30:28,860 --> 00:30:30,299
resources slide at the end if you really

755
00:30:30,299 --> 00:30:31,559
want to learn more

756
00:30:31,559 --> 00:30:33,600
the underlying question Still Remains

757
00:30:33,600 --> 00:30:35,880
have these power VR issues been found

758
00:30:35,880 --> 00:30:38,520
before and not reported it's possible

759
00:30:38,520 --> 00:30:40,320
some of the issues that we were

760
00:30:40,320 --> 00:30:42,360
discovered were not hard to identify and

761
00:30:42,360 --> 00:30:43,500
I can tell you from first-hand

762
00:30:43,500 --> 00:30:45,360
experience one Shing you found the first

763
00:30:45,360 --> 00:30:47,640
PR power VR issue the rest of them

764
00:30:47,640 --> 00:30:49,860
followed very shortly afterwards I

765
00:30:49,860 --> 00:30:52,500
octopuzzing isn't necessarily simple and

766
00:30:52,500 --> 00:30:54,120
there's a link to another black hat talk

767
00:30:54,120 --> 00:30:56,220
that happened a couple years ago in the

768
00:30:56,220 --> 00:30:58,200
resources slide that talks about fuzzing

769
00:30:58,200 --> 00:31:00,059
kernel drivers with interface awareness

770
00:31:00,059 --> 00:31:02,640
and really the authors use this method

771
00:31:02,640 --> 00:31:05,220
to find other cves in the mediatek cmdq

772
00:31:05,220 --> 00:31:07,740
driver these bugs were found using much

773
00:31:07,740 --> 00:31:09,120
simpler methods and much simpler

774
00:31:09,120 --> 00:31:11,940
approaches if this talk inspires you to

775
00:31:11,940 --> 00:31:13,080
go out and find your own type of

776
00:31:13,080 --> 00:31:15,120
vulnerabilities I encourage you to keep

777
00:31:15,120 --> 00:31:16,559
in mind that you can submit these types

778
00:31:16,559 --> 00:31:18,120
of issues to the Android bug bunny

779
00:31:18,120 --> 00:31:19,559
program where they're going to be

780
00:31:19,559 --> 00:31:21,240
assessed and then evaluated to see if

781
00:31:21,240 --> 00:31:22,620
they have underlying impact to the

782
00:31:22,620 --> 00:31:25,200
Android devices or ecosystem

783
00:31:25,200 --> 00:31:27,480
so with that in closing we wanted to

784
00:31:27,480 --> 00:31:29,340
share this list of researchers research

785
00:31:29,340 --> 00:31:31,679
Resources with driver developers

786
00:31:31,679 --> 00:31:33,720
researchers and the security Community

787
00:31:33,720 --> 00:31:35,640
as a whole if you want to dive deeper

788
00:31:35,640 --> 00:31:37,380
into this research so I really

789
00:31:37,380 --> 00:31:38,820
appreciate all of you coming to our talk

790
00:31:38,820 --> 00:31:40,320
today and we look forward to answering

791
00:31:40,320 --> 00:31:42,360
your questions thank you

792
00:31:42,360 --> 00:31:45,419
[Applause]

793
00:31:45,419 --> 00:31:47,600
foreign

794
00:31:52,130 --> 00:31:55,219
[Music]

