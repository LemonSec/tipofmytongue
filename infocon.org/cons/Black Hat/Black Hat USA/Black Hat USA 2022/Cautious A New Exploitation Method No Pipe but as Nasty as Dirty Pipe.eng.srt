1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:06,859 --> 00:00:09,859
thank you

3
00:00:10,800 --> 00:00:14,519
thanks thanks for introduction

4
00:00:14,519 --> 00:00:17,699
so welcome to my talk

5
00:00:17,699 --> 00:00:19,440
um I'm going to start with an

6
00:00:19,440 --> 00:00:21,900
introduction about us my name is Jim

7
00:00:21,900 --> 00:00:24,779
Haley I am a PhD student at Northwestern

8
00:00:24,779 --> 00:00:27,900
University my research focuses on system

9
00:00:27,900 --> 00:00:31,199
security I found box exploit box and

10
00:00:31,199 --> 00:00:32,640
feedback

11
00:00:32,640 --> 00:00:34,700
the guy in the middle is

12
00:00:34,700 --> 00:00:37,500
who is also a puree student at

13
00:00:37,500 --> 00:00:40,739
Northwestern University he is a CTF guy

14
00:00:40,739 --> 00:00:42,420
which are very similar research

15
00:00:42,420 --> 00:00:43,680
interests

16
00:00:43,680 --> 00:00:46,800
both of us are advised by Siri Xing who

17
00:00:46,800 --> 00:00:49,140
is a professor at Northwestern

18
00:00:49,140 --> 00:00:51,620
University

19
00:00:52,620 --> 00:00:56,160
so 30 pipe this is mentioned in the

20
00:00:56,160 --> 00:00:57,539
title

21
00:00:57,539 --> 00:00:59,760
30 pack is named for the kernel

22
00:00:59,760 --> 00:01:03,840
vulnerability CV 2022-0847

23
00:01:03,840 --> 00:01:06,960
it's an initializer bug a Linux kernels

24
00:01:06,960 --> 00:01:08,580
type subsystem

25
00:01:08,580 --> 00:01:12,900
the bug affects kernel V 5.8 and higher

26
00:01:12,900 --> 00:01:15,240
one of the most interesting thing about

27
00:01:15,240 --> 00:01:18,060
the knee pipe is its exploitation

28
00:01:18,060 --> 00:01:19,920
unlike unconventional kernel

29
00:01:19,920 --> 00:01:22,200
exploitation it doesn't hijack control

30
00:01:22,200 --> 00:01:23,220
flow

31
00:01:23,220 --> 00:01:26,759
it's a data holding exploitation so no

32
00:01:26,759 --> 00:01:29,340
rock is needed and it doesn't have to

33
00:01:29,340 --> 00:01:31,680
bypass kslr

34
00:01:31,680 --> 00:01:34,259
the effect of the exploitation is also

35
00:01:34,259 --> 00:01:35,159
different

36
00:01:35,159 --> 00:01:38,159
it doesn't execute code with kernel

37
00:01:38,159 --> 00:01:41,400
privilege instead it can override any

38
00:01:41,400 --> 00:01:43,680
files as long as we have read permission

39
00:01:43,680 --> 00:01:44,820
to it

40
00:01:44,820 --> 00:01:48,000
with such capability 35 even

41
00:01:48,000 --> 00:01:50,159
demonstrated local privilege escalation

42
00:01:50,159 --> 00:01:53,180
or Android system

43
00:01:54,299 --> 00:01:57,479
3D pipe is so powerful and has attracted

44
00:01:57,479 --> 00:01:59,100
so many attentions

45
00:01:59,100 --> 00:02:02,640
but what we learned from dirt you have

46
00:02:02,640 --> 00:02:05,460
from my understanding I think the one of

47
00:02:05,460 --> 00:02:09,119
the most interesting thing I learned is

48
00:02:09,119 --> 00:02:11,700
data only attack is powerful

49
00:02:11,700 --> 00:02:14,760
it brings many benefits

50
00:02:14,760 --> 00:02:18,120
first a data only attack method could

51
00:02:18,120 --> 00:02:21,180
allow you to write a universal exploit

52
00:02:21,180 --> 00:02:23,760
what does universal mean

53
00:02:23,760 --> 00:02:26,580
it means that the exploit code Quran

54
00:02:26,580 --> 00:02:28,260
calls different kernels different

55
00:02:28,260 --> 00:02:32,160
architectures without any modification

56
00:02:32,160 --> 00:02:35,459
second it doesn't have to deal with CFI

57
00:02:35,459 --> 00:02:38,340
which is an effective mitigation for

58
00:02:38,340 --> 00:02:39,720
roughs

59
00:02:39,720 --> 00:02:42,420
CFI is enabling Android kernel which

60
00:02:42,420 --> 00:02:44,580
makes Android kernel exploitation much

61
00:02:44,580 --> 00:02:45,840
harder

62
00:02:45,840 --> 00:02:47,040
third

63
00:02:47,040 --> 00:02:49,920
most mitigation focuses on protecting

64
00:02:49,920 --> 00:02:52,379
control flow Integrity very few

65
00:02:52,379 --> 00:02:55,080
mitigation in Linux kernel protects data

66
00:02:55,080 --> 00:02:57,000
only integrity

67
00:02:57,000 --> 00:02:59,819
that's why there's no effect exploiting

68
00:02:59,819 --> 00:03:03,120
mitigation for dirty pipe so we need

69
00:03:03,120 --> 00:03:06,019
those mitigations

70
00:03:07,519 --> 00:03:11,760
this all sounds interesting but 35 is

71
00:03:11,760 --> 00:03:13,260
not perfect

72
00:03:13,260 --> 00:03:14,640
first

73
00:03:14,640 --> 00:03:17,580
35 candle is gapped from container

74
00:03:17,580 --> 00:03:19,140
actively

75
00:03:19,140 --> 00:03:21,599
escaping from container can only be done

76
00:03:21,599 --> 00:03:24,300
under certain conditions where the whole

77
00:03:24,300 --> 00:03:26,640
The holster is interacting with the

78
00:03:26,640 --> 00:03:27,599
container

79
00:03:27,599 --> 00:03:31,260
in this case 35 can overwrite the file

80
00:03:31,260 --> 00:03:34,080
on the host to execute the command

81
00:03:34,080 --> 00:03:37,019
but this can be achieved when the host

82
00:03:37,019 --> 00:03:40,200
is doing nothing in other words 35

83
00:03:40,200 --> 00:03:45,000
cannot actively escape from container

84
00:03:45,000 --> 00:03:49,739
second 35 is just a bug it's not a

85
00:03:49,739 --> 00:03:52,080
generic exploitation method that could

86
00:03:52,080 --> 00:03:55,340
benefit other bugs

87
00:03:55,379 --> 00:03:58,080
in this talk I would like to introduce a

88
00:03:58,080 --> 00:04:01,140
new exploitation method named 30 Christ

89
00:04:01,140 --> 00:04:03,659
the high level idea of the required is

90
00:04:03,659 --> 00:04:06,720
to swap then its kernel credentials

91
00:04:06,720 --> 00:04:10,260
the method has several advantages first

92
00:04:10,260 --> 00:04:13,319
it's a generic exploitation method

93
00:04:13,319 --> 00:04:16,019
it's very simple which just needs a few

94
00:04:16,019 --> 00:04:18,720
steps but it's very effective

95
00:04:18,720 --> 00:04:22,260
second similar to dirty path you could

96
00:04:22,260 --> 00:04:24,600
write a data only exploit

97
00:04:24,600 --> 00:04:27,180
and without dealing with CFI and Rob

98
00:04:27,180 --> 00:04:29,160
staff third

99
00:04:29,160 --> 00:04:31,560
with 30 credits you are capable of

100
00:04:31,560 --> 00:04:34,139
escaping from container actively

101
00:04:34,139 --> 00:04:38,060
which cannot be done by Dirty pipe

102
00:04:38,639 --> 00:04:41,880
so some summary here first the required

103
00:04:41,880 --> 00:04:45,300
is a generic exploitation method well 30

104
00:04:45,300 --> 00:04:46,740
pipe is a bug

105
00:04:46,740 --> 00:04:49,800
second both of them could generate data

106
00:04:49,800 --> 00:04:51,780
only Universal exploit

107
00:04:51,780 --> 00:04:55,259
third since they are data only so

108
00:04:55,259 --> 00:04:59,040
they could bypass CFI fourth Duty credit

109
00:04:59,040 --> 00:05:02,160
can actively escape from container

110
00:05:02,160 --> 00:05:05,100
which 30 type is not capable of

111
00:05:05,100 --> 00:05:06,780
last but not least

112
00:05:06,780 --> 00:05:09,900
3D pipe is a bug that has been fixed so

113
00:05:09,900 --> 00:05:12,300
the thread has been removed

114
00:05:12,300 --> 00:05:14,639
as the exploitation method

115
00:05:14,639 --> 00:05:20,240
30 30 quad is not available

116
00:05:25,860 --> 00:05:28,039
foreign

117
00:05:28,820 --> 00:05:31,979
attacks kernel credentials what are

118
00:05:31,979 --> 00:05:34,680
kernel credentials

119
00:05:34,680 --> 00:05:37,860
in short kernel credentials are property

120
00:05:37,860 --> 00:05:40,199
that carry privileged information in

121
00:05:40,199 --> 00:05:41,460
kernel

122
00:05:41,460 --> 00:05:43,680
according to Colonel's documentation

123
00:05:43,680 --> 00:05:46,199
there are they are the representation of

124
00:05:46,199 --> 00:05:49,380
users privilege and capability

125
00:05:49,380 --> 00:05:52,080
it Linux Kernel's implementation there

126
00:05:52,080 --> 00:05:54,620
are two main types of credentials

127
00:05:54,620 --> 00:05:58,080
credentials and open file credentials

128
00:05:58,080 --> 00:06:00,860
task credential is for each kernel task

129
00:06:00,860 --> 00:06:04,259
while open file credential includes the

130
00:06:04,259 --> 00:06:07,440
privileged information to an open file

131
00:06:07,440 --> 00:06:10,860
with those credentials Security checks X

132
00:06:10,860 --> 00:06:14,100
on them to examine the privilege

133
00:06:14,100 --> 00:06:16,199
I will give examples of how kernel

134
00:06:16,199 --> 00:06:19,940
implements learn and how to use them

135
00:06:20,639 --> 00:06:24,479
first task credentials it's implemented

136
00:06:24,479 --> 00:06:27,479
as strong Credit in Linux kernel

137
00:06:27,479 --> 00:06:30,180
each kernel task references to a scrap

138
00:06:30,180 --> 00:06:33,000
thread allocated on Heap the credit is

139
00:06:33,000 --> 00:06:36,120
used to examine user privilege for

140
00:06:36,120 --> 00:06:38,100
unpreviewed user the crowd is

141
00:06:38,100 --> 00:06:40,560
unprivileged

142
00:06:40,560 --> 00:06:42,740
when there is a new unprivileged user

143
00:06:42,740 --> 00:06:45,360
spawning a new kernel task

144
00:06:45,360 --> 00:06:47,940
kernel will allocate a unprivileged crap

145
00:06:47,940 --> 00:06:50,520
on a free memory slot

146
00:06:50,520 --> 00:06:53,460
if a user is privileged

147
00:06:53,460 --> 00:06:55,259
kernel will allocate a privilege

148
00:06:55,259 --> 00:06:58,080
required on the Heap

149
00:06:58,080 --> 00:07:00,780
users with privileged credentials are

150
00:07:00,780 --> 00:07:03,720
viewed as root users and this is how

151
00:07:03,720 --> 00:07:07,440
kernel uses task credentials

152
00:07:07,440 --> 00:07:10,919
next open file credentials it's

153
00:07:10,919 --> 00:07:14,160
implemented as scrap file a Linux kernel

154
00:07:14,160 --> 00:07:16,919
similar to straw crime it's stored on

155
00:07:16,919 --> 00:07:18,600
kernel Heap

156
00:07:18,600 --> 00:07:21,419
a new straw file will be created on

157
00:07:21,419 --> 00:07:24,060
kernel Heap on the file or file is

158
00:07:24,060 --> 00:07:25,560
opened

159
00:07:25,560 --> 00:07:27,840
the straw file contains several fields

160
00:07:27,840 --> 00:07:30,060
that we need to care about

161
00:07:30,060 --> 00:07:34,919
first it contains how the file is opened

162
00:07:34,919 --> 00:07:37,560
for example on the slice the file is

163
00:07:37,560 --> 00:07:40,680
opened in read and write mode then the F

164
00:07:40,680 --> 00:07:42,900
mode field will have the corresponding

165
00:07:42,900 --> 00:07:45,060
Flags

166
00:07:45,060 --> 00:07:48,000
this the file track has a reference to

167
00:07:48,000 --> 00:07:52,580
the struck thread of users who open it

168
00:07:53,699 --> 00:07:56,460
the straw file encodes Lafell which is

169
00:07:56,460 --> 00:07:59,639
under operation on the slice the straw

170
00:07:59,639 --> 00:08:01,979
file enclosed the dummy file which is

171
00:08:01,979 --> 00:08:05,060
what we just opened

172
00:08:06,120 --> 00:08:08,520
when the file is open the access

173
00:08:08,520 --> 00:08:10,680
information to the file will be

174
00:08:10,680 --> 00:08:14,099
transferred to the struct file so kernel

175
00:08:14,099 --> 00:08:16,860
checks on the straw file to see if the

176
00:08:16,860 --> 00:08:19,919
access is allowed so let's take a look

177
00:08:19,919 --> 00:08:22,560
at this example when we try to write

178
00:08:22,560 --> 00:08:25,800
content to the file we just opened

179
00:08:25,800 --> 00:08:28,680
kernel will checks whether the F mode in

180
00:08:28,680 --> 00:08:30,960
this rough L contains a red flag

181
00:08:30,960 --> 00:08:33,240
since we open the file in the in the

182
00:08:33,240 --> 00:08:35,820
with the red permission so the

183
00:08:35,820 --> 00:08:39,000
permission check will be satisfied

184
00:08:39,000 --> 00:08:41,099
and eventually the content will be

185
00:08:41,099 --> 00:08:44,120
written to the disk

186
00:08:44,120 --> 00:08:48,120
however if a file is opened with read

187
00:08:48,120 --> 00:08:51,540
only mode which doesn't specify relative

188
00:08:51,540 --> 00:08:54,240
information the kernel will create a

189
00:08:54,240 --> 00:08:57,120
file object with read alien flag in a f

190
00:08:57,120 --> 00:09:00,540
read fmodel field we will try to write

191
00:09:00,540 --> 00:09:03,600
to this file the rest is called will

192
00:09:03,600 --> 00:09:05,820
will be denied because the permission

193
00:09:05,820 --> 00:09:10,160
check on the file will fail

194
00:09:10,440 --> 00:09:13,320
and they eventually write into disk will

195
00:09:13,320 --> 00:09:16,380
fail and this is how kernel uses open

196
00:09:16,380 --> 00:09:19,220
file credential

197
00:09:19,800 --> 00:09:21,180
so with

198
00:09:21,180 --> 00:09:23,580
the background in mind then I'm going to

199
00:09:23,580 --> 00:09:26,339
talk about how dirty crap attacks in

200
00:09:26,339 --> 00:09:28,019
these kernel credentials

201
00:09:28,019 --> 00:09:30,600
the high level idea of the required is

202
00:09:30,600 --> 00:09:33,959
to swap kernel credentials specifically

203
00:09:33,959 --> 00:09:37,440
it swaps unprivileged credentials with

204
00:09:37,440 --> 00:09:39,420
privileged credentials to escalate

205
00:09:39,420 --> 00:09:42,360
privilege in the following I'm going to

206
00:09:42,360 --> 00:09:44,760
talk about two parts of attacks which

207
00:09:44,760 --> 00:09:47,399
are attack attacking task credentials

208
00:09:47,399 --> 00:09:50,779
and open vowel credentials

209
00:09:50,820 --> 00:09:55,040
first attacking task credentials

210
00:09:55,040 --> 00:09:57,839
in Linux kernel each kernel task

211
00:09:57,839 --> 00:10:02,399
references to a structure on a heap

212
00:10:02,399 --> 00:10:05,040
the first step of the attack is to

213
00:10:05,040 --> 00:10:07,800
utilize kernel box to free an

214
00:10:07,800 --> 00:10:09,899
unprivileged required that belongs to

215
00:10:09,899 --> 00:10:13,160
the attacker's task

216
00:10:13,440 --> 00:10:16,200
once the credit is freed the memory slot

217
00:10:16,200 --> 00:10:18,540
will be marked as freed by the HIPAA

218
00:10:18,540 --> 00:10:20,959
allocator

219
00:10:21,360 --> 00:10:24,899
in the second step we spawn new new

220
00:10:24,899 --> 00:10:27,360
privileged kernel tasks

221
00:10:27,360 --> 00:10:30,420
which indeed will allocate a privileged

222
00:10:30,420 --> 00:10:33,360
credential on the Kernel Heap the Hebrew

223
00:10:33,360 --> 00:10:35,700
allocator will reuse the freedom memory

224
00:10:35,700 --> 00:10:39,480
slot and place the new credit on it

225
00:10:39,480 --> 00:10:42,060
after this step the credit of the

226
00:10:42,060 --> 00:10:45,000
attacker's task will change from the

227
00:10:45,000 --> 00:10:47,220
unpreviewed credit to create privilege

228
00:10:47,220 --> 00:10:49,579
request then they can operate as

229
00:10:49,579 --> 00:10:53,220
privileged users and this is how dirty

230
00:10:53,220 --> 00:10:57,019
crack attacks task credential

231
00:10:57,600 --> 00:10:59,940
next I'm going to talk about how Duty

232
00:10:59,940 --> 00:11:02,459
credit attacks open file credentials

233
00:11:02,459 --> 00:11:05,100
which is straw file in kernels

234
00:11:05,100 --> 00:11:07,760
implementation

235
00:11:09,000 --> 00:11:11,880
struct file is used to exam permission

236
00:11:11,880 --> 00:11:15,000
when accessing the file we opened

237
00:11:15,000 --> 00:11:17,519
when the permission check is done the

238
00:11:17,519 --> 00:11:19,560
right operation of the file system will

239
00:11:19,560 --> 00:11:21,839
be invoked to do the real

240
00:11:21,839 --> 00:11:24,740
content right

241
00:11:24,899 --> 00:11:27,720
so the first step of attacking open file

242
00:11:27,720 --> 00:11:30,839
credential is to free the file struct in

243
00:11:30,839 --> 00:11:32,519
kernel memory

244
00:11:32,519 --> 00:11:35,640
this step should be happening after the

245
00:11:35,640 --> 00:11:39,060
permission check is satisfied but before

246
00:11:39,060 --> 00:11:42,480
the right into the file system is is

247
00:11:42,480 --> 00:11:44,940
beginning

248
00:11:44,940 --> 00:11:48,000
after freeing the Rafael in the kernel

249
00:11:48,000 --> 00:11:51,000
Heap memory the memory slot becomes free

250
00:11:51,000 --> 00:11:53,899
the full reuse

251
00:11:54,899 --> 00:11:57,779
in the second step we open a file that

252
00:11:57,779 --> 00:12:00,420
we that we want to overwrite for example

253
00:12:00,420 --> 00:12:03,660
we open the ETC password file

254
00:12:03,660 --> 00:12:06,420
since it is a password file is not

255
00:12:06,420 --> 00:12:08,820
readable for unpreviewed users we open

256
00:12:08,820 --> 00:12:10,800
that in read-only mode

257
00:12:10,800 --> 00:12:13,260
this operation will allocate a new file

258
00:12:13,260 --> 00:12:16,920
struct with read-only flag on the Kernel

259
00:12:16,920 --> 00:12:19,279
Heap

260
00:12:20,279 --> 00:12:22,860
and the Hebrew allocator will reuse the

261
00:12:22,860 --> 00:12:26,220
freed memory and eventually

262
00:12:26,220 --> 00:12:28,860
this allocation will recline the memory

263
00:12:28,860 --> 00:12:30,540
slot we just read

264
00:12:30,540 --> 00:12:33,300
after this step the struct file in

265
00:12:33,300 --> 00:12:35,760
kernel Heap will be swapped from the

266
00:12:35,760 --> 00:12:39,120
dummy file to the ETC password file

267
00:12:39,120 --> 00:12:41,760
because the permission check on the file

268
00:12:41,760 --> 00:12:43,500
has been done before

269
00:12:43,500 --> 00:12:46,260
the right Cisco will not be denied even

270
00:12:46,260 --> 00:12:48,420
though the F mode of a straw file is

271
00:12:48,420 --> 00:12:51,779
real it's real early

272
00:12:51,779 --> 00:12:55,139
in step 3 when kernel continues to

273
00:12:55,139 --> 00:12:57,540
execute it will do the actual file right

274
00:12:57,540 --> 00:13:00,959
on a disk this time since we have

275
00:13:00,959 --> 00:13:03,300
swapped the file struct it actually

276
00:13:03,300 --> 00:13:05,639
writes the content to the ETC password

277
00:13:05,639 --> 00:13:07,019
file

278
00:13:07,019 --> 00:13:09,420
and this is how the required attacks

279
00:13:09,420 --> 00:13:11,540
open file credentials

280
00:13:11,540 --> 00:13:13,079
[Music]

281
00:13:13,079 --> 00:13:17,459
so in summary the required follows three

282
00:13:17,459 --> 00:13:21,480
steps to launch your attack first three

283
00:13:21,480 --> 00:13:23,880
the attackers unprivileged credential

284
00:13:23,880 --> 00:13:25,980
with the vulnerability

285
00:13:25,980 --> 00:13:28,740
second we claim the freed memory slots

286
00:13:28,740 --> 00:13:31,740
by allocating a privileged credential

287
00:13:31,740 --> 00:13:33,060
third

288
00:13:33,060 --> 00:13:35,579
after the credential is swapped the

289
00:13:35,579 --> 00:13:40,219
attacker can operate as previous users

290
00:13:41,579 --> 00:13:43,680
these three steps sound pretty

291
00:13:43,680 --> 00:13:45,899
straightforward but doing so is

292
00:13:45,899 --> 00:13:47,160
challenging

293
00:13:47,160 --> 00:13:49,620
first three required requires the

294
00:13:49,620 --> 00:13:52,320
capability on the credential object

295
00:13:52,320 --> 00:13:54,060
which is challenging when the

296
00:13:54,060 --> 00:13:55,920
vulnerability doesn't have such

297
00:13:55,920 --> 00:13:58,459
capability

298
00:13:58,860 --> 00:14:01,500
this is because both cred and the file

299
00:14:01,500 --> 00:14:03,899
objects are allocated on dedicated

300
00:14:03,899 --> 00:14:07,220
memory cache well most of vulnerability

301
00:14:07,220 --> 00:14:10,519
do not happen on those two memory caches

302
00:14:10,519 --> 00:14:15,300
indeed they may happen on generic memory

303
00:14:15,300 --> 00:14:19,500
caches which I use mostly about a kernel

304
00:14:19,500 --> 00:14:21,720
besides most of vulnerability may not

305
00:14:21,720 --> 00:14:24,620
have three capability

306
00:14:26,040 --> 00:14:29,220
our solution to it is to Pivot

307
00:14:29,220 --> 00:14:31,200
vulnerability capability

308
00:14:31,200 --> 00:14:33,180
in the following I'm going to talk about

309
00:14:33,180 --> 00:14:37,139
how to Pivot invalid right which is Auto

310
00:14:37,139 --> 00:14:40,560
Bond rate and use of the free ride and

311
00:14:40,560 --> 00:14:43,440
pivoting invalid free which is double

312
00:14:43,440 --> 00:14:46,399
free for example

313
00:14:46,980 --> 00:14:50,820
so first pved invalids right

314
00:14:50,820 --> 00:14:52,079
thank you

315
00:14:52,079 --> 00:14:56,100
to Pivot invalid's right capability to

316
00:14:56,100 --> 00:14:59,760
freeing a credential object

317
00:14:59,760 --> 00:15:03,180
our idea is to leverage victim objects

318
00:15:03,180 --> 00:15:05,279
that contains a reference to a

319
00:15:05,279 --> 00:15:06,959
credential object

320
00:15:06,959 --> 00:15:09,959
let's look at the code on the right side

321
00:15:09,959 --> 00:15:13,079
the request key of struct contains a

322
00:15:13,079 --> 00:15:16,920
reference to a struct to a quest object

323
00:15:16,920 --> 00:15:19,560
when it's allocated on kernel Heap its

324
00:15:19,560 --> 00:15:21,480
memory layout could be similar to the

325
00:15:21,480 --> 00:15:23,339
picture on the left side

326
00:15:23,339 --> 00:15:26,339
we have a victim object it contains a

327
00:15:26,339 --> 00:15:29,459
pointer pointing to a credential object

328
00:15:29,459 --> 00:15:33,500
in its own memory cache

329
00:15:34,500 --> 00:15:37,800
from a hip for hip overflow we put such

330
00:15:37,800 --> 00:15:40,740
a victim object right after the Overflow

331
00:15:40,740 --> 00:15:44,399
object so the credit field will be in

332
00:15:44,399 --> 00:15:46,560
the Overflow memory region

333
00:15:46,560 --> 00:15:50,040
for use of the free we overlap

334
00:15:50,040 --> 00:15:52,019
the use of the free object with the

335
00:15:52,019 --> 00:15:54,779
victim object in the meantime the credit

336
00:15:54,779 --> 00:15:57,720
field is also in other memory region of

337
00:15:57,720 --> 00:16:00,800
the use of free ride

338
00:16:00,899 --> 00:16:04,320
next we trigger the vulnerability and

339
00:16:04,320 --> 00:16:06,480
partially overwrite the credit pointer

340
00:16:06,480 --> 00:16:09,300
making a reference to another credential

341
00:16:09,300 --> 00:16:10,440
object

342
00:16:10,440 --> 00:16:12,720
the credential object is managed by

343
00:16:12,720 --> 00:16:15,300
reference count the pointer change will

344
00:16:15,300 --> 00:16:19,500
cause a reference counter unbalance

345
00:16:19,500 --> 00:16:22,019
at the end when we trigger the free of

346
00:16:22,019 --> 00:16:24,000
the vulnerability we will free the

347
00:16:24,000 --> 00:16:26,220
credential object with the tempered

348
00:16:26,220 --> 00:16:29,220
reference and this is how we pivot

349
00:16:29,220 --> 00:16:31,980
invalid to write

350
00:16:31,980 --> 00:16:36,420
next PVD in value free

351
00:16:36,420 --> 00:16:39,360
for invalid free vulnerability we have

352
00:16:39,360 --> 00:16:41,699
two references referencing to the same

353
00:16:41,699 --> 00:16:42,660
object

354
00:16:42,660 --> 00:16:45,959
so a possible memory layout could be

355
00:16:45,959 --> 00:16:48,380
like this

356
00:16:49,380 --> 00:16:51,899
in the first step we free the vulnerable

357
00:16:51,899 --> 00:16:55,699
object from a reference

358
00:16:56,399 --> 00:17:00,000
second we free all the object in the

359
00:17:00,000 --> 00:17:03,180
same memory cache which eventually will

360
00:17:03,180 --> 00:17:07,159
free the memory page for the cache

361
00:17:07,319 --> 00:17:10,199
in the third step we allocate a bunch of

362
00:17:10,199 --> 00:17:12,660
credential objects to reclaim the freed

363
00:17:12,660 --> 00:17:14,099
memory page

364
00:17:14,099 --> 00:17:17,220
this process is called cross-cash attack

365
00:17:17,220 --> 00:17:19,859
after this the memory slot of the

366
00:17:19,859 --> 00:17:22,079
vulnerable object will be okay will be

367
00:17:22,079 --> 00:17:25,859
occupied by credential object so the

368
00:17:25,859 --> 00:17:28,079
remainder reference will be pointing to

369
00:17:28,079 --> 00:17:31,159
a credential object

370
00:17:31,380 --> 00:17:34,799
finally we utilize the reference which

371
00:17:34,799 --> 00:17:36,840
is a dangling pointer to free the

372
00:17:36,840 --> 00:17:39,299
credential object

373
00:17:39,299 --> 00:17:41,700
and this is a process of activity in

374
00:17:41,700 --> 00:17:44,299
value free

375
00:17:45,840 --> 00:17:48,780
the Second Challenge is how to allocate

376
00:17:48,780 --> 00:17:50,460
allocate preview the credential as

377
00:17:50,460 --> 00:17:53,539
unpreviewed users

378
00:17:53,760 --> 00:17:57,000
in Linux kernel unprivileged users come

379
00:17:57,000 --> 00:17:59,640
with unprivileged task credentials

380
00:17:59,640 --> 00:18:01,799
so you cannot directly allocate the

381
00:18:01,799 --> 00:18:03,539
privilege credentials

382
00:18:03,539 --> 00:18:06,980
a simple solution to it is to

383
00:18:06,980 --> 00:18:10,020
just waiting for privileged users to do

384
00:18:10,020 --> 00:18:10,740
so

385
00:18:10,740 --> 00:18:13,620
but it's unpredictable which could

386
00:18:13,620 --> 00:18:16,799
influence the successful rate so we

387
00:18:16,799 --> 00:18:18,600
should take a look for

388
00:18:18,600 --> 00:18:20,460
something that is more determined

389
00:18:20,460 --> 00:18:23,460
deterministic

390
00:18:24,000 --> 00:18:26,520
we figured out there are two types of

391
00:18:26,520 --> 00:18:29,700
solutions one is from user space we

392
00:18:29,700 --> 00:18:32,100
could trigger the privileged user space

393
00:18:32,100 --> 00:18:33,419
process

394
00:18:33,419 --> 00:18:37,080
Elaine is Kernel executables with roots

395
00:18:37,080 --> 00:18:40,320
seoid could run as root users so they

396
00:18:40,320 --> 00:18:43,320
come with privileged credentials those X

397
00:18:43,320 --> 00:18:46,620
cable includes Su and mount

398
00:18:46,620 --> 00:18:49,679
by simply executing them we could force

399
00:18:49,679 --> 00:18:51,480
kernel to allocate the privileged

400
00:18:51,480 --> 00:18:53,340
required

401
00:18:53,340 --> 00:18:57,480
other than suyd executables some demons

402
00:18:57,480 --> 00:19:00,539
running as rude users who also allocate

403
00:19:00,539 --> 00:19:02,640
privilege credentials in linear

404
00:19:02,640 --> 00:19:04,740
credentials in kernel

405
00:19:04,740 --> 00:19:08,880
for example SS key we could interact

406
00:19:08,880 --> 00:19:11,580
with it by establishing excess

407
00:19:11,580 --> 00:19:14,160
connections to the system and it will

408
00:19:14,160 --> 00:19:18,559
allocate the previous price for us

409
00:19:19,320 --> 00:19:22,140
another solution is from the kernel

410
00:19:22,140 --> 00:19:23,039
space

411
00:19:23,039 --> 00:19:25,080
privilege required could be allocated

412
00:19:25,080 --> 00:19:28,740
through new privileged kernels threat

413
00:19:28,740 --> 00:19:30,660
for some place calls

414
00:19:30,660 --> 00:19:33,059
if the user space sends too many

415
00:19:33,059 --> 00:19:34,980
requests to Kernel

416
00:19:34,980 --> 00:19:37,740
kernel will spawn new kernel workers to

417
00:19:37,740 --> 00:19:40,260
handle the requests which will allocate

418
00:19:40,260 --> 00:19:41,940
a new privilege credentials for those

419
00:19:41,940 --> 00:19:44,039
workers as a result

420
00:19:44,039 --> 00:19:46,500
another way from kernel space is to

421
00:19:46,500 --> 00:19:49,799
invoke the user mode helper which is to

422
00:19:49,799 --> 00:19:52,320
load kernel modules from user space

423
00:19:52,320 --> 00:19:54,780
when a user mode helpers requested

424
00:19:54,780 --> 00:19:58,080
kernel will spawn new kernel threads to

425
00:19:58,080 --> 00:20:00,900
execute a user space boundary as a

426
00:20:00,900 --> 00:20:03,419
result this allocates new privilege

427
00:20:03,419 --> 00:20:05,100
credentials

428
00:20:05,100 --> 00:20:07,200
those are the solutions to our Second

429
00:20:07,200 --> 00:20:09,740
Challenge

430
00:20:10,080 --> 00:20:12,960
the third challenge is to stabilize file

431
00:20:12,960 --> 00:20:15,480
exploitation when attacking open file

432
00:20:15,480 --> 00:20:18,200
credentials

433
00:20:18,780 --> 00:20:22,140
when swapping open file credentials we

434
00:20:22,140 --> 00:20:25,080
could confuse a kernel to validate to

435
00:20:25,080 --> 00:20:27,720
write data to another file the timing of

436
00:20:27,720 --> 00:20:30,419
doing a swap is really important

437
00:20:30,419 --> 00:20:33,240
if a swap starts before the permission

438
00:20:33,240 --> 00:20:36,600
check the F mode of the file object will

439
00:20:36,600 --> 00:20:39,480
be read only which results in deny of

440
00:20:39,480 --> 00:20:42,440
the right Cisco

441
00:20:43,500 --> 00:20:46,380
if the swap happens after writing to the

442
00:20:46,380 --> 00:20:49,919
disk kernel will just write dummy file

443
00:20:49,919 --> 00:20:54,260
instead of Etc passwords

444
00:20:55,140 --> 00:20:58,200
so the swap must happen between the

445
00:20:58,200 --> 00:21:00,240
permission check and that the actual

446
00:21:00,240 --> 00:21:01,620
file right

447
00:21:01,620 --> 00:21:04,140
this time window is crucial to the

448
00:21:04,140 --> 00:21:07,140
successful of the attack

449
00:21:07,140 --> 00:21:09,360
but this time we know is very small

450
00:21:09,360 --> 00:21:11,760
because writing content to the file

451
00:21:11,760 --> 00:21:13,740
happens very quickly

452
00:21:13,740 --> 00:21:15,960
during the swap during this time this

453
00:21:15,960 --> 00:21:19,260
small time Windows might be unstable or

454
00:21:19,260 --> 00:21:21,980
even invisible

455
00:21:23,039 --> 00:21:26,760
so our solution to this is to extend the

456
00:21:26,760 --> 00:21:28,799
time window to make the attack

457
00:21:28,799 --> 00:21:30,900
deterministic

458
00:21:30,900 --> 00:21:33,059
the first solution is that we could

459
00:21:33,059 --> 00:21:36,000
utilize user fold ft or fuse to pause

460
00:21:36,000 --> 00:21:37,440
kernel execution

461
00:21:37,440 --> 00:21:40,080
during this time window when the kernel

462
00:21:40,080 --> 00:21:42,419
access user space memory that is managed

463
00:21:42,419 --> 00:21:45,419
by the user folder FD or fuse kernel

464
00:21:45,419 --> 00:21:48,740
execution will be paused

465
00:21:49,500 --> 00:21:53,580
before kernel V 4.13 we could pause

466
00:21:53,580 --> 00:21:56,640
kernel execution it's import our Vector

467
00:21:56,640 --> 00:21:57,780
function

468
00:21:57,780 --> 00:22:00,419
let's look at the red V function on the

469
00:22:00,419 --> 00:22:03,419
slice it's the implementation of writing

470
00:22:03,419 --> 00:22:06,000
Vector data to a file

471
00:22:06,000 --> 00:22:08,340
in the function currently offers a check

472
00:22:08,340 --> 00:22:10,820
permission

473
00:22:10,919 --> 00:22:13,500
it checks whether the file struck is

474
00:22:13,500 --> 00:22:15,780
created with write permission

475
00:22:15,780 --> 00:22:18,539
after the check is satisfied kernel

476
00:22:18,539 --> 00:22:21,780
Imports virtual data from user space

477
00:22:21,780 --> 00:22:24,120
this is the point where we could pause

478
00:22:24,120 --> 00:22:29,239
kernel execution which useful FD of use

479
00:22:30,539 --> 00:22:33,539
this technique was used in gen Horn's

480
00:22:33,539 --> 00:22:35,520
exploitation for cve

481
00:22:35,520 --> 00:22:40,140
2016 4557 by instead of the kernel V

482
00:22:40,140 --> 00:22:43,140
4.13

483
00:22:43,980 --> 00:22:46,740
this is the less the implementation of

484
00:22:46,740 --> 00:22:48,720
the red wave function

485
00:22:48,720 --> 00:22:51,600
the import of our Vector has been moved

486
00:22:51,600 --> 00:22:53,880
before the permission check so even

487
00:22:53,880 --> 00:22:55,740
though we could pause the execution at

488
00:22:55,740 --> 00:22:58,080
the import of our Vector we are no

489
00:22:58,080 --> 00:23:01,020
longer able to extend the time window so

490
00:23:01,020 --> 00:23:02,760
we should look for

491
00:23:02,760 --> 00:23:05,539
something else

492
00:23:06,000 --> 00:23:08,580
it turns out that we could pause kernel

493
00:23:08,580 --> 00:23:11,039
execution as generic performance write

494
00:23:11,039 --> 00:23:12,299
function

495
00:23:12,299 --> 00:23:15,480
the function is in the extra layer of

496
00:23:15,480 --> 00:23:19,020
the red Cisco so different file system

497
00:23:19,020 --> 00:23:22,200
uses before invoking their own right

498
00:23:22,200 --> 00:23:24,419
function in other words

499
00:23:24,419 --> 00:23:27,600
it will be caused by the red system in

500
00:23:27,600 --> 00:23:29,760
most of our systems after the permission

501
00:23:29,760 --> 00:23:31,740
check and the pitfall of the actual file

502
00:23:31,740 --> 00:23:32,940
right

503
00:23:32,940 --> 00:23:35,280
at the beginning of the function it will

504
00:23:35,280 --> 00:23:37,679
try to make a page fault on the user

505
00:23:37,679 --> 00:23:40,200
space buffer to avoid a possible data

506
00:23:40,200 --> 00:23:40,980
log

507
00:23:40,980 --> 00:23:43,380
and this page falls indeed will access

508
00:23:43,380 --> 00:23:46,559
the user space memory as a result we

509
00:23:46,559 --> 00:23:48,659
could utilize this access to pause

510
00:23:48,659 --> 00:23:51,419
current execution thus we could extend

511
00:23:51,419 --> 00:23:54,380
the time windows

512
00:23:56,340 --> 00:23:59,159
the first solution requires user for the

513
00:23:59,159 --> 00:24:02,100
FD or fuse to pause execution but

514
00:24:02,100 --> 00:24:04,440
sometimes those two techniques are

515
00:24:04,440 --> 00:24:07,260
unavailable for example in the docker

516
00:24:07,260 --> 00:24:10,440
so we should develop something else some

517
00:24:10,440 --> 00:24:12,240
other Solutions

518
00:24:12,240 --> 00:24:15,900
that don't utilize those two techniques

519
00:24:15,900 --> 00:24:18,840
and finally we found that there is a

520
00:24:18,840 --> 00:24:22,860
file lock in the rest that's fair system

521
00:24:22,860 --> 00:24:26,039
right which could be utilized

522
00:24:26,039 --> 00:24:29,940
but first what is file lock

523
00:24:29,940 --> 00:24:32,760
a Linux kernel each file has its own

524
00:24:32,760 --> 00:24:34,860
unique unknown object

525
00:24:34,860 --> 00:24:37,440
the file lock is maintained by the inode

526
00:24:37,440 --> 00:24:38,700
object

527
00:24:38,700 --> 00:24:42,120
the log mechanism is used in the valve

528
00:24:42,120 --> 00:24:44,640
systems grader operation

529
00:24:44,640 --> 00:24:46,380
this is the function

530
00:24:46,380 --> 00:24:49,080
the functional slice is a red operation

531
00:24:49,080 --> 00:24:51,659
of ext4 file system

532
00:24:51,659 --> 00:24:54,120
at the beginning of the function kernel

533
00:24:54,120 --> 00:24:56,880
will try to lock the eye note of the

534
00:24:56,880 --> 00:24:57,780
object

535
00:24:57,780 --> 00:25:00,600
after the writer is done the lock will

536
00:25:00,600 --> 00:25:03,900
be released this lock mechanism ensures

537
00:25:03,900 --> 00:25:06,720
the rate of multiple thread will be done

538
00:25:06,720 --> 00:25:08,940
in order

539
00:25:08,940 --> 00:25:11,880
The Muse this diagram to illustrate how

540
00:25:11,880 --> 00:25:13,080
this work

541
00:25:13,080 --> 00:25:16,620
so assuming that we have two threads

542
00:25:16,620 --> 00:25:20,340
says write a and squared B thread a and

543
00:25:20,340 --> 00:25:23,820
try B ground LSM time and the red to the

544
00:25:23,820 --> 00:25:24,960
same file

545
00:25:24,960 --> 00:25:26,880
both of them will pass the access

546
00:25:26,880 --> 00:25:28,799
permission check

547
00:25:28,799 --> 00:25:31,260
before doing the right thread a will

548
00:25:31,260 --> 00:25:34,080
lock the file from the eye note but

549
00:25:34,080 --> 00:25:36,600
rather B will have to wait for the lock

550
00:25:36,600 --> 00:25:39,240
until the right of the thread a is done

551
00:25:39,240 --> 00:25:41,340
and the lock is released

552
00:25:41,340 --> 00:25:44,279
with this lock the right operation will

553
00:25:44,279 --> 00:25:47,360
be done one by one

554
00:25:47,880 --> 00:25:51,539
the question is what if thread a write a

555
00:25:51,539 --> 00:25:53,700
large amount of data say four gigabytes

556
00:25:53,700 --> 00:25:57,480
which might take a dozen of seconds

557
00:25:57,480 --> 00:26:00,779
thing thread B will have two ways at

558
00:26:00,779 --> 00:26:04,020
least the same time to get a lock which

559
00:26:04,020 --> 00:26:06,059
leaves a larger time window between the

560
00:26:06,059 --> 00:26:08,820
permission check and doing the right

561
00:26:08,820 --> 00:26:11,220
in this way we could expand on time

562
00:26:11,220 --> 00:26:13,860
windows and the exploitation could be

563
00:26:13,860 --> 00:26:16,979
done deterministically

564
00:26:17,640 --> 00:26:21,960
all right demo demo time so we use this

565
00:26:21,960 --> 00:26:25,400
cve for the demonstration

566
00:26:27,059 --> 00:26:30,120
so we start with a low privileged user

567
00:26:30,120 --> 00:26:33,480
on the left side is centaurs with kernel

568
00:26:33,480 --> 00:26:36,480
4.18 on the right side it's Ubuntu 20

569
00:26:36,480 --> 00:26:39,120
with kernel 5.4

570
00:26:39,120 --> 00:26:41,340
before running the attack the ETC

571
00:26:41,340 --> 00:26:43,020
passport is intact

572
00:26:43,020 --> 00:26:45,600
the exploit code in two systems has the

573
00:26:45,600 --> 00:26:48,659
same empty check mt5 checksum which

574
00:26:48,659 --> 00:26:51,179
means they are the same X Y code

575
00:26:51,179 --> 00:26:54,179
then we build a build and run exploit

576
00:26:54,179 --> 00:26:57,000
and finally

577
00:26:57,000 --> 00:26:59,720
let's see

578
00:27:07,100 --> 00:27:10,260
and finally we tempered the ETS last

579
00:27:10,260 --> 00:27:12,480
board this Behavior could be done to

580
00:27:12,480 --> 00:27:16,159
escalate privilege to root

581
00:27:17,700 --> 00:27:20,539
we also have a demo on Android with

582
00:27:20,539 --> 00:27:23,880
kernel CFI enabled

583
00:27:23,880 --> 00:27:26,820
we removed some checks

584
00:27:26,820 --> 00:27:29,220
to make sure this vulnerability could be

585
00:27:29,220 --> 00:27:32,340
triggered or enjoyed so originally the

586
00:27:32,340 --> 00:27:34,799
file couldn't be read written by

587
00:27:34,799 --> 00:27:38,039
improved users and it's intact

588
00:27:38,039 --> 00:27:41,760
then we run exploit and eventually we

589
00:27:41,760 --> 00:27:45,140
tempered the content

590
00:27:53,360 --> 00:27:57,360
all right so here I want to summarize

591
00:27:57,360 --> 00:28:00,539
some advantages of 3D craft

592
00:28:00,539 --> 00:28:03,539
first it's a generic exploitation method

593
00:28:03,539 --> 00:28:05,640
that could Empower kernel exploitation

594
00:28:05,640 --> 00:28:09,179
for different bugs the method applies to

595
00:28:09,179 --> 00:28:12,120
container and Android kernel

596
00:28:12,120 --> 00:28:13,380
second

597
00:28:13,380 --> 00:28:17,039
the method is simple it just swaps

598
00:28:17,039 --> 00:28:19,559
kernel credentials but it's very

599
00:28:19,559 --> 00:28:21,779
effective and Powerful

600
00:28:21,779 --> 00:28:25,200
as a data method to request doesn't have

601
00:28:25,200 --> 00:28:28,140
to deal with kslr and the CFI

602
00:28:28,140 --> 00:28:30,600
and there's no public mitigation is

603
00:28:30,600 --> 00:28:32,279
available now

604
00:28:32,279 --> 00:28:36,779
so 30 quad is exploitation friendly you

605
00:28:36,779 --> 00:28:38,340
could write a dirty pipe like the

606
00:28:38,340 --> 00:28:41,159
universal exploit they could work

607
00:28:41,159 --> 00:28:42,960
they could work on different kernels

608
00:28:42,960 --> 00:28:46,700
without any code change

609
00:28:48,120 --> 00:28:51,299
so we have such a powerful exploitation

610
00:28:51,299 --> 00:28:52,559
method

611
00:28:52,559 --> 00:28:55,020
what can we possibly do to mitigate it

612
00:28:55,020 --> 00:28:57,299
and protect users

613
00:28:57,299 --> 00:29:00,059
do we have any mitigation suggestions

614
00:29:00,059 --> 00:29:01,980
yes we do

615
00:29:01,980 --> 00:29:04,460
the fundamental problem of the required

616
00:29:04,460 --> 00:29:08,340
is that the kernel credentials are

617
00:29:08,340 --> 00:29:11,039
isolated based on object type not on

618
00:29:11,039 --> 00:29:12,600
privilege level

619
00:29:12,600 --> 00:29:14,940
so I'm previewed credentials and

620
00:29:14,940 --> 00:29:16,740
privileged credentials will share the

621
00:29:16,740 --> 00:29:18,960
same memory cache and it will be

622
00:29:18,960 --> 00:29:21,120
overlapped with each other

623
00:29:21,120 --> 00:29:24,600
therefore they could be swapped

624
00:29:24,600 --> 00:29:27,539
with this in mind our solution is

625
00:29:27,539 --> 00:29:30,000
straightforward we isolate the

626
00:29:30,000 --> 00:29:32,340
privileged credentials into different

627
00:29:32,340 --> 00:29:35,580
different memory region specifically we

628
00:29:35,580 --> 00:29:39,720
I sold them into virtual memory so there

629
00:29:39,720 --> 00:29:41,940
is no Swap and no cross-cash attack

630
00:29:41,940 --> 00:29:43,440
anymore

631
00:29:43,440 --> 00:29:45,899
we have a prototype implementation and

632
00:29:45,899 --> 00:29:47,399
you could find the code it might get a

633
00:29:47,399 --> 00:29:49,699
variable

634
00:29:51,240 --> 00:29:53,880
finally some take

635
00:29:53,880 --> 00:29:55,500
a presentation

636
00:29:55,500 --> 00:29:59,100
first we introduce a new exploitation

637
00:29:59,100 --> 00:30:02,340
method named the required the code

638
00:30:02,340 --> 00:30:05,520
concept of 3D crime is to swap kernel

639
00:30:05,520 --> 00:30:08,880
credentials to escalate privilege

640
00:30:08,880 --> 00:30:12,659
second to realize the idea we developed

641
00:30:12,659 --> 00:30:15,120
principled approach to tackle different

642
00:30:15,120 --> 00:30:16,500
challenges

643
00:30:16,500 --> 00:30:19,740
third dirty crowd impulse kernel

644
00:30:19,740 --> 00:30:22,740
exploitation it makes exploit to be

645
00:30:22,740 --> 00:30:26,399
Universal they exploit the bypass all

646
00:30:26,399 --> 00:30:28,919
defenses available in Linux kernel and

647
00:30:28,919 --> 00:30:31,260
work across different kernels versions

648
00:30:31,260 --> 00:30:33,059
and architectures

649
00:30:33,059 --> 00:30:34,740
last but not least

650
00:30:34,740 --> 00:30:37,860
we introduce effect effective defense

651
00:30:37,860 --> 00:30:39,779
against the 30 credit card

652
00:30:39,779 --> 00:30:41,760
the defense isolated privilege

653
00:30:41,760 --> 00:30:43,980
credentials which solve the problem

654
00:30:43,980 --> 00:30:46,440
fundamentally

655
00:30:46,440 --> 00:30:48,659
that's all of my talk I would like to

656
00:30:48,659 --> 00:30:51,059
thank my collaborators again for the

657
00:30:51,059 --> 00:30:54,419
help in the think and think so dark heck

658
00:30:54,419 --> 00:30:56,399
for providing this cute logo for the

659
00:30:56,399 --> 00:30:59,039
decreased it's my not only to represent

660
00:30:59,039 --> 00:31:01,640
my work here

661
00:31:01,919 --> 00:31:04,100
foreign

662
00:31:07,910 --> 00:31:11,009
[Music]

