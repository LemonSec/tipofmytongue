1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,400 --> 00:00:09,720
thank you for the introduction so

3
00:00:09,720 --> 00:00:11,580
welcome to my presentation go with the

4
00:00:11,580 --> 00:00:13,679
flow my name is Claudia Canela I'm

5
00:00:13,679 --> 00:00:15,540
currently a PhD candidate at guards

6
00:00:15,540 --> 00:00:17,699
University of Technology in Austria if

7
00:00:17,699 --> 00:00:19,080
you want to reach out after the talk

8
00:00:19,080 --> 00:00:22,260
please do so via Twitter or by email

9
00:00:22,260 --> 00:00:24,180
so before I want to talk about what I'm

10
00:00:24,180 --> 00:00:25,560
actually going to present I want to

11
00:00:25,560 --> 00:00:28,080
present a little bit of motivation and

12
00:00:28,080 --> 00:00:30,060
one thing is that we do see quite a lot

13
00:00:30,060 --> 00:00:31,859
of attacks over the years so here we

14
00:00:31,859 --> 00:00:34,079
have the number of cves that is being

15
00:00:34,079 --> 00:00:36,239
that has been being issued over the

16
00:00:36,239 --> 00:00:37,860
years and as you can see here in this

17
00:00:37,860 --> 00:00:40,140
year we're already on our way on the way

18
00:00:40,140 --> 00:00:43,079
to surpass the values and that we've

19
00:00:43,079 --> 00:00:45,660
encountered in the previous years so we

20
00:00:45,660 --> 00:00:47,280
do need to find a way how we can

21
00:00:47,280 --> 00:00:50,399
mitigate against potential attacks

22
00:00:50,399 --> 00:00:52,800
typically we have two different ways

23
00:00:52,800 --> 00:00:55,199
that we can do this so the first thing

24
00:00:55,199 --> 00:00:56,460
is obviously when we do have

25
00:00:56,460 --> 00:00:57,840
vulnerabilities

26
00:00:57,840 --> 00:01:00,960
we do want to eliminate bugs obviously

27
00:01:00,960 --> 00:01:02,879
this is also quite difficult we haven't

28
00:01:02,879 --> 00:01:05,760
been able to do this in like forever

29
00:01:05,760 --> 00:01:07,979
the second thing that we can do is that

30
00:01:07,979 --> 00:01:09,659
we can limit the post exploitation

31
00:01:09,659 --> 00:01:12,299
impact of these vulnerabilities once

32
00:01:12,299 --> 00:01:13,619
somebody for instance an attacker has

33
00:01:13,619 --> 00:01:15,720
gained control of the application so

34
00:01:15,720 --> 00:01:17,400
instead of being able to do whatever

35
00:01:17,400 --> 00:01:19,920
they want they are severely limited in

36
00:01:19,920 --> 00:01:21,600
what they can achieve

37
00:01:21,600 --> 00:01:23,460
in this talk I won't talk about

38
00:01:23,460 --> 00:01:25,799
eliminating bugs I've never done any

39
00:01:25,799 --> 00:01:28,200
research in that direction so instead I

40
00:01:28,200 --> 00:01:29,460
will focus on limiting the post

41
00:01:29,460 --> 00:01:31,200
exploitation impact

42
00:01:31,200 --> 00:01:33,119
obviously in the past there have been

43
00:01:33,119 --> 00:01:35,820
several attempts to do this as well for

44
00:01:35,820 --> 00:01:38,520
instance sandboxing one very prominent

45
00:01:38,520 --> 00:01:41,280
example that has been proposed like 17

46
00:01:41,280 --> 00:01:44,100
years ago or so now is control flow

47
00:01:44,100 --> 00:01:45,119
integrity

48
00:01:45,119 --> 00:01:47,400
control for integrity has very simple

49
00:01:47,400 --> 00:01:49,020
idea

50
00:01:49,020 --> 00:01:51,360
during static analysis when we compile

51
00:01:51,360 --> 00:01:54,360
the application or using a binary binary

52
00:01:54,360 --> 00:01:57,119
analysis we extract the control flow of

53
00:01:57,119 --> 00:01:58,860
an application so for instance here we

54
00:01:58,860 --> 00:02:00,360
have a simple abstraction of this where

55
00:02:00,360 --> 00:02:02,700
we have several nodes and we extract

56
00:02:02,700 --> 00:02:05,399
information at Node 1 can follow to can

57
00:02:05,399 --> 00:02:07,680
transfer control to node 2 which can

58
00:02:07,680 --> 00:02:10,560
control transfer control to node four

59
00:02:10,560 --> 00:02:13,080
Node 1 can also transfer control to node

60
00:02:13,080 --> 00:02:14,700
3 and so on

61
00:02:14,700 --> 00:02:17,819
so using static analysis we extract this

62
00:02:17,819 --> 00:02:20,160
information build a control flow graph

63
00:02:20,160 --> 00:02:23,520
and then instrument our binary with

64
00:02:23,520 --> 00:02:26,340
some checks so before we transition in

65
00:02:26,340 --> 00:02:28,140
Control Function check Integrity to a

66
00:02:28,140 --> 00:02:30,060
new Target the thing that we do is we

67
00:02:30,060 --> 00:02:33,599
simply check is this a valid transfer or

68
00:02:33,599 --> 00:02:34,620
not

69
00:02:34,620 --> 00:02:36,840
so for instance for node 3 we know that

70
00:02:36,840 --> 00:02:39,180
we can only transfer control to nodes 5

71
00:02:39,180 --> 00:02:41,879
and 6. these can be functions this can

72
00:02:41,879 --> 00:02:45,120
be basic blocks pretty much everything

73
00:02:45,120 --> 00:02:48,360
so if an attacker now tries to hijack

74
00:02:48,360 --> 00:02:50,519
the control of our application

75
00:02:50,519 --> 00:02:52,319
we have this malicious flow to a

76
00:02:52,319 --> 00:02:54,959
different node then CFI will prevent

77
00:02:54,959 --> 00:02:56,099
this

78
00:02:56,099 --> 00:02:59,280
however CFI does have a few limitations

79
00:02:59,280 --> 00:03:02,099
it's typically only applies within a

80
00:03:02,099 --> 00:03:04,680
single domain for instance you can apply

81
00:03:04,680 --> 00:03:06,959
CFI to user space you can apply it to

82
00:03:06,959 --> 00:03:09,420
Kernel space but it's very hard to do

83
00:03:09,420 --> 00:03:13,019
this in a cross-security domain context

84
00:03:13,019 --> 00:03:14,819
but obviously this is something that we

85
00:03:14,819 --> 00:03:16,920
want to do because a lot of pretty much

86
00:03:16,920 --> 00:03:18,599
all of our exploits requires

87
00:03:18,599 --> 00:03:20,159
interactions with the operating system

88
00:03:20,159 --> 00:03:22,319
as it is the privileged entity on our

89
00:03:22,319 --> 00:03:25,019
systems so we need a way

90
00:03:25,019 --> 00:03:27,239
to limit the interaction with the

91
00:03:27,239 --> 00:03:28,620
operating system

92
00:03:28,620 --> 00:03:31,019
and there's one thing that Linux already

93
00:03:31,019 --> 00:03:32,879
provides us and this is Linux second

94
00:03:32,879 --> 00:03:35,400
company secure Computing interface

95
00:03:35,400 --> 00:03:37,739
the idea behind second was quite easy we

96
00:03:37,739 --> 00:03:39,180
checked for every single system call

97
00:03:39,180 --> 00:03:41,760
whether it is part of a filter

98
00:03:41,760 --> 00:03:44,040
or not if it is not we simply terminate

99
00:03:44,040 --> 00:03:46,319
our application the typical flow here is

100
00:03:46,319 --> 00:03:48,239
this we have our application the

101
00:03:48,239 --> 00:03:49,920
application itself you use the developer

102
00:03:49,920 --> 00:03:52,200
you are responsible in identifying what

103
00:03:52,200 --> 00:03:53,640
are the system costs that your

104
00:03:53,640 --> 00:03:56,819
application requires and you send them

105
00:03:56,819 --> 00:03:59,879
to the kernel to install these filters

106
00:03:59,879 --> 00:04:01,920
for every single system call then the

107
00:04:01,920 --> 00:04:03,720
internal intercepts the system call

108
00:04:03,720 --> 00:04:07,080
checks with the with the filters and if

109
00:04:07,080 --> 00:04:09,599
it does not is not part of the filter we

110
00:04:09,599 --> 00:04:11,760
simply terminate it otherwise we execute

111
00:04:11,760 --> 00:04:14,640
the system call and return the result

112
00:04:14,640 --> 00:04:16,019
so this is obviously something quite

113
00:04:16,019 --> 00:04:17,940
nice that we can use to limit the post

114
00:04:17,940 --> 00:04:22,260
exploitation impact of an attack however

115
00:04:22,260 --> 00:04:25,080
sex Compares two limitations in this

116
00:04:25,080 --> 00:04:27,060
case the first one is that we only look

117
00:04:27,060 --> 00:04:29,340
at the current system call we don't have

118
00:04:29,340 --> 00:04:31,680
any context information the second one

119
00:04:31,680 --> 00:04:34,199
is that is quite difficult to apply here

120
00:04:34,199 --> 00:04:36,300
we have a very simple example of a

121
00:04:36,300 --> 00:04:38,220
program it does nothing else than copy

122
00:04:38,220 --> 00:04:40,560
one file the content of one file to

123
00:04:40,560 --> 00:04:41,880
another file

124
00:04:41,880 --> 00:04:43,800
but you as a developer you are

125
00:04:43,800 --> 00:04:45,780
responsible in identifying every single

126
00:04:45,780 --> 00:04:48,419
system call that your application uses

127
00:04:48,419 --> 00:04:50,880
well this is quite simply something like

128
00:04:50,880 --> 00:04:53,160
this it's not a large program

129
00:04:53,160 --> 00:04:54,780
it's quite complicated if you think

130
00:04:54,780 --> 00:04:56,940
about large complex applications like

131
00:04:56,940 --> 00:04:59,280
servers and so on

132
00:04:59,280 --> 00:05:01,199
so just to give you an idea how many

133
00:05:01,199 --> 00:05:03,120
system calls that this application might

134
00:05:03,120 --> 00:05:06,120
require this is the list and as we can

135
00:05:06,120 --> 00:05:08,880
see it's already quite a lot and most

136
00:05:08,880 --> 00:05:11,100
people I would assume would not be able

137
00:05:11,100 --> 00:05:13,080
to identify this system course

138
00:05:13,080 --> 00:05:17,280
so a couple years ago we worked on

139
00:05:17,280 --> 00:05:18,960
automating this and we gave a

140
00:05:18,960 --> 00:05:21,180
presentation on this back at blackhead

141
00:05:21,180 --> 00:05:24,180
in 2020 in blackhead Asia together with

142
00:05:24,180 --> 00:05:25,560
my colleagues so we simply automated

143
00:05:25,560 --> 00:05:28,500
this Con this discovery of the system

144
00:05:28,500 --> 00:05:31,320
cost that your application requires

145
00:05:31,320 --> 00:05:33,600
but when we worked on this we also had

146
00:05:33,600 --> 00:05:36,419
another idea what if we extend SEC comp

147
00:05:36,419 --> 00:05:39,419
with not only enforcing a current system

148
00:05:39,419 --> 00:05:42,360
call but this current system call in the

149
00:05:42,360 --> 00:05:44,340
in the context of the previous one so

150
00:05:44,340 --> 00:05:47,100
we'll try to enforce ciscal sequences

151
00:05:47,100 --> 00:05:48,900
and this brings me to what I'm going to

152
00:05:48,900 --> 00:05:51,300
present today and this is our concept of

153
00:05:51,300 --> 00:05:53,699
Cisco flow Integrity protection it takes

154
00:05:53,699 --> 00:05:57,360
ideas from CFI and SEC comp to to

155
00:05:57,360 --> 00:05:59,580
enforce the program behavior of an

156
00:05:59,580 --> 00:06:02,520
application that is protected for it

157
00:06:02,520 --> 00:06:04,860
as flip as we call it is built upon

158
00:06:04,860 --> 00:06:07,199
three pillars our first pillar is a

159
00:06:07,199 --> 00:06:09,060
simple State machine during static

160
00:06:09,060 --> 00:06:11,880
analysis we extract every single Cisco

161
00:06:11,880 --> 00:06:14,940
sequence of length 2 obviously there are

162
00:06:14,940 --> 00:06:17,639
other lengths are possible as well but

163
00:06:17,639 --> 00:06:20,160
we focused on only length two so we

164
00:06:20,160 --> 00:06:23,520
extract these sequences and then try to

165
00:06:23,520 --> 00:06:25,740
enforce them so I'll assist our

166
00:06:25,740 --> 00:06:28,680
application is only able to call system

167
00:06:28,680 --> 00:06:31,319
ciscos in the sequence as we determined

168
00:06:31,319 --> 00:06:33,000
statically just like we had it in the

169
00:06:33,000 --> 00:06:35,880
CFI but on a different level

170
00:06:35,880 --> 00:06:38,639
however we try to extend this further to

171
00:06:38,639 --> 00:06:40,919
provide even stricter protection and

172
00:06:40,919 --> 00:06:43,440
this is for ciscal Origins during the

173
00:06:43,440 --> 00:06:45,240
same process when we attract extract

174
00:06:45,240 --> 00:06:47,819
this information we also extract the

175
00:06:47,819 --> 00:06:49,500
origin of each single system called

176
00:06:49,500 --> 00:06:52,199
generating a mapping from the CIS called

177
00:06:52,199 --> 00:06:54,180
origin to the system called that it can

178
00:06:54,180 --> 00:06:57,300
execute obviously this can be a mapping

179
00:06:57,300 --> 00:06:59,160
one to one a single sysical instruction

180
00:06:59,160 --> 00:07:02,100
can only execute a single system call or

181
00:07:02,100 --> 00:07:04,080
a single system called instruction can

182
00:07:04,080 --> 00:07:05,759
potentially execute multiple system

183
00:07:05,759 --> 00:07:06,960
calls

184
00:07:06,960 --> 00:07:09,419
both of these things we do extract

185
00:07:09,419 --> 00:07:11,819
during static analysis in the

186
00:07:11,819 --> 00:07:13,860
compilation of the application

187
00:07:13,860 --> 00:07:16,680
however S5 would not be anything without

188
00:07:16,680 --> 00:07:19,380
our third pillar that actually enforces

189
00:07:19,380 --> 00:07:21,900
the information so we modified the Linux

190
00:07:21,900 --> 00:07:23,699
kernel that it can receive the

191
00:07:23,699 --> 00:07:26,280
information that we provided and then

192
00:07:26,280 --> 00:07:28,020
enforce it into set the system color

193
00:07:28,020 --> 00:07:30,360
check is this a valid transition is it a

194
00:07:30,360 --> 00:07:32,460
valid origin and

195
00:07:32,460 --> 00:07:36,500
if it is we continue our execution

196
00:07:36,539 --> 00:07:39,720
so this is the free pillows pillows that

197
00:07:39,720 --> 00:07:42,000
our S5 builds upon

198
00:07:42,000 --> 00:07:44,699
in this talk I will mostly focus on the

199
00:07:44,699 --> 00:07:46,500
first two pillars and less on the third

200
00:07:46,500 --> 00:07:49,080
pillar simply because it's more on the

201
00:07:49,080 --> 00:07:51,240
trivial side this part

202
00:07:51,240 --> 00:07:55,500
so we implemented s-f in a proof of

203
00:07:55,500 --> 00:07:57,660
concept implementation we call this sys

204
00:07:57,660 --> 00:08:00,660
flow sys flow consists of three parts

205
00:08:00,660 --> 00:08:03,840
it's a compiler so we modified the llvm

206
00:08:03,840 --> 00:08:06,599
compiler tool train during that performs

207
00:08:06,599 --> 00:08:08,160
the extraction of both the Cisco

208
00:08:08,160 --> 00:08:11,220
sequences and the the origins

209
00:08:11,220 --> 00:08:13,860
then a simple support Library it does

210
00:08:13,860 --> 00:08:15,120
nothing else than extract the

211
00:08:15,120 --> 00:08:15,860
information

212
00:08:15,860 --> 00:08:18,180
do some adjustments for the Cisco

213
00:08:18,180 --> 00:08:21,300
offsets and send it to the kernel and

214
00:08:21,300 --> 00:08:23,460
finally the third part is our modified

215
00:08:23,460 --> 00:08:25,680
Linux kernel which takes care of the

216
00:08:25,680 --> 00:08:26,759
enforcement

217
00:08:26,759 --> 00:08:28,620
the enforcement can be done in various

218
00:08:28,620 --> 00:08:31,020
ways we choose to modify the Linux

219
00:08:31,020 --> 00:08:34,200
kernel entirely so but you could also

220
00:08:34,200 --> 00:08:35,880
use something like evpf or something

221
00:08:35,880 --> 00:08:37,860
like that

222
00:08:37,860 --> 00:08:40,440
so let's focus a bit on the extraction

223
00:08:40,440 --> 00:08:42,120
part what is the type of extract

224
00:08:42,120 --> 00:08:44,580
information that we extract we have here

225
00:08:44,580 --> 00:08:47,279
a very simple example of just a little

226
00:08:47,279 --> 00:08:49,200
bit of code as we can see we have a

227
00:08:49,200 --> 00:08:51,120
function four it takes a parameter it

228
00:08:51,120 --> 00:08:53,700
calls some functions it has some

229
00:08:53,700 --> 00:08:55,740
um yeah some branches in there as well

230
00:08:55,740 --> 00:08:57,839
and a system call

231
00:08:57,839 --> 00:09:00,360
first it is important that we extract

232
00:09:00,360 --> 00:09:02,760
several key parts of information

233
00:09:02,760 --> 00:09:04,620
so the thing that we extract is the

234
00:09:04,620 --> 00:09:07,200
transitions so we generate an inter an

235
00:09:07,200 --> 00:09:09,360
inter procedural control flow graph so

236
00:09:09,360 --> 00:09:11,339
that we know from where can we go to

237
00:09:11,339 --> 00:09:14,220
where so that we can actually extract

238
00:09:14,220 --> 00:09:16,500
the sequences correctly so we know for

239
00:09:16,500 --> 00:09:18,000
instance that from line three we can

240
00:09:18,000 --> 00:09:20,160
transition to line four or line six and

241
00:09:20,160 --> 00:09:21,360
so on

242
00:09:21,360 --> 00:09:24,000
we also have to call targets so this is

243
00:09:24,000 --> 00:09:26,160
these represent our inter procedural

244
00:09:26,160 --> 00:09:28,500
control flow graph where we know that at

245
00:09:28,500 --> 00:09:30,060
line two we're going to call the

246
00:09:30,060 --> 00:09:32,220
function scan F or on line four we're

247
00:09:32,220 --> 00:09:34,920
going to call printf and finally we also

248
00:09:34,920 --> 00:09:36,660
extract information of the system calls

249
00:09:36,660 --> 00:09:39,899
so we know at line 06 we are going to

250
00:09:39,899 --> 00:09:42,480
call the read system call we extract all

251
00:09:42,480 --> 00:09:44,160
of this information for every single

252
00:09:44,160 --> 00:09:46,680
file that we encounter both if it's a C

253
00:09:46,680 --> 00:09:48,600
file if it's an assembly file we can

254
00:09:48,600 --> 00:09:51,060
extract all this information generate

255
00:09:51,060 --> 00:09:53,640
the object file response

256
00:09:53,640 --> 00:09:55,800
yeah the corresponding object file and

257
00:09:55,800 --> 00:09:58,260
encode all of this information in the

258
00:09:58,260 --> 00:10:00,240
object file

259
00:10:00,240 --> 00:10:02,640
so because only later on we can build

260
00:10:02,640 --> 00:10:04,860
our whole control flow graph and this is

261
00:10:04,860 --> 00:10:06,600
called sequences

262
00:10:06,600 --> 00:10:09,420
the second part is more complicated and

263
00:10:09,420 --> 00:10:11,880
it it builds upon the first part as well

264
00:10:11,880 --> 00:10:13,260
and this is the CIS called offset

265
00:10:13,260 --> 00:10:15,839
extraction first why do we extract this

266
00:10:15,839 --> 00:10:18,300
is called offset as an offset to the

267
00:10:18,300 --> 00:10:20,220
start of the function instead of an

268
00:10:20,220 --> 00:10:22,620
absolute address we simply do this so

269
00:10:22,620 --> 00:10:24,600
that we can still use features like

270
00:10:24,600 --> 00:10:26,339
address based layout randomization

271
00:10:26,339 --> 00:10:28,140
because we simply don't know the final

272
00:10:28,140 --> 00:10:31,320
address once it's being loaded

273
00:10:31,320 --> 00:10:33,300
so what we have here is a simple

274
00:10:33,300 --> 00:10:35,820
translation unit we have a function we

275
00:10:35,820 --> 00:10:37,680
already seen this function before and we

276
00:10:37,680 --> 00:10:39,600
know that it's going to execute a system

277
00:10:39,600 --> 00:10:40,500
call

278
00:10:40,500 --> 00:10:43,440
so we used now the information that in

279
00:10:43,440 --> 00:10:46,019
the back end of the compiler we see a

280
00:10:46,019 --> 00:10:47,880
system called instructure we use the

281
00:10:47,880 --> 00:10:49,140
information that we have extracted

282
00:10:49,140 --> 00:10:51,360
previously and annotate this with a

283
00:10:51,360 --> 00:10:53,459
label so we're going to say this is in

284
00:10:53,459 --> 00:10:56,339
function func and the system call number

285
00:10:56,339 --> 00:10:59,820
39. because at this point we don't know

286
00:10:59,820 --> 00:11:01,560
the offset of the interact instruction

287
00:11:01,560 --> 00:11:03,300
there are several key steps of

288
00:11:03,300 --> 00:11:04,740
optimization that are going to happen

289
00:11:04,740 --> 00:11:06,060
afterwards

290
00:11:06,060 --> 00:11:08,459
only at the very end when we generate

291
00:11:08,459 --> 00:11:11,339
the symbol table for our object file can

292
00:11:11,339 --> 00:11:14,760
we actually determine the offset so once

293
00:11:14,760 --> 00:11:17,700
we have this symbol table we simply take

294
00:11:17,700 --> 00:11:19,620
the the address that's generated for the

295
00:11:19,620 --> 00:11:22,140
function and the address generated for

296
00:11:22,140 --> 00:11:25,200
all now newly generated label calculate

297
00:11:25,200 --> 00:11:27,720
the difference annotate it with add the

298
00:11:27,720 --> 00:11:29,100
information of the system call number

299
00:11:29,100 --> 00:11:31,260
and we have the information so we know

300
00:11:31,260 --> 00:11:33,320
our function func is going to call 13

301
00:11:33,320 --> 00:11:35,760
the system called 39 I think it's the

302
00:11:35,760 --> 00:11:37,740
get ppid system call

303
00:11:37,740 --> 00:11:39,959
at line O2

304
00:11:39,959 --> 00:11:42,180
however what we also see here is this

305
00:11:42,180 --> 00:11:46,200
unknown offsets The Cisco cb3 why do we

306
00:11:46,200 --> 00:11:48,779
have this Cisco CP is a function that's

307
00:11:48,779 --> 00:11:50,279
performing a system call with a

308
00:11:50,279 --> 00:11:51,300
checkpoint

309
00:11:51,300 --> 00:11:55,320
so we don't know what the offset is

310
00:11:55,320 --> 00:11:56,339
there because it's in a different

311
00:11:56,339 --> 00:11:57,959
translation unit we don't have this

312
00:11:57,959 --> 00:12:00,120
information readily available but what

313
00:12:00,120 --> 00:12:02,160
we do have is the assistant information

314
00:12:02,160 --> 00:12:04,620
what the actual system call is

315
00:12:04,620 --> 00:12:06,959
but at one point we have either seen or

316
00:12:06,959 --> 00:12:09,899
will see this function Cisco CP then we

317
00:12:09,899 --> 00:12:11,820
have the opposite problem now we know

318
00:12:11,820 --> 00:12:14,279
what this the offset is but we don't

319
00:12:14,279 --> 00:12:16,140
know what the system call is so we

320
00:12:16,140 --> 00:12:18,000
annotate this information we say we are

321
00:12:18,000 --> 00:12:20,279
in functions it's called CP and as the

322
00:12:20,279 --> 00:12:22,620
number we encode minus one

323
00:12:22,620 --> 00:12:25,620
and now we have the unknown ciscals as

324
00:12:25,620 --> 00:12:27,360
well so we know what is the offset there

325
00:12:27,360 --> 00:12:28,800
in this function

326
00:12:28,800 --> 00:12:30,660
in the Linker we combine this

327
00:12:30,660 --> 00:12:32,519
information to get our final information

328
00:12:32,519 --> 00:12:35,040
where we now also know Cisco CP is going

329
00:12:35,040 --> 00:12:36,660
to perform the function at the system

330
00:12:36,660 --> 00:12:39,779
called free uh I think it's closed at

331
00:12:39,779 --> 00:12:42,560
this offset

332
00:12:42,720 --> 00:12:45,300
so let's talk about the state machine

333
00:12:45,300 --> 00:12:47,519
generation and also in this same process

334
00:12:47,519 --> 00:12:49,380
we generate the final information for

335
00:12:49,380 --> 00:12:52,260
our Cisco offsets we have all these

336
00:12:52,260 --> 00:12:54,839
object files that are now annotated that

337
00:12:54,839 --> 00:12:57,500
contain this new section with our

338
00:12:57,500 --> 00:13:00,720
information that we extracted we take

339
00:13:00,720 --> 00:13:02,579
all of these object files and throw them

340
00:13:02,579 --> 00:13:05,339
into the Linker the Linker extracts all

341
00:13:05,339 --> 00:13:07,620
of this and generates this huge block of

342
00:13:07,620 --> 00:13:09,300
information this whole control flow

343
00:13:09,300 --> 00:13:11,160
graph the whole information on system

344
00:13:11,160 --> 00:13:14,040
classes called offsets and so on

345
00:13:14,040 --> 00:13:15,899
but obviously we need to build the final

346
00:13:15,899 --> 00:13:18,000
Cisco sequence we cannot simply use this

347
00:13:18,000 --> 00:13:19,980
information because the we would

348
00:13:19,980 --> 00:13:21,839
severely over approximate and we still

349
00:13:21,839 --> 00:13:24,300
don't know any inter-procedural ciscal

350
00:13:24,300 --> 00:13:25,500
sequences

351
00:13:25,500 --> 00:13:27,360
so I will briefly illustrate the

352
00:13:27,360 --> 00:13:29,639
generation of the state machine using

353
00:13:29,639 --> 00:13:31,440
this example so in the top left you can

354
00:13:31,440 --> 00:13:33,300
see the current function that we are at

355
00:13:33,300 --> 00:13:35,459
and on the dot right you see the

356
00:13:35,459 --> 00:13:36,959
information that we have available for

357
00:13:36,959 --> 00:13:38,579
this in the bottom you see the last

358
00:13:38,579 --> 00:13:40,500
system calls that we encountered and the

359
00:13:40,500 --> 00:13:42,360
state machine

360
00:13:42,360 --> 00:13:44,820
so our information here tells us that

361
00:13:44,820 --> 00:13:47,459
we're encountering a transition to the

362
00:13:47,459 --> 00:13:50,180
functions full one and full two and

363
00:13:50,180 --> 00:13:52,800
simply based on the order of the line

364
00:13:52,800 --> 00:13:54,720
numbers we know that we first transition

365
00:13:54,720 --> 00:13:56,760
to full one so let's do this we

366
00:13:56,760 --> 00:13:58,920
recursively visit our function through

367
00:13:58,920 --> 00:14:01,019
one we pass all the information to it

368
00:14:01,019 --> 00:14:03,480
and we see that the first thing in this

369
00:14:03,480 --> 00:14:06,060
function is a system called open

370
00:14:06,060 --> 00:14:08,639
so we're going to consume this open add

371
00:14:08,639 --> 00:14:10,500
it to the last system calls but we don't

372
00:14:10,500 --> 00:14:12,300
have a previous system call so this is

373
00:14:12,300 --> 00:14:15,000
more or less our initial state

374
00:14:15,000 --> 00:14:16,860
what we tend to have is the transition

375
00:14:16,860 --> 00:14:19,920
to the function bar one in bar one we

376
00:14:19,920 --> 00:14:22,740
again have a system called read

377
00:14:22,740 --> 00:14:25,019
now we do have a previous system call so

378
00:14:25,019 --> 00:14:26,880
what we can do is we add in the state

379
00:14:26,880 --> 00:14:28,800
machine a transition from open to read

380
00:14:28,800 --> 00:14:31,320
so we have a valid transition there

381
00:14:31,320 --> 00:14:34,019
we then consumed it it's added to the

382
00:14:34,019 --> 00:14:35,760
last system cost replace the previous

383
00:14:35,760 --> 00:14:39,180
value but and can continue but we don't

384
00:14:39,180 --> 00:14:40,800
have any further information for our

385
00:14:40,800 --> 00:14:43,620
function bar one so we simply return no

386
00:14:43,620 --> 00:14:45,420
further information here as well so we

387
00:14:45,420 --> 00:14:47,519
will return again until we are at Main

388
00:14:47,519 --> 00:14:49,920
in the main function where we have now

389
00:14:49,920 --> 00:14:52,260
our transition to Food 2 and we simply

390
00:14:52,260 --> 00:14:54,660
repeat that we go to full two we have

391
00:14:54,660 --> 00:14:56,760
our system call First with the open

392
00:14:56,760 --> 00:14:58,980
system call our last system call is read

393
00:14:58,980 --> 00:15:01,139
so we are going to add a transition from

394
00:15:01,139 --> 00:15:03,480
read to open replace the last system

395
00:15:03,480 --> 00:15:05,220
call that we encountered transition to

396
00:15:05,220 --> 00:15:08,040
Bar two and add now a transition from

397
00:15:08,040 --> 00:15:10,500
the open system call to the Stat system

398
00:15:10,500 --> 00:15:12,779
column so we now know that there are two

399
00:15:12,779 --> 00:15:15,000
valid transitions from the opener system

400
00:15:15,000 --> 00:15:16,380
call

401
00:15:16,380 --> 00:15:18,060
one thing that we also during this

402
00:15:18,060 --> 00:15:20,100
process is that we every single time we

403
00:15:20,100 --> 00:15:22,260
encounter and function we add all the

404
00:15:22,260 --> 00:15:24,000
system called offsets that we have for

405
00:15:24,000 --> 00:15:26,339
this function so simply at the end of

406
00:15:26,339 --> 00:15:28,440
this once we have returned here to our

407
00:15:28,440 --> 00:15:29,699
main function there's no more

408
00:15:29,699 --> 00:15:32,339
information left we have generated this

409
00:15:32,339 --> 00:15:35,880
whole map of uh CIS called Origins as

410
00:15:35,880 --> 00:15:39,480
well as our CIS called sequences

411
00:15:39,480 --> 00:15:42,120
then we encode this information again in

412
00:15:42,120 --> 00:15:44,459
our final binary link our support

413
00:15:44,459 --> 00:15:46,920
library to it which is responsible for

414
00:15:46,920 --> 00:15:48,660
extracting the information

415
00:15:48,660 --> 00:15:50,579
now that we have launched the

416
00:15:50,579 --> 00:15:52,980
application we also know all the the

417
00:15:52,980 --> 00:15:55,440
functional addresses we use this

418
00:15:55,440 --> 00:15:57,920
information make the offset adjustment

419
00:15:57,920 --> 00:16:00,959
and finally send it to our kernel for

420
00:16:00,959 --> 00:16:02,760
the enforcement

421
00:16:02,760 --> 00:16:05,459
the kernel is very simple it intercepts

422
00:16:05,459 --> 00:16:07,620
a system call it keeps track of what was

423
00:16:07,620 --> 00:16:08,940
the previous system call that I

424
00:16:08,940 --> 00:16:11,639
encountered and once we perform a new

425
00:16:11,639 --> 00:16:13,019
system call it looks up in the

426
00:16:13,019 --> 00:16:15,120
information is the current system called

427
00:16:15,120 --> 00:16:16,860
a valid Target for the previous system

428
00:16:16,860 --> 00:16:18,300
code so it performs this transition

429
00:16:18,300 --> 00:16:20,760
check once it passes this it performs

430
00:16:20,760 --> 00:16:22,560
this independent origin check to see

431
00:16:22,560 --> 00:16:24,480
whether the system call also originates

432
00:16:24,480 --> 00:16:27,480
from a location where it is valid

433
00:16:27,480 --> 00:16:29,519
so this is basically the idea of our

434
00:16:29,519 --> 00:16:32,160
concept of of svip but the thing that

435
00:16:32,160 --> 00:16:34,560
always is of Interest obviously is the

436
00:16:34,560 --> 00:16:36,000
evaluation what is the performance

437
00:16:36,000 --> 00:16:39,360
impact of our two of our concept and as

438
00:16:39,360 --> 00:16:41,699
well the security that we provide

439
00:16:41,699 --> 00:16:44,639
let's start with the performance

440
00:16:44,639 --> 00:16:47,399
so the first thing we did is We

441
00:16:47,399 --> 00:16:50,220
performed this micro Benchmark we simply

442
00:16:50,220 --> 00:16:52,199
followed what the Linux kernel

443
00:16:52,199 --> 00:16:54,540
developers do as well we executed the

444
00:16:54,540 --> 00:16:57,000
get ppid system called one million times

445
00:16:57,000 --> 00:17:00,360
we did this for different setups so in

446
00:17:00,360 --> 00:17:02,459
the First Column we see that we simply

447
00:17:02,459 --> 00:17:05,099
used no protection at all in a second we

448
00:17:05,099 --> 00:17:07,079
compared our implementation to sec.com

449
00:17:07,079 --> 00:17:09,359
and then we benchmarked all the

450
00:17:09,359 --> 00:17:11,939
different uh configurations of our svip

451
00:17:11,939 --> 00:17:14,099
so only state checks only origin checks

452
00:17:14,099 --> 00:17:16,260
and only the and then both of them

453
00:17:16,260 --> 00:17:17,939
combined

454
00:17:17,939 --> 00:17:19,980
obviously we are slower than no

455
00:17:19,980 --> 00:17:22,260
protection at all here we have like an

456
00:17:22,260 --> 00:17:26,099
average number of 302 compared to 341 in

457
00:17:26,099 --> 00:17:28,799
the case of our combined protection

458
00:17:28,799 --> 00:17:30,419
this is to be expected simply because

459
00:17:30,419 --> 00:17:32,940
we'd have to take a different uh we have

460
00:17:32,940 --> 00:17:34,620
to perform our checks but also we have

461
00:17:34,620 --> 00:17:36,539
to take a different path into the kernel

462
00:17:36,539 --> 00:17:38,460
there's the the kernel calls it the the

463
00:17:38,460 --> 00:17:40,620
slow path compared to the fast fiscal

464
00:17:40,620 --> 00:17:42,419
enterpath and this is something that we

465
00:17:42,419 --> 00:17:44,100
have in common with sec.com because we

466
00:17:44,100 --> 00:17:46,260
need to intercept the system column

467
00:17:46,260 --> 00:17:48,240
but one thing that we can see is that we

468
00:17:48,240 --> 00:17:50,580
outperform SEC comp in terms of this

469
00:17:50,580 --> 00:17:52,440
micro Benchmark that we performed it's

470
00:17:52,440 --> 00:17:55,200
only seven Cycles but still quite a bit

471
00:17:55,200 --> 00:17:57,960
there's a simple reason why this is the

472
00:17:57,960 --> 00:18:00,539
case section of internally uses the cppf

473
00:18:00,539 --> 00:18:03,780
program language simple to express their

474
00:18:03,780 --> 00:18:05,640
filters it's quite complex they need to

475
00:18:05,640 --> 00:18:08,460
be interpreted and this takes quite a

476
00:18:08,460 --> 00:18:10,440
bit of an overhead

477
00:18:10,440 --> 00:18:13,919
but Micro benchmarks are they are nice

478
00:18:13,919 --> 00:18:16,440
they tell you like a raw estimate of the

479
00:18:16,440 --> 00:18:17,640
overhead

480
00:18:17,640 --> 00:18:19,740
but usually your system your application

481
00:18:19,740 --> 00:18:21,840
isn't going to perform 1 million uh

482
00:18:21,840 --> 00:18:23,580
system calls of the get ppid system

483
00:18:23,580 --> 00:18:24,780
called

484
00:18:24,780 --> 00:18:26,280
um it's simply not going to happen

485
00:18:26,280 --> 00:18:27,660
within a second

486
00:18:27,660 --> 00:18:29,340
so one thing that we did is We performed

487
00:18:29,340 --> 00:18:31,440
this macro this macro Benchmark we

488
00:18:31,440 --> 00:18:33,059
looked at several large-scale

489
00:18:33,059 --> 00:18:36,179
applications uh and compiled it them

490
00:18:36,179 --> 00:18:38,039
with our tool chain

491
00:18:38,039 --> 00:18:41,220
we want we rent them as well so also

492
00:18:41,220 --> 00:18:42,840
obviously yes we can report some

493
00:18:42,840 --> 00:18:44,340
performance numbers we can also say that

494
00:18:44,340 --> 00:18:46,260
our system actually works so this is

495
00:18:46,260 --> 00:18:47,940
also like a functional Corrections test

496
00:18:47,940 --> 00:18:50,280
in itself as well because we were able

497
00:18:50,280 --> 00:18:52,620
for instance for our memcache we ran the

498
00:18:52,620 --> 00:18:55,020
whole test Suite without any errors uh

499
00:18:55,020 --> 00:18:58,020
for nginx we were able to load a website

500
00:18:58,020 --> 00:19:00,179
connect to it make a hundred thousand or

501
00:19:00,179 --> 00:19:02,460
a million requests without it crashing

502
00:19:02,460 --> 00:19:05,160
and for ffmpeg we simply converted one

503
00:19:05,160 --> 00:19:07,380
file to another file format

504
00:19:07,380 --> 00:19:09,660
one thing that we can see here is that

505
00:19:09,660 --> 00:19:11,940
we have a very low overhead the

506
00:19:11,940 --> 00:19:13,260
interesting case here is obviously the

507
00:19:13,260 --> 00:19:15,000
combined case because it provides the

508
00:19:15,000 --> 00:19:17,760
the most protection in all cases we have

509
00:19:17,760 --> 00:19:19,860
less than two percent overhead even

510
00:19:19,860 --> 00:19:21,840
though we perform more checks than

511
00:19:21,840 --> 00:19:24,600
second we provide more security

512
00:19:24,600 --> 00:19:27,179
so even though we do all this we have

513
00:19:27,179 --> 00:19:29,580
quite a nice performance impact that I

514
00:19:29,580 --> 00:19:31,620
would say is acceptable for most

515
00:19:31,620 --> 00:19:33,240
applications

516
00:19:33,240 --> 00:19:35,700
one thing that I want to point to that I

517
00:19:35,700 --> 00:19:38,700
still don't know the answer to it is why

518
00:19:38,700 --> 00:19:41,100
in ffmpec we have this weird case where

519
00:19:41,100 --> 00:19:43,320
the just checking the state or just

520
00:19:43,320 --> 00:19:45,539
checking the Cisco location

521
00:19:45,539 --> 00:19:48,000
performs worse than when we combine

522
00:19:48,000 --> 00:19:50,460
those our repetitive experiment I think

523
00:19:50,460 --> 00:19:52,440
like 20 times and this Behavior was

524
00:19:52,440 --> 00:19:54,299
always prevalent and it's still

525
00:19:54,299 --> 00:19:56,039
something that I'm looking into it I'm

526
00:19:56,039 --> 00:19:57,840
to be honest I'm not entirely sure

527
00:19:57,840 --> 00:19:59,340
what's the case there

528
00:19:59,340 --> 00:20:01,620
I expected some weird caching Behavior

529
00:20:01,620 --> 00:20:03,860
there

530
00:20:03,960 --> 00:20:06,299
but obviously the thing that we also

531
00:20:06,299 --> 00:20:07,799
want to know about is what is the

532
00:20:07,799 --> 00:20:10,200
security benefit of using as fit for

533
00:20:10,200 --> 00:20:11,880
your application

534
00:20:11,880 --> 00:20:14,760
one thing that we can reason with on

535
00:20:14,760 --> 00:20:16,260
that allows us to reason about the

536
00:20:16,260 --> 00:20:18,600
provided security of our system is when

537
00:20:18,600 --> 00:20:20,700
we look at the state machine here we

538
00:20:20,700 --> 00:20:22,260
have several applications that we used

539
00:20:22,260 --> 00:20:24,600
in our in our evaluation or research

540
00:20:24,600 --> 00:20:26,880
paper that we used so we simply

541
00:20:26,880 --> 00:20:29,340
extracted the from the state machine for

542
00:20:29,340 --> 00:20:31,200
all of these applications and looked at

543
00:20:31,200 --> 00:20:33,240
some of the key metrics there are more

544
00:20:33,240 --> 00:20:35,220
metrics in the paper and just present

545
00:20:35,220 --> 00:20:38,460
some of the most important ones here

546
00:20:38,460 --> 00:20:42,240
so let's look at nginx nginx here has

547
00:20:42,240 --> 00:20:45,720
the highest number of states with 107.

548
00:20:45,720 --> 00:20:48,360
obviously this is quite a lot but one

549
00:20:48,360 --> 00:20:49,919
thing that is quite important here is

550
00:20:49,919 --> 00:20:53,400
that 107 States is also the number of of

551
00:20:53,400 --> 00:20:55,679
states or system calls that you would

552
00:20:55,679 --> 00:20:58,740
have in a sec.com filter so it's simply

553
00:20:58,740 --> 00:21:00,539
the equivalent there because it's the

554
00:21:00,539 --> 00:21:02,400
number of Origins for a system call and

555
00:21:02,400 --> 00:21:04,440
if it's an origin obviously at one point

556
00:21:04,440 --> 00:21:07,500
I'm going to require the system color

557
00:21:07,500 --> 00:21:10,200
so the number here also matches our

558
00:21:10,200 --> 00:21:12,419
previous research so when we did the

559
00:21:12,419 --> 00:21:14,640
automated second filter generation we

560
00:21:14,640 --> 00:21:16,260
also arrived at this number and

561
00:21:16,260 --> 00:21:18,720
concurrent work also have this so I'm

562
00:21:18,720 --> 00:21:22,200
pretty confident that this is accurate

563
00:21:22,200 --> 00:21:25,860
one thing with SEC comparison that is

564
00:21:25,860 --> 00:21:28,140
quite important with second we have 107

565
00:21:28,140 --> 00:21:31,620
States and we don't enforce any context

566
00:21:31,620 --> 00:21:33,600
around them so every single one of these

567
00:21:33,600 --> 00:21:36,960
107 states can reach every single one of

568
00:21:36,960 --> 00:21:39,780
the uh of the 107 States so with the

569
00:21:39,780 --> 00:21:42,000
number of average transitions in sec.com

570
00:21:42,000 --> 00:21:43,159
is

571
00:21:43,159 --> 00:21:46,620
107. in our case we have a reduction to

572
00:21:46,620 --> 00:21:49,080
74.05

573
00:21:49,080 --> 00:21:52,020
so on average every single one of these

574
00:21:52,020 --> 00:21:55,380
107 states can reach 74 other system

575
00:21:55,380 --> 00:21:57,600
costs obviously this is quite a high

576
00:21:57,600 --> 00:21:58,380
number

577
00:21:58,380 --> 00:22:02,039
but compared to sec.com there's still an

578
00:22:02,039 --> 00:22:06,360
improvement by yeah 33 system calls and

579
00:22:06,360 --> 00:22:08,520
we see this also for others the question

580
00:22:08,520 --> 00:22:10,559
obviously is why do we have such a high

581
00:22:10,559 --> 00:22:13,140
number of average transitions there are

582
00:22:13,140 --> 00:22:15,900
certain things that we need to to do so

583
00:22:15,900 --> 00:22:17,880
we do over approximate just like you do

584
00:22:17,880 --> 00:22:19,919
in CFI when we build the control flow

585
00:22:19,919 --> 00:22:20,880
graph

586
00:22:20,880 --> 00:22:24,120
resolution of indirect costs is quite

587
00:22:24,120 --> 00:22:27,240
complex it's an undecidable problem so

588
00:22:27,240 --> 00:22:29,400
we need to over approximate their which

589
00:22:29,400 --> 00:22:31,799
results in this high on average this

590
00:22:31,799 --> 00:22:33,480
higher number

591
00:22:33,480 --> 00:22:35,640
now I do want you to keep these two

592
00:22:35,640 --> 00:22:39,000
numbers 74 and 107 in mind when we

593
00:22:39,000 --> 00:22:41,580
transition to our origin analysis then

594
00:22:41,580 --> 00:22:43,500
we did pretty much the same thing we

595
00:22:43,500 --> 00:22:45,539
looked at these applications we looked

596
00:22:45,539 --> 00:22:47,159
at the total number of offsets within

597
00:22:47,159 --> 00:22:48,840
these applications so the total number

598
00:22:48,840 --> 00:22:51,179
of system call instructions and the

599
00:22:51,179 --> 00:22:53,700
number of average offsets that can a

600
00:22:53,700 --> 00:22:56,640
system where a system call can occur

601
00:22:56,640 --> 00:23:00,020
let's look again at nginx here we have

602
00:23:00,020 --> 00:23:03,360
318 system call instructions when we

603
00:23:03,360 --> 00:23:05,580
think about SEC compare again when we

604
00:23:05,580 --> 00:23:08,340
use second comp we have a 107 system

605
00:23:08,340 --> 00:23:09,539
calls

606
00:23:09,539 --> 00:23:11,520
every single one of these system calls

607
00:23:11,520 --> 00:23:14,220
can originate at any one of these 318

608
00:23:14,220 --> 00:23:16,559
locations so this is perfect if you

609
00:23:16,559 --> 00:23:18,299
think about like a Rob chain I can I

610
00:23:18,299 --> 00:23:21,600
still have quite a big attack surface

611
00:23:21,600 --> 00:23:24,480
but one thing that um that we have now

612
00:23:24,480 --> 00:23:27,120
with our uh with our origin enforcement

613
00:23:27,120 --> 00:23:30,539
is we reduce this to free so even though

614
00:23:30,539 --> 00:23:33,120
we have 107 States on average every

615
00:23:33,120 --> 00:23:34,799
single one of these system costs can

616
00:23:34,799 --> 00:23:37,799
only be executed at three locations this

617
00:23:37,799 --> 00:23:39,480
is quite a reduction we have like a

618
00:23:39,480 --> 00:23:43,260
hundred effective 100 less uh Cisco

619
00:23:43,260 --> 00:23:45,539
Origins as would have been possible with

620
00:23:45,539 --> 00:23:47,159
sec.com

621
00:23:47,159 --> 00:23:50,159
and together I think we have this

622
00:23:50,159 --> 00:23:53,100
reduction to 74 possible Transitions and

623
00:23:53,100 --> 00:23:54,900
the reduction to like on average free

624
00:23:54,900 --> 00:23:56,880
system called locations this is quite

625
00:23:56,880 --> 00:23:59,340
nice of a security benefit

626
00:23:59,340 --> 00:24:02,159
but let's have a look at our concept in

627
00:24:02,159 --> 00:24:03,720
the context of return oriented

628
00:24:03,720 --> 00:24:04,799
programming

629
00:24:04,799 --> 00:24:07,260
just to let me give you a quick primer

630
00:24:07,260 --> 00:24:08,760
for those if somebody is not too

631
00:24:08,760 --> 00:24:10,020
familiar with return oriented

632
00:24:10,020 --> 00:24:12,120
programming the idea behind return

633
00:24:12,120 --> 00:24:14,340
behind Rob is simply that we use

634
00:24:14,340 --> 00:24:15,960
existing code in our application to

635
00:24:15,960 --> 00:24:17,820
exploit the program there are certain

636
00:24:17,820 --> 00:24:19,860
reasons why we need to do this I won't

637
00:24:19,860 --> 00:24:22,260
go into too many details here but the

638
00:24:22,260 --> 00:24:24,240
idea then is that we use this existing

639
00:24:24,240 --> 00:24:25,080
code

640
00:24:25,080 --> 00:24:27,480
by simply jumping to parts of functions

641
00:24:27,480 --> 00:24:30,720
which we call gadgets these gadgets are

642
00:24:30,720 --> 00:24:32,820
typically of a very simple form they are

643
00:24:32,820 --> 00:24:34,620
simply in the same assembly instructions

644
00:24:34,620 --> 00:24:36,600
that are followed by return instructions

645
00:24:36,600 --> 00:24:39,120
like we can see here we pop RDI we

646
00:24:39,120 --> 00:24:41,400
return We perform a system called or we

647
00:24:41,400 --> 00:24:43,559
return and that we return

648
00:24:43,559 --> 00:24:46,159
so in on typical export you chain these

649
00:24:46,159 --> 00:24:49,260
gadgets together and the only

650
00:24:49,260 --> 00:24:50,940
requirement here is that we override the

651
00:24:50,940 --> 00:24:52,860
stack with the addresses of the gadgets

652
00:24:52,860 --> 00:24:54,780
as well as any parameters that we

653
00:24:54,780 --> 00:24:56,100
require

654
00:24:56,100 --> 00:24:58,380
a brief illustration so here we have the

655
00:24:58,380 --> 00:25:00,179
stack we have program code and we have

656
00:25:00,179 --> 00:25:02,760
registers we have prepared our Stacks so

657
00:25:02,760 --> 00:25:04,200
we have our return address and the

658
00:25:04,200 --> 00:25:05,760
parameters on there we have the program

659
00:25:05,760 --> 00:25:08,460
code as well so we simply return perform

660
00:25:08,460 --> 00:25:11,280
some asmr's instruction return to next

661
00:25:11,280 --> 00:25:12,419
Gadget

662
00:25:12,419 --> 00:25:15,240
there we now have our Pop instructions

663
00:25:15,240 --> 00:25:17,340
that are part of our Gadget we popped in

664
00:25:17,340 --> 00:25:18,840
two different values that we've prepared

665
00:25:18,840 --> 00:25:21,120
into the register and return to our

666
00:25:21,120 --> 00:25:22,760
Cisco instruction

667
00:25:22,760 --> 00:25:26,039
and now we have a working system a

668
00:25:26,039 --> 00:25:27,600
working blockchain that performs a

669
00:25:27,600 --> 00:25:29,640
system call that we have specified and

670
00:25:29,640 --> 00:25:31,679
with the parameters that we also

671
00:25:31,679 --> 00:25:33,720
provided so obviously this is quite

672
00:25:33,720 --> 00:25:36,000
interesting for an attacker and these

673
00:25:36,000 --> 00:25:37,559
gadgets that we have here they are often

674
00:25:37,559 --> 00:25:40,140
unintended so consider this byte

675
00:25:40,140 --> 00:25:41,700
sequence from an Intel processor you

676
00:25:41,700 --> 00:25:43,580
have o5 5A

677
00:25:43,580 --> 00:25:46,440
5e5fc3 when we disassemble this this is

678
00:25:46,440 --> 00:25:48,299
simple and add instructions so we add a

679
00:25:48,299 --> 00:25:50,159
constant value to whatever is in the

680
00:25:50,159 --> 00:25:51,659
register

681
00:25:51,659 --> 00:25:54,120
however if we skip the first byte then

682
00:25:54,120 --> 00:25:56,460
it disassembles did this very nice uh

683
00:25:56,460 --> 00:25:58,620
Gadget so we pop some values and return

684
00:25:58,620 --> 00:26:01,500
and an attacker can do this obviously as

685
00:26:01,500 --> 00:26:03,000
well so they can simply jump to

686
00:26:03,000 --> 00:26:05,820
underlined addresses and to underline

687
00:26:05,820 --> 00:26:07,760
instructions and perform some

688
00:26:07,760 --> 00:26:10,020
computation that they want even though

689
00:26:10,020 --> 00:26:12,900
it is not there intended by the compiler

690
00:26:12,900 --> 00:26:15,419
or by the application developer and this

691
00:26:15,419 --> 00:26:17,100
property is due to non-aligned variable

692
00:26:17,100 --> 00:26:18,779
with opcodes

693
00:26:18,779 --> 00:26:21,120
now the Cisco instruction itself is

694
00:26:21,120 --> 00:26:23,880
quite small it only has byte sequence of

695
00:26:23,880 --> 00:26:27,960
0505 and of05 so it's very easy to find

696
00:26:27,960 --> 00:26:30,480
underlying ciscal instructions

697
00:26:30,480 --> 00:26:32,880
however when we think about svip in the

698
00:26:32,880 --> 00:26:34,620
context of these return oriented

699
00:26:34,620 --> 00:26:36,779
programming we do impose some

700
00:26:36,779 --> 00:26:39,419
restrictions on them so we restrict

701
00:26:39,419 --> 00:26:42,360
these rough chains by a Cisco Origins so

702
00:26:42,360 --> 00:26:45,000
for instance underlined instructions are

703
00:26:45,000 --> 00:26:46,919
simply no longer possible because we

704
00:26:46,919 --> 00:26:49,200
have never encountered as an underlying

705
00:26:49,200 --> 00:26:51,840
ciscaline structure in our static

706
00:26:51,840 --> 00:26:53,700
analysis because we are the compiler we

707
00:26:53,700 --> 00:26:56,460
have no clue about this at this point

708
00:26:56,460 --> 00:26:59,400
and uh also potentially Shell Code or

709
00:26:59,400 --> 00:27:01,679
something like that is also not possible

710
00:27:01,679 --> 00:27:04,679
second in together with the origins we

711
00:27:04,679 --> 00:27:07,260
also enforce that not uh considered not

712
00:27:07,260 --> 00:27:08,880
every single sequence is possible

713
00:27:08,880 --> 00:27:11,039
anymore so this is also quite a nice

714
00:27:11,039 --> 00:27:12,659
reduction so an attacker must be very

715
00:27:12,659 --> 00:27:14,520
careful in the gadgets that are

716
00:27:14,520 --> 00:27:16,200
constructed and must have previous

717
00:27:16,200 --> 00:27:18,600
knowledge about the possible Transitions

718
00:27:18,600 --> 00:27:21,179
and the possible Origins so together

719
00:27:21,179 --> 00:27:23,159
with this we can say that S3 can poses

720
00:27:23,159 --> 00:27:25,020
significant constraints on control flow

721
00:27:25,020 --> 00:27:27,000
hijacking attacks

722
00:27:27,000 --> 00:27:30,659
however svip is not perfect when it

723
00:27:30,659 --> 00:27:34,980
comes to uh to this we have similar

724
00:27:34,980 --> 00:27:38,220
restrictions to limitations as C5 for

725
00:27:38,220 --> 00:27:39,179
instance as I mentioned the over

726
00:27:39,179 --> 00:27:41,100
approximation and this over

727
00:27:41,100 --> 00:27:43,679
approximation leads to something that we

728
00:27:43,679 --> 00:27:46,980
call that is called a mimicry attack

729
00:27:46,980 --> 00:27:49,380
in our case it's not a typical mimicry

730
00:27:49,380 --> 00:27:51,240
attack as it is discussed in the

731
00:27:51,240 --> 00:27:52,799
literature for intuition detection

732
00:27:52,799 --> 00:27:56,340
systems but a slightly modified version

733
00:27:56,340 --> 00:28:00,000
but let me briefly discuss the mimicry

734
00:28:00,000 --> 00:28:01,380
attacks in the context of intrusion

735
00:28:01,380 --> 00:28:03,240
detection systems because there we have

736
00:28:03,240 --> 00:28:06,299
also used Cisco sequences for detecting

737
00:28:06,299 --> 00:28:08,279
malicious behavior

738
00:28:08,279 --> 00:28:10,500
but not enforcement as we are using it

739
00:28:10,500 --> 00:28:12,240
so we have this detection policy now

740
00:28:12,240 --> 00:28:13,919
intuition detection system that from an

741
00:28:13,919 --> 00:28:15,720
open system call

742
00:28:15,720 --> 00:28:17,460
um if an open system call followed by an

743
00:28:17,460 --> 00:28:19,200
f-stat system called followed by a write

744
00:28:19,200 --> 00:28:21,240
system called if we see this Behavior

745
00:28:21,240 --> 00:28:23,700
then we know that something malicious is

746
00:28:23,700 --> 00:28:25,020
going on

747
00:28:25,020 --> 00:28:27,960
in the mimicry attack the it is quite

748
00:28:27,960 --> 00:28:30,120
simple to evade this this detection

749
00:28:30,120 --> 00:28:31,740
because an attacker can simply do this

750
00:28:31,740 --> 00:28:34,080
we the attacker executes the open system

751
00:28:34,080 --> 00:28:36,360
call then performs some no op system

752
00:28:36,360 --> 00:28:38,340
call it can be anything let's say it's a

753
00:28:38,340 --> 00:28:39,960
read system call

754
00:28:39,960 --> 00:28:42,360
then after the read system call the

755
00:28:42,360 --> 00:28:44,159
attacker performs the f-stat system call

756
00:28:44,159 --> 00:28:46,620
and there we could also potentially do

757
00:28:46,620 --> 00:28:48,779
another no op system call can also be

758
00:28:48,779 --> 00:28:51,179
the read system call again and then we

759
00:28:51,179 --> 00:28:52,919
perform the right system code the only

760
00:28:52,919 --> 00:28:54,480
thing that is necessary for the attacker

761
00:28:54,480 --> 00:28:56,580
is the D2 for instance in this case the

762
00:28:56,580 --> 00:28:58,799
two no op system calls don't interfere

763
00:28:58,799 --> 00:29:01,020
with the actual attack they are simply

764
00:29:01,020 --> 00:29:04,620
there to towards the detection policy

765
00:29:04,620 --> 00:29:07,320
in our case it's a little bit different

766
00:29:07,320 --> 00:29:09,720
because we don't try to detect malicious

767
00:29:09,720 --> 00:29:11,820
behavior we try to enforce program

768
00:29:11,820 --> 00:29:13,380
Behavior

769
00:29:13,380 --> 00:29:16,020
but we do have this over approximation

770
00:29:16,020 --> 00:29:18,480
that allows an attacker to do this when

771
00:29:18,480 --> 00:29:22,080
we uh our application for instance

772
00:29:22,080 --> 00:29:23,760
doesn't have a valid transition from the

773
00:29:23,760 --> 00:29:25,799
open system call to the f-stat system

774
00:29:25,799 --> 00:29:27,899
call but it does have a valid transition

775
00:29:27,899 --> 00:29:30,480
from open to our no op system call which

776
00:29:30,480 --> 00:29:32,700
in turn has a transition to the asset

777
00:29:32,700 --> 00:29:34,860
system call so the attacker with the

778
00:29:34,860 --> 00:29:37,260
knowledge of the Cisco sequences can

779
00:29:37,260 --> 00:29:40,140
weave its way through the

780
00:29:40,140 --> 00:29:42,120
um through the enforcement so to reach

781
00:29:42,120 --> 00:29:45,480
the final system called it's required in

782
00:29:45,480 --> 00:29:46,559
the attack

783
00:29:46,559 --> 00:29:48,840
however even if an attacker tries to do

784
00:29:48,840 --> 00:29:50,399
this there are simple there are still

785
00:29:50,399 --> 00:29:52,860
restrictions so there must be a valid

786
00:29:52,860 --> 00:29:54,600
transition between the no op system call

787
00:29:54,600 --> 00:29:57,960
and the um the source system call and

788
00:29:57,960 --> 00:30:00,480
the know-up system call must execute at

789
00:30:00,480 --> 00:30:03,720
the valid Target at the valid origin if

790
00:30:03,720 --> 00:30:05,340
this is not possible if this is not

791
00:30:05,340 --> 00:30:09,120
given then we will kill the the exploit

792
00:30:09,120 --> 00:30:10,919
and this is possible for every single

793
00:30:10,919 --> 00:30:12,539
one of these edges

794
00:30:12,539 --> 00:30:15,539
so an attacker with knowledge can find a

795
00:30:15,539 --> 00:30:18,120
way but still we do impose some

796
00:30:18,120 --> 00:30:23,239
restrictions on uh on attacks

797
00:30:23,279 --> 00:30:25,799
one thing that I want to point to also

798
00:30:25,799 --> 00:30:27,539
is that something that I've done and

799
00:30:27,539 --> 00:30:29,460
that I will probably release in the near

800
00:30:29,460 --> 00:30:31,559
future it's work that I've done with my

801
00:30:31,559 --> 00:30:34,980
student and it's more or less to

802
00:30:34,980 --> 00:30:39,000
restrict exactly a text like this

803
00:30:39,000 --> 00:30:40,679
let's assume we have a simple example

804
00:30:40,679 --> 00:30:42,720
here we have two code locations we have

805
00:30:42,720 --> 00:30:45,200
in the creation a we have a function

806
00:30:45,200 --> 00:30:48,360
Cisco it performs a system color and

807
00:30:48,360 --> 00:30:49,860
then it should cause the function bar

808
00:30:49,860 --> 00:30:52,200
one bar one in turn also performs system

809
00:30:52,200 --> 00:30:54,899
call and returns to our function from

810
00:30:54,899 --> 00:30:57,779
one location B does pretty much the same

811
00:30:57,779 --> 00:30:59,340
thing it also performs the same system

812
00:30:59,340 --> 00:31:01,440
color but transitions to a different

813
00:31:01,440 --> 00:31:04,020
function so there we perform a different

814
00:31:04,020 --> 00:31:05,279
system call

815
00:31:05,279 --> 00:31:07,380
on the right we can see here the

816
00:31:07,380 --> 00:31:09,779
information that we extract in S5 we

817
00:31:09,779 --> 00:31:11,520
have the transition so we know that open

818
00:31:11,520 --> 00:31:12,960
because we have encountered it can

819
00:31:12,960 --> 00:31:15,000
transition to either the read or the

820
00:31:15,000 --> 00:31:16,919
Stat system column and we have the

821
00:31:16,919 --> 00:31:19,919
origins we have opma can occur at these

822
00:31:19,919 --> 00:31:22,320
different locations and read can occur

823
00:31:22,320 --> 00:31:25,740
these uh locations read and set at these

824
00:31:25,740 --> 00:31:27,419
locations

825
00:31:27,419 --> 00:31:29,159
one thing that an attacker now would be

826
00:31:29,159 --> 00:31:31,260
possible because we perform these

827
00:31:31,260 --> 00:31:32,820
transitions these origin checks

828
00:31:32,820 --> 00:31:34,980
independent of each other an attacker

829
00:31:34,980 --> 00:31:36,840
can do simply execute the open system

830
00:31:36,840 --> 00:31:39,899
call add our location a and transition

831
00:31:39,899 --> 00:31:42,539
to location B and perform the Stat

832
00:31:42,539 --> 00:31:45,360
system call there if it is required this

833
00:31:45,360 --> 00:31:47,760
would pass both tests checks because

834
00:31:47,760 --> 00:31:50,100
it's a valid transition and both system

835
00:31:50,100 --> 00:31:53,399
calls over originate from a valid origin

836
00:31:53,399 --> 00:31:55,320
that's why I refer to this

837
00:31:55,320 --> 00:31:57,480
implementation of svip as coarse grained

838
00:31:57,480 --> 00:32:00,000
as fit similar to what you see in CFI

839
00:32:00,000 --> 00:32:01,320
where we have coarse grained and

840
00:32:01,320 --> 00:32:03,600
fine-grained CFI

841
00:32:03,600 --> 00:32:05,159
one thing that I worked with my student

842
00:32:05,159 --> 00:32:07,980
on is that we thought that okay now that

843
00:32:07,980 --> 00:32:09,840
we know that actually in extracting

844
00:32:09,840 --> 00:32:11,640
these fiscal Origins these Cisco

845
00:32:11,640 --> 00:32:14,520
transition sequences is possible let's

846
00:32:14,520 --> 00:32:18,720
more finely intertwine these parts so we

847
00:32:18,720 --> 00:32:19,860
came up with this idea of this

848
00:32:19,860 --> 00:32:23,100
fine-grained s-fib where we make the

849
00:32:23,100 --> 00:32:25,380
transition check also dependent on the

850
00:32:25,380 --> 00:32:27,480
previous origin so now we have the

851
00:32:27,480 --> 00:32:29,820
information that's open when it occurs

852
00:32:29,820 --> 00:32:32,279
at the location of X2 can only

853
00:32:32,279 --> 00:32:34,380
transition to the system called read at

854
00:32:34,380 --> 00:32:37,320
ox12 so the transition from this point

855
00:32:37,320 --> 00:32:40,100
to this point here is no longer possible

856
00:32:40,100 --> 00:32:42,840
and we've worked on this for quite a

857
00:32:42,840 --> 00:32:45,240
while now if we have evaluated it and it

858
00:32:45,240 --> 00:32:47,580
seems to actually do what we intended it

859
00:32:47,580 --> 00:32:50,580
to do so it poses even more significant

860
00:32:50,580 --> 00:32:52,620
restrictions but at the cost of

861
00:32:52,620 --> 00:32:54,000
performance

862
00:32:54,000 --> 00:32:56,700
now before I finish my presentation here

863
00:32:56,700 --> 00:32:58,440
I want to point you to a proof of

864
00:32:58,440 --> 00:33:01,320
concept uh you can find it on GitHub uh

865
00:33:01,320 --> 00:33:02,940
one thing that I want to point out it's

866
00:33:02,940 --> 00:33:06,000
an academic proof of concept so there

867
00:33:06,000 --> 00:33:08,159
are still restrictions I'm currently

868
00:33:08,159 --> 00:33:10,380
working also on it to make it more easy

869
00:33:10,380 --> 00:33:13,200
to use because it's quite difficult

870
00:33:13,200 --> 00:33:16,019
right now but you can find a proof of

871
00:33:16,019 --> 00:33:19,080
concept implementation on GitHub and I'm

872
00:33:19,080 --> 00:33:20,940
also working on releasing our more

873
00:33:20,940 --> 00:33:23,820
fine-grained solution there as well

874
00:33:23,820 --> 00:33:26,179
if you want more information so there's

875
00:33:26,179 --> 00:33:29,039
obviously not enough time to go into all

876
00:33:29,039 --> 00:33:30,960
the details so you can find more details

877
00:33:30,960 --> 00:33:32,460
in our paper you have all the

878
00:33:32,460 --> 00:33:34,080
information implementation details where

879
00:33:34,080 --> 00:33:36,659
we discuss even potential improvements

880
00:33:36,659 --> 00:33:38,460
that are going even further than what we

881
00:33:38,460 --> 00:33:40,440
have currently limitations more

882
00:33:40,440 --> 00:33:42,899
extensive security discussion we also

883
00:33:42,899 --> 00:33:45,899
demonstrated in our paper uh how a

884
00:33:45,899 --> 00:33:48,480
specific bug would have been prevented

885
00:33:48,480 --> 00:33:50,880
if our Implement if the application

886
00:33:50,880 --> 00:33:52,980
would have prevent been protected by

887
00:33:52,980 --> 00:33:56,460
svip and you can find it on archive

888
00:33:56,460 --> 00:33:58,980
now a brief recap

889
00:33:58,980 --> 00:34:01,200
um so with svip we do provide this

890
00:34:01,200 --> 00:34:03,240
Integrity to use the kernel transitions

891
00:34:03,240 --> 00:34:04,799
that we were not able to do directly

892
00:34:04,799 --> 00:34:07,679
with CFI and also not directly with

893
00:34:07,679 --> 00:34:08,879
secon

894
00:34:08,879 --> 00:34:11,159
we were also able to provide security

895
00:34:11,159 --> 00:34:14,159
via our Cisco Transitions and our origin

896
00:34:14,159 --> 00:34:15,179
checks

897
00:34:15,179 --> 00:34:17,399
and one thing that I also want to point

898
00:34:17,399 --> 00:34:19,139
out similar to our automated second

899
00:34:19,139 --> 00:34:21,418
filter generation it is fully automized

900
00:34:21,418 --> 00:34:23,879
it does not require any

901
00:34:23,879 --> 00:34:26,339
action body developer except adding like

902
00:34:26,339 --> 00:34:29,940
con compiler Flags otherwise it's fully

903
00:34:29,940 --> 00:34:32,639
automated and it has minimal runtime

904
00:34:32,639 --> 00:34:35,339
overhead of less than two percent

905
00:34:35,339 --> 00:34:37,679
um as we have seen with that I would

906
00:34:37,679 --> 00:34:39,659
like to thank you for your attention and

907
00:34:39,659 --> 00:34:41,580
if you have any questions please feel

908
00:34:41,580 --> 00:34:44,179
free to ask

909
00:34:44,280 --> 00:34:47,389
[Music]

910
00:34:51,239 --> 00:34:54,339
[Music]

