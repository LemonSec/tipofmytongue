1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,519 --> 00:00:11,340
so hi everyone I'm Pietro and today

3
00:00:11,340 --> 00:00:13,200
Erica and I were going to present our

4
00:00:13,200 --> 00:00:15,780
latest work on bypass inspector how to

5
00:00:15,780 --> 00:00:18,480
defenses to the kernel data

6
00:00:18,480 --> 00:00:20,460
so first of all the sun credits to the

7
00:00:20,460 --> 00:00:22,080
people behind this project as you can

8
00:00:22,080 --> 00:00:24,779
see here it's me and Enrico and we does

9
00:00:24,779 --> 00:00:27,599
Mario's Herbert and Cristiano that are

10
00:00:27,599 --> 00:00:28,800
part of the our booster group in

11
00:00:28,800 --> 00:00:32,159
Amsterdam actors a lot in this project

12
00:00:32,159 --> 00:00:34,140
so what is this project about this

13
00:00:34,140 --> 00:00:36,059
project is about Spectra which is a

14
00:00:36,059 --> 00:00:37,680
vulnerability that affects most modern

15
00:00:37,680 --> 00:00:39,059
CPUs

16
00:00:39,059 --> 00:00:41,219
and one of the reasons why Specter was

17
00:00:41,219 --> 00:00:42,300
considered interesting from the

18
00:00:42,300 --> 00:00:44,579
beginning was that it allowed attackers

19
00:00:44,579 --> 00:00:46,260
to leak data even across privileged

20
00:00:46,260 --> 00:00:48,120
levels so for instance you could build

21
00:00:48,120 --> 00:00:50,579
exploits leaking data from the kernel to

22
00:00:50,579 --> 00:00:52,500
user space and this was completely

23
00:00:52,500 --> 00:00:55,440
disregard the concept of the supervisor

24
00:00:55,440 --> 00:00:56,820
domains

25
00:00:56,820 --> 00:00:59,039
so what should people vendors did when

26
00:00:59,039 --> 00:01:01,020
this uh Bon Appetit was discovered was

27
00:01:01,020 --> 00:01:03,059
to release all sorts of software and

28
00:01:03,059 --> 00:01:04,440
other defenses

29
00:01:04,440 --> 00:01:06,960
and uh for the purpose of this worker we

30
00:01:06,960 --> 00:01:08,640
mostly focus on the defenses trying to

31
00:01:08,640 --> 00:01:10,500
toward these kind of cross privilege

32
00:01:10,500 --> 00:01:12,479
exploits and the question we asked

33
00:01:12,479 --> 00:01:14,100
ourselves was do this mitigation

34
00:01:14,100 --> 00:01:16,200
actually work

35
00:01:16,200 --> 00:01:18,180
and legal spoiler no they don't quite

36
00:01:18,180 --> 00:01:20,340
work as intended but we're gonna get

37
00:01:20,340 --> 00:01:22,200
there in a bit

38
00:01:22,200 --> 00:01:24,000
so how do we speak this work

39
00:01:24,000 --> 00:01:25,200
um I'm going to start with a

40
00:01:25,200 --> 00:01:26,939
presentation talking about the Spectra

41
00:01:26,939 --> 00:01:28,740
and a bit of background on how it works

42
00:01:28,740 --> 00:01:30,720
and I will talk about these defenses

43
00:01:30,720 --> 00:01:32,939
that they released and also how to

44
00:01:32,939 --> 00:01:35,700
bypass them and afterwards Erika will

45
00:01:35,700 --> 00:01:37,920
pick it up and we'll talk about our new

46
00:01:37,920 --> 00:01:39,360
primitive which is a branch history

47
00:01:39,360 --> 00:01:41,640
injection and then it will talk about

48
00:01:41,640 --> 00:01:43,380
how we can exploit this and we'll give

49
00:01:43,380 --> 00:01:45,420
also a live demo so hopefully that's

50
00:01:45,420 --> 00:01:46,920
gonna go well

51
00:01:46,920 --> 00:01:49,860
so start with Spectrum what is Spectrum

52
00:01:49,860 --> 00:01:51,780
Spectra as I said it's vulnerability

53
00:01:51,780 --> 00:01:54,360
that affects most modern CPUs and in

54
00:01:54,360 --> 00:01:55,560
particular it affects specific

55
00:01:55,560 --> 00:01:57,360
components at the CPU which is the

56
00:01:57,360 --> 00:01:59,100
branch prediction unit

57
00:01:59,100 --> 00:02:01,200
and the best picture unit as the name

58
00:02:01,200 --> 00:02:03,360
suggests is simply trying to predict the

59
00:02:03,360 --> 00:02:05,280
execution of different branches so for

60
00:02:05,280 --> 00:02:06,600
instance in this case here we have an

61
00:02:06,600 --> 00:02:09,000
example of a conditional branch that is

62
00:02:09,000 --> 00:02:11,640
trying to perform a bound check for an

63
00:02:11,640 --> 00:02:14,940
array and what happens here is based on

64
00:02:14,940 --> 00:02:17,280
the value you provide of the index of

65
00:02:17,280 --> 00:02:19,800
the array you will figure out you will

66
00:02:19,800 --> 00:02:21,720
start building confidence at the BPU

67
00:02:21,720 --> 00:02:23,459
level to know if the branch is usually

68
00:02:23,459 --> 00:02:25,680
taken or not so if the if usually the x

69
00:02:25,680 --> 00:02:27,239
value is within the boundaries so for

70
00:02:27,239 --> 00:02:28,860
instance in this case if you provide

71
00:02:28,860 --> 00:02:31,080
zero as a value the BPU will start

72
00:02:31,080 --> 00:02:32,640
building confidence okay this is a

73
00:02:32,640 --> 00:02:34,560
valued in the boundaries so I should

74
00:02:34,560 --> 00:02:36,480
take this Branch same with one and two

75
00:02:36,480 --> 00:02:37,680
as well

76
00:02:37,680 --> 00:02:39,840
now what happened is if you provide a

77
00:02:39,840 --> 00:02:42,239
value uh outside the boundaries of this

78
00:02:42,239 --> 00:02:44,099
array and the BPU built enough

79
00:02:44,099 --> 00:02:45,420
confidence that this branch is usually

80
00:02:45,420 --> 00:02:46,319
taken

81
00:02:46,319 --> 00:02:48,720
it won't care that this really shouldn't

82
00:02:48,720 --> 00:02:49,739
happen it will do it anyway

83
00:02:49,739 --> 00:02:52,440
speculatively so specifically you can

84
00:02:52,440 --> 00:02:54,780
perform an autobound read now clearly

85
00:02:54,780 --> 00:02:56,280
this is not a big deal in the

86
00:02:56,280 --> 00:02:58,019
architectural domain because eventually

87
00:02:58,019 --> 00:03:00,000
you will figure out okay this shouldn't

88
00:03:00,000 --> 00:03:01,860
have happened so I will just squash this

89
00:03:01,860 --> 00:03:03,900
read never happen I'm going to move on

90
00:03:03,900 --> 00:03:06,900
to whatever I need to do when the when

91
00:03:06,900 --> 00:03:08,280
the result of bound

92
00:03:08,280 --> 00:03:09,900
but specifically you still perform the

93
00:03:09,900 --> 00:03:10,980
Rhythm

94
00:03:10,980 --> 00:03:13,019
and what happens when you combine it

95
00:03:13,019 --> 00:03:14,459
with another sort of a micro retraction

96
00:03:14,459 --> 00:03:16,680
attack like a flash reload which is a

97
00:03:16,680 --> 00:03:18,959
cache attacking so what you can do is

98
00:03:18,959 --> 00:03:22,319
for instance combine this uh Autobahn

99
00:03:22,319 --> 00:03:24,659
read with a dependent Auto Body reader

100
00:03:24,659 --> 00:03:27,000
so what we'll do is for instance if in

101
00:03:27,000 --> 00:03:30,000
the location 256 you have the value 3

102
00:03:30,000 --> 00:03:32,280
what you can do is perform a second read

103
00:03:32,280 --> 00:03:34,019
based on this value on a second array

104
00:03:34,019 --> 00:03:36,659
which is your flashy little buffer

105
00:03:36,659 --> 00:03:39,599
and this value this reader will catch

106
00:03:39,599 --> 00:03:43,379
the value of this real buffer so that

107
00:03:43,379 --> 00:03:44,819
the entry of the real buffer will be

108
00:03:44,819 --> 00:03:46,860
cached now so afterwards what you can do

109
00:03:46,860 --> 00:03:50,700
is to leak a secret data you simply time

110
00:03:50,700 --> 00:03:53,519
the memory access of this array

111
00:03:53,519 --> 00:03:55,440
and eventually you will time the whole

112
00:03:55,440 --> 00:03:57,299
array and you figure out that the first

113
00:03:57,299 --> 00:03:59,159
one was the one you actually leaked

114
00:03:59,159 --> 00:04:01,440
and this allows you to lick these uh

115
00:04:01,440 --> 00:04:04,440
data that was out of bound before

116
00:04:04,440 --> 00:04:06,540
and this doesn't only work in the case

117
00:04:06,540 --> 00:04:08,640
of uh conditional branches but also in

118
00:04:08,640 --> 00:04:11,099
the case of in dark branches so for

119
00:04:11,099 --> 00:04:12,120
instance here we're going to use an

120
00:04:12,120 --> 00:04:14,700
example of a polymorphism to explain how

121
00:04:14,700 --> 00:04:17,040
indirect Branch prediction Works in this

122
00:04:17,040 --> 00:04:18,899
case here you have two classes a cat

123
00:04:18,899 --> 00:04:21,298
class and a DOT class and both of them

124
00:04:21,298 --> 00:04:23,460
implement the speak method

125
00:04:23,460 --> 00:04:25,139
and when you call the speak method from

126
00:04:25,139 --> 00:04:26,940
the cat cluster you would expect the

127
00:04:26,940 --> 00:04:29,220
function to execute the meow function

128
00:04:29,220 --> 00:04:31,259
and when you come from the dot class you

129
00:04:31,259 --> 00:04:33,960
would expect the wolf function

130
00:04:33,960 --> 00:04:35,040
and

131
00:04:35,040 --> 00:04:37,380
what happens here is that you can the

132
00:04:37,380 --> 00:04:39,720
BPU can also help in predicting the next

133
00:04:39,720 --> 00:04:42,360
section of these branches so when you

134
00:04:42,360 --> 00:04:44,759
call the function uh from the cat class

135
00:04:44,759 --> 00:04:46,139
in this case the BPU needs to figure out

136
00:04:46,139 --> 00:04:48,780
where to jump and to do so instead of a

137
00:04:48,780 --> 00:04:51,419
few you have another uh you have a table

138
00:04:51,419 --> 00:04:52,680
like you have a specific cache called

139
00:04:52,680 --> 00:04:55,199
the branch Target buffer or btdb which

140
00:04:55,199 --> 00:04:57,780
contains a different Target for all the

141
00:04:57,780 --> 00:05:00,120
possible function that you recently

142
00:05:00,120 --> 00:05:01,560
executed

143
00:05:01,560 --> 00:05:03,479
and in this case you have two options

144
00:05:03,479 --> 00:05:05,280
clearly for this function you have two

145
00:05:05,280 --> 00:05:07,380
Targets one is a meow and one wolf and

146
00:05:07,380 --> 00:05:09,780
if you're coming from the cat class in

147
00:05:09,780 --> 00:05:12,120
this case Mia will be a correct

148
00:05:12,120 --> 00:05:14,280
prediction so you will you will speed up

149
00:05:14,280 --> 00:05:16,199
the execution and move for BMS

150
00:05:16,199 --> 00:05:17,699
prediction which means you will execute

151
00:05:17,699 --> 00:05:20,220
that function speculatively revert back

152
00:05:20,220 --> 00:05:21,780
and then execute the mail function

153
00:05:21,780 --> 00:05:24,060
afterwards

154
00:05:24,060 --> 00:05:25,740
what's the problem with this the problem

155
00:05:25,740 --> 00:05:28,380
is you can exploit Spectra you can build

156
00:05:28,380 --> 00:05:29,820
a different variant prospector which is

157
00:05:29,820 --> 00:05:31,979
known as a specter V2

158
00:05:31,979 --> 00:05:34,139
that attack this kind of uh in dark

159
00:05:34,139 --> 00:05:36,419
branches and the reason why you can

160
00:05:36,419 --> 00:05:38,039
exploit this is because the branch

161
00:05:38,039 --> 00:05:39,900
Target buffer is a shared resource

162
00:05:39,900 --> 00:05:42,360
across different contexts on the CPU and

163
00:05:42,360 --> 00:05:43,979
what an attacker can do is simply

164
00:05:43,979 --> 00:05:45,720
override the entries in the branch

165
00:05:45,720 --> 00:05:47,639
Target buffer with more interesting

166
00:05:47,639 --> 00:05:50,220
interesting targets like a function like

167
00:05:50,220 --> 00:05:52,139
League secret and leak secret would be

168
00:05:52,139 --> 00:05:54,479
something like we the one we discla we

169
00:05:54,479 --> 00:05:56,220
discussed earlier of a flashy load

170
00:05:56,220 --> 00:05:57,300
attack

171
00:05:57,300 --> 00:05:59,639
so now what happened is when the cat

172
00:05:59,639 --> 00:06:02,639
class will call again the speak function

173
00:06:02,639 --> 00:06:05,280
at this point for that uh a specific

174
00:06:05,280 --> 00:06:07,680
class you would expect to execute the

175
00:06:07,680 --> 00:06:09,180
Mia function but now you overwrote it

176
00:06:09,180 --> 00:06:11,280
with the leak secret function which

177
00:06:11,280 --> 00:06:12,780
means that you will execute the league

178
00:06:12,780 --> 00:06:15,660
secret function instead of the the meow

179
00:06:15,660 --> 00:06:17,039
function

180
00:06:17,039 --> 00:06:20,100
and uh and as we said this uh this works

181
00:06:20,100 --> 00:06:22,020
across uh different privileged levels so

182
00:06:22,020 --> 00:06:23,699
you can build across privilege attacks

183
00:06:23,699 --> 00:06:25,800
and these are this you can do it across

184
00:06:25,800 --> 00:06:27,120
a different application running on the

185
00:06:27,120 --> 00:06:29,520
same core you can do it between user and

186
00:06:29,520 --> 00:06:31,440
kernel and even guest and host because

187
00:06:31,440 --> 00:06:33,720
the CPU has no idea that there are

188
00:06:33,720 --> 00:06:35,580
different contexts

189
00:06:35,580 --> 00:06:36,900
so you can imagine this is quite scary

190
00:06:36,900 --> 00:06:38,220
right because this allows you to build

191
00:06:38,220 --> 00:06:39,539
attack across all different previous

192
00:06:39,539 --> 00:06:42,180
levels so what do we do next then

193
00:06:42,180 --> 00:06:45,060
what the CPU vendors did uh when this

194
00:06:45,060 --> 00:06:46,860
was discovered was a come up with all

195
00:06:46,860 --> 00:06:48,600
sorts of defenses and they started with

196
00:06:48,600 --> 00:06:50,220
the initially with the software defenses

197
00:06:50,220 --> 00:06:52,500
because it's faster to implement and the

198
00:06:52,500 --> 00:06:54,180
first one was uh known as red Pauline

199
00:06:54,180 --> 00:06:56,520
and rappling what simply does is uh

200
00:06:56,520 --> 00:06:59,880
convert all the indirect codes that like

201
00:06:59,880 --> 00:07:02,340
this called reacts we have here with the

202
00:07:02,340 --> 00:07:05,520
this is a Big Blob of instructions that

203
00:07:05,520 --> 00:07:07,380
the general idea behind is just trying

204
00:07:07,380 --> 00:07:09,120
to stop speculation altogether

205
00:07:09,120 --> 00:07:12,000
so instead of performing a dark jump you

206
00:07:12,000 --> 00:07:14,819
will convert this to this chunk of code

207
00:07:14,819 --> 00:07:16,919
which will not allow you to perform any

208
00:07:16,919 --> 00:07:18,539
speculation on this so you cannot

209
00:07:18,539 --> 00:07:20,460
exploit Spectra anymore on this

210
00:07:20,460 --> 00:07:22,800
AMD is something very similar it's

211
00:07:22,800 --> 00:07:24,960
called the mdright Pauline or elfense

212
00:07:24,960 --> 00:07:27,000
jump and this is basically the same

213
00:07:27,000 --> 00:07:28,620
exact concept just a very different

214
00:07:28,620 --> 00:07:30,120
implementation for a different micro

215
00:07:30,120 --> 00:07:32,639
architecture whereas Arma because of the

216
00:07:32,639 --> 00:07:35,099
fragmented ecosystem of different

217
00:07:35,099 --> 00:07:36,660
architecture they have they do very

218
00:07:36,660 --> 00:07:38,880
weird things depending on their

219
00:07:38,880 --> 00:07:41,340
different systems

220
00:07:41,340 --> 00:07:45,240
and in other uh both Intel normal worked

221
00:07:45,240 --> 00:07:48,000
on two different mitigation known as ER

222
00:07:48,000 --> 00:07:50,699
BRS and csv2 and this mitigation even

223
00:07:50,699 --> 00:07:51,720
though they're very different in

224
00:07:51,720 --> 00:07:53,340
implementation with us they're actually

225
00:07:53,340 --> 00:07:55,319
very similar in concept and the idea

226
00:07:55,319 --> 00:07:57,300
behind them is that you want to enforce

227
00:07:57,300 --> 00:07:59,460
predictor mode isolation directly in

228
00:07:59,460 --> 00:08:00,780
order

229
00:08:00,780 --> 00:08:02,819
and what do we mean by that the general

230
00:08:02,819 --> 00:08:05,340
idea is that we want to Target the B2B

231
00:08:05,340 --> 00:08:07,800
entries by security domain

232
00:08:07,800 --> 00:08:09,900
so the way you can visualize this is a

233
00:08:09,900 --> 00:08:12,720
you can simply extend the the btb with

234
00:08:12,720 --> 00:08:15,300
an extra column where you tag the entry

235
00:08:15,300 --> 00:08:17,280
with the other user or kernel contacts

236
00:08:17,280 --> 00:08:19,259
or guest or host or whatever

237
00:08:19,259 --> 00:08:21,539
and afterwards what happens is when you

238
00:08:21,539 --> 00:08:24,000
perform a jump from the current context

239
00:08:24,000 --> 00:08:26,220
for instance at this point the PPU will

240
00:08:26,220 --> 00:08:28,379
allow you only to speculate two Targets

241
00:08:28,379 --> 00:08:30,000
that belong to the kernel context then

242
00:08:30,000 --> 00:08:32,219
and as a result you can look at this as

243
00:08:32,219 --> 00:08:34,440
basically uh implement this method but

244
00:08:34,440 --> 00:08:37,200
in the speculative domain so here you

245
00:08:37,200 --> 00:08:38,580
cannot Implement any more attacks that

246
00:08:38,580 --> 00:08:42,899
jump back to user defined functions

247
00:08:42,899 --> 00:08:44,099
so the question we asked when we start

248
00:08:44,099 --> 00:08:45,480
with this project was is this isolation

249
00:08:45,480 --> 00:08:46,860
completed

250
00:08:46,860 --> 00:08:48,600
and the first thing we did was uh going

251
00:08:48,600 --> 00:08:51,360
to look at the the their manuals and

252
00:08:51,360 --> 00:08:52,980
this is a Dr manual for the csv2

253
00:08:52,980 --> 00:08:54,300
function

254
00:08:54,300 --> 00:08:56,519
and in their mind already they suggest

255
00:08:56,519 --> 00:08:58,740
that an attacker can exploitly control

256
00:08:58,740 --> 00:09:01,200
speculative execution only in order to

257
00:09:01,200 --> 00:09:02,519
determine ways

258
00:09:02,519 --> 00:09:03,899
so clearly we're kind of confused when

259
00:09:03,899 --> 00:09:05,940
we started working on this because

260
00:09:05,940 --> 00:09:07,620
what does this even mean

261
00:09:07,620 --> 00:09:09,420
so we start looking at how we can bypass

262
00:09:09,420 --> 00:09:12,180
this uh mitigations

263
00:09:12,180 --> 00:09:13,560
and now I'm going to explain to you how

264
00:09:13,560 --> 00:09:15,779
we did this then and to do so I'm going

265
00:09:15,779 --> 00:09:17,160
to start again with our example of the

266
00:09:17,160 --> 00:09:19,260
cat and dog I'm going to explain a bit

267
00:09:19,260 --> 00:09:20,820
more about how indirect Branch

268
00:09:20,820 --> 00:09:23,160
prediction works on the CPU

269
00:09:23,160 --> 00:09:25,740
so as we said here we expect the cat

270
00:09:25,740 --> 00:09:28,200
class to execute the meow function and

271
00:09:28,200 --> 00:09:29,820
the dog class to execute the wolf

272
00:09:29,820 --> 00:09:31,800
function right but from the previous

273
00:09:31,800 --> 00:09:35,220
review side both functions come from the

274
00:09:35,220 --> 00:09:37,140
same method so the speaker method will

275
00:09:37,140 --> 00:09:39,959
need to execute both of them so here you

276
00:09:39,959 --> 00:09:41,279
have one single function call right so

277
00:09:41,279 --> 00:09:42,899
how does the BPU

278
00:09:42,899 --> 00:09:44,660
distinguish the two different uh

279
00:09:44,660 --> 00:09:46,440
contexts then

280
00:09:46,440 --> 00:09:48,060
and the answer is exactly this the

281
00:09:48,060 --> 00:09:49,440
prediction needs to depend on the

282
00:09:49,440 --> 00:09:51,959
context of the of the function call

283
00:09:51,959 --> 00:09:54,000
and what do we mean by that with context

284
00:09:54,000 --> 00:09:56,880
we simply mean the history of previously

285
00:09:56,880 --> 00:09:59,700
executed functions so for instance in

286
00:09:59,700 --> 00:10:01,080
this case if you're coming from the cat

287
00:10:01,080 --> 00:10:03,540
class you can expect that the previously

288
00:10:03,540 --> 00:10:05,640
executive functions or if condition will

289
00:10:05,640 --> 00:10:07,620
be something like a brickad class

290
00:10:07,620 --> 00:10:10,200
function that follows with a new cat and

291
00:10:10,200 --> 00:10:12,240
kitten for sword and this basically the

292
00:10:12,240 --> 00:10:13,860
context that allows you to distinguish

293
00:10:13,860 --> 00:10:16,980
which element of two is uh uh is the one

294
00:10:16,980 --> 00:10:18,600
you're coming from

295
00:10:18,600 --> 00:10:20,220
to this point you can use this context

296
00:10:20,220 --> 00:10:23,279
to generate the tag for the btb and here

297
00:10:23,279 --> 00:10:25,320
you will have a you can see that since

298
00:10:25,320 --> 00:10:27,600
the context is very cat related you will

299
00:10:27,600 --> 00:10:29,220
suppose you're supposed to speculate

300
00:10:29,220 --> 00:10:31,440
then to the meow function

301
00:10:31,440 --> 00:10:34,140
and how does this work in algor in order

302
00:10:34,140 --> 00:10:36,420
you can implement this uh in very

303
00:10:36,420 --> 00:10:38,880
different ways but uh one of the many

304
00:10:38,880 --> 00:10:40,980
variants that was discussed in the past

305
00:10:40,980 --> 00:10:45,180
is uh to use to use both the call side

306
00:10:45,180 --> 00:10:47,760
and the context set to compute the tag

307
00:10:47,760 --> 00:10:50,640
and what the they suggest is that they

308
00:10:50,640 --> 00:10:53,100
hash together all the different jump

309
00:10:53,100 --> 00:10:56,519
addresses of the the context into a

310
00:10:56,519 --> 00:10:58,200
shift register so you can just like

311
00:10:58,200 --> 00:11:00,420
squash all this information inside a

312
00:11:00,420 --> 00:11:03,420
single shift register and afterwards you

313
00:11:03,420 --> 00:11:05,160
combine this value with the actual

314
00:11:05,160 --> 00:11:07,440
cosight of the speak function

315
00:11:07,440 --> 00:11:09,240
you what you do is again like you get

316
00:11:09,240 --> 00:11:10,620
the value of the shift register the call

317
00:11:10,620 --> 00:11:12,540
side another hash function and you

318
00:11:12,540 --> 00:11:14,579
compute the tag now as you can see here

319
00:11:14,579 --> 00:11:17,940
we have our breed cat context and as a

320
00:11:17,940 --> 00:11:19,380
result since the context is very cap

321
00:11:19,380 --> 00:11:21,240
dependent you will need to speculate to

322
00:11:21,240 --> 00:11:23,640
the meow function

323
00:11:23,640 --> 00:11:25,019
so

324
00:11:25,019 --> 00:11:26,399
this you can see that like a digital

325
00:11:26,399 --> 00:11:28,680
usually depends on the context

326
00:11:28,680 --> 00:11:31,079
but how does it work when you perform a

327
00:11:31,079 --> 00:11:32,760
mode switch so a mode switch between

328
00:11:32,760 --> 00:11:35,820
user and the encounter space and our

329
00:11:35,820 --> 00:11:38,100
intuition is that the user history is

330
00:11:38,100 --> 00:11:39,899
necessary for accurate kernel prediction

331
00:11:39,899 --> 00:11:40,680
right

332
00:11:40,680 --> 00:11:42,180
and I'm going to use this example of a

333
00:11:42,180 --> 00:11:44,640
Cisco to uh to explain why this is the

334
00:11:44,640 --> 00:11:47,519
case so for instance in this case to

335
00:11:47,519 --> 00:11:50,040
perform a printf and when you perform a

336
00:11:50,040 --> 00:11:51,600
printf what you want to do is assist

337
00:11:51,600 --> 00:11:53,279
call and you want to execute a Cisco

338
00:11:53,279 --> 00:11:55,680
right to write out the the context at

339
00:11:55,680 --> 00:11:58,980
the con the the data to standard out and

340
00:11:58,980 --> 00:12:00,660
and what we'll do is generate attack

341
00:12:00,660 --> 00:12:04,800
based on uh this old history shared and

342
00:12:04,800 --> 00:12:06,899
this will store a new entry in the btb

343
00:12:06,899 --> 00:12:09,180
for a Cisco writing

344
00:12:09,180 --> 00:12:11,220
afterwards when you perform a different

345
00:12:11,220 --> 00:12:12,839
function for instance get Char at this

346
00:12:12,839 --> 00:12:14,220
point you want to perform a second Cisco

347
00:12:14,220 --> 00:12:16,680
which is Cisco read and this is supposed

348
00:12:16,680 --> 00:12:18,480
to store another entry in the btb right

349
00:12:18,480 --> 00:12:20,459
but in this case it would be for the

350
00:12:20,459 --> 00:12:21,540
Cisco read

351
00:12:21,540 --> 00:12:23,700
and the original intuition was exactly

352
00:12:23,700 --> 00:12:25,380
this that like if the Easter doesn't

353
00:12:25,380 --> 00:12:28,200
depend on the user space context it

354
00:12:28,200 --> 00:12:29,100
would be very difficult to understand

355
00:12:29,100 --> 00:12:30,959
that to which Cisco you need to jump to

356
00:12:30,959 --> 00:12:34,260
because the Cisco the kernel entry point

357
00:12:34,260 --> 00:12:35,940
is always exactly the same and you

358
00:12:35,940 --> 00:12:37,620
simply have a dispatcher to different

359
00:12:37,620 --> 00:12:40,200
Cisco handlers so this means that if

360
00:12:40,200 --> 00:12:41,399
this mitigation don't take into account

361
00:12:41,399 --> 00:12:43,740
also the history of the user space all

362
00:12:43,740 --> 00:12:45,600
the mispredictions would be vegetable so

363
00:12:45,600 --> 00:12:46,920
in our case we expect that the next time

364
00:12:46,920 --> 00:12:49,440
you call a printf the BPU will think

365
00:12:49,440 --> 00:12:51,120
okay I already seen this is a history so

366
00:12:51,120 --> 00:12:53,820
I need to speculators is called right

367
00:12:53,820 --> 00:12:56,579
and we tested this from with an attacker

368
00:12:56,579 --> 00:12:58,139
mindset and we thought then can we

369
00:12:58,139 --> 00:12:59,880
control kind of Branch prediction using

370
00:12:59,880 --> 00:13:01,560
only user space history

371
00:13:01,560 --> 00:13:03,899
so we went back to our example of the

372
00:13:03,899 --> 00:13:05,399
Cisco identity score right in this case

373
00:13:05,399 --> 00:13:07,680
with the two generic ciscals and two

374
00:13:07,680 --> 00:13:10,079
generic contexts so what we did was we

375
00:13:10,079 --> 00:13:12,420
generated the jump chain in user space

376
00:13:12,420 --> 00:13:15,000
that we call context a and we followed

377
00:13:15,000 --> 00:13:16,740
this with the Cisco that is called Cisco

378
00:13:16,740 --> 00:13:17,700
a

379
00:13:17,700 --> 00:13:19,920
and this will generate the the entry in

380
00:13:19,920 --> 00:13:23,519
the btb to speculate The Cisco a and

381
00:13:23,519 --> 00:13:24,839
afterwards we do the same for Content

382
00:13:24,839 --> 00:13:26,880
experiences could be so two entries in

383
00:13:26,880 --> 00:13:29,579
the btb for Cisco a and Cisco B and

384
00:13:29,579 --> 00:13:31,440
finally we just mix and match two so we

385
00:13:31,440 --> 00:13:33,480
would have a context a but then we

386
00:13:33,480 --> 00:13:35,220
follow this with Cisco B so as you can

387
00:13:35,220 --> 00:13:37,500
see here the history is Cisco a but then

388
00:13:37,500 --> 00:13:38,399
eventually you actually want to perform

389
00:13:38,399 --> 00:13:40,800
Cisco d and this experiment can tell you

390
00:13:40,800 --> 00:13:42,839
if uh if orientation was correct and

391
00:13:42,839 --> 00:13:46,079
indeed we tested this and uh when you

392
00:13:46,079 --> 00:13:48,899
perform this uh history of context a

393
00:13:48,899 --> 00:13:50,639
followed by Cisco B What You observe is

394
00:13:50,639 --> 00:13:52,860
that it speculates the Cisco a so these

395
00:13:52,860 --> 00:13:54,959
the speculation is based on the context

396
00:13:54,959 --> 00:13:57,420
and the reason is again because the

397
00:13:57,420 --> 00:13:58,980
people think already seen this user

398
00:13:58,980 --> 00:14:01,980
history so I should speculate Cisco a

399
00:14:01,980 --> 00:14:03,959
now this is wrong clearly because you

400
00:14:03,959 --> 00:14:05,700
want to speculate The Cisco d

401
00:14:05,700 --> 00:14:06,959
but that's not a problem because

402
00:14:06,959 --> 00:14:09,300
eventually you execute against Cisco B

403
00:14:09,300 --> 00:14:11,519
so that's no big deal

404
00:14:11,519 --> 00:14:14,279
and we tested this on most modern Intel

405
00:14:14,279 --> 00:14:17,279
arm and disappears on MD uh clearly

406
00:14:17,279 --> 00:14:18,959
didn't work because uh they still rely

407
00:14:18,959 --> 00:14:21,720
on uh software defenses like Red Bull in

408
00:14:21,720 --> 00:14:23,880
the completely stop speculation but on

409
00:14:23,880 --> 00:14:25,560
all the internet CPUs will test that we

410
00:14:25,560 --> 00:14:26,820
tested we could observe perfect

411
00:14:26,820 --> 00:14:28,920
misprediction in this experiment

412
00:14:28,920 --> 00:14:30,420
so let's just try to understand what

413
00:14:30,420 --> 00:14:31,320
this means

414
00:14:31,320 --> 00:14:32,700
with this experiment we basically show

415
00:14:32,700 --> 00:14:34,860
that the user context can be used to Mr

416
00:14:34,860 --> 00:14:37,200
in calendar branches even the presence

417
00:14:37,200 --> 00:14:39,360
of these new hardware defenses

418
00:14:39,360 --> 00:14:41,160
and this is our new primitive that we

419
00:14:41,160 --> 00:14:43,019
call Branch history injection I know

420
00:14:43,019 --> 00:14:44,639
Rick is going to explain to you how we

421
00:14:44,639 --> 00:14:48,600
can use this to build a newer exploit

422
00:14:48,600 --> 00:14:49,920
all yours

423
00:14:49,920 --> 00:14:54,120
okay thanks Pedro so as Jasper said we

424
00:14:54,120 --> 00:14:55,980
have a very simple primitive right now

425
00:14:55,980 --> 00:14:58,620
we can control the branch prediction

426
00:14:58,620 --> 00:15:02,339
process of the kernel from user space

427
00:15:02,339 --> 00:15:05,820
injecting some history but as you can

428
00:15:05,820 --> 00:15:07,500
imagine we are still far away from

429
00:15:07,500 --> 00:15:09,720
building a full exploit

430
00:15:09,720 --> 00:15:11,639
and to reach that point we need to

431
00:15:11,639 --> 00:15:13,500
answer two questions

432
00:15:13,500 --> 00:15:16,680
the first one is which Target we can

433
00:15:16,680 --> 00:15:19,199
specifically be execute and by that I

434
00:15:19,199 --> 00:15:21,420
mean okay we can mispredict this in that

435
00:15:21,420 --> 00:15:24,019
branch in the kernel but where we can

436
00:15:24,019 --> 00:15:26,760
speculatively execute

437
00:15:26,760 --> 00:15:28,620
and similarly we need to answer the

438
00:15:28,620 --> 00:15:30,300
opposite question

439
00:15:30,300 --> 00:15:32,519
okay there are many data branches in the

440
00:15:32,519 --> 00:15:36,420
kernel which one we can mispredict

441
00:15:36,420 --> 00:15:40,620
and for doing so you have to perform the

442
00:15:40,620 --> 00:15:42,180
reverse engineering of the branch

443
00:15:42,180 --> 00:15:44,160
prediction unit so the Silicon inside of

444
00:15:44,160 --> 00:15:45,420
the CPU

445
00:15:45,420 --> 00:15:48,360
and usually a first step

446
00:15:48,360 --> 00:15:50,639
is to have a look at the patents that

447
00:15:50,639 --> 00:15:52,920
you can find online however we were

448
00:15:52,920 --> 00:15:56,399
quite unlucky on these aspects so we

449
00:15:56,399 --> 00:15:59,459
didn't find anything useful

450
00:15:59,459 --> 00:16:01,440
so we started doing the let's say

451
00:16:01,440 --> 00:16:03,240
classical reverse engineering of the

452
00:16:03,240 --> 00:16:03,959
hardware

453
00:16:03,959 --> 00:16:06,899
and you can do this by simply performing

454
00:16:06,899 --> 00:16:08,459
some Specific Instructions some

455
00:16:08,459 --> 00:16:10,860
experiment and observing the performance

456
00:16:10,860 --> 00:16:13,860
of the CPU depending on your input of

457
00:16:13,860 --> 00:16:15,120
the experiment

458
00:16:15,120 --> 00:16:17,639
we started very well finding some nice

459
00:16:17,639 --> 00:16:20,399
pattern in the in the hardware but

460
00:16:20,399 --> 00:16:23,459
eventually we failed mainly because the

461
00:16:23,459 --> 00:16:25,680
other is becoming so complex that

462
00:16:25,680 --> 00:16:28,620
reversing them is very difficult

463
00:16:28,620 --> 00:16:31,920
so after two months we decided to stop

464
00:16:31,920 --> 00:16:34,620
this approach because it was very hard

465
00:16:34,620 --> 00:16:36,720
to understand the details of the branch

466
00:16:36,720 --> 00:16:39,180
prediction unit

467
00:16:39,180 --> 00:16:40,920
and we fight with these two approach

468
00:16:40,920 --> 00:16:43,259
what is left our good old friend good

469
00:16:43,259 --> 00:16:45,199
Force

470
00:16:45,199 --> 00:16:47,579
let's make a small step back to

471
00:16:47,579 --> 00:16:49,380
understand why the Brute Force approach

472
00:16:49,380 --> 00:16:50,639
here works

473
00:16:50,639 --> 00:16:53,639
so again as an attacker we only control

474
00:16:53,639 --> 00:16:55,860
the history okay this is the only uh

475
00:16:55,860 --> 00:16:58,019
let's say injection point we have

476
00:16:58,019 --> 00:17:01,740
and if you if you look back at the

477
00:17:01,740 --> 00:17:03,300
possible implementation of a branch

478
00:17:03,300 --> 00:17:04,559
prediction unit

479
00:17:04,559 --> 00:17:07,020
uh we only control the parts that are

480
00:17:07,020 --> 00:17:09,419
lighted in the red so the history or

481
00:17:09,419 --> 00:17:11,939
basically the content of the registry

482
00:17:11,939 --> 00:17:14,339
buffer it is this register containing a

483
00:17:14,339 --> 00:17:17,939
snapshot of the recent execution

484
00:17:17,939 --> 00:17:21,419
so what if we randomize these bits and

485
00:17:21,419 --> 00:17:22,919
let's see what happens

486
00:17:22,919 --> 00:17:25,439
to do so we can build a very simple

487
00:17:25,439 --> 00:17:26,760
experiment

488
00:17:26,760 --> 00:17:29,640
so as you can see here on the left we

489
00:17:29,640 --> 00:17:33,780
have a jump chain that is a simple trick

490
00:17:33,780 --> 00:17:37,080
for us to generate an history so you can

491
00:17:37,080 --> 00:17:39,059
see from the address lead Cafe we are

492
00:17:39,059 --> 00:17:40,919
jumping to the beef from the beef to the

493
00:17:40,919 --> 00:17:43,860
lukak and so on here the idea is that we

494
00:17:43,860 --> 00:17:45,480
are generating generating a specific

495
00:17:45,480 --> 00:17:46,440
history

496
00:17:46,440 --> 00:17:48,780
and after this we are going to an

497
00:17:48,780 --> 00:17:51,480
indirect Branch it will always land to

498
00:17:51,480 --> 00:17:54,720
Target a the idea here is to associate

499
00:17:54,720 --> 00:17:57,539
history a with Target a so every time

500
00:17:57,539 --> 00:17:59,039
the branch prediction unit will see

501
00:17:59,039 --> 00:18:01,440
history a it will say ha it's a good

502
00:18:01,440 --> 00:18:04,080
idea to jump to Target a

503
00:18:04,080 --> 00:18:07,080
so then we generate a random history

504
00:18:07,080 --> 00:18:09,480
that is history B

505
00:18:09,480 --> 00:18:11,820
and again this history should always

506
00:18:11,820 --> 00:18:14,280
jump to Target B so as you can see here

507
00:18:14,280 --> 00:18:17,160
our goal was to associate Target a with

508
00:18:17,160 --> 00:18:20,280
history a and target b with history B

509
00:18:20,280 --> 00:18:23,340
and if we execute these two called path

510
00:18:23,340 --> 00:18:25,919
in an alternate fashion we observe a

511
00:18:25,919 --> 00:18:29,160
Norway's code prediction from the BPO

512
00:18:29,160 --> 00:18:32,220
and this is expected because we are

513
00:18:32,220 --> 00:18:33,780
giving let's see the golden scenario to

514
00:18:33,780 --> 00:18:34,860
the trans prediction need to perform

515
00:18:34,860 --> 00:18:36,539
accurate prediction

516
00:18:36,539 --> 00:18:39,720
but what if we keep the left call part

517
00:18:39,720 --> 00:18:42,419
constant and we randomize the right one

518
00:18:42,419 --> 00:18:45,919
eventually what you serve was a 100

519
00:18:45,919 --> 00:18:49,559
misprediction rate so in other words in

520
00:18:49,559 --> 00:18:51,179
the Silicon CPU

521
00:18:51,179 --> 00:18:54,000
uh the Press prediction prediction unit

522
00:18:54,000 --> 00:18:55,799
wasn't unable to distinguish history

523
00:18:55,799 --> 00:18:58,140
from history B so you can clearly see

524
00:18:58,140 --> 00:18:59,640
the values are different

525
00:18:59,640 --> 00:19:02,340
but since they are harsh in a single

526
00:19:02,340 --> 00:19:04,380
register they will collide to the same

527
00:19:04,380 --> 00:19:06,780
value and from the perspective of the

528
00:19:06,780 --> 00:19:09,539
CPU they are identical so that's why is

529
00:19:09,539 --> 00:19:11,760
always performing its prediction

530
00:19:11,760 --> 00:19:14,220
and for us as an attacker this is

531
00:19:14,220 --> 00:19:17,039
perfect because just by controlling

532
00:19:17,039 --> 00:19:19,440
history B we can accurately perform this

533
00:19:19,440 --> 00:19:23,419
prediction to the Target we want

534
00:19:23,820 --> 00:19:26,940
and let's do a small last experiment

535
00:19:26,940 --> 00:19:30,299
let's completely separately two called

536
00:19:30,299 --> 00:19:32,760
paths so we don't have any more uh

537
00:19:32,760 --> 00:19:34,200
single in the other Branch we have two

538
00:19:34,200 --> 00:19:35,340
of them

539
00:19:35,340 --> 00:19:37,200
and as you can see from yesterday we

540
00:19:37,200 --> 00:19:39,600
always jump to Target a history B Target

541
00:19:39,600 --> 00:19:41,039
B

542
00:19:41,039 --> 00:19:43,140
and here also surprisingly by

543
00:19:43,140 --> 00:19:46,200
randomizing the history B we even

544
00:19:46,200 --> 00:19:49,039
managed to find a case of speculation

545
00:19:49,039 --> 00:19:52,559
from the entire Branch b to Target a if

546
00:19:52,559 --> 00:19:53,940
you think about this is very weird

547
00:19:53,940 --> 00:19:56,700
because that code path never execute

548
00:19:56,700 --> 00:19:59,940
never jumped to Target a so this probe

549
00:19:59,940 --> 00:20:00,900
actually

550
00:20:00,900 --> 00:20:02,460
that the bench prediction unit wasn't

551
00:20:02,460 --> 00:20:04,260
enabled not only to distinguish history

552
00:20:04,260 --> 00:20:06,840
from history B but wasn't even able to

553
00:20:06,840 --> 00:20:09,240
distinguish the different call side

554
00:20:09,240 --> 00:20:11,640
and this as an attacker is an amazing

555
00:20:11,640 --> 00:20:14,640
primitive because now you can mispredict

556
00:20:14,640 --> 00:20:16,860
any other branch and speculate whenever

557
00:20:16,860 --> 00:20:19,799
you want is like total freedom to do

558
00:20:19,799 --> 00:20:22,080
whatever you want

559
00:20:22,080 --> 00:20:24,419
and now you may ask okay Brute Force

560
00:20:24,419 --> 00:20:26,700
approach easy but probably is going to

561
00:20:26,700 --> 00:20:28,980
be super slow right well

562
00:20:28,980 --> 00:20:33,200
not for not not really for us was

563
00:20:33,200 --> 00:20:35,640
we're very lucky it was very fast to

564
00:20:35,640 --> 00:20:37,620
perform the good Force approach

565
00:20:37,620 --> 00:20:40,620
maybe just to give you some number

566
00:20:40,620 --> 00:20:42,179
so you can see here this is for the

567
00:20:42,179 --> 00:20:45,900
Intel 10 gen if you have if you try 40

568
00:20:45,900 --> 00:20:48,419
000 times you are almost sure to find

569
00:20:48,419 --> 00:20:51,419
this colliding history to do the

570
00:20:51,419 --> 00:20:53,340
misprediction if you want

571
00:20:53,340 --> 00:20:55,380
and we tried also many other

572
00:20:55,380 --> 00:20:57,059
architectures and as you can see the

573
00:20:57,059 --> 00:20:59,340
entropy is very small I mean the maximum

574
00:20:59,340 --> 00:21:02,220
was 17 bits that you can break in less

575
00:21:02,220 --> 00:21:04,080
than one minute and a few seconds are

576
00:21:04,080 --> 00:21:06,120
enough usually

577
00:21:06,120 --> 00:21:08,640
okay let's make a smaller recap to

578
00:21:08,640 --> 00:21:10,260
understand

579
00:21:10,260 --> 00:21:12,299
what is our primitive now

580
00:21:12,299 --> 00:21:14,640
so our goal is to mispredict an entire

581
00:21:14,640 --> 00:21:16,679
branch in the kernel

582
00:21:16,679 --> 00:21:18,960
and let's say this entire branch in the

583
00:21:18,960 --> 00:21:21,660
kernel architecturally can only jump to

584
00:21:21,660 --> 00:21:24,419
True Value Targets target a and target b

585
00:21:24,419 --> 00:21:26,640
and again we are considering system

586
00:21:26,640 --> 00:21:28,919
without your defenses so we can no

587
00:21:28,919 --> 00:21:30,840
longer speculate on user provided

588
00:21:30,840 --> 00:21:32,760
function

589
00:21:32,760 --> 00:21:34,799
as an attacker we have very limited

590
00:21:34,799 --> 00:21:37,020
control just the previous instruction

591
00:21:37,020 --> 00:21:39,179
before the Cisco instruction

592
00:21:39,179 --> 00:21:41,100
so we control only the history before

593
00:21:41,100 --> 00:21:43,620
performing the most rich from user to

594
00:21:43,620 --> 00:21:45,480
current space

595
00:21:45,480 --> 00:21:48,600
and as we demonstrated on Intel and arm

596
00:21:48,600 --> 00:21:50,760
CPUs you can

597
00:21:50,760 --> 00:21:53,520
speculated to the valid Targets in a

598
00:21:53,520 --> 00:21:55,620
very precise way again just by

599
00:21:55,620 --> 00:21:56,940
controlling the history

600
00:21:56,940 --> 00:21:59,580
but the best comes for intra processor

601
00:21:59,580 --> 00:22:01,159
where you can actually speculate

602
00:22:01,159 --> 00:22:03,539
whatever you want

603
00:22:03,539 --> 00:22:05,400
and

604
00:22:05,400 --> 00:22:08,460
this was quite powerful because you

605
00:22:08,460 --> 00:22:11,159
really enlarge your attack surface

606
00:22:11,159 --> 00:22:13,200
and to give you some numbers in the

607
00:22:13,200 --> 00:22:16,440
Intel 11 gen for example the context of

608
00:22:16,440 --> 00:22:19,020
the history is composed by the latest 67

609
00:22:19,020 --> 00:22:21,000
taken branches

610
00:22:21,000 --> 00:22:22,919
and as an attacker we only need to

611
00:22:22,919 --> 00:22:26,280
control eight of them so we can even

612
00:22:26,280 --> 00:22:28,799
attack very deep nested in that branch

613
00:22:28,799 --> 00:22:31,200
in the kernel

614
00:22:31,200 --> 00:22:34,320
okay let's switch to exploitation so we

615
00:22:34,320 --> 00:22:36,179
have our nice primitive how can we do

616
00:22:36,179 --> 00:22:38,100
something interesting with it

617
00:22:38,100 --> 00:22:40,740
to show the main idea let's have a look

618
00:22:40,740 --> 00:22:42,059
and attack plan

619
00:22:42,059 --> 00:22:44,220
so the first step is to ensure that our

620
00:22:44,220 --> 00:22:47,220
Gadget or our code we want to execute

621
00:22:47,220 --> 00:22:49,799
in the transient domain is present in

622
00:22:49,799 --> 00:22:52,200
the branch Target buffer and for doing

623
00:22:52,200 --> 00:22:54,840
so you just need to you know execute

624
00:22:54,840 --> 00:22:58,140
that function code and ensure WTB is is

625
00:22:58,140 --> 00:23:00,120
filled with the value we want to to

626
00:23:00,120 --> 00:23:01,500
speculate on

627
00:23:01,500 --> 00:23:03,659
then later we do what we saw before

628
00:23:03,659 --> 00:23:06,360
simply we generate a random mystery we

629
00:23:06,360 --> 00:23:09,960
perform a Cisco any Cisco will be will

630
00:23:09,960 --> 00:23:11,280
be fine

631
00:23:11,280 --> 00:23:12,960
and then what happens as soon as we

632
00:23:12,960 --> 00:23:14,580
enter the counter space

633
00:23:14,580 --> 00:23:16,559
the balance prediction unit will say oh

634
00:23:16,559 --> 00:23:18,539
I don't know where it should jump let's

635
00:23:18,539 --> 00:23:20,520
have a look at the recent execution so

636
00:23:20,520 --> 00:23:22,919
the history from the user space will

637
00:23:22,919 --> 00:23:24,780
generate a tag

638
00:23:24,780 --> 00:23:26,460
and let's say the first time we are

639
00:23:26,460 --> 00:23:28,559
unlucky the tag is not the one we want

640
00:23:28,559 --> 00:23:31,620
no problem we are going to jump to get

641
00:23:31,620 --> 00:23:32,520
paid

642
00:23:32,520 --> 00:23:35,159
no problem we can repeat the process

643
00:23:35,159 --> 00:23:37,799
until we win so we ensure again the

644
00:23:37,799 --> 00:23:40,200
league Gadget is in the vtb we randomize

645
00:23:40,200 --> 00:23:42,240
the history again another attack will be

646
00:23:42,240 --> 00:23:45,059
computed and so on until eventually we

647
00:23:45,059 --> 00:23:47,460
are lucky we break the let's say the

648
00:23:47,460 --> 00:23:51,740
entropy and we generate this exact same

649
00:23:51,740 --> 00:23:55,320
btb tag and this will basically allow us

650
00:23:55,320 --> 00:23:57,240
to speculate on the function we wanted

651
00:23:57,240 --> 00:23:59,600
to

652
00:23:59,820 --> 00:24:02,220
okay now you may ask but why we are

653
00:24:02,220 --> 00:24:03,600
always talking about this Cisco table

654
00:24:03,600 --> 00:24:05,460
land I mean there are many data branches

655
00:24:05,460 --> 00:24:07,380
in the canal why we are so focused on

656
00:24:07,380 --> 00:24:10,320
that one well the main reason is that

657
00:24:10,320 --> 00:24:12,419
you can very easily execute that entire

658
00:24:12,419 --> 00:24:14,940
Branch any c-school will trigger it but

659
00:24:14,940 --> 00:24:18,360
actually the best part of it is that the

660
00:24:18,360 --> 00:24:20,820
the first argument of data of this is

661
00:24:20,820 --> 00:24:22,260
called table Handler

662
00:24:22,260 --> 00:24:25,860
is that is pointing to all the user

663
00:24:25,860 --> 00:24:28,260
space save the register so as an

664
00:24:28,260 --> 00:24:30,840
attacker we have a lot of control

665
00:24:30,840 --> 00:24:33,240
of the the memory and the register that

666
00:24:33,240 --> 00:24:34,080
we

667
00:24:34,080 --> 00:24:36,960
we we can use for finding a specter

668
00:24:36,960 --> 00:24:39,320
Gadget

669
00:24:40,100 --> 00:24:43,500
then the biggest challenge

670
00:24:43,500 --> 00:24:45,960
is to find a gadget so as you can

671
00:24:45,960 --> 00:24:48,179
imagine the kernel binary is huge so

672
00:24:48,179 --> 00:24:50,940
finding the few instructions we need to

673
00:24:50,940 --> 00:24:53,700
leave address in the cache is uh you

674
00:24:53,700 --> 00:24:56,220
should be able to find it uh it's a very

675
00:24:56,220 --> 00:24:58,740
tedious work it requires a lot of time

676
00:24:58,740 --> 00:25:00,600
so since we use a Brute Force approach

677
00:25:00,600 --> 00:25:04,140
why it's not why we should also here

678
00:25:04,140 --> 00:25:07,100
choose the lazy way you know

679
00:25:07,100 --> 00:25:08,940
so

680
00:25:08,940 --> 00:25:10,740
at the time where we were doing the

681
00:25:10,740 --> 00:25:12,659
project there was this nice feature

682
00:25:12,659 --> 00:25:14,820
named and privileged dbpf

683
00:25:14,820 --> 00:25:17,159
that International for us is a Jitter

684
00:25:17,159 --> 00:25:19,020
engine in the kernel that I'm privileged

685
00:25:19,020 --> 00:25:21,840
user can can use yeah it's a bit strange

686
00:25:21,840 --> 00:25:24,480
I mean you can literally com cheat code

687
00:25:24,480 --> 00:25:26,700
in the Canon from an employee's user so

688
00:25:26,700 --> 00:25:29,220
and for us this is amazing because you

689
00:25:29,220 --> 00:25:32,400
just need to find the correct uh BPF BPF

690
00:25:32,400 --> 00:25:35,220
call opcode to jit in a kernel the

691
00:25:35,220 --> 00:25:37,380
perfect leak Gadget directly in the

692
00:25:37,380 --> 00:25:42,419
kernel so this was very helpful for us

693
00:25:42,419 --> 00:25:44,580
but now you may ask but wait a second so

694
00:25:44,580 --> 00:25:47,400
the Canon developer allowed you to

695
00:25:47,400 --> 00:25:49,919
inject spectral Gadget in the canon in

696
00:25:49,919 --> 00:25:52,760
this sounds unsafe I mean for sure the

697
00:25:52,760 --> 00:25:55,440
proposal mitigation against this

698
00:25:55,440 --> 00:25:58,380
that's correct UPF is full of mitigation

699
00:25:58,380 --> 00:26:01,080
against Spectra but on variant one and

700
00:26:01,080 --> 00:26:02,580
now you'll see why

701
00:26:02,580 --> 00:26:03,919
so

702
00:26:03,919 --> 00:26:08,340
ebpf again is just a tool where you can

703
00:26:08,340 --> 00:26:10,679
write some it's a packet filter

704
00:26:10,679 --> 00:26:12,779
for incoming packets

705
00:26:12,779 --> 00:26:15,000
and architecturally is doing something

706
00:26:15,000 --> 00:26:19,260
very uh safe so whenever we receive a

707
00:26:19,260 --> 00:26:21,000
packet we are accessing for example the

708
00:26:21,000 --> 00:26:23,700
mark attribute and depending on data

709
00:26:23,700 --> 00:26:25,500
attribute we are accessing

710
00:26:25,500 --> 00:26:28,740
another array everything is inbound and

711
00:26:28,740 --> 00:26:32,039
even in the speculative domain

712
00:26:32,039 --> 00:26:34,380
there is no exploitation possible

713
00:26:34,380 --> 00:26:37,140
over here thanks to the variant 2 of

714
00:26:37,140 --> 00:26:39,720
Spectra we are no more coming from the

715
00:26:39,720 --> 00:26:42,600
ebpf dispatcher we are coming from the

716
00:26:42,600 --> 00:26:44,220
Cisco Handler

717
00:26:44,220 --> 00:26:46,980
so now there is no more pocket literally

718
00:26:46,980 --> 00:26:49,380
there is a Transit type confusion going

719
00:26:49,380 --> 00:26:52,080
on and we are not accessing the mark

720
00:26:52,080 --> 00:26:55,020
attribute but but we are referencing the

721
00:26:55,020 --> 00:26:56,400
register 12

722
00:26:56,400 --> 00:26:57,900
so literally

723
00:26:57,900 --> 00:26:59,940
we are referencing arbitrary memory

724
00:26:59,940 --> 00:27:01,919
others in the kernel and then leaving

725
00:27:01,919 --> 00:27:04,520
address in the cache that later we can

726
00:27:04,520 --> 00:27:09,059
use to recover the liquid data

727
00:27:09,059 --> 00:27:11,820
and here inside is that translated

728
00:27:11,820 --> 00:27:14,640
confusion or basically Spectra variant

729
00:27:14,640 --> 00:27:15,360
two

730
00:27:15,360 --> 00:27:17,820
really helps you to bypass Spectrum

731
00:27:17,820 --> 00:27:20,100
mitigation

732
00:27:20,100 --> 00:27:23,100
one last missing component is that we

733
00:27:23,100 --> 00:27:25,500
need a precise timer to distinguish

734
00:27:25,500 --> 00:27:29,279
cachit or kashmirs and again our beloved

735
00:27:29,279 --> 00:27:31,980
friendly DPF is so kind to provide it to

736
00:27:31,980 --> 00:27:35,580
us uh uh so yeah we have everything to

737
00:27:35,580 --> 00:27:38,039
to build our exploit now

738
00:27:38,039 --> 00:27:41,340
and let's try a live demo

739
00:27:41,340 --> 00:27:43,820
so you can imagine running a

740
00:27:43,820 --> 00:27:46,559
micro catalog tax life is not a good

741
00:27:46,559 --> 00:27:49,200
idea but we are going to try anyway

742
00:27:49,200 --> 00:27:51,240
so here I'm connected to a machine that

743
00:27:51,240 --> 00:27:53,220
is vulnerable it is an Intel

744
00:27:53,220 --> 00:27:55,020
the engine CPU

745
00:27:55,020 --> 00:27:57,600
and as you can see we have a updated

746
00:27:57,600 --> 00:28:00,360
kernel and if you check the mitigation

747
00:28:00,360 --> 00:28:03,600
we can see is vulnerable because we have

748
00:28:03,600 --> 00:28:05,580
available the system they are aware of

749
00:28:05,580 --> 00:28:07,320
this attack

750
00:28:07,320 --> 00:28:09,419
so we start by building an eviction set

751
00:28:09,419 --> 00:28:11,159
to ensure that the branch prediction

752
00:28:11,159 --> 00:28:13,799
unit will give us a larger speculative

753
00:28:13,799 --> 00:28:15,299
window

754
00:28:15,299 --> 00:28:18,059
and after this is complete Oh wow was

755
00:28:18,059 --> 00:28:20,220
very fast so we are trying to find the

756
00:28:20,220 --> 00:28:21,960
colliding history you see zero seconds

757
00:28:21,960 --> 00:28:23,179
required

758
00:28:23,179 --> 00:28:25,260
and now we are already looking current

759
00:28:25,260 --> 00:28:28,620
memory so the first step is to break SLR

760
00:28:28,620 --> 00:28:31,679
because we need to you know read only a

761
00:28:31,679 --> 00:28:34,080
meaningful part of the kernel and now we

762
00:28:34,080 --> 00:28:36,539
already linearly sweeping the kernel

763
00:28:36,539 --> 00:28:38,820
memory looking for something interesting

764
00:28:38,820 --> 00:28:43,020
and here we decided to look for the ATC

765
00:28:43,020 --> 00:28:46,500
Shadow root password

766
00:28:46,500 --> 00:28:51,620
usually take a moment and let's see

767
00:28:51,779 --> 00:28:55,559
okay here we are so you can see in 30

768
00:28:55,559 --> 00:28:58,700
second knife

769
00:29:02,400 --> 00:29:04,919
and to prove is actually the correct

770
00:29:04,919 --> 00:29:08,460
password as root let's print it and it

771
00:29:08,460 --> 00:29:11,840
matches perfectly nice

772
00:29:12,480 --> 00:29:16,500
okay nice first time

773
00:29:16,500 --> 00:29:18,240
okay let's quickly conclude with the

774
00:29:18,240 --> 00:29:20,220
vendor response and mitigation

775
00:29:20,220 --> 00:29:24,360
uh there are many fatal CPUs but uh to

776
00:29:24,360 --> 00:29:26,580
summarize every Intel CPU starting from

777
00:29:26,580 --> 00:29:29,940
the tangent is affected so any new CPU

778
00:29:29,940 --> 00:29:31,980
parameter is uh is affected

779
00:29:31,980 --> 00:29:34,140
and regarding Arma is a bit more

780
00:29:34,140 --> 00:29:36,059
complicated but in a nutshell

781
00:29:36,059 --> 00:29:38,940
every let's say CPU from the latest two

782
00:29:38,940 --> 00:29:40,620
years with a branch prediction unit

783
00:29:40,620 --> 00:29:43,860
should be affected

784
00:29:43,860 --> 00:29:45,419
what about the mitigation proposed

785
00:29:45,419 --> 00:29:46,980
proposed by the vendors

786
00:29:46,980 --> 00:29:50,640
so Intel proposed mainly one single

787
00:29:50,640 --> 00:29:52,799
defense that is to disable and

788
00:29:52,799 --> 00:29:55,200
privileged eppf that is this jet engine

789
00:29:55,200 --> 00:29:58,500
in the kernel if you think about is not

790
00:29:58,500 --> 00:29:59,880
an ideal solution because you are

791
00:29:59,880 --> 00:30:01,860
removing a nice tool for his

792
00:30:01,860 --> 00:30:03,960
exploitation but the bug is still there

793
00:30:03,960 --> 00:30:06,659
and it's not going to disappear soon

794
00:30:06,659 --> 00:30:08,580
they are promising also some software

795
00:30:08,580 --> 00:30:10,620
and Hardware mitigation that are mainly

796
00:30:10,620 --> 00:30:12,059
doing the same thing

797
00:30:12,059 --> 00:30:13,919
on a mod switch

798
00:30:13,919 --> 00:30:16,440
for example from user to Kernel they are

799
00:30:16,440 --> 00:30:19,020
clearing this Branch history buffer so

800
00:30:19,020 --> 00:30:21,299
that during the prediction process the

801
00:30:21,299 --> 00:30:23,880
user history is no more used in the

802
00:30:23,880 --> 00:30:25,679
prediction process

803
00:30:25,679 --> 00:30:28,580
and harm did exactly the same

804
00:30:28,580 --> 00:30:30,899
slightly different again softer and

805
00:30:30,899 --> 00:30:33,059
other mitigation with the goal of

806
00:30:33,059 --> 00:30:36,120
clearing this Branch history buffer

807
00:30:36,120 --> 00:30:39,419
and MD as we said from the beginning is

808
00:30:39,419 --> 00:30:41,159
not affected because they are still

809
00:30:41,159 --> 00:30:43,320
relying on a software mitigation

810
00:30:43,320 --> 00:30:45,240
so uh

811
00:30:45,240 --> 00:30:46,860
they say by keeping a software

812
00:30:46,860 --> 00:30:49,640
mitigation they are safe by not you know

813
00:30:49,640 --> 00:30:51,539
choosing a faster than Hardware

814
00:30:51,539 --> 00:30:53,159
mitigation

815
00:30:53,159 --> 00:30:56,279
well actually the same day we released

816
00:30:56,279 --> 00:30:59,220
our paper Intel proved that the AMD

817
00:30:59,220 --> 00:31:01,620
defense was broken so

818
00:31:01,620 --> 00:31:04,200
few months ago at the same time Intel

819
00:31:04,200 --> 00:31:06,120
arm and MD were still affected by

820
00:31:06,120 --> 00:31:08,760
specter valentio three years later the

821
00:31:08,760 --> 00:31:11,399
discovery of it and yeah was not that

822
00:31:11,399 --> 00:31:13,200
great

823
00:31:13,200 --> 00:31:15,299
to conclude

824
00:31:15,299 --> 00:31:17,580
together we saw that the attack surface

825
00:31:17,580 --> 00:31:19,679
of these attacks is too wide to Define

826
00:31:19,679 --> 00:31:21,419
it's very difficult

827
00:31:21,419 --> 00:31:24,000
even for us and the CPU manufacturer to

828
00:31:24,000 --> 00:31:26,580
guarantee you are safe against this this

829
00:31:26,580 --> 00:31:28,260
threat

830
00:31:28,260 --> 00:31:30,299
and we do believe that we need more

831
00:31:30,299 --> 00:31:32,159
principal defenses because

832
00:31:32,159 --> 00:31:35,159
even after our attack they release top

833
00:31:35,159 --> 00:31:37,799
Gap defenses like you know disabling a

834
00:31:37,799 --> 00:31:40,140
BPF yeah it's a good idea

835
00:31:40,140 --> 00:31:42,299
but you know the bug is still there

836
00:31:42,299 --> 00:31:45,179
maybe someday another research will find

837
00:31:45,179 --> 00:31:47,220
another Gadget and you know we are

838
00:31:47,220 --> 00:31:49,559
starting from zero again

839
00:31:49,559 --> 00:31:51,960
but to conclude on a positive note uh

840
00:31:51,960 --> 00:31:53,159
positive note

841
00:31:53,159 --> 00:31:55,919
uh during this project we really noticed

842
00:31:55,919 --> 00:31:57,840
or is becoming harder to build such

843
00:31:57,840 --> 00:31:59,179
exploit

844
00:31:59,179 --> 00:32:01,860
and we can make a comparison with

845
00:32:01,860 --> 00:32:03,240
software exploitation

846
00:32:03,240 --> 00:32:06,779
20 years ago writing a buffer overflow

847
00:32:06,779 --> 00:32:09,840
exploit I guess was much easier today is

848
00:32:09,840 --> 00:32:12,600
with SLR canaries and so on you know

849
00:32:12,600 --> 00:32:15,539
it's becoming way harder

850
00:32:15,539 --> 00:32:18,779
that was a that was our talk a little

851
00:32:18,779 --> 00:32:20,760
dirt history

852
00:32:20,760 --> 00:32:23,640
here you can find our project page if

853
00:32:23,640 --> 00:32:25,500
you want more details with the paper and

854
00:32:25,500 --> 00:32:27,600
also the source code for the exploit you

855
00:32:27,600 --> 00:32:29,840
just saw

856
00:32:29,840 --> 00:32:32,949
[Music]

857
00:32:36,810 --> 00:32:39,899
[Music]

