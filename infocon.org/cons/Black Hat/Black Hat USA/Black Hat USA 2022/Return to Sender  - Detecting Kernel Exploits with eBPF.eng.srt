1
00:00:01,730 --> 00:00:04,810
[Music]

2
00:00:08,360 --> 00:00:11,160
good afternoon everyone welcome and

3
00:00:11,160 --> 00:00:12,599
thanks for joining this talk about

4
00:00:12,599 --> 00:00:15,839
detecting kernel exploits with evpf

5
00:00:15,839 --> 00:00:17,640
my name is Guillen Fournier I'm a

6
00:00:17,640 --> 00:00:19,619
security you know security engineer at

7
00:00:19,619 --> 00:00:22,199
data dog and I work with the cloud

8
00:00:22,199 --> 00:00:25,019
workload security team so CWS leverages

9
00:00:25,019 --> 00:00:27,420
the BPF to detect threats at runtime in

10
00:00:27,420 --> 00:00:29,820
user space and everything we do is

11
00:00:29,820 --> 00:00:31,980
embedded into the data log agent what

12
00:00:31,980 --> 00:00:33,660
this means is if you are a client of

13
00:00:33,660 --> 00:00:35,760
datadog and you want to try out CWS all

14
00:00:35,760 --> 00:00:37,440
you have to do is update the data

15
00:00:37,440 --> 00:00:39,660
location config

16
00:00:39,660 --> 00:00:41,460
all right so let's go through the agenda

17
00:00:41,460 --> 00:00:42,840
for today

18
00:00:42,840 --> 00:00:44,280
um first I'm gonna give you a bit of

19
00:00:44,280 --> 00:00:46,800
context about what this talk is about

20
00:00:46,800 --> 00:00:48,360
um then we'll go over the thread models

21
00:00:48,360 --> 00:00:50,460
that we are going to try to address

22
00:00:50,460 --> 00:00:52,559
uh after that I'm going to present uh

23
00:00:52,559 --> 00:00:54,000
sorry I'm going to first talk about why

24
00:00:54,000 --> 00:00:55,680
BPF so it's like probably one of the

25
00:00:55,680 --> 00:00:57,719
main questions of this talk uh why use

26
00:00:57,719 --> 00:00:59,039
this technology to do this kind of

27
00:00:59,039 --> 00:01:00,480
detections

28
00:01:00,480 --> 00:01:02,039
um then I'm going to talk about cry so

29
00:01:02,039 --> 00:01:04,199
cry is an open source project that I

30
00:01:04,199 --> 00:01:05,640
will be releasing today

31
00:01:05,640 --> 00:01:07,560
so we're gonna you know we go down the

32
00:01:07,560 --> 00:01:09,360
the list of features that cry has to

33
00:01:09,360 --> 00:01:11,280
offer and finally we're going to talk

34
00:01:11,280 --> 00:01:13,560
about performance and what you you know

35
00:01:13,560 --> 00:01:15,780
what overhead uh you need to expect if

36
00:01:15,780 --> 00:01:17,580
you were to deploy cry in a real world

37
00:01:17,580 --> 00:01:20,000
environment

38
00:01:20,220 --> 00:01:22,799
all right so um I'm pretty sure it will

39
00:01:22,799 --> 00:01:24,540
come as absolutely no surprise when I

40
00:01:24,540 --> 00:01:26,580
say that uh critical cities are

41
00:01:26,580 --> 00:01:28,619
regularly discovered in the Linux kernel

42
00:01:28,619 --> 00:01:30,600
so it has nothing to do with Linux it's

43
00:01:30,600 --> 00:01:32,340
just like you know perfectly normal in

44
00:01:32,340 --> 00:01:34,500
the life cycle of a software that is

45
00:01:34,500 --> 00:01:36,659
constantly being updated and that has

46
00:01:36,659 --> 00:01:39,060
thousands of uh you know users in the

47
00:01:39,060 --> 00:01:40,259
entire world

48
00:01:40,259 --> 00:01:41,820
um but the thing is because of this

49
00:01:41,820 --> 00:01:43,920
security admins worry about keeping up

50
00:01:43,920 --> 00:01:46,320
with you know security updates uh

51
00:01:46,320 --> 00:01:48,540
deploying those Secret Patches and if

52
00:01:48,540 --> 00:01:51,299
anyone here has had to deal with the

53
00:01:51,299 --> 00:01:52,920
dirty pipes variability you will

54
00:01:52,920 --> 00:01:54,780
definitely know what I'm talking about a

55
00:01:54,780 --> 00:01:56,820
grading kernel in the entire fleet of

56
00:01:56,820 --> 00:01:58,799
your infrastructure takes weeks if not

57
00:01:58,799 --> 00:02:01,500
months and in the meantime well you

58
00:02:01,500 --> 00:02:03,180
don't have any you know you don't have

59
00:02:03,180 --> 00:02:04,680
anything to protect yourself

60
00:02:04,680 --> 00:02:06,299
um so basically security admins worry

61
00:02:06,299 --> 00:02:08,280
about monitoring and protecting uh

62
00:02:08,280 --> 00:02:10,020
vulnerable hosts and so they can

63
00:02:10,020 --> 00:02:11,879
actually defy the upgrade and this is

64
00:02:11,879 --> 00:02:13,440
exactly what this talk is about and

65
00:02:13,440 --> 00:02:17,000
exactly what cry tries to address

66
00:02:17,819 --> 00:02:19,140
um there are technically hundreds of

67
00:02:19,140 --> 00:02:21,720
ways to exploit the Linux kernel and

68
00:02:21,720 --> 00:02:23,940
this still targets just three types of

69
00:02:23,940 --> 00:02:25,319
vulnerabilities

70
00:02:25,319 --> 00:02:26,819
um so the first one is let's say that

71
00:02:26,819 --> 00:02:29,160
another query is able to redirect the

72
00:02:29,160 --> 00:02:31,319
execution flow within the comma

73
00:02:31,319 --> 00:02:33,660
um another one is logic bugs so you know

74
00:02:33,660 --> 00:02:35,040
another query is able to perform

75
00:02:35,040 --> 00:02:37,080
something that is what that is not he's

76
00:02:37,080 --> 00:02:39,120
not supposed to do because you know

77
00:02:39,120 --> 00:02:41,580
developers made a mistake somewhere and

78
00:02:41,580 --> 00:02:43,200
um you know the proper Access Control

79
00:02:43,200 --> 00:02:45,120
could not be called and the operation

80
00:02:45,120 --> 00:02:47,099
was actually actually Allowed by the

81
00:02:47,099 --> 00:02:48,180
criminal even though it shouldn't have

82
00:02:48,180 --> 00:02:49,019
been

83
00:02:49,019 --> 00:02:50,940
and the last one is first compromise

84
00:02:50,940 --> 00:02:53,459
kernel runtime iterations so once an

85
00:02:53,459 --> 00:02:54,959
attacker successfully exploited your

86
00:02:54,959 --> 00:02:57,660
kernel they are likely to try to you

87
00:02:57,660 --> 00:02:59,220
know alter the commons so that they can

88
00:02:59,220 --> 00:03:01,140
hide their tracks and further

89
00:03:01,140 --> 00:03:02,640
um you know compromise the the services

90
00:03:02,640 --> 00:03:05,580
running on the on the on the hosts

91
00:03:05,580 --> 00:03:07,739
right so the goal today is to detect and

92
00:03:07,739 --> 00:03:10,379
prevent these attacks with EPF yeah

93
00:03:10,379 --> 00:03:13,140
simple enough right well absolutely not

94
00:03:13,140 --> 00:03:14,700
um those three you know types of

95
00:03:14,700 --> 00:03:17,220
annuities are way too ambitious and it

96
00:03:17,220 --> 00:03:19,560
would be an Ode to lie if I was to say

97
00:03:19,560 --> 00:03:21,599
that you know I was able to catch every

98
00:03:21,599 --> 00:03:23,280
single one of them

99
00:03:23,280 --> 00:03:24,900
um so what we are more realistically

100
00:03:24,900 --> 00:03:26,819
going to do is trying to make attackers

101
00:03:26,819 --> 00:03:28,620
lives a living hell

102
00:03:28,620 --> 00:03:30,540
um so yeah again we need to be very

103
00:03:30,540 --> 00:03:32,640
realistic about expectations and what

104
00:03:32,640 --> 00:03:35,040
you can actually do with ebpf in the in

105
00:03:35,040 --> 00:03:37,500
the you know in the Spheres of detecting

106
00:03:37,500 --> 00:03:40,400
kernel exploits

107
00:03:41,040 --> 00:03:42,659
um so I've been talking about BPI for a

108
00:03:42,659 --> 00:03:45,120
while um so what is a vpf so in a

109
00:03:45,120 --> 00:03:48,239
nutshell BPF is a way to run sandbox

110
00:03:48,239 --> 00:03:50,459
programs in the Linux kernel so you

111
00:03:50,459 --> 00:03:52,680
think of it as you have you know a c

112
00:03:52,680 --> 00:03:55,080
program that you compile into EPPI by

113
00:03:55,080 --> 00:03:56,760
code and that you load into the kernel

114
00:03:56,760 --> 00:03:58,860
using the BPS Cisco

115
00:03:58,860 --> 00:04:00,599
um so the code is going to you know

116
00:04:00,599 --> 00:04:02,220
perform a bunch of checks essentially

117
00:04:02,220 --> 00:04:03,420
the goal is to make sure that your

118
00:04:03,420 --> 00:04:05,459
program is safe and that the kernel is

119
00:04:05,459 --> 00:04:07,200
not going to crash or into a common

120
00:04:07,200 --> 00:04:08,879
Panic or whatever because of your

121
00:04:08,879 --> 00:04:12,180
program and then the second step is to

122
00:04:12,180 --> 00:04:14,580
actually attach your evpf program to a

123
00:04:14,580 --> 00:04:16,079
hook Point

124
00:04:16,079 --> 00:04:17,279
um so you have a bunch of different

125
00:04:17,279 --> 00:04:19,440
program types A bunch of foodpoints um

126
00:04:19,440 --> 00:04:21,540
I'm gonna go over a few of them through

127
00:04:21,540 --> 00:04:23,880
that talk but just know that yeah you

128
00:04:23,880 --> 00:04:27,479
need to attach an eppf program 2.4 your

129
00:04:27,479 --> 00:04:31,400
ibps program to actually get triggered

130
00:04:32,340 --> 00:04:35,639
all right so why ubpf um what are the

131
00:04:35,639 --> 00:04:37,620
reasons why this technology may make

132
00:04:37,620 --> 00:04:40,800
sense for this kind of projects well the

133
00:04:40,800 --> 00:04:43,139
first point is ebpf has a related

134
00:04:43,139 --> 00:04:45,300
relatively wide kernel support depending

135
00:04:45,300 --> 00:04:46,800
on the BPF features that you actually

136
00:04:46,800 --> 00:04:49,620
use so um as long as you do not use two

137
00:04:49,620 --> 00:04:51,360
fancy features you can actually go back

138
00:04:51,360 --> 00:04:53,280
to I mean you know backboard your

139
00:04:53,280 --> 00:04:56,759
detections back to 4.1 kernels another

140
00:04:56,759 --> 00:04:59,040
good thing about ebpf is that it has

141
00:04:59,040 --> 00:05:00,960
some safety and stability insurances

142
00:05:00,960 --> 00:05:03,780
that kernel modules might not have

143
00:05:03,780 --> 00:05:05,520
um it also has a rich feature set which

144
00:05:05,520 --> 00:05:07,500
means that you have you know a lot of

145
00:05:07,500 --> 00:05:09,419
different ways to understand what the

146
00:05:09,419 --> 00:05:10,860
kernel is doing and what's happening in

147
00:05:10,860 --> 00:05:12,240
Chrome space

148
00:05:12,240 --> 00:05:15,000
and finally if you are you know using a

149
00:05:15,000 --> 00:05:17,160
recent enough kernel you have some right

150
00:05:17,160 --> 00:05:19,979
access and enforcement capabilities

151
00:05:19,979 --> 00:05:22,259
so overall ebpf has a bunch of you know

152
00:05:22,259 --> 00:05:24,600
Pros going for it right

153
00:05:24,600 --> 00:05:26,759
um but at the same time ebpf is pretty

154
00:05:26,759 --> 00:05:28,440
much a terrible idea to do this kind of

155
00:05:28,440 --> 00:05:29,580
detections

156
00:05:29,580 --> 00:05:31,199
um the first reason why it's really like

157
00:05:31,199 --> 00:05:32,900
you know not great to do kernel level

158
00:05:32,900 --> 00:05:35,160
explore detection with the BPF is

159
00:05:35,160 --> 00:05:37,440
because detecting cost compromise

160
00:05:37,440 --> 00:05:39,780
activity is fighting a lost battle so

161
00:05:39,780 --> 00:05:42,840
we're gonna see why in some cases evpf

162
00:05:42,840 --> 00:05:44,759
cannot catch you know and exploit

163
00:05:44,759 --> 00:05:46,500
pre-compromise it's going to have to be

164
00:05:46,500 --> 00:05:49,199
post compromised and the point is

165
00:05:49,199 --> 00:05:50,460
um yeah if you are relying on a

166
00:05:50,460 --> 00:05:52,500
compromise kernel to actually emits you

167
00:05:52,500 --> 00:05:54,060
know security events while you can't

168
00:05:54,060 --> 00:05:56,460
rely on these events to be actually

169
00:05:56,460 --> 00:05:58,919
um you know legit and valuable like they

170
00:05:58,919 --> 00:06:00,900
could be compromised as well

171
00:06:00,900 --> 00:06:02,580
um the other reason why ubpf is not a

172
00:06:02,580 --> 00:06:04,320
great idea for this is because there are

173
00:06:04,320 --> 00:06:06,780
dozens of ways to disable ebpf programs

174
00:06:06,780 --> 00:06:08,880
what this means is it's going to be as

175
00:06:08,880 --> 00:06:10,919
important to actually write deductions

176
00:06:10,919 --> 00:06:12,539
for whatever you're trying to detect

177
00:06:12,539 --> 00:06:14,880
then it will that it will be to actually

178
00:06:14,880 --> 00:06:17,220
protect the ebpf sub system and make

179
00:06:17,220 --> 00:06:19,139
sure that you know it's actually still

180
00:06:19,139 --> 00:06:21,120
enabled and still working and it will

181
00:06:21,120 --> 00:06:23,280
trigger when you want it to trigger

182
00:06:23,280 --> 00:06:25,440
last point is ebpf can have a

183
00:06:25,440 --> 00:06:27,000
significant kernel space performance

184
00:06:27,000 --> 00:06:28,319
impacts but we're going to talk about

185
00:06:28,319 --> 00:06:29,280
this later

186
00:06:29,280 --> 00:06:31,319
all right so what's the point right well

187
00:06:31,319 --> 00:06:33,240
the point is group kit is an out of the

188
00:06:33,240 --> 00:06:35,880
box word kits there is value in trying

189
00:06:35,880 --> 00:06:37,800
to make attackers lives harder and to

190
00:06:37,800 --> 00:06:40,080
try to make it harder to exploit uh

191
00:06:40,080 --> 00:06:42,539
flows within the comma

192
00:06:42,539 --> 00:06:44,280
and last but not least in some very

193
00:06:44,280 --> 00:06:45,720
specific cases that we're going to talk

194
00:06:45,720 --> 00:06:47,520
about detecting and blocking

195
00:06:47,520 --> 00:06:51,318
pre-compromise is actually possible

196
00:06:51,600 --> 00:06:53,460
all right so this is why today I'm

197
00:06:53,460 --> 00:06:55,680
really saying cry so cry stands for kind

198
00:06:55,680 --> 00:06:58,440
of Kernel runtime Integrity with EPF

199
00:06:58,440 --> 00:07:00,120
um it's an open source project there are

200
00:07:00,120 --> 00:07:02,400
there is no RNC board yet uh it's

201
00:07:02,400 --> 00:07:04,860
compatible with at least kernel 5.15 and

202
00:07:04,860 --> 00:07:06,000
plus

203
00:07:06,000 --> 00:07:07,620
um yeah so it's available on GitHub

204
00:07:07,620 --> 00:07:09,660
today so feel free to check it out

205
00:07:09,660 --> 00:07:12,180
so instead of going through regarding

206
00:07:12,180 --> 00:07:14,400
lists of all the features that cry has

207
00:07:14,400 --> 00:07:16,020
to offer what I'm actually going to do

208
00:07:16,020 --> 00:07:18,539
is get in the shoes of an ad hacker and

209
00:07:18,539 --> 00:07:19,860
try to take you through the different

210
00:07:19,860 --> 00:07:22,139
steps that an attacker might you know

211
00:07:22,139 --> 00:07:24,720
follow in order to either exploit a flow

212
00:07:24,720 --> 00:07:27,539
or of the kernel or try to bypass

213
00:07:27,539 --> 00:07:29,160
whatever deductions we're going to talk

214
00:07:29,160 --> 00:07:31,580
about today

215
00:07:32,340 --> 00:07:34,199
all right so let's talk about the first

216
00:07:34,199 --> 00:07:36,180
scenario so let's say that an attacker

217
00:07:36,180 --> 00:07:37,740
controls the address of the next

218
00:07:37,740 --> 00:07:40,500
instruction executed by the kernel so

219
00:07:40,500 --> 00:07:42,660
this is a very textbook example of a

220
00:07:42,660 --> 00:07:44,819
return object programming attack these

221
00:07:44,819 --> 00:07:46,560
kind of attacks are usually used to try

222
00:07:46,560 --> 00:07:48,479
to eventually you know elevate your

223
00:07:48,479 --> 00:07:50,940
privileges and gain root access on a

224
00:07:50,940 --> 00:07:53,819
machine uh when the the process actually

225
00:07:53,819 --> 00:07:56,220
goes back to user space

226
00:07:56,220 --> 00:07:58,199
so let's go through the different steps

227
00:07:58,199 --> 00:08:00,240
of the attack and see you know what's

228
00:08:00,240 --> 00:08:02,400
happening and how cry can actually help

229
00:08:02,400 --> 00:08:04,620
to detect this kind of attacks so the

230
00:08:04,620 --> 00:08:06,900
first step is again so the attacker is

231
00:08:06,900 --> 00:08:09,360
allowed to to choose which you know

232
00:08:09,360 --> 00:08:10,460
which will be the next instruction

233
00:08:10,460 --> 00:08:12,780
executed by the kernel so let's say that

234
00:08:12,780 --> 00:08:15,060
they jump to a stack pivot so stack

235
00:08:15,060 --> 00:08:17,340
pivot is very simple the idea is the

236
00:08:17,340 --> 00:08:19,979
attacker will be able to choose where um

237
00:08:19,979 --> 00:08:22,259
the stack pointer will point to uh

238
00:08:22,259 --> 00:08:24,000
assuming that they have access to and

239
00:08:24,000 --> 00:08:26,160
they can control or just predict the

240
00:08:26,160 --> 00:08:29,879
address that will be in eax or there and

241
00:08:29,879 --> 00:08:31,379
the point is they will actually point

242
00:08:31,379 --> 00:08:33,719
the stack of the kernel thread to a user

243
00:08:33,719 --> 00:08:35,279
space buffer

244
00:08:35,279 --> 00:08:37,140
um and within this usage buffer they

245
00:08:37,140 --> 00:08:38,700
will have prepared the entire web chain

246
00:08:38,700 --> 00:08:40,919
and you know little by little eventually

247
00:08:40,919 --> 00:08:42,779
at some point they will execute a kernel

248
00:08:42,779 --> 00:08:44,039
function with attacker control

249
00:08:44,039 --> 00:08:45,480
parameters

250
00:08:45,480 --> 00:08:48,899
so over the past few years a few and

251
00:08:48,899 --> 00:08:50,459
actually a lot of

252
00:08:50,459 --> 00:08:52,200
um you know features were added to try

253
00:08:52,200 --> 00:08:53,700
to prevent these attacks from working

254
00:08:53,700 --> 00:08:56,100
one of them is called smart so it stands

255
00:08:56,100 --> 00:08:58,380
for supervisor mode access prevention

256
00:08:58,380 --> 00:09:00,779
and what it does is it prevents a kernel

257
00:09:00,779 --> 00:09:03,060
threat from using a user space buffer

258
00:09:03,060 --> 00:09:05,700
for its stack so basically what I've

259
00:09:05,700 --> 00:09:07,140
just described will not be possible

260
00:09:07,140 --> 00:09:08,399
because of snap

261
00:09:08,399 --> 00:09:10,860
is a bit you know it's rated because

262
00:09:10,860 --> 00:09:12,480
it's also checking addresses but the

263
00:09:12,480 --> 00:09:14,220
point is instead of jumping into the

264
00:09:14,220 --> 00:09:16,620
stack pivot I could have tried so here I

265
00:09:16,620 --> 00:09:18,240
could have tried to jump directly in

266
00:09:18,240 --> 00:09:20,700
user space executable memory and Smith

267
00:09:20,700 --> 00:09:22,080
would have prevented me from actually

268
00:09:22,080 --> 00:09:24,360
jumping to user space from a kernel

269
00:09:24,360 --> 00:09:26,959
space thread

270
00:09:27,480 --> 00:09:29,160
um all right but for the sake of this

271
00:09:29,160 --> 00:09:31,260
talk let's say that's map ends map are

272
00:09:31,260 --> 00:09:32,640
disabled

273
00:09:32,640 --> 00:09:34,080
um and also let's say that the route

274
00:09:34,080 --> 00:09:36,420
chain was eventually updated to uh

275
00:09:36,420 --> 00:09:38,760
called commit credits of prepare Canal

276
00:09:38,760 --> 00:09:40,620
credit of zero so basically what these

277
00:09:40,620 --> 00:09:43,279
two functions do is they upgrade the the

278
00:09:43,279 --> 00:09:46,019
kernel sorry the credentials of the

279
00:09:46,019 --> 00:09:48,060
current thread and eventually make the

280
00:09:48,060 --> 00:09:49,680
current thread roots

281
00:09:49,680 --> 00:09:51,720
okay so what can we do for machines

282
00:09:51,720 --> 00:09:54,540
without snap and without smap

283
00:09:54,540 --> 00:09:56,459
well the very first thing that comes to

284
00:09:56,459 --> 00:09:58,500
mind is to put a k probe and prepare

285
00:09:58,500 --> 00:10:00,899
cannot create so what this does okay so

286
00:10:00,899 --> 00:10:02,760
just like before I get into the details

287
00:10:02,760 --> 00:10:04,980
okay probes are a type of programs of

288
00:10:04,980 --> 00:10:07,080
evpf programs that you can use to attach

289
00:10:07,080 --> 00:10:09,360
an ubpf program to an exported kernel

290
00:10:09,360 --> 00:10:11,459
symbol what this means is whenever this

291
00:10:11,459 --> 00:10:13,500
kernel symbol is called the ebpf program

292
00:10:13,500 --> 00:10:15,720
will be triggered first

293
00:10:15,720 --> 00:10:17,399
um so what we can do is put a k program

294
00:10:17,399 --> 00:10:19,500
that on that symbol and then check if

295
00:10:19,500 --> 00:10:21,180
the stack pointer the frame pointer and

296
00:10:21,180 --> 00:10:23,160
the instruction pointer are actually

297
00:10:23,160 --> 00:10:26,480
pointing to the space memory

298
00:10:26,760 --> 00:10:29,820
all right so um what you can see here is

299
00:10:29,820 --> 00:10:31,920
simply uh you know so it's a vulnerable

300
00:10:31,920 --> 00:10:33,959
kernel module that I had to load in

301
00:10:33,959 --> 00:10:35,760
order for the remote to work but

302
00:10:35,760 --> 00:10:37,620
basically what you can see is that here

303
00:10:37,620 --> 00:10:39,600
there is an offset that is actually uh

304
00:10:39,600 --> 00:10:41,160
controlled by the attacker and they can

305
00:10:41,160 --> 00:10:43,260
use these offsets to you know move

306
00:10:43,260 --> 00:10:45,360
wherever they want in the kernel and

307
00:10:45,360 --> 00:10:47,519
choose what the next instruction is

308
00:10:47,519 --> 00:10:48,720
going to be and what the next you know

309
00:10:48,720 --> 00:10:51,180
the instruction that the kernel is going

310
00:10:51,180 --> 00:10:53,160
to execute will be

311
00:10:53,160 --> 00:10:55,860
um all right so this killer module was

312
00:10:55,860 --> 00:10:58,320
loaded so let's jump into a machine and

313
00:10:58,320 --> 00:11:01,040
then start cry

314
00:11:01,320 --> 00:11:03,959
here you go and then eventually you know

315
00:11:03,959 --> 00:11:06,480
exploit the bag and see um the recording

316
00:11:06,480 --> 00:11:07,740
action all right perfect so I've

317
00:11:07,740 --> 00:11:10,079
configured cry to shape all the logs and

318
00:11:10,079 --> 00:11:11,760
all the others to datadog you could

319
00:11:11,760 --> 00:11:13,200
actually have used any kind of any any

320
00:11:13,200 --> 00:11:15,480
log monitoring platform it's okay the

321
00:11:15,480 --> 00:11:18,720
the logs are generated in a Json file

322
00:11:18,720 --> 00:11:20,220
um and yeah if you update the page

323
00:11:20,220 --> 00:11:22,800
you'll see that a new log was sent which

324
00:11:22,800 --> 00:11:25,980
is a registered check event

325
00:11:25,980 --> 00:11:28,260
and then you have context about the

326
00:11:28,260 --> 00:11:29,940
process that made that triggered this

327
00:11:29,940 --> 00:11:31,980
detection and then eventually you get

328
00:11:31,980 --> 00:11:33,480
you know like the hook point on which

329
00:11:33,480 --> 00:11:34,920
the detection was made and then you

330
00:11:34,920 --> 00:11:36,420
clearly see that the side pointer here

331
00:11:36,420 --> 00:11:38,880
is in user space which is you know a

332
00:11:38,880 --> 00:11:40,200
detection that's something weird

333
00:11:40,200 --> 00:11:42,560
happened

334
00:11:44,339 --> 00:11:46,800
all right so it sounds great it does

335
00:11:46,800 --> 00:11:48,899
work but it's simply like Snap and

336
00:11:48,899 --> 00:11:50,579
smartphone and the reason for this is

337
00:11:50,579 --> 00:11:52,380
because you need to hook all the

338
00:11:52,380 --> 00:11:54,060
functions called by kernel exploit for

339
00:11:54,060 --> 00:11:56,459
this work the other problem is blocking

340
00:11:56,459 --> 00:11:59,399
mode only works on 5.3 kernels in plus

341
00:11:59,399 --> 00:12:01,140
and the reason for this is because if

342
00:12:01,140 --> 00:12:02,339
you want to actually block this kind of

343
00:12:02,339 --> 00:12:03,959
things you need to kill the thread and

344
00:12:03,959 --> 00:12:05,459
you're not to kill the thread you need a

345
00:12:05,459 --> 00:12:07,320
helper that was introduced in 5.3

346
00:12:07,320 --> 00:12:09,720
kernels another problem with this is if

347
00:12:09,720 --> 00:12:11,519
an attacker knew that you were using

348
00:12:11,519 --> 00:12:14,519
k-prebs to actually detect this as yeah

349
00:12:14,519 --> 00:12:16,620
well all they would try to do is prevent

350
00:12:16,620 --> 00:12:18,120
the k-probe from firing in the first

351
00:12:18,120 --> 00:12:18,959
place

352
00:12:18,959 --> 00:12:20,820
all right so get on

353
00:12:20,820 --> 00:12:22,860
um what would the networker do to to uh

354
00:12:22,860 --> 00:12:25,200
you know disable the K4 well as far as I

355
00:12:25,200 --> 00:12:26,640
know there are three main ways to

356
00:12:26,640 --> 00:12:28,320
disable the k-probe the first one is to

357
00:12:28,320 --> 00:12:30,120
use kick probes enable interface so I'm

358
00:12:30,120 --> 00:12:31,620
going to talk about this one later the

359
00:12:31,620 --> 00:12:34,260
second one is to use cctl to disable F

360
00:12:34,260 --> 00:12:36,180
Trace enabled so this is a global kill

361
00:12:36,180 --> 00:12:38,519
switch for all the tracing subsystems of

362
00:12:38,519 --> 00:12:40,440
the Linux KOMO and the last one is to

363
00:12:40,440 --> 00:12:42,060
kill the user space process that

364
00:12:42,060 --> 00:12:45,000
actually loaded the BPI programs well

365
00:12:45,000 --> 00:12:47,760
let's try to booby trap everything right

366
00:12:47,760 --> 00:12:48,839
um I'm not going to talk about the last

367
00:12:48,839 --> 00:12:50,579
one a lot because it's probably the

368
00:12:50,579 --> 00:12:52,560
nosiest option and probably not the one

369
00:12:52,560 --> 00:12:53,940
that attackers are going to try to do

370
00:12:53,940 --> 00:12:55,560
first so I'm just going to go over the

371
00:12:55,560 --> 00:12:57,120
first two ones

372
00:12:57,120 --> 00:12:59,220
all right so let's talk about the first

373
00:12:59,220 --> 00:13:01,380
one so kpreps enabled is a global kill

374
00:13:01,380 --> 00:13:03,180
switch to disarm all K probes on your

375
00:13:03,180 --> 00:13:04,320
machine

376
00:13:04,320 --> 00:13:06,120
um if you look at how it works

377
00:13:06,120 --> 00:13:07,560
eventually it will call the right and

378
00:13:07,560 --> 00:13:09,899
evolved five ball hook point and I mean

379
00:13:09,899 --> 00:13:12,360
symbol and you can actually update the

380
00:13:12,360 --> 00:13:14,519
rock chain to do that yourself so what

381
00:13:14,519 --> 00:13:16,200
you could do is use your web chain to

382
00:13:16,200 --> 00:13:18,360
eventually try to disable you know all

383
00:13:18,360 --> 00:13:20,760
the k-probes before jumping to the

384
00:13:20,760 --> 00:13:23,399
commit threads function

385
00:13:23,399 --> 00:13:25,139
all right so let's put the camera on it

386
00:13:25,139 --> 00:13:26,100
as well

387
00:13:26,100 --> 00:13:28,139
on the problem is even if you did put a

388
00:13:28,139 --> 00:13:29,880
good program on it if an attacker knew

389
00:13:29,880 --> 00:13:31,620
that you were using K probes again there

390
00:13:31,620 --> 00:13:33,240
is another way to verify Escape probes

391
00:13:33,240 --> 00:13:35,040
even without going through the paint

392
00:13:35,040 --> 00:13:37,260
part of you know cooling white in a

393
00:13:37,260 --> 00:13:39,000
right on the wall Fireball

394
00:13:39,000 --> 00:13:40,800
um and the way you can you know

395
00:13:40,800 --> 00:13:42,480
understand how to do it is simply by

396
00:13:42,480 --> 00:13:44,639
looking at the buy code at one time so

397
00:13:44,639 --> 00:13:46,380
on the left here you can see that this

398
00:13:46,380 --> 00:13:48,180
is the bytecode of the function without

399
00:13:48,180 --> 00:13:49,860
a k probe and on the right this is with

400
00:13:49,860 --> 00:13:51,839
the k-pro so what's happening here is

401
00:13:51,839 --> 00:13:53,700
that when a k-prov is actually loaded

402
00:13:53,700 --> 00:13:56,399
the bytecode is Rewritten to call to

403
00:13:56,399 --> 00:13:57,600
some address that is actually a

404
00:13:57,600 --> 00:13:59,700
subsystem of the k-probe um you know

405
00:13:59,700 --> 00:14:01,740
feature and and then it will this

406
00:14:01,740 --> 00:14:03,480
subsystem will actually call your ippf

407
00:14:03,480 --> 00:14:05,639
program so if an attacker knew that you

408
00:14:05,639 --> 00:14:08,040
are using this to to check the registers

409
00:14:08,040 --> 00:14:09,779
what they could do is simply jump five

410
00:14:09,779 --> 00:14:11,519
bytes later and then like you know

411
00:14:11,519 --> 00:14:14,100
bypass the call to the caper well again

412
00:14:14,100 --> 00:14:16,260
game on what do you do next

413
00:14:16,260 --> 00:14:17,880
um the cool thing is K probes can

414
00:14:17,880 --> 00:14:21,000
actually be added uh in in you know uh

415
00:14:21,000 --> 00:14:24,000
hooked at multiple offsets past the the

416
00:14:24,000 --> 00:14:25,920
symbol that you care about

417
00:14:25,920 --> 00:14:27,540
um and technically you can actually put

418
00:14:27,540 --> 00:14:30,120
many of them so the point is in order to

419
00:14:30,120 --> 00:14:31,800
prevent them from from preparing the

420
00:14:31,800 --> 00:14:34,079
attacker from being able to jump uh past

421
00:14:34,079 --> 00:14:36,000
the call to your k-pro what you can do

422
00:14:36,000 --> 00:14:38,399
is load multiple instances of them and

423
00:14:38,399 --> 00:14:40,800
then like do that further I mean fire

424
00:14:40,800 --> 00:14:42,540
away inside the function so that the

425
00:14:42,540 --> 00:14:45,060
attacker is deterred to uh ever try to

426
00:14:45,060 --> 00:14:46,920
call the function at all

427
00:14:46,920 --> 00:14:49,019
all right so that could work

428
00:14:49,019 --> 00:14:51,240
um but what else could they do uh you

429
00:14:51,240 --> 00:14:52,740
know past this and to try to bypass this

430
00:14:52,740 --> 00:14:53,940
again

431
00:14:53,940 --> 00:14:55,139
um well if you look at what

432
00:14:55,139 --> 00:14:57,180
right-handable fight ball does it

433
00:14:57,180 --> 00:14:59,519
actually writes zero or one to a global

434
00:14:59,519 --> 00:15:02,339
variable called K probes all designed so

435
00:15:02,339 --> 00:15:04,440
if you I mean the attacker could try to

436
00:15:04,440 --> 00:15:07,260
write one or zero directly to kpreps all

437
00:15:07,260 --> 00:15:08,399
designs

438
00:15:08,399 --> 00:15:10,260
um so it won't necessarily disable the K

439
00:15:10,260 --> 00:15:12,120
probes that are already loaded but at

440
00:15:12,120 --> 00:15:13,680
least it will prevent you from loading

441
00:15:13,680 --> 00:15:15,839
new ones and the bad thing is with the

442
00:15:15,839 --> 00:15:17,760
BPF you have no way to hook anything

443
00:15:17,760 --> 00:15:19,680
right because you don't have any symbols

444
00:15:19,680 --> 00:15:21,240
you don't have any program types that is

445
00:15:21,240 --> 00:15:23,100
able to to just hook on memory that is

446
00:15:23,100 --> 00:15:24,779
being updated so there is nothing you

447
00:15:24,779 --> 00:15:26,940
can do well actually almost what you can

448
00:15:26,940 --> 00:15:28,740
actually do is use a perf event program

449
00:15:28,740 --> 00:15:31,199
type to periodically check the values of

450
00:15:31,199 --> 00:15:33,540
all sensitive kernel parameters so perf

451
00:15:33,540 --> 00:15:35,880
events are usually used to um collect

452
00:15:35,880 --> 00:15:37,500
you know Hardware metrics on your

453
00:15:37,500 --> 00:15:39,899
processes but you can actually configure

454
00:15:39,899 --> 00:15:41,760
it to trigger periodically

455
00:15:41,760 --> 00:15:44,699
so that's what cray does

456
00:15:44,699 --> 00:15:46,699
all right so let's talk about the second

457
00:15:46,699 --> 00:15:49,320
way of disabling K probes the other way

458
00:15:49,320 --> 00:15:52,079
to do it is to use the system interface

459
00:15:52,079 --> 00:15:54,180
the good news is there is an entire BPF

460
00:15:54,180 --> 00:15:57,240
program dedicated to cctl

461
00:15:57,240 --> 00:15:59,339
um and unfortunately it was added in 5.2

462
00:15:59,339 --> 00:16:00,959
kernels so if you want to do this kind

463
00:16:00,959 --> 00:16:02,459
of things for all the kernels you're

464
00:16:02,459 --> 00:16:04,680
going to have to use kfrops again but

465
00:16:04,680 --> 00:16:06,420
the point is with this program type you

466
00:16:06,420 --> 00:16:08,459
can actually detect when the parameter

467
00:16:08,459 --> 00:16:10,139
is about to be changed and you know

468
00:16:10,139 --> 00:16:12,959
preventatively change the value or block

469
00:16:12,959 --> 00:16:15,120
the call entirely

470
00:16:15,120 --> 00:16:16,620
um almost all sensitive system

471
00:16:16,620 --> 00:16:18,779
parameters are checked by crowd

472
00:16:18,779 --> 00:16:21,180
periodically

473
00:16:21,180 --> 00:16:23,399
all right so let's say that whatever you

474
00:16:23,399 --> 00:16:25,139
did so far did not work and the attacker

475
00:16:25,139 --> 00:16:27,240
was able to work around your detections

476
00:16:27,240 --> 00:16:28,920
and eventually became roots on the

477
00:16:28,920 --> 00:16:29,940
machine

478
00:16:29,940 --> 00:16:31,320
um what they're likely going to do after

479
00:16:31,320 --> 00:16:33,899
that is try to persist their access and

480
00:16:33,899 --> 00:16:36,540
also modify the common runtime to hide

481
00:16:36,540 --> 00:16:38,880
their tracks the way they do it usually

482
00:16:38,880 --> 00:16:41,160
is by using column modules and then

483
00:16:41,160 --> 00:16:43,680
within the kernel module try to hook

484
00:16:43,680 --> 00:16:46,440
ciscals to to you know change the output

485
00:16:46,440 --> 00:16:49,380
of a Cisco basically the way to hook

486
00:16:49,380 --> 00:16:50,880
ciscals there are a bunch of ways to do

487
00:16:50,880 --> 00:16:52,800
it but mainly it's usually based on KP

488
00:16:52,800 --> 00:16:54,180
probes or by hooking this is called

489
00:16:54,180 --> 00:16:55,680
table directly

490
00:16:55,680 --> 00:16:57,720
another thing that kind of workers have

491
00:16:57,720 --> 00:17:00,120
been doing the past few years is use BPI

492
00:17:00,120 --> 00:17:02,759
filters to try to tap into the network

493
00:17:02,759 --> 00:17:05,640
traffic or they could also just like you

494
00:17:05,640 --> 00:17:07,500
know not use a kernel module at all and

495
00:17:07,500 --> 00:17:10,199
do everything using BPI ebpf programs um

496
00:17:10,199 --> 00:17:11,579
we actually had to talk last year about

497
00:17:11,579 --> 00:17:13,619
this so if you are interested we uh we

498
00:17:13,619 --> 00:17:15,000
you know we worked and published an

499
00:17:15,000 --> 00:17:20,099
entire uh BPF ebpf base with rootkit

500
00:17:20,099 --> 00:17:22,020
all right so what cry does because of

501
00:17:22,020 --> 00:17:23,459
all of this is actually monitor

502
00:17:23,459 --> 00:17:25,439
everything I've just talked about so you

503
00:17:25,439 --> 00:17:27,000
know any kind of ppf operation will

504
00:17:27,000 --> 00:17:29,160
generate alert any kind of common module

505
00:17:29,160 --> 00:17:31,080
load or deletion events any kind of

506
00:17:31,080 --> 00:17:33,240
K-pop registration or design events and

507
00:17:33,240 --> 00:17:35,700
so on and more importantly here for the

508
00:17:35,700 --> 00:17:39,240
next demo execution of hood ciscals so

509
00:17:39,240 --> 00:17:41,580
cry is able to detect again with the

510
00:17:41,580 --> 00:17:43,980
periodical check trick that the hook the

511
00:17:43,980 --> 00:17:46,140
sorry the Cisco table was hooked just by

512
00:17:46,140 --> 00:17:47,580
looking at the address of the Handler of

513
00:17:47,580 --> 00:17:49,440
a Cisco if it is outside of the kernel

514
00:17:49,440 --> 00:17:51,360
text so if it is for example inside of a

515
00:17:51,360 --> 00:17:52,500
module code

516
00:17:52,500 --> 00:17:54,059
um it will trigger an event and then

517
00:17:54,059 --> 00:17:56,820
also if the handle changes of attack it

518
00:17:56,820 --> 00:17:59,160
will also show you an event another way

519
00:17:59,160 --> 00:18:01,140
and cool trick of cry is that it is able

520
00:18:01,140 --> 00:18:03,120
to detect when a process is about to

521
00:18:03,120 --> 00:18:05,160
execute a Cisco that was hooked and

522
00:18:05,160 --> 00:18:07,559
again can configure cried to either plug

523
00:18:07,559 --> 00:18:09,600
or kill the process that is about to do

524
00:18:09,600 --> 00:18:11,400
that

525
00:18:11,400 --> 00:18:12,780
all right

526
00:18:12,780 --> 00:18:15,480
so again this is the kernel module as

527
00:18:15,480 --> 00:18:17,460
you can see it was modified to on init

528
00:18:17,460 --> 00:18:19,500
just you know this is a basic assist

529
00:18:19,500 --> 00:18:21,000
called table hook method but like

530
00:18:21,000 --> 00:18:23,280
overwrite the Cisco Handler to be our

531
00:18:23,280 --> 00:18:24,960
own Cisco lender

532
00:18:24,960 --> 00:18:27,419
and then if you look at the

533
00:18:27,419 --> 00:18:28,919
um configuration file of cry you'll see

534
00:18:28,919 --> 00:18:31,140
that I've configured it to log whenever

535
00:18:31,140 --> 00:18:33,240
the Cisco table is hooked and also

536
00:18:33,240 --> 00:18:35,340
killed the process that I might try to

537
00:18:35,340 --> 00:18:38,520
execute a Cisco that has been hooked

538
00:18:38,520 --> 00:18:40,559
so for this demo I wrote a basic web

539
00:18:40,559 --> 00:18:42,360
server and then if you you know call the

540
00:18:42,360 --> 00:18:43,919
books endpoint you'll get a list of

541
00:18:43,919 --> 00:18:46,500
books and to answer this list of books

542
00:18:46,500 --> 00:18:49,320
the server has to issue and opens this

543
00:18:49,320 --> 00:18:50,820
call

544
00:18:50,820 --> 00:18:53,700
all right so let's start cry and then

545
00:18:53,700 --> 00:18:56,400
insert the module that I just talked

546
00:18:56,400 --> 00:18:58,460
about

547
00:18:59,039 --> 00:19:00,600
perfect

548
00:19:00,600 --> 00:19:02,700
and then let's jump into Data dog to see

549
00:19:02,700 --> 00:19:04,440
what logs were pretty much immediately

550
00:19:04,440 --> 00:19:06,980
generated

551
00:19:07,140 --> 00:19:09,480
So eventually you'll get two of them

552
00:19:09,480 --> 00:19:11,760
perfect so the first one is init module

553
00:19:11,760 --> 00:19:13,080
so it's simply that you know the new

554
00:19:13,080 --> 00:19:14,640
model was loaded you have the name of

555
00:19:14,640 --> 00:19:16,380
the module and the process that did it

556
00:19:16,380 --> 00:19:18,000
and then if you look at the hook Cisco

557
00:19:18,000 --> 00:19:19,740
table you'll see clearly that you know

558
00:19:19,740 --> 00:19:22,020
the opens is called was hooked it used

559
00:19:22,020 --> 00:19:25,140
to be x64s is open and now it is ours is

560
00:19:25,140 --> 00:19:27,840
open inside the vision device module

561
00:19:27,840 --> 00:19:30,780
so let's go back to our web server and

562
00:19:30,780 --> 00:19:32,400
then like you know issue the request

563
00:19:32,400 --> 00:19:34,200
again and see what happens now that cry

564
00:19:34,200 --> 00:19:36,620
is running

565
00:19:37,919 --> 00:19:39,780
perfect and as expected the process was

566
00:19:39,780 --> 00:19:41,039
scaled and you would have another

567
00:19:41,039 --> 00:19:42,299
notification

568
00:19:42,299 --> 00:19:45,120
um in um you know in data deck

569
00:19:45,120 --> 00:19:47,400
all right so another way to detect uh

570
00:19:47,400 --> 00:19:50,340
chain attacks is uh control flow

571
00:19:50,340 --> 00:19:52,740
Integrity so CFI is a very well known

572
00:19:52,740 --> 00:19:55,980
feature of many programs that lock down

573
00:19:55,980 --> 00:19:58,140
the execution flows within the kernel by

574
00:19:58,140 --> 00:20:00,120
controlling call sites at runtime so

575
00:20:00,120 --> 00:20:01,919
they are usually added at compile time

576
00:20:01,919 --> 00:20:03,600
but sometimes they are added in Hardware

577
00:20:03,600 --> 00:20:05,880
as well and CFI is a great way to

578
00:20:05,880 --> 00:20:07,559
control and to prevent rubber attacks

579
00:20:07,559 --> 00:20:08,820
because it prevents you from jumping

580
00:20:08,820 --> 00:20:10,440
wherever you want inside the kernel

581
00:20:10,440 --> 00:20:13,440
which is basically what robotics do

582
00:20:13,440 --> 00:20:15,000
um these features unfortunately are not

583
00:20:15,000 --> 00:20:16,679
always available specifically the

584
00:20:16,679 --> 00:20:19,080
hardware ones so like you know what can

585
00:20:19,080 --> 00:20:21,480
we do with ebpf well instead of trying

586
00:20:21,480 --> 00:20:23,460
to lock down all the call sites what we

587
00:20:23,460 --> 00:20:25,380
can do vpf is lockdown jumps between

588
00:20:25,380 --> 00:20:27,840
control points so both hook points and

589
00:20:27,840 --> 00:20:29,640
parameters are checked and basically the

590
00:20:29,640 --> 00:20:31,740
idea is you can't reach a low level

591
00:20:31,740 --> 00:20:33,660
function that will eventually upgrade

592
00:20:33,660 --> 00:20:35,400
your credentials if you've not gone

593
00:20:35,400 --> 00:20:37,320
through first The Cisco that is linked

594
00:20:37,320 --> 00:20:39,240
to credentials update and then through

595
00:20:39,240 --> 00:20:40,980
the Linux security module so like you

596
00:20:40,980 --> 00:20:43,260
know the LSM interface that is basically

597
00:20:43,260 --> 00:20:46,620
handling all monetary Access Control

598
00:20:46,620 --> 00:20:48,240
so unfortunately I won't have time to

599
00:20:48,240 --> 00:20:50,160
talk about this further but the goal is

600
00:20:50,160 --> 00:20:51,900
to catch malicious calls to sensitive

601
00:20:51,900 --> 00:20:54,179
functions and also to detect logic bugs

602
00:20:54,179 --> 00:20:56,100
specifically for Access rights so

603
00:20:56,100 --> 00:20:57,539
example for example let's say you open

604
00:20:57,539 --> 00:21:00,240
the file as a writtenly and eventually

605
00:21:00,240 --> 00:21:02,160
you get you know you end up writing to

606
00:21:02,160 --> 00:21:04,559
it for example the bad news is that it's

607
00:21:04,559 --> 00:21:06,299
a very tedious process it's not

608
00:21:06,299 --> 00:21:08,340
automated contrary which is like you

609
00:21:08,340 --> 00:21:09,840
know not the same for

610
00:21:09,840 --> 00:21:11,760
um which is okay sorry for any other

611
00:21:11,760 --> 00:21:15,660
usual or normal CFI tools

612
00:21:15,660 --> 00:21:17,520
um and also like the hook you have to

613
00:21:17,520 --> 00:21:20,039
work around the loop limitations because

614
00:21:20,039 --> 00:21:22,559
again not all functions within the

615
00:21:22,559 --> 00:21:24,360
kernel are exported which means that you

616
00:21:24,360 --> 00:21:26,280
cannot cook everywhere technically with

617
00:21:26,280 --> 00:21:28,440
ebpf

618
00:21:28,440 --> 00:21:31,020
I also talked briefly about enforcements

619
00:21:31,020 --> 00:21:33,419
um so basically cry will try to enable

620
00:21:33,419 --> 00:21:35,520
the blocking features uh whenever they

621
00:21:35,520 --> 00:21:36,780
are available

622
00:21:36,780 --> 00:21:39,299
um so it's either program types or ebdf

623
00:21:39,299 --> 00:21:41,400
helpers and every detection we've talked

624
00:21:41,400 --> 00:21:43,500
about today are configurable to either

625
00:21:43,500 --> 00:21:46,260
log Block kill or paranoid so log block

626
00:21:46,260 --> 00:21:48,059
kills are pretty much self-explanatory

627
00:21:48,059 --> 00:21:50,220
paranoid means that whenever a detection

628
00:21:50,220 --> 00:21:52,140
triggers the all the processes are going

629
00:21:52,140 --> 00:21:54,480
to get killed again only if the right

630
00:21:54,480 --> 00:21:57,480
helper is available on your kernel

631
00:21:57,480 --> 00:21:58,740
all right so when it comes to

632
00:21:58,740 --> 00:21:59,880
Performance

633
00:21:59,880 --> 00:22:01,860
um so I use the Linux kernel computation

634
00:22:01,860 --> 00:22:03,659
time to evaluate the performance of cry

635
00:22:03,659 --> 00:22:05,520
and the reason for this is because it

636
00:22:05,520 --> 00:22:07,380
you know it spawns a lot of processes

637
00:22:07,380 --> 00:22:09,539
which is like it's which means that it's

638
00:22:09,539 --> 00:22:12,000
a very good stress test for cry and as

639
00:22:12,000 --> 00:22:13,200
you can see if you enable all the

640
00:22:13,200 --> 00:22:14,400
features of cry

641
00:22:14,400 --> 00:22:15,840
um well you can have a pretty

642
00:22:15,840 --> 00:22:17,760
significant overhead overcome so up to

643
00:22:17,760 --> 00:22:21,480
40 in the total execution time however

644
00:22:21,480 --> 00:22:23,340
if you disable just one detection which

645
00:22:23,340 --> 00:22:25,620
is the one that checks at runtime when a

646
00:22:25,620 --> 00:22:27,419
Cisco you know that is about to be

647
00:22:27,419 --> 00:22:28,740
executed

648
00:22:28,740 --> 00:22:30,480
um if the Cisco has been hooked or not

649
00:22:30,480 --> 00:22:32,460
so if you're disabled just this hook and

650
00:22:32,460 --> 00:22:34,500
just this direction you go back to less

651
00:22:34,500 --> 00:22:36,360
than one percent overhead which is

652
00:22:36,360 --> 00:22:38,640
totally fine for and actually in the

653
00:22:38,640 --> 00:22:41,280
same margins than other CFI tool out

654
00:22:41,280 --> 00:22:43,460
there

655
00:22:43,640 --> 00:22:46,260
all right so thanks a lot that's it for

656
00:22:46,260 --> 00:22:48,299
me um I think the three takeaways for

657
00:22:48,299 --> 00:22:51,120
this talk is are sorry first that uh

658
00:22:51,120 --> 00:22:52,980
ubpf can be used to write powerful

659
00:22:52,980 --> 00:22:54,299
detections

660
00:22:54,299 --> 00:22:56,640
um however ebpf might not be the ideal

661
00:22:56,640 --> 00:22:58,679
technology to detect kind of exploits

662
00:22:58,679 --> 00:23:00,539
for all the reasons that I've talked

663
00:23:00,539 --> 00:23:02,159
about in the talk

664
00:23:02,159 --> 00:23:04,200
um also more realistically probably the

665
00:23:04,200 --> 00:23:05,460
last resort

666
00:23:05,460 --> 00:23:07,679
um it's not really a public strategy

667
00:23:07,679 --> 00:23:10,440
however there is value in trying to make

668
00:23:10,440 --> 00:23:12,179
attackers lives harder and there is

669
00:23:12,179 --> 00:23:14,340
value in trying to you know just make

670
00:23:14,340 --> 00:23:16,559
exploit harder to to use and definitely

671
00:23:16,559 --> 00:23:18,720
try to make out of the box out of the

672
00:23:18,720 --> 00:23:21,840
box for kids uh fail for script kiddies

673
00:23:21,840 --> 00:23:23,280
for example

674
00:23:23,280 --> 00:23:24,900
all right so again

675
00:23:24,900 --> 00:23:27,480
um the the repository is open source so

676
00:23:27,480 --> 00:23:29,460
feel free to check it out and um I'm

677
00:23:29,460 --> 00:23:32,520
down so I'm ready to ask questions

678
00:23:32,520 --> 00:23:36,460
[Applause]

679
00:23:36,460 --> 00:23:39,579
[Music]

680
00:23:43,420 --> 00:23:46,519
[Music]

