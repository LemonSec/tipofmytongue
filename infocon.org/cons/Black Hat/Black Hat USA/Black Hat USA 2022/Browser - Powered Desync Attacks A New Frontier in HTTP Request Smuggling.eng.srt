1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:08,599 --> 00:00:11,219
and welcome to browser power desync

4
00:00:11,219 --> 00:00:13,320
attacks

5
00:00:13,320 --> 00:00:15,960
have you ever had an idea and then just

6
00:00:15,960 --> 00:00:18,779
dismissed it because there's no way that

7
00:00:18,779 --> 00:00:21,359
that would ever work

8
00:00:21,359 --> 00:00:23,699
three years ago I thought wouldn't it be

9
00:00:23,699 --> 00:00:25,859
cool if you could make browsers launch

10
00:00:25,859 --> 00:00:27,960
desync attacks that would enable some

11
00:00:27,960 --> 00:00:31,260
really interesting possibilities

12
00:00:31,260 --> 00:00:34,620
but I figured that there was no way that

13
00:00:34,620 --> 00:00:36,360
any web server was doing something

14
00:00:36,360 --> 00:00:39,780
foolish enough to make that possible

15
00:00:39,780 --> 00:00:42,239
this year I discovered I was completely

16
00:00:42,239 --> 00:00:45,059
wrong you can achieve all manner of

17
00:00:45,059 --> 00:00:46,800
interesting things and in this session

18
00:00:46,800 --> 00:00:49,620
I'll show you how

19
00:00:49,620 --> 00:00:52,500
like many discoveries the journey that

20
00:00:52,500 --> 00:00:55,620
led to it was quite windy it started in

21
00:00:55,620 --> 00:00:58,199
late 2019 when there was a Spate of

22
00:00:58,199 --> 00:01:00,480
requests smuggling false positives even

23
00:01:00,480 --> 00:01:04,500
leading to an incorrect cve for nginx

24
00:01:04,500 --> 00:01:07,020
I had a look at what the root cause of

25
00:01:07,020 --> 00:01:09,780
this was and declared that there was a

26
00:01:09,780 --> 00:01:12,000
simple solution

27
00:01:12,000 --> 00:01:14,760
and to do was never reuse HTTP one

28
00:01:14,760 --> 00:01:16,680
connections when looking for request

29
00:01:16,680 --> 00:01:18,659
smuggling

30
00:01:18,659 --> 00:01:20,220
and after that well everything was

31
00:01:20,220 --> 00:01:23,040
wonderful until last year when I

32
00:01:23,040 --> 00:01:24,540
realized that connection locked request

33
00:01:24,540 --> 00:01:26,580
smuggling was a thing and the only way

34
00:01:26,580 --> 00:01:30,420
to find this was to always reuse HTTP

35
00:01:30,420 --> 00:01:31,920
one connections

36
00:01:31,920 --> 00:01:36,659
so at this point we had a bit of a mess

37
00:01:36,659 --> 00:01:39,659
this year I set out to tackle this and

38
00:01:39,659 --> 00:01:42,420
after quite a lot of effort I eventually

39
00:01:42,420 --> 00:01:45,659
found that by slowing things down and

40
00:01:45,659 --> 00:01:48,479
paying really close attention to the

41
00:01:48,479 --> 00:01:51,240
exact sequence of events I could reuse

42
00:01:51,240 --> 00:01:53,100
connections and still distinguish

43
00:01:53,100 --> 00:01:54,840
genuine vulnerabilities from false

44
00:01:54,840 --> 00:01:56,520
positives

45
00:01:56,520 --> 00:01:58,200
and that was nice but

46
00:01:58,200 --> 00:02:00,960
sometimes when you pay extra close

47
00:02:00,960 --> 00:02:03,479
attention to things you find more than

48
00:02:03,479 --> 00:02:05,520
you bargained for

49
00:02:05,520 --> 00:02:07,740
on one website I noticed that something

50
00:02:07,740 --> 00:02:10,258
wasn't quite right and I pulled on that

51
00:02:10,258 --> 00:02:13,020
thread and what I found broke my mental

52
00:02:13,020 --> 00:02:15,720
model for request smuggling because the

53
00:02:15,720 --> 00:02:18,840
resulting attack didn't require an

54
00:02:18,840 --> 00:02:21,599
attacker and that meant it didn't even

55
00:02:21,599 --> 00:02:24,660
require a front-end server and that

56
00:02:24,660 --> 00:02:27,300
opens a whole new frontier of attack

57
00:02:27,300 --> 00:02:28,739
surface

58
00:02:28,739 --> 00:02:31,319
so today I'm here to share with you a

59
00:02:31,319 --> 00:02:33,420
methodology and toolkit that I've built

60
00:02:33,420 --> 00:02:35,160
to navigate this new world demonstrated

61
00:02:35,160 --> 00:02:38,520
with exploits on Apache Akamai varnish

62
00:02:38,520 --> 00:02:42,660
amazon.com and multiple web vpns

63
00:02:42,660 --> 00:02:44,819
first we're going to get warmed up with

64
00:02:44,819 --> 00:02:47,580
HP handling anomalies

65
00:02:47,580 --> 00:02:49,440
after that I'll share the client-side

66
00:02:49,440 --> 00:02:52,260
desync methodology using four in-depth

67
00:02:52,260 --> 00:02:54,900
case studies then I'll introduce pause

68
00:02:54,900 --> 00:02:57,180
based desync including a live demo

69
00:02:57,180 --> 00:02:58,800
because the attack is so cool and

70
00:02:58,800 --> 00:03:00,720
unreliable I couldn't resist

71
00:03:00,720 --> 00:03:02,819
and uh after that I'll chat about

72
00:03:02,819 --> 00:03:05,220
defense key takeaways and wrap up with

73
00:03:05,220 --> 00:03:08,220
five minutes of questions

74
00:03:08,220 --> 00:03:10,860
there's a lot of techniques in this

75
00:03:10,860 --> 00:03:13,440
presentation and I really want them to

76
00:03:13,440 --> 00:03:16,319
work for you so as part of that whenever

77
00:03:16,319 --> 00:03:18,599
you see this squiggly logo on a slide

78
00:03:18,599 --> 00:03:20,760
that means that my team has built an

79
00:03:20,760 --> 00:03:22,260
online replica

80
00:03:22,260 --> 00:03:24,120
of this vulnerability so you can

81
00:03:24,120 --> 00:03:25,920
practice that technique on a real system

82
00:03:25,920 --> 00:03:27,780
online for free

83
00:03:27,780 --> 00:03:30,120
I'm also releasing the code that powered

84
00:03:30,120 --> 00:03:32,459
every finding in this presentation and

85
00:03:32,459 --> 00:03:34,379
whenever there's a named Target you'll

86
00:03:34,379 --> 00:03:36,360
find full proof of exploit code on the

87
00:03:36,360 --> 00:03:38,159
white paper even if I haven't managed to

88
00:03:38,159 --> 00:03:41,700
squeeze it onto a slide

89
00:03:41,700 --> 00:03:43,980
we're going to start with a series of

90
00:03:43,980 --> 00:03:46,200
six esoteric vulnerabilities that

91
00:03:46,200 --> 00:03:47,940
directly led to the discovery of

92
00:03:47,940 --> 00:03:50,700
client-side desync attacks and also

93
00:03:50,700 --> 00:03:53,220
really quite valuable in their own right

94
00:03:53,220 --> 00:03:56,340
but first there's something I need to

95
00:03:56,340 --> 00:03:57,959
tell you

96
00:03:57,959 --> 00:04:02,700
the request is a lie HTTP requests are a

97
00:04:02,700 --> 00:04:06,420
really useful abstraction but in HTTP 1

98
00:04:06,420 --> 00:04:08,700
this abstraction is incredibly weak and

99
00:04:08,700 --> 00:04:10,860
the harder you try to cling on to this

100
00:04:10,860 --> 00:04:14,459
concept of a request the less sense the

101
00:04:14,459 --> 00:04:17,639
techniques are going to make so at all

102
00:04:17,639 --> 00:04:19,680
times just bear in mind that all we're

103
00:04:19,680 --> 00:04:21,899
really doing is sending a stream of

104
00:04:21,899 --> 00:04:24,840
bytes to the server and what the server

105
00:04:24,840 --> 00:04:28,620
does with that is up to it

106
00:04:28,620 --> 00:04:31,320
for example if you believe in requests

107
00:04:31,320 --> 00:04:34,199
it's all too easy to forget about HTTP

108
00:04:34,199 --> 00:04:36,300
connection we use most of the time

109
00:04:36,300 --> 00:04:40,199
because HTTP is supposed to be stateless

110
00:04:40,199 --> 00:04:43,259
but sometimes State just finds a way to

111
00:04:43,259 --> 00:04:45,479
creep in take this website that I found

112
00:04:45,479 --> 00:04:48,120
they had a reverse proxy which was set

113
00:04:48,120 --> 00:04:51,060
up to allow me to access sites intended

114
00:04:51,060 --> 00:04:53,900
to be public and not to let me access

115
00:04:53,900 --> 00:04:57,419
private sites on their internal Network

116
00:04:57,419 --> 00:05:00,240
but it was only validating the host

117
00:05:00,240 --> 00:05:02,699
header of the first request on each

118
00:05:02,699 --> 00:05:05,400
connection so by sending a legitimate

119
00:05:05,400 --> 00:05:07,259
request followed by my request to access

120
00:05:07,259 --> 00:05:09,600
an internal system I got access to that

121
00:05:09,600 --> 00:05:11,400
internal system

122
00:05:11,400 --> 00:05:13,680
now fortunately this particular bug

123
00:05:13,680 --> 00:05:16,740
class is quite rare but there is a more

124
00:05:16,740 --> 00:05:19,620
common variation which I'll call First

125
00:05:19,620 --> 00:05:22,080
request routing

126
00:05:22,080 --> 00:05:25,320
this is when the front end looks at the

127
00:05:25,320 --> 00:05:27,240
first request to work out where to Route

128
00:05:27,240 --> 00:05:29,639
it and then just pass us all subsequent

129
00:05:29,639 --> 00:05:32,039
requests on the same connection straight

130
00:05:32,039 --> 00:05:34,740
through to the same back end

131
00:05:34,740 --> 00:05:37,680
this Behavior by itself is not really a

132
00:05:37,680 --> 00:05:39,479
vulnerability but you can use it to hit

133
00:05:39,479 --> 00:05:41,460
any back end with an arbitrary host

134
00:05:41,460 --> 00:05:43,560
header so it can form part of an exploit

135
00:05:43,560 --> 00:05:46,380
chain in this example here I want to hit

136
00:05:46,380 --> 00:05:48,360
the back end with a poisoned password

137
00:05:48,360 --> 00:05:51,840
reset header to generate a poisoned

138
00:05:51,840 --> 00:05:52,800
email

139
00:05:52,800 --> 00:05:54,900
but if I try and do that directly it

140
00:05:54,900 --> 00:05:56,580
doesn't work because the front end won't

141
00:05:56,580 --> 00:05:58,919
route it to the right back end but once

142
00:05:58,919 --> 00:06:01,500
again just by prefixing my attack with a

143
00:06:01,500 --> 00:06:03,660
genuine request with a correct host

144
00:06:03,660 --> 00:06:06,240
header I can hit that back end generate

145
00:06:06,240 --> 00:06:08,699
a poisoned password reset email and

146
00:06:08,699 --> 00:06:11,520
hopefully hijack someone's account

147
00:06:11,520 --> 00:06:14,580
so hopefully that technique will come in

148
00:06:14,580 --> 00:06:16,979
useful for you but there's also a

149
00:06:16,979 --> 00:06:19,139
broader takeaway which is that sometimes

150
00:06:19,139 --> 00:06:21,000
it's good to peel away these

151
00:06:21,000 --> 00:06:23,039
abstractions because they can hide

152
00:06:23,039 --> 00:06:27,020
Behavior that's really quite important

153
00:06:28,319 --> 00:06:30,720
now you know the deal with request

154
00:06:30,720 --> 00:06:32,580
smuggling right you make the front end

155
00:06:32,580 --> 00:06:34,139
and the back end disagree about the

156
00:06:34,139 --> 00:06:36,300
length of the message you use that to

157
00:06:36,300 --> 00:06:38,880
apply a malicious prefix shown in Orange

158
00:06:38,880 --> 00:06:40,740
to the victim's request

159
00:06:40,740 --> 00:06:42,479
that makes bad things happen to the

160
00:06:42,479 --> 00:06:43,680
victim

161
00:06:43,680 --> 00:06:46,259
and to make that length disagreement

162
00:06:46,259 --> 00:06:48,660
happen you usually obfuscate the

163
00:06:48,660 --> 00:06:50,639
transfer and coding header to hide it

164
00:06:50,639 --> 00:06:52,800
from one of the two servers

165
00:06:52,800 --> 00:06:56,880
and so I was a bit puzzled when I found

166
00:06:56,880 --> 00:06:58,500
you could trigger really suspicious

167
00:06:58,500 --> 00:07:01,500
behavior on quite a few websites using

168
00:07:01,500 --> 00:07:04,860
aws's application load balancer using

169
00:07:04,860 --> 00:07:08,520
this HTTP 2 request

170
00:07:08,520 --> 00:07:10,560
if you look at this request you might

171
00:07:10,560 --> 00:07:12,840
wonder where the attack is

172
00:07:12,840 --> 00:07:15,960
because it's a legitimate request it's

173
00:07:15,960 --> 00:07:18,960
specification compliant and there's no

174
00:07:18,960 --> 00:07:21,000
obfuscation in it there's really nothing

175
00:07:21,000 --> 00:07:23,460
sketchy going on here and yet this was

176
00:07:23,460 --> 00:07:25,259
triggering some really shady behavior

177
00:07:25,259 --> 00:07:29,940
and after doing a bunch of Investigation

178
00:07:29,940 --> 00:07:31,800
I discovered that what Amazon was doing

179
00:07:31,800 --> 00:07:33,900
is they were downgrading this request to

180
00:07:33,900 --> 00:07:36,240
http one and when they did so

181
00:07:36,240 --> 00:07:38,460
for some reason they were adding a

182
00:07:38,460 --> 00:07:39,720
header that said this message was

183
00:07:39,720 --> 00:07:41,280
chunked

184
00:07:41,280 --> 00:07:44,460
now I've genuinely not sure why they

185
00:07:44,460 --> 00:07:47,039
were doing that but my best guess is

186
00:07:47,039 --> 00:07:49,259
that it's because browsers always send a

187
00:07:49,259 --> 00:07:50,819
Content length header even when they're

188
00:07:50,819 --> 00:07:53,580
using HTTP 2. even though it's kind of

189
00:07:53,580 --> 00:07:56,220
pointless when you're using H2

190
00:07:56,220 --> 00:07:58,919
so Amazon ended up with some logic that

191
00:07:58,919 --> 00:08:00,960
said well if the request doesn't have a

192
00:08:00,960 --> 00:08:02,580
Content length header I guess it must be

193
00:08:02,580 --> 00:08:04,020
chunked

194
00:08:04,020 --> 00:08:06,780
so using that just by changing the

195
00:08:06,780 --> 00:08:08,580
payload I sent slightly I could trigger

196
00:08:08,580 --> 00:08:10,259
an exploitable desync or a whole bunch

197
00:08:10,259 --> 00:08:12,960
of websites I reported to Amazon they

198
00:08:12,960 --> 00:08:15,360
fixed it pretty fast

199
00:08:15,360 --> 00:08:18,419
but the main thing was this taught me

200
00:08:18,419 --> 00:08:21,900
something really important which is

201
00:08:21,900 --> 00:08:24,599
full request smuggling you don't always

202
00:08:24,599 --> 00:08:28,979
need header obfuscation or ambiguity

203
00:08:28,979 --> 00:08:31,620
all you need is a server taken by

204
00:08:31,620 --> 00:08:33,539
surprise

205
00:08:33,539 --> 00:08:36,659
we'll come back to that later

206
00:08:36,659 --> 00:08:39,000
now let's take a closer look at the

207
00:08:39,000 --> 00:08:40,979
connection locked HP one request

208
00:08:40,979 --> 00:08:43,559
smuggling issue mentioned earlier

209
00:08:43,559 --> 00:08:46,200
to confirm regular request smuggling all

210
00:08:46,200 --> 00:08:48,480
you need to do is send two requests and

211
00:08:48,480 --> 00:08:50,100
confirm that the body of the first

212
00:08:50,100 --> 00:08:52,200
request affects the response to the

213
00:08:52,200 --> 00:08:54,420
second as shown here

214
00:08:54,420 --> 00:08:56,040
and this works great

215
00:08:56,040 --> 00:08:58,560
provided you send those two requests

216
00:08:58,560 --> 00:09:01,380
over separate connections if you send

217
00:09:01,380 --> 00:09:03,720
them over the same connection

218
00:09:03,720 --> 00:09:05,339
you've got a problem so here we're

219
00:09:05,339 --> 00:09:07,200
sending and receiving exactly the same

220
00:09:07,200 --> 00:09:10,080
bytes but we can no longer tell where

221
00:09:10,080 --> 00:09:11,940
the front end thinks the message ends

222
00:09:11,940 --> 00:09:14,399
and therefore we can't tell if this

223
00:09:14,399 --> 00:09:17,399
system is really vulnerable

224
00:09:17,399 --> 00:09:19,980
the solution to this is to realize that

225
00:09:19,980 --> 00:09:21,839
the bites that you get aren't the only

226
00:09:21,839 --> 00:09:24,300
information that you have available

227
00:09:24,300 --> 00:09:27,000
you also have timing information

228
00:09:27,000 --> 00:09:28,620
if the front end

229
00:09:28,620 --> 00:09:30,180
thinks that this initial message is

230
00:09:30,180 --> 00:09:31,980
chunked that means it's actually

231
00:09:31,980 --> 00:09:33,959
starting to generate a response before

232
00:09:33,959 --> 00:09:36,660
we send the orange payload

233
00:09:36,660 --> 00:09:39,180
so before setting the orange data you

234
00:09:39,180 --> 00:09:41,459
can pause and do a read on the socket

235
00:09:41,459 --> 00:09:43,620
and see if you've got a request back

236
00:09:43,620 --> 00:09:46,019
from the server and if you do that tells

237
00:09:46,019 --> 00:09:47,399
you that the front end is treating this

238
00:09:47,399 --> 00:09:49,380
message is chunked it's not using the

239
00:09:49,380 --> 00:09:50,700
content length and therefore you can

240
00:09:50,700 --> 00:09:52,740
bail on the attack because it will just

241
00:09:52,740 --> 00:09:55,080
be a false positive anyway

242
00:09:55,080 --> 00:09:57,600
meanwhile if your read attempt hangs for

243
00:09:57,600 --> 00:09:59,100
several seconds that shows that the

244
00:09:59,100 --> 00:10:00,360
server thinks the message hasn't

245
00:10:00,360 --> 00:10:02,820
finished yet and therefore it must be

246
00:10:02,820 --> 00:10:04,740
using the content length and as long as

247
00:10:04,740 --> 00:10:07,080
the rest of the attack pans out must be

248
00:10:07,080 --> 00:10:08,519
vulnerable

249
00:10:08,519 --> 00:10:11,279
so I automated this technique it does

250
00:10:11,279 --> 00:10:14,040
work I went scanning with it and found a

251
00:10:14,040 --> 00:10:15,720
bunch of systems uh including one that

252
00:10:15,720 --> 00:10:18,000
was slightly funny because they were

253
00:10:18,000 --> 00:10:20,100
using barracuda's web application

254
00:10:20,100 --> 00:10:22,920
firewall in front of IIs

255
00:10:22,920 --> 00:10:25,080
and they were vulnerable because of the

256
00:10:25,080 --> 00:10:27,920
web application firewall and what's more

257
00:10:27,920 --> 00:10:30,180
Barracuda had actually already issued a

258
00:10:30,180 --> 00:10:31,860
patch for this vulnerability but they

259
00:10:31,860 --> 00:10:34,620
hadn't flagged it as a security fix they

260
00:10:34,620 --> 00:10:37,260
just said it was a bit of a hardening

261
00:10:37,260 --> 00:10:39,360
measure and as such the client hadn't

262
00:10:39,360 --> 00:10:41,580
bothered to install it

263
00:10:41,580 --> 00:10:44,940
as usual though the best desync that

264
00:10:44,940 --> 00:10:46,800
that technique found is the one that

265
00:10:46,800 --> 00:10:49,560
initially made the least sense after

266
00:10:49,560 --> 00:10:51,959
extensive testing in refinement it looks

267
00:10:51,959 --> 00:10:54,180
like this

268
00:10:54,180 --> 00:10:57,959
now there's two things to unpack here

269
00:10:57,959 --> 00:11:00,480
first off as you can see the back end

270
00:11:00,480 --> 00:11:02,519
server is completely ignoring the

271
00:11:02,519 --> 00:11:04,620
content length of this message so that

272
00:11:04,620 --> 00:11:06,600
means this is something you could call a

273
00:11:06,600 --> 00:11:10,200
c0.0 desync which is a rarer attack

274
00:11:10,200 --> 00:11:13,200
class that's not detected by any public

275
00:11:13,200 --> 00:11:16,320
black box tools currently

276
00:11:16,320 --> 00:11:19,380
secondly well why is the backend server

277
00:11:19,380 --> 00:11:21,360
ignoring the content length

278
00:11:21,360 --> 00:11:24,360
there's no reason right

279
00:11:24,360 --> 00:11:25,680
they're just ignoring it because they

280
00:11:25,680 --> 00:11:26,820
feel like it

281
00:11:26,820 --> 00:11:29,100
and it never occurred to me that that

282
00:11:29,100 --> 00:11:31,079
might happen and that has serious

283
00:11:31,079 --> 00:11:32,880
consequences

284
00:11:32,880 --> 00:11:35,339
finally this left me wondering given

285
00:11:35,339 --> 00:11:37,019
that I found this vulnerability here by

286
00:11:37,019 --> 00:11:39,120
accident well how many more sites will I

287
00:11:39,120 --> 00:11:41,220
find if I go deliberately looking for

288
00:11:41,220 --> 00:11:42,779
this issue

289
00:11:42,779 --> 00:11:44,579
I'm pleased to say the answer is quite a

290
00:11:44,579 --> 00:11:48,240
few for example on amazon.com they

291
00:11:48,240 --> 00:11:50,160
ignore the content length if you do a

292
00:11:50,160 --> 00:11:52,860
post request to the path slash B

293
00:11:52,860 --> 00:11:55,920
using that I was able to trigger a

294
00:11:55,920 --> 00:11:59,220
proper server side desync and I made a

295
00:11:59,220 --> 00:12:01,079
proof of concept which stored random

296
00:12:01,079 --> 00:12:04,440
users requests inside my Amazon wishlist

297
00:12:04,440 --> 00:12:07,500
so I send the attack a few times load up

298
00:12:07,500 --> 00:12:09,959
my Amazon wishlist grab some random

299
00:12:09,959 --> 00:12:11,700
person's credentials from their request

300
00:12:11,700 --> 00:12:14,820
and I can access their account

301
00:12:14,820 --> 00:12:17,579
so I reported this to Amazon they fixed

302
00:12:17,579 --> 00:12:20,279
it at some point and then I realized I

303
00:12:20,279 --> 00:12:22,440
made a terrible mistake

304
00:12:22,440 --> 00:12:27,440
I'd missed out on a much cooler attack

305
00:12:27,440 --> 00:12:30,839
this attack here exploits a random live

306
00:12:30,839 --> 00:12:34,079
user right and there's no obfuscation in

307
00:12:34,079 --> 00:12:36,420
this attack request so that means that

308
00:12:36,420 --> 00:12:39,120
request can be sent by a browser

309
00:12:39,120 --> 00:12:41,640
so if instead of doing the wish listing

310
00:12:41,640 --> 00:12:44,160
I'd use the head technique to execute

311
00:12:44,160 --> 00:12:47,279
JavaScript in the victim's browser

312
00:12:47,279 --> 00:12:49,320
I could have made every user that got

313
00:12:49,320 --> 00:12:51,360
hit by this spread the attack to 10

314
00:12:51,360 --> 00:12:53,579
other users effectively making a

315
00:12:53,579 --> 00:12:55,560
self-spreading desynchronization worm

316
00:12:55,560 --> 00:12:58,019
and compromising every active Amazon

317
00:12:58,019 --> 00:13:02,579
user with virtually no effort on my part

318
00:13:02,579 --> 00:13:07,079
so that was a cool finding a missed

319
00:13:07,079 --> 00:13:10,200
opportunity and also a hint at an entire

320
00:13:10,200 --> 00:13:13,339
new attack class

321
00:13:13,920 --> 00:13:17,040
which we'll call client-side decent

322
00:13:17,040 --> 00:13:19,200
every decent attack we've seen so far

323
00:13:19,200 --> 00:13:20,940
including the Amazon one has

324
00:13:20,940 --> 00:13:22,860
desynchronized the connection between

325
00:13:22,860 --> 00:13:25,440
the front-end server and the back end

326
00:13:25,440 --> 00:13:26,459
server

327
00:13:26,459 --> 00:13:28,980
but if you can make a web browser cause

328
00:13:28,980 --> 00:13:31,260
a desync you can Target the browser's

329
00:13:31,260 --> 00:13:33,240
own connection pool and therefore

330
00:13:33,240 --> 00:13:35,160
exploit sites that don't actually have a

331
00:13:35,160 --> 00:13:38,220
front-end backend architecture

332
00:13:38,220 --> 00:13:40,500
this attack flow starts with the victim

333
00:13:40,500 --> 00:13:42,360
visiting the attacker site which

334
00:13:42,360 --> 00:13:45,000
triggers two requests to the Target

335
00:13:45,000 --> 00:13:46,740
the first one desynchronizes the

336
00:13:46,740 --> 00:13:48,839
browser's connection so that the second

337
00:13:48,839 --> 00:13:51,600
request triggers a harmful response to

338
00:13:51,600 --> 00:13:53,579
go back from the Target website to the

339
00:13:53,579 --> 00:13:56,040
victim generally given the attacker

340
00:13:56,040 --> 00:13:59,459
control over the victim's account

341
00:13:59,459 --> 00:14:02,040
to build these attacks I've adapted the

342
00:14:02,040 --> 00:14:03,540
methodology from classic request

343
00:14:03,540 --> 00:14:06,420
smuggling the key difference with

344
00:14:06,420 --> 00:14:10,019
client-side desync is the the our entire

345
00:14:10,019 --> 00:14:12,779
exploit needs to run inside our Victims

346
00:14:12,779 --> 00:14:15,360
web browser and that is an environment

347
00:14:15,360 --> 00:14:17,700
that's a lot more complex and

348
00:14:17,700 --> 00:14:20,040
uncontrolled than a dedicated hacking

349
00:14:20,040 --> 00:14:22,560
tool and so as such it's crucial to

350
00:14:22,560 --> 00:14:24,300
periodically check that the proof of

351
00:14:24,300 --> 00:14:26,160
concept that's working in your tool also

352
00:14:26,160 --> 00:14:30,240
works as expected in the Target browser

353
00:14:30,240 --> 00:14:32,519
tooling wise I did this with custom code

354
00:14:32,519 --> 00:14:34,260
which I'm releasing to GitHub straight

355
00:14:34,260 --> 00:14:35,820
after this presentation

356
00:14:35,820 --> 00:14:38,880
uh I also designed a new burp Suite

357
00:14:38,880 --> 00:14:40,320
feature called send request sequence

358
00:14:40,320 --> 00:14:42,300
which offers similar functionality but

359
00:14:42,300 --> 00:14:44,699
with a slightly gentler learning curve

360
00:14:44,699 --> 00:14:47,820
uh for the Target web browser you can

361
00:14:47,820 --> 00:14:49,680
this technique works on all browsers

362
00:14:49,680 --> 00:14:52,199
I've tested personally I focused on

363
00:14:52,199 --> 00:14:54,420
Chrome because it has the best developer

364
00:14:54,420 --> 00:14:58,380
tools for building this kind of exploit

365
00:14:58,380 --> 00:15:01,139
the first step towards an attack is just

366
00:15:01,139 --> 00:15:03,360
to identify your client-side desync

367
00:15:03,360 --> 00:15:04,320
vector

368
00:15:04,320 --> 00:15:07,440
this is a HTTP one request with three

369
00:15:07,440 --> 00:15:09,180
Key Properties

370
00:15:09,180 --> 00:15:11,339
first and foremost the server must

371
00:15:11,339 --> 00:15:13,440
ignore the content length and this

372
00:15:13,440 --> 00:15:15,720
usually happens because your request

373
00:15:15,720 --> 00:15:17,279
either either triggers some kind of

374
00:15:17,279 --> 00:15:19,139
server error or the server just wasn't

375
00:15:19,139 --> 00:15:21,240
expecting a post request to that

376
00:15:21,240 --> 00:15:23,760
endpoint so in this example here I'm

377
00:15:23,760 --> 00:15:26,760
just doing a post request to a static

378
00:15:26,760 --> 00:15:27,720
file

379
00:15:27,720 --> 00:15:30,180
which they might not expect and as you

380
00:15:30,180 --> 00:15:32,160
can see I've sent a contact length

381
00:15:32,160 --> 00:15:33,660
that's higher than the data that I'm

382
00:15:33,660 --> 00:15:35,880
actually sending so if a server responds

383
00:15:35,880 --> 00:15:38,519
to this request immediately that's an

384
00:15:38,519 --> 00:15:40,620
indication that it may be vulnerable to

385
00:15:40,620 --> 00:15:43,560
a client site desync

386
00:15:43,560 --> 00:15:44,639
now

387
00:15:44,639 --> 00:15:46,380
the other key request the other key

388
00:15:46,380 --> 00:15:48,480
requirement is that this request can be

389
00:15:48,480 --> 00:15:51,240
triggered in a web browser cross domain

390
00:15:51,240 --> 00:15:53,940
so that means that you must use the post

391
00:15:53,940 --> 00:15:56,220
method and you can't have any unusual

392
00:15:56,220 --> 00:15:58,620
headers or header obfuscation or stuff

393
00:15:58,620 --> 00:16:01,079
like that and also the target server

394
00:16:01,079 --> 00:16:03,420
can't advertise support for HTTP 2

395
00:16:03,420 --> 00:16:06,000
because this attack exploits HTTP 1

396
00:16:06,000 --> 00:16:08,040
connection of a use and

397
00:16:08,040 --> 00:16:10,440
browsers will aggressively prefer to use

398
00:16:10,440 --> 00:16:13,500
HTTP 2 if the server supports it

399
00:16:13,500 --> 00:16:16,800
finally I after your client-side decent

400
00:16:16,800 --> 00:16:18,600
Vector request the server has to leave

401
00:16:18,600 --> 00:16:20,399
the connection open because there's no

402
00:16:20,399 --> 00:16:22,199
point in desyncing a connection that is

403
00:16:22,199 --> 00:16:25,500
immediately closed

404
00:16:25,500 --> 00:16:27,300
once you've found your client's idsync

405
00:16:27,300 --> 00:16:29,339
Vector the next step is to confirm it

406
00:16:29,339 --> 00:16:32,040
works inside a real browser

407
00:16:32,040 --> 00:16:33,720
you can do that using some JavaScript

408
00:16:33,720 --> 00:16:36,480
that looks something like this as you

409
00:16:36,480 --> 00:16:39,360
can see here we're sending two requests

410
00:16:39,360 --> 00:16:41,279
the first one is going to desync the

411
00:16:41,279 --> 00:16:43,320
connection and the second is going to

412
00:16:43,320 --> 00:16:45,300
suffer the consequences

413
00:16:45,300 --> 00:16:47,699
in the initial request I've got a couple

414
00:16:47,699 --> 00:16:50,339
of special Flags worth mentioning uh

415
00:16:50,339 --> 00:16:53,399
first off I'm specifying mode no chords

416
00:16:53,399 --> 00:16:55,740
this is not actually required for a

417
00:16:55,740 --> 00:16:58,139
successful attack but what it does is

418
00:16:58,139 --> 00:16:59,940
improves the visibility we have into

419
00:16:59,940 --> 00:17:02,579
what's happening inside the dev tools

420
00:17:02,579 --> 00:17:04,439
which is very useful when it doesn't

421
00:17:04,439 --> 00:17:06,599
work as expected

422
00:17:06,599 --> 00:17:09,740
secondly specifying credentials no

423
00:17:09,740 --> 00:17:13,260
credentials include is essential

424
00:17:13,260 --> 00:17:15,240
web browsers have multiple connection

425
00:17:15,240 --> 00:17:19,079
pools per website and if you poison the

426
00:17:19,079 --> 00:17:21,000
wrong connection pool I can promise you

427
00:17:21,000 --> 00:17:23,760
an extremely frustrating time

428
00:17:23,760 --> 00:17:25,980
now when you run this if it's successful

429
00:17:25,980 --> 00:17:28,679
you'll see two two requests Landing in

430
00:17:28,679 --> 00:17:29,940
the dev tools with the same connection

431
00:17:29,940 --> 00:17:30,960
ID

432
00:17:30,960 --> 00:17:32,340
and you should see that the second

433
00:17:32,340 --> 00:17:34,380
response has been affected by the

434
00:17:34,380 --> 00:17:37,320
malicious prefix in the first request as

435
00:17:37,320 --> 00:17:39,980
shown here

436
00:17:41,160 --> 00:17:43,140
if that works well congratulations you

437
00:17:43,140 --> 00:17:45,240
found your first client-side vsync now

438
00:17:45,240 --> 00:17:48,419
it's just time to build an exploit

439
00:17:48,419 --> 00:17:51,179
you've got three main options here first

440
00:17:51,179 --> 00:17:53,340
off you could try and store the user

441
00:17:53,340 --> 00:17:55,620
request somewhere where you can access

442
00:17:55,620 --> 00:17:58,200
it much like what I did on Amazon

443
00:17:58,200 --> 00:18:00,179
uh that works the same as server side

444
00:18:00,179 --> 00:18:01,679
desync so I'm not going to waste time

445
00:18:01,679 --> 00:18:04,980
talking about it now uh secondly there's

446
00:18:04,980 --> 00:18:07,200
an all-new option which is chaining and

447
00:18:07,200 --> 00:18:08,700
pivoting

448
00:18:08,700 --> 00:18:11,400
a client-side desync lets you make your

449
00:18:11,400 --> 00:18:13,620
Victims web browser send arbitrary

450
00:18:13,620 --> 00:18:16,620
requests arbitrary strings of bytes

451
00:18:16,620 --> 00:18:18,480
to the Target website

452
00:18:18,480 --> 00:18:21,419
so that turns their browser into your

453
00:18:21,419 --> 00:18:23,460
personal attack platform and it puts

454
00:18:23,460 --> 00:18:25,320
extra attack surface within your Reach

455
00:18:25,320 --> 00:18:27,539
For example you can make them put log

456
00:18:27,539 --> 00:18:29,880
for Shell payloads wherever you like and

457
00:18:29,880 --> 00:18:31,620
send those to internal systems that you

458
00:18:31,620 --> 00:18:33,900
can't directly access and you can even

459
00:18:33,900 --> 00:18:36,660
hit authenticated attack service using

460
00:18:36,660 --> 00:18:39,179
their using their credentials in a

461
00:18:39,179 --> 00:18:40,799
approach that's a bit like cross-site

462
00:18:40,799 --> 00:18:42,780
request forgery but more powerful

463
00:18:42,780 --> 00:18:44,880
because you don't have the same browser

464
00:18:44,880 --> 00:18:47,220
implemented restrictions on what

465
00:18:47,220 --> 00:18:49,679
requests you can send

466
00:18:49,679 --> 00:18:51,660
I'm going to focus on directly

467
00:18:51,660 --> 00:18:54,600
exploiting the end user now I've tried

468
00:18:54,600 --> 00:18:56,220
quite a few different techniques for

469
00:18:56,220 --> 00:18:58,679
this and had the most success with two

470
00:18:58,679 --> 00:19:00,900
well-known gadgets from server-side

471
00:19:00,900 --> 00:19:03,720
request smuggling with certain tweaks

472
00:19:03,720 --> 00:19:05,880
applied to overcome some of the

473
00:19:05,880 --> 00:19:08,220
challenges that we're going to encounter

474
00:19:08,220 --> 00:19:09,360
so

475
00:19:09,360 --> 00:19:11,179
that's the methodology let's try

476
00:19:11,179 --> 00:19:15,600
applying it with some case studies

477
00:19:15,600 --> 00:19:17,820
first off we're going to exploit a

478
00:19:17,820 --> 00:19:19,799
straightforward vulnerability that

479
00:19:19,799 --> 00:19:22,440
affected a huge number of websites using

480
00:19:22,440 --> 00:19:24,720
the accumbai CDN

481
00:19:24,720 --> 00:19:26,760
here the desync Vector is nice and

482
00:19:26,760 --> 00:19:29,640
simple you just do a post request that

483
00:19:29,640 --> 00:19:32,100
triggers a redirect from the front end

484
00:19:32,100 --> 00:19:34,140
and now ignore the content length

485
00:19:34,140 --> 00:19:36,960
causing a client-side desicc

486
00:19:36,960 --> 00:19:39,480
confirming this in a browser is also

487
00:19:39,480 --> 00:19:42,240
nice and simple so here I've crafted the

488
00:19:42,240 --> 00:19:44,400
malicious prefix in Orange so that when

489
00:19:44,400 --> 00:19:47,100
the browser follows the server redirects

490
00:19:47,100 --> 00:19:49,260
it's just going to end up getting the

491
00:19:49,260 --> 00:19:52,919
contents of the robot's txt file

492
00:19:52,919 --> 00:19:56,340
now for our exploit I'm going to use the

493
00:19:56,340 --> 00:19:58,679
head technique if you're not familiar

494
00:19:58,679 --> 00:20:01,620
with this technique it's documented in

495
00:20:01,620 --> 00:20:03,360
more detail in last year's presentation

496
00:20:03,360 --> 00:20:06,960
on HTTP 2 but the gist is we use the

497
00:20:06,960 --> 00:20:08,780
head method to queue up multiple

498
00:20:08,780 --> 00:20:11,880
responses that when combined are harmful

499
00:20:11,880 --> 00:20:13,200
in their browser

500
00:20:13,200 --> 00:20:16,559
and it's that simple if you're doing a

501
00:20:16,559 --> 00:20:18,299
server-side desync

502
00:20:18,299 --> 00:20:20,640
but because this is client site there's

503
00:20:20,640 --> 00:20:22,919
a couple of extra things that we need to

504
00:20:22,919 --> 00:20:24,780
fix first

505
00:20:24,780 --> 00:20:26,760
first problem is that the initial

506
00:20:26,760 --> 00:20:28,620
response coming back to the browser is a

507
00:20:28,620 --> 00:20:30,600
redirect and so the browser will

508
00:20:30,600 --> 00:20:32,700
immediately follow that and that's the

509
00:20:32,700 --> 00:20:34,440
request that will get hit by the poison

510
00:20:34,440 --> 00:20:37,740
socket and that will break our attack

511
00:20:37,740 --> 00:20:40,559
second issue is something I'll call the

512
00:20:40,559 --> 00:20:42,660
Stacked response problem

513
00:20:42,660 --> 00:20:44,880
whenever Chrome reads in a response from

514
00:20:44,880 --> 00:20:45,960
the server

515
00:20:45,960 --> 00:20:48,240
it deliberately does a little overread

516
00:20:48,240 --> 00:20:51,179
on the TCP socket to see if the server

517
00:20:51,179 --> 00:20:54,120
has sent more data than expected

518
00:20:54,120 --> 00:20:57,020
and if Chrome sees any additional the

519
00:20:57,020 --> 00:21:00,900
data it quietly drops the connection and

520
00:21:00,900 --> 00:21:03,360
breaks our attack

521
00:21:03,360 --> 00:21:05,280
fortunately we can fix both of these

522
00:21:05,280 --> 00:21:07,860
issues fairly easily on this target so

523
00:21:07,860 --> 00:21:09,480
you can fix the Stacked response problem

524
00:21:09,480 --> 00:21:12,120
by adding a cash Buster to the request

525
00:21:12,120 --> 00:21:14,760
which means it causes a cash Miss on the

526
00:21:14,760 --> 00:21:16,620
front end goes all the way to the back

527
00:21:16,620 --> 00:21:18,360
end and that incurs such a big time

528
00:21:18,360 --> 00:21:21,539
delay that by the time it gets back

529
00:21:21,539 --> 00:21:23,640
Chrome has already done the overread and

530
00:21:23,640 --> 00:21:26,340
therefore hasn't seen it and the exploit

531
00:21:26,340 --> 00:21:27,840
works

532
00:21:27,840 --> 00:21:29,880
and secondly we can easily stop the

533
00:21:29,880 --> 00:21:31,740
browser from following the redirect by

534
00:21:31,740 --> 00:21:34,740
changing mode no cores to mode cores

535
00:21:34,740 --> 00:21:36,659
causing an exception when the redirect

536
00:21:36,659 --> 00:21:38,880
is seen which we can then catch and

537
00:21:38,880 --> 00:21:42,380
continue with our exploit

538
00:21:42,480 --> 00:21:45,059
for our next Target we'll hit Cisco's

539
00:21:45,059 --> 00:21:48,059
web VPN and here causing a desync is

540
00:21:48,059 --> 00:21:49,799
even easier you just do a post request

541
00:21:49,799 --> 00:21:51,960
to their home page

542
00:21:51,960 --> 00:21:55,020
using this we can easily trigger an

543
00:21:55,020 --> 00:21:57,360
unexpected redirect to our website which

544
00:21:57,360 --> 00:22:00,240
could in theory let us hijack a

545
00:22:00,240 --> 00:22:02,340
JavaScript resource load and take full

546
00:22:02,340 --> 00:22:04,260
control of the site

547
00:22:04,260 --> 00:22:05,940
the problem is

548
00:22:05,940 --> 00:22:08,640
when a browser renders a page it loads

549
00:22:08,640 --> 00:22:10,620
all the resources at more or less the

550
00:22:10,620 --> 00:22:12,539
same time and that makes it really hard

551
00:22:12,539 --> 00:22:14,880
to ensure that we hijack the correct

552
00:22:14,880 --> 00:22:16,559
request

553
00:22:16,559 --> 00:22:18,720
fortunately there's a solution here

554
00:22:18,720 --> 00:22:20,760
because this redirect response coming

555
00:22:20,760 --> 00:22:23,700
back to the user is cachable

556
00:22:23,700 --> 00:22:27,000
so if we poison the connection with this

557
00:22:27,000 --> 00:22:28,919
response and then navigate the browser

558
00:22:28,919 --> 00:22:31,620
to this slash win.js Javascript file

559
00:22:31,620 --> 00:22:34,020
that we want to poison the browser is

560
00:22:34,020 --> 00:22:35,280
going to see this redirect and get

561
00:22:35,280 --> 00:22:37,260
bounced back to our site but it will

562
00:22:37,260 --> 00:22:41,039
also save that redirect in its cache so

563
00:22:41,039 --> 00:22:43,440
when they land back on our website we

564
00:22:43,440 --> 00:22:45,780
can send them on to the login page on

565
00:22:45,780 --> 00:22:48,419
the VPN which then tries to import that

566
00:22:48,419 --> 00:22:50,400
JavaScript resource and ends up loading

567
00:22:50,400 --> 00:22:53,159
the poisoned version from the cache and

568
00:22:53,159 --> 00:22:55,320
gives us full control of that page and

569
00:22:55,320 --> 00:22:58,879
hopefully their passwords

570
00:22:59,520 --> 00:23:00,659
so

571
00:23:00,659 --> 00:23:03,419
I reported this to Cisco and they didn't

572
00:23:03,419 --> 00:23:06,480
reply for a while and then when they did

573
00:23:06,480 --> 00:23:07,620
and they said actually they're going to

574
00:23:07,620 --> 00:23:08,940
deprecate this product

575
00:23:08,940 --> 00:23:10,320
so they're not going to bother fixing

576
00:23:10,320 --> 00:23:13,020
this issue but to their credit they are

577
00:23:13,020 --> 00:23:16,980
issuing a CV and an advisory for it

578
00:23:16,980 --> 00:23:20,340
next up uh we're going to hit the main

579
00:23:20,340 --> 00:23:22,559
website of Vemma site

580
00:23:22,559 --> 00:23:26,580
so on this website you could trigger a

581
00:23:26,580 --> 00:23:30,000
desync using a URL encoded forward slash

582
00:23:30,000 --> 00:23:32,940
once again I don't really know why but

583
00:23:32,940 --> 00:23:34,919
unfortunately that wasn't the only thing

584
00:23:34,919 --> 00:23:37,740
a bit unusual about their setup for

585
00:23:37,740 --> 00:23:40,020
reasons that I sadly don't have time to

586
00:23:40,020 --> 00:23:42,900
explain to get a working exploit I had

587
00:23:42,900 --> 00:23:44,640
to send a head request with an

588
00:23:44,640 --> 00:23:47,280
incomplete chunked body and then tune

589
00:23:47,280 --> 00:23:49,020
the size of the follow-up request so

590
00:23:49,020 --> 00:23:51,059
that it's slotted inside that trailing

591
00:23:51,059 --> 00:23:52,380
chunk

592
00:23:52,380 --> 00:23:56,340
now the interesting thing here is this

593
00:23:56,340 --> 00:23:58,799
approach is exclusive to client-side

594
00:23:58,799 --> 00:24:00,659
desync because if you're doing a server

595
00:24:00,659 --> 00:24:02,039
side that you think you don't control

596
00:24:02,039 --> 00:24:04,080
what the next request will be and

597
00:24:04,080 --> 00:24:05,880
therefore you can't accurate accurately

598
00:24:05,880 --> 00:24:08,460
predict its size and so attempting this

599
00:24:08,460 --> 00:24:10,799
technique will fail

600
00:24:10,799 --> 00:24:13,260
so it's worth bearing in mind that

601
00:24:13,260 --> 00:24:14,880
although client-side decent can be

602
00:24:14,880 --> 00:24:17,100
painful sometimes you do have some extra

603
00:24:17,100 --> 00:24:20,940
options available to you

604
00:24:20,940 --> 00:24:22,679
speaking of painful

605
00:24:22,679 --> 00:24:25,020
for our final case study we're going to

606
00:24:25,020 --> 00:24:27,059
Target pulse secure VPN

607
00:24:27,059 --> 00:24:29,520
here you can trigger a desync doing a

608
00:24:29,520 --> 00:24:32,280
post request to slash robots txt

609
00:24:32,280 --> 00:24:34,980
and just like Cisco's VPN they've got

610
00:24:34,980 --> 00:24:37,620
host header redirect Gadget that I'd

611
00:24:37,620 --> 00:24:39,240
like to use to hijack a JavaScript

612
00:24:39,240 --> 00:24:40,320
import

613
00:24:40,320 --> 00:24:42,780
but this time the redirect isn't

614
00:24:42,780 --> 00:24:44,340
cachable

615
00:24:44,340 --> 00:24:46,799
so we can't do cash poisoning and we're

616
00:24:46,799 --> 00:24:49,020
in this scenario where our attack timing

617
00:24:49,020 --> 00:24:51,539
is crucial and therefore I had to take

618
00:24:51,539 --> 00:24:53,820
three key steps to make this attack

619
00:24:53,820 --> 00:24:56,820
at least a teeny bit reliable

620
00:24:56,820 --> 00:24:59,280
first off I pre-connect the victim's

621
00:24:59,280 --> 00:25:01,740
browser with the Target website to

622
00:25:01,740 --> 00:25:04,200
reduce the effects of network Jitter on

623
00:25:04,200 --> 00:25:06,480
the on the attack timings to be honest

624
00:25:06,480 --> 00:25:08,039
this probably doesn't actually make any

625
00:25:08,039 --> 00:25:12,120
difference but it does work uh the more

626
00:25:12,120 --> 00:25:13,559
importantly

627
00:25:13,559 --> 00:25:16,020
it's essential that we can have multiple

628
00:25:16,020 --> 00:25:19,740
attempts at our at our attack because it

629
00:25:19,740 --> 00:25:22,140
may fail but a failed attack

630
00:25:22,140 --> 00:25:24,059
and leaves the user on the Target

631
00:25:24,059 --> 00:25:27,720
website so I was able to resolve this by

632
00:25:27,720 --> 00:25:29,580
opening an extra Tab and just running

633
00:25:29,580 --> 00:25:32,400
that attack inside that tab

634
00:25:32,400 --> 00:25:34,679
finally if the attack fails and the

635
00:25:34,679 --> 00:25:36,679
browser ends up caching the genuine

636
00:25:36,679 --> 00:25:39,659
non-poisoned Javascript file then we'll

637
00:25:39,659 --> 00:25:41,460
have to wait for that file to expire

638
00:25:41,460 --> 00:25:42,960
from their cache which could take weeks

639
00:25:42,960 --> 00:25:44,700
so it's essential that that never

640
00:25:44,700 --> 00:25:45,659
happens

641
00:25:45,659 --> 00:25:48,419
but I was able to avoid that by finding

642
00:25:48,419 --> 00:25:51,659
a page on the pulse secure VPN that add

643
00:25:51,659 --> 00:25:53,580
a JavaScript import that never got

644
00:25:53,580 --> 00:25:56,100
cached because the file the Javascript

645
00:25:56,100 --> 00:25:57,480
file wasn't actually present and just

646
00:25:57,480 --> 00:26:00,179
always for a foot

647
00:26:00,179 --> 00:26:03,059
so by stitching all of that together I

648
00:26:03,059 --> 00:26:05,159
built a proof of concept but we'll just

649
00:26:05,159 --> 00:26:06,960
see a quick video of here hopefully so

650
00:26:06,960 --> 00:26:09,120
you see the extra tab pops open loads

651
00:26:09,120 --> 00:26:11,159
the target page a couple of times and

652
00:26:11,159 --> 00:26:13,380
eventually our payload fires and we get

653
00:26:13,380 --> 00:26:15,659
a full control of the site

654
00:26:15,659 --> 00:26:18,179
I've reported that to pulse secure and

655
00:26:18,179 --> 00:26:20,760
they they said they fixed it last week

656
00:26:20,760 --> 00:26:22,559
but I couldn't find any advisory for or

657
00:26:22,559 --> 00:26:24,600
anything so I'm not 100 sure what's

658
00:26:24,600 --> 00:26:28,760
happening there uh but there we go

659
00:26:28,860 --> 00:26:31,980
so that was client side desync now

660
00:26:31,980 --> 00:26:34,980
we saw earlier that slowing down and

661
00:26:34,980 --> 00:26:38,520
pausing can reveal useful information

662
00:26:38,520 --> 00:26:40,799
it turns out pausing can also create

663
00:26:40,799 --> 00:26:43,260
entire new desync vulnerabilities that

664
00:26:43,260 --> 00:26:45,659
are hilariously simple

665
00:26:45,659 --> 00:26:47,880
to trigger a pause-based async when

666
00:26:47,880 --> 00:26:49,860
speaking directly to a vulnerable server

667
00:26:49,860 --> 00:26:51,840
you can start by just sending your

668
00:26:51,840 --> 00:26:54,419
headers promising a body and then just

669
00:26:54,419 --> 00:26:56,880
waiting and eventually the vulnerable

670
00:26:56,880 --> 00:26:59,279
server will hit some kind of timeout and

671
00:26:59,279 --> 00:27:00,900
send a response and then you just follow

672
00:27:00,900 --> 00:27:04,080
up with the rest of your of your request

673
00:27:04,080 --> 00:27:06,179
and the next one and that will be

674
00:27:06,179 --> 00:27:08,520
interpreted as a separate second request

675
00:27:08,520 --> 00:27:11,220
causing it basic

676
00:27:11,220 --> 00:27:14,100
I initially found this Behavior

677
00:27:14,100 --> 00:27:17,340
on varnish through an extreme fluke it

678
00:27:17,340 --> 00:27:19,080
was multiple different bugs in my code

679
00:27:19,080 --> 00:27:22,919
combined that made me find this and once

680
00:27:22,919 --> 00:27:25,200
I realized this before this this was a

681
00:27:25,200 --> 00:27:27,240
thing I went looking for it I found that

682
00:27:27,240 --> 00:27:30,240
it also works on Apache

683
00:27:30,240 --> 00:27:33,000
it seems to tend to happen on an end

684
00:27:33,000 --> 00:27:34,860
point when the server is generating a

685
00:27:34,860 --> 00:27:37,200
response itself instead of forwarding

686
00:27:37,200 --> 00:27:39,419
the request to the to the back end or

687
00:27:39,419 --> 00:27:42,059
handing it off to the application layer

688
00:27:42,059 --> 00:27:45,539
now this single vulnerability enables

689
00:27:45,539 --> 00:27:49,140
two completely different attacks

690
00:27:49,140 --> 00:27:51,840
first off let's use it to cause an

691
00:27:51,840 --> 00:27:55,080
old-school server-side desync for this

692
00:27:55,080 --> 00:27:56,940
to work you need a vulnerable server

693
00:27:56,940 --> 00:27:58,860
like Apache

694
00:27:58,860 --> 00:28:01,440
as a back end and a front-end server

695
00:28:01,440 --> 00:28:04,559
that streams the request specifically it

696
00:28:04,559 --> 00:28:06,120
needs to forward the request headers

697
00:28:06,120 --> 00:28:09,000
without waiting for the entire request

698
00:28:09,000 --> 00:28:12,000
body to a life

699
00:28:12,000 --> 00:28:14,700
now what you do is what will you send

700
00:28:14,700 --> 00:28:16,799
your request you promise to send more

701
00:28:16,799 --> 00:28:18,120
data and then you wait for this timeout

702
00:28:18,120 --> 00:28:19,080
to happen

703
00:28:19,080 --> 00:28:23,039
as before but we don't necessarily what

704
00:28:23,039 --> 00:28:25,500
the front end may not actually read in

705
00:28:25,500 --> 00:28:27,480
this timeout response and pass it on to

706
00:28:27,480 --> 00:28:30,000
us until it's seen us send a complete

707
00:28:30,000 --> 00:28:31,500
request

708
00:28:31,500 --> 00:28:34,380
so what you need to do in practice is

709
00:28:34,380 --> 00:28:36,120
send your headers and then pause until

710
00:28:36,120 --> 00:28:37,860
you think a timeout has probably

711
00:28:37,860 --> 00:28:40,500
happened on the back end and just then

712
00:28:40,500 --> 00:28:43,620
just continue unprompted and send the

713
00:28:43,620 --> 00:28:45,419
body and the follow-up which should

714
00:28:45,419 --> 00:28:48,900
trigger a poison response I've updated

715
00:28:48,900 --> 00:28:51,240
the turbo Intruder tool to add a couple

716
00:28:51,240 --> 00:28:53,460
of different ways of saying where you

717
00:28:53,460 --> 00:28:56,460
want to do this delay and how long it

718
00:28:56,460 --> 00:28:58,320
should wait for before sending the rest

719
00:28:58,320 --> 00:29:00,600
of the request

720
00:29:00,600 --> 00:29:02,580
so you do this and that's it you've got

721
00:29:02,580 --> 00:29:05,520
a nice server side desync

722
00:29:05,520 --> 00:29:07,380
at this point well you might be thinking

723
00:29:07,380 --> 00:29:09,299
well that sounds really nice but what

724
00:29:09,299 --> 00:29:12,779
front ends actually stream requests like

725
00:29:12,779 --> 00:29:13,679
this

726
00:29:13,679 --> 00:29:15,659
oh well I just found out yesterday that

727
00:29:15,659 --> 00:29:18,720
this is much more common with hv2 but

728
00:29:18,720 --> 00:29:20,580
that's not what I was looking at when I

729
00:29:20,580 --> 00:29:23,760
did this Research In This research I

730
00:29:23,760 --> 00:29:25,980
found it works on Amazon's application

731
00:29:25,980 --> 00:29:27,539
load balancer

732
00:29:27,539 --> 00:29:30,480
but there's one extra catch they've got

733
00:29:30,480 --> 00:29:32,100
a defensive measure called early

734
00:29:32,100 --> 00:29:34,260
response detection

735
00:29:34,260 --> 00:29:35,880
if they see a response come back from

736
00:29:35,880 --> 00:29:38,399
the back end before the request from the

737
00:29:38,399 --> 00:29:40,260
client is completed then they'll bend

738
00:29:40,260 --> 00:29:42,539
the connection and our attack will fail

739
00:29:42,539 --> 00:29:45,840
I mean thrash the connection sorry uh

740
00:29:45,840 --> 00:29:49,679
if fortunately this is designed to

741
00:29:49,679 --> 00:29:52,140
prevent bugs rather than actual

742
00:29:52,140 --> 00:29:54,240
attackers from what I can tell so it's

743
00:29:54,240 --> 00:29:56,940
really quite easy to bypass

744
00:29:56,940 --> 00:29:58,980
you just need to identify the back end

745
00:29:58,980 --> 00:30:01,080
timeout and then make the orange payload

746
00:30:01,080 --> 00:30:03,360
hit the front end in the time window

747
00:30:03,360 --> 00:30:05,460
between the back end generating the

748
00:30:05,460 --> 00:30:06,960
timeout response

749
00:30:06,960 --> 00:30:09,360
and the front end seeing it this

750
00:30:09,360 --> 00:30:11,700
basically this attack may require a few

751
00:30:11,700 --> 00:30:15,620
attempts but it's ultimately worth it

752
00:30:16,740 --> 00:30:18,840
there's one final catch you may

753
00:30:18,840 --> 00:30:21,720
encounter which is uh quite a lot worse

754
00:30:21,720 --> 00:30:23,279
this is when the front end and the

755
00:30:23,279 --> 00:30:25,140
back-end server have the same timeout

756
00:30:25,140 --> 00:30:26,640
configured

757
00:30:26,640 --> 00:30:28,740
on application load balancer that

758
00:30:28,740 --> 00:30:31,200
creates a race condition within a race

759
00:30:31,200 --> 00:30:32,760
condition that we need to hit which

760
00:30:32,760 --> 00:30:36,179
makes life really painful I it may be

761
00:30:36,179 --> 00:30:38,700
possible to reset the front-end timer

762
00:30:38,700 --> 00:30:41,340
without resetting the back end timer by

763
00:30:41,340 --> 00:30:42,659
sending some data that the front end

764
00:30:42,659 --> 00:30:44,399
sees but then normalizes and doesn't

765
00:30:44,399 --> 00:30:46,740
send on to the back end but nothing I

766
00:30:46,740 --> 00:30:48,539
tried actually worked

767
00:30:48,539 --> 00:30:50,640
eventually I just gave up of trying

768
00:30:50,640 --> 00:30:52,080
things and I was like you know what I'm

769
00:30:52,080 --> 00:30:53,760
just gonna leave set a vanilla attack

770
00:30:53,760 --> 00:30:55,919
running and just leave it going and just

771
00:30:55,919 --> 00:30:59,279
forget about it and uh 66 hours later it

772
00:30:59,279 --> 00:31:00,480
was successful

773
00:31:00,480 --> 00:31:04,640
so this is one for the patient

774
00:31:05,220 --> 00:31:07,980
so that was server side pause based

775
00:31:07,980 --> 00:31:10,860
async that just leaves us with one final

776
00:31:10,860 --> 00:31:13,980
question which is is there such a thing

777
00:31:13,980 --> 00:31:18,240
as a client side poor space desync now I

778
00:31:18,240 --> 00:31:21,059
couldn't find any way to make a browser

779
00:31:21,059 --> 00:31:23,399
pause halfway through issuing a request

780
00:31:23,399 --> 00:31:26,100
but SSL and TLS don't stop attackers

781
00:31:26,100 --> 00:31:28,380
from delaying your traffic so there is a

782
00:31:28,380 --> 00:31:30,659
potential attack the attacker triggers a

783
00:31:30,659 --> 00:31:32,100
request in the browser that's really big

784
00:31:32,100 --> 00:31:34,679
it gets split into multiple packets and

785
00:31:34,679 --> 00:31:36,240
if the attacker can delay the right

786
00:31:36,240 --> 00:31:39,480
packet that can cause a pause-based

787
00:31:39,480 --> 00:31:42,799
client-side desync

788
00:31:43,020 --> 00:31:45,179
good I've got time so that might sound a

789
00:31:45,179 --> 00:31:48,240
bit theoretical but this is blackout so

790
00:31:48,240 --> 00:31:50,220
I've made a proof of concept that uses

791
00:31:50,220 --> 00:31:52,740
this technique on a default Apache based

792
00:31:52,740 --> 00:31:55,039
website to execute arbitrary JavaScript

793
00:31:55,039 --> 00:31:58,260
and kind of break TLS

794
00:31:58,260 --> 00:32:02,100
uh on the in the victim's browser uh the

795
00:32:02,100 --> 00:32:04,100
attack code looks kind of like a normal

796
00:32:04,100 --> 00:32:06,659
client-side desync except I've injected

797
00:32:06,659 --> 00:32:08,880
tons of padding so the request gets

798
00:32:08,880 --> 00:32:10,860
split into multiple packets

799
00:32:10,860 --> 00:32:13,799
on the attacker's middle box I've just

800
00:32:13,799 --> 00:32:16,020
used the following code to implement the

801
00:32:16,020 --> 00:32:18,899
delay it just says slow down traffic by

802
00:32:18,899 --> 00:32:21,360
60 seconds if it's going to the Target

803
00:32:21,360 --> 00:32:24,600
website and it's in between 700 and 1

804
00:32:24,600 --> 00:32:26,880
300 bytes in size

805
00:32:26,880 --> 00:32:29,880
uh this demo is not the most reliable

806
00:32:29,880 --> 00:32:31,559
because it's based on how the browser

807
00:32:31,559 --> 00:32:34,799
decides just to split the packets up uh

808
00:32:34,799 --> 00:32:37,080
but it works most of the time we'll see

809
00:32:37,080 --> 00:32:39,379
what happens

810
00:32:40,080 --> 00:32:45,299
so two and we got to kill uh so on the

811
00:32:45,299 --> 00:32:47,640
on the victim side I'm just gonna Sox

812
00:32:47,640 --> 00:32:52,559
proxy the victim through a box on Amazon

813
00:32:52,559 --> 00:32:54,960
uh that's being man in the middle just

814
00:32:54,960 --> 00:32:56,520
so the local network doesn't mess things

815
00:32:56,520 --> 00:32:57,779
up too much

816
00:32:57,779 --> 00:33:00,480
uh and here I'm just connecting to the

817
00:33:00,480 --> 00:33:03,200
attacker machine

818
00:33:04,220 --> 00:33:07,359
[Applause]

819
00:33:10,860 --> 00:33:13,260
all right so you can see the code I've

820
00:33:13,260 --> 00:33:15,480
got here to slow down

821
00:33:15,480 --> 00:33:18,240
the packets of a certain size and uh the

822
00:33:18,240 --> 00:33:19,799
only difference from the slide is that

823
00:33:19,799 --> 00:33:22,019
I've changed the vulnerable website

824
00:33:22,019 --> 00:33:24,299
timeout from 60 seconds which is the

825
00:33:24,299 --> 00:33:26,940
default down to five seconds so the demo

826
00:33:26,940 --> 00:33:29,340
doesn't take ages so I'm only injecting

827
00:33:29,340 --> 00:33:32,279
a six second delay on the packets

828
00:33:32,279 --> 00:33:35,100
now I've just launched TCP dump on the

829
00:33:35,100 --> 00:33:37,740
attacker system and

830
00:33:37,740 --> 00:33:39,840
if the attack is successful what we'll

831
00:33:39,840 --> 00:33:42,539
see in TCP dump is a few packets going

832
00:33:42,539 --> 00:33:44,340
through and then a particular large

833
00:33:44,340 --> 00:33:46,440
packet being resent by the browser

834
00:33:46,440 --> 00:33:48,960
multiple times because the browser knows

835
00:33:48,960 --> 00:33:50,580
that it hasn't reached the server yet

836
00:33:50,580 --> 00:33:52,580
and it thinks it might have been

837
00:33:52,580 --> 00:33:55,260
dropped but the attack is actually just

838
00:33:55,260 --> 00:33:58,260
slowing down all those packets and it'll

839
00:33:58,260 --> 00:34:00,120
eventually let them through and if

840
00:34:00,120 --> 00:34:01,980
everything works that will cause a

841
00:34:01,980 --> 00:34:03,840
server-side desync and cores a nice

842
00:34:03,840 --> 00:34:06,899
alert box to pop up in the browser

843
00:34:06,899 --> 00:34:09,480
so uh let's let's see if it works shall

844
00:34:09,480 --> 00:34:11,659
we

845
00:34:11,699 --> 00:34:13,560
okay we can see one packets being resent

846
00:34:13,560 --> 00:34:15,300
a bunch of times here so any second now

847
00:34:15,300 --> 00:34:17,280
in the browser

848
00:34:17,280 --> 00:34:19,679
hopefully there we go

849
00:34:19,679 --> 00:34:21,719
excellent

850
00:34:21,719 --> 00:34:22,909
cool

851
00:34:22,909 --> 00:34:26,178
[Applause]

852
00:34:29,520 --> 00:34:32,899
cool thanks so yep that's one that's one

853
00:34:32,899 --> 00:34:35,040
vulnerability but as you've seen two

854
00:34:35,040 --> 00:34:36,839
completely different attacks coming out

855
00:34:36,839 --> 00:34:38,820
of it uh we can skip my backup video

856
00:34:38,820 --> 00:34:41,879
because it actually worked uh

857
00:34:41,879 --> 00:34:44,060
foreign

858
00:34:45,679 --> 00:34:47,879
that was the final attack of the

859
00:34:47,879 --> 00:34:51,719
presentation so let's talk about defense

860
00:34:51,719 --> 00:34:54,719
these attacks almost all exploit HTTP

861
00:34:54,719 --> 00:34:59,099
one so if you can use hb2 end to end if

862
00:34:59,099 --> 00:35:01,260
you can't use it end to end I would not

863
00:35:01,260 --> 00:35:03,839
recommend doing HP downgrading from H2

864
00:35:03,839 --> 00:35:06,960
to H1 because that introduces extra

865
00:35:06,960 --> 00:35:08,599
risks

866
00:35:08,599 --> 00:35:12,180
the second point is and I'm genuinely

867
00:35:12,180 --> 00:35:14,640
not sure what other people are going to

868
00:35:14,640 --> 00:35:16,200
think about this but

869
00:35:16,200 --> 00:35:19,440
honestly it's really easy to make a HTTP

870
00:35:19,440 --> 00:35:22,260
one server and it's really hard to make

871
00:35:22,260 --> 00:35:25,859
a secure HTTP one server so my advice

872
00:35:25,859 --> 00:35:28,079
would be avoid coding your own HP one

873
00:35:28,079 --> 00:35:29,640
server if you can

874
00:35:29,640 --> 00:35:31,980
that said I think software diversity is

875
00:35:31,980 --> 00:35:34,800
a great thing uh so here's some advice

876
00:35:34,800 --> 00:35:36,960
if you're a server maintainer and you

877
00:35:36,960 --> 00:35:39,720
want to harden your server or patch an

878
00:35:39,720 --> 00:35:42,119
existing client-side desync

879
00:35:42,119 --> 00:35:44,099
vulnerability

880
00:35:44,099 --> 00:35:45,960
there's a bunch of further reading

881
00:35:45,960 --> 00:35:47,880
available the three key things I would

882
00:35:47,880 --> 00:35:49,260
suggest are check out the white paper

883
00:35:49,260 --> 00:35:51,660
that's the top link have a go at the

884
00:35:51,660 --> 00:35:53,520
online Labs that we've made to get some

885
00:35:53,520 --> 00:35:55,200
practical experience and then try out

886
00:35:55,200 --> 00:35:57,359
like my code to scan and find and

887
00:35:57,359 --> 00:35:59,940
exploit some real vulnerable systems uh

888
00:35:59,940 --> 00:36:01,260
feel free to chat me an email to let me

889
00:36:01,260 --> 00:36:02,520
know how it goes

890
00:36:02,520 --> 00:36:04,500
there's also a presentation this

891
00:36:04,500 --> 00:36:06,839
afternoon that is kind of related to

892
00:36:06,839 --> 00:36:08,220
this one actually so you might want to

893
00:36:08,220 --> 00:36:09,780
check that out

894
00:36:09,780 --> 00:36:12,420
uh the three key things to take away

895
00:36:12,420 --> 00:36:15,480
are the request is a lie

896
00:36:15,480 --> 00:36:18,619
HTTP one connection we use is harmful

897
00:36:18,619 --> 00:36:22,740
and all you need is a server taken by

898
00:36:22,740 --> 00:36:24,060
surprise

899
00:36:24,060 --> 00:36:26,640
I'll take about three minutes of

900
00:36:26,640 --> 00:36:28,560
questions now if you have any more after

901
00:36:28,560 --> 00:36:30,540
that feel free to come and chat to me at

902
00:36:30,540 --> 00:36:32,700
the back or just chat me an email time

903
00:36:32,700 --> 00:36:34,680
to forget to follow me on Twitter

904
00:36:34,680 --> 00:36:36,680
thank you for listening

905
00:36:36,680 --> 00:36:46,500
[Applause]

906
00:36:46,500 --> 00:36:50,420
so we've got two minutes any questions

907
00:36:50,460 --> 00:36:53,420
foreign

908
00:36:58,700 --> 00:37:00,660
thank you

909
00:37:00,660 --> 00:37:03,480
[Applause]

910
00:37:03,480 --> 00:37:03,580
[Music]

911
00:37:03,580 --> 00:37:06,740
[Applause]

912
00:37:06,740 --> 00:37:11,689
[Music]

