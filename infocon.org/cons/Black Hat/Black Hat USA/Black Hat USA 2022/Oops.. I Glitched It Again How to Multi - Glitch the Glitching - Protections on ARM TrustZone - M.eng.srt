1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,400 --> 00:00:12,679
it's my honor to present Marvin zoss

3
00:00:12,679 --> 00:00:15,740
thank you

4
00:00:16,500 --> 00:00:18,000
thank you Jack for this content

5
00:00:18,000 --> 00:00:20,640
reduction and yeah I just want to State

6
00:00:20,640 --> 00:00:23,039
before I even start it's really an honor

7
00:00:23,039 --> 00:00:25,980
to be here at blackhead 25 and I met a

8
00:00:25,980 --> 00:00:27,480
lot of cool people having a really great

9
00:00:27,480 --> 00:00:29,820
time and I hope all of you are doing the

10
00:00:29,820 --> 00:00:30,779
very same

11
00:00:30,779 --> 00:00:33,239
and yeah with this I would like to

12
00:00:33,239 --> 00:00:34,739
welcome all of you to my journey of

13
00:00:34,739 --> 00:00:36,239
fault injection countermeasures the

14
00:00:36,239 --> 00:00:38,100
person name architecture as well as

15
00:00:38,100 --> 00:00:39,600
defeating both the aforementioned by

16
00:00:39,600 --> 00:00:41,700
using my very own multiple voltage fault

17
00:00:41,700 --> 00:00:43,379
injection Hardware design but maybe

18
00:00:43,379 --> 00:00:45,180
first of all who am I actually to talk

19
00:00:45,180 --> 00:00:47,219
to you about fault injection

20
00:00:47,219 --> 00:00:49,980
so my name is Marvin Zas and I'm an

21
00:00:49,980 --> 00:00:51,480
graduate in the field of I.T security

22
00:00:51,480 --> 00:00:54,300
from Technical University largest my

23
00:00:54,300 --> 00:00:56,280
expertise is mostly in embedded system

24
00:00:56,280 --> 00:00:57,840
security as well as low-level software

25
00:00:57,840 --> 00:00:59,760
security and back in data I've been

26
00:00:59,760 --> 00:01:01,559
working for quite some time now for a

27
00:01:01,559 --> 00:01:02,820
really awesome research team which is

28
00:01:02,820 --> 00:01:05,640
referred to as the system security lab I

29
00:01:05,640 --> 00:01:07,020
have the great privilege to work with

30
00:01:07,020 --> 00:01:09,720
highly intelligent people over here and

31
00:01:09,720 --> 00:01:11,460
just in case you are around the corner

32
00:01:11,460 --> 00:01:12,840
you know just reach out to me and let's

33
00:01:12,840 --> 00:01:15,060
see what we can break together all right

34
00:01:15,060 --> 00:01:18,119
and this brings me to my motivation so

35
00:01:18,119 --> 00:01:20,100
kind of a central question which we have

36
00:01:20,100 --> 00:01:22,080
been asking what says was well how

37
00:01:22,080 --> 00:01:24,060
secure are actually these highly secure

38
00:01:24,060 --> 00:01:26,220
labeled embedded processes when it comes

39
00:01:26,220 --> 00:01:28,380
to multiple fault injection and in order

40
00:01:28,380 --> 00:01:29,939
to evaluate this question we had to

41
00:01:29,939 --> 00:01:31,680
develop a novel and especially a cheap

42
00:01:31,680 --> 00:01:33,840
way of injecting multiple faults because

43
00:01:33,840 --> 00:01:36,060
I have to State here that well

44
00:01:36,060 --> 00:01:38,040
commercial setups which are dedicated to

45
00:01:38,040 --> 00:01:39,600
multiple laser fault injection already

46
00:01:39,600 --> 00:01:42,299
exist however these come at such high

47
00:01:42,299 --> 00:01:44,579
cost that it is practically infeasible

48
00:01:44,579 --> 00:01:46,079
for private security researchers to

49
00:01:46,079 --> 00:01:48,840
afford them and yeah let's now have a

50
00:01:48,840 --> 00:01:50,399
quick background on fault injection

51
00:01:50,399 --> 00:01:52,619
technical quick history basically and we

52
00:01:52,619 --> 00:01:54,840
will have here a strong focus on voltage

53
00:01:54,840 --> 00:01:56,040
fault injection

54
00:01:56,040 --> 00:01:58,680
so the complexity of voltage fault

55
00:01:58,680 --> 00:02:00,540
injection attacks increased until the

56
00:02:00,540 --> 00:02:02,579
point we are right now researchers

57
00:02:02,579 --> 00:02:05,460
started back in 1997 I would say by

58
00:02:05,460 --> 00:02:07,200
injecting rather simple voltage faults

59
00:02:07,200 --> 00:02:10,139
as we know them today and well these

60
00:02:10,139 --> 00:02:12,239
were very simple and the hands had a low

61
00:02:12,239 --> 00:02:14,640
success rate and a low reliability of

62
00:02:14,640 --> 00:02:15,840
the overall attack

63
00:02:15,840 --> 00:02:17,640
and quite early it has to be said but

64
00:02:17,640 --> 00:02:19,440
Ringgit are introduce to fault injection

65
00:02:19,440 --> 00:02:22,080
countermeasures on the instruction level

66
00:02:22,080 --> 00:02:24,120
which are used to mitigate fault

67
00:02:24,120 --> 00:02:26,040
injection attacks however in this work

68
00:02:26,040 --> 00:02:27,780
we are going to see how their approach

69
00:02:27,780 --> 00:02:29,220
can be broken by using our multiple

70
00:02:29,220 --> 00:02:31,440
fault injection approach

71
00:02:31,440 --> 00:02:33,959
at some point column of linen joined the

72
00:02:33,959 --> 00:02:36,900
game basically and introduced to his

73
00:02:36,900 --> 00:02:38,819
crowbar circuitry to perform voltage

74
00:02:38,819 --> 00:02:40,620
fault injection attacks this has shown

75
00:02:40,620 --> 00:02:43,019
to enhance the reliability of single

76
00:02:43,019 --> 00:02:44,879
voltage fault injection text

77
00:02:44,879 --> 00:02:48,000
Christian cudera utilized this

78
00:02:48,000 --> 00:02:50,280
um fault inject Global Secretary of

79
00:02:50,280 --> 00:02:53,459
college of Lin and injected voltage

80
00:02:53,459 --> 00:02:55,260
Falls based on a negative voltage level

81
00:02:55,260 --> 00:02:57,420
this has shown to increase the timely

82
00:02:57,420 --> 00:02:59,879
resolution of our voltage faults other

83
00:02:59,879 --> 00:03:01,500
researchers went another way namely

84
00:03:01,500 --> 00:03:03,720
butato at all and what they did is to

85
00:03:03,720 --> 00:03:05,700
literally shape the glitch by using

86
00:03:05,700 --> 00:03:09,000
digital to analog converters and yeah by

87
00:03:09,000 --> 00:03:10,800
this they have shown that the

88
00:03:10,800 --> 00:03:13,680
reliability of a single voltage fault

89
00:03:13,680 --> 00:03:16,200
injection attack can even be enhanced

90
00:03:16,200 --> 00:03:18,180
most recently we've been observing a

91
00:03:18,180 --> 00:03:19,620
vast amount of different work which has

92
00:03:19,620 --> 00:03:22,019
been proposed which utilizes different

93
00:03:22,019 --> 00:03:24,239
onboard Regulators to generate this

94
00:03:24,239 --> 00:03:25,560
faulty environment

95
00:03:25,560 --> 00:03:27,480
and this is a really important step

96
00:03:27,480 --> 00:03:29,420
because we're starting to get away from

97
00:03:29,420 --> 00:03:32,159
this physical access threat model which

98
00:03:32,159 --> 00:03:33,599
is commonly the downside of fault

99
00:03:33,599 --> 00:03:35,519
injection attacks as well as such a

100
00:03:35,519 --> 00:03:37,140
normal attacks and we are starting to

101
00:03:37,140 --> 00:03:39,780
get towards an even remote fault

102
00:03:39,780 --> 00:03:41,640
injection setup I would say

103
00:03:41,640 --> 00:03:44,940
really important work and probably the

104
00:03:44,940 --> 00:03:46,920
most related work to this one has been

105
00:03:46,920 --> 00:03:49,319
the work proposed by order at all and

106
00:03:49,319 --> 00:03:51,239
what they did is to inject a single

107
00:03:51,239 --> 00:03:53,159
voltage fault in order to attack the

108
00:03:53,159 --> 00:03:55,440
trust Zone N however at this point the

109
00:03:55,440 --> 00:03:57,060
authors did not realize that there were

110
00:03:57,060 --> 00:03:58,920
additional protections on the internal

111
00:03:58,920 --> 00:04:01,319
HP was available which successfully

112
00:04:01,319 --> 00:04:02,879
mitigate their attack

113
00:04:02,879 --> 00:04:05,459
and well basically here we are right now

114
00:04:05,459 --> 00:04:08,340
at Becker 25. to show you how to inject

115
00:04:08,340 --> 00:04:10,080
up to four consecutive faults in order

116
00:04:10,080 --> 00:04:11,280
to fully break the Trust online

117
00:04:11,280 --> 00:04:13,560
architecture and yeah if you would like

118
00:04:13,560 --> 00:04:15,540
to know how we did this stay tuned

119
00:04:15,540 --> 00:04:17,699
all right there's another part of our

120
00:04:17,699 --> 00:04:19,440
motivation was basically the this

121
00:04:19,440 --> 00:04:21,720
yawning gap between different adversary

122
00:04:21,720 --> 00:04:23,759
models in the IC in the field of I.T

123
00:04:23,759 --> 00:04:25,139
Security in general

124
00:04:25,139 --> 00:04:28,259
and this Gap even enlarges whenever we

125
00:04:28,259 --> 00:04:30,120
talk about Hardware security because we

126
00:04:30,120 --> 00:04:31,680
are just really dependent on different

127
00:04:31,680 --> 00:04:33,960
tooling over here the left you see a lab

128
00:04:33,960 --> 00:04:35,400
which is quite similar to this I'm

129
00:04:35,400 --> 00:04:38,520
currently using and well I assume that

130
00:04:38,520 --> 00:04:41,100
this looks familiar to at least most of

131
00:04:41,100 --> 00:04:41,880
the

132
00:04:41,880 --> 00:04:43,919
um Hardware focused security researchers

133
00:04:43,919 --> 00:04:46,259
who attend this call it just has to be

134
00:04:46,259 --> 00:04:48,180
said our labs are not beautiful in fact

135
00:04:48,180 --> 00:04:50,940
but they suffice our daily purposes

136
00:04:50,940 --> 00:04:53,280
so to the right you see the focus ion

137
00:04:53,280 --> 00:04:54,720
beam lip of the ultrastructural bio

138
00:04:54,720 --> 00:04:56,639
Imaging core facility of The Institute

139
00:04:56,639 --> 00:04:59,100
pastel in France and based on such a

140
00:04:59,100 --> 00:05:00,720
focused I-beam you could for example go

141
00:05:00,720 --> 00:05:03,360
ahead and alter the doping of a single

142
00:05:03,360 --> 00:05:05,040
transistor inside your integrated

143
00:05:05,040 --> 00:05:06,840
circuit even after it has been produced

144
00:05:06,840 --> 00:05:10,440
which is just crazy you know and if you

145
00:05:10,440 --> 00:05:12,479
are like me which means your affiliation

146
00:05:12,479 --> 00:05:14,880
goes to the in the direction of this

147
00:05:14,880 --> 00:05:17,820
left lip over here well we are incapable

148
00:05:17,820 --> 00:05:20,520
of Performing similar attacks and what

149
00:05:20,520 --> 00:05:22,440
we commonly have to do is to improvise

150
00:05:22,440 --> 00:05:24,419
in order to reach our goals and

151
00:05:24,419 --> 00:05:26,400
improvising is exactly what also we did

152
00:05:26,400 --> 00:05:27,780
within this work

153
00:05:27,780 --> 00:05:30,180
so let's now discuss some a quick

154
00:05:30,180 --> 00:05:33,180
background on a background which is

155
00:05:33,180 --> 00:05:34,680
required in order to follow the rest of

156
00:05:34,680 --> 00:05:36,419
this work and here we are going to focus

157
00:05:36,419 --> 00:05:38,460
first of all on fault injection and

158
00:05:38,460 --> 00:05:40,199
afterwards reason about why the

159
00:05:40,199 --> 00:05:41,880
transition M architecture cannot be

160
00:05:41,880 --> 00:05:43,320
overcome by using single fault injection

161
00:05:43,320 --> 00:05:44,220
text

162
00:05:44,220 --> 00:05:46,800
all right so fault injection methods in

163
00:05:46,800 --> 00:05:48,900
general concern rapid changes in an

164
00:05:48,900 --> 00:05:50,340
integrated circuits environment in order

165
00:05:50,340 --> 00:05:52,259
to cause a specific and exploitable

166
00:05:52,259 --> 00:05:54,360
misbehavior in the past mainly four

167
00:05:54,360 --> 00:05:55,500
different types of fault injection

168
00:05:55,500 --> 00:05:56,820
techniques have been used which are

169
00:05:56,820 --> 00:05:58,979
clock fault injection electromagnetic

170
00:05:58,979 --> 00:06:00,600
fault injection Optical fault injection

171
00:06:00,600 --> 00:06:02,220
or laser fault injection more

172
00:06:02,220 --> 00:06:04,500
specifically as well as voltage fault

173
00:06:04,500 --> 00:06:06,720
injection and due to the use of analog

174
00:06:06,720 --> 00:06:07,979
components which are referred to as

175
00:06:07,979 --> 00:06:10,440
Facebook Loops or PLS in short these

176
00:06:10,440 --> 00:06:12,060
clock forward injection attacks to the

177
00:06:12,060 --> 00:06:14,520
left must be considered impractical as

178
00:06:14,520 --> 00:06:16,740
of today and in fact I would like to use

179
00:06:16,740 --> 00:06:18,539
this opportunity of public speaking to

180
00:06:18,539 --> 00:06:20,100
officially declare clock fault injection

181
00:06:20,100 --> 00:06:21,240
as being dead

182
00:06:21,240 --> 00:06:23,160
this leaves us with basically three

183
00:06:23,160 --> 00:06:24,900
promising candidates to perform single

184
00:06:24,900 --> 00:06:27,000
fault injection attacks and throughout

185
00:06:27,000 --> 00:06:28,259
this work we are going to focus on

186
00:06:28,259 --> 00:06:30,479
voltage fault injection for reasons

187
00:06:30,479 --> 00:06:33,120
which we'll discuss once introducing to

188
00:06:33,120 --> 00:06:35,220
multiple fault injection for now let's

189
00:06:35,220 --> 00:06:37,139
just see how voltage fault injection is

190
00:06:37,139 --> 00:06:39,120
commonly performed

191
00:06:39,120 --> 00:06:41,160
all right so here you see different

192
00:06:41,160 --> 00:06:43,139
voltage ranges depicted over time the

193
00:06:43,139 --> 00:06:44,819
green range indicates that we are within

194
00:06:44,819 --> 00:06:46,080
our specified operating conditions

195
00:06:46,080 --> 00:06:48,060
whereas the red range indicates that we

196
00:06:48,060 --> 00:06:49,319
have left our specified operating

197
00:06:49,319 --> 00:06:51,180
conditions what you commonly do in

198
00:06:51,180 --> 00:06:52,680
voltage fault injection is you keep your

199
00:06:52,680 --> 00:06:54,180
supply voltage in the specified range

200
00:06:54,180 --> 00:06:55,740
for most of the time once the

201
00:06:55,740 --> 00:06:57,360
synchronizing trigger is a certain tie

202
00:06:57,360 --> 00:06:59,460
an internal counter starts counting

203
00:06:59,460 --> 00:07:00,960
upward until the specified offset has

204
00:07:00,960 --> 00:07:02,819
been reached once this offset has been

205
00:07:02,819 --> 00:07:04,560
reached we inject the transient fault

206
00:07:04,560 --> 00:07:06,840
and by this uh this fault is

207
00:07:06,840 --> 00:07:09,180
parameterized by our width parameter and

208
00:07:09,180 --> 00:07:10,800
yeah afterwards just continue as

209
00:07:10,800 --> 00:07:11,819
intended

210
00:07:11,819 --> 00:07:13,680
all right let's now see what we are

211
00:07:13,680 --> 00:07:15,419
capable of doing once we found us some

212
00:07:15,419 --> 00:07:18,440
proper parameters

213
00:07:18,900 --> 00:07:21,000
and this is perfectly described by our

214
00:07:21,000 --> 00:07:23,520
void model so default model for voltage

215
00:07:23,520 --> 00:07:26,460
fault injection states that a single

216
00:07:26,460 --> 00:07:28,319
voltage for to be injected mainly

217
00:07:28,319 --> 00:07:30,479
affects our internal processors pipeline

218
00:07:30,479 --> 00:07:32,699
stages this means uh

219
00:07:32,699 --> 00:07:35,639
yeah to the right you see an exemplary

220
00:07:35,639 --> 00:07:37,620
load modified store cycle based on the

221
00:07:37,620 --> 00:07:39,900
arm architecture and this is supposed to

222
00:07:39,900 --> 00:07:42,060
illustrate the implications made by our

223
00:07:42,060 --> 00:07:44,460
fault model so once we go now ahead and

224
00:07:44,460 --> 00:07:46,020
inject a single voltage fault we could

225
00:07:46,020 --> 00:07:48,120
for example corrupt instruction fetches

226
00:07:48,120 --> 00:07:50,400
but we could also go ahead and corrupt

227
00:07:50,400 --> 00:07:52,259
data loads or corrupt even data stores

228
00:07:52,259 --> 00:07:54,599
but finally and what is most commonly

229
00:07:54,599 --> 00:07:57,060
utilized we could skip over the

230
00:07:57,060 --> 00:07:59,099
execution of a whole instruction and

231
00:07:59,099 --> 00:08:00,660
through this work also we are going to

232
00:08:00,660 --> 00:08:02,699
focus on the skipping of instruction due

233
00:08:02,699 --> 00:08:04,380
to its deterministic nature basically

234
00:08:04,380 --> 00:08:08,819
and in this context we Define our fault

235
00:08:08,819 --> 00:08:10,440
Target as the instruction which would

236
00:08:10,440 --> 00:08:12,479
like to skip such a fall Target is

237
00:08:12,479 --> 00:08:14,400
assumed to be hit whenever we

238
00:08:14,400 --> 00:08:16,680
successfully skipped over its execution

239
00:08:16,680 --> 00:08:18,720
all right let's now have an exemplary

240
00:08:18,720 --> 00:08:21,300
fault injection tech for this assume

241
00:08:21,300 --> 00:08:22,800
there is some kind of a memory net

242
00:08:22,800 --> 00:08:24,780
register which is critical to your

243
00:08:24,780 --> 00:08:26,520
secure configuration for example

244
00:08:26,520 --> 00:08:28,319
exemplary firmware to write to this

245
00:08:28,319 --> 00:08:29,940
version some may look like the following

246
00:08:29,940 --> 00:08:31,440
we first of all loaded address

247
00:08:31,440 --> 00:08:33,240
afterwards move a value which we'd like

248
00:08:33,240 --> 00:08:34,559
to store and finally we'll store back

249
00:08:34,559 --> 00:08:36,899
this value let's unroll this execution

250
00:08:36,899 --> 00:08:38,219
and talk about voltage fault injection

251
00:08:38,219 --> 00:08:40,260
and what we would like to do here is to

252
00:08:40,260 --> 00:08:42,240
skip over this time into this memory net

253
00:08:42,240 --> 00:08:44,219
register so there's still instruction

254
00:08:44,219 --> 00:08:46,860
over here represents our for Target now

255
00:08:46,860 --> 00:08:48,720
once executing this load instruction we

256
00:08:48,720 --> 00:08:50,100
keep our Logic Supply in a specified

257
00:08:50,100 --> 00:08:51,779
range same holds true for this move

258
00:08:51,779 --> 00:08:53,760
instruction however once we come close

259
00:08:53,760 --> 00:08:55,560
to our fall Target we inject the

260
00:08:55,560 --> 00:08:56,880
transient fault and by this skip over

261
00:08:56,880 --> 00:08:58,080
the assignment to this duplicate

262
00:08:58,080 --> 00:09:01,200
register to this memory net register

263
00:09:01,200 --> 00:09:03,420
all right due to the criticality of

264
00:09:03,420 --> 00:09:06,420
fault injection attacks well several

265
00:09:06,420 --> 00:09:07,740
countermeasures have been proposed by

266
00:09:07,740 --> 00:09:09,360
Academia and these are mainly divided

267
00:09:09,360 --> 00:09:11,160
into instruction level countermeasures

268
00:09:11,160 --> 00:09:13,140
on the one side as well as Hardware

269
00:09:13,140 --> 00:09:14,459
level countermeasures on the other side

270
00:09:14,459 --> 00:09:16,200
what you commonly do in instruction

271
00:09:16,200 --> 00:09:18,420
level countermeasures is some sort of a

272
00:09:18,420 --> 00:09:21,120
duplication based approach so well for

273
00:09:21,120 --> 00:09:22,500
example you perform some computation

274
00:09:22,500 --> 00:09:24,779
perform all the same permutation all

275
00:09:24,779 --> 00:09:26,580
over again afterwards you check both

276
00:09:26,580 --> 00:09:28,440
your outputs for equality and check them

277
00:09:28,440 --> 00:09:30,480
both for equality again and it should be

278
00:09:30,480 --> 00:09:32,100
easy to see for you at this point that

279
00:09:32,100 --> 00:09:34,080
whenever we skip a single step of this

280
00:09:34,080 --> 00:09:36,060
procedure well the corresponding other

281
00:09:36,060 --> 00:09:37,500
step will still be able to detect your

282
00:09:37,500 --> 00:09:39,120
fault injection attack

283
00:09:39,120 --> 00:09:41,459
all right on the hardware level instead

284
00:09:41,459 --> 00:09:43,920
we would commonly have to deploy

285
00:09:43,920 --> 00:09:46,019
physical sensors along our integrated

286
00:09:46,019 --> 00:09:48,060
circuit and afterwards use these

287
00:09:48,060 --> 00:09:50,940
physical sensors to constantly monitor

288
00:09:50,940 --> 00:09:53,700
our integrated circuit environment

289
00:09:53,700 --> 00:09:55,380
I'm telling you all this because it's

290
00:09:55,380 --> 00:09:57,000
quite interesting to see that this

291
00:09:57,000 --> 00:09:58,500
instruction level countermeasures to the

292
00:09:58,500 --> 00:10:00,180
left have made it into recent

293
00:10:00,180 --> 00:10:01,920
microcontroller units

294
00:10:01,920 --> 00:10:04,260
all right and I think or in my opinion

295
00:10:04,260 --> 00:10:05,700
this is a great step in the right

296
00:10:05,700 --> 00:10:07,740
direction however we are going to see

297
00:10:07,740 --> 00:10:10,399
how to break them

298
00:10:10,620 --> 00:10:13,200
so here are a couple of examples taken

299
00:10:13,200 --> 00:10:15,120
from different data sheets from nxp of

300
00:10:15,120 --> 00:10:17,279
these duplication based approaches as an

301
00:10:17,279 --> 00:10:20,279
example this one is supposed to protect

302
00:10:20,279 --> 00:10:22,920
against malicious attacks whereas this

303
00:10:22,920 --> 00:10:24,360
one is supposed to provide a better

304
00:10:24,360 --> 00:10:25,800
protection against malicious hacking

305
00:10:25,800 --> 00:10:28,560
attacks such as glitter takes yeah you

306
00:10:28,560 --> 00:10:30,240
get the basic idea right

307
00:10:30,240 --> 00:10:32,580
and a question I was asking me when

308
00:10:32,580 --> 00:10:34,260
going through this data sheets was well

309
00:10:34,260 --> 00:10:36,600
how does this actually prevent fault

310
00:10:36,600 --> 00:10:38,160
transaction text so let's have another

311
00:10:38,160 --> 00:10:41,399
look in this you now deploy two memory

312
00:10:41,399 --> 00:10:43,500
map registers instead of only one and

313
00:10:43,500 --> 00:10:45,240
exemplary firmware to write to this

314
00:10:45,240 --> 00:10:46,620
registers may look like the following

315
00:10:46,620 --> 00:10:48,959
you load the address of your original

316
00:10:48,959 --> 00:10:51,180
register which is on the top you move

317
00:10:51,180 --> 00:10:52,800
the value you would like to store and

318
00:10:52,800 --> 00:10:54,660
you finally store back this value you

319
00:10:54,660 --> 00:10:57,060
execute some stuff in between and do the

320
00:10:57,060 --> 00:10:58,860
very same for your duplicate duplicated

321
00:10:58,860 --> 00:11:00,600
register basically

322
00:11:00,600 --> 00:11:02,700
all right let's unroll this execution

323
00:11:02,700 --> 00:11:04,140
again and talk about voltage fault

324
00:11:04,140 --> 00:11:06,060
injection and what we would like to do

325
00:11:06,060 --> 00:11:08,339
here is to perform the very same attack

326
00:11:08,339 --> 00:11:10,740
we've been performing before so this two

327
00:11:10,740 --> 00:11:12,240
instruction over here represents our

328
00:11:12,240 --> 00:11:14,640
fault Target now once executing this

329
00:11:14,640 --> 00:11:16,800
load instruction well we keep our budget

330
00:11:16,800 --> 00:11:18,660
Supply in a specified range same holds

331
00:11:18,660 --> 00:11:19,860
true for this move instruction however

332
00:11:19,860 --> 00:11:21,660
once we come close to our full Target we

333
00:11:21,660 --> 00:11:23,100
inject the transient fold and by this

334
00:11:23,100 --> 00:11:24,959
skip over the assignment to original

335
00:11:24,959 --> 00:11:26,279
register

336
00:11:26,279 --> 00:11:29,040
now as we are capable of only injecting

337
00:11:29,040 --> 00:11:31,200
a single voltage fault well all these

338
00:11:31,200 --> 00:11:32,940
other steps would still be executed as

339
00:11:32,940 --> 00:11:35,519
intended and at this point we introduce

340
00:11:35,519 --> 00:11:37,500
an inconsistency between our original as

341
00:11:37,500 --> 00:11:39,779
well as our duplicated register

342
00:11:39,779 --> 00:11:41,880
and this inconsistency is then going to

343
00:11:41,880 --> 00:11:43,860
be detected by by your processor which

344
00:11:43,860 --> 00:11:45,600
basically locks itself down into some

345
00:11:45,600 --> 00:11:47,700
error on the stage

346
00:11:47,700 --> 00:11:49,920
so a question I was asking you here is

347
00:11:49,920 --> 00:11:51,240
can this instruction level

348
00:11:51,240 --> 00:11:52,980
countermeasures be vetted by simply

349
00:11:52,980 --> 00:11:55,079
injecting multiple faults

350
00:11:55,079 --> 00:11:57,600
and if we think about injecting multiple

351
00:11:57,600 --> 00:11:59,700
faults well which fault injection method

352
00:11:59,700 --> 00:12:01,980
shall we choose so let's reason about

353
00:12:01,980 --> 00:12:02,880
this

354
00:12:02,880 --> 00:12:05,040
in order to implement multiple multiple

355
00:12:05,040 --> 00:12:06,420
fault injection we need a fault

356
00:12:06,420 --> 00:12:08,339
injection method which is first of all

357
00:12:08,339 --> 00:12:09,959
basically alive right clock fault

358
00:12:09,959 --> 00:12:12,899
injection is directly out so we also

359
00:12:12,899 --> 00:12:15,120
need to be capable of injecting faults

360
00:12:15,120 --> 00:12:17,160
on a rapid succession and the problem

361
00:12:17,160 --> 00:12:19,140
with electromagnetic fault injection is

362
00:12:19,140 --> 00:12:21,240
that after each fault injection attempt

363
00:12:21,240 --> 00:12:23,760
you would have to recharge your internal

364
00:12:23,760 --> 00:12:25,860
capacitor and an internal capacitor Bank

365
00:12:25,860 --> 00:12:27,959
basically with a lot of static current

366
00:12:27,959 --> 00:12:30,420
and this just takes too long

367
00:12:30,420 --> 00:12:32,459
also we would like to be as cheap as

368
00:12:32,459 --> 00:12:34,079
possible right just just have a look at

369
00:12:34,079 --> 00:12:35,640
our lab over here I mean we obviously

370
00:12:35,640 --> 00:12:38,459
got no money left so The Logical

371
00:12:38,459 --> 00:12:41,579
consequence would be to go with voltage

372
00:12:41,579 --> 00:12:44,220
voltage at least for this work

373
00:12:44,220 --> 00:12:46,440
all right let's now introduced the trust

374
00:12:46,440 --> 00:12:48,420
and M architecture and due to time

375
00:12:48,420 --> 00:12:49,800
constraints I won't be able to provide

376
00:12:49,800 --> 00:12:52,560
an in-depth um knowledge basically

377
00:12:52,560 --> 00:12:54,540
around the trusts on M architecture

378
00:12:54,540 --> 00:12:56,940
itself and instead I'm going to focus on

379
00:12:56,940 --> 00:12:59,399
the question why can the Trust on an

380
00:12:59,399 --> 00:13:00,959
architecture not be overcome by using

381
00:13:00,959 --> 00:13:03,120
single-fold injection attacks and by

382
00:13:03,120 --> 00:13:05,040
this we'll basically trade brevity for

383
00:13:05,040 --> 00:13:07,260
precision and in case some members of

384
00:13:07,260 --> 00:13:08,700
the Armed family are watching this talk

385
00:13:08,700 --> 00:13:12,480
well I hope you guys can forgive me all

386
00:13:12,480 --> 00:13:14,700
right so let's just assume you get your

387
00:13:14,700 --> 00:13:16,980
rb8m core up and running and this core

388
00:13:16,980 --> 00:13:18,779
is now capable of splitting your 32-bit

389
00:13:18,779 --> 00:13:21,300
address base into basically well secure

390
00:13:21,300 --> 00:13:22,860
as well as non-secure regions let's just

391
00:13:22,860 --> 00:13:24,240
keep it like this

392
00:13:24,240 --> 00:13:26,880
and this how the separation works is as

393
00:13:26,880 --> 00:13:28,860
follows there are three components

394
00:13:28,860 --> 00:13:31,019
involved which are forwarded every

395
00:13:31,019 --> 00:13:32,639
address your core accesses during

396
00:13:32,639 --> 00:13:35,160
runtime and these are the memory

397
00:13:35,160 --> 00:13:37,440
protection unit mpu which determines the

398
00:13:37,440 --> 00:13:38,700
privilege level which is required in

399
00:13:38,700 --> 00:13:40,440
order to access your letter and this

400
00:13:40,440 --> 00:13:41,160
address

401
00:13:41,160 --> 00:13:42,600
and then you have your secure

402
00:13:42,600 --> 00:13:44,639
attribution unit SAU as well as your

403
00:13:44,639 --> 00:13:46,079
implementation defined attribution and

404
00:13:46,079 --> 00:13:48,779
IDU which both determine the security

405
00:13:48,779 --> 00:13:50,399
state which is required in order to

406
00:13:50,399 --> 00:13:52,440
access this address well the final

407
00:13:52,440 --> 00:13:54,120
Security State is then determined by

408
00:13:54,120 --> 00:13:55,560
just choosing the most restrictive

409
00:13:55,560 --> 00:13:59,040
output of both usau as well as your idiu

410
00:13:59,040 --> 00:14:01,139
all right we are in a memory map

411
00:14:01,139 --> 00:14:03,360
architecture right which means we have a

412
00:14:03,360 --> 00:14:04,680
bunch of components basically which are

413
00:14:04,680 --> 00:14:06,959
mapped in our address space and these

414
00:14:06,959 --> 00:14:08,760
are interconnected by using some kind of

415
00:14:08,760 --> 00:14:10,860
a central System bus in arm-based

416
00:14:10,860 --> 00:14:12,600
systems this bus is referred to as the

417
00:14:12,600 --> 00:14:14,700
advanced high performance bus or HB in

418
00:14:14,700 --> 00:14:15,420
short

419
00:14:15,420 --> 00:14:17,519
now based on the configuration of this

420
00:14:17,519 --> 00:14:20,040
SAU and IDU our code now for example go

421
00:14:20,040 --> 00:14:21,899
ahead and Define our RAM and our flash

422
00:14:21,899 --> 00:14:24,600
as being non-seq and our peripherals as

423
00:14:24,600 --> 00:14:25,680
being secure

424
00:14:25,680 --> 00:14:28,139
whenever our course now executing in a

425
00:14:28,139 --> 00:14:29,820
non-secure state well it could only

426
00:14:29,820 --> 00:14:31,079
access these components which have

427
00:14:31,079 --> 00:14:33,120
explicitly been defined as being

428
00:14:33,120 --> 00:14:35,940
non-secure and once our course executed

429
00:14:35,940 --> 00:14:37,560
in a single state instead it could

430
00:14:37,560 --> 00:14:39,180
additionally access our secure

431
00:14:39,180 --> 00:14:40,980
peripherals in this example

432
00:14:40,980 --> 00:14:43,800
all right now problems arise however

433
00:14:43,800 --> 00:14:45,540
when we attempt to introduce other bus

434
00:14:45,540 --> 00:14:47,459
Masters because these have commonly not

435
00:14:47,459 --> 00:14:49,980
heard of Trust on them before and well

436
00:14:49,980 --> 00:14:51,540
if you think about directly attaching

437
00:14:51,540 --> 00:14:53,519
them to the internet of your HP well

438
00:14:53,519 --> 00:14:55,620
this would totally break the security

439
00:14:55,620 --> 00:14:57,300
introduced by your trust and

440
00:14:57,300 --> 00:14:59,459
architecture actually because this could

441
00:14:59,459 --> 00:15:01,320
arbitrarily access your secure as well

442
00:15:01,320 --> 00:15:04,740
as your non-secure securable HP slaves

443
00:15:04,740 --> 00:15:06,779
all right what has been done to fix this

444
00:15:06,779 --> 00:15:09,060
is the following we first of all

445
00:15:09,060 --> 00:15:11,459
introduce what we call a gate here in

446
00:15:11,459 --> 00:15:13,560
front of every other securable HP slaves

447
00:15:13,560 --> 00:15:15,480
and these Gates must be provided in

448
00:15:15,480 --> 00:15:17,399
addition to the address our Security

449
00:15:17,399 --> 00:15:19,680
State as well as our privileged level

450
00:15:19,680 --> 00:15:21,779
for our bus Masters to generate this

451
00:15:21,779 --> 00:15:23,399
required cycle information we would have

452
00:15:23,399 --> 00:15:24,779
to differentiate now between two

453
00:15:24,779 --> 00:15:27,120
different scenarios and the first one we

454
00:15:27,120 --> 00:15:29,100
have a trust on an aware bus master and

455
00:15:29,100 --> 00:15:30,540
then the second one we have a trust on

456
00:15:30,540 --> 00:15:32,040
an underwear bus master

457
00:15:32,040 --> 00:15:33,839
all right for our trust and Emma webass

458
00:15:33,839 --> 00:15:34,920
mustard the solution is quite simple

459
00:15:34,920 --> 00:15:36,660
because we could just directly go ahead

460
00:15:36,660 --> 00:15:39,000
and provide the required information to

461
00:15:39,000 --> 00:15:42,300
the interns of our HB whereas for our

462
00:15:42,300 --> 00:15:45,360
trust on an aware bus Masters well it's

463
00:15:45,360 --> 00:15:47,579
slightly more complicated here we first

464
00:15:47,579 --> 00:15:49,079
of all have to introduce what we call a

465
00:15:49,079 --> 00:15:51,540
wrapper unit here which then based on

466
00:15:51,540 --> 00:15:54,300
its internal configuration is going to

467
00:15:54,300 --> 00:15:57,120
to to to generate this required cycle

468
00:15:57,120 --> 00:15:58,500
information and provide it to the

469
00:15:58,500 --> 00:16:00,480
internals of our HP

470
00:16:00,480 --> 00:16:02,459
all right let's now see what previous

471
00:16:02,459 --> 00:16:05,160
work has been doing so previous work

472
00:16:05,160 --> 00:16:07,620
injected a single voltage fault in into

473
00:16:07,620 --> 00:16:09,660
the configuration of the SAU over here

474
00:16:09,660 --> 00:16:12,779
and based on this fault injection well a

475
00:16:12,779 --> 00:16:14,459
single non-secure region was to be

476
00:16:14,459 --> 00:16:16,920
expanded whenever the IDU in conjunction

477
00:16:16,920 --> 00:16:19,560
stated that this region that this region

478
00:16:19,560 --> 00:16:21,300
was in fact non-secure

479
00:16:21,300 --> 00:16:24,000
all right now the the authors did not

480
00:16:24,000 --> 00:16:26,040
realize that there were this additional

481
00:16:26,040 --> 00:16:27,779
trusts on Gates available on the

482
00:16:27,779 --> 00:16:30,060
internet of our bus and at this point I

483
00:16:30,060 --> 00:16:32,100
hope all of you see that whatever we are

484
00:16:32,100 --> 00:16:34,440
going to to attack over here is

485
00:16:34,440 --> 00:16:36,839
afterwards to be detected over here so

486
00:16:36,839 --> 00:16:39,300
unless we are able to well inject

487
00:16:39,300 --> 00:16:41,759
another fault here there's actually not

488
00:16:41,759 --> 00:16:43,019
much we can do

489
00:16:43,019 --> 00:16:45,000
and this is perfectly stated by all the

490
00:16:45,000 --> 00:16:47,880
different data sheets I'm going to read

491
00:16:47,880 --> 00:16:51,180
out loud this example of an nxp data

492
00:16:51,180 --> 00:16:54,060
sheet here so if some inconsistency is

493
00:16:54,060 --> 00:16:55,920
detected between the SAU and the HB

494
00:16:55,920 --> 00:16:58,259
secure controller configurations due to

495
00:16:58,259 --> 00:17:00,240
some software error of Ledger Tech the

496
00:17:00,240 --> 00:17:03,000
access to a specific resources blocked

497
00:17:03,000 --> 00:17:05,400
that's a lot to hack in actually and

498
00:17:05,400 --> 00:17:08,040
yeah well we cannot conclude all this by

499
00:17:08,040 --> 00:17:10,500
saying in order to fully break the Trust

500
00:17:10,500 --> 00:17:12,419
online architecture well multiple fault

501
00:17:12,419 --> 00:17:15,000
injection is definitely required all

502
00:17:15,000 --> 00:17:17,040
right let's now see what we decided to

503
00:17:17,040 --> 00:17:19,020
go with to implement multiple fault

504
00:17:19,020 --> 00:17:20,220
injections

505
00:17:20,220 --> 00:17:24,000
and here you see our setup a photography

506
00:17:24,000 --> 00:17:25,919
basically of our setup however at this

507
00:17:25,919 --> 00:17:27,780
point it's rather unimportant to be

508
00:17:27,780 --> 00:17:30,059
honest because this is on a level which

509
00:17:30,059 --> 00:17:32,940
we would like not to go into let's just

510
00:17:32,940 --> 00:17:35,640
instead discuss our abstract setup

511
00:17:35,640 --> 00:17:38,160
and in this we basically have three

512
00:17:38,160 --> 00:17:39,960
different components we first of all

513
00:17:39,960 --> 00:17:41,640
have ourselves basically or the

514
00:17:41,640 --> 00:17:43,679
controlling host system we also have

515
00:17:43,679 --> 00:17:45,240
this multiple fault injection platform

516
00:17:45,240 --> 00:17:47,280
and our device on a test which has

517
00:17:47,280 --> 00:17:48,720
implemented some kind of a security

518
00:17:48,720 --> 00:17:51,360
measure which we would like to overcome

519
00:17:51,360 --> 00:17:53,760
and now we can go ahead and communicate

520
00:17:53,760 --> 00:17:54,900
with this multiple fault injection

521
00:17:54,900 --> 00:17:57,419
platform via USB and by this for example

522
00:17:57,419 --> 00:17:59,580
set the number of voltage Falls to be

523
00:17:59,580 --> 00:18:00,660
injected and the corresponding

524
00:18:00,660 --> 00:18:02,820
parameters in this example you see a

525
00:18:02,820 --> 00:18:05,039
curve to set up because well there is

526
00:18:05,039 --> 00:18:08,640
some Target IO going on and moreover the

527
00:18:08,640 --> 00:18:10,260
trigger the synchronizing trigger signal

528
00:18:10,260 --> 00:18:12,299
is directly asserted High by this device

529
00:18:12,299 --> 00:18:14,400
on a test however our multiple fault

530
00:18:14,400 --> 00:18:15,840
injection platform could also be used to

531
00:18:15,840 --> 00:18:18,179
attack non-cooperative setups basically

532
00:18:18,179 --> 00:18:21,240
all right so now whenever the device on

533
00:18:21,240 --> 00:18:23,460
a test in this case asserts the

534
00:18:23,460 --> 00:18:25,200
synchronizing trigger signal High our

535
00:18:25,200 --> 00:18:27,000
multiple fault injection engine gets

536
00:18:27,000 --> 00:18:29,100
triggered and by this starts to inject

537
00:18:29,100 --> 00:18:31,500
multiple voltage faults based on its

538
00:18:31,500 --> 00:18:33,840
provided configuration to break the

539
00:18:33,840 --> 00:18:35,760
security implemented in this device on a

540
00:18:35,760 --> 00:18:36,900
test

541
00:18:36,900 --> 00:18:38,700
all right let's now have a deeper look

542
00:18:38,700 --> 00:18:40,919
into the internals of our multiple fault

543
00:18:40,919 --> 00:18:42,720
injection engine

544
00:18:42,720 --> 00:18:45,179
in order to understand how we decided to

545
00:18:45,179 --> 00:18:46,799
implement multiple multiple fault

546
00:18:46,799 --> 00:18:48,480
injection however it is first of all

547
00:18:48,480 --> 00:18:50,580
important how to generate a single

548
00:18:50,580 --> 00:18:52,500
voltage fault and here you see a single

549
00:18:52,500 --> 00:18:55,020
voltage fault injection unit and this is

550
00:18:55,020 --> 00:18:57,240
provided a reference clock signal and

551
00:18:57,240 --> 00:18:59,520
whenever a trigger signal is asserted

552
00:18:59,520 --> 00:19:01,980
High well an internal counter would

553
00:19:01,980 --> 00:19:03,720
start counting upward until the offset

554
00:19:03,720 --> 00:19:06,299
which is an input here is reached once

555
00:19:06,299 --> 00:19:08,400
this offset has been reached and default

556
00:19:08,400 --> 00:19:10,620
out signal as I set it high for as long

557
00:19:10,620 --> 00:19:15,240
as we have um for for exactly with

558
00:19:15,240 --> 00:19:17,760
number of clock Cycles all right and one

559
00:19:17,760 --> 00:19:20,160
once all this process has taken place or

560
00:19:20,160 --> 00:19:22,320
for down signal is asserted high for a

561
00:19:22,320 --> 00:19:24,000
single clock period in order to indicate

562
00:19:24,000 --> 00:19:25,919
that the single voltage fault injection

563
00:19:25,919 --> 00:19:27,780
has taken place

564
00:19:27,780 --> 00:19:30,000
now if we are talking about multiple

565
00:19:30,000 --> 00:19:31,620
voltage fault injection well it's

566
00:19:31,620 --> 00:19:33,120
obvious that we need multiple such

567
00:19:33,120 --> 00:19:34,620
single voltage fault injection units

568
00:19:34,620 --> 00:19:36,600
right the question is well how to

569
00:19:36,600 --> 00:19:38,940
combine them actually and it turns out

570
00:19:38,940 --> 00:19:40,440
to be quite simple we can just directly

571
00:19:40,440 --> 00:19:42,480
forward this fold down signal into the

572
00:19:42,480 --> 00:19:44,700
subsequent ones trigger signal

573
00:19:44,700 --> 00:19:47,220
there's the downside with this design I

574
00:19:47,220 --> 00:19:49,679
have to mention well this is a static

575
00:19:49,679 --> 00:19:51,620
setup basically right we cannot really

576
00:19:51,620 --> 00:19:54,360
change the number of voltage faults to

577
00:19:54,360 --> 00:19:56,280
be injected after our Hardware synthesis

578
00:19:56,280 --> 00:19:58,140
took place so what we've been doing

579
00:19:58,140 --> 00:20:00,620
instead is to introduce two additional

580
00:20:00,620 --> 00:20:03,299
multiplexers on these forwarding lines

581
00:20:03,299 --> 00:20:05,580
and once we set the selection line to

582
00:20:05,580 --> 00:20:07,799
zero in this in this example the

583
00:20:07,799 --> 00:20:09,780
multiple fault injection just steps with

584
00:20:09,780 --> 00:20:11,760
the most recent voltage fault to be

585
00:20:11,760 --> 00:20:13,440
injected whereas once we set the

586
00:20:13,440 --> 00:20:15,539
selection line to 1

587
00:20:15,539 --> 00:20:17,400
um our subsequent single voltage for the

588
00:20:17,400 --> 00:20:19,620
injection unit gets triggered and based

589
00:20:19,620 --> 00:20:21,660
on this starts to inject another voltage

590
00:20:21,660 --> 00:20:22,679
fault based on its provided

591
00:20:22,679 --> 00:20:24,360
configuration

592
00:20:24,360 --> 00:20:26,520
so in conclusion we could say due to

593
00:20:26,520 --> 00:20:28,020
these multiplexers we are able to change

594
00:20:28,020 --> 00:20:30,000
the number of and voltage faults to be

595
00:20:30,000 --> 00:20:31,559
injected even after our Hardware

596
00:20:31,559 --> 00:20:34,020
synthesis took place and maybe one more

597
00:20:34,020 --> 00:20:37,320
thing this at this slide here well why

598
00:20:37,320 --> 00:20:39,840
are we actually chaining our single

599
00:20:39,840 --> 00:20:41,700
voltage fault injector units right we

600
00:20:41,700 --> 00:20:44,640
could just for example try to to utilize

601
00:20:44,640 --> 00:20:47,160
multiple triggers but

602
00:20:47,160 --> 00:20:49,440
this is wrong because we would like to

603
00:20:49,440 --> 00:20:52,620
be able to to actually search for

604
00:20:52,620 --> 00:20:55,140
parameters on a Cooperative setup and

605
00:20:55,140 --> 00:20:56,520
then afterwards transfer these

606
00:20:56,520 --> 00:20:58,200
parameters to a non-carbotic setup which

607
00:20:58,200 --> 00:21:01,440
means we have a need of a minimum amount

608
00:21:01,440 --> 00:21:04,440
of synchronizing signals here right

609
00:21:04,440 --> 00:21:06,059
okay

610
00:21:06,059 --> 00:21:08,160
be with me

611
00:21:08,160 --> 00:21:10,260
let me now see what we decided to go

612
00:21:10,260 --> 00:21:12,120
with to to perform our search for

613
00:21:12,120 --> 00:21:14,940
parameters basically okay and I would

614
00:21:14,940 --> 00:21:17,160
like you to recap that

615
00:21:17,160 --> 00:21:20,280
um for every voltage fault which we try

616
00:21:20,280 --> 00:21:23,340
to to inject we have to find basically

617
00:21:23,340 --> 00:21:25,620
two things first of all we have to find

618
00:21:25,620 --> 00:21:27,840
an offset with respect to our timely

619
00:21:27,840 --> 00:21:30,179
invariant trigger signal and then we

620
00:21:30,179 --> 00:21:31,620
have to find a proper width in order to

621
00:21:31,620 --> 00:21:33,059
hit our fault Target

622
00:21:33,059 --> 00:21:35,220
all right now what is commonly done in

623
00:21:35,220 --> 00:21:37,620
in single voltage fault injection is

624
00:21:37,620 --> 00:21:39,780
that you just go ahead and combine all

625
00:21:39,780 --> 00:21:41,280
your parameters basically some kind of a

626
00:21:41,280 --> 00:21:43,679
Brute Force approach right and this is

627
00:21:43,679 --> 00:21:44,940
what it looks like on a physical level

628
00:21:44,940 --> 00:21:48,059
here you see for a given offset that we

629
00:21:48,059 --> 00:21:50,460
try try out different widths basically

630
00:21:50,460 --> 00:21:52,320
and then continue to the subsequent

631
00:21:52,320 --> 00:21:53,460
offset

632
00:21:53,460 --> 00:21:56,159
all right if we would now go ahead and

633
00:21:56,159 --> 00:21:58,080
directly apply this approach to our

634
00:21:58,080 --> 00:22:00,179
multiple fault injection platform well

635
00:22:00,179 --> 00:22:02,220
you can see that this already takes some

636
00:22:02,220 --> 00:22:04,320
time to only search for basically two

637
00:22:04,320 --> 00:22:06,620
parameters right and if you now imagine

638
00:22:06,620 --> 00:22:10,380
well you would have to to to to search

639
00:22:10,380 --> 00:22:12,360
for maybe like three or four different

640
00:22:12,360 --> 00:22:15,299
thoughts voltage fault parameters

641
00:22:15,299 --> 00:22:16,799
long story short this is getting

642
00:22:16,799 --> 00:22:18,059
impracticable

643
00:22:18,059 --> 00:22:20,340
all right and in fact we can show that

644
00:22:20,340 --> 00:22:21,960
each additional voltage fault to be

645
00:22:21,960 --> 00:22:24,720
injected increases the overall surface

646
00:22:24,720 --> 00:22:27,539
by exponential means which is basically

647
00:22:27,539 --> 00:22:29,340
the definition of impracticability right

648
00:22:29,340 --> 00:22:31,980
so we have to be we have to be better

649
00:22:31,980 --> 00:22:33,480
than this

650
00:22:33,480 --> 00:22:35,400
what we decided to go with is to

651
00:22:35,400 --> 00:22:37,020
differentiate between different hitfall

652
00:22:37,020 --> 00:22:38,940
targets and this differentiation may

653
00:22:38,940 --> 00:22:41,880
take place for example based on a

654
00:22:41,880 --> 00:22:43,320
clearly distinguishable Behavior upon

655
00:22:43,320 --> 00:22:46,380
partial success or a challenge change in

656
00:22:46,380 --> 00:22:48,659
the section elimination upon partial

657
00:22:48,659 --> 00:22:51,000
success most commonly by using just a

658
00:22:51,000 --> 00:22:52,559
corporate setup but as I said earlier

659
00:22:52,559 --> 00:22:54,780
you can then go ahead and transfer these

660
00:22:54,780 --> 00:22:56,340
parameters you found by a co-parter

661
00:22:56,340 --> 00:22:58,140
setup and transfer them to a to an even

662
00:22:58,140 --> 00:23:00,000
non-corporative setup right

663
00:23:00,000 --> 00:23:01,740
and yeah basically anything you can

664
00:23:01,740 --> 00:23:03,600
imagine which helps you differentiating

665
00:23:03,600 --> 00:23:06,780
between your different hit fall targets

666
00:23:06,780 --> 00:23:09,179
now once we are able to differentiate we

667
00:23:09,179 --> 00:23:10,740
are able to perform our advanced search

668
00:23:10,740 --> 00:23:13,020
which goes like the following so first

669
00:23:13,020 --> 00:23:14,700
of all we Define an overall success

670
00:23:14,700 --> 00:23:16,679
function which determines whether or not

671
00:23:16,679 --> 00:23:19,140
all of our four Target targets have been

672
00:23:19,140 --> 00:23:21,360
hit at once we then go ahead and Define

673
00:23:21,360 --> 00:23:22,980
partial success functions which

674
00:23:22,980 --> 00:23:25,440
determine whether or not a specific for

675
00:23:25,440 --> 00:23:28,200
target has been hit we now utilize a

676
00:23:28,200 --> 00:23:29,700
single voltage fault to sweep through

677
00:23:29,700 --> 00:23:32,460
all our search space and by this also

678
00:23:32,460 --> 00:23:34,320
record partial successes with respect to

679
00:23:34,320 --> 00:23:36,059
our partial success functions

680
00:23:36,059 --> 00:23:37,980
all right now because we have previously

681
00:23:37,980 --> 00:23:39,840
been chaining our single voltage fault

682
00:23:39,840 --> 00:23:41,580
injection units we would have to

683
00:23:41,580 --> 00:23:43,200
translate the parameters we just found

684
00:23:43,200 --> 00:23:45,360
into relative ones quite simple here

685
00:23:45,360 --> 00:23:47,700
a problem arise however because we do

686
00:23:47,700 --> 00:23:50,220
not know how a previous voltage fault to

687
00:23:50,220 --> 00:23:53,159
be injected affects the succeeding one's

688
00:23:53,159 --> 00:23:55,320
parameters basically and in fact this

689
00:23:55,320 --> 00:23:56,880
cannot be decided because we are leaving

690
00:23:56,880 --> 00:23:58,500
the specified operating conditions

691
00:23:58,500 --> 00:24:00,539
guessing would be totally wrong at this

692
00:24:00,539 --> 00:24:02,520
point and what we've been doing instead

693
00:24:02,520 --> 00:24:04,620
is to generate

694
00:24:04,620 --> 00:24:06,360
um very small intervals from our

695
00:24:06,360 --> 00:24:08,460
parameters basically some plus minus

696
00:24:08,460 --> 00:24:11,280
Delta so to speak and use these small

697
00:24:11,280 --> 00:24:13,380
intervals to throw them into our

698
00:24:13,380 --> 00:24:16,440
integration stage which then performs

699
00:24:16,440 --> 00:24:18,419
some kind of a combined brute force on

700
00:24:18,419 --> 00:24:20,460
all these small intervals right this is

701
00:24:20,460 --> 00:24:22,380
the first stage where our overall attack

702
00:24:22,380 --> 00:24:24,240
is performed for the first time

703
00:24:24,240 --> 00:24:26,760
and hence we do not care too much to

704
00:24:26,760 --> 00:24:28,679
evalu to evaluate our partial success

705
00:24:28,679 --> 00:24:30,840
functions anymore but instead we only

706
00:24:30,840 --> 00:24:32,460
evaluate our overall success functions

707
00:24:32,460 --> 00:24:33,900
at this stage

708
00:24:33,900 --> 00:24:35,880
all right now

709
00:24:35,880 --> 00:24:38,580
um in our evaluation stage afterwards we

710
00:24:38,580 --> 00:24:40,440
just check for

711
00:24:40,440 --> 00:24:41,940
um basically repeatability and

712
00:24:41,940 --> 00:24:44,280
reliability of the previous attacks

713
00:24:44,280 --> 00:24:47,100
so quite simple all right let's now see

714
00:24:47,100 --> 00:24:52,020
oh let's now see what we are um what

715
00:24:52,020 --> 00:24:54,120
what we can basically do with this right

716
00:24:54,120 --> 00:24:56,340
let's break some stuff basically

717
00:24:56,340 --> 00:24:59,220
so here I'm going to focus on first of

718
00:24:59,220 --> 00:25:00,659
all Breaking these duplication based

719
00:25:00,659 --> 00:25:02,280
approaches which I've introduced earlier

720
00:25:02,280 --> 00:25:04,140
and afterwards I'm going to show you how

721
00:25:04,140 --> 00:25:05,640
every trust the name architecture out

722
00:25:05,640 --> 00:25:08,159
there can easily be broken so bear with

723
00:25:08,159 --> 00:25:08,880
me

724
00:25:08,880 --> 00:25:12,120
duplicated registers as we see in in our

725
00:25:12,120 --> 00:25:14,039
background section basically these are

726
00:25:14,039 --> 00:25:16,320
commonly used to protect any security

727
00:25:16,320 --> 00:25:18,179
critical configurations in your system

728
00:25:18,179 --> 00:25:20,340
against fault injection and we have

729
00:25:20,340 --> 00:25:22,260
found them to be used in for example

730
00:25:22,260 --> 00:25:24,000
debugging features which determine

731
00:25:24,000 --> 00:25:25,500
whether or not you have debug access to

732
00:25:25,500 --> 00:25:27,900
your core or physically unclogable

733
00:25:27,900 --> 00:25:30,360
functions basically any system security

734
00:25:30,360 --> 00:25:32,700
configurations and well

735
00:25:32,700 --> 00:25:35,640
yeah this is a non-exhaustive list right

736
00:25:35,640 --> 00:25:37,260
all right let's make an attack plan to

737
00:25:37,260 --> 00:25:38,880
attack this and I want you to remember

738
00:25:38,880 --> 00:25:41,880
that we now have two registers mapped

739
00:25:41,880 --> 00:25:43,919
into our memory space which are referred

740
00:25:43,919 --> 00:25:46,140
to as our original register as well as

741
00:25:46,140 --> 00:25:47,940
our duplicated register

742
00:25:47,940 --> 00:25:49,799
under normal circumstances we would

743
00:25:49,799 --> 00:25:52,440
commonly go ahead and assign both of

744
00:25:52,440 --> 00:25:54,240
them the very same value in a sequential

745
00:25:54,240 --> 00:25:56,100
fashion so first of all our original

746
00:25:56,100 --> 00:25:58,260
register gets written afterwards we

747
00:25:58,260 --> 00:25:59,580
write the very same value to our

748
00:25:59,580 --> 00:26:01,799
duplicated register the attack plan ends

749
00:26:01,799 --> 00:26:04,140
looks quite simple we actually just skip

750
00:26:04,140 --> 00:26:06,000
over the assignment to this register and

751
00:26:06,000 --> 00:26:07,500
afterwards skip over the assignment to

752
00:26:07,500 --> 00:26:08,760
this search system

753
00:26:08,760 --> 00:26:11,940
all right let's now see

754
00:26:11,940 --> 00:26:13,860
um the results of our sweeping stage

755
00:26:13,860 --> 00:26:15,779
basically and this is what it looks like

756
00:26:15,779 --> 00:26:18,480
but maybe some preschool May first year

757
00:26:18,480 --> 00:26:20,820
so our multiple fault injection platform

758
00:26:20,820 --> 00:26:22,440
is running with a frequency of 100

759
00:26:22,440 --> 00:26:24,659
megahertz which means in turn we have a

760
00:26:24,659 --> 00:26:27,779
period of exactly 10 nanoseconds right

761
00:26:27,779 --> 00:26:30,600
and this means that a single step along

762
00:26:30,600 --> 00:26:32,580
the x-axis which depicts of voltage

763
00:26:32,580 --> 00:26:34,919
defaults offset and the y-axis which

764
00:26:34,919 --> 00:26:37,380
depicts our voltage faults with is

765
00:26:37,380 --> 00:26:39,779
exactly equivalent to 10 nanoseconds all

766
00:26:39,779 --> 00:26:45,360
right the gray grayish process

767
00:26:45,360 --> 00:26:45,900
um

768
00:26:45,900 --> 00:26:48,240
show these results where we injected a

769
00:26:48,240 --> 00:26:49,919
single fold and basically nothing ever

770
00:26:49,919 --> 00:26:51,000
happened

771
00:26:51,000 --> 00:26:53,039
the red one I've labeled them here

772
00:26:53,039 --> 00:26:55,080
stupid crashes because we we commonly do

773
00:26:55,080 --> 00:26:56,820
not want to encounter them right if we

774
00:26:56,820 --> 00:26:59,400
cause a crash well we have to reboot our

775
00:26:59,400 --> 00:27:01,559
Target and this just lowers our

776
00:27:01,559 --> 00:27:03,539
throughput and and fault injection

777
00:27:03,539 --> 00:27:04,620
attempts

778
00:27:04,620 --> 00:27:07,020
in blue you see where we successfully

779
00:27:07,020 --> 00:27:09,059
skipped over the assignment to our

780
00:27:09,059 --> 00:27:11,159
original register whereas in green you

781
00:27:11,159 --> 00:27:12,720
see where we successfully skipped over

782
00:27:12,720 --> 00:27:13,980
the assignment to our duplicated

783
00:27:13,980 --> 00:27:16,919
register let's now arbitrarily or maybe

784
00:27:16,919 --> 00:27:19,620
semi arbitrarily choose some values from

785
00:27:19,620 --> 00:27:20,880
these intervals to perform multiple

786
00:27:20,880 --> 00:27:23,039
fault injections so let's go with this

787
00:27:23,039 --> 00:27:24,539
one here because there are no stupid

788
00:27:24,539 --> 00:27:25,799
crashes around

789
00:27:25,799 --> 00:27:28,740
and well why am I actually choosing a

790
00:27:28,740 --> 00:27:30,960
much narrower way for the second one any

791
00:27:30,960 --> 00:27:32,700
ideas

792
00:27:32,700 --> 00:27:35,400
all right let me tell you why because

793
00:27:35,400 --> 00:27:36,960
this is what it looks like on a physical

794
00:27:36,960 --> 00:27:39,960
level and after we are done with our

795
00:27:39,960 --> 00:27:41,940
multiple fault injection you see there's

796
00:27:41,940 --> 00:27:44,760
a really slow recover curve right we are

797
00:27:44,760 --> 00:27:46,679
slowly recovering for for from our

798
00:27:46,679 --> 00:27:47,760
multiple fault injection attack

799
00:27:47,760 --> 00:27:50,880
basically and yeah well internal as well

800
00:27:50,880 --> 00:27:52,620
as external capacitances would have to

801
00:27:52,620 --> 00:27:55,200
be recharged at this point this however

802
00:27:55,200 --> 00:27:57,480
is the original voltage level even

803
00:27:57,480 --> 00:27:59,940
before we injected a single fault and

804
00:27:59,940 --> 00:28:02,580
this is the voltage level before we

805
00:28:02,580 --> 00:28:04,860
after we injected a single fold and

806
00:28:04,860 --> 00:28:06,600
before we are about to inject the second

807
00:28:06,600 --> 00:28:08,760
one and as you see this is only roughly

808
00:28:08,760 --> 00:28:11,580
half the original voltage level

809
00:28:11,580 --> 00:28:14,220
so if we would now go ahead and inject a

810
00:28:14,220 --> 00:28:16,860
much wider fault well we would

811
00:28:16,860 --> 00:28:18,539
unnecessarily stress our Target device

812
00:28:18,539 --> 00:28:21,240
and by this cause a lot of crashes

813
00:28:21,240 --> 00:28:23,820
all right so you in in conclusion you

814
00:28:23,820 --> 00:28:26,460
could say that you would have to take

815
00:28:26,460 --> 00:28:28,440
care of this whenever your fault targets

816
00:28:28,440 --> 00:28:32,100
are not reasonably separated in space

817
00:28:32,100 --> 00:28:34,080
okay let's see some results and these

818
00:28:34,080 --> 00:28:35,279
are really amazing I couldn't believe it

819
00:28:35,279 --> 00:28:36,840
but first of all what are we seeing here

820
00:28:36,840 --> 00:28:39,299
the x-axis is an exponential scale which

821
00:28:39,299 --> 00:28:41,220
shows you the number of fault injection

822
00:28:41,220 --> 00:28:43,440
attacks we've been performing and the

823
00:28:43,440 --> 00:28:46,799
y-axis is a linear scale which shows you

824
00:28:46,799 --> 00:28:48,720
um our success rate in percent basically

825
00:28:48,720 --> 00:28:51,120
and as you see it's it's really crazy we

826
00:28:51,120 --> 00:28:53,460
seemingly converge around a success rate

827
00:28:53,460 --> 00:28:55,860
of 70 percent which is really a lot

828
00:28:55,860 --> 00:28:57,659
because if you read single fault

829
00:28:57,659 --> 00:28:59,100
injection papers well they all state

830
00:28:59,100 --> 00:29:01,140
like we have maybe a success rate of 20

831
00:29:01,140 --> 00:29:03,720
or 30 but this is rather High to be

832
00:29:03,720 --> 00:29:05,400
honest and what we did here is we

833
00:29:05,400 --> 00:29:07,380
injected multiple faults even and get

834
00:29:07,380 --> 00:29:10,020
the success rate of 70 percent

835
00:29:10,020 --> 00:29:11,279
okay

836
00:29:11,279 --> 00:29:13,620
so I I hope you all agree that this

837
00:29:13,620 --> 00:29:16,260
encounter measure is in fact broken

838
00:29:16,260 --> 00:29:17,940
let's now see how to attack the trans

839
00:29:17,940 --> 00:29:20,520
architectures out there and here I'm

840
00:29:20,520 --> 00:29:22,140
going to show you an attack which works

841
00:29:22,140 --> 00:29:24,120
on all these processes which are in the

842
00:29:24,120 --> 00:29:25,740
heading over here

843
00:29:25,740 --> 00:29:27,600
so first of all we would have to go

844
00:29:27,600 --> 00:29:29,159
ahead and skip over the activation of

845
00:29:29,159 --> 00:29:31,500
this SIU oh yeah and to the top right

846
00:29:31,500 --> 00:29:33,600
don't worry this is just meant to

847
00:29:33,600 --> 00:29:35,220
provide a reference in case you are

848
00:29:35,220 --> 00:29:37,020
already familiar with the Trust online

849
00:29:37,020 --> 00:29:40,620
architecture if you are not just ignored

850
00:29:40,620 --> 00:29:42,659
so first of all we skip over this SAU

851
00:29:42,659 --> 00:29:44,580
activation over here afterwards so we

852
00:29:44,580 --> 00:29:46,740
have to skip over the

853
00:29:46,740 --> 00:29:47,360
um

854
00:29:47,360 --> 00:29:49,440
these additional back checking

855
00:29:49,440 --> 00:29:52,200
mechanisms on the HP bus and finally we

856
00:29:52,200 --> 00:29:54,960
would have to perform some sort of

857
00:29:54,960 --> 00:29:56,360
a

858
00:29:56,360 --> 00:29:58,799
privileged escalation because we do not

859
00:29:58,799 --> 00:30:01,200
we just deactivated the Trust on M and

860
00:30:01,200 --> 00:30:02,700
we can't make any transitions to

861
00:30:02,700 --> 00:30:05,520
non-secure at this point so yeah this is

862
00:30:05,520 --> 00:30:06,720
basically it

863
00:30:06,720 --> 00:30:09,360
if you are like me know however

864
00:30:09,360 --> 00:30:12,419
um well I I just have to tell you all

865
00:30:12,419 --> 00:30:14,399
these targets broke down you know and

866
00:30:14,399 --> 00:30:16,679
the STM for example it broke down like

867
00:30:16,679 --> 00:30:18,919
every 30 seconds the

868
00:30:18,919 --> 00:30:21,899
m2351 broke down like every five minutes

869
00:30:21,899 --> 00:30:24,960
and the saml 11 took him some longer he

870
00:30:24,960 --> 00:30:26,940
broke down like once in an hour and I

871
00:30:26,940 --> 00:30:28,860
assume that this differences arise due

872
00:30:28,860 --> 00:30:31,440
to maybe imperfect parameters however

873
00:30:31,440 --> 00:30:33,059
the parameters are still sufficient

874
00:30:33,059 --> 00:30:35,100
because we successfully broke them all

875
00:30:35,100 --> 00:30:37,679
and if you are like me now however this

876
00:30:37,679 --> 00:30:39,419
is this should make you happy but this

877
00:30:39,419 --> 00:30:41,100
you know just doesn't make you happy

878
00:30:41,100 --> 00:30:42,899
actually because well we have been

879
00:30:42,899 --> 00:30:45,960
developing this super sophisticated uh

880
00:30:45,960 --> 00:30:47,539
let's let's just

881
00:30:47,539 --> 00:30:49,980
coin it this way super sophisticated

882
00:30:49,980 --> 00:30:52,620
multiple fault injection approach you

883
00:30:52,620 --> 00:30:55,140
know we have developed this advanced

884
00:30:55,140 --> 00:30:57,000
search basically and now really

885
00:30:57,000 --> 00:30:58,980
three-folds is all it takes

886
00:30:58,980 --> 00:31:01,500
so depressing right but you know what

887
00:31:01,500 --> 00:31:03,480
thank God there's nxp

888
00:31:03,480 --> 00:31:05,279
I really love them it's my favorite they

889
00:31:05,279 --> 00:31:07,679
are my favorite IC manufacturer and what

890
00:31:07,679 --> 00:31:10,440
they did is they additionally protected

891
00:31:10,440 --> 00:31:13,020
these trusts on gates to the right by

892
00:31:13,020 --> 00:31:15,000
using this duplication-based approaches

893
00:31:15,000 --> 00:31:17,580
so instead of injecting only threefolds

894
00:31:17,580 --> 00:31:19,760
to to attack these trust and animals

895
00:31:19,760 --> 00:31:22,140
implementations we would have to inject

896
00:31:22,140 --> 00:31:24,659
up to four voltage faults here

897
00:31:24,659 --> 00:31:26,700
first of all same as before we skip over

898
00:31:26,700 --> 00:31:29,220
the activation of this SAU afterwards

899
00:31:29,220 --> 00:31:32,039
well we skip over the original register

900
00:31:32,039 --> 00:31:34,440
of this trusts and gate over here

901
00:31:34,440 --> 00:31:36,600
afterwards we skip over the duplicate

902
00:31:36,600 --> 00:31:38,399
register and by this fully deactivate

903
00:31:38,399 --> 00:31:39,840
the um

904
00:31:39,840 --> 00:31:41,700
this additional back checking mechanisms

905
00:31:41,700 --> 00:31:44,779
and finally we perform the very same

906
00:31:44,779 --> 00:31:47,220
privileged escalation as before

907
00:31:47,220 --> 00:31:50,940
so you see let's let's see some results

908
00:31:50,940 --> 00:31:53,220
actually so we inject a single fault

909
00:31:53,220 --> 00:31:55,500
over here and we gain a success rate of

910
00:31:55,500 --> 00:31:58,140
roughly 45 percent

911
00:31:58,140 --> 00:32:00,059
let's untick both of them and we got a

912
00:32:00,059 --> 00:32:03,120
success rate of 2.5 percent

913
00:32:03,120 --> 00:32:06,179
three of them we are with 0.23 percent

914
00:32:06,179 --> 00:32:08,460
and if we perform our overall attack

915
00:32:08,460 --> 00:32:10,980
against distrust Zone M well we have a

916
00:32:10,980 --> 00:32:14,340
success rate of roughly 0.0003 percent

917
00:32:14,340 --> 00:32:16,440
you may wonder why is there such a huge

918
00:32:16,440 --> 00:32:18,899
drop in between these in between our

919
00:32:18,899 --> 00:32:21,179
third four targets and our fourth fall

920
00:32:21,179 --> 00:32:23,520
Target actually and this is because well

921
00:32:23,520 --> 00:32:26,100
nxp decided today to to to activate

922
00:32:26,100 --> 00:32:28,380
their Brahma detection in between our

923
00:32:28,380 --> 00:32:31,260
third and fourth floor Target so by this

924
00:32:31,260 --> 00:32:33,419
We additionally successfully glitched

925
00:32:33,419 --> 00:32:35,399
over the brown detection of NXT which is

926
00:32:35,399 --> 00:32:37,380
also you know nice to have

927
00:32:37,380 --> 00:32:40,260
all right and if you now think well

928
00:32:40,260 --> 00:32:42,679
this is not a real Attack you know

929
00:32:42,679 --> 00:32:45,779
0.0003 that's almost nothing let me tell

930
00:32:45,779 --> 00:32:48,620
you in our experiments we have been

931
00:32:48,620 --> 00:32:51,480
encountering successes in an average

932
00:32:51,480 --> 00:32:54,600
time of half a day all right and it took

933
00:32:54,600 --> 00:32:56,279
at most one day

934
00:32:56,279 --> 00:32:59,940
let's just say by by saying one day and

935
00:32:59,940 --> 00:33:01,860
if you think about the consequences so

936
00:33:01,860 --> 00:33:03,360
the implications made by this attack

937
00:33:03,360 --> 00:33:04,799
this must be considered critical

938
00:33:04,799 --> 00:33:07,500
actually because once we are done there

939
00:33:07,500 --> 00:33:09,720
is no trusts on left actually there is

940
00:33:09,720 --> 00:33:12,600
no secure there is no it's non-secure

941
00:33:12,600 --> 00:33:14,460
um there is just basically me owning all

942
00:33:14,460 --> 00:33:16,559
just all your precious secret data you

943
00:33:16,559 --> 00:33:17,220
know

944
00:33:17,220 --> 00:33:20,340
and yeah this so even

945
00:33:20,340 --> 00:33:20,940
um

946
00:33:20,940 --> 00:33:24,659
a success rate of 0.0003 in this context

947
00:33:24,659 --> 00:33:26,519
must be considered practical critical

948
00:33:26,519 --> 00:33:29,100
actually all right let's now conclude

949
00:33:29,100 --> 00:33:30,419
with some possible multiple fault

950
00:33:30,419 --> 00:33:32,100
injection countermeasures

951
00:33:32,100 --> 00:33:34,740
and a little teaser here well shall we

952
00:33:34,740 --> 00:33:35,820
maybe Implement them on the instruction

953
00:33:35,820 --> 00:33:38,240
level

954
00:33:39,080 --> 00:33:41,820
all right so in case your answer was yes

955
00:33:41,820 --> 00:33:43,080
I would like you to leave this room

956
00:33:43,080 --> 00:33:44,880
right now because you have obviously not

957
00:33:44,880 --> 00:33:46,679
been paying attention

958
00:33:46,679 --> 00:33:47,940
we

959
00:33:47,940 --> 00:33:49,140
definitely want to go with

960
00:33:49,140 --> 00:33:51,059
hardware-based countermeasures right and

961
00:33:51,059 --> 00:33:53,340
into as an example Intel just integrated

962
00:33:53,340 --> 00:33:54,840
them in that Wolfgang processors

963
00:33:54,840 --> 00:33:56,519
yesterday there was a great talk here at

964
00:33:56,519 --> 00:33:58,559
black cat who

965
00:33:58,559 --> 00:34:01,080
um which just went about this

966
00:34:01,080 --> 00:34:03,539
um the configuration of this

967
00:34:03,539 --> 00:34:05,100
um countermeasures on the hardware level

968
00:34:05,100 --> 00:34:07,760
it's great and it props to you really

969
00:34:07,760 --> 00:34:10,859
and I've been in contact with with quite

970
00:34:10,859 --> 00:34:13,260
a lot of embedded IC manufacturers and

971
00:34:13,260 --> 00:34:15,000
all of them stated that they are working

972
00:34:15,000 --> 00:34:17,820
on well let's just say similar counter

973
00:34:17,820 --> 00:34:19,320
measures basically

974
00:34:19,320 --> 00:34:21,480
you could now go ahead and ask well what

975
00:34:21,480 --> 00:34:23,040
about these devices which are security

976
00:34:23,040 --> 00:34:24,719
critical and which are already on the

977
00:34:24,719 --> 00:34:25,739
market

978
00:34:25,739 --> 00:34:28,260
for this I will strongly appointment is

979
00:34:28,260 --> 00:34:30,960
five minutes okay

980
00:34:30,960 --> 00:34:32,699
um for this I would strongly recommend

981
00:34:32,699 --> 00:34:33,960
you to

982
00:34:33,960 --> 00:34:36,060
um use this duplication based approaches

983
00:34:36,060 --> 00:34:39,060
and we'll combine them with random

984
00:34:39,060 --> 00:34:41,099
delays because we have only been able to

985
00:34:41,099 --> 00:34:43,320
perform our sophisticated uh search

986
00:34:43,320 --> 00:34:45,300
approach basically because these

987
00:34:45,300 --> 00:34:46,800
photographers are always in the same

988
00:34:46,800 --> 00:34:49,739
location right timely location basically

989
00:34:49,739 --> 00:34:51,599
all right so here are your main

990
00:34:51,599 --> 00:34:52,679
takeaways

991
00:34:52,679 --> 00:34:54,239
multiple fault injection can be

992
00:34:54,239 --> 00:34:56,159
implemented rather cheap by using

993
00:34:56,159 --> 00:34:58,380
voltage fault injection attacks such

994
00:34:58,380 --> 00:35:00,000
multiple fault injection can then be

995
00:35:00,000 --> 00:35:01,380
used to for example break instruction

996
00:35:01,380 --> 00:35:02,880
level counter Metals as well as the

997
00:35:02,880 --> 00:35:04,320
transom and implementations out there

998
00:35:04,320 --> 00:35:06,800
and basically any kind of secure

999
00:35:06,800 --> 00:35:10,320
interdependent security measure

1000
00:35:10,320 --> 00:35:12,180
and I just have to state that I would

1001
00:35:12,180 --> 00:35:14,940
like to I would like to optimize our

1002
00:35:14,940 --> 00:35:17,160
parameter search because I would like to

1003
00:35:17,160 --> 00:35:19,140
get rid of this differentiation based

1004
00:35:19,140 --> 00:35:21,560
approach and go towards an even more

1005
00:35:21,560 --> 00:35:23,880
independent solution I couldn't figure

1006
00:35:23,880 --> 00:35:25,859
it out yet so in case someone has a

1007
00:35:25,859 --> 00:35:28,800
suggestion I'm definitely open to it and

1008
00:35:28,800 --> 00:35:31,320
yeah finally we would like to thank nxp

1009
00:35:31,320 --> 00:35:33,540
for their really exceptional engagement

1010
00:35:33,540 --> 00:35:36,000
in our responsible disclosure process

1011
00:35:36,000 --> 00:35:37,690
yeah thank you

1012
00:35:37,690 --> 00:35:40,000
[Applause]

1013
00:35:40,000 --> 00:35:43,110
[Music]

1014
00:35:46,950 --> 00:35:50,060
[Music]

