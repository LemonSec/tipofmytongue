1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:12,080 --> 00:00:15,960
a.m in Taiwan and sorry I can't be

4
00:00:15,960 --> 00:00:18,539
physically on the stage because of the

5
00:00:18,539 --> 00:00:21,840
Visa I hope one day we can meet face to

6
00:00:21,840 --> 00:00:24,300
face in Vegas

7
00:00:24,300 --> 00:00:28,260
about 10 years ago I failed my algorithm

8
00:00:28,260 --> 00:00:30,599
course at University

9
00:00:30,599 --> 00:00:33,360
but I'm now here to talk about the hash

10
00:00:33,360 --> 00:00:37,440
table this is a big achievement for me

11
00:00:37,440 --> 00:00:40,800
and orangey and today my topic is less

12
00:00:40,800 --> 00:00:43,379
dense in the cache this stabilizing hash

13
00:00:43,379 --> 00:00:47,000
table on Microsoft IIs

14
00:00:47,399 --> 00:00:49,920
before the talk I would like to give you

15
00:00:49,920 --> 00:00:52,020
a short test

16
00:00:52,020 --> 00:00:55,739
if there is a super secret area which is

17
00:00:55,739 --> 00:00:59,100
protected by a super secure password

18
00:00:59,100 --> 00:01:02,699
you cannot login only if you know this

19
00:01:02,699 --> 00:01:03,400
long password

20
00:01:03,400 --> 00:01:04,860
[Music]

21
00:01:04,860 --> 00:01:09,560
however under the design of IIs

22
00:01:09,780 --> 00:01:13,260
all of these passwords

23
00:01:13,260 --> 00:01:17,460
are valid and can look into the system

24
00:01:17,460 --> 00:01:20,520
the next thing right I guess you might

25
00:01:20,520 --> 00:01:23,939
have several questions in your life

26
00:01:23,939 --> 00:01:26,220
this is one of the attacks I will

27
00:01:26,220 --> 00:01:28,619
present today and you will learn the

28
00:01:28,619 --> 00:01:31,520
details later

29
00:01:32,280 --> 00:01:35,100
hi and orange another principal security

30
00:01:35,100 --> 00:01:39,060
researcher at that column I I an Azure

31
00:01:39,060 --> 00:01:41,520
the researcher and focusing on web and

32
00:01:41,520 --> 00:01:43,259
application security

33
00:01:43,259 --> 00:01:46,439
my job is to discover the most severe

34
00:01:46,439 --> 00:01:49,020
bugs and the attack service that can

35
00:01:49,020 --> 00:01:52,259
impact the world ahead of the bad guys

36
00:01:52,259 --> 00:01:55,740
my research has also received several

37
00:01:55,740 --> 00:01:58,920
Awards such as the best server side part

38
00:01:58,920 --> 00:02:01,740
of tangney award and the champ and the

39
00:02:01,740 --> 00:02:03,899
champion of the punctivo

40
00:02:03,899 --> 00:02:06,180
if you are interested welcome to follow

41
00:02:06,180 --> 00:02:10,340
my Twitter or chat with me later

42
00:02:10,340 --> 00:02:13,920
this is the outline today first we will

43
00:02:13,920 --> 00:02:16,520
introduce several essential Concepts

44
00:02:16,520 --> 00:02:19,860
those concepts are important to let you

45
00:02:19,860 --> 00:02:23,220
into Microsoft IIs internals in our

46
00:02:23,220 --> 00:02:25,379
topic today

47
00:02:25,379 --> 00:02:28,520
after having a good understanding of IIs

48
00:02:28,520 --> 00:02:31,560
internals we will elaborate on our

49
00:02:31,560 --> 00:02:34,319
research followed by three different

50
00:02:34,319 --> 00:02:37,319
types of vulnerabilities

51
00:02:37,319 --> 00:02:40,200
also we will demonstrate how we apply

52
00:02:40,200 --> 00:02:42,780
this attacks to Microsoft Exchange

53
00:02:42,780 --> 00:02:46,140
Server as a showcase

54
00:02:46,140 --> 00:02:48,500
of course we will provide mitigations

55
00:02:48,500 --> 00:02:51,480
recommendations and Future Works to

56
00:02:51,480 --> 00:02:54,060
those components

57
00:02:54,060 --> 00:02:57,379
so first what is Hash table

58
00:02:57,379 --> 00:03:00,360
hashtago is the most fundamental data

59
00:03:00,360 --> 00:03:03,780
structure in computer science and

60
00:03:03,780 --> 00:03:06,900
its purpose is to store data

61
00:03:06,900 --> 00:03:10,080
no matter how the data is Hash table can

62
00:03:10,080 --> 00:03:13,200
hold the data in memory very well

63
00:03:13,200 --> 00:03:15,540
hash table is especially good at

64
00:03:15,540 --> 00:03:18,360
handling the key value pair and can

65
00:03:18,360 --> 00:03:22,500
operate data with a high performance

66
00:03:22,500 --> 00:03:25,760
due to those benefits hash table is used

67
00:03:25,760 --> 00:03:28,620
extensively in computer infrastructures

68
00:03:28,620 --> 00:03:32,099
such as operating system programming

69
00:03:32,099 --> 00:03:36,360
language database or web server

70
00:03:36,360 --> 00:03:38,760
here's an example of the hash table

71
00:03:38,760 --> 00:03:40,819
usage in programming language

72
00:03:40,819 --> 00:03:43,500
programming language uses the hash table

73
00:03:43,500 --> 00:03:46,680
widely however you don't know because

74
00:03:46,680 --> 00:03:49,739
they wrapped hash table into a more high

75
00:03:49,739 --> 00:03:52,760
level structure such as the array

76
00:03:52,760 --> 00:03:55,739
dictionary or object

77
00:03:55,739 --> 00:03:59,040
so if you are a developer you must have

78
00:03:59,040 --> 00:04:00,920
used hash table

79
00:04:00,920 --> 00:04:04,200
as the internal I assume that everyone

80
00:04:04,200 --> 00:04:07,500
here is a good student at University

81
00:04:07,500 --> 00:04:10,860
so I I skipped the hash table internal

82
00:04:10,860 --> 00:04:13,379
this time

83
00:04:13,379 --> 00:04:16,680
as for what is the hash voting attack

84
00:04:16,680 --> 00:04:19,620
also we are not going to talk about this

85
00:04:19,620 --> 00:04:22,560
attack only we still give it a slot

86
00:04:22,560 --> 00:04:25,919
because I believe that that hash voting

87
00:04:25,919 --> 00:04:28,500
attack is the best test to learn the

88
00:04:28,500 --> 00:04:31,919
mindset of how an attacker abuse a hash

89
00:04:31,919 --> 00:04:33,720
table

90
00:04:33,720 --> 00:04:37,020
the idea of hash floating attack is to

91
00:04:37,020 --> 00:04:39,300
drop all the records into the same

92
00:04:39,300 --> 00:04:40,620
bucket

93
00:04:40,620 --> 00:04:44,040
since the hash algorithm is public an

94
00:04:44,040 --> 00:04:47,220
attacker can predict its hash and make

95
00:04:47,220 --> 00:04:50,460
all records fall into the same bucket

96
00:04:50,460 --> 00:04:53,419
and at the time the attacker degenerate

97
00:04:53,419 --> 00:04:55,979
degenerates the hash table which can

98
00:04:55,979 --> 00:04:58,800
store numbers later into a single linked

99
00:04:58,800 --> 00:05:00,979
list

100
00:05:01,139 --> 00:05:04,080
for example the attacker has crafted

101
00:05:04,080 --> 00:05:06,300
several malicious records on the left

102
00:05:06,300 --> 00:05:07,500
side

103
00:05:07,500 --> 00:05:09,660
the hash function in the in the middle

104
00:05:09,660 --> 00:05:12,360
will process and convert the radical

105
00:05:12,360 --> 00:05:14,840
into an index

106
00:05:14,840 --> 00:05:17,940
the first record is convert to the index

107
00:05:17,940 --> 00:05:21,660
4 and put into the corresponding bucket

108
00:05:21,660 --> 00:05:24,240
the second is also put into the same

109
00:05:24,240 --> 00:05:25,979
bucket

110
00:05:25,979 --> 00:05:28,758
the Third

111
00:05:29,400 --> 00:05:30,900
the fifth

112
00:05:30,900 --> 00:05:34,560
and the attacker can jump all records

113
00:05:34,560 --> 00:05:36,900
into the same bucket and the table now

114
00:05:36,900 --> 00:05:40,380
becomes a single linked list

115
00:05:40,380 --> 00:05:43,500
so the hash floating attack connect the

116
00:05:43,500 --> 00:05:47,160
table always sit under broadcast that

117
00:05:47,160 --> 00:05:48,720
thing that means

118
00:05:48,720 --> 00:05:51,720
for inserting and Records the time

119
00:05:51,720 --> 00:05:55,080
complexity comes to N squared we should

120
00:05:55,080 --> 00:05:58,440
all agree that N squared is is in a

121
00:05:58,440 --> 00:06:01,199
terrible performance

122
00:06:01,199 --> 00:06:04,139
okay with a good understanding of the

123
00:06:04,139 --> 00:06:06,120
hash table let's discuss the

124
00:06:06,120 --> 00:06:08,699
relationship between the hash table and

125
00:06:08,699 --> 00:06:11,120
IIs

126
00:06:11,400 --> 00:06:15,240
first IIs lab hash table

127
00:06:15,240 --> 00:06:18,419
it's a well-known and only web server in

128
00:06:18,419 --> 00:06:21,259
Windows IIs uses the hash table

129
00:06:21,259 --> 00:06:24,539
extensively architecture to store

130
00:06:24,539 --> 00:06:27,840
information such as the HTTP headers

131
00:06:27,840 --> 00:06:31,620
server variables configurations and

132
00:06:31,620 --> 00:06:34,220
cache

133
00:06:34,319 --> 00:06:37,259
due to the nested use of this data

134
00:06:37,259 --> 00:06:40,020
structure Microsoft has designed its own

135
00:06:40,020 --> 00:06:42,900
hash table implementation from a very

136
00:06:42,900 --> 00:06:44,340
early stage

137
00:06:44,340 --> 00:06:46,919
the following two are all the

138
00:06:46,919 --> 00:06:50,000
implementations that will be used in IIs

139
00:06:50,000 --> 00:06:53,819
one is code 3 hash table and the other

140
00:06:53,819 --> 00:06:57,919
is called LKR hash table

141
00:06:58,500 --> 00:07:01,139
the three hash tables should be the most

142
00:07:01,139 --> 00:07:03,539
common like the sample code in your

143
00:07:03,539 --> 00:07:07,080
textbooks it uses the linked list to

144
00:07:07,080 --> 00:07:09,479
resolve the correlation and rehash the

145
00:07:09,479 --> 00:07:12,900
table when it's in an unhealthy state

146
00:07:12,900 --> 00:07:15,720
the rehash is a series of the rebuilding

147
00:07:15,720 --> 00:07:19,039
process it first enlarges the table

148
00:07:19,039 --> 00:07:22,020
recalculates our records and reposition

149
00:07:22,020 --> 00:07:25,080
then to their new index

150
00:07:25,080 --> 00:07:28,860
as for hot hash us for hot hash function

151
00:07:28,860 --> 00:07:31,139
is used we will have a further

152
00:07:31,139 --> 00:07:34,099
discussion later

153
00:07:34,560 --> 00:07:38,400
the other table is the LKR hash and

154
00:07:38,400 --> 00:07:41,819
implementation that adds us to build a

155
00:07:41,819 --> 00:07:44,460
scalable and high concurrent hash table

156
00:07:44,460 --> 00:07:47,699
under the multi trading and multicore

157
00:07:47,699 --> 00:07:49,139
environment

158
00:07:49,139 --> 00:07:52,680
the net LKR is an acronym for the name

159
00:07:52,680 --> 00:07:54,660
of the creators

160
00:07:54,660 --> 00:07:57,419
this implementation was also patterned

161
00:07:57,419 --> 00:08:00,660
by Microsoft in 1999.

162
00:08:00,660 --> 00:08:04,020
the LKR hash is a successor of linear

163
00:08:04,020 --> 00:08:07,580
hashing which uses another better

164
00:08:07,580 --> 00:08:10,620
algorithm to resolve the expensive

165
00:08:10,620 --> 00:08:13,680
rehash to enhance the performance

166
00:08:13,680 --> 00:08:17,099
the creators put a lot of effort to make

167
00:08:17,099 --> 00:08:19,919
this implementation portable flexible

168
00:08:19,919 --> 00:08:22,020
and usable

169
00:08:22,020 --> 00:08:24,539
the application the application can

170
00:08:24,539 --> 00:08:26,639
Define its own terrible related

171
00:08:26,639 --> 00:08:30,060
functions to adapt to multiple products

172
00:08:30,060 --> 00:08:33,240
across Microsoft

173
00:08:33,240 --> 00:08:36,000
it's interesting to note that part of

174
00:08:36,000 --> 00:08:39,839
the creators are also the IIs Developers

175
00:08:39,839 --> 00:08:43,200
which which should be the reason why we

176
00:08:43,200 --> 00:08:48,080
find lots of these implementation in IIs

177
00:08:48,899 --> 00:08:51,899
now we have a complete understanding of

178
00:08:51,899 --> 00:08:55,140
the hash table it's time to go deep into

179
00:08:55,140 --> 00:08:57,420
our research

180
00:08:57,420 --> 00:09:00,720
in this section we will show the IIs in

181
00:09:00,720 --> 00:09:03,540
channels and Define the scope we really

182
00:09:03,540 --> 00:09:05,339
cared about

183
00:09:05,339 --> 00:09:08,820
we will first explain our mindset and

184
00:09:08,820 --> 00:09:11,160
idea to uncover box

185
00:09:11,160 --> 00:09:14,060
we are mainly focusing on the hash table

186
00:09:14,060 --> 00:09:18,060
implementation and its usage

187
00:09:18,060 --> 00:09:21,060
since most of the hash table used in IIs

188
00:09:21,060 --> 00:09:25,320
are cash related we also study and look

189
00:09:25,320 --> 00:09:28,680
into mechanism

190
00:09:29,959 --> 00:09:33,120
because Microsoft has designed its own

191
00:09:33,120 --> 00:09:35,760
hash table without open source the

192
00:09:35,760 --> 00:09:38,640
implementation should be an explored

193
00:09:38,640 --> 00:09:41,399
area to discover box

194
00:09:41,399 --> 00:09:45,600
so in this context we hide we hunt not

195
00:09:45,600 --> 00:09:48,480
only for memory Corruptions but also

196
00:09:48,480 --> 00:09:50,700
Logic box

197
00:09:50,700 --> 00:09:53,100
here I would like to highlight the Box

198
00:09:53,100 --> 00:09:55,700
CV 2006

199
00:09:55,700 --> 00:09:59,640
3017 it's a logic back in the unsafe

200
00:09:59,640 --> 00:10:01,800
function of PHP

201
00:10:01,800 --> 00:10:05,420
the hash table implementation didn't

202
00:10:05,420 --> 00:10:09,060
distinguish the key type of an array so

203
00:10:09,060 --> 00:10:11,700
that so that an attacker can delete

204
00:10:11,700 --> 00:10:15,959
archery elements with an index number

205
00:10:15,959 --> 00:10:19,620
when I saw this part it amazed me and I

206
00:10:19,620 --> 00:10:21,899
believe this is just the bug I'm looking

207
00:10:21,899 --> 00:10:23,700
for

208
00:10:23,700 --> 00:10:26,760
of course we also look for the algorithm

209
00:10:26,760 --> 00:10:29,640
complexity problems such as the hash

210
00:10:29,640 --> 00:10:31,380
floating attack

211
00:10:31,380 --> 00:10:34,980
however since it's already a 20 years

212
00:10:34,980 --> 00:10:38,160
old attack most of the low hanging

213
00:10:38,160 --> 00:10:40,860
fruits should be disappeared

214
00:10:40,860 --> 00:10:44,399
so in this context we put more effort

215
00:10:44,399 --> 00:10:47,839
into the implementation

216
00:10:48,540 --> 00:10:51,360
as for the usage we mentioned that the

217
00:10:51,360 --> 00:10:54,560
Nokia hash is designed to be a portable

218
00:10:54,560 --> 00:10:58,800
flexible and easy to use algorithm that

219
00:10:58,800 --> 00:11:02,220
can be applied to any situation

220
00:11:02,220 --> 00:11:04,620
the convention requires the application

221
00:11:04,620 --> 00:11:07,560
to configure its own table related

222
00:11:07,560 --> 00:11:10,800
functions during initialization

223
00:11:10,800 --> 00:11:14,339
this kind of extensibility gives us more

224
00:11:14,339 --> 00:11:17,820
opportunities to uncover box

225
00:11:17,820 --> 00:11:21,959
when I saw this I was curious that is

226
00:11:21,959 --> 00:11:24,240
the particular function good

227
00:11:24,240 --> 00:11:27,899
is the key calculation good or how does

228
00:11:27,899 --> 00:11:30,540
the function select the correct record

229
00:11:30,540 --> 00:11:33,480
when the Collision when a collision

230
00:11:33,480 --> 00:11:36,300
happens happens

231
00:11:36,300 --> 00:11:40,680
this type of questions all interested me

232
00:11:40,680 --> 00:11:43,860
so in this context we care more about

233
00:11:43,860 --> 00:11:47,220
the relationship between the record the

234
00:11:47,220 --> 00:11:50,720
keys and the function

235
00:11:50,760 --> 00:11:52,399
foreign

236
00:11:52,399 --> 00:11:57,120
HTTP request is coming the kernel http.c

237
00:11:57,120 --> 00:12:00,180
will first will first handle the

238
00:12:00,180 --> 00:12:04,699
connection and dispatch the request

239
00:12:05,640 --> 00:12:08,640
the Kernel check the kernel checks is

240
00:12:08,640 --> 00:12:11,519
based and active IIs worker

241
00:12:11,519 --> 00:12:14,820
if not it knocks the IRS service to

242
00:12:14,820 --> 00:12:18,019
spawn a new process

243
00:12:18,360 --> 00:12:22,500
the was Windows activation Service First

244
00:12:22,500 --> 00:12:25,380
reads the configuration to note several

245
00:12:25,380 --> 00:12:27,720
specifications for the process

246
00:12:27,720 --> 00:12:30,720
initialization

247
00:12:31,019 --> 00:12:34,500
and sprung the worker process several

248
00:12:34,500 --> 00:12:39,079
IRS components are loaded here

249
00:12:39,720 --> 00:12:43,079
the worker then lost the major which are

250
00:12:43,079 --> 00:12:46,519
defined in the configuration

251
00:12:47,519 --> 00:12:51,600
IRS by default load several modules for

252
00:12:51,600 --> 00:12:55,940
different purples such as the compaction

253
00:12:55,940 --> 00:12:57,500
redirection

254
00:12:57,500 --> 00:13:01,760
authentication and the cash

255
00:13:02,540 --> 00:13:05,700
among all measures the following four

256
00:13:05,700 --> 00:13:09,300
are the global cash provider to manage

257
00:13:09,300 --> 00:13:12,420
the cash between modules each measure is

258
00:13:12,420 --> 00:13:14,519
responsible for handling a different

259
00:13:14,519 --> 00:13:18,060
catch such as the cash flow static file

260
00:13:18,060 --> 00:13:21,839
the cash flow configuration or the cash

261
00:13:21,839 --> 00:13:25,220
for Windows token

262
00:13:27,000 --> 00:13:29,940
once the modules are loaded the worker

263
00:13:29,940 --> 00:13:32,760
enters the request life cycle

264
00:13:32,760 --> 00:13:35,519
the life cycle is an event Loop that

265
00:13:35,519 --> 00:13:38,639
process all the notifications from the

266
00:13:38,639 --> 00:13:41,060
request

267
00:13:41,940 --> 00:13:44,519
there are several events in a life cycle

268
00:13:44,519 --> 00:13:47,760
a manager can subscribe to its

269
00:13:47,760 --> 00:13:52,760
interesting events to complete its logic

270
00:13:53,820 --> 00:13:56,760
there are also Global events that a

271
00:13:56,760 --> 00:13:58,980
budget can subscribe to

272
00:13:58,980 --> 00:14:02,399
for example the cash provider subscribes

273
00:14:02,399 --> 00:14:06,060
to the event cash clean up and catch

274
00:14:06,060 --> 00:14:08,700
operation to manage the cash between

275
00:14:08,700 --> 00:14:11,540
modules

276
00:14:12,620 --> 00:14:16,920
so our research is not only focusing on

277
00:14:16,920 --> 00:14:21,000
the cash between the request life cycle

278
00:14:21,000 --> 00:14:24,019
but also the global cash providers

279
00:14:24,019 --> 00:14:29,899
especially those for our golden targets

280
00:14:31,560 --> 00:14:33,839
the following section is about our

281
00:14:33,839 --> 00:14:35,880
research and the Box

282
00:14:35,880 --> 00:14:38,700
in this section we will first elaborate

283
00:14:38,700 --> 00:14:42,240
on our idea and the last direction we

284
00:14:42,240 --> 00:14:45,180
are trying to find bugs we will attach

285
00:14:45,180 --> 00:14:47,760
three different types of vulnerabilities

286
00:14:47,760 --> 00:14:50,339
to prove our idea works

287
00:14:50,339 --> 00:14:53,459
all about our box include a hash

288
00:14:53,459 --> 00:14:57,440
floating dos attach poisoning and

289
00:14:57,440 --> 00:14:59,820
authentication bypass

290
00:14:59,820 --> 00:15:02,459
we will also talk about the exploitation

291
00:15:02,459 --> 00:15:06,240
of how we maximize the civility to make

292
00:15:06,240 --> 00:15:08,880
this bug impactful

293
00:15:08,880 --> 00:15:11,339
of course a real world authentication

294
00:15:11,339 --> 00:15:14,040
bypass a Microsoft Exchange Server will

295
00:15:14,040 --> 00:15:18,139
be detailed and demonstrated

296
00:15:19,260 --> 00:15:21,839
okay the First cast we would like to

297
00:15:21,839 --> 00:15:25,699
share is the hash building POS

298
00:15:26,779 --> 00:15:29,459
first we would like to give you a

299
00:15:29,459 --> 00:15:32,639
spoiler that all hash table implemented

300
00:15:32,639 --> 00:15:35,880
implemented by Microsoft are affected by

301
00:15:35,880 --> 00:15:39,019
hash floating attack

302
00:15:39,420 --> 00:15:42,060
the trade hash table is vulnerable by

303
00:15:42,060 --> 00:15:46,139
default and LKR hash is vulnerable only

304
00:15:46,139 --> 00:15:50,839
if a pro hash function is configured

305
00:15:51,440 --> 00:15:54,959
however vulnerable is not equal to

306
00:15:54,959 --> 00:15:57,240
exploitable

307
00:15:57,240 --> 00:16:00,240
besides finding the entrance point we

308
00:16:00,240 --> 00:16:05,300
still have several obstacles to overcome

309
00:16:05,940 --> 00:16:09,540
we find that URI cache modules seems to

310
00:16:09,540 --> 00:16:11,040
be a good Target

311
00:16:11,040 --> 00:16:14,100
the purpose of this module is to Cache

312
00:16:14,100 --> 00:16:17,220
configuration for urls

313
00:16:17,220 --> 00:16:21,720
grid configuration is costly so cash is

314
00:16:21,720 --> 00:16:25,339
the best strategy strategy

315
00:16:25,339 --> 00:16:28,680
in this module in this module every

316
00:16:28,680 --> 00:16:32,760
https triggers the cache operation and

317
00:16:32,760 --> 00:16:35,279
the most important things is that the

318
00:16:35,279 --> 00:16:38,940
module uses three hash table as is cache

319
00:16:38,940 --> 00:16:41,180
storage

320
00:16:41,420 --> 00:16:44,940
well and as a sport by default three

321
00:16:44,940 --> 00:16:49,160
hash table sounds good to us

322
00:16:49,740 --> 00:16:52,680
and this is the tide chart of every

323
00:16:52,680 --> 00:16:56,100
thousand new records in three hash table

324
00:16:56,100 --> 00:16:58,800
because it's not open source we must

325
00:16:58,800 --> 00:17:01,560
reverse the structure and code the table

326
00:17:01,560 --> 00:17:04,679
dynamically to get the data set

327
00:17:04,679 --> 00:17:07,260
the light in blue is the type of

328
00:17:07,260 --> 00:17:10,260
inserting random records and the light

329
00:17:10,260 --> 00:17:14,220
in Orange is the records with collisions

330
00:17:14,220 --> 00:17:16,740
you should be able to figure out there's

331
00:17:16,740 --> 00:17:21,380
a huge difference between the two lines

332
00:17:21,900 --> 00:17:26,699
however the Jitters around 35

333
00:17:26,699 --> 00:17:30,299
000 and 75 000 are weird what's the

334
00:17:30,299 --> 00:17:31,860
Twitter

335
00:17:31,860 --> 00:17:35,400
so theoretically the lines growth in

336
00:17:35,400 --> 00:17:38,780
Orange should be in linear time

337
00:17:38,780 --> 00:17:42,600
so what actually makes the time increase

338
00:17:42,600 --> 00:17:45,620
on smoothly

339
00:17:45,860 --> 00:17:48,720
the answer is rehash

340
00:17:48,720 --> 00:17:51,840
this is the part of the insert operation

341
00:17:51,840 --> 00:17:55,500
the implementation first traversed the

342
00:17:55,500 --> 00:17:58,980
linked list to ensure no duplicates and

343
00:17:58,980 --> 00:18:02,360
do its internal jobs

344
00:18:02,880 --> 00:18:06,299
however after the internal ad operation

345
00:18:06,299 --> 00:18:09,780
there is a call to the function rehash

346
00:18:09,780 --> 00:18:13,160
table if needed

347
00:18:13,500 --> 00:18:15,539
the function checks the number of

348
00:18:15,539 --> 00:18:18,660
records and rehash the table if the

349
00:18:18,660 --> 00:18:21,299
number is greater than two types of the

350
00:18:21,299 --> 00:18:24,600
threshold threshold the threshold is is

351
00:18:24,600 --> 00:18:27,960
Select from a list of prime numbers

352
00:18:27,960 --> 00:18:31,679
and once rehashing the function enlarges

353
00:18:31,679 --> 00:18:34,320
the table by the next prime number and

354
00:18:34,320 --> 00:18:36,179
we map our records to their

355
00:18:36,179 --> 00:18:39,960
corresponding bucket this is a huge and

356
00:18:39,960 --> 00:18:43,559
extensive operation that's also why the

357
00:18:43,559 --> 00:18:47,600
chart increased on smoothly

358
00:18:48,179 --> 00:18:51,240
to exploit that there are still several

359
00:18:51,240 --> 00:18:55,320
questions to be solved for example how

360
00:18:55,320 --> 00:18:57,960
much of the cash key we can control

361
00:18:57,960 --> 00:19:00,960
or how to construct the paper the

362
00:19:00,960 --> 00:19:04,160
Collision payload

363
00:19:05,460 --> 00:19:08,280
there are several elements in a cache

364
00:19:08,280 --> 00:19:11,100
key and the only element we can control

365
00:19:11,100 --> 00:19:15,299
is the URL test which reflected at the

366
00:19:15,299 --> 00:19:17,880
end of the cache key

367
00:19:17,880 --> 00:19:20,880
the implementation will first convert

368
00:19:20,880 --> 00:19:24,600
all the text to uppercase and send a key

369
00:19:24,600 --> 00:19:27,980
to the hash function

370
00:19:28,740 --> 00:19:31,860
the hash functions simply multiplies

371
00:19:31,860 --> 00:19:36,059
each byte of the cache Key by 101 and

372
00:19:36,059 --> 00:19:38,460
some stand up

373
00:19:38,460 --> 00:19:42,360
the function also uses an lcg to

374
00:19:42,360 --> 00:19:44,100
scramble the result

375
00:19:44,100 --> 00:19:46,679
however

376
00:19:46,679 --> 00:19:50,600
is this hash function good

377
00:19:51,780 --> 00:19:54,840
this is the answer from elect and very

378
00:19:54,840 --> 00:20:01,699
in their in their ocean clock at 2028 C3

379
00:20:03,179 --> 00:20:06,780
this multiplied and add method is a

380
00:20:06,780 --> 00:20:10,820
variant of bjb hash

381
00:20:11,520 --> 00:20:15,600
and this algorithm has been proven that

382
00:20:15,600 --> 00:20:19,559
correlatable by equivalent substrings

383
00:20:19,559 --> 00:20:23,220
point two keys have the same hash such

384
00:20:23,220 --> 00:20:28,020
as the PS and Q2 they must be equal no

385
00:20:28,020 --> 00:20:32,400
matter what you add before or after them

386
00:20:32,400 --> 00:20:36,720
for example after you add a letter A the

387
00:20:36,720 --> 00:20:43,260
H of PSA and q2a are still equal

388
00:20:43,260 --> 00:20:46,080
by knowing the by knowing this feature

389
00:20:46,080 --> 00:20:49,080
it's not difficult to understanding to

390
00:20:49,080 --> 00:20:51,720
understand that two equivalent

391
00:20:51,720 --> 00:20:54,900
substrings can be combined to from

392
00:20:54,900 --> 00:20:57,000
different keys

393
00:20:57,000 --> 00:21:04,580
such as the PSPs psq2 q2ps and Q2 Q2

394
00:21:04,580 --> 00:21:08,960
they all share the same hash

395
00:21:10,200 --> 00:21:12,780
since you can repeat the string many

396
00:21:12,780 --> 00:21:15,480
times constructed constructing the

397
00:21:15,480 --> 00:21:18,960
payload is easy you just need to find a

398
00:21:18,960 --> 00:21:21,360
field string with the send hash and

399
00:21:21,360 --> 00:21:25,100
arrangement in combinations

400
00:21:26,940 --> 00:21:30,679
so all of this share the same hash value

401
00:21:30,679 --> 00:21:35,960
this is Handy for our exploitation

402
00:21:36,000 --> 00:21:39,900
however there is a fatal flow in this

403
00:21:39,900 --> 00:21:40,919
attack

404
00:21:40,919 --> 00:21:42,900
that

405
00:21:42,900 --> 00:21:45,600
is too weak

406
00:21:45,600 --> 00:21:49,260
to get a notice about slow down you must

407
00:21:49,260 --> 00:21:51,480
have sent about 35

408
00:21:51,480 --> 00:21:54,299
000 requests at least

409
00:21:54,299 --> 00:21:57,960
so for our one request at one record

410
00:21:57,960 --> 00:22:01,500
exploit is too slow

411
00:22:01,500 --> 00:22:03,840
and uh

412
00:22:03,840 --> 00:22:07,440
what's more ridiculous is that there's a

413
00:22:07,440 --> 00:22:10,500
cash scavenger to recycle records

414
00:22:10,500 --> 00:22:11,700
regularly

415
00:22:11,700 --> 00:22:14,640
the scavenger is a threat to delete

416
00:22:14,640 --> 00:22:18,840
unused record every 30 seconds every 30

417
00:22:18,840 --> 00:22:20,760
seconds

418
00:22:20,760 --> 00:22:24,720
those two obstacles makes our attacker

419
00:22:24,720 --> 00:22:29,900
make our attack not so practical

420
00:22:31,919 --> 00:22:34,980
to overcome this we have to dive into

421
00:22:34,980 --> 00:22:37,860
the implementation model

422
00:22:37,860 --> 00:22:41,820
during our investigation

423
00:22:42,419 --> 00:22:46,380
we find an interesting behavior that can

424
00:22:46,380 --> 00:22:49,679
rescue the rescue our attack

425
00:22:49,679 --> 00:22:52,679
the implementation will scan the key

426
00:22:52,679 --> 00:22:54,480
recursively

427
00:22:54,480 --> 00:22:58,020
it Trace all subdirectories as new

428
00:22:58,020 --> 00:23:01,620
records and asked all of them to the

429
00:23:01,620 --> 00:23:03,799
table

430
00:23:04,159 --> 00:23:09,299
for example in our imagination the URL

431
00:23:09,299 --> 00:23:12,900
will only trigger one search and one

432
00:23:12,900 --> 00:23:15,299
insert operation

433
00:23:15,299 --> 00:23:17,820
however

434
00:23:17,820 --> 00:23:21,360
each sub directory will also betrayed as

435
00:23:21,360 --> 00:23:24,480
a new record so that the URL will

436
00:23:24,480 --> 00:23:28,020
trigger multiple insert operations

437
00:23:28,020 --> 00:23:31,799
what's more interesting is that

438
00:23:31,799 --> 00:23:34,860
all new case will be packed with a

439
00:23:34,860 --> 00:23:36,059
normal record

440
00:23:36,059 --> 00:23:39,120
the scavenger is nice to know records

441
00:23:39,120 --> 00:23:42,960
and only release them one by one instead

442
00:23:42,960 --> 00:23:47,179
of killing all in a batch

443
00:23:49,200 --> 00:23:53,340
so the only question left is how to

444
00:23:53,340 --> 00:23:56,039
construct the Collision in this new

445
00:23:56,039 --> 00:23:58,440
context

446
00:23:58,440 --> 00:24:01,640
stop the record because because all

447
00:24:01,640 --> 00:24:05,039
subdirectories are Traders are Traders

448
00:24:05,039 --> 00:24:08,220
independent case we have to construct a

449
00:24:08,220 --> 00:24:11,460
payload that satisfies all the following

450
00:24:11,460 --> 00:24:13,440
equations

451
00:24:13,440 --> 00:24:16,799
it may be a little hard to imagine how

452
00:24:16,799 --> 00:24:19,460
to make this happen should our previous

453
00:24:19,460 --> 00:24:23,000
equivalent feature

454
00:24:23,820 --> 00:24:27,419
but if if we map all the results to be

455
00:24:27,419 --> 00:24:30,900
zero then since comes much easier

456
00:24:30,900 --> 00:24:34,980
zero multiply anything is zero and zero

457
00:24:34,980 --> 00:24:38,280
plus zero is also zero

458
00:24:38,280 --> 00:24:42,179
so we can satisfy all the equations if

459
00:24:42,179 --> 00:24:45,480
we make the hash of each subdirectory to

460
00:24:45,480 --> 00:24:47,960
zero

461
00:24:48,240 --> 00:24:52,140
so we can prepare a set of zero hashes

462
00:24:52,140 --> 00:24:55,620
and amplify the attack 10 times at least

463
00:24:55,620 --> 00:24:59,840
by a slide modification

464
00:25:01,140 --> 00:25:04,020
the result is that we can make a server

465
00:25:04,020 --> 00:25:07,679
on responsive with about 30 30

466
00:25:07,679 --> 00:25:11,159
connections per second this is not an

467
00:25:11,159 --> 00:25:14,520
unreasonable number because IIs can

468
00:25:14,520 --> 00:25:17,700
handle thousands of connections

469
00:25:17,700 --> 00:25:19,980
can handle thousands of connections

470
00:25:19,980 --> 00:25:22,860
easily and concurrently

471
00:25:22,860 --> 00:25:25,559
because this bug affects the windows by

472
00:25:25,559 --> 00:25:28,620
default we also avoid a good amount of

473
00:25:28,620 --> 00:25:31,100
bounty

474
00:25:32,400 --> 00:25:36,080
let's check the demo

475
00:25:39,179 --> 00:25:43,260
okay we first double check and ensure

476
00:25:43,260 --> 00:25:47,760
the target server has eight cores and 32

477
00:25:47,760 --> 00:25:50,658
gigabyte Sprint

478
00:25:55,260 --> 00:25:58,860
the window in the lower left is the

479
00:25:58,860 --> 00:26:03,179
script that monitors the status of IIs

480
00:26:03,179 --> 00:26:07,320
it is a simple while loop and checks the

481
00:26:07,320 --> 00:26:10,399
server every second

482
00:26:18,900 --> 00:26:20,640
okay

483
00:26:20,640 --> 00:26:24,840
we first run the random test we we sent

484
00:26:24,840 --> 00:26:27,720
random tests to the IIs

485
00:26:27,720 --> 00:26:30,600
you can see the loading is less than 10

486
00:26:30,600 --> 00:26:32,840
percent

487
00:26:43,860 --> 00:26:48,379
okay we now run the Collision mode

488
00:26:48,659 --> 00:26:51,740
Collision yeah

489
00:26:54,059 --> 00:26:57,059
okay

490
00:27:02,580 --> 00:27:05,779
please wait

491
00:27:07,559 --> 00:27:11,460
okay as you can see the CPU is now on

492
00:27:11,460 --> 00:27:14,360
the high loading

493
00:27:15,299 --> 00:27:18,679
and uh

494
00:27:18,679 --> 00:27:22,400
wait four minutes

495
00:27:24,440 --> 00:27:28,020
and the the check script is enter the

496
00:27:28,020 --> 00:27:30,980
time out Loop

497
00:27:37,080 --> 00:27:41,000
and the CPU loading is 100

498
00:27:41,000 --> 00:27:44,539
uh forever

499
00:27:49,620 --> 00:27:54,260
okay here we speed a little bit up

500
00:27:54,720 --> 00:27:57,320
foreign

501
00:28:08,720 --> 00:28:12,840
is available and cannot handle any

502
00:28:12,840 --> 00:28:15,918
request anymore

503
00:28:16,440 --> 00:28:20,240
okay this is our demo

504
00:28:21,299 --> 00:28:24,240
the second cast is a cash poisoning

505
00:28:24,240 --> 00:28:26,480
attack

506
00:28:26,480 --> 00:28:29,940
there are two types of response catch in

507
00:28:29,940 --> 00:28:33,659
IIs one is the static cache support by

508
00:28:33,659 --> 00:28:37,260
the kernel such as the picture the CSS

509
00:28:37,260 --> 00:28:40,080
and the JavaScript resources

510
00:28:40,080 --> 00:28:42,659
the other is dynamic catch which is

511
00:28:42,659 --> 00:28:46,679
usually used in which is usually used to

512
00:28:46,679 --> 00:28:49,980
catch responses that rarely change

513
00:28:49,980 --> 00:28:52,860
for example the product information of

514
00:28:52,860 --> 00:28:55,620
an online shop or the news announcement

515
00:28:55,620 --> 00:28:57,900
of ncns

516
00:28:57,900 --> 00:29:01,020
the benefit of the dynamic cache is that

517
00:29:01,020 --> 00:29:03,240
you can reduce the number of the

518
00:29:03,240 --> 00:29:06,440
database tests

519
00:29:06,720 --> 00:29:09,960
Dynamic cache is handled by the HTTP

520
00:29:09,960 --> 00:29:12,659
cache module and you can configure the

521
00:29:12,659 --> 00:29:17,240
cache by the output caching component

522
00:29:17,279 --> 00:29:20,640
to use the cache you must first set out

523
00:29:20,640 --> 00:29:23,399
your own rule the law can pass on

524
00:29:23,399 --> 00:29:26,340
several convections such such as the

525
00:29:26,340 --> 00:29:29,640
file extension the query string over the

526
00:29:29,640 --> 00:29:31,440
HTTP header

527
00:29:31,440 --> 00:29:34,200
here we set our level for the extension

528
00:29:34,200 --> 00:29:38,340
of aspx and catch the result based on

529
00:29:38,340 --> 00:29:40,820
the ID

530
00:29:41,700 --> 00:29:44,820
so the low cost of the cash poisoning is

531
00:29:44,820 --> 00:29:47,880
that the manager uses a bad password to

532
00:29:47,880 --> 00:29:49,919
handle the quality string

533
00:29:49,919 --> 00:29:52,620
assign that you have already set out the

534
00:29:52,620 --> 00:29:55,440
rule to catch a specific a specific

535
00:29:55,440 --> 00:29:56,940
pyramid

536
00:29:56,940 --> 00:30:00,000
and inconsistency between the margin and

537
00:30:00,000 --> 00:30:03,000
the backend mainly IIs to catch the

538
00:30:03,000 --> 00:30:04,860
wrong result

539
00:30:04,860 --> 00:30:06,919
foreign

540
00:30:06,919 --> 00:30:11,399
the most common backhand is asp.net and

541
00:30:11,399 --> 00:30:14,820
a simple HTTP Parliament production can

542
00:30:14,820 --> 00:30:16,679
lower than all

543
00:30:16,679 --> 00:30:19,140
for the key to be cast in the color

544
00:30:19,140 --> 00:30:22,140
string the module only uses the first

545
00:30:22,140 --> 00:30:25,080
occurrence of the cache

546
00:30:25,080 --> 00:30:28,559
however the sp.net concatenate all

547
00:30:28,559 --> 00:30:30,120
together

548
00:30:30,120 --> 00:30:33,360
this inconsistent this inconsistent

549
00:30:33,360 --> 00:30:37,020
passive Behavior calls the IIs to catch

550
00:30:37,020 --> 00:30:40,100
the wrong response

551
00:30:40,820 --> 00:30:44,880
for example if a patch just prints out

552
00:30:44,880 --> 00:30:47,100
your name that's on the ID

553
00:30:47,100 --> 00:30:50,100
the attacker can poison the result by

554
00:30:50,100 --> 00:30:54,080
repeating the ID on the URL

555
00:30:54,080 --> 00:30:57,779
IIs only recognized the orange as the

556
00:30:57,779 --> 00:30:58,919
cash key

557
00:30:58,919 --> 00:31:03,000
however the sp.net will concatenate both

558
00:31:03,000 --> 00:31:06,860
values and show them out

559
00:31:07,020 --> 00:31:09,840
so the result is that the next time the

560
00:31:09,840 --> 00:31:14,720
user access the patch he got hacked

561
00:31:15,480 --> 00:31:18,020
foreign

562
00:31:18,020 --> 00:31:22,399
is the authentication bypass

563
00:31:22,620 --> 00:31:26,159
back to our opening a super secret area

564
00:31:26,159 --> 00:31:28,919
which is protected by a super strong

565
00:31:28,919 --> 00:31:33,779
passwords under the design of the IIs

566
00:31:33,779 --> 00:31:37,260
all of these passwords are valid

567
00:31:37,260 --> 00:31:39,480
I guess you might have several questions

568
00:31:39,480 --> 00:31:42,419
and be thinking

569
00:31:42,419 --> 00:31:44,580
what's the loot codes

570
00:31:44,580 --> 00:31:48,059
or how do I get those passwords

571
00:31:48,059 --> 00:31:50,880
or suspect this must be an edge case

572
00:31:50,880 --> 00:31:55,640
what kind of the scenario is vulnerable

573
00:31:57,000 --> 00:32:01,919
first log on is an expensive operation

574
00:32:01,919 --> 00:32:05,100
to not reduce the performance IIs

575
00:32:05,100 --> 00:32:08,580
patches all tokens for password best

576
00:32:08,580 --> 00:32:11,640
authentication by default

577
00:32:11,640 --> 00:32:14,880
the implementation uses the LKR hash

578
00:32:14,880 --> 00:32:17,820
instead of the tree hash table and

579
00:32:17,820 --> 00:32:21,120
configure a scavenger to delete unused

580
00:32:21,120 --> 00:32:25,260
record every 15 minutes

581
00:32:25,260 --> 00:32:27,799
foreign

582
00:32:28,640 --> 00:32:31,620
is highly customized

583
00:32:31,620 --> 00:32:34,860
during initialization the module defines

584
00:32:34,860 --> 00:32:37,559
several functions such as the hash

585
00:32:37,559 --> 00:32:38,640
function

586
00:32:38,640 --> 00:32:41,640
the logic of how to extracting the key

587
00:32:41,640 --> 00:32:45,299
from the breaker and how to decide which

588
00:32:45,299 --> 00:32:47,820
one is the correct record when the

589
00:32:47,820 --> 00:32:50,600
Collision happened

590
00:32:51,360 --> 00:32:54,600
and this is the hash function defined by

591
00:32:54,600 --> 00:32:58,500
the token cache module it simply uses

592
00:32:58,500 --> 00:33:01,980
the djb to Hash the username and the

593
00:33:01,980 --> 00:33:05,460
password and then mix them together by X

594
00:33:05,460 --> 00:33:07,760
all

595
00:33:09,740 --> 00:33:11,460
and

596
00:33:11,460 --> 00:33:14,580
this is the function used to decide

597
00:33:14,580 --> 00:33:18,360
which one is the correct record when the

598
00:33:18,360 --> 00:33:20,220
Collision happens

599
00:33:20,220 --> 00:33:23,340
the function first checks whether the

600
00:33:23,340 --> 00:33:26,880
log on next of both records are equal or

601
00:33:26,880 --> 00:33:27,840
not

602
00:33:27,840 --> 00:33:32,360
and then compare their username

603
00:33:32,360 --> 00:33:36,600
and compare the username again

604
00:33:36,600 --> 00:33:39,840
you may be wondering

605
00:33:39,840 --> 00:33:42,960
why did function compare the username

606
00:33:42,960 --> 00:33:45,059
twice

607
00:33:45,059 --> 00:33:48,659
I guess the original intent of IIs was

608
00:33:48,659 --> 00:33:51,059
to compare the password

609
00:33:51,059 --> 00:33:54,360
however the developer copy and passed

610
00:33:54,360 --> 00:33:57,720
the code but forgot to repress the name

611
00:33:57,720 --> 00:34:00,559
to the possible

612
00:34:00,659 --> 00:34:03,860
it's a big fail

613
00:34:05,880 --> 00:34:08,820
the failure could add an inconsistency

614
00:34:08,820 --> 00:34:11,699
between the hash calculation and the

615
00:34:11,699 --> 00:34:13,619
cash comparison

616
00:34:13,619 --> 00:34:16,440
the hash calculation involves both the

617
00:34:16,440 --> 00:34:18,599
username and the password

618
00:34:18,599 --> 00:34:22,379
however when the Collision occurs the

619
00:34:22,379 --> 00:34:25,440
table only compare the username to get

620
00:34:25,440 --> 00:34:27,599
the correct entry

621
00:34:27,599 --> 00:34:30,300
since we can adjust the field of the

622
00:34:30,300 --> 00:34:32,940
password to change the hash

623
00:34:32,940 --> 00:34:37,199
if a hash if a hash hit a record that is

624
00:34:37,199 --> 00:34:39,839
already in the table the module will

625
00:34:39,839 --> 00:34:43,879
return that to Earth directory

626
00:34:44,639 --> 00:34:47,639
so the result is that you can reuse

627
00:34:47,639 --> 00:34:51,839
another user's logo login token with

628
00:34:51,839 --> 00:34:54,659
random passwords

629
00:34:54,659 --> 00:34:57,180
however there are still a few

630
00:34:57,180 --> 00:34:59,099
prerequisites

631
00:34:59,099 --> 00:35:03,359
first each password attempt only has the

632
00:35:03,359 --> 00:35:07,020
success rate of 4.2 billion because the

633
00:35:07,020 --> 00:35:11,579
hash is is a 32-bit integer

634
00:35:11,579 --> 00:35:14,940
the other is that there must be a

635
00:35:14,940 --> 00:35:16,560
successful looking

636
00:35:16,560 --> 00:35:20,700
uh but the other is that there must be a

637
00:35:20,700 --> 00:35:24,420
successful logging before our attack

638
00:35:24,420 --> 00:35:27,000
however once the loading is done and the

639
00:35:27,000 --> 00:35:29,640
token is cached in the memory you have

640
00:35:29,640 --> 00:35:32,579
unlimited attempts during the 15 minutes

641
00:35:32,579 --> 00:35:35,300
time window

642
00:35:36,359 --> 00:35:40,339
so to make this box a more severe

643
00:35:40,339 --> 00:35:43,920
malability we have developed several

644
00:35:43,920 --> 00:35:46,680
ways to win the lottery

645
00:35:46,680 --> 00:35:49,800
the first enhancements is to increase

646
00:35:49,800 --> 00:35:53,660
the probability of the Collision

647
00:35:53,660 --> 00:35:57,960
and a vulnerability that requires user

648
00:35:57,960 --> 00:36:00,720
interaction is to land

649
00:36:00,720 --> 00:36:04,079
so for the second enhancement we must

650
00:36:04,079 --> 00:36:07,380
find a way to exploit without user

651
00:36:07,380 --> 00:36:09,599
interaction

652
00:36:09,599 --> 00:36:13,440
the last is to defeat the Restriction of

653
00:36:13,440 --> 00:36:16,859
the 15-minute time window we figure out

654
00:36:16,859 --> 00:36:21,680
a way to catch the token forever

655
00:36:22,880 --> 00:36:26,400
okay the first enhancement is to

656
00:36:26,400 --> 00:36:28,800
increase the probability

657
00:36:28,800 --> 00:36:31,859
as we mentioned that the 4 billion

658
00:36:31,859 --> 00:36:35,400
possible records are are a ridiculous

659
00:36:35,400 --> 00:36:36,960
number

660
00:36:36,960 --> 00:36:41,880
the LKR hash even uses an lstg to make

661
00:36:41,880 --> 00:36:44,700
the result more rendered

662
00:36:44,700 --> 00:36:48,960
but just because of this locg we can

663
00:36:48,960 --> 00:36:52,800
lower the key space because the lcg is

664
00:36:52,800 --> 00:36:54,960
not one-to-one mapping under the key

665
00:36:54,960 --> 00:36:59,180
space of 32-bit integer

666
00:36:59,220 --> 00:37:03,359
so there must be results that will never

667
00:37:03,359 --> 00:37:04,920
appear

668
00:37:04,920 --> 00:37:07,920
we can pre-compute a dictionary that

669
00:37:07,920 --> 00:37:10,980
actually excludes the password whose

670
00:37:10,980 --> 00:37:13,560
hash is not in the results

671
00:37:13,560 --> 00:37:16,440
this development can reduce a number of

672
00:37:16,440 --> 00:37:19,200
key stats

673
00:37:19,200 --> 00:37:21,599
also there are still billion possible

674
00:37:21,599 --> 00:37:24,599
records we have increased the success

675
00:37:24,599 --> 00:37:29,099
rate by 30 percent at least

676
00:37:29,099 --> 00:37:29,940
thank you

677
00:37:29,940 --> 00:37:33,540
the second enhancement is to regen Regan

678
00:37:33,540 --> 00:37:34,740
the initiative

679
00:37:34,740 --> 00:37:37,800
there is a feature called connect us

680
00:37:37,800 --> 00:37:41,760
that is usually that is usually used in

681
00:37:41,760 --> 00:37:44,220
the virtual hosting because the vendor

682
00:37:44,220 --> 00:37:47,400
has to separate IIs process for their

683
00:37:47,400 --> 00:37:48,780
customers

684
00:37:48,780 --> 00:37:52,500
with this feature each IIs process can

685
00:37:52,500 --> 00:37:56,960
be under different user contexts

686
00:37:57,780 --> 00:38:01,500
so under this feature IIs will Auto look

687
00:38:01,500 --> 00:38:04,160
on the user use best you specify

688
00:38:04,160 --> 00:38:06,839
corresponding the new process

689
00:38:06,839 --> 00:38:10,380
this token will also be cached that

690
00:38:10,380 --> 00:38:13,200
means we can reuse the customer's

691
00:38:13,200 --> 00:38:16,859
identity and no longer to wait for user

692
00:38:16,859 --> 00:38:18,660
interaction

693
00:38:18,660 --> 00:38:21,180
in this case we have regained the

694
00:38:21,180 --> 00:38:23,720
initiative

695
00:38:24,780 --> 00:38:27,720
to prove it works we did a test in our

696
00:38:27,720 --> 00:38:29,160
lab environment

697
00:38:29,160 --> 00:38:32,640
Windows Server can handle about 1

698
00:38:32,640 --> 00:38:36,060
000 and 800 logging attempts per second

699
00:38:36,060 --> 00:38:39,599
because every attempts cost nothing you

700
00:38:39,599 --> 00:38:42,060
can run this all day and the success

701
00:38:42,060 --> 00:38:46,020
rate is about 42 percent

702
00:38:46,020 --> 00:38:48,619
foreign

703
00:38:54,480 --> 00:38:57,780
you can also rank it for longer five

704
00:38:57,780 --> 00:39:02,640
days for 20 12 days for 50 and the

705
00:39:02,640 --> 00:39:06,480
success rate of running for 24 days can

706
00:39:06,480 --> 00:39:09,859
get 100 percent

707
00:39:09,900 --> 00:39:12,060
we have reproduced in our lab

708
00:39:12,060 --> 00:39:14,820
environment and can get a password in

709
00:39:14,820 --> 00:39:17,839
about five days

710
00:39:18,180 --> 00:39:21,000
the last enhancement is to defeat the

711
00:39:21,000 --> 00:39:25,740
tie window our idea is simple in modern

712
00:39:25,740 --> 00:39:28,619
software architecture it's common to see

713
00:39:28,619 --> 00:39:31,500
the pattern of a background demon

714
00:39:31,500 --> 00:39:34,200
monitors the system's healthy

715
00:39:34,200 --> 00:39:37,020
or several Chrome jobs access the

716
00:39:37,020 --> 00:39:40,940
internal apis regularly

717
00:39:42,359 --> 00:39:46,380
so we can assign a situation that a

718
00:39:46,380 --> 00:39:49,020
credential is attached with the contract

719
00:39:49,020 --> 00:39:52,320
and the gap between each assets is less

720
00:39:52,320 --> 00:39:55,380
than 50 15 minutes

721
00:39:55,380 --> 00:39:58,320
in this assumption the token will be

722
00:39:58,320 --> 00:40:01,339
cashed forever

723
00:40:01,440 --> 00:40:04,980
okay I know it's very I I know it's very

724
00:40:04,980 --> 00:40:09,500
ideal is there any real test

725
00:40:09,960 --> 00:40:12,480
sure let's talk about The Exchange

726
00:40:12,480 --> 00:40:15,320
Server again

727
00:40:15,960 --> 00:40:18,599
there is a service called active

728
00:40:18,599 --> 00:40:21,780
monitoring which is enabled by default

729
00:40:21,780 --> 00:40:24,960
and responsible for monitoring all

730
00:40:24,960 --> 00:40:26,520
services

731
00:40:26,520 --> 00:40:30,240
it checks the owa and the active sync

732
00:40:30,240 --> 00:40:33,480
service every 10 minutes with a text

733
00:40:33,480 --> 00:40:36,180
with a test credential

734
00:40:36,180 --> 00:40:39,359
so thanks for the health check the token

735
00:40:39,359 --> 00:40:43,940
of the credential will be cashed forever

736
00:40:45,060 --> 00:40:48,540
you can try as many as you like until

737
00:40:48,540 --> 00:40:52,520
you get a successful login

738
00:40:52,859 --> 00:40:56,520
and the password is also usable to log

739
00:40:56,520 --> 00:40:59,960
into the owa

740
00:41:00,619 --> 00:41:04,140
the account for the health track has its

741
00:41:04,140 --> 00:41:07,140
own mailbox too this is useful for

742
00:41:07,140 --> 00:41:10,619
further exploitations such as fishing or

743
00:41:10,619 --> 00:41:12,720
training and other post office rce

744
00:41:12,720 --> 00:41:14,099
together

745
00:41:14,099 --> 00:41:17,420
that's our last test

746
00:41:18,240 --> 00:41:21,420
okay let's talk about medications and

747
00:41:21,420 --> 00:41:23,820
Future Works

748
00:41:23,820 --> 00:41:26,220
for the design of the hash table it's

749
00:41:26,220 --> 00:41:28,380
recommend to use the pseudo-render

750
00:41:28,380 --> 00:41:31,440
functions such as the Sip hash or

751
00:41:31,440 --> 00:41:33,839
Highway hash that can reduce the

752
00:41:33,839 --> 00:41:36,180
collision and make the attacker more

753
00:41:36,180 --> 00:41:37,680
costly

754
00:41:37,680 --> 00:41:39,740
for the design of the cache

755
00:41:39,740 --> 00:41:42,660
inconsistency is still the king just

756
00:41:42,660 --> 00:41:45,180
like our classes today the cash

757
00:41:45,180 --> 00:41:47,700
poisoning due to the different possible

758
00:41:47,700 --> 00:41:49,980
behaviors and the authentication

759
00:41:49,980 --> 00:41:54,119
bypassed due to the unkinned Past groups

760
00:41:54,119 --> 00:41:57,000
since the hash voting attack is by this

761
00:41:57,000 --> 00:41:59,099
side attack there are several

762
00:41:59,099 --> 00:42:01,440
workarounds to mitigate the problems

763
00:42:01,440 --> 00:42:05,099
such as the input size limitation or a

764
00:42:05,099 --> 00:42:07,800
state to randomize the hash

765
00:42:07,800 --> 00:42:10,880
if solution has its limitations

766
00:42:10,880 --> 00:42:14,880
so so my last recommendation is to learn

767
00:42:14,880 --> 00:42:17,900
from the history

768
00:42:18,720 --> 00:42:21,960
there are still several cool ideas in my

769
00:42:21,960 --> 00:42:24,780
mind such as using Timeless timing

770
00:42:24,780 --> 00:42:27,780
attack to reduce the keys fast

771
00:42:27,780 --> 00:42:31,380
however since I am lazy will come to

772
00:42:31,380 --> 00:42:35,660
pick them up if you are interested

773
00:42:35,960 --> 00:42:39,599
this is the end of my presentation if

774
00:42:39,599 --> 00:42:42,060
you have any questions here's my contact

775
00:42:42,060 --> 00:42:43,440
information

776
00:42:43,440 --> 00:42:48,020
thank you again for being here thanks

777
00:42:48,390 --> 00:42:51,509
[Music]

778
00:42:55,350 --> 00:42:58,440
[Music]

