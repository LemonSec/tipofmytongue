1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,460 --> 00:00:09,720
so thank you for the kind introduction

3
00:00:09,720 --> 00:00:11,400
and today we're going to present to you

4
00:00:11,400 --> 00:00:13,200
I had actually leaking data from the

5
00:00:13,200 --> 00:00:16,079
micro architecture actually we lied to

6
00:00:16,079 --> 00:00:19,380
you since that's not the title today we

7
00:00:19,380 --> 00:00:20,760
are going to present a

8
00:00:20,760 --> 00:00:22,980
big leak architectural leaking

9
00:00:22,980 --> 00:00:25,140
uninitialized data from the macro

10
00:00:25,140 --> 00:00:26,279
architecture

11
00:00:26,279 --> 00:00:28,920
you will witness the first architectural

12
00:00:28,920 --> 00:00:31,260
bug that is able to leak stale data

13
00:00:31,260 --> 00:00:34,140
without any side Channel and furthermore

14
00:00:34,140 --> 00:00:37,200
it's not a transient execution attack

15
00:00:37,200 --> 00:00:39,960
it's able to deterministically leaks

16
00:00:39,960 --> 00:00:43,379
stale data from sjx enclaves

17
00:00:43,379 --> 00:00:45,840
and also we do not even require hyper

18
00:00:45,840 --> 00:00:47,640
threading for the basic leakage to

19
00:00:47,640 --> 00:00:49,980
happen yeah and it affects like most

20
00:00:49,980 --> 00:00:53,520
recent Intel CPUs so the name is epic

21
00:00:53,520 --> 00:00:56,340
league so what is epic league so in the

22
00:00:56,340 --> 00:00:59,160
name we have epic like and the component

23
00:00:59,160 --> 00:01:01,440
so what is actually the Epic component

24
00:01:01,440 --> 00:01:04,860
in a modern CPU yeah so the Epic is this

25
00:01:04,860 --> 00:01:06,360
component in the CPU that is like

26
00:01:06,360 --> 00:01:08,820
responsible to like generate receiving

27
00:01:08,820 --> 00:01:11,820
generic might manage all the interrupts

28
00:01:11,820 --> 00:01:14,100
for like smaller CPUs we have a local

29
00:01:14,100 --> 00:01:17,220
epic for every core and like an IO epic

30
00:01:17,220 --> 00:01:19,920
for like external devices like you

31
00:01:19,920 --> 00:01:22,920
interact with the Epic with like the

32
00:01:22,920 --> 00:01:25,680
Epic registers that by default are

33
00:01:25,680 --> 00:01:28,259
memory mapped they are mapped on a like

34
00:01:28,259 --> 00:01:30,659
region that is a physical memory that is

35
00:01:30,659 --> 00:01:33,060
okay controlled by an MSR and they are

36
00:01:33,060 --> 00:01:36,479
all 32 bits and always aligned to 16

37
00:01:36,479 --> 00:01:40,020
bytes so wait if it only have 32 bits

38
00:01:40,020 --> 00:01:42,180
and there was a line to 16 bytes with a

39
00:01:42,180 --> 00:01:43,979
lot of free spaces and actually the Epic

40
00:01:43,979 --> 00:01:45,900
range yes and the really important thing

41
00:01:45,900 --> 00:01:48,600
is that you should never ever access

42
00:01:48,600 --> 00:01:52,140
bytes 4 through 15 of this epic mmao

43
00:01:52,140 --> 00:01:55,380
region okay but why oh yeah actually

44
00:01:55,380 --> 00:01:58,320
Intel tells it oh if you read the Epic

45
00:01:58,320 --> 00:02:01,259
the inter manual you can see that any

46
00:02:01,259 --> 00:02:04,560
access to byte for 4 through 15 may

47
00:02:04,560 --> 00:02:06,659
cause undefined Behavior

48
00:02:06,659 --> 00:02:09,060
so wait the Intel manual says that if

49
00:02:09,060 --> 00:02:11,400
you access those bytes you get undefined

50
00:02:11,400 --> 00:02:13,459
Behavior yes or incorrect results

51
00:02:13,459 --> 00:02:17,459
exactly so let's try this yes so we can

52
00:02:17,459 --> 00:02:19,560
simply like you saw like a simple POC

53
00:02:19,560 --> 00:02:22,200
where we Mark the we map the AP and dump

54
00:02:22,200 --> 00:02:25,379
it not not so fast so we let me explain

55
00:02:25,379 --> 00:02:26,940
those lines let's go over the lines a

56
00:02:26,940 --> 00:02:28,620
little bit more slowly yeah so in the

57
00:02:28,620 --> 00:02:30,840
first line we can see that we map the

58
00:02:30,840 --> 00:02:32,280
physical address where the Epic is

59
00:02:32,280 --> 00:02:34,260
located into the virtual address space

60
00:02:34,260 --> 00:02:36,540
so we can actually read from it and then

61
00:02:36,540 --> 00:02:39,540
I assume this first dump Epic Base from

62
00:02:39,540 --> 00:02:41,819
zero that's just reading the the normal

63
00:02:41,819 --> 00:02:43,500
that's a valid register so you're like

64
00:02:43,500 --> 00:02:45,660
what you were expecting so we get zeros

65
00:02:45,660 --> 00:02:46,440
back

66
00:02:46,440 --> 00:02:48,420
but then let's continue let's continue

67
00:02:48,420 --> 00:02:51,120
might be like dumping the Epic so we see

68
00:02:51,120 --> 00:02:53,220
something so what's happening there so

69
00:02:53,220 --> 00:02:55,019
if we access those bytes these four to

70
00:02:55,019 --> 00:02:58,379
15 bytes we get back one interrupt yeah

71
00:02:58,379 --> 00:03:00,360
like what is this is it in the Epic if

72
00:03:00,360 --> 00:03:03,060
we continue to dump it like we have data

73
00:03:03,060 --> 00:03:05,940
isn't it strange so if you look at this

74
00:03:05,940 --> 00:03:07,739
memory jump we basically generated by

75
00:03:07,739 --> 00:03:09,780
just reading from the Epic we can see

76
00:03:09,780 --> 00:03:11,400
that in the first four bytes we always

77
00:03:11,400 --> 00:03:13,800
get like Valley epic data but on the

78
00:03:13,800 --> 00:03:16,680
byte from 4 to 15 we get strings yeah

79
00:03:16,680 --> 00:03:18,959
that's strings and what's Happening Here

80
00:03:18,959 --> 00:03:22,019
we are architecturally leaking State

81
00:03:22,019 --> 00:03:25,019
values just by dumping the Epic mmio

82
00:03:25,019 --> 00:03:27,300
region so I can see that this is data

83
00:03:27,300 --> 00:03:29,280
because that's obviously strings one

84
00:03:29,280 --> 00:03:30,900
interrupt Source bending or something

85
00:03:30,900 --> 00:03:32,819
like that but if you take a look at this

86
00:03:32,819 --> 00:03:35,940
dump here uuh that's not a string so

87
00:03:35,940 --> 00:03:38,159
yeah okay there's no data that's

88
00:03:38,159 --> 00:03:39,659
instructions

89
00:03:39,659 --> 00:03:41,700
wait these are instructions yeah let's

90
00:03:41,700 --> 00:03:43,440
disassemble it like you just see it

91
00:03:43,440 --> 00:03:45,180
value destruction there like

92
00:03:45,180 --> 00:03:47,280
obviously not in the Epic but we read

93
00:03:47,280 --> 00:03:50,340
that so we just recovered instructions

94
00:03:50,340 --> 00:03:53,159
which are able to disassemble from

95
00:03:53,159 --> 00:03:55,920
Reading undefined epic registers exactly

96
00:03:55,920 --> 00:03:59,099
okay actually not on every CPUs so on

97
00:03:59,099 --> 00:04:01,620
most CPUs you read either zeros or refs

98
00:04:01,620 --> 00:04:03,840
or like sometimes even the whole CPU

99
00:04:03,840 --> 00:04:06,780
hangs or triple filter reboots but on

100
00:04:06,780 --> 00:04:09,480
Modern CPUs from Intel like 10 11th and

101
00:04:09,480 --> 00:04:12,780
12th generation CPUs that's not the case

102
00:04:12,780 --> 00:04:15,959
okay okay okay I I see that we leaked

103
00:04:15,959 --> 00:04:17,279
some data I see that leaks some

104
00:04:17,279 --> 00:04:19,260
instructions but where the hell do we

105
00:04:19,260 --> 00:04:21,060
leak instructions from where does the

106
00:04:21,060 --> 00:04:23,759
leakage actually come from yeah so we

107
00:04:23,759 --> 00:04:26,220
can devise simple experiments to try to

108
00:04:26,220 --> 00:04:27,900
understand okay where this data came

109
00:04:27,900 --> 00:04:30,060
from we can like we have here a model of

110
00:04:30,060 --> 00:04:32,699
the CPU with like all the stages from

111
00:04:32,699 --> 00:04:35,160
the CPU to memory and we can start to

112
00:04:35,160 --> 00:04:36,240
understand and start to try to

113
00:04:36,240 --> 00:04:37,680
understand like where does it come from

114
00:04:37,680 --> 00:04:39,780
okay let's let's just systematically go

115
00:04:39,780 --> 00:04:41,940
over this so can we leak is the data

116
00:04:41,940 --> 00:04:43,380
leaking from the registers or the

117
00:04:43,380 --> 00:04:45,419
execution engine yeah so let's do an

118
00:04:45,419 --> 00:04:47,940
experiment where we only keep data in

119
00:04:47,940 --> 00:04:49,380
the registers all right we make simple

120
00:04:49,380 --> 00:04:51,300
operation with that and we don't see

121
00:04:51,300 --> 00:04:53,400
that data so it's not coming from

122
00:04:53,400 --> 00:04:55,440
register or the execution engine what

123
00:04:55,440 --> 00:04:57,180
about the private caches of the core so

124
00:04:57,180 --> 00:05:00,000
L1 or L2 yeah so like now we're talking

125
00:05:00,000 --> 00:05:02,820
about the memory and okay if we access a

126
00:05:02,820 --> 00:05:04,979
lot of memory we see leaks but if we

127
00:05:04,979 --> 00:05:06,479
only access a small amount of memory

128
00:05:06,479 --> 00:05:09,360
like that fits in the L1 or L2 cache we

129
00:05:09,360 --> 00:05:10,680
don't see anything

130
00:05:10,680 --> 00:05:13,320
okay I also see that what about the

131
00:05:13,320 --> 00:05:15,780
shared hash so the LSC or even the Ram

132
00:05:15,780 --> 00:05:17,759
or the memory subsystem in general yeah

133
00:05:17,759 --> 00:05:19,919
that's interesting too if we access like

134
00:05:19,919 --> 00:05:21,600
a lot of memory from a color then we see

135
00:05:21,600 --> 00:05:23,820
leaks but with the only access that

136
00:05:23,820 --> 00:05:26,460
memory from another code different than

137
00:05:26,460 --> 00:05:28,500
the work that we are looking from we

138
00:05:28,500 --> 00:05:30,900
don't see anything there

139
00:05:30,900 --> 00:05:33,120
okay so we systematically go over all

140
00:05:33,120 --> 00:05:35,160
these components what is what is missing

141
00:05:35,160 --> 00:05:36,600
what do we miss yeah it must be

142
00:05:36,600 --> 00:05:37,919
something in the middle it does the

143
00:05:37,919 --> 00:05:41,400
super queue so what's the super queue so

144
00:05:41,400 --> 00:05:43,139
it's really simple the super queue is

145
00:05:43,139 --> 00:05:45,419
this the coupling buffer between the L2

146
00:05:45,419 --> 00:05:48,240
cache and the LLC it just contains like

147
00:05:48,240 --> 00:05:50,160
all the data that passes between the two

148
00:05:50,160 --> 00:05:52,620
caches like from the L2 to the LLC and

149
00:05:52,620 --> 00:05:55,680
back and forth so if you were like if

150
00:05:55,680 --> 00:05:57,360
you know like MDS attacks and all this

151
00:05:57,360 --> 00:05:58,680
stuff they were targeting like line

152
00:05:58,680 --> 00:06:00,960
field buffers is the same but line field

153
00:06:00,960 --> 00:06:03,419
buffers were between L1 and little cache

154
00:06:03,419 --> 00:06:05,580
and here we're talking about L2 cache

155
00:06:05,580 --> 00:06:07,259
and LLC cache

156
00:06:07,259 --> 00:06:09,600
okay so what we're now talking about an

157
00:06:09,600 --> 00:06:11,580
interconnection between the L2 and the

158
00:06:11,580 --> 00:06:14,280
LSC and we can leak data that's passing

159
00:06:14,280 --> 00:06:16,259
over this interconnection but can we

160
00:06:16,259 --> 00:06:17,880
actually leak all the data that's

161
00:06:17,880 --> 00:06:19,500
passing over those using the connections

162
00:06:19,500 --> 00:06:21,120
no okay first of all we are talking

163
00:06:21,120 --> 00:06:24,000
about undefined offsets of the Epic mmio

164
00:06:24,000 --> 00:06:26,819
so every time we read like the initial

165
00:06:26,819 --> 00:06:29,220
values of the APK mmao registers we

166
00:06:29,220 --> 00:06:30,900
don't see anything so we only leak three

167
00:06:30,900 --> 00:06:33,419
quarters of a cache line oh I can see

168
00:06:33,419 --> 00:06:35,340
that because one quarter of each of the

169
00:06:35,340 --> 00:06:37,620
16 byte regions is actually a valid epic

170
00:06:37,620 --> 00:06:39,240
register so you will never leak from

171
00:06:39,240 --> 00:06:40,919
that because you're giving just back the

172
00:06:40,919 --> 00:06:43,440
defined epic value for the register yeah

173
00:06:43,440 --> 00:06:45,419
and then there is something more we

174
00:06:45,419 --> 00:06:47,220
cannot explain this but in all our

175
00:06:47,220 --> 00:06:50,400
experiments we always ever observed even

176
00:06:50,400 --> 00:06:53,280
cache lines so if we map the like the if

177
00:06:53,280 --> 00:06:55,199
you number the cache lines in a page

178
00:06:55,199 --> 00:06:57,360
from like the zeros the the first the

179
00:06:57,360 --> 00:07:00,300
second Etc you only leak values from the

180
00:07:00,300 --> 00:07:02,340
zeroth the second the first and that's

181
00:07:02,340 --> 00:07:05,400
it so we can leak like three quarters of

182
00:07:05,400 --> 00:07:07,440
even cash lines

183
00:07:07,440 --> 00:07:10,380
now we see we like we have this really

184
00:07:10,380 --> 00:07:13,139
cool attacks where we leak data from the

185
00:07:13,139 --> 00:07:16,380
super queue and so we can think about it

186
00:07:16,380 --> 00:07:19,860
as if it was like an initialized memory

187
00:07:19,860 --> 00:07:22,620
reads but in the CPU itself so it's not

188
00:07:22,620 --> 00:07:25,080
like at the software level but that's at

189
00:07:25,080 --> 00:07:26,759
the hardware level

190
00:07:26,759 --> 00:07:29,460
but we have kind of like I would say a

191
00:07:29,460 --> 00:07:31,860
problem here to exploit this we have to

192
00:07:31,860 --> 00:07:34,500
access the Epic mmio registers

193
00:07:34,500 --> 00:07:36,300
and the problem is that's only like

194
00:07:36,300 --> 00:07:38,520
something like an operating system can

195
00:07:38,520 --> 00:07:40,740
access that so I mean what can we attack

196
00:07:40,740 --> 00:07:43,680
with this so actually their Intel sgx

197
00:07:43,680 --> 00:07:45,360
comes to the rescue

198
00:07:45,360 --> 00:07:47,639
and the other thing what's interest GX

199
00:07:47,639 --> 00:07:50,280
so intellects is this uh environment as

200
00:07:50,280 --> 00:07:51,660
it is the software software guard

201
00:07:51,660 --> 00:07:53,639
extension that

202
00:07:53,639 --> 00:07:56,039
aims to give you an environment where

203
00:07:56,039 --> 00:07:57,900
your code on data is all protected

204
00:07:57,900 --> 00:07:59,940
against a privileged attacker and this

205
00:07:59,940 --> 00:08:02,280
also includes a malicious operating s

206
00:08:02,280 --> 00:08:04,740
operating system for example so with a

207
00:08:04,740 --> 00:08:06,300
malicious operating system we could like

208
00:08:06,300 --> 00:08:08,940
map the Epic mmao region and access it

209
00:08:08,940 --> 00:08:11,039
to leaked data that's interesting but

210
00:08:11,039 --> 00:08:13,560
how do they protect memory with sgx so

211
00:08:13,560 --> 00:08:15,599
one of the key concepts of sjx is that

212
00:08:15,599 --> 00:08:18,240
it transparently encrypts data that is

213
00:08:18,240 --> 00:08:20,280
stored in The Enclave this is done by

214
00:08:20,280 --> 00:08:22,919
The Enclave pagecars this is a small

215
00:08:22,919 --> 00:08:25,139
region in Ram where basically the data

216
00:08:25,139 --> 00:08:26,819
gets transparently encrypted if you

217
00:08:26,819 --> 00:08:28,379
write data to it

218
00:08:28,379 --> 00:08:30,240
okay that's interesting so we are

219
00:08:30,240 --> 00:08:32,339
talking about pages but isn't the like

220
00:08:32,339 --> 00:08:34,559
operating system that manages Pages here

221
00:08:34,559 --> 00:08:37,080
yes that's a really good point also in

222
00:08:37,080 --> 00:08:39,240
sgx the operating system is still

223
00:08:39,240 --> 00:08:41,339
responsible for the page management of

224
00:08:41,339 --> 00:08:43,740
an enclave and furthermore in each of

225
00:08:43,740 --> 00:08:45,540
the enclaves and sjx you have one

226
00:08:45,540 --> 00:08:47,880
specific page special page the store

227
00:08:47,880 --> 00:08:50,040
called State safe area and the idea of

228
00:08:50,040 --> 00:08:52,680
this page is to store register values

229
00:08:52,680 --> 00:08:54,420
you have to safely store them for

230
00:08:54,420 --> 00:08:56,279
example if an asynchronous event occurs

231
00:08:56,279 --> 00:08:57,660
think of life you can interrupt

232
00:08:57,660 --> 00:09:00,000
interrupt the idea is that you store the

233
00:09:00,000 --> 00:09:02,100
registers there before giving back the

234
00:09:02,100 --> 00:09:03,959
control flow to the operating system

235
00:09:03,959 --> 00:09:07,140
which is potentially malicious oh that's

236
00:09:07,140 --> 00:09:10,080
cool so if we target sgx enclaves we can

237
00:09:10,080 --> 00:09:12,720
like sample data from this Enclave like

238
00:09:12,720 --> 00:09:15,000
we can run the enclave and use an upper

239
00:09:15,000 --> 00:09:17,760
thread to like dump the Epic and then

240
00:09:17,760 --> 00:09:19,920
like there we can leak the values that

241
00:09:19,920 --> 00:09:21,720
they're using but

242
00:09:21,720 --> 00:09:23,940
that's that's not enough like how can we

243
00:09:23,940 --> 00:09:26,700
lick interesting data is there any way

244
00:09:26,700 --> 00:09:28,500
that we can like force the data that we

245
00:09:28,500 --> 00:09:30,180
want to leak to be in the Super queue

246
00:09:30,180 --> 00:09:32,940
and like to keep this data long enough

247
00:09:32,940 --> 00:09:35,580
to be able to leak those data that's a

248
00:09:35,580 --> 00:09:37,320
really good point and that brings us to

249
00:09:37,320 --> 00:09:41,040
Enclave shaking so Enclave shaking uses

250
00:09:41,040 --> 00:09:43,140
those two instructions which are

251
00:09:43,140 --> 00:09:45,300
basically responsible for taking a page

252
00:09:45,300 --> 00:09:47,760
out of the EPC page cache and bringing

253
00:09:47,760 --> 00:09:50,279
them back to main memory this is done so

254
00:09:50,279 --> 00:09:53,700
by using the evb instruction and just

255
00:09:53,700 --> 00:09:55,980
brings the data to from the encrypted

256
00:09:55,980 --> 00:09:58,500
page to the core re-encrypts it and then

257
00:09:58,500 --> 00:10:00,360
stores it into the main memory and if

258
00:10:00,360 --> 00:10:01,920
you can guess what the counterpart is

259
00:10:01,920 --> 00:10:03,420
yeah I would say that they'll do

260
00:10:03,420 --> 00:10:05,640
instructions then like brings the page

261
00:10:05,640 --> 00:10:08,519
from the like main memory and the grips

262
00:10:08,519 --> 00:10:11,040
it and like put it back to into the APC

263
00:10:11,040 --> 00:10:12,839
exactly and this gets a bit more

264
00:10:12,839 --> 00:10:15,000
visualized here if you see on the right

265
00:10:15,000 --> 00:10:17,880
side we have one page inside the sjx

266
00:10:17,880 --> 00:10:20,580
page cache and we can now use ewb to

267
00:10:20,580 --> 00:10:23,459
bring that page to the core re-encrypted

268
00:10:23,459 --> 00:10:25,380
and then booted out into the main memory

269
00:10:25,380 --> 00:10:27,120
okay this is very interesting since

270
00:10:27,120 --> 00:10:29,580
while we bring this page like back and

271
00:10:29,580 --> 00:10:31,920
forth to the CPU to the memory then we

272
00:10:31,920 --> 00:10:33,480
are literally making the page pass

273
00:10:33,480 --> 00:10:35,760
through the super queue so that we left

274
00:10:35,760 --> 00:10:38,220
the data that is in the page passing

275
00:10:38,220 --> 00:10:39,660
through our super queue that we can lick

276
00:10:39,660 --> 00:10:41,880
that exactly and the same happens if you

277
00:10:41,880 --> 00:10:44,459
take the words around the the inverse

278
00:10:44,459 --> 00:10:47,399
route from an encrypted page in main

279
00:10:47,399 --> 00:10:49,560
memory in this case is P2 we bring it to

280
00:10:49,560 --> 00:10:51,720
the core we decrypt it and can put it

281
00:10:51,720 --> 00:10:53,940
back into the EPC page cache with the

282
00:10:53,940 --> 00:10:56,160
ldu instruction and this passes as well

283
00:10:56,160 --> 00:10:57,839
through the super queue so that we can

284
00:10:57,839 --> 00:11:00,779
Target it and leave it but okay that's

285
00:11:00,779 --> 00:11:03,060
not enough we I want a cool attack we

286
00:11:03,060 --> 00:11:05,100
can like only control like the whole

287
00:11:05,100 --> 00:11:07,740
pages here I want to process precisely

288
00:11:07,740 --> 00:11:09,600
Target like cache lines so that we can

289
00:11:09,600 --> 00:11:12,180
like for example select what we want to

290
00:11:12,180 --> 00:11:14,820
leak with this attack yeah that's a cool

291
00:11:14,820 --> 00:11:16,320
idea and we also have a solution for

292
00:11:16,320 --> 00:11:18,600
that it's called cache line freezing and

293
00:11:18,600 --> 00:11:20,220
as we mentioned in the beginning This

294
00:11:20,220 --> 00:11:21,600
Thread model is already strong enough to

295
00:11:21,600 --> 00:11:23,579
we can simply sample data from the super

296
00:11:23,579 --> 00:11:26,279
queue but we can also use the hyper

297
00:11:26,279 --> 00:11:28,079
thread we don't need it but if we use

298
00:11:28,079 --> 00:11:30,000
the hyper thread we can enhance the

299
00:11:30,000 --> 00:11:32,279
leakage even further why is that think

300
00:11:32,279 --> 00:11:34,079
about it the hyper thread and its

301
00:11:34,079 --> 00:11:36,480
sibling share the super queue oh that's

302
00:11:36,480 --> 00:11:38,339
cool so this means that like another

303
00:11:38,339 --> 00:11:40,920
thread can affect what is kept in the

304
00:11:40,920 --> 00:11:43,019
super queue with like just like using

305
00:11:43,019 --> 00:11:45,680
memory yes and we also use add Fury

306
00:11:45,680 --> 00:11:49,500
basically that 32 bytes of zeros are

307
00:11:49,500 --> 00:11:51,540
never actually transmitted over the

308
00:11:51,540 --> 00:11:54,060
serial queue okay this is cool how does

309
00:11:54,060 --> 00:11:56,160
it work yeah so let's take a look at

310
00:11:56,160 --> 00:11:59,279
that so in this animation we have on the

311
00:11:59,279 --> 00:12:01,680
top left we have two Frets fret one has

312
00:12:01,680 --> 00:12:04,320
an address where where it tries to

313
00:12:04,320 --> 00:12:06,300
access a secret value from the memory

314
00:12:06,300 --> 00:12:08,640
thread 2 also has an address as a

315
00:12:08,640 --> 00:12:10,440
different address but the page offset

316
00:12:10,440 --> 00:12:12,959
offset address is the same and if fret

317
00:12:12,959 --> 00:12:14,459
one now tries to read from that address

318
00:12:14,459 --> 00:12:16,260
the secret is loaded into the Super

319
00:12:16,260 --> 00:12:18,600
queue then forward it to the private

320
00:12:18,600 --> 00:12:20,700
caches and finally it ends up in the

321
00:12:20,700 --> 00:12:22,500
read that's cool so we have the secret

322
00:12:22,500 --> 00:12:23,880
in the super queue now so that we can

323
00:12:23,880 --> 00:12:25,500
lick it yes that's basically without

324
00:12:25,500 --> 00:12:27,000
using hyper threading okay but what

325
00:12:27,000 --> 00:12:29,040
happens now is fret 2 at the same time

326
00:12:29,040 --> 00:12:31,620
or after the first secret access was

327
00:12:31,620 --> 00:12:33,540
performed accesses the different address

328
00:12:33,540 --> 00:12:36,420
where the access are located so the X's

329
00:12:36,420 --> 00:12:38,640
are then replacing that super queue

330
00:12:38,640 --> 00:12:41,279
entry again drawing brought back to the

331
00:12:41,279 --> 00:12:43,200
L1 L2 caches and forward it to the

332
00:12:43,200 --> 00:12:45,240
different route wait don't now we don't

333
00:12:45,240 --> 00:12:46,800
have any more this Security in the super

334
00:12:46,800 --> 00:12:48,180
we just destroyed what we wanted to

335
00:12:48,180 --> 00:12:50,220
leave yes we overwrote our secret so if

336
00:12:50,220 --> 00:12:52,320
we now use epic we get back to access so

337
00:12:52,320 --> 00:12:54,360
we didn't gain much there however if we

338
00:12:54,360 --> 00:12:56,579
now take a look at the zero case and we

339
00:12:56,579 --> 00:12:58,620
perform the secret axis again in fret

340
00:12:58,620 --> 00:12:59,399
one

341
00:12:59,399 --> 00:13:01,320
the data travels over the simple queue

342
00:13:01,320 --> 00:13:03,300
into the private caches to the read and

343
00:13:03,300 --> 00:13:05,579
now thread 2 accesses that address where

344
00:13:05,579 --> 00:13:06,899
the series are located something

345
00:13:06,899 --> 00:13:08,279
different happens

346
00:13:08,279 --> 00:13:10,500
zeros are a few reasons that the zeros

347
00:13:10,500 --> 00:13:11,820
are marked differently in the super

348
00:13:11,820 --> 00:13:13,620
queue and are actually never transmitted

349
00:13:13,620 --> 00:13:15,660
so we just marked the super queue entry

350
00:13:15,660 --> 00:13:18,000
that it contains not all zeros this is

351
00:13:18,000 --> 00:13:19,560
then resolved and forwarded to the

352
00:13:19,560 --> 00:13:21,779
private caches and ends up in the final

353
00:13:21,779 --> 00:13:24,300
read so this is like an optimization to

354
00:13:24,300 --> 00:13:26,459
avoid passing zeros through this through

355
00:13:26,459 --> 00:13:28,200
a cashier we actually don't know but

356
00:13:28,200 --> 00:13:30,839
yeah that's interesting so if you take a

357
00:13:30,839 --> 00:13:32,880
look now we can see that we have Frozen

358
00:13:32,880 --> 00:13:35,339
The Secret inside the super queue entry

359
00:13:35,339 --> 00:13:37,320
and what we can now do is we can use

360
00:13:37,320 --> 00:13:39,959
epic the undefined bytes the undefined

361
00:13:39,959 --> 00:13:42,180
line bytes to read that secret out of

362
00:13:42,180 --> 00:13:44,160
the super queue entry okay this is cool

363
00:13:44,160 --> 00:13:47,399
and I guess this is epically yes so

364
00:13:47,399 --> 00:13:49,680
every click just combines all these

365
00:13:49,680 --> 00:13:51,899
techniques we can use Enclave checking

366
00:13:51,899 --> 00:13:54,480
to make pages of targets as Jacks

367
00:13:54,480 --> 00:13:56,279
enclaves pass through the super queue

368
00:13:56,279 --> 00:13:58,680
and then freezing those cache lines that

369
00:13:58,680 --> 00:14:00,360
we want to leak using cache line

370
00:14:00,360 --> 00:14:02,160
freezing so that we can precisely Target

371
00:14:02,160 --> 00:14:05,519
what we want to leak basically with epic

372
00:14:05,519 --> 00:14:08,279
click we can like leak three quarters of

373
00:14:08,279 --> 00:14:11,160
every single cache line that is in an

374
00:14:11,160 --> 00:14:14,459
even offset and we can like do this from

375
00:14:14,459 --> 00:14:16,920
any sjx Enclave page that we want to

376
00:14:16,920 --> 00:14:18,660
Target and one of the biggest and

377
00:14:18,660 --> 00:14:20,639
strongest Parts is that we can do that

378
00:14:20,639 --> 00:14:22,800
even without the Enclave running because

379
00:14:22,800 --> 00:14:25,680
the encrypted Pages exist still after an

380
00:14:25,680 --> 00:14:27,600
enclave is idling so we can attack an

381
00:14:27,600 --> 00:14:29,519
enclave even though the Enclave is not

382
00:14:29,519 --> 00:14:30,240
running

383
00:14:30,240 --> 00:14:32,100
okay this is cool but what can we do

384
00:14:32,100 --> 00:14:34,019
with this so This brings us to our two

385
00:14:34,019 --> 00:14:36,600
attack setups we have in the publication

386
00:14:36,600 --> 00:14:38,459
there and the first one is just

387
00:14:38,459 --> 00:14:40,620
targeting data and code so we've seen

388
00:14:40,620 --> 00:14:42,180
that we can leak data and code where

389
00:14:42,180 --> 00:14:43,500
you're reading the Epic registers and

390
00:14:43,500 --> 00:14:45,540
the idea is now quite simple we start an

391
00:14:45,540 --> 00:14:47,639
enclave and wait until the Enclave is

392
00:14:47,639 --> 00:14:50,040
filled with some secret data oh okay so

393
00:14:50,040 --> 00:14:52,079
then we just move the page that we want

394
00:14:52,079 --> 00:14:54,420
to Target out of the APC okay this is

395
00:14:54,420 --> 00:14:55,680
good and if you remember in the

396
00:14:55,680 --> 00:14:57,540
beginning where we talked about sjx

397
00:14:57,540 --> 00:15:00,240
there was this one special page and this

398
00:15:00,240 --> 00:15:02,220
page is the solution how we can leak

399
00:15:02,220 --> 00:15:04,860
register contents so the idea there is a

400
00:15:04,860 --> 00:15:06,000
little bit different so we started The

401
00:15:06,000 --> 00:15:08,339
Enclave again but then we wait to have

402
00:15:08,339 --> 00:15:10,320
specific instruction and force The

403
00:15:10,320 --> 00:15:12,660
Enclave to store the content of its

404
00:15:12,660 --> 00:15:15,060
registers onto that special page oh so

405
00:15:15,060 --> 00:15:17,399
it's the same then we move the SSA page

406
00:15:17,399 --> 00:15:19,620
out freeze the cache line that we want

407
00:15:19,620 --> 00:15:21,660
to leak and by selecting the cache line

408
00:15:21,660 --> 00:15:23,220
we can then select the register that we

409
00:15:23,220 --> 00:15:25,019
want to leak and then like dump the

410
00:15:25,019 --> 00:15:27,420
Epica dump this stuff that we want to

411
00:15:27,420 --> 00:15:30,180
leak and then move it back exactly and

412
00:15:30,180 --> 00:15:32,699
as you remember they are blind spots so

413
00:15:32,699 --> 00:15:35,279
there's actually a few spots where we

414
00:15:35,279 --> 00:15:37,500
can't leak data from and this also maps

415
00:15:37,500 --> 00:15:39,839
to registers where we can't leak from so

416
00:15:39,839 --> 00:15:41,579
we have some general purpose registers

417
00:15:41,579 --> 00:15:44,279
where we only leak partially content but

418
00:15:44,279 --> 00:15:46,440
also some registers we can't leak

419
00:15:46,440 --> 00:15:49,199
completely okay that's interesting

420
00:15:49,199 --> 00:15:51,899
what is happening

421
00:15:51,899 --> 00:15:54,120
you know what it is it's demo time oh

422
00:15:54,120 --> 00:15:55,800
that's cool when you're leaking these

423
00:15:55,800 --> 00:15:58,260
lights from an enclave yes

424
00:15:58,260 --> 00:16:01,880
so let's try this

425
00:16:06,720 --> 00:16:09,959
so I'm trying something risky here I'm

426
00:16:09,959 --> 00:16:12,360
connecting I'm SSH connected to a system

427
00:16:12,360 --> 00:16:15,360
in our home country and I have here a

428
00:16:15,360 --> 00:16:17,519
few things in that folder so we can see

429
00:16:17,519 --> 00:16:20,399
here that there's an AES Enclave so this

430
00:16:20,399 --> 00:16:22,980
a is an enclave uses the as9 instruction

431
00:16:22,980 --> 00:16:25,980
set to perform as encryptions

432
00:16:25,980 --> 00:16:28,079
that's interesting so asni is a special

433
00:16:28,079 --> 00:16:31,320
instruction set for like x86 CPUs where

434
00:16:31,320 --> 00:16:33,420
the as encryption and encryption steps

435
00:16:33,420 --> 00:16:35,519
are implemented in arduer and this is

436
00:16:35,519 --> 00:16:38,339
really like resistant to like all

437
00:16:38,339 --> 00:16:40,079
different attacks like side channels or

438
00:16:40,079 --> 00:16:43,920
like also like different yes and one and

439
00:16:43,920 --> 00:16:45,779
one specific instruction in the ASI

440
00:16:45,779 --> 00:16:48,180
instruction set is the ASN key Gan

441
00:16:48,180 --> 00:16:50,279
assist so this instruction is used in

442
00:16:50,279 --> 00:16:52,199
order to generate the round keys from

443
00:16:52,199 --> 00:16:53,940
the root key so if you now take a look

444
00:16:53,940 --> 00:16:55,920
at that enclave and simply disassemble

445
00:16:55,920 --> 00:16:57,660
it and search for the instruction which

446
00:16:57,660 --> 00:17:00,420
is called vas Tegan assist we will find

447
00:17:00,420 --> 00:17:02,880
it at some point insert the enclave and

448
00:17:02,880 --> 00:17:05,520
for our attack to work we now know that

449
00:17:05,520 --> 00:17:07,619
at this point inside the code execution

450
00:17:07,619 --> 00:17:10,859
of The Enclave in the richest xmm0 will

451
00:17:10,859 --> 00:17:13,740
be the key for that encryption so if we

452
00:17:13,740 --> 00:17:16,859
stop The Enclave at that moment then the

453
00:17:16,859 --> 00:17:21,179
SSA page at the offset where XS X xmm0

454
00:17:21,179 --> 00:17:23,579
register is stored it will contain the

455
00:17:23,579 --> 00:17:26,459
private key that we want to leak yes so

456
00:17:26,459 --> 00:17:28,559
in order to perform our Tech we need two

457
00:17:28,559 --> 00:17:30,720
components first we need to locate the

458
00:17:30,720 --> 00:17:32,580
page offset at which this instruction is

459
00:17:32,580 --> 00:17:34,740
located so in our case it's the page 20

460
00:17:34,740 --> 00:17:37,679
inside the enclave and we also need to

461
00:17:37,679 --> 00:17:40,200
know the at which instruction we have to

462
00:17:40,200 --> 00:17:42,600
stop so basically the how the end of

463
00:17:42,600 --> 00:17:44,460
instruction on the page I don't show you

464
00:17:44,460 --> 00:17:46,020
this it's the third infrastructure on

465
00:17:46,020 --> 00:17:47,760
the page because there's stuff in the

466
00:17:47,760 --> 00:17:50,100
beginning and now we simply

467
00:17:50,100 --> 00:17:52,440
simply edit a config so we should create

468
00:17:52,440 --> 00:17:54,960
a config file and we add there that we

469
00:17:54,960 --> 00:17:58,020
want to Target this 20th page in The sjx

470
00:17:58,020 --> 00:17:59,940
Enclave we want to Target the first unit

471
00:17:59,940 --> 00:18:02,280
of instruction inside the page and we

472
00:18:02,280 --> 00:18:05,160
want to leak xlm m0 so now we can like

473
00:18:05,160 --> 00:18:07,799
wrap the enclave and stop it precisely

474
00:18:07,799 --> 00:18:09,480
at the point where we want to leak the

475
00:18:09,480 --> 00:18:11,700
data

476
00:18:11,700 --> 00:18:13,799
so and if we now execute our attack

477
00:18:13,799 --> 00:18:14,880
program

478
00:18:14,880 --> 00:18:17,520
yes I want to pasteurope

479
00:18:17,520 --> 00:18:20,280
we can see that we directly recovered

480
00:18:20,280 --> 00:18:22,620
the as an I key of that encryption and

481
00:18:22,620 --> 00:18:25,380
you'll see how fast was that this is

482
00:18:25,380 --> 00:18:26,940
like showing that this is not like a

483
00:18:26,940 --> 00:18:28,440
Transit execution attack where you have

484
00:18:28,440 --> 00:18:30,419
to employ site Channel and lick the

485
00:18:30,419 --> 00:18:32,820
stuff that is like noisy and slow this

486
00:18:32,820 --> 00:18:35,100
is architectural leak so you dump it and

487
00:18:35,100 --> 00:18:37,440
that's it and if you know take a look at

488
00:18:37,440 --> 00:18:39,539
if you dump the key out of the actual

489
00:18:39,539 --> 00:18:41,460
source code of The Enclave we can see

490
00:18:41,460 --> 00:18:44,280
that the key parts from the byte 4 to 15

491
00:18:44,280 --> 00:18:46,679
actually match the as Nike used in this

492
00:18:46,679 --> 00:18:48,539
example and you might be wondering now

493
00:18:48,539 --> 00:18:51,419
so we can see that the xmm0 register has

494
00:18:51,419 --> 00:18:53,640
this blind spot however if you think

495
00:18:53,640 --> 00:18:56,400
about it this is just one position in

496
00:18:56,400 --> 00:18:58,080
the code where we leaked already three

497
00:18:58,080 --> 00:19:00,360
quarters of the secret key the key

498
00:19:00,360 --> 00:19:02,880
travels through a lot more code in order

499
00:19:02,880 --> 00:19:05,100
to be at that position so we can combine

500
00:19:05,100 --> 00:19:06,840
multiple leakage sources in order to

501
00:19:06,840 --> 00:19:08,760
recover the remaining four parts as we

502
00:19:08,760 --> 00:19:11,960
did in the publication of someone

503
00:19:15,660 --> 00:19:17,880
so that brings us back to the

504
00:19:17,880 --> 00:19:19,919
presentation and I can skip the backup

505
00:19:19,919 --> 00:19:22,080
videos so I'm amazed it worked for the

506
00:19:22,080 --> 00:19:25,260
first time yes I'm also missed so let's

507
00:19:25,260 --> 00:19:27,059
talk about mitigations so we have seen

508
00:19:27,059 --> 00:19:29,640
that we can precisely Target and leak

509
00:19:29,640 --> 00:19:31,020
um secret information stored in

510
00:19:31,020 --> 00:19:33,360
registers we can dump Enclave pages but

511
00:19:33,360 --> 00:19:35,460
how can we protect against it yes this

512
00:19:35,460 --> 00:19:37,799
is a really powerful attack that needs

513
00:19:37,799 --> 00:19:39,660
to be mitigated and Intel release

514
00:19:39,660 --> 00:19:42,000
mitigations for that obviously and okay

515
00:19:42,000 --> 00:19:44,460
the first thing is to recommend to

516
00:19:44,460 --> 00:19:47,280
disable the Epic mmio region

517
00:19:47,280 --> 00:19:49,320
this is like closing literally the

518
00:19:49,320 --> 00:19:51,600
attack surface for that if we like look

519
00:19:51,600 --> 00:19:53,700
at it in like with respect to like

520
00:19:53,700 --> 00:19:55,500
another advisor that may map the Epic

521
00:19:55,500 --> 00:19:57,960
mmao region but obviously this is not

522
00:19:57,960 --> 00:20:00,360
enough so in in practice this mitigation

523
00:20:00,360 --> 00:20:03,360
will enable X2 apic that's like a newer

524
00:20:03,360 --> 00:20:05,400
version for epic and this is also faster

525
00:20:05,400 --> 00:20:08,340
so it's like highly recommended but this

526
00:20:08,340 --> 00:20:10,440
is not enough for like sgx enclaves

527
00:20:10,440 --> 00:20:12,179
where like a malicious operating system

528
00:20:12,179 --> 00:20:15,360
can just like not disable epic Mio and

529
00:20:15,360 --> 00:20:17,340
just like bypass this mitigation so

530
00:20:17,340 --> 00:20:19,559
Intel also released micro code patches

531
00:20:19,559 --> 00:20:22,380
and this patches Flash the super Q on

532
00:20:22,380 --> 00:20:25,200
like all the sgx transitions so that you

533
00:20:25,200 --> 00:20:27,539
can if you like try to move the page in

534
00:20:27,539 --> 00:20:29,520
and out then you will not have the data

535
00:20:29,520 --> 00:20:31,260
in the super queue that you want to leak

536
00:20:31,260 --> 00:20:33,720
yeah and as always one one suggested

537
00:20:33,720 --> 00:20:36,059
mitigation of the general rule of thumb

538
00:20:36,059 --> 00:20:38,100
basically is if you use HX you should

539
00:20:38,100 --> 00:20:40,380
also disable hyper threading why because

540
00:20:40,380 --> 00:20:42,299
if you know consider these super Q

541
00:20:42,299 --> 00:20:44,100
flashes and they only flush during

542
00:20:44,100 --> 00:20:46,559
entering exit of this HDX Enclave the

543
00:20:46,559 --> 00:20:48,780
hyper thread can still be running in

544
00:20:48,780 --> 00:20:50,520
between those Transitions and leaked

545
00:20:50,520 --> 00:20:53,160
data over the super queue yes exactly so

546
00:20:53,160 --> 00:20:54,780
for who is interested this is the

547
00:20:54,780 --> 00:20:56,160
timeline we discovered this attack in

548
00:20:56,160 --> 00:20:58,380
December and like it was embargoed until

549
00:20:58,380 --> 00:21:01,620
yesterday when it went public

550
00:21:01,620 --> 00:21:04,260
so that brings us to the conclusion so

551
00:21:04,260 --> 00:21:06,480
we have seen that by reading unaligned

552
00:21:06,480 --> 00:21:08,880
memory from the Epic we can actually

553
00:21:08,880 --> 00:21:11,100
leak data and code we have seen some

554
00:21:11,100 --> 00:21:12,480
techniques so we can extend those

555
00:21:12,480 --> 00:21:15,000
leakage to precisely Target cache lines

556
00:21:15,000 --> 00:21:17,340
inside an enclave to jump registers and

557
00:21:17,340 --> 00:21:19,500
even data pages so overall we say that

558
00:21:19,500 --> 00:21:21,000
epic league is the first architecture

559
00:21:21,000 --> 00:21:23,039
leak that is capable of leaking stale

560
00:21:23,039 --> 00:21:24,960
data from the super queue it does not

561
00:21:24,960 --> 00:21:26,880
require rapid trading even if we can

562
00:21:26,880 --> 00:21:28,559
exploit other trading to improve our

563
00:21:28,559 --> 00:21:31,140
attack and it affects like most recent

564
00:21:31,140 --> 00:21:33,059
Intel CPUs if you want to learn more

565
00:21:33,059 --> 00:21:34,320
about the attack you can go to

566
00:21:34,320 --> 00:21:36,900
epicly.com or even read our paper that

567
00:21:36,900 --> 00:21:39,299
will be published using in two days

568
00:21:39,299 --> 00:21:42,700
yes so thank you for your attention

569
00:21:42,700 --> 00:21:45,809
[Music]

570
00:21:49,660 --> 00:21:52,759
[Music]

