1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:10,460 --> 00:00:13,860
I'm a social professor in the school of

4
00:00:13,860 --> 00:00:16,680
computing and information systems SMU in

5
00:00:16,680 --> 00:00:19,560
here in Singapore not the one in Texas

6
00:00:19,560 --> 00:00:22,800
so it's my pleasure to come here and get

7
00:00:22,800 --> 00:00:24,960
this opportunity to share with you with

8
00:00:24,960 --> 00:00:28,640
our research work about a new Dynamic

9
00:00:28,640 --> 00:00:31,679
software analysis framework

10
00:00:31,679 --> 00:00:34,680
uh this is a framework that allows you

11
00:00:34,680 --> 00:00:38,160
to develop your program and to

12
00:00:38,160 --> 00:00:40,440
dynamically analyze a kernel even

13
00:00:40,440 --> 00:00:43,680
dynamically analyze a malware

14
00:00:43,680 --> 00:00:46,320
uh so strictly speaking this is not a

15
00:00:46,320 --> 00:00:48,420
new framework in a sense that we

16
00:00:48,420 --> 00:00:52,260
actually uh have published this paper

17
00:00:52,260 --> 00:00:54,960
um in Auckland last year but the reason

18
00:00:54,960 --> 00:00:57,420
we came we come to the black hat

19
00:00:57,420 --> 00:00:59,879
conference to uh to share with you this

20
00:00:59,879 --> 00:01:01,920
work is mainly because we want to reach

21
00:01:01,920 --> 00:01:04,140
out to much broader audience

22
00:01:04,140 --> 00:01:08,460
and we do have the belief that uh this

23
00:01:08,460 --> 00:01:11,760
this framework called Oasis indeed can

24
00:01:11,760 --> 00:01:13,979
help many users in this community to

25
00:01:13,979 --> 00:01:16,740
address many uh Dynamic analysis

26
00:01:16,740 --> 00:01:18,600
challenges so later on you can see what

27
00:01:18,600 --> 00:01:20,880
are the features our technique can can

28
00:01:20,880 --> 00:01:23,159
bring to you

29
00:01:23,159 --> 00:01:26,159
okay so here's my online and I will

30
00:01:26,159 --> 00:01:28,759
first do a quicker review of existing

31
00:01:28,759 --> 00:01:31,220
approaches for kernel analysis

32
00:01:31,220 --> 00:01:34,320
dynamically and then I will introduce

33
00:01:34,320 --> 00:01:37,860
our work called Oasis which is a this is

34
00:01:37,860 --> 00:01:39,780
called the on-site yeah analysis

35
00:01:39,780 --> 00:01:42,780
infrastructure I will explain to you the

36
00:01:42,780 --> 00:01:45,780
analysis Primitives provided by all this

37
00:01:45,780 --> 00:01:49,380
to developers here developers otherwise

38
00:01:49,380 --> 00:01:51,960
that developing analysis tools

39
00:01:51,960 --> 00:01:54,659
I will also show you two examples uh

40
00:01:54,659 --> 00:01:57,420
with some of the screen recording of our

41
00:01:57,420 --> 00:02:00,119
demo then in the end I'll just wrap up

42
00:02:00,119 --> 00:02:02,220
with with summary

43
00:02:02,220 --> 00:02:04,500
so since we already published paper the

44
00:02:04,500 --> 00:02:07,860
paper elaborate a lot about the internal

45
00:02:07,860 --> 00:02:11,340
details of how OSS works so here in this

46
00:02:11,340 --> 00:02:14,819
talk I will only focus on how a user

47
00:02:14,819 --> 00:02:18,060
uses osis of course I will explain some

48
00:02:18,060 --> 00:02:20,220
high level picture the the basic idea

49
00:02:20,220 --> 00:02:23,160
behind but I'm not going to delve into a

50
00:02:23,160 --> 00:02:26,520
complex low level issues of the internal

51
00:02:26,520 --> 00:02:28,980
working OSIS

52
00:02:28,980 --> 00:02:30,900
all right so

53
00:02:30,900 --> 00:02:32,580
just a quick review

54
00:02:32,580 --> 00:02:34,560
um if you want to do kernel Dynamic

55
00:02:34,560 --> 00:02:36,360
analysis basically there are two

56
00:02:36,360 --> 00:02:38,940
approaches the most common one is

57
00:02:38,940 --> 00:02:41,640
a code instrumentation you want to get

58
00:02:41,640 --> 00:02:43,739
some drop down with your kernel you add

59
00:02:43,739 --> 00:02:46,680
in your code uh to the kernel and you

60
00:02:46,680 --> 00:02:48,599
you may need to compile it if you do it

61
00:02:48,599 --> 00:02:50,519
statically so there are two approaches

62
00:02:50,519 --> 00:02:52,860
for you to do instrumentation

63
00:02:52,860 --> 00:02:55,920
a static gain implementation or dynamic

64
00:02:55,920 --> 00:02:58,800
Institute dynamical instrumentation no

65
00:02:58,800 --> 00:03:01,800
matter what in the end what you get is

66
00:03:01,800 --> 00:03:04,920
the kernel whose code has been mixed

67
00:03:04,920 --> 00:03:06,900
with your analysis code

68
00:03:06,900 --> 00:03:09,780
so your code and the kernel code will

69
00:03:09,780 --> 00:03:12,239
become one body one binary they will

70
00:03:12,239 --> 00:03:14,879
share the execution flow and share the

71
00:03:14,879 --> 00:03:16,200
address space

72
00:03:16,200 --> 00:03:18,659
then this is very wonderful because your

73
00:03:18,659 --> 00:03:21,360
code can easily get the job done your

74
00:03:21,360 --> 00:03:23,879
code help will have this native access

75
00:03:23,879 --> 00:03:27,720
to the kernel objects the current memory

76
00:03:27,720 --> 00:03:30,840
the same time because your code is in

77
00:03:30,840 --> 00:03:34,080
assembly with with the kernel then there

78
00:03:34,080 --> 00:03:37,379
are implications one application is

79
00:03:37,379 --> 00:03:39,840
now this is intrusive you have to modify

80
00:03:39,840 --> 00:03:41,580
the kernel well not to mention those

81
00:03:41,580 --> 00:03:44,640
hassles for the compilation uh modifying

82
00:03:44,640 --> 00:03:46,379
color sometimes doesn't work in

83
00:03:46,379 --> 00:03:49,799
scenarios such as you get a production

84
00:03:49,799 --> 00:03:51,659
kernel running with in the virtual

85
00:03:51,659 --> 00:03:53,519
machine they don't get the chance to do

86
00:03:53,519 --> 00:03:55,080
the pre-processing

87
00:03:55,080 --> 00:03:56,700
they are from the security perspective

88
00:03:56,700 --> 00:03:59,519
if you have if if you interest if you

89
00:03:59,519 --> 00:04:02,159
make this modification then your kernel

90
00:04:02,159 --> 00:04:07,860
your code can can be compromised or or

91
00:04:07,860 --> 00:04:12,120
detected or Modified by the malware in

92
00:04:12,120 --> 00:04:14,459
the kernel so suppose the kernel itself

93
00:04:14,459 --> 00:04:17,040
has been compromised the adversary can

94
00:04:17,040 --> 00:04:20,100
easily modify your code and change your

95
00:04:20,100 --> 00:04:23,400
analysis outcome so this is the bad

96
00:04:23,400 --> 00:04:25,259
so that's why we get the second approach

97
00:04:25,259 --> 00:04:28,080
which is more from the Academia

98
00:04:28,080 --> 00:04:30,720
in Academia when they look at this

99
00:04:30,720 --> 00:04:32,639
problem they say hey let's don't do

100
00:04:32,639 --> 00:04:35,940
instrumentation so let's use some

101
00:04:35,940 --> 00:04:38,880
Hardware features to trap the current

102
00:04:38,880 --> 00:04:41,759
execution into a more privileged

103
00:04:41,759 --> 00:04:43,040
environment

104
00:04:43,040 --> 00:04:45,300
that dependently on the combination

105
00:04:45,300 --> 00:04:47,220
let's say you can use virtualization you

106
00:04:47,220 --> 00:04:49,199
can trap the current execution into the

107
00:04:49,199 --> 00:04:52,259
hypervisor or you can you may use the

108
00:04:52,259 --> 00:04:54,780
pmu to trap the current execution into

109
00:04:54,780 --> 00:04:56,820
the SNM

110
00:04:56,820 --> 00:04:59,699
so the advantage here is okay you solve

111
00:04:59,699 --> 00:05:01,440
this um transparency and security

112
00:05:01,440 --> 00:05:04,740
problem because your analyzer your code

113
00:05:04,740 --> 00:05:07,560
stays outside of the kernel is in a more

114
00:05:07,560 --> 00:05:09,900
privileged environment so kernel cannot

115
00:05:09,900 --> 00:05:11,639
read or cannot tamper with your

116
00:05:11,639 --> 00:05:12,720
execution

117
00:05:12,720 --> 00:05:16,080
nonetheless there are drawbacks

118
00:05:16,080 --> 00:05:19,620
since your analyzer is outside then you

119
00:05:19,620 --> 00:05:22,259
lose the lose this flexibility and

120
00:05:22,259 --> 00:05:25,440
Native Access Control to the kernel

121
00:05:25,440 --> 00:05:29,039
um there are several issues one is

122
00:05:29,039 --> 00:05:31,500
when and where to trigger this event

123
00:05:31,500 --> 00:05:34,500
this is entirely at the mercy of the

124
00:05:34,500 --> 00:05:36,660
hardware you don't have the entire

125
00:05:36,660 --> 00:05:37,740
control

126
00:05:37,740 --> 00:05:40,139
secondly when you do introspection when

127
00:05:40,139 --> 00:05:42,600
you read the current memory you are

128
00:05:42,600 --> 00:05:44,699
reading the Kernel's physical memory

129
00:05:44,699 --> 00:05:47,340
you're not reading the Kernel's virtual

130
00:05:47,340 --> 00:05:49,919
memory so this is something like you

131
00:05:49,919 --> 00:05:52,740
walk in the dark in a dark room you want

132
00:05:52,740 --> 00:05:55,380
to find out the where is the door so you

133
00:05:55,380 --> 00:05:57,360
have to Fumble with your fingers to find

134
00:05:57,360 --> 00:06:00,360
out instead of you can see it clearly

135
00:06:00,360 --> 00:06:02,400
uh lastly

136
00:06:02,400 --> 00:06:05,900
um programming in this um uh special

137
00:06:05,900 --> 00:06:08,639
environment is tough

138
00:06:08,639 --> 00:06:11,039
let's say imagine you write in Universe

139
00:06:11,039 --> 00:06:12,060
your

140
00:06:12,060 --> 00:06:14,820
um analyzer in this smm it's a very

141
00:06:14,820 --> 00:06:16,380
difficult job

142
00:06:16,380 --> 00:06:17,639
um not you don't have the library

143
00:06:17,639 --> 00:06:19,199
support you don't have always support

144
00:06:19,199 --> 00:06:24,539
everything you have it's just a row CPU

145
00:06:24,539 --> 00:06:27,780
so so we are asking this a big question

146
00:06:27,780 --> 00:06:31,680
can we combine these two approaches to

147
00:06:31,680 --> 00:06:34,080
get the best out of them but we don't

148
00:06:34,080 --> 00:06:37,620
want we don't want their drawbacks

149
00:06:37,620 --> 00:06:39,960
meaning we want to get the transparent

150
00:06:39,960 --> 00:06:42,780
and secure access analysis however we

151
00:06:42,780 --> 00:06:46,259
want our analyzer our tools

152
00:06:46,259 --> 00:06:49,380
um can have native access to the kernel

153
00:06:49,380 --> 00:06:52,919
can do introspection can do modification

154
00:06:52,919 --> 00:06:54,840
now how can we do that

155
00:06:54,840 --> 00:06:57,780
so we came up with the idea of why not

156
00:06:57,780 --> 00:07:01,280
we interleave the target

157
00:07:01,280 --> 00:07:05,460
instruction stream with the analyzers uh

158
00:07:05,460 --> 00:07:08,400
instruction scheme but without mix code

159
00:07:08,400 --> 00:07:09,840
together

160
00:07:09,840 --> 00:07:13,020
so imagine this you have a CPU this CPU

161
00:07:13,020 --> 00:07:15,960
will continuously fetch instructions but

162
00:07:15,960 --> 00:07:18,240
sometimes fetch the instructions from a

163
00:07:18,240 --> 00:07:20,400
kernel sometimes it affects the

164
00:07:20,400 --> 00:07:23,280
instructions from the analyzer so the

165
00:07:23,280 --> 00:07:25,319
analyze code and a kernel code are

166
00:07:25,319 --> 00:07:27,660
physically separated

167
00:07:27,660 --> 00:07:30,120
but the execution are kind of mingled

168
00:07:30,120 --> 00:07:31,680
together

169
00:07:31,680 --> 00:07:34,979
so we call this execution flow

170
00:07:34,979 --> 00:07:38,400
instrumentation EFI to mimic the sense

171
00:07:38,400 --> 00:07:40,919
of code instrumentation so we mix

172
00:07:40,919 --> 00:07:43,560
execution together but we don't miss mix

173
00:07:43,560 --> 00:07:46,039
the code together

174
00:07:46,039 --> 00:07:50,940
so and we call such analysis as on-site

175
00:07:50,940 --> 00:07:53,940
analysis so the analyzer analyzes

176
00:07:53,940 --> 00:07:57,539
attacked program that kernel as if it

177
00:07:57,539 --> 00:07:59,340
were one part of it

178
00:07:59,340 --> 00:08:02,160
the reason we we limit of the onsite

179
00:08:02,160 --> 00:08:04,680
analysis because this is try to give you

180
00:08:04,680 --> 00:08:06,360
this inclusion that it's not something

181
00:08:06,360 --> 00:08:10,080
like you are doing a outside interview

182
00:08:10,080 --> 00:08:12,120
so you go there you go to the the the

183
00:08:12,120 --> 00:08:15,479
the this company's building you meet the

184
00:08:15,479 --> 00:08:17,639
people there of course you get the first

185
00:08:17,639 --> 00:08:20,819
hand information from about this company

186
00:08:20,819 --> 00:08:24,000
nonetheless you are remain you remain as

187
00:08:24,000 --> 00:08:25,560
outsider

188
00:08:25,560 --> 00:08:28,199
so with also analysis we're hoping that

189
00:08:28,199 --> 00:08:30,840
the our analyzer can have this security

190
00:08:30,840 --> 00:08:34,260
transparency and Native control then to

191
00:08:34,260 --> 00:08:37,260
to do so we need to satisfy a few

192
00:08:37,260 --> 00:08:39,000
requirements

193
00:08:39,000 --> 00:08:41,820
number one you want this analyzer to

194
00:08:41,820 --> 00:08:44,279
dynamically

195
00:08:44,279 --> 00:08:48,080
to dynamically choose the site of

196
00:08:48,080 --> 00:08:51,120
instruction flow into living so we

197
00:08:51,120 --> 00:08:53,160
cannot leave this to Hardware to decide

198
00:08:53,160 --> 00:08:56,040
we need to have another analyzer to take

199
00:08:56,040 --> 00:08:57,480
the full control

200
00:08:57,480 --> 00:09:00,959
so the analyzer can can decide at any

201
00:09:00,959 --> 00:09:03,000
point of the program execution and the

202
00:09:03,000 --> 00:09:05,399
current execution then you can do this

203
00:09:05,399 --> 00:09:07,860
interleaving of instructions

204
00:09:07,860 --> 00:09:11,580
secondly we don't want a CPU mode or CPU

205
00:09:11,580 --> 00:09:13,260
probability switch

206
00:09:13,260 --> 00:09:15,899
if the touch thread runs in the kernel

207
00:09:15,899 --> 00:09:18,839
in a ring 0 and our analyzer will also

208
00:09:18,839 --> 00:09:22,620
run in run in ring zero if the target

209
00:09:22,620 --> 00:09:25,260
program Capital three runs in ring 3

210
00:09:25,260 --> 00:09:28,560
they are our analyzer can also run ring

211
00:09:28,560 --> 00:09:31,860
3. so the main reason behind is this are

212
00:09:31,860 --> 00:09:34,680
not the analyzer to natively share the

213
00:09:34,680 --> 00:09:37,500
CPU context with the cardo so they are

214
00:09:37,500 --> 00:09:41,640
they have the same Computing environment

215
00:09:41,640 --> 00:09:44,160
lastly this is the most important one

216
00:09:44,160 --> 00:09:46,860
see we want to have this one-way address

217
00:09:46,860 --> 00:09:48,600
space isolation

218
00:09:48,600 --> 00:09:51,380
meaning that the target address space

219
00:09:51,380 --> 00:09:54,360
can be accessible it can be accessed by

220
00:09:54,360 --> 00:09:57,000
the analyzer so from the internet's

221
00:09:57,000 --> 00:09:59,820
perspective we can natively access the

222
00:09:59,820 --> 00:10:01,860
entire kernel space

223
00:10:01,860 --> 00:10:04,440
however not the vice versa the kernel

224
00:10:04,440 --> 00:10:07,800
cannot access the analyzer so this is

225
00:10:07,800 --> 00:10:10,620
something like a one-way mirror in the

226
00:10:10,620 --> 00:10:13,320
the police station's interrogation room

227
00:10:13,320 --> 00:10:15,899
so the police officers can can see

228
00:10:15,899 --> 00:10:18,180
everything inside the room but the

229
00:10:18,180 --> 00:10:21,000
suspect cannot see things outside of

230
00:10:21,000 --> 00:10:23,640
course the suspect can make a guess

231
00:10:23,640 --> 00:10:27,779
but he or she doesn't see anything

232
00:10:27,779 --> 00:10:29,940
so if we can solve these issues they'll

233
00:10:29,940 --> 00:10:32,899
get a secure and transparent analysis

234
00:10:32,899 --> 00:10:36,660
and we can also have native access and

235
00:10:36,660 --> 00:10:38,220
another can read everything in the

236
00:10:38,220 --> 00:10:40,860
Kernel's virtual memory and they will

237
00:10:40,860 --> 00:10:44,339
get allow the cross space on analysis

238
00:10:44,339 --> 00:10:47,399
because this is the the whole address

239
00:10:47,399 --> 00:10:51,899
space will be shared with the analyzer

240
00:10:51,899 --> 00:10:54,540
then how can we do that

241
00:10:54,540 --> 00:10:57,540
so we design uh this infrastructure

242
00:10:57,540 --> 00:11:00,680
called the osis that stands for

243
00:11:00,680 --> 00:11:04,200
on-site analysis infrastructure

244
00:11:04,200 --> 00:11:07,200
so in this infrastructure we consider

245
00:11:07,200 --> 00:11:10,560
the target is one thread one thread okay

246
00:11:10,560 --> 00:11:12,660
not the one not the program one thread

247
00:11:12,660 --> 00:11:15,480
running in the case the VM

248
00:11:15,480 --> 00:11:18,779
the analyzer is a normal application

249
00:11:18,779 --> 00:11:22,440
running only host the Linux

250
00:11:22,440 --> 00:11:25,680
so so this technique is many uh it's for

251
00:11:25,680 --> 00:11:28,980
Linux only but the the target can be any

252
00:11:28,980 --> 00:11:32,220
operating system in the windows

253
00:11:32,220 --> 00:11:32,940
um

254
00:11:32,940 --> 00:11:36,360
so when around most most of the osc's

255
00:11:36,360 --> 00:11:39,959
job is done with in the host kernel

256
00:11:39,959 --> 00:11:43,620
and we this Oasis will create the

257
00:11:43,620 --> 00:11:46,920
on-site environment as I show here

258
00:11:46,920 --> 00:11:49,680
in this on-site environment

259
00:11:49,680 --> 00:11:52,019
um this is also environment has a

260
00:11:52,019 --> 00:11:53,760
dedicated CPU core

261
00:11:53,760 --> 00:11:55,260
so this environment doesn't have

262
00:11:55,260 --> 00:11:57,600
operating system and the only two

263
00:11:57,600 --> 00:12:00,180
threads running on the CPU one is

264
00:12:00,180 --> 00:12:02,820
analyzer the other is Target so their

265
00:12:02,820 --> 00:12:04,920
instructions will be interleaved

266
00:12:04,920 --> 00:12:06,180
together

267
00:12:06,180 --> 00:12:10,440
and this outside environment also has a

268
00:12:10,440 --> 00:12:13,620
special paging hierarchy we will give a

269
00:12:13,620 --> 00:12:17,519
special pml4 page for the mmu to do

270
00:12:17,519 --> 00:12:20,220
translation but the outside environment

271
00:12:20,220 --> 00:12:24,839
does not have any dedicated memory pages

272
00:12:24,839 --> 00:12:27,000
all the data all the code of the

273
00:12:27,000 --> 00:12:30,480
analyzer is managed by the host OS the

274
00:12:30,480 --> 00:12:34,380
target runs in the uh against the VM

275
00:12:34,380 --> 00:12:36,720
so we think in this onsite environment

276
00:12:36,720 --> 00:12:42,420
uh working around on-site analysis

277
00:12:42,420 --> 00:12:44,940
so let's see a high picture of a high

278
00:12:44,940 --> 00:12:46,980
picture of a higher picture of this

279
00:12:46,980 --> 00:12:49,800
workflow of on-site and Analysis so you

280
00:12:49,800 --> 00:12:52,260
get two environments one is the onsite

281
00:12:52,260 --> 00:12:54,360
environment you get a dedicated on-site

282
00:12:54,360 --> 00:12:58,980
core and we also can we also grab one

283
00:12:58,980 --> 00:13:03,120
core from the guest VM so we export the

284
00:13:03,120 --> 00:13:04,260
target

285
00:13:04,260 --> 00:13:07,200
threat to the on-site environment there

286
00:13:07,200 --> 00:13:09,839
we conduct this on-site analysis

287
00:13:09,839 --> 00:13:12,540
in within the sponsored environment

288
00:13:12,540 --> 00:13:14,880
uh once the job is done then the

289
00:13:14,880 --> 00:13:17,579
analyzer can release release the target

290
00:13:17,579 --> 00:13:20,579
the target can continue to execute uh in

291
00:13:20,579 --> 00:13:22,139
the guest VM

292
00:13:22,139 --> 00:13:24,360
then you can repeat this cycle

293
00:13:24,360 --> 00:13:26,940
you can periodically or randomly pick

294
00:13:26,940 --> 00:13:29,100
one thread to analysis

295
00:13:29,100 --> 00:13:31,019
after a while can release it let's

296
00:13:31,019 --> 00:13:33,660
around in the in the guest VM if needed

297
00:13:33,660 --> 00:13:35,399
you can catch it again or catch another

298
00:13:35,399 --> 00:13:38,160
thread to analysis

299
00:13:38,160 --> 00:13:41,220
they're within the sponsor analysis is

300
00:13:41,220 --> 00:13:44,700
basically uh it is composed of this

301
00:13:44,700 --> 00:13:47,600
cycle of execution between analyzer to

302
00:13:47,600 --> 00:13:50,160
analyzer to to the Target

303
00:13:50,160 --> 00:13:53,399
so we just turn exit and entry exit

304
00:13:53,399 --> 00:13:55,440
refers to the control flow will pass

305
00:13:55,440 --> 00:13:58,079
from the target to the analyzer the

306
00:13:58,079 --> 00:14:00,899
entry means from analyzer to the to the

307
00:14:00,899 --> 00:14:02,040
Target

308
00:14:02,040 --> 00:14:04,980
so this is how the if you if you run

309
00:14:04,980 --> 00:14:08,700
your analyzer on top of Oasis this is uh

310
00:14:08,700 --> 00:14:12,500
the the flow

311
00:14:12,600 --> 00:14:16,980
so let me explain to you what are the uh

312
00:14:16,980 --> 00:14:19,620
Primitives that allow you to develop

313
00:14:19,620 --> 00:14:22,440
your program your analyzer

314
00:14:22,440 --> 00:14:25,740
so the number one primitive is actually

315
00:14:25,740 --> 00:14:29,940
doesn't require spatial apis from Oasis

316
00:14:29,940 --> 00:14:33,420
uh always just allow you to natively

317
00:14:33,420 --> 00:14:37,019
access kernel memory meaning uh given

318
00:14:37,019 --> 00:14:39,720
any kernel address kernels current

319
00:14:39,720 --> 00:14:42,660
virtual address you can easily use it as

320
00:14:42,660 --> 00:14:46,440
if it is in your code that is in your uh

321
00:14:46,440 --> 00:14:48,959
in your in your programs then you can

322
00:14:48,959 --> 00:14:51,060
let's say you can use the economy here

323
00:14:51,060 --> 00:14:54,540
they can do direct memory copy all the

324
00:14:54,540 --> 00:14:56,779
standard liposite libraries can be used

325
00:14:56,779 --> 00:14:59,760
without additional treatment because

326
00:14:59,760 --> 00:15:01,800
this is part of the of the of the

327
00:15:01,800 --> 00:15:04,380
analyzer you get the memory copy you can

328
00:15:04,380 --> 00:15:06,720
read the memory it can copy the memory

329
00:15:06,720 --> 00:15:09,300
and you can also to print that you can

330
00:15:09,300 --> 00:15:12,000
also use networks you can also use file

331
00:15:12,000 --> 00:15:15,079
because the analyzer is a normal

332
00:15:15,079 --> 00:15:18,240
userspace application running in the

333
00:15:18,240 --> 00:15:20,420
host

334
00:15:20,699 --> 00:15:24,000
so let's see uh one one demo here is the

335
00:15:24,000 --> 00:15:25,920
video recording so we have the analyzer

336
00:15:25,920 --> 00:15:28,440
on the left side of the screen the two

337
00:15:28,440 --> 00:15:31,019
windows the one belong to the Caster VM

338
00:15:31,019 --> 00:15:33,420
the top one is against the vm's kernel

339
00:15:33,420 --> 00:15:37,199
output the the one the bottom is the

340
00:15:37,199 --> 00:15:38,459
target

341
00:15:38,459 --> 00:15:41,519
okay so let's play it and we play it

342
00:15:41,519 --> 00:15:43,880
okay

343
00:15:44,940 --> 00:15:47,820
so here in order for the purpose of demo

344
00:15:47,820 --> 00:15:51,959
there we we are we made some changes on

345
00:15:51,959 --> 00:15:54,000
the guest kind of in order to print out

346
00:15:54,000 --> 00:15:55,500
something

347
00:15:55,500 --> 00:15:58,139
so here they are the kernels we our

348
00:15:58,139 --> 00:16:00,060
current module will print out some of

349
00:16:00,060 --> 00:16:03,420
the key ring on content binaries

350
00:16:03,420 --> 00:16:06,060
there we run the target

351
00:16:06,060 --> 00:16:09,720
now we uh export type the thread to the

352
00:16:09,720 --> 00:16:12,360
analyzer then analyzer will print out

353
00:16:12,360 --> 00:16:14,220
the kernel memory easily

354
00:16:14,220 --> 00:16:16,639
uh here

355
00:16:16,639 --> 00:16:20,940
here the the analyzer is given uh the

356
00:16:20,940 --> 00:16:22,440
local variable of the current address

357
00:16:22,440 --> 00:16:25,079
then just do the dereference find out

358
00:16:25,079 --> 00:16:28,860
the the virtual address of this uh query

359
00:16:28,860 --> 00:16:32,940
then just print out the binaries then in

360
00:16:32,940 --> 00:16:36,180
this object there's one pointer pointing

361
00:16:36,180 --> 00:16:39,839
to uh another object called a key user

362
00:16:39,839 --> 00:16:42,660
then this analyzer was just printed out

363
00:16:42,660 --> 00:16:46,199
this uh this uh key user object so these

364
00:16:46,199 --> 00:16:50,040
two binaries are identical

365
00:16:50,040 --> 00:16:52,620
so the good thing here is you can easily

366
00:16:52,620 --> 00:16:57,360
use any standard libraries to process

367
00:16:57,360 --> 00:16:59,820
the kernel memory and always is

368
00:16:59,820 --> 00:17:02,100
guarantees that whatever you see from

369
00:17:02,100 --> 00:17:03,959
the current virtual machine or from the

370
00:17:03,959 --> 00:17:06,480
Kernel's working memory is exactly the

371
00:17:06,480 --> 00:17:10,020
same from the kernel currently runs so

372
00:17:10,020 --> 00:17:14,240
there's there's a consistent memory View

373
00:17:14,459 --> 00:17:17,699
okay then with this one you can you can

374
00:17:17,699 --> 00:17:19,619
of course you can uh

375
00:17:19,619 --> 00:17:21,480
think

376
00:17:21,480 --> 00:17:23,959
with this one you can write your

377
00:17:23,959 --> 00:17:27,480
analyzer to process whatever analysis

378
00:17:27,480 --> 00:17:30,419
test you want but it doesn't provide you

379
00:17:30,419 --> 00:17:32,580
the control and how do we how can your

380
00:17:32,580 --> 00:17:34,740
analyzer control control the product

381
00:17:34,740 --> 00:17:36,299
operation

382
00:17:36,299 --> 00:17:39,299
well we introduced three mechanisms for

383
00:17:39,299 --> 00:17:41,880
you to control the control the character

384
00:17:41,880 --> 00:17:45,120
thread one is the traditional into three

385
00:17:45,120 --> 00:17:47,940
probe so we place this one byte in the

386
00:17:47,940 --> 00:17:51,660
kernels code anywhere you want then once

387
00:17:51,660 --> 00:17:53,940
it is triggered then this interrupt

388
00:17:53,940 --> 00:17:56,760
Handler will transfer the control to the

389
00:17:56,760 --> 00:17:59,340
osis exit gate

390
00:17:59,340 --> 00:18:03,000
so this Escape is basically a couple of

391
00:18:03,000 --> 00:18:06,840
uh instructions uh I won't go to details

392
00:18:06,840 --> 00:18:07,799
here

393
00:18:07,799 --> 00:18:10,440
um basically this will make a patient

394
00:18:10,440 --> 00:18:13,340
hierarchy switch so that the instruction

395
00:18:13,340 --> 00:18:17,340
runs afterwards will will be from the

396
00:18:17,340 --> 00:18:20,100
analyzer secret space not the kernels of

397
00:18:20,100 --> 00:18:22,260
the space that's why we call it execate

398
00:18:22,260 --> 00:18:24,960
we need the control the execution flow

399
00:18:24,960 --> 00:18:27,780
will switch from the target the kernel

400
00:18:27,780 --> 00:18:30,900
to the analyzer

401
00:18:30,900 --> 00:18:34,200
we also have this jump probe for a

402
00:18:34,200 --> 00:18:36,120
manifold control flow and tracing that

403
00:18:36,120 --> 00:18:38,880
can replace certain bytes that allow you

404
00:18:38,880 --> 00:18:41,940
to jump up this gate we can also allow

405
00:18:41,940 --> 00:18:44,340
you to do this event exception so you

406
00:18:44,340 --> 00:18:48,480
can catch a kind of page default uh

407
00:18:48,480 --> 00:18:52,580
interrupt Handler to do the analysis

408
00:18:52,620 --> 00:18:56,220
so one caveat here is these changes are

409
00:18:56,220 --> 00:18:59,520
only effective for the Target thread

410
00:18:59,520 --> 00:19:02,700
running in the on-site code the entire

411
00:19:02,700 --> 00:19:05,520
case the VM is not affected

412
00:19:05,520 --> 00:19:06,980
secondly

413
00:19:06,980 --> 00:19:11,100
also when we make changes on this on the

414
00:19:11,100 --> 00:19:14,220
on The Code by adding probes uh we may

415
00:19:14,220 --> 00:19:16,620
also provide a Handler but all these

416
00:19:16,620 --> 00:19:19,440
changes are remained transparent to the

417
00:19:19,440 --> 00:19:21,720
kernel to talk to a target the target

418
00:19:21,720 --> 00:19:25,260
doesn't doesn't see these artifacts

419
00:19:25,260 --> 00:19:27,660
uh this is by using virtualization

420
00:19:27,660 --> 00:19:30,840
techniques again the details are in our

421
00:19:30,840 --> 00:19:33,299
paper but of course I will be happy to

422
00:19:33,299 --> 00:19:35,280
expand later on

423
00:19:35,280 --> 00:19:37,919
Ben how do we resume the target once

424
00:19:37,919 --> 00:19:39,299
you've done your job how do how do you

425
00:19:39,299 --> 00:19:42,120
put it back well you can just jump in uh

426
00:19:42,120 --> 00:19:44,940
allow your code to jump to the entry

427
00:19:44,940 --> 00:19:47,340
gate so that control will pay passed

428
00:19:47,340 --> 00:19:50,940
back to the Target at this moment then

429
00:19:50,940 --> 00:19:54,179
you can choose where to resume you can

430
00:19:54,179 --> 00:19:57,000
choose the rip for the packed kernel to

431
00:19:57,000 --> 00:19:58,640
resume

432
00:19:58,640 --> 00:20:01,980
so let's look at these are two uh some

433
00:20:01,980 --> 00:20:04,020
examples this is the first one is you to

434
00:20:04,020 --> 00:20:07,620
use uh the Intel 3 probe to add the uh

435
00:20:07,620 --> 00:20:11,039
break point in the camera function entry

436
00:20:11,039 --> 00:20:13,980
so what yours your analyzer will only be

437
00:20:13,980 --> 00:20:16,140
composed of two piece of two functions

438
00:20:16,140 --> 00:20:17,640
one is the main

439
00:20:17,640 --> 00:20:19,320
so in the main function you set this

440
00:20:19,320 --> 00:20:22,440
probe uh in the location of this camera

441
00:20:22,440 --> 00:20:24,360
lock address then you just receive the

442
00:20:24,360 --> 00:20:26,280
program you still sorry you assume the

443
00:20:26,280 --> 00:20:29,600
the kernel then so when the current runs

444
00:20:29,600 --> 00:20:33,720
it Encounters this uh Kmart then this

445
00:20:33,720 --> 00:20:36,600
into three will hijack the fluid and

446
00:20:36,600 --> 00:20:39,240
pass it to your these uh into three

447
00:20:39,240 --> 00:20:41,820
Handler so head on over around you do

448
00:20:41,820 --> 00:20:44,340
some analysis work then you decide

449
00:20:44,340 --> 00:20:47,460
should I remove it or should I keep the

450
00:20:47,460 --> 00:20:49,260
kernel around

451
00:20:49,260 --> 00:20:52,559
Okay then if you use this control flow

452
00:20:52,559 --> 00:20:54,000
tracing then it's a little bit more

453
00:20:54,000 --> 00:20:55,400
complicated because you have to

454
00:20:55,400 --> 00:20:58,080
calculate where to put where to put the

455
00:20:58,080 --> 00:21:01,260
probe so initially you put this um the

456
00:21:01,260 --> 00:21:03,299
probe in the basic block engine basic

457
00:21:03,299 --> 00:21:06,720
block uh exit then resume Target so

458
00:21:06,720 --> 00:21:09,419
Target will run go to the candleer this

459
00:21:09,419 --> 00:21:12,000
this jump Handler the Handler where will

460
00:21:12,000 --> 00:21:14,880
just remove the previous one then set

461
00:21:14,880 --> 00:21:17,820
the new probe to the next block based on

462
00:21:17,820 --> 00:21:20,400
your calculation then you receive a

463
00:21:20,400 --> 00:21:23,160
target the target will continue to run

464
00:21:23,160 --> 00:21:25,080
okay

465
00:21:25,080 --> 00:21:27,960
so this jump rope is mainly for control

466
00:21:27,960 --> 00:21:30,299
flow and tracing this industry mainly

467
00:21:30,299 --> 00:21:33,480
for the code breakpoint

468
00:21:33,480 --> 00:21:35,580
all right again we have a short demo

469
00:21:35,580 --> 00:21:36,659
here

470
00:21:36,659 --> 00:21:38,720
um

471
00:21:43,980 --> 00:21:47,400
so again the this uh we run this and

472
00:21:47,400 --> 00:21:49,679
there are three Windows the Energizer on

473
00:21:49,679 --> 00:21:51,120
the left side there are two windows

474
00:21:51,120 --> 00:21:54,240
above the Target on the right side so

475
00:21:54,240 --> 00:21:56,880
one is from the gas VM output the second

476
00:21:56,880 --> 00:21:59,220
the one in the bottom is the information

477
00:21:59,220 --> 00:22:02,100
about the target thread so in the Target

478
00:22:02,100 --> 00:22:04,260
here the tax thread will issue two six

479
00:22:04,260 --> 00:22:08,039
calls both are get priority uh with

480
00:22:08,039 --> 00:22:09,419
different arguments

481
00:22:09,419 --> 00:22:13,200
then we export the thread to the to the

482
00:22:13,200 --> 00:22:16,440
analyzer so the analyzer can uh it will

483
00:22:16,440 --> 00:22:20,039
do two things one is to install uh in

484
00:22:20,039 --> 00:22:23,760
the three probe at the entry of

485
00:22:23,760 --> 00:22:25,880
at the entry of

486
00:22:25,880 --> 00:22:26,100
[Music]

487
00:22:26,100 --> 00:22:27,419
um

488
00:22:27,419 --> 00:22:30,960
of this uh get priority so you can see

489
00:22:30,960 --> 00:22:33,179
this get the priorities Handler sorry

490
00:22:33,179 --> 00:22:36,419
this picture is is triggered twice

491
00:22:36,419 --> 00:22:38,940
the in the second triggering of this

492
00:22:38,940 --> 00:22:41,760
Handler then well we can do a basic

493
00:22:41,760 --> 00:22:44,159
block tracing here we only Trace five

494
00:22:44,159 --> 00:22:46,020
blocks of code you can trace it to the

495
00:22:46,020 --> 00:22:47,520
end

496
00:22:47,520 --> 00:22:50,299
okay

497
00:22:54,059 --> 00:22:58,919
so to wrap up uh so uh osis give you

498
00:22:58,919 --> 00:23:01,440
this uh some new features for kind of

499
00:23:01,440 --> 00:23:05,400
analysis it is the third Centric allows

500
00:23:05,400 --> 00:23:08,100
you to make to make a surgical analysis

501
00:23:08,100 --> 00:23:11,460
uh it's not good for large scale code

502
00:23:11,460 --> 00:23:15,000
Centric analysis such as profiling or

503
00:23:15,000 --> 00:23:16,440
you want to you want to observe the

504
00:23:16,440 --> 00:23:20,460
kernels as one whole piece of work uh

505
00:23:20,460 --> 00:23:23,159
how how the if you want to observe some

506
00:23:23,159 --> 00:23:25,320
Global effects sorry it's always this

507
00:23:25,320 --> 00:23:27,600
may not help you but if we want make a

508
00:23:27,600 --> 00:23:31,140
uh uh say debugging then that is a very

509
00:23:31,140 --> 00:23:32,520
good application

510
00:23:32,520 --> 00:23:34,919
uh the second feature is it allows you

511
00:23:34,919 --> 00:23:36,780
to make a native access to the kernel

512
00:23:36,780 --> 00:23:39,419
memory and to the to the CPU context

513
00:23:39,419 --> 00:23:41,640
it has a strong security and

514
00:23:41,640 --> 00:23:45,299
transparency uh your analyzer is immune

515
00:23:45,299 --> 00:23:48,000
from a text from from the guest kernel

516
00:23:48,000 --> 00:23:51,059
because they are separated physically

517
00:23:51,059 --> 00:23:53,880
um is protected by the underlying on the

518
00:23:53,880 --> 00:23:55,260
paging hierarchy

519
00:23:55,260 --> 00:23:57,360
and your program lets you I think this

520
00:23:57,360 --> 00:23:58,860
is the most attractive one your program

521
00:23:58,860 --> 00:24:01,140
remains at the user space application

522
00:24:01,140 --> 00:24:04,980
you are free to use libraries like this

523
00:24:04,980 --> 00:24:08,159
course to build your analyzer and you

524
00:24:08,159 --> 00:24:09,360
don't need to worry about okay I'm

525
00:24:09,360 --> 00:24:10,980
programming the kernel the kind of

526
00:24:10,980 --> 00:24:13,080
service I can use you can do it at like

527
00:24:13,080 --> 00:24:15,419
a normal application

528
00:24:15,419 --> 00:24:17,340
there are a few

529
00:24:17,340 --> 00:24:19,860
um potential applications you can do VMI

530
00:24:19,860 --> 00:24:22,380
you can do the kernel debugging you can

531
00:24:22,380 --> 00:24:24,960
do crawl space malware analysis you can

532
00:24:24,960 --> 00:24:28,020
also do the attacks in forensics and to

533
00:24:28,020 --> 00:24:30,480
respond to the attack

534
00:24:30,480 --> 00:24:32,120
okay um

535
00:24:32,120 --> 00:24:35,880
five minutes uh yeah thank you I want to

536
00:24:35,880 --> 00:24:37,740
give some time for Q a session

537
00:24:37,740 --> 00:24:41,460
so to wrap up this is uh the um black

538
00:24:41,460 --> 00:24:43,500
has some bites basically the main

539
00:24:43,500 --> 00:24:46,320
takeaways so main takeaway here is uh

540
00:24:46,320 --> 00:24:48,659
with osis what you can do is you can

541
00:24:48,659 --> 00:24:51,600
easily develop and run a user space

542
00:24:51,600 --> 00:24:54,120
application this application allows you

543
00:24:54,120 --> 00:24:56,940
to dynamically and natively read and

544
00:24:56,940 --> 00:25:00,000
write control the the the the the type

545
00:25:00,000 --> 00:25:03,179
the thread in the get the VM so return

546
00:25:03,179 --> 00:25:05,940
is the threat is in a user mode on the

547
00:25:05,940 --> 00:25:07,440
current mode you can also do the

548
00:25:07,440 --> 00:25:10,140
analysis and you do not need to

549
00:25:10,140 --> 00:25:12,539
pre-process in the kernel there's no

550
00:25:12,539 --> 00:25:14,600
modification of the kernel is required

551
00:25:14,600 --> 00:25:17,940
uh there's no we don't need the source

552
00:25:17,940 --> 00:25:21,240
code okay apply this on Windows uh it

553
00:25:21,240 --> 00:25:23,400
has strong security and transparency

554
00:25:23,400 --> 00:25:26,039
there are a bunch of suitable

555
00:25:26,039 --> 00:25:28,500
applications from from our understanding

556
00:25:28,500 --> 00:25:31,440
we must culture BMI such as kind of

557
00:25:31,440 --> 00:25:35,230
debugging or malware analysis

558
00:25:35,230 --> 00:25:38,309
[Music]

559
00:25:42,150 --> 00:25:45,249
[Music]

