1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,340 --> 00:00:09,960
now it's my pleasure to Welcome to the

3
00:00:09,960 --> 00:00:12,660
stage uh piano Trooper Royal and Martin

4
00:00:12,660 --> 00:00:15,500
shortlaw

5
00:00:16,320 --> 00:00:18,960
thank you for this nice introduction so

6
00:00:18,960 --> 00:00:21,000
hi and welcome to this talk about custom

7
00:00:21,000 --> 00:00:23,160
Processing Unit tracing and patching

8
00:00:23,160 --> 00:00:25,859
intellectual microcode I'm Martin and

9
00:00:25,859 --> 00:00:28,619
I'm Pedro so today you will we will

10
00:00:28,619 --> 00:00:30,779
present you the first study can Dynamic

11
00:00:30,779 --> 00:00:33,660
analysis framework for CPU microcode all

12
00:00:33,660 --> 00:00:36,660
done via software yeah so we give the

13
00:00:36,660 --> 00:00:39,180
people a short outline now so we first

14
00:00:39,180 --> 00:00:41,879
start off with a deep dive on CPU

15
00:00:41,879 --> 00:00:44,879
microcode especially the atom microcode

16
00:00:44,879 --> 00:00:47,780
then we'll present you a the first

17
00:00:47,780 --> 00:00:50,520
static and analysis software framework

18
00:00:50,520 --> 00:00:53,399
for microcode then based on that we show

19
00:00:53,399 --> 00:00:55,199
you how you can use the framework to

20
00:00:55,199 --> 00:00:58,140
reverse engineer the microcode update

21
00:00:58,140 --> 00:00:59,760
algorithm

22
00:00:59,760 --> 00:01:02,460
and and then we will end up with some

23
00:01:02,460 --> 00:01:04,799
bonus content so first of all a

24
00:01:04,799 --> 00:01:06,960
disclaimer this is based on like our

25
00:01:06,960 --> 00:01:09,360
understanding of CPU micro code So in

26
00:01:09,360 --> 00:01:11,580
theory it would be all wrong but in

27
00:01:11,580 --> 00:01:13,500
practice we will see that a lot seems

28
00:01:13,500 --> 00:01:16,799
right so but before we get into the deep

29
00:01:16,799 --> 00:01:20,280
dive we will go to like an high level

30
00:01:20,280 --> 00:01:22,680
view on how CPUs works so at the

31
00:01:22,680 --> 00:01:24,960
University most people learn you have

32
00:01:24,960 --> 00:01:28,020
like this fetch decode execute right

33
00:01:28,020 --> 00:01:30,780
back steps and yeah basically we can see

34
00:01:30,780 --> 00:01:32,460
it in this high level view there is this

35
00:01:32,460 --> 00:01:35,159
front-end doing a fetching decode stage

36
00:01:35,159 --> 00:01:36,960
and then there are the out of order

37
00:01:36,960 --> 00:01:38,880
engine and somewhere there is the memory

38
00:01:38,880 --> 00:01:41,460
subsystem in between where it tries to

39
00:01:41,460 --> 00:01:43,380
speed up things using caches and all

40
00:01:43,380 --> 00:01:45,900
this stuff yes but it is not that simple

41
00:01:45,900 --> 00:01:49,259
obviously and x86 instructions like to

42
00:01:49,259 --> 00:01:51,240
be executed effectively they get

43
00:01:51,240 --> 00:01:53,460
translated into micro operations and

44
00:01:53,460 --> 00:01:55,020
okay most of them are like really simple

45
00:01:55,020 --> 00:01:56,939
instructions so like they have one or

46
00:01:56,939 --> 00:01:58,619
two micro operations like think about if

47
00:01:58,619 --> 00:02:00,720
you access memory or like you are to

48
00:02:00,720 --> 00:02:03,360
like to register for example but like

49
00:02:03,360 --> 00:02:05,939
some instructions need some more complex

50
00:02:05,939 --> 00:02:07,979
logic like think about CPU ID where you

51
00:02:07,979 --> 00:02:09,780
have like multiple leaves and you have

52
00:02:09,780 --> 00:02:12,000
like conditional execution based on the

53
00:02:12,000 --> 00:02:13,920
input that you do so there is a

54
00:02:13,920 --> 00:02:15,060
component called the macro code

55
00:02:15,060 --> 00:02:18,060
sequencer that takes care of like

56
00:02:18,060 --> 00:02:20,099
emitting a stream of micro operations

57
00:02:20,099 --> 00:02:22,800
that implement the logic of complex

58
00:02:22,800 --> 00:02:25,680
instructions yeah but before we go

59
00:02:25,680 --> 00:02:27,000
deeper into that

60
00:02:27,000 --> 00:02:28,680
we'll have to

61
00:02:28,680 --> 00:02:31,200
talk about the preliminary thing and

62
00:02:31,200 --> 00:02:34,140
that's the red unlock finding from

63
00:02:34,140 --> 00:02:36,360
positive Technologies from Mark amoloff

64
00:02:36,360 --> 00:02:39,360
and his team so they basically found on

65
00:02:39,360 --> 00:02:42,720
an exploit in the smm engine and they

66
00:02:42,720 --> 00:02:45,120
basically managed to Red unlock the CPU

67
00:02:45,120 --> 00:02:47,340
into a special State such that they can

68
00:02:47,340 --> 00:02:50,160
debug it and read out special

69
00:02:50,160 --> 00:02:52,980
um buffers like caches or staging

70
00:02:52,980 --> 00:02:55,379
buffers similar things and based on that

71
00:02:55,379 --> 00:02:57,720
they managed to extract and reverse

72
00:02:57,720 --> 00:03:00,420
engineer the gold mode u-code format

73
00:03:00,420 --> 00:03:03,540
they presented a disassembler for that

74
00:03:03,540 --> 00:03:05,580
and based on the reverse engineering

75
00:03:05,580 --> 00:03:07,860
they discovered new undocumented

76
00:03:07,860 --> 00:03:10,319
instructions which basically allow it to

77
00:03:10,319 --> 00:03:12,900
con control the access to internal

78
00:03:12,900 --> 00:03:15,840
buffers yes but like to understand what

79
00:03:15,840 --> 00:03:18,239
can we do based on this work we have to

80
00:03:18,239 --> 00:03:20,459
understand first like how does the like

81
00:03:20,459 --> 00:03:23,340
magical stuff work and we're talking

82
00:03:23,340 --> 00:03:25,739
about this magical sequencer you like

83
00:03:25,739 --> 00:03:26,760
let's assume that you have an

84
00:03:26,760 --> 00:03:28,739
instruction like CPU ID that needs a

85
00:03:28,739 --> 00:03:31,260
stream of micro operations you have like

86
00:03:31,260 --> 00:03:33,120
a translation table where like the

87
00:03:33,120 --> 00:03:36,000
instruction gets matched and you will

88
00:03:36,000 --> 00:03:38,519
jump to the microcode ROM where the CPU

89
00:03:38,519 --> 00:03:40,620
will takes micro instructions and

90
00:03:40,620 --> 00:03:42,540
execute them to implement the complex

91
00:03:42,540 --> 00:03:45,180
Logic the micro instructions are like

92
00:03:45,180 --> 00:03:47,159
organizing Triads and every single

93
00:03:47,159 --> 00:03:49,379
Triads as a sequence word Associated to

94
00:03:49,379 --> 00:03:51,659
it like a sequence rule effect of maybe

95
00:03:51,659 --> 00:03:53,519
affects some synchronization during the

96
00:03:53,519 --> 00:03:55,200
micro operations like think about like

97
00:03:55,200 --> 00:03:57,599
elephants like stuff or even the Contour

98
00:03:57,599 --> 00:04:00,239
flow while executing this so obviously

99
00:04:00,239 --> 00:04:02,519
if it was like that you have a ROM and

100
00:04:02,519 --> 00:04:04,620
the CPU code will be fixed so what if

101
00:04:04,620 --> 00:04:06,299
you have like to patch some bug like

102
00:04:06,299 --> 00:04:08,459
epic click for example and you have to

103
00:04:08,459 --> 00:04:12,739
fix that so CPU like also supports a ram

104
00:04:12,739 --> 00:04:15,360
like kind of internal memory where you

105
00:04:15,360 --> 00:04:17,699
can like edit and Patch the microphone

106
00:04:17,699 --> 00:04:20,040
there but how can you pass between those

107
00:04:20,040 --> 00:04:21,660
two internal buffers there is a

108
00:04:21,660 --> 00:04:22,919
component called the match and patch

109
00:04:22,919 --> 00:04:25,199
that every time you execute an

110
00:04:25,199 --> 00:04:27,419
instruction if the destruction is like

111
00:04:27,419 --> 00:04:29,820
programmed to jump so to their arm the

112
00:04:29,820 --> 00:04:31,320
matching patch will redirect to the

113
00:04:31,320 --> 00:04:33,360
control flow to the RAM and execute the

114
00:04:33,360 --> 00:04:36,000
new instruction that are passed there

115
00:04:36,000 --> 00:04:39,360
so um now I I managed to look into the

116
00:04:39,360 --> 00:04:41,639
disassembly and I found this Triads here

117
00:04:41,639 --> 00:04:43,080
we're managing so we have these three

118
00:04:43,080 --> 00:04:44,940
operations the fourth one was always a

119
00:04:44,940 --> 00:04:47,040
knob operation and then we have this

120
00:04:47,040 --> 00:04:48,900
sequence words you mentioned which are

121
00:04:48,900 --> 00:04:50,880
basically properties about the current

122
00:04:50,880 --> 00:04:52,800
microcode instructions but if you look

123
00:04:52,800 --> 00:04:55,020
at that it's like you cannot really read

124
00:04:55,020 --> 00:04:57,120
that so we use the disassembler

125
00:04:57,120 --> 00:04:59,940
obviously and then we see like the

126
00:04:59,940 --> 00:05:02,759
microcode has a similar structure to x86

127
00:05:02,759 --> 00:05:04,740
yeah it's really similar so you have

128
00:05:04,740 --> 00:05:06,840
branching instructions you have internal

129
00:05:06,840 --> 00:05:09,540
temporary registers and the things in

130
00:05:09,540 --> 00:05:12,060
blue if you see them there are these

131
00:05:12,060 --> 00:05:14,400
sequence word instructions so they're

132
00:05:14,400 --> 00:05:16,680
for instance the last line shows the

133
00:05:16,680 --> 00:05:17,840
next

134
00:05:17,840 --> 00:05:20,340
microcode instruction being X yes and

135
00:05:20,340 --> 00:05:22,199
every sequence word is associated to all

136
00:05:22,199 --> 00:05:23,940
the three micro instructions that you

137
00:05:23,940 --> 00:05:26,639
have there but if we look at the

138
00:05:26,639 --> 00:05:28,979
microcode we can see that it's highly

139
00:05:28,979 --> 00:05:31,139
optimized so in the CPU we have like a

140
00:05:31,139 --> 00:05:33,240
small buffer we have to like pack all

141
00:05:33,240 --> 00:05:34,560
the instructions that you want to like

142
00:05:34,560 --> 00:05:36,419
to use to implement the functionalities

143
00:05:36,419 --> 00:05:38,580
that you want to microcode there

144
00:05:38,580 --> 00:05:41,580
so the market is highly Tangled you have

145
00:05:41,580 --> 00:05:43,320
like blocks of code that are shared

146
00:05:43,320 --> 00:05:44,880
between multiple functions so it's

147
00:05:44,880 --> 00:05:47,880
really hard to like analyze it and I

148
00:05:47,880 --> 00:05:49,800
mean it would be cool to have like a

149
00:05:49,800 --> 00:05:52,199
high level view of the microcode but

150
00:05:52,199 --> 00:05:54,360
unfortunately like at the compiler for

151
00:05:54,360 --> 00:05:55,800
example for this doesn't exist since

152
00:05:55,800 --> 00:05:57,960
it's like it was undocumented so we

153
00:05:57,960 --> 00:05:59,340
brought one

154
00:05:59,340 --> 00:06:01,699
so you see here this is a guitar

155
00:06:01,699 --> 00:06:05,400
decompiler it actually looks cool and

156
00:06:05,400 --> 00:06:08,400
you can for instance see the rc4 decrypt

157
00:06:08,400 --> 00:06:10,620
function which is later on as we will

158
00:06:10,620 --> 00:06:13,320
show used in the update algorithm and

159
00:06:13,320 --> 00:06:15,300
you see clearly that's like beautiful C

160
00:06:15,300 --> 00:06:17,400
code and you can work on that and start

161
00:06:17,400 --> 00:06:19,560
your reverse engineering with that

162
00:06:19,560 --> 00:06:21,900
so when I was going through this whole

163
00:06:21,900 --> 00:06:23,699
thing I saw like there was a special

164
00:06:23,699 --> 00:06:26,280
interaction always with with a certain

165
00:06:26,280 --> 00:06:28,319
component and this one was called the CR

166
00:06:28,319 --> 00:06:30,900
paths yes so to understand better like

167
00:06:30,900 --> 00:06:33,000
what when you do this we have to

168
00:06:33,000 --> 00:06:34,500
understand what is the control register

169
00:06:34,500 --> 00:06:37,259
bus and this is like the bus that the

170
00:06:37,259 --> 00:06:39,360
CPU uses to interact with its internal

171
00:06:39,360 --> 00:06:42,539
components so for example like msrs are

172
00:06:42,539 --> 00:06:45,300
mapped into sierbassadors some of them

173
00:06:45,300 --> 00:06:48,000
actually and also also like control

174
00:06:48,000 --> 00:06:50,639
status registers are effectively like

175
00:06:50,639 --> 00:06:52,919
addresses in this year bus where the CPU

176
00:06:52,919 --> 00:06:54,060
access them to implement the

177
00:06:54,060 --> 00:06:55,919
functionality that you want like system

178
00:06:55,919 --> 00:06:57,780
management mode configuration is mapped

179
00:06:57,780 --> 00:06:59,520
to this earbuds system management mode

180
00:06:59,520 --> 00:07:02,160
is like this ring -2 mode in the CPU

181
00:07:02,160 --> 00:07:05,100
that is like really like lockdown that

182
00:07:05,100 --> 00:07:06,360
you should never access that and the

183
00:07:06,360 --> 00:07:08,400
configuration for that is in the CR bus

184
00:07:08,400 --> 00:07:10,500
and also like interesting look also the

185
00:07:10,500 --> 00:07:13,500
L that is mapped into the CR bus so what

186
00:07:13,500 --> 00:07:16,500
what is that ldot so I guess yeah so the

187
00:07:16,500 --> 00:07:18,900
ldot is this like really interesting

188
00:07:18,900 --> 00:07:21,599
component in like Intel CPUs that is

189
00:07:21,599 --> 00:07:23,639
used for like post silicon validation

190
00:07:23,639 --> 00:07:25,979
and it's a component that has access to

191
00:07:25,979 --> 00:07:28,080
like all the internal buffers of the CPU

192
00:07:28,080 --> 00:07:30,000
like let's think about for example the

193
00:07:30,000 --> 00:07:32,940
tlb or like load and store buffers so

194
00:07:32,940 --> 00:07:35,520
through the ldot you can check that this

195
00:07:35,520 --> 00:07:38,039
component actually work

196
00:07:38,039 --> 00:07:40,500
that's awesome so yes and also for

197
00:07:40,500 --> 00:07:42,419
example you have access to the microcode

198
00:07:42,419 --> 00:07:45,240
sequencers here to the ldot so the

199
00:07:45,240 --> 00:07:46,560
microcode sequence as you already

200
00:07:46,560 --> 00:07:49,259
mentioned that so what does it exactly

201
00:07:49,259 --> 00:07:51,780
do so yeah like as we say the multiple

202
00:07:51,780 --> 00:07:54,060
sequencer is the component that has

203
00:07:54,060 --> 00:07:56,400
access to the microcode in the CPU both

204
00:07:56,400 --> 00:07:58,139
to the ROM and to the ROM and

205
00:07:58,139 --> 00:08:00,060
interestingly you had access it has

206
00:08:00,060 --> 00:08:02,400
bright access to the ram so leveraging

207
00:08:02,400 --> 00:08:04,259
the macro sequencer you have access to

208
00:08:04,259 --> 00:08:07,560
the microcode and to like modify it so

209
00:08:07,560 --> 00:08:10,139
here we can I would say let's have an

210
00:08:10,139 --> 00:08:13,620
idea we know that the ldot can access

211
00:08:13,620 --> 00:08:16,139
the microcode sequencer and that the

212
00:08:16,139 --> 00:08:19,440
ldap is can be accessed through the CR

213
00:08:19,440 --> 00:08:24,000
bus all right so if we now access the CR

214
00:08:24,000 --> 00:08:26,699
bus we can basically control the

215
00:08:26,699 --> 00:08:28,500
microcode yes basically if you can

216
00:08:28,500 --> 00:08:30,060
access this your bus then you have

217
00:08:30,060 --> 00:08:32,580
Microsoft control okay but we need one

218
00:08:32,580 --> 00:08:34,860
more building block oh yeah so you were

219
00:08:34,860 --> 00:08:37,500
talking about or I was talking actually

220
00:08:37,500 --> 00:08:39,839
about this undocumented instructions so

221
00:08:39,839 --> 00:08:42,179
let's take a look on how those work and

222
00:08:42,179 --> 00:08:44,520
what we can access with them yeah so

223
00:08:44,520 --> 00:08:46,260
like one of the discoveries of positive

224
00:08:46,260 --> 00:08:49,019
technology guys was this existence of

225
00:08:49,019 --> 00:08:50,640
this and documented destruction that has

226
00:08:50,640 --> 00:08:52,740
access with like a few internal

227
00:08:52,740 --> 00:08:55,380
components of the CPU among those that's

228
00:08:55,380 --> 00:08:57,959
the sheer bus awesome so we have our

229
00:08:57,959 --> 00:08:59,940
primitive too so yeah we can leverage

230
00:08:59,940 --> 00:09:02,820
this primitive as an easy way to access

231
00:09:02,820 --> 00:09:05,580
this year bus for red unlocked CPUs like

232
00:09:05,580 --> 00:09:07,800
the government but the problem is that

233
00:09:07,800 --> 00:09:10,560
okay but what can we do with this how

234
00:09:10,560 --> 00:09:12,720
can we access the ldot like how does it

235
00:09:12,720 --> 00:09:15,660
work and here like our the compiler came

236
00:09:15,660 --> 00:09:18,600
handy since we can analyze what the CPU

237
00:09:18,600 --> 00:09:21,120
does with the CR bus to access the ldot

238
00:09:21,120 --> 00:09:23,580
to modify the microbot sequencer and

239
00:09:23,580 --> 00:09:25,800
just copy that yes we know that the CPU

240
00:09:25,800 --> 00:09:27,660
knows how to do that so we can just do

241
00:09:27,660 --> 00:09:29,880
the same thing and we can Define like

242
00:09:29,880 --> 00:09:32,339
easy wrappers around this where you can

243
00:09:32,339 --> 00:09:35,160
like access the microcode sequencer and

244
00:09:35,160 --> 00:09:37,440
for example with these wrappers that's

245
00:09:37,440 --> 00:09:39,720
like just copy what the CPU are doing

246
00:09:39,720 --> 00:09:42,660
and access the like ldot ports you can

247
00:09:42,660 --> 00:09:45,120
like access the microcode access the

248
00:09:45,120 --> 00:09:46,500
sequence word and even the matching

249
00:09:46,500 --> 00:09:49,019
patch yeah so we have arbitrary written

250
00:09:49,019 --> 00:09:51,720
right and you already mentioned that

251
00:09:51,720 --> 00:09:53,700
match and fetch mechanism so we were

252
00:09:53,700 --> 00:09:55,800
thinking about it like maybe to a

253
00:09:55,800 --> 00:09:58,320
similar extent as like software hooking

254
00:09:58,320 --> 00:10:00,720
where you say like I want to overwrite

255
00:10:00,720 --> 00:10:03,779
this function and point redirect it to

256
00:10:03,779 --> 00:10:05,820
the other one so is it is it really that

257
00:10:05,820 --> 00:10:08,100
simple in the microcode yeah so we can

258
00:10:08,100 --> 00:10:09,839
still leverage our the compiler to

259
00:10:09,839 --> 00:10:11,580
understand how the CPU uses the machine

260
00:10:11,580 --> 00:10:14,160
patch and device like the simple formula

261
00:10:14,160 --> 00:10:17,399
that the CPU uses to like program this

262
00:10:17,399 --> 00:10:19,800
machine parts so every time we want to

263
00:10:19,800 --> 00:10:22,320
hook something or pass something we can

264
00:10:22,320 --> 00:10:23,820
program the address to the matching

265
00:10:23,820 --> 00:10:25,620
patch to just jump to the instruction

266
00:10:25,620 --> 00:10:27,060
that we want

267
00:10:27,060 --> 00:10:30,180
awesome so if we sum that up this is

268
00:10:30,180 --> 00:10:32,880
like I can hook a microcode update and

269
00:10:32,880 --> 00:10:34,980
override it with my own code so it's

270
00:10:34,980 --> 00:10:37,440
super custom now yes and this brings to

271
00:10:37,440 --> 00:10:39,959
our framework we can leverage this

272
00:10:39,959 --> 00:10:42,240
undocumented instruction to patch the

273
00:10:42,240 --> 00:10:44,880
microcode Via software this allows us to

274
00:10:44,880 --> 00:10:47,399
observe completely the CPU Behavior but

275
00:10:47,399 --> 00:10:49,560
also to completely control their

276
00:10:49,560 --> 00:10:51,959
behavior and all of this via software

277
00:10:51,959 --> 00:10:54,240
like either with a custom bios like a

278
00:10:54,240 --> 00:10:57,480
ufi application or a kernel module so

279
00:10:57,480 --> 00:10:59,579
summing up the framework I think we can

280
00:10:59,579 --> 00:11:02,339
now patch code we can hook code run our

281
00:11:02,339 --> 00:11:05,040
own custom code and I think we can even

282
00:11:05,040 --> 00:11:07,440
do more right we can yes we can trace

283
00:11:07,440 --> 00:11:09,060
the code and we will see how but let's

284
00:11:09,060 --> 00:11:11,160
start first from patching code

285
00:11:11,160 --> 00:11:13,860
so with you got Patches we can change

286
00:11:13,860 --> 00:11:17,040
the CPU behavior and notice that usually

287
00:11:17,040 --> 00:11:19,019
only Intel is allowed to do that since

288
00:11:19,019 --> 00:11:21,240
microgot patches are signed and you're

289
00:11:21,240 --> 00:11:23,640
not supposed to load your patches but

290
00:11:23,640 --> 00:11:25,500
with our framework we can inject

291
00:11:25,500 --> 00:11:27,959
microcode patches to change completely

292
00:11:27,959 --> 00:11:30,120
CPU Behavior like we can change

293
00:11:30,120 --> 00:11:32,220
microcoded instructions with this or

294
00:11:32,220 --> 00:11:34,440
even add functionalities to the CPU

295
00:11:34,440 --> 00:11:38,279
so maybe we go up a step back I think

296
00:11:38,279 --> 00:11:40,200
it's too complicated here at the moment

297
00:11:40,200 --> 00:11:42,360
let's do a simple program maybe

298
00:11:42,360 --> 00:11:44,399
something like Hello World in microcode

299
00:11:44,399 --> 00:11:47,100
yes so let me present you the first

300
00:11:47,100 --> 00:11:49,680
microcode part shallow world so I was

301
00:11:49,680 --> 00:11:51,180
thinking what can we do with an L word

302
00:11:51,180 --> 00:11:53,459
and like let's pick the art Duran

303
00:11:53,459 --> 00:11:55,200
Destruction for example so rdrand is

304
00:11:55,200 --> 00:11:56,640
supposed to provide you a

305
00:11:56,640 --> 00:11:59,040
cryptographically strong random number

306
00:11:59,040 --> 00:12:01,500
so let's piss off some cryptographers

307
00:12:01,500 --> 00:12:04,140
and let's make it return hello world

308
00:12:04,140 --> 00:12:06,420
with our framework

309
00:12:06,420 --> 00:12:09,420
you can select what do we want to eat to

310
00:12:09,420 --> 00:12:11,700
hook and then where do you want to jump

311
00:12:11,700 --> 00:12:13,980
for the instruction and you can see

312
00:12:13,980 --> 00:12:16,560
there we have two micro operations that

313
00:12:16,560 --> 00:12:18,959
load hello world to the registers so

314
00:12:18,959 --> 00:12:20,160
that you will not have random numbers

315
00:12:20,160 --> 00:12:23,459
but hello order and then you just end

316
00:12:23,459 --> 00:12:25,500
the instruction stream and tell the CPU

317
00:12:25,500 --> 00:12:29,160
okay you're done but I think you left

318
00:12:29,160 --> 00:12:30,720
out one point we kind of need to

319
00:12:30,720 --> 00:12:33,180
assemble this stuff yes so we brought an

320
00:12:33,180 --> 00:12:35,519
assembler for the microcode so that our

321
00:12:35,519 --> 00:12:37,440
framework translates from a textual

322
00:12:37,440 --> 00:12:39,779
representation of the macro code to the

323
00:12:39,779 --> 00:12:41,519
interactions that you need to do to the

324
00:12:41,519 --> 00:12:43,860
macrobot sequencer to actually patch the

325
00:12:43,860 --> 00:12:46,079
micro code so we assemble the microcode

326
00:12:46,079 --> 00:12:48,180
write it to the address that we set in

327
00:12:48,180 --> 00:12:50,940
this case 730 that is just the like

328
00:12:50,940 --> 00:12:53,399
starting address of the UVO drum and

329
00:12:53,399 --> 00:12:55,380
then we set up the matching patch so

330
00:12:55,380 --> 00:12:57,180
that every time you execute our Durand

331
00:12:57,180 --> 00:13:00,180
you actually return L word so I think

332
00:13:00,180 --> 00:13:02,339
the example is kind of nice and handy

333
00:13:02,339 --> 00:13:04,440
but I think the people here want to see

334
00:13:04,440 --> 00:13:07,500
something more yeah it easier so let's

335
00:13:07,500 --> 00:13:09,240
do something more interest

336
00:13:09,240 --> 00:13:11,459
we can okay we know that Rd running

337
00:13:11,459 --> 00:13:14,459
returns like randomly though so like

338
00:13:14,459 --> 00:13:16,079
let's change this I don't like random

339
00:13:16,079 --> 00:13:17,279
data I want to look something

340
00:13:17,279 --> 00:13:19,320
interesting so let's make cardi run

341
00:13:19,320 --> 00:13:22,019
return system management mode memory so

342
00:13:22,019 --> 00:13:24,120
system management mode is this caged

343
00:13:24,120 --> 00:13:26,519
environment in the CPO is like this ring

344
00:13:26,519 --> 00:13:28,680
-2 mode where you are not obviously

345
00:13:28,680 --> 00:13:30,839
supposed to access it but we can change

346
00:13:30,839 --> 00:13:32,160
the microcode for the algebra

347
00:13:32,160 --> 00:13:34,980
instruction to just load the SM ROM

348
00:13:34,980 --> 00:13:37,200
address for example but what happens if

349
00:13:37,200 --> 00:13:39,420
you now read from this so yeah this is

350
00:13:39,420 --> 00:13:41,760
like a cage memory so if you do this you

351
00:13:41,760 --> 00:13:43,440
will read a bunch of F's like if you

352
00:13:43,440 --> 00:13:45,420
access for example Enclave memory from

353
00:13:45,420 --> 00:13:47,639
outside on Enclave the CPU protects

354
00:13:47,639 --> 00:13:50,279
sorry the mmu protects that region so

355
00:13:50,279 --> 00:13:52,440
you will not able to access it but we

356
00:13:52,440 --> 00:13:54,000
are in the microcode so we can change

357
00:13:54,000 --> 00:13:56,579
this and leveraging our framework we can

358
00:13:56,579 --> 00:13:59,100
understand where the configuration for

359
00:13:59,100 --> 00:14:01,620
the SM ROM is like located in the CR bus

360
00:14:01,620 --> 00:14:03,720
and actually zero it out

361
00:14:03,720 --> 00:14:06,000
so that this SM room will not be

362
00:14:06,000 --> 00:14:08,160
protected anymore yes but then you break

363
00:14:08,160 --> 00:14:10,260
the CPU right yeah so the CPU will not

364
00:14:10,260 --> 00:14:11,579
be happy about this since you're like

365
00:14:11,579 --> 00:14:14,519
just disabling smm so you can save and

366
00:14:14,519 --> 00:14:17,339
restore the smm configuration but just

367
00:14:17,339 --> 00:14:19,019
after you're dumping that oh that's

368
00:14:19,019 --> 00:14:21,899
really nice so but I think the people

369
00:14:21,899 --> 00:14:24,600
might not believe us so let's show them

370
00:14:24,600 --> 00:14:26,760
a demo yeah like let's show something

371
00:14:26,760 --> 00:14:29,519
cool so here for example we have a

372
00:14:29,519 --> 00:14:31,260
simple program in our ufi application

373
00:14:31,260 --> 00:14:33,779
where you just dump like the ardu and

374
00:14:33,779 --> 00:14:36,600
others like they are their results with

375
00:14:36,600 --> 00:14:39,540
random data here but we can program the

376
00:14:39,540 --> 00:14:42,180
CPU with our patches to change it and

377
00:14:42,180 --> 00:14:44,699
actually return L word to that so that

378
00:14:44,699 --> 00:14:46,920
with this with our CPU framework with

379
00:14:46,920 --> 00:14:49,079
our custom Processing Unit framework we

380
00:14:49,079 --> 00:14:51,000
hook the patch and the next time that

381
00:14:51,000 --> 00:14:53,519
you execute rd-ron you have L word wow

382
00:14:53,519 --> 00:14:55,920
that's super cool and about the system

383
00:14:55,920 --> 00:14:58,320
management yes so let's go there more

384
00:14:58,320 --> 00:15:00,660
cool stuff yeah and we still have like a

385
00:15:00,660 --> 00:15:03,000
simple program that dumps a bunch of

386
00:15:03,000 --> 00:15:05,160
buffer filled with on our Duran content

387
00:15:05,160 --> 00:15:07,860
and it's obviously random since random

388
00:15:07,860 --> 00:15:10,860
data but let's apply our fetch the patch

389
00:15:10,860 --> 00:15:12,540
that you've seen before just modify to

390
00:15:12,540 --> 00:15:14,639
like dump different addresses and not

391
00:15:14,639 --> 00:15:17,220
only one and we can apply our patch and

392
00:15:17,220 --> 00:15:18,540
the next time we execute the program

393
00:15:18,540 --> 00:15:21,000
that dumps memory they already around

394
00:15:21,000 --> 00:15:23,100
you actually dump system management mode

395
00:15:23,100 --> 00:15:25,019
memory you can see the header of system

396
00:15:25,019 --> 00:15:28,260
management mode there oh yeah awesome

397
00:15:28,260 --> 00:15:29,579
so

398
00:15:29,579 --> 00:15:32,579
going further so now we can do something

399
00:15:32,579 --> 00:15:34,560
more you already mentioned it what

400
00:15:34,560 --> 00:15:36,600
happens if we now set up this match and

401
00:15:36,600 --> 00:15:38,160
Patch mechanism

402
00:15:38,160 --> 00:15:41,279
and execute custom microcode at certain

403
00:15:41,279 --> 00:15:43,740
events right yeah and resume the

404
00:15:43,740 --> 00:15:45,959
execution we basically don't need to

405
00:15:45,959 --> 00:15:47,579
fetch stuff but we actually find

406
00:15:47,579 --> 00:15:49,680
something out about it yeah so we we

407
00:15:49,680 --> 00:15:51,540
don't have to like stop an instruction

408
00:15:51,540 --> 00:15:53,459
after the rooking that you can simple

409
00:15:53,459 --> 00:15:55,560
continue the execution and this brings

410
00:15:55,560 --> 00:15:57,779
to like microcode hooks where you can

411
00:15:57,779 --> 00:16:00,060
execute more code and extend the

412
00:16:00,060 --> 00:16:02,040
functionalities of something or for

413
00:16:02,040 --> 00:16:04,199
example observe stuff

414
00:16:04,199 --> 00:16:06,720
so after executing an instruction if you

415
00:16:06,720 --> 00:16:08,160
resolve the execution on the CPU will

416
00:16:08,160 --> 00:16:09,779
like not even notice that you like

417
00:16:09,779 --> 00:16:13,459
hijack that and for example here we can

418
00:16:13,459 --> 00:16:16,800
like make our own performance counters

419
00:16:16,800 --> 00:16:18,300
so let's assume that you want to observe

420
00:16:18,300 --> 00:16:21,660
something in sapu but like the CPU is

421
00:16:21,660 --> 00:16:24,180
not nice enough to already have that

422
00:16:24,180 --> 00:16:25,560
performance counter that you want to

423
00:16:25,560 --> 00:16:28,380
observe set up for you and let's assume

424
00:16:28,380 --> 00:16:29,940
that you want to observe I don't know

425
00:16:29,940 --> 00:16:32,040
every time the vert W extraction is

426
00:16:32,040 --> 00:16:34,139
executed you know it Intel uses a lot

427
00:16:34,139 --> 00:16:37,500
this instruction to like a patch like

428
00:16:37,500 --> 00:16:39,600
vulnerability is there to flush internal

429
00:16:39,600 --> 00:16:41,820
buffers for example for MDS mitigation

430
00:16:41,820 --> 00:16:43,740
so maybe you want to understand okay but

431
00:16:43,740 --> 00:16:46,199
okay given a full system let me know how

432
00:16:46,199 --> 00:16:48,120
many times you you did that actually

433
00:16:48,120 --> 00:16:51,360
exactly and we can leverage our hooks to

434
00:16:51,360 --> 00:16:53,399
hook the entry point of the instruction

435
00:16:53,399 --> 00:16:55,560
that we want to trace so so that we want

436
00:16:55,560 --> 00:16:57,899
to hook and then continue with after and

437
00:16:57,899 --> 00:16:59,519
in our hook we can just Implement a

438
00:16:59,519 --> 00:17:01,680
simple counter that will be incremented

439
00:17:01,680 --> 00:17:03,839
every time the instruction is executed

440
00:17:03,839 --> 00:17:06,599
so you will effectively have defined

441
00:17:06,599 --> 00:17:08,939
your own performance counter that's

442
00:17:08,939 --> 00:17:11,220
awesome but I guess you can even do more

443
00:17:11,220 --> 00:17:13,319
with that yes we can be smarter with the

444
00:17:13,319 --> 00:17:15,660
hooks if we Define a hook that every

445
00:17:15,660 --> 00:17:17,760
time it gets triggered like it just

446
00:17:17,760 --> 00:17:19,740
dumps the timestamp when it got

447
00:17:19,740 --> 00:17:22,980
triggered you can then like program this

448
00:17:22,980 --> 00:17:25,500
hook for every single micro operation in

449
00:17:25,500 --> 00:17:27,959
the CPU and every time an a micro

450
00:17:27,959 --> 00:17:29,880
operation will be executed you will dump

451
00:17:29,880 --> 00:17:31,980
the timestamp where that micro operation

452
00:17:31,980 --> 00:17:35,039
is executed in the end you will have all

453
00:17:35,039 --> 00:17:37,440
the timestamp that got triggered by this

454
00:17:37,440 --> 00:17:39,900
hook and then you can reorder them so

455
00:17:39,900 --> 00:17:41,580
that effectively you can obtain a trace

456
00:17:41,580 --> 00:17:43,620
of the micro operations that are

457
00:17:43,620 --> 00:17:45,960
executed in the CPU and this basically

458
00:17:45,960 --> 00:17:48,600
leads to a microcode control flow red

459
00:17:48,600 --> 00:17:50,460
you exactly know what's going on inside

460
00:17:50,460 --> 00:17:52,679
you you are effectively doing a dynamic

461
00:17:52,679 --> 00:17:54,900
trace of the microcode that is executed

462
00:17:54,900 --> 00:17:57,240
in the CPU so now we have all the

463
00:17:57,240 --> 00:17:59,220
building blocks to look at the microcode

464
00:17:59,220 --> 00:18:01,679
update routine yeah so what can we do

465
00:18:01,679 --> 00:18:03,480
with these phrases for example we can

466
00:18:03,480 --> 00:18:05,340
apply these traces so you can observe

467
00:18:05,340 --> 00:18:07,140
like literally everything the CPU is

468
00:18:07,140 --> 00:18:09,000
doing with the macro code and we did

469
00:18:09,000 --> 00:18:11,340
that for microgrid updates so so if you

470
00:18:11,340 --> 00:18:12,960
look at the mcgregate updates statically

471
00:18:12,960 --> 00:18:15,059
you will find a huge amount of code that

472
00:18:15,059 --> 00:18:16,260
will be like really hard to reverse

473
00:18:16,260 --> 00:18:19,380
engineering even with our decompiler but

474
00:18:19,380 --> 00:18:21,299
with traces it gets much better since

475
00:18:21,299 --> 00:18:23,340
you can observe exactly which control

476
00:18:23,340 --> 00:18:26,220
flow inside the microwave updates is

477
00:18:26,220 --> 00:18:28,799
taken so now we can trigger microcode

478
00:18:28,799 --> 00:18:31,860
update for instance then Trace if a

479
00:18:31,860 --> 00:18:34,140
micro instruction is executed and then

480
00:18:34,140 --> 00:18:37,140
repeat for all the possible micro call

481
00:18:37,140 --> 00:18:39,660
instructions and then we just restore

482
00:18:39,660 --> 00:18:41,700
the order again check out the timestamps

483
00:18:41,700 --> 00:18:44,400
and we see exactly which microcode

484
00:18:44,400 --> 00:18:46,799
instructions were accessed are so you

485
00:18:46,799 --> 00:18:48,179
effectively reverse engineer the

486
00:18:48,179 --> 00:18:49,740
microbial update algorithm that is

487
00:18:49,740 --> 00:18:51,960
always being kept secrets by Intel so

488
00:18:51,960 --> 00:18:53,940
here we like analyze what is happening

489
00:18:53,940 --> 00:18:56,100
during a microcode update and a

490
00:18:56,100 --> 00:18:58,500
microcode update is usually triggered by

491
00:18:58,500 --> 00:19:00,660
a bright MSR and the first thing that

492
00:19:00,660 --> 00:19:03,179
the CPU does is okay you have to apply

493
00:19:03,179 --> 00:19:05,640
this update and encrypt it so it first

494
00:19:05,640 --> 00:19:07,740
moves the update to a secret location

495
00:19:07,740 --> 00:19:10,140
there is no more secret but it's like

496
00:19:10,140 --> 00:19:12,360
fpv zero one thousand for example in

497
00:19:12,360 --> 00:19:14,220
Goldman CPUs and these are special

498
00:19:14,220 --> 00:19:16,200
physical address where the CPU puts the

499
00:19:16,200 --> 00:19:18,240
microcode of date and we can look at the

500
00:19:18,240 --> 00:19:19,860
format of the magical date that we

501
00:19:19,860 --> 00:19:21,660
reverse engineered at the beginning we

502
00:19:21,660 --> 00:19:23,280
have like some metadata that is like the

503
00:19:23,280 --> 00:19:24,720
date where the microbial date was

504
00:19:24,720 --> 00:19:26,640
published the security version number of

505
00:19:26,640 --> 00:19:29,880
the CPU ID that the microgridize is for

506
00:19:29,880 --> 00:19:32,640
and then you have like a nouns we will

507
00:19:32,640 --> 00:19:34,799
like focus on that later but it's used

508
00:19:34,799 --> 00:19:37,020
to like generate the decryption key for

509
00:19:37,020 --> 00:19:38,700
the motherboard update and then you have

510
00:19:38,700 --> 00:19:41,880
the RSA signature stuff so that you can

511
00:19:41,880 --> 00:19:44,400
like this CPU can verify that the macro

512
00:19:44,400 --> 00:19:47,340
got a date was actually from Intel and

513
00:19:47,340 --> 00:19:49,440
it was signed so the first thing that

514
00:19:49,440 --> 00:19:52,020
happens at the micrograph date is okay

515
00:19:52,020 --> 00:19:54,780
you have to check that the signature is

516
00:19:54,780 --> 00:19:56,880
what you expect for so the CPU has a

517
00:19:56,880 --> 00:19:58,860
white list of the modulus and the

518
00:19:58,860 --> 00:20:01,260
exponents that you can accept so that he

519
00:20:01,260 --> 00:20:04,140
knows that he don't didn't go tempered

520
00:20:04,140 --> 00:20:06,240
then you then you have to generate the

521
00:20:06,240 --> 00:20:08,760
key to decrypt the update and the CPU

522
00:20:08,760 --> 00:20:11,340
does this with two different Secrets One

523
00:20:11,340 --> 00:20:13,980
secret is the notes and it's embedded in

524
00:20:13,980 --> 00:20:15,720
every single macro called update and is

525
00:20:15,720 --> 00:20:18,000
always different per update then we have

526
00:20:18,000 --> 00:20:20,400
another secret that is Percival and

527
00:20:20,400 --> 00:20:23,280
every CPU has this like in like uh

528
00:20:23,280 --> 00:20:26,220
secret and random number that he uses in

529
00:20:26,220 --> 00:20:28,440
combination with the nodes to generate

530
00:20:28,440 --> 00:20:30,900
and to like do a case function algorithm

531
00:20:30,900 --> 00:20:32,640
based on shock to generate the

532
00:20:32,640 --> 00:20:34,260
decryption key

533
00:20:34,260 --> 00:20:36,960
the rc4 key then is generated so that we

534
00:20:36,960 --> 00:20:41,160
can like use rc4 to decrypt and as a

535
00:20:41,160 --> 00:20:43,140
best practice and they do that they

536
00:20:43,140 --> 00:20:45,539
eliminate the first Ox 200 bytes since

537
00:20:45,539 --> 00:20:47,280
they were like too tight with the like

538
00:20:47,280 --> 00:20:48,720
key bytes

539
00:20:48,720 --> 00:20:50,940
so now I guess that after generating the

540
00:20:50,940 --> 00:20:54,660
key we can go to the Crypt the update

541
00:20:54,660 --> 00:20:56,820
obviously after having to decrypt the

542
00:20:56,820 --> 00:20:59,039
update you have to check that the grid

543
00:20:59,039 --> 00:21:01,620
adapted the decrypted update was

544
00:21:01,620 --> 00:21:04,559
actually signed correctly so the shot

545
00:21:04,559 --> 00:21:07,500
256 of the update is calculated which is

546
00:21:07,500 --> 00:21:09,900
computed combining with the metadata and

547
00:21:09,900 --> 00:21:11,580
the nuns so that you cannot tamper with

548
00:21:11,580 --> 00:21:15,600
that and if the verification succeeds

549
00:21:15,600 --> 00:21:18,419
then you finally can pass the microgrid

550
00:21:18,419 --> 00:21:19,559
of days

551
00:21:19,559 --> 00:21:22,620
awesome so I was wondering you are

552
00:21:22,620 --> 00:21:25,200
mentioning this weird address here at

553
00:21:25,200 --> 00:21:27,960
the beginning so what is that yeah so

554
00:21:27,960 --> 00:21:30,240
it's so interesting to try to deepen

555
00:21:30,240 --> 00:21:32,580
okay what is this address

556
00:21:32,580 --> 00:21:34,440
this address is like this special

557
00:21:34,440 --> 00:21:37,140
physical location that the CPU uses to

558
00:21:37,140 --> 00:21:39,539
save the microphone update to move the

559
00:21:39,539 --> 00:21:41,580
macro code update there so if we query

560
00:21:41,580 --> 00:21:43,200
the operating system the poor operating

561
00:21:43,200 --> 00:21:45,059
system will have no idea what this this

562
00:21:45,059 --> 00:21:47,400
other is for and we can also try to dump

563
00:21:47,400 --> 00:21:50,039
this address and we will only read apps

564
00:21:50,039 --> 00:21:52,679
like if you access an enclave or SSM

565
00:21:52,679 --> 00:21:54,720
memory without unprotecting it so it

566
00:21:54,720 --> 00:21:57,299
must be something special yes so we

567
00:21:57,299 --> 00:21:58,799
should further investigate that maybe

568
00:21:58,799 --> 00:22:01,200
like using our framework to see what's

569
00:22:01,200 --> 00:22:03,120
going on right yes so we can see what

570
00:22:03,120 --> 00:22:04,799
this the CPU is doing with this address

571
00:22:04,799 --> 00:22:06,960
and we can see that this address is

572
00:22:06,960 --> 00:22:09,120
dynamically enabled by the CPU every

573
00:22:09,120 --> 00:22:10,860
time the microcode update is performed

574
00:22:10,860 --> 00:22:13,799
the CPU of rights to the CR bus like a

575
00:22:13,799 --> 00:22:16,500
bit that enables this address and we can

576
00:22:16,500 --> 00:22:19,020
poke around this address so we can like

577
00:22:19,020 --> 00:22:20,520
measure the access time when this

578
00:22:20,520 --> 00:22:21,960
address is enabled and this is

579
00:22:21,960 --> 00:22:24,840
surprising it's only 20 Cycles so mmio

580
00:22:24,840 --> 00:22:26,460
usually is really slow and this address

581
00:22:26,460 --> 00:22:28,080
is surprisingly fast

582
00:22:28,080 --> 00:22:31,559
but we can also observe that the content

583
00:22:31,559 --> 00:22:33,600
of this address is not shared between

584
00:22:33,600 --> 00:22:35,880
the CPUs it's like the CPUs has local

585
00:22:35,880 --> 00:22:38,700
view on this address and we can only fit

586
00:22:38,700 --> 00:22:41,220
a small amount of relatively small

587
00:22:41,220 --> 00:22:43,440
amount of data even if the mapped area

588
00:22:43,440 --> 00:22:46,140
is much bigger and then with Observer

589
00:22:46,140 --> 00:22:48,720
replacement policy on the address while

590
00:22:48,720 --> 00:22:50,640
we write them we lose the data sometimes

591
00:22:50,640 --> 00:22:53,100
okay that that reminds me of something

592
00:22:53,100 --> 00:22:56,220
you have 20 Cycles it's super fast then

593
00:22:56,220 --> 00:22:59,460
it's not shared between cores it fits to

594
00:22:59,460 --> 00:23:00,600
a certain size

595
00:23:00,600 --> 00:23:02,520
and then you have replacement policies

596
00:23:02,520 --> 00:23:04,919
so this kind of indicates that it's kind

597
00:23:04,919 --> 00:23:06,720
of a cache right yeah so our worry about

598
00:23:06,720 --> 00:23:08,580
this is is that the CPU through this

599
00:23:08,580 --> 00:23:10,980
physical address has a special view on

600
00:23:10,980 --> 00:23:14,039
the L2 cache that is like Frozen and

601
00:23:14,039 --> 00:23:15,780
used for the Micro World updates so that

602
00:23:15,780 --> 00:23:18,480
they have so the CPU as like a private

603
00:23:18,480 --> 00:23:20,400
buffer that is not accessible or

604
00:23:20,400 --> 00:23:23,480
tamperable from for example other course

605
00:23:23,480 --> 00:23:26,640
so let's look at the decrypted microcode

606
00:23:26,640 --> 00:23:28,140
up there yeah so finally we got the

607
00:23:28,140 --> 00:23:30,179
magical decrypted and you can look at

608
00:23:30,179 --> 00:23:32,340
the structure oh yeah so you see some

609
00:23:32,340 --> 00:23:34,799
kind of structure here again but yeah it

610
00:23:34,799 --> 00:23:36,720
looks like a byte code maybe so what

611
00:23:36,720 --> 00:23:39,419
yeah so you can still use our decompiler

612
00:23:39,419 --> 00:23:41,520
to try to understand okay what is the

613
00:23:41,520 --> 00:23:43,440
CPU doing with this update and it turns

614
00:23:43,440 --> 00:23:45,900
out that I'm aggregate is actually by

615
00:23:45,900 --> 00:23:47,820
its code it's interpreted by the CPU

616
00:23:47,820 --> 00:23:50,460
it's like if you download an installer

617
00:23:50,460 --> 00:23:53,460
that tells you how to update the CPU and

618
00:23:53,460 --> 00:23:55,380
you have different comments that the CPU

619
00:23:55,380 --> 00:23:57,659
that like the CPU follows while updating

620
00:23:57,659 --> 00:24:00,000
for example resetting internal buffers

621
00:24:00,000 --> 00:24:01,860
writing the microcode for the update

622
00:24:01,860 --> 00:24:04,980
setting the match and Patch hooks or

623
00:24:04,980 --> 00:24:07,320
even control flow directives so during

624
00:24:07,320 --> 00:24:09,299
the update you can have like conditional

625
00:24:09,299 --> 00:24:11,280
parts of the update based on different

626
00:24:11,280 --> 00:24:14,159
conditions so this basically allows you

627
00:24:14,159 --> 00:24:16,500
to deprecate things enable things this

628
00:24:16,500 --> 00:24:19,380
is yeah like dynamically wow that's nice

629
00:24:19,380 --> 00:24:22,140
so we should put all this together to

630
00:24:22,140 --> 00:24:24,720
build a decrypto yeah so we created a

631
00:24:24,720 --> 00:24:26,700
parser for microcode update collected

632
00:24:26,700 --> 00:24:28,760
all the Microsoft

633
00:24:28,760 --> 00:24:32,039
now in the CPU secrets so Goldman CPUs

634
00:24:32,039 --> 00:24:34,679
and we decrypted all of them and we

635
00:24:34,679 --> 00:24:37,080
released them publicly so that you can

636
00:24:37,080 --> 00:24:38,520
look at that

637
00:24:38,520 --> 00:24:41,460
all right that's super nice

638
00:24:41,460 --> 00:24:43,500
uh one thing to mention also the

639
00:24:43,500 --> 00:24:46,320
decompiler is like referred to in the in

640
00:24:46,320 --> 00:24:48,720
the repository we don't it's a separate

641
00:24:48,720 --> 00:24:51,000
GitHub yeah but and the compiler

642
00:24:51,000 --> 00:24:52,860
supports macro updates so that you can

643
00:24:52,860 --> 00:24:55,080
observe an eye level view of what the

644
00:24:55,080 --> 00:24:57,600
macrocodile place actually purchased

645
00:24:57,600 --> 00:24:59,700
but you already also mentioned at the

646
00:24:59,700 --> 00:25:01,140
beginning that there's some more some

647
00:25:01,140 --> 00:25:02,940
bonus content yeah okay let's look at

648
00:25:02,940 --> 00:25:04,320
something cooler

649
00:25:04,320 --> 00:25:06,900
and okay all this talk was about Goldman

650
00:25:06,900 --> 00:25:10,440
CPUs but does this generalize so it's

651
00:25:10,440 --> 00:25:11,940
really hard to say how much this

652
00:25:11,940 --> 00:25:14,220
generalizes but we can hear for example

653
00:25:14,220 --> 00:25:17,400
use a cool technique by Brandon Fork to

654
00:25:17,400 --> 00:25:19,620
trace their performance counters during

655
00:25:19,620 --> 00:25:22,080
the macro code update so the whole world

656
00:25:22,080 --> 00:25:24,000
stops during the macro code updates but

657
00:25:24,000 --> 00:25:26,100
not the performance counters so if we

658
00:25:26,100 --> 00:25:29,100
trace the load sorry the execution ports

659
00:25:29,100 --> 00:25:31,380
usage during the update we can try to

660
00:25:31,380 --> 00:25:33,360
infer what is happening during the

661
00:25:33,360 --> 00:25:35,220
update and we can see okay like

662
00:25:35,220 --> 00:25:37,740
sometimes load and store ports are used

663
00:25:37,740 --> 00:25:40,080
a lot so like this is like memory bounce

664
00:25:40,080 --> 00:25:42,179
stuff maybe like meme copying around

665
00:25:42,179 --> 00:25:44,279
maybe arithmetic stuff is used more so

666
00:25:44,279 --> 00:25:45,900
you have a face where the macro is

667
00:25:45,900 --> 00:25:47,820
decrypted so you can kind of try to

668
00:25:47,820 --> 00:25:49,620
guess what is happening there and maybe

669
00:25:49,620 --> 00:25:51,240
a machine learning guy will be handy

670
00:25:51,240 --> 00:25:53,400
here to understand what it's doing yes

671
00:25:53,400 --> 00:25:54,299
maybe

672
00:25:54,299 --> 00:25:57,200
is there some machine learning guy here

673
00:25:57,200 --> 00:26:00,120
but then let's go to some more bonuses

674
00:26:00,120 --> 00:26:01,380
oh yes yeah

675
00:26:01,380 --> 00:26:03,419
you you were mentioning like yesterday

676
00:26:03,419 --> 00:26:07,980
the Epic league and I think you we can

677
00:26:07,980 --> 00:26:10,679
kind of use the Epic yeah so we still

678
00:26:10,679 --> 00:26:12,539
have a special address and the CPU wants

679
00:26:12,539 --> 00:26:14,760
to access that address yesterday we were

680
00:26:14,760 --> 00:26:17,279
talking about epic mmio and we can take

681
00:26:17,279 --> 00:26:19,200
inspiration from a really cool exploit

682
00:26:19,200 --> 00:26:22,440
by Chris Tomas where this called memory

683
00:26:22,440 --> 00:26:24,840
sinkhole where you can move the Epic to

684
00:26:24,840 --> 00:26:27,059
Shadow different things so original the

685
00:26:27,059 --> 00:26:29,580
exploit was doing was like leveraged to

686
00:26:29,580 --> 00:26:31,799
like break system management mode but

687
00:26:31,799 --> 00:26:34,020
here we can move the Epic mmao region

688
00:26:34,020 --> 00:26:37,380
over the L2 cache view of the processor

689
00:26:37,380 --> 00:26:39,179
so that the processor actually access

690
00:26:39,179 --> 00:26:41,340
the Epic and not the macro update

691
00:26:41,340 --> 00:26:43,679
content so this is actually a failed

692
00:26:43,679 --> 00:26:47,220
exploit unfortunately but we tried both

693
00:26:47,220 --> 00:26:49,620
to move the Epic mmio over for example

694
00:26:49,620 --> 00:26:51,419
the shot tables that the micro code

695
00:26:51,419 --> 00:26:53,220
update is like using to compute the shot

696
00:26:53,220 --> 00:26:55,260
so that we can like for example generate

697
00:26:55,260 --> 00:26:56,580
a wrong shot that is not

698
00:26:56,580 --> 00:26:58,860
cryptographically secure to like bypass

699
00:26:58,860 --> 00:27:01,020
the signatures and even we try to like

700
00:27:01,020 --> 00:27:03,200
play

701
00:27:03,200 --> 00:27:05,940
buffer when is decrypted to lick that

702
00:27:05,940 --> 00:27:07,919
but the complexities of the microgrid

703
00:27:07,919 --> 00:27:10,260
update algorithm prevented us to exploit

704
00:27:10,260 --> 00:27:11,580
it further but I think that's a cool

705
00:27:11,580 --> 00:27:13,320
like future direction to look into

706
00:27:13,320 --> 00:27:16,860
definitely so um concluding our talk so

707
00:27:16,860 --> 00:27:18,720
you saw

708
00:27:18,720 --> 00:27:21,000
or learned a bit about microcode today

709
00:27:21,000 --> 00:27:23,880
and we deepen our understanding but

710
00:27:23,880 --> 00:27:26,640
using the framework you can even like go

711
00:27:26,640 --> 00:27:28,320
further and learn more about the micro

712
00:27:28,320 --> 00:27:29,279
code

713
00:27:29,279 --> 00:27:32,279
using our decompiler assembler aperture

714
00:27:32,279 --> 00:27:36,299
and tracer and so our framework is open

715
00:27:36,299 --> 00:27:38,580
source you can start hacking around your

716
00:27:38,580 --> 00:27:39,960
CPU also

717
00:27:39,960 --> 00:27:42,610
thank you very much thank you very much

718
00:27:42,610 --> 00:27:44,590
[Applause]

719
00:27:44,590 --> 00:27:47,699
[Music]

720
00:27:51,540 --> 00:27:54,649
[Music]

