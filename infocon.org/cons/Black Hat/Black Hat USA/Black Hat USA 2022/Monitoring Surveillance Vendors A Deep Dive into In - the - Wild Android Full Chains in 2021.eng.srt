1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,340 --> 00:00:09,599
it's my pleasure to welcome Christian

3
00:00:09,599 --> 00:00:12,620
Russell to the stage

4
00:00:17,520 --> 00:00:19,680
all right hey everyone uh Welcome to our

5
00:00:19,680 --> 00:00:22,260
presentation uh today we'll talk about a

6
00:00:22,260 --> 00:00:24,420
couple of uh Android full chains we

7
00:00:24,420 --> 00:00:27,420
discovered in the wild in 2021 by

8
00:00:27,420 --> 00:00:30,539
monitoring surveillance vendors

9
00:00:30,539 --> 00:00:33,120
This Is Us on your left hand side you

10
00:00:33,120 --> 00:00:35,520
have shingyu and Richard they work in

11
00:00:35,520 --> 00:00:37,800
the Android malware research team where

12
00:00:37,800 --> 00:00:39,899
they work on protecting Android against

13
00:00:39,899 --> 00:00:42,300
malware and exploits

14
00:00:42,300 --> 00:00:44,160
and on your right hand side you have me

15
00:00:44,160 --> 00:00:46,320
Christian I work in Google's threat

16
00:00:46,320 --> 00:00:48,719
analysis group I'll talk a bit uh more

17
00:00:48,719 --> 00:00:52,879
about what we do in a couple of slides

18
00:00:53,160 --> 00:00:55,320
so uh the main part of this presentation

19
00:00:55,320 --> 00:00:58,440
is a deep dive into an exploit uh we

20
00:00:58,440 --> 00:01:01,260
found as part of a food chain uh and

21
00:01:01,260 --> 00:01:03,539
xingyu will guide us through this

22
00:01:03,539 --> 00:01:05,040
um but before that I'll give you some

23
00:01:05,040 --> 00:01:08,040
background on what tagged us and some

24
00:01:08,040 --> 00:01:10,680
examples of these full chains

25
00:01:10,680 --> 00:01:12,960
and after that uh Richard will go

26
00:01:12,960 --> 00:01:14,100
through some post exploitation

27
00:01:14,100 --> 00:01:16,799
techniques uh an exploit we found in the

28
00:01:16,799 --> 00:01:19,860
Play Store and a bit about defending

29
00:01:19,860 --> 00:01:24,380
Android before we wrap up the conclusion

30
00:01:25,140 --> 00:01:27,720
all right so Google's threat analysis

31
00:01:27,720 --> 00:01:30,240
group or tag for sure

32
00:01:30,240 --> 00:01:33,060
um our goal is to protect Google and our

33
00:01:33,060 --> 00:01:35,520
users and one way that we're doing this

34
00:01:35,520 --> 00:01:37,619
is that we're routinely hunting for zero

35
00:01:37,619 --> 00:01:40,560
days exploited in the wild and as you

36
00:01:40,560 --> 00:01:42,659
can see on your right hand side

37
00:01:42,659 --> 00:01:46,200
um back in 2019 we reported seven zero

38
00:01:46,200 --> 00:01:49,140
days found in the wild uh five in 2020

39
00:01:49,140 --> 00:01:51,899
10 in 2021 so it was a pretty good year

40
00:01:51,899 --> 00:01:55,259
for us and so far in 2022 we reported

41
00:01:55,259 --> 00:01:56,939
three zero days that we found in the

42
00:01:56,939 --> 00:01:58,560
wild

43
00:01:58,560 --> 00:02:00,899
and to discover these series

44
00:02:00,899 --> 00:02:02,520
um what we're doing is that or one thing

45
00:02:02,520 --> 00:02:04,500
we're doing is that we're tracking more

46
00:02:04,500 --> 00:02:05,759
than 30 different commercial

47
00:02:05,759 --> 00:02:08,399
surveillance vendor so any company that

48
00:02:08,399 --> 00:02:09,660
provides

49
00:02:09,660 --> 00:02:12,120
um exploits or implants or other

50
00:02:12,120 --> 00:02:16,520
offensive services to its customers

51
00:02:16,680 --> 00:02:18,480
um yeah and as I mentioned there's like

52
00:02:18,480 --> 00:02:21,239
we're tracking more than 30. so like we

53
00:02:21,239 --> 00:02:23,040
often see just a handful of companies

54
00:02:23,040 --> 00:02:25,140
mentioned in the media but that's just

55
00:02:25,140 --> 00:02:26,940
the tip of the iceberg and this is a

56
00:02:26,940 --> 00:02:28,500
very thriving industry with a lot of

57
00:02:28,500 --> 00:02:31,379
different companies involved

58
00:02:31,379 --> 00:02:33,060
and one interesting thing that we've

59
00:02:33,060 --> 00:02:35,400
seen is that some of these groups are

60
00:02:35,400 --> 00:02:37,620
actually sharing or selling exploits

61
00:02:37,620 --> 00:02:40,080
between each other so there was one case

62
00:02:40,080 --> 00:02:42,800
uh we had a chrome intense logic floor

63
00:02:42,800 --> 00:02:45,959
uh back in I think it was 2021 that we

64
00:02:45,959 --> 00:02:47,640
saw several groups using the same

65
00:02:47,640 --> 00:02:50,580
exploit so there's also some form of

66
00:02:50,580 --> 00:02:53,220
cooperation going on here

67
00:02:53,220 --> 00:02:54,900
all right and next up I'll talk about

68
00:02:54,900 --> 00:02:56,760
two Android full chains that we

69
00:02:56,760 --> 00:03:00,720
discovered in 2021 so these are two full

70
00:03:00,720 --> 00:03:02,519
chains from two different surveillance

71
00:03:02,519 --> 00:03:04,940
vendors

72
00:03:05,760 --> 00:03:07,680
and the first one

73
00:03:07,680 --> 00:03:10,319
um this was discovered by us in October

74
00:03:10,319 --> 00:03:12,840
2021 uh and it was served to an

75
00:03:12,840 --> 00:03:15,540
up-to-date Android device at the time uh

76
00:03:15,540 --> 00:03:16,739
and they were exploiting two

77
00:03:16,739 --> 00:03:18,599
vulnerabilities uh one of them was a

78
00:03:18,599 --> 00:03:21,000
zero day in Chrome to get execution in

79
00:03:21,000 --> 00:03:23,159
Chrome's rendering process which is

80
00:03:23,159 --> 00:03:25,440
heavily sandboxed and from there they

81
00:03:25,440 --> 00:03:27,720
need to escape the samox and they were

82
00:03:27,720 --> 00:03:29,700
exploiting an e-pol reference counting

83
00:03:29,700 --> 00:03:32,580
vulnerability in the Linux kernel

84
00:03:32,580 --> 00:03:34,319
and what's interesting about this

85
00:03:34,319 --> 00:03:35,879
vulnerability is that it was actually

86
00:03:35,879 --> 00:03:39,300
quickly fixed in the Upstream kernel so

87
00:03:39,300 --> 00:03:42,360
they introduced the patch like or the

88
00:03:42,360 --> 00:03:44,400
bug with one patch and then it was fixed

89
00:03:44,400 --> 00:03:45,840
like I think it was a week later so

90
00:03:45,840 --> 00:03:47,819
pretty quickly but unfortunately in

91
00:03:47,819 --> 00:03:49,739
Android only the first patch was picked

92
00:03:49,739 --> 00:03:52,500
up so it left Android vulnerable for

93
00:03:52,500 --> 00:03:54,720
about a year I think

94
00:03:54,720 --> 00:03:56,640
and unfortunately it's not the first

95
00:03:56,640 --> 00:03:58,980
time this has happened this was also the

96
00:03:58,980 --> 00:04:00,720
case for another runability known as bad

97
00:04:00,720 --> 00:04:04,019
binder which has been yeah documented a

98
00:04:04,019 --> 00:04:05,340
lot publicly

99
00:04:05,340 --> 00:04:07,260
and this was also quickly fixed in the

100
00:04:07,260 --> 00:04:09,060
Upstream kernel but took a while to

101
00:04:09,060 --> 00:04:11,159
reach Android

102
00:04:11,159 --> 00:04:12,720
yep

103
00:04:12,720 --> 00:04:14,040
um so one thing that was interesting

104
00:04:14,040 --> 00:04:15,360
with this

105
00:04:15,360 --> 00:04:18,120
um full chain uh in the sandbox Escape

106
00:04:18,120 --> 00:04:20,399
Park so when they were exploiting this

107
00:04:20,399 --> 00:04:22,019
EPO reference counting vulnerability

108
00:04:22,019 --> 00:04:23,639
they had a pretty interesting

109
00:04:23,639 --> 00:04:25,620
exploitation technique that I just

110
00:04:25,620 --> 00:04:27,000
wanted to mention because yeah I thought

111
00:04:27,000 --> 00:04:28,620
it was cool and I don't think I've ever

112
00:04:28,620 --> 00:04:31,380
seen this documented before so yeah

113
00:04:31,380 --> 00:04:33,840
so this vulnerability uh gives an

114
00:04:33,840 --> 00:04:36,180
attacker the ability to free a file

115
00:04:36,180 --> 00:04:39,060
structure in the Linux kernel uh while

116
00:04:39,060 --> 00:04:40,500
you still have a reference to it from

117
00:04:40,500 --> 00:04:43,560
userspace as a file descriptor so you

118
00:04:43,560 --> 00:04:45,419
have a pretty classic use after free

119
00:04:45,419 --> 00:04:47,100
scenario

120
00:04:47,100 --> 00:04:50,040
um and the goal of this exploitation

121
00:04:50,040 --> 00:04:51,840
technique which is just a part of the

122
00:04:51,840 --> 00:04:53,639
exploit it's not like the full exploit

123
00:04:53,639 --> 00:04:56,160
but the way that the surveillance vendor

124
00:04:56,160 --> 00:04:58,380
chose to exploit the vulnerability

125
00:04:58,380 --> 00:05:02,280
uh is to get Riot access to codes and

126
00:05:02,280 --> 00:05:04,080
what they're doing here is that they're

127
00:05:04,080 --> 00:05:07,320
getting right access to lib C and these

128
00:05:07,320 --> 00:05:09,120
changes when they're writing to lib c

129
00:05:09,120 --> 00:05:11,340
will be mirrored into every process on

130
00:05:11,340 --> 00:05:14,000
the system so effectively this gives you

131
00:05:14,000 --> 00:05:17,100
by exploiting this you get code

132
00:05:17,100 --> 00:05:19,440
execution every process that uses slip C

133
00:05:19,440 --> 00:05:22,280
which is everything

134
00:05:22,440 --> 00:05:24,960
and the steps uh the first step is you

135
00:05:24,960 --> 00:05:27,060
map lib C which is your target using a

136
00:05:27,060 --> 00:05:29,460
map and then you create some file

137
00:05:29,460 --> 00:05:30,780
descriptor that you can trigger this

138
00:05:30,780 --> 00:05:33,479
vulnerability on

139
00:05:33,479 --> 00:05:34,919
and

140
00:05:34,919 --> 00:05:35,580
um

141
00:05:35,580 --> 00:05:39,419
yeah so I've uh in the original code I

142
00:05:39,419 --> 00:05:41,280
mean there was a huge bug trigger but I

143
00:05:41,280 --> 00:05:42,960
replaced this with f put which is the

144
00:05:42,960 --> 00:05:45,300
kernel API for freeing file structures

145
00:05:45,300 --> 00:05:48,060
so just to kind of distill it into one

146
00:05:48,060 --> 00:05:51,060
slide so it's easier to see but yeah so

147
00:05:51,060 --> 00:05:52,440
the next step is like you triggered a

148
00:05:52,440 --> 00:05:54,300
bug so now you have a file descriptor

149
00:05:54,300 --> 00:05:55,740
that points to a freed file in the

150
00:05:55,740 --> 00:05:56,820
kernel

151
00:05:56,820 --> 00:05:59,880
and you quickly replace it by creating

152
00:05:59,880 --> 00:06:02,699
an MFD which will occupy the last read

153
00:06:02,699 --> 00:06:04,320
file structure

154
00:06:04,320 --> 00:06:06,060
and then you map this as readable and

155
00:06:06,060 --> 00:06:08,479
writable

156
00:06:08,940 --> 00:06:11,639
and now uh we want to free this yet

157
00:06:11,639 --> 00:06:13,740
again so

158
00:06:13,740 --> 00:06:15,780
since we replaced this previous file

159
00:06:15,780 --> 00:06:18,060
structure by creating another file both

160
00:06:18,060 --> 00:06:20,220
of these file descriptors in user space

161
00:06:20,220 --> 00:06:21,960
actually points to the same file

162
00:06:21,960 --> 00:06:24,780
structure in the kernel so by closing

163
00:06:24,780 --> 00:06:27,479
this twice we can free the file

164
00:06:27,479 --> 00:06:28,620
structure again

165
00:06:28,620 --> 00:06:30,360
and the reason why I have to do it twice

166
00:06:30,360 --> 00:06:32,880
is because the Linux kernel has two

167
00:06:32,880 --> 00:06:36,419
references to this file one by creating

168
00:06:36,419 --> 00:06:40,440
the MFD and one by doing the M map

169
00:06:40,440 --> 00:06:43,259
so if we and yet again we replace it

170
00:06:43,259 --> 00:06:45,120
so now this

171
00:06:45,120 --> 00:06:48,240
um memfd shared memory mapping it has a

172
00:06:48,240 --> 00:06:50,639
reference to the previous file which you

173
00:06:50,639 --> 00:06:52,319
know should be like a shared mem file

174
00:06:52,319 --> 00:06:56,520
but now it's actually lib C again

175
00:06:56,520 --> 00:06:58,979
and this is like the juicy part of the

176
00:06:58,979 --> 00:07:00,780
exploit technique what they're doing is

177
00:07:00,780 --> 00:07:03,900
looping through every page in libsy so

178
00:07:03,900 --> 00:07:05,819
you don't have this Loop looping through

179
00:07:05,819 --> 00:07:07,560
every single page and you touch the

180
00:07:07,560 --> 00:07:10,500
start of a page this makes sure that the

181
00:07:10,500 --> 00:07:13,080
kernel will load the pages into memory

182
00:07:13,080 --> 00:07:15,300
from this

183
00:07:15,300 --> 00:07:16,740
um but the interesting part is when you

184
00:07:16,740 --> 00:07:18,240
do this for the readable and writable

185
00:07:18,240 --> 00:07:19,919
mapping the Linux kernel like the page

186
00:07:19,919 --> 00:07:22,440
full Handler will look up the file

187
00:07:22,440 --> 00:07:24,539
that's associated with this memory

188
00:07:24,539 --> 00:07:25,680
mapping

189
00:07:25,680 --> 00:07:28,560
which now is actually lib C and since we

190
00:07:28,560 --> 00:07:30,780
just folded in all the pages the kernel

191
00:07:30,780 --> 00:07:33,300
is happy and we get lib C pages into our

192
00:07:33,300 --> 00:07:36,000
readable and writable memory mapping

193
00:07:36,000 --> 00:07:38,520
which we can then overwrite and this

194
00:07:38,520 --> 00:07:40,800
will be reflected in every process

195
00:07:40,800 --> 00:07:42,840
and this particular surveillance vendor

196
00:07:42,840 --> 00:07:46,380
used this to inject a shell code into

197
00:07:46,380 --> 00:07:48,060
certain system calls that would then

198
00:07:48,060 --> 00:07:50,160
load an implant if it was running in the

199
00:07:50,160 --> 00:07:52,819
correct process

200
00:07:53,220 --> 00:07:54,479
yeah

201
00:07:54,479 --> 00:07:56,220
that was the first full chain so the

202
00:07:56,220 --> 00:07:57,900
second one this is directly related to

203
00:07:57,900 --> 00:08:00,060
the exploit that xinyu and Richard will

204
00:08:00,060 --> 00:08:01,380
talk about

205
00:08:01,380 --> 00:08:04,080
um and this surveillance vendor was

206
00:08:04,080 --> 00:08:05,639
using quite a it was a bit different

207
00:08:05,639 --> 00:08:06,780
strategy

208
00:08:06,780 --> 00:08:08,880
so instead of using zero days against

209
00:08:08,880 --> 00:08:11,099
Chrome they were actually targeting a

210
00:08:11,099 --> 00:08:13,440
chrome based browser that was lagging

211
00:08:13,440 --> 00:08:16,740
behind Chrome in patches

212
00:08:16,740 --> 00:08:18,780
so they could use

213
00:08:18,780 --> 00:08:21,780
um end days against these browsers as it

214
00:08:21,780 --> 00:08:23,699
was a zero day basically

215
00:08:23,699 --> 00:08:26,160
and depending on the version of the

216
00:08:26,160 --> 00:08:27,539
browser they have three different bugs

217
00:08:27,539 --> 00:08:29,280
that they would bundle uh with their

218
00:08:29,280 --> 00:08:30,660
exploit

219
00:08:30,660 --> 00:08:32,760
and for the samples Escape part to

220
00:08:32,760 --> 00:08:35,159
escape from chrome uh in some cases they

221
00:08:35,159 --> 00:08:36,779
were using the bad binder vulnerability

222
00:08:36,779 --> 00:08:38,399
that I mentioned earlier

223
00:08:38,399 --> 00:08:40,200
but in other cases they were actually

224
00:08:40,200 --> 00:08:42,958
using a zero day and you'll hear more

225
00:08:42,958 --> 00:08:46,140
about this bug very soon

226
00:08:46,140 --> 00:08:48,000
but first let me take you through the

227
00:08:48,000 --> 00:08:50,120
kind of timeline how does it look like

228
00:08:50,120 --> 00:08:53,580
for a user that's targeted by this

229
00:08:53,580 --> 00:08:56,279
so the first thing that happens is the

230
00:08:56,279 --> 00:08:58,440
user receives a one-time link

231
00:08:58,440 --> 00:09:01,320
and they click it

232
00:09:01,320 --> 00:09:02,700
and when they click it they're

233
00:09:02,700 --> 00:09:05,399
redirected to an exploit server uh and

234
00:09:05,399 --> 00:09:06,899
the job of this exploit server is to

235
00:09:06,899 --> 00:09:09,180
fingerprint the device and serve the

236
00:09:09,180 --> 00:09:10,920
correct exploit depending on browser

237
00:09:10,920 --> 00:09:14,519
versions OS version and so on

238
00:09:14,519 --> 00:09:17,640
and in both of these cases for the uh

239
00:09:17,640 --> 00:09:20,700
for the surveillance vendors they were

240
00:09:20,700 --> 00:09:22,740
targeting Chrome so they have some sort

241
00:09:22,740 --> 00:09:24,660
of chrome exploit that gets code

242
00:09:24,660 --> 00:09:27,480
execution in Chrome's rendering process

243
00:09:27,480 --> 00:09:29,880
and from there at least at the time of

244
00:09:29,880 --> 00:09:31,620
uh when we discovered this vulnerability

245
00:09:31,620 --> 00:09:33,200
I'm not sure if it's the same anymore

246
00:09:33,200 --> 00:09:35,820
but they were abusing Chrome's

247
00:09:35,820 --> 00:09:38,399
webassembly code mappings because they

248
00:09:38,399 --> 00:09:40,740
used to be readable writable executable

249
00:09:40,740 --> 00:09:44,040
so they put some Shell Code and elf

250
00:09:44,040 --> 00:09:47,519
loader yeah and they're explaining there

251
00:09:47,519 --> 00:09:51,180
and by jumping to this elf loader they

252
00:09:51,180 --> 00:09:52,980
load a local privilege escalation

253
00:09:52,980 --> 00:09:54,180
exploits

254
00:09:54,180 --> 00:09:56,279
and with that I'll hand it over to

255
00:09:56,279 --> 00:09:58,140
shinyu

256
00:09:58,140 --> 00:09:59,839
there we go

257
00:09:59,839 --> 00:10:02,100
thank you Christian

258
00:10:02,100 --> 00:10:05,279
so uh we're gonna do a div dive to the

259
00:10:05,279 --> 00:10:07,620
zero day we captured and it's also fixed

260
00:10:07,620 --> 00:10:11,640
in the last November it's a CV 2021 0920

261
00:10:11,640 --> 00:10:13,800
so it's the most probably the most

262
00:10:13,800 --> 00:10:16,500
complicated Android uh kernels exploit

263
00:10:16,500 --> 00:10:18,480
last year and it could also be one of

264
00:10:18,480 --> 00:10:21,180
the most convoluted exploit in across

265
00:10:21,180 --> 00:10:22,680
the newest kind of History

266
00:10:22,680 --> 00:10:25,380
in terms of this uh broadcast analysis

267
00:10:25,380 --> 00:10:27,660
and exploitation techniques so basically

268
00:10:27,660 --> 00:10:29,820
we capture two major versions of

269
00:10:29,820 --> 00:10:32,339
exploits so the expiration version a

270
00:10:32,339 --> 00:10:35,580
targeted at recent early devices and

271
00:10:35,580 --> 00:10:38,760
expert B Target our recent devices so

272
00:10:38,760 --> 00:10:41,160
everything starting at a very simple

273
00:10:41,160 --> 00:10:43,560
kind of features that users can send

274
00:10:43,560 --> 00:10:46,140
fight this graders to other process by

275
00:10:46,140 --> 00:10:48,060
something called SCM let's call it right

276
00:10:48,060 --> 00:10:51,300
datagram by send message Cisco so let's

277
00:10:51,300 --> 00:10:53,640
say I am a socket fight in square a and

278
00:10:53,640 --> 00:10:56,399
I send a cell to a 5D square B so what

279
00:10:56,399 --> 00:10:58,200
happens in kernel is that first of all

280
00:10:58,200 --> 00:11:00,480
kernel Atticus structure called SK

281
00:11:00,480 --> 00:11:03,600
underscore buff or socket buffer or AKA

282
00:11:03,600 --> 00:11:07,800
as SKB at attend the circuit buffer to

283
00:11:07,800 --> 00:11:10,079
the receiver queue and as you can see

284
00:11:10,079 --> 00:11:12,240
there's one field in the socket buffer

285
00:11:12,240 --> 00:11:14,399
point to another newly allocated

286
00:11:14,399 --> 00:11:17,940
structure called Sam underscore list and

287
00:11:17,940 --> 00:11:20,579
it contains an Aries of file Founders

288
00:11:20,579 --> 00:11:23,220
that point to the file in the flight so

289
00:11:23,220 --> 00:11:25,140
from our receiver point of view it

290
00:11:25,140 --> 00:11:26,880
received the message so the socket

291
00:11:26,880 --> 00:11:28,500
platform is removed from the receiver

292
00:11:28,500 --> 00:11:31,079
queue and get free and kernel will

293
00:11:31,079 --> 00:11:33,720
install another file disclosure C in

294
00:11:33,720 --> 00:11:36,660
terms of the 5A so as you can see the 5A

295
00:11:36,660 --> 00:11:39,899
now has two reference count okay so

296
00:11:39,899 --> 00:11:42,420
however let's consider the following

297
00:11:42,420 --> 00:11:45,060
scenario like I am despite this group a

298
00:11:45,060 --> 00:11:47,880
I send a cell to B and B Center cell 2A

299
00:11:47,880 --> 00:11:49,980
and then what happens in the user space

300
00:11:49,980 --> 00:11:52,620
is that uses space cross A and B so

301
00:11:52,620 --> 00:11:54,360
there's no way for the kernel to

302
00:11:54,360 --> 00:11:56,459
destruct file A and B because they still

303
00:11:56,459 --> 00:11:58,800
have a reference count but there's no

304
00:11:58,800 --> 00:12:00,300
way for the user Space Program to

305
00:12:00,300 --> 00:12:02,579
calculus again because five Distributors

306
00:12:02,579 --> 00:12:04,620
are already removed from kind of

307
00:12:04,620 --> 00:12:07,500
descriptive table so that's why we need

308
00:12:07,500 --> 00:12:10,200
a guard reflector in the Linux kernel so

309
00:12:10,200 --> 00:12:12,540
for example every time you you call

310
00:12:12,540 --> 00:12:14,459
close this car it may trigger W

311
00:12:14,459 --> 00:12:16,500
collection system and the way to

312
00:12:16,500 --> 00:12:18,720
identify potential garbage is to

313
00:12:18,720 --> 00:12:20,339
implement something called in Flight

314
00:12:20,339 --> 00:12:22,680
count so what does inflightcom means is

315
00:12:22,680 --> 00:12:25,380
is pretty simple is that you know if

316
00:12:25,380 --> 00:12:27,180
there's a file in the flight then we

317
00:12:27,180 --> 00:12:29,040
just increment the reference in Flight

318
00:12:29,040 --> 00:12:31,560
comes so as you can see the Ace in front

319
00:12:31,560 --> 00:12:34,079
count is one because a is in the fly so

320
00:12:34,079 --> 00:12:36,300
similarly it based in flight card is

321
00:12:36,300 --> 00:12:39,120
sort of one so as you can see the

322
00:12:39,120 --> 00:12:41,760
replica here equals to the infrared

323
00:12:41,760 --> 00:12:43,500
count so it could be a good sign of

324
00:12:43,500 --> 00:12:45,540
potential garbage but it is not always

325
00:12:45,540 --> 00:12:48,779
the case if we consider this cycle like

326
00:12:48,779 --> 00:12:52,019
a center b b send itself to alpha alpha

327
00:12:52,019 --> 00:12:54,480
centers out to 3 and b Center a

328
00:12:54,480 --> 00:12:57,360
so if you're the Space Program close A

329
00:12:57,360 --> 00:12:59,700
and B what happens here is that the Run

330
00:12:59,700 --> 00:13:01,380
Ace reference count equals to the inside

331
00:13:01,380 --> 00:13:04,380
count and B's infinite account equals to

332
00:13:04,380 --> 00:13:06,779
the reference count so A and B are

333
00:13:06,779 --> 00:13:08,940
considered as potential garbage but they

334
00:13:08,940 --> 00:13:10,980
are not actually garbage because we can

335
00:13:10,980 --> 00:13:13,620
guide 5D square B from 5 Discord Alpha

336
00:13:13,620 --> 00:13:15,959
and we can get 5 display a from the 5D

337
00:13:15,959 --> 00:13:18,120
is great to be so for our coverage

338
00:13:18,120 --> 00:13:20,399
collector point of view is that first of

339
00:13:20,399 --> 00:13:22,440
all A and B are considered as potential

340
00:13:22,440 --> 00:13:25,139
garbage so A and B are put into Global

341
00:13:25,139 --> 00:13:28,200
list called GC underscore candidates

342
00:13:28,200 --> 00:13:31,260
and then what kind of does is to scan

343
00:13:31,260 --> 00:13:33,839
the inflight for the GC candidate so

344
00:13:33,839 --> 00:13:36,660
let's say the criminal scans a first so

345
00:13:36,660 --> 00:13:39,300
it will check a receiver queue

346
00:13:39,300 --> 00:13:42,779
okay so a is the reciprocal Q is B and

347
00:13:42,779 --> 00:13:45,420
because B is also in the GC candidates

348
00:13:45,420 --> 00:13:47,760
what kind of what does is to decrement

349
00:13:47,760 --> 00:13:50,279
these inflate columns so this infrared

350
00:13:50,279 --> 00:13:53,339
count is decremented from two to one and

351
00:13:53,339 --> 00:13:55,500
similarly Ace infinite count is also

352
00:13:55,500 --> 00:13:58,560
document to zero however as a result

353
00:13:58,560 --> 00:14:00,540
because this infrared account is still

354
00:14:00,540 --> 00:14:03,779
above zero so B is not considered as a

355
00:14:03,779 --> 00:14:05,760
garbage what kind of will do is to

356
00:14:05,760 --> 00:14:08,459
recursely restore info account so this

357
00:14:08,459 --> 00:14:10,620
info account will be restored to two and

358
00:14:10,620 --> 00:14:12,720
Ace infant color will be restored from 0

359
00:14:12,720 --> 00:14:15,839
to 1 and no one is considered as garbage

360
00:14:15,839 --> 00:14:19,380
so however if you consider the the

361
00:14:19,380 --> 00:14:22,740
formation on breakout cycle A and B are

362
00:14:22,740 --> 00:14:25,139
considered as potential coverage so they

363
00:14:25,139 --> 00:14:27,360
are put into the GC candidates and

364
00:14:27,360 --> 00:14:29,880
scanning flag process will lead to the

365
00:14:29,880 --> 00:14:32,339
foreign result that A and B's inflatcom

366
00:14:32,339 --> 00:14:34,680
are both zero so all of them are

367
00:14:34,680 --> 00:14:36,720
considered as garbage so the final step

368
00:14:36,720 --> 00:14:38,459
for the kernel is to improve this

369
00:14:38,459 --> 00:14:41,100
garbage is by remove and free the socket

370
00:14:41,100 --> 00:14:44,040
buffer and then digital 5 in and P

371
00:14:44,040 --> 00:14:47,399
so we also have two ways to cause

372
00:14:47,399 --> 00:14:49,500
receive message so if we call receive

373
00:14:49,500 --> 00:14:51,420
messages call without massive Peak flag

374
00:14:51,420 --> 00:14:53,820
first of all it will synchronize with GC

375
00:14:53,820 --> 00:14:56,040
which means that kernel will install a

376
00:14:56,040 --> 00:14:58,500
new fight distribution artwork before

377
00:14:58,500 --> 00:15:00,660
did she say finish so what happens in

378
00:15:00,660 --> 00:15:03,300
kernel is that the receiver will remove

379
00:15:03,300 --> 00:15:05,639
and free the socket buffers and install

380
00:15:05,639 --> 00:15:09,180
another file distributor however if we

381
00:15:09,180 --> 00:15:11,279
call receive message with massive Peak

382
00:15:11,279 --> 00:15:14,279
flag it doesn't synchronize with GC it

383
00:15:14,279 --> 00:15:16,079
means that we can have one third cause

384
00:15:16,079 --> 00:15:17,820
received message with message Peak flag

385
00:15:17,820 --> 00:15:19,860
while there's another thread doing the

386
00:15:19,860 --> 00:15:22,980
GC in the meantime and also from

387
00:15:22,980 --> 00:15:25,620
receiver point of view it will not

388
00:15:25,620 --> 00:15:28,620
remove the socket buffer so and and

389
00:15:28,620 --> 00:15:30,660
kernel will still install another file

390
00:15:30,660 --> 00:15:33,420
description so you can see and the a

391
00:15:33,420 --> 00:15:35,699
reference column can get elevated

392
00:15:35,699 --> 00:15:38,880
okay so now we really want to introduce

393
00:15:38,880 --> 00:15:40,560
the vulnerability scenario so like I

394
00:15:40,560 --> 00:15:44,100
said the issue here is that the recently

395
00:15:44,100 --> 00:15:45,720
message with massive big flag doesn't

396
00:15:45,720 --> 00:15:48,120
synchronize with GC so there will be one

397
00:15:48,120 --> 00:15:50,399
file and the reference can't get

398
00:15:50,399 --> 00:15:51,540
elevated

399
00:15:51,540 --> 00:15:53,279
however you know this kind of

400
00:15:53,279 --> 00:15:55,440
vulnerability is difficult to trigger

401
00:15:55,440 --> 00:15:56,880
because you know most of the time you

402
00:15:56,880 --> 00:15:58,740
heard about is like hey the file

403
00:15:58,740 --> 00:16:00,540
reference can't get decremented by

404
00:16:00,540 --> 00:16:03,420
accident so how to do how to get a

405
00:16:03,420 --> 00:16:05,880
user-free by elevator file files

406
00:16:05,880 --> 00:16:08,880
reference count however it's very

407
00:16:08,880 --> 00:16:11,459
complicated and unfortunately we are not

408
00:16:11,459 --> 00:16:13,620
going to go through details here but we

409
00:16:13,620 --> 00:16:15,839
will illustrate call Ideal

410
00:16:15,839 --> 00:16:18,720
um so you know the color here that I

411
00:16:18,720 --> 00:16:20,160
received message zip code doesn't

412
00:16:20,160 --> 00:16:22,199
synchronize with uh with massive pink

413
00:16:22,199 --> 00:16:24,540
product and simplified with GC so if we

414
00:16:24,540 --> 00:16:27,180
at least we are very very uh complex and

415
00:16:27,180 --> 00:16:29,220
consistent GC State and various subtle

416
00:16:29,220 --> 00:16:31,320
risk conditions here uh when it leads to

417
00:16:31,320 --> 00:16:33,300
a result in a user-free in the socket

418
00:16:33,300 --> 00:16:36,839
buffer so uh you know we have to create

419
00:16:36,839 --> 00:16:39,240
three main threads one thread does GC

420
00:16:39,240 --> 00:16:42,180
and two or two tasks cause risky message

421
00:16:42,180 --> 00:16:44,160
with some good results massive Peak flag

422
00:16:44,160 --> 00:16:46,800
and through a very comfortable coaches

423
00:16:46,800 --> 00:16:49,199
are one of the receiver will receive a

424
00:16:49,199 --> 00:16:51,240
user-friendly socket buffer object so

425
00:16:51,240 --> 00:16:53,220
the patch here is actually pretty simple

426
00:16:53,220 --> 00:16:55,139
you know it's just called spin long it's

427
00:16:55,139 --> 00:16:57,000
being all in two lines to make sure like

428
00:16:57,000 --> 00:16:58,920
uh the best it picks the top will

429
00:16:58,920 --> 00:17:01,500
install a fighter skirt before GC have

430
00:17:01,500 --> 00:17:02,639
completes

431
00:17:02,639 --> 00:17:04,859
and interestingly the current bug was

432
00:17:04,859 --> 00:17:07,740
found in 2016 and you can see you can

433
00:17:07,740 --> 00:17:10,919
check this email address because there's

434
00:17:10,919 --> 00:17:12,919
a public Linux kind of email address

435
00:17:12,919 --> 00:17:15,540
unfortunately the patch was not accepted

436
00:17:15,540 --> 00:17:18,720
so that means any Bad actors see the

437
00:17:18,720 --> 00:17:20,579
ones kind of email thread may come up

438
00:17:20,579 --> 00:17:22,500
with an exploit against the Linux and

439
00:17:22,500 --> 00:17:25,799
Android users okay so now let's take a

440
00:17:25,799 --> 00:17:28,860
look at how of the Explorer a does so A

441
00:17:28,860 --> 00:17:31,860
is for the old devices so first of all

442
00:17:31,860 --> 00:17:33,299
you know there will be a lot of thread

443
00:17:33,299 --> 00:17:35,880
in living and the way to win the risk

444
00:17:35,880 --> 00:17:37,559
condition with higher chance is to

445
00:17:37,559 --> 00:17:39,360
generate as much coverage as possible

446
00:17:39,360 --> 00:17:41,100
and it's also a good sign for detection

447
00:17:41,100 --> 00:17:43,620
and in reality there will be really a

448
00:17:43,620 --> 00:17:45,419
lot to us including each other sometimes

449
00:17:45,419 --> 00:17:47,820
for history some threads for fixing the

450
00:17:47,820 --> 00:17:50,460
kernel structure for for backgrounds and

451
00:17:50,460 --> 00:17:52,320
there will be also a lot a lot of

452
00:17:52,320 --> 00:17:54,900
threads to impact on schedulers and

453
00:17:54,900 --> 00:17:56,880
through very very cool choices there

454
00:17:56,880 --> 00:17:58,919
will be very small chance that you will

455
00:17:58,919 --> 00:18:00,600
have a useful object and also get

456
00:18:00,600 --> 00:18:02,580
history so that's why the X-ray tries

457
00:18:02,580 --> 00:18:05,940
250 times for getting a free soccer park

458
00:18:05,940 --> 00:18:08,940
object and also spray on the circuit

459
00:18:08,940 --> 00:18:10,919
buffer object is not it's not easy

460
00:18:10,919 --> 00:18:12,720
because circuit buffer object is

461
00:18:12,720 --> 00:18:15,419
allocated from our separate cache

462
00:18:15,419 --> 00:18:17,640
so that means the conventional ships to

463
00:18:17,640 --> 00:18:20,160
the technique doesn't work but there is

464
00:18:20,160 --> 00:18:22,380
something called cross-catching pad is

465
00:18:22,380 --> 00:18:24,240
that you know if we can free all the

466
00:18:24,240 --> 00:18:26,640
circuit buffer object in The Sims lab

467
00:18:26,640 --> 00:18:29,220
page and freeze so the page may have the

468
00:18:29,220 --> 00:18:30,600
chance to be returned to the page

469
00:18:30,600 --> 00:18:33,419
allocator that might be used by other

470
00:18:33,419 --> 00:18:36,000
cache that could be impacted by the

471
00:18:36,000 --> 00:18:37,620
normal confessional history technique

472
00:18:37,620 --> 00:18:40,320
but the chance is very small and now

473
00:18:40,320 --> 00:18:43,320
assume we can spray the SKB and we can

474
00:18:43,320 --> 00:18:45,419
control that SKB data what happens here

475
00:18:45,419 --> 00:18:47,160
in kernel inter if we call the receive

476
00:18:47,160 --> 00:18:50,160
message Cisco kernel will copy address

477
00:18:50,160 --> 00:18:53,100
from SKB data back to user space so now

478
00:18:53,100 --> 00:18:55,500
the question here is that I have no

479
00:18:55,500 --> 00:18:57,419
information disclosure what address I

480
00:18:57,419 --> 00:18:59,700
should read so for the actual sample a

481
00:18:59,700 --> 00:19:01,559
it's very interesting because it reads

482
00:19:01,559 --> 00:19:04,500
our physical address and it is the page

483
00:19:04,500 --> 00:19:07,640
size data calculated md5 hash value

484
00:19:07,640 --> 00:19:11,520
comparing with a hash table with 512

485
00:19:11,520 --> 00:19:15,059
values so you can calculate the kind of

486
00:19:15,059 --> 00:19:19,160
base of the that so why does it actually

487
00:19:19,160 --> 00:19:23,100
reads our fixed and address so we

488
00:19:23,100 --> 00:19:25,679
believe it's because OEM X invent is on

489
00:19:25,679 --> 00:19:27,299
things for current based realization

490
00:19:27,299 --> 00:19:29,280
before mainstream kernel and based on

491
00:19:29,280 --> 00:19:31,140
the exponent it only randomized nine

492
00:19:31,140 --> 00:19:33,539
base at 4K alignment so an attacker is

493
00:19:33,539 --> 00:19:35,580
due to excess of that it can address

494
00:19:35,580 --> 00:19:39,179
locally so by having a semi arbitrary

495
00:19:39,179 --> 00:19:42,000
they actually is able to iterate in the

496
00:19:42,000 --> 00:19:44,039
tasks and find the exact type structures

497
00:19:44,039 --> 00:19:46,559
from its one within chart process and

498
00:19:46,559 --> 00:19:48,840
get the address of the address damage so

499
00:19:48,840 --> 00:19:50,520
if you run your Android device which can

500
00:19:50,520 --> 00:19:52,200
use conversion lower than 4.14

501
00:19:52,200 --> 00:19:54,059
overwriting the address limit to like

502
00:19:54,059 --> 00:19:57,660
minus two where that and user users

503
00:19:57,660 --> 00:19:59,700
based program is able to write object

504
00:19:59,700 --> 00:20:00,840
kind of address

505
00:20:00,840 --> 00:20:04,320
so to get the arbitrary right perimeter

506
00:20:04,320 --> 00:20:06,240
they actually has some very rare things

507
00:20:06,240 --> 00:20:08,820
called kernel stagger for primitive and

508
00:20:08,820 --> 00:20:11,100
so basic idea here is that you know if

509
00:20:11,100 --> 00:20:13,260
user Space Program initialize something

510
00:20:13,260 --> 00:20:15,179
called Unix address and pass it to the

511
00:20:15,179 --> 00:20:17,460
kernel what kind of what does is to cast

512
00:20:17,460 --> 00:20:20,340
mem copy to copy the the name of around

513
00:20:20,340 --> 00:20:22,559
the user's address and as you can see

514
00:20:22,559 --> 00:20:25,140
the address here is from the SKB because

515
00:20:25,140 --> 00:20:28,980
we have control of SKB so presumably if

516
00:20:28,980 --> 00:20:32,039
we have the control of the SKB SK then

517
00:20:32,039 --> 00:20:35,100
we can craft a stack Overflow so if we

518
00:20:35,100 --> 00:20:37,500
have stock flow we can corrupt a lot of

519
00:20:37,500 --> 00:20:39,780
Stack variable from the above or three

520
00:20:39,780 --> 00:20:41,940
voltages underscore recent message so

521
00:20:41,940 --> 00:20:43,559
this is a bigger diagram and this is the

522
00:20:43,559 --> 00:20:45,900
affected area of the stack Overflow if

523
00:20:45,900 --> 00:20:50,039
we can control the SKB SK so the way to

524
00:20:50,039 --> 00:20:52,700
do so or bypass privilege access level

525
00:20:52,700 --> 00:20:55,919
is that the experts use in map Cisco and

526
00:20:55,919 --> 00:20:58,740
create a USB memory with mapshare

527
00:20:58,740 --> 00:21:00,780
property and because map sure property

528
00:21:00,780 --> 00:21:02,820
is not affected by the copyright

529
00:21:02,820 --> 00:21:04,919
mechanism so the first time reading

530
00:21:04,919 --> 00:21:07,440
memory will trigger the page fault so as

531
00:21:07,440 --> 00:21:09,299
a result the current way allocator Page

532
00:21:09,299 --> 00:21:13,140
and the expert is able to use its semi

533
00:21:13,140 --> 00:21:15,840
option real printer to find to dump the

534
00:21:15,840 --> 00:21:18,179
entire Corner stack and find the

535
00:21:18,179 --> 00:21:20,100
pointers or page pointers and use page

536
00:21:20,100 --> 00:21:22,559
to Verge macro to get a corresponding

537
00:21:22,559 --> 00:21:25,080
kernel address

538
00:21:25,080 --> 00:21:27,020
in other words

539
00:21:27,020 --> 00:21:30,080
the expert is able to you know get

540
00:21:30,080 --> 00:21:32,460
corresponding kernel address but the

541
00:21:32,460 --> 00:21:34,500
pressure the user-based memory and

542
00:21:34,500 --> 00:21:37,260
kernel space memory maps to the same

543
00:21:37,260 --> 00:21:39,840
Facebook pages and then you can craft

544
00:21:39,840 --> 00:21:42,360
all the fake kind of data structures

545
00:21:42,360 --> 00:21:44,940
from the user space memory and it Factor

546
00:21:44,940 --> 00:21:47,640
trigger the stack Overflow so once you

547
00:21:47,640 --> 00:21:50,220
do so and and Trigger stack flow here is

548
00:21:50,220 --> 00:21:52,559
what actually looks like so first of all

549
00:21:52,559 --> 00:21:55,679
there's one very critical stack variable

550
00:21:55,679 --> 00:21:58,200
called massive header get corrupted so

551
00:21:58,200 --> 00:22:00,539
every time when a receiver calls receive

552
00:22:00,539 --> 00:22:03,000
message the kernel will be tricked to

553
00:22:03,000 --> 00:22:05,940
use the corrupted method header and then

554
00:22:05,940 --> 00:22:07,919
we kind of believe that hey we are using

555
00:22:07,919 --> 00:22:09,780
the pipe data structure so you will look

556
00:22:09,780 --> 00:22:12,600
at the fake pipe data structure so the

557
00:22:12,600 --> 00:22:15,360
the right destination address here is it

558
00:22:15,360 --> 00:22:17,700
pointed to the touch structure and the

559
00:22:17,700 --> 00:22:20,280
source address now the point is SKB data

560
00:22:20,280 --> 00:22:22,860
and it just points to it points to your

561
00:22:22,860 --> 00:22:26,280
keyword which you feel with -2 so as a

562
00:22:26,280 --> 00:22:28,740
result if the receiver called receive

563
00:22:28,740 --> 00:22:31,679
message uh the fake pipe data structure

564
00:22:31,679 --> 00:22:33,720
will be utilized so the address limit

565
00:22:33,720 --> 00:22:36,360
will be over breathing against matters

566
00:22:36,360 --> 00:22:38,640
too so using space program can call

567
00:22:38,640 --> 00:22:41,580
option unit right primitive to do uh to

568
00:22:41,580 --> 00:22:44,280
get a room privilege okay so uh let's

569
00:22:44,280 --> 00:22:46,500
talk about expert sample B so actual

570
00:22:46,500 --> 00:22:48,780
sample B Target out a recent version so

571
00:22:48,780 --> 00:22:50,700
there will be no issues in implementing

572
00:22:50,700 --> 00:22:54,840
aslr okay so you know anytime what we

573
00:22:54,840 --> 00:22:57,720
have a user 360 buffer the SKB data will

574
00:22:57,720 --> 00:23:00,900
be free to and if like in the if I stand

575
00:23:00,900 --> 00:23:02,640
a fighting spirituality I learn the task

576
00:23:02,640 --> 00:23:04,080
the kernel will allocated structure

577
00:23:04,080 --> 00:23:06,659
called essay on FB list which contains

578
00:23:06,659 --> 00:23:08,640
an area of five pointer that point to

579
00:23:08,640 --> 00:23:11,400
the final flight okay so when the

580
00:23:11,400 --> 00:23:13,980
escaping part so when SKB gets user-free

581
00:23:13,980 --> 00:23:16,919
we can somehow to history to history on

582
00:23:16,919 --> 00:23:19,980
the SQL data to the newly allocated LCM

583
00:23:19,980 --> 00:23:23,580
activities so the strategy here is that

584
00:23:23,580 --> 00:23:26,039
the activate sample spans about 85

585
00:23:26,039 --> 00:23:28,020
Distributors for opening five a device

586
00:23:28,020 --> 00:23:30,900
new and then from the receiver side it

587
00:23:30,900 --> 00:23:34,020
will receive like 80 kernel file adjust

588
00:23:34,020 --> 00:23:36,360
so you know there will be several file

589
00:23:36,360 --> 00:23:38,700
structures occupying an entire slide

590
00:23:38,700 --> 00:23:39,539
page

591
00:23:39,539 --> 00:23:42,539
okay so if we close these five

592
00:23:42,539 --> 00:23:44,520
descriptors and do the history by

593
00:23:44,520 --> 00:23:47,100
sending socket datagram that means we

594
00:23:47,100 --> 00:23:49,860
can control the entire stack page

595
00:23:49,860 --> 00:23:52,200
and then we can craft the all kinds of

596
00:23:52,200 --> 00:23:54,659
fake pipe data structure here to this is

597
00:23:54,659 --> 00:23:56,580
the control stack page so the next

598
00:23:56,580 --> 00:23:58,500
question here is that how to link up

599
00:23:58,500 --> 00:24:00,840
with our normal file to this fake pack

600
00:24:00,840 --> 00:24:02,880
data structure so this is what the

601
00:24:02,880 --> 00:24:05,460
online Premiership came to rescue so

602
00:24:05,460 --> 00:24:07,679
well victim tells receive users free

603
00:24:07,679 --> 00:24:10,860
socket socket buffer it may invoke

604
00:24:10,860 --> 00:24:13,500
something called SV on link and by

605
00:24:13,500 --> 00:24:16,380
springing on the SKB and override the

606
00:24:16,380 --> 00:24:19,200
next and privilege to some uh malicious

607
00:24:19,200 --> 00:24:22,320
address then what happened in unlink is

608
00:24:22,320 --> 00:24:24,360
that the number file especially the

609
00:24:24,360 --> 00:24:27,539
private data get hijacked it to the

610
00:24:27,539 --> 00:24:30,419
controls that page address or to be more

611
00:24:30,419 --> 00:24:32,820
specific is the pipe in node info so the

612
00:24:32,820 --> 00:24:34,799
pipe in node info designate kernel that

613
00:24:34,799 --> 00:24:37,860
hey we have two following pipe buffers

614
00:24:37,860 --> 00:24:40,500
for arena right primitive and the next

615
00:24:40,500 --> 00:24:43,260
issue here is that Pi buffer offs is not

616
00:24:43,260 --> 00:24:45,299
initialized so we can now use this fake

617
00:24:45,299 --> 00:24:48,780
pipe structure now however initialize

618
00:24:48,780 --> 00:24:51,059
the pipe off is a type buffer off is

619
00:24:51,059 --> 00:24:53,640
very easy just write one byte to the pi

620
00:24:53,640 --> 00:24:55,260
so the color will initialize the up

621
00:24:55,260 --> 00:24:56,340
first

622
00:24:56,340 --> 00:24:59,159
and by reading the socket used to occupy

623
00:24:59,159 --> 00:25:01,320
the slab page we can link the entire

624
00:25:01,320 --> 00:25:03,720
slab page including the pi buffer a lot

625
00:25:03,720 --> 00:25:06,000
so we can effectively by pass the ASL

626
00:25:06,000 --> 00:25:08,820
and we may also do the something called

627
00:25:08,820 --> 00:25:11,700
type migration to bypass privileged

628
00:25:11,700 --> 00:25:15,840
access never so to sum up we by

629
00:25:15,840 --> 00:25:17,760
manipulating the type buffer page and

630
00:25:17,760 --> 00:25:20,039
type buffer offset we can achieve a

631
00:25:20,039 --> 00:25:22,380
kernel object in the right primitive and

632
00:25:22,380 --> 00:25:25,080
this is one more method to bypass the

633
00:25:25,080 --> 00:25:28,020
hardware level of mitigation user access

634
00:25:28,020 --> 00:25:31,440
override and we call it as Pi primitive

635
00:25:31,440 --> 00:25:34,500
and we see in the Y expert use this

636
00:25:34,500 --> 00:25:36,480
tricks into the alternative

637
00:25:36,480 --> 00:25:39,360
so since you have the option green right

638
00:25:39,360 --> 00:25:41,400
perimeter you can get code execution you

639
00:25:41,400 --> 00:25:42,900
can recover a kind of simple table

640
00:25:42,900 --> 00:25:45,779
address so for more information please

641
00:25:45,779 --> 00:25:47,580
stay turned on our project table guest

642
00:25:47,580 --> 00:25:49,559
blog now please welcome Richard for

643
00:25:49,559 --> 00:25:50,760
talking about post exploitation

644
00:25:50,760 --> 00:25:52,559
techniques thank you

645
00:25:52,559 --> 00:25:56,000
okay thank you

646
00:25:56,520 --> 00:25:59,220
so post exploitation

647
00:25:59,220 --> 00:26:01,320
um the attackers at this point have got

648
00:26:01,320 --> 00:26:04,020
a kernel read write so you might think

649
00:26:04,020 --> 00:26:06,720
the next step is the normal status SE

650
00:26:06,720 --> 00:26:09,299
Linux to permissive and overwrite the

651
00:26:09,299 --> 00:26:12,659
process credentials so you become uid 0.

652
00:26:12,659 --> 00:26:16,220
however in this case the target devices

653
00:26:16,220 --> 00:26:19,380
concerned have a hypervisor providing an

654
00:26:19,380 --> 00:26:21,720
additional set layer of protection

655
00:26:21,720 --> 00:26:24,299
the memory containing SE Linux enforcing

656
00:26:24,299 --> 00:26:26,580
is read-only the process credential

657
00:26:26,580 --> 00:26:28,260
structures are monitored so you can't

658
00:26:28,260 --> 00:26:31,260
edit them and unprivileged user mode

659
00:26:31,260 --> 00:26:33,539
processes aren't allowed to call useful

660
00:26:33,539 --> 00:26:36,779
functions such as rkp override creds or

661
00:26:36,779 --> 00:26:39,539
power off command so the attackers need

662
00:26:39,539 --> 00:26:43,080
to find other ways to change SE Linux

663
00:26:43,080 --> 00:26:45,539
and set their user ID

664
00:26:45,539 --> 00:26:49,919
so for SE Linux the exploit code finds

665
00:26:49,919 --> 00:26:52,200
some important static variables by

666
00:26:52,200 --> 00:26:54,539
analyzing instructions in SE Linux

667
00:26:54,539 --> 00:26:56,720
related kernel functions

668
00:26:56,720 --> 00:26:59,880
they find an adrp instruction which if

669
00:26:59,880 --> 00:27:01,860
you know arm assembler it's referencing

670
00:27:01,860 --> 00:27:05,340
some data find the instruction you know

671
00:27:05,340 --> 00:27:07,860
the address of the data the exploit code

672
00:27:07,860 --> 00:27:10,340
can then extract the SE Linux policy

673
00:27:10,340 --> 00:27:14,279
make some modifications to it refresh

674
00:27:14,279 --> 00:27:16,860
reload the database and effectively SC

675
00:27:16,860 --> 00:27:19,440
Linux has been made permissive

676
00:27:19,440 --> 00:27:23,220
so what about uid 0 this is a little bit

677
00:27:23,220 --> 00:27:25,919
more complicated the real-time kernel

678
00:27:25,919 --> 00:27:28,380
protection mechanism trusts its own

679
00:27:28,380 --> 00:27:32,520
executable system bin SMD exe is

680
00:27:32,520 --> 00:27:35,520
executed as a privileged process so this

681
00:27:35,520 --> 00:27:38,159
gives you an initial point of entry for

682
00:27:38,159 --> 00:27:39,779
getting the back door running

683
00:27:39,779 --> 00:27:42,840
a second executable simple perf is used

684
00:27:42,840 --> 00:27:45,960
to get the the full back door running

685
00:27:45,960 --> 00:27:49,140
so how this works inject a bit of Shell

686
00:27:49,140 --> 00:27:52,159
Code into SMD exe

687
00:27:52,159 --> 00:27:55,980
this does then use rkp override creds

688
00:27:55,980 --> 00:27:58,799
because it is a trusted privilege

689
00:27:58,799 --> 00:28:02,220
process so that sets itself to root uid

690
00:28:02,220 --> 00:28:03,600
0.

691
00:28:03,600 --> 00:28:05,640
the full back door has been put into

692
00:28:05,640 --> 00:28:09,179
simple perf so SMD exe then runs simple

693
00:28:09,179 --> 00:28:11,580
perf at which point we have the entire

694
00:28:11,580 --> 00:28:15,720
back door running as uid 0 and SE Linux

695
00:28:15,720 --> 00:28:18,900
is effectively in permissive mode

696
00:28:18,900 --> 00:28:21,960
right what do the attackers do with this

697
00:28:21,960 --> 00:28:23,820
um to begin with it's pretty much what

698
00:28:23,820 --> 00:28:26,039
you might expect they upload a lot of

699
00:28:26,039 --> 00:28:28,559
information off the device focusing on

700
00:28:28,559 --> 00:28:31,320
social media databases messages that

701
00:28:31,320 --> 00:28:33,600
kind of thing the list here isn't

702
00:28:33,600 --> 00:28:35,460
comprehensive we didn't have space on

703
00:28:35,460 --> 00:28:37,559
the slide to fit all the path names on

704
00:28:37,559 --> 00:28:39,960
but you can see Social Media stuff at

705
00:28:39,960 --> 00:28:42,419
the top Android accounts databases at

706
00:28:42,419 --> 00:28:44,820
the bottom and there's a spelling

707
00:28:44,820 --> 00:28:46,980
mistake highlighted in red which we'll

708
00:28:46,980 --> 00:28:49,020
come back to later

709
00:28:49,020 --> 00:28:51,600
after copying various data off the

710
00:28:51,600 --> 00:28:53,940
device the attackers then go through and

711
00:28:53,940 --> 00:28:56,159
disable a lot of

712
00:28:56,159 --> 00:28:59,279
system security settings again they

713
00:28:59,279 --> 00:29:00,900
change more settings than are shown here

714
00:29:00,900 --> 00:29:04,440
but we didn't have space on the slide so

715
00:29:04,440 --> 00:29:07,620
the device is now at increased risk of

716
00:29:07,620 --> 00:29:10,679
other malware because security settings

717
00:29:10,679 --> 00:29:14,400
automatic updates Etc have been disabled

718
00:29:14,400 --> 00:29:15,900
uh

719
00:29:15,900 --> 00:29:18,240
a number of third-party anti-virus

720
00:29:18,240 --> 00:29:20,460
applications are also uninstalled again

721
00:29:20,460 --> 00:29:22,860
potentially placing the user at greater

722
00:29:22,860 --> 00:29:25,440
risk of random other malware

723
00:29:25,440 --> 00:29:27,720
and finally the back door can clean

724
00:29:27,720 --> 00:29:32,159
itself up if it's commanded to do so

725
00:29:32,159 --> 00:29:35,840
now Christian earlier mentioned cve

726
00:29:35,840 --> 00:29:38,640
2019-2215 so I'd like to go back to look

727
00:29:38,640 --> 00:29:41,100
at a particular instance of that

728
00:29:41,100 --> 00:29:43,980
as a reminder of the timeline in late

729
00:29:43,980 --> 00:29:46,980
September 2019 Maddie Stone from Project

730
00:29:46,980 --> 00:29:50,640
zero identified the vulnerability and

731
00:29:50,640 --> 00:29:53,340
tag confirmed evidence of exploitation

732
00:29:53,340 --> 00:29:54,720
in the wild

733
00:29:54,720 --> 00:29:57,899
October 2019 Android patched the

734
00:29:57,899 --> 00:30:00,720
vulnerability we wrote some detection

735
00:30:00,720 --> 00:30:04,520
for exploitation and

736
00:30:04,520 --> 00:30:07,159
sent that out to see what we could find

737
00:30:07,159 --> 00:30:11,820
so what did we find well we found an

738
00:30:11,820 --> 00:30:13,820
exploit four CV

739
00:30:13,820 --> 00:30:17,220
2019-2215 uh slightly more interestingly

740
00:30:17,220 --> 00:30:19,440
it contained references to a couple of

741
00:30:19,440 --> 00:30:21,899
Android applications within it one of

742
00:30:21,899 --> 00:30:24,919
which is shown here pictivio viewer kit

743
00:30:24,919 --> 00:30:28,140
this was on play at the time we found it

744
00:30:28,140 --> 00:30:30,840
and interestingly it had been uploaded

745
00:30:30,840 --> 00:30:34,320
to play in February 2019 some seven

746
00:30:34,320 --> 00:30:37,679
months before we knew about the

747
00:30:37,679 --> 00:30:39,679
existence of CV

748
00:30:39,679 --> 00:30:42,600
2019-2215 as you can see on the right

749
00:30:42,600 --> 00:30:45,299
hand side of this slide that's quite a

750
00:30:45,299 --> 00:30:47,100
comprehensive list of permissions this

751
00:30:47,100 --> 00:30:49,140
image viewer has you probably don't need

752
00:30:49,140 --> 00:30:50,700
all of those in order to render images

753
00:30:50,700 --> 00:30:53,760
on your device the second application

754
00:30:53,760 --> 00:30:56,039
wasn't on play that was an off-market

755
00:30:56,039 --> 00:30:58,860
application masquerading as an app from

756
00:30:58,860 --> 00:31:02,159
Google using the Google Drive icon

757
00:31:02,159 --> 00:31:04,380
pictivio viewer kit didn't have very

758
00:31:04,380 --> 00:31:06,720
many installs we saw less than 30

759
00:31:06,720 --> 00:31:10,080
lifetime installs by the time we spotted

760
00:31:10,080 --> 00:31:11,880
it

761
00:31:11,880 --> 00:31:13,500
there are a number of similarities

762
00:31:13,500 --> 00:31:16,620
between the payloads in 2019 and the

763
00:31:16,620 --> 00:31:20,880
payloads in 2021. the elf files exported

764
00:31:20,880 --> 00:31:23,220
a function which was essentially a

765
00:31:23,220 --> 00:31:26,640
self-loader call that function that

766
00:31:26,640 --> 00:31:29,340
patches up the L file for where In

767
00:31:29,340 --> 00:31:32,640
memory it is at that time processes all

768
00:31:32,640 --> 00:31:35,520
of the relocations and resolves all of

769
00:31:35,520 --> 00:31:38,279
the Imports what's shown on the slide is

770
00:31:38,279 --> 00:31:41,100
something else that we saw sometimes the

771
00:31:41,100 --> 00:31:43,440
elf header was overwritten by a fairly

772
00:31:43,440 --> 00:31:46,440
simple shim which calls the self-loading

773
00:31:46,440 --> 00:31:49,679
function this is the 64-bit shim there

774
00:31:49,679 --> 00:31:51,899
was another very similar one for 32-bit

775
00:31:51,899 --> 00:31:54,299
so you can treat the L file like a blob

776
00:31:54,299 --> 00:31:56,279
of Shell Code just drop it off in memory

777
00:31:56,279 --> 00:31:59,340
jump into the beginning of that block of

778
00:31:59,340 --> 00:32:01,620
memory and itself loads

779
00:32:01,620 --> 00:32:04,380
so everything is fixed up no extra

780
00:32:04,380 --> 00:32:09,899
hassle as in 2021 in 2019 the payloads

781
00:32:09,899 --> 00:32:11,880
were injected into various privileged

782
00:32:11,880 --> 00:32:14,039
processes

783
00:32:14,039 --> 00:32:16,860
the list of similarities goes on uh

784
00:32:16,860 --> 00:32:20,039
security settings disabled files to copy

785
00:32:20,039 --> 00:32:23,820
applications to uninstall Etc and we see

786
00:32:23,820 --> 00:32:26,820
here the same spelling mistake in the

787
00:32:26,820 --> 00:32:30,480
2019 payloads as in 2021

788
00:32:30,480 --> 00:32:32,940
that config file hasn't actually been in

789
00:32:32,940 --> 00:32:34,980
that location for a little while so

790
00:32:34,980 --> 00:32:37,140
maybe the attackers just didn't clean up

791
00:32:37,140 --> 00:32:40,980
their standard list of files to copy

792
00:32:40,980 --> 00:32:43,260
right uh what are we doing about this

793
00:32:43,260 --> 00:32:44,580
well

794
00:32:44,580 --> 00:32:47,100
native payloads anything written that

795
00:32:47,100 --> 00:32:50,340
compiles into arm or arm 64. you've got

796
00:32:50,340 --> 00:32:52,620
to have executable memory to run that in

797
00:32:52,620 --> 00:32:55,440
so if you can see some

798
00:32:55,440 --> 00:32:58,200
unexpected executable memory turning up

799
00:32:58,200 --> 00:33:00,120
in your process it might be interesting

800
00:33:00,120 --> 00:33:02,100
to have a look in that memory to see

801
00:33:02,100 --> 00:33:04,380
what the contents are the information

802
00:33:04,380 --> 00:33:07,860
shown here is from one of our internal

803
00:33:07,860 --> 00:33:10,559
analysis systems running Chrome where

804
00:33:10,559 --> 00:33:14,360
we've given Chrome the cve 2020

805
00:33:14,360 --> 00:33:17,100
16040 exploit again that Christian

806
00:33:17,100 --> 00:33:18,720
mentioned earlier

807
00:33:18,720 --> 00:33:21,779
if you look here we can see

808
00:33:21,779 --> 00:33:25,980
an interesting length blob of memory is

809
00:33:25,980 --> 00:33:28,679
being made read write execute and then

810
00:33:28,679 --> 00:33:31,320
slightly below we can see a system call

811
00:33:31,320 --> 00:33:34,500
is returning into this potentially

812
00:33:34,500 --> 00:33:37,200
suspicious block of read write execute

813
00:33:37,200 --> 00:33:39,720
memory so there's definitely some code

814
00:33:39,720 --> 00:33:42,299
in there and happily our analysis system

815
00:33:42,299 --> 00:33:44,760
captured this blob of memory and saved

816
00:33:44,760 --> 00:33:46,320
it out for us

817
00:33:46,320 --> 00:33:48,539
so here's the beginning of that

818
00:33:48,539 --> 00:33:50,279
potentially suspicious blob of memory

819
00:33:50,279 --> 00:33:52,559
and the first thing that might catch

820
00:33:52,559 --> 00:33:55,980
your eye is there's an elf header at a

821
00:33:55,980 --> 00:33:57,840
rather unusual offset normally you'd

822
00:33:57,840 --> 00:33:59,279
expect to see the elf header at the

823
00:33:59,279 --> 00:34:01,559
beginning of the page or as I mentioned

824
00:34:01,559 --> 00:34:02,640
earlier

825
00:34:02,640 --> 00:34:04,919
uh depending on what you're looking at

826
00:34:04,919 --> 00:34:07,500
potentially in this case overwritten by

827
00:34:07,500 --> 00:34:09,480
the shim jumping into the self-loading

828
00:34:09,480 --> 00:34:10,739
code

829
00:34:10,739 --> 00:34:13,199
the data before the L file here is

830
00:34:13,199 --> 00:34:15,060
another shim this one's potentially

831
00:34:15,060 --> 00:34:17,339
slightly more interesting it copies some

832
00:34:17,339 --> 00:34:19,080
data from one location to another

833
00:34:19,080 --> 00:34:21,659
location and then it jumps into the

834
00:34:21,659 --> 00:34:25,679
self-loading export from the L file

835
00:34:25,679 --> 00:34:28,940
so yeah this

836
00:34:28,940 --> 00:34:32,040
tldr this is the exploit payload that

837
00:34:32,040 --> 00:34:34,139
shinyu has just explained in great

838
00:34:34,139 --> 00:34:35,099
detail

839
00:34:35,099 --> 00:34:38,460
uh so this takes us full circle tag

840
00:34:38,460 --> 00:34:40,320
found the Chrome remote code execution

841
00:34:40,320 --> 00:34:43,199
being used in the wild it contained an

842
00:34:43,199 --> 00:34:45,000
interesting payload which turned out to

843
00:34:45,000 --> 00:34:48,719
be a zero day the payloads in 2021 have

844
00:34:48,719 --> 00:34:50,940
some very strong similarities to the

845
00:34:50,940 --> 00:34:55,199
older payloads and in both cases the

846
00:34:55,199 --> 00:34:58,020
exploits concerned are relating to

847
00:34:58,020 --> 00:35:00,300
patching mismatches you could call them

848
00:35:00,300 --> 00:35:03,000
between Android and Linux where perhaps

849
00:35:03,000 --> 00:35:05,520
a patch wasn't applied in one whereas it

850
00:35:05,520 --> 00:35:07,140
was applied in the other or something

851
00:35:07,140 --> 00:35:09,540
was missed out

852
00:35:09,540 --> 00:35:12,619
so CV

853
00:35:12,619 --> 00:35:15,180
2021-0920 was a very complicated

854
00:35:15,180 --> 00:35:17,280
vulnerability and it was quite

855
00:35:17,280 --> 00:35:20,280
complicated to exploit the developers

856
00:35:20,280 --> 00:35:22,140
came up with some rather interesting

857
00:35:22,140 --> 00:35:23,940
behavioral Primitives in order to make

858
00:35:23,940 --> 00:35:26,660
everything work

859
00:35:26,760 --> 00:35:28,560
researching and implementing all of that

860
00:35:28,560 --> 00:35:30,359
must have taken them some time so

861
00:35:30,359 --> 00:35:31,920
they're obviously fairly well resourced

862
00:35:31,920 --> 00:35:33,900
to be able to do it because it might not

863
00:35:33,900 --> 00:35:35,480
have succeeded

864
00:35:35,480 --> 00:35:38,160
the faster the security industry can

865
00:35:38,160 --> 00:35:40,800
find and patch things like that the

866
00:35:40,800 --> 00:35:42,839
better we can protect our users and the

867
00:35:42,839 --> 00:35:44,520
more time and money it costs the

868
00:35:44,520 --> 00:35:46,740
surveillance industry to maintain their

869
00:35:46,740 --> 00:35:50,099
capability against things

870
00:35:50,099 --> 00:35:53,339
so we need to reduce the time it takes

871
00:35:53,339 --> 00:35:55,560
us to detect things to patch things and

872
00:35:55,560 --> 00:35:58,020
to get the updates out there in order to

873
00:35:58,020 --> 00:36:00,599
keep protecting people the faster

874
00:36:00,599 --> 00:36:02,280
response we can do this the better

875
00:36:02,280 --> 00:36:04,320
hopefully things like vulnerability

876
00:36:04,320 --> 00:36:06,060
reward programs are going to help with

877
00:36:06,060 --> 00:36:08,160
this because it encourages people to

878
00:36:08,160 --> 00:36:10,079
submit things to us and they'll get some

879
00:36:10,079 --> 00:36:11,160
reward

880
00:36:11,160 --> 00:36:14,040
so with that I think that's the end

881
00:36:14,040 --> 00:36:15,480
thank you very much for watching

882
00:36:15,480 --> 00:36:17,470
everybody

883
00:36:17,470 --> 00:36:20,580
[Music]

884
00:36:23,180 --> 00:36:26,779
thank you

