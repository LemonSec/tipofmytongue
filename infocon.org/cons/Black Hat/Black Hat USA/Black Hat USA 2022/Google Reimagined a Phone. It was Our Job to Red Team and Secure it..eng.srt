1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,040 --> 00:00:09,240
all right well welcome everyone to our

3
00:00:09,240 --> 00:00:11,160
session uh we are the Android red team

4
00:00:11,160 --> 00:00:13,320
we work for Google my name is farzan

5
00:00:13,320 --> 00:00:14,820
curry me the engineering manager of the

6
00:00:14,820 --> 00:00:16,560
team I'm joined by our two senior

7
00:00:16,560 --> 00:00:18,300
security researchers Juan Chang our

8
00:00:18,300 --> 00:00:19,859
technical lead as well as Eugene

9
00:00:19,859 --> 00:00:22,859
rodianov a special thanks to Christopher

10
00:00:22,859 --> 00:00:25,380
Cole as well one of our former leaders

11
00:00:25,380 --> 00:00:28,080
in Android security for all your help

12
00:00:28,080 --> 00:00:30,000
Contra for your contributions to this

13
00:00:30,000 --> 00:00:31,619
deck but also for helping us build a

14
00:00:31,619 --> 00:00:33,000
phenomenal red team

15
00:00:33,000 --> 00:00:35,460
so our presentation is uh we'll cover

16
00:00:35,460 --> 00:00:37,559
how Google reimagined a phone with the

17
00:00:37,559 --> 00:00:39,899
pixel 6 and how it was our job to red

18
00:00:39,899 --> 00:00:41,820
team and secure it uh so this

19
00:00:41,820 --> 00:00:43,379
transformation from prior generation

20
00:00:43,379 --> 00:00:44,879
phones meant that our red team had the

21
00:00:44,879 --> 00:00:46,680
unique task to test a phone that serves

22
00:00:46,680 --> 00:00:48,660
millions of customers with an entirely

23
00:00:48,660 --> 00:00:51,780
new SOC it's a new hardware firmware of

24
00:00:51,780 --> 00:00:54,480
uh software components as well and we

25
00:00:54,480 --> 00:00:55,980
had to get all this work done in about a

26
00:00:55,980 --> 00:00:57,660
year before launch so we're going to

27
00:00:57,660 --> 00:00:59,039
cover how we did that

28
00:00:59,039 --> 00:01:01,020
the first a little bit about who we are

29
00:01:01,020 --> 00:01:03,480
uh our scope and how our red team fits

30
00:01:03,480 --> 00:01:05,519
into the Android security wheel to help

31
00:01:05,519 --> 00:01:06,840
secure Google products running on

32
00:01:06,840 --> 00:01:08,880
Android OS so we'll talk about some

33
00:01:08,880 --> 00:01:10,500
interesting attack surface under pixel 6

34
00:01:10,500 --> 00:01:12,479
and then we'll dive into some impactful

35
00:01:12,479 --> 00:01:14,340
pocs or proof of Concepts we developed

36
00:01:14,340 --> 00:01:15,720
over the course of a few red team

37
00:01:15,720 --> 00:01:17,939
engagements so we'll be demoing the

38
00:01:17,939 --> 00:01:19,740
first code execution on the Titan M2

39
00:01:19,740 --> 00:01:21,720
today so you definitely want to stick

40
00:01:21,720 --> 00:01:23,340
around for that and we also have some

41
00:01:23,340 --> 00:01:24,360
impressive work on the Android

42
00:01:24,360 --> 00:01:27,299
Bootloader which we call ADL so a lot of

43
00:01:27,299 --> 00:01:28,500
quality content to cover in this

44
00:01:28,500 --> 00:01:29,700
presentation

45
00:01:29,700 --> 00:01:31,560
also want to emphasize that everything

46
00:01:31,560 --> 00:01:33,720
in this presentation is fixed we are not

47
00:01:33,720 --> 00:01:36,659
dropping zero days today

48
00:01:36,659 --> 00:01:38,159
a little bit about who we are we are the

49
00:01:38,159 --> 00:01:39,840
red team we are the eyes of Android

50
00:01:39,840 --> 00:01:42,000
security so our mission is to secure

51
00:01:42,000 --> 00:01:44,759
pixel and Android uh by from by

52
00:01:44,759 --> 00:01:47,579
attacking key uh surfaces or rather

53
00:01:47,579 --> 00:01:48,960
features to find impactful security

54
00:01:48,960 --> 00:01:51,180
issues before real attackers find them

55
00:01:51,180 --> 00:01:53,100
so we do that a number of ways primarily

56
00:01:53,100 --> 00:01:56,100
through red team engagements so uh this

57
00:01:56,100 --> 00:01:58,020
helps us validate security assumptions

58
00:01:58,020 --> 00:02:00,600
are real or we wind up breaking them uh

59
00:02:00,600 --> 00:02:01,740
we scale through tool develop

60
00:02:01,740 --> 00:02:04,079
development primarily through fuzzing so

61
00:02:04,079 --> 00:02:05,820
we built fuzzers and we hand them off to

62
00:02:05,820 --> 00:02:07,619
our Central Android fuzzing team to

63
00:02:07,619 --> 00:02:10,080
enhance and manage so that they can

64
00:02:10,080 --> 00:02:11,520
continue to work for us behind the

65
00:02:11,520 --> 00:02:14,819
scenes 24 7 365 days a year and this is

66
00:02:14,819 --> 00:02:16,379
an approach we call continuous fuzzing

67
00:02:16,379 --> 00:02:17,940
that has provided a lot of benefit for

68
00:02:17,940 --> 00:02:18,720
us

69
00:02:18,720 --> 00:02:21,480
we invest time in exploit development so

70
00:02:21,480 --> 00:02:23,819
this helps inform difficult security

71
00:02:23,819 --> 00:02:25,680
decisions we found so it helps

72
00:02:25,680 --> 00:02:27,780
articulate impact the leadership it also

73
00:02:27,780 --> 00:02:29,760
helps us as a red team during the

74
00:02:29,760 --> 00:02:31,560
exploit writing exercise find even new

75
00:02:31,560 --> 00:02:32,819
vulnerabilities we wouldn't have found

76
00:02:32,819 --> 00:02:33,720
before

77
00:02:33,720 --> 00:02:35,520
and finally we're deeply integrated in

78
00:02:35,520 --> 00:02:37,920
the remediation process red team

79
00:02:37,920 --> 00:02:39,480
shouldn't just be finding bugs but

80
00:02:39,480 --> 00:02:41,160
should be active participants in

81
00:02:41,160 --> 00:02:43,319
remediation it's ultimately how we

82
00:02:43,319 --> 00:02:45,959
provide the most value to the business

83
00:02:45,959 --> 00:02:48,239
so the business being Android and Google

84
00:02:48,239 --> 00:02:49,739
products that run on Android such as the

85
00:02:49,739 --> 00:02:51,000
pixel

86
00:02:51,000 --> 00:02:53,340
so how do we secure these areas well our

87
00:02:53,340 --> 00:02:55,080
Android security organization makes many

88
00:02:55,080 --> 00:02:56,819
Investments to ensure we ship products

89
00:02:56,819 --> 00:02:58,620
like pixel to you into most secure form

90
00:02:58,620 --> 00:03:00,840
possible this the intent of this slide

91
00:03:00,840 --> 00:03:02,879
is just to really hone in on red team is

92
00:03:02,879 --> 00:03:04,620
just one integral piece of this big

93
00:03:04,620 --> 00:03:06,840
process another big part of that process

94
00:03:06,840 --> 00:03:09,000
is you so thank you for all your

95
00:03:09,000 --> 00:03:10,920
contributions to our vrp program our

96
00:03:10,920 --> 00:03:13,500
vulnerability Rewards program it's also

97
00:03:13,500 --> 00:03:14,940
a great opportunity to acknowledge some

98
00:03:14,940 --> 00:03:16,620
of the other sessions at black hat on

99
00:03:16,620 --> 00:03:18,720
Android security last I counted I think

100
00:03:18,720 --> 00:03:19,940
there's 12

101
00:03:19,940 --> 00:03:22,140
and there's actually another session

102
00:03:22,140 --> 00:03:24,540
tomorrow on the Titan M it's really

103
00:03:24,540 --> 00:03:26,700
world-class research like fees that

104
00:03:26,700 --> 00:03:28,500
helps improve the security posture of

105
00:03:28,500 --> 00:03:31,260
Google products like the pixel

106
00:03:31,260 --> 00:03:33,239
so a few words on where we focus today

107
00:03:33,239 --> 00:03:34,920
as a red team so we invest heavily in

108
00:03:34,920 --> 00:03:36,780
fuzzing and static analysis so both

109
00:03:36,780 --> 00:03:38,099
Schwann and Eugene will dive into

110
00:03:38,099 --> 00:03:41,400
intensive detail on what we do here but

111
00:03:41,400 --> 00:03:43,319
as we're growing we're also looking at

112
00:03:43,319 --> 00:03:45,900
server-side attacks as a red team

113
00:03:45,900 --> 00:03:49,200
so quick overview of the pixel Journey

114
00:03:49,200 --> 00:03:51,060
so the point to highlight here is that

115
00:03:51,060 --> 00:03:52,620
there have been many iterations of pixel

116
00:03:52,620 --> 00:03:55,080
with unique security components uh prior

117
00:03:55,080 --> 00:03:57,599
to the pixel 6. pixel 3 took a big step

118
00:03:57,599 --> 00:03:59,519
forward with the creation of the Titan M

119
00:03:59,519 --> 00:04:00,420
chip

120
00:04:00,420 --> 00:04:02,940
and uh and finally with the pixel 6 we

121
00:04:02,940 --> 00:04:04,980
build a custom SOC that adds an

122
00:04:04,980 --> 00:04:06,840
additional security Enclave private

123
00:04:06,840 --> 00:04:08,760
compute core and most importantly the

124
00:04:08,760 --> 00:04:10,560
Titan from our perspective the Titan M2

125
00:04:10,560 --> 00:04:12,060
is introduced as the most secure element

126
00:04:12,060 --> 00:04:14,640
in the pixel 6.

127
00:04:14,640 --> 00:04:16,978
so how does that Journey translate to

128
00:04:16,978 --> 00:04:19,440
where attackers are focused today so in

129
00:04:19,440 --> 00:04:21,120
general vulnerability Trends are moving

130
00:04:21,120 --> 00:04:23,100
lower down to stack uh don't worry

131
00:04:23,100 --> 00:04:24,120
there's still plenty of cross-site

132
00:04:24,120 --> 00:04:25,380
scripting out there if that's your bread

133
00:04:25,380 --> 00:04:27,540
and butter but as applications were

134
00:04:27,540 --> 00:04:29,820
moved to sandboxes attacks also started

135
00:04:29,820 --> 00:04:31,860
moving lower through the OS down to the

136
00:04:31,860 --> 00:04:34,560
kernel firmware level even ROM code

137
00:04:34,560 --> 00:04:36,000
that makes exploits in these lower

138
00:04:36,000 --> 00:04:37,259
portions of the stack incredibly

139
00:04:37,259 --> 00:04:39,900
attractive for attackers

140
00:04:39,900 --> 00:04:41,699
so just some supporting evidence we can

141
00:04:41,699 --> 00:04:43,800
look at exploit pricing at one data

142
00:04:43,800 --> 00:04:45,300
point to support these vulnerability

143
00:04:45,300 --> 00:04:47,280
Trends so we've come to the consensus

144
00:04:47,280 --> 00:04:49,199
that if third-party markets or pricing

145
00:04:49,199 --> 00:04:51,180
exploits against Android higher than

146
00:04:51,180 --> 00:04:52,800
other mobile platforms then we know

147
00:04:52,800 --> 00:04:54,360
we're doing a pretty good job

148
00:04:54,360 --> 00:04:56,639
so the harder it is to explain the

149
00:04:56,639 --> 00:04:57,840
higher the price of those exploits

150
00:04:57,840 --> 00:05:00,180
generally are so this is the zero DM

151
00:05:00,180 --> 00:05:02,280
Elemental chart of mobile payouts uh

152
00:05:02,280 --> 00:05:03,660
this tells us how third parties are

153
00:05:03,660 --> 00:05:05,520
pricing exploits on mobile platforms and

154
00:05:05,520 --> 00:05:07,440
browsers you can see what's worth two

155
00:05:07,440 --> 00:05:09,660
and a half million up top that's an

156
00:05:09,660 --> 00:05:11,580
Android full chain with persistent zero

157
00:05:11,580 --> 00:05:13,680
click bug again this gives it some level

158
00:05:13,680 --> 00:05:14,940
of confidence that we're doing good

159
00:05:14,940 --> 00:05:18,259
things and shipping you a secure phone

160
00:05:18,300 --> 00:05:20,520
so let's hone in on a bit on the pixel 6

161
00:05:20,520 --> 00:05:23,160
attack surface

162
00:05:23,160 --> 00:05:25,139
so this diagram represents a high level

163
00:05:25,139 --> 00:05:27,300
attack surface of the Google tensor SOC

164
00:05:27,300 --> 00:05:29,639
in the pixel 6. what you see in light

165
00:05:29,639 --> 00:05:31,500
blue are updated features from previous

166
00:05:31,500 --> 00:05:34,199
pixels dark blue is new primarily our

167
00:05:34,199 --> 00:05:35,699
tensor security core as well as the

168
00:05:35,699 --> 00:05:38,280
Titan M2 Chip uh what you see covered in

169
00:05:38,280 --> 00:05:40,080
red now is attack surface that our red

170
00:05:40,080 --> 00:05:42,419
team has tested and helped mitigate uh

171
00:05:42,419 --> 00:05:44,280
in Prior red team reviews so we covered

172
00:05:44,280 --> 00:05:46,080
thing areas like normal and secure world

173
00:05:46,080 --> 00:05:48,060
everything including our trust EOS our

174
00:05:48,060 --> 00:05:50,280
trusted execution environment all the

175
00:05:50,280 --> 00:05:53,280
way to secure monitor running in the L3

176
00:05:53,280 --> 00:05:55,620
now what you see in dark red is attack

177
00:05:55,620 --> 00:05:56,880
surface that we'll cover in this

178
00:05:56,880 --> 00:05:58,680
presentation today again the Titan M2

179
00:05:58,680 --> 00:06:01,860
and the ADL or Android Bootloader so

180
00:06:01,860 --> 00:06:03,360
last point I want to emphasize before I

181
00:06:03,360 --> 00:06:05,580
hand it off to Eugene is that we're

182
00:06:05,580 --> 00:06:07,020
going to be talking about some pretty

183
00:06:07,020 --> 00:06:09,240
impactful code execution bugs today

184
00:06:09,240 --> 00:06:11,280
but despite this we're confident in

185
00:06:11,280 --> 00:06:13,020
sharing with you that we're shipping the

186
00:06:13,020 --> 00:06:15,000
most secure pixel yet with the pixel 6

187
00:06:15,000 --> 00:06:17,280
and you might ask well isn't that

188
00:06:17,280 --> 00:06:18,600
counter-intuitive if you're telling me

189
00:06:18,600 --> 00:06:20,520
about code execution bugs and we would

190
00:06:20,520 --> 00:06:22,380
say that that's exactly why the pixel 6

191
00:06:22,380 --> 00:06:24,780
is so secure we've red teamed it we've

192
00:06:24,780 --> 00:06:26,400
improved line coverage through fuzzing

193
00:06:26,400 --> 00:06:28,800
and static analysis we've worked with uh

194
00:06:28,800 --> 00:06:30,600
remediation or rather feature teams to

195
00:06:30,600 --> 00:06:33,120
prioritize remediation efforts and

196
00:06:33,120 --> 00:06:35,280
Implement hardening recommendations so

197
00:06:35,280 --> 00:06:37,800
that we can ship you a secure phone

198
00:06:37,800 --> 00:06:39,180
so with that said I'm going to hand it

199
00:06:39,180 --> 00:06:40,860
off to Eugene rhodianov who will cover

200
00:06:40,860 --> 00:06:43,880
the Titan M2

201
00:06:45,360 --> 00:06:48,680
thank you for sending so

202
00:06:48,680 --> 00:06:51,780
from the attacker standpoint Titan M2 is

203
00:06:51,780 --> 00:06:53,819
one of the high profile targets it is

204
00:06:53,819 --> 00:06:55,740
created to handle heavily secrets on

205
00:06:55,740 --> 00:06:58,460
Android platform and pixel devices and

206
00:06:58,460 --> 00:07:00,720
it provides such protections against

207
00:07:00,720 --> 00:07:02,280
physical attacks such as fault injection

208
00:07:02,280 --> 00:07:05,460
as an example Android Erp program offers

209
00:07:05,460 --> 00:07:07,199
bounties up to one million dollars per

210
00:07:07,199 --> 00:07:09,060
code execution on Titan M2 which

211
00:07:09,060 --> 00:07:10,979
signifies the security claims

212
00:07:10,979 --> 00:07:14,400
and for Pixel and Android type number 2

213
00:07:14,400 --> 00:07:16,020
provides foundational security services

214
00:07:16,020 --> 00:07:18,720
such as a hardware-backed key storage

215
00:07:18,720 --> 00:07:20,639
strong box

216
00:07:20,639 --> 00:07:22,800
key area station it plays an essential

217
00:07:22,800 --> 00:07:25,220
role in Android verified boot process

218
00:07:25,220 --> 00:07:27,539
so Titan M2 is the second version of

219
00:07:27,539 --> 00:07:29,639
Titan chip the first version of Titan

220
00:07:29,639 --> 00:07:31,500
was released first in pixel 3 devices

221
00:07:31,500 --> 00:07:34,259
and unlike Titan M which is based on arm

222
00:07:34,259 --> 00:07:36,780
architecture Titan M2 is based on custom

223
00:07:36,780 --> 00:07:39,060
risk fiber architecture build with a

224
00:07:39,060 --> 00:07:41,099
non-standard tool chain and runs a

225
00:07:41,099 --> 00:07:42,539
completely redesigned operating system

226
00:07:42,539 --> 00:07:45,440
and firmware stack

227
00:07:46,800 --> 00:07:48,060
and given that there is not too much

228
00:07:48,060 --> 00:07:49,680
publicly available information on

229
00:07:49,680 --> 00:07:51,240
technical details of that name I would

230
00:07:51,240 --> 00:07:53,160
like to reference a great paper a

231
00:07:53,160 --> 00:07:55,500
titanium Odyssey presented at black hat

232
00:07:55,500 --> 00:07:57,539
2021 which provides a lot of interesting

233
00:07:57,539 --> 00:07:59,819
details on reverse engineering type name

234
00:07:59,819 --> 00:08:01,979
chip and a lot of technical details

235
00:08:01,979 --> 00:08:04,319
that's really great to see what the

236
00:08:04,319 --> 00:08:06,180
researchers could achieve with the black

237
00:08:06,180 --> 00:08:09,000
box approach on this that Target so here

238
00:08:09,000 --> 00:08:09,960
is a

239
00:08:09,960 --> 00:08:13,199
attack surface of Titan M2 so Titan M2

240
00:08:13,199 --> 00:08:15,000
is a discrete secure element connected

241
00:08:15,000 --> 00:08:17,900
to the main tensor SOC over spy bus

242
00:08:17,900 --> 00:08:20,699
the application processor is not able to

243
00:08:20,699 --> 00:08:23,699
directly send data to Titan M2 over spy

244
00:08:23,699 --> 00:08:26,340
bus or there is an Enterprise in a

245
00:08:26,340 --> 00:08:28,379
dedicated tensor security core which

246
00:08:28,379 --> 00:08:31,259
actually sends data to Titan 2 over spy

247
00:08:31,259 --> 00:08:32,219
bus

248
00:08:32,219 --> 00:08:33,779
and on the left hand side of the slide

249
00:08:33,779 --> 00:08:35,880
we can see a high level architecture of

250
00:08:35,880 --> 00:08:38,159
Titan empty chips or at the bottom we

251
00:08:38,159 --> 00:08:39,958
have mask from a hardware responsible

252
00:08:39,958 --> 00:08:42,260
for secure boot to boost the bootloader

253
00:08:42,260 --> 00:08:44,459
bootloader on its own implements

254
00:08:44,459 --> 00:08:46,860
recovery functionality it authenticates

255
00:08:46,860 --> 00:08:49,740
the next stage main firmware image which

256
00:08:49,740 --> 00:08:53,060
consists of the kernel and applications

257
00:08:53,060 --> 00:08:56,100
and Titan M2 implements risk fiber

258
00:08:56,100 --> 00:08:57,660
architecture using team modes user

259
00:08:57,660 --> 00:08:59,880
remote and machine mode

260
00:08:59,880 --> 00:09:01,200
um so all the applications are running

261
00:09:01,200 --> 00:09:03,120
in the same address space

262
00:09:03,120 --> 00:09:06,180
um as there is no mmu so I will be also

263
00:09:06,180 --> 00:09:08,220
calling them in the slides as tasks but

264
00:09:08,220 --> 00:09:10,080
they are isolated between each other and

265
00:09:10,080 --> 00:09:11,519
those applications they implement the

266
00:09:11,519 --> 00:09:13,680
main logic of the chief exposed to their

267
00:09:13,680 --> 00:09:16,860
SOC and the Android platform and

268
00:09:16,860 --> 00:09:19,080
basically those applications they

269
00:09:19,080 --> 00:09:21,839
process uh untrusted data received from

270
00:09:21,839 --> 00:09:23,580
their AP and this is our main attack

271
00:09:23,580 --> 00:09:26,580
Vector in this uh so this is our threat

272
00:09:26,580 --> 00:09:29,040
model so we're assuming that an attacker

273
00:09:29,040 --> 00:09:30,839
is able to run arbitrary code on the

274
00:09:30,839 --> 00:09:32,580
application processor in the privileged

275
00:09:32,580 --> 00:09:34,620
context and is able to send arbitrary

276
00:09:34,620 --> 00:09:38,120
data to your titman 2.

277
00:09:38,220 --> 00:09:41,220
uh before we dive into details are of

278
00:09:41,220 --> 00:09:43,200
fuzzing and vulnerabilities which we

279
00:09:43,200 --> 00:09:44,880
discovered in this engagement I would

280
00:09:44,880 --> 00:09:46,740
like to say a few words about your

281
00:09:46,740 --> 00:09:48,000
defense and depth mitigations

282
00:09:48,000 --> 00:09:49,680
implemented in titanum 2 which they

283
00:09:49,680 --> 00:09:52,019
which make this chip more secure so well

284
00:09:52,019 --> 00:09:53,640
there is another next policy which is

285
00:09:53,640 --> 00:09:55,200
enforced by physical memory protection

286
00:09:55,200 --> 00:09:57,959
registers and custom uh Titan extensions

287
00:09:57,959 --> 00:10:00,480
uh which should make code

288
00:10:00,480 --> 00:10:02,399
section not writable and stack not

289
00:10:02,399 --> 00:10:04,140
executable

290
00:10:04,140 --> 00:10:06,720
um but there isolation so or essentially

291
00:10:06,720 --> 00:10:08,580
physical memory protection registers are

292
00:10:08,580 --> 00:10:11,580
used to make sure that a certain task is

293
00:10:11,580 --> 00:10:13,500
not able to read or write globals and

294
00:10:13,500 --> 00:10:15,360
stack of other tasks so that if an

295
00:10:15,360 --> 00:10:16,980
attacker is able to compromise sites and

296
00:10:16,980 --> 00:10:19,200
get code execution inside one task they

297
00:10:19,200 --> 00:10:21,060
are not able to or compromise Secrets

298
00:10:21,060 --> 00:10:23,580
handled by other tasks in addition to

299
00:10:23,580 --> 00:10:25,740
address isolation there is also a file

300
00:10:25,740 --> 00:10:27,420
system isolation so every task is

301
00:10:27,420 --> 00:10:29,519
provided with this album file system to

302
00:10:29,519 --> 00:10:32,820
persist its secrets and finally there is

303
00:10:32,820 --> 00:10:34,680
a number of ciscals exposed by the

304
00:10:34,680 --> 00:10:36,480
kernel to the applications and there is

305
00:10:36,480 --> 00:10:39,120
an ACL policy which allows to restrict

306
00:10:39,120 --> 00:10:42,060
certain Seas calls to the applications

307
00:10:42,060 --> 00:10:44,700
which we actually don't need them

308
00:10:44,700 --> 00:10:48,060
so we're in this red team engagement our

309
00:10:48,060 --> 00:10:50,160
team was tasked with uh proactively

310
00:10:50,160 --> 00:10:52,019
identifying and helping and helping the

311
00:10:52,019 --> 00:10:54,720
feature team to mitigate issues in Titan

312
00:10:54,720 --> 00:10:57,779
M2 firmware before pixel 6 release and

313
00:10:57,779 --> 00:11:00,420
as far as I mentioned earlier fuzzing is

314
00:11:00,420 --> 00:11:02,820
one of our Central methodologies and

315
00:11:02,820 --> 00:11:04,740
Titan Mt was no exception so we

316
00:11:04,740 --> 00:11:06,839
approached it using two directions a

317
00:11:06,839 --> 00:11:08,579
host based buzzing and emulator based

318
00:11:08,579 --> 00:11:10,800
buzzing thanks to the implementation

319
00:11:10,800 --> 00:11:14,339
details of Titan M2 firmware we were

320
00:11:14,339 --> 00:11:16,500
able to build a subset of modules for

321
00:11:16,500 --> 00:11:19,320
x86 32-bit architecture and as a result

322
00:11:19,320 --> 00:11:21,060
we came up with a very high performance

323
00:11:21,060 --> 00:11:24,300
buzzer and we also took advantage of a

324
00:11:24,300 --> 00:11:25,980
large arsenal of tools available for

325
00:11:25,980 --> 00:11:27,899
fast and onyx86 platforms such as

326
00:11:27,899 --> 00:11:29,820
address sanitizers

327
00:11:29,820 --> 00:11:32,399
uh with Father Aboriginal guided fasting

328
00:11:32,399 --> 00:11:33,600
engine and so on

329
00:11:33,600 --> 00:11:35,399
as a downside of this approach there are

330
00:11:35,399 --> 00:11:37,019
some components which we obviously were

331
00:11:37,019 --> 00:11:38,700
not able to build for host nodes for

332
00:11:38,700 --> 00:11:40,860
instance crypto task because crypto task

333
00:11:40,860 --> 00:11:42,180
communicates directly with the crypto

334
00:11:42,180 --> 00:11:44,760
Hardware which we which is not easy to

335
00:11:44,760 --> 00:11:48,360
mock on host uh platform and also there

336
00:11:48,360 --> 00:11:49,860
are some architecture specific drivers

337
00:11:49,860 --> 00:11:53,279
which we also needed to deal with so in

338
00:11:53,279 --> 00:11:55,200
order to cover those critical components

339
00:11:55,200 --> 00:11:57,060
we implemented in other fuzzer using the

340
00:11:57,060 --> 00:11:58,800
full system emulator provided by the

341
00:11:58,800 --> 00:12:00,600
feature team in order to be able to

342
00:12:00,600 --> 00:12:04,320
cover the firmware stack completely

343
00:12:04,320 --> 00:12:06,899
and in total we developed three fuzzers

344
00:12:06,899 --> 00:12:09,480
so two host based fuzzers uh one Elite

345
00:12:09,480 --> 00:12:12,360
prot above meter coverage guided fuzzer

346
00:12:12,360 --> 00:12:13,140
um

347
00:12:13,140 --> 00:12:17,579
and one dedicated father to you fast as

348
00:12:17,579 --> 00:12:19,260
and one decoding functionality because

349
00:12:19,260 --> 00:12:22,079
well as we know asm1 decoding is not

350
00:12:22,079 --> 00:12:23,760
really difficult to get right so we want

351
00:12:23,760 --> 00:12:25,560
to make sure that this attack surface is

352
00:12:25,560 --> 00:12:26,519
mitigated

353
00:12:26,519 --> 00:12:28,740
and additionally we have a third fuzzer

354
00:12:28,740 --> 00:12:30,980
emulator based fuzzer

355
00:12:30,980 --> 00:12:34,079
and interestingly we have fuzzers number

356
00:12:34,079 --> 00:12:36,420
one and number three we can replace test

357
00:12:36,420 --> 00:12:37,740
cases from each other so basically

358
00:12:37,740 --> 00:12:40,440
they're using the same interface

359
00:12:40,440 --> 00:12:42,600
um as we expected the the emulator the

360
00:12:42,600 --> 00:12:45,300
father was quite slow uh five test cases

361
00:12:45,300 --> 00:12:47,519
per second this is attributed to the

362
00:12:47,519 --> 00:12:49,320
accuracy of the emulation of the

363
00:12:49,320 --> 00:12:50,940
peripheral devices because this is like

364
00:12:50,940 --> 00:12:53,160
an accurate Hardware emulator

365
00:12:53,160 --> 00:12:55,200
provided by the feature team but on the

366
00:12:55,200 --> 00:12:57,600
other hand side but on the other hand

367
00:12:57,600 --> 00:12:59,820
host based faster compensated for it

368
00:12:59,820 --> 00:13:02,519
because it's about 2.200 times faster a

369
00:13:02,519 --> 00:13:04,800
thousand test cases per second and by

370
00:13:04,800 --> 00:13:06,899
running this fuzzers for some time we

371
00:13:06,899 --> 00:13:09,540
accumulated the initial set of issues I

372
00:13:09,540 --> 00:13:11,160
would say that not all the issues

373
00:13:11,160 --> 00:13:13,079
identified in this engagements were came

374
00:13:13,079 --> 00:13:14,940
from the fuzzers but fuzzers were

375
00:13:14,940 --> 00:13:16,560
instrumental in bringing our attention

376
00:13:16,560 --> 00:13:18,540
to our problematic code and by doing

377
00:13:18,540 --> 00:13:20,480
variant analysis we were able uncover

378
00:13:20,480 --> 00:13:24,000
issues in other components and uh

379
00:13:24,000 --> 00:13:26,279
essentially here as we were triaging the

380
00:13:26,279 --> 00:13:27,600
issues we were particularly interested

381
00:13:27,600 --> 00:13:30,720
in exploitable ones and there uh we got

382
00:13:30,720 --> 00:13:33,600
a few interesting examples so

383
00:13:33,600 --> 00:13:36,120
one of this is actually out of bonds

384
00:13:36,120 --> 00:13:38,880
right in the identity task so as we can

385
00:13:38,880 --> 00:13:41,040
see here there is a vulnerable mem CPI

386
00:13:41,040 --> 00:13:44,279
operation in a presentation push reader

387
00:13:44,279 --> 00:13:46,019
cert so this is a pretty straightforward

388
00:13:46,019 --> 00:13:47,880
vulnerability to exploit quite powerful

389
00:13:47,880 --> 00:13:49,620
primitive where the attacker is able to

390
00:13:49,620 --> 00:13:51,959
control public key and public key length

391
00:13:51,959 --> 00:13:54,720
arguments and essentially your

392
00:13:54,720 --> 00:13:55,920
uh

393
00:13:55,920 --> 00:13:58,019
attacker is able to write arbitrary data

394
00:13:58,019 --> 00:13:59,579
of arbitral links to non-controlled

395
00:13:59,579 --> 00:14:02,399
address so this is not yet sufficient to

396
00:14:02,399 --> 00:14:03,959
give code execution and we started to

397
00:14:03,959 --> 00:14:05,399
explore how can we improve this

398
00:14:05,399 --> 00:14:06,360
primitive

399
00:14:06,360 --> 00:14:08,100
if you look at the where with the

400
00:14:08,100 --> 00:14:09,720
Republic key points at it actually

401
00:14:09,720 --> 00:14:11,220
points in global variables of the

402
00:14:11,220 --> 00:14:14,040
identity task and we can see that there

403
00:14:14,040 --> 00:14:16,200
are two interesting objects located in

404
00:14:16,200 --> 00:14:19,320
identity tasks at offset A4 and 164 and

405
00:14:19,320 --> 00:14:21,839
hex so our C board dot buffer size and

406
00:14:21,839 --> 00:14:24,360
cboard.buffer and those variables are

407
00:14:24,360 --> 00:14:27,060
used in another operation C board and

408
00:14:27,060 --> 00:14:29,579
string so if we change those two

409
00:14:29,579 --> 00:14:31,380
commands together we're able to come up

410
00:14:31,380 --> 00:14:33,120
with write what we're primitive very

411
00:14:33,120 --> 00:14:36,120
precise we can basically overwrite data

412
00:14:36,120 --> 00:14:38,040
on the stack and

413
00:14:38,040 --> 00:14:42,440
uh trigger our code execution

414
00:14:42,440 --> 00:14:44,639
well in reality it takes a little bit

415
00:14:44,639 --> 00:14:46,500
more interaction with the cheap to get

416
00:14:46,500 --> 00:14:49,079
kill execution because identity is a

417
00:14:49,079 --> 00:14:51,720
stateful task and they're in order to

418
00:14:51,720 --> 00:14:53,279
exploit the first vulnerability we

419
00:14:53,279 --> 00:14:54,779
needed to put identity into the right

420
00:14:54,779 --> 00:14:56,880
state so that's why basically we are

421
00:14:56,880 --> 00:14:58,980
replaying those commands step number one

422
00:14:58,980 --> 00:15:00,779
and step number two just to advance

423
00:15:00,779 --> 00:15:03,959
identity State into the right state

424
00:15:03,959 --> 00:15:06,060
step number three this is actually we

425
00:15:06,060 --> 00:15:08,760
were we exploited the first mem CPI out

426
00:15:08,760 --> 00:15:11,399
of bonds right and we override Global C

427
00:15:11,399 --> 00:15:14,279
board with the attacker control values

428
00:15:14,279 --> 00:15:16,139
we have step number four and step number

429
00:15:16,139 --> 00:15:18,360
five again to your Advanced identity

430
00:15:18,360 --> 00:15:20,519
task into the right State and at step

431
00:15:20,519 --> 00:15:22,860
number six we're actually delivering our

432
00:15:22,860 --> 00:15:25,980
Shell Code we are overwriting the return

433
00:15:25,980 --> 00:15:27,899
address on the stack and we're executing

434
00:15:27,899 --> 00:15:29,519
our code

435
00:15:29,519 --> 00:15:31,380
so at this point we're able to run

436
00:15:31,380 --> 00:15:32,940
arbitrary codes in the context of the

437
00:15:32,940 --> 00:15:34,440
identity task

438
00:15:34,440 --> 00:15:36,079
and uh

439
00:15:36,079 --> 00:15:39,060
so what we can do else

440
00:15:39,060 --> 00:15:40,740
our ultimate goal in this engagement was

441
00:15:40,740 --> 00:15:42,180
to compromise high value Secrets

442
00:15:42,180 --> 00:15:44,040
protected by technology chip and then I

443
00:15:44,040 --> 00:15:45,959
started to look around and see like what

444
00:15:45,959 --> 00:15:48,720
actually is protected by identity we we

445
00:15:48,720 --> 00:15:50,459
didn't find any interesting secrets you

446
00:15:50,459 --> 00:15:52,079
were compromised from the identity tasks

447
00:15:52,079 --> 00:15:54,959
or we started looking like a different

448
00:15:54,959 --> 00:15:56,940
exploitation scenarios and one of them

449
00:15:56,940 --> 00:15:59,760
was actually to compromise Weber Secrets

450
00:15:59,760 --> 00:16:03,360
by dumping a secure file system so on

451
00:16:03,360 --> 00:16:04,620
the previous slide I mentioned that

452
00:16:04,620 --> 00:16:06,839
every task is isolated file system so

453
00:16:06,839 --> 00:16:08,760
you may wonder how it is possible well I

454
00:16:08,760 --> 00:16:10,139
will explain on the next slide how it is

455
00:16:10,139 --> 00:16:12,300
possible but right now just a quick

456
00:16:12,300 --> 00:16:14,519
overview of what river is and how it

457
00:16:14,519 --> 00:16:16,560
works so we will provides a password

458
00:16:16,560 --> 00:16:18,660
protected storage for Secrets where a

459
00:16:18,660 --> 00:16:21,360
user when it would like to store a

460
00:16:21,360 --> 00:16:23,220
secret using Weber it submits password

461
00:16:23,220 --> 00:16:25,860
and secret and Weaver will store those

462
00:16:25,860 --> 00:16:27,660
objects in Secure flash in the plain

463
00:16:27,660 --> 00:16:28,620
text

464
00:16:28,620 --> 00:16:30,899
and when a user would like to retrieve

465
00:16:30,899 --> 00:16:32,760
the secret it submissive password waiver

466
00:16:32,760 --> 00:16:34,740
verifies password if it matches the

467
00:16:34,740 --> 00:16:37,019
record it Returns the secret by reading

468
00:16:37,019 --> 00:16:38,940
the plain text Data from The Flash

469
00:16:38,940 --> 00:16:40,680
if the password isn't correct obviously

470
00:16:40,680 --> 00:16:43,019
we refuses to return secret and then

471
00:16:43,019 --> 00:16:44,519
also throttles the consequent

472
00:16:44,519 --> 00:16:46,920
authentication attempts to prevent Brute

473
00:16:46,920 --> 00:16:49,259
Force attacks even with passwords uh

474
00:16:49,259 --> 00:16:51,480
with low entropy and at this point when

475
00:16:51,480 --> 00:16:53,940
we're able to run code arbitrary code on

476
00:16:53,940 --> 00:16:56,339
Titan M2 we basically your bypass waiver

477
00:16:56,339 --> 00:16:57,899
protection will read secret directly

478
00:16:57,899 --> 00:16:59,759
from The Flash and return it to the

479
00:16:59,759 --> 00:17:00,899
attacker

480
00:17:00,899 --> 00:17:02,579
and now let's take a look how it is

481
00:17:02,579 --> 00:17:04,319
possible because they're

482
00:17:04,319 --> 00:17:06,599
um identity is not able to read the

483
00:17:06,599 --> 00:17:08,280
secret directly from the reverse file

484
00:17:08,280 --> 00:17:10,319
system but there is a gap in the ACL

485
00:17:10,319 --> 00:17:12,900
policy so there are some ciscolls which

486
00:17:12,900 --> 00:17:16,020
enable to map The Flash page directly

487
00:17:16,020 --> 00:17:18,900
into the SRAM and as a result bypass

488
00:17:18,900 --> 00:17:21,359
this isolation ciscals exposed by the

489
00:17:21,359 --> 00:17:22,500
kernel

490
00:17:22,500 --> 00:17:24,660
and the identity task was actually able

491
00:17:24,660 --> 00:17:27,119
to call the Cisco so and here is how our

492
00:17:27,119 --> 00:17:29,400
Shell Code script looks like we first

493
00:17:29,400 --> 00:17:32,580
invoke flash map page to map the page

494
00:17:32,580 --> 00:17:34,860
with Weaver secrets into the SRAM of the

495
00:17:34,860 --> 00:17:37,620
identity task we use Cisco number two to

496
00:17:37,620 --> 00:17:39,120
allocate a short memory buffer which

497
00:17:39,120 --> 00:17:41,280
will be used to transfer data to the

498
00:17:41,280 --> 00:17:45,059
attacker Cisco number three is a signal

499
00:17:45,059 --> 00:17:48,000
to the technical that this operation is

500
00:17:48,000 --> 00:17:49,700
done and

501
00:17:49,700 --> 00:17:52,020
the title current will send data over

502
00:17:52,020 --> 00:17:53,820
spy bus to the attacker and step number

503
00:17:53,820 --> 00:17:56,039
four is put tighten them 2 into the

504
00:17:56,039 --> 00:17:57,240
Sleep state to prevent them from

505
00:17:57,240 --> 00:17:59,460
crashing because when the Titan will

506
00:17:59,460 --> 00:18:01,140
wake up from the Sleep state next time

507
00:18:01,140 --> 00:18:04,020
it will re-initialize the state of the

508
00:18:04,020 --> 00:18:06,240
tasks and step and we can replay our

509
00:18:06,240 --> 00:18:08,100
attack as many times as possible without

510
00:18:08,100 --> 00:18:11,760
crushing the Weaver and tightening and

511
00:18:11,760 --> 00:18:14,460
here is the final piece before we go to

512
00:18:14,460 --> 00:18:16,080
the attack is the actual the Rope

513
00:18:16,080 --> 00:18:17,400
gadgets that we use to run the Shell

514
00:18:17,400 --> 00:18:20,160
Code we had some small difficulty to

515
00:18:20,160 --> 00:18:22,320
find useful rub gadgets because we

516
00:18:22,320 --> 00:18:23,640
really wanted to Control Function

517
00:18:23,640 --> 00:18:25,679
argument registers and function in Risk

518
00:18:25,679 --> 00:18:27,480
5 architecture and this is something

519
00:18:27,480 --> 00:18:28,980
which is

520
00:18:28,980 --> 00:18:31,559
difficult to achieve

521
00:18:31,559 --> 00:18:33,539
um so we had four graduates in total

522
00:18:33,539 --> 00:18:35,340
Gadget number one will load save

523
00:18:35,340 --> 00:18:36,900
registers with the attacker control

524
00:18:36,900 --> 00:18:39,720
values then Gadget number two will load

525
00:18:39,720 --> 00:18:41,760
those saved registers into the function

526
00:18:41,760 --> 00:18:43,679
argument registers Gadget number three

527
00:18:43,679 --> 00:18:45,960
will be invoked in the Cisco and Gadget

528
00:18:45,960 --> 00:18:47,400
number four will start operation over

529
00:18:47,400 --> 00:18:49,919
because we want to invoke four Cisco's

530
00:18:49,919 --> 00:18:52,020
in in a row

531
00:18:52,020 --> 00:18:54,900
and we have all our ingredients ready to

532
00:18:54,900 --> 00:18:56,460
put our Tech together and show you the

533
00:18:56,460 --> 00:18:57,660
demo

534
00:18:57,660 --> 00:19:00,600
so we're in this case we're exploitation

535
00:19:00,600 --> 00:19:02,760
happens on Raven device which is pixel 6

536
00:19:02,760 --> 00:19:04,860
Pro and we are using Citadel updater

537
00:19:04,860 --> 00:19:08,039
command your readout the firmware

538
00:19:08,039 --> 00:19:10,260
version of the

539
00:19:10,260 --> 00:19:13,020
running on Titan 2 which we are given to

540
00:19:13,020 --> 00:19:15,299
your exploit in this case

541
00:19:15,299 --> 00:19:19,080
um so this is a retail firmware uh

542
00:19:19,080 --> 00:19:21,419
signed but your pre-production version

543
00:19:21,419 --> 00:19:24,240
before device is released

544
00:19:24,240 --> 00:19:26,460
and right now is the next step we will

545
00:19:26,460 --> 00:19:28,740
try to write a secret into the Weaver so

546
00:19:28,740 --> 00:19:30,720
our custom secret to simplify this work

547
00:19:30,720 --> 00:19:32,460
we developed a tool read dauntless flash

548
00:19:32,460 --> 00:19:34,440
which essentially communicates directly

549
00:19:34,440 --> 00:19:37,559
with Citadel Daemon and there well we

550
00:19:37,559 --> 00:19:39,120
need to have root preview just to run

551
00:19:39,120 --> 00:19:41,039
this so we use rightly recommend we

552
00:19:41,039 --> 00:19:42,840
provide three arguments the first

553
00:19:42,840 --> 00:19:44,760
argument is the slot number because we

554
00:19:44,760 --> 00:19:46,860
will have multiple slots the second

555
00:19:46,860 --> 00:19:49,440
argument is actually the password and

556
00:19:49,440 --> 00:19:51,780
the last argument is the secret which we

557
00:19:51,780 --> 00:19:54,179
would like to protect so 13 is a slot

558
00:19:54,179 --> 00:19:56,580
number uh this is our password and this

559
00:19:56,580 --> 00:19:58,200
is our secret

560
00:19:58,200 --> 00:20:01,200
and we return success so it means that

561
00:20:01,200 --> 00:20:02,880
our secrets are right now in Weaver

562
00:20:02,880 --> 00:20:04,919
right now we will use another command

563
00:20:04,919 --> 00:20:08,039
redweaver to retrieve the same secret

564
00:20:08,039 --> 00:20:10,860
and show that everything works correctly

565
00:20:10,860 --> 00:20:13,500
so we use read we recommend we provide

566
00:20:13,500 --> 00:20:15,539
the same slot number and we provide the

567
00:20:15,539 --> 00:20:18,240
same password and uh

568
00:20:18,240 --> 00:20:20,100
um waiver should be returning as our

569
00:20:20,100 --> 00:20:21,960
secret so we got our secret back from

570
00:20:21,960 --> 00:20:23,039
the Weaver

571
00:20:23,039 --> 00:20:24,900
right now we will do a little bit

572
00:20:24,900 --> 00:20:26,940
different we will

573
00:20:26,940 --> 00:20:29,160
we will essentially alter the password

574
00:20:29,160 --> 00:20:32,039
and right now Weber refuses to return to

575
00:20:32,039 --> 00:20:32,820
Secret

576
00:20:32,820 --> 00:20:34,559
would have been really weird if it

577
00:20:34,559 --> 00:20:36,419
provided Secret at this point

578
00:20:36,419 --> 00:20:39,419
um so or do it a few more times in a row

579
00:20:39,419 --> 00:20:42,299
uh to see how it throttles so right now

580
00:20:42,299 --> 00:20:44,039
after fifth unsuccessful attempt it

581
00:20:44,039 --> 00:20:45,960
tells us to wait 30 seconds

582
00:20:45,960 --> 00:20:48,780
but given that we're able to run code

583
00:20:48,780 --> 00:20:51,000
directly on Titan we will not be waiting

584
00:20:51,000 --> 00:20:52,679
soar we will be

585
00:20:52,679 --> 00:20:53,340
um

586
00:20:53,340 --> 00:20:55,620
sending our Shell Code exploit and

587
00:20:55,620 --> 00:20:57,900
vulnerability right away so we're using

588
00:20:57,900 --> 00:21:00,360
done flash command and Flash command

589
00:21:00,360 --> 00:21:02,160
takes two arguments the first argument

590
00:21:02,160 --> 00:21:04,500
is address of The Flash page which we

591
00:21:04,500 --> 00:21:06,059
would like to dump with Weaver secrets

592
00:21:06,059 --> 00:21:08,340
and then the number of bytes and hex to

593
00:21:08,340 --> 00:21:09,660
dump

594
00:21:09,660 --> 00:21:12,960
and as we run it uh here we go we have

595
00:21:12,960 --> 00:21:16,559
our secret red from the flash memory

596
00:21:16,559 --> 00:21:18,120
without providing passwords so we

597
00:21:18,120 --> 00:21:20,640
achieved our goal here

598
00:21:20,640 --> 00:21:22,440
and

599
00:21:22,440 --> 00:21:25,020
if we scroll up here here is actually

600
00:21:25,020 --> 00:21:27,299
the commands that we will burst we have

601
00:21:27,299 --> 00:21:29,280
mirror sending to Weaver uh to

602
00:21:29,280 --> 00:21:30,720
technology to exploit this vulnerability

603
00:21:30,720 --> 00:21:33,780
exactly the same six requests

604
00:21:33,780 --> 00:21:35,220
to your

605
00:21:35,220 --> 00:21:38,640
which we showed on previous slide

606
00:21:38,640 --> 00:21:40,740
and I think this is probably mostly it

607
00:21:40,740 --> 00:21:42,419
what I would like to say about Titan M2

608
00:21:42,419 --> 00:21:43,860
before I hand it off to Shawn I would

609
00:21:43,860 --> 00:21:45,240
like to say a few words that even though

610
00:21:45,240 --> 00:21:46,620
we were able to wear final

611
00:21:46,620 --> 00:21:48,539
vulnerabilities exploit them code to get

612
00:21:48,539 --> 00:21:51,000
code execution those issues are have

613
00:21:51,000 --> 00:21:53,100
been mitigated proactively before

614
00:21:53,100 --> 00:21:54,900
release of pixel 6 which made their

615
00:21:54,900 --> 00:21:57,720
Titanium 2 and pixel 6 more secure and

616
00:21:57,720 --> 00:21:59,940
more importantly we developed fuzzers

617
00:21:59,940 --> 00:22:02,100
which are up and running on the internal

618
00:22:02,100 --> 00:22:04,140
Android fuzzing infrastructure to

619
00:22:04,140 --> 00:22:05,760
provide continuous fuzzing and

620
00:22:05,760 --> 00:22:07,380
continuous security for taking them to

621
00:22:07,380 --> 00:22:08,280
Firmware

622
00:22:08,280 --> 00:22:12,139
and with that I'm transferring to Schwan

623
00:22:13,620 --> 00:22:17,100
hey thanks Eugene

624
00:22:17,100 --> 00:22:18,780
let's take a look at another component

625
00:22:18,780 --> 00:22:21,659
that we covered so this is AVL

626
00:22:21,659 --> 00:22:23,400
we're going through the very interesting

627
00:22:23,400 --> 00:22:25,679
issue that we discovered and show a code

628
00:22:25,679 --> 00:22:30,080
execution that based on this issue

629
00:22:30,960 --> 00:22:33,179
so here's a very high

630
00:22:33,179 --> 00:22:36,000
overly simplified boot sequence how

631
00:22:36,000 --> 00:22:39,120
pixel 6 works so the boot ROM starts at

632
00:22:39,120 --> 00:22:41,460
the beginning and it loads PBA or pr1

633
00:22:41,460 --> 00:22:43,919
and from there it initialized trust the

634
00:22:43,919 --> 00:22:46,260
environment and it also loads APR in

635
00:22:46,260 --> 00:22:48,720
non-secure DIY environment ABR will

636
00:22:48,720 --> 00:22:51,000
eventually jump to Android kernel but

637
00:22:51,000 --> 00:22:53,039
before doing that it also talks to

638
00:22:53,039 --> 00:22:54,780
trusty apps to secure some

639
00:22:54,780 --> 00:22:57,320
configurations

640
00:22:58,440 --> 00:23:00,960
and ABR is a very important piece in the

641
00:23:00,960 --> 00:23:03,419
Android boot chain for example it does

642
00:23:03,419 --> 00:23:05,280
lock down some security settings before

643
00:23:05,280 --> 00:23:07,200
kernel is loaded it implements the

644
00:23:07,200 --> 00:23:09,720
Android verify boot it of course loads a

645
00:23:09,720 --> 00:23:12,299
kernel and it also hosts our recovery

646
00:23:12,299 --> 00:23:14,220
environment which is fastboot

647
00:23:14,220 --> 00:23:17,100
and because of all that APR shows a

648
00:23:17,100 --> 00:23:18,720
bigger attack surface compared to other

649
00:23:18,720 --> 00:23:20,640
pool of the components

650
00:23:20,640 --> 00:23:22,679
for example in general recovery

651
00:23:22,679 --> 00:23:24,360
interface is a historical source of

652
00:23:24,360 --> 00:23:26,159
security issues especially for secure

653
00:23:26,159 --> 00:23:27,480
boot

654
00:23:27,480 --> 00:23:30,480
and also ADR is dealing with arbitrary

655
00:23:30,480 --> 00:23:33,360
user input via fastboot implementations

656
00:23:33,360 --> 00:23:36,600
and of course it also needs to load and

657
00:23:36,600 --> 00:23:39,059
update some Android configurations which

658
00:23:39,059 --> 00:23:41,159
are usually stored in the flash which is

659
00:23:41,159 --> 00:23:44,039
considered as an unsecured source

660
00:23:44,039 --> 00:23:46,500
and lastly APR is also responsible for

661
00:23:46,500 --> 00:23:48,960
loading and verifying kernel signatures

662
00:23:48,960 --> 00:23:52,820
which is another attack surface

663
00:23:53,039 --> 00:23:55,020
so because of all the other we include

664
00:23:55,020 --> 00:23:57,840
AVR into our engagement for this

665
00:23:57,840 --> 00:24:00,299
component there are some low level

666
00:24:00,299 --> 00:24:01,919
dependencies to Hardware so it's not

667
00:24:01,919 --> 00:24:04,020
easy to fast so we decide to go with

668
00:24:04,020 --> 00:24:06,120
manual code reviews

669
00:24:06,120 --> 00:24:08,460
for this engagement our main focus is

670
00:24:08,460 --> 00:24:10,559
actually on the fastboot handlers but

671
00:24:10,559 --> 00:24:12,720
while doing that we noticed a very

672
00:24:12,720 --> 00:24:14,460
interesting issue from our Eurotech

673
00:24:14,460 --> 00:24:16,140
surface

674
00:24:16,140 --> 00:24:18,840
which leads to our poc in this case so

675
00:24:18,840 --> 00:24:21,360
the issue we look into is the hip OB

676
00:24:21,360 --> 00:24:25,639
ride in the GPT practice handlers

677
00:24:25,799 --> 00:24:28,260
to demonstrate that we need to modify

678
00:24:28,260 --> 00:24:30,720
the GPT headers in Flash and we could

679
00:24:30,720 --> 00:24:32,640
install the chip modify the Flash and

680
00:24:32,640 --> 00:24:35,039
restarter it but that's destructive and

681
00:24:35,039 --> 00:24:38,159
technically it's hard to do that so we

682
00:24:38,159 --> 00:24:40,440
think okay let's step back and assuming

683
00:24:40,440 --> 00:24:42,120
we already have a good privilege what

684
00:24:42,120 --> 00:24:44,100
can we do we can probably modify the

685
00:24:44,100 --> 00:24:46,740
block devices directly and and then

686
00:24:46,740 --> 00:24:49,679
reboot to activate our attacks

687
00:24:49,679 --> 00:24:51,840
so that means we have a prerequisite is

688
00:24:51,840 --> 00:24:54,620
a root privilege

689
00:24:59,100 --> 00:25:01,860
code here's how the code looks like on

690
00:25:01,860 --> 00:25:03,720
the right side we have two structures

691
00:25:03,720 --> 00:25:06,419
defined according to the GPT format and

692
00:25:06,419 --> 00:25:08,760
on the left side we have a function

693
00:25:08,760 --> 00:25:11,880
parsing the GPD headers it does this by

694
00:25:11,880 --> 00:25:14,100
first allocating a maximum buffer that

695
00:25:14,100 --> 00:25:16,440
is able to holding the maximum allowed

696
00:25:16,440 --> 00:25:18,960
DVD entries and the calculation is Down

697
00:25:18,960 --> 00:25:21,299
based on the side of the structure and

698
00:25:21,299 --> 00:25:23,400
the maximum number of activity entries

699
00:25:23,400 --> 00:25:26,340
and after that it loads The Flash into

700
00:25:26,340 --> 00:25:28,860
this buffer however when doing the load

701
00:25:28,860 --> 00:25:30,179
instead of using the side of the

702
00:25:30,179 --> 00:25:32,760
structure and using the size declared in

703
00:25:32,760 --> 00:25:35,100
the header itself and the header is not

704
00:25:35,100 --> 00:25:38,400
very uh is not validated

705
00:25:38,400 --> 00:25:40,919
so in this case if we put a large value

706
00:25:40,919 --> 00:25:44,039
in the header or entry size we can trick

707
00:25:44,039 --> 00:25:46,380
the AVL to read more data than it should

708
00:25:46,380 --> 00:25:49,140
be into the buffer that creates a heat

709
00:25:49,140 --> 00:25:51,919
buff override

710
00:25:52,080 --> 00:25:54,720
so how do we explore this issue

711
00:25:54,720 --> 00:25:57,720
not two cents first ABR uses a linked

712
00:25:57,720 --> 00:25:59,760
list based Heap implementation so that

713
00:25:59,760 --> 00:26:01,679
means classic hip-hop overflow works

714
00:26:01,679 --> 00:26:02,700
here

715
00:26:02,700 --> 00:26:04,500
another thing I want to call it is that

716
00:26:04,500 --> 00:26:07,260
we have multiple flash disks on the on

717
00:26:07,260 --> 00:26:10,080
the device and every disk has a dpd

718
00:26:10,080 --> 00:26:11,940
header that means we can explore this

719
00:26:11,940 --> 00:26:15,360
issue multiple times not just once

720
00:26:15,360 --> 00:26:17,580
assuming that this is first time when

721
00:26:17,580 --> 00:26:20,880
the code runs and this is hip layout so

722
00:26:20,880 --> 00:26:23,100
we have a TPT entries pointed to the

723
00:26:23,100 --> 00:26:25,620
Adobe buffer and following that buffer

724
00:26:25,620 --> 00:26:28,740
is a free Block buffer and in the free

725
00:26:28,740 --> 00:26:30,720
Block there's a header showing the side

726
00:26:30,720 --> 00:26:33,240
of the free block and also the next free

727
00:26:33,240 --> 00:26:34,740
Block

728
00:26:34,740 --> 00:26:37,679
so we prepare our first GPD header so

729
00:26:37,679 --> 00:26:39,240
that after read

730
00:26:39,240 --> 00:26:41,760
it overrides this header and modifies

731
00:26:41,760 --> 00:26:44,220
the size to be a very small value and

732
00:26:44,220 --> 00:26:49,400
also modifies the P next to a stack area

733
00:26:49,980 --> 00:26:52,620
so next time when the code tries to load

734
00:26:52,620 --> 00:26:54,600
the next GPD header or try to allocate

735
00:26:54,600 --> 00:26:57,539
the same buffer from the Heap but

736
00:26:57,539 --> 00:26:59,100
because it modified the size to be a

737
00:26:59,100 --> 00:27:00,419
very small value it's not able to hold

738
00:27:00,419 --> 00:27:02,880
that so try to follow this chain to the

739
00:27:02,880 --> 00:27:04,799
next memory buffer which is the buffer

740
00:27:04,799 --> 00:27:07,260
we specified on step

741
00:27:07,260 --> 00:27:09,419
after reading GPD headers

742
00:27:09,419 --> 00:27:12,299
we overwrite the call frame that

743
00:27:12,299 --> 00:27:14,760
contains ARR and other registers from

744
00:27:14,760 --> 00:27:18,000
there we control our PC registers

745
00:27:18,000 --> 00:27:21,600
so starting from here we could just wrap

746
00:27:21,600 --> 00:27:24,659
our way to get our code executions

747
00:27:24,659 --> 00:27:26,520
and I guess first thing you would do is

748
00:27:26,520 --> 00:27:28,559
modify the MMA configurations to add to

749
00:27:28,559 --> 00:27:32,820
add more executable areas but we found

750
00:27:32,820 --> 00:27:35,400
well there's an easy way there's a

751
00:27:35,400 --> 00:27:37,980
incorrectly configured memory region

752
00:27:37,980 --> 00:27:39,600
which is marked and read write

753
00:27:39,600 --> 00:27:43,799
executable and its address is predefined

754
00:27:43,799 --> 00:27:47,159
so all we need is run our payload to

755
00:27:47,159 --> 00:27:49,679
this region and then jump to it so that

756
00:27:49,679 --> 00:27:53,840
gives our full control of abl

757
00:27:53,940 --> 00:27:56,039
in the real case there's always troubles

758
00:27:56,039 --> 00:27:58,919
we'll Implement that for example we have

759
00:27:58,919 --> 00:28:01,380
to be very careful we modify the GPD

760
00:28:01,380 --> 00:28:03,240
headers because if we modify it

761
00:28:03,240 --> 00:28:05,760
containing the PBR or other earlier

762
00:28:05,760 --> 00:28:07,679
stage bootloaders our device will be

763
00:28:07,679 --> 00:28:10,260
bricked it won't be getting through here

764
00:28:10,260 --> 00:28:12,720
now recovery from there without fastboot

765
00:28:12,720 --> 00:28:15,960
interface is not a good experience

766
00:28:15,960 --> 00:28:18,779
and the other thing is in APR there's a

767
00:28:18,779 --> 00:28:20,400
multi-threading happening so there's

768
00:28:20,400 --> 00:28:22,740
some synchronization environment we need

769
00:28:22,740 --> 00:28:26,179
to fix after we get into control

770
00:28:27,480 --> 00:28:29,820
so now we get code executions but what's

771
00:28:29,820 --> 00:28:32,760
impact remember we require root

772
00:28:32,760 --> 00:28:36,120
privilege and that is very close to a

773
00:28:36,120 --> 00:28:38,400
kernel and it's running a year when not

774
00:28:38,400 --> 00:28:41,120
secure so we get code execution

775
00:28:41,120 --> 00:28:43,679
eery input loader is that something

776
00:28:43,679 --> 00:28:46,020
better than codex extreme kernel yes

777
00:28:46,020 --> 00:28:48,600
first is we get full persistence by

778
00:28:48,600 --> 00:28:50,580
default because our attack is from flash

779
00:28:50,580 --> 00:28:52,919
it's by default survives the reboots and

780
00:28:52,919 --> 00:28:55,799
also even OT updates the next thing is

781
00:28:55,799 --> 00:28:57,360
that

782
00:28:57,360 --> 00:28:59,940
our bootloader can now run malicious

783
00:28:59,940 --> 00:29:02,880
kernel without violating a testation

784
00:29:02,880 --> 00:29:05,880
service integrity that's because this

785
00:29:05,880 --> 00:29:08,520
exploitation happens earlier than the

786
00:29:08,520 --> 00:29:10,320
key master initialization

787
00:29:10,320 --> 00:29:13,320
so that the exploit cash boost AVB

788
00:29:13,320 --> 00:29:15,539
measurement by providing expected hash

789
00:29:15,539 --> 00:29:18,840
OS patch lab or unlock status

790
00:29:18,840 --> 00:29:21,840
and from there the malicious kernel is

791
00:29:21,840 --> 00:29:23,700
allowed to use key Masters protective

792
00:29:23,700 --> 00:29:26,179
secrets

793
00:29:26,520 --> 00:29:30,860
so with that let's take a look at a demo

794
00:29:31,860 --> 00:29:34,200
so we have our pixel 6 device connected

795
00:29:34,200 --> 00:29:35,640
to the laptop

796
00:29:35,640 --> 00:29:37,799
and in theory we should we're supposed

797
00:29:37,799 --> 00:29:40,200
to use a root vulnerability first to get

798
00:29:40,200 --> 00:29:42,000
there but we didn't have one so we just

799
00:29:42,000 --> 00:29:44,279
use the debug build it gives us root

800
00:29:44,279 --> 00:29:46,980
access automatically but even with user

801
00:29:46,980 --> 00:29:48,720
debug build the device is still running

802
00:29:48,720 --> 00:29:51,600
a locked production sign for loader so

803
00:29:51,600 --> 00:29:54,779
we are still attacking the right target

804
00:29:54,779 --> 00:29:57,899
and our only operation here is to

805
00:29:57,899 --> 00:30:00,120
prepare our exploit and write to GPD

806
00:30:00,120 --> 00:30:04,140
headers we use ufs2 and ufs3 these two

807
00:30:04,140 --> 00:30:06,000
are proved working and all the other

808
00:30:06,000 --> 00:30:09,200
competitions will break the device

809
00:30:09,779 --> 00:30:12,000
and this is a done deal once we write

810
00:30:12,000 --> 00:30:13,559
that we reboot the device to activate

811
00:30:13,559 --> 00:30:15,960
the attack if it works it works if it

812
00:30:15,960 --> 00:30:19,220
doesn't we break our device

813
00:30:20,039 --> 00:30:22,740
so now we reboot into bootloader we do

814
00:30:22,740 --> 00:30:25,140
that because our payload is implemented

815
00:30:25,140 --> 00:30:27,600
as a fastboot Handler but in real

816
00:30:27,600 --> 00:30:29,279
scenario you don't have to do that you

817
00:30:29,279 --> 00:30:31,919
can just reboot into regular mode and

818
00:30:31,919 --> 00:30:34,200
our payload will still run

819
00:30:34,200 --> 00:30:37,380
so now that the device is rebooting and

820
00:30:37,380 --> 00:30:40,980
let's check first a secure boot element

821
00:30:40,980 --> 00:30:43,260
so it shows production that means the

822
00:30:43,260 --> 00:30:46,799
device security is still enabled

823
00:30:46,799 --> 00:30:50,658
and here's our bootloader version

824
00:30:53,520 --> 00:30:54,659
yeah for this one you're gonna have to

825
00:30:54,659 --> 00:30:56,159
trust me this is the retail version but

826
00:30:56,159 --> 00:30:58,580
loaders

827
00:30:59,520 --> 00:31:02,399
and now let's check our magic command

828
00:31:02,399 --> 00:31:06,199
we call it OEM rootkit

829
00:31:07,320 --> 00:31:10,380
yep so this icon shows okay our code is

830
00:31:10,380 --> 00:31:12,059
running ABR actually

831
00:31:12,059 --> 00:31:15,179
for demo purposes our rootkit Implement

832
00:31:15,179 --> 00:31:17,520
only two commands the first one is read

833
00:31:17,520 --> 00:31:21,379
arbitrary memory from the address

834
00:31:28,860 --> 00:31:31,020
and the other one is patch the memory

835
00:31:31,020 --> 00:31:33,779
with arbitrary values

836
00:31:33,779 --> 00:31:36,120
so this proves that we gain full control

837
00:31:36,120 --> 00:31:38,760
of abl and okay we can do whatever we

838
00:31:38,760 --> 00:31:41,100
want from there and if you reboot the

839
00:31:41,100 --> 00:31:44,940
device our attack is still there

840
00:31:44,940 --> 00:31:47,399
so let's conclude the demo

841
00:31:47,399 --> 00:31:49,620
the series we used for this demo the

842
00:31:49,620 --> 00:31:51,899
first one is OB right that's assessed as

843
00:31:51,899 --> 00:31:54,299
a high severity the other one is read

844
00:31:54,299 --> 00:31:56,039
write executable memory configurations

845
00:31:56,039 --> 00:31:58,679
which is also high and both issues are

846
00:31:58,679 --> 00:32:00,120
already patched and released on the

847
00:32:00,120 --> 00:32:02,159
device

848
00:32:02,159 --> 00:32:04,260
from here I'll head over to farzan for

849
00:32:04,260 --> 00:32:06,740
the conclusions

850
00:32:09,179 --> 00:32:11,279
all right thank you Sean all right so

851
00:32:11,279 --> 00:32:13,020
I'm just a brief concluding thoughts to

852
00:32:13,020 --> 00:32:14,580
leave some room from q a

853
00:32:14,580 --> 00:32:17,520
uh so our red team identified impactful

854
00:32:17,520 --> 00:32:19,620
issues during our pixel 6 reviews for

855
00:32:19,620 --> 00:32:21,059
those who have not yet invested in red

856
00:32:21,059 --> 00:32:22,620
teaming we highly encourage you to do it

857
00:32:22,620 --> 00:32:24,960
it provides that adversarial input into

858
00:32:24,960 --> 00:32:27,179
your security program on fuzzing the

859
00:32:27,179 --> 00:32:28,740
team continues to manually develop

860
00:32:28,740 --> 00:32:31,380
fuzzers that run in perpetuity uh so

861
00:32:31,380 --> 00:32:33,720
that helps us scale but despite that

862
00:32:33,720 --> 00:32:36,059
ability to scale a fuzzing ain't easy

863
00:32:36,059 --> 00:32:38,399
and so specifically a fuzzing bare metal

864
00:32:38,399 --> 00:32:40,020
code so having a good Hardware

865
00:32:40,020 --> 00:32:41,159
abstraction layer and good

866
00:32:41,159 --> 00:32:43,320
compartmentalization really helps uh

867
00:32:43,320 --> 00:32:46,020
that make that process easier for us

868
00:32:46,020 --> 00:32:48,000
uh mitigations while doing Security

869
00:32:48,000 --> 00:32:49,799
reviews we noticed a common theme when

870
00:32:49,799 --> 00:32:51,720
we were reviewing low-level components

871
00:32:51,720 --> 00:32:53,279
that there was some basic mitigations

872
00:32:53,279 --> 00:32:55,440
that were not implemented such as aslr

873
00:32:55,440 --> 00:32:57,299
so we're actually working with various

874
00:32:57,299 --> 00:32:59,340
feature teams to assess the feasibility

875
00:32:59,340 --> 00:33:02,299
of these moving forward

876
00:33:02,820 --> 00:33:04,919
and uh finally the the last Point we'd

877
00:33:04,919 --> 00:33:06,059
like to land is that we want to

878
00:33:06,059 --> 00:33:07,500
emphasize your pixel 6 is the most

879
00:33:07,500 --> 00:33:09,720
secure pixel to date uh sure we talked

880
00:33:09,720 --> 00:33:11,399
about impactful code execution bugs but

881
00:33:11,399 --> 00:33:13,260
again this is a good thing there's no

882
00:33:13,260 --> 00:33:14,940
bugless software and proactively

883
00:33:14,940 --> 00:33:16,740
identifying security issues like these

884
00:33:16,740 --> 00:33:18,240
that Sean and Eugene talked about

885
00:33:18,240 --> 00:33:20,880
through red teaming is a very positive

886
00:33:20,880 --> 00:33:22,260
benefit of having an offensive security

887
00:33:22,260 --> 00:33:23,399
program

888
00:33:23,399 --> 00:33:25,019
we're also being transparent about our

889
00:33:25,019 --> 00:33:27,000
process so the community grows from

890
00:33:27,000 --> 00:33:29,880
knowledge sharing we also encourage the

891
00:33:29,880 --> 00:33:31,679
folks out there to continue submitting

892
00:33:31,679 --> 00:33:34,440
to our vrp program we've had actually a

893
00:33:34,440 --> 00:33:37,440
pretty active uh researcher that's been

894
00:33:37,440 --> 00:33:39,240
submitting bugs I think the last two

895
00:33:39,240 --> 00:33:40,860
bugs they submitted were worth more than

896
00:33:40,860 --> 00:33:43,320
40K each so we decided to just hire that

897
00:33:43,320 --> 00:33:44,760
person instead of paying them out

898
00:33:44,760 --> 00:33:47,399
continuously probably better for the

899
00:33:47,399 --> 00:33:50,220
company big kudos to the Google pixel

900
00:33:50,220 --> 00:33:51,899
and Android feature teams they value

901
00:33:51,899 --> 00:33:54,600
security and support remediation work as

902
00:33:54,600 --> 00:33:57,059
if it was the next big priority feature

903
00:33:57,059 --> 00:33:59,159
and finally our work is never done right

904
00:33:59,159 --> 00:34:00,720
so we're already working closely with

905
00:34:00,720 --> 00:34:03,120
pixel in the Next Generation phone we

906
00:34:03,120 --> 00:34:04,559
have a presentation in the works on the

907
00:34:04,559 --> 00:34:06,179
pixel modem as well it's a lot of great

908
00:34:06,179 --> 00:34:07,799
work there it's a great point to land

909
00:34:07,799 --> 00:34:09,599
here at the end uh red teams in the

910
00:34:09,599 --> 00:34:11,219
industry often look at Products Post

911
00:34:11,219 --> 00:34:13,379
deployment uh you can get profound

912
00:34:13,379 --> 00:34:15,659
exponential impact if you integrate your

913
00:34:15,659 --> 00:34:17,399
red team into your software development

914
00:34:17,399 --> 00:34:18,960
life cycle so you can catch these issues

915
00:34:18,960 --> 00:34:21,480
of how to launch with that uh we'll move

916
00:34:21,480 --> 00:34:23,339
over to uh thank you everyone rather for

917
00:34:23,339 --> 00:34:26,659
your time we'll move over to q a

918
00:34:27,530 --> 00:34:30,639
[Music]

919
00:34:34,699 --> 00:34:37,759
thank you

