1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:11,059 --> 00:00:13,080
suggests we're going to discuss about

4
00:00:13,080 --> 00:00:15,420
fuzzing so it's a journey into phasing

5
00:00:15,420 --> 00:00:17,220
webassembly virtual machine

6
00:00:17,220 --> 00:00:21,960
so it will be mainly focus on the

7
00:00:21,960 --> 00:00:24,720
step the different step you need to do

8
00:00:24,720 --> 00:00:26,699
in order to do fuzzing when you are

9
00:00:26,699 --> 00:00:29,480
targeting a huge and complex

10
00:00:29,480 --> 00:00:31,740
Target that is in that case the web

11
00:00:31,740 --> 00:00:34,200
assembly virtual machine so of course we

12
00:00:34,200 --> 00:00:35,940
found bugs I will not discuss too much

13
00:00:35,940 --> 00:00:37,920
about them and even less about

14
00:00:37,920 --> 00:00:39,960
exploitation it's really more focused on

15
00:00:39,960 --> 00:00:42,540
fuzzing and I hope you will find a lot

16
00:00:42,540 --> 00:00:45,180
of interesting points to apply that on

17
00:00:45,180 --> 00:00:48,000
other targets so my name is Patrick I'm

18
00:00:48,000 --> 00:00:50,280
the founder and CEO of closing Labs so

19
00:00:50,280 --> 00:00:51,600
as the name suggests we are doing

20
00:00:51,600 --> 00:00:53,820
phasing and with the military research

21
00:00:53,820 --> 00:00:56,460
so mainly on I mean I would say

22
00:00:56,460 --> 00:00:59,160
different targets and the main goal for

23
00:00:59,160 --> 00:01:01,079
us is really to develop further custom

24
00:01:01,079 --> 00:01:04,619
further and also Custom Security tool so

25
00:01:04,619 --> 00:01:07,260
the main focus we are doing is mainly us

26
00:01:07,260 --> 00:01:10,140
to go and a browserver housing in

27
00:01:10,140 --> 00:01:11,820
general

28
00:01:11,820 --> 00:01:14,340
so a quick introduction to webassembly

29
00:01:14,340 --> 00:01:17,159
so webassembly have been introduced in

30
00:01:17,159 --> 00:01:22,500
2017 officially with the MVP 1.0 it's a

31
00:01:22,500 --> 00:01:24,720
binary instrumentation

32
00:01:24,720 --> 00:01:27,000
so in binary instrumentation format

33
00:01:27,000 --> 00:01:29,700
instruction format but it's just not a

34
00:01:29,700 --> 00:01:32,280
binary format it's a binary format plus

35
00:01:32,280 --> 00:01:36,420
a text-based representation plus a stack

36
00:01:36,420 --> 00:01:38,579
based virtual machine that means a

37
00:01:38,579 --> 00:01:41,400
complete architecture as itself

38
00:01:41,400 --> 00:01:44,100
so it's natively supported by all the

39
00:01:44,100 --> 00:01:46,400
major browsers since quite some time now

40
00:01:46,400 --> 00:01:49,140
and the main goal of webassembly is

41
00:01:49,140 --> 00:01:51,540
basically not to replace JavaScript is

42
00:01:51,540 --> 00:01:54,180
to be in addition to JavaScript in order

43
00:01:54,180 --> 00:01:58,320
to be more fast and so on

44
00:01:58,320 --> 00:02:01,380
so all webassembly works basically you

45
00:02:01,380 --> 00:02:03,180
have two steps the first one is

46
00:02:03,180 --> 00:02:04,860
basically the compilation so you have

47
00:02:04,860 --> 00:02:07,560
your classical piece of source code and

48
00:02:07,560 --> 00:02:09,538
you will compile that into webassembly

49
00:02:09,538 --> 00:02:11,940
it will be your compilation Target so

50
00:02:11,940 --> 00:02:14,220
there is some tools like llvms that

51
00:02:14,220 --> 00:02:16,140
actually supports webassembly as a

52
00:02:16,140 --> 00:02:19,080
Target and script 10 bin REM and and

53
00:02:19,080 --> 00:02:21,720
some others so at the end you have

54
00:02:21,720 --> 00:02:23,760
something like that like the Fibonacci

55
00:02:23,760 --> 00:02:26,520
function in C C plus plus or rest and

56
00:02:26,520 --> 00:02:28,379
you're going to compile that into the

57
00:02:28,379 --> 00:02:30,239
binary files that is the webassembly

58
00:02:30,239 --> 00:02:31,920
module

59
00:02:31,920 --> 00:02:34,080
on the other part you have the runtime

60
00:02:34,080 --> 00:02:36,239
and host environment so your web

61
00:02:36,239 --> 00:02:39,780
assembly VM that will actually take as

62
00:02:39,780 --> 00:02:41,940
an inputer webassembly module will

63
00:02:41,940 --> 00:02:46,500
decode and execute the module you have

64
00:02:46,500 --> 00:02:50,700
the most famous One let's say is V8 that

65
00:02:50,700 --> 00:02:52,560
actually contain a webassembly virtual

66
00:02:52,560 --> 00:02:54,900
machine and you have also like wasmer

67
00:02:54,900 --> 00:02:57,120
and wasn't time that are actually pretty

68
00:02:57,120 --> 00:02:58,400
famous

69
00:02:58,400 --> 00:03:00,840
so the way it's work when you are

70
00:03:00,840 --> 00:03:03,239
providing a webassembly module it will

71
00:03:03,239 --> 00:03:06,900
go to multiple stage so the first one is

72
00:03:06,900 --> 00:03:08,940
the decoding and the passing so from

73
00:03:08,940 --> 00:03:12,120
this binary format the webassembly vvm

74
00:03:12,120 --> 00:03:14,580
will actually create an internal module

75
00:03:14,580 --> 00:03:16,200
representation

76
00:03:16,200 --> 00:03:18,360
then it will do the validation phase

77
00:03:18,360 --> 00:03:20,760
meaning that it will decode the module

78
00:03:20,760 --> 00:03:23,640
and check for particular stuff like type

79
00:03:23,640 --> 00:03:25,980
checking and some others

80
00:03:25,980 --> 00:03:27,920
then you have the instantiation

81
00:03:27,920 --> 00:03:30,360
basically it will create a module

82
00:03:30,360 --> 00:03:31,680
instance and you will create some

83
00:03:31,680 --> 00:03:34,940
additional stuff so you can think of

84
00:03:34,940 --> 00:03:39,000
memories Global tables and some others

85
00:03:39,000 --> 00:03:42,420
so that's basically a quick overview of

86
00:03:42,420 --> 00:03:44,819
the VM and the host interaction and

87
00:03:44,819 --> 00:03:47,580
different object so in one side on the

88
00:03:47,580 --> 00:03:50,040
top you have a bunch of memories a bunch

89
00:03:50,040 --> 00:03:52,620
of globals and tables those one are

90
00:03:52,620 --> 00:03:55,080
created by the host

91
00:03:55,080 --> 00:03:57,959
and basically this one will be shared to

92
00:03:57,959 --> 00:04:00,840
the web assembly instance that is at the

93
00:04:00,840 --> 00:04:01,980
bottom

94
00:04:01,980 --> 00:04:03,780
the webassem resistance is actually

95
00:04:03,780 --> 00:04:05,819
immutable meaning that once the

96
00:04:05,819 --> 00:04:08,340
webassembly module is loaded and

97
00:04:08,340 --> 00:04:11,159
instantiated there is no way to modify

98
00:04:11,159 --> 00:04:13,920
the function body the function contact

99
00:04:13,920 --> 00:04:16,260
the indirect function table and the

100
00:04:16,260 --> 00:04:19,380
execution stack it's not a classic stack

101
00:04:19,380 --> 00:04:21,358
I mean it's a stack for

102
00:04:21,358 --> 00:04:24,900
um like you just push and pop some data

103
00:04:24,900 --> 00:04:27,600
on it so it's kind of really Limited in

104
00:04:27,600 --> 00:04:30,300
that way so that's why we are telling

105
00:04:30,300 --> 00:04:32,759
that actually webassembly is sandboxed

106
00:04:32,759 --> 00:04:36,240
that's typically for this kind of reason

107
00:04:36,240 --> 00:04:39,419
finally once the webassembly module is

108
00:04:39,419 --> 00:04:42,180
ready to go you have the execution and

109
00:04:42,180 --> 00:04:44,460
in that case the host will maybe provide

110
00:04:44,460 --> 00:04:47,880
some argument to a specific function

111
00:04:47,880 --> 00:04:51,120
that will be exported and then it will

112
00:04:51,120 --> 00:04:53,759
run the webassembly module the specific

113
00:04:53,759 --> 00:04:57,960
byte code of webassembly and do the job

114
00:04:57,960 --> 00:05:01,020
so in terms of so that's just the

115
00:05:01,020 --> 00:05:02,699
webassembly VM and of course this

116
00:05:02,699 --> 00:05:05,639
webassembly VM will need a host a host

117
00:05:05,639 --> 00:05:08,340
environment so usually we are speaking

118
00:05:08,340 --> 00:05:10,500
about browsers like what I've done at

119
00:05:10,500 --> 00:05:12,660
the beginning but it's not the only us

120
00:05:12,660 --> 00:05:14,699
that is actually running webassembly VM

121
00:05:14,699 --> 00:05:18,860
one other case is basically blockchains

122
00:05:18,860 --> 00:05:21,540
that can use webassembly VM for like

123
00:05:21,540 --> 00:05:24,780
smart contracts in in general and there

124
00:05:24,780 --> 00:05:27,060
is plenty of other one

125
00:05:27,060 --> 00:05:29,759
for Standalone VM so that's this case so

126
00:05:29,759 --> 00:05:31,680
you can think of a webassembly VM that

127
00:05:31,680 --> 00:05:33,720
is running on the server you can think

128
00:05:33,720 --> 00:05:37,620
of edge Computing iot blockchain node.js

129
00:05:37,620 --> 00:05:39,840
that is actually running a web assembly

130
00:05:39,840 --> 00:05:43,199
as well over V8 and so on on the browser

131
00:05:43,199 --> 00:05:43,940
side

132
00:05:43,940 --> 00:05:46,979
you have a bunch of applications that

133
00:05:46,979 --> 00:05:49,139
actually really leverage on webassembly

134
00:05:49,139 --> 00:05:51,060
you can think of everything that is

135
00:05:51,060 --> 00:05:54,300
really intensive in computation like

136
00:05:54,300 --> 00:05:56,699
video audio image processing this kind

137
00:05:56,699 --> 00:05:59,820
of stuff video game and also complex web

138
00:05:59,820 --> 00:06:02,960
apps see like Google Earth for example

139
00:06:02,960 --> 00:06:07,020
to give you a quick history Google Earth

140
00:06:07,020 --> 00:06:09,720
before was only available on Chrome

141
00:06:09,720 --> 00:06:11,460
because it was using something called

142
00:06:11,460 --> 00:06:13,740
native clients that was like a precursor

143
00:06:13,740 --> 00:06:16,380
of webassembly but since they switched

144
00:06:16,380 --> 00:06:19,560
back they evolved into webassembly it's

145
00:06:19,560 --> 00:06:21,300
not possible to for you to run Google

146
00:06:21,300 --> 00:06:23,639
Earth and whatever web browser that

147
00:06:23,639 --> 00:06:26,340
support webassembly

148
00:06:26,340 --> 00:06:28,919
so in this talk we're gonna mainly focus

149
00:06:28,919 --> 00:06:31,560
on this part that means providing a web

150
00:06:31,560 --> 00:06:33,960
assembly module to the Target that will

151
00:06:33,960 --> 00:06:36,240
be the virtual machine

152
00:06:36,240 --> 00:06:39,000
and our final goal will be Italy to find

153
00:06:39,000 --> 00:06:41,280
bugs in all those different stage so

154
00:06:41,280 --> 00:06:43,979
that's what we're gonna do and my goal

155
00:06:43,979 --> 00:06:46,699
is to show you how you can basically

156
00:06:46,699 --> 00:06:50,280
improve your fuzzing process over time

157
00:06:50,280 --> 00:06:54,120
to basically reach more in the paths

158
00:06:54,120 --> 00:06:57,060
into the webassembly VM

159
00:06:57,060 --> 00:06:59,280
so the first technique I used was

160
00:06:59,280 --> 00:07:01,259
coverage guided fuzzing it's

161
00:07:01,259 --> 00:07:04,080
pretty easy the main reason for that is

162
00:07:04,080 --> 00:07:06,000
since the first stage is actually the

163
00:07:06,000 --> 00:07:08,160
decoding of a binary coverage guided

164
00:07:08,160 --> 00:07:10,440
phasing is actually switching pretty

165
00:07:10,440 --> 00:07:11,280
well

166
00:07:11,280 --> 00:07:13,259
so the main goal for us will be to

167
00:07:13,259 --> 00:07:15,600
provide a corporate so the Corpus that

168
00:07:15,600 --> 00:07:16,979
will be contained that will contain

169
00:07:16,979 --> 00:07:19,500
webassembly module basically we're going

170
00:07:19,500 --> 00:07:21,599
to provide that to a further the further

171
00:07:21,599 --> 00:07:23,580
will do the mutation meaning that it

172
00:07:23,580 --> 00:07:26,520
will add Randomness into the webassembly

173
00:07:26,520 --> 00:07:28,860
binary and then it will provide that to

174
00:07:28,860 --> 00:07:30,900
the webassembly vvm

175
00:07:30,900 --> 00:07:33,300
at the same time you were monitoring the

176
00:07:33,300 --> 00:07:36,360
coverage so we monitor oh deep and or

177
00:07:36,360 --> 00:07:38,759
interesting this sample is and based on

178
00:07:38,759 --> 00:07:41,520
that we will either classify that as an

179
00:07:41,520 --> 00:07:44,039
interesting sample if we get a crush we

180
00:07:44,039 --> 00:07:46,380
are keeping the crash on one side and so

181
00:07:46,380 --> 00:07:50,039
on so it's basically the way it works

182
00:07:50,039 --> 00:07:52,380
so for the input I mentioned the web

183
00:07:52,380 --> 00:07:55,199
does only binary format so it's not that

184
00:07:55,199 --> 00:07:56,819
complicated if you take a look at the

185
00:07:56,819 --> 00:07:58,919
structure you have one Adder that is

186
00:07:58,919 --> 00:08:01,800
composed of one magic number A plus a

187
00:08:01,800 --> 00:08:04,199
version so the magic number is a null

188
00:08:04,199 --> 00:08:05,819
byte Asm

189
00:08:05,819 --> 00:08:08,880
and then you have 11 sections that are

190
00:08:08,880 --> 00:08:11,400
unique and one custom section that can

191
00:08:11,400 --> 00:08:16,460
be in a limited amount of time

192
00:08:16,620 --> 00:08:18,720
so the first Target I first was

193
00:08:18,720 --> 00:08:21,000
basically a bunch of Standalone VM and

194
00:08:21,000 --> 00:08:23,699
passing libraries so mainly written in C

195
00:08:23,699 --> 00:08:26,099
and C plus plus the main reason for that

196
00:08:26,099 --> 00:08:30,000
is I was working a lot on reversing and

197
00:08:30,000 --> 00:08:32,219
Analysis of web assembly module so I was

198
00:08:32,219 --> 00:08:35,039
using those tool and I decided that it

199
00:08:35,039 --> 00:08:37,080
could be a good shot to actually fuss

200
00:08:37,080 --> 00:08:40,740
them at the same time so I Target on I

201
00:08:40,740 --> 00:08:44,219
Target basically been a VM webm3 and

202
00:08:44,219 --> 00:08:47,640
some other and even redirect2 since I

203
00:08:47,640 --> 00:08:51,300
was using that for reversing as well

204
00:08:51,300 --> 00:08:54,300
so nothing complicated I mean I will not

205
00:08:54,300 --> 00:08:55,740
focus too much on that that's the

206
00:08:55,740 --> 00:08:57,480
classical stuff if you are doing phasing

207
00:08:57,480 --> 00:09:00,360
coverage guided fuzzing I've used AFL on

208
00:09:00,360 --> 00:09:03,120
First and AFL plus Blues my favorite is

209
00:09:03,120 --> 00:09:05,339
actually on first but AFL plus first is

210
00:09:05,339 --> 00:09:08,519
definitely a good content there and

211
00:09:08,519 --> 00:09:12,959
after running a bunch of stuff and just

212
00:09:12,959 --> 00:09:15,660
basically instrumenting the target using

213
00:09:15,660 --> 00:09:18,600
the class the custom version the custom

214
00:09:18,600 --> 00:09:22,380
GCC or clang of unk's first or AFL I was

215
00:09:22,380 --> 00:09:24,240
able to basically make those stuff to

216
00:09:24,240 --> 00:09:26,040
run and already start to find some

217
00:09:26,040 --> 00:09:29,160
crashes so it was really easy not that

218
00:09:29,160 --> 00:09:32,640
complicated so that's the good part the

219
00:09:32,640 --> 00:09:34,620
actually most complicated part is

220
00:09:34,620 --> 00:09:36,899
actually include the traging because I

221
00:09:36,899 --> 00:09:38,640
was triggering a lot of different bugs

222
00:09:38,640 --> 00:09:43,260
so I report a bunch of them already and

223
00:09:43,260 --> 00:09:45,839
as you can see the most common bug that

224
00:09:45,839 --> 00:09:48,300
we actually found was out of born

225
00:09:48,300 --> 00:09:51,240
semester gener

226
00:09:51,240 --> 00:09:54,360
and so on so that was the common bugs at

227
00:09:54,360 --> 00:09:56,100
this stage that is in that case the

228
00:09:56,100 --> 00:09:59,760
parsing of the web assembly module

229
00:09:59,760 --> 00:10:02,399
so the first Improvement I've made in my

230
00:10:02,399 --> 00:10:04,800
phrasing strategy was basically to reuse

231
00:10:04,800 --> 00:10:06,720
the corporate between all Targets the

232
00:10:06,720 --> 00:10:09,180
main reason of that is since all those

233
00:10:09,180 --> 00:10:12,060
targets are written differently they

234
00:10:12,060 --> 00:10:14,160
follow the same specification but the

235
00:10:14,160 --> 00:10:16,440
implementation is different so there is

236
00:10:16,440 --> 00:10:20,100
a clear real value of reusing one

237
00:10:20,100 --> 00:10:23,640
corpora to another because what one tool

238
00:10:23,640 --> 00:10:25,740
will do in terms of the CFG and so on

239
00:10:25,740 --> 00:10:27,959
and the different checks it will do will

240
00:10:27,959 --> 00:10:30,120
might might not be the same as another

241
00:10:30,120 --> 00:10:32,760
one so it was the first step and then

242
00:10:32,760 --> 00:10:35,040
the second step was also to add all the

243
00:10:35,040 --> 00:10:37,260
crashes that iPhone on one sample

244
00:10:37,260 --> 00:10:39,779
directly into the global corpora that I

245
00:10:39,779 --> 00:10:42,600
was using again the main reason is it

246
00:10:42,600 --> 00:10:44,700
might be a crash for one program but it

247
00:10:44,700 --> 00:10:46,500
could be a really interesting sample for

248
00:10:46,500 --> 00:10:49,079
another one so there is no reason I have

249
00:10:49,079 --> 00:10:52,099
I'm not doing that

250
00:10:52,260 --> 00:10:55,320
then I decided to do in-process fuzzing

251
00:10:55,320 --> 00:10:58,740
so in process fuzzing is basically let's

252
00:10:58,740 --> 00:10:59,839
say

253
00:10:59,839 --> 00:11:03,060
optimized way to do fuzzing the main

254
00:11:03,060 --> 00:11:04,800
goal is basically you will get your

255
00:11:04,800 --> 00:11:06,779
further that will actually run your

256
00:11:06,779 --> 00:11:08,700
Target in the same process so it will be

257
00:11:08,700 --> 00:11:12,420
way faster and in that case you don't

258
00:11:12,420 --> 00:11:14,959
need to restart the process you can just

259
00:11:14,959 --> 00:11:17,880
for every test cases replace them in

260
00:11:17,880 --> 00:11:20,399
memory and provide that to to your

261
00:11:20,399 --> 00:11:22,920
Target and so on and so on so it's way

262
00:11:22,920 --> 00:11:25,019
faster the main reason I've been doing

263
00:11:25,019 --> 00:11:28,320
that only on reverse and python since I

264
00:11:28,320 --> 00:11:30,839
was already playing with CNC plus plus

265
00:11:30,839 --> 00:11:33,360
and finding bugs it was

266
00:11:33,360 --> 00:11:36,060
not worth it at the time to basically

267
00:11:36,060 --> 00:11:38,399
create fuzzing harnesses for for them it

268
00:11:38,399 --> 00:11:40,380
was already working well I mean I was

269
00:11:40,380 --> 00:11:42,180
happy with the result so

270
00:11:42,180 --> 00:11:43,860
um I decided that it was the good shot

271
00:11:43,860 --> 00:11:46,980
to actually Target something else and

272
00:11:46,980 --> 00:11:49,680
basically try some other tools so in

273
00:11:49,680 --> 00:11:52,079
that case I first the Standalone VM and

274
00:11:52,079 --> 00:11:55,560
passing Library mainly on Rust so you

275
00:11:55,560 --> 00:11:57,420
can think of wasmail wasam time was

276
00:11:57,420 --> 00:12:00,600
Ambassador and so on so this kind of web

277
00:12:00,600 --> 00:12:03,899
assembly runtime and Standalone VM

278
00:12:03,899 --> 00:12:06,240
and I also Target two other tools that I

279
00:12:06,240 --> 00:12:09,000
was using like piwazam that is a python

280
00:12:09,000 --> 00:12:10,380
interpreter

281
00:12:10,380 --> 00:12:13,019
and webassembly.js that is a JavaScript

282
00:12:13,019 --> 00:12:17,100
library for webassemian Channel

283
00:12:17,100 --> 00:12:19,560
so the result of that when you are doing

284
00:12:19,560 --> 00:12:21,420
in-process phasing on the rest you have

285
00:12:21,420 --> 00:12:23,399
a bunch of tools that are available the

286
00:12:23,399 --> 00:12:25,380
funny part is actually those tools are

287
00:12:25,380 --> 00:12:28,079
binding to the classical CNC plus plus

288
00:12:28,079 --> 00:12:30,720
tool so if you are already familiar with

289
00:12:30,720 --> 00:12:32,820
them it should be pretty easy for you to

290
00:12:32,820 --> 00:12:35,519
basically ramp up into a rest in process

291
00:12:35,519 --> 00:12:37,920
fuzzing so I was using cargo first on

292
00:12:37,920 --> 00:12:41,640
first rust and AFL West and the main

293
00:12:41,640 --> 00:12:43,860
part in that case is to write the

294
00:12:43,860 --> 00:12:46,260
phasing harness so with some log the

295
00:12:46,260 --> 00:12:48,420
documentation is pretty good but even in

296
00:12:48,420 --> 00:12:50,040
that case I mean Rusty is not that

297
00:12:50,040 --> 00:12:53,100
complicated to to read so you can it's

298
00:12:53,100 --> 00:12:55,860
pretty straightforward and most of the

299
00:12:55,860 --> 00:12:58,019
time the name of the function are pretty

300
00:12:58,019 --> 00:13:00,120
clear of what it's doing

301
00:13:00,120 --> 00:13:02,880
so I've made that for basically all the

302
00:13:02,880 --> 00:13:05,820
target I was mentioning previously so a

303
00:13:05,820 --> 00:13:08,579
bunch of facing RMS and then I was

304
00:13:08,579 --> 00:13:10,500
running the stuff so it was not that

305
00:13:10,500 --> 00:13:12,720
complex uh what you just need to write

306
00:13:12,720 --> 00:13:15,660
the phasing RNs learn a bit or to to

307
00:13:15,660 --> 00:13:18,000
play with the framework and you are good

308
00:13:18,000 --> 00:13:19,980
to go

309
00:13:19,980 --> 00:13:23,399
for python MGS I was using asterisk so

310
00:13:23,399 --> 00:13:25,740
it's a python fuzzing framework it's

311
00:13:25,740 --> 00:13:28,740
actually based on lip fuzzer and GS

312
00:13:28,740 --> 00:13:31,260
files so again you just need to write

313
00:13:31,260 --> 00:13:34,019
the facing RNs so you don't need to know

314
00:13:34,019 --> 00:13:37,100
exactly all the language work and the

315
00:13:37,100 --> 00:13:39,120
expert in development and reduce

316
00:13:39,120 --> 00:13:42,360
language you follow while the black

317
00:13:42,360 --> 00:13:44,820
fuzzing on this template and then you

318
00:13:44,820 --> 00:13:47,519
you are more or less good to go so the

319
00:13:47,519 --> 00:13:50,339
result of that was like 62 bucks uh

320
00:13:50,339 --> 00:13:53,100
mainly on Rust actually

321
00:13:53,100 --> 00:13:55,980
um and the type of bug I actually found

322
00:13:55,980 --> 00:13:59,399
was a panicking macros index out of bond

323
00:13:59,399 --> 00:14:03,000
unwrapping overflows and so on so just

324
00:14:03,000 --> 00:14:04,139
to mention

325
00:14:04,139 --> 00:14:06,180
um we say that rest is memory safe

326
00:14:06,180 --> 00:14:08,760
that's true but it doesn't mean there is

327
00:14:08,760 --> 00:14:11,579
no availability typically this one in

328
00:14:11,579 --> 00:14:15,180
the context of a CLI application it's

329
00:14:15,180 --> 00:14:18,360
it's not critical but if you are using

330
00:14:18,360 --> 00:14:20,700
that in a library on a server and you

331
00:14:20,700 --> 00:14:22,680
are able to trigger a panic in rest that

332
00:14:22,680 --> 00:14:24,899
means you are crushing the server and

333
00:14:24,899 --> 00:14:26,760
for blockchain software in the same way

334
00:14:26,760 --> 00:14:28,800
you are crushing the whole network or at

335
00:14:28,800 --> 00:14:31,380
least the node so that's clearly

336
00:14:31,380 --> 00:14:33,899
critical and that's really important to

337
00:14:33,899 --> 00:14:37,040
to have that in mind

338
00:14:37,560 --> 00:14:40,920
so the Improvement I made at this point

339
00:14:40,920 --> 00:14:43,740
was basically to improve my corpora I

340
00:14:43,740 --> 00:14:46,139
was reaching a point where actually the

341
00:14:46,139 --> 00:14:49,380
coverage was not evolving that much so I

342
00:14:49,380 --> 00:14:51,600
basically took a look at the official

343
00:14:51,600 --> 00:14:55,019
test Suite of webassembly and also at

344
00:14:55,019 --> 00:14:57,120
some existing phasing Copperas that was

345
00:14:57,120 --> 00:15:00,600
available on GitHub and I add that to my

346
00:15:00,600 --> 00:15:04,019
copies again the main goal is

347
00:15:04,019 --> 00:15:08,339
I maybe have won a specific binary that

348
00:15:08,339 --> 00:15:10,440
will actually contain a dedicated

349
00:15:10,440 --> 00:15:12,959
feature on webassembly that I was not

350
00:15:12,959 --> 00:15:16,199
aware of and it's maybe worth it to put

351
00:15:16,199 --> 00:15:18,620
it in place

352
00:15:18,740 --> 00:15:22,019
then we are going to the validation

353
00:15:22,019 --> 00:15:24,360
phase so I've been fuzzing a lot the

354
00:15:24,360 --> 00:15:28,380
decoding Parts finding a lot of bugs but

355
00:15:28,380 --> 00:15:30,240
then I reached the point where basically

356
00:15:30,240 --> 00:15:33,060
my web assembly module was

357
00:15:33,060 --> 00:15:35,339
correct in term of the structure the

358
00:15:35,339 --> 00:15:37,139
binary structure but in terms of the

359
00:15:37,139 --> 00:15:40,680
content there was invalid so the first

360
00:15:40,680 --> 00:15:42,720
step of course is to add some new

361
00:15:42,720 --> 00:15:45,300
fuzzing harnesses dedicated to First

362
00:15:45,300 --> 00:15:47,540
deuce on tripods that are the validation

363
00:15:47,540 --> 00:15:52,380
function and then I decide to also take

364
00:15:52,380 --> 00:15:54,959
a look a bit more at the validation

365
00:15:54,959 --> 00:15:57,420
mechanism to learn a bit more which kind

366
00:15:57,420 --> 00:16:00,420
of stuff was actually checked at this

367
00:16:00,420 --> 00:16:02,820
point so there is a bunch of stuff like

368
00:16:02,820 --> 00:16:07,620
the type the especially the type and the

369
00:16:07,620 --> 00:16:10,079
kind of op code and also interact with

370
00:16:10,079 --> 00:16:12,839
each other so there is a huge work on

371
00:16:12,839 --> 00:16:15,779
that and it's really interesting uh to

372
00:16:15,779 --> 00:16:19,260
to learn more from this from this stuff

373
00:16:19,260 --> 00:16:23,279
so photogram are best fuzzing usually we

374
00:16:23,279 --> 00:16:26,160
are writing a grammar and so on so I've

375
00:16:26,160 --> 00:16:28,260
used grammar based using in a bit

376
00:16:28,260 --> 00:16:31,139
different way in that case my goal since

377
00:16:31,139 --> 00:16:32,660
we have the

378
00:16:32,660 --> 00:16:35,639
webassembly text format available that

379
00:16:35,639 --> 00:16:38,759
is called the what I decide to grab all

380
00:16:38,759 --> 00:16:41,699
the what files that I was able to find

381
00:16:41,699 --> 00:16:45,480
and using some tool to basically convert

382
00:16:45,480 --> 00:16:48,899
its text format into webassembly module

383
00:16:48,899 --> 00:16:51,839
so that's the good part with these

384
00:16:51,839 --> 00:16:54,180
specifications that have been designed

385
00:16:54,180 --> 00:16:57,000
like that in mind at the beginning you

386
00:16:57,000 --> 00:16:59,579
can go from a what file to text format

387
00:16:59,579 --> 00:17:02,519
that is on the right easily to the

388
00:17:02,519 --> 00:17:05,699
binary format and so on so we can also

389
00:17:05,699 --> 00:17:08,220
and that's been for us for debugging and

390
00:17:08,220 --> 00:17:11,220
even to write some edge cases use this

391
00:17:11,220 --> 00:17:13,500
text format representation

392
00:17:13,500 --> 00:17:16,020
so it looked like that it's not that

393
00:17:16,020 --> 00:17:18,660
complicated you have the next s

394
00:17:18,660 --> 00:17:21,599
expression like to basically Define the

395
00:17:21,599 --> 00:17:24,240
module section and so on and then you

396
00:17:24,240 --> 00:17:26,099
have a linear representation that will

397
00:17:26,099 --> 00:17:27,839
contain the function body and the low

398
00:17:27,839 --> 00:17:30,179
level instruction so it's pretty easy to

399
00:17:30,179 --> 00:17:31,919
read to be honest I mean if you want to

400
00:17:31,919 --> 00:17:34,799
do reversing on that it's definitely not

401
00:17:34,799 --> 00:17:36,960
that complicated if you are doing a bit

402
00:17:36,960 --> 00:17:38,400
of reversing

403
00:17:38,400 --> 00:17:41,460
in terms of the MVP instruction set it

404
00:17:41,460 --> 00:17:43,860
was not that big the data type are

405
00:17:43,860 --> 00:17:47,520
pretty limited it's basically integral

406
00:17:47,520 --> 00:17:49,740
you have some control flow operator

407
00:17:49,740 --> 00:17:51,419
that's why it's a turing complete

408
00:17:51,419 --> 00:17:52,980
instruction set

409
00:17:52,980 --> 00:17:55,740
you have some memory operators to load

410
00:17:55,740 --> 00:17:57,780
and store from the memory some local and

411
00:17:57,780 --> 00:18:00,059
Global variable some arithmetic

412
00:18:00,059 --> 00:18:02,100
operators constant and also some

413
00:18:02,100 --> 00:18:04,380
conversion operators that basically

414
00:18:04,380 --> 00:18:06,000
allow you to switch from let's say

415
00:18:06,000 --> 00:18:09,840
float32 to integer 64.

416
00:18:09,840 --> 00:18:11,760
so when I said that actually the

417
00:18:11,760 --> 00:18:13,140
instruction set is not that too

418
00:18:13,140 --> 00:18:15,780
complicated that's why for example the

419
00:18:15,780 --> 00:18:18,480
for the integer 32 and the integer 64

420
00:18:18,480 --> 00:18:20,520
that's basically the exact same up code

421
00:18:20,520 --> 00:18:22,980
it's just that is specific for one

422
00:18:22,980 --> 00:18:25,740
format or another so there is

423
00:18:25,740 --> 00:18:28,320
let's say already Alpha do stuff that

424
00:18:28,320 --> 00:18:30,480
are actually pretty redundant and easy

425
00:18:30,480 --> 00:18:33,299
to understand

426
00:18:33,299 --> 00:18:35,460
so by doing that I actually found some

427
00:18:35,460 --> 00:18:37,320
vulnerability more or less by accident

428
00:18:37,320 --> 00:18:39,780
because when I was converting this what

429
00:18:39,780 --> 00:18:42,960
file into webassembly module I was at

430
00:18:42,960 --> 00:18:44,340
the same time doing some phrasing

431
00:18:44,340 --> 00:18:46,980
because why not and actually found some

432
00:18:46,980 --> 00:18:51,000
bugs inside so it was mainly assertion

433
00:18:51,000 --> 00:18:53,880
failure and one out of bond memory error

434
00:18:53,880 --> 00:18:56,820
so not that interesting and especially

435
00:18:56,820 --> 00:19:00,960
even the tools are not supposed to be

436
00:19:00,960 --> 00:19:04,140
run into a server and so on so even the

437
00:19:04,140 --> 00:19:06,600
impact was not that interesting but I

438
00:19:06,600 --> 00:19:08,700
mean there's still some free bugs so why

439
00:19:08,700 --> 00:19:10,440
not

440
00:19:10,440 --> 00:19:13,140
so the strategy Improvement I've made in

441
00:19:13,140 --> 00:19:15,960
that case what was since I was aware of

442
00:19:15,960 --> 00:19:17,820
the text format and the internal

443
00:19:17,820 --> 00:19:20,520
structure I decided to try to write

444
00:19:20,520 --> 00:19:22,940
write some edge cases about that

445
00:19:22,940 --> 00:19:25,500
typically I mentioned there is some

446
00:19:25,500 --> 00:19:27,539
section and this section are unique so

447
00:19:27,539 --> 00:19:29,460
what is happening basically if you try

448
00:19:29,460 --> 00:19:31,140
to duplicate the unique one and the

449
00:19:31,140 --> 00:19:33,780
custom one I try to change the ordering

450
00:19:33,780 --> 00:19:37,140
to see if some tools are actually

451
00:19:37,140 --> 00:19:40,020
dependent of that and so on and so on I

452
00:19:40,020 --> 00:19:42,480
even create a polygrot webassembly

453
00:19:42,480 --> 00:19:44,340
module that is at the same time a valid

454
00:19:44,340 --> 00:19:47,520
HTML file and a valid webassembly module

455
00:19:47,520 --> 00:19:51,900
just for fun but actually at TNN sync I

456
00:19:51,900 --> 00:19:54,419
found any box with that but at least it

457
00:19:54,419 --> 00:19:56,760
was funny

458
00:19:56,760 --> 00:20:00,179
so it was the first step I got even more

459
00:20:00,179 --> 00:20:03,059
stuff in my copper that's good but it's

460
00:20:03,059 --> 00:20:05,220
still not enough uh I mean when I'm

461
00:20:05,220 --> 00:20:07,140
fuzzing in that case at this moment

462
00:20:07,140 --> 00:20:09,419
that's mean I will be stuck I will

463
00:20:09,419 --> 00:20:11,820
always go to the decoding phases

464
00:20:11,820 --> 00:20:14,280
and then going to the validation phases

465
00:20:14,280 --> 00:20:17,100
so what I decide to use is structure

466
00:20:17,100 --> 00:20:20,280
overpassing where basically I will

467
00:20:20,280 --> 00:20:23,820
directly since I have knowledge of the

468
00:20:23,820 --> 00:20:25,740
web assembly module structure internally

469
00:20:25,740 --> 00:20:28,440
I will be able to generate valid

470
00:20:28,440 --> 00:20:30,539
webassembly module directly from scratch

471
00:20:30,539 --> 00:20:35,940
inside my further so it's really good I

472
00:20:35,940 --> 00:20:39,179
will not lose time on in passing so it

473
00:20:39,179 --> 00:20:40,679
will still go in the passing phase but

474
00:20:40,679 --> 00:20:42,600
what I mean by that is instead of

475
00:20:42,600 --> 00:20:45,299
sending let's say 100 file into the

476
00:20:45,299 --> 00:20:48,360
process and maybe 50 of them are

477
00:20:48,360 --> 00:20:51,419
rejected for invalid formats in that

478
00:20:51,419 --> 00:20:53,820
case 100 of them will actually go

479
00:20:53,820 --> 00:20:55,980
through the validation phases

480
00:20:55,980 --> 00:20:59,280
so that was a really efficient in that

481
00:20:59,280 --> 00:21:01,799
way so the way I've used that is

482
00:21:01,799 --> 00:21:04,440
basically by leveraging on inverse what

483
00:21:04,440 --> 00:21:07,440
we call the arbitrary trait so you

484
00:21:07,440 --> 00:21:10,740
basically have already a bunch of tools

485
00:21:10,740 --> 00:21:13,020
that you saw in rest that actually

486
00:21:13,020 --> 00:21:15,660
Define a webassembly module structure so

487
00:21:15,660 --> 00:21:18,559
by using the arbitrary trait I'm forcing

488
00:21:18,559 --> 00:21:22,980
basically my further to try to fill this

489
00:21:22,980 --> 00:21:25,380
structure by random byte to to get

490
00:21:25,380 --> 00:21:27,419
something valid

491
00:21:27,419 --> 00:21:29,580
in the same way you have wazam Smith

492
00:21:29,580 --> 00:21:32,100
that is actually even better that was

493
00:21:32,100 --> 00:21:34,380
released a bit after I was doing that

494
00:21:34,380 --> 00:21:37,260
and typically this web assembly test

495
00:21:37,260 --> 00:21:40,320
care generator will generate web

496
00:21:40,320 --> 00:21:42,419
assembly modules that are always valid

497
00:21:42,419 --> 00:21:46,500
at the same time so I retarget all my

498
00:21:46,500 --> 00:21:49,620
stuff in Pro by doing in process fuzzing

499
00:21:49,620 --> 00:21:52,200
for the at least the rush libraries and

500
00:21:52,200 --> 00:21:54,960
I at the end I also Target the other one

501
00:21:54,960 --> 00:21:57,419
since the corpora was actually shared

502
00:21:57,419 --> 00:21:59,640
between each other so that's also the

503
00:21:59,640 --> 00:22:00,900
good part

504
00:22:00,900 --> 00:22:03,299
so it was not that complicated again you

505
00:22:03,299 --> 00:22:05,940
just need to do a bunch of rest in that

506
00:22:05,940 --> 00:22:07,860
case arbitrary trade can be a bit

507
00:22:07,860 --> 00:22:10,740
challenging but that's okay so iPhone

508
00:22:10,740 --> 00:22:13,740
xero newbergs directly using that but

509
00:22:13,740 --> 00:22:16,440
the fact is since the new stuff was

510
00:22:16,440 --> 00:22:19,080
generated and put directly in the copper

511
00:22:19,080 --> 00:22:24,840
I don't monitor exactly which new bugs

512
00:22:24,840 --> 00:22:27,659
what are the input file that actually

513
00:22:27,659 --> 00:22:30,659
triggered these bugs after mutation so I

514
00:22:30,659 --> 00:22:33,539
might actually I found some bugs using

515
00:22:33,539 --> 00:22:36,120
this technique but I don't know so at

516
00:22:36,120 --> 00:22:38,760
least it increased the coverage since I

517
00:22:38,760 --> 00:22:41,340
was filling my corpora with only valid

518
00:22:41,340 --> 00:22:42,600
web assembly modules that are

519
00:22:42,600 --> 00:22:44,959
interesting

520
00:22:45,000 --> 00:22:48,240
so at the end we have the instant

521
00:22:48,240 --> 00:22:50,760
session and the invocation and in that

522
00:22:50,760 --> 00:22:52,380
case I decided to use differential

523
00:22:52,380 --> 00:22:54,600
phasing so that could look weird because

524
00:22:54,600 --> 00:22:56,460
differential forzing is not something

525
00:22:56,460 --> 00:22:59,340
that is really common

526
00:22:59,340 --> 00:23:02,100
um to be honest so first of all I create

527
00:23:02,100 --> 00:23:05,120
some new fuzzing harnesses to actually

528
00:23:05,120 --> 00:23:08,520
instant set my module and then I decide

529
00:23:08,520 --> 00:23:10,799
to basically Implement differential

530
00:23:10,799 --> 00:23:12,419
refusing using some really simple

531
00:23:12,419 --> 00:23:15,000
scripts so the goal of differential

532
00:23:15,000 --> 00:23:17,460
phasing in that case is you're going to

533
00:23:17,460 --> 00:23:20,220
provide a web assembly module to your

534
00:23:20,220 --> 00:23:23,159
different targets and you can monitor

535
00:23:23,159 --> 00:23:25,020
the result it could be really simple

536
00:23:25,020 --> 00:23:27,480
like monitoring the return code or it

537
00:23:27,480 --> 00:23:29,760
could be more complex like

538
00:23:29,760 --> 00:23:34,140
like checking the exact return value so

539
00:23:34,140 --> 00:23:36,480
by doing that my goal is really to

540
00:23:36,480 --> 00:23:38,760
identify for one given webassembly

541
00:23:38,760 --> 00:23:41,159
module what are the result of all the

542
00:23:41,159 --> 00:23:43,200
different targets I have and if some of

543
00:23:43,200 --> 00:23:45,900
them are actually rejecting the module

544
00:23:45,900 --> 00:23:48,179
or validating the module and it's

545
00:23:48,179 --> 00:23:50,039
different than the other that means

546
00:23:50,039 --> 00:23:51,919
something wrong is happening so

547
00:23:51,919 --> 00:23:54,419
differential for me the phasing is for

548
00:23:54,419 --> 00:23:57,179
me to really maybe most efficient

549
00:23:57,179 --> 00:23:59,460
technique to find logic bugs the

550
00:23:59,460 --> 00:24:01,500
downside is of course you need to have

551
00:24:01,500 --> 00:24:04,200
multiple implementation of the same

552
00:24:04,200 --> 00:24:07,620
Target or maybe different version of the

553
00:24:07,620 --> 00:24:09,539
same Target that's usually what we have

554
00:24:09,539 --> 00:24:11,159
with like regression testing that's

555
00:24:11,159 --> 00:24:14,460
exactly what we are doing and so on so

556
00:24:14,460 --> 00:24:16,320
some famous differential facing

557
00:24:16,320 --> 00:24:19,020
protection for example crypto first and

558
00:24:19,020 --> 00:24:21,419
the goal is to find cryptographic

559
00:24:21,419 --> 00:24:22,980
vulnerability in the different

560
00:24:22,980 --> 00:24:25,799
implementation so it's done by Guido

561
00:24:25,799 --> 00:24:28,559
vancran and another one is Beacon first

562
00:24:28,559 --> 00:24:31,620
that is another project of mine and it

563
00:24:31,620 --> 00:24:34,320
was basically fuzzing at around 2.0

564
00:24:34,320 --> 00:24:37,260
validation clients by doing differential

565
00:24:37,260 --> 00:24:39,419
fuzzing again the same goal finding

566
00:24:39,419 --> 00:24:41,220
logic bugs

567
00:24:41,220 --> 00:24:45,360
so logic bugs can look not so appealing

568
00:24:45,360 --> 00:24:48,480
to be honest it's always depending of

569
00:24:48,480 --> 00:24:50,760
the context and who are running the web

570
00:24:50,760 --> 00:24:54,539
assembly module typically what you will

571
00:24:54,539 --> 00:24:56,760
have most of the time are an implemented

572
00:24:56,760 --> 00:25:00,600
feature especially on webassembly so it

573
00:25:00,600 --> 00:25:03,659
will require you a lot of debugging and

574
00:25:03,659 --> 00:25:06,480
manual analysis to determine if there is

575
00:25:06,480 --> 00:25:08,820
no false positive so that's the downside

576
00:25:08,820 --> 00:25:12,720
but on the other way if we are going in

577
00:25:12,720 --> 00:25:15,900
the context of blockchains a logic bug

578
00:25:15,900 --> 00:25:18,720
like this one meaning you are providing

579
00:25:18,720 --> 00:25:20,940
a web assembly module as a smart

580
00:25:20,940 --> 00:25:23,159
contract and it will be executed and so

581
00:25:23,159 --> 00:25:24,539
on and the result can be different

582
00:25:24,539 --> 00:25:28,679
between clients that's typically the

583
00:25:28,679 --> 00:25:30,960
sign of a concerns juiceberg so it's

584
00:25:30,960 --> 00:25:33,179
really really critical I mean it's one

585
00:25:33,179 --> 00:25:34,740
of the most critical vulnerability you

586
00:25:34,740 --> 00:25:36,539
can have in production software in

587
00:25:36,539 --> 00:25:37,740
general

588
00:25:37,740 --> 00:25:40,200
so for the further nothing that

589
00:25:40,200 --> 00:25:42,419
complicated just a python script or

590
00:25:42,419 --> 00:25:45,299
batch script is enough I've used rest as

591
00:25:45,299 --> 00:25:48,120
well you can basically Target all the

592
00:25:48,120 --> 00:25:49,140
different

593
00:25:49,140 --> 00:25:49,799
um

594
00:25:49,799 --> 00:25:51,720
I mean I was targeting all the different

595
00:25:51,720 --> 00:25:55,440
targets I implemented because I mean I

596
00:25:55,440 --> 00:25:57,240
already got the all the phasing harness

597
00:25:57,240 --> 00:25:59,880
so it was really easy for that so it was

598
00:25:59,880 --> 00:26:03,659
not that complicated but yeah it needed

599
00:26:03,659 --> 00:26:06,500
again it requires a lot of manual

600
00:26:06,500 --> 00:26:09,960
analysis to to determine if yes or not

601
00:26:09,960 --> 00:26:12,179
you have something ability so I found

602
00:26:12,179 --> 00:26:15,000
two birds in wabits that is one of the

603
00:26:15,000 --> 00:26:19,799
most choose Library written since in

604
00:26:19,799 --> 00:26:21,419
that case yeah it was incorrect

605
00:26:21,419 --> 00:26:24,480
validation or rejection of web assembly

606
00:26:24,480 --> 00:26:26,279
module

607
00:26:26,279 --> 00:26:28,559
but what about brothers because since

608
00:26:28,559 --> 00:26:31,620
the beginning I'm speaking more evenly

609
00:26:31,620 --> 00:26:34,620
more on Standalone VM so let's talk

610
00:26:34,620 --> 00:26:36,900
quickly about browsers and actually the

611
00:26:36,900 --> 00:26:38,820
stuff that they got that is a bit more

612
00:26:38,820 --> 00:26:39,900
special

613
00:26:39,900 --> 00:26:42,059
so typically web assembly the

614
00:26:42,059 --> 00:26:44,100
webassembly vvm is part of the

615
00:26:44,100 --> 00:26:47,700
JavaScript online and so it's directly

616
00:26:47,700 --> 00:26:50,520
inside a spider monkey JavaScript code

617
00:26:50,520 --> 00:26:54,120
or V8 for the most famous one and we

618
00:26:54,120 --> 00:26:57,140
have multiple stuff that are actually

619
00:26:57,140 --> 00:26:59,820
involved the web assembly of course you

620
00:26:59,820 --> 00:27:01,559
have the web assembly runtime that is

621
00:27:01,559 --> 00:27:03,299
exactly the same that what I've shown

622
00:27:03,299 --> 00:27:05,279
you and then you also have the

623
00:27:05,279 --> 00:27:07,679
JavaScript interrupt that's mean that's

624
00:27:07,679 --> 00:27:10,320
all those webassembly API that allow you

625
00:27:10,320 --> 00:27:12,600
to communicate from JavaScript to the

626
00:27:12,600 --> 00:27:16,200
webassembly VM so for this one I mean

627
00:27:16,200 --> 00:27:18,960
there is plenty of them actually the MDM

628
00:27:18,960 --> 00:27:21,000
is really a good documentation for that

629
00:27:21,000 --> 00:27:25,020
and using those JavaScript API you are

630
00:27:25,020 --> 00:27:27,480
able to basically instantiate a

631
00:27:27,480 --> 00:27:30,240
webassembly module you can create some

632
00:27:30,240 --> 00:27:32,880
memory some Global some tables so all

633
00:27:32,880 --> 00:27:34,620
the stuff I told you that was basically

634
00:27:34,620 --> 00:27:39,299
shared between the um the host and the

635
00:27:39,299 --> 00:27:42,779
web from the instance and we are doing

636
00:27:42,779 --> 00:27:44,580
something like that so when you are

637
00:27:44,580 --> 00:27:47,220
dealing with JavaScript code in that

638
00:27:47,220 --> 00:27:49,559
case doing something like coverage

639
00:27:49,559 --> 00:27:53,460
guided fuzzing is not that easy and

640
00:27:53,460 --> 00:27:55,799
especially if you want to mutate your

641
00:27:55,799 --> 00:27:58,799
input file you will need to you need to

642
00:27:58,799 --> 00:28:00,539
deal with JavaScript syntax so

643
00:28:00,539 --> 00:28:02,820
definitely not the best

644
00:28:02,820 --> 00:28:05,580
so for that usually I'm using grammar

645
00:28:05,580 --> 00:28:07,620
based fuzzing so that's what I've done

646
00:28:07,620 --> 00:28:10,080
the only downside is you will need to

647
00:28:10,080 --> 00:28:11,640
write the grammar so it could be time

648
00:28:11,640 --> 00:28:13,679
consuming but I mean the webassembly

649
00:28:13,679 --> 00:28:16,860
apis are not that huge so that's what

650
00:28:16,860 --> 00:28:20,400
I've done with Dharma and tomato and do

651
00:28:20,400 --> 00:28:22,200
store will basically generate some

652
00:28:22,200 --> 00:28:25,080
sequence of webassembly JavaScript API

653
00:28:25,080 --> 00:28:28,740
like the one on the bottom and after

654
00:28:28,740 --> 00:28:30,840
that I will provide this Javascript file

655
00:28:30,840 --> 00:28:33,179
directly to the GSM join and it will

656
00:28:33,179 --> 00:28:36,539
basically create some objects and Target

657
00:28:36,539 --> 00:28:41,940
the extra new part of of the online that

658
00:28:41,940 --> 00:28:43,740
we have that is the JavaScript interrupt

659
00:28:43,740 --> 00:28:46,980
and also the web assembly runtime by

660
00:28:46,980 --> 00:28:48,539
effect

661
00:28:48,539 --> 00:28:51,419
I've also use a really good tool named

662
00:28:51,419 --> 00:28:53,580
facility for wasm it's basically firstly

663
00:28:53,580 --> 00:28:56,640
with some patch to add web assembly on

664
00:28:56,640 --> 00:28:59,400
it so that's what you have on the top

665
00:28:59,400 --> 00:29:01,799
right it's actually generating some

666
00:29:01,799 --> 00:29:04,440
really good stuff and it was working

667
00:29:04,440 --> 00:29:08,940
pretty well so at the end it was

668
00:29:08,940 --> 00:29:12,059
long but not that complex to create

669
00:29:12,059 --> 00:29:14,760
those grammar and it actually triggers

670
00:29:14,760 --> 00:29:16,679
some bugs that in that case are not

671
00:29:16,679 --> 00:29:19,440
public or duplicates on some other one

672
00:29:19,440 --> 00:29:23,399
so that's working well usually when I'm

673
00:29:23,399 --> 00:29:25,220
teaching browser phrasing I always

674
00:29:25,220 --> 00:29:28,020
invite people to actually use grammar

675
00:29:28,020 --> 00:29:30,240
base using for that it's also a really

676
00:29:30,240 --> 00:29:31,799
good way for you to learn more about

677
00:29:31,799 --> 00:29:33,299
your targets because you will need

678
00:29:33,299 --> 00:29:36,299
basically to implement all the spec on

679
00:29:36,299 --> 00:29:40,140
that so that's the that's the good point

680
00:29:40,140 --> 00:29:43,980
so that's the webassembly VM the fact is

681
00:29:43,980 --> 00:29:46,260
since we are running inside a browser

682
00:29:46,260 --> 00:29:48,960
there is what also what we call also the

683
00:29:48,960 --> 00:29:52,500
webassem legit enzymes so usually the

684
00:29:52,500 --> 00:29:54,779
classical way is let's say for

685
00:29:54,779 --> 00:29:56,700
JavaScript you have your JavaScript it

686
00:29:56,700 --> 00:29:58,980
will be passed into AST it will be

687
00:29:58,980 --> 00:30:00,960
converted into bytecode and it will be

688
00:30:00,960 --> 00:30:03,179
interpreted after some time when the

689
00:30:03,179 --> 00:30:06,360
code will be hot it will go through the

690
00:30:06,360 --> 00:30:08,580
jit and join and you will get like a

691
00:30:08,580 --> 00:30:11,039
optimized machine code that will be

692
00:30:11,039 --> 00:30:12,840
executed each time you are calling the

693
00:30:12,840 --> 00:30:16,020
function so the fact is they actually

694
00:30:16,020 --> 00:30:18,419
implement the same concept for

695
00:30:18,419 --> 00:30:20,760
webassembly so when you are providing a

696
00:30:20,760 --> 00:30:23,399
webassembly module the first time it

697
00:30:23,399 --> 00:30:26,340
will be interpreted so nothing fancy in

698
00:30:26,340 --> 00:30:29,760
that case and if we become hot it will

699
00:30:29,760 --> 00:30:33,539
go through the jit compilers and be

700
00:30:33,539 --> 00:30:35,820
optimized generate machine code and be

701
00:30:35,820 --> 00:30:37,679
execute it as well

702
00:30:37,679 --> 00:30:40,260
so for spider monkey we have like a

703
00:30:40,260 --> 00:30:42,380
switch here

704
00:30:42,380 --> 00:30:45,960
compilers JavaScript as well and for V8

705
00:30:45,960 --> 00:30:48,360
we have liftoff and turbo fan that are

706
00:30:48,360 --> 00:30:51,000
the the one that are used

707
00:30:51,000 --> 00:30:53,820
so the main goal for me with in that

708
00:30:53,820 --> 00:30:55,860
case different shelf using against the

709
00:30:55,860 --> 00:30:58,440
digital design is basically to reproduce

710
00:30:58,440 --> 00:31:00,360
a concept and a technique that is

711
00:31:00,360 --> 00:31:03,000
already used for classical JavaScript

712
00:31:03,000 --> 00:31:07,440
that is we have a function we are

713
00:31:07,440 --> 00:31:08,940
calling this function with some argument

714
00:31:08,940 --> 00:31:11,520
we are getting a result then we force

715
00:31:11,520 --> 00:31:13,860
the optimization by the compilers and we

716
00:31:13,860 --> 00:31:16,140
are calling again the function what we

717
00:31:16,140 --> 00:31:18,360
opt to find is basically a difference

718
00:31:18,360 --> 00:31:21,299
between the interpretation and the

719
00:31:21,299 --> 00:31:24,299
compilation result and typically those

720
00:31:24,299 --> 00:31:26,460
kind of stuff lead to

721
00:31:26,460 --> 00:31:27,720
um

722
00:31:27,720 --> 00:31:30,000
incorrect optimization

723
00:31:30,000 --> 00:31:32,220
so that's the good part the fact is

724
00:31:32,220 --> 00:31:34,500
since we also have webassembly compilers

725
00:31:34,500 --> 00:31:36,899
we can perfectly apply the exact same

726
00:31:36,899 --> 00:31:39,840
technique for webassembly and in that

727
00:31:39,840 --> 00:31:42,539
case I will load I will generate a

728
00:31:42,539 --> 00:31:45,000
webassembly module that will do some

729
00:31:45,000 --> 00:31:48,360
operation I will load that using

730
00:31:48,360 --> 00:31:50,760
JavaScript I will call this function I

731
00:31:50,760 --> 00:31:53,700
mean call this module this module by

732
00:31:53,700 --> 00:31:56,820
default will be optimized by liftoff and

733
00:31:56,820 --> 00:31:59,700
I will force the optimization in order

734
00:31:59,700 --> 00:32:01,620
to

735
00:32:01,620 --> 00:32:05,220
make turbo fan to optimize the web

736
00:32:05,220 --> 00:32:06,779
assembly module and this particular

737
00:32:06,779 --> 00:32:07,679
function

738
00:32:07,679 --> 00:32:09,899
the main goal again let's say that you

739
00:32:09,899 --> 00:32:13,320
provide an argument to a function the

740
00:32:13,320 --> 00:32:15,539
goal is to find for the same argument

741
00:32:15,539 --> 00:32:19,440
two different results on that so that's

742
00:32:19,440 --> 00:32:23,340
a technique that actually is is working

743
00:32:23,340 --> 00:32:26,159
well it's General it's actually not that

744
00:32:26,159 --> 00:32:29,279
complicated to do but the downside is

745
00:32:29,279 --> 00:32:31,320
you need to generate valid webassembly

746
00:32:31,320 --> 00:32:34,500
module and especially valid web assembly

747
00:32:34,500 --> 00:32:37,559
module that contain interesting bytecode

748
00:32:37,559 --> 00:32:42,679
inside so that's what you can see on the

749
00:32:42,679 --> 00:32:47,399
upper right is basically the the code

750
00:32:47,399 --> 00:32:50,820
generated by liftoff so it's a pure

751
00:32:50,820 --> 00:32:53,580
assembly and then you can see on the

752
00:32:53,580 --> 00:32:56,460
bottom the card generated by chobofan so

753
00:32:56,460 --> 00:32:58,500
the way it will go from one to the other

754
00:32:58,500 --> 00:33:01,740
is by doing a lot of optimization on the

755
00:33:01,740 --> 00:33:03,320
bytecode and

756
00:33:03,320 --> 00:33:06,720
leveraging on a bunch of

757
00:33:06,720 --> 00:33:09,539
profiling data that he actually retrieve

758
00:33:09,539 --> 00:33:14,039
at runtime and yeah again the goal is is

759
00:33:14,039 --> 00:33:16,200
this one is the one on the right and the

760
00:33:16,200 --> 00:33:18,779
one at the bottom is actually doing the

761
00:33:18,779 --> 00:33:21,240
same stuff that's the goal we want to

762
00:33:21,240 --> 00:33:22,919
find out

763
00:33:22,919 --> 00:33:25,679
so for the moment nurburgs are found

764
00:33:25,679 --> 00:33:28,620
with that it's actually a recent stuff

765
00:33:28,620 --> 00:33:30,840
I've made for all the the rest of the

766
00:33:30,840 --> 00:33:32,820
research it was basically

767
00:33:32,820 --> 00:33:33,600
um

768
00:33:33,600 --> 00:33:37,860
taking me a bunch of months and years to

769
00:33:37,860 --> 00:33:40,320
do over all these process over the time

770
00:33:40,320 --> 00:33:41,960
and basically also

771
00:33:41,960 --> 00:33:45,120
adapt all my tooling to the modification

772
00:33:45,120 --> 00:33:47,700
in webassembly so this one is still in

773
00:33:47,700 --> 00:33:49,919
progress I will let you know if I'm

774
00:33:49,919 --> 00:33:52,320
finding any any bugs on that the the

775
00:33:52,320 --> 00:33:55,080
fact is I have not so there is something

776
00:33:55,080 --> 00:33:58,380
big research about jit and gine fuzzing

777
00:33:58,380 --> 00:34:00,899
and vulnerability research in like

778
00:34:00,899 --> 00:34:03,000
incorrect optimization and so on really

779
00:34:03,000 --> 00:34:04,700
a bunch of

780
00:34:04,700 --> 00:34:08,219
research done by Samuel from Project

781
00:34:08,219 --> 00:34:12,359
zero and Amy from red to system and so

782
00:34:12,359 --> 00:34:14,879
on but on the web assembly side I have

783
00:34:14,879 --> 00:34:17,879
not seen a lot of stuff actually so if

784
00:34:17,879 --> 00:34:19,320
someone is doing something similar

785
00:34:19,320 --> 00:34:22,320
please please come to to see me at the

786
00:34:22,320 --> 00:34:24,540
end I will be really happy to to discuss

787
00:34:24,540 --> 00:34:25,619
that

788
00:34:25,619 --> 00:34:28,379
so the final result of all this journey

789
00:34:28,379 --> 00:34:32,399
is basically something like 120 bugs

790
00:34:32,399 --> 00:34:35,339
more or less some of them I maybe just

791
00:34:35,339 --> 00:34:38,280
forget the final couple of size it's

792
00:34:38,280 --> 00:34:40,500
like 2 million web assembly modules so

793
00:34:40,500 --> 00:34:42,480
as I mentioned the fact that I'm storing

794
00:34:42,480 --> 00:34:44,339
everything between all those different

795
00:34:44,339 --> 00:34:46,918
tools targeting something like more than

796
00:34:46,918 --> 00:34:50,219
20 30 targets it's just starting to be a

797
00:34:50,219 --> 00:34:52,859
really huge couple the good part is when

798
00:34:52,859 --> 00:34:55,260
you have something like that if there is

799
00:34:55,260 --> 00:34:58,680
a new tool that comes in the wild and

800
00:34:58,680 --> 00:35:01,380
that is actually passing webassembly

801
00:35:01,380 --> 00:35:03,960
binary I can just take all my corpora

802
00:35:03,960 --> 00:35:07,260
doing copies minimization on it and I

803
00:35:07,260 --> 00:35:09,240
will get something that will reach a

804
00:35:09,240 --> 00:35:12,180
huge part of the coverage for free

805
00:35:12,180 --> 00:35:14,520
so it took me around two years not full

806
00:35:14,520 --> 00:35:16,680
time of course I would say maybe six

807
00:35:16,680 --> 00:35:19,800
months full time to to do all of it uh

808
00:35:19,800 --> 00:35:22,320
something like 84 fuzzing RMS is more or

809
00:35:22,320 --> 00:35:24,960
less I actually released an open source

810
00:35:24,960 --> 00:35:28,800
tool a web assemblyment I'm fuzzing it's

811
00:35:28,800 --> 00:35:31,140
I released maybe two two years ago so it

812
00:35:31,140 --> 00:35:34,140
might need to be updated but it's in

813
00:35:34,140 --> 00:35:37,140
progress the interesting stuff we can

814
00:35:37,140 --> 00:35:39,119
see is that actually coverage guided

815
00:35:39,119 --> 00:35:41,339
fuzzing and in process fuzzing that we

816
00:35:41,339 --> 00:35:43,920
can consider are actually using similar

817
00:35:43,920 --> 00:35:45,599
technique but just one is faster than

818
00:35:45,599 --> 00:35:48,420
the other one is the stuff that actually

819
00:35:48,420 --> 00:35:52,320
find the most bugs so that's always

820
00:35:52,320 --> 00:35:55,320
showing that it should be a default

821
00:35:55,320 --> 00:35:56,880
stuff to be done by the developer

822
00:35:56,880 --> 00:36:00,240
because I clearly it was clearly not

823
00:36:00,240 --> 00:36:02,880
difficult to to implement that so there

824
00:36:02,880 --> 00:36:05,040
is no valid reason to for you to not put

825
00:36:05,040 --> 00:36:07,260
any fuzzing and coverage graduate

826
00:36:07,260 --> 00:36:09,599
phasing in your CI especially because

827
00:36:09,599 --> 00:36:11,579
you basically are fuzzing framework for

828
00:36:11,579 --> 00:36:14,280
all the language that exist more or less

829
00:36:14,280 --> 00:36:18,240
so that was nice the challenges it's

830
00:36:18,240 --> 00:36:20,820
it's complicated to update everything I

831
00:36:20,820 --> 00:36:22,740
mean all the different targets evolved

832
00:36:22,740 --> 00:36:26,160
and I mean I have a full-time job so um

833
00:36:26,160 --> 00:36:28,140
and it's not that

834
00:36:28,140 --> 00:36:31,560
um so that's why also the fact that

835
00:36:31,560 --> 00:36:33,060
there is a different web assembly

836
00:36:33,060 --> 00:36:34,440
features

837
00:36:34,440 --> 00:36:37,740
um is an issue especially for

838
00:36:37,740 --> 00:36:39,359
differential phasing as I mentioned

839
00:36:39,359 --> 00:36:42,720
because one might support it and not the

840
00:36:42,720 --> 00:36:43,740
other one

841
00:36:43,740 --> 00:36:46,140
and then you also need to adapt to

842
00:36:46,140 --> 00:36:48,420
multiple phrasing framework so that's

843
00:36:48,420 --> 00:36:49,920
actually the good part I mean it's a

844
00:36:49,920 --> 00:36:52,200
it's a nice excuse to basically try to

845
00:36:52,200 --> 00:36:56,220
first everything and um and so on so

846
00:36:56,220 --> 00:36:58,500
some future Next Step I'm planning

847
00:36:58,500 --> 00:37:02,339
actually to implement and and first like

848
00:37:02,339 --> 00:37:03,740
the go

849
00:37:03,740 --> 00:37:06,300
there is some tool some web assembly VM

850
00:37:06,300 --> 00:37:07,800
written and go so I'm planning to First

851
00:37:07,800 --> 00:37:11,700
this one as well maybe some Java one uh

852
00:37:11,700 --> 00:37:13,500
there'll be some implementation as well

853
00:37:13,500 --> 00:37:16,920
and also since uh recently the announce

854
00:37:16,920 --> 00:37:20,280
webassembly MVP 2.0 I'm also planning to

855
00:37:20,280 --> 00:37:22,680
basically update my facing analysis and

856
00:37:22,680 --> 00:37:24,839
maybe find some new bugs in those new

857
00:37:24,839 --> 00:37:28,380
features that will be added into

858
00:37:28,380 --> 00:37:31,920
so I hope you learn a lot and that my

859
00:37:31,920 --> 00:37:34,079
journey into fuzzing can help you to

860
00:37:34,079 --> 00:37:36,780
basically copy past this journey but

861
00:37:36,780 --> 00:37:39,599
just change the Target and please let me

862
00:37:39,599 --> 00:37:41,579
know if you are doing fuzzing and you

863
00:37:41,579 --> 00:37:43,380
want to discuss more about that I mean

864
00:37:43,380 --> 00:37:45,420
you have my Twitter and I'm pretty

865
00:37:45,420 --> 00:37:49,520
responsive so thank you

866
00:37:50,140 --> 00:37:52,380
[Applause]

867
00:37:52,380 --> 00:37:55,669
[Music]

868
00:37:59,530 --> 00:38:02,619
[Music]

