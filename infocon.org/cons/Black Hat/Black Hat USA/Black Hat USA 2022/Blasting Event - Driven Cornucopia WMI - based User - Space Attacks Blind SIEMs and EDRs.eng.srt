1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:12,559 --> 00:00:16,619
event driven Cornucopia representing the

4
00:00:16,619 --> 00:00:18,619
binary team Windows management

5
00:00:18,619 --> 00:00:22,619
instrumentation provides the ability to

6
00:00:22,619 --> 00:00:25,619
manage Enterprise devices both locally

7
00:00:25,619 --> 00:00:27,859
and remotely

8
00:00:27,859 --> 00:00:30,840
various tools edrs and Sim Solutions

9
00:00:30,840 --> 00:00:33,600
leverage this functionality for

10
00:00:33,600 --> 00:00:36,120
performance monitoring and device

11
00:00:36,120 --> 00:00:39,300
Telemetry Gathering attacking this uh

12
00:00:39,300 --> 00:00:42,059
the this functionality can blind all

13
00:00:42,059 --> 00:00:44,100
these solutions that rely on this

14
00:00:44,100 --> 00:00:45,360
telemetry

15
00:00:45,360 --> 00:00:47,820
and also this is an important topic for

16
00:00:47,820 --> 00:00:50,219
uh for Defenders for experts in Windows

17
00:00:50,219 --> 00:00:54,840
security and uh malware detection and

18
00:00:54,840 --> 00:00:57,480
the incident response

19
00:00:57,480 --> 00:00:59,940
a little bit about the binary team so

20
00:00:59,940 --> 00:01:03,359
finally the device security uh startup

21
00:01:03,359 --> 00:01:06,900
based in La that focuses on threats that

22
00:01:06,900 --> 00:01:09,540
originate below the uh below the

23
00:01:09,540 --> 00:01:11,700
operating system in the firmware and

24
00:01:11,700 --> 00:01:14,100
understand how they move up the stack

25
00:01:14,100 --> 00:01:18,119
into the operating system and uh

26
00:01:18,119 --> 00:01:20,820
we use our land to deploy their next

27
00:01:20,820 --> 00:01:26,460
level uh the their next stages uh in a

28
00:01:26,460 --> 00:01:29,340
2021 and black at Europe the same team

29
00:01:29,340 --> 00:01:32,040
presented the Deep dive on attacks on

30
00:01:32,040 --> 00:01:33,180
etw

31
00:01:33,180 --> 00:01:37,799
for this talk we chose to attack wmi and

32
00:01:37,799 --> 00:01:39,560
as we will see through the presentation

33
00:01:39,560 --> 00:01:44,040
we have a lot to talk about again my

34
00:01:44,040 --> 00:01:46,619
name is Claudia todresco I'm the CTO and

35
00:01:46,619 --> 00:01:50,180
co-founder of binary unfortunately Andre

36
00:01:50,180 --> 00:01:52,560
retlet and the Igor couldn't make the

37
00:01:52,560 --> 00:01:55,200
trip to be with us today but their

38
00:01:55,200 --> 00:01:57,479
contribution to this research was

39
00:01:57,479 --> 00:01:59,700
essential

40
00:01:59,700 --> 00:02:01,680
so it was very important to understand

41
00:02:01,680 --> 00:02:04,439
how we can attack wmi because it is used

42
00:02:04,439 --> 00:02:07,439
by a lot of Solutions in the field and

43
00:02:07,439 --> 00:02:09,899
these Solutions can be blind or it can

44
00:02:09,899 --> 00:02:10,979
be tricked

45
00:02:10,979 --> 00:02:13,379
uh in terms of the Telemetry that

46
00:02:13,379 --> 00:02:15,840
they're Gathering also more important is

47
00:02:15,840 --> 00:02:19,500
to find ways how to detect if the wmi or

48
00:02:19,500 --> 00:02:23,040
any other solution that is used by by

49
00:02:23,040 --> 00:02:26,099
Security Solutions is tampered with and

50
00:02:26,099 --> 00:02:28,260
then act upon that by notifying the

51
00:02:28,260 --> 00:02:32,220
proper audience so as for the agenda

52
00:02:32,220 --> 00:02:34,800
we'll start with presenting some

53
00:02:34,800 --> 00:02:36,660
information about the Windows management

54
00:02:36,660 --> 00:02:38,879
information in terms of architecture and

55
00:02:38,879 --> 00:02:42,660
features also we'll look at how the

56
00:02:42,660 --> 00:02:45,260
hackers and the threat actors are using

57
00:02:45,260 --> 00:02:50,040
wmi in the in the wild

58
00:02:50,040 --> 00:02:52,980
next we'll go to the core of the

59
00:02:52,980 --> 00:02:54,900
presentation by introducing different

60
00:02:54,900 --> 00:02:56,480
types of attack on

61
00:02:56,480 --> 00:03:01,019
wmi and also introduce eight new brands

62
00:03:01,019 --> 00:03:04,860
new attacks on it uh on the wmi

63
00:03:04,860 --> 00:03:07,980
at the end we'll introduce some uh some

64
00:03:07,980 --> 00:03:10,500
solutions that can uh some solutions

65
00:03:10,500 --> 00:03:13,440
like wmi check and the memory Ranger

66
00:03:13,440 --> 00:03:15,900
those Solutions can detect and prevent

67
00:03:15,900 --> 00:03:17,400
some of the attacks that will be

68
00:03:17,400 --> 00:03:21,180
presented in this presentation

69
00:03:21,180 --> 00:03:22,019
foreign

70
00:03:22,019 --> 00:03:24,239
next let's go a little bit into the

71
00:03:24,239 --> 00:03:25,620
Windows management instrumentation

72
00:03:25,620 --> 00:03:30,120
architecture uh for for short uh short

73
00:03:30,120 --> 00:03:33,080
wmi actually the windows implementation

74
00:03:33,080 --> 00:03:37,440
of two standards the the wbam or a

75
00:03:37,440 --> 00:03:41,299
web-based Enterprise management and cim

76
00:03:41,299 --> 00:03:45,780
common information model it has

77
00:03:45,780 --> 00:03:48,080
very good advantages it's available

78
00:03:48,080 --> 00:03:51,260
system-wide in all the

79
00:03:51,260 --> 00:03:53,580
Windows operating systems starting with

80
00:03:53,580 --> 00:03:58,560
Windows and deep 4.0 also it provides a

81
00:03:58,560 --> 00:04:01,440
standardized framework to talk with

82
00:04:01,440 --> 00:04:04,019
consumers and providers via Chrome

83
00:04:04,019 --> 00:04:06,120
interfaces

84
00:04:06,120 --> 00:04:08,280
going into the specifics of the

85
00:04:08,280 --> 00:04:11,159
architecture so we have the wmi

86
00:04:11,159 --> 00:04:13,260
providers

87
00:04:13,260 --> 00:04:17,760
that produce uh device Telemetry as wmi

88
00:04:17,760 --> 00:04:20,699
objects we have the clients that consume

89
00:04:20,699 --> 00:04:23,520
those events we have the cim standard

90
00:04:23,520 --> 00:04:26,940
that is a structuring querying and

91
00:04:26,940 --> 00:04:30,540
transmitting the wmi objects for

92
00:04:30,540 --> 00:04:31,979
reference W by objects actually

93
00:04:31,979 --> 00:04:35,120
instances of wmi classes

94
00:04:35,120 --> 00:04:38,520
next uh so as part of the cim standard

95
00:04:38,520 --> 00:04:41,639
we have the wmi repository that stores

96
00:04:41,639 --> 00:04:43,320
the class definitions the Dems and

97
00:04:43,320 --> 00:04:45,560
definitions and their Associated

98
00:04:45,560 --> 00:04:49,560
properties as well as the persistent wmi

99
00:04:49,560 --> 00:04:52,340
objects then we have the

100
00:04:52,340 --> 00:04:56,460
moth or managed object format it's a

101
00:04:56,460 --> 00:05:00,720
object oriented language that it is that

102
00:05:00,720 --> 00:05:04,560
is used to specify uh different wmi

103
00:05:04,560 --> 00:05:07,680
artifacts to extend the format then we

104
00:05:07,680 --> 00:05:10,139
have the query language that is the SQL

105
00:05:10,139 --> 00:05:14,040
like type language wql to query to

106
00:05:14,040 --> 00:05:17,160
filter events and uh

107
00:05:17,160 --> 00:05:20,880
to very remotely connect and transmit

108
00:05:20,880 --> 00:05:23,160
the receive data Windows Remote

109
00:05:23,160 --> 00:05:25,740
Management or dcom can be leveraged last

110
00:05:25,740 --> 00:05:27,600
but not the least we have the wmi

111
00:05:27,600 --> 00:05:30,900
service which is implemented at the SVC

112
00:05:30,900 --> 00:05:34,139
host service dll in the net svcs Group

113
00:05:34,139 --> 00:05:37,680
which is called winm GMT

114
00:05:37,680 --> 00:05:39,960
let's talk a little bit about a little

115
00:05:39,960 --> 00:05:43,199
bit about the wmi providers so in user

116
00:05:43,199 --> 00:05:46,100
mode they are implemented as comb base

117
00:05:46,100 --> 00:05:50,639
dla dlls or kernel drivers for the

118
00:05:50,639 --> 00:05:53,520
kernel component as you can see in the

119
00:05:53,520 --> 00:05:55,800
more definition of a provider

120
00:05:55,800 --> 00:05:58,080
a provider is an instance of the

121
00:05:58,080 --> 00:06:00,020
underscore underscore Windows 32

122
00:06:00,020 --> 00:06:02,400
provider standard class

123
00:06:02,400 --> 00:06:05,160
it is identified by a class ID and as

124
00:06:05,160 --> 00:06:07,919
any com interface it has its own

125
00:06:07,919 --> 00:06:11,340
registry configuration uh as we can see

126
00:06:11,340 --> 00:06:13,440
in Windows 11 we have more than 4 000

127
00:06:13,440 --> 00:06:16,800
built-in wmi con providers that can

128
00:06:16,800 --> 00:06:18,900
cover a lot of different device

129
00:06:18,900 --> 00:06:22,380
components some of them are listed in

130
00:06:22,380 --> 00:06:24,800
the table

131
00:06:24,919 --> 00:06:29,340
wmi advance so double my offers a great

132
00:06:29,340 --> 00:06:32,819
ability for both attackers and Defenders

133
00:06:32,819 --> 00:06:36,060
to act on a certain double on pretty

134
00:06:36,060 --> 00:06:38,819
much every wmi event which covers mostly

135
00:06:38,819 --> 00:06:43,020
any of the operating system events also

136
00:06:43,020 --> 00:06:45,960
another great ability uh offered by wmi

137
00:06:45,960 --> 00:06:49,380
is to register a permanent event

138
00:06:49,380 --> 00:06:54,660
subscriptions this is very uh which uh

139
00:06:54,660 --> 00:06:57,720
obviously we'll uh survive a reboot

140
00:06:57,720 --> 00:07:00,539
which is very used by uh in the field by

141
00:07:00,539 --> 00:07:03,539
by attackers to obtain persistence on on

142
00:07:03,539 --> 00:07:05,699
those systems there are two types of

143
00:07:05,699 --> 00:07:07,919
events intrinsic events and extrasing

144
00:07:07,919 --> 00:07:11,280
events I leave this the definition uh to

145
00:07:11,280 --> 00:07:13,560
this uh on as reference

146
00:07:13,560 --> 00:07:16,800
next we move to filters it's an instance

147
00:07:16,800 --> 00:07:18,600
of underscore underscore invent filter

148
00:07:18,600 --> 00:07:21,900
wmi class that specify which events are

149
00:07:21,900 --> 00:07:24,660
delivered to the bound consumer we'll

150
00:07:24,660 --> 00:07:27,599
see what bound bounding means the most

151
00:07:27,599 --> 00:07:29,000
important

152
00:07:29,000 --> 00:07:31,259
properties of this class are the event

153
00:07:31,259 --> 00:07:34,139
namespace the query language to filter

154
00:07:34,139 --> 00:07:36,780
the events and also the query itself as

155
00:07:36,780 --> 00:07:40,620
a expressed as a wql query

156
00:07:40,620 --> 00:07:43,620
these are the example of the general

157
00:07:43,620 --> 00:07:47,280
syntax of a w double query and also we

158
00:07:47,280 --> 00:07:50,819
have two two examples one for uh uh

159
00:07:50,819 --> 00:07:53,099
intrinsic uh

160
00:07:53,099 --> 00:07:56,220
event query which actually uh triggers

161
00:07:56,220 --> 00:08:00,060
every time a notepad exe is launched

162
00:08:00,060 --> 00:08:02,360
and the other one it's an example of

163
00:08:02,360 --> 00:08:07,139
extrinsic event filter which detects

164
00:08:07,139 --> 00:08:07,919
um

165
00:08:07,919 --> 00:08:10,919
persistence in the Run registry key

166
00:08:10,919 --> 00:08:14,220
next the consumer the wmi consumer defy

167
00:08:14,220 --> 00:08:16,259
the action to be carried out once the

168
00:08:16,259 --> 00:08:19,379
bound filter event filter has triggered

169
00:08:19,379 --> 00:08:22,160
and in the standard there are available

170
00:08:22,160 --> 00:08:25,620
five event consumers

171
00:08:25,620 --> 00:08:28,639
to perform actions such as uh

172
00:08:28,639 --> 00:08:32,399
logging uh executing scripts or command

173
00:08:32,399 --> 00:08:36,659
lines or even sending notifications and

174
00:08:36,659 --> 00:08:37,520
uh

175
00:08:37,520 --> 00:08:40,799
in terms of we talked about the the

176
00:08:40,799 --> 00:08:44,000
permanent event subscription how is that

177
00:08:44,000 --> 00:08:48,120
performed is uh the way persistence and

178
00:08:48,120 --> 00:08:49,920
code execution happens in the wmi

179
00:08:49,920 --> 00:08:52,740
repository it's in three steps create a

180
00:08:52,740 --> 00:08:55,200
filter to describe the event to trigger

181
00:08:55,200 --> 00:08:58,560
on create a consumer that describes the

182
00:08:58,560 --> 00:09:01,440
action once the the filter has triggered

183
00:09:01,440 --> 00:09:04,140
and then bind them using a filter to

184
00:09:04,140 --> 00:09:07,980
Consumer binding instance to link pretty

185
00:09:07,980 --> 00:09:10,260
much the trigger to the action to be

186
00:09:10,260 --> 00:09:11,459
performed

187
00:09:11,459 --> 00:09:14,040
so this is a simple example how it can

188
00:09:14,040 --> 00:09:17,100
detect uh a new when a new service is

189
00:09:17,100 --> 00:09:20,160
installed you create a

190
00:09:20,160 --> 00:09:24,480
event filter that monitors for instance

191
00:09:24,480 --> 00:09:27,480
creation events

192
00:09:27,480 --> 00:09:29,760
or the polling interval

193
00:09:29,760 --> 00:09:32,640
for which the target instance is a of

194
00:09:32,640 --> 00:09:37,399
type 132 service then you you create a

195
00:09:37,399 --> 00:09:40,680
consumer that will uh

196
00:09:40,680 --> 00:09:43,080
trigger on this if one when the new

197
00:09:43,080 --> 00:09:45,240
service is created and write a

198
00:09:45,240 --> 00:09:48,120
notification into the event log using

199
00:09:48,120 --> 00:09:50,339
the Event Viewer consumer

200
00:09:50,339 --> 00:09:53,580
and last but not least you bind the the

201
00:09:53,580 --> 00:09:57,779
the the filter with the consumer to link

202
00:09:57,779 --> 00:09:59,700
pretty much the trigger to the action to

203
00:09:59,700 --> 00:10:01,500
be performed

204
00:10:01,500 --> 00:10:03,180
let's talk a little talk a little bit

205
00:10:03,180 --> 00:10:07,200
about the cim repository uh it's the

206
00:10:07,200 --> 00:10:10,920
database for the wmi that stores the uh

207
00:10:10,920 --> 00:10:13,440
class definitions for the class

208
00:10:13,440 --> 00:10:14,880
definition namespace definitions

209
00:10:14,880 --> 00:10:17,459
together with their qualifiers and

210
00:10:17,459 --> 00:10:20,420
properties as long as as well as the

211
00:10:20,420 --> 00:10:24,720
persistent uh objects wmi objects

212
00:10:24,720 --> 00:10:28,140
consists of three types of files it's

213
00:10:28,140 --> 00:10:31,920
the index BTR object that data and the

214
00:10:31,920 --> 00:10:34,620
mapping three mapping files the

215
00:10:34,620 --> 00:10:38,720
index.btr contains the uh the index

216
00:10:38,720 --> 00:10:42,959
index for the wmi which is implemented

217
00:10:42,959 --> 00:10:44,640
as a B3

218
00:10:44,640 --> 00:10:48,779
uh organized in index records stored in

219
00:10:48,779 --> 00:10:52,260
Pages the object that data contains the

220
00:10:52,260 --> 00:10:55,740
actual class definitions and and the

221
00:10:55,740 --> 00:10:58,860
persistent objects uh this in the same

222
00:10:58,860 --> 00:11:02,760
way it is organized in records and uh I

223
00:11:02,760 --> 00:11:05,820
mean those records are stored in pages

224
00:11:05,820 --> 00:11:09,060
and then the mapping uh the mapping is

225
00:11:09,060 --> 00:11:13,260
has one one uh only one purpose to

226
00:11:13,260 --> 00:11:16,800
translate The Logical page numbers to uh

227
00:11:16,800 --> 00:11:19,380
their physical page number equivalent

228
00:11:19,380 --> 00:11:22,260
for both the object that data and index

229
00:11:22,260 --> 00:11:24,839
that that the BTR

230
00:11:24,839 --> 00:11:28,440
uh one was part of the flare team in in

231
00:11:28,440 --> 00:11:31,260
FireEye I reversed the format the format

232
00:11:31,260 --> 00:11:35,760
of uh wmi and right wrote a paper and

233
00:11:35,760 --> 00:11:39,060
released uh several forensic tools with

234
00:11:39,060 --> 00:11:42,300
my good good friends uh uh Willie and

235
00:11:42,300 --> 00:11:44,660
Matt

236
00:11:45,420 --> 00:11:47,700
so let's go a little bit deeper into the

237
00:11:47,700 --> 00:11:50,760
the forensics how it works in in simple

238
00:11:50,760 --> 00:11:53,160
terms so pretty much the search storage

239
00:11:53,160 --> 00:11:56,399
path is constructed by using the

240
00:11:56,399 --> 00:11:59,160
identifier of the namespace class

241
00:11:59,160 --> 00:12:01,079
and the instance

242
00:12:01,079 --> 00:12:04,500
the index.btr is searched and then the

243
00:12:04,500 --> 00:12:07,140
the corresponding index record is found

244
00:12:07,140 --> 00:12:10,200
which contains the logical page number

245
00:12:10,200 --> 00:12:12,600
of the in the object data for the record

246
00:12:12,600 --> 00:12:14,220
that you're looking for the record

247
00:12:14,220 --> 00:12:17,459
identifier and its size then the mapping

248
00:12:17,459 --> 00:12:20,040
file is used to translate The Logical

249
00:12:20,040 --> 00:12:22,620
page number into its physical uh

250
00:12:22,620 --> 00:12:25,440
equivalent then now we have the physical

251
00:12:25,440 --> 00:12:27,959
page where the data you are you are

252
00:12:27,959 --> 00:12:30,300
looking for it's in object that data you

253
00:12:30,300 --> 00:12:32,279
go through that page record by record

254
00:12:32,279 --> 00:12:34,560
and identify the one that you're looking

255
00:12:34,560 --> 00:12:37,380
for by looking at the record ID of

256
00:12:37,380 --> 00:12:39,360
course the size in the index record

257
00:12:39,360 --> 00:12:41,940
should match the the actual size in the

258
00:12:41,940 --> 00:12:44,639
objects that data also the same approach

259
00:12:44,639 --> 00:12:48,240
can be used for index.btr because it's

260
00:12:48,240 --> 00:12:51,380
it's a bit B3 implementation and

261
00:12:51,380 --> 00:12:54,420
the pointers to the next nodes in the B3

262
00:12:54,420 --> 00:12:58,500
are specified as logical page numbers

263
00:12:58,500 --> 00:13:02,399
now that we know how to pass the

264
00:13:02,399 --> 00:13:04,320
now that we know that how to parse the

265
00:13:04,320 --> 00:13:09,060
the repository we took uh we we did a

266
00:13:09,060 --> 00:13:11,579
very quick exercise to figure out what

267
00:13:11,579 --> 00:13:16,680
is in actual uh database for a Lenovo uh

268
00:13:16,680 --> 00:13:20,040
machine so we saw that in the root wmi

269
00:13:20,040 --> 00:13:23,600
netspace we have uh very interesting

270
00:13:23,600 --> 00:13:26,639
classes starting with Lenovo underscore

271
00:13:26,639 --> 00:13:29,160
as prefix one of them it's a bio setting

272
00:13:29,160 --> 00:13:31,560
another one is Lenovo set biosetting

273
00:13:31,560 --> 00:13:34,380
another one is Lenovo set BIOS password

274
00:13:34,380 --> 00:13:36,720
and in the right we have the definition

275
00:13:36,720 --> 00:13:38,700
the complete definition with properties

276
00:13:38,700 --> 00:13:41,639
in it for which current setting pick our

277
00:13:41,639 --> 00:13:43,980
attention it's a string and if we're

278
00:13:43,980 --> 00:13:46,860
trying to look uh in the repository for

279
00:13:46,860 --> 00:13:49,740
instances of this class we have empty

280
00:13:49,740 --> 00:13:53,300
results which means this class is uh

281
00:13:53,300 --> 00:13:56,160
dynamically created on the Fly by a

282
00:13:56,160 --> 00:13:59,220
custom provider that is implemented by

283
00:13:59,220 --> 00:14:03,360
the OEM vendor so we can use a w my to

284
00:14:03,360 --> 00:14:06,120
actually look for non-empty instances of

285
00:14:06,120 --> 00:14:08,399
this class and then printing out the

286
00:14:08,399 --> 00:14:11,279
current settings we have this uh these

287
00:14:11,279 --> 00:14:13,560
results if we magnify a little bit we

288
00:14:13,560 --> 00:14:17,040
see some information about The Trusted

289
00:14:17,040 --> 00:14:20,660
execution the TPM and also

290
00:14:20,660 --> 00:14:24,540
about update updating the BIOS

291
00:14:24,540 --> 00:14:28,260
which means that having those classes

292
00:14:28,260 --> 00:14:31,680
you can alter the

293
00:14:31,680 --> 00:14:34,320
settings of the BIOS from the user land

294
00:14:34,320 --> 00:14:36,839
remember that there is a Lenovo

295
00:14:36,839 --> 00:14:39,720
underscore set bios setting so which

296
00:14:39,720 --> 00:14:41,459
means

297
00:14:41,459 --> 00:14:44,579
Lenovo provides an interface in the in

298
00:14:44,579 --> 00:14:47,579
the firmware so the wmi provider can

299
00:14:47,579 --> 00:14:48,899
communicate to

300
00:14:48,899 --> 00:14:51,899
to read or alter

301
00:14:51,899 --> 00:14:54,660
the settings which from my point of view

302
00:14:54,660 --> 00:14:57,779
as the device security startup is pretty

303
00:14:57,779 --> 00:14:59,519
scary

304
00:14:59,519 --> 00:15:03,060
also the standard provides a class with

305
00:15:03,060 --> 00:15:05,880
32 bios to give us information about the

306
00:15:05,880 --> 00:15:09,320
the current uh the current uh BIOS

307
00:15:09,320 --> 00:15:12,720
version uh it's serial the device serial

308
00:15:12,720 --> 00:15:15,779
number and also the OEM vendor

309
00:15:15,779 --> 00:15:18,899
so now let's look at how the wmi is

310
00:15:18,899 --> 00:15:20,220
leveraged by both Defenders and

311
00:15:20,220 --> 00:15:23,339
attackers for Defenders it's a it's a

312
00:15:23,339 --> 00:15:25,800
great tool to uh to use uh to gather

313
00:15:25,800 --> 00:15:28,199
Telemetry for attackers is a great

314
00:15:28,199 --> 00:15:30,060
living of the land infrastructure to

315
00:15:30,060 --> 00:15:34,199
perform a malicious uh activities

316
00:15:34,199 --> 00:15:38,420
so how the threat actors leverage wmi

317
00:15:38,420 --> 00:15:40,139
reconnaissance you can start with

318
00:15:40,139 --> 00:15:43,740
reconnaissance AV detection and so on

319
00:15:43,740 --> 00:15:47,339
in the next slides I'll present an

320
00:15:47,339 --> 00:15:51,620
example of how in the wild wmi is

321
00:15:51,620 --> 00:15:54,839
leveraged for far less persistence

322
00:15:54,839 --> 00:15:57,120
called the execution and data storage

323
00:15:57,120 --> 00:15:59,459
so pretty much we have a three we have a

324
00:15:59,459 --> 00:16:03,420
trigger or even filter that

325
00:16:03,420 --> 00:16:04,860
triggers

326
00:16:04,860 --> 00:16:07,320
several seconds after the system power

327
00:16:07,320 --> 00:16:11,519
up to allow the uh the the device to to

328
00:16:11,519 --> 00:16:14,880
boot up which will this this trigger

329
00:16:14,880 --> 00:16:16,560
will make the command line event

330
00:16:16,560 --> 00:16:19,560
consumer to execute what it will execute

331
00:16:19,560 --> 00:16:22,740
is a Powershell script that is located

332
00:16:22,740 --> 00:16:24,560
in the description

333
00:16:24,560 --> 00:16:27,600
property of the option class

334
00:16:27,600 --> 00:16:29,579
so we have the definition of the option

335
00:16:29,579 --> 00:16:32,279
class which has a name and a description

336
00:16:32,279 --> 00:16:34,079
both of them strings

337
00:16:34,079 --> 00:16:36,660
in the description that is called by the

338
00:16:36,660 --> 00:16:38,399
consumer we have the script if we look

339
00:16:38,399 --> 00:16:41,339
at the script very quick we see that it

340
00:16:41,339 --> 00:16:44,160
extracts the the encoded the base64

341
00:16:44,160 --> 00:16:47,160
encoded payload from the name property

342
00:16:47,160 --> 00:16:49,339
and uh

343
00:16:49,339 --> 00:16:53,959
decodes it drops it to disk the

344
00:16:53,959 --> 00:16:57,120
path specified in the configuration and

345
00:16:57,120 --> 00:17:00,240
then it Executives the second stage

346
00:17:00,240 --> 00:17:02,639
so the tools that we use in our research

347
00:17:02,639 --> 00:17:06,839
the WM test to showcase the wmi

348
00:17:06,839 --> 00:17:09,780
interaction scripting via vbscript and

349
00:17:09,780 --> 00:17:11,760
Powershell to play with

350
00:17:11,760 --> 00:17:14,459
filters and consumers also developed our

351
00:17:14,459 --> 00:17:15,559
own

352
00:17:15,559 --> 00:17:18,799
wmi client to

353
00:17:18,799 --> 00:17:22,140
look for for running processes

354
00:17:22,140 --> 00:17:25,799
so WMA attacks now let's switch to the

355
00:17:25,799 --> 00:17:27,720
main topic

356
00:17:27,720 --> 00:17:30,960
the threat model the thread model of wmi

357
00:17:30,960 --> 00:17:33,260
consists of the

358
00:17:33,260 --> 00:17:36,480
wmi service that connects an interact

359
00:17:36,480 --> 00:17:40,080
that communicates with consumers clients

360
00:17:40,080 --> 00:17:44,640
and providers via Advanced LPC ports uh

361
00:17:44,640 --> 00:17:48,539
LPC channels then we have the wmi files

362
00:17:48,539 --> 00:17:51,059
the repository and and the provider dlls

363
00:17:51,059 --> 00:17:52,919
and so on we have the configuration and

364
00:17:52,919 --> 00:17:56,280
registry and also the the data in the

365
00:17:56,280 --> 00:17:58,140
wmi service

366
00:17:58,140 --> 00:17:59,520
memory

367
00:17:59,520 --> 00:18:02,940
and then we split uh each one in uh in

368
00:18:02,940 --> 00:18:04,919
in each of the attacks in five buckets

369
00:18:04,919 --> 00:18:08,039
depending uh which are the targets uh

370
00:18:08,039 --> 00:18:11,360
the WNY data process the lapc

371
00:18:11,360 --> 00:18:13,559
connections the files and Registries

372
00:18:13,559 --> 00:18:17,880
then the the sandboxing of a wmi using a

373
00:18:17,880 --> 00:18:20,100
user mode attack and then some boxing of

374
00:18:20,100 --> 00:18:23,220
wmi using a decom attack

375
00:18:23,220 --> 00:18:26,340
so why the wmi attacks are so dangerous

376
00:18:26,340 --> 00:18:29,039
so these attacks have existed in in the

377
00:18:29,039 --> 00:18:33,419
uh in in wmi from the beginning and the

378
00:18:33,419 --> 00:18:36,419
reason for that is wi wasn't built for

379
00:18:36,419 --> 00:18:39,780
to be used for a security solution wmi

380
00:18:39,780 --> 00:18:41,820
was built just to gather Telemetry on

381
00:18:41,820 --> 00:18:42,660
the device

382
00:18:42,660 --> 00:18:45,240
also the wmi service is not considered a

383
00:18:45,240 --> 00:18:47,160
critical app it doesn't have PPL or a

384
00:18:47,160 --> 00:18:49,020
trust label

385
00:18:49,020 --> 00:18:51,559
and the solution the the

386
00:18:51,559 --> 00:18:54,240
Security Solutions

387
00:18:54,240 --> 00:18:56,880
don't have a way to check if the wmi has

388
00:18:56,880 --> 00:18:59,039
been disabled or has been tampered with

389
00:18:59,039 --> 00:19:02,340
so that on on top of that all these

390
00:19:02,340 --> 00:19:03,419
attacks

391
00:19:03,419 --> 00:19:06,419
are architectural flaws

392
00:19:06,419 --> 00:19:08,760
which cannot be just fixed with a simple

393
00:19:08,760 --> 00:19:11,240
patch

394
00:19:13,740 --> 00:19:15,660
so let's start with the fur the first

395
00:19:15,660 --> 00:19:18,660
bucket which is uh attacks on files and

396
00:19:18,660 --> 00:19:22,020
registry configuration so you can modify

397
00:19:22,020 --> 00:19:24,179
content you can remove files you can

398
00:19:24,179 --> 00:19:26,280
restrict access to the files on disks

399
00:19:26,280 --> 00:19:29,820
like the the the files that represent

400
00:19:29,820 --> 00:19:33,179
the database or the provider dlls in the

401
00:19:33,179 --> 00:19:35,220
registry we have the the service

402
00:19:35,220 --> 00:19:39,620
configuration and uh the the other the

403
00:19:39,620 --> 00:19:43,320
wmi internal settings

404
00:19:43,320 --> 00:19:46,380
so let's the first attack uh there is an

405
00:19:46,380 --> 00:19:48,539
a there is a registry key called enable

406
00:19:48,539 --> 00:19:51,840
events when a new event comes if wmi

407
00:19:51,840 --> 00:19:54,299
client comes in that's the following uh

408
00:19:54,299 --> 00:19:56,820
call stack on any TSS which stands for

409
00:19:56,820 --> 00:20:00,240
initialized event subsystem is called in

410
00:20:00,240 --> 00:20:04,020
it in inside the the function

411
00:20:04,020 --> 00:20:06,840
the enabled events registry value is red

412
00:20:06,840 --> 00:20:10,080
if it's different from one then an inter

413
00:20:10,080 --> 00:20:12,299
a pointer to the interface is uh

414
00:20:12,299 --> 00:20:15,120
obtained and success is returned if so

415
00:20:15,120 --> 00:20:18,720
an attacker basically can write a number

416
00:20:18,720 --> 00:20:20,880
different from one on the in the in the

417
00:20:20,880 --> 00:20:24,600
registry if value restart the wmi

418
00:20:24,600 --> 00:20:29,039
service and then everything is disabled

419
00:20:29,039 --> 00:20:32,039
so the UW my interest infrastructure in

420
00:20:32,039 --> 00:20:33,360
the user space

421
00:20:33,360 --> 00:20:35,640
uh the most important is the is the

422
00:20:35,640 --> 00:20:36,840
service

423
00:20:36,840 --> 00:20:39,600
the service uh the main Services wmi

424
00:20:39,600 --> 00:20:43,380
svcd is the wmysc SVC dll it's

425
00:20:43,380 --> 00:20:46,080
implemented as we see host service dll

426
00:20:46,080 --> 00:20:48,840
and the other dlls that are important

427
00:20:48,840 --> 00:20:51,960
for our discussion the wbm core the

428
00:20:51,960 --> 00:20:55,940
webdr VFS and wbms

429
00:20:56,640 --> 00:20:58,799
so let's look at the templates how this

430
00:20:58,799 --> 00:21:01,320
is attacked

431
00:21:01,320 --> 00:21:04,320
so we have a the code of a certain dll

432
00:21:04,320 --> 00:21:05,700
and on the right we have the running

433
00:21:05,700 --> 00:21:08,820
memory so when the dll is loaded the

434
00:21:08,820 --> 00:21:10,860
global flag is initialized to its

435
00:21:10,860 --> 00:21:13,020
default value in this case Zero in the

436
00:21:13,020 --> 00:21:15,720
initialized uh function uh this flag is

437
00:21:15,720 --> 00:21:18,020
termed one when a new connection or

438
00:21:18,020 --> 00:21:20,520
registration of an event filter comes in

439
00:21:20,520 --> 00:21:24,240
the global tag is checked if it's true

440
00:21:24,240 --> 00:21:27,720
or one then uh the the event is process

441
00:21:27,720 --> 00:21:30,419
the the event is processed and success

442
00:21:30,419 --> 00:21:32,280
is returned we have a new connection

443
00:21:32,280 --> 00:21:34,919
established and the registration uh

444
00:21:34,919 --> 00:21:36,000
successful

445
00:21:36,000 --> 00:21:37,620
then

446
00:21:37,620 --> 00:21:40,860
an attacker can clear the global flag so

447
00:21:40,860 --> 00:21:44,580
the error path in the dispatch routine

448
00:21:44,580 --> 00:21:47,640
is taken the event is dropped and then

449
00:21:47,640 --> 00:21:49,620
the error is returned

450
00:21:49,620 --> 00:21:52,919
so we'll talk about all these flags so

451
00:21:52,919 --> 00:21:56,280
different flags in different uh

452
00:21:56,280 --> 00:21:58,980
dlls can be attacked the only difference

453
00:21:58,980 --> 00:22:01,799
is the error returns after the attack

454
00:22:01,799 --> 00:22:04,860
when you we disable wmi

455
00:22:04,860 --> 00:22:06,720
so we'll try we'll start with the global

456
00:22:06,720 --> 00:22:08,520
Boolean variable do not allow new

457
00:22:08,520 --> 00:22:11,460
connections when the WM Accord dll is

458
00:22:11,460 --> 00:22:14,039
loaded then it is set to false

459
00:22:14,039 --> 00:22:16,860
in the when the it is unloaded in the

460
00:22:16,860 --> 00:22:20,520
shutdown method it is set to True when a

461
00:22:20,520 --> 00:22:21,840
new double my commission comes in

462
00:22:21,840 --> 00:22:25,200
ensuring it initialize is finally called

463
00:22:25,200 --> 00:22:29,340
and uh when is it called if it's false

464
00:22:29,340 --> 00:22:31,280
then the initialize the the system is

465
00:22:31,280 --> 00:22:33,440
initialized and uh

466
00:22:33,440 --> 00:22:36,539
everything works correctly if an

467
00:22:36,539 --> 00:22:39,179
attacker comes in on on the uh to turn

468
00:22:39,179 --> 00:22:41,520
this value to true then the insurers

469
00:22:41,520 --> 00:22:43,740
initial initialize and return an error

470
00:22:43,740 --> 00:22:46,140
which is called a server stopping

471
00:22:46,140 --> 00:22:50,299
so now it's time for the first demo

472
00:23:22,200 --> 00:23:25,039
thank you

473
00:24:10,320 --> 00:24:12,980
amazing

474
00:24:43,200 --> 00:24:45,440
foreign

475
00:25:16,320 --> 00:25:18,439
thank you

476
00:25:38,220 --> 00:25:40,020
cool

477
00:25:40,020 --> 00:25:42,559
nice

478
00:25:44,340 --> 00:25:47,520
thank you so let's introduce wmi check

479
00:25:47,520 --> 00:25:49,260
which is a tool developed by Andre

480
00:25:49,260 --> 00:25:51,980
redplate

481
00:25:52,279 --> 00:25:54,720
consists of a console app and a kernel

482
00:25:54,720 --> 00:25:59,100
driver it can it can scan uh the process

483
00:25:59,100 --> 00:26:01,020
process and parse the wmi internal

484
00:26:01,020 --> 00:26:02,700
objects

485
00:26:02,700 --> 00:26:04,740
uh you can do that for a specific

486
00:26:04,740 --> 00:26:08,159
process and also for uh for the whole

487
00:26:08,159 --> 00:26:10,559
system on the right side we have the all

488
00:26:10,559 --> 00:26:12,179
the options that are supported on the

489
00:26:12,179 --> 00:26:15,120
left side uh it's a screenshot of how uh

490
00:26:15,120 --> 00:26:19,020
double my check can detect uh wmi data

491
00:26:19,020 --> 00:26:22,440
patching so you have a snapshot before

492
00:26:22,440 --> 00:26:24,059
and after the attack comparing the

493
00:26:24,059 --> 00:26:26,460
snapshot you see how the internal flags

494
00:26:26,460 --> 00:26:28,440
are modified between a different

495
00:26:28,440 --> 00:26:32,940
instances so next demo showing how to

496
00:26:32,940 --> 00:26:36,299
detect the previous attack using the

497
00:26:36,299 --> 00:26:39,379
wmi check

498
00:27:15,900 --> 00:27:18,679
you know

499
00:27:36,300 --> 00:27:37,740
[Music]

500
00:27:37,740 --> 00:27:40,100
okay

501
00:27:47,460 --> 00:27:49,700
foreign

502
00:27:51,440 --> 00:27:54,059
core event delivery this is an internal

503
00:27:54,059 --> 00:27:57,179
flag the offset C in the ESC session uh

504
00:27:57,179 --> 00:28:00,240
field of C repository class

505
00:28:00,240 --> 00:28:03,600
pretty much when the dll is loaded the

506
00:28:03,600 --> 00:28:06,120
event delivery is set to its default

507
00:28:06,120 --> 00:28:07,679
value which is false in start event

508
00:28:07,679 --> 00:28:09,960
delivery is set to true and stop event

509
00:28:09,960 --> 00:28:13,620
delivery it is sent to false same same

510
00:28:13,620 --> 00:28:15,419
attack pattern you have an interesting

511
00:28:15,419 --> 00:28:17,460
event coming in you have the delivery

512
00:28:17,460 --> 00:28:19,799
delivery implicit event function an

513
00:28:19,799 --> 00:28:22,080
attacker will come in and Patch this

514
00:28:22,080 --> 00:28:24,419
flag to false

515
00:28:24,419 --> 00:28:27,240
so that the winner is nowhere or is is

516
00:28:27,240 --> 00:28:30,240
sent that's actually an error if you use

517
00:28:30,240 --> 00:28:33,480
failed on this error it returns true

518
00:28:33,480 --> 00:28:35,580
uh so what happened all the intrinsic

519
00:28:35,580 --> 00:28:38,039
events are disabled

520
00:28:38,039 --> 00:28:41,100
and let's see another demo

521
00:28:41,100 --> 00:28:43,140
about how this

522
00:28:43,140 --> 00:28:45,799
works

523
00:29:22,559 --> 00:29:24,799
foreign

524
00:29:55,919 --> 00:29:58,039
okay

525
00:30:06,779 --> 00:30:09,380
thank you

526
00:30:18,810 --> 00:30:22,950
[Applause]

527
00:30:41,580 --> 00:30:43,919
let's move on the next attack is a

528
00:30:43,919 --> 00:30:47,340
global Boolean variable which is called

529
00:30:47,340 --> 00:30:49,500
shutting down

530
00:30:49,500 --> 00:30:52,620
when the DLR is loaded he said we need a

531
00:30:52,620 --> 00:30:54,480
value which is false in the initialize

532
00:30:54,480 --> 00:30:58,080
class in C repository in a initialize

533
00:30:58,080 --> 00:31:00,000
method in C repository is sent to false

534
00:31:00,000 --> 00:31:02,039
in the shutdown set to true

535
00:31:02,039 --> 00:31:04,860
this uh flag is checked in more than 50

536
00:31:04,860 --> 00:31:07,100
functions so a

537
00:31:07,100 --> 00:31:09,659
template of this of a dispatching

538
00:31:09,659 --> 00:31:11,880
routine looks like this so the obvious

539
00:31:11,880 --> 00:31:16,080
attack is just to set the flag to uh

540
00:31:16,080 --> 00:31:18,179
to false because it's the reverse uh

541
00:31:18,179 --> 00:31:20,640
logic and then

542
00:31:20,640 --> 00:31:22,520
um

543
00:31:22,520 --> 00:31:25,380
true actually to to make sure that the

544
00:31:25,380 --> 00:31:28,799
error is returned uh if it if it falls

545
00:31:28,799 --> 00:31:31,740
then the internal dispatch is uh is

546
00:31:31,740 --> 00:31:33,000
executed

547
00:31:33,000 --> 00:31:35,880
now let's move to another flag in the G

548
00:31:35,880 --> 00:31:39,779
Global instance a global instance of the

549
00:31:39,779 --> 00:31:43,919
field of set 0 g Globe is a group a

550
00:31:43,919 --> 00:31:45,840
global instance for the C globals class

551
00:31:45,840 --> 00:31:48,539
in the Constructor we see it is set one

552
00:31:48,539 --> 00:31:51,000
in the initialize method it is set to

553
00:31:51,000 --> 00:31:54,779
zero and we have this uh call stack when

554
00:31:54,779 --> 00:31:57,120
a new filter comes in put object is

555
00:31:57,120 --> 00:32:00,360
called and also calls the get core

556
00:32:00,360 --> 00:32:01,860
Services

557
00:32:01,860 --> 00:32:03,918
um

558
00:32:04,200 --> 00:32:06,659
next and then the attack is again

559
00:32:06,659 --> 00:32:09,779
obvious we set this value to zero so the

560
00:32:09,779 --> 00:32:12,120
return

561
00:32:12,120 --> 00:32:14,640
return is an error the WMA

562
00:32:14,640 --> 00:32:18,500
initialization failure which will be

563
00:32:20,700 --> 00:32:24,720
picked out by the put object and then

564
00:32:24,720 --> 00:32:27,559
return return

565
00:32:27,720 --> 00:32:29,760
the error

566
00:32:29,760 --> 00:32:32,880
next uh this is the same attack

567
00:32:32,880 --> 00:32:35,100
as the previous one

568
00:32:35,100 --> 00:32:39,000
the the field that offset 38 in the same

569
00:32:39,000 --> 00:32:41,220
G globe

570
00:32:41,220 --> 00:32:44,880
instance the only difference is that the

571
00:32:44,880 --> 00:32:47,220
the field that offset 38 is actually a

572
00:32:47,220 --> 00:32:49,200
pointer to an interface to double my

573
00:32:49,200 --> 00:32:52,020
core services and the obvious attack is

574
00:32:52,020 --> 00:32:55,320
uh just setting uh null or zero to this

575
00:32:55,320 --> 00:32:59,700
to this value which will make uh

576
00:32:59,700 --> 00:33:02,340
get core Services return the same error

577
00:33:02,340 --> 00:33:06,120
as before now uh the

578
00:33:06,120 --> 00:33:09,600
word field at the offset BC in the in G

579
00:33:09,600 --> 00:33:11,100
globe

580
00:33:11,100 --> 00:33:13,620
it's set one when when the dll is loaded

581
00:33:13,620 --> 00:33:17,279
in an ash in in uninitialized is set to

582
00:33:17,279 --> 00:33:20,580
uh zero when uh double my connection

583
00:33:20,580 --> 00:33:21,840
comes in

584
00:33:21,840 --> 00:33:24,480
we have the deserialization function

585
00:33:24,480 --> 00:33:28,679
file to instance called and in there we

586
00:33:28,679 --> 00:33:31,860
see that if it's zero it returns uh

587
00:33:31,860 --> 00:33:33,779
error server shutdown in progress which

588
00:33:33,779 --> 00:33:35,880
is an internal error so the attackers

589
00:33:35,880 --> 00:33:40,860
has to set this uh field to zero then uh

590
00:33:40,860 --> 00:33:44,700
the internal error is uh is set and it's

591
00:33:44,700 --> 00:33:47,580
translated on out to a external error a

592
00:33:47,580 --> 00:33:50,760
w bam error in the A51 translator or

593
00:33:50,760 --> 00:33:52,940
code

594
00:33:53,039 --> 00:33:59,039
and the next is the G underscore p e s s

595
00:33:59,039 --> 00:34:03,600
M4 which is a global variable that keeps

596
00:34:03,600 --> 00:34:05,399
the pointer to an interface

597
00:34:05,399 --> 00:34:09,179
so uh when the dll is loaded it is set

598
00:34:09,179 --> 00:34:13,260
to null then uh it's it is set using the

599
00:34:13,260 --> 00:34:15,060
query interface

600
00:34:15,060 --> 00:34:18,179
in the initss and then it is released

601
00:34:18,179 --> 00:34:19,679
the interface is pointer to the

602
00:34:19,679 --> 00:34:21,839
interface is released when shut down ESS

603
00:34:21,839 --> 00:34:24,300
is called

604
00:34:24,300 --> 00:34:26,580
so we have this call stack

605
00:34:26,580 --> 00:34:30,060
and we get the last two functions the

606
00:34:30,060 --> 00:34:32,219
exact notification query calls get ESS

607
00:34:32,219 --> 00:34:35,460
sync which is just returning that uh

608
00:34:35,460 --> 00:34:38,639
that variable and then based on the in

609
00:34:38,639 --> 00:34:41,159
return if the if an attacker comes in

610
00:34:41,159 --> 00:34:44,580
and Patch the uh the global uh variable

611
00:34:44,580 --> 00:34:48,000
and set null to it then this will the

612
00:34:48,000 --> 00:34:51,899
the calling function will return the WN

613
00:34:51,899 --> 00:34:54,659
not supported

614
00:34:54,659 --> 00:34:57,780
next a new type of attack is some some

615
00:34:57,780 --> 00:35:01,740
boxing wmi so wmi Service as we

616
00:35:01,740 --> 00:35:04,260
mentioned uh communicate with uh

617
00:35:04,260 --> 00:35:07,080
providers and client consumers using

618
00:35:07,080 --> 00:35:10,740
Advanced LPC uh connections also it

619
00:35:10,740 --> 00:35:12,599
interacts with the file system on the

620
00:35:12,599 --> 00:35:13,820
registry

621
00:35:13,820 --> 00:35:18,119
as we mentioned before so to sandbox wmi

622
00:35:18,119 --> 00:35:21,960
agent wmi uh service to only isolate him

623
00:35:21,960 --> 00:35:24,839
it from the OS we have to set the

624
00:35:24,839 --> 00:35:27,140
untrust the Integrity level to untrusted

625
00:35:27,140 --> 00:35:31,619
and we have to revoke the SE impersonal

626
00:35:31,619 --> 00:35:35,760
privilege privilege of the service app

627
00:35:35,760 --> 00:35:38,359
and what's happening

628
00:35:38,359 --> 00:35:40,859
this then the service become isolated

629
00:35:40,859 --> 00:35:43,200
every connection request will get the

630
00:35:43,200 --> 00:35:44,880
access denied

631
00:35:44,880 --> 00:35:48,480
and how this is uh achieved we can do

632
00:35:48,480 --> 00:35:50,760
this in on in the user land

633
00:35:50,760 --> 00:35:53,760
using uh these two functions and then

634
00:35:53,760 --> 00:35:56,220
you can use decom attack in the kernel

635
00:35:56,220 --> 00:35:59,700
to modify the the token uh belonging to

636
00:35:59,700 --> 00:36:02,400
the wmi service

637
00:36:02,400 --> 00:36:06,780
and as a result we have a sandboxed wmi

638
00:36:06,780 --> 00:36:07,740
service

639
00:36:07,740 --> 00:36:10,079
so let's introduce let me introduce the

640
00:36:10,079 --> 00:36:11,940
memory Ranger which is a solution that

641
00:36:11,940 --> 00:36:14,160
can prevent against the decom attack on

642
00:36:14,160 --> 00:36:17,099
the uh on the wmi token of the of the

643
00:36:17,099 --> 00:36:21,180
wmi service process how this is done uh

644
00:36:21,180 --> 00:36:25,619
the memory Rangers uh traps the loading

645
00:36:25,619 --> 00:36:28,680
of the attacker's driver creates a

646
00:36:28,680 --> 00:36:31,619
memory a separate memory Enclave where

647
00:36:31,619 --> 00:36:34,020
the attacker's driver is running in

648
00:36:34,020 --> 00:36:37,400
where it doesn't have any access to uh

649
00:36:37,400 --> 00:36:40,560
modify the token belonging to double my

650
00:36:40,560 --> 00:36:42,480
service

651
00:36:42,480 --> 00:36:44,520
so um

652
00:36:44,520 --> 00:36:46,339
as a conclusion

653
00:36:46,339 --> 00:36:49,560
we did this research

654
00:36:49,560 --> 00:36:53,460
more like to tell the industry that they

655
00:36:53,460 --> 00:36:55,800
when they're leveraging some type of

656
00:36:55,800 --> 00:36:59,160
solutions they understand their risks

657
00:36:59,160 --> 00:37:02,099
that they're uh there is that they are

658
00:37:02,099 --> 00:37:04,980
exposed to so this is

659
00:37:04,980 --> 00:37:08,400
in any case A bash of that is a very

660
00:37:08,400 --> 00:37:11,640
very interesting uh and very very useful

661
00:37:11,640 --> 00:37:15,780
uh solution is more like a wake-up call

662
00:37:15,780 --> 00:37:18,180
be sure you have in place

663
00:37:18,180 --> 00:37:20,880
mitigations are way to detect if this

664
00:37:20,880 --> 00:37:22,740
functionality has been

665
00:37:22,740 --> 00:37:26,220
tampered with either disabled or or to

666
00:37:26,220 --> 00:37:28,140
send bogus information

667
00:37:28,140 --> 00:37:31,579
uh and everything that we showed that uh

668
00:37:31,579 --> 00:37:33,780
all the attacks that we showed are

669
00:37:33,780 --> 00:37:35,280
attacking the the architectural

670
00:37:35,280 --> 00:37:38,460
weaknesses we call this attacks uh most

671
00:37:38,460 --> 00:37:39,800
of them are

672
00:37:39,800 --> 00:37:44,520
one bit change attack you just flip

673
00:37:44,520 --> 00:37:46,020
a bit

674
00:37:46,020 --> 00:37:49,020
and everything is disabled

675
00:37:49,020 --> 00:37:52,200
we introduced wmi check that can pretty

676
00:37:52,200 --> 00:37:53,339
much

677
00:37:53,339 --> 00:37:56,060
detect

678
00:37:56,640 --> 00:37:59,520
W my attacks on on the on the on the

679
00:37:59,520 --> 00:38:03,240
service data and then memory Ranger that

680
00:38:03,240 --> 00:38:06,720
can prevent the sandboxing of wmi

681
00:38:06,720 --> 00:38:10,140
for the decoma the data kernel object

682
00:38:10,140 --> 00:38:13,740
direct kernel object manipulation attack

683
00:38:13,740 --> 00:38:16,380
so another conclusion to conclusion

684
00:38:16,380 --> 00:38:18,300
pretty much all these attacks can

685
00:38:18,300 --> 00:38:21,900
originate from uh from firmware and uh

686
00:38:21,900 --> 00:38:24,960
right now former is a big blind spot for

687
00:38:24,960 --> 00:38:26,460
the industry

688
00:38:26,460 --> 00:38:29,520
and we see every time we have uh

689
00:38:29,520 --> 00:38:31,800
different attacks that originate in

690
00:38:31,800 --> 00:38:34,320
firmware that has been stealthy for

691
00:38:34,320 --> 00:38:38,040
for six to seven years so I think this

692
00:38:38,040 --> 00:38:39,300
is one thing that I want to leave

693
00:38:39,300 --> 00:38:41,880
everybody out that this attacks happen

694
00:38:41,880 --> 00:38:44,640
in the user land what can originate in

695
00:38:44,640 --> 00:38:49,140
the formula also one one to plug uh my

696
00:38:49,140 --> 00:38:51,900
co-founder and CEO of Winery talk that

697
00:38:51,900 --> 00:38:55,380
follows this talk at 11 10. which is

698
00:38:55,380 --> 00:38:57,119
very interesting one it will he'll drop

699
00:38:57,119 --> 00:39:00,660
11 new vulnerabilities and you will talk

700
00:39:00,660 --> 00:39:03,839
about exploiting early boot phases

701
00:39:03,839 --> 00:39:06,680
thank you very much

702
00:39:07,870 --> 00:39:10,989
[Music]

703
00:39:14,840 --> 00:39:17,929
[Music]

