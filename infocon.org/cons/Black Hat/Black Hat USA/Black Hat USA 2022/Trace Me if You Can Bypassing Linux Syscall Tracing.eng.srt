1
00:00:01,390 --> 00:00:07,940
[Music]

2
00:00:07,940 --> 00:00:10,980
okay everyone uh thank you everyone for

3
00:00:10,980 --> 00:00:14,120
coming to this talk my name is Rex wall

4
00:00:14,120 --> 00:00:18,000
and this is my co-speaker genuine Zhang

5
00:00:18,000 --> 00:00:20,340
you can read about us online we have a

6
00:00:20,340 --> 00:00:22,320
lot of things to cover today so we're

7
00:00:22,320 --> 00:00:25,640
just going to Jump Right In

8
00:00:26,039 --> 00:00:29,900
so imagine a sophisticated attacker

9
00:00:29,900 --> 00:00:32,220
compromise your Linux production

10
00:00:32,220 --> 00:00:33,420
environment

11
00:00:33,420 --> 00:00:36,239
uh he launches a lock for Shell exploit

12
00:00:36,239 --> 00:00:38,460
and then executed a reverse shell back

13
00:00:38,460 --> 00:00:40,940
to his machine

14
00:00:41,399 --> 00:00:43,500
then he discovered that the machine has

15
00:00:43,500 --> 00:00:45,059
a vulnerable version of pseudo running

16
00:00:45,059 --> 00:00:49,459
on it so he elevated the privilege

17
00:00:51,059 --> 00:00:52,440
and he tried to read the Etsy Shadow

18
00:00:52,440 --> 00:00:53,579
file to see if there's anything

19
00:00:53,579 --> 00:00:56,660
interesting to crack

20
00:00:57,600 --> 00:00:59,820
then he also found out that he can move

21
00:00:59,820 --> 00:01:01,620
to another Machine by reading into the

22
00:01:01,620 --> 00:01:05,719
SSH processing environmental variable

23
00:01:05,820 --> 00:01:07,740
so he happily moved to the second

24
00:01:07,740 --> 00:01:12,540
machine and as he is celebrating

25
00:01:12,540 --> 00:01:16,080
he discovered that his assets was gone

26
00:01:16,080 --> 00:01:18,840
so he fired the RC again and this time

27
00:01:18,840 --> 00:01:21,360
there's no luck quickly he find out his

28
00:01:21,360 --> 00:01:24,320
assets was blocked

29
00:01:24,540 --> 00:01:26,159
so now let's take a look at the other

30
00:01:26,159 --> 00:01:27,720
side of the story

31
00:01:27,720 --> 00:01:30,360
as everything happens your security

32
00:01:30,360 --> 00:01:33,119
engineer received a sequence of alerts

33
00:01:33,119 --> 00:01:35,040
from The Cutting Edge security

34
00:01:35,040 --> 00:01:38,040
monitoring software and these softwares

35
00:01:38,040 --> 00:01:40,140
monitor the processing information and

36
00:01:40,140 --> 00:01:41,880
all the system calls happening on the

37
00:01:41,880 --> 00:01:44,540
machine so for example

38
00:01:44,540 --> 00:01:47,460
when a reverse shell is executed there

39
00:01:47,460 --> 00:01:49,380
will be a connection call and there may

40
00:01:49,380 --> 00:01:52,020
be others depending on the technique

41
00:01:52,020 --> 00:01:54,540
when the attacker tried to read the Etsy

42
00:01:54,540 --> 00:01:56,520
Shadow file they will be either open or

43
00:01:56,520 --> 00:01:59,100
open ad system call

44
00:01:59,100 --> 00:02:03,240
now the question is how does how do you

45
00:02:03,240 --> 00:02:05,880
use this level of visibility to actually

46
00:02:05,880 --> 00:02:09,139
perform a threat detection

47
00:02:10,199 --> 00:02:12,840
so we want to use a really really simple

48
00:02:12,840 --> 00:02:16,260
detection rule to illustrate the idea

49
00:02:16,260 --> 00:02:19,200
so this rule is saying um I want to

50
00:02:19,200 --> 00:02:21,360
detect untrusted program that's reading

51
00:02:21,360 --> 00:02:23,280
the Etsy Shadow file now let me explain

52
00:02:23,280 --> 00:02:25,560
the rule the rule is saying if the

53
00:02:25,560 --> 00:02:28,020
system call is open or open at

54
00:02:28,020 --> 00:02:30,959
and it has re-permission

55
00:02:30,959 --> 00:02:34,020
and the file name argument points to the

56
00:02:34,020 --> 00:02:36,540
SC Shadow file

57
00:02:36,540 --> 00:02:39,000
and also the program is not in the allow

58
00:02:39,000 --> 00:02:41,040
list of programs

59
00:02:41,040 --> 00:02:44,160
then we'll fire the alert

60
00:02:44,160 --> 00:02:46,800
so you can see that you can quickly

61
00:02:46,800 --> 00:02:49,140
build out really complicated rules with

62
00:02:49,140 --> 00:02:51,120
even multiple system calls you can even

63
00:02:51,120 --> 00:02:54,000
build a machine learning algorithms on

64
00:02:54,000 --> 00:02:56,160
top of these visibility

65
00:02:56,160 --> 00:02:59,220
but all these logic relies on the fact

66
00:02:59,220 --> 00:03:01,500
that the system called software is able

67
00:03:01,500 --> 00:03:05,180
to extract the data correctly

68
00:03:06,300 --> 00:03:07,980
so in this talk we're going to dive

69
00:03:07,980 --> 00:03:09,720
really deep into how system called

70
00:03:09,720 --> 00:03:11,700
tracing works and then we'll talk about

71
00:03:11,700 --> 00:03:14,280
the vulnerabilities in the system called

72
00:03:14,280 --> 00:03:16,560
tracing software once we understand the

73
00:03:16,560 --> 00:03:18,000
vulnerability we'll talk about how to

74
00:03:18,000 --> 00:03:19,940
actually exploit these vulnerabilities

75
00:03:19,940 --> 00:03:22,140
and then we'll conclude with mitigations

76
00:03:22,140 --> 00:03:25,099
and takeaways

77
00:03:25,220 --> 00:03:27,360
thank you

78
00:03:27,360 --> 00:03:30,060
yeah thank you Rex um as last mentioned

79
00:03:30,060 --> 00:03:31,800
Cisco tradition is really important with

80
00:03:31,800 --> 00:03:33,060
the text best

81
00:03:33,060 --> 00:03:34,860
so this diagram gives you an overview

82
00:03:34,860 --> 00:03:37,440
for Cisco tracing basically including

83
00:03:37,440 --> 00:03:39,959
two parts one is the hopes for C4

84
00:03:39,959 --> 00:03:41,580
interception and also the tracing

85
00:03:41,580 --> 00:03:42,480
program

86
00:03:42,480 --> 00:03:44,340
so one application issue a system called

87
00:03:44,340 --> 00:03:46,019
into the kernel the assist or code pass

88
00:03:46,019 --> 00:03:49,260
is executed if any hooks plays in the

89
00:03:49,260 --> 00:03:51,299
co-pass the attached tracing program

90
00:03:51,299 --> 00:03:53,220
will be triggered to collect seasonal

91
00:03:53,220 --> 00:03:55,739
information and send those data to the

92
00:03:55,739 --> 00:03:58,620
monitor agent to detect threat

93
00:03:58,620 --> 00:04:00,599
the tracing program can be implemented

94
00:04:00,599 --> 00:04:03,360
and in kernel space as shown on the left

95
00:04:03,360 --> 00:04:05,819
diagram or implemented as a user space

96
00:04:05,819 --> 00:04:08,220
program as part of the monitoring agent

97
00:04:08,220 --> 00:04:11,720
which is shown on the right diagram

98
00:04:11,760 --> 00:04:13,920
so the program used to collect seasonal

99
00:04:13,920 --> 00:04:15,780
data like system arguments is called

100
00:04:15,780 --> 00:04:16,918
tracing program

101
00:04:16,918 --> 00:04:18,540
this program can be attached to

102
00:04:18,540 --> 00:04:21,000
different hooks like Trace point k-pro

103
00:04:21,000 --> 00:04:22,440
or P Trace

104
00:04:22,440 --> 00:04:24,479
we can directly use Linux native

105
00:04:24,479 --> 00:04:27,240
magnesis as a tracing program or you can

106
00:04:27,240 --> 00:04:29,699
Implement your own tracing program as

107
00:04:29,699 --> 00:04:32,280
kernel module adbf Pro or use a Space

108
00:04:32,280 --> 00:04:34,500
Program

109
00:04:34,500 --> 00:04:36,780
the first kind of hooks for Cisco

110
00:04:36,780 --> 00:04:39,180
interception is called Chase point

111
00:04:39,180 --> 00:04:41,699
it's a steady hook in the kernel for

112
00:04:41,699 --> 00:04:43,979
Cisco intersection this is Kernel

113
00:04:43,979 --> 00:04:47,520
provides six enter and 6X Trace point

114
00:04:47,520 --> 00:04:50,100
if we attach the tracing program to the

115
00:04:50,100 --> 00:04:52,320
address point the function call or

116
00:04:52,320 --> 00:04:54,900
traces enter and traces exit if you use

117
00:04:54,900 --> 00:04:56,759
the same parameters to trigger the

118
00:04:56,759 --> 00:04:59,220
tracing program the first parameter is

119
00:04:59,220 --> 00:05:01,320
called Rex which same The Cisco

120
00:05:01,320 --> 00:05:04,320
arguments the second parameter is ID

121
00:05:04,320 --> 00:05:06,360
which is the accessible number

122
00:05:06,360 --> 00:05:08,759
Trace Point provide low overhead but

123
00:05:08,759 --> 00:05:10,620
it's only provides static single

124
00:05:10,620 --> 00:05:13,020
interception

125
00:05:13,020 --> 00:05:15,419
you can also use the dynamic hook like

126
00:05:15,419 --> 00:05:16,860
cable

127
00:05:16,860 --> 00:05:19,560
using cable you can register the tracing

128
00:05:19,560 --> 00:05:21,900
program on almost any instructions in

129
00:05:21,900 --> 00:05:23,940
the Cisco podcast

130
00:05:23,940 --> 00:05:25,740
when the instructions get excluded the

131
00:05:25,740 --> 00:05:28,199
tracing program will trigger

132
00:05:28,199 --> 00:05:31,560
k-pro is a dynamic approach but compared

133
00:05:31,560 --> 00:05:33,120
to the choice point it's kind of slow

134
00:05:33,120 --> 00:05:35,460
and also you need to know exactly how

135
00:05:35,460 --> 00:05:37,139
the data is stored in the memory and

136
00:05:37,139 --> 00:05:38,940
register in order to get the useful

137
00:05:38,940 --> 00:05:43,160
information like assistful arguments

138
00:05:43,199 --> 00:05:45,960
future is provide a user space solution

139
00:05:45,960 --> 00:05:47,759
for Cisco tracing

140
00:05:47,759 --> 00:05:49,680
similar to the trace point is a steady

141
00:05:49,680 --> 00:05:53,039
hook for Cisco enter and exit

142
00:05:53,039 --> 00:05:54,539
using p-trace you don't need to

143
00:05:54,539 --> 00:05:57,720
implement any kernel programs and as a

144
00:05:57,720 --> 00:06:00,060
tracing program but only the user Space

145
00:06:00,060 --> 00:06:01,740
Program are needed

146
00:06:01,740 --> 00:06:03,539
compared to the previous two approach

147
00:06:03,539 --> 00:06:06,840
key trace overheads of performance is

148
00:06:06,840 --> 00:06:08,340
higher

149
00:06:08,340 --> 00:06:10,380
for optimization you can combine with

150
00:06:10,380 --> 00:06:12,360
the second and Cisco filtering for

151
00:06:12,360 --> 00:06:14,520
better performance

152
00:06:14,520 --> 00:06:17,039
you can also use the ldp load for

153
00:06:17,039 --> 00:06:19,080
physical interception but this approach

154
00:06:19,080 --> 00:06:21,600
is easy to bypass if we use assembly

155
00:06:21,600 --> 00:06:24,960
code to issue system call

156
00:06:24,960 --> 00:06:27,060
so many of you have probably heard about

157
00:06:27,060 --> 00:06:28,919
the cloud workload protection products

158
00:06:28,919 --> 00:06:31,080
this product usually provides Advanced

159
00:06:31,080 --> 00:06:34,199
threat detection based ones for tracing

160
00:06:34,199 --> 00:06:35,280
there are different kinds of cloud

161
00:06:35,280 --> 00:06:36,900
workloads like virtual machine

162
00:06:36,900 --> 00:06:39,780
containers on customer merge VMS service

163
00:06:39,780 --> 00:06:42,419
containers and others so for service

164
00:06:42,419 --> 00:06:45,180
containers it's usually allocated and

165
00:06:45,180 --> 00:06:47,100
maintained by the cloud provider on

166
00:06:47,100 --> 00:06:49,680
demand so it usually have no access to

167
00:06:49,680 --> 00:06:51,979
the host

168
00:06:52,400 --> 00:06:55,680
this table summarized how Cisco trading

169
00:06:55,680 --> 00:06:57,780
techniques can be applied to different

170
00:06:57,780 --> 00:06:59,759
workloads in the cloud

171
00:06:59,759 --> 00:07:01,740
for virtual machine we have full access

172
00:07:01,740 --> 00:07:04,199
3D host so we can use any kinds of the

173
00:07:04,199 --> 00:07:06,300
Hawks trading programs

174
00:07:06,300 --> 00:07:08,580
and for the tools you can use Sparkle

175
00:07:08,580 --> 00:07:11,340
ebpf kernel module and fuckopedic we'll

176
00:07:11,340 --> 00:07:13,740
talk about this tour later

177
00:07:13,740 --> 00:07:16,800
for containers on customer major VM so

178
00:07:16,800 --> 00:07:19,020
you can have the same options as the

179
00:07:19,020 --> 00:07:21,240
virtual machine as long as they get

180
00:07:21,240 --> 00:07:22,919
enough capabilities

181
00:07:22,919 --> 00:07:25,139
for service containers as we mentioned

182
00:07:25,139 --> 00:07:27,780
you have no ss3d host

183
00:07:27,780 --> 00:07:29,819
so we can only use the key Trace as

184
00:07:29,819 --> 00:07:32,280
talking point and implement the tracing

185
00:07:32,280 --> 00:07:34,560
program in user space

186
00:07:34,560 --> 00:07:37,259
instead of using file called ebpf and

187
00:07:37,259 --> 00:07:39,000
kernel module we can only use the

188
00:07:39,000 --> 00:07:41,720
fuckopedic

189
00:07:42,599 --> 00:07:44,819
Falco used the similar techniques to

190
00:07:44,819 --> 00:07:46,259
trade system core

191
00:07:46,259 --> 00:07:49,380
it's open source project in cncf

192
00:07:49,380 --> 00:07:52,139
and it's widely used

193
00:07:52,139 --> 00:07:54,599
so internal space is support kernel

194
00:07:54,599 --> 00:07:58,919
module and evapf pro using tracepoint

195
00:07:58,919 --> 00:08:01,800
in user space speed is developed based

196
00:08:01,800 --> 00:08:03,000
on key Trace

197
00:08:03,000 --> 00:08:05,940
faculty kidding is dedicated for system

198
00:08:05,940 --> 00:08:10,080
tracing of service workloads

199
00:08:10,080 --> 00:08:12,000
so we did not evaluate other security

200
00:08:12,000 --> 00:08:14,819
monitor agents but we believe the

201
00:08:14,819 --> 00:08:16,979
popularity of Fargo represent an

202
00:08:16,979 --> 00:08:18,720
implementation that is widely accepted

203
00:08:18,720 --> 00:08:20,280
by the community

204
00:08:20,280 --> 00:08:22,580
unfortunately this kind of imitation

205
00:08:22,580 --> 00:08:26,039
suffer for the total issue there is time

206
00:08:26,039 --> 00:08:27,960
to check time use

207
00:08:27,960 --> 00:08:29,580
let's take the connect system core for

208
00:08:29,580 --> 00:08:30,360
example

209
00:08:30,360 --> 00:08:32,940
the second argument of Kinesis Encore is

210
00:08:32,940 --> 00:08:36,000
a user pointer called user V address

211
00:08:36,000 --> 00:08:38,520
which pointing to the stock address in

212
00:08:38,520 --> 00:08:40,260
user space

213
00:08:40,260 --> 00:08:42,059
during time will check the tracing

214
00:08:42,059 --> 00:08:44,039
program did reference this user space

215
00:08:44,039 --> 00:08:46,380
pointer to get the socket address

216
00:08:46,380 --> 00:08:49,080
and during time we use the kernel did

217
00:08:49,080 --> 00:08:51,000
reference the same used as space pointer

218
00:08:51,000 --> 00:08:54,060
to get the socket address again

219
00:08:54,060 --> 00:08:56,339
however between time or check and time

220
00:08:56,339 --> 00:08:59,339
will use the memory from user space

221
00:08:59,339 --> 00:09:02,399
pointed by the user V address pointer is

222
00:09:02,399 --> 00:09:04,560
vulnerable to be changed by this user

223
00:09:04,560 --> 00:09:06,959
space attacker so in this case the stock

224
00:09:06,959 --> 00:09:08,820
address can be different between timer

225
00:09:08,820 --> 00:09:13,080
check and time use causing a total issue

226
00:09:13,080 --> 00:09:15,420
so let's dive into the connection call

227
00:09:15,420 --> 00:09:16,920
which can help you understand the

228
00:09:16,920 --> 00:09:20,339
important issue for Cisco tracing

229
00:09:20,339 --> 00:09:22,740
when the application issue the connected

230
00:09:22,740 --> 00:09:26,220
flow in the kernel so the Cisco Handler

231
00:09:26,220 --> 00:09:28,140
will check if any tracing program

232
00:09:28,140 --> 00:09:30,180
attached to the static hook a system

233
00:09:30,180 --> 00:09:32,940
called enter like key Trace second Sixth

234
00:09:32,940 --> 00:09:34,620
and the trace point

235
00:09:34,620 --> 00:09:36,600
if this is true the trading program will

236
00:09:36,600 --> 00:09:38,760
be triggered

237
00:09:38,760 --> 00:09:42,180
after that the Cisco Handler will look

238
00:09:42,180 --> 00:09:44,339
up the accessible table and jump to the

239
00:09:44,339 --> 00:09:45,839
connection core to create a connection

240
00:09:45,839 --> 00:09:48,480
on a socket

241
00:09:48,480 --> 00:09:50,760
before returning to our user space the

242
00:09:50,760 --> 00:09:53,220
Handler will again check if any trading

243
00:09:53,220 --> 00:09:55,740
program attached to the study Fork

244
00:09:55,740 --> 00:09:58,920
assets or exit like e-trace 6X Tracy

245
00:09:58,920 --> 00:10:00,360
point and so on

246
00:10:00,360 --> 00:10:03,300
similarly if this is true the tracing

247
00:10:03,300 --> 00:10:06,019
program will be called

248
00:10:06,120 --> 00:10:08,820
so as I mentioned earlier the second

249
00:10:08,820 --> 00:10:11,279
argument of Kinesis and core is a user

250
00:10:11,279 --> 00:10:13,920
pointer pointing to the stock address in

251
00:10:13,920 --> 00:10:16,380
user space this pointer is passed

252
00:10:16,380 --> 00:10:17,880
through the connect session call and

253
00:10:17,880 --> 00:10:19,800
assigned to different kernel variables

254
00:10:19,800 --> 00:10:23,000
which is highlight in red

255
00:10:23,100 --> 00:10:25,500
the kernel called move address to Kernel

256
00:10:25,500 --> 00:10:27,839
to make a copy of stock address from the

257
00:10:27,839 --> 00:10:31,519
user space to the kernel buffer

258
00:10:33,000 --> 00:10:35,880
and then the kernel will call internal

259
00:10:35,880 --> 00:10:37,920
function six connect file to create a

260
00:10:37,920 --> 00:10:39,839
connection on a socket based on the

261
00:10:39,839 --> 00:10:41,279
Kernel buffer

262
00:10:41,279 --> 00:10:43,500
and this is a time of use by Linux

263
00:10:43,500 --> 00:10:45,420
kernel for the connectors and core

264
00:10:45,420 --> 00:10:47,839
arguments

265
00:10:48,120 --> 00:10:51,000
before the memory copy function the

266
00:10:51,000 --> 00:10:55,440
kernel buffer is not created so

267
00:11:06,240 --> 00:11:09,480
and call enter or to any places before

268
00:11:09,480 --> 00:11:12,720
the memory copy function using k-pro

269
00:11:12,720 --> 00:11:14,640
the tracing programs need to

270
00:11:14,640 --> 00:11:17,100
de-reference the user pointer or read

271
00:11:17,100 --> 00:11:19,980
the user space memory directory to get

272
00:11:19,980 --> 00:11:21,120
the stock address

273
00:11:21,120 --> 00:11:23,579
as we mentioned earlier the user memory

274
00:11:23,579 --> 00:11:25,500
is vulnerable to be changed by the

275
00:11:25,500 --> 00:11:28,640
attacker from the user space

276
00:11:28,800 --> 00:11:32,880
after the memory copy function so uh the

277
00:11:32,880 --> 00:11:35,100
kernel buffer is created with one copies

278
00:11:35,100 --> 00:11:36,899
of the stock address

279
00:11:36,899 --> 00:11:38,940
unfortunately the total issue may still

280
00:11:38,940 --> 00:11:39,839
exist

281
00:11:39,839 --> 00:11:42,180
think about if we attach the tracing

282
00:11:42,180 --> 00:11:44,100
program to the study hook a system

283
00:11:44,100 --> 00:11:45,300
called exit

284
00:11:45,300 --> 00:11:48,420
right 6X tracing point or P Trace

285
00:11:48,420 --> 00:11:50,459
the tracing program may still will it

286
00:11:50,459 --> 00:11:52,620
reference the user pointer to get the

287
00:11:52,620 --> 00:11:54,120
socket address

288
00:11:54,120 --> 00:11:57,060
again the user memory is vulnerable for

289
00:11:57,060 --> 00:12:00,540
the attacker from user space

290
00:12:00,540 --> 00:12:03,959
faculty use p-trace for Cisco Android

291
00:12:03,959 --> 00:12:07,939
and exit but only use the

292
00:12:18,240 --> 00:12:22,320
only used 6X Express point

293
00:12:22,320 --> 00:12:24,600
so hopefully you got some idea about the

294
00:12:24,600 --> 00:12:27,120
total issue for system of tracing in the

295
00:12:27,120 --> 00:12:28,980
source code level next I'll head over to

296
00:12:28,980 --> 00:12:32,600
Rex talk about the variabilities

297
00:12:35,760 --> 00:12:37,560
okay so

298
00:12:37,560 --> 00:12:40,440
um although the example that we use is

299
00:12:40,440 --> 00:12:43,920
uh on kernel 5.7 but this uh tactical

300
00:12:43,920 --> 00:12:45,839
issue really exists since the day

301
00:12:45,839 --> 00:12:47,880
features and Trace point was introduced

302
00:12:47,880 --> 00:12:49,680
and we actually confirmed with the

303
00:12:49,680 --> 00:12:52,380
kernel developers that this is the

304
00:12:52,380 --> 00:12:55,019
expected Behavior because these features

305
00:12:55,019 --> 00:12:56,519
are really designed for performance and

306
00:12:56,519 --> 00:12:58,800
debugging initially and in terms of

307
00:12:58,800 --> 00:13:01,860
mitigation what they recommend is

308
00:13:01,860 --> 00:13:03,120
um you know the software need to

309
00:13:03,120 --> 00:13:05,519
actually monitor the kernel memory for

310
00:13:05,519 --> 00:13:08,459
this kind of security purposes but it

311
00:13:08,459 --> 00:13:10,560
sounds very simple it will become

312
00:13:10,560 --> 00:13:13,200
quickly very complicated when you

313
00:13:13,200 --> 00:13:14,519
actually implement it and we'll talk

314
00:13:14,519 --> 00:13:15,660
about that when we talk about

315
00:13:15,660 --> 00:13:18,199
mitigations

316
00:13:20,399 --> 00:13:21,839
so

317
00:13:21,839 --> 00:13:24,660
um basically we reported this issue to

318
00:13:24,660 --> 00:13:27,720
Falco and the main thing in their

319
00:13:27,720 --> 00:13:29,160
software is that they have to talk to

320
00:13:29,160 --> 00:13:31,800
issue as this exit because they use the

321
00:13:31,800 --> 00:13:34,620
three-spoint SS exit and P dick also

322
00:13:34,620 --> 00:13:37,200
used the P trees SSX

323
00:13:37,200 --> 00:13:39,839
so this will impact Falco version older

324
00:13:39,839 --> 00:13:43,200
than 0.31.1 and if you're using the

325
00:13:43,200 --> 00:13:45,000
commercial version you probably want to

326
00:13:45,000 --> 00:13:47,000
check what version is affected

327
00:13:47,000 --> 00:13:50,279
and uh we report this issue on December

328
00:13:50,279 --> 00:13:52,860
and it's mitigated in March the

329
00:13:52,860 --> 00:13:55,860
mitigation that was deployed is they

330
00:13:55,860 --> 00:13:58,079
will compare the for Trace point they

331
00:13:58,079 --> 00:13:59,880
will compare the center and this exit

332
00:13:59,880 --> 00:14:02,399
data and if there's any change that

333
00:14:02,399 --> 00:14:04,260
potential will indicate a tampering

334
00:14:04,260 --> 00:14:05,700
attempt

335
00:14:05,700 --> 00:14:08,339
for ptake they also deploy the same

336
00:14:08,339 --> 00:14:11,940
mitigation for p3s as a center and also

337
00:14:11,940 --> 00:14:15,620
features SS exit

338
00:14:16,680 --> 00:14:19,500
now in terms of the what kind of system

339
00:14:19,500 --> 00:14:21,839
calls are actually being affected so we

340
00:14:21,839 --> 00:14:23,820
analyze the important system calls in

341
00:14:23,820 --> 00:14:26,399
the open source Falco rules pretty much

342
00:14:26,399 --> 00:14:29,160
majority of them are impacted there are

343
00:14:29,160 --> 00:14:31,800
two exceptions in this table one is the

344
00:14:31,800 --> 00:14:34,740
exactly system call the reason is that

345
00:14:34,740 --> 00:14:37,680
when Falco trees exactly they actually

346
00:14:37,680 --> 00:14:40,260
go in and read the kernel data so they

347
00:14:40,260 --> 00:14:42,360
didn't fully rely on the trace Point

348
00:14:42,360 --> 00:14:43,800
result

349
00:14:43,800 --> 00:14:45,959
uh the second one is the send to and

350
00:14:45,959 --> 00:14:49,380
send message system call so later we'll

351
00:14:49,380 --> 00:14:50,820
talk about how to use the blocking

352
00:14:50,820 --> 00:14:53,220
condition to exploit uh the talk to

353
00:14:53,220 --> 00:14:55,380
issue but in the send to and send

354
00:14:55,380 --> 00:14:58,500
message we didn't find a reliable way to

355
00:14:58,500 --> 00:15:00,779
influence the blocking condition

356
00:15:00,779 --> 00:15:03,180
but also keep in mind that this two

357
00:15:03,180 --> 00:15:05,639
system costs are typically heavy to

358
00:15:05,639 --> 00:15:11,120
Monitor and this limits their adoption

359
00:15:12,240 --> 00:15:14,519
okay so I think the vulnerability

360
00:15:14,519 --> 00:15:16,260
hopefully everybody got a sense of what

361
00:15:16,260 --> 00:15:17,639
the vulnerability is now let's talk

362
00:15:17,639 --> 00:15:19,139
about how to actually exploit the

363
00:15:19,139 --> 00:15:21,000
vulnerability

364
00:15:21,000 --> 00:15:23,760
so we don't want to acquire any

365
00:15:23,760 --> 00:15:26,339
additional privilege and also we don't

366
00:15:26,339 --> 00:15:27,540
want to acquire any additional

367
00:15:27,540 --> 00:15:30,180
capabilities in the bypass

368
00:15:30,180 --> 00:15:34,399
we need to have some level of control

369
00:15:44,899 --> 00:15:47,880
we want the exploit to be 100 reliable

370
00:15:47,880 --> 00:15:51,120
because in this game if the attacker is

371
00:15:51,120 --> 00:15:52,620
being detected once then the whole

372
00:15:52,620 --> 00:15:56,360
operation are potentially at risk

373
00:15:57,620 --> 00:16:00,420
okay so this leads us to two

374
00:16:00,420 --> 00:16:03,120
exploitation strategies uh we will first

375
00:16:03,120 --> 00:16:04,920
talk about exported strategy number one

376
00:16:04,920 --> 00:16:06,660
which is the research that we did in

377
00:16:06,660 --> 00:16:08,760
last year's Defcon

378
00:16:08,760 --> 00:16:12,620
um from there you can sort of see

379
00:16:26,639 --> 00:16:29,699
uh cross-core uh interrupt

380
00:16:29,699 --> 00:16:33,600
but in order to properly manage the

381
00:16:33,600 --> 00:16:35,459
bypass using this delay everything has

382
00:16:35,459 --> 00:16:37,440
to be precisely synchronized we have to

383
00:16:37,440 --> 00:16:39,660
inject it at the precise timing and then

384
00:16:39,660 --> 00:16:41,220
we have to synchronize all the data

385
00:16:41,220 --> 00:16:44,040
operations so this we we need to use a

386
00:16:44,040 --> 00:16:46,440
system called user4sd

387
00:16:46,440 --> 00:16:50,579
and there are some limitations of using

388
00:16:50,579 --> 00:16:53,279
this citizen call number one is

389
00:16:53,279 --> 00:16:56,100
if you are using Docker containers and

390
00:16:56,100 --> 00:16:59,399
you enable the default icon profile then

391
00:16:59,399 --> 00:17:00,959
the second profile will actually block

392
00:17:00,959 --> 00:17:03,720
the system call so this wouldn't work in

393
00:17:03,720 --> 00:17:05,220
the container

394
00:17:05,220 --> 00:17:08,640
uh the other limitation is that

395
00:17:08,640 --> 00:17:12,059
most of the cloud workloads are not uh

396
00:17:12,059 --> 00:17:15,119
does not use user 5D so the usage of

397
00:17:15,119 --> 00:17:16,740
this system call indicates something

398
00:17:16,740 --> 00:17:18,119
abnormal

399
00:17:18,119 --> 00:17:20,220
and this is actually the mitigation

400
00:17:20,220 --> 00:17:22,740
deploy by Falco last year so they detect

401
00:17:22,740 --> 00:17:26,760
the usage of user 5D system called

402
00:17:26,760 --> 00:17:29,100
okay so last year we went back and we

403
00:17:29,100 --> 00:17:30,900
think you know how do we how do we

404
00:17:30,900 --> 00:17:33,360
overcome this limitation what if what if

405
00:17:33,360 --> 00:17:37,100
we don't need user for fds on Call

406
00:17:38,700 --> 00:17:42,419
um now in order to do that it basically

407
00:17:42,419 --> 00:17:45,059
means we cannot precisely synchronize uh

408
00:17:45,059 --> 00:17:46,380
when we inject

409
00:17:46,380 --> 00:17:49,440
but what if we can inject a really

410
00:17:49,440 --> 00:17:51,179
really long delay

411
00:17:51,179 --> 00:17:52,260
then we don't need to worry about

412
00:17:52,260 --> 00:17:54,840
synchronization at all

413
00:17:54,840 --> 00:17:56,820
right the idea sounds really simple but

414
00:17:56,820 --> 00:17:59,340
the question is how how do we actually

415
00:17:59,340 --> 00:18:01,879
do this

416
00:18:03,660 --> 00:18:05,760
so we actually found out two ways to

417
00:18:05,760 --> 00:18:08,880
achieve this uh the first way to achieve

418
00:18:08,880 --> 00:18:12,419
this is using the blocking condition

419
00:18:12,419 --> 00:18:14,580
now I'll talk more about blocking

420
00:18:14,580 --> 00:18:17,039
condition the second way to do this is

421
00:18:17,039 --> 00:18:19,799
to use the second to actually delay the

422
00:18:19,799 --> 00:18:22,700
system called execution

423
00:18:23,280 --> 00:18:24,960
um so what do we mean by System called

424
00:18:24,960 --> 00:18:26,940
getting block now if you think about the

425
00:18:26,940 --> 00:18:28,559
fundamental

426
00:18:28,559 --> 00:18:30,960
kind of system call it's essentially the

427
00:18:30,960 --> 00:18:33,840
kernel interacting with some resources

428
00:18:33,840 --> 00:18:36,179
on behalf of the user Space Program

429
00:18:36,179 --> 00:18:39,960
now many of these resources are i o

430
00:18:39,960 --> 00:18:41,100
devices

431
00:18:41,100 --> 00:18:43,140
and it takes time for them to respond

432
00:18:43,140 --> 00:18:45,179
before the kernel returned the results

433
00:18:45,179 --> 00:18:48,140
to the user space

434
00:18:48,780 --> 00:18:51,120
so to be more concrete let's look at

435
00:18:51,120 --> 00:18:53,520
Connexus and call

436
00:18:53,520 --> 00:18:56,419
so in this in this diagram there are two

437
00:18:56,419 --> 00:18:58,740
machines there's a client machine

438
00:18:58,740 --> 00:19:00,720
there's a server machine

439
00:19:00,720 --> 00:19:03,900
and on the client machine it's monitored

440
00:19:03,900 --> 00:19:06,539
by the system called monitoring software

441
00:19:06,539 --> 00:19:08,940
and let's say there's an application the

442
00:19:08,940 --> 00:19:11,880
application triggers a connection call

443
00:19:11,880 --> 00:19:14,580
what happens in the normal scenario is

444
00:19:14,580 --> 00:19:16,140
that the networking stack will send us

445
00:19:16,140 --> 00:19:17,940
impacted to the server

446
00:19:17,940 --> 00:19:19,740
and then server will respond the same

447
00:19:19,740 --> 00:19:22,020
back packet and then client respond with

448
00:19:22,020 --> 00:19:23,400
the ACT packet

449
00:19:23,400 --> 00:19:25,140
and then your sys card will hit the

450
00:19:25,140 --> 00:19:27,780
return path a trace Point features will

451
00:19:27,780 --> 00:19:29,580
read the argument

452
00:19:29,580 --> 00:19:32,400
and then this is called will exit

453
00:19:32,400 --> 00:19:34,559
right so now you may be wondering this

454
00:19:34,559 --> 00:19:37,140
is just computer networking 101 what can

455
00:19:37,140 --> 00:19:39,620
go wrong here

456
00:19:40,380 --> 00:19:42,900
now imagine the following scenario

457
00:19:42,900 --> 00:19:46,280
many times when attacker compromise a

458
00:19:46,280 --> 00:19:49,080
environment they will try to connect to

459
00:19:49,080 --> 00:19:51,000
their command and control server which

460
00:19:51,000 --> 00:19:53,880
means they control the server as well

461
00:19:53,880 --> 00:19:56,220
so imagine the scenario we have a client

462
00:19:56,220 --> 00:19:58,700
and the server now on the client side

463
00:19:58,700 --> 00:20:00,960
the attacker first create a system

464
00:20:00,960 --> 00:20:02,220
called thread

465
00:20:02,220 --> 00:20:05,160
the system call thread will create an

466
00:20:05,160 --> 00:20:07,080
override thread

467
00:20:07,080 --> 00:20:08,700
and then the system customer will call

468
00:20:08,700 --> 00:20:11,100
the system called connect

469
00:20:11,100 --> 00:20:13,080
when it called the assistant call it

470
00:20:13,080 --> 00:20:16,260
will use a user space memory that

471
00:20:16,260 --> 00:20:19,320
contains the malicious IP address

472
00:20:19,320 --> 00:20:21,360
and when this happens the kernel will

473
00:20:21,360 --> 00:20:24,740
send the same packet to the server

474
00:20:24,840 --> 00:20:26,580
now what if the server dropped the

475
00:20:26,580 --> 00:20:28,879
packet

476
00:20:29,700 --> 00:20:31,860
so the client will retry

477
00:20:31,860 --> 00:20:33,480
what if the server dropped the packet

478
00:20:33,480 --> 00:20:34,500
again

479
00:20:34,500 --> 00:20:37,620
then the client will retry again

480
00:20:37,620 --> 00:20:41,400
but every time the client retry this uh

481
00:20:41,400 --> 00:20:43,260
the num the amount of delay is

482
00:20:43,260 --> 00:20:44,700
controlled by the TCP congestion

483
00:20:44,700 --> 00:20:47,280
algorithm so it's roughly you know think

484
00:20:47,280 --> 00:20:50,580
about it more or less exponential delay

485
00:20:50,580 --> 00:20:53,100
now with that amount of delay the

486
00:20:53,100 --> 00:20:54,780
override threat has enough time to

487
00:20:54,780 --> 00:20:57,480
override the user space memory with a

488
00:20:57,480 --> 00:20:59,820
benign IP address

489
00:20:59,820 --> 00:21:01,980
and then it has enough time to propagate

490
00:21:01,980 --> 00:21:06,600
all the memory copies so when the server

491
00:21:06,600 --> 00:21:08,340
sends the same packet and then client

492
00:21:08,340 --> 00:21:10,740
return the ACT packet when they hit the

493
00:21:10,740 --> 00:21:13,320
Sysco return path the trace point and

494
00:21:13,320 --> 00:21:15,660
the p3s will happily read the bin iip

495
00:21:15,660 --> 00:21:17,960
address

496
00:21:18,720 --> 00:21:21,960
so we're going to show you a demo on the

497
00:21:21,960 --> 00:21:24,380
scenario

498
00:21:28,200 --> 00:21:29,640
foreign

499
00:21:29,640 --> 00:21:32,400
okay so in this demo there are two

500
00:21:32,400 --> 00:21:34,080
machines just as what we Illustrated in

501
00:21:34,080 --> 00:21:35,280
the diagram

502
00:21:35,280 --> 00:21:37,080
so right now what you're seeing is a

503
00:21:37,080 --> 00:21:39,000
server machine now you can see the

504
00:21:39,000 --> 00:21:40,679
server machine has IP address ending

505
00:21:40,679 --> 00:21:43,860
with 176.

506
00:21:46,860 --> 00:21:48,600
okay and then on the server we start up

507
00:21:48,600 --> 00:21:50,520
this program that's going to look at the

508
00:21:50,520 --> 00:21:52,500
same packet and drop the same packet and

509
00:21:52,500 --> 00:21:54,240
then we also start a listening server on

510
00:21:54,240 --> 00:21:56,159
the server side

511
00:21:56,159 --> 00:21:58,020
on the client side we're going to run

512
00:21:58,020 --> 00:22:00,419
Falco

513
00:22:00,419 --> 00:22:02,700
and we also use Wireshark to see what's

514
00:22:02,700 --> 00:22:05,039
actually running on The Wire

515
00:22:05,039 --> 00:22:07,679
and now we run this attack program that

516
00:22:07,679 --> 00:22:12,020
is going to try to connect to the server

517
00:22:12,960 --> 00:22:15,120
so you see it's connected now it's

518
00:22:15,120 --> 00:22:17,460
trying to send some dummy chat

519
00:22:17,460 --> 00:22:20,280
okay so client got the message sorry

520
00:22:20,280 --> 00:22:23,240
server got the message

521
00:22:27,659 --> 00:22:30,320
but now if you look at the

522
00:22:30,320 --> 00:22:33,360
result reported by Falco you can see

523
00:22:33,360 --> 00:22:34,980
that it's actually saying our client is

524
00:22:34,980 --> 00:22:38,100
talking to IP address 1.1.1.1 that

525
00:22:38,100 --> 00:22:41,480
indicates a successful bypass

526
00:22:41,700 --> 00:22:43,500
but now if you look at what's actually

527
00:22:43,500 --> 00:22:45,780
happening on the wire you'll see that

528
00:22:45,780 --> 00:22:48,000
the first two SIM package got dropped

529
00:22:48,000 --> 00:22:50,159
and then it says that you know we're

530
00:22:50,159 --> 00:22:52,020
actually talking to IP address ending

531
00:22:52,020 --> 00:22:55,100
with 176.

532
00:23:02,460 --> 00:23:05,460
so the previous demo is for the ebpf and

533
00:23:05,460 --> 00:23:08,039
the kernel module version of the Falco

534
00:23:08,039 --> 00:23:09,659
which use the trace point now we're

535
00:23:09,659 --> 00:23:12,360
going to show you how we do the same

536
00:23:12,360 --> 00:23:17,000
bypass for p dick on AWS far gate

537
00:23:17,640 --> 00:23:19,500
okay so what you're seeing here is again

538
00:23:19,500 --> 00:23:21,840
the server machine uh the IP address is

539
00:23:21,840 --> 00:23:23,700
ending with 163

540
00:23:23,700 --> 00:23:25,919
we're going to run the the Sim packet

541
00:23:25,919 --> 00:23:29,179
drop program

542
00:23:37,500 --> 00:23:40,080
and we're going to fire the TCP

543
00:23:40,080 --> 00:23:41,640
listening server

544
00:23:41,640 --> 00:23:43,860
now this isn't a far game machine

545
00:23:43,860 --> 00:23:48,360
so pdig will launch our attacker program

546
00:23:48,360 --> 00:23:50,100
so it's the same program that try to

547
00:23:50,100 --> 00:23:51,840
connect to the server and you can see

548
00:23:51,840 --> 00:23:54,240
that the IP address reported by pdig is

549
00:23:54,240 --> 00:23:56,940
again 1.1.1.1 which indicates a

550
00:23:56,940 --> 00:23:59,720
successful bypass

551
00:24:18,659 --> 00:24:21,059
okay now you may be wondering okay this

552
00:24:21,059 --> 00:24:22,559
is for connect system call does it

553
00:24:22,559 --> 00:24:24,299
actually work for other system call as

554
00:24:24,299 --> 00:24:27,720
well so we actually discovered that the

555
00:24:27,720 --> 00:24:30,000
entire class of file system calls are

556
00:24:30,000 --> 00:24:32,280
also affected

557
00:24:32,280 --> 00:24:34,380
um and some other system calls that

558
00:24:34,380 --> 00:24:36,240
relies on file system will also be

559
00:24:36,240 --> 00:24:37,980
effective for example with the exact V

560
00:24:37,980 --> 00:24:40,799
and the exactly at the reason is that

561
00:24:40,799 --> 00:24:43,740
when you execute a binary first it's

562
00:24:43,740 --> 00:24:46,080
going to the disk to actually fetch the

563
00:24:46,080 --> 00:24:46,919
binary

564
00:24:46,919 --> 00:24:50,700
and therefore they're also affected

565
00:24:50,700 --> 00:24:53,159
next you know we'll talk about how we

566
00:24:53,159 --> 00:24:57,740
exploit the file system costs

567
00:24:57,799 --> 00:25:00,480
so uh before I talk about how to bypass

568
00:25:00,480 --> 00:25:02,520
open S is for Tracy let me introduce

569
00:25:02,520 --> 00:25:05,220
Fields so Fields stand for user space

570
00:25:05,220 --> 00:25:06,960
fire system framework it usually

571
00:25:06,960 --> 00:25:09,419
including a kernel module a user library

572
00:25:09,419 --> 00:25:12,000
and also a multi utility

573
00:25:12,000 --> 00:25:14,820
so in Cloud scenario the fields is often

574
00:25:14,820 --> 00:25:17,520
often used as a remote storage fields so

575
00:25:17,520 --> 00:25:19,740
using such Fields you can mount the

576
00:25:19,740 --> 00:25:22,320
remote stored objects as local file

577
00:25:22,320 --> 00:25:24,720
system and access the remote file as

578
00:25:24,720 --> 00:25:25,980
local file

579
00:25:25,980 --> 00:25:28,559
since it's the user space version so it

580
00:25:28,559 --> 00:25:30,419
provides faster involvement or

581
00:25:30,419 --> 00:25:33,059
development and it usually do not Penny

582
00:25:33,059 --> 00:25:34,740
the kernel

583
00:25:34,740 --> 00:25:37,679
so here is the list of examples for the

584
00:25:37,679 --> 00:25:39,779
remote storage Fields so you can see

585
00:25:39,779 --> 00:25:42,299
it's very popular it's widely used

586
00:25:42,299 --> 00:25:45,480
from the list you can see the um the

587
00:25:45,480 --> 00:25:46,980
major cloud provider has their own

588
00:25:46,980 --> 00:25:49,320
fields

589
00:25:49,320 --> 00:25:51,179
this is the general architecture for

590
00:25:51,179 --> 00:25:54,179
remote storage views so if the user

591
00:25:54,179 --> 00:25:56,400
space application or container wants to

592
00:25:56,400 --> 00:25:59,340
open a remote file what it does is the

593
00:25:59,340 --> 00:26:01,500
same as opening a local file

594
00:26:01,500 --> 00:26:03,299
basically it will issue the open or open

595
00:26:03,299 --> 00:26:05,700
SSM call into the kernel

596
00:26:05,700 --> 00:26:08,820
when the requests reached the VFS layer

597
00:26:08,820 --> 00:26:11,159
a little bit round to the fields kernel

598
00:26:11,159 --> 00:26:13,500
driver and then Judy uses the base fire

599
00:26:13,500 --> 00:26:16,320
system like GCS fuse

600
00:26:16,320 --> 00:26:18,659
the demon will send the request to the

601
00:26:18,659 --> 00:26:20,100
remote storage

602
00:26:20,100 --> 00:26:22,200
once the response is back from the

603
00:26:22,200 --> 00:26:25,440
server the it will be allowed that to

604
00:26:25,440 --> 00:26:27,299
the user space application through the

605
00:26:27,299 --> 00:26:29,100
original path

606
00:26:29,100 --> 00:26:31,620
one thing I need to mention is the delay

607
00:26:31,620 --> 00:26:34,919
between the client and server is much

608
00:26:34,919 --> 00:26:37,500
longer than the Cisco delay itself

609
00:26:37,500 --> 00:26:39,360
basically you can leverage this long

610
00:26:39,360 --> 00:26:43,260
delay to bypass the Open Access and call

611
00:26:43,260 --> 00:26:47,460
so let me show how it works so we have a

612
00:26:47,460 --> 00:26:49,380
malicious cry that is monitored by the

613
00:26:49,380 --> 00:26:50,820
tracing program

614
00:26:50,820 --> 00:26:53,340
The Cisco threat is trying to open the

615
00:26:53,340 --> 00:26:56,039
remote file called malicious file

616
00:26:56,039 --> 00:26:57,779
basically it will issue an open

617
00:26:57,779 --> 00:27:00,240
Assistant call into the kernel with the

618
00:27:00,240 --> 00:27:02,159
past name when you do the malicious file

619
00:27:02,159 --> 00:27:04,799
name in user space

620
00:27:04,799 --> 00:27:08,100
since the file is stored remotely so the

621
00:27:08,100 --> 00:27:10,260
open request will be round from the

622
00:27:10,260 --> 00:27:12,480
kernel to the user space and then to the

623
00:27:12,480 --> 00:27:14,400
remote storage

624
00:27:14,400 --> 00:27:18,120
before the response response is back the

625
00:27:18,120 --> 00:27:20,400
override thread can jump in and trying

626
00:27:20,400 --> 00:27:23,460
to override the user memory pointed by

627
00:27:23,460 --> 00:27:26,100
the past named from Malaysia's fine name

628
00:27:26,100 --> 00:27:27,900
to ub95 name

629
00:27:27,900 --> 00:27:30,179
and again because the delay is so long

630
00:27:30,179 --> 00:27:32,640
the CPU have enough time to propagate a

631
00:27:32,640 --> 00:27:35,600
change to all the copies of CP uh

632
00:27:35,600 --> 00:27:38,940
register and memories

633
00:27:38,940 --> 00:27:41,039
after the responsibility is back and

634
00:27:41,039 --> 00:27:44,100
before it returned to the use space the

635
00:27:44,100 --> 00:27:46,260
tracing program can leverage the sixth

636
00:27:46,260 --> 00:27:48,240
exit Trace point to read The Cisco

637
00:27:48,240 --> 00:27:49,620
arguments

638
00:27:49,620 --> 00:27:52,320
for example last name unfortunately the

639
00:27:52,320 --> 00:27:54,120
person has changed from the malicious

640
00:27:54,120 --> 00:27:56,220
file to the b95

641
00:27:56,220 --> 00:28:00,179
which means our bypass will be succeed

642
00:28:00,179 --> 00:28:04,279
right now let me show you a demo

643
00:28:11,279 --> 00:28:13,740
so we have the console on the left side

644
00:28:13,740 --> 00:28:16,559
for Google Cloud Storage bucket

645
00:28:16,559 --> 00:28:21,260
and we deployed the Fargo in gke cluster

646
00:28:22,260 --> 00:28:25,700
and we log into one of the part

647
00:28:27,299 --> 00:28:29,340
then we checked the process inside the

648
00:28:29,340 --> 00:28:31,380
container so we have the Fargo agent

649
00:28:31,380 --> 00:28:32,340
running

650
00:28:32,340 --> 00:28:34,740
and also we have GCS fields around the

651
00:28:34,740 --> 00:28:36,659
end which amount of Google Cloud Storage

652
00:28:36,659 --> 00:28:40,440
bucket as a local folder MNT

653
00:28:40,440 --> 00:28:43,679
and then we check the log for Falco so

654
00:28:43,679 --> 00:28:46,140
we have one event generated because we

655
00:28:46,140 --> 00:28:49,100
just log into the port

656
00:28:51,000 --> 00:28:53,700
so right now the nnd folder is empty

657
00:28:53,700 --> 00:28:57,919
which means the remote storage is empty

658
00:29:00,600 --> 00:29:03,480
and then we're trying to open the file

659
00:29:03,480 --> 00:29:05,220
called malicious file in the entity

660
00:29:05,220 --> 00:29:07,700
folder

661
00:29:16,500 --> 00:29:18,419
and then you check the end the local

662
00:29:18,419 --> 00:29:20,779
folder so the manuscript file is created

663
00:29:20,779 --> 00:29:24,380
in remote storage

664
00:29:26,039 --> 00:29:28,740
and then we try to lock from Falco so we

665
00:29:28,740 --> 00:29:31,740
have a event generated because if you're

666
00:29:31,740 --> 00:29:34,440
trying to open a malicious file on the

667
00:29:34,440 --> 00:29:37,279
entity folder

668
00:29:40,440 --> 00:29:43,440
and let me remove this malicious fire

669
00:29:43,440 --> 00:29:45,480
so it will remove it from the remote

670
00:29:45,480 --> 00:29:47,899
storage

671
00:29:49,140 --> 00:29:52,279
and then we run attack

672
00:29:56,220 --> 00:29:58,140
we check the folder so the malicious

673
00:29:58,140 --> 00:30:01,260
file is created by the attack code

674
00:30:01,260 --> 00:30:04,380
for the remote storage bucket

675
00:30:04,380 --> 00:30:07,200
and we check the effect of lock

676
00:30:07,200 --> 00:30:08,760
so there are no new event generated

677
00:30:08,760 --> 00:30:11,580
which means our attacks the seat

678
00:30:11,580 --> 00:30:13,440
next I will hand over to Rex to talk

679
00:30:13,440 --> 00:30:15,840
about the uh if more Express and also

680
00:30:15,840 --> 00:30:17,820
conclude

681
00:30:17,820 --> 00:30:20,418
you've got three

682
00:30:24,840 --> 00:30:27,360
okay so now we're going to talk about

683
00:30:27,360 --> 00:30:31,080
how to bypass the center tracing

684
00:30:31,080 --> 00:30:33,059
um so if you remember earlier in the

685
00:30:33,059 --> 00:30:35,940
diagram when the system call executes it

686
00:30:35,940 --> 00:30:39,000
hits P trees and then hit second

687
00:30:39,000 --> 00:30:40,799
you know and a bunch of other stuff is

688
00:30:40,799 --> 00:30:43,140
eventually it's going to the system call

689
00:30:43,140 --> 00:30:44,820
actually going to dereference the user

690
00:30:44,820 --> 00:30:47,640
space memory so now the question is can

691
00:30:47,640 --> 00:30:50,640
we use second to actually delay the uh

692
00:30:50,640 --> 00:30:52,559
the execution and therefore bypass the

693
00:30:52,559 --> 00:30:55,520
features as a center

694
00:30:55,679 --> 00:30:58,740
uh before I dive into the detail just a

695
00:30:58,740 --> 00:31:01,740
really quick recap on what that comp is

696
00:31:01,740 --> 00:31:04,200
so it is a kernel level mechanism that

697
00:31:04,200 --> 00:31:07,320
allows developer to specify

698
00:31:07,320 --> 00:31:09,840
um you know allow or block system calls

699
00:31:09,840 --> 00:31:11,580
and you can even allow and block based

700
00:31:11,580 --> 00:31:13,860
on system called arguments

701
00:31:13,860 --> 00:31:16,500
you can build a Sandbox on top of this

702
00:31:16,500 --> 00:31:19,860
mechanism and these rules can quickly

703
00:31:19,860 --> 00:31:22,380
become really complicated and it will

704
00:31:22,380 --> 00:31:25,020
take more time to compute

705
00:31:25,020 --> 00:31:27,419
one last caveat I want to highlight is

706
00:31:27,419 --> 00:31:29,580
the

707
00:31:29,580 --> 00:31:32,279
um first inserted ruins.com are actually

708
00:31:32,279 --> 00:31:35,340
evaluated the last

709
00:31:35,340 --> 00:31:36,899
assume you wouldn't understand why this

710
00:31:36,899 --> 00:31:39,260
matters

711
00:31:40,080 --> 00:31:42,720
okay so the bypass idea is very very

712
00:31:42,720 --> 00:31:44,159
simple

713
00:31:44,159 --> 00:31:46,200
um if you understand the previous attack

714
00:31:46,200 --> 00:31:49,320
so you know in this diagram we have

715
00:31:49,320 --> 00:31:50,399
everything is running on the same

716
00:31:50,399 --> 00:31:52,620
machine there's a system call thread

717
00:31:52,620 --> 00:31:54,960
that is going to first insert a bunch of

718
00:31:54,960 --> 00:31:56,340
second rules

719
00:31:56,340 --> 00:31:59,399
just like a regular application

720
00:31:59,399 --> 00:32:00,960
and then it's going to create the

721
00:32:00,960 --> 00:32:02,460
override thread

722
00:32:02,460 --> 00:32:03,960
then it's going to call the system

723
00:32:03,960 --> 00:32:07,380
called create

724
00:32:07,679 --> 00:32:10,620
then as you call the system call is

725
00:32:10,620 --> 00:32:12,659
passing in an argument that points to

726
00:32:12,659 --> 00:32:15,299
user space memory that points to that

727
00:32:15,299 --> 00:32:17,640
that contains a b95

728
00:32:17,640 --> 00:32:19,980
now Petri is happily read the benign

729
00:32:19,980 --> 00:32:23,520
file argument and then the second check

730
00:32:23,520 --> 00:32:26,700
kick in right you know at the same time

731
00:32:26,700 --> 00:32:28,740
the authorized thread will override the

732
00:32:28,740 --> 00:32:30,240
assistant car argument with the

733
00:32:30,240 --> 00:32:31,919
malicious file

734
00:32:31,919 --> 00:32:34,860
so finally after the second finish all

735
00:32:34,860 --> 00:32:37,020
the computation then the kernel is

736
00:32:37,020 --> 00:32:38,460
actually going to reference the argument

737
00:32:38,460 --> 00:32:40,140
and then it's going to create the

738
00:32:40,140 --> 00:32:43,039
malicious file for us

739
00:32:44,580 --> 00:32:47,700
so one one interesting caveat I want to

740
00:32:47,700 --> 00:32:50,179
mention is

741
00:32:50,220 --> 00:32:51,059
um

742
00:32:51,059 --> 00:32:52,980
what we talk about is pictures in

743
00:32:52,980 --> 00:32:54,480
playing mode

744
00:32:54,480 --> 00:32:57,600
now you can also use P trees plus second

745
00:32:57,600 --> 00:32:58,799
redirect

746
00:32:58,799 --> 00:33:01,440
what that means is you can use P trees

747
00:33:01,440 --> 00:33:04,440
to set up a rule in the monitor program

748
00:33:04,440 --> 00:33:06,960
uh whenever you hit the second group the

749
00:33:06,960 --> 00:33:08,940
rule will say redirect execution back to

750
00:33:08,940 --> 00:33:10,740
the Tracer

751
00:33:10,740 --> 00:33:13,500
now in this case if the Tracer start the

752
00:33:13,500 --> 00:33:17,220
application that means the Tracer let's

753
00:33:17,220 --> 00:33:18,720
say the application runs the first

754
00:33:18,720 --> 00:33:20,220
person call the Tracer will say let me

755
00:33:20,220 --> 00:33:22,140
insert the second rule and this will be

756
00:33:22,140 --> 00:33:25,019
the first rule being inserted so if this

757
00:33:25,019 --> 00:33:27,000
is the case then later no matter how

758
00:33:27,000 --> 00:33:28,380
many second rules the application

759
00:33:28,380 --> 00:33:30,600
inserts it's not going to impact the

760
00:33:30,600 --> 00:33:31,919
talk to window

761
00:33:31,919 --> 00:33:33,960
and therefore this will not be

762
00:33:33,960 --> 00:33:35,100
vulnerable

763
00:33:35,100 --> 00:33:37,679
but it will not be the case if the trees

764
00:33:37,679 --> 00:33:39,179
are attached to a running application

765
00:33:39,179 --> 00:33:41,279
because there's no control whether the

766
00:33:41,279 --> 00:33:42,600
application has already insert a

767
00:33:42,600 --> 00:33:45,260
computer or not

768
00:33:46,740 --> 00:33:48,299
okay so

769
00:33:48,299 --> 00:33:48,899
um

770
00:33:48,899 --> 00:33:51,480
we have cover different type of attack

771
00:33:51,480 --> 00:33:53,640
at different uh part of the system call

772
00:33:53,640 --> 00:33:55,919
we just want to quickly summarize

773
00:33:55,919 --> 00:33:58,640
so we talk about features as a center

774
00:33:58,640 --> 00:34:02,159
in order to mitigate this issue

775
00:34:02,159 --> 00:34:04,080
one we need to use pcom plus.com

776
00:34:04,080 --> 00:34:05,760
redirect

777
00:34:05,760 --> 00:34:08,339
and make sure it's actually starting the

778
00:34:08,339 --> 00:34:09,599
application

779
00:34:09,599 --> 00:34:11,460
if the actually if the application

780
00:34:11,460 --> 00:34:13,080
already started then you may want to

781
00:34:13,080 --> 00:34:15,960
inspect the second filter to see if

782
00:34:15,960 --> 00:34:17,699
there's anything abnormal in the second

783
00:34:17,699 --> 00:34:19,859
filters

784
00:34:19,859 --> 00:34:22,139
for trees Point as the center

785
00:34:22,139 --> 00:34:25,080
although the tactile issue exists but we

786
00:34:25,080 --> 00:34:27,119
didn't find any reliable way to export

787
00:34:27,119 --> 00:34:29,460
it so you may be able to explode it but

788
00:34:29,460 --> 00:34:31,980
it's a probabilistic

789
00:34:31,980 --> 00:34:34,980
now for Trace Point access exit it's

790
00:34:34,980 --> 00:34:36,179
vulnerable to the blocking condition

791
00:34:36,179 --> 00:34:38,639
attack that we talk about here and also

792
00:34:38,639 --> 00:34:42,480
what we did in Defcon 29.

793
00:34:42,480 --> 00:34:47,219
so in order to mitigate this one-way you

794
00:34:47,219 --> 00:34:49,560
know to do this is to compare the system

795
00:34:49,560 --> 00:34:52,020
called enter and also system called exit

796
00:34:52,020 --> 00:34:54,418
arguments and to make sure nothing got

797
00:34:54,418 --> 00:34:56,760
changed

798
00:34:56,760 --> 00:35:00,420
for p trees uh SSX it's vulnerable to

799
00:35:00,420 --> 00:35:02,640
the same attack

800
00:35:02,640 --> 00:35:05,700
in order to mitigate this uh Trace

801
00:35:05,700 --> 00:35:08,520
location one we need to deploy all the

802
00:35:08,520 --> 00:35:11,640
mitigations for petri's asset Center and

803
00:35:11,640 --> 00:35:14,099
then compare the center analysis exit

804
00:35:14,099 --> 00:35:16,440
arguments to make sure nothing

805
00:35:16,440 --> 00:35:19,400
um you know is changed

806
00:35:19,500 --> 00:35:21,359
um the last one we didn't talk a lot

807
00:35:21,359 --> 00:35:24,420
about in this uh talk it's the k-probe

808
00:35:24,420 --> 00:35:26,940
who came to Kernel internal functions

809
00:35:26,940 --> 00:35:29,099
whether this can be exploited really

810
00:35:29,099 --> 00:35:30,720
depends on

811
00:35:30,720 --> 00:35:32,940
which function is being hooked

812
00:35:32,940 --> 00:35:34,980
so

813
00:35:34,980 --> 00:35:38,700
in general what we in for system call

814
00:35:38,700 --> 00:35:42,180
monitoring uh what we see is

815
00:35:42,180 --> 00:35:45,540
depends on the number of Kernel versions

816
00:35:45,540 --> 00:35:48,119
that you want to support you can choose

817
00:35:48,119 --> 00:35:51,240
RSM Linux security module interfaces so

818
00:35:51,240 --> 00:35:53,339
that will cover certain amount of system

819
00:35:53,339 --> 00:35:57,000
costs but the support across different

820
00:35:57,000 --> 00:35:59,099
kernel versions is different

821
00:35:59,099 --> 00:36:01,079
on some neural kernel you can use even

822
00:36:01,079 --> 00:36:03,480
use a BPF or RSM

823
00:36:03,480 --> 00:36:06,420
but if you have to support a wide range

824
00:36:06,420 --> 00:36:09,180
of Kernel and RSM

825
00:36:09,180 --> 00:36:11,880
in some version doesn't have the system

826
00:36:11,880 --> 00:36:13,859
called interfaces that you wanted then

827
00:36:13,859 --> 00:36:15,000
you may need to look into other

828
00:36:15,000 --> 00:36:16,260
interfaces

829
00:36:16,260 --> 00:36:19,079
and then you quickly get into tracking

830
00:36:19,079 --> 00:36:20,520
different kernel versions and make sure

831
00:36:20,520 --> 00:36:25,339
all these interfaces exist in the kernel

832
00:36:26,400 --> 00:36:27,960
okay so

833
00:36:27,960 --> 00:36:30,960
um to conclude

834
00:36:30,960 --> 00:36:33,480
um so first let's zoom into this

835
00:36:33,480 --> 00:36:36,660
research which is we demonstrated that

836
00:36:36,660 --> 00:36:38,400
Linux kernel tracing can be bypassed

837
00:36:38,400 --> 00:36:40,619
reliably in many different ways at

838
00:36:40,619 --> 00:36:43,079
different asset Center and sus access

839
00:36:43,079 --> 00:36:46,980
so if you happen to deploy a similar

840
00:36:46,980 --> 00:36:49,859
tool you may want to check if your tool

841
00:36:49,859 --> 00:36:52,500
is actually secure against this type of

842
00:36:52,500 --> 00:36:54,240
attack because we only evaluated the

843
00:36:54,240 --> 00:36:56,400
open source solution

844
00:36:56,400 --> 00:36:59,700
the second thing is the mitigations are

845
00:36:59,700 --> 00:37:01,560
very complicated depends on how many

846
00:37:01,560 --> 00:37:03,060
kernel versions are being supported by

847
00:37:03,060 --> 00:37:05,400
the tool so you will also want to check

848
00:37:05,400 --> 00:37:08,460
the mitigation claims by the tool to

849
00:37:08,460 --> 00:37:09,900
make sure they're actually mitigated in

850
00:37:09,900 --> 00:37:13,560
the way that you intended to be

851
00:37:13,560 --> 00:37:16,859
now if I you know if we zoom out from

852
00:37:16,859 --> 00:37:18,599
this particular issue if we think about

853
00:37:18,599 --> 00:37:20,700
the bigger picture

854
00:37:20,700 --> 00:37:22,740
now today we propose some fundamental

855
00:37:22,740 --> 00:37:24,540
bypass right that doesn't mean in the

856
00:37:24,540 --> 00:37:26,760
future there wouldn't be newer bypass

857
00:37:26,760 --> 00:37:30,000
against this type of tracing technology

858
00:37:30,000 --> 00:37:33,000
so I think for the security teams

859
00:37:33,000 --> 00:37:35,280
um we recommend that you have a

860
00:37:35,280 --> 00:37:37,260
comprehensive visibility into the

861
00:37:37,260 --> 00:37:39,359
environment because if I need to bypass

862
00:37:39,359 --> 00:37:40,920
all the different data sources that

863
00:37:40,920 --> 00:37:43,260
exponentially increase my bypass

864
00:37:43,260 --> 00:37:45,540
difficulty

865
00:37:45,540 --> 00:37:48,000
the last but not least this is something

866
00:37:48,000 --> 00:37:53,040
that we do a lot at least work which is

867
00:37:53,040 --> 00:37:54,720
um we

868
00:37:54,720 --> 00:37:56,460
think about what is normal in the

869
00:37:56,460 --> 00:37:58,079
environment we Baseline the environment

870
00:37:58,079 --> 00:38:00,180
because if you know what is intended to

871
00:38:00,180 --> 00:38:02,760
be in your environment then even if the

872
00:38:02,760 --> 00:38:05,640
attacker is able to change these values

873
00:38:05,640 --> 00:38:07,980
they have to select the right value to

874
00:38:07,980 --> 00:38:10,560
choose otherwise they will trigger a

875
00:38:10,560 --> 00:38:13,460
certain type of detection

876
00:38:13,740 --> 00:38:18,740
now with that we are ready for Q a

877
00:38:18,920 --> 00:38:22,039
[Music]

878
00:38:24,500 --> 00:38:25,880
thank you

879
00:38:25,880 --> 00:38:28,979
[Music]

