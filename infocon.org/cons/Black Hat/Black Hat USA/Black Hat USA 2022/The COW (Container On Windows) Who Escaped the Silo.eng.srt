1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,820 --> 00:00:10,500
welcome to my talk the container on

3
00:00:10,500 --> 00:00:13,200
Windows we escaped The Silo in this talk

4
00:00:13,200 --> 00:00:15,719
I'm going to demonstrate our malicious

5
00:00:15,719 --> 00:00:18,600
Windows container can impact the host it

6
00:00:18,600 --> 00:00:20,400
is running on

7
00:00:20,400 --> 00:00:23,220
my name is Iran Segal I've been in the

8
00:00:23,220 --> 00:00:25,320
cyber security field for over seven

9
00:00:25,320 --> 00:00:28,619
years currently I'm a research team lead

10
00:00:28,619 --> 00:00:31,140
in safe breach Labs my experience

11
00:00:31,140 --> 00:00:33,600
involved vulnerability research on

12
00:00:33,600 --> 00:00:36,660
Windows and weather devices

13
00:00:36,660 --> 00:00:39,360
so I'm going to start with a background

14
00:00:39,360 --> 00:00:41,940
of Windows process isolated containers

15
00:00:41,940 --> 00:00:45,059
then I'll continue to how to gain

16
00:00:45,059 --> 00:00:47,820
anti-system inside of the container

17
00:00:47,820 --> 00:00:50,579
after again the empty system I'll show

18
00:00:50,579 --> 00:00:52,920
the method I use in order to find two

19
00:00:52,920 --> 00:00:55,219
vulnerabilities that can impact the host

20
00:00:55,219 --> 00:00:58,260
after that I'll show a demo containing

21
00:00:58,260 --> 00:01:00,480
chain of vulnerabilities and we will

22
00:01:00,480 --> 00:01:03,300
finish with the Q a

23
00:01:03,300 --> 00:01:06,960
so the goal of the research is to find

24
00:01:06,960 --> 00:01:09,180
what is the impact of an attacker

25
00:01:09,180 --> 00:01:12,060
crafted Windows container on the host it

26
00:01:12,060 --> 00:01:13,260
is running on

27
00:01:13,260 --> 00:01:15,780
I chose this research because containers

28
00:01:15,780 --> 00:01:17,280
are everywhere

29
00:01:17,280 --> 00:01:20,640
this attack Vector is a real old one and

30
00:01:20,640 --> 00:01:22,619
reverse engineering Windows kernel is

31
00:01:22,619 --> 00:01:24,119
fun

32
00:01:24,119 --> 00:01:26,880
so let's deep dive into Windows

33
00:01:26,880 --> 00:01:28,860
containers

34
00:01:28,860 --> 00:01:31,020
containers are similar to Virtual

35
00:01:31,020 --> 00:01:34,020
machines each container is Created from

36
00:01:34,020 --> 00:01:36,659
a container image which contains all the

37
00:01:36,659 --> 00:01:39,720
dependencies for the container for

38
00:01:39,720 --> 00:01:41,700
example the application that will it

39
00:01:41,700 --> 00:01:45,960
will run the file system or registry and

40
00:01:45,960 --> 00:01:48,900
the configurations of the OS

41
00:01:48,900 --> 00:01:51,840
container image contains all the

42
00:01:51,840 --> 00:01:54,060
dependencies therefore it's easy to

43
00:01:54,060 --> 00:01:57,180
manage and deploy like VMS

44
00:01:57,180 --> 00:01:58,439
but

45
00:01:58,439 --> 00:02:01,439
in Windows it is possible to deploy the

46
00:02:01,439 --> 00:02:04,619
containers via two methods which defines

47
00:02:04,619 --> 00:02:06,659
the degree of the isolation

48
00:02:06,659 --> 00:02:09,660
process isolated containers and hyperly

49
00:02:09,660 --> 00:02:12,120
isolated containers

50
00:02:12,120 --> 00:02:15,120
hypermic isolated containers are very

51
00:02:15,120 --> 00:02:17,640
similar to Virtual machines they have

52
00:02:17,640 --> 00:02:20,040
their own kernel and they communicate

53
00:02:20,040 --> 00:02:22,099
over the hyper-v

54
00:02:22,099 --> 00:02:24,660
of windows

55
00:02:24,660 --> 00:02:27,540
is the container can't interact directly

56
00:02:27,540 --> 00:02:30,180
with the container with the host

57
00:02:30,180 --> 00:02:34,160
it has to go over the hyper-v interface

58
00:02:34,160 --> 00:02:37,620
therefore the most secure but it comes

59
00:02:37,620 --> 00:02:40,800
with computation and overhead

60
00:02:40,800 --> 00:02:43,379
process isolated containers are similar

61
00:02:43,379 --> 00:02:46,019
to The Linux containers the entire

62
00:02:46,019 --> 00:02:48,660
container runs from the user mode but

63
00:02:48,660 --> 00:02:50,700
process isolated containers

64
00:02:50,700 --> 00:02:53,160
are interact directly with the kernel

65
00:02:53,160 --> 00:02:56,040
and are isolated from the host via

66
00:02:56,040 --> 00:02:58,200
multiple aspects

67
00:02:58,200 --> 00:03:00,480
so

68
00:03:00,480 --> 00:03:01,620
yeah

69
00:03:01,620 --> 00:03:05,640
but in order to validate that the

70
00:03:05,640 --> 00:03:07,680
container won't be able to impact the

71
00:03:07,680 --> 00:03:08,459
host

72
00:03:08,459 --> 00:03:10,800
there are few mitigations in the kernel

73
00:03:10,800 --> 00:03:14,220
that violates it for example it prevents

74
00:03:14,220 --> 00:03:16,800
loading driver from the container to the

75
00:03:16,800 --> 00:03:18,540
house to the kernel

76
00:03:18,540 --> 00:03:21,180
in this presentation I'm going to focus

77
00:03:21,180 --> 00:03:24,659
only on process isolated containers

78
00:03:24,659 --> 00:03:27,420
so when we are running a task list

79
00:03:27,420 --> 00:03:30,360
inside windows container we see lots of

80
00:03:30,360 --> 00:03:33,000
system processors which are related to

81
00:03:33,000 --> 00:03:34,379
the OS itself

82
00:03:34,379 --> 00:03:36,319
unlikely not

83
00:03:36,319 --> 00:03:39,120
which doesn't contain system processes

84
00:03:39,120 --> 00:03:41,340
inside the container

85
00:03:41,340 --> 00:03:43,739
these differences between the windows

86
00:03:43,739 --> 00:03:46,379
container and the layer container are

87
00:03:46,379 --> 00:03:48,360
because of the architecture of the

88
00:03:48,360 --> 00:03:51,080
kernel itself

89
00:03:51,120 --> 00:03:53,760
both Linux and windows containers are

90
00:03:53,760 --> 00:03:55,799
running from the user mode only in order

91
00:03:55,799 --> 00:03:57,720
to validate that the container can

92
00:03:57,720 --> 00:04:01,200
impact impact the host

93
00:04:01,200 --> 00:04:04,200
Linux container is monolithic therefore

94
00:04:04,200 --> 00:04:06,360
all its basic functionality is

95
00:04:06,360 --> 00:04:09,000
implemented in the kernel itself

96
00:04:09,000 --> 00:04:12,480
plan like Windows which some of its

97
00:04:12,480 --> 00:04:14,640
functionality is implemented in the user

98
00:04:14,640 --> 00:04:16,978
mode while other is implemented in the

99
00:04:16,978 --> 00:04:19,320
kernel therefore Windows containers

100
00:04:19,320 --> 00:04:22,620
contain Services System services such as

101
00:04:22,620 --> 00:04:25,100
SVC host

102
00:04:25,100 --> 00:04:28,080
so let's deep dive into how process

103
00:04:28,080 --> 00:04:32,040
isolated containers are implemented

104
00:04:32,040 --> 00:04:34,740
there are two parts for Windows

105
00:04:34,740 --> 00:04:37,440
containers the engine which manage all

106
00:04:37,440 --> 00:04:39,720
the containers for example Docker

107
00:04:39,720 --> 00:04:42,840
container and the OS part the windows

108
00:04:42,840 --> 00:04:45,660
part which responsible for the isolation

109
00:04:45,660 --> 00:04:50,040
isolating the container from The Host

110
00:04:50,040 --> 00:04:55,380
I'm gonna Focus only on the Windows part

111
00:04:55,380 --> 00:04:58,440
when a new windows container begins it

112
00:04:58,440 --> 00:05:00,120
creates an environment request for the

113
00:05:00,120 --> 00:05:03,240
container such as object namespace file

114
00:05:03,240 --> 00:05:05,520
system job object and create the

115
00:05:05,520 --> 00:05:07,800
processes that are running inside of the

116
00:05:07,800 --> 00:05:10,220
container

117
00:05:10,259 --> 00:05:13,139
Windows container isolation is separated

118
00:05:13,139 --> 00:05:14,759
into three parts

119
00:05:14,759 --> 00:05:18,660
job object namespaces and layers

120
00:05:18,660 --> 00:05:20,880
this stock I'm going to focus on

121
00:05:20,880 --> 00:05:23,340
bypassing the candle isolation of the

122
00:05:23,340 --> 00:05:24,780
job object

123
00:05:24,780 --> 00:05:27,539
so let's understand what is a job object

124
00:05:27,539 --> 00:05:30,120
job objects were created in Windows a

125
00:05:30,120 --> 00:05:33,419
long long time ago to Google processes

126
00:05:33,419 --> 00:05:36,479
as a single unit and manage the

127
00:05:36,479 --> 00:05:39,360
resources for example CPU time memory

128
00:05:39,360 --> 00:05:42,300
time and limit CR memory limits and so

129
00:05:42,300 --> 00:05:43,380
on

130
00:05:43,380 --> 00:05:45,780
but in order to support isolation as

131
00:05:45,780 --> 00:05:48,419
well the job object is required to be

132
00:05:48,419 --> 00:05:52,380
converted into Asylum

133
00:05:52,380 --> 00:05:55,139
Asylum provide basic isolation

134
00:05:55,139 --> 00:05:57,660
but it is not enough for containers

135
00:05:57,660 --> 00:06:00,240
which which require much more

136
00:06:00,240 --> 00:06:03,360
so in order to have all these

137
00:06:03,360 --> 00:06:06,360
capabilities this Styler have to be

138
00:06:06,360 --> 00:06:09,180
converted into server Asylum

139
00:06:09,180 --> 00:06:14,479
so any server Siler is also a silo

140
00:06:14,639 --> 00:06:17,520
we converted our Silo to server Silo

141
00:06:17,520 --> 00:06:19,800
which support redirection of resources

142
00:06:19,800 --> 00:06:22,919
now we can redirect to resources for

143
00:06:22,919 --> 00:06:25,560
example registry Network stock and

144
00:06:25,560 --> 00:06:29,639
object manager to use resources from the

145
00:06:29,639 --> 00:06:33,199
container image not from the host

146
00:06:33,199 --> 00:06:36,720
but this isolation is not enough

147
00:06:36,720 --> 00:06:40,460
as I said before the kernel requires to

148
00:06:40,460 --> 00:06:44,759
mitigate dangerous systems for example a

149
00:06:44,759 --> 00:06:46,740
load driver

150
00:06:46,740 --> 00:06:50,520
so if it was possible to do to load

151
00:06:50,520 --> 00:06:53,220
driver directly from the container it

152
00:06:53,220 --> 00:06:56,759
wasn't it could not be that isolated and

153
00:06:56,759 --> 00:06:59,580
the container could have escaped so some

154
00:06:59,580 --> 00:07:02,880
validations were added to the content to

155
00:07:02,880 --> 00:07:06,360
the kernel and validate that if the

156
00:07:06,360 --> 00:07:08,639
context of the

157
00:07:08,639 --> 00:07:11,819
thread that did the ciscal is inside of

158
00:07:11,819 --> 00:07:14,039
the container it will block the request

159
00:07:14,039 --> 00:07:18,360
and won't load the driver

160
00:07:18,360 --> 00:07:21,660
as you can see here in the screenshot so

161
00:07:21,660 --> 00:07:24,419
let's deep dive into this mechanism

162
00:07:24,419 --> 00:07:27,360
so when the kernel need to detect if the

163
00:07:27,360 --> 00:07:30,780
current process is isolated such as in a

164
00:07:30,780 --> 00:07:34,020
container it checks for Server Silo in

165
00:07:34,020 --> 00:07:37,620
the e-thread or E process struct

166
00:07:37,620 --> 00:07:40,500
which are the structs in the Canon that

167
00:07:40,500 --> 00:07:44,819
represent the threads and processes

168
00:07:44,819 --> 00:07:47,160
the kernel need to check all the job

169
00:07:47,160 --> 00:07:49,860
objects which attach to the ethread and

170
00:07:49,860 --> 00:07:52,020
E process

171
00:07:52,020 --> 00:07:55,139
struct in order to validate that because

172
00:07:55,139 --> 00:07:57,419
it is possible to attach multiple job

173
00:07:57,419 --> 00:08:01,758
objects to a single thread or process

174
00:08:01,919 --> 00:08:04,440
another example of a flow in the kernel

175
00:08:04,440 --> 00:08:06,599
which required to validate if the

176
00:08:06,599 --> 00:08:09,180
process that did the ciscal is inside of

177
00:08:09,180 --> 00:08:12,539
the container or not is process list

178
00:08:12,539 --> 00:08:16,319
in this flow the kernel just skips the

179
00:08:16,319 --> 00:08:18,780
processes that are outside of the

180
00:08:18,780 --> 00:08:21,300
container and because of that

181
00:08:21,300 --> 00:08:23,940
when a process inside of the container

182
00:08:23,940 --> 00:08:27,479
that a process Lays it gets only the

183
00:08:27,479 --> 00:08:29,699
processes which are inside of the

184
00:08:29,699 --> 00:08:32,120
container

185
00:08:32,159 --> 00:08:34,440
so after we understood how containers

186
00:08:34,440 --> 00:08:36,899
work let's gain empty system inside of

187
00:08:36,899 --> 00:08:39,059
the container

188
00:08:39,059 --> 00:08:42,240
when running Docker run command with

189
00:08:42,240 --> 00:08:43,860
user flag

190
00:08:43,860 --> 00:08:46,560
we can Define the user that the

191
00:08:46,560 --> 00:08:48,440
container will start for example

192
00:08:48,440 --> 00:08:52,440
container user which is a weak user I

193
00:08:52,440 --> 00:08:54,540
would have expected the container to run

194
00:08:54,540 --> 00:08:58,440
as weak user but as you can see on the

195
00:08:58,440 --> 00:09:01,260
slide some processors inside of the

196
00:09:01,260 --> 00:09:04,740
container are running a system

197
00:09:04,740 --> 00:09:07,140
the only process running as a container

198
00:09:07,140 --> 00:09:11,220
user is CMD that we started it means

199
00:09:11,220 --> 00:09:13,920
that the container can communicate with

200
00:09:13,920 --> 00:09:16,980
processes with system permissions and

201
00:09:16,980 --> 00:09:19,620
more interestingly these processes are

202
00:09:19,620 --> 00:09:22,019
loaded from the container image itself

203
00:09:22,019 --> 00:09:24,120
that we can control

204
00:09:24,120 --> 00:09:27,120
so no matter what the user flag was

205
00:09:27,120 --> 00:09:29,519
indicated it means that we can gain

206
00:09:29,519 --> 00:09:32,540
system permissions

207
00:09:32,880 --> 00:09:35,399
so let's understand how to use this

208
00:09:35,399 --> 00:09:37,740
discovery and gaining real system

209
00:09:37,740 --> 00:09:40,620
permissions

210
00:09:40,620 --> 00:09:44,220
in order to craft a container image that

211
00:09:44,220 --> 00:09:47,459
will run a system always we can follow

212
00:09:47,459 --> 00:09:50,459
four simple steps first con start the

213
00:09:50,459 --> 00:09:52,740
container in our lab with system

214
00:09:52,740 --> 00:09:54,120
permissions

215
00:09:54,120 --> 00:09:57,779
and then we will create a service that

216
00:09:57,779 --> 00:10:01,680
will run a system start it and convert

217
00:10:01,680 --> 00:10:04,320
the container into container image that

218
00:10:04,320 --> 00:10:08,480
it will be possible to deploy it again

219
00:10:08,880 --> 00:10:12,000
zero I showed you is not the only way we

220
00:10:12,000 --> 00:10:14,459
can gain system permissions via multiple

221
00:10:14,459 --> 00:10:16,620
ways and I'm sure there are even more

222
00:10:16,620 --> 00:10:19,140
than the ones that are showed here

223
00:10:19,140 --> 00:10:21,480
because we control the image so we can

224
00:10:21,480 --> 00:10:24,540
override system 32 executables that are

225
00:10:24,540 --> 00:10:26,940
loaded from the container startup use

226
00:10:26,940 --> 00:10:29,399
dll side loading modify Windows

227
00:10:29,399 --> 00:10:32,279
configuration changing the registry and

228
00:10:32,279 --> 00:10:34,740
even changing the permissions of the

229
00:10:34,740 --> 00:10:38,839
container user that we are starting

230
00:10:39,660 --> 00:10:42,480
so we gain system permissions inside the

231
00:10:42,480 --> 00:10:45,420
container but we can't do anything we

232
00:10:45,420 --> 00:10:47,760
want on the host because we are still

233
00:10:47,760 --> 00:10:50,940
isolated and we can do anything we want

234
00:10:50,940 --> 00:10:52,440
with this system

235
00:10:52,440 --> 00:10:55,260
so in order to understand how to break

236
00:10:55,260 --> 00:10:58,140
the isolation we need to learn about two

237
00:10:58,140 --> 00:11:02,360
past vulnerabilities of container Escape

238
00:11:02,720 --> 00:11:05,760
vulnerability represents a method for

239
00:11:05,760 --> 00:11:09,600
finding a vulnerability in containers

240
00:11:09,600 --> 00:11:13,200
the first method is to look for apis

241
00:11:13,200 --> 00:11:16,019
that Microsoft just forgot to block

242
00:11:16,019 --> 00:11:18,839
unit 42 found the vulnerability in

243
00:11:18,839 --> 00:11:21,839
object manager symbolically the LED a

244
00:11:21,839 --> 00:11:23,880
process inside of the container access

245
00:11:23,880 --> 00:11:27,120
any hard drive on the host which means

246
00:11:27,120 --> 00:11:30,000
that the container can write arbitrary

247
00:11:30,000 --> 00:11:33,420
files and control the file system

248
00:11:33,420 --> 00:11:36,300
the second method is to try to bypass

249
00:11:36,300 --> 00:11:38,760
Microsoft mitigations

250
00:11:38,760 --> 00:11:41,399
for sure found a way to bypass the

251
00:11:41,399 --> 00:11:44,700
kernel validation of the server silo by

252
00:11:44,700 --> 00:11:47,100
creating a new style object which is not

253
00:11:47,100 --> 00:11:48,720
a cell Asylum

254
00:11:48,720 --> 00:11:51,300
Microsoft added the support for

255
00:11:51,300 --> 00:11:54,000
containers after most of the kernel apis

256
00:11:54,000 --> 00:11:56,519
were written therefore I chose to look

257
00:11:56,519 --> 00:12:00,140
for this first method for looking for

258
00:12:00,140 --> 00:12:04,939
apis with Microsoft just forgot to block

259
00:12:05,160 --> 00:12:06,560
foreign

260
00:12:06,560 --> 00:12:10,380
I'll focus on vulnerable fiscals but

261
00:12:10,380 --> 00:12:13,260
there are over 500 CS cards and each one

262
00:12:13,260 --> 00:12:16,140
of them is huge so I had to find better

263
00:12:16,140 --> 00:12:18,360
patterns to look for

264
00:12:18,360 --> 00:12:22,140
so as I said before it has to be a Cisco

265
00:12:22,140 --> 00:12:25,740
and the second very check it that there

266
00:12:25,740 --> 00:12:28,500
are no validations of isolation

267
00:12:28,500 --> 00:12:30,899
this means that Microsoft possibly

268
00:12:30,899 --> 00:12:33,480
forgot to add them

269
00:12:33,480 --> 00:12:35,820
the third one is tricky

270
00:12:35,820 --> 00:12:39,120
checking administrator privileges

271
00:12:39,120 --> 00:12:41,339
if the Cisco have admin privilege

272
00:12:41,339 --> 00:12:44,220
requires admin privileges it means that

273
00:12:44,220 --> 00:12:47,459
the impact of the Cisco is high which

274
00:12:47,459 --> 00:12:49,320
means that we can impact the host

275
00:12:49,320 --> 00:12:53,940
drastically it can be a major inflict or

276
00:12:53,940 --> 00:12:56,700
it can impact the host in a way that it

277
00:12:56,700 --> 00:12:59,100
won't boot again

278
00:12:59,100 --> 00:13:02,279
so I thought about writing escape to

279
00:13:02,279 --> 00:13:04,620
validate that but it was easy to do it

280
00:13:04,620 --> 00:13:07,920
manually so I didn't have to

281
00:13:07,920 --> 00:13:10,860
after I built this recipe my life become

282
00:13:10,860 --> 00:13:13,079
much easier and I began to find

283
00:13:13,079 --> 00:13:16,500
vulnerable assist goals

284
00:13:16,500 --> 00:13:19,560
a quick trivia and the first function

285
00:13:19,560 --> 00:13:22,740
that took my my eye was anti-quare

286
00:13:22,740 --> 00:13:25,019
system information

287
00:13:25,019 --> 00:13:28,380
this function contains huge switch case

288
00:13:28,380 --> 00:13:32,519
over the enum which contains about 200

289
00:13:32,519 --> 00:13:35,519
options it's not possible to reverse it

290
00:13:35,519 --> 00:13:39,240
manually luckily I had symbols so I

291
00:13:39,240 --> 00:13:41,220
could choose only the interesting enum

292
00:13:41,220 --> 00:13:44,399
values and focus on them so I wrote a

293
00:13:44,399 --> 00:13:46,500
small code the trigger only the

294
00:13:46,500 --> 00:13:48,839
interesting ones and I found an

295
00:13:48,839 --> 00:13:50,519
interesting result

296
00:13:50,519 --> 00:13:53,880
so when I call this this call with the

297
00:13:53,880 --> 00:13:57,839
enum value of CIS handle information it

298
00:13:57,839 --> 00:14:00,360
returned to me a list of all the handles

299
00:14:00,360 --> 00:14:03,420
and the other sets of objects in the

300
00:14:03,420 --> 00:14:04,800
kernel itself

301
00:14:04,800 --> 00:14:08,100
and all the processes on the hospital

302
00:14:08,100 --> 00:14:10,800
which means that we can see process

303
00:14:10,800 --> 00:14:14,700
ideas of other containers and processes

304
00:14:14,700 --> 00:14:16,860
that are running on the host

305
00:14:16,860 --> 00:14:20,100
but it is not possible to use these

306
00:14:20,100 --> 00:14:23,519
handles or other cells because we can't

307
00:14:23,519 --> 00:14:25,920
open process to a process which outside

308
00:14:25,920 --> 00:14:27,420
of the container

309
00:14:27,420 --> 00:14:30,240
or duplicate the handle of him

310
00:14:30,240 --> 00:14:33,420
so it is a minor in folic

311
00:14:33,420 --> 00:14:36,600
so we can get all the process IDs of all

312
00:14:36,600 --> 00:14:39,660
the processes on the host but I want

313
00:14:39,660 --> 00:14:42,420
much more so I continue to learn

314
00:14:42,420 --> 00:14:45,480
addition is this call I found was a

315
00:14:45,480 --> 00:14:48,959
anti-system debug control

316
00:14:48,959 --> 00:14:51,240
anti-system debug control is similar to

317
00:14:51,240 --> 00:14:54,240
the previous one it's also I have

318
00:14:54,240 --> 00:14:56,519
multiple options depend on the enum

319
00:14:56,519 --> 00:14:58,019
value

320
00:14:58,019 --> 00:15:00,899
I saw that this function called multiple

321
00:15:00,899 --> 00:15:03,360
interesting functions such as enable

322
00:15:03,360 --> 00:15:06,839
kernel debugger but all these options

323
00:15:06,839 --> 00:15:10,980
were blocked and only if the current

324
00:15:10,980 --> 00:15:15,360
debugger is enabled sorry only if it's

325
00:15:15,360 --> 00:15:17,100
disabled

326
00:15:17,100 --> 00:15:19,800
the only two options that on a clean

327
00:15:19,800 --> 00:15:23,639
windows machine will work are dump user

328
00:15:23,639 --> 00:15:25,980
mode which won't give me any actual

329
00:15:25,980 --> 00:15:28,680
value because I need an open handle to

330
00:15:28,680 --> 00:15:32,940
it and kernel dump which definitely will

331
00:15:32,940 --> 00:15:34,860
do the work

332
00:15:34,860 --> 00:15:37,380
so in order to do a candle dump from the

333
00:15:37,380 --> 00:15:40,019
container I need to fill this truck

334
00:15:40,019 --> 00:15:43,019
since the bug life dump control which

335
00:15:43,019 --> 00:15:45,980
contains two important

336
00:15:45,980 --> 00:15:49,019
parameters handle to a file in the

337
00:15:49,019 --> 00:15:50,220
container

338
00:15:50,220 --> 00:15:55,260
it's easy and flags for dump and Page

339
00:15:55,260 --> 00:15:58,500
control which defines how the dump will

340
00:15:58,500 --> 00:16:02,040
look like and what it will contain

341
00:16:02,040 --> 00:16:03,839
I took a source code from the internet

342
00:16:03,839 --> 00:16:06,480
that triggered the camera dump I change

343
00:16:06,480 --> 00:16:08,880
it a bit and managed to call Acura Dam

344
00:16:08,880 --> 00:16:11,760
to do a counter dump and read it from

345
00:16:11,760 --> 00:16:14,779
inside the container

346
00:16:15,440 --> 00:16:19,260
so let's look about what we've done

347
00:16:19,260 --> 00:16:21,720
and the flags the flags were

348
00:16:21,720 --> 00:16:24,120
undocumented and the ones that I found

349
00:16:24,120 --> 00:16:25,680
listed here

350
00:16:25,680 --> 00:16:28,860
the interesting one is dump user space

351
00:16:28,860 --> 00:16:33,120
memory and the hyper-v pages

352
00:16:33,120 --> 00:16:36,899
I attach a VM with the kernel debugger

353
00:16:36,899 --> 00:16:40,320
and try to do the dump with the VM

354
00:16:40,320 --> 00:16:42,959
and it worked I managed to dump all user

355
00:16:42,959 --> 00:16:46,199
mode hyper-v and all the flags that I

356
00:16:46,199 --> 00:16:46,920
found

357
00:16:46,920 --> 00:16:50,220
but on a clean windows machine

358
00:16:50,220 --> 00:16:53,579
all the flags work except one dumping

359
00:16:53,579 --> 00:16:57,180
the user mode and so if the kernel

360
00:16:57,180 --> 00:17:00,600
debugger is enabled we can dump LS which

361
00:17:00,600 --> 00:17:03,720
contains all the processes and all the

362
00:17:03,720 --> 00:17:06,119
passwords in Windows

363
00:17:06,119 --> 00:17:09,119
yeah so if we can dump else we can

364
00:17:09,119 --> 00:17:10,679
access it

365
00:17:10,679 --> 00:17:15,839
but on a regular machines

366
00:17:15,839 --> 00:17:18,359
current debugger is not enabled so let's

367
00:17:18,359 --> 00:17:20,699
understand how to gain passwords with

368
00:17:20,699 --> 00:17:22,859
the camera dump

369
00:17:22,859 --> 00:17:24,900
so there are multiple ways to get them

370
00:17:24,900 --> 00:17:27,419
the first one is process list we can

371
00:17:27,419 --> 00:17:29,760
access from the current dump all the

372
00:17:29,760 --> 00:17:32,640
processes and the parameters they can

373
00:17:32,640 --> 00:17:33,840
access

374
00:17:33,840 --> 00:17:36,360
and we can access the environment

375
00:17:36,360 --> 00:17:38,880
variables that are passed through we can

376
00:17:38,880 --> 00:17:42,780
access the arguments and in addition to

377
00:17:42,780 --> 00:17:46,919
that we can read and query all the

378
00:17:46,919 --> 00:17:50,640
registry and that are loaded on the host

379
00:17:50,640 --> 00:17:53,520
itself and sometimes passwords are

380
00:17:53,520 --> 00:17:55,380
stored there as well

381
00:17:55,380 --> 00:17:58,440
and if current debugger is enabled it it

382
00:17:58,440 --> 00:18:00,059
is possible to gain all the password

383
00:18:00,059 --> 00:18:02,880
much easier with elders

384
00:18:02,880 --> 00:18:05,460
and of course Canon debugger is not only

385
00:18:05,460 --> 00:18:08,940
about passwords we can see lots of other

386
00:18:08,940 --> 00:18:12,960
interesting information for example edrs

387
00:18:12,960 --> 00:18:16,679
detect which one are running from view

388
00:18:16,679 --> 00:18:20,340
event logs stack traces kernel memory

389
00:18:20,340 --> 00:18:23,600
and much more

390
00:18:23,760 --> 00:18:26,820
additional vulnerability I found is

391
00:18:26,820 --> 00:18:29,760
related to the ue5 so in order to

392
00:18:29,760 --> 00:18:32,400
understand the impact and how we can use

393
00:18:32,400 --> 00:18:34,980
this vulnerability I give a little bit

394
00:18:34,980 --> 00:18:37,020
of a background

395
00:18:37,020 --> 00:18:39,960
when we bought a new Windows PC it

396
00:18:39,960 --> 00:18:41,640
probably will boot in the following

397
00:18:41,640 --> 00:18:46,620
sequence first the UEFI in the CPU loads

398
00:18:46,620 --> 00:18:50,760
the UEFI drivers and devices then the

399
00:18:50,760 --> 00:18:54,240
UEFI reads the envelope memory in order

400
00:18:54,240 --> 00:18:57,720
to know how to continue the boot

401
00:18:57,720 --> 00:19:01,500
then the boot sequence path from the ue5

402
00:19:01,500 --> 00:19:03,419
to the windows

403
00:19:03,419 --> 00:19:06,780
on the third step Windows Begins the

404
00:19:06,780 --> 00:19:08,880
boot sequence Windows pulls the

405
00:19:08,880 --> 00:19:11,400
configuration from BCD which are stored

406
00:19:11,400 --> 00:19:14,640
on the EFI partition and then it

407
00:19:14,640 --> 00:19:16,919
contains the boat until Windows fully

408
00:19:16,919 --> 00:19:18,000
loaded

409
00:19:18,000 --> 00:19:21,960
let's focus on the Android storage

410
00:19:21,960 --> 00:19:24,120
so the environment contains a

411
00:19:24,120 --> 00:19:26,520
configuration of the ue5

412
00:19:26,520 --> 00:19:29,100
these configurations are not stored on

413
00:19:29,100 --> 00:19:31,679
the hard disk but on a chip on the

414
00:19:31,679 --> 00:19:32,880
motherboard

415
00:19:32,880 --> 00:19:34,980
this memory is shared between the

416
00:19:34,980 --> 00:19:38,760
operating system Windows and the UEFI

417
00:19:38,760 --> 00:19:39,960
itself

418
00:19:39,960 --> 00:19:42,480
in order to access a environment

419
00:19:42,480 --> 00:19:45,360
variable we need to know its good unique

420
00:19:45,360 --> 00:19:49,919
identifier and its name

421
00:19:49,919 --> 00:19:53,039
two examples of interesting environment

422
00:19:53,039 --> 00:19:57,780
variables are good and boot order

423
00:19:57,780 --> 00:20:00,960
boot is a variable the defined for the

424
00:20:00,960 --> 00:20:04,320
UEFI how to boot using a specific method

425
00:20:04,320 --> 00:20:07,080
for example boot from a specific file

426
00:20:07,080 --> 00:20:11,700
boot from hard disk Network and so on

427
00:20:11,700 --> 00:20:15,539
boot order defines the order of the boot

428
00:20:15,539 --> 00:20:18,179
whether we are going to Define put from

429
00:20:18,179 --> 00:20:22,760
CD first hard disk first and so on

430
00:20:22,760 --> 00:20:27,299
the boot variable sometimes a link to a

431
00:20:27,299 --> 00:20:30,480
file system files on the file system

432
00:20:30,480 --> 00:20:33,240
but these files are found in the EFI

433
00:20:33,240 --> 00:20:37,320
partition in FAT32 so the container can

434
00:20:37,320 --> 00:20:38,720
access them

435
00:20:38,720 --> 00:20:42,559
so we can't use it

436
00:20:44,039 --> 00:20:48,000
the UEFI support multiple types and

437
00:20:48,000 --> 00:20:49,280
flags

438
00:20:49,280 --> 00:20:53,100
the variables can be permanent or they

439
00:20:53,100 --> 00:20:55,620
can be a volatile

440
00:20:55,620 --> 00:20:59,179
and it is possible to Mark each variable

441
00:20:59,179 --> 00:21:02,220
when it is possible to access it for

442
00:21:02,220 --> 00:21:06,720
example access on boot only so it is not

443
00:21:06,720 --> 00:21:09,780
possible to access him from the windows

444
00:21:09,780 --> 00:21:12,840
part or is it possible only to access it

445
00:21:12,840 --> 00:21:16,080
from the Windows File

446
00:21:16,080 --> 00:21:18,539
after we finished the introduction

447
00:21:18,539 --> 00:21:21,000
let's jump to the group of vulnerable

448
00:21:21,000 --> 00:21:27,080
ciscals which are related to the NVM API

449
00:21:28,380 --> 00:21:31,020
the first capability we need is listing

450
00:21:31,020 --> 00:21:33,900
environment variables on the host

451
00:21:33,900 --> 00:21:39,440
we do that at using the anti

452
00:21:39,740 --> 00:21:43,380
-venom Barbers which are accessible from

453
00:21:43,380 --> 00:21:45,179
the

454
00:21:45,179 --> 00:21:47,880
the container

455
00:21:47,880 --> 00:21:52,039
the Bell from the host itself

456
00:21:53,400 --> 00:21:57,419
without reading them which lead us to

457
00:21:57,419 --> 00:22:01,039
to the seconds is called

458
00:22:01,500 --> 00:22:04,320
create a specific environment model

459
00:22:04,320 --> 00:22:07,260
that we already know the good and the

460
00:22:07,260 --> 00:22:09,120
name from before

461
00:22:09,120 --> 00:22:11,640
Microsoft didn't block The Cisco from

462
00:22:11,640 --> 00:22:14,280
the container as well

463
00:22:14,280 --> 00:22:17,520
and the last capability we need is

464
00:22:17,520 --> 00:22:21,299
writing the NVM variables

465
00:22:21,299 --> 00:22:24,539
and so now we can get

466
00:22:24,539 --> 00:22:27,900
read write and list all the andron

467
00:22:27,900 --> 00:22:31,260
Barbers that are in the host

468
00:22:31,260 --> 00:22:33,659
so let's understand what we can do with

469
00:22:33,659 --> 00:22:35,840
it

470
00:22:36,360 --> 00:22:38,460
after the container is killed and start

471
00:22:38,460 --> 00:22:41,280
over all its storage under some

472
00:22:41,280 --> 00:22:44,960
configurations are reverted

473
00:22:44,960 --> 00:22:48,240
environment storage is permanent

474
00:22:48,240 --> 00:22:52,200
so we can use use this storage in order

475
00:22:52,200 --> 00:22:56,220
to store persistent storage and this

476
00:22:56,220 --> 00:22:58,380
information will be stored between

477
00:22:58,380 --> 00:23:01,980
container reboots host reboots and

478
00:23:01,980 --> 00:23:04,679
because NVM variables are stored on the

479
00:23:04,679 --> 00:23:07,620
motherboard itself it can stay even up

480
00:23:07,620 --> 00:23:10,760
between formats

481
00:23:11,159 --> 00:23:14,460
additional impact is that we can

482
00:23:14,460 --> 00:23:16,880
communicate between two containers

483
00:23:16,880 --> 00:23:19,080
isolated containers

484
00:23:19,080 --> 00:23:22,440
both of the containers can communicate

485
00:23:22,440 --> 00:23:25,440
with NVM storage

486
00:23:25,440 --> 00:23:29,460
so we can read one variable and write it

487
00:23:29,460 --> 00:23:31,140
from another

488
00:23:31,140 --> 00:23:33,059
which leads us to a possible

489
00:23:33,059 --> 00:23:36,780
exfiltration data between them

490
00:23:36,780 --> 00:23:39,419
but the most interesting impact is

491
00:23:39,419 --> 00:23:41,820
triggering permanent denial of service

492
00:23:41,820 --> 00:23:43,500
of the host

493
00:23:43,500 --> 00:23:46,200
because the UEFI passes the environment

494
00:23:46,200 --> 00:23:47,100
bubble

495
00:23:47,100 --> 00:23:49,559
it is possible to change some of them

496
00:23:49,559 --> 00:23:54,059
and make the host unbootable forever

497
00:23:54,059 --> 00:23:56,880
by changing the boot and boot order

498
00:23:56,880 --> 00:24:00,419
doesn't prevent the ufi from booting

499
00:24:00,419 --> 00:24:04,200
because Windows back because the ufi

500
00:24:04,200 --> 00:24:06,900
have backup configuration which are

501
00:24:06,900 --> 00:24:09,480
flashed on the ue5

502
00:24:09,480 --> 00:24:14,120
therefore I have to look for other flows

503
00:24:14,880 --> 00:24:19,440
so another variable found in the NVM is

504
00:24:19,440 --> 00:24:21,480
hddp

505
00:24:21,480 --> 00:24:24,419
writing non-valid value to it will do

506
00:24:24,419 --> 00:24:26,700
the job and it will cause permanent

507
00:24:26,700 --> 00:24:29,880
denial of service to The Host

508
00:24:29,880 --> 00:24:34,400
this variable is read only on the boot

509
00:24:34,400 --> 00:24:38,220
so after changing this variable nothing

510
00:24:38,220 --> 00:24:40,380
will happen on the host

511
00:24:40,380 --> 00:24:43,740
only after the host will shut down and

512
00:24:43,740 --> 00:24:46,440
it will shut down as expected

513
00:24:46,440 --> 00:24:50,220
and try to boot up again it it won't be

514
00:24:50,220 --> 00:24:53,340
possible to load with the windows again

515
00:24:53,340 --> 00:24:55,260
so it doesn't matter how much restart

516
00:24:55,260 --> 00:24:58,860
you try to do for the host it won't work

517
00:24:58,860 --> 00:25:02,520
but this variable exists only on some

518
00:25:02,520 --> 00:25:06,659
ureifies on VMware UEFI

519
00:25:06,659 --> 00:25:09,299
if we will run Windows container inside

520
00:25:09,299 --> 00:25:13,559
windows VM running VMware machine for

521
00:25:13,559 --> 00:25:18,179
example es6 VMware Workstation the UEFI

522
00:25:18,179 --> 00:25:21,000
of the windows VM is a vulnerable

523
00:25:21,000 --> 00:25:22,440
component

524
00:25:22,440 --> 00:25:25,860
so when we are writing HTTP variable

525
00:25:25,860 --> 00:25:27,960
from the container

526
00:25:27,960 --> 00:25:31,740
it will cause the vimo VM to permanent

527
00:25:31,740 --> 00:25:34,520
denial of service

528
00:25:44,159 --> 00:25:46,440
the host of the machine won't be

529
00:25:46,440 --> 00:25:48,600
impacted by this

530
00:25:48,600 --> 00:25:50,940
so let's deep dive into the vulnerable

531
00:25:50,940 --> 00:25:53,159
component in the

532
00:25:53,159 --> 00:25:54,480
UEFI

533
00:25:54,480 --> 00:25:57,779
the UEFI is built from multiple parts

534
00:25:57,779 --> 00:26:01,679
the vulnerable one is BDS driver which

535
00:26:01,679 --> 00:26:04,679
responsible for selecting which device

536
00:26:04,679 --> 00:26:07,880
to boot from

537
00:26:09,360 --> 00:26:12,960
the root cause in the BDS dxc

538
00:26:12,960 --> 00:26:17,340
is that it reads the HTTP variable and

539
00:26:17,340 --> 00:26:20,520
because we are overwrite it with invalid

540
00:26:20,520 --> 00:26:21,659
value

541
00:26:21,659 --> 00:26:25,940
it jumps to the function assert efil

542
00:26:25,940 --> 00:26:30,840
which Loops over which breaks the boot

543
00:26:30,840 --> 00:26:32,100
sequence

544
00:26:32,100 --> 00:26:34,500
and call the permanent denial of service

545
00:26:34,500 --> 00:26:37,500
because the UEFI now can't continue and

546
00:26:37,500 --> 00:26:40,760
load the windows part

547
00:26:41,039 --> 00:26:44,700
so let's jump to the demo in this demo

548
00:26:44,700 --> 00:26:48,600
I'll show the Privileges relation that I

549
00:26:48,600 --> 00:26:51,299
showed before using a malicious Windows

550
00:26:51,299 --> 00:26:54,059
container and how I caused the permanent

551
00:26:54,059 --> 00:26:58,639
denial of service to a VMware via

552
00:27:01,220 --> 00:27:03,900
so here

553
00:27:03,900 --> 00:27:06,500
sorry

554
00:27:07,080 --> 00:27:11,340
here I'm going to start a weak Windows

555
00:27:11,340 --> 00:27:14,220
container

556
00:27:14,220 --> 00:27:18,120
with a malicious content

557
00:27:18,120 --> 00:27:22,140
so as you can see here the user doesn't

558
00:27:22,140 --> 00:27:24,659
have pre-admin privileges

559
00:27:24,659 --> 00:27:28,260
but there is a background service that

560
00:27:28,260 --> 00:27:31,620
attached to it that reads into reads the

561
00:27:31,620 --> 00:27:35,700
input file and writes the output to the

562
00:27:35,700 --> 00:27:38,460
output and it runs a system

563
00:27:38,460 --> 00:27:42,120
if I'll use this capability in order to

564
00:27:42,120 --> 00:27:45,799
override the environment variable HTTP

565
00:27:45,799 --> 00:27:50,640
and use the service you can see in here

566
00:27:50,640 --> 00:27:52,500
that it wrote

567
00:27:52,500 --> 00:27:56,400
six times a to the variable

568
00:27:56,400 --> 00:27:59,159
then nothing will happen until the

569
00:27:59,159 --> 00:28:00,120
restart

570
00:28:00,120 --> 00:28:03,000
so now we will need to wait for the

571
00:28:03,000 --> 00:28:03,960
restart

572
00:28:03,960 --> 00:28:06,659
and it will shut down as expected

573
00:28:06,659 --> 00:28:09,559
everything will go smooth

574
00:28:09,559 --> 00:28:13,200
but when the UEFI will try to load it

575
00:28:13,200 --> 00:28:17,460
again and read this environment it will

576
00:28:17,460 --> 00:28:20,360
fail to continue

577
00:28:21,360 --> 00:28:25,559
so as you can see here VMware VM started

578
00:28:25,559 --> 00:28:27,080
in its

579
00:28:27,080 --> 00:28:31,980
settings and in stock on this it won't

580
00:28:31,980 --> 00:28:35,779
continue this step forever

581
00:28:41,340 --> 00:28:44,059
thank you

582
00:28:44,400 --> 00:28:48,299
so let's explain how the demo works

583
00:28:48,299 --> 00:28:51,240
so before the demo I created the back

584
00:28:51,240 --> 00:28:54,779
door service which run a system and it

585
00:28:54,779 --> 00:28:57,480
reads and writes to the input and output

586
00:28:57,480 --> 00:28:59,340
files

587
00:28:59,340 --> 00:29:03,120
and when we override the variable HTTP

588
00:29:03,120 --> 00:29:05,940
it and to restart the machine it

589
00:29:05,940 --> 00:29:07,679
triggered the permanent denial of

590
00:29:07,679 --> 00:29:09,360
service

591
00:29:09,360 --> 00:29:11,820
it is not easy to mitigate these

592
00:29:11,820 --> 00:29:14,039
vulnerabilities without official patch

593
00:29:14,039 --> 00:29:15,480
for Microsoft

594
00:29:15,480 --> 00:29:19,200
but there are a few walk arounds and

595
00:29:19,200 --> 00:29:22,080
that we can use in order to validate

596
00:29:22,080 --> 00:29:24,539
that we will not we want to be

597
00:29:24,539 --> 00:29:27,600
vulnerable to this one and these flows

598
00:29:27,600 --> 00:29:30,600
the first and easiest way to do is to

599
00:29:30,600 --> 00:29:33,000
use hyperview isolation and not process

600
00:29:33,000 --> 00:29:36,059
isolated containers but it would cost us

601
00:29:36,059 --> 00:29:39,720
with the performance overhead

602
00:29:39,720 --> 00:29:42,960
the another way is to just trust the

603
00:29:42,960 --> 00:29:46,220
container images that you want and only

604
00:29:46,220 --> 00:29:49,700
use signed once

605
00:29:49,700 --> 00:29:53,940
and the other way is another solution is

606
00:29:53,940 --> 00:29:56,279
to assume that any process in any

607
00:29:56,279 --> 00:29:57,500
container

608
00:29:57,500 --> 00:30:01,860
that run in Windows is system

609
00:30:01,860 --> 00:30:05,460
so you should Define it in the

610
00:30:05,460 --> 00:30:09,320
is the network topology

611
00:30:10,200 --> 00:30:12,480
container input scanning used in order

612
00:30:12,480 --> 00:30:14,640
to ensure that there are no privileged

613
00:30:14,640 --> 00:30:17,039
escalation or malicious content exists

614
00:30:17,039 --> 00:30:18,240
in the image

615
00:30:18,240 --> 00:30:21,179
I tested my container against container

616
00:30:21,179 --> 00:30:23,460
image scanning which didn't detect the

617
00:30:23,460 --> 00:30:26,399
privilege escalation but only after I

618
00:30:26,399 --> 00:30:29,340
really dug into them into their website

619
00:30:29,340 --> 00:30:31,860
I discovered that the don't officially

620
00:30:31,860 --> 00:30:35,580
supported but they do show that the

621
00:30:35,580 --> 00:30:37,039
image is clean

622
00:30:37,039 --> 00:30:41,340
and sadly I could not put my hands on a

623
00:30:41,340 --> 00:30:43,559
container image scanning product let's

624
00:30:43,559 --> 00:30:46,940
support Windows containers

625
00:30:47,340 --> 00:30:50,100
regarding the vendor responses

626
00:30:50,100 --> 00:30:52,620
and the previous escalation and

627
00:30:52,620 --> 00:30:55,559
Microsoft said that because it may only

628
00:30:55,559 --> 00:30:59,460
admin Stratos can start the containers

629
00:30:59,460 --> 00:31:02,880
there is no privilege escalation here

630
00:31:02,880 --> 00:31:05,640
and regarding the current dump they said

631
00:31:05,640 --> 00:31:06,539
that

632
00:31:06,539 --> 00:31:08,940
it is not a vulnerability because we

633
00:31:08,940 --> 00:31:12,539
need a system permissions inside of the

634
00:31:12,539 --> 00:31:14,700
container

635
00:31:14,700 --> 00:31:19,320
but they do plan to fix it in the future

636
00:31:19,320 --> 00:31:21,179
regarding the environment variable

637
00:31:21,179 --> 00:31:23,340
attack which we can read and write

638
00:31:23,340 --> 00:31:26,760
environment variables from inside of the

639
00:31:26,760 --> 00:31:29,760
container they defined it as moderate

640
00:31:29,760 --> 00:31:31,500
denial of service

641
00:31:31,500 --> 00:31:34,200
but it is outside of the scope of

642
00:31:34,200 --> 00:31:36,059
Windows security update

643
00:31:36,059 --> 00:31:38,520
and they do plan to fix it

644
00:31:38,520 --> 00:31:42,299
and regarding the last one the VMware

645
00:31:42,299 --> 00:31:45,240
ue5 variable hddp

646
00:31:45,240 --> 00:31:48,659
female treated as functional issue it

647
00:31:48,659 --> 00:31:51,419
because it impacts only the VM itself

648
00:31:51,419 --> 00:31:54,840
and it requires admin privileges inside

649
00:31:54,840 --> 00:31:59,959
of them and but they do plan to fix it

650
00:32:00,240 --> 00:32:03,480
I uploaded all the tools and cards that

651
00:32:03,480 --> 00:32:06,120
I use how to do a privilege escalation

652
00:32:06,120 --> 00:32:09,240
using your malicious container image

653
00:32:09,240 --> 00:32:12,059
how to do care dump and the

654
00:32:12,059 --> 00:32:15,419
modifications that I did there and a

655
00:32:15,419 --> 00:32:18,120
manual for how to cause permanent denial

656
00:32:18,120 --> 00:32:23,279
of service like I showed here and down

657
00:32:23,279 --> 00:32:26,159
I would like to thank Mickey for help me

658
00:32:26,159 --> 00:32:29,220
reversing the female ufi

659
00:32:29,220 --> 00:32:31,919
and I would like to credit multiple

660
00:32:31,919 --> 00:32:34,080
other researchers that I best my

661
00:32:34,080 --> 00:32:36,960
research on top of them

662
00:32:36,960 --> 00:32:41,050
thank you for joining moving to the Q a

663
00:32:41,050 --> 00:32:44,169
[Music]

664
00:32:48,020 --> 00:32:51,109
[Music]

