1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:06,859 --> 00:00:09,859
thank you

3
00:00:10,679 --> 00:00:14,219
okay so my name is Maxim rosibelon and

4
00:00:14,219 --> 00:00:15,660
together with my colleague Damiano

5
00:00:15,660 --> 00:00:17,640
miloti we are going to speak about the

6
00:00:17,640 --> 00:00:19,500
titanium chip and how we performed in a

7
00:00:19,500 --> 00:00:22,080
rability research on it and you may have

8
00:00:22,080 --> 00:00:24,480
noticed that nowadays smartphone vendors

9
00:00:24,480 --> 00:00:25,980
tend to integrate Hardware security

10
00:00:25,980 --> 00:00:27,960
modules in their smartphones and on this

11
00:00:27,960 --> 00:00:30,439
module relies the most critical security

12
00:00:30,439 --> 00:00:33,840
critical security features of the device

13
00:00:33,840 --> 00:00:36,239
and this module comes with a

14
00:00:36,239 --> 00:00:38,340
cryptographic capabilities and Hardware

15
00:00:38,340 --> 00:00:40,079
protections against Hardware reverse

16
00:00:40,079 --> 00:00:42,600
engineering or fault injection and most

17
00:00:42,600 --> 00:00:45,660
of their design is both hardware and

18
00:00:45,660 --> 00:00:47,879
software is only known by the chief

19
00:00:47,879 --> 00:00:50,879
manufacturer sometimes the vendor

20
00:00:50,879 --> 00:00:53,520
yet for US security researchers are

21
00:00:53,520 --> 00:00:55,320
these components are working the whole

22
00:00:55,320 --> 00:00:57,539
device security which is pretty much the

23
00:00:57,539 --> 00:00:59,699
motivation for this talk today

24
00:00:59,699 --> 00:01:02,399
we will show you how we perform the

25
00:01:02,399 --> 00:01:04,619
vulnerability research on the titanium

26
00:01:04,619 --> 00:01:06,420
chip so a security chip designed by

27
00:01:06,420 --> 00:01:09,420
Google for their pixel devices and we

28
00:01:09,420 --> 00:01:11,880
hope that what we will show you today

29
00:01:11,880 --> 00:01:13,560
um we will be useful to other

30
00:01:13,560 --> 00:01:15,240
researchers who will face similar

31
00:01:15,240 --> 00:01:17,400
targets

32
00:01:17,400 --> 00:01:20,520
so uh we all both security researchers

33
00:01:20,520 --> 00:01:23,220
at quarks lab and we are working in a

34
00:01:23,220 --> 00:01:26,880
team that deals with uh embedded devices

35
00:01:26,880 --> 00:01:30,479
and we did a Target and we also very

36
00:01:30,479 --> 00:01:33,180
curious about mobile mobile targets

37
00:01:33,180 --> 00:01:34,979
now

38
00:01:34,979 --> 00:01:36,900
we are going to speak about the titanium

39
00:01:36,900 --> 00:01:39,659
chip so it's in fact

40
00:01:39,659 --> 00:01:40,740
um

41
00:01:40,740 --> 00:01:42,659
yesterday there were this great talk

42
00:01:42,659 --> 00:01:44,880
about some folks at Google about how the

43
00:01:44,880 --> 00:01:49,259
red team the the Titan M2 device so the

44
00:01:49,259 --> 00:01:52,200
Titan device we are speaking uh about

45
00:01:52,200 --> 00:01:56,460
today is the old generation one and on

46
00:01:56,460 --> 00:01:57,720
this device

47
00:01:57,720 --> 00:01:59,820
it has been introduced in fact starting

48
00:01:59,820 --> 00:02:03,119
from the pixel 3 and up to the the pixel

49
00:02:03,119 --> 00:02:06,600
5 I guess and on this device you will um

50
00:02:06,600 --> 00:02:09,660
you will um will realize the critical

51
00:02:09,660 --> 00:02:12,239
security features uh of the smartphone

52
00:02:12,239 --> 00:02:14,520
and among them you will find the secure

53
00:02:14,520 --> 00:02:16,020
boot

54
00:02:16,020 --> 00:02:19,200
you will find the unlock feature

55
00:02:19,200 --> 00:02:21,780
um using the pin code on password and

56
00:02:21,780 --> 00:02:24,420
also the key store which is probably the

57
00:02:24,420 --> 00:02:26,900
most important one for us today

58
00:02:26,900 --> 00:02:29,879
uh this feature allows Android

59
00:02:29,879 --> 00:02:32,160
applications to generate and use keys

60
00:02:32,160 --> 00:02:34,260
from within the safe environment meaning

61
00:02:34,260 --> 00:02:37,140
the Titan M chip and whenever this

62
00:02:37,140 --> 00:02:38,819
feature relies on a security chip it is

63
00:02:38,819 --> 00:02:40,319
called strongbox

64
00:02:40,319 --> 00:02:42,840
now it is important to keep in mind that

65
00:02:42,840 --> 00:02:46,260
this chip is separated from the main CPU

66
00:02:46,260 --> 00:02:48,480
from the application processor you have

67
00:02:48,480 --> 00:02:51,060
one hand the main system on chip that

68
00:02:51,060 --> 00:02:52,739
runs Android and its application and you

69
00:02:52,739 --> 00:02:54,300
have another chip the Titan and Chip

70
00:02:54,300 --> 00:02:56,340
they communicate together through an

71
00:02:56,340 --> 00:02:59,580
Hardware boss as a client server model

72
00:02:59,580 --> 00:03:02,760
now according to Google this chip has

73
00:03:02,760 --> 00:03:05,220
been introduced in order to mitigate a

74
00:03:05,220 --> 00:03:07,140
wide range of side Channel attacks that

75
00:03:07,140 --> 00:03:10,260
were impacting the arm trade zone where

76
00:03:10,260 --> 00:03:12,840
previously uh the features I mentioned

77
00:03:12,840 --> 00:03:15,840
were implemented into

78
00:03:15,840 --> 00:03:19,560
now this Titan m is based on aux

79
00:03:19,560 --> 00:03:21,599
um cortex M3 architecture which is quite

80
00:03:21,599 --> 00:03:24,360
common for microcontrollers the firmware

81
00:03:24,360 --> 00:03:26,580
is close to us but it is based on an

82
00:03:26,580 --> 00:03:29,220
open source OS called EC EC stands for

83
00:03:29,220 --> 00:03:32,280
embed controller and it's uh it's

84
00:03:32,280 --> 00:03:34,560
designed by Google and it targets the

85
00:03:34,560 --> 00:03:36,480
various microcontrollers of the Chrome

86
00:03:36,480 --> 00:03:38,400
OS Project which is why it's quite

87
00:03:38,400 --> 00:03:40,920
simple and small for example there is

88
00:03:40,920 --> 00:03:43,500
pretty much no Dynamic allocation in it

89
00:03:43,500 --> 00:03:46,379
and most of the code is running into a

90
00:03:46,379 --> 00:03:47,640
task that can be compared to

91
00:03:47,640 --> 00:03:50,760
applications in bigger os's now the two

92
00:03:50,760 --> 00:03:52,860
Hardware bosses that are interesting for

93
00:03:52,860 --> 00:03:55,200
us today or first of all the SPI boss

94
00:03:55,200 --> 00:03:57,299
that is used to communicate with the

95
00:03:57,299 --> 00:03:58,879
application processor and with Android

96
00:03:58,879 --> 00:04:02,159
and the uart bus that is not available

97
00:04:02,159 --> 00:04:03,959
by default but we will show you how you

98
00:04:03,959 --> 00:04:06,420
can find it on some devices and the uart

99
00:04:06,420 --> 00:04:07,920
is used for

100
00:04:07,920 --> 00:04:09,480
um for the logs and a minimalistic

101
00:04:09,480 --> 00:04:11,340
console

102
00:04:11,340 --> 00:04:14,280
now let's zoom into the way Android uh

103
00:04:14,280 --> 00:04:17,100
communicates uh with the Titan name so

104
00:04:17,100 --> 00:04:20,279
you have the SPI boss and uh on the main

105
00:04:20,279 --> 00:04:22,199
CPU you have a kernel driver that will

106
00:04:22,199 --> 00:04:24,479
handle the SPI communication and it

107
00:04:24,479 --> 00:04:26,820
exposes an IO CTL interface

108
00:04:26,820 --> 00:04:29,280
uh to the to the demons and in fact you

109
00:04:29,280 --> 00:04:30,900
have only one demon and artery that

110
00:04:30,900 --> 00:04:32,160
communicates with this driver it's

111
00:04:32,160 --> 00:04:35,160
called CWD and its role is to dispatch

112
00:04:35,160 --> 00:04:37,320
the values messages received from

113
00:04:37,320 --> 00:04:39,240
services to the driver

114
00:04:39,240 --> 00:04:41,820
now these Services I call them here Hal

115
00:04:41,820 --> 00:04:44,639
for Hardware abstraction layer

116
00:04:44,639 --> 00:04:46,919
there is one service per functionality

117
00:04:46,919 --> 00:04:50,460
so one for Crystal one for wither

118
00:04:50,460 --> 00:04:51,780
and

119
00:04:51,780 --> 00:04:53,840
um this service will translate

120
00:04:53,840 --> 00:04:56,240
the generic Android

121
00:04:56,240 --> 00:04:59,639
API into something custom and here to do

122
00:04:59,639 --> 00:05:01,759
so they use protobuf a famous

123
00:05:01,759 --> 00:05:03,780
serialization framework designed by

124
00:05:03,780 --> 00:05:07,259
Google and thanks for us in fact the the

125
00:05:07,259 --> 00:05:09,540
definitions the protobab definitions are

126
00:05:09,540 --> 00:05:12,000
available in the iosp repositories so it

127
00:05:12,000 --> 00:05:13,979
will be quite convenient for the

128
00:05:13,979 --> 00:05:15,419
different tools that will be present

129
00:05:15,419 --> 00:05:17,659
today

130
00:05:17,699 --> 00:05:20,220
it is not the first time we speak about

131
00:05:20,220 --> 00:05:23,039
the Titan and chip in fact last year and

132
00:05:23,039 --> 00:05:24,960
like at Europe we presented the first

133
00:05:24,960 --> 00:05:27,660
stages of our research on this uh on

134
00:05:27,660 --> 00:05:29,520
this chip and it can be summarized as

135
00:05:29,520 --> 00:05:31,680
the following so the first thing we did

136
00:05:31,680 --> 00:05:33,720
was to reverse uh the VMware we

137
00:05:33,720 --> 00:05:36,600
identified the firmware file and the

138
00:05:36,600 --> 00:05:38,940
next thing was to in order to help us in

139
00:05:38,940 --> 00:05:41,940
this reverse step we wanted to interact

140
00:05:41,940 --> 00:05:43,380
with the chip

141
00:05:43,380 --> 00:05:46,680
and first of all on Audrey we

142
00:05:46,680 --> 00:05:48,360
implemented a Frida script in order to

143
00:05:48,360 --> 00:05:50,100
sniff all the communications going on so

144
00:05:50,100 --> 00:05:52,199
we hooked the citadeli demon and thanks

145
00:05:52,199 --> 00:05:53,580
to that we were able to seal the

146
00:05:53,580 --> 00:05:56,100
messages sent by the applications

147
00:05:56,100 --> 00:05:58,560
and we also implemented our tool that we

148
00:05:58,560 --> 00:06:00,539
call nose clients in order to send

149
00:06:00,539 --> 00:06:02,940
Customs custom commands to the chip

150
00:06:02,940 --> 00:06:06,180
now all tools only run on Android but

151
00:06:06,180 --> 00:06:07,440
there are some commands that will

152
00:06:07,440 --> 00:06:09,900
exchange uh between uh with the with the

153
00:06:09,900 --> 00:06:12,180
chip by them that are sent to the chip

154
00:06:12,180 --> 00:06:14,759
Sorry by the bootloader of the main CPU

155
00:06:14,759 --> 00:06:17,520
and in order to see what's going on we

156
00:06:17,520 --> 00:06:19,020
wanted to do the same things on the

157
00:06:19,020 --> 00:06:20,699
hardware level and this is the picture

158
00:06:20,699 --> 00:06:23,639
you see on the left uh it's probably the

159
00:06:23,639 --> 00:06:25,500
most impressive thing that we presented

160
00:06:25,500 --> 00:06:28,860
at this visually last year thanks to the

161
00:06:28,860 --> 00:06:30,479
Magic Hands of our colleague Philippe

162
00:06:30,479 --> 00:06:33,120
the one uh he was able to solve the

163
00:06:33,120 --> 00:06:35,759
ratio of the 64 pins

164
00:06:35,759 --> 00:06:38,699
of the chip onto a breaker board and

165
00:06:38,699 --> 00:06:42,120
then back to the the footprint uh on the

166
00:06:42,120 --> 00:06:44,520
on the smartphone and thanks to that we

167
00:06:44,520 --> 00:06:46,319
were able to uh interact with the chip

168
00:06:46,319 --> 00:06:48,479
from the hardware level

169
00:06:48,479 --> 00:06:51,539
the next thing we did was to find

170
00:06:51,539 --> 00:06:53,639
vulnerabilities and the most important

171
00:06:53,639 --> 00:06:57,300
one was a downgrade issue that allowed

172
00:06:57,300 --> 00:06:59,819
us to flash any old VMware

173
00:06:59,819 --> 00:07:01,860
and with a side effect that's all the

174
00:07:01,860 --> 00:07:03,300
debts I would be erased from the chip

175
00:07:03,300 --> 00:07:06,180
Now using this vulnerability uh we have

176
00:07:06,180 --> 00:07:08,699
been able to downgrade into an old

177
00:07:08,699 --> 00:07:11,520
VMware on which we discovered uh we

178
00:07:11,520 --> 00:07:13,139
notified that one day vulnerability that

179
00:07:13,139 --> 00:07:15,600
we then exploited that and it allowed us

180
00:07:15,600 --> 00:07:17,759
to execute God on the chip

181
00:07:17,759 --> 00:07:20,280
and in the end to leak values hidden

182
00:07:20,280 --> 00:07:21,599
parts of the firmware including the

183
00:07:21,599 --> 00:07:23,039
bootron

184
00:07:23,039 --> 00:07:26,060
now today we are going to speak about

185
00:07:26,060 --> 00:07:28,800
fuzzing and how it how useful it can be

186
00:07:28,800 --> 00:07:31,139
on this target even though it's quite

187
00:07:31,139 --> 00:07:32,940
constrained there is no uh we don't have

188
00:07:32,940 --> 00:07:34,860
the sources there are a lot of Hardware

189
00:07:34,860 --> 00:07:36,840
interactions but we can get interesting

190
00:07:36,840 --> 00:07:40,020
results so we will cover two approaches

191
00:07:40,020 --> 00:07:42,780
first of all the Black Box fuzzing uh in

192
00:07:42,780 --> 00:07:44,160
that case we don't have any idea of

193
00:07:44,160 --> 00:07:47,039
what's going on inside the chip

194
00:07:47,039 --> 00:07:49,020
and we will also cover the immigration

195
00:07:49,020 --> 00:07:51,900
based fuzzing where we have a lot more

196
00:07:51,900 --> 00:07:54,180
insight of what's going on yet we will

197
00:07:54,180 --> 00:07:55,979
need uh we will show you a few tricks to

198
00:07:55,979 --> 00:07:57,599
optimize the results

199
00:07:57,599 --> 00:08:00,360
so the next thing is that we will show

200
00:08:00,360 --> 00:08:02,460
you how we exploited without any

201
00:08:02,460 --> 00:08:04,440
debuggers or stack traces of neurability

202
00:08:04,440 --> 00:08:06,180
that we discovered and how thanks to

203
00:08:06,180 --> 00:08:09,360
this vulnerability we have been able to

204
00:08:09,360 --> 00:08:11,280
execute code on the Chip And to

205
00:08:11,280 --> 00:08:13,319
compromise one of the most important

206
00:08:13,319 --> 00:08:15,539
security property behind that behind

207
00:08:15,539 --> 00:08:17,160
that chip so I'm not going to let

208
00:08:17,160 --> 00:08:18,780
Damiano speak about the black box

209
00:08:18,780 --> 00:08:21,258
fuzzing

210
00:08:23,039 --> 00:08:27,539
okay so when starting to test the chip

211
00:08:27,539 --> 00:08:29,879
like that titanium one of the first

212
00:08:29,879 --> 00:08:33,240
steps that one can try to to make is

213
00:08:33,240 --> 00:08:36,479
start with black box fuzzing and here by

214
00:08:36,479 --> 00:08:39,360
Black Box we mean when we only have a

215
00:08:39,360 --> 00:08:41,219
very limited visibility on the Target

216
00:08:41,219 --> 00:08:43,919
that we want to test all we have all we

217
00:08:43,919 --> 00:08:46,620
need actually is just a channel uh to

218
00:08:46,620 --> 00:08:48,779
send messages to these targets and then

219
00:08:48,779 --> 00:08:51,180
a signal that tells us what happened so

220
00:08:51,180 --> 00:08:55,200
in our case this was given by the custom

221
00:08:55,200 --> 00:08:57,240
clients that we developed to communicate

222
00:08:57,240 --> 00:08:59,640
with the chip we could send arbitrary

223
00:08:59,640 --> 00:09:02,339
messages that we could mutate

224
00:09:02,339 --> 00:09:06,480
in the fuzzing in the fancy workflow and

225
00:09:06,480 --> 00:09:08,820
then get a return code back that would

226
00:09:08,820 --> 00:09:12,300
tell us what is the result of the

227
00:09:12,300 --> 00:09:13,980
processing of our message

228
00:09:13,980 --> 00:09:17,640
now the return codes are also in the

229
00:09:17,640 --> 00:09:20,360
AOSP and you can see them on this slide

230
00:09:20,360 --> 00:09:22,440
generally we are interested in those

231
00:09:22,440 --> 00:09:25,380
return codes uh return codes higher than

232
00:09:25,380 --> 00:09:28,320
on equal two with two being uh error

233
00:09:28,320 --> 00:09:30,660
internal this is for example the one we

234
00:09:30,660 --> 00:09:32,880
get when the chip crashes so

235
00:09:32,880 --> 00:09:37,380
we just uh implement this by uh plugging

236
00:09:37,380 --> 00:09:41,279
a mutator into our uh to our NOS client

237
00:09:41,279 --> 00:09:43,200
limitator is leave brought above mutator

238
00:09:43,200 --> 00:09:45,240
because we leverage the grammar that is

239
00:09:45,240 --> 00:09:46,620
available

240
00:09:46,620 --> 00:09:48,300
um it is actually fairly straightforward

241
00:09:48,300 --> 00:09:51,360
to use we start from an empty Corpus but

242
00:09:51,360 --> 00:09:54,779
we do try to set some fields that would

243
00:09:54,779 --> 00:09:58,620
make us pass certain checks to make sure

244
00:09:58,620 --> 00:10:01,440
that we can explore more States and then

245
00:10:01,440 --> 00:10:03,660
of course we keep the inputs that

246
00:10:03,660 --> 00:10:05,940
generate uh some interesting return

247
00:10:05,940 --> 00:10:07,680
codes

248
00:10:07,680 --> 00:10:10,800
now we did a first campaign on an old

249
00:10:10,800 --> 00:10:12,839
version of the filmer a filmer we knew

250
00:10:12,839 --> 00:10:14,640
had some vulnerabilities and we managed

251
00:10:14,640 --> 00:10:16,980
to discover a bunch of them one of them

252
00:10:16,980 --> 00:10:18,839
is actually the buffer overflow that we

253
00:10:18,839 --> 00:10:21,240
had exploited uh by rolling back the

254
00:10:21,240 --> 00:10:23,880
fumer so this kind of told us that the

255
00:10:23,880 --> 00:10:25,860
approach was working and we repeated the

256
00:10:25,860 --> 00:10:28,380
same proceed procedure at with the

257
00:10:28,380 --> 00:10:31,260
latest fumer at the time we found two

258
00:10:31,260 --> 00:10:33,000
commands that were leading to an Old

259
00:10:33,000 --> 00:10:35,700
Point at the reference that was making

260
00:10:35,700 --> 00:10:39,360
the cheap crash so we reported this

261
00:10:39,360 --> 00:10:42,060
vulnerability like the others and this

262
00:10:42,060 --> 00:10:44,160
one was not considered serious enough to

263
00:10:44,160 --> 00:10:47,279
end up in the security Bulletin

264
00:10:47,279 --> 00:10:49,140
the interesting part is that all these

265
00:10:49,140 --> 00:10:51,120
results come after just a few minutes of

266
00:10:51,120 --> 00:10:54,000
fuzzing so this is kind of suggesting

267
00:10:54,000 --> 00:10:55,740
that the approach is working we get the

268
00:10:55,740 --> 00:10:58,740
bugs so that's that's positive uh it is

269
00:10:58,740 --> 00:11:00,660
also as I said fairly easy to put in

270
00:11:00,660 --> 00:11:03,300
place and uh we are testing in the real

271
00:11:03,300 --> 00:11:07,079
device so what we get is uh is gonna be

272
00:11:07,079 --> 00:11:09,480
reproducible for sure but at the same

273
00:11:09,480 --> 00:11:11,880
time uh there is a very well known

274
00:11:11,880 --> 00:11:13,440
limitation when it comes to black box

275
00:11:13,440 --> 00:11:15,000
fuzzing that is that we are probably

276
00:11:15,000 --> 00:11:17,579
only exercising the shallow states of

277
00:11:17,579 --> 00:11:19,320
the targets

278
00:11:19,320 --> 00:11:22,200
um we also are prone to false positive

279
00:11:22,200 --> 00:11:25,440
with this uh return code heuristics that

280
00:11:25,440 --> 00:11:28,260
we that we implemented and detection is

281
00:11:28,260 --> 00:11:31,920
a quite complicated we only detect those

282
00:11:31,920 --> 00:11:35,579
bugs that produce a meaningful uh

283
00:11:35,579 --> 00:11:38,640
return code which is not always the case

284
00:11:38,640 --> 00:11:40,920
so the bottom line is really that it is

285
00:11:40,920 --> 00:11:42,899
hard to know what is going on on the

286
00:11:42,899 --> 00:11:46,260
target so that is when we wanted to move

287
00:11:46,260 --> 00:11:47,880
forward and try to explore a different

288
00:11:47,880 --> 00:11:49,560
approach to these emulation based

289
00:11:49,560 --> 00:11:50,700
fuzzing

290
00:11:50,700 --> 00:11:54,300
and this comes from uh the fact that we

291
00:11:54,300 --> 00:11:56,220
know how the firmware works we have been

292
00:11:56,220 --> 00:12:00,000
reversing it and we know also how to

293
00:12:00,000 --> 00:12:01,920
leak some parts of the memory when we

294
00:12:01,920 --> 00:12:03,660
need to do so thanks to the

295
00:12:03,660 --> 00:12:06,360
vulnerability we exploited by rolling

296
00:12:06,360 --> 00:12:09,060
back the firmware so we can put this

297
00:12:09,060 --> 00:12:11,220
together and emulate the firmware on our

298
00:12:11,220 --> 00:12:14,100
laptop this way we control what is being

299
00:12:14,100 --> 00:12:16,380
executed and we also have a very good

300
00:12:16,380 --> 00:12:20,100
feedback for a fuzzer if we want to do a

301
00:12:20,100 --> 00:12:22,380
coverage guided fuzzing

302
00:12:22,380 --> 00:12:25,920
so to emulate uh the firmware we have of

303
00:12:25,920 --> 00:12:27,959
course many different uh Frameworks out

304
00:12:27,959 --> 00:12:30,180
there uh in the end we decided to use

305
00:12:30,180 --> 00:12:33,720
unicorn this is a firmware that is this

306
00:12:33,720 --> 00:12:35,459
is a framework that is built on top of

307
00:12:35,459 --> 00:12:37,800
qimo and it allows to emulate only the

308
00:12:37,800 --> 00:12:40,100
CPU without caring about full system

309
00:12:40,100 --> 00:12:43,440
emulation which is something we actually

310
00:12:43,440 --> 00:12:46,019
wanted so we can actually set it up

311
00:12:46,019 --> 00:12:49,079
fairly easily and tweak it uh to try to

312
00:12:49,079 --> 00:12:51,720
detect more bugs and also a very

313
00:12:51,720 --> 00:12:54,360
interesting feature of unicorn is that

314
00:12:54,360 --> 00:12:56,459
it integrates very well with AFL plus

315
00:12:56,459 --> 00:12:58,980
plus and I'm sure most of the audience

316
00:12:58,980 --> 00:13:01,079
will be familiar with it AFL plus plus

317
00:13:01,079 --> 00:13:02,880
has this unicorn mode that basically

318
00:13:02,880 --> 00:13:05,160
allows you to fuzz anything that you can

319
00:13:05,160 --> 00:13:08,279
that you can emulate with unicorn you

320
00:13:08,279 --> 00:13:10,940
only need to take care about riding your

321
00:13:10,940 --> 00:13:13,560
writing your input somewhere in the

322
00:13:13,560 --> 00:13:16,260
memory of the uh of your emulation

323
00:13:16,260 --> 00:13:18,120
script and then you will get the

324
00:13:18,120 --> 00:13:21,139
classical AFL experience there is also

325
00:13:21,139 --> 00:13:23,579
allowing for example to use custom

326
00:13:23,579 --> 00:13:26,279
mutators which is something we we used

327
00:13:26,279 --> 00:13:28,320
extensively

328
00:13:28,320 --> 00:13:30,180
another nice property about

329
00:13:30,180 --> 00:13:31,860
emulation-based fuzzing is that you can

330
00:13:31,860 --> 00:13:34,139
fast anything you want all you need is

331
00:13:34,139 --> 00:13:36,079
an entry point

332
00:13:36,079 --> 00:13:38,399
some properties that you want to set

333
00:13:38,399 --> 00:13:40,380
such as the value of the registers and

334
00:13:40,380 --> 00:13:42,420
the memory mappings and then a point

335
00:13:42,420 --> 00:13:45,680
where you want to exit your execution so

336
00:13:45,680 --> 00:13:48,660
this is this gives a lot of freedom at

337
00:13:48,660 --> 00:13:50,399
the same time we of course need to take

338
00:13:50,399 --> 00:13:52,680
into account that we want to keep it

339
00:13:52,680 --> 00:13:55,079
consistent with the surface that an

340
00:13:55,079 --> 00:13:57,240
attacker is actually able to reach

341
00:13:57,240 --> 00:13:59,399
but one attack surface that is exposed

342
00:13:59,399 --> 00:14:01,680
that we hadn't explored earlier is the

343
00:14:01,680 --> 00:14:03,899
SPI rescue feature so this is a feature

344
00:14:03,899 --> 00:14:06,839
that allows to flash a new firmware by

345
00:14:06,839 --> 00:14:10,200
uh sending a new firmware in this

346
00:14:10,200 --> 00:14:11,760
specific format that you see on the

347
00:14:11,760 --> 00:14:13,260
slide

348
00:14:13,260 --> 00:14:15,899
um this is done through the bootloader

349
00:14:15,899 --> 00:14:19,440
and uh the user data on the chip are

350
00:14:19,440 --> 00:14:21,180
going to be wiped

351
00:14:21,180 --> 00:14:23,399
um so since this is a fairly interesting

352
00:14:23,399 --> 00:14:25,260
format we wanted to check whether this

353
00:14:25,260 --> 00:14:26,420
was actually

354
00:14:26,420 --> 00:14:28,800
processed correctly so we fast the

355
00:14:28,800 --> 00:14:32,339
header of this feature on the firmware

356
00:14:32,339 --> 00:14:35,040
um and the way we did it was using as I

357
00:14:35,040 --> 00:14:37,560
anticipated a custom mutator we used

358
00:14:37,560 --> 00:14:40,220
format fuzzer in this case there is a

359
00:14:40,220 --> 00:14:43,320
project that allows to generate and

360
00:14:43,320 --> 00:14:45,839
parse binary files following a specific

361
00:14:45,839 --> 00:14:47,399
format

362
00:14:47,399 --> 00:14:49,440
um and that runs with a modified version

363
00:14:49,440 --> 00:14:51,300
of AFL

364
00:14:51,300 --> 00:14:54,420
now uh unfortunately unfortunately we

365
00:14:54,420 --> 00:14:56,279
couldn't really find any interesting

366
00:14:56,279 --> 00:15:00,060
bugs in this campaign but still having

367
00:15:00,060 --> 00:15:02,220
to build an emulation script for this

368
00:15:02,220 --> 00:15:05,519
feature uh kind of got us to a next

369
00:15:05,519 --> 00:15:07,740
level of reverse engineering and we

370
00:15:07,740 --> 00:15:09,959
discovered some things that at least

371
00:15:09,959 --> 00:15:12,360
myself I wasn't able to understand with

372
00:15:12,360 --> 00:15:14,339
simple static reversing when you need to

373
00:15:14,339 --> 00:15:16,980
sort out how to make it work you kind of

374
00:15:16,980 --> 00:15:20,279
get a little bit further so one example

375
00:15:20,279 --> 00:15:23,399
is that the bytes in the hash the zero

376
00:15:23,399 --> 00:15:26,940
bytes get replaced with one and this is

377
00:15:26,940 --> 00:15:29,100
something that was just interesting to

378
00:15:29,100 --> 00:15:30,720
discover in the process

379
00:15:30,720 --> 00:15:32,639
but then we wanted to go back to the

380
00:15:32,639 --> 00:15:35,579
tasks so repeat the same uh campaign but

381
00:15:35,579 --> 00:15:36,839
using a

382
00:15:36,839 --> 00:15:40,139
uh using emulation this time so again we

383
00:15:40,139 --> 00:15:42,779
base ourselves on librato Buff mutator

384
00:15:42,779 --> 00:15:45,000
and we focus mostly on three tasks

385
00:15:45,000 --> 00:15:47,160
actually two identity and Key Master

386
00:15:47,160 --> 00:15:49,620
there's also Weaver but it is fairly

387
00:15:49,620 --> 00:15:52,680
simple and there isn't really much uh to

388
00:15:52,680 --> 00:15:54,480
explore there at least from a fuzzing

389
00:15:54,480 --> 00:15:57,240
perspective so the first question is can

390
00:15:57,240 --> 00:15:58,980
we actually find the same bugs we know

391
00:15:58,980 --> 00:16:00,720
about otherwise we're not really making

392
00:16:00,720 --> 00:16:04,079
any progress and the answer is yes but

393
00:16:04,079 --> 00:16:06,660
apart from one which will actually bring

394
00:16:06,660 --> 00:16:09,300
me to the limitations of this approach

395
00:16:09,300 --> 00:16:12,540
because as we know there is never a free

396
00:16:12,540 --> 00:16:14,880
lunch in this case emulation has always

397
00:16:14,880 --> 00:16:16,980
the problem of

398
00:16:16,980 --> 00:16:19,139
um are the dependent code that you

399
00:16:19,139 --> 00:16:21,660
really don't know how to emulate the way

400
00:16:21,660 --> 00:16:23,519
we did it was just hooking those

401
00:16:23,519 --> 00:16:26,160
functions that we knew were not uh

402
00:16:26,160 --> 00:16:29,779
possible to actually emulate

403
00:16:29,779 --> 00:16:33,060
also in this case detection is still not

404
00:16:33,060 --> 00:16:35,459
perfect because we only detect a bug

405
00:16:35,459 --> 00:16:38,820
when unicorn crashes but if there is

406
00:16:38,820 --> 00:16:41,279
enough by one or a corruption in this in

407
00:16:41,279 --> 00:16:43,560
a page that is already mapped we're not

408
00:16:43,560 --> 00:16:46,199
really able to detect that and then no

409
00:16:46,199 --> 00:16:47,699
full system emulation this was our

410
00:16:47,699 --> 00:16:49,740
choice but of course no full system

411
00:16:49,740 --> 00:16:51,540
navigation you don't get those bugs that

412
00:16:51,540 --> 00:16:54,660
entail for example the scheduler this is

413
00:16:54,660 --> 00:16:56,699
the reason why we didn't manage to find

414
00:16:56,699 --> 00:16:59,639
again that one bug that I mentioned

415
00:16:59,639 --> 00:17:02,399
but really what is uh nice about this

416
00:17:02,399 --> 00:17:03,899
approach is that you can tweak it a lot

417
00:17:03,899 --> 00:17:06,780
you can uh come up with heuristics and

418
00:17:06,780 --> 00:17:09,419
hooks that try to look for specific

419
00:17:09,419 --> 00:17:12,179
patterns of uh things that you know are

420
00:17:12,179 --> 00:17:14,579
not supposed to happen we have been for

421
00:17:14,579 --> 00:17:17,040
example checking for mem copies that end

422
00:17:17,040 --> 00:17:18,959
up reading from the boot ROM that is

423
00:17:18,959 --> 00:17:21,480
mapped at the address zero this was a

424
00:17:21,480 --> 00:17:23,760
pattern for some bugs that we kind of

425
00:17:23,760 --> 00:17:27,059
wanted to double check and this was

426
00:17:27,059 --> 00:17:30,299
possible with a custom hook but at some

427
00:17:30,299 --> 00:17:32,760
point there is a trade-off between how

428
00:17:32,760 --> 00:17:34,880
much a reverse engineer and come up with

429
00:17:34,880 --> 00:17:38,100
these tweaks and how much you finally

430
00:17:38,100 --> 00:17:40,919
let your father run

431
00:17:40,919 --> 00:17:44,160
but what uh we are presenting today is

432
00:17:44,160 --> 00:17:46,140
also one specific vulnerability that we

433
00:17:46,140 --> 00:17:49,860
found and uh this is a vulnerability in

434
00:17:49,860 --> 00:17:50,760
uh

435
00:17:50,760 --> 00:17:52,559
uh the function a function called param

436
00:17:52,559 --> 00:17:55,020
find digest internal this is a function

437
00:17:55,020 --> 00:17:58,020
that parses key parameter objects inside

438
00:17:58,020 --> 00:18:01,260
the requests and specifically this is an

439
00:18:01,260 --> 00:18:03,960
out of binds bounce right of exactly one

440
00:18:03,960 --> 00:18:08,760
byte that is set to exactly one so uh

441
00:18:08,760 --> 00:18:10,620
the first time I bumped into this I

442
00:18:10,620 --> 00:18:12,539
thought okay this is probably a minor

443
00:18:12,539 --> 00:18:15,299
issue no way to exploit it but let me

444
00:18:15,299 --> 00:18:18,000
walk you through it so here you see the

445
00:18:18,000 --> 00:18:20,280
assembly and the compiled view of the of

446
00:18:20,280 --> 00:18:22,500
the function and this is the vulnerable

447
00:18:22,500 --> 00:18:24,840
instruction store byte so one byte

448
00:18:24,840 --> 00:18:25,980
instruction

449
00:18:25,980 --> 00:18:28,679
uh but there are some checks actually a

450
00:18:28,679 --> 00:18:30,299
lot of checks on the offset so let's

451
00:18:30,299 --> 00:18:33,960
start from a 32-bit value uh the

452
00:18:33,960 --> 00:18:37,140
actually we only care about the least

453
00:18:37,140 --> 00:18:39,600
significant byte because of a mask that

454
00:18:39,600 --> 00:18:42,120
is applied this is actually uh

455
00:18:42,120 --> 00:18:45,059
interesting for us but that one byte has

456
00:18:45,059 --> 00:18:47,160
to go through a lot of checks so first

457
00:18:47,160 --> 00:18:49,020
of all it needs to be smaller than or

458
00:18:49,020 --> 00:18:52,020
equal four so we kind of lose all those

459
00:18:52,020 --> 00:18:54,120
bits and then there is a little bit of a

460
00:18:54,120 --> 00:18:56,880
complicated bitwise operation which just

461
00:18:56,880 --> 00:18:59,400
bear with me for now if we put

462
00:18:59,400 --> 00:19:00,780
everything together the list is

463
00:19:00,780 --> 00:19:04,200
significant byte can only be 0 2 or 4

464
00:19:04,200 --> 00:19:08,160
out of the 255 possible values

465
00:19:08,160 --> 00:19:11,039
so what can we do

466
00:19:11,039 --> 00:19:13,200
um there are actually multiple ways to

467
00:19:13,200 --> 00:19:15,539
get to this snippet of code as I told

468
00:19:15,539 --> 00:19:17,940
you it's a function that processes this

469
00:19:17,940 --> 00:19:19,740
type of uh of

470
00:19:19,740 --> 00:19:22,080
um field in different messages

471
00:19:22,080 --> 00:19:24,960
and also don't forget the Titan M has a

472
00:19:24,960 --> 00:19:26,940
static memory layout objects are always

473
00:19:26,940 --> 00:19:29,880
at the same place so if we can write

474
00:19:29,880 --> 00:19:32,220
that one byte at the right place we

475
00:19:32,220 --> 00:19:33,660
might be able to to get something

476
00:19:33,660 --> 00:19:35,460
interesting you know from a simple

477
00:19:35,460 --> 00:19:37,500
denial of surface to perhaps changing

478
00:19:37,500 --> 00:19:40,080
some field that gives us a corruption

479
00:19:40,080 --> 00:19:43,679
elsewhere there is a lot that we can do

480
00:19:43,679 --> 00:19:47,039
so what we did was we generated all the

481
00:19:47,039 --> 00:19:49,740
possible addresses we could reach uh and

482
00:19:49,740 --> 00:19:52,559
then we tried to look one one by one and

483
00:19:52,559 --> 00:19:54,480
see what we could do with them

484
00:19:54,480 --> 00:19:56,940
and we arrive at the point where we

485
00:19:56,940 --> 00:19:58,679
understood that there was this structure

486
00:19:58,679 --> 00:20:00,720
in memory we called it Key Master SPI

487
00:20:00,720 --> 00:20:03,720
data and we could overwrite one byte in

488
00:20:03,720 --> 00:20:06,660
a field that we called a request address

489
00:20:06,660 --> 00:20:09,780
command request address so this is a a

490
00:20:09,780 --> 00:20:13,200
structure that is meant to hold data

491
00:20:13,200 --> 00:20:15,660
about the SPI exchanges for the key

492
00:20:15,660 --> 00:20:18,419
master task specifically there's one for

493
00:20:18,419 --> 00:20:19,440
each task

494
00:20:19,440 --> 00:20:22,520
and the actual field that we are

495
00:20:22,520 --> 00:20:26,000
overwriting is the one that is uh

496
00:20:26,000 --> 00:20:28,440
expressing the address where Key Master

497
00:20:28,440 --> 00:20:32,340
messages will end up being stored so as

498
00:20:32,340 --> 00:20:36,539
you can see uh from 192 C8 we go to one

499
00:20:36,539 --> 00:20:39,720
zero one C8 so now requests will be

500
00:20:39,720 --> 00:20:41,700
stored quite far from where they're

501
00:20:41,700 --> 00:20:44,760
supposed to be and this was the

502
00:20:44,760 --> 00:20:47,340
beginning of the fun part but first

503
00:20:47,340 --> 00:20:50,220
don't forget that all we have to

504
00:20:50,220 --> 00:20:52,980
communicate with this titanium chip is

505
00:20:52,980 --> 00:20:56,280
our NOS client so all we can do is

506
00:20:56,280 --> 00:20:58,260
Force the message the way we like it

507
00:20:58,260 --> 00:21:01,559
send it through our binary and then get

508
00:21:01,559 --> 00:21:04,620
the return code perhaps retro code 2 if

509
00:21:04,620 --> 00:21:07,140
the chip crashes but not much so as you

510
00:21:07,140 --> 00:21:09,480
can imagine developing and debugging an

511
00:21:09,480 --> 00:21:12,000
exploit is quite of a challenge but

512
00:21:12,000 --> 00:21:14,100
there's a is there's an ace we have been

513
00:21:14,100 --> 00:21:16,740
keeping in our holes so far Max briefly

514
00:21:16,740 --> 00:21:19,559
mentioned this u-word that we could uh

515
00:21:19,559 --> 00:21:22,679
access and this is specifically uh

516
00:21:22,679 --> 00:21:25,260
thanks to two pins that are Exposed on

517
00:21:25,260 --> 00:21:28,380
the motherboard so we soldered two wires

518
00:21:28,380 --> 00:21:30,720
into those pins and we ended up getting

519
00:21:30,720 --> 00:21:34,140
this uart console that is actually

520
00:21:34,140 --> 00:21:36,419
fairly simple and you cannot really do

521
00:21:36,419 --> 00:21:39,120
much apart from asking to the chief

522
00:21:39,120 --> 00:21:41,280
about versions and statistics and stuff

523
00:21:41,280 --> 00:21:43,799
like that but it is the place where the

524
00:21:43,799 --> 00:21:46,620
logs of the chip are printed so although

525
00:21:46,620 --> 00:21:48,840
this doesn't provide any information on

526
00:21:48,840 --> 00:21:51,000
what goes wrong when something doesn't

527
00:21:51,000 --> 00:21:53,460
work this is very useful when writing an

528
00:21:53,460 --> 00:21:55,500
exploit because we can always try to

529
00:21:55,500 --> 00:21:58,080
trigger some logs and see if we can

530
00:21:58,080 --> 00:22:01,260
actually get them on the uart

531
00:22:01,260 --> 00:22:04,020
so I'm not gonna go uh sadly there's no

532
00:22:04,020 --> 00:22:06,240
time to go over the memory layout of the

533
00:22:06,240 --> 00:22:10,440
titanium chip so we just want to write

534
00:22:10,440 --> 00:22:12,840
our requests to the new address and

535
00:22:12,840 --> 00:22:15,600
basically see uh see what happens so we

536
00:22:15,600 --> 00:22:18,120
send bigger and bigger payloads while

537
00:22:18,120 --> 00:22:21,299
monitoring the uart okay so we send

538
00:22:21,299 --> 00:22:23,460
bigger bigger impedance and some at some

539
00:22:23,460 --> 00:22:25,380
point we realize that the chip starts

540
00:22:25,380 --> 00:22:27,179
crashing

541
00:22:27,179 --> 00:22:29,940
um so what if we place actually a

542
00:22:29,940 --> 00:22:33,299
function that logs uh the tasks right at

543
00:22:33,299 --> 00:22:34,980
this point where the chip starts

544
00:22:34,980 --> 00:22:37,320
crashing and what we get is actually the

545
00:22:37,320 --> 00:22:39,780
logs on the uart that tells us that we

546
00:22:39,780 --> 00:22:42,179
are triggering a function we are getting

547
00:22:42,179 --> 00:22:45,059
uh code execution

548
00:22:45,059 --> 00:22:48,299
so what's going on probably this is our

549
00:22:48,299 --> 00:22:50,159
guess at least is that this is an

550
00:22:50,159 --> 00:22:52,100
address that was pushed into the stack

551
00:22:52,100 --> 00:22:55,860
by some task that is maybe maybe has to

552
00:22:55,860 --> 00:22:59,520
return there after its execution and uh

553
00:22:59,520 --> 00:23:03,299
from now on things get quite complex to

554
00:23:03,299 --> 00:23:07,500
actually get a an exploit working uh we

555
00:23:07,500 --> 00:23:09,840
need to move uh elsewhere because we

556
00:23:09,840 --> 00:23:13,080
cannot write any blockchain there it's

557
00:23:13,080 --> 00:23:15,419
it's quite uh quite cumbersome but we

558
00:23:15,419 --> 00:23:18,000
are actually releasing a blog post where

559
00:23:18,000 --> 00:23:20,220
we go over also the exploitation details

560
00:23:20,220 --> 00:23:22,320
of this vulnerability

561
00:23:22,320 --> 00:23:24,299
but now I'm gonna hand it over to Max

562
00:23:24,299 --> 00:23:28,620
for the impact that we achieved

563
00:23:28,620 --> 00:23:31,399
thank you Daniel

564
00:23:32,340 --> 00:23:34,020
so let's look at the impact of this

565
00:23:34,020 --> 00:23:36,120
vulnerability not only on the chip

566
00:23:36,120 --> 00:23:38,360
itself but on the whole system security

567
00:23:38,360 --> 00:23:40,740
uh something that would be great for us

568
00:23:40,740 --> 00:23:42,600
would be to find a memory region that is

569
00:23:42,600 --> 00:23:44,580
both writable and executable so we can

570
00:23:44,580 --> 00:23:46,980
write on our code but there is no such

571
00:23:46,980 --> 00:23:49,020
regions so then another thing we could

572
00:23:49,020 --> 00:23:51,840
try would be to reconfigure this memory

573
00:23:51,840 --> 00:23:55,020
uh permissions by playing with something

574
00:23:55,020 --> 00:23:57,360
called the mpus for memory protection

575
00:23:57,360 --> 00:24:01,679
units but on Titan name this mpu has a

576
00:24:01,679 --> 00:24:03,600
custom interface and that we did not

577
00:24:03,600 --> 00:24:06,960
spend enough time to reverse it so what

578
00:24:06,960 --> 00:24:09,179
we can do is to reuse the code that is

579
00:24:09,179 --> 00:24:10,679
already present in the VMware like

580
00:24:10,679 --> 00:24:13,260
making Rob change like Damiano explained

581
00:24:13,260 --> 00:24:16,200
and doing so we implemented again a leak

582
00:24:16,200 --> 00:24:18,840
command in our nose client tool this

583
00:24:18,840 --> 00:24:20,400
time based on the zero day we just

584
00:24:20,400 --> 00:24:23,580
presented so since we did not downgrade

585
00:24:23,580 --> 00:24:25,380
the VMware this time the data is not

586
00:24:25,380 --> 00:24:27,299
erased meaning that we can leak all the

587
00:24:27,299 --> 00:24:29,880
secrets present in the Chip's memory

588
00:24:29,880 --> 00:24:33,120
and uh the the command you see below

589
00:24:33,120 --> 00:24:34,500
um the lead command so is the one I'm

590
00:24:34,500 --> 00:24:37,140
speaking about here we are leaking this

591
00:24:37,140 --> 00:24:39,179
first 16 bytes that's all present at the

592
00:24:39,179 --> 00:24:41,220
address 0 and at the address zero uh you

593
00:24:41,220 --> 00:24:42,720
have the bootron so you see the first

594
00:24:42,720 --> 00:24:44,820
bytes of the bootron but can we do

595
00:24:44,820 --> 00:24:46,380
something more harmful with this

596
00:24:46,380 --> 00:24:49,559
vulnerability uh more harmful on this on

597
00:24:49,559 --> 00:24:52,980
the device can we leak strong box keys

598
00:24:52,980 --> 00:24:54,720
but before I answer that question let's

599
00:24:54,720 --> 00:24:56,360
first have a look at what is strongbox

600
00:24:56,360 --> 00:24:59,039
so it's the hardware back version of the

601
00:24:59,039 --> 00:25:01,500
Keystone and it allows applications to

602
00:25:01,500 --> 00:25:05,100
generate and use uh keys from within a

603
00:25:05,100 --> 00:25:06,780
safe environment meaning the Titan M

604
00:25:06,780 --> 00:25:09,059
chip but the Titan M does not store any

605
00:25:09,059 --> 00:25:11,580
Keys instead the keys are stored in

606
00:25:11,580 --> 00:25:13,559
object called key blobs that are

607
00:25:13,559 --> 00:25:16,740
encrypted inside the Titan and using a

608
00:25:16,740 --> 00:25:19,200
key encryption key that will is

609
00:25:19,200 --> 00:25:22,080
generated from several internal elements

610
00:25:22,080 --> 00:25:24,179
now these key blobs are then installed

611
00:25:24,179 --> 00:25:27,419
encrypted in the Android file system so

612
00:25:27,419 --> 00:25:29,220
whenever an application wants to use a

613
00:25:29,220 --> 00:25:32,279
key from strongbox it has the system to

614
00:25:32,279 --> 00:25:34,200
send the key blob to the chip the chip

615
00:25:34,200 --> 00:25:36,179
will decrypt the key blob and use the

616
00:25:36,179 --> 00:25:37,980
key to perform the operation

617
00:25:37,980 --> 00:25:39,659
so it's important it's interesting to

618
00:25:39,659 --> 00:25:43,020
note that as long as the root user can I

619
00:25:43,020 --> 00:25:44,760
mean as long as the user so root can

620
00:25:44,760 --> 00:25:46,380
access all the key blobs that's all

621
00:25:46,380 --> 00:25:48,659
present in Android file system so it can

622
00:25:48,659 --> 00:25:50,460
use any key but it should never be able

623
00:25:50,460 --> 00:25:54,600
to extract uh the the keys

624
00:25:54,600 --> 00:25:57,179
now something that we would be

625
00:25:57,179 --> 00:25:58,679
interesting for us to do would be to

626
00:25:58,679 --> 00:26:00,900
leak the the several elements that are

627
00:26:00,900 --> 00:26:02,760
used to derive the these key encryption

628
00:26:02,760 --> 00:26:04,500
keys but

629
00:26:04,500 --> 00:26:06,840
in short there is one element that is

630
00:26:06,840 --> 00:26:09,059
stored in a memory region that cannot be

631
00:26:09,059 --> 00:26:11,460
read from the OS so it's not the way to

632
00:26:11,460 --> 00:26:13,740
go to League strong boxes instead let's

633
00:26:13,740 --> 00:26:16,799
have a look to uh the the commands that

634
00:26:16,799 --> 00:26:19,500
are used to actually use these key blobs

635
00:26:19,500 --> 00:26:22,380
and uh to perform crypto operation so

636
00:26:22,380 --> 00:26:24,600
the First Command and the one that is

637
00:26:24,600 --> 00:26:25,980
interesting for us right now is begin

638
00:26:25,980 --> 00:26:28,620
operation it contains

639
00:26:28,620 --> 00:26:30,900
um the key blob and the characteristic

640
00:26:30,900 --> 00:26:33,960
characteristics of the key meaning the

641
00:26:33,960 --> 00:26:35,820
algorithm the the key size and

642
00:26:35,820 --> 00:26:37,980
informations like this and whenever the

643
00:26:37,980 --> 00:26:39,779
chip receives it it will decrypt the key

644
00:26:39,779 --> 00:26:41,039
blob and then

645
00:26:41,039 --> 00:26:44,580
save the decrypted data somewhere at a

646
00:26:44,580 --> 00:26:46,260
fixed address for later

647
00:26:46,260 --> 00:26:47,820
so by now we should see where we are

648
00:26:47,820 --> 00:26:49,440
going the two other commands are not

649
00:26:49,440 --> 00:26:52,380
really interesting uh for us but in

650
00:26:52,380 --> 00:26:54,900
short they allow the system and the chip

651
00:26:54,900 --> 00:26:56,940
to perform the operation and the data

652
00:26:56,940 --> 00:26:59,279
that it contains

653
00:26:59,279 --> 00:27:01,799
so our strategy is simple first of all

654
00:27:01,799 --> 00:27:04,740
we get the key blobs the key blob from

655
00:27:04,740 --> 00:27:06,000
the device they're all stored in a

656
00:27:06,000 --> 00:27:08,340
database inside the Keystone directory

657
00:27:08,340 --> 00:27:10,860
at least starting from Android 12 then

658
00:27:10,860 --> 00:27:12,900
we Forge a begin operation request with

659
00:27:12,900 --> 00:27:13,799
it

660
00:27:13,799 --> 00:27:15,659
we send it to the chip the chip will

661
00:27:15,659 --> 00:27:17,820
decrypt it and then we use our

662
00:27:17,820 --> 00:27:21,179
vulnerability to leak this decrypted key

663
00:27:21,179 --> 00:27:24,059
from the chip memory so now time for a

664
00:27:24,059 --> 00:27:28,639
live demo and I will call Damiano

665
00:27:28,679 --> 00:27:32,659
to help me with this so

666
00:27:35,159 --> 00:27:37,860
here you should see our demo application

667
00:27:37,860 --> 00:27:43,500
running on the pixel 3A device that uh

668
00:27:43,500 --> 00:27:44,820
what

669
00:27:44,820 --> 00:27:48,659
that runs the vulnerable version so let

670
00:27:48,659 --> 00:27:50,039
me just

671
00:27:50,039 --> 00:27:52,520
first

672
00:27:53,460 --> 00:27:56,520
okay so whenever I'm going to enter a

673
00:27:56,520 --> 00:27:58,980
secret in this application

674
00:27:58,980 --> 00:28:00,980
um

675
00:28:01,440 --> 00:28:03,120
the the application will generate a

676
00:28:03,120 --> 00:28:05,279
strong box key and then encrypt it with

677
00:28:05,279 --> 00:28:06,600
it

678
00:28:06,600 --> 00:28:08,520
so it will then print the ciphertext as

679
00:28:08,520 --> 00:28:10,200
you can see both on the screen and on

680
00:28:10,200 --> 00:28:12,360
the log so we have the IV and the

681
00:28:12,360 --> 00:28:16,020
ciphertext the next thing we do is that

682
00:28:16,020 --> 00:28:18,480
we will uh before we use our

683
00:28:18,480 --> 00:28:21,440
vulnerability so

684
00:28:22,980 --> 00:28:25,380
here are the First Command I'm using

685
00:28:25,380 --> 00:28:27,360
well first of all there is an extra step

686
00:28:27,360 --> 00:28:30,240
I need to stop the set of the demon

687
00:28:30,240 --> 00:28:32,039
because it's kind of locking the

688
00:28:32,039 --> 00:28:34,320
communication with the driver and our

689
00:28:34,320 --> 00:28:36,840
tool is uh

690
00:28:36,840 --> 00:28:38,520
it will communicate directly with the

691
00:28:38,520 --> 00:28:40,559
driver here we go

692
00:28:40,559 --> 00:28:42,779
so

693
00:28:42,779 --> 00:28:45,720
now I'm using the leak KB command that

694
00:28:45,720 --> 00:28:47,279
we implemented and this command will

695
00:28:47,279 --> 00:28:49,679
simply list the key blobs available so

696
00:28:49,679 --> 00:28:51,960
stored in strongbox from the database so

697
00:28:51,960 --> 00:28:53,400
we see there is only one the one

698
00:28:53,400 --> 00:28:55,260
corresponding to our demo app

699
00:28:55,260 --> 00:28:58,020
so the next thing is that's

700
00:28:58,020 --> 00:29:01,158
we will lick it

701
00:29:10,140 --> 00:29:12,840
hopefully it will work

702
00:29:12,840 --> 00:29:15,120
yeah so the bytes you see or the bytes

703
00:29:15,120 --> 00:29:16,440
uh

704
00:29:16,440 --> 00:29:18,840
of the key of the AES key that have been

705
00:29:18,840 --> 00:29:21,240
used during activity secrets so the next

706
00:29:21,240 --> 00:29:23,820
thing is that we will simply convert

707
00:29:23,820 --> 00:29:26,340
these values into a format accepted by

708
00:29:26,340 --> 00:29:29,340
open SSL because we will use open SSL to

709
00:29:29,340 --> 00:29:31,080
uh

710
00:29:31,080 --> 00:29:35,279
to decrypt this ciphertext

711
00:29:35,580 --> 00:29:36,960
so

712
00:29:36,960 --> 00:29:38,940
I will do some copy pasting from my

713
00:29:38,940 --> 00:29:40,500
cheat sheet because I do not recommend

714
00:29:40,500 --> 00:29:41,820
buy heart

715
00:29:41,820 --> 00:29:43,980
oops

716
00:29:43,980 --> 00:29:46,580
yes

717
00:29:47,580 --> 00:29:49,620
I will just remove the spaces from the

718
00:29:49,620 --> 00:29:51,840
key because otherwise open SSL won't be

719
00:29:51,840 --> 00:29:54,678
happy about it

720
00:29:58,679 --> 00:30:00,299
okay

721
00:30:00,299 --> 00:30:01,799
so now

722
00:30:01,799 --> 00:30:04,740
I'll just give this ciphertext to open

723
00:30:04,740 --> 00:30:07,279
SSL

724
00:30:16,740 --> 00:30:20,539
okay I can provide the IV

725
00:30:22,500 --> 00:30:25,399
and then the key

726
00:30:27,360 --> 00:30:30,179
great so here we go we decrypted our

727
00:30:30,179 --> 00:30:31,300
secret

728
00:30:31,300 --> 00:30:35,550
[Applause]

729
00:30:38,220 --> 00:30:39,899
thanks

730
00:30:39,899 --> 00:30:43,620
so noted for the video okay so before

731
00:30:43,620 --> 00:30:45,179
being able to put in place this attack

732
00:30:45,179 --> 00:30:46,980
there are few conditions that you must

733
00:30:46,980 --> 00:30:49,260
be followed so

734
00:30:49,260 --> 00:30:52,020
um first of all we need to be able to

735
00:30:52,020 --> 00:30:53,760
talk to the chief so in our case we

736
00:30:53,760 --> 00:30:55,679
rooted our device so it's fine but in in

737
00:30:55,679 --> 00:30:57,240
the real life you need other abilities

738
00:30:57,240 --> 00:30:59,880
of course to uh to get to that point and

739
00:30:59,880 --> 00:31:02,399
the other thing you can try uh is to do

740
00:31:02,399 --> 00:31:05,100
a to to interact directly on the

741
00:31:05,100 --> 00:31:06,779
hardware level with the SBI boss like

742
00:31:06,779 --> 00:31:08,520
remember the picture I show at the

743
00:31:08,520 --> 00:31:11,340
beginning uh of this presentation the

744
00:31:11,340 --> 00:31:14,640
next condition is to access the key blob

745
00:31:14,640 --> 00:31:16,260
so here again you need to have enough

746
00:31:16,260 --> 00:31:18,960
privilege to to read the database or you

747
00:31:18,960 --> 00:31:20,700
can find a way to bypass the the file

748
00:31:20,700 --> 00:31:22,440
based encryption which may sound even

749
00:31:22,440 --> 00:31:25,020
harder so this is just two highlights

750
00:31:25,020 --> 00:31:27,000
that before being able to put in places

751
00:31:27,000 --> 00:31:29,760
attack their field extra steps that must

752
00:31:29,760 --> 00:31:31,380
be followed in real life so other

753
00:31:31,380 --> 00:31:34,140
vulnerabilities to be exploited

754
00:31:34,140 --> 00:31:36,179
now we wanted to show you this

755
00:31:36,179 --> 00:31:39,679
mitigation whenever uh whenever

756
00:31:39,679 --> 00:31:41,820
implementing an application and whenever

757
00:31:41,820 --> 00:31:44,580
declaring all the parameters to use a

758
00:31:44,580 --> 00:31:47,039
strong box key it's possible to add this

759
00:31:47,039 --> 00:31:49,860
uh dislike that we highlighted set user

760
00:31:49,860 --> 00:31:52,679
authentication required and why is that

761
00:31:52,679 --> 00:31:54,720
too true the the key blob will be

762
00:31:54,720 --> 00:31:56,460
encrypted a second time with the value

763
00:31:56,460 --> 00:31:58,679
derived from the

764
00:31:58,679 --> 00:32:00,360
from the user password

765
00:32:00,360 --> 00:32:02,460
so whenever the user whenever the

766
00:32:02,460 --> 00:32:04,320
application will try to use this kid lob

767
00:32:04,320 --> 00:32:06,539
the user will be asked to enter its

768
00:32:06,539 --> 00:32:08,399
password so

769
00:32:08,399 --> 00:32:10,679
and of course the best mitigation is to

770
00:32:10,679 --> 00:32:13,500
update the VMware since we uh we

771
00:32:13,500 --> 00:32:15,480
reported this vulnerability to Google

772
00:32:15,480 --> 00:32:17,640
and it's not fixed

773
00:32:17,640 --> 00:32:20,220
so now it's time for a conclusion

774
00:32:20,220 --> 00:32:23,640
and with some takeaways so first of all

775
00:32:23,640 --> 00:32:25,380
the titanium is an interesting Target

776
00:32:25,380 --> 00:32:27,480
especially because it's very important

777
00:32:27,480 --> 00:32:29,760
for the whole system security

778
00:32:29,760 --> 00:32:32,340
we show that with black box fuzzing you

779
00:32:32,340 --> 00:32:34,919
can easily get the surface bugs but

780
00:32:34,919 --> 00:32:37,440
emulation the exposing is really more

781
00:32:37,440 --> 00:32:39,000
effective on such targets even though

782
00:32:39,000 --> 00:32:40,620
there are a few tricks that you need to

783
00:32:40,620 --> 00:32:43,140
put in place to optimize the results

784
00:32:43,140 --> 00:32:45,480
we discovered this critical zero day we

785
00:32:45,480 --> 00:32:48,659
presented and it allowed us to execute

786
00:32:48,659 --> 00:32:50,940
code on the Chip And to leak pretty much

787
00:32:50,940 --> 00:32:53,340
anything from the Chip's memory so we

788
00:32:53,340 --> 00:32:55,500
use that vulnerability to

789
00:32:55,500 --> 00:32:57,840
it was enough to leak strongbox Keys

790
00:32:57,840 --> 00:32:59,279
like any strongbox keys that were

791
00:32:59,279 --> 00:33:01,860
installed on the device

792
00:33:01,860 --> 00:33:03,659
the last thing is that we would like to

793
00:33:03,659 --> 00:33:06,419
thank Google for handling our uh

794
00:33:06,419 --> 00:33:08,820
vulnerability reports and for making the

795
00:33:08,820 --> 00:33:11,820
efforts to fix everything before today

796
00:33:11,820 --> 00:33:13,320
so that we can disclose the

797
00:33:13,320 --> 00:33:16,200
vulnerability for you

798
00:33:16,200 --> 00:33:19,140
so this is the end of this presentation

799
00:33:19,140 --> 00:33:23,820
um where you can find here a link uh We

800
00:33:23,820 --> 00:33:26,519
Will We Will um sorry we will push all

801
00:33:26,519 --> 00:33:28,080
the materials of this

802
00:33:28,080 --> 00:33:30,059
um talk in our GitHub repository so you

803
00:33:30,059 --> 00:33:31,980
have the link here

804
00:33:31,980 --> 00:33:34,740
and thank you everyone for listening

805
00:33:34,740 --> 00:33:37,849
[Music]

806
00:33:41,690 --> 00:33:44,799
[Music]

