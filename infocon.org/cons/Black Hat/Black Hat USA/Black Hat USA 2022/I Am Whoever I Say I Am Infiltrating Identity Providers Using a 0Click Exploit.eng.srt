1
00:00:01,430 --> 00:00:04,810
[Music]

2
00:00:07,760 --> 00:00:10,320
thank you for coming to my talk

3
00:00:10,320 --> 00:00:12,960
um I am whoever I say I am infiltrating

4
00:00:12,960 --> 00:00:14,700
identity providers using zero click

5
00:00:14,700 --> 00:00:16,920
exploits I changed the title slightly to

6
00:00:16,920 --> 00:00:19,980
include the s for exports

7
00:00:19,980 --> 00:00:21,660
um a little bit of background about who

8
00:00:21,660 --> 00:00:25,199
I am I'm a security researcher at 360 as

9
00:00:25,199 --> 00:00:26,400
part of the vulnerability Research

10
00:00:26,400 --> 00:00:29,460
Institute I also run a training class so

11
00:00:29,460 --> 00:00:31,439
if you enjoy this presentation feel free

12
00:00:31,439 --> 00:00:33,600
to check it out call full stack web

13
00:00:33,600 --> 00:00:35,760
attack I've spoken at some past

14
00:00:35,760 --> 00:00:38,280
conferences and also trained at those

15
00:00:38,280 --> 00:00:40,559
some of those conferences and in the

16
00:00:40,559 --> 00:00:43,140
past I've discovered over 1500 high

17
00:00:43,140 --> 00:00:46,140
impact or critical vulnerabilities and I

18
00:00:46,140 --> 00:00:47,940
played pone to own this year last year

19
00:00:47,940 --> 00:00:49,200
in the year before

20
00:00:49,200 --> 00:00:51,239
to have

21
00:00:51,239 --> 00:00:52,980
so the agenda for today we're going to

22
00:00:52,980 --> 00:00:55,500
discuss is what is identity and access

23
00:00:55,500 --> 00:00:57,420
management first then we're going to

24
00:00:57,420 --> 00:00:59,460
look at authentication authorization at

25
00:00:59,460 --> 00:01:01,739
more of a high level then we're going to

26
00:01:01,739 --> 00:01:03,780
quickly discuss some past attacks

27
00:01:03,780 --> 00:01:06,840
against other solution IM Solutions such

28
00:01:06,840 --> 00:01:09,540
as Oracle access manager Forge Rock open

29
00:01:09,540 --> 00:01:13,080
am and VMware workspace one access

30
00:01:13,080 --> 00:01:14,820
we'll get into this discovery of the

31
00:01:14,820 --> 00:01:15,960
bugs we'll talk about in this

32
00:01:15,960 --> 00:01:19,080
presentation and also the exploitation

33
00:01:19,080 --> 00:01:21,360
process for some of those and then we'll

34
00:01:21,360 --> 00:01:24,979
cover some conclusions and takeaways

35
00:01:25,740 --> 00:01:29,640
so let's first cover what is I am uh

36
00:01:29,640 --> 00:01:31,560
it's the integration of identity and

37
00:01:31,560 --> 00:01:34,140
access management into a single solution

38
00:01:34,140 --> 00:01:36,659
so you have identity on one hand being

39
00:01:36,659 --> 00:01:39,000
authentication which is the validation

40
00:01:39,000 --> 00:01:41,460
that is I am whoever I say I am I

41
00:01:41,460 --> 00:01:43,020
present credentials to the system and

42
00:01:43,020 --> 00:01:45,119
the system validates those credentials

43
00:01:45,119 --> 00:01:46,560
and that's usually done through password

44
00:01:46,560 --> 00:01:48,600
authentication or Federated

45
00:01:48,600 --> 00:01:50,579
authentication such as single sign-on

46
00:01:50,579 --> 00:01:51,720
technology

47
00:01:51,720 --> 00:01:53,700
and typically the protocol mainly used

48
00:01:53,700 --> 00:01:56,040
for single sign on technology is uh saml

49
00:01:56,040 --> 00:01:58,619
or security assertion markup language

50
00:01:58,619 --> 00:02:01,200
on the other hand there is

51
00:02:01,200 --> 00:02:04,200
um access or authorization which is the

52
00:02:04,200 --> 00:02:05,579
verification of privileges or

53
00:02:05,579 --> 00:02:07,439
permissions for an already authenticated

54
00:02:07,439 --> 00:02:08,399
user

55
00:02:08,399 --> 00:02:11,160
and typically speaking the protocol used

56
00:02:11,160 --> 00:02:13,800
for this is open authorization or oauth

57
00:02:13,800 --> 00:02:14,760
2.

58
00:02:14,760 --> 00:02:18,840
and that protocol is usually Inc uses

59
00:02:18,840 --> 00:02:20,819
another protocol in combination of that

60
00:02:20,819 --> 00:02:22,800
technology called Java web token and

61
00:02:22,800 --> 00:02:24,840
that's used for a data exchange right to

62
00:02:24,840 --> 00:02:28,260
keep the the data across systems

63
00:02:28,260 --> 00:02:31,680
so IM is really a prime target for

64
00:02:31,680 --> 00:02:35,520
attackers right you have it's a it's a

65
00:02:35,520 --> 00:02:36,900
technology stack that includes both

66
00:02:36,900 --> 00:02:38,940
authentication authorization

67
00:02:38,940 --> 00:02:40,739
it must be externally Exposed on the

68
00:02:40,739 --> 00:02:43,080
perimeter especially for the oauth

69
00:02:43,080 --> 00:02:45,060
component

70
00:02:45,060 --> 00:02:47,220
um it's it's got a complicated

71
00:02:47,220 --> 00:02:49,019
technology stack using several

72
00:02:49,019 --> 00:02:50,400
authentication protocols and

73
00:02:50,400 --> 00:02:52,500
authorization protocols and several

74
00:02:52,500 --> 00:02:54,959
other components inside of those systems

75
00:02:54,959 --> 00:02:58,560
so breaching in IM solution

76
00:02:58,560 --> 00:03:00,959
um is is really critical right because

77
00:03:00,959 --> 00:03:02,819
it's the keys it holds all the keys to

78
00:03:02,819 --> 00:03:04,319
the kingdom essentially for an

79
00:03:04,319 --> 00:03:05,879
organization

80
00:03:05,879 --> 00:03:09,120
and those uh those credentials that are

81
00:03:09,120 --> 00:03:11,099
stolen from that system or those tokens

82
00:03:11,099 --> 00:03:13,140
that are reforged can be replayed

83
00:03:13,140 --> 00:03:14,819
against other systems externally exposed

84
00:03:14,819 --> 00:03:16,800
and attacks can further into the network

85
00:03:16,800 --> 00:03:18,780
and more information can be stolen and

86
00:03:18,780 --> 00:03:20,760
things like that

87
00:03:20,760 --> 00:03:24,480
so you really have uh identity on one

88
00:03:24,480 --> 00:03:26,280
hand and access on the other and combine

89
00:03:26,280 --> 00:03:28,860
into a single security solution which is

90
00:03:28,860 --> 00:03:31,019
sold to many organizations and placed on

91
00:03:31,019 --> 00:03:33,500
the perimeter

92
00:03:33,500 --> 00:03:36,000
so let's go through at a high level

93
00:03:36,000 --> 00:03:39,239
Federated Authentication

94
00:03:39,239 --> 00:03:41,099
um Step One the user makes a resource

95
00:03:41,099 --> 00:03:43,260
request which goes through a service

96
00:03:43,260 --> 00:03:45,798
provider

97
00:03:46,739 --> 00:03:48,540
step two the service provider redirects

98
00:03:48,540 --> 00:03:51,980
the request to the identity provider

99
00:03:52,319 --> 00:03:54,900
step three the user then sends the

100
00:03:54,900 --> 00:03:57,180
authentication request and the resource

101
00:03:57,180 --> 00:04:00,060
to the identity provider right both the

102
00:04:00,060 --> 00:04:01,980
two types of requests

103
00:04:01,980 --> 00:04:03,420
step four the identity provider

104
00:04:03,420 --> 00:04:05,099
validates that authentication requests

105
00:04:05,099 --> 00:04:07,379
and sends back a signed response for

106
00:04:07,379 --> 00:04:10,040
data integrity

107
00:04:10,319 --> 00:04:12,239
that sign responses forwarded to the

108
00:04:12,239 --> 00:04:13,980
service provider

109
00:04:13,980 --> 00:04:15,599
and finally the service provider

110
00:04:15,599 --> 00:04:17,279
verifies that the user is authorized

111
00:04:17,279 --> 00:04:18,899
authorized to access that specific

112
00:04:18,899 --> 00:04:21,660
resource and returns a response with the

113
00:04:21,660 --> 00:04:25,460
original resource requests okay

114
00:04:25,919 --> 00:04:28,199
so like I said on the other hand for

115
00:04:28,199 --> 00:04:32,220
authorization you now have uh oauth2 and

116
00:04:32,220 --> 00:04:34,440
this works a little bit differently so

117
00:04:34,440 --> 00:04:37,199
the user is already authenticated and an

118
00:04:37,199 --> 00:04:39,000
application requests permission to that

119
00:04:39,000 --> 00:04:40,580
user

120
00:04:40,580 --> 00:04:42,960
for granting access to a particular

121
00:04:42,960 --> 00:04:44,580
resource and that's usually done through

122
00:04:44,580 --> 00:04:46,800
like a pop-up box for example and the

123
00:04:46,800 --> 00:04:49,080
user says okay I grant permission for

124
00:04:49,080 --> 00:04:51,780
that application to access uh the the

125
00:04:51,780 --> 00:04:54,380
resource

126
00:04:54,660 --> 00:04:56,639
and then that application takes that

127
00:04:56,639 --> 00:04:58,620
Grant and sends it off to the

128
00:04:58,620 --> 00:05:00,720
authorization server to gain an access

129
00:05:00,720 --> 00:05:03,540
token right

130
00:05:03,540 --> 00:05:05,520
and then finally that access token is

131
00:05:05,520 --> 00:05:07,979
used to gain access to resources right

132
00:05:07,979 --> 00:05:10,880
Naturally Speaking

133
00:05:11,460 --> 00:05:13,080
so we have some interesting points here

134
00:05:13,080 --> 00:05:15,900
for authentication it's typically only

135
00:05:15,900 --> 00:05:18,000
server-side obviously right and

136
00:05:18,000 --> 00:05:20,160
authorization combines a mixture of

137
00:05:20,160 --> 00:05:23,039
client-side and server-side components

138
00:05:23,039 --> 00:05:25,259
so for Authentication

139
00:05:25,259 --> 00:05:27,840
the obvious sort of XML tax exist for

140
00:05:27,840 --> 00:05:31,020
saml because saml is based on XML uh

141
00:05:31,020 --> 00:05:33,479
data structures and so you have token

142
00:05:33,479 --> 00:05:35,160
passing vulnerabilities like external

143
00:05:35,160 --> 00:05:37,440
entity injection uh server-side request

144
00:05:37,440 --> 00:05:41,160
forgery uh XSL transformation

145
00:05:41,160 --> 00:05:44,060
you may also have the ability to uh

146
00:05:44,060 --> 00:05:46,560
trigger a missing verification entirely

147
00:05:46,560 --> 00:05:48,180
in the system so for example you might

148
00:05:48,180 --> 00:05:49,919
be able to authenticate a system and

149
00:05:49,919 --> 00:05:52,080
they don't verify the signature at all

150
00:05:52,080 --> 00:05:53,580
and so you can completely just

151
00:05:53,580 --> 00:05:55,440
authenticate to the system with a signed

152
00:05:55,440 --> 00:05:56,639
response

153
00:05:56,639 --> 00:05:58,740
but there's also the ability to bypass

154
00:05:58,740 --> 00:06:00,979
signature verification in some cases

155
00:06:00,979 --> 00:06:04,080
using XML signature wrapping or XML

156
00:06:04,080 --> 00:06:06,020
canonicalization

157
00:06:06,020 --> 00:06:08,940
but these these type of vulnerabilities

158
00:06:08,940 --> 00:06:10,800
are

159
00:06:10,800 --> 00:06:11,580
um

160
00:06:11,580 --> 00:06:14,520
are past the differential type bug and

161
00:06:14,520 --> 00:06:16,680
as such they require the attacker to

162
00:06:16,680 --> 00:06:20,280
obtain an already existing saml response

163
00:06:20,280 --> 00:06:22,319
a sign saml response so that could be

164
00:06:22,319 --> 00:06:24,120
through an information disclosure or

165
00:06:24,120 --> 00:06:25,319
that could be through already having

166
00:06:25,319 --> 00:06:27,419
authentication to the to the system as a

167
00:06:27,419 --> 00:06:29,100
low privilege user for example

168
00:06:29,100 --> 00:06:31,560
so I try to avoid auditing for these

169
00:06:31,560 --> 00:06:33,120
types of vulnerabilities although they

170
00:06:33,120 --> 00:06:34,680
still have a high impact against these

171
00:06:34,680 --> 00:06:36,300
types of systems

172
00:06:36,300 --> 00:06:39,180
for authorization you have like I said

173
00:06:39,180 --> 00:06:41,100
client-side sort of attacks so you could

174
00:06:41,100 --> 00:06:44,400
have the idea here is the step to get

175
00:06:44,400 --> 00:06:46,740
access to an access token an attacker

176
00:06:46,740 --> 00:06:48,300
might use some client-side type of

177
00:06:48,300 --> 00:06:50,460
attack to leak the authorization codes

178
00:06:50,460 --> 00:06:53,280
or an access token through cross-site

179
00:06:53,280 --> 00:06:56,039
scripting CrossFit request forgery open

180
00:06:56,039 --> 00:06:57,900
redirect or click jacking and we've seen

181
00:06:57,900 --> 00:07:00,300
these in in done in the wild and also as

182
00:07:00,300 --> 00:07:03,120
part of bug bounties and this is more or

183
00:07:03,120 --> 00:07:05,280
less the account takeover style type

184
00:07:05,280 --> 00:07:07,800
vulnerability right

185
00:07:07,800 --> 00:07:09,919
thank you

186
00:07:10,020 --> 00:07:12,000
so now let's have a look at some past

187
00:07:12,000 --> 00:07:15,440
attacks against IM Solutions

188
00:07:16,740 --> 00:07:18,660
the uh some of the products we'll look

189
00:07:18,660 --> 00:07:20,759
at is the Oracle access manager which is

190
00:07:20,759 --> 00:07:23,520
oracle's Flagship IM solution and comes

191
00:07:23,520 --> 00:07:25,560
bundled with oracles or weblogic

192
00:07:25,560 --> 00:07:26,940
application server

193
00:07:26,940 --> 00:07:29,280
all right and this is uh this is

194
00:07:29,280 --> 00:07:31,259
actually a separate product from Oracle

195
00:07:31,259 --> 00:07:33,479
identity management solution and then

196
00:07:33,479 --> 00:07:36,000
you have the forge Rock open am and it

197
00:07:36,000 --> 00:07:38,300
was originally called opensso

198
00:07:38,300 --> 00:07:41,880
and open am is a fork of open SSO it was

199
00:07:41,880 --> 00:07:43,800
maintained and developed by the open

200
00:07:43,800 --> 00:07:46,560
source project by Ford Rock but then

201
00:07:46,560 --> 00:07:48,419
later in 2016

202
00:07:48,419 --> 00:07:52,139
they had created a forge Rock am from

203
00:07:52,139 --> 00:07:54,840
open SSO and it became a closed Source

204
00:07:54,840 --> 00:07:56,819
product having said that though the code

205
00:07:56,819 --> 00:07:58,380
bases are quite similar even though

206
00:07:58,380 --> 00:08:00,180
there's six years difference of

207
00:08:00,180 --> 00:08:01,800
development

208
00:08:01,800 --> 00:08:03,539
and then finally we have VMware

209
00:08:03,539 --> 00:08:06,300
workspace one access and it was formerly

210
00:08:06,300 --> 00:08:09,180
known as VMware identity manager and his

211
00:08:09,180 --> 00:08:11,460
vmware's Flagship IM solution and

212
00:08:11,460 --> 00:08:14,039
relatively new uh to the market but it's

213
00:08:14,039 --> 00:08:16,199
still uh used by several Fortune 500

214
00:08:16,199 --> 00:08:18,000
companies and has some technical debt of

215
00:08:18,000 --> 00:08:19,860
course

216
00:08:19,860 --> 00:08:22,259
so the first bug we'll look at is uh CV

217
00:08:22,259 --> 00:08:25,440
20 21 35 587 and this was a

218
00:08:25,440 --> 00:08:28,580
deserialization of untrusted data it was

219
00:08:28,580 --> 00:08:30,479
pre-authenticated and essentially had

220
00:08:30,479 --> 00:08:32,580
completely zero limitations

221
00:08:32,580 --> 00:08:37,380
it allowed for RC against the systems of

222
00:08:37,380 --> 00:08:39,479
uh oam 11g

223
00:08:39,479 --> 00:08:41,458
but at the time it was end of life when

224
00:08:41,458 --> 00:08:43,979
this bug was reported but it also worked

225
00:08:43,979 --> 00:08:47,700
on oam 12g which wasn't end of life but

226
00:08:47,700 --> 00:08:50,160
it didn't work on the latest patches of

227
00:08:50,160 --> 00:08:53,040
OEM 12g and that was because Oracle had

228
00:08:53,040 --> 00:08:56,339
removed the endpoint due to some code

229
00:08:56,339 --> 00:08:57,779
refactoring they didn't actually know

230
00:08:57,779 --> 00:09:00,240
about the vulnerability so essentially

231
00:09:00,240 --> 00:09:01,680
there was really not much for Oracle to

232
00:09:01,680 --> 00:09:03,839
do right so it was it was interesting to

233
00:09:03,839 --> 00:09:06,180
see it was kind of like a an end day on

234
00:09:06,180 --> 00:09:09,360
a one day vulnerability or half a zero

235
00:09:09,360 --> 00:09:10,560
day

236
00:09:10,560 --> 00:09:14,580
and then you have uh cb21 35 464 which

237
00:09:14,580 --> 00:09:16,860
was another deserialization of untrusted

238
00:09:16,860 --> 00:09:19,560
data in Forge Rock open am and this was

239
00:09:19,560 --> 00:09:21,600
very interesting because it was in a

240
00:09:21,600 --> 00:09:23,640
third-party component a third-party

241
00:09:23,640 --> 00:09:26,940
library that was separate from the

242
00:09:26,940 --> 00:09:28,740
actual original code base

243
00:09:28,740 --> 00:09:31,920
and we can see in the code here that the

244
00:09:31,920 --> 00:09:34,680
vulnerability uh came from the get

245
00:09:34,680 --> 00:09:37,620
parameter jado dots page session which

246
00:09:37,620 --> 00:09:40,920
was passed to base64 decoded essentially

247
00:09:40,920 --> 00:09:45,319
and passed to a deserialization function

248
00:09:45,620 --> 00:09:48,000
the limitations of vulnerability was

249
00:09:48,000 --> 00:09:49,500
also none and allowed for

250
00:09:49,500 --> 00:09:51,240
pre-authenticated RCU

251
00:09:51,240 --> 00:09:53,880
and the way it was patched by forged

252
00:09:53,880 --> 00:09:56,459
Rock uh in their am solution was by

253
00:09:56,459 --> 00:09:58,700
removing the vulnerable Library Jato

254
00:09:58,700 --> 00:10:01,740
which was developed Way Long Ago by Sun

255
00:10:01,740 --> 00:10:04,560
Microsystems but it was also patched

256
00:10:04,560 --> 00:10:07,800
interestingly in open am too

257
00:10:07,800 --> 00:10:10,680
and the patch uh you can see there use a

258
00:10:10,680 --> 00:10:13,440
look ahead uh whitelist destroyalization

259
00:10:13,440 --> 00:10:18,800
check for uh dangerous classes there

260
00:10:19,200 --> 00:10:21,000
and let's look at the the third

261
00:10:21,000 --> 00:10:22,680
vulnerability in the list here uh this

262
00:10:22,680 --> 00:10:26,100
is CV 2020 uh 4006. this is very

263
00:10:26,100 --> 00:10:27,720
interesting because this impacted VMware

264
00:10:27,720 --> 00:10:29,519
workspace one access and this was a

265
00:10:29,519 --> 00:10:30,899
command ejection

266
00:10:30,899 --> 00:10:32,880
and it came through the generate and

267
00:10:32,880 --> 00:10:35,399
install self-signed certificate function

268
00:10:35,399 --> 00:10:36,779
and it was very straightforward actually

269
00:10:36,779 --> 00:10:38,940
when you look at the code it was kind of

270
00:10:38,940 --> 00:10:41,100
quite obvious but the interesting point

271
00:10:41,100 --> 00:10:41,940
that I wanted to make with this

272
00:10:41,940 --> 00:10:43,620
vulnerability was the fact that it came

273
00:10:43,620 --> 00:10:44,880
from this sand parameter that was

274
00:10:44,880 --> 00:10:47,220
embedded inside of a command string in

275
00:10:47,220 --> 00:10:49,320
either Linux or Windows so if the

276
00:10:49,320 --> 00:10:51,120
software was deployed on either Linux or

277
00:10:51,120 --> 00:10:53,279
Windows the command injection would work

278
00:10:53,279 --> 00:10:55,860
and in both cases they used the command

279
00:10:55,860 --> 00:10:58,800
shell so you didn't need to do any extra

280
00:10:58,800 --> 00:11:00,899
argument attacks on the particular

281
00:11:00,899 --> 00:11:02,459
binary that was being targeted inside

282
00:11:02,459 --> 00:11:04,200
the command injection you could just use

283
00:11:04,200 --> 00:11:08,339
the shell to gain remote code execution

284
00:11:08,339 --> 00:11:10,500
okay

285
00:11:10,500 --> 00:11:12,180
but the extra interesting thing about

286
00:11:12,180 --> 00:11:14,700
this vulnerability that I noticed was

287
00:11:14,700 --> 00:11:16,620
that it was actually exploited in the

288
00:11:16,620 --> 00:11:18,720
wild back in 2020

289
00:11:18,720 --> 00:11:21,120
and on top of that it actually required

290
00:11:21,120 --> 00:11:23,880
authentication as the administrator user

291
00:11:23,880 --> 00:11:27,420
it also required access to Port 8443

292
00:11:27,420 --> 00:11:29,220
which is a Management Port that's not

293
00:11:29,220 --> 00:11:32,279
typically Exposed on the system

294
00:11:32,279 --> 00:11:34,740
and it also had csrf protection meaning

295
00:11:34,740 --> 00:11:36,540
an attacker couldn't use it in a

296
00:11:36,540 --> 00:11:38,399
client-side style attack they couldn't

297
00:11:38,399 --> 00:11:40,560
deliver it via VIA an email or anything

298
00:11:40,560 --> 00:11:42,120
like that they actually needed to

299
00:11:42,120 --> 00:11:45,300
exploit it from client to server okay so

300
00:11:45,300 --> 00:11:46,380
they needed to have credentials

301
00:11:46,380 --> 00:11:47,339
essentially

302
00:11:47,339 --> 00:11:50,180
foreign

303
00:11:50,480 --> 00:11:54,480
very simply VMware built a a class

304
00:11:54,480 --> 00:11:57,060
called input validation utils and had a

305
00:11:57,060 --> 00:11:59,880
method inside called is valid San and

306
00:11:59,880 --> 00:12:02,880
they just did a a white list or allow

307
00:12:02,880 --> 00:12:06,180
list check using regex string which was

308
00:12:06,180 --> 00:12:08,399
pretty strong strong enough to stop the

309
00:12:08,399 --> 00:12:10,440
attack

310
00:12:10,440 --> 00:12:11,880
so let's have a look at a Target

311
00:12:11,880 --> 00:12:14,220
selection and vulnerability discovery

312
00:12:14,220 --> 00:12:16,200
okay

313
00:12:16,200 --> 00:12:19,079
so as you can imagine I found VMware

314
00:12:19,079 --> 00:12:21,120
workspace one quite interesting since it

315
00:12:21,120 --> 00:12:24,360
had that externally that vulnerability

316
00:12:24,360 --> 00:12:26,760
from 2020 that was uh exploded in the

317
00:12:26,760 --> 00:12:27,720
wild

318
00:12:27,720 --> 00:12:29,760
and it also had a history of no

319
00:12:29,760 --> 00:12:31,560
pre-authenticated RCU so this made it

320
00:12:31,560 --> 00:12:32,940
super interesting for me

321
00:12:32,940 --> 00:12:34,680
it had a single point of failure for a

322
00:12:34,680 --> 00:12:37,079
system it had the same complex protocols

323
00:12:37,079 --> 00:12:40,079
or web protocols inside the system

324
00:12:40,079 --> 00:12:42,779
and uh they had a lot of technical debt

325
00:12:42,779 --> 00:12:45,360
um primarily from try Cipher so the

326
00:12:45,360 --> 00:12:46,860
software was originally developed by try

327
00:12:46,860 --> 00:12:49,680
Cipher well before 2010 and VMware came

328
00:12:49,680 --> 00:12:52,440
along and bought it in 2010. so it had

329
00:12:52,440 --> 00:12:56,180
some some technical debt there as well

330
00:12:56,579 --> 00:12:58,079
so let's have a look at how I discovered

331
00:12:58,079 --> 00:13:02,399
uh 20 22 22 954 it was quite interesting

332
00:13:02,399 --> 00:13:05,100
I was testing one of the API endpoints

333
00:13:05,100 --> 00:13:07,200
and just using some semicolons

334
00:13:07,200 --> 00:13:10,560
and I got thrown a 500 error and as a

335
00:13:10,560 --> 00:13:12,000
regular pen tester I thought that was

336
00:13:12,000 --> 00:13:13,620
quite interesting

337
00:13:13,620 --> 00:13:15,720
um so I wanted to dig further

338
00:13:15,720 --> 00:13:17,639
and just looking at the the return

339
00:13:17,639 --> 00:13:19,620
response from the server I got this

340
00:13:19,620 --> 00:13:22,560
stack trace and this error message uh

341
00:13:22,560 --> 00:13:24,959
saying he's in a isn't a valve it's is

342
00:13:24,959 --> 00:13:27,540
sync inside of this template custom

343
00:13:27,540 --> 00:13:28,639
error

344
00:13:28,639 --> 00:13:31,260
and we have a stack Trace there and it's

345
00:13:31,260 --> 00:13:34,139
mentioning free marker and so

346
00:13:34,139 --> 00:13:36,060
I put two or two together and I realized

347
00:13:36,060 --> 00:13:38,040
I think I got a template injection here

348
00:13:38,040 --> 00:13:39,779
I'd never looked at template injection

349
00:13:39,779 --> 00:13:41,339
before so I thought that was quite

350
00:13:41,339 --> 00:13:43,019
interesting

351
00:13:43,019 --> 00:13:45,959
um and the real error came down to using

352
00:13:45,959 --> 00:13:48,600
a valve inside of the custom error.stl

353
00:13:48,600 --> 00:13:50,220
script

354
00:13:50,220 --> 00:13:52,860
um and potentially attack controlled

355
00:13:52,860 --> 00:13:55,200
data can land into that into that uh

356
00:13:55,200 --> 00:13:57,920
evolve there

357
00:13:58,380 --> 00:14:00,540
so going through spring a little bit

358
00:14:00,540 --> 00:14:02,339
stepping back from a little bit and

359
00:14:02,339 --> 00:14:04,320
thinking well how is this manifested how

360
00:14:04,320 --> 00:14:06,899
is this error generated I decided to

361
00:14:06,899 --> 00:14:09,360
look at how spring handles errors all

362
00:14:09,360 --> 00:14:11,940
right and I found out that spring allow

363
00:14:11,940 --> 00:14:15,300
a developer to map slash error and set

364
00:14:15,300 --> 00:14:17,220
that as the default error Handler so

365
00:14:17,220 --> 00:14:18,839
anytime an exception is thrown in the

366
00:14:18,839 --> 00:14:21,120
application it will jump to slash error

367
00:14:21,120 --> 00:14:24,540
uh controller the Handler inside of a

368
00:14:24,540 --> 00:14:26,639
controller and it will try to attempt to

369
00:14:26,639 --> 00:14:29,220
handle that error gracefully right and

370
00:14:29,220 --> 00:14:31,800
looking at the code I found that UI uh

371
00:14:31,800 --> 00:14:34,560
the class UI error controller had a

372
00:14:34,560 --> 00:14:36,420
mapping for slash error so I set a

373
00:14:36,420 --> 00:14:38,579
breakpoint on there and I saw that it

374
00:14:38,579 --> 00:14:42,000
reached a couple of different functions

375
00:14:42,000 --> 00:14:44,040
it first reached the get error page

376
00:14:44,040 --> 00:14:45,000
function

377
00:14:45,000 --> 00:14:46,920
and then eventually reached handle

378
00:14:46,920 --> 00:14:48,959
generic error and then that handle

379
00:14:48,959 --> 00:14:51,779
generic error eventually returned the

380
00:14:51,779 --> 00:14:54,360
custom error.ftl's page

381
00:14:54,360 --> 00:14:56,880
and inside of that pay before it returns

382
00:14:56,880 --> 00:14:59,220
that page it sets the the error object

383
00:14:59,220 --> 00:15:01,519
with the error message which potentially

384
00:15:01,519 --> 00:15:04,560
controlled out contained our injected

385
00:15:04,560 --> 00:15:06,899
string

386
00:15:06,899 --> 00:15:09,420
so I set the breakpoint on the slash

387
00:15:09,420 --> 00:15:11,220
error Handler and I knew the error

388
00:15:11,220 --> 00:15:13,680
message that I was hitting right I I did

389
00:15:13,680 --> 00:15:16,079
my semicolon I saw the error message

390
00:15:16,079 --> 00:15:18,540
and I thought well how am I going to

391
00:15:18,540 --> 00:15:20,100
find out where this error message is

392
00:15:20,100 --> 00:15:21,360
right where is this coming from so

393
00:15:21,360 --> 00:15:23,160
naturally I decided to search the system

394
00:15:23,160 --> 00:15:25,920
or the code for that exception string

395
00:15:25,920 --> 00:15:27,600
all right

396
00:15:27,600 --> 00:15:29,399
and eventually I came across some

397
00:15:29,399 --> 00:15:31,079
interesting code inside of the spring

398
00:15:31,079 --> 00:15:32,279
core

399
00:15:32,279 --> 00:15:35,100
I discovered that inside of our spring

400
00:15:35,100 --> 00:15:37,100
core within version

401
00:15:37,100 --> 00:15:41,100
4.2.4 they enable by default a strict HP

402
00:15:41,100 --> 00:15:43,800
firewall and this is more or less like

403
00:15:43,800 --> 00:15:46,260
an internal web application firewall

404
00:15:46,260 --> 00:15:47,940
internal wef inside of the spring

405
00:15:47,940 --> 00:15:50,040
framework and they check for a

406
00:15:50,040 --> 00:15:51,660
particular malicious strings inside of

407
00:15:51,660 --> 00:15:54,779
URL request particular dangerous

408
00:15:54,779 --> 00:15:56,519
parameters being passed and things like

409
00:15:56,519 --> 00:15:59,639
that and it's more or less a kind of

410
00:15:59,639 --> 00:16:02,339
glorified denialists right and that they

411
00:16:02,339 --> 00:16:03,839
assume that developers are not going to

412
00:16:03,839 --> 00:16:05,459
need a semicolon not going to need

413
00:16:05,459 --> 00:16:07,920
specific characters encoded and things

414
00:16:07,920 --> 00:16:09,420
like that

415
00:16:09,420 --> 00:16:11,639
and we saw that it's sure enough it's

416
00:16:11,639 --> 00:16:13,680
hitting this exception message and it's

417
00:16:13,680 --> 00:16:15,540
the request was rejected because blah

418
00:16:15,540 --> 00:16:16,920
blah blah and it was the same error

419
00:16:16,920 --> 00:16:18,180
message I was getting back when

420
00:16:18,180 --> 00:16:20,959
triggering the bug

421
00:16:21,839 --> 00:16:23,579
so I had to step back a little bit I had

422
00:16:23,579 --> 00:16:25,860
to give it some time and let this sink I

423
00:16:25,860 --> 00:16:27,540
I decided to do some Google searching

424
00:16:27,540 --> 00:16:29,100
and I found this stack Overflow post

425
00:16:29,100 --> 00:16:31,260
that explaining the issue and it really

426
00:16:31,260 --> 00:16:34,199
came down to before uh free marker

427
00:16:34,199 --> 00:16:36,180
2.3.31

428
00:16:36,180 --> 00:16:39,120
uh the developers would use either valve

429
00:16:39,120 --> 00:16:42,360
to pass a Json string

430
00:16:42,360 --> 00:16:45,779
and after 2.3.31 a free marker they

431
00:16:45,779 --> 00:16:47,279
exposed the method called evalve

432
00:16:47,279 --> 00:16:49,500
underscore Json and that was a safer way

433
00:16:49,500 --> 00:16:52,980
to handle uh strings to pass it to Json

434
00:16:52,980 --> 00:16:55,380
but I looked further into this and the

435
00:16:55,380 --> 00:16:57,660
the free market developers expected the

436
00:16:57,660 --> 00:17:00,420
developer to pass a Json object already

437
00:17:00,420 --> 00:17:03,959
to a free market template so it didn't

438
00:17:03,959 --> 00:17:05,939
expect pre-processing of that of a

439
00:17:05,939 --> 00:17:08,160
string and so developers kind of got

440
00:17:08,160 --> 00:17:09,839
confused and decided to use the valve

441
00:17:09,839 --> 00:17:13,380
and it led to several security issues

442
00:17:13,380 --> 00:17:15,359
so thinking about this from a higher

443
00:17:15,359 --> 00:17:17,819
level point of view I I said well okay

444
00:17:17,819 --> 00:17:19,140
what do we have here we have a free

445
00:17:19,140 --> 00:17:20,760
marker injection

446
00:17:20,760 --> 00:17:22,679
do we need to escape the free market

447
00:17:22,679 --> 00:17:24,179
sandbox that was the first question I

448
00:17:24,179 --> 00:17:26,400
had the second question was can I find

449
00:17:26,400 --> 00:17:28,559
an exception message that I can

450
00:17:28,559 --> 00:17:31,080
partially control an exception

451
00:17:31,080 --> 00:17:33,480
and inject attack Control Data into that

452
00:17:33,480 --> 00:17:36,660
to trigger the injection correctly okay

453
00:17:36,660 --> 00:17:39,179
and in Spring MBC the configuration is

454
00:17:39,179 --> 00:17:40,919
typically done inside of the Java code

455
00:17:40,919 --> 00:17:43,860
itself not inside of XML files and in

456
00:17:43,860 --> 00:17:45,240
this particular case it was inside of

457
00:17:45,240 --> 00:17:47,460
the web config class and inside of the

458
00:17:47,460 --> 00:17:50,340
web config class they had the following

459
00:17:50,340 --> 00:17:52,559
code to Define how to create the free

460
00:17:52,559 --> 00:17:55,799
market Factory and all is good they're

461
00:17:55,799 --> 00:17:57,660
using free market default and freaker

462
00:17:57,660 --> 00:17:59,460
Market default user sandbox so that's

463
00:17:59,460 --> 00:18:01,679
pretty good but they've missed a couple

464
00:18:01,679 --> 00:18:04,980
of things all right they first of all

465
00:18:04,980 --> 00:18:09,360
they forgot to uh disable the debug and

466
00:18:09,360 --> 00:18:11,039
that's why we got our debug message back

467
00:18:11,039 --> 00:18:12,660
for the free market stack trace and and

468
00:18:12,660 --> 00:18:14,039
that kind of thing so if we were to

469
00:18:14,039 --> 00:18:16,559
disable that and by default debug is on

470
00:18:16,559 --> 00:18:18,900
and they also forgot to disable the set

471
00:18:18,900 --> 00:18:21,179
new built-in resolver

472
00:18:21,179 --> 00:18:23,340
class resolver so essentially an

473
00:18:23,340 --> 00:18:25,320
attacker could Supply a class and that

474
00:18:25,320 --> 00:18:26,940
could be instantiated and used as an

475
00:18:26,940 --> 00:18:29,460
attack and there's a famous class inside

476
00:18:29,460 --> 00:18:30,900
of free marker that you could use to

477
00:18:30,900 --> 00:18:33,660
gain RCU if you instantiate it and pass

478
00:18:33,660 --> 00:18:36,320
a string to it

479
00:18:36,360 --> 00:18:38,400
okay so we don't have to bypass the

480
00:18:38,400 --> 00:18:40,260
sandbox we've got the new built-in

481
00:18:40,260 --> 00:18:41,820
available to us let's look at the next

482
00:18:41,820 --> 00:18:44,280
issue let's try to find an exception

483
00:18:44,280 --> 00:18:46,860
right that we can inject into

484
00:18:46,860 --> 00:18:49,320
I decided to look at spring interceptors

485
00:18:49,320 --> 00:18:51,360
because the interceptors are a code

486
00:18:51,360 --> 00:18:53,100
pattern that happened before controller

487
00:18:53,100 --> 00:18:55,080
controller code and so essentially

488
00:18:55,080 --> 00:18:56,520
interceptors are used for things like

489
00:18:56,520 --> 00:18:59,640
authentication csrf token checks uh

490
00:18:59,640 --> 00:19:01,679
cookie checks and things like that and

491
00:19:01,679 --> 00:19:03,179
so I decided to look at the interceptors

492
00:19:03,179 --> 00:19:04,919
to see what are they doing and I knew

493
00:19:04,919 --> 00:19:06,480
that was pre-authenticated code and that

494
00:19:06,480 --> 00:19:09,480
was that was interesting for me

495
00:19:09,480 --> 00:19:11,160
so again I went back to my web config

496
00:19:11,160 --> 00:19:12,419
class and I had a look at how they're

497
00:19:12,419 --> 00:19:13,799
defining all the interceptors for that

498
00:19:13,799 --> 00:19:15,960
particular application and I started

499
00:19:15,960 --> 00:19:17,700
going through the interceptors one by

500
00:19:17,700 --> 00:19:19,980
one and I got to the third one which was

501
00:19:19,980 --> 00:19:23,520
auth context population interceptor

502
00:19:23,520 --> 00:19:25,740
and they took in two get parameters

503
00:19:25,740 --> 00:19:28,320
right the device you did

504
00:19:28,320 --> 00:19:31,140
and the device type and that was passed

505
00:19:31,140 --> 00:19:34,020
to an auth context instance a North a

506
00:19:34,020 --> 00:19:37,020
North context uh Builder instance and

507
00:19:37,020 --> 00:19:39,419
then of course build was called on that

508
00:19:39,419 --> 00:19:42,720
on that code and then those values that

509
00:19:42,720 --> 00:19:44,580
device ID and device type were passed

510
00:19:44,580 --> 00:19:45,419
into

511
00:19:45,419 --> 00:19:47,880
directly to properties on that object

512
00:19:47,880 --> 00:19:51,120
and then if the request wasn't valid

513
00:19:51,120 --> 00:19:52,679
then it would throw an exception message

514
00:19:52,679 --> 00:19:55,380
with those values device type and device

515
00:19:55,380 --> 00:19:59,520
ID right so now we had we had everything

516
00:19:59,520 --> 00:20:03,260
we needed we had all the ingredients

517
00:20:03,360 --> 00:20:04,980
and we have a single get request for

518
00:20:04,980 --> 00:20:06,419
payload delivery

519
00:20:06,419 --> 00:20:07,980
it works on default installation it's

520
00:20:07,980 --> 00:20:10,020
pre-authenticated and worked against

521
00:20:10,020 --> 00:20:13,100
even vmware's cloud

522
00:20:14,580 --> 00:20:17,640
and the exploit looks as simple as that

523
00:20:17,640 --> 00:20:19,440
one get request

524
00:20:19,440 --> 00:20:22,340
and I got RCA on on VMware workspace one

525
00:20:22,340 --> 00:20:24,960
and this vulnerability was actually

526
00:20:24,960 --> 00:20:26,940
exploited in the wild I tried to keep

527
00:20:26,940 --> 00:20:28,980
the details quite private but uh

528
00:20:28,980 --> 00:20:31,740
reverses and and researchers pulled

529
00:20:31,740 --> 00:20:33,120
apart the application found the patch

530
00:20:33,120 --> 00:20:34,620
and figured out what the issue was quite

531
00:20:34,620 --> 00:20:36,780
quickly and and released an exploit for

532
00:20:36,780 --> 00:20:38,039
that so I got exploited in the wild

533
00:20:38,039 --> 00:20:40,440
unfortunately

534
00:20:40,440 --> 00:20:42,299
so let's have a look at another exploit

535
00:20:42,299 --> 00:20:44,580
that I I developed uh this was uh hekate

536
00:20:44,580 --> 00:20:46,740
uh hekate stands for the Triple moon

537
00:20:46,740 --> 00:20:49,320
goddess or and there was three bugs used

538
00:20:49,320 --> 00:20:50,760
in the next exploits change so I thought

539
00:20:50,760 --> 00:20:53,400
that was a good name

540
00:20:53,400 --> 00:20:54,720
um and we'll there's actually two

541
00:20:54,720 --> 00:20:56,160
components to this exploit there's a

542
00:20:56,160 --> 00:20:57,660
client-side component and a server side

543
00:20:57,660 --> 00:21:00,480
but I just wanted to focus on the server

544
00:21:00,480 --> 00:21:01,860
side for this presentation since I don't

545
00:21:01,860 --> 00:21:03,419
have too much time but it was this

546
00:21:03,419 --> 00:21:05,280
client side was quite interesting and if

547
00:21:05,280 --> 00:21:06,840
you wanted to have a look further uh the

548
00:21:06,840 --> 00:21:08,340
code is available on GitHub after the

549
00:21:08,340 --> 00:21:10,140
presentation

550
00:21:10,140 --> 00:21:12,480
so the first vulnerability was the axis

551
00:21:12,480 --> 00:21:14,340
control service authentication bypass

552
00:21:14,340 --> 00:21:16,620
and this was quite interesting this was

553
00:21:16,620 --> 00:21:20,220
the way they implemented or2 was a

554
00:21:20,220 --> 00:21:21,720
little bit incorrect it was off the

555
00:21:21,720 --> 00:21:23,640
specification and they had two different

556
00:21:23,640 --> 00:21:24,780
classes so there was two different

557
00:21:24,780 --> 00:21:27,900
vulnerabilities vulnerable patterns but

558
00:21:27,900 --> 00:21:29,700
they've essentially exposed two methods

559
00:21:29,700 --> 00:21:31,919
generate activation token and activate

560
00:21:31,919 --> 00:21:33,919
ol2 client

561
00:21:33,919 --> 00:21:38,159
and uh they allowed an attacker to use

562
00:21:38,159 --> 00:21:40,500
an existing or2 client to obtain a

563
00:21:40,500 --> 00:21:42,840
client secret or potentially a grant

564
00:21:42,840 --> 00:21:44,340
right

565
00:21:44,340 --> 00:21:47,700
so the way that works uh and oh if we

566
00:21:47,700 --> 00:21:48,840
have a look at the system when I look

567
00:21:48,840 --> 00:21:50,159
logged in and had a little play around

568
00:21:50,159 --> 00:21:52,500
with it I actually found there was two

569
00:21:52,500 --> 00:21:54,900
defaults ol2 clients and they had the

570
00:21:54,900 --> 00:21:57,840
scope of system and admin so it's like

571
00:21:57,840 --> 00:21:59,520
having hard-coded credentials in the

572
00:21:59,520 --> 00:22:02,159
system in essence

573
00:22:02,159 --> 00:22:03,780
so let's have a look at how the attacks

574
00:22:03,780 --> 00:22:05,760
worked first the attacker makes a

575
00:22:05,760 --> 00:22:07,500
request to generate activation token

576
00:22:07,500 --> 00:22:09,360
endpoint and passes in one of the

577
00:22:09,360 --> 00:22:11,520
default or2 clients in this case it was

578
00:22:11,520 --> 00:22:13,440
ACS

579
00:22:13,440 --> 00:22:15,360
the system returns

580
00:22:15,360 --> 00:22:18,299
with an activation token right

581
00:22:18,299 --> 00:22:20,340
then the attacker sends that activation

582
00:22:20,340 --> 00:22:23,039
token to the activate endpoint

583
00:22:23,039 --> 00:22:24,720
and then of course the system returns

584
00:22:24,720 --> 00:22:28,440
back a client ID and the client Secret

585
00:22:28,440 --> 00:22:30,500
completely unauthenticated this is just

586
00:22:30,500 --> 00:22:32,580
assessing the system and we get back a

587
00:22:32,580 --> 00:22:35,059
client Secret

588
00:22:35,220 --> 00:22:37,620
so essentially what we have now is the

589
00:22:37,620 --> 00:22:39,840
ability to bypass this client side

590
00:22:39,840 --> 00:22:43,679
action of Old 2 and directly access and

591
00:22:43,679 --> 00:22:45,720
send a grant request a client

592
00:22:45,720 --> 00:22:48,480
credentials Grant request to the system

593
00:22:48,480 --> 00:22:50,220
to then say okay now give me back a

594
00:22:50,220 --> 00:22:51,900
token because I got I got the grant here

595
00:22:51,900 --> 00:22:53,640
I got the client secret give me back an

596
00:22:53,640 --> 00:22:55,679
access token and now I can now use that

597
00:22:55,679 --> 00:22:57,059
access token to access any of the

598
00:22:57,059 --> 00:22:59,340
resources on the system as system or

599
00:22:59,340 --> 00:23:01,320
admin scope level

600
00:23:01,320 --> 00:23:02,700
okay

601
00:23:02,700 --> 00:23:04,799
this was a fun bug because it completely

602
00:23:04,799 --> 00:23:06,960
required no outbound access to the

603
00:23:06,960 --> 00:23:09,240
network no interaction with other

604
00:23:09,240 --> 00:23:11,580
attacker systems it was completely all

605
00:23:11,580 --> 00:23:15,240
built in within the within the framework

606
00:23:15,240 --> 00:23:16,799
so to understand the next vulnerability

607
00:23:16,799 --> 00:23:18,539
let's have a little bit of a look at

608
00:23:18,539 --> 00:23:22,620
Java database connectivity or jdbc

609
00:23:22,620 --> 00:23:24,720
Java provides a level of abstraction for

610
00:23:24,720 --> 00:23:26,820
developers to interface with database

611
00:23:26,820 --> 00:23:28,260
Technologies in order to encourage

612
00:23:28,260 --> 00:23:30,659
cross-platform development

613
00:23:30,659 --> 00:23:32,220
the idea is that the Java developer

614
00:23:32,220 --> 00:23:33,419
doesn't really need to know what

615
00:23:33,419 --> 00:23:36,299
database technology the application uses

616
00:23:36,299 --> 00:23:39,000
if they adhere to the jsr 221

617
00:23:39,000 --> 00:23:40,440
specification

618
00:23:40,440 --> 00:23:42,919
right these drivers implement the

619
00:23:42,919 --> 00:23:46,740
java.sql driver interface

620
00:23:46,740 --> 00:23:49,140
and the issue really here is that the

621
00:23:49,140 --> 00:23:50,820
drivers provide a very large attack

622
00:23:50,820 --> 00:23:53,460
surface for any jwc injection endpoint

623
00:23:53,460 --> 00:23:56,120
okay

624
00:23:56,820 --> 00:23:58,320
so before we get into the bug let's have

625
00:23:58,320 --> 00:23:59,880
a quick look at this particular class

626
00:23:59,880 --> 00:24:01,679
this was the DB connection check

627
00:24:01,679 --> 00:24:04,080
controller and this actually had

628
00:24:04,080 --> 00:24:07,559
implemented the ignore a csrf handling

629
00:24:07,559 --> 00:24:10,440
interface so essentially any request to

630
00:24:10,440 --> 00:24:12,120
this controller could have been done

631
00:24:12,120 --> 00:24:13,919
from a from client-side as well from a

632
00:24:13,919 --> 00:24:15,419
client-side attack so that was part of

633
00:24:15,419 --> 00:24:18,059
the hikate exploit

634
00:24:18,059 --> 00:24:20,460
and inside of this controller they had a

635
00:24:20,460 --> 00:24:22,919
method mapped called dbe check and this

636
00:24:22,919 --> 00:24:26,280
passed in a jwc URL That Was Then passed

637
00:24:26,280 --> 00:24:29,280
to the the check connection method

638
00:24:29,280 --> 00:24:30,840
and following several layers of

639
00:24:30,840 --> 00:24:32,880
abstraction we eventually get to drive

640
00:24:32,880 --> 00:24:35,039
and manager.getconnection which is the

641
00:24:35,039 --> 00:24:37,919
actual sync for jwc injection using the

642
00:24:37,919 --> 00:24:42,559
attack controller jdbc URL

643
00:24:43,620 --> 00:24:45,720
now there are several ways to exploit

644
00:24:45,720 --> 00:24:47,340
jwc injections that are publicly

645
00:24:47,340 --> 00:24:49,919
available as it currently stands attacks

646
00:24:49,919 --> 00:24:52,919
against mice color driver postgres H2

647
00:24:52,919 --> 00:24:55,799
driver you've got db2

648
00:24:55,799 --> 00:24:58,020
Apache Derby and even my scroll fabric

649
00:24:58,020 --> 00:25:00,659
drivers okay not all of them achieve rce

650
00:25:00,659 --> 00:25:03,480
but most of them do

651
00:25:03,480 --> 00:25:05,760
the interesting one for me was the MySQL

652
00:25:05,760 --> 00:25:07,440
driver and the postgres

653
00:25:07,440 --> 00:25:09,360
because these were the drivers that were

654
00:25:09,360 --> 00:25:11,700
installed on the system right but it was

655
00:25:11,700 --> 00:25:13,140
interesting to note that the actual

656
00:25:13,140 --> 00:25:15,240
system used a posca's database under the

657
00:25:15,240 --> 00:25:18,299
hood so the the MySQL driver was

658
00:25:18,299 --> 00:25:20,220
technical debt right sitting in the

659
00:25:20,220 --> 00:25:23,159
system not being utilized at all

660
00:25:23,159 --> 00:25:25,679
let's have a look at a sample request

661
00:25:25,679 --> 00:25:29,039
so if I was attacking the MySQL using

662
00:25:29,039 --> 00:25:30,720
the MySQL driver to attack the jwc

663
00:25:30,720 --> 00:25:31,799
injection

664
00:25:31,799 --> 00:25:33,600
it would be an attack like this first we

665
00:25:33,600 --> 00:25:35,220
bypass the authentication and grab the

666
00:25:35,220 --> 00:25:37,020
pages NN cookie

667
00:25:37,020 --> 00:25:39,600
and then we make a request to that

668
00:25:39,600 --> 00:25:42,419
endpoint DB check we pass in the jwc

669
00:25:42,419 --> 00:25:44,520
string pointing it to an attacker

670
00:25:44,520 --> 00:25:46,860
control MySQL server and that attack

671
00:25:46,860 --> 00:25:48,840
controlled MySQL server will deliver a

672
00:25:48,840 --> 00:25:51,299
Java object back

673
00:25:51,299 --> 00:25:52,919
and then the system would deserialize

674
00:25:52,919 --> 00:25:55,140
that Java object hopefully achieving

675
00:25:55,140 --> 00:25:57,919
remote code execution

676
00:25:58,140 --> 00:26:00,419
and in terms of the postgres uh

677
00:26:00,419 --> 00:26:02,700
injection attack I did this was a little

678
00:26:02,700 --> 00:26:05,039
bit trickier because it didn't actually

679
00:26:05,039 --> 00:26:07,380
require a valid connect back to an

680
00:26:07,380 --> 00:26:09,720
attack controlled server for the the

681
00:26:09,720 --> 00:26:11,400
postgres driver

682
00:26:11,400 --> 00:26:13,740
but it did require a connect back if we

683
00:26:13,740 --> 00:26:14,880
were exploiting the soccer Factory

684
00:26:14,880 --> 00:26:16,440
technique of

685
00:26:16,440 --> 00:26:18,779
um unsafe unmarshalling and what that

686
00:26:18,779 --> 00:26:20,760
requires is that an attacker Supply and

687
00:26:20,760 --> 00:26:22,740
arbitrary class and that class is

688
00:26:22,740 --> 00:26:24,360
instantiated with a single argument

689
00:26:24,360 --> 00:26:26,940
parameter a string argument and in the

690
00:26:26,940 --> 00:26:30,419
context of spring they have uh they have

691
00:26:30,419 --> 00:26:32,520
application contact classes context

692
00:26:32,520 --> 00:26:34,980
classes and these classes can

693
00:26:34,980 --> 00:26:38,640
um unmarshall essentially

694
00:26:38,640 --> 00:26:41,700
um and and xml's payload that can be

695
00:26:41,700 --> 00:26:44,159
supplied over a URL okay so let's have a

696
00:26:44,159 --> 00:26:46,380
look at the payload

697
00:26:46,380 --> 00:26:48,419
something as simple as this

698
00:26:48,419 --> 00:26:50,760
you pass in process Builder

699
00:26:50,760 --> 00:26:53,400
and you set the initiate method to start

700
00:26:53,400 --> 00:26:56,640
and you say start and execute this

701
00:26:56,640 --> 00:26:58,799
string and the interesting point to make

702
00:26:58,799 --> 00:27:01,320
is this is not even a bean class and yet

703
00:27:01,320 --> 00:27:02,940
it still works

704
00:27:02,940 --> 00:27:05,220
all right this is not a valid job of

705
00:27:05,220 --> 00:27:07,559
being at all process Builder

706
00:27:07,559 --> 00:27:09,600
another point to make is that

707
00:27:09,600 --> 00:27:11,220
unfortunately this attack required an

708
00:27:11,220 --> 00:27:13,020
outbound network access to an attacker's

709
00:27:13,020 --> 00:27:14,039
machine

710
00:27:14,039 --> 00:27:16,320
and also the MySQL driver acquired an

711
00:27:16,320 --> 00:27:18,000
outbound attack to us an attacker's

712
00:27:18,000 --> 00:27:19,080
machine

713
00:27:19,080 --> 00:27:20,940
so I was sort of scratching my head I

714
00:27:20,940 --> 00:27:22,200
knew where the authentication bypass

715
00:27:22,200 --> 00:27:23,940
didn't require any outbound access and I

716
00:27:23,940 --> 00:27:25,140
was kind of like

717
00:27:25,140 --> 00:27:29,279
you know how can I get uh an attack like

718
00:27:29,279 --> 00:27:31,559
this without network outbound access

719
00:27:31,559 --> 00:27:33,000
especially because I wanted to Target

720
00:27:33,000 --> 00:27:35,760
the cloud right and I had the the common

721
00:27:35,760 --> 00:27:38,159
beans u201 Gadget working from yss

722
00:27:38,159 --> 00:27:39,600
serial and I was like okay this is this

723
00:27:39,600 --> 00:27:40,740
is great I don't even have to come up

724
00:27:40,740 --> 00:27:43,620
with a Java Gadget here but it required

725
00:27:43,620 --> 00:27:45,360
uh outbound network access and I was

726
00:27:45,360 --> 00:27:48,059
kind of thinking how can I do better

727
00:27:48,059 --> 00:27:49,919
I decided to look into the code a little

728
00:27:49,919 --> 00:27:52,080
bit more and I found a particular class

729
00:27:52,080 --> 00:27:55,020
called license checker and that took a

730
00:27:55,020 --> 00:27:56,159
single string argument in the

731
00:27:56,159 --> 00:27:57,360
Constructor

732
00:27:57,360 --> 00:28:00,179
and that was that string was passed to

733
00:28:00,179 --> 00:28:03,360
set State inside of the license handle

734
00:28:03,360 --> 00:28:05,779
instance

735
00:28:06,900 --> 00:28:09,720
and that essentially was base64 decoded

736
00:28:09,720 --> 00:28:12,120
and passed it this realize as an array

737
00:28:12,120 --> 00:28:14,100
as a byte array

738
00:28:14,100 --> 00:28:16,799
and integer is read from there and if

739
00:28:16,799 --> 00:28:18,299
the integer matches a specific value

740
00:28:18,299 --> 00:28:22,020
then it's past deserialize underscore V2

741
00:28:22,020 --> 00:28:24,539
and then of course that byte array is

742
00:28:24,539 --> 00:28:27,360
then decrypted and deserialized under

743
00:28:27,360 --> 00:28:29,700
the hood so it was very nice no outbound

744
00:28:29,700 --> 00:28:31,980
network access required and essentially

745
00:28:31,980 --> 00:28:33,539
we had our attack we had our

746
00:28:33,539 --> 00:28:35,700
authentication bypass we could point it

747
00:28:35,700 --> 00:28:37,980
to the postgres uh use the postgres

748
00:28:37,980 --> 00:28:39,840
driver pointed to a server that doesn't

749
00:28:39,840 --> 00:28:42,000
even exist on any network or anything

750
00:28:42,000 --> 00:28:45,000
and use the license Checker class and

751
00:28:45,000 --> 00:28:48,840
pass in the the uh encrypted string

752
00:28:48,840 --> 00:28:51,720
that would be deserialized on the server

753
00:28:51,720 --> 00:28:53,940
right

754
00:28:53,940 --> 00:28:56,159
so yeah we can do better if you keep

755
00:28:56,159 --> 00:29:00,240
trying you know got very lucky we have a

756
00:29:00,240 --> 00:29:01,980
little problem we're executing arbitrary

757
00:29:01,980 --> 00:29:04,320
code AS Horizon user and this is an

758
00:29:04,320 --> 00:29:06,720
appliance and I was testing and I said I

759
00:29:06,720 --> 00:29:08,279
thought to myself look I want to try to

760
00:29:08,279 --> 00:29:09,659
get root access you know it's not enough

761
00:29:09,659 --> 00:29:11,700
to just get the Horizon user code

762
00:29:11,700 --> 00:29:13,620
execution I said let's try to get root

763
00:29:13,620 --> 00:29:15,299
access

764
00:29:15,299 --> 00:29:16,980
so one of the first things I do when I

765
00:29:16,980 --> 00:29:19,679
look at appliances I look at the sudowiz

766
00:29:19,679 --> 00:29:22,440
file right and look at well what

767
00:29:22,440 --> 00:29:24,360
scripts or things can I execute as the

768
00:29:24,360 --> 00:29:26,039
Horizon user and it turns out there was

769
00:29:26,039 --> 00:29:27,840
two specific scripts well there was lots

770
00:29:27,840 --> 00:29:29,340
of scripts I could execute but two that

771
00:29:29,340 --> 00:29:31,200
were interesting to me at the time

772
00:29:31,200 --> 00:29:33,179
it was The Gather config and the

773
00:29:33,179 --> 00:29:35,779
published CA

774
00:29:36,000 --> 00:29:38,940
so the first one published CA cert took

775
00:29:38,940 --> 00:29:40,980
an input file and made it readable and

776
00:29:40,980 --> 00:29:42,480
writable by the owner

777
00:29:42,480 --> 00:29:44,580
and this essentially allowed me to be

778
00:29:44,580 --> 00:29:47,399
able to leak uh the ETC Shadow file for

779
00:29:47,399 --> 00:29:49,380
example I could read arbitrary root

780
00:29:49,380 --> 00:29:51,240
owned files and things like that

781
00:29:51,240 --> 00:29:53,820
but I needed a bit more I needed to

782
00:29:53,820 --> 00:29:55,679
figure out what else I can do

783
00:29:55,679 --> 00:29:57,059
but it allowed me readable and

784
00:29:57,059 --> 00:29:59,880
writerable by the owner so I then found

785
00:29:59,880 --> 00:30:01,860
that the gather config script allowed me

786
00:30:01,860 --> 00:30:04,559
to take ownership of a root own file so

787
00:30:04,559 --> 00:30:07,260
I could just Sim link debug config.txt

788
00:30:07,260 --> 00:30:09,600
and point it to a root owned file

789
00:30:09,600 --> 00:30:11,520
and we were pretty much done at that

790
00:30:11,520 --> 00:30:13,639
point

791
00:30:14,100 --> 00:30:16,380
so in this screenshot here we have

792
00:30:16,380 --> 00:30:19,140
showing a root own file which is one of

793
00:30:19,140 --> 00:30:20,760
the scripts that was part of the sudowiz

794
00:30:20,760 --> 00:30:22,940
file

795
00:30:23,279 --> 00:30:26,220
and show the permissions here as Horizon

796
00:30:26,220 --> 00:30:28,440
so we gain root access by leveraging the

797
00:30:28,440 --> 00:30:31,320
the exploit but the idea here is it

798
00:30:31,320 --> 00:30:32,760
changes the ownership of that particular

799
00:30:32,760 --> 00:30:35,279
file and changes it to be writable and

800
00:30:35,279 --> 00:30:37,679
then we edit the file as as a low

801
00:30:37,679 --> 00:30:39,120
privilege user and just execute it as

802
00:30:39,120 --> 00:30:42,299
sudo we get our root shell and you can

803
00:30:42,299 --> 00:30:43,559
see that that script is actually in the

804
00:30:43,559 --> 00:30:45,419
pseudo is there as well

805
00:30:45,419 --> 00:30:47,820
all right

806
00:30:47,820 --> 00:30:49,919
so now let's have a little demo time

807
00:30:49,919 --> 00:30:52,580
we'll see how we go

808
00:30:52,580 --> 00:30:56,360
uh you see here

809
00:30:56,880 --> 00:30:58,380
you guys should be able to see the

810
00:30:58,380 --> 00:31:00,240
screen now just going to make sure the

811
00:31:00,240 --> 00:31:02,279
system the target system is up

812
00:31:02,279 --> 00:31:05,340
so I'm going to run my POC now

813
00:31:05,340 --> 00:31:08,658
first I'm going to grab my IP

814
00:31:09,299 --> 00:31:11,539
okay

815
00:31:13,919 --> 00:31:16,559
let me see here

816
00:31:16,559 --> 00:31:19,980
okay and I'll just change this

817
00:31:19,980 --> 00:31:24,000
to 131 and hopefully if everything's

818
00:31:24,000 --> 00:31:26,279
right we bypass authentication trigger

819
00:31:26,279 --> 00:31:28,200
the deserialization wait a couple of

820
00:31:28,200 --> 00:31:30,299
seconds and we should have our root

821
00:31:30,299 --> 00:31:31,450
shell pre-authenticated

822
00:31:31,450 --> 00:31:34,700
[Applause]

823
00:31:34,700 --> 00:31:37,440
put the command wrong there

824
00:31:37,440 --> 00:31:38,580
hey

825
00:31:38,580 --> 00:31:42,139
all right let's go back to the slides

826
00:31:45,779 --> 00:31:48,000
okay

827
00:31:48,000 --> 00:31:50,700
so hekate results

828
00:31:50,700 --> 00:31:52,380
um no outbound network access required

829
00:31:52,380 --> 00:31:53,580
Works in default installation

830
00:31:53,580 --> 00:31:55,620
pre-authenticated against the client and

831
00:31:55,620 --> 00:31:56,940
server

832
00:31:56,940 --> 00:31:59,520
achieves root access works on VMware

833
00:31:59,520 --> 00:32:02,640
cloud and exploit even cleans up after

834
00:32:02,640 --> 00:32:05,940
it modifies the sudo script right

835
00:32:05,940 --> 00:32:08,159
conclusions and takeaway

836
00:32:08,159 --> 00:32:10,200
for the defender

837
00:32:10,200 --> 00:32:11,940
um don't allow your organization to have

838
00:32:11,940 --> 00:32:13,740
a single point of failure right so

839
00:32:13,740 --> 00:32:16,020
having a system like an IAM Solution on

840
00:32:16,020 --> 00:32:17,640
your perimeter is really kind of a

841
00:32:17,640 --> 00:32:19,140
single point of failure if that system

842
00:32:19,140 --> 00:32:22,559
is accessed or penetrated and gained to

843
00:32:22,559 --> 00:32:23,940
taken over then you have a serious

844
00:32:23,940 --> 00:32:26,340
problem in your hands don't deviate from

845
00:32:26,340 --> 00:32:28,380
the or2 spec in fact don't deviate from

846
00:32:28,380 --> 00:32:30,360
any complex protocol stack

847
00:32:30,360 --> 00:32:34,020
um especially web facing and disable the

848
00:32:34,020 --> 00:32:35,399
new built-in when implementing free

849
00:32:35,399 --> 00:32:37,500
marker in fact just watch out for unsafe

850
00:32:37,500 --> 00:32:39,059
defaults when implementing third-party

851
00:32:39,059 --> 00:32:40,380
libraries

852
00:32:40,380 --> 00:32:42,600
um templating engines are complex you

853
00:32:42,600 --> 00:32:44,340
know and even though they might enable a

854
00:32:44,340 --> 00:32:46,020
Sandbox there might be some other issues

855
00:32:46,020 --> 00:32:47,940
that you want to check that could be

856
00:32:47,940 --> 00:32:49,380
insecure

857
00:32:49,380 --> 00:32:51,000
for the attacker

858
00:32:51,000 --> 00:32:52,500
you really want to always check the

859
00:32:52,500 --> 00:32:54,000
implementation for protocols or mistakes

860
00:32:54,000 --> 00:32:56,039
right you always want to want to double

861
00:32:56,039 --> 00:32:57,600
check how they implemented a particular

862
00:32:57,600 --> 00:32:59,640
protocol that could be something just

863
00:32:59,640 --> 00:33:01,200
slightly off and enough for you to take

864
00:33:01,200 --> 00:33:02,399
over a system

865
00:33:02,399 --> 00:33:04,260
always try to change vulnerabilities

866
00:33:04,260 --> 00:33:05,940
together and Primitives together even if

867
00:33:05,940 --> 00:33:07,140
it's just a little vulnerability here

868
00:33:07,140 --> 00:33:08,520
and a little vulnerability there put it

869
00:33:08,520 --> 00:33:10,200
together and see what you can how far

870
00:33:10,200 --> 00:33:11,340
you can push it

871
00:33:11,340 --> 00:33:13,740
and make giving up harder than giving in

872
00:33:13,740 --> 00:33:15,360
one of the things I see often is is

873
00:33:15,360 --> 00:33:17,220
people are looking at systems and they

874
00:33:17,220 --> 00:33:19,140
and they just they're close to finishing

875
00:33:19,140 --> 00:33:20,399
an exploit chain or they're close to

876
00:33:20,399 --> 00:33:22,200
finishing something and then they just I

877
00:33:22,200 --> 00:33:23,700
can't quite solve it and just leave it

878
00:33:23,700 --> 00:33:25,380
right but don't give up keep keep

879
00:33:25,380 --> 00:33:27,779
working at it

880
00:33:27,779 --> 00:33:30,720
and there's some references there and I

881
00:33:30,720 --> 00:33:33,059
will release the code and a blog post

882
00:33:33,059 --> 00:33:35,039
after this presentation with a little

883
00:33:35,039 --> 00:33:36,600
bit more detail surrounding the

884
00:33:36,600 --> 00:33:38,159
vulnerabilities for example about how

885
00:33:38,159 --> 00:33:40,080
the or2 clients are generated and things

886
00:33:40,080 --> 00:33:42,360
like that okay any questions and thank

887
00:33:42,360 --> 00:33:45,559
you for attending my talk

888
00:33:45,580 --> 00:33:47,760
[Music]

889
00:33:47,760 --> 00:33:49,940
foreign

890
00:33:52,540 --> 00:33:55,639
[Music]

