1
00:00:01,700 --> 00:00:04,810
[Music]

2
00:00:07,400 --> 00:00:09,840
so thank you all for coming out this

3
00:00:09,840 --> 00:00:10,500
morning

4
00:00:10,500 --> 00:00:12,780
today I'm going to be presenting to you

5
00:00:12,780 --> 00:00:14,280
the results of our group's latest

6
00:00:14,280 --> 00:00:16,859
research effort which was to develop

7
00:00:16,859 --> 00:00:18,840
memory forensics techniques to let us

8
00:00:18,840 --> 00:00:21,539
automatically detect and analyze malware

9
00:00:21,539 --> 00:00:24,539
that monitors Hardware devices

10
00:00:24,539 --> 00:00:26,400
and if you work in the incident response

11
00:00:26,400 --> 00:00:28,260
field you likely see this malware all

12
00:00:28,260 --> 00:00:30,779
the time we see this targeted at our

13
00:00:30,779 --> 00:00:33,300
clients on a daily basis and if you read

14
00:00:33,300 --> 00:00:35,100
the reports from other security vendors

15
00:00:35,100 --> 00:00:37,320
it's pretty much Universal that when you

16
00:00:37,320 --> 00:00:39,420
have a motivated threat group targeting

17
00:00:39,420 --> 00:00:41,399
an organization whether that's a

18
00:00:41,399 --> 00:00:42,899
research group inside the organization

19
00:00:42,899 --> 00:00:44,820
whether it's Executives whether it's

20
00:00:44,820 --> 00:00:47,160
down to just an individual person the

21
00:00:47,160 --> 00:00:48,600
malware that gets deployed on those

22
00:00:48,600 --> 00:00:51,360
machines are going to leverage access to

23
00:00:51,360 --> 00:00:53,579
Hardware devices for truly sensitive

24
00:00:53,579 --> 00:00:55,440
information everything that's typed on

25
00:00:55,440 --> 00:00:57,239
the keyboard all of the activity with

26
00:00:57,239 --> 00:00:59,039
the mouse you will see the microphones

27
00:00:59,039 --> 00:01:01,199
being sampled and then audio shipped out

28
00:01:01,199 --> 00:01:03,000
the video cameras are going to be

29
00:01:03,000 --> 00:01:04,379
recorded and whether that's still

30
00:01:04,379 --> 00:01:06,840
pictures or video that's produced off of

31
00:01:06,840 --> 00:01:09,000
it all that gets sent back to those

32
00:01:09,000 --> 00:01:11,340
attackers and so if you're an individual

33
00:01:11,340 --> 00:01:14,100
and you're targeted by a hostile foreign

34
00:01:14,100 --> 00:01:16,020
Nation their intelligent service you

35
00:01:16,020 --> 00:01:17,220
probably don't want everything you do

36
00:01:17,220 --> 00:01:19,080
within five feet of your laptop shift

37
00:01:19,080 --> 00:01:21,240
shift out to those people so that they

38
00:01:21,240 --> 00:01:23,100
can take advantage of it and certainly

39
00:01:23,100 --> 00:01:24,420
if you're trying to keep secrets within

40
00:01:24,420 --> 00:01:26,280
your your organization having all of

41
00:01:26,280 --> 00:01:28,320
that monitored across your Fleet is

42
00:01:28,320 --> 00:01:30,360
going to make that very difficult

43
00:01:30,360 --> 00:01:32,400
and then so what we wanted to do was get

44
00:01:32,400 --> 00:01:33,540
it to where our memory forensics

45
00:01:33,540 --> 00:01:35,460
algorithms are tools like volatility

46
00:01:35,460 --> 00:01:37,740
could just automatically find these rip

47
00:01:37,740 --> 00:01:39,420
these out of memory and make it where

48
00:01:39,420 --> 00:01:41,280
attackers know if they're going to use

49
00:01:41,280 --> 00:01:42,600
these types of techniques they're going

50
00:01:42,600 --> 00:01:44,340
to be caught rather quickly

51
00:01:44,340 --> 00:01:46,200
but unfortunately we knew from our

52
00:01:46,200 --> 00:01:48,060
existing work in our existing research

53
00:01:48,060 --> 00:01:50,520
that the algorithms that were present

54
00:01:50,520 --> 00:01:52,740
and available before our work were

55
00:01:52,740 --> 00:01:54,299
either outdated so they didn't support

56
00:01:54,299 --> 00:01:56,460
things like Windows 10 or the latest Mac

57
00:01:56,460 --> 00:01:58,560
they were incomplete so we knew that

58
00:01:58,560 --> 00:02:00,840
malware could try variations on existing

59
00:02:00,840 --> 00:02:02,700
techniques that wouldn't be caught and

60
00:02:02,700 --> 00:02:04,200
then some of them with the newer ways

61
00:02:04,200 --> 00:02:05,340
that malware Works were just

62
00:02:05,340 --> 00:02:06,960
non-existent so we could certainly

63
00:02:06,960 --> 00:02:08,399
figure these out on our own through

64
00:02:08,399 --> 00:02:10,080
reverse engineering and things like that

65
00:02:10,080 --> 00:02:11,700
that's how we knew we were missing stuff

66
00:02:11,700 --> 00:02:13,319
but we want to be able to automate

67
00:02:13,319 --> 00:02:15,000
things at scale so we need to really

68
00:02:15,000 --> 00:02:17,580
understand how it works

69
00:02:17,580 --> 00:02:19,680
so this turned into a pretty significant

70
00:02:19,680 --> 00:02:21,660
research project it took us two to three

71
00:02:21,660 --> 00:02:23,400
months to get with a lot of reverse

72
00:02:23,400 --> 00:02:25,140
engineering source code analysis get it

73
00:02:25,140 --> 00:02:26,879
working but we wanted to do a very

74
00:02:26,879 --> 00:02:28,920
thorough job so we started at the

75
00:02:28,920 --> 00:02:31,200
beginning by taking every malware report

76
00:02:31,200 --> 00:02:33,480
we had internally as well as all the

77
00:02:33,480 --> 00:02:35,760
ones that we could get online we made a

78
00:02:35,760 --> 00:02:38,459
list of the apis and the subsystems that

79
00:02:38,459 --> 00:02:40,560
process malware will abuse to get access

80
00:02:40,560 --> 00:02:43,260
to the hardware devices we then spent

81
00:02:43,260 --> 00:02:45,300
many many nights and weekends in Ida Pro

82
00:02:45,300 --> 00:02:47,340
and other tools figuring out how those

83
00:02:47,340 --> 00:02:49,680
apis are implemented on the system

84
00:02:49,680 --> 00:02:51,599
we then developed proof-of-concept

85
00:02:51,599 --> 00:02:53,760
applications so exactly what we saw the

86
00:02:53,760 --> 00:02:55,860
malware doing we wanted to implement

87
00:02:55,860 --> 00:02:57,780
that on our own in a controlled manner

88
00:02:57,780 --> 00:02:59,340
so we knew that our tools were working

89
00:02:59,340 --> 00:03:00,900
we want to make it where we truly never

90
00:03:00,900 --> 00:03:02,879
missed this malware in the wild going

91
00:03:02,879 --> 00:03:04,680
forward and then we're going to develop

92
00:03:04,680 --> 00:03:06,780
new volatility plugins so that like I

93
00:03:06,780 --> 00:03:10,080
said we can do this in an automated way

94
00:03:10,080 --> 00:03:11,580
and if you're in this talk you're

95
00:03:11,580 --> 00:03:13,140
probably interested in memory forensics

96
00:03:13,140 --> 00:03:15,060
or probably know what it means but if

97
00:03:15,060 --> 00:03:16,440
you're not too familiar with it the

98
00:03:16,440 --> 00:03:18,180
reason memory forensics is so important

99
00:03:18,180 --> 00:03:20,280
and we spend so much time working on it

100
00:03:20,280 --> 00:03:22,620
is when you look at modern attacks and

101
00:03:22,620 --> 00:03:24,300
modern threats the payloads that are

102
00:03:24,300 --> 00:03:26,519
used the tool sets that are launched the

103
00:03:26,519 --> 00:03:28,200
really important parts or in some case

104
00:03:28,200 --> 00:03:30,599
all the parts are memory only so what

105
00:03:30,599 --> 00:03:32,760
that means is nothing is written out to

106
00:03:32,760 --> 00:03:35,040
disk if you reboot that machine all your

107
00:03:35,040 --> 00:03:36,659
forensics evidence goes away there's

108
00:03:36,659 --> 00:03:38,700
nothing to look at and as you might

109
00:03:38,700 --> 00:03:40,440
imagine all the data that's sent from

110
00:03:40,440 --> 00:03:42,120
The Operators is encrypted on the

111
00:03:42,120 --> 00:03:43,739
network so even if you're a place that

112
00:03:43,739 --> 00:03:45,659
has full pcap that doesn't really help

113
00:03:45,659 --> 00:03:48,299
right so we want to be able to get a

114
00:03:48,299 --> 00:03:50,340
sample of memory off a machine and then

115
00:03:50,340 --> 00:03:52,200
deeply analyze it to find this type of

116
00:03:52,200 --> 00:03:54,659
malware and this type of malware like I

117
00:03:54,659 --> 00:03:56,220
said is used all the times there's other

118
00:03:56,220 --> 00:03:57,599
black hat talks throughout the week

119
00:03:57,599 --> 00:03:59,220
where people are showing off their new

120
00:03:59,220 --> 00:04:01,920
memory only Frameworks and such but this

121
00:04:01,920 --> 00:04:03,599
quote that I have at the bottom or this

122
00:04:03,599 --> 00:04:05,400
screenshot that I have highlighted it

123
00:04:05,400 --> 00:04:07,260
was perfect timing this literally came

124
00:04:07,260 --> 00:04:08,819
out when I was going through the slides

125
00:04:08,819 --> 00:04:11,280
last week and I added it in Microsoft

126
00:04:11,280 --> 00:04:13,439
essentially burned this company out of

127
00:04:13,439 --> 00:04:15,599
Australia Australia that sells

128
00:04:15,599 --> 00:04:17,220
commercial spyware and is used by

129
00:04:17,220 --> 00:04:18,899
governments across the world and it was

130
00:04:18,899 --> 00:04:20,040
really interesting Microsoft just

131
00:04:20,040 --> 00:04:21,660
destroyed them like reversed it down to

132
00:04:21,660 --> 00:04:23,820
every bit all the capabilities it had

133
00:04:23,820 --> 00:04:25,680
but in the beginning you see what I have

134
00:04:25,680 --> 00:04:27,780
highlighted in red all the capabilities

135
00:04:27,780 --> 00:04:29,639
of that tool set that they found and

136
00:04:29,639 --> 00:04:31,680
published the one were memory only so it

137
00:04:31,680 --> 00:04:33,600
was an example from literally a week ago

138
00:04:33,600 --> 00:04:35,880
when you're targeted by motivated actors

139
00:04:35,880 --> 00:04:37,620
you're going to get hit with memory only

140
00:04:37,620 --> 00:04:40,160
malware

141
00:04:41,820 --> 00:04:43,919
so again we looked at Windows Linux and

142
00:04:43,919 --> 00:04:45,720
Mac we started with Windows because we

143
00:04:45,720 --> 00:04:47,220
figured it would take the longest to do

144
00:04:47,220 --> 00:04:48,360
so that's what I'm going to go through

145
00:04:48,360 --> 00:04:50,820
first we focused our research on Windows

146
00:04:50,820 --> 00:04:52,680
10. this is what I know not everyone

147
00:04:52,680 --> 00:04:55,020
updates right away and Windows XP lives

148
00:04:55,020 --> 00:04:57,060
on forever but we do see Windows 10 in

149
00:04:57,060 --> 00:04:59,100
most of our investigations now so we

150
00:04:59,100 --> 00:05:00,660
wanted to make sure our algorithms were

151
00:05:00,660 --> 00:05:02,820
up to date for that so we went all the

152
00:05:02,820 --> 00:05:04,560
way back to the first stable versions of

153
00:05:04,560 --> 00:05:06,419
Windows 10 through the latest stable

154
00:05:06,419 --> 00:05:09,180
release back in March we had our memory

155
00:05:09,180 --> 00:05:10,800
collection tools so we could do our

156
00:05:10,800 --> 00:05:13,259
research and then also save out memory

157
00:05:13,259 --> 00:05:14,940
samples with those proof of Concepts

158
00:05:14,940 --> 00:05:16,800
loaded so that going forward we know

159
00:05:16,800 --> 00:05:19,979
that our tools always work

160
00:05:19,979 --> 00:05:22,080
the first API that we looked at that

161
00:05:22,080 --> 00:05:24,300
malware abuses is set Windows hook ex

162
00:05:24,300 --> 00:05:26,580
this has been abused by malware for

163
00:05:26,580 --> 00:05:29,220
years and years on Windows the idea of

164
00:05:29,220 --> 00:05:30,780
it and the reason it gets abused so much

165
00:05:30,780 --> 00:05:33,060
is it's extremely powerful all your

166
00:05:33,060 --> 00:05:34,860
malware has to do is call one function

167
00:05:34,860 --> 00:05:36,960
in most cases when it calls that

168
00:05:36,960 --> 00:05:38,639
function it's going to pass in the path

169
00:05:38,639 --> 00:05:41,220
to a dll on disk that it once injected

170
00:05:41,220 --> 00:05:43,500
into every process and then the malware

171
00:05:43,500 --> 00:05:44,880
doesn't have to do anything after that

172
00:05:44,880 --> 00:05:46,860
Windows does all the hard work of every

173
00:05:46,860 --> 00:05:48,840
time a process starts that dll gets

174
00:05:48,840 --> 00:05:51,300
loaded once an event is triggered it

175
00:05:51,300 --> 00:05:52,740
does all the hard work of making sure

176
00:05:52,740 --> 00:05:54,840
the Callback that that dll registers

177
00:05:54,840 --> 00:05:56,699
gets triggered so every time a key is

178
00:05:56,699 --> 00:05:58,800
pressed every time a mouse is moved and

179
00:05:58,800 --> 00:06:00,900
so on and so again this makes it very

180
00:06:00,900 --> 00:06:03,000
nice for malware if you're familiar with

181
00:06:03,000 --> 00:06:04,979
code injection with like create remote

182
00:06:04,979 --> 00:06:07,259
thread virtual Alec ex the malware

183
00:06:07,259 --> 00:06:08,759
doesn't have to do any of that the

184
00:06:08,759 --> 00:06:11,039
operating system does it for it so

185
00:06:11,039 --> 00:06:13,800
inside of volatility we have a plugin

186
00:06:13,800 --> 00:06:15,300
called message hooks that's been around

187
00:06:15,300 --> 00:06:17,400
for years and years but it was never

188
00:06:17,400 --> 00:06:19,919
never properly updated for Windows 10.

189
00:06:19,919 --> 00:06:21,780
and when we really studied the set

190
00:06:21,780 --> 00:06:23,819
Windows hook ex usages out in the wild

191
00:06:23,819 --> 00:06:25,919
we realized there were some variations

192
00:06:25,919 --> 00:06:28,139
on it that we weren't detecting and one

193
00:06:28,139 --> 00:06:29,940
of them that I'll talk about I actually

194
00:06:29,940 --> 00:06:31,199
didn't know don't know anyone in the

195
00:06:31,199 --> 00:06:32,759
field who knew about it before

196
00:06:32,759 --> 00:06:34,919
um so it's something that wasn't known

197
00:06:34,919 --> 00:06:37,979
but we want to detect all of it

198
00:06:37,979 --> 00:06:39,960
so this is a look at set Windows hook ex

199
00:06:39,960 --> 00:06:41,759
the parameters that the malware is going

200
00:06:41,759 --> 00:06:43,979
to set the first one is you say which

201
00:06:43,979 --> 00:06:45,600
device you want to monitor keyboard

202
00:06:45,600 --> 00:06:48,360
mouse and so on and then the last two

203
00:06:48,360 --> 00:06:51,060
things that you have to send in are in

204
00:06:51,060 --> 00:06:52,500
most cases you're going to send the path

205
00:06:52,500 --> 00:06:54,419
to a dll but we'll see you don't have to

206
00:06:54,419 --> 00:06:56,520
do that and then the last parameter the

207
00:06:56,520 --> 00:06:58,680
thread ID says if you want to monitor a

208
00:06:58,680 --> 00:07:00,300
specific thread so basically if you want

209
00:07:00,300 --> 00:07:02,759
to monitor just one application or if

210
00:07:02,759 --> 00:07:04,500
you want to hook all processes and

211
00:07:04,500 --> 00:07:07,080
applications for a specific user and

212
00:07:07,080 --> 00:07:08,880
then again you send in what you want to

213
00:07:08,880 --> 00:07:10,560
monitor where your code is that's going

214
00:07:10,560 --> 00:07:12,180
to monitor it and then Windows takes

215
00:07:12,180 --> 00:07:15,080
care of it for you

216
00:07:15,840 --> 00:07:17,759
this is the proof of concept that we

217
00:07:17,759 --> 00:07:19,860
developed for this technique you can see

218
00:07:19,860 --> 00:07:23,220
that we have a dll called fakedll.dlo we

219
00:07:23,220 --> 00:07:24,780
have a function that's going to get

220
00:07:24,780 --> 00:07:26,880
registered and called every time the

221
00:07:26,880 --> 00:07:29,160
mouse is used we're calling set Windows

222
00:07:29,160 --> 00:07:31,560
hook ex with the path to that dll and

223
00:07:31,560 --> 00:07:32,940
for the last parameter we're setting

224
00:07:32,940 --> 00:07:34,800
zero which is the same thing as null so

225
00:07:34,800 --> 00:07:37,199
this is going to affect every process on

226
00:07:37,199 --> 00:07:38,759
that user's desktop

227
00:07:38,759 --> 00:07:40,680
at the bottom what we're seeing is this

228
00:07:40,680 --> 00:07:42,840
is the memory sample that we have once

229
00:07:42,840 --> 00:07:45,960
our proof of concept was loaded and the

230
00:07:45,960 --> 00:07:48,240
way it works is you launch this malware

231
00:07:48,240 --> 00:07:51,180
and then from then on anytime the mouse

232
00:07:51,180 --> 00:07:52,860
is moved in an application in this case

233
00:07:52,860 --> 00:07:55,380
the dll is going to get loaded so we ran

234
00:07:55,380 --> 00:07:57,360
a notepad we open a notepad instance

235
00:07:57,360 --> 00:07:59,460
move the mouse inside of it took the

236
00:07:59,460 --> 00:08:01,139
memory sample and as we would expect

237
00:08:01,139 --> 00:08:03,660
that notepad process now has our dll

238
00:08:03,660 --> 00:08:06,900
loaded by the operating system but this

239
00:08:06,900 --> 00:08:08,699
isn't enough to automatically detect the

240
00:08:08,699 --> 00:08:10,500
malware there's going to be dozens of

241
00:08:10,500 --> 00:08:12,599
dlls in most processes so you can't just

242
00:08:12,599 --> 00:08:15,419
look at a dll list we just do this here

243
00:08:15,419 --> 00:08:17,340
to make sure that our back door loaded

244
00:08:17,340 --> 00:08:19,758
correctly

245
00:08:19,979 --> 00:08:23,160
sorry so to actually detect these hooks

246
00:08:23,160 --> 00:08:25,500
we have to examine the GUI subsystem of

247
00:08:25,500 --> 00:08:27,599
Windows as you might imagine this is

248
00:08:27,599 --> 00:08:29,520
closed source so when we say examine it

249
00:08:29,520 --> 00:08:31,800
means lots of time reverse engineering

250
00:08:31,800 --> 00:08:34,500
the uh the win32k subsystem in the

251
00:08:34,500 --> 00:08:36,899
kernel so at a very high level when you

252
00:08:36,899 --> 00:08:39,179
log into a Windows system that will

253
00:08:39,179 --> 00:08:41,099
create a session which creates a Windows

254
00:08:41,099 --> 00:08:42,958
station and then what you're used to is

255
00:08:42,958 --> 00:08:45,180
you use one or more desktops the one on

256
00:08:45,180 --> 00:08:47,040
the local machine you can RDP into a

257
00:08:47,040 --> 00:08:49,620
system and associated with that desktops

258
00:08:49,620 --> 00:08:51,720
are two things we need to track down

259
00:08:51,720 --> 00:08:54,060
the first one is the atom table which is

260
00:08:54,060 --> 00:08:55,920
basically a set of strings associated

261
00:08:55,920 --> 00:08:58,800
with what's occurring on that desktop in

262
00:08:58,800 --> 00:09:00,180
this case there's going to be a string

263
00:09:00,180 --> 00:09:02,339
for the full path to the dll used to

264
00:09:02,339 --> 00:09:04,440
implement the hook and then you can see

265
00:09:04,440 --> 00:09:05,820
down in the bottom in the Black Box

266
00:09:05,820 --> 00:09:07,920
there's the set of hooks remember the

267
00:09:07,920 --> 00:09:09,899
name of the API is set Windows hook ex

268
00:09:09,899 --> 00:09:12,360
so this is going to store information on

269
00:09:12,360 --> 00:09:14,220
all the applications that are monitoring

270
00:09:14,220 --> 00:09:17,000
that desktop

271
00:09:18,240 --> 00:09:20,220
so like I said initially the message

272
00:09:20,220 --> 00:09:22,380
hooks plugin was very inconsistent in

273
00:09:22,380 --> 00:09:24,240
most case produced no results against

274
00:09:24,240 --> 00:09:26,339
windows 10. so the first thing we had to

275
00:09:26,339 --> 00:09:28,440
do was reverse out all the offsets for

276
00:09:28,440 --> 00:09:30,600
the different Windows 10 versions but

277
00:09:30,600 --> 00:09:32,580
then we noticed that when we did that we

278
00:09:32,580 --> 00:09:34,680
weren't getting the path to the dll back

279
00:09:34,680 --> 00:09:36,959
so remember we have our hook what to

280
00:09:36,959 --> 00:09:38,519
know which dll is actually implementing

281
00:09:38,519 --> 00:09:40,380
it we have to look in the atoms table

282
00:09:40,380 --> 00:09:42,540
this was super frustrating because it

283
00:09:42,540 --> 00:09:44,279
worked on literally none of the samples

284
00:09:44,279 --> 00:09:46,080
that we created at first so we were like

285
00:09:46,080 --> 00:09:47,519
okay we have to go back to the drawing

286
00:09:47,519 --> 00:09:50,220
board fast forward many hours in Ida Pro

287
00:09:50,220 --> 00:09:52,260
later and this is what you're seeing on

288
00:09:52,260 --> 00:09:54,300
the bottom of the slide so for every

289
00:09:54,300 --> 00:09:56,420
version of Windows going back to XP

290
00:09:56,420 --> 00:09:59,279
until before 10 you had this thing

291
00:09:59,279 --> 00:10:01,380
called the user atom table handle that

292
00:10:01,380 --> 00:10:03,180
was your table of strings volatility

293
00:10:03,180 --> 00:10:05,279
knew how to find it and then starting in

294
00:10:05,279 --> 00:10:07,019
Windows 10 it looks like Microsoft just

295
00:10:07,019 --> 00:10:09,180
re-implemented that whole subsystem so

296
00:10:09,180 --> 00:10:10,800
we had to go through and Ida figure that

297
00:10:10,800 --> 00:10:12,540
out and now we have this other table

298
00:10:12,540 --> 00:10:15,180
that we can inspect so the message hooks

299
00:10:15,180 --> 00:10:16,920
plugin now branches right it knows if

300
00:10:16,920 --> 00:10:19,019
it's looking at Windows 7 or Windows 10

301
00:10:19,019 --> 00:10:21,600
and we get those paths back so now just

302
00:10:21,600 --> 00:10:23,220
by running the plugin even on the latest

303
00:10:23,220 --> 00:10:25,500
versions of Windows 10 you get the dll

304
00:10:25,500 --> 00:10:27,300
placing the hook you get the offset

305
00:10:27,300 --> 00:10:29,640
inside of the dll where that hook is and

306
00:10:29,640 --> 00:10:31,080
if you're familiar with volatility you

307
00:10:31,080 --> 00:10:32,519
know you can just extract it out at that

308
00:10:32,519 --> 00:10:35,580
point and start reversing it

309
00:10:35,580 --> 00:10:38,220
the second variation of set Windows hook

310
00:10:38,220 --> 00:10:40,860
ex and this is the one that is kind of

311
00:10:40,860 --> 00:10:42,779
mind-blowing and like I said once once

312
00:10:42,779 --> 00:10:44,160
we figured out I pulled a bunch of

313
00:10:44,160 --> 00:10:45,720
people that I would consider experts and

314
00:10:45,720 --> 00:10:47,700
like Windows internals and malware no

315
00:10:47,700 --> 00:10:50,160
one knew this was possible so the idea

316
00:10:50,160 --> 00:10:52,260
is it only works for the low level

317
00:10:52,260 --> 00:10:54,000
keyboard hook so you're hooking the

318
00:10:54,000 --> 00:10:55,740
keyboard to low level you are going to

319
00:10:55,740 --> 00:10:57,899
get every keystroke but when you call

320
00:10:57,899 --> 00:10:59,880
set Windows hook ex you say I'm not

321
00:10:59,880 --> 00:11:02,160
giving you a path to a dll but I still

322
00:11:02,160 --> 00:11:04,260
want to hook every process across the

323
00:11:04,260 --> 00:11:06,200
desktop which makes literally no sense

324
00:11:06,200 --> 00:11:09,000
so you call it like you see at the top

325
00:11:09,000 --> 00:11:11,399
here you give the dll that you reference

326
00:11:11,399 --> 00:11:13,019
is your own executable which is

327
00:11:13,019 --> 00:11:14,700
obviously not something that can be

328
00:11:14,700 --> 00:11:16,920
injected into other processes and we

329
00:11:16,920 --> 00:11:18,480
found this documentation it wasn't

330
00:11:18,480 --> 00:11:20,279
incredibly easy to find but we

331
00:11:20,279 --> 00:11:21,899
eventually found what you see at the

332
00:11:21,899 --> 00:11:24,779
bottom of the slide on the msdn and this

333
00:11:24,779 --> 00:11:26,640
is where it gets really crazy so what

334
00:11:26,640 --> 00:11:28,980
Microsoft is saying is if you want to

335
00:11:28,980 --> 00:11:30,839
have essentially key log every process

336
00:11:30,839 --> 00:11:33,120
on the system you don't have to put any

337
00:11:33,120 --> 00:11:34,800
code into those processes you don't have

338
00:11:34,800 --> 00:11:36,959
to hook those process is at all you just

339
00:11:36,959 --> 00:11:39,000
have your own process running and then

340
00:11:39,000 --> 00:11:40,860
Microsoft or Windows is going to do all

341
00:11:40,860 --> 00:11:42,360
the hard work to send your code to

342
00:11:42,360 --> 00:11:44,459
keystrokes anyway so if you're used to

343
00:11:44,459 --> 00:11:46,320
doing memory forensics or live forensics

344
00:11:46,320 --> 00:11:49,019
on a machine you kind of understand if a

345
00:11:49,019 --> 00:11:50,820
process is being key logged if a process

346
00:11:50,820 --> 00:11:53,700
has malicious actions focused on it you

347
00:11:53,700 --> 00:11:55,200
can extract the memory of that process

348
00:11:55,200 --> 00:11:57,000
you can debug that process and find the

349
00:11:57,000 --> 00:11:59,040
malware in this case all of the

350
00:11:59,040 --> 00:12:00,839
processes that are being key logged have

351
00:12:00,839 --> 00:12:02,940
literally zero anything you can look at

352
00:12:02,940 --> 00:12:04,800
it's all in this other process on the

353
00:12:04,800 --> 00:12:07,740
system so I don't know of any where else

354
00:12:07,740 --> 00:12:10,260
this happens it's very strange so we

355
00:12:10,260 --> 00:12:11,640
wanted to be able to make sure we could

356
00:12:11,640 --> 00:12:14,100
detect it and this is something where

357
00:12:14,100 --> 00:12:16,079
volatility kind of had support before

358
00:12:16,079 --> 00:12:17,700
like once we got it working on Windows

359
00:12:17,700 --> 00:12:20,040
10 but the output was not particularly

360
00:12:20,040 --> 00:12:22,440
useful so what we're seeing three blocks

361
00:12:22,440 --> 00:12:24,000
of output here you can see there's

362
00:12:24,000 --> 00:12:26,279
spaces between them but the first one is

363
00:12:26,279 --> 00:12:28,560
the global information so volatility is

364
00:12:28,560 --> 00:12:30,000
saying hey there's this low-level

365
00:12:30,000 --> 00:12:31,740
keyboard hook that's hooking every

366
00:12:31,740 --> 00:12:34,560
thread it tells us the address of where

367
00:12:34,560 --> 00:12:37,019
that is but it has no idea which process

368
00:12:37,019 --> 00:12:39,660
it's in which is fairly useless right

369
00:12:39,660 --> 00:12:41,760
you say you have 50 processes on a

370
00:12:41,760 --> 00:12:43,320
desktop you're not going to go to that

371
00:12:43,320 --> 00:12:45,180
address in 50 different processes and

372
00:12:45,180 --> 00:12:46,680
look for malicious code

373
00:12:46,680 --> 00:12:49,860
so we went back to reversing for a while

374
00:12:49,860 --> 00:12:52,500
and we figured out that on a per thread

375
00:12:52,500 --> 00:12:54,240
basis which When I Say thread just think

376
00:12:54,240 --> 00:12:56,579
of process so on a per thread basis

377
00:12:56,579 --> 00:12:59,100
there's a flag that set that is set if

378
00:12:59,100 --> 00:13:01,500
that process set the hook so what you're

379
00:13:01,500 --> 00:13:03,600
seeing in the second two blocks is for

380
00:13:03,600 --> 00:13:05,399
the Powershell one there's a false

381
00:13:05,399 --> 00:13:07,620
printed and then for the GUI tester all

382
00:13:07,620 --> 00:13:09,839
process there's a true printed message

383
00:13:09,839 --> 00:13:11,820
hooks didn't print that before that's us

384
00:13:11,820 --> 00:13:13,800
that's us parsing that flag to say hey

385
00:13:13,800 --> 00:13:15,360
there's a global hook it's not

386
00:13:15,360 --> 00:13:17,279
Powershell that said it it's the GUI

387
00:13:17,279 --> 00:13:18,899
tester all which you'll see quite a lot

388
00:13:18,899 --> 00:13:20,279
because that was our proof of concept

389
00:13:20,279 --> 00:13:22,800
application so again this was a really

390
00:13:22,800 --> 00:13:24,959
strange Edge case it's key logging on

391
00:13:24,959 --> 00:13:26,820
the system and memory forensics knew

392
00:13:26,820 --> 00:13:29,600
nothing about it before

393
00:13:29,600 --> 00:13:32,339
then the last variation of set Windows

394
00:13:32,339 --> 00:13:34,200
hook ex is again you pick whichever

395
00:13:34,200 --> 00:13:36,000
device you want to monitor this one

396
00:13:36,000 --> 00:13:38,579
isn't limited to just the keyboard you

397
00:13:38,579 --> 00:13:41,100
can send it either a path to a dll or

398
00:13:41,100 --> 00:13:43,200
you can send it no like before but

399
00:13:43,200 --> 00:13:45,240
you're going to Target a specific thread

400
00:13:45,240 --> 00:13:47,339
which again is a process so if you just

401
00:13:47,339 --> 00:13:48,959
want to key log the web browser the

402
00:13:48,959 --> 00:13:50,519
password manager whatever it might be

403
00:13:50,519 --> 00:13:53,100
you can pick that and then you don't

404
00:13:53,100 --> 00:13:55,980
have your code going into every process

405
00:13:55,980 --> 00:13:58,200
there was literally zero documentation

406
00:13:58,200 --> 00:14:00,360
about this online so again it was more

407
00:14:00,360 --> 00:14:03,060
time in Idaho Pro so off of the threads

408
00:14:03,060 --> 00:14:05,339
so what we saw on two slides ago where

409
00:14:05,339 --> 00:14:07,200
we saw a Powershell and GUI tester all

410
00:14:07,200 --> 00:14:09,779
inside of the data structure in memory

411
00:14:09,779 --> 00:14:11,700
that represents that there's another

412
00:14:11,700 --> 00:14:14,820
kind of per thread atom table atom

413
00:14:14,820 --> 00:14:16,139
tables and quotes because it's not

414
00:14:16,139 --> 00:14:18,000
really a generic atom table it just

415
00:14:18,000 --> 00:14:19,920
stores the dlls associated with that

416
00:14:19,920 --> 00:14:22,139
thread but once we were figured that out

417
00:14:22,139 --> 00:14:24,120
we were able to update the plugin to

418
00:14:24,120 --> 00:14:27,000
then find this hook variation

419
00:14:27,000 --> 00:14:29,519
so like I said before this type of hook

420
00:14:29,519 --> 00:14:31,620
variation was not known to volatility at

421
00:14:31,620 --> 00:14:34,019
all when we first got it working when we

422
00:14:34,019 --> 00:14:35,940
figured out we had to go deeper into the

423
00:14:35,940 --> 00:14:38,160
thread we have the output that you see

424
00:14:38,160 --> 00:14:40,920
up top and the module 7 which is

425
00:14:40,920 --> 00:14:43,440
obviously not a path to a dll what that

426
00:14:43,440 --> 00:14:46,019
is saying is I know that the index into

427
00:14:46,019 --> 00:14:47,760
the string table is seven but I don't

428
00:14:47,760 --> 00:14:49,800
know how to find the string so then we

429
00:14:49,800 --> 00:14:51,660
figured out about that per thread atom

430
00:14:51,660 --> 00:14:53,639
table and you can see the updated output

431
00:14:53,639 --> 00:14:55,380
at the bottom which we're still able to

432
00:14:55,380 --> 00:14:58,260
recover the dll path so now as far as we

433
00:14:58,260 --> 00:15:00,180
know no matter how set Windows hooky X

434
00:15:00,180 --> 00:15:02,160
is used to key log systems we can

435
00:15:02,160 --> 00:15:05,300
automatically find it

436
00:15:09,779 --> 00:15:12,300
the second API on Windows that we looked

437
00:15:12,300 --> 00:15:14,279
at was is called register raw input

438
00:15:14,279 --> 00:15:16,380
devices this is another way to perform

439
00:15:16,380 --> 00:15:19,139
key logging a lot of your EDR systems

440
00:15:19,139 --> 00:15:20,820
will look for calls to set Windows hook

441
00:15:20,820 --> 00:15:22,800
ex obviously they're not perfect and I'm

442
00:15:22,800 --> 00:15:24,839
well aware that can be bypassed but they

443
00:15:24,839 --> 00:15:27,060
do make an effort so malware started

444
00:15:27,060 --> 00:15:29,399
using this API instead to achieve

445
00:15:29,399 --> 00:15:31,139
essentially the same goals

446
00:15:31,139 --> 00:15:33,420
when you call this API there's some

447
00:15:33,420 --> 00:15:35,100
constants you need to use so you

448
00:15:35,100 --> 00:15:36,360
basically just say I want to hook

449
00:15:36,360 --> 00:15:38,459
everything and I'm interested in the

450
00:15:38,459 --> 00:15:39,480
keyboard

451
00:15:39,480 --> 00:15:41,100
it's a little different than just

452
00:15:41,100 --> 00:15:43,199
passing a path to a dll though in this

453
00:15:43,199 --> 00:15:45,180
case instead you should tell it which

454
00:15:45,180 --> 00:15:48,319
window you want to Target

455
00:15:48,779 --> 00:15:50,339
so if you remember our picture from

456
00:15:50,339 --> 00:15:52,500
before we got down to the desktop of the

457
00:15:52,500 --> 00:15:54,540
user then we needed to look at the atom

458
00:15:54,540 --> 00:15:56,220
tables and the hooks to figure it out

459
00:15:56,220 --> 00:15:57,899
this is a bit different we're not

460
00:15:57,899 --> 00:16:00,300
reusing those same data structures and

461
00:16:00,300 --> 00:16:01,740
then what you see at the bottom is part

462
00:16:01,740 --> 00:16:04,139
of our proof of concept code we have our

463
00:16:04,139 --> 00:16:05,639
callback function or our hooking

464
00:16:05,639 --> 00:16:08,339
function which is called wnd proc we're

465
00:16:08,339 --> 00:16:10,260
calling register class and then create

466
00:16:10,260 --> 00:16:13,260
Windows with that function Associated so

467
00:16:13,260 --> 00:16:14,940
what that means is every time a message

468
00:16:14,940 --> 00:16:17,220
is passed to that window our function is

469
00:16:17,220 --> 00:16:18,779
going to be called and once our

470
00:16:18,779 --> 00:16:20,940
keylogger is active you might guess the

471
00:16:20,940 --> 00:16:22,920
message information is going going to

472
00:16:22,920 --> 00:16:25,139
include the keys that were typed on the

473
00:16:25,139 --> 00:16:26,820
keyboard

474
00:16:26,820 --> 00:16:29,399
so this is a partial part of our

475
00:16:29,399 --> 00:16:31,440
implementation of that callback function

476
00:16:31,440 --> 00:16:34,620
you can see for WM create when a window

477
00:16:34,620 --> 00:16:36,600
is created we're going to say register

478
00:16:36,600 --> 00:16:39,420
raw input devices so from then on every

479
00:16:39,420 --> 00:16:41,100
time a window is created on the machine

480
00:16:41,100 --> 00:16:43,440
you open Chrome you create a new tab any

481
00:16:43,440 --> 00:16:45,300
application creating Windows we're

482
00:16:45,300 --> 00:16:46,800
automatically going to get to hook it

483
00:16:46,800 --> 00:16:48,660
and then when that window starts

484
00:16:48,660 --> 00:16:50,160
producing input which again is someone

485
00:16:50,160 --> 00:16:52,320
typing on the keyboard we can read out

486
00:16:52,320 --> 00:16:54,300
that key and log it or send it across

487
00:16:54,300 --> 00:16:56,699
the network there was no memory forensic

488
00:16:56,699 --> 00:16:58,620
support for this before

489
00:16:58,620 --> 00:17:01,440
so we figured out that off of those same

490
00:17:01,440 --> 00:17:02,759
data structures we were getting the

491
00:17:02,759 --> 00:17:04,919
thread and process information there was

492
00:17:04,919 --> 00:17:06,359
a second set of tables that we could

493
00:17:06,359 --> 00:17:08,339
examine and it would tell us all the

494
00:17:08,339 --> 00:17:11,459
processes that had used that API

495
00:17:11,459 --> 00:17:13,020
and then this is a brand new plugin

496
00:17:13,020 --> 00:17:15,240
called raw input device monitors that we

497
00:17:15,240 --> 00:17:17,160
wrote to implement what we were just

498
00:17:17,160 --> 00:17:18,780
talking about and as you can see it

499
00:17:18,780 --> 00:17:21,059
tells us on the desktop in the GUI

500
00:17:21,059 --> 00:17:23,160
tester all process and our proof of

501
00:17:23,160 --> 00:17:24,780
concept the name of the window was my

502
00:17:24,780 --> 00:17:26,640
hidden window just so it would stand out

503
00:17:26,640 --> 00:17:28,799
in the output we have the address where

504
00:17:28,799 --> 00:17:31,140
that hook is and the process ID again we

505
00:17:31,140 --> 00:17:32,580
can extract that executable out of

506
00:17:32,580 --> 00:17:34,020
memory and then really start to figure

507
00:17:34,020 --> 00:17:36,620
out what happened

508
00:17:37,080 --> 00:17:39,299
so we targeted those two functions for

509
00:17:39,299 --> 00:17:41,160
Windows the next thing we looked at was

510
00:17:41,160 --> 00:17:42,840
Linux we deal with Linux investigations

511
00:17:42,840 --> 00:17:45,419
all the time especially in the cloud and

512
00:17:45,419 --> 00:17:46,799
something we still see that works which

513
00:17:46,799 --> 00:17:49,380
is rather unfortunate is abuse of the

514
00:17:49,380 --> 00:17:51,660
debugging facilities so on Linux you

515
00:17:51,660 --> 00:17:54,299
have the p-trace facility this is what

516
00:17:54,299 --> 00:17:57,059
lets processes do debugging on Linux and

517
00:17:57,059 --> 00:17:58,620
then you have S Trace which is a really

518
00:17:58,620 --> 00:18:01,320
popular tool to trace system calls that

519
00:18:01,320 --> 00:18:03,059
applications make and if you're not

520
00:18:03,059 --> 00:18:04,860
familiar with system calls anytime you

521
00:18:04,860 --> 00:18:06,600
want to interact with Hardware the

522
00:18:06,600 --> 00:18:08,400
network and other process you have to

523
00:18:08,400 --> 00:18:10,919
make a system call to do it so obviously

524
00:18:10,919 --> 00:18:12,660
by monitoring system calls you can

525
00:18:12,660 --> 00:18:15,360
monitor any hardware device

526
00:18:15,360 --> 00:18:17,280
whether that's a keyboard mic video

527
00:18:17,280 --> 00:18:19,740
camera and so on you can completely

528
00:18:19,740 --> 00:18:21,539
disable this feature because it's such a

529
00:18:21,539 --> 00:18:23,280
security threat but as you're probably

530
00:18:23,280 --> 00:18:24,840
aware security patches aren't

531
00:18:24,840 --> 00:18:26,460
universally applied people don't

532
00:18:26,460 --> 00:18:28,440
configure things right so we still see

533
00:18:28,440 --> 00:18:31,760
this being abused in the wild

534
00:18:31,860 --> 00:18:34,200
from a detection standpoint there's two

535
00:18:34,200 --> 00:18:35,760
variations we wanted to be able to

536
00:18:35,760 --> 00:18:38,400
detect in our plugins with this and this

537
00:18:38,400 --> 00:18:40,380
what we're seeing is direct debugging so

538
00:18:40,380 --> 00:18:42,600
if you start a process under a debugger

539
00:18:42,600 --> 00:18:44,280
which in this case we're starting the

540
00:18:44,280 --> 00:18:47,520
cat process under GDB so cat has started

541
00:18:47,520 --> 00:18:50,039
under GDB which is the debugger you can

542
00:18:50,039 --> 00:18:53,580
see the process IDs are 778 and 780 and

543
00:18:53,580 --> 00:18:55,440
then we wrote a new plugin called Linux

544
00:18:55,440 --> 00:18:57,419
process P Trace which is going to tell

545
00:18:57,419 --> 00:18:58,919
you all the processes that are being

546
00:18:58,919 --> 00:19:00,900
debugged and you can see in the output

547
00:19:00,900 --> 00:19:02,880
here I have it highlighted we get our

548
00:19:02,880 --> 00:19:05,880
GDB and our cat process the flags for

549
00:19:05,880 --> 00:19:07,919
cat is p Trace which tells you that it's

550
00:19:07,919 --> 00:19:09,840
being traced and then you can see for

551
00:19:09,840 --> 00:19:13,260
GDB it's tracing PID 780 which is cat so

552
00:19:13,260 --> 00:19:15,240
we automatically report that interaction

553
00:19:15,240 --> 00:19:17,940
between the processes

554
00:19:17,940 --> 00:19:20,400
now an extremely dangerous form we see

555
00:19:20,400 --> 00:19:22,740
of this quite often in the field is

556
00:19:22,740 --> 00:19:24,720
using the debug facilities to monitor

557
00:19:24,720 --> 00:19:27,419
the SSH Daemon so what we're seeing here

558
00:19:27,419 --> 00:19:30,539
is we we're on a Linux system the SSH

559
00:19:30,539 --> 00:19:33,419
Daemon is running with PID 436

560
00:19:33,419 --> 00:19:35,760
and then we're using S tray s Trace

561
00:19:35,760 --> 00:19:37,860
which obviously you have to be root to

562
00:19:37,860 --> 00:19:40,080
debug that running SSH Daemon so we're

563
00:19:40,080 --> 00:19:41,580
not restarting the Daemon it's not like

564
00:19:41,580 --> 00:19:43,080
people who are currently logged in are

565
00:19:43,080 --> 00:19:44,760
going to get kicked out we are just

566
00:19:44,760 --> 00:19:46,380
dynamically attaching to that running

567
00:19:46,380 --> 00:19:47,640
process

568
00:19:47,640 --> 00:19:50,160
so once that was running in one terminal

569
00:19:50,160 --> 00:19:52,679
I opened the second terminal and I SSH

570
00:19:52,679 --> 00:19:55,080
into that machine and what you're seeing

571
00:19:55,080 --> 00:19:57,360
is me logging in so the password was

572
00:19:57,360 --> 00:19:59,700
secret password exclamation point that

573
00:19:59,700 --> 00:20:01,380
gets read directly by the debugger

574
00:20:01,380 --> 00:20:04,380
because it in order for the process the

575
00:20:04,380 --> 00:20:06,179
SSH process to communicate that

576
00:20:06,179 --> 00:20:07,620
information it's going to go through a

577
00:20:07,620 --> 00:20:09,539
system call so you steal the password

578
00:20:09,539 --> 00:20:11,940
right away then what you see is me

579
00:20:11,940 --> 00:20:14,100
typing the netstat command one letter at

580
00:20:14,100 --> 00:20:16,440
a time that gets logged you see where

581
00:20:16,440 --> 00:20:18,240
netstat is run and then if you're

582
00:20:18,240 --> 00:20:19,620
familiar with how netstat works it's

583
00:20:19,620 --> 00:20:21,600
going to read some files under procnet

584
00:20:21,600 --> 00:20:23,100
to figure out what connections are

585
00:20:23,100 --> 00:20:25,380
active and so on so you can see how

586
00:20:25,380 --> 00:20:27,120
dangerous this is right if you use SSH

587
00:20:27,120 --> 00:20:29,039
Keys you'll get a little reprieve from

588
00:20:29,039 --> 00:20:30,780
it but if you're logging with passwords

589
00:20:30,780 --> 00:20:32,700
and you have this type of malware your

590
00:20:32,700 --> 00:20:34,020
passwords are getting logged in real

591
00:20:34,020 --> 00:20:36,179
time every time you log in as well as

592
00:20:36,179 --> 00:20:38,520
all the commands you run now making this

593
00:20:38,520 --> 00:20:40,679
infinitely worse as you can imagine if

594
00:20:40,679 --> 00:20:42,780
ransomware automated this situation with

595
00:20:42,780 --> 00:20:44,640
using the passwords and then performing

596
00:20:44,640 --> 00:20:47,280
lateral movement and then still not good

597
00:20:47,280 --> 00:20:49,919
but not as bad as ransomware is in many

598
00:20:49,919 --> 00:20:51,419
environments you you'll have to move

599
00:20:51,419 --> 00:20:53,460
through multiple Linux servers to get to

600
00:20:53,460 --> 00:20:55,740
your final destination so you go through

601
00:20:55,740 --> 00:20:58,320
those jump boxes logging in each time so

602
00:20:58,320 --> 00:21:00,299
you can imagine if box one is

603
00:21:00,299 --> 00:21:02,220
compromised with malware like this and

604
00:21:02,220 --> 00:21:03,780
it gets the password that you logged in

605
00:21:03,780 --> 00:21:06,120
with then you go to box two which might

606
00:21:06,120 --> 00:21:08,160
be your internal credentials the fact

607
00:21:08,160 --> 00:21:09,480
that you're logging into that remote

608
00:21:09,480 --> 00:21:11,160
machine is going to be key logged as

609
00:21:11,160 --> 00:21:13,140
well and no matter how many hops you're

610
00:21:13,140 --> 00:21:15,480
using to try to be secure the malware is

611
00:21:15,480 --> 00:21:16,980
just getting access to that data all

612
00:21:16,980 --> 00:21:18,840
along the way so this is definitely

613
00:21:18,840 --> 00:21:22,200
something we want to be able to detect

614
00:21:22,200 --> 00:21:24,960
so that same Linux process P Trace

615
00:21:24,960 --> 00:21:27,480
plugin we wrote to cgdb and Cat

616
00:21:27,480 --> 00:21:29,400
interacting is going to work for this as

617
00:21:29,400 --> 00:21:31,740
well if you remember and it's in the

618
00:21:31,740 --> 00:21:33,780
first line of the plugin our SSH Daemon

619
00:21:33,780 --> 00:21:36,840
was PID 436. you can see it's listed

620
00:21:36,840 --> 00:21:39,419
here and then it's p traced and seized

621
00:21:39,419 --> 00:21:41,400
you then see I'm going to skip the SS

622
00:21:41,400 --> 00:21:43,860
Trace process for a second you then see

623
00:21:43,860 --> 00:21:46,140
more sshd processes those are the

624
00:21:46,140 --> 00:21:48,000
children processes that are spawned to

625
00:21:48,000 --> 00:21:50,280
handle when someone logs in and then

626
00:21:50,280 --> 00:21:52,440
once you successfully authenticate bash

627
00:21:52,440 --> 00:21:54,419
or whichever shell you use will get

628
00:21:54,419 --> 00:21:56,100
spawned and you can see that's being

629
00:21:56,100 --> 00:21:58,799
debugged also so then if we look at the

630
00:21:58,799 --> 00:22:01,980
the s-trace process we see it's 11 27

631
00:22:01,980 --> 00:22:04,620
and the tracing column has all the pids

632
00:22:04,620 --> 00:22:06,480
that it's attacking right or that it's

633
00:22:06,480 --> 00:22:08,640
monitoring and then if we have many SSH

634
00:22:08,640 --> 00:22:10,679
sessions going on like on a real server

635
00:22:10,679 --> 00:22:12,360
the amount of pids is just going to go

636
00:22:12,360 --> 00:22:14,520
on forever and then just if you're not

637
00:22:14,520 --> 00:22:16,679
familiar with Linux what sees means it's

638
00:22:16,679 --> 00:22:18,120
actually really important in the output

639
00:22:18,120 --> 00:22:21,000
that means a process was running and a

640
00:22:21,000 --> 00:22:22,559
debugger attached to it while it was

641
00:22:22,559 --> 00:22:25,080
still active or when a process started

642
00:22:25,080 --> 00:22:26,760
it's basically a victim from the start

643
00:22:26,760 --> 00:22:28,440
because its parent process was being

644
00:22:28,440 --> 00:22:30,059
debugged so it's definitely something

645
00:22:30,059 --> 00:22:33,440
that we want to key in on

646
00:22:34,559 --> 00:22:36,720
another place we looked in Linux was

647
00:22:36,720 --> 00:22:39,059
input events so this is a really handy

648
00:22:39,059 --> 00:22:41,159
feature for legitimate uses it's pretty

649
00:22:41,159 --> 00:22:43,440
cool what it makes available but it also

650
00:22:43,440 --> 00:22:45,120
gets abused by malware just like

651
00:22:45,120 --> 00:22:47,580
everything else so the way this works is

652
00:22:47,580 --> 00:22:49,860
if you look in the dev input bypass

653
00:22:49,860 --> 00:22:51,659
folder on a Linux machine where this is

654
00:22:51,659 --> 00:22:53,340
enabled which if you have like Ubuntu

655
00:22:53,340 --> 00:22:55,200
Debian any normal distro it's going to

656
00:22:55,200 --> 00:22:57,539
be there and basically it makes a Sim

657
00:22:57,539 --> 00:23:00,539
link file out to that physical device so

658
00:23:00,539 --> 00:23:01,860
in this case we can see that the

659
00:23:01,860 --> 00:23:05,340
keyboard is Sim link to event zero and

660
00:23:05,340 --> 00:23:07,860
there's an API you can call that is it's

661
00:23:07,860 --> 00:23:09,900
literally like 10 lines of code to read

662
00:23:09,900 --> 00:23:11,940
this device constantly and pull that

663
00:23:11,940 --> 00:23:14,159
device and then get anything sent to it

664
00:23:14,159 --> 00:23:15,840
which it's the keyboard so you're going

665
00:23:15,840 --> 00:23:18,299
to be sending keystrokes to it so we

666
00:23:18,299 --> 00:23:20,700
wrote a new plugin to detect processes

667
00:23:20,700 --> 00:23:22,740
that were using this subsystem it's

668
00:23:22,740 --> 00:23:25,080
called Linux input event input events

669
00:23:25,080 --> 00:23:27,600
and you're seeing the output here so one

670
00:23:27,600 --> 00:23:29,760
thing to be aware of is the login Daemon

671
00:23:29,760 --> 00:23:31,620
from systemd is going to use this that's

672
00:23:31,620 --> 00:23:33,419
legitimate right it's monitoring your

673
00:23:33,419 --> 00:23:35,100
keyboard so you can log into the system

674
00:23:35,100 --> 00:23:38,520
so that's expected but then we loaded we

675
00:23:38,520 --> 00:23:39,659
didn't really write our own proof of

676
00:23:39,659 --> 00:23:41,159
concept for this one there's a project

677
00:23:41,159 --> 00:23:43,440
called log keys on GitHub that's like a

678
00:23:43,440 --> 00:23:45,000
proof of concept for abusing this

679
00:23:45,000 --> 00:23:47,520
subsystem so we loaded that in our VM

680
00:23:47,520 --> 00:23:49,620
got the memory sample and then you can

681
00:23:49,620 --> 00:23:51,780
see we are reporting it so in a real

682
00:23:51,780 --> 00:23:53,520
investigation it would be as simple as

683
00:23:53,520 --> 00:23:55,260
filtering out the system Daemon login

684
00:23:55,260 --> 00:23:57,240
process which is like I said gonna

685
00:23:57,240 --> 00:24:00,000
access your keys so you can log in and

686
00:24:00,000 --> 00:24:03,799
then anything else is definitely suspect

687
00:24:07,380 --> 00:24:10,380
foreign

688
00:24:12,240 --> 00:24:14,159
the next thing we looked at is a feature

689
00:24:14,159 --> 00:24:16,140
of Linux that is just mind-blowingly

690
00:24:16,140 --> 00:24:18,960
painful from a security perspective so I

691
00:24:18,960 --> 00:24:20,520
tried to highlight in the slide just how

692
00:24:20,520 --> 00:24:23,340
ridiculous this is so the idea is you

693
00:24:23,340 --> 00:24:25,740
have an in and out control call which is

694
00:24:25,740 --> 00:24:27,900
a subsystem it exists on Windows and Mac

695
00:24:27,900 --> 00:24:30,480
and every other operating system where

696
00:24:30,480 --> 00:24:32,580
code so code running in an application

697
00:24:32,580 --> 00:24:34,980
can ask a driver to do something for it

698
00:24:34,980 --> 00:24:36,480
because you can imagine your process

699
00:24:36,480 --> 00:24:38,580
can't just go read the file system or

700
00:24:38,580 --> 00:24:40,679
send raw packets so you can use this

701
00:24:40,679 --> 00:24:42,539
ability to ask the more privileged

702
00:24:42,539 --> 00:24:44,880
driver to do something for you so for

703
00:24:44,880 --> 00:24:46,440
whatever reason that doesn't make any

704
00:24:46,440 --> 00:24:49,260
sense Linux has one of these requests

705
00:24:49,260 --> 00:24:51,419
that you can make that says hey for

706
00:24:51,419 --> 00:24:53,520
another terminal that's not mine so

707
00:24:53,520 --> 00:24:56,039
someone else logged into the machine I

708
00:24:56,039 --> 00:24:58,080
want to inject a character into their

709
00:24:58,080 --> 00:25:00,360
terminals input stream which translated

710
00:25:00,360 --> 00:25:02,220
from Linux terms means I want to fake

711
00:25:02,220 --> 00:25:04,559
keystrokes for them which is like

712
00:25:04,559 --> 00:25:06,840
mind-blowingly crazy right so when you

713
00:25:06,840 --> 00:25:08,340
Google this instead of getting any

714
00:25:08,340 --> 00:25:10,679
documentation on it the first 10 links

715
00:25:10,679 --> 00:25:12,000
are about all the vulnerabilities that

716
00:25:12,000 --> 00:25:14,100
have been caused by this all of the

717
00:25:14,100 --> 00:25:17,159
attacks that were propagated by this and

718
00:25:17,159 --> 00:25:19,500
finally open BSD removed it so they

719
00:25:19,500 --> 00:25:20,580
didn't even try for backwards

720
00:25:20,580 --> 00:25:22,380
compatibility if you make that call on

721
00:25:22,380 --> 00:25:25,260
openbsd the call is going to fail but

722
00:25:25,260 --> 00:25:27,779
the Linux developers refuse to do it so

723
00:25:27,779 --> 00:25:29,400
especially in those shared environments

724
00:25:29,400 --> 00:25:32,640
this is a major issue

725
00:25:32,640 --> 00:25:35,279
and what's cool from a like a red team

726
00:25:35,279 --> 00:25:37,140
perspective is you can use this for a

727
00:25:37,140 --> 00:25:39,000
dead simple key logger what you're

728
00:25:39,000 --> 00:25:41,340
seeing on the left is the entire source

729
00:25:41,340 --> 00:25:42,960
code for our proof of concept we wrote

730
00:25:42,960 --> 00:25:45,059
it in Python so it's a little easier to

731
00:25:45,059 --> 00:25:47,520
understand what you do is you open a

732
00:25:47,520 --> 00:25:50,220
handle to another user's terminal

733
00:25:50,220 --> 00:25:52,260
you're then going to set Raw on it which

734
00:25:52,260 --> 00:25:53,640
means you want to deal with the raw

735
00:25:53,640 --> 00:25:55,919
characters going in and then you're

736
00:25:55,919 --> 00:25:57,600
going to read from that terminal right

737
00:25:57,600 --> 00:25:59,400
so if you read from someone's terminal

738
00:25:59,400 --> 00:26:01,500
and they type a key you're basically

739
00:26:01,500 --> 00:26:03,840
going to steal that key out that would

740
00:26:03,840 --> 00:26:05,940
be bad because it the user would notice

741
00:26:05,940 --> 00:26:07,440
their typing and nothing's happening and

742
00:26:07,440 --> 00:26:09,539
nothing's showing up on the screen so

743
00:26:09,539 --> 00:26:10,980
what you do is you read the latest

744
00:26:10,980 --> 00:26:13,380
character they typed and then you use

745
00:26:13,380 --> 00:26:15,960
which you can see in the ioctl call the

746
00:26:15,960 --> 00:26:17,220
last thing that's highlighted in the red

747
00:26:17,220 --> 00:26:20,100
box we're making that call to say hey

748
00:26:20,100 --> 00:26:22,200
take the character I just read and

749
00:26:22,200 --> 00:26:24,360
retype it for the user so even if you're

750
00:26:24,360 --> 00:26:25,860
a super fast typer you're not going to

751
00:26:25,860 --> 00:26:27,779
notice that your character is being

752
00:26:27,779 --> 00:26:29,880
stolen and replayed back and forth but

753
00:26:29,880 --> 00:26:31,740
we can perfectly key log all of their

754
00:26:31,740 --> 00:26:34,140
interactions through SSH or through a

755
00:26:34,140 --> 00:26:35,820
physical keyboard on a Linux machine

756
00:26:35,820 --> 00:26:37,679
they're getting key log the whole time

757
00:26:37,679 --> 00:26:38,940
and they will never notice the

758
00:26:38,940 --> 00:26:41,279
difference so again we wanted to be able

759
00:26:41,279 --> 00:26:44,940
to detect this in an automated fashion

760
00:26:44,940 --> 00:26:47,220
so we wrote a plug-in called Linux TTY

761
00:26:47,220 --> 00:26:49,740
handles and what we're seeing here is

762
00:26:49,740 --> 00:26:51,659
like like I said our proof of Concepts

763
00:26:51,659 --> 00:26:54,059
in Python so we're catching the python

764
00:26:54,059 --> 00:26:56,580
process that's doing this and the way

765
00:26:56,580 --> 00:26:58,260
our detection works and you'll see it if

766
00:26:58,260 --> 00:27:00,360
you read the plug-in source code is we

767
00:27:00,360 --> 00:27:02,159
look at the console that our process was

768
00:27:02,159 --> 00:27:04,140
spawned on so which user it was spawn

769
00:27:04,140 --> 00:27:06,120
for and then we see if it has an open

770
00:27:06,120 --> 00:27:08,880
handle to another process and at first

771
00:27:08,880 --> 00:27:10,320
we weren't sure like maybe this would

772
00:27:10,320 --> 00:27:11,760
have false positives or something like

773
00:27:11,760 --> 00:27:13,919
that we ran it over the couple hundred

774
00:27:13,919 --> 00:27:15,960
memory samples we had easy access to

775
00:27:15,960 --> 00:27:17,820
from the wild and everything there

776
00:27:17,820 --> 00:27:19,320
wasn't one false positive because why

777
00:27:19,320 --> 00:27:20,880
would you ever you know legitimately

778
00:27:20,880 --> 00:27:22,679
want to spy on someone else's terminal

779
00:27:22,679 --> 00:27:25,440
so it's a pretty very it's a very nice

780
00:27:25,440 --> 00:27:27,600
indicator that something's wrong and

781
00:27:27,600 --> 00:27:30,480
then I just ran the PSA ux plugin which

782
00:27:30,480 --> 00:27:31,980
shows you the command line arguments

783
00:27:31,980 --> 00:27:33,840
because again for the process name we're

784
00:27:33,840 --> 00:27:35,820
just seeing python but then if you look

785
00:27:35,820 --> 00:27:37,860
at the arguments it's another project on

786
00:27:37,860 --> 00:27:40,740
GitHub called SSH keylogger that abuses

787
00:27:40,740 --> 00:27:43,380
this facility that that one is kind of

788
00:27:43,380 --> 00:27:44,940
complex we we just broke down the

789
00:27:44,940 --> 00:27:47,400
functionality so it fit on a slide but

790
00:27:47,400 --> 00:27:50,539
we're still key logging there

791
00:27:58,679 --> 00:28:00,419
and then the last thing we looked at was

792
00:28:00,419 --> 00:28:02,700
Mac on Mac you have what are called

793
00:28:02,700 --> 00:28:05,100
event Taps and what this means is you

794
00:28:05,100 --> 00:28:07,740
can tap the hardware devices so you can

795
00:28:07,740 --> 00:28:09,600
tap the keyboard tap the mouse whatever

796
00:28:09,600 --> 00:28:11,940
it is you want to Target it's somewhat

797
00:28:11,940 --> 00:28:14,220
similar to set Windows hook EX in that

798
00:28:14,220 --> 00:28:15,840
you tell it the function you want to be

799
00:28:15,840 --> 00:28:18,299
called when a key is pressed so that you

800
00:28:18,299 --> 00:28:20,580
can steal it but this is built into Mac

801
00:28:20,580 --> 00:28:23,400
there's a cool tool from Patrick Wardle

802
00:28:23,400 --> 00:28:25,740
one of his free security tools that will

803
00:28:25,740 --> 00:28:27,539
monitor the live system for when these

804
00:28:27,539 --> 00:28:29,159
are registered so I run this on my

805
00:28:29,159 --> 00:28:31,080
laptop 24 7 because these are very

806
00:28:31,080 --> 00:28:32,880
dangerous but we want to be able to

807
00:28:32,880 --> 00:28:34,500
detect it from the memory forensics

808
00:28:34,500 --> 00:28:37,400
perspective as well

809
00:28:37,559 --> 00:28:39,779
for this proof of concept we used

810
00:28:39,779 --> 00:28:41,700
another we took another project from

811
00:28:41,700 --> 00:28:43,679
GitHub and modified it to work well in

812
00:28:43,679 --> 00:28:45,480
our environment I have the link down

813
00:28:45,480 --> 00:28:47,520
here at the bottom to it but what we're

814
00:28:47,520 --> 00:28:49,740
doing here is we're getting set up to

815
00:28:49,740 --> 00:28:52,020
call the create tap function we're

816
00:28:52,020 --> 00:28:53,580
saying that we want to monitor the

817
00:28:53,580 --> 00:28:55,500
keyboard and that we want to monitor the

818
00:28:55,500 --> 00:28:57,600
flags and the flag the flags are

819
00:28:57,600 --> 00:28:58,679
important because that's going to tell

820
00:28:58,679 --> 00:29:00,659
you is caps lock one is shift key being

821
00:29:00,659 --> 00:29:02,220
held down because if you're trying to

822
00:29:02,220 --> 00:29:04,140
steal credentials you need to know that

823
00:29:04,140 --> 00:29:05,760
specific information

824
00:29:05,760 --> 00:29:08,400
so once our event tab is created we're

825
00:29:08,400 --> 00:29:10,620
going to add it to a run Loop which is a

826
00:29:10,620 --> 00:29:12,419
very technical part of Mac that just

827
00:29:12,419 --> 00:29:14,820
says I want to hook every process so

828
00:29:14,820 --> 00:29:16,860
just from this very simple code our

829
00:29:16,860 --> 00:29:18,779
keylogger is going to be put into every

830
00:29:18,779 --> 00:29:21,240
process that code will be

831
00:29:21,240 --> 00:29:23,580
placed into there and then from then on

832
00:29:23,580 --> 00:29:26,520
we'll get every keystroke possible

833
00:29:26,520 --> 00:29:29,100
now reverse engineering this what was

834
00:29:29,100 --> 00:29:30,600
summarized in like two minutes on that

835
00:29:30,600 --> 00:29:32,820
slide was extremely difficult one of the

836
00:29:32,820 --> 00:29:34,679
most painful reversing tasks I've taken

837
00:29:34,679 --> 00:29:37,380
on because Mac works very differently

838
00:29:37,380 --> 00:29:41,039
than Windows or Linux Mac in its xnu

839
00:29:41,039 --> 00:29:42,899
kernel tries to be like a micro kernel

840
00:29:42,899 --> 00:29:44,399
which if you're not familiar with that

841
00:29:44,399 --> 00:29:46,679
says the kernel should only do the bare

842
00:29:46,679 --> 00:29:48,659
minimal minimum so what's in that

843
00:29:48,659 --> 00:29:50,399
privileged space that can access all the

844
00:29:50,399 --> 00:29:52,679
hardware should be very very small and

845
00:29:52,679 --> 00:29:54,899
this is good from a security perspective

846
00:29:54,899 --> 00:29:56,760
but it makes memory of forensics and

847
00:29:56,760 --> 00:29:59,100
reversing very strange because instead

848
00:29:59,100 --> 00:30:00,659
of being able to just look in the kernel

849
00:30:00,659 --> 00:30:02,880
and the process you're analyzing you

850
00:30:02,880 --> 00:30:04,200
have to then go look at some other

851
00:30:04,200 --> 00:30:05,760
process that's actually doing the hard

852
00:30:05,760 --> 00:30:08,100
work and there's no equivalent to that

853
00:30:08,100 --> 00:30:10,440
in any other operating system that we

854
00:30:10,440 --> 00:30:12,480
deal with so after a good bit of

855
00:30:12,480 --> 00:30:14,700
reversing we figured out that when you

856
00:30:14,700 --> 00:30:17,120
call the CG event tab create function

857
00:30:17,120 --> 00:30:19,860
inside of your process is going to be

858
00:30:19,860 --> 00:30:21,659
the Skylight Library so that's what's

859
00:30:21,659 --> 00:30:23,100
going to implement a lot of the GUI

860
00:30:23,100 --> 00:30:25,200
stuff and then we figured out that that

861
00:30:25,200 --> 00:30:28,140
eventually goes to CG replace tab and

862
00:30:28,140 --> 00:30:29,940
then inside the kernel all that does

863
00:30:29,940 --> 00:30:32,399
it's like two lines of code in either or

864
00:30:32,399 --> 00:30:34,679
just a few instructions all it does is

865
00:30:34,679 --> 00:30:37,080
call Mac message inside the kernel with

866
00:30:37,080 --> 00:30:39,059
a hard-coded value so you're reversing

867
00:30:39,059 --> 00:30:40,559
and you have literally no idea what that

868
00:30:40,559 --> 00:30:42,539
means it's completely useless to look at

869
00:30:42,539 --> 00:30:44,640
that so we had to figure out where is

870
00:30:44,640 --> 00:30:46,860
that actually reaching on the other end

871
00:30:46,860 --> 00:30:49,440
so then we figured out in the Skylight

872
00:30:49,440 --> 00:30:52,080
library that for every underscore CG

873
00:30:52,080 --> 00:30:54,000
function which is the one that the

874
00:30:54,000 --> 00:30:55,620
processes are going to call so like the

875
00:30:55,620 --> 00:30:58,020
key loggers are going to use inside that

876
00:30:58,020 --> 00:30:59,820
same library is a companion function

877
00:30:59,820 --> 00:31:02,100
that starts with underscore X and as

878
00:31:02,100 --> 00:31:03,240
soon as we figured that out which was

879
00:31:03,240 --> 00:31:05,640
multiple days later it was very easy to

880
00:31:05,640 --> 00:31:07,080
do it because you see the function

881
00:31:07,080 --> 00:31:08,700
that's being called and you see the

882
00:31:08,700 --> 00:31:11,460
Handler so with that we wrote a plug-in

883
00:31:11,460 --> 00:31:14,520
that can see these calls going into

884
00:31:14,520 --> 00:31:16,380
Windows server

885
00:31:16,380 --> 00:31:18,240
once the Windows server has that

886
00:31:18,240 --> 00:31:19,980
registered then every time a key is

887
00:31:19,980 --> 00:31:21,539
pressed or the mouse is used whatever it

888
00:31:21,539 --> 00:31:23,580
is that the malware was interested in

889
00:31:23,580 --> 00:31:25,500
it's going to pass it back through the

890
00:31:25,500 --> 00:31:27,240
kernel back to whichever process is

891
00:31:27,240 --> 00:31:30,059
doing the key logger so we then realized

892
00:31:30,059 --> 00:31:31,200
that was kind of interesting because

893
00:31:31,200 --> 00:31:33,179
there's two places we can look to find

894
00:31:33,179 --> 00:31:35,279
this type of malware we can look inside

895
00:31:35,279 --> 00:31:37,020
the key logger process it's going to

896
00:31:37,020 --> 00:31:38,940
have the malicious function it's going

897
00:31:38,940 --> 00:31:40,679
to have information on how it registered

898
00:31:40,679 --> 00:31:43,020
it hook it's hooked and then we can also

899
00:31:43,020 --> 00:31:44,940
look at the Windows Server process just

900
00:31:44,940 --> 00:31:46,919
to get a global list of all of the key

901
00:31:46,919 --> 00:31:48,840
loggers

902
00:31:48,840 --> 00:31:51,000
so instead of showing you assembly I use

903
00:31:51,000 --> 00:31:53,580
the decompiler for a quick view but we

904
00:31:53,580 --> 00:31:54,960
realized when we found the correct

905
00:31:54,960 --> 00:31:57,419
function that X plays tap what happens

906
00:31:57,419 --> 00:32:00,899
is memory is allocated I named it cgx

907
00:32:00,899 --> 00:32:02,340
event tap because we figured out that's

908
00:32:02,340 --> 00:32:03,720
what the data structure was when we were

909
00:32:03,720 --> 00:32:05,940
in Ida and then you can see once that

910
00:32:05,940 --> 00:32:07,980
new data structure is created it's

911
00:32:07,980 --> 00:32:10,440
pointed to a global variable called cgx

912
00:32:10,440 --> 00:32:12,840
event tap Master list and then that

913
00:32:12,840 --> 00:32:14,399
Master list is getting pointed to the

914
00:32:14,399 --> 00:32:15,960
new tab and if you're familiar with

915
00:32:15,960 --> 00:32:17,520
programming that's how linked lists are

916
00:32:17,520 --> 00:32:19,620
set up and the plugin was

917
00:32:19,620 --> 00:32:21,480
straightforward at that point so we have

918
00:32:21,480 --> 00:32:23,760
a new plugin called Mac event Taps it

919
00:32:23,760 --> 00:32:25,380
looks inside of the Windows Server

920
00:32:25,380 --> 00:32:27,720
process it finds this event tap Master

921
00:32:27,720 --> 00:32:29,640
list and then it just prints out all the

922
00:32:29,640 --> 00:32:31,799
entries and this is another one where on

923
00:32:31,799 --> 00:32:33,480
a clean system you shouldn't have any

924
00:32:33,480 --> 00:32:35,340
key loggers active or things monitoring

925
00:32:35,340 --> 00:32:37,799
other Hardware devices why would you so

926
00:32:37,799 --> 00:32:39,299
you can see in this case the plugins

927
00:32:39,299 --> 00:32:40,919
reporting the fact that we found a key

928
00:32:40,919 --> 00:32:42,899
logger the PID and then what it's

929
00:32:42,899 --> 00:32:45,439
looking for

930
00:32:45,600 --> 00:32:48,120
so in conclusion we did a pretty

931
00:32:48,120 --> 00:32:50,100
thorough analysis on all the malware

932
00:32:50,100 --> 00:32:52,140
that will monitor Hardware devices and

933
00:32:52,140 --> 00:32:53,700
steal all the data

934
00:32:53,700 --> 00:32:55,620
I mentioned it before but if you came in

935
00:32:55,620 --> 00:32:56,940
late and I think we were just kind of

936
00:32:56,940 --> 00:32:59,159
talking on the side besides the slides

937
00:32:59,159 --> 00:33:00,600
where you have some pictures and some

938
00:33:00,600 --> 00:33:02,640
data I think they published tomorrow

939
00:33:02,640 --> 00:33:04,919
morning you'll have a copy of these

940
00:33:04,919 --> 00:33:06,779
slides as well as a white paper that

941
00:33:06,779 --> 00:33:09,000
turned out to be like 35 pages of all

942
00:33:09,000 --> 00:33:10,559
the Ida screenshots all the really

943
00:33:10,559 --> 00:33:12,539
technical details so if you want the

944
00:33:12,539 --> 00:33:14,159
full Deep dive on anything I talked

945
00:33:14,159 --> 00:33:16,260
about check out the white paper when it

946
00:33:16,260 --> 00:33:18,919
goes online

947
00:33:19,080 --> 00:33:22,460
so thank you all for coming

948
00:33:22,460 --> 00:33:25,569
[Music]

949
00:33:29,420 --> 00:33:32,519
[Music]

