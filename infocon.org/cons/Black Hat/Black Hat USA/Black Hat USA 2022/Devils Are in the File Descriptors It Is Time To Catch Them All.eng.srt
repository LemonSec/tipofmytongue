1
00:00:01,730 --> 00:00:03,720
[Music]

2
00:00:03,720 --> 00:00:06,720
foreign

3
00:00:11,840 --> 00:00:15,719
Security in this talk I will present my

4
00:00:15,719 --> 00:00:17,699
research about the vulnerabilities

5
00:00:17,699 --> 00:00:21,060
related to the five describers I will

6
00:00:21,060 --> 00:00:24,480
discuss how to find them fix them and

7
00:00:24,480 --> 00:00:26,880
some exploit methods are also included

8
00:00:26,880 --> 00:00:28,920
in the slides

9
00:00:28,920 --> 00:00:31,920
and here are some introductions about me

10
00:00:31,920 --> 00:00:35,160
I am interested in Android Linux

11
00:00:35,160 --> 00:00:38,700
accounting and exploit I found over 200

12
00:00:38,700 --> 00:00:40,820
vulnerabilities in the last two years

13
00:00:40,820 --> 00:00:43,559
and I am also a speaker of blackhead

14
00:00:43,559 --> 00:00:45,239
Asia this year

15
00:00:45,239 --> 00:00:47,839
foreign

16
00:00:49,460 --> 00:00:52,800
of my talk first of all I will give some

17
00:00:52,800 --> 00:00:55,739
background on what a file describer is

18
00:00:55,739 --> 00:00:58,680
and why I do research about it after

19
00:00:58,680 --> 00:01:01,500
that I will dive into the issues in the

20
00:01:01,500 --> 00:01:04,500
FD export and FD import operations

21
00:01:04,500 --> 00:01:08,040
separately At Last I will give a summary

22
00:01:08,040 --> 00:01:10,860
and discuss the future work

23
00:01:10,860 --> 00:01:13,439
so let's have a look at what a file

24
00:01:13,439 --> 00:01:16,080
descriptor is

25
00:01:16,080 --> 00:01:18,720
we all know that everything is a file in

26
00:01:18,720 --> 00:01:21,240
Linux so file descriptors are almost

27
00:01:21,240 --> 00:01:24,600
everywhere in Linux a file descriptor is

28
00:01:24,600 --> 00:01:28,500
an integer that identifies an open file

29
00:01:28,500 --> 00:01:29,880
in a process

30
00:01:29,880 --> 00:01:32,340
there could be many file describers in

31
00:01:32,340 --> 00:01:34,920
the process and the value of A5

32
00:01:34,920 --> 00:01:39,180
descriptor could be 0 1 2 and so on

33
00:01:39,180 --> 00:01:41,460
all the threads in the process can

34
00:01:41,460 --> 00:01:44,579
operate the FD through this course like

35
00:01:44,579 --> 00:01:48,180
read write and so on normally every file

36
00:01:48,180 --> 00:01:51,360
described is associated with a fire

37
00:01:51,360 --> 00:01:53,280
object in kernel space

38
00:01:53,280 --> 00:01:57,240
when we operate an FD in user space the

39
00:01:57,240 --> 00:02:00,240
associated file object will be operated

40
00:02:00,240 --> 00:02:04,039
accordingly in kernel space

41
00:02:05,180 --> 00:02:09,300
to record record the mapping between the

42
00:02:09,300 --> 00:02:13,020
FD and the the file object and FD array

43
00:02:13,020 --> 00:02:15,959
is created in each process

44
00:02:15,959 --> 00:02:19,140
the FD array is an array of file object

45
00:02:19,140 --> 00:02:20,459
pointers

46
00:02:20,459 --> 00:02:24,720
and the index of FD array is FD so we

47
00:02:24,720 --> 00:02:27,480
can use it easily know which file object

48
00:02:27,480 --> 00:02:32,840
is associated with a specific FD

49
00:02:34,080 --> 00:02:36,540
kernel needs to handle the translation

50
00:02:36,540 --> 00:02:41,040
between fire object and FD frequently on

51
00:02:41,040 --> 00:02:43,379
the one hand kernel needs to export a

52
00:02:43,379 --> 00:02:47,700
file object as NFD to user process so

53
00:02:47,700 --> 00:02:50,940
the Euro process can operate the FD for

54
00:02:50,940 --> 00:02:55,140
read or write the translation from file

55
00:02:55,140 --> 00:02:58,620
object to FD is finished through the FDX

56
00:02:58,620 --> 00:03:00,840
Port operation

57
00:03:00,840 --> 00:03:03,599
on the other hand kernel needs to import

58
00:03:03,599 --> 00:03:07,319
import the FD to find the associated

59
00:03:07,319 --> 00:03:10,200
file object for further operations in

60
00:03:10,200 --> 00:03:13,500
this course the translation from FD to

61
00:03:13,500 --> 00:03:16,500
file object is finished through the FD

62
00:03:16,500 --> 00:03:19,019
import operation

63
00:03:19,019 --> 00:03:22,080
the FDX port and import operations are

64
00:03:22,080 --> 00:03:24,840
very common and basic operations in

65
00:03:24,840 --> 00:03:26,239
kernel

66
00:03:26,239 --> 00:03:29,340
so let's have a look at the FDX post

67
00:03:29,340 --> 00:03:32,120
operation first

68
00:03:32,120 --> 00:03:36,000
the FD export operation in kernel is

69
00:03:36,000 --> 00:03:38,760
divided into three steps for example

70
00:03:38,760 --> 00:03:42,360
here is a file object X

71
00:03:42,360 --> 00:03:47,879
and we want to export it as NFD

72
00:03:47,879 --> 00:03:51,000
the first step is to get an unused FD

73
00:03:51,000 --> 00:03:53,840
which is X

74
00:03:54,299 --> 00:03:57,480
second step is to set up the FD array to

75
00:03:57,480 --> 00:04:00,120
make sure the element of FD array

76
00:04:00,120 --> 00:04:03,840
indexed by the FD point to the file

77
00:04:03,840 --> 00:04:06,200
object

78
00:04:06,239 --> 00:04:09,840
the last step is to pass the FD to user

79
00:04:09,840 --> 00:04:11,400
process

80
00:04:11,400 --> 00:04:14,640
after these three step steps the FD

81
00:04:14,640 --> 00:04:17,519
export operation is finished and the

82
00:04:17,519 --> 00:04:20,279
user process can operate the FD for

83
00:04:20,279 --> 00:04:23,419
reading or writing

84
00:04:23,639 --> 00:04:26,220
the FD import operation in kernel is

85
00:04:26,220 --> 00:04:30,360
divided into two steps for example here

86
00:04:30,360 --> 00:04:34,919
is NFD which is X and we want to import

87
00:04:34,919 --> 00:04:35,940
it

88
00:04:35,940 --> 00:04:38,639
the first step is to look up the FD

89
00:04:38,639 --> 00:04:41,639
array to get the file object

90
00:04:41,639 --> 00:04:44,759
the second second step is to acquire

91
00:04:44,759 --> 00:04:46,320
file reference

92
00:04:46,320 --> 00:04:48,780
after these two steps the FD import

93
00:04:48,780 --> 00:04:51,419
operation is finished and kernel can

94
00:04:51,419 --> 00:04:54,919
operate the file object

95
00:04:56,699 --> 00:05:00,000
let's make a summary the FD export

96
00:05:00,000 --> 00:05:03,000
operation is down in Three Steps step

97
00:05:03,000 --> 00:05:07,259
one get an unused FD step to set up set

98
00:05:07,259 --> 00:05:11,100
up the fdre step 3 pass the FD to user

99
00:05:11,100 --> 00:05:14,340
space and the FD import operation is

100
00:05:14,340 --> 00:05:17,759
down in Two Steps step one look up the

101
00:05:17,759 --> 00:05:20,699
FD array to find the file object step

102
00:05:20,699 --> 00:05:23,280
two acquire file reference

103
00:05:23,280 --> 00:05:24,440
thank you

104
00:05:24,440 --> 00:05:27,259
we also need to know another FD related

105
00:05:27,259 --> 00:05:30,660
operation which is close FD when we

106
00:05:30,660 --> 00:05:34,199
close NFD the element of FD array

107
00:05:34,199 --> 00:05:38,039
indexed by the FD will be set to now

108
00:05:38,039 --> 00:05:41,039
and then the reference of the associated

109
00:05:41,039 --> 00:05:44,880
file object will be dropped and the FD

110
00:05:44,880 --> 00:05:47,960
will become only used

111
00:05:49,500 --> 00:05:51,840
after understanding some basic knowledge

112
00:05:51,840 --> 00:05:54,600
of file describers let's talk about why

113
00:05:54,600 --> 00:05:57,419
I research file describers

114
00:05:57,419 --> 00:06:00,479
uh they research is inspired by an

115
00:06:00,479 --> 00:06:02,580
interesting vulnerability I found last

116
00:06:02,580 --> 00:06:08,340
year which is the severe 2021 0929

117
00:06:08,340 --> 00:06:11,460
as you can see that thread B uh creates

118
00:06:11,460 --> 00:06:14,820
a DME buff FD with ion

119
00:06:14,820 --> 00:06:18,120
uh this DME buff FD is passed to Kernel

120
00:06:18,120 --> 00:06:22,080
space and then in thread a kernel impose

121
00:06:22,080 --> 00:06:25,380
the game above FD and create an ion

122
00:06:25,380 --> 00:06:26,639
handle object

123
00:06:26,639 --> 00:06:29,520
after that the memory buffer represented

124
00:06:29,520 --> 00:06:31,979
by the i o handle gets mapped into

125
00:06:31,979 --> 00:06:35,460
kernel space as kernel virtual drawer

126
00:06:35,460 --> 00:06:37,979
uh Connor would reference the kernel

127
00:06:37,979 --> 00:06:41,160
virtual draw later but in thread B it

128
00:06:41,160 --> 00:06:44,340
can trigger the on map of of the kernel

129
00:06:44,340 --> 00:06:47,280
virtual drawer as a result uh use after

130
00:06:47,280 --> 00:06:51,559
3 will happen in this risk condition

131
00:06:53,039 --> 00:06:58,139
the CV 2021 0929 gave me a really

132
00:06:58,139 --> 00:07:01,319
important hint a file describe tool can

133
00:07:01,319 --> 00:07:03,840
be shared between kernel space and user

134
00:07:03,840 --> 00:07:04,800
space

135
00:07:04,800 --> 00:07:07,740
as a result risk conditions can happen

136
00:07:07,740 --> 00:07:10,440
between kernel and user operations

137
00:07:10,440 --> 00:07:12,900
and here are two kinds of risk

138
00:07:12,900 --> 00:07:16,099
conditions I can think of

139
00:07:16,860 --> 00:07:20,280
risk Edition one is like thread a is

140
00:07:20,280 --> 00:07:22,620
operating in the file object in kernel

141
00:07:22,620 --> 00:07:26,400
space while thread B is operating the FD

142
00:07:26,400 --> 00:07:28,860
in user space

143
00:07:28,860 --> 00:07:31,620
and the risk condition 2 is like thread

144
00:07:31,620 --> 00:07:34,380
a is operating the FD in kernel space

145
00:07:34,380 --> 00:07:37,979
while thread B is also operating the FD

146
00:07:37,979 --> 00:07:40,818
in user space

147
00:07:41,580 --> 00:07:45,060
and I I started to think that maybe

148
00:07:45,060 --> 00:07:47,280
there are more issues in these risk

149
00:07:47,280 --> 00:07:50,699
conditions and I should try to construct

150
00:07:50,699 --> 00:07:53,699
such risk conditions in the FD export

151
00:07:53,699 --> 00:07:57,080
and import operations

152
00:07:57,080 --> 00:08:00,660
so um let's dive into the issues in the

153
00:08:00,660 --> 00:08:04,759
FD export operation first

154
00:08:05,759 --> 00:08:08,039
I will talk about the four parts in this

155
00:08:08,039 --> 00:08:11,280
section including the scenario scenario

156
00:08:11,280 --> 00:08:14,160
of FD export operation uh use after free

157
00:08:14,160 --> 00:08:17,699
course by risk condition and how to find

158
00:08:17,699 --> 00:08:21,080
and fix the issues

159
00:08:21,300 --> 00:08:24,020
first first let's have a look at the

160
00:08:24,020 --> 00:08:27,539
comments common scenario of FD export

161
00:08:27,539 --> 00:08:30,539
operation usually user process would

162
00:08:30,539 --> 00:08:33,719
request a certain resource by opening a

163
00:08:33,719 --> 00:08:37,200
file and kernel we will create a file

164
00:08:37,200 --> 00:08:40,559
object representing the resource this

165
00:08:40,559 --> 00:08:44,159
file object would be exported as NFD

166
00:08:44,159 --> 00:08:47,160
through the F FDX Port operation I have

167
00:08:47,160 --> 00:08:48,120
mentioned

168
00:08:48,120 --> 00:08:51,300
after the user process knows the value

169
00:08:51,300 --> 00:08:54,959
ffd it will perform operations on FD

170
00:08:54,959 --> 00:08:57,859
through this course

171
00:08:59,279 --> 00:09:02,360
here is a typical example as you can see

172
00:09:02,360 --> 00:09:06,899
the implementation of Cisco open is the

173
00:09:06,899 --> 00:09:09,360
scenario we are talking about a file

174
00:09:09,360 --> 00:09:12,420
object is created and this file object

175
00:09:12,420 --> 00:09:16,019
gets exported as NFD to user process

176
00:09:16,019 --> 00:09:20,279
through the FDA exporter operation

177
00:09:20,279 --> 00:09:22,939
foreign

178
00:09:23,240 --> 00:09:26,279
export operation is executed

179
00:09:26,279 --> 00:09:27,540
sequentially

180
00:09:27,540 --> 00:09:29,880
which is still far from the risk

181
00:09:29,880 --> 00:09:32,279
conditions we want to see so let's

182
00:09:32,279 --> 00:09:35,040
review the scenario to make sure we are

183
00:09:35,040 --> 00:09:37,560
not missing something

184
00:09:37,560 --> 00:09:41,100
we know the FD export operation is down

185
00:09:41,100 --> 00:09:43,740
in three steps

186
00:09:43,740 --> 00:09:46,980
actually we already have the ability to

187
00:09:46,980 --> 00:09:49,920
perform the operations on FD right after

188
00:09:49,920 --> 00:09:53,279
step two because the FD has been

189
00:09:53,279 --> 00:09:56,100
associated with a valid file object in

190
00:09:56,100 --> 00:09:58,880
step two however we can only perform

191
00:09:58,880 --> 00:10:01,980
operations on FD after step three

192
00:10:01,980 --> 00:10:04,860
because we only know the value of FD

193
00:10:04,860 --> 00:10:07,260
after step three

194
00:10:07,260 --> 00:10:10,620
but hold on do we have to wait for FD to

195
00:10:10,620 --> 00:10:13,019
be passed from kernel to know the value

196
00:10:13,019 --> 00:10:14,519
of it

197
00:10:14,519 --> 00:10:16,500
the answer is no

198
00:10:16,500 --> 00:10:20,399
because FDA is predictable we can know

199
00:10:20,399 --> 00:10:24,779
the value of NFD in advance first FDA is

200
00:10:24,779 --> 00:10:27,660
assigned in ascending order for a new

201
00:10:27,660 --> 00:10:29,180
process

202
00:10:29,180 --> 00:10:33,300
fd012 are usually occupied three will be

203
00:10:33,300 --> 00:10:37,740
the next FD exported from kernel

204
00:10:37,740 --> 00:10:40,339
foreign

205
00:10:41,240 --> 00:10:44,640
five six and so on second FD will be

206
00:10:44,640 --> 00:10:48,060
reused after close as you can see uh the

207
00:10:48,060 --> 00:10:53,719
in this example the fd2 is equal to FD

208
00:10:54,300 --> 00:10:57,000
ever since we can know the value of fde

209
00:10:57,000 --> 00:10:59,160
of that in advance we can change the

210
00:10:59,160 --> 00:11:02,160
regular scenario of FDX Port operation

211
00:11:02,160 --> 00:11:06,060
to a parallel scenario Suppose there are

212
00:11:06,060 --> 00:11:10,019
two threads uh thread thread a performs

213
00:11:10,019 --> 00:11:12,600
the three steps of the FD export

214
00:11:12,600 --> 00:11:15,360
operation type B performs the operations

215
00:11:15,360 --> 00:11:19,800
on the FD right after step two

216
00:11:19,800 --> 00:11:23,040
we can see a Time window between step

217
00:11:23,040 --> 00:11:27,620
two and step 3 of FD export operation

218
00:11:27,839 --> 00:11:30,839
so if there are some operations on the

219
00:11:30,839 --> 00:11:34,200
fire object during this time window

220
00:11:34,200 --> 00:11:37,200
we will succeed in constructing the case

221
00:11:37,200 --> 00:11:39,839
of risk condition one

222
00:11:39,839 --> 00:11:42,360
as you can see that thread a is

223
00:11:42,360 --> 00:11:45,240
performing the operations operations on

224
00:11:45,240 --> 00:11:47,339
the file object and thread B is

225
00:11:47,339 --> 00:11:51,980
performing the operations on the FD

226
00:11:51,980 --> 00:11:54,839
in this scenario we can construct a

227
00:11:54,839 --> 00:11:57,660
potential use of the free case as you

228
00:11:57,660 --> 00:12:00,180
can see that thread B can close the FD

229
00:12:00,180 --> 00:12:03,060
right after thread thread a finishing

230
00:12:03,060 --> 00:12:05,820
step two the closed FD will trigger the

231
00:12:05,820 --> 00:12:08,339
release of file object and release the

232
00:12:08,339 --> 00:12:11,579
objects after that use after three would

233
00:12:11,579 --> 00:12:13,920
happen when thread a operates the file

234
00:12:13,920 --> 00:12:15,180
object

235
00:12:15,180 --> 00:12:18,060
however this use after free scenario is

236
00:12:18,060 --> 00:12:21,660
only based on our assumptions until now

237
00:12:21,660 --> 00:12:24,420
now we we still don't know if there are

238
00:12:24,420 --> 00:12:28,279
any actual cases in real world

239
00:12:28,279 --> 00:12:31,800
so I started to search for such issues

240
00:12:31,800 --> 00:12:34,860
in real world in order to search for the

241
00:12:34,860 --> 00:12:38,579
issues thoroughly I looked for all kinds

242
00:12:38,579 --> 00:12:41,160
of Kernel apis which performed the step

243
00:12:41,160 --> 00:12:44,820
two of FDA export operation here are the

244
00:12:44,820 --> 00:12:46,260
apis I found

245
00:12:46,260 --> 00:12:50,100
FD install is the most common API we can

246
00:12:50,100 --> 00:12:51,660
say in kernel

247
00:12:51,660 --> 00:12:54,600
and there are many other apis that wrap

248
00:12:54,600 --> 00:12:57,680
the FD in store

249
00:12:58,139 --> 00:13:01,200
based on these Econo apis I searched for

250
00:13:01,200 --> 00:13:03,360
the bug pattern in some vendors kernels

251
00:13:03,360 --> 00:13:06,480
and I quickly found two typical codes of

252
00:13:06,480 --> 00:13:08,820
debug pattern in the kernel of two

253
00:13:08,820 --> 00:13:12,120
vendors as you can see that the file all

254
00:13:12,120 --> 00:13:15,180
related objects gets gets referenced

255
00:13:15,180 --> 00:13:18,440
after the step two of FDX Port operation

256
00:13:18,440 --> 00:13:22,139
and this just proves that our assumption

257
00:13:22,139 --> 00:13:24,380
is correct

258
00:13:24,380 --> 00:13:27,839
so I spent more time searching for the

259
00:13:27,839 --> 00:13:30,180
bug pattern in many kernels and finally

260
00:13:30,180 --> 00:13:32,760
I found I found quite a few issues of

261
00:13:32,760 --> 00:13:34,980
debug pattern it turns out the bug

262
00:13:34,980 --> 00:13:37,680
pattern exists in both vendors kernels

263
00:13:37,680 --> 00:13:40,980
and Linux mainstream there are a few

264
00:13:40,980 --> 00:13:43,920
interesting facts we can see from these

265
00:13:43,920 --> 00:13:45,839
vulnerabilities

266
00:13:45,839 --> 00:13:49,260
first using DME buff is more likely to

267
00:13:49,260 --> 00:13:52,500
introduce such issues this is this is

268
00:13:52,500 --> 00:13:54,839
reasonable because the dma buff

269
00:13:54,839 --> 00:13:57,300
component is designed for sharing

270
00:13:57,300 --> 00:14:00,300
buffers across across multiple device

271
00:14:00,300 --> 00:14:04,620
drivers and subsystems so it exports the

272
00:14:04,620 --> 00:14:08,399
dma buff objects as as the ft to user

273
00:14:08,399 --> 00:14:10,880
space for the sharing purpose

274
00:14:10,880 --> 00:14:14,100
but unfortunately many drivers are not

275
00:14:14,100 --> 00:14:16,079
taking good care of the FDX Port

276
00:14:16,079 --> 00:14:20,100
operation resulting in use after free

277
00:14:20,100 --> 00:14:23,279
second I found the GPU driver

278
00:14:23,279 --> 00:14:27,600
say more likely to introduce such issues

279
00:14:27,600 --> 00:14:29,700
so I started to search for the bug

280
00:14:29,700 --> 00:14:33,000
pattern in many GPU drivers and finally

281
00:14:33,000 --> 00:14:36,959
I found two more vulnerabilities in the

282
00:14:36,959 --> 00:14:40,079
um melee GPU driver

283
00:14:40,079 --> 00:14:42,060
things are getting more interesting

284
00:14:42,060 --> 00:14:45,600
because many Android devices you use the

285
00:14:45,600 --> 00:14:50,160
melee driver and the meta driver can be

286
00:14:50,160 --> 00:14:54,740
accessed by untrust apps on Android

287
00:14:55,160 --> 00:14:57,600
uh so let's have a look at the

288
00:14:57,600 --> 00:15:01,399
vulnerability Savvy 2022

289
00:15:01,399 --> 00:15:04,860
28349 which is an end date I found in

290
00:15:04,860 --> 00:15:08,160
melee driver and it affects some older

291
00:15:08,160 --> 00:15:10,920
version of many driver some Android 10

292
00:15:10,920 --> 00:15:13,800
devices or vendors are still using the

293
00:15:13,800 --> 00:15:16,139
older versions of many driver so they

294
00:15:16,139 --> 00:15:19,880
are affected by the vulnerability

295
00:15:19,980 --> 00:15:26,519
the vulnerability cvu 2022 to 28350 is a

296
00:15:26,519 --> 00:15:29,459
real zero day I found a melee driver it

297
00:15:29,459 --> 00:15:32,760
existed in a version of melee driver and

298
00:15:32,760 --> 00:15:35,720
some Android 12 devices or vendors are

299
00:15:35,720 --> 00:15:38,940
affected for now the vulnerability has

300
00:15:38,940 --> 00:15:40,560
been fixed

301
00:15:40,560 --> 00:15:43,160
foreign

302
00:15:45,199 --> 00:15:48,180
exploit of this vulnerability actually

303
00:15:48,180 --> 00:15:52,019
before my exploit exploit a no exploited

304
00:15:52,019 --> 00:15:55,440
method has been given by Matthias across

305
00:15:55,440 --> 00:15:57,300
from Geo security for a similar

306
00:15:57,300 --> 00:16:00,540
vulnerability with this method we can

307
00:16:00,540 --> 00:16:02,880
finish reading or writing privileged

308
00:16:02,880 --> 00:16:05,399
files from unprivileged privileged

309
00:16:05,399 --> 00:16:07,920
processes without worrying about

310
00:16:07,920 --> 00:16:12,440
mitigations like kasr Smet or kcfi

311
00:16:12,440 --> 00:16:15,959
however this method won't work on

312
00:16:15,959 --> 00:16:19,740
Android because of SC Linux to exploit

313
00:16:19,740 --> 00:16:22,019
this vulnerability on the affected

314
00:16:22,019 --> 00:16:25,320
Android device I came up with a new

315
00:16:25,320 --> 00:16:28,500
method with which I can succeed in

316
00:16:28,500 --> 00:16:32,100
succeed in writing privileged files from

317
00:16:32,100 --> 00:16:34,440
on trusted apps

318
00:16:34,440 --> 00:16:38,399
and here is our poc in in this POC I

319
00:16:38,399 --> 00:16:40,620
succeeded in writing a privilege to

320
00:16:40,620 --> 00:16:43,500
share the library from an on Trust app

321
00:16:43,500 --> 00:16:44,699
app

322
00:16:44,699 --> 00:16:47,459
because of the limited time the details

323
00:16:47,459 --> 00:16:50,940
of the exploit exploits are put in the

324
00:16:50,940 --> 00:16:55,339
supplement part of the slides

325
00:16:56,759 --> 00:17:00,899
to find the use of free issue caused by

326
00:17:00,899 --> 00:17:03,360
the risk condition in the FDA export

327
00:17:03,360 --> 00:17:06,240
operation we only need to check if the

328
00:17:06,240 --> 00:17:09,119
fire or related objects are referenced

329
00:17:09,119 --> 00:17:12,900
after these listed functions this can be

330
00:17:12,900 --> 00:17:15,540
done more effectively by tools like code

331
00:17:15,540 --> 00:17:18,079
ql

332
00:17:18,919 --> 00:17:22,319
there are two fixed methods for such

333
00:17:22,319 --> 00:17:25,020
issues the first method method is

334
00:17:25,020 --> 00:17:28,380
obvious which is uh don't reference the

335
00:17:28,380 --> 00:17:31,860
file or related objects after the step

336
00:17:31,860 --> 00:17:34,860
two of FDA export operation in kernel

337
00:17:34,860 --> 00:17:38,700
until retain written to user space here

338
00:17:38,700 --> 00:17:41,340
is an example which is the part of Cisco

339
00:17:41,340 --> 00:17:45,240
open as you can see after the FD is

340
00:17:45,240 --> 00:17:47,280
installed the file object is not

341
00:17:47,280 --> 00:17:50,340
referenced and FD is returned to user

342
00:17:50,340 --> 00:17:53,120
space directly

343
00:17:53,120 --> 00:17:56,640
the second method to fix the issue is to

344
00:17:56,640 --> 00:17:59,220
reference the file or related objects

345
00:17:59,220 --> 00:18:02,460
with log protection and share the lock

346
00:18:02,460 --> 00:18:06,660
in the file release function of of FD as

347
00:18:06,660 --> 00:18:09,720
you can see that if if we share the same

348
00:18:09,720 --> 00:18:12,660
mutex log in the two codes the risk

349
00:18:12,660 --> 00:18:15,720
condition can never succeed so the uaf

350
00:18:15,720 --> 00:18:17,220
won't happen

351
00:18:17,220 --> 00:18:22,340
here is an actual example from vendor s

352
00:18:24,780 --> 00:18:28,260
and then let's dive into the issues in

353
00:18:28,260 --> 00:18:32,240
the FD importer operation

354
00:18:33,679 --> 00:18:36,539
I will talk about four parts in this

355
00:18:36,539 --> 00:18:39,240
section including the scenario of FD

356
00:18:39,240 --> 00:18:41,940
import operation FD type confusion

357
00:18:41,940 --> 00:18:45,720
caused by risk condition and how to fix

358
00:18:45,720 --> 00:18:49,520
find and fix the issues

359
00:18:50,820 --> 00:18:53,640
let's have a look at the common scenario

360
00:18:53,640 --> 00:18:57,240
of FD import operation when user process

361
00:18:57,240 --> 00:18:59,880
when user process performs the operation

362
00:18:59,880 --> 00:19:02,940
on FD through this course like read

363
00:19:02,940 --> 00:19:04,080
write

364
00:19:04,080 --> 00:19:07,440
uh the FD will be passed to Kernel space

365
00:19:07,440 --> 00:19:11,039
and kernel will get the associated file

366
00:19:11,039 --> 00:19:13,400
object through the FD import operation

367
00:19:13,400 --> 00:19:17,100
after that kernel will operate the file

368
00:19:17,100 --> 00:19:21,660
object to finish the further work

369
00:19:21,660 --> 00:19:26,520
here is an example of the scenario which

370
00:19:26,520 --> 00:19:29,880
is the implementation of Cisco right

371
00:19:29,880 --> 00:19:32,520
as you can see that the Ft import

372
00:19:32,520 --> 00:19:35,400
operation is performed in the function

373
00:19:35,400 --> 00:19:38,760
FD get post and then the file object

374
00:19:38,760 --> 00:19:42,720
will be got and passed to VFS rights for

375
00:19:42,720 --> 00:19:45,559
further operations

376
00:19:46,640 --> 00:19:50,179
but this regular FD import operation is

377
00:19:50,179 --> 00:19:53,160
executed sequentially which is still far

378
00:19:53,160 --> 00:19:55,919
from the risk conditions we want to see

379
00:19:55,919 --> 00:19:59,580
so I started to re search for all kinds

380
00:19:59,580 --> 00:20:02,700
of scenarios of FD import operations in

381
00:20:02,700 --> 00:20:07,500
kernels and by by referencing all these

382
00:20:07,500 --> 00:20:09,900
listed kernel apis for FDA import

383
00:20:09,900 --> 00:20:12,600
operation and finally I found some

384
00:20:12,600 --> 00:20:15,480
really interesting issues so let's have

385
00:20:15,480 --> 00:20:18,080
a look at them

386
00:20:18,179 --> 00:20:23,460
the first one is Savvy 2022 21772

387
00:20:23,460 --> 00:20:26,820
which I found in your vendors kernel as

388
00:20:26,820 --> 00:20:29,100
you can see that this function will

389
00:20:29,100 --> 00:20:33,000
create a specific team DME buff FD and

390
00:20:33,000 --> 00:20:35,400
then it will import the FG to get the

391
00:20:35,400 --> 00:20:37,020
dma buff object

392
00:20:37,020 --> 00:20:40,320
after that the private field of the game

393
00:20:40,320 --> 00:20:43,559
buff object will be referenced as a

394
00:20:43,559 --> 00:20:46,980
t-share mem object object for literature

395
00:20:46,980 --> 00:20:49,100
use

396
00:20:49,500 --> 00:20:52,260
there's three steps in the function are

397
00:20:52,260 --> 00:20:55,620
simple normally this is safe in

398
00:20:55,620 --> 00:20:58,620
sequential execution but what if there

399
00:20:58,620 --> 00:21:01,500
is a risk condition getting involved I

400
00:21:01,500 --> 00:21:03,660
found that if we apply the risk

401
00:21:03,660 --> 00:21:06,539
condition 2 into this case something

402
00:21:06,539 --> 00:21:09,740
interesting would happen

403
00:21:12,120 --> 00:21:14,640
here are the details as you can see that

404
00:21:14,640 --> 00:21:17,820
thread a will perform the three steps of

405
00:21:17,820 --> 00:21:20,940
the function it will create specific dma

406
00:21:20,940 --> 00:21:23,039
buff FD in the first step

407
00:21:23,039 --> 00:21:26,220
right after this Fred B closed the FD

408
00:21:26,220 --> 00:21:28,860
and create a different different game

409
00:21:28,860 --> 00:21:32,100
above FD this will make the FD become a

410
00:21:32,100 --> 00:21:35,100
totally different one in thread a

411
00:21:35,100 --> 00:21:38,400
as a result a win thread a imposed the

412
00:21:38,400 --> 00:21:41,640
game buff FD it will get a totally

413
00:21:41,640 --> 00:21:43,679
different dma buff object

414
00:21:43,679 --> 00:21:47,220
but thread a still treats the private

415
00:21:47,220 --> 00:21:50,460
field of the DMV buff as t-share mem

416
00:21:50,460 --> 00:21:53,400
object this will cause a type confusion

417
00:21:53,400 --> 00:21:55,880
issue

418
00:21:55,940 --> 00:22:00,120
and the second issue is like this

419
00:22:00,120 --> 00:22:04,320
there is a sync file FD passed from user

420
00:22:04,320 --> 00:22:07,799
space and the function imposed the FD

421
00:22:07,799 --> 00:22:10,620
for the first time to get the damn fence

422
00:22:10,620 --> 00:22:13,260
object it will check the dma fence

423
00:22:13,260 --> 00:22:16,380
object to make sure it's valid and then

424
00:22:16,380 --> 00:22:18,780
the function Imports the FD for the

425
00:22:18,780 --> 00:22:19,860
second time

426
00:22:19,860 --> 00:22:24,059
and the private data of a file object is

427
00:22:24,059 --> 00:22:26,700
returned as sync file object for little

428
00:22:26,700 --> 00:22:29,179
use

429
00:22:29,720 --> 00:22:32,880
the fourth step four steps in the

430
00:22:32,880 --> 00:22:35,340
function are simple normally this is

431
00:22:35,340 --> 00:22:38,400
safe in sequential execution but I found

432
00:22:38,400 --> 00:22:41,159
that if we apply the risk condition 2

433
00:22:41,159 --> 00:22:43,740
into this case something interesting

434
00:22:43,740 --> 00:22:46,580
will happen too

435
00:22:46,620 --> 00:22:49,620
here are the the details as you can see

436
00:22:49,620 --> 00:22:51,900
that thread a will perform the four

437
00:22:51,900 --> 00:22:54,960
steps of the function it will it will

438
00:22:54,960 --> 00:22:57,480
import the FD for the first time to get

439
00:22:57,480 --> 00:23:00,480
the game above fence object it will

440
00:23:00,480 --> 00:23:03,120
check the dma fans object to make sure

441
00:23:03,120 --> 00:23:04,380
it's valid

442
00:23:04,380 --> 00:23:07,559
right after this third B close the FD

443
00:23:07,559 --> 00:23:10,740
and create a different FD this will make

444
00:23:10,740 --> 00:23:13,200
the FD become a totally different one in

445
00:23:13,200 --> 00:23:16,260
thread a as a result when thread a

446
00:23:16,260 --> 00:23:18,960
imposed the FD for the second time it

447
00:23:18,960 --> 00:23:20,640
will get the totally different file

448
00:23:20,640 --> 00:23:21,720
object

449
00:23:21,720 --> 00:23:24,419
but thread a still treats the private

450
00:23:24,419 --> 00:23:25,799
data of

451
00:23:25,799 --> 00:23:30,600
fire fire object as sync file object

452
00:23:30,600 --> 00:23:33,059
this will cause a type confusion issue

453
00:23:33,059 --> 00:23:35,299
too

454
00:23:36,260 --> 00:23:39,480
these two special issues represent two

455
00:23:39,480 --> 00:23:42,360
types of the issues in the scenario of

456
00:23:42,360 --> 00:23:44,220
FD import operation

457
00:23:44,220 --> 00:23:47,640
the first type is FD time of create time

458
00:23:47,640 --> 00:23:49,140
of import

459
00:23:49,140 --> 00:23:51,780
the bug pattern of the type is like this

460
00:23:51,780 --> 00:23:54,960
the first step is to create a specific

461
00:23:54,960 --> 00:23:58,919
FD the second step is to import the FD

462
00:23:58,919 --> 00:24:02,360
to get a specific file object at last

463
00:24:02,360 --> 00:24:06,000
the reference the private data or file

464
00:24:06,000 --> 00:24:08,580
file object or other related private

465
00:24:08,580 --> 00:24:10,260
objects

466
00:24:10,260 --> 00:24:13,080
because there is a Type window

467
00:24:13,080 --> 00:24:16,500
the FD can be recreated

468
00:24:16,500 --> 00:24:21,140
the second type is the fdw import

469
00:24:21,140 --> 00:24:24,480
ant of the type is like this kernel

470
00:24:24,480 --> 00:24:27,120
Imports the FD for the first time

471
00:24:27,120 --> 00:24:30,539
to get a file object and this this file

472
00:24:30,539 --> 00:24:33,659
object gets processed for ProPress a

473
00:24:33,659 --> 00:24:36,720
after that kernel Imports DFD again to

474
00:24:36,720 --> 00:24:40,620
get a file object and this file object

475
00:24:40,620 --> 00:24:43,679
gets processed for purpose B because

476
00:24:43,679 --> 00:24:45,900
there is a Time window between the two

477
00:24:45,900 --> 00:24:48,720
type 2 ft import operations

478
00:24:48,720 --> 00:24:52,799
the FD can be recreated both both types

479
00:24:52,799 --> 00:24:58,158
of issues might cause FD type confusion

480
00:25:01,080 --> 00:25:03,659
however there are still two questions

481
00:25:03,659 --> 00:25:07,020
that need to be answered there are more

482
00:25:07,020 --> 00:25:10,020
issues of these types and how to find

483
00:25:10,020 --> 00:25:13,200
these issues more effectively actually

484
00:25:13,200 --> 00:25:15,299
it could be difficult to find such

485
00:25:15,299 --> 00:25:18,659
issues by fuzzing because sometimes the

486
00:25:18,659 --> 00:25:21,539
budget code is located in kernel the

487
00:25:21,539 --> 00:25:24,059
user process can barely notice it

488
00:25:24,059 --> 00:25:27,240
and also the risk risk window could be

489
00:25:27,240 --> 00:25:30,360
tiny so I'm thinking about that maybe we

490
00:25:30,360 --> 00:25:33,240
can detect such issues at runtime by

491
00:25:33,240 --> 00:25:36,679
some detecting code

492
00:25:38,400 --> 00:25:42,779
here is the regular life cycle of an FD

493
00:25:42,779 --> 00:25:46,559
the original state of NFD is FD unused

494
00:25:46,559 --> 00:25:48,679
as you can see

495
00:25:48,679 --> 00:25:53,220
and vfd will become FD created when the

496
00:25:53,220 --> 00:25:56,100
FD gets associated with a file object

497
00:25:56,100 --> 00:25:58,080
through FD install

498
00:25:58,080 --> 00:26:00,779
when the FD gets returned to user space

499
00:26:00,779 --> 00:26:05,039
the state will change from FD created to

500
00:26:05,039 --> 00:26:07,200
FTE user

501
00:26:07,200 --> 00:26:09,840
when the user press user process

502
00:26:09,840 --> 00:26:13,200
operates the FD through a Cisco the FD

503
00:26:13,200 --> 00:26:17,159
will will be imported by kernel and the

504
00:26:17,159 --> 00:26:20,279
FD state will change from fde user to

505
00:26:20,279 --> 00:26:22,260
FDA first to use

506
00:26:22,260 --> 00:26:25,559
and then when the Cisco Returns the

507
00:26:25,559 --> 00:26:28,380
state will change from FD first use to

508
00:26:28,380 --> 00:26:31,580
fde user

509
00:26:32,059 --> 00:26:35,640
the two types of of issues in the

510
00:26:35,640 --> 00:26:37,980
scenario scenario of FD imported

511
00:26:37,980 --> 00:26:41,400
operation can be located clearly in the

512
00:26:41,400 --> 00:26:46,380
life cycle of NFD the FD time of create

513
00:26:46,380 --> 00:26:49,500
time of import issue might happen when

514
00:26:49,500 --> 00:26:53,279
the FD State changed from FD created to

515
00:26:53,279 --> 00:26:57,059
Ft first to use and the fdw import issue

516
00:26:57,059 --> 00:26:59,460
might happen when the fds did change

517
00:26:59,460 --> 00:27:03,500
from FD first used to FD Second Use

518
00:27:03,500 --> 00:27:07,500
actually the implementation of

519
00:27:07,500 --> 00:27:10,679
of the detecting code is very simple we

520
00:27:10,679 --> 00:27:13,919
only need to add some code to a few

521
00:27:13,919 --> 00:27:17,220
kernel apis which such as the FD install

522
00:27:17,220 --> 00:27:20,460
fd-get and so on and I have put the

523
00:27:20,460 --> 00:27:24,200
detecting code at GitHub

524
00:27:25,140 --> 00:27:27,840
here are the issues I found by both the

525
00:27:27,840 --> 00:27:31,559
detect tool and code outdating it seems

526
00:27:31,559 --> 00:27:34,260
that there are quite a few issues in the

527
00:27:34,260 --> 00:27:36,480
scenario of FD import operations in

528
00:27:36,480 --> 00:27:39,320
vendors kernels

529
00:27:41,100 --> 00:27:45,000
the fix for FD time of create time or

530
00:27:45,000 --> 00:27:48,059
important import is obvious kernel

531
00:27:48,059 --> 00:27:50,520
should create a specific file object for

532
00:27:50,520 --> 00:27:54,659
use directly instead of creating NFD and

533
00:27:54,659 --> 00:27:56,460
importing it

534
00:27:56,460 --> 00:27:59,580
the fix for Ft double import is also

535
00:27:59,580 --> 00:28:03,120
obvious kernel should import FD only

536
00:28:03,120 --> 00:28:06,720
once to get the file object and all the

537
00:28:06,720 --> 00:28:09,960
following code should process this file

538
00:28:09,960 --> 00:28:13,500
object directly importing NFD many times

539
00:28:13,500 --> 00:28:16,880
is never a good idea

540
00:28:17,419 --> 00:28:20,700
for now we have talked about the issues

541
00:28:20,700 --> 00:28:23,820
in the FD export and import operations

542
00:28:23,820 --> 00:28:27,059
let's make conclusion and talk about the

543
00:28:27,059 --> 00:28:28,260
future work

544
00:28:28,260 --> 00:28:30,779
in this talk I discussed a typical use

545
00:28:30,779 --> 00:28:33,419
of free issue caused by risk condition

546
00:28:33,419 --> 00:28:37,620
in the FDX for operation in kernel so

547
00:28:37,620 --> 00:28:39,779
there is a really obvious question we

548
00:28:39,779 --> 00:28:43,320
may need to ask ourselves

549
00:28:43,320 --> 00:28:46,020
are there other similar kinds of

550
00:28:46,020 --> 00:28:49,559
resources just like the file describer

551
00:28:49,559 --> 00:28:53,100
which is predictable and with export

552
00:28:53,100 --> 00:28:55,620
operations in kernel

553
00:28:55,620 --> 00:28:57,720
the answer is yes

554
00:28:57,720 --> 00:29:01,200
I found that IDR is a really typical

555
00:29:01,200 --> 00:29:04,380
resource of this kind it's predictable

556
00:29:04,380 --> 00:29:07,860
and x and Export operations can be

557
00:29:07,860 --> 00:29:10,919
performed on it in kernel

558
00:29:10,919 --> 00:29:13,799
and is widely used in kernel drivers as

559
00:29:13,799 --> 00:29:17,700
handle ID session ID or object ID and so

560
00:29:17,700 --> 00:29:18,360
on

561
00:29:18,360 --> 00:29:20,700
so here comes the future work

562
00:29:20,700 --> 00:29:23,220
we can try to find a similar use after

563
00:29:23,220 --> 00:29:26,720
three issues in IDR or others

564
00:29:26,720 --> 00:29:30,620
self-implementing indexes

565
00:29:30,899 --> 00:29:33,840
I also discussed the Ft type confusion

566
00:29:33,840 --> 00:29:36,539
issues caused by risk condition in the

567
00:29:36,539 --> 00:29:38,520
FD import operation

568
00:29:38,520 --> 00:29:40,980
there is also a really obvious question

569
00:29:40,980 --> 00:29:43,740
we may need to ask ourselves

570
00:29:43,740 --> 00:29:46,140
are there other similar kinds of

571
00:29:46,140 --> 00:29:48,600
resources just like the file described

572
00:29:48,600 --> 00:29:50,159
on which

573
00:29:50,159 --> 00:29:52,440
similar import operations can be

574
00:29:52,440 --> 00:29:57,179
performed in kernel the answer is yes

575
00:29:57,179 --> 00:29:59,760
there are quite a few resources on which

576
00:29:59,760 --> 00:30:02,880
we can perform similar import operations

577
00:30:02,880 --> 00:30:08,100
in kernel such as IDR process PID user

578
00:30:08,100 --> 00:30:10,740
virtual address and so on so we can try

579
00:30:10,740 --> 00:30:13,380
to find a similar issues in these

580
00:30:13,380 --> 00:30:15,860
resources

581
00:30:16,620 --> 00:30:21,260
and thanks to more important

582
00:30:26,360 --> 00:30:30,299
for helping me with my slides they made

583
00:30:30,299 --> 00:30:34,340
great suggestions thanks a lot

584
00:30:35,220 --> 00:30:37,980
actually I really want to talk about my

585
00:30:37,980 --> 00:30:43,039
exploit method for CV 2022 to

586
00:30:43,039 --> 00:30:47,399
28350 but due to the time constraint I

587
00:30:47,399 --> 00:30:49,980
put all the exploited details in the

588
00:30:49,980 --> 00:30:53,220
supplement supplement supplement part

589
00:30:53,220 --> 00:30:56,820
and also I have proved that the issues I

590
00:30:56,820 --> 00:30:59,580
researched about are exported

591
00:30:59,580 --> 00:31:03,059
exploitable even if the risk window is

592
00:31:03,059 --> 00:31:04,620
really small

593
00:31:04,620 --> 00:31:07,320
details of turning these issues to

594
00:31:07,320 --> 00:31:10,380
memory corruption for for exploitation

595
00:31:10,380 --> 00:31:15,000
are also put in the supplement part

596
00:31:15,000 --> 00:31:17,460
read them if you are interested

597
00:31:17,460 --> 00:31:19,780
thanks

598
00:31:19,780 --> 00:31:22,879
[Music]

599
00:31:26,740 --> 00:31:29,829
[Music]

