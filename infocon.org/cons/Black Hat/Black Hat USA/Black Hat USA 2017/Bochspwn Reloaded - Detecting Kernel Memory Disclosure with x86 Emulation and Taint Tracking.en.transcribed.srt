1
00:00:00,030 --> 00:00:03,840
hello everyone my name<font color="#CCCCCC"> is Matteo</font><font color="#E5E5E5"> Utrecht</font>

2
00:00:02,129 --> 00:00:06,330
and<font color="#CCCCCC"> today I</font><font color="#E5E5E5"> will be talking about my</font>

3
00:00:03,840 --> 00:00:09,179
latest project called the<font color="#CCCCCC"> box pol</font>

4
00:00:06,330 --> 00:00:11,370
reloaded<font color="#CCCCCC"> which is using x86 emulation</font>

5
00:00:09,179 --> 00:00:13,679
and<font color="#CCCCCC"> stained tracking to disclose</font><font color="#E5E5E5"> to</font>

6
00:00:11,370 --> 00:00:16,009
discover this closure of initialized

7
00:00:13,679 --> 00:00:18,990
memory in operating system kernels<font color="#E5E5E5"> so</font>

8
00:00:16,010 --> 00:00:21,320
<font color="#CCCCCC">the</font><font color="#E5E5E5"> agenda for today</font><font color="#CCCCCC"> is first off to</font>

9
00:00:18,990 --> 00:00:23,339
briefly start discussing the

10
00:00:21,320 --> 00:00:24,990
<font color="#E5E5E5">communication between user and kernel</font>

11
00:00:23,340 --> 00:00:27,660
mode in operating systems<font color="#E5E5E5"> and what are</font>

12
00:00:24,990 --> 00:00:29,669
the<font color="#E5E5E5"> common pitfalls</font><font color="#CCCCCC"> that are related to</font>

13
00:00:27,660 --> 00:00:32,308
them and then<font color="#E5E5E5"> introduce the</font><font color="#CCCCCC"> box pawn</font>

14
00:00:29,670 --> 00:00:35,040
reloaded project<font color="#E5E5E5"> the principles behind</font>

15
00:00:32,308 --> 00:00:37,320
it how it works in<font color="#CCCCCC"> general and how it</font>

16
00:00:35,040 --> 00:00:40,170
<font color="#CCCCCC">uses the full system emulation</font><font color="#E5E5E5"> to</font>

17
00:00:37,320 --> 00:00:42,360
discover any kind<font color="#E5E5E5"> of bugs</font><font color="#CCCCCC"> then I will</font>

18
00:00:40,170 --> 00:00:44,399
talk about<font color="#E5E5E5"> the system specific</font>

19
00:00:42,360 --> 00:00:46,200
approaches which are specific to both

20
00:00:44,399 --> 00:00:49,020
<font color="#E5E5E5">Windows and Linux which are the two</font>

21
00:00:46,200 --> 00:00:50,730
operating<font color="#E5E5E5"> systems</font><font color="#CCCCCC"> that I analyzed I will</font>

22
00:00:49,020 --> 00:00:53,280
talk about<font color="#CCCCCC"> the results in in those</font>

23
00:00:50,730 --> 00:00:55,589
<font color="#E5E5E5">operating</font><font color="#CCCCCC"> systems</font><font color="#E5E5E5"> and then wrap up with</font>

24
00:00:53,280 --> 00:00:57,600
some<font color="#E5E5E5"> ideas</font><font color="#CCCCCC"> for future</font><font color="#E5E5E5"> work on how this</font>

25
00:00:55,590 --> 00:01:00,539
<font color="#CCCCCC">project</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> be extended</font><font color="#E5E5E5"> and improved</font><font color="#CCCCCC"> and</font>

26
00:00:57,600 --> 00:01:04,500
how we can deal with<font color="#E5E5E5"> this type of issues</font>

27
00:01:00,539 --> 00:01:06,630
<font color="#E5E5E5">in the future a few words about myself I</font>

28
00:01:04,500 --> 00:01:08,729
am a low-level security researcher

29
00:01:06,630 --> 00:01:10,259
<font color="#E5E5E5">interest obviously</font><font color="#CCCCCC"> in all sorts of</font>

30
00:01:08,729 --> 00:01:12,510
vulnerability research and software

31
00:01:10,260 --> 00:01:15,750
exploitation<font color="#CCCCCC"> I work at freedom</font><font color="#E5E5E5"> 0 at</font>

32
00:01:12,510 --> 00:01:18,299
Google in my spare time I place in<font color="#CCCCCC"> CDF's</font>

33
00:01:15,750 --> 00:01:19,830
as part<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> dragon sector team and I</font>

34
00:01:18,299 --> 00:01:22,530
have a blog<font color="#CCCCCC"> and</font><font color="#E5E5E5"> Twitter where I post</font>

35
00:01:19,830 --> 00:01:24,869
some of<font color="#E5E5E5"> my research as well so yeah</font>

36
00:01:22,530 --> 00:01:26,460
let's start with with some basics<font color="#E5E5E5"> very</font>

37
00:01:24,869 --> 00:01:29,220
quickly about<font color="#E5E5E5"> user and kernel</font>

38
00:01:26,460 --> 00:01:31,289
communication<font color="#E5E5E5"> so as</font><font color="#CCCCCC"> you all know user</font>

39
00:01:29,220 --> 00:01:34,170
applications run independently<font color="#E5E5E5"> of other</font>

40
00:01:31,290 --> 00:01:36,450
programs and independently<font color="#E5E5E5"> of the kernel</font>

41
00:01:34,170 --> 00:01:37,979
<font color="#E5E5E5">and whenever they actually want to do</font>

42
00:01:36,450 --> 00:01:39,810
<font color="#CCCCCC">something in the operating</font><font color="#E5E5E5"> system</font><font color="#CCCCCC"> they</font>

43
00:01:37,979 --> 00:01:42,840
call<font color="#CCCCCC"> into the</font><font color="#E5E5E5"> kernel to request the</font>

44
00:01:39,810 --> 00:01:44,729
operation<font color="#CCCCCC"> that they want to</font><font color="#E5E5E5"> do and when</font>

45
00:01:42,840 --> 00:01:46,530
<font color="#CCCCCC">they do it the</font><font color="#E5E5E5"> ring free memory which is</font>

46
00:01:44,729 --> 00:01:49,500
<font color="#CCCCCC">a shared memory</font><font color="#E5E5E5"> between</font><font color="#CCCCCC"> the user</font><font color="#E5E5E5"> and</font>

47
00:01:46,530 --> 00:01:52,380
kernel mode is used as the<font color="#E5E5E5"> exchange data</font>

48
00:01:49,500 --> 00:01:55,259
exchange<font color="#E5E5E5"> channel</font><font color="#CCCCCC"> so this</font><font color="#E5E5E5"> is how it looks</font>

49
00:01:52,380 --> 00:01:57,240
<font color="#E5E5E5">on a simple graph so we have the user</font>

50
00:01:55,259 --> 00:01:59,790
mode program which wants<font color="#CCCCCC"> to perform</font><font color="#E5E5E5"> some</font>

51
00:01:57,240 --> 00:02:02,610
operations so<font color="#CCCCCC"> it writes</font><font color="#E5E5E5"> input data to</font>

52
00:01:59,790 --> 00:02:03,960
the shirt user mode<font color="#E5E5E5"> memory then in it</font>

53
00:02:02,610 --> 00:02:06,299
invokes the system<font color="#CCCCCC"> called which</font>

54
00:02:03,960 --> 00:02:09,209
transfers execution<font color="#E5E5E5"> to the system kernel</font>

55
00:02:06,299 --> 00:02:11,819
which then reads the<font color="#E5E5E5"> input data</font><font color="#CCCCCC"> performs</font>

56
00:02:09,209 --> 00:02:13,800
some logic<font color="#CCCCCC"> writes output beta back and</font>

57
00:02:11,819 --> 00:02:15,660
returns to user space then the<font color="#E5E5E5"> use</font>

58
00:02:13,800 --> 00:02:18,270
<font color="#E5E5E5">program reads the output data back and</font>

59
00:02:15,660 --> 00:02:20,220
operates on<font color="#CCCCCC"> it so in this presentation</font>

60
00:02:18,270 --> 00:02:22,050
<font color="#CCCCCC">we're mostly interested in these two</font>

61
00:02:20,220 --> 00:02:23,700
stages<font color="#E5E5E5"> of the system kernel first</font>

62
00:02:22,050 --> 00:02:26,460
reading input data<font color="#E5E5E5"> and then writing</font>

63
00:02:23,700 --> 00:02:29,459
output data and<font color="#CCCCCC"> especially in the in the</font>

64
00:02:26,460 --> 00:02:32,160
second<font color="#E5E5E5"> part so let's</font><font color="#CCCCCC"> imagine</font><font color="#E5E5E5"> in a</font>

65
00:02:29,460 --> 00:02:35,160
<font color="#E5E5E5">perfect world where the kernel doesn't</font>

66
00:02:32,160 --> 00:02:38,760
<font color="#E5E5E5">have any bugs so we would like in this</font>

67
00:02:35,160 --> 00:02:41,190
<font color="#E5E5E5">perfect</font><font color="#CCCCCC"> word for the kernel to only</font><font color="#E5E5E5"> read</font>

68
00:02:38,760 --> 00:02:43,739
every<font color="#E5E5E5"> memory unit once within</font><font color="#CCCCCC"> the scope</font>

69
00:02:41,190 --> 00:02:46,680
<font color="#E5E5E5">of a system call and then write</font><font color="#CCCCCC"> to it</font>

70
00:02:43,740 --> 00:02:49,020
also at most once<font color="#E5E5E5"> after</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> is done with</font>

71
00:02:46,680 --> 00:02:51,300
all<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the system call logic do it in a</font>

72
00:02:49,020 --> 00:02:53,370
secure<font color="#E5E5E5"> manner and only write</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> data</font>

73
00:02:51,300 --> 00:02:55,260
that<font color="#E5E5E5"> is intended</font><font color="#CCCCCC"> for user mode</font><font color="#E5E5E5"> so that</font>

74
00:02:53,370 --> 00:02:57,600
<font color="#CCCCCC">is the state of</font><font color="#E5E5E5"> the perfect world that</font>

75
00:02:55,260 --> 00:03:01,049
<font color="#E5E5E5">we could imagine but of course we have</font>

76
00:02:57,600 --> 00:03:03,060
free LT instead so these assumptions

77
00:03:01,050 --> 00:03:05,760
that<font color="#E5E5E5"> I mentioned can be</font><font color="#CCCCCC"> broken in in a</font>

78
00:03:03,060 --> 00:03:07,290
<font color="#E5E5E5">number</font><font color="#CCCCCC"> of ways</font><font color="#E5E5E5"> so for example we can</font>

79
00:03:05,760 --> 00:03:11,010
break the assumption that<font color="#E5E5E5"> every memory</font>

80
00:03:07,290 --> 00:03:13,350
<font color="#E5E5E5">unit is read from at most once it may</font>

81
00:03:11,010 --> 00:03:15,600
happen that<font color="#E5E5E5"> memory is actually read most</font>

82
00:03:13,350 --> 00:03:17,790
and more<font color="#E5E5E5"> than once</font><font color="#CCCCCC"> this was the subject</font>

83
00:03:15,600 --> 00:03:19,470
of<font color="#E5E5E5"> the original box</font><font color="#CCCCCC"> boom research that</font>

84
00:03:17,790 --> 00:03:21,359
we performed<font color="#E5E5E5"> four years ago we've been</font>

85
00:03:19,470 --> 00:03:23,580
<font color="#CCCCCC">very cold wind and the possible</font>

86
00:03:21,360 --> 00:03:26,310
violation is that<font color="#CCCCCC"> we have two or more</font>

87
00:03:23,580 --> 00:03:29,430
fetches from user<font color="#CCCCCC"> mode memory which may</font>

88
00:03:26,310 --> 00:03:31,080
allow some race conditions<font color="#E5E5E5"> to break code</font>

89
00:03:29,430 --> 00:03:33,239
assumptions which can lead to buffer

90
00:03:31,080 --> 00:03:35,670
overflows<font color="#E5E5E5"> right what with work</font>

91
00:03:33,239 --> 00:03:38,340
conditions<font color="#E5E5E5"> arbitrary it's all kind of</font>

92
00:03:35,670 --> 00:03:41,070
<font color="#E5E5E5">badness so these this original research</font>

93
00:03:38,340 --> 00:03:45,709
resulted in discovering more than<font color="#CCCCCC"> 40</font>

94
00:03:41,070 --> 00:03:48,810
vulnerabilities in Windows<font color="#E5E5E5"> and yeah so</font>

95
00:03:45,709 --> 00:03:50,700
we wrote quite a few papers<font color="#E5E5E5"> on</font><font color="#CCCCCC"> this</font>

96
00:03:48,810 --> 00:03:52,650
<font color="#CCCCCC">subject</font><font color="#E5E5E5"> on both trying to find</font><font color="#CCCCCC"> these</font>

97
00:03:50,700 --> 00:03:55,769
kind<font color="#E5E5E5"> of double fetters</font><font color="#CCCCCC"> and also exploit</font>

98
00:03:52,650 --> 00:03:59,370
them this research was also<font color="#E5E5E5"> presented</font>

99
00:03:55,770 --> 00:04:01,590
<font color="#CCCCCC">here at blackhat we can also break</font><font color="#E5E5E5"> the</font>

100
00:03:59,370 --> 00:04:03,900
other assumptions in a number of<font color="#CCCCCC"> ways so</font>

101
00:04:01,590 --> 00:04:05,610
<font color="#E5E5E5">for example we can</font><font color="#CCCCCC"> have like unprotected</font>

102
00:04:03,900 --> 00:04:08,340
accesses<font color="#CCCCCC"> to user mode pointers in the</font>

103
00:04:05,610 --> 00:04:09,810
<font color="#E5E5E5">kernel we can have multiple writes to a</font>

104
00:04:08,340 --> 00:04:11,910
single memory area which can<font color="#E5E5E5"> also</font>

105
00:04:09,810 --> 00:04:15,090
indicate<font color="#E5E5E5"> that something fishy's going on</font>

106
00:04:11,910 --> 00:04:16,529
in the kernel<font color="#E5E5E5"> we can have reading from</font>

107
00:04:15,090 --> 00:04:18,510
the user mode address<font color="#E5E5E5"> after already</font>

108
00:04:16,529 --> 00:04:21,059
<font color="#CCCCCC">having written</font><font color="#E5E5E5"> to it which is</font><font color="#CCCCCC"> also kind</font>

109
00:04:18,510 --> 00:04:23,909
<font color="#CCCCCC">of fishy because why</font><font color="#E5E5E5"> would a kernel do</font>

110
00:04:21,060 --> 00:04:25,890
it and there are<font color="#E5E5E5"> some other</font><font color="#CCCCCC"> behaviors</font>

111
00:04:23,910 --> 00:04:27,130
which can raise an eyebrow for example

112
00:04:25,890 --> 00:04:29,500
<font color="#E5E5E5">accessing ring</font>

113
00:04:27,130 --> 00:04:32,200
memory<font color="#E5E5E5"> within very deeply nested</font><font color="#CCCCCC"> skull</font>

114
00:04:29,500 --> 00:04:33,880
stacks or with the first enabled

115
00:04:32,200 --> 00:04:35,830
exception<font color="#E5E5E5"> hands are very high</font><font color="#CCCCCC"> optical</font>

116
00:04:33,880 --> 00:04:38,080
<font color="#E5E5E5">stack these are also some some weird</font>

117
00:04:35,830 --> 00:04:40,330
behaviors that<font color="#E5E5E5"> could</font><font color="#CCCCCC"> happen but</font><font color="#E5E5E5"> the</font>

118
00:04:38,080 --> 00:04:42,250
subject of this talk<font color="#CCCCCC"> is actually this</font>

119
00:04:40,330 --> 00:04:44,560
part about only<font color="#CCCCCC"> writing data that is</font>

120
00:04:42,250 --> 00:04:47,590
intended<font color="#E5E5E5"> to</font><font color="#CCCCCC"> be used</font><font color="#E5E5E5"> by user mode so</font>

121
00:04:44,560 --> 00:04:51,220
<font color="#E5E5E5">that's what we will focus on so writing</font>

122
00:04:47,590 --> 00:04:53,770
<font color="#E5E5E5">data to use during</font><font color="#CCCCCC"> 3 happens in general</font>

123
00:04:51,220 --> 00:04:55,090
in<font color="#CCCCCC"> 4</font><font color="#E5E5E5"> different cases so we have system</font>

124
00:04:53,770 --> 00:04:57,789
calls which exist<font color="#E5E5E5"> in all operating</font>

125
00:04:55,090 --> 00:05:00,099
<font color="#E5E5E5">systems</font><font color="#CCCCCC"> that were interested in we have</font>

126
00:04:57,790 --> 00:05:02,920
<font color="#CCCCCC">IO</font><font color="#E5E5E5"> CDLs which are also a special case of</font>

127
00:05:00,100 --> 00:05:04,690
<font color="#E5E5E5">sis calls but they have often dedicated</font>

128
00:05:02,920 --> 00:05:06,850
output mechanisms so we can consider

129
00:05:04,690 --> 00:05:08,680
them differently<font color="#E5E5E5"> a little</font><font color="#CCCCCC"> bit we have</font>

130
00:05:06,850 --> 00:05:10,990
<font color="#E5E5E5">user mode callbacks which are a</font>

131
00:05:08,680 --> 00:05:14,410
<font color="#E5E5E5">mechanism which is specific to Windows</font>

132
00:05:10,990 --> 00:05:16,750
<font color="#CCCCCC">and win 32k graphical subsystem and we</font>

133
00:05:14,410 --> 00:05:19,120
<font color="#E5E5E5">finally have exception handling where</font>

134
00:05:16,750 --> 00:05:21,370
the<font color="#CCCCCC"> kernel has to</font><font color="#E5E5E5"> build an exception</font>

135
00:05:19,120 --> 00:05:24,520
frame on the user mode stack so then it

136
00:05:21,370 --> 00:05:26,890
also writes to the user mode<font color="#E5E5E5"> memory so</font>

137
00:05:24,520 --> 00:05:29,260
let's let's go<font color="#CCCCCC"> back a</font><font color="#E5E5E5"> little bit and</font>

138
00:05:26,890 --> 00:05:31,390
<font color="#E5E5E5">think about where when writing</font>

139
00:05:29,260 --> 00:05:33,670
<font color="#E5E5E5">initialized memory or some kind of</font>

140
00:05:31,390 --> 00:05:35,740
unintended memory to user mode can

141
00:05:33,670 --> 00:05:37,600
happen<font color="#E5E5E5"> so we have this easy problem on</font>

142
00:05:35,740 --> 00:05:41,050
the example of a fake<font color="#CCCCCC"> Windows system</font>

143
00:05:37,600 --> 00:05:43,450
call implementation here<font color="#E5E5E5"> of writing an</font>

144
00:05:41,050 --> 00:05:45,520
<font color="#E5E5E5">initialized value of a primitive type</font>

145
00:05:43,450 --> 00:05:48,670
variable so here we have a<font color="#E5E5E5"> system call</font>

146
00:05:45,520 --> 00:05:50,770
which<font color="#CCCCCC"> calculates the multiplication</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> 2</font>

147
00:05:48,670 --> 00:05:52,690
of a value and<font color="#E5E5E5"> of course as we</font><font color="#CCCCCC"> can see</font>

148
00:05:50,770 --> 00:05:55,570
the local<font color="#E5E5E5"> output value</font><font color="#CCCCCC"> is not</font>

149
00:05:52,690 --> 00:05:58,420
<font color="#E5E5E5">initialized if input value is equal to</font><font color="#CCCCCC"> 0</font>

150
00:05:55,570 --> 00:06:00,310
<font color="#E5E5E5">so then we are leaking for or yeah</font>

151
00:05:58,420 --> 00:06:02,980
<font color="#E5E5E5">basically for 4 bytes of initialized</font>

152
00:06:00,310 --> 00:06:05,380
kernel stack<font color="#CCCCCC"> memory back to user mode so</font>

153
00:06:02,980 --> 00:06:08,440
this of course can happen and will

154
00:06:05,380 --> 00:06:10,630
<font color="#CCCCCC">happen but this is not not as bad as it</font>

155
00:06:08,440 --> 00:06:12,219
seems because<font color="#E5E5E5"> first of all it's it's not</font>

156
00:06:10,630 --> 00:06:14,920
a very trivial bug to make for

157
00:06:12,220 --> 00:06:17,530
developers<font color="#E5E5E5"> compilers will often warn</font>

158
00:06:14,920 --> 00:06:18,670
about instances of such<font color="#E5E5E5"> issues it</font>

159
00:06:17,530 --> 00:06:20,619
<font color="#E5E5E5">doesn't</font><font color="#CCCCCC"> leak too much information</font>

160
00:06:18,670 --> 00:06:22,750
<font color="#CCCCCC">because it's just a single variable and</font>

161
00:06:20,620 --> 00:06:24,460
it very well<font color="#CCCCCC"> may be detected during</font>

162
00:06:22,750 --> 00:06:26,770
<font color="#CCCCCC">development as well because it may be</font><font color="#E5E5E5"> a</font>

163
00:06:24,460 --> 00:06:28,840
functional<font color="#E5E5E5"> part so this is not not so</font>

164
00:06:26,770 --> 00:06:31,030
bad<font color="#E5E5E5"> but we have many many other</font>

165
00:06:28,840 --> 00:06:33,070
definitely<font color="#E5E5E5"> harder problems so first of</font>

166
00:06:31,030 --> 00:06:35,890
<font color="#E5E5E5">all we have structures and unions which</font>

167
00:06:33,070 --> 00:06:37,540
are used in C and C++<font color="#E5E5E5"> so here in this</font>

168
00:06:35,890 --> 00:06:39,250
<font color="#E5E5E5">example we have</font><font color="#CCCCCC"> a structure who has</font>

169
00:06:37,540 --> 00:06:40,390
which has<font color="#CCCCCC"> three fields which are being</font>

170
00:06:39,250 --> 00:06:44,860
<font color="#CCCCCC">used to output some</font>

171
00:06:40,390 --> 00:06:46,539
<font color="#CCCCCC">user</font><font color="#E5E5E5"> mode</font><font color="#CCCCCC"> so the two of them</font><font color="#E5E5E5"> - two of</font>

172
00:06:44,860 --> 00:06:48,370
<font color="#CCCCCC">the</font><font color="#E5E5E5"> fields in</font><font color="#CCCCCC"> this structure and are</font>

173
00:06:46,540 --> 00:06:49,990
initialized because they are used by the

174
00:06:48,370 --> 00:06:52,240
system<font color="#CCCCCC"> call</font><font color="#E5E5E5"> but the third one is</font>

175
00:06:49,990 --> 00:06:54,790
reserved<font color="#CCCCCC"> so it's not honest it's not</font>

176
00:06:52,240 --> 00:06:57,790
<font color="#E5E5E5">initialized by default</font><font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of by design</font>

177
00:06:54,790 --> 00:07:00,730
but still<font color="#CCCCCC"> it's allocated in the kernel</font>

178
00:06:57,790 --> 00:07:02,770
stack and it still output back<font color="#CCCCCC"> to user</font>

179
00:07:00,730 --> 00:07:05,980
mode so it's leaking some some<font color="#E5E5E5"> data</font>

180
00:07:02,770 --> 00:07:08,859
within<font color="#E5E5E5"> that fuel furthermore we have</font>

181
00:07:05,980 --> 00:07:11,560
unions which can have fields and you

182
00:07:08,860 --> 00:07:13,870
know types of fields that have different

183
00:07:11,560 --> 00:07:16,600
<font color="#E5E5E5">sizes so here you can see that we have</font>

184
00:07:13,870 --> 00:07:19,060
one D word and one<font color="#CCCCCC"> Q word and only the D</font>

185
00:07:16,600 --> 00:07:21,100
word<font color="#E5E5E5"> is initialized here which leaves</font>

186
00:07:19,060 --> 00:07:23,020
the other four bytes<font color="#E5E5E5"> unutilized and they</font>

187
00:07:21,100 --> 00:07:26,800
are also<font color="#CCCCCC"> leaked back to user mode</font><font color="#E5E5E5"> in the</font>

188
00:07:23,020 --> 00:07:29,859
in the<font color="#CCCCCC"> annualized state</font><font color="#E5E5E5"> and furthermore</font>

189
00:07:26,800 --> 00:07:31,690
we have structures which have<font color="#E5E5E5"> padding</font>

190
00:07:29,860 --> 00:07:32,830
holes inside so we have a D word

191
00:07:31,690 --> 00:07:34,600
followed by a<font color="#CCCCCC"> Q word</font>

192
00:07:32,830 --> 00:07:37,150
but since the<font color="#CCCCCC"> key word has to be</font><font color="#E5E5E5"> 8 byte</font>

193
00:07:34,600 --> 00:07:39,520
aligned<font color="#E5E5E5"> the compiler inserts a</font><font color="#CCCCCC"> pairing</font>

194
00:07:37,150 --> 00:07:42,099
<font color="#CCCCCC">whole of 4 bytes</font><font color="#E5E5E5"> which in this code are</font>

195
00:07:39,520 --> 00:07:46,359
also not initialized properly<font color="#CCCCCC"> and output</font>

196
00:07:42,100 --> 00:07:47,860
<font color="#E5E5E5">to user mode</font><font color="#CCCCCC"> so we have as I said</font>

197
00:07:46,360 --> 00:07:50,200
<font color="#E5E5E5">different problems related</font><font color="#CCCCCC"> to the</font>

198
00:07:47,860 --> 00:07:52,000
structures and unions first of all they

199
00:07:50,200 --> 00:07:54,250
<font color="#CCCCCC">are usually copied in memory entirely</font>

200
00:07:52,000 --> 00:07:56,980
using functions such as mem copy and

201
00:07:54,250 --> 00:08:00,490
size is calculated<font color="#CCCCCC"> by the</font><font color="#E5E5E5"> sizeof</font>

202
00:07:56,980 --> 00:08:03,220
operator<font color="#CCCCCC"> they have often many fields so</font>

203
00:08:00,490 --> 00:08:05,050
it's either<font color="#E5E5E5"> easy to forget about about</font>

204
00:08:03,220 --> 00:08:08,440
setting some<font color="#CCCCCC"> of them or they may</font><font color="#E5E5E5"> be and</font>

205
00:08:05,050 --> 00:08:10,750
<font color="#E5E5E5">not set by design we have padding halls</font>

206
00:08:08,440 --> 00:08:13,840
we have as I<font color="#CCCCCC"> said different sizes</font><font color="#E5E5E5"> and</font>

207
00:08:10,750 --> 00:08:15,280
unions<font color="#E5E5E5"> and worst of all compilers don't</font>

208
00:08:13,840 --> 00:08:16,659
really have too much inside<font color="#E5E5E5"> into</font>

209
00:08:15,280 --> 00:08:18,580
structures especially<font color="#CCCCCC"> when they are</font>

210
00:08:16,660 --> 00:08:21,280
<font color="#E5E5E5">dynamically allocated from the heap or</font>

211
00:08:18,580 --> 00:08:23,409
pools<font color="#E5E5E5"> and also because of</font><font color="#CCCCCC"> the fact that</font>

212
00:08:21,280 --> 00:08:25,960
they are<font color="#E5E5E5"> often copied using functions</font>

213
00:08:23,410 --> 00:08:28,660
such as mem copy<font color="#E5E5E5"> then we have</font><font color="#CCCCCC"> another</font>

214
00:08:25,960 --> 00:08:30,960
problem related to fixed size<font color="#CCCCCC"> erase so</font>

215
00:08:28,660 --> 00:08:34,960
here we have an example of<font color="#E5E5E5"> a system call</font>

216
00:08:30,960 --> 00:08:37,569
<font color="#E5E5E5">which returns the path to the system on</font>

217
00:08:34,960 --> 00:08:40,000
file system<font color="#E5E5E5"> and as you can</font><font color="#CCCCCC"> see we have</font>

218
00:08:37,570 --> 00:08:41,890
this huge array which is<font color="#CCCCCC"> allocated from</font>

219
00:08:40,000 --> 00:08:43,990
<font color="#E5E5E5">the stack but it's only partially</font>

220
00:08:41,890 --> 00:08:45,910
initialized with with the relevant

221
00:08:43,990 --> 00:08:47,970
string that we want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> return but the</font>

222
00:08:45,910 --> 00:08:51,689
kernel still returns the whole array

223
00:08:47,970 --> 00:08:53,450
with more than 200<font color="#CCCCCC"> initialized bytes</font>

224
00:08:51,690 --> 00:08:56,150
inside

225
00:08:53,450 --> 00:08:58,460
and we have a lot<font color="#CCCCCC"> of instances of such</font>

226
00:08:56,150 --> 00:09:00,260
long<font color="#E5E5E5"> fixed</font><font color="#CCCCCC"> size buffers in a window in</font>

227
00:08:58,460 --> 00:09:02,510
the Windows kernel<font color="#E5E5E5"> which are used in the</font>

228
00:09:00,260 --> 00:09:04,760
exchange of<font color="#E5E5E5"> data</font><font color="#CCCCCC"> between user and</font><font color="#E5E5E5"> kernel</font>

229
00:09:02,510 --> 00:09:08,240
mode<font color="#CCCCCC"> they used for paths</font><font color="#E5E5E5"> in the file</font>

230
00:09:04,760 --> 00:09:10,850
system<font color="#E5E5E5"> for names identifiers etc and</font>

231
00:09:08,240 --> 00:09:13,430
most most often even<font color="#E5E5E5"> though these</font>

232
00:09:10,850 --> 00:09:15,700
buffers are fixed in size the length of

233
00:09:13,430 --> 00:09:18,500
the content<font color="#E5E5E5"> inside is variable</font><font color="#CCCCCC"> and</font>

234
00:09:15,700 --> 00:09:21,950
usually most<font color="#E5E5E5"> of the storage used by the</font>

235
00:09:18,500 --> 00:09:23,630
array is actually<font color="#E5E5E5"> not not used at all</font><font color="#CCCCCC"> so</font>

236
00:09:21,950 --> 00:09:25,640
and the<font color="#E5E5E5"> other problem is that these</font>

237
00:09:23,630 --> 00:09:28,100
these arrays are often part<font color="#E5E5E5"> of</font>

238
00:09:25,640 --> 00:09:30,050
structures which are which<font color="#E5E5E5"> makes it even</font>

239
00:09:28,100 --> 00:09:33,380
harder<font color="#CCCCCC"> to only copy the relevant part of</font>

240
00:09:30,050 --> 00:09:35,420
<font color="#E5E5E5">the string</font><font color="#CCCCCC"> to user mode so and</font><font color="#E5E5E5"> also the</font>

241
00:09:33,380 --> 00:09:37,220
bad thing about<font color="#CCCCCC"> this is that since the</font>

242
00:09:35,420 --> 00:09:39,110
<font color="#E5E5E5">yes array can</font><font color="#CCCCCC"> be very huge</font>

243
00:09:37,220 --> 00:09:42,010
they can also leak<font color="#CCCCCC"> a</font><font color="#E5E5E5"> lot of data from</font>

244
00:09:39,110 --> 00:09:44,450
<font color="#E5E5E5">the kernel to the user space at once and</font>

245
00:09:42,010 --> 00:09:47,120
then we have yet another<font color="#E5E5E5"> problem which</font>

246
00:09:44,450 --> 00:09:50,900
<font color="#CCCCCC">is kind of specific</font><font color="#E5E5E5"> to Windows but not</font>

247
00:09:47,120 --> 00:09:53,870
not<font color="#E5E5E5"> not only so even though we have this</font>

248
00:09:50,900 --> 00:09:57,230
<font color="#E5E5E5">system call</font><font color="#CCCCCC"> which only returns</font><font color="#E5E5E5"> 12 bytes</font>

249
00:09:53,870 --> 00:09:59,660
in total in three magic D words<font color="#E5E5E5"> it</font>

250
00:09:57,230 --> 00:10:01,730
allows<font color="#CCCCCC"> the</font><font color="#E5E5E5"> user mode color to specify</font>

251
00:09:59,660 --> 00:10:04,250
the length of the output<font color="#E5E5E5"> buffer and it</font>

252
00:10:01,730 --> 00:10:07,130
allocates<font color="#E5E5E5"> a number of bytes</font><font color="#CCCCCC"> that is</font>

253
00:10:04,250 --> 00:10:08,780
<font color="#E5E5E5">requested</font><font color="#CCCCCC"> by the user a mode color</font><font color="#E5E5E5"> and</font>

254
00:10:07,130 --> 00:10:10,910
even though it only<font color="#E5E5E5"> writes a limited</font>

255
00:10:08,780 --> 00:10:13,430
<font color="#CCCCCC">number of bytes into</font><font color="#E5E5E5"> the buffer it</font>

256
00:10:10,910 --> 00:10:16,819
copies<font color="#E5E5E5"> this use this kernel mode buffer</font>

257
00:10:13,430 --> 00:10:18,620
in a<font color="#E5E5E5"> hole back to user mode so we also</font>

258
00:10:16,820 --> 00:10:21,980
end up<font color="#CCCCCC"> with a lot of</font><font color="#E5E5E5"> uninitialized data</font>

259
00:10:18,620 --> 00:10:24,620
here<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is also</font><font color="#E5E5E5"> very</font><font color="#CCCCCC"> common in</font><font color="#E5E5E5"> Windows</font>

260
00:10:21,980 --> 00:10:27,110
as I said<font color="#E5E5E5"> and the interesting</font><font color="#CCCCCC"> thing</font>

261
00:10:24,620 --> 00:10:29,060
about this is<font color="#CCCCCC"> that it this this kind</font><font color="#E5E5E5"> of</font>

262
00:10:27,110 --> 00:10:30,860
<font color="#E5E5E5">bug may actually enable disclosure from</font>

263
00:10:29,060 --> 00:10:32,900
<font color="#E5E5E5">both the stack and the heap in the same</font>

264
00:10:30,860 --> 00:10:35,240
affected code because<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> fact that</font>

265
00:10:32,900 --> 00:10:37,130
<font color="#E5E5E5">Windows uses an optimization so for</font>

266
00:10:35,240 --> 00:10:38,870
small request sizes it uses stack

267
00:10:37,130 --> 00:10:42,830
buffers and for a larger<font color="#CCCCCC"> one it uses</font>

268
00:10:38,870 --> 00:10:45,110
<font color="#E5E5E5">heap allocations in many cases and it</font>

269
00:10:42,830 --> 00:10:48,770
<font color="#E5E5E5">often leads to large leaks of control</font>

270
00:10:45,110 --> 00:10:52,130
number of bytes and the worst thing is

271
00:10:48,770 --> 00:10:54,170
<font color="#CCCCCC">that in this particular</font><font color="#E5E5E5"> case it could be</font>

272
00:10:52,130 --> 00:10:56,630
<font color="#E5E5E5">possible for the user to actually be</font>

273
00:10:54,170 --> 00:10:58,819
able<font color="#E5E5E5"> to specify that the size of the</font>

274
00:10:56,630 --> 00:11:01,010
allocation that<font color="#CCCCCC"> is</font><font color="#E5E5E5"> being leaked so it</font>

275
00:10:58,820 --> 00:11:02,750
may enable<font color="#CCCCCC"> the attacker to</font><font color="#E5E5E5"> try to</font>

276
00:11:01,010 --> 00:11:05,300
collide with<font color="#E5E5E5"> interesting objects in</font>

277
00:11:02,750 --> 00:11:07,010
kernel mode<font color="#CCCCCC"> memory in order to leak</font>

278
00:11:05,300 --> 00:11:09,740
something interesting

279
00:11:07,010 --> 00:11:11,540
so apart from<font color="#E5E5E5"> all of this we have some</font>

280
00:11:09,740 --> 00:11:14,360
<font color="#E5E5E5">more factors which contribute</font><font color="#CCCCCC"> to this</font>

281
00:11:11,540 --> 00:11:17,120
whole problem<font color="#CCCCCC"> so first of all</font><font color="#E5E5E5"> neither</font>

282
00:11:14,360 --> 00:11:18,920
windows nor Linux actually pre

283
00:11:17,120 --> 00:11:21,649
initialized allocations on the stack<font color="#CCCCCC"> or</font>

284
00:11:18,920 --> 00:11:24,139
heap by default<font color="#CCCCCC"> of course there are</font><font color="#E5E5E5"> a</font>

285
00:11:21,649 --> 00:11:27,320
lot of<font color="#CCCCCC"> exceptions mostly in Linux such</font>

286
00:11:24,139 --> 00:11:30,829
as the case a<font color="#CCCCCC"> lock function</font><font color="#E5E5E5"> the GFP zero</font>

287
00:11:27,320 --> 00:11:33,889
flag etc<font color="#E5E5E5"> but in general allocations are</font>

288
00:11:30,829 --> 00:11:37,790
not initialized by default<font color="#CCCCCC"> a recent</font>

289
00:11:33,889 --> 00:11:40,730
<font color="#CCCCCC">change in</font><font color="#E5E5E5"> Windows from a few months ago</font>

290
00:11:37,790 --> 00:11:43,969
<font color="#E5E5E5">is that some some allocations used for</font>

291
00:11:40,730 --> 00:11:45,949
ioctl<font color="#CCCCCC"> IO buffers are initialized now but</font>

292
00:11:43,970 --> 00:11:48,649
that is<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is something</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> was not</font>

293
00:11:45,949 --> 00:11:51,260
<font color="#CCCCCC">true</font><font color="#E5E5E5"> two months ago</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> the general rule</font>

294
00:11:48,649 --> 00:11:53,870
still stands<font color="#E5E5E5"> and as you can</font><font color="#CCCCCC"> see here in</font>

295
00:11:51,260 --> 00:11:55,790
the screenshot even the official

296
00:11:53,870 --> 00:11:57,649
<font color="#E5E5E5">documentation of the</font><font color="#CCCCCC"> X</font><font color="#E5E5E5"> allocate</font><font color="#CCCCCC"> pool</font>

297
00:11:55,790 --> 00:12:00,620
<font color="#E5E5E5">with</font><font color="#CCCCCC"> tagged windows function warns about</font>

298
00:11:57,649 --> 00:12:02,839
<font color="#E5E5E5">the fact that allocations returned by</font>

299
00:12:00,620 --> 00:12:05,149
this function<font color="#E5E5E5"> contain initialized memory</font>

300
00:12:02,839 --> 00:12:08,110
and if the code wants to return it<font color="#E5E5E5"> to</font>

301
00:12:05,149 --> 00:12:10,399
user mode<font color="#E5E5E5"> it has</font><font color="#CCCCCC"> to memset</font><font color="#E5E5E5"> it first</font>

302
00:12:08,110 --> 00:12:12,560
another factor is that<font color="#E5E5E5"> there are no</font>

303
00:12:10,399 --> 00:12:15,410
visible visible consequences of this

304
00:12:12,560 --> 00:12:18,800
<font color="#E5E5E5">kind of behavior</font><font color="#CCCCCC"> so even though</font><font color="#E5E5E5"> C and</font>

305
00:12:15,410 --> 00:12:20,870
<font color="#E5E5E5">C++ don't really make</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> easy for</font><font color="#CCCCCC"> the</font>

306
00:12:18,800 --> 00:12:23,060
code to copy data securely between

307
00:12:20,870 --> 00:12:25,100
<font color="#CCCCCC">security</font><font color="#E5E5E5"> domains there isn't any</font>

308
00:12:23,060 --> 00:12:27,800
punishment<font color="#CCCCCC"> if</font><font color="#E5E5E5"> you fail to</font><font color="#CCCCCC"> do it</font>

309
00:12:25,100 --> 00:12:30,529
<font color="#E5E5E5">correctly</font><font color="#CCCCCC"> so you know</font><font color="#E5E5E5"> even if the kernel</font>

310
00:12:27,800 --> 00:12:33,260
discloses if you initialize bytes<font color="#E5E5E5"> in one</font>

311
00:12:30,529 --> 00:12:36,709
syscall or another<font color="#CCCCCC"> nothing will really</font>

312
00:12:33,260 --> 00:12:39,740
<font color="#E5E5E5">crash</font><font color="#CCCCCC"> in most cases and so no one will</font>

313
00:12:36,709 --> 00:12:41,420
discover<font color="#E5E5E5"> this bug and so as a</font><font color="#CCCCCC"> result if</font>

314
00:12:39,740 --> 00:12:43,550
a kernel developer is not<font color="#E5E5E5"> aware of this</font>

315
00:12:41,420 --> 00:12:45,890
<font color="#CCCCCC">bug class and they</font><font color="#E5E5E5"> are not trying</font><font color="#CCCCCC"> to</font>

316
00:12:43,550 --> 00:12:48,380
<font color="#E5E5E5">actively prevent it</font><font color="#CCCCCC"> they will</font><font color="#E5E5E5"> probably</font>

317
00:12:45,890 --> 00:12:51,170
<font color="#E5E5E5">never kind of find out because the code</font>

318
00:12:48,380 --> 00:12:54,589
crashes or<font color="#CCCCCC"> something doesn't work so</font>

319
00:12:51,170 --> 00:12:57,500
it's a very silent type<font color="#E5E5E5"> of bug</font><font color="#CCCCCC"> yet</font>

320
00:12:54,589 --> 00:12:59,390
another factor<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the fact</font><font color="#E5E5E5"> that it might</font>

321
00:12:57,500 --> 00:13:00,980
<font color="#E5E5E5">be not very easy</font><font color="#CCCCCC"> to discover that any</font>

322
00:12:59,390 --> 00:13:03,920
leaks from kernel mode are actually

323
00:13:00,980 --> 00:13:05,899
taking<font color="#CCCCCC"> place because</font><font color="#E5E5E5"> some</font><font color="#CCCCCC"> of them could</font>

324
00:13:03,920 --> 00:13:08,420
be<font color="#E5E5E5"> hidden behind the user</font><font color="#CCCCCC"> mode system</font>

325
00:13:05,899 --> 00:13:10,399
<font color="#CCCCCC">api so</font><font color="#E5E5E5"> even though data is actually</font>

326
00:13:08,420 --> 00:13:14,180
<font color="#E5E5E5">leaked from</font><font color="#CCCCCC"> the system kernel back to</font>

327
00:13:10,399 --> 00:13:16,910
user mode<font color="#CCCCCC"> in general</font><font color="#E5E5E5"> that the original</font>

328
00:13:14,180 --> 00:13:20,540
color<font color="#CCCCCC"> of the system api might not see</font>

329
00:13:16,910 --> 00:13:21,920
this<font color="#E5E5E5"> data at all so yeah</font>

330
00:13:20,540 --> 00:13:25,339
when it comes to the severity and

331
00:13:21,920 --> 00:13:27,949
considerations of<font color="#E5E5E5"> this of these bugs</font><font color="#CCCCCC"> you</font>

332
00:13:25,339 --> 00:13:30,320
can say that they<font color="#E5E5E5"> are</font><font color="#CCCCCC"> not very severe</font>

333
00:13:27,949 --> 00:13:32,449
because<font color="#E5E5E5"> it's just local info leaks</font><font color="#CCCCCC"> there</font>

334
00:13:30,320 --> 00:13:34,459
is no<font color="#E5E5E5"> memory corruption taking place</font><font color="#CCCCCC"> now</font>

335
00:13:32,449 --> 00:13:38,599
remote exploitation involved by nature

336
00:13:34,459 --> 00:13:40,790
and and and<font color="#E5E5E5"> etc</font><font color="#CCCCCC"> but the actual severity</font>

337
00:13:38,600 --> 00:13:42,050
depends on what we<font color="#E5E5E5"> managed to leak out</font>

338
00:13:40,790 --> 00:13:44,060
<font color="#CCCCCC">of</font><font color="#E5E5E5"> the kernel</font>

339
00:13:42,050 --> 00:13:45,680
this can be addresses that we can use

340
00:13:44,060 --> 00:13:47,630
for further<font color="#E5E5E5"> exploitation of other</font>

341
00:13:45,680 --> 00:13:49,310
vulnerabilities<font color="#CCCCCC"> or it can be some</font>

342
00:13:47,630 --> 00:13:51,529
sensitive<font color="#E5E5E5"> data that we can use more</font>

343
00:13:49,310 --> 00:13:54,920
directly<font color="#E5E5E5"> to elevate our privileges in</font>

344
00:13:51,529 --> 00:13:57,139
the system<font color="#E5E5E5"> but on the positive</font><font color="#CCCCCC"> side from</font>

345
00:13:54,920 --> 00:13:59,269
the attacker perspective<font color="#E5E5E5"> these bugs are</font>

346
00:13:57,139 --> 00:14:01,610
mostly silent and transparent so we<font color="#E5E5E5"> can</font>

347
00:13:59,269 --> 00:14:03,440
try to exploit them basically

348
00:14:01,610 --> 00:14:05,360
indefinitely and<font color="#E5E5E5"> very silently without</font>

349
00:14:03,440 --> 00:14:07,850
<font color="#CCCCCC">ever worrying about the system going</font>

350
00:14:05,360 --> 00:14:09,740
<font color="#E5E5E5">down or someone actually discovering</font>

351
00:14:07,850 --> 00:14:13,130
<font color="#E5E5E5">that something something fishy is going</font>

352
00:14:09,740 --> 00:14:15,860
on<font color="#CCCCCC"> hmm so as I</font><font color="#E5E5E5"> said these bugs are</font>

353
00:14:13,130 --> 00:14:18,560
mostly useful<font color="#E5E5E5"> in practice as a single</font>

354
00:14:15,860 --> 00:14:20,990
link in a full exploit<font color="#CCCCCC"> chains for local</font>

355
00:14:18,560 --> 00:14:22,518
privilege escalation<font color="#E5E5E5"> especially given</font>

356
00:14:20,990 --> 00:14:24,440
how much effort is<font color="#CCCCCC"> actually being put</font>

357
00:14:22,519 --> 00:14:27,949
into protecting kernel address space

358
00:14:24,440 --> 00:14:30,680
information<font color="#E5E5E5"> in Windows and one real-life</font>

359
00:14:27,949 --> 00:14:32,569
example<font color="#E5E5E5"> of this would be an exploit</font>

360
00:14:30,680 --> 00:14:35,719
found in the hacking<font color="#CCCCCC"> team</font><font color="#E5E5E5"> dump two years</font>

361
00:14:32,569 --> 00:14:37,729
ago so in order<font color="#E5E5E5"> to exploit another</font>

362
00:14:35,720 --> 00:14:39,740
vulnerability<font color="#E5E5E5"> they used a pool memory</font>

363
00:14:37,730 --> 00:14:43,660
disclosure<font color="#E5E5E5"> which leaked the base address</font>

364
00:14:39,740 --> 00:14:46,910
<font color="#CCCCCC">of the winter dedicated sis</font><font color="#E5E5E5"> driver</font><font color="#CCCCCC"> and</font>

365
00:14:43,660 --> 00:14:50,029
so yeah it was used in practice<font color="#E5E5E5"> and at</font>

366
00:14:46,910 --> 00:14:52,600
the same time<font color="#E5E5E5"> a few weeks before all of</font>

367
00:14:50,029 --> 00:14:55,279
this came to light<font color="#CCCCCC"> a project zero</font>

368
00:14:52,600 --> 00:14:58,670
<font color="#CCCCCC">researcher mod</font><font color="#E5E5E5"> state also discovered</font>

369
00:14:55,279 --> 00:15:01,699
this<font color="#E5E5E5"> independently and reported it so</font>

370
00:14:58,670 --> 00:15:03,500
yeah<font color="#E5E5E5"> when it comes to the benefits</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> of</font>

371
00:15:01,699 --> 00:15:05,839
<font color="#E5E5E5">this kind</font><font color="#CCCCCC"> of disclosures you have to</font>

372
00:15:03,500 --> 00:15:07,010
consider<font color="#E5E5E5"> them separately when it comes</font>

373
00:15:05,839 --> 00:15:10,120
to whether they<font color="#E5E5E5"> are stack or heap</font>

374
00:15:07,010 --> 00:15:12,980
<font color="#E5E5E5">disclosures so</font><font color="#CCCCCC"> when it comes to stack</font>

375
00:15:10,120 --> 00:15:16,610
these are consistent<font color="#CCCCCC"> and immediately</font>

376
00:15:12,980 --> 00:15:18,529
useful values<font color="#E5E5E5"> because you know these are</font>

377
00:15:16,610 --> 00:15:21,769
the desert<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is the type of data that</font>

378
00:15:18,529 --> 00:15:24,019
<font color="#E5E5E5">is being stored on</font><font color="#CCCCCC"> the stack so</font><font color="#E5E5E5"> we have</font>

379
00:15:21,769 --> 00:15:26,930
things<font color="#CCCCCC"> like addresses of the kernel</font>

380
00:15:24,019 --> 00:15:29,540
stack because of the stack pointers we

381
00:15:26,930 --> 00:15:31,790
have heap addresses we have<font color="#E5E5E5"> addresses of</font>

382
00:15:29,540 --> 00:15:33,949
executable images because of return

383
00:15:31,790 --> 00:15:36,019
addresses we can leak

384
00:15:33,950 --> 00:15:38,180
values of<font color="#CCCCCC"> stock cookies which can be</font>

385
00:15:36,019 --> 00:15:40,970
then used<font color="#CCCCCC"> to exploit</font><font color="#E5E5E5"> a stack buffer</font>

386
00:15:38,180 --> 00:15:43,219
overflow<font color="#E5E5E5"> we have some Cisco specific</font>

387
00:15:40,970 --> 00:15:46,329
data that<font color="#CCCCCC"> is used</font><font color="#E5E5E5"> by services called</font>

388
00:15:43,220 --> 00:15:49,209
directly<font color="#E5E5E5"> before the leaking Cisco and</font>

389
00:15:46,329 --> 00:15:51,829
also interesting thing is that<font color="#E5E5E5"> we can</font>

390
00:15:49,209 --> 00:15:53,930
<font color="#CCCCCC">sometimes leak data</font><font color="#E5E5E5"> of interrupt</font>

391
00:15:51,829 --> 00:15:55,969
handlers if they happen to trigger<font color="#E5E5E5"> in</font>

392
00:15:53,930 --> 00:15:59,660
the same context as the<font color="#E5E5E5"> exploiting</font>

393
00:15:55,970 --> 00:16:01,699
threat<font color="#CCCCCC"> but</font><font color="#E5E5E5"> that's only on Windows 7 on</font>

394
00:15:59,660 --> 00:16:04,730
the<font color="#E5E5E5"> other hand when it comes to heap</font>

395
00:16:01,699 --> 00:16:07,719
disclosure<font color="#CCCCCC"> we have kind</font><font color="#E5E5E5"> of less</font><font color="#CCCCCC"> obvious</font>

396
00:16:04,730 --> 00:16:10,490
memory because it's it's<font color="#E5E5E5"> not always just</font>

397
00:16:07,720 --> 00:16:12,410
pointers to the stack<font color="#E5E5E5"> into executable</font>

398
00:16:10,490 --> 00:16:14,449
images but we have more potential<font color="#E5E5E5"> to</font>

399
00:16:12,410 --> 00:16:16,910
collide with<font color="#CCCCCC"> something</font><font color="#E5E5E5"> that is more</font>

400
00:16:14,449 --> 00:16:18,500
<font color="#CCCCCC">sensitive</font><font color="#E5E5E5"> so of course we have addresses</font>

401
00:16:16,910 --> 00:16:20,149
again of the heap<font color="#E5E5E5"> and potentially of</font>

402
00:16:18,500 --> 00:16:24,019
executable images but we can collide

403
00:16:20,149 --> 00:16:25,850
with virtually allocations of any active

404
00:16:24,019 --> 00:16:31,779
kernel modules<font color="#CCCCCC"> related to the disk</font>

405
00:16:25,850 --> 00:16:35,180
<font color="#E5E5E5">networking video</font><font color="#CCCCCC"> etc yeah interestingly</font>

406
00:16:31,779 --> 00:16:38,170
<font color="#E5E5E5">there hasn't been too much work with</font>

407
00:16:35,180 --> 00:16:41,269
within<font color="#CCCCCC"> that space on Windows</font><font color="#E5E5E5"> so</font>

408
00:16:38,170 --> 00:16:43,189
according<font color="#CCCCCC"> to my best knowledge people</font>

409
00:16:41,269 --> 00:16:45,860
have started<font color="#E5E5E5"> to</font><font color="#CCCCCC"> take interest</font><font color="#E5E5E5"> in this</font>

410
00:16:43,190 --> 00:16:48,380
<font color="#E5E5E5">kind of issues something like two years</font>

411
00:16:45,860 --> 00:16:50,240
ago<font color="#E5E5E5"> so we have this this one issue in</font>

412
00:16:48,380 --> 00:16:53,290
project<font color="#E5E5E5"> zero tracker discovered by</font><font color="#CCCCCC"> Mott</font>

413
00:16:50,240 --> 00:16:56,060
state<font color="#E5E5E5"> then we have a presentation</font><font color="#CCCCCC"> of</font>

414
00:16:53,290 --> 00:16:58,760
<font color="#E5E5E5">given by</font><font color="#CCCCCC"> wandering glitch</font><font color="#E5E5E5"> last year</font>

415
00:16:56,060 --> 00:17:01,699
about several<font color="#E5E5E5"> unutilized memory</font>

416
00:16:58,760 --> 00:17:03,860
disclosure bugs<font color="#E5E5E5"> fixed in 2015 and we</font>

417
00:17:01,699 --> 00:17:06,199
have two more<font color="#E5E5E5"> we have a presentation</font>

418
00:17:03,860 --> 00:17:08,120
from this year from can sequester

419
00:17:06,199 --> 00:17:10,640
which doesn't really concern this

420
00:17:08,119 --> 00:17:12,948
subject but mentions that there<font color="#E5E5E5"> are some</font>

421
00:17:10,640 --> 00:17:15,500
<font color="#E5E5E5">leaks in win32</font><font color="#CCCCCC"> k user</font><font color="#E5E5E5"> remote callbacks</font>

422
00:17:12,949 --> 00:17:18,500
<font color="#E5E5E5">and also we have this work from</font><font color="#CCCCCC"> just</font>

423
00:17:15,500 --> 00:17:21,319
last month from<font color="#E5E5E5"> two researchers which</font>

424
00:17:18,500 --> 00:17:23,689
also collided with my<font color="#E5E5E5"> research and and</font>

425
00:17:21,319 --> 00:17:25,040
tried<font color="#CCCCCC"> to find some</font><font color="#E5E5E5"> sum of info</font><font color="#CCCCCC"> League</font>

426
00:17:23,689 --> 00:17:28,910
parks in the Windows kernel

427
00:17:25,040 --> 00:17:31,100
<font color="#E5E5E5">automatically on the</font><font color="#CCCCCC"> other hand the</font>

428
00:17:28,910 --> 00:17:32,210
<font color="#E5E5E5">problem seems to be much better well</font>

429
00:17:31,100 --> 00:17:36,219
<font color="#E5E5E5">known on Linux</font>

430
00:17:32,210 --> 00:17:38,799
so already<font color="#E5E5E5"> seven years ago Dan Rosenberg</font>

431
00:17:36,220 --> 00:17:41,990
<font color="#E5E5E5">apparently went on a rampage and killed</font>

432
00:17:38,799 --> 00:17:45,500
<font color="#E5E5E5">several dozen I think more than 20 info</font>

433
00:17:41,990 --> 00:17:47,190
leaks<font color="#E5E5E5"> in various subsystems</font><font color="#CCCCCC"> he presented</font>

434
00:17:45,500 --> 00:17:50,640
<font color="#E5E5E5">some</font><font color="#CCCCCC"> of this work in</font>

435
00:17:47,190 --> 00:17:53,730
<font color="#CCCCCC">patien given by him and yon aburrida</font><font color="#E5E5E5"> in</font>

436
00:17:50,640 --> 00:17:56,670
2011<font color="#CCCCCC"> and then there are</font><font color="#E5E5E5"> also a lot of</font>

437
00:17:53,730 --> 00:18:00,120
<font color="#E5E5E5">other comets provided by different</font>

438
00:17:56,670 --> 00:18:01,860
<font color="#E5E5E5">security researchers which who</font>

439
00:18:00,120 --> 00:18:02,969
discovered this kind of bugs throughout

440
00:18:01,860 --> 00:18:05,159
the history

441
00:18:02,970 --> 00:18:06,900
so this problem<font color="#E5E5E5"> seems</font><font color="#CCCCCC"> to be much better</font>

442
00:18:05,160 --> 00:18:09,630
well known and well well understood in

443
00:18:06,900 --> 00:18:11,190
Linux<font color="#CCCCCC"> than it is on</font><font color="#E5E5E5"> Windows</font><font color="#CCCCCC"> probably</font>

444
00:18:09,630 --> 00:18:13,770
<font color="#E5E5E5">because of the fact</font><font color="#CCCCCC"> that Linux is open</font>

445
00:18:11,190 --> 00:18:16,380
source so you can<font color="#E5E5E5"> more easily find this</font>

446
00:18:13,770 --> 00:18:20,670
kind of stuff there<font color="#CCCCCC"> so let's look into</font>

447
00:18:16,380 --> 00:18:23,070
the design of<font color="#E5E5E5"> the of the tool now</font><font color="#CCCCCC"> we'll</font>

448
00:18:20,670 --> 00:18:25,320
start with a quick description<font color="#E5E5E5"> of box</font>

449
00:18:23,070 --> 00:18:28,409
because box<font color="#CCCCCC"> spawn reloaded is is based</font>

450
00:18:25,320 --> 00:18:31,080
on the<font color="#CCCCCC"> Box emulator it's a full emulator</font>

451
00:18:28,410 --> 00:18:35,850
developed by Intel<font color="#CCCCCC"> it has a full</font>

452
00:18:31,080 --> 00:18:37,649
implementation of<font color="#CCCCCC"> the CPU</font><font color="#E5E5E5"> it has support</font>

453
00:18:35,850 --> 00:18:40,639
<font color="#E5E5E5">for all</font><font color="#CCCCCC"> of the latest features</font><font color="#E5E5E5"> of the</font>

454
00:18:37,650 --> 00:18:43,830
CPU<font color="#CCCCCC"> all of the extensions such as</font><font color="#E5E5E5"> SSE</font><font color="#CCCCCC"> a</font>

455
00:18:40,640 --> 00:18:46,980
<font color="#CCCCCC">Fe X and stuff</font><font color="#E5E5E5"> like that it also has all</font>

456
00:18:43,830 --> 00:18:49,020
basic peripherals<font color="#CCCCCC"> so you can just run a</font>

457
00:18:46,980 --> 00:18:52,350
full operating system on this single

458
00:18:49,020 --> 00:18:53,730
emulator<font color="#E5E5E5"> without any problems and a good</font>

459
00:18:52,350 --> 00:18:56,010
thing is<font color="#CCCCCC"> that it</font><font color="#E5E5E5"> also</font><font color="#CCCCCC"> provides an</font>

460
00:18:53,730 --> 00:18:59,400
extension instrumentation API so we can

461
00:18:56,010 --> 00:19:01,980
we can<font color="#E5E5E5"> in addition to just running the</font>

462
00:18:59,400 --> 00:19:03,930
system we<font color="#E5E5E5"> can look into how it works and</font>

463
00:19:01,980 --> 00:19:07,380
we<font color="#CCCCCC"> can change its behavior</font><font color="#E5E5E5"> in any way we</font>

464
00:19:03,930 --> 00:19:10,140
want<font color="#CCCCCC"> in</font><font color="#E5E5E5"> terms of performance</font><font color="#CCCCCC"> of this</font>

465
00:19:07,380 --> 00:19:12,990
emulator<font color="#E5E5E5"> since it's a full system is</font>

466
00:19:10,140 --> 00:19:15,180
full<font color="#E5E5E5"> software emulator the performance</font>

467
00:19:12,990 --> 00:19:18,030
is<font color="#E5E5E5"> not very good so here we have you can</font>

468
00:19:15,180 --> 00:19:19,740
<font color="#E5E5E5">see that I at this at the point of</font>

469
00:19:18,030 --> 00:19:22,080
taking<font color="#E5E5E5"> the</font><font color="#CCCCCC"> screenshot it was executing</font>

470
00:19:19,740 --> 00:19:24,570
<font color="#E5E5E5">for to me about 40 million instructions</font>

471
00:19:22,080 --> 00:19:27,120
per second so that's not too<font color="#E5E5E5"> much</font>

472
00:19:24,570 --> 00:19:30,030
the longer story is that<font color="#E5E5E5"> if we have a</font>

473
00:19:27,120 --> 00:19:33,389
<font color="#E5E5E5">non instrumented guest it can run up</font><font color="#CCCCCC"> to</font>

474
00:19:30,030 --> 00:19:35,310
100<font color="#E5E5E5"> IPS which is sufficient to boot a</font>

475
00:19:33,390 --> 00:19:38,610
system in kind of reasonable<font color="#E5E5E5"> time which</font>

476
00:19:35,310 --> 00:19:40,889
is under<font color="#CCCCCC"> five minutes and when we do it</font>

477
00:19:38,610 --> 00:19:44,669
the environment<font color="#CCCCCC"> is</font><font color="#E5E5E5"> fairly responsive we</font>

478
00:19:40,890 --> 00:19:47,280
can you know<font color="#E5E5E5"> like use the system</font>

479
00:19:44,670 --> 00:19:49,680
move the mouse<font color="#E5E5E5"> open</font><font color="#CCCCCC"> some applications</font>

480
00:19:47,280 --> 00:19:51,510
<font color="#E5E5E5">and stuff like that when we add some</font>

481
00:19:49,680 --> 00:19:53,160
<font color="#E5E5E5">instrumentation on top of that we have</font>

482
00:19:51,510 --> 00:19:56,160
some<font color="#E5E5E5"> overhead depending on what</font>

483
00:19:53,160 --> 00:19:58,230
instrumentation we write in my case in

484
00:19:56,160 --> 00:20:02,480
in case of box phone reloaded that

485
00:19:58,230 --> 00:20:05,519
performance drop was to around 30 to 40

486
00:20:02,480 --> 00:20:07,679
<font color="#CCCCCC">million IPS which was still kind of</font>

487
00:20:05,519 --> 00:20:09,779
<font color="#E5E5E5">acceptable for research purposes so I</font>

488
00:20:07,679 --> 00:20:13,320
can still interact with<font color="#E5E5E5"> the system</font><font color="#CCCCCC"> and</font>

489
00:20:09,779 --> 00:20:15,210
get some visible results<font color="#CCCCCC"> but when</font>

490
00:20:13,320 --> 00:20:16,980
interacting<font color="#CCCCCC"> with box we actually had to</font>

491
00:20:15,210 --> 00:20:18,450
<font color="#E5E5E5">put a lot of effort into</font><font color="#CCCCCC"> making</font><font color="#E5E5E5"> sure</font>

492
00:20:16,980 --> 00:20:21,480
that the logic that<font color="#CCCCCC"> we're implementing</font>

493
00:20:18,450 --> 00:20:26,580
<font color="#E5E5E5">in</font><font color="#CCCCCC"> the instrumentation</font><font color="#E5E5E5"> is is as simple</font>

494
00:20:21,480 --> 00:20:28,019
and as<font color="#E5E5E5"> fast as possible</font><font color="#CCCCCC"> so about the</font>

495
00:20:26,580 --> 00:20:32,908
instrumentation support<font color="#E5E5E5"> in box</font>

496
00:20:28,019 --> 00:20:35,909
technically it works through<font color="#E5E5E5"> macros</font>

497
00:20:32,909 --> 00:20:40,049
defined in<font color="#E5E5E5"> C++ starting with the BX</font>

498
00:20:35,909 --> 00:20:42,690
<font color="#CCCCCC">instru prefix and</font><font color="#E5E5E5"> then we have a lot of</font>

499
00:20:40,049 --> 00:20:46,039
callbacks<font color="#CCCCCC"> to actually choose from so we</font>

500
00:20:42,690 --> 00:20:48,149
can we can execute our own code<font color="#E5E5E5"> on</font>

501
00:20:46,039 --> 00:20:51,119
initialization of<font color="#E5E5E5"> the virtual machine</font>

502
00:20:48,149 --> 00:20:53,850
shuts down before and after executing an

503
00:20:51,119 --> 00:20:56,639
instruction on linear<font color="#E5E5E5"> and physical</font>

504
00:20:53,850 --> 00:20:58,109
memory access on exceptions<font color="#E5E5E5"> interrupts</font>

505
00:20:56,639 --> 00:20:59,789
<font color="#E5E5E5">and stuff like that so we</font><font color="#CCCCCC"> can control</font>

506
00:20:58,109 --> 00:21:02,908
and<font color="#CCCCCC"> everything that is going on</font><font color="#E5E5E5"> in the</font>

507
00:20:59,789 --> 00:21:05,549
system<font color="#CCCCCC"> and this enables us to develop</font>

508
00:21:02,909 --> 00:21:07,200
virtually any logic that we want<font color="#CCCCCC"> to do</font>

509
00:21:05,549 --> 00:21:09,720
so we can count statistics on what

510
00:21:07,200 --> 00:21:12,389
<font color="#E5E5E5">instructions are executing and how often</font>

511
00:21:09,720 --> 00:21:15,659
<font color="#E5E5E5">we can trace instructions or trace</font>

512
00:21:12,389 --> 00:21:16,488
memory<font color="#E5E5E5"> accesses add metadata and stuff</font>

513
00:21:15,659 --> 00:21:19,350
like that

514
00:21:16,489 --> 00:21:21,149
<font color="#E5E5E5">so here you can see a full</font><font color="#CCCCCC"> list</font><font color="#E5E5E5"> of the</font>

515
00:21:19,350 --> 00:21:23,399
instrumentation callbacks<font color="#CCCCCC"> that</font><font color="#E5E5E5"> box</font>

516
00:21:21,149 --> 00:21:26,189
provides and the<font color="#CCCCCC"> ones that are</font>

517
00:21:23,399 --> 00:21:28,619
<font color="#E5E5E5">underlined</font><font color="#CCCCCC"> are the ones that</font><font color="#E5E5E5"> that I used</font>

518
00:21:26,190 --> 00:21:30,809
in box<font color="#CCCCCC"> one reloaded</font><font color="#E5E5E5"> so it's not not too</font>

519
00:21:28,619 --> 00:21:32,399
<font color="#CCCCCC">many</font><font color="#E5E5E5"> of them</font><font color="#CCCCCC"> basically the most</font>

520
00:21:30,809 --> 00:21:34,769
important ones are<font color="#E5E5E5"> just the ones</font>

521
00:21:32,399 --> 00:21:37,080
triggering before and after execution<font color="#E5E5E5"> of</font>

522
00:21:34,769 --> 00:21:40,470
an instruction and the one triggering on

523
00:21:37,080 --> 00:21:42,989
accessing linear memory and the

524
00:21:40,470 --> 00:21:45,600
<font color="#CCCCCC">CoreLogic of box bone</font><font color="#E5E5E5"> is that we want to</font>

525
00:21:42,989 --> 00:21:48,779
change track the<font color="#E5E5E5"> entire kernel address</font>

526
00:21:45,600 --> 00:21:50,969
space<font color="#E5E5E5"> and in order to do it we</font><font color="#CCCCCC"> need to</font>

527
00:21:48,779 --> 00:21:53,159
first<font color="#E5E5E5"> be able</font><font color="#CCCCCC"> to send change</font><font color="#E5E5E5"> on new</font>

528
00:21:50,970 --> 00:21:55,139
<font color="#E5E5E5">allocations</font><font color="#CCCCCC"> that are being performed in</font>

529
00:21:53,159 --> 00:21:57,149
kernel mode<font color="#E5E5E5"> both from the stack</font><font color="#CCCCCC"> and the</font>

530
00:21:55,139 --> 00:22:00,178
heap<font color="#E5E5E5"> then we want to be able to remove</font>

531
00:21:57,149 --> 00:22:02,008
taint when memory is freed of course we

532
00:22:00,179 --> 00:22:04,590
want<font color="#E5E5E5"> to propagate taint in memory and</font>

533
00:22:02,009 --> 00:22:07,230
<font color="#E5E5E5">then most importantly we want</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> detect</font>

534
00:22:04,590 --> 00:22:09,740
when some initialized memory is copied

535
00:22:07,230 --> 00:22:13,559
<font color="#CCCCCC">from the</font><font color="#E5E5E5"> kernel space to the user space</font>

536
00:22:09,740 --> 00:22:14,580
apart from<font color="#E5E5E5"> that core functionality it's</font>

537
00:22:13,559 --> 00:22:17,010
also good<font color="#E5E5E5"> that</font>

538
00:22:14,580 --> 00:22:19,590
we are able<font color="#E5E5E5"> to reproduce</font><font color="#CCCCCC"> the bugs and</font>

539
00:22:17,010 --> 00:22:21,510
<font color="#CCCCCC">analyse them somehow so in order</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> do</font>

540
00:22:19,590 --> 00:22:24,120
that we<font color="#E5E5E5"> want to also keep track of all</font>

541
00:22:21,510 --> 00:22:27,269
the loaded<font color="#CCCCCC"> cast kernel modules so we</font>

542
00:22:24,120 --> 00:22:30,360
know which driver is triggering<font color="#E5E5E5"> the bug</font>

543
00:22:27,269 --> 00:22:32,820
<font color="#CCCCCC">we will also</font><font color="#E5E5E5"> want to read full stack</font>

544
00:22:30,360 --> 00:22:35,668
traces to be able<font color="#CCCCCC"> to duplicate the bugs</font>

545
00:22:32,820 --> 00:22:38,309
<font color="#E5E5E5">not to run into the same vulnerability</font>

546
00:22:35,669 --> 00:22:40,320
all over and over again<font color="#CCCCCC"> of course</font><font color="#E5E5E5"> it's</font>

547
00:22:38,309 --> 00:22:42,178
good to<font color="#E5E5E5"> also symbolize the call stacks</font>

548
00:22:40,320 --> 00:22:45,000
<font color="#CCCCCC">to have pretty</font><font color="#E5E5E5"> reports that we can</font>

549
00:22:42,179 --> 00:22:47,130
analyze<font color="#E5E5E5"> and finally we want to break</font>

550
00:22:45,000 --> 00:22:49,169
<font color="#E5E5E5">into kernel debugger attached to the</font>

551
00:22:47,130 --> 00:22:52,049
guests<font color="#E5E5E5"> when an error actually happens so</font>

552
00:22:49,169 --> 00:22:55,380
<font color="#CCCCCC">that we can interactively</font><font color="#E5E5E5"> try to see</font>

553
00:22:52,049 --> 00:22:57,240
what's going<font color="#E5E5E5"> on in the system</font><font color="#CCCCCC"> here you</font>

554
00:22:55,380 --> 00:22:59,250
can see a representation of the shadow

555
00:22:57,240 --> 00:23:01,320
memory so we have the guest<font color="#E5E5E5"> the</font><font color="#CCCCCC"> West</font>

556
00:22:59,250 --> 00:23:05,429
memory divided into user a lot and

557
00:23:01,320 --> 00:23:10,439
kernel<font color="#CCCCCC"> and for every kernel and byte or</font>

558
00:23:05,429 --> 00:23:11,789
rather we<font color="#E5E5E5"> have a mapping of the a full</font>

559
00:23:10,440 --> 00:23:13,440
mapping of the shadow memory

560
00:23:11,789 --> 00:23:15,658
corresponding to the kernel<font color="#CCCCCC"> land</font><font color="#E5E5E5"> and</font>

561
00:23:13,440 --> 00:23:18,269
then every<font color="#E5E5E5"> memory unit is described by a</font>

562
00:23:15,659 --> 00:23:21,620
few variables<font color="#E5E5E5"> of course we have detained</font>

563
00:23:18,269 --> 00:23:23,970
bit but also we have information<font color="#CCCCCC"> about</font>

564
00:23:21,620 --> 00:23:27,449
what is the base address<font color="#E5E5E5"> of the</font>

565
00:23:23,970 --> 00:23:29,789
allocation<font color="#E5E5E5"> that despite belongs to we</font>

566
00:23:27,450 --> 00:23:32,639
have the information<font color="#E5E5E5"> about where despite</font>

567
00:23:29,789 --> 00:23:36,570
was allocated<font color="#E5E5E5"> in</font><font color="#CCCCCC"> the kernel</font><font color="#E5E5E5"> and stuff</font>

568
00:23:32,639 --> 00:23:39,299
like<font color="#E5E5E5"> that so this this shadow memory</font>

569
00:23:36,570 --> 00:23:41,059
size is linear in relation<font color="#CCCCCC"> to the</font><font color="#E5E5E5"> size</font>

570
00:23:39,299 --> 00:23:44,158
of<font color="#E5E5E5"> the guest kernel address space</font>

571
00:23:41,059 --> 00:23:47,250
<font color="#E5E5E5">currently</font><font color="#CCCCCC"> we only support</font><font color="#E5E5E5"> 32-bit guests</font>

572
00:23:44,159 --> 00:23:49,649
<font color="#E5E5E5">but that shouldn't be really too hard to</font>

573
00:23:47,250 --> 00:23:51,630
to modify and some of the<font color="#CCCCCC"> information is</font>

574
00:23:49,649 --> 00:23:55,110
stored at<font color="#E5E5E5"> one by</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> on orality and some</font>

575
00:23:51,630 --> 00:23:56,970
at<font color="#CCCCCC"> eight byte granularity so right now</font>

576
00:23:55,110 --> 00:23:59,039
with my implementation<font color="#E5E5E5"> the size of the</font>

577
00:23:56,970 --> 00:24:01,139
<font color="#E5E5E5">shadow memory is three times the size of</font>

578
00:23:59,039 --> 00:24:03,750
the kernel address space<font color="#CCCCCC"> so we have six</font>

579
00:24:01,139 --> 00:24:05,850
gigabytes of memory<font color="#CCCCCC"> for</font><font color="#E5E5E5"> for a windows</font>

580
00:24:03,750 --> 00:24:09,330
guest and three gigabytes<font color="#CCCCCC"> of memory for</font>

581
00:24:05,850 --> 00:24:11,519
<font color="#CCCCCC">linux guest</font><font color="#E5E5E5"> so it can easily run on any</font>

582
00:24:09,330 --> 00:24:15,090
any host machine that has a reasonable

583
00:24:11,519 --> 00:24:17,429
<font color="#E5E5E5">amount of RAM</font><font color="#CCCCCC"> memory</font><font color="#E5E5E5"> and apart</font><font color="#CCCCCC"> from just</font>

584
00:24:15,090 --> 00:24:19,168
painting<font color="#E5E5E5"> the memory that we that is</font>

585
00:24:17,429 --> 00:24:22,620
being allocated in our shadow memory

586
00:24:19,169 --> 00:24:25,590
what I wanted to do is<font color="#CCCCCC"> also part the</font>

587
00:24:22,620 --> 00:24:28,080
guest memory with some special<font color="#E5E5E5"> marker</font>

588
00:24:25,590 --> 00:24:30,330
bytes<font color="#E5E5E5"> so we have a</font>

589
00:24:28,080 --> 00:24:34,110
with the a a bite for hip allocations

590
00:24:30,330 --> 00:24:36,449
and<font color="#CCCCCC"> BB</font><font color="#E5E5E5"> bite for</font><font color="#CCCCCC"> stack areas this is used</font>

591
00:24:34,110 --> 00:24:38,280
mostly first of all in<font color="#CCCCCC"> order to</font>

592
00:24:36,450 --> 00:24:40,680
<font color="#CCCCCC">eliminate all false positives because</font>

593
00:24:38,280 --> 00:24:42,540
<font color="#E5E5E5">now we have the guarantee</font><font color="#CCCCCC"> that if shadow</font>

594
00:24:40,680 --> 00:24:44,880
memory<font color="#E5E5E5"> indicates that there is</font><font color="#CCCCCC"> a bug we</font>

595
00:24:42,540 --> 00:24:47,220
can also refer to<font color="#E5E5E5"> the</font><font color="#CCCCCC"> actual</font><font color="#E5E5E5"> guest</font>

596
00:24:44,880 --> 00:24:49,560
memory and see if<font color="#E5E5E5"> these original marker</font>

597
00:24:47,220 --> 00:24:55,200
<font color="#E5E5E5">bites are still these values of a a or</font>

598
00:24:49,560 --> 00:24:57,659
<font color="#CCCCCC">BB and it can also trigger some use of</font>

599
00:24:55,200 --> 00:25:02,390
<font color="#CCCCCC">an energized memory bugs that are not</font>

600
00:24:57,660 --> 00:25:05,400
just info leaks but also other bugs so

601
00:25:02,390 --> 00:25:07,710
about setting paint on stack this<font color="#E5E5E5"> is</font>

602
00:25:05,400 --> 00:25:10,500
this is<font color="#CCCCCC"> actually very</font><font color="#E5E5E5"> easy because all</font>

603
00:25:07,710 --> 00:25:12,180
allocations performed on stack are

604
00:25:10,500 --> 00:25:14,870
performed<font color="#CCCCCC"> using the</font><font color="#E5E5E5"> same assembly</font>

605
00:25:12,180 --> 00:25:17,610
pattern so it's<font color="#E5E5E5"> close cross-platform</font>

606
00:25:14,870 --> 00:25:19,229
<font color="#E5E5E5">what I do in my instrumentation is I</font>

607
00:25:17,610 --> 00:25:21,840
<font color="#E5E5E5">just detect these three instruction of</font>

608
00:25:19,230 --> 00:25:24,450
adding subtracting and ending against

609
00:25:21,840 --> 00:25:26,879
the ESP register and then after the

610
00:25:24,450 --> 00:25:29,160
execution of this instruction if ESP

611
00:25:26,880 --> 00:25:30,840
<font color="#CCCCCC">decrease that</font><font color="#E5E5E5"> I just</font><font color="#CCCCCC"> sent the taint</font><font color="#E5E5E5"> on</font>

612
00:25:29,160 --> 00:25:33,240
the whole new memory region that also

613
00:25:30,840 --> 00:25:35,429
<font color="#E5E5E5">allocated this way of course you can</font>

614
00:25:33,240 --> 00:25:38,060
imagine<font color="#E5E5E5"> cases</font><font color="#CCCCCC"> where this would crash the</font>

615
00:25:35,430 --> 00:25:41,250
operating system if it didn't perform

616
00:25:38,060 --> 00:25:42,929
properly<font color="#E5E5E5"> but unfortunately both</font><font color="#CCCCCC"> windows</font>

617
00:25:41,250 --> 00:25:46,710
and<font color="#CCCCCC"> linux</font><font color="#E5E5E5"> do so this behavior</font><font color="#CCCCCC"> doesn't</font>

618
00:25:42,930 --> 00:25:48,660
crash<font color="#E5E5E5"> anything and it all works out</font><font color="#CCCCCC"> on</font>

619
00:25:46,710 --> 00:25:51,030
the other hand setting taint<font color="#E5E5E5"> on heap and</font>

620
00:25:48,660 --> 00:25:53,370
<font color="#E5E5E5">full allocations</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> completely different</font>

621
00:25:51,030 --> 00:25:55,620
<font color="#CCCCCC">we cannot do it universally in</font><font color="#E5E5E5"> any way</font>

622
00:25:53,370 --> 00:25:57,750
we<font color="#CCCCCC"> actually have to know how</font><font color="#E5E5E5"> the system</font>

623
00:25:55,620 --> 00:26:00,330
<font color="#E5E5E5">allocates memory where the allocators</font>

624
00:25:57,750 --> 00:26:04,020
are located in the kernel address space

625
00:26:00,330 --> 00:26:06,510
and how<font color="#CCCCCC"> do how they work</font><font color="#E5E5E5"> so right now we</font>

626
00:26:04,020 --> 00:26:08,700
can<font color="#CCCCCC"> just say</font><font color="#E5E5E5"> that after we detect an</font>

627
00:26:06,510 --> 00:26:09,960
allocation and<font color="#E5E5E5"> we know the address and</font>

628
00:26:08,700 --> 00:26:12,360
the size<font color="#E5E5E5"> of the allocation</font><font color="#CCCCCC"> we've just</font>

629
00:26:09,960 --> 00:26:14,280
tainted and<font color="#CCCCCC"> I will talk about</font><font color="#E5E5E5"> how we do</font>

630
00:26:12,360 --> 00:26:16,770
it specifically<font color="#E5E5E5"> in later in the</font>

631
00:26:14,280 --> 00:26:19,379
<font color="#E5E5E5">presentation</font><font color="#CCCCCC"> then we want to</font><font color="#E5E5E5"> remove</font>

632
00:26:16,770 --> 00:26:22,379
<font color="#E5E5E5">taint on</font><font color="#CCCCCC"> hip free which is</font><font color="#E5E5E5"> also very</font>

633
00:26:19,380 --> 00:26:24,660
<font color="#E5E5E5">reliant on how the heap implementation</font>

634
00:26:22,380 --> 00:26:26,460
works on the specific system<font color="#E5E5E5"> but</font>

635
00:26:24,660 --> 00:26:27,990
<font color="#E5E5E5">basically when we break on a free</font>

636
00:26:26,460 --> 00:26:30,560
function Prolog we look<font color="#CCCCCC"> up the</font>

637
00:26:27,990 --> 00:26:33,120
<font color="#E5E5E5">allocation size of</font><font color="#CCCCCC"> the memory</font><font color="#E5E5E5"> that</font>

638
00:26:30,560 --> 00:26:35,460
corresponds<font color="#E5E5E5"> to the address and we just</font>

639
00:26:33,120 --> 00:26:37,139
clear all of<font color="#E5E5E5"> the taint and metadata</font><font color="#CCCCCC"> that</font>

640
00:26:35,460 --> 00:26:39,690
corresponds to the whole<font color="#E5E5E5"> memory region</font>

641
00:26:37,140 --> 00:26:41,940
another<font color="#E5E5E5"> idea would be to escape this</font>

642
00:26:39,690 --> 00:26:45,029
this clearing of the taint<font color="#E5E5E5"> and is</font>

643
00:26:41,940 --> 00:26:46,950
that retains this this memory<font color="#E5E5E5"> in order</font>

644
00:26:45,029 --> 00:26:49,399
to detect use after free and leaks of

645
00:26:46,950 --> 00:26:52,950
freed memory but that's an implement

646
00:26:49,399 --> 00:26:55,110
implementational detail<font color="#E5E5E5"> and the hardest</font>

647
00:26:52,950 --> 00:26:57,809
<font color="#E5E5E5">part of all</font><font color="#CCCCCC"> of this is the taint</font>

648
00:26:55,110 --> 00:27:01,199
propagation because<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> easily detect</font>

649
00:26:57,809 --> 00:27:02,490
allocations but detecting data transfers

650
00:27:01,200 --> 00:27:05,370
and handling them correctly is

651
00:27:02,490 --> 00:27:08,909
definitely the hardest<font color="#E5E5E5"> part so in case</font>

652
00:27:05,370 --> 00:27:11,100
<font color="#CCCCCC">of my project I</font><font color="#E5E5E5"> only propagate time for</font>

653
00:27:08,909 --> 00:27:13,139
the<font color="#CCCCCC"> red</font><font color="#E5E5E5"> mob</font><font color="#CCCCCC"> as Dee and</font><font color="#E5E5E5"> her red mob as be</font>

654
00:27:11,100 --> 00:27:17,428
instructions which correspond to<font color="#CCCCCC"> the</font><font color="#E5E5E5"> mem</font>

655
00:27:13,139 --> 00:27:20,519
copy<font color="#E5E5E5"> kind of construct it's used both in</font>

656
00:27:17,429 --> 00:27:23,190
<font color="#E5E5E5">the mem copy implementation of various</font><font color="#CCCCCC"> C</font>

657
00:27:20,519 --> 00:27:25,440
clients and it's also used as an inline

658
00:27:23,190 --> 00:27:28,740
version of the mem copy function<font color="#CCCCCC"> and the</font>

659
00:27:25,440 --> 00:27:30,779
good thing about handling this specific

660
00:27:28,740 --> 00:27:33,450
instruction is that<font color="#CCCCCC"> we know the source</font>

661
00:27:30,779 --> 00:27:35,399
<font color="#CCCCCC">and destination addresses</font><font color="#E5E5E5"> at the same</font>

662
00:27:33,450 --> 00:27:38,519
time so we know how many<font color="#E5E5E5"> bytes are</font>

663
00:27:35,399 --> 00:27:41,158
copied<font color="#CCCCCC"> from</font><font color="#E5E5E5"> which address location to to</font>

664
00:27:38,519 --> 00:27:43,860
which one so we can analyze<font color="#CCCCCC"> this very</font>

665
00:27:41,159 --> 00:27:46,679
easily<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> know of</font><font color="#E5E5E5"> course this is</font>

666
00:27:43,860 --> 00:27:48,928
only a<font color="#E5E5E5"> best-effort approach it's not</font>

667
00:27:46,679 --> 00:27:53,580
perfect we don't<font color="#E5E5E5"> handle all of the data</font>

668
00:27:48,929 --> 00:27:57,179
transfers but you know it still<font color="#CCCCCC"> gives</font><font color="#E5E5E5"> us</font>

669
00:27:53,580 --> 00:27:59,730
<font color="#CCCCCC">a lot of information and we</font><font color="#E5E5E5"> still mostly</font>

670
00:27:57,179 --> 00:28:03,149
care about copying large memory blobs

671
00:27:59,730 --> 00:28:05,879
<font color="#E5E5E5">and not single variables so this this</font>

672
00:28:03,149 --> 00:28:09,168
lets us to spend as little time<font color="#CCCCCC"> on this</font>

673
00:28:05,879 --> 00:28:14,299
with as much benefit<font color="#E5E5E5"> as we can get and</font>

674
00:28:09,169 --> 00:28:18,029
it also has a quite a small CPU overhead

675
00:28:14,299 --> 00:28:19,799
so if a memory access<font color="#CCCCCC"> is not a result</font><font color="#E5E5E5"> of</font>

676
00:28:18,029 --> 00:28:21,779
this instruction<font color="#E5E5E5"> that we specifically</font>

677
00:28:19,799 --> 00:28:24,299
<font color="#CCCCCC">analyzed then we perform the</font><font color="#E5E5E5"> following</font>

678
00:28:21,779 --> 00:28:25,889
<font color="#CCCCCC">steps</font><font color="#E5E5E5"> if this instruction that we</font>

679
00:28:24,299 --> 00:28:27,389
encounter is writing<font color="#CCCCCC"> to some memory</font>

680
00:28:25,889 --> 00:28:29,459
<font color="#CCCCCC">we'll just clear the taint on that</font>

681
00:28:27,389 --> 00:28:31,529
memory area and if the instruction is

682
00:28:29,460 --> 00:28:35,220
reading from<font color="#E5E5E5"> the from the memory we</font>

683
00:28:31,529 --> 00:28:36,840
check the taint information<font color="#CCCCCC"> and if the</font>

684
00:28:35,220 --> 00:28:39,269
shadow memory indicates that<font color="#E5E5E5"> this is</font>

685
00:28:36,840 --> 00:28:41,399
actually an<font color="#CCCCCC"> annualized read we verify</font>

686
00:28:39,269 --> 00:28:43,590
whether this is the<font color="#E5E5E5"> case or not with the</font>

687
00:28:41,399 --> 00:28:45,449
marker bytes that<font color="#CCCCCC"> I mentioned before in</font>

688
00:28:43,590 --> 00:28:47,299
case there<font color="#CCCCCC"> is a mismatch for</font><font color="#E5E5E5"> whatever</font>

689
00:28:45,450 --> 00:28:50,759
reason we just<font color="#CCCCCC"> cleared the</font><font color="#E5E5E5"> taint again</font>

690
00:28:47,299 --> 00:28:55,399
<font color="#CCCCCC">but if the marker bytes are still there</font>

691
00:28:50,759 --> 00:28:55,399
<font color="#CCCCCC">in the</font><font color="#E5E5E5"> guest memory we we report the bug</font>

692
00:28:55,500 --> 00:29:02,779
and<font color="#CCCCCC"> also the real detection of the user</font>

693
00:28:59,850 --> 00:29:04,949
mode<font color="#E5E5E5"> or kernel mode information leak</font>

694
00:29:02,779 --> 00:29:07,740
<font color="#CCCCCC">triggers on</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> read mode as be</font>

695
00:29:04,950 --> 00:29:10,769
instruction where the ESI is in kernel

696
00:29:07,740 --> 00:29:13,379
<font color="#E5E5E5">mode and idea is in user mode</font><font color="#CCCCCC"> which</font>

697
00:29:10,769 --> 00:29:15,240
which<font color="#CCCCCC"> is a very clear indicator that</font>

698
00:29:13,379 --> 00:29:18,389
initialized<font color="#E5E5E5"> memory is actually copied</font>

699
00:29:15,240 --> 00:29:22,019
from kernel to user mode<font color="#E5E5E5"> so once we have</font>

700
00:29:18,389 --> 00:29:23,850
all<font color="#CCCCCC"> of this</font><font color="#E5E5E5"> information and this picture</font>

701
00:29:22,019 --> 00:29:25,940
of how this product<font color="#E5E5E5"> should look</font><font color="#CCCCCC"> like we</font>

702
00:29:23,850 --> 00:29:30,178
can try<font color="#E5E5E5"> to run it on some real systems</font>

703
00:29:25,940 --> 00:29:32,759
starting with<font color="#E5E5E5"> Windows</font><font color="#CCCCCC"> what we have to do</font>

704
00:29:30,179 --> 00:29:36,450
first is we have<font color="#E5E5E5"> to implement the</font>

705
00:29:32,759 --> 00:29:38,549
painting of pool allocations<font color="#CCCCCC"> in Windows</font>

706
00:29:36,450 --> 00:29:41,009
we have a lot<font color="#CCCCCC"> of functions which</font>

707
00:29:38,549 --> 00:29:43,350
allocate memory from<font color="#E5E5E5"> the pool all of</font>

708
00:29:41,009 --> 00:29:45,480
<font color="#CCCCCC">them start with X allocate pool but</font>

709
00:29:43,350 --> 00:29:47,039
there are different variants but

710
00:29:45,480 --> 00:29:48,960
<font color="#E5E5E5">fortunately</font><font color="#CCCCCC"> for us all</font><font color="#E5E5E5"> of these</font>

711
00:29:47,039 --> 00:29:49,408
<font color="#E5E5E5">functions</font><font color="#CCCCCC"> eventually call into one</font>

712
00:29:48,960 --> 00:29:52,980
called

713
00:29:49,409 --> 00:29:55,379
X<font color="#E5E5E5"> allocate pool with tag and it's very</font>

714
00:29:52,980 --> 00:29:57,210
convenient because<font color="#CCCCCC"> it uses the STD</font><font color="#E5E5E5"> call</font>

715
00:29:55,379 --> 00:29:59,158
calling<font color="#E5E5E5"> convention which means that we</font>

716
00:29:57,210 --> 00:30:02,789
<font color="#CCCCCC">have the</font><font color="#E5E5E5"> arguments on the stack and the</font>

717
00:29:59,159 --> 00:30:05,820
return value in EAX<font color="#CCCCCC"> and this</font><font color="#E5E5E5"> means</font><font color="#CCCCCC"> that</font>

718
00:30:02,789 --> 00:30:07,500
when the<font color="#E5E5E5"> read instruction is executed in</font>

719
00:30:05,820 --> 00:30:09,210
this function we<font color="#CCCCCC"> have all</font><font color="#E5E5E5"> of the</font>

720
00:30:07,500 --> 00:30:10,919
<font color="#E5E5E5">information about both the allocation</font>

721
00:30:09,210 --> 00:30:12,779
<font color="#E5E5E5">request and allocation result at the</font>

722
00:30:10,919 --> 00:30:15,419
<font color="#CCCCCC">same time so this</font><font color="#E5E5E5"> is this is very</font>

723
00:30:12,779 --> 00:30:18,330
<font color="#E5E5E5">convenient</font><font color="#CCCCCC"> for us this is how it looks</font>

724
00:30:15,419 --> 00:30:19,919
on<font color="#E5E5E5"> a graph so we have we have different</font>

725
00:30:18,330 --> 00:30:22,080
colors of<font color="#E5E5E5"> all of the allocation</font>

726
00:30:19,919 --> 00:30:24,059
functions<font color="#E5E5E5"> eventually they all call</font><font color="#CCCCCC"> into</font>

727
00:30:22,080 --> 00:30:26,039
X allocate<font color="#E5E5E5"> pool with tag and then we</font>

728
00:30:24,059 --> 00:30:27,960
break on<font color="#E5E5E5"> this single read instruction</font>

729
00:30:26,039 --> 00:30:28,769
and read all of the relevant<font color="#CCCCCC"> information</font>

730
00:30:27,960 --> 00:30:33,419
from<font color="#CCCCCC"> ax</font>

731
00:30:28,769 --> 00:30:36,029
and from memory under ESP so we read

732
00:30:33,419 --> 00:30:38,309
where the allocation is being made from

733
00:30:36,029 --> 00:30:40,259
from the return address and<font color="#CCCCCC"> the</font>

734
00:30:38,309 --> 00:30:43,559
requested size and the allocation tag

735
00:30:40,259 --> 00:30:46,620
for some<font color="#E5E5E5"> debugging information and then</font>

736
00:30:43,559 --> 00:30:48,720
we also break on the<font color="#E5E5E5"> X free pool with</font>

737
00:30:46,620 --> 00:30:51,508
<font color="#CCCCCC">tag function this time in the</font><font color="#E5E5E5"> prologue</font>

738
00:30:48,720 --> 00:30:53,700
of the function<font color="#E5E5E5"> and we just read the</font>

739
00:30:51,509 --> 00:30:56,779
address<font color="#CCCCCC"> of the regem that is being freed</font>

740
00:30:53,700 --> 00:30:58,559
in order to clear<font color="#CCCCCC"> the taint</font>

741
00:30:56,779 --> 00:31:00,720
<font color="#CCCCCC">unfortunately there</font><font color="#E5E5E5"> are some corner</font>

742
00:30:58,559 --> 00:31:03,299
cases<font color="#E5E5E5"> which we also have to take into</font>

743
00:31:00,720 --> 00:31:05,279
<font color="#CCCCCC">account in order to</font><font color="#E5E5E5"> find</font><font color="#CCCCCC"> all of the bugs</font>

744
00:31:03,299 --> 00:31:07,168
<font color="#E5E5E5">so for example in Windows we have some</font>

745
00:31:05,279 --> 00:31:08,970
optimized specialized<font color="#CCCCCC"> alligators such</font>

746
00:31:07,169 --> 00:31:11,610
<font color="#E5E5E5">though such as the one used by winter</font>

747
00:31:08,970 --> 00:31:13,950
<font color="#E5E5E5">okay</font><font color="#CCCCCC"> so there is this</font><font color="#E5E5E5"> alligator which</font>

748
00:31:11,610 --> 00:31:16,199
first of all tries to return a cached

749
00:31:13,950 --> 00:31:20,280
memory region that is<font color="#CCCCCC"> pre allocated and</font>

750
00:31:16,200 --> 00:31:20,820
after only it is busy<font color="#E5E5E5"> the actual</font><font color="#CCCCCC"> Windows</font>

751
00:31:20,280 --> 00:31:24,178
kernel

752
00:31:20,820 --> 00:31:26,428
<font color="#E5E5E5">a locator is used so and it's called</font>

753
00:31:24,179 --> 00:31:28,140
from from quite a few locations so<font color="#CCCCCC"> we</font>

754
00:31:26,429 --> 00:31:30,179
have to take<font color="#E5E5E5"> care</font><font color="#CCCCCC"> of that</font><font color="#E5E5E5"> but what we</font>

755
00:31:28,140 --> 00:31:32,039
can do is we can just<font color="#E5E5E5"> simply patch this</font>

756
00:31:30,179 --> 00:31:34,940
function to always use<font color="#CCCCCC"> the system</font><font color="#E5E5E5"> a</font>

757
00:31:32,039 --> 00:31:37,559
<font color="#E5E5E5">locator instead and we are good</font><font color="#CCCCCC"> to go</font>

758
00:31:34,940 --> 00:31:39,210
<font color="#CCCCCC">when it comes to propagating taint</font><font color="#E5E5E5"> and</font>

759
00:31:37,559 --> 00:31:42,450
detecting bugs in<font color="#E5E5E5"> Windows</font>

760
00:31:39,210 --> 00:31:44,070
we are quite<font color="#CCCCCC"> lucky because the the mem</font>

761
00:31:42,450 --> 00:31:46,890
copy function<font color="#CCCCCC"> that is used by</font><font color="#E5E5E5"> the</font>

762
00:31:44,070 --> 00:31:48,980
Windows kernel actually<font color="#E5E5E5"> uses the</font><font color="#CCCCCC"> red</font>

763
00:31:46,890 --> 00:31:53,870
<font color="#CCCCCC">morph as</font><font color="#E5E5E5"> B and</font><font color="#CCCCCC"> wrap morph as d function</font>

764
00:31:48,980 --> 00:31:55,710
<font color="#E5E5E5">instructions sometimes</font><font color="#CCCCCC"> they have some</font>

765
00:31:53,870 --> 00:31:58,199
optimizations that we have to care about

766
00:31:55,710 --> 00:32:01,350
<font color="#E5E5E5">so for example in Windows</font>

767
00:31:58,200 --> 00:32:04,320
if the copy size is less<font color="#CCCCCC"> than 32 bytes</font>

768
00:32:01,350 --> 00:32:06,959
<font color="#E5E5E5">then</font><font color="#CCCCCC"> morph instructions are used instead</font>

769
00:32:04,320 --> 00:32:10,428
<font color="#E5E5E5">of red morph as beep or</font><font color="#CCCCCC"> red Mofaz d but</font>

770
00:32:06,960 --> 00:32:14,130
<font color="#E5E5E5">we also can just modify that in assembly</font>

771
00:32:10,429 --> 00:32:16,799
<font color="#CCCCCC">so in</font><font color="#E5E5E5"> general as a result tracking most</font>

772
00:32:14,130 --> 00:32:19,230
transfers of data blobs in<font color="#CCCCCC"> Windows works</font>

773
00:32:16,799 --> 00:32:21,840
out of<font color="#CCCCCC"> the box with the approach that I</font>

774
00:32:19,230 --> 00:32:23,490
mentioned before I'm not<font color="#E5E5E5"> sure oh you can</font>

775
00:32:21,840 --> 00:32:26,309
<font color="#CCCCCC">actually see that quite well</font><font color="#E5E5E5"> so I</font>

776
00:32:23,490 --> 00:32:28,530
created a small visualization of the

777
00:32:26,309 --> 00:32:31,260
whole address<font color="#E5E5E5"> space in Windows 7 so here</font>

778
00:32:28,530 --> 00:32:36,000
<font color="#CCCCCC">you</font><font color="#E5E5E5"> can see the whole</font><font color="#CCCCCC"> 2 gigabyte kernel</font>

779
00:32:31,260 --> 00:32:40,650
address space<font color="#E5E5E5"> over time</font><font color="#CCCCCC"> this is an image</font>

780
00:32:36,000 --> 00:32:43,770
which is<font color="#E5E5E5"> of dimensions 1024 by 512</font><font color="#CCCCCC"> each</font>

781
00:32:40,650 --> 00:32:46,860
pixel is a single memory page and so

782
00:32:43,770 --> 00:32:49,679
these<font color="#CCCCCC"> pages that are that have some</font>

783
00:32:46,860 --> 00:32:53,070
stack memory<font color="#E5E5E5"> taint</font><font color="#CCCCCC"> are marked</font><font color="#E5E5E5"> in green</font>

784
00:32:49,679 --> 00:32:55,740
and the<font color="#E5E5E5"> pool ones are marked in red</font><font color="#CCCCCC"> so</font>

785
00:32:53,070 --> 00:32:57,960
now we can see that what the<font color="#E5E5E5"> patterns</font>

786
00:32:55,740 --> 00:33:00,240
are in Windows<font color="#E5E5E5"> when it boots up and when</font>

787
00:32:57,960 --> 00:33:02,070
you start some<font color="#CCCCCC"> of the some of the</font>

788
00:33:00,240 --> 00:33:05,190
applications in Windows so that's 40

789
00:33:02,070 --> 00:33:08,610
minutes<font color="#CCCCCC"> of runtime a new</font><font color="#E5E5E5"> snapshot was</font>

790
00:33:05,190 --> 00:33:10,049
being taken every 20 seconds<font color="#E5E5E5"> here so I I</font>

791
00:33:08,610 --> 00:33:13,740
found<font color="#CCCCCC"> I find that</font><font color="#E5E5E5"> quite interesting</font>

792
00:33:10,049 --> 00:33:18,510
<font color="#E5E5E5">myself and here you can see the similar</font>

793
00:33:13,740 --> 00:33:20,850
image on Windows 10<font color="#CCCCCC"> over</font><font color="#E5E5E5"> 120 minutes</font>

794
00:33:18,510 --> 00:33:21,870
with a snapshot taking every 60 seconds

795
00:33:20,850 --> 00:33:24,360
because

796
00:33:21,870 --> 00:33:26,699
the boots<font color="#E5E5E5"> time was much longer on the</font>

797
00:33:24,360 --> 00:33:28,949
<font color="#E5E5E5">box emulator so you can see that much</font>

798
00:33:26,700 --> 00:33:31,230
<font color="#E5E5E5">more memories consumed by the operating</font>

799
00:33:28,950 --> 00:33:32,880
<font color="#CCCCCC">system and the patterns in which memory</font>

800
00:33:31,230 --> 00:33:35,429
is allocated also<font color="#CCCCCC"> is</font><font color="#E5E5E5"> also quite</font>

801
00:33:32,880 --> 00:33:37,350
<font color="#CCCCCC">different</font><font color="#E5E5E5"> when it comes</font><font color="#CCCCCC"> to other</font>

802
00:33:35,429 --> 00:33:40,049
technical details such as<font color="#E5E5E5"> keeping track</font>

803
00:33:37,350 --> 00:33:41,908
of processes and<font color="#E5E5E5"> threads it's very</font>

804
00:33:40,049 --> 00:33:45,090
simple it's the<font color="#E5E5E5"> same as in the</font><font color="#CCCCCC"> original</font>

805
00:33:41,909 --> 00:33:48,539
box born from<font color="#E5E5E5"> four years ago</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> just</font>

806
00:33:45,090 --> 00:33:51,899
about traversing a simple traversing<font color="#E5E5E5"> a</font>

807
00:33:48,539 --> 00:33:54,149
single<font color="#CCCCCC"> a linked list</font><font color="#E5E5E5"> of of</font><font color="#CCCCCC"> modules in</font>

808
00:33:51,900 --> 00:33:56,520
the kernel address space and the same

809
00:33:54,149 --> 00:33:58,678
goes for keeping track of keeping track

810
00:33:56,520 --> 00:34:01,799
<font color="#CCCCCC">of</font><font color="#E5E5E5"> loaded kernel modules you</font><font color="#CCCCCC"> also</font><font color="#E5E5E5"> just</font>

811
00:33:58,679 --> 00:34:05,460
have to go<font color="#E5E5E5"> through a list</font><font color="#CCCCCC"> of descriptors</font>

812
00:34:01,799 --> 00:34:07,980
<font color="#E5E5E5">and note the values there so here we</font>

813
00:34:05,460 --> 00:34:10,530
have an example of<font color="#CCCCCC"> Bach's bone</font><font color="#E5E5E5"> that that</font>

814
00:34:07,980 --> 00:34:11,909
was generated<font color="#E5E5E5"> in an actual</font><font color="#CCCCCC"> runtime so</font>

815
00:34:10,530 --> 00:34:13,919
you can see all of the information<font color="#CCCCCC"> that</font>

816
00:34:11,909 --> 00:34:16,260
we have about<font color="#E5E5E5"> the bag that happened we</font>

817
00:34:13,918 --> 00:34:19,589
have the address<font color="#CCCCCC"> of the memory that is</font>

818
00:34:16,260 --> 00:34:22,020
being<font color="#E5E5E5"> read</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> have information about</font><font color="#CCCCCC"> the</font>

819
00:34:19,589 --> 00:34:24,330
process in this case<font color="#E5E5E5"> it's</font><font color="#CCCCCC"> Explorer dot X</font>

820
00:34:22,020 --> 00:34:26,399
<font color="#E5E5E5">ax we have</font><font color="#CCCCCC"> the faulting instruction</font>

821
00:34:24,330 --> 00:34:29,879
which as I<font color="#CCCCCC"> mentioned before can only be</font>

822
00:34:26,399 --> 00:34:32,668
read<font color="#CCCCCC"> more</font><font color="#E5E5E5"> of SD in this case</font><font color="#CCCCCC"> and we</font><font color="#E5E5E5"> have</font>

823
00:34:29,879 --> 00:34:35,040
information<font color="#CCCCCC"> about where the memory</font>

824
00:34:32,668 --> 00:34:37,589
region was allocated<font color="#E5E5E5"> in this case it was</font>

825
00:34:35,040 --> 00:34:40,710
<font color="#CCCCCC">just a generic function inside of win32</font>

826
00:34:37,589 --> 00:34:44,699
<font color="#E5E5E5">K and the stack trace of where this</font>

827
00:34:40,710 --> 00:34:48,210
happened<font color="#E5E5E5"> so this is all very</font><font color="#CCCCCC"> good</font><font color="#E5E5E5"> and it</font>

828
00:34:44,699 --> 00:34:50,819
looks<font color="#CCCCCC"> very nice</font><font color="#E5E5E5"> but it was</font><font color="#CCCCCC"> a very</font><font color="#E5E5E5"> simple</font>

829
00:34:48,210 --> 00:34:54,000
example<font color="#CCCCCC"> and there are much more</font><font color="#E5E5E5"> complex</font>

830
00:34:50,820 --> 00:34:56,639
examples where we have<font color="#CCCCCC"> a bug</font><font color="#E5E5E5"> but it's</font>

831
00:34:54,000 --> 00:34:58,950
it's<font color="#E5E5E5"> not</font><font color="#CCCCCC"> just to stack frames it's</font>

832
00:34:56,639 --> 00:35:00,780
actually like 30 stack frames<font color="#E5E5E5"> because</font>

833
00:34:58,950 --> 00:35:03,029
the back happens inside of<font color="#E5E5E5"> a ioctl</font>

834
00:35:00,780 --> 00:35:06,300
<font color="#E5E5E5">handler someone very deep inside of the</font>

835
00:35:03,030 --> 00:35:08,040
kernel<font color="#E5E5E5"> so it's not very convenient in</font>

836
00:35:06,300 --> 00:35:09,869
that case to try to<font color="#E5E5E5"> analyze the bug</font>

837
00:35:08,040 --> 00:35:11,790
<font color="#E5E5E5">based just on the single box</font><font color="#CCCCCC"> spawn</font>

838
00:35:09,869 --> 00:35:13,530
report so as I mentioned<font color="#CCCCCC"> before</font><font color="#E5E5E5"> what I</font>

839
00:35:11,790 --> 00:35:16,560
wanted to do is to be able<font color="#CCCCCC"> to attach</font>

840
00:35:13,530 --> 00:35:19,560
windbg<font color="#CCCCCC"> or wind back to the</font><font color="#E5E5E5"> emulated</font>

841
00:35:16,560 --> 00:35:21,480
<font color="#CCCCCC">guest kernel and this is not a very big</font>

842
00:35:19,560 --> 00:35:23,520
problem<font color="#CCCCCC"> because box</font><font color="#E5E5E5"> actually supports</font>

843
00:35:21,480 --> 00:35:25,830
redirecting<font color="#CCCCCC"> comm ports to Windows pipes</font>

844
00:35:23,520 --> 00:35:28,560
so we can just enable kernel debugging

845
00:35:25,830 --> 00:35:31,170
in the guest system and then attach a

846
00:35:28,560 --> 00:35:33,930
wind wind back<font color="#E5E5E5"> to it from outside of</font>

847
00:35:31,170 --> 00:35:35,550
course<font color="#E5E5E5"> this is very very slow</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> you try</font>

848
00:35:33,930 --> 00:35:37,500
to attach wind back

849
00:35:35,550 --> 00:35:40,020
takes<font color="#E5E5E5"> maybe five minutes for it</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> fully</font>

850
00:35:37,500 --> 00:35:42,150
on<font color="#E5E5E5"> initially and provide with</font><font color="#CCCCCC"> the</font>

851
00:35:40,020 --> 00:35:45,870
<font color="#E5E5E5">interactive shell but it's still</font>

852
00:35:42,150 --> 00:35:47,970
workable<font color="#E5E5E5"> for our purposes</font><font color="#CCCCCC"> and of course</font>

853
00:35:45,870 --> 00:35:49,920
this is not sufficient<font color="#CCCCCC"> because even</font>

854
00:35:47,970 --> 00:35:53,339
though we have<font color="#CCCCCC"> this kernel debugger</font>

855
00:35:49,920 --> 00:35:55,440
attached<font color="#E5E5E5"> we don't know when when the</font>

856
00:35:53,340 --> 00:35:57,540
bugs are happening so what we also<font color="#CCCCCC"> want</font>

857
00:35:55,440 --> 00:36:00,180
to do is that we want<font color="#CCCCCC"> to break on the</font>

858
00:35:57,540 --> 00:36:04,259
specific moment<font color="#E5E5E5"> when a bug happens and</font>

859
00:36:00,180 --> 00:36:07,230
this is achieved<font color="#E5E5E5"> by injecting an entry</font>

860
00:36:04,260 --> 00:36:09,510
instruction<font color="#E5E5E5"> in the emulator exactly at</font>

861
00:36:07,230 --> 00:36:11,820
the moment<font color="#CCCCCC"> when the bug is detected</font><font color="#E5E5E5"> so</font>

862
00:36:09,510 --> 00:36:14,460
this this lets us break into the

863
00:36:11,820 --> 00:36:16,830
debugger<font color="#CCCCCC"> and see exactly what is going</font>

864
00:36:14,460 --> 00:36:20,340
<font color="#E5E5E5">on and what memory is being copied to</font>

865
00:36:16,830 --> 00:36:23,460
user mode and<font color="#E5E5E5"> why so for me at</font><font color="#CCCCCC"> least it</font>

866
00:36:20,340 --> 00:36:25,950
seems it feels<font color="#E5E5E5"> quite magical that it</font>

867
00:36:23,460 --> 00:36:28,350
<font color="#CCCCCC">will all works but it does</font><font color="#E5E5E5"> so here</font><font color="#CCCCCC"> I</font>

868
00:36:25,950 --> 00:36:33,419
<font color="#CCCCCC">have a screenshot of wind wind bag</font>

869
00:36:28,350 --> 00:36:35,069
attached to the<font color="#CCCCCC"> box guest here yeah when</font>

870
00:36:33,420 --> 00:36:37,020
it comes to the testing that<font color="#E5E5E5"> I performed</font>

871
00:36:35,070 --> 00:36:39,780
in order<font color="#E5E5E5"> to get some reasonable</font><font color="#CCCCCC"> cold</font>

872
00:36:37,020 --> 00:36:41,610
coverage<font color="#CCCCCC"> first of all I run the</font>

873
00:36:39,780 --> 00:36:44,880
instrumentation against<font color="#E5E5E5"> Windows 7 and</font>

874
00:36:41,610 --> 00:36:47,040
<font color="#E5E5E5">Windows 10 in order to get</font><font color="#CCCCCC"> above</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> old</font>

875
00:36:44,880 --> 00:36:48,930
<font color="#E5E5E5">code that could have been removed in</font>

876
00:36:47,040 --> 00:36:51,720
Windows<font color="#CCCCCC"> 10</font><font color="#E5E5E5"> and also the new code</font><font color="#CCCCCC"> that</font>

877
00:36:48,930 --> 00:36:53,669
<font color="#E5E5E5">was added in</font><font color="#CCCCCC"> that system and within that</font>

878
00:36:51,720 --> 00:36:55,560
guests<font color="#E5E5E5"> what I did is that I of course</font>

879
00:36:53,670 --> 00:36:57,540
booted up the system started<font color="#E5E5E5"> a few</font>

880
00:36:55,560 --> 00:36:59,310
default applications such<font color="#CCCCCC"> as Internet</font>

881
00:36:57,540 --> 00:37:01,529
Explorer WordPad stuff like that

882
00:36:59,310 --> 00:37:05,250
I generally did some network traffic<font color="#E5E5E5"> and</font>

883
00:37:01,530 --> 00:37:07,170
I also run<font color="#CCCCCC"> so-called</font><font color="#E5E5E5"> react OS unit tests</font>

884
00:37:05,250 --> 00:37:09,960
which is<font color="#CCCCCC"> a bunch of applications which</font>

885
00:37:07,170 --> 00:37:11,580
<font color="#E5E5E5">are used by react OS to test whether the</font>

886
00:37:09,960 --> 00:37:14,340
behavior<font color="#CCCCCC"> of the system</font><font color="#E5E5E5"> is the same as</font>

887
00:37:11,580 --> 00:37:17,700
<font color="#CCCCCC">Windows so it</font><font color="#E5E5E5"> actually helps us provide</font>

888
00:37:14,340 --> 00:37:19,530
<font color="#E5E5E5">or get a lot of code coverage in the</font>

889
00:37:17,700 --> 00:37:22,439
kernel<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> wouldn't be able</font><font color="#CCCCCC"> to do</font>

890
00:37:19,530 --> 00:37:24,750
otherwise<font color="#E5E5E5"> we already used this</font><font color="#CCCCCC"> these</font>

891
00:37:22,440 --> 00:37:27,540
<font color="#E5E5E5">tests</font><font color="#CCCCCC"> four years</font><font color="#E5E5E5"> ago but they</font><font color="#CCCCCC"> were</font>

892
00:37:24,750 --> 00:37:29,760
largely<font color="#E5E5E5"> improved since then so they were</font>

893
00:37:27,540 --> 00:37:31,980
very<font color="#CCCCCC"> helpful for</font><font color="#E5E5E5"> us but of course even</font>

894
00:37:29,760 --> 00:37:34,680
though we did all<font color="#CCCCCC"> of those</font><font color="#E5E5E5"> things it's</font>

895
00:37:31,980 --> 00:37:37,170
still not the<font color="#E5E5E5"> perfect amount of code</font>

896
00:37:34,680 --> 00:37:41,069
<font color="#E5E5E5">coverage that we can get so it's still a</font>

897
00:37:37,170 --> 00:37:42,780
major<font color="#E5E5E5"> roadblock in every effective usage</font>

898
00:37:41,070 --> 00:37:44,760
of full system instrumentation<font color="#CCCCCC"> because</font>

899
00:37:42,780 --> 00:37:47,550
we can find<font color="#E5E5E5"> only as many bugs are</font>

900
00:37:44,760 --> 00:37:50,690
actually<font color="#E5E5E5"> triggered on the system so</font>

901
00:37:47,550 --> 00:37:50,690
let's look into the<font color="#CCCCCC"> results</font>

902
00:37:51,010 --> 00:37:55,690
this is this is the results on a single

903
00:37:53,860 --> 00:37:58,000
<font color="#E5E5E5">slide so it's a it's a couple of</font>

904
00:37:55,690 --> 00:38:01,390
screenshots from Microsoft<font color="#CCCCCC"> Billiton from</font>

905
00:37:58,000 --> 00:38:05,050
the last four<font color="#CCCCCC"> months the summary</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> that</font>

906
00:38:01,390 --> 00:38:07,600
we found so<font color="#CCCCCC"> far 30 vulnerabilities 13</font><font color="#E5E5E5"> of</font>

907
00:38:05,050 --> 00:38:11,340
them were in from the pools and 17 from

908
00:38:07,600 --> 00:38:15,549
<font color="#E5E5E5">the stack so it's quite evenly divided</font>

909
00:38:11,340 --> 00:38:17,680
and we can see here the pool<font color="#E5E5E5"> ones were</font>

910
00:38:15,550 --> 00:38:20,470
triggered in a number of kernel drivers

911
00:38:17,680 --> 00:38:24,100
so we<font color="#E5E5E5"> have both the core NTS OS kernel</font>

912
00:38:20,470 --> 00:38:27,209
<font color="#E5E5E5">we have win32</font><font color="#CCCCCC"> k we have a bunch of you</font>

913
00:38:24,100 --> 00:38:30,089
know like partition manager drivers

914
00:38:27,210 --> 00:38:33,430
<font color="#E5E5E5">volume manager driver stuff like that</font>

915
00:38:30,090 --> 00:38:36,100
and root causes<font color="#E5E5E5"> of those bugs are also</font>

916
00:38:33,430 --> 00:38:38,350
very<font color="#CCCCCC"> diverse so we have bugs caused by</font>

917
00:38:36,100 --> 00:38:41,620
<font color="#E5E5E5">structure alignment</font><font color="#CCCCCC"> unicode string</font>

918
00:38:38,350 --> 00:38:43,390
alignment padding<font color="#E5E5E5"> halls and you</font><font color="#CCCCCC"> know a</font>

919
00:38:41,620 --> 00:38:46,299
lot of<font color="#E5E5E5"> different things and also the the</font>

920
00:38:43,390 --> 00:38:48,970
<font color="#CCCCCC">amount of bytes that were leaked</font><font color="#E5E5E5"> is also</font>

921
00:38:46,300 --> 00:38:51,790
quite diverse so it<font color="#E5E5E5"> ranges from</font><font color="#CCCCCC"> just a</font>

922
00:38:48,970 --> 00:38:54,730
single<font color="#E5E5E5"> byte to over</font><font color="#CCCCCC"> 6</font><font color="#E5E5E5"> kilobytes of</font>

923
00:38:51,790 --> 00:38:56,430
information at a single request<font color="#E5E5E5"> and then</font>

924
00:38:54,730 --> 00:38:59,320
we have the<font color="#CCCCCC"> stock disclosures as well</font>

925
00:38:56,430 --> 00:39:01,359
<font color="#CCCCCC">from a number of</font><font color="#E5E5E5"> functions they are also</font>

926
00:38:59,320 --> 00:39:03,490
diverse<font color="#CCCCCC"> for some of them I</font><font color="#E5E5E5"> wasn't really</font>

927
00:39:01,360 --> 00:39:06,490
<font color="#E5E5E5">able to figure out what the reason for</font>

928
00:39:03,490 --> 00:39:08,859
for the leak was but yeah it's still

929
00:39:06,490 --> 00:39:12,100
<font color="#E5E5E5">quite a lot</font><font color="#CCCCCC"> of them so it's it's an</font>

930
00:39:08,860 --> 00:39:13,810
important problem once<font color="#E5E5E5"> we detected these</font>

931
00:39:12,100 --> 00:39:15,790
<font color="#E5E5E5">bugs we want to reproduce them of course</font>

932
00:39:13,810 --> 00:39:19,240
<font color="#E5E5E5">and this is</font><font color="#CCCCCC"> another important problem</font>

933
00:39:15,790 --> 00:39:21,550
that<font color="#E5E5E5"> we have to look into so in order to</font>

934
00:39:19,240 --> 00:39:24,220
reproduce<font color="#E5E5E5"> the pool info leaks what I did</font>

935
00:39:21,550 --> 00:39:26,110
is<font color="#CCCCCC"> that I used regular vm in order to</font>

936
00:39:24,220 --> 00:39:28,830
make<font color="#CCCCCC"> sure that this</font><font color="#E5E5E5"> bug is not specific</font>

937
00:39:26,110 --> 00:39:31,210
to box but also<font color="#E5E5E5"> a normal</font><font color="#CCCCCC"> environment</font>

938
00:39:28,830 --> 00:39:33,610
<font color="#CCCCCC">what I did is that I just found out</font>

939
00:39:31,210 --> 00:39:35,980
which drivers making<font color="#E5E5E5"> the allocation that</font>

940
00:39:33,610 --> 00:39:38,380
<font color="#CCCCCC">is</font><font color="#E5E5E5"> being leaked to user mode and I</font>

941
00:39:35,980 --> 00:39:40,990
already<font color="#E5E5E5"> had this information from the</font>

942
00:39:38,380 --> 00:39:43,000
metadata<font color="#CCCCCC"> I enabled</font><font color="#E5E5E5"> special pools for</font>

943
00:39:40,990 --> 00:39:45,939
<font color="#E5E5E5">that model reboot the system and then</font>

944
00:39:43,000 --> 00:39:48,460
started the<font color="#E5E5E5"> POC twice</font><font color="#CCCCCC"> and then I could</font>

945
00:39:45,940 --> 00:39:50,500
<font color="#CCCCCC">observe a repeated marker bite at the</font>

946
00:39:48,460 --> 00:39:52,480
offsets where the data was leaked<font color="#E5E5E5"> so</font>

947
00:39:50,500 --> 00:39:55,780
this is how it looked like<font color="#E5E5E5"> for the</font>

948
00:39:52,480 --> 00:39:58,090
<font color="#E5E5E5">volume disks extents vulnerability when</font>

949
00:39:55,780 --> 00:40:00,520
I run it the first time<font color="#E5E5E5"> you can see 39</font>

950
00:39:58,090 --> 00:40:02,800
marker byte<font color="#CCCCCC"> but then when I run it again</font>

951
00:40:00,520 --> 00:40:04,330
it's<font color="#E5E5E5"> another byte so you can easily see</font>

952
00:40:02,800 --> 00:40:07,090
where the leak is actually taking<font color="#CCCCCC"> place</font>

953
00:40:04,330 --> 00:40:09,549
here<font color="#CCCCCC"> when it comes to stacking fully</font>

954
00:40:07,090 --> 00:40:12,010
reproduction<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is much more</font><font color="#CCCCCC"> difficult</font>

955
00:40:09,550 --> 00:40:13,300
<font color="#CCCCCC">because there is no</font><font color="#E5E5E5"> official or</font>

956
00:40:12,010 --> 00:40:15,880
documented way of padding stack

957
00:40:13,300 --> 00:40:17,890
allocations<font color="#CCCCCC"> with marker bytes but on the</font>

958
00:40:15,880 --> 00:40:19,780
other hand<font color="#CCCCCC"> we still want to reproduce</font>

959
00:40:17,890 --> 00:40:22,839
<font color="#CCCCCC">these packs reliably and be able to show</font>

960
00:40:19,780 --> 00:40:25,660
where the<font color="#E5E5E5"> bytes are being leaked</font><font color="#CCCCCC"> because</font>

961
00:40:22,840 --> 00:40:28,180
otherwise you know first of all<font color="#E5E5E5"> it's</font>

962
00:40:25,660 --> 00:40:30,730
easier for<font color="#E5E5E5"> Microsoft to find add</font><font color="#CCCCCC"> to to</font>

963
00:40:28,180 --> 00:40:32,319
to<font color="#E5E5E5"> fix those bugs and also it's easier</font>

964
00:40:30,730 --> 00:40:34,840
for<font color="#E5E5E5"> us</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> make</font><font color="#CCCCCC"> sure that the back is</font>

965
00:40:32,320 --> 00:40:37,420
<font color="#E5E5E5">real and also reproduce outside of the</font>

966
00:40:34,840 --> 00:40:39,630
test environment<font color="#CCCCCC"> what we can do in this</font>

967
00:40:37,420 --> 00:40:43,720
case<font color="#E5E5E5"> is</font><font color="#CCCCCC"> that we can</font><font color="#E5E5E5"> use stack spraying</font>

968
00:40:39,630 --> 00:40:46,450
this is a technique that<font color="#E5E5E5"> allows us to</font>

969
00:40:43,720 --> 00:40:49,600
spray the kernel stack with some

970
00:40:46,450 --> 00:40:51,669
controlled memory<font color="#E5E5E5"> and it works thanks</font><font color="#CCCCCC"> to</font>

971
00:40:49,600 --> 00:40:53,380
the fact that<font color="#E5E5E5"> Windows uses optimization</font>

972
00:40:51,670 --> 00:40:56,680
<font color="#E5E5E5">of using local buffers for small</font>

973
00:40:53,380 --> 00:40:59,230
requests and some of the system calls

974
00:40:56,680 --> 00:41:02,440
actually<font color="#CCCCCC"> have very large</font><font color="#E5E5E5"> buffers for</font>

975
00:40:59,230 --> 00:41:04,690
storing<font color="#E5E5E5"> optimized local data so we have</font>

976
00:41:02,440 --> 00:41:07,600
this system<font color="#E5E5E5"> call called anti map</font><font color="#CCCCCC"> user</font>

977
00:41:04,690 --> 00:41:09,910
<font color="#E5E5E5">physical pages which allows us to</font><font color="#CCCCCC"> put 4</font>

978
00:41:07,600 --> 00:41:13,270
<font color="#E5E5E5">or</font><font color="#CCCCCC"> 8 kilobytes of controlled data</font><font color="#E5E5E5"> on the</font>

979
00:41:09,910 --> 00:41:15,549
stack<font color="#CCCCCC"> so it's</font><font color="#E5E5E5"> very convenient so this is</font>

980
00:41:13,270 --> 00:41:17,230
illustrated<font color="#CCCCCC"> here first of</font><font color="#E5E5E5"> all what we do</font>

981
00:41:15,550 --> 00:41:19,120
is<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> just spray the</font><font color="#CCCCCC"> current start</font>

982
00:41:17,230 --> 00:41:21,160
with some easily recognizable patterns

983
00:41:19,120 --> 00:41:22,990
such<font color="#CCCCCC"> as the</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> byte and then we</font>

984
00:41:21,160 --> 00:41:26,710
trigger<font color="#CCCCCC"> the vulnerability and we see</font>

985
00:41:22,990 --> 00:41:29,620
where this marker byte happens<font color="#E5E5E5"> to to be</font>

986
00:41:26,710 --> 00:41:32,590
in our output buffer so this is another

987
00:41:29,620 --> 00:41:35,890
example of running<font color="#E5E5E5"> the anti GDI get</font>

988
00:41:32,590 --> 00:41:38,890
realization info<font color="#E5E5E5"> POC here which leaks</font><font color="#CCCCCC"> 8</font>

989
00:41:35,890 --> 00:41:40,690
bytes from the kernel stack<font color="#E5E5E5"> and a quick</font>

990
00:41:38,890 --> 00:41:42,220
digression is that if memory marking can

991
00:41:40,690 --> 00:41:44,500
be used for<font color="#CCCCCC"> bug demonstration it can</font>

992
00:41:42,220 --> 00:41:46,720
also be used for discovery<font color="#E5E5E5"> that's what I</font>

993
00:41:44,500 --> 00:41:48,910
at least thought<font color="#E5E5E5"> and the basic idea</font>

994
00:41:46,720 --> 00:41:51,669
would be<font color="#CCCCCC"> to first of all enable special</font>

995
00:41:48,910 --> 00:41:55,299
pools for all of the kernel modules and

996
00:41:51,670 --> 00:41:57,880
then invoke invite invoke<font color="#CCCCCC"> test</font><font color="#E5E5E5"> tested</font>

997
00:41:55,300 --> 00:41:59,620
system called twice<font color="#E5E5E5"> pre spraying the</font>

998
00:41:57,880 --> 00:42:01,600
kernel stack with a different bite each

999
00:41:59,620 --> 00:42:03,880
time and<font color="#E5E5E5"> then we can compare the</font><font color="#CCCCCC"> output</font>

1000
00:42:01,600 --> 00:42:05,860
<font color="#CCCCCC">of the system call and see if if it</font>

1001
00:42:03,880 --> 00:42:09,490
differs in a reliable<font color="#E5E5E5"> way</font>

1002
00:42:05,860 --> 00:42:12,400
and the perfect<font color="#CCCCCC"> candidate to</font><font color="#E5E5E5"> to test in</font>

1003
00:42:09,490 --> 00:42:14,919
<font color="#E5E5E5">this way is that function is the family</font>

1004
00:42:12,400 --> 00:42:17,470
of<font color="#E5E5E5"> anti query information system calls</font>

1005
00:42:14,920 --> 00:42:20,020
which have a very calm

1006
00:42:17,470 --> 00:42:21,910
structures so we<font color="#E5E5E5"> have a handle to the</font>

1007
00:42:20,020 --> 00:42:23,650
object<font color="#E5E5E5"> that we want</font><font color="#CCCCCC"> to query we have</font>

1008
00:42:21,910 --> 00:42:26,319
some information class which is just a

1009
00:42:23,650 --> 00:42:28,330
simple integer<font color="#E5E5E5"> and we have a pointer and</font>

1010
00:42:26,320 --> 00:42:31,780
size of the<font color="#CCCCCC"> output buffer so we can</font>

1011
00:42:28,330 --> 00:42:33,700
create the object that we<font color="#CCCCCC"> want to</font><font color="#E5E5E5"> query</font>

1012
00:42:31,780 --> 00:42:35,800
<font color="#E5E5E5">and then we can just brute force pretty</font>

1013
00:42:33,700 --> 00:42:39,399
much both the information<font color="#CCCCCC"> class and the</font>

1014
00:42:35,800 --> 00:42:41,260
expected buffer size<font color="#E5E5E5"> and</font><font color="#CCCCCC"> our about</font><font color="#E5E5E5"> ten</font>

1015
00:42:39,400 --> 00:42:44,950
such functions which we can test this

1016
00:42:41,260 --> 00:42:46,780
way<font color="#E5E5E5"> so this looked quite promising</font><font color="#CCCCCC"> and</font>

1017
00:42:44,950 --> 00:42:49,000
indeed it<font color="#CCCCCC"> turned out</font><font color="#E5E5E5"> that this was a</font>

1018
00:42:46,780 --> 00:42:51,640
fruitful idea and<font color="#E5E5E5"> I was</font><font color="#CCCCCC"> able to find</font>

1019
00:42:49,000 --> 00:42:55,420
<font color="#E5E5E5">about five bucks this way as well</font><font color="#CCCCCC"> so it</font>

1020
00:42:51,640 --> 00:42:57,190
was it was<font color="#CCCCCC"> quite easy</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> in summary</font><font color="#E5E5E5"> the</font>

1021
00:42:55,420 --> 00:43:00,370
problem seems<font color="#E5E5E5"> to have remained mostly</font>

1022
00:42:57,190 --> 00:43:02,020
unrecognized<font color="#E5E5E5"> until now</font><font color="#CCCCCC"> probably</font><font color="#E5E5E5"> because</font>

1023
00:43:00,370 --> 00:43:03,970
of<font color="#E5E5E5"> the factor that factors that I</font>

1024
00:43:02,020 --> 00:43:06,160
mentioned<font color="#CCCCCC"> before</font><font color="#E5E5E5"> that it's quite</font>

1025
00:43:03,970 --> 00:43:08,350
invisible<font color="#E5E5E5"> and not obvious</font><font color="#CCCCCC"> to find these</font>

1026
00:43:06,160 --> 00:43:10,060
bugs but on the<font color="#E5E5E5"> other</font><font color="#CCCCCC"> hand it's a</font>

1027
00:43:08,350 --> 00:43:13,210
fundamental issue which<font color="#E5E5E5"> is trivial</font><font color="#CCCCCC"> to</font>

1028
00:43:10,060 --> 00:43:17,890
overlook<font color="#E5E5E5"> but very</font><font color="#CCCCCC"> difficult</font><font color="#E5E5E5"> to get right</font>

1029
00:43:13,210 --> 00:43:19,540
in the code<font color="#E5E5E5"> so I think it's also a tip</font>

1030
00:43:17,890 --> 00:43:22,450
of the<font color="#CCCCCC"> iceberg so even though I found</font>

1031
00:43:19,540 --> 00:43:24,340
<font color="#CCCCCC">thirty bucks so far there are</font><font color="#E5E5E5"> hundreds</font>

1032
00:43:22,450 --> 00:43:26,230
of men<font color="#CCCCCC"> copy calls to</font><font color="#E5E5E5"> user remote in the</font>

1033
00:43:24,340 --> 00:43:29,380
<font color="#E5E5E5">Windows kernel and every one of them is</font>

1034
00:43:26,230 --> 00:43:31,180
a potential disclosure so so there are

1035
00:43:29,380 --> 00:43:33,190
still probably<font color="#E5E5E5"> a lot of such bugs</font>

1036
00:43:31,180 --> 00:43:35,259
lurking in the<font color="#CCCCCC"> codebase of Windows and</font>

1037
00:43:33,190 --> 00:43:36,970
this is<font color="#E5E5E5"> especially true</font><font color="#CCCCCC"> in the</font><font color="#E5E5E5"> cases</font>

1038
00:43:35,260 --> 00:43:39,520
where<font color="#CCCCCC"> the size is user controlled but</font>

1039
00:43:36,970 --> 00:43:42,910
the amount of lab relevant data is fixed

1040
00:43:39,520 --> 00:43:45,400
or otherwise limited there are<font color="#E5E5E5"> some</font>

1041
00:43:42,910 --> 00:43:47,589
mitigations ideas that Microsoft could

1042
00:43:45,400 --> 00:43:50,800
<font color="#CCCCCC">probably implement in some way in order</font>

1043
00:43:47,590 --> 00:43:53,170
<font color="#E5E5E5">to to try to mitigate those bugs</font><font color="#CCCCCC"> first</font>

1044
00:43:50,800 --> 00:43:54,910
of<font color="#E5E5E5"> all of</font><font color="#CCCCCC"> course they could just</font><font color="#E5E5E5"> memset</font>

1045
00:43:53,170 --> 00:43:57,400
<font color="#E5E5E5">all stack and</font><font color="#CCCCCC"> pool allocations we</font>

1046
00:43:54,910 --> 00:43:59,200
<font color="#E5E5E5">learned there made or requested</font><font color="#CCCCCC"> which</font>

1047
00:43:57,400 --> 00:44:01,660
would make the bug go away without<font color="#E5E5E5"> doing</font>

1048
00:43:59,200 --> 00:44:03,399
<font color="#E5E5E5">any bug fixing at all but of course that</font>

1049
00:44:01,660 --> 00:44:05,940
is probably incurring<font color="#E5E5E5"> too much of an</font>

1050
00:44:03,400 --> 00:44:07,930
overhead so it's<font color="#E5E5E5"> not realistic</font><font color="#CCCCCC"> and</font>

1051
00:44:05,940 --> 00:44:10,210
<font color="#CCCCCC">especially given the fact that most</font>

1052
00:44:07,930 --> 00:44:13,960
kernel<font color="#E5E5E5"> allocations probably don't at end</font>

1053
00:44:10,210 --> 00:44:16,090
up copied to user mode anyway<font color="#E5E5E5"> but it</font>

1054
00:44:13,960 --> 00:44:19,270
turns out<font color="#E5E5E5"> that Microsoft implemented a</font>

1055
00:44:16,090 --> 00:44:22,980
part of this idea<font color="#E5E5E5"> by mem setting the</font>

1056
00:44:19,270 --> 00:44:25,420
buffered i/o<font color="#E5E5E5"> output buffer in the ioctl</font>

1057
00:44:22,980 --> 00:44:27,790
implementation just just a<font color="#E5E5E5"> few weeks ago</font>

1058
00:44:25,420 --> 00:44:29,870
<font color="#E5E5E5">so they are definitely</font><font color="#CCCCCC"> looking into into</font>

1059
00:44:27,790 --> 00:44:31,490
this<font color="#E5E5E5"> there are some other</font>

1060
00:44:29,870 --> 00:44:34,100
creation ideas that are more<font color="#CCCCCC"> realistic</font>

1061
00:44:31,490 --> 00:44:37,490
such as for example<font color="#CCCCCC"> Creek</font><font color="#E5E5E5"> clearing the</font>

1062
00:44:34,100 --> 00:44:39,440
kernel stack<font color="#E5E5E5"> between system calls</font><font color="#CCCCCC"> they</font>

1063
00:44:37,490 --> 00:44:41,060
could also add a new<font color="#CCCCCC"> a locator function</font>

1064
00:44:39,440 --> 00:44:44,960
which<font color="#CCCCCC"> just clears the returned memory</font>

1065
00:44:41,060 --> 00:44:46,970
regions before<font color="#E5E5E5"> returning them and they</font>

1066
00:44:44,960 --> 00:44:48,800
could also just detect which allocations

1067
00:44:46,970 --> 00:44:51,410
end up being copied<font color="#E5E5E5"> to user</font><font color="#CCCCCC"> mode</font><font color="#E5E5E5"> and</font>

1068
00:44:48,800 --> 00:44:53,510
<font color="#CCCCCC">then</font><font color="#E5E5E5"> only clear those either</font>

1069
00:44:51,410 --> 00:44:57,379
automatically or just by adding<font color="#CCCCCC"> Maps</font><font color="#E5E5E5"> it</font>

1070
00:44:53,510 --> 00:44:59,000
calls manually<font color="#E5E5E5"> and in general since when</font>

1071
00:44:57,380 --> 00:45:02,270
<font color="#CCCCCC">the Microsoft has the wins of source</font>

1072
00:44:59,000 --> 00:45:05,030
code they could bring this idea<font color="#E5E5E5"> to a</font>

1073
00:45:02,270 --> 00:45:06,410
<font color="#CCCCCC">whole new level</font><font color="#E5E5E5"> by writing better</font>

1074
00:45:05,030 --> 00:45:08,420
instrumentation<font color="#E5E5E5"> which has more</font>

1075
00:45:06,410 --> 00:45:11,420
<font color="#CCCCCC">information about data transfers and</font>

1076
00:45:08,420 --> 00:45:12,950
stuff<font color="#E5E5E5"> like that</font><font color="#CCCCCC"> they also have probably</font>

1077
00:45:11,420 --> 00:45:15,500
mode code coverage that<font color="#E5E5E5"> I am able to</font>

1078
00:45:12,950 --> 00:45:17,270
<font color="#E5E5E5">achieve by just running</font><font color="#CCCCCC"> a few simple</font>

1079
00:45:15,500 --> 00:45:21,340
<font color="#E5E5E5">tests and starting a few</font><font color="#CCCCCC"> applications</font>

1080
00:45:17,270 --> 00:45:24,170
<font color="#E5E5E5">which also means more bugs found and</font>

1081
00:45:21,340 --> 00:45:27,710
static analysis is<font color="#E5E5E5"> also easier to use to</font>

1082
00:45:24,170 --> 00:45:30,470
guide this dynamic approaches so when it

1083
00:45:27,710 --> 00:45:32,270
comes to closing<font color="#E5E5E5"> remarks for Windows of</font>

1084
00:45:30,470 --> 00:45:34,220
course this box<font color="#CCCCCC"> phone approach could</font><font color="#E5E5E5"> be</font>

1085
00:45:32,270 --> 00:45:36,710
<font color="#E5E5E5">also used to detect regular use of</font><font color="#CCCCCC"> an</font>

1086
00:45:34,220 --> 00:45:38,660
<font color="#E5E5E5">initialized memory but the results in</font>

1087
00:45:36,710 --> 00:45:40,670
case of<font color="#CCCCCC"> Windows are much harder</font><font color="#E5E5E5"> to try</font>

1088
00:45:38,660 --> 00:45:42,770
<font color="#CCCCCC">out because</font><font color="#E5E5E5"> we don't</font><font color="#CCCCCC"> have access to the</font>

1089
00:45:40,670 --> 00:45:45,380
source<font color="#E5E5E5"> code so</font><font color="#CCCCCC"> we cannot easily</font><font color="#E5E5E5"> analyze</font>

1090
00:45:42,770 --> 00:45:49,280
if this use<font color="#CCCCCC"> of an</font><font color="#E5E5E5"> initialized memory is</font>

1091
00:45:45,380 --> 00:45:52,130
an actual<font color="#CCCCCC"> buck or not and another point</font>

1092
00:45:49,280 --> 00:45:53,930
<font color="#E5E5E5">that I wanted</font><font color="#CCCCCC"> to make is that the</font><font color="#E5E5E5"> the</font>

1093
00:45:52,130 --> 00:45:57,140
subject<font color="#CCCCCC"> of leaking specific sensitive</font>

1094
00:45:53,930 --> 00:45:58,609
data<font color="#E5E5E5"> from pool disclosures is still an</font>

1095
00:45:57,140 --> 00:46:01,759
interesting<font color="#E5E5E5"> subject that hasn't been</font>

1096
00:45:58,610 --> 00:46:03,650
<font color="#E5E5E5">explored</font><font color="#CCCCCC"> too much now I also wanted to</font>

1097
00:46:01,760 --> 00:46:05,900
talk<font color="#CCCCCC"> about running Bach's bone against</font>

1098
00:46:03,650 --> 00:46:06,740
<font color="#E5E5E5">Linux but I guess I don't</font><font color="#CCCCCC"> have too much</font>

1099
00:46:05,900 --> 00:46:10,760
<font color="#E5E5E5">time anymore</font>

1100
00:46:06,740 --> 00:46:12,709
so I will<font color="#E5E5E5"> just quickly say that the</font>

1101
00:46:10,760 --> 00:46:14,660
tainting of heap allocations is much

1102
00:46:12,710 --> 00:46:17,840
more difficult<font color="#E5E5E5"> on Linux</font><font color="#CCCCCC"> because the</font>

1103
00:46:14,660 --> 00:46:19,790
<font color="#CCCCCC">allocators</font><font color="#E5E5E5"> themselves are plenty it's</font>

1104
00:46:17,840 --> 00:46:22,040
not just a single<font color="#E5E5E5"> function but we have</font><font color="#CCCCCC"> a</font>

1105
00:46:19,790 --> 00:46:24,200
couple<font color="#CCCCCC"> of families that are schema log V</font>

1106
00:46:22,040 --> 00:46:26,380
<font color="#CCCCCC">ma log K</font><font color="#E5E5E5"> memcache a log and stuff like</font>

1107
00:46:24,200 --> 00:46:29,960
<font color="#E5E5E5">that all of them work in different ways</font>

1108
00:46:26,380 --> 00:46:31,910
<font color="#E5E5E5">so we have a lot of these functions for</font>

1109
00:46:29,960 --> 00:46:35,000
came along a lot<font color="#E5E5E5"> of these functions in</font>

1110
00:46:31,910 --> 00:46:36,740
vemma log we have to hook into most of

1111
00:46:35,000 --> 00:46:40,070
<font color="#E5E5E5">them in order to</font><font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to catch all of</font>

1112
00:46:36,740 --> 00:46:42,799
the allocations in my<font color="#E5E5E5"> case it was seven</font>

1113
00:46:40,070 --> 00:46:43,970
<font color="#E5E5E5">of them we also have problems</font><font color="#CCCCCC"> such as</font>

1114
00:46:42,800 --> 00:46:45,950
<font color="#E5E5E5">the fact</font>

1115
00:46:43,970 --> 00:46:48,379
we have a different calling conventions

1116
00:46:45,950 --> 00:46:51,980
<font color="#E5E5E5">with arguments passed through registers</font>

1117
00:46:48,380 --> 00:46:53,750
and not<font color="#E5E5E5"> the stack so instead of just</font>

1118
00:46:51,980 --> 00:46:56,240
hooking<font color="#E5E5E5"> into a single read instruction</font>

1119
00:46:53,750 --> 00:46:57,890
<font color="#E5E5E5">we actually have to hook into the both</font>

1120
00:46:56,240 --> 00:46:59,540
the prologue of<font color="#CCCCCC"> the app function in</font>

1121
00:46:57,890 --> 00:47:02,210
order<font color="#E5E5E5"> to save information</font><font color="#CCCCCC"> about the</font>

1122
00:46:59,540 --> 00:47:04,160
<font color="#E5E5E5">allocation request and then we have to</font>

1123
00:47:02,210 --> 00:47:06,200
hook into the return<font color="#CCCCCC"> instruction in</font>

1124
00:47:04,160 --> 00:47:08,270
order<font color="#CCCCCC"> to be able to read the</font><font color="#E5E5E5"> address</font>

1125
00:47:06,200 --> 00:47:11,000
<font color="#E5E5E5">that it was being allocated and then we</font>

1126
00:47:08,270 --> 00:47:13,690
can set the taint<font color="#E5E5E5"> then we have this</font>

1127
00:47:11,000 --> 00:47:16,460
troublesome<font color="#E5E5E5"> family of</font><font color="#CCCCCC"> K memcache</font>

1128
00:47:13,690 --> 00:47:19,670
<font color="#E5E5E5">functions which create a cache of</font>

1129
00:47:16,460 --> 00:47:22,640
allocations which are initialized and

1130
00:47:19,670 --> 00:47:24,710
<font color="#E5E5E5">tainted at the time where the object is</font>

1131
00:47:22,640 --> 00:47:26,960
initialized but not at the<font color="#E5E5E5"> time when it</font>

1132
00:47:24,710 --> 00:47:29,630
is requested<font color="#CCCCCC"> so we have to implement</font>

1133
00:47:26,960 --> 00:47:32,510
some additional logic to account for

1134
00:47:29,630 --> 00:47:34,250
<font color="#E5E5E5">that other than</font><font color="#CCCCCC"> that we have a few flags</font>

1135
00:47:32,510 --> 00:47:37,490
that we have to set in the config in

1136
00:47:34,250 --> 00:47:42,010
order to make the mem copy function<font color="#E5E5E5"> be</font>

1137
00:47:37,490 --> 00:47:47,000
compiled<font color="#E5E5E5"> into a set</font><font color="#CCCCCC"> of rep move</font><font color="#E5E5E5"> move SB</font>

1138
00:47:42,010 --> 00:47:49,280
instructions we have<font color="#E5E5E5"> this visualization</font>

1139
00:47:47,000 --> 00:47:51,829
of<font color="#CCCCCC"> Ubuntu memory</font><font color="#E5E5E5"> layout which I'm gonna</font>

1140
00:47:49,280 --> 00:47:53,810
skip right now we have a few<font color="#E5E5E5"> other</font>

1141
00:47:51,829 --> 00:47:56,359
config options that we also have<font color="#E5E5E5"> to set</font>

1142
00:47:53,810 --> 00:47:59,390
<font color="#E5E5E5">in order to enable debugging symbols use</font>

1143
00:47:56,359 --> 00:48:02,509
the right<font color="#E5E5E5"> kernel user address mode split</font>

1144
00:47:59,390 --> 00:48:06,040
<font color="#E5E5E5">and</font><font color="#CCCCCC"> disable some</font><font color="#E5E5E5"> of the</font><font color="#CCCCCC"> mechanisms that</font>

1145
00:48:02,510 --> 00:48:08,690
<font color="#E5E5E5">we don't want to use in the emulation</font>

1146
00:48:06,040 --> 00:48:10,849
<font color="#CCCCCC">then we also have to set another config</font>

1147
00:48:08,690 --> 00:48:13,460
option to make sure that copy<font color="#E5E5E5"> to user</font>

1148
00:48:10,849 --> 00:48:15,290
which<font color="#E5E5E5"> is used to copy memory back from</font>

1149
00:48:13,460 --> 00:48:17,960
kernel mode to user mode is<font color="#E5E5E5"> also</font>

1150
00:48:15,290 --> 00:48:21,770
compiled<font color="#E5E5E5"> into</font><font color="#CCCCCC"> read mob SP</font><font color="#E5E5E5"> and read more</font>

1151
00:48:17,960 --> 00:48:24,349
SD instructions unfortunately there is

1152
00:48:21,770 --> 00:48:26,569
one problematic function<font color="#E5E5E5"> that we have to</font>

1153
00:48:24,349 --> 00:48:30,290
<font color="#E5E5E5">also care</font><font color="#CCCCCC"> about which is put user which</font>

1154
00:48:26,569 --> 00:48:33,050
is<font color="#E5E5E5"> a macro used to copy simple types</font>

1155
00:48:30,290 --> 00:48:37,910
back to user mode but<font color="#E5E5E5"> we can take care</font>

1156
00:48:33,050 --> 00:48:41,000
<font color="#CCCCCC">of that by just</font><font color="#E5E5E5"> using a hack of using</font>

1157
00:48:37,910 --> 00:48:43,940
these prefetch instructions<font color="#E5E5E5"> in order to</font>

1158
00:48:41,000 --> 00:48:47,660
enable<font color="#E5E5E5"> and disable strict mode in box</font>

1159
00:48:43,940 --> 00:48:49,849
which means<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> just sanitize all of</font>

1160
00:48:47,660 --> 00:48:52,848
the reads from memory<font color="#E5E5E5"> that happened</font>

1161
00:48:49,849 --> 00:48:55,280
between those two<font color="#E5E5E5"> instructions you are</font>

1162
00:48:52,849 --> 00:48:56,390
<font color="#E5E5E5">welcome to ask</font><font color="#CCCCCC"> me about</font><font color="#E5E5E5"> the details of</font>

1163
00:48:55,280 --> 00:48:58,760
<font color="#E5E5E5">that after</font>

1164
00:48:56,390 --> 00:49:01,250
presentation but that's how it looks in

1165
00:48:58,760 --> 00:49:03,020
assembly<font color="#E5E5E5"> so we have the</font><font color="#CCCCCC"> preface</font><font color="#E5E5E5"> one and</font>

1166
00:49:01,250 --> 00:49:05,270
<font color="#CCCCCC">preffered two instructions and be in</font>

1167
00:49:03,020 --> 00:49:08,810
<font color="#E5E5E5">between these instructions we just</font>

1168
00:49:05,270 --> 00:49:11,450
<font color="#CCCCCC">sanitize all of the memory reads so yeah</font>

1169
00:49:08,810 --> 00:49:14,090
<font color="#E5E5E5">we have we have a very similar log from</font>

1170
00:49:11,450 --> 00:49:15,410
<font color="#E5E5E5">box pawn report right now so it's all</font>

1171
00:49:14,090 --> 00:49:17,300
the same<font color="#E5E5E5"> information</font><font color="#CCCCCC"> about the</font>

1172
00:49:15,410 --> 00:49:19,730
instruction the stack trace where<font color="#CCCCCC"> the</font>

1173
00:49:17,300 --> 00:49:21,860
back happened and stuff<font color="#E5E5E5"> like that</font><font color="#CCCCCC"> we</font>

1174
00:49:19,730 --> 00:49:24,800
also have a kernel<font color="#E5E5E5"> debugger attached as</font>

1175
00:49:21,860 --> 00:49:29,660
<font color="#CCCCCC">well so we can we can debug these bugs</font>

1176
00:49:24,800 --> 00:49:31,730
<font color="#E5E5E5">that happen at runtime we perform</font><font color="#CCCCCC"> some</font>

1177
00:49:29,660 --> 00:49:34,670
very<font color="#CCCCCC"> simple testing as well by running</font><font color="#E5E5E5"> a</font>

1178
00:49:31,730 --> 00:49:39,170
few system professors such as Trinity

1179
00:49:34,670 --> 00:49:41,600
<font color="#E5E5E5">pools</font><font color="#CCCCCC"> I know this also</font><font color="#E5E5E5"> a few unit tests</font>

1180
00:49:39,170 --> 00:49:44,000
such as<font color="#CCCCCC"> the Linux</font><font color="#E5E5E5"> test project and a</font>

1181
00:49:41,600 --> 00:49:45,860
<font color="#E5E5E5">couple of other things</font><font color="#CCCCCC"> unfortunately we</font>

1182
00:49:44,000 --> 00:49:47,330
are<font color="#E5E5E5"> but we</font><font color="#CCCCCC"> weren't able</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> use this</font>

1183
00:49:45,860 --> 00:49:51,290
<font color="#E5E5E5">color because it's currently only</font>

1184
00:49:47,330 --> 00:49:54,319
<font color="#E5E5E5">supporting 64-bit architectures and we</font>

1185
00:49:51,290 --> 00:49:56,810
were<font color="#E5E5E5"> working with 32-bit when it comes</font>

1186
00:49:54,320 --> 00:49:59,360
to the results<font color="#E5E5E5"> they</font><font color="#CCCCCC"> are much less</font>

1187
00:49:56,810 --> 00:50:01,670
<font color="#CCCCCC">impressive</font><font color="#E5E5E5"> than on Windows</font><font color="#CCCCCC"> so it was</font>

1188
00:49:59,360 --> 00:50:05,060
<font color="#E5E5E5">just a single bug which was very minor</font>

1189
00:50:01,670 --> 00:50:07,880
<font color="#E5E5E5">because it was in the ioctl of a device</font>

1190
00:50:05,060 --> 00:50:10,759
<font color="#E5E5E5">that was only accessible to</font><font color="#CCCCCC"> route I'd</font>

1191
00:50:07,880 --> 00:50:13,280
still discovered it<font color="#E5E5E5"> around April 20th</font>

1192
00:50:10,760 --> 00:50:14,990
and I was I was<font color="#CCCCCC"> still able to I was</font>

1193
00:50:13,280 --> 00:50:17,360
still going<font color="#E5E5E5"> to report it</font><font color="#CCCCCC"> a few days</font>

1194
00:50:14,990 --> 00:50:19,339
later but<font color="#CCCCCC"> when I started looking</font><font color="#E5E5E5"> around</font>

1195
00:50:17,360 --> 00:50:19,790
seeing if<font color="#E5E5E5"> anybody has reported it</font>

1196
00:50:19,340 --> 00:50:22,100
already

1197
00:50:19,790 --> 00:50:24,440
I discovered that<font color="#E5E5E5"> seven days after</font><font color="#CCCCCC"> yeah</font>

1198
00:50:22,100 --> 00:50:26,930
after I<font color="#CCCCCC"> discovered it someone from</font>

1199
00:50:24,440 --> 00:50:31,220
Google<font color="#E5E5E5"> already have have fixed it so</font><font color="#CCCCCC"> too</font>

1200
00:50:26,930 --> 00:50:34,819
bad<font color="#CCCCCC"> but since</font><font color="#E5E5E5"> that didn't work out so</font>

1201
00:50:31,220 --> 00:50:37,310
<font color="#E5E5E5">well for</font><font color="#CCCCCC"> me to detect</font><font color="#E5E5E5"> does direct kernel</font>

1202
00:50:34,820 --> 00:50:39,590
to user info leaks<font color="#CCCCCC"> I decided that I</font>

1203
00:50:37,310 --> 00:50:41,810
could enable that global<font color="#E5E5E5"> strict mode and</font>

1204
00:50:39,590 --> 00:50:43,880
detect all uses<font color="#CCCCCC"> of</font><font color="#E5E5E5"> unutilized memory and</font>

1205
00:50:41,810 --> 00:50:45,620
analyze all<font color="#CCCCCC"> of</font><font color="#E5E5E5"> them because I had access</font>

1206
00:50:43,880 --> 00:50:48,290
<font color="#CCCCCC">to the source code in this case so I</font>

1207
00:50:45,620 --> 00:50:51,170
could just look into the<font color="#CCCCCC"> in-depth</font><font color="#E5E5E5"> root</font>

1208
00:50:48,290 --> 00:50:54,590
cause of every such instance<font color="#E5E5E5"> so I did</font>

1209
00:50:51,170 --> 00:50:57,920
<font color="#E5E5E5">that and this was more lucky for me so I</font>

1210
00:50:54,590 --> 00:51:00,020
was<font color="#CCCCCC"> able to find a few bugs one of them</font>

1211
00:50:57,920 --> 00:51:03,500
<font color="#E5E5E5">actually led to</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> discovery of an</font>

1212
00:51:00,020 --> 00:51:07,400
actual kernel info<font color="#E5E5E5"> leak in the LLC piece</font>

1213
00:51:03,500 --> 00:51:09,740
<font color="#E5E5E5">or connect in NFC sockets</font><font color="#CCCCCC"> the other ones</font>

1214
00:51:07,400 --> 00:51:11,210
are much lesser

1215
00:51:09,740 --> 00:51:13,220
they were still uses of<font color="#CCCCCC"> uninitialized</font>

1216
00:51:11,210 --> 00:51:16,490
memory but<font color="#CCCCCC"> not directly leading</font><font color="#E5E5E5"> to</font>

1217
00:51:13,220 --> 00:51:19,310
information<font color="#E5E5E5"> disclosure</font><font color="#CCCCCC"> thankfully all</font><font color="#E5E5E5"> of</font>

1218
00:51:16,490 --> 00:51:21,799
<font color="#E5E5E5">them have been fixed now and as you can</font>

1219
00:51:19,310 --> 00:51:27,799
<font color="#CCCCCC">see some of them have also been</font><font color="#E5E5E5"> found by</font>

1220
00:51:21,800 --> 00:51:31,040
external researchers<font color="#E5E5E5"> as</font><font color="#CCCCCC"> well so it turns</font>

1221
00:51:27,800 --> 00:51:34,130
out<font color="#CCCCCC"> that when it comes</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> analyze reads</font>

1222
00:51:31,040 --> 00:51:36,230
from<font color="#E5E5E5"> kernel mode</font><font color="#CCCCCC"> my project</font><font color="#E5E5E5"> was not the</font>

1223
00:51:34,130 --> 00:51:38,390
<font color="#E5E5E5">only one in Linux so there is a project</font>

1224
00:51:36,230 --> 00:51:40,760
called kernel memory sanitizer which is

1225
00:51:38,390 --> 00:51:43,759
being worked on right<font color="#E5E5E5"> now</font>

1226
00:51:40,760 --> 00:51:46,310
it's called km<font color="#CCCCCC"> Sun</font><font color="#E5E5E5"> it's developed by</font>

1227
00:51:43,760 --> 00:51:49,850
<font color="#CCCCCC">Alexander Potter Penco and it has</font>

1228
00:51:46,310 --> 00:51:51,529
<font color="#E5E5E5">collided on a few on a few of my</font>

1229
00:51:49,850 --> 00:51:54,140
findings<font color="#E5E5E5"> and the important</font><font color="#CCCCCC"> thing is that</font>

1230
00:51:51,530 --> 00:51:56,300
it's<font color="#CCCCCC"> actually working in a different way</font>

1231
00:51:54,140 --> 00:51:59,420
it's adding instrumentation at compile

1232
00:51:56,300 --> 00:52:01,850
time<font color="#CCCCCC"> it's very similar to projects such</font>

1233
00:51:59,420 --> 00:52:04,490
<font color="#CCCCCC">as address</font><font color="#E5E5E5"> ionizer memory sanitizer for</font>

1234
00:52:01,850 --> 00:52:06,980
<font color="#E5E5E5">user mode</font><font color="#CCCCCC"> and this is the</font><font color="#E5E5E5"> the correct</font>

1235
00:52:04,490 --> 00:52:09,049
<font color="#E5E5E5">way to do it in Linux but</font><font color="#CCCCCC"> I still wanted</font>

1236
00:52:06,980 --> 00:52:12,020
to<font color="#CCCCCC"> also test</font><font color="#E5E5E5"> my approach on</font><font color="#CCCCCC"> that</font>

1237
00:52:09,050 --> 00:52:15,320
operating<font color="#CCCCCC"> system so the conclusions in</font>

1238
00:52:12,020 --> 00:52:16,910
terms of<font color="#E5E5E5"> Linux is that here we</font><font color="#CCCCCC"> have we</font>

1239
00:52:15,320 --> 00:52:19,310
have a community which has been<font color="#CCCCCC"> on top</font>

1240
00:52:16,910 --> 00:52:21,379
of<font color="#E5E5E5"> the problem for the last</font><font color="#CCCCCC"> few years we</font>

1241
00:52:19,310 --> 00:52:24,049
don't<font color="#E5E5E5"> have so many info leaks here and</font>

1242
00:52:21,380 --> 00:52:26,210
even<font color="#CCCCCC"> if we</font><font color="#E5E5E5"> find something</font><font color="#CCCCCC"> it turns out</font>

1243
00:52:24,050 --> 00:52:28,840
that these<font color="#CCCCCC"> bugs seem to be quite</font>

1244
00:52:26,210 --> 00:52:31,880
short-lived<font color="#E5E5E5"> from my experience at least</font>

1245
00:52:28,840 --> 00:52:33,920
yeah<font color="#E5E5E5"> there is a little bit of future</font>

1246
00:52:31,880 --> 00:52:36,230
work to be done here<font color="#CCCCCC"> we can run further</font>

1247
00:52:33,920 --> 00:52:38,000
iteration on Windows we can try<font color="#E5E5E5"> to</font><font color="#CCCCCC"> look</font>

1248
00:52:36,230 --> 00:52:40,609
into improving code coverage which<font color="#CCCCCC"> is</font>

1249
00:52:38,000 --> 00:52:43,160
always<font color="#CCCCCC"> something that</font><font color="#E5E5E5"> needs to</font><font color="#CCCCCC"> be done I</font>

1250
00:52:40,609 --> 00:52:46,750
can also think<font color="#E5E5E5"> about improving</font><font color="#CCCCCC"> taste</font>

1251
00:52:43,160 --> 00:52:49,399
propagation beyond just<font color="#CCCCCC"> rap</font><font color="#E5E5E5"> of SB and</font>

1252
00:52:46,750 --> 00:52:52,670
implementing support for 64-bit<font color="#CCCCCC"> guests</font>

1253
00:52:49,400 --> 00:52:56,090
which also<font color="#E5E5E5"> should</font><font color="#CCCCCC"> be able to</font><font color="#E5E5E5"> identify a</font>

1254
00:52:52,670 --> 00:52:58,400
<font color="#E5E5E5">few more new bugs</font><font color="#CCCCCC"> there are some other</font>

1255
00:52:56,090 --> 00:53:02,119
more crazy approaches such as<font color="#E5E5E5"> taint less</font>

1256
00:52:58,400 --> 00:53:03,980
approaches of not having any taint but

1257
00:53:02,119 --> 00:53:05,630
only<font color="#E5E5E5"> looking into writes</font><font color="#CCCCCC"> into user</font>

1258
00:53:03,980 --> 00:53:07,130
<font color="#E5E5E5">remote memory and seeing if there are</font>

1259
00:53:05,630 --> 00:53:10,040
any marker<font color="#E5E5E5"> bytes that</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> being leaked</font>

1260
00:53:07,130 --> 00:53:12,530
there<font color="#E5E5E5"> this addresses</font><font color="#CCCCCC"> the problem of</font>

1261
00:53:10,040 --> 00:53:16,400
<font color="#CCCCCC">non-ideal tyne propagation but it has</font>

1262
00:53:12,530 --> 00:53:19,550
other<font color="#E5E5E5"> problems as well yeah we can also</font>

1263
00:53:16,400 --> 00:53:21,800
we can also<font color="#E5E5E5"> think about detecting leaks</font>

1264
00:53:19,550 --> 00:53:23,330
not just<font color="#E5E5E5"> into user remote memory but</font>

1265
00:53:21,800 --> 00:53:25,280
into other<font color="#E5E5E5"> sinks</font><font color="#CCCCCC"> that</font>

1266
00:53:23,330 --> 00:53:28,430
outgoing network traffic<font color="#E5E5E5"> file system</font>

1267
00:53:25,280 --> 00:53:30,530
metadata and stuff like that<font color="#CCCCCC"> so there is</font>

1268
00:53:28,430 --> 00:53:33,200
a lot<font color="#CCCCCC"> of work to do still but I</font><font color="#E5E5E5"> think</font>

1269
00:53:30,530 --> 00:53:36,890
the results so far<font color="#E5E5E5"> are still quite</font>

1270
00:53:33,200 --> 00:53:38,899
impressive<font color="#E5E5E5"> and are motivating to look</font>

1271
00:53:36,890 --> 00:53:41,089
into info leaks more in the future<font color="#CCCCCC"> so</font>

1272
00:53:38,900 --> 00:53:41,880
<font color="#CCCCCC">thank you</font><font color="#E5E5E5"> for listening and I'm happy to</font>

1273
00:53:41,090 --> 00:53:42,580
answer questions

1274
00:53:41,880 --> 00:53:45,060
[Applause]

1275
00:53:42,580 --> 00:53:45,670
[Music]

1276
00:53:45,060 --> 00:53:47,220
[Applause]

1277
00:53:45,670 --> 00:53:50,780
[Music]

1278
00:53:47,220 --> 00:53:50,779
[Applause]

