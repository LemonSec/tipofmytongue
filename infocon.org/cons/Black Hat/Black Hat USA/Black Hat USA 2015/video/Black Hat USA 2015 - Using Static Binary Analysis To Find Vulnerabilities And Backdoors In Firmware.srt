1
00:00:00,000 --> 00:00:03,419
all right so walt's first quickly goal
of our introduction until a little bit

2
00:00:03,419 --> 00:00:07,449
but we're talking about so I my name is
Kris Kringle I am the co-founder and

3
00:00:07,450 --> 00:00:10,750
chief scientist of the last line which
is a company that develops breach

4
00:00:10,750 --> 00:00:15,389
detection solutions and anti-malware
solutions but I where other heads as

5
00:00:15,389 --> 00:00:20,799
well and I'm also professor at UC Santa
Barbara and you know where are you on

6
00:00:20,800 --> 00:00:25,609
and a number of other students to get it
with me in to work on interesting

7
00:00:25,609 --> 00:00:30,550
research topics and also on binary
analysis and vulnerability finding which

8
00:00:30,550 --> 00:00:34,770
is what the topic of today's talk is and
when we still have a little bit of time

9
00:00:34,770 --> 00:00:40,550
I'm also a member of the shellfish team
which is you know playing in CTF

10
00:00:40,550 --> 00:00:46,449
competitions and enjoying final analysis
in general so we are not just to let you

11
00:00:46,450 --> 00:00:53,000
introduced before we can get off course
I'm he on BGC in the UC Santa Barbara

12
00:00:53,000 --> 00:00:57,510
which is an awesome place I would be a
PhD student there but then it would be

13
00:00:57,510 --> 00:01:05,188
kind of crowded also part of shellfish
like Chris but slightly newer part I did

14
00:01:05,188 --> 00:01:09,289
lead the shellfish effort for that
doctors I'm going to challenge though

15
00:01:09,290 --> 00:01:13,350
that I know this I began challenge is an
effort to create a fully automated

16
00:01:13,350 --> 00:01:23,298
hacking program that can hack patch and
when CTS so that was really fun to talk

17
00:01:23,299 --> 00:01:23,860
about it

18
00:01:23,860 --> 00:01:29,360
a tiny bit later and I don't like peanut
butter much to several people should

19
00:01:29,360 --> 00:01:30,530
grand

20
00:01:30,530 --> 00:01:34,759
about tobacco to Chris now with this
most important part of our presentation

21
00:01:34,759 --> 00:01:37,909
of the way what I was talking about that
we're talking about firmware and

22
00:01:37,909 --> 00:01:42,780
basically embedded software and widening
white why is it important to analyze

23
00:01:42,780 --> 00:01:47,600
this kind of software how can we do it
how can we create automated tools that

24
00:01:47,600 --> 00:01:52,210
perform minor analysis and alice is off
the binaries that power tools embedded

25
00:01:52,210 --> 00:01:56,539
devices and then we introduce one
particular jaan will introduce anger

26
00:01:56,540 --> 00:02:01,100
anger is our platform to reform binary
analysis in an automated fashion and you

27
00:02:01,100 --> 00:02:03,550
can find a variety of

28
00:02:03,550 --> 00:02:08,680
abilities in far more and you know we'll
we'll talk more about how we do this

29
00:02:08,680 --> 00:02:12,630
analysis and why it might be interesting
for you as well

30
00:02:12,630 --> 00:02:17,260
ok so I just want to set the stage a
little bit I'm sure you know all of her

31
00:02:17,260 --> 00:02:21,070
to the Internet of Things and its rapid
growth and what that basically tells us

32
00:02:21,070 --> 00:02:25,799
there are more and more devices out
there that Ron embedded software and

33
00:02:25,800 --> 00:02:30,360
those devices and software is becoming
increasingly connected to the Internet

34
00:02:30,360 --> 00:02:33,900
which means more and more people can
possibly access that software remotely

35
00:02:33,900 --> 00:02:38,130
and of course finding vulnerabilities
allows them to remotely exploitable

36
00:02:38,130 --> 00:02:43,140
vulnerabilities in embedded software
which you know is is a problem and of

37
00:02:43,140 --> 00:02:48,779
course also this software is often not
written with security in mind and you

38
00:02:48,780 --> 00:02:54,100
you sort of have a situation almost like
reno's in the late nineties when

39
00:02:54,100 --> 00:02:58,590
actually fairly easy to find bugs in in
that software and that is a problem

40
00:02:58,590 --> 00:03:03,180
because embedded software is becoming
more and more mainstream and it's really

41
00:03:03,180 --> 00:03:08,440
everywhere and starting not only to be
embedded in in some devices that you

42
00:03:08,440 --> 00:03:11,790
might not care about but really devices
that you do care about such as you know

43
00:03:11,790 --> 00:03:18,400
cars industrial control systems and of
course also lot of consumer products

44
00:03:18,400 --> 00:03:23,590
with things for your house like like the
nest or Thomastown so basically we have

45
00:03:23,590 --> 00:03:29,000
this combination off potentially
vulnerable softer that becomes more and

46
00:03:29,000 --> 00:03:34,370
more important is driving more and more
important processes and devices and at

47
00:03:34,370 --> 00:03:39,790
the same time is often treatment with
not a lot of security in mind and not

48
00:03:39,790 --> 00:03:43,109
necessarily easy to operate them to
patch when will our abilities are being

49
00:03:43,110 --> 00:03:48,350
found and of course that really sets up
a situation where there could be a lot

50
00:03:48,350 --> 00:03:51,590
of security problems and and that's
really the reason why I want to study

51
00:03:51,590 --> 00:03:56,030
dole's and Bill automated tools to find
and ultimately defend against those

52
00:03:56,030 --> 00:04:02,400
vulnerabilities ok so how are we looking
at when I basically talked about

53
00:04:02,400 --> 00:04:07,700
embedded devices in from of course in
many cases so the Beasties embedded

54
00:04:07,700 --> 00:04:11,609
devices are just running Linux nice just
a scaled-down version

55
00:04:11,610 --> 00:04:17,049
was some variant of Linux user space
processes and has the normal operating

56
00:04:17,048 --> 00:04:22,019
system college and i know that is is is
more easy to analyze because people are

57
00:04:22,019 --> 00:04:25,640
more familiar with it but when we talk
about from Robbie also mean in

58
00:04:25,640 --> 00:04:31,099
particular mean those kind of far more
to our custom operating system

59
00:04:31,100 --> 00:04:36,200
scaled-down operating system some old
real-time operating systems maybe with

60
00:04:36,200 --> 00:04:41,539
custom programs at all combined together
in what we call a binary blog so that

61
00:04:41,540 --> 00:04:46,660
really means you don't get a familiar
environment you just get a binary blob

62
00:04:46,660 --> 00:04:52,230
some software in binary format and
sometimes it's not easy easy actually

63
00:04:52,230 --> 00:04:56,220
took get this software even often
utilize these devices are running that

64
00:04:56,220 --> 00:04:59,640
embedded software but the question is
how can you access and how can you

65
00:04:59,640 --> 00:05:04,380
translate to do some time environment we
can actually perform some analysis on

66
00:05:04,380 --> 00:05:07,659
top of it so these are already starting

67
00:05:07,660 --> 00:05:11,970
challenges that you face when you
perform when you try to perform some

68
00:05:11,970 --> 00:05:17,330
kind of analysis on this embedded
software okay and and sort of things are

69
00:05:17,330 --> 00:05:21,810
only given the bindery what can you do
well we will perform program analysis

70
00:05:21,810 --> 00:05:26,530
and in particular we performed by every
program or binary code analysis and to

71
00:05:26,530 --> 00:05:32,010
go all is ok we wanted to ride some
property some interesting traits some

72
00:05:32,010 --> 00:05:37,150
interesting behaviour off the software
that we give them and they are just

73
00:05:37,150 --> 00:05:41,419
briefly talked about the two different
ways that two different ways in general

74
00:05:41,419 --> 00:05:46,289
that you can do software analysis and of
course that's also true for binaries its

75
00:05:46,290 --> 00:05:51,780
static binary analysis or dynamic binary
analysis and when before we dive too

76
00:05:51,780 --> 00:05:55,469
much into the details there let me just
remind you of the goals so we want to

77
00:05:55,470 --> 00:05:59,720
perform this analysis was performed by
now and alice is ultimately to him to

78
00:05:59,720 --> 00:06:04,600
find vulnerabilities here we want to
find one or abilities test programs we

79
00:06:04,600 --> 00:06:09,040
want to maybe even verified I'm so when
I prove the absence of certain classes

80
00:06:09,040 --> 00:06:13,740
of one or two be reduced by analyzing
programs and you know we might wanna

81
00:06:13,740 --> 00:06:19,300
generate signatures or defense
mechanisms that can constrain imports

82
00:06:19,300 --> 00:06:21,960
that can trigger dog's owner abilities

83
00:06:21,960 --> 00:06:24,270
and of course you can also use and of
course when you want to find

84
00:06:24,270 --> 00:06:28,549
vulnerabilities you can write exploits
and you know you sexy knowledge of

85
00:06:28,550 --> 00:06:34,930
course possibly 44 not so good purposes
ok so when we look at the to defriend

86
00:06:34,930 --> 00:06:39,470
ways in which you can do the analysis
static or dynamic when we look at static

87
00:06:39,470 --> 00:06:42,250
analysis it really means you just look
at the code right so you look at the

88
00:06:42,250 --> 00:06:48,430
code you don't execute a program and you
try to reason for all possible program

89
00:06:48,430 --> 00:06:53,900
path so you basically need an analysis
that can check out all the possible

90
00:06:53,900 --> 00:06:59,270
actions that that program can possibly
perform which which is great because in

91
00:06:59,270 --> 00:07:02,389
some sense you can achieve this great
coverage you don't have to trial the

92
00:07:02,389 --> 00:07:06,820
path one by one but you can see
meaningful things about the entirety of

93
00:07:06,820 --> 00:07:10,680
the program the problem on a trade-off
is that sometimes the things you can see

94
00:07:10,680 --> 00:07:15,330
about the entirety of the program a very
loose you might say that program might

95
00:07:15,330 --> 00:07:19,940
happen or ability that's not very useful
right so there is an important trade off

96
00:07:19,940 --> 00:07:24,969
that you a static analysis needs to be
precise enough to not produce these are

97
00:07:24,970 --> 00:07:29,419
very generic yes I might be able to
video all past and yes it's a correct

98
00:07:29,419 --> 00:07:34,609
statement but it's not a very useful
statement to be precise analysis as well

99
00:07:34,610 --> 00:07:37,930
there is a more immediate we have high
confidence that there is actually a

100
00:07:37,930 --> 00:07:42,180
vulnerability but that on the other hand
has tradeoffs with scalability because

101
00:07:42,180 --> 00:07:46,710
the more precise you want to be more
costly your analysis could be and the

102
00:07:46,710 --> 00:07:50,739
last scalable might be too large
programs so that sort of a challenge

103
00:07:50,740 --> 00:07:54,590
that we face but in principle static
analysis is great because it allows this

104
00:07:54,590 --> 00:07:58,549
coverage is completeness and also in
some sense verification of programs

105
00:07:58,550 --> 00:08:03,990
because it allows you to say well we
have not found any bugs this class of

106
00:08:03,990 --> 00:08:08,400
this kind in all possible program paths
in that case you have actually verified

107
00:08:08,400 --> 00:08:12,870
a proven that this program is is not
vulnerable to that kind of your ability

108
00:08:12,870 --> 00:08:17,740
so that's great and it's definitely
something that we use but it has dole's

109
00:08:17,740 --> 00:08:22,400
position and scalability tradeoffs that
will get much morning to lay down in

110
00:08:22,400 --> 00:08:26,030
some ways in which you can combine
different analyses to get around the

111
00:08:26,030 --> 00:08:29,950
problem that you want to be both
scalable and precise enough to find prob

112
00:08:29,950 --> 00:08:34,309
homes and of course then sort of the the
counterpart will be dynamic analysis you

113
00:08:34,309 --> 00:08:38,020
just run the program which means you
examine every inch of you don't program

114
00:08:38,020 --> 00:08:42,980
path which on each execution is very
precise you know a lot about that

115
00:08:42,980 --> 00:08:47,580
particular path you know everything
about that particular path but of course

116
00:08:47,580 --> 00:08:52,630
the coverage is not hard to achieve
because you are in some sense limited on

117
00:08:52,630 --> 00:08:57,290
how many of these paths can you execute
in parallel when you find them out of

118
00:08:57,290 --> 00:09:01,390
one after another and what is
particularly interesting also in the

119
00:09:01,390 --> 00:09:04,710
runoff from where sometimes just a
running these programs is actually hard

120
00:09:04,710 --> 00:09:08,310
because let's say you're on them any
principle they would want to interact

121
00:09:08,310 --> 00:09:12,969
with some kind of a peripheral device
right I didn't have sensors that read

122
00:09:12,970 --> 00:09:16,880
something from the environment so if you
took that blog when you moved in some

123
00:09:16,880 --> 00:09:22,170
kind of environment where you are on
your analysis but see an emulator then

124
00:09:22,170 --> 00:09:26,910
what happens if that program tries to
get some sensor readings or tries to act

125
00:09:26,910 --> 00:09:31,949
28 some advice how do you react to this
how can you make sure that you get the

126
00:09:31,950 --> 00:09:35,180
right the proper input to the program so
that he can actually meaningfully

127
00:09:35,180 --> 00:09:40,530
execute so that's a difficult task and
and and something that is particularly

128
00:09:40,530 --> 00:09:46,740
hard on on binary firmware and not as
hard as you would run it on a normal

129
00:09:46,740 --> 00:09:51,500
debt ceiling talks program there are
some ways around this of course you can

130
00:09:51,500 --> 00:09:55,710
you can you try to stop in and try to
fake those imports and try to make the

131
00:09:55,710 --> 00:10:00,750
program run we can try to offload some
system calls as a system called about $5

132
00:10:00,750 --> 00:10:04,580
were you basically have it in an
environment where the interaction with

133
00:10:04,580 --> 00:10:07,600
the device is offloaded to the real
device and then get the data back and

134
00:10:07,600 --> 00:10:11,330
then you can continue to analyze it but
they're definitely challenges in both

135
00:10:11,330 --> 00:10:15,630
areas and then what we do will be a
combination off what traditional static

136
00:10:15,630 --> 00:10:20,170
program analysis and a combination of
dynamic and static analysis which is

137
00:10:20,170 --> 00:10:26,689
called symbolic execution which yon will
go much more into detail ok so we

138
00:10:26,690 --> 00:10:29,600
already talked a little bit about the
challenges of static final analysis hard

139
00:10:29,600 --> 00:10:33,360
to get the binary code but also by his
lack significant information that you

140
00:10:33,360 --> 00:10:36,960
would have when you analyze source code
and also you have to problem that often

141
00:10:36,960 --> 00:10:38,840
are no plea operating system

142
00:10:38,840 --> 00:10:43,580
abstractions when you perform static
analysis on Etsy Linux program and it

143
00:10:43,580 --> 00:10:49,310
reads from a file it would typically you
to call a library that does it for you

144
00:10:49,310 --> 00:10:52,560
know of course that library in turn
causes system call and that system call

145
00:10:52,560 --> 00:10:57,050
or that library function have been very
clear semantics and typically when you

146
00:10:57,050 --> 00:11:01,199
can extract that semantics and you can
feed that Eskom putting your program

147
00:11:01,200 --> 00:11:05,590
analysis then your program analysis has
an ad has already some knowledge about

148
00:11:05,590 --> 00:11:10,290
what functions or system called studio
that you normally don't have when you

149
00:11:10,290 --> 00:11:14,709
just get the entire law and the
operating system functions and library

150
00:11:14,710 --> 00:11:19,420
functions they all match together and
you don't really have that nicely as

151
00:11:19,420 --> 00:11:24,959
abstraction that can add information to
your analysis ok I'm just you know to to

152
00:11:24,960 --> 00:11:29,170
quickly run police challenges that's
probably most of you know when you get

153
00:11:29,170 --> 00:11:32,050
the source but you can violate you
linked together and then you strip any

154
00:11:32,050 --> 00:11:36,810
superfluous information out that might
not be needed to execute binary and when

155
00:11:36,810 --> 00:11:42,430
you do that then things like names
variable in function names of course are

156
00:11:42,430 --> 00:11:47,709
thrown away but also type information
and some targets for indirect control

157
00:11:47,710 --> 00:11:50,120
flow transactions which you have to now

158
00:11:50,120 --> 00:11:54,270
infer back from the binary even if you
want to be able to complete control flow

159
00:11:54,270 --> 00:12:00,030
graph so you have to to perform extra
work to reconstruct the control flow

160
00:12:00,030 --> 00:12:03,380
graph of the application to understand
where the functions and how they can

161
00:12:03,380 --> 00:12:07,770
call each other you have to extract
potential indirect jump targets to be

162
00:12:07,770 --> 00:12:11,270
able to get this complete graph and you
have to know something about the types

163
00:12:11,270 --> 00:12:16,319
of variables to understand its operating
on streams or into just so what

164
00:12:16,320 --> 00:12:20,540
precision appendages so does a lot of
work that we had to put into analysis to

165
00:12:20,540 --> 00:12:25,310
recreate to reconstruct that information
to be even able to just simply say what

166
00:12:25,310 --> 00:12:29,619
are the functions and what what possible
cause between functions can up her

167
00:12:29,620 --> 00:12:35,130
already talked a little bit about the
missing last seen live reps tractions as

168
00:12:35,130 --> 00:12:39,060
I said when you have system calls it's
great you know what I older teens are

169
00:12:39,060 --> 00:12:44,430
and that's very important because in a
sense of vulnerability analysis you have

170
00:12:44,430 --> 00:12:49,349
to assume that the attacker has some apt
to send you data rights and some input

171
00:12:49,350 --> 00:12:50,230
to your program

172
00:12:50,230 --> 00:12:54,670
to your system and this is a great
starting point to do not believe in

173
00:12:54,670 --> 00:12:58,860
Dallas because you want to start at
attacked are potentially can provide

174
00:12:58,860 --> 00:13:03,480
input so you can follow this important
and and understand the attacker can be

175
00:13:03,480 --> 00:13:08,500
flipped off early dawn or influence the
execution down the road if you're

176
00:13:08,500 --> 00:13:13,820
looking at a binary blob just don't have
that information you might have to

177
00:13:13,820 --> 00:13:19,310
reconstruct it based on some interaction
where you know the program I tried to

178
00:13:19,310 --> 00:13:22,949
certain registers 02 certain memory
regions and you have to map that back to

179
00:13:22,950 --> 00:13:27,760
i/o functions also of course you can do
in Alice's on the ceiling with a Linux

180
00:13:27,760 --> 00:13:30,240
system going to face you get type
parameters you know what the return

181
00:13:30,240 --> 00:13:35,390
values mean and you can focus on a much
smaller pocket just the main program and

182
00:13:35,390 --> 00:13:40,630
of course you ask it's not really there
are two bed in a binary blob so we need

183
00:13:40,630 --> 00:13:44,850
your instincts to find all functions
which we know are are possibly

184
00:13:44,850 --> 00:13:49,360
incomplete but we have to come up with
some and doesn't open challenge to be

185
00:13:49,360 --> 00:13:53,300
able to find a different components we
can say he's probably some components of

186
00:13:53,300 --> 00:13:56,979
belong to the operating system and here
I components that are probably the main

187
00:13:56,980 --> 00:14:02,660
program under routine that act on beta
is not supporting functionality so how

188
00:14:02,660 --> 00:14:06,800
can you extract and separate dole's is
it something that is not necessarily

189
00:14:06,800 --> 00:14:13,280
trivial and no single argument supplied
library functions especially for dole's

190
00:14:13,280 --> 00:14:16,589
if you have ever done static analysis
library functions are great because you

191
00:14:16,590 --> 00:14:20,670
actually don't have to analyze them but
rather you can write summary functions

192
00:14:20,670 --> 00:14:26,079
that say ok I know what string compare
does I know what does so I don't have to

193
00:14:26,080 --> 00:14:29,630
look at all the code that implements
that function when I can just write a

194
00:14:29,630 --> 00:14:33,670
little summary that tells me or rather
than static analysis what dysfunctional

195
00:14:33,670 --> 00:14:39,300
do and in a sort of abstract City
semantic summary and that makes the

196
00:14:39,300 --> 00:14:43,510
analysis much easier so not as is gone
into firmware because we don't have the

197
00:14:43,510 --> 00:14:47,110
knowledge of what are you most looking
at you statically linked into a binary

198
00:14:47,110 --> 00:14:54,760
so we need to do this and goes down well
known techniques I dot as flirt the

199
00:14:54,760 --> 00:14:58,069
function my bread and occasional
recognition technology which tries to

200
00:14:58,070 --> 00:15:01,529
guess what for how functions look like
after they've been compiled

201
00:15:01,529 --> 00:15:04,999
you something fairly similar but not so
much

202
00:15:04,999 --> 00:15:08,850
syntactically based on sequence of
instructions but more based on how to

203
00:15:08,850 --> 00:15:14,110
control Florida program looks like and
textile y you say okay there's a control

204
00:15:14,110 --> 00:15:17,899
flow graph that looks like a particular
function that we know is a library

205
00:15:17,899 --> 00:15:21,779
functions we can substitute dysfunction
with our summary and don't have to look

206
00:15:21,779 --> 00:15:26,709
deeper into it which makes the analysis
again faster more precise and more

207
00:15:26,709 --> 00:15:33,809
scalable from those challenges you'll be
wanting you stand by our analysis some

208
00:15:33,809 --> 00:15:37,779
variants of static analysis what kind of
repeated as I was looking for a while

209
00:15:37,779 --> 00:15:41,839
now we look for the classic memory
safety vulnerabilities popular flows out

210
00:15:41,839 --> 00:15:49,100
of bounds reads the right what wears a
day right value to any location at you

211
00:15:49,100 --> 00:15:53,779
can control so that the more traditional
generic memory corruption

212
00:15:53,779 --> 00:15:58,439
vulnerabilities but also at alf
indication bypass back doors which is

213
00:15:58,439 --> 00:16:04,389
odd RSI will talking about the second
because it's more application specific

214
00:16:04,389 --> 00:16:08,920
about 400 ho is the same regardless of
what application to look at its a memory

215
00:16:08,920 --> 00:16:13,240
violation can be specified very cleanly
if you talk about authentication bypass

216
00:16:13,240 --> 00:16:17,399
it's harder because you have to know
more about the application what

217
00:16:17,399 --> 00:16:22,029
authentication means in the context of
an application what it means to be

218
00:16:22,029 --> 00:16:27,769
authenticated so it's harder to model an
authentication by pressing generically

219
00:16:27,769 --> 00:16:33,050
than a memory safety vulnerability and
that exact way to control basically ok

220
00:16:33,050 --> 00:16:37,709
can and attacked her reach certain parts
of the program where you can actually I

221
00:16:37,709 --> 00:16:41,050
can trigger something that you know
makes things in the real world

222
00:16:41,050 --> 00:16:47,529
ok so I'll give you one motivating
example that shows how we detect back

223
00:16:47,529 --> 00:16:52,679
doors on how we model back doors there's
a simple embedded devices and HTTP

224
00:16:52,679 --> 00:16:56,399
Server is actually this is not a binary
blob but will just give you a simple

225
00:16:56,399 --> 00:17:01,009
example same thing applies to to actual
battery blobs and what you have here

226
00:17:01,009 --> 00:17:04,370
someone else home that you basically
have a back door when you get a certain

227
00:17:04,369 --> 00:17:05,928
user name and a password

228
00:17:05,929 --> 00:17:09,970
that's hard coated in a binary and that
allows you to reach authenticated

229
00:17:09,970 --> 00:17:11,880
functionality without actually giving a
result

230
00:17:11,880 --> 00:17:15,709
password so how would you model that
normally would say okay there's a

231
00:17:15,709 --> 00:17:19,730
problem to program a schism using put
that has authentic Asian routine and and

232
00:17:19,730 --> 00:17:23,720
depending on the outcome of that
authentication to reach a success or a

233
00:17:23,720 --> 00:17:27,829
failure branch that makes sense and so
how would you model it back door

234
00:17:27,829 --> 00:17:32,790
well some other paths in that program
that bypasses the authentication 14 and

235
00:17:32,790 --> 00:17:37,080
I could have a string compared with some
other check on the template that is

236
00:17:37,080 --> 00:17:40,699
different from the normal and occasional
team so that's how traditionally back

237
00:17:40,700 --> 00:17:46,070
towards a model the problem is that in
many cases it's actually hard to find

238
00:17:46,070 --> 00:17:49,340
that authentication function if you
don't manually reverse engineer the

239
00:17:49,340 --> 00:17:53,899
program which is exactly what we tried
to avoid with all the meta-analysis so

240
00:17:53,900 --> 00:18:00,580
how can you walk around this how can you
specify an authentication bypass without

241
00:18:00,580 --> 00:18:04,030
actually Milind authentication 14
because there could be other problems

242
00:18:04,030 --> 00:18:08,399
were causing casualties actually simply
missing and I just passing some inputs

243
00:18:08,400 --> 00:18:13,370
to reach a program state where you are
supposedly authenticated or we can do

244
00:18:13,370 --> 00:18:17,540
something that is something that you
shouldn't be able to do as a normal user

245
00:18:17,540 --> 00:18:20,340
but there has never been an
authentication routine in the first

246
00:18:20,340 --> 00:18:24,990
place so that sort of problems with the
previous model were you would have to

247
00:18:24,990 --> 00:18:26,580
notify indication routine

248
00:18:26,580 --> 00:18:30,879
indication he would have to be present
and we need to be able to find path

249
00:18:30,880 --> 00:18:36,820
around that so in order to change this
we decided okay let's let's change them

250
00:18:36,820 --> 00:18:41,210
all the little bits and observed that
it's often easier to find what dole's

251
00:18:41,210 --> 00:18:46,320
authenticated states are when you have
been successful in reaching an

252
00:18:46,320 --> 00:18:49,810
authenticated state so that's easier
than finding authentication routine and

253
00:18:49,810 --> 00:18:55,889
if we can find that would be great to
see ok can I find statically by just

254
00:18:55,890 --> 00:19:01,990
looking at the program some inputs that
allow me to drive that program to that

255
00:19:01,990 --> 00:19:03,090
success state

256
00:19:03,090 --> 00:19:06,709
I don't care what the authentication
genius I don't have to some bypass I

257
00:19:06,710 --> 00:19:11,110
don't get scared all can I have
deterministic import cannot determine

258
00:19:11,110 --> 00:19:15,300
the import just by looking at the
program that allows me to drive the

259
00:19:15,300 --> 00:19:20,710
execution down to the authenticated
success state and there is no bypass the

260
00:19:20,710 --> 00:19:24,550
answer should be no the program itself
doesn't tell you enough information to

261
00:19:24,550 --> 00:19:31,020
bypass authentication and he might be
used on passwords stored somewhere else

262
00:19:31,020 --> 00:19:36,250
however you can actually have authentic
Asian bypass like it back to it as a

263
00:19:36,250 --> 00:19:39,410
string compare then I can actually just
look at the program and I can't

264
00:19:39,410 --> 00:19:44,390
determine by looking at the program
alone what I need to pass to the program

265
00:19:44,390 --> 00:19:49,080
so that i driving down to that success
state and then I can automatically find

266
00:19:49,080 --> 00:19:53,270
back those without even having to know
the authentication 40 so we built this

267
00:19:53,270 --> 00:19:58,950
and we'll show you an example of how it
works in a simple case and the only

268
00:19:58,950 --> 00:20:04,340
problem that is sort of left is how to
mod like indication bypass how to find

269
00:20:04,340 --> 00:20:10,310
the success to authenticate the state
easy to find but how well they are

270
00:20:10,310 --> 00:20:14,720
certain ways you can say okay five some
EBI information some system call

271
00:20:14,720 --> 00:20:18,690
information I could say okay I'm
expecting a particular program that only

272
00:20:18,690 --> 00:20:22,350
authenticated or trusted users should be
able to do I'm accessing certain

273
00:20:22,350 --> 00:20:27,699
operating system resources like files
but I don't have that after say okay is

274
00:20:27,700 --> 00:20:31,190
the program printing out to certain
stream that says hey you are logged in

275
00:20:31,190 --> 00:20:36,500
or hey you authenticated patch certain
parts of the program that I know

276
00:20:36,500 --> 00:20:41,570
touching devices that only authenticated
users should touch what you can do that

277
00:20:41,570 --> 00:20:45,270
if I can just find one point in a
program where I can see a PQ its success

278
00:20:45,270 --> 00:20:51,060
of an hour import determinism approach
will just analyze the program and will

279
00:20:51,060 --> 00:20:55,210
be able to find what imports are needed
form that program to drive it down to

280
00:20:55,210 --> 00:20:59,680
that state and allows us to find
authentication bypass in a very generic

281
00:20:59,680 --> 00:21:03,510
way without actually knowing anything
about the authentication routine in the

282
00:21:03,510 --> 00:21:04,490
first place

283
00:21:04,490 --> 00:21:08,730
ok so basically what I've told you now
are some some of our security policies

284
00:21:08,730 --> 00:21:12,290
and security policy checkers CID is a
paid take a program

285
00:21:12,290 --> 00:21:16,500
you have some policy that says okay this
is authentic Asian bypass that I don't

286
00:21:16,500 --> 00:21:21,640
want or he is just my model memory
corruption and not a question is how can

287
00:21:21,640 --> 00:21:25,870
I applied or security policy so how can
a check for the security policies in

288
00:21:25,870 --> 00:21:30,620
that binary program using our static
analysis tools and this is when I handed

289
00:21:30,620 --> 00:21:35,989
to you he will talk about anger and our
static analysis that allows us to find

290
00:21:35,990 --> 00:21:40,830
violations of these security policies
and produce reports or even

291
00:21:40,830 --> 00:21:49,240
concepts alright thanks Chris so as
Chris mentioned I will be talking about

292
00:21:49,240 --> 00:21:54,870
our awesome by an analysis framework
called anger fear super excited about it

293
00:21:54,870 --> 00:21:59,659
hopefully by the time the silver your
super excited about it you'll see some

294
00:21:59,660 --> 00:22:05,750
good stuff if things get really exciting
you'll see some crashes of our stuff

295
00:22:05,750 --> 00:22:13,670
maybe we'll see so anger has three main
components the first component is a

296
00:22:13,670 --> 00:22:20,120
binary loader doesn't sound too sexy but
a binary loader is very necessary when

297
00:22:20,120 --> 00:22:24,250
you're dealing with firmware right it's
often not clearly Chris mentioned where

298
00:22:24,250 --> 00:22:28,380
that firmware should be loaded in memory
where'd execution should begin and so

299
00:22:28,380 --> 00:22:29,160
forth

300
00:22:29,160 --> 00:22:35,120
then we have a symbolic execution engine
and a static analysis bunch of static

301
00:22:35,120 --> 00:22:41,229
analysis routines talk about all of them
seven Loader because you know I already

302
00:22:41,230 --> 00:22:47,710
mentioned that but let's talk about this
season engine first so what is symbolic

303
00:22:47,710 --> 00:22:53,540
execution so much is a good way of
figuring out how to trigger a certain

304
00:22:53,540 --> 00:22:56,270
path or certain condition in the program

305
00:22:56,270 --> 00:22:59,780
why would we want to do that it's not
just for fun

306
00:22:59,780 --> 00:23:09,790
recall the example of input determinism
to identify firmware back doors in this

307
00:23:09,790 --> 00:23:16,770
model of you really asking ourselves can
we satisfy this pat that gets to the

308
00:23:16,770 --> 00:23:27,060
success can be satisfied with some known
in but that began in binary imagine that

309
00:23:27,060 --> 00:23:31,760
their main ways of answering this
question so we might try for some of the

310
00:23:31,760 --> 00:23:36,220
previous analysis techniques that Chris
talked about so he might try dynamic

311
00:23:36,220 --> 00:23:42,820
analysis techniques so you pick up using
password you try it probably not you try

312
00:23:42,820 --> 00:23:44,230
another one

313
00:23:44,230 --> 00:23:48,970
randomly getting one of these body gonna
be pretty difficult I might want to buy

314
00:23:48,970 --> 00:23:51,520
cable lottery tickets see how that goes

315
00:23:51,520 --> 00:23:57,540
so then you could move on to static
analysis static analysis is to emphasize

316
00:23:57,540 --> 00:24:02,190
it will tell you that maybe you can
there might be a dataflow our paths blow

317
00:24:02,190 --> 00:24:08,340
to the success that great but it does
provide the sort of actionable inputs so

318
00:24:08,340 --> 00:24:15,418
we need something slightly different so
we go into symbolic execution execution

319
00:24:15,419 --> 00:24:23,030
is of course no technique anger
implements that have some occasion based

320
00:24:23,030 --> 00:24:29,899
on improvements off various on their
platforms but the basic ideas first we

321
00:24:29,900 --> 00:24:34,880
interpret the application and we
interpret application by modeling any

322
00:24:34,880 --> 00:24:40,440
user input as a symbolic variables over
here you see program that might read in

323
00:24:40,440 --> 00:24:45,890
four bytes right so that's a reason and
that in coming from user input is

324
00:24:45,890 --> 00:24:53,890
modeled as a symbolic variable acts it's
not 10 it's not 02 not 1337 its acts and

325
00:24:53,890 --> 00:25:01,190
as the program branches retract
constraints this input so if certain

326
00:25:01,190 --> 00:25:06,520
that requires extra be between town and
a hundred we know that down and when

327
00:25:06,520 --> 00:25:11,500
they're quite condition is triggered
order required pat is pat found we then

328
00:25:11,500 --> 00:25:16,370
do what caused the composition steps to
convert the symbolic set of constraints

329
00:25:16,370 --> 00:25:22,428
to a real input so what does that look
like the other set of constraints from

330
00:25:22,429 --> 00:25:26,549
that branch and if you want to take that
branch of you want to satisfy that state

331
00:25:26,549 --> 00:25:32,740
of constraints to a congregation step
using a constraint solvers such as III

332
00:25:32,740 --> 00:25:35,140
or a number of others

333
00:25:35,140 --> 00:25:40,760
get back a possible value chain solving
is pretty tricky it's an np-complete

334
00:25:40,760 --> 00:25:46,760
problem in general so that's what kind
of complications of symbolic execution

335
00:25:46,760 --> 00:25:51,290
that you know you might side constraints
off then you might you know starve to

336
00:25:51,290 --> 00:25:57,500
death while waiting for it to finish but
luckily they're stylish library leverage

337
00:25:57,500 --> 00:26:06,590
for this so given that you know we do
some execution your I'm sure chomping at

338
00:26:06,590 --> 00:26:10,730
the bit to see it happen so we have a

339
00:26:10,730 --> 00:26:19,230
binary that implements kind of an
example model of this back door that

340
00:26:19,230 --> 00:26:25,160
marijuana fine so this binary binary
here I'd ask for username password

341
00:26:25,160 --> 00:26:32,220
authentication 1414 return 0 senator
Jack the user otherwise except these are

342
00:26:32,220 --> 00:26:37,090
the sneaky thing is that this
identicator team has a back door and

343
00:26:37,090 --> 00:26:42,100
that's right here back door string
compares the password against some

344
00:26:42,100 --> 00:26:50,639
hardcore deterring and if it's true it
says that dedicated variable 21 so this

345
00:26:50,640 --> 00:26:56,350
binary has a back door so let's see what
happens when we try to find the back

346
00:26:56,350 --> 00:27:04,449
door and the binary so here is the GUI
for anger anger management

347
00:27:04,450 --> 00:27:11,300
opens up and begin symbolic execution at
the entry points of the program said is

348
00:27:11,300 --> 00:27:18,190
that she points of the program even
before main so we can see and what is

349
00:27:18,190 --> 00:27:29,430
the output what is the output of the
program so far there's no fire no output

350
00:27:29,430 --> 00:27:37,750
here so let's stop until we see a branch
with some other executions ABC a set of

351
00:27:37,750 --> 00:27:45,150
constraints on a conditional branch on
an if statement where we could come up

352
00:27:45,150 --> 00:27:51,680
with input to satisfy both sides are at
least a bit until it matches and Harry

353
00:27:51,680 --> 00:28:01,280
HAP Dec the binary asking the user name
of asking for a password and username so

354
00:28:01,280 --> 00:28:08,410
if you look at as well as the input we
look at that out as little as out when

355
00:28:08,410 --> 00:28:11,540
you look at the input see what happened

356
00:28:11,540 --> 00:28:20,810
be seeded branch here on the password so
sneaky so in order to satisfy this path

357
00:28:20,810 --> 00:28:25,090
the battery to be so sneaky and/or
testified dis pat the password can be

358
00:28:25,090 --> 00:28:34,990
anything except for social if we keep
stepping real see that the social Nikki

359
00:28:34,990 --> 00:28:40,220
Pat says welcome to that and console so
there's a backdoor found using symbolic

360
00:28:40,220 --> 00:28:46,110
execution which reduces actionable in
fluid and matches are

361
00:28:46,110 --> 00:28:53,189
security policy so this is great i mean
this is awesome why don't we just use

362
00:28:53,190 --> 00:28:56,700
symbolic execution for everything ever
and be done with it

363
00:28:56,700 --> 00:29:04,000
well I'll show you why this binary of
course is quite simple but if we look at

364
00:29:04,000 --> 00:29:12,780
a more complicated binary lets a bash I
like you know it was my programming

365
00:29:12,780 --> 00:29:18,020
language of choice for a little but if
we tried to symbolically analyzed batch

366
00:29:18,020 --> 00:29:23,379
will see something interesting happens
so that's step until bash forks not

367
00:29:23,380 --> 00:29:28,030
ports but until the app to possible ties
and let's keep going let's let's see

368
00:29:28,030 --> 00:29:32,470
what happens if we keep going we have
three possible past now now we have like

369
00:29:32,470 --> 00:29:39,809
five or six now be quite a bit more and
as we zoom out we can see that if he

370
00:29:39,809 --> 00:29:50,120
keeps tapping the amount of possible
tats is not sustainable to track so and

371
00:29:50,120 --> 00:29:54,120
thereby keep stepping this will keep
growing and growing and if I sit here

372
00:29:54,120 --> 00:29:57,760
and hammer on this month about double
run around and have another technical

373
00:29:57,760 --> 00:30:02,730
situation like at the beginning of the
presentation but what's wonders as you

374
00:30:02,730 --> 00:30:09,770
can see that with all of this branching
back is branching on the input that you

375
00:30:09,770 --> 00:30:16,860
provide the command line parameters
standard input and so court but if you

376
00:30:16,860 --> 00:30:24,049
look even with so many states here in
and bash already if we cut what Bosch

377
00:30:24,049 --> 00:30:29,030
has output at Sapphire relay that graph

378
00:30:29,030 --> 00:30:34,899
man this is that even with all of these
paths bash still hasn't even printed

379
00:30:34,900 --> 00:30:40,799
anything right so this is symbolic
exploration undergoing a path explosion

380
00:30:40,799 --> 00:30:45,429
inside like initialization code of bash
and this is why some of his probation

381
00:30:45,429 --> 00:30:47,570
alone is

382
00:30:47,570 --> 00:30:56,500
not feasible approach for this sort of
vetting 44 back doors and one abilities

383
00:30:56,500 --> 00:31:07,690
at least I'm not alone so what can we do

384
00:31:07,690 --> 00:31:13,540
execution because it's very precise one
that tells us that the back door if you

385
00:31:13,540 --> 00:31:21,540
give us an input to trigger that back
door and you know those in Wiltshire

386
00:31:21,540 --> 00:31:26,730
immediately actionable it's very
flexible but unfortunately just not

387
00:31:26,730 --> 00:31:32,090
scalable on its own because the
Patagonian problem that we just saw and

388
00:31:32,090 --> 00:31:36,679
because constraint solving is tricky so
if you saw sometimes when I click it was

389
00:31:36,680 --> 00:31:45,380
it for a while solving a particular set
of constraints in the background so and

390
00:31:45,380 --> 00:31:51,690
furthermore we have my case that's very
simple back door but as we saw in a real

391
00:31:51,690 --> 00:31:58,700
program with Bosch things go badly and
in fact a real back door might be

392
00:31:58,700 --> 00:32:02,270
burdened identification between that's
in the real program writer that's in a

393
00:32:02,270 --> 00:32:10,460
real binary and as a control flow that
is kinda crazy and you might not even

394
00:32:10,460 --> 00:32:13,820
get to the back door might be in that
red square we might not even get there

395
00:32:13,820 --> 00:32:17,919
because of a bad explosion will run out
of resources never reached so what do we

396
00:32:17,920 --> 00:32:23,510
do well in anger we provide a bunch of
static analysis routines that we can use

397
00:32:23,510 --> 00:32:30,450
to guide symbolic execution and keep it
feasible to detect these back doors

398
00:32:30,450 --> 00:32:39,910
specifically we provide two main types
of analyses based on a really cool

399
00:32:39,910 --> 00:32:46,020
technique of valujet houses control flow
graph I'm so angry control flow graph

400
00:32:46,020 --> 00:32:47,840
isn't

401
00:32:47,840 --> 00:32:51,689
like I just control photograph in the
sense that it just shows you you know

402
00:32:51,690 --> 00:32:57,990
direct jobs and some heuristic lead
recovered as it attempts to be extremely

403
00:32:57,990 --> 00:33:06,070
complete we tried to resolve indirect
jobs cost function pointers also it's

404
00:33:06,070 --> 00:33:13,059
hard to analyze control transitions to
attempt to create a very complete

405
00:33:13,059 --> 00:33:17,840
control program for other analyses on
top of that we do a data-flow analysis

406
00:33:17,840 --> 00:33:24,980
so want to be identified successfully
authenticated point the data-flow

407
00:33:24,980 --> 00:33:30,340
analysis to determine a small slice of
the program that began executed instead

408
00:33:30,340 --> 00:33:36,470
of the entire firmware to analyze just a
dot on occasion routine and this is all

409
00:33:36,470 --> 00:33:42,799
powered like I said by valujet analysis
houses real quick

410
00:33:42,799 --> 00:33:47,870
valujet analysis is very useful that
telling us things that symbolic

411
00:33:47,870 --> 00:33:55,399
execution is not good ad that you know
that others that he now sees might not

412
00:33:55,399 --> 00:34:01,570
be very good at taking this example this
is a simple ooh that looks through an

413
00:34:01,570 --> 00:34:09,668
array for the value 1337 and we want to
know at the end of this loop what is the

414
00:34:09,668 --> 00:34:17,149
value in RBX ride an RBI access of
course of the loop counter in this

415
00:34:17,149 --> 00:34:23,469
example so symbolic exploration
undergoes a state explosion here at

416
00:34:23,469 --> 00:34:31,040
every little it looked at that exists a
loop and one that doesn't first time it

417
00:34:31,040 --> 00:34:35,839
says okay is it wouldn't be fine 127
maybe you're right side it spawns off to

418
00:34:35,839 --> 00:34:41,609
Batswana what you did when we sit and by
that I did you have 10 24 at-bats and of

419
00:34:41,609 --> 00:34:46,199
course that every other part of your
program more than every other part of

420
00:34:46,199 --> 00:34:50,158
your now says will explode by that much
so he could do something ie static

421
00:34:50,159 --> 00:34:53,530
analysis which saw this I'll be asking
you anything that's precise

422
00:34:53,530 --> 00:35:00,840
that's correct but it's not precise
right we could improve the precision

423
00:35:00,840 --> 00:35:07,730
with Iranian analysis that's houses IBX
is less than 0 X 1024 1024

424
00:35:07,730 --> 00:35:15,370
reason is the size of this offer you can
see it right here so there's no question

425
00:35:15,370 --> 00:35:20,450
can we do better answer is yes you can
use value chain analysis a detailed

426
00:35:20,450 --> 00:35:27,779
analysis is really complex analysis that
was quite a lot of complicated things

427
00:35:27,780 --> 00:35:33,940
but let's dive into a specific part of
it you look at stride intervals in

428
00:35:33,940 --> 00:35:41,160
Valley Center now is such a terrible
represents a set of values of all of the

429
00:35:41,160 --> 00:35:47,129
equipment is symbolic execution symbolic
variable fragile and we had acts before

430
00:35:47,130 --> 00:35:51,360
and then we add constraint on a tax
write about a variable is static

431
00:35:51,360 --> 00:35:58,590
analysis equipment that in this case so
this is radical here has a low value of

432
00:35:58,590 --> 00:36:05,010
x 100 a high value X 120 size 32 mites
and a stride of poor so the shut up for

433
00:36:05,010 --> 00:36:09,640
me is that it can take any value at
intervals of four between 100 and 1:20

434
00:36:09,640 --> 00:36:14,819
so how does this help us right now let's
look at how he'd analyze that example

435
00:36:14,820 --> 00:36:19,390
with valujet analysis we start out at

436
00:36:19,390 --> 00:36:24,509
program position one here where we just
initialize IBX be acts is now a shadow

437
00:36:24,510 --> 00:36:29,960
fall between zero and zero the shadow
one great so then we go through the

438
00:36:29,960 --> 00:36:38,329
little boy who wants a ride so as we go
through the loop we merge the loop about

439
00:36:38,329 --> 00:36:43,079
cattle better be merged the value of RBS
with his previous value so any margin

440
00:36:43,079 --> 00:36:48,650
though is that it was we get a shot
animal that could be 044 thats radio

441
00:36:48,650 --> 00:36:55,529
33014 with a straight up or two values
we go through it again be much it can

442
00:36:55,529 --> 00:37:01,589
have three values 0 corn 890 porn scene
and finally we hit the limit of our

443
00:37:01,589 --> 00:37:06,269
patients we say screw it and we do a
widening operation right so in order to

444
00:37:06,269 --> 00:37:11,089
give this is above absolute limit at
which is why did he say ok now it can be

445
00:37:11,089 --> 00:37:14,690
between zero and infinity but if it's
the let's ride up for me know it's a

446
00:37:14,690 --> 00:37:20,440
strata for which we didn't know that in
any of the other analyses but further on

447
00:37:20,440 --> 00:37:25,500
because then do a narrowing operation we
analyze that again and we see all K that

448
00:37:25,500 --> 00:37:28,799
maximum was 1024

449
00:37:28,799 --> 00:37:33,599
and allowed us to get out of the loop in
two RBIs and now we know that IBX can be

450
00:37:33,599 --> 00:37:39,849
between 0 and 1024 1024 this is more
information that I read in the house has

451
00:37:39,849 --> 00:37:45,130
told us and it specifically critical
because for example if I be accessed and

452
00:37:45,130 --> 00:37:50,549
used as entry into a jump table we know
that the jump to as addresses starting

453
00:37:50,549 --> 00:37:55,299
every fortnight which is critical for
assaulting indirect jumps through a temp

454
00:37:55,299 --> 00:37:59,569
table that's anger

455
00:37:59,569 --> 00:38:08,049
talk about the different components
different analyses you have some of them

456
00:38:08,049 --> 00:38:13,319
there's more of course but what did we
use it for one of the things we use it

457
00:38:13,319 --> 00:38:18,660
for other than back doors and from where
is the dog beside a grand challenge as I

458
00:38:18,660 --> 00:38:23,459
said the same again challenge is a
contest to build an autonomous hacking

459
00:38:23,459 --> 00:38:30,529
platform that can happen patentability
shellfish participated as a bunch of

460
00:38:30,529 --> 00:38:35,670
grad students at UC Santa Barbara if you
guys think you are

461
00:38:35,670 --> 00:38:43,009
company's code is kinda crazy you should
see what 11 grad students together in

462
00:38:43,009 --> 00:38:49,739
their spare time with very little lower
side pretty crazy but we use that we

463
00:38:49,739 --> 00:38:58,759
created a cyber reasoning system which
did a lot of stuff including scanning

464
00:38:58,759 --> 00:39:03,949
for vulnerabilities and Patrick the
possibilities and both of those uses one

465
00:39:03,949 --> 00:39:08,570
of the main components anger so this
system is pretty

466
00:39:08,570 --> 00:39:15,410
powerful and actually very usable use
that to qualify for the CDC and when it

467
00:39:15,410 --> 00:39:22,240
fair chunk of change for shellfish so
it's pretty awesome so we made anger so

468
00:39:22,240 --> 00:39:27,979
that anyone could use it not just us to
use it for my python you can access its

469
00:39:27,980 --> 00:39:35,520
analyses encapsulated very usable a lot
of buzz words and moreover he made

470
00:39:35,520 --> 00:39:40,360
architecture independent easy on me
analyze unarmed binary CDC was x86

471
00:39:40,360 --> 00:39:46,150
actually support the 64 bit and 32 bit
variants of every major architecture

472
00:39:46,150 --> 00:39:55,980
maps on PPC x86 these facts as I
interpretation which allows us to do

473
00:39:55,980 --> 00:40:04,520
that vaccines what background uses which
is a great man checks work so they said

474
00:40:04,520 --> 00:40:05,680
super easy to use

475
00:40:05,680 --> 00:40:11,529
here's the top there we can generate and
display control flow graph for a binary

476
00:40:11,530 --> 00:40:15,670
and four lines of Python that's
including importing anger and loading

477
00:40:15,670 --> 00:40:19,620
the binary and on the bottom we can

478
00:40:19,620 --> 00:40:26,040
carry-out symbolic execution super
simply as well of course it's up to you

479
00:40:26,040 --> 00:40:32,160
to make sure it doesn't explode and so
forth but core analyses are exposed very

480
00:40:32,160 --> 00:40:38,529
readily and what's more hangers open
source so as of right now as of this

481
00:40:38,530 --> 00:40:44,160
talk we open sourced anger you can find
it on github you can head up our website

482
00:40:44,160 --> 00:40:48,350
angered I O as long as they got the
internet working enough to update the

483
00:40:48,350 --> 00:40:56,890
website and you can subscribe to our
mailing list represents two years at

484
00:40:56,890 --> 00:41:03,279
work this is our baby the line numbers
are almost 60,000 and gigantic project

485
00:41:03,280 --> 00:41:11,150
called twice and a tiny bit overseas in
one place and there are about 6,000

486
00:41:11,150 --> 00:41:18,330
commits I mean this is pretty crazy
undertaking and we hope that this will

487
00:41:18,330 --> 00:41:23,470
kind of lunch the next generation of
mine analysis that we'd love to

488
00:41:23,470 --> 00:41:30,209
collaborate with everyone to improve our
capabilities in this field as in the

489
00:41:30,210 --> 00:41:34,700
communities capabilities so check out
anger stars of course I'm getting up

490
00:41:34,700 --> 00:41:36,069
there goes without saying

491
00:41:36,070 --> 00:41:52,170
and issues pull request everything's
welcome email yeah

492
00:41:52,170 --> 00:42:17,860
question

493
00:42:17,860 --> 00:42:34,450
it seems like you're going from the
start to the end to find the success or

494
00:42:34,450 --> 00:42:39,990
the success bad there isn't much easier
to do that it seems that the passing

495
00:42:39,990 --> 00:42:49,649
game engine but what if you go from the
success path backwards to find full

496
00:42:49,650 --> 00:42:55,460
approach but we don't have a visual
going to the pool approaches of course

497
00:42:55,460 --> 00:43:00,270
identified that success bad I'm
calculate the data dependency graph and

498
00:43:00,270 --> 00:43:05,630
then slide backwards and then actually
just that slice that's much harder to

499
00:43:05,630 --> 00:43:13,310
visualize right now supports static
analyses mostly in terms of grabbing

500
00:43:13,310 --> 00:43:20,190
control growth graph and that it
supports this operation

501
00:43:20,190 --> 00:43:33,180
what he did for the paper for example is
implemented exactly what you're saying

502
00:43:33,180 --> 00:43:42,669
resulting function pointers soviet
valujet analysis for a whole bunch of

503
00:43:42,670 --> 00:43:46,319
things they see if he could you can
check it out of several thousand lines

504
00:43:46,319 --> 00:43:55,160
long as complete insanity is sitting
over there laughing right now

505
00:43:55,160 --> 00:44:01,920
a lot of stuff depending on the function
pointer so fit for example something

506
00:44:01,920 --> 00:44:06,500
dads in a global structure right he
might use valujet analysis to identify

507
00:44:06,500 --> 00:44:09,710
the possible range as

508
00:44:09,710 --> 00:44:17,240
where to point her point to and then
jump there if it's something that is

509
00:44:17,240 --> 00:44:19,598
computer on the fly

510
00:44:19,599 --> 00:44:25,279
in certain cases have to resort to
slicing backwards from the jump and

511
00:44:25,279 --> 00:44:30,229
symbolically executing that slice to
determine the jump target areas where

512
00:44:30,229 --> 00:44:34,299
several of these different types of
operation that we can carry out to

513
00:44:34,299 --> 00:44:38,849
resolve as many of these indirect
pointers as possible I guess my question

514
00:44:38,849 --> 00:44:44,609
really was like what kind of points to
elsa studios more of a fish question but

515
00:44:44,609 --> 00:44:58,288
I love to talk to you are flying with
other guys have to wrap it up regularly

516
00:44:58,289 --> 00:45:12,709
but the papers from Alice it was
published that NDSS in February I'm

517
00:45:12,709 --> 00:45:21,890
sorry for us and I see thank you

518
00:45:21,890 --> 00:45:31,969
loader do have some nice pics that can
detect like the ex-works something that

519
00:45:31,969 --> 00:45:33,660
can cast

520
00:45:33,660 --> 00:45:40,078
loading addresses just remember we
detect loading offices and then we have

521
00:45:40,079 --> 00:45:47,869
some analyses identified tried to
identify it like a start point I like

522
00:45:47,869 --> 00:45:54,549
where we're at said you might go to
start loading Jackson has fairly robust

523
00:45:54,549 --> 00:45:59,079
did use a bunch of different like jump
tables global memory access right figure

524
00:45:59,079 --> 00:46:07,420
out where to buy their needs to go look
sometimes yes sometimes it happens

525
00:46:07,420 --> 00:46:16,280
ok does it work with polymorphic code or
10 you extended to do this so called the

526
00:46:16,280 --> 00:46:22,059
changes in cells have never tested it
with polymorphic code but when we lived

527
00:46:22,059 --> 00:46:30,260
by its like to translate and analyzed be
lifted from the running state I'd have

528
00:46:30,260 --> 00:46:36,470
to see that the default but we do have
that ability so I want to say yes it

529
00:46:36,470 --> 00:46:41,089
should be it should be able to there's
not a fundamental stopping but I'm sure

530
00:46:41,089 --> 00:46:45,470
that the first time you tried somethin
will go horribly wrong but tried to open

531
00:46:45,470 --> 00:46:52,200
an issue it'll be interesting to see
tanks ok soul which software did you use

532
00:46:52,200 --> 00:47:00,390
for the symbolic execution tool WZ 30
yes every every every release anger has

533
00:47:00,390 --> 00:47:05,940
a bunch of different components as like
six or seven repositories and check it

534
00:47:05,940 --> 00:47:12,980
out but we have one thats abstraction
layer over history and the main

535
00:47:12,980 --> 00:47:18,020
supporting bout analysis so they could
have this kind of unified interface to

536
00:47:18,020 --> 00:47:19,790
them but for solving busy

