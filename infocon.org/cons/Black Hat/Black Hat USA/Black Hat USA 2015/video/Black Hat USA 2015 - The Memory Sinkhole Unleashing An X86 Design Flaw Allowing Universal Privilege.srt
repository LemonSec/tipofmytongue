1
00:00:00,000 --> 00:00:05,720
the stock is the memory sinkhole
unleashing an x86 design flaw allowing

2
00:00:05,720 --> 00:00:18,460
for universal privilege escalation for
Speaker Christopher Thomas right good

3
00:00:18,460 --> 00:00:21,670
morning everyone thanks for coming out
my name is Christopher Domus I'm a

4
00:00:21,670 --> 00:00:25,369
cyber-security researcher a group called
the Battelle Memorial Institute it's a

5
00:00:25,369 --> 00:00:28,849
pretty cool place to work is my chance
to do a lot of research into the fringe

6
00:00:28,849 --> 00:00:32,399
areas of cybersecurity that I wouldn't
otherwise get to see what I want and

7
00:00:32,399 --> 00:00:36,040
what I wanted to talk to you about today
is something I've been tinkering with my

8
00:00:36,040 --> 00:00:39,769
free time for the last couple of months
actually an x86 architectural

9
00:00:39,770 --> 00:00:43,300
vulnerability that allows privilege
escalation it's been hittin on these

10
00:00:43,300 --> 00:00:46,989
processors for the last 20 years without
anybody noticing yet what did

11
00:00:46,989 --> 00:00:51,570
effectively does open up an entirely new
class of exploits on these processors

12
00:00:51,570 --> 00:00:54,860
and i wanna talk about exactly how
that's going to work but first I wanna

13
00:00:54,860 --> 00:00:58,980
give a demonstration in order to sort of
frame what we're going to see today so

14
00:00:58,980 --> 00:01:02,288
demonstrations a little bit risky so
instead of doing this on my actual

15
00:01:02,289 --> 00:01:05,670
presentation laptop I've got the same
netbook over here I love doing this

16
00:01:05,670 --> 00:01:08,840
deport her ability research on these
netbooks because I can break these

17
00:01:08,840 --> 00:01:12,299
things all day long and just not feel
bad about it and just in case something

18
00:01:12,299 --> 00:01:16,000
does go very bad I've got entire stack
of backups here so we should be prepared

19
00:01:16,000 --> 00:01:23,430
so some s estate interests into this
netbook that's the prompt that we see

20
00:01:23,430 --> 00:01:28,020
here and I just sshd in some boring
unprivileged user who can do boring

21
00:01:28,020 --> 00:01:32,560
unprivileged things the one of things
are boring unprivileged user can do is

22
00:01:32,560 --> 00:01:36,130
they can run boring unprivileged
programs so I've got the simple C

23
00:01:36,130 --> 00:01:40,429
program here that doesn't really do
anything interesting does this create a

24
00:01:40,430 --> 00:01:44,649
couple of 64 bit variables it's got this
sort of clue genus hear that I'll fix

25
00:01:44,649 --> 00:01:49,180
later on this ensures that the processes
can be scheduled on court 0 of the

26
00:01:49,180 --> 00:01:52,710
processor right now this exploits only
gonna work on Corey 0 I can fix it later

27
00:01:52,710 --> 00:01:56,640
but then we do something very very
simple decision loop for a couple

28
00:01:56,640 --> 00:02:01,350
million iterations and all we do in this
loop is right to 64 bit value out to

29
00:02:01,350 --> 00:02:05,939
memory read it back in from memory into
the processor registers and then write

30
00:02:05,939 --> 00:02:09,119
that back out to memory again we do that
over and over and over again so this is

31
00:02:09,119 --> 00:02:10,560
a real hammer this is literally

32
00:02:10,560 --> 00:02:15,030
just reading a 64 bit value into the
processor registers for a very very long

33
00:02:15,030 --> 00:02:21,069
time and after that's done we're gonna
exacting shell hoping that maybe we

34
00:02:21,069 --> 00:02:26,040
cause something to happen by using this
magic 64 bit number I'm gonna go ahead

35
00:02:26,040 --> 00:02:32,470
and compile this simple C program here
and one more time before I run this

36
00:02:32,470 --> 00:02:36,170
double check who I am I am user right
now we're gonna go ahead and run this

37
00:02:36,170 --> 00:02:41,079
little C program here and hopefully
maybe something will actually happen to

38
00:02:41,080 --> 00:02:45,640
run this and it sits in that loop and it
didn't work we still have that dollar

39
00:02:45,640 --> 00:02:51,290
sign which means we checked who I am I'm
still user so of course it didn't work

40
00:02:51,290 --> 00:02:55,390
you can escalate privileges by loading a
64 bit number and the processor

41
00:02:55,390 --> 00:03:02,708
registers that's kind of silly but maybe
maybe you can maybe if we find the right

42
00:03:02,709 --> 00:03:07,250
64 bit number we can do that so many
change that last three in the 64 bit

43
00:03:07,250 --> 00:03:11,930
numbers going to become a four instead
we're going to retry this attack where

44
00:03:11,930 --> 00:03:17,170
recompile the program one more time
verify that we're just user and run the

45
00:03:17,170 --> 00:03:25,079
program and all of a sudden something
changed

46
00:03:25,080 --> 00:03:33,250
the hour figuring out how this thing
works but I got a warning that its

47
00:03:33,250 --> 00:03:37,730
flashier than it actually seems there is
absolutely nothing special about that 64

48
00:03:37,730 --> 00:03:41,320
bit value if you run this exact same
code on your computer's absolutely

49
00:03:41,320 --> 00:03:45,780
nothing will happen exactly as you would
expect all that 64 bit number really was

50
00:03:45,780 --> 00:03:50,890
a signal to something running much much
deeper on the processor is something

51
00:03:50,890 --> 00:03:54,290
running so deep that our process
couldn't see it in fact even the kernel

52
00:03:54,290 --> 00:03:58,620
running in room 0 couldnt see that piece
of code that just gave us that root

53
00:03:58,620 --> 00:04:01,910
access infected to tear the system apart
for the last piece into a forensic

54
00:04:01,910 --> 00:04:06,359
analysis on here and not be able to see
the piece of code that just gave us that

55
00:04:06,360 --> 00:04:10,270
root access so what we're really gonna
find out exactly how to get something

56
00:04:10,270 --> 00:04:14,870
running so deeply on the processor that
nothing else can see it there what we're

57
00:04:14,870 --> 00:04:18,180
going to see today is an architectural
solution for reminders to privilege

58
00:04:18,180 --> 00:04:22,600
escalation in order to understand how
this work we need we need a little bit

59
00:04:22,600 --> 00:04:26,680
of background information on the x86
privilege model sexy 6 divides privilege

60
00:04:26,680 --> 00:04:30,440
in two different rings are the top is
ring 3 where we really can't do anything

61
00:04:30,440 --> 00:04:34,320
useful that's where all our usual and
code runs inside of ring 3 just doing

62
00:04:34,320 --> 00:04:38,270
boring uninteresting things we've got
room 201 below that nobody really uses

63
00:04:38,270 --> 00:04:41,770
those anymore about ring 0 for the real
magic happens where the kernel lives

64
00:04:41,770 --> 00:04:45,229
that's where we can finally start doing
some interesting things on the processor

65
00:04:45,230 --> 00:04:48,750
and usually if you want to do something
really interesting and exploit you try

66
00:04:48,750 --> 00:04:55,169
to go from three down 20 but it doesn't
stop there it goes much much deeper than

67
00:04:55,169 --> 00:04:59,310
that over the course of evolution of the
x86 processor we sort of found out that

68
00:04:59,310 --> 00:05:04,470
some things are so important that ring 0
shouldn't have access to them so we

69
00:05:04,470 --> 00:05:08,660
created additional levels of privilege
deeper on the processor so we invented

70
00:05:08,660 --> 00:05:11,810
this ring minus one which is more
commonly known as simply the hypervisor

71
00:05:11,810 --> 00:05:16,910
but as we found out he eventually
somethings are still so important that

72
00:05:16,910 --> 00:05:21,560
even the hypervisor shouldn't be able to
access it so we traded on another level

73
00:05:21,560 --> 00:05:27,169
on the processor will be called 3-2 or
system management mode the system and to

74
00:05:27,169 --> 00:05:30,830
promote started out simply enough is
just what if we had this mode of

75
00:05:30,830 --> 00:05:34,609
execution that's invisible to the
operating system I would want something

76
00:05:34,610 --> 00:05:38,440
like that well originally is pretty
simple we just want to be able to power

77
00:05:38,440 --> 00:05:41,730
management without the operating system
having to worry about it does a simple

78
00:05:41,730 --> 00:05:46,430
goal for system management mode but it
evolved from there over the course of

79
00:05:46,430 --> 00:05:49,570
time system and remote sort of became
this dumping grounds for all these

80
00:05:49,570 --> 00:05:53,150
miscellaneous things that we didn't want
the operating system to have to worry

81
00:05:53,150 --> 00:05:57,539
about and then all of a sudden came a
big one we don't platform security into

82
00:05:57,540 --> 00:05:59,670
system management mode and why not

83
00:05:59,670 --> 00:06:03,310
platform security is really really
important and ring 0 could be

84
00:06:03,310 --> 00:06:07,510
compromised if we put platform security
and to remind us to all of a sudden we

85
00:06:07,510 --> 00:06:11,060
don't have to worry about ring 0
compromises anymore but it really opened

86
00:06:11,060 --> 00:06:14,600
up a whole pandora's box for what system
management mode can do it's now in

87
00:06:14,600 --> 00:06:19,120
charge of an alarming number of very
important things on the processor like

88
00:06:19,120 --> 00:06:22,290
cryptographically authenticated
variables signature verifications

89
00:06:22,290 --> 00:06:26,470
hardware locks keep him communications
controller platform lockbox on that

90
00:06:26,470 --> 00:06:28,970
system and it's actually the interface
to the root of trust in the system

91
00:06:28,970 --> 00:06:33,700
because system management mode alone can
modify the very first instruction that

92
00:06:33,700 --> 00:06:41,150
the processor will ever executes when it
turns on so basically what we've seen

93
00:06:41,150 --> 00:06:45,380
over the evolution of SMN is that
whenever we had anything that was so

94
00:06:45,380 --> 00:06:49,270
important that we didn't want the kernel
to screw it up or so secret that I need

95
00:06:49,270 --> 00:06:53,590
to be hidden from the OS and GMA
accesses or so sensitive that it should

96
00:06:53,590 --> 00:06:58,130
never be touched by anyone we just
tossed into system management mode for

97
00:06:58,130 --> 00:07:01,550
modern process this is really what are
privileged model looks like at the

98
00:07:01,550 --> 00:07:04,940
highest level least privilege is just a
ring three total sitting just below ring

99
00:07:04,940 --> 00:07:11,190
30 where the kernel execute its but much
deeper than 30 is the hypervisor and

100
00:07:11,190 --> 00:07:14,310
there's a chasm that separates the
hypervisor from system management mode

101
00:07:14,310 --> 00:07:19,250
and ring minus 22 alternately reminders
to us what's really in control of the

102
00:07:19,250 --> 00:07:23,520
processor so if you think that you own a
system when you get down to ring 0

103
00:07:23,520 --> 00:07:28,090
you're really not even close because
there are layers and layers of

104
00:07:28,090 --> 00:07:33,710
separation between 30 and the actual
processors on modern systems 30 simply

105
00:07:33,710 --> 00:07:35,380
not in control

106
00:07:35,380 --> 00:07:38,990
3-2 is what controls the hardware the
firmware in all the most critical

107
00:07:38,990 --> 00:07:41,790
security checks if we want to do
something interesting we need to find a

108
00:07:41,790 --> 00:07:46,169
way to get deeper than ring 01 ordered
figure out how to do that we need to

109
00:07:46,169 --> 00:07:50,139
understand the privilege model for SMS
works how can estimate

110
00:07:50,139 --> 00:07:53,610
be something invisible to the operating
system how can you bring your own not

111
00:07:53,610 --> 00:07:58,499
see something sitting in memory will the
idea behind system management mode is

112
00:07:58,499 --> 00:08:01,289
that it's going to execute from a
special region of memory card system

113
00:08:01,289 --> 00:08:06,900
management RAM RSM RAM thats region of
memories only gonna be accessible to S&M

114
00:08:06,900 --> 00:08:11,529
code so the idea that the processor will
receive what's called a system

115
00:08:11,529 --> 00:08:15,360
management interrupt an SMI that's going
to switch processor over to system

116
00:08:15,360 --> 00:08:19,729
management mode and it's going to unlock
some RAM system engine motor cortex cue

117
00:08:19,729 --> 00:08:22,990
from a supreme and when it's done it's
one issue to resume instruction which is

118
00:08:22,990 --> 00:08:26,270
going to lead system management mode and
relock as Henry I'm so with this model

119
00:08:26,270 --> 00:08:31,270
system management RAM is only ever
visible to ASM code that's how we hide

120
00:08:31,270 --> 00:08:36,279
it from 10 so if you're sitting in room
0 and you try to read from SEM Rams on

121
00:08:36,279 --> 00:08:39,519
specific system I was looking at a
summer camp started at one at this point

122
00:08:39,519 --> 00:08:44,130
eight megabytes if we try to read from
that address from 10 we're just gonna

123
00:08:44,130 --> 00:08:49,610
get a bunch of garbage in this case we
can't actually see what's there but but

124
00:08:49,610 --> 00:08:53,140
how does that work how is it possible
that reads 0 can't see memory that's

125
00:08:53,140 --> 00:08:56,920
physically on the system lets memory
controller hub job its job is to

126
00:08:56,920 --> 00:09:02,670
separate Sen RAM from ring 0 and it's
ultimately in charge of enforcing a

127
00:09:02,670 --> 00:09:06,800
cement security so this sort of the
layout that we have for SMS security

128
00:09:06,800 --> 00:09:09,890
that the processor on the left and
memory controller hub sitting in between

129
00:09:09,890 --> 00:09:15,100
a processor and memory syndrome sitting
somewhere in memory so if we're in Assam

130
00:09:15,100 --> 00:09:19,589
and we try to read from a memory address
inside of RAM memory controller hub

131
00:09:19,589 --> 00:09:23,130
looked at that address season attendance
and ram it looks at what motor and it

132
00:09:23,130 --> 00:09:27,269
seems that were innocent men do it
allows us to access that memory returns

133
00:09:27,269 --> 00:09:31,010
to us some real values on the other hand
if we're in room 0 we tried to issue

134
00:09:31,010 --> 00:09:34,260
that exact same instruction that address
goes over the memory controller hub

135
00:09:34,260 --> 00:09:38,839
memory controller hub says no you're not
in a cement you can't access this memory

136
00:09:38,839 --> 00:09:42,870
here's a bunch of apps instead that's
sort of how awesome insecurities design

137
00:09:42,870 --> 00:09:46,620
but who's to say we can't modify the
memory controller hub I can we just go

138
00:09:46,620 --> 00:09:49,820
around this and we're ringing 0 code
after all we should be able to set the

139
00:09:49,820 --> 00:09:50,529
stuff up

140
00:09:50,529 --> 00:09:54,430
turns out that there are layers and
layers of protections built around a

141
00:09:54,430 --> 00:09:58,540
sitting room to keep us from ever seeing
what's inside of that memory from ever

142
00:09:58,540 --> 00:10:02,829
modifying system management mode code
we've got ways to configure si se aage

143
00:10:02,829 --> 00:10:03,459
se te

144
00:10:03,459 --> 00:10:07,758
different regions of SNMP that waste to
lock a simmering down and got wasted

145
00:10:07,759 --> 00:10:11,829
locked the locks down we've got ways to
enforce cache coherency on the processor

146
00:10:11,829 --> 00:10:16,329
which got ways of preventing remapping
memory controller hub configuration we

147
00:10:16,329 --> 00:10:21,008
have lakhs and lakhs and lakhs and lakhs
and lakhs on this processor keeping us

148
00:10:21,009 --> 00:10:26,319
out a system management RAM on this
thing is better protected than ring 0 is

149
00:10:26,319 --> 00:10:31,050
and it is a daunting task to try to get
past all of these things so a lot of

150
00:10:31,050 --> 00:10:36,069
these locks some of these latter on the
processor themself itself but most of

151
00:10:36,069 --> 00:10:39,540
these locks existing memory controller
hub so far as how we can get around

152
00:10:39,540 --> 00:10:43,599
these things a lot of really really cool
research going on right now and how to

153
00:10:43,600 --> 00:10:48,480
circumvent these protections in order to
dive into ring minus two code so there's

154
00:10:48,480 --> 00:10:51,769
ways of attacking the fringes of the
memory controller hub of exploiting this

155
00:10:51,769 --> 00:10:55,550
configurations in the firmware and S&M
code so if you're interested in that

156
00:10:55,550 --> 00:10:58,670
kind of thing should check out the
research from like the core and ITIL in

157
00:10:58,670 --> 00:11:02,740
haiti are some really cool stuff going
on here represent something a little bit

158
00:11:02,740 --> 00:11:06,959
different because there is a way to
simultaneously circumvent every single

159
00:11:06,959 --> 00:11:12,579
one of these protections and it's built
into the architecture itself in order to

160
00:11:12,579 --> 00:11:15,089
understand how that works we need to
step back in time and look at something

161
00:11:15,089 --> 00:11:20,329
completely unrelated to system
management mode while back some twenty

162
00:11:20,329 --> 00:11:23,679
years ago we had something called the
local APIC so the local APIC and x86

163
00:11:23,679 --> 00:11:27,499
architecture is in charge of receiving
interrupt events from things happening

164
00:11:27,499 --> 00:11:30,809
on that system and sending those over to
the processor and used to be that the

165
00:11:30,809 --> 00:11:35,110
local APIC was asked physically separate
chip on the chipset that sent things

166
00:11:35,110 --> 00:11:39,459
over the processor but that was sort of
an inefficient designed so 20 some years

167
00:11:39,459 --> 00:11:43,489
ago Intel move the local APIC onto the
processor itself with the local APIC

168
00:11:43,490 --> 00:11:46,920
into the actual silicon at the processor
was using that had a lot of benefits way

169
00:11:46,920 --> 00:11:51,469
more efficient cheaper to manufacture
things this way also opened up a unique

170
00:11:51,470 --> 00:11:55,879
opportunity we no longer have things I O
instructions to communicate with the

171
00:11:55,879 --> 00:12:00,589
local APIC we can now use mio memory
mapped i/o for communicating with the

172
00:12:00,589 --> 00:12:03,610
local a pic which means we can configure
and communicate with the eighth pick way

173
00:12:03,610 --> 00:12:08,360
WAY faster than we ever would've been
able to before so with a key five

174
00:12:08,360 --> 00:12:12,779
generation of micro architectures until
reserved this region of memory this for

175
00:12:12,779 --> 00:12:14,899
killing by region starting at Ste

176
00:12:14,899 --> 00:12:18,199
megabytes and they said whenever you try
to access this region of memory instead

177
00:12:18,199 --> 00:12:21,529
of being sent out of the processor that
memory address is going to be accepted

178
00:12:21,529 --> 00:12:26,680
by the local APIC and you're gonna be
accessing a pic registers instead so for

179
00:12:26,680 --> 00:12:30,660
example let's say you want to quickly
access a pic register 280 what you would

180
00:12:30,660 --> 00:12:34,589
really do is issue what looks like a
memory read instruction accessing 280

181
00:12:34,589 --> 00:12:39,179
offset from FTE megabytes you moved out
into one of your registers so the apex

182
00:12:39,179 --> 00:12:43,929
going to catch that memory access and
then give you back one of its own

183
00:12:43,929 --> 00:12:49,119
registers discuss the problem for Intel
Intel doesn't like to break things when

184
00:12:49,119 --> 00:12:53,470
they release a new processor that makes
sense but this broke something this

185
00:12:53,470 --> 00:12:58,550
model namely there are some old legacy
systems that were already using that

186
00:12:58,550 --> 00:13:01,709
memory range for something else if they
then dropping one of these new

187
00:13:01,709 --> 00:13:05,179
processors that expects that memory
range to go to the apec that's going to

188
00:13:05,179 --> 00:13:09,139
break things so they could fix their
stuff but instead Intel decided to fix

189
00:13:09,139 --> 00:13:14,459
their processors instead so with a PMP
sixth generation of micro architectures

190
00:13:14,459 --> 00:13:18,939
they change things a little bit so if
you take out the 1997 version of the

191
00:13:18,939 --> 00:13:22,709
Intel software developer manual you'll
find this blurb buried in there the

192
00:13:22,709 --> 00:13:25,949
peace extremely processors permit the
starting address of the a pic registers

193
00:13:25,949 --> 00:13:30,609
to be relocated from XLIII megabytes to
another physical address this extension

194
00:13:30,610 --> 00:13:34,249
of the a pic architecture is provided to
help resolve conflicts with the memory

195
00:13:34,249 --> 00:13:39,800
maps of existing systems so it's really
sad to see how that's going to work in

196
00:13:39,800 --> 00:13:45,449
its default configuration da pic accepts
access is within this memory range so if

197
00:13:45,449 --> 00:13:49,748
we were to issue a memory requests
within that memory range to a picnic at

198
00:13:49,749 --> 00:13:53,589
first it's gonna get us back to one of
its registers in this case register 280

199
00:13:53,589 --> 00:13:57,199
on the other hand if we tried to access
something just one megabyte below that

200
00:13:57,199 --> 00:14:00,689
looked similar that's not in da pic
range a picture to look at that and

201
00:14:00,689 --> 00:14:04,040
that's not my range so it's gonna send
that out on the system bus you're

202
00:14:04,040 --> 00:14:10,839
actually in effect RAM or memory instead
but with this new new addition to the p6

203
00:14:10,839 --> 00:14:14,920
generation of micro architectures they
let us move with the a pic is so we can

204
00:14:14,920 --> 00:14:17,819
issue a couple of assembly instructions
and a right

205
00:14:17,819 --> 00:14:23,660
MSR instruction in order to change where
the 80.00 is located so now I just moved

206
00:14:23,660 --> 00:14:27,150
the apex of the FTD megabytes Ste

207
00:14:27,150 --> 00:14:31,439
lights if I should the same exact
instructions now Fe II goes out onto the

208
00:14:31,440 --> 00:14:37,240
system bus in front pages from RAM and
HDD is accepted by the a pic so that we

209
00:14:37,240 --> 00:14:41,810
access in a pic register so seems
trivial it's it's a vestigial featured

210
00:14:41,810 --> 00:14:47,060
fix some things that occurred along time
ago largely been forgotten nobody really

211
00:14:47,060 --> 00:14:52,170
uses it anymore in fact software manuals
almost universally assumed that the a

212
00:14:52,170 --> 00:14:52,760
picture

213
00:14:52,760 --> 00:14:57,740
located at SCE megabytes it's it's
really just a forgotten patch to fix a

214
00:14:57,740 --> 00:15:02,550
forgotten problem on some tiny number of
legacy systems some twenty years ago but

215
00:15:02,550 --> 00:15:07,189
incidentally this opens up an incredible
vulnerability on an entirely unrelated

216
00:15:07,190 --> 00:15:13,160
piece of the processor today so we can
actually use this relocatable a text

217
00:15:13,160 --> 00:15:18,770
feature from twenty years ago to attack
modern system management mode code and

218
00:15:18,770 --> 00:15:22,060
here's how we would do that if we look
at the standard configuration for the

219
00:15:22,060 --> 00:15:27,790
processor for sitting in room 0 we try
to read something out of ASM RAM that

220
00:15:27,790 --> 00:15:30,949
address is going to be sent out to the
memory controller hub memory controller

221
00:15:30,950 --> 00:15:34,620
hub gonna say you're not an S&M you
can't access i said im gonna give us

222
00:15:34,620 --> 00:15:38,710
back a bunch of apps can't do anything
until then if we did it at that exact

223
00:15:38,710 --> 00:15:41,730
same thing from SMS that address is
going to be some type of memory

224
00:15:41,730 --> 00:15:44,940
controller how that's going to allow us
to access memory I'm gonna give us back

225
00:15:44,940 --> 00:15:48,160
in actual value in that situation

226
00:15:48,160 --> 00:15:53,870
30 code and we moved the a pic we put
the a picture that it overlapped yes

227
00:15:53,870 --> 00:15:58,760
NVRAM region instead of a sudden we've
changed the view of our memory so from

228
00:15:58,760 --> 00:16:01,620
rings here we show that exact same
instruction that we just tried to issue

229
00:16:01,620 --> 00:16:05,630
before we got back a bunch of BS now
that address never makes it out of the

230
00:16:05,630 --> 00:16:09,689
processor da pic except that address now
and it gives us back one of its

231
00:16:09,690 --> 00:16:12,750
registers instead it's a really
interesting doesn't matter if we can

232
00:16:12,750 --> 00:16:17,380
modify our view of memory and ring 0 the
interesting part is this allows us to

233
00:16:17,380 --> 00:16:24,330
modify SMMC view of memory so now as a
man tries to value from Sen RAM instead

234
00:16:24,330 --> 00:16:28,300
of getting what it actually expected to
see the apex going to grab that memory

235
00:16:28,300 --> 00:16:33,849
access and give us back our register
instead so the nth in this situation

236
00:16:33,850 --> 00:16:38,290
never actually received the memory
request meaning of the primary enforcer

237
00:16:38,290 --> 00:16:40,480
of rain minus two security has just been

238
00:16:40,480 --> 00:16:45,760
removed from the picture through this
legacy a pic based feature 10 can

239
00:16:45,760 --> 00:16:51,120
manipulate me a pic il mio range and
intercept bring negative to accesses to

240
00:16:51,120 --> 00:16:56,980
ram so how can we actually use this to
attack 3-2 from ring 0 and try to

241
00:16:56,980 --> 00:16:58,639
infiltrate this most privileged

242
00:16:58,639 --> 00:17:04,030
execution on the processor while the
concept is that as a result of access as

243
00:17:04,030 --> 00:17:08,760
a safe haven for ASM code it's where
estimate lives is an SMS RAM as long as

244
00:17:08,760 --> 00:17:13,290
ASM code stays inside of a summer and we
can never see it from 10 can't touch it

245
00:17:13,290 --> 00:17:17,928
we can't modify it in any way but if we
could get a cement to step outside of

246
00:17:17,929 --> 00:17:22,620
its hiding spot if we could get it to
leave and go into normal memory then we

247
00:17:22,619 --> 00:17:27,780
could hijack its execution and gain a
cement privileges for ourselves so first

248
00:17:27,780 --> 00:17:32,620
version of this attack is really pretty
straight forward to move the a pic

249
00:17:32,620 --> 00:17:36,939
overestimate am let the system switch
over to system management mode it's

250
00:17:36,940 --> 00:17:39,830
going to fault because its breeding a
bunch of data that it didn't expect to

251
00:17:39,830 --> 00:17:44,360
have there and win at fault it's going
to try to figure out how to handle that

252
00:17:44,360 --> 00:17:46,928
exception is going to look up an
exception handler and interrupt

253
00:17:46,929 --> 00:17:50,970
descriptor table and that handlers under
our control our handlers and going to

254
00:17:50,970 --> 00:17:54,590
execute with us in that context so
pretty simple idea for an attack and

255
00:17:54,590 --> 00:17:57,199
fortunately it fails there's an
undocumented security feature on these

256
00:17:57,200 --> 00:18:01,080
processors when this process which is
over to system management mode zeros out

257
00:18:01,080 --> 00:18:04,970
the ADTR limit field effectively
disabling interrupt handling when that

258
00:18:04,970 --> 00:18:08,470
happens if you trigger an exception and
system management mode the system does

259
00:18:08,470 --> 00:18:12,950
what he called triple faulting
essentially a reset of the system so we

260
00:18:12,950 --> 00:18:17,169
tried this attack from 10 we can triple
fault the system and system management

261
00:18:17,169 --> 00:18:21,350
mode but what good does it do is to
simply reset the system from rig 0 we

262
00:18:21,350 --> 00:18:25,678
could have done that anyways gotta find
a much much more elaborate version of

263
00:18:25,679 --> 00:18:29,080
this attack so here's what we're going
to do instead we're gonna literally that

264
00:18:29,080 --> 00:18:33,340
a pic mio range at the SMI entry points
on the system for switches over to

265
00:18:33,340 --> 00:18:36,590
system management mode the very first
thing it tries to execute wanna put the

266
00:18:36,590 --> 00:18:41,129
a pic right over that location then
we're gonna load up are a pic with a

267
00:18:41,130 --> 00:18:44,320
payload that we want the processor to be
executing inside a system management

268
00:18:44,320 --> 00:18:47,210
mode we're going to trigger an SMI
system management and up to switch the

269
00:18:47,210 --> 00:18:51,580
system over the system management mode
allows to hijack execution when SMN

270
00:18:51,580 --> 00:18:53,299
begins executing our payload

271
00:18:53,299 --> 00:18:57,080
out of the a pic to look something like
this in normal situation when a

272
00:18:57,080 --> 00:19:01,269
processor receives a system management
interrupt it tries to touch the first

273
00:19:01,269 --> 00:19:05,759
systematic about instruction from a
fixed address it since that address out

274
00:19:05,759 --> 00:19:09,649
to the MCH DMCA territories that
instruction from SA RAM is it back to

275
00:19:09,649 --> 00:19:14,350
the processor to execute simple enough
but if it rains 0 we decided to move me

276
00:19:14,350 --> 00:19:19,129
a pic of range so did exactly overlapped
the SMI entry point we've also all the

277
00:19:19,129 --> 00:19:22,178
sudden taking control of which
instructions to process going to be

278
00:19:22,179 --> 00:19:26,220
affection when it switches to system
management mode 240 then we can trigger

279
00:19:26,220 --> 00:19:30,460
an SMI by writing to the key to ports
responded transition the processor

280
00:19:30,460 --> 00:19:34,450
system management mode only now when it
tries to fetch the 1st SEM instruction

281
00:19:34,450 --> 00:19:40,029
it's going to be a pic registers instead
of that is a similar am so it's gonna

282
00:19:40,029 --> 00:19:42,929
return one of its registered in the
process going try to execute that as if

283
00:19:42,929 --> 00:19:48,019
it was an instruction so we could store
she'll code in a pic registers could

284
00:19:48,019 --> 00:19:52,850
gain control of the processor with an
estimate from those be really really

285
00:19:52,850 --> 00:19:56,299
hard to do the challenges that the
eighth the creditors have to be for

286
00:19:56,299 --> 00:20:00,999
Caroline meaning that we have no real
way and how we place the Saitek memory

287
00:20:00,999 --> 00:20:05,340
when do we have to put it exactly at the
SMI entry point we've got 4096 bytes

288
00:20:05,340 --> 00:20:11,109
available inside the 88 that we can use
for shellcode unfortunately for us i

289
00:20:11,109 --> 00:20:14,649
mean those biter actually writable and
only a few bits of each of those bites

290
00:20:14,649 --> 00:20:19,580
are writable that's not a lot of control
over the shellcode complicating matters

291
00:20:19,580 --> 00:20:24,908
this is actually an invalid instruction
so they begin executing these registers

292
00:20:24,909 --> 00:20:29,269
from the top but when it hits a symbolic
instruction code triple faulting going

293
00:20:29,269 --> 00:20:33,820
to reset the system are tax over at that
point we have control over exactly 17

294
00:20:33,820 --> 00:20:39,799
debts before that happens to our
blackboard registers in this diagram are

295
00:20:39,799 --> 00:20:46,359
largely hardwired 20 so we try to
disassemble 0000 as an assembly

296
00:20:46,359 --> 00:20:49,480
instruction that's just an ad
instruction doesn't do anything you

297
00:20:49,480 --> 00:20:53,179
spoke but it's also not harmful which
means he attacked and continue so this

298
00:20:53,179 --> 00:20:56,669
is what our show code ends up looking
like it's mostly just a bunch of bad

299
00:20:56,669 --> 00:21:00,090
instructions that we have no control
over and every once in a while a couple

300
00:21:00,090 --> 00:21:03,428
of bits that we can actually modify
where we have to try to do something

301
00:21:03,429 --> 00:21:04,500
useful

302
00:21:04,500 --> 00:21:08,050
unfortunately eventually we're going to
hit this region where we can't change it

303
00:21:08,050 --> 00:21:12,840
and that's not a valid instruction it's
going to trigger false and reset the

304
00:21:12,840 --> 00:21:16,189
system we need to make something used
what happened before that occurs so

305
00:21:16,190 --> 00:21:20,220
these are the exact a pic registers we
have control over in this region and

306
00:21:20,220 --> 00:21:23,530
when I say control I mean that word very
loosely because some of these registers

307
00:21:23,530 --> 00:21:27,160
we can't actually did write directly
right to their actually pulled from

308
00:21:27,160 --> 00:21:31,660
other things on the processor and on the
system so getting those register set to

309
00:21:31,660 --> 00:21:35,210
the right value involve setting the
system up to a very specific state

310
00:21:35,210 --> 00:21:37,780
Justice of those are read as the
instruction that we want them to be

311
00:21:37,780 --> 00:21:42,230
turns out this is pretty hard to work
with a few tanker with these registers

312
00:21:42,230 --> 00:21:45,680
for a really really long time try to
make them into something useful

313
00:21:45,680 --> 00:21:49,210
eventually gonna find is that the best
instructions you can possibly get into

314
00:21:49,210 --> 00:21:54,530
these registers do nothing but the bad
instructions 20 don't want to use crash

315
00:21:54,530 --> 00:21:58,379
the system to end up wasting most of
your seventeen bits just trying to keep

316
00:21:58,380 --> 00:22:01,830
the system alive trying to keep it from
resetting when it's executing out of the

317
00:22:01,830 --> 00:22:06,149
a pic but if you that just right you can
get it to not crash by the time it hits

318
00:22:06,150 --> 00:22:09,910
your last bite so that last bite is our
last chance that's a spurious

319
00:22:09,910 --> 00:22:14,010
Enterobacter register inside of the a
pic if you look at the documentation on

320
00:22:14,010 --> 00:22:18,310
this will tell you that the load enabled
8033 are hardwired 2012 high level is

321
00:22:18,310 --> 00:22:21,409
actually write about that means of a
kind of pic and instruction to place

322
00:22:21,410 --> 00:22:26,010
into that register it's got to end and
apps take its US four bits left to try

323
00:22:26,010 --> 00:22:30,300
to take control of most privileged mode
of execution on a processor so we need

324
00:22:30,300 --> 00:22:33,510
to figure out what destruction could we
possibly put into the spurious interrupt

325
00:22:33,510 --> 00:22:37,430
vector to make this thing do something
useful before the system crashes to

326
00:22:37,430 --> 00:22:41,560
consult an opcode map our choices are
pretty slim and we've got prefix bites I

327
00:22:41,560 --> 00:22:45,200
don't do anything some ways of modifying
the stack a bunch of instructions that

328
00:22:45,200 --> 00:22:48,080
shouldn't even exist in this
architecture none of these do anything

329
00:22:48,080 --> 00:22:51,840
for us but all of a sudden right about
when we're out of possible opcodes the

330
00:22:51,840 --> 00:22:56,439
place into that register small miracle
and I read instruction that's her return

331
00:22:56,440 --> 00:23:00,880
from interrupt routine and I reckon
return returnValue off the top of the

332
00:23:00,880 --> 00:23:05,290
stacking jump to that address in a bit
of a way to escape this horrible a pic

333
00:23:05,290 --> 00:23:09,590
and jump to some code that we actually
have reasonable control over by placing

334
00:23:09,590 --> 00:23:12,830
an IRA instruction into that series
interrupt vector registering configuring

335
00:23:12,830 --> 00:23:16,639
the stack to support this I read
instruction we had a dream at the apec

336
00:23:16,640 --> 00:23:21,230
triggered a semi and take control of the
processor so this is what are a pic

337
00:23:21,230 --> 00:23:25,410
payload attack looks like we set up that
I read instruction set up a stack set up

338
00:23:25,410 --> 00:23:30,920
a payload to jump to remap GA Tech and
then trigger an awesome I this is really

339
00:23:30,920 --> 00:23:34,700
really cool as really excited to find
this a lot like a lot of processor and

340
00:23:34,700 --> 00:23:40,330
don't work that was depressing I spent
forty hours debugging the same trying to

341
00:23:40,330 --> 00:23:43,590
figure out why it doesn't work and it
turns out that instruction fetches

342
00:23:43,590 --> 00:23:47,030
actually bypassed the 88 window that's
not the kind of thing they had a

343
00:23:47,030 --> 00:23:51,389
documents nobody was ever supposed to
try to execute code how to be a pic

344
00:23:51,390 --> 00:23:56,310
registers turns out only data fetches
actually hit that window this attack is

345
00:23:56,310 --> 00:24:03,570
as useless at this point just got a
whole whole lot harder so despairing at

346
00:24:03,570 --> 00:24:07,280
this point this is a real vulnerability
I could influence the view of a summary

347
00:24:07,280 --> 00:24:11,490
I'm doing any good if we can't actually
take control of the system but I tried

348
00:24:11,490 --> 00:24:15,180
to reason about inside thinking what we
can text you from the apec we don't have

349
00:24:15,180 --> 00:24:18,890
control of the instructions are going to
take control of SMN through data

350
00:24:18,890 --> 00:24:23,070
accesses alone some of that sort of the
sound like something rather familiar

351
00:24:23,070 --> 00:24:27,929
there's other common situations where we
don't have control over instructions but

352
00:24:27,930 --> 00:24:31,070
we do have control over data which had
to get the system to do something useful

353
00:24:31,070 --> 00:24:35,439
so need to do something like a pic
dropping in order to circumvent this

354
00:24:35,440 --> 00:24:41,390
execution limitations we can do that but
it turned out to be way more difficult

355
00:24:41,390 --> 00:24:45,170
than I imagined because if we fought the
system the system resets the attack is

356
00:24:45,170 --> 00:24:46,360
over

357
00:24:46,360 --> 00:24:50,949
invisible we can even see the thing
we're trying to attack 99.5% of the

358
00:24:50,950 --> 00:24:54,510
eight bits are hardwired 20 we have no
control over the data that we're using

359
00:24:54,510 --> 00:24:59,960
this attack that has to be for Caroline
it's pork a large then it really really

360
00:24:59,960 --> 00:25:04,620
unwieldy so this is more like line
dropping with this enormous unwieldy

361
00:25:04,620 --> 00:25:09,139
payload of zeros but if we're
open-minded we can maybe make this work

362
00:25:09,140 --> 00:25:14,720
so that's a memory single attack that
we're going to see a century from 10 by

363
00:25:14,720 --> 00:25:19,550
moving that a pic weekend sinkhole a
single page of rain minus two memory so

364
00:25:19,550 --> 00:25:23,570
that reads from that memory returns 0
because most of those registers are

365
00:25:23,570 --> 00:25:24,740
wired 20

366
00:25:24,740 --> 00:25:28,440
and rights are completely lost its
registries are hardwired any writer

367
00:25:28,440 --> 00:25:33,960
simply discarded so that's the sinkhole
effect for the CSM attack the challenge

368
00:25:33,960 --> 00:25:37,150
is how to attack code when are only
controls the ability to disable a page

369
00:25:37,150 --> 00:25:41,110
of memory that's not a whole lot of
control but if we use our imagination

370
00:25:41,110 --> 00:25:45,020
maybe we can find some ways to do this
but altman conect to cover as many

371
00:25:45,020 --> 00:25:48,730
systems as we possibly can so in order
to do that we need to understand a

372
00:25:48,730 --> 00:25:53,429
little bit about whereas I'm code comes
from a smoke detector installed by your

373
00:25:53,429 --> 00:25:56,910
system firmware so if you wanna make a
very broad attack we need to understand

374
00:25:56,910 --> 00:26:01,630
the firmware ecosystem a little bit so
former starts with Intel Intel writes

375
00:26:01,630 --> 00:26:05,700
what they called the EFI template code
sort of a skeleton firmware for other

376
00:26:05,700 --> 00:26:09,630
people to adopt run and they get that
template code to the independent bio

377
00:26:09,630 --> 00:26:13,690
spenders di DVDs div these at their own
modifications to the template code and

378
00:26:13,690 --> 00:26:17,960
sell it to the IOM's things like HP and
Dell they had their own modifications to

379
00:26:17,960 --> 00:26:21,590
the template code and then adapted for
each of the individual models of

380
00:26:21,590 --> 00:26:25,689
computers that they sell so you end up
with really really really diverse system

381
00:26:25,690 --> 00:26:30,130
management mode code by the time you get
down to the individual systems to try to

382
00:26:30,130 --> 00:26:35,370
attack that oh yum code stuff they added
but even if you find an exploit in that

383
00:26:35,370 --> 00:26:39,239
code it's really only going to affect
one system if we attack the code that

384
00:26:39,240 --> 00:26:42,340
the idea of these wrote we do a little
bit better but if you really want to

385
00:26:42,340 --> 00:26:45,620
universal attack we have to go after
that template code that code that

386
00:26:45,620 --> 00:26:50,860
everybody is using its hard to attack
but one exploit will allow you to attack

387
00:26:50,860 --> 00:26:56,780
almost any system out there so just so
happens that the EFI template code is

388
00:26:56,780 --> 00:27:00,320
actually responsible for DSM entry
points that's what that entry point

389
00:27:00,320 --> 00:27:05,409
looks like this little bit hard to
decipher if you're not familiar with the

390
00:27:05,410 --> 00:27:10,360
S&M execution environments but this is
the entry point for S&M on nearly every

391
00:27:10,360 --> 00:27:15,050
modern system because it comes from that
template code so execution a cement

392
00:27:15,050 --> 00:27:19,419
starts and what we colloquially called
on real mode and executing from high

393
00:27:19,420 --> 00:27:22,950
memory which as it turns out is a really
really complicated environment to try to

394
00:27:22,950 --> 00:27:27,660
write code for so the very first thing
that this SMN handler tries to do is try

395
00:27:27,660 --> 00:27:30,630
to set up some kind of reasonable
execution environment for the rest of

396
00:27:30,630 --> 00:27:31,860
the S&M code

397
00:27:31,860 --> 00:27:35,240
gonna do that by building up segment
descriptors transitioning the processor

398
00:27:35,240 --> 00:27:39,320
to protected mode in transition the
processor to lawn mowed and pieces of

399
00:27:39,320 --> 00:27:42,740
that of this that are really important
for that process are these little pieces

400
00:27:42,740 --> 00:27:46,420
right here so with a little work we can
reverse engineer this and understand

401
00:27:46,420 --> 00:27:50,970
exactly how it's operating the very
first thing this SMS code is going to

402
00:27:50,970 --> 00:27:54,929
try to do is going to try to set up a
GDT descriptor that's a global

403
00:27:54,929 --> 00:27:57,780
descriptor table which is basically
going to define the memory mappings to

404
00:27:57,780 --> 00:28:02,100
use in the rest of SMN to the first
things it does for setting up the GDT

405
00:28:02,100 --> 00:28:06,520
descriptor it reads the size of the GDT
out of memory and stores that into the

406
00:28:06,520 --> 00:28:11,000
descriptor in a retail location of the
GDT out of memory and stories that can

407
00:28:11,000 --> 00:28:15,419
turn into the descriptor gonna use a
little self modifying code here we've

408
00:28:15,419 --> 00:28:18,820
got an upcoming far jumped up for
jumpers going to transition from sixteen

409
00:28:18,820 --> 00:28:22,840
that protected mode to 32 bit protected
mode getting yourself modifying code to

410
00:28:22,840 --> 00:28:27,428
write out a selector into this far jump
right out to let your time for that and

411
00:28:27,429 --> 00:28:30,960
then some more self modifying coat of
bright out the offset on that it's going

412
00:28:30,960 --> 00:28:35,059
to jump to for this far jump finally we
had to start jump but the first jump

413
00:28:35,059 --> 00:28:39,690
does is it looks at the global
descriptor table looks up its location

414
00:28:39,690 --> 00:28:43,650
in memory and then accesses that global
descriptor table and then moved to

415
00:28:43,650 --> 00:28:47,460
offset 10 in the global descriptor table
to figure out which segment of memory

416
00:28:47,460 --> 00:28:51,669
it's about to be jumping 20 segment two
happens to be at offset 10 inside at

417
00:28:51,669 --> 00:28:55,990
this table it fetches information about
that segment and then jumps to this

418
00:28:55,990 --> 00:29:00,700
offset within that segment so that's how
execution supposed to work if we look at

419
00:29:00,700 --> 00:29:03,799
that go to a little bit more deaths what
you're going to find is that all of that

420
00:29:03,799 --> 00:29:07,280
information that it loaded out of memory
is being read from one large structure

421
00:29:07,280 --> 00:29:11,210
called the DSC structure the template
awesome in Hamburg uses this single

422
00:29:11,210 --> 00:29:14,919
structure for storing all of its most
critical environment information things

423
00:29:14,919 --> 00:29:17,080
like the global descriptor table
information the segment selector

424
00:29:17,080 --> 00:29:20,620
information the memory mapping that it's
going to use outside a system management

425
00:29:20,620 --> 00:29:25,459
mode are all stored inside of this one
structure to sing calling this structure

426
00:29:25,460 --> 00:29:29,530
that has all the most important
information for S&M would be devastating

427
00:29:29,530 --> 00:29:34,428
for the processor so I figured let's see
what happens when we do that so from 10

428
00:29:34,429 --> 00:29:39,000
we try to sync all that DSC structure by
moving the eighth pick over its location

429
00:29:39,000 --> 00:29:40,910
in triggering an SMI

430
00:29:40,910 --> 00:29:43,640
transition to system to system
management mode

431
00:29:43,640 --> 00:29:48,750
we can watch what exactly happens on the
system we don't have control over the

432
00:29:48,750 --> 00:29:51,520
processor anymore at that point which
the system management mode and then it's

433
00:29:51,520 --> 00:29:52,540
out of our hands

434
00:29:52,540 --> 00:29:55,879
any exceptions going to reset the system
but maybe maybe it'll do something

435
00:29:55,880 --> 00:30:01,120
that'll let us hijack execution before
it resets so these are pieces of memory

436
00:30:01,120 --> 00:30:04,820
of that same region that we just looked
at these are now the memory accesses

437
00:30:04,820 --> 00:30:08,439
that are going to be seeing cold by our
attack each of these is going to read as

438
00:30:08,440 --> 00:30:12,420
0 out of the eighth pick registers
instead of what it intended to read out

439
00:30:12,420 --> 00:30:15,800
of a summary I'm so when they gonna try
to set up a global descriptor table

440
00:30:15,800 --> 00:30:20,700
descriptor in order to define its memory
mappings the very first thing it's going

441
00:30:20,700 --> 00:30:24,120
to try to do is going to try to load up
the size of that global descriptor table

442
00:30:24,120 --> 00:30:29,810
but it accesses memory sinkhole reading
a zero for the size that would kill our

443
00:30:29,810 --> 00:30:33,629
attack the right there if you have a
zero size for your descriptor table that

444
00:30:33,630 --> 00:30:36,900
means you have no memory now playing on
the system it's going to triple phone

445
00:30:36,900 --> 00:30:40,540
reset we've got this miraculous
instruction in here that just happens to

446
00:30:40,540 --> 00:30:45,820
save us a detriment that size so instead
of being 0 it becomes FFF the largest

447
00:30:45,820 --> 00:30:49,929
possible descriptor table size we could
possibly have a store that into the

448
00:30:49,930 --> 00:30:54,400
global descriptor table register next
thing they need to figure out is where's

449
00:30:54,400 --> 00:30:57,560
the global descriptor table located
again they read that out of the sinkhole

450
00:30:57,560 --> 00:31:01,879
and then write that into this DDT
descriptor and again it's miscalculated

451
00:31:01,880 --> 00:31:07,060
now as being at address 02 we just
successfully tainted the entire global

452
00:31:07,060 --> 00:31:10,990
descriptor table descriptor that they
constructed here that's going to help us

453
00:31:10,990 --> 00:31:15,020
a lot and some upcoming code this'll
trunks not especially relevant and doing

454
00:31:15,020 --> 00:31:18,170
some more self modifying code for an
upcoming instruction because they're

455
00:31:18,170 --> 00:31:20,680
reading that information out of the
sinkhole the end up corrupting the

456
00:31:20,680 --> 00:31:24,840
upcoming instruction so if we get this
far if we get down here

457
00:31:24,840 --> 00:31:28,010
past this jump the system's going to
trouble fault because of this corruption

458
00:31:28,010 --> 00:31:30,490
and reset in our attack will be over

459
00:31:30,490 --> 00:31:34,220
fortunately we never make it that far so
once again they do some self modifying

460
00:31:34,220 --> 00:31:38,110
code they write out that select your 10
into the upcoming far jump they tried to

461
00:31:38,110 --> 00:31:42,090
set up the offset to use for that far
jumped at twenty miscalculated again

462
00:31:42,090 --> 00:31:45,949
because of the sinkhole so we managed to
take that far jumped out at you as well

463
00:31:45,950 --> 00:31:48,560
so when it hits the fire jumped now it's
going to try to figure out where the

464
00:31:48,560 --> 00:31:52,080
global descriptor table located what
memory mapping using what segment of

465
00:31:52,080 --> 00:31:55,949
memory am I going to so it's going to
fetch the global descriptor table from

466
00:31:55,950 --> 00:31:56,679
address

467
00:31:56,679 --> 00:32:00,710
I just heroes now outside of SNR and
that's something we have control over

468
00:32:00,710 --> 00:32:05,970
from ring 03 should sexually gotta to
fetch some data that we can actually

469
00:32:05,970 --> 00:32:11,139
influence at this point so to look up a
global descriptor table had addressed 0

470
00:32:11,139 --> 00:32:15,678
gonna move to offset 10 inside of that
table and read a segment selector out of

471
00:32:15,679 --> 00:32:20,749
that offset to the cigarette lighter now
since his energy to that we control is

472
00:32:20,749 --> 00:32:24,389
also selectively control that means we
control which memory mappings it's going

473
00:32:24,389 --> 00:32:27,939
to be using the memory segment it's
about to jump to is now under our

474
00:32:27,940 --> 00:32:28,940
control

475
00:32:28,940 --> 00:32:32,330
it's going to add its offset to that
memory segment base and it's going to

476
00:32:32,330 --> 00:32:36,980
jump to that region so that far jump
costs as mental 02 protected mode memory

477
00:32:36,980 --> 00:32:41,269
mapping from the GDT under our control
and if we were pre-emptively configure a

478
00:32:41,269 --> 00:32:45,639
malicious global descriptor table and
place it right address euro then we

479
00:32:45,639 --> 00:32:49,389
could control exactly where this jumped
about to go we could force it to

480
00:32:49,389 --> 00:32:54,008
jumpstart outside of ASM RAM to code
that we control to hijack the processor

481
00:32:54,009 --> 00:32:59,190
3-2 so this is what our paper looks like
and the situation in this seems a little

482
00:32:59,190 --> 00:33:02,840
bit complex but after preprocessing it
boils down to just these instructions

483
00:33:02,840 --> 00:33:10,379
flushing the cash setting up descriptor
entry in low memory for to use in moving

484
00:33:10,379 --> 00:33:14,389
the a pic registers to sinkhole that DSC
structure and then simply looping in

485
00:33:14,389 --> 00:33:18,129
place simply waiting for periodic SMI to
transition the system to system

486
00:33:18,129 --> 00:33:22,110
management mode so that we can take
control of the processor when we do that

487
00:33:22,110 --> 00:33:26,850
we fired at the end the process
certainly wait and it worked this time

488
00:33:26,850 --> 00:33:30,658
around so I was extremely ecstatic to
see that this thing work because with

489
00:33:30,659 --> 00:33:35,259
eight lines of code we're down to six
successfully exploited a huge number of

490
00:33:35,259 --> 00:33:38,669
features on this process we explain
hardware remapping descriptor cache

491
00:33:38,669 --> 00:33:42,340
configurations instruction data cache
properties to process gonna go through

492
00:33:42,340 --> 00:33:46,080
for execution modes in four different
memory models before it actually hits

493
00:33:46,080 --> 00:33:50,029
that far jump that we tainted and jumps
to code under our control so that we can

494
00:33:50,029 --> 00:33:53,649
successfully infiltrated the most
privileged mode of execution on the x86

495
00:33:53,649 --> 00:33:58,518
processor the coolest thing about this
whole thing is that that template a semi

496
00:33:58,519 --> 00:34:02,369
himmler had no vulnerability and it
there's absolutely nothing wrong with

497
00:34:02,369 --> 00:34:05,619
that code we managed to attack it
through this law and the x86

498
00:34:05,619 --> 00:34:09,348
architecture like I mentioned earlier
this opens up an entirely new class of

499
00:34:09,349 --> 00:34:10,149
exploits

500
00:34:10,149 --> 00:34:13,308
against ring minus two we can start
looking for other things that would

501
00:34:13,309 --> 00:34:16,919
apply the sinkhole against so for
example this is the firmware that I

502
00:34:16,918 --> 00:34:20,828
pulled off the MacBook that I've got up
here for this demonstration this is how

503
00:34:20,829 --> 00:34:24,889
the Mac handles interrupts in system
management mode they have this table a

504
00:34:24,889 --> 00:34:28,589
function pointers over here and they're
gonna ask all instruction to call into

505
00:34:28,589 --> 00:34:31,710
one of these function pointers if you
were to sink oldest able to function

506
00:34:31,710 --> 00:34:35,770
pointers that call instructions going to
fetch a zero as the address that it's

507
00:34:35,770 --> 00:34:40,270
supposed to branch to forcing him to
jump outside Sen RAM to where we can I

508
00:34:40,270 --> 00:34:45,589
jacket alternatively yes ma'am stack is
another fantastic place to apply the

509
00:34:45,589 --> 00:34:50,179
sinkhole imposes going to try to set up
a stack to use when executing inside a

510
00:34:50,179 --> 00:34:54,500
system management mode so if we were to
apply the sinkhole over the stack then

511
00:34:54,500 --> 00:34:59,660
every call instruction is going to try
to push a return address on of the staff

512
00:34:59,660 --> 00:35:02,660
that return address is going to get
consumed by the sinkhole and just

513
00:35:02,660 --> 00:35:07,078
completely lost but when it issues a
return instruction it going to try to

514
00:35:07,079 --> 00:35:10,799
pop a return address often to stack its
going to reach a zero out of the

515
00:35:10,799 --> 00:35:15,770
sinkhole and branch to address 0 under
our control so there's just a tremendous

516
00:35:15,770 --> 00:35:20,329
number of things we can apply this to
it's really whatever you can imagine the

517
00:35:20,329 --> 00:35:23,869
question is how do we actually do with
this capability ok we've got reminders

518
00:35:23,869 --> 00:35:28,589
to control how to use that we can unlock
hardware that wasn't available to us and

519
00:35:28,589 --> 00:35:32,069
ring 0 we can disable the cryptographic
checksum the system with a break the

520
00:35:32,069 --> 00:35:35,599
system if we wanted to some system and
remote is in charge of thermoregulation

521
00:35:35,599 --> 00:35:38,250
on many systems we could just catch fire

522
00:35:38,250 --> 00:35:43,010
we can open the lockbox on the system or
we can just install a really really

523
00:35:43,010 --> 00:35:48,799
nasty rootkits that's the route I took
the normal demonstration for when you

524
00:35:48,799 --> 00:35:53,420
game system management no taxes on the
system is simply brick the system and

525
00:35:53,420 --> 00:35:56,470
it's really cool demonstration but it's
not necessarily the most practical

526
00:35:56,470 --> 00:36:00,439
attack that out of the way way more
interesting to actually install a system

527
00:36:00,440 --> 00:36:04,890
management mode rootkit using the memory
sinkhole attack on such what we do here

528
00:36:04,890 --> 00:36:09,460
we deploy to get through the memory
sinkhole once to root it has control and

529
00:36:09,460 --> 00:36:13,390
system management Moda music preempt
hypervisor can periodically intercept

530
00:36:13,390 --> 00:36:18,200
ring 0 Cody can filter rings your lyle
excesses and modify any memory on that

531
00:36:18,200 --> 00:36:22,319
system can escalate process privilege
levels it you can do all of this

532
00:36:22,319 --> 00:36:23,390
completely invisible

533
00:36:23,390 --> 00:36:28,480
operating system to run 02 antivirus
technology into the hypervisor a rootkit

534
00:36:28,480 --> 00:36:33,269
at this point once it's placed NSM RAM
is entirely undetectable on that system

535
00:36:33,269 --> 00:36:40,558
so for this demonstration I had together
some code created by this guy crash who

536
00:36:40,559 --> 00:36:44,760
made a really really cool for robust as
a memory kits are adopted us some of his

537
00:36:44,760 --> 00:36:49,029
code for this demonstration what we do
is we signal that rootkit by some magic

538
00:36:49,029 --> 00:36:54,829
64 bit number in user land when the kid
sees at Magic City 64 bit number it

539
00:36:54,829 --> 00:36:58,510
knows that some processes secretly
requesting to be escalated into

540
00:36:58,510 --> 00:37:02,990
privileges so yes memory kit then parses
that process page tables locate the

541
00:37:02,990 --> 00:37:08,529
process credentials he gets it rude
access to the system so we revisit the

542
00:37:08,529 --> 00:37:16,809
attack that we illustrated early on the
way this really worked we had this

543
00:37:16,809 --> 00:37:22,079
attack driver code the attack drivers
which in charge of using the memory

544
00:37:22,079 --> 00:37:26,150
sinkhole exploit in order to actually
install a rootkit out of the processor

545
00:37:26,150 --> 00:37:30,230
so the attack drivers actually not too
complex simply must also hoping to low

546
00:37:30,230 --> 00:37:34,299
memory that's what I sometimes
accidentally going to branch two copies

547
00:37:34,299 --> 00:37:39,339
actual rootkit that we want to use into
memory on for later reference has some

548
00:37:39,339 --> 00:37:42,900
inline assembly here to actually apply
the sinkhole attacks on this specific

549
00:37:42,900 --> 00:37:47,549
situation I was tinkering with using the
same kollek attack against the S&M

550
00:37:47,549 --> 00:37:52,190
stacks we sinkhole their status forcing
them to branch to address the euro will

551
00:37:52,190 --> 00:37:57,210
take control and install the rootkit
into system management RAM I rooted

552
00:37:57,210 --> 00:38:01,329
itself like I said a doctor from crashes
source code also not especially

553
00:38:01,329 --> 00:38:06,230
complicated I'm always going to be doing
is reading a couple of register values

554
00:38:06,230 --> 00:38:08,839
that have what's called the state saving
that basically it's going to look at

555
00:38:08,839 --> 00:38:15,599
what process it interrupted and if it
sees these magic magic 64 bit values in

556
00:38:15,599 --> 00:38:19,099
those registers didn't know that a
process is secretly requesting privilege

557
00:38:19,099 --> 00:38:23,079
escalation of costs of privilege
escalation function for that process

558
00:38:23,079 --> 00:38:27,349
privilege escalation function profit
versus that processes page tables

559
00:38:27,349 --> 00:38:30,339
located credentials and assigns it

560
00:38:30,339 --> 00:38:33,070
root privileges here

561
00:38:33,070 --> 00:38:39,630
going back to the actual escalation
attack when we run the escalation attack

562
00:38:39,630 --> 00:38:43,720
all is really doing is loading those
couple of 32 bit values into the

563
00:38:43,720 --> 00:38:49,629
registers to signal to the rootkit
running on the system el Frio remember

564
00:38:49,630 --> 00:38:57,780
to actually install the rootkit we were
up one run a single strict script driver

565
00:38:57,780 --> 00:39:00,610
to install a rootkit and system
management mode where can no longer be

566
00:39:00,610 --> 00:39:14,550
seen so that now we run our escalate
process we gain access to Route so the

567
00:39:14,550 --> 00:39:19,660
impact of this is fairly large we
simultaneously just circumvented every

568
00:39:19,660 --> 00:39:23,830
single ring minus two protection in
place on this processor and medications

569
00:39:23,830 --> 00:39:26,420
don't look great

570
00:39:26,420 --> 00:39:30,720
firmware update to fix this kind of
thing maybe movie a pic back to the

571
00:39:30,720 --> 00:39:34,180
proper location inside of the system
management mode code you can try that

572
00:39:34,180 --> 00:39:38,330
the problem is by the time are able to
do that you have probably already been

573
00:39:38,330 --> 00:39:42,279
sinkhole by the attack so does it really
work very well could you microcode

574
00:39:42,280 --> 00:39:46,290
update probably not on this is too
deeply ingrained in the process it's not

575
00:39:46,290 --> 00:39:51,320
something you can easily reconfigure
really this is untouchable the only real

576
00:39:51,320 --> 00:39:55,680
mitigation to this attack is to build
new processors unfortunately for me

577
00:39:55,680 --> 00:40:00,330
that's exactly what Intel did somebody
at Intel discovered this shortly before

578
00:40:00,330 --> 00:40:03,950
I did this problem is fixed on their
latest generations of processors

579
00:40:03,950 --> 00:40:08,500
starting with Sandy Bridge and Adam 2013
processors what they have some

580
00:40:08,500 --> 00:40:11,280
undocumented internal checks against
what he called the system management

581
00:40:11,280 --> 00:40:14,790
range registers when you try to relocate
the a pic and if you try to put the

582
00:40:14,790 --> 00:40:18,460
apical over SMU am there want to block
that from happening

583
00:40:18,460 --> 00:40:22,790
the good news from attackers perspective
is that still requires the SMR are to be

584
00:40:22,790 --> 00:40:28,050
properly configured which an alarming
number of systems are still not doing as

585
00:40:28,050 --> 00:40:32,410
far as AMD goes haven't had enough time
to thoroughly research and Dion still

586
00:40:32,410 --> 00:40:37,080
analyzing that now keep people posted on
what I find as far as I'm concerned when

587
00:40:37,080 --> 00:40:40,779
I can tell you for now his and he
doesn't have these SMR our registers

588
00:40:40,780 --> 00:40:44,410
they'd never needed them for the same
reason that in tilted so this fix

589
00:40:44,410 --> 00:40:49,279
on Intel processors won't work on AMD
processors on top of that AMD tends to

590
00:40:49,280 --> 00:40:52,830
document their stuff really really well
which is actually incredibly helpful

591
00:40:52,830 --> 00:40:56,450
from attackers point of view so he
actually has buried in their developer

592
00:40:56,450 --> 00:41:00,879
manuals a blurb stating that the a pic
window takes precedence over the S and

593
00:41:00,880 --> 00:41:06,130
RAM window me at the apec attack should
work on Andy processors and I don't know

594
00:41:06,130 --> 00:41:10,460
for certain but I suspect these are very
vulnerable to this attack but these

595
00:41:10,460 --> 00:41:15,450
medications only work if every single
one of these other security mechanisms

596
00:41:15,450 --> 00:41:19,069
is properly configured and even when
that's the case there are hundreds of

597
00:41:19,070 --> 00:41:23,680
millions of process out there right now
in which this can't be fixed so I'm

598
00:41:23,680 --> 00:41:26,930
working on getting a CT number from this
if you're interested in Intel's

599
00:41:26,930 --> 00:41:31,390
perspective on a problem and what
they're doing to mitigate the issue you

600
00:41:31,390 --> 00:41:34,339
can go to Intel dot com slash security
there right up right now so I

601
00:41:34,340 --> 00:41:37,820
coordinated this disclosure with Intel I
gotta tell you they have been fantastic

602
00:41:37,820 --> 00:41:42,100
to work with they were really interested
in keeping your processor secure they

603
00:41:42,100 --> 00:41:45,279
instantly started work now mitigations
wherever was architecture only feasible

604
00:41:45,280 --> 00:41:49,420
they're working on their most recently
vulnerable processors and working their

605
00:41:49,420 --> 00:41:52,540
way back where it will take a little bit
of time for their updates to trickle

606
00:41:52,540 --> 00:41:57,560
down so in the meantime just be careful
looking forward to future of this attack

607
00:41:57,560 --> 00:42:00,799
as far as I know the special only the
second architectural privilege

608
00:42:00,800 --> 00:42:05,360
escalation vulnerability on the x86
processor and that's behind the original

609
00:42:05,360 --> 00:42:10,840
cache poisoning attack discovered by the
flight invisible things a couple of

610
00:42:10,840 --> 00:42:15,000
years back so they've been exploits
against the chipset configuration

611
00:42:15,000 --> 00:42:20,790
vulnerabilities in the firmware and
software even had dear AM corruption

612
00:42:20,790 --> 00:42:25,009
errors but the process itself has
actually been surprisingly resilient to

613
00:42:25,010 --> 00:42:28,060
attack throughout its long history but
it

614
00:42:28,060 --> 00:42:33,610
x86 is an immensely complex architecture
with forty years of evolution behind it

615
00:42:33,610 --> 00:42:36,830
so I think what we're gonna keep on
finding is that there are a multitude of

616
00:42:36,830 --> 00:42:41,080
pieces that are individually secure but
maybe collectively vulnerable as was

617
00:42:41,080 --> 00:42:46,640
this case where a man was secure on the
apical insecure about when you combine

618
00:42:46,640 --> 00:42:50,200
those two things I meant introduced an
interesting vulnerability so I really

619
00:42:50,200 --> 00:42:53,419
think we're just beginning to scratch
the surface in terms of the style of

620
00:42:53,420 --> 00:42:57,780
attacks so a lot of people went into
helping this work either directly or

621
00:42:57,780 --> 00:43:02,020
directly so want to make sure to
acknowledge my coworker Scott fantastic

622
00:43:02,020 --> 00:43:06,870
researchers in this field on the teams
that Intel and crashed you created that

623
00:43:06,870 --> 00:43:11,730
S&M rootkit which I was able to deploy
with this attack interested in looking

624
00:43:11,730 --> 00:43:15,360
at some proof of concept Coach Madison a
little bit more depth to check out on my

625
00:43:15,360 --> 00:43:20,760
get home page you can also follow me on
Twitter for more updates on a stack as I

626
00:43:20,760 --> 00:43:25,360
do more research at sex or EAX EAX EAX
or you can email me at the same address

627
00:43:25,360 --> 00:43:30,720
I've got a few minutes left so I want to
diverge a little bit and talk about side

628
00:43:30,720 --> 00:43:36,000
project of mine since I'm at black hat
and I'm talking about weird x86 things I

629
00:43:36,000 --> 00:43:41,460
also thought to be a good opportunity to
release another weird x86 project I've

630
00:43:41,460 --> 00:43:45,500
been working on so if you saw me speak
at recon a couple months ago I talked

631
00:43:45,500 --> 00:43:50,350
about this weird x86 back in that the
move instruction is itself Turing

632
00:43:50,350 --> 00:43:54,140
complete so what that meant from our
perspective is that you could write

633
00:43:54,140 --> 00:43:58,640
entire programs using only the move
instruction which was really cool as a

634
00:43:58,640 --> 00:44:02,670
proof of concept for that I made this
compiler that compiled code from this

635
00:44:02,670 --> 00:44:07,380
really really awful language called
brain into only move instructions to

636
00:44:07,380 --> 00:44:12,690
actually remove only programs which was
neat but writing code like this isn't

637
00:44:12,690 --> 00:44:17,410
the most practical thing in the world so
I have promised and alteration today

638
00:44:17,410 --> 00:44:22,740
compiler so today in the next hour to
check out to get her page I'll post what

639
00:44:22,740 --> 00:44:27,750
i think is the world's first single
instruction C compiler so it's got a

640
00:44:27,750 --> 00:44:32,060
little after you download the source
code to help you build everything and

641
00:44:32,060 --> 00:44:35,080
then how to actually run through the
sissy how the single instruction C

642
00:44:35,080 --> 00:44:39,860
compiler actually works like all the
same obfuscator when you do a date clone

643
00:44:39,860 --> 00:44:42,520
you'll get this check script it's going
to download an open source

644
00:44:42,520 --> 00:44:46,509
implementation of the AES algorithm it's
going to compile it with the Mafia

645
00:44:46,510 --> 00:44:50,360
skater and dumped out the assembly
results so what you see is just

646
00:44:50,360 --> 00:44:55,100
absolutely monstrous number of
unconditional move instructions used to

647
00:44:55,100 --> 00:44:58,740
implement the C program in sometime
today this is actually gonna finish

648
00:44:58,740 --> 00:45:03,629
something out when it does we'll be able
to actually see this program run and run

649
00:45:03,630 --> 00:45:08,230
the program exactly as you would expect
it to run so this was sort of an

650
00:45:08,230 --> 00:45:10,150
exercise are thought experiments

651
00:45:10,150 --> 00:45:14,029
and anti reverse engineering or code
obfuscation but mostly I just thought it

652
00:45:14,029 --> 00:45:17,869
was funny so when it's done it's
actually run this program and it'll do

653
00:45:17,869 --> 00:45:22,630
all of a yes using only move
instructions so I think it's really cool

654
00:45:22,630 --> 00:45:26,099
kinda neat tool I would love to get some
feedback on it so I love it if people

655
00:45:26,099 --> 00:45:30,680
are interested in checking that out so
if you're interested in weird x86 things

656
00:45:30,680 --> 00:45:32,960
are we talking a little bit more about
that

657
00:45:32,960 --> 00:45:38,859
DEFCON but more importantly at DEFCON I
wanted to illustrate another side

658
00:45:38,859 --> 00:45:44,190
project I've been working on a way of
manipulating control flow graphs and

659
00:45:44,190 --> 00:45:48,049
assembly code by manipulating your
control flow graph very carefully I

660
00:45:48,049 --> 00:45:52,410
found that you did you really
groundbreaking revolutionary things like

661
00:45:52,410 --> 00:46:00,558
take a healthy and I so far only some
source code for doing that to check that

662
00:46:00,559 --> 00:46:08,849
out a test on if you're more interested
in practical things every single is

663
00:46:08,849 --> 00:46:12,309
practical and you can find out the
source and get how the soon as I posted

664
00:46:12,309 --> 00:46:15,619
in about an hour they appreciate
everyone's time today I think I'm out of

665
00:46:15,619 --> 00:46:21,730
time for questions although I'm not sure
about that but if anyone wanted to talk

666
00:46:21,730 --> 00:46:22,789
to me about this

667
00:46:22,789 --> 00:46:26,119
offline outlook to answer any questions
or discuss this further so thank you

668
00:46:26,119 --> 00:46:26,279
again

