1
00:00:00,000 --> 00:00:04,380
so hello my name is Travis<font color="#CCCCCC"> Ormandy this</font>

2
00:00:02,370 --> 00:00:06,210
is Julie antennas where where

3
00:00:04,380 --> 00:00:09,269
information<font color="#E5E5E5"> security engineers on</font><font color="#CCCCCC"> the</font>

4
00:00:06,210 --> 00:00:10,650
Google security team and yeah talk is

5
00:00:09,269 --> 00:00:16,109
called there's a party at ring 0 and

6
00:00:10,650 --> 00:00:17,580
<font color="#E5E5E5">you're invited so all systems make</font>

7
00:00:16,109 --> 00:00:20,550
assumptions about Colonel security and

8
00:00:17,580 --> 00:00:22,919
in fact in the entire<font color="#CCCCCC"> scheme bottle of</font>

9
00:00:20,550 --> 00:00:24,420
some systems can be based on the

10
00:00:22,920 --> 00:00:28,109
security banjee provided by the colonel

11
00:00:24,420 --> 00:00:32,160
things like Sam boxing in google chrome

12
00:00:28,109 --> 00:00:34,530
and and an<font color="#CCCCCC"> android make make Google in</font>

13
00:00:32,159 --> 00:00:38,218
particular in particular dependent on

14
00:00:34,530 --> 00:00:40,050
Colonel security and of course<font color="#CCCCCC"> this is</font>

15
00:00:38,219 --> 00:00:43,079
true for lots of other<font color="#CCCCCC"> applications on</font>

16
00:00:40,050 --> 00:00:44,910
other platforms so we've<font color="#E5E5E5"> been involved</font>

17
00:00:43,079 --> 00:00:46,829
<font color="#CCCCCC">in finding fixing and mitigating some</font>

18
00:00:44,910 --> 00:00:49,050
really interesting killer bugs over the

19
00:00:46,829 --> 00:00:51,899
last<font color="#E5E5E5"> year and I'm looking to share some</font>

20
00:00:49,050 --> 00:00:54,718
of our work today so we can discuss<font color="#CCCCCC"> them</font>

21
00:00:51,899 --> 00:00:55,949
the ways that that you can<font color="#E5E5E5"> protect the</font>

22
00:00:54,719 --> 00:00:57,809
colonel<font color="#E5E5E5"> from malicious user</font><font color="#CCCCCC"> line code</font>

23
00:00:55,949 --> 00:01:01,620
and mitigate unknown<font color="#CCCCCC"> clever burner</font>

24
00:00:57,809 --> 00:01:06,600
abilities that in in the kernel itself

25
00:01:01,620 --> 00:01:10,770
so the first<font color="#E5E5E5"> section</font><font color="#CCCCCC"> of our talk is</font>

26
00:01:06,600 --> 00:01:12,330
called<font color="#CCCCCC"> the colonel is</font><font color="#E5E5E5"> a target so</font>

27
00:01:10,770 --> 00:01:15,030
imagine<font color="#CCCCCC"> you have arbitrary code</font>

28
00:01:12,330 --> 00:01:18,030
execution on a machine and if you want

29
00:01:15,030 --> 00:01:19,830
<font color="#E5E5E5">to escalate or just merely switch your</font>

30
00:01:18,030 --> 00:01:22,530
privileges because it's not necessarily

31
00:01:19,830 --> 00:01:25,170
<font color="#E5E5E5">an escalation you might want to get the</font>

32
00:01:22,530 --> 00:01:28,229
privileges of just another user what can

33
00:01:25,170 --> 00:01:30,119
you target you<font color="#E5E5E5"> can target in general</font>

34
00:01:28,229 --> 00:01:32,460
processes with more or different

35
00:01:30,119 --> 00:01:34,860
privileges so for instance running

36
00:01:32,460 --> 00:01:37,559
demons<font color="#CCCCCC"> situat</font><font color="#E5E5E5"> binaries you can execute</font>

37
00:01:34,860 --> 00:01:40,979
on unix and you can also target the

38
00:01:37,560 --> 00:01:44,159
corner and<font color="#E5E5E5"> the colonel has a lot of nice</font>

39
00:01:40,979 --> 00:01:47,158
properties for you as an attacker for

40
00:01:44,159 --> 00:01:48,960
instance it has a huge<font color="#E5E5E5"> code code base it</font>

41
00:01:47,159 --> 00:01:51,030
performs a lot of complex and

42
00:01:48,960 --> 00:01:53,280
error-prone tasks and it's responsible

43
00:01:51,030 --> 00:01:56,280
<font color="#CCCCCC">for the whole security model of the</font>

44
00:01:53,280 --> 00:02:00,390
system so it's really a primary target

45
00:01:56,280 --> 00:02:02,880
for you the Linux kernel has

46
00:02:00,390 --> 00:02:06,000
has been a local target for over a

47
00:02:02,880 --> 00:02:08,068
decade we've seen we've seen<font color="#E5E5E5"> many</font>

48
00:02:06,000 --> 00:02:10,318
different kinds of bug we've seen memory

49
00:02:08,068 --> 00:02:14,130
and memory management corruption type of

50
00:02:10,318 --> 00:02:18,480
bug which is the first type of<font color="#E5E5E5"> bug</font>

51
00:02:14,130 --> 00:02:21,000
<font color="#E5E5E5">versus logic bugs and the complexity of</font>

52
00:02:18,480 --> 00:02:24,540
a kernel makes for more diverse<font color="#E5E5E5"> and</font>

53
00:02:21,000 --> 00:02:27,930
interesting logic bugs than then in New

54
00:02:24,540 --> 00:02:31,980
Zealand usually we've we've listed here

55
00:02:27,930 --> 00:02:34,709
a few logic bug that we really liked in

56
00:02:31,980 --> 00:02:36,869
particular<font color="#CCCCCC"> the first one I think is a is</font>

57
00:02:34,709 --> 00:02:39,930
a really good<font color="#E5E5E5"> example of things going</font>

58
00:02:36,870 --> 00:02:41,160
<font color="#CCCCCC">wrong so if you want if</font><font color="#E5E5E5"> you want to take</font>

59
00:02:39,930 --> 00:02:45,209
a look<font color="#CCCCCC"> at</font><font color="#E5E5E5"> this they are really</font>

60
00:02:41,160 --> 00:02:48,060
<font color="#E5E5E5">interesting and we've seen</font><font color="#CCCCCC"> within also</font>

61
00:02:45,209 --> 00:02:51,269
memory management corruption bugs and

62
00:02:48,060 --> 00:02:53,250
they also tend to be more interesting

63
00:02:51,269 --> 00:02:56,040
and<font color="#E5E5E5"> diverse than their usual encounter</font>

64
00:02:53,250 --> 00:02:59,820
part where it's almost always the same

65
00:02:56,040 --> 00:03:02,190
this is due to first the complexity of

66
00:02:59,820 --> 00:03:04,260
the memory management because of course

67
00:03:02,190 --> 00:03:06,900
the<font color="#CCCCCC"> the colonel</font><font color="#E5E5E5"> is handling the whole</font>

68
00:03:04,260 --> 00:03:10,470
memory management and it's also due to

69
00:03:06,900 --> 00:03:13,079
<font color="#CCCCCC">an</font><font color="#E5E5E5"> interesting different wording where</font>

70
00:03:10,470 --> 00:03:16,019
the attacker actually finally controls a

71
00:03:13,079 --> 00:03:18,390
full address<font color="#E5E5E5"> space so this this this</font>

72
00:03:16,019 --> 00:03:20,280
allows an attacker<font color="#E5E5E5"> to make way more</font>

73
00:03:18,390 --> 00:03:25,920
complex attacks because he had the

74
00:03:20,280 --> 00:03:28,590
controller whole address face 22 finally

75
00:03:25,920 --> 00:03:31,559
finally exploit any any bugs he might

76
00:03:28,590 --> 00:03:33,630
find on the other hand in<font color="#E5E5E5"> user none</font>

77
00:03:31,560 --> 00:03:36,390
<font color="#E5E5E5">usually if you're trying to exploit a</font>

78
00:03:33,630 --> 00:03:38,579
bug remotely trying trying to get

79
00:03:36,390 --> 00:03:40,828
<font color="#CCCCCC">control over the other dress space by by</font>

80
00:03:38,579 --> 00:03:43,920
by itself is already something some

81
00:03:40,829 --> 00:03:46,860
something quite hard and that's<font color="#E5E5E5"> why you</font>

82
00:03:43,920 --> 00:03:49,048
see things such as<font color="#CCCCCC"> heap</font><font color="#E5E5E5"> spraying and all</font>

83
00:03:46,860 --> 00:03:51,209
<font color="#CCCCCC">this</font><font color="#E5E5E5"> thing there are they are just</font>

84
00:03:49,049 --> 00:03:53,640
giving<font color="#E5E5E5"> you some control over the address</font>

85
00:03:51,209 --> 00:03:56,100
<font color="#E5E5E5">space in this prodding you have full</font>

86
00:03:53,640 --> 00:03:58,559
<font color="#CCCCCC">control so we've also listed a few bug</font>

87
00:03:56,100 --> 00:04:01,260
that we won't detail today that you can

88
00:03:58,560 --> 00:04:04,600
<font color="#E5E5E5">at</font><font color="#CCCCCC"> which you can look if you're</font>

89
00:04:01,260 --> 00:04:06,730
interested we<font color="#CCCCCC"> will just</font><font color="#E5E5E5"> mention today</font>

90
00:04:04,600 --> 00:04:08,920
<font color="#E5E5E5">no or two to use a long pointy our</font>

91
00:04:06,730 --> 00:04:12,910
differences we will mention two of those

92
00:04:08,920 --> 00:04:17,079
<font color="#E5E5E5">today's and give them as example so</font>

93
00:04:12,910 --> 00:04:19,180
escapes for<font color="#CCCCCC"> the colonel and exploiting</font>

94
00:04:17,079 --> 00:04:23,349
the calendar is often the easiest way

95
00:04:19,180 --> 00:04:27,370
<font color="#E5E5E5">out of basically all kind of San boxing</font>

96
00:04:23,350 --> 00:04:29,350
techniques so all school ones such as CH

97
00:04:27,370 --> 00:04:33,070
food gels which have been used<font color="#CCCCCC"> forever</font>

98
00:04:29,350 --> 00:04:36,130
mandatory access control which is which

99
00:04:33,070 --> 00:04:37,960
has been<font color="#E5E5E5"> gaining traction in Linux for</font>

100
00:04:36,130 --> 00:04:40,420
the last<font color="#CCCCCC"> ten years</font><font color="#E5E5E5"> but it still not</font>

101
00:04:37,960 --> 00:04:43,719
really<font color="#E5E5E5"> widely used continuous</font><font color="#CCCCCC"> tight</font>

102
00:04:40,420 --> 00:04:45,730
segregation such as<font color="#CCCCCC"> V</font><font color="#E5E5E5"> server and I'm</font>

103
00:04:43,720 --> 00:04:49,510
only talking about linux right now but

104
00:04:45,730 --> 00:04:52,540
on Windows you see you see the same the

105
00:04:49,510 --> 00:04:55,420
same<font color="#E5E5E5"> thing happening using this for</font>

106
00:04:52,540 --> 00:04:57,670
segregation you still mostly export the

107
00:04:55,420 --> 00:05:00,610
full colonel at extra<font color="#CCCCCC"> phase which is</font>

108
00:04:57,670 --> 00:05:03,370
also why virtualization is a popular

109
00:05:00,610 --> 00:05:06,970
alternative because it gives you a very

110
00:05:03,370 --> 00:05:09,220
<font color="#CCCCCC">very different security because you have</font>

111
00:05:06,970 --> 00:05:12,790
a sanotica<font color="#E5E5E5"> you will have to attack the</font>

112
00:05:09,220 --> 00:05:15,310
virtualization layer instead of just

113
00:05:12,790 --> 00:05:17,890
having to attack a kernel to to get out

114
00:05:15,310 --> 00:05:21,130
of<font color="#CCCCCC"> state for jail or any traditional</font>

115
00:05:17,890 --> 00:05:23,710
sandbox and things such<font color="#E5E5E5"> as mandatory</font>

116
00:05:21,130 --> 00:05:27,340
access control for instance selinux<font color="#E5E5E5"> they</font>

117
00:05:23,710 --> 00:05:29,770
make more sense<font color="#E5E5E5"> if you have a full fully</font>

118
00:05:27,340 --> 00:05:32,650
<font color="#E5E5E5">featured security patch such as gr</font>

119
00:05:29,770 --> 00:05:38,020
security that also tries to protect the

120
00:05:32,650 --> 00:05:40,840
colonel in<font color="#CCCCCC"> Windows the</font><font color="#E5E5E5"> situation has</font>

121
00:05:38,020 --> 00:05:44,890
been different but it's getting more<font color="#E5E5E5"> and</font>

122
00:05:40,840 --> 00:05:47,349
more the same traditionally local kernel

123
00:05:44,890 --> 00:05:49,630
bugs were not considered really relevant

124
00:05:47,350 --> 00:05:52,510
and important on<font color="#E5E5E5"> Windows it has changed</font>

125
00:05:49,630 --> 00:05:55,870
<font color="#E5E5E5">somewhat recently especially since the</font>

126
00:05:52,510 --> 00:05:58,330
introduction of Windows Vista and we can

127
00:05:55,870 --> 00:06:01,510
see an increased reliance on domain

128
00:05:58,330 --> 00:06:04,270
control the use of network services and

129
00:06:01,510 --> 00:06:05,920
features such as protected mode and

130
00:06:04,270 --> 00:06:09,010
integrity levels have been introduced

131
00:06:05,920 --> 00:06:11,980
with Windows Vista so this has changed

132
00:06:09,010 --> 00:06:14,129
<font color="#CCCCCC">in the last few years and no windows is</font>

133
00:06:11,980 --> 00:06:16,860
roughly in the same situation as<font color="#E5E5E5"> Linux</font>

134
00:06:14,129 --> 00:06:18,330
now and people care more and more about

135
00:06:16,860 --> 00:06:23,580
a local private education on this

136
00:06:18,330 --> 00:06:26,459
platform so it's still<font color="#E5E5E5"> it's a bit of the</font>

137
00:06:23,580 --> 00:06:28,498
same that<font color="#E5E5E5"> I've seen no real big complex</font>

138
00:06:26,459 --> 00:06:30,989
min direct access control system on

139
00:06:28,499 --> 00:06:33,599
Windows but that's yeah that because the

140
00:06:30,989 --> 00:06:38,369
difference<font color="#CCCCCC"> now in terms of remotely</font>

141
00:06:33,599 --> 00:06:40,409
exploitable bug bugs on linux they have

142
00:06:38,369 --> 00:06:44,789
been quite rare we have seen a few

143
00:06:40,409 --> 00:06:47,759
notable exceptions around 2004-2005 when

144
00:06:44,789 --> 00:06:49,860
when Wi-Fi was was<font color="#E5E5E5"> getting more and more</font>

145
00:06:47,759 --> 00:06:51,479
used and was<font color="#E5E5E5"> getting into the linux</font>

146
00:06:49,860 --> 00:06:56,009
<font color="#E5E5E5">kernel's we've seen a few</font><font color="#CCCCCC"> remote</font>

147
00:06:51,479 --> 00:07:01,229
exploits by different people but

148
00:06:56,009 --> 00:07:04,499
otherwise there's this rare exception SG

149
00:07:01,229 --> 00:07:07,349
rock you<font color="#E5E5E5"> sctp exploit which has been</font>

150
00:07:04,499 --> 00:07:09,179
released<font color="#CCCCCC"> I think two years ago he has</font>

151
00:07:07,349 --> 00:07:10,529
written a reinter esting article in fact

152
00:07:09,179 --> 00:07:14,399
if you want to check this<font color="#E5E5E5"> out with</font>

153
00:07:10,529 --> 00:07:18,149
twists and a few others<font color="#CCCCCC"> but it's it's</font>

154
00:07:14,399 --> 00:07:21,269
not very common on<font color="#E5E5E5"> Windows it they have</font>

155
00:07:18,149 --> 00:07:23,909
been quite popular for yeah at least six

156
00:07:21,269 --> 00:07:25,979
seven years<font color="#CCCCCC"> I</font><font color="#E5E5E5"> think actually Barnaby</font>

157
00:07:23,909 --> 00:07:29,879
Jack who gave a talk yesterday gave a

158
00:07:25,979 --> 00:07:33,179
talk in 2005 on on on some remote canal

159
00:07:29,879 --> 00:07:36,300
bugs on<font color="#E5E5E5"> Windows and usually the the</font>

160
00:07:33,179 --> 00:07:40,078
target was not<font color="#E5E5E5"> Microsoft code itself but</font>

161
00:07:36,300 --> 00:07:44,279
mostly third-party naive code in

162
00:07:40,079 --> 00:07:47,610
antivirus and personal firewall you've

163
00:07:44,279 --> 00:07:51,719
seen<font color="#CCCCCC"> also a</font><font color="#E5E5E5"> few a few GDI related bug a</font>

164
00:07:47,610 --> 00:07:54,119
very few tcp/ip stack rated ones our

165
00:07:51,719 --> 00:07:56,429
colleague nina mehta and others have fun

166
00:07:54,119 --> 00:07:59,939
<font color="#E5E5E5">one quite recently also</font><font color="#CCCCCC"> you may be</font>

167
00:07:56,429 --> 00:08:02,758
noticed this SMB<font color="#CCCCCC"> v</font><font color="#E5E5E5"> to exploit by</font>

168
00:07:59,939 --> 00:08:07,439
immunity last year which generated some

169
00:08:02,759 --> 00:08:11,159
some buzz and was quite impressive so

170
00:08:07,439 --> 00:08:13,679
those were nice remote colonel bugs but

171
00:08:11,159 --> 00:08:15,089
the web browser are really you what are

172
00:08:13,679 --> 00:08:17,969
changing the game now because

173
00:08:15,089 --> 00:08:20,699
surprisingly they do expose colonel

174
00:08:17,969 --> 00:08:23,750
attacks for face remotely for instance

175
00:08:20,699 --> 00:08:25,820
through GDI and

176
00:08:23,750 --> 00:08:28,100
it's it's something that we've also seen

177
00:08:25,820 --> 00:08:30,469
on Linux for instance there has been a

178
00:08:28,100 --> 00:08:32,900
remotely exploitable bug in nvidia

179
00:08:30,470 --> 00:08:35,360
drivers that you<font color="#E5E5E5"> could actually exploit</font>

180
00:08:32,900 --> 00:08:36,860
through web browser and and the reason

181
00:08:35,360 --> 00:08:40,550
<font color="#CCCCCC">for that and Tavis will talk a little</font>

182
00:08:36,860 --> 00:08:42,890
<font color="#E5E5E5">bit more about</font><font color="#CCCCCC"> it later that we have we</font>

183
00:08:40,549 --> 00:08:45,680
have tons<font color="#E5E5E5"> of new features coming to the</font>

184
00:08:42,890 --> 00:08:48,050
broader set of such as web font WebGL

185
00:08:45,680 --> 00:08:52,400
and so this<font color="#CCCCCC"> expose a</font><font color="#E5E5E5"> lot of</font><font color="#CCCCCC"> canada</font>

186
00:08:48,050 --> 00:08:55,640
texture face remotely so we will now

187
00:08:52,400 --> 00:09:00,829
present some of the bugs we found this

188
00:08:55,640 --> 00:09:04,430
past year so we were working on Colonel

189
00:09:00,830 --> 00:09:06,710
security for about a year and<font color="#CCCCCC"> over that</font>

190
00:09:04,430 --> 00:09:09,050
time we published lots of bugs me<font color="#E5E5E5"> we</font>

191
00:09:06,710 --> 00:09:11,030
still got some dough<font color="#E5E5E5"> and patched we're</font>

192
00:09:09,050 --> 00:09:12,380
still<font color="#E5E5E5"> waiting for fixes for some of</font>

193
00:09:11,030 --> 00:09:13,640
these but yeah we found quite a few over

194
00:09:12,380 --> 00:09:18,620
the course this over the course of this

195
00:09:13,640 --> 00:09:20,090
year so there were many entry points for

196
00:09:18,620 --> 00:09:21,980
<font color="#E5E5E5">an attacker to reach Colonel attack</font>

197
00:09:20,090 --> 00:09:23,030
surface the obvious ones<font color="#CCCCCC"> are system</font>

198
00:09:21,980 --> 00:09:25,550
calls but there's also things like a

199
00:09:23,030 --> 00:09:27,470
lock tools anything that the colonel

200
00:09:25,550 --> 00:09:29,030
passes file systems weren't

201
00:09:27,470 --> 00:09:30,950
traditionally considered part of you

202
00:09:29,030 --> 00:09:32,750
colonel attack surface but within recent

203
00:09:30,950 --> 00:09:35,660
in recent years or things like water

204
00:09:32,750 --> 00:09:38,540
mounter it's a legitimate way to attack

205
00:09:35,660 --> 00:09:39,650
the colonel obviously those things like

206
00:09:38,540 --> 00:09:42,290
<font color="#E5E5E5">network protocols which are extremely</font>

207
00:09:39,650 --> 00:09:43,670
<font color="#CCCCCC">attractive two attackers and apparently</font>

208
00:09:42,290 --> 00:09:47,780
<font color="#CCCCCC">on</font><font color="#E5E5E5"> Windows you have things like fonts</font>

209
00:09:43,670 --> 00:09:50,510
another formats that are handled in

210
00:09:47,780 --> 00:09:52,010
kernel of course there's been lots of

211
00:09:50,510 --> 00:09:53,750
<font color="#E5E5E5">issues with the executable formats which</font>

212
00:09:52,010 --> 00:09:56,240
are<font color="#E5E5E5"> quite complex object object formats</font>

213
00:09:53,750 --> 00:09:59,300
on Windows and<font color="#CCCCCC"> Linux there's in famous</font>

214
00:09:56,240 --> 00:10:04,010
bugs in in cough elf<font color="#CCCCCC"> ADA outs and so on</font>

215
00:09:59,300 --> 00:10:06,199
but<font color="#E5E5E5"> when underappreciated entry point</font>

216
00:10:04,010 --> 00:10:08,810
that we reconsidered word DPLA interrupt

217
00:10:06,200 --> 00:10:12,530
handlers so we decided that that we

218
00:10:08,810 --> 00:10:14,359
should take a look<font color="#E5E5E5"> at the stuff so we</font>

219
00:10:12,530 --> 00:10:18,500
found one interesting issue on windows

220
00:10:14,360 --> 00:10:21,500
2003 so Microsoft introduced a new DPL<font color="#CCCCCC"> 3</font>

221
00:10:18,500 --> 00:10:25,880
IDT entry<font color="#E5E5E5"> DPL</font><font color="#CCCCCC"> free just means successful</font>

222
00:10:21,500 --> 00:10:27,710
to win<font color="#E5E5E5"> 3 code so in the public symbols</font>

223
00:10:25,880 --> 00:10:31,610
<font color="#E5E5E5">Microsoft called this ki raise assertion</font>

224
00:10:27,710 --> 00:10:33,650
it if you this basically makes if you if

225
00:10:31,610 --> 00:10:34,700
you<font color="#CCCCCC"> ax you in to see it makes it makes</font>

226
00:10:33,650 --> 00:10:35,610
roughly equivalent to just raise

227
00:10:34,700 --> 00:10:39,540
exception state

228
00:10:35,610 --> 00:10:41,339
unveiled so this<font color="#CCCCCC"> is kind of odd I've</font>

229
00:10:39,540 --> 00:10:45,149
looked a lots of Microsoft curtain I've

230
00:10:41,339 --> 00:10:46,860
never seen me<font color="#CCCCCC"> use this feature and in</font>

231
00:10:45,149 --> 00:10:48,029
fact looking at the the implementation

232
00:10:46,860 --> 00:10:50,850
in the kernel it turns out that they

233
00:10:48,029 --> 00:10:53,640
made an interesting ever they dispatch

234
00:10:50,850 --> 00:10:56,250
the interrupt before enabling they just

235
00:10:53,640 --> 00:11:00,269
passed the the exception before enabling

236
00:10:56,250 --> 00:11:01,980
interrupt so this bug while not

237
00:11:00,269 --> 00:11:05,550
particularly high impact I had had two

238
00:11:01,980 --> 00:11:07,980
interesting<font color="#E5E5E5"> characteristics the</font><font color="#CCCCCC"> exploit</font>

239
00:11:05,550 --> 00:11:09,449
you simply just<font color="#E5E5E5"> invalidate ESP and then</font>

240
00:11:07,980 --> 00:11:11,970
call in to see so you could exploit it

241
00:11:09,450 --> 00:11:13,560
in just<font color="#CCCCCC"> four bytes and and the patch was</font>

242
00:11:11,970 --> 00:11:16,200
interesting as well simply<font color="#CCCCCC"> because it</font>

243
00:11:13,560 --> 00:11:17,550
just that you had to just<font color="#CCCCCC"> me enable</font><font color="#E5E5E5"> the</font>

244
00:11:16,200 --> 00:11:20,579
interrupt flag so that's just one byte

245
00:11:17,550 --> 00:11:21,689
instruction STI so I it's not<font color="#CCCCCC"> ticking</font>

246
00:11:20,579 --> 00:11:22,620
<font color="#CCCCCC">hind back but we thought</font><font color="#E5E5E5"> it was fun</font>

247
00:11:21,690 --> 00:11:27,980
because this and I<font color="#CCCCCC"> asked you have</font><font color="#E5E5E5"> a</font>

248
00:11:22,620 --> 00:11:27,980
<font color="#E5E5E5">video with this happening</font>

249
00:11:31,059 --> 00:11:41,799
okay oh<font color="#E5E5E5"> okay so i'm just using CDV to</font>

250
00:11:39,069 --> 00:11:44,429
open a an extra bill so that<font color="#CCCCCC"> i can</font><font color="#E5E5E5"> have</font>

251
00:11:41,799 --> 00:11:44,429
some code into it

252
00:11:47,420 --> 00:11:51,560
so yeah I just<font color="#E5E5E5"> choose anyone demise</font>

253
00:11:49,250 --> 00:11:53,780
beatable so that i can<font color="#CCCCCC"> use the the</font>

254
00:11:51,560 --> 00:12:00,290
assemble function from the windows

255
00:11:53,780 --> 00:12:01,670
debuggers so yeah<font color="#CCCCCC"> Justin</font><font color="#E5E5E5"> valet DSP call</font>

256
00:12:00,290 --> 00:12:08,329
in to see to raise the exception

257
00:12:01,670 --> 00:12:11,420
detached from the process and yet you

258
00:12:08,330 --> 00:12:12,920
see soft paste is<font color="#CCCCCC"> x-default</font><font color="#E5E5E5"> and begged</font>

259
00:12:11,420 --> 00:12:14,240
you to facial if<font color="#E5E5E5"> I turn</font><font color="#CCCCCC"> off faults and</font>

260
00:12:12,920 --> 00:12:17,300
then letter continued you get a bug<font color="#CCCCCC"> jack</font>

261
00:12:14,240 --> 00:12:18,950
so it's it's kind of a funny bug it's a

262
00:12:17,300 --> 00:12:20,900
but this one wasn't particularly high

263
00:12:18,950 --> 00:12:22,250
impact but it was just<font color="#E5E5E5"> interesting then</font>

264
00:12:20,900 --> 00:12:24,020
shows that<font color="#E5E5E5"> really there isn't much</font>

265
00:12:22,250 --> 00:12:30,410
exploration<font color="#CCCCCC"> whom researchers in</font><font color="#E5E5E5"> this</font>

266
00:12:24,020 --> 00:12:33,920
area see okay so on the subject<font color="#CCCCCC"> of</font>

267
00:12:30,410 --> 00:12:37,280
exceptions and interrupt handlers every

268
00:12:33,920 --> 00:12:38,150
cup of how page faults work so<font color="#E5E5E5"> as I'm</font>

269
00:12:37,280 --> 00:12:40,189
sure every when I was a page fault

270
00:12:38,150 --> 00:12:42,530
occurs when when there's some attempt to

271
00:12:40,190 --> 00:12:45,530
<font color="#E5E5E5">access a non present page but it's also</font>

272
00:12:42,530 --> 00:12:47,540
if you have insufficient access to to

273
00:12:45,530 --> 00:12:51,770
touch a present page and this various

274
00:12:47,540 --> 00:12:53,390
other<font color="#E5E5E5"> low-level paging related errors so</font>

275
00:12:51,770 --> 00:12:55,970
when a page fault occurs the the page

276
00:12:53,390 --> 00:12:58,220
fault the handle of a page fault is

277
00:12:55,970 --> 00:12:59,450
passed an exception code which has a

278
00:12:58,220 --> 00:13:01,940
number of flags that describe what

279
00:12:59,450 --> 00:13:04,310
happened when the page what occurred so

280
00:13:01,940 --> 00:13:06,170
the flags are ID which is<font color="#E5E5E5"> which explains</font>

281
00:13:04,310 --> 00:13:09,410
whether is was the page full was caused

282
00:13:06,170 --> 00:13:11,420
by instruction<font color="#E5E5E5"> or data fetch us which</font>

283
00:13:09,410 --> 00:13:15,020
means the page while occurred when

284
00:13:11,420 --> 00:13:16,130
during the user or supervisor mode WR

285
00:13:15,020 --> 00:13:18,829
which has where there is a read or write

286
00:13:16,130 --> 00:13:25,040
and<font color="#E5E5E5"> p or ND which means presently not</font>

287
00:13:18,830 --> 00:13:28,790
present so so supervisor mode which<font color="#CCCCCC"> is</font>

288
00:13:25,040 --> 00:13:31,520
what sets the<font color="#E5E5E5"> u.s. bit is is that when</font>

289
00:13:28,790 --> 00:13:34,939
the patriotic<font color="#E5E5E5"> ered during some</font>

290
00:13:31,520 --> 00:13:36,350
privileged operation so if the

291
00:13:34,940 --> 00:13:38,000
<font color="#CCCCCC">supervised a bit is set it can mean</font>

292
00:13:36,350 --> 00:13:40,460
various<font color="#CCCCCC"> things it could mean the bug</font>

293
00:13:38,000 --> 00:13:42,440
Colonel bug was encountered and then

294
00:13:40,460 --> 00:13:46,010
you'd expect<font color="#CCCCCC"> to</font><font color="#E5E5E5"> see</font><font color="#CCCCCC"> an oops or</font><font color="#E5E5E5"> a budget</font>

295
00:13:42,440 --> 00:13:48,260
on<font color="#CCCCCC"> Linux or</font><font color="#E5E5E5"> bug check on Windows or some</font>

296
00:13:46,010 --> 00:13:49,850
<font color="#CCCCCC">of the kind of panic but it can also</font>

297
00:13:48,260 --> 00:13:53,420
mean some other unusual<font color="#E5E5E5"> low-level event</font>

298
00:13:49,850 --> 00:13:54,770
happened in and you'd expect it would be

299
00:13:53,420 --> 00:13:57,920
normal for that to occur<font color="#CCCCCC"> in</font><font color="#E5E5E5"> sudden like</font>

300
00:13:54,770 --> 00:13:58,970
a copy from user operation in most other

301
00:13:57,920 --> 00:13:59,969
circumstances it would mean something

302
00:13:58,970 --> 00:14:05,699
unusual happened

303
00:13:59,970 --> 00:14:06,839
so by looking at this code we realized

304
00:14:05,699 --> 00:14:08,040
that<font color="#E5E5E5"> if the processor can be tricked</font>

305
00:14:06,839 --> 00:14:10,649
into setting these flags incorrectly

306
00:14:08,040 --> 00:14:12,120
then you can confuse a lot of really

307
00:14:10,649 --> 00:14:14,879
privileged<font color="#CCCCCC"> core operating system code</font>

308
00:14:12,120 --> 00:14:18,660
and so we were thinking<font color="#E5E5E5"> about this for a</font>

309
00:14:14,879 --> 00:14:23,399
while<font color="#E5E5E5"> and we came up with a</font><font color="#CCCCCC"> way to do</font>

310
00:14:18,660 --> 00:14:26,610
this so what we did was study the

311
00:14:23,399 --> 00:14:29,550
<font color="#CCCCCC">machine state of while executing a</font>

312
00:14:26,610 --> 00:14:33,149
virtual 8086 mode task in vmware in a

313
00:14:29,550 --> 00:14:35,040
vmware guest and we<font color="#E5E5E5"> actually found a way</font>

314
00:14:33,149 --> 00:14:39,089
to<font color="#E5E5E5"> make vmware set the</font><font color="#CCCCCC"> supervised a bit</font>

315
00:14:35,040 --> 00:14:40,800
<font color="#E5E5E5">for an unprivileged paid fault so the</font>

316
00:14:39,089 --> 00:14:47,220
<font color="#E5E5E5">problem was if you do a far call in</font>

317
00:14:40,800 --> 00:14:49,709
virtual 8086 mode the p it was emulated

318
00:14:47,220 --> 00:14:51,810
incorrectly so obviously when you get a

319
00:14:49,709 --> 00:14:52,859
far call you'd expect that the the cs

320
00:14:51,810 --> 00:14:54,989
and I prepare to<font color="#E5E5E5"> be pushed onto the</font>

321
00:14:52,860 --> 00:14:58,079
stack and<font color="#E5E5E5"> this is actually done with</font>

322
00:14:54,990 --> 00:14:59,579
supervisor access it's it's it's it's

323
00:14:58,079 --> 00:15:01,109
reasonable to understand why<font color="#CCCCCC"> VMware did</font>

324
00:14:59,579 --> 00:15:03,089
this they were probably trying to reuse

325
00:15:01,110 --> 00:15:04,230
<font color="#CCCCCC">the real mode emulation code for if you</font>

326
00:15:03,089 --> 00:15:07,350
<font color="#E5E5E5">want to Doss</font><font color="#CCCCCC"> guests or something like</font>

327
00:15:04,230 --> 00:15:09,240
that<font color="#E5E5E5"> and it's a it's obviously pretty</font>

328
00:15:07,350 --> 00:15:10,290
reasonable to to use supervisor access

329
00:15:09,240 --> 00:15:13,470
for that because it makes no difference

330
00:15:10,290 --> 00:15:15,329
but in virtual 8086 mode<font color="#CCCCCC"> intel actually</font>

331
00:15:13,470 --> 00:15:18,689
guarantees that you're always running

332
00:15:15,329 --> 00:15:21,239
his wing<font color="#E5E5E5"> free it's a as a CPL</font><font color="#CCCCCC"> 3 it's</font>

333
00:15:18,689 --> 00:15:24,209
<font color="#E5E5E5">it's very clear and all of the manuals</font>

334
00:15:21,240 --> 00:15:26,490
that this is guaranteed so this was an

335
00:15:24,209 --> 00:15:28,649
error and surprisingly we were able to

336
00:15:26,490 --> 00:15:34,470
<font color="#E5E5E5">exploit this get ring 0 code execution</font>

337
00:15:28,649 --> 00:15:35,730
enter<font color="#E5E5E5"> VMware</font><font color="#CCCCCC"> guest the the</font><font color="#E5E5E5"> reason we</font>

338
00:15:34,470 --> 00:15:37,529
were able to<font color="#E5E5E5"> do this was because the</font>

339
00:15:35,730 --> 00:15:39,750
links kernel has a magic check has a

340
00:15:37,529 --> 00:15:43,199
check for a magic CS value to look for

341
00:15:39,750 --> 00:15:47,399
an unusual unusual event caused<font color="#CCCCCC"> by pnp</font>

342
00:15:43,199 --> 00:15:48,389
bio support but because this magic value

343
00:15:47,399 --> 00:15:51,839
is something that you wouldn't normally

344
00:15:48,389 --> 00:15:53,069
be able to set in virtual 86 mode you

345
00:15:51,839 --> 00:15:55,199
must be allowed to set it because this

346
00:15:53,069 --> 00:15:58,769
is how real mode addressing works in ode

347
00:15:55,199 --> 00:16:00,569
the obviously<font color="#CCCCCC"> address is a 16 bits in in</font>

348
00:15:58,769 --> 00:16:02,279
real mode but the<font color="#E5E5E5"> address space is 20</font>

349
00:16:00,569 --> 00:16:05,459
bits so you do this by shifting around

350
00:16:02,279 --> 00:16:07,410
<font color="#CCCCCC">CS and adding</font><font color="#E5E5E5"> it to IP so in order to</font>

351
00:16:05,459 --> 00:16:09,929
access the full 20-bit address space you

352
00:16:07,410 --> 00:16:11,800
need you need to be able to set any CS

353
00:16:09,929 --> 00:16:14,470
value

354
00:16:11,800 --> 00:16:16,180
obviously this has that this<font color="#E5E5E5"> has a</font>

355
00:16:14,470 --> 00:16:17,830
special meaning in protected mode but in

356
00:16:16,180 --> 00:16:18,969
in real<font color="#E5E5E5"> mode yeah it doesn't mean</font>

357
00:16:17,830 --> 00:16:21,250
anything is just part of the address

358
00:16:18,970 --> 00:16:25,720
<font color="#E5E5E5">calculation to form a physical address</font>

359
00:16:21,250 --> 00:16:26,920
from a from a from an address so believe

360
00:16:25,720 --> 00:16:29,380
<font color="#CCCCCC">it or not we can actually</font><font color="#E5E5E5"> exploit this</font>

361
00:16:26,920 --> 00:16:31,719
error it might be surprising<font color="#E5E5E5"> but we</font>

362
00:16:29,380 --> 00:16:35,050
worked on this<font color="#E5E5E5"> Emily we actually</font><font color="#CCCCCC"> got it</font>

363
00:16:31,720 --> 00:16:37,360
to work so all<font color="#E5E5E5"> we have to do</font><font color="#CCCCCC"> is mi pie</font>

364
00:16:35,050 --> 00:16:40,209
shell code and no and then we've enter

365
00:16:37,360 --> 00:16:41,470
vm<font color="#E5E5E5"> age of</font><font color="#CCCCCC"> 6 mode so as we when we were</font>

366
00:16:40,209 --> 00:16:43,119
working on this there was a new feature

367
00:16:41,470 --> 00:16:44,860
of image that was<font color="#CCCCCC"> beginning to gain</font>

368
00:16:43,120 --> 00:16:46,510
popularity<font color="#E5E5E5"> called nmap me</font><font color="#CCCCCC"> nadra at the</font>

369
00:16:44,860 --> 00:16:49,089
<font color="#E5E5E5">moment it's it's it's quite well known</font>

370
00:16:46,510 --> 00:16:50,410
and well used but at the time we were

371
00:16:49,089 --> 00:16:52,630
<font color="#E5E5E5">concerned that maybe we would say this</font>

372
00:16:50,410 --> 00:16:54,490
was this wasn't<font color="#CCCCCC"> real and this issue</font>

373
00:16:52,630 --> 00:16:55,870
wasn't really realistic because of their

374
00:16:54,490 --> 00:16:57,700
mark may not have just<font color="#CCCCCC"> been introduced</font>

375
00:16:55,870 --> 00:17:02,350
so we find a way to bypass that as well

376
00:16:57,700 --> 00:17:04,329
begin to<font color="#E5E5E5"> talk about later so all we had</font>

377
00:17:02,350 --> 00:17:06,189
to do was set up a far call to a non

378
00:17:04,329 --> 00:17:09,579
present page at SS with a non-person

379
00:17:06,189 --> 00:17:13,089
page with the<font color="#CCCCCC"> SSSP address a PF is</font>

380
00:17:09,579 --> 00:17:14,649
delivered which is as expected but

381
00:17:13,089 --> 00:17:20,918
because we can set these magic values in

382
00:17:14,650 --> 00:17:25,179
in CS and then which is<font color="#E5E5E5"> recognized as a</font>

383
00:17:20,919 --> 00:17:26,559
PMP<font color="#E5E5E5"> BIOS fault then because the colonel</font>

384
00:17:25,179 --> 00:17:28,900
wasn't expecting as fault and there was

385
00:17:26,559 --> 00:17:30,580
no handler set up the fault isn't the

386
00:17:28,900 --> 00:17:31,960
fault handler isn't installed it's a BSS

387
00:17:30,580 --> 00:17:33,909
object so it's set to know and the

388
00:17:31,960 --> 00:17:36,160
colonel just jumps to know and then you

389
00:17:33,910 --> 00:17:40,600
<font color="#CCCCCC">basically you've got you routed the</font>

390
00:17:36,160 --> 00:17:42,610
machine so this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> how we triggered it</font>

391
00:17:40,600 --> 00:17:44,230
we basically<font color="#E5E5E5"> you put set some nonsense</font>

392
00:17:42,610 --> 00:17:45,459
in the SP and SS so that you'll call it

393
00:17:44,230 --> 00:17:46,660
<font color="#E5E5E5">cause a page fault because the please</font>

394
00:17:45,460 --> 00:17:50,350
obviously this page is<font color="#E5E5E5"> going to be</font>

395
00:17:46,660 --> 00:17:52,809
present then we set CS<font color="#E5E5E5"> to 90 which is</font>

396
00:17:50,350 --> 00:17:54,040
the magic value for PMP BIOS faults and

397
00:17:52,809 --> 00:17:55,809
then we<font color="#E5E5E5"> did this</font><font color="#CCCCCC"> Park all and that</font><font color="#E5E5E5"> was</font>

398
00:17:54,040 --> 00:18:02,770
that was it basically the<font color="#E5E5E5"> kennel</font><font color="#CCCCCC"> we just</font>

399
00:17:55,809 --> 00:18:04,300
<font color="#CCCCCC">jumped</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> our code has rings ero so this</font>

400
00:18:02,770 --> 00:18:05,679
was when the first issues we found<font color="#E5E5E5"> with</font>

401
00:18:04,300 --> 00:18:08,918
page faults but we formed we found some

402
00:18:05,679 --> 00:18:10,390
more as well on<font color="#E5E5E5"> Windows so obviously</font>

403
00:18:08,919 --> 00:18:12,010
it's it's well known that if the colonel

404
00:18:10,390 --> 00:18:12,910
ever trusts any data from user space and

405
00:18:12,010 --> 00:18:16,330
there's going<font color="#E5E5E5"> to be a security issue</font>

406
00:18:12,910 --> 00:18:18,400
somewhere but it's<font color="#E5E5E5"> not just</font><font color="#CCCCCC"> a presence</font>

407
00:18:16,330 --> 00:18:21,550
of data that users control it's also the

408
00:18:18,400 --> 00:18:23,350
presence or absence of data so you can

409
00:18:21,550 --> 00:18:24,399
set up some<font color="#E5E5E5"> nonsense and set at Ella</font>

410
00:18:23,350 --> 00:18:25,480
Colonel<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is like some data</font>

411
00:18:24,400 --> 00:18:26,650
structures expecting

412
00:18:25,480 --> 00:18:29,950
you can say there was date there's more

413
00:18:26,650 --> 00:18:32,500
data here than was expected or less data

414
00:18:29,950 --> 00:18:35,740
than expected and<font color="#CCCCCC"> the and and the same</font>

415
00:18:32,500 --> 00:18:37,150
things can happen so by claiming we have

416
00:18:35,740 --> 00:18:38,590
more<font color="#E5E5E5"> data available than we really do</font>

417
00:18:37,150 --> 00:18:41,860
and we can reach lots of unusual<font color="#CCCCCC"> abba</font>

418
00:18:38,590 --> 00:18:44,740
parts and this<font color="#E5E5E5"> is this is mainly to on</font>

419
00:18:41,860 --> 00:18:46,479
windows because the system like the main

420
00:18:44,740 --> 00:18:47,950
system types are large interdependence

421
00:18:46,480 --> 00:18:49,480
structures that often have multiple

422
00:18:47,950 --> 00:18:51,309
components and they sometimes have

423
00:18:49,480 --> 00:18:53,020
version numbers we have to read the

424
00:18:51,309 --> 00:18:54,129
first version number first to see<font color="#CCCCCC"> how</font>

425
00:18:53,020 --> 00:18:55,690
big the structure is going to be and

426
00:18:54,130 --> 00:18:57,940
then they can have valuable sized arrays

427
00:18:55,690 --> 00:19:00,340
this is a millionth case on linux we're

428
00:18:57,940 --> 00:19:02,110
at best you have like you have one

429
00:19:00,340 --> 00:19:07,209
structure that's they could be read in a

430
00:19:02,110 --> 00:19:09,189
single operation or at most two

431
00:19:07,210 --> 00:19:12,070
operations for things like sized for a

432
00:19:09,190 --> 00:19:16,750
for something like<font color="#CCCCCC"> and white v</font>

433
00:19:12,070 --> 00:19:18,639
structures i 0 vectors but on<font color="#CCCCCC"> Windows</font>

434
00:19:16,750 --> 00:19:21,070
yeah reading data from user space can be

435
00:19:18,640 --> 00:19:22,809
a complex operation and we found an

436
00:19:21,070 --> 00:19:24,399
example of this that they could<font color="#E5E5E5"> result</font>

437
00:19:22,809 --> 00:19:27,520
in a privilege escalation on every

438
00:19:24,400 --> 00:19:28,510
version of Windows NT the bug wasn't

439
00:19:27,520 --> 00:19:30,820
particularly exciting because<font color="#E5E5E5"> you had to</font>

440
00:19:28,510 --> 00:19:33,400
<font color="#E5E5E5">win a race condition to win it to get</font>

441
00:19:30,820 --> 00:19:35,649
code execution so it wasn't particularly

442
00:19:33,400 --> 00:19:40,210
exciting for attackers because simply

443
00:19:35,650 --> 00:19:41,590
because nine times out of ten you're

444
00:19:40,210 --> 00:19:44,049
<font color="#CCCCCC">going to</font><font color="#E5E5E5"> get a bug check whether than</font>

445
00:19:41,590 --> 00:19:45,790
code execution but<font color="#E5E5E5"> it was it was a</font>

446
00:19:44,049 --> 00:19:50,320
<font color="#E5E5E5">legitimate issue and it was a double</font>

447
00:19:45,790 --> 00:19:51,820
<font color="#CCCCCC">three in NT filter token so</font><font color="#E5E5E5"> aunty filter</font>

448
00:19:50,320 --> 00:19:54,070
token is the<font color="#CCCCCC"> backend system surface that</font>

449
00:19:51,820 --> 00:19:56,770
makes the win32<font color="#E5E5E5"> API create restricted</font>

450
00:19:54,070 --> 00:19:58,570
token work how ND filter token works

451
00:19:56,770 --> 00:20:00,460
would be that you'd pass it it would

452
00:19:58,570 --> 00:20:01,780
pass a pointer to a pointer to a helper

453
00:20:00,460 --> 00:20:04,630
routine that was<font color="#CCCCCC"> try to</font><font color="#E5E5E5"> capture all this</font>

454
00:20:01,780 --> 00:20:07,720
complex SI d data that it would they

455
00:20:04,630 --> 00:20:10,510
need<font color="#E5E5E5"> it a pass but we can post this to</font>

456
00:20:07,720 --> 00:20:11,950
fails but we can we can bigger a check

457
00:20:10,510 --> 00:20:13,929
past that says the date was present

458
00:20:11,950 --> 00:20:16,510
because by putting<font color="#CCCCCC"> that by starting</font><font color="#E5E5E5"> the</font>

459
00:20:13,929 --> 00:20:18,910
the<font color="#E5E5E5"> structure on a on a pleasant page</font>

460
00:20:16,510 --> 00:20:21,850
and then saying it spans across a page

461
00:20:18,910 --> 00:20:23,080
boundary to a no access page so we<font color="#E5E5E5"> can</font>

462
00:20:21,850 --> 00:20:26,980
cause some unusual ever conditions like

463
00:20:23,080 --> 00:20:30,580
this and by<font color="#E5E5E5"> making this structure he has</font>

464
00:20:26,980 --> 00:20:31,570
trouble page boundary so on our this

465
00:20:30,580 --> 00:20:33,790
<font color="#E5E5E5">helper routine they were supposed to</font>

466
00:20:31,570 --> 00:20:35,168
<font color="#E5E5E5">capture</font><font color="#CCCCCC"> this user data would release</font>

467
00:20:33,790 --> 00:20:37,418
this buffer they was going to save the

468
00:20:35,169 --> 00:20:38,330
data into and then we turn 20 filter

469
00:20:37,419 --> 00:20:39,529
token

470
00:20:38,330 --> 00:20:41,418
ND filter token didn't handle this

471
00:20:39,529 --> 00:20:45,860
correctly and it would try to<font color="#E5E5E5"> flee the</font>

472
00:20:41,419 --> 00:20:47,210
bathroom<font color="#CCCCCC"> again so if because there's</font>

473
00:20:45,860 --> 00:20:49,010
only<font color="#E5E5E5"> a short period between these two</font>

474
00:20:47,210 --> 00:20:51,529
events the colonel<font color="#CCCCCC"> took that detects a</font>

475
00:20:49,010 --> 00:20:52,820
double free and bug checks so you only

476
00:20:51,529 --> 00:20:54,019
get one attempt<font color="#CCCCCC"> to exploit this and you</font>

477
00:20:52,820 --> 00:20:55,279
need to get<font color="#E5E5E5"> that buffer reallocated</font>

478
00:20:54,019 --> 00:20:57,710
somewhere else within<font color="#E5E5E5"> this very short</font>

479
00:20:55,279 --> 00:20:59,600
period so we<font color="#CCCCCC"> know this</font><font color="#E5E5E5"> is exploitable on</font>

480
00:20:57,710 --> 00:21:01,010
MP systems because<font color="#E5E5E5"> using a debugger we</font>

481
00:20:59,600 --> 00:21:03,709
can force us we can let ourselves win

482
00:21:01,010 --> 00:21:05,929
the race condition every time but<font color="#E5E5E5"> Emmy a</font>

483
00:21:03,710 --> 00:21:07,010
Latino buddy is going<font color="#E5E5E5"> to be no real</font>

484
00:21:05,929 --> 00:21:09,860
attackers going to be interested in this

485
00:21:07,010 --> 00:21:13,940
<font color="#E5E5E5">burg simply because they'd only win one</font>

486
00:21:09,860 --> 00:21:16,729
in<font color="#CCCCCC"> 100 times</font><font color="#E5E5E5"> it was possible</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> it was</font>

487
00:21:13,940 --> 00:21:19,010
<font color="#CCCCCC">a fun bug and that there's a URL for</font>

488
00:21:16,730 --> 00:21:23,000
some from example code<font color="#CCCCCC"> so you can check</font>

489
00:21:19,010 --> 00:21:24,679
if you're interested how<font color="#E5E5E5"> I did this okay</font>

490
00:21:23,000 --> 00:21:27,139
so this is another<font color="#E5E5E5"> vulnerability in</font>

491
00:21:24,679 --> 00:21:28,940
Windows NT so this<font color="#E5E5E5"> is a quote from from</font>

492
00:21:27,139 --> 00:21:32,269
recent of<font color="#E5E5E5"> H in</font><font color="#CCCCCC"> Windows internal</font><font color="#E5E5E5"> fourth</font>

493
00:21:28,940 --> 00:21:33,769
edition he explains the moving GDI from

494
00:21:32,269 --> 00:21:35,179
user mode to kernel mode has provided

495
00:21:33,769 --> 00:21:36,559
improved performance without any

496
00:21:35,179 --> 00:21:39,350
significant decrease in system stability

497
00:21:36,559 --> 00:21:41,210
or reliability I think you might regret

498
00:21:39,350 --> 00:21:43,668
this regret this quote it's maybe it's

499
00:21:41,210 --> 00:21:45,200
true<font color="#CCCCCC"> but there's no question the GDI</font>

500
00:21:43,669 --> 00:21:48,409
represents a significant<font color="#E5E5E5"> criminal attack</font>

501
00:21:45,200 --> 00:21:53,269
surface now and that it's possibly the

502
00:21:48,409 --> 00:21:55,850
most easily accessible remotely so it's

503
00:21:53,269 --> 00:21:57,049
<font color="#E5E5E5">it's obvious to us that the</font><font color="#CCCCCC"> fun passing</font>

504
00:21:55,850 --> 00:21:58,820
<font color="#E5E5E5">was going to be one of the weak point</font>

505
00:21:57,049 --> 00:22:00,710
simply because<font color="#E5E5E5"> it's series so easy to</font>

506
00:21:58,820 --> 00:22:02,330
access via<font color="#CCCCCC"> Internet Explorer's app font</font>

507
00:22:00,710 --> 00:22:04,370
face support for CSS which allows a

508
00:22:02,330 --> 00:22:07,279
arbitrary web fonts to<font color="#E5E5E5"> be downloaded for</font>

509
00:22:04,370 --> 00:22:10,699
your<font color="#E5E5E5"> web pages this is probably our most</font>

510
00:22:07,279 --> 00:22:12,620
critical discovery over the year that we

511
00:22:10,700 --> 00:22:14,059
were working on this simply because just

512
00:22:12,620 --> 00:22:15,979
by visiting<font color="#CCCCCC"> a website you</font><font color="#E5E5E5"> could you</font>

513
00:22:14,059 --> 00:22:18,230
could actually arbitrary wing zero code

514
00:22:15,980 --> 00:22:19,429
this is interesting because it doesn't

515
00:22:18,230 --> 00:22:21,260
matter<font color="#E5E5E5"> whether your sandbox tour your</font>

516
00:22:19,429 --> 00:22:22,429
unprivileged<font color="#CCCCCC"> or using protective mode it</font>

517
00:22:21,260 --> 00:22:23,779
makes a difference we can make an

518
00:22:22,429 --> 00:22:26,570
exploit that and become<font color="#CCCCCC"> the most</font>

519
00:22:23,779 --> 00:22:27,409
privileged users on the system it

520
00:22:26,570 --> 00:22:28,700
doesn't<font color="#E5E5E5"> matter if you don't have</font>

521
00:22:27,409 --> 00:22:33,980
administrative access<font color="#E5E5E5"> anything about it</font>

522
00:22:28,700 --> 00:22:36,649
was easy to use easy to<font color="#E5E5E5"> escape so the</font>

523
00:22:33,980 --> 00:22:37,970
way<font color="#E5E5E5"> this work was that the font format</font>

524
00:22:36,649 --> 00:22:40,428
supported by<font color="#E5E5E5"> Internet Explorer is called</font>

525
00:22:37,970 --> 00:22:41,929
eot which is embedded<font color="#CCCCCC"> open type it's</font>

526
00:22:40,429 --> 00:22:46,580
essentially just a trivial drm layer

527
00:22:41,929 --> 00:22:47,779
added on top of TTF format forms the it

528
00:22:46,580 --> 00:22:49,580
defines some interesting data

529
00:22:47,779 --> 00:22:50,480
compression sub formats called CTF and

530
00:22:49,580 --> 00:22:52,490
MTX

531
00:22:50,480 --> 00:22:54,169
we actually<font color="#E5E5E5"> also pwned these as well</font>

532
00:22:52,490 --> 00:22:56,990
<font color="#E5E5E5">with some</font><font color="#CCCCCC"> bring</font><font color="#E5E5E5"> three vulnerabilities</font>

533
00:22:54,169 --> 00:22:58,520
these<font color="#CCCCCC"> were you can see ms1000 one but</font>

534
00:22:56,990 --> 00:23:02,750
<font color="#E5E5E5">there's a couple of others that I don't</font>

535
00:22:58,520 --> 00:23:04,610
know the numbers but eot is basically

536
00:23:02,750 --> 00:23:07,130
just added confession and reduced

537
00:23:04,610 --> 00:23:08,418
redundancy<font color="#CCCCCC"> CDF and MTX are actually</font>

538
00:23:07,130 --> 00:23:09,710
quite clever data compression formats

539
00:23:08,419 --> 00:23:11,390
and they're quite interesting<font color="#CCCCCC"> to read it</font>

540
00:23:09,710 --> 00:23:13,520
isn't they<font color="#CCCCCC"> do some cool tricks</font><font color="#E5E5E5"> to make</font>

541
00:23:11,390 --> 00:23:15,380
fonts as small as possible<font color="#E5E5E5"> I believe the</font>

542
00:23:13,520 --> 00:23:18,049
<font color="#E5E5E5">Microsoft license this technology from</font>

543
00:23:15,380 --> 00:23:19,490
agfa and they published in documents on

544
00:23:18,049 --> 00:23:22,879
it they're actually pretty cool if

545
00:23:19,490 --> 00:23:26,210
interested in data compression sorry so

546
00:23:22,880 --> 00:23:28,400
yeah eot<font color="#E5E5E5"> had had some pretty silly</font>

547
00:23:26,210 --> 00:23:31,130
extensions things like support for<font color="#CCCCCC"> x or</font>

548
00:23:28,400 --> 00:23:33,799
encryption and some other drm techniques

549
00:23:31,130 --> 00:23:35,630
the the<font color="#E5E5E5"> XO encryption is really silly</font>

550
00:23:33,799 --> 00:23:37,340
basically just if the flag is set that

551
00:23:35,630 --> 00:23:39,080
says this is encrypted it basically<font color="#E5E5E5"> just</font>

552
00:23:37,340 --> 00:23:43,040
exles the entire data stream with this

553
00:23:39,080 --> 00:23:44,990
fixed x 0 x 50 so yeah that's<font color="#E5E5E5"> not it's</font>

554
00:23:43,040 --> 00:23:49,340
not particularly challenging to to a

555
00:23:44,990 --> 00:23:51,710
decrypter there's also some other some

556
00:23:49,340 --> 00:23:54,409
another drm technique called root

557
00:23:51,710 --> 00:23:55,910
strings<font color="#E5E5E5"> I think the idea is that if you</font>

558
00:23:54,410 --> 00:23:57,260
<font color="#E5E5E5">want you have a form that you've</font>

559
00:23:55,910 --> 00:24:00,290
licensed and you only want it<font color="#E5E5E5"> to be</font>

560
00:23:57,260 --> 00:24:02,990
accessible on your website your you'd

561
00:24:00,290 --> 00:24:04,820
get your you put your website into the

562
00:24:02,990 --> 00:24:06,169
old<font color="#E5E5E5"> you put all the URLs that you want</font>

563
00:24:04,820 --> 00:24:09,110
this<font color="#E5E5E5"> pond to be accessible for into the</font>

564
00:24:06,169 --> 00:24:10,610
eot file and then sign it but the

565
00:24:09,110 --> 00:24:11,659
signature<font color="#E5E5E5"> is ridiculous especially just</font>

566
00:24:10,610 --> 00:24:13,490
add all the character the character

567
00:24:11,660 --> 00:24:16,400
values and then accelerate with a fixed

568
00:24:13,490 --> 00:24:21,740
32-bit keyword so yeah it's not taking a

569
00:24:16,400 --> 00:24:23,270
challenging to the Venus so so yeah this

570
00:24:21,740 --> 00:24:25,070
is all handled by a new library<font color="#E5E5E5"> called T</font>

571
00:24:23,270 --> 00:24:27,620
to embed but<font color="#E5E5E5"> basically it just takes the</font>

572
00:24:25,070 --> 00:24:31,159
<font color="#CCCCCC">eot file handle the</font><font color="#E5E5E5"> XOR decryption and</font>

573
00:24:27,620 --> 00:24:32,659
so on and<font color="#E5E5E5"> then passes it to GDI and then</font>

574
00:24:31,160 --> 00:24:37,910
everything<font color="#E5E5E5"> from that point on happens</font>

575
00:24:32,660 --> 00:24:40,880
with<font color="#CCCCCC"> being 0 so this is pretty scary and</font>

576
00:24:37,910 --> 00:24:42,980
it turns out we were able<font color="#E5E5E5"> to find lots</font>

577
00:24:40,880 --> 00:24:45,620
of integer hours when GDI passes the ttf

578
00:24:42,980 --> 00:24:47,840
directories so the directories are

579
00:24:45,620 --> 00:24:49,459
basically at the at the start of<font color="#E5E5E5"> a ttf</font>

580
00:24:47,840 --> 00:24:53,990
file and<font color="#CCCCCC"> the explain why each table is</font>

581
00:24:49,460 --> 00:24:56,000
in the rest of the file this was we this

582
00:24:53,990 --> 00:24:57,559
code was all<font color="#CCCCCC"> exited a ring 0 and the</font>

583
00:24:56,000 --> 00:24:59,960
code was really old it was unchanged

584
00:24:57,559 --> 00:25:01,760
since at least NT 4 and in fact if<font color="#CCCCCC"> you</font>

585
00:24:59,960 --> 00:25:02,830
<font color="#CCCCCC">got a ftp don microsoft com you can</font>

586
00:25:01,760 --> 00:25:04,870
still download

587
00:25:02,830 --> 00:25:06,519
t three point three point one service

588
00:25:04,870 --> 00:25:11,199
packs and you can see curls as old as

589
00:25:06,519 --> 00:25:13,960
like 94 95 and and<font color="#E5E5E5"> there's</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> the code</font>

590
00:25:11,200 --> 00:25:15,370
is<font color="#E5E5E5"> very similar it's barely changed</font><font color="#CCCCCC"> and</font>

591
00:25:13,960 --> 00:25:16,809
so Mike's wasn't alone there<font color="#E5E5E5"> were lots</font>

592
00:25:15,370 --> 00:25:18,158
of other implications that work that we

593
00:25:16,809 --> 00:25:20,559
tested that were vulnerable to pretty

594
00:25:18,159 --> 00:25:22,299
much the same bug but it was it was

595
00:25:20,559 --> 00:25:23,799
mainly serious on on<font color="#E5E5E5"> Microsoft platform</font>

596
00:25:22,299 --> 00:25:27,519
simply because they run this code at

597
00:25:23,799 --> 00:25:29,590
such a high privilege level so we<font color="#CCCCCC"> had a</font>

598
00:25:27,519 --> 00:25:31,269
we had a this was obviously explodable

599
00:25:29,590 --> 00:25:32,860
remotely but we only worked<font color="#E5E5E5"> on a local</font>

600
00:25:31,269 --> 00:25:35,860
exploit just for demonstration purposes

601
00:25:32,860 --> 00:25:39,789
it was a<font color="#E5E5E5"> very reliable and nice nice</font><font color="#CCCCCC"> to</font>

602
00:25:35,860 --> 00:25:45,549
exploit bug yeah so it's this one was

603
00:25:39,789 --> 00:25:49,870
pretty fun we'll talk a<font color="#E5E5E5"> bit about null</font>

604
00:25:45,549 --> 00:25:51,639
pointer<font color="#E5E5E5"> to references so in in general</font>

605
00:25:49,870 --> 00:25:53,678
what we call null pointer references

606
00:25:51,639 --> 00:25:55,479
aren't necessarily not pointed

607
00:25:53,679 --> 00:25:57,340
references it just in general to user

608
00:25:55,480 --> 00:25:59,470
long pointed references just when the

609
00:25:57,340 --> 00:26:03,580
colonel dereference is a pointer that

610
00:25:59,470 --> 00:26:06,250
goes to user none so and of course if at

611
00:26:03,580 --> 00:26:09,100
any time<font color="#CCCCCC"> the colonel trust data in user</font>

612
00:26:06,250 --> 00:26:13,570
space there<font color="#E5E5E5"> is a likely privilege</font>

613
00:26:09,100 --> 00:26:15,459
escalation so of<font color="#E5E5E5"> course the</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> reason</font>

614
00:26:13,570 --> 00:26:17,710
why most people call this null pointer

615
00:26:15,460 --> 00:26:20,769
references because null<font color="#E5E5E5"> is the very</font>

616
00:26:17,710 --> 00:26:23,230
common value because since it's a common

617
00:26:20,769 --> 00:26:25,899
initialization value for pointer it's

618
00:26:23,230 --> 00:26:28,690
also a common error code returned as a

619
00:26:25,899 --> 00:26:32,500
pointer and it's a special value in<font color="#CCCCCC"> C</font>

620
00:26:28,690 --> 00:26:36,070
and<font color="#E5E5E5"> so some people just expect it to be</font>

621
00:26:32,500 --> 00:26:40,059
special to the underlying hardware but

622
00:26:36,070 --> 00:26:44,889
it's absolutely not the case on x86 and

623
00:26:40,059 --> 00:26:47,408
very interestingly they used to not be

624
00:26:44,889 --> 00:26:50,260
exploitable so if you were<font color="#CCCCCC"> familiar with</font>

625
00:26:47,409 --> 00:26:52,840
<font color="#E5E5E5">linux to the zero and the versions</font>

626
00:26:50,260 --> 00:26:57,158
before that actually segmentation was

627
00:26:52,840 --> 00:27:00,610
used in the the colonel had its<font color="#E5E5E5"> its code</font>

628
00:26:57,159 --> 00:27:03,399
its code base and its data<font color="#E5E5E5"> segment base</font>

629
00:27:00,610 --> 00:27:06,189
both above page offset so<font color="#E5E5E5"> basically</font>

630
00:27:03,399 --> 00:27:10,330
above all user column<font color="#E5E5E5"> oh all</font><font color="#CCCCCC"> use our own</font>

631
00:27:06,190 --> 00:27:12,100
<font color="#CCCCCC">data in code so a different pointer</font>

632
00:27:10,330 --> 00:27:14,289
without a segment override would never

633
00:27:12,100 --> 00:27:14,870
reach you turn on which what was quite

634
00:27:14,289 --> 00:27:19,129
convenient

635
00:27:14,870 --> 00:27:21,229
because I mean you explicitly had to

636
00:27:19,130 --> 00:27:23,059
write a segment override when you want

637
00:27:21,230 --> 00:27:25,250
it to reach you turn on so so you

638
00:27:23,059 --> 00:27:29,330
couldn't unexpectedly<font color="#CCCCCC"> rich ozone on</font>

639
00:27:25,250 --> 00:27:31,130
which was a cool feature so Ron pointer

640
00:27:29,330 --> 00:27:32,929
Francis didn't become<font color="#CCCCCC"> two years alone</font>

641
00:27:31,130 --> 00:27:35,690
<font color="#CCCCCC">point early references automatically and</font>

642
00:27:32,930 --> 00:27:38,000
so their destination would be harder to

643
00:27:35,690 --> 00:27:40,220
control of<font color="#E5E5E5"> course you can argue</font><font color="#CCCCCC"> that you</font>

644
00:27:38,000 --> 00:27:42,410
still have some you still have some

645
00:27:40,220 --> 00:27:45,440
control over the<font color="#E5E5E5"> Connors address space</font>

646
00:27:42,410 --> 00:27:48,710
from New Zealand<font color="#E5E5E5"> so first because there</font>

647
00:27:45,440 --> 00:27:49,970
are this usually this hyper space inside

648
00:27:48,710 --> 00:27:52,160
the kind<font color="#E5E5E5"> of space that map's the</font>

649
00:27:49,970 --> 00:27:54,050
physical memory and also because of

650
00:27:52,160 --> 00:27:56,240
course indirectly you control some

651
00:27:54,050 --> 00:27:57,889
kernel structures but still it would<font color="#CCCCCC"> be</font>

652
00:27:56,240 --> 00:28:00,830
way harder to control in to exploit

653
00:27:57,890 --> 00:28:03,020
those bugs in the situation and instead

654
00:28:00,830 --> 00:28:05,990
interestingly I remember that in

655
00:28:03,020 --> 00:28:09,320
2004-2005 we had some interesting

656
00:28:05,990 --> 00:28:10,700
strides with linux kernel developers who

657
00:28:09,320 --> 00:28:13,100
did not understand<font color="#E5E5E5"> the security</font>

658
00:28:10,700 --> 00:28:16,370
consequences of them and it<font color="#E5E5E5"> was not</font><font color="#CCCCCC"> very</font>

659
00:28:13,100 --> 00:28:18,889
<font color="#E5E5E5">clear if if they just expected not to be</font>

660
00:28:16,370 --> 00:28:23,360
special to the the underlying hardware

661
00:28:18,890 --> 00:28:25,429
or if if they still remember the<font color="#E5E5E5"> more</font>

662
00:28:23,360 --> 00:28:27,949
early days of Linux when this was not

663
00:28:25,429 --> 00:28:29,660
exploitable but it was expected<font color="#E5E5E5"> on</font>

664
00:28:27,950 --> 00:28:31,580
another platform so I don't know what

665
00:28:29,660 --> 00:28:33,679
happened<font color="#CCCCCC"> but for some reason a lot of</font>

666
00:28:31,580 --> 00:28:36,500
people didn't think<font color="#E5E5E5"> this this was an</font>

667
00:28:33,679 --> 00:28:38,450
issue and it was very surprising because

668
00:28:36,500 --> 00:28:40,550
it<font color="#CCCCCC"> wasn't the most trivial and easy to</font>

669
00:28:38,450 --> 00:28:44,240
understand issues but many people didn't

670
00:28:40,550 --> 00:28:46,850
didn't get it and so even even recently

671
00:28:44,240 --> 00:28:48,620
a few of you even<font color="#E5E5E5"> seen your kernel</font>

672
00:28:46,850 --> 00:28:50,840
developers in Linux didn't didn't

673
00:28:48,620 --> 00:28:53,360
understand that we will talk about a map

674
00:28:50,840 --> 00:28:55,309
<font color="#E5E5E5">minute or later because now no this this</font>

675
00:28:53,360 --> 00:28:57,889
problem I think is<font color="#E5E5E5"> very widely</font>

676
00:28:55,309 --> 00:29:00,110
understood and there is<font color="#CCCCCC"> even a feature</font>

677
00:28:57,890 --> 00:29:03,650
and the linux kernel to prefer to<font color="#E5E5E5"> try</font>

678
00:29:00,110 --> 00:29:05,479
and<font color="#E5E5E5"> prevent you to exploit this so we</font>

679
00:29:03,650 --> 00:29:09,830
found we found of course<font color="#E5E5E5"> a couple of</font>

680
00:29:05,480 --> 00:29:12,890
those types of bugs one of one of<font color="#E5E5E5"> those</font>

681
00:29:09,830 --> 00:29:17,059
what the linux kernel sucks n page but

682
00:29:12,890 --> 00:29:18,830
we found<font color="#E5E5E5"> last august and it's quite well</font>

683
00:29:17,059 --> 00:29:21,800
<font color="#E5E5E5">known and actually it was nominated for</font>

684
00:29:18,830 --> 00:29:24,919
a pony award yesterday because it

685
00:29:21,800 --> 00:29:26,990
affected<font color="#E5E5E5"> our Linux kernels from to dot</font>

686
00:29:24,920 --> 00:29:27,740
for revisions and to that six revisions

687
00:29:26,990 --> 00:29:30,559
to

688
00:29:27,740 --> 00:29:32,630
so it was<font color="#CCCCCC"> 10</font><font color="#E5E5E5"> years worth of</font><font color="#CCCCCC"> Linux</font>

689
00:29:30,559 --> 00:29:35,059
cannons and every major distribution

690
00:29:32,630 --> 00:29:36,920
ship venerable<font color="#E5E5E5"> cannons it was an odd</font>

691
00:29:35,059 --> 00:29:40,070
function pointer dereference which makes

692
00:29:36,920 --> 00:29:43,670
it even easier to to exploit it was very

693
00:29:40,070 --> 00:29:45,889
very very easy to exploit and we've seen

694
00:29:43,670 --> 00:29:49,700
public exploits<font color="#CCCCCC"> for a lot of</font>

695
00:29:45,890 --> 00:29:52,340
architectures every every saw so the way

696
00:29:49,700 --> 00:29:55,160
<font color="#CCCCCC">it works is that</font><font color="#E5E5E5"> the reason for this is</font>

697
00:29:52,340 --> 00:29:58,189
<font color="#E5E5E5">every circuit in the linux kernel every</font>

698
00:29:55,160 --> 00:30:00,440
type of circuit has a set of functions

699
00:29:58,190 --> 00:30:02,840
pointers associated with it called proto

700
00:30:00,440 --> 00:30:06,500
ops which stands for protocol operations

701
00:30:02,840 --> 00:30:09,470
and those protocol operations they

702
00:30:06,500 --> 00:30:11,030
implement the various operations that

703
00:30:09,470 --> 00:30:14,450
can be performed on the circuit so it

704
00:30:11,030 --> 00:30:17,899
can<font color="#E5E5E5"> be except buying shut down etc and</font>

705
00:30:14,450 --> 00:30:19,640
and thanks to<font color="#E5E5E5"> this the general circuit</font>

706
00:30:17,900 --> 00:30:22,100
management code doesn't have to know

707
00:30:19,640 --> 00:30:23,780
<font color="#E5E5E5">about the underlying transport or</font>

708
00:30:22,100 --> 00:30:26,750
protocol because everything is

709
00:30:23,780 --> 00:30:28,580
abstracted away so that that's<font color="#E5E5E5"> quite</font>

710
00:30:26,750 --> 00:30:30,530
convenient and you can see you<font color="#CCCCCC"> can see</font>

711
00:30:28,580 --> 00:30:33,379
here the proto of definition as

712
00:30:30,530 --> 00:30:36,320
available in<font color="#E5E5E5"> include / news / net dot H</font>

713
00:30:33,380 --> 00:30:38,780
so you see a struct photo ops with

714
00:30:36,320 --> 00:30:44,240
different operation release<font color="#E5E5E5"> bind except</font>

715
00:30:38,780 --> 00:30:45,740
and so some basically what drivers do it

716
00:30:44,240 --> 00:30:48,590
they implement the operation they

717
00:30:45,740 --> 00:30:50,300
support<font color="#E5E5E5"> and they point to opera and they</font>

718
00:30:48,590 --> 00:30:52,189
implement the operation they support<font color="#E5E5E5"> and</font>

719
00:30:50,300 --> 00:30:54,919
they point to operation they don't

720
00:30:52,190 --> 00:30:56,900
support to predefined Colonel Stubbs so

721
00:30:54,920 --> 00:30:59,600
in this illustration you see<font color="#E5E5E5"> for</font>

722
00:30:56,900 --> 00:31:02,210
instance release points to my release

723
00:30:59,600 --> 00:31:05,270
which is an implementation<font color="#E5E5E5"> bind to mind</font>

724
00:31:02,210 --> 00:31:08,090
bind but<font color="#CCCCCC"> accept</font><font color="#E5E5E5"> appoints to sock</font><font color="#CCCCCC"> know</font>

725
00:31:05,270 --> 00:31:11,629
except which basically means this is

726
00:31:08,090 --> 00:31:14,030
unknown implemented operation so this

727
00:31:11,630 --> 00:31:17,059
model is really fragile if you if you

728
00:31:14,030 --> 00:31:19,940
think about it because<font color="#CCCCCC"> anytime</font><font color="#E5E5E5"> you add a</font>

729
00:31:17,059 --> 00:31:21,470
new operations on sockets what do<font color="#E5E5E5"> you</font>

730
00:31:19,940 --> 00:31:24,800
need to<font color="#CCCCCC"> do you need</font><font color="#E5E5E5"> to update all</font>

731
00:31:21,470 --> 00:31:29,720
drivers and point the new operation to a

732
00:31:24,800 --> 00:31:31,280
stab or implement it and it's<font color="#E5E5E5"> actually a</font>

733
00:31:29,720 --> 00:31:33,650
lot of code to update because it means

734
00:31:31,280 --> 00:31:37,820
all drivers right and on Linux it's it's

735
00:31:33,650 --> 00:31:40,490
it's a lot of<font color="#CCCCCC"> of drivers and also since</font>

736
00:31:37,820 --> 00:31:41,439
<font color="#E5E5E5">macros are used for initializations you</font>

737
00:31:40,490 --> 00:31:44,379
also need<font color="#CCCCCC"> to update</font>

738
00:31:41,440 --> 00:31:48,129
all those macros so of course<font color="#E5E5E5"> it went</font>

739
00:31:44,379 --> 00:31:51,158
wrong and when<font color="#E5E5E5"> a 16-page was was added</font>

740
00:31:48,129 --> 00:31:54,519
so<font color="#CCCCCC"> 16-page</font><font color="#E5E5E5"> is quite all</font><font color="#CCCCCC"> I think it</font><font color="#E5E5E5"> was</font>

741
00:31:51,159 --> 00:31:58,029
odd in<font color="#E5E5E5"> Linux to the two actually well</font>

742
00:31:54,519 --> 00:32:00,009
anyway so when<font color="#E5E5E5"> 16-page was added it</font>

743
00:31:58,029 --> 00:32:01,419
assumed the corresponding proto ops

744
00:32:00,009 --> 00:32:04,690
field will always be correctly

745
00:32:01,419 --> 00:32:06,429
initialized and well that's<font color="#E5E5E5"> that was not</font>

746
00:32:04,690 --> 00:32:09,370
a good assumption so you can see here

747
00:32:06,429 --> 00:32:11,529
the code from 16 page and if you read

748
00:32:09,370 --> 00:32:14,768
the very bottom line it just returns

749
00:32:11,529 --> 00:32:18,340
suck-ups<font color="#CCCCCC"> sent page without checking that</font>

750
00:32:14,769 --> 00:32:20,350
this is not null so of<font color="#E5E5E5"> course it went</font>

751
00:32:18,340 --> 00:32:22,809
wrong and it was very<font color="#E5E5E5"> wrong because</font>

752
00:32:20,350 --> 00:32:25,389
first a lot of drivers did not get

753
00:32:22,809 --> 00:32:28,600
properly updated but the really funny

754
00:32:25,389 --> 00:32:31,029
thing<font color="#CCCCCC"> that we found out or that the the</font>

755
00:32:28,600 --> 00:32:33,399
very<font color="#E5E5E5"> sock up wrap macro which is used to</font>

756
00:32:31,029 --> 00:32:36,009
initialize a lot of drivers had the bug

757
00:32:33,399 --> 00:32:37,959
and<font color="#CCCCCC"> the burg is quite circle I mean if</font>

758
00:32:36,009 --> 00:32:41,440
you won't take a look at some it's not

759
00:32:37,960 --> 00:32:43,750
trivial to spot i would<font color="#E5E5E5"> say because the</font>

760
00:32:41,440 --> 00:32:47,169
macro itself uses a lot of all those

761
00:32:43,750 --> 00:32:49,299
macros it's it's a mess so<font color="#E5E5E5"> basically</font>

762
00:32:47,169 --> 00:32:52,210
what happened is for many drivers even

763
00:32:49,299 --> 00:32:55,389
<font color="#CCCCCC">those which had been updated sent page</font>

764
00:32:52,210 --> 00:32:57,909
was implicitly initialized to know so

765
00:32:55,389 --> 00:33:00,699
well 16 page would happily start

766
00:32:57,909 --> 00:33:02,110
executing code at null for you so the

767
00:33:00,700 --> 00:33:05,139
expectation was<font color="#E5E5E5"> just you map your</font>

768
00:33:02,110 --> 00:33:08,350
shellcode null you get you you you

769
00:33:05,139 --> 00:33:11,139
trigger send page for instance by using

770
00:33:08,350 --> 00:33:12,908
the sent file system call and you get

771
00:33:11,139 --> 00:33:14,649
<font color="#CCCCCC">your</font><font color="#E5E5E5"> code executed so we've wrote a</font>

772
00:33:12,909 --> 00:33:18,429
trivial exploit for this that we share

773
00:33:14,649 --> 00:33:21,070
<font color="#CCCCCC">with vendors and but other people have</font>

774
00:33:18,429 --> 00:33:25,029
written public exploits for like pretty

775
00:33:21,070 --> 00:33:28,240
much every every popular architecture so

776
00:33:25,029 --> 00:33:30,970
you can find this is ed<font color="#CCCCCC"> online shortly</font>

777
00:33:28,240 --> 00:33:37,000
after that we found<font color="#CCCCCC"> another one which</font>

778
00:33:30,970 --> 00:33:40,779
was yeah not not not<font color="#CCCCCC"> this not</font><font color="#E5E5E5"> as bad but</font>

779
00:33:37,000 --> 00:33:42,190
way more complicated it was<font color="#E5E5E5"> possible we</font>

780
00:33:40,779 --> 00:33:44,919
found out<font color="#E5E5E5"> that it</font><font color="#CCCCCC"> was possible to</font>

781
00:33:42,190 --> 00:33:47,500
trigger a special code pass in UDP send

782
00:33:44,919 --> 00:33:50,409
message that would result in calling

783
00:33:47,500 --> 00:33:52,029
some function called IP append data with

784
00:33:50,409 --> 00:33:53,769
<font color="#E5E5E5">a new routing table</font>

785
00:33:52,029 --> 00:33:57,009
the interesting part<font color="#E5E5E5"> of this bug is</font>

786
00:33:53,769 --> 00:33:59,169
mostly that that it's quite<font color="#E5E5E5"> hard to spot</font>

787
00:33:57,009 --> 00:34:02,469
if you look at this function the cut

788
00:33:59,169 --> 00:34:04,330
pass is really complicated and this time

789
00:34:02,469 --> 00:34:06,309
it was a data and I went<font color="#CCCCCC"> under reference</font>

790
00:34:04,330 --> 00:34:09,339
the attacker would control some<font color="#CCCCCC"> canal</font>

791
00:34:06,309 --> 00:34:10,989
data a routing table through address

792
00:34:09,339 --> 00:34:13,750
null and this turned out to<font color="#CCCCCC"> be</font>

793
00:34:10,989 --> 00:34:19,270
exploitable as well<font color="#E5E5E5"> although it was less</font>

794
00:34:13,750 --> 00:34:21,399
<font color="#CCCCCC">trivial you want to talk about this so</font>

795
00:34:19,270 --> 00:34:23,259
another interesting<font color="#CCCCCC"> i admit we worked on</font>

796
00:34:21,399 --> 00:34:26,500
was a use after three in the linear

797
00:34:23,260 --> 00:34:28,000
facing subsystem so if a driver wants to

798
00:34:26,500 --> 00:34:29,918
provide<font color="#CCCCCC"> asynchronous i/o notification</font>

799
00:34:28,000 --> 00:34:32,739
they have a linked list of FA sing

800
00:34:29,918 --> 00:34:34,118
struts they contain the<font color="#CCCCCC"> FDS and the</font>

801
00:34:32,739 --> 00:34:36,699
cause many file structures that they

802
00:34:34,119 --> 00:34:40,149
want to notify when I always available

803
00:34:36,699 --> 00:34:41,439
the same file structure turns out the

804
00:34:40,149 --> 00:34:44,259
same file structure could be in multiple

805
00:34:41,440 --> 00:34:45,940
FAS construct lists and there was a

806
00:34:44,260 --> 00:34:49,629
<font color="#E5E5E5">special one specifically for locked</font>

807
00:34:45,940 --> 00:34:51,760
files if the file was locked and then

808
00:34:49,629 --> 00:34:54,038
closed there was a logical book where

809
00:34:51,760 --> 00:34:56,829
<font color="#E5E5E5">the file structure would be removed from</font>

810
00:34:54,039 --> 00:34:57,970
only the locked files linked<font color="#E5E5E5"> list the</font>

811
00:34:56,829 --> 00:34:59,349
structure<font color="#CCCCCC"> will be freed even though</font><font color="#E5E5E5"> it</font>

812
00:34:57,970 --> 00:35:02,828
appeared multiple<font color="#E5E5E5"> lists so then you have</font>

813
00:34:59,349 --> 00:35:04,539
this this the structure<font color="#E5E5E5"> in in the second</font>

814
00:35:02,829 --> 00:35:06,130
list that in release that has been

815
00:35:04,539 --> 00:35:11,230
passed out to anybody else who wants<font color="#CCCCCC"> her</font>

816
00:35:06,130 --> 00:35:12,789
some<font color="#CCCCCC"> came alok buffer so the driver</font>

817
00:35:11,230 --> 00:35:19,000
still<font color="#E5E5E5"> had a reference to this plead file</font>

818
00:35:12,789 --> 00:35:20,770
structure so this was we vote a proof of

819
00:35:19,000 --> 00:35:22,029
concept but we we didn't<font color="#E5E5E5"> get next by</font>

820
00:35:20,770 --> 00:35:23,829
working simply because it was really

821
00:35:22,029 --> 00:35:27,819
really complicated but we released the

822
00:35:23,829 --> 00:35:30,549
information about it in<font color="#E5E5E5"> Linux and a guy</font>

823
00:35:27,819 --> 00:35:33,730
called the Gabrielle<font color="#CCCCCC"> campanha work next</font>

824
00:35:30,549 --> 00:35:35,170
point for it and he wrote an article in

825
00:35:33,730 --> 00:35:39,760
a<font color="#CCCCCC"> French their information security</font>

826
00:35:35,170 --> 00:35:41,380
magazine called misc mi SE I don't read

827
00:35:39,760 --> 00:35:42,579
French but I'm told from from<font color="#E5E5E5"> French</font>

828
00:35:41,380 --> 00:35:43,779
speakers that it was<font color="#E5E5E5"> actually an awesome</font>

829
00:35:42,579 --> 00:35:46,900
article so if you do a friend she should

830
00:35:43,779 --> 00:35:48,789
check it<font color="#E5E5E5"> out he used some really cool</font>

831
00:35:46,900 --> 00:35:53,020
tricks to get a reliable and to make a

832
00:35:48,789 --> 00:35:56,039
reliable code execution so yeah you

833
00:35:53,020 --> 00:35:56,038
should check<font color="#E5E5E5"> out a few interested</font>

834
00:35:56,690 --> 00:36:03,770
and so this bug is in net be as it's<font color="#E5E5E5"> the</font>

835
00:36:01,250 --> 00:36:05,869
only net BS debug we are talking<font color="#E5E5E5"> about</font>

836
00:36:03,770 --> 00:36:10,369
<font color="#E5E5E5">today but we really love this book</font>

837
00:36:05,869 --> 00:36:13,400
actually investigating this bug took me

838
00:36:10,369 --> 00:36:15,349
more time than<font color="#E5E5E5"> then for a lot of other</font>

839
00:36:13,400 --> 00:36:18,680
bugs we are talking<font color="#CCCCCC"> about</font><font color="#E5E5E5"> today it was</font>

840
00:36:15,349 --> 00:36:20,930
really<font color="#E5E5E5"> nice so we found out well I mean</font>

841
00:36:18,680 --> 00:36:24,529
it's documented in the Intel manuals but

842
00:36:20,930 --> 00:36:27,319
it's not very easy to find that an inter

843
00:36:24,530 --> 00:36:32,690
a privilege<font color="#CCCCCC"> irate can fail before the</font>

844
00:36:27,319 --> 00:36:35,990
previous switch occurs so what we called

845
00:36:32,690 --> 00:36:38,300
we call this the the commit point where

846
00:36:35,990 --> 00:36:41,629
the previous<font color="#E5E5E5"> which occurs so we said I</font>

847
00:36:38,300 --> 00:36:45,950
read can fail pre-commit so for<font color="#E5E5E5"> instance</font>

848
00:36:41,630 --> 00:36:49,010
if the restored<font color="#CCCCCC"> eip is passed the</font><font color="#E5E5E5"> code</font>

849
00:36:45,950 --> 00:36:52,490
segment limit general protection fault

850
00:36:49,010 --> 00:36:54,829
will occur while in kernel mode so no

851
00:36:52,490 --> 00:36:56,419
<font color="#CCCCCC">proofs which will occur so what's what</font>

852
00:36:54,829 --> 00:36:59,480
what difference<font color="#E5E5E5"> does</font><font color="#CCCCCC"> it make that</font><font color="#E5E5E5"> no</font>

853
00:36:56,420 --> 00:37:02,030
previous which occurs well if no prints

854
00:36:59,480 --> 00:37:04,730
which occurs no statutory<font color="#CCCCCC"> nose tax which</font>

855
00:37:02,030 --> 00:37:07,010
occurs between user<font color="#CCCCCC"> London and kernel</font>

856
00:37:04,730 --> 00:37:09,079
and stacks so basically<font color="#E5E5E5"> you have no</font>

857
00:37:07,010 --> 00:37:11,359
saved<font color="#E5E5E5"> stack information on the trap</font>

858
00:37:09,079 --> 00:37:16,099
frame so if you're operating system is

859
00:37:11,359 --> 00:37:17,810
not expecting this and net<font color="#E5E5E5"> bsd was not</font>

860
00:37:16,099 --> 00:37:19,940
expecting this to happen so it was

861
00:37:17,810 --> 00:37:22,759
expecting a full trap frame all the time

862
00:37:19,940 --> 00:37:25,130
well basically<font color="#E5E5E5"> you will have your trap</font>

863
00:37:22,760 --> 00:37:27,349
frame shifted so of course you can you

864
00:37:25,130 --> 00:37:30,980
can play with this and and and try to

865
00:37:27,349 --> 00:37:33,800
exploit this and so we were thinking

866
00:37:30,980 --> 00:37:37,849
about<font color="#CCCCCC"> this and we also found out that</font>

867
00:37:33,800 --> 00:37:42,530
the way the the<font color="#E5E5E5"> non-executive will stack</font>

868
00:37:37,849 --> 00:37:45,890
emulation work on net bsd is they they

869
00:37:42,530 --> 00:37:51,560
they put us<font color="#CCCCCC"> a</font><font color="#E5E5E5"> cut segment limit just</font>

870
00:37:45,890 --> 00:37:54,020
below the stack so what and we found<font color="#CCCCCC"> out</font>

871
00:37:51,560 --> 00:37:56,150
that that during a legitimate programs

872
00:37:54,020 --> 00:37:59,210
execution we could we could trigger the

873
00:37:56,150 --> 00:38:01,099
bug<font color="#E5E5E5"> because if you happen to</font><font color="#CCCCCC"> have</font>

874
00:37:59,210 --> 00:38:03,500
<font color="#E5E5E5">legitimate call on the stack so that</font>

875
00:38:01,099 --> 00:38:07,050
happens for<font color="#E5E5E5"> instance if you have nested</font>

876
00:38:03,500 --> 00:38:10,110
functions in GCC you can get

877
00:38:07,050 --> 00:38:12,300
champlin on the stack so if<font color="#CCCCCC"> you're</font><font color="#E5E5E5"> if</font>

878
00:38:10,110 --> 00:38:14,190
you're for instance in in a signal

879
00:38:12,300 --> 00:38:17,040
<font color="#E5E5E5">handler in the kernel and you return</font>

880
00:38:14,190 --> 00:38:19,590
from the signal handler to to this

881
00:38:17,040 --> 00:38:22,050
trampoline on the<font color="#E5E5E5"> stack for a nested</font>

882
00:38:19,590 --> 00:38:25,920
function you will start you will

883
00:38:22,050 --> 00:38:27,780
directly return from Colonel to code

884
00:38:25,920 --> 00:38:30,660
that actually passed the segment limit

885
00:38:27,780 --> 00:38:33,540
so that's exactly<font color="#E5E5E5"> the situation we</font>

886
00:38:30,660 --> 00:38:36,120
described here and so what this means is

887
00:38:33,540 --> 00:38:38,610
this book can actually happen like this

888
00:38:36,120 --> 00:38:41,880
in in real life and<font color="#E5E5E5"> just crush net bsd</font>

889
00:38:38,610 --> 00:38:44,460
kernels so we reported this a long time

890
00:38:41,880 --> 00:38:46,800
ago<font color="#CCCCCC"> i think</font><font color="#E5E5E5"> more a year and a half ago</font>

891
00:38:44,460 --> 00:38:50,520
and<font color="#CCCCCC"> i think it's still not corrected as</font>

892
00:38:46,800 --> 00:38:52,860
far as we know<font color="#CCCCCC"> and that that one was</font>

893
00:38:50,520 --> 00:38:56,520
really interested interesting because

894
00:38:52,860 --> 00:39:01,260
actually<font color="#CCCCCC"> tavis used used this</font><font color="#E5E5E5"> streak</font>

895
00:38:56,520 --> 00:39:02,820
later for his auntie vdm exploit which<font color="#E5E5E5"> i</font>

896
00:39:01,260 --> 00:39:07,410
think<font color="#E5E5E5"> you're going to take talk about</font>

897
00:39:02,820 --> 00:39:09,210
now<font color="#CCCCCC"> okay so after we discovered these</font>

898
00:39:07,410 --> 00:39:11,730
fun bugs in various interrupt handlers

899
00:39:09,210 --> 00:39:13,290
we decided<font color="#CCCCCC"> this was going to be some</font>

900
00:39:11,730 --> 00:39:15,300
food for research so we decided to

901
00:39:13,290 --> 00:39:18,270
<font color="#E5E5E5">remain altered the remaining interrupt</font>

902
00:39:15,300 --> 00:39:20,340
handlers we defined so we found one

903
00:39:18,270 --> 00:39:21,780
section of code in ki<font color="#CCCCCC"> Tripodi which is</font>

904
00:39:20,340 --> 00:39:24,540
the name of the GP trap handler in

905
00:39:21,780 --> 00:39:26,370
microsoft public symbols and we<font color="#E5E5E5"> found</font>

906
00:39:24,540 --> 00:39:28,470
one location where<font color="#CCCCCC"> it appeared to trust</font>

907
00:39:26,370 --> 00:39:31,589
the contents of the trap frame this was

908
00:39:28,470 --> 00:39:33,029
a bit of a WTF moment for us where we

909
00:39:31,590 --> 00:39:36,210
saw we saw this code that was<font color="#E5E5E5"> obviously</font>

910
00:39:33,030 --> 00:39:37,440
doing something completely bizarre we

911
00:39:36,210 --> 00:39:40,020
could tell<font color="#E5E5E5"> that this was a component of</font>

912
00:39:37,440 --> 00:39:41,850
the virtual 8086 mode monitor simply

913
00:39:40,020 --> 00:39:47,009
<font color="#E5E5E5">because the the branch to reach this</font>

914
00:39:41,850 --> 00:39:51,690
code was was checking the vm flag in the

915
00:39:47,010 --> 00:39:54,090
e clogs image so it the reaching this

916
00:39:51,690 --> 00:39:55,170
code was was really hard work and it

917
00:39:54,090 --> 00:39:56,730
took about two weeks of research to

918
00:39:55,170 --> 00:39:58,680
figure out how to start of each this

919
00:39:56,730 --> 00:40:01,530
code and on top<font color="#E5E5E5"> of that we</font><font color="#CCCCCC"> need to</font><font color="#E5E5E5"> write</font>

920
00:39:58,680 --> 00:40:02,879
a reliable exploit but<font color="#E5E5E5"> I think it was</font>

921
00:40:01,530 --> 00:40:04,440
<font color="#E5E5E5">worth it at the end we found a really</font>

922
00:40:02,880 --> 00:40:08,580
fascinating an ancient vulnerability in

923
00:40:04,440 --> 00:40:09,750
really<font color="#E5E5E5"> the core of Windows NT and yeah I</font>

924
00:40:08,580 --> 00:40:11,250
<font color="#E5E5E5">actually want a pony award for this last</font>

925
00:40:09,750 --> 00:40:13,270
night so I<font color="#CCCCCC"> think it</font><font color="#E5E5E5"> was like it was</font>

926
00:40:11,250 --> 00:40:17,560
worth it

927
00:40:13,270 --> 00:40:21,670
so this<font color="#CCCCCC"> is a recap</font><font color="#E5E5E5"> of some of the</font>

928
00:40:17,560 --> 00:40:23,890
features that we needed to exploit this

929
00:40:21,670 --> 00:40:25,570
if you remember most programming you'll

930
00:40:23,890 --> 00:40:28,299
be familiar with in 21 which is used to

931
00:40:25,570 --> 00:40:29,950
invoke system services but if you wanted

932
00:40:28,300 --> 00:40:32,560
to make a bios call to interact<font color="#CCCCCC"> with the</font>

933
00:40:29,950 --> 00:40:34,120
hardware than you needed call other

934
00:40:32,560 --> 00:40:35,770
interrupt handlers most people remember

935
00:40:34,120 --> 00:40:40,299
in 10<font color="#E5E5E5"> because it was used for things</font>

936
00:40:35,770 --> 00:40:43,660
like the demo scene<font color="#CCCCCC"> I'd also</font><font color="#E5E5E5"> that was</font>

937
00:40:40,300 --> 00:40:45,310
quite famous but<font color="#E5E5E5"> obviously you can't you</font>

938
00:40:43,660 --> 00:40:46,810
can't allow a protected mode task to

939
00:40:45,310 --> 00:40:50,170
<font color="#E5E5E5">interact the</font><font color="#CCCCCC"> interactive hardware</font><font color="#E5E5E5"> this</font>

940
00:40:46,810 --> 00:40:52,000
way so in virtual 8086 mode these are

941
00:40:50,170 --> 00:40:55,900
services are<font color="#E5E5E5"> intercepted by the monitor</font>

942
00:40:52,000 --> 00:40:58,120
so<font color="#E5E5E5"> Intel Intel calls this concept</font>

943
00:40:55,900 --> 00:41:01,150
sensitive instructions so basically what

944
00:40:58,120 --> 00:41:03,100
they do is any operation that a real

945
00:41:01,150 --> 00:41:06,160
real mode program would be<font color="#E5E5E5"> expected</font>

946
00:41:03,100 --> 00:41:08,650
would expect to<font color="#E5E5E5"> work is made sensitive</font>

947
00:41:06,160 --> 00:41:11,770
and that basically means that<font color="#CCCCCC"> in hell</font>

948
00:41:08,650 --> 00:41:16,780
will will cause this GP and give the

949
00:41:11,770 --> 00:41:21,130
operating system a chance to to fix this

950
00:41:16,780 --> 00:41:23,500
up or emulate it or do whatever<font color="#CCCCCC"> ones so</font>

951
00:41:21,130 --> 00:41:25,180
in this way programs that could never be

952
00:41:23,500 --> 00:41:28,180
allowed<font color="#CCCCCC"> to work in protected mode can</font>

953
00:41:25,180 --> 00:41:29,919
can all the services they expect<font color="#E5E5E5"> to be</font>

954
00:41:28,180 --> 00:41:31,299
able to use can be faked and if they can

955
00:41:29,920 --> 00:41:35,680
<font color="#E5E5E5">they can think they were working</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> a</font>

956
00:41:31,300 --> 00:41:36,850
real and I star system or whatever so

957
00:41:35,680 --> 00:41:38,080
yeah these actions trap and then the

958
00:41:36,850 --> 00:41:43,960
colonel is given an opportunity to

959
00:41:38,080 --> 00:41:45,850
decide how it wants to proceed so so the

960
00:41:43,960 --> 00:41:48,070
design<font color="#E5E5E5"> of the the virtual 8086 mode</font>

961
00:41:45,850 --> 00:41:50,560
monitor in Windows NT has really never

962
00:41:48,070 --> 00:41:52,600
changed since it's since imputation<font color="#E5E5E5"> and</font>

963
00:41:50,560 --> 00:41:53,710
implementation in the early 90s and in

964
00:41:52,600 --> 00:41:55,810
fact yeah if you download these old

965
00:41:53,710 --> 00:41:57,370
service packs from ftp microsoft com for

966
00:41:55,810 --> 00:41:58,750
old out-of-date versions that they don't

967
00:41:57,370 --> 00:42:03,400
support you can you can still<font color="#E5E5E5"> get a copy</font>

968
00:41:58,750 --> 00:42:05,140
these kernels they<font color="#E5E5E5"> even include public</font>

969
00:42:03,400 --> 00:42:06,550
symbols but obviously they're in DVD

970
00:42:05,140 --> 00:42:08,890
format not PD be like we use nowadays

971
00:42:06,550 --> 00:42:14,380
but<font color="#E5E5E5"> still you can still pass them and</font>

972
00:42:08,890 --> 00:42:15,970
and look around it's a kind of

973
00:42:14,380 --> 00:42:18,150
archaeology for code I guess it's kind

974
00:42:15,970 --> 00:42:18,149
of fun

975
00:42:18,440 --> 00:42:21,770
so yeah in order to<font color="#CCCCCC"> support these by</font><font color="#E5E5E5"> our</font>

976
00:42:20,359 --> 00:42:23,450
server two teams<font color="#E5E5E5"> and stuff exists in the</font>

977
00:42:21,770 --> 00:42:26,930
GP trap handler that the restores

978
00:42:23,450 --> 00:42:28,279
execution context for the trap frame in

979
00:42:26,930 --> 00:42:30,109
order to access this code it's

980
00:42:28,280 --> 00:42:31,190
authenticated but<font color="#E5E5E5"> these were by magic</font>

981
00:42:30,109 --> 00:42:34,700
values that we already<font color="#E5E5E5"> knew that</font><font color="#CCCCCC"> we</font>

982
00:42:31,190 --> 00:42:36,109
could Forge from from<font color="#E5E5E5"> VMware exploit and</font>

983
00:42:34,700 --> 00:42:38,779
from our<font color="#E5E5E5"> previous work on interrupt</font>

984
00:42:36,109 --> 00:42:40,160
handlers so we knew that we were we will

985
00:42:38,780 --> 00:42:42,920
under something that we could we could

986
00:42:40,160 --> 00:42:44,149
really control there were<font color="#E5E5E5"> lots of</font>

987
00:42:42,920 --> 00:42:46,819
hurdles on the way and it took us a long

988
00:42:44,150 --> 00:42:49,099
time to get to reach this but each one

989
00:42:46,819 --> 00:42:53,390
<font color="#CCCCCC">was an interesting exercise and I'm</font>

990
00:42:49,099 --> 00:42:54,950
<font color="#CCCCCC">talking</font><font color="#E5E5E5"> about them so how do you</font>

991
00:42:53,390 --> 00:42:57,710
interact with<font color="#E5E5E5"> the virtual 8086 polk</font>

992
00:42:54,950 --> 00:42:59,689
monitor on<font color="#CCCCCC"> windows NT it's</font><font color="#E5E5E5"> a non</font>

993
00:42:57,710 --> 00:43:03,020
undocumented system service called NT

994
00:42:59,690 --> 00:43:04,250
vdm control it's authenticated you're

995
00:43:03,020 --> 00:43:06,109
not allowed to access it and as you have

996
00:43:04,250 --> 00:43:09,470
<font color="#E5E5E5">a special flag in your process structure</font>

997
00:43:06,109 --> 00:43:12,078
called vdm allowed you can't set this

998
00:43:09,470 --> 00:43:13,430
flag unless you<font color="#E5E5E5"> have setc be privileged</font>

999
00:43:12,079 --> 00:43:15,440
and you'll use something like I think

1000
00:43:13,430 --> 00:43:18,529
it's empty system information or set

1001
00:43:15,440 --> 00:43:22,730
process information and<font color="#E5E5E5"> you need s ettv</font>

1002
00:43:18,530 --> 00:43:24,140
privilege so if you have setc be

1003
00:43:22,730 --> 00:43:26,270
privileged like STC<font color="#CCCCCC"> bears trusted code</font>

1004
00:43:24,140 --> 00:43:27,920
base then you're already when there was

1005
00:43:26,270 --> 00:43:29,180
privileged processes on the system<font color="#E5E5E5"> and</font>

1006
00:43:27,920 --> 00:43:32,690
you don't really need to escape images

1007
00:43:29,180 --> 00:43:33,980
any further so this is so it's<font color="#E5E5E5"> not</font>

1008
00:43:32,690 --> 00:43:36,980
immediately obvious that you cancel you

1009
00:43:33,980 --> 00:43:38,300
can still access the system call but you

1010
00:43:36,980 --> 00:43:39,950
can defeat this really easily all you

1011
00:43:38,300 --> 00:43:42,589
have to do is invoke the real NTV DMSO

1012
00:43:39,950 --> 00:43:44,750
subsystem and then use the winter

1013
00:43:42,589 --> 00:43:47,089
<font color="#CCCCCC">youtube api</font><font color="#E5E5E5"> create remote</font><font color="#CCCCCC"> led to execute</font>

1014
00:43:44,750 --> 00:43:48,470
within within it this way your thread is

1015
00:43:47,089 --> 00:43:50,089
meeting with in a<font color="#CCCCCC"> process that already</font>

1016
00:43:48,470 --> 00:43:54,020
has this flag set in its<font color="#E5E5E5"> media in its</font>

1017
00:43:50,089 --> 00:43:55,279
energy process structure so yeah auntie

1018
00:43:54,020 --> 00:43:57,290
vdm control is completely undocumented

1019
00:43:55,280 --> 00:43:59,000
the best documentation for it is really

1020
00:43:57,290 --> 00:44:01,430
<font color="#CCCCCC">Alex Insp was already reverse engineered</font>

1021
00:43:59,000 --> 00:44:04,579
it so that you can work out<font color="#E5E5E5"> the API from</font>

1022
00:44:01,430 --> 00:44:05,930
his code in react OS so yeah he's

1023
00:44:04,579 --> 00:44:09,349
already done<font color="#E5E5E5"> all the hard work so it's</font>

1024
00:44:05,930 --> 00:44:10,640
you<font color="#E5E5E5"> can understand it that way this is</font>

1025
00:44:09,349 --> 00:44:11,900
still of other special cases that we

1026
00:44:10,640 --> 00:44:16,368
needed to<font color="#E5E5E5"> understand for this particular</font>

1027
00:44:11,900 --> 00:44:19,760
bug we needed to bypass things like a

1028
00:44:16,369 --> 00:44:22,160
checks for structure sizes and magic

1029
00:44:19,760 --> 00:44:24,560
checks and so on it took some<font color="#E5E5E5"> time but</font>

1030
00:44:22,160 --> 00:44:27,569
yeah Alex<font color="#E5E5E5"> I know speech code in Viet Wes</font>

1031
00:44:24,560 --> 00:44:32,670
was really hard to understand<font color="#E5E5E5"> this stuff</font>

1032
00:44:27,569 --> 00:44:35,459
so this code that we found in the<font color="#CCCCCC"> trial</font>

1033
00:44:32,670 --> 00:44:37,589
in the in the GP trap handler was gutted

1034
00:44:35,459 --> 00:44:40,589
by a test for a specific<font color="#E5E5E5"> CSE I pee pad</font>

1035
00:44:37,589 --> 00:44:42,239
we can forge these with these trap

1036
00:44:40,589 --> 00:44:44,219
frames by making<font color="#CCCCCC"> an</font><font color="#E5E5E5"> I read failed but we</font>

1037
00:44:42,239 --> 00:44:45,390
still you can't request to turn into an

1038
00:44:44,219 --> 00:44:46,799
allergy code segment obviously that

1039
00:44:45,390 --> 00:44:50,969
would be stupid because you're just

1040
00:44:46,799 --> 00:44:52,739
you're just using the RPL<font color="#CCCCCC"> 0</font><font color="#E5E5E5"> a value and</font>

1041
00:44:50,969 --> 00:44:55,140
then you'd get instant kernel code

1042
00:44:52,739 --> 00:44:58,259
execution so nobody would just be silly

1043
00:44:55,140 --> 00:45:00,150
enough to make<font color="#E5E5E5"> that mistake but as we</font>

1044
00:44:58,259 --> 00:45:02,430
vote in OCS loses its magic value in

1045
00:45:00,150 --> 00:45:06,329
virtual 86 mode because you need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be</font>

1046
00:45:02,430 --> 00:45:08,999
able to access<font color="#E5E5E5"> these</font><font color="#CCCCCC"> discs 2008 real</font>

1047
00:45:06,329 --> 00:45:13,920
address space so it's completely

1048
00:45:08,999 --> 00:45:16,319
reasonable to request any value but we

1049
00:45:13,920 --> 00:45:19,199
<font color="#E5E5E5">still need</font><font color="#CCCCCC"> to cause i</font><font color="#E5E5E5"> right</font><font color="#CCCCCC"> to GP and we</font>

1050
00:45:16,319 --> 00:45:21,329
did this by by setting the TF flag in

1051
00:45:19,199 --> 00:45:23,130
the e flags image when returning so

1052
00:45:21,329 --> 00:45:25,440
<font color="#E5E5E5">intel actually considers this sensitive</font>

1053
00:45:23,130 --> 00:45:28,140
and<font color="#CCCCCC"> had ins control over the virtual</font>

1054
00:45:25,440 --> 00:45:30,719
8086 mode monitor but this is actually

1055
00:45:28,140 --> 00:45:31,709
<font color="#E5E5E5">poorly documented and in fact there's no</font>

1056
00:45:30,719 --> 00:45:34,589
<font color="#E5E5E5">mention of this at all in the</font>

1057
00:45:31,709 --> 00:45:36,749
documentation<font color="#E5E5E5"> and from research we know</font>

1058
00:45:34,589 --> 00:45:38,729
that early versions<font color="#CCCCCC"> of the pentium</font>

1059
00:45:36,749 --> 00:45:41,549
processor would impact not treat<font color="#CCCCCC"> IRA</font>

1060
00:45:38,729 --> 00:45:44,459
flags TF sat in the e flags images

1061
00:45:41,549 --> 00:45:46,890
sensitive and that wasn't considered

1062
00:45:44,459 --> 00:45:48,089
sensitive at all but apparently<font color="#E5E5E5"> doing</font>

1063
00:45:46,890 --> 00:45:51,420
some later revisions of the pentium

1064
00:45:48,089 --> 00:45:56,549
<font color="#E5E5E5">intel updated this and and did consider</font>

1065
00:45:51,420 --> 00:45:58,469
a sensitive and in fact this<font color="#CCCCCC"> is really</font>

1066
00:45:56,549 --> 00:46:01,559
documented by other members named the

1067
00:45:58,469 --> 00:46:03,569
<font color="#CCCCCC">sand pile yet so there's this great</font>

1068
00:46:01,559 --> 00:46:05,039
resource online called sand pile where

1069
00:46:03,569 --> 00:46:07,469
lots of crazy<font color="#E5E5E5"> intel tricks had</font>

1070
00:46:05,039 --> 00:46:10,559
documented and yes so it's explained

1071
00:46:07,469 --> 00:46:12,059
that at some point intel decided that

1072
00:46:10,559 --> 00:46:13,949
this did this should be sensitive<font color="#E5E5E5"> and</font>

1073
00:46:12,059 --> 00:46:15,449
they updated it but they never issued

1074
00:46:13,949 --> 00:46:17,759
any Lovato or they never updated any

1075
00:46:15,449 --> 00:46:19,440
documentation so what we think might

1076
00:46:17,759 --> 00:46:21,359
have happened was that<font color="#E5E5E5"> Microsoft</font><font color="#CCCCCC"> Judas</font>

1077
00:46:19,440 --> 00:46:23,640
when Microsoft implemented this they

1078
00:46:21,359 --> 00:46:25,288
<font color="#E5E5E5">believed</font><font color="#CCCCCC"> that this would they could rely</font>

1079
00:46:23,640 --> 00:46:28,109
on<font color="#E5E5E5"> this and then Intel suddenly</font><font color="#CCCCCC"> changes</font>

1080
00:46:25,289 --> 00:46:30,839
the the the the x86 document

1081
00:46:28,109 --> 00:46:32,190
specification so that it was sensitive

1082
00:46:30,839 --> 00:46:35,819
and<font color="#E5E5E5"> Microsoft never bothered to check</font>

1083
00:46:32,190 --> 00:46:39,210
whether these checks were still valid

1084
00:46:35,819 --> 00:46:40,320
which is pretty reasonable I mean

1085
00:46:39,210 --> 00:46:45,060
how many people<font color="#CCCCCC"> check this little level</font>

1086
00:46:40,320 --> 00:46:46,080
code every day it's it's it's it's<font color="#E5E5E5"> the</font>

1087
00:46:45,060 --> 00:46:47,580
kind of thing that you why Quentin

1088
00:46:46,080 --> 00:46:52,619
nobody remembers how it works just don't

1089
00:46:47,580 --> 00:46:53,970
touch it so yeah so we found that we by

1090
00:46:52,619 --> 00:46:58,170
experimentation we<font color="#CCCCCC"> proof that this was</font>

1091
00:46:53,970 --> 00:46:59,520
this is actually still<font color="#E5E5E5"> the case</font><font color="#CCCCCC"> ok so i</font>

1092
00:46:58,170 --> 00:47:08,609
<font color="#CCCCCC">have a video</font><font color="#E5E5E5"> of this it's not</font>

1093
00:46:59,520 --> 00:47:10,920
particularly to watch but it's<font color="#CCCCCC"> ok so</font>

1094
00:47:08,609 --> 00:47:13,200
yeah so I<font color="#CCCCCC"> votive a libel exploit for</font>

1095
00:47:10,920 --> 00:47:15,210
every every supported version of Windows

1096
00:47:13,200 --> 00:47:16,770
NT you basically just invoked a new

1097
00:47:15,210 --> 00:47:20,160
process and it would hand it over and

1098
00:47:16,770 --> 00:47:21,630
you a system<font color="#E5E5E5"> token so yeah it was it was</font>

1099
00:47:20,160 --> 00:47:23,460
very reliable and it worked perfectly

1100
00:47:21,630 --> 00:47:26,609
<font color="#CCCCCC">and in fact it was a bit</font><font color="#E5E5E5"> of a challenge</font>

1101
00:47:23,460 --> 00:47:28,140
to write because all the existing

1102
00:47:26,609 --> 00:47:30,509
published<font color="#CCCCCC"> shell code for Windows NT</font>

1103
00:47:28,140 --> 00:47:33,960
privilege escalation bugs<font color="#CCCCCC"> we're never</font>

1104
00:47:30,510 --> 00:47:35,580
<font color="#E5E5E5">expected anything to work across more</font>

1105
00:47:33,960 --> 00:47:36,630
than one or two kernel versions so

1106
00:47:35,580 --> 00:47:39,029
everything published was like very

1107
00:47:36,630 --> 00:47:40,530
windows XP specific or whatever and they

1108
00:47:39,030 --> 00:47:44,160
had like<font color="#CCCCCC"> hard coded offsets into</font>

1109
00:47:40,530 --> 00:47:46,260
structures and so on and so yeah I spent

1110
00:47:44,160 --> 00:47:48,180
<font color="#E5E5E5">some time working on a completely</font>

1111
00:47:46,260 --> 00:47:50,430
<font color="#CCCCCC">colonel neutral version that would work</font>

1112
00:47:48,180 --> 00:47:52,020
<font color="#E5E5E5">on every version of Windows NT simply</font>

1113
00:47:50,430 --> 00:47:53,220
because there wasn't an exploit<font color="#E5E5E5"> exists</font>

1114
00:47:52,020 --> 00:47:58,410
<font color="#CCCCCC">that no explore you existed like this</font>

1115
00:47:53,220 --> 00:48:01,859
around that I could reference so<font color="#E5E5E5"> I have</font>

1116
00:47:58,410 --> 00:48:05,940
<font color="#CCCCCC">some code that i can i can</font><font color="#E5E5E5"> show you so</font>

1117
00:48:01,859 --> 00:48:07,560
what I did was so this is where my<font color="#E5E5E5"> where</font>

1118
00:48:05,940 --> 00:48:09,750
the colonel lands after<font color="#CCCCCC"> I exploit</font><font color="#E5E5E5"> this</font>

1119
00:48:07,560 --> 00:48:12,480
vulnerability and so basically<font color="#CCCCCC"> I have to</font>

1120
00:48:09,750 --> 00:48:13,890
start biting a driver code as if I was

1121
00:48:12,480 --> 00:48:16,380
writing a real driver based on like

1122
00:48:13,890 --> 00:48:17,368
symbols that microsoft support so that I

1123
00:48:16,380 --> 00:48:20,369
could be sure<font color="#CCCCCC"> that they would be</font>

1124
00:48:17,369 --> 00:48:22,380
<font color="#E5E5E5">available on every kernel version so</font>

1125
00:48:20,369 --> 00:48:24,210
yeah I basically<font color="#E5E5E5"> have to work out where</font>

1126
00:48:22,380 --> 00:48:25,380
my kernel is loaded<font color="#E5E5E5"> and then start</font>

1127
00:48:24,210 --> 00:48:28,830
passing the colonel export directing

1128
00:48:25,380 --> 00:48:31,530
myself manually so then<font color="#E5E5E5"> I based and I</font>

1129
00:48:28,830 --> 00:48:33,210
can basically<font color="#E5E5E5"> write driver coded as if</font>

1130
00:48:31,530 --> 00:48:36,150
it was as if I was writing a genuine

1131
00:48:33,210 --> 00:48:38,310
driver so because<font color="#CCCCCC"> the kernel stack gets</font>

1132
00:48:36,150 --> 00:48:41,010
d synchronized because<font color="#CCCCCC"> I'm passing at</font>

1133
00:48:38,310 --> 00:48:43,020
this fake stack that that I wanted<font color="#CCCCCC"> to</font>

1134
00:48:41,010 --> 00:48:44,220
swap to it turns out that the host my

1135
00:48:43,020 --> 00:48:46,740
whole cage reg structure gets completely

1136
00:48:44,220 --> 00:48:48,330
messed up and in order not to for this

1137
00:48:46,740 --> 00:48:48,939
corruption to propagate<font color="#CCCCCC"> to other parts</font>

1138
00:48:48,330 --> 00:48:50,770
of<font color="#E5E5E5"> the system</font>

1139
00:48:48,940 --> 00:48:52,960
I had to repair it so I find all

1140
00:48:50,770 --> 00:48:56,560
references to to this to my this<font color="#E5E5E5"> fake</font>

1141
00:48:52,960 --> 00:48:58,210
<font color="#E5E5E5">stack up set</font><font color="#CCCCCC"> up and and we store them</font>

1142
00:48:56,560 --> 00:48:59,560
because I'm going<font color="#E5E5E5"> to kill this process</font>

1143
00:48:58,210 --> 00:49:02,770
anyway because I only want<font color="#E5E5E5"> it I only</font>

1144
00:48:59,560 --> 00:49:05,020
wanted<font color="#CCCCCC"> to use it to to pass to paste a</font>

1145
00:49:02,770 --> 00:49:06,609
privilege token<font color="#E5E5E5"> onto another process I</font>

1146
00:49:05,020 --> 00:49:07,960
don't really care what a quitter points

1147
00:49:06,609 --> 00:49:10,540
out I<font color="#CCCCCC"> just wanted to so that I just</font>

1148
00:49:07,960 --> 00:49:12,849
wanted not to be corrupt anything so

1149
00:49:10,540 --> 00:49:15,250
yeah so basically I just search for all

1150
00:49:12,849 --> 00:49:17,380
these values then I find debate the most

1151
00:49:15,250 --> 00:49:19,960
privileged process on the system which

1152
00:49:17,380 --> 00:49:21,730
is the initial system process grab a

1153
00:49:19,960 --> 00:49:23,530
<font color="#E5E5E5">couple reference to its primary token</font>

1154
00:49:21,730 --> 00:49:26,290
and then pasted on tomato paste it onto

1155
00:49:23,530 --> 00:49:29,470
my<font color="#E5E5E5"> this process that's unprivileged and</font>

1156
00:49:26,290 --> 00:49:33,460
yeah<font color="#E5E5E5"> and this works on this only uses</font>

1157
00:49:29,470 --> 00:49:36,640
exported symbols that microsoft support

1158
00:49:33,460 --> 00:49:38,710
but for<font color="#E5E5E5"> driver developers so it's</font>

1159
00:49:36,640 --> 00:49:44,230
completely reliable across every every

1160
00:49:38,710 --> 00:49:47,619
anti version that was affected so let's

1161
00:49:44,230 --> 00:49:50,920
see so yeah so basically yeah I set up

1162
00:49:47,619 --> 00:49:53,200
this kernel stack and the offsets for

1163
00:49:50,920 --> 00:49:56,920
things like we're strolling into TB and

1164
00:49:53,200 --> 00:49:59,259
the the new a<font color="#E5E5E5"> new stack pointer which is</font>

1165
00:49:56,920 --> 00:50:02,230
going<font color="#E5E5E5"> to be</font><font color="#CCCCCC"> a fake stack and user and</font>

1166
00:49:59,260 --> 00:50:04,180
the use of address space and changed the

1167
00:50:02,230 --> 00:50:07,839
return address into my into my exploit I

1168
00:50:04,180 --> 00:50:09,640
mean my payload so you need in order to

1169
00:50:07,839 --> 00:50:12,250
access this code you did data structure

1170
00:50:09,640 --> 00:50:13,750
called a tip in your tab I don't know

1171
00:50:12,250 --> 00:50:14,859
what eid stands<font color="#E5E5E5"> like this is that</font>

1172
00:50:13,750 --> 00:50:17,230
<font color="#E5E5E5">information block or something like that</font>

1173
00:50:14,859 --> 00:50:19,180
with the TV<font color="#E5E5E5"> is obviously a fun</font>

1174
00:50:17,230 --> 00:50:22,480
environment block then you<font color="#E5E5E5"> in slice the</font>

1175
00:50:19,180 --> 00:50:24,879
<font color="#CCCCCC">vdm subsystem and it turns out because</font>

1176
00:50:22,480 --> 00:50:26,829
this data structure is unsupported and

1177
00:50:24,880 --> 00:50:27,880
undocumented<font color="#CCCCCC"> microsoft in mind changing</font>

1178
00:50:26,829 --> 00:50:32,140
it as much as much as they liked

1179
00:50:27,880 --> 00:50:34,329
obviously<font color="#E5E5E5"> very reasonable but in order</font>

1180
00:50:32,140 --> 00:50:37,540
to identify which version is is being

1181
00:50:34,329 --> 00:50:41,710
used they there's a size field which

1182
00:50:37,540 --> 00:50:46,480
which the if it isn't the correct value

1183
00:50:41,710 --> 00:50:48,250
they say they return access denied but

1184
00:50:46,480 --> 00:50:49,420
because<font color="#E5E5E5"> i don't know which i don't know</font>

1185
00:50:48,250 --> 00:50:50,829
what<font color="#E5E5E5"> the size should be with in fact</font>

1186
00:50:49,420 --> 00:50:52,150
leaving changes between service packs so

1187
00:50:50,829 --> 00:50:54,190
<font color="#E5E5E5">i can't</font><font color="#CCCCCC"> even I can't even</font><font color="#E5E5E5"> guess from the</font>

1188
00:50:52,150 --> 00:50:55,569
<font color="#CCCCCC">virgin so I just</font><font color="#E5E5E5"> basically had a brute</font>

1189
00:50:54,190 --> 00:50:59,660
force<font color="#CCCCCC"> and try every value until it works</font>

1190
00:50:55,569 --> 00:51:02,660
and this<font color="#E5E5E5"> would this works fine</font>

1191
00:50:59,660 --> 00:51:04,399
so yeah because<font color="#E5E5E5"> the real address in</font>

1192
00:51:02,660 --> 00:51:09,170
virtual 8086 mode<font color="#CCCCCC"> Intel expect you to</font>

1193
00:51:04,400 --> 00:51:11,059
map the virtual the the fake wheel mode

1194
00:51:09,170 --> 00:51:15,589
address space on the first page needs to

1195
00:51:11,059 --> 00:51:18,380
map know the first page so there's no

1196
00:51:15,589 --> 00:51:19,759
documented way to do this and in fact if

1197
00:51:18,380 --> 00:51:21,710
you<font color="#E5E5E5"> try to do it with any of the win32</font>

1198
00:51:19,760 --> 00:51:25,849
<font color="#CCCCCC">API is it just</font><font color="#E5E5E5"> doesn't work because no</font>

1199
00:51:21,710 --> 00:51:28,760
special meaning and it it means you know

1200
00:51:25,849 --> 00:51:31,400
<font color="#E5E5E5">you have no preference whether this is</font>

1201
00:51:28,760 --> 00:51:32,900
going to be mapped but<font color="#E5E5E5"> if you if you use</font>

1202
00:51:31,400 --> 00:51:34,039
NT allocate virtual memory which<font color="#CCCCCC"> is the</font>

1203
00:51:32,900 --> 00:51:38,450
system called the backs all the stuff

1204
00:51:34,039 --> 00:51:41,660
that all the regular allocation stuff

1205
00:51:38,450 --> 00:51:42,919
like virtual or consumer then it's

1206
00:51:41,660 --> 00:51:44,690
possible<font color="#E5E5E5"> to do that because it round</font>

1207
00:51:42,920 --> 00:51:46,609
style addresses to<font color="#CCCCCC"> the nearest page so</font>

1208
00:51:44,690 --> 00:51:50,030
if you wanted something map-21 the

1209
00:51:46,609 --> 00:51:51,920
address one then obviously one isn't a

1210
00:51:50,030 --> 00:51:53,599
page boundary so if you want something

1211
00:51:51,920 --> 00:51:55,490
map-21 you need to do it is maps and<font color="#E5E5E5"> get</font>

1212
00:51:53,599 --> 00:51:56,809
the next available<font color="#E5E5E5"> page which is</font><font color="#CCCCCC"> 0 so</font>

1213
00:51:55,490 --> 00:51:57,890
you basically just pass in a really low

1214
00:51:56,809 --> 00:51:59,510
address it bans it down to the nearest

1215
00:51:57,890 --> 00:52:06,049
page and you get it you get it mapped

1216
00:51:59,510 --> 00:52:07,819
and there you go and that works so we've

1217
00:52:06,049 --> 00:52:12,650
also been working on automation and

1218
00:52:07,819 --> 00:52:16,640
automation and buzzing for<font color="#CCCCCC"> the operating</font>

1219
00:52:12,650 --> 00:52:18,410
system kernels so we've<font color="#E5E5E5"> been</font><font color="#CCCCCC"> working on</font>

1220
00:52:16,640 --> 00:52:19,848
the system called exploration to try and

1221
00:52:18,410 --> 00:52:21,799
find interesting attack<font color="#E5E5E5"> servers that we</font>

1222
00:52:19,849 --> 00:52:23,599
want<font color="#E5E5E5"> to reach on</font><font color="#CCCCCC"> Windows the system call</font>

1223
00:52:21,799 --> 00:52:25,160
interface<font color="#E5E5E5"> it's complex it's unstable</font><font color="#CCCCCC"> its</font>

1224
00:52:23,599 --> 00:52:27,710
unsupported and it's undocumented and

1225
00:52:25,160 --> 00:52:30,740
it's also pretty vast if you consider

1226
00:52:27,710 --> 00:52:33,170
<font color="#E5E5E5">Linux has about 300 system calls windows</font>

1227
00:52:30,740 --> 00:52:34,910
actually has about 1,400 but in fact

1228
00:52:33,170 --> 00:52:37,789
that that's a pretty conservative value

1229
00:52:34,910 --> 00:52:40,098
because<font color="#E5E5E5"> Microsoft really like this</font>

1230
00:52:37,789 --> 00:52:41,990
design of multiplexing system calls on

1231
00:52:40,099 --> 00:52:44,059
linux there's only one multiplexing

1232
00:52:41,990 --> 00:52:47,660
system call which is socket call so

1233
00:52:44,059 --> 00:52:49,910
things like bind except understand and

1234
00:52:47,660 --> 00:52:51,230
things like this<font color="#E5E5E5"> of all of</font><font color="#CCCCCC"> all</font><font color="#E5E5E5"> the same</font>

1235
00:52:49,910 --> 00:52:52,640
system called called socket call I need

1236
00:52:51,230 --> 00:52:55,250
to pass a value saying which year which

1237
00:52:52,640 --> 00:52:56,839
one you wanted but my tough love love

1238
00:52:55,250 --> 00:52:59,839
<font color="#E5E5E5">this and they have they have dozens and</font>

1239
00:52:56,839 --> 00:53:02,089
dozens of them so you pass a magic value

1240
00:52:59,839 --> 00:53:04,130
<font color="#E5E5E5">it which tells them which system call</font>

1241
00:53:02,089 --> 00:53:06,950
you actually<font color="#CCCCCC"> want it</font><font color="#E5E5E5"> and it can</font><font color="#CCCCCC"> be</font>

1242
00:53:04,130 --> 00:53:10,640
dozens available via one in the pier one

1243
00:53:06,950 --> 00:53:12,720
entry point so in fact<font color="#CCCCCC"> 1400 is probably</font>

1244
00:53:10,640 --> 00:53:15,750
<font color="#E5E5E5">pretty conservative value there's</font>

1245
00:53:12,720 --> 00:53:19,259
1400 ssdd entries but there's<font color="#E5E5E5"> more</font>

1246
00:53:15,750 --> 00:53:23,160
likely<font color="#CCCCCC"> I would guess about 3,000 system</font>

1247
00:53:19,260 --> 00:53:25,590
calls really so on windows these are

1248
00:53:23,160 --> 00:53:27,598
designed only to to only<font color="#CCCCCC"> ever</font><font color="#E5E5E5"> be called</font>

1249
00:53:25,590 --> 00:53:29,130
by<font color="#E5E5E5"> Microsoft code it's they make it they</font>

1250
00:53:27,599 --> 00:53:30,390
make it very<font color="#E5E5E5"> difficult to call system</font>

1251
00:53:29,130 --> 00:53:32,609
calls and it's they're not supported

1252
00:53:30,390 --> 00:53:34,080
across versions so they don't mind

1253
00:53:32,609 --> 00:53:35,609
<font color="#E5E5E5">breaking stuff which is totally</font>

1254
00:53:34,080 --> 00:53:40,200
reasonable this is all this is all

1255
00:53:35,609 --> 00:53:41,369
expected so and as most<font color="#E5E5E5"> people know I</font>

1256
00:53:40,200 --> 00:53:43,439
guess they<font color="#CCCCCC"> random I system calls</font>

1257
00:53:41,369 --> 00:53:44,880
physical numbers between service packs

1258
00:53:43,440 --> 00:53:48,990
just<font color="#CCCCCC"> to</font><font color="#E5E5E5"> make sure that you're not trying</font>

1259
00:53:44,880 --> 00:53:50,220
<font color="#E5E5E5">to rely</font><font color="#CCCCCC"> on this well I guess that's</font>

1260
00:53:48,990 --> 00:53:51,089
prolly not with this design to do they

1261
00:53:50,220 --> 00:53:56,069
just do<font color="#CCCCCC"> that's part of the build process</font>

1262
00:53:51,090 --> 00:53:57,810
but that's that's the effect because

1263
00:53:56,070 --> 00:53:59,580
nobody no windows program is called

1264
00:53:57,810 --> 00:54:01,049
these<font color="#E5E5E5"> setting goals directly there you</font>

1265
00:53:59,580 --> 00:54:03,330
go to the wind did you<font color="#CCCCCC"> two supported and</font>

1266
00:54:01,050 --> 00:54:05,340
documented abis they're rarely exposed

1267
00:54:03,330 --> 00:54:06,720
to malformed parameters so in<font color="#E5E5E5"> general</font>

1268
00:54:05,340 --> 00:54:10,500
simple fuzzing<font color="#E5E5E5"> can still exposed</font>

1269
00:54:06,720 --> 00:54:11,879
interesting bugs simply<font color="#E5E5E5"> because real</font>

1270
00:54:10,500 --> 00:54:18,869
world program is<font color="#E5E5E5"> on touching</font><font color="#CCCCCC"> their stuff</font>

1271
00:54:11,880 --> 00:54:21,150
so ya on the next if if it's expected

1272
00:54:18,869 --> 00:54:22,740
that just<font color="#E5E5E5"> regular programmers will call</font>

1273
00:54:21,150 --> 00:54:24,180
system calls and in fact<font color="#E5E5E5"> when you</font>

1274
00:54:22,740 --> 00:54:25,649
<font color="#CCCCCC">sitting call functionality is a little</font>

1275
00:54:24,180 --> 00:54:30,060
<font color="#CCCCCC">Linux it so it's quite common to see</font>

1276
00:54:25,650 --> 00:54:31,560
regular programmers bugs or reports that

1277
00:54:30,060 --> 00:54:34,290
there oops has been Luke's has been

1278
00:54:31,560 --> 00:54:36,390
caused as they try out the new code and

1279
00:54:34,290 --> 00:54:37,680
this weeds out lots of bugs before it

1280
00:54:36,390 --> 00:54:38,549
reaches anything that could<font color="#E5E5E5"> be security</font>

1281
00:54:37,680 --> 00:54:42,210
sensitive in like<font color="#CCCCCC"> Enterprise</font>

1282
00:54:38,550 --> 00:54:43,650
distributions or whatever but yeah this

1283
00:54:42,210 --> 00:54:45,510
<font color="#E5E5E5">is in the case on Windows simply because</font>

1284
00:54:43,650 --> 00:54:49,740
this isn't designed to be called by end

1285
00:54:45,510 --> 00:54:50,790
users but<font color="#E5E5E5"> obviously there's nothing</font>

1286
00:54:49,740 --> 00:54:54,689
stopping you actually do that<font color="#CCCCCC"> if you</font>

1287
00:54:50,790 --> 00:54:56,400
want<font color="#CCCCCC"> attacker so also the design of</font>

1288
00:54:54,690 --> 00:54:58,650
system calls on Windows NT is very

1289
00:54:56,400 --> 00:55:01,859
different from<font color="#CCCCCC"> from</font><font color="#E5E5E5"> the philosophy on on</font>

1290
00:54:58,650 --> 00:55:03,720
Linux in general on the next structures

1291
00:55:01,859 --> 00:55:05,819
are very<font color="#E5E5E5"> simple they can be read in one</font>

1292
00:55:03,720 --> 00:55:07,980
or two operations and they're easy to

1293
00:55:05,820 --> 00:55:11,640
pass the very simple structures but on

1294
00:55:07,980 --> 00:55:13,290
<font color="#CCCCCC">home windows the often complex object</font>

1295
00:55:11,640 --> 00:55:14,640
<font color="#E5E5E5">objects the multiple levels deep they</font>

1296
00:55:13,290 --> 00:55:17,849
have large interdependencies that all

1297
00:55:14,640 --> 00:55:19,710
need to be passed if you set

1298
00:55:17,849 --> 00:55:21,270
pathological parameters in in these

1299
00:55:19,710 --> 00:55:23,990
complex structures you can reach some

1300
00:55:21,270 --> 00:55:25,550
very rarely exercised code

1301
00:55:23,990 --> 00:55:27,560
and in fact there's code that you just

1302
00:55:25,550 --> 00:55:30,320
simply cannot reach via any supported

1303
00:55:27,560 --> 00:55:31,759
interface and and it's<font color="#CCCCCC"> it's difficult to</font>

1304
00:55:30,320 --> 00:55:34,160
it's<font color="#E5E5E5"> difficult to imagine how Microsoft</font>

1305
00:55:31,760 --> 00:55:35,300
managed to test this and no and no end

1306
00:55:34,160 --> 00:55:38,390
users are going<font color="#E5E5E5"> to complain simply</font>

1307
00:55:35,300 --> 00:55:42,080
because they did<font color="#CCCCCC"> the dead never never</font>

1308
00:55:38,390 --> 00:55:43,970
rely on<font color="#E5E5E5"> this code of course colonel is</font>

1309
00:55:42,080 --> 00:55:46,610
also pass lots of interesting stuff like

1310
00:55:43,970 --> 00:55:47,660
fonts and other complex formats and this

1311
00:55:46,610 --> 00:55:50,000
is all done<font color="#E5E5E5"> it</font><font color="#CCCCCC"> rings you</font><font color="#E5E5E5"> and these are</font>

1312
00:55:47,660 --> 00:55:52,368
great first candidates so we've we've

1313
00:55:50,000 --> 00:55:53,960
been working on system called fuzzing so

1314
00:55:52,369 --> 00:55:56,960
trivial fuzzing can still find<font color="#CCCCCC"> Windows</font>

1315
00:55:53,960 --> 00:55:58,190
bugs the attacks her place is really

1316
00:55:56,960 --> 00:56:00,560
large and there's lots<font color="#E5E5E5"> of system calls</font>

1317
00:55:58,190 --> 00:56:02,750
to play with you can find buzzing with

1318
00:56:00,560 --> 00:56:03,860
you can find buzzing on Linux but in

1319
00:56:02,750 --> 00:56:05,750
general<font color="#E5E5E5"> the task is not so trivial</font>

1320
00:56:03,860 --> 00:56:07,640
simply because the interfaces are so

1321
00:56:05,750 --> 00:56:10,190
simple it's it's tough to get them wrong

1322
00:56:07,640 --> 00:56:12,200
you need to do<font color="#CCCCCC"> some work need to</font><font color="#E5E5E5"> set</font><font color="#CCCCCC"> up</font>

1323
00:56:10,190 --> 00:56:14,960
some some complex state with file

1324
00:56:12,200 --> 00:56:15,919
descriptors or whatever but<font color="#E5E5E5"> buzzing real</font>

1325
00:56:14,960 --> 00:56:17,869
<font color="#CCCCCC">find bugs and we've had some success</font>

1326
00:56:15,920 --> 00:56:19,369
this<font color="#E5E5E5"> way we've been developing some</font>

1327
00:56:17,869 --> 00:56:20,330
techniques for working on<font color="#E5E5E5"> this that</font>

1328
00:56:19,369 --> 00:56:22,310
we're<font color="#CCCCCC"> trying to integrate into things</font>

1329
00:56:20,330 --> 00:56:24,920
like<font color="#CCCCCC"> Chrome OS</font><font color="#E5E5E5"> release so we're hoping</font>

1330
00:56:22,310 --> 00:56:29,299
that that we're hoping<font color="#CCCCCC"> that this can</font>

1331
00:56:24,920 --> 00:56:32,180
help make things like Linux privilege

1332
00:56:29,300 --> 00:56:34,550
escalation via malformed system core

1333
00:56:32,180 --> 00:56:35,990
operations are easier to spot as they've

1334
00:56:34,550 --> 00:56:37,910
introduced<font color="#E5E5E5"> a regression testing and so</font>

1335
00:56:35,990 --> 00:56:42,799
on<font color="#CCCCCC"> so we're hoping this is going to help</font>

1336
00:56:37,910 --> 00:56:43,790
Linux a local security in future so yeah

1337
00:56:42,800 --> 00:56:45,680
now we can<font color="#E5E5E5"> talk about protecting the</font>

1338
00:56:43,790 --> 00:56:50,509
colonel from from military slang code

1339
00:56:45,680 --> 00:56:52,430
one of one of<font color="#E5E5E5"> the the first way that was</font>

1340
00:56:50,510 --> 00:56:55,310
quite popular to try and protect the

1341
00:56:52,430 --> 00:56:59,240
colonel from malicious user non-code was

1342
00:56:55,310 --> 00:57:01,100
just having trusted paths executables so

1343
00:56:59,240 --> 00:57:04,069
well<font color="#E5E5E5"> I mean the idea</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> just to have</font>

1344
00:57:01,100 --> 00:57:06,799
trusted executables on me so it's it's

1345
00:57:04,070 --> 00:57:09,710
reasonably old<font color="#E5E5E5"> I think I've seen acting</font>

1346
00:57:06,800 --> 00:57:13,730
this accent people running shell boxes

1347
00:57:09,710 --> 00:57:16,040
in in the mid-90s using this so it was

1348
00:57:13,730 --> 00:57:20,240
pretty popular and there was a very

1349
00:57:16,040 --> 00:57:22,759
naive way of doing it on Linux which was

1350
00:57:20,240 --> 00:57:25,040
to just mount all use of writable<font color="#E5E5E5"> pass</font>

1351
00:57:22,760 --> 00:57:27,950
to know exact so if you could write

1352
00:57:25,040 --> 00:57:32,540
somewhere you could not execute the<font color="#E5E5E5"> code</font>

1353
00:57:27,950 --> 00:57:35,149
there we are trivial bypass for this for

1354
00:57:32,540 --> 00:57:36,990
instance for<font color="#E5E5E5"> for systems which already</font>

1355
00:57:35,150 --> 00:57:41,610
supported

1356
00:57:36,990 --> 00:57:43,020
dynamic libraries at the time you could

1357
00:57:41,610 --> 00:57:45,660
<font color="#E5E5E5">just go through the dynamic loader</font>

1358
00:57:43,020 --> 00:57:48,210
because the dynamic load el de<font color="#E5E5E5"> wood</font>

1359
00:57:45,660 --> 00:57:51,930
would be in a trusted pass and it would

1360
00:57:48,210 --> 00:57:55,619
happily map<font color="#CCCCCC"> map your code that it's a</font>

1361
00:57:51,930 --> 00:57:59,609
job and execute your code just<font color="#E5E5E5"> secure he</font>

1362
00:57:55,619 --> 00:58:01,830
had a good GI DUI debased 14 years i

1363
00:57:59,610 --> 00:58:05,700
think<font color="#E5E5E5"> it was released in two thousand</font><font color="#CCCCCC"> or</font>

1364
00:58:01,830 --> 00:58:07,710
something<font color="#E5E5E5"> of this and nowadays it would</font>

1365
00:58:05,700 --> 00:58:09,960
actually<font color="#E5E5E5"> work if you what it could</font>

1366
00:58:07,710 --> 00:58:11,790
almost work if you would just just mount

1367
00:58:09,960 --> 00:58:14,970
something with no exact<font color="#CCCCCC"> because nowadays</font>

1368
00:58:11,790 --> 00:58:17,759
that<font color="#CCCCCC"> semantic is actually respected and</font>

1369
00:58:14,970 --> 00:58:21,750
it does prevent fine mapping a spot

1370
00:58:17,760 --> 00:58:25,800
exact and not only exactly so this

1371
00:58:21,750 --> 00:58:27,840
approach is gaining some popularity on

1372
00:58:25,800 --> 00:58:29,910
the<font color="#CCCCCC"> windows platforms who whitelisting</font>

1373
00:58:27,840 --> 00:58:32,040
whitelisting we've seen a<font color="#E5E5E5"> few products</font>

1374
00:58:29,910 --> 00:58:34,200
<font color="#CCCCCC">that portray and perform</font><font color="#E5E5E5"> white listing</font>

1375
00:58:32,040 --> 00:58:36,930
on<font color="#CCCCCC"> the windows</font><font color="#E5E5E5"> platform so the idea is</font>

1376
00:58:34,200 --> 00:58:38,700
just to prevent gaining arbitrary code

1377
00:58:36,930 --> 00:58:41,549
execution in the first place<font color="#CCCCCC"> so that you</font>

1378
00:58:38,700 --> 00:58:44,189
can't attack the colonel but of<font color="#CCCCCC"> course</font>

1379
00:58:41,550 --> 00:58:46,080
there are tons of way to bypass this

1380
00:58:44,190 --> 00:58:48,810
because arbitrary code execution should

1381
00:58:46,080 --> 00:58:51,569
not only<font color="#E5E5E5"> mean arbitrary up codes if you</font>

1382
00:58:48,810 --> 00:58:53,490
have if you if you can expect lots of

1383
00:58:51,570 --> 00:58:56,460
colonel bugs from a Python or Ruby

1384
00:58:53,490 --> 00:58:58,229
<font color="#E5E5E5">interpreter so if Python or Ruby are in</font>

1385
00:58:56,460 --> 00:59:00,690
your trusted pass you<font color="#CCCCCC"> can just explode</font>

1386
00:58:58,230 --> 00:59:02,670
can I box for this also if you<font color="#E5E5E5"> think</font>

1387
00:59:00,690 --> 00:59:05,160
about powerful executive birds such as

1388
00:59:02,670 --> 00:59:07,200
gdb you can do whatever you want<font color="#CCCCCC"> for GDB</font>

1389
00:59:05,160 --> 00:59:11,069
so if you have access to gdb you can

1390
00:59:07,200 --> 00:59:14,730
obviously<font color="#E5E5E5"> run arbitrary code</font><font color="#CCCCCC"> I'm so</font>

1391
00:59:11,070 --> 00:59:16,859
quite interesting<font color="#E5E5E5"> tweak if if you're</font>

1392
00:59:14,730 --> 00:59:18,990
trying<font color="#E5E5E5"> to</font><font color="#CCCCCC"> build a system with trusted</font>

1393
00:59:16,859 --> 00:59:22,380
pass<font color="#CCCCCC"> executable it the straight model is</font>

1394
00:59:18,990 --> 00:59:24,029
completely changed for many binaries for

1395
00:59:22,380 --> 00:59:26,490
instance a local vulnerability nethack

1396
00:59:24,030 --> 00:59:28,590
or the minesweeper on<font color="#CCCCCC"> Windows would</font>

1397
00:59:26,490 --> 00:59:32,459
would become useful because they would

1398
00:59:28,590 --> 00:59:34,770
allow you to run arbitrary code and<font color="#CCCCCC"> you</font>

1399
00:59:32,460 --> 00:59:37,290
you've probably seen a few releases such

1400
00:59:34,770 --> 00:59:40,440
as vulnerabilities in make of energy in

1401
00:59:37,290 --> 00:59:43,410
<font color="#CCCCCC">gsh which didn't really make any sense</font>

1402
00:59:40,440 --> 00:59:45,220
but in this very parodying they they do

1403
00:59:43,410 --> 00:59:49,540
make make sense

1404
00:59:45,220 --> 00:59:52,089
so of course of<font color="#CCCCCC"> course this is</font><font color="#E5E5E5"> also</font>

1405
00:59:49,540 --> 00:59:54,250
<font color="#E5E5E5">useless if the attacker already has</font>

1406
00:59:52,090 --> 00:59:56,170
arbitrary code execution so if you're

1407
00:59:54,250 --> 00:59:58,900
trying<font color="#E5E5E5"> to</font><font color="#CCCCCC"> protect a broader sandbox with</font>

1408
00:59:56,170 --> 01:00:01,000
this it's useless because you're

1409
00:59:58,900 --> 01:00:03,250
assuming the attacker already has

1410
01:00:01,000 --> 01:00:06,730
arbitrary code execution in sandbox same

1411
01:00:03,250 --> 01:00:11,560
same thing for openssh or vsftpd first

1412
01:00:06,730 --> 01:00:14,410
separated sandbox so what what could we

1413
01:00:11,560 --> 01:00:16,869
really<font color="#E5E5E5"> do</font><font color="#CCCCCC"> that would</font><font color="#E5E5E5"> be useful to choose</font>

1414
01:00:14,410 --> 01:00:18,670
to do proper sandboxing an attack

1415
01:00:16,869 --> 01:00:23,320
surface reduction<font color="#E5E5E5"> for for the colonel</font>

1416
01:00:18,670 --> 01:00:25,480
ideally a process could opt out for from

1417
01:00:23,320 --> 01:00:29,410
some kernel features it does not require

1418
01:00:25,480 --> 01:00:33,790
on Linux there is nothing<font color="#CCCCCC"> really that</font>

1419
01:00:29,410 --> 01:00:37,810
that allows you to to drop privileges in

1420
01:00:33,790 --> 01:00:40,240
a discretionary way and all the<font color="#E5E5E5"> focus is</font>

1421
01:00:37,810 --> 01:00:42,970
<font color="#CCCCCC">on mandatory access control on Linux and</font>

1422
01:00:40,240 --> 01:00:44,950
basically the prodding is very different

1423
01:00:42,970 --> 01:00:46,810
<font color="#E5E5E5">if you're if you're a programmer what</font>

1424
01:00:44,950 --> 01:00:48,580
you want is you know<font color="#E5E5E5"> that you know your</font>

1425
01:00:46,810 --> 01:00:50,830
program you know how it works so you

1426
01:00:48,580 --> 01:00:53,440
want to be<font color="#CCCCCC"> able to define a policy for</font>

1427
01:00:50,830 --> 01:00:56,560
your own program but mini access control

1428
01:00:53,440 --> 01:00:59,290
is more<font color="#E5E5E5"> about an administrator on</font><font color="#CCCCCC"> the</font>

1429
01:00:56,560 --> 01:01:01,000
system being able to define a policy so

1430
01:00:59,290 --> 01:01:03,400
if you're if you're writing<font color="#CCCCCC"> a web</font>

1431
01:01:01,000 --> 01:01:05,800
browser is not what<font color="#CCCCCC"> you want on</font><font color="#E5E5E5"> Windows</font>

1432
01:01:03,400 --> 01:01:08,470
there are slightly more previous

1433
01:01:05,800 --> 01:01:10,690
drooping like features thanks to the

1434
01:01:08,470 --> 01:01:15,490
control over token and more recently

1435
01:01:10,690 --> 01:01:19,480
since Windows Vista we have things<font color="#E5E5E5"> like</font>

1436
01:01:15,490 --> 01:01:21,459
integrity levels so there are some

1437
01:01:19,480 --> 01:01:23,140
previous drooping like features but

1438
01:01:21,460 --> 01:01:27,369
there is still nothing<font color="#E5E5E5"> to protect the</font>

1439
01:01:23,140 --> 01:01:32,109
canals attack surface so the<font color="#E5E5E5"> options are</font>

1440
01:01:27,369 --> 01:01:34,180
limited and on<font color="#CCCCCC"> linux v44 for google</font>

1441
01:01:32,109 --> 01:01:39,670
chrome we needed something like this and

1442
01:01:34,180 --> 01:01:42,730
we we did some some hacks and we have a

1443
01:01:39,670 --> 01:01:44,950
saturated sandbox design that you can

1444
01:01:42,730 --> 01:01:48,490
look at if you're interested in this

1445
01:01:44,950 --> 01:01:51,970
we've published slides at black hat you

1446
01:01:48,490 --> 01:01:54,069
rap about this and it's it's quite weird

1447
01:01:51,970 --> 01:01:55,970
because<font color="#CCCCCC"> they I</font><font color="#E5E5E5"> mean nothing was really</font>

1448
01:01:54,070 --> 01:01:59,420
designed for<font color="#E5E5E5"> this so we kind of</font>

1449
01:01:55,970 --> 01:02:02,060
hacked our way through<font color="#E5E5E5"> it also</font><font color="#CCCCCC"> bitchface</font>

1450
01:01:59,420 --> 01:02:05,450
based sandboxes are quite popular the

1451
01:02:02,060 --> 01:02:09,200
idea is<font color="#CCCCCC"> to use</font><font color="#E5E5E5"> pitch ways to to be to be</font>

1452
01:02:05,450 --> 01:02:12,830
notified<font color="#E5E5E5"> whenever an untrusted process</font>

1453
01:02:09,200 --> 01:02:14,569
will perform a system call so this can

1454
01:02:12,830 --> 01:02:16,609
be<font color="#E5E5E5"> a good choice and for me of course</font>

1455
01:02:14,570 --> 01:02:18,770
<font color="#E5E5E5">it's slow but otherwise for security can</font>

1456
01:02:16,609 --> 01:02:20,869
be a good choice but it's very<font color="#E5E5E5"> hard to</font>

1457
01:02:18,770 --> 01:02:23,840
get right because betrayal ptrace was

1458
01:02:20,869 --> 01:02:27,470
not designed for this at<font color="#E5E5E5"> all also</font>

1459
01:02:23,840 --> 01:02:29,869
there's onion you guys<font color="#CCCCCC"> 11 feature which</font>

1460
01:02:27,470 --> 01:02:32,839
we which could have been interesting<font color="#CCCCCC"> for</font>

1461
01:02:29,869 --> 01:02:35,300
this called second second is a special

1462
01:02:32,840 --> 01:02:37,700
mode you can switch your process into

1463
01:02:35,300 --> 01:02:40,580
that that will only allow the process to

1464
01:02:37,700 --> 01:02:44,060
reach for system calls it will allow the

1465
01:02:40,580 --> 01:02:47,480
process to reach read write and just

1466
01:02:44,060 --> 01:02:50,150
exit<font color="#CCCCCC"> plus</font><font color="#E5E5E5"> sig return to be</font><font color="#CCCCCC"> able to</font>

1467
01:02:47,480 --> 01:02:52,609
handle<font color="#E5E5E5"> signals so it's just</font><font color="#CCCCCC"> the four</font>

1468
01:02:50,150 --> 01:02:54,500
system<font color="#CCCCCC"> calls so of course the kind of</font>

1469
01:02:52,609 --> 01:02:57,710
attack surface is incredibly reduced

1470
01:02:54,500 --> 01:03:00,470
through this but the<font color="#CCCCCC"> problem is</font><font color="#E5E5E5"> for for</font>

1471
01:02:57,710 --> 01:03:03,320
instance<font color="#E5E5E5"> for Chrome we were very limited</font>

1472
01:03:00,470 --> 01:03:05,390
for system calls are not<font color="#E5E5E5"> going to be to</font>

1473
01:03:03,320 --> 01:03:09,380
be enough we need<font color="#E5E5E5"> to be able to allocate</font>

1474
01:03:05,390 --> 01:03:12,920
memory for instance and 11<font color="#CCCCCC"> Googler</font>

1475
01:03:09,380 --> 01:03:15,830
Marcus gojco is working on a sec comp

1476
01:03:12,920 --> 01:03:19,099
base sandbox and he's<font color="#E5E5E5"> using crazy tricks</font>

1477
01:03:15,830 --> 01:03:21,259
such as sharing address space between

1478
01:03:19,099 --> 01:03:23,270
different processes sharing file

1479
01:03:21,260 --> 01:03:27,740
descriptors and then other processes

1480
01:03:23,270 --> 01:03:32,119
which are not under<font color="#CCCCCC"> Sec comp are are</font>

1481
01:03:27,740 --> 01:03:35,569
able to to to proxy the needed system

1482
01:03:32,119 --> 01:03:37,820
calls it sort of works but it's not

1483
01:03:35,570 --> 01:03:41,900
deploying to chrome yet but you can

1484
01:03:37,820 --> 01:03:44,599
<font color="#E5E5E5">already look at it so another popular</font>

1485
01:03:41,900 --> 01:03:47,630
alternative is basically<font color="#E5E5E5"> people say</font><font color="#CCCCCC"> okay</font>

1486
01:03:44,599 --> 01:03:50,359
we<font color="#E5E5E5"> can protect the colonel from from</font>

1487
01:03:47,630 --> 01:03:53,420
from malicious code so what can we<font color="#E5E5E5"> do</font>

1488
01:03:50,359 --> 01:03:55,520
well let's reduce<font color="#E5E5E5"> the kind of religious</font>

1489
01:03:53,420 --> 01:03:57,500
by using virtualization so<font color="#E5E5E5"> lots of</font>

1490
01:03:55,520 --> 01:03:59,490
<font color="#CCCCCC">people do</font><font color="#E5E5E5"> this of course virtualization</font>

1491
01:03:57,500 --> 01:04:01,920
has its problem and

1492
01:03:59,490 --> 01:04:04,259
also expose quite a lot<font color="#E5E5E5"> of attack</font>

1493
01:04:01,920 --> 01:04:07,860
surface nowadays especially in some

1494
01:04:04,260 --> 01:04:09,660
popular products so well it's a I mean

1495
01:04:07,860 --> 01:04:13,710
it's a good idea<font color="#E5E5E5"> but of course it has</font>

1496
01:04:09,660 --> 01:04:17,819
its drawbacks something else<font color="#E5E5E5"> to protect</font>

1497
01:04:13,710 --> 01:04:19,800
the colonel is<font color="#CCCCCC"> you</font><font color="#E5E5E5"> derive and as we've</font>

1498
01:04:17,820 --> 01:04:22,260
mentioned unexpected to user on point I

1499
01:04:19,800 --> 01:04:25,590
references are an issue and I've

1500
01:04:22,260 --> 01:04:29,160
mentioned before that on Linux they used

1501
01:04:25,590 --> 01:04:32,610
to not be exploitable because of thanks

1502
01:04:29,160 --> 01:04:36,330
to segmentation and so the idea be

1503
01:04:32,610 --> 01:04:41,430
behind you TF is very simple is just to

1504
01:04:36,330 --> 01:04:44,730
to<font color="#E5E5E5"> make the kind of</font><font color="#CCCCCC"> segments the cannons</font>

1505
01:04:41,430 --> 01:04:47,279
data segment descriptor expand down and

1506
01:04:44,730 --> 01:04:49,650
put its limit above above user on code

1507
01:04:47,280 --> 01:04:52,530
the problem is what what can you do on

1508
01:04:49,650 --> 01:04:54,000
<font color="#E5E5E5">64-bit system since</font><font color="#CCCCCC"> segmentation for for</font>

1509
01:04:52,530 --> 01:04:56,130
most of its segmentation is not there

1510
01:04:54,000 --> 01:04:58,740
anymore so you can always<font color="#E5E5E5"> do full</font>

1511
01:04:56,130 --> 01:05:01,050
address space switching or other small

1512
01:04:58,740 --> 01:05:04,589
tricks but it's going<font color="#E5E5E5"> to have some</font>

1513
01:05:01,050 --> 01:05:06,840
performance penalty so<font color="#E5E5E5"> a map minute</font><font color="#CCCCCC"> away</font>

1514
01:05:04,590 --> 01:05:08,760
was a pragmatic attempt by the<font color="#E5E5E5"> Linux</font>

1515
01:05:06,840 --> 01:05:11,910
developers to tackle this problem in a

1516
01:05:08,760 --> 01:05:14,400
<font color="#CCCCCC">possible mania the idea is just to have</font>

1517
01:05:11,910 --> 01:05:17,399
a system<font color="#E5E5E5"> why minimum address that can be</font>

1518
01:05:14,400 --> 01:05:19,890
used in<font color="#E5E5E5"> a process usually</font><font color="#CCCCCC"> it's set to</font>

1519
01:05:17,400 --> 01:05:23,730
64k so<font color="#CCCCCC"> processes you learnin</font><font color="#E5E5E5"> process</font>

1520
01:05:19,890 --> 01:05:25,920
cannot i cannot map behind 64k but there

1521
01:05:23,730 --> 01:05:28,800
is an exception of<font color="#E5E5E5"> course for processes</font>

1522
01:05:25,920 --> 01:05:31,770
with the caps destroy your capability so

1523
01:05:28,800 --> 01:05:33,840
lots of root processes for instance this

1524
01:05:31,770 --> 01:05:35,910
has been plagued with many bugs in the

1525
01:05:33,840 --> 01:05:40,320
past it's in much better shape now but

1526
01:05:35,910 --> 01:05:42,660
we found we found<font color="#E5E5E5"> one bypass that will</font>

1527
01:05:40,320 --> 01:05:47,790
present now and we found<font color="#CCCCCC"> another</font><font color="#E5E5E5"> one</font>

1528
01:05:42,660 --> 01:05:53,339
that we need<font color="#CCCCCC"> to investigate so we use</font>

1529
01:05:47,790 --> 01:05:57,480
personalities the this systems 5 release

1530
01:05:53,340 --> 01:06:00,000
for operating system<font color="#E5E5E5"> maps page 0 as a</font>

1531
01:05:57,480 --> 01:06:02,100
<font color="#CCCCCC">swede only and so on for here's some</font>

1532
01:06:00,000 --> 01:06:04,350
programs depend on the<font color="#CCCCCC"> behavior and to</font>

1533
01:06:02,100 --> 01:06:06,540
make<font color="#E5E5E5"> porting programs easier from from</font>

1534
01:06:04,350 --> 01:06:08,130
system<font color="#CCCCCC"> fiber is for to linux linux</font>

1535
01:06:06,540 --> 01:06:10,590
reports a system fiber is for

1536
01:06:08,130 --> 01:06:11,240
personality so the this personality is

1537
01:06:10,590 --> 01:06:14,750
pure

1538
01:06:11,240 --> 01:06:17,660
says and it's kept on xik v of course so

1539
01:06:14,750 --> 01:06:20,690
the funny thing is we could get this

1540
01:06:17,660 --> 01:06:23,779
path personality and just choose to

1541
01:06:20,690 --> 01:06:26,360
execute a statue<font color="#E5E5E5"> Iggy binary and then</font>

1542
01:06:23,780 --> 01:06:28,550
since this is a saturated<font color="#CCCCCC"> binary it</font>

1543
01:06:26,360 --> 01:06:30,619
automatically gaps the caps is<font color="#CCCCCC"> fry your</font>

1544
01:06:28,550 --> 01:06:34,040
capabilities in said<font color="#E5E5E5"> it executors fruit</font>

1545
01:06:30,619 --> 01:06:38,720
and thanks to this capability and map

1546
01:06:34,040 --> 01:06:40,759
the map<font color="#CCCCCC"> minado a check is bypassed and a</font>

1547
01:06:38,720 --> 01:06:43,970
<font color="#E5E5E5">pap a page is mapped as zero in the</font>

1548
01:06:40,760 --> 01:06:46,070
<font color="#E5E5E5">address space but of course dies there's</font>

1549
01:06:43,970 --> 01:06:48,140
not much we can do it's a it's a root

1550
01:06:46,070 --> 01:06:50,630
process we don't control which has a

1551
01:06:48,140 --> 01:06:53,750
page mapped<font color="#E5E5E5"> at zero so yeah you could</font>

1552
01:06:50,630 --> 01:06:56,540
imagine that if this<font color="#E5E5E5"> root process if</font>

1553
01:06:53,750 --> 01:06:58,700
this<font color="#E5E5E5"> foot yeah this would process has a</font>

1554
01:06:56,540 --> 01:07:00,830
vulnerability like a null pointer

1555
01:06:58,700 --> 01:07:04,490
dereference maybe you could exploit it

1556
01:07:00,830 --> 01:07:07,040
but we we were trying to<font color="#CCCCCC"> actually regain</font>

1557
01:07:04,490 --> 01:07:09,080
control of this process<font color="#E5E5E5"> and so we</font>

1558
01:07:07,040 --> 01:07:11,509
started<font color="#E5E5E5"> to</font><font color="#CCCCCC"> look for</font><font color="#E5E5E5"> a binary that would</font>

1559
01:07:09,080 --> 01:07:13,279
drop religious and let let us regain

1560
01:07:11,510 --> 01:07:16,310
control without going through exact<font color="#E5E5E5"> V</font>

1561
01:07:13,280 --> 01:07:18,770
and we<font color="#CCCCCC"> actually found one per soldier</font>

1562
01:07:16,310 --> 01:07:20,540
allowed us to do this and it was not a

1563
01:07:18,770 --> 01:07:22,100
bug in / soda which was just<font color="#E5E5E5"> a bug in</font>

1564
01:07:20,540 --> 01:07:25,100
the linux<font color="#E5E5E5"> kernel that we expected</font>

1565
01:07:22,100 --> 01:07:27,950
through / so you but then of<font color="#CCCCCC"> course then</font>

1566
01:07:25,100 --> 01:07:30,410
we<font color="#E5E5E5"> discovered / so do and and we took a</font>

1567
01:07:27,950 --> 01:07:32,210
look at it and of<font color="#CCCCCC"> course we also found a</font>

1568
01:07:30,410 --> 01:07:35,990
vanity a completely different random

1569
01:07:32,210 --> 01:07:37,940
teen / sodium that<font color="#E5E5E5"> was underrated so</font>

1570
01:07:35,990 --> 01:07:39,470
your other other canal protections were

1571
01:07:37,940 --> 01:07:41,960
there are a few kind<font color="#E5E5E5"> of protection from</font>

1572
01:07:39,470 --> 01:07:44,029
<font color="#E5E5E5">pax but we don't</font><font color="#CCCCCC"> have much time now if</font>

1573
01:07:41,960 --> 01:07:47,930
you want to<font color="#E5E5E5"> take questions so</font><font color="#CCCCCC"> i will</font><font color="#E5E5E5"> go</font>

1574
01:07:44,030 --> 01:07:51,619
through this quickly<font color="#E5E5E5"> so there are lots</font>

1575
01:07:47,930 --> 01:07:55,100
of birds to find in canada we found 20

1576
01:07:51,619 --> 01:07:59,000
of them in<font color="#E5E5E5"> in a year and we were still</font>

1577
01:07:55,100 --> 01:08:02,240
doing a lot of other job other work so

1578
01:07:59,000 --> 01:08:04,100
it's there are lots of work<font color="#E5E5E5"> to find the</font>

1579
01:08:02,240 --> 01:08:06,618
attack surface is growing in general and

1580
01:08:04,100 --> 01:08:09,020
the<font color="#E5E5E5"> really interesting thing that's not</font>

1581
01:08:06,619 --> 01:08:11,180
necessarily expected is it's<font color="#E5E5E5"> actually</font>

1582
01:08:09,020 --> 01:08:14,119
easier to<font color="#E5E5E5"> reach these attacks for phase</font>

1583
01:08:11,180 --> 01:08:15,669
from remote if you've attended our talk

1584
01:08:14,119 --> 01:08:18,190
on virtualization a

1585
01:08:15,670 --> 01:08:21,730
pack<font color="#E5E5E5"> sec we also we've also said a sim</font>

1586
01:08:18,189 --> 01:08:24,549
racing for<font color="#CCCCCC"> theater ization because</font>

1587
01:08:21,729 --> 01:08:27,129
basically what happens is for

1588
01:08:24,549 --> 01:08:29,080
<font color="#E5E5E5">performance is reasoned people want to</font>

1589
01:08:27,130 --> 01:08:30,790
design<font color="#CCCCCC"> system so that everything goes</font>

1590
01:08:29,080 --> 01:08:33,880
<font color="#CCCCCC">through as fast as possible to the</font>

1591
01:08:30,790 --> 01:08:35,830
hardware<font color="#E5E5E5"> and there is actually</font><font color="#CCCCCC"> more and</font>

1592
01:08:33,880 --> 01:08:37,839
more low-level attacks of<font color="#CCCCCC"> face exposed</font>

1593
01:08:35,830 --> 01:08:41,080
remotely which is which might be

1594
01:08:37,839 --> 01:08:43,269
unexpected and so they are expert the

1595
01:08:41,080 --> 01:08:46,000
exploitation of those flows goes from

1596
01:08:43,270 --> 01:08:48,219
<font color="#CCCCCC">very easy to very challenging it can be</font>

1597
01:08:46,000 --> 01:08:50,439
really trivial and really<font color="#E5E5E5"> hard it's</font>

1598
01:08:48,219 --> 01:08:54,189
really hard to also get rid of the

1599
01:08:50,439 --> 01:08:56,948
<font color="#CCCCCC">knesset extra face even even in systems</font>

1600
01:08:54,189 --> 01:09:00,428
design with security in mind it remains

1601
01:08:56,948 --> 01:09:03,160
so yeah we're hoping that<font color="#CCCCCC"> Microsoft will</font>

1602
01:09:00,429 --> 01:09:06,489
have some kernels attack<font color="#CCCCCC"> surface</font>

1603
01:09:03,160 --> 01:09:11,019
reduction facilities soon in Windows

1604
01:09:06,488 --> 01:09:13,689
we'll see<font color="#E5E5E5"> how it goes also you can</font>

1605
01:09:11,020 --> 01:09:16,120
really say that use on prevention user

1606
01:09:13,689 --> 01:09:19,719
and exploitation prevention is kind of

1607
01:09:16,120 --> 01:09:21,519
mature but in in terms<font color="#E5E5E5"> of</font><font color="#CCCCCC"> Colonel</font>

1608
01:09:19,719 --> 01:09:23,710
expectation prevention it's really the

1609
01:09:21,520 --> 01:09:26,020
beginning and all the<font color="#CCCCCC"> current send</font>

1610
01:09:23,710 --> 01:09:30,399
<font color="#CCCCCC">boxing techniques you see in Google</font>

1611
01:09:26,020 --> 01:09:34,179
Chrome now in microsoft office soon in

1612
01:09:30,399 --> 01:09:37,778
other products really make the<font color="#E5E5E5"> current</font>

1613
01:09:34,179 --> 01:09:40,149
an ideal target so thank thank you<font color="#E5E5E5"> for</font>

1614
01:09:37,779 --> 01:09:42,400
attending and if you have<font color="#E5E5E5"> any question</font>

1615
01:09:40,149 --> 01:09:44,549
we can take them we still have six

1616
01:09:42,399 --> 01:09:44,549
minutes

1617
01:09:48,670 --> 01:09:53,880
no questions thank you bye

