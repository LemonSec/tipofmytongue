1
00:00:00,000 --> 00:00:06,330
greetings welcome to Black Hat USA 2010

2
00:00:03,389 --> 00:00:15,120
you are in the exploitation<font color="#CCCCCC"> track and I</font>

3
00:00:06,330 --> 00:00:18,359
present to you chris valasek hi everyone

4
00:00:15,120 --> 00:00:20,100
everyone hear me all right<font color="#E5E5E5"> as he said my</font>

5
00:00:18,359 --> 00:00:24,810
name<font color="#E5E5E5"> is</font><font color="#CCCCCC"> Chris valasek and this is</font>

6
00:00:20,100 --> 00:00:25,680
cross-site scripting for dummies now

7
00:00:24,810 --> 00:00:27,810
we're going to<font color="#E5E5E5"> talk about the low</font>

8
00:00:25,680 --> 00:00:30,240
fragmentation heat today and a lot<font color="#CCCCCC"> of</font>

9
00:00:27,810 --> 00:00:33,660
<font color="#E5E5E5">things have have kind of changed since</font>

10
00:00:30,240 --> 00:00:35,339
windows XP service pack 2 and we're

11
00:00:33,660 --> 00:00:36,839
going to<font color="#E5E5E5"> go over all that stuff today a</font>

12
00:00:35,340 --> 00:00:40,230
lot<font color="#CCCCCC"> of data structures have been added</font>

13
00:00:36,840 --> 00:00:41,969
right to deal with this newfound

14
00:00:40,230 --> 00:00:44,489
technology that needed to<font color="#E5E5E5"> add data</font>

15
00:00:41,969 --> 00:00:47,489
structure in<font color="#CCCCCC"> my opinion memory</font>

16
00:00:44,489 --> 00:00:49,199
management has become probably far more

17
00:00:47,489 --> 00:00:51,269
complex<font color="#E5E5E5"> than it used to be</font><font color="#CCCCCC"> you have</font>

18
00:00:49,200 --> 00:00:53,399
these simple<font color="#CCCCCC"> lookaside lists</font><font color="#E5E5E5"> right that</font>

19
00:00:51,270 --> 00:00:55,800
we're<font color="#E5E5E5"> just singly linked list low</font>

20
00:00:53,399 --> 00:00:58,800
fragmentation heap is kind of a bit more

21
00:00:55,800 --> 00:01:01,410
complex obviously there's new security

22
00:00:58,800 --> 00:01:03,328
measures and what I say this this is the

23
00:01:01,410 --> 00:01:06,658
windows vista<font color="#E5E5E5"> code base that is you know</font>

24
00:01:03,329 --> 00:01:08,790
rolled into<font color="#CCCCCC"> Windows 7 as well and with</font>

25
00:01:06,659 --> 00:01:11,430
all these security measures you need to

26
00:01:08,790 --> 00:01:14,340
ensure<font color="#CCCCCC"> that</font><font color="#E5E5E5"> you can get the proper</font>

27
00:01:11,430 --> 00:01:16,350
levels of determinism in the heap when

28
00:01:14,340 --> 00:01:19,140
exploiting vulnerabilities you know

29
00:01:16,350 --> 00:01:22,320
<font color="#E5E5E5">before writing a bunch of 4 byte</font>

30
00:01:19,140 --> 00:01:24,990
addresses everywhere and getting a nice

31
00:01:22,320 --> 00:01:27,298
unlink that that's over it doesn't exist

32
00:01:24,990 --> 00:01:29,939
anymore but even<font color="#CCCCCC"> with all</font><font color="#E5E5E5"> this</font>

33
00:01:27,299 --> 00:01:33,540
protection there is there is<font color="#E5E5E5"> still</font>

34
00:01:29,939 --> 00:01:35,548
there's still a lot to be done with with

35
00:01:33,540 --> 00:01:38,400
metadata corruption and and we'll

36
00:01:35,549 --> 00:01:42,060
<font color="#CCCCCC">discuss that</font><font color="#E5E5E5"> as well today it's going to</font>

37
00:01:38,400 --> 00:01:44,670
<font color="#E5E5E5">go in order from boring too boring</font><font color="#CCCCCC"> ER to</font>

38
00:01:42,060 --> 00:01:46,829
most boring<font color="#E5E5E5"> to fun we'll talk about the</font>

39
00:01:44,670 --> 00:01:51,090
core data structures all the stuff they

40
00:01:46,829 --> 00:01:54,570
added in this in this new heap will then

41
00:01:51,090 --> 00:01:55,740
talk about architecture specifically<font color="#E5E5E5"> the</font>

42
00:01:54,570 --> 00:01:58,469
free list and they have changed

43
00:01:55,740 --> 00:02:00,960
drastically since we've last visited

44
00:01:58,469 --> 00:02:04,710
them<font color="#CCCCCC"> in the windows XP</font><font color="#E5E5E5"> code base and</font>

45
00:02:00,960 --> 00:02:06,030
finally everyone can feel<font color="#CCCCCC"> free to go</font>

46
00:02:04,710 --> 00:02:08,609
asleep<font color="#E5E5E5"> while I go through the core</font>

47
00:02:06,030 --> 00:02:09,780
algorithms as I'll do it both for the

48
00:02:08,610 --> 00:02:12,540
front end and

49
00:02:09,780 --> 00:02:14,700
and the<font color="#E5E5E5"> back end</font><font color="#CCCCCC"> and lastly we'll</font>

50
00:02:12,540 --> 00:02:17,310
discuss tactics specifically heap

51
00:02:14,700 --> 00:02:20,970
determinism and then some exploitation

52
00:02:17,310 --> 00:02:22,980
techniques one by<font color="#CCCCCC"> Ben Hawks which I call</font>

53
00:02:20,970 --> 00:02:26,340
Ben<font color="#E5E5E5"> Hawks number one and then another</font>

54
00:02:22,980 --> 00:02:28,170
one that is strikingly similar by me

55
00:02:26,340 --> 00:02:31,800
which is overriding this free entry

56
00:02:28,170 --> 00:02:34,140
offset before I start<font color="#CCCCCC"> I</font><font color="#E5E5E5"> would like to</font>

57
00:02:31,800 --> 00:02:36,239
kind of define some terms I'm not trying

58
00:02:34,140 --> 00:02:38,549
<font color="#CCCCCC">to say any other terms are wrong and</font>

59
00:02:36,239 --> 00:02:39,840
minor right<font color="#E5E5E5"> I just want to be consistent</font>

60
00:02:38,550 --> 00:02:42,000
throughout this talk and they're also

61
00:02:39,840 --> 00:02:45,630
consistent throughout<font color="#E5E5E5"> the paper I wrote</font>

62
00:02:42,000 --> 00:02:47,700
with this presentation as well I got all

63
00:02:45,630 --> 00:02:50,640
the code from a<font color="#E5E5E5"> specific version of NT</font>

64
00:02:47,700 --> 00:02:53,190
dll i know that's changed I had a<font color="#E5E5E5"> panic</font>

65
00:02:50,640 --> 00:02:56,160
attack when i saw<font color="#CCCCCC"> it changed luckily not</font>

66
00:02:53,190 --> 00:02:58,560
too much if anything was touched that I

67
00:02:56,160 --> 00:03:01,560
cover in this presentation when I say

68
00:02:58,560 --> 00:03:04,470
block or blocks one block equals<font color="#E5E5E5"> eight</font>

69
00:03:01,560 --> 00:03:06,420
bytes you know that's the unit

70
00:03:04,470 --> 00:03:09,209
measurement for keeping track of memory

71
00:03:06,420 --> 00:03:10,890
in<font color="#CCCCCC"> the heap a chunk is a contiguous</font>

72
00:03:09,209 --> 00:03:14,790
piece of memory that<font color="#CCCCCC"> is</font><font color="#E5E5E5"> either measured</font>

73
00:03:10,890 --> 00:03:16,589
in blocks or bytes of course<font color="#E5E5E5"> I'll say LF</font>

74
00:03:14,790 --> 00:03:18,150
<font color="#E5E5E5">h instead</font><font color="#CCCCCC"> of saying low fragmentation</font>

75
00:03:16,590 --> 00:03:21,000
heap every time because that's just a

76
00:03:18,150 --> 00:03:23,010
mouthful and finally this<font color="#CCCCCC"> is probably</font>

77
00:03:21,000 --> 00:03:25,680
the one that some people might not agree

78
00:03:23,010 --> 00:03:29,280
with but when I use the<font color="#E5E5E5"> term bucket or</font>

79
00:03:25,680 --> 00:03:31,590
heat bucket this actually refers to the

80
00:03:29,280 --> 00:03:33,209
size<font color="#E5E5E5"> a unit measurement instead of</font>

81
00:03:31,590 --> 00:03:35,820
actually a piece of committed memory

82
00:03:33,209 --> 00:03:38,940
that will service<font color="#CCCCCC"> request</font><font color="#E5E5E5"> I do this</font>

83
00:03:35,820 --> 00:03:40,980
because there's a heat bucket data

84
00:03:38,940 --> 00:03:43,079
structure in the debugging symbols and

85
00:03:40,980 --> 00:03:45,810
it's a<font color="#CCCCCC"> four byte data</font><font color="#E5E5E5"> structure that</font><font color="#CCCCCC"> is</font>

86
00:03:43,079 --> 00:03:47,430
solely used for indices and<font color="#E5E5E5"> size when I</font>

87
00:03:45,810 --> 00:03:49,500
talk<font color="#CCCCCC"> about the committed memory that's</font>

88
00:03:47,430 --> 00:03:52,140
used<font color="#E5E5E5"> to service these requests I'll say</font>

89
00:03:49,500 --> 00:03:56,280
heat bin user blocks or something<font color="#CCCCCC"> of</font>

90
00:03:52,140 --> 00:03:58,679
that nature<font color="#CCCCCC"> okay time for the core data</font>

91
00:03:56,280 --> 00:04:00,930
structures if you don't understand all

92
00:03:58,680 --> 00:04:03,150
these right off the bat that's<font color="#E5E5E5"> okay</font>

93
00:04:00,930 --> 00:04:04,500
they're kind<font color="#E5E5E5"> of complex and I think</font>

94
00:04:03,150 --> 00:04:06,359
you'll get a better<font color="#CCCCCC"> idea of how they</font>

95
00:04:04,500 --> 00:04:08,940
work once we go through the algorithm

96
00:04:06,359 --> 00:04:10,440
section we'll start<font color="#E5E5E5"> with the kind of</font>

97
00:04:08,940 --> 00:04:13,739
heart of all this every heap that gets

98
00:04:10,440 --> 00:04:15,690
created is going to have a heap base and

99
00:04:13,739 --> 00:04:18,030
this heat base is this big data

100
00:04:15,690 --> 00:04:22,180
structure and<font color="#E5E5E5"> it's really similar to</font><font color="#CCCCCC"> how</font>

101
00:04:18,029 --> 00:04:24,460
it was in<font color="#E5E5E5"> Windows XP but some things</font>

102
00:04:22,180 --> 00:04:25,720
change there are security mechanisms the

103
00:04:24,460 --> 00:04:28,000
first thing<font color="#E5E5E5"> I'll talk</font><font color="#CCCCCC"> about is a thing</font>

104
00:04:25,720 --> 00:04:30,490
called the encode flag mask this is a

105
00:04:28,000 --> 00:04:32,979
value that's set in the heap create call

106
00:04:30,490 --> 00:04:34,960
and it's used to check to<font color="#CCCCCC"> see if a chunk</font>

107
00:04:32,979 --> 00:04:36,639
was encoded it'll do a bitwise operation

108
00:04:34,960 --> 00:04:39,159
interment if a chunk was encoded or not

109
00:04:36,639 --> 00:04:41,199
that brings us<font color="#CCCCCC"> to the encoding member</font>

110
00:04:39,160 --> 00:04:43,419
this encoding member is a pseudo

111
00:04:41,199 --> 00:04:45,250
randomly generated value during heap

112
00:04:43,419 --> 00:04:47,320
create that actually used in the

113
00:04:45,250 --> 00:04:49,360
encoding process when encoding chunk

114
00:04:47,320 --> 00:04:52,659
headers which we'll talk about as we go

115
00:04:49,360 --> 00:04:55,150
on the<font color="#CCCCCC"> block's index or the heap list</font>

116
00:04:52,660 --> 00:04:57,070
look up structure is<font color="#CCCCCC"> the next slide and</font>

117
00:04:55,150 --> 00:04:59,500
<font color="#CCCCCC">I think is the second most important</font>

118
00:04:57,070 --> 00:05:01,960
data structure in the<font color="#CCCCCC"> windows 7 heap</font>

119
00:04:59,500 --> 00:05:04,270
that brings us<font color="#CCCCCC"> to the free list and</font>

120
00:05:01,960 --> 00:05:06,520
these<font color="#CCCCCC"> are similar</font><font color="#E5E5E5"> to the free list that</font>

121
00:05:04,270 --> 00:05:09,039
we're in<font color="#CCCCCC"> Windows</font><font color="#E5E5E5"> XP but instead of</font>

122
00:05:06,520 --> 00:05:11,229
having these dedicated free lists you

123
00:05:09,039 --> 00:05:12,699
have this overall free<font color="#E5E5E5"> this structure</font>

124
00:05:11,229 --> 00:05:14,620
and we'll go over that<font color="#E5E5E5"> more in the</font>

125
00:05:12,699 --> 00:05:16,360
architecture section just remember that

126
00:05:14,620 --> 00:05:19,750
this pointer resides in the heat base

127
00:05:16,360 --> 00:05:21,550
and finally you<font color="#CCCCCC"> have a front-end heap</font>

128
00:05:19,750 --> 00:05:23,620
and the only front-end heap supported by

129
00:05:21,550 --> 00:05:26,770
windows 7 is the low fragmentation heap

130
00:05:23,620 --> 00:05:29,770
there is no more<font color="#E5E5E5"> look aside list the</font>

131
00:05:26,770 --> 00:05:32,440
heap let's look up or blocks index it is

132
00:05:29,770 --> 00:05:34,510
a linked list data structure so<font color="#E5E5E5"> the</font>

133
00:05:32,440 --> 00:05:37,060
first member is a pointer to the next

134
00:05:34,510 --> 00:05:39,190
blocks index if there isn't one it's

135
00:05:37,060 --> 00:05:42,550
going<font color="#E5E5E5"> to be known it has an array size</font>

136
00:05:39,190 --> 00:05:44,620
it tracks chunks of a certain size and

137
00:05:42,550 --> 00:05:48,250
this array size is measured in blocks

138
00:05:44,620 --> 00:05:52,509
and says this is how<font color="#CCCCCC"> many in blocks</font>

139
00:05:48,250 --> 00:05:55,000
chunks I will track so the first blocks

140
00:05:52,509 --> 00:05:59,320
index as i call it will track all chunks

141
00:05:55,000 --> 00:06:02,710
below 80 blocks or 124 bites the second

142
00:05:59,320 --> 00:06:07,000
one will track chunks under<font color="#E5E5E5"> 800 blocks</font>

143
00:06:02,710 --> 00:06:08,620
or 16 k you have a base index since

144
00:06:07,000 --> 00:06:10,240
there's multiple blocks index and they

145
00:06:08,620 --> 00:06:11,860
measure different sizes this is just

146
00:06:10,240 --> 00:06:16,690
<font color="#E5E5E5">used to get a relative offset</font><font color="#CCCCCC"> two places</font>

147
00:06:11,860 --> 00:06:18,970
then you have a list head and this list

148
00:06:16,690 --> 00:06:21,460
head is literally identical to the heap

149
00:06:18,970 --> 00:06:24,190
free list pointer<font color="#CCCCCC"> it's assigned during</font>

150
00:06:21,460 --> 00:06:26,979
creation in heap create or<font color="#CCCCCC"> are TLP</font>

151
00:06:24,190 --> 00:06:28,719
extend list look up so it is<font color="#CCCCCC"> literally</font>

152
00:06:26,979 --> 00:06:31,450
<font color="#E5E5E5">identical to the pointer that is in the</font>

153
00:06:28,720 --> 00:06:33,660
heat base now that you have multiple

154
00:06:31,450 --> 00:06:36,000
blocks index and

155
00:06:33,660 --> 00:06:37,800
and these blocks index contain<font color="#E5E5E5"> the</font>

156
00:06:36,000 --> 00:06:39,990
listings right these lists hints are

157
00:06:37,800 --> 00:06:42,000
kind of like<font color="#E5E5E5"> the old free list as</font>

158
00:06:39,990 --> 00:06:43,770
they're dedicated a certain size but

159
00:06:42,000 --> 00:06:45,240
they actually<font color="#CCCCCC"> can go into</font><font color="#E5E5E5"> the next size</font>

160
00:06:43,770 --> 00:06:47,729
as<font color="#CCCCCC"> well we'll go over this in the</font>

161
00:06:45,240 --> 00:06:49,440
architecture section and<font color="#E5E5E5"> be it that each</font>

162
00:06:47,730 --> 00:06:51,870
one of these blocks in desks can have

163
00:06:49,440 --> 00:06:54,000
free list right you're going to need<font color="#E5E5E5"> the</font>

164
00:06:51,870 --> 00:06:56,580
optimization the<font color="#CCCCCC"> listing use of ulong</font>

165
00:06:54,000 --> 00:06:58,500
aka<font color="#E5E5E5"> the free list and use bitmap instead</font>

166
00:06:56,580 --> 00:07:00,060
of<font color="#E5E5E5"> having one just in heat base you're</font>

167
00:06:58,500 --> 00:07:03,630
going to have one for each blocks index

168
00:07:00,060 --> 00:07:05,940
the low fragmentation heat<font color="#E5E5E5"> blocks own</font>

169
00:07:03,630 --> 00:07:08,520
structure is a small data structure

170
00:07:05,940 --> 00:07:10,740
that's used solely for providing

171
00:07:08,520 --> 00:07:13,140
addresses to create other data

172
00:07:10,740 --> 00:07:17,100
structures<font color="#CCCCCC"> and</font><font color="#E5E5E5"> what will kind of get on</font>

173
00:07:13,140 --> 00:07:18,780
this more in the allocation section the

174
00:07:17,100 --> 00:07:21,510
low fragmentation heap as you can

175
00:07:18,780 --> 00:07:23,520
probably guess keeps track of items in

176
00:07:21,510 --> 00:07:25,170
the low fragmentation heap<font color="#E5E5E5"> and</font><font color="#CCCCCC"> I think</font>

177
00:07:23,520 --> 00:07:26,940
<font color="#CCCCCC">the most important data structures are</font>

178
00:07:25,170 --> 00:07:28,590
the buckets these are the<font color="#CCCCCC"> four byte data</font>

179
00:07:26,940 --> 00:07:30,870
structure the heat buckets that<font color="#CCCCCC"> I talked</font>

180
00:07:28,590 --> 00:07:33,179
about you see that there's only 128 of

181
00:07:30,870 --> 00:07:35,640
them right but the low fragmentation you

182
00:07:33,180 --> 00:07:36,990
can keep track<font color="#E5E5E5"> of 16 k that means</font>

183
00:07:35,640 --> 00:07:39,330
there's you know less buckets than there

184
00:07:36,990 --> 00:07:42,000
are chunks there's actually an algorithm

185
00:07:39,330 --> 00:07:43,109
<font color="#CCCCCC">that is used to determine if a chunk</font>

186
00:07:42,000 --> 00:07:45,060
could be serviced by the low

187
00:07:43,110 --> 00:07:48,120
fragmentation heat this low

188
00:07:45,060 --> 00:07:50,730
fragmentation heap contains a heap local

189
00:07:48,120 --> 00:07:54,210
data and this heap local data sole

190
00:07:50,730 --> 00:07:56,820
purpose is providing an array of heap

191
00:07:54,210 --> 00:07:58,080
local segment info structures again

192
00:07:56,820 --> 00:08:00,210
there was a hundred twenty eight of them

193
00:07:58,080 --> 00:08:02,280
that the kind of same algorithm is used

194
00:08:00,210 --> 00:08:05,489
to determine if there is one for a

195
00:08:02,280 --> 00:08:08,460
certain size these local segment info

196
00:08:05,490 --> 00:08:10,800
structures contain things called sub sub

197
00:08:08,460 --> 00:08:12,750
segments and I know this is kind of

198
00:08:10,800 --> 00:08:14,250
<font color="#E5E5E5">really boring and tricky but hopefully I</font>

199
00:08:12,750 --> 00:08:17,610
have a diagram at the end that that will

200
00:08:14,250 --> 00:08:19,919
little sum all this up but um these sub

201
00:08:17,610 --> 00:08:21,480
segments are actually used<font color="#E5E5E5"> for servicing</font>

202
00:08:19,919 --> 00:08:23,310
requests they contain pointers to

203
00:08:21,480 --> 00:08:25,410
committed memory that is used for

204
00:08:23,310 --> 00:08:29,760
allocation and then freeing into them as

205
00:08:25,410 --> 00:08:33,210
well each sub segments will contain I

206
00:08:29,760 --> 00:08:36,120
think to most integral pointers the user

207
00:08:33,210 --> 00:08:38,760
blocks which is a pointer to a heap user

208
00:08:36,120 --> 00:08:41,520
data header and that user data header is

209
00:08:38,760 --> 00:08:42,659
proceeds a big block of<font color="#E5E5E5"> memory that</font>

210
00:08:41,520 --> 00:08:44,460
<font color="#CCCCCC">we're going</font><font color="#E5E5E5"> to call the user blocks</font>

211
00:08:42,659 --> 00:08:47,910
that's the committed memory we use to

212
00:08:44,460 --> 00:08:50,310
allocate and free memory it also has in

213
00:08:47,910 --> 00:08:53,040
interlock sequence structure and this

214
00:08:50,310 --> 00:08:55,560
structure here<font color="#E5E5E5"> a sole purpose is keeping</font>

215
00:08:53,040 --> 00:08:57,750
track of the<font color="#E5E5E5"> state of that user block it</font>

216
00:08:55,560 --> 00:08:59,939
keeps track<font color="#E5E5E5"> of a depth that is how</font><font color="#CCCCCC"> many</font>

217
00:08:57,750 --> 00:09:01,920
chunks does this thing have left it<font color="#CCCCCC"> also</font>

218
00:08:59,940 --> 00:09:04,080
<font color="#E5E5E5">keeps track of an offset the offset is</font>

219
00:09:01,920 --> 00:09:08,610
where is the next free chunk of memory I

220
00:09:04,080 --> 00:09:11,310
can use<font color="#CCCCCC"> it as you see this is the the</font>

221
00:09:08,610 --> 00:09:13,740
heap user data header it's a simple<font color="#E5E5E5"> 16</font>

222
00:09:11,310 --> 00:09:16,199
byte structure and then the big<font color="#E5E5E5"> block of</font>

223
00:09:13,740 --> 00:09:17,970
<font color="#E5E5E5">memory that we're going to use the</font>

224
00:09:16,200 --> 00:09:21,150
interlock sequence as I said keeps

225
00:09:17,970 --> 00:09:23,580
tracks of depths and offset lastly we're

226
00:09:21,150 --> 00:09:25,740
going to cover the heap entry structure

227
00:09:23,580 --> 00:09:29,040
which<font color="#CCCCCC"> is what a lot of people refer to</font>

228
00:09:25,740 --> 00:09:31,440
<font color="#E5E5E5">as the chunk header right it has</font><font color="#CCCCCC"> changed</font>

229
00:09:29,040 --> 00:09:32,579
drastically since<font color="#E5E5E5"> Windows XP but it</font>

230
00:09:31,440 --> 00:09:35,160
still contains a lot<font color="#E5E5E5"> of the same</font>

231
00:09:32,580 --> 00:09:36,900
information you have your size you have

232
00:09:35,160 --> 00:09:39,060
flags whether it's free or whether it's

233
00:09:36,900 --> 00:09:43,410
busy<font color="#E5E5E5"> and you're going to have a checksum</font>

234
00:09:39,060 --> 00:09:45,420
in the third offset just a you know<font color="#E5E5E5"> to</font>

235
00:09:43,410 --> 00:09:47,250
<font color="#E5E5E5">let you know only</font><font color="#CCCCCC"> the first four bytes</font>

236
00:09:45,420 --> 00:09:48,900
of this<font color="#E5E5E5"> eight byte data structure are</font>

237
00:09:47,250 --> 00:09:52,770
encoded and we'll talk about that more

238
00:09:48,900 --> 00:09:55,949
as we get along this presentation<font color="#CCCCCC"> okay</font>

239
00:09:52,770 --> 00:09:57,540
so here's my overview and I redid this a

240
00:09:55,950 --> 00:09:59,190
few times and my<font color="#CCCCCC"> buddy John larimer</font>

241
00:09:57,540 --> 00:10:01,920
<font color="#CCCCCC">helped me pan it out so it wasn't a big</font>

242
00:09:59,190 --> 00:10:03,750
jumbled mess but this basically has the

243
00:10:01,920 --> 00:10:05,699
<font color="#E5E5E5">heat it contains to keep this look up</font>

244
00:10:03,750 --> 00:10:07,260
<font color="#E5E5E5">right and it contains aloe fragmentation</font>

245
00:10:05,700 --> 00:10:08,730
heap that low fragmentation heap

246
00:10:07,260 --> 00:10:11,370
contains<font color="#CCCCCC"> the heap local data which</font>

247
00:10:08,730 --> 00:10:13,710
contains an array of heap local 7th info

248
00:10:11,370 --> 00:10:15,480
structures which contains sub segments

249
00:10:13,710 --> 00:10:17,940
and those sub segments they hold

250
00:10:15,480 --> 00:10:20,310
pointers to committed memory right and

251
00:10:17,940 --> 00:10:21,720
it holds a you know a structure<font color="#CCCCCC"> that's</font>

252
00:10:20,310 --> 00:10:23,219
going to keep track of how much of that

253
00:10:21,720 --> 00:10:25,500
<font color="#E5E5E5">memory is left and where should I get</font>

254
00:10:23,220 --> 00:10:27,060
the next piece so I<font color="#E5E5E5"> think this diagram</font>

255
00:10:25,500 --> 00:10:29,850
kind of works out well how how

256
00:10:27,060 --> 00:10:33,510
everything works on to the architecture

257
00:10:29,850 --> 00:10:35,910
section back long a long long time ago

258
00:10:33,510 --> 00:10:38,370
right there were free lists and they

259
00:10:35,910 --> 00:10:40,020
were dedicated that<font color="#E5E5E5"> is a dedicated for</font>

260
00:10:38,370 --> 00:10:42,930
this would only hold chunks of a certain

261
00:10:40,020 --> 00:10:45,180
size no greater no less if they were

262
00:10:42,930 --> 00:10:46,890
empty they would<font color="#CCCCCC"> actually have the ford</font>

263
00:10:45,180 --> 00:10:48,719
lincoln backlink pointer putting back to

264
00:10:46,890 --> 00:10:50,160
the sentinel node to themselves and that

265
00:10:48,720 --> 00:10:52,050
would note that<font color="#E5E5E5"> they're an empty list</font>

266
00:10:50,160 --> 00:10:54,630
<font color="#E5E5E5">these all resided on the heat base</font>

267
00:10:52,050 --> 00:10:57,569
that's that's no longer the case anymore

268
00:10:54,630 --> 00:11:00,330
these<font color="#E5E5E5"> dedicated free list have have</font><font color="#CCCCCC"> been</font>

269
00:10:57,570 --> 00:11:01,139
shed for these lists hints or<font color="#E5E5E5"> will still</font>

270
00:11:00,330 --> 00:11:04,529
<font color="#E5E5E5">call them free list</font>

271
00:11:01,139 --> 00:11:06,209
just not dedicated they don't terminate

272
00:11:04,529 --> 00:11:08,339
by pointing back to themself they just

273
00:11:06,209 --> 00:11:10,498
point to<font color="#CCCCCC"> the next</font><font color="#E5E5E5"> biggest chunk the last</font>

274
00:11:08,339 --> 00:11:12,569
biggest chunk on the list is going to

275
00:11:10,499 --> 00:11:17,790
point to that heap free list pointer on

276
00:11:12,569 --> 00:11:20,519
he base now they're the<font color="#CCCCCC"> same and that</font>

277
00:11:17,790 --> 00:11:23,488
they're linked<font color="#CCCCCC"> this</font><font color="#E5E5E5"> structure but the</font>

278
00:11:20,519 --> 00:11:27,029
the the backlink of these free this kind

279
00:11:23,489 --> 00:11:28,649
of souls a dual purpose now in the

280
00:11:27,029 --> 00:11:30,329
<font color="#E5E5E5">settle nodes then that blocks index the</font>

281
00:11:28,649 --> 00:11:32,699
list hint structure that<font color="#E5E5E5"> I was</font><font color="#CCCCCC"> talking</font>

282
00:11:30,329 --> 00:11:35,549
about<font color="#E5E5E5"> these do contain lists for a</font>

283
00:11:32,699 --> 00:11:37,410
certain size but in the<font color="#CCCCCC"> backlink if a</font>

284
00:11:35,549 --> 00:11:39,179
low fragmentation heap isn't in use for

285
00:11:37,410 --> 00:11:41,100
it it's going<font color="#E5E5E5"> to keep a counter and that</font>

286
00:11:39,179 --> 00:11:42,809
counter is going<font color="#E5E5E5"> to be used to actually</font>

287
00:11:41,100 --> 00:11:46,049
enable the low fragmentation heap after

288
00:11:42,809 --> 00:11:47,850
its reads to a certain threshold if it

289
00:11:46,049 --> 00:11:50,549
doesn't<font color="#E5E5E5"> contain a counter it's going to</font>

290
00:11:47,850 --> 00:11:52,499
contain a heap bucket and it's a dress

291
00:11:50,549 --> 00:11:55,858
of a heat bucket<font color="#E5E5E5"> plus one that's how the</font>

292
00:11:52,499 --> 00:11:57,149
allocator and<font color="#CCCCCC"> D allocator know whether</font>

293
00:11:55,859 --> 00:12:00,059
to use the<font color="#CCCCCC"> front-end heap the low</font>

294
00:11:57,149 --> 00:12:01,739
fragmentation heap or the back end<font color="#CCCCCC"> and</font>

295
00:12:00,059 --> 00:12:03,929
like<font color="#E5E5E5"> I said before the low fragmentation</font>

296
00:12:01,739 --> 00:12:06,569
heap only deals with chunks from eight

297
00:12:03,929 --> 00:12:09,389
to 16 k<font color="#E5E5E5"> in bytes that doesn't mean the</font>

298
00:12:06,569 --> 00:12:10,919
blocks index don't track you know chunks

299
00:12:09,389 --> 00:12:13,589
larger than that it's just<font color="#CCCCCC"> that the low</font>

300
00:12:10,919 --> 00:12:16,470
fragmentation heap won't won't do any of

301
00:12:13,589 --> 00:12:19,439
the work for<font color="#CCCCCC"> them okay so here's a</font>

302
00:12:16,470 --> 00:12:21,779
little simple example I have<font color="#E5E5E5"> it's only a</font>

303
00:12:19,439 --> 00:12:24,118
small heap that has the first blocks

304
00:12:21,779 --> 00:12:26,429
index enabled and it has five chunks

305
00:12:24,119 --> 00:12:29,220
that is tracking the first three chunks

306
00:12:26,429 --> 00:12:33,119
going from upper<font color="#CCCCCC"> right hand corner to</font>

307
00:12:29,220 --> 00:12:34,919
bottom or are<font color="#CCCCCC"> four six blocks but as you</font>

308
00:12:33,119 --> 00:12:37,829
see that<font color="#CCCCCC"> the third one for six blocks</font>

309
00:12:34,919 --> 00:12:39,629
doesn't point back to the blocks index

310
00:12:37,829 --> 00:12:41,519
structure it actually<font color="#CCCCCC"> points down to the</font>

311
00:12:39,629 --> 00:12:45,629
<font color="#E5E5E5">next biggest chunk which is of size</font>

312
00:12:41,519 --> 00:12:47,699
seven blocks is this differs greatly

313
00:12:45,629 --> 00:12:50,939
obviously from how it worked in windows

314
00:12:47,699 --> 00:12:53,219
XP that that chunk for size of<font color="#E5E5E5"> seven</font>

315
00:12:50,939 --> 00:12:56,279
blocks again doesn't terminate itself it

316
00:12:53,220 --> 00:12:58,230
points to the next biggest chunk this

317
00:12:56,279 --> 00:12:59,910
next<font color="#E5E5E5"> biggest chunk is held in a special</font>

318
00:12:58,230 --> 00:13:02,730
free list this is very<font color="#E5E5E5"> similar to how</font>

319
00:12:59,910 --> 00:13:04,709
free list 0 worked in Windows XP you're

320
00:13:02,730 --> 00:13:06,929
going to have a list hint that holds all

321
00:13:04,709 --> 00:13:09,809
chunks greater than array size minus<font color="#CCCCCC"> 1</font>

322
00:13:06,929 --> 00:13:10,919
at a certain position this finally since

323
00:13:09,809 --> 00:13:13,810
it's the last chunk that we're managing

324
00:13:10,919 --> 00:13:16,689
points back<font color="#E5E5E5"> to the the</font>

325
00:13:13,810 --> 00:13:21,369
the heat base in the free list member

326
00:13:16,690 --> 00:13:23,920
section but you also see<font color="#CCCCCC"> that there's a</font>

327
00:13:21,370 --> 00:13:25,270
free list at free list eight that

328
00:13:23,920 --> 00:13:27,069
doesn't have a forward length pointer

329
00:13:25,270 --> 00:13:31,480
everywhere but it does have a backlink

330
00:13:27,070 --> 00:13:34,150
that that can be<font color="#E5E5E5"> bitwise ANDed with one</font>

331
00:13:31,480 --> 00:13:35,710
and if that<font color="#CCCCCC"> pass is true then it</font>

332
00:13:34,150 --> 00:13:37,959
contains a heat bucket and this one does

333
00:13:35,710 --> 00:13:40,029
you see<font color="#CCCCCC"> all the other ones</font><font color="#E5E5E5"> that do have</font>

334
00:13:37,960 --> 00:13:42,460
forward link pointers actually contain

335
00:13:40,029 --> 00:13:45,490
you know an integer value this is the

336
00:13:42,460 --> 00:13:49,120
counter that's used in to enable the low

337
00:13:45,490 --> 00:13:51,400
fragmentation heat I like<font color="#CCCCCC"> to</font><font color="#E5E5E5"> think of</font>

338
00:13:49,120 --> 00:13:53,980
these new free list structure as a

339
00:13:51,400 --> 00:13:57,730
circular organization of chunk headers

340
00:13:53,980 --> 00:14:00,730
or a cock and these cocks are much like

341
00:13:57,730 --> 00:14:03,279
the<font color="#E5E5E5"> highway system right so you're going</font>

342
00:14:00,730 --> 00:14:07,300
<font color="#E5E5E5">to you know wrap around the example I</font>

343
00:14:03,279 --> 00:14:09,550
like to give is you<font color="#E5E5E5"> don't go to mal</font><font color="#CCCCCC"> zero</font>

344
00:14:07,300 --> 00:14:11,079
at us one to get on it you're going to

345
00:14:09,550 --> 00:14:12,969
find the nearest tributary to get on

346
00:14:11,080 --> 00:14:14,380
yourself<font color="#E5E5E5"> right so that's what the list</font>

347
00:14:12,970 --> 00:14:17,680
hints are like now if the listings

348
00:14:14,380 --> 00:14:20,200
failed and<font color="#E5E5E5"> you know you're in Cuba you</font>

349
00:14:17,680 --> 00:14:22,180
probably<font color="#E5E5E5"> have to start at mal one and go</font>

350
00:14:20,200 --> 00:14:24,580
from there so<font color="#E5E5E5"> hopefully with this</font>

351
00:14:22,180 --> 00:14:26,589
explanation example and my newly devised

352
00:14:24,580 --> 00:14:30,280
acronym you will remember how the free

353
00:14:26,589 --> 00:14:31,870
lists work<font color="#CCCCCC"> ok we're going</font><font color="#E5E5E5"> to start</font><font color="#CCCCCC"> with</font>

354
00:14:30,280 --> 00:14:33,939
allocation I like<font color="#E5E5E5"> to start with</font>

355
00:14:31,870 --> 00:14:37,150
allocation because you can't free a

356
00:14:33,940 --> 00:14:40,510
chunk without allocating at first the

357
00:14:37,150 --> 00:14:42,400
allocation a function kind of starts off

358
00:14:40,510 --> 00:14:44,410
with a<font color="#E5E5E5"> little bit of a rapper as does</font>

359
00:14:42,400 --> 00:14:46,240
free the first thing this<font color="#E5E5E5"> rapper is</font>

360
00:14:44,410 --> 00:14:48,310
going to do is it's going to sure that

361
00:14:46,240 --> 00:14:49,510
the size you pass to it is eight by the

362
00:14:48,310 --> 00:14:52,359
line it's<font color="#E5E5E5"> going to round it to the</font>

363
00:14:49,510 --> 00:14:55,000
nearest<font color="#E5E5E5"> eight byte integer right this</font>

364
00:14:52,360 --> 00:14:56,920
also if you pass it zero it's<font color="#E5E5E5"> still</font>

365
00:14:55,000 --> 00:14:58,839
<font color="#E5E5E5">going to give you eight bytes back at</font>

366
00:14:56,920 --> 00:15:00,040
least in user land this<font color="#CCCCCC"> is how memory</font>

367
00:14:58,839 --> 00:15:01,870
works a lot of<font color="#E5E5E5"> people think if you pass</font>

368
00:15:00,040 --> 00:15:03,370
it 0 it's<font color="#E5E5E5"> going to give you nothing back</font>

369
00:15:01,870 --> 00:15:06,820
it will actually round it<font color="#E5E5E5"> to eight and</font>

370
00:15:03,370 --> 00:15:08,530
give you<font color="#CCCCCC"> 8 bytes back so just for to</font>

371
00:15:06,820 --> 00:15:10,360
clear that up if everyone thought you

372
00:15:08,530 --> 00:15:13,839
<font color="#E5E5E5">would get zero bytes back in user land</font>

373
00:15:10,360 --> 00:15:16,570
the next<font color="#E5E5E5"> thing it does is pretty simple</font>

374
00:15:13,839 --> 00:15:18,220
it starts iterating through those blocks

375
00:15:16,570 --> 00:15:20,800
index structures right and they had the

376
00:15:18,220 --> 00:15:22,839
array size and it's going<font color="#E5E5E5"> to say does</font>

377
00:15:20,800 --> 00:15:24,550
the chunk I want is it bigger than this

378
00:15:22,839 --> 00:15:26,560
array saw is if it<font color="#CCCCCC"> is it's going</font><font color="#E5E5E5"> to try</font>

379
00:15:24,550 --> 00:15:27,339
to<font color="#E5E5E5"> go to the next blocks index if it</font>

380
00:15:26,560 --> 00:15:29,229
doesn't<font color="#CCCCCC"> have one</font>

381
00:15:27,340 --> 00:15:30,910
it's going<font color="#E5E5E5"> to use the index of that</font>

382
00:15:29,230 --> 00:15:32,920
special free list zebra like structure

383
00:15:30,910 --> 00:15:35,199
to start searching for this allocation

384
00:15:32,920 --> 00:15:36,819
request again throughout this

385
00:15:35,200 --> 00:15:41,200
presentation will refer<font color="#CCCCCC"> to this piece of</font>

386
00:15:36,820 --> 00:15:43,090
code as blocks index search<font color="#CCCCCC"> okay so now</font>

387
00:15:41,200 --> 00:15:45,430
<font color="#CCCCCC">it has an index what's it going to do</font>

388
00:15:43,090 --> 00:15:48,310
it's going to get the list hint for that

389
00:15:45,430 --> 00:15:51,579
certain index and if<font color="#CCCCCC"> that list exists</font>

390
00:15:48,310 --> 00:15:53,109
and the backlink of it can<font color="#E5E5E5"> be ended with</font>

391
00:15:51,580 --> 00:15:55,300
one<font color="#E5E5E5"> it's going to use a low</font>

392
00:15:53,110 --> 00:15:57,610
fragmentation heap if<font color="#E5E5E5"> anything else</font>

393
00:15:55,300 --> 00:16:01,479
<font color="#E5E5E5">fails it will use the</font><font color="#CCCCCC"> backend manager to</font>

394
00:15:57,610 --> 00:16:03,910
service this request<font color="#E5E5E5"> I just like to</font>

395
00:16:01,480 --> 00:16:06,160
reiterate that the<font color="#E5E5E5"> backend manager is</font>

396
00:16:03,910 --> 00:16:08,199
used in failure whether there's<font color="#CCCCCC"> no heat</font>

397
00:16:06,160 --> 00:16:13,780
bucket or the<font color="#E5E5E5"> front end manager fails</font>

398
00:16:08,200 --> 00:16:14,980
<font color="#CCCCCC">okay so we we have to decide which piece</font>

399
00:16:13,780 --> 00:16:16,600
of<font color="#CCCCCC"> this we're going</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> look</font><font color="#E5E5E5"> at first and</font>

400
00:16:14,980 --> 00:16:18,820
I'd like<font color="#E5E5E5"> to</font><font color="#CCCCCC"> look at the back end manager</font>

401
00:16:16,600 --> 00:16:22,240
<font color="#CCCCCC">first because the back end manager is</font>

402
00:16:18,820 --> 00:16:24,430
actually responsible for activating and

403
00:16:22,240 --> 00:16:27,220
enabling the low fragmentation heat

404
00:16:24,430 --> 00:16:29,140
again the first thing it does is it sees

405
00:16:27,220 --> 00:16:31,600
that list<font color="#CCCCCC"> entry</font><font color="#E5E5E5"> free this you pass it if</font>

406
00:16:29,140 --> 00:16:33,670
it's valid you know it goes<font color="#E5E5E5"> on its way</font>

407
00:16:31,600 --> 00:16:34,960
if it's not again it does rounding you

408
00:16:33,670 --> 00:16:38,319
pass it 0 bytes you're still going to

409
00:16:34,960 --> 00:16:40,240
get<font color="#E5E5E5"> 8 the next thing it looks at is does</font>

410
00:16:38,320 --> 00:16:42,010
this heap support<font color="#E5E5E5"> serialization and</font><font color="#CCCCCC"> if</font>

411
00:16:40,240 --> 00:16:44,230
it does<font color="#CCCCCC"> not the low fragmentation heap</font>

412
00:16:42,010 --> 00:16:46,660
will never be used you need to support

413
00:16:44,230 --> 00:16:49,900
<font color="#E5E5E5">serialization for the low fragmentation</font>

414
00:16:46,660 --> 00:16:51,579
he ever to be used if civilization is

415
00:16:49,900 --> 00:16:54,340
supported it<font color="#E5E5E5"> checks the compatibility</font>

416
00:16:51,580 --> 00:16:55,810
flags if these certain flags are set it

417
00:16:54,340 --> 00:16:57,130
calls this function perform heat

418
00:16:55,810 --> 00:16:59,500
maintenance this is what will actually

419
00:16:57,130 --> 00:17:01,570
<font color="#E5E5E5">activate the low fragmentation heap if</font>

420
00:16:59,500 --> 00:17:03,550
you<font color="#E5E5E5"> just create a heap and start making</font>

421
00:17:01,570 --> 00:17:04,990
allocations they will not come<font color="#E5E5E5"> from a</font>

422
00:17:03,550 --> 00:17:06,669
low fragmentation heap they will come

423
00:17:04,990 --> 00:17:09,490
<font color="#E5E5E5">from the back end manager internal until</font>

424
00:17:06,670 --> 00:17:12,160
certain heuristics are met well how

425
00:17:09,490 --> 00:17:13,990
exactly these flags get set they get set

426
00:17:12,160 --> 00:17:15,520
again by the<font color="#CCCCCC"> backend</font><font color="#E5E5E5"> manager it checks</font>

427
00:17:13,990 --> 00:17:17,589
the free list did you pass it is it null

428
00:17:15,520 --> 00:17:19,690
if it's not and it doesn't contain<font color="#E5E5E5"> a</font>

429
00:17:17,589 --> 00:17:21,939
heat bucket that's where the logical and

430
00:17:19,690 --> 00:17:24,310
one comes there it adds a constant to it

431
00:17:21,940 --> 00:17:26,740
and this constant<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the one</font><font color="#E5E5E5"> that we saw</font>

432
00:17:24,310 --> 00:17:29,560
in our free list example if it exceeds a

433
00:17:26,740 --> 00:17:31,360
certain amount it's going to<font color="#E5E5E5"> say</font><font color="#CCCCCC"> okay</font>

434
00:17:29,560 --> 00:17:33,220
get<font color="#CCCCCC"> me the front front end manager from</font>

435
00:17:31,360 --> 00:17:35,860
the heap and try to get a heat bucket

436
00:17:33,220 --> 00:17:37,900
from it if this heat bucket returns null

437
00:17:35,860 --> 00:17:40,209
that means that low fragmentation heap

438
00:17:37,900 --> 00:17:43,240
is yet to be activated<font color="#CCCCCC"> and it will set</font>

439
00:17:40,210 --> 00:17:46,210
the compatibility flags if the threshold

440
00:17:43,240 --> 00:17:48,430
has been met if a bucket is given back

441
00:17:46,210 --> 00:17:50,740
it will actually store that heat bucket

442
00:17:48,430 --> 00:17:53,140
in the back<font color="#CCCCCC"> leg so the next</font><font color="#E5E5E5"> subsequent</font>

443
00:17:50,740 --> 00:17:54,640
requests for this size will be serviced

444
00:17:53,140 --> 00:17:57,820
by the low fragmentation heap instead of

445
00:17:54,640 --> 00:18:00,070
the back end<font color="#E5E5E5"> okay now that</font><font color="#CCCCCC"> all the</font>

446
00:17:57,820 --> 00:18:01,450
<font color="#CCCCCC">heuristics are done for</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> low</font>

447
00:18:00,070 --> 00:18:03,280
fragmentation heap it will actually

448
00:18:01,450 --> 00:18:06,880
service the request<font color="#E5E5E5"> from the back end</font>

449
00:18:03,280 --> 00:18:10,420
this is strikingly similar<font color="#CCCCCC"> to how it was</font>

450
00:18:06,880 --> 00:18:12,310
done in Windows XP service pack 2 it

451
00:18:10,420 --> 00:18:15,010
checks to see if the<font color="#E5E5E5"> list hit you gave</font>

452
00:18:12,310 --> 00:18:16,540
it contains a chunk and if it does we're

453
00:18:15,010 --> 00:18:17,950
going to safely unlink it and you<font color="#E5E5E5"> know</font>

454
00:18:16,540 --> 00:18:19,480
and by safely unlink it it's going<font color="#E5E5E5"> to</font>

455
00:18:17,950 --> 00:18:22,240
make<font color="#CCCCCC"> sure that it's Ford Lincoln</font>

456
00:18:19,480 --> 00:18:23,920
backlink values aren't tainted if

457
00:18:22,240 --> 00:18:25,510
<font color="#E5E5E5">everything goes well it on links the</font>

458
00:18:23,920 --> 00:18:28,630
chunk from the list and gives it back to

459
00:18:25,510 --> 00:18:30,640
you but if there wasn't<font color="#CCCCCC"> a list hint for</font>

460
00:18:28,630 --> 00:18:33,100
that certain size and and it doesn't

461
00:18:30,640 --> 00:18:35,680
work we're<font color="#CCCCCC"> going to</font><font color="#E5E5E5"> have to go to our</font>

462
00:18:33,100 --> 00:18:37,810
starting<font color="#CCCCCC"> at mal</font><font color="#E5E5E5"> 0 for us one type</font>

463
00:18:35,680 --> 00:18:39,400
scenario it's going to start at<font color="#CCCCCC"> the</font>

464
00:18:37,810 --> 00:18:41,080
beginning of the list head which<font color="#CCCCCC"> is the</font>

465
00:18:39,400 --> 00:18:42,400
same<font color="#CCCCCC"> as the heat free list right and</font>

466
00:18:41,080 --> 00:18:46,030
it's going<font color="#E5E5E5"> to just start traversing</font>

467
00:18:42,400 --> 00:18:49,810
those in the preview it would start at

468
00:18:46,030 --> 00:18:52,510
that first chunk for six blocks if the

469
00:18:49,810 --> 00:18:54,280
list head is empty or the largest chunk

470
00:18:52,510 --> 00:18:55,930
on<font color="#E5E5E5"> that on that free list can't service</font>

471
00:18:54,280 --> 00:18:58,090
this request it's going to need<font color="#CCCCCC"> to</font>

472
00:18:55,930 --> 00:18:59,440
extend the heap and when I say<font color="#E5E5E5"> extend</font>

473
00:18:58,090 --> 00:19:01,179
the heap it's going<font color="#E5E5E5"> to need</font><font color="#CCCCCC"> to commit</font>

474
00:18:59,440 --> 00:19:03,940
more memory so<font color="#CCCCCC"> it can service this</font>

475
00:19:01,180 --> 00:19:05,920
request if that's not<font color="#CCCCCC"> the case it starts</font>

476
00:19:03,940 --> 00:19:08,110
<font color="#E5E5E5">going through these chunk headers gets</font>

477
00:19:05,920 --> 00:19:12,610
one splits it up if necessary and gives

478
00:19:08,110 --> 00:19:15,879
it back to the user the<font color="#E5E5E5"> backend</font>

479
00:19:12,610 --> 00:19:18,070
allocator does a plethora of things it

480
00:19:15,880 --> 00:19:19,930
activates low fragmentation heat it

481
00:19:18,070 --> 00:19:21,550
<font color="#E5E5E5">actually calculates heuristics to</font>

482
00:19:19,930 --> 00:19:24,790
determine<font color="#E5E5E5"> if the low fragmentation heap</font>

483
00:19:21,550 --> 00:19:27,280
should be used so and then it'll service

484
00:19:24,790 --> 00:19:29,230
<font color="#E5E5E5">a little quest or get more memory now</font>

485
00:19:27,280 --> 00:19:30,639
we'll see how the front-end allocated

486
00:19:29,230 --> 00:19:33,910
works the low fragmentation heat and

487
00:19:30,640 --> 00:19:36,970
this is a big blob of code and it's ugly

488
00:19:33,910 --> 00:19:38,890
<font color="#E5E5E5">but it's easier to explain actually than</font>

489
00:19:36,970 --> 00:19:41,050
it is to read<font color="#CCCCCC"> the first thing that</font>

490
00:19:38,890 --> 00:19:43,630
happens is that heat bucket that<font color="#E5E5E5"> was</font>

491
00:19:41,050 --> 00:19:46,510
stored in<font color="#E5E5E5"> the backlink is passed and the</font>

492
00:19:43,630 --> 00:19:48,760
low fragmentation heap structure<font color="#E5E5E5"> the</font>

493
00:19:46,510 --> 00:19:50,650
pointer fort is actually calculated from

494
00:19:48,760 --> 00:19:52,440
that heat bucket based on size so they

495
00:19:50,650 --> 00:19:54,510
don't pass a pointer

496
00:19:52,440 --> 00:19:56,220
of the low fragmentation heap there they

497
00:19:54,510 --> 00:19:58,740
<font color="#E5E5E5">actually calculate it based off the</font>

498
00:19:56,220 --> 00:20:01,500
bucket size and in<font color="#CCCCCC"> Ben Hawks</font><font color="#E5E5E5"> Austin</font>

499
00:19:58,740 --> 00:20:03,930
paper in 2008 he theorized that if you

500
00:20:01,500 --> 00:20:05,370
<font color="#E5E5E5">could</font><font color="#CCCCCC"> punch up this heat bucket in the</font>

501
00:20:03,930 --> 00:20:06,960
size you could<font color="#CCCCCC"> potentially get a pointer</font>

502
00:20:05,370 --> 00:20:10,770
back to a low fragmentation heap that

503
00:20:06,960 --> 00:20:12,750
wasn't so that being said the main goal

504
00:20:10,770 --> 00:20:15,750
<font color="#E5E5E5">of this is to get that heap sub segments</font>

505
00:20:12,750 --> 00:20:17,490
based on the size and it does that<font color="#E5E5E5"> it</font>

506
00:20:15,750 --> 00:20:20,400
gets the local segment info and it tries

507
00:20:17,490 --> 00:20:22,740
the hint first the hint<font color="#CCCCCC"> sub-segments is</font>

508
00:20:20,400 --> 00:20:24,840
only set if you freed a chunk of that

509
00:20:22,740 --> 00:20:26,700
size if you never free a chunk<font color="#E5E5E5"> of that</font>

510
00:20:24,840 --> 00:20:28,919
size which in a real worlds narrow never

511
00:20:26,700 --> 00:20:30,570
happens but if you<font color="#CCCCCC"> never do the hint</font>

512
00:20:28,920 --> 00:20:32,880
won't be set<font color="#E5E5E5"> it'll use the active sub</font>

513
00:20:30,570 --> 00:20:34,649
segments the<font color="#CCCCCC"> code for these two things</font>

514
00:20:32,880 --> 00:20:36,300
are identical<font color="#E5E5E5"> so I've only listed them</font>

515
00:20:34,650 --> 00:20:39,000
one here but<font color="#CCCCCC"> basically in</font><font color="#E5E5E5"> this example</font>

516
00:20:36,300 --> 00:20:40,770
you can<font color="#E5E5E5"> place the the member hint with</font>

517
00:20:39,000 --> 00:20:43,830
active sub<font color="#CCCCCC"> segments and</font><font color="#E5E5E5"> it works exactly</font>

518
00:20:40,770 --> 00:20:45,840
<font color="#E5E5E5">the</font><font color="#CCCCCC"> same so what does it want to do it</font>

519
00:20:43,830 --> 00:20:48,929
has this big chunk of memory right that

520
00:20:45,840 --> 00:20:50,429
we talked about the user block well the

521
00:20:48,930 --> 00:20:52,050
<font color="#CCCCCC">first thing it's going to do is get that</font>

522
00:20:50,430 --> 00:20:53,550
interlock sequence structure and it's

523
00:20:52,050 --> 00:20:55,740
going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> get the free entry offset the</font>

524
00:20:53,550 --> 00:20:58,320
free entry offset tells you where's the

525
00:20:55,740 --> 00:21:01,020
first free trunk i can grab based on

526
00:20:58,320 --> 00:21:03,300
that if the sub segments is in working

527
00:21:01,020 --> 00:21:05,910
order which i guess i'll talk a little

528
00:21:03,300 --> 00:21:07,980
bit<font color="#E5E5E5"> more</font><font color="#CCCCCC"> about later it gets the chunk</font>

529
00:21:05,910 --> 00:21:10,620
based off that all set but how does it

530
00:21:07,980 --> 00:21:12,840
<font color="#E5E5E5">calculate the next offset well it looks</font>

531
00:21:10,620 --> 00:21:15,270
at the first two bites of the chunk<font color="#E5E5E5"> that</font>

532
00:21:12,840 --> 00:21:17,820
you've<font color="#E5E5E5"> just grabbed and uses that as the</font>

533
00:21:15,270 --> 00:21:19,650
next free offset but that first two

534
00:21:17,820 --> 00:21:21,389
<font color="#CCCCCC">bytes is in user readable when</font><font color="#E5E5E5"> user</font>

535
00:21:19,650 --> 00:21:23,310
writable memory so this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the whole</font>

536
00:21:21,390 --> 00:21:25,620
premise for my free entry offset attack

537
00:21:23,310 --> 00:21:29,070
again we'll talk about more about this

538
00:21:25,620 --> 00:21:31,169
in the the exploitation section the

539
00:21:29,070 --> 00:21:32,669
depth is easy it decrements it by one

540
00:21:31,170 --> 00:21:35,220
you've<font color="#CCCCCC"> just taken one chunk from</font><font color="#E5E5E5"> the</font>

541
00:21:32,670 --> 00:21:37,110
user block if all goes well it returns

542
00:21:35,220 --> 00:21:40,230
it the user if it doesn't go well

543
00:21:37,110 --> 00:21:41,820
there's no user blocks the depth is<font color="#E5E5E5"> zero</font>

544
00:21:40,230 --> 00:21:45,060
which means there's no chunks left in it

545
00:21:41,820 --> 00:21:46,860
right it's going<font color="#E5E5E5"> to have to acquire more</font>

546
00:21:45,060 --> 00:21:51,720
memory via the back end for the front

547
00:21:46,860 --> 00:21:54,209
end manager to use this brings us<font color="#E5E5E5"> to</font>

548
00:21:51,720 --> 00:21:59,070
what<font color="#E5E5E5"> I refer to as the magic formula</font>

549
00:21:54,210 --> 00:22:01,380
<font color="#E5E5E5">because it's</font><font color="#CCCCCC"> magic it looks complex but</font>

550
00:21:59,070 --> 00:22:03,689
just<font color="#CCCCCC"> think of it as rounding it to</font>

551
00:22:01,380 --> 00:22:05,940
nearest page align value to allocate

552
00:22:03,690 --> 00:22:06,390
memory for a certain size if you can do

553
00:22:05,940 --> 00:22:08,460
<font color="#E5E5E5">that</font>

554
00:22:06,390 --> 00:22:11,400
it's pretty simple then it calls the

555
00:22:08,460 --> 00:22:14,640
function<font color="#E5E5E5"> our TLP allocate user block</font>

556
00:22:11,400 --> 00:22:17,850
this by its name<font color="#CCCCCC"> obviously gets that big</font>

557
00:22:14,640 --> 00:22:20,130
chunk from<font color="#CCCCCC"> the back end manager there is</font>

558
00:22:17,850 --> 00:22:21,719
some caching and some indexing if you

559
00:22:20,130 --> 00:22:23,910
read my paper I talk<font color="#CCCCCC"> about it more but</font>

560
00:22:21,720 --> 00:22:28,680
we'll<font color="#CCCCCC"> just assume this is a wrapper for</font>

561
00:22:23,910 --> 00:22:30,660
a call to the<font color="#CCCCCC"> backend manager now let's</font>

562
00:22:28,680 --> 00:22:32,220
allocated a large chunk<font color="#E5E5E5"> of memory for</font>

563
00:22:30,660 --> 00:22:33,630
that user block it's going to need a

564
00:22:32,220 --> 00:22:35,730
sub-segment a couple it with right

565
00:22:33,630 --> 00:22:38,220
because that<font color="#CCCCCC"> sub-segments holds a</font>

566
00:22:35,730 --> 00:22:40,110
pointer to this user block well it does

567
00:22:38,220 --> 00:22:42,390
this either by using one that was

568
00:22:40,110 --> 00:22:45,659
previously deleted or it'll grab one

569
00:22:42,390 --> 00:22:47,280
from a pool of memory addresses so

570
00:22:45,660 --> 00:22:49,650
instead of<font color="#E5E5E5"> just allocating enough memory</font>

571
00:22:47,280 --> 00:22:51,629
for well you know one<font color="#E5E5E5"> subsequent at a</font>

572
00:22:49,650 --> 00:22:54,690
time it's going to<font color="#E5E5E5"> actually allocate</font>

573
00:22:51,630 --> 00:22:56,430
<font color="#E5E5E5">this big bunch of memory and take a</font>

574
00:22:54,690 --> 00:22:59,160
piece when needed and when it runs out

575
00:22:56,430 --> 00:23:01,470
it will allocate more and again this

576
00:22:59,160 --> 00:23:03,480
this<font color="#E5E5E5"> I</font><font color="#CCCCCC"> talk about an observation section</font>

577
00:23:01,470 --> 00:23:06,450
because it struck me as something that

578
00:23:03,480 --> 00:23:09,510
that you could abuse if about 415

579
00:23:06,450 --> 00:23:10,980
prerequisites are made now that<font color="#CCCCCC"> now that</font>

580
00:23:09,510 --> 00:23:12,750
you've<font color="#E5E5E5"> gotten memory for a sub-segment</font>

581
00:23:10,980 --> 00:23:15,480
you're going to have<font color="#E5E5E5"> to initialize it</font>

582
00:23:12,750 --> 00:23:18,030
and what does an installation mean it's

583
00:23:15,480 --> 00:23:21,840
going<font color="#E5E5E5"> to take that user block and it's</font>

584
00:23:18,030 --> 00:23:25,410
it needs to split it up the way it

585
00:23:21,840 --> 00:23:27,149
splits it up is by determining how big

586
00:23:25,410 --> 00:23:30,330
that block is and then<font color="#E5E5E5"> dividing it by</font>

587
00:23:27,150 --> 00:23:32,670
the<font color="#CCCCCC"> size that you requested so it takes</font>

588
00:23:30,330 --> 00:23:33,990
that user chunk it subtracts the size of

589
00:23:32,670 --> 00:23:35,760
a user data header because<font color="#E5E5E5"> we all</font><font color="#CCCCCC"> know</font>

590
00:23:33,990 --> 00:23:38,280
that proceeds the user block and then

591
00:23:35,760 --> 00:23:39,780
just divide by that number and iterates

592
00:23:38,280 --> 00:23:41,879
through it it doesn't<font color="#E5E5E5"> actually take this</font>

593
00:23:39,780 --> 00:23:44,340
memory and move it anywhere or set up a

594
00:23:41,880 --> 00:23:47,760
linked list it just writes a heap entry

595
00:23:44,340 --> 00:23:49,709
or a chunk header every so often so<font color="#E5E5E5"> 430</font>

596
00:23:47,760 --> 00:23:50,970
hex bites every 30 hex bytes there's

597
00:23:49,710 --> 00:23:53,880
going to be an eight byte header and

598
00:23:50,970 --> 00:23:57,090
it's pretty<font color="#E5E5E5"> simple there is two things</font>

599
00:23:53,880 --> 00:23:59,790
<font color="#E5E5E5">to note the interlock sequence structure</font>

600
00:23:57,090 --> 00:24:01,500
the the free entry offset will always be

601
00:23:59,790 --> 00:24:04,500
initialized to two it's always

602
00:24:01,500 --> 00:24:06,570
initialized to two because that heap

603
00:24:04,500 --> 00:24:09,330
user data header is<font color="#E5E5E5"> 16 bytes its</font>

604
00:24:06,570 --> 00:24:12,300
measured in blocks 2 times 8<font color="#CCCCCC"> is 16</font>

605
00:24:09,330 --> 00:24:15,060
another neat thing to know is the last

606
00:24:12,300 --> 00:24:17,190
chunk in that user block<font color="#E5E5E5"> its to bite</font>

607
00:24:15,060 --> 00:24:20,159
next free entry offset is set to

608
00:24:17,190 --> 00:24:21,900
negative<font color="#E5E5E5"> 1 so if you could somehow</font>

609
00:24:20,160 --> 00:24:23,490
you know read this value and you got to

610
00:24:21,900 --> 00:24:25,800
negative<font color="#E5E5E5"> one you would know that you've</font>

611
00:24:23,490 --> 00:24:31,620
reached the last block in that chunk

612
00:24:25,800 --> 00:24:34,470
<font color="#CCCCCC">okay I think the best</font><font color="#E5E5E5"> way to show how</font>

613
00:24:31,620 --> 00:24:37,770
the allocation from user blocks occurs

614
00:24:34,470 --> 00:24:41,460
is with an example in this example I'm

615
00:24:37,770 --> 00:24:45,420
going to use size 30 x 30 x bytes for

616
00:24:41,460 --> 00:24:47,070
each chunk and you see that the this is

617
00:24:45,420 --> 00:24:48,330
a fool chunk we just got it from the

618
00:24:47,070 --> 00:24:50,460
back end manager<font color="#CCCCCC"> and it's just been</font>

619
00:24:48,330 --> 00:24:53,580
split up and now we can make you<font color="#CCCCCC"> know an</font>

620
00:24:50,460 --> 00:24:55,350
allocation the first allocation is the

621
00:24:53,580 --> 00:24:57,810
free entry offset is at two that's the

622
00:24:55,350 --> 00:25:00,570
first chunk the depth is to a that that

623
00:24:57,810 --> 00:25:04,200
that<font color="#E5E5E5"> number is based off the magic</font>

624
00:25:00,570 --> 00:25:07,320
formula<font color="#E5E5E5"> I like</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> think of this as a big</font>

625
00:25:04,200 --> 00:25:08,760
Sicilian pizza from me<font color="#CCCCCC"> Neos in squirrel</font>

626
00:25:07,320 --> 00:25:10,710
hill so if anyone's from pittsburgh

627
00:25:08,760 --> 00:25:12,360
they'll know<font color="#E5E5E5"> what that is but um you</font>

628
00:25:10,710 --> 00:25:15,360
have this big pizza and they're in big

629
00:25:12,360 --> 00:25:17,070
square slices so let's say it's two in

630
00:25:15,360 --> 00:25:19,110
the morning and you have<font color="#CCCCCC"> dr raid come</font>

631
00:25:17,070 --> 00:25:21,419
<font color="#E5E5E5">over for late night pizza party right</font>

632
00:25:19,110 --> 00:25:23,490
and dr. raids going to grab a slice

633
00:25:21,420 --> 00:25:25,320
first thing pushes everyone out of<font color="#E5E5E5"> the</font>

634
00:25:23,490 --> 00:25:27,840
way your grandma whatever<font color="#E5E5E5"> just to get</font>

635
00:25:25,320 --> 00:25:31,139
his first slice you see what happened

636
00:25:27,840 --> 00:25:33,360
right the free entry offset is updated

637
00:25:31,140 --> 00:25:35,640
to offset of eight because<font color="#E5E5E5"> that's what</font>

638
00:25:33,360 --> 00:25:39,149
was stored<font color="#E5E5E5"> in the first two bites the</font>

639
00:25:35,640 --> 00:25:40,890
depth decremented by one simple dr. raid

640
00:25:39,150 --> 00:25:43,410
being the jerk that he is is going to

641
00:25:40,890 --> 00:25:45,750
grab another<font color="#E5E5E5"> slice before anyone else at</font>

642
00:25:43,410 --> 00:25:47,670
the party gets any so now he has<font color="#E5E5E5"> two</font>

643
00:25:45,750 --> 00:25:50,400
slices of pizza on his plate and no one

644
00:25:47,670 --> 00:25:53,340
else<font color="#CCCCCC"> has any again depth decremented by</font>

645
00:25:50,400 --> 00:25:55,650
one free entry offset upset updated to

646
00:25:53,340 --> 00:25:57,540
you know the<font color="#CCCCCC"> next century</font><font color="#E5E5E5"> keep in mind</font>

647
00:25:55,650 --> 00:26:00,330
that dr. raid has two pieces of pizza

648
00:25:57,540 --> 00:26:02,310
<font color="#E5E5E5">right now no one has</font><font color="#CCCCCC"> any and we'll</font>

649
00:26:00,330 --> 00:26:09,540
continue this example in the freeing

650
00:26:02,310 --> 00:26:11,399
section<font color="#E5E5E5"> okay on</font><font color="#CCCCCC"> to fring freeing just</font>

651
00:26:09,540 --> 00:26:13,530
like allocation kind of has that stub

652
00:26:11,400 --> 00:26:15,000
function<font color="#CCCCCC"> RTL free heap and this is just</font>

653
00:26:13,530 --> 00:26:17,610
<font color="#CCCCCC">going</font><font color="#E5E5E5"> to determine</font><font color="#CCCCCC"> whether you</font><font color="#E5E5E5"> should</font>

654
00:26:15,000 --> 00:26:20,520
use the low fragmentation heap or the

655
00:26:17,610 --> 00:26:22,590
back end it will do a few checks first

656
00:26:20,520 --> 00:26:25,110
if you pass it in all it will return to

657
00:26:22,590 --> 00:26:27,179
you if<font color="#E5E5E5"> you pass it a non 8-byte aligned</font>

658
00:26:25,110 --> 00:26:29,010
memory address it will log the heat

659
00:26:27,180 --> 00:26:30,810
failure and return to you so you can't

660
00:26:29,010 --> 00:26:33,560
pass an<font color="#CCCCCC"> all or non</font><font color="#E5E5E5"> eight by the line the</font>

661
00:26:30,810 --> 00:26:36,200
dresses the next neat thing that I saw

662
00:26:33,560 --> 00:26:37,850
is it checks the chunk headers unused

663
00:26:36,200 --> 00:26:40,130
<font color="#E5E5E5">bites we'll just call</font><font color="#CCCCCC"> it unused bites</font>

664
00:26:37,850 --> 00:26:42,740
it's at offset<font color="#CCCCCC"> seven it's that can be</font>

665
00:26:40,130 --> 00:26:45,710
bitwise ANDed with hex<font color="#E5E5E5"> 80 it was the the</font>

666
00:26:42,740 --> 00:26:47,990
low fragmentation heap if it can't then

667
00:26:45,710 --> 00:26:51,230
<font color="#CCCCCC">they'll use the back end the neat thing</font>

668
00:26:47,990 --> 00:26:53,030
to realize right here is that that piece

669
00:26:51,230 --> 00:26:55,190
<font color="#CCCCCC">of information</font><font color="#E5E5E5"> the chunk header isn't</font>

670
00:26:53,030 --> 00:26:56,720
encoded so if you can get an 8-byte over

671
00:26:55,190 --> 00:26:59,180
right you can actually overwrite this

672
00:26:56,720 --> 00:27:00,830
value and free a chunk with the low

673
00:26:59,180 --> 00:27:03,530
fragmentation heap instead of<font color="#E5E5E5"> the back</font>

674
00:27:00,830 --> 00:27:07,580
end when it was allocated from the the

675
00:27:03,530 --> 00:27:08,570
<font color="#E5E5E5">back end manager okay we'll start with</font>

676
00:27:07,580 --> 00:27:10,639
<font color="#CCCCCC">the back end just for consistency</font>

677
00:27:08,570 --> 00:27:13,370
reasons here and and we'll see a few

678
00:27:10,640 --> 00:27:15,110
things well we see that search blocks

679
00:27:13,370 --> 00:27:18,379
index function right where it gets you

680
00:27:15,110 --> 00:27:22,159
an offset in the list hence if if that

681
00:27:18,380 --> 00:27:24,710
list<font color="#CCCCCC"> hint can contain a value and it</font>

682
00:27:22,160 --> 00:27:27,020
doesn't contain<font color="#CCCCCC"> a heat bucket it's going</font>

683
00:27:24,710 --> 00:27:28,640
to subtract two from it<font color="#E5E5E5"> and this is used</font>

684
00:27:27,020 --> 00:27:32,030
in<font color="#E5E5E5"> the heuristic to determine whether</font>

685
00:27:28,640 --> 00:27:34,640
ever to enable the low fragmentation

686
00:27:32,030 --> 00:27:38,030
heap for this size so even if you did

687
00:27:34,640 --> 00:27:39,890
<font color="#E5E5E5">400 allocation free allocation free</font>

688
00:27:38,030 --> 00:27:41,420
combos the low fragmentation heap for

689
00:27:39,890 --> 00:27:43,250
that size would never be enabled you

690
00:27:41,420 --> 00:27:47,180
need consecutive allocations for this to

691
00:27:43,250 --> 00:27:50,150
happen<font color="#CCCCCC"> okay we've you know we've updated</font>

692
00:27:47,180 --> 00:27:53,180
these these<font color="#E5E5E5"> flags and done some things</font>

693
00:27:50,150 --> 00:27:55,160
if the heat permits coalesce it right if

694
00:27:53,180 --> 00:27:56,540
the previous chunk is free coalesced it

695
00:27:55,160 --> 00:27:57,920
with a chunk we're freeing if the next

696
00:27:56,540 --> 00:28:00,409
<font color="#E5E5E5">chunk is free coalesce the truck were</font>

697
00:27:57,920 --> 00:28:01,880
freeing update the sizes you<font color="#CCCCCC"> know that</font>

698
00:28:00,410 --> 00:28:05,510
that again can be<font color="#E5E5E5"> looked at more</font>

699
00:28:01,880 --> 00:28:09,200
thoroughly in a paper written by dr.

700
00:28:05,510 --> 00:28:11,660
McDonald<font color="#E5E5E5"> and myself from 2009</font><font color="#CCCCCC"> all right</font>

701
00:28:09,200 --> 00:28:13,310
so now we've officially done everything

702
00:28:11,660 --> 00:28:14,900
we need<font color="#E5E5E5"> to do we've updated a low</font>

703
00:28:13,310 --> 00:28:17,120
fragmentation a pure<font color="#E5E5E5"> istic we've</font>

704
00:28:14,900 --> 00:28:21,350
coalesced the chunks how do you how do

705
00:28:17,120 --> 00:28:23,989
you link this guy back<font color="#E5E5E5"> in well you know</font>

706
00:28:21,350 --> 00:28:26,360
its first going<font color="#E5E5E5"> to attempt to determine</font>

707
00:28:23,990 --> 00:28:29,090
can we actually you know can we free

708
00:28:26,360 --> 00:28:30,560
this chunk in a certain location if that

709
00:28:29,090 --> 00:28:32,510
list head doesn't contain any entries

710
00:28:30,560 --> 00:28:34,040
it's easy we're going to link it in<font color="#E5E5E5"> the</font>

711
00:28:32,510 --> 00:28:36,620
first spot no need to do anything<font color="#E5E5E5"> else</font>

712
00:28:34,040 --> 00:28:40,010
otherwise you know try<font color="#E5E5E5"> to find that list</font>

713
00:28:36,620 --> 00:28:42,350
hint you<font color="#CCCCCC"> know and</font><font color="#E5E5E5"> traverse that that</font>

714
00:28:40,010 --> 00:28:45,379
that entry until it finds a chunk bigger

715
00:28:42,350 --> 00:28:46,918
than itself so what it does is inserts

716
00:28:45,380 --> 00:28:49,259
itself before the

717
00:28:46,919 --> 00:28:51,840
that's bigger than it this again<font color="#E5E5E5"> is</font>

718
00:28:49,259 --> 00:28:55,590
<font color="#E5E5E5">similar to windows XP but there are some</font>

719
00:28:51,840 --> 00:28:59,309
changes<font color="#E5E5E5"> and here are</font><font color="#CCCCCC"> the changes</font><font color="#E5E5E5"> that I</font>

720
00:28:55,590 --> 00:29:02,009
found strikingly sad for exploit writers

721
00:28:59,309 --> 00:29:04,168
when it finds that list where it's

722
00:29:02,009 --> 00:29:07,470
inserting and in our example say we're

723
00:29:04,169 --> 00:29:10,350
freeing a chunk<font color="#CCCCCC"> of size six blocks right</font>

724
00:29:07,470 --> 00:29:11,580
it wouldn't insert it first before all

725
00:29:10,350 --> 00:29:14,129
of them it would traverse through all

726
00:29:11,580 --> 00:29:15,960
the blocks of size six and then when it

727
00:29:14,129 --> 00:29:18,238
hit that<font color="#E5E5E5"> one of seven it would insert it</font>

728
00:29:15,960 --> 00:29:21,570
before the one in seven well<font color="#E5E5E5"> before</font>

729
00:29:18,239 --> 00:29:23,879
Brett more had the ingenious idea that

730
00:29:21,570 --> 00:29:26,309
if you<font color="#CCCCCC"> overwrote the</font><font color="#E5E5E5"> backlink of one of</font>

731
00:29:23,879 --> 00:29:28,678
these and you could insert it before it

732
00:29:26,309 --> 00:29:30,960
the and if you over up the backlink you

733
00:29:28,679 --> 00:29:32,879
could have<font color="#E5E5E5"> that address point to the</font>

734
00:29:30,960 --> 00:29:34,859
chunk you just freed this<font color="#E5E5E5"> really isn't a</font>

735
00:29:32,879 --> 00:29:36,748
case anymore they do a check which we'll

736
00:29:34,859 --> 00:29:39,269
talk about<font color="#E5E5E5"> more you see that inserts be</font>

737
00:29:36,749 --> 00:29:41,340
linked<font color="#E5E5E5"> f link equals insert list it's</font>

738
00:29:39,269 --> 00:29:44,609
just<font color="#CCCCCC"> making sure that</font><font color="#E5E5E5"> it's backlink for</font>

739
00:29:41,340 --> 00:29:47,009
link points to itself if not there's a

740
00:29:44,609 --> 00:29:49,769
log of a heat failure but eventually

741
00:29:47,009 --> 00:29:53,129
you'll see you know the<font color="#E5E5E5"> chunk that you</font>

742
00:29:49,769 --> 00:29:58,619
just free will be the list hint will be

743
00:29:53,129 --> 00:30:01,139
updated for it<font color="#E5E5E5"> okay so it updates the</font>

744
00:29:58,619 --> 00:30:03,928
backend updates a heuristic<font color="#E5E5E5"> coalesce</font>

745
00:30:01,139 --> 00:30:06,840
chunks attempts<font color="#CCCCCC"> to safely link in the</font>

746
00:30:03,929 --> 00:30:08,159
chunk into the list let's see how the

747
00:30:06,840 --> 00:30:14,158
front<font color="#E5E5E5"> end does things be that it's not</font>

748
00:30:08,159 --> 00:30:15,359
<font color="#CCCCCC">just a bunch of linked lists</font><font color="#E5E5E5"> okay first</font>

749
00:30:14,159 --> 00:30:17,519
thing that happens it's<font color="#E5E5E5"> going to get the</font>

750
00:30:15,359 --> 00:30:20,489
chunk header it<font color="#E5E5E5"> usually does this by</font>

751
00:30:17,519 --> 00:30:22,409
subtracting 8 but if certain flags are

752
00:30:20,489 --> 00:30:25,529
set it will actually subtract more from

753
00:30:22,409 --> 00:30:28,169
that value this is what<font color="#E5E5E5"> Ben Hawks</font>

754
00:30:25,529 --> 00:30:30,840
explained is 2008 paper and I have a

755
00:30:28,169 --> 00:30:32,489
kind<font color="#E5E5E5"> of a contrived example in the</font>

756
00:30:30,840 --> 00:30:34,109
exploitation section of this paper of

757
00:30:32,489 --> 00:30:37,049
how you could leverage is to gain code

758
00:30:34,109 --> 00:30:39,629
execution the sub segments for this

759
00:30:37,049 --> 00:30:42,480
chunk is acquired again it's not past

760
00:30:39,629 --> 00:30:43,980
it's calculated via certain values<font color="#CCCCCC"> in</font>

761
00:30:42,480 --> 00:30:45,450
the heap and the low fragmentation heap

762
00:30:43,980 --> 00:30:48,899
and the<font color="#E5E5E5"> address of the chunk that you're</font>

763
00:30:45,450 --> 00:30:50,249
free by the way that was really

764
00:30:48,899 --> 00:30:51,748
confusing when reversing this stuff

765
00:30:50,249 --> 00:30:53,129
because<font color="#E5E5E5"> you had a bunch of weird</font>

766
00:30:51,749 --> 00:30:54,929
arithmetic and a bunch of you<font color="#E5E5E5"> know</font>

767
00:30:53,129 --> 00:30:59,428
bitwise operations it took me a while to

768
00:30:54,929 --> 00:31:00,700
<font color="#E5E5E5">figure out but</font><font color="#CCCCCC"> okay so</font><font color="#E5E5E5"> now we've reached</font>

769
00:30:59,429 --> 00:31:02,530
this point where we<font color="#CCCCCC"> have</font>

770
00:31:00,700 --> 00:31:04,810
this<font color="#CCCCCC"> sub-segment again right and we want</font>

771
00:31:02,530 --> 00:31:07,149
a free to it again the<font color="#E5E5E5"> first thing you</font>

772
00:31:04,810 --> 00:31:10,419
do get that depth and get that offset

773
00:31:07,150 --> 00:31:11,950
what you want to do is the offset to the

774
00:31:10,420 --> 00:31:13,780
next chunk that was stored in the

775
00:31:11,950 --> 00:31:15,070
interlock sequence structure we're<font color="#E5E5E5"> going</font>

776
00:31:13,780 --> 00:31:16,450
<font color="#E5E5E5">to</font><font color="#CCCCCC"> Stewart in the</font><font color="#E5E5E5"> first two bites of the</font>

777
00:31:15,070 --> 00:31:17,919
chunk<font color="#E5E5E5"> that we're freeing because that</font>

778
00:31:16,450 --> 00:31:20,890
will point<font color="#E5E5E5"> to the next</font><font color="#CCCCCC"> three one after</font>

779
00:31:17,920 --> 00:31:22,390
we allocate this one the<font color="#CCCCCC"> the depth real</font>

780
00:31:20,890 --> 00:31:25,750
<font color="#CCCCCC">ways</font><font color="#E5E5E5"> you add one you've</font><font color="#CCCCCC"> just given a</font>

781
00:31:22,390 --> 00:31:27,850
chunk back to the memory manager if all

782
00:31:25,750 --> 00:31:29,770
goes well you know it returns I've left

783
00:31:27,850 --> 00:31:32,050
out a lot of code to show what happens

784
00:31:29,770 --> 00:31:34,510
say when you freed every chunk in a user

785
00:31:32,050 --> 00:31:37,210
block my paper explains it a little bit

786
00:31:34,510 --> 00:31:41,650
more but it is confusing<font color="#E5E5E5"> and I just left</font>

787
00:31:37,210 --> 00:31:44,350
<font color="#E5E5E5">it out for brevity's reason okay we'll</font>

788
00:31:41,650 --> 00:31:47,740
continue with<font color="#E5E5E5"> our</font><font color="#CCCCCC"> doctor raid late night</font>

789
00:31:44,350 --> 00:31:50,290
pizza thief example now at this<font color="#E5E5E5"> point</font>

790
00:31:47,740 --> 00:31:52,330
you<font color="#E5E5E5"> know this</font><font color="#CCCCCC"> this guy has just taken a</font>

791
00:31:50,290 --> 00:31:54,490
third piece<font color="#CCCCCC"> of pizza and no one else</font><font color="#E5E5E5"> has</font>

792
00:31:52,330 --> 00:31:56,800
gotten one you see what happened the

793
00:31:54,490 --> 00:31:59,650
depth decremented again the free entry

794
00:31:56,800 --> 00:32:02,860
offset points to 14 that's the next free

795
00:31:59,650 --> 00:32:04,810
slice of pizza we can use well<font color="#E5E5E5"> dr. raid</font>

796
00:32:02,860 --> 00:32:07,209
and always slyness realizes that first

797
00:32:04,810 --> 00:32:09,940
chunk first piece<font color="#CCCCCC"> of pizza he grabbed</font>

798
00:32:07,210 --> 00:32:11,530
it's<font color="#CCCCCC"> ice cold he doesn't want it so</font>

799
00:32:09,940 --> 00:32:14,950
what's he<font color="#E5E5E5"> going to do he's going to put</font>

800
00:32:11,530 --> 00:32:17,379
it back in<font color="#CCCCCC"> the box and this updates our</font>

801
00:32:14,950 --> 00:32:19,870
entries again the free entry offset now

802
00:32:17,380 --> 00:32:21,850
points22 that is the first chunk that is

803
00:32:19,870 --> 00:32:24,610
the first piece<font color="#CCCCCC"> of pizza that that</font><font color="#E5E5E5"> was</font>

804
00:32:21,850 --> 00:32:26,949
grabbed the next offset in that chunk

805
00:32:24,610 --> 00:32:28,510
points to the previous free entry offset

806
00:32:26,950 --> 00:32:30,730
see how the free entry offset here at

807
00:32:28,510 --> 00:32:33,310
the<font color="#E5E5E5"> bottom is 14 you've just freed a</font>

808
00:32:30,730 --> 00:32:35,680
chunk the next entry offset is what was

809
00:32:33,310 --> 00:32:38,379
previously in that interlock sequence

810
00:32:35,680 --> 00:32:40,360
structure again he's munching on that

811
00:32:38,380 --> 00:32:42,820
nice warm slice third piece of<font color="#E5E5E5"> pizza</font>

812
00:32:40,360 --> 00:32:45,250
doesn't want the second one and he puts

813
00:32:42,820 --> 00:32:49,000
it back it's updated again the free

814
00:32:45,250 --> 00:32:51,880
entry offset you know now points28 the

815
00:32:49,000 --> 00:32:54,130
depth has been incremented and you know

816
00:32:51,880 --> 00:32:56,410
all those chunks are back I'd like to

817
00:32:54,130 --> 00:32:59,860
<font color="#E5E5E5">think</font><font color="#CCCCCC"> of this</font><font color="#E5E5E5"> actually as a stack right</font>

818
00:32:56,410 --> 00:33:02,410
so its last in first out if we were to

819
00:32:59,860 --> 00:33:04,240
allocate memory we would get that chunk

820
00:33:02,410 --> 00:33:07,150
if we were at allocate again we<font color="#E5E5E5"> would</font>

821
00:33:04,240 --> 00:33:09,220
get<font color="#E5E5E5"> that chunk so the the first piece</font><font color="#CCCCCC"> of</font>

822
00:33:07,150 --> 00:33:10,900
memory you put in is<font color="#E5E5E5"> going to be the</font>

823
00:33:09,220 --> 00:33:13,480
last one you get out and<font color="#E5E5E5"> I think in the</font>

824
00:33:10,900 --> 00:33:14,050
tactic section it will explain more of

825
00:33:13,480 --> 00:33:19,210
<font color="#E5E5E5">why this</font>

826
00:33:14,050 --> 00:33:22,360
be useful to<font color="#CCCCCC"> you as well on the security</font>

827
00:33:19,210 --> 00:33:23,740
mechanisms everyone i think is<font color="#E5E5E5"> kind of</font>

828
00:33:22,360 --> 00:33:26,620
familiar<font color="#E5E5E5"> with heap randomization right</font>

829
00:33:23,740 --> 00:33:30,310
aslr is prevalent what they try to do is

830
00:33:26,620 --> 00:33:33,189
they will create sudam<font color="#E5E5E5"> res pseudo random</font>

831
00:33:30,310 --> 00:33:34,899
value that's<font color="#E5E5E5"> 64k aligned and they will</font>

832
00:33:33,190 --> 00:33:37,840
add<font color="#CCCCCC"> it to the heat base that's so the</font>

833
00:33:34,900 --> 00:33:40,330
heat isn't at attempts to make sure the

834
00:33:37,840 --> 00:33:44,080
heap is an at the same address on every

835
00:33:40,330 --> 00:33:45,939
iteration be there is only you know<font color="#CCCCCC"> 5</font>

836
00:33:44,080 --> 00:33:48,669
bits of entropy I'm not saying it's

837
00:33:45,940 --> 00:33:51,460
impossible to get that<font color="#E5E5E5"> address it is</font>

838
00:33:48,670 --> 00:33:54,310
improbable but if you have more than one

839
00:33:51,460 --> 00:33:56,440
attempt<font color="#E5E5E5"> to guess the address I think it</font>

840
00:33:54,310 --> 00:34:00,820
could actually be doable which I'll talk

841
00:33:56,440 --> 00:34:03,280
about in the exploitation section we've

842
00:34:00,820 --> 00:34:07,389
seen<font color="#E5E5E5"> some header encoding and decoding</font>

843
00:34:03,280 --> 00:34:09,969
already this made overriding predictably

844
00:34:07,390 --> 00:34:13,120
overriding the size and the<font color="#E5E5E5"> flags and</font>

845
00:34:09,969 --> 00:34:14,859
the checksum nearly impossible if<font color="#CCCCCC"> you</font>

846
00:34:13,120 --> 00:34:18,969
didn't<font color="#E5E5E5"> have an address linked to figure</font>

847
00:34:14,860 --> 00:34:21,850
out what what what values were used to X

848
00:34:18,969 --> 00:34:23,918
or encode this stuff there was a few

849
00:34:21,850 --> 00:34:25,810
<font color="#CCCCCC">things</font><font color="#E5E5E5"> that I noticed the first one I've</font>

850
00:34:23,918 --> 00:34:27,759
already talked<font color="#CCCCCC"> about there's four</font><font color="#E5E5E5"> bytes</font>

851
00:34:25,810 --> 00:34:29,710
of this chunk header that<font color="#E5E5E5"> have never</font>

852
00:34:27,760 --> 00:34:31,330
been encoded so if you could play around

853
00:34:29,710 --> 00:34:33,220
with<font color="#E5E5E5"> those values you could potentially</font>

854
00:34:31,330 --> 00:34:37,210
<font color="#E5E5E5">you know leverage your way into</font>

855
00:34:33,219 --> 00:34:41,949
advantageous situation the second being

856
00:34:37,210 --> 00:34:44,918
you see how it does an end or ensures

857
00:34:41,949 --> 00:34:49,120
the encode flag mask is not in all this

858
00:34:44,918 --> 00:34:51,940
encode flag mass is set in in in the

859
00:34:49,120 --> 00:34:53,529
heap create function but theoretically

860
00:34:51,940 --> 00:34:55,840
you could<font color="#E5E5E5"> nollette out and if you know</font>

861
00:34:53,530 --> 00:34:58,540
it out that means this heap will no

862
00:34:55,840 --> 00:35:00,490
longer do encoding or decoding the only

863
00:34:58,540 --> 00:35:02,650
problem with this is<font color="#E5E5E5"> if you do this to</font>

864
00:35:00,490 --> 00:35:05,229
heap that has already been encoding

865
00:35:02,650 --> 00:35:07,300
chunks the size of these things and the

866
00:35:05,230 --> 00:35:08,710
checksum will be all munge because you

867
00:35:07,300 --> 00:35:10,240
know they were already encoded and if it

868
00:35:08,710 --> 00:35:12,310
treats is unencoded they're going to be

869
00:35:10,240 --> 00:35:13,959
way off maybe you could<font color="#E5E5E5"> create a new</font>

870
00:35:12,310 --> 00:35:16,000
heap with this value and<font color="#CCCCCC"> then do your</font>

871
00:35:13,960 --> 00:35:18,610
size over rights but you know again

872
00:35:16,000 --> 00:35:21,220
<font color="#E5E5E5">there's are a lot of prerequisites what</font>

873
00:35:18,610 --> 00:35:23,470
did a<font color="#CCCCCC"> matt miller told me when</font><font color="#E5E5E5"> i was</font>

874
00:35:21,220 --> 00:35:24,970
<font color="#CCCCCC">writing this paper you're you're laying</font>

875
00:35:23,470 --> 00:35:27,069
the train tracks you're not driving the

876
00:35:24,970 --> 00:35:27,520
<font color="#CCCCCC">Train I'm too stupid to drive the train</font>

877
00:35:27,070 --> 00:35:28,840
so I

878
00:35:27,520 --> 00:35:30,340
lay<font color="#CCCCCC"> the tracks and hopefully everyone</font>

879
00:35:28,840 --> 00:35:34,540
else can figure out how to get the train

880
00:35:30,340 --> 00:35:36,880
down them lastly for this one you<font color="#CCCCCC"> see</font>

881
00:35:34,540 --> 00:35:39,670
that the the header is ended with in

882
00:35:36,880 --> 00:35:42,760
code flag<font color="#E5E5E5"> mask that ensures that this</font>

883
00:35:39,670 --> 00:35:45,820
chunk that<font color="#CCCCCC"> you're getting was it once</font>

884
00:35:42,760 --> 00:35:47,560
encoded but if you can overwrite the

885
00:35:45,820 --> 00:35:50,080
encoded<font color="#CCCCCC"> 4 bytes of encoded information</font>

886
00:35:47,560 --> 00:35:52,390
and make sure<font color="#E5E5E5"> that returns false it</font>

887
00:35:50,080 --> 00:35:55,810
won't it won't decode the chunk and

888
00:35:52,390 --> 00:35:57,549
<font color="#CCCCCC">we'll treat it as an unencoded chunk the</font>

889
00:35:55,810 --> 00:35:59,740
only place this is really<font color="#E5E5E5"> useful to you</font>

890
00:35:57,550 --> 00:36:02,230
is in freeing if you can overwrite a

891
00:35:59,740 --> 00:36:04,569
free list to<font color="#CCCCCC"> have this situation where</font>

892
00:36:02,230 --> 00:36:07,570
it fails you can actually<font color="#CCCCCC"> manipulate the</font>

893
00:36:04,570 --> 00:36:09,550
size with that size manipulation you may

894
00:36:07,570 --> 00:36:11,140
be able<font color="#E5E5E5"> to set up walls in free lists</font>

895
00:36:09,550 --> 00:36:13,180
where they'll stop because<font color="#CCCCCC"> you have</font>

896
00:36:11,140 --> 00:36:14,920
manipulated the size again just

897
00:36:13,180 --> 00:36:20,140
something to think about it could lead

898
00:36:14,920 --> 00:36:23,680
to something<font color="#E5E5E5"> more prosperous death of</font>

899
00:36:20,140 --> 00:36:25,900
the bitmap flip we<font color="#E5E5E5"> John McDonald and I</font>

900
00:36:23,680 --> 00:36:29,710
actually use bitmap flipping in our

901
00:36:25,900 --> 00:36:32,860
exploit last year when<font color="#CCCCCC"> we</font><font color="#E5E5E5"> did our XP</font>

902
00:36:29,710 --> 00:36:34,810
2003 talk now this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of dead</font>

903
00:36:32,860 --> 00:36:36,700
before if you could trick<font color="#E5E5E5"> freelist into</font>

904
00:36:34,810 --> 00:36:39,759
thinking it was empty<font color="#E5E5E5"> and you could</font>

905
00:36:36,700 --> 00:36:42,189
alter<font color="#CCCCCC"> the size you could act there was</font>

906
00:36:39,760 --> 00:36:45,070
an XOR operation right that would<font color="#E5E5E5"> that</font>

907
00:36:42,190 --> 00:36:48,040
would flip the bit that's not the case

908
00:36:45,070 --> 00:36:51,400
anymore they use you<font color="#CCCCCC"> know bitwise and</font>

909
00:36:48,040 --> 00:36:53,440
when allocating that is if you're

910
00:36:51,400 --> 00:36:55,390
allocating from a list it can only

911
00:36:53,440 --> 00:36:56,710
become them empty allocating from lists

912
00:36:55,390 --> 00:36:59,080
can never lead to that that list

913
00:36:56,710 --> 00:37:02,980
becoming populated right the same with

914
00:36:59,080 --> 00:37:04,840
freeing they use bitwise or a populated

915
00:37:02,980 --> 00:37:08,320
list after<font color="#CCCCCC"> a chunk has been take it out</font>

916
00:37:04,840 --> 00:37:11,950
cannot become you know more populated so

917
00:37:08,320 --> 00:37:14,050
with the the encoding of the sizes<font color="#E5E5E5"> and</font>

918
00:37:11,950 --> 00:37:16,359
everything else this isn't really useful

919
00:37:14,050 --> 00:37:18,520
to<font color="#CCCCCC"> you anyway not to mention dedicated</font>

920
00:37:16,360 --> 00:37:22,210
free list aren't<font color="#E5E5E5"> on heat base anymore so</font>

921
00:37:18,520 --> 00:37:24,340
that all in all it did fix it but<font color="#E5E5E5"> at the</font>

922
00:37:22,210 --> 00:37:27,280
<font color="#E5E5E5">same time it's not</font><font color="#CCCCCC"> as useful as it</font><font color="#E5E5E5"> used</font>

923
00:37:24,340 --> 00:37:30,190
to be sorry Nico I apologize they ruined

924
00:37:27,280 --> 00:37:32,380
it for you the last<font color="#E5E5E5"> thing I kind of</font>

925
00:37:30,190 --> 00:37:33,880
already talked<font color="#CCCCCC"> about is safe linking and</font>

926
00:37:32,380 --> 00:37:37,150
to my knowledge i think this directly

927
00:37:33,880 --> 00:37:40,869
addresses brett moore's paper exploiting

928
00:37:37,150 --> 00:37:43,599
items on free the zero in Windows XP

929
00:37:40,869 --> 00:37:45,970
service pack 2 u over right Abby link of

930
00:37:43,599 --> 00:37:48,130
an item<font color="#CCCCCC"> on a free list you get insert a</font>

931
00:37:45,970 --> 00:37:50,259
chunk before it that address now points

932
00:37:48,130 --> 00:37:53,170
the chunk you just freed it's<font color="#E5E5E5"> not the</font>

933
00:37:50,260 --> 00:37:56,170
case you'll get<font color="#E5E5E5"> a you get a heat blog</font>

934
00:37:53,170 --> 00:37:59,559
failure at analog what happened the

935
00:37:56,170 --> 00:38:02,230
thing is if you if the if the process

936
00:37:59,559 --> 00:38:04,329
doesn't terminate when the the failure

937
00:38:02,230 --> 00:38:07,299
happens you see that it just goes down

938
00:38:04,329 --> 00:38:09,760
and it will actually update that<font color="#CCCCCC"> listing</font>

939
00:38:07,299 --> 00:38:11,950
and put your chunk in well since the

940
00:38:09,760 --> 00:38:14,380
chunk hasn't safely been linked in you

941
00:38:11,950 --> 00:38:16,598
fully control the<font color="#CCCCCC"> Ford</font><font color="#E5E5E5"> link and backlink</font>

942
00:38:14,380 --> 00:38:18,490
of that value so if you<font color="#E5E5E5"> could get this</font>

943
00:38:16,599 --> 00:38:19,960
to happen you still have to deal with

944
00:38:18,490 --> 00:38:22,240
safe unlinking when getting<font color="#E5E5E5"> this item</font>

945
00:38:19,960 --> 00:38:25,240
back off the list<font color="#CCCCCC"> and you know that does</font>

946
00:38:22,240 --> 00:38:27,189
terminate but if not<font color="#E5E5E5"> and you can figure</font>

947
00:38:25,240 --> 00:38:29,200
out something you<font color="#E5E5E5"> know ingenious you</font>

948
00:38:27,190 --> 00:38:32,680
fully control the<font color="#E5E5E5"> ford lincoln backlink</font>

949
00:38:29,200 --> 00:38:35,348
in this scenario<font color="#CCCCCC"> alright I think</font><font color="#E5E5E5"> we're</font>

950
00:38:32,680 --> 00:38:38,770
<font color="#CCCCCC">done</font><font color="#E5E5E5"> with most of the boring stuff now</font>

951
00:38:35,349 --> 00:38:40,930
we can<font color="#E5E5E5"> get to tactics the first tactic</font>

952
00:38:38,770 --> 00:38:43,180
when addressing the low fragmentation

953
00:38:40,930 --> 00:38:45,910
heap is how do i enable it for a certain

954
00:38:43,180 --> 00:38:47,770
size<font color="#CCCCCC"> i can guarantee</font><font color="#E5E5E5"> you if you</font><font color="#CCCCCC"> make 18</font>

955
00:38:45,910 --> 00:38:49,690
consecutive allocations the next

956
00:38:47,770 --> 00:38:51,130
allocation you will make will be in the

957
00:38:49,690 --> 00:38:53,319
low fragmentation heap it will be coming

958
00:38:51,130 --> 00:38:55,450
<font color="#E5E5E5">from that user block so this is pretty</font>

959
00:38:53,319 --> 00:38:57,880
simple<font color="#E5E5E5"> you</font><font color="#CCCCCC"> know you can do this in</font>

960
00:38:55,450 --> 00:39:00,189
almost any application in IE you know

961
00:38:57,880 --> 00:39:01,539
create create a bunch<font color="#E5E5E5"> of Dom objects you</font>

962
00:39:00,190 --> 00:39:03,520
know in a network application send a

963
00:39:01,539 --> 00:39:06,819
bunch<font color="#E5E5E5"> of requests it will turn it on</font>

964
00:39:03,520 --> 00:39:08,140
unfortunately you know a<font color="#E5E5E5"> lot of times</font>

965
00:39:06,819 --> 00:39:10,329
this isn't the case for all this stuff

966
00:39:08,140 --> 00:39:11,799
<font color="#E5E5E5">you're going</font><font color="#CCCCCC"> to get these these user</font>

967
00:39:10,329 --> 00:39:13,750
blocks they've been used and there's

968
00:39:11,799 --> 00:39:15,369
<font color="#E5E5E5">going to be holes in them you know the</font>

969
00:39:13,750 --> 00:39:17,319
FM next offset isn't going to be nicely

970
00:39:15,369 --> 00:39:19,960
to you know the next<font color="#E5E5E5"> adjacent chunk it</font>

971
00:39:17,319 --> 00:39:21,970
could be all over<font color="#E5E5E5"> the place really this</font>

972
00:39:19,960 --> 00:39:23,619
is where defragmentation comes in you

973
00:39:21,970 --> 00:39:26,379
have to normalize this heap a

974
00:39:23,619 --> 00:39:29,109
prerequisite for all the attacks that<font color="#E5E5E5"> at</font>

975
00:39:26,380 --> 00:39:31,750
least<font color="#CCCCCC"> i have are chunks being adjacent</font>

976
00:39:29,109 --> 00:39:33,700
to each other directly adjacent now be

977
00:39:31,750 --> 00:39:35,470
that all the chunks in a user block

978
00:39:33,700 --> 00:39:37,839
right are adjacent because it's one big

979
00:39:35,470 --> 00:39:39,279
contiguous block of memory but at<font color="#E5E5E5"> the</font>

980
00:39:37,839 --> 00:39:41,319
same time you're<font color="#E5E5E5"> going to want two</font>

981
00:39:39,279 --> 00:39:43,750
things right close<font color="#CCCCCC"> to each other i</font>

982
00:39:41,319 --> 00:39:45,970
talked to alex todorov about kind of

983
00:39:43,750 --> 00:39:48,339
what he<font color="#E5E5E5"> did when he was exploiting these</font>

984
00:39:45,970 --> 00:39:50,040
things and he was<font color="#E5E5E5"> saying that making a</font>

985
00:39:48,339 --> 00:39:51,870
large amount of

986
00:39:50,040 --> 00:39:54,570
locations for the same size would

987
00:39:51,870 --> 00:39:56,759
actually fill these holes and if these

988
00:39:54,570 --> 00:39:58,770
holes are filled you know you have

989
00:39:56,760 --> 00:40:00,240
adjacent chunks not to mention if you

990
00:39:58,770 --> 00:40:02,910
make enough allocations you can

991
00:40:00,240 --> 00:40:04,109
completely exhaust a user block and it

992
00:40:02,910 --> 00:40:05,670
won't quit using it it will just

993
00:40:04,110 --> 00:40:07,710
allocate more memory for it so you could

994
00:40:05,670 --> 00:40:09,690
<font color="#CCCCCC">potentially get a nice fresh user block</font>

995
00:40:07,710 --> 00:40:15,150
for yourself make<font color="#E5E5E5"> after making you know</font>

996
00:40:09,690 --> 00:40:18,720
a large amount of allocations what do

997
00:40:15,150 --> 00:40:21,000
<font color="#E5E5E5">you do with this adjacent data I think a</font>

998
00:40:18,720 --> 00:40:24,390
great example of what to do with

999
00:40:21,000 --> 00:40:25,980
adjacent data as of recently was Peter

1000
00:40:24,390 --> 00:40:28,049
ruckman<font color="#CCCCCC"> hills I hope I pronounced</font><font color="#E5E5E5"> that</font>

1001
00:40:25,980 --> 00:40:31,200
correctly but I don't think<font color="#CCCCCC"> I did paper</font>

1002
00:40:28,050 --> 00:40:32,790
that he did for pound 20 in 2010 what he

1003
00:40:31,200 --> 00:40:34,710
did he is he over wrote a null

1004
00:40:32,790 --> 00:40:37,410
<font color="#E5E5E5">terminator right and now that the spell</font>

1005
00:40:34,710 --> 00:40:38,580
terminator was overwritten the string

1006
00:40:37,410 --> 00:40:40,740
was<font color="#E5E5E5"> way longer than it was supposed to</font>

1007
00:40:38,580 --> 00:40:43,529
<font color="#E5E5E5">be and he used it you know in a process</font>

1008
00:40:40,740 --> 00:40:45,600
<font color="#E5E5E5">to exploit something with adjacent data</font>

1009
00:40:43,530 --> 00:40:47,370
you can you can overwrite chunk headers

1010
00:40:45,600 --> 00:40:49,950
and you can overwrite data inside of it

1011
00:40:47,370 --> 00:40:51,720
if you can get to<font color="#E5E5E5"> C++ objects next to</font>

1012
00:40:49,950 --> 00:40:53,189
each other and right into the next one

1013
00:40:51,720 --> 00:40:56,970
that's going<font color="#E5E5E5"> to be bad times forever</font>

1014
00:40:53,190 --> 00:40:58,740
wrote that application well what if what

1015
00:40:56,970 --> 00:41:01,259
if you can't afford<font color="#E5E5E5"> to overwrite these</font>

1016
00:40:58,740 --> 00:41:04,229
things what if that the munch<font color="#E5E5E5"> C++ object</font>

1017
00:41:01,260 --> 00:41:06,720
is a few chunks away and there's one

1018
00:41:04,230 --> 00:41:09,390
<font color="#E5E5E5">used in between it well you can actually</font>

1019
00:41:06,720 --> 00:41:12,450
<font color="#CCCCCC">use a series of allocations and fries</font>

1020
00:41:09,390 --> 00:41:15,330
based off the last in first out

1021
00:41:12,450 --> 00:41:18,089
structure of<font color="#CCCCCC"> the low fragmentation heap</font>

1022
00:41:15,330 --> 00:41:20,160
so you know you get these blocks if<font color="#E5E5E5"> you</font>

1023
00:41:18,090 --> 00:41:22,260
allocate a piece of memory free it

1024
00:41:20,160 --> 00:41:23,670
allocate it directly again you'll<font color="#E5E5E5"> get</font>

1025
00:41:22,260 --> 00:41:29,280
the same interests back each time you

1026
00:41:23,670 --> 00:41:31,890
know for that<font color="#E5E5E5"> given chunk all right so</font>

1027
00:41:29,280 --> 00:41:34,350
you have you know these chunks and you

1028
00:41:31,890 --> 00:41:35,790
have adjacent data what else can you<font color="#E5E5E5"> use</font>

1029
00:41:34,350 --> 00:41:38,460
since you can get the same chunk back

1030
00:41:35,790 --> 00:41:42,330
multiple times if<font color="#CCCCCC"> you know the size and</font>

1031
00:41:38,460 --> 00:41:43,740
<font color="#E5E5E5">you kind of had a</font><font color="#CCCCCC"> good</font><font color="#E5E5E5"> idea of of the</font>

1032
00:41:42,330 --> 00:41:46,500
you<font color="#E5E5E5"> know the allocation of a certain</font>

1033
00:41:43,740 --> 00:41:49,950
application data seating you can put

1034
00:41:46,500 --> 00:41:52,680
data inside of chunks and have it stay

1035
00:41:49,950 --> 00:41:54,089
<font color="#CCCCCC">there if anyone went to nikka Wiseman's</font>

1036
00:41:52,680 --> 00:41:56,640
<font color="#CCCCCC">talk yesterday he gave you a very</font>

1037
00:41:54,090 --> 00:41:58,530
practical example of what you can do

1038
00:41:56,640 --> 00:42:02,970
with the knowledge<font color="#E5E5E5"> of data seating and</font>

1039
00:41:58,530 --> 00:42:03,810
<font color="#CCCCCC">the sizes</font><font color="#E5E5E5"> of allocations here in my</font>

1040
00:42:02,970 --> 00:42:05,850
example

1041
00:42:03,810 --> 00:42:07,650
I made<font color="#E5E5E5"> for allocations I wrote some</font>

1042
00:42:05,850 --> 00:42:09,960
memory to it i freed all those four

1043
00:42:07,650 --> 00:42:11,880
blocks<font color="#CCCCCC"> I made for subsequent allocations</font>

1044
00:42:09,960 --> 00:42:14,370
this time not writing any memory if you

1045
00:42:11,880 --> 00:42:15,720
see they generally have the same data

1046
00:42:14,370 --> 00:42:18,480
inside of it the only thing that's

1047
00:42:15,720 --> 00:42:19,950
changed is the first<font color="#E5E5E5"> two cha two bites</font>

1048
00:42:18,480 --> 00:42:22,590
right because<font color="#E5E5E5"> that's the free entry</font>

1049
00:42:19,950 --> 00:42:25,770
offset<font color="#CCCCCC"> and again Nico talked in his</font>

1050
00:42:22,590 --> 00:42:27,630
presentation about using this you know

1051
00:42:25,770 --> 00:42:29,759
the the<font color="#E5E5E5"> free entry offset over right to</font>

1052
00:42:27,630 --> 00:42:31,680
overwrite a V table as<font color="#E5E5E5"> well so I think</font>

1053
00:42:29,760 --> 00:42:35,220
<font color="#E5E5E5">everyone should definitely check out his</font>

1054
00:42:31,680 --> 00:42:39,930
presentation<font color="#CCCCCC"> reedom read his paper buy</font>

1055
00:42:35,220 --> 00:42:42,540
<font color="#E5E5E5">him a beer downstairs</font><font color="#CCCCCC"> okay now it's time</font>

1056
00:42:39,930 --> 00:42:45,029
to talk about exploitation for all the

1057
00:42:42,540 --> 00:42:47,700
bus<font color="#CCCCCC"> tecate out there the first thing</font>

1058
00:42:45,030 --> 00:42:50,070
<font color="#E5E5E5">I'll talk about is a technique that I</font>

1059
00:42:47,700 --> 00:42:51,569
call Ben<font color="#E5E5E5"> Hawks number one Ben Hawks</font>

1060
00:42:50,070 --> 00:42:53,640
wrote a paper and did a<font color="#E5E5E5"> black hat</font>

1061
00:42:51,570 --> 00:42:56,040
presentation in 2008 I've read<font color="#E5E5E5"> it like</font>

1062
00:42:53,640 --> 00:42:58,319
20 times and there's literally like 30

1063
00:42:56,040 --> 00:43:00,630
techniques that he<font color="#E5E5E5"> came up with in it he</font>

1064
00:42:58,320 --> 00:43:03,720
<font color="#CCCCCC">just</font><font color="#E5E5E5"> you know had a bunch of brilliant</font>

1065
00:43:00,630 --> 00:43:05,970
ideas but I<font color="#CCCCCC"> singled this one out because</font>

1066
00:43:03,720 --> 00:43:07,770
it just caught my eye we saw when

1067
00:43:05,970 --> 00:43:10,890
freeing a low fragmentation heap chunk

1068
00:43:07,770 --> 00:43:13,500
right that if the onions bites have a

1069
00:43:10,890 --> 00:43:17,580
<font color="#E5E5E5">value of five more more data is actually</font>

1070
00:43:13,500 --> 00:43:19,620
the the pointer is actually updated to a

1071
00:43:17,580 --> 00:43:21,480
different location instead<font color="#CCCCCC"> of the the</font>

1072
00:43:19,620 --> 00:43:23,549
the chunk header that you kind of just

1073
00:43:21,480 --> 00:43:25,470
passed in there well what could you do

1074
00:43:23,550 --> 00:43:28,890
with this you you control the amount

1075
00:43:25,470 --> 00:43:30,930
that that is subtracted if you<font color="#E5E5E5"> haven't</font>

1076
00:43:28,890 --> 00:43:33,509
over right and you control whether it

1077
00:43:30,930 --> 00:43:36,540
gets triggered I think the best thing

1078
00:43:33,510 --> 00:43:39,630
that you could do<font color="#E5E5E5"> with this is abuse C++</font>

1079
00:43:36,540 --> 00:43:41,279
objects so what you want to do right is

1080
00:43:39,630 --> 00:43:44,280
you want<font color="#E5E5E5"> to get two chunks adjacent to</font>

1081
00:43:41,280 --> 00:43:46,230
each other one that<font color="#CCCCCC"> you can overflow one</font>

1082
00:43:44,280 --> 00:43:49,200
that you can overflow into the one that

1083
00:43:46,230 --> 00:43:51,270
you overflow into it should<font color="#E5E5E5"> be capable</font>

1084
00:43:49,200 --> 00:43:54,540
<font color="#E5E5E5">of being freed if you overwrite those</font>

1085
00:43:51,270 --> 00:43:57,180
unused<font color="#E5E5E5"> bytes to be five and you</font>

1086
00:43:54,540 --> 00:43:59,880
overwrite the the segment off set to a

1087
00:43:57,180 --> 00:44:02,910
value control you<font color="#E5E5E5"> have eight times one</font>

1088
00:43:59,880 --> 00:44:05,160
bite so eight times ff- range that you

1089
00:44:02,910 --> 00:44:08,759
can point now it has<font color="#E5E5E5"> to point to a valid</font>

1090
00:44:05,160 --> 00:44:10,770
valid heap entry but if you're in the

1091
00:44:08,760 --> 00:44:12,510
user blocks you know every so often

1092
00:44:10,770 --> 00:44:13,890
there there<font color="#CCCCCC"> are valid he'd been trees</font>

1093
00:44:12,510 --> 00:44:15,270
especially you know if you make sum

1094
00:44:13,890 --> 00:44:16,220
allocations there's going<font color="#CCCCCC"> to be ones</font>

1095
00:44:15,270 --> 00:44:18,950
behind you

1096
00:44:16,220 --> 00:44:20,899
with this<font color="#E5E5E5"> you free that chunk and since</font>

1097
00:44:18,950 --> 00:44:22,730
the last in first out nature<font color="#E5E5E5"> of the low</font>

1098
00:44:20,900 --> 00:44:26,599
fragmentation heap works you make an

1099
00:44:22,730 --> 00:44:28,910
allocation you just got the dress of say

1100
00:44:26,599 --> 00:44:30,890
a c++ object that is currently in use

1101
00:44:28,910 --> 00:44:32,540
overwrite whatever's there especially

1102
00:44:30,890 --> 00:44:35,299
the<font color="#E5E5E5"> first four bytes hopefully that's a</font>

1103
00:44:32,540 --> 00:44:37,550
V table make a call to that<font color="#E5E5E5"> C++ object</font>

1104
00:44:35,300 --> 00:44:39,890
at that point<font color="#E5E5E5"> you know you can work on</font>

1105
00:44:37,550 --> 00:44:45,560
defeating depth<font color="#CCCCCC"> a SLR whatever you want</font>

1106
00:44:39,890 --> 00:44:48,650
now for my half-assed version of an

1107
00:44:45,560 --> 00:44:51,770
exploitation tactic before<font color="#E5E5E5"> I talk about</font>

1108
00:44:48,650 --> 00:44:56,359
<font color="#E5E5E5">it I wanted to explain to everyone that</font>

1109
00:44:51,770 --> 00:44:57,680
everything in our TLP loaf rag heap<font color="#E5E5E5"> Alec</font>

1110
00:44:56,359 --> 00:44:59,660
from<font color="#E5E5E5"> context that's the low</font>

1111
00:44:57,680 --> 00:45:02,000
fragmentation<font color="#CCCCCC"> deep allocator is wrapped</font>

1112
00:44:59,660 --> 00:45:04,879
in<font color="#E5E5E5"> a try catch all if there's any</font>

1113
00:45:02,000 --> 00:45:07,099
exceptions 0 will<font color="#CCCCCC"> be returned and as I</font>

1114
00:45:04,880 --> 00:45:09,980
said before the<font color="#E5E5E5"> back end manager</font><font color="#CCCCCC"> will</font>

1115
00:45:07,099 --> 00:45:12,859
fill that request this is where you

1116
00:45:09,980 --> 00:45:14,420
could abuse basically<font color="#CCCCCC"> brute forcing we</font>

1117
00:45:12,859 --> 00:45:17,060
kind of hinted to this last year as well

1118
00:45:14,420 --> 00:45:18,230
with the<font color="#E5E5E5"> look aside list as well you</font>

1119
00:45:17,060 --> 00:45:20,270
could potentially<font color="#CCCCCC"> start guessing</font>

1120
00:45:18,230 --> 00:45:22,130
addresses if they're you know if it's

1121
00:45:20,270 --> 00:45:24,710
uncommitted memory exception happens

1122
00:45:22,130 --> 00:45:27,020
nicely that the<font color="#CCCCCC"> back end allocator will</font>

1123
00:45:24,710 --> 00:45:28,730
fill<font color="#CCCCCC"> a quest the culling process is done</font>

1124
00:45:27,020 --> 00:45:30,020
the wiser if you can keep triggering

1125
00:45:28,730 --> 00:45:33,530
this you<font color="#E5E5E5"> could potentially you know</font>

1126
00:45:30,020 --> 00:45:36,410
guess values that could be the the<font color="#CCCCCC"> heat</font>

1127
00:45:33,530 --> 00:45:38,450
base and you can<font color="#CCCCCC"> perform</font><font color="#E5E5E5"> bent hawks you</font>

1128
00:45:36,410 --> 00:45:41,839
know heap handle<font color="#CCCCCC"> overwrite attack to to</font>

1129
00:45:38,450 --> 00:45:46,910
gain code execution but back<font color="#CCCCCC"> to the free</font>

1130
00:45:41,839 --> 00:45:49,910
entry offset so let's<font color="#CCCCCC"> assume again a</font>

1131
00:45:46,910 --> 00:45:51,770
user block for size of<font color="#E5E5E5"> 30 hex bites and</font>

1132
00:45:49,910 --> 00:45:53,720
it's going<font color="#E5E5E5"> to be a fresh user block it</font>

1133
00:45:51,770 --> 00:45:55,880
doesn't<font color="#CCCCCC"> necessarily have to be you</font><font color="#E5E5E5"> just</font>

1134
00:45:53,720 --> 00:45:57,348
need two adjacent chunks one that you

1135
00:45:55,880 --> 00:46:00,200
can overwrite and one that could<font color="#E5E5E5"> be</font>

1136
00:45:57,349 --> 00:46:02,210
overwritten into so you know if you

1137
00:46:00,200 --> 00:46:04,129
would<font color="#E5E5E5"> make an allocation here the free</font>

1138
00:46:02,210 --> 00:46:06,710
entry offset would be updated<font color="#CCCCCC"> to point</font>

1139
00:46:04,130 --> 00:46:08,810
to offset<font color="#E5E5E5"> eight that's the next chunk if</font>

1140
00:46:06,710 --> 00:46:11,900
you made another allocation offset<font color="#CCCCCC"> II</font>

1141
00:46:08,810 --> 00:46:13,640
another allocation offset 14 its sensor

1142
00:46:11,900 --> 00:46:17,599
at second etc that's because you know

1143
00:46:13,640 --> 00:46:19,400
for size 30 X bites it's six blocks well

1144
00:46:17,599 --> 00:46:23,300
what if what did<font color="#E5E5E5"> you make an allocation</font>

1145
00:46:19,400 --> 00:46:25,400
and you overwrite the next offset entry

1146
00:46:23,300 --> 00:46:28,580
so that basically assumes you have at

1147
00:46:25,400 --> 00:46:29,680
least nine bytes of overflow tend to be

1148
00:46:28,580 --> 00:46:32,740
preferable

1149
00:46:29,680 --> 00:46:35,379
well if you overwrite this next offset

1150
00:46:32,740 --> 00:46:37,810
you can override it with whatever short

1151
00:46:35,380 --> 00:46:40,990
you want right so that's FF FF x 8

1152
00:46:37,810 --> 00:46:43,690
that's<font color="#E5E5E5"> forward range that you have and</font>

1153
00:46:40,990 --> 00:46:46,180
you know<font color="#E5E5E5"> you make another allocation the</font>

1154
00:46:43,690 --> 00:46:48,910
free entry offset now is a value that i

1155
00:46:46,180 --> 00:46:51,399
wrote 1501 instead of<font color="#E5E5E5"> you know II that</font>

1156
00:46:48,910 --> 00:46:53,620
<font color="#E5E5E5">it should have been a lot of people ask</font>

1157
00:46:51,400 --> 00:46:55,510
<font color="#E5E5E5">me well so what if you have an overflow</font>

1158
00:46:53,620 --> 00:46:58,390
just just overflow everything the user

1159
00:46:55,510 --> 00:47:01,450
block you know and an overflow values

1160
00:46:58,390 --> 00:47:02,620
well you can be you know brutal about it

1161
00:47:01,450 --> 00:47:05,410
you could be a little<font color="#E5E5E5"> bit elegant as</font>

1162
00:47:02,620 --> 00:47:07,089
well you could try to get this so you

1163
00:47:05,410 --> 00:47:08,379
<font color="#E5E5E5">don't munge all the data you don't want</font>

1164
00:47:07,090 --> 00:47:10,690
to ruin every chunk header<font color="#E5E5E5"> in a user</font>

1165
00:47:08,380 --> 00:47:12,160
block what if there's<font color="#E5E5E5"> C++ objects and</font>

1166
00:47:10,690 --> 00:47:14,410
not use a block that are used the

1167
00:47:12,160 --> 00:47:17,109
application is<font color="#CCCCCC"> going</font><font color="#E5E5E5"> to crash but if you</font>

1168
00:47:14,410 --> 00:47:19,180
only you know update this free entry

1169
00:47:17,110 --> 00:47:22,030
offset you kind of have a range to where

1170
00:47:19,180 --> 00:47:25,270
you point to now the next allocation

1171
00:47:22,030 --> 00:47:27,550
will be at the user blocks plus we're

1172
00:47:25,270 --> 00:47:32,170
the last chunk was plus the free entry

1173
00:47:27,550 --> 00:47:34,510
offset x 8 that on this one for size 30

1174
00:47:32,170 --> 00:47:36,100
would you know point off the memory page

1175
00:47:34,510 --> 00:47:38,620
it<font color="#E5E5E5"> would it would point into uncommitted</font>

1176
00:47:36,100 --> 00:47:40,540
memory somewhere but say after you<font color="#E5E5E5"> do</font>

1177
00:47:38,620 --> 00:47:43,870
this you create a bunch<font color="#E5E5E5"> of objects of</font>

1178
00:47:40,540 --> 00:47:46,390
another size specifically<font color="#CCCCCC"> C++ objects</font>

1179
00:47:43,870 --> 00:47:48,430
right if you can get this within<font color="#CCCCCC"> the</font>

1180
00:47:46,390 --> 00:47:50,680
range it doesn't necessarily<font color="#CCCCCC"> need to be</font>

1181
00:47:48,430 --> 00:47:52,540
in completely adjacent data it just

1182
00:47:50,680 --> 00:47:55,930
needs<font color="#E5E5E5"> to be within the range you control</font>

1183
00:47:52,540 --> 00:47:58,029
you can set these objects up make a

1184
00:47:55,930 --> 00:47:59,980
subsequent allocation right you know

1185
00:47:58,030 --> 00:48:02,320
normally<font color="#E5E5E5"> under good circumstances you</font>

1186
00:47:59,980 --> 00:48:04,150
would get<font color="#E5E5E5"> the chunk at offset e but now</font>

1187
00:48:02,320 --> 00:48:07,240
<font color="#E5E5E5">since we've bunged the free entry offset</font>

1188
00:48:04,150 --> 00:48:08,920
you can get the different address back

1189
00:48:07,240 --> 00:48:11,770
hopefully<font color="#E5E5E5"> this point it points it to the</font>

1190
00:48:08,920 --> 00:48:14,650
<font color="#E5E5E5">C++ objects from there you have a right</font>

1191
00:48:11,770 --> 00:48:17,680
end situation for whatever n is the

1192
00:48:14,650 --> 00:48:20,860
bucket size that you're using this could

1193
00:48:17,680 --> 00:48:23,830
be used<font color="#CCCCCC"> to skip</font><font color="#E5E5E5"> over you know areas of</font>

1194
00:48:20,860 --> 00:48:25,750
uncommitted memory possibly you know

1195
00:48:23,830 --> 00:48:28,060
guard pages or whatever it could

1196
00:48:25,750 --> 00:48:30,970
technically you know nullify this but

1197
00:48:28,060 --> 00:48:33,400
also you could kind of skip anywhere<font color="#CCCCCC"> you</font>

1198
00:48:30,970 --> 00:48:35,319
want in memory and write write data out

1199
00:48:33,400 --> 00:48:36,610
without ruining everything in between it

1200
00:48:35,320 --> 00:48:37,840
so I thought it<font color="#E5E5E5"> was neat because you</font>

1201
00:48:36,610 --> 00:48:40,150
know a lot of the<font color="#CCCCCC"> traditional overflows</font>

1202
00:48:37,840 --> 00:48:42,190
you needed<font color="#E5E5E5"> to destroy everything in its</font>

1203
00:48:40,150 --> 00:48:43,030
path to get where you're going kind of

1204
00:48:42,190 --> 00:48:45,100
<font color="#E5E5E5">with this technique</font>

1205
00:48:43,030 --> 00:48:48,340
you can be<font color="#E5E5E5"> more selective about what you</font>

1206
00:48:45,100 --> 00:48:51,279
want to overwrite the last thing I'm

1207
00:48:48,340 --> 00:48:53,320
going<font color="#E5E5E5"> to talk about is an observation I</font>

1208
00:48:51,280 --> 00:48:57,190
guess I didn't want<font color="#CCCCCC"> to put it</font><font color="#E5E5E5"> in the</font>

1209
00:48:53,320 --> 00:49:00,130
exploitation section because it has a

1210
00:48:57,190 --> 00:49:02,020
lot of prerequisites and a lot<font color="#E5E5E5"> of them I</font>

1211
00:49:00,130 --> 00:49:04,300
haven't fully figured out yet but I

1212
00:49:02,020 --> 00:49:05,950
would totally like if someone looked<font color="#E5E5E5"> at</font>

1213
00:49:04,300 --> 00:49:09,220
this and figured<font color="#E5E5E5"> out exactly how to</font><font color="#CCCCCC"> make</font>

1214
00:49:05,950 --> 00:49:11,710
this work we talked<font color="#CCCCCC"> about before an</font>

1215
00:49:09,220 --> 00:49:14,259
allocation right if the sub segments

1216
00:49:11,710 --> 00:49:15,910
can't fulfill this allocation it's going

1217
00:49:14,260 --> 00:49:18,640
to need to<font color="#E5E5E5"> allocate more memory well</font>

1218
00:49:15,910 --> 00:49:21,759
it's going to allocate the user block

1219
00:49:18,640 --> 00:49:23,980
first and if<font color="#CCCCCC"> that pool of addresses for</font>

1220
00:49:21,760 --> 00:49:25,270
<font color="#CCCCCC">the sub segments have been</font><font color="#E5E5E5"> exhausted or</font>

1221
00:49:23,980 --> 00:49:27,700
this is<font color="#E5E5E5"> the first run of</font><font color="#CCCCCC"> the low</font>

1222
00:49:25,270 --> 00:49:29,710
fragmentation heap it's going<font color="#E5E5E5"> to it's</font>

1223
00:49:27,700 --> 00:49:32,319
going to allocate memory for sub

1224
00:49:29,710 --> 00:49:35,020
segments in directly<font color="#E5E5E5"> adjacent memory so</font>

1225
00:49:32,320 --> 00:49:37,420
there's a point where you could have a

1226
00:49:35,020 --> 00:49:41,050
memory layout like this you could have

1227
00:49:37,420 --> 00:49:42,790
your user block directly before a memory

1228
00:49:41,050 --> 00:49:44,800
that's use for these heap sub segments

1229
00:49:42,790 --> 00:49:47,920
well what good is this to you if you

1230
00:49:44,800 --> 00:49:49,660
remember heap sub-segments have that

1231
00:49:47,920 --> 00:49:52,030
that user blocks pointer and that user

1232
00:49:49,660 --> 00:49:53,200
blocks pointer it is used<font color="#E5E5E5"> to give a</font>

1233
00:49:52,030 --> 00:49:55,720
memory address back to<font color="#CCCCCC"> the calling</font>

1234
00:49:53,200 --> 00:49:58,029
<font color="#E5E5E5">process for which you can write well at</font>

1235
00:49:55,720 --> 00:49:59,560
that point choose a dress you want<font color="#E5E5E5"> to</font>

1236
00:49:58,030 --> 00:50:02,020
overwrite make an allocation and

1237
00:49:59,560 --> 00:50:03,370
overwrite it it sounds all fine and

1238
00:50:02,020 --> 00:50:07,060
dandy when I first looked at it I

1239
00:50:03,370 --> 00:50:08,259
thought<font color="#E5E5E5"> it</font><font color="#CCCCCC"> was that</font><font color="#E5E5E5"> easy as you see here</font>

1240
00:50:07,060 --> 00:50:10,420
this<font color="#CCCCCC"> is what you can potentially over</font>

1241
00:50:08,260 --> 00:50:12,400
right you could overflow or you could

1242
00:50:10,420 --> 00:50:14,650
<font color="#CCCCCC">use kind of the the free entry offset</font>

1243
00:50:12,400 --> 00:50:15,910
attack I came up with to elegantly skip

1244
00:50:14,650 --> 00:50:20,650
over all the chunks you don't want to

1245
00:50:15,910 --> 00:50:23,589
ruin into<font color="#CCCCCC"> this zone unfortunately it's</font>

1246
00:50:20,650 --> 00:50:25,720
kind of hard to figure<font color="#CCCCCC"> out when this</font>

1247
00:50:23,590 --> 00:50:29,590
scenario would happen when you would run

1248
00:50:25,720 --> 00:50:31,419
<font color="#E5E5E5">out of of chunks in the user block and</font>

1249
00:50:29,590 --> 00:50:34,930
actually have it put directly adjacent

1250
00:50:31,420 --> 00:50:36,910
or within range at<font color="#CCCCCC"> least of the pool</font>

1251
00:50:34,930 --> 00:50:38,410
<font color="#CCCCCC">used for sub segments I'm not saying</font>

1252
00:50:36,910 --> 00:50:40,569
<font color="#CCCCCC">it's impossible i'm just saying i was</font>

1253
00:50:38,410 --> 00:50:42,910
too dumb and lazy to figure it out so

1254
00:50:40,570 --> 00:50:45,190
like I said if someone wants<font color="#CCCCCC"> to look at</font>

1255
00:50:42,910 --> 00:50:46,330
it more figure it out<font color="#E5E5E5"> I think it would</font>

1256
00:50:45,190 --> 00:50:48,790
<font color="#CCCCCC">be really neat because at this point</font>

1257
00:50:46,330 --> 00:50:51,610
you're basically relying on pure heat

1258
00:50:48,790 --> 00:50:54,520
metadata to get an<font color="#E5E5E5"> invite over right</font>

1259
00:50:51,610 --> 00:50:56,770
there's really<font color="#E5E5E5"> no trickeration involved</font>

1260
00:50:54,520 --> 00:50:59,350
with you<font color="#CCCCCC"> know having 14 prerequisites</font>

1261
00:50:56,770 --> 00:51:01,480
of application<font color="#CCCCCC"> layer data to to</font>

1262
00:50:59,350 --> 00:51:03,400
overwrite the other thing that kind of

1263
00:51:01,480 --> 00:51:06,700
ruins this as well is there's a check

1264
00:51:03,400 --> 00:51:08,800
and allocator it ensures that the sub

1265
00:51:06,700 --> 00:51:10,299
segments parent that local info

1266
00:51:08,800 --> 00:51:13,060
structure we saw how<font color="#E5E5E5"> could have all</font>

1267
00:51:10,300 --> 00:51:15,460
these structures are parental matches

1268
00:51:13,060 --> 00:51:17,950
the one the address stored in the low

1269
00:51:15,460 --> 00:51:19,600
fragmentation heat if you don't know

1270
00:51:17,950 --> 00:51:21,069
this address it will fail when just

1271
00:51:19,600 --> 00:51:24,130
allocate more memory which is<font color="#E5E5E5"> not</font><font color="#CCCCCC"> what</font>

1272
00:51:21,070 --> 00:51:26,200
you want that being said again I think

1273
00:51:24,130 --> 00:51:29,920
the free entry offset attack could be

1274
00:51:26,200 --> 00:51:31,660
used<font color="#CCCCCC"> to skip over the this local info</font>

1275
00:51:29,920 --> 00:51:33,370
member because it comes before the user

1276
00:51:31,660 --> 00:51:35,290
block in memory<font color="#CCCCCC"> so maybe you could just</font>

1277
00:51:33,370 --> 00:51:38,410
skip over it and write directly to that

1278
00:51:35,290 --> 00:51:39,670
user info and and be done with it but

1279
00:51:38,410 --> 00:51:42,370
<font color="#E5E5E5">again that's something I</font><font color="#CCCCCC"> just kind of</font>

1280
00:51:39,670 --> 00:51:46,660
<font color="#E5E5E5">theorized about and and have no kind of</font>

1281
00:51:42,370 --> 00:51:49,960
practical application at the moment this

1282
00:51:46,660 --> 00:51:53,049
kind<font color="#E5E5E5"> of brings us to to the end of this</font>

1283
00:51:49,960 --> 00:51:55,930
I hope everyone saw that that data

1284
00:51:53,050 --> 00:51:57,790
structures were far more complex<font color="#E5E5E5"> than</font>

1285
00:51:55,930 --> 00:51:59,859
they used to be and you know these

1286
00:51:57,790 --> 00:52:03,070
dedicated free days have gone away these

1287
00:51:59,860 --> 00:52:06,100
listings you know point into<font color="#CCCCCC"> the overall</font>

1288
00:52:03,070 --> 00:52:07,810
free<font color="#CCCCCC"> list security mechanisms or their</font>

1289
00:52:06,100 --> 00:52:12,910
all-time highest it's really difficult

1290
00:52:07,810 --> 00:52:16,480
<font color="#E5E5E5">to exploit reliably heap overflows that</font>

1291
00:52:12,910 --> 00:52:19,000
being said normalization work is more

1292
00:52:16,480 --> 00:52:20,650
than important than ever you're going to

1293
00:52:19,000 --> 00:52:23,260
<font color="#E5E5E5">need to figure</font><font color="#CCCCCC"> out</font><font color="#E5E5E5"> how to get memory</font>

1294
00:52:20,650 --> 00:52:26,080
close to each other to do what you need

1295
00:52:23,260 --> 00:52:28,510
to be done but I do think<font color="#CCCCCC"> there's still</font>

1296
00:52:26,080 --> 00:52:31,779
a lot of<font color="#CCCCCC"> things to be done as well I</font>

1297
00:52:28,510 --> 00:52:33,880
want to<font color="#E5E5E5"> see a lot more windows 7</font>

1298
00:52:31,780 --> 00:52:36,010
reliable exploits out there I want<font color="#E5E5E5"> to</font>

1299
00:52:33,880 --> 00:52:38,140
see what other people think and what

1300
00:52:36,010 --> 00:52:40,600
other techniques they have just for a

1301
00:52:38,140 --> 00:52:43,660
few the unencoded section of the heap

1302
00:52:40,600 --> 00:52:45,400
entry you know that<font color="#E5E5E5"> could be abused for</font>

1303
00:52:43,660 --> 00:52:47,710
things<font color="#E5E5E5"> I didn't even begin to reverse</font>

1304
00:52:45,400 --> 00:52:49,720
any of the virtual debug allocation or

1305
00:52:47,710 --> 00:52:51,280
free routines in Windows 7<font color="#E5E5E5"> that's a lot</font>

1306
00:52:49,720 --> 00:52:53,950
<font color="#CCCCCC">of ground to cover there for you know</font>

1307
00:52:51,280 --> 00:52:55,720
chunks of very large sizes there's a lot

1308
00:52:53,950 --> 00:52:57,669
<font color="#CCCCCC">of caching mechanisms that I left out</font>

1309
00:52:55,720 --> 00:53:02,200
for simplicity's sake that may<font color="#CCCCCC"> be able</font>

1310
00:52:57,670 --> 00:53:04,900
<font color="#E5E5E5">to be abused you know accordingly I</font>

1311
00:53:02,200 --> 00:53:07,770
think heap manipulation techniques are

1312
00:53:04,900 --> 00:53:11,010
going to be<font color="#E5E5E5"> even more important that</font>

1313
00:53:07,770 --> 00:53:12,900
then you know the bug at that point Dino

1314
00:53:11,010 --> 00:53:15,690
<font color="#CCCCCC">and I the other</font><font color="#E5E5E5"> night we're talking</font>

1315
00:53:12,900 --> 00:53:17,490
<font color="#E5E5E5">about you</font><font color="#CCCCCC"> know hey wouldn't it be nice</font>

1316
00:53:15,690 --> 00:53:20,040
if you know at least at a

1317
00:53:17,490 --> 00:53:22,830
per-application level you could write

1318
00:53:20,040 --> 00:53:25,110
these programs that would put the heap

1319
00:53:22,830 --> 00:53:26,490
in a guaranteed normalized state and I

1320
00:53:25,110 --> 00:53:28,230
things think things like that are

1321
00:53:26,490 --> 00:53:30,359
possible<font color="#E5E5E5"> you you can ensure</font>

1322
00:53:28,230 --> 00:53:33,540
normalization if you know enough about

1323
00:53:30,360 --> 00:53:35,790
the<font color="#CCCCCC"> application and and how it allocates</font>

1324
00:53:33,540 --> 00:53:38,400
in<font color="#CCCCCC"> fries memory you know</font><font color="#E5E5E5"> obviously</font>

1325
00:53:35,790 --> 00:53:40,080
address leaks are going to be really

1326
00:53:38,400 --> 00:53:42,000
important because that's a prerequisite

1327
00:53:40,080 --> 00:53:45,120
for everything nowadays really right i

1328
00:53:42,000 --> 00:53:48,390
mean you can defeat dep if you know in

1329
00:53:45,120 --> 00:53:50,069
ASL are if you<font color="#E5E5E5"> have a leaked address the</font>

1330
00:53:48,390 --> 00:53:52,859
<font color="#E5E5E5">other thing I want to state was last</font>

1331
00:53:50,070 --> 00:53:55,200
year<font color="#E5E5E5"> after our talk how about flake said</font>

1332
00:53:52,860 --> 00:53:57,750
hey you know what you guys should do you

1333
00:53:55,200 --> 00:53:59,430
should do a thing<font color="#CCCCCC"> called heap</font><font color="#E5E5E5"> con and</font>

1334
00:53:57,750 --> 00:54:00,690
it's just a convention where everyone

1335
00:53:59,430 --> 00:54:02,850
talks about different heaps and

1336
00:54:00,690 --> 00:54:03,930
different operating systems what they

1337
00:54:02,850 --> 00:54:05,910
should do and<font color="#CCCCCC"> I</font><font color="#E5E5E5"> thought it was a</font>

1338
00:54:03,930 --> 00:54:07,379
brilliant idea I just don't<font color="#E5E5E5"> want to do</font>

1339
00:54:05,910 --> 00:54:09,060
it so maybe someone could organize that

1340
00:54:07,380 --> 00:54:16,260
and we can we can all<font color="#E5E5E5"> get to talk</font><font color="#CCCCCC"> about</font>

1341
00:54:09,060 --> 00:54:18,660
heaps so he's passed it<font color="#E5E5E5"> to be and I'm</font>

1342
00:54:16,260 --> 00:54:21,210
passing it at someone else that's

1343
00:54:18,660 --> 00:54:23,940
fantastic<font color="#CCCCCC"> but</font><font color="#E5E5E5"> um I'd like</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> greet</font>

1344
00:54:21,210 --> 00:54:25,440
everyone who kind<font color="#E5E5E5"> of did copy edits and</font>

1345
00:54:23,940 --> 00:54:27,120
help me out if I've left anyone awesome

1346
00:54:25,440 --> 00:54:29,250
sorry but it<font color="#E5E5E5"> was a lot of work and a lot</font>

1347
00:54:27,120 --> 00:54:32,069
of people actually<font color="#E5E5E5"> you know helped me do</font>

1348
00:54:29,250 --> 00:54:33,720
everything there you know the bus tecate

1349
00:54:32,070 --> 00:54:37,020
look out for one another and<font color="#E5E5E5"> that's how</font>

1350
00:54:33,720 --> 00:54:39,689
we roll now<font color="#E5E5E5"> I have a little demo of a</font>

1351
00:54:37,020 --> 00:54:42,060
unity<font color="#CCCCCC"> plug-in i wrote i think it's going</font>

1352
00:54:39,690 --> 00:54:46,260
to be released in the the<font color="#CCCCCC"> next release</font>

1353
00:54:42,060 --> 00:54:50,100
yeah probably<font color="#CCCCCC"> i also upload at least you</font>

1354
00:54:46,260 --> 00:54:54,390
know my script to to the website for

1355
00:54:50,100 --> 00:54:57,630
black hat so what this script does is it

1356
00:54:54,390 --> 00:55:00,089
just traverses these blocks index

1357
00:54:57,630 --> 00:55:02,670
structures and you know kind of

1358
00:55:00,090 --> 00:55:07,620
determines what heat buckets are in use

1359
00:55:02,670 --> 00:55:09,390
and let me get this all figured out you

1360
00:55:07,620 --> 00:55:15,960
know<font color="#E5E5E5"> I think that would</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> neat for</font>

1361
00:55:09,390 --> 00:55:17,160
exploit writers you know whoever all

1362
00:55:15,960 --> 00:55:19,170
right while we're waiting<font color="#CCCCCC"> for this I</font>

1363
00:55:17,160 --> 00:55:20,690
will win a side bet with twitter i said

1364
00:55:19,170 --> 00:55:23,150
i would say meow<font color="#E5E5E5"> tent</font>

1365
00:55:20,690 --> 00:55:27,260
<font color="#E5E5E5">during this presentation now now now now</font>

1366
00:55:23,150 --> 00:55:32,569
now now<font color="#E5E5E5"> meow meow meow now someone else</font>

1367
00:55:27,260 --> 00:55:34,010
<font color="#E5E5E5">be drinks downstairs yeah okay so the</font>

1368
00:55:32,569 --> 00:55:37,910
first thing we'll do with ie here is

1369
00:55:34,010 --> 00:55:39,410
we'll find a heap to use right and we'll

1370
00:55:37,910 --> 00:55:41,660
<font color="#E5E5E5">just use this first one my command is</font>

1371
00:55:39,410 --> 00:55:46,549
called horse because heaps are a lot

1372
00:55:41,660 --> 00:55:48,920
like horses they can't be<font color="#E5E5E5"> trusted okay</font>

1373
00:55:46,550 --> 00:55:53,210
so we'll do a horse and then give it a

1374
00:55:48,920 --> 00:55:54,770
heap to use and slowly but<font color="#E5E5E5"> surely this</font>

1375
00:55:53,210 --> 00:55:58,849
will come up<font color="#CCCCCC"> here and we'll scroll up</font>

1376
00:55:54,770 --> 00:56:01,009
well I'm being at I want to be

1377
00:55:58,849 --> 00:56:04,099
consultant services manager<font color="#CCCCCC"> and should</font>

1378
00:56:01,010 --> 00:56:06,920
<font color="#E5E5E5">get hired it shows you buckets here so</font>

1379
00:56:04,099 --> 00:56:10,400
you see<font color="#CCCCCC"> you</font><font color="#E5E5E5"> know for bucket six it has a</font>

1380
00:56:06,920 --> 00:56:12,800
heat<font color="#CCCCCC"> puckett for bucket you know for</font>

1381
00:56:10,400 --> 00:56:14,270
bucket 12 it's not using a low

1382
00:56:12,800 --> 00:56:15,740
fragmentation heap yet it actually<font color="#E5E5E5"> only</font>

1383
00:56:14,270 --> 00:56:17,780
needs two more allocations though then

1384
00:56:15,740 --> 00:56:20,029
it will start using it so you could use

1385
00:56:17,780 --> 00:56:21,470
this to determine what buckets are being

1386
00:56:20,030 --> 00:56:23,630
used by the low fragmentation heap and

1387
00:56:21,470 --> 00:56:25,279
specifically my thoughts were<font color="#E5E5E5"> you want</font>

1388
00:56:23,630 --> 00:56:27,170
fresh user blocks to deal with that way

1389
00:56:25,280 --> 00:56:29,540
you don't even need to defragment<font color="#CCCCCC"> I</font>

1390
00:56:27,170 --> 00:56:31,849
added another little command here will

1391
00:56:29,540 --> 00:56:40,970
clear the window and you can<font color="#E5E5E5"> actually</font>

1392
00:56:31,849 --> 00:56:42,740
<font color="#E5E5E5">say dash n ok these will give you all</font>

1393
00:56:40,970 --> 00:56:44,359
the heat buckets that have never been

1394
00:56:42,740 --> 00:56:47,240
used there have never been an allocation

1395
00:56:44,359 --> 00:56:49,549
for these this size so<font color="#E5E5E5"> you know you</font>

1396
00:56:47,240 --> 00:56:52,339
could say hey I can control this size

1397
00:56:49,550 --> 00:56:55,700
you can fully control when it's enabled

1398
00:56:52,339 --> 00:56:57,560
and how<font color="#CCCCCC"> many blocks so well not</font><font color="#E5E5E5"> that</font>

1399
00:56:55,700 --> 00:57:01,189
useful it will give you a good<font color="#CCCCCC"> idea on</font>

1400
00:56:57,560 --> 00:57:04,578
on how much and how many<font color="#E5E5E5"> blocks are used</font>

1401
00:57:01,190 --> 00:57:07,790
so that being said if there's any

1402
00:57:04,579 --> 00:57:09,380
questions you can ask me here or see me

1403
00:57:07,790 --> 00:57:11,650
at the galleria bar downstairs and buy

1404
00:57:09,380 --> 00:57:11,650
me<font color="#CCCCCC"> a drink</font>

1405
00:57:13,740 --> 00:57:15,799
you

