1
00:00:03,820 --> 00:00:13,640
[Music]

2
00:00:14,719 --> 00:00:16,560
hello everyone welcome to my

3
00:00:16,560 --> 00:00:17,760
presentation

4
00:00:17,760 --> 00:00:20,720
today my topic is related to the apple

5
00:00:20,720 --> 00:00:21,279
wi-fi

6
00:00:21,279 --> 00:00:26,760
subsystem the title is dive into apple

7
00:00:26,760 --> 00:00:28,800
io80211 family

8
00:00:28,800 --> 00:00:32,320
version 2. my name is wang

9
00:00:32,320 --> 00:00:34,960
from dd research america i can be

10
00:00:34,960 --> 00:00:35,600
reached

11
00:00:35,600 --> 00:00:39,040
through this email address

12
00:00:39,520 --> 00:00:41,920
in the first part of the presentation we

13
00:00:41,920 --> 00:00:43,200
will focus on

14
00:00:43,200 --> 00:00:47,200
the architecture of the subsystem

15
00:00:49,960 --> 00:00:51,120
io80211

16
00:00:51,120 --> 00:00:55,280
family is a very old kernel component

17
00:00:55,280 --> 00:00:58,960
but things has changed since last year

18
00:00:58,960 --> 00:01:02,480
apple refactored the architecture of the

19
00:01:02,480 --> 00:01:06,000
wi-fi client drivers and renamed

20
00:01:06,000 --> 00:01:09,920
the new generation design to version 2.

21
00:01:09,920 --> 00:01:12,960
so our questions follow why does apple

22
00:01:12,960 --> 00:01:15,439
need to refactor the code

23
00:01:15,439 --> 00:01:18,720
what are the new changes and what is the

24
00:01:18,720 --> 00:01:22,240
impact of these changes for us

25
00:01:22,240 --> 00:01:24,840
we may pay more attention to security

26
00:01:24,840 --> 00:01:26,240
impact

27
00:01:26,240 --> 00:01:28,880
i will try to answer these questions i

28
00:01:28,880 --> 00:01:30,400
hope this presentation will help you

29
00:01:30,400 --> 00:01:31,360
better understand

30
00:01:31,360 --> 00:01:33,439
the architecture and the security

31
00:01:33,439 --> 00:01:34,479
challenges

32
00:01:34,479 --> 00:01:40,240
of the apple wi-fi subsystem

33
00:01:40,240 --> 00:01:43,520
if we call the previous generation as

34
00:01:43,520 --> 00:01:47,360
version one we will see that version one

35
00:01:47,360 --> 00:01:50,479
and version two as family drivers

36
00:01:50,479 --> 00:01:53,840
play a very important role in apple's

37
00:01:53,840 --> 00:01:55,920
communication model

38
00:01:55,920 --> 00:01:59,200
they are responsible for managing almost

39
00:01:59,200 --> 00:02:02,399
all wi-fi communication functions here

40
00:02:02,399 --> 00:02:03,439
are some

41
00:02:03,439 --> 00:02:06,880
specific examples for example we need to

42
00:02:06,880 --> 00:02:10,239
set up and the manager ssid

43
00:02:10,239 --> 00:02:15,120
channel antenna rate something like that

44
00:02:16,560 --> 00:02:19,599
with these basic concepts in mind

45
00:02:19,599 --> 00:02:22,239
let's examine the subsystem from a

46
00:02:22,239 --> 00:02:23,040
higher

47
00:02:23,040 --> 00:02:26,239
perspective the above management

48
00:02:26,239 --> 00:02:27,200
features

49
00:02:27,200 --> 00:02:29,920
are common to the two generations of

50
00:02:29,920 --> 00:02:30,879
design

51
00:02:30,879 --> 00:02:34,800
but soon we will find some differences

52
00:02:34,800 --> 00:02:37,680
here i list some typical modules of

53
00:02:37,680 --> 00:02:38,640
version 1

54
00:02:38,640 --> 00:02:42,480
error from user mode to kernel mode

55
00:02:42,480 --> 00:02:45,599
for daemon we have airpod

56
00:02:45,599 --> 00:02:48,560
after entering the kernel we have the

57
00:02:48,560 --> 00:02:49,760
version one

58
00:02:49,760 --> 00:02:52,160
family kernel extensions and plug-in

59
00:02:52,160 --> 00:02:53,519
drivers

60
00:02:53,519 --> 00:02:56,959
in short version one is mainly designed

61
00:02:56,959 --> 00:02:58,159
to support

62
00:02:58,159 --> 00:03:02,480
apple airpod and related equipment

63
00:03:02,480 --> 00:03:05,280
we can also find this from the name of

64
00:03:05,280 --> 00:03:07,519
plugin drivers

65
00:03:07,519 --> 00:03:10,800
like like airport

66
00:03:10,800 --> 00:03:13,360
broadcom

67
00:03:15,280 --> 00:03:17,840
however with the development of mobile

68
00:03:17,840 --> 00:03:18,879
devices

69
00:03:18,879 --> 00:03:22,319
we can see that the the design

70
00:03:22,319 --> 00:03:25,760
concepts of the wi-fi subsystem has

71
00:03:25,760 --> 00:03:27,959
changed

72
00:03:27,959 --> 00:03:30,400
io80211 family version 2

73
00:03:30,400 --> 00:03:33,440
is mainly designed for communication and

74
00:03:33,440 --> 00:03:34,799
the data sharing

75
00:03:34,799 --> 00:03:37,920
between the new generation mobile-based

76
00:03:37,920 --> 00:03:39,840
apple devices

77
00:03:39,840 --> 00:03:43,040
and airpods no longer appears

78
00:03:43,040 --> 00:03:46,400
in the name of the kernel extensions

79
00:03:46,400 --> 00:03:49,200
it's all removed

80
00:03:50,159 --> 00:03:53,599
here are two examples we can see that

81
00:03:53,599 --> 00:03:56,720
the new subsystem is better spotted

82
00:03:56,720 --> 00:04:00,080
such as skywalk reverse engineering

83
00:04:00,080 --> 00:04:03,200
shows that many functions

84
00:04:03,200 --> 00:04:06,000
integrate at least the three branches

85
00:04:06,000 --> 00:04:08,640
which lead to different subsystem

86
00:04:08,640 --> 00:04:12,319
and the skywalk is a one that was

87
00:04:12,319 --> 00:04:16,238
recently introduced for new features

88
00:04:16,238 --> 00:04:19,279
sidecar was recently introduced

89
00:04:19,279 --> 00:04:21,679
as well

90
00:04:22,720 --> 00:04:26,080
two conclusions here number one family

91
00:04:26,080 --> 00:04:27,120
version 2

92
00:04:27,120 --> 00:04:30,320
is a brand new design for the

93
00:04:30,320 --> 00:04:33,520
mobile era number two

94
00:04:33,520 --> 00:04:37,280
family version 2 and w lan core

95
00:04:37,280 --> 00:04:39,600
integrated the original airpod broadcom

96
00:04:39,600 --> 00:04:40,639
drivers

97
00:04:40,639 --> 00:04:45,040
with more features and better logic

98
00:04:45,440 --> 00:04:47,600
one more thing is that please also keep

99
00:04:47,600 --> 00:04:48,639
in mind

100
00:04:48,639 --> 00:04:51,600
new features always mean new attack

101
00:04:51,600 --> 00:04:52,750
services

102
00:04:52,750 --> 00:04:55,600
[Music]

103
00:04:55,600 --> 00:04:58,960
if we want to further understand the

104
00:04:58,960 --> 00:05:03,280
wi-fi subsystem where should we start

105
00:05:03,280 --> 00:05:06,000
my approach is that i follow the two

106
00:05:06,000 --> 00:05:07,280
articles by

107
00:05:07,280 --> 00:05:11,280
jonathan these two articles try to build

108
00:05:11,280 --> 00:05:14,479
an wi-fi compatible framework from

109
00:05:14,479 --> 00:05:16,560
scratch

110
00:05:16,560 --> 00:05:19,120
through this project we can quickly

111
00:05:19,120 --> 00:05:21,039
become familiar with

112
00:05:21,039 --> 00:05:23,280
the user mode of the entire wi-fi

113
00:05:23,280 --> 00:05:24,479
subsystem

114
00:05:24,479 --> 00:05:28,400
and the interface of the kernel layer

115
00:05:28,400 --> 00:05:31,759
personally i have learned a lot from the

116
00:05:31,759 --> 00:05:35,360
compatible framework project

117
00:05:36,560 --> 00:05:40,080
seeing this you might see that i'm

118
00:05:40,080 --> 00:05:43,520
familiar with this matter because we did

119
00:05:43,520 --> 00:05:44,000
many

120
00:05:44,000 --> 00:05:47,680
similar projects on windows platform

121
00:05:47,680 --> 00:05:51,440
for example in order to combat

122
00:05:51,440 --> 00:05:54,479
root kits and kernel online hook we have

123
00:05:54,479 --> 00:05:55,199
tried such

124
00:05:55,199 --> 00:05:58,000
solutions in file system and the night

125
00:05:58,000 --> 00:05:58,400
work

126
00:05:58,400 --> 00:06:02,160
related functions yes you're right

127
00:06:02,160 --> 00:06:05,600
but before we start i would

128
00:06:05,600 --> 00:06:08,319
recommend it reading uh the following

129
00:06:08,319 --> 00:06:09,759
projects

130
00:06:09,759 --> 00:06:12,960
like intel wi-fi for mac os

131
00:06:12,960 --> 00:06:20,400
and udu wifi

132
00:06:20,400 --> 00:06:24,240
in the next section we will focus on

133
00:06:24,240 --> 00:06:26,319
attack surface and the security

134
00:06:26,319 --> 00:06:28,800
assessment

135
00:06:29,680 --> 00:06:32,400
first of all we should consider all

136
00:06:32,400 --> 00:06:33,039
inputs

137
00:06:33,039 --> 00:06:36,479
are potentially dangerous or we can call

138
00:06:36,479 --> 00:06:37,199
it

139
00:06:37,199 --> 00:06:40,639
zero trust for kernel

140
00:06:40,639 --> 00:06:43,039
the attack surface can be divided into

141
00:06:43,039 --> 00:06:43,680
at least

142
00:06:43,680 --> 00:06:47,280
two categories from remote

143
00:06:47,280 --> 00:06:50,080
and local firmware to operating system

144
00:06:50,080 --> 00:06:50,880
kernel

145
00:06:50,880 --> 00:06:54,000
and from daemon and framework

146
00:06:54,000 --> 00:06:57,520
to operating system kernel the third

147
00:06:57,520 --> 00:06:58,800
category belongs to

148
00:06:58,800 --> 00:07:02,319
some exceptions so i listed

149
00:07:02,319 --> 00:07:05,360
it as all all other handlers

150
00:07:05,360 --> 00:07:08,240
and the puzzles

151
00:07:09,919 --> 00:07:12,800
for the category from remote and

152
00:07:12,800 --> 00:07:14,240
firmware to kernel

153
00:07:14,240 --> 00:07:17,039
i have two examples the first one is

154
00:07:17,039 --> 00:07:20,960
from the research of google project zero

155
00:07:20,960 --> 00:07:24,400
gail biniami discovered a large number

156
00:07:24,400 --> 00:07:25,599
of vulnerabilities

157
00:07:25,599 --> 00:07:29,599
caused by handle event packet

158
00:07:29,599 --> 00:07:32,880
this function can be reached remotely

159
00:07:32,880 --> 00:07:36,479
the second example is handle firmware

160
00:07:36,479 --> 00:07:40,479
trap this function handles requests and

161
00:07:40,479 --> 00:07:44,000
events from the firmware they are all

162
00:07:44,000 --> 00:07:47,280
excellent attack surfaces

163
00:07:49,039 --> 00:07:51,919
for the other direction from user mode

164
00:07:51,919 --> 00:07:53,199
to kernel

165
00:07:53,199 --> 00:07:56,639
as early as 2007

166
00:07:56,639 --> 00:07:59,680
magazine only informed had an

167
00:07:59,680 --> 00:08:02,479
article about the set scan request

168
00:08:02,479 --> 00:08:03,919
vulnerability

169
00:08:03,919 --> 00:08:06,960
which is well worth reading

170
00:08:06,960 --> 00:08:10,960
in addition we also have examples for

171
00:08:10,960 --> 00:08:14,560
airport broadcom and ic the two links

172
00:08:14,560 --> 00:08:15,440
below

173
00:08:15,440 --> 00:08:18,479
are from zdi

174
00:08:21,280 --> 00:08:24,319
for the third category it covers a

175
00:08:24,319 --> 00:08:29,360
wide range for example awdl particle

176
00:08:29,360 --> 00:08:32,479
skywalk and the routing

177
00:08:32,479 --> 00:08:35,919
handle data packet these are the attack

178
00:08:35,919 --> 00:08:36,559
surfaces

179
00:08:36,559 --> 00:08:40,799
that i discovered during daily debugging

180
00:08:40,799 --> 00:08:43,679
behind them are often very complex

181
00:08:43,679 --> 00:08:46,159
designs

182
00:08:48,000 --> 00:08:51,360
two years ago i wrote a

183
00:08:51,360 --> 00:08:55,120
kernel extension called chemo

184
00:08:55,120 --> 00:08:58,399
in addition to monitoring features came

185
00:08:58,399 --> 00:08:58,959
on has

186
00:08:58,959 --> 00:09:02,320
an inline hook engine which can hook

187
00:09:02,320 --> 00:09:02,720
almost

188
00:09:02,720 --> 00:09:05,760
any function kernel function you want

189
00:09:05,760 --> 00:09:08,560
the source code can be found on github

190
00:09:08,560 --> 00:09:09,680
and last year

191
00:09:09,680 --> 00:09:13,279
i practiced mac os ipc and xpc

192
00:09:13,279 --> 00:09:15,519
communication monitoring based on this

193
00:09:15,519 --> 00:09:16,959
project

194
00:09:16,959 --> 00:09:20,839
here is a link to black hat arsenal

195
00:09:20,839 --> 00:09:23,839
2019

196
00:09:25,279 --> 00:09:27,760
and in order to learn more about the

197
00:09:27,760 --> 00:09:28,959
attack surfaces

198
00:09:28,959 --> 00:09:32,240
of the wi-fi subsystem i wrote

199
00:09:32,240 --> 00:09:34,959
several sniffers based on came on so

200
00:09:34,959 --> 00:09:36,080
that's why i introduced

201
00:09:36,080 --> 00:09:39,040
the came on to you this picture is one

202
00:09:39,040 --> 00:09:40,000
of them

203
00:09:40,000 --> 00:09:43,040
it can intercept all get and

204
00:09:43,040 --> 00:09:46,320
set requests sent to the wi-fi

205
00:09:46,320 --> 00:09:50,000
family drivers but because kimono has

206
00:09:50,000 --> 00:09:53,600
pre and post callback capabilities

207
00:09:53,600 --> 00:09:56,720
i can pass the input parameters and

208
00:09:56,720 --> 00:09:58,320
other useful information

209
00:09:58,320 --> 00:10:01,360
in the pre-callback handler as we can

210
00:10:01,360 --> 00:10:01,920
see

211
00:10:01,920 --> 00:10:05,040
i can capture process name

212
00:10:05,040 --> 00:10:08,959
type user buffer and the lens

213
00:10:08,959 --> 00:10:12,959
use a buffer lens i can also modify

214
00:10:12,959 --> 00:10:16,079
retain data of the target function in

215
00:10:16,079 --> 00:10:19,120
the post callback handler

216
00:10:19,120 --> 00:10:22,880
like the compatible framework project

217
00:10:22,880 --> 00:10:27,200
this sniffers helping me a lot

218
00:10:28,720 --> 00:10:32,480
so let's make a summary since i have

219
00:10:32,480 --> 00:10:35,440
chemo in hand i can perform code

220
00:10:35,440 --> 00:10:37,120
coverage analysis

221
00:10:37,120 --> 00:10:40,560
on the closed source drivers i implement

222
00:10:40,560 --> 00:10:42,240
several sniffers

223
00:10:42,240 --> 00:10:46,320
i can convert them to passive father

224
00:10:46,320 --> 00:10:48,959
for example i can do bit flipping of

225
00:10:48,959 --> 00:10:50,240
input parameters

226
00:10:50,240 --> 00:10:54,720
easily i have compatible frameworks

227
00:10:54,720 --> 00:10:57,839
so i can also convert them to active

228
00:10:57,839 --> 00:11:00,959
fuzzers in practice i found that

229
00:11:00,959 --> 00:11:03,360
combining the two fuzzing methods often

230
00:11:03,360 --> 00:11:04,160
has better

231
00:11:04,160 --> 00:11:06,719
results

232
00:11:08,640 --> 00:11:11,839
okay in the next section

233
00:11:11,839 --> 00:11:14,560
we will discuss the latest vulnerability

234
00:11:14,560 --> 00:11:15,519
cases

235
00:11:15,519 --> 00:11:19,040
that i found this year

236
00:11:22,399 --> 00:11:26,320
so far i have reported a total of

237
00:11:26,320 --> 00:11:28,800
18 vulnerabilities of the wi-fi

238
00:11:28,800 --> 00:11:31,040
subsystem to apple security

239
00:11:31,040 --> 00:11:33,920
and four of them were repaired repelled

240
00:11:33,920 --> 00:11:36,959
at the end of may

241
00:11:37,440 --> 00:11:41,440
the types of vulnerabilities covered

242
00:11:41,440 --> 00:11:45,120
hipaa floor hip data

243
00:11:45,120 --> 00:11:49,440
ob access kernel information disclosure

244
00:11:49,440 --> 00:11:51,120
stackable floor without cookie

245
00:11:51,120 --> 00:11:53,760
protection arbitrary kernel memory right

246
00:11:53,760 --> 00:11:57,519
and the integral floor

247
00:11:57,519 --> 00:12:00,800
it can be said that i have been

248
00:12:00,800 --> 00:12:04,560
dealing with all kind of stranger panics

249
00:12:04,560 --> 00:12:07,680
in the past few months

250
00:12:09,760 --> 00:12:13,040
i can classify this vulnerability

251
00:12:13,040 --> 00:12:16,240
from another perspective uh like number

252
00:12:16,240 --> 00:12:17,240
one

253
00:12:17,240 --> 00:12:21,120
vulnerabilities affecting olin

254
00:12:21,120 --> 00:12:24,320
version two and the vulnerabilities

255
00:12:24,320 --> 00:12:27,360
affecting both version 1 and version 2

256
00:12:27,360 --> 00:12:30,320
and the number 3 vulnerabilities

257
00:12:30,320 --> 00:12:31,519
affecting odin

258
00:12:31,519 --> 00:12:34,079
version 1.

259
00:12:36,839 --> 00:12:39,760
further if we deeply

260
00:12:39,760 --> 00:12:42,560
analysis the first category

261
00:12:42,560 --> 00:12:44,320
vulnerabilities affecting

262
00:12:44,320 --> 00:12:47,839
olin family in version two we can find

263
00:12:47,839 --> 00:12:48,560
that

264
00:12:48,560 --> 00:12:52,160
it can be disassembled as

265
00:12:52,160 --> 00:12:55,279
1.1 introduced link to v2

266
00:12:55,279 --> 00:12:58,639
when porting existing rerun features and

267
00:12:58,639 --> 00:13:02,720
1.2 introducing to way to when

268
00:13:02,720 --> 00:13:05,120
implementing new features we will

269
00:13:05,120 --> 00:13:08,399
discuss them one by one

270
00:13:09,200 --> 00:13:14,320
but let's start with cbe 2020 9834

271
00:13:14,320 --> 00:13:18,959
it belongs to category 1.1

272
00:13:18,959 --> 00:13:22,240
generally speaking when i run fuzzer

273
00:13:22,240 --> 00:13:25,200
for the first time usually nothing

274
00:13:25,200 --> 00:13:27,440
happens

275
00:13:27,440 --> 00:13:30,560
i i need to spend a lot of effort

276
00:13:30,560 --> 00:13:34,160
to find out what is the reason for

277
00:13:34,160 --> 00:13:37,360
not having panics maybe the target

278
00:13:37,360 --> 00:13:40,560
is really robust or maybe the

279
00:13:40,560 --> 00:13:43,360
code coverage rate of my father is too

280
00:13:43,360 --> 00:13:44,800
low

281
00:13:44,800 --> 00:13:48,000
but this time this time was different

282
00:13:48,000 --> 00:13:51,360
i got a panic report at the same time i

283
00:13:51,360 --> 00:13:54,959
rang the fuzzer and after an hour

284
00:13:54,959 --> 00:13:58,959
there were too many reports to handle

285
00:13:59,680 --> 00:14:02,959
i have four cases here um

286
00:14:02,959 --> 00:14:06,720
so to to save time let me escape the

287
00:14:06,720 --> 00:14:10,079
case one case two because they are

288
00:14:10,079 --> 00:14:13,680
uh or non-point d reference issue

289
00:14:13,680 --> 00:14:17,519
in case three the last panning clog

290
00:14:17,519 --> 00:14:20,720
seems pretty good it's called stack

291
00:14:20,720 --> 00:14:24,240
is clear and the instruction that caused

292
00:14:24,240 --> 00:14:29,199
the crash seems uh full of hope

293
00:14:29,279 --> 00:14:33,600
seems we can control the rex register

294
00:14:34,560 --> 00:14:38,000
then i started to tailor my

295
00:14:38,000 --> 00:14:41,839
fuzzer i narrowed down

296
00:14:41,839 --> 00:14:45,279
the scope step by step until i

297
00:14:45,279 --> 00:14:49,839
found the routing set scan request

298
00:14:49,839 --> 00:14:52,720
in the output of the adder hex three on

299
00:14:52,720 --> 00:14:53,760
the right

300
00:14:53,760 --> 00:15:00,240
we can see that on lies 34 and 35

301
00:15:00,240 --> 00:15:03,360
the input from user mode should not be

302
00:15:03,360 --> 00:15:07,120
greater than 9d4 this is a very large

303
00:15:07,120 --> 00:15:08,800
input structure

304
00:15:08,800 --> 00:15:10,480
to understand the root cause of the

305
00:15:10,480 --> 00:15:13,199
problem we need to figure out the

306
00:15:13,199 --> 00:15:16,800
detail of the structure so one challenge

307
00:15:16,800 --> 00:15:21,199
i faced at the time was whether

308
00:15:21,199 --> 00:15:23,600
this input structure could be clarified

309
00:15:23,600 --> 00:15:24,639
through

310
00:15:24,639 --> 00:15:28,800
uh like remove remote engineering

311
00:15:29,759 --> 00:15:32,959
soon i found a method

312
00:15:32,959 --> 00:15:36,160
reverse engineering is feasible

313
00:15:36,160 --> 00:15:38,240
i found debugging information including

314
00:15:38,240 --> 00:15:40,160
set scan request

315
00:15:40,160 --> 00:15:43,199
here in which

316
00:15:43,199 --> 00:15:46,639
a lot of readable strings were submitted

317
00:15:46,639 --> 00:15:47,839
to the function

318
00:15:47,839 --> 00:15:50,959
cc log string for example

319
00:15:50,959 --> 00:15:55,440
on the right side we can see that

320
00:15:55,440 --> 00:16:00,079
uh the offset 34

321
00:16:00,079 --> 00:16:03,519
of the input structure should be

322
00:16:03,519 --> 00:16:07,279
a member called scan type

323
00:16:07,279 --> 00:16:11,360
and the 44 should be a member called

324
00:16:11,360 --> 00:16:14,480
number of channels so so we can have a

325
00:16:14,480 --> 00:16:16,240
table

326
00:16:16,240 --> 00:16:19,279
we can make a table

327
00:16:20,639 --> 00:16:24,079
as the program continue to execute

328
00:16:24,079 --> 00:16:26,720
we will continue we will come to a

329
00:16:26,720 --> 00:16:27,759
routine

330
00:16:27,759 --> 00:16:30,959
called field scan parameters

331
00:16:30,959 --> 00:16:33,519
this function is responsible for

332
00:16:33,519 --> 00:16:34,720
extracting

333
00:16:34,720 --> 00:16:37,519
external parameters and feeding the

334
00:16:37,519 --> 00:16:38,240
input

335
00:16:38,240 --> 00:16:42,160
into an internal structure

336
00:16:42,160 --> 00:16:44,639
the data structure on the left is

337
00:16:44,639 --> 00:16:45,680
positive by

338
00:16:45,680 --> 00:16:49,440
callers and we can treat it as

339
00:16:49,440 --> 00:16:52,880
untrusted or tinted data

340
00:16:52,880 --> 00:16:55,440
the data structure on the right is the

341
00:16:55,440 --> 00:16:57,040
internal data structure of

342
00:16:57,040 --> 00:17:00,800
field scan parameter which is merge

343
00:17:00,800 --> 00:17:05,839
external inputs

344
00:17:06,000 --> 00:17:09,359
i audited each member's

345
00:17:09,359 --> 00:17:12,880
scoping process one by one until i saw

346
00:17:12,880 --> 00:17:15,199
the code on the right

347
00:17:15,199 --> 00:17:18,480
i found a fatal arrow

348
00:17:18,480 --> 00:17:20,799
on the first of the line of the picture

349
00:17:20,799 --> 00:17:21,640
which is

350
00:17:21,640 --> 00:17:26,720
179 of the era hex record

351
00:17:26,720 --> 00:17:30,080
here the program

352
00:17:30,080 --> 00:17:33,120
extracts data from the

353
00:17:33,120 --> 00:17:36,799
44 offset of the input buffer

354
00:17:36,799 --> 00:17:39,120
combining the previous knowledge we know

355
00:17:39,120 --> 00:17:39,919
that

356
00:17:39,919 --> 00:17:43,760
the private symbol of this

357
00:17:43,760 --> 00:17:47,280
member is number of channels

358
00:17:47,280 --> 00:17:50,640
then the value of number of channels

359
00:17:50,640 --> 00:17:54,240
will be stored at the offset 3c

360
00:17:54,240 --> 00:17:58,799
okay 3c of the internal structure

361
00:17:58,799 --> 00:18:03,440
the k point is the do well loop

362
00:18:03,679 --> 00:18:06,960
that starts at 185

363
00:18:06,960 --> 00:18:10,400
the loop starts at zero and

364
00:18:10,400 --> 00:18:13,440
accumulates until it equals

365
00:18:13,440 --> 00:18:17,039
number of channels here so

366
00:18:17,039 --> 00:18:20,320
is there an upper limit for

367
00:18:20,320 --> 00:18:23,440
number of channels unfortunately i

368
00:18:23,440 --> 00:18:26,559
don't see such logic in the code in

369
00:18:26,559 --> 00:18:29,840
other words the

370
00:18:29,840 --> 00:18:33,360
external input number of channels

371
00:18:33,360 --> 00:18:35,840
determines the number of execution of

372
00:18:35,840 --> 00:18:37,520
the dual loop

373
00:18:37,520 --> 00:18:40,960
which can be zero or can be

374
00:18:40,960 --> 00:18:43,520
hundred thousand but you know henry

375
00:18:43,520 --> 00:18:44,480
thousand is

376
00:18:44,480 --> 00:18:49,200
absolutely unacceptable it's hipaa floor

377
00:18:49,200 --> 00:18:52,720
and by the way there is an interesting

378
00:18:52,720 --> 00:18:56,559
fact is in english code on

379
00:18:56,559 --> 00:18:59,600
line 188 we can see that

380
00:18:59,600 --> 00:19:02,320
when the code reads data from the input

381
00:19:02,320 --> 00:19:03,120
buffer

382
00:19:03,120 --> 00:19:07,039
it will escape c bytes each time

383
00:19:07,039 --> 00:19:10,799
this detail is actually very important

384
00:19:10,799 --> 00:19:13,760
when writing exploit code we need to set

385
00:19:13,760 --> 00:19:14,559
the

386
00:19:14,559 --> 00:19:18,720
memory layout according to this feature

387
00:19:20,640 --> 00:19:24,160
after having all these analysis we

388
00:19:24,160 --> 00:19:26,799
finally got a sense of this hippo floor

389
00:19:26,799 --> 00:19:28,400
vulnerability

390
00:19:28,400 --> 00:19:31,200
in the input buffer on the left if we

391
00:19:31,200 --> 00:19:33,440
lay out the memory like this

392
00:19:33,440 --> 00:19:37,039
we will have full right capability to

393
00:19:37,039 --> 00:19:39,440
the target internal structure

394
00:19:39,440 --> 00:19:42,559
and because number of channels can be

395
00:19:42,559 --> 00:19:45,919
fully manipulated so we can precisely

396
00:19:45,919 --> 00:19:47,280
control the

397
00:19:47,280 --> 00:19:52,960
number of bytes overflowed

398
00:19:52,960 --> 00:19:56,480
okay let me summarize the root cause of

399
00:19:56,480 --> 00:19:57,720
cve 2020

400
00:19:57,720 --> 00:20:01,280
9834 the vulnerable function lacks the

401
00:20:01,280 --> 00:20:02,320
necessary checks

402
00:20:02,320 --> 00:20:04,720
for number of channels in the input

403
00:20:04,720 --> 00:20:05,679
parameter

404
00:20:05,679 --> 00:20:08,720
input structure which leads to

405
00:20:08,720 --> 00:20:12,320
auto bound operations autobahn's

406
00:20:12,320 --> 00:20:15,600
operation has two place places source

407
00:20:15,600 --> 00:20:18,559
and the destination buffer for source

408
00:20:18,559 --> 00:20:19,600
buffer this means

409
00:20:19,600 --> 00:20:22,000
autobahn access and for destination

410
00:20:22,000 --> 00:20:24,480
buffer this means

411
00:20:24,480 --> 00:20:27,360
people were right the quality of this

412
00:20:27,360 --> 00:20:30,000
vulnerability is pretty good because the

413
00:20:30,000 --> 00:20:33,200
right primitive is relatively complete

414
00:20:33,200 --> 00:20:36,080
and for vulnerability with incomplete

415
00:20:36,080 --> 00:20:37,200
right permittive

416
00:20:37,200 --> 00:20:41,440
please refer to my previous write up

417
00:20:43,760 --> 00:20:46,960
so at this point we can

418
00:20:46,960 --> 00:20:50,080
write the analysis report and even

419
00:20:50,080 --> 00:20:53,440
exploit code but there are still some

420
00:20:53,440 --> 00:20:57,039
unanswered questions uh such as

421
00:20:57,039 --> 00:20:59,280
why does the right committee read from

422
00:20:59,280 --> 00:21:00,559
the

423
00:21:00,559 --> 00:21:03,840
inputs average z bytes and what is the

424
00:21:03,840 --> 00:21:04,720
remaining

425
00:21:04,720 --> 00:21:07,120
meaning of the remaining fields in the

426
00:21:07,120 --> 00:21:09,120
input structure

427
00:21:09,120 --> 00:21:12,559
uh usually if i i have a

428
00:21:12,559 --> 00:21:15,600
new task coming i will leave a

429
00:21:15,600 --> 00:21:18,559
to-do list here and maybe i will not

430
00:21:18,559 --> 00:21:20,240
touch it for years

431
00:21:20,240 --> 00:21:23,120
but this year is really special working

432
00:21:23,120 --> 00:21:23,919
at home is

433
00:21:23,919 --> 00:21:28,799
boring to me so i found this

434
00:21:28,880 --> 00:21:31,919
the apple sdk from mac os

435
00:21:31,919 --> 00:21:37,039
x 10.1 to mac os 10.15

436
00:21:37,039 --> 00:21:39,600
it is interesting that the sdk header

437
00:21:39,600 --> 00:21:40,799
files of the

438
00:21:40,799 --> 00:21:44,080
wi-fi subsystem appeared briefly on

439
00:21:44,080 --> 00:21:48,400
the ten point four five and six

440
00:21:48,400 --> 00:21:52,400
things uh 10.7 these files

441
00:21:52,400 --> 00:21:55,679
have been removed uh so we have a

442
00:21:55,679 --> 00:21:58,880
very small window to pick at what the

443
00:21:58,880 --> 00:22:02,080
six file contains

444
00:22:03,919 --> 00:22:06,960
and next i found that i found that

445
00:22:06,960 --> 00:22:10,960
there are some projects that did contain

446
00:22:10,960 --> 00:22:15,440
more recent apple wi-fi sdk header files

447
00:22:15,440 --> 00:22:19,520
like high sierra or even katrina

448
00:22:19,520 --> 00:22:23,360
so why is apple's sdk code

449
00:22:23,360 --> 00:22:27,200
leaked um not really

450
00:22:27,200 --> 00:22:30,400
after comparison i found that the code

451
00:22:30,400 --> 00:22:32,640
was not from apple

452
00:22:32,640 --> 00:22:35,600
they are more like the communities

453
00:22:35,600 --> 00:22:38,240
reverse knowledge sharing

454
00:22:38,240 --> 00:22:41,200
in order to write compatible frameworks

455
00:22:41,200 --> 00:22:42,720
and better spot

456
00:22:42,720 --> 00:22:46,320
network devices they reversed

457
00:22:46,320 --> 00:22:49,360
a large number of kernel drivers uh

458
00:22:49,360 --> 00:22:53,520
for example the interfaces here

459
00:22:53,520 --> 00:22:56,000
are all from reverse engineering of

460
00:22:56,000 --> 00:22:56,720
family

461
00:22:56,720 --> 00:22:59,919
kernel extensions

462
00:23:00,000 --> 00:23:02,960
well maybe i can also contribute to the

463
00:23:02,960 --> 00:23:04,240
community

464
00:23:04,240 --> 00:23:08,400
this is the 18 interface added by

465
00:23:08,400 --> 00:23:11,760
mac os bixer this interface

466
00:23:11,760 --> 00:23:14,240
represents the latest changes in the

467
00:23:14,240 --> 00:23:15,360
platform

468
00:23:15,360 --> 00:23:18,480
so together we can make the community

469
00:23:18,480 --> 00:23:23,840
community a better place

470
00:23:24,320 --> 00:23:26,880
without further ado let's go back to the

471
00:23:26,880 --> 00:23:28,720
vulnerability

472
00:23:28,720 --> 00:23:31,840
with the support of the apple sdk we can

473
00:23:31,840 --> 00:23:34,320
get all the necessary information

474
00:23:34,320 --> 00:23:37,679
including unknown fields

475
00:23:37,679 --> 00:23:40,799
the previews on the question was uh can

476
00:23:40,799 --> 00:23:41,279
also

477
00:23:41,279 --> 00:23:44,640
answered the reason for reading every c

478
00:23:44,640 --> 00:23:49,039
bytes is because there is a substruct

479
00:23:49,039 --> 00:23:52,960
array in the definition of scanned data

480
00:23:52,960 --> 00:23:55,600
and the wonderful routing olin wants to

481
00:23:55,600 --> 00:23:56,240
copy

482
00:23:56,240 --> 00:23:59,279
the channel member

483
00:23:59,279 --> 00:24:02,720
channel members in addition we can see

484
00:24:02,720 --> 00:24:06,960
that here here is the definition called

485
00:24:06,960 --> 00:24:10,640
max channels which is 64

486
00:24:10,640 --> 00:24:14,480
inside so the the wonderbar code does

487
00:24:14,480 --> 00:24:15,360
not follow the

488
00:24:15,360 --> 00:24:19,840
requirements here

489
00:24:20,640 --> 00:24:23,760
i think you may have a similar questions

490
00:24:23,760 --> 00:24:26,960
as i did a few months ago why

491
00:24:26,960 --> 00:24:29,919
why can such an obvious vulnerability

492
00:24:29,919 --> 00:24:31,039
survive to

493
00:24:31,039 --> 00:24:33,840
2020

494
00:24:35,840 --> 00:24:38,400
the answer is that this vulnerability

495
00:24:38,400 --> 00:24:40,320
was introduced into v2

496
00:24:40,320 --> 00:24:43,360
when porting the existing feature of v1

497
00:24:43,360 --> 00:24:46,880
and there is no problem with v1 related

498
00:24:46,880 --> 00:24:48,080
function

499
00:24:48,080 --> 00:24:52,080
we can see in the picture on the right

500
00:24:52,080 --> 00:24:54,080
there is a limit on the size of the

501
00:24:54,080 --> 00:24:56,720
array on mac os mojave

502
00:24:56,720 --> 00:25:00,799
but for unknown readings io8

503
00:25:00,799 --> 00:25:03,679
family version 2 removed the binary

504
00:25:03,679 --> 00:25:05,760
check

505
00:25:05,760 --> 00:25:08,400
so this is a brand new vulnerability

506
00:25:08,400 --> 00:25:09,120
introduced

507
00:25:09,120 --> 00:25:12,080
by developers

508
00:25:13,360 --> 00:25:15,760
a more a more interesting fact is that

509
00:25:15,760 --> 00:25:17,520
this is not the first time

510
00:25:17,520 --> 00:25:20,159
that the set scan request function is

511
00:25:20,159 --> 00:25:21,200
vulnerable

512
00:25:21,200 --> 00:25:24,559
if you have uh read the

513
00:25:24,559 --> 00:25:28,880
the article osx

514
00:25:28,880 --> 00:25:32,000
kernel mode exploitation in a weekend

515
00:25:32,000 --> 00:25:35,120
before you will find this function was

516
00:25:35,120 --> 00:25:38,240
attacked 13 years ago so

517
00:25:38,240 --> 00:25:41,760
if other had a time machine

518
00:25:41,760 --> 00:25:44,799
at that time i would suggest

519
00:25:44,799 --> 00:25:50,000
flying to 2020. this year is so special

520
00:25:50,000 --> 00:25:53,120
he will be surprised

521
00:25:53,760 --> 00:25:56,720
okay the next case is also interesting

522
00:25:56,720 --> 00:26:01,120
it belongs to the category 1.2

523
00:26:01,600 --> 00:26:04,799
um i have three pictures here

524
00:26:04,799 --> 00:26:08,840
the first picture mingling says

525
00:26:08,840 --> 00:26:11,520
um the driver

526
00:26:11,520 --> 00:26:15,200
allocates over 200 bytes

527
00:26:15,200 --> 00:26:19,279
to a buffer called the trapping four

528
00:26:19,279 --> 00:26:21,440
but please note that there is no

529
00:26:21,440 --> 00:26:23,520
initialization

530
00:26:23,520 --> 00:26:27,120
at this stage in the second picture

531
00:26:27,120 --> 00:26:29,919
on the right we finally see the

532
00:26:29,919 --> 00:26:31,440
initialization process

533
00:26:31,440 --> 00:26:35,279
of this buffer a routine named

534
00:26:35,279 --> 00:26:38,480
handle firmware trap will fill in the

535
00:26:38,480 --> 00:26:39,200
trap

536
00:26:39,200 --> 00:26:42,080
infor with information returned by the

537
00:26:42,080 --> 00:26:43,600
phone well

538
00:26:43,600 --> 00:26:46,799
the third picture actually sends

539
00:26:46,799 --> 00:26:50,320
this information to the caller

540
00:26:50,320 --> 00:26:53,360
in short we have three functions and the

541
00:26:53,360 --> 00:26:54,720
three steps

542
00:26:54,720 --> 00:26:58,400
allocation initialization and the

543
00:26:58,400 --> 00:27:01,440
extraction so my question is

544
00:27:01,440 --> 00:27:04,960
can you sport the hidden vulnerability

545
00:27:04,960 --> 00:27:07,840
among them

546
00:27:09,360 --> 00:27:13,360
yeah i know uh boring question

547
00:27:13,360 --> 00:27:17,520
let me speed up i only have 40 minutes

548
00:27:17,520 --> 00:27:21,120
um this scopes make an assumption

549
00:27:21,120 --> 00:27:24,399
the expected execution order is

550
00:27:24,399 --> 00:27:28,080
step one two and then three

551
00:27:28,080 --> 00:27:31,200
so my question can actually be changed

552
00:27:31,200 --> 00:27:32,159
to

553
00:27:32,159 --> 00:27:34,480
is it possible to extract the

554
00:27:34,480 --> 00:27:36,000
information before

555
00:27:36,000 --> 00:27:39,440
it is initialized

556
00:27:40,320 --> 00:27:43,679
the answer is yes

557
00:27:43,679 --> 00:27:47,440
it is possible the leaked heap data can

558
00:27:47,440 --> 00:27:51,039
execute 200 bytes including

559
00:27:51,039 --> 00:27:54,159
kernel data function pointers

560
00:27:54,159 --> 00:27:56,399
and we can see a large number of kernel

561
00:27:56,399 --> 00:27:57,360
objects

562
00:27:57,360 --> 00:28:02,559
linked on the right

563
00:28:02,559 --> 00:28:05,600
um we need to beat uh

564
00:28:05,600 --> 00:28:09,679
kasra when writing exploit code

565
00:28:09,679 --> 00:28:13,520
i also tried it in the figure

566
00:28:13,520 --> 00:28:17,279
we can see that the destination

567
00:28:17,279 --> 00:28:20,240
is the buffer to be returned to the user

568
00:28:20,240 --> 00:28:21,360
mode

569
00:28:21,360 --> 00:28:24,880
and the source is trapping for

570
00:28:24,880 --> 00:28:28,559
buffer and at here

571
00:28:28,559 --> 00:28:30,559
the base address of the trapping per

572
00:28:30,559 --> 00:28:33,039
buffer has been leaked

573
00:28:33,039 --> 00:28:36,159
through hip finishing you can see here

574
00:28:36,159 --> 00:28:40,240
this address this data is actually

575
00:28:40,240 --> 00:28:43,039
the the base address of trapping for

576
00:28:43,039 --> 00:28:45,039
buffer

577
00:28:45,039 --> 00:28:48,720
so and then kasr will be

578
00:28:48,720 --> 00:28:52,799
will become meaningless

579
00:28:54,960 --> 00:28:58,320
okay i have a demo of this one reability

580
00:28:58,320 --> 00:28:59,520
please let me

581
00:28:59,520 --> 00:29:02,799
play the video

582
00:29:09,120 --> 00:29:12,720
okay um

583
00:29:12,720 --> 00:29:15,679
the operating system is unpatched it's a

584
00:29:15,679 --> 00:29:16,159
it's a

585
00:29:16,159 --> 00:29:22,000
older version and let me run the exploit

586
00:29:24,880 --> 00:29:28,080
yeah we can see a large number of

587
00:29:28,080 --> 00:29:30,240
kernel functions function pointers

588
00:29:30,240 --> 00:29:32,559
leaked

589
00:29:33,279 --> 00:29:41,840
they are all kernel objects

590
00:29:44,080 --> 00:29:46,480
okay um the following two

591
00:29:46,480 --> 00:29:48,000
vulnerabilities belongs

592
00:29:48,000 --> 00:29:51,440
belong to the second category um

593
00:29:51,440 --> 00:29:54,640
let me make the the long story short

594
00:29:54,640 --> 00:29:58,559
i found this problem both

595
00:29:58,559 --> 00:30:01,840
on old and new family drivers

596
00:30:01,840 --> 00:30:05,039
the root cause is still related to

597
00:30:05,039 --> 00:30:09,360
improved validation

598
00:30:09,360 --> 00:30:12,000
these are the panic logs of the two

599
00:30:12,000 --> 00:30:13,120
versions

600
00:30:13,120 --> 00:30:16,799
we can see when i passing

601
00:30:16,799 --> 00:30:20,000
for example database

602
00:30:20,000 --> 00:30:23,279
the function set scanning state

603
00:30:23,279 --> 00:30:28,080
will read out of bounds

604
00:30:30,000 --> 00:30:34,159
this vulnerability can be used to detect

605
00:30:34,159 --> 00:30:37,360
hip data or memory layout

606
00:30:37,360 --> 00:30:40,480
but i i have to see

607
00:30:40,480 --> 00:30:43,440
its quality cannot be compared with the

608
00:30:43,440 --> 00:30:46,159
previous one

609
00:30:46,640 --> 00:30:49,760
okay the third category is vulnerability

610
00:30:49,760 --> 00:30:51,600
affecting only one

611
00:30:51,600 --> 00:30:55,039
in other words version 2

612
00:30:55,039 --> 00:30:58,480
fixes wonderful functions

613
00:30:58,480 --> 00:31:00,640
unfortunately these important

614
00:31:00,640 --> 00:31:01,519
improvements

615
00:31:01,519 --> 00:31:03,760
have not been synchronized with other

616
00:31:03,760 --> 00:31:05,679
system platforms

617
00:31:05,679 --> 00:31:07,760
so we can use them to attack targets

618
00:31:07,760 --> 00:31:08,960
like the

619
00:31:08,960 --> 00:31:12,000
latest mac os mojave and the macos high

620
00:31:12,000 --> 00:31:14,000
sierra

621
00:31:14,000 --> 00:31:18,320
apple plans to address this case

622
00:31:18,320 --> 00:31:23,439
in a future security update

623
00:31:27,440 --> 00:31:30,320
in addition to the above vulnerabilities

624
00:31:30,320 --> 00:31:30,960
i

625
00:31:30,960 --> 00:31:34,080
i have at least a dozen new zero days

626
00:31:34,080 --> 00:31:35,519
waiting to be fixed

627
00:31:35,519 --> 00:31:38,880
um but i cannot share

628
00:31:38,880 --> 00:31:41,360
their details this time uh maybe in the

629
00:31:41,360 --> 00:31:42,480
future i will

630
00:31:42,480 --> 00:31:45,120
share this interesting and powerful

631
00:31:45,120 --> 00:31:47,200
vulnerabilities with you through

632
00:31:47,200 --> 00:31:50,559
blog um let's work together to

633
00:31:50,559 --> 00:31:53,519
protect the endpoint security of apple

634
00:31:53,519 --> 00:31:54,799
platforms

635
00:31:54,799 --> 00:31:57,039
thanks

636
00:31:58,159 --> 00:32:01,679
um i mentioned uh i

637
00:32:01,679 --> 00:32:05,360
implemented several wi-fi fuzzers

638
00:32:05,360 --> 00:32:08,559
so let's say how it works on

639
00:32:08,559 --> 00:32:11,600
mac os bixer

640
00:32:11,840 --> 00:32:17,039
please let me play the video

641
00:32:26,840 --> 00:32:29,840
okay

642
00:32:30,799 --> 00:32:33,679
yes this video

643
00:32:37,519 --> 00:32:40,960
this is a target machine

644
00:32:41,440 --> 00:32:45,120
and the os is the latest macos fixer

645
00:32:45,120 --> 00:32:48,240
we can say the the build number is

646
00:32:48,240 --> 00:32:51,519
uh 430b

647
00:32:51,519 --> 00:32:54,399
is the latest one

648
00:32:54,840 --> 00:32:59,279
and let me run my fuzzer

649
00:32:59,279 --> 00:33:01,519
yes

650
00:33:02,480 --> 00:33:05,840
okay after a few seconds the system

651
00:33:05,840 --> 00:33:07,279
crashed

652
00:33:07,279 --> 00:33:10,399
um this is the

653
00:33:10,399 --> 00:33:13,840
this is the target machine and on the

654
00:33:13,840 --> 00:33:14,240
left

655
00:33:14,240 --> 00:33:17,760
set is the rdb remote debugger

656
00:33:17,760 --> 00:33:20,720
you can see uh the current instruction

657
00:33:20,720 --> 00:33:22,399
shows that

658
00:33:22,399 --> 00:33:25,840
this is a panic

659
00:33:26,399 --> 00:33:28,639
okay

660
00:33:37,279 --> 00:33:40,559
okay yeah another interesting

661
00:33:40,559 --> 00:33:43,760
uh question is

662
00:33:43,760 --> 00:33:47,519
does uh do this vulnerabilities

663
00:33:47,519 --> 00:33:50,559
uh affect ios

664
00:33:50,559 --> 00:33:53,840
um the answer is yes again

665
00:33:53,840 --> 00:33:56,880
um we just need to add an

666
00:33:56,880 --> 00:34:01,600
entitlement to the poc

667
00:34:02,960 --> 00:34:07,360
like com.apple dot wlan

668
00:34:07,360 --> 00:34:10,879
authentication dot authentication

669
00:34:11,199 --> 00:34:15,399
and then for cve 2020

670
00:34:15,399 --> 00:34:19,839
9834 we can get such a panic

671
00:34:19,839 --> 00:34:23,520
on ios the version number is

672
00:34:23,520 --> 00:34:30,399
iphone os 13 view number is 1750

673
00:34:30,480 --> 00:34:35,839
it's a hip override vulnerability

674
00:34:41,918 --> 00:34:44,960
okay let's move to the last section of

675
00:34:44,960 --> 00:34:49,839
today's presentation

676
00:34:52,560 --> 00:34:55,119
takeaways

677
00:34:56,320 --> 00:34:59,040
the first point is related to the

678
00:34:59,040 --> 00:35:00,240
architecture

679
00:35:00,240 --> 00:35:04,160
of the wi-fi subsystem family version 2

680
00:35:04,160 --> 00:35:07,280
and the wlan core

681
00:35:07,280 --> 00:35:10,240
integrates the original airpods broadcom

682
00:35:10,240 --> 00:35:11,119
drivers

683
00:35:11,119 --> 00:35:14,839
with more features and more reasonable

684
00:35:14,839 --> 00:35:18,720
logic the second i want to say is

685
00:35:18,720 --> 00:35:21,200
new features always mean new attack

686
00:35:21,200 --> 00:35:23,119
services

687
00:35:23,119 --> 00:35:26,880
and number three the apple sdk

688
00:35:26,880 --> 00:35:30,880
helped me a lot for me combining reverse

689
00:35:30,880 --> 00:35:31,839
engineering

690
00:35:31,839 --> 00:35:36,720
and the apple sdk means a better life

691
00:35:36,720 --> 00:35:40,480
the last one we reviewed several brand

692
00:35:40,480 --> 00:35:41,760
new

693
00:35:41,760 --> 00:35:44,960
kernel vulnerabilities and in the future

694
00:35:44,960 --> 00:35:49,520
we will have some more interesting cases

695
00:35:50,800 --> 00:35:53,200
time's up thank you very much thank you

696
00:35:53,200 --> 00:35:55,680
for your time

697
00:35:56,839 --> 00:35:58,960
thanks

698
00:35:58,960 --> 00:36:02,320
um hi uh hello everyone welcome to

699
00:36:02,320 --> 00:36:06,240
my presentation um

700
00:36:06,320 --> 00:36:10,320
uh yes we have one question is about my

701
00:36:10,320 --> 00:36:14,880
uh buzzing method

702
00:36:15,680 --> 00:36:19,359
okay yes my fuzzing method can

703
00:36:19,359 --> 00:36:22,560
consist of three parts

704
00:36:22,560 --> 00:36:25,680
the first one is i wrote

705
00:36:25,680 --> 00:36:28,720
my own i o

706
00:36:28,720 --> 00:36:32,880
apple h0211 compatible framework

707
00:36:32,880 --> 00:36:35,359
according to the method of jonathan this

708
00:36:35,359 --> 00:36:37,480
project can be

709
00:36:37,480 --> 00:36:41,599
transformed into an active facet

710
00:36:41,599 --> 00:36:45,200
and i implement a

711
00:36:45,200 --> 00:36:49,200
wi-fi request receiver based on chemo

712
00:36:49,200 --> 00:36:51,440
so this project can either be

713
00:36:51,440 --> 00:36:52,480
transformed to

714
00:36:52,480 --> 00:36:55,200
a passive budget for example i can do

715
00:36:55,200 --> 00:36:56,880
bit flipping

716
00:36:56,880 --> 00:37:00,720
for the whole subsystem and

717
00:37:00,720 --> 00:37:04,240
i also implement a simple

718
00:37:04,240 --> 00:37:06,400
code coverage analysis tool based on

719
00:37:06,400 --> 00:37:08,400
chemos in a hook engine

720
00:37:08,400 --> 00:37:11,839
so right now the current version is

721
00:37:11,839 --> 00:37:13,040
still very basic

722
00:37:13,040 --> 00:37:15,680
uh the current version works at the

723
00:37:15,680 --> 00:37:16,640
function level

724
00:37:16,640 --> 00:37:19,920
and supports about the henries of i o

725
00:37:19,920 --> 00:37:21,440
control handlers

726
00:37:21,440 --> 00:37:26,160
and abnormal exit branches

727
00:37:26,160 --> 00:37:29,359
but this this version already helped me

728
00:37:29,359 --> 00:37:34,000
find the kernel vulnerabilities so

729
00:37:35,040 --> 00:37:38,700
yes i i combined

730
00:37:38,700 --> 00:37:41,359
[Music]

731
00:37:41,359 --> 00:37:45,280
two different ways together and

732
00:37:45,280 --> 00:37:48,880
i have a a simple code coverage

733
00:37:48,880 --> 00:37:51,839
analysis solution

734
00:37:53,599 --> 00:38:05,839
yes that's my method

735
00:38:13,280 --> 00:38:18,890
okay um okay just uh

736
00:38:18,890 --> 00:38:22,040
[Music]

737
00:38:23,359 --> 00:38:26,240
another thing i want to mention is that

738
00:38:26,240 --> 00:38:27,680
uh

739
00:38:27,680 --> 00:38:32,480
um in this slides i

740
00:38:32,480 --> 00:38:35,520
i have three series

741
00:38:35,520 --> 00:38:40,880
um cbe 2020 9832 is related to

742
00:38:40,880 --> 00:38:44,960
kernel extension um io

743
00:38:44,960 --> 00:38:48,400
wi-fi family version 2 and

744
00:38:48,400 --> 00:38:52,720
the cv number 9833 is related to the

745
00:38:52,720 --> 00:38:57,040
underlying plug-in drivers

746
00:38:57,520 --> 00:39:02,160
the apple bcmw bus interface pcie

747
00:39:02,160 --> 00:39:06,560
and the the cv number 9834 is related to

748
00:39:06,560 --> 00:39:08,240
the function of

749
00:39:08,240 --> 00:39:11,599
apple bcm wn

750
00:39:11,599 --> 00:39:14,720
w lan core so

751
00:39:14,720 --> 00:39:17,119
in other words the entire kernel cost

752
00:39:17,119 --> 00:39:19,200
stack of

753
00:39:19,200 --> 00:39:23,119
i o wi-fi version 2 has been

754
00:39:23,119 --> 00:39:26,960
found to have problems so

755
00:39:26,960 --> 00:39:30,240
so so to me i think there's

756
00:39:30,240 --> 00:39:34,319
still room for improvement

757
00:39:40,839 --> 00:39:43,839
yes

758
00:39:45,839 --> 00:39:48,960
that that's it um thank you

759
00:39:48,960 --> 00:39:51,960
for your questions um and thanks for

760
00:39:51,960 --> 00:39:54,960
watching

