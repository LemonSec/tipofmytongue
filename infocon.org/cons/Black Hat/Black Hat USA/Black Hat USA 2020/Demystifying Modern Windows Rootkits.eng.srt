1
00:00:03,930 --> 00:00:14,369
[Music]

2
00:00:15,040 --> 00:00:17,760
thanks for coming out to my talk

3
00:00:17,760 --> 00:00:20,480
let's start with who am i well i'm 18

4
00:00:20,480 --> 00:00:21,600
years old

5
00:00:21,600 --> 00:00:23,199
i'm a sophomore at the rochester

6
00:00:23,199 --> 00:00:24,880
institute of technology

7
00:00:24,880 --> 00:00:27,439
i love windows internals i'm mostly

8
00:00:27,439 --> 00:00:29,199
self-taught with a strong mentor group

9
00:00:29,199 --> 00:00:30,000
helping me along the

10
00:00:30,000 --> 00:00:32,238
way and i have a strong game hacking

11
00:00:32,238 --> 00:00:33,680
background which is why i'm involved

12
00:00:33,680 --> 00:00:36,320
with windows internals

13
00:00:36,320 --> 00:00:38,239
so let's begin with what is this talk

14
00:00:38,239 --> 00:00:39,840
about well in this talk we're going to

15
00:00:39,840 --> 00:00:40,960
be going over

16
00:00:40,960 --> 00:00:43,360
loading a rootkit communicating with the

17
00:00:43,360 --> 00:00:44,239
rootkit

18
00:00:44,239 --> 00:00:45,600
abusing legitimate network

19
00:00:45,600 --> 00:00:48,320
communications an example rookit i wrote

20
00:00:48,320 --> 00:00:50,320
called the spectre rookit and the design

21
00:00:50,320 --> 00:00:52,160
choices behind it

22
00:00:52,160 --> 00:00:54,480
executing commands from kernel and

23
00:00:54,480 --> 00:00:56,239
tricks to cover up the file system trace

24
00:00:56,239 --> 00:00:58,800
of your kit

25
00:00:58,800 --> 00:01:00,399
so let's begin with windows root kit

26
00:01:00,399 --> 00:01:02,160
overview well when i say root can in

27
00:01:02,160 --> 00:01:03,199
this presentation

28
00:01:03,199 --> 00:01:04,559
i'm going to be referring to kernel

29
00:01:04,559 --> 00:01:07,280
level rootkits on windows

30
00:01:07,280 --> 00:01:09,119
so why would you want to use a rootkit

31
00:01:09,119 --> 00:01:11,600
well kernel drivers have significant

32
00:01:11,600 --> 00:01:13,760
access to the machine unlike in user

33
00:01:13,760 --> 00:01:15,439
mode you pretty much have access to

34
00:01:15,439 --> 00:01:17,600
anything and everything

35
00:01:17,600 --> 00:01:19,600
kernel drivers run at the same privilege

36
00:01:19,600 --> 00:01:22,640
level as a typical kernel anti-virus

37
00:01:22,640 --> 00:01:24,799
so this means that generally speaking

38
00:01:24,799 --> 00:01:26,400
you have the same access to the same

39
00:01:26,400 --> 00:01:28,000
resources

40
00:01:28,000 --> 00:01:29,840
there are less mitigations and security

41
00:01:29,840 --> 00:01:32,240
solutions targeting kernel malware

42
00:01:32,240 --> 00:01:34,560
if you can load kernel code chances are

43
00:01:34,560 --> 00:01:37,520
you can do a lot to cover up your tracks

44
00:01:37,520 --> 00:01:39,680
antivirus often have less visibility

45
00:01:39,680 --> 00:01:41,360
into the operations performed by kernel

46
00:01:41,360 --> 00:01:42,240
drivers

47
00:01:42,240 --> 00:01:44,799
this is because antivirus often depend

48
00:01:44,799 --> 00:01:46,479
on using user mode hooks to gain

49
00:01:46,479 --> 00:01:48,479
invisibility into certain suspicious

50
00:01:48,479 --> 00:01:49,439
operations

51
00:01:49,439 --> 00:01:51,280
but in the kernel you can't directly

52
00:01:51,280 --> 00:01:52,880
hook and toss kernel because of patch

53
00:01:52,880 --> 00:01:55,200
card

54
00:01:55,200 --> 00:01:57,439
finally kernel drivers are often ignored

55
00:01:57,439 --> 00:01:58,479
by antivirus

56
00:01:58,479 --> 00:02:01,119
let's take a look at an example of that

57
00:02:01,119 --> 00:02:02,240
so whether you're running

58
00:02:02,240 --> 00:02:05,520
a consumer antivirus or a corporate edr

59
00:02:05,520 --> 00:02:07,680
chances are that is that the application

60
00:02:07,680 --> 00:02:09,038
you use will treat

61
00:02:09,038 --> 00:02:11,120
kernel drivers with a significant amount

62
00:02:11,120 --> 00:02:12,640
of trust

63
00:02:12,640 --> 00:02:14,160
for example here we have the

64
00:02:14,160 --> 00:02:15,840
pre-processed thread callbacks from both

65
00:02:15,840 --> 00:02:17,599
malwarebytes and carbon black

66
00:02:17,599 --> 00:02:19,760
so these functions are called whenever a

67
00:02:19,760 --> 00:02:21,440
handle is created or duplicated

68
00:02:21,440 --> 00:02:24,000
to a process or a thread starting with

69
00:02:24,000 --> 00:02:25,200
malwarebytes

70
00:02:25,200 --> 00:02:27,200
what they do in their callback is check

71
00:02:27,200 --> 00:02:29,840
to see if the process id is less than a

72
00:02:29,840 --> 00:02:32,080
and if the kernel handle is if the

73
00:02:32,080 --> 00:02:33,120
handle is for a kernel

74
00:02:33,120 --> 00:02:35,519
handle then it will just go ahead and

75
00:02:35,519 --> 00:02:36,879
return zero and stop

76
00:02:36,879 --> 00:02:39,200
processing there for carbon block they

77
00:02:39,200 --> 00:02:40,160
take a little bit of a different

78
00:02:40,160 --> 00:02:41,519
perspective

79
00:02:41,519 --> 00:02:43,760
if you if the handle is for a kernel

80
00:02:43,760 --> 00:02:44,720
handle

81
00:02:44,720 --> 00:02:48,000
or if the previous mode is going is

82
00:02:48,000 --> 00:02:51,280
not user mode then it will not process

83
00:02:51,280 --> 00:02:54,800
that handle creation so let's talk a

84
00:02:54,800 --> 00:02:56,480
little bit about loading your rootkit

85
00:02:56,480 --> 00:02:58,319
well there are a lot of vulnerable

86
00:02:58,319 --> 00:03:00,239
drivers with some reversing

87
00:03:00,239 --> 00:03:02,159
knowledge finding a zero day in a driver

88
00:03:02,159 --> 00:03:03,519
can also be trivial

89
00:03:03,519 --> 00:03:05,280
some examples include capcom's

90
00:03:05,280 --> 00:03:06,640
anti-cheat driver

91
00:03:06,640 --> 00:03:08,640
intel's now driver and even microsoft

92
00:03:08,640 --> 00:03:10,400
themselves now the reason i put

93
00:03:10,400 --> 00:03:11,920
vulnerable in zero day in quotes is

94
00:03:11,920 --> 00:03:12,400
because

95
00:03:12,400 --> 00:03:14,640
oftentimes drivers require

96
00:03:14,640 --> 00:03:16,400
administrative privileges to communicate

97
00:03:16,400 --> 00:03:17,280
with them

98
00:03:17,280 --> 00:03:19,599
following microsoft standards ring 3

99
00:03:19,599 --> 00:03:21,840
with administrator to ring 0 is not a

100
00:03:21,840 --> 00:03:23,920
valid security boundary

101
00:03:23,920 --> 00:03:25,440
so technically it isn't even a

102
00:03:25,440 --> 00:03:27,599
vulnerability

103
00:03:27,599 --> 00:03:29,120
but this doesn't mean we can't abuse it

104
00:03:29,120 --> 00:03:30,799
either so using

105
00:03:30,799 --> 00:03:32,159
legitimate drivers has quite a few

106
00:03:32,159 --> 00:03:33,840
benefits too because you only need a few

107
00:03:33,840 --> 00:03:35,920
primitives to ask late privileges

108
00:03:35,920 --> 00:03:38,159
and finding a vulnerable driver is

109
00:03:38,159 --> 00:03:39,519
relatively trivial

110
00:03:39,519 --> 00:03:42,080
a great place to start is oem drivers

111
00:03:42,080 --> 00:03:44,000
and it's very difficult to detect

112
00:03:44,000 --> 00:03:45,680
some operations due to compatibility

113
00:03:45,680 --> 00:03:47,599
reasons for example

114
00:03:47,599 --> 00:03:49,440
let's say that a driver exposes some

115
00:03:49,440 --> 00:03:51,120
suspicious operations over its eye

116
00:03:51,120 --> 00:03:52,640
optical interface

117
00:03:52,640 --> 00:03:55,040
especially if the legitimate application

118
00:03:55,040 --> 00:03:57,519
uses that suspicious functionality

119
00:03:57,519 --> 00:03:59,040
it can be very difficult for an

120
00:03:59,040 --> 00:04:00,959
antivirus to discern whether or not

121
00:04:00,959 --> 00:04:03,120
an operation is from a legitimate

122
00:04:03,120 --> 00:04:04,000
application

123
00:04:04,000 --> 00:04:06,159
and this is just intended use or if a

124
00:04:06,159 --> 00:04:08,159
militia's application is abusing that

125
00:04:08,159 --> 00:04:11,280
driver functionality now abusing

126
00:04:11,280 --> 00:04:12,319
legitimate drivers

127
00:04:12,319 --> 00:04:14,799
does have some strong drawbacks as well

128
00:04:14,799 --> 00:04:16,720
one of the only reasons i don't really

129
00:04:16,720 --> 00:04:18,478
like this method is because

130
00:04:18,478 --> 00:04:20,560
let's say you use a legitimate driver to

131
00:04:20,560 --> 00:04:21,759
load your own driver

132
00:04:21,759 --> 00:04:23,040
the problem with this is that you can

133
00:04:23,040 --> 00:04:25,040
often run into compatibil compatibility

134
00:04:25,040 --> 00:04:26,080
issues especially across

135
00:04:26,080 --> 00:04:28,320
operating system versions but even if

136
00:04:28,320 --> 00:04:29,759
you you know

137
00:04:29,759 --> 00:04:32,160
we're trying to get rid of all the bugs

138
00:04:32,160 --> 00:04:33,280
you're going to probably run into some

139
00:04:33,280 --> 00:04:34,960
edge cases that can cause blue screens

140
00:04:34,960 --> 00:04:36,720
and the last thing i want to do is blue

141
00:04:36,720 --> 00:04:38,960
screen a victim

142
00:04:38,960 --> 00:04:41,120
for some red teamers an option is just

143
00:04:41,120 --> 00:04:42,479
buy your own certificate for your

144
00:04:42,479 --> 00:04:43,360
company

145
00:04:43,360 --> 00:04:45,280
now this is great for targeted attacks

146
00:04:45,280 --> 00:04:47,040
you're not gonna have stability concerns

147
00:04:47,040 --> 00:04:49,120
but it potentially reveals your identity

148
00:04:49,120 --> 00:04:50,880
and it can be blacklisted

149
00:04:50,880 --> 00:04:52,400
now this black listing doesn't really

150
00:04:52,400 --> 00:04:54,160
happen so much these days

151
00:04:54,160 --> 00:04:55,440
it's something that's being worked on by

152
00:04:55,440 --> 00:04:58,479
av vendors but it's very possible that

153
00:04:58,479 --> 00:05:00,639
a red team company might have their

154
00:05:00,639 --> 00:05:02,160
certificate blacklisted because

155
00:05:02,160 --> 00:05:04,000
it's strictly associated with colonel

156
00:05:04,000 --> 00:05:06,400
malware

157
00:05:06,479 --> 00:05:08,080
another option is just use someone

158
00:05:08,080 --> 00:05:09,759
else's certificate and there's actually

159
00:05:09,759 --> 00:05:11,520
quite a few publicly leaked certificates

160
00:05:11,520 --> 00:05:12,560
available to download

161
00:05:12,560 --> 00:05:14,240
if you're looking for one a good place

162
00:05:14,240 --> 00:05:16,000
to start is cheating forms which have

163
00:05:16,000 --> 00:05:17,600
quite a few posted

164
00:05:17,600 --> 00:05:20,320
there's almost all the benefits of using

165
00:05:20,320 --> 00:05:21,600
your own certificate

166
00:05:21,600 --> 00:05:24,080
except without de-anonymizing yourself

167
00:05:24,080 --> 00:05:25,840
but at least certificate you use

168
00:05:25,840 --> 00:05:28,080
can be detected in the future especially

169
00:05:28,080 --> 00:05:30,320
if it's a very public one

170
00:05:30,320 --> 00:05:32,000
if the leak certificate was issued after

171
00:05:32,000 --> 00:05:34,320
july 29 2015

172
00:05:34,320 --> 00:05:36,960
it won't work for kernel drivers on

173
00:05:36,960 --> 00:05:38,160
windows machines

174
00:05:38,160 --> 00:05:40,880
over version 1607 that have secured

175
00:05:40,880 --> 00:05:43,280
enabled

176
00:05:43,520 --> 00:05:45,199
so in most cases windows doesn't

177
00:05:45,199 --> 00:05:46,800
actually care if your driver has been

178
00:05:46,800 --> 00:05:48,560
expired or revoked

179
00:05:48,560 --> 00:05:51,280
so what you see in digital signatures is

180
00:05:51,280 --> 00:05:53,280
not what the kernel code signing policy

181
00:05:53,280 --> 00:05:53,919
is

182
00:05:53,919 --> 00:05:55,440
so even if you see you know this

183
00:05:55,440 --> 00:05:56,800
certificate has been revoked or the

184
00:05:56,800 --> 00:05:58,160
certificate has been expired

185
00:05:58,160 --> 00:06:00,000
i'd still give it a try because chances

186
00:06:00,000 --> 00:06:01,120
are it's going to work for kernel

187
00:06:01,120 --> 00:06:03,440
drivers

188
00:06:03,440 --> 00:06:05,199
so several leaked certificates are

189
00:06:05,199 --> 00:06:07,039
already publicly posted but it's not

190
00:06:07,039 --> 00:06:08,639
impossible to find your own either

191
00:06:08,639 --> 00:06:10,080
for example this website called

192
00:06:10,080 --> 00:06:12,000
greyhound warfare allows me to search

193
00:06:12,000 --> 00:06:14,400
open s3 buckets for files

194
00:06:14,400 --> 00:06:17,039
when i search for pfx and p12 files

195
00:06:17,039 --> 00:06:18,960
common extensions for private keys

196
00:06:18,960 --> 00:06:22,639
i found over 6 000 results

197
00:06:22,639 --> 00:06:24,240
and the best part about this method is

198
00:06:24,240 --> 00:06:25,680
that at this time

199
00:06:25,680 --> 00:06:27,840
the bulk of antivirus don't even come

200
00:06:27,840 --> 00:06:29,840
near detecting this method

201
00:06:29,840 --> 00:06:31,440
this is because i guess they haven't

202
00:06:31,440 --> 00:06:33,360
been working on blacklisting as much but

203
00:06:33,360 --> 00:06:36,720
i have not seen any antivirus yet detect

204
00:06:36,720 --> 00:06:38,240
most leaked certificates i've come

205
00:06:38,240 --> 00:06:39,919
across

206
00:06:39,919 --> 00:06:41,360
so let's talk about communicating with a

207
00:06:41,360 --> 00:06:43,759
rookie well a try and true method is

208
00:06:43,759 --> 00:06:46,000
just a beacon out to a c2

209
00:06:46,000 --> 00:06:48,319
now firewalls can block or flag outgoing

210
00:06:48,319 --> 00:06:50,240
requests that are to suspicious ip's

211
00:06:50,240 --> 00:06:51,120
reports

212
00:06:51,120 --> 00:06:52,319
and even for the more advanced

213
00:06:52,319 --> 00:06:53,919
techniques uh there's new features such

214
00:06:53,919 --> 00:06:55,440
as advanced network inspection

215
00:06:55,440 --> 00:06:58,400
that try to combat them another option

216
00:06:58,400 --> 00:07:00,080
is just to open a port onto your victim

217
00:07:00,080 --> 00:07:01,039
machine

218
00:07:01,039 --> 00:07:05,680
and have the c2 connect to the victim

219
00:07:05,680 --> 00:07:07,199
now the problem with this is that even

220
00:07:07,199 --> 00:07:09,199
though it's relatively simple to set up

221
00:07:09,199 --> 00:07:11,120
it can be blocked by a firewall and it

222
00:07:11,120 --> 00:07:12,639
can be difficult to blend in with the

223
00:07:12,639 --> 00:07:15,039
noise

224
00:07:15,280 --> 00:07:16,800
so another option for more advanced

225
00:07:16,800 --> 00:07:19,120
actors i've seen is application specific

226
00:07:19,120 --> 00:07:19,919
hooking

227
00:07:19,919 --> 00:07:21,599
this is where you piggyback on one

228
00:07:21,599 --> 00:07:23,360
application specific communication

229
00:07:23,360 --> 00:07:24,000
channel

230
00:07:24,000 --> 00:07:25,520
to receive communications directly from

231
00:07:25,520 --> 00:07:28,000
the c2 now this is incredibly difficult

232
00:07:28,000 --> 00:07:28,960
to detect

233
00:07:28,960 --> 00:07:30,479
especially if it's using a legitimate

234
00:07:30,479 --> 00:07:32,080
protocol

235
00:07:32,080 --> 00:07:34,319
but it's not very flexible because if

236
00:07:34,319 --> 00:07:35,919
the machine you're infecting doesn't

237
00:07:35,919 --> 00:07:38,160
have that one service exposed

238
00:07:38,160 --> 00:07:39,360
then you're going to be out of luck

239
00:07:39,360 --> 00:07:41,360
unless you have backup communication

240
00:07:41,360 --> 00:07:43,520
methods exposed as well

241
00:07:43,520 --> 00:07:45,919
so what i wanted was a method that had

242
00:07:45,919 --> 00:07:47,759
limited detection vectors

243
00:07:47,759 --> 00:07:49,120
flexibility for a variety of

244
00:07:49,120 --> 00:07:51,599
environments and my assumptions were

245
00:07:51,599 --> 00:07:52,879
that victim machines will have

246
00:07:52,879 --> 00:07:54,879
some services exposed which is

247
00:07:54,879 --> 00:07:56,160
especially true for corporate

248
00:07:56,160 --> 00:07:57,199
environments

249
00:07:57,199 --> 00:07:58,879
and inbound and half pound access may be

250
00:07:58,879 --> 00:08:00,639
monitored as well

251
00:08:00,639 --> 00:08:02,639
so application specific cooking was

252
00:08:02,639 --> 00:08:04,400
perfect for my needs

253
00:08:04,400 --> 00:08:06,720
except for the flexibility is there any

254
00:08:06,720 --> 00:08:07,440
way we can

255
00:08:07,440 --> 00:08:09,919
change application specific hooking to

256
00:08:09,919 --> 00:08:12,080
where it isn't dependent on any single

257
00:08:12,080 --> 00:08:14,560
application well what if instead of

258
00:08:14,560 --> 00:08:15,120
hooking an

259
00:08:15,120 --> 00:08:17,599
application directly we hooked network

260
00:08:17,599 --> 00:08:18,800
communication

261
00:08:18,800 --> 00:08:21,120
similar to tools such as wireshark then

262
00:08:21,120 --> 00:08:22,639
what we would do is we create these

263
00:08:22,639 --> 00:08:24,639
malicious packets in our c2

264
00:08:24,639 --> 00:08:27,039
and insert a magic constant value that

265
00:08:27,039 --> 00:08:29,120
the malware is aware of as well

266
00:08:29,120 --> 00:08:32,000
then we send this malicious packet over

267
00:08:32,000 --> 00:08:32,320
to

268
00:08:32,320 --> 00:08:34,479
any legitimate port on the victim

269
00:08:34,479 --> 00:08:35,679
machine

270
00:08:35,679 --> 00:08:37,279
since our malware is intercepting all

271
00:08:37,279 --> 00:08:38,719
packets being received

272
00:08:38,719 --> 00:08:40,559
it also constantly searches these

273
00:08:40,559 --> 00:08:42,640
packets for the magic constant

274
00:08:42,640 --> 00:08:45,040
that the c2 inserted so what we can do

275
00:08:45,040 --> 00:08:46,399
is we can piggyback off of all

276
00:08:46,399 --> 00:08:48,320
legitimate communication channels

277
00:08:48,320 --> 00:08:50,959
by simply abusing the fact of

278
00:08:50,959 --> 00:08:52,880
intercepting all packets

279
00:08:52,880 --> 00:08:54,560
because what we can do is again from the

280
00:08:54,560 --> 00:08:57,040
c2 to the victim any open port

281
00:08:57,040 --> 00:08:59,040
and with that magic constant the malware

282
00:08:59,040 --> 00:09:00,959
then knows that packet is from the c2

283
00:09:00,959 --> 00:09:04,080
and it processes out other data from it

284
00:09:04,080 --> 00:09:05,440
so let's talk about how we would hook

285
00:09:05,440 --> 00:09:07,680
the user mode network stack

286
00:09:07,680 --> 00:09:10,399
so a significant amount of services on

287
00:09:10,399 --> 00:09:11,519
windows can be found

288
00:09:11,519 --> 00:09:13,680
in user mode but how can we globally

289
00:09:13,680 --> 00:09:15,680
intercept this traffic well

290
00:09:15,680 --> 00:09:17,600
networking relating to wind socket is

291
00:09:17,600 --> 00:09:19,760
handled by afd.cis

292
00:09:19,760 --> 00:09:21,440
otherwise known as the ancillary

293
00:09:21,440 --> 00:09:23,440
function driver for windsock

294
00:09:23,440 --> 00:09:25,480
reversing a few functions inside of

295
00:09:25,480 --> 00:09:27,279
mswsoc.dll revealed that

296
00:09:27,279 --> 00:09:30,399
they're using an iactal interface by the

297
00:09:30,399 --> 00:09:31,360
afd driver

298
00:09:31,360 --> 00:09:33,360
to communicate now if we could intercept

299
00:09:33,360 --> 00:09:35,120
these requests we could snoop in on the

300
00:09:35,120 --> 00:09:37,839
data being received

301
00:09:38,160 --> 00:09:40,399
so when you call nt device i o control

302
00:09:40,399 --> 00:09:41,360
file

303
00:09:41,360 --> 00:09:42,880
how does it actually know how does the

304
00:09:42,880 --> 00:09:44,800
kernel know what function to call

305
00:09:44,800 --> 00:09:47,680
well first it gets the device object

306
00:09:47,680 --> 00:09:49,200
associated with the file object

307
00:09:49,200 --> 00:09:52,480
by calling i o get related device object

308
00:09:52,480 --> 00:09:54,399
this is for our purposes just going to

309
00:09:54,399 --> 00:09:56,480
be retrieving the device object member

310
00:09:56,480 --> 00:09:58,880
of the file object if the driver

311
00:09:58,880 --> 00:10:00,080
supports fast dio

312
00:10:00,080 --> 00:10:02,079
it'll dispatch the request using the

313
00:10:02,079 --> 00:10:04,000
fast i o dispatch table of the driver

314
00:10:04,000 --> 00:10:07,120
object if it doesn't support fast io

315
00:10:07,120 --> 00:10:08,720
then what it'll do is allocate and fill

316
00:10:08,720 --> 00:10:10,640
out a nerp and then use i o

317
00:10:10,640 --> 00:10:14,399
call driver to dispatch to europe

318
00:10:14,399 --> 00:10:16,000
so let's talk about standard methods of

319
00:10:16,000 --> 00:10:17,600
intercepting herbs

320
00:10:17,600 --> 00:10:19,839
so the few common methods include so in

321
00:10:19,839 --> 00:10:21,040
the driver object

322
00:10:21,040 --> 00:10:23,680
there is this major function array now

323
00:10:23,680 --> 00:10:25,279
this major function array

324
00:10:25,279 --> 00:10:27,519
it contains pointers to dispatch

325
00:10:27,519 --> 00:10:29,519
functions and the index for this array

326
00:10:29,519 --> 00:10:31,839
corresponds to the major function code

327
00:10:31,839 --> 00:10:33,360
so let's say we want to hook a specific

328
00:10:33,360 --> 00:10:34,480
major function code

329
00:10:34,480 --> 00:10:36,560
what we would do is we would go into the

330
00:10:36,560 --> 00:10:37,920
major function array

331
00:10:37,920 --> 00:10:40,320
and for that index replace the dispatch

332
00:10:40,320 --> 00:10:42,079
function pointer to our own dispatch

333
00:10:42,079 --> 00:10:43,279
function

334
00:10:43,279 --> 00:10:45,120
another option is to just perform a code

335
00:10:45,120 --> 00:10:47,519
hook directly on the dispatch handler

336
00:10:47,519 --> 00:10:49,680
so for picking these picking a method

337
00:10:49,680 --> 00:10:51,200
there are a few common questions you

338
00:10:51,200 --> 00:10:52,480
should ask yourself

339
00:10:52,480 --> 00:10:54,000
how many detection vectors are you

340
00:10:54,000 --> 00:10:55,760
potentially exposed to

341
00:10:55,760 --> 00:10:58,079
how usable is the method from a

342
00:10:58,079 --> 00:10:58,800
stability

343
00:10:58,800 --> 00:11:01,279
and compatibility perspective and how

344
00:11:01,279 --> 00:11:03,040
expensive would it be to detect that

345
00:11:03,040 --> 00:11:04,240
method

346
00:11:04,240 --> 00:11:06,399
so for hooking a driver object's major

347
00:11:06,399 --> 00:11:08,320
function table

348
00:11:08,320 --> 00:11:09,440
you're going to be exposing yourself to

349
00:11:09,440 --> 00:11:11,360
memory artifacts from a usability

350
00:11:11,360 --> 00:11:12,480
perspective it's going to be quite

351
00:11:12,480 --> 00:11:14,079
stable because

352
00:11:14,079 --> 00:11:15,839
driver objects are well documented and

353
00:11:15,839 --> 00:11:18,079
easy to find

354
00:11:18,079 --> 00:11:20,079
finally for how expensive is it to

355
00:11:20,079 --> 00:11:21,839
detect well

356
00:11:21,839 --> 00:11:23,120
it's not going to be that expensive

357
00:11:23,120 --> 00:11:24,560
because if you think about it all

358
00:11:24,560 --> 00:11:25,839
antivirus would need to do

359
00:11:25,839 --> 00:11:28,079
is enumerate the loaded drivers and

360
00:11:28,079 --> 00:11:30,000
check their major function table

361
00:11:30,000 --> 00:11:33,200
for any patches so for code hooking

362
00:11:33,200 --> 00:11:34,320
you're going to be exposing yourself to

363
00:11:34,320 --> 00:11:35,680
memory artifacts

364
00:11:35,680 --> 00:11:37,839
and unless the function is exported

365
00:11:37,839 --> 00:11:39,680
you're going to need to find a function

366
00:11:39,680 --> 00:11:40,640
yourself

367
00:11:40,640 --> 00:11:42,880
now the problem with this is is present

368
00:11:42,880 --> 00:11:43,839
especially if

369
00:11:43,839 --> 00:11:46,000
the driver file changes between

370
00:11:46,000 --> 00:11:48,320
operating system versions

371
00:11:48,320 --> 00:11:50,160
and also not all driver is going to be

372
00:11:50,160 --> 00:11:52,160
compatible with this code hook because

373
00:11:52,160 --> 00:11:53,440
of patch card

374
00:11:53,440 --> 00:11:56,560
and if hvcis hvci's enabled

375
00:11:56,560 --> 00:11:59,680
this method won't be viable at all it's

376
00:11:59,680 --> 00:12:01,680
very how expensive is it to detect

377
00:12:01,680 --> 00:12:03,519
well it's potentially inexpensive

378
00:12:03,519 --> 00:12:04,639
because there's so many different ways

379
00:12:04,639 --> 00:12:05,360
to detect

380
00:12:05,360 --> 00:12:07,839
hooking for example if an antivirus

381
00:12:07,839 --> 00:12:09,360
implemented a generic detection

382
00:12:09,360 --> 00:12:10,639
functionality where they would

383
00:12:10,639 --> 00:12:13,120
enumerate the executable sections for

384
00:12:13,120 --> 00:12:14,160
loaded drivers

385
00:12:14,160 --> 00:12:16,160
with what's on disk now that's quite

386
00:12:16,160 --> 00:12:17,200
expensive but

387
00:12:17,200 --> 00:12:18,959
if they know that you're hooking a

388
00:12:18,959 --> 00:12:21,279
specific function of a specific driver

389
00:12:21,279 --> 00:12:23,279
then checking the first few bytes isn't

390
00:12:23,279 --> 00:12:26,399
going to be very expensive at all

391
00:12:26,399 --> 00:12:28,079
so i wanted a method that was

392
00:12:28,079 --> 00:12:29,920
undocumented stable

393
00:12:29,920 --> 00:12:32,720
and relatively expensive to detect well

394
00:12:32,720 --> 00:12:33,600
what if instead

395
00:12:33,600 --> 00:12:35,839
instead of hooking the original driver

396
00:12:35,839 --> 00:12:36,720
object

397
00:12:36,720 --> 00:12:39,519
we hook the file object instead so what

398
00:12:39,519 --> 00:12:40,720
i'm talking about is

399
00:12:40,720 --> 00:12:42,880
well the device retrieved for a file

400
00:12:42,880 --> 00:12:43,760
file object

401
00:12:43,760 --> 00:12:45,200
is going to end up being the device

402
00:12:45,200 --> 00:12:46,720
object pointer inside of that file

403
00:12:46,720 --> 00:12:47,600
object

404
00:12:47,600 --> 00:12:49,600
so what is actually stopping us from

405
00:12:49,600 --> 00:12:51,360
overwriting this pointer of that one

406
00:12:51,360 --> 00:12:52,320
file object

407
00:12:52,320 --> 00:12:54,720
with our own well it turns out

408
00:12:54,720 --> 00:12:56,079
absolutely nothing

409
00:12:56,079 --> 00:12:57,760
so what we can do is create our own

410
00:12:57,760 --> 00:12:59,760
device and driver object

411
00:12:59,760 --> 00:13:02,079
patch our copy of the driver object so

412
00:13:02,079 --> 00:13:03,839
this is not the same thing as

413
00:13:03,839 --> 00:13:05,600
patching the original driver object

414
00:13:05,600 --> 00:13:07,200
which can be easily found

415
00:13:07,200 --> 00:13:10,240
this is patching our own copy then we

416
00:13:10,240 --> 00:13:12,000
can replace the device object pointer of

417
00:13:12,000 --> 00:13:13,440
the file object we're hooking

418
00:13:13,440 --> 00:13:15,680
with our own device the neat thing with

419
00:13:15,680 --> 00:13:16,959
this method is that instead of

420
00:13:16,959 --> 00:13:19,760
hooking globally for every for every

421
00:13:19,760 --> 00:13:21,920
different herb from any process

422
00:13:21,920 --> 00:13:25,760
we specifically hook the specific handle

423
00:13:25,760 --> 00:13:27,680
we'd like to hook

424
00:13:27,680 --> 00:13:28,880
let's talk about how we would actually

425
00:13:28,880 --> 00:13:31,279
do this well we need to first find

426
00:13:31,279 --> 00:13:33,120
file objects to hook and the way we can

427
00:13:33,120 --> 00:13:35,200
do this is through the great api called

428
00:13:35,200 --> 00:13:37,600
cw query system information which

429
00:13:37,600 --> 00:13:39,279
exposes a variety of information about

430
00:13:39,279 --> 00:13:40,320
your system

431
00:13:40,320 --> 00:13:42,079
now one of the classes you can request

432
00:13:42,079 --> 00:13:43,839
is the system handle information

433
00:13:43,839 --> 00:13:46,240
class which will allow you to query all

434
00:13:46,240 --> 00:13:46,959
handles

435
00:13:46,959 --> 00:13:49,440
on a system including the process id

436
00:13:49,440 --> 00:13:50,800
behind that handle

437
00:13:50,800 --> 00:13:52,399
and the kernel pointer for the object

438
00:13:52,399 --> 00:13:54,560
that that handle points to

439
00:13:54,560 --> 00:13:57,760
now if we open the afd device ourselves

440
00:13:57,760 --> 00:13:59,920
before scanning for these file objects

441
00:13:59,920 --> 00:14:02,639
we can easily determine if a file object

442
00:14:02,639 --> 00:14:04,079
is for the afd device

443
00:14:04,079 --> 00:14:06,079
by comparing the device object member of

444
00:14:06,079 --> 00:14:08,079
the file object with the afd device we

445
00:14:08,079 --> 00:14:10,800
already retrieved

446
00:14:10,959 --> 00:14:12,959
so before we can overwrite the device

447
00:14:12,959 --> 00:14:14,480
object member we need to actually create

448
00:14:14,480 --> 00:14:15,600
our fake objects and

449
00:14:15,600 --> 00:14:18,399
fortunately the kernel actually exports

450
00:14:18,399 --> 00:14:20,079
the function it uses to create these

451
00:14:20,079 --> 00:14:20,639
objects

452
00:14:20,639 --> 00:14:23,680
them itself so all we need to do

453
00:14:23,680 --> 00:14:26,560
is call ob create object the i o device

454
00:14:26,560 --> 00:14:27,600
object type

455
00:14:27,600 --> 00:14:29,600
an i o driver object type depending on

456
00:14:29,600 --> 00:14:31,040
what object you're creating

457
00:14:31,040 --> 00:14:32,880
once you've created objects you can just

458
00:14:32,880 --> 00:14:36,000
simply copy over the existing values

459
00:14:36,000 --> 00:14:37,519
so with our fake objects created we're

460
00:14:37,519 --> 00:14:39,440
almost ready to set the device object of

461
00:14:39,440 --> 00:14:40,720
our file object

462
00:14:40,720 --> 00:14:42,880
but first we need to hook our driver

463
00:14:42,880 --> 00:14:43,760
object

464
00:14:43,760 --> 00:14:45,279
now the way we're going to do this is

465
00:14:45,279 --> 00:14:46,959
again by using that standard hookah

466
00:14:46,959 --> 00:14:48,399
driver object method

467
00:14:48,399 --> 00:14:50,880
but except we are not performing it on

468
00:14:50,880 --> 00:14:51,760
the original

469
00:14:51,760 --> 00:14:54,480
driver object this is our own copy which

470
00:14:54,480 --> 00:14:57,279
an antivirus cannot easily retrieve

471
00:14:57,279 --> 00:14:58,880
so to prevent race conditions while

472
00:14:58,880 --> 00:15:01,040
replacing the device object member

473
00:15:01,040 --> 00:15:03,120
the original device object we use inside

474
00:15:03,120 --> 00:15:05,279
of our hooked dispatch function

475
00:15:05,279 --> 00:15:07,600
needs to be set at the same time that

476
00:15:07,600 --> 00:15:09,519
our that we replace the device object of

477
00:15:09,519 --> 00:15:10,720
the file object

478
00:15:10,720 --> 00:15:13,199
so the way i did this is by simply using

479
00:15:13,199 --> 00:15:16,240
interlocked exchange

480
00:15:17,199 --> 00:15:18,959
so now that we've hooked our file object

481
00:15:18,959 --> 00:15:20,480
there's not much work left

482
00:15:20,480 --> 00:15:22,639
so in our dispatch hook if the major

483
00:15:22,639 --> 00:15:24,160
function code that is being called is

484
00:15:24,160 --> 00:15:24,800
hooked

485
00:15:24,800 --> 00:15:26,160
then we should pass the original

486
00:15:26,160 --> 00:15:28,720
dispatch function the original device

487
00:15:28,720 --> 00:15:30,000
object and the erp

488
00:15:30,000 --> 00:15:33,199
to the hooked function then

489
00:15:33,199 --> 00:15:35,519
if the major function code erp matrix

490
00:15:35,519 --> 00:15:37,199
function cleanup

491
00:15:37,199 --> 00:15:39,920
is requested then we need to replace the

492
00:15:39,920 --> 00:15:42,240
device object member of the file object

493
00:15:42,240 --> 00:15:44,160
with the original device this is to

494
00:15:44,160 --> 00:15:47,440
prevent any issues during teardown

495
00:15:47,440 --> 00:15:49,279
so how many detection vectors are you

496
00:15:49,279 --> 00:15:50,880
potentially exposed to well

497
00:15:50,880 --> 00:15:52,880
it's going to be memory artifacts and

498
00:15:52,880 --> 00:15:54,000
how usable is the method

499
00:15:54,000 --> 00:15:56,959
well since most of the functions we use

500
00:15:56,959 --> 00:15:58,800
are at least semi-documented

501
00:15:58,800 --> 00:16:00,079
they're probably not going to change too

502
00:16:00,079 --> 00:16:02,720
much how expensive would it be to detect

503
00:16:02,720 --> 00:16:04,560
method well it's also going to be pretty

504
00:16:04,560 --> 00:16:06,639
expensive because an antivirus would

505
00:16:06,639 --> 00:16:08,560
have to replicate our hooking process

506
00:16:08,560 --> 00:16:10,959
and scan each file object to see if it's

507
00:16:10,959 --> 00:16:14,160
device object has been patched

508
00:16:14,160 --> 00:16:15,839
let's talk about how the spectrorootkit

509
00:16:15,839 --> 00:16:18,720
abuses user mode network stack

510
00:16:18,720 --> 00:16:21,839
so using the file object hook we can now

511
00:16:21,839 --> 00:16:25,120
intercept earps to the afd driver

512
00:16:25,120 --> 00:16:27,279
this allows us to intercept all user

513
00:16:27,279 --> 00:16:29,199
mode networking traffic

514
00:16:29,199 --> 00:16:31,360
and send and receive our own data over

515
00:16:31,360 --> 00:16:33,440
any socket

516
00:16:33,440 --> 00:16:35,839
so to review our existing plan is to

517
00:16:35,839 --> 00:16:37,600
hook network communication in our

518
00:16:37,600 --> 00:16:40,079
malware that is on the victim machine

519
00:16:40,079 --> 00:16:41,519
similar to tools such as wireshark and

520
00:16:41,519 --> 00:16:43,680
then we place a special indicator

521
00:16:43,680 --> 00:16:46,399
in the packets we create in our c2 then

522
00:16:46,399 --> 00:16:47,680
when this packet is sent

523
00:16:47,680 --> 00:16:49,279
the malware scans for that magic

524
00:16:49,279 --> 00:16:51,040
constant and then recognizes that magic

525
00:16:51,040 --> 00:16:51,680
constant

526
00:16:51,680 --> 00:16:53,600
and it parses out any extra data that

527
00:16:53,600 --> 00:16:55,120
that packet might have

528
00:16:55,120 --> 00:16:56,880
but how can we actually retrieve the

529
00:16:56,880 --> 00:16:59,120
content of packets that are received

530
00:16:59,120 --> 00:17:00,800
just because we intercept afd

531
00:17:00,800 --> 00:17:02,560
communication doesn't mean we have

532
00:17:02,560 --> 00:17:05,039
immediate access to those buffers

533
00:17:05,039 --> 00:17:08,160
so for receive operations an iot code i

534
00:17:08,160 --> 00:17:08,880
octal afd

535
00:17:08,880 --> 00:17:11,280
receive is sent to the afd driver here's

536
00:17:11,280 --> 00:17:12,640
the structures that are sent to the

537
00:17:12,640 --> 00:17:13,679
input buffer

538
00:17:13,679 --> 00:17:15,439
now the afd receive info structure is

539
00:17:15,439 --> 00:17:16,880
the one that's actually sent

540
00:17:16,880 --> 00:17:18,799
and it has some flags and an array of

541
00:17:18,799 --> 00:17:19,919
buffers

542
00:17:19,919 --> 00:17:22,079
this array of buffers is what actually

543
00:17:22,079 --> 00:17:23,039
contains

544
00:17:23,039 --> 00:17:24,559
the content of the data that was

545
00:17:24,559 --> 00:17:27,039
received

546
00:17:27,520 --> 00:17:29,600
let's talk about how the spectre rootkit

547
00:17:29,600 --> 00:17:31,280
was designed specifically the packet

548
00:17:31,280 --> 00:17:32,559
structure that gets sent

549
00:17:32,559 --> 00:17:35,840
from the c2 to any legitimate port well

550
00:17:35,840 --> 00:17:37,200
the packet structure allows you to

551
00:17:37,200 --> 00:17:38,960
prepend any data you want

552
00:17:38,960 --> 00:17:41,440
as long as it isn't the magic value then

553
00:17:41,440 --> 00:17:43,360
you can have your magic constant

554
00:17:43,360 --> 00:17:45,440
and what you can do is this magic

555
00:17:45,440 --> 00:17:47,760
constant will act as a reference point

556
00:17:47,760 --> 00:17:50,160
for the rest of the structures after the

557
00:17:50,160 --> 00:17:51,440
magic constant

558
00:17:51,440 --> 00:17:52,640
you're going to have a base packet

559
00:17:52,640 --> 00:17:54,080
structure which is seen on the right as

560
00:17:54,080 --> 00:17:54,720
well

561
00:17:54,720 --> 00:17:57,120
and all it contains is the packet length

562
00:17:57,120 --> 00:18:00,160
and the packet operation being requested

563
00:18:00,160 --> 00:18:02,080
after the base packet structure is an

564
00:18:02,080 --> 00:18:03,919
optional custom structure

565
00:18:03,919 --> 00:18:06,240
now this custom structure will vary or

566
00:18:06,240 --> 00:18:07,679
may not even exist

567
00:18:07,679 --> 00:18:09,440
depending on type of operation being

568
00:18:09,440 --> 00:18:11,760
requested after the custom structure you

569
00:18:11,760 --> 00:18:14,559
can append any data you'd like the idea

570
00:18:14,559 --> 00:18:14,799
is

571
00:18:14,799 --> 00:18:16,240
with this packet structure is that you

572
00:18:16,240 --> 00:18:18,640
can send any packets you'd like before

573
00:18:18,640 --> 00:18:20,480
the malicious packet or after the

574
00:18:20,480 --> 00:18:22,080
malicious packet and even in the

575
00:18:22,080 --> 00:18:23,600
malicious packet itself

576
00:18:23,600 --> 00:18:25,520
you can pre-pend or append any data

577
00:18:25,520 --> 00:18:28,320
you'd like besides the magic value

578
00:18:28,320 --> 00:18:30,880
so once a packet is received by the

579
00:18:30,880 --> 00:18:32,640
malware what it does is it'll search

580
00:18:32,640 --> 00:18:35,520
a buffer search the buffer received for

581
00:18:35,520 --> 00:18:36,640
the magic value

582
00:18:36,640 --> 00:18:38,160
and if the buffer contains the magic

583
00:18:38,160 --> 00:18:39,520
it'll go ahead and pass it on for

584
00:18:39,520 --> 00:18:40,400
processing

585
00:18:40,400 --> 00:18:42,240
if it does not it'll simply ignore the

586
00:18:42,240 --> 00:18:43,840
packet

587
00:18:43,840 --> 00:18:46,000
for processing it'll use the res it'll

588
00:18:46,000 --> 00:18:47,919
check to see if there's enough bytes

589
00:18:47,919 --> 00:18:49,600
to fill out a base packet structure in

590
00:18:49,600 --> 00:18:51,360
the already received data

591
00:18:51,360 --> 00:18:53,840
if there is enough bytes it'll use to

592
00:18:53,840 --> 00:18:54,880
check to see if the

593
00:18:54,880 --> 00:18:56,400
there's enough bytes for the custom

594
00:18:56,400 --> 00:18:58,880
structure if there is one

595
00:18:58,880 --> 00:19:00,880
only when both of these base packet in

596
00:19:00,880 --> 00:19:02,080
the optional custom structure is

597
00:19:02,080 --> 00:19:02,880
fulfilled

598
00:19:02,880 --> 00:19:05,280
will it dispatch packet if in any case

599
00:19:05,280 --> 00:19:07,039
it needs to get extra bytes it'll go

600
00:19:07,039 --> 00:19:08,840
ahead and receive it using the socket

601
00:19:08,840 --> 00:19:10,799
handle

602
00:19:10,799 --> 00:19:12,480
so before we go any further let's also

603
00:19:12,480 --> 00:19:14,160
talk about packet handlers in the

604
00:19:14,160 --> 00:19:15,280
spectre rookie

605
00:19:15,280 --> 00:19:16,960
so the spectroroute contains a general

606
00:19:16,960 --> 00:19:18,400
packet handler class

607
00:19:18,400 --> 00:19:20,400
that exposes a virtual process packet

608
00:19:20,400 --> 00:19:22,799
function now this base packet handler

609
00:19:22,799 --> 00:19:24,480
class has a default constructor

610
00:19:24,480 --> 00:19:26,559
that accepts a pointer to the current

611
00:19:26,559 --> 00:19:28,480
packet dispatcher instance

612
00:19:28,480 --> 00:19:30,640
and the process packet function below it

613
00:19:30,640 --> 00:19:33,120
accepts a pointer to the current packet

614
00:19:33,120 --> 00:19:34,799
we'll talk about the dispatcher at a

615
00:19:34,799 --> 00:19:37,120
later slide

616
00:19:37,120 --> 00:19:38,799
so an example of a packet handler

617
00:19:38,799 --> 00:19:40,799
included with the spectre rootkit

618
00:19:40,799 --> 00:19:43,200
is the ping packet handler now this

619
00:19:43,200 --> 00:19:45,039
handler is used specifically

620
00:19:45,039 --> 00:19:47,679
to determine if a machine or port is

621
00:19:47,679 --> 00:19:49,120
infected

622
00:19:49,120 --> 00:19:51,919
now the incoming packet has no actual

623
00:19:51,919 --> 00:19:52,720
data

624
00:19:52,720 --> 00:19:55,200
other than indicating that its type is a

625
00:19:55,200 --> 00:19:56,080
ping

626
00:19:56,080 --> 00:19:58,080
and that the handler responds to the

627
00:19:58,080 --> 00:20:00,080
client or the c2

628
00:20:00,080 --> 00:20:02,159
with just another empty base packet with

629
00:20:02,159 --> 00:20:05,200
this type set to ping

630
00:20:05,360 --> 00:20:09,039
so once packet is completely populated

631
00:20:09,039 --> 00:20:11,440
during dispatching the packet dispatcher

632
00:20:11,440 --> 00:20:13,360
will allocate a packet handler

633
00:20:13,360 --> 00:20:15,360
depending on the type of operation being

634
00:20:15,360 --> 00:20:16,640
requested

635
00:20:16,640 --> 00:20:18,480
it'll call the packet handler's process

636
00:20:18,480 --> 00:20:20,000
packet function

637
00:20:20,000 --> 00:20:21,360
and then it'll free the packet handler

638
00:20:21,360 --> 00:20:23,520
once it's done now the reason the packet

639
00:20:23,520 --> 00:20:26,000
dispatcher is really awesome is because

640
00:20:26,000 --> 00:20:28,799
since it passes a pointer to itself to

641
00:20:28,799 --> 00:20:30,080
packet handlers

642
00:20:30,080 --> 00:20:31,679
what can happen is that the packet

643
00:20:31,679 --> 00:20:33,760
handler can re-dispatch

644
00:20:33,760 --> 00:20:36,720
recursively a brand new packet so the

645
00:20:36,720 --> 00:20:38,159
best way i can explain this is through

646
00:20:38,159 --> 00:20:39,200
an example

647
00:20:39,200 --> 00:20:40,640
so let's talk about the zorb packet

648
00:20:40,640 --> 00:20:43,039
handler included with the spectre rookie

649
00:20:43,039 --> 00:20:44,960
the zorp packet handler takes in a zora

650
00:20:44,960 --> 00:20:46,240
packet structure

651
00:20:46,240 --> 00:20:48,000
and this structure contains a xor key

652
00:20:48,000 --> 00:20:49,760
and a zork content

653
00:20:49,760 --> 00:20:51,520
so what the c2 does is let's say it

654
00:20:51,520 --> 00:20:53,440
wants to request some operation

655
00:20:53,440 --> 00:20:55,600
it'll take the bytes of that base packet

656
00:20:55,600 --> 00:20:57,679
in optional custom structure

657
00:20:57,679 --> 00:21:00,400
and stick it into the zor content array

658
00:21:00,400 --> 00:21:00,880
then

659
00:21:00,880 --> 00:21:02,880
it'll generate a random byte in place of

660
00:21:02,880 --> 00:21:05,360
the zorky and use this random byte

661
00:21:05,360 --> 00:21:07,360
to perform a zero operation on each byte

662
00:21:07,360 --> 00:21:09,679
of the zor content

663
00:21:09,679 --> 00:21:12,000
when the zorb packet is received by the

664
00:21:12,000 --> 00:21:13,679
malware

665
00:21:13,679 --> 00:21:15,679
it'll use a zorky to de-obfuscate the

666
00:21:15,679 --> 00:21:16,960
zorg content

667
00:21:16,960 --> 00:21:18,240
and then what it'll do is call the

668
00:21:18,240 --> 00:21:20,000
dispatch function again

669
00:21:20,000 --> 00:21:22,640
except it'll pass the zorg content as

670
00:21:22,640 --> 00:21:24,960
the new packet to dispatch

671
00:21:24,960 --> 00:21:28,000
so to explain this is pretty simple

672
00:21:28,000 --> 00:21:29,840
the spectre rootkit allows you to create

673
00:21:29,840 --> 00:21:32,080
infinite layers of encapsulation

674
00:21:32,080 --> 00:21:34,559
now this is great because for example if

675
00:21:34,559 --> 00:21:35,760
you create a few different type of

676
00:21:35,760 --> 00:21:36,640
packet handlers

677
00:21:36,640 --> 00:21:38,960
such as a door packet handler you can

678
00:21:38,960 --> 00:21:41,280
create layers of obfuscation and change

679
00:21:41,280 --> 00:21:42,240
the bytes of

680
00:21:42,240 --> 00:21:45,200
packets randomly and allowing to add

681
00:21:45,200 --> 00:21:46,960
entropy even if you're requesting

682
00:21:46,960 --> 00:21:50,000
the same operation

683
00:21:50,720 --> 00:21:52,720
another common feature seen in kernel

684
00:21:52,720 --> 00:21:55,120
malware or sorry malware in general is

685
00:21:55,120 --> 00:21:57,440
executing commands but before we can

686
00:21:57,440 --> 00:21:59,840
actually execute commands in the kernel

687
00:21:59,840 --> 00:22:01,440
we need to understand how do you

688
00:22:01,440 --> 00:22:03,039
actually connect execute commands in

689
00:22:03,039 --> 00:22:04,159
user mode

690
00:22:04,159 --> 00:22:07,440
well to follow a basic example first

691
00:22:07,440 --> 00:22:10,880
you need to create pipes for your output

692
00:22:10,880 --> 00:22:12,640
now this is going to have a reading hand

693
00:22:12,640 --> 00:22:14,799
read and write handle to this new pipe

694
00:22:14,799 --> 00:22:16,400
and you can you just use the create pipe

695
00:22:16,400 --> 00:22:18,320
function for this then

696
00:22:18,320 --> 00:22:20,320
you're going to create a startup info

697
00:22:20,320 --> 00:22:21,360
structure

698
00:22:21,360 --> 00:22:22,640
and in the structure you're going to set

699
00:22:22,640 --> 00:22:24,880
the standard error and standard output

700
00:22:24,880 --> 00:22:27,280
handles to the unknown pipe you just

701
00:22:27,280 --> 00:22:28,159
created

702
00:22:28,159 --> 00:22:29,840
and you can here you can also set window

703
00:22:29,840 --> 00:22:31,679
flags such as hide the window

704
00:22:31,679 --> 00:22:33,200
so that the victim doesn't see the

705
00:22:33,200 --> 00:22:35,600
command prompt window being created

706
00:22:35,600 --> 00:22:37,600
once you set those structures you just

707
00:22:37,600 --> 00:22:39,440
can call create process

708
00:22:39,440 --> 00:22:40,960
and you can wait for it to exit using

709
00:22:40,960 --> 00:22:43,120
wait for a single object

710
00:22:43,120 --> 00:22:45,440
once the process is exited you can

711
00:22:45,440 --> 00:22:47,520
retrieve the output of the process

712
00:22:47,520 --> 00:22:53,919
by calling read file on the unnamed pipe

713
00:22:53,919 --> 00:22:54,640
so first

714
00:22:54,640 --> 00:22:56,080
let's begin by re-implementing the

715
00:22:56,080 --> 00:22:58,400
create pipe function so what the creep

716
00:22:58,400 --> 00:22:59,520
pipe function does

717
00:22:59,520 --> 00:23:02,720
in the background is name if it'll check

718
00:23:02,720 --> 00:23:04,400
if the device named pipe is already

719
00:23:04,400 --> 00:23:05,039
opened

720
00:23:05,039 --> 00:23:07,440
if it is not it'll go ahead and open it

721
00:23:07,440 --> 00:23:09,840
then it'll set the root directory

722
00:23:09,840 --> 00:23:11,760
for the object attributes for the brand

723
00:23:11,760 --> 00:23:15,360
new pipe test to this named pipe device

724
00:23:15,360 --> 00:23:17,840
when it calls nt create name type file

725
00:23:17,840 --> 00:23:19,760
it'll use the access right's generic

726
00:23:19,760 --> 00:23:20,400
read

727
00:23:20,400 --> 00:23:22,080
because this function creates both a

728
00:23:22,080 --> 00:23:24,240
read handle and a right handle

729
00:23:24,240 --> 00:23:26,480
once the pipe is created it'll call

730
00:23:26,480 --> 00:23:27,760
anti-open file

731
00:23:27,760 --> 00:23:29,280
with the root directory set to this

732
00:23:29,280 --> 00:23:31,679
brand new pipe

733
00:23:31,679 --> 00:23:33,520
this is used to obtain a right handle

734
00:23:33,520 --> 00:23:36,880
for that pipe

735
00:23:36,880 --> 00:23:39,120
so once we have the pipes we just need

736
00:23:39,120 --> 00:23:40,880
to create the actual process and we'll

737
00:23:40,880 --> 00:23:43,039
be using zw create user process

738
00:23:43,039 --> 00:23:44,880
because that's what the kernel 32 api

739
00:23:44,880 --> 00:23:47,120
uses itself

740
00:23:47,120 --> 00:23:48,720
the first thing you need to do is

741
00:23:48,720 --> 00:23:50,480
generate an attribute list

742
00:23:50,480 --> 00:23:52,400
now the actual attribute we're going to

743
00:23:52,400 --> 00:23:54,720
set is just a ps attribute image name

744
00:23:54,720 --> 00:23:56,720
which represents the image file name for

745
00:23:56,720 --> 00:23:59,520
the new process

746
00:23:59,520 --> 00:24:02,640
next we have to set an rtl user process

747
00:24:02,640 --> 00:24:04,960
parameter structure for the new process

748
00:24:04,960 --> 00:24:05,760
and in this

749
00:24:05,760 --> 00:24:07,440
it's very similar to the startup info

750
00:24:07,440 --> 00:24:08,960
structure we saw in user mode

751
00:24:08,960 --> 00:24:10,240
except we have to specify a little bit

752
00:24:10,240 --> 00:24:12,480
more information so besides the window

753
00:24:12,480 --> 00:24:14,000
flags and the output handles to our

754
00:24:14,000 --> 00:24:14,799
pipes

755
00:24:14,799 --> 00:24:16,799
we need to specify the current directory

756
00:24:16,799 --> 00:24:18,159
the command line arguments

757
00:24:18,159 --> 00:24:20,400
the process image path and the default

758
00:24:20,400 --> 00:24:22,640
desktop name

759
00:24:22,640 --> 00:24:25,600
from there all it takes is a call to zw

760
00:24:25,600 --> 00:24:26,799
create user process

761
00:24:26,799 --> 00:24:29,279
to start a process and once the process

762
00:24:29,279 --> 00:24:30,159
has exited

763
00:24:30,159 --> 00:24:32,080
similar to what we do in user mode we

764
00:24:32,080 --> 00:24:33,840
can just call zw read file

765
00:24:33,840 --> 00:24:38,000
to read the output of the process

766
00:24:38,480 --> 00:24:40,320
so let's talk a little bit about hiding

767
00:24:40,320 --> 00:24:42,799
a rootkit

768
00:24:42,799 --> 00:24:44,320
i'd like you to i'd like to introduce

769
00:24:44,320 --> 00:24:46,080
you to many filters so what many filter

770
00:24:46,080 --> 00:24:47,440
drivers allow you to do

771
00:24:47,440 --> 00:24:49,760
is attach to volumes and intercept

772
00:24:49,760 --> 00:24:51,679
certain file i o

773
00:24:51,679 --> 00:24:53,360
this is performed by registering with

774
00:24:53,360 --> 00:24:55,120
the filter manager driver

775
00:24:55,120 --> 00:24:57,039
so to give an example from microsoft

776
00:24:57,039 --> 00:24:58,880
when a user requests file io

777
00:24:58,880 --> 00:25:00,799
when it's sent to the file system the

778
00:25:00,799 --> 00:25:02,480
filter manager driver will actually

779
00:25:02,480 --> 00:25:04,080
intercept this request

780
00:25:04,080 --> 00:25:06,000
and then it will pass it along to the

781
00:25:06,000 --> 00:25:07,600
many filters that have registered with

782
00:25:07,600 --> 00:25:08,640
it

783
00:25:08,640 --> 00:25:10,880
these many filters have a lot of control

784
00:25:10,880 --> 00:25:12,159
and they can even edit

785
00:25:12,159 --> 00:25:15,440
or modify the file request

786
00:25:15,440 --> 00:25:17,279
once it's been edited or just pass

787
00:25:17,279 --> 00:25:18,799
through all the many filters

788
00:25:18,799 --> 00:25:21,679
it's then sent to the file system so

789
00:25:21,679 --> 00:25:23,200
many filters can be useful

790
00:25:23,200 --> 00:25:25,600
to mask the presence of our rootkit for

791
00:25:25,600 --> 00:25:26,720
example

792
00:25:26,720 --> 00:25:28,720
a mini filter can redirect all file

793
00:25:28,720 --> 00:25:30,400
access for a certain file

794
00:25:30,400 --> 00:25:32,480
to another one so we can use this to

795
00:25:32,480 --> 00:25:34,640
redirect access from our rootkit file

796
00:25:34,640 --> 00:25:37,840
to a legitimate driver file so again

797
00:25:37,840 --> 00:25:39,840
going back to the previous picking a

798
00:25:39,840 --> 00:25:40,960
method slide

799
00:25:40,960 --> 00:25:42,400
you were concerned about detection

800
00:25:42,400 --> 00:25:44,720
vectors how usable is the method

801
00:25:44,720 --> 00:25:49,360
and how expensive is it to detect

802
00:25:49,760 --> 00:25:51,760
the easiest way to abuse functionality

803
00:25:51,760 --> 00:25:52,880
of a mini filter

804
00:25:52,880 --> 00:25:55,919
is to become one yourself here here's

805
00:25:55,919 --> 00:25:57,279
the minimum requirements for flt

806
00:25:57,279 --> 00:25:58,559
register filter

807
00:25:58,559 --> 00:26:00,559
first you create an instances key under

808
00:26:00,559 --> 00:26:01,760
the service key

809
00:26:01,760 --> 00:26:03,760
then under the instances key you create

810
00:26:03,760 --> 00:26:05,279
an instance name key

811
00:26:05,279 --> 00:26:07,520
this can be any name you'd like you'll

812
00:26:07,520 --> 00:26:09,840
use you'll use this name for step 3

813
00:26:09,840 --> 00:26:11,919
when you create a default instance value

814
00:26:11,919 --> 00:26:13,919
under the instances key

815
00:26:13,919 --> 00:26:15,919
and you set this name to the string

816
00:26:15,919 --> 00:26:18,559
value to the name you used in step 2.

817
00:26:18,559 --> 00:26:20,960
and finally in step 4 well under the

818
00:26:20,960 --> 00:26:22,080
instance name key

819
00:26:22,080 --> 00:26:23,760
we'll add we'll add the altitude and

820
00:26:23,760 --> 00:26:26,799
flags values

821
00:26:26,799 --> 00:26:28,240
so how many detection vectors are you

822
00:26:28,240 --> 00:26:29,760
potentially exposed to well you're going

823
00:26:29,760 --> 00:26:31,440
to be exposing yourself to registry and

824
00:26:31,440 --> 00:26:32,880
memory artifacts

825
00:26:32,880 --> 00:26:34,960
how usable is the method there's no

826
00:26:34,960 --> 00:26:36,720
concerns from a stability or usability

827
00:26:36,720 --> 00:26:37,440
perspective

828
00:26:37,440 --> 00:26:39,360
because this is how legitimate drivers

829
00:26:39,360 --> 00:26:41,360
register as a mini filter

830
00:26:41,360 --> 00:26:43,600
how expensive is it to detect well

831
00:26:43,600 --> 00:26:44,400
besides

832
00:26:44,400 --> 00:26:46,400
the registry artifacts you're going to

833
00:26:46,400 --> 00:26:47,840
be easily enumerable

834
00:26:47,840 --> 00:26:49,760
through functions such as flt enumerate

835
00:26:49,760 --> 00:26:50,880
filters

836
00:26:50,880 --> 00:26:54,000
and also filters can be enumerated from

837
00:26:54,000 --> 00:26:56,000
user mode with administrative privileges

838
00:26:56,000 --> 00:26:57,919
so really it's not that expensive to

839
00:26:57,919 --> 00:27:00,400
detect

840
00:27:00,400 --> 00:27:02,400
so another method is to just simply hook

841
00:27:02,400 --> 00:27:03,760
an existing mini filter

842
00:27:03,760 --> 00:27:05,039
and there's a couple of routes you can

843
00:27:05,039 --> 00:27:06,960
take you can code hook an

844
00:27:06,960 --> 00:27:10,080
existing callback or you can overwrite

845
00:27:10,080 --> 00:27:12,080
the flt registration structure

846
00:27:12,080 --> 00:27:14,320
that is used in the call to flt register

847
00:27:14,320 --> 00:27:15,600
filter

848
00:27:15,600 --> 00:27:18,480
before that function is actually called

849
00:27:18,480 --> 00:27:19,679
or you can decom

850
00:27:19,679 --> 00:27:22,240
an existing filter instance and replace

851
00:27:22,240 --> 00:27:25,600
the original callback with yours

852
00:27:25,840 --> 00:27:27,840
so again one of the easiest ways of

853
00:27:27,840 --> 00:27:29,600
intercepting callbacks is just perform a

854
00:27:29,600 --> 00:27:30,480
code hook

855
00:27:30,480 --> 00:27:31,760
there's going to be quite a few

856
00:27:31,760 --> 00:27:34,000
drawbacks even if you did something as

857
00:27:34,000 --> 00:27:37,039
simple as a jump book

858
00:27:37,200 --> 00:27:38,159
you're gonna be exposing yourself to

859
00:27:38,159 --> 00:27:39,760
memory artifacts you're gonna need to

860
00:27:39,760 --> 00:27:41,440
find a function yourself

861
00:27:41,440 --> 00:27:42,960
it's not compatible with patch card or

862
00:27:42,960 --> 00:27:44,799
hvci and

863
00:27:44,799 --> 00:27:48,000
it's gonna be pretty easy to detect

864
00:27:48,000 --> 00:27:50,880
to you uh because there's just so many

865
00:27:50,880 --> 00:27:54,240
different ways of detecting hooking

866
00:27:54,240 --> 00:27:56,080
so another semi-documented method of

867
00:27:56,080 --> 00:27:58,640
hooking is using an existing mini filter

868
00:27:58,640 --> 00:28:00,159
so what you can do is you can enumerate

869
00:28:00,159 --> 00:28:02,000
filters in their instances using flt

870
00:28:02,000 --> 00:28:03,279
enumerate filters

871
00:28:03,279 --> 00:28:05,919
and eval enumerate instances the

872
00:28:05,919 --> 00:28:07,840
function that gets called for a certain

873
00:28:07,840 --> 00:28:09,120
operation

874
00:28:09,120 --> 00:28:11,360
is specified in the flt instance

875
00:28:11,360 --> 00:28:12,880
structure

876
00:28:12,880 --> 00:28:15,120
so this flt instance structure has this

877
00:28:15,120 --> 00:28:16,720
callback nodes array

878
00:28:16,720 --> 00:28:18,799
and what this array contains is the free

879
00:28:18,799 --> 00:28:20,559
operation and post operation

880
00:28:20,559 --> 00:28:22,720
depending on the array index which is

881
00:28:22,720 --> 00:28:25,039
associated with the major function

882
00:28:25,039 --> 00:28:26,799
so what you can do is you can find the

883
00:28:26,799 --> 00:28:28,080
flt instance

884
00:28:28,080 --> 00:28:30,159
by first enumerating filters and then

885
00:28:30,159 --> 00:28:32,480
enumerating instances for that filter

886
00:28:32,480 --> 00:28:34,080
and if there's a callback node you'd

887
00:28:34,080 --> 00:28:35,919
like to replace you just simply set the

888
00:28:35,919 --> 00:28:38,159
pre-operation or post operation function

889
00:28:38,159 --> 00:28:41,200
to your own now a note with this is that

890
00:28:41,200 --> 00:28:42,960
you're going to also want to patch

891
00:28:42,960 --> 00:28:45,600
the flt filter structure as well which

892
00:28:45,600 --> 00:28:48,399
contains an flt registration structure

893
00:28:48,399 --> 00:28:49,840
this is because you don't want to leave

894
00:28:49,840 --> 00:28:51,440
any traces of your hooking

895
00:28:51,440 --> 00:28:53,039
so what you're going to want to do is

896
00:28:53,039 --> 00:28:54,799
inside of that registration structure

897
00:28:54,799 --> 00:28:56,960
inside of the filter structure

898
00:28:56,960 --> 00:28:58,799
is replace the pre-operation or post

899
00:28:58,799 --> 00:29:00,240
operation there as well

900
00:29:00,240 --> 00:29:02,240
now this doesn't have any actual impact

901
00:29:02,240 --> 00:29:03,600
other than making sure

902
00:29:03,600 --> 00:29:05,760
that the values align with the function

903
00:29:05,760 --> 00:29:08,240
that you're hooking

904
00:29:08,240 --> 00:29:09,760
so how many detection vectors are you

905
00:29:09,760 --> 00:29:11,520
potentially exposed to well you're going

906
00:29:11,520 --> 00:29:12,960
to be potentially exposed to memory

907
00:29:12,960 --> 00:29:13,840
artifacts

908
00:29:13,840 --> 00:29:16,960
how usable is the method now since

909
00:29:16,960 --> 00:29:18,720
finding an flt instance is

910
00:29:18,720 --> 00:29:20,000
semi-documented

911
00:29:20,000 --> 00:29:22,799
it's going to be pretty stable but the

912
00:29:22,799 --> 00:29:24,640
flt instance structure itself is

913
00:29:24,640 --> 00:29:25,679
undocumented so

914
00:29:25,679 --> 00:29:28,399
that can change randomly as well how

915
00:29:28,399 --> 00:29:30,000
expensive is it to detect

916
00:29:30,000 --> 00:29:31,760
it's going to be still relatively

917
00:29:31,760 --> 00:29:33,279
inexpensive because

918
00:29:33,279 --> 00:29:35,279
an antivirus can enumerate these filters

919
00:29:35,279 --> 00:29:36,320
and their instances

920
00:29:36,320 --> 00:29:38,480
and then check to see if any of the

921
00:29:38,480 --> 00:29:39,840
functions

922
00:29:39,840 --> 00:29:43,760
are outside of the bounds of the driver

923
00:29:45,520 --> 00:29:48,480
so let's say you have a mini filter and

924
00:29:48,480 --> 00:29:50,000
you like to abuse it what's an example

925
00:29:50,000 --> 00:29:50,640
of that

926
00:29:50,640 --> 00:29:52,320
well what you can do is inside of the

927
00:29:52,320 --> 00:29:54,640
pre-create callback

928
00:29:54,640 --> 00:29:57,360
you can use flt get name information to

929
00:29:57,360 --> 00:29:59,919
get the path of the file being accessed

930
00:29:59,919 --> 00:30:02,960
if a path contains a protected file you

931
00:30:02,960 --> 00:30:04,559
can replace that file name

932
00:30:04,559 --> 00:30:07,840
using i o replace file object name then

933
00:30:07,840 --> 00:30:09,760
if you return status reparse

934
00:30:09,760 --> 00:30:11,840
what will happen is that file access

935
00:30:11,840 --> 00:30:13,200
will be redirected

936
00:30:13,200 --> 00:30:15,600
to that brand new file and so what we

937
00:30:15,600 --> 00:30:16,880
can do is then when

938
00:30:16,880 --> 00:30:18,799
a person accesses our rootkit on the

939
00:30:18,799 --> 00:30:19,919
file system

940
00:30:19,919 --> 00:30:21,279
we can then redirect it to another

941
00:30:21,279 --> 00:30:23,440
legitimate driver so that it appears to

942
00:30:23,440 --> 00:30:26,159
be legitimate

943
00:30:27,120 --> 00:30:29,279
all right so wrapping up i'd like to

944
00:30:29,279 --> 00:30:31,200
give thanks to alex ionescu

945
00:30:31,200 --> 00:30:33,360
who's been a longtime mentor and is very

946
00:30:33,360 --> 00:30:36,000
experienced with windows internals

947
00:30:36,000 --> 00:30:38,880
react os because their documentation and

948
00:30:38,880 --> 00:30:39,840
source code is

949
00:30:39,840 --> 00:30:41,840
fantastic when you're reversing windows

950
00:30:41,840 --> 00:30:43,520
itself

951
00:30:43,520 --> 00:30:46,640
nemanja mas magic and vlad ionescu who

952
00:30:46,640 --> 00:30:49,600
helped review this presentation

953
00:30:49,600 --> 00:30:51,840
so thank you so much for coming to my

954
00:30:51,840 --> 00:30:54,320
talk uh during these hard times and

955
00:30:54,320 --> 00:30:56,559
i appreciate you coming out if you'd

956
00:30:56,559 --> 00:30:57,760
like to follow me on twitter

957
00:30:57,760 --> 00:30:59,760
you that's my twitter handle check out

958
00:30:59,760 --> 00:31:01,279
my blog and if you'd like to check out

959
00:31:01,279 --> 00:31:02,480
the spectre rootkit

960
00:31:02,480 --> 00:31:04,240
there's a link available hopefully it'll

961
00:31:04,240 --> 00:31:06,480
work

962
00:31:09,760 --> 00:31:11,919
hi there guys uh and thanks for coming

963
00:31:11,919 --> 00:31:13,120
out to my talk

964
00:31:13,120 --> 00:31:14,960
i'll be answering questions in chat now

965
00:31:14,960 --> 00:31:16,559
and uh if you ever want to reach out

966
00:31:16,559 --> 00:31:17,600
with any more

967
00:31:17,600 --> 00:31:19,679
feel free to contact me over twitter or

968
00:31:19,679 --> 00:31:23,919
by email

