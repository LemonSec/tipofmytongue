1
00:00:04,230 --> 00:00:14,050
[Music]

2
00:00:15,599 --> 00:00:17,119
hello and welcome to

3
00:00:17,119 --> 00:00:19,680
our talk my name is daniel and i will

4
00:00:19,680 --> 00:00:20,320
start

5
00:00:20,320 --> 00:00:23,039
with uh introducing you to rohammer and

6
00:00:23,039 --> 00:00:25,199
you might remember row hammer js

7
00:00:25,199 --> 00:00:28,320
it took the known row hammer attack and

8
00:00:28,320 --> 00:00:31,199
was able to gain root privileges just

9
00:00:31,199 --> 00:00:31,519
from

10
00:00:31,519 --> 00:00:34,160
a web browser from a website how do we

11
00:00:34,160 --> 00:00:36,160
get to these bit flips well row hammer

12
00:00:36,160 --> 00:00:38,719
is a problem in dram cells and if you

13
00:00:38,719 --> 00:00:40,079
look at dram

14
00:00:40,079 --> 00:00:42,160
you will see that this chip is split

15
00:00:42,160 --> 00:00:44,000
into multiple banks and you will have

16
00:00:44,000 --> 00:00:47,520
rows maybe something like 32 000 rows

17
00:00:47,520 --> 00:00:50,800
and these rows also have a row buffer

18
00:00:50,800 --> 00:00:53,440
if you read from a row then things have

19
00:00:53,440 --> 00:00:56,000
to be copied into this row buffer

20
00:00:56,000 --> 00:00:58,239
the rows themselves they are basically

21
00:00:58,239 --> 00:00:59,680
they store the single bits

22
00:00:59,680 --> 00:01:02,000
um and that's basically capacitor and

23
00:01:02,000 --> 00:01:02,719
transistor

24
00:01:02,719 --> 00:01:05,040
the capacitor is charged to store a

25
00:01:05,040 --> 00:01:08,240
value of one or zero

26
00:01:08,240 --> 00:01:11,439
okay and the next step uh how

27
00:01:11,439 --> 00:01:14,479
does rowhammer work well these cells

28
00:01:14,479 --> 00:01:17,200
these are capacitors they leak over time

29
00:01:17,200 --> 00:01:18,479
so they need to be

30
00:01:18,479 --> 00:01:21,840
refreshed regularly

31
00:01:21,840 --> 00:01:25,280
and what you can do here is you can

32
00:01:25,280 --> 00:01:28,560
access certain rows in this

33
00:01:28,560 --> 00:01:31,840
dram bank and

34
00:01:31,840 --> 00:01:35,040
by accessing a row you will discharge

35
00:01:35,040 --> 00:01:37,119
not only the cells that you are reading

36
00:01:37,119 --> 00:01:39,439
and copying into the row buffer but also

37
00:01:39,439 --> 00:01:42,000
close by cells that are in proximity to

38
00:01:42,000 --> 00:01:43,040
these cells

39
00:01:43,040 --> 00:01:45,119
and this is what we call the row hammer

40
00:01:45,119 --> 00:01:46,399
effect

41
00:01:46,399 --> 00:01:49,200
so to guarantee data integrity you have

42
00:01:49,200 --> 00:01:51,439
to refresh very frequently so that this

43
00:01:51,439 --> 00:01:52,399
effect

44
00:01:52,399 --> 00:01:55,680
and other effects don't occur so

45
00:01:55,680 --> 00:01:57,680
you activate a row you copy it into the

46
00:01:57,680 --> 00:01:59,759
row buffer you activate the other row

47
00:01:59,759 --> 00:02:02,560
you copy it into the row buffer and then

48
00:02:02,560 --> 00:02:04,640
after some time you see bit flips in the

49
00:02:04,640 --> 00:02:05,920
middle row

50
00:02:05,920 --> 00:02:07,680
now what can you do with that well you

51
00:02:07,680 --> 00:02:09,440
can exploit this in different ways for

52
00:02:09,440 --> 00:02:09,919
instance

53
00:02:09,919 --> 00:02:13,440
flipping um bits in code and here is an

54
00:02:13,440 --> 00:02:14,160
example

55
00:02:14,160 --> 00:02:16,239
uh for instance if you look at sudo

56
00:02:16,239 --> 00:02:19,200
there is this jump equal instruction

57
00:02:19,200 --> 00:02:20,959
that is used for the password check if

58
00:02:20,959 --> 00:02:22,720
you enter the password correctly then

59
00:02:22,720 --> 00:02:24,640
the jump equal will be true

60
00:02:24,640 --> 00:02:26,720
and it will jump to the location and

61
00:02:26,720 --> 00:02:28,800
will uh give you this elevated

62
00:02:28,800 --> 00:02:30,080
privileges

63
00:02:30,080 --> 00:02:32,879
however if not then it will terminate

64
00:02:32,879 --> 00:02:34,400
and you won't get the privileges but

65
00:02:34,400 --> 00:02:36,400
what happens if we flip a bit in exactly

66
00:02:36,400 --> 00:02:36,800
this

67
00:02:36,800 --> 00:02:38,720
jump instruction well if we flip the

68
00:02:38,720 --> 00:02:40,319
first bit it becomes the heart

69
00:02:40,319 --> 00:02:41,519
instruction

70
00:02:41,519 --> 00:02:44,640
xor push some prefix for other

71
00:02:44,640 --> 00:02:46,080
instructions

72
00:02:46,080 --> 00:02:48,480
um other jump instructions that might be

73
00:02:48,480 --> 00:02:50,480
exploitable already

74
00:02:50,480 --> 00:02:52,800
and the last one great if we flip one

75
00:02:52,800 --> 00:02:54,239
bit we get go from

76
00:02:54,239 --> 00:02:57,599
jump equal to jump not equal and then

77
00:02:57,599 --> 00:03:01,280
sudo will give anyone uh root privileges

78
00:03:01,280 --> 00:03:03,599
who does not enter the correct password

79
00:03:03,599 --> 00:03:05,040
but not to the person entering the

80
00:03:05,040 --> 00:03:05,920
correct password

81
00:03:05,920 --> 00:03:08,319
this is great and this allows us to

82
00:03:08,319 --> 00:03:09,040
exploit

83
00:03:09,040 --> 00:03:11,920
row hammer but ddr3 is affected ddr4 is

84
00:03:11,920 --> 00:03:12,640
affected

85
00:03:12,640 --> 00:03:16,400
even ecc ram can have errors

86
00:03:16,400 --> 00:03:19,599
that are not corrected by the integrated

87
00:03:19,599 --> 00:03:21,280
error correction

88
00:03:21,280 --> 00:03:23,280
the question then is if you think about

89
00:03:23,280 --> 00:03:24,319
sgx

90
00:03:24,319 --> 00:03:27,040
intel's sgx security enclaves they are

91
00:03:27,040 --> 00:03:28,560
integrity protected

92
00:03:28,560 --> 00:03:31,040
and this would prevent rohammer in

93
00:03:31,040 --> 00:03:32,560
principle because

94
00:03:32,560 --> 00:03:35,760
you would detect the integrity error

95
00:03:35,760 --> 00:03:37,840
um actually daniel this is meant to be a

96
00:03:37,840 --> 00:03:39,360
talk about how to flip bits

97
00:03:39,360 --> 00:03:42,799
without row hammer

98
00:03:43,200 --> 00:03:46,239
sorry yes i was getting to that kid

99
00:03:46,239 --> 00:03:48,640
i was i was getting there but can you

100
00:03:48,640 --> 00:03:50,959
please not just walk into my slides

101
00:03:50,959 --> 00:03:54,159
well i'll take over for a little bit

102
00:03:54,159 --> 00:03:57,680
so let's talk about plunder vault

103
00:03:57,680 --> 00:03:59,439
plundervolt is flipping bits from

104
00:03:59,439 --> 00:04:01,760
software but without row hammer

105
00:04:01,760 --> 00:04:03,519
and the first thing we did is we did

106
00:04:03,519 --> 00:04:05,120
something called fault injection

107
00:04:05,120 --> 00:04:07,200
yes i know what fault injection is i do

108
00:04:07,200 --> 00:04:09,120
that all the time so you have to have

109
00:04:09,120 --> 00:04:12,000
some specialized lab equipment and you

110
00:04:12,000 --> 00:04:14,000
maybe need some to sort of some cables

111
00:04:14,000 --> 00:04:15,439
to the pins of the chip

112
00:04:15,439 --> 00:04:17,120
and then you can play around maybe with

113
00:04:17,120 --> 00:04:19,279
the voltage or so to flip some bits in

114
00:04:19,279 --> 00:04:19,839
the chip

115
00:04:19,839 --> 00:04:21,918
you mean like the picture wall actually

116
00:04:21,918 --> 00:04:23,120
not anymore

117
00:04:23,120 --> 00:04:25,840
so now you can modify hardware from

118
00:04:25,840 --> 00:04:27,759
software so you can effectively create

119
00:04:27,759 --> 00:04:30,000
hardware fault injection attacks

120
00:04:30,000 --> 00:04:33,280
using software okay so you say basically

121
00:04:33,280 --> 00:04:34,560
this replaces my

122
00:04:34,560 --> 00:04:36,240
whole lab equipment and so on with this

123
00:04:36,240 --> 00:04:38,000
memory mapped register so

124
00:04:38,000 --> 00:04:41,199
what is that that's exactly right so

125
00:04:41,199 --> 00:04:44,160
you can in software write to a memory

126
00:04:44,160 --> 00:04:45,360
maps register

127
00:04:45,360 --> 00:04:48,479
which then modifies the hardware and the

128
00:04:48,479 --> 00:04:50,080
reason you might want to do this

129
00:04:50,080 --> 00:04:52,479
is because you might have a gaming

130
00:04:52,479 --> 00:04:54,320
machine that you want to respond really

131
00:04:54,320 --> 00:04:55,360
really quickly

132
00:04:55,360 --> 00:04:57,520
or you might have a computer in the

133
00:04:57,520 --> 00:04:58,720
cloud that you want to have

134
00:04:58,720 --> 00:05:01,759
low power consumption or your machine

135
00:05:01,759 --> 00:05:02,560
might be getting

136
00:05:02,560 --> 00:05:05,199
really really hot and this gives the

137
00:05:05,199 --> 00:05:06,720
operating system a way

138
00:05:06,720 --> 00:05:08,639
to dynamically change maybe the

139
00:05:08,639 --> 00:05:10,160
frequency or voltage

140
00:05:10,160 --> 00:05:13,039
to protect the chip okay it sounds like

141
00:05:13,039 --> 00:05:14,560
a lot less hassle than

142
00:05:14,560 --> 00:05:16,320
like fiddling around with the hardware

143
00:05:16,320 --> 00:05:18,800
and all the time we short something and

144
00:05:18,800 --> 00:05:20,240
destroy something yeah and this is

145
00:05:20,240 --> 00:05:20,800
called

146
00:05:20,800 --> 00:05:23,280
dynamic voltage and frequency scaling

147
00:05:23,280 --> 00:05:24,800
this has been used

148
00:05:24,800 --> 00:05:26,960
in the first of its kind attack in

149
00:05:26,960 --> 00:05:27,919
something called

150
00:05:27,919 --> 00:05:31,039
clock screw a clock screw exposing the

151
00:05:31,039 --> 00:05:33,199
perils of security oblivious

152
00:05:33,199 --> 00:05:36,400
energy management and what they did is

153
00:05:36,400 --> 00:05:39,840
in software they modified the

154
00:05:39,840 --> 00:05:42,880
code which changed the frequency

155
00:05:42,880 --> 00:05:46,720
which caused faults and

156
00:05:46,720 --> 00:05:49,600
from this they were also able to fault

157
00:05:49,600 --> 00:05:50,080
something

158
00:05:50,080 --> 00:05:52,639
inside trust zone because the frequency

159
00:05:52,639 --> 00:05:54,720
and the voltage regulators

160
00:05:54,720 --> 00:05:57,120
are the same they manage the same

161
00:05:57,120 --> 00:05:58,560
voltage and frequency whether you're

162
00:05:58,560 --> 00:05:59,199
running

163
00:05:59,199 --> 00:06:02,240
untrusted code or theoretically trusted

164
00:06:02,240 --> 00:06:03,120
code

165
00:06:03,120 --> 00:06:05,120
and this is their attack they were able

166
00:06:05,120 --> 00:06:08,000
to an infer a secret aes key that was

167
00:06:08,000 --> 00:06:09,600
stored within trust zone

168
00:06:09,600 --> 00:06:11,440
and they were able to trick trustzone

169
00:06:11,440 --> 00:06:13,280
into loading a self-signed

170
00:06:13,280 --> 00:06:15,840
application not long after there was

171
00:06:15,840 --> 00:06:16,639
another

172
00:06:16,639 --> 00:06:18,720
attack very similar called vault jockey

173
00:06:18,720 --> 00:06:20,639
again this focused on an

174
00:06:20,639 --> 00:06:22,479
arm chip though they were both attacks

175
00:06:22,479 --> 00:06:24,720
against arm

176
00:06:24,720 --> 00:06:26,160
wait a second wait a second you're

177
00:06:26,160 --> 00:06:28,160
talking all about attacks that already

178
00:06:28,160 --> 00:06:30,160
exist and yes okay we know you can

179
00:06:30,160 --> 00:06:30,560
attack

180
00:06:30,560 --> 00:06:33,520
arm chips like that but you know that uh

181
00:06:33,520 --> 00:06:34,000
intel

182
00:06:34,000 --> 00:06:36,479
has a very very big market share on

183
00:06:36,479 --> 00:06:37,680
desktop computers

184
00:06:37,680 --> 00:06:40,479
so maybe we should also look at intel

185
00:06:40,479 --> 00:06:41,440
processors

186
00:06:41,440 --> 00:06:43,440
yeah but can you actually can you do

187
00:06:43,440 --> 00:06:45,120
that can you underclock and overclock on

188
00:06:45,120 --> 00:06:46,319
intel i don't know

189
00:06:46,319 --> 00:06:48,639
uh i actually did that when i was a

190
00:06:48,639 --> 00:06:49,599
teenager

191
00:06:49,599 --> 00:06:53,280
um because my system was running too hot

192
00:06:53,280 --> 00:06:55,280
and then i undervolted it and these

193
00:06:55,280 --> 00:06:57,919
tools um i also later on used this when

194
00:06:57,919 --> 00:06:58,720
i had

195
00:06:58,720 --> 00:07:01,680
some laptop um the under vaulting made a

196
00:07:01,680 --> 00:07:02,000
huge

197
00:07:02,000 --> 00:07:04,080
difference if you run a benchmark you

198
00:07:04,080 --> 00:07:06,160
would underwater the cpu not change the

199
00:07:06,160 --> 00:07:07,199
cpu frequency

200
00:07:07,199 --> 00:07:09,280
you would undervolt it and then you

201
00:07:09,280 --> 00:07:11,039
would get a higher benchmark

202
00:07:11,039 --> 00:07:14,479
score because the cpu runs into

203
00:07:14,479 --> 00:07:15,120
throttling

204
00:07:15,120 --> 00:07:17,680
less often and this is really

205
00:07:17,680 --> 00:07:18,639
interesting

206
00:07:18,639 --> 00:07:20,880
that means you can actually change the

207
00:07:20,880 --> 00:07:22,240
voltage from software

208
00:07:22,240 --> 00:07:24,160
and i've also used different tools here

209
00:07:24,160 --> 00:07:25,599
for instance

210
00:07:25,599 --> 00:07:28,960
i used the rm clock tool but there are

211
00:07:28,960 --> 00:07:30,639
many different tools that you can use

212
00:07:30,639 --> 00:07:31,440
for that

213
00:07:31,440 --> 00:07:33,520
um and today it's quite normal that you

214
00:07:33,520 --> 00:07:36,000
would uh optimize the clock frequency

215
00:07:36,000 --> 00:07:37,039
and the voltage

216
00:07:37,039 --> 00:07:39,759
on gaming computers uh or also on

217
00:07:39,759 --> 00:07:42,000
laptops so that they don't overheat all

218
00:07:42,000 --> 00:07:43,280
the time

219
00:07:43,280 --> 00:07:45,919
so if you look at these tools you will

220
00:07:45,919 --> 00:07:47,440
figure out that

221
00:07:47,440 --> 00:07:50,639
they use some secret

222
00:07:50,639 --> 00:07:55,520
msr msr hex 150

223
00:07:55,520 --> 00:07:58,879
and we looked a bit at this msr

224
00:07:58,879 --> 00:08:02,400
and we can identify uh what

225
00:08:02,400 --> 00:08:05,680
uh bit that serves which purpose yeah

226
00:08:05,680 --> 00:08:06,400
and this

227
00:08:06,400 --> 00:08:09,520
model specific register this msr has

228
00:08:09,520 --> 00:08:11,599
many functions but we're just showing

229
00:08:11,599 --> 00:08:13,360
the voltage functions here so you've got

230
00:08:13,360 --> 00:08:14,479
the offset

231
00:08:14,479 --> 00:08:17,360
which is over and under volting and

232
00:08:17,360 --> 00:08:19,120
you've got static voltage

233
00:08:19,120 --> 00:08:21,440
and we're specifically looking at under

234
00:08:21,440 --> 00:08:22,800
vaulting

235
00:08:22,800 --> 00:08:25,360
so let's have a look at c code and see

236
00:08:25,360 --> 00:08:26,080
how you actually

237
00:08:26,080 --> 00:08:28,319
run that so the first thing we're going

238
00:08:28,319 --> 00:08:29,120
to need to do

239
00:08:29,120 --> 00:08:31,120
is to set the frequency to be one

240
00:08:31,120 --> 00:08:32,159
specific thing

241
00:08:32,159 --> 00:08:33,760
because we're going to be modifying the

242
00:08:33,760 --> 00:08:36,080
voltage so you want the frequency to

243
00:08:36,080 --> 00:08:37,839
stay the same but the voltage

244
00:08:37,839 --> 00:08:40,080
to be changed and we're setting for this

245
00:08:40,080 --> 00:08:41,599
particular machine we're setting it to

246
00:08:41,599 --> 00:08:42,000
one

247
00:08:42,000 --> 00:08:44,159
gigahertz and i'm just going to check

248
00:08:44,159 --> 00:08:46,480
that that has taken

249
00:08:46,480 --> 00:08:48,080
and yet we're now running at one

250
00:08:48,080 --> 00:08:50,320
gigahertz and the next thing that we're

251
00:08:50,320 --> 00:08:51,120
going to need to do

252
00:08:51,120 --> 00:08:54,480
is to load the msr driver because it's

253
00:08:54,480 --> 00:08:57,839
not explicitly loaded

254
00:08:58,160 --> 00:08:59,680
and now we're going to look at how you

255
00:08:59,680 --> 00:09:01,600
actually change the voltage so what you

256
00:09:01,600 --> 00:09:02,240
need to do

257
00:09:02,240 --> 00:09:06,080
is to open the msr see if you can spot

258
00:09:06,080 --> 00:09:09,839
the line of code that does that

259
00:09:10,880 --> 00:09:13,360
yep there it is and here's where we

260
00:09:13,360 --> 00:09:15,200
write to the msr

261
00:09:15,200 --> 00:09:16,640
and you only need to write to one of the

262
00:09:16,640 --> 00:09:18,240
cpus because they all

263
00:09:18,240 --> 00:09:20,720
share the same voltage you'll notice

264
00:09:20,720 --> 00:09:22,480
that we're writing to two planes plane

265
00:09:22,480 --> 00:09:24,000
zero and plane two

266
00:09:24,000 --> 00:09:26,560
that's the cpu core and also the cache

267
00:09:26,560 --> 00:09:28,399
and you need to write to both of them

268
00:09:28,399 --> 00:09:30,480
because the msi will take the higher of

269
00:09:30,480 --> 00:09:32,320
the two

270
00:09:32,320 --> 00:09:34,480
and now that we know that we are able to

271
00:09:34,480 --> 00:09:36,880
undervolt what can we do with that

272
00:09:36,880 --> 00:09:39,760
well let's write some code to see if we

273
00:09:39,760 --> 00:09:42,399
can possibly get this to fault

274
00:09:42,399 --> 00:09:44,240
can you see what my code is doing okay

275
00:09:44,240 --> 00:09:45,680
let me check

276
00:09:45,680 --> 00:09:47,760
so this is a while loop and you

277
00:09:47,760 --> 00:09:49,600
initialized var and correct

278
00:09:49,600 --> 00:09:53,360
the same value and then you also compute

279
00:09:53,360 --> 00:09:54,240
all the time

280
00:09:54,240 --> 00:09:57,839
same value again yeah so this will never

281
00:09:57,839 --> 00:10:00,160
stop

282
00:10:00,560 --> 00:10:02,800
where did you learn to program where did

283
00:10:02,800 --> 00:10:04,560
i learn to program

284
00:10:04,560 --> 00:10:07,200
at birmingham university uh so let's

285
00:10:07,200 --> 00:10:08,640
take a look at it in action

286
00:10:08,640 --> 00:10:10,640
so here we go i'm multiplying dead beef

287
00:10:10,640 --> 00:10:12,480
by one one two two three three four four

288
00:10:12,480 --> 00:10:13,279
five five

289
00:10:13,279 --> 00:10:16,880
i'm under volting minus 252 millivolts

290
00:10:16,880 --> 00:10:20,399
three four five oh come on yeah

291
00:10:20,399 --> 00:10:23,040
we got a fault we got an incorrect

292
00:10:23,040 --> 00:10:24,720
multiplication result and if you look at

293
00:10:24,720 --> 00:10:25,040
the

294
00:10:25,040 --> 00:10:28,560
xor it's a bit flip so then we started

295
00:10:28,560 --> 00:10:30,160
just trying random numbers so we're just

296
00:10:30,160 --> 00:10:32,079
generating a whole set of random numbers

297
00:10:32,079 --> 00:10:33,279
to see if we get

298
00:10:33,279 --> 00:10:35,120
any other faults can we follow a

299
00:10:35,120 --> 00:10:37,279
different multiplication

300
00:10:37,279 --> 00:10:40,560
and again we got another bit flip

301
00:10:40,560 --> 00:10:42,000
so at this point we just did lots and

302
00:10:42,000 --> 00:10:44,000
lots of random numbers and we started to

303
00:10:44,000 --> 00:10:45,680
see not just one bit flip

304
00:10:45,680 --> 00:10:47,200
but there you go we've got more we've

305
00:10:47,200 --> 00:10:49,360
got more bit flips and in different

306
00:10:49,360 --> 00:10:50,399
locations

307
00:10:50,399 --> 00:10:53,200
so we have just managed to create bit

308
00:10:53,200 --> 00:10:54,000
flips

309
00:10:54,000 --> 00:10:57,440
by lowering the voltage in user space

310
00:10:57,440 --> 00:11:00,720
and this is where we come to intel sjx

311
00:11:00,720 --> 00:11:01,600
because

312
00:11:01,600 --> 00:11:04,399
we need root privileges to write msr so

313
00:11:04,399 --> 00:11:06,399
a user space fault in itself is not very

314
00:11:06,399 --> 00:11:08,000
useful because we

315
00:11:08,000 --> 00:11:10,640
if we root we can do anyway anything in

316
00:11:10,640 --> 00:11:12,640
user space right

317
00:11:12,640 --> 00:11:15,200
so that's where intel sjx comes in as

318
00:11:15,200 --> 00:11:17,519
daniel said it's a technology to create

319
00:11:17,519 --> 00:11:20,800
trusted uh areas enclaves uh in your

320
00:11:20,800 --> 00:11:23,600
uh in your intel cpu so from an

321
00:11:23,600 --> 00:11:24,800
untrusted program

322
00:11:24,800 --> 00:11:27,279
you can create an enclave and then call

323
00:11:27,279 --> 00:11:29,839
trusted functions in that enclave

324
00:11:29,839 --> 00:11:31,680
but you cannot actually look at the

325
00:11:31,680 --> 00:11:33,920
memory of the enclave so if for instance

326
00:11:33,920 --> 00:11:35,839
the cryptographic signature is running

327
00:11:35,839 --> 00:11:37,120
inside the enclave

328
00:11:37,120 --> 00:11:39,360
you can kind of invoke signature but you

329
00:11:39,360 --> 00:11:41,600
cannot actually extract the key

330
00:11:41,600 --> 00:11:43,519
but if you're the operating system can't

331
00:11:43,519 --> 00:11:46,079
you just look at the data anyway

332
00:11:46,079 --> 00:11:49,440
no so that's a crucial part of sjx

333
00:11:49,440 --> 00:11:52,800
so even the operating system is

334
00:11:52,800 --> 00:11:54,720
untrusted and the operating system

335
00:11:54,720 --> 00:11:56,240
cannot read the enclave

336
00:11:56,240 --> 00:11:58,959
memory so how is it protected then how

337
00:11:58,959 --> 00:12:00,560
can you do that

338
00:12:00,560 --> 00:12:02,959
so that uses something called the memory

339
00:12:02,959 --> 00:12:03,760
encryption

340
00:12:03,760 --> 00:12:07,040
engine that encrypts and integrity

341
00:12:07,040 --> 00:12:08,079
protects

342
00:12:08,079 --> 00:12:10,480
all the data that is written to uh

343
00:12:10,480 --> 00:12:12,240
external dram

344
00:12:12,240 --> 00:12:14,240
so whenever an enclave writes something

345
00:12:14,240 --> 00:12:15,600
to memory it goes through this memory

346
00:12:15,600 --> 00:12:16,639
encryption engine

347
00:12:16,639 --> 00:12:18,959
is encrypted with a key that is not

348
00:12:18,959 --> 00:12:19,760
accessible

349
00:12:19,760 --> 00:12:22,240
even to the operating system and is then

350
00:12:22,240 --> 00:12:24,320
written into dram and vice versa when

351
00:12:24,320 --> 00:12:25,519
you read it back

352
00:12:25,519 --> 00:12:27,360
the memory encryption engine will first

353
00:12:27,360 --> 00:12:29,200
check that the data has not been changed

354
00:12:29,200 --> 00:12:30,399
for instance not

355
00:12:30,399 --> 00:12:32,079
that you have not flipped a bit with row

356
00:12:32,079 --> 00:12:33,760
hammer also in

357
00:12:33,760 --> 00:12:36,560
in dram and then only if that's valid it

358
00:12:36,560 --> 00:12:38,800
will pass it on to the enclave and

359
00:12:38,800 --> 00:12:43,760
provides a decrypted data to the enclave

360
00:12:45,200 --> 00:12:48,800
so if you inject a bit flip in

361
00:12:48,800 --> 00:12:50,639
enclave memory say with rawhammer what

362
00:12:50,639 --> 00:12:52,480
you get is that you will basically crash

363
00:12:52,480 --> 00:12:53,120
the system

364
00:12:53,120 --> 00:12:54,800
so you lock the memory controller and

365
00:12:54,800 --> 00:12:56,399
the system hauls

366
00:12:56,399 --> 00:12:58,240
that's kind of like a denial of service

367
00:12:58,240 --> 00:12:59,760
attack but you cannot do

368
00:12:59,760 --> 00:13:02,000
much much more with that so you cannot

369
00:13:02,000 --> 00:13:03,040
let's say flip

370
00:13:03,040 --> 00:13:06,399
bits inside uh enclave memory with rohan

371
00:13:06,399 --> 00:13:08,480
you're saying that rowhammer didn't work

372
00:13:08,480 --> 00:13:12,800
so my question is will plundervolt work

373
00:13:12,800 --> 00:13:16,000
so yes we will see that in a bit

374
00:13:16,000 --> 00:13:18,160
and plundervolt works because you inject

375
00:13:18,160 --> 00:13:19,200
the fault actually

376
00:13:19,200 --> 00:13:23,440
inside the cpu before the data is

377
00:13:23,440 --> 00:13:25,200
written into the encryption engine and

378
00:13:25,200 --> 00:13:26,720
from there then to memory

379
00:13:26,720 --> 00:13:28,480
so you kind of inject the bit flip in

380
00:13:28,480 --> 00:13:30,639
the cpu and then it's encrypted

381
00:13:30,639 --> 00:13:32,480
integrity protected and written to

382
00:13:32,480 --> 00:13:35,040
memory in so here we can see your

383
00:13:35,040 --> 00:13:37,680
multiplication example inside an enclave

384
00:13:37,680 --> 00:13:40,880
we go down in voltage one millivolt at a

385
00:13:40,880 --> 00:13:41,680
time

386
00:13:41,680 --> 00:13:44,880
and then at minus 265 millivolts

387
00:13:44,880 --> 00:13:47,760
here we have actually managed to flip a

388
00:13:47,760 --> 00:13:48,000
bit

389
00:13:48,000 --> 00:13:50,880
in a multiplication and as you can see

390
00:13:50,880 --> 00:13:53,519
that's actually exactly the same bit

391
00:13:53,519 --> 00:13:55,519
that we flipped in user space code

392
00:13:55,519 --> 00:13:56,800
before but this time

393
00:13:56,800 --> 00:13:59,839
inside an sgx enclave so

394
00:13:59,839 --> 00:14:02,240
yeah great you've flipped a bit inside

395
00:14:02,240 --> 00:14:02,959
sgx

396
00:14:02,959 --> 00:14:05,199
and it didn't lock up you didn't get an

397
00:14:05,199 --> 00:14:06,079
integrity

398
00:14:06,079 --> 00:14:09,040
error but it's just multiplications what

399
00:14:09,040 --> 00:14:12,240
on earth can you use that for

400
00:14:12,240 --> 00:14:14,399
well multiplication maybe uh not

401
00:14:14,399 --> 00:14:17,199
directly but um we can of course look at

402
00:14:17,199 --> 00:14:18,639
crypto so i like to break

403
00:14:18,639 --> 00:14:20,560
cryptographic algorithms and i used to

404
00:14:20,560 --> 00:14:21,680
do that with

405
00:14:21,680 --> 00:14:23,440
hardware fault attacks and now i can do

406
00:14:23,440 --> 00:14:25,279
it from software in

407
00:14:25,279 --> 00:14:28,720
sjx so for instance rsa well-known

408
00:14:28,720 --> 00:14:29,600
public key

409
00:14:29,600 --> 00:14:33,519
crypto algorithm and very often when rsa

410
00:14:33,519 --> 00:14:36,160
is actually implemented that uses a

411
00:14:36,160 --> 00:14:39,199
optimization called the chinese

412
00:14:39,199 --> 00:14:41,839
remainder theorem and for that we have a

413
00:14:41,839 --> 00:14:42,720
very

414
00:14:42,720 --> 00:14:45,440
very effective fault attack if we can

415
00:14:45,440 --> 00:14:48,160
inject a fault into that computation

416
00:14:48,160 --> 00:14:50,399
so i will not go into the mathematical

417
00:14:50,399 --> 00:14:51,920
details too much here

418
00:14:51,920 --> 00:14:55,199
just say that in normal rsa you have a

419
00:14:55,199 --> 00:14:57,680
public public modulus which is a product

420
00:14:57,680 --> 00:14:59,360
of two prime numbers

421
00:14:59,360 --> 00:15:01,680
and for instance when you decrypt a

422
00:15:01,680 --> 00:15:02,880
message using your

423
00:15:02,880 --> 00:15:06,000
private key you take the ciphertext to

424
00:15:06,000 --> 00:15:08,000
the power of your private exponent

425
00:15:08,000 --> 00:15:09,199
modulo

426
00:15:09,199 --> 00:15:11,920
n and then you get the message back now

427
00:15:11,920 --> 00:15:13,839
in this chinese remainder theorem that

428
00:15:13,839 --> 00:15:15,760
is a bit more complicated so kind of

429
00:15:15,760 --> 00:15:17,279
what you do is you split up the

430
00:15:17,279 --> 00:15:19,199
computation into two parts

431
00:15:19,199 --> 00:15:22,800
modulo p and modulo q and

432
00:15:22,800 --> 00:15:24,079
again i will not go into the

433
00:15:24,079 --> 00:15:26,480
mathematical details but if you manage

434
00:15:26,480 --> 00:15:27,199
to only

435
00:15:27,199 --> 00:15:29,639
fault one of these two

436
00:15:29,639 --> 00:15:31,040
sub-exponentiations

437
00:15:31,040 --> 00:15:33,680
they're very very efficient ways to

438
00:15:33,680 --> 00:15:34,560
recover

439
00:15:34,560 --> 00:15:36,160
one of the prime factors and then you

440
00:15:36,160 --> 00:15:38,079
can just divide the

441
00:15:38,079 --> 00:15:40,160
public modulus n by one of the prime

442
00:15:40,160 --> 00:15:41,360
factors and you

443
00:15:41,360 --> 00:15:43,759
get the other one got a question what

444
00:15:43,759 --> 00:15:44,959
are we we're trying to get p

445
00:15:44,959 --> 00:15:46,880
and q so what what does that give us if

446
00:15:46,880 --> 00:15:48,000
we've got p or q

447
00:15:48,000 --> 00:15:50,800
so that gives you the uh private key so

448
00:15:50,800 --> 00:15:51,680
you

449
00:15:51,680 --> 00:15:54,240
uh you get p and then you take the

450
00:15:54,240 --> 00:15:55,120
public value

451
00:15:55,120 --> 00:15:58,560
n divided by p for instance you get q

452
00:15:58,560 --> 00:16:01,199
and then you can also compute this uh d

453
00:16:01,199 --> 00:16:03,040
this private exponent

454
00:16:03,040 --> 00:16:07,120
so will plunder volt be able to do that

455
00:16:07,120 --> 00:16:10,000
of course plunder world uh can do that

456
00:16:10,000 --> 00:16:10,720
so there

457
00:16:10,720 --> 00:16:12,959
um just before i show the actual demos

458
00:16:12,959 --> 00:16:13,839
there are

459
00:16:13,839 --> 00:16:15,920
two ways to kind of recover one of the

460
00:16:15,920 --> 00:16:17,440
prime factors from

461
00:16:17,440 --> 00:16:20,880
a faulty uh in this case a decryption

462
00:16:20,880 --> 00:16:22,560
so one is called the bell core attack

463
00:16:22,560 --> 00:16:24,720
that needs the decryption

464
00:16:24,720 --> 00:16:27,519
uh once valid and one's faulty of the

465
00:16:27,519 --> 00:16:29,199
same cipher text

466
00:16:29,199 --> 00:16:30,800
and the other optimized variant is

467
00:16:30,800 --> 00:16:32,480
called the lenstra attack and that can

468
00:16:32,480 --> 00:16:34,000
work with a single

469
00:16:34,000 --> 00:16:36,320
faulty decryption which is great if

470
00:16:36,320 --> 00:16:38,079
there's some randomization

471
00:16:38,079 --> 00:16:40,800
in the scheme so we only need to get one

472
00:16:40,800 --> 00:16:42,480
fault to be able to get

473
00:16:42,480 --> 00:16:44,959
the private key out correct correct so

474
00:16:44,959 --> 00:16:45,680
let's look at

475
00:16:45,680 --> 00:16:48,880
an example we have here an sjx

476
00:16:48,880 --> 00:16:52,240
function so what we do in there is just

477
00:16:52,240 --> 00:16:54,480
use the intel library function

478
00:16:54,480 --> 00:16:57,680
ipps rsa decrypt which uses this

479
00:16:57,680 --> 00:17:00,399
chinese remainder cream optimization and

480
00:17:00,399 --> 00:17:01,680
we underwater

481
00:17:01,680 --> 00:17:04,160
and we undervolt until we get like a

482
00:17:04,160 --> 00:17:05,599
faulty uh

483
00:17:05,599 --> 00:17:08,559
until we get a faulty uh decryption so

484
00:17:08,559 --> 00:17:10,400
that we can see in this video here we do

485
00:17:10,400 --> 00:17:11,520
an rsa

486
00:17:11,520 --> 00:17:14,079
decryption and actually first get a

487
00:17:14,079 --> 00:17:14,880
correct

488
00:17:14,880 --> 00:17:17,119
result even though we're undervolting so

489
00:17:17,119 --> 00:17:18,000
we try again

490
00:17:18,000 --> 00:17:20,799
again get a correct result let's do

491
00:17:20,799 --> 00:17:21,760
another try

492
00:17:21,760 --> 00:17:24,480
and again we will get a correct result

493
00:17:24,480 --> 00:17:26,160
this time

494
00:17:26,160 --> 00:17:29,039
now if we try force time finally we'll

495
00:17:29,039 --> 00:17:29,360
get

496
00:17:29,360 --> 00:17:32,080
our desired faulty results we get a

497
00:17:32,080 --> 00:17:33,039
faulty

498
00:17:33,039 --> 00:17:36,160
decryption and that we can now put into

499
00:17:36,160 --> 00:17:39,440
our little python script here which

500
00:17:39,440 --> 00:17:41,280
implements a leinster attack

501
00:17:41,280 --> 00:17:43,760
to recover one of the prime factors in

502
00:17:43,760 --> 00:17:46,160
this case a value starting with

503
00:17:46,160 --> 00:17:49,360
eecf and now to prove that we actually

504
00:17:49,360 --> 00:17:50,640
haven't cheated

505
00:17:50,640 --> 00:17:53,280
let's look into the enclave code here

506
00:17:53,280 --> 00:17:54,400
and let's see

507
00:17:54,400 --> 00:17:57,200
which kind of value was hard coded there

508
00:17:57,200 --> 00:17:57,840
and

509
00:17:57,840 --> 00:18:00,080
we'll also check like for the first few

510
00:18:00,080 --> 00:18:01,840
digits of our um

511
00:18:01,840 --> 00:18:04,960
of our coefficient and then we see that

512
00:18:04,960 --> 00:18:06,000
we have recovered

513
00:18:06,000 --> 00:18:10,400
p here so you've got the private key

514
00:18:10,400 --> 00:18:13,679
out of of something happening inside an

515
00:18:13,679 --> 00:18:15,039
enclave

516
00:18:15,039 --> 00:18:17,280
just by under vaulting yes exactly and

517
00:18:17,280 --> 00:18:19,039
that is uh things that should not be

518
00:18:19,039 --> 00:18:20,960
possible right that's why there's uh

519
00:18:20,960 --> 00:18:21,679
integrity

520
00:18:21,679 --> 00:18:24,320
protection on the memory so if you can

521
00:18:24,320 --> 00:18:25,360
do it

522
00:18:25,360 --> 00:18:28,080
for rsa what else could you do it for

523
00:18:28,080 --> 00:18:29,520
the are there other more

524
00:18:29,520 --> 00:18:32,160
commonly used cryptographic algorithms

525
00:18:32,160 --> 00:18:33,760
you could try

526
00:18:33,760 --> 00:18:35,919
uh so yes certainly i like to break

527
00:18:35,919 --> 00:18:37,200
crypto so i'll stay a bit

528
00:18:37,200 --> 00:18:39,280
more with the crypto so yeah the

529
00:18:39,280 --> 00:18:41,600
question is what else can we break

530
00:18:41,600 --> 00:18:44,559
and now we look at aes which is probably

531
00:18:44,559 --> 00:18:46,960
the most popular symmetric encryption

532
00:18:46,960 --> 00:18:50,480
algorithm it's all over the code base of

533
00:18:50,480 --> 00:18:53,520
sjx in in even in the sdk of

534
00:18:53,520 --> 00:18:56,160
intel for various operations internally

535
00:18:56,160 --> 00:18:58,080
it uses a four times four byte

536
00:18:58,080 --> 00:19:01,120
state and applies uh ten rounds of uh

537
00:19:01,120 --> 00:19:02,799
transformations on that

538
00:19:02,799 --> 00:19:05,440
and i was just thinking maybe you could

539
00:19:05,440 --> 00:19:06,080
attack

540
00:19:06,080 --> 00:19:08,320
the brand new instruction set uh intel's

541
00:19:08,320 --> 00:19:09,360
brand new aes

542
00:19:09,360 --> 00:19:10,880
new instruction set because that's

543
00:19:10,880 --> 00:19:13,200
really heavily optimized

544
00:19:13,200 --> 00:19:15,200
isn't this right to uh to prevent side

545
00:19:15,200 --> 00:19:16,559
channel attacks

546
00:19:16,559 --> 00:19:19,679
yes correct so in halfway new intel

547
00:19:19,679 --> 00:19:21,039
processors you have

548
00:19:21,039 --> 00:19:24,320
this asni instructions that allow you to

549
00:19:24,320 --> 00:19:25,280
do aes

550
00:19:25,280 --> 00:19:28,240
very quickly and also protect against

551
00:19:28,240 --> 00:19:30,160
some side channel attacks but this only

552
00:19:30,160 --> 00:19:30,799
protects

553
00:19:30,799 --> 00:19:33,360
protects against timing attacks so it

554
00:19:33,360 --> 00:19:35,360
will not protect you against a fault

555
00:19:35,360 --> 00:19:35,919
attack

556
00:19:35,919 --> 00:19:38,320
and luckily there's again also very

557
00:19:38,320 --> 00:19:39,679
efficient fault attack

558
00:19:39,679 --> 00:19:42,720
on as

559
00:19:42,720 --> 00:19:45,520
so that works like this you inject a

560
00:19:45,520 --> 00:19:47,120
single byte fault

561
00:19:47,120 --> 00:19:50,160
into the eighth round of aes

562
00:19:50,160 --> 00:19:52,240
into the state and then that will

563
00:19:52,240 --> 00:19:53,919
propagate and through some

564
00:19:53,919 --> 00:19:56,799
mathematical operations you can recover

565
00:19:56,799 --> 00:19:58,160
the complete aes

566
00:19:58,160 --> 00:20:01,280
key from only one correct and one

567
00:20:01,280 --> 00:20:04,000
faulty encryption or decryption of the

568
00:20:04,000 --> 00:20:04,840
same

569
00:20:04,840 --> 00:20:07,919
input so here we have the

570
00:20:07,919 --> 00:20:10,080
implementation of that inside sjx so we

571
00:20:10,080 --> 00:20:11,360
do as you see here

572
00:20:11,360 --> 00:20:13,679
twice the same operation so normally

573
00:20:13,679 --> 00:20:15,520
this loop should never terminate because

574
00:20:15,520 --> 00:20:16,960
the result is uh

575
00:20:16,960 --> 00:20:20,000
can i ask why why are you now doing the

576
00:20:20,000 --> 00:20:22,480
same operation twice

577
00:20:22,480 --> 00:20:24,960
uh because we need uh one correct and

578
00:20:24,960 --> 00:20:26,240
one faulty

579
00:20:26,240 --> 00:20:29,600
uh encryption in this case

580
00:20:29,600 --> 00:20:31,600
by the way this is of course uh just

581
00:20:31,600 --> 00:20:33,360
pseudocode so we're not really comparing

582
00:20:33,360 --> 00:20:35,120
this uh pointers here just for

583
00:20:35,120 --> 00:20:37,760
like people who wanted so there's an

584
00:20:37,760 --> 00:20:42,000
actual memcompair uh happening there

585
00:20:42,000 --> 00:20:44,880
okay so let's see that in action in sjx

586
00:20:44,880 --> 00:20:45,600
so we

587
00:20:45,600 --> 00:20:49,039
call a s encryption here with minus 262

588
00:20:49,039 --> 00:20:50,240
millivolts and we got

589
00:20:50,240 --> 00:20:53,120
fault here in the fourth round that's

590
00:20:53,120 --> 00:20:55,760
actually too early so we do it again

591
00:20:55,760 --> 00:20:58,400
here we have a fault again in the fifth

592
00:20:58,400 --> 00:20:59,200
round so

593
00:20:59,200 --> 00:21:02,400
too early so we'll run the attack again

594
00:21:02,400 --> 00:21:05,840
another fifth round and then finally in

595
00:21:05,840 --> 00:21:08,000
another attempt we'll get the desired

596
00:21:08,000 --> 00:21:08,960
location which

597
00:21:08,960 --> 00:21:12,240
is the eighth round and now we can use

598
00:21:12,240 --> 00:21:12,640
the

599
00:21:12,640 --> 00:21:15,840
faulty and the correct cipher

600
00:21:15,840 --> 00:21:18,240
and puts it into our differential fault

601
00:21:18,240 --> 00:21:20,320
attack and as you see here

602
00:21:20,320 --> 00:21:24,080
we actually use two pairs on which we

603
00:21:24,080 --> 00:21:26,559
run the differential fault attack this

604
00:21:26,559 --> 00:21:28,000
is simply because the

605
00:21:28,000 --> 00:21:29,840
attack will give us multiple key

606
00:21:29,840 --> 00:21:31,039
candidates

607
00:21:31,039 --> 00:21:33,919
and then we can use the uh intersection

608
00:21:33,919 --> 00:21:34,799
of the

609
00:21:34,799 --> 00:21:37,919
two results to find the correct key so

610
00:21:37,919 --> 00:21:40,320
here you see the attack uh running

611
00:21:40,320 --> 00:21:43,120
we recovered the keys from for pair one

612
00:21:43,120 --> 00:21:44,720
and pair two and we take the

613
00:21:44,720 --> 00:21:46,000
intersection

614
00:21:46,000 --> 00:21:49,039
and recover the um in this case here is

615
00:21:49,039 --> 00:21:50,960
the correct key which is zero zero zero

616
00:21:50,960 --> 00:21:52,240
one zero two

617
00:21:52,240 --> 00:21:55,360
uh and so on so

618
00:21:55,360 --> 00:21:58,080
just to show that we didn't cheat let's

619
00:21:58,080 --> 00:21:59,200
look at the

620
00:21:59,200 --> 00:22:02,880
enclave code and let's grab for the key

621
00:22:02,880 --> 00:22:05,840
and indeed we recover this value so as i

622
00:22:05,840 --> 00:22:06,640
said we used

623
00:22:06,640 --> 00:22:09,760
two pairs in this example you could also

624
00:22:09,760 --> 00:22:12,080
get away with one pair and then a brute

625
00:22:12,080 --> 00:22:14,320
force overall the candidate if you have

626
00:22:14,320 --> 00:22:17,840
unknown plaintext for instance

627
00:22:17,840 --> 00:22:19,919
brilliant so now we've got keys out of

628
00:22:19,919 --> 00:22:20,880
both both

629
00:22:20,880 --> 00:22:24,640
rsa and aes new instruction set

630
00:22:24,640 --> 00:22:26,880
but that's just crypto and i don't

631
00:22:26,880 --> 00:22:28,159
really get cryptos

632
00:22:28,159 --> 00:22:29,280
is there anything else we can do with

633
00:22:29,280 --> 00:22:31,520
that yes i think we could do something

634
00:22:31,520 --> 00:22:33,919
uh with that that would relate more to

635
00:22:33,919 --> 00:22:35,919
uh system security

636
00:22:35,919 --> 00:22:39,120
um i would say it's not just crypto uh

637
00:22:39,120 --> 00:22:41,360
for instance if you take a simple code

638
00:22:41,360 --> 00:22:42,720
snippet like this

639
00:22:42,720 --> 00:22:46,240
uh we take a pointer to some area offset

640
00:22:46,240 --> 00:22:48,320
uh and then we want to store something

641
00:22:48,320 --> 00:22:50,400
there an enclave secret maybe

642
00:22:50,400 --> 00:22:53,360
a secret key or something but daniel

643
00:22:53,360 --> 00:22:55,120
what what's that got to do there's no

644
00:22:55,120 --> 00:22:56,799
multiplications in there that's just

645
00:22:56,799 --> 00:22:57,760
pointer arithmetic

646
00:22:57,760 --> 00:22:59,679
that's right that's right but pointer

647
00:22:59,679 --> 00:23:01,600
arithmetic implicitly

648
00:23:01,600 --> 00:23:04,480
uses multiplications so if you would

649
00:23:04,480 --> 00:23:05,840
rewrite this

650
00:23:05,840 --> 00:23:08,720
uh this area axis there then you would

651
00:23:08,720 --> 00:23:10,559
get this code basically

652
00:23:10,559 --> 00:23:14,400
just wow foo equals area plus offset

653
00:23:14,400 --> 00:23:17,520
times uh the size of the structure

654
00:23:17,520 --> 00:23:20,080
that you were addressing here this is

655
00:23:20,080 --> 00:23:22,159
simple pointer arithmetics i know i

656
00:23:22,159 --> 00:23:23,679
think that many people will know that

657
00:23:23,679 --> 00:23:26,000
from their c programming classes

658
00:23:26,000 --> 00:23:28,159
um and of course then you have a

659
00:23:28,159 --> 00:23:30,000
multiplication so that's something that

660
00:23:30,000 --> 00:23:31,360
we can fault

661
00:23:31,360 --> 00:23:34,159
so maybe we should try that uh if we

662
00:23:34,159 --> 00:23:35,840
follow this multiplication we will get

663
00:23:35,840 --> 00:23:37,039
to the wrong offset

664
00:23:37,039 --> 00:23:40,000
and then hopefully we will write to a

665
00:23:40,000 --> 00:23:41,679
wrong location and see what we can do

666
00:23:41,679 --> 00:23:44,080
with that

667
00:23:44,720 --> 00:23:47,039
okay so in this example we have an

668
00:23:47,039 --> 00:23:49,279
enclave with a base and a limit so

669
00:23:49,279 --> 00:23:52,080
within this region this is secure memory

670
00:23:52,080 --> 00:23:53,919
that the attacker cannot read

671
00:23:53,919 --> 00:23:56,640
so staying between here and here is

672
00:23:56,640 --> 00:23:58,559
secure

673
00:23:58,559 --> 00:24:02,080
now if we run this many many times

674
00:24:02,080 --> 00:24:04,480
we will see that at some point we we

675
00:24:04,480 --> 00:24:05,600
have a fault

676
00:24:05,600 --> 00:24:09,200
and this fault um means that

677
00:24:09,200 --> 00:24:11,200
we started writing to the same location

678
00:24:11,200 --> 00:24:12,240
over and over again

679
00:24:12,240 --> 00:24:14,000
and now we have a fold and it now writes

680
00:24:14,000 --> 00:24:15,600
to a different location

681
00:24:15,600 --> 00:24:18,080
outside of this secure region and that

682
00:24:18,080 --> 00:24:19,679
means that we can

683
00:24:19,679 --> 00:24:22,799
read what the enclave wrote there

684
00:24:22,799 --> 00:24:24,799
and we can see that it wrote that beef

685
00:24:24,799 --> 00:24:26,400
there which is in this case

686
00:24:26,400 --> 00:24:29,360
the secret that we have implemented in

687
00:24:29,360 --> 00:24:30,799
our enclave

688
00:24:30,799 --> 00:24:33,200
now this is pretty bad so if we go back

689
00:24:33,200 --> 00:24:33,919
to the

690
00:24:33,919 --> 00:24:36,559
to the graphic you can see that clearly

691
00:24:36,559 --> 00:24:39,039
only writing within this green area

692
00:24:39,039 --> 00:24:41,600
uh this is secure writing to the faulted

693
00:24:41,600 --> 00:24:43,600
location outside to user memory means

694
00:24:43,600 --> 00:24:45,600
that the user directly can read

695
00:24:45,600 --> 00:24:48,480
this value

696
00:24:49,120 --> 00:24:51,279
well the question then is of course if

697
00:24:51,279 --> 00:24:52,720
we can induce

698
00:24:52,720 --> 00:24:55,919
faults like that how difficult is it to

699
00:24:55,919 --> 00:24:58,080
produce these faults without running

700
00:24:58,080 --> 00:24:59,360
into a lot of trouble

701
00:24:59,360 --> 00:25:01,279
yeah i get asked this question i have to

702
00:25:01,279 --> 00:25:02,880
say this is probably the question that i

703
00:25:02,880 --> 00:25:04,720
have been asked more than any other

704
00:25:04,720 --> 00:25:05,840
single thing

705
00:25:05,840 --> 00:25:08,799
so let's talk about that for a bit the

706
00:25:08,799 --> 00:25:09,840
first thing that we did

707
00:25:09,840 --> 00:25:11,600
is for all the computers that we were

708
00:25:11,600 --> 00:25:12,880
able to follow the first thing that we

709
00:25:12,880 --> 00:25:14,799
did is we ran a benchmark

710
00:25:14,799 --> 00:25:17,679
we found out what was the voltage uh

711
00:25:17,679 --> 00:25:18,159
when

712
00:25:18,159 --> 00:25:20,720
it was idle and at what point did did it

713
00:25:20,720 --> 00:25:21,279
crash

714
00:25:21,279 --> 00:25:24,480
and what we wanted to know was how close

715
00:25:24,480 --> 00:25:27,120
to the crash point do we need to be and

716
00:25:27,120 --> 00:25:28,240
i have to tell you i had some

717
00:25:28,240 --> 00:25:30,000
spectacular crashes

718
00:25:30,000 --> 00:25:33,039
um when this is my favorite crash um

719
00:25:33,039 --> 00:25:34,640
they weren't all as colorful as that

720
00:25:34,640 --> 00:25:37,520
unfortunately

721
00:25:37,520 --> 00:25:39,440
but here you can see this is an actual

722
00:25:39,440 --> 00:25:40,720
graph of

723
00:25:40,720 --> 00:25:44,080
a crash and a fulton and it looks

724
00:25:44,080 --> 00:25:46,159
like they're pretty close together but

725
00:25:46,159 --> 00:25:48,320
actually if you get to the frequencies

726
00:25:48,320 --> 00:25:49,840
in the middle we found those to be the

727
00:25:49,840 --> 00:25:50,880
most stable

728
00:25:50,880 --> 00:25:54,000
and you've got maybe sort of 20 maybe 10

729
00:25:54,000 --> 00:25:55,600
millivolts to play with them

730
00:25:55,600 --> 00:25:57,760
so you've got just enough to keep the

731
00:25:57,760 --> 00:25:59,679
computer stable

732
00:25:59,679 --> 00:26:03,679
but we also found out some other things

733
00:26:03,679 --> 00:26:06,720
we found out that if you try and buy two

734
00:26:06,720 --> 00:26:09,840
identical only mean absolutely identical

735
00:26:09,840 --> 00:26:10,880
computers

736
00:26:10,880 --> 00:26:14,400
and then you benchmark them they might

737
00:26:14,400 --> 00:26:16,240
look different

738
00:26:16,240 --> 00:26:19,200
um and that was one of them yeah that's

739
00:26:19,200 --> 00:26:21,279
weird so that means that

740
00:26:21,279 --> 00:26:23,039
although i bought exactly the same

741
00:26:23,039 --> 00:26:24,799
machine i will get

742
00:26:24,799 --> 00:26:27,039
basically more performance out of or i

743
00:26:27,039 --> 00:26:28,960
might get more performance out of one

744
00:26:28,960 --> 00:26:32,240
because it produces less heat yes

745
00:26:32,240 --> 00:26:33,760
interesting i didn't know yeah we

746
00:26:33,760 --> 00:26:35,200
actually thought we were buying exactly

747
00:26:35,200 --> 00:26:36,080
identical

748
00:26:36,080 --> 00:26:38,480
machines and we weren't but this way

749
00:26:38,480 --> 00:26:39,679
this is why the benchmarking

750
00:26:39,679 --> 00:26:41,440
portion is really important before you

751
00:26:41,440 --> 00:26:43,440
start faulting um

752
00:26:43,440 --> 00:26:46,480
we also found out that we were able

753
00:26:46,480 --> 00:26:50,000
to make a machine more stable by

754
00:26:50,000 --> 00:26:52,880
maxing out the cause because you needed

755
00:26:52,880 --> 00:26:53,279
more

756
00:26:53,279 --> 00:26:55,679
under vaulting when they were idle and

757
00:26:55,679 --> 00:26:58,240
consequently i was getting more crashes

758
00:26:58,240 --> 00:27:01,279
but if we if we maxed out the cause

759
00:27:01,279 --> 00:27:03,840
then you needed less under bolting and

760
00:27:03,840 --> 00:27:05,600
let's have a quick look at an example of

761
00:27:05,600 --> 00:27:07,600
that

762
00:27:07,600 --> 00:27:09,039
firstly i'm going to run the

763
00:27:09,039 --> 00:27:10,799
multiplication while the cores aren't

764
00:27:10,799 --> 00:27:11,600
under a

765
00:27:11,600 --> 00:27:15,279
huge load and we get our first volt

766
00:27:15,279 --> 00:27:19,279
at minus 163 millivolts

767
00:27:19,279 --> 00:27:21,200
incidentally uh these are all things

768
00:27:21,200 --> 00:27:22,880
that we haven't demonstrated before

769
00:27:22,880 --> 00:27:25,120
uh none of this made it into the paper

770
00:27:25,120 --> 00:27:28,720
uh so let's max out the chords now

771
00:27:28,720 --> 00:27:32,960
and now we get a fault up minus 153

772
00:27:32,960 --> 00:27:34,080
millivolts

773
00:27:34,080 --> 00:27:37,200
that gives us you know 10 millivolts to

774
00:27:37,200 --> 00:27:38,000
play with

775
00:27:38,000 --> 00:27:40,640
to keep our system stable but there's

776
00:27:40,640 --> 00:27:42,080
some more things i thought this might be

777
00:27:42,080 --> 00:27:42,960
kind of fun

778
00:27:42,960 --> 00:27:45,679
let's just see what else i can fault so

779
00:27:45,679 --> 00:27:47,279
first of all i'm going to have a go of

780
00:27:47,279 --> 00:27:48,320
faulting cat

781
00:27:48,320 --> 00:27:50,159
i'm just going to cat a program and i'm

782
00:27:50,159 --> 00:27:51,760
going to undervolt

783
00:27:51,760 --> 00:27:53,039
you can see the text being written to

784
00:27:53,039 --> 00:27:54,720
the screen and there we are we've got a

785
00:27:54,720 --> 00:27:55,520
core dump

786
00:27:55,520 --> 00:27:59,120
with cat let's try something else

787
00:27:59,120 --> 00:28:02,240
how about trying find i'm just going to

788
00:28:02,240 --> 00:28:04,080
find a file i know he's on my computer

789
00:28:04,080 --> 00:28:05,360
and i'm going to undervolt

790
00:28:05,360 --> 00:28:06,960
it found it there and then it core

791
00:28:06,960 --> 00:28:08,640
dumped again so we can

792
00:28:08,640 --> 00:28:11,840
we can force find to cordon

793
00:28:11,840 --> 00:28:14,880
how about ls i piped it to a file

794
00:28:14,880 --> 00:28:16,320
otherwise my screen filled up with

795
00:28:16,320 --> 00:28:17,279
rubbish

796
00:28:17,279 --> 00:28:19,679
and ls yes we even managed to get a core

797
00:28:19,679 --> 00:28:20,559
dump with ls

798
00:28:20,559 --> 00:28:22,799
that's -181 million so that was quite

799
00:28:22,799 --> 00:28:25,440
hard how about verifying a signature

800
00:28:25,440 --> 00:28:26,559
with openssl

801
00:28:26,559 --> 00:28:29,600
yep again we got a verification failure

802
00:28:29,600 --> 00:28:32,159
minus 167 millivolts and that was kind

803
00:28:32,159 --> 00:28:33,520
of a bit of fun just to see

804
00:28:33,520 --> 00:28:35,279
there was an awful lot of things we were

805
00:28:35,279 --> 00:28:36,880
able to fault

806
00:28:36,880 --> 00:28:39,039
okay so kid hang on a second so you said

807
00:28:39,039 --> 00:28:40,159
that you can

808
00:28:40,159 --> 00:28:43,039
kind of crash some programs sounds to me

809
00:28:43,039 --> 00:28:45,120
like uh denial of service or do you

810
00:28:45,120 --> 00:28:47,279
think there's some some or more to it

811
00:28:47,279 --> 00:28:49,039
i think by under vaulting we're managing

812
00:28:49,039 --> 00:28:50,799
to get the program to do something it

813
00:28:50,799 --> 00:28:53,360
shouldn't and that's kind of interesting

814
00:28:53,360 --> 00:28:54,000
because this

815
00:28:54,000 --> 00:28:56,640
could be um something that you could

816
00:28:56,640 --> 00:28:57,360
attack

817
00:28:57,360 --> 00:29:00,080
possibly in the future so we reported

818
00:29:00,080 --> 00:29:00,799
this to

819
00:29:00,799 --> 00:29:03,039
intel and intel confirmed that we were

820
00:29:03,039 --> 00:29:05,200
the first reporters they also issued an

821
00:29:05,200 --> 00:29:06,000
embargo

822
00:29:06,000 --> 00:29:10,480
and we complied with the embargo and

823
00:29:10,480 --> 00:29:12,880
during this embargo uh there were also

824
00:29:12,880 --> 00:29:14,799
other reporters who also discovered the

825
00:29:14,799 --> 00:29:16,159
same vulnerability

826
00:29:16,159 --> 00:29:18,480
for instance the vault pawn team and the

827
00:29:18,480 --> 00:29:20,799
wall jockey team they also discovered

828
00:29:20,799 --> 00:29:22,640
that you can induce

829
00:29:22,640 --> 00:29:25,360
faults by playing around with dvfs on

830
00:29:25,360 --> 00:29:27,919
intel processors

831
00:29:27,919 --> 00:29:30,000
they also participated in the embargo

832
00:29:30,000 --> 00:29:31,039
and all of this then

833
00:29:31,039 --> 00:29:34,799
went online at the same time

834
00:29:34,880 --> 00:29:38,159
so in summary we created a new type of

835
00:29:38,159 --> 00:29:40,399
attack against intel sgx

836
00:29:40,399 --> 00:29:43,919
we broke the integrity of sgx and within

837
00:29:43,919 --> 00:29:47,120
sgx we were able to retrieve

838
00:29:47,120 --> 00:29:49,840
aes new instruction set keys we were

839
00:29:49,840 --> 00:29:52,399
able to retrieve an rsa key

840
00:29:52,399 --> 00:29:54,960
we were able to induce memory corruption

841
00:29:54,960 --> 00:29:56,880
in bug-free code

842
00:29:56,880 --> 00:29:59,600
and we made the enclave write secrets to

843
00:29:59,600 --> 00:30:01,360
untrusted memory

844
00:30:01,360 --> 00:30:03,840
not only that we were able to get some

845
00:30:03,840 --> 00:30:07,600
linux binaries to core dump

846
00:30:07,600 --> 00:30:09,360
and a massive thank you to the grants

847
00:30:09,360 --> 00:30:12,000
that make this research possible

848
00:30:12,000 --> 00:30:13,919
and a massive thanks to you for watching

849
00:30:13,919 --> 00:30:15,200
this talk and

850
00:30:15,200 --> 00:30:17,520
for hopefully making it all the way to

851
00:30:17,520 --> 00:30:23,039
the end thank you

852
00:30:23,039 --> 00:30:26,158
and i look like a bit of an idiot

853
00:30:26,240 --> 00:30:28,240
okay we're live no we're not i don't

854
00:30:28,240 --> 00:30:32,159
think not i think we're live now

855
00:30:34,840 --> 00:30:37,039
okay

856
00:30:37,039 --> 00:30:39,440
so we got a few questions in the chat

857
00:30:39,440 --> 00:30:42,320
and uh just keep posting the questions

858
00:30:42,320 --> 00:30:44,320
so one of the last questions that we got

859
00:30:44,320 --> 00:30:47,039
was wait wait we're not live

860
00:30:47,039 --> 00:30:51,840
i do think well are we

861
00:30:52,640 --> 00:30:56,000
yes we are live um so one of the last

862
00:30:56,000 --> 00:30:58,240
questions that we had was uh whether

863
00:30:58,240 --> 00:31:02,080
the um susceptibility to bit flips

864
00:31:02,080 --> 00:31:05,519
comes from uh differences in

865
00:31:05,519 --> 00:31:10,320
the chip manufacturing um and

866
00:31:10,320 --> 00:31:13,360
we can only say we don't know basically

867
00:31:13,360 --> 00:31:16,480
we just observe that they are

868
00:31:16,480 --> 00:31:20,559
susceptible to um plunder volt bit flips

869
00:31:20,559 --> 00:31:22,559
yeah and that's it and we've seen

870
00:31:22,559 --> 00:31:23,840
differences same

871
00:31:23,840 --> 00:31:26,480
same processor right you had one example

872
00:31:26,480 --> 00:31:28,880
um

873
00:31:28,880 --> 00:31:31,519
the same processor and it was a

874
00:31:31,519 --> 00:31:33,360
susceptible to bit flips at a different

875
00:31:33,360 --> 00:31:34,480
voltage level

876
00:31:34,480 --> 00:31:36,559
yeah and it's we don't we don't think

877
00:31:36,559 --> 00:31:37,919
i'm 100 live

878
00:31:37,919 --> 00:31:41,440
thanks um i don't think we don't think

879
00:31:41,440 --> 00:31:44,000
it was differences in production line

880
00:31:44,000 --> 00:31:45,840
because i think they would be tiny tiny

881
00:31:45,840 --> 00:31:46,880
differences

882
00:31:46,880 --> 00:31:49,760
but um i do think possibly the way it's

883
00:31:49,760 --> 00:31:50,320
set up

884
00:31:50,320 --> 00:31:52,240
or something like that the way the

885
00:31:52,240 --> 00:31:53,760
differences in the way the chips

886
00:31:53,760 --> 00:31:55,360
um are prepared on the motherboard as

887
00:31:55,360 --> 00:31:57,279
they go out which would be kind of

888
00:31:57,279 --> 00:31:58,320
interesting to know

889
00:31:58,320 --> 00:32:00,799
i i would love to go and uh have a peek

890
00:32:00,799 --> 00:32:02,559
at the way intel do things and ask them

891
00:32:02,559 --> 00:32:03,919
but i i don't think they're gonna let us

892
00:32:03,919 --> 00:32:06,159
know

893
00:32:06,880 --> 00:32:10,000
so a lot of uh um good feedback

894
00:32:10,000 --> 00:32:13,039
um thank you for the positive feedback

895
00:32:13,039 --> 00:32:15,519
um yeah we did actually we filmed it if

896
00:32:15,519 --> 00:32:16,799
you're interested we tried to film it

897
00:32:16,799 --> 00:32:17,519
live across

898
00:32:17,519 --> 00:32:20,159
three uh three different places so we

899
00:32:20,159 --> 00:32:21,519
had two different countries

900
00:32:21,519 --> 00:32:22,960
and three different locations and we

901
00:32:22,960 --> 00:32:25,279
actually did it as live whilst recording

902
00:32:25,279 --> 00:32:26,799
ourselves so thank you very much

903
00:32:26,799 --> 00:32:28,240
because it took us a long time to do

904
00:32:28,240 --> 00:32:31,679
that so thanks for the appreciation

905
00:32:32,480 --> 00:32:34,640
a question are there similar

906
00:32:34,640 --> 00:32:35,679
capabilities to

907
00:32:35,679 --> 00:32:39,760
msr on other architectures

908
00:32:40,559 --> 00:32:43,039
well there is an arm right there where

909
00:32:43,039 --> 00:32:43,760
the um

910
00:32:43,760 --> 00:32:46,399
there were already papers on that uh the

911
00:32:46,399 --> 00:32:48,720
vault jockey paper for instance that

912
00:32:48,720 --> 00:32:51,760
um did some manipulation

913
00:32:51,760 --> 00:32:56,960
of um voltage frequency scaling

914
00:32:56,960 --> 00:33:02,080
on an arm so yes there are

915
00:33:04,080 --> 00:33:06,399
um i think anyone said someone said does

916
00:33:06,399 --> 00:33:09,279
this apply to intel xeon chips as well

917
00:33:09,279 --> 00:33:10,799
because you test you've got a xeon

918
00:33:10,799 --> 00:33:13,360
machine haven't you oh yeah we have xeon

919
00:33:13,360 --> 00:33:15,039
machines i would expect that it's

920
00:33:15,039 --> 00:33:17,279
uh applicable just the same yeah i don't

921
00:33:17,279 --> 00:33:20,000
see a difference there

922
00:33:20,000 --> 00:33:21,600
is there any way to protect against this

923
00:33:21,600 --> 00:33:24,480
attack well unfortunately the way to

924
00:33:24,480 --> 00:33:26,240
protect against it is to turn the msr

925
00:33:26,240 --> 00:33:27,760
off which is what intel have done

926
00:33:27,760 --> 00:33:29,200
but you have a choice you can either

927
00:33:29,200 --> 00:33:31,600
have sgx or

928
00:33:31,600 --> 00:33:34,640
you can undervolt and i have seen a lot

929
00:33:34,640 --> 00:33:36,640
of people talking about newer machines

930
00:33:36,640 --> 00:33:39,279
that appear to be coming out without the

931
00:33:39,279 --> 00:33:40,159
ability

932
00:33:40,159 --> 00:33:44,240
to undervolt which is a shame i think

933
00:33:44,240 --> 00:33:46,559
it's an interesting uh situation because

934
00:33:46,559 --> 00:33:48,640
for more constrained devices it was

935
00:33:48,640 --> 00:33:49,120
always

936
00:33:49,120 --> 00:33:52,159
possible to implement a protected

937
00:33:52,159 --> 00:33:53,120
algorithm

938
00:33:53,120 --> 00:33:55,200
but in this case it's unclear what you

939
00:33:55,200 --> 00:33:57,200
attack right if you don't detect the

940
00:33:57,200 --> 00:33:59,279
crypto then you attack some something

941
00:33:59,279 --> 00:34:01,200
else like pointer arithmetic

942
00:34:01,200 --> 00:34:03,519
and suddenly it's much more difficult to

943
00:34:03,519 --> 00:34:05,440
protect against that in a generic

944
00:34:05,440 --> 00:34:08,239
way um more difficult than for certain

945
00:34:08,239 --> 00:34:08,879
crypto

946
00:34:08,879 --> 00:34:11,440
algorithms

947
00:34:13,520 --> 00:34:17,760
thank you uh marina thank you

948
00:34:17,760 --> 00:34:19,599
how did you become interested in lower

949
00:34:19,599 --> 00:34:22,000
level fault attacks

950
00:34:22,000 --> 00:34:27,239
as individuals and a team rather than

951
00:34:27,239 --> 00:34:30,239
applications

952
00:34:32,159 --> 00:34:34,159
so the fault attacks i mean let's be

953
00:34:34,159 --> 00:34:35,918
honest we can we can openly say that

954
00:34:35,918 --> 00:34:36,719
clock screw

955
00:34:36,719 --> 00:34:38,960
was the first of its kind and clock

956
00:34:38,960 --> 00:34:41,040
screw is an absolutely fantastic paper

957
00:34:41,040 --> 00:34:44,239
and it opened the world to new attacks

958
00:34:44,239 --> 00:34:46,800
and it's because of clock's crew that

959
00:34:46,800 --> 00:34:48,159
we've gone on to see a number of attacks

960
00:34:48,159 --> 00:34:48,800
against

961
00:34:48,800 --> 00:34:51,679
lots of other um chips so that was where

962
00:34:51,679 --> 00:34:53,760
we started but as a team i think this is

963
00:34:53,760 --> 00:34:54,879
what you're asking

964
00:34:54,879 --> 00:34:56,800
as a team we came together because we

965
00:34:56,800 --> 00:34:58,240
all brought different things to the

966
00:34:58,240 --> 00:34:58,960
table

967
00:34:58,960 --> 00:35:02,160
um and so at birmingham we didn't have

968
00:35:02,160 --> 00:35:04,320
as much experience as daniel's got for

969
00:35:04,320 --> 00:35:05,440
fault injection so

970
00:35:05,440 --> 00:35:08,560
when you come together um you know

971
00:35:08,560 --> 00:35:10,560
each bring something that adds to the

972
00:35:10,560 --> 00:35:13,040
overall research

973
00:35:13,040 --> 00:35:16,400
i think the interest for topics like

974
00:35:16,400 --> 00:35:17,040
this from

975
00:35:17,040 --> 00:35:20,560
from my site came actually from my

976
00:35:20,560 --> 00:35:24,240
phd supervisor who said uh well this is

977
00:35:24,240 --> 00:35:28,240
an interesting area take a look at that

978
00:35:29,200 --> 00:35:31,839
um

979
00:35:32,320 --> 00:35:35,440
okay thank you a lot of

980
00:35:35,440 --> 00:35:37,920
uh um do you plan to continue this

981
00:35:37,920 --> 00:35:39,599
research yeah we have we at birmingham

982
00:35:39,599 --> 00:35:41,280
have been looking at amd

983
00:35:41,280 --> 00:35:45,520
um i don't think we've had much success

984
00:35:45,520 --> 00:35:46,160
i actually

985
00:35:46,160 --> 00:35:48,400
i'm not working on that specifically um

986
00:35:48,400 --> 00:35:49,599
yes the code

987
00:35:49,599 --> 00:35:52,640
is available uh it's on uh

988
00:35:52,640 --> 00:35:56,000
github uh it's forward slash kit murdock

989
00:35:56,000 --> 00:35:59,520
which is my name um or kit hyphen

990
00:35:59,520 --> 00:36:01,119
murdock it's either kit mode or kit kit

991
00:36:01,119 --> 00:36:02,720
hyphen model try one of the two

992
00:36:02,720 --> 00:36:04,000
and that's where we've got the code to

993
00:36:04,000 --> 00:36:06,320
modify the msr and also to create a

994
00:36:06,320 --> 00:36:06,960
fault

995
00:36:06,960 --> 00:36:09,839
um in one of the cryptos it might be

996
00:36:09,839 --> 00:36:12,160
both of them can't remember that's not

997
00:36:12,160 --> 00:36:14,079
very helpful

998
00:36:14,079 --> 00:36:16,240
why do identical products produce

999
00:36:16,240 --> 00:36:20,240
different results a bit unclear there

1000
00:36:20,640 --> 00:36:24,240
we had in the team we had multiple

1001
00:36:24,240 --> 00:36:27,920
small nucs with the same processor with

1002
00:36:27,920 --> 00:36:28,960
the same

1003
00:36:28,960 --> 00:36:31,839
um yeah basically the same processor

1004
00:36:31,839 --> 00:36:33,359
same micro architecture

1005
00:36:33,359 --> 00:36:37,280
same um specifier

1006
00:36:37,280 --> 00:36:39,359
what the processor is but different

1007
00:36:39,359 --> 00:36:40,640
voltage baselines

1008
00:36:40,640 --> 00:36:44,160
so apparently um even the same processor

1009
00:36:44,160 --> 00:36:45,280
as you buy it

1010
00:36:45,280 --> 00:36:48,960
with exactly the same number uh

1011
00:36:48,960 --> 00:36:52,160
can be different and that has a lot of

1012
00:36:52,160 --> 00:36:54,240
consequences for instance also

1013
00:36:54,240 --> 00:36:57,200
and i personally i find that a bit

1014
00:36:57,200 --> 00:36:58,000
concerning

1015
00:36:58,000 --> 00:37:00,560
that these might even lead to

1016
00:37:00,560 --> 00:37:03,200
performance differences in benchmarks

1017
00:37:03,200 --> 00:37:04,960
if one has a higher performance level

1018
00:37:04,960 --> 00:37:06,400
than the other a

1019
00:37:06,400 --> 00:37:09,839
higher voltage level than the other

1020
00:37:09,920 --> 00:37:12,000
um someone's asked how much time roughly

1021
00:37:12,000 --> 00:37:13,680
does the attack take to carry out

1022
00:37:13,680 --> 00:37:15,920
well it can be seconds um the hardest

1023
00:37:15,920 --> 00:37:18,160
bit is the benchmarking which takes

1024
00:37:18,160 --> 00:37:19,920
hours because you're crashing your

1025
00:37:19,920 --> 00:37:22,240
computer just constantly crashing it

1026
00:37:22,240 --> 00:37:23,920
but once you know where the crash point

1027
00:37:23,920 --> 00:37:27,200
is you just stay a little bit above that

1028
00:37:27,200 --> 00:37:31,040
and at that point you can um

1029
00:37:31,040 --> 00:37:36,400
seconds i mean yeah seconds

1030
00:37:36,400 --> 00:37:39,440
what vintage is that um on my side some

1031
00:37:39,440 --> 00:37:40,160
austrian

1032
00:37:40,160 --> 00:37:42,720
local wine um yeah this is awful because

1033
00:37:42,720 --> 00:37:44,160
it's it's written in english and we

1034
00:37:44,160 --> 00:37:45,760
don't produce red wine in england so you

1035
00:37:45,760 --> 00:37:48,839
know that it is not a good bottle of red

1036
00:37:48,839 --> 00:37:50,240
wine

1037
00:37:50,240 --> 00:37:51,839
uh bear in mind that we're in europe so

1038
00:37:51,839 --> 00:37:53,760
we're allowed to drink

1039
00:37:53,760 --> 00:37:57,119
yeah because it's evening

1040
00:37:57,520 --> 00:37:59,920
i think that's all the questions oh

1041
00:37:59,920 --> 00:38:01,200
there's a question could the msrp

1042
00:38:01,200 --> 00:38:03,040
protected admin access required for

1043
00:38:03,040 --> 00:38:03,599
example

1044
00:38:03,599 --> 00:38:05,680
so the msr does require admin access

1045
00:38:05,680 --> 00:38:07,599
which is root you have to be rude

1046
00:38:07,599 --> 00:38:11,040
which is why the um application of sgx

1047
00:38:11,040 --> 00:38:13,200
is is where we focused all our attacks

1048
00:38:13,200 --> 00:38:15,839
because sgx says you should be protected

1049
00:38:15,839 --> 00:38:19,200
even against an attacker who has root

1050
00:38:19,200 --> 00:38:23,839
and you're not because of plundervolt

1051
00:38:24,160 --> 00:38:28,160
in general you can fault any application

1052
00:38:28,160 --> 00:38:30,480
but as kid just said you need root

1053
00:38:30,480 --> 00:38:32,800
privileges to modify the msr

1054
00:38:32,800 --> 00:38:36,240
um if there are other ways to induce

1055
00:38:36,240 --> 00:38:39,040
faults without that that or if if

1056
00:38:39,040 --> 00:38:40,000
someone would

1057
00:38:40,000 --> 00:38:42,480
introduce an interface where you don't

1058
00:38:42,480 --> 00:38:44,240
need root privileges

1059
00:38:44,240 --> 00:38:46,560
to induce faults well then you could

1060
00:38:46,560 --> 00:38:47,440
also very

1061
00:38:47,440 --> 00:38:51,599
realistically attack other applications

1062
00:38:59,040 --> 00:39:00,960
someone is schooling me on red wine

1063
00:39:00,960 --> 00:39:03,200
production in the uk

1064
00:39:03,200 --> 00:39:07,919
we do produce red wine i apologize

1065
00:39:09,520 --> 00:39:12,599
[Music]

1066
00:39:13,040 --> 00:39:16,480
um another question are there similar

1067
00:39:16,480 --> 00:39:17,920
capabilities to msr and other

1068
00:39:17,920 --> 00:39:20,720
architectures yes

1069
00:39:23,760 --> 00:39:26,160
clock scroll on that scoop is on arm

1070
00:39:26,160 --> 00:39:29,119
yeah and amd

1071
00:39:29,119 --> 00:39:32,800
very nice there's an area of research we

1072
00:39:34,320 --> 00:39:36,800
how reliably can you get the fault into

1073
00:39:36,800 --> 00:39:39,760
the aids operation of aes

1074
00:39:39,760 --> 00:39:42,400
it yeah so it was pretty evenly spread

1075
00:39:42,400 --> 00:39:44,800
yeah um

1076
00:39:45,280 --> 00:39:48,480
so one in as many rounds as there are

1077
00:39:48,480 --> 00:39:51,680
one in 11. i am not a cryptographer

1078
00:39:51,680 --> 00:39:54,400
yeah at this point let's uh thank the

1079
00:39:54,400 --> 00:39:55,040
audience

1080
00:39:55,040 --> 00:39:56,880
thanks for being here thanks for all the

1081
00:39:56,880 --> 00:39:58,400
very positive feedback

1082
00:39:58,400 --> 00:40:00,240
and if you have any further questions

1083
00:40:00,240 --> 00:40:01,920
just send us a mail or

1084
00:40:01,920 --> 00:40:05,280
ask them through some other means

1085
00:40:05,280 --> 00:40:10,319
we are always happy to answer questions

