1
00:00:03,580 --> 00:00:15,280
[Music]

2
00:00:15,280 --> 00:00:16,160
hi everyone

3
00:00:16,160 --> 00:00:18,000
welcome to our talk about hacking the

4
00:00:18,000 --> 00:00:19,520
supply chain the ripple 20

5
00:00:19,520 --> 00:00:21,279
vulnerabilities that

6
00:00:21,279 --> 00:00:23,840
hundreds of millions of devices what

7
00:00:23,840 --> 00:00:25,920
about who we are

8
00:00:25,920 --> 00:00:27,199
joseph is a software security

9
00:00:27,199 --> 00:00:29,599
consultancy we do security research

10
00:00:29,599 --> 00:00:31,279
penetration testing

11
00:00:31,279 --> 00:00:33,520
uh consulting on secure development as

12
00:00:33,520 --> 00:00:34,960
well as some training

13
00:00:34,960 --> 00:00:36,640
my name is shlomi obermann i'm a

14
00:00:36,640 --> 00:00:38,160
co-founder at jsof

15
00:00:38,160 --> 00:00:39,760
together with me we'll be speaking moshe

16
00:00:39,760 --> 00:00:42,160
cole a security researcher at jasof

17
00:00:42,160 --> 00:00:43,440
and the founder of the ripple 20

18
00:00:43,440 --> 00:00:45,200
vulnerabilities and

19
00:00:45,200 --> 00:00:47,280
ariel shawn a security researcher at

20
00:00:47,280 --> 00:00:49,520
jasof also heavily involved in the

21
00:00:49,520 --> 00:00:50,879
research

22
00:00:50,879 --> 00:00:52,960
today we'll be talking about what ripple

23
00:00:52,960 --> 00:00:53,920
20 is

24
00:00:53,920 --> 00:00:55,760
and then diving in detail into one of

25
00:00:55,760 --> 00:00:57,120
the vulnerabilities

26
00:00:57,120 --> 00:01:00,399
cve 2020 11901

27
00:01:00,399 --> 00:01:02,640
after that we'll be showing some of the

28
00:01:02,640 --> 00:01:04,400
details about exploitation

29
00:01:04,400 --> 00:01:07,520
of cve 2020 11901 and

30
00:01:07,520 --> 00:01:10,000
a demo of exploitation on a vulnerable

31
00:01:10,000 --> 00:01:11,600
device

32
00:01:11,600 --> 00:01:14,960
so ripple 20 ripple 20 is a series of 19

33
00:01:14,960 --> 00:01:17,920
zero-day vulnerabilities in a tcpatc ip

34
00:01:17,920 --> 00:01:18,479
stack

35
00:01:18,479 --> 00:01:21,680
called trek tcpip

36
00:01:21,680 --> 00:01:24,000
19 vulnerabilities give or take two of

37
00:01:24,000 --> 00:01:25,360
these vulnerabilities were actually

38
00:01:25,360 --> 00:01:27,840
reported anonymously at the same time as

39
00:01:27,840 --> 00:01:30,960
we reported and actually resulted in 24

40
00:01:30,960 --> 00:01:32,240
patches altogether

41
00:01:32,240 --> 00:01:34,240
so depends how you count these

42
00:01:34,240 --> 00:01:36,000
vulnerabilities were amplified by the

43
00:01:36,000 --> 00:01:36,799
supply chain

44
00:01:36,799 --> 00:01:38,720
something that we'll be talking about

45
00:01:38,720 --> 00:01:40,400
and showing to affect hundreds of

46
00:01:40,400 --> 00:01:41,600
millions of devices

47
00:01:41,600 --> 00:01:44,159
across a wide range of verticals uh

48
00:01:44,159 --> 00:01:45,040
pretty much

49
00:01:45,040 --> 00:01:46,720
any type of iot device you can think

50
00:01:46,720 --> 00:01:49,360
about out of these vulnerabilities

51
00:01:49,360 --> 00:01:50,799
four of the vulnerabilities are critical

52
00:01:50,799 --> 00:01:53,200
remote code execution vulnerabilities

53
00:01:53,200 --> 00:01:54,960
this is not necessarily according to the

54
00:01:54,960 --> 00:01:57,439
cvss but according to our assessment of

55
00:01:57,439 --> 00:01:59,280
the vulnerabilities

56
00:01:59,280 --> 00:02:02,399
but four of them are also critical cvss

57
00:02:02,399 --> 00:02:04,560
eight of the vulnerabilities are medium

58
00:02:04,560 --> 00:02:06,320
to high severity vulnerabilities with

59
00:02:06,320 --> 00:02:07,119
some chance

60
00:02:07,119 --> 00:02:09,440
of remote code execution and other

61
00:02:09,440 --> 00:02:10,720
effects

62
00:02:10,720 --> 00:02:14,239
the uh devices affected are made by

63
00:02:14,239 --> 00:02:17,520
vendors you all know large vendors uh

64
00:02:17,520 --> 00:02:19,360
devices of high impact as well as

65
00:02:19,360 --> 00:02:22,000
smaller smaller vendors

66
00:02:22,000 --> 00:02:25,200
vendors really range from all types of

67
00:02:25,200 --> 00:02:27,520
iot devices and from fortune 500

68
00:02:27,520 --> 00:02:28,319
companies

69
00:02:28,319 --> 00:02:30,720
to one-person shops tiny little

70
00:02:30,720 --> 00:02:32,480
companies making embedded specialist

71
00:02:32,480 --> 00:02:33,599
devices

72
00:02:33,599 --> 00:02:35,360
the types of devices you can encounter

73
00:02:35,360 --> 00:02:38,879
in your hospital at home on your network

74
00:02:38,879 --> 00:02:42,000
power water cellular utilities

75
00:02:42,000 --> 00:02:43,680
things you use in your everyday life

76
00:02:43,680 --> 00:02:45,920
transportation pretty much anything we

77
00:02:45,920 --> 00:02:46,239
do

78
00:02:46,239 --> 00:02:48,400
is powered by devices affected by ripple

79
00:02:48,400 --> 00:02:49,760
20 vulnerabilities

80
00:02:49,760 --> 00:02:51,840
at this stage knowing what we know about

81
00:02:51,840 --> 00:02:53,200
affected devices and effective

82
00:02:53,200 --> 00:02:54,480
vulnerabilities

83
00:02:54,480 --> 00:02:56,800
we're assuming every mid to large

84
00:02:56,800 --> 00:02:59,040
organization in the u.s has at least one

85
00:02:59,040 --> 00:03:02,159
vulnerable device whether it be

86
00:03:02,159 --> 00:03:04,480
a networking device a printing device

87
00:03:04,480 --> 00:03:05,599
ics device

88
00:03:05,599 --> 00:03:09,360
uh etc why did this happen

89
00:03:09,360 --> 00:03:10,959
so it all has to do with the supply

90
00:03:10,959 --> 00:03:13,360
chain somebody takes a

91
00:03:13,360 --> 00:03:15,680
piece of source code a library and

92
00:03:15,680 --> 00:03:17,760
embeds it into a larger component say an

93
00:03:17,760 --> 00:03:18,800
operating system

94
00:03:18,800 --> 00:03:20,720
this component then gets embedded

95
00:03:20,720 --> 00:03:22,879
further in a system-on-module or a

96
00:03:22,879 --> 00:03:24,000
larger component

97
00:03:24,000 --> 00:03:26,159
which then once again gets embedded into

98
00:03:26,159 --> 00:03:27,200
a larger component

99
00:03:27,200 --> 00:03:28,959
and so on and so forth until we reach

100
00:03:28,959 --> 00:03:31,120
our final product

101
00:03:31,120 --> 00:03:32,799
at the certain moment in the supply

102
00:03:32,799 --> 00:03:34,799
chain nobody knows they're using the

103
00:03:34,799 --> 00:03:35,599
original

104
00:03:35,599 --> 00:03:37,519
library there nobody knows they're using

105
00:03:37,519 --> 00:03:39,040
this original source code

106
00:03:39,040 --> 00:03:41,040
just imagine what happens if one of the

107
00:03:41,040 --> 00:03:43,680
components along the way

108
00:03:43,680 --> 00:03:46,080
one of the companies along the way goes

109
00:03:46,080 --> 00:03:47,760
bankrupt or cc's operation

110
00:03:47,760 --> 00:03:50,480
how difficult it is to fix these uh

111
00:03:50,480 --> 00:03:51,760
vulnerabilities

112
00:03:51,760 --> 00:03:53,519
and so with this supply chain we have a

113
00:03:53,519 --> 00:03:54,959
network of devices

114
00:03:54,959 --> 00:03:56,959
that embed different components

115
00:03:56,959 --> 00:03:58,000
beginning

116
00:03:58,000 --> 00:04:00,080
at a single library a single piece of

117
00:04:00,080 --> 00:04:01,040
source code

118
00:04:01,040 --> 00:04:04,239
and if a vulnerability exists in a

119
00:04:04,239 --> 00:04:05,920
certain library at the beginning of the

120
00:04:05,920 --> 00:04:06,720
supply chain

121
00:04:06,720 --> 00:04:09,439
this vulnerability infects the other

122
00:04:09,439 --> 00:04:10,720
parts of the network

123
00:04:10,720 --> 00:04:12,159
kind of like a plague and the

124
00:04:12,159 --> 00:04:14,080
vulnerability travels from one

125
00:04:14,080 --> 00:04:16,560
device to the other device reaching all

126
00:04:16,560 --> 00:04:18,000
kinds of different

127
00:04:18,000 --> 00:04:19,440
areas in the supply chain reaching

128
00:04:19,440 --> 00:04:21,839
different types of devices

129
00:04:21,839 --> 00:04:23,680
this is what happened with ripple 20 a

130
00:04:23,680 --> 00:04:26,160
vulnerability deep in the supply chain

131
00:04:26,160 --> 00:04:28,400
that affected other devices affected

132
00:04:28,400 --> 00:04:29,919
more and more devices

133
00:04:29,919 --> 00:04:33,759
as the piece of code traveled

134
00:04:33,759 --> 00:04:36,880
um why we chose track tcp and why we

135
00:04:36,880 --> 00:04:37,440
think this

136
00:04:37,440 --> 00:04:40,479
uh this research is interesting for the

137
00:04:40,479 --> 00:04:42,320
community and for the listeners

138
00:04:42,320 --> 00:04:44,400
well the first issue is the issue of

139
00:04:44,400 --> 00:04:46,240
supply chain not in the sense that

140
00:04:46,240 --> 00:04:47,600
somebody put a backdoor

141
00:04:47,600 --> 00:04:49,840
in your supply chain in the sense that

142
00:04:49,840 --> 00:04:51,280
one vulnerability

143
00:04:51,280 --> 00:04:53,440
in a single piece of code travels across

144
00:04:53,440 --> 00:04:55,440
the supply chain so one vulnerability

145
00:04:55,440 --> 00:04:56,000
multiple

146
00:04:56,000 --> 00:04:58,560
products multiple products a few dozen

147
00:04:58,560 --> 00:04:59,280
different

148
00:04:59,280 --> 00:05:01,120
vendors few hundreds of different types

149
00:05:01,120 --> 00:05:03,759
of products extremely large iot

150
00:05:03,759 --> 00:05:06,800
uh impact and the potential for zombie

151
00:05:06,800 --> 00:05:08,639
vulnerabilities zombie vulnerabilities

152
00:05:08,639 --> 00:05:10,320
these vulnerabilities we're not exactly

153
00:05:10,320 --> 00:05:11,759
sure whether to call them one days or

154
00:05:11,759 --> 00:05:12,639
zero days

155
00:05:12,639 --> 00:05:16,000
because we've already reported them but

156
00:05:16,000 --> 00:05:18,320
probably not going to be fixed in some

157
00:05:18,320 --> 00:05:19,840
of these devices where the company went

158
00:05:19,840 --> 00:05:22,000
bankrupt chose not to fix

159
00:05:22,000 --> 00:05:23,680
the supply chain is too complex to

160
00:05:23,680 --> 00:05:25,120
follow etc

161
00:05:25,120 --> 00:05:28,320
and of course a good attack surface tcp

162
00:05:28,320 --> 00:05:31,360
mostly unauthenticated a lot of parsing

163
00:05:31,360 --> 00:05:34,639
pretty old code um the perfect

164
00:05:34,639 --> 00:05:38,800
attack candidate a little bit about the

165
00:05:38,800 --> 00:05:41,199
concrete specific tcp stack that we

166
00:05:41,199 --> 00:05:41,840
chose

167
00:05:41,840 --> 00:05:45,840
uh track tcpip a pretty successful

168
00:05:45,840 --> 00:05:49,199
tcp stack one of the leading tcp stacks

169
00:05:49,199 --> 00:05:52,000
at least for a while trek is a small

170
00:05:52,000 --> 00:05:53,360
american company

171
00:05:53,360 --> 00:05:56,960
that makes tcpac stack a fully

172
00:05:56,960 --> 00:05:59,280
featured tcp stack all the way going all

173
00:05:59,280 --> 00:06:00,720
the way from the link layer

174
00:06:00,720 --> 00:06:04,319
to application layer protocols

175
00:06:04,319 --> 00:06:06,720
complete with all the rfcs needed to be

176
00:06:06,720 --> 00:06:07,440
implemented

177
00:06:07,440 --> 00:06:10,240
and has been available for over 20 years

178
00:06:10,240 --> 00:06:10,560
no

179
00:06:10,560 --> 00:06:12,400
usually used in embedded devices and

180
00:06:12,400 --> 00:06:14,240
real-time operating systems

181
00:06:14,240 --> 00:06:16,560
and very importantly for our research

182
00:06:16,560 --> 00:06:18,160
very very configurable

183
00:06:18,160 --> 00:06:20,400
so each instance of the trek stack each

184
00:06:20,400 --> 00:06:22,240
device implementing the trek stack has a

185
00:06:22,240 --> 00:06:23,600
slightly different version

186
00:06:23,600 --> 00:06:26,240
of trek and this affected a lot of the

187
00:06:26,240 --> 00:06:27,840
vulnerabilities and a lot of the way we

188
00:06:27,840 --> 00:06:28,960
did our research

189
00:06:28,960 --> 00:06:30,639
this happens because different vendors

190
00:06:30,639 --> 00:06:32,160
compile the trek stack differently

191
00:06:32,160 --> 00:06:33,600
and because they use different versions

192
00:06:33,600 --> 00:06:35,199
of trek and then

193
00:06:35,199 --> 00:06:37,759
sometimes stop support and most

194
00:06:37,759 --> 00:06:38,400
importantly

195
00:06:38,400 --> 00:06:40,639
it's strategically located at the very

196
00:06:40,639 --> 00:06:42,800
beginning of an extremely long supply

197
00:06:42,800 --> 00:06:43,360
chain

198
00:06:43,360 --> 00:06:45,680
so in some cases we've seen companies

199
00:06:45,680 --> 00:06:47,120
that are second hand third hand forward

200
00:06:47,120 --> 00:06:47,759
forward-hand

201
00:06:47,759 --> 00:06:49,919
fourth-hand users of trek and had no

202
00:06:49,919 --> 00:06:52,960
idea they were using this piece of code

203
00:06:52,960 --> 00:06:54,880
um a little bit about how we conducted

204
00:06:54,880 --> 00:06:56,000
our research so

205
00:06:56,000 --> 00:06:59,039
because every piece of uh

206
00:06:59,039 --> 00:07:01,280
trek tcp stack is different every

207
00:07:01,280 --> 00:07:02,800
instance is different

208
00:07:02,800 --> 00:07:04,560
we took six data points six different

209
00:07:04,560 --> 00:07:06,639
devices and reverse engineered them

210
00:07:06,639 --> 00:07:08,800
in multiple versions we didn't spend as

211
00:07:08,800 --> 00:07:11,280
much effort on every one of the devices

212
00:07:11,280 --> 00:07:12,560
the same amount of effort on all the

213
00:07:12,560 --> 00:07:15,120
devices but we used these

214
00:07:15,120 --> 00:07:17,759
in order to understand the um the

215
00:07:17,759 --> 00:07:19,440
situation better understand how the

216
00:07:19,440 --> 00:07:21,520
vulnerabilities change over time

217
00:07:21,520 --> 00:07:23,120
every one of our devices had different

218
00:07:23,120 --> 00:07:25,599
configuration a different version

219
00:07:25,599 --> 00:07:27,599
the research took approximately nine one

220
00:07:27,599 --> 00:07:29,120
months with different levels of

221
00:07:29,120 --> 00:07:30,240
intensity

222
00:07:30,240 --> 00:07:32,479
starting september 19th ending uh

223
00:07:32,479 --> 00:07:33,759
sometime around

224
00:07:33,759 --> 00:07:37,280
june 20th with the public disclosure

225
00:07:37,280 --> 00:07:39,680
and the research involved a few strange

226
00:07:39,680 --> 00:07:41,919
architectures a few strange frameworks

227
00:07:41,919 --> 00:07:44,879
we'll be talking about one of them today

228
00:07:44,879 --> 00:07:46,400
unfortunately we can't go into all the

229
00:07:46,400 --> 00:07:48,879
details today we only have 35 minutes

230
00:07:48,879 --> 00:07:51,280
but we did release two white papers

231
00:07:51,280 --> 00:07:52,160
detailing

232
00:07:52,160 --> 00:07:54,960
uh full technical details uh of several

233
00:07:54,960 --> 00:07:56,879
of the vulnerabilities as well as

234
00:07:56,879 --> 00:07:58,879
exploitation uh you're welcome to to

235
00:07:58,879 --> 00:08:00,080
look them up on our

236
00:08:00,080 --> 00:08:02,319
um on our website today we're going to

237
00:08:02,319 --> 00:08:03,520
be talking mostly

238
00:08:03,520 --> 00:08:06,400
about a single cve which is the cve we

239
00:08:06,400 --> 00:08:07,680
find most interesting

240
00:08:07,680 --> 00:08:10,400
and perhaps the most critical of the

241
00:08:10,400 --> 00:08:13,280
ripple 20 vulnerabilities

242
00:08:13,280 --> 00:08:14,960
it's a vulnerability a client side

243
00:08:14,960 --> 00:08:17,039
vulnerability and trek's dns resolver

244
00:08:17,039 --> 00:08:18,639
component

245
00:08:18,639 --> 00:08:20,560
it can result in remote code execution

246
00:08:20,560 --> 00:08:21,919
and we've demonstrated this

247
00:08:21,919 --> 00:08:23,759
and the interesting thing about it is

248
00:08:23,759 --> 00:08:25,520
that because dns will travel

249
00:08:25,520 --> 00:08:27,520
from inside your corporate network to

250
00:08:27,520 --> 00:08:29,520
the internet a sophisticated attacker

251
00:08:29,520 --> 00:08:30,960
can potentially use this

252
00:08:30,960 --> 00:08:33,360
to attack a device from outside network

253
00:08:33,360 --> 00:08:34,958
boundaries

254
00:08:34,958 --> 00:08:37,519
another interesting thing is because the

255
00:08:37,519 --> 00:08:39,839
trek tcpip stack is so configurable

256
00:08:39,839 --> 00:08:41,599
this one cv actually hides four

257
00:08:41,599 --> 00:08:43,679
vulnerabilities and one

258
00:08:43,679 --> 00:08:45,279
what we're calling an artifact a bug

259
00:08:45,279 --> 00:08:48,480
that makes it easier for us to exploit

260
00:08:48,480 --> 00:08:50,640
different versions of the track

261
00:08:50,640 --> 00:08:52,000
different vendors have different

262
00:08:52,000 --> 00:08:54,000
versions of the vulnerabilities

263
00:08:54,000 --> 00:08:55,600
all of them have a remote code execution

264
00:08:55,600 --> 00:08:57,200
in this case but

265
00:08:57,200 --> 00:08:58,800
just an example of how complex this

266
00:08:58,800 --> 00:09:00,959
really is today we'll be talking

267
00:09:00,959 --> 00:09:03,120
about three of these vulnerabilities and

268
00:09:03,120 --> 00:09:05,120
the artifact

269
00:09:05,120 --> 00:09:06,240
now i'm going to hand over the

270
00:09:06,240 --> 00:09:07,920
microphone to moche call who is going to

271
00:09:07,920 --> 00:09:08,880
be discussing

272
00:09:08,880 --> 00:09:12,800
the vulnerabilities in detail

273
00:09:12,800 --> 00:09:14,880
hi i'm moshe security researcher at

274
00:09:14,880 --> 00:09:16,880
jasof and i will be talking about

275
00:09:16,880 --> 00:09:18,160
three of the vulnerabilities that

276
00:09:18,160 --> 00:09:21,040
comprise cv2020 11901

277
00:09:21,040 --> 00:09:24,160
also known as the dns box so

278
00:09:24,160 --> 00:09:25,920
as long we said the vulnerability is

279
00:09:25,920 --> 00:09:28,240
found in the dns resolver component of

280
00:09:28,240 --> 00:09:30,720
track tcp and we need to refresh our

281
00:09:30,720 --> 00:09:32,560
memory about the basics of the

282
00:09:32,560 --> 00:09:36,880
dns protocol so dns

283
00:09:36,880 --> 00:09:38,959
is a core internet protocol designed to

284
00:09:38,959 --> 00:09:40,800
map between domain names and ip

285
00:09:40,800 --> 00:09:41,760
addresses

286
00:09:41,760 --> 00:09:43,760
it's a query response protocol client

287
00:09:43,760 --> 00:09:45,360
server architecture

288
00:09:45,360 --> 00:09:47,120
so the client resolves the name by

289
00:09:47,120 --> 00:09:49,440
issuing a query to a dns server

290
00:09:49,440 --> 00:09:52,839
so if for example you browse to

291
00:09:52,839 --> 00:09:54,080
www.exemple.com

292
00:09:54,080 --> 00:09:56,800
your browser issues a dns query of type

293
00:09:56,800 --> 00:09:57,519
a

294
00:09:57,519 --> 00:09:59,920
to one of the configured dns servers and

295
00:09:59,920 --> 00:10:01,279
the dns server

296
00:10:01,279 --> 00:10:04,000
look up the name and returns a response

297
00:10:04,000 --> 00:10:06,320
each response has a value

298
00:10:06,320 --> 00:10:08,720
for type a the value is an ipv for

299
00:10:08,720 --> 00:10:10,959
others

300
00:10:10,959 --> 00:10:13,519
dns servers can return multiple answers

301
00:10:13,519 --> 00:10:15,519
in the same dns response

302
00:10:15,519 --> 00:10:17,760
and an answer is specified as a resource

303
00:10:17,760 --> 00:10:19,360
record

304
00:10:19,360 --> 00:10:21,040
which consists of the following fields

305
00:10:21,040 --> 00:10:22,880
according to to the rfc

306
00:10:22,880 --> 00:10:27,120
and the name specifies uh specifies the

307
00:10:27,120 --> 00:10:29,519
the name to which the cycle differs each

308
00:10:29,519 --> 00:10:31,519
records have a type we talk about the

309
00:10:31,519 --> 00:10:32,720
the type shortly

310
00:10:32,720 --> 00:10:34,880
a class field within in practice is

311
00:10:34,880 --> 00:10:35,920
always constant

312
00:10:35,920 --> 00:10:38,720
a ttl field which specifies the number

313
00:10:38,720 --> 00:10:39,680
of seconds

314
00:10:39,680 --> 00:10:42,000
this record is valid and the value is

315
00:10:42,000 --> 00:10:44,240
specified in the r data field

316
00:10:44,240 --> 00:10:46,000
whose length is specified in the audi

317
00:10:46,000 --> 00:10:47,360
length field

318
00:10:47,360 --> 00:10:50,560
so both questions and answers have a

319
00:10:50,560 --> 00:10:51,600
type

320
00:10:51,600 --> 00:10:54,720
some of the common type includes type a

321
00:10:54,720 --> 00:10:57,600
which we saw before specifies an ipv4

322
00:10:57,600 --> 00:10:59,440
address for the query domain

323
00:10:59,440 --> 00:11:02,079
type c name which defines an alias a

324
00:11:02,079 --> 00:11:03,200
canonical name

325
00:11:03,200 --> 00:11:06,240
for the query domain and the type mx

326
00:11:06,240 --> 00:11:08,560
that specifies a domain name of a mail

327
00:11:08,560 --> 00:11:09,440
server

328
00:11:09,440 --> 00:11:11,920
for the query domain so if you send an

329
00:11:11,920 --> 00:11:12,480
email to

330
00:11:12,480 --> 00:11:16,000
gmail.com your mail client issues a dns

331
00:11:16,000 --> 00:11:17,440
query of type amix

332
00:11:17,440 --> 00:11:20,079
and get back a domain name of a mail

333
00:11:20,079 --> 00:11:20,880
server

334
00:11:20,880 --> 00:11:23,360
for gmail.com and because this is a name

335
00:11:23,360 --> 00:11:23,920
this name

336
00:11:23,920 --> 00:11:26,640
need to be resolved in into an ip

337
00:11:26,640 --> 00:11:29,200
address so a second dns query of type a

338
00:11:29,200 --> 00:11:30,160
in this case

339
00:11:30,160 --> 00:11:32,800
is generated by the client in practice

340
00:11:32,800 --> 00:11:34,880
most dns servers simply hand in

341
00:11:34,880 --> 00:11:38,320
type a records in the first dns response

342
00:11:38,320 --> 00:11:40,839
to reduce latency but nonetheless this

343
00:11:40,839 --> 00:11:42,720
functionality should be

344
00:11:42,720 --> 00:11:45,839
supported by dns resolvers

345
00:11:45,839 --> 00:11:47,360
so a little bit about domain names

346
00:11:47,360 --> 00:11:50,160
encoding so domain names are encoded as

347
00:11:50,160 --> 00:11:51,600
a sequence of labels

348
00:11:51,600 --> 00:11:55,440
so www is a label example is a label

349
00:11:55,440 --> 00:11:59,920
each label is preceded by length byte

350
00:11:59,920 --> 00:12:01,839
which specifies the number of characters

351
00:12:01,839 --> 00:12:03,519
this label occupies

352
00:12:03,519 --> 00:12:05,839
and the name is terminated with the zero

353
00:12:05,839 --> 00:12:07,040
length byte

354
00:12:07,040 --> 00:12:09,120
and according to the rfc the maximum

355
00:12:09,120 --> 00:12:10,720
label length is 63

356
00:12:10,720 --> 00:12:13,839
this will come up later

357
00:12:13,920 --> 00:12:15,519
so what the designers of the dns

358
00:12:15,519 --> 00:12:17,360
protocol notice is that

359
00:12:17,360 --> 00:12:19,839
there is a lot of repetition in a single

360
00:12:19,839 --> 00:12:20,639
dns

361
00:12:20,639 --> 00:12:25,200
packet so to reduce the size of the dns

362
00:12:25,200 --> 00:12:27,600
messages they simply employ

363
00:12:27,600 --> 00:12:30,959
a compression scheme in this scheme

364
00:12:30,959 --> 00:12:32,880
cooperation is achieved by replacing a

365
00:12:32,880 --> 00:12:35,279
sequence of labels with a pointer to

366
00:12:35,279 --> 00:12:37,519
prior occurrence of the same sequence

367
00:12:37,519 --> 00:12:39,920
so you can see a sample dns response

368
00:12:39,920 --> 00:12:40,560
packet

369
00:12:40,560 --> 00:12:43,680
or for of type mx

370
00:12:43,680 --> 00:12:46,160
for gmail.com you can see gmail.com is

371
00:12:46,160 --> 00:12:48,240
specified literally in the packet

372
00:12:48,240 --> 00:12:51,600
in offset hex c from the start and it so

373
00:12:51,600 --> 00:12:52,959
happens that gmat.com

374
00:12:52,959 --> 00:12:55,680
need to be specified additional times in

375
00:12:55,680 --> 00:12:56,560
the packet

376
00:12:56,560 --> 00:12:58,399
so instead of specifying gmail.com

377
00:12:58,399 --> 00:13:00,399
literally

378
00:13:00,399 --> 00:13:03,279
we we will use the the compression

379
00:13:03,279 --> 00:13:03,839
scheme

380
00:13:03,839 --> 00:13:06,639
we'll replace it with the pointer to to

381
00:13:06,639 --> 00:13:08,399
the offset from the start of the header

382
00:13:08,399 --> 00:13:08,880
with

383
00:13:08,880 --> 00:13:11,760
where it it is written so if you want to

384
00:13:11,760 --> 00:13:12,920
to write

385
00:13:12,920 --> 00:13:15,120
smtp.gmail.com we only need to write

386
00:13:15,120 --> 00:13:17,519
smtp the first label literally

387
00:13:17,519 --> 00:13:19,920
and the next two labels are specified

388
00:13:19,920 --> 00:13:21,839
using the compression pointer

389
00:13:21,839 --> 00:13:24,240
so in this scheme compression pointers

390
00:13:24,240 --> 00:13:25,760
are encoded in two bytes

391
00:13:25,760 --> 00:13:28,240
the first byte begins with one one as

392
00:13:28,240 --> 00:13:29,680
most significant bits

393
00:13:29,680 --> 00:13:32,480
and the other 14 bits specify an offset

394
00:13:32,480 --> 00:13:33,200
from the

395
00:13:33,200 --> 00:13:37,040
start of the header so we found

396
00:13:37,040 --> 00:13:39,040
the three vulnerabilities in the dns

397
00:13:39,040 --> 00:13:40,320
pulsing logic of

398
00:13:40,320 --> 00:13:43,519
track tcpap specifically in the function

399
00:13:43,519 --> 00:13:45,600
tf dns callbacks with which is

400
00:13:45,600 --> 00:13:47,279
responsible for the parsing

401
00:13:47,279 --> 00:13:50,079
and here you can see a pseudo code of

402
00:13:50,079 --> 00:13:50,880
this function

403
00:13:50,880 --> 00:13:54,320
responsible for pulsing mx resource

404
00:13:54,320 --> 00:13:55,360
records

405
00:13:55,360 --> 00:13:57,600
so we can see that the length of the

406
00:13:57,600 --> 00:13:59,360
hammock source name is calculated

407
00:13:59,360 --> 00:14:02,000
by the function expand label length

408
00:14:02,000 --> 00:14:03,600
based on that length a buffer is

409
00:14:03,600 --> 00:14:05,279
allocated on the heap

410
00:14:05,279 --> 00:14:08,399
and then a label to ascii

411
00:14:08,399 --> 00:14:11,519
copies the mxos name as ascii to the

412
00:14:11,519 --> 00:14:13,279
previously allocated buffer

413
00:14:13,279 --> 00:14:16,240
pointed to by ascii ptr and the snippet

414
00:14:16,240 --> 00:14:18,320
and what we can see is that labor task

415
00:14:18,320 --> 00:14:19,920
is not aware of the length of the

416
00:14:19,920 --> 00:14:21,360
allocated buffer

417
00:14:21,360 --> 00:14:24,000
this means that if for some reason

418
00:14:24,000 --> 00:14:25,360
expand label lengths return

419
00:14:25,360 --> 00:14:29,199
a length value which is too small then

420
00:14:29,199 --> 00:14:31,279
labor to ascii will overflow the buffer

421
00:14:31,279 --> 00:14:33,920
because it simply copies the

422
00:14:33,920 --> 00:14:36,800
bytes until a null byte is reached so

423
00:14:36,800 --> 00:14:38,560
this motivates us to

424
00:14:38,560 --> 00:14:42,560
look further into expand level length

425
00:14:42,560 --> 00:14:44,959
so this is a pseudocode for expandable

426
00:14:44,959 --> 00:14:46,639
lengths what this function is basically

427
00:14:46,639 --> 00:14:48,800
doing is sums up all the length byte

428
00:14:48,800 --> 00:14:51,040
while honoring compression so in more

429
00:14:51,040 --> 00:14:52,880
details it reads the current label

430
00:14:52,880 --> 00:14:53,519
length

431
00:14:53,519 --> 00:14:55,040
it then checks to see if there is

432
00:14:55,040 --> 00:14:56,959
compression or not

433
00:14:56,959 --> 00:14:58,560
if there is no compression which is the

434
00:14:58,560 --> 00:15:00,560
common case uh

435
00:15:00,560 --> 00:15:02,880
it adds the current label length plus

436
00:15:02,880 --> 00:15:04,880
one to the total length variable which

437
00:15:04,880 --> 00:15:06,160
is later returned

438
00:15:06,160 --> 00:15:09,360
from this function uh and advanced the

439
00:15:09,360 --> 00:15:10,480
inputted

440
00:15:10,480 --> 00:15:12,160
if there is compression it reads the

441
00:15:12,160 --> 00:15:14,480
compression offset computes a new label

442
00:15:14,480 --> 00:15:16,240
pointer based on that offset

443
00:15:16,240 --> 00:15:19,440
and then checks to see that the new

444
00:15:19,440 --> 00:15:21,680
level ptl points before the initial

445
00:15:21,680 --> 00:15:23,839
label pointer

446
00:15:23,839 --> 00:15:26,000
this means we can only jump backwards

447
00:15:26,000 --> 00:15:27,120
and we cannot

448
00:15:27,120 --> 00:15:29,839
jump forward this will come up later and

449
00:15:29,839 --> 00:15:30,320
the

450
00:15:30,320 --> 00:15:32,959
length calculation continues from the

451
00:15:32,959 --> 00:15:33,519
new

452
00:15:33,519 --> 00:15:37,360
label point so as you can see

453
00:15:37,360 --> 00:15:40,560
expand label length is not aware of the

454
00:15:40,560 --> 00:15:43,040
bounds of the packet buffer this led us

455
00:15:43,040 --> 00:15:44,959
to the first vulnerability a readout of

456
00:15:44,959 --> 00:15:46,639
bound vulnerability

457
00:15:46,639 --> 00:15:50,320
so this vulnerability could result in a

458
00:15:50,320 --> 00:15:52,399
deny of service if for example while

459
00:15:52,399 --> 00:15:55,519
iterating over the length bytes

460
00:15:55,519 --> 00:15:57,839
we read from an unmapped page but more

461
00:15:57,839 --> 00:15:59,920
interestingly it can

462
00:15:59,920 --> 00:16:02,959
lead to an info leak so

463
00:16:02,959 --> 00:16:05,040
tf dns label to ascii the function that

464
00:16:05,040 --> 00:16:06,880
does the copying has no bond checks

465
00:16:06,880 --> 00:16:08,000
either

466
00:16:08,000 --> 00:16:09,839
this means that data from the heap could

467
00:16:09,839 --> 00:16:11,199
be interpreted

468
00:16:11,199 --> 00:16:13,519
as dynamic source name this semi source

469
00:16:13,519 --> 00:16:14,320
name is later

470
00:16:14,320 --> 00:16:16,320
resolved by the client in an attempt to

471
00:16:16,320 --> 00:16:17,920
get an ip address

472
00:16:17,920 --> 00:16:20,399
uh so this means the data is leaked

473
00:16:20,399 --> 00:16:23,600
inside the mxos name itself

474
00:16:23,600 --> 00:16:25,600
so this vulnerability affects track

475
00:16:25,600 --> 00:16:26,639
version at least

476
00:16:26,639 --> 00:16:30,160
4.7 it was fixed in later versions

477
00:16:30,160 --> 00:16:32,560
as we we see we don't know the exact

478
00:16:32,560 --> 00:16:33,279
date

479
00:16:33,279 --> 00:16:35,839
they fixed the vulnerability but

480
00:16:35,839 --> 00:16:38,240
nonetheless the vulnerability is still

481
00:16:38,240 --> 00:16:39,360
found in the wild

482
00:16:39,360 --> 00:16:42,160
due to the complex supply chain effect

483
00:16:42,160 --> 00:16:43,920
so some vendors don't receive support

484
00:16:43,920 --> 00:16:45,440
from track or don't apply

485
00:16:45,440 --> 00:16:48,880
patches um and some devices

486
00:16:48,880 --> 00:16:50,720
don't even have the means to have them

487
00:16:50,720 --> 00:16:51,920
themselves so

488
00:16:51,920 --> 00:16:55,199
still something to worry about and

489
00:16:55,199 --> 00:16:57,040
this is nice and all but we are looking

490
00:16:57,040 --> 00:16:59,199
for an lc so let's go back to the

491
00:16:59,199 --> 00:17:00,959
function that calculates the length

492
00:17:00,959 --> 00:17:03,759
and examine its operation there are more

493
00:17:03,759 --> 00:17:05,039
issues with it

494
00:17:05,039 --> 00:17:07,760
so there is a limitation on the maximum

495
00:17:07,760 --> 00:17:08,640
on the

496
00:17:08,640 --> 00:17:11,039
the length of the domain name and the

497
00:17:11,039 --> 00:17:13,760
limitation according to the lfc is 255

498
00:17:13,760 --> 00:17:14,559
characters

499
00:17:14,559 --> 00:17:18,240
and this limitation is not enforced um

500
00:17:18,240 --> 00:17:20,079
expandable links further does not

501
00:17:20,079 --> 00:17:21,839
validate that the

502
00:17:21,839 --> 00:17:25,199
characters of the domain name

503
00:17:25,199 --> 00:17:27,280
they should be alphanumeric and iphone

504
00:17:27,280 --> 00:17:28,240
only but

505
00:17:28,240 --> 00:17:31,440
it doesn't validate the characters

506
00:17:31,440 --> 00:17:34,400
and most importantly the total length

507
00:17:34,400 --> 00:17:36,720
variables is stored as an unsight shot

508
00:17:36,720 --> 00:17:40,320
16 bit width and this is also the return

509
00:17:40,320 --> 00:17:42,400
value of explained label length

510
00:17:42,400 --> 00:17:45,039
so we will try to get rce by overflowing

511
00:17:45,039 --> 00:17:47,919
the total length variable

512
00:17:47,919 --> 00:17:50,640
so in order to pull this thing off we we

513
00:17:50,640 --> 00:17:52,559
need to construct a name whose length is

514
00:17:52,559 --> 00:17:54,640
larger than 64k

515
00:17:54,640 --> 00:17:57,120
and we wonder is it really possible can

516
00:17:57,120 --> 00:17:57,760
we

517
00:17:57,760 --> 00:17:59,679
we do this can we overflow the total

518
00:17:59,679 --> 00:18:01,440
rank variable within a single

519
00:18:01,440 --> 00:18:04,000
dns response bucket and the answer is

520
00:18:04,000 --> 00:18:06,400
yes we use the dns compression feature

521
00:18:06,400 --> 00:18:07,840
to achieve this

522
00:18:07,840 --> 00:18:09,440
the idea was to nest compression

523
00:18:09,440 --> 00:18:11,919
pointers within themselves

524
00:18:11,919 --> 00:18:14,720
so recall that expand the balance does

525
00:18:14,720 --> 00:18:16,320
not validate the characters of

526
00:18:16,320 --> 00:18:19,600
the domain name this means we can embed

527
00:18:19,600 --> 00:18:21,760
inside the name itself any bytes we want

528
00:18:21,760 --> 00:18:23,600
and in this case we chose compression

529
00:18:23,600 --> 00:18:24,400
pointers

530
00:18:24,400 --> 00:18:27,600
as we will see in the example shortly

531
00:18:27,600 --> 00:18:29,520
keep in mind during the example that we

532
00:18:29,520 --> 00:18:31,520
have two challenges to overcome

533
00:18:31,520 --> 00:18:33,760
uh first the there is a limitation on

534
00:18:33,760 --> 00:18:34,640
the

535
00:18:34,640 --> 00:18:36,880
on the size of the dns response packet

536
00:18:36,880 --> 00:18:39,240
the maximum size allowed is

537
00:18:39,240 --> 00:18:42,160
1460 bytes over udp

538
00:18:42,160 --> 00:18:44,640
and keep in mind that we can only jump

539
00:18:44,640 --> 00:18:45,600
backwards

540
00:18:45,600 --> 00:18:47,520
from our current level pointer so we

541
00:18:47,520 --> 00:18:50,640
need to overcome this challenge also

542
00:18:50,640 --> 00:18:52,160
so what you see in front of you is the

543
00:18:52,160 --> 00:18:54,000
basic construction we used in order to

544
00:18:54,000 --> 00:18:56,960
overflow the total length

545
00:18:56,960 --> 00:18:59,200
variable you can see a name arranging

546
00:18:59,200 --> 00:19:01,840
the metrics like form

547
00:19:01,840 --> 00:19:04,480
each row in the matrix has length 16

548
00:19:04,480 --> 00:19:05,360
bluish cells

549
00:19:05,360 --> 00:19:07,520
represent compression pointers and pink

550
00:19:07,520 --> 00:19:08,720
cells

551
00:19:08,720 --> 00:19:11,120
represent branch byte talk about those

552
00:19:11,120 --> 00:19:11,919
shortly

553
00:19:11,919 --> 00:19:14,480
so let's assume that we start expanding

554
00:19:14,480 --> 00:19:15,120
the name

555
00:19:15,120 --> 00:19:18,400
from this spot that is

556
00:19:18,400 --> 00:19:20,480
calculating the length we can actually

557
00:19:20,480 --> 00:19:22,080
achieve this in practice by using

558
00:19:22,080 --> 00:19:24,240
another compression pointer that will

559
00:19:24,240 --> 00:19:25,760
lend us exactly in that spot

560
00:19:25,760 --> 00:19:28,799
but for now take it as a given so if we

561
00:19:28,799 --> 00:19:30,559
start expanding the

562
00:19:30,559 --> 00:19:33,600
the length from this byte uh what

563
00:19:33,600 --> 00:19:35,200
expandable length does it checks

564
00:19:35,200 --> 00:19:36,880
to see if there is compression or not

565
00:19:36,880 --> 00:19:38,799
there is no compression in this case so

566
00:19:38,799 --> 00:19:40,880
we simply add

567
00:19:40,880 --> 00:19:44,160
zero f plus one bytes to the total

568
00:19:44,160 --> 00:19:47,600
length variable and skip zero f plus one

569
00:19:47,600 --> 00:19:49,840
because the metric is arranging this

570
00:19:49,840 --> 00:19:51,760
special matrix form we simply move to

571
00:19:51,760 --> 00:19:52,000
the

572
00:19:52,000 --> 00:19:55,280
next row and stay in the same column

573
00:19:55,280 --> 00:19:57,520
so the process repeats until we reach a

574
00:19:57,520 --> 00:19:59,120
branch byte

575
00:19:59,120 --> 00:20:01,039
for this value of th the purpose of the

576
00:20:01,039 --> 00:20:02,720
branch byte is to lead us to the next

577
00:20:02,720 --> 00:20:03,919
compression pointer

578
00:20:03,919 --> 00:20:05,919
for this value of the branch of the

579
00:20:05,919 --> 00:20:07,679
branch but we we will end at this

580
00:20:07,679 --> 00:20:09,120
compression pointer

581
00:20:09,120 --> 00:20:10,880
uh we can tell that it is compression

582
00:20:10,880 --> 00:20:12,720
pointer because the high nibble of the

583
00:20:12,720 --> 00:20:14,720
first byte is c

584
00:20:14,720 --> 00:20:16,159
and at this point we read the

585
00:20:16,159 --> 00:20:18,320
compression offset in this case it's

586
00:20:18,320 --> 00:20:21,120
zero e which uh points before our

587
00:20:21,120 --> 00:20:22,000
initial

588
00:20:22,000 --> 00:20:24,720
level pointer our initial offset that

589
00:20:24,720 --> 00:20:25,120
was

590
00:20:25,120 --> 00:20:27,679
zero f so we passed the the check that

591
00:20:27,679 --> 00:20:29,120
we can only jump backward

592
00:20:29,120 --> 00:20:31,440
and we continue expanding uh from this

593
00:20:31,440 --> 00:20:33,919
part the process continues we will reach

594
00:20:33,919 --> 00:20:35,280
a branch by it will end in

595
00:20:35,280 --> 00:20:38,000
another compression pointer and you can

596
00:20:38,000 --> 00:20:39,600
see that the total length

597
00:20:39,600 --> 00:20:42,400
value nearly doubles itself after we did

598
00:20:42,400 --> 00:20:44,080
this compression trick

599
00:20:44,080 --> 00:20:47,120
so we simply

600
00:20:47,120 --> 00:20:49,520
dude continue expanding the the name

601
00:20:49,520 --> 00:20:50,240
until the

602
00:20:50,240 --> 00:20:52,400
an albert is reached you can see that

603
00:20:52,400 --> 00:20:54,320
the total length value

604
00:20:54,320 --> 00:20:58,799
uh in this example turns out to be 1502

605
00:20:58,799 --> 00:21:00,559
bytes which is pretty neat if you

606
00:21:00,559 --> 00:21:02,400
consider the fact that the name only

607
00:21:02,400 --> 00:21:05,120
occupies 128 bytes

608
00:21:05,120 --> 00:21:06,960
so this of course doesn't overflow the

609
00:21:06,960 --> 00:21:09,120
total length variable yet

610
00:21:09,120 --> 00:21:11,120
but when we use the maximum label length

611
00:21:11,120 --> 00:21:12,640
allowed of

612
00:21:12,640 --> 00:21:16,720
x3f instead of xf shown in the example

613
00:21:16,720 --> 00:21:19,440
we reached using this construction a

614
00:21:19,440 --> 00:21:20,720
name

615
00:21:20,720 --> 00:21:24,000
whose length is greater than 64k thus

616
00:21:24,000 --> 00:21:26,240
overflowing the total length variable

617
00:21:26,240 --> 00:21:28,559
and recall that if expandable length

618
00:21:28,559 --> 00:21:30,799
returns a value which

619
00:21:30,799 --> 00:21:33,600
which is too small than the actual value

620
00:21:33,600 --> 00:21:35,360
we have in

621
00:21:35,360 --> 00:21:38,480
any base buffer overflow so this is a

622
00:21:38,480 --> 00:21:40,240
good rca candidate

623
00:21:40,240 --> 00:21:42,480
and it's important to know that this

624
00:21:42,480 --> 00:21:44,000
vulnerability can be triggered

625
00:21:44,000 --> 00:21:46,080
in response to every query type

626
00:21:46,080 --> 00:21:47,840
supported by the network stack

627
00:21:47,840 --> 00:21:50,720
by using cname resource records which

628
00:21:50,720 --> 00:21:51,440
must be

629
00:21:51,440 --> 00:21:55,200
passed in every dns response

630
00:21:55,200 --> 00:21:56,640
and this vulnerability affects the

631
00:21:56,640 --> 00:21:58,559
latest track version at the time of

632
00:21:58,559 --> 00:22:00,400
disclosure

633
00:22:00,400 --> 00:22:03,200
so we were pretty happy about it at this

634
00:22:03,200 --> 00:22:03,840
stage

635
00:22:03,840 --> 00:22:06,880
and we purchased a new device

636
00:22:06,880 --> 00:22:09,440
schneiderlin qps device at this point

637
00:22:09,440 --> 00:22:10,000
and

638
00:22:10,000 --> 00:22:11,919
we wanted to to know if the

639
00:22:11,919 --> 00:22:13,360
vulnerabilities

640
00:22:13,360 --> 00:22:16,559
uh affect this ups

641
00:22:16,559 --> 00:22:18,799
device and what we saw is the track

642
00:22:18,799 --> 00:22:20,000
fixes the

643
00:22:20,000 --> 00:22:22,320
readout of the band vulnerability which

644
00:22:22,320 --> 00:22:24,480
means the ups device has a slightly

645
00:22:24,480 --> 00:22:27,280
newer version of track than the one we

646
00:22:27,280 --> 00:22:28,159
examined

647
00:22:28,159 --> 00:22:30,799
you can see that the audi length value

648
00:22:30,799 --> 00:22:31,520
is checked

649
00:22:31,520 --> 00:22:34,880
against the remaining size of the packet

650
00:22:34,880 --> 00:22:37,039
and now expand level lengths accept a

651
00:22:37,039 --> 00:22:38,400
third argument

652
00:22:38,400 --> 00:22:42,400
label nptr which is calculated based on

653
00:22:42,400 --> 00:22:44,559
the rdl x value

654
00:22:44,559 --> 00:22:46,880
so what expandable length does when it

655
00:22:46,880 --> 00:22:48,720
reaches label nptel

656
00:22:48,720 --> 00:22:50,960
it simply stops processing without any

657
00:22:50,960 --> 00:22:53,120
error and returns the current total

658
00:22:53,120 --> 00:22:54,960
length this is perfect from an

659
00:22:54,960 --> 00:22:56,559
attacker's standpoint because audi

660
00:22:56,559 --> 00:22:58,159
length is attacker controlled

661
00:22:58,159 --> 00:23:01,200
so if we can specify a value which is

662
00:23:01,200 --> 00:23:05,280
smaller than the actual audix value

663
00:23:05,280 --> 00:23:07,200
there is a chance that expanded balance

664
00:23:07,200 --> 00:23:08,720
returns a value which is

665
00:23:08,720 --> 00:23:12,000
too small so here for example you can

666
00:23:12,000 --> 00:23:12,320
see

667
00:23:12,320 --> 00:23:15,679
a resource record uh so instead of

668
00:23:15,679 --> 00:23:18,240
specifying 20 as the audience we specify

669
00:23:18,240 --> 00:23:19,039
seven

670
00:23:19,039 --> 00:23:21,120
and level and ptr will points here in

671
00:23:21,120 --> 00:23:22,159
this case

672
00:23:22,159 --> 00:23:25,520
but expand level length returns five and

673
00:23:25,520 --> 00:23:27,600
tf dns label to ask you will copy the

674
00:23:27,600 --> 00:23:29,120
entire name exhaust name

675
00:23:29,120 --> 00:23:32,080
thus overflowing our buffer so another

676
00:23:32,080 --> 00:23:34,400
artifact we found

677
00:23:34,400 --> 00:23:36,880
during our research is that we can link

678
00:23:36,880 --> 00:23:38,640
another infrastructure

679
00:23:38,640 --> 00:23:41,760
uh during the mx parsing logic so you

680
00:23:41,760 --> 00:23:43,600
can see here when other infrastructure

681
00:23:43,600 --> 00:23:44,880
is allocated

682
00:23:44,880 --> 00:23:47,600
and in these two error flows it is not

683
00:23:47,600 --> 00:23:48,159
freed

684
00:23:48,159 --> 00:23:50,640
so this means we have two ways to to

685
00:23:50,640 --> 00:23:52,240
leak another infrastructure

686
00:23:52,240 --> 00:23:54,960
first by specifying an audi length value

687
00:23:54,960 --> 00:23:56,559
which is smaller than two

688
00:23:56,559 --> 00:23:59,360
like one or by causing expandable

689
00:23:59,360 --> 00:24:01,919
lengths to return a length of zero

690
00:24:01,919 --> 00:24:03,600
and we can do this by using a bad

691
00:24:03,600 --> 00:24:06,080
compression pointer for example

692
00:24:06,080 --> 00:24:08,880
so the size of the leak is hex 3c and

693
00:24:08,880 --> 00:24:10,960
this leaks come in handy when exploiting

694
00:24:10,960 --> 00:24:12,159
heavy vulnerabilities

695
00:24:12,159 --> 00:24:15,120
and in fact we use the exact same memory

696
00:24:15,120 --> 00:24:16,400
leak in our exploit

697
00:24:16,400 --> 00:24:20,000
as you will see later so to summarize

698
00:24:20,000 --> 00:24:23,919
uh cv 2020 11901 is comprised of four

699
00:24:23,919 --> 00:24:25,679
vulnerabilities we talk about three of

700
00:24:25,679 --> 00:24:27,360
them and one artifact

701
00:24:27,360 --> 00:24:29,120
so the first vulnerability readout of

702
00:24:29,120 --> 00:24:30,799
band vulnerability affects older

703
00:24:30,799 --> 00:24:32,159
versions of the stack

704
00:24:32,159 --> 00:24:34,080
but was fixed in later versions as we

705
00:24:34,080 --> 00:24:35,600
saw the integer over

706
00:24:35,600 --> 00:24:38,400
flow vulnerability and affects both old

707
00:24:38,400 --> 00:24:40,320
and newer versions of the stack

708
00:24:40,320 --> 00:24:42,159
the bad arduino's vulnerability is a

709
00:24:42,159 --> 00:24:43,760
result

710
00:24:43,760 --> 00:24:45,600
from a bad fix for the results of band

711
00:24:45,600 --> 00:24:46,880
vulnerability so

712
00:24:46,880 --> 00:24:48,799
it affects only newer versions of the

713
00:24:48,799 --> 00:24:50,960
stack and the artifact is present

714
00:24:50,960 --> 00:24:52,880
in a bottle and your version of the

715
00:24:52,880 --> 00:24:55,039
stack so the main takeaway from this

716
00:24:55,039 --> 00:24:57,279
part is that a device can be affected by

717
00:24:57,279 --> 00:24:59,279
one or more vulnerabilities depending on

718
00:24:59,279 --> 00:25:01,520
the exact version of track they use

719
00:25:01,520 --> 00:25:04,000
and this fragmentation causes it

720
00:25:04,000 --> 00:25:06,880
security personnel

721
00:25:06,880 --> 00:25:08,720
this fragmentation makes the life of the

722
00:25:08,720 --> 00:25:10,960
i.t security personnel more challenging

723
00:25:10,960 --> 00:25:12,880
to know whether their devices are

724
00:25:12,880 --> 00:25:14,320
affected or not

725
00:25:14,320 --> 00:25:16,559
so now i'll hand over the mic to ariel

726
00:25:16,559 --> 00:25:20,000
shawn he will talk about exploitation

727
00:25:20,000 --> 00:25:22,640
thanks moshe hi i'm ariel i'm also a

728
00:25:22,640 --> 00:25:24,720
security researcher at jsof

729
00:25:24,720 --> 00:25:26,960
and today i'm going to talk about

730
00:25:26,960 --> 00:25:29,360
exploitation specifically exploiting

731
00:25:29,360 --> 00:25:31,039
one of the vulnerabilities moshe talked

732
00:25:31,039 --> 00:25:34,080
about on a schneider electric ups device

733
00:25:34,080 --> 00:25:38,400
so a ups ups essentially stands for

734
00:25:38,400 --> 00:25:41,279
uninterruptable power supply it's a big

735
00:25:41,279 --> 00:25:43,039
battery connected to the wall

736
00:25:43,039 --> 00:25:45,039
and you plug all sorts of devices into

737
00:25:45,039 --> 00:25:46,400
it that you don't want them to suffer

738
00:25:46,400 --> 00:25:48,640
from power outages or power fluctuations

739
00:25:48,640 --> 00:25:49,520
such as

740
00:25:49,520 --> 00:25:51,840
medical devices critical infrastructure

741
00:25:51,840 --> 00:25:52,640
server racks

742
00:25:52,640 --> 00:25:56,559
stuff like that um so we exploit on a

743
00:25:56,559 --> 00:25:58,400
ups made by schneider specifically on

744
00:25:58,400 --> 00:26:00,240
the network card

745
00:26:00,240 --> 00:26:03,600
um this uh the network card houses a

746
00:26:03,600 --> 00:26:06,320
turbo 186 processor it's an x86 based

747
00:26:06,320 --> 00:26:07,760
processor

748
00:26:07,760 --> 00:26:10,559
all code runs in 16-bit real mode so os

749
00:26:10,559 --> 00:26:11,200
track

750
00:26:11,200 --> 00:26:14,480
app whatever everything meaning also

751
00:26:14,480 --> 00:26:15,279
that it has

752
00:26:15,279 --> 00:26:17,840
basically no modern mitigation so no slr

753
00:26:17,840 --> 00:26:18,559
no depth

754
00:26:18,559 --> 00:26:21,919
making our life a bit easier um

755
00:26:21,919 --> 00:26:24,159
one crook that this processor is

756
00:26:24,159 --> 00:26:26,480
different from x86 is that the

757
00:26:26,480 --> 00:26:29,520
it shifts it shifts the segment register

758
00:26:29,520 --> 00:26:31,679
by eight bits instead of four bits

759
00:26:31,679 --> 00:26:33,200
and we'll talk about that a bit more

760
00:26:33,200 --> 00:26:34,799
later

761
00:26:34,799 --> 00:26:36,720
and during our research we had

762
00:26:36,720 --> 00:26:39,039
essentially no debugging capabilities

763
00:26:39,039 --> 00:26:41,120
so we focused mainly on the static

764
00:26:41,120 --> 00:26:43,120
analysis and reverse engineering

765
00:26:43,120 --> 00:26:44,480
and we also had a little bit of

766
00:26:44,480 --> 00:26:46,320
assistance from partial crash dumps

767
00:26:46,320 --> 00:26:47,919
including a stack trace and some

768
00:26:47,919 --> 00:26:50,960
registers so just to recap the

769
00:26:50,960 --> 00:26:52,400
vulnerability

770
00:26:52,400 --> 00:26:54,880
um our primitive is a heap overflow

771
00:26:54,880 --> 00:26:57,200
through dns response parsing

772
00:26:57,200 --> 00:26:58,720
and because this is a slightly newer

773
00:26:58,720 --> 00:27:00,640
version of trek we can only overflow

774
00:27:00,640 --> 00:27:03,600
with alphanumeric characters and hyphens

775
00:27:03,600 --> 00:27:07,360
we chose to exploit on this device using

776
00:27:07,360 --> 00:27:10,640
the bad rd length venerability

777
00:27:10,640 --> 00:27:13,919
um so we can overflow through

778
00:27:13,919 --> 00:27:16,159
all dns response types as much as i said

779
00:27:16,159 --> 00:27:18,000
earlier so whether it be

780
00:27:18,000 --> 00:27:21,520
cname a mx ptr all response types

781
00:27:21,520 --> 00:27:22,720
and but we chose the overflow

782
00:27:22,720 --> 00:27:24,960
specifically through mx and because when

783
00:27:24,960 --> 00:27:25,760
the device

784
00:27:25,760 --> 00:27:27,760
boots up the network card will send out

785
00:27:27,760 --> 00:27:29,840
three mx requests to

786
00:27:29,840 --> 00:27:33,120
notify about some events via email and

787
00:27:33,120 --> 00:27:34,640
this is very advantageous from an

788
00:27:34,640 --> 00:27:36,240
exploitation point of view

789
00:27:36,240 --> 00:27:37,919
and because we would like as much

790
00:27:37,919 --> 00:27:39,760
interactivity as possible in our exploit

791
00:27:39,760 --> 00:27:40,640
to allow

792
00:27:40,640 --> 00:27:44,080
easier heap shaping we don't

793
00:27:44,080 --> 00:27:46,399
care a lot and that we need to crash the

794
00:27:46,399 --> 00:27:48,399
device in order for this to happen

795
00:27:48,399 --> 00:27:50,240
since we probably need to get the heap

796
00:27:50,240 --> 00:27:51,840
into a relatively deterministic state

797
00:27:51,840 --> 00:27:53,200
anyway having no

798
00:27:53,200 --> 00:27:55,120
debugging capability so no real insight

799
00:27:55,120 --> 00:27:56,399
into the heap

800
00:27:56,399 --> 00:27:57,919
and also the penalty for crashing the

801
00:27:57,919 --> 00:27:59,440
network card is relatively low

802
00:27:59,440 --> 00:28:03,039
as it has no functional or vis

803
00:28:03,039 --> 00:28:06,480
or visual influence on the ups

804
00:28:06,480 --> 00:28:08,799
and the only effect is a few minutes a

805
00:28:08,799 --> 00:28:10,240
few seconds of downtime

806
00:28:10,240 --> 00:28:14,159
on the network card web interface

807
00:28:14,320 --> 00:28:17,360
so we chose to overflow the ts dns cache

808
00:28:17,360 --> 00:28:20,159
entry struct using our heap overflow

809
00:28:20,159 --> 00:28:22,640
um as you can see it has all sorts of

810
00:28:22,640 --> 00:28:23,440
interesting

811
00:28:23,440 --> 00:28:26,559
fields um it has a list of other info

812
00:28:26,559 --> 00:28:28,080
structs adder info holds

813
00:28:28,080 --> 00:28:30,960
the contents of dns responses so if you

814
00:28:30,960 --> 00:28:32,399
resolve an ip address it will have the

815
00:28:32,399 --> 00:28:33,760
ip if you resolve the name it will have

816
00:28:33,760 --> 00:28:34,399
a name

817
00:28:34,399 --> 00:28:37,120
all sorts of stuff like that and other

818
00:28:37,120 --> 00:28:37,679
than that

819
00:28:37,679 --> 00:28:39,840
it has other interesting pointers you

820
00:28:39,840 --> 00:28:41,279
can see it's in a doubly linked list

821
00:28:41,279 --> 00:28:44,159
always advantageous for exploitation and

822
00:28:44,159 --> 00:28:45,279
it's referenced

823
00:28:45,279 --> 00:28:47,440
often in dns response parsing logic

824
00:28:47,440 --> 00:28:49,039
which is the logic we can trigger

825
00:28:49,039 --> 00:28:51,600
so this track was interesting for us so

826
00:28:51,600 --> 00:28:52,480
assuming we can

827
00:28:52,480 --> 00:28:55,200
overflow this truck what can we do with

828
00:28:55,200 --> 00:28:55,679
it

829
00:28:55,679 --> 00:28:58,799
so for example during cname record

830
00:28:58,799 --> 00:29:00,320
processing

831
00:29:00,320 --> 00:29:02,720
you can see this bit of pseudocode it

832
00:29:02,720 --> 00:29:04,640
will first take a pointer from the cache

833
00:29:04,640 --> 00:29:05,360
entry the

834
00:29:05,360 --> 00:29:07,360
the adderinfo list ptr and save it in a

835
00:29:07,360 --> 00:29:08,640
local variable

836
00:29:08,640 --> 00:29:12,080
it will then expand the cname allocate

837
00:29:12,080 --> 00:29:14,960
the cname we provided on the heap and it

838
00:29:14,960 --> 00:29:16,159
will later

839
00:29:16,159 --> 00:29:19,520
put the pointer to that heap buffer

840
00:29:19,520 --> 00:29:22,320
into the address provided from dns cache

841
00:29:22,320 --> 00:29:23,279
entry

842
00:29:23,279 --> 00:29:25,919
so basically if we can overflow the dns

843
00:29:25,919 --> 00:29:27,039
ptr field

844
00:29:27,039 --> 00:29:30,240
of the cache entry we can with some

845
00:29:30,240 --> 00:29:32,559
arbitrary value we can write a pointer

846
00:29:32,559 --> 00:29:33,760
to some

847
00:29:33,760 --> 00:29:37,440
address in the address space

848
00:29:37,440 --> 00:29:40,320
so a control pointer right uh pointers

849
00:29:40,320 --> 00:29:41,840
in six and bit real mode are made

850
00:29:41,840 --> 00:29:43,600
absolute pointers are made of two bytes

851
00:29:43,600 --> 00:29:45,440
offset and two byte segment

852
00:29:45,440 --> 00:29:46,799
and we can write them to any

853
00:29:46,799 --> 00:29:48,640
alphanumeric address since our

854
00:29:48,640 --> 00:29:51,039
overflow is alphanumeric and this is a

855
00:29:51,039 --> 00:29:52,480
strong exploitation primitive

856
00:29:52,480 --> 00:29:54,080
writing data to places you're not

857
00:29:54,080 --> 00:29:55,520
supposed to write to is

858
00:29:55,520 --> 00:29:56,960
always interesting from an exploiter

859
00:29:56,960 --> 00:29:59,039
point of view so we chose to go ahead

860
00:29:59,039 --> 00:29:59,520
with this

861
00:29:59,520 --> 00:30:02,559
primitive our overflow

862
00:30:02,559 --> 00:30:04,559
is a simple heap overflow it's from the

863
00:30:04,559 --> 00:30:06,960
end of the mx name buffer with no

864
00:30:06,960 --> 00:30:09,520
jumps it's a contiguous overflow so in

865
00:30:09,520 --> 00:30:11,520
order to overflow the dns cache entry we

866
00:30:11,520 --> 00:30:13,440
need it to be placed

867
00:30:13,440 --> 00:30:16,559
linearly after us

868
00:30:17,039 --> 00:30:18,640
this can prove a bit tricky since the

869
00:30:18,640 --> 00:30:20,960
dns cache entry is allocated on dns

870
00:30:20,960 --> 00:30:22,480
request creation

871
00:30:22,480 --> 00:30:24,640
and our mx name buffer is obviously

872
00:30:24,640 --> 00:30:26,480
allocated on response parsing

873
00:30:26,480 --> 00:30:29,520
which happens chronologically later and

874
00:30:29,520 --> 00:30:31,039
we need the cache entry to be placed

875
00:30:31,039 --> 00:30:32,640
after our name buffer so

876
00:30:32,640 --> 00:30:34,960
we need to do some shaping to make this

877
00:30:34,960 --> 00:30:36,880
happen

878
00:30:36,880 --> 00:30:39,840
luckily this heap is a bit sophisticated

879
00:30:39,840 --> 00:30:41,120
and it

880
00:30:41,120 --> 00:30:44,399
supports tight fit preference meaning

881
00:30:44,399 --> 00:30:46,640
that if you have a hole of a specific

882
00:30:46,640 --> 00:30:48,080
size as shown in

883
00:30:48,080 --> 00:30:51,440
this diagram it will prefer to take the

884
00:30:51,440 --> 00:30:53,200
tightest fit for the allocation size

885
00:30:53,200 --> 00:30:54,080
requested

886
00:30:54,080 --> 00:30:56,159
from all the three blocks so if we

887
00:30:56,159 --> 00:30:58,799
create for example a whole pattern

888
00:30:58,799 --> 00:31:01,039
that has a hole the size of the dns

889
00:31:01,039 --> 00:31:02,480
cache entry struct

890
00:31:02,480 --> 00:31:04,559
after a hole the size of the mxname

891
00:31:04,559 --> 00:31:06,320
buffer we're going to allocate

892
00:31:06,320 --> 00:31:09,279
um it can assist us in reaching the

893
00:31:09,279 --> 00:31:10,880
linear overflow target

894
00:31:10,880 --> 00:31:12,799
however we do need to separate these

895
00:31:12,799 --> 00:31:14,960
holes with some allocated separator of

896
00:31:14,960 --> 00:31:16,840
some sort to prevent free block

897
00:31:16,840 --> 00:31:19,440
coalescing

898
00:31:19,440 --> 00:31:22,399
so we'll use the memory leak artifact

899
00:31:22,399 --> 00:31:23,840
moshe talked about to create the

900
00:31:23,840 --> 00:31:25,279
separators

901
00:31:25,279 --> 00:31:27,440
and simple name dns name allocation to

902
00:31:27,440 --> 00:31:28,399
create the names

903
00:31:28,399 --> 00:31:30,159
as they are freed after dns response

904
00:31:30,159 --> 00:31:31,600
parsing is finished and we have three

905
00:31:31,600 --> 00:31:34,000
responses

906
00:31:34,000 --> 00:31:36,000
so the limitations on our cname pointer

907
00:31:36,000 --> 00:31:37,279
right are

908
00:31:37,279 --> 00:31:39,360
the cname pointer is written to an

909
00:31:39,360 --> 00:31:40,880
address we overflowed into the cache

910
00:31:40,880 --> 00:31:43,200
entry so it must be alphanumeric

911
00:31:43,200 --> 00:31:46,960
um this is a little ndn architecture

912
00:31:46,960 --> 00:31:49,679
um so the offset and segment will look

913
00:31:49,679 --> 00:31:50,480
like that

914
00:31:50,480 --> 00:31:52,320
and since our overflow is after all a

915
00:31:52,320 --> 00:31:54,080
string overflow we do have a trailing

916
00:31:54,080 --> 00:31:54,799
nullbyte

917
00:31:54,799 --> 00:31:56,640
which can be used as the segment most

918
00:31:56,640 --> 00:31:58,480
significant byte allowing us a bit more

919
00:31:58,480 --> 00:32:00,799
flexibility in what we can overflow

920
00:32:00,799 --> 00:32:04,080
however nothing interesting is placed in

921
00:32:04,080 --> 00:32:05,840
a strictly alpha numeric address so no

922
00:32:05,840 --> 00:32:08,399
code no heap no stack no globals

923
00:32:08,399 --> 00:32:11,679
and nothing interesting really

924
00:32:11,679 --> 00:32:13,120
luckily because of the weird

925
00:32:13,120 --> 00:32:16,080
segmentation feature of this processor

926
00:32:16,080 --> 00:32:17,760
and we can easily combine two

927
00:32:17,760 --> 00:32:19,519
alphanumeric bytes to reach a

928
00:32:19,519 --> 00:32:20,960
non-alphanumeric byte

929
00:32:20,960 --> 00:32:22,880
so that will look something like this if

930
00:32:22,880 --> 00:32:25,039
we have a valid segment that we can

931
00:32:25,039 --> 00:32:27,039
overflow such as nullbyte4b

932
00:32:27,039 --> 00:32:29,440
and we add to it an alphanumeric offset

933
00:32:29,440 --> 00:32:30,159
such as

934
00:32:30,159 --> 00:32:33,840
a a the result will contain a

935
00:32:33,840 --> 00:32:35,519
non-alphanumeric

936
00:32:35,519 --> 00:32:37,679
byte corresponding directly to a

937
00:32:37,679 --> 00:32:39,200
non-alphanumeric segment

938
00:32:39,200 --> 00:32:40,880
this is possible due to the fact that

939
00:32:40,880 --> 00:32:43,039
the shift is by 8 bits and not 4 bits

940
00:32:43,039 --> 00:32:44,399
giving us more flexibility in this

941
00:32:44,399 --> 00:32:45,919
calculation

942
00:32:45,919 --> 00:32:48,240
and using this technique we can reach

943
00:32:48,240 --> 00:32:49,679
the heap utility

944
00:32:49,679 --> 00:32:52,240
functions text section allowing us to

945
00:32:52,240 --> 00:32:54,840
directly override with our pointer heap

946
00:32:54,840 --> 00:32:57,840
code again no mitigation so no depth no

947
00:32:57,840 --> 00:32:59,039
slr

948
00:32:59,039 --> 00:33:02,000
um so when you can overwrite code with a

949
00:33:02,000 --> 00:33:03,519
pointer one of the interesting

950
00:33:03,519 --> 00:33:05,840
things to do in x86 is to overwrite the

951
00:33:05,840 --> 00:33:07,039
far call destination

952
00:33:07,039 --> 00:33:08,880
as it is encoded directly with an

953
00:33:08,880 --> 00:33:10,960
absolute pointer in it

954
00:33:10,960 --> 00:33:14,080
um so if we can overwrite a farco like

955
00:33:14,080 --> 00:33:14,399
this

956
00:33:14,399 --> 00:33:18,320
in the in some hebrew flow we can

957
00:33:18,320 --> 00:33:20,880
cause the far call to direct execution

958
00:33:20,880 --> 00:33:22,159
to our cname buffer

959
00:33:22,159 --> 00:33:24,960
instead of the original destination and

960
00:33:24,960 --> 00:33:26,880
we chose in our example to patch

961
00:33:26,880 --> 00:33:29,919
a farco in a free airflow called

962
00:33:29,919 --> 00:33:31,600
when heap metadata corruption is

963
00:33:31,600 --> 00:33:33,519
detected and

964
00:33:33,519 --> 00:33:34,720
so when the metadata corruption is

965
00:33:34,720 --> 00:33:36,720
detected the farco

966
00:33:36,720 --> 00:33:39,919
will execute our payload so just to

967
00:33:39,919 --> 00:33:41,360
recap the vulnerability

968
00:33:41,360 --> 00:33:43,760
we shape the heap to allow the mxn name

969
00:33:43,760 --> 00:33:45,760
buffer to be placed before the dns cache

970
00:33:45,760 --> 00:33:46,559
entry

971
00:33:46,559 --> 00:33:49,600
we then overflow the dnsc other info ptr

972
00:33:49,600 --> 00:33:52,720
so it will point into some heap code

973
00:33:52,720 --> 00:33:55,679
specifically a farco then a cnn record

974
00:33:55,679 --> 00:33:57,200
we provided is processed

975
00:33:57,200 --> 00:34:00,960
and the name and the r data of the

976
00:34:00,960 --> 00:34:02,960
cname is allocated on the heap in this

977
00:34:02,960 --> 00:34:04,640
case it will be some evil payloads or

978
00:34:04,640 --> 00:34:04,960
some

979
00:34:04,960 --> 00:34:07,440
alphanumeric shell code of some sort

980
00:34:07,440 --> 00:34:09,520
then the pointer to that buffer will be

981
00:34:09,520 --> 00:34:10,000
placed

982
00:34:10,000 --> 00:34:12,879
into the pointer we overflowed on the

983
00:34:12,879 --> 00:34:14,320
cache entry

984
00:34:14,320 --> 00:34:17,839
struct essentially overriding the farco

985
00:34:17,839 --> 00:34:19,440
destination in the free airflow

986
00:34:19,440 --> 00:34:21,918
redirects redirecting execution to the

987
00:34:21,918 --> 00:34:24,560
evil payload

988
00:34:24,560 --> 00:34:27,679
so to trigger this this error flow will

989
00:34:27,679 --> 00:34:28,560
be triggered

990
00:34:28,560 --> 00:34:32,159
when we free the mx name we overflowed

991
00:34:32,159 --> 00:34:32,719
from

992
00:34:32,719 --> 00:34:34,399
since we overflowed the end of it some

993
00:34:34,399 --> 00:34:36,159
metadata was corrupted and when it will

994
00:34:36,159 --> 00:34:37,359
be freed

995
00:34:37,359 --> 00:34:40,800
um our code will get executed and our

996
00:34:40,800 --> 00:34:43,280
payload contains a two-stage decoder

997
00:34:43,280 --> 00:34:45,599
to allow us to run arbitrary payloads

998
00:34:45,599 --> 00:34:47,440
and not be

999
00:34:47,440 --> 00:34:49,199
contained only to alphanumeric shell

1000
00:34:49,199 --> 00:34:50,719
codes and

1001
00:34:50,719 --> 00:34:53,679
in the demo you'll see soon we execute a

1002
00:34:53,679 --> 00:34:54,560
payload

1003
00:34:54,560 --> 00:34:57,680
turning of power to the ups power

1004
00:34:57,680 --> 00:34:59,119
outlets essentially turning off any

1005
00:34:59,119 --> 00:35:00,800
device connected to it

1006
00:35:00,800 --> 00:35:03,200
achieving arbitrary payload execution

1007
00:35:03,200 --> 00:35:04,960
and owning the device

1008
00:35:04,960 --> 00:35:17,839
so let's see a short table

1009
00:35:28,839 --> 00:35:31,839
foreign

1010
00:35:42,839 --> 00:35:45,839
so

1011
00:35:56,880 --> 00:35:59,839
foreign

1012
00:36:10,839 --> 00:36:13,599
so

1013
00:36:13,599 --> 00:36:16,880
everyone thanks for listening thanks for

1014
00:36:16,880 --> 00:36:17,680
joining us

1015
00:36:17,680 --> 00:36:20,880
uh we're here to take uh any questions

1016
00:36:20,880 --> 00:36:23,440
uh you have about uh what we've just

1017
00:36:23,440 --> 00:36:24,240
seen

1018
00:36:24,240 --> 00:36:27,280
uh feel free in the last questions in

1019
00:36:27,280 --> 00:36:29,680
the chat

1020
00:36:31,839 --> 00:36:35,119
um all the speakers are here i'm shlomi

1021
00:36:35,119 --> 00:36:41,520
and ariel and monsieur are here with me

1022
00:36:41,520 --> 00:36:44,720
so we have questions um

1023
00:36:44,720 --> 00:36:46,560
someone asked about finding these

1024
00:36:46,560 --> 00:36:47,920
vulnerabilities

1025
00:36:47,920 --> 00:36:49,599
they were all found manually by reverse

1026
00:36:49,599 --> 00:36:52,079
engineering we had to reverse engineer

1027
00:36:52,079 --> 00:36:54,400
several different devices to get a

1028
00:36:54,400 --> 00:36:55,119
handle on

1029
00:36:55,119 --> 00:36:57,760
on the the variances in the track stack

1030
00:36:57,760 --> 00:36:58,400
the different

1031
00:36:58,400 --> 00:37:01,520
uh variations of uh

1032
00:37:01,520 --> 00:37:03,280
what the vulnerabilities look like but

1033
00:37:03,280 --> 00:37:04,720
everything was done uh

1034
00:37:04,720 --> 00:37:07,040
manually and then some bindif and you

1035
00:37:07,040 --> 00:37:07,760
know on the

1036
00:37:07,760 --> 00:37:10,800
basic tools gabra

1037
00:37:10,800 --> 00:37:14,160
some ida some

1038
00:37:14,160 --> 00:37:18,000
hacked ida modules to support

1039
00:37:20,839 --> 00:37:23,839
architectures

1040
00:37:26,000 --> 00:37:30,400
maybe we have another one no these are

1041
00:37:30,400 --> 00:37:33,839
source code okay so john

1042
00:37:33,839 --> 00:37:37,200
is asking if we had source code

1043
00:37:37,200 --> 00:37:41,200
for our research yeah so um

1044
00:37:41,200 --> 00:37:44,160
so yeah the answer is no we we did our

1045
00:37:44,160 --> 00:37:45,760
research

1046
00:37:45,760 --> 00:37:49,119
engineering several devices

1047
00:37:49,119 --> 00:37:52,480
and and what we saw in the slides of the

1048
00:37:52,480 --> 00:37:55,520
pseudocode essentially

1049
00:37:55,520 --> 00:37:59,280
decompilation what we did have is we had

1050
00:37:59,280 --> 00:38:01,119
pretty good uh the bad symbols

1051
00:38:01,119 --> 00:38:04,160
um the

1052
00:38:04,160 --> 00:38:05,920
stack being in so many different devices

1053
00:38:05,920 --> 00:38:07,280
different vendors

1054
00:38:07,280 --> 00:38:09,520
compile them differently um so some of

1055
00:38:09,520 --> 00:38:11,119
the vendors compiled them with quite a

1056
00:38:11,119 --> 00:38:11,839
few

1057
00:38:11,839 --> 00:38:14,240
uh debug symbols and that was of course

1058
00:38:14,240 --> 00:38:16,799
very helpful

1059
00:38:16,839 --> 00:38:18,530
okay we have a

1060
00:38:18,530 --> 00:38:19,839
[Music]

1061
00:38:19,839 --> 00:38:22,560
question what effect will ripple 20 have

1062
00:38:22,560 --> 00:38:23,440
on the defense

1063
00:38:23,440 --> 00:38:26,720
industries um so that's that's a pretty

1064
00:38:26,720 --> 00:38:27,760
good question

1065
00:38:27,760 --> 00:38:29,200
it's a question that we're at to some

1066
00:38:29,200 --> 00:38:30,880
extent asking ourselves because of

1067
00:38:30,880 --> 00:38:32,160
course it's it's

1068
00:38:32,160 --> 00:38:34,640
uh quite difficult to get reliable

1069
00:38:34,640 --> 00:38:35,359
information

1070
00:38:35,359 --> 00:38:38,560
in this case um we can say that we do

1071
00:38:38,560 --> 00:38:39,200
know

1072
00:38:39,200 --> 00:38:43,760
of at least a few defense contractors

1073
00:38:43,760 --> 00:38:45,119
from different countries that are

1074
00:38:45,119 --> 00:38:47,040
affected

1075
00:38:47,040 --> 00:38:49,920
and also that the green hills integrity

1076
00:38:49,920 --> 00:38:51,599
operating system is to some extent

1077
00:38:51,599 --> 00:38:52,800
affected and it's used

1078
00:38:52,800 --> 00:38:55,119
heavily in the defense sector so the

1079
00:38:55,119 --> 00:38:56,480
defence sector

1080
00:38:56,480 --> 00:39:01,359
is affected but of course the whole uh

1081
00:39:01,359 --> 00:39:04,240
the risk model is uh is different there

1082
00:39:04,240 --> 00:39:06,320
the risks are different

1083
00:39:06,320 --> 00:39:08,640
and the flow of information is very

1084
00:39:08,640 --> 00:39:10,880
difficult

1085
00:39:10,880 --> 00:39:13,599
um okay we have another question from

1086
00:39:13,599 --> 00:39:14,720
cameron

1087
00:39:14,720 --> 00:39:17,599
uh was there a response from apc or

1088
00:39:17,599 --> 00:39:18,880
schneiderlin

1089
00:39:18,880 --> 00:39:22,400
so um schneider were very responsive

1090
00:39:22,400 --> 00:39:24,720
um and we're very communicative and

1091
00:39:24,720 --> 00:39:26,640
they've released patches for the abc

1092
00:39:26,640 --> 00:39:27,200
devices

1093
00:39:27,200 --> 00:39:30,640
as well as their other devices and

1094
00:39:30,640 --> 00:39:32,400
at this point if you apply patches all

1095
00:39:32,400 --> 00:39:34,400
the apc devices are

1096
00:39:34,400 --> 00:39:37,920
you know not affected by all these if uh

1097
00:39:37,920 --> 00:39:43,040
if you apply the patches

1098
00:39:43,040 --> 00:39:46,240
um okay so brent is asking what are the

1099
00:39:46,240 --> 00:39:46,560
top

1100
00:39:46,560 --> 00:39:48,000
vendors that you think are most

1101
00:39:48,000 --> 00:39:50,240
important that people should worry about

1102
00:39:50,240 --> 00:39:51,920
patching

1103
00:39:51,920 --> 00:39:55,440
like common hd printers

1104
00:39:58,079 --> 00:40:00,400
yeah so i think it very much depends on

1105
00:40:00,400 --> 00:40:01,920
your industry and your

1106
00:40:01,920 --> 00:40:04,880
you know the assets on your network um

1107
00:40:04,880 --> 00:40:06,319
as well as um

1108
00:40:06,319 --> 00:40:11,839
the uh

