1
00:00:03,860 --> 00:00:16,640
[Music]

2
00:00:16,640 --> 00:00:17,119
hi

3
00:00:17,119 --> 00:00:19,199
and welcome to black investment in

4
00:00:19,199 --> 00:00:21,279
secure kennel we are sergeant daniel kim

5
00:00:21,279 --> 00:00:23,119
security researchers from the msrc

6
00:00:23,119 --> 00:00:24,720
and we are very excited to share with

7
00:00:24,720 --> 00:00:26,160
you today our story about how to

8
00:00:26,160 --> 00:00:28,080
insecure kernel to offensive research

9
00:00:28,080 --> 00:00:29,840
we have so much to cover today we are

10
00:00:29,840 --> 00:00:31,199
going to see the shortest introduction

11
00:00:31,199 --> 00:00:32,800
ever to the architecture of vsm and the

12
00:00:32,800 --> 00:00:33,760
secure kernel

13
00:00:33,760 --> 00:00:35,200
then we are going to talk about two of

14
00:00:35,200 --> 00:00:36,800
the vulnerabilities that we found

15
00:00:36,800 --> 00:00:38,239
bought by fuzzing anime statically

16
00:00:38,239 --> 00:00:39,760
auditing the code and we're going to

17
00:00:39,760 --> 00:00:41,280
have some fun and again i'll be record

18
00:00:41,280 --> 00:00:42,800
execution in the secure channel by

19
00:00:42,800 --> 00:00:44,640
exploiting both of those vulnerabilities

20
00:00:44,640 --> 00:00:46,559
and then of course some takeaways what

21
00:00:46,559 --> 00:00:48,160
you can take from this talk in order to

22
00:00:48,160 --> 00:00:49,840
kick off your own secure camera resource

23
00:00:49,840 --> 00:00:50,320
at home

24
00:00:50,320 --> 00:00:51,840
and what we can take from this talk is

25
00:00:51,840 --> 00:00:53,120
microsoft in order to improve the

26
00:00:53,120 --> 00:00:54,879
security in our products

27
00:00:54,879 --> 00:00:57,280
so without any further ado let's talk

28
00:00:57,280 --> 00:00:58,239
about vbs

29
00:00:58,239 --> 00:00:59,920
so with the new architecture of windows

30
00:00:59,920 --> 00:01:02,000
10 and vbs we use virtualization in

31
00:01:02,000 --> 00:01:03,280
order to enforce isolation

32
00:01:03,280 --> 00:01:05,519
and restrictions in the operating system

33
00:01:05,519 --> 00:01:07,840
this m introduces vtls which are virtual

34
00:01:07,840 --> 00:01:08,560
trust levels

35
00:01:08,560 --> 00:01:10,320
which we use in order to isolate the

36
00:01:10,320 --> 00:01:12,000
operating system into different

37
00:01:12,000 --> 00:01:15,040
isolated security contexts

38
00:01:15,040 --> 00:01:17,040
as for today we have two btls we have

39
00:01:17,040 --> 00:01:18,880
vtl0 for the normal world and we tell

40
00:01:18,880 --> 00:01:20,080
one for the secured

41
00:01:20,080 --> 00:01:21,759
in the normal world kernel space we have

42
00:01:21,759 --> 00:01:23,200
endless kernel just

43
00:01:23,200 --> 00:01:24,880
as you know it and we can call it now

44
00:01:24,880 --> 00:01:26,720
the normal kernel and in the normal

45
00:01:26,720 --> 00:01:28,400
world user space you have your own user

46
00:01:28,400 --> 00:01:30,560
space you know a few programs either etc

47
00:01:30,560 --> 00:01:32,400
in a secure world we keep all of the

48
00:01:32,400 --> 00:01:34,240
most privileges and trusted components

49
00:01:34,240 --> 00:01:35,840
which we really want to protect and

50
00:01:35,840 --> 00:01:37,520
isolate from the normal load

51
00:01:37,520 --> 00:01:38,720
so we actually assume here that

52
00:01:38,720 --> 00:01:40,320
attackers already gained redux

53
00:01:40,320 --> 00:01:42,159
primitives in the normal world kernel

54
00:01:42,159 --> 00:01:42,640
space

55
00:01:42,640 --> 00:01:44,880
and we want to restrict them as much as

56
00:01:44,880 --> 00:01:46,399
possible and all of that has been

57
00:01:46,399 --> 00:01:47,439
managed by hyper-v

58
00:01:47,439 --> 00:01:49,759
so you have end of scanners in ring zero

59
00:01:49,759 --> 00:01:50,560
vtl0

60
00:01:50,560 --> 00:01:52,560
you have a secure kernel runs in ring

61
00:01:52,560 --> 00:01:53,600
zero one

62
00:01:53,600 --> 00:01:55,360
and hyper-v exposes two hyper chords for

63
00:01:55,360 --> 00:01:57,280
normal calls and secure calls which are

64
00:01:57,280 --> 00:01:57,920
services

65
00:01:57,920 --> 00:02:00,640
provided by each kernel to the audio the

66
00:02:00,640 --> 00:02:02,240
normal kernel clearly needs many

67
00:02:02,240 --> 00:02:03,920
services from the secure kernel for all

68
00:02:03,920 --> 00:02:05,680
of the most privileged functionalities

69
00:02:05,680 --> 00:02:07,040
it can no longer do

70
00:02:07,040 --> 00:02:08,639
a secure kernel still needs many

71
00:02:08,639 --> 00:02:10,479
services from the normal kernel because

72
00:02:10,479 --> 00:02:12,080
most of the functionalities actually

73
00:02:12,080 --> 00:02:13,840
remained in the normal kernel

74
00:02:13,840 --> 00:02:15,120
because we really want to keep the

75
00:02:15,120 --> 00:02:16,959
secure kernel as small as possible in

76
00:02:16,959 --> 00:02:18,080
order to decrease

77
00:02:18,080 --> 00:02:20,400
its attack surface okay now the

78
00:02:20,400 --> 00:02:22,239
hypervisor exposes hyper calls for the

79
00:02:22,239 --> 00:02:24,800
for the secure kernel to restrict vtl0

80
00:02:24,800 --> 00:02:26,480
and the secure canal uses the cyber

81
00:02:26,480 --> 00:02:28,000
calls in order to restrict

82
00:02:28,000 --> 00:02:30,319
vtl0 access to the both of the physical

83
00:02:30,319 --> 00:02:32,319
addresses and the system registers

84
00:02:32,319 --> 00:02:34,480
this is exactly what let us create great

85
00:02:34,480 --> 00:02:36,480
mitigations such as hvci

86
00:02:36,480 --> 00:02:38,080
which means that all of the pages that

87
00:02:38,080 --> 00:02:40,000
are marked as executable in a retail

88
00:02:40,000 --> 00:02:40,959
zero ept

89
00:02:40,959 --> 00:02:42,640
have to be signed it's mean that we can

90
00:02:42,640 --> 00:02:44,480
hide secrets in a secure world user

91
00:02:44,480 --> 00:02:44,959
space

92
00:02:44,959 --> 00:02:46,319
and mark all of those pages as

93
00:02:46,319 --> 00:02:48,560
unreadable to vtl0

94
00:02:48,560 --> 00:02:50,480
and clearly compromise of eater one of

95
00:02:50,480 --> 00:02:53,200
the secure kernel or of the hypervisor

96
00:02:53,200 --> 00:02:55,120
bypasses those mitigations and break the

97
00:02:55,120 --> 00:02:56,319
model guarantees

98
00:02:56,319 --> 00:02:57,840
and this is the motivation for this

99
00:02:57,840 --> 00:02:59,519
research

100
00:02:59,519 --> 00:03:01,599
okay so our story begins with a great

101
00:03:01,599 --> 00:03:03,840
steamwork daniel what an amazing father

102
00:03:03,840 --> 00:03:04,720
called hypersid

103
00:03:04,720 --> 00:03:06,159
its main purpose was to fuss the

104
00:03:06,159 --> 00:03:08,480
hypercalls interface exposed by hyper-v

105
00:03:08,480 --> 00:03:09,840
i really encourage you to catch this

106
00:03:09,840 --> 00:03:11,440
talk by sean and daniel from offensive

107
00:03:11,440 --> 00:03:12,560
con 2019

108
00:03:12,560 --> 00:03:14,000
it was absolutely amazing they found

109
00:03:14,000 --> 00:03:16,159
many issues in hyper-v and

110
00:03:16,159 --> 00:03:17,920
when i joined the team i just saw this

111
00:03:17,920 --> 00:03:19,680
incredible work and i think daniel and i

112
00:03:19,680 --> 00:03:20,239
asked him

113
00:03:20,239 --> 00:03:22,000
hey do you try to use hyperseed to

114
00:03:22,000 --> 00:03:23,519
further secure services interface

115
00:03:23,519 --> 00:03:25,120
exposed by the secure kernel

116
00:03:25,120 --> 00:03:26,640
because this interface is actually very

117
00:03:26,640 --> 00:03:28,640
similar to the hypercalls interface

118
00:03:28,640 --> 00:03:29,920
exposed by hyperv

119
00:03:29,920 --> 00:03:31,680
and two weeks later daniel here just got

120
00:03:31,680 --> 00:03:33,680
back to me with hey i i just

121
00:03:33,680 --> 00:03:36,159
found five different bugs with zero to

122
00:03:36,159 --> 00:03:38,000
retl one it was absolutely amazing

123
00:03:38,000 --> 00:03:39,599
it moved to us there is still much to

124
00:03:39,599 --> 00:03:41,840
cover in this area so we teamed up we

125
00:03:41,840 --> 00:03:43,440
found more bugs and now we have a good

126
00:03:43,440 --> 00:03:44,400
story to tell

127
00:03:44,400 --> 00:03:46,879
no bugs are really interesting if we can

128
00:03:46,879 --> 00:03:47,599
exploit them

129
00:03:47,599 --> 00:03:50,640
so let's talk about exploitation and

130
00:03:50,640 --> 00:03:51,760
before we start

131
00:03:51,760 --> 00:03:53,840
to do this classic circle of life let's

132
00:03:53,840 --> 00:03:54,799
stop four minutes

133
00:03:54,799 --> 00:03:56,799
and ask ourselves what we can do

134
00:03:56,799 --> 00:03:58,000
assuming that we gain

135
00:03:58,000 --> 00:04:00,720
read write primitives in ring zero vtl1

136
00:04:00,720 --> 00:04:02,400
and in order to answer this question we

137
00:04:02,400 --> 00:04:04,239
really need to talk about mitigations

138
00:04:04,239 --> 00:04:05,599
because as you know we have great

139
00:04:05,599 --> 00:04:07,519
mitigations in the normal kernel

140
00:04:07,519 --> 00:04:09,120
but unfortunately not all of those

141
00:04:09,120 --> 00:04:10,799
mitigations made their way

142
00:04:10,799 --> 00:04:13,120
into the secure caramel for instance the

143
00:04:13,120 --> 00:04:14,959
secure kernel image binary does go

144
00:04:14,959 --> 00:04:16,639
through randomization on every boot

145
00:04:16,639 --> 00:04:18,000
but there are still many hard coded

146
00:04:18,000 --> 00:04:19,918
addresses we don't have c5 and

147
00:04:19,918 --> 00:04:21,440
unfortunately we don't have stat

148
00:04:21,440 --> 00:04:22,880
enforcement which is one of the key

149
00:04:22,880 --> 00:04:24,400
features of vbs

150
00:04:24,400 --> 00:04:26,080
so let's begin here all of those

151
00:04:26,080 --> 00:04:28,639
addresses are hard coded in a secure

152
00:04:28,639 --> 00:04:29,199
kernel

153
00:04:29,199 --> 00:04:30,560
there are even more addresses which

154
00:04:30,560 --> 00:04:32,320
aren't hardcoded but they are still can

155
00:04:32,320 --> 00:04:33,120
be predicted

156
00:04:33,120 --> 00:04:35,120
because because of the so predictable

157
00:04:35,120 --> 00:04:36,720
and deterministic boot process

158
00:04:36,720 --> 00:04:39,520
of the secure kernel i really want you

159
00:04:39,520 --> 00:04:41,199
to take a closer look into this

160
00:04:41,199 --> 00:04:43,520
shell page vtl0 mapping this is a very

161
00:04:43,520 --> 00:04:44,400
special page

162
00:04:44,400 --> 00:04:46,560
as it's a one-to-one mapping of the

163
00:04:46,560 --> 00:04:47,600
shared page

164
00:04:47,600 --> 00:04:50,080
from vtl0 to this fixed virtual address

165
00:04:50,080 --> 00:04:51,040
in vtl1

166
00:04:51,040 --> 00:04:52,720
and therefore every byte that you write

167
00:04:52,720 --> 00:04:54,720
through the shared page in vtl0 simply

168
00:04:54,720 --> 00:04:56,880
appears this fixed virtual address space

169
00:04:56,880 --> 00:04:58,479
in a secure kernel

170
00:04:58,479 --> 00:05:00,000
this introduces a great exploitation

171
00:05:00,000 --> 00:05:02,160
permittive of control content at known

172
00:05:02,160 --> 00:05:02,720
address

173
00:05:02,720 --> 00:05:04,960
which we usually need to invest some

174
00:05:04,960 --> 00:05:07,120
time before we can gain such a primitive

175
00:05:07,120 --> 00:05:08,960
and there is the pc of that in the first

176
00:05:08,960 --> 00:05:10,560
debugger which is attached to in the

177
00:05:10,560 --> 00:05:12,720
scanner we just write arbitrary value

178
00:05:12,720 --> 00:05:14,479
in a second debugger which is which is

179
00:05:14,479 --> 00:05:16,320
attached to the secure canon we just

180
00:05:16,320 --> 00:05:17,280
read this value

181
00:05:17,280 --> 00:05:19,680
and everything works great okay let's

182
00:05:19,680 --> 00:05:21,199
talk about flat enforcement

183
00:05:21,199 --> 00:05:23,199
in our model we only have ept

184
00:05:23,199 --> 00:05:25,039
enforcement on lower videos from higher

185
00:05:25,039 --> 00:05:25,440
ones

186
00:05:25,440 --> 00:05:27,680
this is exactly how we implemented

187
00:05:27,680 --> 00:05:30,000
mitigations such as hvci conditional

188
00:05:30,000 --> 00:05:31,759
guard and etc

189
00:05:31,759 --> 00:05:34,000
but this means that the secure kernel

190
00:05:34,000 --> 00:05:35,680
being the most higher vtl that we have

191
00:05:35,680 --> 00:05:36,240
today

192
00:05:36,240 --> 00:05:38,400
isn't ept enforced which means that the

193
00:05:38,400 --> 00:05:39,680
pte

194
00:05:39,680 --> 00:05:42,400
in vtl1 have the final say this actually

195
00:05:42,400 --> 00:05:43,520
tells us that given

196
00:05:43,520 --> 00:05:46,000
a the arbitrary right primitive in a

197
00:05:46,000 --> 00:05:47,039
secure kernel

198
00:05:47,039 --> 00:05:49,280
we just can create read write execute

199
00:05:49,280 --> 00:05:50,639
chunk of memory

200
00:05:50,639 --> 00:05:52,639
in the secure kernel and we don't even

201
00:05:52,639 --> 00:05:54,160
need a red primitive for that because

202
00:05:54,160 --> 00:05:54,880
the pt

203
00:05:54,880 --> 00:05:57,120
is best is fixed okay this is super

204
00:05:57,120 --> 00:05:58,000
interesting

205
00:05:58,000 --> 00:05:59,520
and just actually raises another

206
00:05:59,520 --> 00:06:01,360
question what about xox

207
00:06:01,360 --> 00:06:03,759
because as as we know many researchers

208
00:06:03,759 --> 00:06:05,280
found several addresses

209
00:06:05,280 --> 00:06:07,120
that were marked as both writable and

210
00:06:07,120 --> 00:06:08,319
executable in

211
00:06:08,319 --> 00:06:11,520
the vtl zero ptes and this is actually

212
00:06:11,520 --> 00:06:12,240
fine because

213
00:06:12,240 --> 00:06:14,720
hdcis does a great job of mitigating

214
00:06:14,720 --> 00:06:15,600
this

215
00:06:15,600 --> 00:06:19,039
by state enforcement but

216
00:06:19,039 --> 00:06:20,720
if we could find this pattern the same

217
00:06:20,720 --> 00:06:22,960
behavior in vtl1 then we really have

218
00:06:22,960 --> 00:06:23,759
something here

219
00:06:23,759 --> 00:06:25,520
and indeed we found four different

220
00:06:25,520 --> 00:06:27,600
addresses in vtl1

221
00:06:27,600 --> 00:06:29,199
that were marked as both writable and

222
00:06:29,199 --> 00:06:31,360
executable in the ptes

223
00:06:31,360 --> 00:06:33,039
we fixed them all by now of course but

224
00:06:33,039 --> 00:06:34,720
this is just another great value of this

225
00:06:34,720 --> 00:06:36,240
research

226
00:06:36,240 --> 00:06:37,919
okay let's talk about setup setup is

227
00:06:37,919 --> 00:06:40,080
super important we chose to use hyperc

228
00:06:40,080 --> 00:06:41,280
it's super convenient we can write all

229
00:06:41,280 --> 00:06:43,520
of the plcs and experts in user space

230
00:06:43,520 --> 00:06:45,360
and we have our own kernel switch driver

231
00:06:45,360 --> 00:06:45,680
which

232
00:06:45,680 --> 00:06:47,840
wraps all of the secure cores for us if

233
00:06:47,840 --> 00:06:49,440
you don't want to go through all of this

234
00:06:49,440 --> 00:06:51,440
troubles you can simply debug endoscope

235
00:06:51,440 --> 00:06:52,720
breakpoint on key functions

236
00:06:52,720 --> 00:06:54,319
and patch the registers in memory in

237
00:06:54,319 --> 00:06:56,560
runtime to trigger certain flows in the

238
00:06:56,560 --> 00:06:58,000
secure kernel

239
00:06:58,000 --> 00:06:59,840
we don't ship the secure kernel release

240
00:06:59,840 --> 00:07:01,840
binaries with the debugger compiled in

241
00:07:01,840 --> 00:07:03,280
but you can still achieve that and your

242
00:07:03,280 --> 00:07:05,280
machine is at home by using nested

243
00:07:05,280 --> 00:07:07,440
virtualization kvm qmu

244
00:07:07,440 --> 00:07:09,680
many researchers are doing that here are

245
00:07:09,680 --> 00:07:10,960
some links that you can follow

246
00:07:10,960 --> 00:07:12,639
and now with this new spirit let's go

247
00:07:12,639 --> 00:07:14,319
over to daniel which will tell us about

248
00:07:14,319 --> 00:07:15,840
the first vulnerability and the first

249
00:07:15,840 --> 00:07:18,000
extract

250
00:07:18,000 --> 00:07:20,160
thanks sar for the introduction i am

251
00:07:20,160 --> 00:07:22,319
daniel now let me walk you through the

252
00:07:22,319 --> 00:07:22,720
first

253
00:07:22,720 --> 00:07:26,160
vulnerability and exploit in this talk

254
00:07:26,160 --> 00:07:28,880
we will discuss two vulnerabilities they

255
00:07:28,880 --> 00:07:30,080
are very different from

256
00:07:30,080 --> 00:07:32,639
each other the only common part is that

257
00:07:32,639 --> 00:07:34,639
they are in the same function

258
00:07:34,639 --> 00:07:37,680
the vulnerable function is named as km

259
00:07:37,680 --> 00:07:40,800
obtain hot patch undo table it is a long

260
00:07:40,800 --> 00:07:41,440
name

261
00:07:41,440 --> 00:07:43,599
but you can tell it is related to the

262
00:07:43,599 --> 00:07:46,000
hot patch implementation

263
00:07:46,000 --> 00:07:48,639
the function obtains an undo table this

264
00:07:48,639 --> 00:07:50,560
table describes addresses

265
00:07:50,560 --> 00:07:53,039
that will be affected by reverting a hot

266
00:07:53,039 --> 00:07:54,000
patch

267
00:07:54,000 --> 00:07:56,479
the first vulnerability is the autobahn

268
00:07:56,479 --> 00:07:57,199
right

269
00:07:57,199 --> 00:07:59,919
it is found by fuzzing with hyperseed

270
00:07:59,919 --> 00:08:01,360
the second vulnerability

271
00:08:01,360 --> 00:08:04,479
is related to mdl and mapping it

272
00:08:04,479 --> 00:08:08,080
is found by source code review generally

273
00:08:08,080 --> 00:08:10,240
secure calls use transfer mdl to

274
00:08:10,240 --> 00:08:11,440
transfer data

275
00:08:11,440 --> 00:08:14,800
from vtl0 the entos world to vtr1 to

276
00:08:14,800 --> 00:08:16,080
secureworld

277
00:08:16,080 --> 00:08:18,080
those transfer mdios are fully

278
00:08:18,080 --> 00:08:20,639
controlled from vtl0

279
00:08:20,639 --> 00:08:23,599
here in this vulnerable function in vtr1

280
00:08:23,599 --> 00:08:24,720
it will first

281
00:08:24,720 --> 00:08:27,759
map the transfer mdl to vtr1 address

282
00:08:27,759 --> 00:08:28,879
space

283
00:08:28,879 --> 00:08:31,680
it then construct a new mdl and

284
00:08:31,680 --> 00:08:33,440
initialize it with the content

285
00:08:33,440 --> 00:08:36,640
stored in transfer mdl at last

286
00:08:36,640 --> 00:08:40,000
it will unmip and clean up this mdl the

287
00:08:40,000 --> 00:08:41,440
security guideline here

288
00:08:41,440 --> 00:08:44,480
is to sanitize our refuels at rate from

289
00:08:44,480 --> 00:08:45,760
vtr0

290
00:08:45,760 --> 00:08:47,600
including the bad count field in

291
00:08:47,600 --> 00:08:49,040
transfer ambia

292
00:08:49,040 --> 00:08:53,360
this is where the first vulnerability

293
00:08:53,360 --> 00:08:55,680
this code snippet shows the first

294
00:08:55,680 --> 00:08:57,120
vulnerability

295
00:08:57,120 --> 00:09:00,560
the bad count field passed from the vtr0

296
00:09:00,560 --> 00:09:02,000
can be any value

297
00:09:02,000 --> 00:09:04,480
and it will be used as the allocation

298
00:09:04,480 --> 00:09:06,480
length for the newly allocated

299
00:09:06,480 --> 00:09:09,760
andu mdr and do mdr should be at least

300
00:09:09,760 --> 00:09:10,959
48 bytes

301
00:09:10,959 --> 00:09:14,080
as an instance of mdl data structure

302
00:09:14,080 --> 00:09:16,640
guess what will happen if bad count is

303
00:09:16,640 --> 00:09:18,640
smaller than 48

304
00:09:18,640 --> 00:09:21,680
yeah you're right outer bound right will

305
00:09:21,680 --> 00:09:23,519
happen

306
00:09:23,519 --> 00:09:26,240
let's see the mdl data structure layout

307
00:09:26,240 --> 00:09:28,800
it represents information for a buffer

308
00:09:28,800 --> 00:09:30,160
in physical memory

309
00:09:30,160 --> 00:09:33,519
it consists of two parts the fixed title

310
00:09:33,519 --> 00:09:36,560
and the wearable pfn array the fixed

311
00:09:36,560 --> 00:09:38,320
title occupies the first

312
00:09:38,320 --> 00:09:41,680
48 bytes and contains several important

313
00:09:41,680 --> 00:09:42,640
fields

314
00:09:42,640 --> 00:09:45,839
next is a pointer to another mdl in this

315
00:09:45,839 --> 00:09:46,399
way

316
00:09:46,399 --> 00:09:48,880
several mdls can be chained together

317
00:09:48,880 --> 00:09:50,000
into a singularly linked

318
00:09:50,000 --> 00:09:53,200
list and as list size

319
00:09:53,200 --> 00:09:55,200
is the total length of the whole data

320
00:09:55,200 --> 00:09:56,320
structure

321
00:09:56,320 --> 00:09:59,839
mapped system va points to the buffer

322
00:09:59,839 --> 00:10:02,000
after getting mapped into the address

323
00:10:02,000 --> 00:10:04,640
space bad count is the length of the

324
00:10:04,640 --> 00:10:07,040
buffer

325
00:10:07,120 --> 00:10:09,839
transfer mdl describes a piece of buffer

326
00:10:09,839 --> 00:10:12,959
transferred from vtl0 to vtr1

327
00:10:12,959 --> 00:10:15,120
here the transfer buffer happened to be

328
00:10:15,120 --> 00:10:17,200
another mdr instance

329
00:10:17,200 --> 00:10:19,440
the vulnerable function guides the bad

330
00:10:19,440 --> 00:10:22,079
count as the transfer buffer lens

331
00:10:22,079 --> 00:10:24,640
and allocate a new and dual mdr with the

332
00:10:24,640 --> 00:10:26,320
same lines

333
00:10:26,320 --> 00:10:29,680
if we specify the bat count to be 16

334
00:10:29,680 --> 00:10:32,480
then a 16 bytes sequence will be

335
00:10:32,480 --> 00:10:33,440
allocated

336
00:10:33,440 --> 00:10:36,560
for the undo mdl

337
00:10:36,560 --> 00:10:39,519
here i only discussed the situation that

338
00:10:39,519 --> 00:10:41,519
undo mdl is allocated

339
00:10:41,519 --> 00:10:44,320
in we are skip i will explain the reason

340
00:10:44,320 --> 00:10:45,279
later

341
00:10:45,279 --> 00:10:48,240
we can see that the next full allocation

342
00:10:48,240 --> 00:10:49,519
is also shown here

343
00:10:49,519 --> 00:10:52,800
in blue color with 16 bytes we as

344
00:10:52,800 --> 00:10:56,399
chunk header the transfer mdr

345
00:10:56,399 --> 00:10:59,760
gets mapped into the vtr1 address space

346
00:10:59,760 --> 00:11:02,800
then mapped system va can be used to

347
00:11:02,800 --> 00:11:05,600
access the transfer buffer directly

348
00:11:05,600 --> 00:11:07,440
we call this transfer buffer the

349
00:11:07,440 --> 00:11:09,200
original mdl

350
00:11:09,200 --> 00:11:12,079
original mdl is also fully controlled

351
00:11:12,079 --> 00:11:14,480
from vtl0

352
00:11:14,480 --> 00:11:16,959
the undo mdr will be initialized

353
00:11:16,959 --> 00:11:19,440
according to the original mdl

354
00:11:19,440 --> 00:11:21,680
now we see how the auto bound right

355
00:11:21,680 --> 00:11:24,399
happen when calling mm initialize

356
00:11:24,399 --> 00:11:27,279
mdl the next pool allocation will be

357
00:11:27,279 --> 00:11:28,000
operated

358
00:11:28,000 --> 00:11:30,720
with the original mdl the overwriting

359
00:11:30,720 --> 00:11:31,760
capability

360
00:11:31,760 --> 00:11:35,519
is 16 bytes we see that the wii as trunk

361
00:11:35,519 --> 00:11:36,000
hider

362
00:11:36,000 --> 00:11:39,279
is still intact after the override which

363
00:11:39,279 --> 00:11:41,279
is very good for exploitation

364
00:11:41,279 --> 00:11:43,920
since this override won't be detected by

365
00:11:43,920 --> 00:11:46,640
pull system

366
00:11:46,640 --> 00:11:48,720
if we try the poc for the first

367
00:11:48,720 --> 00:11:49,680
vulnerability

368
00:11:49,680 --> 00:11:52,320
we will see the typical back type caused

369
00:11:52,320 --> 00:11:54,000
by access violation

370
00:11:54,000 --> 00:11:56,639
and we will see the gsod for windows

371
00:11:56,639 --> 00:11:58,639
insider build

372
00:11:58,639 --> 00:12:00,880
the fix for the first vulnerability is

373
00:12:00,880 --> 00:12:02,160
also straightforward

374
00:12:02,160 --> 00:12:04,560
stop further precising if bad count is

375
00:12:04,560 --> 00:12:06,800
smaller than 48

376
00:12:06,800 --> 00:12:09,440
the fix is more intuitive by comparing

377
00:12:09,440 --> 00:12:12,560
other pro cfgs

378
00:12:12,560 --> 00:12:14,800
what can we do with this upgrade right

379
00:12:14,800 --> 00:12:16,560
to the vtr1 world

380
00:12:16,560 --> 00:12:19,360
sar has some considerable insight this

381
00:12:19,360 --> 00:12:20,000
is all

382
00:12:20,000 --> 00:12:25,120
what a hiker need let me show you why

383
00:12:25,120 --> 00:12:27,360
now i have the capability to overwrite

384
00:12:27,360 --> 00:12:29,200
the neighbor pool allocation

385
00:12:29,200 --> 00:12:32,880
what should i do first yes i should

386
00:12:32,880 --> 00:12:34,800
select a good neighbor to be the

387
00:12:34,800 --> 00:12:36,720
overwritten victim

388
00:12:36,720 --> 00:12:39,040
since i am already familiar with mdl

389
00:12:39,040 --> 00:12:40,240
data structure

390
00:12:40,240 --> 00:12:42,720
why not choose another mdl as the

391
00:12:42,720 --> 00:12:44,079
neighbor

392
00:12:44,079 --> 00:12:46,959
we can overwrite the first 16 bytes of

393
00:12:46,959 --> 00:12:48,560
the victim mdl

394
00:12:48,560 --> 00:12:51,440
including the next pointer size and

395
00:12:51,440 --> 00:12:52,480
flags

396
00:12:52,480 --> 00:12:55,519
the inertial primitive is ready and

397
00:12:55,519 --> 00:12:56,959
seems promising

398
00:12:56,959 --> 00:12:58,320
let me show you more essential

399
00:12:58,320 --> 00:13:01,279
backgrounds for the final exploit

400
00:13:01,279 --> 00:13:04,000
let me introduce the skpg context a

401
00:13:04,000 --> 00:13:05,200
little bit

402
00:13:05,200 --> 00:13:07,680
it is a core data structure used for

403
00:13:07,680 --> 00:13:09,600
secure kernel hyper guard

404
00:13:09,600 --> 00:13:11,920
we already know that its address is

405
00:13:11,920 --> 00:13:12,959
predictable

406
00:13:12,959 --> 00:13:15,680
a very good stable target i should take

407
00:13:15,680 --> 00:13:17,680
advantage of this fact

408
00:13:17,680 --> 00:13:19,680
that request some interesting fields in

409
00:13:19,680 --> 00:13:21,920
it including two callback routine

410
00:13:21,920 --> 00:13:24,079
function pointers

411
00:13:24,079 --> 00:13:26,600
i have to be very cautious since it is

412
00:13:26,600 --> 00:13:28,800
self-protected

413
00:13:28,800 --> 00:13:31,279
there is an embedded timer in it the

414
00:13:31,279 --> 00:13:33,360
timer routine will be invoked when due

415
00:13:33,360 --> 00:13:34,639
time comes

416
00:13:34,639 --> 00:13:36,480
the timer routine will trigger the

417
00:13:36,480 --> 00:13:38,000
runtime charge routine

418
00:13:38,000 --> 00:13:40,800
the later will verify the data integrity

419
00:13:40,800 --> 00:13:42,560
of the whole data structure

420
00:13:42,560 --> 00:13:46,399
it will fast fail if anything wrong

421
00:13:46,399 --> 00:13:49,360
corrupting any fields of skpg context

422
00:13:49,360 --> 00:13:51,199
will be noticed by the runtime check

423
00:13:51,199 --> 00:13:52,240
routine

424
00:13:52,240 --> 00:13:54,800
except those two callback pointers in

425
00:13:54,800 --> 00:13:55,760
fact

426
00:13:55,760 --> 00:13:58,079
if i replace one of those two function

427
00:13:58,079 --> 00:13:59,040
pointers

428
00:13:59,040 --> 00:14:02,560
the whole self protection is bypassed

429
00:14:02,560 --> 00:14:04,639
those two callback pointers are good

430
00:14:04,639 --> 00:14:05,680
candidates

431
00:14:05,680 --> 00:14:07,920
for redirecting control flow to shell

432
00:14:07,920 --> 00:14:09,600
code

433
00:14:09,600 --> 00:14:11,920
i have mentioned secure kernel pool now

434
00:14:11,920 --> 00:14:13,839
let's take a closer look

435
00:14:13,839 --> 00:14:16,480
secure kernel use segment heap which is

436
00:14:16,480 --> 00:14:17,199
typically

437
00:14:17,199 --> 00:14:20,000
comprised of wearable size heap and low

438
00:14:20,000 --> 00:14:21,760
fragmentation keep

439
00:14:21,760 --> 00:14:24,320
in weight as heap allocations of

440
00:14:24,320 --> 00:14:25,519
different sizes

441
00:14:25,519 --> 00:14:28,639
are put together side by side in rfh

442
00:14:28,639 --> 00:14:29,360
keep

443
00:14:29,360 --> 00:14:31,360
allocations of the same size are put

444
00:14:31,360 --> 00:14:33,600
together and allocations of different

445
00:14:33,600 --> 00:14:34,399
sizes

446
00:14:34,399 --> 00:14:37,440
are separated from each other in secure

447
00:14:37,440 --> 00:14:38,000
kernel

448
00:14:38,000 --> 00:14:40,079
the tag and prototype arguments are

449
00:14:40,079 --> 00:14:41,040
ignored

450
00:14:41,040 --> 00:14:44,480
pools are always allocated in page 4.

451
00:14:44,480 --> 00:14:47,920
since undo mdl is 16 bytes well i cannot

452
00:14:47,920 --> 00:14:49,839
make the victim mdl

453
00:14:49,839 --> 00:14:52,720
smaller than 48 bytes if i want to put

454
00:14:52,720 --> 00:14:53,760
them together

455
00:14:53,760 --> 00:14:56,800
i have to use the we asked keep during

456
00:14:56,800 --> 00:14:58,160
the exploitation

457
00:14:58,160 --> 00:15:00,399
the main challenge here is in secure

458
00:15:00,399 --> 00:15:01,920
world there is

459
00:15:01,920 --> 00:15:06,079
too few allocations i create

460
00:15:06,079 --> 00:15:09,040
two and debug javascript extensions to

461
00:15:09,040 --> 00:15:09,440
help

462
00:15:09,440 --> 00:15:12,480
dump out the rfh and we asked keep

463
00:15:12,480 --> 00:15:13,760
layout

464
00:15:13,760 --> 00:15:15,519
you don't need to understand the meaning

465
00:15:15,519 --> 00:15:17,760
of i refuse here i just want to show you

466
00:15:17,760 --> 00:15:18,800
how scars

467
00:15:18,800 --> 00:15:21,360
the pull allocations are in secure world

468
00:15:21,360 --> 00:15:22,720
by default

469
00:15:22,720 --> 00:15:26,519
in the upper screenshot only 15 after

470
00:15:26,519 --> 00:15:30,560
129 out of each buckets are activated

471
00:15:30,560 --> 00:15:32,800
they are highlighted in write in the

472
00:15:32,800 --> 00:15:34,079
lower screenshot

473
00:15:34,079 --> 00:15:37,920
only 22 segments used in the vs heap

474
00:15:37,920 --> 00:15:41,680
each segment ranges from 16 to 64

475
00:15:41,680 --> 00:15:45,040
pages the fewer the poor allocations

476
00:15:45,040 --> 00:15:48,240
the lesser possibility for push shipping

477
00:15:48,240 --> 00:15:50,240
for good push shipping i have to find

478
00:15:50,240 --> 00:15:51,519
out a persistent

479
00:15:51,519 --> 00:15:54,399
uncontrollable pool allocation create

480
00:15:54,399 --> 00:15:55,279
secure image

481
00:15:55,279 --> 00:15:58,480
sql call can be used for this purpose it

482
00:15:58,480 --> 00:15:59,279
can allocate

483
00:15:59,279 --> 00:16:02,079
up to resized pool allocations the

484
00:16:02,079 --> 00:16:03,600
minimal allocation size

485
00:16:03,600 --> 00:16:07,360
is 48 bytes a handle to each create

486
00:16:07,360 --> 00:16:10,800
secure image is returned to the vtl0

487
00:16:10,800 --> 00:16:12,720
closing this handle will free the

488
00:16:12,720 --> 00:16:15,680
corresponding secure image allocation

489
00:16:15,680 --> 00:16:18,079
i can use this allocation to make holes

490
00:16:18,079 --> 00:16:19,920
of 16 bytes

491
00:16:19,920 --> 00:16:22,880
another sql core level start will

492
00:16:22,880 --> 00:16:25,199
allocate a list of mdls

493
00:16:25,199 --> 00:16:28,560
with controllable mdl size those mdls

494
00:16:28,560 --> 00:16:30,160
are good candidates

495
00:16:30,160 --> 00:16:33,519
for being victim mdl

496
00:16:33,519 --> 00:16:35,279
there are two challenges here during

497
00:16:35,279 --> 00:16:36,959
push shipping first

498
00:16:36,959 --> 00:16:39,600
there is a guard page after each we ask

499
00:16:39,600 --> 00:16:40,959
heap segment

500
00:16:40,959 --> 00:16:44,560
if the undo mdl is allocated at the end

501
00:16:44,560 --> 00:16:46,959
of this segment it will corrupt the

502
00:16:46,959 --> 00:16:47,680
guard page

503
00:16:47,680 --> 00:16:50,639
and call spark check second i cannot

504
00:16:50,639 --> 00:16:52,480
make too much allocations of the sim

505
00:16:52,480 --> 00:16:53,279
size

506
00:16:53,279 --> 00:16:56,560
otherwise it will activate rfh bucket

507
00:16:56,560 --> 00:16:59,759
if a word threshold

508
00:16:59,759 --> 00:17:02,800
this is how i do the shipping i have

509
00:17:02,800 --> 00:17:04,799
pasted some persons groups here

510
00:17:04,799 --> 00:17:08,240
for reference first i make two series of

511
00:17:08,240 --> 00:17:08,880
push

512
00:17:08,880 --> 00:17:11,439
pull allocations which create secure

513
00:17:11,439 --> 00:17:11,919
image

514
00:17:11,919 --> 00:17:16,839
sequel calls of different sizes a and b

515
00:17:16,839 --> 00:17:19,919
repeatedly then i replace all of the b

516
00:17:19,919 --> 00:17:22,720
allocations with the left amp mdl of the

517
00:17:22,720 --> 00:17:24,959
same size

518
00:17:24,959 --> 00:17:27,760
then i replace all of the a allocations

519
00:17:27,760 --> 00:17:28,880
with smaller d

520
00:17:28,880 --> 00:17:32,080
allocations making 32 bytes holes

521
00:17:32,080 --> 00:17:34,960
which is suitable for undo mdr including

522
00:17:34,960 --> 00:17:37,840
the wii as trunk hide

523
00:17:37,840 --> 00:17:40,080
further undo mdr allocation will be

524
00:17:40,080 --> 00:17:41,120
allocated

525
00:17:41,120 --> 00:17:44,160
in these holes and cropped the

526
00:17:44,160 --> 00:17:46,799
neighbor left amp mdr with the first

527
00:17:46,799 --> 00:17:49,200
vulnerability

528
00:17:49,200 --> 00:17:52,799
ascii laptop start this sequel call will

529
00:17:52,799 --> 00:17:54,080
allocate a list of

530
00:17:54,080 --> 00:17:56,400
mdios and change them into the

531
00:17:56,400 --> 00:17:58,320
singularly linked list

532
00:17:58,320 --> 00:18:01,039
ascii lab dump at buffer this sequel

533
00:18:01,039 --> 00:18:02,799
call will try to allocate

534
00:18:02,799 --> 00:18:06,080
a target mdl from the s list and right

535
00:18:06,080 --> 00:18:07,760
to the pfn array

536
00:18:07,760 --> 00:18:11,840
at the end of of that mdl

537
00:18:11,840 --> 00:18:14,400
left arm context is a global symbol it

538
00:18:14,400 --> 00:18:18,160
contains a pointer to the as list

539
00:18:18,160 --> 00:18:20,799
pages added in the livedam context

540
00:18:20,799 --> 00:18:22,640
determines where to write to

541
00:18:22,640 --> 00:18:25,679
when calling livedump at buffer but

542
00:18:25,679 --> 00:18:28,160
count in each mdr determines its

543
00:18:28,160 --> 00:18:29,280
capacity

544
00:18:29,280 --> 00:18:31,360
after filling up its capacity the

545
00:18:31,360 --> 00:18:33,200
writing cursor will be moved

546
00:18:33,200 --> 00:18:36,320
to the next mdl in s list

547
00:18:36,320 --> 00:18:38,320
the calculation of writing cursor is

548
00:18:38,320 --> 00:18:39,679
demonstrated here

549
00:18:39,679 --> 00:18:43,039
with this pseudocode with the push

550
00:18:43,039 --> 00:18:44,960
shipping approach i discussed

551
00:18:44,960 --> 00:18:47,760
it is possible to make the level amdial

552
00:18:47,760 --> 00:18:49,440
the victim amdia

553
00:18:49,440 --> 00:18:52,720
and allocate it after the andu mdl

554
00:18:52,720 --> 00:18:55,120
trigger the outer boundary will modify

555
00:18:55,120 --> 00:18:56,240
the next pointer

556
00:18:56,240 --> 00:18:59,120
of the victim mdl as list will be

557
00:18:59,120 --> 00:19:01,520
diverted to a powered mdl

558
00:19:01,520 --> 00:19:05,440
under our control if we make the power

559
00:19:05,440 --> 00:19:07,440
time they are in the shared memory which

560
00:19:07,440 --> 00:19:09,360
is readable from vtl0

561
00:19:09,360 --> 00:19:12,000
we can fully control its content

562
00:19:12,000 --> 00:19:13,520
including the next pointer

563
00:19:13,520 --> 00:19:16,559
and bad count this modification will be

564
00:19:16,559 --> 00:19:17,360
reflected

565
00:19:17,360 --> 00:19:20,559
to the vtr1 in real time which can be

566
00:19:20,559 --> 00:19:21,360
used for

567
00:19:21,360 --> 00:19:23,840
repetitive adjustment of the next

568
00:19:23,840 --> 00:19:24,640
pointer

569
00:19:24,640 --> 00:19:28,640
and overwrite to obturary address

570
00:19:28,640 --> 00:19:31,320
but the shared page is read only from

571
00:19:31,320 --> 00:19:33,360
vtl1

572
00:19:33,360 --> 00:19:35,280
writing to the piphan array of the

573
00:19:35,280 --> 00:19:37,120
powertime dial will backtrack

574
00:19:37,120 --> 00:19:39,600
due to the access variation there is a

575
00:19:39,600 --> 00:19:40,640
trick here

576
00:19:40,640 --> 00:19:42,720
we can modify the bet count to be

577
00:19:42,720 --> 00:19:44,559
smaller than page size

578
00:19:44,559 --> 00:19:46,400
which makes the power time dials

579
00:19:46,400 --> 00:19:48,160
capacity zero

580
00:19:48,160 --> 00:19:50,640
and it will be skipped directly to the

581
00:19:50,640 --> 00:19:53,600
next mdr

582
00:19:53,600 --> 00:19:55,679
now we have fully control of the powered

583
00:19:55,679 --> 00:19:57,679
ambiance and we can retarget

584
00:19:57,679 --> 00:20:00,799
worker mdl by modifying next pointer

585
00:20:00,799 --> 00:20:03,360
we can write to anywhere but we need to

586
00:20:03,360 --> 00:20:04,720
know

587
00:20:04,720 --> 00:20:07,440
where to mod uh we need to know when to

588
00:20:07,440 --> 00:20:09,760
modify the next pointer

589
00:20:09,760 --> 00:20:12,240
we use the second shared memory as the

590
00:20:12,240 --> 00:20:14,080
worker mdl and detect

591
00:20:14,080 --> 00:20:16,799
if its pivot array has been overwritten

592
00:20:16,799 --> 00:20:20,400
after we call the left dump add buffer

593
00:20:20,400 --> 00:20:23,200
once we detected that the worker mdl has

594
00:20:23,200 --> 00:20:24,400
been overwritten

595
00:20:24,400 --> 00:20:27,360
we add power time the bad count with

596
00:20:27,360 --> 00:20:28,480
page size

597
00:20:28,480 --> 00:20:31,280
it makes sure next time we collect a

598
00:20:31,280 --> 00:20:32,000
buffer

599
00:20:32,000 --> 00:20:34,400
we are still writing to the beginning of

600
00:20:34,400 --> 00:20:35,679
the worker mds

601
00:20:35,679 --> 00:20:38,960
pfm array in theory we can write to

602
00:20:38,960 --> 00:20:39,600
anywhere

603
00:20:39,600 --> 00:20:42,000
the only constraint here is the worker

604
00:20:42,000 --> 00:20:43,440
mdl bad count

605
00:20:43,440 --> 00:20:46,159
should not be smaller than page size

606
00:20:46,159 --> 00:20:48,080
otherwise it will be skipped

607
00:20:48,080 --> 00:20:51,200
and writing writing will be redirected

608
00:20:51,200 --> 00:20:54,159
to its next mdr normally this

609
00:20:54,159 --> 00:20:56,080
constituent can be bypassed

610
00:20:56,080 --> 00:20:58,480
if we can find some non-zero content

611
00:20:58,480 --> 00:21:00,559
before the overwriting target

612
00:21:00,559 --> 00:21:02,960
crafting a worker mdr there and

613
00:21:02,960 --> 00:21:04,559
adjusting the writing cursor

614
00:21:04,559 --> 00:21:08,480
by changing the bad count accordingly

615
00:21:08,480 --> 00:21:10,880
you can see i take fully advantage of

616
00:21:10,880 --> 00:21:12,159
the shared pages

617
00:21:12,159 --> 00:21:15,039
i use the first shared memory to craft

618
00:21:15,039 --> 00:21:16,320
power to mdl

619
00:21:16,320 --> 00:21:19,919
i modify worker mdr repeatedly i use the

620
00:21:19,919 --> 00:21:20,640
second

621
00:21:20,640 --> 00:21:22,559
shell memory as the tentative

622
00:21:22,559 --> 00:21:24,000
overwriting target

623
00:21:24,000 --> 00:21:26,240
and determine the good timing to modify

624
00:21:26,240 --> 00:21:27,440
the next pointer

625
00:21:27,440 --> 00:21:31,600
when the worker mdl has been activated

626
00:21:31,600 --> 00:21:34,159
after the worker mdr has been activated

627
00:21:34,159 --> 00:21:35,679
i can do repeatable

628
00:21:35,679 --> 00:21:39,200
red what where where is determined by

629
00:21:39,200 --> 00:21:40,320
the next pointer

630
00:21:40,320 --> 00:21:43,039
and bad count of the power time here

631
00:21:43,039 --> 00:21:44,880
writing cursor is pointing to the

632
00:21:44,880 --> 00:21:46,640
operating target

633
00:21:46,640 --> 00:21:49,840
what is passed as parameters to the

634
00:21:49,840 --> 00:21:52,080
laptop at buffer sql call

635
00:21:52,080 --> 00:21:55,120
here i use just one page from number

636
00:21:55,120 --> 00:21:58,080
which is exactly one keyword this is the

637
00:21:58,080 --> 00:22:00,240
overwriting content

638
00:22:00,240 --> 00:22:02,240
trigger the left arm at buffer circle

639
00:22:02,240 --> 00:22:03,760
call which will do

640
00:22:03,760 --> 00:22:07,280
the final override in this way i can do

641
00:22:07,280 --> 00:22:09,039
the red what where trick

642
00:22:09,039 --> 00:22:12,880
accurately and repeatedly

643
00:22:12,880 --> 00:22:15,440
a little summary here first i cropped

644
00:22:15,440 --> 00:22:16,799
the next pointer

645
00:22:16,799 --> 00:22:19,919
of the mdl get one up to the right

646
00:22:19,919 --> 00:22:21,919
then i fake a power time they are in the

647
00:22:21,919 --> 00:22:23,039
shared page

648
00:22:23,039 --> 00:22:26,080
where i can modify repeatedly from vtr0

649
00:22:26,080 --> 00:22:27,360
by design

650
00:22:27,360 --> 00:22:30,400
with this up to write i cropped a node

651
00:22:30,400 --> 00:22:33,440
in the livedamp context mdr chain and

652
00:22:33,440 --> 00:22:35,520
make it point to the power time dial in

653
00:22:35,520 --> 00:22:36,960
shared page

654
00:22:36,960 --> 00:22:39,039
call leveldumpadbuffer to trigger the

655
00:22:39,039 --> 00:22:40,559
arbitrary write

656
00:22:40,559 --> 00:22:43,280
changing the sharp pitch content to

657
00:22:43,280 --> 00:22:43,840
adjust

658
00:22:43,840 --> 00:22:46,080
the overwriting target call level dump

659
00:22:46,080 --> 00:22:48,080
at buffer again to trigger another

660
00:22:48,080 --> 00:22:49,360
override

661
00:22:49,360 --> 00:22:51,919
with this up to write capability i

662
00:22:51,919 --> 00:22:53,600
modified page table entry

663
00:22:53,600 --> 00:22:56,640
of the shared page to executable place a

664
00:22:56,640 --> 00:22:58,480
piece of shellcode there

665
00:22:58,480 --> 00:23:00,760
then i modify the

666
00:23:00,760 --> 00:23:02,159
skpgcontextcallbackroutine

667
00:23:02,159 --> 00:23:04,960
and jump to the shellcode in this way

668
00:23:04,960 --> 00:23:06,480
arbitrary code execution

669
00:23:06,480 --> 00:23:10,720
is achieved this is the demo shell code

670
00:23:10,720 --> 00:23:13,600
it first modifies the skpg context

671
00:23:13,600 --> 00:23:15,039
callback routine

672
00:23:15,039 --> 00:23:17,520
then it leaks the secure kernel base

673
00:23:17,520 --> 00:23:19,360
pointer back to vtr0

674
00:23:19,360 --> 00:23:22,559
through shard page it resets timer

675
00:23:22,559 --> 00:23:25,360
configure 5 seconds relative due time

676
00:23:25,360 --> 00:23:27,520
shellcode will be invoked every 5

677
00:23:27,520 --> 00:23:28,559
seconds

678
00:23:28,559 --> 00:23:30,640
and shellcode is fully controlled from

679
00:23:30,640 --> 00:23:31,600
vtl0

680
00:23:31,600 --> 00:23:35,120
and can be refactored for any purpose

681
00:23:35,120 --> 00:23:37,760
the first vulnerability was fixed in

682
00:23:37,760 --> 00:23:39,760
january 2019.

683
00:23:39,760 --> 00:23:42,080
the secular pool then switched to

684
00:23:42,080 --> 00:23:42,960
segment heap

685
00:23:42,960 --> 00:23:46,159
in the middle of 2019 and the

686
00:23:46,159 --> 00:23:48,320
exploit push shipping depends on the

687
00:23:48,320 --> 00:23:51,679
segment heap this demo is against build

688
00:23:51,679 --> 00:23:53,279
in may 2020

689
00:23:53,279 --> 00:23:55,039
where the first vulnerability has

690
00:23:55,039 --> 00:23:56,640
already been fixed

691
00:23:56,640 --> 00:23:58,960
a trick to undo the fix is by one

692
00:23:58,960 --> 00:24:00,159
debugger command

693
00:24:00,159 --> 00:24:02,400
this command will erase the fixed code

694
00:24:02,400 --> 00:24:04,080
to not slide

695
00:24:04,080 --> 00:24:06,799
so this exploit approach works well on

696
00:24:06,799 --> 00:24:08,000
latest build

697
00:24:08,000 --> 00:24:10,720
but the vulnerability is already gone no

698
00:24:10,720 --> 00:24:13,520
customer will be at risk with this demo

699
00:24:13,520 --> 00:24:16,840
since no build is both vulnerable and

700
00:24:16,840 --> 00:24:18,159
exploitable

701
00:24:18,159 --> 00:24:20,320
here is the demo i have pasted

702
00:24:20,320 --> 00:24:21,360
screenshots

703
00:24:21,360 --> 00:24:24,640
of important output here as background

704
00:24:24,640 --> 00:24:27,120
i will play the demo video this video

705
00:24:27,120 --> 00:24:33,840
has been edited to look smoothly

706
00:24:35,919 --> 00:24:38,320
second kernel debugger is attached here

707
00:24:38,320 --> 00:24:39,120
and the fix

708
00:24:39,120 --> 00:24:41,520
has been unpatched by the debugger

709
00:24:41,520 --> 00:24:42,480
command

710
00:24:42,480 --> 00:24:44,880
before the exploit the shared page is

711
00:24:44,880 --> 00:24:45,679
filled with

712
00:24:45,679 --> 00:24:48,960
zeros rather than the shell code and the

713
00:24:48,960 --> 00:24:49,760
shared page

714
00:24:49,760 --> 00:24:52,720
is not executable i will play the demo

715
00:24:52,720 --> 00:24:55,279
video now

716
00:24:58,240 --> 00:25:00,400
i run the first passing script which

717
00:25:00,400 --> 00:25:02,000
will do the push shaking

718
00:25:02,000 --> 00:25:05,279
place live damp mdr after the hole and

719
00:25:05,279 --> 00:25:07,120
trigger the first vulnerability

720
00:25:07,120 --> 00:25:10,240
and modify the mdr next pointer it takes

721
00:25:10,240 --> 00:25:11,039
some time

722
00:25:11,039 --> 00:25:15,440
for the pull shaping

723
00:25:15,440 --> 00:25:17,440
then i run the second person script

724
00:25:17,440 --> 00:25:18,559
which will detect

725
00:25:18,559 --> 00:25:20,960
if the tentative shared memory has been

726
00:25:20,960 --> 00:25:22,640
modified or not

727
00:25:22,640 --> 00:25:25,120
if it has been modified i can do further

728
00:25:25,120 --> 00:25:25,840
actually

729
00:25:25,840 --> 00:25:29,279
read what where the third person script

730
00:25:29,279 --> 00:25:31,440
will modify the shard page pte to

731
00:25:31,440 --> 00:25:32,880
executable

732
00:25:32,880 --> 00:25:35,600
and the last person script will redirect

733
00:25:35,600 --> 00:25:38,240
the skpg context callback routine

734
00:25:38,240 --> 00:25:40,880
to the show code i prepared in the

735
00:25:40,880 --> 00:25:43,440
shared page

736
00:25:43,440 --> 00:25:46,240
after the due time comes the show code

737
00:25:46,240 --> 00:25:47,440
gets executed

738
00:25:47,440 --> 00:25:50,159
successfully

739
00:25:51,440 --> 00:25:55,600
now the shared page is executable

740
00:25:55,600 --> 00:25:58,080
and it is filled with the demo shell

741
00:25:58,080 --> 00:25:58,799
code

742
00:25:58,799 --> 00:26:01,360
and this piece of shell code is invoked

743
00:26:01,360 --> 00:26:04,000
by redirecting the skpg context

744
00:26:04,000 --> 00:26:08,159
callback routine and this shellcode

745
00:26:08,159 --> 00:26:11,360
will get executed periodically i can

746
00:26:11,360 --> 00:26:14,320
modify the shellcode from vtl0 freely

747
00:26:14,320 --> 00:26:18,240
at any time for any purpose in this way

748
00:26:18,240 --> 00:26:22,559
arbitrary code execution is achieved

749
00:26:22,559 --> 00:26:24,640
okay this is my part i will transfer

750
00:26:24,640 --> 00:26:25,600
control to star

751
00:26:25,600 --> 00:26:28,640
thank you thank you so much daniel for

752
00:26:28,640 --> 00:26:30,480
this great analysis and exploit so yeah

753
00:26:30,480 --> 00:26:32,000
we fixed this issue and now we make sure

754
00:26:32,000 --> 00:26:33,520
that the transfer mdl by country is

755
00:26:33,520 --> 00:26:34,240
valid

756
00:26:34,240 --> 00:26:36,159
but there's but there is something else

757
00:26:36,159 --> 00:26:37,919
which is super interesting in the

758
00:26:37,919 --> 00:26:39,679
general flow in this function over over

759
00:26:39,679 --> 00:26:40,080
here

760
00:26:40,080 --> 00:26:41,440
and this is something which is related

761
00:26:41,440 --> 00:26:43,440
to the way that we map in unmapped vtl1

762
00:26:43,440 --> 00:26:45,760
mdls let's take a closer look

763
00:26:45,760 --> 00:26:48,559
so this is a the general flow in skma

764
00:26:48,559 --> 00:26:49,919
obtained hotpatch on the table

765
00:26:49,919 --> 00:26:52,240
and as you can see we just allocate some

766
00:26:52,240 --> 00:26:53,679
chunk in a secure camera hip

767
00:26:53,679 --> 00:26:55,919
we copy the entire transfer mdl into

768
00:26:55,919 --> 00:26:56,799
this new chunk

769
00:26:56,799 --> 00:26:58,640
we make some integrity check and if this

770
00:26:58,640 --> 00:27:00,960
check passes we call skma map mdl

771
00:27:00,960 --> 00:27:03,600
to map this new mdl into the vtl1 outer

772
00:27:03,600 --> 00:27:04,400
space

773
00:27:04,400 --> 00:27:06,640
and if this check fails then we do go to

774
00:27:06,640 --> 00:27:08,240
clean up we take the ballot flow

775
00:27:08,240 --> 00:27:11,360
and we hit the call to skmm mdl

776
00:27:11,360 --> 00:27:12,960
now the problem here is that we don't

777
00:27:12,960 --> 00:27:14,559
make sure that we indeed called

778
00:27:14,559 --> 00:27:18,720
skmm up mdl before calling sk map mdl

779
00:27:18,720 --> 00:27:20,159
and this is exactly what is going to

780
00:27:20,159 --> 00:27:22,480
happen if the integrity check fails

781
00:27:22,480 --> 00:27:24,480
now since we can control over the entire

782
00:27:24,480 --> 00:27:26,640
undo mdl over here we can make this

783
00:27:26,640 --> 00:27:27,919
integrity check fails

784
00:27:27,919 --> 00:27:29,440
and therefore we just summed up to be

785
00:27:29,440 --> 00:27:31,919
the ability to call skmmdl

786
00:27:31,919 --> 00:27:34,960
on a fully controlled mdl by vtr0

787
00:27:34,960 --> 00:27:37,440
uh okay great and here you can see the

788
00:27:37,440 --> 00:27:38,960
code at the beginning you

789
00:27:38,960 --> 00:27:40,320
you can see the integrity check at the

790
00:27:40,320 --> 00:27:42,240
end you can see the call to sqm of

791
00:27:42,240 --> 00:27:44,480
mdl and right there in the middle there

792
00:27:44,480 --> 00:27:46,320
is the call to sqm up mdl which we

793
00:27:46,320 --> 00:27:47,440
clearly skipped

794
00:27:47,440 --> 00:27:49,679
okay plc's we have to write plcs for

795
00:27:49,679 --> 00:27:50,799
everything that we find because

796
00:27:50,799 --> 00:27:52,640
otherwise everything is meaningless

797
00:27:52,640 --> 00:27:54,960
so let's cover the mdl set our phone for

798
00:27:54,960 --> 00:27:56,080
one in the

799
00:27:56,080 --> 00:27:58,480
virtual address in the map system va

800
00:27:58,480 --> 00:28:00,159
trigger the vulnerability and boom

801
00:28:00,159 --> 00:28:02,320
we got the exact expected call stack in

802
00:28:02,320 --> 00:28:03,760
the crash from the vulnerable function

803
00:28:03,760 --> 00:28:04,720
to skmm and

804
00:28:04,720 --> 00:28:07,279
mdl and then password in other area on

805
00:28:07,279 --> 00:28:09,120
the virtual address aoa

806
00:28:09,120 --> 00:28:11,159
which is the pte address of the virtual

807
00:28:11,159 --> 00:28:12,399
rs4141

808
00:28:12,399 --> 00:28:14,840
from the mdl this happened because skm

809
00:28:14,840 --> 00:28:17,520
skmmpfmdl resolves the pte address of

810
00:28:17,520 --> 00:28:18,640
the virtual address

811
00:28:18,640 --> 00:28:21,840
in old drive zero into the pte

812
00:28:21,840 --> 00:28:23,840
okay great knowing this we can create

813
00:28:23,840 --> 00:28:24,960
another plc

814
00:28:24,960 --> 00:28:26,799
let's try to custom arbitrary flow in a

815
00:28:26,799 --> 00:28:28,720
secure kernel and for this to happen

816
00:28:28,720 --> 00:28:30,559
we really need to find some virtual

817
00:28:30,559 --> 00:28:32,399
address which is being used by something

818
00:28:32,399 --> 00:28:33,520
in within

819
00:28:33,520 --> 00:28:36,080
vtl1 i just show zero the shell page

820
00:28:36,080 --> 00:28:38,320
vtl1 has its own shell page it's this

821
00:28:38,320 --> 00:28:40,320
fixed virtual address set it up in the

822
00:28:40,320 --> 00:28:42,240
mdl trigger the vulnerability and again

823
00:28:42,240 --> 00:28:44,000
we got a crash in some arbitrary

824
00:28:44,000 --> 00:28:46,880
flow in the secure kernel uh in some

825
00:28:46,880 --> 00:28:48,480
thread they tried to dereference the

826
00:28:48,480 --> 00:28:50,320
shell page and of course

827
00:28:50,320 --> 00:28:52,159
this page is no longer present because

828
00:28:52,159 --> 00:28:54,159
we wrote zero on its pt

829
00:28:54,159 --> 00:28:56,159
okay great so we have the vulnerability

830
00:28:56,159 --> 00:28:58,000
we have the plc we know everything and

831
00:28:58,000 --> 00:28:59,840
now it's the time to get the actual work

832
00:28:59,840 --> 00:29:02,559
starting uh so please note that we don't

833
00:29:02,559 --> 00:29:03,200
have here

834
00:29:03,200 --> 00:29:04,880
a memory corruption with a controlled

835
00:29:04,880 --> 00:29:06,640
content permittive yet but we can

836
00:29:06,640 --> 00:29:07,520
clearly build one

837
00:29:07,520 --> 00:29:09,440
and in order to build one we really need

838
00:29:09,440 --> 00:29:12,399
to understand the functionality of sk

839
00:29:12,399 --> 00:29:14,640
mdl now this happened to be super simple

840
00:29:14,640 --> 00:29:15,600
this function

841
00:29:15,600 --> 00:29:17,760
simply scans all of the pte is discarded

842
00:29:17,760 --> 00:29:20,159
by this mdl

843
00:29:20,159 --> 00:29:22,960
it writes zeros over all of the speakers

844
00:29:22,960 --> 00:29:24,320
please note that after this step

845
00:29:24,320 --> 00:29:26,159
everyday reference to every single page

846
00:29:26,159 --> 00:29:27,520
discard by this mdl

847
00:29:27,520 --> 00:29:29,279
will panic because all of the present

848
00:29:29,279 --> 00:29:31,360
bits in all of the pte's

849
00:29:31,360 --> 00:29:33,360
are zeros and then we can choose if you

850
00:29:33,360 --> 00:29:35,120
want to take the call to skmi release

851
00:29:35,120 --> 00:29:36,080
unknown ptes

852
00:29:36,080 --> 00:29:37,840
which in addition to the zeroing out of

853
00:29:37,840 --> 00:29:39,760
all of the pts goes to the bitmap and

854
00:29:39,760 --> 00:29:41,279
clear all of the relevant bits

855
00:29:41,279 --> 00:29:43,520
just to indicate to the pt allocator hey

856
00:29:43,520 --> 00:29:45,039
all of the species are ready to be

857
00:29:45,039 --> 00:29:47,279
reclaimed and reuse

858
00:29:47,279 --> 00:29:48,960
okay great please note that all of the

859
00:29:48,960 --> 00:29:50,559
rights done by skm and

860
00:29:50,559 --> 00:29:52,320
mdl are safe in the sense that all of

861
00:29:52,320 --> 00:29:54,320
the rights to all of the ptes will for

862
00:29:54,320 --> 00:29:56,320
sure fall inside the pt's range

863
00:29:56,320 --> 00:29:58,080
due to the nature of the calculation

864
00:29:58,080 --> 00:30:00,240
which converts from the virtual address

865
00:30:00,240 --> 00:30:01,360
to the pt address

866
00:30:01,360 --> 00:30:02,480
and all of the rights to all of the

867
00:30:02,480 --> 00:30:04,000
pages left currents will for sure fall

868
00:30:04,000 --> 00:30:05,520
inside the pf and db range

869
00:30:05,520 --> 00:30:08,480
due to an explicit check in the code but

870
00:30:08,480 --> 00:30:10,240
we don't really need that

871
00:30:10,240 --> 00:30:12,399
we can zero out arbitrary rpts and

872
00:30:12,399 --> 00:30:14,080
therefore we can clearly create some use

873
00:30:14,080 --> 00:30:15,120
after this scenario

874
00:30:15,120 --> 00:30:16,720
by replacing the underlying physical

875
00:30:16,720 --> 00:30:18,559
page and if we want this to happen it

876
00:30:18,559 --> 00:30:19,840
would be very good of us to take the

877
00:30:19,840 --> 00:30:22,080
call to skma release unknown ptes just

878
00:30:22,080 --> 00:30:24,080
to make sure that the pt allocator can

879
00:30:24,080 --> 00:30:27,039
reuse those pts okay now it's the time

880
00:30:27,039 --> 00:30:28,799
to talk about some structures

881
00:30:28,799 --> 00:30:30,320
the secure canal maintains some

882
00:30:30,320 --> 00:30:31,760
structure in order to manage its own

883
00:30:31,760 --> 00:30:33,360
virtual address space makes sense

884
00:30:33,360 --> 00:30:35,919
one of the structure is the pte range

885
00:30:35,919 --> 00:30:37,840
this structure simply describes a range

886
00:30:37,840 --> 00:30:38,720
of pts of

887
00:30:38,720 --> 00:30:40,399
a certain use there are some examples

888
00:30:40,399 --> 00:30:42,640
that over here and this structure has

889
00:30:42,640 --> 00:30:44,480
exactly what you expect for me to have

890
00:30:44,480 --> 00:30:46,399
it has a pointer to all of the pts it

891
00:30:46,399 --> 00:30:47,679
has a pointer to the bitmap which

892
00:30:47,679 --> 00:30:49,600
indicates which one of those pts are

893
00:30:49,600 --> 00:30:51,679
free and which one is in used and this

894
00:30:51,679 --> 00:30:53,679
is really important for us here because

895
00:30:53,679 --> 00:30:56,000
the function skma releases unknown pts

896
00:30:56,000 --> 00:30:58,000
try to resolve the pte range which

897
00:30:58,000 --> 00:31:00,080
contains the pt address of the virtual

898
00:31:00,080 --> 00:31:01,440
address from the mdl

899
00:31:01,440 --> 00:31:03,200
and here you can see that this function

900
00:31:03,200 --> 00:31:04,880
only looks for specific

901
00:31:04,880 --> 00:31:07,600
three pt ranges which which absolutely

902
00:31:07,600 --> 00:31:09,200
don't cover the entire virtual other

903
00:31:09,200 --> 00:31:10,240
space there are more

904
00:31:10,240 --> 00:31:12,480
pt ranges and even after this function

905
00:31:12,480 --> 00:31:14,240
chooses one

906
00:31:14,240 --> 00:31:17,120
it doesn't really make sure that the ptl

907
00:31:17,120 --> 00:31:18,640
is inside the pta range

908
00:31:18,640 --> 00:31:20,799
it's only check against the base so i

909
00:31:20,799 --> 00:31:22,559
can just choose a virtual address

910
00:31:22,559 --> 00:31:24,399
which it spits here that is outside of

911
00:31:24,399 --> 00:31:26,080
all of those three pt ranges

912
00:31:26,080 --> 00:31:28,399
set it up in mdl and therefore i gain

913
00:31:28,399 --> 00:31:30,000
the ability to

914
00:31:30,000 --> 00:31:33,279
write relatively to the bitmap of one of

915
00:31:33,279 --> 00:31:35,120
those pt ranges so we gained

916
00:31:35,120 --> 00:31:37,360
a like relative right primitive

917
00:31:37,360 --> 00:31:38,320
fantastic

918
00:31:38,320 --> 00:31:40,240
and there is the plc from the vulnerable

919
00:31:40,240 --> 00:31:41,840
function to skmm of

920
00:31:41,840 --> 00:31:43,679
mdl and then and then page for the

921
00:31:43,679 --> 00:31:46,880
knowledge area

922
00:31:46,880 --> 00:31:49,519
during the the clearing of the bitmap

923
00:31:49,519 --> 00:31:50,480
okay fantastic

924
00:31:50,480 --> 00:31:52,640
this is super great and it's really cool

925
00:31:52,640 --> 00:31:53,919
and really awesome but it actually

926
00:31:53,919 --> 00:31:55,279
doesn't help us a lot because

927
00:31:55,279 --> 00:31:57,600
there are so many pages outside of all

928
00:31:57,600 --> 00:31:58,559
of those

929
00:31:58,559 --> 00:32:01,519
bitmaps of those specific 3pt ranges

930
00:32:01,519 --> 00:32:02,000
that

931
00:32:02,000 --> 00:32:04,159
aren't mapped and they are not in use at

932
00:32:04,159 --> 00:32:05,120
all so

933
00:32:05,120 --> 00:32:07,039
i really could make it work of course

934
00:32:07,039 --> 00:32:09,279
but i really prefer to do better tricks

935
00:32:09,279 --> 00:32:10,399
and therefore i just

936
00:32:10,399 --> 00:32:13,039
do the use after free idea it would be

937
00:32:13,039 --> 00:32:14,080
much much better

938
00:32:14,080 --> 00:32:16,559
and i'm gonna target the sky system pts

939
00:32:16,559 --> 00:32:18,240
since it's the main pte range in the

940
00:32:18,240 --> 00:32:19,200
secure kernel

941
00:32:19,200 --> 00:32:20,640
so we know exactly what we have to do

942
00:32:20,640 --> 00:32:22,080
right we need to find some some

943
00:32:22,080 --> 00:32:23,360
interesting structure

944
00:32:23,360 --> 00:32:24,880
we need to trigger the vulnerability and

945
00:32:24,880 --> 00:32:27,440
unmap the like underlying

946
00:32:27,440 --> 00:32:30,880
physical page reclaim the pt use of the

947
00:32:30,880 --> 00:32:31,279
free

948
00:32:31,279 --> 00:32:34,480
profit fantastic and it would be a very

949
00:32:34,480 --> 00:32:36,080
smart idea of us to understand the

950
00:32:36,080 --> 00:32:37,760
allocator involved here because we need

951
00:32:37,760 --> 00:32:40,080
to reclaim the pte

952
00:32:40,080 --> 00:32:42,240
so let's talk about the pt allocator

953
00:32:42,240 --> 00:32:44,080
this happens to be very very simple

954
00:32:44,080 --> 00:32:45,600
there are two functions the location

955
00:32:45,600 --> 00:32:47,120
function and the free function

956
00:32:47,120 --> 00:32:48,559
and the allocation function simply

957
00:32:48,559 --> 00:32:50,640
checks out the pit the

958
00:32:50,640 --> 00:32:52,720
bitmap hints value from the relevant pte

959
00:32:52,720 --> 00:32:54,559
range and it uses this value as the

960
00:32:54,559 --> 00:32:56,240
first index to scan form

961
00:32:56,240 --> 00:32:58,880
in the pte is bitmap and just looks for

962
00:32:58,880 --> 00:33:00,480
sequence of enough zeros

963
00:33:00,480 --> 00:33:02,640
and note that this bitmap hint value

964
00:33:02,640 --> 00:33:04,559
wraps around only when the allocation

965
00:33:04,559 --> 00:33:06,240
function reaches to the end of the

966
00:33:06,240 --> 00:33:09,440
pte range and you can see this

967
00:33:09,440 --> 00:33:11,200
in those debug traces you can see that

968
00:33:11,200 --> 00:33:13,039
all of the locations are continuous

969
00:33:13,039 --> 00:33:14,640
independent of all of the freeze in the

970
00:33:14,640 --> 00:33:16,320
middle okay

971
00:33:16,320 --> 00:33:18,799
great now we really want to get a good

972
00:33:18,799 --> 00:33:19,360
crush

973
00:33:19,360 --> 00:33:21,279
basically you know which area really

974
00:33:21,279 --> 00:33:22,799
isn't good enough and it's really

975
00:33:22,799 --> 00:33:24,000
doesn't interesting

976
00:33:24,000 --> 00:33:27,120
uh so i gave you two options i chose not

977
00:33:27,120 --> 00:33:29,360
to allocate the target structure myself

978
00:33:29,360 --> 00:33:31,279
because if i will i will also need to

979
00:33:31,279 --> 00:33:33,200
spray a lot in order to make the big pop

980
00:33:33,200 --> 00:33:34,640
hints to wrap around

981
00:33:34,640 --> 00:33:37,200
and i really prefer to do a better

982
00:33:37,200 --> 00:33:39,200
tricks and stable exploits

983
00:33:39,200 --> 00:33:42,480
uh so i simply can rely on the fact that

984
00:33:42,480 --> 00:33:43,200
the secure

985
00:33:43,200 --> 00:33:45,440
kernel boot process is so predictable

986
00:33:45,440 --> 00:33:46,799
and so deterministic

987
00:33:46,799 --> 00:33:48,880
that actually every time after boot i

988
00:33:48,880 --> 00:33:50,640
have about the same bitmap hints

989
00:33:50,640 --> 00:33:53,519
so i can just look over the entire

990
00:33:53,519 --> 00:33:55,279
address space that i have after the

991
00:33:55,279 --> 00:33:56,080
bitmap hint

992
00:33:56,080 --> 00:33:58,880
that i have after both and just see if i

993
00:33:58,880 --> 00:34:01,200
have already existing structure

994
00:34:01,200 --> 00:34:04,240
and that it's in used and

995
00:34:04,240 --> 00:34:07,679
that and it comes after the bitmap pins

996
00:34:07,679 --> 00:34:09,918
and of course i found the plcb structure

997
00:34:09,918 --> 00:34:11,280
which is great candidate for memory

998
00:34:11,280 --> 00:34:13,359
corruption exploits

999
00:34:13,359 --> 00:34:15,040
please note that i can't corrupt

1000
00:34:15,040 --> 00:34:17,280
specific data i have to corrupt at least

1001
00:34:17,280 --> 00:34:19,280
at least one page due to the nature of

1002
00:34:19,280 --> 00:34:20,560
the vulnerability

1003
00:34:20,560 --> 00:34:22,480
and but it's actually fine because this

1004
00:34:22,480 --> 00:34:24,159
structure is very very large it spends

1005
00:34:24,159 --> 00:34:25,679
over a few pages

1006
00:34:25,679 --> 00:34:27,918
and i can of course choose the specific

1007
00:34:27,918 --> 00:34:30,239
page which is best for me to corrupt

1008
00:34:30,239 --> 00:34:31,839
okay great so we know what the high

1009
00:34:31,839 --> 00:34:33,280
level plan here

1010
00:34:33,280 --> 00:34:36,000
is right okay let's see it in action so

1011
00:34:36,000 --> 00:34:36,560
this is

1012
00:34:36,560 --> 00:34:40,719
the the bitmap of all of the pts in skmi

1013
00:34:40,719 --> 00:34:43,119
system pt is pt range there is the

1014
00:34:43,119 --> 00:34:44,800
bitmap hints that i have

1015
00:34:44,800 --> 00:34:47,199
after both right there so let's pray

1016
00:34:47,199 --> 00:34:48,879
just to get closer to the plc

1017
00:34:48,879 --> 00:34:51,520
pages to regular vulnerability on the

1018
00:34:51,520 --> 00:34:53,119
expected virtual address

1019
00:34:53,119 --> 00:34:55,199
and keeps brain in order to reclaim the

1020
00:34:55,199 --> 00:34:56,320
pt of

1021
00:34:56,320 --> 00:34:58,960
this single page inside the plc pages

1022
00:34:58,960 --> 00:34:59,520
and by

1023
00:34:59,520 --> 00:35:02,640
implementing this and run the poc

1024
00:35:02,640 --> 00:35:04,720
we got finally a great crash of

1025
00:35:04,720 --> 00:35:07,680
dereferencing arbitrary pointers

1026
00:35:07,680 --> 00:35:09,839
from this point it's very trivial to

1027
00:35:09,839 --> 00:35:11,440
gain read write primitives

1028
00:35:11,440 --> 00:35:13,200
and from this point we know exactly what

1029
00:35:13,200 --> 00:35:15,280
we need to do and we don't have time to

1030
00:35:15,280 --> 00:35:16,720
see the full extract but

1031
00:35:16,720 --> 00:35:19,680
but we already saw what we can do with

1032
00:35:19,680 --> 00:35:20,720
right

1033
00:35:20,720 --> 00:35:23,520
primitive so it's game over okay now

1034
00:35:23,520 --> 00:35:25,040
let's talk about what you can do after

1035
00:35:25,040 --> 00:35:26,720
we gain arbitrary code execution

1036
00:35:26,720 --> 00:35:30,079
so of course we can bypass a both hvci

1037
00:35:30,079 --> 00:35:31,920
and traditional guard as we said because

1038
00:35:31,920 --> 00:35:33,520
the secure can by design

1039
00:35:33,520 --> 00:35:35,440
have the ability to issue hyper calls

1040
00:35:35,440 --> 00:35:36,560
for the hypervisor

1041
00:35:36,560 --> 00:35:39,599
and requesting setting arbitrary

1042
00:35:39,599 --> 00:35:41,760
permissions in the slots

1043
00:35:41,760 --> 00:35:44,640
of course fantastic we keep work on

1044
00:35:44,640 --> 00:35:45,359
hardening

1045
00:35:45,359 --> 00:35:47,119
the secure kernel we fix all of the

1046
00:35:47,119 --> 00:35:50,240
issues we found in this research

1047
00:35:50,240 --> 00:35:52,240
we truly believe that there is so much

1048
00:35:52,240 --> 00:35:53,280
high values

1049
00:35:53,280 --> 00:35:55,520
in developing end-to-end exploits and

1050
00:35:55,520 --> 00:35:56,720
one of those is

1051
00:35:56,720 --> 00:35:59,760
to spot an important behaviors to change

1052
00:35:59,760 --> 00:36:03,119
uh so we made this for both writable and

1053
00:36:03,119 --> 00:36:05,599
executable addresses to be non-writable

1054
00:36:05,599 --> 00:36:07,680
uh we are investigating right now

1055
00:36:07,680 --> 00:36:09,040
options for

1056
00:36:09,040 --> 00:36:11,119
randomization of secure kernel regions

1057
00:36:11,119 --> 00:36:12,640
there are actually more surprises to

1058
00:36:12,640 --> 00:36:13,040
come

1059
00:36:13,040 --> 00:36:15,760
so please stay with us and of course if

1060
00:36:15,760 --> 00:36:16,640
you have bugs

1061
00:36:16,640 --> 00:36:19,040
please please submit to us we really

1062
00:36:19,040 --> 00:36:20,480
want to work together

1063
00:36:20,480 --> 00:36:24,160
and and just

1064
00:36:24,160 --> 00:36:27,200
like we said uh dos isn't in scope

1065
00:36:27,200 --> 00:36:27,839
because

1066
00:36:27,839 --> 00:36:30,880
a vtl0 can of course by design dos

1067
00:36:30,880 --> 00:36:33,920
vtl1 so we need to find plc's uh

1068
00:36:33,920 --> 00:36:36,560
which actually can leak sensitive data

1069
00:36:36,560 --> 00:36:37,920
or can corrupt memory

1070
00:36:37,920 --> 00:36:40,960
and etc okay great uh this

1071
00:36:40,960 --> 00:36:42,640
this rituals could not have been done

1072
00:36:42,640 --> 00:36:45,599
like without a a

1073
00:36:45,599 --> 00:36:48,800
a great fox so thank you all so much

1074
00:36:48,800 --> 00:36:51,520
and now would be the time for q a thank

1075
00:36:51,520 --> 00:36:55,839
you so much

1076
00:36:56,079 --> 00:36:59,839
thank you hi thank you so much

1077
00:36:59,839 --> 00:37:04,240
for for attending the talk

1078
00:37:04,240 --> 00:37:07,920
and we don't see any questions that we

1079
00:37:07,920 --> 00:37:08,800
didn't answer

1080
00:37:08,800 --> 00:37:12,720
right if there is some clarification

1081
00:37:12,720 --> 00:37:13,760
that you want to make

1082
00:37:13,760 --> 00:37:17,760
some question some issue please um

1083
00:37:17,760 --> 00:37:23,839
write it right now in the chat

1084
00:37:24,560 --> 00:37:26,800
it might be worth uh to mention that we

1085
00:37:26,800 --> 00:37:29,119
are about to upload the slides in about

1086
00:37:29,119 --> 00:37:29,760
uh

1087
00:37:29,760 --> 00:37:32,960
five minutes also so you can find it

1088
00:37:32,960 --> 00:37:37,760
on twitter and are there any

1089
00:37:37,760 --> 00:37:51,839
any questions

1090
00:38:10,240 --> 00:38:14,400
okay so you could find the slides again

1091
00:38:14,400 --> 00:38:18,079
on twitter it will be on the msrc github

1092
00:38:18,079 --> 00:38:22,160
and thank you so much

1093
00:38:30,079 --> 00:38:33,839
thank you

1094
00:38:36,079 --> 00:38:39,520
oh wait i see are the plans to extend

1095
00:38:39,520 --> 00:38:40,640
the vital zero

1096
00:38:40,640 --> 00:38:43,119
mitigations to retail one secure kernel

1097
00:38:43,119 --> 00:38:44,160
yes so

1098
00:38:44,160 --> 00:38:47,599
so this is a very very good point uh yes

1099
00:38:47,599 --> 00:38:50,880
uh as i said at the end we are working

1100
00:38:50,880 --> 00:38:53,680
on porting some of the noble kernel

1101
00:38:53,680 --> 00:38:55,839
mitigations into the secure kernel

1102
00:38:55,839 --> 00:38:58,240
uh we are starting with investigating

1103
00:38:58,240 --> 00:39:00,720
some um

1104
00:39:00,720 --> 00:39:02,960
randomization for all of the fixed

1105
00:39:02,960 --> 00:39:04,240
addresses and all of the like

1106
00:39:04,240 --> 00:39:05,760
predictable ones

1107
00:39:05,760 --> 00:39:08,000
and and there are some more like

1108
00:39:08,000 --> 00:39:09,359
surprises to come

1109
00:39:09,359 --> 00:39:12,400
the devs team are talking on that

1110
00:39:12,400 --> 00:39:15,440
uh stay tuned for some like interesting

1111
00:39:15,440 --> 00:39:16,000
news

1112
00:39:16,000 --> 00:39:20,240
in the near future and yes so

1113
00:39:20,240 --> 00:39:23,920
just like i said queso

1114
00:39:23,920 --> 00:39:26,960
will for show um

1115
00:39:26,960 --> 00:39:29,520
they are working on it's like right now

1116
00:39:29,520 --> 00:39:31,440
and see if i it's and like

1117
00:39:31,440 --> 00:39:33,119
interesting point yeah we definitely

1118
00:39:33,119 --> 00:39:35,280
want to have c fighter

1119
00:39:35,280 --> 00:39:37,599
and then the the like interesting point

1120
00:39:37,599 --> 00:39:38,880
is that unlike

1121
00:39:38,880 --> 00:39:42,079
uh the k uh cfg that we

1122
00:39:42,079 --> 00:39:45,280
will have in in there like

1123
00:39:45,280 --> 00:39:47,920
a normal kernel and we can protect uh

1124
00:39:47,920 --> 00:39:49,280
recover the bitmap

1125
00:39:49,280 --> 00:39:52,000
uh with the uh extended vegetables we

1126
00:39:52,000 --> 00:39:52,320
can't

1127
00:39:52,320 --> 00:39:53,920
do that for the secure camera because

1128
00:39:53,920 --> 00:39:55,760
there isn't slot enforcement

1129
00:39:55,760 --> 00:39:58,960
but we can shell have like a normal

1130
00:39:58,960 --> 00:40:01,839
sieve jitter it might happen in the

1131
00:40:01,839 --> 00:40:11,839
future as well

1132
00:40:22,839 --> 00:40:25,839
okay

1133
00:40:44,880 --> 00:40:48,160
okay great so thank you so

1134
00:40:48,160 --> 00:40:51,359
so much again er enjoy

1135
00:40:51,359 --> 00:40:56,400
the rest of brackets bye

