1
00:00:03,500 --> 00:00:15,839
[Music]

2
00:00:15,839 --> 00:00:16,239
hi

3
00:00:16,239 --> 00:00:20,240
everyone my name is from the city of

4
00:00:20,240 --> 00:00:23,199
life i'm glad to have this opportunity

5
00:00:23,199 --> 00:00:25,119
to share this topic with you

6
00:00:25,119 --> 00:00:28,400
and we know because of the exist of many

7
00:00:28,400 --> 00:00:31,439
mitigations in android nowadays it's

8
00:00:31,439 --> 00:00:33,040
very difficult to

9
00:00:33,040 --> 00:00:35,920
the most needed android devices but

10
00:00:35,920 --> 00:00:36,559
today

11
00:00:36,559 --> 00:00:39,120
i'll show you how i importantly use the

12
00:00:39,120 --> 00:00:41,200
toughest android device

13
00:00:41,200 --> 00:00:44,480
the pixel 4 at the beginning of this

14
00:00:44,480 --> 00:00:45,280
talk

15
00:00:45,280 --> 00:00:50,079
i want to introduce our team shortening

16
00:00:52,320 --> 00:00:55,520
i am the team leader of 360 of lab

17
00:00:55,520 --> 00:00:58,079
our main research fields are android

18
00:00:58,079 --> 00:00:59,520
assistant security and

19
00:00:59,520 --> 00:01:02,559
chrome broader security we have found

20
00:01:02,559 --> 00:01:05,519
more than 300 vulnerabilities in android

21
00:01:05,519 --> 00:01:07,680
system

22
00:01:07,680 --> 00:01:10,799
we won the highest

23
00:01:10,799 --> 00:01:15,400
reward in the history of asr program in

24
00:01:15,400 --> 00:01:18,320
2017 because of the

25
00:01:18,320 --> 00:01:22,159
express chain introduced in this talk

26
00:01:22,159 --> 00:01:24,720
we have won the highest reward in the

27
00:01:24,720 --> 00:01:25,439
history

28
00:01:25,439 --> 00:01:30,079
of all google vrp programs in 2019

29
00:01:30,079 --> 00:01:33,040
we have also had different targets in

30
00:01:33,040 --> 00:01:33,520
different

31
00:01:33,520 --> 00:01:36,479
porn contests

32
00:01:39,280 --> 00:01:42,159
a brief look at today's agenda i'll

33
00:01:42,159 --> 00:01:42,640
first

34
00:01:42,640 --> 00:01:44,880
explain why google pixel phone is a

35
00:01:44,880 --> 00:01:45,759
tough target

36
00:01:45,759 --> 00:01:49,040
from two aspects the price paid by

37
00:01:49,040 --> 00:01:51,200
vulnerability blocks and the

38
00:01:51,200 --> 00:01:56,640
results of mobile. in last three years

39
00:01:56,640 --> 00:02:00,000
next i'll introduce remote telescopes of

40
00:02:00,000 --> 00:02:02,079
android devices

41
00:02:02,079 --> 00:02:04,479
then i'll share my experience of

42
00:02:04,479 --> 00:02:06,159
recording android device

43
00:02:06,159 --> 00:02:09,440
six times in different competitions

44
00:02:09,440 --> 00:02:13,120
next we will overview the exploit chain

45
00:02:13,120 --> 00:02:16,319
name the tv zoom this can remotely use

46
00:02:16,319 --> 00:02:19,040
a wide range of qualcomm based android

47
00:02:19,040 --> 00:02:19,760
devices

48
00:02:19,760 --> 00:02:23,040
include pixel devices after that

49
00:02:23,040 --> 00:02:25,920
i'll detail the three vulnerabilities in

50
00:02:25,920 --> 00:02:26,800
the chain

51
00:02:26,800 --> 00:02:29,360
and how i change these three

52
00:02:29,360 --> 00:02:30,319
vulnerabilities

53
00:02:30,319 --> 00:02:35,200
for exploitation without any rp

54
00:02:35,200 --> 00:02:37,440
at the end of this presentation i'll

55
00:02:37,440 --> 00:02:38,239
demonstrate

56
00:02:38,239 --> 00:02:41,040
how to get a reverse share with good

57
00:02:41,040 --> 00:02:41,760
permission

58
00:02:41,760 --> 00:02:44,640
or a piece of form by accessing a

59
00:02:44,640 --> 00:02:45,840
malicious

60
00:02:45,840 --> 00:02:49,120
link in android

61
00:02:49,360 --> 00:02:52,879
which is the most secure smartphone

62
00:02:52,879 --> 00:02:55,440
it's an open question and i think there

63
00:02:55,440 --> 00:02:57,760
is no standard answer

64
00:02:57,760 --> 00:03:01,680
android and ios are the two most popular

65
00:03:01,680 --> 00:03:04,720
mobile operating system in the world and

66
00:03:04,720 --> 00:03:06,400
there are too many arguments

67
00:03:06,400 --> 00:03:10,560
about which one is more secure

68
00:03:10,560 --> 00:03:12,480
there are different answers from

69
00:03:12,480 --> 00:03:14,959
different perspectives

70
00:03:14,959 --> 00:03:17,680
if we ask the questions from the

71
00:03:17,680 --> 00:03:20,480
perspective of their price paid by

72
00:03:20,480 --> 00:03:23,120
vulnerability blocks is since now

73
00:03:23,120 --> 00:03:24,560
android is

74
00:03:24,560 --> 00:03:29,599
more secure than always

75
00:03:29,840 --> 00:03:33,920
the audience pays up to 0.5

76
00:03:33,920 --> 00:03:36,959
million dollars for android fcp there

77
00:03:36,959 --> 00:03:37,840
are click

78
00:03:37,840 --> 00:03:40,879
express chain which is higher than

79
00:03:40,879 --> 00:03:44,840
rs fcp zero click export

80
00:03:44,840 --> 00:03:47,840
chain

81
00:03:48,000 --> 00:03:51,519
if we assume android is more secure

82
00:03:51,519 --> 00:03:54,640
than ios the remaining question is

83
00:03:54,640 --> 00:03:57,680
which is the most secure phones among

84
00:03:57,680 --> 00:04:00,720
android phones is easier to answer

85
00:04:00,720 --> 00:04:04,959
than the previous one google pixel phone

86
00:04:04,959 --> 00:04:08,080
often have more updates also versions

87
00:04:08,080 --> 00:04:10,879
security patches and vulnerability

88
00:04:10,879 --> 00:04:12,239
mitigations

89
00:04:12,239 --> 00:04:16,160
than other android phones which makes it

90
00:04:16,160 --> 00:04:19,279
more difficult to be attracted

91
00:04:19,279 --> 00:04:22,320
as shown in table

92
00:04:22,320 --> 00:04:25,600
the pizza phone is the only device

93
00:04:25,600 --> 00:04:29,040
that will not pond him welcome to all

94
00:04:29,040 --> 00:04:32,639
competitions in another three years

95
00:04:32,639 --> 00:04:35,120
while iphone will pronounce seven tasks

96
00:04:35,120 --> 00:04:36,320
in total

97
00:04:36,320 --> 00:04:40,160
all other android android devices

98
00:04:40,160 --> 00:04:43,360
include the sensor galaxy huawei

99
00:04:43,360 --> 00:04:46,639
mate p-series xiaomi mi

100
00:04:46,639 --> 00:04:51,040
devices were found several times

101
00:04:51,040 --> 00:04:55,520
in the contest too many exploits

102
00:04:55,520 --> 00:04:58,400
demonstrated in the contest target

103
00:04:58,400 --> 00:04:59,040
android

104
00:04:59,040 --> 00:05:02,479
devices existed in australia

105
00:05:02,479 --> 00:05:05,759
os component or unsecured

106
00:05:05,759 --> 00:05:08,960
customized code so we can conclude that

107
00:05:08,960 --> 00:05:10,720
pixel device is a

108
00:05:10,720 --> 00:05:13,440
tough target

109
00:05:14,000 --> 00:05:17,520
before i talk about my exploit chain

110
00:05:17,520 --> 00:05:20,479
i want to give you a telesurface

111
00:05:20,479 --> 00:05:21,840
analysis

112
00:05:21,840 --> 00:05:26,160
of remotely compromising smartphones

113
00:05:26,160 --> 00:05:29,360
as shown in the picture the most attack

114
00:05:29,360 --> 00:05:33,199
of smart remote attacks of smartphones

115
00:05:33,199 --> 00:05:36,639
can be divided into two categories by

116
00:05:36,639 --> 00:05:39,919
a target victor it hurts through

117
00:05:39,919 --> 00:05:43,759
internet and attacks

118
00:05:43,759 --> 00:05:47,680
through adjacent network

119
00:05:48,400 --> 00:05:51,759
normally speaking attacks that

120
00:05:51,759 --> 00:05:55,199
vulnerabilities in brothers arms

121
00:05:55,199 --> 00:05:58,479
and emails can be launched through

122
00:05:58,479 --> 00:06:01,520
internet more more evenly

123
00:06:01,520 --> 00:06:04,240
it has that exploits availabilities in

124
00:06:04,240 --> 00:06:05,280
nfc

125
00:06:05,280 --> 00:06:08,400
bluetooth wi-fi and the baseband

126
00:06:08,400 --> 00:06:11,120
are mostly launched through adjacent

127
00:06:11,120 --> 00:06:12,240
network

128
00:06:12,240 --> 00:06:14,080
attacks from internet is more

129
00:06:14,080 --> 00:06:15,919
destructive than it has from

130
00:06:15,919 --> 00:06:19,039
hs network but the former often

131
00:06:19,039 --> 00:06:22,240
needs some instructions such as clicking

132
00:06:22,240 --> 00:06:24,960
a url opening an email or instance

133
00:06:24,960 --> 00:06:26,400
message

134
00:06:26,400 --> 00:06:29,600
is relative easier to launch i tag from

135
00:06:29,600 --> 00:06:33,039
adjacent network without interaction

136
00:06:33,039 --> 00:06:36,160
than from the internet product home and

137
00:06:36,160 --> 00:06:37,759
blue bone are amazing

138
00:06:37,759 --> 00:06:40,080
adjacent network attacks it's hard to

139
00:06:40,080 --> 00:06:42,400
say which attack is more harmful

140
00:06:42,400 --> 00:06:45,919
between zero click adjacent

141
00:06:45,919 --> 00:06:49,120
adjacent network attack and one click

142
00:06:49,120 --> 00:06:52,720
internet deployable attack

143
00:06:55,199 --> 00:06:57,599
the exploit chain are used to remotely

144
00:06:57,599 --> 00:06:59,199
use the piece of phone is a

145
00:06:59,199 --> 00:07:02,560
one-click internet deployable attaching

146
00:07:02,560 --> 00:07:06,240
this table summarize some remote

147
00:07:06,240 --> 00:07:09,039
working support chains from the by me

148
00:07:09,039 --> 00:07:10,240
started android

149
00:07:10,240 --> 00:07:13,639
in recent years in mobile control

150
00:07:13,639 --> 00:07:17,520
2015 upcoming lesson 6 with a single

151
00:07:17,520 --> 00:07:18,800
variability

152
00:07:18,800 --> 00:07:22,080
a force to get rce in chrome render

153
00:07:22,080 --> 00:07:22,800
process

154
00:07:22,800 --> 00:07:26,400
then attend this rc into a uss

155
00:07:26,400 --> 00:07:27,599
vulnerability

156
00:07:27,599 --> 00:07:30,639
so any javascript could be injected to

157
00:07:30,639 --> 00:07:32,160
google play websites

158
00:07:32,160 --> 00:07:35,840
any apps any gap could be installed

159
00:07:35,840 --> 00:07:37,440
right

160
00:07:37,440 --> 00:07:42,560
in front of rama 2016

161
00:07:42,560 --> 00:07:45,280
upon enjoy the phone with a single

162
00:07:45,280 --> 00:07:46,800
express chain

163
00:07:46,800 --> 00:07:49,440
the express chain also started from a vs

164
00:07:49,440 --> 00:07:50,240
bug

165
00:07:50,240 --> 00:07:55,039
combined with a chrome ipc weakness

166
00:07:56,240 --> 00:07:59,039
the webview in android had no standpoint

167
00:07:59,039 --> 00:08:00,879
at that time

168
00:08:00,879 --> 00:08:04,000
by exploiting the v8 bug again in a

169
00:08:04,000 --> 00:08:04,960
review

170
00:08:04,960 --> 00:08:08,000
chrome samples could be bypassed

171
00:08:08,000 --> 00:08:11,440
easily this thunderbolts escaping method

172
00:08:11,440 --> 00:08:12,720
that doesn't work

173
00:08:12,720 --> 00:08:16,000
anymore because webview is sandbox now

174
00:08:16,000 --> 00:08:19,680
is it also unboxed now

175
00:08:20,479 --> 00:08:23,520
in front of us 2016

176
00:08:23,520 --> 00:08:26,560
i found a pixel xl

177
00:08:26,560 --> 00:08:29,440
with a single vulnerability once more

178
00:08:29,440 --> 00:08:30,479
the method is

179
00:08:30,479 --> 00:08:33,799
similar to point on

180
00:08:33,799 --> 00:08:38,120
2050 house confessed

181
00:08:38,120 --> 00:08:40,399
2016 google

182
00:08:40,399 --> 00:08:44,080
output updated their

183
00:08:44,080 --> 00:08:48,560
remote apps installation features to

184
00:08:48,560 --> 00:08:51,360
prompt their user to enter their

185
00:08:51,360 --> 00:08:52,560
password

186
00:08:52,560 --> 00:08:54,480
which makes this form of attack

187
00:08:54,480 --> 00:08:55,680
difficult but

188
00:08:55,680 --> 00:08:58,399
it took more than a year for them to

189
00:08:58,399 --> 00:09:00,959
mitigate this kind of attack

190
00:09:00,959 --> 00:09:04,160
and of chrome 77 such

191
00:09:04,160 --> 00:09:06,880
as nation has been enabled on android

192
00:09:06,880 --> 00:09:08,160
devices

193
00:09:08,160 --> 00:09:10,640
it's nearly impossible to navigate the

194
00:09:10,640 --> 00:09:12,000
rce2

195
00:09:12,000 --> 00:09:16,600
uss method in mobile.

196
00:09:16,600 --> 00:09:21,360
2017 i found a galaxy s8 with two parts

197
00:09:21,360 --> 00:09:24,800
an oob ass bar in sensor internet

198
00:09:24,800 --> 00:09:26,160
browser and a

199
00:09:26,160 --> 00:09:29,200
use of a map variability in sensor

200
00:09:29,200 --> 00:09:32,480
essentials gr lock module

201
00:09:32,480 --> 00:09:34,480
and can create a reverse share with

202
00:09:34,480 --> 00:09:36,160
system user permission

203
00:09:36,160 --> 00:09:40,959
through this exploit chair in 2018

204
00:09:40,959 --> 00:09:44,640
i found a piece of phone with two parts

205
00:09:44,640 --> 00:09:47,920
fbs engine bug is used to get rc

206
00:09:47,920 --> 00:09:51,200
in sun post render process above

207
00:09:51,200 --> 00:09:56,000
in android devices

208
00:09:56,399 --> 00:09:59,600
module is used to escape from

209
00:09:59,600 --> 00:10:03,040
chrome's sandbox together this

210
00:10:03,040 --> 00:10:06,160
express chain can be used to inject

211
00:10:06,160 --> 00:10:09,839
archery code into system server by

212
00:10:09,839 --> 00:10:13,200
accessing a malicious url in

213
00:10:13,200 --> 00:10:16,240
chrome in 2

214
00:10:16,240 --> 00:10:19,279
3 and 19 upon the first three

215
00:10:19,279 --> 00:10:22,480
with three bars and then this explode

216
00:10:22,480 --> 00:10:23,360
chain

217
00:10:23,360 --> 00:10:26,000
t window

218
00:10:27,680 --> 00:10:31,519
so what is t window tv zone is from a

219
00:10:31,519 --> 00:10:32,959
very famous

220
00:10:32,959 --> 00:10:36,720
chinese kung fu story and these come for

221
00:10:36,720 --> 00:10:37,600
all people

222
00:10:37,600 --> 00:10:41,519
to move upward swiftly and

223
00:10:41,519 --> 00:10:45,360
effortlessly as if clouds are the stairs

224
00:10:45,360 --> 00:10:47,920
the explorer chain includes three bars

225
00:10:47,920 --> 00:10:50,399
which are just not the cloud styles of

226
00:10:50,399 --> 00:10:50,800
tv

227
00:10:50,800 --> 00:10:53,040
zone

228
00:10:56,000 --> 00:10:58,640
the exploit chain is composed of three

229
00:10:58,640 --> 00:10:59,120
bars

230
00:10:59,120 --> 00:11:02,480
two chromebooks and one qualcomm kg sl

231
00:11:02,480 --> 00:11:03,920
java bar

232
00:11:03,920 --> 00:11:07,839
the attack vector is malicious links

233
00:11:07,839 --> 00:11:10,959
once victim access a

234
00:11:10,959 --> 00:11:14,000
weblink conjured by attack it

235
00:11:14,000 --> 00:11:16,880
has they target can get a reward share

236
00:11:16,880 --> 00:11:18,800
with the permission of the

237
00:11:18,800 --> 00:11:21,920
intellect form this video

238
00:11:21,920 --> 00:11:24,480
shows how to emotionally get those

239
00:11:24,480 --> 00:11:25,120
permission

240
00:11:25,120 --> 00:11:28,800
with the use production first

241
00:11:28,800 --> 00:11:32,640
orb aspart in v8 is

242
00:11:32,640 --> 00:11:35,040
exploited to achieve remote code

243
00:11:35,040 --> 00:11:36,640
execution in

244
00:11:36,640 --> 00:11:40,079
a chrome vendor process random process

245
00:11:40,079 --> 00:11:40,880
runs in the

246
00:11:40,880 --> 00:11:43,680
sc seniors domain as needed app and a

247
00:11:43,680 --> 00:11:45,200
harness and post

248
00:11:45,200 --> 00:11:47,680
for example if it can't access the gpu

249
00:11:47,680 --> 00:11:50,399
java territory

250
00:11:50,399 --> 00:11:54,040
cbe 2019

251
00:11:54,040 --> 00:11:57,680
10567 is about in core contribute java

252
00:11:57,680 --> 00:11:59,040
but it can be tweaked

253
00:11:59,040 --> 00:12:02,320
directly from isolated

254
00:12:02,320 --> 00:12:05,600
isolated app domain in order to

255
00:12:05,600 --> 00:12:07,760
trigger this problem we need to escape

256
00:12:07,760 --> 00:12:09,279
from isolated

257
00:12:09,279 --> 00:12:12,480
abdomen with the help of

258
00:12:12,480 --> 00:12:17,120
cve 2019 5s70

259
00:12:17,120 --> 00:12:20,399
firstly it is a use of free

260
00:12:20,399 --> 00:12:21,360
vulnerability

261
00:12:21,360 --> 00:12:24,720
in the media component a

262
00:12:24,720 --> 00:12:27,760
compromise the render process can

263
00:12:27,760 --> 00:12:29,839
trigger this vulnerability

264
00:12:29,839 --> 00:12:33,040
through module call by exploiting

265
00:12:33,040 --> 00:12:36,160
this bug archicad can be

266
00:12:36,160 --> 00:12:39,600
executed in chrome privileged process

267
00:12:39,600 --> 00:12:43,279
this process runs in the synx domain

268
00:12:43,279 --> 00:12:48,160
on just the app it can access gpu driver

269
00:12:48,160 --> 00:12:51,360
i'm going to detail how to exploit

270
00:12:51,360 --> 00:12:55,040
these three bugs separately

271
00:12:56,480 --> 00:12:58,880
first let me introduce the rce

272
00:12:58,880 --> 00:13:01,600
vulnerability

273
00:13:04,320 --> 00:13:07,680
this bug exists in the tokyo of chrome

274
00:13:07,680 --> 00:13:10,399
vs javascript engine

275
00:13:10,399 --> 00:13:13,839
we add the code stop assembler

276
00:13:13,839 --> 00:13:17,600
provide no newer primitive

277
00:13:17,600 --> 00:13:20,560
as a thin abstract abstraction over

278
00:13:20,560 --> 00:13:22,240
assembly

279
00:13:22,240 --> 00:13:25,680
we as a tokyo is a we as

280
00:13:25,680 --> 00:13:28,959
a specifier a specific domain

281
00:13:28,959 --> 00:13:34,079
specific language that is translated

282
00:13:39,839 --> 00:13:42,880
many javascript appears in functions and

283
00:13:42,880 --> 00:13:44,399
the objects are

284
00:13:44,399 --> 00:13:48,079
implemented by vlog

285
00:13:48,079 --> 00:13:51,839
talk this figure shows the build process

286
00:13:51,839 --> 00:13:52,240
of

287
00:13:52,240 --> 00:13:56,079
talking code if there is any bug in

288
00:13:56,079 --> 00:13:59,360
toggle code it will be

289
00:13:59,360 --> 00:14:02,560
propagated to generate the css

290
00:14:02,560 --> 00:14:05,680
csa code and then to the generated

291
00:14:05,680 --> 00:14:06,320
structural

292
00:14:06,320 --> 00:14:09,600
file in the end the snapshot file

293
00:14:09,600 --> 00:14:13,199
is embedded into chrome to speed up

294
00:14:13,199 --> 00:14:16,639
the initialization of all built-in

295
00:14:16,639 --> 00:14:21,279
functionality in v8 heap

296
00:14:21,839 --> 00:14:24,959
before we talk about the rc bug we have

297
00:14:24,959 --> 00:14:25,839
to know

298
00:14:25,839 --> 00:14:29,120
the js function memory layout first

299
00:14:29,120 --> 00:14:32,160
this function in columbia is the

300
00:14:32,160 --> 00:14:35,760
internal representation of function in

301
00:14:35,760 --> 00:14:37,040
javascript

302
00:14:37,040 --> 00:14:40,320
the sound of these objects in vs is not

303
00:14:40,320 --> 00:14:41,279
fixed

304
00:14:41,279 --> 00:14:44,160
it may contain the field the product

305
00:14:44,160 --> 00:14:46,800
type orientation map or not

306
00:14:46,800 --> 00:14:49,199
the field prototype or initial map is

307
00:14:49,199 --> 00:14:50,480
the last field of

308
00:14:50,480 --> 00:14:54,079
js function if it has

309
00:14:56,399 --> 00:14:58,399
this is the field information of the

310
00:14:58,399 --> 00:15:00,880
function

311
00:15:01,680 --> 00:15:04,720
how prototype slots

312
00:15:04,720 --> 00:15:09,279
means the area function has a field

313
00:15:09,279 --> 00:15:13,760
prototype or initial map so it starts in

314
00:15:13,760 --> 00:15:17,680
the 64 parts this is the field

315
00:15:17,680 --> 00:15:19,440
information of the function

316
00:15:19,440 --> 00:15:22,959
pass in it has no prototypes node

317
00:15:22,959 --> 00:15:27,440
so itself is 56

318
00:15:27,440 --> 00:15:30,480
but in most situation

319
00:15:30,480 --> 00:15:33,519
if a function is a constructor

320
00:15:33,519 --> 00:15:37,199
it has prototypes not

321
00:15:37,199 --> 00:15:39,759
if a function is not a construct it has

322
00:15:39,759 --> 00:15:41,040
no prototypes node

323
00:15:41,040 --> 00:15:44,800
but there is an exception

324
00:15:44,800 --> 00:15:50,320
the function proxy is a constructor

325
00:15:50,320 --> 00:15:54,240
but it has no prototypes node

326
00:15:54,240 --> 00:15:57,920
so the bucket here the token macro

327
00:15:57,920 --> 00:16:01,680
credit derived map didn't check

328
00:16:01,680 --> 00:16:04,880
whether the argument's a new target

329
00:16:04,880 --> 00:16:08,800
contains a prototype or initial map

330
00:16:08,800 --> 00:16:11,920
and the analysis is directed so it's out

331
00:16:11,920 --> 00:16:15,040
of boundary access

332
00:16:16,800 --> 00:16:19,040
it's easy to trigger the bug you can

333
00:16:19,040 --> 00:16:20,480
only

334
00:16:20,480 --> 00:16:22,880
need one layer of javascript with the

335
00:16:22,880 --> 00:16:24,480
code

336
00:16:24,480 --> 00:16:27,600
as shown on screen you can create an

337
00:16:27,600 --> 00:16:30,240
untapped array with the refresh dot

338
00:16:30,240 --> 00:16:31,920
construct

339
00:16:31,920 --> 00:16:35,120
to trigger the bug refresh dot construct

340
00:16:35,120 --> 00:16:38,160
we are called a token function create

341
00:16:38,160 --> 00:16:38,560
type

342
00:16:38,560 --> 00:16:41,199
array this function we are called a

343
00:16:41,199 --> 00:16:42,079
variable

344
00:16:42,079 --> 00:16:45,440
macro credit derived map

345
00:16:45,440 --> 00:16:47,839
because the new target argument is set

346
00:16:47,839 --> 00:16:49,279
to the proxy function

347
00:16:49,279 --> 00:16:52,480
so the obsess will be triggered

348
00:16:52,480 --> 00:16:55,600
but if the above javascript is wrong in

349
00:16:55,600 --> 00:16:58,079
chrome symphony nothing special will

350
00:16:58,079 --> 00:16:58,959
happen

351
00:16:58,959 --> 00:17:05,839
although the obsess has already occurred

352
00:17:06,000 --> 00:17:09,199
it is because that

353
00:17:09,199 --> 00:17:12,480
after loading proper prototype prototype

354
00:17:12,480 --> 00:17:14,480
or initial map

355
00:17:14,480 --> 00:17:17,679
the value will will be treated

356
00:17:17,679 --> 00:17:21,039
as a map is construct

357
00:17:21,039 --> 00:17:24,240
constructor is loaded and compared

358
00:17:24,240 --> 00:17:27,199
with a target

359
00:17:29,039 --> 00:17:31,760
and in most situation this value is an

360
00:17:31,760 --> 00:17:32,640
illegal map

361
00:17:32,640 --> 00:17:35,760
but its constructor is not the same as a

362
00:17:35,760 --> 00:17:36,720
target

363
00:17:36,720 --> 00:17:39,520
so execution flow your bare altitudes no

364
00:17:39,520 --> 00:17:41,360
pass

365
00:17:41,360 --> 00:17:44,320
everything is normal if revenue isn't a

366
00:17:44,320 --> 00:17:44,960
map

367
00:17:44,960 --> 00:17:47,120
execution flow your bare other tools no

368
00:17:47,120 --> 00:17:49,919
past two well it's fair to

369
00:17:49,919 --> 00:17:53,679
to be cast today to a map because of

370
00:17:53,679 --> 00:17:56,640
because there is no path we are will

371
00:17:56,640 --> 00:17:59,200
make all the assets use needs

372
00:17:59,200 --> 00:18:02,240
to exploit this bug

373
00:18:02,240 --> 00:18:05,600
the execution flow must return a map in

374
00:18:05,600 --> 00:18:08,240
fast pass

375
00:18:08,720 --> 00:18:11,679
so here is the exploit strategy of this

376
00:18:11,679 --> 00:18:12,720
park

377
00:18:12,720 --> 00:18:15,840
first we have to free the objects below

378
00:18:15,840 --> 00:18:16,720
the

379
00:18:16,720 --> 00:18:20,000
proxy function then we

380
00:18:20,000 --> 00:18:22,880
occupy the free space with an object

381
00:18:22,880 --> 00:18:24,640
with map

382
00:18:24,640 --> 00:18:28,000
whose maps the construct is unit at ua

383
00:18:28,000 --> 00:18:31,200
we need this map for x

384
00:18:31,200 --> 00:18:34,720
and then drop all reference to map x

385
00:18:34,720 --> 00:18:38,080
so the graphics connect will mark the

386
00:18:38,080 --> 00:18:42,240
map else and capture and we also sweep

387
00:18:42,240 --> 00:18:42,559
it

388
00:18:42,559 --> 00:18:46,880
in schedule the sweep task

389
00:18:46,880 --> 00:18:50,320
then we trigger the obs part before map

390
00:18:50,320 --> 00:18:50,960
x gets

391
00:18:50,960 --> 00:18:54,640
swept by gc so the developer

392
00:18:54,640 --> 00:18:57,840
creative map

393
00:19:04,960 --> 00:19:08,080
after sweep task finished we

394
00:19:08,080 --> 00:19:11,600
occupy the free space of

395
00:19:11,600 --> 00:19:14,799
map x with a map whose construct is

396
00:19:14,799 --> 00:19:18,080
you enter 32

397
00:19:18,080 --> 00:19:21,840
l.a so because a smartphone tablet array

398
00:19:21,840 --> 00:19:23,440
is marked if you enter

399
00:19:23,440 --> 00:19:26,080
32 anyway but there's no odds especially

400
00:19:26,080 --> 00:19:27,360
if the element hand

401
00:19:27,360 --> 00:19:31,360
is you enter at a later it's easy to

402
00:19:31,360 --> 00:19:33,840
implement optional read and write with

403
00:19:33,840 --> 00:19:34,880
this smartphone

404
00:19:34,880 --> 00:19:38,320
object with the ability of

405
00:19:38,320 --> 00:19:40,960
archery reader loads we can enable

406
00:19:40,960 --> 00:19:41,520
module

407
00:19:41,520 --> 00:19:44,000
js binding and exploit the following

408
00:19:44,000 --> 00:19:46,320
module variability to escape from chrome

409
00:19:46,320 --> 00:19:48,879
samples

410
00:19:51,200 --> 00:19:55,120
next i'm going to introduce the eop bug

411
00:19:55,120 --> 00:19:57,039
chrome use a multi-processed

412
00:19:57,039 --> 00:19:59,200
architecture it also needs

413
00:19:59,200 --> 00:20:01,520
render process from other privileged

414
00:20:01,520 --> 00:20:03,280
process

415
00:20:03,280 --> 00:20:06,960
and the pictures show the main process

416
00:20:06,960 --> 00:20:09,840
that runs the ui and manages types is

417
00:20:09,840 --> 00:20:11,520
called the broadcast

418
00:20:11,520 --> 00:20:15,280
process the gpu process is a process

419
00:20:15,280 --> 00:20:18,640
used when chrome is displaying

420
00:20:18,640 --> 00:20:22,000
tpu gpu accelerated content

421
00:20:22,000 --> 00:20:25,200
likewise the type of specific

422
00:20:25,200 --> 00:20:29,200
processes are called render processes

423
00:20:29,200 --> 00:20:32,159
normally render process has the noise

424
00:20:32,159 --> 00:20:33,679
the privilege

425
00:20:33,679 --> 00:20:36,720
the gpu process and the broader process

426
00:20:36,720 --> 00:20:40,159
have high probabilities random processes

427
00:20:40,159 --> 00:20:42,400
are highly standardized and main and

428
00:20:42,400 --> 00:20:45,360
many interaction between then and the

429
00:20:45,360 --> 00:20:48,080
system are processed by all the

430
00:20:48,080 --> 00:20:50,080
privileged process

431
00:20:50,080 --> 00:20:52,960
in android render process run the unit

432
00:20:52,960 --> 00:20:54,880
only associated app

433
00:20:54,880 --> 00:20:57,360
the gpu process and the broad process

434
00:20:57,360 --> 00:20:58,640
run in the domain

435
00:20:58,640 --> 00:21:01,760
on trusted app the rc park

436
00:21:01,760 --> 00:21:04,799
according to a random process while the

437
00:21:04,799 --> 00:21:06,240
eop

438
00:21:06,240 --> 00:21:09,280
occurred in the gpu process the

439
00:21:09,280 --> 00:21:12,799
communication between processes

440
00:21:12,799 --> 00:21:16,000
the vrpc there are two rpc systems in

441
00:21:16,000 --> 00:21:19,919
chrome network cmc and the module fc

442
00:21:19,919 --> 00:21:24,240
module is chrome's new ibc system

443
00:21:24,240 --> 00:21:26,320
the eop plug can be triggered by a

444
00:21:26,320 --> 00:21:29,120
module confirm render process

445
00:21:29,120 --> 00:21:32,880
is a url vulnerability in chrome's

446
00:21:32,880 --> 00:21:36,320
media component it is related with the

447
00:21:36,320 --> 00:21:40,000
interface of content decryption

448
00:21:40,000 --> 00:21:43,600
module this module and our chrome to

449
00:21:43,600 --> 00:21:46,400
play drm protected html file

450
00:21:46,400 --> 00:21:51,120
video and audio the idl format of the

451
00:21:51,120 --> 00:21:54,080
content decryption module is shown on

452
00:21:54,080 --> 00:21:55,919
the screen

453
00:21:55,919 --> 00:21:58,640
the function in night ring is

454
00:21:58,640 --> 00:21:59,600
responsible

455
00:21:59,600 --> 00:22:03,200
for initiating the ctm

456
00:22:03,200 --> 00:22:06,240
if it is narration succeed

457
00:22:06,240 --> 00:22:10,080
cdm ide will be no zero

458
00:22:10,080 --> 00:22:13,280
and we are later he used to locate

459
00:22:13,280 --> 00:22:17,360
the cm at the remote side

460
00:22:18,080 --> 00:22:21,360
the initial function is implemented in c

461
00:22:21,360 --> 00:22:26,960
plus plus if initialization succeeds the

462
00:22:26,960 --> 00:22:31,120
function on cdm created

463
00:22:31,120 --> 00:22:35,600
will be called this functional code

464
00:22:35,600 --> 00:22:37,679
the cost of the variability is that

465
00:22:37,679 --> 00:22:40,000
there is no restriction to

466
00:22:40,000 --> 00:22:42,799
the number of the cause of the function

467
00:22:42,799 --> 00:22:45,440
initial

468
00:22:46,559 --> 00:22:50,880
if this function is called twice by

469
00:22:50,880 --> 00:22:53,919
through module call in debug version

470
00:22:53,919 --> 00:22:56,640
this detector will be triggered

471
00:22:56,640 --> 00:22:59,679
and all cdm created

472
00:22:59,679 --> 00:23:04,799
will would it be called a twice two

473
00:23:05,039 --> 00:23:09,520
which without the same

474
00:23:09,520 --> 00:23:12,720
module stem service would be reduced

475
00:23:12,720 --> 00:23:18,080
to us in a function or cdn create

476
00:23:20,840 --> 00:23:22,159
created

477
00:23:22,159 --> 00:23:24,880
in the function we twisted the end two

478
00:23:24,880 --> 00:23:25,440
cdm

479
00:23:25,440 --> 00:23:28,720
ids will be mapped to the same

480
00:23:28,720 --> 00:23:33,440
module module stem service in nav4

481
00:23:33,440 --> 00:23:36,000
when module stem service was distributed

482
00:23:36,000 --> 00:23:36,480
only

483
00:23:36,480 --> 00:23:39,679
one cdm id was unregistered

484
00:23:39,679 --> 00:23:42,799
and removed from the map

485
00:23:42,799 --> 00:23:46,880
cdn services the other steam id was

486
00:23:46,880 --> 00:23:47,279
mapped

487
00:23:47,279 --> 00:23:51,039
to a dangling point

488
00:23:51,039 --> 00:23:53,760
after that if the function kills dm

489
00:23:53,760 --> 00:23:56,000
contest level code with

490
00:23:56,000 --> 00:23:59,360
a formation that's dmrd

491
00:23:59,360 --> 00:24:04,640
the uf would equally null 6. modus dm

492
00:24:04,640 --> 00:24:05,760
services

493
00:24:05,760 --> 00:24:08,320
can be configured to be run in different

494
00:24:08,320 --> 00:24:09,440
process

495
00:24:09,440 --> 00:24:12,400
it can be configured to run in the

496
00:24:12,400 --> 00:24:13,360
broader process

497
00:24:13,360 --> 00:24:16,480
the gpu process it also can be

498
00:24:16,480 --> 00:24:21,200
configured to run in utility process

499
00:24:21,200 --> 00:24:25,840
desk desktop chrome

500
00:24:25,840 --> 00:24:29,279
is a desktop chrome config

501
00:24:29,279 --> 00:24:33,760
configure um ctm service

502
00:24:33,760 --> 00:24:37,600
run in utility process

503
00:24:38,880 --> 00:24:41,760
utility process is a highly sandboxed

504
00:24:41,760 --> 00:24:42,159
just

505
00:24:42,159 --> 00:24:45,600
a render process so it can't be

506
00:24:45,600 --> 00:24:49,279
exploited to escape both in desktop

507
00:24:49,279 --> 00:24:50,240
chrome

508
00:24:50,240 --> 00:24:54,240
but anakin mojo stem source is

509
00:24:54,240 --> 00:24:57,600
configured to be run in the gpu process

510
00:24:57,600 --> 00:24:59,360
by defaulting android

511
00:24:59,360 --> 00:25:03,440
so we can exploit this part this bug to

512
00:25:03,440 --> 00:25:07,440
access the gpu drive directly

513
00:25:08,000 --> 00:25:12,159
the usf object is a module cm service

514
00:25:12,159 --> 00:25:16,360
itself is small it has only

515
00:25:16,360 --> 00:25:19,440
48 parts

516
00:25:19,440 --> 00:25:22,240
there is a lot of noise in the heap in

517
00:25:22,240 --> 00:25:24,320
this cell range

518
00:25:24,320 --> 00:25:26,720
so it's hard to be occupied through the

519
00:25:26,720 --> 00:25:28,640
modulus stem service objects will

520
00:25:28,640 --> 00:25:29,840
control the

521
00:25:29,840 --> 00:25:34,080
data now a member pointer

522
00:25:34,080 --> 00:25:37,440
point to a large object this type is a

523
00:25:37,440 --> 00:25:40,510
meteor drm bridge the cell is

524
00:25:40,510 --> 00:25:42,360
[Music]

525
00:25:42,360 --> 00:25:45,360
168

526
00:25:45,440 --> 00:25:49,640
bytes in debug version and

527
00:25:49,640 --> 00:25:52,880
160 but in relation

528
00:25:52,880 --> 00:25:56,000
her release version we can

529
00:25:56,000 --> 00:25:59,039
we occupy the memory of the free the

530
00:25:59,039 --> 00:26:02,240
media diamond bridge

531
00:26:04,559 --> 00:26:08,799
you'll use the control data

532
00:26:08,880 --> 00:26:12,720
so we can control its water table

533
00:26:12,720 --> 00:26:18,159
alright it is a water table

534
00:26:18,640 --> 00:26:21,440
with this snack we can use rp to finish

535
00:26:21,440 --> 00:26:21,760
the

536
00:26:21,760 --> 00:26:25,520
exploit because there is another problem

537
00:26:25,520 --> 00:26:28,720
we can't we can't allocate memories with

538
00:26:28,720 --> 00:26:29,039
no

539
00:26:29,039 --> 00:26:32,799
address in gpu process

540
00:26:32,799 --> 00:26:35,760
so we don't know where the water table

541
00:26:35,760 --> 00:26:36,480
coins

542
00:26:36,480 --> 00:26:40,320
can can be modified 2.2

543
00:26:40,320 --> 00:26:43,520
we need another information disclosure

544
00:26:43,520 --> 00:26:43,919
bug

545
00:26:43,919 --> 00:26:48,559
to fake a volume table with no edges

546
00:26:48,559 --> 00:26:52,480
then we can finish the exploiter group

547
00:26:52,480 --> 00:26:55,360
however it's not a good choice there is

548
00:26:55,360 --> 00:26:56,400
a

549
00:26:56,400 --> 00:26:59,679
simple simple solution as we know

550
00:26:59,679 --> 00:27:03,200
random process and the gpu process

551
00:27:03,200 --> 00:27:06,240
have the same memory layout in android

552
00:27:06,240 --> 00:27:09,679
they are focused from the same process

553
00:27:09,679 --> 00:27:12,960
so we know the best address of most

554
00:27:12,960 --> 00:27:16,240
shared library in gpu process the shield

555
00:27:16,240 --> 00:27:17,520
library

556
00:27:17,520 --> 00:27:20,960
new llvm geo next

557
00:27:20,960 --> 00:27:24,480
use as system function

558
00:27:26,320 --> 00:27:28,799
so there will be a system function point

559
00:27:28,799 --> 00:27:29,840
in

560
00:27:29,840 --> 00:27:33,120
in this child library after it's

561
00:27:33,120 --> 00:27:36,240
loaded now if we modify

562
00:27:36,240 --> 00:27:40,480
what your projectile pointer to point to

563
00:27:40,480 --> 00:27:44,000
near system function point

564
00:27:44,000 --> 00:27:46,320
when you have a clause the system

565
00:27:46,320 --> 00:27:48,000
function is called

566
00:27:48,000 --> 00:27:52,000
the argument is a controllable tool

567
00:27:52,000 --> 00:27:55,279
we can use this simple method

568
00:27:55,279 --> 00:27:58,480
we can use a simple method that we tend

569
00:27:58,480 --> 00:27:58,960
to leave

570
00:27:58,960 --> 00:28:02,480
c to execute any share command

571
00:28:02,480 --> 00:28:05,600
in gpu process so we

572
00:28:05,600 --> 00:28:09,600
escape from the chrome sandbox

573
00:28:13,440 --> 00:28:16,320
next i'm going to introduce the root

574
00:28:16,320 --> 00:28:19,120
vulnerability

575
00:28:20,080 --> 00:28:22,960
the google plus phone has an adreno gpu

576
00:28:22,960 --> 00:28:23,360
it's

577
00:28:23,360 --> 00:28:26,399
used ktsl driver developed by

578
00:28:26,399 --> 00:28:29,520
qualcomm the picture

579
00:28:29,520 --> 00:28:33,360
shows the architecture of kgsl driver

580
00:28:33,360 --> 00:28:36,480
apps can create adrenal context with

581
00:28:36,480 --> 00:28:37,200
different

582
00:28:37,200 --> 00:28:40,399
priorities normally there are four

583
00:28:40,399 --> 00:28:43,760
content context priorities

584
00:28:43,760 --> 00:28:47,600
0 1 2 and 3 0 denotes

585
00:28:47,600 --> 00:28:51,039
the highest priority and 3 denotes the

586
00:28:51,039 --> 00:28:54,080
noise the priority

587
00:28:54,080 --> 00:28:56,960
each adrenal context is bonded to a ring

588
00:28:56,960 --> 00:28:58,320
buffer

589
00:28:58,320 --> 00:29:00,880
depending on its priority because

590
00:29:00,880 --> 00:29:02,559
adrenal context have

591
00:29:02,559 --> 00:29:05,039
four priorities there are four ring

592
00:29:05,039 --> 00:29:06,000
buffers

593
00:29:06,000 --> 00:29:09,200
relatively there are rb0 rb2 of

594
00:29:09,200 --> 00:29:12,559
3 and r4 similar

595
00:29:12,559 --> 00:29:15,600
as cpu has different

596
00:29:15,600 --> 00:29:18,320
pre-regional gpu current in different

597
00:29:18,320 --> 00:29:19,919
mode

598
00:29:19,919 --> 00:29:23,520
adreno gpu can run in two more two modes

599
00:29:23,520 --> 00:29:26,320
primitive mode and unpredicted mode some

600
00:29:26,320 --> 00:29:27,279
pages and

601
00:29:27,279 --> 00:29:31,039
register can only be accessed

602
00:29:31,039 --> 00:29:34,159
or modified in privileged mode

603
00:29:34,159 --> 00:29:37,600
after an app creates an

604
00:29:37,600 --> 00:29:41,600
arduino context the app can send the gpu

605
00:29:41,600 --> 00:29:42,159
command

606
00:29:42,159 --> 00:29:46,159
to the context by our control

607
00:29:46,159 --> 00:29:50,720
each context has a command q

608
00:29:51,120 --> 00:29:54,960
they receive the gpu command are killed

609
00:29:54,960 --> 00:29:58,640
the dispatcher is the core

610
00:29:58,640 --> 00:30:02,559
module in ktsl

611
00:30:03,279 --> 00:30:06,559
it stands in a

612
00:30:07,279 --> 00:30:11,360
separate separate kernel thread

613
00:30:11,360 --> 00:30:14,320
the google pixel phone has an adreno gpu

614
00:30:14,320 --> 00:30:16,880
it's used the ktsl driver developed by

615
00:30:16,880 --> 00:30:19,760
qualcomm the picture shows the

616
00:30:19,760 --> 00:30:23,200
architecture of ktsl java

617
00:30:23,200 --> 00:30:27,200
apps create apps can create adrenal

618
00:30:27,200 --> 00:30:32,080
content context with different

619
00:30:34,840 --> 00:30:37,840
priorities

620
00:30:57,919 --> 00:31:05,840
all right

621
00:31:08,799 --> 00:31:11,360
the pix

622
00:31:12,240 --> 00:31:15,600
the google pixel phone has a adrenal gpu

623
00:31:15,600 --> 00:31:19,120
it uses the ktsl driver developed by

624
00:31:19,120 --> 00:31:21,360
qualcomm the picture shows the

625
00:31:21,360 --> 00:31:22,480
architecture of

626
00:31:22,480 --> 00:31:26,159
the kgs driver apps can create

627
00:31:26,159 --> 00:31:28,159
adrenal contacts with different

628
00:31:28,159 --> 00:31:31,840
priorities normally there are four

629
00:31:31,840 --> 00:31:35,440
properties 0 1 2 and 3 0 denotes the

630
00:31:35,440 --> 00:31:36,799
highest priority and

631
00:31:36,799 --> 00:31:39,440
read loads the noise priority each

632
00:31:39,440 --> 00:31:41,679
adrenal context is bonded

633
00:31:41,679 --> 00:31:45,039
it bonded to a ring buffer

634
00:31:45,039 --> 00:31:48,559
depending on its priority

635
00:31:48,559 --> 00:31:50,799
because adrenal contacts have four

636
00:31:50,799 --> 00:31:51,840
priorities

637
00:31:51,840 --> 00:31:55,279
there are four ring buffer win buffers

638
00:31:55,279 --> 00:31:58,559
relatively 0 rb1

639
00:31:58,559 --> 00:32:02,960
r2 and rb3 similar and cpu has different

640
00:32:02,960 --> 00:32:06,000
priority level gpu can

641
00:32:06,000 --> 00:32:09,360
run in different mode

642
00:32:09,519 --> 00:32:13,440
arduino gpu can run in two modes

643
00:32:13,440 --> 00:32:16,640
the mode and unprivileged mode some

644
00:32:16,640 --> 00:32:17,679
pages and

645
00:32:17,679 --> 00:32:21,279
registers can only be accessed and

646
00:32:21,279 --> 00:32:25,279
modified in privileged mode after a map

647
00:32:25,279 --> 00:32:28,799
created create an

648
00:32:28,799 --> 00:32:32,000
arduino context the app can send the gpu

649
00:32:32,000 --> 00:32:32,960
command to the

650
00:32:32,960 --> 00:32:36,640
context by our control each context has

651
00:32:36,640 --> 00:32:37,200
a

652
00:32:37,200 --> 00:32:40,240
mod queue the received gpu command are

653
00:32:40,240 --> 00:32:43,519
queued the dispatch is the core model in

654
00:32:43,519 --> 00:32:47,279
ktsl it runs in a separate

655
00:32:47,279 --> 00:32:51,200
cloud thread and keeps reading commands

656
00:32:51,200 --> 00:32:52,399
from the queue and

657
00:32:52,399 --> 00:32:55,200
submit sub submitting them to win

658
00:32:55,200 --> 00:32:56,399
bubbles

659
00:32:56,399 --> 00:32:58,880
after commands are submitting to a rim

660
00:32:58,880 --> 00:33:00,159
buffer the

661
00:33:00,159 --> 00:33:04,880
red point of the ring buffer is updated

662
00:33:04,880 --> 00:33:08,960
now the gpu executes some

663
00:33:08,960 --> 00:33:12,640
commands the reader point is updated by

664
00:33:12,640 --> 00:33:16,799
gpu every context

665
00:33:16,799 --> 00:33:19,919
use different page tables but some pages

666
00:33:19,919 --> 00:33:24,880
are mapped globally to all contexts

667
00:33:24,880 --> 00:33:27,440
contest

668
00:33:30,720 --> 00:33:33,919
this list shows all globally mapped

669
00:33:33,919 --> 00:33:36,960
pages in pizza form note that

670
00:33:36,960 --> 00:33:40,320
scratch in that file is a globally

671
00:33:40,320 --> 00:33:41,279
mapped page and

672
00:33:41,279 --> 00:33:44,960
we will exploit it later some pages in

673
00:33:44,960 --> 00:33:45,600
this list

674
00:33:45,600 --> 00:33:48,720
are not only mapped by gpu but also

675
00:33:48,720 --> 00:33:52,080
can be modified by cpu scratches above

676
00:33:52,080 --> 00:33:55,120
this kind of page

677
00:33:55,679 --> 00:33:58,799
the scratch memory is a it is one page

678
00:33:58,799 --> 00:34:01,600
data that is mapped into the gpu

679
00:34:01,600 --> 00:34:04,159
this can offer some shared data between

680
00:34:04,159 --> 00:34:04,799
gpu and

681
00:34:04,799 --> 00:34:07,919
cpu for example it will be used by the

682
00:34:07,919 --> 00:34:09,599
gpu to

683
00:34:09,599 --> 00:34:12,639
right update the read point for each

684
00:34:12,639 --> 00:34:13,599
member

685
00:34:13,599 --> 00:34:17,359
the format of the scratch is showing

686
00:34:17,359 --> 00:34:20,719
this table the fourth six

687
00:34:20,719 --> 00:34:23,760
sixteen parts are the middle point of

688
00:34:23,760 --> 00:34:25,199
the

689
00:34:25,199 --> 00:34:28,239
four ring buffers

690
00:34:29,520 --> 00:34:33,599
and therefore information the real point

691
00:34:33,599 --> 00:34:36,639
of rim buffers are stored in scratch

692
00:34:36,639 --> 00:34:39,280
scratch memory the scratch memory is

693
00:34:39,280 --> 00:34:41,040
mapped in gpu space and

694
00:34:41,040 --> 00:34:44,960
cpu space reader pointer

695
00:34:44,960 --> 00:34:48,079
since read point of sensitive

696
00:34:48,079 --> 00:34:51,918
data for ktsl driver the

697
00:34:51,918 --> 00:34:55,520
travel read reads read points

698
00:34:55,520 --> 00:34:59,280
when allocate buffer from ring bubbles

699
00:34:59,280 --> 00:35:01,599
but this scratch memory is running set

700
00:35:01,599 --> 00:35:03,280
to drag table

701
00:35:03,280 --> 00:35:05,920
by normal gpu command processor

702
00:35:05,920 --> 00:35:07,040
instructions

703
00:35:07,040 --> 00:35:10,960
in this function

704
00:35:10,960 --> 00:35:16,400
in this noun the function ktsl allocator

705
00:35:16,400 --> 00:35:18,800
globe

706
00:35:20,720 --> 00:35:24,079
allocate a global memory without read

707
00:35:24,079 --> 00:35:24,560
only

708
00:35:24,560 --> 00:35:28,160
and privilege the flag

709
00:35:29,440 --> 00:35:32,640
so rptr's can be modified by gpu command

710
00:35:32,640 --> 00:35:35,280
processor

711
00:35:35,280 --> 00:35:39,040
by gpu command processor instructions

712
00:35:39,040 --> 00:35:45,359
in on privilege mode

713
00:35:45,359 --> 00:35:48,640
in a function in a functioning arduino

714
00:35:48,640 --> 00:35:52,320
invert for a local space the variable

715
00:35:52,320 --> 00:35:55,440
iptr is

716
00:35:55,520 --> 00:36:00,000
the variable rptr in nav5

717
00:36:00,000 --> 00:36:02,720
is a reader from their scratch memory an

718
00:36:02,720 --> 00:36:05,680
rptr can be modified to any value

719
00:36:05,680 --> 00:36:08,880
the function can be conjured to return a

720
00:36:08,880 --> 00:36:09,520
wrong

721
00:36:09,520 --> 00:36:13,839
ring buffer point

722
00:36:16,320 --> 00:36:18,720
as with that we can override the eagle

723
00:36:18,720 --> 00:36:20,320
these command process

724
00:36:20,320 --> 00:36:23,440
instructions and inject initial command

725
00:36:23,440 --> 00:36:24,160
processing

726
00:36:24,160 --> 00:36:28,000
instructions into ring upper to execute

727
00:36:28,000 --> 00:36:31,599
so how to exploit this file there are

728
00:36:31,599 --> 00:36:34,240
few public documents about the internal

729
00:36:34,240 --> 00:36:35,200
architecture of

730
00:36:35,200 --> 00:36:38,800
arduino gpu you can only speculate some

731
00:36:38,800 --> 00:36:42,640
internal behaviors of the gpu

732
00:36:42,640 --> 00:36:46,240
rpts in the scratch memory are updated

733
00:36:46,240 --> 00:36:47,920
by the gpu

734
00:36:47,920 --> 00:36:50,720
but in the sense that there are there

735
00:36:50,720 --> 00:36:51,520
are just

736
00:36:51,520 --> 00:36:55,839
shadows of read point used by the gpu to

737
00:36:55,839 --> 00:36:59,040
fetch instructions modifying the

738
00:36:59,040 --> 00:37:02,400
rptr in the scratching memory don't

739
00:37:02,400 --> 00:37:05,440
affect the effects of the execution flow

740
00:37:05,440 --> 00:37:06,960
of the gpu

741
00:37:06,960 --> 00:37:11,040
knocking it affects the canal allocation

742
00:37:11,040 --> 00:37:14,400
space for rim buffers

743
00:37:15,760 --> 00:37:19,040
rptr points to the next instruction

744
00:37:19,040 --> 00:37:22,240
which will be executed by

745
00:37:22,240 --> 00:37:27,520
the gpu and the wp2

746
00:37:27,520 --> 00:37:30,240
red point and the other point point to

747
00:37:30,240 --> 00:37:31,040
the

748
00:37:31,040 --> 00:37:35,200
start of a free space of a

749
00:37:35,200 --> 00:37:38,400
bubble there are two scenarios

750
00:37:38,400 --> 00:37:40,880
of the positioning of reader peter and

751
00:37:40,880 --> 00:37:43,440
the red media

752
00:37:43,440 --> 00:37:46,880
with a picture less than

753
00:37:47,040 --> 00:37:50,320
less than or equal radication or reader

754
00:37:50,320 --> 00:37:52,079
picture

755
00:37:52,079 --> 00:37:56,079
not than not peter

756
00:37:58,880 --> 00:38:02,079
when real point is less than or equal

757
00:38:02,079 --> 00:38:06,160
to red point if there is enough step

758
00:38:06,160 --> 00:38:08,720
enough space from right point to the end

759
00:38:08,720 --> 00:38:10,000
of the

760
00:38:10,000 --> 00:38:13,119
ring bubble allocating is simple we just

761
00:38:13,119 --> 00:38:16,079
need to advance red point and retain the

762
00:38:16,079 --> 00:38:17,119
original

763
00:38:17,119 --> 00:38:20,240
blood point if there isn't enough space

764
00:38:20,240 --> 00:38:22,800
towards the end of the ring buffer you

765
00:38:22,800 --> 00:38:23,520
have to look

766
00:38:23,520 --> 00:38:26,640
for space from the beginning of the

767
00:38:26,640 --> 00:38:33,440
ring buffer up to the read point

768
00:38:33,440 --> 00:38:36,800
if there is enough space advance a

769
00:38:36,800 --> 00:38:40,640
red point from the beginning of

770
00:38:40,640 --> 00:38:42,560
it advance the red point from the

771
00:38:42,560 --> 00:38:44,160
beginning of the

772
00:38:44,160 --> 00:38:47,280
window otherwise the allocation will

773
00:38:47,280 --> 00:38:51,040
fail when windpoint is not on

774
00:38:51,040 --> 00:38:53,920
red point if there is enough space from

775
00:38:53,920 --> 00:38:55,040
red point

776
00:38:55,040 --> 00:38:58,160
to midpoint we just need to advance the

777
00:38:58,160 --> 00:39:00,800
red point and return the original red

778
00:39:00,800 --> 00:39:02,079
point

779
00:39:02,079 --> 00:39:06,800
otherwise their allocation will fail

780
00:39:08,880 --> 00:39:12,560
midpoints in scratch alpha can be set to

781
00:39:12,560 --> 00:39:14,240
any value

782
00:39:14,240 --> 00:39:17,040
by normal gpu installation because of

783
00:39:17,040 --> 00:39:17,839
the

784
00:39:17,839 --> 00:39:22,240
bug so we can follow the allocation

785
00:39:22,240 --> 00:39:25,839
function as shown on screen

786
00:39:25,839 --> 00:39:29,440
assume that after gpu executing some

787
00:39:29,440 --> 00:39:33,119
instructions rptr is less than

788
00:39:33,119 --> 00:39:37,240
less than wptr a request of

789
00:39:37,240 --> 00:39:41,280
locating a knowledge space will be

790
00:39:41,280 --> 00:39:44,160
is issued because of the space at the

791
00:39:44,160 --> 00:39:45,440
beginning

792
00:39:45,440 --> 00:39:48,720
and the end is small the request

793
00:39:48,720 --> 00:39:52,560
will fail if we modify rtr in scratch

794
00:39:52,560 --> 00:39:53,359
memory

795
00:39:53,359 --> 00:39:56,560
for example advanced is near

796
00:39:56,560 --> 00:39:59,359
wptr

797
00:40:01,760 --> 00:40:05,440
then some space will only mark as free

798
00:40:05,440 --> 00:40:08,839
as this moment if another request of

799
00:40:08,839 --> 00:40:12,000
allocating energy space from rim buffer

800
00:40:12,000 --> 00:40:13,040
is issued

801
00:40:13,040 --> 00:40:16,319
it's real succeed but some existing

802
00:40:16,319 --> 00:40:17,920
command processor

803
00:40:17,920 --> 00:40:21,599
instructions will be overwritten

804
00:40:21,599 --> 00:40:24,880
the the adrenal gpu will execute the

805
00:40:24,880 --> 00:40:27,359
instructions still from the

806
00:40:27,359 --> 00:40:32,800
the original rptr without reducing the

807
00:40:32,800 --> 00:40:35,839
without him executing on another

808
00:40:35,839 --> 00:40:37,440
instructions

809
00:40:37,440 --> 00:40:40,560
it means executing from the middle of

810
00:40:40,560 --> 00:40:43,839
uh instrumentation choose some

811
00:40:43,839 --> 00:40:46,880
data of the instructions or code

812
00:40:46,880 --> 00:40:49,119
so it's possible to inject arbitrary

813
00:40:49,119 --> 00:40:50,480
command process

814
00:40:50,480 --> 00:40:54,000
instructions into rainbow for a week

815
00:40:54,000 --> 00:40:57,040
large optical data to ring buffer

816
00:40:57,040 --> 00:40:59,839
when gpu instructions are dispatched to

817
00:40:59,839 --> 00:41:01,920
rim buffer

818
00:41:01,920 --> 00:41:04,240
cp indirect buffer prefetcher

819
00:41:04,240 --> 00:41:05,119
instructions

820
00:41:05,119 --> 00:41:08,480
are inserted into ring buffer by ktsa

821
00:41:08,480 --> 00:41:09,680
driver

822
00:41:09,680 --> 00:41:12,960
gpu instructions provided in euler mode

823
00:41:12,960 --> 00:41:16,319
are in into the bubbles

824
00:41:16,319 --> 00:41:19,119
they are not copied into green buffer

825
00:41:19,119 --> 00:41:20,560
directory

826
00:41:20,560 --> 00:41:22,880
the execution flow will jump to

827
00:41:22,880 --> 00:41:24,960
integrate buffer when

828
00:41:24,960 --> 00:41:26,880
cp indirect buffer prefetching

829
00:41:26,880 --> 00:41:29,119
instruction is executed

830
00:41:29,119 --> 00:41:31,280
it's difficult to write arbitrary code

831
00:41:31,280 --> 00:41:32,560
into rimba

832
00:41:32,560 --> 00:41:35,119
narcany we found another party in user

833
00:41:35,119 --> 00:41:36,720
profiling command

834
00:41:36,720 --> 00:41:39,359
user profiling command is used to read

835
00:41:39,359 --> 00:41:41,760
the gpu tickets at the

836
00:41:41,760 --> 00:41:49,839
ancestor and the end of gpu command

837
00:41:52,319 --> 00:41:55,440
the gpu address of the profiling buffer

838
00:41:55,440 --> 00:41:57,520
is accountable by user mode and

839
00:41:57,520 --> 00:42:00,480
can be set to any manual gpu address is

840
00:42:00,480 --> 00:42:00,720
a

841
00:42:00,720 --> 00:42:03,760
8 parts it's enough to write a

842
00:42:03,760 --> 00:42:06,640
cp knob or cv cell protection mode and

843
00:42:06,640 --> 00:42:07,920
charge into it

844
00:42:07,920 --> 00:42:11,440
as shown in the picture it's

845
00:42:11,440 --> 00:42:14,240
it's a cp instruction sequence of

846
00:42:14,240 --> 00:42:15,200
executing

847
00:42:15,200 --> 00:42:19,280
our control ktso tpu command

848
00:42:19,280 --> 00:42:21,280
cp introduced buffer professional

849
00:42:21,280 --> 00:42:22,560
instructions

850
00:42:22,560 --> 00:42:25,280
instructions are loved by other

851
00:42:25,280 --> 00:42:26,160
instruction

852
00:42:26,160 --> 00:42:29,119
instructions such as instructions to

853
00:42:29,119 --> 00:42:30,720
enable and disable

854
00:42:30,720 --> 00:42:33,599
protected mode instructions to start and

855
00:42:33,599 --> 00:42:34,000
end

856
00:42:34,000 --> 00:42:37,280
user profiling if protest mode is

857
00:42:37,280 --> 00:42:38,480
disabled

858
00:42:38,480 --> 00:42:42,400
gpu runs in privileged mode

859
00:42:42,400 --> 00:42:45,599
many privileged registers

860
00:42:45,599 --> 00:42:50,240
can be modified protected module

861
00:42:50,240 --> 00:42:53,599
can only be disabled by cp instructions

862
00:42:53,599 --> 00:42:56,480
which is runs in rim buffer cp

863
00:42:56,480 --> 00:42:57,680
instructions

864
00:42:57,680 --> 00:43:00,720
executed in each directory buffer have

865
00:43:00,720 --> 00:43:02,480
low permission to

866
00:43:02,480 --> 00:43:06,079
disable protection mode

867
00:43:07,760 --> 00:43:10,800
as mentioned before we can execute a cp

868
00:43:10,800 --> 00:43:13,040
instruction from its middle

869
00:43:13,040 --> 00:43:16,240
so we can exploit the bug as shown in

870
00:43:16,240 --> 00:43:17,520
the picture

871
00:43:17,520 --> 00:43:21,119
before we trigger the bug the layout of

872
00:43:21,119 --> 00:43:27,839
a ring buffer is shown on the left

873
00:43:28,560 --> 00:43:31,200
the first the cp indirect buffer

874
00:43:31,200 --> 00:43:32,560
prefetcher

875
00:43:32,560 --> 00:43:35,680
will jump to uh into the buffer

876
00:43:35,680 --> 00:43:38,640
in this buckle there is a cp with

877
00:43:38,640 --> 00:43:39,440
regular

878
00:43:39,440 --> 00:43:42,560
is junction which will wait until the

879
00:43:42,560 --> 00:43:44,079
venue in a specific

880
00:43:44,079 --> 00:43:47,280
gpu address to become a specific

881
00:43:47,280 --> 00:43:50,000
value at this moment i assume the

882
00:43:50,000 --> 00:43:52,240
condition is not satisfied

883
00:43:52,240 --> 00:43:55,680
so read the pointer the reader point of

884
00:43:55,680 --> 00:43:57,040
view

885
00:43:57,040 --> 00:44:00,720
point to the next

886
00:44:00,720 --> 00:44:05,440
cp induced buffer prefecture instruction

887
00:44:05,440 --> 00:44:08,880
then we trigger the power in

888
00:44:10,160 --> 00:44:12,400
about in the highest priority contact

889
00:44:12,400 --> 00:44:14,079
context

890
00:44:14,079 --> 00:44:17,280
so we can preempt

891
00:44:17,280 --> 00:44:20,400
the weight instruction to

892
00:44:20,400 --> 00:44:23,520
modify feeder pointer

893
00:44:23,520 --> 00:44:28,079
near to to near wptr

894
00:44:28,319 --> 00:44:32,079
which distills the gpu kernel

895
00:44:32,079 --> 00:44:36,319
gpu cannot drive into think

896
00:44:36,319 --> 00:44:39,359
the space before with the pointer

897
00:44:39,359 --> 00:44:43,040
is all free then we

898
00:44:43,040 --> 00:44:48,240
execute our control kt seo gpu command

899
00:44:48,240 --> 00:44:51,760
two times to override the ring buffer

900
00:44:51,760 --> 00:44:55,280
as shown in the middle the gpu address

901
00:44:55,280 --> 00:44:55,599
of

902
00:44:55,599 --> 00:44:58,079
the second and the fourth user profiling

903
00:44:58,079 --> 00:44:59,680
command

904
00:44:59,680 --> 00:45:03,040
are carefully designed as a cp

905
00:45:03,040 --> 00:45:06,720
nope instruction and a cp protected

906
00:45:06,720 --> 00:45:09,440
model is charging if the weight

907
00:45:09,440 --> 00:45:10,880
condition is satisfied

908
00:45:10,880 --> 00:45:14,000
at this moment after execute executing

909
00:45:14,000 --> 00:45:17,040
some refreshed instructions

910
00:45:17,040 --> 00:45:20,240
cpu knob instruction will be executed as

911
00:45:20,240 --> 00:45:23,200
shown on the right

912
00:45:23,280 --> 00:45:26,640
cpu no instruction will unlock all the

913
00:45:26,640 --> 00:45:30,960
instructions until the cp says protected

914
00:45:30,960 --> 00:45:33,839
mode

915
00:45:38,400 --> 00:45:40,880
the cpu says the protection instruction

916
00:45:40,880 --> 00:45:43,839
via disable protective mode

917
00:45:43,839 --> 00:45:47,680
so the cpu induced buffer professional

918
00:45:47,680 --> 00:45:49,680
instruction will jump to

919
00:45:49,680 --> 00:45:52,800
it deals a buffer with protect will

920
00:45:52,800 --> 00:45:55,680
protest off

921
00:45:57,520 --> 00:46:01,839
with protector off

922
00:46:04,400 --> 00:46:07,760
now we can change ttpr

923
00:46:07,760 --> 00:46:11,280
to any value by instructions in

924
00:46:11,280 --> 00:46:14,160
individual buffer is a powerful

925
00:46:14,160 --> 00:46:15,440
primitive

926
00:46:15,440 --> 00:46:18,079
we can exploit to read a lot of

927
00:46:18,079 --> 00:46:20,160
arbitrary

928
00:46:20,160 --> 00:46:23,520
physical memory including core segments

929
00:46:23,520 --> 00:46:24,319
in kernel

930
00:46:24,319 --> 00:46:27,839
is easy to improve

931
00:46:27,839 --> 00:46:30,800
together archery cannot call the

932
00:46:30,800 --> 00:46:33,440
execution

933
00:46:33,599 --> 00:46:35,839
at the end of my presentation let me

934
00:46:35,839 --> 00:46:37,520
show you a demo of the

935
00:46:37,520 --> 00:46:43,520
huawei blood chain

936
00:46:43,520 --> 00:46:46,240
first we launch a web server in the

937
00:46:46,240 --> 00:46:46,960
attack's

938
00:46:46,960 --> 00:46:50,720
computer then the victim form

939
00:46:50,720 --> 00:46:54,640
accesses the monitor's link because in

940
00:46:54,640 --> 00:46:58,400
a reverse shield will be

941
00:46:58,400 --> 00:47:11,760
established please wait for a moment

942
00:47:11,760 --> 00:47:16,560
okay we get a reward still

943
00:47:18,240 --> 00:47:21,760
then the target can execute

944
00:47:21,760 --> 00:47:24,800
the downloaded binary file to exploit

945
00:47:24,800 --> 00:47:25,440
the

946
00:47:25,440 --> 00:47:30,079
total variability to get a load share

947
00:47:30,079 --> 00:47:35,119
we run the root exploit

948
00:47:35,119 --> 00:47:40,079
you can see we have loot commission

949
00:47:41,520 --> 00:47:47,119
and the uh this is disabled

950
00:47:48,800 --> 00:47:50,800
i show the conclusion in this

951
00:47:50,800 --> 00:47:52,160
presentation i

952
00:47:52,160 --> 00:47:54,800
first explained why google pixel phone

953
00:47:54,800 --> 00:47:56,000
is one of the most

954
00:47:56,000 --> 00:47:59,040
secure smartphones then i

955
00:47:59,040 --> 00:48:01,920
introduced the remote telesource of

956
00:48:01,920 --> 00:48:02,800
android

957
00:48:02,800 --> 00:48:05,839
phone and the sixth android express

958
00:48:05,839 --> 00:48:06,240
chain

959
00:48:06,240 --> 00:48:10,319
funded by me over three years after that

960
00:48:10,319 --> 00:48:13,280
we overviewed the express chain which

961
00:48:13,280 --> 00:48:13,680
can

962
00:48:13,680 --> 00:48:16,079
importantly do to the modern android

963
00:48:16,079 --> 00:48:18,880
devices include google plus phones

964
00:48:18,880 --> 00:48:22,319
as not detailed three vulnerabilities

965
00:48:22,319 --> 00:48:26,800
in the chain and how i exploit them

966
00:48:26,800 --> 00:48:30,160
okay that's all for my talk thanks for

967
00:48:30,160 --> 00:48:31,359
your listening

968
00:48:31,359 --> 00:48:35,359
any questions

969
00:48:35,359 --> 00:48:49,839
okay hello

970
00:48:53,680 --> 00:48:56,400
okay thank you everyone for your

971
00:48:56,400 --> 00:48:57,760
listening for my

972
00:48:57,760 --> 00:49:00,319
talk if you have any questions you can

973
00:49:00,319 --> 00:49:00,960
contact

974
00:49:00,960 --> 00:49:04,400
contact me online

975
00:49:04,400 --> 00:49:08,000
and i will be very

976
00:49:08,000 --> 00:49:12,720
happy to answer that

