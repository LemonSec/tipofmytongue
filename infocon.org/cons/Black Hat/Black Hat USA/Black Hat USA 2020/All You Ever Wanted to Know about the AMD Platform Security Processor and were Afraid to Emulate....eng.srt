1
00:00:01,180 --> 00:00:12,960
[Music]

2
00:00:12,960 --> 00:00:15,200
okay welcome to our talk all you ever

3
00:00:15,200 --> 00:00:16,960
wanted to know about the amd platform

4
00:00:16,960 --> 00:00:18,800
security processor and we're afraid to

5
00:00:18,800 --> 00:00:20,640
emulate in this talk we present

6
00:00:20,640 --> 00:00:24,720
pcbmu an emulator for the amd psp

7
00:00:24,720 --> 00:00:26,960
so this is alex here and i'm robert and

8
00:00:26,960 --> 00:00:29,279
alex is doing his master thesis

9
00:00:29,279 --> 00:00:31,359
at the technical universitat in berlin

10
00:00:31,359 --> 00:00:35,360
and i'm his supervising phd student

11
00:00:35,360 --> 00:00:38,239
today i'm going to talk about the

12
00:00:38,239 --> 00:00:40,079
platform security processor

13
00:00:40,079 --> 00:00:42,879
and what it's used for and why we would

14
00:00:42,879 --> 00:00:44,079
want to emulate it

15
00:00:44,079 --> 00:00:46,239
and then alex will tell you about how we

16
00:00:46,239 --> 00:00:48,000
emulated the psp

17
00:00:48,000 --> 00:00:51,280
and what you can do with the emulator

18
00:00:51,280 --> 00:00:54,320
so let's start with a brief overview on

19
00:00:54,320 --> 00:00:56,239
the amd psp

20
00:00:56,239 --> 00:00:59,280
so this is a slide i've took from

21
00:00:59,280 --> 00:01:02,559
an amd slide deck and amd says here that

22
00:01:02,559 --> 00:01:04,720
the amd secure processor is an

23
00:01:04,720 --> 00:01:06,400
integrated microcontroller

24
00:01:06,400 --> 00:01:09,920
integrated into the x86 slc

25
00:01:09,920 --> 00:01:12,720
there's an arm cortex f5 and it's

26
00:01:12,720 --> 00:01:13,680
present on

27
00:01:13,680 --> 00:01:17,520
both epic and ryzen cpus

28
00:01:17,520 --> 00:01:19,640
actually it has been integrated since

29
00:01:19,640 --> 00:01:21,119
2013

30
00:01:21,119 --> 00:01:23,680
but for our chalk we only concentrate on

31
00:01:23,680 --> 00:01:25,040
the psp

32
00:01:25,040 --> 00:01:29,200
of zen and later generation of amd cpus

33
00:01:29,200 --> 00:01:30,799
so it runs an undocumented and

34
00:01:30,799 --> 00:01:33,520
proprietary firmware provided by amd

35
00:01:33,520 --> 00:01:36,000
and the psp is the root of trust for the

36
00:01:36,000 --> 00:01:37,360
whole

37
00:01:37,360 --> 00:01:40,640
x86 slc

38
00:01:40,640 --> 00:01:42,479
so why would we want to emulate this

39
00:01:42,479 --> 00:01:44,000
device well

40
00:01:44,000 --> 00:01:45,920
it runs privileged software at a very

41
00:01:45,920 --> 00:01:47,200
high privilege level

42
00:01:47,200 --> 00:01:49,840
it is the root of trust and we can

43
00:01:49,840 --> 00:01:52,320
analystically analyze its firmware

44
00:01:52,320 --> 00:01:55,680
but that is time consuming and from my

45
00:01:55,680 --> 00:01:57,520
point of view also a bit boring

46
00:01:57,520 --> 00:01:59,680
and it's only good for a single firmware

47
00:01:59,680 --> 00:02:01,920
version if at one point in time amd

48
00:02:01,920 --> 00:02:03,439
decides to

49
00:02:03,439 --> 00:02:05,680
completely rewrite their embedded

50
00:02:05,680 --> 00:02:07,600
firmware code for the psp

51
00:02:07,600 --> 00:02:10,080
we would have to start over again and

52
00:02:10,080 --> 00:02:11,760
analyze the binaries

53
00:02:11,760 --> 00:02:13,920
however if we would be able to emulate

54
00:02:13,920 --> 00:02:15,599
the psp itself

55
00:02:15,599 --> 00:02:18,160
we could just execute the emulator with

56
00:02:18,160 --> 00:02:19,360
the new firmware

57
00:02:19,360 --> 00:02:22,080
and analyze it at runtime which is way

58
00:02:22,080 --> 00:02:25,200
easier than plain static analysis

59
00:02:25,200 --> 00:02:28,239
now before we start emulate writing the

60
00:02:28,239 --> 00:02:29,520
emulator we need to have

61
00:02:29,520 --> 00:02:33,040
the firmware and the amd psp framework

62
00:02:33,040 --> 00:02:35,280
can be found within the padding

63
00:02:35,280 --> 00:02:38,080
of uefi images so if you download a new

64
00:02:38,080 --> 00:02:40,239
image update for a motherboard

65
00:02:40,239 --> 00:02:42,480
you will find a padding section and

66
00:02:42,480 --> 00:02:43,920
within that padding section

67
00:02:43,920 --> 00:02:46,319
you will find the psp firmware code and

68
00:02:46,319 --> 00:02:47,040
the psp

69
00:02:47,040 --> 00:02:50,160
has its own file system

70
00:02:50,160 --> 00:02:52,879
and we wrote a tool called psp tool

71
00:02:52,879 --> 00:02:54,400
which you can use to

72
00:02:54,400 --> 00:02:56,879
dump the content of that file system i'm

73
00:02:56,879 --> 00:02:58,800
not going to go into details about this

74
00:02:58,800 --> 00:02:59,920
file system

75
00:02:59,920 --> 00:03:02,959
during this talk but you can have a look

76
00:03:02,959 --> 00:03:04,879
at our previous talk which we have given

77
00:03:04,879 --> 00:03:06,879
at the cares communication congress

78
00:03:06,879 --> 00:03:10,080
back in 2019 where we explain more about

79
00:03:10,080 --> 00:03:11,840
the firmware file system structure

80
00:03:11,840 --> 00:03:13,360
and a little bit of background of the

81
00:03:13,360 --> 00:03:15,280
psp

82
00:03:15,280 --> 00:03:18,000
today i'm going to talk again about how

83
00:03:18,000 --> 00:03:19,360
the pcp

84
00:03:19,360 --> 00:03:22,400
boot process is working as i said the

85
00:03:22,400 --> 00:03:24,959
psp is the root of trust for the amd

86
00:03:24,959 --> 00:03:28,560
soc so the psp actually boots before

87
00:03:28,560 --> 00:03:31,840
the x86 course and on the psp there is a

88
00:03:31,840 --> 00:03:34,080
component called the on-chip bootloader

89
00:03:34,080 --> 00:03:36,799
which is the first component which boots

90
00:03:36,799 --> 00:03:38,560
and the on-chip bootloader

91
00:03:38,560 --> 00:03:41,599
is an bootloader which is embedded in

92
00:03:41,599 --> 00:03:44,319
read-only rom memory now the

93
00:03:44,319 --> 00:03:46,000
responsibilities of this onshore

94
00:03:46,000 --> 00:03:47,440
bootloader are to

95
00:03:47,440 --> 00:03:50,640
load and verify an off-chip bootloader

96
00:03:50,640 --> 00:03:53,760
which is stored on the sbi flash

97
00:03:53,760 --> 00:03:56,720
now if the binary of the offshore

98
00:03:56,720 --> 00:03:58,400
bootloader could be verified using a

99
00:03:58,400 --> 00:03:59,439
public key

100
00:03:59,439 --> 00:04:01,840
the offshoot builder is executed and the

101
00:04:01,840 --> 00:04:04,159
office of boot order will initialize the

102
00:04:04,159 --> 00:04:04,720
system

103
00:04:04,720 --> 00:04:08,239
and it's to do so it will load

104
00:04:08,239 --> 00:04:12,239
various applications in a static order

105
00:04:12,239 --> 00:04:15,439
and from these applications you can see

106
00:04:15,439 --> 00:04:17,839
that there is an abl zero stage which

107
00:04:17,839 --> 00:04:19,358
has embedded multiple

108
00:04:19,358 --> 00:04:21,839
abl one to six stages and these are the

109
00:04:21,839 --> 00:04:22,720
stages

110
00:04:22,720 --> 00:04:25,680
that actually configure and initialize

111
00:04:25,680 --> 00:04:27,199
the x86 soc

112
00:04:27,199 --> 00:04:28,960
and this includes the training for the

113
00:04:28,960 --> 00:04:31,120
drim for example

114
00:04:31,120 --> 00:04:32,800
when this is finished and dram is

115
00:04:32,800 --> 00:04:34,479
available the psp

116
00:04:34,479 --> 00:04:36,880
will load and verify an uefa image into

117
00:04:36,880 --> 00:04:37,919
the dram

118
00:04:37,919 --> 00:04:40,000
and then release the x86 cores from

119
00:04:40,000 --> 00:04:42,080
reset and only now

120
00:04:42,080 --> 00:04:46,560
the system or the main x86 cores boot up

121
00:04:46,560 --> 00:04:49,759
now on the epic server variant of amd

122
00:04:49,759 --> 00:04:50,639
cpus

123
00:04:50,639 --> 00:04:52,880
when the system is fully booted and we

124
00:04:52,880 --> 00:04:54,320
have for example linux running on the

125
00:04:54,320 --> 00:04:55,600
x86 course

126
00:04:55,600 --> 00:04:58,160
linux can issue a request to the psp

127
00:04:58,160 --> 00:04:59,759
which will then load

128
00:04:59,759 --> 00:05:02,000
the firmware for the secure encrypted

129
00:05:02,000 --> 00:05:05,680
virtualization technology from amd

130
00:05:05,680 --> 00:05:08,639
again i refer you to our previous talk

131
00:05:08,639 --> 00:05:10,639
if you want to have a bit more

132
00:05:10,639 --> 00:05:12,639
background or details on this part of

133
00:05:12,639 --> 00:05:15,280
the amd psp

134
00:05:15,280 --> 00:05:17,919
now if we look at the ryzen cpus the

135
00:05:17,919 --> 00:05:19,520
boot process is

136
00:05:19,520 --> 00:05:21,759
somewhat similar except for the last

137
00:05:21,759 --> 00:05:22,800
step

138
00:05:22,800 --> 00:05:25,840
when the x86 scores are load

139
00:05:25,840 --> 00:05:30,080
released from reset the psp will

140
00:05:30,080 --> 00:05:32,400
overwrite its own sram memory with

141
00:05:32,400 --> 00:05:33,520
another

142
00:05:33,520 --> 00:05:36,639
operating system and this is the

143
00:05:36,639 --> 00:05:39,199
secure s which is provided by trustonic

144
00:05:39,199 --> 00:05:40,080
it's a kinebi

145
00:05:40,080 --> 00:05:43,600
tee and the whole sram is replaced with

146
00:05:43,600 --> 00:05:45,440
that operating system

147
00:05:45,440 --> 00:05:48,479
and this os is responsible for example

148
00:05:48,479 --> 00:05:49,520
to

149
00:05:49,520 --> 00:05:53,039
host a firmware tpm so if you have a amd

150
00:05:53,039 --> 00:05:55,120
mainboard and there is an option to use

151
00:05:55,120 --> 00:05:56,319
a firmware tpm

152
00:05:56,319 --> 00:05:58,720
that firmware tpm is actually running on

153
00:05:58,720 --> 00:06:00,720
the psp

154
00:06:00,720 --> 00:06:04,960
now the secure s will divide the

155
00:06:04,960 --> 00:06:07,840
psp again into a non-secure and secure

156
00:06:07,840 --> 00:06:08,560
site

157
00:06:08,560 --> 00:06:12,160
using armed trusts on technology

158
00:06:12,160 --> 00:06:15,199
so so much for the boot process let's

159
00:06:15,199 --> 00:06:17,199
have a look at the hardware of the psp

160
00:06:17,199 --> 00:06:18,479
itself

161
00:06:18,479 --> 00:06:20,560
now the psp as mentioned is an arm

162
00:06:20,560 --> 00:06:21,840
cortex f5

163
00:06:21,840 --> 00:06:23,840
so that means it has a 32-bit address

164
00:06:23,840 --> 00:06:25,440
space and

165
00:06:25,440 --> 00:06:27,520
at the top of this address space or at

166
00:06:27,520 --> 00:06:29,039
the bottom the way

167
00:06:29,039 --> 00:06:30,720
depending on the way you look at it we

168
00:06:30,720 --> 00:06:32,240
have the local sram

169
00:06:32,240 --> 00:06:35,199
and the sram is either 256 kilobytes or

170
00:06:35,199 --> 00:06:35,600
for

171
00:06:35,600 --> 00:06:39,360
then one cpus or 384 kilobytes for the

172
00:06:39,360 --> 00:06:39,919
n2

173
00:06:39,919 --> 00:06:42,880
cpus and this is the whole memory which

174
00:06:42,880 --> 00:06:43,680
is used

175
00:06:43,680 --> 00:06:47,039
to uh store and execute the offshore

176
00:06:47,039 --> 00:06:48,000
bootloader and

177
00:06:48,000 --> 00:06:51,280
all its applications now at the arm high

178
00:06:51,280 --> 00:06:53,039
vectors page at the end of the address

179
00:06:53,039 --> 00:06:55,440
space we have the rom bootloader

180
00:06:55,440 --> 00:06:57,599
this is present at the fixed memory

181
00:06:57,599 --> 00:06:58,479
location

182
00:06:58,479 --> 00:07:01,280
and this is the start of the boot

183
00:07:01,280 --> 00:07:02,639
process

184
00:07:02,639 --> 00:07:06,800
now in between we have a dedicated mmio

185
00:07:06,800 --> 00:07:08,880
region which contains various devices

186
00:07:08,880 --> 00:07:09,520
such as

187
00:07:09,520 --> 00:07:12,639
nike controller a timer crypto

188
00:07:12,639 --> 00:07:13,680
accelerator

189
00:07:13,680 --> 00:07:17,680
and x86 and smn slot controllers

190
00:07:17,680 --> 00:07:19,680
and the rest of the memory space is

191
00:07:19,680 --> 00:07:21,520
essentially divided between the

192
00:07:21,520 --> 00:07:23,360
smn so the system management network

193
00:07:23,360 --> 00:07:26,400
slots and x86 slots

194
00:07:26,400 --> 00:07:29,919
so what is what are these slots a slot

195
00:07:29,919 --> 00:07:32,639
is a view into another address space

196
00:07:32,639 --> 00:07:34,960
and this is required because the psp has

197
00:07:34,960 --> 00:07:37,440
not only access to its own address space

198
00:07:37,440 --> 00:07:40,080
but also access to various other address

199
00:07:40,080 --> 00:07:41,360
spaces

200
00:07:41,360 --> 00:07:43,440
so the psp has access to the system

201
00:07:43,440 --> 00:07:44,479
management network

202
00:07:44,479 --> 00:07:47,599
this is another 32-bit address space

203
00:07:47,599 --> 00:07:51,280
which has various devices present

204
00:07:51,280 --> 00:07:54,639
so for example the memory controller

205
00:07:54,639 --> 00:07:57,520
of the x86 soc is part of the system

206
00:07:57,520 --> 00:07:58,000
management

207
00:07:58,000 --> 00:08:00,319
network and when the psp wants to

208
00:08:00,319 --> 00:08:02,080
configure encryption keys

209
00:08:02,080 --> 00:08:04,080
for the memory controller it will talk

210
00:08:04,080 --> 00:08:06,319
to the memory controller via the system

211
00:08:06,319 --> 00:08:08,080
management network

212
00:08:08,080 --> 00:08:10,800
we can also find some fuses there and

213
00:08:10,800 --> 00:08:11,440
the

214
00:08:11,440 --> 00:08:13,599
spi flash is also part of the system

215
00:08:13,599 --> 00:08:15,360
management network

216
00:08:15,360 --> 00:08:18,400
now this system management network is

217
00:08:18,400 --> 00:08:20,080
completely undocumented so

218
00:08:20,080 --> 00:08:22,240
there are probably a lot more various

219
00:08:22,240 --> 00:08:24,080
devices there which we have not figured

220
00:08:24,080 --> 00:08:27,759
out yet now the psp has access to this

221
00:08:27,759 --> 00:08:29,599
address space and the way this works is

222
00:08:29,599 --> 00:08:31,840
that the psp

223
00:08:31,840 --> 00:08:33,760
one can map certain parts of this

224
00:08:33,760 --> 00:08:35,919
address space into its own address space

225
00:08:35,919 --> 00:08:37,599
so for example if it wants to access

226
00:08:37,599 --> 00:08:39,200
this green part of the sbi

227
00:08:39,200 --> 00:08:41,599
region it will tell a dedicated

228
00:08:41,599 --> 00:08:42,399
controller

229
00:08:42,399 --> 00:08:45,839
within the mmio space to map this region

230
00:08:45,839 --> 00:08:48,480
into its address space as a fixed slot

231
00:08:48,480 --> 00:08:49,600
slot

232
00:08:49,600 --> 00:08:52,399
so the hardware then will ensure that

233
00:08:52,399 --> 00:08:53,200
the same

234
00:08:53,200 --> 00:08:55,120
system management region as configured

235
00:08:55,120 --> 00:08:59,360
is visible within the pcb address space

236
00:08:59,920 --> 00:09:02,880
now for x86 there's a similar mechanism

237
00:09:02,880 --> 00:09:04,480
the x86 address space is

238
00:09:04,480 --> 00:09:07,680
48 bits wide and it's partially

239
00:09:07,680 --> 00:09:08,560
documented

240
00:09:08,560 --> 00:09:11,519
you can google for the amd processor

241
00:09:11,519 --> 00:09:13,040
programming references

242
00:09:13,040 --> 00:09:15,440
references and they will yield some

243
00:09:15,440 --> 00:09:17,279
information about various devices which

244
00:09:17,279 --> 00:09:19,440
are present in the x86 address space

245
00:09:19,440 --> 00:09:21,839
and the psp has access to all of them

246
00:09:21,839 --> 00:09:22,640
using the same

247
00:09:22,640 --> 00:09:24,880
similar mechanism as explained

248
00:09:24,880 --> 00:09:25,760
previously

249
00:09:25,760 --> 00:09:28,080
so for example the psp can access the

250
00:09:28,080 --> 00:09:29,120
complete dram

251
00:09:29,120 --> 00:09:31,040
by mapping parts of the dram into its

252
00:09:31,040 --> 00:09:32,720
own address space and then performing a

253
00:09:32,720 --> 00:09:36,880
simple read operation

254
00:09:36,880 --> 00:09:38,720
another interesting device which is

255
00:09:38,720 --> 00:09:40,080
present on the pcb

256
00:09:40,080 --> 00:09:43,680
itself is the crypto accelerator the psp

257
00:09:43,680 --> 00:09:44,399
has a

258
00:09:44,399 --> 00:09:46,800
cryptographic co-processor version 5 or

259
00:09:46,800 --> 00:09:48,640
ccp

260
00:09:48,640 --> 00:09:50,640
descriptor accelerator has support for

261
00:09:50,640 --> 00:09:52,560
various algorithms such as

262
00:09:52,560 --> 00:09:56,240
sha rsa aes ecc zlib or even provide

263
00:09:56,240 --> 00:09:59,680
support for true random numbers now

264
00:09:59,680 --> 00:10:02,000
the psp makes extensive use of this

265
00:10:02,000 --> 00:10:03,040
device and

266
00:10:03,040 --> 00:10:06,240
it also uses this device as a simple

267
00:10:06,240 --> 00:10:09,360
dmi copy engine it uses it also for

268
00:10:09,360 --> 00:10:12,240
to verify signatures or to decompress

269
00:10:12,240 --> 00:10:14,560
firmware files

270
00:10:14,560 --> 00:10:16,320
there is no official documentation

271
00:10:16,320 --> 00:10:18,399
available for this device

272
00:10:18,399 --> 00:10:21,360
but there's a linux kernel driver and

273
00:10:21,360 --> 00:10:22,160
this is

274
00:10:22,160 --> 00:10:24,399
extremely valuable for us because that

275
00:10:24,399 --> 00:10:25,920
allowed us to

276
00:10:25,920 --> 00:10:28,399
really understand how the pcp performs

277
00:10:28,399 --> 00:10:29,680
certain actions such as

278
00:10:29,680 --> 00:10:32,240
signature verification or decompressing

279
00:10:32,240 --> 00:10:33,680
binaries

280
00:10:33,680 --> 00:10:36,480
now alex will continue and talk about

281
00:10:36,480 --> 00:10:37,600
how to

282
00:10:37,600 --> 00:10:40,079
emulate those devices i just told you

283
00:10:40,079 --> 00:10:42,640
earlier about

284
00:10:42,880 --> 00:10:45,120
thanks robot so how did we approach the

285
00:10:45,120 --> 00:10:46,560
actual emulation

286
00:10:46,560 --> 00:10:48,320
well the easiest approach of course is

287
00:10:48,320 --> 00:10:50,320
to just start executing the firmware and

288
00:10:50,320 --> 00:10:51,839
see for how it gets

289
00:10:51,839 --> 00:10:53,600
for that task we have chosen unicorn

290
00:10:53,600 --> 00:10:55,360
because it has an easy to use api

291
00:10:55,360 --> 00:10:56,880
and we thought it is perfect for that

292
00:10:56,880 --> 00:10:58,399
kind of task

293
00:10:58,399 --> 00:11:00,320
so at some point the firmware will hang

294
00:11:00,320 --> 00:11:02,240
or unicorn will throw an error because

295
00:11:02,240 --> 00:11:03,600
an unmapped region is accessed for

296
00:11:03,600 --> 00:11:04,800
example

297
00:11:04,800 --> 00:11:06,959
we then analyzed the fold and the code

298
00:11:06,959 --> 00:11:08,880
was executed before trying to make sense

299
00:11:08,880 --> 00:11:10,720
of it and get an idea what the emulator

300
00:11:10,720 --> 00:11:12,000
was missing

301
00:11:12,000 --> 00:11:13,839
at last we've implemented and debugged

302
00:11:13,839 --> 00:11:15,279
the missing functionality and then

303
00:11:15,279 --> 00:11:17,279
started at the execute step again and

304
00:11:17,279 --> 00:11:20,560
continued with the next round

305
00:11:21,519 --> 00:11:23,440
this approach brought us pretty far so

306
00:11:23,440 --> 00:11:24,800
after about two months

307
00:11:24,800 --> 00:11:26,560
the emulator was able to execute the

308
00:11:26,560 --> 00:11:28,560
on-chip bootloader we've

309
00:11:28,560 --> 00:11:31,120
gathered from various cpus previously

310
00:11:31,120 --> 00:11:33,040
and the on-chip bootloader was able to

311
00:11:33,040 --> 00:11:34,959
load and execute the offchip bootloader

312
00:11:34,959 --> 00:11:36,880
from the emulated spi flash using the

313
00:11:36,880 --> 00:11:40,560
emulated cryptographic coprocessor

314
00:11:40,560 --> 00:11:42,560
the offshore bootloader was also able to

315
00:11:42,560 --> 00:11:43,760
load and execute the first two

316
00:11:43,760 --> 00:11:45,519
applications we as of today

317
00:11:45,519 --> 00:11:46,800
still don't know what they're actually

318
00:11:46,800 --> 00:11:48,800
used for this

319
00:11:48,800 --> 00:11:50,959
required working signature checking zlip

320
00:11:50,959 --> 00:11:53,200
decompression inside the ccp among other

321
00:11:53,200 --> 00:11:54,959
things

322
00:11:54,959 --> 00:11:56,800
the offchip bootloader also started

323
00:11:56,800 --> 00:11:58,560
executing the base ajisa code for

324
00:11:58,560 --> 00:12:00,079
bootstrapping the whole platform but at

325
00:12:00,079 --> 00:12:01,839
this point the code was hanging trying

326
00:12:01,839 --> 00:12:04,720
to communicate with some device

327
00:12:04,720 --> 00:12:06,639
there we had to stop with our so far

328
00:12:06,639 --> 00:12:08,000
successful approach because

329
00:12:08,000 --> 00:12:09,920
trying to emulate all devices to some

330
00:12:09,920 --> 00:12:11,440
extent would be a daunting and almost

331
00:12:11,440 --> 00:12:13,839
impossible task without knowing anything

332
00:12:13,839 --> 00:12:15,519
just think of possible side effects

333
00:12:15,519 --> 00:12:17,120
certain accesses might have on other

334
00:12:17,120 --> 00:12:20,880
registers and devices in the system

335
00:12:20,880 --> 00:12:22,560
here you see a part of the trace from

336
00:12:22,560 --> 00:12:24,160
the emulator for an emulator run of the

337
00:12:24,160 --> 00:12:25,120
firmware

338
00:12:25,120 --> 00:12:29,120
the psp has a register in mmio space

339
00:12:29,120 --> 00:12:31,680
which is used by the firmware to store

340
00:12:31,680 --> 00:12:33,600
postcodes to it when it reaches a

341
00:12:33,600 --> 00:12:35,440
certain point in the boot process

342
00:12:35,440 --> 00:12:36,800
and you can actually see that it

343
00:12:36,800 --> 00:12:38,800
successfully started up that it

344
00:12:38,800 --> 00:12:42,079
read and initialized the data from the

345
00:12:42,079 --> 00:12:43,279
spi

346
00:12:43,279 --> 00:12:46,000
rom and also that it executed the first

347
00:12:46,000 --> 00:12:47,839
two applications the debug unlock app

348
00:12:47,839 --> 00:12:50,000
and the security gasket application

349
00:12:50,000 --> 00:12:52,240
and the last status you see here is that

350
00:12:52,240 --> 00:12:54,320
it also started loading and executing

351
00:12:54,320 --> 00:12:54,560
the

352
00:12:54,560 --> 00:12:59,119
gisa0 application

353
00:13:00,639 --> 00:13:02,880
so we had to choose a different approach

354
00:13:02,880 --> 00:13:04,560
and because we already had code

355
00:13:04,560 --> 00:13:06,000
execution on the psp for

356
00:13:06,000 --> 00:13:07,680
quite some time we quickly came to the

357
00:13:07,680 --> 00:13:09,519
conclusion to leverage that and try to

358
00:13:09,519 --> 00:13:11,279
pass through hardware accesses the

359
00:13:11,279 --> 00:13:13,279
firmware makes from the psp emulator to

360
00:13:13,279 --> 00:13:14,880
the real hardware

361
00:13:14,880 --> 00:13:17,680
for that the real psp will run a stop

362
00:13:17,680 --> 00:13:19,839
forwarding those requests from a generic

363
00:13:19,839 --> 00:13:22,320
proxy component in the emulator

364
00:13:22,320 --> 00:13:24,240
this component will capture all accesses

365
00:13:24,240 --> 00:13:26,079
to regions which are not being used by

366
00:13:26,079 --> 00:13:28,000
configured emulated devices like the

367
00:13:28,000 --> 00:13:30,000
emulator flash for example

368
00:13:30,000 --> 00:13:32,000
and forward it to the stop running on

369
00:13:32,000 --> 00:13:33,040
the real psp

370
00:13:33,040 --> 00:13:34,560
where it communicates with the device

371
00:13:34,560 --> 00:13:36,079
and return the result back to the

372
00:13:36,079 --> 00:13:37,680
emulator

373
00:13:37,680 --> 00:13:39,600
robert will talk about the vulnerability

374
00:13:39,600 --> 00:13:41,199
we've exploited a bit later on in this

375
00:13:41,199 --> 00:13:42,720
talk

376
00:13:42,720 --> 00:13:45,360
so proxy mode was born but the biggest

377
00:13:45,360 --> 00:13:46,320
question was

378
00:13:46,320 --> 00:13:48,240
the communication channel to use as the

379
00:13:48,240 --> 00:13:50,240
whole system wasn't initialized when we

380
00:13:50,240 --> 00:13:51,920
wanted to take control over it

381
00:13:51,920 --> 00:13:53,440
which is right after the onshore

382
00:13:53,440 --> 00:13:55,680
bootloader tries to hand over execution

383
00:13:55,680 --> 00:13:57,920
to the offshore bootloader so not even a

384
00:13:57,920 --> 00:13:59,920
simple device like the serial port was

385
00:13:59,920 --> 00:14:01,839
working and because the whole system is

386
00:14:01,839 --> 00:14:03,440
still mostly black box to us

387
00:14:03,440 --> 00:14:06,959
was making it even more difficult

388
00:14:08,240 --> 00:14:11,199
so the only interface we knew about and

389
00:14:11,199 --> 00:14:13,279
had access to was the spi flash

390
00:14:13,279 --> 00:14:14,800
interface

391
00:14:14,800 --> 00:14:16,720
the psp contains a flash controller

392
00:14:16,720 --> 00:14:18,800
which maps the content of the spi flash

393
00:14:18,800 --> 00:14:20,320
into the smn address space

394
00:14:20,320 --> 00:14:23,040
and if the psp firmware reads or writes

395
00:14:23,040 --> 00:14:25,279
to or from the spi flash region

396
00:14:25,279 --> 00:14:27,040
it will generate the necessary spi

397
00:14:27,040 --> 00:14:29,519
commands on the on the spi bus

398
00:14:29,519 --> 00:14:32,000
so the university bought an spi flash

399
00:14:32,000 --> 00:14:33,040
emulator

400
00:14:33,040 --> 00:14:35,600
which was hooked up to the system the

401
00:14:35,600 --> 00:14:37,199
good thing is that it also has an open

402
00:14:37,199 --> 00:14:39,120
source utility to configure it and read

403
00:14:39,120 --> 00:14:40,959
the spi trace later on

404
00:14:40,959 --> 00:14:44,880
so we could modify it the idea was to

405
00:14:44,880 --> 00:14:46,000
let our stop

406
00:14:46,000 --> 00:14:47,680
read or write a magic location in the

407
00:14:47,680 --> 00:14:49,600
flash area which then the

408
00:14:49,600 --> 00:14:51,279
controller translate to the necessary

409
00:14:51,279 --> 00:14:53,519
spi commands and the flash emulator

410
00:14:53,519 --> 00:14:55,600
would then capture

411
00:14:55,600 --> 00:14:58,480
the tool on the host would then read out

412
00:14:58,480 --> 00:14:58,880
the

413
00:14:58,880 --> 00:15:01,519
the trace pars it and extract the data

414
00:15:01,519 --> 00:15:02,480
inside

415
00:15:02,480 --> 00:15:05,760
the the data when it recognizes the

416
00:15:05,760 --> 00:15:07,360
magic location

417
00:15:07,360 --> 00:15:09,199
the extracted data would be then made

418
00:15:09,199 --> 00:15:10,880
available over a simple network socket

419
00:15:10,880 --> 00:15:12,880
to a psp emulator

420
00:15:12,880 --> 00:15:14,480
likewise it would also take the data

421
00:15:14,480 --> 00:15:16,320
from the socket and reprogram the flash

422
00:15:16,320 --> 00:15:18,079
so the stub has access to the data when

423
00:15:18,079 --> 00:15:20,160
it tries to read it

424
00:15:20,160 --> 00:15:21,600
this sounds simple but was made

425
00:15:21,600 --> 00:15:23,279
complicated by the flash emulator itself

426
00:15:23,279 --> 00:15:25,199
because you have to disable spi

427
00:15:25,199 --> 00:15:28,079
emulation on the flash emulator when you

428
00:15:28,079 --> 00:15:28,639
up

429
00:15:28,639 --> 00:15:31,199
want to update the content of the spi

430
00:15:31,199 --> 00:15:31,759
flash

431
00:15:31,759 --> 00:15:35,680
image in ram which is obviously a bad

432
00:15:35,680 --> 00:15:37,199
idea if the stuff is accessing the flash

433
00:15:37,199 --> 00:15:38,240
at the same time

434
00:15:38,240 --> 00:15:40,160
so we had to put some sort of locking

435
00:15:40,160 --> 00:15:42,000
protocol on top of it to prevent the

436
00:15:42,000 --> 00:15:42,720
tool

437
00:15:42,720 --> 00:15:45,120
from disabling the flash emulator at an

438
00:15:45,120 --> 00:15:46,720
unconvenient time when the stop is

439
00:15:46,720 --> 00:15:48,720
actually accessing the flash

440
00:15:48,720 --> 00:15:50,880
um the problem here is that is

441
00:15:50,880 --> 00:15:52,720
everything got rather slow we had a

442
00:15:52,720 --> 00:15:54,639
stable communication

443
00:15:54,639 --> 00:15:56,639
using that method but we could only do

444
00:15:56,639 --> 00:15:58,320
two to three register accesses per

445
00:15:58,320 --> 00:16:00,880
second using this method

446
00:16:00,880 --> 00:16:02,720
for example it took about 20 minutes for

447
00:16:02,720 --> 00:16:04,720
the onship bootloader to complete its

448
00:16:04,720 --> 00:16:06,160
run in the emulator

449
00:16:06,160 --> 00:16:07,600
even though it wasn't accessing a whole

450
00:16:07,600 --> 00:16:10,160
lot of regions inside

451
00:16:10,160 --> 00:16:14,880
the smn or mmi address space

452
00:16:15,199 --> 00:16:17,920
so and it of course still requires an

453
00:16:17,920 --> 00:16:22,320
expensive flash emulator um

454
00:16:22,320 --> 00:16:24,000
at this point we started looking into

455
00:16:24,000 --> 00:16:26,079
getting the uid initialized and working

456
00:16:26,079 --> 00:16:28,880
so we had something hopefully faster and

457
00:16:28,880 --> 00:16:30,320
not requiring an expensive flash

458
00:16:30,320 --> 00:16:31,839
emulator

459
00:16:31,839 --> 00:16:33,680
robert already mentioned that we then

460
00:16:33,680 --> 00:16:35,360
came across the processor programming

461
00:16:35,360 --> 00:16:36,959
reference manuals which are freely

462
00:16:36,959 --> 00:16:38,560
available for everyone

463
00:16:38,560 --> 00:16:40,399
and in there we found a description of

464
00:16:40,399 --> 00:16:41,600
an low level

465
00:16:41,600 --> 00:16:44,399
spi controller interface allowing the

466
00:16:44,399 --> 00:16:47,199
bios oe file on the x86 site to send

467
00:16:47,199 --> 00:16:48,720
arbitrary commands

468
00:16:48,720 --> 00:16:51,680
to the attached spi flash we've also

469
00:16:51,680 --> 00:16:53,600
found some code in the psp firmware

470
00:16:53,600 --> 00:16:54,160
earlier

471
00:16:54,160 --> 00:16:55,839
which we thought would do the same but

472
00:16:55,839 --> 00:16:57,759
we were never able to recreate it in our

473
00:16:57,759 --> 00:16:59,440
startup to execute arbitrary spi

474
00:16:59,440 --> 00:17:01,680
commands

475
00:17:01,680 --> 00:17:03,440
so with the described spi flash

476
00:17:03,440 --> 00:17:05,839
interface residing in x86 mmo space and

477
00:17:05,839 --> 00:17:06,559
the smn

478
00:17:06,559 --> 00:17:08,559
address from the psp firmware we hope

479
00:17:08,559 --> 00:17:10,079
that the register interface described

480
00:17:10,079 --> 00:17:12,000
for the x86 site is actually just the

481
00:17:12,000 --> 00:17:12,640
same

482
00:17:12,640 --> 00:17:15,119
than what's behind the smn address and

483
00:17:15,119 --> 00:17:16,720
it actually worked

484
00:17:16,720 --> 00:17:18,720
so now we were able to send arbitrary

485
00:17:18,720 --> 00:17:22,000
spi commands directly to the spi flash

486
00:17:22,000 --> 00:17:23,520
which enables us to use this

487
00:17:23,520 --> 00:17:25,679
communication side channel inside inside

488
00:17:25,679 --> 00:17:27,919
the spi flash emulator

489
00:17:27,919 --> 00:17:31,200
so we could exchange data

490
00:17:31,200 --> 00:17:33,679
at a much much greater speed than

491
00:17:33,679 --> 00:17:34,960
previously

492
00:17:34,960 --> 00:17:36,799
so after implementing a proper transport

493
00:17:36,799 --> 00:17:38,799
packet in our stop and modifying the

494
00:17:38,799 --> 00:17:40,080
flash emulator

495
00:17:40,080 --> 00:17:42,400
tool to forward the data using this side

496
00:17:42,400 --> 00:17:43,440
channel

497
00:17:43,440 --> 00:17:45,039
we had a really fast and reliable

498
00:17:45,039 --> 00:17:47,440
communication channel to work with

499
00:17:47,440 --> 00:17:50,000
it however still requires um an

500
00:17:50,000 --> 00:17:51,679
expensive flash emulator

501
00:17:51,679 --> 00:17:53,600
unfortunately so to put this in

502
00:17:53,600 --> 00:17:55,440
perspective um

503
00:17:55,440 --> 00:17:58,080
with the running the off chip offshore

504
00:17:58,080 --> 00:18:00,320
bootloader inside the emulator it now

505
00:18:00,320 --> 00:18:02,400
took only about five minutes for the

506
00:18:02,400 --> 00:18:03,440
complete bootstrapping

507
00:18:03,440 --> 00:18:06,000
process to complete whereas before only

508
00:18:06,000 --> 00:18:07,520
the on-chip bootloader would already

509
00:18:07,520 --> 00:18:10,639
take over 20 minutes

510
00:18:12,080 --> 00:18:15,120
so because we still need

511
00:18:15,120 --> 00:18:17,440
an expensive flash emulator and we

512
00:18:17,440 --> 00:18:19,120
wanted to make it easier for others to

513
00:18:19,120 --> 00:18:21,039
fully use our code

514
00:18:21,039 --> 00:18:22,640
so we still wanted to get the serial

515
00:18:22,640 --> 00:18:24,080
port working

516
00:18:24,080 --> 00:18:25,840
it would be much slower than the spi

517
00:18:25,840 --> 00:18:27,600
channel but

518
00:18:27,600 --> 00:18:31,039
it would be a very low cost solution um

519
00:18:31,039 --> 00:18:32,799
legacy serial ports on almost all

520
00:18:32,799 --> 00:18:34,400
consumer members today are handled by a

521
00:18:34,400 --> 00:18:36,000
so-called super io chip

522
00:18:36,000 --> 00:18:38,080
which sole purpose is to provide legacy

523
00:18:38,080 --> 00:18:40,160
i o like a keyboard mouse controller a

524
00:18:40,160 --> 00:18:41,039
parallel

525
00:18:41,039 --> 00:18:44,400
and serial ports among others and these

526
00:18:44,400 --> 00:18:46,320
super io chips are attached via the so

527
00:18:46,320 --> 00:18:48,400
called low pin count bus

528
00:18:48,400 --> 00:18:52,000
directly to the amd soc

529
00:18:52,080 --> 00:18:53,919
however these superior chips need to be

530
00:18:53,919 --> 00:18:56,720
configured to enable serial ports

531
00:18:56,720 --> 00:18:58,640
and the configuration sequence depends

532
00:18:58,640 --> 00:19:00,400
on the chip being used

533
00:19:00,400 --> 00:19:02,240
this is usually done by the bios earlier

534
00:19:02,240 --> 00:19:03,679
e5 firmware

535
00:19:03,679 --> 00:19:05,520
and to complicate matters most of these

536
00:19:05,520 --> 00:19:07,600
chips like the ite one on our main board

537
00:19:07,600 --> 00:19:08,559
have no public

538
00:19:08,559 --> 00:19:11,440
reference manual so we had to get at the

539
00:19:11,440 --> 00:19:13,120
initialization sequence for the urge

540
00:19:13,120 --> 00:19:14,400
somehow

541
00:19:14,400 --> 00:19:16,240
for that we hooked up a logic analyzer

542
00:19:16,240 --> 00:19:17,440
to the lpc bus

543
00:19:17,440 --> 00:19:18,880
and captured everything going on there

544
00:19:18,880 --> 00:19:20,960
using the stock firmware image

545
00:19:20,960 --> 00:19:22,640
the resulting captcha file was then

546
00:19:22,640 --> 00:19:24,400
processed by a self-written tool called

547
00:19:24,400 --> 00:19:26,400
lpc decoder to make analysis

548
00:19:26,400 --> 00:19:30,000
easier after extracting the necessary

549
00:19:30,000 --> 00:19:31,520
sequence from the capture and

550
00:19:31,520 --> 00:19:33,039
implementing that in our step however

551
00:19:33,039 --> 00:19:34,880
the uride was still not working

552
00:19:34,880 --> 00:19:36,640
and after a lot of trial and error it

553
00:19:36,640 --> 00:19:38,400
turns out that one has to flip a single

554
00:19:38,400 --> 00:19:40,080
bit in a register living in the system

555
00:19:40,080 --> 00:19:41,840
management network space to either turn

556
00:19:41,840 --> 00:19:43,440
on the superior chip or bring it out of

557
00:19:43,440 --> 00:19:44,720
reset

558
00:19:44,720 --> 00:19:46,640
but with that in place we also now have

559
00:19:46,640 --> 00:19:48,000
a slow but low cost solution to

560
00:19:48,000 --> 00:19:49,600
communicate with the code running on the

561
00:19:49,600 --> 00:19:52,640
psp before the platform is initialized

562
00:19:52,640 --> 00:19:54,720
however depending on the super io chip

563
00:19:54,720 --> 00:19:56,400
being used for a particular main board

564
00:19:56,400 --> 00:19:57,679
one might to have adapt this

565
00:19:57,679 --> 00:20:01,280
initialization sequence a bit

566
00:20:02,799 --> 00:20:05,600
so and before continuing with the an

567
00:20:05,600 --> 00:20:06,000
overview

568
00:20:06,000 --> 00:20:07,840
of the psp emulator i will hand back to

569
00:20:07,840 --> 00:20:09,360
robert who will

570
00:20:09,360 --> 00:20:11,360
talk about the security vulnerability

571
00:20:11,360 --> 00:20:12,960
we've leveraged to gain actual code

572
00:20:12,960 --> 00:20:16,240
execution on the psp

573
00:20:16,240 --> 00:20:19,360
okay thanks alex now let's talk about

574
00:20:19,360 --> 00:20:20,080
how we can

575
00:20:20,080 --> 00:20:23,120
inject our own stop code so we can use

576
00:20:23,120 --> 00:20:24,559
the proxy mode

577
00:20:24,559 --> 00:20:27,360
now as explained previously when the psp

578
00:20:27,360 --> 00:20:28,960
boots up the first thing

579
00:20:28,960 --> 00:20:30,559
that's happening is that the onshore

580
00:20:30,559 --> 00:20:32,080
bootloader is executing and the on

581
00:20:32,080 --> 00:20:33,760
chipboard is executing

582
00:20:33,760 --> 00:20:36,880
from non-writable rom

583
00:20:36,880 --> 00:20:39,520
memory so that means before the onshore

584
00:20:39,520 --> 00:20:41,039
bootloader can do anything

585
00:20:41,039 --> 00:20:43,200
it needs to map certain parts of the

586
00:20:43,200 --> 00:20:45,200
address space for its stack

587
00:20:45,200 --> 00:20:46,799
and that's what's happening so part of

588
00:20:46,799 --> 00:20:49,520
the sram now is reserved for the on-chip

589
00:20:49,520 --> 00:20:50,080
boot or

590
00:20:50,080 --> 00:20:52,880
stack and then we need to load and

591
00:20:52,880 --> 00:20:54,640
verify the object boot order which is

592
00:20:54,640 --> 00:20:56,400
stored on the spi flash

593
00:20:56,400 --> 00:20:58,480
so then the next step for the onshore

594
00:20:58,480 --> 00:21:00,000
booter is to

595
00:21:00,000 --> 00:21:03,440
load to map the spi flash

596
00:21:03,440 --> 00:21:06,400
and then the onto bootloader will load

597
00:21:06,400 --> 00:21:08,400
and verify an amd public key

598
00:21:08,400 --> 00:21:11,120
which is present in the spi flash the

599
00:21:11,120 --> 00:21:13,440
public key is placed into the

600
00:21:13,440 --> 00:21:16,559
sram once that is finished

601
00:21:16,559 --> 00:21:18,559
the onshore bootloader will load and

602
00:21:18,559 --> 00:21:20,480
verify the offshore. the object

603
00:21:20,480 --> 00:21:22,480
bootloader is part of the sbi flash

604
00:21:22,480 --> 00:21:24,640
and it will copy the binary into the

605
00:21:24,640 --> 00:21:26,799
local sram

606
00:21:26,799 --> 00:21:29,600
now you can see that there's a red line

607
00:21:29,600 --> 00:21:30,000
between

608
00:21:30,000 --> 00:21:32,400
the offshore butter and the butter stack

609
00:21:32,400 --> 00:21:34,400
of course this copy operation must not

610
00:21:34,400 --> 00:21:36,000
cross that line

611
00:21:36,000 --> 00:21:38,400
so we have a certain maximum size that

612
00:21:38,400 --> 00:21:40,159
the off-chip bootloader can occupy and

613
00:21:40,159 --> 00:21:42,840
this size is smaller than the s-ramp

614
00:21:42,840 --> 00:21:44,080
size

615
00:21:44,080 --> 00:21:45,679
so the onshore bootloader needs to

616
00:21:45,679 --> 00:21:47,919
validate the size of the offshore boot

617
00:21:47,919 --> 00:21:48,559
order

618
00:21:48,559 --> 00:21:51,679
before the cop operation takes place

619
00:21:51,679 --> 00:21:54,000
now how do we get the size of the option

620
00:21:54,000 --> 00:21:55,840
off to bootloader

621
00:21:55,840 --> 00:21:57,360
now if we look at the firmware file

622
00:21:57,360 --> 00:22:00,000
system we see a structure like this

623
00:22:00,000 --> 00:22:02,240
we have a directories and we have

624
00:22:02,240 --> 00:22:04,080
entries in directories and these entries

625
00:22:04,080 --> 00:22:04,720
point to

626
00:22:04,720 --> 00:22:06,799
files the object boot order is one of

627
00:22:06,799 --> 00:22:08,640
those files and each file

628
00:22:08,640 --> 00:22:11,679
has a header a body and a signature now

629
00:22:11,679 --> 00:22:12,799
if you look at the

630
00:22:12,799 --> 00:22:16,080
header content we see that there are two

631
00:22:16,080 --> 00:22:17,120
different

632
00:22:17,120 --> 00:22:19,520
values of interest right now so first of

633
00:22:19,520 --> 00:22:20,320
all

634
00:22:20,320 --> 00:22:23,440
at offset hex 14 we have the body size

635
00:22:23,440 --> 00:22:25,679
so this is the size of the off-chip

636
00:22:25,679 --> 00:22:27,679
bootloader in the spi flash

637
00:22:27,679 --> 00:22:29,520
and then we have a load address and this

638
00:22:29,520 --> 00:22:30,880
load address is the

639
00:22:30,880 --> 00:22:32,720
target where this offshore bootloader

640
00:22:32,720 --> 00:22:34,320
wants to be placed in the

641
00:22:34,320 --> 00:22:38,960
sram now the on-chip bootloader

642
00:22:38,960 --> 00:22:41,520
needs to copy the octa-putter into the

643
00:22:41,520 --> 00:22:42,240
sram

644
00:22:42,240 --> 00:22:44,640
and only then its signature can be

645
00:22:44,640 --> 00:22:45,679
verified

646
00:22:45,679 --> 00:22:47,760
this is because the onshore boot order

647
00:22:47,760 --> 00:22:50,240
must avoid any talk to attacks

648
00:22:50,240 --> 00:22:52,240
where the attacker switches the content

649
00:22:52,240 --> 00:22:54,080
of the sbi flash for example

650
00:22:54,080 --> 00:22:57,679
after it has been validated so

651
00:22:57,679 --> 00:23:00,159
this header i talked about is processed

652
00:23:00,159 --> 00:23:01,200
before

653
00:23:01,200 --> 00:23:03,760
the signature check is validated or the

654
00:23:03,760 --> 00:23:05,919
signature check is carried out

655
00:23:05,919 --> 00:23:07,760
so that means the onshore bootloader

656
00:23:07,760 --> 00:23:09,120
needs to validate

657
00:23:09,120 --> 00:23:13,760
the header values uh carefully

658
00:23:13,760 --> 00:23:15,280
so let's have a look at the function

659
00:23:15,280 --> 00:23:17,280
that does this validation

660
00:23:17,280 --> 00:23:20,320
now first thing the entropy

661
00:23:20,320 --> 00:23:23,120
does it compares the load address from

662
00:23:23,120 --> 00:23:24,400
the header

663
00:23:24,400 --> 00:23:26,880
plus the body size for also from the

664
00:23:26,880 --> 00:23:28,720
header against the fixed threshold which

665
00:23:28,720 --> 00:23:30,880
is the start of the bootload stack

666
00:23:30,880 --> 00:23:33,120
but it does not take the values as they

667
00:23:33,120 --> 00:23:34,000
are

668
00:23:34,000 --> 00:23:36,480
stored in the spi flash instead it takes

669
00:23:36,480 --> 00:23:38,320
the absolute of those values

670
00:23:38,320 --> 00:23:41,520
so it masks out the sign bit the highest

671
00:23:41,520 --> 00:23:42,720
bit

672
00:23:42,720 --> 00:23:46,159
so if we calculate now this value you

673
00:23:46,159 --> 00:23:48,240
see that we have an absolute of x 100

674
00:23:48,240 --> 00:23:49,760
plus the absolute of

675
00:23:49,760 --> 00:23:53,600
hex c 640 and the result is

676
00:23:53,600 --> 00:23:56,799
c 740 in hex and

677
00:23:56,799 --> 00:23:59,520
if that value does not cross the

678
00:23:59,520 --> 00:24:01,520
beginning of the boot order stack we can

679
00:24:01,520 --> 00:24:03,520
safely place the offshore bootloader

680
00:24:03,520 --> 00:24:05,200
here

681
00:24:05,200 --> 00:24:08,240
now the copy operation that's doing our

682
00:24:08,240 --> 00:24:10,080
actual copy part

683
00:24:10,080 --> 00:24:12,559
looks like this so we copy to the load

684
00:24:12,559 --> 00:24:14,320
address

685
00:24:14,320 --> 00:24:17,120
from the spi source address and we copy

686
00:24:17,120 --> 00:24:18,000
body size

687
00:24:18,000 --> 00:24:21,120
time size now

688
00:24:21,120 --> 00:24:22,720
let's have a look at those values you

689
00:24:22,720 --> 00:24:24,799
can see for the check we use the

690
00:24:24,799 --> 00:24:26,000
absolute body size

691
00:24:26,000 --> 00:24:27,840
however for the copy operation we use

692
00:24:27,840 --> 00:24:29,760
the body size as is

693
00:24:29,760 --> 00:24:32,880
so that means let's say we

694
00:24:32,880 --> 00:24:35,840
take the body size in the spi flash and

695
00:24:35,840 --> 00:24:37,760
we flip the highest bit

696
00:24:37,760 --> 00:24:41,440
making it either a negative number or

697
00:24:41,440 --> 00:24:44,400
a very large if interpreted as an

698
00:24:44,400 --> 00:24:46,080
unsigned integer

699
00:24:46,080 --> 00:24:49,120
now if we do the check again we see it

700
00:24:49,120 --> 00:24:50,080
calculates

701
00:24:50,080 --> 00:24:53,200
to the same value so

702
00:24:53,200 --> 00:24:55,200
it doesn't matter if we flip the highest

703
00:24:55,200 --> 00:24:57,760
bit for the security check

704
00:24:57,760 --> 00:25:00,320
the resulting value is still small

705
00:25:00,320 --> 00:25:01,039
enough

706
00:25:01,039 --> 00:25:03,520
for the cop operation to take place but

707
00:25:03,520 --> 00:25:05,760
the cop operation actually uses the size

708
00:25:05,760 --> 00:25:06,000
as

709
00:25:06,000 --> 00:25:08,559
is so we have now a mismatch between the

710
00:25:08,559 --> 00:25:10,240
size that it's validated and the size

711
00:25:10,240 --> 00:25:12,320
that is used for copy

712
00:25:12,320 --> 00:25:14,960
and actually this size now here is way

713
00:25:14,960 --> 00:25:17,120
larger than the whole sram of this

714
00:25:17,120 --> 00:25:20,320
psp so if we use that copy

715
00:25:20,320 --> 00:25:23,039
operation right now we would copy over

716
00:25:23,039 --> 00:25:24,320
the whole sram content

717
00:25:24,320 --> 00:25:26,480
of the psp including the onshore

718
00:25:26,480 --> 00:25:28,880
bootloader stack

719
00:25:28,880 --> 00:25:32,240
so let's do that to insert our stop

720
00:25:32,240 --> 00:25:35,279
so we place our step within the spi

721
00:25:35,279 --> 00:25:36,000
flash

722
00:25:36,000 --> 00:25:38,240
and we append it with return addresses

723
00:25:38,240 --> 00:25:39,279
and these addresses

724
00:25:39,279 --> 00:25:42,000
start to the beginning of our stop a

725
00:25:42,000 --> 00:25:44,080
point to the beginning of our step

726
00:25:44,080 --> 00:25:46,480
now then we flip the sine bit of the

727
00:25:46,480 --> 00:25:48,000
body size

728
00:25:48,000 --> 00:25:50,400
and the resulting copy operation will

729
00:25:50,400 --> 00:25:52,240
happily copy over

730
00:25:52,240 --> 00:25:55,520
the whole sram and the data which is

731
00:25:55,520 --> 00:25:56,000
copied

732
00:25:56,000 --> 00:25:58,799
is our data which we put into the spi

733
00:25:58,799 --> 00:26:00,000
flash

734
00:26:00,000 --> 00:26:02,480
so that means in the end our stop is

735
00:26:02,480 --> 00:26:03,840
copied into the

736
00:26:03,840 --> 00:26:06,960
sram the return addresses are the whole

737
00:26:06,960 --> 00:26:08,880
stack of the onshore boot order

738
00:26:08,880 --> 00:26:12,000
is replaced with our return addresses

739
00:26:12,000 --> 00:26:15,120
with which then point to our psp step

740
00:26:15,120 --> 00:26:17,039
and as soon as the copy operation inside

741
00:26:17,039 --> 00:26:18,799
the onshore bootloader returns

742
00:26:18,799 --> 00:26:21,840
we execute our stop immediately and this

743
00:26:21,840 --> 00:26:23,279
all happens before

744
00:26:23,279 --> 00:26:26,720
any signature is validated so that means

745
00:26:26,720 --> 00:26:28,640
the fact that we cannot create a valid

746
00:26:28,640 --> 00:26:30,159
signature for the pcb stop

747
00:26:30,159 --> 00:26:33,679
doesn't really matter at all

748
00:26:33,679 --> 00:26:36,960
now if we use the same setup

749
00:26:36,960 --> 00:26:39,919
inside the emulator you would see

750
00:26:39,919 --> 00:26:41,520
something like this

751
00:26:41,520 --> 00:26:44,480
this is an output of the emulator which

752
00:26:44,480 --> 00:26:45,679
shows the

753
00:26:45,679 --> 00:26:48,880
ccp request this is the copy operation

754
00:26:48,880 --> 00:26:52,480
which i talked about earlier now the psp

755
00:26:52,480 --> 00:26:56,080
firmware uses the ccp for larger mem

756
00:26:56,080 --> 00:26:57,440
copy operations

757
00:26:57,440 --> 00:27:00,080
so in our case when copying the offshore

758
00:27:00,080 --> 00:27:02,159
boot order from the spi flash to the

759
00:27:02,159 --> 00:27:03,200
sram

760
00:27:03,200 --> 00:27:04,960
not a simple map copy is used but the

761
00:27:04,960 --> 00:27:07,039
ccp is used to copy the data

762
00:27:07,039 --> 00:27:08,960
and this is the printout of the

763
00:27:08,960 --> 00:27:10,640
corresponding request

764
00:27:10,640 --> 00:27:14,320
and here we can see the ccp request

765
00:27:14,320 --> 00:27:17,279
uses a very large size value to copy the

766
00:27:17,279 --> 00:27:18,000
data

767
00:27:18,000 --> 00:27:20,240
and the target address is a low address

768
00:27:20,240 --> 00:27:21,200
into the sram

769
00:27:21,200 --> 00:27:23,039
this is the target address which is

770
00:27:23,039 --> 00:27:25,279
specified in the sbi flash in the header

771
00:27:25,279 --> 00:27:27,360
of the off-chip bootloader

772
00:27:27,360 --> 00:27:30,240
now this way we can insert our own code

773
00:27:30,240 --> 00:27:32,840
directly after the on-chip boot order

774
00:27:32,840 --> 00:27:35,200
executed

775
00:27:35,200 --> 00:27:38,640
now to summarize this this feature

776
00:27:38,640 --> 00:27:41,520
um we've tried this on several systems

777
00:27:41,520 --> 00:27:42,080
and

778
00:27:42,080 --> 00:27:44,640
from the best of our knowledge all zen

779
00:27:44,640 --> 00:27:46,000
and then plus cpus are

780
00:27:46,000 --> 00:27:49,120
affected we confirmed this

781
00:27:49,120 --> 00:27:53,559
on the ryzen 1700 and epic

782
00:27:53,559 --> 00:27:56,480
7281 and the zen plus cpu

783
00:27:56,480 --> 00:27:59,919
it's a ryzen pro 3500u

784
00:27:59,919 --> 00:28:04,799
and ryzen 5 2600.

785
00:28:04,960 --> 00:28:07,279
we've looked at zen 2 we don't think

786
00:28:07,279 --> 00:28:08,640
it's affected

787
00:28:08,640 --> 00:28:12,399
but we don't know for sure actually

788
00:28:12,399 --> 00:28:15,120
of course we reported this to amd we

789
00:28:15,120 --> 00:28:16,000
were reported this

790
00:28:16,000 --> 00:28:19,840
in the end of february this year and

791
00:28:19,840 --> 00:28:22,640
well it took some time for amd to

792
00:28:22,640 --> 00:28:24,720
respond at all

793
00:28:24,720 --> 00:28:26,720
so they responded in the beginning of

794
00:28:26,720 --> 00:28:28,159
may and what they

795
00:28:28,159 --> 00:28:30,399
said was basically our all right this is

796
00:28:30,399 --> 00:28:31,200
a known bug

797
00:28:31,200 --> 00:28:33,919
it has been reported by others so we're

798
00:28:33,919 --> 00:28:35,840
obviously not the first one to discover

799
00:28:35,840 --> 00:28:36,720
this

800
00:28:36,720 --> 00:28:39,440
and they have developed mitigations in

801
00:28:39,440 --> 00:28:40,480
various products

802
00:28:40,480 --> 00:28:44,320
where appropriate so i don't think

803
00:28:44,320 --> 00:28:46,559
there's any meaningful mitigation

804
00:28:46,559 --> 00:28:48,640
besides replacing the actual hardware

805
00:28:48,640 --> 00:28:50,000
because this is a bug in the

806
00:28:50,000 --> 00:28:53,600
rom bootloader code but what do i know

807
00:28:53,600 --> 00:28:55,600
maybe amd has some magic that actually

808
00:28:55,600 --> 00:28:58,000
fixes this

809
00:28:58,000 --> 00:29:00,080
now i'm going to hand over again to alex

810
00:29:00,080 --> 00:29:01,679
for you to show you how

811
00:29:01,679 --> 00:29:04,640
you can use the emulator to analyze your

812
00:29:04,640 --> 00:29:04,960
own

813
00:29:04,960 --> 00:29:06,960
firmware which you downloaded maybe from

814
00:29:06,960 --> 00:29:09,520
a motherboard update

815
00:29:09,520 --> 00:29:11,440
so next we will go over the most basic

816
00:29:11,440 --> 00:29:13,039
command line arguments and features you

817
00:29:13,039 --> 00:29:14,320
will encounter when working with the

818
00:29:14,320 --> 00:29:15,919
emulator yourself

819
00:29:15,919 --> 00:29:17,679
so first you have to set the starting

820
00:29:17,679 --> 00:29:19,039
point in the boot process where you want

821
00:29:19,039 --> 00:29:20,880
to begin emulating

822
00:29:20,880 --> 00:29:22,799
the shown example starts executing the

823
00:29:22,799 --> 00:29:24,159
on-chip bootloader

824
00:29:24,159 --> 00:29:25,919
but we also have modes to execute the

825
00:29:25,919 --> 00:29:27,840
offshoot bootloader or even the securis

826
00:29:27,840 --> 00:29:29,919
directly

827
00:29:29,919 --> 00:29:31,840
the second argument selects the flash

828
00:29:31,840 --> 00:29:33,840
image to use for the emulated spi flash

829
00:29:33,840 --> 00:29:34,640
image

830
00:29:34,640 --> 00:29:36,559
and as we've selected to start emulating

831
00:29:36,559 --> 00:29:37,919
with the onshore bootloader we also have

832
00:29:37,919 --> 00:29:40,480
to load that one as well if you

833
00:29:40,480 --> 00:29:42,320
decide to start with the offshoot

834
00:29:42,320 --> 00:29:44,080
bootloader or the securis you have to

835
00:29:44,080 --> 00:29:46,240
use different arguments to load that one

836
00:29:46,240 --> 00:29:49,120
into sram

837
00:29:49,360 --> 00:29:52,080
then you set the destination of the

838
00:29:52,080 --> 00:29:54,000
trace log so everything which is deemed

839
00:29:54,000 --> 00:29:55,520
important by the emulator will be locked

840
00:29:55,520 --> 00:29:56,640
to the trace log like

841
00:29:56,640 --> 00:29:59,200
i o reads and writes and so on and

842
00:29:59,200 --> 00:30:00,720
because most of the time it will be

843
00:30:00,720 --> 00:30:02,000
interesting to see the interaction

844
00:30:02,000 --> 00:30:03,600
between the various user mode modules

845
00:30:03,600 --> 00:30:05,039
and the supervisor mode code you should

846
00:30:05,039 --> 00:30:05,919
also enable

847
00:30:05,919 --> 00:30:07,840
this call tracing so every score being

848
00:30:07,840 --> 00:30:09,360
made along with its arguments will be

849
00:30:09,360 --> 00:30:12,399
locked to the aforementioned trace log

850
00:30:12,399 --> 00:30:14,960
the last argument in this example will

851
00:30:14,960 --> 00:30:16,720
enable the gdb stop

852
00:30:16,720 --> 00:30:18,799
at the to listen at the specified port

853
00:30:18,799 --> 00:30:21,279
so you can hook up gdb

854
00:30:21,279 --> 00:30:23,679
to the psp emulator and then use

855
00:30:23,679 --> 00:30:25,840
breakpoints and watch points to control

856
00:30:25,840 --> 00:30:29,039
the execution of the loaded binary

857
00:30:29,039 --> 00:30:33,039
and analyze it so this is a basic

858
00:30:33,039 --> 00:30:37,840
workflow of when using the emulator

859
00:30:38,399 --> 00:30:40,080
next i will give a brief overview about

860
00:30:40,080 --> 00:30:41,520
the architecture of the

861
00:30:41,520 --> 00:30:44,240
psp emulator so at the core we use a

862
00:30:44,240 --> 00:30:45,919
heavily patched unicorn which gets

863
00:30:45,919 --> 00:30:47,440
wrapped by our own psp

864
00:30:47,440 --> 00:30:49,520
core abstraction layer which takes care

865
00:30:49,520 --> 00:30:50,480
of mmi

866
00:30:50,480 --> 00:30:52,720
related things handling svc calls from

867
00:30:52,720 --> 00:30:53,760
user space

868
00:30:53,760 --> 00:30:55,279
like doing the transition to supervisor

869
00:30:55,279 --> 00:30:57,039
mode code and back for example

870
00:30:57,039 --> 00:30:59,600
and other stuff because it turns out

871
00:30:59,600 --> 00:31:01,120
unicorn wasn't made to be used as a

872
00:31:01,120 --> 00:31:03,600
complete system emulator after all

873
00:31:03,600 --> 00:31:06,799
then the pspiom i o manager handles all

874
00:31:06,799 --> 00:31:09,039
mmi oh smn and x86

875
00:31:09,039 --> 00:31:10,799
access is being made from the firmware

876
00:31:10,799 --> 00:31:12,240
and forwards them to the appropriate

877
00:31:12,240 --> 00:31:14,159
devices

878
00:31:14,159 --> 00:31:18,399
therefore it emulates the um

879
00:31:18,399 --> 00:31:21,679
smn and x86 slot registers robert

880
00:31:21,679 --> 00:31:23,440
already talked about in the first

881
00:31:23,440 --> 00:31:26,720
part of this talk everything is then

882
00:31:26,720 --> 00:31:27,360
wrapped

883
00:31:27,360 --> 00:31:29,120
by the psp cct component which

884
00:31:29,120 --> 00:31:31,039
represents a single ccd and therefore

885
00:31:31,039 --> 00:31:33,840
psp instance in a real system

886
00:31:33,840 --> 00:31:35,519
below all that there is a tracing

887
00:31:35,519 --> 00:31:37,120
component which is responsible for

888
00:31:37,120 --> 00:31:38,799
generating the trace log and capturing

889
00:31:38,799 --> 00:31:40,480
information about i o reads and writes

890
00:31:40,480 --> 00:31:43,200
and svc calls for example

891
00:31:43,200 --> 00:31:46,559
and our gd debugging component is based

892
00:31:46,559 --> 00:31:48,559
up on our own libgdb stuff so you can

893
00:31:48,559 --> 00:31:50,399
debug the firmware with gdb or

894
00:31:50,399 --> 00:31:52,880
even ida pro for example and if you have

895
00:31:52,880 --> 00:31:54,399
written your own code you also get

896
00:31:54,399 --> 00:31:56,399
source level debugging for free

897
00:31:56,399 --> 00:31:58,399
we've used that to debug certain parts

898
00:31:58,399 --> 00:31:59,840
of our stub and for debugging the

899
00:31:59,840 --> 00:32:02,000
exploit for example

900
00:32:02,000 --> 00:32:04,880
it also gives access to special commands

901
00:32:04,880 --> 00:32:06,640
when using gdb's monitor

902
00:32:06,640 --> 00:32:08,880
command so you can access certain

903
00:32:08,880 --> 00:32:10,880
features of the emulator for example to

904
00:32:10,880 --> 00:32:12,559
read or write to devices on real

905
00:32:12,559 --> 00:32:15,440
hardware when proxy mode is used

906
00:32:15,440 --> 00:32:17,440
the proxy mode component is based upon

907
00:32:17,440 --> 00:32:18,880
the psp proxy

908
00:32:18,880 --> 00:32:22,000
which gives access to

909
00:32:22,000 --> 00:32:24,240
the real hardware using the

910
00:32:24,240 --> 00:32:25,120
aforementioned

911
00:32:25,120 --> 00:32:27,600
methods like the uart or spi flash

912
00:32:27,600 --> 00:32:29,840
emulator

913
00:32:31,120 --> 00:32:34,000
the gdb monitor command also gives

914
00:32:34,000 --> 00:32:35,519
access to the

915
00:32:35,519 --> 00:32:39,039
built-in coverage tracer so

916
00:32:39,039 --> 00:32:42,640
the coverage tracer generates coverage

917
00:32:42,640 --> 00:32:44,320
traces of either the complete run of the

918
00:32:44,320 --> 00:32:45,919
firmware or just a certain part of the

919
00:32:45,919 --> 00:32:47,600
code you are interested in

920
00:32:47,600 --> 00:32:49,440
and the coverage trace is compatible to

921
00:32:49,440 --> 00:32:50,960
the archive and can be loaded into

922
00:32:50,960 --> 00:32:52,640
github for example using the dragon

923
00:32:52,640 --> 00:32:54,880
dragon dance extension

924
00:32:54,880 --> 00:32:58,159
and also recently psp gained the feature

925
00:32:58,159 --> 00:33:00,480
to record all i o reads and writes into

926
00:33:00,480 --> 00:33:02,799
a certain log file and replay that later

927
00:33:02,799 --> 00:33:03,440
on

928
00:33:03,440 --> 00:33:06,640
so you can recreate a specific run of

929
00:33:06,640 --> 00:33:07,600
the firmware

930
00:33:07,600 --> 00:33:09,360
when you don't have access to the real

931
00:33:09,360 --> 00:33:11,840
hardware

932
00:33:12,880 --> 00:33:15,519
and with that our emulator can already

933
00:33:15,519 --> 00:33:17,279
do quite a bit

934
00:33:17,279 --> 00:33:20,159
for example what we can do is bootstrap

935
00:33:20,159 --> 00:33:22,480
the real hardware when in proxy mode

936
00:33:22,480 --> 00:33:23,840
up to the point where dram is

937
00:33:23,840 --> 00:33:25,600
initialized and the ue5 firmware starts

938
00:33:25,600 --> 00:33:28,159
executing on the x86 cores

939
00:33:28,159 --> 00:33:31,919
however the wifi firmware will then

940
00:33:31,919 --> 00:33:34,240
detect an error and will go into a

941
00:33:34,240 --> 00:33:35,039
recovery

942
00:33:35,039 --> 00:33:37,120
recovery mode and won't continue with

943
00:33:37,120 --> 00:33:39,120
booting the system further

944
00:33:39,120 --> 00:33:43,039
and also this is all for a ryzen 1700x

945
00:33:43,039 --> 00:33:45,440
which is first gen zen and we didn't try

946
00:33:45,440 --> 00:33:48,320
that yet on zen plus or zen ii systems

947
00:33:48,320 --> 00:33:51,039
also cpus which have multiple ccds and

948
00:33:51,039 --> 00:33:52,799
therefore multiple piece piece

949
00:33:52,799 --> 00:33:55,840
won't work right now but we also have

950
00:33:55,840 --> 00:33:57,279
the stable communication channel with

951
00:33:57,279 --> 00:33:59,279
the psp for further exploration you can

952
00:33:59,279 --> 00:34:00,480
use the uart

953
00:34:00,480 --> 00:34:04,880
or the fast spi flash emulator

954
00:34:04,880 --> 00:34:06,559
we also have a basic tool chain for

955
00:34:06,559 --> 00:34:07,919
writing and debugging your own code

956
00:34:07,919 --> 00:34:09,760
running on the psp

957
00:34:09,760 --> 00:34:12,079
and the i o log record and replay

958
00:34:12,079 --> 00:34:12,800
feature

959
00:34:12,800 --> 00:34:14,719
doesn't require access to real hardware

960
00:34:14,719 --> 00:34:17,119
for first steps

961
00:34:17,119 --> 00:34:19,119
last we also have a basic micro python

962
00:34:19,119 --> 00:34:20,719
port which runs on the psp

963
00:34:20,719 --> 00:34:22,800
so all the python fans out there can run

964
00:34:22,800 --> 00:34:25,199
python and embedded arm cpu inside

965
00:34:25,199 --> 00:34:28,319
their amd cpu

966
00:34:28,560 --> 00:34:30,239
so we still have a lot of room for

967
00:34:30,239 --> 00:34:32,399
improvement though our final goal is

968
00:34:32,399 --> 00:34:34,320
getting the real hardware to fully boot

969
00:34:34,320 --> 00:34:36,399
using our emulator

970
00:34:36,399 --> 00:34:38,960
for that we have to understand securis

971
00:34:38,960 --> 00:34:39,918
on ryzen

972
00:34:39,918 --> 00:34:42,000
and getting it to run properly in the

973
00:34:42,000 --> 00:34:43,760
emulator

974
00:34:43,760 --> 00:34:45,760
also for most cpus we have to emulate

975
00:34:45,760 --> 00:34:47,040
multiple

976
00:34:47,040 --> 00:34:49,839
ccds and psps which also require support

977
00:34:49,839 --> 00:34:51,440
in our staff to handle that on real

978
00:34:51,440 --> 00:34:52,960
hardware as well

979
00:34:52,960 --> 00:34:55,199
and we also want to investigate security

980
00:34:55,199 --> 00:34:57,040
as further looking for more security

981
00:34:57,040 --> 00:34:59,680
vulnerabilities

982
00:34:59,680 --> 00:35:03,440
also what we want to get working is

983
00:35:03,440 --> 00:35:05,520
the emulator working with zen plus and

984
00:35:05,520 --> 00:35:07,359
then two systems

985
00:35:07,359 --> 00:35:09,119
and last but not least then three is

986
00:35:09,119 --> 00:35:10,960
about to be released end of this year

987
00:35:10,960 --> 00:35:12,560
and we will see what kind of surprises

988
00:35:12,560 --> 00:35:16,400
it brings with it

989
00:35:16,400 --> 00:35:18,240
so if you are interested in getting

990
00:35:18,240 --> 00:35:20,079
yourself familiar with the emulator and

991
00:35:20,079 --> 00:35:21,680
want to run your own code

992
00:35:21,680 --> 00:35:23,599
here are all the main repositories of

993
00:35:23,599 --> 00:35:24,960
the components required

994
00:35:24,960 --> 00:35:28,240
everything is either mit or gpl

995
00:35:28,240 --> 00:35:29,599
and with that we thank you for your

996
00:35:29,599 --> 00:35:31,440
attention and should hopefully be open

997
00:35:31,440 --> 00:35:34,320
for questions now

998
00:35:36,800 --> 00:35:39,200
hi there

999
00:35:42,640 --> 00:35:45,520
hi um just a quick starters update

1000
00:35:45,520 --> 00:35:46,560
before we

1001
00:35:46,560 --> 00:35:49,520
start answering questions um so because

1002
00:35:49,520 --> 00:35:49,839
the

1003
00:35:49,839 --> 00:35:52,880
talk was pre-recorded uh we had some

1004
00:35:52,880 --> 00:35:55,040
time to develop the pc emulator further

1005
00:35:55,040 --> 00:35:55,280
and

1006
00:35:55,280 --> 00:35:57,359
right now uh we also added the mode

1007
00:35:57,359 --> 00:35:59,119
where we can run the uefi image for

1008
00:35:59,119 --> 00:36:01,119
example inside of virtualbox and forward

1009
00:36:01,119 --> 00:36:03,359
all the x86 hardware accesses

1010
00:36:03,359 --> 00:36:06,160
through the psp emulator um to the real

1011
00:36:06,160 --> 00:36:07,200
hardware so

1012
00:36:07,200 --> 00:36:11,359
we can also examine the ua5 firmware

1013
00:36:11,359 --> 00:36:15,040
and how it interacts with the psp

1014
00:36:16,960 --> 00:36:19,680
so feel free to ask any questions if you

1015
00:36:19,680 --> 00:36:21,200
have

1016
00:36:21,200 --> 00:36:23,119
so for the question is a proprietary

1017
00:36:23,119 --> 00:36:24,720
operating system running in psp

1018
00:36:24,720 --> 00:36:27,680
the offship bootloader is so everything

1019
00:36:27,680 --> 00:36:29,280
is proprietary the offshore bootloader

1020
00:36:29,280 --> 00:36:30,160
is not the real

1021
00:36:30,160 --> 00:36:32,160
operating system in the usual sense

1022
00:36:32,160 --> 00:36:34,960
because it has no scheduling and no

1023
00:36:34,960 --> 00:36:38,160
um virtual memory uh

1024
00:36:38,160 --> 00:36:40,400
and memory protection features as you

1025
00:36:40,400 --> 00:36:41,760
would normally find in an operating

1026
00:36:41,760 --> 00:36:42,560
system

1027
00:36:42,560 --> 00:36:46,400
um the secures on risen is kinibe

1028
00:36:46,400 --> 00:36:49,680
so it is a full-fledged trusted trust

1029
00:36:49,680 --> 00:36:50,720
zone based

1030
00:36:50,720 --> 00:36:54,240
operating system but we couldn't

1031
00:36:54,240 --> 00:36:58,560
uh have a deeper look into it right now

1032
00:37:01,760 --> 00:37:09,839
okay no questions

1033
00:37:19,280 --> 00:37:22,400
um the onshore bootloader we got through

1034
00:37:22,400 --> 00:37:25,839
uh the security bug which we explained

1035
00:37:25,839 --> 00:37:27,359
in the cows communication

1036
00:37:27,359 --> 00:37:29,119
communication congress talk from last

1037
00:37:29,119 --> 00:37:30,480
year and

1038
00:37:30,480 --> 00:37:32,720
we got into it using the offshoot

1039
00:37:32,720 --> 00:37:34,720
bootloader and then we're able to just

1040
00:37:34,720 --> 00:37:39,040
read out the high the last 64 kilobytes

1041
00:37:39,040 --> 00:37:40,800
of the four gigabyte address space

1042
00:37:40,800 --> 00:37:43,760
to to get at the bootloader because

1043
00:37:43,760 --> 00:37:45,119
there's not apparently no protection

1044
00:37:45,119 --> 00:37:46,000
there

1045
00:37:46,000 --> 00:37:51,839
again screening it

1046
00:38:02,839 --> 00:38:05,839
um

1047
00:38:20,160 --> 00:38:24,640
so yeah the the presentation was started

1048
00:38:24,640 --> 00:38:25,200
i guess

1049
00:38:25,200 --> 00:38:27,359
probably 10 minutes too early so that

1050
00:38:27,359 --> 00:38:28,640
was a technical issue

1051
00:38:28,640 --> 00:38:31,839
and uh sorry for that

1052
00:38:31,839 --> 00:38:34,320
the talk will be available on demand so

1053
00:38:34,320 --> 00:38:35,200
if you want to get

1054
00:38:35,200 --> 00:38:38,000
into the first 10 minutes or so you can

1055
00:38:38,000 --> 00:38:38,800
find them

1056
00:38:38,800 --> 00:38:42,079
later on the

1057
00:38:42,079 --> 00:38:45,200
cortex used inside the amd

1058
00:38:45,200 --> 00:39:01,839
cpu is a cortex a5

1059
00:39:52,079 --> 00:39:56,160
um so when the psp is booting

1060
00:39:56,160 --> 00:39:58,960
it won't make use of any trust and

1061
00:39:58,960 --> 00:39:59,520
features

1062
00:39:59,520 --> 00:40:01,440
features at all so that was not an issue

1063
00:40:01,440 --> 00:40:02,640
for emulation

1064
00:40:02,640 --> 00:40:06,160
of course later on when the uh secure os

1065
00:40:06,160 --> 00:40:09,040
takes over that one uses the trust on

1066
00:40:09,040 --> 00:40:09,599
features

1067
00:40:09,599 --> 00:40:12,640
and that was some technical problems

1068
00:40:12,640 --> 00:40:13,520
that we have to

1069
00:40:13,520 --> 00:40:16,079
had to overcome because our emulator is

1070
00:40:16,079 --> 00:40:17,680
based on unicorn

1071
00:40:17,680 --> 00:40:22,480
and it's not made to be a full system

1072
00:40:22,839 --> 00:40:25,839
emulator

1073
00:40:48,560 --> 00:40:51,440
not sure what you mean by work with amd

1074
00:40:51,440 --> 00:40:55,520
i mean we reported the issues we found

1075
00:40:55,520 --> 00:40:59,280
but that's about it we didn't have any

1076
00:40:59,280 --> 00:41:01,839
further contact with amd regarding our

1077
00:41:01,839 --> 00:41:04,160
work

1078
00:41:04,640 --> 00:41:07,760
so regarding the proxy mode um it

1079
00:41:07,760 --> 00:41:08,400
accesses

1080
00:41:08,400 --> 00:41:10,800
the the psp emulator through the spi

1081
00:41:10,800 --> 00:41:12,480
flash interface currently we have an

1082
00:41:12,480 --> 00:41:16,000
um spi flash emulator which also has a

1083
00:41:16,000 --> 00:41:17,760
call feature called hyper terminal so

1084
00:41:17,760 --> 00:41:19,520
you can essentially

1085
00:41:19,520 --> 00:41:22,560
exchange data between the spi

1086
00:41:22,560 --> 00:41:26,000
uh master and and the the spi flash

1087
00:41:26,000 --> 00:41:28,480
emulator itself and that is used as the

1088
00:41:28,480 --> 00:41:29,599
communication channel

1089
00:41:29,599 --> 00:41:31,680
because the psp also has access to the

1090
00:41:31,680 --> 00:41:33,040
x86

1091
00:41:33,040 --> 00:41:35,520
device and mmi oh space that also can

1092
00:41:35,520 --> 00:41:36,560
access the

1093
00:41:36,560 --> 00:41:38,560
legacy uart so we can also use the

1094
00:41:38,560 --> 00:41:41,839
legacy ui and serial port to access the

1095
00:41:41,839 --> 00:41:49,839
stop running on the psp itself

1096
00:42:12,319 --> 00:42:17,839
what's going on

1097
00:42:56,839 --> 00:42:59,839
so

1098
00:42:59,920 --> 00:43:02,480
yeah the torque was uh run 10 minutes

1099
00:43:02,480 --> 00:43:04,400
too early so it's not your fault that

1100
00:43:04,400 --> 00:43:13,839
you missed any of it

1101
00:43:19,760 --> 00:43:21,359
yes we are still using the emulator

1102
00:43:21,359 --> 00:43:24,960
right now because it's uh much faster so

1103
00:43:24,960 --> 00:43:27,119
we're using the emulator to get to the

1104
00:43:27,119 --> 00:43:29,440
uh initialized dram stage we

1105
00:43:29,440 --> 00:43:31,280
it takes a bit over five minutes and

1106
00:43:31,280 --> 00:43:32,640
with the serial

1107
00:43:32,640 --> 00:43:36,240
port we have already almost 45 minutes

1108
00:43:36,240 --> 00:43:39,520
and so the flash emulator is much faster

1109
00:43:39,520 --> 00:43:43,440
if you change something then to test it

1110
00:43:43,440 --> 00:43:46,319
but the the serial port is as stable as

1111
00:43:46,319 --> 00:43:47,599
the

1112
00:43:47,599 --> 00:43:49,200
flash emulator because there are

1113
00:43:49,200 --> 00:43:52,319
apparently no critical timeouts

1114
00:43:52,319 --> 00:43:56,240
during the initialization stage

1115
00:43:56,240 --> 00:44:09,839
of the off chipboard loader

1116
00:44:12,000 --> 00:44:15,359
so for zen 2 um

1117
00:44:15,359 --> 00:44:18,160
the overall firmware structure is

1118
00:44:18,160 --> 00:44:19,200
essentially the same

1119
00:44:19,200 --> 00:44:22,800
it looks like it's an uh the same

1120
00:44:22,800 --> 00:44:25,359
code base as used for first generation

1121
00:44:25,359 --> 00:44:26,240
zen

1122
00:44:26,240 --> 00:44:29,440
but the amd tightened up the security a

1123
00:44:29,440 --> 00:44:29,839
lot

1124
00:44:29,839 --> 00:44:34,160
so they're not too many issues

1125
00:44:34,160 --> 00:44:36,800
for example for for epic systems we did

1126
00:44:36,800 --> 00:44:38,079
not find any

1127
00:44:38,079 --> 00:44:42,400
uh exploitable security issues so far um

1128
00:44:42,400 --> 00:44:45,760
for verizon um it's a bit different

1129
00:44:45,760 --> 00:44:50,160
there are some issues um but um

1130
00:44:50,160 --> 00:44:52,480
not that many as we found in the first

1131
00:44:52,480 --> 00:44:53,359
generation

1132
00:44:53,359 --> 00:44:57,359
zen cpus overall the uh

1133
00:44:57,359 --> 00:45:00,480
security measures are much

1134
00:45:00,480 --> 00:45:03,119
harder much more but much better

1135
00:45:03,119 --> 00:45:04,880
implemented by amd than for first

1136
00:45:04,880 --> 00:45:06,079
generation

1137
00:45:06,079 --> 00:45:08,400
zen cpus but the firmware itself is

1138
00:45:08,400 --> 00:45:11,280
pretty much the same

1139
00:45:14,880 --> 00:45:17,440
[Music]

1140
00:45:17,440 --> 00:45:20,560
okay so because i the the poll close and

1141
00:45:20,560 --> 00:45:22,400
there were two

1142
00:45:22,400 --> 00:45:24,319
persons who said that they want to see a

1143
00:45:24,319 --> 00:45:26,079
demo i hope you can see my screen right

1144
00:45:26,079 --> 00:45:27,440
now so what we have here

1145
00:45:27,440 --> 00:45:30,000
is the emulator itself running with all

1146
00:45:30,000 --> 00:45:31,200
the

1147
00:45:31,200 --> 00:45:32,720
arguments required so what we will

1148
00:45:32,720 --> 00:45:34,720
showcase is our exploit

1149
00:45:34,720 --> 00:45:36,720
taking over the psp in this case the

1150
00:45:36,720 --> 00:45:38,160
emulated psp

1151
00:45:38,160 --> 00:45:41,200
and executing the psp stuff

1152
00:45:41,200 --> 00:45:43,760
below you have the gdp attached to the

1153
00:45:43,760 --> 00:45:45,280
emulator and on the right hand side you

1154
00:45:45,280 --> 00:45:46,160
will see the

1155
00:45:46,160 --> 00:45:48,800
um the trace log which is generated

1156
00:45:48,800 --> 00:45:49,839
while

1157
00:45:49,839 --> 00:45:53,119
the uh emulator executes the code and we

1158
00:45:53,119 --> 00:45:55,280
set a breakpoint to hex 100 so that is

1159
00:45:55,280 --> 00:45:57,200
the offship bootloader entry point

1160
00:45:57,200 --> 00:46:00,640
and we will just go with continue

1161
00:46:00,640 --> 00:46:03,920
and then at some point you will see a

1162
00:46:03,920 --> 00:46:05,359
lot of output which is a bit double

1163
00:46:05,359 --> 00:46:06,079
because you

1164
00:46:06,079 --> 00:46:09,280
need a bit wider a window for that

1165
00:46:09,280 --> 00:46:11,760
but you see here below we are in our

1166
00:46:11,760 --> 00:46:13,359
code

1167
00:46:13,359 --> 00:46:15,839
we can then set a breakpoint to the main

1168
00:46:15,839 --> 00:46:18,400
for example

1169
00:46:18,480 --> 00:46:21,440
so and it will execute um it's a bit

1170
00:46:21,440 --> 00:46:22,400
slow because it's

1171
00:46:22,400 --> 00:46:26,000
single stepping okay so and now we also

1172
00:46:26,000 --> 00:46:27,280
have source code debugging we can do

1173
00:46:27,280 --> 00:46:28,960
next for example we can

1174
00:46:28,960 --> 00:46:33,119
show register sorry not show

1175
00:46:33,119 --> 00:46:35,839
info registers um you can see the call

1176
00:46:35,839 --> 00:46:36,720
stack

1177
00:46:36,720 --> 00:46:40,480
and then we can evaluate the firmware so

1178
00:46:40,480 --> 00:46:41,839
with the normal film you of course have

1179
00:46:41,839 --> 00:46:43,520
no source code access but

1180
00:46:43,520 --> 00:46:45,359
uh you can step through the disassembly

1181
00:46:45,359 --> 00:46:46,720
and so on and do

1182
00:46:46,720 --> 00:46:48,319
all kinds of things like changing

1183
00:46:48,319 --> 00:46:49,839
registers and

1184
00:46:49,839 --> 00:46:52,160
changing memory and we also have a quite

1185
00:46:52,160 --> 00:46:54,839
a few uh

1186
00:46:54,839 --> 00:46:57,839
special uh commands for the debugger

1187
00:46:57,839 --> 00:46:59,599
which is accessible through the monitor

1188
00:46:59,599 --> 00:47:02,880
uh gb command for uh for uh

1189
00:47:02,880 --> 00:47:06,000
yeah which is specific to the uh

1190
00:47:06,000 --> 00:47:08,160
psp itself so and if you're on proxy

1191
00:47:08,160 --> 00:47:10,240
mode you can also have a lot of more

1192
00:47:10,240 --> 00:47:12,160
a few more commands when you can for

1193
00:47:12,160 --> 00:47:14,480
example from gdp access the smn network

1194
00:47:14,480 --> 00:47:16,480
directly or mmi o space

1195
00:47:16,480 --> 00:47:21,280
or the x86 um address based

1196
00:47:21,280 --> 00:47:24,880
on the real hardware itself

1197
00:47:24,880 --> 00:47:27,040
so

1198
00:47:29,440 --> 00:47:33,119
so maybe um this is what what was also

1199
00:47:33,119 --> 00:47:34,480
shown in the

1200
00:47:34,480 --> 00:47:36,559
in the presentation so this is where our

1201
00:47:36,559 --> 00:47:39,200
exploit kicks in when the

1202
00:47:39,200 --> 00:47:42,240
uh onshore bootloader tri while the um

1203
00:47:42,240 --> 00:47:44,079
the entry bootloader passes the header

1204
00:47:44,079 --> 00:47:45,440
and then tries to copy the offshore

1205
00:47:45,440 --> 00:47:46,960
buddha into sram and

1206
00:47:46,960 --> 00:47:50,720
just uses our our own size and then it

1207
00:47:50,720 --> 00:47:53,119
overwrites the on-chip bootloader stack

1208
00:47:53,119 --> 00:47:54,640
with our return address which is the

1209
00:47:54,640 --> 00:47:56,960
entry point to our

1210
00:47:56,960 --> 00:47:59,520
stop which then takes over the execution

1211
00:47:59,520 --> 00:48:02,240
on the psp

1212
00:48:03,760 --> 00:48:06,079
for the proxy mode demo we apparently

1213
00:48:06,079 --> 00:48:07,920
won't have the time right now because

1214
00:48:07,920 --> 00:48:21,839
it takes a moment to set up everything

1215
00:49:24,910 --> 00:49:28,219
[Music]

1216
00:49:35,119 --> 00:49:37,760
well uh regarding that question if we

1217
00:49:37,760 --> 00:49:39,040
can take control

1218
00:49:39,040 --> 00:49:41,839
we could also then just patch the

1219
00:49:41,839 --> 00:49:43,200
offshore bootloader

1220
00:49:43,200 --> 00:49:46,800
for example to do whatever we want so it

1221
00:49:46,800 --> 00:49:50,400
might continue and then we we might be

1222
00:49:50,400 --> 00:49:51,040
able

1223
00:49:51,040 --> 00:49:53,119
at least on on epic systems for example

1224
00:49:53,119 --> 00:49:54,640
to to then

1225
00:49:54,640 --> 00:49:57,280
uh look be uh in the background and that

1226
00:49:57,280 --> 00:49:59,200
respond maybe to a special write and

1227
00:49:59,200 --> 00:50:01,599
dram and then do some stuff

1228
00:50:01,599 --> 00:50:04,720
if the x86 cpus uh

1229
00:50:04,720 --> 00:50:07,520
poke that specific address on on risen

1230
00:50:07,520 --> 00:50:08,880
it's a bit harder because

1231
00:50:08,880 --> 00:50:11,760
uh the cqrs takes over the sram and we

1232
00:50:11,760 --> 00:50:12,079
don't

1233
00:50:12,079 --> 00:50:15,760
have that much knowledge about securis

1234
00:50:15,760 --> 00:50:18,160
right now

1235
00:50:20,000 --> 00:50:22,480
yeah but as for security measures as we

1236
00:50:22,480 --> 00:50:24,839
have now code execution on the psp

1237
00:50:24,839 --> 00:50:27,280
itself uh in theory there's nothing that

1238
00:50:27,280 --> 00:50:28,640
can stop us from

1239
00:50:28,640 --> 00:50:30,880
doing anything we want with the system

1240
00:50:30,880 --> 00:50:32,559
because the psp is the root of trust for

1241
00:50:32,559 --> 00:50:34,079
the whole

1242
00:50:34,079 --> 00:50:37,359
amd cpu so if that is taken over it's

1243
00:50:37,359 --> 00:50:39,359
game over for any security feature later

1244
00:50:39,359 --> 00:50:41,839
on

1245
00:50:46,240 --> 00:50:49,520
so regarding the evil mate attack um

1246
00:50:49,520 --> 00:50:52,400
yeah you just need to flash the spi

1247
00:50:52,400 --> 00:50:52,880
image

1248
00:50:52,880 --> 00:50:55,280
onto onto the on on the main board and

1249
00:50:55,280 --> 00:50:57,680
then you can get access to the psp

1250
00:50:57,680 --> 00:51:00,640
at least for the uh first generation zen

1251
00:51:00,640 --> 00:51:00,960
and

1252
00:51:00,960 --> 00:51:04,400
um also zen plus systems uh

1253
00:51:04,400 --> 00:51:08,559
so yeah you could put some backdoor

1254
00:51:08,559 --> 00:51:12,240
onto the psp

1255
00:51:15,920 --> 00:51:19,209
[Music]

1256
00:51:21,599 --> 00:51:23,680
we didn't had a look at the tegra

1257
00:51:23,680 --> 00:51:26,000
exploit for the nintendo switch actually

1258
00:51:26,000 --> 00:51:29,280
yeah but thanks for for the hint uh

1259
00:51:29,280 --> 00:51:32,559
we can we will have a look at this later

1260
00:51:32,559 --> 00:51:33,119
and then

1261
00:51:33,119 --> 00:51:37,839
see what kind of similarities they share

1262
00:51:40,000 --> 00:51:42,240
[Music]

1263
00:51:42,240 --> 00:51:45,359
similar attacks for amd cpus or in

1264
00:51:45,359 --> 00:51:46,319
general

1265
00:51:46,319 --> 00:51:48,559
i mean probably in general there are

1266
00:51:48,559 --> 00:51:50,480
similar bugs but

1267
00:51:50,480 --> 00:51:52,480
intel me for example had bucks in the

1268
00:51:52,480 --> 00:51:53,760
past which

1269
00:51:53,760 --> 00:51:57,200
allowed third parties to gain code

1270
00:51:57,200 --> 00:51:58,160
execution on

1271
00:51:58,160 --> 00:52:01,920
on their embedded me engine

1272
00:52:01,920 --> 00:52:06,319
and for a lot of smartphone trust zones

1273
00:52:06,319 --> 00:52:09,040
um which are which are mostly based on

1274
00:52:09,040 --> 00:52:09,440
arm

1275
00:52:09,440 --> 00:52:12,160
and there were also a lot of similar

1276
00:52:12,160 --> 00:52:13,680
things in the past where you could take

1277
00:52:13,680 --> 00:52:15,520
over the boot process and then put your

1278
00:52:15,520 --> 00:52:16,640
own code and

1279
00:52:16,640 --> 00:52:19,440
into the the trusted uh context of the

1280
00:52:19,440 --> 00:52:21,920
cpu

1281
00:52:22,720 --> 00:52:24,319
uh the spi flash is actually on the

1282
00:52:24,319 --> 00:52:26,079
mainboard because the the motherboard

1283
00:52:26,079 --> 00:52:27,920
vendor has to

1284
00:52:27,920 --> 00:52:30,720
supply their own uefi image because they

1285
00:52:30,720 --> 00:52:32,880
tailor towards their own hardware they

1286
00:52:32,880 --> 00:52:34,800
build on the main board

1287
00:52:34,800 --> 00:52:38,960
um but the uh the offshore bootloader

1288
00:52:38,960 --> 00:52:40,240
and the on-chip boot uh so the

1289
00:52:40,240 --> 00:52:42,720
entrepreneur is baked into the cpu

1290
00:52:42,720 --> 00:52:45,040
itself so that is always vulnerable if

1291
00:52:45,040 --> 00:52:46,640
you have an affected cpu

1292
00:52:46,640 --> 00:52:49,359
and the offshoot booth is supplied by

1293
00:52:49,359 --> 00:52:51,200
amd through their igesa

1294
00:52:51,200 --> 00:52:53,359
code blob and is then integrated by the

1295
00:52:53,359 --> 00:52:54,960
firmware window so

1296
00:52:54,960 --> 00:52:57,520
if you have a bug there you will

1297
00:52:57,520 --> 00:52:58,480
probably have a bug

1298
00:52:58,480 --> 00:53:01,040
in all the other main boards which share

1299
00:53:01,040 --> 00:53:02,240
the same version of the

1300
00:53:02,240 --> 00:53:15,839
giza code

1301
00:53:24,160 --> 00:53:28,160
so so i think our time is almost up

1302
00:53:28,160 --> 00:53:31,839
um but uh alex and i will be

1303
00:53:31,839 --> 00:53:34,319
reachable through the black cat system i

1304
00:53:34,319 --> 00:53:35,920
believe so if you have any further

1305
00:53:35,920 --> 00:53:38,480
questions feel free to to ask us

1306
00:53:38,480 --> 00:53:41,119
and if you try out i mean emulator um

1307
00:53:41,119 --> 00:53:42,400
and find any issues

1308
00:53:42,400 --> 00:53:44,319
please file a report on github that

1309
00:53:44,319 --> 00:53:45,839
would really help us

1310
00:53:45,839 --> 00:53:57,839
in developing this emulator further

1311
00:53:58,640 --> 00:54:02,559
so the the thing is the spi

1312
00:54:02,559 --> 00:54:06,160
um has to be what we do is we flash our

1313
00:54:06,160 --> 00:54:06,960
own

1314
00:54:06,960 --> 00:54:10,160
code on the spi attached flash chip

1315
00:54:10,160 --> 00:54:12,559
now if you can protect it put it in the

1316
00:54:12,559 --> 00:54:13,920
case or something

1317
00:54:13,920 --> 00:54:16,640
well there is some protection there but

1318
00:54:16,640 --> 00:54:18,240
it's a physical projection right if you

1319
00:54:18,240 --> 00:54:18,559
can

1320
00:54:18,559 --> 00:54:21,599
again access the sbi bus

1321
00:54:21,599 --> 00:54:24,960
which is used by the cpu then you can

1322
00:54:24,960 --> 00:54:28,000
mount this uh exploit and there is no

1323
00:54:28,000 --> 00:54:30,559
rollback prevention for the firmware as

1324
00:54:30,559 --> 00:54:32,000
of zen and zen plus

1325
00:54:32,000 --> 00:54:34,960
for the zen 2 also i'm not too sure i

1326
00:54:34,960 --> 00:54:36,240
don't think so actually

1327
00:54:36,240 --> 00:54:38,799
so so you can always flash a vulnerable

1328
00:54:38,799 --> 00:54:40,880
version of the agiza code and then get

1329
00:54:40,880 --> 00:54:53,839
access on the psp itself

1330
00:55:11,040 --> 00:55:14,079
okay so thanks again for joining

1331
00:55:14,079 --> 00:55:16,799
our talk and if you as robert already

1332
00:55:16,799 --> 00:55:18,480
mentioned if you have any questions uh

1333
00:55:18,480 --> 00:55:20,000
feel free to contact us through the

1334
00:55:20,000 --> 00:55:21,839
blackhead

1335
00:55:21,839 --> 00:55:28,558
website and we will then respond

