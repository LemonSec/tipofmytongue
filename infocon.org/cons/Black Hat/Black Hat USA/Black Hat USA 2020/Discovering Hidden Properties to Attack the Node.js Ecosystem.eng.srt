1
00:00:03,910 --> 00:00:13,710
[Music]

2
00:00:14,719 --> 00:00:15,759
hi everyone

3
00:00:15,759 --> 00:00:18,080
my name is fun xiao from georgia tech so

4
00:00:18,080 --> 00:00:19,920
this is not only my work but also the

5
00:00:19,920 --> 00:00:21,680
work of my wonderful co-workers from

6
00:00:21,680 --> 00:00:23,199
georgia tech and texas a

7
00:00:23,199 --> 00:00:25,760
m so today i'm going to talk about some

8
00:00:25,760 --> 00:00:28,840
interesting new attack in node.js

9
00:00:28,840 --> 00:00:30,080
ecosystems

10
00:00:30,080 --> 00:00:32,320
before the talk normally begins please

11
00:00:32,320 --> 00:00:34,719
let me introduce myself a little more

12
00:00:34,719 --> 00:00:38,000
so i'm a csd phd phd student at georgia

13
00:00:38,000 --> 00:00:38,640
tech

14
00:00:38,640 --> 00:00:41,040
and i'm a vulnerability researcher my

15
00:00:41,040 --> 00:00:43,120
research is about building tools to

16
00:00:43,120 --> 00:00:44,239
automatically

17
00:00:44,239 --> 00:00:46,719
detect and exploit zero days so that

18
00:00:46,719 --> 00:00:48,480
people can be aware of both the

19
00:00:48,480 --> 00:00:49,440
existence

20
00:00:49,440 --> 00:00:51,120
and the consequence of their security

21
00:00:51,120 --> 00:00:54,559
bugs so i do research in web application

22
00:00:54,559 --> 00:00:57,039
security but i'm also enjoying

23
00:00:57,039 --> 00:00:58,800
researching security problems

24
00:00:58,800 --> 00:01:01,280
in other areas such as software defining

25
00:01:01,280 --> 00:01:02,239
networks

26
00:01:02,239 --> 00:01:06,080
and x86 virtualizations

27
00:01:06,080 --> 00:01:08,320
okay so these are the topics i'm going

28
00:01:08,320 --> 00:01:10,560
to cover today

29
00:01:10,560 --> 00:01:12,240
the talk will be divided into three

30
00:01:12,240 --> 00:01:14,720
parts first i will introduce the

31
00:01:14,720 --> 00:01:16,880
technical details of the new security

32
00:01:16,880 --> 00:01:18,640
risks we discovered

33
00:01:18,640 --> 00:01:22,080
and discussed how to exploit it and then

34
00:01:22,080 --> 00:01:24,159
we will talk more about the bug finding

35
00:01:24,159 --> 00:01:26,560
part which is about the lessons and

36
00:01:26,560 --> 00:01:28,799
insights from building such a javascript

37
00:01:28,799 --> 00:01:31,119
security analysis tools

38
00:01:31,119 --> 00:01:33,920
and in the end we will give up impact

39
00:01:33,920 --> 00:01:35,600
analyze of our discovered

40
00:01:35,600 --> 00:01:36,799
vulnerabilities

41
00:01:36,799 --> 00:01:39,680
and have some evaluation data on our new

42
00:01:39,680 --> 00:01:42,079
tools

43
00:01:42,560 --> 00:01:45,439
so first of all please let let's take a

44
00:01:45,439 --> 00:01:46,720
quick look at the one new

45
00:01:46,720 --> 00:01:48,479
vulnerabilities we found

46
00:01:48,479 --> 00:01:50,640
in total we found 13 zero-day

47
00:01:50,640 --> 00:01:52,399
vulnerabilities from widely used

48
00:01:52,399 --> 00:01:53,360
programs

49
00:01:53,360 --> 00:01:56,159
many of them have more than 1 million of

50
00:01:56,159 --> 00:01:57,200
downloads

51
00:01:57,200 --> 00:01:59,840
such as mongodb official drivers class

52
00:01:59,840 --> 00:02:00,719
validators

53
00:02:00,719 --> 00:02:04,159
and so on so this bugs can be exploited

54
00:02:04,159 --> 00:02:04,799
to launch

55
00:02:04,799 --> 00:02:07,920
serious attack effects such as leaking

56
00:02:07,920 --> 00:02:10,160
credential user data

57
00:02:10,160 --> 00:02:12,319
by passing security checks and deny of

58
00:02:12,319 --> 00:02:14,640
services yeah so this is pretty much the

59
00:02:14,640 --> 00:02:17,360
big picture of our research

60
00:02:17,360 --> 00:02:19,599
okay so before we touch the technical

61
00:02:19,599 --> 00:02:20,640
detail

62
00:02:20,640 --> 00:02:22,640
let's have some little background about

63
00:02:22,640 --> 00:02:25,440
the node.js

64
00:02:25,680 --> 00:02:28,560
node.js is used is used for executing

65
00:02:28,560 --> 00:02:29,280
javascript

66
00:02:29,280 --> 00:02:31,920
outside of browsers the picture on the

67
00:02:31,920 --> 00:02:32,400
right

68
00:02:32,400 --> 00:02:34,959
is the overall system design of the

69
00:02:34,959 --> 00:02:36,239
node.js

70
00:02:36,239 --> 00:02:39,040
to interpret and execute javascript the

71
00:02:39,040 --> 00:02:41,120
node.js implements a runtime

72
00:02:41,120 --> 00:02:44,959
execution engine on top of chrome ev8

73
00:02:44,959 --> 00:02:47,440
to satisfy the needs of server-side

74
00:02:47,440 --> 00:02:48,959
civic scenarios

75
00:02:48,959 --> 00:02:51,360
java the runtime also provides a set of

76
00:02:51,360 --> 00:02:52,319
apis

77
00:02:52,319 --> 00:02:54,959
to let javascript interact with the host

78
00:02:54,959 --> 00:02:56,319
environment

79
00:02:56,319 --> 00:02:58,640
with the provided apis the javascript

80
00:02:58,640 --> 00:03:01,200
code can access the host environments

81
00:03:01,200 --> 00:03:03,599
like any other server-side languages for

82
00:03:03,599 --> 00:03:04,720
example

83
00:03:04,720 --> 00:03:08,080
they can read and write file systems

84
00:03:08,080 --> 00:03:11,440
and or execute system command so node.js

85
00:03:11,440 --> 00:03:14,080
is pretty powerful

86
00:03:14,080 --> 00:03:16,800
nowadays many websites are deployed in

87
00:03:16,800 --> 00:03:17,760
node.js

88
00:03:17,760 --> 00:03:20,480
for example node.js are intensively used

89
00:03:20,480 --> 00:03:21,360
in companies

90
00:03:21,360 --> 00:03:24,640
like linking and paypal and also we are

91
00:03:24,640 --> 00:03:27,040
using a lot of electron apps

92
00:03:27,040 --> 00:03:29,360
and search electron apps are also

93
00:03:29,360 --> 00:03:33,280
powered by node.js runtimes

94
00:03:33,280 --> 00:03:35,440
web-based applications are the most

95
00:03:35,440 --> 00:03:38,239
common types of node.js programs

96
00:03:38,239 --> 00:03:41,120
for these web web-based applications

97
00:03:41,120 --> 00:03:43,200
packing the communication data into

98
00:03:43,200 --> 00:03:47,760
object representation is really common

99
00:03:47,760 --> 00:03:49,920
so this feature is convenient and very

100
00:03:49,920 --> 00:03:50,879
powerful

101
00:03:50,879 --> 00:03:53,200
with the help of this feature node.js

102
00:03:53,200 --> 00:03:54,640
applications can send

103
00:03:54,640 --> 00:03:58,319
or receive very complex data structures

104
00:03:58,319 --> 00:04:00,799
from monthly downloads statistics on the

105
00:04:00,799 --> 00:04:02,640
right we can have a sense of

106
00:04:02,640 --> 00:04:04,959
how object sharing is being supported

107
00:04:04,959 --> 00:04:05,680
and used

108
00:04:05,680 --> 00:04:09,760
by the node.js ecosystems

109
00:04:10,879 --> 00:04:13,360
so the diagram demonstrates how the

110
00:04:13,360 --> 00:04:15,680
object sharing is being used

111
00:04:15,680 --> 00:04:18,399
in node.js ecosystem there are two major

112
00:04:18,399 --> 00:04:20,560
methods of serializing communication

113
00:04:20,560 --> 00:04:21,440
objects

114
00:04:21,440 --> 00:04:23,840
which is the query stream based sharing

115
00:04:23,840 --> 00:04:26,160
and the json-based sharing

116
00:04:26,160 --> 00:04:28,240
as shown in the picture if the user

117
00:04:28,240 --> 00:04:30,560
wants to update the age information in

118
00:04:30,560 --> 00:04:32,080
his website

119
00:04:32,080 --> 00:04:35,520
he may do this in two in two ways first

120
00:04:35,520 --> 00:04:38,240
it can send his data through through the

121
00:04:38,240 --> 00:04:41,120
standard query string in the url

122
00:04:41,120 --> 00:04:43,600
and also he can send a json screen

123
00:04:43,600 --> 00:04:44,160
stream

124
00:04:44,160 --> 00:04:46,560
to the server in some somewhere such as

125
00:04:46,560 --> 00:04:48,560
the post body

126
00:04:48,560 --> 00:04:51,040
upon receiving the request the node.js

127
00:04:51,040 --> 00:04:52,000
server

128
00:04:52,000 --> 00:04:54,720
will pass the request and pass the data

129
00:04:54,720 --> 00:04:56,080
into an object

130
00:04:56,080 --> 00:04:58,320
so the object can further propagate into

131
00:04:58,320 --> 00:05:01,840
the corresponding logics in the program

132
00:05:01,840 --> 00:05:05,120
okay so this is basically how node.js

133
00:05:05,120 --> 00:05:06,960
object sharing is carried out

134
00:05:06,960 --> 00:05:08,880
usually we want to if we want to

135
00:05:08,880 --> 00:05:11,759
evaluate the security of such a program

136
00:05:11,759 --> 00:05:13,680
we may usu may inject a different

137
00:05:13,680 --> 00:05:15,520
payloads into the age field

138
00:05:15,520 --> 00:05:17,680
to trigger potential vulnerabilities

139
00:05:17,680 --> 00:05:19,600
such as cycle injection

140
00:05:19,600 --> 00:05:22,800
or crosses grips

141
00:05:22,800 --> 00:05:25,280
but what if we choose not to test the

142
00:05:25,280 --> 00:05:27,199
existing data fields

143
00:05:27,199 --> 00:05:29,360
since we can pass an object into the

144
00:05:29,360 --> 00:05:30,400
server

145
00:05:30,400 --> 00:05:32,720
what will happen if we inject additional

146
00:05:32,720 --> 00:05:33,520
properties

147
00:05:33,520 --> 00:05:36,639
into the program which is not expected

148
00:05:36,639 --> 00:05:38,240
by the server program

149
00:05:38,240 --> 00:05:40,560
in particular if an attacker can send

150
00:05:40,560 --> 00:05:41,919
properties that forge

151
00:05:41,919 --> 00:05:44,639
or override certain internal states the

152
00:05:44,639 --> 00:05:46,800
attacker may easily obtain dangerous

153
00:05:46,800 --> 00:05:47,600
abilities

154
00:05:47,600 --> 00:05:49,919
such as manipulating the key logics of

155
00:05:49,919 --> 00:05:52,479
the program

156
00:05:52,479 --> 00:05:55,360
so what we are going to introduce is the

157
00:05:55,360 --> 00:05:56,479
hidden property

158
00:05:56,479 --> 00:05:59,680
abusing which we called hpa

159
00:05:59,680 --> 00:06:01,919
hpa leverage the object sharing in

160
00:06:01,919 --> 00:06:03,199
node.js

161
00:06:03,199 --> 00:06:06,000
to forge or temper critical program

162
00:06:06,000 --> 00:06:08,800
states in the node.js applications

163
00:06:08,800 --> 00:06:11,199
we called these additional properties we

164
00:06:11,199 --> 00:06:13,039
injected as hidden property

165
00:06:13,039 --> 00:06:15,039
because these properties are kind of

166
00:06:15,039 --> 00:06:16,160
like some hidden

167
00:06:16,160 --> 00:06:19,120
parameters valid to the endpoint user

168
00:06:19,120 --> 00:06:20,160
api

169
00:06:20,160 --> 00:06:22,400
these parameters are associated with

170
00:06:22,400 --> 00:06:24,160
certain internal states

171
00:06:24,160 --> 00:06:26,639
however nobody knows their existence

172
00:06:26,639 --> 00:06:28,560
until an attacker

173
00:06:28,560 --> 00:06:30,560
find it and exploit it to temper

174
00:06:30,560 --> 00:06:32,400
internal states

175
00:06:32,400 --> 00:06:34,160
in this talk we mainly focus on the

176
00:06:34,160 --> 00:06:35,600
server-side scenarios

177
00:06:35,600 --> 00:06:38,800
where a remote attacker wants to hack a

178
00:06:38,800 --> 00:06:40,400
node.js web application

179
00:06:40,400 --> 00:06:43,840
or some microservices thus to explore

180
00:06:43,840 --> 00:06:44,960
the vulnerabilities

181
00:06:44,960 --> 00:06:47,280
the attacker access the legitimate the

182
00:06:47,280 --> 00:06:48,000
interface

183
00:06:48,000 --> 00:06:50,080
such as the web endpoint to send his

184
00:06:50,080 --> 00:06:52,560
payload

185
00:06:52,880 --> 00:06:55,680
in most cases the payload should be in

186
00:06:55,680 --> 00:06:56,800
the plan type

187
00:06:56,800 --> 00:06:59,120
plan objects which is the simplest

188
00:06:59,120 --> 00:07:00,960
object representations

189
00:07:00,960 --> 00:07:03,440
which only support the primitive types

190
00:07:03,440 --> 00:07:05,120
we have these restrictions

191
00:07:05,120 --> 00:07:07,919
because the plan object types is the

192
00:07:07,919 --> 00:07:10,240
most widely supported object types

193
00:07:10,240 --> 00:07:13,360
in node.js object sharing

194
00:07:13,360 --> 00:07:15,520
okay so during our research we

195
00:07:15,520 --> 00:07:18,319
discovered two types of attack vectors

196
00:07:18,319 --> 00:07:20,800
we call the first one as app-specific

197
00:07:20,800 --> 00:07:23,520
attribute manipulation

198
00:07:23,520 --> 00:07:25,680
this one is for manipulating certain

199
00:07:25,680 --> 00:07:27,440
internal properties defined by the

200
00:07:27,440 --> 00:07:29,360
application themselves

201
00:07:29,360 --> 00:07:31,599
such internal properties are supposed to

202
00:07:31,599 --> 00:07:34,080
be initialized and managed by the some

203
00:07:34,080 --> 00:07:35,680
internal functions

204
00:07:35,680 --> 00:07:37,599
and they usually represent certain

205
00:07:37,599 --> 00:07:39,599
internal states of the programs

206
00:07:39,599 --> 00:07:42,720
as shown in the picture the the init row

207
00:07:42,720 --> 00:07:43,280
is an

208
00:07:43,280 --> 00:07:45,280
internal function that are responsible

209
00:07:45,280 --> 00:07:47,120
for managing the access right

210
00:07:47,120 --> 00:07:51,440
of the user object however with hba

211
00:07:51,440 --> 00:07:53,520
attackers can propagate a conflicting

212
00:07:53,520 --> 00:07:56,160
name properly into the user object

213
00:07:56,160 --> 00:07:58,800
and thus control the internal states as

214
00:07:58,800 --> 00:08:00,319
shown in the program

215
00:08:00,319 --> 00:08:02,960
the program also provided an api called

216
00:08:02,960 --> 00:08:04,400
update

217
00:08:04,400 --> 00:08:08,720
in external usage if malicious

218
00:08:08,720 --> 00:08:11,440
malicious user injected his payload

219
00:08:11,440 --> 00:08:13,759
which is a additional key value pair

220
00:08:13,759 --> 00:08:17,199
into his request then the

221
00:08:17,199 --> 00:08:19,199
additional keyword appear probably will

222
00:08:19,199 --> 00:08:20,479
overwrite the

223
00:08:20,479 --> 00:08:23,520
existing data on the user object

224
00:08:23,520 --> 00:08:26,160
so this attack vector is really useful

225
00:08:26,160 --> 00:08:27,599
when we want to abuse

226
00:08:27,599 --> 00:08:29,840
certain concrete logics in large

227
00:08:29,840 --> 00:08:30,879
programs

228
00:08:30,879 --> 00:08:33,599
such as order states or user privilege

229
00:08:33,599 --> 00:08:36,000
management

230
00:08:36,000 --> 00:08:39,440
also hpa can also target as some unique

231
00:08:39,440 --> 00:08:40,320
javascript

232
00:08:40,320 --> 00:08:43,440
schemes such as prototyping we call the

233
00:08:43,440 --> 00:08:45,120
second attack scenario

234
00:08:45,120 --> 00:08:48,160
as prototype inheritance hijacking

235
00:08:48,160 --> 00:08:51,600
in javascript every object has a link to

236
00:08:51,600 --> 00:08:53,440
a prototype object

237
00:08:53,440 --> 00:08:55,839
when the when the javascript code wants

238
00:08:55,839 --> 00:08:56,480
to

239
00:08:56,480 --> 00:08:58,720
access on property of an object the

240
00:08:58,720 --> 00:09:00,640
property will not only be searched

241
00:09:00,640 --> 00:09:02,800
within the object itself

242
00:09:02,800 --> 00:09:05,040
but also the prototype of the object and

243
00:09:05,040 --> 00:09:07,440
even the prototype of the prototype

244
00:09:07,440 --> 00:09:09,920
until a property with a matching name is

245
00:09:09,920 --> 00:09:11,360
found

246
00:09:11,360 --> 00:09:13,120
as shown in the picture when the

247
00:09:13,120 --> 00:09:15,040
javascript code wants to

248
00:09:15,040 --> 00:09:17,120
access the constructor property from the

249
00:09:17,120 --> 00:09:18,240
input object

250
00:09:18,240 --> 00:09:20,720
it will first search locally within the

251
00:09:20,720 --> 00:09:22,080
input object

252
00:09:22,080 --> 00:09:23,839
since there is no probably named

253
00:09:23,839 --> 00:09:25,120
constructor there

254
00:09:25,120 --> 00:09:27,360
the code will continue its search to its

255
00:09:27,360 --> 00:09:28,320
prototype

256
00:09:28,320 --> 00:09:32,320
where the constructor is really located

257
00:09:33,200 --> 00:09:35,839
with hpa we can hijack the inheritance

258
00:09:35,839 --> 00:09:36,480
chains

259
00:09:36,480 --> 00:09:38,480
and forge our own payload as our

260
00:09:38,480 --> 00:09:40,720
internal properties on the chain

261
00:09:40,720 --> 00:09:43,279
as shown in the picture if we inject a

262
00:09:43,279 --> 00:09:45,200
property named constructor

263
00:09:45,200 --> 00:09:46,959
the searching process will be really

264
00:09:46,959 --> 00:09:49,360
different since there is already a

265
00:09:49,360 --> 00:09:51,360
property named constructor within the

266
00:09:51,360 --> 00:09:52,480
input object

267
00:09:52,480 --> 00:09:55,519
the search will immediately stopped and

268
00:09:55,519 --> 00:09:57,680
end up written returning a user

269
00:09:57,680 --> 00:09:59,279
controlled value

270
00:09:59,279 --> 00:10:01,920
as demonstrated by the red circle here

271
00:10:01,920 --> 00:10:03,760
the value of the constructor will become

272
00:10:03,760 --> 00:10:04,000
the

273
00:10:04,000 --> 00:10:06,720
string rig and multi rather than a

274
00:10:06,720 --> 00:10:09,920
normal javascript prototype function

275
00:10:09,920 --> 00:10:12,240
so the second attack vector is very

276
00:10:12,240 --> 00:10:13,200
useful

277
00:10:13,200 --> 00:10:15,040
because we found many javascript

278
00:10:15,040 --> 00:10:17,440
developers tend to trust the properties

279
00:10:17,440 --> 00:10:18,000
inherited

280
00:10:18,000 --> 00:10:20,560
from prototypes and they also make many

281
00:10:20,560 --> 00:10:21,519
security

282
00:10:21,519 --> 00:10:23,680
sensitive disease decisions based on

283
00:10:23,680 --> 00:10:25,360
them

284
00:10:25,360 --> 00:10:27,760
also we should be aware of the

285
00:10:27,760 --> 00:10:29,440
differences between the prototype

286
00:10:29,440 --> 00:10:30,160
pollution

287
00:10:30,160 --> 00:10:34,640
and the prototype inheritance hijacking

288
00:10:34,640 --> 00:10:37,440
so prototype pollution as the name

289
00:10:37,440 --> 00:10:38,480
suggested

290
00:10:38,480 --> 00:10:41,200
is about attacking and tempering the

291
00:10:41,200 --> 00:10:42,800
prototype objects

292
00:10:42,800 --> 00:10:45,360
however our attack vectors does not

293
00:10:45,360 --> 00:10:47,040
modify the object

294
00:10:47,040 --> 00:10:50,160
the prototype object

295
00:10:50,399 --> 00:10:53,440
so the root cause of hpa is that the

296
00:10:53,440 --> 00:10:54,160
node.js

297
00:10:54,160 --> 00:10:57,519
fails to isolate the unsafe objects such

298
00:10:57,519 --> 00:10:59,600
as user input from

299
00:10:59,600 --> 00:11:02,880
critical internal states to make a clear

300
00:11:02,880 --> 00:11:05,600
demonstration the hpa can be seen as a

301
00:11:05,600 --> 00:11:07,440
new security risk

302
00:11:07,440 --> 00:11:10,399
under the weakness category 915 whose

303
00:11:10,399 --> 00:11:12,800
child variants are all about

304
00:11:12,800 --> 00:11:16,640
improper modification of dynamic objects

305
00:11:16,640 --> 00:11:18,720
as shown in the pic in the hierarchy

306
00:11:18,720 --> 00:11:19,839
tree on the right

307
00:11:19,839 --> 00:11:22,079
there are some similar issues on the

308
00:11:22,079 --> 00:11:22,880
other language

309
00:11:22,880 --> 00:11:25,680
platform such as ruby mass assignment

310
00:11:25,680 --> 00:11:28,240
and php object injections

311
00:11:28,240 --> 00:11:30,399
although these variants share the same

312
00:11:30,399 --> 00:11:33,440
behavior feature dominated by 915

313
00:11:33,440 --> 00:11:35,440
they all have their own patterns due to

314
00:11:35,440 --> 00:11:37,839
the language differences

315
00:11:37,839 --> 00:11:40,399
for example the ruby mass assignment is

316
00:11:40,399 --> 00:11:42,480
a set of vulnerabilities discussed and

317
00:11:42,480 --> 00:11:44,880
invited to use the ruby web framework

318
00:11:44,880 --> 00:11:48,560
called ruby on rails unlike hpa

319
00:11:48,560 --> 00:11:51,279
the attacker does not pass objects into

320
00:11:51,279 --> 00:11:52,639
the ruby program

321
00:11:52,639 --> 00:11:54,839
instead the attacker abused a

322
00:11:54,839 --> 00:11:57,279
framework-specific assignment feature

323
00:11:57,279 --> 00:11:59,600
to temper the existing object that

324
00:11:59,600 --> 00:12:01,360
associated with the

325
00:12:01,360 --> 00:12:04,639
assignment so the payloads are also

326
00:12:04,639 --> 00:12:05,600
different

327
00:12:05,600 --> 00:12:07,360
the mass assigned payloads are literal

328
00:12:07,360 --> 00:12:08,959
values however

329
00:12:08,959 --> 00:12:12,079
hbk hpa can introduce both

330
00:12:12,079 --> 00:12:13,920
hidden properties with either literal

331
00:12:13,920 --> 00:12:15,120
values or

332
00:12:15,120 --> 00:12:18,320
nested objects more importantly

333
00:12:18,320 --> 00:12:20,959
ruby is strongly typed so the mass

334
00:12:20,959 --> 00:12:22,320
assignment vulnerabilities

335
00:12:22,320 --> 00:12:24,800
cannot introduce new properties into the

336
00:12:24,800 --> 00:12:26,320
victim object

337
00:12:26,320 --> 00:12:29,440
however hpa can inject arbitrary

338
00:12:29,440 --> 00:12:30,720
properties which makes

339
00:12:30,720 --> 00:12:33,920
which make hpa very flexible and

340
00:12:33,920 --> 00:12:36,399
powerful

341
00:12:36,480 --> 00:12:39,120
okay with several pages of concept

342
00:12:39,120 --> 00:12:40,480
introduction i think

343
00:12:40,480 --> 00:12:43,200
it's time we can hack some real targets

344
00:12:43,200 --> 00:12:44,399
in this example

345
00:12:44,399 --> 00:12:47,440
we target as our popular web framework

346
00:12:47,440 --> 00:12:47,839
named

347
00:12:47,839 --> 00:12:50,399
rooting controller we will hack its

348
00:12:50,399 --> 00:12:51,440
official code

349
00:12:51,440 --> 00:12:54,800
to demonstrate an end-to-end attack from

350
00:12:54,800 --> 00:12:57,360
security check by passing to database

351
00:12:57,360 --> 00:12:59,600
injection

352
00:12:59,600 --> 00:13:01,680
the figure on the on the right can give

353
00:13:01,680 --> 00:13:03,920
you a brief idea on how our example

354
00:13:03,920 --> 00:13:04,959
works

355
00:13:04,959 --> 00:13:07,279
in this example a server program is

356
00:13:07,279 --> 00:13:08,560
deployed using

357
00:13:08,560 --> 00:13:11,200
routing controllers if a remote user

358
00:13:11,200 --> 00:13:13,519
wants to authenticate with the server

359
00:13:13,519 --> 00:13:15,519
his data will flows into the following

360
00:13:15,519 --> 00:13:17,440
date components

361
00:13:17,440 --> 00:13:20,160
first he will send his serialized data

362
00:13:20,160 --> 00:13:21,200
into the web

363
00:13:21,200 --> 00:13:24,240
api endpoint upon receiving the request

364
00:13:24,240 --> 00:13:27,519
the authentication module will init

365
00:13:27,519 --> 00:13:30,000
instantiate an object according to his

366
00:13:30,000 --> 00:13:30,880
json string

367
00:13:30,880 --> 00:13:34,000
and send it to the para handler

368
00:13:34,000 --> 00:13:36,000
we here we use the green box to

369
00:13:36,000 --> 00:13:37,200
demonstrate the

370
00:13:37,200 --> 00:13:40,560
user input object and we use okay

371
00:13:40,560 --> 00:13:43,760
and the the handler will first collect

372
00:13:43,760 --> 00:13:44,880
the internal

373
00:13:44,880 --> 00:13:47,519
format specifications which is the blue

374
00:13:47,519 --> 00:13:49,040
box here

375
00:13:49,040 --> 00:13:52,160
and he will merge the internal format

376
00:13:52,160 --> 00:13:53,360
specification

377
00:13:53,360 --> 00:13:56,240
with the input object and invoke the

378
00:13:56,240 --> 00:13:58,880
input validation api

379
00:13:58,880 --> 00:14:01,360
so the input validation components will

380
00:14:01,360 --> 00:14:03,199
synchronize the user input data

381
00:14:03,199 --> 00:14:06,240
according to the format specification

382
00:14:06,240 --> 00:14:08,800
in this case it will check if the email

383
00:14:08,800 --> 00:14:11,040
field is legitimate or not

384
00:14:11,040 --> 00:14:13,519
if the check pass the user object will

385
00:14:13,519 --> 00:14:15,600
flow into the database

386
00:14:15,600 --> 00:14:18,720
okay so this is overall of

387
00:14:18,720 --> 00:14:21,440
data flow let's analyze how we can

388
00:14:21,440 --> 00:14:25,440
attack the logic step by steps

389
00:14:25,920 --> 00:14:28,000
the first step is the hidden property

390
00:14:28,000 --> 00:14:29,120
injections

391
00:14:29,120 --> 00:14:31,600
where the malicious user includes our

392
00:14:31,600 --> 00:14:32,720
additional property

393
00:14:32,720 --> 00:14:35,199
into the request which is the control

394
00:14:35,199 --> 00:14:37,120
constructor in this case

395
00:14:37,120 --> 00:14:39,519
as shown in the picture when the server

396
00:14:39,519 --> 00:14:40,639
program

397
00:14:40,639 --> 00:14:43,519
the instantiate the user input there

398
00:14:43,519 --> 00:14:45,440
will be an additional property within

399
00:14:45,440 --> 00:14:46,720
the param object

400
00:14:46,720 --> 00:14:50,079
which is the constructor and

401
00:14:50,079 --> 00:14:52,399
in the second step the program will

402
00:14:52,399 --> 00:14:54,399
prepare the parameters needed by the

403
00:14:54,399 --> 00:14:54,959
input

404
00:14:54,959 --> 00:14:58,000
validation api the server program will

405
00:14:58,000 --> 00:15:02,079
merge the user input with the parameter

406
00:15:02,079 --> 00:15:05,199
which is the param with a object named

407
00:15:05,199 --> 00:15:06,320
scammer

408
00:15:06,320 --> 00:15:09,040
so the merging operation is performed

409
00:15:09,040 --> 00:15:10,000
performed by

410
00:15:10,000 --> 00:15:12,639
putting every properties of the parent

411
00:15:12,639 --> 00:15:14,800
objects into the scanner object

412
00:15:14,800 --> 00:15:17,199
so this is a process very much like

413
00:15:17,199 --> 00:15:19,120
object assign

414
00:15:19,120 --> 00:15:21,360
to simplify the demonstration here we

415
00:15:21,360 --> 00:15:22,240
let's just use

416
00:15:22,240 --> 00:15:25,360
object or sign in this example by

417
00:15:25,360 --> 00:15:26,320
performing the

418
00:15:26,320 --> 00:15:28,800
merging operations the hidden property

419
00:15:28,800 --> 00:15:31,120
constructor also transformed into the

420
00:15:31,120 --> 00:15:32,720
scammer

421
00:15:32,720 --> 00:15:36,160
so by performing such a transformation

422
00:15:36,160 --> 00:15:38,959
we now can hijack the inheritance chains

423
00:15:38,959 --> 00:15:40,000
of the constructor

424
00:15:40,000 --> 00:15:43,040
on the scanner object like we have

425
00:15:43,040 --> 00:15:45,199
demonstrated in the second attack

426
00:15:45,199 --> 00:15:47,279
vectors

427
00:15:47,279 --> 00:15:49,839
actually the constructor scanner plays a

428
00:15:49,839 --> 00:15:51,759
very important role in the routing

429
00:15:51,759 --> 00:15:53,600
controller

430
00:15:53,600 --> 00:15:56,000
as shown in the picture the scan object

431
00:15:56,000 --> 00:15:58,880
follows a object-oriented program style

432
00:15:58,880 --> 00:16:01,040
which use the constructor of his

433
00:16:01,040 --> 00:16:02,240
prototype to

434
00:16:02,240 --> 00:16:08,480
to store important format restrictions

435
00:16:08,480 --> 00:16:12,320
okay so on the last so

436
00:16:12,320 --> 00:16:14,880
as a result the merging operation enable

437
00:16:14,880 --> 00:16:17,120
us to hijack the inheritance of these

438
00:16:17,120 --> 00:16:19,680
important format restrictions

439
00:16:19,680 --> 00:16:21,920
as shown in the picture when the

440
00:16:21,920 --> 00:16:23,040
constructor is

441
00:16:23,040 --> 00:16:26,000
is read by the get spam gamma function

442
00:16:26,000 --> 00:16:28,560
our hidden property will immediately

443
00:16:28,560 --> 00:16:31,519
matched and returned to the code to

444
00:16:31,519 --> 00:16:33,440
bypass the input validation

445
00:16:33,440 --> 00:16:35,360
we just need to set the format

446
00:16:35,360 --> 00:16:37,920
specification as an invalid value

447
00:16:37,920 --> 00:16:40,480
so our cycle injection payload can

448
00:16:40,480 --> 00:16:42,959
escape the check

449
00:16:42,959 --> 00:16:44,720
the last step is much more

450
00:16:44,720 --> 00:16:47,199
straightforward the validated payload

451
00:16:47,199 --> 00:16:49,279
then flows into the sensitive database

452
00:16:49,279 --> 00:16:50,079
api

453
00:16:50,079 --> 00:16:54,000
to finish the entire attack so this is

454
00:16:54,000 --> 00:16:58,800
how the entire hpa exploit can work

455
00:16:58,800 --> 00:17:00,880
actually the code logics behind

456
00:17:00,880 --> 00:17:02,959
vulnerabilities is much more complex

457
00:17:02,959 --> 00:17:04,000
than the simplified

458
00:17:04,000 --> 00:17:07,439
graph here for example the input

459
00:17:07,439 --> 00:17:09,760
validation module itself contains more

460
00:17:09,760 --> 00:17:10,240
than

461
00:17:10,240 --> 00:17:13,520
30 000 lines of code so it would be

462
00:17:13,520 --> 00:17:14,559
really helpful

463
00:17:14,559 --> 00:17:16,880
if we can have a tool to help us

464
00:17:16,880 --> 00:17:18,880
automatically track all these data

465
00:17:18,880 --> 00:17:19,839
structures

466
00:17:19,839 --> 00:17:21,839
and automatically detect all these

467
00:17:21,839 --> 00:17:23,199
hidden properties

468
00:17:23,199 --> 00:17:27,679
and even automatically exploit them

469
00:17:28,079 --> 00:17:29,679
so what is the challenge of building

470
00:17:29,679 --> 00:17:31,120
such a tool

471
00:17:31,120 --> 00:17:33,440
first of all this is javascript

472
00:17:33,440 --> 00:17:34,720
analyzing javascript

473
00:17:34,720 --> 00:17:37,520
is known to be hard due to the dynamic

474
00:17:37,520 --> 00:17:38,559
feature

475
00:17:38,559 --> 00:17:41,679
the fact is even if we have chosen a

476
00:17:41,679 --> 00:17:42,400
reliable

477
00:17:42,400 --> 00:17:45,120
analyze framework as our underlying

478
00:17:45,120 --> 00:17:48,080
platform and we design smart methods

479
00:17:48,080 --> 00:17:50,799
and we test a large number of programs

480
00:17:50,799 --> 00:17:51,360
we still

481
00:17:51,360 --> 00:17:54,320
occasionally encounter crashes and

482
00:17:54,320 --> 00:17:55,360
incomparability

483
00:17:55,360 --> 00:17:58,160
issues when trying to analyzing large

484
00:17:58,160 --> 00:18:01,840
and very complex programs

485
00:18:02,480 --> 00:18:05,919
and the second challenge is

486
00:18:05,919 --> 00:18:08,559
does hpa actually create new data

487
00:18:08,559 --> 00:18:09,840
dependencies

488
00:18:09,840 --> 00:18:13,120
but the program analyzes is good at

489
00:18:13,120 --> 00:18:14,640
digging the existing

490
00:18:14,640 --> 00:18:18,400
data flows rather than creating new ones

491
00:18:18,400 --> 00:18:20,480
third from running examples we can

492
00:18:20,480 --> 00:18:22,960
observe that hpa actually

493
00:18:22,960 --> 00:18:26,080
exploit internal program states so the

494
00:18:26,080 --> 00:18:26,640
attack

495
00:18:26,640 --> 00:18:28,640
effect highly depends on the code

496
00:18:28,640 --> 00:18:30,400
context

497
00:18:30,400 --> 00:18:32,400
this makes the detection more

498
00:18:32,400 --> 00:18:33,919
challenging

499
00:18:33,919 --> 00:18:37,280
okay so to over overcome these

500
00:18:37,280 --> 00:18:37,919
challenges

501
00:18:37,919 --> 00:18:41,120
we design and implement links a hybrid

502
00:18:41,120 --> 00:18:43,440
javascript program analyze tool

503
00:18:43,440 --> 00:18:45,760
to detect and exploit hpa

504
00:18:45,760 --> 00:18:48,559
vulnerabilities

505
00:18:49,360 --> 00:18:51,760
the lynx is a type of wildcat and in

506
00:18:51,760 --> 00:18:52,559
greek

507
00:18:52,559 --> 00:18:55,039
means it is believed that links can see

508
00:18:55,039 --> 00:18:56,320
other people's kent

509
00:18:56,320 --> 00:18:58,880
and his role is for revolt revealing the

510
00:18:58,880 --> 00:19:00,160
hidden truths

511
00:19:00,160 --> 00:19:02,480
so it's in in our system is for

512
00:19:02,480 --> 00:19:06,000
revolting the hidden properties

513
00:19:06,000 --> 00:19:08,000
the picture below gives a high level

514
00:19:08,000 --> 00:19:09,360
workflow of links

515
00:19:09,360 --> 00:19:11,600
the tool mainly consists of two parts

516
00:19:11,600 --> 00:19:13,919
the left parse is for discovering the

517
00:19:13,919 --> 00:19:15,520
potential hidden properties

518
00:19:15,520 --> 00:19:17,360
which is the core components in our

519
00:19:17,360 --> 00:19:19,280
system

520
00:19:19,280 --> 00:19:22,640
it will first leverage data dynamic flow

521
00:19:22,640 --> 00:19:23,520
analysis

522
00:19:23,520 --> 00:19:26,559
to track the user input data flows and

523
00:19:26,559 --> 00:19:26,960
then

524
00:19:26,960 --> 00:19:30,000
it use static syntax syntax analyzers to

525
00:19:30,000 --> 00:19:32,720
infer potential hidden properties

526
00:19:32,720 --> 00:19:35,520
the the right part is about how we can

527
00:19:35,520 --> 00:19:37,120
detecting the harmful

528
00:19:37,120 --> 00:19:39,120
hidden properties from all those

529
00:19:39,120 --> 00:19:40,720
potential candidates

530
00:19:40,720 --> 00:19:44,400
and generated exploit for them

531
00:19:44,400 --> 00:19:47,120
so to help future node.js security

532
00:19:47,120 --> 00:19:47,840
research

533
00:19:47,840 --> 00:19:50,240
we will open source our links project on

534
00:19:50,240 --> 00:19:53,840
the github link at the bottom

535
00:19:54,240 --> 00:19:56,720
so the very first thing links will do is

536
00:19:56,720 --> 00:19:58,880
dynamic flow tracking

537
00:19:58,880 --> 00:20:01,840
first of all links will generate a label

538
00:20:01,840 --> 00:20:02,559
object

539
00:20:02,559 --> 00:20:05,600
which is a unique key and value pair

540
00:20:05,600 --> 00:20:08,000
links will inject the label into the

541
00:20:08,000 --> 00:20:10,240
input data of the program

542
00:20:10,240 --> 00:20:12,080
different properties from the input

543
00:20:12,080 --> 00:20:14,000
objects may flow into the different

544
00:20:14,000 --> 00:20:15,679
program logics

545
00:20:15,679 --> 00:20:17,600
so to track all the potential

546
00:20:17,600 --> 00:20:18,880
propagations

547
00:20:18,880 --> 00:20:21,440
our label injection is performed

548
00:20:21,440 --> 00:20:23,200
recursively

549
00:20:23,200 --> 00:20:25,200
taking the rooting controller cases as

550
00:20:25,200 --> 00:20:26,320
an example

551
00:20:26,320 --> 00:20:28,799
as shown in the left part of the picture

552
00:20:28,799 --> 00:20:29,919
links will first

553
00:20:29,919 --> 00:20:32,880
generate three different input objects

554
00:20:32,880 --> 00:20:36,640
by label injecting the original one

555
00:20:36,640 --> 00:20:39,440
in each time link will inject the label

556
00:20:39,440 --> 00:20:41,120
into a different property

557
00:20:41,120 --> 00:20:44,000
such as the gmail i'm sorry such as the

558
00:20:44,000 --> 00:20:44,720
email

559
00:20:44,720 --> 00:20:47,679
and the password and also he will inject

560
00:20:47,679 --> 00:20:49,360
a label into the root

561
00:20:49,360 --> 00:20:53,039
of the input object and then

562
00:20:53,039 --> 00:20:57,840
we execute the mutated test input

563
00:20:57,840 --> 00:21:01,039
in our instrumental framework to observe

564
00:21:01,039 --> 00:21:01,679
the program

565
00:21:01,679 --> 00:21:03,919
execution we leverage a javascript

566
00:21:03,919 --> 00:21:05,919
analyze framework called jalanki

567
00:21:05,919 --> 00:21:09,039
to instrument our test program since we

568
00:21:09,039 --> 00:21:11,039
are studying the data flows

569
00:21:11,039 --> 00:21:13,520
we instrument only the variable read and

570
00:21:13,520 --> 00:21:14,080
write

571
00:21:14,080 --> 00:21:17,440
and object property indexing and the

572
00:21:17,440 --> 00:21:18,559
function

573
00:21:18,559 --> 00:21:21,679
course then we execute the program

574
00:21:21,679 --> 00:21:24,320
during the execution links will examine

575
00:21:24,320 --> 00:21:26,799
every object within the data flow

576
00:21:26,799 --> 00:21:29,679
if an object carrier carries our

577
00:21:29,679 --> 00:21:30,640
property

578
00:21:30,640 --> 00:21:33,679
labels we will record it for further

579
00:21:33,679 --> 00:21:34,640
analysis

580
00:21:34,640 --> 00:21:37,440
and we will quote the objects that carry

581
00:21:37,440 --> 00:21:41,679
the labels as a property carriers

582
00:21:41,919 --> 00:21:43,919
so now we have a list of probably

583
00:21:43,919 --> 00:21:45,919
carriers recorded that

584
00:21:45,919 --> 00:21:48,640
an object is flagged as a property

585
00:21:48,640 --> 00:21:49,280
carrier

586
00:21:49,280 --> 00:21:51,679
because we detected our injected label

587
00:21:51,679 --> 00:21:53,840
under his body

588
00:21:53,840 --> 00:21:57,679
so if we can propagate our label here

589
00:21:57,679 --> 00:22:00,320
is it possible we also propagate other

590
00:22:00,320 --> 00:22:02,000
properties here

591
00:22:02,000 --> 00:22:05,120
most more specifically if we propagate

592
00:22:05,120 --> 00:22:07,760
it on property with a conflicting name

593
00:22:07,760 --> 00:22:10,080
of with certain internal properties we

594
00:22:10,080 --> 00:22:11,039
may be able to

595
00:22:11,039 --> 00:22:14,320
override the original states so

596
00:22:14,320 --> 00:22:16,799
we need to extract all the potent all

597
00:22:16,799 --> 00:22:18,080
the original properties

598
00:22:18,080 --> 00:22:21,600
under the carrier so now

599
00:22:21,600 --> 00:22:24,240
we want to extract all the childs from

600
00:22:24,240 --> 00:22:25,360
the property carrier

601
00:22:25,360 --> 00:22:27,280
and flagged them as hidden property

602
00:22:27,280 --> 00:22:29,280
candidates

603
00:22:29,280 --> 00:22:32,880
to achieve this goal we need static

604
00:22:32,880 --> 00:22:35,200
syntax analyzed to extract necessary

605
00:22:35,200 --> 00:22:36,000
syntactic

606
00:22:36,000 --> 00:22:38,960
information from the code so the picture

607
00:22:38,960 --> 00:22:41,120
on the right demonstrates how

608
00:22:41,120 --> 00:22:43,280
we pass a statement from our running

609
00:22:43,280 --> 00:22:44,400
example

610
00:22:44,400 --> 00:22:48,159
so to pass this statement links will

611
00:22:48,159 --> 00:22:50,880
traverse the syntax tree until reaching

612
00:22:50,880 --> 00:22:53,280
the property carrier

613
00:22:53,280 --> 00:22:55,919
which is circled by the right by the red

614
00:22:55,919 --> 00:22:57,600
line in our graph

615
00:22:57,600 --> 00:22:59,919
then it records all the properties under

616
00:22:59,919 --> 00:23:00,960
the carrier

617
00:23:00,960 --> 00:23:03,120
in our in our case the hidden property

618
00:23:03,120 --> 00:23:04,480
candidate is the

619
00:23:04,480 --> 00:23:07,120
constructor

620
00:23:07,679 --> 00:23:10,960
okay so this is the output screenshot of

621
00:23:10,960 --> 00:23:14,080
the first component

622
00:23:19,360 --> 00:23:21,840
as you can assume as you can observed

623
00:23:21,840 --> 00:23:23,280
the links will first

624
00:23:23,280 --> 00:23:26,240
instrument the code based and in total

625
00:23:26,240 --> 00:23:26,799
you can

626
00:23:26,799 --> 00:23:30,000
observe that we tracked 43 different

627
00:23:30,000 --> 00:23:31,360
carriers

628
00:23:31,360 --> 00:23:34,559
and as indicated by the red circle links

629
00:23:34,559 --> 00:23:36,720
successfully detected a hidden property

630
00:23:36,720 --> 00:23:39,679
named constructor

631
00:23:40,080 --> 00:23:42,080
so in the previous components we

632
00:23:42,080 --> 00:23:44,320
discovered the key name of the potential

633
00:23:44,320 --> 00:23:45,360
hidden properties

634
00:23:45,360 --> 00:23:48,400
which is the constructor by injecting a

635
00:23:48,400 --> 00:23:50,240
property with such a key

636
00:23:50,240 --> 00:23:52,640
we may override the certain internal

637
00:23:52,640 --> 00:23:53,840
states

638
00:23:53,840 --> 00:23:56,080
however we still we still don't know

639
00:23:56,080 --> 00:23:57,919
whether the candidates can be override

640
00:23:57,919 --> 00:23:58,880
or not

641
00:23:58,880 --> 00:24:01,279
and we also don't know how to introduce

642
00:24:01,279 --> 00:24:02,400
attack effects

643
00:24:02,400 --> 00:24:05,840
with these candidates so apparently

644
00:24:05,840 --> 00:24:09,840
links should do more let's revisit our

645
00:24:09,840 --> 00:24:11,440
run example to see if there's

646
00:24:11,440 --> 00:24:14,320
any insights to god to guide us design

647
00:24:14,320 --> 00:24:14,640
such

648
00:24:14,640 --> 00:24:17,679
exploitation components so the feature

649
00:24:17,679 --> 00:24:18,559
on the right

650
00:24:18,559 --> 00:24:20,320
on the on the left is the vulnerable

651
00:24:20,320 --> 00:24:22,320
code from our running example

652
00:24:22,320 --> 00:24:26,159
as we have discussed many times hit hpa

653
00:24:26,159 --> 00:24:28,880
exploit internal program states which

654
00:24:28,880 --> 00:24:29,360
means

655
00:24:29,360 --> 00:24:32,159
its exploitation highly relay rely on

656
00:24:32,159 --> 00:24:34,080
the code context

657
00:24:34,080 --> 00:24:37,600
so this is it is important that we can

658
00:24:37,600 --> 00:24:40,720
concluded a set of sensitive behaviors

659
00:24:40,720 --> 00:24:43,440
these behaviors should clearly indicated

660
00:24:43,440 --> 00:24:45,200
certain security consequences by

661
00:24:45,200 --> 00:24:46,240
themselves

662
00:24:46,240 --> 00:24:48,559
so that we can decouple the harmfulness

663
00:24:48,559 --> 00:24:49,440
detection

664
00:24:49,440 --> 00:24:52,640
from the code context also

665
00:24:52,640 --> 00:24:56,080
from this run example indeed

666
00:24:56,080 --> 00:24:58,000
the exploitation is mainly about

667
00:24:58,000 --> 00:25:00,640
manipulating the return result

668
00:25:00,640 --> 00:25:02,400
for example there are two possible

669
00:25:02,400 --> 00:25:04,559
possible paths in this picture

670
00:25:04,559 --> 00:25:07,120
if the execution enter the branch on 9

671
00:25:07,120 --> 00:25:07,919
19

672
00:25:07,919 --> 00:25:10,960
we will get a validation failed which is

673
00:25:10,960 --> 00:25:11,600
which is

674
00:25:11,600 --> 00:25:14,320
what we don't want to see but if we go

675
00:25:14,320 --> 00:25:16,159
into line 21

676
00:25:16,159 --> 00:25:19,279
we can successfully pass the check so

677
00:25:19,279 --> 00:25:22,240
the employee the exploitation point and

678
00:25:22,240 --> 00:25:24,240
the override point may not be the same

679
00:25:24,240 --> 00:25:25,039
place

680
00:25:25,039 --> 00:25:27,520
which means we should not stop our

681
00:25:27,520 --> 00:25:28,720
analyze at

682
00:25:28,720 --> 00:25:32,400
line 11 and we should continue

683
00:25:32,400 --> 00:25:35,120
exploring all the possible paths that

684
00:25:35,120 --> 00:25:36,080
can trigger

685
00:25:36,080 --> 00:25:40,320
by the manipulating the hidden property

686
00:25:40,480 --> 00:25:42,960
we study and concluded six general types

687
00:25:42,960 --> 00:25:44,640
of sensitive things

688
00:25:44,640 --> 00:25:47,279
the first type is keyword-based things

689
00:25:47,279 --> 00:25:48,480
such as c1

690
00:25:48,480 --> 00:25:52,240
c2 and i1 based on our observations

691
00:25:52,240 --> 00:25:54,960
certain parameters of sensitive methods

692
00:25:54,960 --> 00:25:55,600
are

693
00:25:55,600 --> 00:25:58,640
really a common attack targets for hpa

694
00:25:58,640 --> 00:26:01,520
hence we collect we collect widely used

695
00:26:01,520 --> 00:26:03,039
api that are frequently

696
00:26:03,039 --> 00:26:05,760
involved in handling user input such as

697
00:26:05,760 --> 00:26:07,360
file system operations

698
00:26:07,360 --> 00:26:10,720
database queries like that

699
00:26:10,720 --> 00:26:13,120
and we made our best effort to collect

700
00:26:13,120 --> 00:26:16,000
as many sensitive apis possible

701
00:26:16,000 --> 00:26:18,400
while we know that it is not complete

702
00:26:18,400 --> 00:26:20,080
but it can be easily

703
00:26:20,080 --> 00:26:23,440
extended over time the second thing

704
00:26:23,440 --> 00:26:25,840
belongs to the behavior-based sync

705
00:26:25,840 --> 00:26:28,799
for example in the sync i2 we are

706
00:26:28,799 --> 00:26:30,720
monitoring that whether our hidden

707
00:26:30,720 --> 00:26:31,600
property can

708
00:26:31,600 --> 00:26:34,400
change the return value of the module

709
00:26:34,400 --> 00:26:34,799
such

710
00:26:34,799 --> 00:26:37,440
things are killing weapons for security

711
00:26:37,440 --> 00:26:38,000
related

712
00:26:38,000 --> 00:26:41,919
modules like input validators

713
00:26:42,240 --> 00:26:44,480
okay after defining our sensitive

714
00:26:44,480 --> 00:26:46,640
behaviors we want the hidden property to

715
00:26:46,640 --> 00:26:48,400
trigger as many

716
00:26:48,400 --> 00:26:50,320
as possible branches and the monitor

717
00:26:50,320 --> 00:26:51,520
rather we can hit a

718
00:26:51,520 --> 00:26:54,240
certain thing to achieve this goal we

719
00:26:54,240 --> 00:26:56,480
will use symbolic execution to explore

720
00:26:56,480 --> 00:26:59,039
the hidden property value space

721
00:26:59,039 --> 00:27:01,840
so the links first generate a exploit

722
00:27:01,840 --> 00:27:02,640
template

723
00:27:02,640 --> 00:27:04,720
that can reach the potential vulnerable

724
00:27:04,720 --> 00:27:07,360
prop properties

725
00:27:07,360 --> 00:27:09,840
we denote such structure as a template

726
00:27:09,840 --> 00:27:11,200
because lynx

727
00:27:11,200 --> 00:27:14,880
actually does not inject concrete value

728
00:27:14,880 --> 00:27:18,080
here he will inject instead he will

729
00:27:18,080 --> 00:27:19,600
inject a placeholder

730
00:27:19,600 --> 00:27:22,159
which is used by the symbolic execution

731
00:27:22,159 --> 00:27:22,640
then

732
00:27:22,640 --> 00:27:24,960
we will run the test program on our

733
00:27:24,960 --> 00:27:27,440
construct with our constructed templates

734
00:27:27,440 --> 00:27:29,600
and symbolically executing the hidden

735
00:27:29,600 --> 00:27:30,480
property

736
00:27:30,480 --> 00:27:32,559
so as shown in the picture with the

737
00:27:32,559 --> 00:27:34,640
symbolic fusion we'll explore all the

738
00:27:34,640 --> 00:27:38,399
past constraints on the path and if

739
00:27:38,399 --> 00:27:41,360
the exploration hit a certain sink we

740
00:27:41,360 --> 00:27:43,679
will fetch the corresponding payloads

741
00:27:43,679 --> 00:27:46,960
that can trick the sink

742
00:27:47,120 --> 00:27:49,760
so this is the output of our find the

743
00:27:49,760 --> 00:27:51,120
exploit module

744
00:27:51,120 --> 00:27:53,039
from the circuit area we can observe

745
00:27:53,039 --> 00:27:54,880
that the key value paid

746
00:27:54,880 --> 00:27:57,200
here constructor and one triggered the

747
00:27:57,200 --> 00:27:58,799
sync i2

748
00:27:58,799 --> 00:28:01,360
and in the last line we can find that

749
00:28:01,360 --> 00:28:04,080
links automatically generates exploits

750
00:28:04,080 --> 00:28:06,960
that can successfully lead to the input

751
00:28:06,960 --> 00:28:07,679
validate

752
00:28:07,679 --> 00:28:11,120
input validation bypass

753
00:28:12,720 --> 00:28:16,240
so here let's have some evaluation data

754
00:28:16,240 --> 00:28:19,520
and have more insights about the impact

755
00:28:19,520 --> 00:28:21,360
of our research

756
00:28:21,360 --> 00:28:23,919
so during our research we choose 60

757
00:28:23,919 --> 00:28:26,640
widely used programs from npm

758
00:28:26,640 --> 00:28:30,080
there are 55 modules and five web

759
00:28:30,080 --> 00:28:31,440
applications

760
00:28:31,440 --> 00:28:34,360
with help of links we tracked more than

761
00:28:34,360 --> 00:28:36,240
1030 carriers

762
00:28:36,240 --> 00:28:39,039
and detected 300 hidden properties

763
00:28:39,039 --> 00:28:41,279
candidates associated with them

764
00:28:41,279 --> 00:28:43,919
in the end we confirmed 13 wonder

765
00:28:43,919 --> 00:28:45,840
zero-day vulnerabilities

766
00:28:45,840 --> 00:28:48,080
and with the help of symbolic execution

767
00:28:48,080 --> 00:28:52,240
links even synthesized 10 exploits

768
00:28:53,360 --> 00:28:56,159
so how is the impact of the detected

769
00:28:56,159 --> 00:28:57,760
vulnerabilities

770
00:28:57,760 --> 00:29:00,159
we found that the hpa can introduce

771
00:29:00,159 --> 00:29:02,080
various attack effects

772
00:29:02,080 --> 00:29:04,480
such as leaking the credential data

773
00:29:04,480 --> 00:29:06,720
bypassing security checks and deny of

774
00:29:06,720 --> 00:29:08,720
services

775
00:29:08,720 --> 00:29:10,960
based on the impact analysis we can

776
00:29:10,960 --> 00:29:13,520
observe that hepa compromised previously

777
00:29:13,520 --> 00:29:14,480
on reasonable

778
00:29:14,480 --> 00:29:17,279
program state which effectively enlarged

779
00:29:17,279 --> 00:29:19,360
our tax service

780
00:29:19,360 --> 00:29:21,919
also we could notice that hpa is not a

781
00:29:21,919 --> 00:29:22,480
simple

782
00:29:22,480 --> 00:29:26,320
input validation problems and also many

783
00:29:26,320 --> 00:29:28,559
input validators themselves are very

784
00:29:28,559 --> 00:29:31,918
vulnerable to hpa

785
00:29:32,880 --> 00:29:35,520
okay so in the following style slides i

786
00:29:35,520 --> 00:29:36,880
will pick up some interesting

787
00:29:36,880 --> 00:29:39,039
vulnerabilities for our result

788
00:29:39,039 --> 00:29:42,080
and case studying how we leverage hpa to

789
00:29:42,080 --> 00:29:43,679
compromise them

790
00:29:43,679 --> 00:29:45,919
and note that other vulnerabilities here

791
00:29:45,919 --> 00:29:49,760
have been reported to the one vendors

792
00:29:49,760 --> 00:29:52,000
so the first case comes from mongodb

793
00:29:52,000 --> 00:29:53,440
official driver

794
00:29:53,440 --> 00:29:56,000
we found that the we can temper an

795
00:29:56,000 --> 00:29:57,200
internal state named

796
00:29:57,200 --> 00:30:00,960
bison type so a background here is that

797
00:30:00,960 --> 00:30:01,360
the

798
00:30:01,360 --> 00:30:04,640
mongodb leverage this b bison type to

799
00:30:04,640 --> 00:30:05,919
indicate the data

800
00:30:05,919 --> 00:30:09,039
type of the query object however when

801
00:30:09,039 --> 00:30:11,120
serializing the query object

802
00:30:11,120 --> 00:30:13,840
mongodb will ignore the object with our

803
00:30:13,840 --> 00:30:16,000
unknown basin type

804
00:30:16,000 --> 00:30:19,440
so what if we abuse the logic in a query

805
00:30:19,440 --> 00:30:20,840
condition

806
00:30:20,840 --> 00:30:23,600
object the code on the right

807
00:30:23,600 --> 00:30:26,480
is an open source online game the online

808
00:30:26,480 --> 00:30:28,399
game used the vulnerable mongodb

809
00:30:28,399 --> 00:30:30,960
api to implement his user management

810
00:30:30,960 --> 00:30:32,399
logics

811
00:30:32,399 --> 00:30:34,399
as shown in the picture there are two

812
00:30:34,399 --> 00:30:37,039
apis implemented by the online games

813
00:30:37,039 --> 00:30:39,360
the first one is about loading a user

814
00:30:39,360 --> 00:30:41,039
and the second one is about delete a

815
00:30:41,039 --> 00:30:42,159
user

816
00:30:42,159 --> 00:30:45,600
so by as an attacker by injecting an

817
00:30:45,600 --> 00:30:48,000
unknown business type such as black hat

818
00:30:48,000 --> 00:30:49,679
into the user input

819
00:30:49,679 --> 00:30:52,080
the attacker can force the mongodb not

820
00:30:52,080 --> 00:30:53,120
serializing

821
00:30:53,120 --> 00:30:56,159
the curio condition so the mongodb will

822
00:30:56,159 --> 00:30:58,559
always return

823
00:30:58,559 --> 00:31:01,440
the first the first user on the mongodb

824
00:31:01,440 --> 00:31:02,960
database

825
00:31:02,960 --> 00:31:06,000
with this ability the attacker can login

826
00:31:06,000 --> 00:31:08,880
or delete arbitrary users in the

827
00:31:08,880 --> 00:31:11,440
database

828
00:31:12,080 --> 00:31:15,679
and so the second case is for another

829
00:31:15,679 --> 00:31:17,600
widely used in-memory javascript

830
00:31:17,600 --> 00:31:19,120
database

831
00:31:19,120 --> 00:31:21,039
the kind of the hidden property is more

832
00:31:21,039 --> 00:31:22,159
like a backdoor

833
00:31:22,159 --> 00:31:24,159
which helps attacker access the

834
00:31:24,159 --> 00:31:25,919
sensitive data

835
00:31:25,919 --> 00:31:28,720
so in tufidb we discover a hidden

836
00:31:28,720 --> 00:31:30,960
property named id

837
00:31:30,960 --> 00:31:33,519
which is our internal index for the

838
00:31:33,519 --> 00:31:35,279
database

839
00:31:35,279 --> 00:31:38,399
items once we specify

840
00:31:38,399 --> 00:31:41,919
we specify our own id in the query

841
00:31:41,919 --> 00:31:44,080
type edb will ignore other query

842
00:31:44,080 --> 00:31:46,000
conditions and directly

843
00:31:46,000 --> 00:31:48,399
return the results associated with the

844
00:31:48,399 --> 00:31:49,600
index

845
00:31:49,600 --> 00:31:52,880
moreover since the internal index is

846
00:31:52,880 --> 00:31:57,080
in a easily guessable format such as

847
00:31:57,080 --> 00:32:00,640
t00002r so it is so that attacker can

848
00:32:00,640 --> 00:32:02,960
use this vulnerabilities to access

849
00:32:02,960 --> 00:32:05,200
arbitrary data in the data in the

850
00:32:05,200 --> 00:32:06,320
database

851
00:32:06,320 --> 00:32:08,720
so as shown in the picture even though

852
00:32:08,720 --> 00:32:11,360
we we specify a wrong password and

853
00:32:11,360 --> 00:32:12,399
username

854
00:32:12,399 --> 00:32:15,760
we can still leak the correct user data

855
00:32:15,760 --> 00:32:19,919
by with the craft hidden properties

856
00:32:21,440 --> 00:32:24,399
so here is our the the last case in this

857
00:32:24,399 --> 00:32:25,200
talk

858
00:32:25,200 --> 00:32:27,919
before we can introduce this case we

859
00:32:27,919 --> 00:32:29,600
would like to give a brief

860
00:32:29,600 --> 00:32:31,919
uh introduction to the event handler

861
00:32:31,919 --> 00:32:34,159
skin of node.js

862
00:32:34,159 --> 00:32:37,200
so in node.js there's only one thread

863
00:32:37,200 --> 00:32:40,080
handling all the incoming requests

864
00:32:40,080 --> 00:32:42,720
in the third as a result the

865
00:32:42,720 --> 00:32:44,880
availability of the event handler is

866
00:32:44,880 --> 00:32:46,159
really critical

867
00:32:46,159 --> 00:32:48,880
in the third case we want to demonstrate

868
00:32:48,880 --> 00:32:49,200
how

869
00:32:49,200 --> 00:32:52,640
hpa can attack the event handler

870
00:32:52,640 --> 00:32:55,200
and thus freeze the entire server

871
00:32:55,200 --> 00:32:57,840
programs

872
00:32:58,080 --> 00:33:00,559
so in express we found that we

873
00:33:00,559 --> 00:33:02,080
found a hidden property

874
00:33:02,080 --> 00:33:04,080
which allows us to pass a function

875
00:33:04,080 --> 00:33:05,360
definition

876
00:33:05,360 --> 00:33:07,679
this function will be executed in an

877
00:33:07,679 --> 00:33:10,159
isolated safe sandbox

878
00:33:10,159 --> 00:33:11,919
even though we cannot execute the

879
00:33:11,919 --> 00:33:14,320
commands using these hidden properties

880
00:33:14,320 --> 00:33:16,960
we can still block the event handler by

881
00:33:16,960 --> 00:33:19,200
passing an infinite loop

882
00:33:19,200 --> 00:33:22,000
so as shown in the bottom of the picture

883
00:33:22,000 --> 00:33:23,120
we if we pass

884
00:33:23,120 --> 00:33:25,279
an up a hidden property through the web

885
00:33:25,279 --> 00:33:27,919
api which is an infinite loop

886
00:33:27,919 --> 00:33:30,640
then upon receiving the request the

887
00:33:30,640 --> 00:33:34,799
whole site will immediately get blocked

888
00:33:34,799 --> 00:33:38,320
yeah so yeah so thanks for attending

889
00:33:38,320 --> 00:33:39,519
attending our talk

890
00:33:39,519 --> 00:33:42,880
this is pretty much about our research

891
00:33:42,880 --> 00:33:44,960
you are also welcome to follow me at uh

892
00:33:44,960 --> 00:33:46,640
you to twitter

893
00:33:46,640 --> 00:33:53,279
on the bottom of the slides thank you

894
00:33:53,279 --> 00:33:56,000
hi everyone

895
00:33:56,960 --> 00:34:00,320
so i'm here to taking questions

896
00:34:00,320 --> 00:34:02,880
um okay so i noticed that there's

897
00:34:02,880 --> 00:34:04,399
already some questions

898
00:34:04,399 --> 00:34:07,600
uh in the chat box so i'll

899
00:34:07,600 --> 00:34:10,239
answer this question first okay so for

900
00:34:10,239 --> 00:34:12,079
the links called release plan

901
00:34:12,079 --> 00:34:14,960
so actually we are clean cleaning up the

902
00:34:14,960 --> 00:34:15,520
project

903
00:34:15,520 --> 00:34:18,000
and prepare the documentations as you

904
00:34:18,000 --> 00:34:19,599
guys may notice

905
00:34:19,599 --> 00:34:23,520
we have several modules and

906
00:34:23,520 --> 00:34:27,520
from the hci part and the interface is

907
00:34:27,520 --> 00:34:28,320
not

908
00:34:28,320 --> 00:34:31,599
so user friendly so we are try our best

909
00:34:31,599 --> 00:34:31,918
to

910
00:34:31,918 --> 00:34:34,079
prepare the documentations and also

911
00:34:34,079 --> 00:34:35,679
clean up the code

912
00:34:35,679 --> 00:34:37,679
in case some researchers may want to

913
00:34:37,679 --> 00:34:38,879
read our codes

914
00:34:38,879 --> 00:34:42,719
and yeah so that's why we

915
00:34:42,719 --> 00:34:45,280
and our plan is to release it no later

916
00:34:45,280 --> 00:34:46,560
than the end of august

917
00:34:46,560 --> 00:34:49,280
so this is the first question and

918
00:34:49,280 --> 00:34:50,639
[Music]

919
00:34:50,639 --> 00:34:53,760
and so for the second question uh is

920
00:34:53,760 --> 00:34:55,440
there any paper or blogs

921
00:34:55,440 --> 00:34:59,440
from you on this topic

922
00:34:59,599 --> 00:35:03,040
i'm sorry that actually we are uh

923
00:35:03,040 --> 00:35:05,359
we are only maintaining our internal

924
00:35:05,359 --> 00:35:06,880
technical documents

925
00:35:06,880 --> 00:35:10,960
and uh uh so so

926
00:35:10,960 --> 00:35:13,680
in shorthand uh we haven't haven't had a

927
00:35:13,680 --> 00:35:16,560
plan to release it publicly

928
00:35:16,560 --> 00:35:20,000
yeah so but uh we will probably release

929
00:35:20,000 --> 00:35:23,680
a complete write-up uh a white paper

930
00:35:23,680 --> 00:35:26,960
uh along with the project sometimes

931
00:35:26,960 --> 00:35:29,520
but yeah but we will give out our source

932
00:35:29,520 --> 00:35:30,640
code first

933
00:35:30,640 --> 00:35:33,680
yeah and yeah so

934
00:35:33,680 --> 00:35:37,200
as for the twitter id question

935
00:35:37,200 --> 00:35:41,520
okay so i can i will send you

936
00:35:41,680 --> 00:35:44,960
the twitter link so so is there any

937
00:35:44,960 --> 00:35:59,839
other questions

938
00:36:10,839 --> 00:36:13,839
okay

939
00:36:25,119 --> 00:36:28,160
okay yeah so and so

940
00:36:28,160 --> 00:36:31,119
we are we're having about four minutes

941
00:36:31,119 --> 00:36:32,800
if there is any question feel free to

942
00:36:32,800 --> 00:36:33,920
ask me

943
00:36:33,920 --> 00:36:36,079
okay so i noticed there's two more

944
00:36:36,079 --> 00:36:37,280
questions

945
00:36:37,280 --> 00:36:41,839
let's take a look

946
00:36:41,920 --> 00:36:45,119
okay so uh for the question from jason

947
00:36:45,119 --> 00:36:47,760
uh thanks for the question so jason is

948
00:36:47,760 --> 00:36:49,760
asking about does this means both the

949
00:36:49,760 --> 00:36:50,640
expected and

950
00:36:50,640 --> 00:36:52,320
unexpected parameters need to be

951
00:36:52,320 --> 00:36:54,720
centralized or there is a more elegant

952
00:36:54,720 --> 00:36:55,760
solution

953
00:36:55,760 --> 00:36:58,640
okay so in our research we mainly focus

954
00:36:58,640 --> 00:37:00,400
on the hidden part which is the

955
00:37:00,400 --> 00:37:03,599
unexpected parameters and we believe

956
00:37:03,599 --> 00:37:04,480
that it is

957
00:37:04,480 --> 00:37:08,000
actually not a

958
00:37:08,000 --> 00:37:10,079
the the mpd we believe that the

959
00:37:10,079 --> 00:37:12,400
synchronization is not the silver bullet

960
00:37:12,400 --> 00:37:14,640
because some standardization or

961
00:37:14,640 --> 00:37:16,480
validator models are also one

962
00:37:16,480 --> 00:37:19,520
directly vulnerable to our attacks so we

963
00:37:19,520 --> 00:37:20,079
believe

964
00:37:20,079 --> 00:37:23,119
uh more elegant uh method is

965
00:37:23,119 --> 00:37:26,400
is to let programmers developers to be

966
00:37:26,400 --> 00:37:28,160
aware of those hidden properties

967
00:37:28,160 --> 00:37:31,359
so that's why we developed and uh want

968
00:37:31,359 --> 00:37:31,680
to

969
00:37:31,680 --> 00:37:35,280
open source our code yeah

970
00:37:35,280 --> 00:37:38,480
and uh it seems that we still have time

971
00:37:38,480 --> 00:37:40,000
so maybe we can take another one

972
00:37:40,000 --> 00:37:40,800
question

973
00:37:40,800 --> 00:37:43,200
um

974
00:37:44,320 --> 00:37:47,520
uh so i have so the

975
00:37:47,520 --> 00:37:49,920
question is uh you mentioned that the

976
00:37:49,920 --> 00:37:52,079
most traditional payload validation

977
00:37:52,079 --> 00:37:53,119
tools are not

978
00:37:53,119 --> 00:37:55,680
able to deal with hpa vulnerabilities

979
00:37:55,680 --> 00:37:59,359
because they are also vulnerable to it

980
00:38:01,040 --> 00:38:04,160
joi okay

981
00:38:04,160 --> 00:38:07,280
yeah so uh i kind of uh

982
00:38:07,280 --> 00:38:10,400
so i so we test

983
00:38:10,400 --> 00:38:13,520
60 modules um

984
00:38:13,520 --> 00:38:16,079
uh i kind of remember that i i choose

985
00:38:16,079 --> 00:38:16,960
that one

986
00:38:16,960 --> 00:38:19,520
but unfortunately we didn't find

987
00:38:19,520 --> 00:38:21,359
exploitable hidden properties

988
00:38:21,359 --> 00:38:33,119
if i remember correctly yes

989
00:38:33,119 --> 00:38:35,119
so i will check if we still have time

990
00:38:35,119 --> 00:38:38,079
for taking more questions

991
00:38:38,079 --> 00:38:41,359
okay cool uh

992
00:38:44,079 --> 00:38:47,119
yeah so i i just shared my

993
00:38:47,119 --> 00:38:50,880
uh my twitter

994
00:38:50,880 --> 00:38:54,000
through the chat and uh uh if

995
00:38:54,000 --> 00:38:57,680
uh if we are about to release our tools

996
00:38:57,680 --> 00:39:00,240
and the the white papers i will also

997
00:39:00,240 --> 00:39:02,399
note

998
00:39:04,079 --> 00:39:07,599
make a tweet about it yes and okay so

999
00:39:07,599 --> 00:39:10,079
if we have time we can take other

1000
00:39:10,079 --> 00:39:12,320
questions

1001
00:39:12,320 --> 00:39:15,119
please wait for a moment it seems okay

1002
00:39:15,119 --> 00:39:16,160
yeah

1003
00:39:16,160 --> 00:39:19,359
okay so it seems like it's still uh many

1004
00:39:19,359 --> 00:39:20,320
questions

1005
00:39:20,320 --> 00:39:22,720
so uh and we don't have that much time

1006
00:39:22,720 --> 00:39:23,760
so probably

1007
00:39:23,760 --> 00:39:26,320
uh we can uh i will take the question

1008
00:39:26,320 --> 00:39:28,960
through the chat box

1009
00:39:28,960 --> 00:39:31,520
then yeah thanks for all you guys

1010
00:39:31,520 --> 00:39:32,760
attending my talk

1011
00:39:32,760 --> 00:39:35,760
yes

