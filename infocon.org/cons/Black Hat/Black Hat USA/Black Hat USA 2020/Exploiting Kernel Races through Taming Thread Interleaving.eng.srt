1
00:00:03,820 --> 00:00:14,249
[Music]

2
00:00:15,519 --> 00:00:17,359
hello my name is yutan from

3
00:00:17,359 --> 00:00:20,400
zoro national university and today i

4
00:00:20,400 --> 00:00:23,519
will present our talk

5
00:00:23,519 --> 00:00:26,000
exploiting conal laces through taming

6
00:00:26,000 --> 00:00:28,320
spreading the living

7
00:00:28,320 --> 00:00:30,080
and this is the joint work with

8
00:00:30,080 --> 00:00:31,679
processor branyon lee

9
00:00:31,679 --> 00:00:35,519
and professor tango min

10
00:00:36,559 --> 00:00:39,280
we've present our talk in lovely three

11
00:00:39,280 --> 00:00:40,640
steps

12
00:00:40,640 --> 00:00:43,840
first we briefly introduced the lace

13
00:00:43,840 --> 00:00:44,480
condition

14
00:00:44,480 --> 00:00:48,800
as a background and then we classify the

15
00:00:48,800 --> 00:00:52,239
lace conditions into several types of

16
00:00:52,239 --> 00:00:55,840
several types to explain which type of

17
00:00:55,840 --> 00:00:56,879
lace condition

18
00:00:56,879 --> 00:01:00,320
is unexploitable finally

19
00:01:00,320 --> 00:01:03,280
we present our new method to transform

20
00:01:03,280 --> 00:01:07,439
such a lace condition exploitable

21
00:01:07,680 --> 00:01:11,280
let's start with the less condition

22
00:01:11,280 --> 00:01:14,080
the lace condition is the kind of bug

23
00:01:14,080 --> 00:01:15,840
that is persisted

24
00:01:15,840 --> 00:01:18,320
since the early days of multi-strength

25
00:01:18,320 --> 00:01:19,920
in development

26
00:01:19,920 --> 00:01:23,600
but only recently getting increasing

27
00:01:23,600 --> 00:01:26,640
attention the

28
00:01:26,640 --> 00:01:29,840
security community

29
00:01:32,720 --> 00:01:37,520
taking some representative examples

30
00:01:37,520 --> 00:01:42,079
rather was developed by academia in 2019

31
00:01:42,079 --> 00:01:45,520
and found more than 30 lace books

32
00:01:45,520 --> 00:01:48,240
and in the same year google developed

33
00:01:48,240 --> 00:01:49,040
their own

34
00:01:49,040 --> 00:01:52,079
color concurrency sanitizer and

35
00:01:52,079 --> 00:01:55,600
found more than 300 lace books

36
00:01:55,600 --> 00:01:59,840
as a dessert unlike other types of books

37
00:01:59,840 --> 00:02:02,320
the number of lace conditioned bugs

38
00:02:02,320 --> 00:02:04,159
found by

39
00:02:04,159 --> 00:02:07,840
the seed colors slowly

40
00:02:07,840 --> 00:02:13,440
2019 maintaining its upward trend

41
00:02:14,720 --> 00:02:19,200
so what is the lace condition

42
00:02:19,440 --> 00:02:22,800
basically lace condition occur when

43
00:02:22,800 --> 00:02:25,840
multiple processes access the same

44
00:02:25,840 --> 00:02:27,440
memory location

45
00:02:27,440 --> 00:02:30,319
and it results in a different memory

46
00:02:30,319 --> 00:02:31,120
state

47
00:02:31,120 --> 00:02:34,319
depending on the access order

48
00:02:34,319 --> 00:02:37,440
for example suppose two instruction a

49
00:02:37,440 --> 00:02:40,840
and b are executed by chord one and two

50
00:02:40,840 --> 00:02:44,319
respectively and each of them

51
00:02:44,319 --> 00:02:48,720
leads and write the same memory location

52
00:02:48,720 --> 00:02:52,239
in this setting we can think of two

53
00:02:52,239 --> 00:02:56,480
execution scenarios one that the

54
00:02:56,480 --> 00:02:59,200
instruction a is executed before the

55
00:02:59,200 --> 00:03:00,560
instruction b

56
00:03:00,560 --> 00:03:05,440
and the other is vice versa

57
00:03:05,440 --> 00:03:08,159
if the former scenario produced the

58
00:03:08,159 --> 00:03:08,720
leaders

59
00:03:08,720 --> 00:03:12,879
x while the letter scenario produced the

60
00:03:12,879 --> 00:03:15,840
leisure y we call this kind of

61
00:03:15,840 --> 00:03:17,120
situations the

62
00:03:17,120 --> 00:03:19,840
less condition

63
00:03:20,239 --> 00:03:23,040
the lizard can be the value stored in

64
00:03:23,040 --> 00:03:24,319
the memory

65
00:03:24,319 --> 00:03:29,839
or the value led by lead instruction

66
00:03:30,159 --> 00:03:32,799
but all lace conditions are not

67
00:03:32,799 --> 00:03:33,840
necessarily

68
00:03:33,840 --> 00:03:37,040
the vulnerabilities in fact

69
00:03:37,040 --> 00:03:39,760
such a situation casually happens in

70
00:03:39,760 --> 00:03:40,480
most of

71
00:03:40,480 --> 00:03:45,280
producer consumers threading patterns

72
00:03:45,280 --> 00:03:47,480
a lace condition is regarded as a

73
00:03:47,480 --> 00:03:48,959
vulnerability

74
00:03:48,959 --> 00:03:51,920
when it hurts all the contour flow or

75
00:03:51,920 --> 00:03:53,280
the data flow and

76
00:03:53,280 --> 00:03:55,599
eventually literate in the memory

77
00:03:55,599 --> 00:03:57,599
correction

78
00:03:57,599 --> 00:04:00,560
at this time the lace condition consists

79
00:04:00,560 --> 00:04:00,879
of

80
00:04:00,879 --> 00:04:05,439
two or more pairs of lace instruction

81
00:04:09,200 --> 00:04:12,319
when it comes to the vulnerabilities

82
00:04:12,319 --> 00:04:15,200
they do not occur when the inverted lace

83
00:04:15,200 --> 00:04:15,840
instructions

84
00:04:15,840 --> 00:04:19,120
are merely executed but only

85
00:04:19,120 --> 00:04:21,680
when they are executed in a specific

86
00:04:21,680 --> 00:04:23,600
order

87
00:04:23,600 --> 00:04:26,800
the problem is that we cannot always

88
00:04:26,800 --> 00:04:30,479
enforce such a desired order

89
00:04:30,479 --> 00:04:33,360
as the multiple threads are scheduled in

90
00:04:33,360 --> 00:04:36,560
a non-deterministic fashion

91
00:04:36,560 --> 00:04:39,680
in this sense executing them in

92
00:04:39,680 --> 00:04:43,120
specific order is pure luck just like

93
00:04:43,120 --> 00:04:43,840
hitting

94
00:04:43,840 --> 00:04:46,880
the jackpot in the slot

95
00:04:46,880 --> 00:04:50,560
motion game the good news is that

96
00:04:50,560 --> 00:04:53,520
computer programs never demand us to

97
00:04:53,520 --> 00:04:55,040
insert the coins

98
00:04:55,040 --> 00:04:58,720
to keep executing it so we can try brute

99
00:04:58,720 --> 00:04:59,759
forcing it

100
00:04:59,759 --> 00:05:04,000
until we get the desired effect

101
00:05:04,639 --> 00:05:08,320
this boils down to the question that

102
00:05:08,320 --> 00:05:11,360
whether such a desired order can

103
00:05:11,360 --> 00:05:15,440
even happen eventually specifically

104
00:05:15,440 --> 00:05:18,639
even if a lace condition literature in

105
00:05:18,639 --> 00:05:20,960
memory correction they cost address

106
00:05:20,960 --> 00:05:22,160
breaks or

107
00:05:22,160 --> 00:05:26,080
rap controlling it cannot be exploitable

108
00:05:26,080 --> 00:05:30,720
even if if we cannot enforce

109
00:05:30,720 --> 00:05:34,880
such a problematic execution order

110
00:05:34,880 --> 00:05:38,240
one may think that this is not an

111
00:05:38,240 --> 00:05:41,440
important issue because first protein

112
00:05:41,440 --> 00:05:41,919
will

113
00:05:41,919 --> 00:05:44,160
somehow trigger the instructions in the

114
00:05:44,160 --> 00:05:45,680
desired order

115
00:05:45,680 --> 00:05:48,800
but we will show that some late in

116
00:05:48,800 --> 00:05:52,240
lace conditions have the execution order

117
00:05:52,240 --> 00:05:54,080
that cannot be triggered by

118
00:05:54,080 --> 00:05:56,880
first person

119
00:05:57,759 --> 00:05:59,840
now let's look at the types of less

120
00:05:59,840 --> 00:06:01,520
condition vulnerabilities

121
00:06:01,520 --> 00:06:05,199
and their exploitability

122
00:06:05,199 --> 00:06:07,199
we first classified the latest

123
00:06:07,199 --> 00:06:09,120
conditions by the number of

124
00:06:09,120 --> 00:06:12,639
variables that are inverted in

125
00:06:12,639 --> 00:06:16,160
namely if a last instruction pair

126
00:06:16,160 --> 00:06:19,280
access a single variable or

127
00:06:19,280 --> 00:06:21,840
variable

128
00:06:22,960 --> 00:06:25,360
the single variable lace condition is

129
00:06:25,360 --> 00:06:26,240
the most

130
00:06:26,240 --> 00:06:28,080
basic type of lace condition

131
00:06:28,080 --> 00:06:30,319
vulnerability

132
00:06:30,319 --> 00:06:33,039
where every lace instruction pair

133
00:06:33,039 --> 00:06:34,000
centers around

134
00:06:34,000 --> 00:06:37,039
a single variable for

135
00:06:37,039 --> 00:06:40,319
example the speaker shows two lace

136
00:06:40,319 --> 00:06:41,199
instructions

137
00:06:41,199 --> 00:06:44,400
between the instruction a and b and the

138
00:06:44,400 --> 00:06:45,280
instruction b

139
00:06:45,280 --> 00:06:48,800
and c and they both interact with

140
00:06:48,800 --> 00:06:52,319
each other by a single

141
00:06:52,319 --> 00:06:56,000
variable this type of lace condition

142
00:06:56,000 --> 00:06:58,160
vulnerability occurs when the

143
00:06:58,160 --> 00:07:02,080
instruction a b and c are executed in

144
00:07:02,080 --> 00:07:05,680
order specifically

145
00:07:05,680 --> 00:07:08,720
the instruction b should be executed

146
00:07:08,720 --> 00:07:12,400
after the instruction a and before the

147
00:07:12,400 --> 00:07:16,000
instruction c and we refer the time

148
00:07:16,000 --> 00:07:19,840
between them to the time window

149
00:07:19,840 --> 00:07:23,599
or lace window the figure on the right

150
00:07:23,599 --> 00:07:26,319
describe a single variable less

151
00:07:26,319 --> 00:07:28,479
condition vulnerability

152
00:07:28,479 --> 00:07:32,560
found in the linux kernel

153
00:07:32,639 --> 00:07:35,520
this vulnerability consists of two pairs

154
00:07:35,520 --> 00:07:37,280
of laser instructions

155
00:07:37,280 --> 00:07:40,479
and both are accessing the same header

156
00:07:40,479 --> 00:07:44,000
inclusion variable to see

157
00:07:44,000 --> 00:07:46,400
how this lace condition measures in

158
00:07:46,400 --> 00:07:48,000
memory encryption

159
00:07:48,000 --> 00:07:50,879
suppose the header inclusion variable is

160
00:07:50,879 --> 00:07:51,919
1

161
00:07:51,919 --> 00:07:55,520
when the instruction a is executed

162
00:07:55,520 --> 00:07:58,479
you can see that this leaves the

163
00:07:58,479 --> 00:08:01,639
variable called rfb

164
00:08:01,639 --> 00:08:05,360
uninitialized now if the

165
00:08:05,360 --> 00:08:09,840
instruction b is executed

166
00:08:09,840 --> 00:08:13,039
and write zero to the header inclusion

167
00:08:13,039 --> 00:08:14,240
variable

168
00:08:14,240 --> 00:08:17,520
the include the instruction c will then

169
00:08:17,520 --> 00:08:18,160
lead

170
00:08:18,160 --> 00:08:23,680
zero from the header including variable

171
00:08:24,560 --> 00:08:26,639
which literature in the memory copy

172
00:08:26,639 --> 00:08:27,919
function calls

173
00:08:27,919 --> 00:08:31,199
with the uninitialized rfp

174
00:08:31,199 --> 00:08:33,759
variable

175
00:08:34,559 --> 00:08:37,360
in this type the less condition is more

176
00:08:37,360 --> 00:08:38,320
likely to

177
00:08:38,320 --> 00:08:41,120
occur as the time window between the

178
00:08:41,120 --> 00:08:41,839
instruction a

179
00:08:41,839 --> 00:08:45,120
and c is larger and it is less

180
00:08:45,120 --> 00:08:50,000
likely if the time window is thin

181
00:08:50,320 --> 00:08:53,760
however because there is an old

182
00:08:53,760 --> 00:08:56,560
that such an execution order happens no

183
00:08:56,560 --> 00:08:57,760
matter how

184
00:08:57,760 --> 00:09:00,640
unlikely it is bruce person would

185
00:09:00,640 --> 00:09:03,440
eventually trigger the less condition

186
00:09:03,440 --> 00:09:09,360
allowing us to exploit the vulnerability

187
00:09:09,360 --> 00:09:12,720
the other type of lace condition is

188
00:09:12,720 --> 00:09:16,000
multivariable lace condition and it is

189
00:09:16,000 --> 00:09:18,080
more common in real world than

190
00:09:18,080 --> 00:09:22,080
the single variable lace condition

191
00:09:22,080 --> 00:09:24,720
multivariable lace condition may also

192
00:09:24,720 --> 00:09:25,279
consist

193
00:09:25,279 --> 00:09:29,200
of multiple pairs or last instructions

194
00:09:29,200 --> 00:09:32,720
but at this time each pair access

195
00:09:32,720 --> 00:09:36,560
the different variables

196
00:09:36,560 --> 00:09:39,760
for example the figure shows

197
00:09:39,760 --> 00:09:42,640
two lace instruction pairs between

198
00:09:42,640 --> 00:09:44,480
instruction a and b

199
00:09:44,480 --> 00:09:48,399
and the instruction c and d while the

200
00:09:48,399 --> 00:09:52,320
instruction a and b access the memory 1

201
00:09:52,320 --> 00:09:55,760
and the instruction c and d access the

202
00:09:55,760 --> 00:09:57,839
memory 2.

203
00:09:57,839 --> 00:10:00,399
in this type the memory correction

204
00:10:00,399 --> 00:10:01,440
occurs when

205
00:10:01,440 --> 00:10:04,880
the instruction b and c are executed

206
00:10:04,880 --> 00:10:08,480
after the instruction a and before the

207
00:10:08,480 --> 00:10:11,200
instruction d

208
00:10:11,279 --> 00:10:13,680
we have already seen that the time

209
00:10:13,680 --> 00:10:15,839
window between the instruction a

210
00:10:15,839 --> 00:10:19,200
and d that is supposed to contain the

211
00:10:19,200 --> 00:10:22,240
the other instructions in core two

212
00:10:22,240 --> 00:10:25,120
but since there are two instructions in

213
00:10:25,120 --> 00:10:25,440
core

214
00:10:25,440 --> 00:10:28,880
two the instructions in it

215
00:10:28,880 --> 00:10:33,200
has its own time tier time window

216
00:10:33,200 --> 00:10:36,079
let's call each time window x and y

217
00:10:36,079 --> 00:10:37,760
respectively

218
00:10:37,760 --> 00:10:41,440
we noted that when explaining a

219
00:10:41,440 --> 00:10:43,680
multivariate release condition the

220
00:10:43,680 --> 00:10:45,279
relationship between

221
00:10:45,279 --> 00:10:50,320
these two time window is very important

222
00:10:50,880 --> 00:10:53,600
so let's further classify the

223
00:10:53,600 --> 00:10:55,440
multivariable lace conditions

224
00:10:55,440 --> 00:10:59,360
into the inclusive one and

225
00:10:59,360 --> 00:11:02,160
non-inclusive one according to whether

226
00:11:02,160 --> 00:11:03,120
the time window

227
00:11:03,120 --> 00:11:07,120
x contains the time and the y

228
00:11:07,200 --> 00:11:10,399
if the time window x contains the

229
00:11:10,399 --> 00:11:16,079
time window y it is classified as a

230
00:11:16,079 --> 00:11:19,040
inclusive merge variable lace condition

231
00:11:19,040 --> 00:11:20,160
on the other hand

232
00:11:20,160 --> 00:11:24,240
if the timing of x does not contain the

233
00:11:24,240 --> 00:11:28,399
time in the y it is classified as a

234
00:11:28,399 --> 00:11:30,320
non-inclusive multivariable lace

235
00:11:30,320 --> 00:11:32,800
condition

236
00:11:33,920 --> 00:11:36,240
similar to the single variable race

237
00:11:36,240 --> 00:11:36,959
condition

238
00:11:36,959 --> 00:11:39,760
the likelihood of triggering the

239
00:11:39,760 --> 00:11:41,040
inclusive emergency

240
00:11:41,040 --> 00:11:42,880
variable not

241
00:11:55,120 --> 00:11:59,360
less available is less likely to occur

242
00:11:59,360 --> 00:12:01,839
however like a single variable less

243
00:12:01,839 --> 00:12:02,800
condition

244
00:12:02,800 --> 00:12:06,160
bruce person will eventually manage to

245
00:12:06,160 --> 00:12:09,519
trigger the less condition because

246
00:12:09,519 --> 00:12:12,560
there is an oath no matter how thin

247
00:12:12,560 --> 00:12:14,959
it is

248
00:12:15,600 --> 00:12:18,639
however this is not the case in the

249
00:12:18,639 --> 00:12:21,360
non-inclusive lace condition the

250
00:12:21,360 --> 00:12:22,880
examples show some

251
00:12:22,880 --> 00:12:24,959
non-inclusive multivariable lace

252
00:12:24,959 --> 00:12:28,240
condition found in the linux kernel

253
00:12:28,240 --> 00:12:31,920
basically the color uses uninitialized

254
00:12:31,920 --> 00:12:32,560
memory

255
00:12:32,560 --> 00:12:35,920
if only the instruction b and c in

256
00:12:35,920 --> 00:12:39,279
core 2 is executed between the

257
00:12:39,279 --> 00:12:42,639
instruction a and d in core 1.

258
00:12:42,639 --> 00:12:45,839
however notice that the instruction a

259
00:12:45,839 --> 00:12:48,480
and d locate back to back with each

260
00:12:48,480 --> 00:12:49,440
other

261
00:12:49,440 --> 00:12:52,959
without any branches which suggests that

262
00:12:52,959 --> 00:12:55,839
the time window between them is very

263
00:12:55,839 --> 00:12:56,880
thin

264
00:12:56,880 --> 00:12:59,920
18 cycles to be specific

265
00:12:59,920 --> 00:13:03,040
on the other hand there is a huge time

266
00:13:03,040 --> 00:13:04,200
margin of

267
00:13:04,200 --> 00:13:07,519
2250 cycles between the instruction b

268
00:13:07,519 --> 00:13:07,839
and

269
00:13:07,839 --> 00:13:11,279
c the instruction d will always be

270
00:13:11,279 --> 00:13:15,839
executed before the instruction c

271
00:13:17,200 --> 00:13:20,240
in other words it is simply impossible

272
00:13:20,240 --> 00:13:22,560
to trigger this vulnerability by

273
00:13:22,560 --> 00:13:23,360
reversing

274
00:13:23,360 --> 00:13:26,720
it unless core one stops the

275
00:13:26,720 --> 00:13:29,120
execution between the instruction a and

276
00:13:29,120 --> 00:13:30,240
d and

277
00:13:30,240 --> 00:13:35,839
extend the timing though

278
00:13:36,399 --> 00:13:39,680
since this kind of vulnerability cannot

279
00:13:39,680 --> 00:13:40,000
be

280
00:13:40,000 --> 00:13:43,120
triggered by normal brute forcing

281
00:13:43,120 --> 00:13:46,839
it's been difficult to find it through

282
00:13:46,839 --> 00:13:49,279
farting in fact this kind of

283
00:13:49,279 --> 00:13:51,040
vulnerability has begun to

284
00:13:51,040 --> 00:13:54,480
be discovered only after furthers

285
00:13:54,480 --> 00:13:55,360
integrate

286
00:13:55,360 --> 00:13:58,880
the mechanism that arbitrarily stops the

287
00:13:58,880 --> 00:14:02,720
coronary execution it is

288
00:14:02,720 --> 00:14:05,440
still impossible to trigger this type of

289
00:14:05,440 --> 00:14:08,320
vulnerability in real world

290
00:14:08,320 --> 00:14:11,440
because the attacker can

291
00:14:11,440 --> 00:14:15,199
not cannot control the execution of

292
00:14:15,199 --> 00:14:18,320
kernel when exploiting it

293
00:14:18,320 --> 00:14:21,360
therefore most of these vulnerabilities

294
00:14:21,360 --> 00:14:26,240
are way to exploit

295
00:14:27,360 --> 00:14:30,880
however there are there are

296
00:14:30,880 --> 00:14:33,920
there are a handful of methods to

297
00:14:33,920 --> 00:14:37,360
reserve this problem under certain

298
00:14:37,360 --> 00:14:40,639
circumstance the first method

299
00:14:40,639 --> 00:14:44,160
is using the difference core latency

300
00:14:44,160 --> 00:14:47,600
there are cpus that have cores with

301
00:14:47,600 --> 00:14:50,880
different frequencies such as

302
00:14:50,880 --> 00:14:54,800
kirkham snapdragon 845

303
00:14:54,800 --> 00:14:58,320
it has two sets of cores

304
00:14:58,320 --> 00:15:02,079
and it shows that each set contains

305
00:15:02,079 --> 00:15:06,399
four 2.5 gigahertz scores and four

306
00:15:06,399 --> 00:15:11,519
1.6 gigahertz cores respectively

307
00:15:11,519 --> 00:15:14,720
if you place the spread if this timing

308
00:15:14,720 --> 00:15:16,480
don't need to be extended

309
00:15:16,480 --> 00:15:19,440
on a slow core and place the other

310
00:15:19,440 --> 00:15:20,720
thread on the

311
00:15:20,720 --> 00:15:25,199
fast core you can reduce the difference

312
00:15:25,199 --> 00:15:27,680
between the time window and the

313
00:15:27,680 --> 00:15:29,440
instruction

314
00:15:29,440 --> 00:15:33,199
can be executed in order

315
00:15:34,079 --> 00:15:37,839
however this method is only possible

316
00:15:37,839 --> 00:15:40,880
if the target systems use such as

317
00:15:40,880 --> 00:15:44,959
cpu with different core frequencies

318
00:15:44,959 --> 00:15:48,240
also to the best of our knowledge since

319
00:15:48,240 --> 00:15:48,800
there

320
00:15:48,800 --> 00:15:52,320
are no cpus with extremely different

321
00:15:52,320 --> 00:15:55,680
latency between cores if the

322
00:15:55,680 --> 00:15:58,000
difference between the timing though is

323
00:15:58,000 --> 00:15:58,959
large

324
00:15:58,959 --> 00:16:02,479
it cannot apply cable

325
00:16:04,240 --> 00:16:07,600
the second method is using the thread

326
00:16:07,600 --> 00:16:11,120
scheduler of the kernel

327
00:16:11,120 --> 00:16:14,480
for example in the linux kernel

328
00:16:14,480 --> 00:16:17,279
where the config printer option is

329
00:16:17,279 --> 00:16:18,560
enabled

330
00:16:18,560 --> 00:16:21,440
contact switching occurs even if it's

331
00:16:21,440 --> 00:16:22,800
operating

332
00:16:22,800 --> 00:16:26,560
it is operating in this corner mode

333
00:16:26,560 --> 00:16:29,600
yan hong use this method

334
00:16:29,600 --> 00:16:33,279
and demonstrate how one can extend the

335
00:16:33,279 --> 00:16:37,600
lace window specifically the scan set

336
00:16:37,600 --> 00:16:41,040
affinity function in the kernel prints

337
00:16:41,040 --> 00:16:44,079
the thread in another core and

338
00:16:44,079 --> 00:16:47,440
inject a thread to it by

339
00:16:47,440 --> 00:16:50,160
injecting a thread between the time

340
00:16:50,160 --> 00:16:51,440
window x

341
00:16:51,440 --> 00:16:54,880
one can postpone the execution of the

342
00:16:54,880 --> 00:16:57,440
instruction d which resulting in the

343
00:16:57,440 --> 00:17:00,079
extended time window x

344
00:17:00,079 --> 00:17:03,680
to visually demonstrate how it works

345
00:17:03,680 --> 00:17:06,799
suppose the instruction a is

346
00:17:06,799 --> 00:17:10,079
executed first then core

347
00:17:10,079 --> 00:17:12,559
one receives the request to reschedule

348
00:17:12,559 --> 00:17:15,599
from core zero

349
00:17:15,599 --> 00:17:18,799
upon receiving the request core one

350
00:17:18,799 --> 00:17:22,000
changed the status of current stress to

351
00:17:22,000 --> 00:17:22,720
weight

352
00:17:22,720 --> 00:17:24,959
and then it performed context switching

353
00:17:24,959 --> 00:17:26,160
to the threat

354
00:17:26,160 --> 00:17:30,240
because the requested by quarter zero

355
00:17:30,240 --> 00:17:33,440
meanwhile the instruction b and c are

356
00:17:33,440 --> 00:17:34,799
executed

357
00:17:34,799 --> 00:17:38,160
in core 2. by the time

358
00:17:38,160 --> 00:17:41,360
the instruction b and c are executed in

359
00:17:41,360 --> 00:17:44,799
core 2 core 1 finished the thread

360
00:17:44,799 --> 00:17:50,080
that core 0 only originally requested

361
00:17:50,080 --> 00:17:52,880
is legion does threaten the weight q

362
00:17:52,880 --> 00:17:53,600
hence

363
00:17:53,600 --> 00:17:57,360
executing the instruction d

364
00:17:59,039 --> 00:18:02,240
however this is only possible in

365
00:18:02,240 --> 00:18:04,880
columns with the config print option

366
00:18:04,880 --> 00:18:07,039
enabled

367
00:18:07,039 --> 00:18:09,760
but the latest columns use the config

368
00:18:09,760 --> 00:18:10,240
print

369
00:18:10,240 --> 00:18:14,240
voluntary option by deferred

370
00:18:14,240 --> 00:18:17,760
in other words this method does not work

371
00:18:17,760 --> 00:18:22,160
for most of the linux systems

372
00:18:24,000 --> 00:18:27,760
as you can see all previous methods have

373
00:18:27,760 --> 00:18:31,280
obvious limitations and are

374
00:18:31,280 --> 00:18:34,960
hardly useful in general so

375
00:18:34,960 --> 00:18:38,640
what we need is a new method to extend

376
00:18:38,640 --> 00:18:39,679
the time window

377
00:18:39,679 --> 00:18:44,160
that can be used in general settings

378
00:18:50,320 --> 00:18:53,360
to designers to that to design social

379
00:18:53,360 --> 00:18:55,039
method

380
00:18:55,039 --> 00:18:58,559
we within think about how to extend the

381
00:18:58,559 --> 00:19:00,640
time window

382
00:19:00,640 --> 00:19:03,679
it turns out that it

383
00:19:03,679 --> 00:19:07,600
all boils down to stopping the core

384
00:19:07,600 --> 00:19:10,080
while it's hitting the instruction a and

385
00:19:10,080 --> 00:19:10,799
d

386
00:19:10,799 --> 00:19:14,000
were degrading degrading the performance

387
00:19:14,000 --> 00:19:16,559
of the core

388
00:19:16,559 --> 00:19:19,919
however the first method cannot be used

389
00:19:19,919 --> 00:19:23,600
because users cannot control the

390
00:19:23,600 --> 00:19:26,799
operation of the hardware so

391
00:19:26,799 --> 00:19:30,080
we choose the second method namely

392
00:19:30,080 --> 00:19:31,919
degrading the performance

393
00:19:31,919 --> 00:19:34,720
of the core

394
00:19:36,080 --> 00:19:39,840
the key idea of explains

395
00:19:39,840 --> 00:19:42,640
is to keep lazing interrupts to

396
00:19:42,640 --> 00:19:44,320
indirectly alter

397
00:19:44,320 --> 00:19:47,679
corner stress interleaving

398
00:19:47,679 --> 00:19:51,039
we noted that the stress

399
00:19:51,039 --> 00:19:53,919
immediately immediately excuse the

400
00:19:53,919 --> 00:19:55,360
intertender

401
00:19:55,360 --> 00:19:59,039
whenever it received an interrupt

402
00:19:59,039 --> 00:20:02,240
this suggests that as the intertumbling

403
00:20:02,240 --> 00:20:06,240
happens to fall in to the time window

404
00:20:06,240 --> 00:20:09,840
we are targeting the size of the

405
00:20:09,840 --> 00:20:12,080
time window will be extended while

406
00:20:12,080 --> 00:20:14,400
handling it

407
00:20:14,400 --> 00:20:18,080
to demonstrate this idea we found

408
00:20:18,080 --> 00:20:21,200
two types of interrupts that can affect

409
00:20:21,200 --> 00:20:21,679
the

410
00:20:21,679 --> 00:20:25,039
corner mode execution

411
00:20:26,159 --> 00:20:28,799
interprocessor interrupt and hardware

412
00:20:28,799 --> 00:20:30,159
interrupt

413
00:20:30,159 --> 00:20:33,200
let's call them ipi and irq

414
00:20:33,200 --> 00:20:35,840
insured

415
00:20:37,360 --> 00:20:41,919
however both both ipi and irq

416
00:20:41,919 --> 00:20:45,200
cannot be directly sent from the

417
00:20:45,200 --> 00:20:48,960
user mode they are only used in the

418
00:20:48,960 --> 00:20:53,280
color mode therefore esp lace attempts

419
00:20:53,280 --> 00:20:56,799
to indirectly send interrupts

420
00:20:56,799 --> 00:20:59,679
using system calls that internally

421
00:20:59,679 --> 00:21:00,320
transmit

422
00:21:00,320 --> 00:21:03,600
ipi and irq

423
00:21:03,600 --> 00:21:07,200
the system call that send on ipi

424
00:21:07,200 --> 00:21:10,240
and the system call that send a request

425
00:21:10,240 --> 00:21:11,840
to the device

426
00:21:11,840 --> 00:21:17,120
which eventually stand on irq

427
00:21:17,120 --> 00:21:20,559
so we found the system call

428
00:21:20,559 --> 00:21:23,440
that performs tlv shootdown internally

429
00:21:23,440 --> 00:21:24,480
transmit

430
00:21:24,480 --> 00:21:28,640
ipi since each cpu core has

431
00:21:28,640 --> 00:21:32,240
its own tlb all tlv entries

432
00:21:32,240 --> 00:21:35,280
across different cores should be

433
00:21:35,280 --> 00:21:39,440
synchronized in multiprocessor systems

434
00:21:39,440 --> 00:21:43,280
tlp shutdown is a process to synchronize

435
00:21:43,280 --> 00:21:47,120
synchronize the tlb of each core

436
00:21:47,120 --> 00:21:50,159
for example when

437
00:21:50,159 --> 00:21:53,520
a mapping the address or modifying the

438
00:21:53,520 --> 00:21:57,360
permission of the others in one core

439
00:21:57,360 --> 00:22:00,480
first the core flushes

440
00:22:00,480 --> 00:22:03,840
its own tlb and

441
00:22:03,840 --> 00:22:07,039
find another course that

442
00:22:07,039 --> 00:22:10,400
may have the same address in the tlb

443
00:22:10,400 --> 00:22:14,000
and send an ipi to flush them

444
00:22:14,000 --> 00:22:18,400
finally upon receiving the ipi

445
00:22:18,400 --> 00:22:21,919
the core flushes the address through the

446
00:22:21,919 --> 00:22:26,480
ipi handler

447
00:22:26,480 --> 00:22:29,679
to use tlv shutdown in extending the

448
00:22:29,679 --> 00:22:31,360
time window

449
00:22:31,360 --> 00:22:34,880
an additional process is required to

450
00:22:34,880 --> 00:22:36,000
send ipi

451
00:22:36,000 --> 00:22:39,520
to the target core in this figure

452
00:22:39,520 --> 00:22:42,799
the process c is the one

453
00:22:42,799 --> 00:22:46,400
sending ipi and the process

454
00:22:46,400 --> 00:22:48,960
a is the one that contains the time

455
00:22:48,960 --> 00:22:49,760
window

456
00:22:49,760 --> 00:22:52,960
we want to extend

457
00:22:53,200 --> 00:22:56,640
the important thing here is that

458
00:22:56,640 --> 00:23:00,000
the process a and c must have the

459
00:23:00,000 --> 00:23:03,679
same memory map and processes that

460
00:23:03,679 --> 00:23:06,640
shouldn't receive ipi must have

461
00:23:06,640 --> 00:23:08,880
different memory maps

462
00:23:08,880 --> 00:23:11,919
if three processes have the same memory

463
00:23:11,919 --> 00:23:13,120
map

464
00:23:13,120 --> 00:23:16,320
ipi is delivered to both core 1 and

465
00:23:16,320 --> 00:23:19,760
2 at the same time which leader 10

466
00:23:19,760 --> 00:23:24,880
extension extending both time windows

467
00:23:24,880 --> 00:23:28,159
if the boost if the process a

468
00:23:28,159 --> 00:23:31,360
and c have the same memory map and the

469
00:23:31,360 --> 00:23:32,159
process b

470
00:23:32,159 --> 00:23:35,440
has a different memory map ipi

471
00:23:35,440 --> 00:23:39,120
is only delivered to core one so

472
00:23:39,120 --> 00:23:44,719
only the time window x will be extended

473
00:23:47,760 --> 00:23:50,320
and the second method is hardware

474
00:23:50,320 --> 00:23:51,679
interrupt

475
00:23:51,679 --> 00:23:54,720
before sending interrupts we need

476
00:23:54,720 --> 00:23:57,760
two steps the first step is

477
00:23:57,760 --> 00:24:02,000
checking the core affinity of each irq

478
00:24:02,000 --> 00:24:04,960
the core affinity of irq can be checked

479
00:24:04,960 --> 00:24:05,440
through

480
00:24:05,440 --> 00:24:08,559
the file shown in the figure

481
00:24:08,559 --> 00:24:12,120
this file has a lead permission for the

482
00:24:12,120 --> 00:24:15,760
non-privileged user so attacker can

483
00:24:15,760 --> 00:24:19,840
find out the specific core

484
00:24:20,880 --> 00:24:23,520
the second step is pinning the thread

485
00:24:23,520 --> 00:24:26,000
that has the timing needed to

486
00:24:26,000 --> 00:24:30,240
be extended to that core

487
00:24:30,400 --> 00:24:34,240
if the process c calls the

488
00:24:34,240 --> 00:24:37,440
system call descendant request to a

489
00:24:37,440 --> 00:24:39,120
device and irq

490
00:24:39,120 --> 00:24:41,760
is delivered in the middle of the time

491
00:24:41,760 --> 00:24:43,440
window x

492
00:24:43,440 --> 00:24:47,600
the time window x is extended by

493
00:24:47,600 --> 00:24:51,039
inter-service luton and we can execute

494
00:24:51,039 --> 00:24:51,279
the

495
00:24:51,279 --> 00:24:55,520
instructions in the desired order

496
00:24:56,559 --> 00:24:59,760
now let's look at the efficiency of

497
00:24:59,760 --> 00:25:02,000
explains

498
00:25:02,000 --> 00:25:05,440
we measure how many cycles are extended

499
00:25:05,440 --> 00:25:06,240
through

500
00:25:06,240 --> 00:25:10,960
esp lace as a result of measuring the

501
00:25:10,960 --> 00:25:14,159
extended cycle due to the

502
00:25:14,159 --> 00:25:18,320
ipi the ipi extends from

503
00:25:18,320 --> 00:25:23,279
1.5 000 to 20 000 cycles

504
00:25:23,279 --> 00:25:26,960
the reason for wide length is

505
00:25:26,960 --> 00:25:30,559
that it can be it can only flush one tlb

506
00:25:30,559 --> 00:25:33,600
at a time when

507
00:25:33,600 --> 00:25:36,960
a larger dress is flushed

508
00:25:36,960 --> 00:25:40,000
it takes longer because it is

509
00:25:40,000 --> 00:25:43,360
flushed several times

510
00:25:43,360 --> 00:25:46,400
so the larger the amount of memory is

511
00:25:46,400 --> 00:25:47,760
being flushed

512
00:25:47,760 --> 00:25:52,000
the longer the time window is extended

513
00:25:52,000 --> 00:25:55,120
and hardware interrupts extend the time

514
00:25:55,120 --> 00:25:56,000
window by

515
00:25:56,000 --> 00:26:00,559
about 15 000 cycles

516
00:26:01,840 --> 00:26:04,960
the reason for introducing ipi

517
00:26:04,960 --> 00:26:08,240
and irq together is that two

518
00:26:08,240 --> 00:26:12,480
interrupts can be used at the same time

519
00:26:12,480 --> 00:26:15,919
ipi sends an interrupt to the core where

520
00:26:15,919 --> 00:26:19,200
a process with the same memory map is

521
00:26:19,200 --> 00:26:20,559
learning

522
00:26:20,559 --> 00:26:24,799
and the irq is sent to a specific core

523
00:26:24,799 --> 00:26:27,840
so the conditions doesn't

524
00:26:27,840 --> 00:26:30,880
does not overlap

525
00:26:30,880 --> 00:26:34,080
using both methods at the same time

526
00:26:34,080 --> 00:26:36,840
the target core is interrupted more

527
00:26:36,840 --> 00:26:39,159
often this means the

528
00:26:39,159 --> 00:26:42,000
probability that an interrupt is

529
00:26:42,000 --> 00:26:42,880
transmitted

530
00:26:42,880 --> 00:26:46,000
transmitted while the time in the axis

531
00:26:46,000 --> 00:26:49,520
running is increased and

532
00:26:49,520 --> 00:26:53,200
if irq and ipi are received at the same

533
00:26:53,200 --> 00:26:54,240
time

534
00:26:54,240 --> 00:26:57,919
the interrupt that comes first is handed

535
00:26:57,919 --> 00:27:00,880
first and then another interrupt is

536
00:27:00,880 --> 00:27:01,840
handled

537
00:27:01,840 --> 00:27:04,880
at this time the time window

538
00:27:04,880 --> 00:27:08,640
is extended up to 200

539
00:27:08,640 --> 00:27:11,600
000 cycles

540
00:27:12,559 --> 00:27:15,600
now let's exploit the non-inclusive

541
00:27:15,600 --> 00:27:16,400
multivariate

542
00:27:16,400 --> 00:27:19,840
lace condition binaural vulnerability

543
00:27:19,840 --> 00:27:20,559
through

544
00:27:20,559 --> 00:27:23,679
explains here is

545
00:27:23,679 --> 00:27:25,760
the non-inclusive lace condition

546
00:27:25,760 --> 00:27:27,200
vulnerability

547
00:27:27,200 --> 00:27:30,960
found in linux kernel

548
00:27:30,960 --> 00:27:34,399
the useful free vulnerability

549
00:27:34,399 --> 00:27:37,760
occurs if the instruction a is

550
00:27:37,760 --> 00:27:41,039
executed before instruction b

551
00:27:41,039 --> 00:27:44,960
and the c and the instruction c

552
00:27:44,960 --> 00:27:48,399
is executed before instruction d

553
00:27:48,399 --> 00:27:52,000
there but there are two problems

554
00:27:52,000 --> 00:27:55,919
in exploiting this vulnerability

555
00:27:55,919 --> 00:27:58,720
the first is a non-inclusive lace

556
00:27:58,720 --> 00:27:59,360
condition

557
00:27:59,360 --> 00:28:02,240
so no memory caption would be triggered

558
00:28:02,240 --> 00:28:02,559
if

559
00:28:02,559 --> 00:28:07,600
an exploit only used normal bursting

560
00:28:07,600 --> 00:28:11,200
the second is that there is no time to

561
00:28:11,200 --> 00:28:12,960
rear locate

562
00:28:12,960 --> 00:28:15,240
to exploit the use after free

563
00:28:15,240 --> 00:28:16,799
vulnerability

564
00:28:16,799 --> 00:28:19,760
all the yellow case step must be

565
00:28:19,760 --> 00:28:20,880
required

566
00:28:20,880 --> 00:28:24,960
however this vulnerability cannot be

567
00:28:24,960 --> 00:28:28,240
relocated because a location and

568
00:28:28,240 --> 00:28:32,559
free must be done almost

569
00:28:32,559 --> 00:28:35,760
location allocation step

570
00:28:35,760 --> 00:28:39,520
and three step and use that

571
00:28:39,520 --> 00:28:44,640
must be done almost simultaneously

572
00:28:44,640 --> 00:28:47,840
explains can solve two problems

573
00:28:47,840 --> 00:28:51,200
at once according to our measurement

574
00:28:51,200 --> 00:28:54,799
the time taken from the

575
00:28:54,799 --> 00:28:58,559
instruction b to allocate leo locate is

576
00:28:58,559 --> 00:29:01,600
about oh sorry

577
00:29:01,600 --> 00:29:03,520
according to our measurement the time

578
00:29:03,520 --> 00:29:06,000
taken from the instruction c

579
00:29:06,000 --> 00:29:10,960
to relocate is about 3 000 cycles

580
00:29:10,960 --> 00:29:14,640
as i mentioned earlier the time window

581
00:29:14,640 --> 00:29:14,960
is

582
00:29:14,960 --> 00:29:18,000
extended at least 15 15

583
00:29:18,000 --> 00:29:21,760
000 cycles due to exp lace

584
00:29:21,760 --> 00:29:25,520
so if the interrupt is received in

585
00:29:25,520 --> 00:29:29,440
correct timing the vulnerability will

586
00:29:29,440 --> 00:29:32,799
modify the memory that should not be

587
00:29:32,799 --> 00:29:35,520
modified

588
00:29:36,559 --> 00:29:40,080
now we can

589
00:29:40,080 --> 00:29:44,000
use it for free right to relocate buffer

590
00:29:44,000 --> 00:29:47,360
since this presentation is not focused

591
00:29:47,360 --> 00:29:47,840
on

592
00:29:47,840 --> 00:29:51,200
memory corruption exploit technique so

593
00:29:51,200 --> 00:29:54,320
i will explain it briefly

594
00:29:54,320 --> 00:29:57,600
first we spray the file structure

595
00:29:57,600 --> 00:30:00,880
pointer and we partially overlay

596
00:30:00,880 --> 00:30:04,000
data pointer pointers

597
00:30:04,000 --> 00:30:06,240
and we partially overwrite the data

598
00:30:06,240 --> 00:30:07,360
pointers

599
00:30:07,360 --> 00:30:10,799
in real located relocated

600
00:30:10,799 --> 00:30:14,640
structure so that it leaves spread area

601
00:30:14,640 --> 00:30:18,000
and lick the file pointer

602
00:30:18,000 --> 00:30:22,399
and we use iobc structures for

603
00:30:22,399 --> 00:30:24,880
arbitrary other suite and arbitrary

604
00:30:24,880 --> 00:30:27,679
address right

605
00:30:28,080 --> 00:30:36,640
so here is the demo

606
00:30:36,640 --> 00:30:40,320
first check the current

607
00:30:40,320 --> 00:30:44,000
id and first bring the

608
00:30:44,000 --> 00:30:46,880
file structure

609
00:30:48,399 --> 00:30:51,120
and then pre create the process that

610
00:30:51,120 --> 00:30:53,360
send an interrupt

611
00:30:53,360 --> 00:30:57,919
and trigger the

612
00:30:57,919 --> 00:31:01,279
vulnerability and leak the

613
00:31:01,279 --> 00:31:04,640
file pointer

614
00:31:04,640 --> 00:31:07,679
and leak the credit pointer of current

615
00:31:07,679 --> 00:31:09,120
process

616
00:31:09,120 --> 00:31:12,559
and finally we trigger the vulnerability

617
00:31:12,559 --> 00:31:15,840
one more and overwrite zero to uid

618
00:31:15,840 --> 00:31:17,440
variable

619
00:31:17,440 --> 00:31:22,240
finally we got the loot permission

620
00:31:25,360 --> 00:31:29,039
and in conclusion there is a type of

621
00:31:29,039 --> 00:31:30,799
lace condition vulnerability

622
00:31:30,799 --> 00:31:33,919
that cannot be exploited with normal

623
00:31:33,919 --> 00:31:35,519
break pricing

624
00:31:35,519 --> 00:31:39,279
and we introduced a new laser exploit

625
00:31:39,279 --> 00:31:40,480
technique

626
00:31:40,480 --> 00:31:44,240
explains with explains

627
00:31:44,240 --> 00:31:47,679
which turn unexplorable lace into

628
00:31:47,679 --> 00:31:51,919
least exploitable lace we can

629
00:31:51,919 --> 00:31:56,720
exploit the unexploitable lace condition

630
00:31:56,720 --> 00:32:00,000
explice utilize the hardware's basic

631
00:32:00,000 --> 00:32:02,880
interrupt mechanism so it is not

632
00:32:02,880 --> 00:32:04,320
affected by corner

633
00:32:04,320 --> 00:32:07,679
configuration or needs specific

634
00:32:07,679 --> 00:32:11,279
hardware so it is generally applicable

635
00:32:11,279 --> 00:32:14,799
okay so it is generally applicable

636
00:32:14,799 --> 00:32:17,600
regardless of the corner configuration

637
00:32:17,600 --> 00:32:18,240
or

638
00:32:18,240 --> 00:32:23,279
specific situation thank you

639
00:32:24,399 --> 00:32:28,080
the question is is there a white paper

640
00:32:28,080 --> 00:32:31,840
on this uh

641
00:32:31,840 --> 00:32:35,679
you're writing but

642
00:32:35,679 --> 00:32:39,120
not published now

643
00:32:39,120 --> 00:32:43,840
in uh after ever

644
00:32:46,240 --> 00:32:49,679
the next question is

645
00:32:49,679 --> 00:32:53,039
oh i wonder how i wonder for how many

646
00:32:53,039 --> 00:32:53,919
cases

647
00:32:53,919 --> 00:32:58,080
they try the technique in order to be

648
00:32:58,080 --> 00:33:01,279
sure that it is in the assets as well

649
00:33:01,279 --> 00:33:04,480
as it needs to be

650
00:33:07,360 --> 00:33:10,559
yes we test tested on windows and

651
00:33:10,559 --> 00:33:14,600
mac west and it

652
00:33:14,600 --> 00:33:17,840
practically works

653
00:33:17,840 --> 00:33:21,840
and we tested uh

654
00:33:21,840 --> 00:33:25,679
word more than tata 10 limitation books

655
00:33:25,679 --> 00:33:31,120
for proof that the general

656
00:33:36,840 --> 00:33:39,840
genetically

657
00:33:44,720 --> 00:33:48,080
and then next is

658
00:33:48,080 --> 00:33:52,639
are you planning to make the xp public

659
00:33:55,360 --> 00:33:59,360
i think about that but

660
00:34:00,960 --> 00:34:05,120
after working white paper published

661
00:34:05,120 --> 00:34:09,119
i will publicly

662
00:34:09,119 --> 00:34:21,839
open the exploit

663
00:35:48,000 --> 00:35:51,599
uh next question do you have github or

664
00:35:51,599 --> 00:35:57,040
reader to file for futurely from you

665
00:35:57,040 --> 00:36:01,040
uh i don't have a public key

666
00:36:01,040 --> 00:36:05,680
top iv enter but

667
00:36:06,800 --> 00:36:09,839
follow our

668
00:36:11,359 --> 00:36:27,839
follow our left side

669
00:36:38,839 --> 00:36:41,839
uh

670
00:37:09,040 --> 00:37:12,240
uh i think it's fun

671
00:37:12,240 --> 00:37:16,400
was it difficult to find i i iq gathered

672
00:37:16,400 --> 00:37:20,800
richer from cisco's

673
00:37:20,839 --> 00:37:24,320
u.s no

674
00:37:24,480 --> 00:37:28,240
yeah it's probably the same

675
00:37:28,240 --> 00:37:31,440
mechanism so

676
00:37:31,440 --> 00:37:34,640
it's d

677
00:37:34,640 --> 00:37:37,839
yeah yeah

678
00:38:30,240 --> 00:38:33,839
i think thank you for learning

679
00:38:34,880 --> 00:38:38,079
our presentation

680
00:38:44,000 --> 00:38:47,839
thank you

