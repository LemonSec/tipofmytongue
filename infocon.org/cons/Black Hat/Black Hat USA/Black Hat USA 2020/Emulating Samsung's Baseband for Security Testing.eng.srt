1
00:00:04,110 --> 00:00:16,720
[Music]

2
00:00:16,720 --> 00:00:18,080
okay

3
00:00:18,080 --> 00:00:19,680
well uh thanks so much everybody for

4
00:00:19,680 --> 00:00:21,279
joining me to my talk

5
00:00:21,279 --> 00:00:23,119
um i'm happy to present work we've been

6
00:00:23,119 --> 00:00:24,400
working on for the last year on

7
00:00:24,400 --> 00:00:26,800
emulating samsung's baseband

8
00:00:26,800 --> 00:00:28,880
um before we get to into it a little bit

9
00:00:28,880 --> 00:00:30,960
about me i'm grant hernandez

10
00:00:30,960 --> 00:00:32,640
i'm a recent phd graduate from the

11
00:00:32,640 --> 00:00:34,320
university of florida

12
00:00:34,320 --> 00:00:36,320
and i work primarily on android security

13
00:00:36,320 --> 00:00:38,000
and firmware analysis

14
00:00:38,000 --> 00:00:39,680
and i just joined qualcomm's product

15
00:00:39,680 --> 00:00:42,480
security team working on their modem

16
00:00:42,480 --> 00:00:44,640
my co-author marius mensch a phd

17
00:00:44,640 --> 00:00:46,160
graduate from eurocom

18
00:00:46,160 --> 00:00:49,120
he's a postdoc at fusek and he works on

19
00:00:49,120 --> 00:00:50,719
building tooling for better dynamic

20
00:00:50,719 --> 00:00:52,559
analysis of embed systems

21
00:00:52,559 --> 00:00:54,800
unfortunately he can't be here today but

22
00:00:54,800 --> 00:00:56,399
please just imagine he's standing right

23
00:00:56,399 --> 00:00:57,520
next to me because

24
00:00:57,520 --> 00:01:00,000
he was as integral to this work as i was

25
00:01:00,000 --> 00:01:01,280
so

26
00:01:01,280 --> 00:01:03,120
um let's talk a little bit about our

27
00:01:03,120 --> 00:01:04,799
agenda today

28
00:01:04,799 --> 00:01:06,400
so um i'm going to start with a little

29
00:01:06,400 --> 00:01:08,400
bit of a motivation as to why we decide

30
00:01:08,400 --> 00:01:09,840
to look at basebands

31
00:01:09,840 --> 00:01:11,360
and to do that we're going to actually

32
00:01:11,360 --> 00:01:14,320
go over some previous baseband work

33
00:01:14,320 --> 00:01:16,080
initially we'll talk about how i started

34
00:01:16,080 --> 00:01:17,840
doing baseband vulnerability research

35
00:01:17,840 --> 00:01:18,720
and well it felt

36
00:01:18,720 --> 00:01:21,040
where it fell short and then we'll jump

37
00:01:21,040 --> 00:01:22,240
right into reverse engineering the

38
00:01:22,240 --> 00:01:23,520
baseband firmware

39
00:01:23,520 --> 00:01:25,680
how we built the baseband emulator and

40
00:01:25,680 --> 00:01:27,119
then how we actually used

41
00:01:27,119 --> 00:01:30,400
our angular to fuzz via afl allowing us

42
00:01:30,400 --> 00:01:32,799
to find end days and zero days

43
00:01:32,799 --> 00:01:34,240
uh finally we'll actually demonstrate

44
00:01:34,240 --> 00:01:36,159
that the things we find in our emulator

45
00:01:36,159 --> 00:01:38,240
actually work over the air and then

46
00:01:38,240 --> 00:01:40,400
we'll conclude

47
00:01:40,400 --> 00:01:42,399
so before we get really deep into the

48
00:01:42,399 --> 00:01:43,840
weeds let's make sure everyone's on the

49
00:01:43,840 --> 00:01:44,880
same page

50
00:01:44,880 --> 00:01:46,399
and i want everyone to know what a

51
00:01:46,399 --> 00:01:48,240
baseband processor is

52
00:01:48,240 --> 00:01:50,799
it's effectively a dedicated device that

53
00:01:50,799 --> 00:01:52,720
is implementing the two through five g

54
00:01:52,720 --> 00:01:55,119
cellular protocols this pretty much

55
00:01:55,119 --> 00:01:56,719
allows you to walk outside of your house

56
00:01:56,719 --> 00:01:58,320
without a wi-fi connection and be able

57
00:01:58,320 --> 00:01:59,520
to get data calls

58
00:01:59,520 --> 00:02:03,040
sms and and the like and it really is

59
00:02:03,040 --> 00:02:05,600
the phone part of your smartphone

60
00:02:05,600 --> 00:02:08,479
so the vendors below implement their own

61
00:02:08,479 --> 00:02:10,080
version of the baseband processor

62
00:02:10,080 --> 00:02:12,959
based off of the cellular protocols

63
00:02:12,959 --> 00:02:15,599
these basebands run embedded firmware

64
00:02:15,599 --> 00:02:17,280
and they usually leverage a real-time

65
00:02:17,280 --> 00:02:18,959
operating system to

66
00:02:18,959 --> 00:02:20,720
schedule tasks and maintain their

67
00:02:20,720 --> 00:02:22,480
real-time deadlines

68
00:02:22,480 --> 00:02:23,760
and it's important to note that

69
00:02:23,760 --> 00:02:25,840
basebands are separate cpus

70
00:02:25,840 --> 00:02:27,840
from the application processor found on

71
00:02:27,840 --> 00:02:29,440
mobile phones whether it's

72
00:02:29,440 --> 00:02:31,760
android or ios and this is likely due to

73
00:02:31,760 --> 00:02:34,480
their performance requirements

74
00:02:34,480 --> 00:02:37,920
so why basebands well basebands have a

75
00:02:37,920 --> 00:02:39,519
lot of attack surface

76
00:02:39,519 --> 00:02:41,760
as i said they support the 2 through 5g

77
00:02:41,760 --> 00:02:44,480
protocols which are really complicated

78
00:02:44,480 --> 00:02:45,680
some of the things you can find on

79
00:02:45,680 --> 00:02:48,800
basebands include custom dsps

80
00:02:48,800 --> 00:02:51,440
asm1 encoders possibly auto generated or

81
00:02:51,440 --> 00:02:52,879
written by hand

82
00:02:52,879 --> 00:02:56,160
custom ip ip stacks voice and audio

83
00:02:56,160 --> 00:02:57,680
codecs

84
00:02:57,680 --> 00:03:00,720
x509 parsing dns parsing and a ton

85
00:03:00,720 --> 00:03:02,959
more the more you look the more you find

86
00:03:02,959 --> 00:03:04,400
some things are really obscure and

87
00:03:04,400 --> 00:03:05,519
unique to sell here

88
00:03:05,519 --> 00:03:07,040
some things are things you'd only expect

89
00:03:07,040 --> 00:03:09,440
to find on a desktop

90
00:03:09,440 --> 00:03:11,920
and another reason is that baseband

91
00:03:11,920 --> 00:03:14,000
attacks can be devastating

92
00:03:14,000 --> 00:03:16,159
so imagine being able to compromise a

93
00:03:16,159 --> 00:03:17,120
baseband

94
00:03:17,120 --> 00:03:18,480
at this point if you're running code on

95
00:03:18,480 --> 00:03:20,879
a baseband you can intercept calls

96
00:03:20,879 --> 00:03:23,360
sms and all the data independent of the

97
00:03:23,360 --> 00:03:24,720
operating system

98
00:03:24,720 --> 00:03:26,720
and even if you're feeling really bold

99
00:03:26,720 --> 00:03:28,000
you can try and escalate to the

100
00:03:28,000 --> 00:03:29,440
application processor itself

101
00:03:29,440 --> 00:03:31,440
further compromising the phone so it's

102
00:03:31,440 --> 00:03:34,720
an important attack vector to consider

103
00:03:34,720 --> 00:03:36,560
today we'll be focusing on samsung

104
00:03:36,560 --> 00:03:38,000
shannon baseband

105
00:03:38,000 --> 00:03:39,760
this baseband is present on samsung's

106
00:03:39,760 --> 00:03:42,080
smartphones with the x on his chipset

107
00:03:42,080 --> 00:03:44,319
effectively non-us phones because the us

108
00:03:44,319 --> 00:03:47,040
phones use qualcomm's chipset instead

109
00:03:47,040 --> 00:03:49,280
it implements two through 5g protocols

110
00:03:49,280 --> 00:03:51,440
and it uses an arm cortex-r

111
00:03:51,440 --> 00:03:54,480
to maintain its real-time properties

112
00:03:54,480 --> 00:03:56,080
and it's an interesting vulnerability

113
00:03:56,080 --> 00:03:57,920
research target it's

114
00:03:57,920 --> 00:03:59,439
been shown that there are over-the-air

115
00:03:59,439 --> 00:04:01,200
attacks that can be launched against the

116
00:04:01,200 --> 00:04:02,640
the baseband itself

117
00:04:02,640 --> 00:04:04,640
and it's also been shown that there are

118
00:04:04,640 --> 00:04:06,720
less than seller exploit mitigations

119
00:04:06,720 --> 00:04:08,959
on the application than compared to the

120
00:04:08,959 --> 00:04:11,360
application processor

121
00:04:11,360 --> 00:04:13,519
there's been three talks that are really

122
00:04:13,519 --> 00:04:15,280
good on chain and exploitation

123
00:04:15,280 --> 00:04:17,199
the breaking ban talk the walk with

124
00:04:17,199 --> 00:04:18,880
shannon which went over a pawn to own

125
00:04:18,880 --> 00:04:20,560
vulnerability in great detail

126
00:04:20,560 --> 00:04:22,880
and even more recent more recently how

127
00:04:22,880 --> 00:04:24,000
to actually design

128
00:04:24,000 --> 00:04:27,520
a baseband debugger on device so

129
00:04:27,520 --> 00:04:29,040
in this case we'll be doing our

130
00:04:29,040 --> 00:04:32,479
debugging in our virtual environment

131
00:04:32,479 --> 00:04:35,440
uh there is other baseband work too but

132
00:04:35,440 --> 00:04:36,960
as you can see by the dates

133
00:04:36,960 --> 00:04:39,840
and the years not as much as you would

134
00:04:39,840 --> 00:04:40,880
expect

135
00:04:40,880 --> 00:04:42,880
given the importance of it on our mobile

136
00:04:42,880 --> 00:04:44,240
devices today

137
00:04:44,240 --> 00:04:45,360
it's something that's in everyone's

138
00:04:45,360 --> 00:04:47,600
pocket but really there hasn't been

139
00:04:47,600 --> 00:04:50,720
in my opinion enough focus on the impact

140
00:04:50,720 --> 00:04:52,400
of exploits and memory corruptions in

141
00:04:52,400 --> 00:04:53,280
base bands

142
00:04:53,280 --> 00:04:54,960
the fact that i can put most of the top

143
00:04:54,960 --> 00:04:56,400
work on one slide

144
00:04:56,400 --> 00:04:59,680
i should tell you that and that's where

145
00:04:59,680 --> 00:05:00,479
really

146
00:05:00,479 --> 00:05:02,720
our work comes in we've developed a tool

147
00:05:02,720 --> 00:05:04,400
called shannon ee

148
00:05:04,400 --> 00:05:06,000
it's an emulation environment for the

149
00:05:06,000 --> 00:05:07,440
shannon baseband

150
00:05:07,440 --> 00:05:09,280
and what it does is it executes firmware

151
00:05:09,280 --> 00:05:11,280
directly so no pre-processing

152
00:05:11,280 --> 00:05:12,639
such as a static analysis tool is

153
00:05:12,639 --> 00:05:14,880
required you don't need a physical

154
00:05:14,880 --> 00:05:15,600
device

155
00:05:15,600 --> 00:05:18,080
and it's a scalable to as many cores you

156
00:05:18,080 --> 00:05:19,199
have available

157
00:05:19,199 --> 00:05:21,360
it is able to cold boot a baseband and

158
00:05:21,360 --> 00:05:24,000
brings up most rtos tasks

159
00:05:24,000 --> 00:05:25,360
some of the core features include a

160
00:05:25,360 --> 00:05:27,280
python api for

161
00:05:27,280 --> 00:05:29,680
pro prototyping peripherals and anything

162
00:05:29,680 --> 00:05:31,280
else you can come up with

163
00:05:31,280 --> 00:05:34,560
mod kit and c-based ffi for extending

164
00:05:34,560 --> 00:05:36,800
and exploring the baseband

165
00:05:36,800 --> 00:05:38,560
integrated coverage guided fuzzing the

166
00:05:38,560 --> 00:05:40,720
afl gdb for triage

167
00:05:40,720 --> 00:05:43,759
and support for multiple soc versions

168
00:05:43,759 --> 00:05:46,240
so all in all this gives us a really

169
00:05:46,240 --> 00:05:47,039
good platform

170
00:05:47,039 --> 00:05:48,479
and i'm going to show it to you right

171
00:05:48,479 --> 00:05:53,840
off the bat

172
00:05:54,479 --> 00:05:56,720
so all you really need to do is run our

173
00:05:56,720 --> 00:05:58,000
shannon wrapper

174
00:05:58,000 --> 00:05:59,440
at which point there's a config file

175
00:05:59,440 --> 00:06:01,520
which will be loaded and it will

176
00:06:01,520 --> 00:06:02,960
tell which baseband firmware we're going

177
00:06:02,960 --> 00:06:04,720
to target it will initialize the

178
00:06:04,720 --> 00:06:06,639
baseband emulator

179
00:06:06,639 --> 00:06:09,120
it will apply hooks you can introspect

180
00:06:09,120 --> 00:06:09,919
it'll boot

181
00:06:09,919 --> 00:06:11,919
the bootloader jump straight to the main

182
00:06:11,919 --> 00:06:14,479
file these are the log messages coming

183
00:06:14,479 --> 00:06:15,360
from the

184
00:06:15,360 --> 00:06:17,520
non-volatile memory initialization and

185
00:06:17,520 --> 00:06:18,960
it will just continue booting

186
00:06:18,960 --> 00:06:21,600
and it will start initializing tasks and

187
00:06:21,600 --> 00:06:23,680
you can at that point start fuzzing or

188
00:06:23,680 --> 00:06:25,680
start exploring the base band of memory

189
00:06:25,680 --> 00:06:28,560
craft your exploits and the like so it's

190
00:06:28,560 --> 00:06:30,479
a real dynamic analysis platform for

191
00:06:30,479 --> 00:06:31,919
base bands which

192
00:06:31,919 --> 00:06:33,600
to my knowledge there hasn't been one

193
00:06:33,600 --> 00:06:36,400
publicly released

194
00:06:36,479 --> 00:06:38,080
but how did we get here i think the

195
00:06:38,080 --> 00:06:39,600
journey of how we actually got this tool

196
00:06:39,600 --> 00:06:40,319
to work

197
00:06:40,319 --> 00:06:42,479
is more interesting than the tool itself

198
00:06:42,479 --> 00:06:43,919
and i'm going to tell you how we

199
00:06:43,919 --> 00:06:47,360
actually achieve this so it actually

200
00:06:47,360 --> 00:06:48,479
started last year

201
00:06:48,479 --> 00:06:50,639
around may and honestly probably a

202
00:06:50,639 --> 00:06:51,759
little before that

203
00:06:51,759 --> 00:06:54,400
um i had started to do um kind of a

204
00:06:54,400 --> 00:06:55,599
discussion of what i could do to

205
00:06:55,599 --> 00:06:56,960
actually do baseband analysis

206
00:06:56,960 --> 00:06:58,479
was i going to go static was it going to

207
00:06:58,479 --> 00:07:00,720
go dynamic i had seen a lot of static

208
00:07:00,720 --> 00:07:02,479
work but i ended up trying to do a

209
00:07:02,479 --> 00:07:04,880
baseband fuzzing over the air

210
00:07:04,880 --> 00:07:07,520
i didn't have any experience with sdr or

211
00:07:07,520 --> 00:07:09,440
cellular but i had a lot of reversing

212
00:07:09,440 --> 00:07:11,280
and exploitation knowledge

213
00:07:11,280 --> 00:07:13,199
under my belt so how hard could it be

214
00:07:13,199 --> 00:07:14,720
right well

215
00:07:14,720 --> 00:07:16,639
cellular protocol standards are pretty

216
00:07:16,639 --> 00:07:18,160
much acronym soup

217
00:07:18,160 --> 00:07:19,440
which makes things really hard to get

218
00:07:19,440 --> 00:07:21,919
into i spend a whole lot of time

219
00:07:21,919 --> 00:07:23,440
wrestling with the physical aspects

220
00:07:23,440 --> 00:07:25,680
because i'm not a signal analysis person

221
00:07:25,680 --> 00:07:27,520
um base stations getting them set up and

222
00:07:27,520 --> 00:07:29,199
then debugging why my phone wasn't

223
00:07:29,199 --> 00:07:30,240
working

224
00:07:30,240 --> 00:07:33,120
was a big headache but finally after

225
00:07:33,120 --> 00:07:33,840
reading and

226
00:07:33,840 --> 00:07:35,199
trying things out i was able to get a

227
00:07:35,199 --> 00:07:37,680
test set up with a 2g base station

228
00:07:37,680 --> 00:07:41,919
and 2g and implemented the gsm and gprs

229
00:07:41,919 --> 00:07:45,440
data protocols i added a really dead

230
00:07:45,440 --> 00:07:46,639
simple bit flipper

231
00:07:46,639 --> 00:07:49,759
to the layer two to layer one code

232
00:07:49,759 --> 00:07:51,599
so i would flip all packets leaving the

233
00:07:51,599 --> 00:07:53,199
baseband

234
00:07:53,199 --> 00:07:54,879
i then connected a mix of phones to the

235
00:07:54,879 --> 00:07:56,240
network

236
00:07:56,240 --> 00:07:58,960
i use an adb log cat monitor to see if i

237
00:07:58,960 --> 00:08:00,560
can find crashes

238
00:08:00,560 --> 00:08:02,800
and i found crashes uh which is really

239
00:08:02,800 --> 00:08:03,759
cool um

240
00:08:03,759 --> 00:08:06,560
but then i now realized the the main

241
00:08:06,560 --> 00:08:08,240
issue with this approach

242
00:08:08,240 --> 00:08:10,000
i couldn't understand why they had

243
00:08:10,000 --> 00:08:11,599
crashed i was just flipping

244
00:08:11,599 --> 00:08:13,919
packets randomly and not to mention that

245
00:08:13,919 --> 00:08:15,199
the phones themselves

246
00:08:15,199 --> 00:08:16,800
weren't giving me the required debugging

247
00:08:16,800 --> 00:08:18,080
output to actually figure out what was

248
00:08:18,080 --> 00:08:18,639
happening

249
00:08:18,639 --> 00:08:20,319
let alone the impact of what i just

250
00:08:20,319 --> 00:08:22,160
found and on the right here you can see

251
00:08:22,160 --> 00:08:22,720
a phone

252
00:08:22,720 --> 00:08:25,039
crash i got on a samsung phone and this

253
00:08:25,039 --> 00:08:26,000
is all it told me

254
00:08:26,000 --> 00:08:28,400
it it mentions oh there's a memory guard

255
00:08:28,400 --> 00:08:29,919
corruption which sounds really promising

256
00:08:29,919 --> 00:08:31,919
it's a heap overflow but it has this

257
00:08:31,919 --> 00:08:33,599
thing a little symbol

258
00:08:33,599 --> 00:08:36,080
it's like the word root looking more

259
00:08:36,080 --> 00:08:37,120
into that um

260
00:08:37,120 --> 00:08:39,279
and honestly i should have probably

261
00:08:39,279 --> 00:08:41,039
listened to comp secures they don't

262
00:08:41,039 --> 00:08:41,599
recommend

263
00:08:41,599 --> 00:08:43,599
ota fuzzing for more than just the fact

264
00:08:43,599 --> 00:08:45,519
that you can't get debugging output on

265
00:08:45,519 --> 00:08:47,200
base fans

266
00:08:47,200 --> 00:08:50,480
it's just not a good approach um

267
00:08:50,480 --> 00:08:52,240
looking more into the debugging side of

268
00:08:52,240 --> 00:08:53,920
things i found that there are root

269
00:08:53,920 --> 00:08:56,080
checks within the baseband code itself

270
00:08:56,080 --> 00:08:58,000
pretty much if it's if your phone's been

271
00:08:58,000 --> 00:09:00,399
unlocked or rooted in a way that i guess

272
00:09:00,399 --> 00:09:00,800
is

273
00:09:00,800 --> 00:09:03,680
you know not using an exploit the modem

274
00:09:03,680 --> 00:09:05,040
will no longer give you the debugging

275
00:09:05,040 --> 00:09:07,440
output that you would expect

276
00:09:07,440 --> 00:09:09,040
so we're kind of kind of stuck to get

277
00:09:09,040 --> 00:09:10,640
modem dumps we need root

278
00:09:10,640 --> 00:09:13,839
but rooting suppresses modem logs so

279
00:09:13,839 --> 00:09:15,839
how do we actually find let alone debug

280
00:09:15,839 --> 00:09:17,360
these memory corruptions in a scalable

281
00:09:17,360 --> 00:09:18,320
way

282
00:09:18,320 --> 00:09:20,399
the anti-debug makes this difficult we

283
00:09:20,399 --> 00:09:21,600
probably need some off-the-shelf

284
00:09:21,600 --> 00:09:24,880
exploits to bypass these things silently

285
00:09:24,880 --> 00:09:27,360
manual engineering is an option but base

286
00:09:27,360 --> 00:09:29,120
bands are huge this doesn't really scale

287
00:09:29,120 --> 00:09:29,920
too well and

288
00:09:29,920 --> 00:09:31,920
um on the link there you can visit

289
00:09:31,920 --> 00:09:33,600
offline is a

290
00:09:33,600 --> 00:09:35,760
kind of a demonstration of how much is

291
00:09:35,760 --> 00:09:37,839
really going on at a baseband

292
00:09:37,839 --> 00:09:39,440
so from a vulnerability research

293
00:09:39,440 --> 00:09:41,440
perspective

294
00:09:41,440 --> 00:09:44,399
the gdb coverage guided fuzzer and

295
00:09:44,399 --> 00:09:45,839
snapchatting

296
00:09:45,839 --> 00:09:47,360
so at this point seems like the most

297
00:09:47,360 --> 00:09:49,200
viable approach was to drop the over

298
00:09:49,200 --> 00:09:50,000
there fuzzing

299
00:09:50,000 --> 00:09:53,760
and go jump straight into emulation

300
00:09:53,760 --> 00:09:55,519
to do that we started by reversing the

301
00:09:55,519 --> 00:09:56,959
firmware

302
00:09:56,959 --> 00:09:58,720
and this started by getting the firmware

303
00:09:58,720 --> 00:10:00,640
from a publicly available source

304
00:10:00,640 --> 00:10:02,720
um we bought a research phone the

305
00:10:02,720 --> 00:10:05,040
samsung s10 we targeted this specific

306
00:10:05,040 --> 00:10:05,839
firmware

307
00:10:05,839 --> 00:10:08,079
and uh we was able to we also had to

308
00:10:08,079 --> 00:10:09,519
launch a other firmware lying around

309
00:10:09,519 --> 00:10:11,120
which we used this kind of flowchart to

310
00:10:11,120 --> 00:10:12,240
categorize

311
00:10:12,240 --> 00:10:14,480
pretty much it's just the zip file tar

312
00:10:14,480 --> 00:10:15,440
files within it

313
00:10:15,440 --> 00:10:17,200
we pick one tar file which has the modem

314
00:10:17,200 --> 00:10:19,839
code untar it we have modem.bin

315
00:10:19,839 --> 00:10:22,480
and modem debug that bin uh there had

316
00:10:22,480 --> 00:10:24,640
been talk that actually these files

317
00:10:24,640 --> 00:10:26,800
were encrypted we didn't see that none

318
00:10:26,800 --> 00:10:28,079
of our images were encrypted

319
00:10:28,079 --> 00:10:29,600
we were able to just throw it into geija

320
00:10:29,600 --> 00:10:32,160
and get started this format

321
00:10:32,160 --> 00:10:34,320
the the table of contents format i'll

322
00:10:34,320 --> 00:10:35,680
show on the next slide it's been well

323
00:10:35,680 --> 00:10:38,720
reverse engineered already

324
00:10:38,720 --> 00:10:40,240
so it's a pretty simple format the

325
00:10:40,240 --> 00:10:42,800
modem.bin file has a header

326
00:10:42,800 --> 00:10:46,240
this header has a name file load address

327
00:10:46,240 --> 00:10:49,200
size crc and entry id and then this

328
00:10:49,200 --> 00:10:51,040
header is replicated for every entry

329
00:10:51,040 --> 00:10:53,600
within the toc format

330
00:10:53,600 --> 00:10:55,360
but for our purposes we are really only

331
00:10:55,360 --> 00:10:57,680
interested into into these two sections

332
00:10:57,680 --> 00:11:00,399
the boot and main sections

333
00:11:00,399 --> 00:11:02,640
uh starting with the boot we seeked

334
00:11:02,640 --> 00:11:03,920
forward into the file

335
00:11:03,920 --> 00:11:06,720
defined at start points and uh looking

336
00:11:06,720 --> 00:11:08,240
into the actual code

337
00:11:08,240 --> 00:11:09,760
we started to notice a very obvious

338
00:11:09,760 --> 00:11:10,959
pattern if you've done arm reverse

339
00:11:10,959 --> 00:11:12,000
engineering

340
00:11:12,000 --> 00:11:14,720
the the conditional flag is set so this

341
00:11:14,720 --> 00:11:16,000
pretty much means the code is not

342
00:11:16,000 --> 00:11:16,720
encrypted

343
00:11:16,720 --> 00:11:18,480
and uh we can just throw it into each

344
00:11:18,480 --> 00:11:20,720
other and get started

345
00:11:20,720 --> 00:11:22,880
um further disassembling confirm these

346
00:11:22,880 --> 00:11:24,480
are the exception vectors

347
00:11:24,480 --> 00:11:25,920
and at which point we can then jump

348
00:11:25,920 --> 00:11:28,399
straight into the boot um the reset

349
00:11:28,399 --> 00:11:31,600
exception handler and get started on

350
00:11:31,600 --> 00:11:32,880
doing some reverse engineering

351
00:11:32,880 --> 00:11:34,720
disassembling and naming

352
00:11:34,720 --> 00:11:36,240
we realize that the bootloader is using

353
00:11:36,240 --> 00:11:38,079
uart which is really cool

354
00:11:38,079 --> 00:11:39,360
something we're going to emulate later

355
00:11:39,360 --> 00:11:41,440
on to be able to get this output or

356
00:11:41,440 --> 00:11:42,959
pretty much liberate this output from

357
00:11:42,959 --> 00:11:45,440
the baseband and we also noted

358
00:11:45,440 --> 00:11:47,600
two boot modes the dump and the regular

359
00:11:47,600 --> 00:11:48,560
boot mode

360
00:11:48,560 --> 00:11:50,639
and in order to do an emulation to be

361
00:11:50,639 --> 00:11:52,320
able to bring up this firmware in our

362
00:11:52,320 --> 00:11:53,120
shannon ee

363
00:11:53,120 --> 00:11:55,200
system we need to know who's signaling

364
00:11:55,200 --> 00:11:56,639
these boot modes and what what boot

365
00:11:56,639 --> 00:11:58,720
modes are possible

366
00:11:58,720 --> 00:12:00,399
so that brought us to a side quest on

367
00:12:00,399 --> 00:12:02,480
the into the samsung kernel

368
00:12:02,480 --> 00:12:04,639
thankfully because of the gpl this is

369
00:12:04,639 --> 00:12:05,839
available publicly

370
00:12:05,839 --> 00:12:07,760
i mirrored it here at this link but

371
00:12:07,760 --> 00:12:09,200
effectively there are

372
00:12:09,200 --> 00:12:10,639
there's the modem driver within the

373
00:12:10,639 --> 00:12:13,200
within the code uh we looked at it and

374
00:12:13,200 --> 00:12:14,880
two files stood out

375
00:12:14,880 --> 00:12:17,040
the modem i o device file which is

376
00:12:17,040 --> 00:12:18,560
actually the i o control

377
00:12:18,560 --> 00:12:22,480
handlers for the modem driver

378
00:12:22,480 --> 00:12:24,560
and this allows for read and write and

379
00:12:24,560 --> 00:12:26,480
then this linked device memory file

380
00:12:26,480 --> 00:12:28,320
which actually contains trucks on the

381
00:12:28,320 --> 00:12:29,680
shared memory regions

382
00:12:29,680 --> 00:12:31,760
between the application processor and

383
00:12:31,760 --> 00:12:33,680
cellular processor

384
00:12:33,680 --> 00:12:35,600
looking more into the i o controls

385
00:12:35,600 --> 00:12:37,440
there's something called cbd or the

386
00:12:37,440 --> 00:12:39,040
cellular boot daemon

387
00:12:39,040 --> 00:12:40,959
this communicates with the dev node via

388
00:12:40,959 --> 00:12:42,079
io controls

389
00:12:42,079 --> 00:12:45,040
and it actually will boot the modem up

390
00:12:45,040 --> 00:12:46,880
it will do this by first resetting it

391
00:12:46,880 --> 00:12:50,480
setting up security setting it to on

392
00:12:50,480 --> 00:12:52,480
booting on download which means i'll

393
00:12:52,480 --> 00:12:53,600
upload the code

394
00:12:53,600 --> 00:12:56,399
and then boot off um the security

395
00:12:56,399 --> 00:12:57,760
request is actually interesting and

396
00:12:57,760 --> 00:12:59,600
i'd like to talk about that at another

397
00:12:59,600 --> 00:13:01,839
time but that pretty much enables secure

398
00:13:01,839 --> 00:13:04,560
boot for the moda

399
00:13:04,720 --> 00:13:07,120
so looking more into this uh shared this

400
00:13:07,120 --> 00:13:08,720
link device memory file we found a

401
00:13:08,720 --> 00:13:09,519
structure

402
00:13:09,519 --> 00:13:12,000
that's packed and is referenced in the

403
00:13:12,000 --> 00:13:12,800
actual

404
00:13:12,800 --> 00:13:16,160
uh io like it's an i o memory uh

405
00:13:16,160 --> 00:13:18,639
reference so what this really means is

406
00:13:18,639 --> 00:13:20,000
actually going to be used for dma

407
00:13:20,000 --> 00:13:22,800
and ipc there are commands and there's

408
00:13:22,800 --> 00:13:24,079
this magic field

409
00:13:24,079 --> 00:13:26,800
this magic field actually matched the

410
00:13:26,800 --> 00:13:27,839
the magic

411
00:13:27,839 --> 00:13:29,440
numbers here actually match what we saw

412
00:13:29,440 --> 00:13:30,880
in the baseband bootloader

413
00:13:30,880 --> 00:13:32,959
which means we can now actually map this

414
00:13:32,959 --> 00:13:35,200
same memory region in our emulator

415
00:13:35,200 --> 00:13:37,040
to be able to signal to the bootloader

416
00:13:37,040 --> 00:13:38,480
how we would like it to boot

417
00:13:38,480 --> 00:13:40,240
and allow us to explore the baseband and

418
00:13:40,240 --> 00:13:42,000
continue booting

419
00:13:42,000 --> 00:13:44,639
forward as a side note those other

420
00:13:44,639 --> 00:13:47,120
buffers the format and the raw tx and rx

421
00:13:47,120 --> 00:13:48,800
buffs those are actually receiving

422
00:13:48,800 --> 00:13:50,240
commands from the samsung

423
00:13:50,240 --> 00:13:52,480
radio interface layer so that's actually

424
00:13:52,480 --> 00:13:53,839
something we'd like to explore further

425
00:13:53,839 --> 00:13:56,079
because that is really the ipc between

426
00:13:56,079 --> 00:13:58,240
the linux kernel and the base the

427
00:13:58,240 --> 00:14:00,959
baseband itself

428
00:14:00,959 --> 00:14:02,560
so with this reverse engineering out of

429
00:14:02,560 --> 00:14:04,480
the way we actually had this uh nice

430
00:14:04,480 --> 00:14:06,000
block diagram we could make to help us

431
00:14:06,000 --> 00:14:06,880
understand

432
00:14:06,880 --> 00:14:08,639
kind of like how everything's organized

433
00:14:08,639 --> 00:14:09,839
and to make sure that we're on the same

434
00:14:09,839 --> 00:14:10,800
page

435
00:14:10,800 --> 00:14:12,800
um so far we've looked at these portions

436
00:14:12,800 --> 00:14:14,639
we had looked at the the modem interface

437
00:14:14,639 --> 00:14:15,120
which is

438
00:14:15,120 --> 00:14:17,680
the host interface and via ipc cross

439
00:14:17,680 --> 00:14:18,480
core

440
00:14:18,480 --> 00:14:20,240
and we'd also seen that there is uart

441
00:14:20,240 --> 00:14:21,519
but there's a lot more to look at

442
00:14:21,519 --> 00:14:23,440
we need the tasks that are specific to

443
00:14:23,440 --> 00:14:25,040
the seller technologies

444
00:14:25,040 --> 00:14:27,120
we need the other peripherals and that's

445
00:14:27,120 --> 00:14:30,480
brings us to our next step

446
00:14:30,480 --> 00:14:31,839
at this point we could actually start

447
00:14:31,839 --> 00:14:34,160
writing emulation code but first we need

448
00:14:34,160 --> 00:14:35,519
to pick our weapons

449
00:14:35,519 --> 00:14:37,760
and for that we chose avatar 2 which

450
00:14:37,760 --> 00:14:40,079
uses kimu as a target underneath

451
00:14:40,079 --> 00:14:42,000
a little bit about avatar 2 it's

452
00:14:42,000 --> 00:14:43,440
actually a python framework

453
00:14:43,440 --> 00:14:45,760
that orchestrates other frameworks and

454
00:14:45,760 --> 00:14:48,000
allows you to interoperate between them

455
00:14:48,000 --> 00:14:50,240
it allows you to define python based

456
00:14:50,240 --> 00:14:51,600
peripheral definitions

457
00:14:51,600 --> 00:14:54,079
for easy prototyping which we which i

458
00:14:54,079 --> 00:14:55,760
really liked because

459
00:14:55,760 --> 00:14:57,199
i allowed me to work fast and i have to

460
00:14:57,199 --> 00:14:58,800
worry about compiling c over and over

461
00:14:58,800 --> 00:14:59,680
again

462
00:14:59,680 --> 00:15:01,440
and it had a really nice interface to

463
00:15:01,440 --> 00:15:02,880
kimu such as gdb

464
00:15:02,880 --> 00:15:05,279
and its monitor protocol so a really

465
00:15:05,279 --> 00:15:07,279
good thing to choose

466
00:15:07,279 --> 00:15:08,880
and the first thing i did was i wrote a

467
00:15:08,880 --> 00:15:11,040
peripheral for the boot uart

468
00:15:11,040 --> 00:15:13,760
it was really simple um on the right you

469
00:15:13,760 --> 00:15:15,519
see this peripheral definition

470
00:15:15,519 --> 00:15:17,199
there are two functions the read and

471
00:15:17,199 --> 00:15:18,880
write functions which are

472
00:15:18,880 --> 00:15:22,480
called if um kimu will access a memory

473
00:15:22,480 --> 00:15:24,720
address within the memory range that is

474
00:15:24,720 --> 00:15:27,120
defined on the left

475
00:15:27,120 --> 00:15:28,639
dead simple and we were able to liberate

476
00:15:28,639 --> 00:15:30,160
the initial boot messages to help us

477
00:15:30,160 --> 00:15:30,800
debug

478
00:15:30,800 --> 00:15:32,399
our peripheral definitions from that

479
00:15:32,399 --> 00:15:34,959
point forward

480
00:15:35,040 --> 00:15:37,120
and uh here's a initial video of

481
00:15:37,120 --> 00:15:38,240
actually

482
00:15:38,240 --> 00:15:42,000
it booting once we had done the uart

483
00:15:42,000 --> 00:15:44,320
so uh you'll notice in the bottom left

484
00:15:44,320 --> 00:15:46,079
there's some kind of debugging output

485
00:15:46,079 --> 00:15:47,519
showing us what's being done and you

486
00:15:47,519 --> 00:15:49,199
notice this is actually the uart coming

487
00:15:49,199 --> 00:15:50,000
out now but

488
00:15:50,000 --> 00:15:52,160
look how slow it is it's pretty much

489
00:15:52,160 --> 00:15:54,800
slower than the 56k modem at this point

490
00:15:54,800 --> 00:15:57,920
um which is okay it's a good first start

491
00:15:57,920 --> 00:15:58,800
but

492
00:15:58,800 --> 00:16:01,680
we definitely need to do better so

493
00:16:01,680 --> 00:16:02,800
that's why we started

494
00:16:02,800 --> 00:16:06,079
going even further and the first thing i

495
00:16:06,079 --> 00:16:08,000
did after seeing this was implementing

496
00:16:08,000 --> 00:16:10,160
snapshots uh which ended up being a

497
00:16:10,160 --> 00:16:11,680
piece of cake with avatar's

498
00:16:11,680 --> 00:16:13,920
frameworks because of have it allowed us

499
00:16:13,920 --> 00:16:15,600
to remotely control kimu

500
00:16:15,600 --> 00:16:16,880
we could just send the command to do a

501
00:16:16,880 --> 00:16:19,360
snapshot the only caveat is because we

502
00:16:19,360 --> 00:16:20,320
had python

503
00:16:20,320 --> 00:16:22,560
and c based peripherals we need to make

504
00:16:22,560 --> 00:16:24,560
sure we snapchatted both

505
00:16:24,560 --> 00:16:26,480
so we just pretty much the code you see

506
00:16:26,480 --> 00:16:28,000
here is exactly what we use

507
00:16:28,000 --> 00:16:29,920
to snapshot the python peripherals

508
00:16:29,920 --> 00:16:31,600
peripherals at the same time

509
00:16:31,600 --> 00:16:34,639
as the ones in kimu

510
00:16:34,639 --> 00:16:37,040
and taking a step back this is what we

511
00:16:37,040 --> 00:16:37,839
have so far

512
00:16:37,839 --> 00:16:40,560
the first incarnation of shannon ee we

513
00:16:40,560 --> 00:16:41,680
have avatar 2

514
00:16:41,680 --> 00:16:44,800
we have our uart uh peripheral we have

515
00:16:44,800 --> 00:16:45,600
the

516
00:16:45,600 --> 00:16:48,399
the file parser for the mode of images

517
00:16:48,399 --> 00:16:50,959
we've been using gdb hooks up until now

518
00:16:50,959 --> 00:16:53,040
and uh kimu is our target and everything

519
00:16:53,040 --> 00:16:55,519
is being done over ipc

520
00:16:55,519 --> 00:16:57,440
uh but this is where the problem is

521
00:16:57,440 --> 00:16:59,360
actually because this ipc

522
00:16:59,360 --> 00:17:01,759
is cross process and we're needing a lot

523
00:17:01,759 --> 00:17:03,120
of hooks and a lot of remote memory

524
00:17:03,120 --> 00:17:03,759
reads

525
00:17:03,759 --> 00:17:06,240
these become the primary bottleneck and

526
00:17:06,240 --> 00:17:07,359
we needed a way

527
00:17:07,359 --> 00:17:09,760
to actually solve this but i spent a

528
00:17:09,760 --> 00:17:11,599
whole lot more time hacking on this

529
00:17:11,599 --> 00:17:12,799
trying to figure out trying to improve

530
00:17:12,799 --> 00:17:14,720
the speed and i kind of hit a dead end i

531
00:17:14,720 --> 00:17:15,599
was like you know it

532
00:17:15,599 --> 00:17:17,119
something's wrong here maybe we need to

533
00:17:17,119 --> 00:17:19,280
take a different approach

534
00:17:19,280 --> 00:17:21,520
so uh this is when i brought on board

535
00:17:21,520 --> 00:17:22,319
marius

536
00:17:22,319 --> 00:17:24,400
who better who better to bring on than

537
00:17:24,400 --> 00:17:26,880
the lead developer of avatar 2.

538
00:17:26,880 --> 00:17:29,200
so uh with him and his knowledge he

539
00:17:29,200 --> 00:17:30,720
suggested we actually move

540
00:17:30,720 --> 00:17:32,000
to a different approach we actually

541
00:17:32,000 --> 00:17:34,880
instead of using kimu let's use panda

542
00:17:34,880 --> 00:17:37,200
so we ported the rest of what we had

543
00:17:37,200 --> 00:17:38,400
done to panda

544
00:17:38,400 --> 00:17:41,360
panda is just a fork of kimu from from

545
00:17:41,360 --> 00:17:42,799
2013 or so

546
00:17:42,799 --> 00:17:44,960
and what it offers in addition to kimu

547
00:17:44,960 --> 00:17:46,559
is a plug-in infrastructure

548
00:17:46,559 --> 00:17:48,720
callbacks during kim's runtime state and

549
00:17:48,720 --> 00:17:50,480
record and replay

550
00:17:50,480 --> 00:17:53,679
and it's already integrated in avatar to

551
00:17:53,679 --> 00:17:56,720
i guess framework so the main issue is

552
00:17:56,720 --> 00:17:58,000
it still has the performance

553
00:17:58,000 --> 00:17:59,440
issues that we're dealing with it's

554
00:17:59,440 --> 00:18:01,280
still a separate process

555
00:18:01,280 --> 00:18:04,240
but that's when we discovered pi panda

556
00:18:04,240 --> 00:18:06,160
it's a pretty much a library based

557
00:18:06,160 --> 00:18:06,720
import

558
00:18:06,720 --> 00:18:09,120
of kimu or a panda you can literally

559
00:18:09,120 --> 00:18:10,160
import panda

560
00:18:10,160 --> 00:18:12,559
and that means it's now a thread within

561
00:18:12,559 --> 00:18:13,600
your process

562
00:18:13,600 --> 00:18:16,320
so no more ipc you get a single python

563
00:18:16,320 --> 00:18:17,039
interpreter

564
00:18:17,039 --> 00:18:19,360
with ffi to pandas c functions so you

565
00:18:19,360 --> 00:18:22,240
can do extremely fast native hooks

566
00:18:22,240 --> 00:18:24,160
which allowed me to replace all the gdb

567
00:18:24,160 --> 00:18:25,840
hooks with panda hooks

568
00:18:25,840 --> 00:18:28,080
and we got a huge speed up doing this

569
00:18:28,080 --> 00:18:30,480
their ipc was pretty much just um

570
00:18:30,480 --> 00:18:33,600
a mutex waking up another threat now

571
00:18:33,600 --> 00:18:36,080
which is a big speed up and on the right

572
00:18:36,080 --> 00:18:37,679
you see our block diagram of how things

573
00:18:37,679 --> 00:18:38,480
have changed

574
00:18:38,480 --> 00:18:40,160
it's not all integrated together and we

575
00:18:40,160 --> 00:18:42,240
can get higher performance and we don't

576
00:18:42,240 --> 00:18:43,919
need multiple python interpreters on

577
00:18:43,919 --> 00:18:46,400
either end

578
00:18:46,480 --> 00:18:47,919
this is when we really started getting

579
00:18:47,919 --> 00:18:49,600
into the weeds of emily emulating

580
00:18:49,600 --> 00:18:50,559
peripherals

581
00:18:50,559 --> 00:18:52,640
and we hit this function called pal in

582
00:18:52,640 --> 00:18:54,880
it one it's a huge monolith that pretty

583
00:18:54,880 --> 00:18:56,640
much boots the modem

584
00:18:56,640 --> 00:18:58,400
once you've gotten past the boot loader

585
00:18:58,400 --> 00:18:59,840
you've gone into the main image

586
00:18:59,840 --> 00:19:01,440
you hit this function which brings up

587
00:19:01,440 --> 00:19:03,360
all the heap objects

588
00:19:03,360 --> 00:19:06,480
the non-volatile items the timers

589
00:19:06,480 --> 00:19:09,679
dsps and all the tasks

590
00:19:09,679 --> 00:19:12,160
so to kind of turn through this we

591
00:19:12,160 --> 00:19:14,240
iteratively emulated the peripherals

592
00:19:14,240 --> 00:19:15,919
we watch for crash strings or infinite

593
00:19:15,919 --> 00:19:17,760
loops we use memory mapped i o

594
00:19:17,760 --> 00:19:19,440
monitoring to see which peripherals need

595
00:19:19,440 --> 00:19:20,400
more modeling

596
00:19:20,400 --> 00:19:22,720
and it was really an iterative cycle we

597
00:19:22,720 --> 00:19:24,799
also used some kind of simple a cyclic

598
00:19:24,799 --> 00:19:26,000
bit pattern

599
00:19:26,000 --> 00:19:27,520
to like kind of fuzz our way through

600
00:19:27,520 --> 00:19:29,440
some peripherals that we

601
00:19:29,440 --> 00:19:32,240
that were able to get us past any checks

602
00:19:32,240 --> 00:19:33,440
and after doing all this we had

603
00:19:33,440 --> 00:19:35,280
partially emulated the power management

604
00:19:35,280 --> 00:19:36,080
ic

605
00:19:36,080 --> 00:19:38,559
the clock peripheral a very very small

606
00:19:38,559 --> 00:19:39,600
amount of the dsp

607
00:19:39,600 --> 00:19:40,960
not the actual just enough to the

608
00:19:40,960 --> 00:19:43,360
communication the soc

609
00:19:43,360 --> 00:19:46,160
driver uh the samsung ipc peripheral the

610
00:19:46,160 --> 00:19:48,240
slash certain memory the timer and the

611
00:19:48,240 --> 00:19:50,720
um the generic interrupt controller so

612
00:19:50,720 --> 00:19:52,000
we could boot and we could bring

613
00:19:52,000 --> 00:19:55,120
tasks up and we hit the banner we had

614
00:19:55,120 --> 00:19:57,280
seen this banner in the static analysis

615
00:19:57,280 --> 00:19:58,799
and we're like if we can get to this

616
00:19:58,799 --> 00:20:00,799
banner we'll be in really good shape

617
00:20:00,799 --> 00:20:03,039
and we reached it and this was about i

618
00:20:03,039 --> 00:20:04,480
think march

619
00:20:04,480 --> 00:20:07,679
so um it had been i brought marius on

620
00:20:07,679 --> 00:20:09,440
board in january and then in march so

621
00:20:09,440 --> 00:20:11,440
things really kicked off and we're

622
00:20:11,440 --> 00:20:13,919
really cooking with gas now

623
00:20:13,919 --> 00:20:16,640
so at this point we had started to get

624
00:20:16,640 --> 00:20:18,559
tasks running and we were like okay

625
00:20:18,559 --> 00:20:21,600
let's start doing fuzzing so we started

626
00:20:21,600 --> 00:20:24,480
the port triforce afl to our system

627
00:20:24,480 --> 00:20:27,280
triforce afl is a patch set on top of a

628
00:20:27,280 --> 00:20:28,159
fill

629
00:20:28,159 --> 00:20:30,480
it's originally developed in 2017 and

630
00:20:30,480 --> 00:20:31,840
what it does differently is it allows

631
00:20:31,840 --> 00:20:32,240
you

632
00:20:32,240 --> 00:20:34,960
to do system level fuzzing so shannon ee

633
00:20:34,960 --> 00:20:36,880
is a system level emulator

634
00:20:36,880 --> 00:20:39,919
meaning it has a software mmu and it

635
00:20:39,919 --> 00:20:42,240
invokes afl from within the guest via

636
00:20:42,240 --> 00:20:43,600
hyper calls

637
00:20:43,600 --> 00:20:45,679
and we combine this patch set with some

638
00:20:45,679 --> 00:20:47,360
afl plus plus editions

639
00:20:47,360 --> 00:20:49,360
because i have some really good patches

640
00:20:49,360 --> 00:20:50,880
which means we got better coverage

641
00:20:50,880 --> 00:20:51,520
collection

642
00:20:51,520 --> 00:20:54,320
and a persistent mode and this allowed

643
00:20:54,320 --> 00:20:55,360
us to do fuzzing

644
00:20:55,360 --> 00:20:57,919
within using something called the afl

645
00:20:57,919 --> 00:21:00,080
task

646
00:21:00,080 --> 00:21:02,559
so to get an afl task running in the

647
00:21:02,559 --> 00:21:03,360
baseband

648
00:21:03,360 --> 00:21:05,840
we used our mod kit we wrote a mod kit

649
00:21:05,840 --> 00:21:07,919
that allowed us to inject custom tasks

650
00:21:07,919 --> 00:21:10,159
into the emulated baseband uh playing

651
00:21:10,159 --> 00:21:12,960
very nice with all the apis that exist

652
00:21:12,960 --> 00:21:15,440
we use we were able to write these in c

653
00:21:15,440 --> 00:21:16,080
and

654
00:21:16,080 --> 00:21:18,240
we had dynamic symbol resolution for a

655
00:21:18,240 --> 00:21:19,280
nice c

656
00:21:19,280 --> 00:21:22,320
like ffi um this was done cross

657
00:21:22,320 --> 00:21:23,679
version as well so you wouldn't have to

658
00:21:23,679 --> 00:21:25,679
change our harness for different for

659
00:21:25,679 --> 00:21:28,400
let's say a 2017 firmware image to a

660
00:21:28,400 --> 00:21:30,960
2019 firmware image it would be seamless

661
00:21:30,960 --> 00:21:32,799
and the diagram below shows you kind of

662
00:21:32,799 --> 00:21:35,039
how the afl task is integrated

663
00:21:35,039 --> 00:21:37,679
it has a couple of steps it will set up

664
00:21:37,679 --> 00:21:38,640
the fuzz case

665
00:21:38,640 --> 00:21:42,000
test case it'll start the fork server

666
00:21:42,000 --> 00:21:44,640
it will receive data from afl it will

667
00:21:44,640 --> 00:21:46,480
start the work collecting coverage

668
00:21:46,480 --> 00:21:48,480
it will do the single fuzz test case and

669
00:21:48,480 --> 00:21:52,000
then it'll call done and repeat

670
00:21:52,400 --> 00:21:54,159
so now we actually needed to target

671
00:21:54,159 --> 00:21:55,840
tasks so

672
00:21:55,840 --> 00:21:58,720
we integrated afl within the rtos itself

673
00:21:58,720 --> 00:22:00,400
which means we could use the apis that

674
00:22:00,400 --> 00:22:03,840
the rtos tasks themselves already used

675
00:22:03,840 --> 00:22:05,520
and this was an important thing that we

676
00:22:05,520 --> 00:22:07,039
chose to do because it allowed us to

677
00:22:07,039 --> 00:22:08,640
avoid re-hosting

678
00:22:08,640 --> 00:22:11,360
i guess and carving out portions of the

679
00:22:11,360 --> 00:22:12,640
baseband to get

680
00:22:12,640 --> 00:22:14,559
our fuzz harness to work we could just

681
00:22:14,559 --> 00:22:16,080
play nice with the messaging

682
00:22:16,080 --> 00:22:18,000
and we reverse engineered the message

683
00:22:18,000 --> 00:22:20,080
and cues that were used to send

684
00:22:20,080 --> 00:22:22,559
data between tasks and we would just

685
00:22:22,559 --> 00:22:25,200
call send message to target a task

686
00:22:25,200 --> 00:22:26,880
on the right is the header of the queue

687
00:22:26,880 --> 00:22:28,480
items that would be sent

688
00:22:28,480 --> 00:22:31,679
very simple source destination cues

689
00:22:31,679 --> 00:22:35,039
a size and a message id

690
00:22:35,039 --> 00:22:38,000
so our as an example here is the gsm

691
00:22:38,000 --> 00:22:39,520
session management

692
00:22:39,520 --> 00:22:43,120
in the gprs fuzzing harness this is 2.5

693
00:22:43,120 --> 00:22:44,880
g slash 2g

694
00:22:44,880 --> 00:22:46,720
this is what the data connections under

695
00:22:46,720 --> 00:22:49,520
very early 2gs would use

696
00:22:49,520 --> 00:22:50,960
on the left is the queue item that's

697
00:22:50,960 --> 00:22:53,440
specific to the sm task

698
00:22:53,440 --> 00:22:56,240
and on the right is the setup function

699
00:22:56,240 --> 00:22:57,600
for the task

700
00:22:57,600 --> 00:22:59,280
this is important because we had to do

701
00:22:59,280 --> 00:23:02,320
an initial packet to send to the sm task

702
00:23:02,320 --> 00:23:03,919
which would initialize it to the point

703
00:23:03,919 --> 00:23:05,600
where it would then be ready to receive

704
00:23:05,600 --> 00:23:08,000
radio messages and it's important to

705
00:23:08,000 --> 00:23:09,280
note that our approach is skipping

706
00:23:09,280 --> 00:23:10,159
layers two

707
00:23:10,159 --> 00:23:11,919
and one it's jumping straight to layer

708
00:23:11,919 --> 00:23:13,600
three

709
00:23:13,600 --> 00:23:14,880
which saves us a lot of time with

710
00:23:14,880 --> 00:23:17,280
peripheral emulation

711
00:23:17,280 --> 00:23:20,080
here's actual fuzz single what it really

712
00:23:20,080 --> 00:23:21,120
does is

713
00:23:21,120 --> 00:23:23,120
very much the same it will allocate a

714
00:23:23,120 --> 00:23:24,559
message cue item

715
00:23:24,559 --> 00:23:27,280
uh it'll allocate a pdu it will get the

716
00:23:27,280 --> 00:23:29,120
work from afl

717
00:23:29,120 --> 00:23:30,960
it will copy it in set the size set the

718
00:23:30,960 --> 00:23:32,559
radio message id which will be reverse

719
00:23:32,559 --> 00:23:33,440
engineered

720
00:23:33,440 --> 00:23:34,960
start collecting coverage send the

721
00:23:34,960 --> 00:23:36,720
message and this is an important part it

722
00:23:36,720 --> 00:23:37,120
actually

723
00:23:37,120 --> 00:23:39,760
will send a message from task the afl

724
00:23:39,760 --> 00:23:40,400
task

725
00:23:40,400 --> 00:23:42,159
and then it will the rtos will

726
00:23:42,159 --> 00:23:44,400
reschedule directly towards a task

727
00:23:44,400 --> 00:23:46,000
and we did this by actually setting the

728
00:23:46,000 --> 00:23:47,600
priority of our afl task

729
00:23:47,600 --> 00:23:50,960
to the lowest possible and then

730
00:23:50,960 --> 00:23:52,159
finally once that message is in

731
00:23:52,159 --> 00:23:54,000
processing or any sub messages that

732
00:23:54,000 --> 00:23:54,640
return

733
00:23:54,640 --> 00:23:56,240
it will call done work and do it all

734
00:23:56,240 --> 00:23:58,320
over again

735
00:23:58,320 --> 00:24:01,360
so here's a video of it in action

736
00:24:01,360 --> 00:24:04,080
it's just as how you would normally use

737
00:24:04,080 --> 00:24:05,279
afl

738
00:24:05,279 --> 00:24:07,840
and you can call it directly on the

739
00:24:07,840 --> 00:24:08,559
shannon

740
00:24:08,559 --> 00:24:11,279
ee it will spin up the fork server from

741
00:24:11,279 --> 00:24:12,240
a snapshot

742
00:24:12,240 --> 00:24:13,360
so we don't have to wait for the whole

743
00:24:13,360 --> 00:24:15,200
thing to boot up we can snapchat right

744
00:24:15,200 --> 00:24:16,159
before

745
00:24:16,159 --> 00:24:18,559
the afl task is ready to run and the

746
00:24:18,559 --> 00:24:20,559
baseband is quiesce

747
00:24:20,559 --> 00:24:22,320
waiting for events it will lower the

748
00:24:22,320 --> 00:24:25,120
initial corpus start collecting coverage

749
00:24:25,120 --> 00:24:28,000
and boom it will start fuzzing and uh

750
00:24:28,000 --> 00:24:28,400
our

751
00:24:28,400 --> 00:24:29,840
exact speed's pretty high because we've

752
00:24:29,840 --> 00:24:32,159
set a pretty high um

753
00:24:32,159 --> 00:24:35,279
persistent mode number this does come at

754
00:24:35,279 --> 00:24:37,120
the expense of variable test cases so

755
00:24:37,120 --> 00:24:38,640
you don't have to use it but if you want

756
00:24:38,640 --> 00:24:40,400
to really turn through things fast

757
00:24:40,400 --> 00:24:43,360
you can go ahead and do that and now

758
00:24:43,360 --> 00:24:45,679
let's talk about the bugs we found

759
00:24:45,679 --> 00:24:48,000
so before we jumped straight into oday

760
00:24:48,000 --> 00:24:50,000
stuff we wanted to make sure that we

761
00:24:50,000 --> 00:24:51,760
had built a tool that actually worked on

762
00:24:51,760 --> 00:24:54,640
real uh to find real bugs not just kind

763
00:24:54,640 --> 00:24:56,400
of fake false positive bugs

764
00:24:56,400 --> 00:24:59,120
so we decided to rediscover an end day

765
00:24:59,120 --> 00:25:01,200
and we actually went off of ahmad's talk

766
00:25:01,200 --> 00:25:03,039
which was targeting a galaxy i believe

767
00:25:03,039 --> 00:25:03,840
s10

768
00:25:03,840 --> 00:25:07,200
or sorry s7 and we were then

769
00:25:07,200 --> 00:25:10,000
able to build a harness for the same

770
00:25:10,000 --> 00:25:11,919
subsystems he fuzzed

771
00:25:11,919 --> 00:25:14,000
so the gsm and gprs radio packet

772
00:25:14,000 --> 00:25:15,919
handlers

773
00:25:15,919 --> 00:25:17,600
and more specifically we built harnesses

774
00:25:17,600 --> 00:25:18,960
for call control

775
00:25:18,960 --> 00:25:21,440
cc mobility management and session

776
00:25:21,440 --> 00:25:22,159
management

777
00:25:22,159 --> 00:25:23,679
these are all something you could read

778
00:25:23,679 --> 00:25:26,320
the standards of gsm

779
00:25:26,320 --> 00:25:28,960
we set afl to the task set up the fuzzer

780
00:25:28,960 --> 00:25:29,360
and

781
00:25:29,360 --> 00:25:31,679
boom we were able to actually rediscover

782
00:25:31,679 --> 00:25:33,760
the pdp network accept crash

783
00:25:33,760 --> 00:25:36,080
from a walk with shannon talk so this

784
00:25:36,080 --> 00:25:37,679
gave us a lot of motivation

785
00:25:37,679 --> 00:25:39,520
and we had pretty much done some ground

786
00:25:39,520 --> 00:25:42,640
truth testing on our emulator

787
00:25:42,640 --> 00:25:45,120
now defined new things once again our

788
00:25:45,120 --> 00:25:47,520
target was gsm and gprs because hey you

789
00:25:47,520 --> 00:25:48,080
know

790
00:25:48,080 --> 00:25:49,840
if we find something here this is the

791
00:25:49,840 --> 00:25:51,919
lowest hanging fruit

792
00:25:51,919 --> 00:25:55,200
why not look at lte or 3g or even 5g

793
00:25:55,200 --> 00:25:56,720
i mean at the end of the day if you're

794
00:25:56,720 --> 00:25:58,240
trying to compromise a baseband

795
00:25:58,240 --> 00:25:59,760
you're going to go for the easiest

796
00:25:59,760 --> 00:26:02,159
target 2g is at target and it is still

797
00:26:02,159 --> 00:26:04,159
implemented in pretty much every base

798
00:26:04,159 --> 00:26:07,120
baseband today you can do a fake base

799
00:26:07,120 --> 00:26:08,880
station attack trivially

800
00:26:08,880 --> 00:26:11,039
there's no mutual authentication so it's

801
00:26:11,039 --> 00:26:13,840
easy to craft any message you like

802
00:26:13,840 --> 00:26:16,559
um our coverage guiding fuzzing we had

803
00:26:16,559 --> 00:26:16,880
some

804
00:26:16,880 --> 00:26:19,039
blank initial seeds and we were able to

805
00:26:19,039 --> 00:26:20,640
debug coverage using panda

806
00:26:20,640 --> 00:26:23,200
exporting coverage and giger's dragon

807
00:26:23,200 --> 00:26:24,559
dance

808
00:26:24,559 --> 00:26:27,039
um we didn't run even for that long 30

809
00:26:27,039 --> 00:26:28,080
cp

810
00:26:28,080 --> 00:26:31,520
30 cpu cores across uh five days

811
00:26:31,520 --> 00:26:33,200
uh which further demonstrates the

812
00:26:33,200 --> 00:26:35,360
scalability and we've discovered two end

813
00:26:35,360 --> 00:26:35,760
days

814
00:26:35,760 --> 00:26:37,360
the one from before and the one i'll

815
00:26:37,360 --> 00:26:39,520
talk about next and one zero day

816
00:26:39,520 --> 00:26:41,279
which we're in disclosure with samsung

817
00:26:41,279 --> 00:26:42,880
about right now

818
00:26:42,880 --> 00:26:45,039
and given the success of gsm the fact

819
00:26:45,039 --> 00:26:46,960
that this is 30 years old at this point

820
00:26:46,960 --> 00:26:48,640
we're still finding things i'd say

821
00:26:48,640 --> 00:26:50,840
lte and above is definitely next on our

822
00:26:50,840 --> 00:26:52,799
list

823
00:26:52,799 --> 00:26:54,320
so let's talk about the other end day we

824
00:26:54,320 --> 00:26:56,000
found which were which were coining the

825
00:26:56,000 --> 00:26:57,440
call of death

826
00:26:57,440 --> 00:26:59,760
it's uh pretty much an i believe a

827
00:26:59,760 --> 00:27:01,679
previously unknown overflow at least

828
00:27:01,679 --> 00:27:02,559
publicly

829
00:27:02,559 --> 00:27:05,520
in the call setup packet using targeting

830
00:27:05,520 --> 00:27:06,080
this field

831
00:27:06,080 --> 00:27:08,880
called the bearer capability this is

832
00:27:08,880 --> 00:27:09,760
something you can look up in the

833
00:27:09,760 --> 00:27:10,640
standards

834
00:27:10,640 --> 00:27:12,080
but effectively it comes in when you're

835
00:27:12,080 --> 00:27:13,760
receiving a call

836
00:27:13,760 --> 00:27:15,279
this packet was incorrectly parsed by

837
00:27:15,279 --> 00:27:17,039
the baseband when the call is incoming

838
00:27:17,039 --> 00:27:19,840
and it's a heap based buffer overflow

839
00:27:19,840 --> 00:27:21,600
which we seem to have a fair amount of

840
00:27:21,600 --> 00:27:24,240
control over and we did confirm that

841
00:27:24,240 --> 00:27:26,240
this vulnerability is no longer on newer

842
00:27:26,240 --> 00:27:27,520
firmwares

843
00:27:27,520 --> 00:27:29,360
balance checking has been added and it's

844
00:27:29,360 --> 00:27:30,960
pretty explicit that they were fixing

845
00:27:30,960 --> 00:27:32,640
this whether it was from a report or an

846
00:27:32,640 --> 00:27:34,720
internal audit we don't know

847
00:27:34,720 --> 00:27:36,960
but the fact is we found it and we were

848
00:27:36,960 --> 00:27:39,760
able to use shannon to triage it

849
00:27:39,760 --> 00:27:42,000
as you can see at the top here our afl

850
00:27:42,000 --> 00:27:44,000
task sent the message to the target task

851
00:27:44,000 --> 00:27:45,600
which is the cc task

852
00:27:45,600 --> 00:27:47,919
the cc task was scheduled in it then

853
00:27:47,919 --> 00:27:49,679
received the setup message

854
00:27:49,679 --> 00:27:51,840
which is noted as a radio message it

855
00:27:51,840 --> 00:27:52,960
entered the decode

856
00:27:52,960 --> 00:27:55,360
function and finally later on after some

857
00:27:55,360 --> 00:27:56,480
snips

858
00:27:56,480 --> 00:27:58,080
it you can see the length which is

859
00:27:58,080 --> 00:27:59,440
pretty large for the bear should be

860
00:27:59,440 --> 00:28:01,039
maybe only a couple bytes

861
00:28:01,039 --> 00:28:02,880
and then it crashes with the palm guard

862
00:28:02,880 --> 00:28:05,039
corruption if you remember we had seen

863
00:28:05,039 --> 00:28:06,640
on in the very beginning we'd seen the

864
00:28:06,640 --> 00:28:08,080
palum guard corruption

865
00:28:08,080 --> 00:28:10,000
in the phone screen but now we can

866
00:28:10,000 --> 00:28:11,679
actually see why this is happening

867
00:28:11,679 --> 00:28:14,159
and the back trace to do it but logs

868
00:28:14,159 --> 00:28:15,200
aren't always enough

869
00:28:15,200 --> 00:28:16,559
so that's why we actually have the

870
00:28:16,559 --> 00:28:18,720
ability to use gdb

871
00:28:18,720 --> 00:28:21,279
so we have the register r2 which is set

872
00:28:21,279 --> 00:28:22,960
to 30 30 30 30

873
00:28:22,960 --> 00:28:24,399
and we have this comparison which is

874
00:28:24,399 --> 00:28:26,000
comparing r2 against

875
00:28:26,000 --> 00:28:29,200
all a's this is actually the static heap

876
00:28:29,200 --> 00:28:30,000
cookie

877
00:28:30,000 --> 00:28:32,640
and this check is going to fail and you

878
00:28:32,640 --> 00:28:34,080
can see the payload here

879
00:28:34,080 --> 00:28:35,279
and the reason it's going to fail is

880
00:28:35,279 --> 00:28:36,720
because this is our payload afl

881
00:28:36,720 --> 00:28:38,080
generated

882
00:28:38,080 --> 00:28:41,360
everything that's not ascii 0 is the

883
00:28:41,360 --> 00:28:43,120
message header enough to reach the

884
00:28:43,120 --> 00:28:44,559
bearer and the rest is

885
00:28:44,559 --> 00:28:46,480
the bearer so that's pretty much being

886
00:28:46,480 --> 00:28:47,600
copied straight into

887
00:28:47,600 --> 00:28:52,000
a heap buffer that is clearly too small

888
00:28:52,080 --> 00:28:54,080
so to even further have confidence that

889
00:28:54,080 --> 00:28:55,120
what we built is

890
00:28:55,120 --> 00:28:56,640
going to work in the real world we

891
00:28:56,640 --> 00:28:59,440
replicated what we found over the air

892
00:28:59,440 --> 00:29:01,279
our experimental setup included a blade

893
00:29:01,279 --> 00:29:02,480
rf which is

894
00:29:02,480 --> 00:29:05,760
about 420 a base station yate bts which

895
00:29:05,760 --> 00:29:07,919
we modified for the exploit payload

896
00:29:07,919 --> 00:29:11,039
we literally just copied it in verbatim

897
00:29:11,039 --> 00:29:13,200
maybe cut off the the header the very

898
00:29:13,200 --> 00:29:14,080
initial header

899
00:29:14,080 --> 00:29:16,480
and that was it we targeted the s10 and

900
00:29:16,480 --> 00:29:18,000
s7 in our testing

901
00:29:18,000 --> 00:29:20,000
and we used sim cards from osmocom to

902
00:29:20,000 --> 00:29:22,000
help the phone get an easy connection

903
00:29:22,000 --> 00:29:23,760
and shout out to tyler tucker who is an

904
00:29:23,760 --> 00:29:25,440
author on this paper

905
00:29:25,440 --> 00:29:27,520
on this work who uh pretty much

906
00:29:27,520 --> 00:29:29,520
spearheaded this and made sure that

907
00:29:29,520 --> 00:29:30,559
you know i didn't have to go through the

908
00:29:30,559 --> 00:29:32,480
hell of getting this set up again so he

909
00:29:32,480 --> 00:29:35,760
suffered for what you're about to see

910
00:29:35,840 --> 00:29:39,120
and here's the demo so the call uh the

911
00:29:39,120 --> 00:29:40,159
phone on the left and the phone the

912
00:29:40,159 --> 00:29:41,360
right are both connected

913
00:29:41,360 --> 00:29:44,640
to the uh fake base station calling the

914
00:29:44,640 --> 00:29:46,320
left is calling the phone on the right

915
00:29:46,320 --> 00:29:49,440
uh you can pick it up and um it will go

916
00:29:49,440 --> 00:29:50,960
through but the phone on the right won't

917
00:29:50,960 --> 00:29:52,640
have the call working

918
00:29:52,640 --> 00:29:53,840
for some reason you get another call

919
00:29:53,840 --> 00:29:55,679
whether you decline or answer

920
00:29:55,679 --> 00:29:57,520
at this point it's too late uh the

921
00:29:57,520 --> 00:29:59,679
signal bars disappear and that little

922
00:29:59,679 --> 00:30:01,200
x comes in which means the base band is

923
00:30:01,200 --> 00:30:03,760
crashed um at this point

924
00:30:03,760 --> 00:30:06,000
it's a pretty cool thing we could do and

925
00:30:06,000 --> 00:30:08,159
uh to even further confirm

926
00:30:08,159 --> 00:30:11,919
we uh use logcat to get the logs

927
00:30:11,919 --> 00:30:13,600
but as you can see this is all you can

928
00:30:13,600 --> 00:30:15,120
see in the logs you actually can't see

929
00:30:15,120 --> 00:30:16,159
anything else so

930
00:30:16,159 --> 00:30:18,000
uh without shannon e it'd be really

931
00:30:18,000 --> 00:30:20,720
tough to debug why this happened

932
00:30:20,720 --> 00:30:23,440
so let's wrap things up um there are a

933
00:30:23,440 --> 00:30:24,799
lot of remaining challenges and i think

934
00:30:24,799 --> 00:30:26,080
future work for this

935
00:30:26,080 --> 00:30:28,559
like for instance doing fuzzing for

936
00:30:28,559 --> 00:30:29,840
cellular tailored fuzzing would be

937
00:30:29,840 --> 00:30:30,559
really cool

938
00:30:30,559 --> 00:30:32,640
to get better code coverage we ignore

939
00:30:32,640 --> 00:30:33,840
the physical layer so

940
00:30:33,840 --> 00:30:35,760
what aren't we missing by supporting it

941
00:30:35,760 --> 00:30:38,240
i mean dsps are attack surface too

942
00:30:38,240 --> 00:30:39,919
and honestly i think i would love to see

943
00:30:39,919 --> 00:30:41,840
this a holistic analysis of baseband

944
00:30:41,840 --> 00:30:43,200
attack surface

945
00:30:43,200 --> 00:30:44,799
what has been covered and what still

946
00:30:44,799 --> 00:30:46,960
remains

947
00:30:46,960 --> 00:30:48,799
some key takeaways we really need

948
00:30:48,799 --> 00:30:50,480
scalable tools to keep up with all the

949
00:30:50,480 --> 00:30:52,399
seller protocols especially 5g

950
00:30:52,399 --> 00:30:54,720
which is on the ryzen if we can barely

951
00:30:54,720 --> 00:30:55,440
do 2g

952
00:30:55,440 --> 00:30:56,640
how on earth are we going to keep up

953
00:30:56,640 --> 00:30:58,480
with the rest of the 5 and

954
00:30:58,480 --> 00:31:01,760
beyond g's building an emulator

955
00:31:01,760 --> 00:31:03,440
even with undocumented hardware can be

956
00:31:03,440 --> 00:31:05,760
done we can bring this methodology to

957
00:31:05,760 --> 00:31:08,320
other base fans and i think we should

958
00:31:08,320 --> 00:31:10,320
um and honestly we have to emulate

959
00:31:10,320 --> 00:31:11,760
basebands we need the right

960
00:31:11,760 --> 00:31:13,440
introspection level especially to do

961
00:31:13,440 --> 00:31:14,880
memory corruption debugging

962
00:31:14,880 --> 00:31:16,480
and over there testing i think we've

963
00:31:16,480 --> 00:31:19,519
shown is just not going to do it

964
00:31:19,519 --> 00:31:21,519
with that we have some releases we'll be

965
00:31:21,519 --> 00:31:24,320
releasing um the top link has all of our

966
00:31:24,320 --> 00:31:26,640
reverse engineering tools and code uh

967
00:31:26,640 --> 00:31:27,760
giga loaders and

968
00:31:27,760 --> 00:31:30,159
and so forth some firmware samples an

969
00:31:30,159 --> 00:31:31,600
on-device log parser

970
00:31:31,600 --> 00:31:34,080
for the btl format and shannon ee will

971
00:31:34,080 --> 00:31:35,519
be released at a later date

972
00:31:35,519 --> 00:31:37,600
after disclosures in some further qa but

973
00:31:37,600 --> 00:31:39,039
you can watch that repository and you

974
00:31:39,039 --> 00:31:40,159
should be able to get an email when we

975
00:31:40,159 --> 00:31:42,480
do our first push

976
00:31:42,480 --> 00:31:44,480
um with that i have to thank all the

977
00:31:44,480 --> 00:31:45,600
sponsors and

978
00:31:45,600 --> 00:31:48,720
people who funded this work nsf src

979
00:31:48,720 --> 00:31:52,000
nwo and the air force and navy

980
00:31:52,000 --> 00:31:54,320
without their contribution and support

981
00:31:54,320 --> 00:31:56,880
this work wouldn't have happened

982
00:31:56,880 --> 00:31:59,279
with that um i hope you enjoyed the talk

983
00:31:59,279 --> 00:32:00,880
and i would be happy to take any of your

984
00:32:00,880 --> 00:32:03,279
questions

985
00:32:08,000 --> 00:32:11,679
okay well um thanks everybody for

986
00:32:11,679 --> 00:32:12,640
attending this talk

987
00:32:12,640 --> 00:32:16,159
i i'm sorry for the buffering issues

988
00:32:16,159 --> 00:32:18,720
um but if you manage to catch some parts

989
00:32:18,720 --> 00:32:19,440
of the talk

990
00:32:19,440 --> 00:32:20,880
we are here to answer any of your

991
00:32:20,880 --> 00:32:22,880
questions

992
00:32:22,880 --> 00:32:26,000
and yeah here's here's marius so yeah

993
00:32:26,000 --> 00:32:28,960
hi yeah and unfortunately the logistics

994
00:32:28,960 --> 00:32:29,200
of

995
00:32:29,200 --> 00:32:31,679
the talk didn't let us kind of get

996
00:32:31,679 --> 00:32:32,240
together

997
00:32:32,240 --> 00:32:34,159
due to you know there being an ocean

998
00:32:34,159 --> 00:32:35,519
between us so

999
00:32:35,519 --> 00:32:38,960
but yeah but at least i'm now also here

1000
00:32:38,960 --> 00:32:41,760
to to answer question of yours and

1001
00:32:41,760 --> 00:32:43,760
to the technical problems the video on

1002
00:32:43,760 --> 00:32:45,440
demand for this talk will be available

1003
00:32:45,440 --> 00:32:47,120
at a later point in time so you can

1004
00:32:47,120 --> 00:32:48,000
re-watch

1005
00:32:48,000 --> 00:32:51,200
this yeah just the parts you missed and

1006
00:32:51,200 --> 00:32:52,960
of course you can also reach out to us

1007
00:32:52,960 --> 00:32:55,120
later on the

1008
00:32:55,120 --> 00:32:56,880
swap card platform and ask questions in

1009
00:32:56,880 --> 00:32:58,799
private later on but we will also

1010
00:32:58,799 --> 00:33:01,039
answer a question right here um we have

1011
00:33:01,039 --> 00:33:02,640
one already coming in which

1012
00:33:02,640 --> 00:33:04,720
uh we inlined already in the chat but

1013
00:33:04,720 --> 00:33:06,640
still let's repeat it already

1014
00:33:06,640 --> 00:33:08,880
um did we have access to the source when

1015
00:33:08,880 --> 00:33:10,720
we started the project

1016
00:33:10,720 --> 00:33:13,840
uh grant no we did not um

1017
00:33:13,840 --> 00:33:15,600
i know there had been a leaked source

1018
00:33:15,600 --> 00:33:17,200
for i think mediatek

1019
00:33:17,200 --> 00:33:20,159
i believe um but we did not have that in

1020
00:33:20,159 --> 00:33:21,440
this case so we had to

1021
00:33:21,440 --> 00:33:23,200
really just start reverse engineering

1022
00:33:23,200 --> 00:33:24,720
from the very beginning

1023
00:33:24,720 --> 00:33:27,679
um so if that definitely complicated

1024
00:33:27,679 --> 00:33:28,880
matters but also

1025
00:33:28,880 --> 00:33:31,120
it's more realistic in terms of well i

1026
00:33:31,120 --> 00:33:32,559
guess if you're an actual kind of

1027
00:33:32,559 --> 00:33:34,320
vulnerability researcher

1028
00:33:34,320 --> 00:33:35,600
source is kind of a luxury you don't

1029
00:33:35,600 --> 00:33:39,200
normally have so

1030
00:33:39,200 --> 00:33:41,760
uh there's another question coming in um

1031
00:33:41,760 --> 00:33:43,279
roughly how long until shannon e's

1032
00:33:43,279 --> 00:33:44,559
release date

1033
00:33:44,559 --> 00:33:46,559
um so right now we're in disclosure with

1034
00:33:46,559 --> 00:33:47,919
samsung um

1035
00:33:47,919 --> 00:33:49,919
we still need a qa of the code i don't

1036
00:33:49,919 --> 00:33:51,440
really have an estimate because

1037
00:33:51,440 --> 00:33:53,120
the disclosure process could take longer

1038
00:33:53,120 --> 00:33:54,960
than it usually takes longer than you

1039
00:33:54,960 --> 00:33:56,000
think

1040
00:33:56,000 --> 00:33:58,559
um that's all i can really say and yeah

1041
00:33:58,559 --> 00:34:00,159
but we are eager to release

1042
00:34:00,159 --> 00:34:04,399
so uh we want yeah as soon as possible

1043
00:34:04,399 --> 00:34:06,399
right the sources will be in your hands

1044
00:34:06,399 --> 00:34:07,679
at some point um

1045
00:34:07,679 --> 00:34:09,040
we're not intending to keep for

1046
00:34:09,040 --> 00:34:11,520
ourselves and um

1047
00:34:11,520 --> 00:34:13,918
yeah i i i didn't really catch this in

1048
00:34:13,918 --> 00:34:14,639
the very beginning

1049
00:34:14,639 --> 00:34:17,679
i didn't say enough but i mean me marius

1050
00:34:17,679 --> 00:34:18,960
and all the other people on the first

1051
00:34:18,960 --> 00:34:20,480
slide were very important towards this

1052
00:34:20,480 --> 00:34:21,520
work

1053
00:34:21,520 --> 00:34:25,040
um so although marius wasn't presenting

1054
00:34:25,040 --> 00:34:25,918
i mean

1055
00:34:25,918 --> 00:34:28,239
make sure everyone understands that this

1056
00:34:28,239 --> 00:34:29,280
work wouldn't have happened without

1057
00:34:29,280 --> 00:34:29,760
everyone

1058
00:34:29,760 --> 00:34:33,280
working behind us so yeah it was a team

1059
00:34:33,280 --> 00:34:34,079
effort

1060
00:34:34,079 --> 00:34:36,639
for sure definitely another question

1061
00:34:36,639 --> 00:34:38,239
came in do the bucks tend to group

1062
00:34:38,239 --> 00:34:39,199
toward crash

1063
00:34:39,199 --> 00:34:42,719
fail or remote access

1064
00:34:46,719 --> 00:34:49,839
well i guess i guess it depends i mean

1065
00:34:49,839 --> 00:34:51,520
that's kind of like a question of

1066
00:34:51,520 --> 00:34:54,719
how of like what your threat model is

1067
00:34:54,719 --> 00:34:56,560
because in our case we assume you have a

1068
00:34:56,560 --> 00:34:58,160
fake base station you can get a phone to

1069
00:34:58,160 --> 00:34:59,119
connect to the

1070
00:34:59,119 --> 00:35:01,359
fake base station at that point you can

1071
00:35:01,359 --> 00:35:04,160
send arbitrary messages at least via 2g

1072
00:35:04,160 --> 00:35:06,640
um so it's hard to say where the bugs

1073
00:35:06,640 --> 00:35:07,200
are if

1074
00:35:07,200 --> 00:35:08,720
if you happen you know if we knew where

1075
00:35:08,720 --> 00:35:10,240
the bugs were i think we would have had

1076
00:35:10,240 --> 00:35:11,599
a lot more to talk about but

1077
00:35:11,599 --> 00:35:13,440
um that's what this tool allows you to

1078
00:35:13,440 --> 00:35:15,040
do is define box

1079
00:35:15,040 --> 00:35:17,440
yeah and for instance the end day we

1080
00:35:17,440 --> 00:35:19,040
showcased was in

1081
00:35:19,040 --> 00:35:21,119
that scenario uh heap-based buffer

1082
00:35:21,119 --> 00:35:22,720
workflow which is potentially

1083
00:35:22,720 --> 00:35:24,560
leverageable to uh

1084
00:35:24,560 --> 00:35:26,560
full chain remote code execution exploit

1085
00:35:26,560 --> 00:35:28,400
we did not do this we did not attempt it

1086
00:35:28,400 --> 00:35:31,359
for us it was uh yeah far enough to get

1087
00:35:31,359 --> 00:35:32,640
to the crash

1088
00:35:32,640 --> 00:35:35,200
yeah and there are no heap like the heat

1089
00:35:35,200 --> 00:35:36,800
metadata is fairly straightforward and

1090
00:35:36,800 --> 00:35:38,320
there's no there's like a static heap

1091
00:35:38,320 --> 00:35:39,359
cookie so there aren't really a whole

1092
00:35:39,359 --> 00:35:41,440
lot of mitigations there

1093
00:35:41,440 --> 00:35:43,280
um one other question so i use the

1094
00:35:43,280 --> 00:35:44,960
bladeruff x40

1095
00:35:44,960 --> 00:35:48,320
um yeah there is a very good reason why

1096
00:35:48,320 --> 00:35:50,160
um there's a blog post i just posted on

1097
00:35:50,160 --> 00:35:51,599
my twitter about how to set up a

1098
00:35:51,599 --> 00:35:52,880
cellular test bed

1099
00:35:52,880 --> 00:35:56,000
and i explained why we used the x40 um

1100
00:35:56,000 --> 00:35:58,240
we couldn't get the xa4 to work on yate

1101
00:35:58,240 --> 00:35:58,880
bts

1102
00:35:58,880 --> 00:36:01,200
so yeah we would have liked to use it

1103
00:36:01,200 --> 00:36:03,200
and we we did try and it just didn't

1104
00:36:03,200 --> 00:36:04,400
work so

1105
00:36:04,400 --> 00:36:05,760
check out the blog post on my twitter

1106
00:36:05,760 --> 00:36:07,680
that will let you get set up with the

1107
00:36:07,680 --> 00:36:08,960
testbed yourself and you'll see kind of

1108
00:36:08,960 --> 00:36:13,839
the pain we had to go through to do that

1109
00:36:14,720 --> 00:36:17,760
okay another question which came in

1110
00:36:17,760 --> 00:36:19,359
is the moon processor equipped with

1111
00:36:19,359 --> 00:36:21,599
custom peripherals or standard arm

1112
00:36:21,599 --> 00:36:25,040
so that's the answer so we spent a lot

1113
00:36:25,040 --> 00:36:26,800
of time reverse engineering custom

1114
00:36:26,800 --> 00:36:28,480
peripherals and trying to figure out

1115
00:36:28,480 --> 00:36:30,560
what they do because uh sometimes even

1116
00:36:30,560 --> 00:36:32,480
standard peripherals as timers which you

1117
00:36:32,480 --> 00:36:34,400
would expect following the

1118
00:36:34,400 --> 00:36:36,880
standard uh arm definition of time as

1119
00:36:36,880 --> 00:36:37,440
well

1120
00:36:37,440 --> 00:36:39,839
a little bit different and hence needed

1121
00:36:39,839 --> 00:36:41,359
a lot of additional reverse engineering

1122
00:36:41,359 --> 00:36:42,400
kept us busy for

1123
00:36:42,400 --> 00:36:45,200
quite a while plus uh so these are just

1124
00:36:45,200 --> 00:36:46,320
the standard peripherals

1125
00:36:46,320 --> 00:36:48,560
but then there are also those crazy

1126
00:36:48,560 --> 00:36:50,079
baseband specific peripherals for

1127
00:36:50,079 --> 00:36:52,560
instance the digital signal processor is

1128
00:36:52,560 --> 00:36:55,599
a full peripheral on its own um

1129
00:36:55,599 --> 00:36:58,400
with its own culture with its own code

1130
00:36:58,400 --> 00:36:59,359
but also

1131
00:36:59,359 --> 00:37:01,599
with its own interfaces mapped in the

1132
00:37:01,599 --> 00:37:02,640
basements processor

1133
00:37:02,640 --> 00:37:05,920
and reptile ranges yeah so we didn't

1134
00:37:05,920 --> 00:37:07,440
really touch that too much because we

1135
00:37:07,440 --> 00:37:08,800
tried to avoid layer one as much as

1136
00:37:08,800 --> 00:37:10,160
possible

1137
00:37:10,160 --> 00:37:12,079
because that has its own can of worms we

1138
00:37:12,079 --> 00:37:13,359
didn't we didn't want to go there but

1139
00:37:13,359 --> 00:37:18,160
it could be something we look into later

1140
00:37:19,119 --> 00:37:22,240
um you want to take the next one

1141
00:37:22,240 --> 00:37:23,760
uh yeah so how extensible is the

1142
00:37:23,760 --> 00:37:25,359
emulator to the base band of the

1143
00:37:25,359 --> 00:37:26,800
qualcomm for example

1144
00:37:26,800 --> 00:37:30,000
so basically um the qualcomm baseband

1145
00:37:30,000 --> 00:37:31,760
uses a completely different instruction

1146
00:37:31,760 --> 00:37:33,040
set architecture

1147
00:37:33,040 --> 00:37:36,079
hexagon and we focus our full

1148
00:37:36,079 --> 00:37:39,280
our or our full efforts on well an

1149
00:37:39,280 --> 00:37:40,800
arm-based course so

1150
00:37:40,800 --> 00:37:43,040
and then the tooling we use like panda

1151
00:37:43,040 --> 00:37:44,480
chemo avatar and so on

1152
00:37:44,480 --> 00:37:47,040
do not foresee really uh support for

1153
00:37:47,040 --> 00:37:47,680
hexagon

1154
00:37:47,680 --> 00:37:49,200
yet it may change in the future who

1155
00:37:49,200 --> 00:37:51,119
knows but at the moment

1156
00:37:51,119 --> 00:37:53,520
um extensibility to qualcomm-based

1157
00:37:53,520 --> 00:37:55,119
basebands is

1158
00:37:55,119 --> 00:37:57,280
out of scope let's say when it comes to

1159
00:37:57,280 --> 00:37:58,400
other arm-based

1160
00:37:58,400 --> 00:38:02,079
um basebands

1161
00:38:02,079 --> 00:38:04,240
what sorry or maps based yeah i think

1162
00:38:04,240 --> 00:38:06,880
yeah yeah um or miss based um

1163
00:38:06,880 --> 00:38:10,880
i mean general the the way how we

1164
00:38:10,880 --> 00:38:12,400
started this project and how reverse

1165
00:38:12,400 --> 00:38:15,040
engineering and and basically focus on

1166
00:38:15,040 --> 00:38:16,800
airtrust primitives and airtel's tasks i

1167
00:38:16,800 --> 00:38:19,200
think this should be transferable to

1168
00:38:19,200 --> 00:38:22,560
other baseband processors as well but

1169
00:38:22,560 --> 00:38:24,960
the tool itself shannon e is definitely

1170
00:38:24,960 --> 00:38:28,960
focused on shannon-based basebands

1171
00:38:31,200 --> 00:38:32,480
yeah so there's a question here about

1172
00:38:32,480 --> 00:38:34,240
the if there's a white paper available

1173
00:38:34,240 --> 00:38:36,000
um the time constraints of getting the

1174
00:38:36,000 --> 00:38:37,599
talk prepared didn't really let us

1175
00:38:37,599 --> 00:38:39,599
give you a good white paper but we are

1176
00:38:39,599 --> 00:38:41,280
releasing the tools we used to do

1177
00:38:41,280 --> 00:38:42,560
reverse engineering and some of the kind

1178
00:38:42,560 --> 00:38:44,079
of the knowledge there

1179
00:38:44,079 --> 00:38:45,760
we hope to add more in the future like

1180
00:38:45,760 --> 00:38:47,680
going forward so check out the link i

1181
00:38:47,680 --> 00:38:48,720
just posted in chat

1182
00:38:48,720 --> 00:38:52,959
um that's what we have for now

1183
00:38:58,320 --> 00:39:00,720
um well if there aren't any more

1184
00:39:00,720 --> 00:39:01,520
questions

1185
00:39:01,520 --> 00:39:04,160
um feel free to reach us reach out to us

1186
00:39:04,160 --> 00:39:04,880
on twitter

1187
00:39:04,880 --> 00:39:06,960
um email or however you'd like to reach

1188
00:39:06,960 --> 00:39:07,920
out out to us

1189
00:39:07,920 --> 00:39:09,119
and we'll be happy to answer more

1190
00:39:09,119 --> 00:39:11,520
questions um offline but um we're about

1191
00:39:11,520 --> 00:39:12,720
out of time so we'll

1192
00:39:12,720 --> 00:39:14,640
we'll sign off thanks again for

1193
00:39:14,640 --> 00:39:16,240
attending and

1194
00:39:16,240 --> 00:39:18,640
yeah see you around yep thank you so

1195
00:39:18,640 --> 00:39:19,280
much

1196
00:39:19,280 --> 00:39:24,240
bye see ya

