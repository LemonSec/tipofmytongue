1
00:00:02,850 --> 00:00:13,310
[Music]

2
00:00:13,519 --> 00:00:14,639
all right welcome everyone

3
00:00:14,639 --> 00:00:16,480
this is detecting exploits with novel

4
00:00:16,480 --> 00:00:18,240
hardware performance counters and ml

5
00:00:18,240 --> 00:00:18,960
magic

6
00:00:18,960 --> 00:00:21,039
uh before we begin a brief introduction

7
00:00:21,039 --> 00:00:22,000
to who we are

8
00:00:22,000 --> 00:00:23,760
so i'm nick gregory i'm a research

9
00:00:23,760 --> 00:00:25,519
scientist at capsule 8.

10
00:00:25,519 --> 00:00:28,320
um have a background in low-level

11
00:00:28,320 --> 00:00:30,960
systems and binary exploitation

12
00:00:30,960 --> 00:00:33,200
i'm a recent graduate of fenway tandon

13
00:00:33,200 --> 00:00:34,239
and the osiris lab

14
00:00:34,239 --> 00:00:37,280
shout out where i'm actually also now a

15
00:00:37,280 --> 00:00:39,920
hacker in residence my contact info is

16
00:00:39,920 --> 00:00:40,719
on screen

17
00:00:40,719 --> 00:00:43,440
if you wanted to email with questions

18
00:00:43,440 --> 00:00:44,160
ideas

19
00:00:44,160 --> 00:00:46,160
anything like that after the talk i'm

20
00:00:46,160 --> 00:00:48,879
happy to have you to talk

21
00:00:48,879 --> 00:00:51,920
hello everyone my name is harini kanan

22
00:00:51,920 --> 00:00:55,039
i am a data scientist at capsule 8. my

23
00:00:55,039 --> 00:00:57,600
background is in business statistics i

24
00:00:57,600 --> 00:00:59,840
am currently working on system user

25
00:00:59,840 --> 00:01:01,520
behavior profiling

26
00:01:01,520 --> 00:01:05,600
text analytics uh interpretable ml mlaps

27
00:01:05,600 --> 00:01:07,439
uh you can hit me up at twitter at

28
00:01:07,439 --> 00:01:08,880
jarvision or

29
00:01:08,880 --> 00:01:12,240
um through my website so

30
00:01:12,240 --> 00:01:14,960
without much to do let's get started

31
00:01:14,960 --> 00:01:17,600
over to ghost

32
00:01:17,600 --> 00:01:19,840
so introduction to the talk uh what are

33
00:01:19,840 --> 00:01:20,640
we going to be covering

34
00:01:20,640 --> 00:01:22,560
so first we're going to be covering what

35
00:01:22,560 --> 00:01:23,920
hardware performance counters

36
00:01:23,920 --> 00:01:26,560
are and why they exist uh then we'll be

37
00:01:26,560 --> 00:01:27,280
going into

38
00:01:27,280 --> 00:01:29,360
some prior work that harini and i have

39
00:01:29,360 --> 00:01:30,799
done specifically on detecting

40
00:01:30,799 --> 00:01:32,960
spectre and meltdown but with documented

41
00:01:32,960 --> 00:01:34,159
counters

42
00:01:34,159 --> 00:01:36,320
then we'll be going into this work

43
00:01:36,320 --> 00:01:37,680
particularly

44
00:01:37,680 --> 00:01:40,400
what what these undocumented hardware

45
00:01:40,400 --> 00:01:40,880
counters

46
00:01:40,880 --> 00:01:43,680
are and kind of exploring them a little

47
00:01:43,680 --> 00:01:44,479
bit

48
00:01:44,479 --> 00:01:47,360
uh we'll be then training models on

49
00:01:47,360 --> 00:01:48,720
undocumented counters

50
00:01:48,720 --> 00:01:51,280
uh seeing what we can detect with these

51
00:01:51,280 --> 00:01:52,399
trained models

52
00:01:52,399 --> 00:01:53,920
and doing a little bit of interpretation

53
00:01:53,920 --> 00:01:55,520
on the results again given that these

54
00:01:55,520 --> 00:01:55,840
are

55
00:01:55,840 --> 00:01:58,000
undocumented we can't know for sure

56
00:01:58,000 --> 00:01:58,880
exactly what they're

57
00:01:58,880 --> 00:02:01,680
measuring but we have some ideas and

58
00:02:01,680 --> 00:02:02,399
lastly we'll

59
00:02:02,399 --> 00:02:04,399
go over some future work ideas of which

60
00:02:04,399 --> 00:02:06,560
there are plenty

61
00:02:06,560 --> 00:02:08,239
so the main question that we're out to

62
00:02:08,239 --> 00:02:10,720
answer is can we detect

63
00:02:10,720 --> 00:02:12,959
exploits using undocumented hardware

64
00:02:12,959 --> 00:02:15,360
performance counters on intel cpus

65
00:02:15,360 --> 00:02:18,959
it's a mouthful so first what are these

66
00:02:18,959 --> 00:02:20,560
hardware performance counters that we've

67
00:02:20,560 --> 00:02:22,000
been talking about

68
00:02:22,000 --> 00:02:25,200
so they're also known as performance

69
00:02:25,200 --> 00:02:26,239
monitoring counters

70
00:02:26,239 --> 00:02:28,560
basically they're hardware devices that

71
00:02:28,560 --> 00:02:29,520
count events

72
00:02:29,520 --> 00:02:31,920
as they happen in a couple of different

73
00:02:31,920 --> 00:02:34,400
performance monitoring units or pmus

74
00:02:34,400 --> 00:02:36,480
inside of the processor

75
00:02:36,480 --> 00:02:39,920
um they're usually used to debug things

76
00:02:39,920 --> 00:02:40,959
like system

77
00:02:40,959 --> 00:02:42,879
slowness or program slowness measuring

78
00:02:42,879 --> 00:02:45,200
things like cache misses total number

79
00:02:45,200 --> 00:02:46,160
instructions run

80
00:02:46,160 --> 00:02:49,040
things like that but as we'll see they

81
00:02:49,040 --> 00:02:52,080
have a lot more uses as well

82
00:02:52,080 --> 00:02:55,280
um specifically we'll be focusing on the

83
00:02:55,280 --> 00:02:58,480
cpu pmu today and that

84
00:02:58,480 --> 00:03:00,319
is the performance modern unit that

85
00:03:00,319 --> 00:03:01,599
lives on each core

86
00:03:01,599 --> 00:03:05,680
or on each hyper thread in a modern cpu

87
00:03:05,680 --> 00:03:08,319
most modern intel cpus let you pick four

88
00:03:08,319 --> 00:03:09,680
or five depending on the exact

89
00:03:09,680 --> 00:03:10,720
generation

90
00:03:10,720 --> 00:03:12,400
counters to monitor at once if you're on

91
00:03:12,400 --> 00:03:13,760
a hyper thread or

92
00:03:13,760 --> 00:03:15,440
eight or ten if you're on a

93
00:03:15,440 --> 00:03:17,920
non-hyper-threaded core

94
00:03:17,920 --> 00:03:19,440
and you specify what you actually want

95
00:03:19,440 --> 00:03:21,680
to measure to the processor as two 8-bit

96
00:03:21,680 --> 00:03:22,239
integers

97
00:03:22,239 --> 00:03:24,640
an event id and a hue mask broadly

98
00:03:24,640 --> 00:03:25,920
speaking the event id

99
00:03:25,920 --> 00:03:28,799
is the category or kind of the subsystem

100
00:03:28,799 --> 00:03:29,840
that you're wanting to measure

101
00:03:29,840 --> 00:03:33,920
so the branch predictor or the

102
00:03:33,920 --> 00:03:36,640
caches something else like that and then

103
00:03:36,640 --> 00:03:39,040
umass specifies exactly what

104
00:03:39,040 --> 00:03:40,879
counter you're interested in within that

105
00:03:40,879 --> 00:03:43,200
so l1 cache misses or

106
00:03:43,200 --> 00:03:46,879
conditional branches

107
00:03:46,879 --> 00:03:49,680
on linux you interact with these through

108
00:03:49,680 --> 00:03:51,040
the perf subsystem

109
00:03:51,040 --> 00:03:54,000
and usually through the perth cli there

110
00:03:54,000 --> 00:03:55,200
are some examples up there

111
00:03:55,200 --> 00:03:56,959
if you wanted to mess around the first

112
00:03:56,959 --> 00:03:59,040
one as you may guess

113
00:03:59,040 --> 00:04:02,080
measures the number of cache misses that

114
00:04:02,080 --> 00:04:03,519
the processor

115
00:04:03,519 --> 00:04:06,799
has while running bin ls and then the

116
00:04:06,799 --> 00:04:08,640
second one is specifying a specific

117
00:04:08,640 --> 00:04:10,239
event id and umask and that one in

118
00:04:10,239 --> 00:04:11,599
particular you'll actually

119
00:04:11,599 --> 00:04:15,360
see show up in our models later

120
00:04:15,360 --> 00:04:16,639
it's also worth noting that there's a

121
00:04:16,639 --> 00:04:18,560
couple different ways to actually sample

122
00:04:18,560 --> 00:04:21,120
these counters from the cpu you can get

123
00:04:21,120 --> 00:04:21,759
them on

124
00:04:21,759 --> 00:04:25,680
a timer basis so every n milliseconds

125
00:04:25,680 --> 00:04:28,000
you can get them when the counter

126
00:04:28,000 --> 00:04:29,759
overflows a certain value

127
00:04:29,759 --> 00:04:32,560
so when it reaches a threshold or you

128
00:04:32,560 --> 00:04:33,919
can just let them build up the entire

129
00:04:33,919 --> 00:04:35,199
duration of the program run

130
00:04:35,199 --> 00:04:37,440
which will be what we'll be exploring to

131
00:04:37,440 --> 00:04:39,680
start with

132
00:04:39,680 --> 00:04:42,240
so a couple years ago spectrum meltdown

133
00:04:42,240 --> 00:04:43,040
happened

134
00:04:43,040 --> 00:04:46,240
um for those who didn't hear at the time

135
00:04:46,240 --> 00:04:47,919
or haven't heard since

136
00:04:47,919 --> 00:04:50,080
there are cpu level vulnerabilities that

137
00:04:50,080 --> 00:04:52,160
abuse processor speculation

138
00:04:52,160 --> 00:04:53,360
basically the process of modern

139
00:04:53,360 --> 00:04:55,199
processors speculate what code should be

140
00:04:55,199 --> 00:04:56,720
run before they know for sure

141
00:04:56,720 --> 00:04:59,919
to make your code faster

142
00:05:00,000 --> 00:05:02,720
this introduces a lot of ways to do bad

143
00:05:02,720 --> 00:05:03,840
things though

144
00:05:03,840 --> 00:05:06,880
so spectre v1 was speculating through a

145
00:05:06,880 --> 00:05:08,960
bounce check so in your speculated code

146
00:05:08,960 --> 00:05:10,400
you could read an

147
00:05:10,400 --> 00:05:12,560
i don't know past the end of an array

148
00:05:12,560 --> 00:05:13,759
for example

149
00:05:13,759 --> 00:05:16,400
um spectre rsv will let you speculate

150
00:05:16,400 --> 00:05:17,759
through a bad return address

151
00:05:17,759 --> 00:05:20,800
inspector return stack buffer you could

152
00:05:20,800 --> 00:05:21,440
speculate

153
00:05:21,440 --> 00:05:24,639
reading a disabled fpu which is lazy fp

154
00:05:24,639 --> 00:05:27,039
so potentially leaking secrets from

155
00:05:27,039 --> 00:05:29,360
other processes on the system entirely

156
00:05:29,360 --> 00:05:32,880
and there's a bunch more so

157
00:05:32,880 --> 00:05:34,080
a bit of background here these

158
00:05:34,080 --> 00:05:36,000
speculative execution attacks by

159
00:05:36,000 --> 00:05:38,000
themselves don't do a whole lot

160
00:05:38,000 --> 00:05:40,320
uh right you can speculate execute code

161
00:05:40,320 --> 00:05:41,280
but

162
00:05:41,280 --> 00:05:43,199
can't do anything with that because all

163
00:05:43,199 --> 00:05:45,280
of the actual artifacts

164
00:05:45,280 --> 00:05:47,919
get they don't get committed to the

165
00:05:47,919 --> 00:05:49,520
system state

166
00:05:49,520 --> 00:05:53,280
so what you can do is use a separate

167
00:05:53,280 --> 00:05:54,960
exultration technique like flush and

168
00:05:54,960 --> 00:05:55,759
reload

169
00:05:55,759 --> 00:05:58,319
to actually exfiltrate data out of the

170
00:05:58,319 --> 00:06:00,319
speculative execution

171
00:06:00,319 --> 00:06:02,720
so the one we'll be talking about today

172
00:06:02,720 --> 00:06:04,800
is flush and reload

173
00:06:04,800 --> 00:06:07,360
which is pretty consistent and easy

174
00:06:07,360 --> 00:06:08,080
enough to do

175
00:06:08,080 --> 00:06:10,000
with assembly level access this can be

176
00:06:10,000 --> 00:06:11,120
done through

177
00:06:11,120 --> 00:06:12,560
like a javascript interpreter for

178
00:06:12,560 --> 00:06:14,880
instance uh the basic idea is that you

179
00:06:14,880 --> 00:06:16,160
have a timing array

180
00:06:16,160 --> 00:06:19,039
and before you run whatever part of code

181
00:06:19,039 --> 00:06:20,639
you want to spec you want to get data

182
00:06:20,639 --> 00:06:24,080
out of you still flush that entire array

183
00:06:24,080 --> 00:06:25,039
out of memory

184
00:06:25,039 --> 00:06:28,240
or out of the cache so that any accesses

185
00:06:28,240 --> 00:06:30,240
to it will force a memory

186
00:06:30,240 --> 00:06:33,199
read you then go through with your

187
00:06:33,199 --> 00:06:35,039
schedule of execution and have the

188
00:06:35,039 --> 00:06:36,000
speculation

189
00:06:36,000 --> 00:06:39,360
load a cache line and what they'll do is

190
00:06:39,360 --> 00:06:42,160
mark a cache line active and then when

191
00:06:42,160 --> 00:06:42,720
you can

192
00:06:42,720 --> 00:06:44,800
you come along later read through all

193
00:06:44,800 --> 00:06:46,400
the cache lines in the array and one of

194
00:06:46,400 --> 00:06:48,160
them will read faster than the others

195
00:06:48,160 --> 00:06:49,520
because the other ones are still reading

196
00:06:49,520 --> 00:06:51,120
from main memory because you cl flushed

197
00:06:51,120 --> 00:06:51,759
it earlier

198
00:06:51,759 --> 00:06:53,919
but one of them will be fast because you

199
00:06:53,919 --> 00:06:54,880
loaded it during

200
00:06:54,880 --> 00:06:56,880
speculative execution and that side

201
00:06:56,880 --> 00:06:59,360
effect on the cpu doesn't get

202
00:06:59,360 --> 00:07:01,199
thrown away when the processor realized

203
00:07:01,199 --> 00:07:03,599
it's misspeculated

204
00:07:03,599 --> 00:07:06,639
so a hypothetical example here this is

205
00:07:06,639 --> 00:07:08,720
super oversimplified cache lines are

206
00:07:08,720 --> 00:07:09,680
like one byte

207
00:07:09,680 --> 00:07:11,520
in this example so it's obviously not

208
00:07:11,520 --> 00:07:14,319
real but just to get the point across

209
00:07:14,319 --> 00:07:16,639
let's say you have a conditional branch

210
00:07:16,639 --> 00:07:18,319
that is slow to load and

211
00:07:18,319 --> 00:07:20,800
usually true so the branch predictor

212
00:07:20,800 --> 00:07:22,400
encounters this and says okay

213
00:07:22,400 --> 00:07:24,080
let me go dispatch the actual read but

214
00:07:24,080 --> 00:07:25,520
let me try and continue

215
00:07:25,520 --> 00:07:28,000
into this next instruction speculating

216
00:07:28,000 --> 00:07:29,199
that

217
00:07:29,199 --> 00:07:32,479
the conditional come back true so in the

218
00:07:32,479 --> 00:07:33,520
speculation

219
00:07:33,520 --> 00:07:37,680
we now load from secret number and load

220
00:07:37,680 --> 00:07:40,160
a cache line in our out array which is

221
00:07:40,160 --> 00:07:41,599
our timing array

222
00:07:41,599 --> 00:07:43,840
based on the secret so in this case

223
00:07:43,840 --> 00:07:45,520
we're masking off the low two bits

224
00:07:45,520 --> 00:07:48,400
and we're saying let's load from that so

225
00:07:48,400 --> 00:07:49,280
that'll make

226
00:07:49,280 --> 00:07:52,080
in this case the third cache line active

227
00:07:52,080 --> 00:07:53,280
um

228
00:07:53,280 --> 00:07:56,080
now eventually the load will originally

229
00:07:56,080 --> 00:07:57,120
come through and

230
00:07:57,120 --> 00:07:58,400
processor will realize and miss

231
00:07:58,400 --> 00:08:00,400
speculated and will throw away all the

232
00:08:00,400 --> 00:08:02,000
architectural state

233
00:08:02,000 --> 00:08:05,680
um but leave the cache line active

234
00:08:05,680 --> 00:08:07,520
so we can come along later and measure

235
00:08:07,520 --> 00:08:09,120
how long it takes to actually access all

236
00:08:09,120 --> 00:08:09,440
these

237
00:08:09,440 --> 00:08:10,879
and we'll find that the first two are

238
00:08:10,879 --> 00:08:12,720
slow but the third one's really fast

239
00:08:12,720 --> 00:08:14,400
because it's already in cash

240
00:08:14,400 --> 00:08:16,319
and so with this we can leave that at

241
00:08:16,319 --> 00:08:18,319
least below two bits of our secret

242
00:08:18,319 --> 00:08:18,720
number

243
00:08:18,720 --> 00:08:21,840
r2 so

244
00:08:21,840 --> 00:08:24,160
we developed detections for spectrum

245
00:08:24,160 --> 00:08:25,280
meltdown

246
00:08:25,280 --> 00:08:28,960
using three counters early in 2018.

247
00:08:28,960 --> 00:08:31,120
we used the total number of cash misses

248
00:08:31,120 --> 00:08:32,640
the number of cash references

249
00:08:32,640 --> 00:08:34,719
and the number of branch misses the

250
00:08:34,719 --> 00:08:35,679
first two form

251
00:08:35,679 --> 00:08:38,320
effectively the cash miss ratio and then

252
00:08:38,320 --> 00:08:40,159
the third was actually chosen just by

253
00:08:40,159 --> 00:08:41,839
experimentation but

254
00:08:41,839 --> 00:08:43,919
makes sense kind of looking back after

255
00:08:43,919 --> 00:08:45,760
the fact basically it normalizes to the

256
00:08:45,760 --> 00:08:47,600
complexity of the program

257
00:08:47,600 --> 00:08:50,880
so the idea is if a program

258
00:08:50,880 --> 00:08:52,959
is branch mispredicting a lot it's also

259
00:08:52,959 --> 00:08:54,880
likely to cache miss a lot

260
00:08:54,880 --> 00:08:56,640
just it's not well optimized or it's

261
00:08:56,640 --> 00:08:58,399
doing something really weird

262
00:08:58,399 --> 00:09:02,160
um so we sample all of these counters on

263
00:09:02,160 --> 00:09:03,600
100 ml hertz

264
00:09:03,600 --> 00:09:06,880
and again on 100 millisecond ticker

265
00:09:06,880 --> 00:09:09,440
and this technique detects all the

266
00:09:09,440 --> 00:09:10,959
public proof of concepts that we've

267
00:09:10,959 --> 00:09:12,480
tried

268
00:09:12,480 --> 00:09:16,160
so uh this is a visualization of the svm

269
00:09:16,160 --> 00:09:18,080
model that we built around this hernia

270
00:09:18,080 --> 00:09:19,680
will go into details about what this

271
00:09:19,680 --> 00:09:22,080
actually means later and what svm is

272
00:09:22,080 --> 00:09:23,760
but roughly speaking to you the green

273
00:09:23,760 --> 00:09:26,080
dots are non-attacks they're benign

274
00:09:26,080 --> 00:09:26,959
programs running

275
00:09:26,959 --> 00:09:29,839
the red dots are attacks uh they're

276
00:09:29,839 --> 00:09:30,560
instances of

277
00:09:30,560 --> 00:09:32,880
spectral proof of concept running and

278
00:09:32,880 --> 00:09:33,839
you can see basically

279
00:09:33,839 --> 00:09:35,920
we've successfully drawn circles around

280
00:09:35,920 --> 00:09:37,279
all the red dots which means we've

281
00:09:37,279 --> 00:09:38,959
caught the attacks

282
00:09:38,959 --> 00:09:41,440
um specifically if we actually look at

283
00:09:41,440 --> 00:09:42,880
the accuracy

284
00:09:42,880 --> 00:09:45,200
if we combine the svm model and a

285
00:09:45,200 --> 00:09:46,800
deterministic model which is

286
00:09:46,800 --> 00:09:50,560
just cachement's ratio and

287
00:09:50,560 --> 00:09:52,560
branchness ratio below a certain

288
00:09:52,560 --> 00:09:55,120
threshold we can see that we get 100

289
00:09:55,120 --> 00:09:57,200
accuracy and a zero false negative rate

290
00:09:57,200 --> 00:09:58,720
so we have effectively a perfect

291
00:09:58,720 --> 00:09:59,839
detector here

292
00:09:59,839 --> 00:10:01,360
for all the proof of concepts that we've

293
00:10:01,360 --> 00:10:04,160
tried however

294
00:10:04,160 --> 00:10:05,519
this detection can actually be really

295
00:10:05,519 --> 00:10:07,600
easily defeated if you know what it's

296
00:10:07,600 --> 00:10:08,720
looking for

297
00:10:08,720 --> 00:10:10,480
so all you have to do is mix in some

298
00:10:10,480 --> 00:10:12,399
cache friendly code into the proof

299
00:10:12,399 --> 00:10:13,680
concept

300
00:10:13,680 --> 00:10:16,880
an example like this you have this stuff

301
00:10:16,880 --> 00:10:19,519
array which we effectively always keep

302
00:10:19,519 --> 00:10:20,480
in cash

303
00:10:20,480 --> 00:10:23,920
uh and excuse all the register

304
00:10:23,920 --> 00:10:25,920
old c style nonsense i just wanted to

305
00:10:25,920 --> 00:10:27,200
make sure that

306
00:10:27,200 --> 00:10:29,200
this doesn't end up writing something

307
00:10:29,200 --> 00:10:31,040
into the stack which modifies the cache

308
00:10:31,040 --> 00:10:32,000
in another way

309
00:10:32,000 --> 00:10:33,839
this just does what i think it does and

310
00:10:33,839 --> 00:10:35,279
sure enough this will bypass

311
00:10:35,279 --> 00:10:38,000
our detection we can even tune using the

312
00:10:38,000 --> 00:10:40,079
high bound of the round parameter

313
00:10:40,079 --> 00:10:43,279
how would our cache ratio what we want

314
00:10:43,279 --> 00:10:44,839
it to be so we can mimic

315
00:10:44,839 --> 00:10:48,160
anything so

316
00:10:48,160 --> 00:10:51,360
with that done let's dive into

317
00:10:51,360 --> 00:10:54,160
our current research so as i mentioned

318
00:10:54,160 --> 00:10:55,200
earlier harper

319
00:10:55,200 --> 00:10:58,640
performance counters are

320
00:10:58,640 --> 00:11:01,839
specified with two 8-bit integers so

321
00:11:01,839 --> 00:11:05,200
we actually have room for 65

322
00:11:05,200 --> 00:11:08,800
536 counters potentially

323
00:11:08,800 --> 00:11:11,040
but only a subset of those are actually

324
00:11:11,040 --> 00:11:12,959
documented by intel

325
00:11:12,959 --> 00:11:16,720
um somewhere in the low hundreds to

326
00:11:16,720 --> 00:11:19,760
a thousand-ish i think 1500-ish was the

327
00:11:19,760 --> 00:11:22,320
most they've ever documented

328
00:11:22,320 --> 00:11:24,640
but that's not to say that the ones that

329
00:11:24,640 --> 00:11:26,399
aren't documented don't have any

330
00:11:26,399 --> 00:11:27,760
data behind them that they're not

331
00:11:27,760 --> 00:11:29,440
counting anything

332
00:11:29,440 --> 00:11:32,480
so the idea basically came out what if

333
00:11:32,480 --> 00:11:33,440
we read

334
00:11:33,440 --> 00:11:35,279
all of the counters even the

335
00:11:35,279 --> 00:11:36,720
undocumented ones

336
00:11:36,720 --> 00:11:38,399
um by doing this we're basically turning

337
00:11:38,399 --> 00:11:40,320
this x-ray detection problem into a

338
00:11:40,320 --> 00:11:41,360
black box ml

339
00:11:41,360 --> 00:11:43,440
problem so just completely changing

340
00:11:43,440 --> 00:11:45,040
frame

341
00:11:45,040 --> 00:11:48,640
um so what are we going to run these

342
00:11:48,640 --> 00:11:49,519
cameras on

343
00:11:49,519 --> 00:11:51,120
though i guess is the question that

344
00:11:51,120 --> 00:11:54,160
arises so we have four sample programs

345
00:11:54,160 --> 00:11:56,079
that we were running on we have a

346
00:11:56,079 --> 00:11:58,240
minified exit zero which is basically

347
00:11:58,240 --> 00:11:59,680
theirs to detect

348
00:11:59,680 --> 00:12:02,160
any overhead of the kernel actually

349
00:12:02,160 --> 00:12:03,920
starting the process

350
00:12:03,920 --> 00:12:06,959
um we have a scikit benchmark which was

351
00:12:06,959 --> 00:12:08,399
known from prior research

352
00:12:08,399 --> 00:12:11,440
just to be something that was very

353
00:12:11,440 --> 00:12:14,160
that had a very high cache miss ratio so

354
00:12:14,160 --> 00:12:14,800
it

355
00:12:14,800 --> 00:12:17,519
sort of looks like spectre we had the

356
00:12:17,519 --> 00:12:19,120
spectre proof concept itself

357
00:12:19,120 --> 00:12:21,040
and then we had our modified specter

358
00:12:21,040 --> 00:12:22,560
proof of concept

359
00:12:22,560 --> 00:12:26,079
with our cache friendly code mixed in

360
00:12:26,079 --> 00:12:28,560
so once we gather all that data we did a

361
00:12:28,560 --> 00:12:30,480
few filtering steps we removed all the

362
00:12:30,480 --> 00:12:31,760
counters that were always zero

363
00:12:31,760 --> 00:12:34,320
just because they weren't doing anything

364
00:12:34,320 --> 00:12:36,079
we removed counters that had a

365
00:12:36,079 --> 00:12:36,639
difference

366
00:12:36,639 --> 00:12:40,079
between psychic and spectre less than 95

367
00:12:40,079 --> 00:12:43,600
so the idea is basically we want things

368
00:12:43,600 --> 00:12:44,480
that are

369
00:12:44,480 --> 00:12:48,079
very different than we want things that

370
00:12:48,079 --> 00:12:49,120
are very different between

371
00:12:49,120 --> 00:12:51,519
psychic and spectre then we removed

372
00:12:51,519 --> 00:12:52,959
counters that differed more than five

373
00:12:52,959 --> 00:12:53,680
percent

374
00:12:53,680 --> 00:12:56,320
between our modified specter before the

375
00:12:56,320 --> 00:12:58,240
original proof of concept again the idea

376
00:12:58,240 --> 00:12:59,279
being

377
00:12:59,279 --> 00:13:02,639
those two should should give a similar

378
00:13:02,639 --> 00:13:04,399
signature because we want to actually

379
00:13:04,399 --> 00:13:06,079
detect the exploit running not like a

380
00:13:06,079 --> 00:13:07,360
side effect of it

381
00:13:07,360 --> 00:13:09,360
so since those are at their core doing

382
00:13:09,360 --> 00:13:10,800
the same exploit they should be

383
00:13:10,800 --> 00:13:13,519
relatively similar in their accounts um

384
00:13:13,519 --> 00:13:15,360
at the end of that we were left with 81

385
00:13:15,360 --> 00:13:15,920
counters

386
00:13:15,920 --> 00:13:17,519
and interestingly enough none of them

387
00:13:17,519 --> 00:13:18,959
were documented so

388
00:13:18,959 --> 00:13:20,399
we thought okay maybe we're actually on

389
00:13:20,399 --> 00:13:22,079
something here

390
00:13:22,079 --> 00:13:23,440
um it's worth noting at this point that

391
00:13:23,440 --> 00:13:25,279
all of our tests were run on a haswell

392
00:13:25,279 --> 00:13:27,120
machine and an iv bridge machine

393
00:13:27,120 --> 00:13:29,839
so a bit older microarchitectures but

394
00:13:29,839 --> 00:13:30,399
should

395
00:13:30,399 --> 00:13:32,639
what we found should still be valid with

396
00:13:32,639 --> 00:13:33,600
adaptation

397
00:13:33,600 --> 00:13:36,079
on newer microarchitectures but the

398
00:13:36,079 --> 00:13:37,440
results will differ

399
00:13:37,440 --> 00:13:39,440
because again these counters change from

400
00:13:39,440 --> 00:13:42,160
generation to generation

401
00:13:42,160 --> 00:13:44,959
so we came up with two data sets of

402
00:13:44,959 --> 00:13:46,560
counters that looked interesting

403
00:13:46,560 --> 00:13:48,320
the first one is one that we'll be

404
00:13:48,320 --> 00:13:49,920
covering from here on out

405
00:13:49,920 --> 00:13:52,320
um the second performed almost

406
00:13:52,320 --> 00:13:53,360
identically

407
00:13:53,360 --> 00:13:55,279
but we just don't have time to cover

408
00:13:55,279 --> 00:13:57,199
both of them and interestingly enough

409
00:13:57,199 --> 00:13:58,160
you'll actually see

410
00:13:58,160 --> 00:13:59,839
one of the counters appears in both

411
00:13:59,839 --> 00:14:01,519
which turns out to be a very significant

412
00:14:01,519 --> 00:14:03,600
counter

413
00:14:03,600 --> 00:14:06,720
all right now that we have zeroed in on

414
00:14:06,720 --> 00:14:08,800
which undocumented counters we want to

415
00:14:08,800 --> 00:14:11,680
use as features for our models

416
00:14:11,680 --> 00:14:15,279
let's see how the experiments run

417
00:14:15,279 --> 00:14:18,320
so uh the exploits of interest for us

418
00:14:18,320 --> 00:14:21,680
where uh meltdown aka spectre v3

419
00:14:21,680 --> 00:14:24,480
which is the road data cache load uh

420
00:14:24,480 --> 00:14:26,800
spectral v1 which is the bounce check

421
00:14:26,800 --> 00:14:29,760
bypass spectral v2 which is the branch

422
00:14:29,760 --> 00:14:31,680
target injection

423
00:14:31,680 --> 00:14:34,160
spectrov4 which is the speculative store

424
00:14:34,160 --> 00:14:35,519
bypass

425
00:14:35,519 --> 00:14:37,600
ghosting spectrov4 which is the same

426
00:14:37,600 --> 00:14:39,760
aspect of before but with invasive

427
00:14:39,760 --> 00:14:40,800
changes

428
00:14:40,800 --> 00:14:44,560
that ghost made to make sure we bypass

429
00:14:44,560 --> 00:14:46,639
the existing uh detections

430
00:14:46,639 --> 00:14:49,760
using known performance counters right

431
00:14:49,760 --> 00:14:52,639
uh we were also curious to see if we can

432
00:14:52,639 --> 00:14:53,279
detect

433
00:14:53,279 --> 00:14:56,480
uh drop and stack pivot attacks using

434
00:14:56,480 --> 00:14:57,199
these same

435
00:14:57,199 --> 00:15:00,639
undocumented per features and

436
00:15:00,639 --> 00:15:05,760
surprisingly we could let's see how

437
00:15:05,760 --> 00:15:08,800
so for the data collection we

438
00:15:08,800 --> 00:15:11,839
are using linux perf counters of course

439
00:15:11,839 --> 00:15:12,560
and

440
00:15:12,560 --> 00:15:14,639
along with the exploits mentioned before

441
00:15:14,639 --> 00:15:16,959
uh we also collected data for the

442
00:15:16,959 --> 00:15:20,160
following uh baseline programs um they

443
00:15:20,160 --> 00:15:20,560
were

444
00:15:20,560 --> 00:15:22,800
limited unit tests uh scikit-learn

445
00:15:22,800 --> 00:15:25,440
benchmark tests uh pharonix enginex test

446
00:15:25,440 --> 00:15:26,639
suit

447
00:15:26,639 --> 00:15:29,680
and linux stuff config compiler

448
00:15:29,680 --> 00:15:32,480
and uh we selected uh these selected

449
00:15:32,480 --> 00:15:34,560
counters were measured for every

450
00:15:34,560 --> 00:15:37,279
100 milliseconds and each of the test

451
00:15:37,279 --> 00:15:39,360
script was run five times

452
00:15:39,360 --> 00:15:42,800
for uh statistical significance right

453
00:15:42,800 --> 00:15:45,680
and uh these were the model metrics that

454
00:15:45,680 --> 00:15:46,720
we calculated

455
00:15:46,720 --> 00:15:50,320
um precision recall f1 score

456
00:15:50,320 --> 00:15:52,880
false positive rate false negative rate

457
00:15:52,880 --> 00:15:54,240
area under the curve

458
00:15:54,240 --> 00:15:57,759
test accuracy and confusion matrix

459
00:15:57,759 --> 00:16:01,279
now before going to the numbers uh let's

460
00:16:01,279 --> 00:16:03,759
uh quickly see what each of the metrics

461
00:16:03,759 --> 00:16:04,320
mean

462
00:16:04,320 --> 00:16:08,160
um as a quick summary uh

463
00:16:08,160 --> 00:16:10,480
so precision is the ability of a

464
00:16:10,480 --> 00:16:11,279
classifier

465
00:16:11,279 --> 00:16:14,639
to not label a true negative observation

466
00:16:14,639 --> 00:16:18,160
as possible it's the proportion of

467
00:16:18,160 --> 00:16:20,160
positive identifications

468
00:16:20,160 --> 00:16:22,399
made by the classifier that are actually

469
00:16:22,399 --> 00:16:23,440
correct

470
00:16:23,440 --> 00:16:25,519
so it's basically the percentage of your

471
00:16:25,519 --> 00:16:27,759
results uh which are relevant

472
00:16:27,759 --> 00:16:31,120
right uh next is recall

473
00:16:31,120 --> 00:16:32,959
uh recall is the ability of the

474
00:16:32,959 --> 00:16:34,320
classifier to find

475
00:16:34,320 --> 00:16:37,279
uh positive examples uh basically what

476
00:16:37,279 --> 00:16:39,920
proportion of actual positives

477
00:16:39,920 --> 00:16:43,199
were identified correctly so if we want

478
00:16:43,199 --> 00:16:44,639
to be certain to find

479
00:16:44,639 --> 00:16:46,880
all the positive examples uh we could

480
00:16:46,880 --> 00:16:47,759
maximize

481
00:16:47,759 --> 00:16:50,880
recall right the next one

482
00:16:50,880 --> 00:16:53,519
is f1 score f1 score is basically the

483
00:16:53,519 --> 00:16:54,480
harmonic mean

484
00:16:54,480 --> 00:16:57,199
of precision and recall and it ranges

485
00:16:57,199 --> 00:16:59,440
from zero to one so you want it to be as

486
00:16:59,440 --> 00:17:01,839
high as possible as close to one

487
00:17:01,839 --> 00:17:04,240
uh so instead of seeing precision and

488
00:17:04,240 --> 00:17:04,880
recall

489
00:17:04,880 --> 00:17:06,480
uh separately you can just look at the

490
00:17:06,480 --> 00:17:08,319
f1 score and

491
00:17:08,319 --> 00:17:10,569
um look at the um

492
00:17:10,569 --> 00:17:11,839
[Music]

493
00:17:11,839 --> 00:17:14,160
the goodness of the mod how how good it

494
00:17:14,160 --> 00:17:15,839
is

495
00:17:15,839 --> 00:17:17,839
the next one is area under the curve

496
00:17:17,839 --> 00:17:19,439
this is an important metric for any

497
00:17:19,439 --> 00:17:21,119
classification problem

498
00:17:21,119 --> 00:17:23,760
uh the rc curve represents the true

499
00:17:23,760 --> 00:17:24,559
positive rate

500
00:17:24,559 --> 00:17:26,400
and false positive rate for all

501
00:17:26,400 --> 00:17:28,240
probability thresholds of a binary

502
00:17:28,240 --> 00:17:29,280
classifier

503
00:17:29,280 --> 00:17:32,160
right the auc evaluates the overall

504
00:17:32,160 --> 00:17:33,679
quality of the model

505
00:17:33,679 --> 00:17:36,799
so more the um area of the curve

506
00:17:36,799 --> 00:17:39,120
the better right so in the plot you can

507
00:17:39,120 --> 00:17:40,080
see uh

508
00:17:40,080 --> 00:17:42,480
in the left in the x-axis you can see

509
00:17:42,480 --> 00:17:44,160
the false positive rate in the y-axis

510
00:17:44,160 --> 00:17:45,120
you can see the

511
00:17:45,120 --> 00:17:48,960
true positive rate so you want the um

512
00:17:48,960 --> 00:17:52,400
plot the graph to be pulled as

513
00:17:52,400 --> 00:17:56,160
um close to the left top quadrant as

514
00:17:56,160 --> 00:17:56,960
possible

515
00:17:56,960 --> 00:17:59,440
right you want the lowest false positive

516
00:17:59,440 --> 00:18:02,160
rate and the highest true positive rate

517
00:18:02,160 --> 00:18:04,640
right so this is a good metric to

518
00:18:04,640 --> 00:18:05,200
measure

519
00:18:05,200 --> 00:18:08,320
a classification model the next one is

520
00:18:08,320 --> 00:18:10,720
confusion matrix another important one

521
00:18:10,720 --> 00:18:13,200
this is also known as error matrix and

522
00:18:13,200 --> 00:18:15,520
is a specific table layout that allows

523
00:18:15,520 --> 00:18:16,880
visualization of the

524
00:18:16,880 --> 00:18:19,440
performance of an algorithm right

525
00:18:19,440 --> 00:18:21,679
confusion matrix visualizes the

526
00:18:21,679 --> 00:18:23,760
accuracy of the classifier by comparing

527
00:18:23,760 --> 00:18:25,919
the true and the predicted

528
00:18:25,919 --> 00:18:29,360
predicted classes as you can see

529
00:18:29,360 --> 00:18:32,000
the diagonal squares are the are the

530
00:18:32,000 --> 00:18:33,200
correct predictions

531
00:18:33,200 --> 00:18:35,520
and the off diagonal squares are the

532
00:18:35,520 --> 00:18:36,559
incorrect predictions

533
00:18:36,559 --> 00:18:39,200
um in the plot you can see the y axis is

534
00:18:39,200 --> 00:18:40,240
the true clause

535
00:18:40,240 --> 00:18:43,919
and the x-axis is the predicted class

536
00:18:43,919 --> 00:18:46,000
so that makes all the diagonals as the

537
00:18:46,000 --> 00:18:47,200
true positives

538
00:18:47,200 --> 00:18:50,480
and uh and the two negatives

539
00:18:50,480 --> 00:18:53,280
right so you want them to be as high as

540
00:18:53,280 --> 00:18:55,039
possible and you want the

541
00:18:55,039 --> 00:18:56,799
off diagonal squares which are the wrong

542
00:18:56,799 --> 00:19:00,000
predictions uh to be as low

543
00:19:00,000 --> 00:19:03,200
as possible um so next we will see uh

544
00:19:03,200 --> 00:19:04,240
the algorithms

545
00:19:04,240 --> 00:19:07,360
uh that we have used um

546
00:19:07,360 --> 00:19:09,360
these are the algorithm algorithms that

547
00:19:09,360 --> 00:19:10,880
have performed the best

548
00:19:10,880 --> 00:19:12,799
for us the idea was to start from the

549
00:19:12,799 --> 00:19:13,919
simplest uh

550
00:19:13,919 --> 00:19:16,559
most interpretable model and go up from

551
00:19:16,559 --> 00:19:17,280
there

552
00:19:17,280 --> 00:19:19,760
uh till we get good results and these

553
00:19:19,760 --> 00:19:21,440
are the four models that have

554
00:19:21,440 --> 00:19:24,960
worked really well for us so far

555
00:19:24,960 --> 00:19:27,039
the first one is support vector machine

556
00:19:27,039 --> 00:19:28,480
uh random forest

557
00:19:28,480 --> 00:19:30,320
extreme gradient boosting which is the

558
00:19:30,320 --> 00:19:31,600
xg boost

559
00:19:31,600 --> 00:19:34,000
and histogram based query and boosting

560
00:19:34,000 --> 00:19:34,799
now uh

561
00:19:34,799 --> 00:19:37,200
we'll quickly see what each model just

562
00:19:37,200 --> 00:19:39,039
like a quick summary

563
00:19:39,039 --> 00:19:42,400
uh svm is a supervised ml

564
00:19:42,400 --> 00:19:44,080
algorithm which can be used for

565
00:19:44,080 --> 00:19:45,919
classification as well as regression

566
00:19:45,919 --> 00:19:48,240
uh obviously we are using here for a

567
00:19:48,240 --> 00:19:50,160
binary classification

568
00:19:50,160 --> 00:19:53,280
in svm we plot each data item as

569
00:19:53,280 --> 00:19:56,480
a point in n-dimensional space where

570
00:19:56,480 --> 00:19:58,960
n is the number of features you have and

571
00:19:58,960 --> 00:20:00,880
the value of the feature

572
00:20:00,880 --> 00:20:03,679
being its coordinate then we perform

573
00:20:03,679 --> 00:20:04,640
classification

574
00:20:04,640 --> 00:20:06,960
by finding the hyperplane that

575
00:20:06,960 --> 00:20:09,440
differentiates the tool classes

576
00:20:09,440 --> 00:20:12,080
as you can see in the plot on the left

577
00:20:12,080 --> 00:20:13,280
the objective

578
00:20:13,280 --> 00:20:15,520
is to maximize the distance between the

579
00:20:15,520 --> 00:20:17,039
nearest data point of

580
00:20:17,039 --> 00:20:19,360
either class and the hyperplane that

581
00:20:19,360 --> 00:20:20,559
separates it

582
00:20:20,559 --> 00:20:22,400
right for us the hyperplane is not

583
00:20:22,400 --> 00:20:24,000
linear but it's

584
00:20:24,000 --> 00:20:26,799
it was rbf kernel radial basis function

585
00:20:26,799 --> 00:20:28,799
uh you can see the distance boundaries

586
00:20:28,799 --> 00:20:31,840
of different kernels in the second plot

587
00:20:31,840 --> 00:20:35,280
on the right all right the next one

588
00:20:35,280 --> 00:20:37,760
is uh random forest uh it's an ensemble

589
00:20:37,760 --> 00:20:39,679
method where multiple decision trees are

590
00:20:39,679 --> 00:20:40,240
created

591
00:20:40,240 --> 00:20:42,799
uh using random subsets of features and

592
00:20:42,799 --> 00:20:44,799
bootstrap data

593
00:20:44,799 --> 00:20:46,720
each distinct tree then boots by

594
00:20:46,720 --> 00:20:49,039
predicting the class

595
00:20:49,039 --> 00:20:51,440
the words are then tallied to reach the

596
00:20:51,440 --> 00:20:52,240
final

597
00:20:52,240 --> 00:20:54,799
prediction before seeing the next model

598
00:20:54,799 --> 00:20:55,360
which is the

599
00:20:55,360 --> 00:20:58,080
xt boost and which also performed the

600
00:20:58,080 --> 00:20:59,600
best for us

601
00:20:59,600 --> 00:21:01,679
let's see the basic behind the scenes

602
00:21:01,679 --> 00:21:03,280
difference in concept

603
00:21:03,280 --> 00:21:07,200
for um both these models

604
00:21:07,200 --> 00:21:10,240
random forest uses distant trees which

605
00:21:10,240 --> 00:21:10,799
are

606
00:21:10,799 --> 00:21:13,520
very prone to overfitting in order to

607
00:21:13,520 --> 00:21:15,120
achieve higher accuracy

608
00:21:15,120 --> 00:21:17,679
random forest decides to create a large

609
00:21:17,679 --> 00:21:18,799
number of them

610
00:21:18,799 --> 00:21:21,919
based on bagging now bagging the basic

611
00:21:21,919 --> 00:21:22,960
idea is to

612
00:21:22,960 --> 00:21:25,600
re-sample the data over and over again

613
00:21:25,600 --> 00:21:27,200
for each sample

614
00:21:27,200 --> 00:21:30,080
and it trains a new classifier right so

615
00:21:30,080 --> 00:21:32,159
different classifiers over for the data

616
00:21:32,159 --> 00:21:33,280
in different ways

617
00:21:33,280 --> 00:21:35,600
and through voting those differences are

618
00:21:35,600 --> 00:21:36,559
averaged out

619
00:21:36,559 --> 00:21:38,640
now gbm you know gradient boosting

620
00:21:38,640 --> 00:21:40,320
method is um

621
00:21:40,320 --> 00:21:42,400
a boosting method which builds on weak

622
00:21:42,400 --> 00:21:43,600
classifiers

623
00:21:43,600 --> 00:21:46,799
the idea is to add a classifier at a

624
00:21:46,799 --> 00:21:47,520
time

625
00:21:47,520 --> 00:21:49,840
so that the next classifier is trained

626
00:21:49,840 --> 00:21:51,039
to improve the

627
00:21:51,039 --> 00:21:54,080
already trained ensemble notice that for

628
00:21:54,080 --> 00:21:55,679
random forest each iteration

629
00:21:55,679 --> 00:21:57,520
declassified string independently from

630
00:21:57,520 --> 00:21:58,080
the rest

631
00:21:58,080 --> 00:22:00,559
uh whereas it's the opposite for uh xd

632
00:22:00,559 --> 00:22:01,679
boost

633
00:22:01,679 --> 00:22:06,159
right now uh hd boost which is extreme

634
00:22:06,159 --> 00:22:07,200
gradient boosting

635
00:22:07,200 --> 00:22:10,000
this was the best model we had uh it

636
00:22:10,000 --> 00:22:10,720
builds on b

637
00:22:10,720 --> 00:22:13,360
class first as we saw before um it adds

638
00:22:13,360 --> 00:22:15,520
uh one classifier distance free at a

639
00:22:15,520 --> 00:22:16,400
time

640
00:22:16,400 --> 00:22:18,400
so that the next classifier is trained

641
00:22:18,400 --> 00:22:20,480
to improve the already trained ensemble

642
00:22:20,480 --> 00:22:23,600
right uh the next model

643
00:22:23,600 --> 00:22:26,000
is histogram based and boosting it's a

644
00:22:26,000 --> 00:22:27,520
very similar model to

645
00:22:27,520 --> 00:22:31,120
xd boost it's a faster implementation of

646
00:22:31,120 --> 00:22:32,799
gradient boosting classifier

647
00:22:32,799 --> 00:22:36,080
when the number of samples is high

648
00:22:36,080 --> 00:22:38,880
it binds the input samples into integer

649
00:22:38,880 --> 00:22:40,240
valued bins

650
00:22:40,240 --> 00:22:42,000
which reduces the number of splitting

651
00:22:42,000 --> 00:22:44,080
points to consider

652
00:22:44,080 --> 00:22:45,840
this allows the algorithm to leverage

653
00:22:45,840 --> 00:22:47,679
integer based data structures

654
00:22:47,679 --> 00:22:50,080
instead of relying on sorted continuous

655
00:22:50,080 --> 00:22:50,960
values

656
00:22:50,960 --> 00:22:55,280
when building the trees right now

657
00:22:55,280 --> 00:22:57,919
let's detect spectra again uh but this

658
00:22:57,919 --> 00:22:58,320
time

659
00:22:58,320 --> 00:23:01,520
even the ghost inspector which evaded us

660
00:23:01,520 --> 00:23:02,559
before

661
00:23:02,559 --> 00:23:06,559
um here you can see the summary um

662
00:23:06,559 --> 00:23:10,480
of all the uh model um

663
00:23:10,480 --> 00:23:12,799
that models that we have tested so far

664
00:23:12,799 --> 00:23:14,880
uh the first three columns shows the

665
00:23:14,880 --> 00:23:18,559
the features themselves 3698 40 e3 and

666
00:23:18,559 --> 00:23:20,240
eff4

667
00:23:20,240 --> 00:23:22,000
the next column shows the intel

668
00:23:22,000 --> 00:23:23,840
architecture uh it's either iv

669
00:23:23,840 --> 00:23:26,799
bridge or hassel and the four models

670
00:23:26,799 --> 00:23:27,440
that we have

671
00:23:27,440 --> 00:23:30,400
uh tested uh that worked really well

672
00:23:30,400 --> 00:23:30,960
which are

673
00:23:30,960 --> 00:23:34,320
svm xd boost random forest and hg boost

674
00:23:34,320 --> 00:23:37,679
and then you can see um all the metrics

675
00:23:37,679 --> 00:23:38,240
that we

676
00:23:38,240 --> 00:23:40,960
uh talked about before precision recall

677
00:23:40,960 --> 00:23:42,799
false posture rate false negative rate

678
00:23:42,799 --> 00:23:43,840
area on the curve

679
00:23:43,840 --> 00:23:46,159
and accuracy and then you can see

680
00:23:46,159 --> 00:23:48,840
whether these models detected

681
00:23:48,840 --> 00:23:51,600
um the attacks that we

682
00:23:51,600 --> 00:23:54,720
uh fed um the

683
00:23:54,720 --> 00:23:57,760
green colored rows as you can see have

684
00:23:57,760 --> 00:23:59,679
the models that are doing really well

685
00:23:59,679 --> 00:24:00,960
and they are detecting

686
00:24:00,960 --> 00:24:02,799
all the attack variants all these

687
00:24:02,799 --> 00:24:04,480
spectrum well down variants

688
00:24:04,480 --> 00:24:07,440
right let's see the um the best model

689
00:24:07,440 --> 00:24:09,039
that we had so far

690
00:24:09,039 --> 00:24:12,000
uh which is the xg boost using the three

691
00:24:12,000 --> 00:24:13,679
features that we saw

692
00:24:13,679 --> 00:24:16,880
and the metrics here you can see it has

693
00:24:16,880 --> 00:24:17,840
99

694
00:24:17,840 --> 00:24:21,039
precision 98 recall um

695
00:24:21,039 --> 00:24:24,480
0.04 percent falls past a rate of 4

696
00:24:24,480 --> 00:24:25,200
percent

697
00:24:25,200 --> 00:24:29,039
false negative rate and 98

698
00:24:29,039 --> 00:24:31,679
area of the curve now false negative

699
00:24:31,679 --> 00:24:33,360
rate here doesn't imply

700
00:24:33,360 --> 00:24:35,440
that the attack itself was being missed

701
00:24:35,440 --> 00:24:37,840
um it just shows the part of the exploit

702
00:24:37,840 --> 00:24:38,480
uh

703
00:24:38,480 --> 00:24:41,600
that was being missed so all the uh

704
00:24:41,600 --> 00:24:44,000
as you can see in the uh table before

705
00:24:44,000 --> 00:24:46,400
all the attacks were caught by this

706
00:24:46,400 --> 00:24:47,039
model

707
00:24:47,039 --> 00:24:48,559
uh so the false negative right just

708
00:24:48,559 --> 00:24:50,400
shows the part of the exploit that was

709
00:24:50,400 --> 00:24:52,000
missed

710
00:24:52,000 --> 00:24:54,000
uh so the next you can see the area

711
00:24:54,000 --> 00:24:55,360
under the curve for

712
00:24:55,360 --> 00:24:58,799
um the the best model which was xt boost

713
00:24:58,799 --> 00:25:01,279
uh here you can see two plots the left

714
00:25:01,279 --> 00:25:02,880
one is for the

715
00:25:02,880 --> 00:25:06,080
um test data set and the right uh

716
00:25:06,080 --> 00:25:08,799
plot is for the holdout data set so the

717
00:25:08,799 --> 00:25:09,200
uh

718
00:25:09,200 --> 00:25:11,840
spectral v for uh the edited one the

719
00:25:11,840 --> 00:25:14,480
ghosting spectral v4

720
00:25:14,480 --> 00:25:16,320
was part of the holdout data set we

721
00:25:16,320 --> 00:25:18,080
wanted to make sure the model has

722
00:25:18,080 --> 00:25:20,880
never seen that variant before and we

723
00:25:20,880 --> 00:25:22,080
wanted to test

724
00:25:22,080 --> 00:25:24,720
whether it can still detect the newer

725
00:25:24,720 --> 00:25:26,159
variant when trained on

726
00:25:26,159 --> 00:25:29,440
other existing variants right and it did

727
00:25:29,440 --> 00:25:33,679
so um that's why um

728
00:25:33,679 --> 00:25:37,120
it's it's it's super interesting um

729
00:25:37,120 --> 00:25:39,440
so you can see in the left plot the test

730
00:25:39,440 --> 00:25:42,400
accuracy was 98.99

731
00:25:42,400 --> 00:25:46,480
percent uh adrian the curve was 98

732
00:25:46,480 --> 00:25:50,159
uh false positive rate was uh 0.04

733
00:25:50,159 --> 00:25:52,400
and false negative rate for was four

734
00:25:52,400 --> 00:25:53,279
percent

735
00:25:53,279 --> 00:25:56,799
and the f1 score was 98

736
00:25:56,799 --> 00:25:59,919
um which is good now let's see how it

737
00:25:59,919 --> 00:26:03,120
um fares in the holdout data set

738
00:26:03,120 --> 00:26:07,120
uh it fares better than what we saw

739
00:26:07,120 --> 00:26:08,720
in the test data set you can see the

740
00:26:08,720 --> 00:26:12,080
test accuracy was a 99.9 percent

741
00:26:12,080 --> 00:26:15,840
area under the curve 99.6 percent

742
00:26:15,840 --> 00:26:20,000
zero false positive rate and 0.68

743
00:26:20,000 --> 00:26:20,960
percent

744
00:26:20,960 --> 00:26:24,320
false negative rate so it cost

745
00:26:24,320 --> 00:26:26,960
it caught almost all of the all parts of

746
00:26:26,960 --> 00:26:27,360
the

747
00:26:27,360 --> 00:26:30,400
attack and a hundred percent

748
00:26:30,400 --> 00:26:33,919
um f1 score uh which is great now let's

749
00:26:33,919 --> 00:26:34,320
see

750
00:26:34,320 --> 00:26:37,039
the uh confusion matrix for uh the same

751
00:26:37,039 --> 00:26:37,520
model

752
00:26:37,520 --> 00:26:40,480
right again the left shows the

753
00:26:40,480 --> 00:26:42,640
normalized confusion matrix for

754
00:26:42,640 --> 00:26:45,760
um the test data set and the right plot

755
00:26:45,760 --> 00:26:47,200
is for the

756
00:26:47,200 --> 00:26:50,720
holdout data set which had the edited

757
00:26:50,720 --> 00:26:54,159
ghosting spectre v4 right so again

758
00:26:54,159 --> 00:26:57,600
as we saw before we need the diagonal to

759
00:26:57,600 --> 00:26:59,760
be as high as possible and the off

760
00:26:59,760 --> 00:27:01,120
diagonal squares to be as low as

761
00:27:01,120 --> 00:27:02,320
possible

762
00:27:02,320 --> 00:27:07,279
um so the left top quadrant which is the

763
00:27:07,279 --> 00:27:10,799
two negatives a 100 percent of the non

764
00:27:10,799 --> 00:27:13,360
malicious baseline data points have been

765
00:27:13,360 --> 00:27:13,919
um

766
00:27:13,919 --> 00:27:17,120
classified correctly and 96

767
00:27:17,120 --> 00:27:18,960
of malicious attack data points have

768
00:27:18,960 --> 00:27:21,520
been classified correctly which is great

769
00:27:21,520 --> 00:27:23,840
now let's see in the right plot for the

770
00:27:23,840 --> 00:27:24,640
holdout

771
00:27:24,640 --> 00:27:27,760
data set uh 100 of baseline

772
00:27:27,760 --> 00:27:29,919
non-malicious data points

773
00:27:29,919 --> 00:27:33,600
have been classified correctly and 99

774
00:27:33,600 --> 00:27:37,120
of um malicious attack data points have

775
00:27:37,120 --> 00:27:37,840
been uh

776
00:27:37,840 --> 00:27:41,200
classified correctly so it it definitely

777
00:27:41,200 --> 00:27:42,559
fairs better

778
00:27:42,559 --> 00:27:45,120
um than any other models that we have

779
00:27:45,120 --> 00:27:47,200
seen uh so far

780
00:27:47,200 --> 00:27:49,279
so next let's look at some model

781
00:27:49,279 --> 00:27:51,440
interpretation this is a topic that

782
00:27:51,440 --> 00:27:55,679
um i'm very fond of um

783
00:27:55,679 --> 00:27:57,520
so here we will see the modern

784
00:27:57,520 --> 00:27:58,960
information using

785
00:27:58,960 --> 00:28:02,000
the shop library um it's

786
00:28:02,000 --> 00:28:04,880
a shapely additive explanation it's

787
00:28:04,880 --> 00:28:05,919
based on

788
00:28:05,919 --> 00:28:09,120
shapely values uh technique used in game

789
00:28:09,120 --> 00:28:09,600
theory

790
00:28:09,600 --> 00:28:12,080
to determine how much each player in a

791
00:28:12,080 --> 00:28:13,279
collaborative game

792
00:28:13,279 --> 00:28:15,919
has contributed to its success so here

793
00:28:15,919 --> 00:28:17,600
each shaft value

794
00:28:17,600 --> 00:28:20,320
measures how much each feature in our

795
00:28:20,320 --> 00:28:21,120
model

796
00:28:21,120 --> 00:28:23,120
contributes to the prediction either

797
00:28:23,120 --> 00:28:25,360
positively or negatively

798
00:28:25,360 --> 00:28:28,480
right so here we'll see the

799
00:28:28,480 --> 00:28:30,480
feature importance for the xc boost

800
00:28:30,480 --> 00:28:32,159
model um

801
00:28:32,159 --> 00:28:35,840
eff4 um seems to be the most important

802
00:28:35,840 --> 00:28:36,559
feature

803
00:28:36,559 --> 00:28:40,120
followed by 4d e3 followed by

804
00:28:40,120 --> 00:28:42,799
3698. now how

805
00:28:42,799 --> 00:28:46,000
each feature um impacts the um target

806
00:28:46,000 --> 00:28:47,200
variable

807
00:28:47,200 --> 00:28:50,399
um let's see so uh

808
00:28:50,399 --> 00:28:52,320
the next one the the plot that you're

809
00:28:52,320 --> 00:28:53,440
going to see is

810
00:28:53,440 --> 00:28:56,320
a partial dependence plot so this shows

811
00:28:56,320 --> 00:28:57,679
the marginal effect

812
00:28:57,679 --> 00:28:59,520
that one or two variables have on the

813
00:28:59,520 --> 00:29:00,960
predicted outcome

814
00:29:00,960 --> 00:29:03,200
um whether the relationship between the

815
00:29:03,200 --> 00:29:05,039
target and the feature variable is

816
00:29:05,039 --> 00:29:05,600
linear

817
00:29:05,600 --> 00:29:08,880
monotonic or more complex so let's see

818
00:29:08,880 --> 00:29:10,559
the partial dependence plots for each of

819
00:29:10,559 --> 00:29:12,480
the three features

820
00:29:12,480 --> 00:29:14,799
separately so the first one we'll see

821
00:29:14,799 --> 00:29:16,640
for the most important feature which is

822
00:29:16,640 --> 00:29:18,559
eff4

823
00:29:18,559 --> 00:29:21,600
you can see it clearly influences

824
00:29:21,600 --> 00:29:25,120
the outcome variable negatively

825
00:29:25,120 --> 00:29:27,360
helping the model classify the baseline

826
00:29:27,360 --> 00:29:29,919
data correctly so if you see there is a

827
00:29:29,919 --> 00:29:32,399
big cluster of uh blue data points so

828
00:29:32,399 --> 00:29:33,679
the blue data points here

829
00:29:33,679 --> 00:29:36,799
denote the non-malicious baseline

830
00:29:36,799 --> 00:29:39,679
um data points and the red ones denote

831
00:29:39,679 --> 00:29:40,000
the

832
00:29:40,000 --> 00:29:43,360
attack uh data points right so there is

833
00:29:43,360 --> 00:29:44,720
a huge cluster of blue

834
00:29:44,720 --> 00:29:48,559
on top left corner and uh clearly

835
00:29:48,559 --> 00:29:52,000
higher the shaft value for eff4 uh

836
00:29:52,000 --> 00:29:54,720
there is a clear denomination where it

837
00:29:54,720 --> 00:29:55,440
classifies

838
00:29:55,440 --> 00:29:59,039
the baseline data correctly and

839
00:29:59,039 --> 00:30:02,000
in the right y-axis you can see another

840
00:30:02,000 --> 00:30:05,360
feature 3698 this shows that eff4

841
00:30:05,360 --> 00:30:08,640
interacts slightly with 3698

842
00:30:08,640 --> 00:30:11,200
which is the yellow feature uh where the

843
00:30:11,200 --> 00:30:12,080
value of

844
00:30:12,080 --> 00:30:15,679
uh the 3698 feature are between

845
00:30:15,679 --> 00:30:19,120
10k and um 30k right so there is

846
00:30:19,120 --> 00:30:20,559
definitely a small

847
00:30:20,559 --> 00:30:23,520
infraction going on there but eff4

848
00:30:23,520 --> 00:30:25,279
clearly

849
00:30:25,279 --> 00:30:28,559
with its huge and negative uh influence

850
00:30:28,559 --> 00:30:32,399
on the model um helps it to classify the

851
00:30:32,399 --> 00:30:33,679
baseline data points

852
00:30:33,679 --> 00:30:37,760
um correctly the next one

853
00:30:37,760 --> 00:30:41,039
is for uh the second feature which is 4d

854
00:30:41,039 --> 00:30:44,480
e3 the same partial dependence

855
00:30:44,480 --> 00:30:47,440
plot it clearly shows there is

856
00:30:47,440 --> 00:30:48,720
approximately a

857
00:30:48,720 --> 00:30:51,360
linear positive trend between 40 e3 and

858
00:30:51,360 --> 00:30:52,720
a target variable

859
00:30:52,720 --> 00:30:55,600
right higher the shaft values for 40 e3

860
00:30:55,600 --> 00:30:56,159
the

861
00:30:56,159 --> 00:30:59,600
uh the classification becomes uh

862
00:30:59,600 --> 00:31:03,200
one which is malicious right so um

863
00:31:03,200 --> 00:31:04,880
there is an approximate linear

864
00:31:04,880 --> 00:31:06,880
relationship there and it clearly

865
00:31:06,880 --> 00:31:08,880
doesn't react with any other feature

866
00:31:08,880 --> 00:31:12,000
as you notice there is no a y-axis on

867
00:31:12,000 --> 00:31:12,880
the right side

868
00:31:12,880 --> 00:31:14,960
meaning there is no other feature that's

869
00:31:14,960 --> 00:31:16,000
interacting with

870
00:31:16,000 --> 00:31:19,279
um this feature which is 483 which is

871
00:31:19,279 --> 00:31:19,760
great

872
00:31:19,760 --> 00:31:22,320
uh the next one is the last feature

873
00:31:22,320 --> 00:31:24,480
which is 3698

874
00:31:24,480 --> 00:31:27,120
uh this has a significant impact um it

875
00:31:27,120 --> 00:31:28,799
can be seen for the highest

876
00:31:28,799 --> 00:31:31,120
and the lowest values of the feature

877
00:31:31,120 --> 00:31:32,320
right

878
00:31:32,320 --> 00:31:34,640
if you see in the right most uh uh

879
00:31:34,640 --> 00:31:35,360
corner

880
00:31:35,360 --> 00:31:37,360
right top corner there's a cluster of

881
00:31:37,360 --> 00:31:38,720
red data points and

882
00:31:38,720 --> 00:31:41,519
in the left uh bottom corner you can see

883
00:31:41,519 --> 00:31:43,840
there's a cluster of blue data points

884
00:31:43,840 --> 00:31:46,159
so there is a clear impact for the

885
00:31:46,159 --> 00:31:47,840
highest and the lowest features

886
00:31:47,840 --> 00:31:49,970
um classified as um

887
00:31:49,970 --> 00:31:51,360
[Music]

888
00:31:51,360 --> 00:31:53,679
malicious and non-malicious respectively

889
00:31:53,679 --> 00:31:54,960
and there's also

890
00:31:54,960 --> 00:31:58,080
some interaction uh going on with the

891
00:31:58,080 --> 00:31:59,519
feature 40 e3

892
00:31:59,519 --> 00:32:02,960
as you can see in the right y axis um

893
00:32:02,960 --> 00:32:05,760
there is interaction for the values of

894
00:32:05,760 --> 00:32:06,640
40 e3

895
00:32:06,640 --> 00:32:09,840
lying in between 75 000

896
00:32:09,840 --> 00:32:12,720
and 300 000 if you see the um the

897
00:32:12,720 --> 00:32:14,640
parallel red and blue dots right

898
00:32:14,640 --> 00:32:17,200
so definitely some interaction going on

899
00:32:17,200 --> 00:32:17,840
um

900
00:32:17,840 --> 00:32:21,200
the next plot is um called

901
00:32:21,200 --> 00:32:23,440
force plot uh the first thought shows

902
00:32:23,440 --> 00:32:25,279
the interpretation of the prediction

903
00:32:25,279 --> 00:32:28,240
using a logistic regression right the

904
00:32:28,240 --> 00:32:29,760
red color denotes uh

905
00:32:29,760 --> 00:32:32,080
features that push the prediction uh

906
00:32:32,080 --> 00:32:34,159
higher to the right

907
00:32:34,159 --> 00:32:36,000
and those pushing the prediction lower

908
00:32:36,000 --> 00:32:38,000
are shown in the blue color right

909
00:32:38,000 --> 00:32:40,960
in the first plot it shows for one data

910
00:32:40,960 --> 00:32:42,080
point amongst the

911
00:32:42,080 --> 00:32:44,559
whole test data set um so this is just

912
00:32:44,559 --> 00:32:45,760
for one data point

913
00:32:45,760 --> 00:32:47,600
and in this case it was a positive one

914
00:32:47,600 --> 00:32:48,799
it was a malicious one

915
00:32:48,799 --> 00:32:52,559
right the features 40 e3 and 3698

916
00:32:52,559 --> 00:32:55,279
have the most positive impact on the

917
00:32:55,279 --> 00:32:56,640
prediction being

918
00:32:56,640 --> 00:33:00,000
malicious uh there's one and the feature

919
00:33:00,000 --> 00:33:00,880
eff4

920
00:33:00,880 --> 00:33:03,200
has the most negative impact right it's

921
00:33:03,200 --> 00:33:04,399
bringing it down

922
00:33:04,399 --> 00:33:07,840
so you rotate this plot 90 degrees

923
00:33:07,840 --> 00:33:10,000
and plot the same for all the data

924
00:33:10,000 --> 00:33:11,440
points in the test

925
00:33:11,440 --> 00:33:14,240
data set together and you get the second

926
00:33:14,240 --> 00:33:15,039
plot

927
00:33:15,039 --> 00:33:17,600
right each data point here is a vertical

928
00:33:17,600 --> 00:33:18,240
line

929
00:33:18,240 --> 00:33:21,279
it clearly shows feature eff4 has a

930
00:33:21,279 --> 00:33:22,399
negative

931
00:33:22,399 --> 00:33:24,960
effect on the outcome variable and the

932
00:33:24,960 --> 00:33:27,039
other two features push for the outcome

933
00:33:27,039 --> 00:33:29,600
uh to be one you know that is malicious

934
00:33:29,600 --> 00:33:31,840
uh this intuitively retraces the

935
00:33:31,840 --> 00:33:33,760
uh feature importance graph where uh

936
00:33:33,760 --> 00:33:36,240
eff4 is the most important feature

937
00:33:36,240 --> 00:33:39,440
um responsible for making sure

938
00:33:39,440 --> 00:33:41,679
the baseline non-malicious programs are

939
00:33:41,679 --> 00:33:43,519
classified uh correctly

940
00:33:43,519 --> 00:33:45,120
and the other two features play their

941
00:33:45,120 --> 00:33:46,559
secondary roles to push the

942
00:33:46,559 --> 00:33:48,799
classification towards one you know for

943
00:33:48,799 --> 00:33:49,120
the

944
00:33:49,120 --> 00:33:52,320
malicious data points um

945
00:33:52,320 --> 00:33:56,480
here you can see the uh same force plot

946
00:33:56,480 --> 00:33:59,840
uh for each feature um

947
00:33:59,840 --> 00:34:01,200
being filtered out right here's the

948
00:34:01,200 --> 00:34:04,559
force plot filter just showing eff4

949
00:34:04,559 --> 00:34:06,799
clearly the blue dominates right showing

950
00:34:06,799 --> 00:34:07,840
its negative impact

951
00:34:07,840 --> 00:34:10,560
uh negative effect on the um outcome

952
00:34:10,560 --> 00:34:11,679
variable

953
00:34:11,679 --> 00:34:14,960
uh the next one is the uh

954
00:34:14,960 --> 00:34:18,000
force plot for 40 e3 uh filtered right

955
00:34:18,000 --> 00:34:19,040
clearly

956
00:34:19,040 --> 00:34:21,199
it has a positive impact and helps the

957
00:34:21,199 --> 00:34:23,440
model push across the line

958
00:34:23,440 --> 00:34:25,839
to classify the malicious data points uh

959
00:34:25,839 --> 00:34:27,599
correctly

960
00:34:27,599 --> 00:34:30,159
now let's see the uh force plot filter

961
00:34:30,159 --> 00:34:31,239
just for feature

962
00:34:31,239 --> 00:34:35,119
3698 this again has a positive impact

963
00:34:35,119 --> 00:34:38,000
on the target variable though not as

964
00:34:38,000 --> 00:34:39,599
strong as 483

965
00:34:39,599 --> 00:34:41,520
but healthy model push across the line

966
00:34:41,520 --> 00:34:43,119
to classify the

967
00:34:43,119 --> 00:34:47,200
malicious data points correctly

968
00:34:47,520 --> 00:34:49,359
thanks rooney so at this point we've

969
00:34:49,359 --> 00:34:51,040
seen that we can detect

970
00:34:51,040 --> 00:34:53,040
specter and variants really well using

971
00:34:53,040 --> 00:34:54,879
undocumented counters but we wanted to

972
00:34:54,879 --> 00:34:56,000
see if we could detect

973
00:34:56,000 --> 00:34:59,040
other exploits specifically rob

974
00:34:59,040 --> 00:35:00,720
there's been prior work done on

975
00:35:00,720 --> 00:35:02,480
detecting rob with

976
00:35:02,480 --> 00:35:04,960
hardware performance counters or other

977
00:35:04,960 --> 00:35:06,720
hardware performance monitoring

978
00:35:06,720 --> 00:35:09,040
things like the last branch record and

979
00:35:09,040 --> 00:35:11,040
intel processor trace

980
00:35:11,040 --> 00:35:14,240
um the main thing with lbr and pt

981
00:35:14,240 --> 00:35:16,320
is that there's a lot of data right it's

982
00:35:16,320 --> 00:35:18,240
measuring everywhere that the program is

983
00:35:18,240 --> 00:35:19,200
running

984
00:35:19,200 --> 00:35:22,160
and so you just end up with a lot of

985
00:35:22,160 --> 00:35:23,760
overhead and actually trying to run

986
00:35:23,760 --> 00:35:26,480
these detections

987
00:35:26,480 --> 00:35:29,359
in theory rob should also have a signal

988
00:35:29,359 --> 00:35:31,280
in branch miss bricks

989
00:35:31,280 --> 00:35:33,920
right rock chains make the return stack

990
00:35:33,920 --> 00:35:34,800
buffer and the

991
00:35:34,800 --> 00:35:36,800
processor basically useless because

992
00:35:36,800 --> 00:35:38,480
you're returning all over the place to

993
00:35:38,480 --> 00:35:41,359
places where you're not coming from

994
00:35:41,359 --> 00:35:43,359
problem here though is that rock chains

995
00:35:43,359 --> 00:35:44,560
are really short

996
00:35:44,560 --> 00:35:46,560
right you're looking at kind of 50 to

997
00:35:46,560 --> 00:35:48,480
100 instructions at most you definitely

998
00:35:48,480 --> 00:35:50,079
could have longer one but

999
00:35:50,079 --> 00:35:52,560
there's often not a need for it and so

1000
00:35:52,560 --> 00:35:53,520
you're dealing with

1001
00:35:53,520 --> 00:35:56,000
50 to 100 branch missed predicts which

1002
00:35:56,000 --> 00:35:57,440
in the grand scheme things just really

1003
00:35:57,440 --> 00:35:58,079
isn't that

1004
00:35:58,079 --> 00:36:02,079
much so we wanted to take a crack at it

1005
00:36:02,079 --> 00:36:02,720
though

1006
00:36:02,720 --> 00:36:06,560
so we ran a rob exploit that i developed

1007
00:36:06,560 --> 00:36:09,680
about a hundred or

1008
00:36:10,079 --> 00:36:12,000
so we ran a rob exploit that i developed

1009
00:36:12,000 --> 00:36:13,359
a hundred times uh

1010
00:36:13,359 --> 00:36:16,240
per cycle to maximize whatever signal we

1011
00:36:16,240 --> 00:36:16,800
could find

1012
00:36:16,800 --> 00:36:18,480
which obviously means that the data from

1013
00:36:18,480 --> 00:36:20,000
this is not really productionizable it

1014
00:36:20,000 --> 00:36:20,400
just

1015
00:36:20,400 --> 00:36:22,720
means we're just looking to see if there

1016
00:36:22,720 --> 00:36:24,079
is anything to be there

1017
00:36:24,079 --> 00:36:26,400
or to be seen there in the first place

1018
00:36:26,400 --> 00:36:28,720
uh we also added a new baseline program

1019
00:36:28,720 --> 00:36:30,560
which did exactly what the rock chain

1020
00:36:30,560 --> 00:36:32,240
did but without propping so same

1021
00:36:32,240 --> 00:36:33,040
syscalls

1022
00:36:33,040 --> 00:36:35,920
same memory creation same snack pivoting

1023
00:36:35,920 --> 00:36:37,119
all that

1024
00:36:37,119 --> 00:36:38,240
this is just to make sure that we're

1025
00:36:38,240 --> 00:36:39,359
actually picking up the rock chain

1026
00:36:39,359 --> 00:36:40,320
itself

1027
00:36:40,320 --> 00:36:43,520
and not side effects of whatever the

1028
00:36:43,520 --> 00:36:45,920
rock chain is doing

1029
00:36:45,920 --> 00:36:48,240
and crazy enough after running all this

1030
00:36:48,240 --> 00:36:50,000
and crunching the numbers

1031
00:36:50,000 --> 00:36:53,200
the exact same counters work for rob

1032
00:36:53,200 --> 00:36:56,560
as did for spectre vector variants

1033
00:36:56,560 --> 00:36:58,240
and this absolutely blew my mind the

1034
00:36:58,240 --> 00:36:59,839
first time that we

1035
00:36:59,839 --> 00:37:02,880
got the data back for this because

1036
00:37:02,880 --> 00:37:05,280
this just doesn't make any sense and so

1037
00:37:05,280 --> 00:37:06,560
i spent a good

1038
00:37:06,560 --> 00:37:08,160
at least a good few hours trying to

1039
00:37:08,160 --> 00:37:09,839
figure out like how did we mess up there

1040
00:37:09,839 --> 00:37:10,960
must be something wrong here

1041
00:37:10,960 --> 00:37:14,240
what did we do um but no it turns out

1042
00:37:14,240 --> 00:37:16,800
as you can see we're we're doing pretty

1043
00:37:16,800 --> 00:37:17,359
well

1044
00:37:17,359 --> 00:37:19,040
it's definitely not as good as our

1045
00:37:19,040 --> 00:37:20,720
spectre detections were but

1046
00:37:20,720 --> 00:37:22,480
it's better than the coin toss much

1047
00:37:22,480 --> 00:37:24,000
better than the coin toss

1048
00:37:24,000 --> 00:37:26,079
um as you can see from the confusion

1049
00:37:26,079 --> 00:37:28,400
matrix the main problem that we have

1050
00:37:28,400 --> 00:37:32,240
isn't in false positiving

1051
00:37:32,240 --> 00:37:34,720
on normal programs it's that we don't

1052
00:37:34,720 --> 00:37:36,720
always pick up the rock chain

1053
00:37:36,720 --> 00:37:39,839
which again leads back to what we've

1054
00:37:39,839 --> 00:37:40,720
seen before with

1055
00:37:40,720 --> 00:37:42,880
using the branch predictor and branch

1056
00:37:42,880 --> 00:37:43,839
misses

1057
00:37:43,839 --> 00:37:46,400
but using these undocumented counters

1058
00:37:46,400 --> 00:37:48,000
which again seem to not have anything to

1059
00:37:48,000 --> 00:37:49,280
do with the branch predictor because

1060
00:37:49,280 --> 00:37:50,320
they also picked up

1061
00:37:50,320 --> 00:37:53,359
spectre um we're still getting

1062
00:37:53,359 --> 00:37:57,760
77 malicious classifications correct

1063
00:37:57,760 --> 00:38:00,640
so there's a lot more research to be

1064
00:38:00,640 --> 00:38:01,040
done

1065
00:38:01,040 --> 00:38:04,079
in this bit because again this just does

1066
00:38:04,079 --> 00:38:04,720
not make

1067
00:38:04,720 --> 00:38:07,680
much sense but nonetheless it's how it

1068
00:38:07,680 --> 00:38:09,119
is

1069
00:38:09,119 --> 00:38:11,760
so now that we know all this now that

1070
00:38:11,760 --> 00:38:12,400
we've covered

1071
00:38:12,400 --> 00:38:14,800
basically everything else um i want to

1072
00:38:14,800 --> 00:38:15,920
spend a little bit of

1073
00:38:15,920 --> 00:38:18,240
time talking about interpreting these

1074
00:38:18,240 --> 00:38:19,040
results

1075
00:38:19,040 --> 00:38:22,320
the little that we know about it so

1076
00:38:22,320 --> 00:38:25,520
for spectre there's a single support

1077
00:38:25,520 --> 00:38:26,000
file

1078
00:38:26,000 --> 00:38:29,440
inside of intel vtune which names

1079
00:38:29,440 --> 00:38:32,480
the ef event id has coarse new response

1080
00:38:32,480 --> 00:38:34,880
with the helpful description of tvd

1081
00:38:34,880 --> 00:38:38,560
um thanks intel um supposedly though

1082
00:38:38,560 --> 00:38:40,320
this is only for

1083
00:38:40,320 --> 00:38:43,520
skylake x and cascade lake so much newer

1084
00:38:43,520 --> 00:38:44,800
microarchitectures than what we're

1085
00:38:44,800 --> 00:38:46,079
testing on

1086
00:38:46,079 --> 00:38:48,960
however it does make a little bit of

1087
00:38:48,960 --> 00:38:50,160
sense

1088
00:38:50,160 --> 00:38:54,000
the hypothesis currently is that this ef

1089
00:38:54,000 --> 00:38:57,520
counter is detecting it's detecting the

1090
00:38:57,520 --> 00:38:58,640
cl flush

1091
00:38:58,640 --> 00:39:01,280
somehow if this is actually horse nuke

1092
00:39:01,280 --> 00:39:02,560
response it could be

1093
00:39:02,560 --> 00:39:04,800
from other cores basically acknowledging

1094
00:39:04,800 --> 00:39:05,760
the cl flush

1095
00:39:05,760 --> 00:39:07,119
and responding to the core where the

1096
00:39:07,119 --> 00:39:09,119
seal flush originated

1097
00:39:09,119 --> 00:39:11,119
or it could be something else entirely

1098
00:39:11,119 --> 00:39:12,160
that's actually just completely

1099
00:39:12,160 --> 00:39:13,680
undocumented but it does seem to have

1100
00:39:13,680 --> 00:39:15,040
some correlation with

1101
00:39:15,040 --> 00:39:18,079
cl flush um the main reason we think

1102
00:39:18,079 --> 00:39:18,480
this

1103
00:39:18,480 --> 00:39:21,119
is that the counters actually showed

1104
00:39:21,119 --> 00:39:21,599
that

1105
00:39:21,599 --> 00:39:23,680
the sample program was malicious that

1106
00:39:23,680 --> 00:39:25,119
the spectre of concept

1107
00:39:25,119 --> 00:39:27,839
was malicious even when the actual like

1108
00:39:27,839 --> 00:39:29,920
flush and reload exfiltration bit was

1109
00:39:29,920 --> 00:39:30,800
broken

1110
00:39:30,800 --> 00:39:32,640
so we are correctly cl flushing things

1111
00:39:32,640 --> 00:39:34,640
we just weren't retrieving data

1112
00:39:34,640 --> 00:39:36,160
and this was still classified as

1113
00:39:36,160 --> 00:39:37,680
malicious

1114
00:39:37,680 --> 00:39:40,720
so that's definitely an encouraging

1115
00:39:40,720 --> 00:39:42,800
sign that we're not just picking up on

1116
00:39:42,800 --> 00:39:45,040
some other counter that's measuring

1117
00:39:45,040 --> 00:39:47,119
cash misses this definitely seems to be

1118
00:39:47,119 --> 00:39:50,720
something new and better

1119
00:39:50,880 --> 00:39:53,920
for rob very unsure

1120
00:39:53,920 --> 00:39:55,760
as we saw before it's the same counter

1121
00:39:55,760 --> 00:39:57,680
so we know that there can't be

1122
00:39:57,680 --> 00:40:00,000
too many other options for what the ef

1123
00:40:00,000 --> 00:40:01,280
counter does at least

1124
00:40:01,280 --> 00:40:03,040
it definitely seems related to cl

1125
00:40:03,040 --> 00:40:05,440
flushing so continuing on the idea that

1126
00:40:05,440 --> 00:40:06,240
it has to do

1127
00:40:06,240 --> 00:40:10,480
with uh cache flushing and cash

1128
00:40:10,480 --> 00:40:14,079
less level cash management stuff um

1129
00:40:14,079 --> 00:40:15,680
a couple theories this could be

1130
00:40:15,680 --> 00:40:17,760
detecting the embedded stack pivot

1131
00:40:17,760 --> 00:40:21,280
in the rop sample uh specifically

1132
00:40:21,280 --> 00:40:23,200
i don't know this for effect but if the

1133
00:40:23,200 --> 00:40:25,119
processor keeps special store buffers

1134
00:40:25,119 --> 00:40:27,359
around for the stack since it's used

1135
00:40:27,359 --> 00:40:30,400
so commonly uh if rsp changes perhaps it

1136
00:40:30,400 --> 00:40:32,640
has to invalidate and flush all of those

1137
00:40:32,640 --> 00:40:35,680
which could cause a flood of effectively

1138
00:40:35,680 --> 00:40:37,280
cl flushes

1139
00:40:37,280 --> 00:40:40,640
um it could also be detecting the return

1140
00:40:40,640 --> 00:40:41,920
stack buffer mispredicts

1141
00:40:41,920 --> 00:40:45,359
in kind of an odd way uh theory

1142
00:40:45,359 --> 00:40:48,560
is if the caches are preemptively

1143
00:40:48,560 --> 00:40:49,200
loading

1144
00:40:49,200 --> 00:40:50,880
based on what's in the return stack

1145
00:40:50,880 --> 00:40:52,720
buffer then

1146
00:40:52,720 --> 00:40:55,359
you'll cache miss every time right

1147
00:40:55,359 --> 00:40:56,560
because your return stack buffer is

1148
00:40:56,560 --> 00:40:58,079
saying all right load this

1149
00:40:58,079 --> 00:40:59,839
cache loads that and then suddenly

1150
00:40:59,839 --> 00:41:00,960
you're not returning there you're

1151
00:41:00,960 --> 00:41:02,079
returning where else the route

1152
00:41:02,079 --> 00:41:04,839
or wherever else the rop change is going

1153
00:41:04,839 --> 00:41:07,599
um very unsure about these but

1154
00:41:07,599 --> 00:41:11,599
some initial ideas were very unsure

1155
00:41:11,599 --> 00:41:14,560
so future work

1156
00:41:15,040 --> 00:41:18,240
the biggest thing here is in my mind

1157
00:41:18,240 --> 00:41:20,160
generalizing and automating data

1158
00:41:20,160 --> 00:41:21,760
collection you have scripts that will

1159
00:41:21,760 --> 00:41:23,200
run through all the perf counters for

1160
00:41:23,200 --> 00:41:25,040
whatever program you want but we've only

1161
00:41:25,040 --> 00:41:27,200
done it again on two micro architectures

1162
00:41:27,200 --> 00:41:30,319
so extending all that to be done on all

1163
00:41:30,319 --> 00:41:31,520
the micro architectures that you could

1164
00:41:31,520 --> 00:41:33,520
reasonably care about nowadays

1165
00:41:33,520 --> 00:41:35,520
and this is actually made somewhat

1166
00:41:35,520 --> 00:41:37,200
easier by the fact that the cloud is so

1167
00:41:37,200 --> 00:41:38,160
prevalent now

1168
00:41:38,160 --> 00:41:40,880
you know in theory you could just buy a

1169
00:41:40,880 --> 00:41:41,599
instance

1170
00:41:41,599 --> 00:41:43,920
out for each micro architecture for a

1171
00:41:43,920 --> 00:41:45,200
couple hours run the script

1172
00:41:45,200 --> 00:41:46,880
get your data and you're done we just

1173
00:41:46,880 --> 00:41:48,800
haven't done it yet

1174
00:41:48,800 --> 00:41:52,560
um there's other also pmus to explore

1175
00:41:52,560 --> 00:41:54,640
specifically the uncore counters on

1176
00:41:54,640 --> 00:41:56,640
intel chips could be very promising

1177
00:41:56,640 --> 00:41:57,760
because they also deal with

1178
00:41:57,760 --> 00:42:00,160
cash coherency stuff i have less level

1179
00:42:00,160 --> 00:42:02,160
cash stuff um

1180
00:42:02,160 --> 00:42:04,640
there's also amd and he is a player

1181
00:42:04,640 --> 00:42:06,400
again in the x86 space

1182
00:42:06,400 --> 00:42:09,760
and presumably has a similar pipeline

1183
00:42:09,760 --> 00:42:11,280
architecture didn't tell i don't know

1184
00:42:11,280 --> 00:42:12,079
for sure but

1185
00:42:12,079 --> 00:42:14,720
i would assume so and so they'll also

1186
00:42:14,720 --> 00:42:15,440
have

1187
00:42:15,440 --> 00:42:17,359
probably similar counters whether they

1188
00:42:17,359 --> 00:42:18,880
actually expose ones that aren't

1189
00:42:18,880 --> 00:42:19,760
documented

1190
00:42:19,760 --> 00:42:22,000
i'm not sure of but there's research to

1191
00:42:22,000 --> 00:42:23,359
be done there

1192
00:42:23,359 --> 00:42:25,520
and then of course there's also arm yet

1193
00:42:25,520 --> 00:42:26,880
another kind of

1194
00:42:26,880 --> 00:42:30,000
player that's come up and coming on the

1195
00:42:30,000 --> 00:42:30,880
field

1196
00:42:30,880 --> 00:42:34,079
um with arm in particular there's

1197
00:42:34,079 --> 00:42:35,760
potentially some vendor specific

1198
00:42:35,760 --> 00:42:37,680
internals which could be interesting to

1199
00:42:37,680 --> 00:42:38,800
poke at

1200
00:42:38,800 --> 00:42:42,160
uh again haven't done any of this yet so

1201
00:42:42,160 --> 00:42:44,640
they could be very boring but there's

1202
00:42:44,640 --> 00:42:46,880
potential there

1203
00:42:46,880 --> 00:42:49,200
so a couple closing remarks just to

1204
00:42:49,200 --> 00:42:51,040
finish everything out

1205
00:42:51,040 --> 00:42:52,640
as i've said a couple times now due to

1206
00:42:52,640 --> 00:42:53,599
the nature of all this being

1207
00:42:53,599 --> 00:42:55,359
undocumented we really can't know for

1208
00:42:55,359 --> 00:42:55,680
sure

1209
00:42:55,680 --> 00:42:58,480
what's going on here um unless until

1210
00:42:58,480 --> 00:42:59,920
releases more documentation

1211
00:42:59,920 --> 00:43:03,119
you're listening it'd be great um that

1212
00:43:03,119 --> 00:43:04,000
said there are definitely other

1213
00:43:04,000 --> 00:43:05,760
experiments that we could do to try and

1214
00:43:05,760 --> 00:43:07,520
determine what these counters are

1215
00:43:07,520 --> 00:43:09,359
counting and so if you have any ideas

1216
00:43:09,359 --> 00:43:11,119
for these let us know

1217
00:43:11,119 --> 00:43:12,800
run on yourself and tag us in a post or

1218
00:43:12,800 --> 00:43:15,359
something uh we're all very curious now

1219
00:43:15,359 --> 00:43:17,119
what's going on with this

1220
00:43:17,119 --> 00:43:20,720
so our contact info is on the first few

1221
00:43:20,720 --> 00:43:23,040
slides again if you want to get in touch

1222
00:43:23,040 --> 00:43:24,319
otherwise i think we're going to

1223
00:43:24,319 --> 00:43:26,400
transition into a q a now so thanks

1224
00:43:26,400 --> 00:43:28,800
everyone

1225
00:43:29,760 --> 00:43:31,280
all right hey everyone uh thanks for

1226
00:43:31,280 --> 00:43:32,800
watching and thanks for the questions in

1227
00:43:32,800 --> 00:43:33,440
chat

1228
00:43:33,440 --> 00:43:35,920
um we basically don't have any time to

1229
00:43:35,920 --> 00:43:37,760
actually respond to stuff on camera

1230
00:43:37,760 --> 00:43:38,800
unfortunately

1231
00:43:38,800 --> 00:43:41,760
so feel free to again contact us um i'm

1232
00:43:41,760 --> 00:43:44,640
goest encapsulate.com or at tlsims on

1233
00:43:44,640 --> 00:43:45,680
twitter

1234
00:43:45,680 --> 00:43:48,880
uh yeah and harini at capslick.com or uh

1235
00:43:48,880 --> 00:43:51,920
jarvis twitter and uh

1236
00:43:51,920 --> 00:43:53,359
yeah we're happy to take your questions

1237
00:43:53,359 --> 00:43:54,800
talk about future research any of that

1238
00:43:54,800 --> 00:43:55,760
kind of stuff

1239
00:43:55,760 --> 00:43:58,880
um and i think with that i think we're

1240
00:43:58,880 --> 00:43:59,599
done

1241
00:43:59,599 --> 00:44:03,920
yeah thank you all thank you

