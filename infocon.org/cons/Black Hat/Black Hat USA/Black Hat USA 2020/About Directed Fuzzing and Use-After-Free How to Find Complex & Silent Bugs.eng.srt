1
00:00:04,220 --> 00:00:14,678
[Music]

2
00:00:16,880 --> 00:00:17,760
hi everyone

3
00:00:17,760 --> 00:00:19,600
this is sebastian barda and mandurgen

4
00:00:19,600 --> 00:00:21,760
bien from several east and university

5
00:00:21,760 --> 00:00:22,640
grenoble help

6
00:00:22,640 --> 00:00:24,640
france we are going to talk to you today

7
00:00:24,640 --> 00:00:26,480
about directed fuzzing and use after

8
00:00:26,480 --> 00:00:27,199
free bugs

9
00:00:27,199 --> 00:00:28,880
this is joint work with our colleagues

10
00:00:28,880 --> 00:00:30,960
richard bonichon mature male and roland

11
00:00:30,960 --> 00:00:33,120
gross

12
00:00:33,120 --> 00:00:35,120
so what's the talk about fuzzing has

13
00:00:35,120 --> 00:00:36,880
been proven to be great for finding

14
00:00:36,880 --> 00:00:38,879
vulnerabilities in the world

15
00:00:38,879 --> 00:00:41,120
today we will focus on directed fuzzing

16
00:00:41,120 --> 00:00:42,800
a slightly different setting where the

17
00:00:42,800 --> 00:00:45,280
goal is to reach a specific cut target

18
00:00:45,280 --> 00:00:47,600
with application for example to patreon

19
00:00:47,600 --> 00:00:49,280
testing

20
00:00:49,280 --> 00:00:51,120
the problem we want to address is that

21
00:00:51,120 --> 00:00:53,039
current fuzzing techniques are very bad

22
00:00:53,039 --> 00:00:54,239
for some class of complex

23
00:00:54,239 --> 00:00:55,360
vulnerabilities

24
00:00:55,360 --> 00:00:57,920
here use after three unfortunately the

25
00:00:57,920 --> 00:01:00,000
scientific event can be critical

26
00:01:00,000 --> 00:01:02,000
so we propose a directed phasing

27
00:01:02,000 --> 00:01:03,760
approach tailored to use after three

28
00:01:03,760 --> 00:01:04,559
bugs

29
00:01:04,559 --> 00:01:06,400
and we'll show some application to patch

30
00:01:06,400 --> 00:01:09,360
oriented testing

31
00:01:10,479 --> 00:01:13,680
so first of all what is a use after free

32
00:01:13,680 --> 00:01:16,400
it's an error that occurs when some

33
00:01:16,400 --> 00:01:17,119
memory

34
00:01:17,119 --> 00:01:20,159
has been allocated then freed

35
00:01:20,159 --> 00:01:22,960
then it is still accessed after its

36
00:01:22,960 --> 00:01:24,080
lifetime

37
00:01:24,080 --> 00:01:27,280
for a dangling pointer

38
00:01:27,280 --> 00:01:29,200
so there are some three points here

39
00:01:29,200 --> 00:01:30,400
first it is critical

40
00:01:30,400 --> 00:01:32,079
it can lead to data corruption

41
00:01:32,079 --> 00:01:34,240
information leak the need of service

42
00:01:34,240 --> 00:01:34,720
attack

43
00:01:34,720 --> 00:01:38,000
and so on uh second there are more and

44
00:01:38,000 --> 00:01:38,400
more

45
00:01:38,400 --> 00:01:41,439
of them in the wild maybe a reason is

46
00:01:41,439 --> 00:01:41,759
that

47
00:01:41,759 --> 00:01:43,600
currently buffer overflow and so on are

48
00:01:43,600 --> 00:01:45,680
well protected and well mitigated

49
00:01:45,680 --> 00:01:48,159
and many tools exist to try to remove

50
00:01:48,159 --> 00:01:49,360
them in advance

51
00:01:49,360 --> 00:01:51,200
while use after three are still hard to

52
00:01:51,200 --> 00:01:53,920
mitigate on how to find

53
00:01:53,920 --> 00:01:56,320
last point it's quite a complex

54
00:01:56,320 --> 00:01:58,320
vulnerability actually

55
00:01:58,320 --> 00:02:00,240
if you think of a standard buffer

56
00:02:00,240 --> 00:02:01,439
overflow

57
00:02:01,439 --> 00:02:04,799
you just need at some point to to go

58
00:02:04,799 --> 00:02:07,119
out of bones where in that case you have

59
00:02:07,119 --> 00:02:09,440
some kind of finite state automaton like

60
00:02:09,440 --> 00:02:12,959
we see in the in the right corner

61
00:02:12,959 --> 00:02:15,200
that you must fulfill before activating

62
00:02:15,200 --> 00:02:18,079
the issue

63
00:02:18,319 --> 00:02:21,520
so as a teaser here is a small example

64
00:02:21,520 --> 00:02:23,200
you don't really need to know what this

65
00:02:23,200 --> 00:02:25,360
cuts time it does exactly

66
00:02:25,360 --> 00:02:27,040
the point is there is a use after

67
00:02:27,040 --> 00:02:28,640
freeing it if you go through

68
00:02:28,640 --> 00:02:31,920
the allocation then the free and then

69
00:02:31,920 --> 00:02:34,480
the use

70
00:02:34,800 --> 00:02:37,200
now if you take i fel on this small code

71
00:02:37,200 --> 00:02:38,560
actually actual qmu

72
00:02:38,560 --> 00:02:41,280
to go on binary within six hour it

73
00:02:41,280 --> 00:02:42,640
cannot find it

74
00:02:42,640 --> 00:02:45,599
if you take ifl go or direct it further

75
00:02:45,599 --> 00:02:47,200
which will work on source

76
00:02:47,200 --> 00:02:51,440
and with an adequate trust target

77
00:02:51,440 --> 00:02:53,680
again within six hours it will not find

78
00:02:53,680 --> 00:02:55,280
the use after free bug

79
00:02:55,280 --> 00:02:58,319
with our technique called ufos within 20

80
00:02:58,319 --> 00:03:00,239
minutes we are indeed able to find this

81
00:03:00,239 --> 00:03:03,360
use after free bug

82
00:03:03,760 --> 00:03:07,840
so first of all a bit of context

83
00:03:07,920 --> 00:03:10,319
so as most of you probably know fuzzing

84
00:03:10,319 --> 00:03:12,319
is very popular for finding code level

85
00:03:12,319 --> 00:03:13,040
flows

86
00:03:13,040 --> 00:03:15,440
it has found many many many bugs it is

87
00:03:15,440 --> 00:03:17,599
used by many security people and

88
00:03:17,599 --> 00:03:19,040
security teams

89
00:03:19,040 --> 00:03:21,120
and many big companies are involved

90
00:03:21,120 --> 00:03:22,720
microsoft google

91
00:03:22,720 --> 00:03:26,480
apple whatever you want mostly

92
00:03:27,280 --> 00:03:30,799
actually fuzzing's come from quite a

93
00:03:30,799 --> 00:03:34,319
quite long time now first it means

94
00:03:34,319 --> 00:03:36,879
mostly random testing which is called

95
00:03:36,879 --> 00:03:38,560
now black box fuzzing

96
00:03:38,560 --> 00:03:41,440
and it consists in generating a massive

97
00:03:41,440 --> 00:03:42,400
amount

98
00:03:42,400 --> 00:03:45,200
of input data feed them to the program

99
00:03:45,200 --> 00:03:46,080
and the test

100
00:03:46,080 --> 00:03:48,799
and see if it's crash or not okay it was

101
00:03:48,799 --> 00:03:49,920
very simple but

102
00:03:49,920 --> 00:03:53,120
it turns out to be very effective but

103
00:03:53,120 --> 00:03:54,080
along the years

104
00:03:54,080 --> 00:03:57,599
it had made a huge progress so now there

105
00:03:57,599 --> 00:03:59,280
are three shades of fuzzing

106
00:03:59,280 --> 00:04:00,879
so there is still this black box

107
00:04:00,879 --> 00:04:02,879
approach to fuzzing

108
00:04:02,879 --> 00:04:04,720
there is also something called white box

109
00:04:04,720 --> 00:04:06,480
fuzzing which use

110
00:04:06,480 --> 00:04:08,799
lots of advanced program analysis

111
00:04:08,799 --> 00:04:10,400
techniques to find bugs but

112
00:04:10,400 --> 00:04:13,519
we just problem with scalability and

113
00:04:13,519 --> 00:04:15,840
there is grey box fuzzing which tried to

114
00:04:15,840 --> 00:04:18,798
take the best of both sides scalability

115
00:04:18,798 --> 00:04:20,478
from black box approach

116
00:04:20,478 --> 00:04:23,680
and cleverness from white box approach

117
00:04:23,680 --> 00:04:26,400
and actually ifel was probably the first

118
00:04:26,400 --> 00:04:28,639
gray box further it was a very

119
00:04:28,639 --> 00:04:30,880
pioneering and inspiring work

120
00:04:30,880 --> 00:04:33,759
and it has been very very successful and

121
00:04:33,759 --> 00:04:35,120
now this is a very

122
00:04:35,120 --> 00:04:38,479
active research area with more and more

123
00:04:38,479 --> 00:04:40,560
new ideas to

124
00:04:40,560 --> 00:04:43,280
to move the sweet spot and add more and

125
00:04:43,280 --> 00:04:43,840
more

126
00:04:43,840 --> 00:04:46,639
intelligence in the tool without any

127
00:04:46,639 --> 00:04:49,919
scalability penalty

128
00:04:50,560 --> 00:04:53,600
so from uh i'll give you just a

129
00:04:53,600 --> 00:04:56,320
little test of what fuzzing is so

130
00:04:56,320 --> 00:04:59,199
basically you have a set of input

131
00:04:59,199 --> 00:05:02,160
you need a way some heuristic to choose

132
00:05:02,160 --> 00:05:04,160
a good input to select which are the

133
00:05:04,160 --> 00:05:05,120
best one

134
00:05:05,120 --> 00:05:08,160
so for example those input which

135
00:05:08,160 --> 00:05:10,000
which activate new part of the code for

136
00:05:10,000 --> 00:05:12,000
example then you will

137
00:05:12,000 --> 00:05:14,400
create a lots of new input from them

138
00:05:14,400 --> 00:05:16,720
from mutation so inputs which

139
00:05:16,720 --> 00:05:19,280
looks pretty similar to the initial good

140
00:05:19,280 --> 00:05:20,080
input but

141
00:05:20,080 --> 00:05:23,280
a bit different and then you will simply

142
00:05:23,280 --> 00:05:24,160
run them all

143
00:05:24,160 --> 00:05:27,680
against the code under test look or

144
00:05:27,680 --> 00:05:28,240
compute

145
00:05:28,240 --> 00:05:30,479
a look observe their behavior compute

146
00:05:30,479 --> 00:05:31,600
their score

147
00:05:31,600 --> 00:05:34,240
take the best again and then mutate them

148
00:05:34,240 --> 00:05:36,000
and so on and so on in some kind of

149
00:05:36,000 --> 00:05:38,800
evolutionary process so here the big

150
00:05:38,800 --> 00:05:39,680
difference between

151
00:05:39,680 --> 00:05:42,000
black box fuzzing and grey box fuzzing

152
00:05:42,000 --> 00:05:42,800
is that

153
00:05:42,800 --> 00:05:45,280
in black box you cannot observe a lot

154
00:05:45,280 --> 00:05:46,560
especially

155
00:05:46,560 --> 00:05:49,039
mostly on level output in grey box you

156
00:05:49,039 --> 00:05:50,720
can observe typically coverage

157
00:05:50,720 --> 00:05:54,080
information the fragment

158
00:05:54,960 --> 00:05:58,000
obviously fuzzing is not a silver bullet

159
00:05:58,000 --> 00:06:00,160
so it can have a hard time

160
00:06:00,160 --> 00:06:03,680
covering very complex condition or going

161
00:06:03,680 --> 00:06:05,440
very deep inside the code

162
00:06:05,440 --> 00:06:08,080
okay it has our time with complex bugs

163
00:06:08,080 --> 00:06:09,840
like use after three we will discuss

164
00:06:09,840 --> 00:06:10,960
that after

165
00:06:10,960 --> 00:06:12,400
and it does also it might also have a

166
00:06:12,400 --> 00:06:14,639
hard time to to do some target oriented

167
00:06:14,639 --> 00:06:16,080
testing where the goal is to

168
00:06:16,080 --> 00:06:19,680
cover some specific part of the code

169
00:06:19,680 --> 00:06:22,160
so regarding this last point recently a

170
00:06:22,160 --> 00:06:24,319
new flavor of fuzzing as a match

171
00:06:24,319 --> 00:06:26,720
directed fuzzing that precisely aims at

172
00:06:26,720 --> 00:06:28,160
taking this problem

173
00:06:28,160 --> 00:06:30,639
so you take an additional input which is

174
00:06:30,639 --> 00:06:31,440
a target

175
00:06:31,440 --> 00:06:33,840
level trace or cut trace or code

176
00:06:33,840 --> 00:06:35,120
location

177
00:06:35,120 --> 00:06:37,520
and what you want is to find an input

178
00:06:37,520 --> 00:06:39,360
which will cover this trace

179
00:06:39,360 --> 00:06:41,680
so ever cover the trace or reach for

180
00:06:41,680 --> 00:06:43,520
location

181
00:06:43,520 --> 00:06:45,280
so it has interesting application in

182
00:06:45,280 --> 00:06:48,000
security such as bug reproduction

183
00:06:48,000 --> 00:06:50,880
so typically you have some partial

184
00:06:50,880 --> 00:06:52,800
information report on a bug but you

185
00:06:52,800 --> 00:06:53,680
don't have

186
00:06:53,680 --> 00:06:56,800
the input for triggering input so

187
00:06:56,800 --> 00:06:58,720
with directed fuzzing you can try to

188
00:06:58,720 --> 00:07:00,880
find the triggering input for this

189
00:07:00,880 --> 00:07:04,000
bug report patch oriented testing where

190
00:07:04,000 --> 00:07:06,080
you will try to direct your testing

191
00:07:06,080 --> 00:07:07,440
towards some specific

192
00:07:07,440 --> 00:07:09,919
part of the code typically your patch

193
00:07:09,919 --> 00:07:12,000
and for example confirmation of static

194
00:07:12,000 --> 00:07:14,080
analysis report to see if you are

195
00:07:14,080 --> 00:07:16,400
false positive false alarm or real

196
00:07:16,400 --> 00:07:17,680
problems

197
00:07:17,680 --> 00:07:20,479
uh the very very first directed gray box

198
00:07:20,479 --> 00:07:21,280
uh

199
00:07:21,280 --> 00:07:23,960
directed robust further was ifalgo in

200
00:07:23,960 --> 00:07:25,360
2017

201
00:07:25,360 --> 00:07:31,840
so this line of research is kind of new

202
00:07:31,840 --> 00:07:34,240
so from a more technical point of view

203
00:07:34,240 --> 00:07:34,960
actually

204
00:07:34,960 --> 00:07:37,039
coverage guided grey box fuzzing so

205
00:07:37,039 --> 00:07:38,720
stone dark gray box fuzzing

206
00:07:38,720 --> 00:07:41,039
and directed gray box fuzzing are not

207
00:07:41,039 --> 00:07:42,400
that different

208
00:07:42,400 --> 00:07:44,400
so this is a high level view of coverage

209
00:07:44,400 --> 00:07:46,160
guiding grabox fuzzing

210
00:07:46,160 --> 00:07:48,080
so first you have some instrumentation

211
00:07:48,080 --> 00:07:49,919
step where you will have to record

212
00:07:49,919 --> 00:07:52,720
all the information you need to record

213
00:07:52,720 --> 00:07:56,000
typically coverage information

214
00:07:56,000 --> 00:07:58,560
then you have the fuzzing loop by itself

215
00:07:58,560 --> 00:07:59,919
with seed selection

216
00:07:59,919 --> 00:08:03,120
mutation also you can give

217
00:08:03,120 --> 00:08:05,840
some power schedule to which is time

218
00:08:05,840 --> 00:08:08,240
budget to seeds according to

219
00:08:08,240 --> 00:08:10,800
versco with a good seed having better

220
00:08:10,800 --> 00:08:11,280
score

221
00:08:11,280 --> 00:08:13,919
and so on then you need also a wave

222
00:08:13,919 --> 00:08:16,160
which is called here 3h to distinguish

223
00:08:16,160 --> 00:08:16,639
between

224
00:08:16,639 --> 00:08:20,160
bugs and not non-bugs

225
00:08:20,160 --> 00:08:22,319
so for buffer overflow it's pretty

226
00:08:22,319 --> 00:08:24,080
simple actually

227
00:08:24,080 --> 00:08:26,479
when it crash when you have a bug you

228
00:08:26,479 --> 00:08:28,800
can miss a few before the flow but most

229
00:08:28,800 --> 00:08:31,599
of the time it will be okay

230
00:08:31,599 --> 00:08:33,360
for something like use after three it

231
00:08:33,360 --> 00:08:35,279
will be much more complicated as we'll

232
00:08:35,279 --> 00:08:37,439
see

233
00:08:38,000 --> 00:08:40,080
so now if we look at direct grabox

234
00:08:40,080 --> 00:08:41,839
fuzzing it's mostly the same

235
00:08:41,839 --> 00:08:44,560
so you have an additional input which is

236
00:08:44,560 --> 00:08:45,680
a target

237
00:08:45,680 --> 00:08:47,600
and one additional component which is

238
00:08:47,600 --> 00:08:49,839
the seed distance meaning the distance

239
00:08:49,839 --> 00:08:50,560
between

240
00:08:50,560 --> 00:08:53,600
an input the execution of an input

241
00:08:53,600 --> 00:08:55,600
and the true of a target you want to

242
00:08:55,600 --> 00:08:57,360
reach

243
00:08:57,360 --> 00:08:59,680
once you have that then basically it's

244
00:08:59,680 --> 00:09:01,680
follow the same architecture except that

245
00:09:01,680 --> 00:09:05,120
typically some part of the architecture

246
00:09:05,120 --> 00:09:07,760
will take the distance into information

247
00:09:07,760 --> 00:09:09,440
into a code for example

248
00:09:09,440 --> 00:09:12,399
the power schedule

249
00:09:13,120 --> 00:09:16,160
so now coming back to use after three

250
00:09:16,160 --> 00:09:18,080
as we saw before there are more and more

251
00:09:18,080 --> 00:09:19,360
of them yet

252
00:09:19,360 --> 00:09:21,760
actually further do not find a lot of

253
00:09:21,760 --> 00:09:22,720
them

254
00:09:22,720 --> 00:09:26,240
we have statistics from oss fuzz

255
00:09:26,240 --> 00:09:29,519
on the on the right part actually there

256
00:09:29,519 --> 00:09:31,200
are deep reasons for that there are two

257
00:09:31,200 --> 00:09:33,279
main difficulties for ending use after

258
00:09:33,279 --> 00:09:35,040
three bugs with further

259
00:09:35,040 --> 00:09:37,040
the first one is that there are very

260
00:09:37,040 --> 00:09:39,200
strong temporal and special constraints

261
00:09:39,200 --> 00:09:40,160
for this kind

262
00:09:40,160 --> 00:09:42,720
of bugs they are very very complicated

263
00:09:42,720 --> 00:09:44,320
because you have this temporal

264
00:09:44,320 --> 00:09:47,360
constraint you need us to find an event

265
00:09:47,360 --> 00:09:50,320
a sequence of event so the allocation

266
00:09:50,320 --> 00:09:50,640
the

267
00:09:50,640 --> 00:09:53,360
allocation and the use in this specific

268
00:09:53,360 --> 00:09:54,720
order

269
00:09:54,720 --> 00:09:57,120
and also some special constraint because

270
00:09:57,120 --> 00:09:59,519
all these events must

271
00:09:59,519 --> 00:10:02,000
must relate to the same memory cell and

272
00:10:02,000 --> 00:10:03,839
here already fuzzing has already

273
00:10:03,839 --> 00:10:05,360
radiated time compared to buffer

274
00:10:05,360 --> 00:10:07,120
overflow where typically you just need

275
00:10:07,120 --> 00:10:08,399
to reach one point

276
00:10:08,399 --> 00:10:11,680
in the code with big enough arguments

277
00:10:11,680 --> 00:10:13,360
the second point which is hard for

278
00:10:13,360 --> 00:10:15,040
fuzzing is that

279
00:10:15,040 --> 00:10:16,880
usually for you use after three you

280
00:10:16,880 --> 00:10:18,720
don't have uh

281
00:10:18,720 --> 00:10:21,600
you don't have any crash so it's kind of

282
00:10:21,600 --> 00:10:23,360
a silent bug

283
00:10:23,360 --> 00:10:25,519
so what people will do if they want to

284
00:10:25,519 --> 00:10:26,800
find use after free

285
00:10:26,800 --> 00:10:30,000
with fuzzing is to equip further with uh

286
00:10:30,000 --> 00:10:32,880
with a sanitizer like file grind and so

287
00:10:32,880 --> 00:10:33,680
to run it

288
00:10:33,680 --> 00:10:37,360
uh to run sanitized execution but

289
00:10:37,360 --> 00:10:40,160
there is a big uh runtime of a red with

290
00:10:40,160 --> 00:10:42,320
that and this is a problem actually

291
00:10:42,320 --> 00:10:44,800
because fuzzing is good because it is

292
00:10:44,800 --> 00:10:46,000
able to

293
00:10:46,000 --> 00:10:49,760
to create a very huge amount of input

294
00:10:49,760 --> 00:10:52,560
so if you have runtime of a red you will

295
00:10:52,560 --> 00:10:53,200
run

296
00:10:53,200 --> 00:10:56,560
much much less input and you will be

297
00:10:56,560 --> 00:10:57,839
less effective

298
00:10:57,839 --> 00:11:01,839
so this is a big problem too

299
00:11:01,839 --> 00:11:03,839
so and actually it happens that both

300
00:11:03,839 --> 00:11:06,079
fuzzing and directed fuzzing have a very

301
00:11:06,079 --> 00:11:08,000
hard time in practice on use after free

302
00:11:08,000 --> 00:11:11,040
so recall or tiny motivating example

303
00:11:11,040 --> 00:11:13,120
so now that i have set up the stage

304
00:11:13,120 --> 00:11:15,279
mandun will explain a technique for use

305
00:11:15,279 --> 00:11:16,160
after free

306
00:11:16,160 --> 00:11:19,680
directed phasing thanks sebastian i will

307
00:11:19,680 --> 00:11:22,000
present you a fast a little further for

308
00:11:22,000 --> 00:11:26,399
use other free box and then draw some

309
00:11:26,839 --> 00:11:28,160
conclusions

310
00:11:28,160 --> 00:11:30,320
discussing our techniques so we first

311
00:11:30,320 --> 00:11:32,480
revised the workflow of with the father

312
00:11:32,480 --> 00:11:33,120
and so

313
00:11:33,120 --> 00:11:36,640
the limitation in finding use auto-free

314
00:11:36,640 --> 00:11:38,560
adjusting with the father are distant

315
00:11:38,560 --> 00:11:40,399
guided so however

316
00:11:40,399 --> 00:11:42,079
the instrumentation phase at stroke

317
00:11:42,079 --> 00:11:43,760
level is costly

318
00:11:43,760 --> 00:11:45,680
around several hours for complex

319
00:11:45,680 --> 00:11:46,800
programs

320
00:11:46,800 --> 00:11:48,720
and it cannot differentiate the

321
00:11:48,720 --> 00:11:50,720
differences between two inputs

322
00:11:50,720 --> 00:11:53,279
covering the same set of basic blocks

323
00:11:53,279 --> 00:11:57,120
but in different order

324
00:11:57,120 --> 00:11:59,360
existing way of offering just as is

325
00:11:59,360 --> 00:12:00,399
equally

326
00:12:00,399 --> 00:12:04,480
however given a set of predefined target

327
00:12:04,480 --> 00:12:06,880
the likelihood of s destination being

328
00:12:06,880 --> 00:12:09,360
reachable to targets are different

329
00:12:09,360 --> 00:12:12,320
consequently in some cases they migrate

330
00:12:12,320 --> 00:12:14,079
effort exploring

331
00:12:14,079 --> 00:12:16,880
non-vulnerable code or invisible part

332
00:12:16,880 --> 00:12:17,680
leading to

333
00:12:17,680 --> 00:12:21,839
specified target also previous work

334
00:12:21,839 --> 00:12:24,320
don't take into account the orange of

335
00:12:24,320 --> 00:12:25,519
cover basic block

336
00:12:25,519 --> 00:12:28,240
when selecting inputs for mutation they

337
00:12:28,240 --> 00:12:29,839
might skip input that

338
00:12:29,839 --> 00:12:32,240
already covered in sequence several

339
00:12:32,240 --> 00:12:35,279
target basic block

340
00:12:36,639 --> 00:12:40,000
next uh as uaf box fails silently

341
00:12:40,000 --> 00:12:42,720
we need to choose on input produced by

342
00:12:42,720 --> 00:12:43,440
the father

343
00:12:43,440 --> 00:12:46,720
to find the proof concept input

344
00:12:46,720 --> 00:12:49,440
such a large amount of unreachable input

345
00:12:49,440 --> 00:12:49,839
waste

346
00:12:49,839 --> 00:12:52,720
a lot of time in standardized by each

347
00:12:52,720 --> 00:12:55,519
other person

348
00:12:56,320 --> 00:12:58,720
to address the limitations discussed

349
00:12:58,720 --> 00:12:59,839
above

350
00:12:59,839 --> 00:13:03,360
so we propose ua fast graduated further

351
00:13:03,360 --> 00:13:04,399
dedicated to

352
00:13:04,399 --> 00:13:07,279
use after three bucks by carefully

353
00:13:07,279 --> 00:13:09,440
tuning the key component of digital

354
00:13:09,440 --> 00:13:10,480
fuzzing

355
00:13:10,480 --> 00:13:13,440
to meet specific characteristics of this

356
00:13:13,440 --> 00:13:15,680
type

357
00:13:16,639 --> 00:13:19,600
overall ua fast has a similar workflow

358
00:13:19,600 --> 00:13:20,320
as read

359
00:13:20,320 --> 00:13:24,160
further and we add our improvement

360
00:13:24,160 --> 00:13:25,200
highlighted in

361
00:13:25,200 --> 00:13:29,120
orange along the whole fuzzing process

362
00:13:29,120 --> 00:13:32,720
first the static pre-computation of ua5

363
00:13:32,720 --> 00:13:36,480
is fast at binary level second

364
00:13:36,480 --> 00:13:38,880
we introduce new input metric to guide

365
00:13:38,880 --> 00:13:40,720
the further toward target

366
00:13:40,720 --> 00:13:44,320
at runtime finally we choose only

367
00:13:44,320 --> 00:13:45,680
potential inputs

368
00:13:45,680 --> 00:13:48,399
covering all targets in the expected

369
00:13:48,399 --> 00:13:49,440
trades

370
00:13:49,440 --> 00:13:52,560
and pre-filter for free input that

371
00:13:52,560 --> 00:13:56,719
are less likely to trigger the bug

372
00:13:58,399 --> 00:14:01,120
overall with select input for mutation

373
00:14:01,120 --> 00:14:02,720
based on similarities

374
00:14:02,720 --> 00:14:05,440
and orderings of input trace compared to

375
00:14:05,440 --> 00:14:07,279
the expected tray

376
00:14:07,279 --> 00:14:10,399
we assess the likelihood of an input

377
00:14:10,399 --> 00:14:13,519
based on three metric dedicated to

378
00:14:13,519 --> 00:14:17,680
uf at different levels of granularities

379
00:14:17,680 --> 00:14:22,160
function cones edges and basic block

380
00:14:22,160 --> 00:14:25,199
so the more vibrant geometric the more

381
00:14:25,199 --> 00:14:26,240
precise

382
00:14:26,240 --> 00:14:29,519
analysis is in terms of identifying

383
00:14:29,519 --> 00:14:30,959
interesting input

384
00:14:30,959 --> 00:14:34,720
that are likely covers the aspect tray

385
00:14:34,720 --> 00:14:37,279
so in next slide we will detail our

386
00:14:37,279 --> 00:14:40,160
input matrix

387
00:14:42,399 --> 00:14:45,440
and we focus on book revelation and past

388
00:14:45,440 --> 00:14:47,279
testing application

389
00:14:47,279 --> 00:14:49,680
so it's more likely we have a complete

390
00:14:49,680 --> 00:14:52,000
uh stack trace of own memory

391
00:14:52,000 --> 00:14:55,600
rated uf event so in this case

392
00:14:55,600 --> 00:14:59,920
unlike existing general related approach

393
00:14:59,920 --> 00:15:02,079
we need to take into account the

394
00:15:02,079 --> 00:15:02,959
relationship

395
00:15:02,959 --> 00:15:07,360
among target to improve weightedness

396
00:15:07,360 --> 00:15:11,680
so to facilitate our further analysis

397
00:15:11,680 --> 00:15:14,959
we must own stack trace as shown in

398
00:15:14,959 --> 00:15:17,680
the figure on the left hand side to

399
00:15:17,680 --> 00:15:18,639
recreate

400
00:15:18,639 --> 00:15:22,000
a dynamic current tree then perform a

401
00:15:22,000 --> 00:15:24,639
pre-order traversal of the tree

402
00:15:24,639 --> 00:15:28,079
to generate a block choice and

403
00:15:28,079 --> 00:15:31,519
our target so we make sure that the

404
00:15:31,519 --> 00:15:32,639
children are

405
00:15:32,639 --> 00:15:35,680
according to the offerings of the

406
00:15:35,680 --> 00:15:41,839
eof event after the flattening process

407
00:15:44,480 --> 00:15:47,759
previous uh distance do not account for

408
00:15:47,759 --> 00:15:50,880
any order among the target location

409
00:15:50,880 --> 00:15:54,160
why is essential for uf

410
00:15:54,160 --> 00:15:57,120
so we address the issue by actually

411
00:15:57,120 --> 00:15:59,120
modifying the distance between

412
00:15:59,120 --> 00:16:02,320
function in chrome graph to favor

413
00:16:02,320 --> 00:16:05,440
part that sequentially go through the

414
00:16:05,440 --> 00:16:09,440
three uf event i look free and use

415
00:16:09,440 --> 00:16:12,560
of the blockchain this is done by

416
00:16:12,560 --> 00:16:15,279
decreasing the weight of the ads

417
00:16:15,279 --> 00:16:17,759
in the cone graph that are likely to be

418
00:16:17,759 --> 00:16:18,639
between

419
00:16:18,639 --> 00:16:21,120
the events using lightweight static

420
00:16:21,120 --> 00:16:23,279
analysis

421
00:16:23,279 --> 00:16:25,759
so our listen-based technique therefore

422
00:16:25,759 --> 00:16:26,399
consider

423
00:16:26,399 --> 00:16:29,759
both calling a reaction in general

424
00:16:29,759 --> 00:16:32,399
for example in some cases where the

425
00:16:32,399 --> 00:16:33,040
conley

426
00:16:33,040 --> 00:16:35,440
can appear several times at different

427
00:16:35,440 --> 00:16:37,360
locations in the collar

428
00:16:37,360 --> 00:16:40,079
and the calling recent covering you have

429
00:16:40,079 --> 00:16:40,720
event

430
00:16:40,720 --> 00:16:43,440
in sequence

431
00:16:45,680 --> 00:16:48,399
as existing worksheet as is equally in

432
00:16:48,399 --> 00:16:50,880
term of a reaching sequence target in

433
00:16:50,880 --> 00:16:52,399
sequent targets

434
00:16:52,399 --> 00:16:54,959
we propose a live wet cut excavate

435
00:16:54,959 --> 00:16:55,440
metric

436
00:16:55,440 --> 00:16:59,680
by measuring progress at at level

437
00:16:59,680 --> 00:17:04,160
but on the critical disease not only

438
00:17:04,160 --> 00:17:07,280
first we statically identified s

439
00:17:07,280 --> 00:17:09,599
whose destination are more likely to

440
00:17:09,599 --> 00:17:13,119
reach the neck target in the box tray

441
00:17:13,119 --> 00:17:15,439
as soon as the figure is lightweight

442
00:17:15,439 --> 00:17:16,160
because we

443
00:17:16,160 --> 00:17:18,880
only perform static in triple zero

444
00:17:18,880 --> 00:17:19,919
analysis of

445
00:17:19,919 --> 00:17:23,679
console program at runtime a ufo's

446
00:17:23,679 --> 00:17:26,959
favor inputs exercising market edge

447
00:17:26,959 --> 00:17:29,280
by score depending on the number of

448
00:17:29,280 --> 00:17:31,039
cover cut edge

449
00:17:31,039 --> 00:17:34,000
and hit count

450
00:17:36,240 --> 00:17:40,080
the sequence aware target similar metric

451
00:17:40,080 --> 00:17:43,039
concretely assess how many targets a

452
00:17:43,039 --> 00:17:43,520
seat

453
00:17:43,520 --> 00:17:46,559
execution tray cover at run time and

454
00:17:46,559 --> 00:17:47,919
also take

455
00:17:47,919 --> 00:17:52,799
orderings of the target in into account

456
00:17:52,799 --> 00:17:56,559
we combine both prefix and back option

457
00:17:56,559 --> 00:18:00,000
as prefix option is more

458
00:18:00,000 --> 00:18:02,799
precise because it counts value until

459
00:18:02,799 --> 00:18:03,440
the first

460
00:18:03,440 --> 00:18:06,960
diversion in the box trade and

461
00:18:06,960 --> 00:18:09,039
the back option also provides more

462
00:18:09,039 --> 00:18:12,000
information about the whole trade

463
00:18:12,000 --> 00:18:15,120
then we use this metric for c

464
00:18:15,120 --> 00:18:17,919
selection by actually selecting more

465
00:18:17,919 --> 00:18:18,640
frequently

466
00:18:18,640 --> 00:18:21,679
input that are most similar to the

467
00:18:21,679 --> 00:18:24,559
target merchant

468
00:18:26,640 --> 00:18:30,000
so overall uh first prioritize uh

469
00:18:30,000 --> 00:18:32,640
the size more energy to input in the

470
00:18:32,640 --> 00:18:34,160
following cases

471
00:18:34,160 --> 00:18:36,559
first he put that closer to the block

472
00:18:36,559 --> 00:18:37,280
tray

473
00:18:37,280 --> 00:18:41,280
by our distance matrix second he put a

474
00:18:41,280 --> 00:18:44,480
more similar to the expected trade

475
00:18:44,480 --> 00:18:48,240
by our target similarity matrix finally

476
00:18:48,240 --> 00:18:50,720
input that make matter decision at

477
00:18:50,720 --> 00:18:52,559
critical code function

478
00:18:52,559 --> 00:18:57,840
by our cut excavate matrix

479
00:18:57,840 --> 00:19:00,640
in the two other process you will first

480
00:19:00,640 --> 00:19:02,799
choose the only potential input

481
00:19:02,799 --> 00:19:05,840
recover in sequence on target location

482
00:19:05,840 --> 00:19:08,320
in the box tray

483
00:19:08,320 --> 00:19:10,960
so we obtain this kind of information

484
00:19:10,960 --> 00:19:11,919
for free

485
00:19:11,919 --> 00:19:16,320
by our target similarity matrix

486
00:19:17,120 --> 00:19:20,240
for implementation we

487
00:19:20,240 --> 00:19:23,120
view our two ui files on top of the

488
00:19:23,120 --> 00:19:24,720
popular faster

489
00:19:24,720 --> 00:19:29,039
ff in qme mode we use ida pro

490
00:19:29,039 --> 00:19:32,080
to get the control program of the tested

491
00:19:32,080 --> 00:19:33,120
binaries

492
00:19:33,120 --> 00:19:36,720
and we also aim to support more

493
00:19:36,720 --> 00:19:39,760
open stroke binary disassembler

494
00:19:39,760 --> 00:19:43,120
li radar and

495
00:19:43,120 --> 00:19:46,080
then we deploy marklin plug-in of the

496
00:19:46,080 --> 00:19:47,919
memory analysis framework

497
00:19:47,919 --> 00:19:51,520
being set for static computation

498
00:19:51,520 --> 00:19:54,480
uh finally we use the profile tool like

499
00:19:54,480 --> 00:19:55,360
one grants

500
00:19:55,360 --> 00:19:58,639
in the two other process

501
00:20:02,240 --> 00:20:05,600
for evaluation we evaluate our approach

502
00:20:05,600 --> 00:20:06,159
in

503
00:20:06,159 --> 00:20:09,360
two applications so for book reversal

504
00:20:09,360 --> 00:20:12,240
we compare our two with state of the art

505
00:20:12,240 --> 00:20:13,760
coverage guided

506
00:20:13,760 --> 00:20:17,600
and read further on 13

507
00:20:17,600 --> 00:20:20,720
uaf box of real

508
00:20:20,720 --> 00:20:23,919
programs as for goal is solved by

509
00:20:23,919 --> 00:20:26,960
father and hawkeye is not viable

510
00:20:26,960 --> 00:20:30,320
so we implemented their core techniques

511
00:20:30,320 --> 00:20:33,600
on our framework

512
00:20:33,679 --> 00:20:36,960
also we use a time to exposure number

513
00:20:36,960 --> 00:20:37,840
book file

514
00:20:37,840 --> 00:20:42,080
overhead and number of changing input as

515
00:20:42,080 --> 00:20:45,280
comparison metric

516
00:20:46,240 --> 00:20:48,400
and you can see in the figures ua files

517
00:20:48,400 --> 00:20:51,200
are performed state of the art faster

518
00:20:51,200 --> 00:20:53,600
in terms of book reproduction with a

519
00:20:53,600 --> 00:20:56,080
high confidence level

520
00:20:56,080 --> 00:21:00,159
for example ifr file two times faster

521
00:21:00,159 --> 00:21:01,440
and

522
00:21:01,440 --> 00:21:04,320
34 percent more books than the second

523
00:21:04,320 --> 00:21:07,039
best father

524
00:21:08,559 --> 00:21:11,600
you will also enjoy about

525
00:21:11,600 --> 00:21:14,559
a live web in transition time principle

526
00:21:14,559 --> 00:21:16,320
15 times faster than

527
00:21:16,320 --> 00:21:19,760
the stroke by flow

528
00:21:19,760 --> 00:21:22,640
and a minimal runtime overhead compared

529
00:21:22,640 --> 00:21:23,200
to

530
00:21:23,200 --> 00:21:26,080
iphone qmu

531
00:21:28,159 --> 00:21:31,280
you have reduced a large portion of

532
00:21:31,280 --> 00:21:32,320
choosing input

533
00:21:32,320 --> 00:21:35,520
around 90

534
00:21:35,520 --> 00:21:40,400
and spend only second in post processing

535
00:21:42,840 --> 00:21:45,840
phase

536
00:21:46,559 --> 00:21:48,720
so another practical application of

537
00:21:48,720 --> 00:21:50,000
bluetooth fuzzing is

538
00:21:50,000 --> 00:21:52,960
fast testing so the goal is to find

539
00:21:52,960 --> 00:21:55,679
incomplete patch on regression box

540
00:21:55,679 --> 00:21:58,720
also by exploring around the

541
00:21:58,720 --> 00:22:02,960
previously vulnerable code we could uh

542
00:22:02,960 --> 00:22:06,720
find a new box so how do we do

543
00:22:06,720 --> 00:22:09,919
first we identify recently discover

544
00:22:09,919 --> 00:22:13,919
uaf lots of open source programs

545
00:22:13,919 --> 00:22:16,480
as the code has evolved in some cases we

546
00:22:16,480 --> 00:22:17,200
need to

547
00:22:17,200 --> 00:22:20,240
manually extract cone instruction

548
00:22:20,240 --> 00:22:23,120
in the block choice and use them as

549
00:22:23,120 --> 00:22:23,760
target

550
00:22:23,760 --> 00:22:27,200
to guides and ua files

551
00:22:27,200 --> 00:22:30,080
so actually we first found 30 new box

552
00:22:30,080 --> 00:22:32,080
and four of them are incomplete

553
00:22:32,080 --> 00:22:35,120
erf bug fix in critical programs

554
00:22:35,120 --> 00:22:40,559
and got seven cvs

555
00:22:40,559 --> 00:22:44,399
this table detail our finding

556
00:22:49,440 --> 00:22:52,159
first of all we found an incomplete fix

557
00:22:52,159 --> 00:22:53,520
of gnu pass

558
00:22:53,520 --> 00:22:56,799
by using the block tray of existing

559
00:22:56,799 --> 00:22:59,520
double free

560
00:23:04,799 --> 00:23:07,440
so to summarize what we ran over in this

561
00:23:07,440 --> 00:23:08,240
talk

562
00:23:08,240 --> 00:23:10,640
we proposed a reactive fusing framework

563
00:23:10,640 --> 00:23:13,039
to detect you after three bucks

564
00:23:13,039 --> 00:23:16,320
at binary level and we saw its

565
00:23:16,320 --> 00:23:19,200
effectiveness and efficiency in mercury

566
00:23:19,200 --> 00:23:20,559
person

567
00:23:20,559 --> 00:23:24,400
and path testing application

568
00:23:24,400 --> 00:23:28,559
so four key takeaway part of our talk

569
00:23:28,559 --> 00:23:31,039
so first read the fuzzing is practical

570
00:23:31,039 --> 00:23:31,760
and should be

571
00:23:31,760 --> 00:23:34,840
integrated into the software development

572
00:23:34,840 --> 00:23:36,159
process

573
00:23:36,159 --> 00:23:39,280
second we should develop vulnerabilities

574
00:23:39,280 --> 00:23:42,640
oriented further to actually

575
00:23:42,640 --> 00:23:46,640
effectively detect a complex block

576
00:23:46,640 --> 00:23:50,720
and third pass-oriented fuzzing is

577
00:23:50,720 --> 00:23:55,520
bigger than the bus thirteen

578
00:23:55,520 --> 00:23:58,400
and finally we should find and fix the

579
00:23:58,400 --> 00:23:59,440
variance of

580
00:23:59,440 --> 00:24:04,880
bug class uh thank you for

581
00:24:04,880 --> 00:24:07,520
your attention and we check out our

582
00:24:07,520 --> 00:24:09,120
paper and our tool

583
00:24:09,120 --> 00:24:19,840
so we happy to take any questions

584
00:24:23,840 --> 00:24:25,679
internet connection so if you have any

585
00:24:25,679 --> 00:24:28,559
questions we'll be happy to

586
00:24:28,559 --> 00:24:33,840
answer it

587
00:24:47,039 --> 00:25:01,520
um okay

588
00:25:01,520 --> 00:25:04,080
uh so

589
00:25:05,840 --> 00:25:09,200
so yes there is a github repo actually i

590
00:25:09,200 --> 00:25:15,840
think it's your last slide

591
00:25:21,360 --> 00:25:24,320
so there is a github repo on the slide

592
00:25:24,320 --> 00:25:24,640
you

593
00:25:24,640 --> 00:25:29,840
you will have the address

594
00:25:59,679 --> 00:26:03,279
okay so a lot of questions coming um

595
00:26:03,279 --> 00:26:05,919
so kenta regarding your turn so we have

596
00:26:05,919 --> 00:26:06,640
a github

597
00:26:06,640 --> 00:26:10,000
uh canta regarding your talk so

598
00:26:10,000 --> 00:26:13,520
indeed the main idea is uh beyond ufos

599
00:26:13,520 --> 00:26:14,000
is to

600
00:26:14,000 --> 00:26:15,919
to realize that usually direct it

601
00:26:15,919 --> 00:26:17,520
further uh just

602
00:26:17,520 --> 00:26:19,360
don't really take into account the

603
00:26:19,360 --> 00:26:20,960
specificities of the bug they are

604
00:26:20,960 --> 00:26:22,000
looking for

605
00:26:22,000 --> 00:26:23,760
it's good for memory overflow but

606
00:26:23,760 --> 00:26:25,679
clearly this is a problem for use after

607
00:26:25,679 --> 00:26:26,480
free

608
00:26:26,480 --> 00:26:28,640
and so we try to to take that into

609
00:26:28,640 --> 00:26:30,320
account and here one of the very

610
00:26:30,320 --> 00:26:32,159
important point was about uh

611
00:26:32,159 --> 00:26:35,360
sequence ordering so that's one point

612
00:26:35,360 --> 00:26:38,400
uh but there are also other things but

613
00:26:38,400 --> 00:26:40,640
it's the idea of all these metrics that

614
00:26:40,640 --> 00:26:41,440
mandung

615
00:26:41,440 --> 00:26:44,400
just uh described uh it's all about

616
00:26:44,400 --> 00:26:45,520
putting

617
00:26:45,520 --> 00:26:48,559
um putting intelligence putting

618
00:26:48,559 --> 00:26:49,120
knowledge

619
00:26:49,120 --> 00:26:51,279
of the vulnerability of a kind of

620
00:26:51,279 --> 00:26:52,320
ability

621
00:26:52,320 --> 00:26:55,679
inside the directed fuzzing process

622
00:26:55,679 --> 00:27:07,840
and it's why it works better

623
00:27:09,600 --> 00:27:11,600
question so what kind of program did we

624
00:27:11,600 --> 00:27:12,640
test again

625
00:27:12,640 --> 00:27:15,279
this is probably more commanding but at

626
00:27:15,279 --> 00:27:17,279
the end of the slide

627
00:27:17,279 --> 00:27:21,840
uh you will have um

628
00:27:23,440 --> 00:27:25,840
basically a table with uh with a

629
00:27:25,840 --> 00:27:27,919
different veneer ability we found and so

630
00:27:27,919 --> 00:27:28,559
on

631
00:27:28,559 --> 00:27:30,960
uh so basically we have two kind of

632
00:27:30,960 --> 00:27:31,679
experiments

633
00:27:31,679 --> 00:27:35,039
on the one experiment we we compare with

634
00:27:35,039 --> 00:27:37,279
with over directed further but which are

635
00:27:37,279 --> 00:27:38,640
not

636
00:27:38,640 --> 00:27:41,279
tailored to use after free so we take

637
00:27:41,279 --> 00:27:42,480
their benchmark

638
00:27:42,480 --> 00:27:49,840
so i don't really remember

639
00:27:58,720 --> 00:28:01,679
we check we take a use after three bucks

640
00:28:01,679 --> 00:28:03,440
on some programs

641
00:28:03,440 --> 00:28:05,840
uh take patch version and see if we can

642
00:28:05,840 --> 00:28:07,919
find bugs in this patch version

643
00:28:07,919 --> 00:28:09,919
so in this case we have programs like a

644
00:28:09,919 --> 00:28:12,000
new patch per 5

645
00:28:12,000 --> 00:28:15,120
new pdf some stuff like that so we have

646
00:28:15,120 --> 00:28:17,760
also a technical report on the web

647
00:28:17,760 --> 00:28:20,080
there is also some address in the slide

648
00:28:20,080 --> 00:28:31,840
and there are much more detail on that

649
00:28:35,440 --> 00:28:37,360
uh okay so there is a white paper

650
00:28:37,360 --> 00:28:39,279
actually there is even an academic paper

651
00:28:39,279 --> 00:28:40,799
which has been accepted to

652
00:28:40,799 --> 00:28:43,919
red this is an academic conference so

653
00:28:43,919 --> 00:28:45,039
the paper will

654
00:28:45,039 --> 00:28:47,840
appear i guess in september and i think

655
00:28:47,840 --> 00:28:48,960
there will be a

656
00:28:48,960 --> 00:28:51,200
anywhere technical paper before that on

657
00:28:51,200 --> 00:28:52,640
my web page and on the

658
00:28:52,640 --> 00:28:55,919
webpage of mandongo really soon

659
00:28:55,919 --> 00:29:00,559
we have a camera ready version so

660
00:29:02,399 --> 00:29:04,640
when we have all the details about the

661
00:29:04,640 --> 00:29:07,440
programs experiments data and so on

662
00:29:07,440 --> 00:29:13,840
oh perfect

663
00:29:14,480 --> 00:29:17,679
so harrison i will let mandung uh answer

664
00:29:17,679 --> 00:29:18,720
for this question

665
00:29:18,720 --> 00:29:20,480
because actually i'm not sure he's the

666
00:29:20,480 --> 00:29:27,840
main programmer and designer of a tool

667
00:29:30,960 --> 00:29:32,960
actually i would say uh regarding val

668
00:29:32,960 --> 00:29:34,559
grind

669
00:29:34,559 --> 00:29:37,120
unless mandom server thing but i would

670
00:29:37,120 --> 00:29:37,919
say that it can't

671
00:29:37,919 --> 00:29:39,919
the thing is uh from background the

672
00:29:39,919 --> 00:29:42,799
thing we take is really the

673
00:29:42,799 --> 00:29:45,200
what we really really need is about the

674
00:29:45,200 --> 00:29:46,799
kind of

675
00:29:46,799 --> 00:29:49,600
bug trace the kind of format so that's

676
00:29:49,600 --> 00:29:55,840
not a very big big problem

677
00:30:06,840 --> 00:30:09,840
so

678
00:30:23,039 --> 00:30:25,919
any other question

679
00:30:28,720 --> 00:30:31,600
okay so i'll let you let's say 10

680
00:30:31,600 --> 00:30:33,279
seconds for our last question

681
00:30:33,279 --> 00:30:37,840
otherwise we stop

682
00:30:38,399 --> 00:30:41,279
okay thank you guys that was a really

683
00:30:41,279 --> 00:30:42,880
really interesting

684
00:30:42,880 --> 00:30:45,919
hope you enjoyed it and see you next

685
00:30:45,919 --> 00:30:46,600
time

686
00:30:46,600 --> 00:30:49,600
bye

