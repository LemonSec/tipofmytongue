1
00:00:04,260 --> 00:00:14,060
[Music]

2
00:00:14,639 --> 00:00:15,679
hello everybody

3
00:00:15,679 --> 00:00:18,160
this is frank block and you're watching

4
00:00:18,160 --> 00:00:19,279
hiding process memory

5
00:00:19,279 --> 00:00:22,480
via anti-forensic techniques this talk

6
00:00:22,480 --> 00:00:23,840
is based on the research

7
00:00:23,840 --> 00:00:25,199
that i've done together with ralph

8
00:00:25,199 --> 00:00:27,039
politger patrick reichenberger and

9
00:00:27,039 --> 00:00:28,320
dominic schwepper

10
00:00:28,320 --> 00:00:31,279
from the university of erlangenberg so

11
00:00:31,279 --> 00:00:33,440
this was a cooperation between the emw

12
00:00:33,440 --> 00:00:37,360
research and the university of erlang

13
00:00:37,360 --> 00:00:39,360
to the agenda we will start with a short

14
00:00:39,360 --> 00:00:41,440
introduction some technical background

15
00:00:41,440 --> 00:00:43,760
then dive into the subversion techniques

16
00:00:43,760 --> 00:00:45,680
there are three of them

17
00:00:45,680 --> 00:00:47,840
then we'll talk a little bit about about

18
00:00:47,840 --> 00:00:50,480
challenges and some considerations

19
00:00:50,480 --> 00:00:52,559
after that we'll have a look at

20
00:00:52,559 --> 00:00:54,239
evaluation so we have

21
00:00:54,239 --> 00:00:56,719
evaluated our techniques with memory

22
00:00:56,719 --> 00:00:59,199
forensics and life forensics techniques

23
00:00:59,199 --> 00:01:01,039
after that we'll talk about and have a

24
00:01:01,039 --> 00:01:03,440
look at detection approaches

25
00:01:03,440 --> 00:01:06,159
evaluate those two and at the end some

26
00:01:06,159 --> 00:01:08,720
conclusion

27
00:01:09,119 --> 00:01:10,479
there's some radiated work that i wanted

28
00:01:10,479 --> 00:01:12,799
to mention also to give you an idea what

29
00:01:12,799 --> 00:01:14,000
this is about and what

30
00:01:14,000 --> 00:01:17,119
is different from them the first great

31
00:01:17,119 --> 00:01:18,560
research that i want to mention is

32
00:01:18,560 --> 00:01:20,560
shadow walker by sherry sparks and jaime

33
00:01:20,560 --> 00:01:21,360
butler

34
00:01:21,360 --> 00:01:23,759
so what they basically did was changing

35
00:01:23,759 --> 00:01:26,479
the mapping between witcher and physical

36
00:01:26,479 --> 00:01:30,799
memory and by that any subsequent

37
00:01:30,799 --> 00:01:32,640
access to a which address would not end

38
00:01:32,640 --> 00:01:33,840
up anymore at

39
00:01:33,840 --> 00:01:35,759
the actual physical content for that

40
00:01:35,759 --> 00:01:37,040
mutual address

41
00:01:37,040 --> 00:01:38,720
we are doing something similar but there

42
00:01:38,720 --> 00:01:40,479
are three major differences between

43
00:01:40,479 --> 00:01:42,079
those two approaches

44
00:01:42,079 --> 00:01:45,759
on the one hand shadow walker

45
00:01:45,759 --> 00:01:48,799
only focused on the kernel space it

46
00:01:48,799 --> 00:01:50,159
required a hook in the

47
00:01:50,159 --> 00:01:52,320
page fault handler in order to work and

48
00:01:52,320 --> 00:01:54,720
the third difference is that it doesn't

49
00:01:54,720 --> 00:01:55,680
work anymore

50
00:01:55,680 --> 00:01:59,200
on current cpus so sadly or luckily

51
00:01:59,200 --> 00:02:00,960
and the second related work that i

52
00:02:00,960 --> 00:02:02,719
wanted to mention is gargoyle by josh

53
00:02:02,719 --> 00:02:04,560
los pinozzo

54
00:02:04,560 --> 00:02:06,640
he concentrated on the process address

55
00:02:06,640 --> 00:02:10,080
space so similar to our approaches

56
00:02:10,080 --> 00:02:12,800
but he didn't his approach doesn't hide

57
00:02:12,800 --> 00:02:14,560
the actual memory content but he

58
00:02:14,560 --> 00:02:16,000
changed some characteristics of the

59
00:02:16,000 --> 00:02:17,599
injected code

60
00:02:17,599 --> 00:02:20,400
in this case the executable state and by

61
00:02:20,400 --> 00:02:20,720
that

62
00:02:20,720 --> 00:02:24,000
tried tries to hide from detection tools

63
00:02:24,000 --> 00:02:26,319
uh our approach is here in this case

64
00:02:26,319 --> 00:02:27,840
different we are

65
00:02:27,840 --> 00:02:29,680
solely interested in hiding the actual

66
00:02:29,680 --> 00:02:31,599
memory content so we don't change

67
00:02:31,599 --> 00:02:32,879
characteristics

68
00:02:32,879 --> 00:02:34,560
uh the memory is still executable for

69
00:02:34,560 --> 00:02:36,480
example in some cases

70
00:02:36,480 --> 00:02:38,640
but the actual memory content behind it

71
00:02:38,640 --> 00:02:41,440
is hidden

72
00:02:41,599 --> 00:02:44,080
okay let's talk about a little bit a

73
00:02:44,080 --> 00:02:45,599
little bit about some

74
00:02:45,599 --> 00:02:47,760
technical backgrounds so the procedure

75
00:02:47,760 --> 00:02:49,280
space contains

76
00:02:49,280 --> 00:02:52,879
different data executables dlls

77
00:02:52,879 --> 00:02:55,920
schedule shared libraries or heap

78
00:02:55,920 --> 00:02:57,920
stack data whatsoever and all those

79
00:02:57,920 --> 00:02:59,840
memory areas are described by what we

80
00:02:59,840 --> 00:03:01,120
will call in this context

81
00:03:01,120 --> 00:03:03,519
memory error structures so mes

82
00:03:03,519 --> 00:03:04,319
structures

83
00:03:04,319 --> 00:03:06,239
on windows those are virtual address

84
00:03:06,239 --> 00:03:08,720
descriptors on linux those are

85
00:03:08,720 --> 00:03:12,560
virtual memory areas and as you can see

86
00:03:12,560 --> 00:03:15,120
one thing that both those types have in

87
00:03:15,120 --> 00:03:16,480
common both those structures have in

88
00:03:16,480 --> 00:03:17,120
common

89
00:03:17,120 --> 00:03:19,599
is a start and an end pointer so you can

90
00:03:19,599 --> 00:03:20,480
see here that

91
00:03:20,480 --> 00:03:21,519
the start address points to the

92
00:03:21,519 --> 00:03:23,360
beginning of the memory area and the end

93
00:03:23,360 --> 00:03:24,799
pointer to the end

94
00:03:24,799 --> 00:03:27,440
and normally every memory in the which

95
00:03:27,440 --> 00:03:29,120
address base of a process is described

96
00:03:29,120 --> 00:03:30,159
by at least one

97
00:03:30,159 --> 00:03:35,440
or ideally by one memory error structure

98
00:03:36,000 --> 00:03:38,400
so the second second part that we're

99
00:03:38,400 --> 00:03:40,080
going to talk a little bit about is the

100
00:03:40,080 --> 00:03:42,159
depends are the paging structures

101
00:03:42,159 --> 00:03:44,159
so the process of translating a virtual

102
00:03:44,159 --> 00:03:45,599
address to a physical

103
00:03:45,599 --> 00:03:48,799
page frame the relevant part for us here

104
00:03:48,799 --> 00:03:49,760
in this case is

105
00:03:49,760 --> 00:03:51,599
just a page table so at the end of the

106
00:03:51,599 --> 00:03:53,120
translation process

107
00:03:53,120 --> 00:03:56,159
we will end up for a which address on a

108
00:03:56,159 --> 00:03:59,519
specific pte a page table entry this one

109
00:03:59,519 --> 00:04:01,280
contains a pointer to the actual page

110
00:04:01,280 --> 00:04:03,040
frame that contains the memory for the

111
00:04:03,040 --> 00:04:04,560
switch address

112
00:04:04,560 --> 00:04:06,400
and the widget just also has a page

113
00:04:06,400 --> 00:04:08,000
offset into this page frame where the

114
00:04:08,000 --> 00:04:08,640
actual

115
00:04:08,640 --> 00:04:11,920
byte is that byte is located where this

116
00:04:11,920 --> 00:04:13,599
address points to

117
00:04:13,599 --> 00:04:15,920
and yeah exactly this is something that

118
00:04:15,920 --> 00:04:17,260
we are going to

119
00:04:17,260 --> 00:04:19,040
[Music]

120
00:04:19,040 --> 00:04:22,079
tamper with also to mention right here

121
00:04:22,079 --> 00:04:22,400
now

122
00:04:22,400 --> 00:04:26,000
is uh on both operating systems on

123
00:04:26,000 --> 00:04:27,680
windows and linux there are some reverse

124
00:04:27,680 --> 00:04:28,240
mappings

125
00:04:28,240 --> 00:04:30,000
so in windows there's the page frame

126
00:04:30,000 --> 00:04:32,160
number database and the linux

127
00:04:32,160 --> 00:04:35,199
the page structures and those are more

128
00:04:35,199 --> 00:04:36,160
or less the

129
00:04:36,160 --> 00:04:38,400
physical point of view and the memory

130
00:04:38,400 --> 00:04:39,759
but we will dig a little bit

131
00:04:39,759 --> 00:04:42,560
deeper into those two types a little bit

132
00:04:42,560 --> 00:04:44,320
later

133
00:04:44,320 --> 00:04:46,960
and the third part is shared memory so

134
00:04:46,960 --> 00:04:48,800
the idea of short memory is to just

135
00:04:48,800 --> 00:04:51,600
share data between different processes

136
00:04:51,600 --> 00:04:53,520
and the relevant part for us here to

137
00:04:53,520 --> 00:04:54,000
mention

138
00:04:54,000 --> 00:04:57,759
is that shared memory as um despite

139
00:04:57,759 --> 00:05:00,160
in contrast to private memory is still

140
00:05:00,160 --> 00:05:00,880
accessible

141
00:05:00,880 --> 00:05:03,440
if the shared memory has been unmapped

142
00:05:03,440 --> 00:05:04,639
so if it's not

143
00:05:04,639 --> 00:05:07,039
part of any process for example anymore

144
00:05:07,039 --> 00:05:07,759
not in

145
00:05:07,759 --> 00:05:09,840
not mapped in any virtual address space

146
00:05:09,840 --> 00:05:11,360
it can still be wrestling in a physical

147
00:05:11,360 --> 00:05:13,120
memory and can still be remapped as long

148
00:05:13,120 --> 00:05:13,759
as at least

149
00:05:13,759 --> 00:05:16,240
one process has a handle to the shared

150
00:05:16,240 --> 00:05:17,039
memory

151
00:05:17,039 --> 00:05:19,919
so that's something to keep in mind and

152
00:05:19,919 --> 00:05:21,199
there are different ways to create

153
00:05:21,199 --> 00:05:22,400
shared memory on windows there's

154
00:05:22,400 --> 00:05:23,360
especially this

155
00:05:23,360 --> 00:05:26,080
api sequence on linux there are at least

156
00:05:26,080 --> 00:05:26,880
three different

157
00:05:26,880 --> 00:05:28,479
ways to create shared memory that we had

158
00:05:28,479 --> 00:05:32,560
a look at and we will see later

159
00:05:32,560 --> 00:05:34,160
okay let's start with our separation

160
00:05:34,160 --> 00:05:36,880
techniques in general

161
00:05:36,880 --> 00:05:39,759
we are trying to hide process memory

162
00:05:39,759 --> 00:05:40,800
with those

163
00:05:40,800 --> 00:05:42,560
those techniques can be used

164
00:05:42,560 --> 00:05:44,880
independently or can also be combined

165
00:05:44,880 --> 00:05:46,800
and our scenario is for example an

166
00:05:46,800 --> 00:05:48,560
attacker that injected code into another

167
00:05:48,560 --> 00:05:49,360
process

168
00:05:49,360 --> 00:05:51,440
and now wants to hide this memory or he

169
00:05:51,440 --> 00:05:53,360
wants to hide memory that is in

170
00:05:53,360 --> 00:05:56,560
his own process space

171
00:05:56,800 --> 00:06:00,000
so the first technique is what we will

172
00:06:00,000 --> 00:06:00,319
call

173
00:06:00,319 --> 00:06:04,240
mas remapping so the idea was

174
00:06:04,240 --> 00:06:06,479
to do this technique is because that

175
00:06:06,479 --> 00:06:07,680
many tools

176
00:06:07,680 --> 00:06:09,199
attention tools depend on the

177
00:06:09,199 --> 00:06:11,759
information provided by those structures

178
00:06:11,759 --> 00:06:15,440
so you rely on those and this is why we

179
00:06:15,440 --> 00:06:17,600
wanted to remap some of the information

180
00:06:17,600 --> 00:06:19,680
so to change the information in order to

181
00:06:19,680 --> 00:06:20,000
hide

182
00:06:20,000 --> 00:06:22,479
our malicious memory um one thing to

183
00:06:22,479 --> 00:06:24,160
note here is that this technique will

184
00:06:24,160 --> 00:06:26,000
require kernel level privileges

185
00:06:26,000 --> 00:06:28,160
so this is something to keep in mind so

186
00:06:28,160 --> 00:06:29,840
we are here right now at the beginning

187
00:06:29,840 --> 00:06:32,160
with our malicious memory

188
00:06:32,160 --> 00:06:34,880
and we are now trying to hide it by just

189
00:06:34,880 --> 00:06:35,440
simply

190
00:06:35,440 --> 00:06:37,919
changing those pointers here so you can

191
00:06:37,919 --> 00:06:39,919
now see here the effect so what we did

192
00:06:39,919 --> 00:06:41,759
is we placed some benign data in the

193
00:06:41,759 --> 00:06:42,639
beginning

194
00:06:42,639 --> 00:06:45,440
which is not malicious any in any way

195
00:06:45,440 --> 00:06:46,880
and we are changing the

196
00:06:46,880 --> 00:06:49,039
pointers in that way that the malicious

197
00:06:49,039 --> 00:06:50,400
memory which is

198
00:06:50,400 --> 00:06:52,639
placed right after is not described or

199
00:06:52,639 --> 00:06:53,520
not contained

200
00:06:53,520 --> 00:06:56,880
in this area so they're not described

201
00:06:56,880 --> 00:06:59,280
by the vm and vm start they are not in

202
00:06:59,280 --> 00:07:00,639
this range

203
00:07:00,639 --> 00:07:03,520
so there's no mes structure anymore at

204
00:07:03,520 --> 00:07:04,479
this point of

205
00:07:04,479 --> 00:07:08,000
time that is including this memory area

206
00:07:08,000 --> 00:07:08,960
right here

207
00:07:08,960 --> 00:07:11,520
but still it can can still be accessed

208
00:07:11,520 --> 00:07:14,319
especially by the cpu cpu executed

209
00:07:14,319 --> 00:07:16,400
because the cu cpu doesn't care about

210
00:07:16,400 --> 00:07:17,919
the mas structures

211
00:07:17,919 --> 00:07:21,599
it only is interested or

212
00:07:21,599 --> 00:07:23,520
uses the ptes in order to do the

213
00:07:23,520 --> 00:07:25,520
translation and to access the memory

214
00:07:25,520 --> 00:07:26,960
and those are still valid and are still

215
00:07:26,960 --> 00:07:29,120
there so this

216
00:07:29,120 --> 00:07:32,800
works after this modification fine

217
00:07:32,800 --> 00:07:35,360
one advantage of this technique in

218
00:07:35,360 --> 00:07:36,880
regards to the other twos

219
00:07:36,880 --> 00:07:39,440
to the other two that we will see right

220
00:07:39,440 --> 00:07:40,000
now

221
00:07:40,000 --> 00:07:42,960
is that there's no it is not necessary

222
00:07:42,960 --> 00:07:43,840
to reverse

223
00:07:43,840 --> 00:07:46,960
this modification in order for the

224
00:07:46,960 --> 00:07:50,240
malicious coach to execute

225
00:07:50,240 --> 00:07:52,240
so the second technique also requires

226
00:07:52,240 --> 00:07:53,680
kernel privileges

227
00:07:53,680 --> 00:07:56,319
in order to work and it also requires

228
00:07:56,319 --> 00:07:58,240
some restoration so

229
00:07:58,240 --> 00:08:01,520
it is necessary to all the time unhide

230
00:08:01,520 --> 00:08:02,560
and re-hide

231
00:08:02,560 --> 00:08:05,440
the memory in order for it to work and

232
00:08:05,440 --> 00:08:06,319
we will talk about

233
00:08:06,319 --> 00:08:08,240
two different flavors of this technique

234
00:08:08,240 --> 00:08:09,520
so we are calling them

235
00:08:09,520 --> 00:08:11,919
pt subversions and we have the pte rimer

236
00:08:11,919 --> 00:08:12,560
peng

237
00:08:12,560 --> 00:08:15,919
and the pte erasure and the beginning in

238
00:08:15,919 --> 00:08:17,840
both cases is the same so we have here

239
00:08:17,840 --> 00:08:19,520
our malicious page

240
00:08:19,520 --> 00:08:22,400
and we have a benign page with data that

241
00:08:22,400 --> 00:08:24,560
is yeah not malicious at all

242
00:08:24,560 --> 00:08:26,960
and our goal now is to remap in the

243
00:08:26,960 --> 00:08:28,800
first technique to remake

244
00:08:28,800 --> 00:08:30,479
remap this witcher address to this

245
00:08:30,479 --> 00:08:34,159
benign data by simply changing the pfn

246
00:08:34,159 --> 00:08:36,320
so there's a field and this pte that

247
00:08:36,320 --> 00:08:37,919
points to the physical page

248
00:08:37,919 --> 00:08:40,000
and we are just changing this volume so

249
00:08:40,000 --> 00:08:41,120
that this which

250
00:08:41,120 --> 00:08:43,839
address does it uh from this point on um

251
00:08:43,839 --> 00:08:45,920
point to this benign data down here

252
00:08:45,920 --> 00:08:48,560
and this page here has no pte the point

253
00:08:48,560 --> 00:08:50,160
switch is not mapped in any virtual

254
00:08:50,160 --> 00:08:50,800
address

255
00:08:50,800 --> 00:08:53,839
and hence can't be accessed simply by

256
00:08:53,839 --> 00:08:54,880
enumerating or

257
00:08:54,880 --> 00:08:58,240
accessing which addresses anymore

258
00:08:58,399 --> 00:09:00,399
the second technique is what we call pte

259
00:09:00,399 --> 00:09:02,240
erasure so in this case

260
00:09:02,240 --> 00:09:04,640
we are nullifying so we are erasing the

261
00:09:04,640 --> 00:09:05,760
pte

262
00:09:05,760 --> 00:09:08,880
just putting zeros in there so there's

263
00:09:08,880 --> 00:09:10,399
also in this case

264
00:09:10,399 --> 00:09:12,640
no more reference to this malicious page

265
00:09:12,640 --> 00:09:14,320
it's not mapped in any rich address

266
00:09:14,320 --> 00:09:16,080
space anymore

267
00:09:16,080 --> 00:09:18,240
and any access to this which address

268
00:09:18,240 --> 00:09:20,000
will end up in no memory

269
00:09:20,000 --> 00:09:22,880
which is not a problem per se because um

270
00:09:22,880 --> 00:09:24,160
this can be

271
00:09:24,160 --> 00:09:26,399
for when it reasons the case for example

272
00:09:26,399 --> 00:09:28,640
if the page has not yet been accessed

273
00:09:28,640 --> 00:09:30,640
um then this would be look the same so

274
00:09:30,640 --> 00:09:32,480
it's not suspicious by itself

275
00:09:32,480 --> 00:09:34,080
if there's a rich address that points to

276
00:09:34,080 --> 00:09:37,839
a pte that is zero

277
00:09:38,320 --> 00:09:40,000
and the third technique that we want to

278
00:09:40,000 --> 00:09:42,320
talk about is shared memory subversion

279
00:09:42,320 --> 00:09:44,399
so the idea here is now to use shared

280
00:09:44,399 --> 00:09:46,000
memory in order to hide our manager's

281
00:09:46,000 --> 00:09:47,040
content

282
00:09:47,040 --> 00:09:50,800
and it is not to mention

283
00:09:50,800 --> 00:09:52,240
i wanted to mention that it is not

284
00:09:52,240 --> 00:09:54,560
necessary to share memory

285
00:09:54,560 --> 00:09:56,320
um between poses shadman we can also use

286
00:09:56,320 --> 00:09:58,080
solely by one process and this is also

287
00:09:58,080 --> 00:09:59,839
the way we are using it

288
00:09:59,839 --> 00:10:02,079
our evil process does use this memory

289
00:10:02,079 --> 00:10:03,519
more or less like private memory

290
00:10:03,519 --> 00:10:05,279
but with the advantages that come with

291
00:10:05,279 --> 00:10:06,959
chad memory from the attacker's point of

292
00:10:06,959 --> 00:10:07,839
view

293
00:10:07,839 --> 00:10:10,079
so what the attacker does is he creates

294
00:10:10,079 --> 00:10:11,600
a shared memory segment

295
00:10:11,600 --> 00:10:13,760
and puts his malicious code in there and

296
00:10:13,760 --> 00:10:14,800
then

297
00:10:14,800 --> 00:10:16,640
the first step unmaps it so it's not

298
00:10:16,640 --> 00:10:18,000
visible anymore

299
00:10:18,000 --> 00:10:21,040
and then after that anytime he wants to

300
00:10:21,040 --> 00:10:22,959
use it he will remap it and again and

301
00:10:22,959 --> 00:10:24,240
again one

302
00:10:24,240 --> 00:10:26,399
major advantage of this technique is

303
00:10:26,399 --> 00:10:28,160
that it doesn't require any kernel

304
00:10:28,160 --> 00:10:30,079
privileges so it can be used with solely

305
00:10:30,079 --> 00:10:31,279
users with

306
00:10:31,279 --> 00:10:35,279
solely standard user privileges

307
00:10:35,279 --> 00:10:37,040
so the attack process after we have set

308
00:10:37,040 --> 00:10:39,040
it up is more or less like this

309
00:10:39,040 --> 00:10:41,200
as soon as the evil process wants to

310
00:10:41,200 --> 00:10:43,440
execute or access the malicious data

311
00:10:43,440 --> 00:10:46,480
it shortly unmaps it into

312
00:10:46,480 --> 00:10:49,360
its memory space executed or reads data

313
00:10:49,360 --> 00:10:51,600
from it and then unmaps it again

314
00:10:51,600 --> 00:10:54,320
and by that we successfully hide from

315
00:10:54,320 --> 00:10:55,920
most of the tools or from

316
00:10:55,920 --> 00:10:57,839
nearly every detection tool that we

317
00:10:57,839 --> 00:10:59,600
evaluated by simply

318
00:10:59,600 --> 00:11:02,640
with the with the simple trick so

319
00:11:02,640 --> 00:11:05,440
why is that that this memory can't be um

320
00:11:05,440 --> 00:11:06,880
detected by any of the tools that we

321
00:11:06,880 --> 00:11:07,440
will

322
00:11:07,440 --> 00:11:10,800
see later let's dig a little bit into

323
00:11:10,800 --> 00:11:11,600
the details

324
00:11:11,600 --> 00:11:13,920
so with the unmapping what happens in

325
00:11:13,920 --> 00:11:14,640
the background

326
00:11:14,640 --> 00:11:16,800
is that the page tab entries for this

327
00:11:16,800 --> 00:11:17,680
shared memory

328
00:11:17,680 --> 00:11:20,399
are zeroed so they are not pointing

329
00:11:20,399 --> 00:11:22,640
anymore to the malicious pages

330
00:11:22,640 --> 00:11:24,320
but there must be still some reference

331
00:11:24,320 --> 00:11:26,079
to it because it is possible

332
00:11:26,079 --> 00:11:28,240
to remit it remap those pages so there

333
00:11:28,240 --> 00:11:30,800
must be some kind of reference to them

334
00:11:30,800 --> 00:11:33,920
and this reference is more or less

335
00:11:33,920 --> 00:11:36,240
hidden behind this memory handle that

336
00:11:36,240 --> 00:11:37,360
the process keeps

337
00:11:37,360 --> 00:11:40,959
in order for the pages not to be erased

338
00:11:40,959 --> 00:11:43,120
in the case of windows this memory

339
00:11:43,120 --> 00:11:44,640
handle is a section

340
00:11:44,640 --> 00:11:47,600
object so a pointer to a section object

341
00:11:47,600 --> 00:11:48,800
and this section

342
00:11:48,800 --> 00:11:50,959
object the section structure is located

343
00:11:50,959 --> 00:11:52,720
in the kernel address space

344
00:11:52,720 --> 00:11:54,000
so if you're following the section

345
00:11:54,000 --> 00:11:56,399
structure we are getting to a control

346
00:11:56,399 --> 00:11:57,680
area field

347
00:11:57,680 --> 00:11:59,920
this one points to the controller area

348
00:11:59,920 --> 00:12:01,200
structure

349
00:12:01,200 --> 00:12:03,600
which is more or less um pointing to the

350
00:12:03,600 --> 00:12:04,240
file

351
00:12:04,240 --> 00:12:06,000
if there's a if there's a file related

352
00:12:06,000 --> 00:12:07,360
to this memory area

353
00:12:07,360 --> 00:12:09,600
and right after that more interesting

354
00:12:09,600 --> 00:12:11,360
more interestingly for us

355
00:12:11,360 --> 00:12:13,120
is a subsection structure or there can

356
00:12:13,120 --> 00:12:15,519
be multiple ones and those are pointing

357
00:12:15,519 --> 00:12:17,519
to the so-called prototype pds and this

358
00:12:17,519 --> 00:12:19,200
is the interesting part for us

359
00:12:19,200 --> 00:12:22,639
because those type ptes contain the

360
00:12:22,639 --> 00:12:25,440
actual pointer to the malicious pages

361
00:12:25,440 --> 00:12:28,720
so the reason why we are that we don't

362
00:12:28,720 --> 00:12:30,079
find this

363
00:12:30,079 --> 00:12:32,639
malicious memory also if we scan the

364
00:12:32,639 --> 00:12:33,200
kernel

365
00:12:33,200 --> 00:12:36,399
address space is that the pages are not

366
00:12:36,399 --> 00:12:38,639
mapped into the kernel address space so

367
00:12:38,639 --> 00:12:41,440
those prototype pds are not part of the

368
00:12:41,440 --> 00:12:43,920
page tables for the kernel address for

369
00:12:43,920 --> 00:12:44,959
the kernel

370
00:12:44,959 --> 00:12:46,959
so they are not mapped into the current

371
00:12:46,959 --> 00:12:48,320
address space but only

372
00:12:48,320 --> 00:12:51,200
those prototype pd's itself are part of

373
00:12:51,200 --> 00:12:52,480
the virtual address space of the kernel

374
00:12:52,480 --> 00:12:54,000
so it's just data

375
00:12:54,000 --> 00:12:56,560
lying in there those ptes they are not

376
00:12:56,560 --> 00:12:57,360
part of the

377
00:12:57,360 --> 00:12:59,200
page tables itself from for for the

378
00:12:59,200 --> 00:13:01,040
kernel and that means that

379
00:13:01,040 --> 00:13:02,800
those pages are not mapped into the

380
00:13:02,800 --> 00:13:04,320
address space and hence the memory

381
00:13:04,320 --> 00:13:05,279
content

382
00:13:05,279 --> 00:13:08,079
can't be found when searching the

383
00:13:08,079 --> 00:13:10,880
witcher address space

384
00:13:11,120 --> 00:13:13,920
okay let's have a look at the evaluation

385
00:13:13,920 --> 00:13:15,600
we implemented our techniques for

386
00:13:15,600 --> 00:13:17,120
windows and linux

387
00:13:17,120 --> 00:13:20,399
and tested those in multiple vms

388
00:13:20,399 --> 00:13:22,240
for windows and linux and both in both

389
00:13:22,240 --> 00:13:25,040
cases on x64 architectures

390
00:13:25,040 --> 00:13:27,120
and this is the those are the results

391
00:13:27,120 --> 00:13:29,279
for the memory forensics point of view

392
00:13:29,279 --> 00:13:31,839
we used multiple plugins we used

393
00:13:31,839 --> 00:13:33,760
yarascan plugins

394
00:13:33,760 --> 00:13:35,680
we use recall and volatility for all

395
00:13:35,680 --> 00:13:37,120
those plugins

396
00:13:37,120 --> 00:13:39,120
and what you can see for yar scan for

397
00:13:39,120 --> 00:13:40,959
example is that volatility cr scan was

398
00:13:40,959 --> 00:13:42,720
not able to detect

399
00:13:42,720 --> 00:13:45,839
any of our hidden malicious content

400
00:13:45,839 --> 00:13:48,720
but recalled it the reason is that

401
00:13:48,720 --> 00:13:50,720
recall does a raw search so it doesn't

402
00:13:50,720 --> 00:13:51,600
rely on any

403
00:13:51,600 --> 00:13:53,839
virtual address structures which address

404
00:13:53,839 --> 00:13:55,519
translation structures

405
00:13:55,519 --> 00:13:58,079
it only searches the raw memory and by

406
00:13:58,079 --> 00:13:58,560
that

407
00:13:58,560 --> 00:14:01,680
he finds our hidden code but

408
00:14:01,680 --> 00:14:03,519
obviously this only works if we know

409
00:14:03,519 --> 00:14:05,519
upfront what we are searching for

410
00:14:05,519 --> 00:14:09,199
so it doesn't work as a generic method

411
00:14:09,199 --> 00:14:11,279
we also had a look at some dumping

412
00:14:11,279 --> 00:14:13,360
plugins so we dumped

413
00:14:13,360 --> 00:14:15,600
the memory content of the processes and

414
00:14:15,600 --> 00:14:17,680
only in the case of

415
00:14:17,680 --> 00:14:20,880
the mas remapping and only

416
00:14:20,880 --> 00:14:23,600
with volatility we were able to find our

417
00:14:23,600 --> 00:14:24,880
malicious code in there

418
00:14:24,880 --> 00:14:27,839
with the other tools and other plugins

419
00:14:27,839 --> 00:14:31,600
it was not the case and

420
00:14:31,600 --> 00:14:34,720
also we did find our malicious code by

421
00:14:34,720 --> 00:14:37,760
if we accessed it directly so if we used

422
00:14:37,760 --> 00:14:39,360
recall or volatility the interactive

423
00:14:39,360 --> 00:14:39,839
shell

424
00:14:39,839 --> 00:14:41,519
and the reach for the virtual address in

425
00:14:41,519 --> 00:14:43,360
this case also it was possible

426
00:14:43,360 --> 00:14:44,959
to detect the malicious memory but only

427
00:14:44,959 --> 00:14:48,160
in the case again for mas remapping

428
00:14:48,160 --> 00:14:51,680
and a third time again with pte num

429
00:14:51,680 --> 00:14:53,600
we were also able to find our engineer

430
00:14:53,600 --> 00:14:55,839
code for mes remapping

431
00:14:55,839 --> 00:14:58,000
but besides that in all other cases our

432
00:14:58,000 --> 00:14:59,279
malicious code

433
00:14:59,279 --> 00:15:02,800
was not found by any of those plugins

434
00:15:02,800 --> 00:15:04,639
in some cases there were some indicators

435
00:15:04,639 --> 00:15:06,160
that could

436
00:15:06,160 --> 00:15:07,920
maybe give you a hint about something

437
00:15:07,920 --> 00:15:09,920
fishy going on but the actual memory

438
00:15:09,920 --> 00:15:12,320
content was only detected in those cases

439
00:15:12,320 --> 00:15:15,120
that i mentioned earlier

440
00:15:15,120 --> 00:15:17,440
so from a live forensics point of view

441
00:15:17,440 --> 00:15:19,680
it gets a little bit worse

442
00:15:19,680 --> 00:15:22,079
on the one hand we also use the tools

443
00:15:22,079 --> 00:15:22,959
yara

444
00:15:22,959 --> 00:15:26,399
and scanned all the processes um

445
00:15:26,399 --> 00:15:28,399
none of our hidden memory has been

446
00:15:28,399 --> 00:15:30,160
detected by yara

447
00:15:30,160 --> 00:15:33,279
um we were able to detect our malicious

448
00:15:33,279 --> 00:15:33,920
content

449
00:15:33,920 --> 00:15:36,480
in the case of mas remapping again with

450
00:15:36,480 --> 00:15:37,040
the

451
00:15:37,040 --> 00:15:39,600
debugger but only on windows so with the

452
00:15:39,600 --> 00:15:40,880
wind debug

453
00:15:40,880 --> 00:15:42,959
tool we were we were able to find our

454
00:15:42,959 --> 00:15:45,120
manager's content by searching

455
00:15:45,120 --> 00:15:46,639
and also by directly accessing the

456
00:15:46,639 --> 00:15:48,720
visual addresses but besides that

457
00:15:48,720 --> 00:15:50,639
none of those approaches were able to

458
00:15:50,639 --> 00:15:52,160
find our

459
00:15:52,160 --> 00:15:56,160
hidden malicious code we tried

460
00:15:56,160 --> 00:15:57,920
dumping the process address space with

461
00:15:57,920 --> 00:16:00,240
debug with gdb within debug

462
00:16:00,240 --> 00:16:03,440
also used process explorer on g-core but

463
00:16:03,440 --> 00:16:05,440
our image's content wasn't in those

464
00:16:05,440 --> 00:16:07,759
dumps but at least in some cases there

465
00:16:07,759 --> 00:16:08,560
were errors

466
00:16:08,560 --> 00:16:10,240
um pointing out that some of the

467
00:16:10,240 --> 00:16:12,000
addresses seemed to be that

468
00:16:12,000 --> 00:16:13,360
seemed to be something wrong with them

469
00:16:13,360 --> 00:16:14,880
so there were some indicators but the

470
00:16:14,880 --> 00:16:16,160
actual memory content

471
00:16:16,160 --> 00:16:18,560
was only detected in those two cases for

472
00:16:18,560 --> 00:16:20,959
mes remapping and not in the other cases

473
00:16:20,959 --> 00:16:22,639
and also to mention the shared memory

474
00:16:22,639 --> 00:16:24,560
scenario with shem get

475
00:16:24,560 --> 00:16:27,519
on linux was not at all in any case in

476
00:16:27,519 --> 00:16:29,360
any way detected by any of those

477
00:16:29,360 --> 00:16:33,040
plugins or tools okay

478
00:16:33,040 --> 00:16:34,959
let's talk about some challenges and

479
00:16:34,959 --> 00:16:36,480
considerations some things that you have

480
00:16:36,480 --> 00:16:37,920
to consider when you're implementing and

481
00:16:37,920 --> 00:16:40,000
using those techniques

482
00:16:40,000 --> 00:16:42,079
and the one hand as mentioned earlier

483
00:16:42,079 --> 00:16:44,399
for pte subversions and chat memory

484
00:16:44,399 --> 00:16:46,639
we need still some control code that has

485
00:16:46,639 --> 00:16:48,079
to be somewhere so this could be

486
00:16:48,079 --> 00:16:49,759
detected

487
00:16:49,759 --> 00:16:51,199
in order to unhide and re-hide the

488
00:16:51,199 --> 00:16:53,680
memory we did also

489
00:16:53,680 --> 00:16:56,800
lock our memory in order to prevent any

490
00:16:56,800 --> 00:16:59,839
interferences from page swapping and

491
00:16:59,839 --> 00:17:03,040
also to prevent any side effects we

492
00:17:03,040 --> 00:17:05,439
are doing we are undoing all our

493
00:17:05,439 --> 00:17:06,640
modifications

494
00:17:06,640 --> 00:17:10,079
right before the process exits also

495
00:17:10,079 --> 00:17:11,199
especially on linux

496
00:17:11,199 --> 00:17:13,039
there are some fields that you want to

497
00:17:13,039 --> 00:17:14,400
have a look at and might

498
00:17:14,400 --> 00:17:16,240
in some cases have to that you might

499
00:17:16,240 --> 00:17:18,240
have to adjust in order to prevent side

500
00:17:18,240 --> 00:17:19,520
effects especially if you're not on

501
00:17:19,520 --> 00:17:20,959
doing the modifications

502
00:17:20,959 --> 00:17:22,160
then there are some counters that you

503
00:17:22,160 --> 00:17:24,559
might have a look at and might have to

504
00:17:24,559 --> 00:17:28,000
adjust in order to prevent any problems

505
00:17:28,000 --> 00:17:30,160
okay let's talk a little bit about a

506
00:17:30,160 --> 00:17:32,240
problem on windows with the standard pfn

507
00:17:32,240 --> 00:17:33,360
remapping

508
00:17:33,360 --> 00:17:35,520
so if we are doing the pfn remapping as

509
00:17:35,520 --> 00:17:36,799
explained earlier

510
00:17:36,799 --> 00:17:39,039
this will lead to crashes especially if

511
00:17:39,039 --> 00:17:40,240
we for example

512
00:17:40,240 --> 00:17:43,440
scan the process with yara then a pretty

513
00:17:43,440 --> 00:17:44,960
reliable crashes after

514
00:17:44,960 --> 00:17:48,000
the pfn remapping so we came up with a

515
00:17:48,000 --> 00:17:50,720
little work around in this case

516
00:17:50,720 --> 00:17:53,760
this is an initial situation so the pte

517
00:17:53,760 --> 00:17:56,640
points to a malicious memory and what we

518
00:17:56,640 --> 00:17:58,320
now do in order to prevent

519
00:17:58,320 --> 00:18:00,640
the detection is to in the first step to

520
00:18:00,640 --> 00:18:02,000
erase to

521
00:18:02,000 --> 00:18:05,360
erase it similar to the pta ratio but

522
00:18:05,360 --> 00:18:07,440
we added some additional steps so what

523
00:18:07,440 --> 00:18:09,360
we then do after that we are doing a

524
00:18:09,360 --> 00:18:11,280
read access to the switch address

525
00:18:11,280 --> 00:18:13,600
which will lead to the creation of a new

526
00:18:13,600 --> 00:18:14,799
page because the

527
00:18:14,799 --> 00:18:16,720
operating system will think um there has

528
00:18:16,720 --> 00:18:18,640
not yet been created any page for this

529
00:18:18,640 --> 00:18:21,440
um virtual address so we are creating it

530
00:18:21,440 --> 00:18:23,360
that means that after that we have two

531
00:18:23,360 --> 00:18:24,799
pages

532
00:18:24,799 --> 00:18:28,559
which relate on correspond to this pte

533
00:18:28,559 --> 00:18:31,039
and after that we are simply switching

534
00:18:31,039 --> 00:18:32,880
between those two pages

535
00:18:32,880 --> 00:18:34,320
in order to hide and unhide our

536
00:18:34,320 --> 00:18:36,320
malicious memory and by that we are

537
00:18:36,320 --> 00:18:38,480
preventing the process from crashing

538
00:18:38,480 --> 00:18:42,000
if yara scans it there's still some

539
00:18:42,000 --> 00:18:44,559
issue left with this approach at blue

540
00:18:44,559 --> 00:18:45,440
screens

541
00:18:45,440 --> 00:18:47,760
as soon as the process exits we have not

542
00:18:47,760 --> 00:18:49,440
yet identified what exactly is the

543
00:18:49,440 --> 00:18:50,799
problem with that so this is something

544
00:18:50,799 --> 00:18:51,760
to be done

545
00:18:51,760 --> 00:18:53,919
and will be hopefully fixed in the next

546
00:18:53,919 --> 00:18:56,799
few weeks or months

547
00:18:56,799 --> 00:18:58,640
so let's talk about memories of version

548
00:18:58,640 --> 00:19:00,160
detection

549
00:19:00,160 --> 00:19:02,799
first mas remapping detection what we

550
00:19:02,799 --> 00:19:03,679
are using here

551
00:19:03,679 --> 00:19:06,400
are the paging structures we are

552
00:19:06,400 --> 00:19:08,480
enumerating all the page tables

553
00:19:08,480 --> 00:19:11,280
and examining the page table entries

554
00:19:11,280 --> 00:19:13,360
each page table entry corresponds to a

555
00:19:13,360 --> 00:19:14,640
virtual address

556
00:19:14,640 --> 00:19:16,400
and by examining the page table entry we

557
00:19:16,400 --> 00:19:17,840
know which virtual addresses are

558
00:19:17,840 --> 00:19:19,200
currently valid so they

559
00:19:19,200 --> 00:19:21,280
are referencing page frames that are

560
00:19:21,280 --> 00:19:23,280
currently mapped

561
00:19:23,280 --> 00:19:25,679
and we can use this information to check

562
00:19:25,679 --> 00:19:27,440
whether or not they are

563
00:19:27,440 --> 00:19:29,520
virtual addresses which are not

564
00:19:29,520 --> 00:19:31,919
described by a vm area structure but are

565
00:19:31,919 --> 00:19:32,720
valid

566
00:19:32,720 --> 00:19:34,640
so in this case we have those two which

567
00:19:34,640 --> 00:19:37,600
addresses which seem to reference

568
00:19:37,600 --> 00:19:39,440
valid page frames so there's actually

569
00:19:39,440 --> 00:19:41,120
memory content behind them

570
00:19:41,120 --> 00:19:42,880
but they are not part of any mas

571
00:19:42,880 --> 00:19:44,480
structure so that's something suspicious

572
00:19:44,480 --> 00:19:47,360
which we alert on

573
00:19:47,840 --> 00:19:49,919
now the pt subversion detection on

574
00:19:49,919 --> 00:19:52,160
windows it's on linux

575
00:19:52,160 --> 00:19:55,919
different story so we are splitting this

576
00:19:55,919 --> 00:19:59,280
detection into parts on windows we now

577
00:19:59,280 --> 00:20:01,039
have here the initial situation

578
00:20:01,039 --> 00:20:03,600
so the messages pte points currently

579
00:20:03,600 --> 00:20:06,240
still to the malicious page and

580
00:20:06,240 --> 00:20:08,159
in this case here now we have also the

581
00:20:08,159 --> 00:20:09,440
physical point of view

582
00:20:09,440 --> 00:20:11,520
on the memory the phn database which we

583
00:20:11,520 --> 00:20:13,840
mentioned earlier briefly

584
00:20:13,840 --> 00:20:15,840
this is just an more or less just an

585
00:20:15,840 --> 00:20:18,720
array of mmpfn structs which are indexed

586
00:20:18,720 --> 00:20:20,400
by the pfn number

587
00:20:20,400 --> 00:20:22,480
so the pfn here points at the one hand

588
00:20:22,480 --> 00:20:24,159
through the page

589
00:20:24,159 --> 00:20:26,559
to the page frame and to a mmp of

590
00:20:26,559 --> 00:20:29,120
instruct over here

591
00:20:29,120 --> 00:20:32,480
each mmpf instruct for valid page

592
00:20:32,480 --> 00:20:36,000
also points back to the pte that

593
00:20:36,000 --> 00:20:39,120
belongs to it so we have here a kind of

594
00:20:39,120 --> 00:20:39,919
loop

595
00:20:39,919 --> 00:20:43,280
that points back and forth so we are now

596
00:20:43,280 --> 00:20:45,200
doing the pt remapping so we are

597
00:20:45,200 --> 00:20:47,120
changing the pfn value

598
00:20:47,120 --> 00:20:50,240
the pointers get modified

599
00:20:50,240 --> 00:20:51,919
so we are now pointing at the b9 page

600
00:20:51,919 --> 00:20:53,840
down here and we are also referencing

601
00:20:53,840 --> 00:20:54,400
another

602
00:20:54,400 --> 00:20:58,320
mmph instruct so that means we have

603
00:20:58,320 --> 00:21:00,240
a broken loop we have a valid loop down

604
00:21:00,240 --> 00:21:02,480
here because um this mmph instructor

605
00:21:02,480 --> 00:21:04,320
belongs to a valid page

606
00:21:04,320 --> 00:21:06,720
the benign patch is already there and we

607
00:21:06,720 --> 00:21:08,159
have a valid loop here

608
00:21:08,159 --> 00:21:10,480
but we have also the pointer from from

609
00:21:10,480 --> 00:21:11,600
over here

610
00:21:11,600 --> 00:21:14,000
which does not point back over here so

611
00:21:14,000 --> 00:21:16,400
this is something that we can detect on

612
00:21:16,400 --> 00:21:18,480
also by enumerating all the mmpf

613
00:21:18,480 --> 00:21:20,559
instructs we will encounter this one

614
00:21:20,559 --> 00:21:22,400
here which points to this pte

615
00:21:22,400 --> 00:21:24,400
but the pte does not point back so this

616
00:21:24,400 --> 00:21:27,840
is also something that we can detect

617
00:21:27,840 --> 00:21:30,400
and the third part here is the pfn

618
00:21:30,400 --> 00:21:32,559
number so by enumerating all the ptes

619
00:21:32,559 --> 00:21:33,760
and collecting all the page frame

620
00:21:33,760 --> 00:21:34,799
numbers

621
00:21:34,799 --> 00:21:37,919
we can detect duplicates

622
00:21:37,919 --> 00:21:41,360
and by that the pt remapping this only

623
00:21:41,360 --> 00:21:42,880
works for shared memory for private

624
00:21:42,880 --> 00:21:43,679
memory

625
00:21:43,679 --> 00:21:45,440
with shared memory this doesn't work

626
00:21:45,440 --> 00:21:46,960
because with chat memory it's quite

627
00:21:46,960 --> 00:21:49,200
common that multiple ptes

628
00:21:49,200 --> 00:21:51,679
point to the same page frame to the same

629
00:21:51,679 --> 00:21:52,960
page frame

630
00:21:52,960 --> 00:21:54,960
also this detection here does not work

631
00:21:54,960 --> 00:21:56,480
with shared memory because for shared

632
00:21:56,480 --> 00:21:57,200
memory

633
00:21:57,200 --> 00:21:59,919
those mmpfns don't point to this pt but

634
00:21:59,919 --> 00:22:02,159
to the prototype pte

635
00:22:02,159 --> 00:22:03,679
so we don't have this loop that we can

636
00:22:03,679 --> 00:22:06,000
detect on so this detections here

637
00:22:06,000 --> 00:22:08,799
only work with private memory on windows

638
00:22:08,799 --> 00:22:11,440
the detection that we will now see for

639
00:22:11,440 --> 00:22:14,080
in a few seconds on linux does work also

640
00:22:14,080 --> 00:22:16,720
with shared memory

641
00:22:16,720 --> 00:22:19,760
okay now the last slide for windows

642
00:22:19,760 --> 00:22:21,840
in this case we see now our motif or

643
00:22:21,840 --> 00:22:24,000
modified pte remapping

644
00:22:24,000 --> 00:22:26,400
because the original one as i said um

645
00:22:26,400 --> 00:22:28,240
crashes when yara is for example

646
00:22:28,240 --> 00:22:29,600
scanning the process

647
00:22:29,600 --> 00:22:31,120
so this is the situation the detection

648
00:22:31,120 --> 00:22:32,799
is more or less the same only the

649
00:22:32,799 --> 00:22:33,840
situation

650
00:22:33,840 --> 00:22:36,400
is a bit different so we can see now

651
00:22:36,400 --> 00:22:37,520
here um we have

652
00:22:37,520 --> 00:22:40,320
our pfn value which points at the second

653
00:22:40,320 --> 00:22:43,039
page which has been created for this pte

654
00:22:43,039 --> 00:22:45,840
so the uh also created mmpfn struct

655
00:22:45,840 --> 00:22:48,080
points back to this pt so this loop here

656
00:22:48,080 --> 00:22:48,799
is fine

657
00:22:48,799 --> 00:22:50,400
it points back and forth validly so

658
00:22:50,400 --> 00:22:52,400
there's nothing suspicious here

659
00:22:52,400 --> 00:22:54,799
but there are two um things to mention

660
00:22:54,799 --> 00:22:55,760
over here

661
00:22:55,760 --> 00:22:58,159
at the one hand we have again an mmp of

662
00:22:58,159 --> 00:22:59,679
n struct which points to this

663
00:22:59,679 --> 00:23:02,320
pte but this pt doesn't point back and

664
00:23:02,320 --> 00:23:03,520
also we have two

665
00:23:03,520 --> 00:23:06,320
mm pfn structs which point to the same

666
00:23:06,320 --> 00:23:07,200
pt

667
00:23:07,200 --> 00:23:08,960
so those are two characteristics that we

668
00:23:08,960 --> 00:23:11,760
can detect on

669
00:23:12,080 --> 00:23:15,600
okay let's now look at linux

670
00:23:15,600 --> 00:23:18,480
the physical the point of view on the

671
00:23:18,480 --> 00:23:19,760
physical memory

672
00:23:19,760 --> 00:23:22,720
on linux is are the page structures so

673
00:23:22,720 --> 00:23:24,080
there are several page structures which

674
00:23:24,080 --> 00:23:25,120
are more or less also

675
00:23:25,120 --> 00:23:28,240
indexed by the page frame number and by

676
00:23:28,240 --> 00:23:31,360
enumerating those we can collect

677
00:23:31,360 --> 00:23:33,039
pages which belong page structures which

678
00:23:33,039 --> 00:23:35,120
belong together and also physical pages

679
00:23:35,120 --> 00:23:36,559
by that manner

680
00:23:36,559 --> 00:23:39,200
this is done by looking at the mapping

681
00:23:39,200 --> 00:23:41,039
object that is referenced by those page

682
00:23:41,039 --> 00:23:41,919
structures

683
00:23:41,919 --> 00:23:43,679
this mapping object is also referenced

684
00:23:43,679 --> 00:23:45,520
by the vm area structures

685
00:23:45,520 --> 00:23:47,679
so by this mapping we can correlate

686
00:23:47,679 --> 00:23:48,720
pages

687
00:23:48,720 --> 00:23:50,480
with their corresponding vm area

688
00:23:50,480 --> 00:23:52,960
structures

689
00:23:53,440 --> 00:23:55,919
um a little thing to mention over here

690
00:23:55,919 --> 00:23:57,360
there can be multiple mappings

691
00:23:57,360 --> 00:24:00,400
per vm area structure and the one end

692
00:24:00,400 --> 00:24:02,320
mapping camera can be referenced by the

693
00:24:02,320 --> 00:24:04,320
f mapping so this is the case for

694
00:24:04,320 --> 00:24:06,880
files that are mapped and also in this

695
00:24:06,880 --> 00:24:08,480
case they can additionally be the n on

696
00:24:08,480 --> 00:24:09,840
vmat chain

697
00:24:09,840 --> 00:24:11,200
pointing to mappings there can be

698
00:24:11,200 --> 00:24:13,200
multiple ones this is especially the

699
00:24:13,200 --> 00:24:13,919
case

700
00:24:13,919 --> 00:24:16,640
when forking and when using copy and

701
00:24:16,640 --> 00:24:17,039
write

702
00:24:17,039 --> 00:24:19,679
protections and then getting private

703
00:24:19,679 --> 00:24:21,200
copies being created

704
00:24:21,200 --> 00:24:22,559
those are then referenced by those

705
00:24:22,559 --> 00:24:24,960
mappings so there can be multiple ones

706
00:24:24,960 --> 00:24:26,159
just something that we have to keep in

707
00:24:26,159 --> 00:24:28,240
mind when investigating this issue that

708
00:24:28,240 --> 00:24:29,200
we have to

709
00:24:29,200 --> 00:24:32,720
collect all of them behind those mapping

710
00:24:32,720 --> 00:24:33,120
is

711
00:24:33,120 --> 00:24:35,840
in this case for the nmn vma chain uh uh

712
00:24:35,840 --> 00:24:37,279
n on vma structs

713
00:24:37,279 --> 00:24:38,799
and for the f mapping it's an

714
00:24:38,799 --> 00:24:41,039
address-based struct but this detail

715
00:24:41,039 --> 00:24:42,400
doesn't really matter for us

716
00:24:42,400 --> 00:24:43,840
uh the only thing that we are interested

717
00:24:43,840 --> 00:24:46,159
in is are the um the

718
00:24:46,159 --> 00:24:48,159
object itself which we can use to

719
00:24:48,159 --> 00:24:50,000
correlate the page structures

720
00:24:50,000 --> 00:24:52,080
with the vm error structure so the

721
00:24:52,080 --> 00:24:53,039
fields of those

722
00:24:53,039 --> 00:24:54,880
mappings are not really interesting to

723
00:24:54,880 --> 00:24:57,760
us just the object itself

724
00:24:57,760 --> 00:25:00,000
okay now let's have a look at the other

725
00:25:00,000 --> 00:25:02,559
side so when we are now enumerating the

726
00:25:02,559 --> 00:25:04,960
which addresses foreign vm

727
00:25:04,960 --> 00:25:08,240
area struct we can resolve them to the

728
00:25:08,240 --> 00:25:10,240
page frame number and by that

729
00:25:10,240 --> 00:25:13,440
get the corresponding page structure and

730
00:25:13,440 --> 00:25:14,159
again we can

731
00:25:14,159 --> 00:25:17,679
um collect them based on the mapping

732
00:25:17,679 --> 00:25:19,120
and in this case we have three virtual

733
00:25:19,120 --> 00:25:20,799
addresses with the

734
00:25:20,799 --> 00:25:22,480
three page structures which belong to

735
00:25:22,480 --> 00:25:24,240
this mapping which also corresponds to

736
00:25:24,240 --> 00:25:24,559
the

737
00:25:24,559 --> 00:25:28,000
mapping for this vm error structure if

738
00:25:28,000 --> 00:25:28,960
we are now looking at

739
00:25:28,960 --> 00:25:31,919
our our attacks in this case the pt

740
00:25:31,919 --> 00:25:33,120
erasure

741
00:25:33,120 --> 00:25:34,640
the initial situation is that we have

742
00:25:34,640 --> 00:25:36,240
the analysis page over here which is

743
00:25:36,240 --> 00:25:37,440
still referenced

744
00:25:37,440 --> 00:25:40,559
now we are erasing the pte the pointer

745
00:25:40,559 --> 00:25:41,520
goes

746
00:25:41,520 --> 00:25:43,760
goes away and when we are enumerating

747
00:25:43,760 --> 00:25:45,360
the witcher addresses

748
00:25:45,360 --> 00:25:47,679
we now only get two pages because this

749
00:25:47,679 --> 00:25:49,120
one doesn't um

750
00:25:49,120 --> 00:25:50,799
belong to any page structure anymore

751
00:25:50,799 --> 00:25:53,440
because it doesn't have a corresponding

752
00:25:53,440 --> 00:25:56,400
pfn so when we are collecting those for

753
00:25:56,400 --> 00:25:56,720
this

754
00:25:56,720 --> 00:25:59,039
vm area for the witcher addresses we

755
00:25:59,039 --> 00:26:00,559
only get two pages

756
00:26:00,559 --> 00:26:03,600
for this mapping or with this mapping if

757
00:26:03,600 --> 00:26:05,039
we on the other hand

758
00:26:05,039 --> 00:26:06,960
enumerating all the page structures

759
00:26:06,960 --> 00:26:09,520
collecting them based on their mapping

760
00:26:09,520 --> 00:26:11,279
and then looking for each vm error

761
00:26:11,279 --> 00:26:13,440
struct for their corresponding mapping

762
00:26:13,440 --> 00:26:14,640
and the pages

763
00:26:14,640 --> 00:26:16,240
we will see that we will end up with

764
00:26:16,240 --> 00:26:18,799
three pages page structures

765
00:26:18,799 --> 00:26:21,120
so we can clearly see a diff two on the

766
00:26:21,120 --> 00:26:22,000
left side

767
00:26:22,000 --> 00:26:23,200
three on the right side and this is

768
00:26:23,200 --> 00:26:26,799
something suspicious which we alert

769
00:26:26,799 --> 00:26:29,600
so and the last step uh is our shared

770
00:26:29,600 --> 00:26:31,440
memory subversion detection

771
00:26:31,440 --> 00:26:32,880
it's small it's the same on linux and

772
00:26:32,880 --> 00:26:34,559
windows and we are basically just

773
00:26:34,559 --> 00:26:36,080
enumerating all the shared memory

774
00:26:36,080 --> 00:26:36,880
handles

775
00:26:36,880 --> 00:26:38,080
and looking for those which are

776
00:26:38,080 --> 00:26:39,520
currently not mapped into the original

777
00:26:39,520 --> 00:26:41,679
address space and alert on them

778
00:26:41,679 --> 00:26:43,440
on windows we are additionally checking

779
00:26:43,440 --> 00:26:45,440
for the executable permission

780
00:26:45,440 --> 00:26:47,360
so we are only alerting on executable

781
00:26:47,360 --> 00:26:49,039
memory because there would otherwise be

782
00:26:49,039 --> 00:26:50,640
a lot of false positives

783
00:26:50,640 --> 00:26:53,360
on linux we are not checking for the

784
00:26:53,360 --> 00:26:55,039
exitable state because it's a not a

785
00:26:55,039 --> 00:26:56,240
reliable way

786
00:26:56,240 --> 00:26:58,960
to detect this kind of memory and hence

787
00:26:58,960 --> 00:26:59,360
we

788
00:26:59,360 --> 00:27:01,039
also have some false puzzles on linux

789
00:27:01,039 --> 00:27:04,000
which we'll see later

790
00:27:04,000 --> 00:27:06,799
okay let's now talk about detection

791
00:27:06,799 --> 00:27:07,440
about the

792
00:27:07,440 --> 00:27:10,240
evaluation of our detection approaches

793
00:27:10,240 --> 00:27:11,919
we use the same environment as for the

794
00:27:11,919 --> 00:27:14,480
memory subversion evaluation

795
00:27:14,480 --> 00:27:16,240
additionally for the false positive

796
00:27:16,240 --> 00:27:18,080
positive evaluation we

797
00:27:18,080 --> 00:27:20,000
started several browsers office

798
00:27:20,000 --> 00:27:21,200
applications

799
00:27:21,200 --> 00:27:25,039
and also pdf documents and

800
00:27:25,039 --> 00:27:26,720
this will the results of that we will

801
00:27:26,720 --> 00:27:28,640
see a little bit later

802
00:27:28,640 --> 00:27:30,960
okay here are some some examples for

803
00:27:30,960 --> 00:27:32,320
detection on windows

804
00:27:32,320 --> 00:27:34,640
in the first case we have an output of

805
00:27:34,640 --> 00:27:37,120
our recoil plug-in for the standard pfn

806
00:27:37,120 --> 00:27:38,080
remapping

807
00:27:38,080 --> 00:27:40,320
so not our modified version so what

808
00:27:40,320 --> 00:27:42,559
would look would look like in the output

809
00:27:42,559 --> 00:27:45,039
if we would use the standard version and

810
00:27:45,039 --> 00:27:46,960
also for the pt erasure

811
00:27:46,960 --> 00:27:50,559
so the first two entries here are

812
00:27:50,559 --> 00:27:53,600
an output for the pfn remapping so we

813
00:27:53,600 --> 00:27:55,360
can see here in the dot pfn

814
00:27:55,360 --> 00:27:57,120
column that we have a true for the first

815
00:27:57,120 --> 00:27:59,360
two entries so there

816
00:27:59,360 --> 00:28:01,039
we can see also here in the pfn column

817
00:28:01,039 --> 00:28:02,399
that there's in fact

818
00:28:02,399 --> 00:28:05,120
the same pfn value for those two entries

819
00:28:05,120 --> 00:28:05,679
and what we

820
00:28:05,679 --> 00:28:08,080
also can see is a true value for the pte

821
00:28:08,080 --> 00:28:09,039
pointer div

822
00:28:09,039 --> 00:28:12,399
which means that the pte with its pfn

823
00:28:12,399 --> 00:28:14,880
points to a certain mmpf instruct

824
00:28:14,880 --> 00:28:17,520
but the mmp instruct doesn't point back

825
00:28:17,520 --> 00:28:18,320
so we have a

826
00:28:18,320 --> 00:28:20,480
diff over here and this also means that

827
00:28:20,480 --> 00:28:22,320
the second entry is the malicious one or

828
00:28:22,320 --> 00:28:24,000
most probably dimensionless one

829
00:28:24,000 --> 00:28:26,000
because it has the value true in this

830
00:28:26,000 --> 00:28:27,039
case

831
00:28:27,039 --> 00:28:30,080
and this the third entry is an example

832
00:28:30,080 --> 00:28:32,720
for the three zero for the pte erasure

833
00:28:32,720 --> 00:28:35,120
we have in the column zero pde a true

834
00:28:35,120 --> 00:28:37,279
uh we can also see that the pte value is

835
00:28:37,279 --> 00:28:38,880
actually zero

836
00:28:38,880 --> 00:28:41,919
and um this means that we have a mmpfn

837
00:28:41,919 --> 00:28:43,840
struct identified which is valid and

838
00:28:43,840 --> 00:28:45,360
points to a pte

839
00:28:45,360 --> 00:28:47,520
which however has a pt value of zero

840
00:28:47,520 --> 00:28:48,880
which shouldn't be the case and this is

841
00:28:48,880 --> 00:28:49,679
something that is

842
00:28:49,679 --> 00:28:52,320
detected over here and the second

843
00:28:52,320 --> 00:28:53,600
example is an

844
00:28:53,600 --> 00:28:55,760
example output for mas remapping so in

845
00:28:55,760 --> 00:28:57,520
this case we have in the column

846
00:28:57,520 --> 00:28:59,840
orphaned page a true value for those two

847
00:28:59,840 --> 00:29:00,960
virtual addresses

848
00:29:00,960 --> 00:29:02,960
which means that they are currently

849
00:29:02,960 --> 00:29:05,200
valid but not described by any

850
00:29:05,200 --> 00:29:09,200
mas here are some examples for

851
00:29:09,200 --> 00:29:12,399
the evaluation on linux first pte

852
00:29:12,399 --> 00:29:13,520
remapping

853
00:29:13,520 --> 00:29:16,720
so here we can see output essentially

854
00:29:16,720 --> 00:29:18,240
two mappings that

855
00:29:18,240 --> 00:29:20,399
have been identified by our plugins the

856
00:29:20,399 --> 00:29:22,000
first case is in

857
00:29:22,000 --> 00:29:24,880
false positive so we have in the systemd

858
00:29:24,880 --> 00:29:26,320
journal process we have

859
00:29:26,320 --> 00:29:29,120
some mappings that are reported here but

860
00:29:29,120 --> 00:29:29,840
it

861
00:29:29,840 --> 00:29:31,919
is not an attack so it's no subversion

862
00:29:31,919 --> 00:29:32,960
technique that has been

863
00:29:32,960 --> 00:29:35,039
resolved for this so in linux we have

864
00:29:35,039 --> 00:29:37,440
quite some false processes in some cases

865
00:29:37,440 --> 00:29:39,919
but the second output is in fact a

866
00:29:39,919 --> 00:29:42,240
result of our pte subversion

867
00:29:42,240 --> 00:29:45,919
attack so we have two pages

868
00:29:45,919 --> 00:29:49,200
which are not referenced by the virtual

869
00:29:49,200 --> 00:29:50,320
addresses but are

870
00:29:50,320 --> 00:29:53,440
part of the page structures so this is

871
00:29:53,440 --> 00:29:56,399
detected over here and the last output

872
00:29:56,399 --> 00:29:58,159
here is an example for shared memory on

873
00:29:58,159 --> 00:29:59,440
linux in this case

874
00:29:59,440 --> 00:30:01,760
so we have a shared memory handle which

875
00:30:01,760 --> 00:30:04,080
is currently not mapped in any process

876
00:30:04,080 --> 00:30:06,840
or not in this process so this is

877
00:30:06,840 --> 00:30:09,440
reported

878
00:30:09,440 --> 00:30:10,960
okay now let's have a look at false

879
00:30:10,960 --> 00:30:13,279
positives first windows

880
00:30:13,279 --> 00:30:15,919
regarding mes remapping there have been

881
00:30:15,919 --> 00:30:17,120
some false positives

882
00:30:17,120 --> 00:30:20,159
in the context of chromium so

883
00:30:20,159 --> 00:30:21,840
there were pages which are not described

884
00:30:21,840 --> 00:30:23,360
by any mes structure which is

885
00:30:23,360 --> 00:30:25,120
interesting and we

886
00:30:25,120 --> 00:30:27,520
are planning to have a closer look at

887
00:30:27,520 --> 00:30:29,360
regarding pd sub versions

888
00:30:29,360 --> 00:30:31,440
there are no false poses at the moment

889
00:30:31,440 --> 00:30:32,720
known at least we didn't

890
00:30:32,720 --> 00:30:35,440
find any in our test environments and

891
00:30:35,440 --> 00:30:36,640
regarding shared memory

892
00:30:36,640 --> 00:30:39,760
subversion there can be false positives

893
00:30:39,760 --> 00:30:42,799
obviously if the process has a shared

894
00:30:42,799 --> 00:30:43,840
memory handle but

895
00:30:43,840 --> 00:30:46,159
does not have this memory mapped into

896
00:30:46,159 --> 00:30:47,760
its address space

897
00:30:47,760 --> 00:30:49,279
but in our test environment we did not

898
00:30:49,279 --> 00:30:51,919
encounter any shard memory

899
00:30:51,919 --> 00:30:54,080
segment that is executable or not mapped

900
00:30:54,080 --> 00:30:56,559
at the moment

901
00:30:56,880 --> 00:30:59,200
with linux mis remapping is not

902
00:30:59,200 --> 00:31:00,399
implemented yet so

903
00:31:00,399 --> 00:31:03,279
we can't make any statements there pd

904
00:31:03,279 --> 00:31:04,000
subversion

905
00:31:04,000 --> 00:31:06,000
on linux there were quite some false

906
00:31:06,000 --> 00:31:08,640
positives especially for the firefox

907
00:31:08,640 --> 00:31:11,440
and for the systemd journal process so

908
00:31:11,440 --> 00:31:12,480
this is something that we

909
00:31:12,480 --> 00:31:15,279
are trying to optimize in the next time

910
00:31:15,279 --> 00:31:16,000
some

911
00:31:16,000 --> 00:31:17,679
hopefully we'll come up with a solution

912
00:31:17,679 --> 00:31:20,000
for that and regarding essentially the

913
00:31:20,000 --> 00:31:21,600
shared memory subversion

914
00:31:21,600 --> 00:31:24,080
uh in our test cases uh also again with

915
00:31:24,080 --> 00:31:26,080
the firefox we had quite some

916
00:31:26,080 --> 00:31:29,039
false positives 40 shared memory

917
00:31:29,039 --> 00:31:30,840
segments that were reported by our

918
00:31:30,840 --> 00:31:32,240
plugin

919
00:31:32,240 --> 00:31:34,480
so it's also something where we might be

920
00:31:34,480 --> 00:31:36,720
able hopefully in the future to

921
00:31:36,720 --> 00:31:39,919
improve the output okay let's come to

922
00:31:39,919 --> 00:31:41,360
the conclusion

923
00:31:41,360 --> 00:31:44,000
here we can see a simple short

924
00:31:44,000 --> 00:31:45,200
comparison

925
00:31:45,200 --> 00:31:47,039
of the techniques from a ticker's point

926
00:31:47,039 --> 00:31:48,559
of view we already mentioned

927
00:31:48,559 --> 00:31:50,799
all the advantages and disadvantages so

928
00:31:50,799 --> 00:31:53,519
it's just for the documentation

929
00:31:53,519 --> 00:31:56,320
to conclude with this research and with

930
00:31:56,320 --> 00:31:57,039
this talk we

931
00:31:57,039 --> 00:31:59,200
introduced three novel subversion

932
00:31:59,200 --> 00:32:00,159
techniques

933
00:32:00,159 --> 00:32:02,640
which are able to hide memory from

934
00:32:02,640 --> 00:32:04,240
memory and live forensics on windows and

935
00:32:04,240 --> 00:32:05,679
linux

936
00:32:05,679 --> 00:32:07,519
we are releasing with this talk also

937
00:32:07,519 --> 00:32:08,960
some proof of concept implementations

938
00:32:08,960 --> 00:32:10,240
for both operating systems

939
00:32:10,240 --> 00:32:12,559
that implement our subversion techniques

940
00:32:12,559 --> 00:32:14,640
and our plugins

941
00:32:14,640 --> 00:32:16,080
the recall and volatility plugins that

942
00:32:16,080 --> 00:32:18,320
we've implemented which are applying the

943
00:32:18,320 --> 00:32:19,679
detection approaches which

944
00:32:19,679 --> 00:32:22,799
we have described in this talk and those

945
00:32:22,799 --> 00:32:23,360
are all

946
00:32:23,360 --> 00:32:26,480
referenced in the next slides where you

947
00:32:26,480 --> 00:32:26,799
can

948
00:32:26,799 --> 00:32:30,320
grab them some limitations

949
00:32:30,320 --> 00:32:32,799
um we still have the issue for the

950
00:32:32,799 --> 00:32:34,320
subversion with the blue screen and

951
00:32:34,320 --> 00:32:34,960
windows

952
00:32:34,960 --> 00:32:36,799
with our pd subversions so this is

953
00:32:36,799 --> 00:32:38,960
something that we need to

954
00:32:38,960 --> 00:32:42,080
fix also the detection approaches for

955
00:32:42,080 --> 00:32:43,679
the pt subversions on windows

956
00:32:43,679 --> 00:32:46,960
can be circumvented by shared memory by

957
00:32:46,960 --> 00:32:48,159
the usage of chat memory

958
00:32:48,159 --> 00:32:50,720
so there's something that we have uh in

959
00:32:50,720 --> 00:32:52,720
the future to have a closer look at

960
00:32:52,720 --> 00:32:54,000
also there were quite some false

961
00:32:54,000 --> 00:32:56,320
positives with windows with linux

962
00:32:56,320 --> 00:32:59,039
with the detections so that's something

963
00:32:59,039 --> 00:32:59,919
that's not

964
00:32:59,919 --> 00:33:02,320
ideal at the moment also an additional

965
00:33:02,320 --> 00:33:04,240
problem in linux there can be page

966
00:33:04,240 --> 00:33:07,200
instances so paid structure instances

967
00:33:07,200 --> 00:33:08,559
that have no

968
00:33:08,559 --> 00:33:11,679
corresponding mapping and by that

969
00:33:11,679 --> 00:33:13,200
it's not possible for us at the moment

970
00:33:13,200 --> 00:33:15,200
to attack those

971
00:33:15,200 --> 00:33:17,039
pages with in regards to subversion

972
00:33:17,039 --> 00:33:18,240
techniques

973
00:33:18,240 --> 00:33:21,600
and also again on linux our ptc version

974
00:33:21,600 --> 00:33:23,519
detection implementation is at the

975
00:33:23,519 --> 00:33:25,760
moment quite

976
00:33:25,760 --> 00:33:28,320
time consuming the main reason is that

977
00:33:28,320 --> 00:33:29,360
we

978
00:33:29,360 --> 00:33:31,039
have not yet implemented the ms

979
00:33:31,039 --> 00:33:32,960
remapping detection because the same

980
00:33:32,960 --> 00:33:33,760
approach

981
00:33:33,760 --> 00:33:36,480
for that is also used to speed up the pd

982
00:33:36,480 --> 00:33:37,200
subversion

983
00:33:37,200 --> 00:33:39,279
so as soon as we have implemented that

984
00:33:39,279 --> 00:33:40,799
also the pd subversion detection should

985
00:33:40,799 --> 00:33:42,799
be faster but at the moment it's quite

986
00:33:42,799 --> 00:33:47,840
slow okay some words to future work

987
00:33:47,840 --> 00:33:49,519
one thing that we want to have a closer

988
00:33:49,519 --> 00:33:51,360
look at is different ways

989
00:33:51,360 --> 00:33:53,840
for mapping shared memory especially

990
00:33:53,840 --> 00:33:55,200
using subfuse

991
00:33:55,200 --> 00:33:58,559
and by that maybe circumventing our

992
00:33:58,559 --> 00:34:00,399
detection approaches

993
00:34:00,399 --> 00:34:02,320
also we want to resolve the windows

994
00:34:02,320 --> 00:34:03,600
crash obviously

995
00:34:03,600 --> 00:34:06,080
and we are also wanting to have a closer

996
00:34:06,080 --> 00:34:06,960
look at the

997
00:34:06,960 --> 00:34:09,599
new windows 10 memory combining feature

998
00:34:09,599 --> 00:34:11,040
so this might be something that

999
00:34:11,040 --> 00:34:12,480
interferes with our detection and

1000
00:34:12,480 --> 00:34:13,440
subversion

1001
00:34:13,440 --> 00:34:15,440
techniques and we should have a closer

1002
00:34:15,440 --> 00:34:16,560
look at

1003
00:34:16,560 --> 00:34:18,719
and last but not least manipulating

1004
00:34:18,719 --> 00:34:20,879
everything that we've used for detection

1005
00:34:20,879 --> 00:34:21,359
so far

1006
00:34:21,359 --> 00:34:24,399
so the mmp mmp fans drugs paid

1007
00:34:24,399 --> 00:34:25,839
structures

1008
00:34:25,839 --> 00:34:27,679
messing with those might be interesting

1009
00:34:27,679 --> 00:34:30,239
to look at in order to

1010
00:34:30,239 --> 00:34:31,679
prevent the detection from being

1011
00:34:31,679 --> 00:34:33,599
successful

1012
00:34:33,599 --> 00:34:36,159
so with that thank you for attention if

1013
00:34:36,159 --> 00:34:37,520
there are any questions hopefully we

1014
00:34:37,520 --> 00:34:38,879
have some time for them

1015
00:34:38,879 --> 00:34:41,040
here are the resources so all the links

1016
00:34:41,040 --> 00:34:43,199
to all the proof concept implementations

1017
00:34:43,199 --> 00:34:44,480
and plugins

1018
00:34:44,480 --> 00:34:49,040
and with that are there any questions

1019
00:34:49,040 --> 00:34:52,000
okay hello everybody i hope you can hear

1020
00:34:52,000 --> 00:34:52,879
me fine

1021
00:34:52,879 --> 00:34:54,800
i'm not sure if it's working right now

1022
00:34:54,800 --> 00:34:59,119
because my screen freaks here

1023
00:34:59,920 --> 00:35:03,839
and now i see there's a movement

1024
00:35:07,680 --> 00:35:10,240
yeah hello

1025
00:35:12,640 --> 00:35:14,880
yeah i started to talk but i'm not sure

1026
00:35:14,880 --> 00:35:16,240
if everybody can hear me

1027
00:35:16,240 --> 00:35:18,160
maybe in the chat someone can tell me if

1028
00:35:18,160 --> 00:35:30,240
you hear me fine

1029
00:35:30,240 --> 00:35:33,119
but do they hear me because i don't see

1030
00:35:33,119 --> 00:35:36,400
any reactions in the chat

1031
00:35:37,040 --> 00:35:45,040
okay yeah

1032
00:35:45,040 --> 00:35:47,599
hello so if there are any questions feel

1033
00:35:47,599 --> 00:35:50,079
free to

1034
00:35:50,160 --> 00:35:54,000
do it in the chat um

1035
00:35:54,320 --> 00:35:56,320
otherwise thank you for your attention

1036
00:35:56,320 --> 00:35:57,839
hope you enjoyed the talk and the rest

1037
00:35:57,839 --> 00:36:00,560
of the conference

1038
00:36:02,640 --> 00:36:13,839
oh yeah okay now

1039
00:36:14,400 --> 00:36:17,119
yeah thank you let's see now that you

1040
00:36:17,119 --> 00:36:17,920
can hear me

1041
00:36:17,920 --> 00:36:20,079
i had a little delay in the chat so i

1042
00:36:20,079 --> 00:36:21,119
was not sure okay

1043
00:36:21,119 --> 00:36:27,839
thank you very much

1044
00:36:29,440 --> 00:36:33,280
i don't see any questions right now

1045
00:36:33,280 --> 00:36:36,079
then yeah feel free to contact me um

1046
00:36:36,079 --> 00:36:36,960
there's some

1047
00:36:36,960 --> 00:36:39,760
coding information in the github page

1048
00:36:39,760 --> 00:36:41,040
feel free to email me

1049
00:36:41,040 --> 00:36:43,680
uh my linkedin handle should also be in

1050
00:36:43,680 --> 00:36:45,359
my profile so

1051
00:36:45,359 --> 00:36:46,880
yeah if there are any further questions

1052
00:36:46,880 --> 00:36:48,640
later on feel free to

1053
00:36:48,640 --> 00:36:51,599
uh question and put a question somewhere

1054
00:36:51,599 --> 00:36:52,400
in the

1055
00:36:52,400 --> 00:36:55,680
mobile world uh otherwise

1056
00:36:55,680 --> 00:36:59,040
yeah enjoy the rest of the conference

1057
00:36:59,040 --> 00:37:01,200
see

1058
00:37:06,800 --> 00:37:09,839
you too thank you

