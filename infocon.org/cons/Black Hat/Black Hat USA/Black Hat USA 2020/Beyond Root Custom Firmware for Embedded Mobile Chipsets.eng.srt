1
00:00:03,860 --> 00:00:13,658
[Music]

2
00:00:15,280 --> 00:00:16,560
hello everyone my name is christopher

3
00:00:16,560 --> 00:00:17,520
wade and we're going to

4
00:00:17,520 --> 00:00:20,080
talk about embedded mobile chipsets

5
00:00:20,080 --> 00:00:21,359
today and how you can write customer

6
00:00:21,359 --> 00:00:23,279
firmware for them

7
00:00:23,279 --> 00:00:25,279
i am a security consultant at pen test

8
00:00:25,279 --> 00:00:26,320
partners where i mainly work with

9
00:00:26,320 --> 00:00:27,840
automotive hardware and maritime

10
00:00:27,840 --> 00:00:28,480
equipment

11
00:00:28,480 --> 00:00:29,439
but today we're going to be talking

12
00:00:29,439 --> 00:00:31,279
about embedded chipsets in their

13
00:00:31,279 --> 00:00:34,239
entirety especially on mobile devices

14
00:00:34,239 --> 00:00:35,680
the origin of this project was that i

15
00:00:35,680 --> 00:00:37,520
had rooted several phones and found that

16
00:00:37,520 --> 00:00:39,200
while i could modify certain aspects of

17
00:00:39,200 --> 00:00:40,879
the operating system i couldn't modify

18
00:00:40,879 --> 00:00:42,320
the hardware capabilities of them in any

19
00:00:42,320 --> 00:00:43,280
meaningful manner

20
00:00:43,280 --> 00:00:44,640
while it was still possible in certain

21
00:00:44,640 --> 00:00:46,480
ways it was not possible in

22
00:00:46,480 --> 00:00:48,239
their entirety so it couldn't modify

23
00:00:48,239 --> 00:00:49,680
certain closed-sourced

24
00:00:49,680 --> 00:00:51,360
enclosed hardware elements of the

25
00:00:51,360 --> 00:00:52,879
devices such as

26
00:00:52,879 --> 00:00:55,840
hardware peripherals such as bluetooth

27
00:00:55,840 --> 00:00:57,680
while it is possible via um

28
00:00:57,680 --> 00:01:00,000
certain kernel modifications or changes

29
00:01:00,000 --> 00:01:01,199
to configurations to

30
00:01:01,199 --> 00:01:03,039
get monitor mode it does require a

31
00:01:03,039 --> 00:01:04,879
custom firmware for things like broadcom

32
00:01:04,879 --> 00:01:06,320
chipsets

33
00:01:06,320 --> 00:01:08,000
the usb device emulation as well is

34
00:01:08,000 --> 00:01:09,439
quite an interesting uh

35
00:01:09,439 --> 00:01:11,280
feature that can be added to on android

36
00:01:11,280 --> 00:01:13,200
phones with a certain amount of effort

37
00:01:13,200 --> 00:01:15,040
if you modify your kernel so that it

38
00:01:15,040 --> 00:01:15,759
implements

39
00:01:15,759 --> 00:01:18,080
all the usb functionality modules that

40
00:01:18,080 --> 00:01:19,520
you want instead of just the static one

41
00:01:19,520 --> 00:01:20,479
for android

42
00:01:20,479 --> 00:01:22,320
you can implement things like gadget fs

43
00:01:22,320 --> 00:01:23,520
which allows you to emulate

44
00:01:23,520 --> 00:01:25,840
any kind of usb device you want to fire

45
00:01:25,840 --> 00:01:28,479
user space applications

46
00:01:28,479 --> 00:01:30,079
but i want to talk about nfc more than

47
00:01:30,079 --> 00:01:31,600
anything which is something i'm very

48
00:01:31,600 --> 00:01:32,400
interested in

49
00:01:32,400 --> 00:01:34,400
and is quite limited on android hardware

50
00:01:34,400 --> 00:01:35,680
as it is

51
00:01:35,680 --> 00:01:38,079
for instance on android even with root

52
00:01:38,079 --> 00:01:38,960
access you're

53
00:01:38,960 --> 00:01:41,040
limited to generic reading mobile

54
00:01:41,040 --> 00:01:42,399
payments and death communication and

55
00:01:42,399 --> 00:01:43,600
host card communication

56
00:01:43,600 --> 00:01:45,280
the last of which is communication that

57
00:01:45,280 --> 00:01:46,880
allows you to emulate certain amounts of

58
00:01:46,880 --> 00:01:49,520
nfc attacks but not in their entirety

59
00:01:49,520 --> 00:01:50,720
well this allows you to do certain

60
00:01:50,720 --> 00:01:52,240
things like relay attacks which may be

61
00:01:52,240 --> 00:01:52,880
useful

62
00:01:52,880 --> 00:01:54,240
for an attacker who wants to commit

63
00:01:54,240 --> 00:01:56,640
fraud etcetera it's not very useful for

64
00:01:56,640 --> 00:02:00,079
other use cases if you were to make an

65
00:02:00,079 --> 00:02:01,840
nfc attack tool you'd want to implement

66
00:02:01,840 --> 00:02:03,040
slightly more complex

67
00:02:03,040 --> 00:02:05,840
functionality such as emulation of a

68
00:02:05,840 --> 00:02:08,318
reader to attack cryptography on an nfc

69
00:02:08,318 --> 00:02:08,878
tag

70
00:02:08,878 --> 00:02:10,878
or emulate the tag itself in order to

71
00:02:10,878 --> 00:02:12,319
perform attacks that are only possible

72
00:02:12,319 --> 00:02:13,680
from that endpoint

73
00:02:13,680 --> 00:02:15,280
or you may want to be able to passively

74
00:02:15,280 --> 00:02:16,640
sniff tags like you would with a prox

75
00:02:16,640 --> 00:02:18,959
mark or a chameleon device

76
00:02:18,959 --> 00:02:20,879
my first target was my samsung s6 which

77
00:02:20,879 --> 00:02:22,319
is quite an old phone but one i had

78
00:02:22,319 --> 00:02:23,280
readily available

79
00:02:23,280 --> 00:02:25,599
and unlocked using the standard samsung

80
00:02:25,599 --> 00:02:26,959
oem unlocking and custom rom

81
00:02:26,959 --> 00:02:28,080
functionality

82
00:02:28,080 --> 00:02:30,000
i found that in my samsung device which

83
00:02:30,000 --> 00:02:31,200
was a non-us

84
00:02:31,200 --> 00:02:34,319
phone it had a samsung semiconductor nfc

85
00:02:34,319 --> 00:02:35,599
chip that was completely custom and

86
00:02:35,599 --> 00:02:38,160
developed by samsung for their devices

87
00:02:38,160 --> 00:02:41,200
this was called the s3fw rn5

88
00:02:41,200 --> 00:02:42,720
which was a custom chip developed by

89
00:02:42,720 --> 00:02:44,400
samsung semiconductor

90
00:02:44,400 --> 00:02:46,080
it has the ability to update firmware

91
00:02:46,080 --> 00:02:47,760
security securely

92
00:02:47,760 --> 00:02:50,160
and is found in samsung s6's and samsung

93
00:02:50,160 --> 00:02:51,920
note 4 devices which are were

94
00:02:51,920 --> 00:02:54,720
manufactured in 2014 and 2015.

95
00:02:54,720 --> 00:02:57,360
it was found to use an arm sc-00 secure

96
00:02:57,360 --> 00:02:58,879
car architecture which is a

97
00:02:58,879 --> 00:03:00,560
embedded arm architecture used for

98
00:03:00,560 --> 00:03:02,800
secure applications and was communicated

99
00:03:02,800 --> 00:03:04,159
with on the phone via

100
00:03:04,159 --> 00:03:06,879
custom device drivers which communicate

101
00:03:06,879 --> 00:03:08,720
with the i2c and gpio interfaces of the

102
00:03:08,720 --> 00:03:10,720
device

103
00:03:10,720 --> 00:03:12,560
inside communication which is how nfc

104
00:03:12,560 --> 00:03:14,720
chips are communicated with via

105
00:03:14,720 --> 00:03:18,319
host devices is quite a simple protocol

106
00:03:18,319 --> 00:03:20,800
essentially you have a group id

107
00:03:20,800 --> 00:03:21,760
operation id

108
00:03:21,760 --> 00:03:22,959
length and payload which are used in

109
00:03:22,959 --> 00:03:24,879
conjunction to configure certain

110
00:03:24,879 --> 00:03:25,440
settings

111
00:03:25,440 --> 00:03:27,360
or to read certain data from the device

112
00:03:27,360 --> 00:03:29,360
in order to configure specific

113
00:03:29,360 --> 00:03:31,519
nfc functionality while this does make

114
00:03:31,519 --> 00:03:33,440
nfc quite simple it also restricts it

115
00:03:33,440 --> 00:03:34,879
quite heavily

116
00:03:34,879 --> 00:03:36,400
there's also non-standard functionality

117
00:03:36,400 --> 00:03:38,400
built into this protocol however such as

118
00:03:38,400 --> 00:03:40,720
vendor group ids which are group ids

119
00:03:40,720 --> 00:03:42,159
which allow a vendor to implement any

120
00:03:42,159 --> 00:03:43,680
functionality they need whatsoever

121
00:03:43,680 --> 00:03:45,280
they may use this for configuration of

122
00:03:45,280 --> 00:03:47,120
certain hardware that's not standard

123
00:03:47,120 --> 00:03:49,120
or they may use it to add certain

124
00:03:49,120 --> 00:03:50,720
debugging functionality that they'd want

125
00:03:50,720 --> 00:03:52,480
later on in the project

126
00:03:52,480 --> 00:03:54,879
but what this is never used for is

127
00:03:54,879 --> 00:03:56,159
firmware updates which

128
00:03:56,159 --> 00:03:58,959
is a key aspect of any embedded chipset

129
00:03:58,959 --> 00:04:00,319
the device itself

130
00:04:00,319 --> 00:04:02,799
is was found to set whether it was in

131
00:04:02,799 --> 00:04:03,599
bootloader

132
00:04:03,599 --> 00:04:05,599
for firmware updates or regular mode via

133
00:04:05,599 --> 00:04:07,680
a gpio input which could be set by the

134
00:04:07,680 --> 00:04:08,400
driver

135
00:04:08,400 --> 00:04:10,480
and i found that when you switched it

136
00:04:10,480 --> 00:04:11,920
into bootloader mode it had a slightly

137
00:04:11,920 --> 00:04:13,519
different

138
00:04:13,519 --> 00:04:15,920
protocol than nci but only slightly

139
00:04:15,920 --> 00:04:16,798
different

140
00:04:16,798 --> 00:04:18,399
what was this was used for was to

141
00:04:18,399 --> 00:04:20,639
differentiate differentiate itself from

142
00:04:20,639 --> 00:04:21,440
nci

143
00:04:21,440 --> 00:04:25,280
in order to allow the vendor partition

144
00:04:25,280 --> 00:04:27,040
and the vendor implementations of

145
00:04:27,040 --> 00:04:28,720
certain aspects of the firmware

146
00:04:28,720 --> 00:04:31,440
to upload update this chipset and use it

147
00:04:31,440 --> 00:04:31,759
to

148
00:04:31,759 --> 00:04:34,720
do different things this firmware update

149
00:04:34,720 --> 00:04:36,240
protocol was quite simple i pulled these

150
00:04:36,240 --> 00:04:37,680
traces from logcat just by running

151
00:04:37,680 --> 00:04:39,919
logcat while doing a firmware update

152
00:04:39,919 --> 00:04:41,840
and found that it was made up of a

153
00:04:41,840 --> 00:04:43,120
command type which was

154
00:04:43,120 --> 00:04:45,600
usually zero one or two a command which

155
00:04:45,600 --> 00:04:46,240
was uh

156
00:04:46,240 --> 00:04:48,400
based on what aspect of the firmware

157
00:04:48,400 --> 00:04:49,360
update was being performed

158
00:04:49,360 --> 00:04:51,360
and the payload size which was two bytes

159
00:04:51,360 --> 00:04:53,360
but was limited to only 256 bytes in

160
00:04:53,360 --> 00:04:54,160
total

161
00:04:54,160 --> 00:04:55,919
as well as a parity bit at the top of

162
00:04:55,919 --> 00:04:57,759
each command and

163
00:04:57,759 --> 00:04:59,520
type in order to set where they were in

164
00:04:59,520 --> 00:05:02,080
the firmware update process

165
00:05:02,080 --> 00:05:03,440
the firmware update files used had a

166
00:05:03,440 --> 00:05:05,440
very basic format they had some metadata

167
00:05:05,440 --> 00:05:07,759
highlighted in red which was the date

168
00:05:07,759 --> 00:05:08,639
that the

169
00:05:08,639 --> 00:05:11,280
firmware was made a signature which is

170
00:05:11,280 --> 00:05:12,880
highlighted in green which was just

171
00:05:12,880 --> 00:05:15,759
a simple rsa signature and highlighted

172
00:05:15,759 --> 00:05:17,280
in blue was the start of the firmware

173
00:05:17,280 --> 00:05:19,360
which i found to be standard

174
00:05:19,360 --> 00:05:23,840
arm update firmware there's a way to um

175
00:05:23,840 --> 00:05:25,680
identify this quite quickly just by

176
00:05:25,680 --> 00:05:27,120
using a simple mnemonic

177
00:05:27,120 --> 00:05:29,199
if you run strings on a firmware update

178
00:05:29,199 --> 00:05:30,320
that's unencrypted

179
00:05:30,320 --> 00:05:32,320
and search for the uh string the

180
00:05:32,320 --> 00:05:34,479
characters lowercase p and upcase g

181
00:05:34,479 --> 00:05:36,240
you'll quickly find that a lot of these

182
00:05:36,240 --> 00:05:38,000
get dumped out if it is using some

183
00:05:38,000 --> 00:05:40,960
code which is the shortened architecture

184
00:05:40,960 --> 00:05:42,160
used by arm

185
00:05:42,160 --> 00:05:44,560
because lowercase p and upcase g

186
00:05:44,560 --> 00:05:46,960
translates to 1747 in ascii

187
00:05:46,960 --> 00:05:50,560
which is the the xlr or branch and link

188
00:05:50,560 --> 00:05:54,240
operation used by uh

189
00:05:54,240 --> 00:05:56,400
armed devices in order to return from

190
00:05:56,400 --> 00:05:57,280
functions

191
00:05:57,280 --> 00:06:00,319
you can quickly identify lots of areas

192
00:06:00,319 --> 00:06:01,280
where this has been

193
00:06:01,280 --> 00:06:04,720
used when this is found in

194
00:06:04,720 --> 00:06:06,160
large quantities it usually means that

195
00:06:06,160 --> 00:06:09,120
it's using arm firmware

196
00:06:09,120 --> 00:06:10,560
a good way to implement firmware updates

197
00:06:10,560 --> 00:06:11,759
is just by you replaying all the

198
00:06:11,759 --> 00:06:13,440
commands that you've dumped in sequence

199
00:06:13,440 --> 00:06:14,639
you don't necessarily need to know how

200
00:06:14,639 --> 00:06:15,840
the protocol works as long as you can

201
00:06:15,840 --> 00:06:17,440
send commands in exactly the same orders

202
00:06:17,440 --> 00:06:18,240
they sent before

203
00:06:18,240 --> 00:06:19,759
these things are usually immutable just

204
00:06:19,759 --> 00:06:22,080
due to how the signature checking and

205
00:06:22,080 --> 00:06:24,319
hash checking are implemented what i did

206
00:06:24,319 --> 00:06:26,000
was use that log cat made a huge number

207
00:06:26,000 --> 00:06:27,520
of byte arrays and cycled through them

208
00:06:27,520 --> 00:06:28,800
while making sure that in

209
00:06:28,800 --> 00:06:31,680
io controls used and pulled from the

210
00:06:31,680 --> 00:06:33,919
open source kernel drivers for this chip

211
00:06:33,919 --> 00:06:36,479
were used

212
00:06:36,560 --> 00:06:37,840
looking at this further and looking at

213
00:06:37,840 --> 00:06:40,319
this open source uh driver i found that

214
00:06:40,319 --> 00:06:41,520
it had

215
00:06:41,520 --> 00:06:43,680
commands well defined in there for me to

216
00:06:43,680 --> 00:06:45,840
look at so command zero was defined as

217
00:06:45,840 --> 00:06:46,479
reset

218
00:06:46,479 --> 00:06:48,800
command one was boot info command 2 was

219
00:06:48,800 --> 00:06:50,000
beginning the updates

220
00:06:50,000 --> 00:06:51,919
command 4 was to update specific sectors

221
00:06:51,919 --> 00:06:53,280
which included a

222
00:06:53,280 --> 00:06:55,759
address and the data itself and 5 which

223
00:06:55,759 --> 00:06:57,840
verified the signature and hash together

224
00:06:57,840 --> 00:07:00,800
in order to complete the update because

225
00:07:00,800 --> 00:07:02,160
there was no command 3

226
00:07:02,160 --> 00:07:03,199
it made me think that there were some

227
00:07:03,199 --> 00:07:04,639
hidden commands that weren't used by the

228
00:07:04,639 --> 00:07:06,160
firmware update but may have some extra

229
00:07:06,160 --> 00:07:08,160
functionality

230
00:07:08,160 --> 00:07:09,680
i could easily identify hidden

231
00:07:09,680 --> 00:07:11,039
bootloader commands just by seeing what

232
00:07:11,039 --> 00:07:12,400
errors were returned by the chip when i

233
00:07:12,400 --> 00:07:14,000
sent certain commands

234
00:07:14,000 --> 00:07:15,840
if it returned to it meant that the

235
00:07:15,840 --> 00:07:17,120
commands were not valid

236
00:07:17,120 --> 00:07:18,560
at that stage of the firmware update

237
00:07:18,560 --> 00:07:19,919
process and what i did was process

238
00:07:19,919 --> 00:07:21,280
through each step of the firmware update

239
00:07:21,280 --> 00:07:21,840
process

240
00:07:21,840 --> 00:07:23,199
while using these different supposed

241
00:07:23,199 --> 00:07:25,120
command states however if the chip

242
00:07:25,120 --> 00:07:26,240
returned to nine

243
00:07:26,240 --> 00:07:27,680
i was able to see that the payload was

244
00:07:27,680 --> 00:07:29,280
just too small and if i increase the

245
00:07:29,280 --> 00:07:30,479
size eventually i'd get a different

246
00:07:30,479 --> 00:07:30,880
error

247
00:07:30,880 --> 00:07:32,319
which would let me know the minimum size

248
00:07:32,319 --> 00:07:34,000
of the commands being sent

249
00:07:34,000 --> 00:07:35,280
brute forcing through this allowed me to

250
00:07:35,280 --> 00:07:37,039
find that command 3 was just

251
00:07:37,039 --> 00:07:39,039
a different version of command 4.

252
00:07:39,039 --> 00:07:41,120
however instead of sending the 4096

253
00:07:41,120 --> 00:07:41,680
blocks

254
00:07:41,680 --> 00:07:44,960
used by command 4 it sent 512 instead

255
00:07:44,960 --> 00:07:47,599
however command 6 was also noted and was

256
00:07:47,599 --> 00:07:49,840
much more interesting

257
00:07:49,840 --> 00:07:51,599
command 6 was found to take eight bytes

258
00:07:51,599 --> 00:07:53,199
of parameters which was two 32-bit

259
00:07:53,199 --> 00:07:54,080
values

260
00:07:54,080 --> 00:07:56,080
by setting random bits inside these

261
00:07:56,080 --> 00:07:57,759
parameters i found that it would dump

262
00:07:57,759 --> 00:07:59,680
out arbitrary memory from the chip

263
00:07:59,680 --> 00:08:01,360
but and allowed me to work out that this

264
00:08:01,360 --> 00:08:03,440
was taking an address and under size

265
00:08:03,440 --> 00:08:05,599
for data being returned using this i

266
00:08:05,599 --> 00:08:06,720
could damp ram

267
00:08:06,720 --> 00:08:10,080
firmware uh hidden hardware registers

268
00:08:10,080 --> 00:08:11,520
and the secure bootloader meaning i

269
00:08:11,520 --> 00:08:13,599
could reverse engineer this

270
00:08:13,599 --> 00:08:15,680
i stitched this bootloader together and

271
00:08:15,680 --> 00:08:17,440
found that it used a standard cortex-m

272
00:08:17,440 --> 00:08:18,639
firmware format

273
00:08:18,639 --> 00:08:21,199
so this would be the start of the first

274
00:08:21,199 --> 00:08:23,039
bytes would be the start of the stack

275
00:08:23,039 --> 00:08:24,720
and the next bytes would be the reset

276
00:08:24,720 --> 00:08:26,800
vector used to start up the chip

277
00:08:26,800 --> 00:08:28,160
looking at these together i could easily

278
00:08:28,160 --> 00:08:30,000
disassemble this in any disassembler i

279
00:08:30,000 --> 00:08:30,960
had

280
00:08:30,960 --> 00:08:33,120
however because this is a embedded

281
00:08:33,120 --> 00:08:34,640
firmware had very few strings and i'd

282
00:08:34,640 --> 00:08:35,839
have to look at everything by hand

283
00:08:35,839 --> 00:08:37,760
statically

284
00:08:37,760 --> 00:08:39,279
there are a few interesting artifacts in

285
00:08:39,279 --> 00:08:41,440
here so all the firmware was deployed

286
00:08:41,440 --> 00:08:42,320
was found to be

287
00:08:42,320 --> 00:08:45,360
stored starting at address 3000 and in

288
00:08:45,360 --> 00:08:45,839
the

289
00:08:45,839 --> 00:08:47,279
firmware itself i found that the first

290
00:08:47,279 --> 00:08:48,800
four bytes of the firmware were always

291
00:08:48,800 --> 00:08:51,200
fff fff

292
00:08:51,200 --> 00:08:52,959
however i found that the firmware update

293
00:08:52,959 --> 00:08:56,080
would overwrite this with 5if00fa 5

294
00:08:56,080 --> 00:08:57,040
which was found to be

295
00:08:57,040 --> 00:08:58,640
a magic number used to verify whether

296
00:08:58,640 --> 00:09:00,640
the firmware update was indeed valid and

297
00:09:00,640 --> 00:09:01,920
the signature had been checked during

298
00:09:01,920 --> 00:09:02,640
updates

299
00:09:02,640 --> 00:09:04,480
i tried to stick this particular value

300
00:09:04,480 --> 00:09:06,720
in straight away in a completely invalid

301
00:09:06,720 --> 00:09:08,399
firmware and found that this didn't work

302
00:09:08,399 --> 00:09:10,080
and that the bootloader checked whether

303
00:09:10,080 --> 00:09:13,200
the first value was always ffff

304
00:09:13,200 --> 00:09:15,360
i also found the state machine which

305
00:09:15,360 --> 00:09:16,640
checked which commands were being

306
00:09:16,640 --> 00:09:18,800
received so we have zero one two and six

307
00:09:18,800 --> 00:09:20,000
which were the commands that were

308
00:09:20,000 --> 00:09:21,279
available at the start of the firmware

309
00:09:21,279 --> 00:09:22,480
update process

310
00:09:22,480 --> 00:09:23,839
and i can look through to see that there

311
00:09:23,839 --> 00:09:25,360
were no other commands that were in use

312
00:09:25,360 --> 00:09:27,600
during this process

313
00:09:27,600 --> 00:09:29,360
i also noted the rsa public key in

314
00:09:29,360 --> 00:09:30,640
memory which was

315
00:09:30,640 --> 00:09:32,080
interesting but not useful because it

316
00:09:32,080 --> 00:09:34,080
was quite high entropy

317
00:09:34,080 --> 00:09:35,519
this can be easily identified by looking

318
00:09:35,519 --> 00:09:37,360
for zero zero zero one zero zero zero

319
00:09:37,360 --> 00:09:37,920
one

320
00:09:37,920 --> 00:09:39,760
which translates to six five five three

321
00:09:39,760 --> 00:09:42,720
seven the exponent of our rsa public key

322
00:09:42,720 --> 00:09:44,560
and before this is usually

323
00:09:44,560 --> 00:09:47,440
128 or a different size of high entropy

324
00:09:47,440 --> 00:09:48,080
bytes

325
00:09:48,080 --> 00:09:50,240
which usually usually denote the modulus

326
00:09:50,240 --> 00:09:53,040
of the rsa public key

327
00:09:53,040 --> 00:09:54,720
now because i now have the bootloader

328
00:09:54,720 --> 00:09:55,920
what i really wanted to do was find a

329
00:09:55,920 --> 00:09:57,200
memory corruption exploit in this

330
00:09:57,200 --> 00:09:58,160
bootloader

331
00:09:58,160 --> 00:09:59,680
allowing me to have an immutable

332
00:09:59,680 --> 00:10:01,680
unchangeable way of adding custom

333
00:10:01,680 --> 00:10:03,120
firmware to this chip whenever i wanted

334
00:10:03,120 --> 00:10:03,680
to

335
00:10:03,680 --> 00:10:05,519
now fuzzing my phone seemed like a bad

336
00:10:05,519 --> 00:10:06,959
idea at the time

337
00:10:06,959 --> 00:10:08,880
mainly due to the fact that if i broke

338
00:10:08,880 --> 00:10:10,399
the chip i'd have to buy a new phone to

339
00:10:10,399 --> 00:10:11,200
look at it

340
00:10:11,200 --> 00:10:12,800
or find a way to unbrick it which would

341
00:10:12,800 --> 00:10:14,079
involve some hard work modification

342
00:10:14,079 --> 00:10:17,040
which i didn't want to do

343
00:10:17,120 --> 00:10:19,200
also due to the fact that the only

344
00:10:19,200 --> 00:10:21,519
endpoint i had into the device was i2c

345
00:10:21,519 --> 00:10:22,880
debugging an analysis would be very

346
00:10:22,880 --> 00:10:25,040
difficult due to this i decided to

347
00:10:25,040 --> 00:10:26,480
emulate the bootloader as much as i

348
00:10:26,480 --> 00:10:28,880
could i decided to use the unicorn

349
00:10:28,880 --> 00:10:30,880
engine for this which is a library which

350
00:10:30,880 --> 00:10:32,320
is very powerful allows

351
00:10:32,320 --> 00:10:35,680
one to implement different firmware

352
00:10:35,680 --> 00:10:37,440
types using different architectures

353
00:10:37,440 --> 00:10:40,399
in order to assess how it works and also

354
00:10:40,399 --> 00:10:41,360
run functionality that wouldn't

355
00:10:41,360 --> 00:10:42,480
necessarily be possible

356
00:10:42,480 --> 00:10:44,240
on the architecture you're using it's

357
00:10:44,240 --> 00:10:46,160
sort of like a form of qmu except

358
00:10:46,160 --> 00:10:47,680
inside applications rather than

359
00:10:47,680 --> 00:10:50,399
something to run applications themselves

360
00:10:50,399 --> 00:10:52,880
um i loaded my bootloader into address

361
00:10:52,880 --> 00:10:54,880
zero as it would be in the actual device

362
00:10:54,880 --> 00:10:56,560
i set the program counter to the reset

363
00:10:56,560 --> 00:10:58,079
vector which is found in the bootloader

364
00:10:58,079 --> 00:11:00,079
and i met memory for hardware registers

365
00:11:00,079 --> 00:11:01,760
ram and flash ready to

366
00:11:01,760 --> 00:11:05,120
start fuzzing this protocol

367
00:11:05,120 --> 00:11:06,720
however a key aspect of this was the

368
00:11:06,720 --> 00:11:09,120
fact that even though i'd implement i'd

369
00:11:09,120 --> 00:11:13,839
use unicorn engine i wouldn't be able to

370
00:11:13,839 --> 00:11:15,440
emulate the hardware as easily because

371
00:11:15,440 --> 00:11:16,880
it just simply didn't exist and it was

372
00:11:16,880 --> 00:11:18,800
completely new and no one had ever seen

373
00:11:18,800 --> 00:11:20,160
it before

374
00:11:20,160 --> 00:11:23,200
especially in this format what i did is

375
00:11:23,200 --> 00:11:24,720
let the firmware run until it started

376
00:11:24,720 --> 00:11:25,920
reading from the hardware addresses

377
00:11:25,920 --> 00:11:28,320
which started ox 4000.

378
00:11:28,320 --> 00:11:30,320
i found that it started reading a

379
00:11:30,320 --> 00:11:32,240
specific address during startup

380
00:11:32,240 --> 00:11:34,240
and was checking for specific bits in

381
00:11:34,240 --> 00:11:35,440
the firmware

382
00:11:35,440 --> 00:11:38,560
in this register in order to identify

383
00:11:38,560 --> 00:11:40,959
certain aspects of the status i'd worked

384
00:11:40,959 --> 00:11:42,399
out that this was the status register

385
00:11:42,399 --> 00:11:43,360
for i2c

386
00:11:43,360 --> 00:11:45,040
so i made this always return randomized

387
00:11:45,040 --> 00:11:47,680
data meaning that the status of the itc

388
00:11:47,680 --> 00:11:48,800
bus would be deemed

389
00:11:48,800 --> 00:11:50,800
to be doing something at the time and

390
00:11:50,800 --> 00:11:53,040
would move past this state

391
00:11:53,040 --> 00:11:55,120
next i found the firmware continually

392
00:11:55,120 --> 00:11:56,800
reading bytes from another address

393
00:11:56,800 --> 00:11:58,959
which was um close to the original and

394
00:11:58,959 --> 00:12:00,639
found that this was likely to be the itc

395
00:12:00,639 --> 00:12:02,000
fifo buffer due to the fact that it was

396
00:12:02,000 --> 00:12:02,639
loading

397
00:12:02,639 --> 00:12:04,639
any bytes inputted from this into a

398
00:12:04,639 --> 00:12:06,079
buffer

399
00:12:06,079 --> 00:12:08,079
i started sending firmware update

400
00:12:08,079 --> 00:12:09,600
commands via this register

401
00:12:09,600 --> 00:12:12,959
by looking into unicorn engine and found

402
00:12:12,959 --> 00:12:14,560
that it would then start sending data

403
00:12:14,560 --> 00:12:16,000
on another address that was close in

404
00:12:16,000 --> 00:12:17,920
that area i found that this was sending

405
00:12:17,920 --> 00:12:19,200
responses to my

406
00:12:19,200 --> 00:12:21,440
i2c messages as the bootloader would

407
00:12:21,440 --> 00:12:22,959
have because of this i had full

408
00:12:22,959 --> 00:12:24,480
emulation of the i2c communication of

409
00:12:24,480 --> 00:12:25,279
the bootloader

410
00:12:25,279 --> 00:12:26,720
and could start fuzzing it as needed

411
00:12:26,720 --> 00:12:28,320
without having the potential of

412
00:12:28,320 --> 00:12:31,600
breaking my chip i started randomly

413
00:12:31,600 --> 00:12:32,160
fuzzing

414
00:12:32,160 --> 00:12:33,600
the chip but found that it wasn't really

415
00:12:33,600 --> 00:12:35,200
viable and didn't do very much

416
00:12:35,200 --> 00:12:37,360
while commands have 16-bit sizes and

417
00:12:37,360 --> 00:12:39,120
largely the entire contents of ram

418
00:12:39,120 --> 00:12:41,279
they were limited to only 256 bytes and

419
00:12:41,279 --> 00:12:43,040
i couldn't do much with that

420
00:12:43,040 --> 00:12:45,040
um i did find that some commands would

421
00:12:45,040 --> 00:12:47,360
send additional data in chunks

422
00:12:47,360 --> 00:12:50,079
for instance when you were sending 4096

423
00:12:50,079 --> 00:12:50,959
bytes of

424
00:12:50,959 --> 00:12:52,639
update data these were chunked into the

425
00:12:52,639 --> 00:12:54,639
256 bytes that were permitted

426
00:12:54,639 --> 00:12:56,959
by the protocol however i also found

427
00:12:56,959 --> 00:12:58,639
that the size of the hash and signature

428
00:12:58,639 --> 00:13:00,320
which was sent subsequent to the hash

429
00:13:00,320 --> 00:13:02,240
and signature command were defined in

430
00:13:02,240 --> 00:13:02,639
the

431
00:13:02,639 --> 00:13:06,480
in this command and were modifiable

432
00:13:06,480 --> 00:13:08,240
by increasing the size of the hash and

433
00:13:08,240 --> 00:13:10,160
signature sizes i could

434
00:13:10,160 --> 00:13:12,480
allow myself to send more and more data

435
00:13:12,480 --> 00:13:13,360
subsequently

436
00:13:13,360 --> 00:13:15,600
for instance if i said that the hash the

437
00:13:15,600 --> 00:13:16,639
xiao1 hash

438
00:13:16,639 --> 00:13:19,200
was 200 bytes instead of the classic

439
00:13:19,200 --> 00:13:21,200
amount i would be able to send that much

440
00:13:21,200 --> 00:13:22,000
data

441
00:13:22,000 --> 00:13:24,320
what i found was in my emulated chipset

442
00:13:24,320 --> 00:13:25,760
this overwrote the stack

443
00:13:25,760 --> 00:13:28,480
and hit a invalid aspect of memory so

444
00:13:28,480 --> 00:13:29,440
over the 8k

445
00:13:29,440 --> 00:13:32,560
of memory that was available

446
00:13:32,800 --> 00:13:34,160
because i could overwrite the stack i

447
00:13:34,160 --> 00:13:35,519
could change where the return pointers

448
00:13:35,519 --> 00:13:37,279
were in the stack and change where the

449
00:13:37,279 --> 00:13:38,560
program counter would jump to after

450
00:13:38,560 --> 00:13:40,240
returning from these commands

451
00:13:40,240 --> 00:13:42,199
due to the fact that the am securecore

452
00:13:42,199 --> 00:13:43,920
sc000 chipsets

453
00:13:43,920 --> 00:13:45,440
can't execute from ram i wouldn't be

454
00:13:45,440 --> 00:13:46,720
able to do anything simple like just

455
00:13:46,720 --> 00:13:48,800
write a bit of shell code

456
00:13:48,800 --> 00:13:50,639
also because the stack was so small only

457
00:13:50,639 --> 00:13:52,639
being about 12 bytes at this point

458
00:13:52,639 --> 00:13:54,800
it was too uh small to do any complex

459
00:13:54,800 --> 00:13:56,240
drop exploits

460
00:13:56,240 --> 00:13:58,720
in order to um get past this i what i

461
00:13:58,720 --> 00:13:59,920
did was just make it jump

462
00:13:59,920 --> 00:14:02,160
the program counter into the signature

463
00:14:02,160 --> 00:14:03,600
checks at the start of the bootloader

464
00:14:03,600 --> 00:14:05,360
past the checks actually occurred and

465
00:14:05,360 --> 00:14:06,399
it's the part where it loaded the

466
00:14:06,399 --> 00:14:07,519
address of the firmware

467
00:14:07,519 --> 00:14:09,440
and jumped into it which restarted the

468
00:14:09,440 --> 00:14:10,800
chip into the

469
00:14:10,800 --> 00:14:14,160
core firmware i then

470
00:14:14,160 --> 00:14:15,680
perform this exploit on the physical

471
00:14:15,680 --> 00:14:16,959
chip and found that it worked

472
00:14:16,959 --> 00:14:17,920
beautifully so

473
00:14:17,920 --> 00:14:20,880
i booted uh my bootloader sent my

474
00:14:20,880 --> 00:14:21,920
exploit

475
00:14:21,920 --> 00:14:25,040
and then noticed that after i'd run it

476
00:14:25,040 --> 00:14:25,680
it would start

477
00:14:25,680 --> 00:14:27,600
behaving as the real firmware and i

478
00:14:27,600 --> 00:14:28,959
could send nci commands instead of

479
00:14:28,959 --> 00:14:30,079
firmware update commands

480
00:14:30,079 --> 00:14:33,040
to the chip what i did was simply change

481
00:14:33,040 --> 00:14:33,440
the

482
00:14:33,440 --> 00:14:35,440
version number of the firmware just to

483
00:14:35,440 --> 00:14:36,720
show that this signature checking had

484
00:14:36,720 --> 00:14:38,079
been bypassed and i could run my own

485
00:14:38,079 --> 00:14:39,279
custom firmware

486
00:14:39,279 --> 00:14:42,079
i then disclosed this to samsung now

487
00:14:42,079 --> 00:14:43,519
there are two ways they could have uh

488
00:14:43,519 --> 00:14:44,720
fixed this now because it was a

489
00:14:44,720 --> 00:14:47,120
bootloader um level exploit it's a bit

490
00:14:47,120 --> 00:14:48,480
more complicated than just updating the

491
00:14:48,480 --> 00:14:49,440
firmware

492
00:14:49,440 --> 00:14:50,800
they would have to patch the bootloader

493
00:14:50,800 --> 00:14:52,720
from the main firmware um

494
00:14:52,720 --> 00:14:54,560
removing this buffer overflow uh

495
00:14:54,560 --> 00:14:56,160
vulnerability however

496
00:14:56,160 --> 00:14:58,000
while this was being undergone if

497
00:14:58,000 --> 00:14:59,519
someone power cycled the chip or there

498
00:14:59,519 --> 00:15:00,639
was some kind of error

499
00:15:00,639 --> 00:15:02,880
the butler would loader would be left

500
00:15:02,880 --> 00:15:04,880
erased and they wouldn't ever be able to

501
00:15:04,880 --> 00:15:07,279
restart it again leaving the nfc

502
00:15:07,279 --> 00:15:08,240
functionality of the chip

503
00:15:08,240 --> 00:15:09,600
completely non-functional because the

504
00:15:09,600 --> 00:15:11,440
chip wouldn't be able to start or they

505
00:15:11,440 --> 00:15:12,480
could have patched the kernel to

506
00:15:12,480 --> 00:15:13,440
disallow

507
00:15:13,440 --> 00:15:15,279
large hashes and signatures however this

508
00:15:15,279 --> 00:15:16,800
was trivially bypassed just by kernel

509
00:15:16,800 --> 00:15:19,519
modification if they did that

510
00:15:19,519 --> 00:15:21,040
i decided to look at other nfc chips

511
00:15:21,040 --> 00:15:22,959
that samsung had

512
00:15:22,959 --> 00:15:25,680
used or developed rather and found that

513
00:15:25,680 --> 00:15:27,360
they were there were four that were in

514
00:15:27,360 --> 00:15:31,120
modern use the s3 and rn 74 s3 nrn81

515
00:15:31,120 --> 00:15:35,839
s3 nrn82 and scn82ab

516
00:15:35,920 --> 00:15:37,839
i wanted to find these chipsets in

517
00:15:37,839 --> 00:15:39,120
different samsung phones to see which

518
00:15:39,120 --> 00:15:40,320
one i should purchase in order to

519
00:15:40,320 --> 00:15:41,839
continue this research

520
00:15:41,839 --> 00:15:43,680
now because teardowns aren't always

521
00:15:43,680 --> 00:15:45,199
available especially for um

522
00:15:45,199 --> 00:15:48,480
non-us devices it wouldn't be a simple

523
00:15:48,480 --> 00:15:49,440
task of just

524
00:15:49,440 --> 00:15:51,360
google searching for these version

525
00:15:51,360 --> 00:15:53,519
numbers and

526
00:15:53,519 --> 00:15:56,880
phone types so what i ended up doing

527
00:15:56,880 --> 00:15:58,720
was going to sam mobile.com which

528
00:15:58,720 --> 00:16:00,399
contains roms for almost every samsung

529
00:16:00,399 --> 00:16:01,040
device

530
00:16:01,040 --> 00:16:03,360
downloading them extracting them and

531
00:16:03,360 --> 00:16:04,160
finding what

532
00:16:04,160 --> 00:16:06,800
um whether they had the firmware files

533
00:16:06,800 --> 00:16:08,160
embedded in them

534
00:16:08,160 --> 00:16:09,440
these are usually found in the slash

535
00:16:09,440 --> 00:16:11,519
vendor directory and

536
00:16:11,519 --> 00:16:12,639
occasionally this is a separate

537
00:16:12,639 --> 00:16:14,079
partition but generally it's easy to

538
00:16:14,079 --> 00:16:16,000
find

539
00:16:16,000 --> 00:16:17,199
looking through this i managed to find

540
00:16:17,199 --> 00:16:19,440
the s3n82 which is used

541
00:16:19,440 --> 00:16:21,279
by the samsung s9 as well as the samsung

542
00:16:21,279 --> 00:16:22,959
s8 and that's something s10

543
00:16:22,959 --> 00:16:24,720
however i decided to buy a samsung s9

544
00:16:24,720 --> 00:16:26,480
for this purpose

545
00:16:26,480 --> 00:16:28,959
um i found that had multiple chip

546
00:16:28,959 --> 00:16:30,320
firmware revisions just by looking at

547
00:16:30,320 --> 00:16:31,440
different roms which would be very

548
00:16:31,440 --> 00:16:32,160
helpful if i

549
00:16:32,160 --> 00:16:34,240
needed to reverse engineer more and i

550
00:16:34,240 --> 00:16:35,680
found that the samsung s9

551
00:16:35,680 --> 00:16:37,519
while it was secure from a routing

552
00:16:37,519 --> 00:16:38,959
perspective you could

553
00:16:38,959 --> 00:16:40,880
use oem unlocking and a custom rom in

554
00:16:40,880 --> 00:16:42,720
order to root it appropriately to

555
00:16:42,720 --> 00:16:44,959
perform any attacks on it

556
00:16:44,959 --> 00:16:46,480
the firmware file was found to be almost

557
00:16:46,480 --> 00:16:48,880
exactly the same as the s3w iron five at

558
00:16:48,880 --> 00:16:50,079
least in formatting

559
00:16:50,079 --> 00:16:51,839
so it had the same metadata signature

560
00:16:51,839 --> 00:16:53,279
and firmware payload

561
00:16:53,279 --> 00:16:55,040
however the reset vector of the firmware

562
00:16:55,040 --> 00:16:56,560
which was found at the top of it

563
00:16:56,560 --> 00:16:57,920
was much smaller implying that the

564
00:16:57,920 --> 00:16:59,120
bootloader had been modified to be

565
00:16:59,120 --> 00:16:59,839
smaller

566
00:16:59,839 --> 00:17:01,759
and the firmware size were 32 kilobytes

567
00:17:01,759 --> 00:17:03,680
larger which was corroborated with what

568
00:17:03,680 --> 00:17:05,280
was on the data sheets on samsung's

569
00:17:05,280 --> 00:17:07,199
website

570
00:17:07,199 --> 00:17:08,559
i found that commands three and six

571
00:17:08,559 --> 00:17:10,799
these being the um smaller

572
00:17:10,799 --> 00:17:13,119
deployment of code command and the

573
00:17:13,119 --> 00:17:14,319
firmware readout command

574
00:17:14,319 --> 00:17:16,319
no longer available however command

575
00:17:16,319 --> 00:17:18,319
seven was identified but all it did was

576
00:17:18,319 --> 00:17:19,679
reboot the chip

577
00:17:19,679 --> 00:17:21,760
a new bootloader size implied that the

578
00:17:21,760 --> 00:17:22,720
firmware had what

579
00:17:22,720 --> 00:17:24,799
bootloader had been modified in some way

580
00:17:24,799 --> 00:17:26,559
meaning that i'd probably have to uh

581
00:17:26,559 --> 00:17:28,240
do something a bit different in order to

582
00:17:28,240 --> 00:17:30,160
exploit this and due to the lack of

583
00:17:30,160 --> 00:17:31,600
memory readout verifying

584
00:17:31,600 --> 00:17:33,039
what i'd done before would not be as

585
00:17:33,039 --> 00:17:34,880
easy and i'd have to do any expectation

586
00:17:34,880 --> 00:17:36,559
blind anyway

587
00:17:36,559 --> 00:17:37,919
also i found that trying to upload

588
00:17:37,919 --> 00:17:39,919
firmware using a shower one hash was not

589
00:17:39,919 --> 00:17:42,720
possible anymore

590
00:17:43,360 --> 00:17:46,240
because x1 because the itc communication

591
00:17:46,240 --> 00:17:48,000
was no longer provided by log cap

592
00:17:48,000 --> 00:17:49,360
i have to go looking around to see how

593
00:17:49,360 --> 00:17:51,200
this was locked and found a device file

594
00:17:51,200 --> 00:17:52,160
called slash prog

595
00:17:52,160 --> 00:17:55,120
nfc log which contains sizes of all the

596
00:17:55,120 --> 00:17:56,640
commands being written to the chip in

597
00:17:56,640 --> 00:17:57,520
sequence

598
00:17:57,520 --> 00:17:59,840
and found that at the start of firmer

599
00:17:59,840 --> 00:18:00,640
updates

600
00:18:00,640 --> 00:18:03,760
um a largest hash size had written so

601
00:18:03,760 --> 00:18:04,480
instead of the

602
00:18:04,480 --> 00:18:07,120
sha1 hash size it was now sending 32

603
00:18:07,120 --> 00:18:07,600
bytes

604
00:18:07,600 --> 00:18:09,919
plus the start the header of a command

605
00:18:09,919 --> 00:18:10,799
which was

606
00:18:10,799 --> 00:18:12,880
four bytes this implied that instead of

607
00:18:12,880 --> 00:18:14,880
using sha1 hashes for firmware updates

608
00:18:14,880 --> 00:18:15,679
they were now using

609
00:18:15,679 --> 00:18:17,679
type 256 hashes which were compared

610
00:18:17,679 --> 00:18:19,919
against the signature

611
00:18:19,919 --> 00:18:21,600
i verified this by modifying my firmware

612
00:18:21,600 --> 00:18:24,159
update tool

613
00:18:24,880 --> 00:18:27,919
because i no longer had any knowledge of

614
00:18:27,919 --> 00:18:29,280
how the inner workings of the bootloader

615
00:18:29,280 --> 00:18:30,799
worked on this new bootloader i would

616
00:18:30,799 --> 00:18:31,520
have to guess

617
00:18:31,520 --> 00:18:32,799
quite a lot of how the exploitation

618
00:18:32,799 --> 00:18:35,120
worked due to the nature of device

619
00:18:35,120 --> 00:18:35,760
crashes

620
00:18:35,760 --> 00:18:38,240
i could work this out however i decided

621
00:18:38,240 --> 00:18:40,320
to attempt the exact same exploit i did

622
00:18:40,320 --> 00:18:42,160
before by increasing the size of the

623
00:18:42,160 --> 00:18:42,960
hashes

624
00:18:42,960 --> 00:18:45,600
until i overwrote the stack what i did

625
00:18:45,600 --> 00:18:46,480
was keep adding

626
00:18:46,480 --> 00:18:48,960
more and more size to this stat to the

627
00:18:48,960 --> 00:18:50,320
size of the hash

628
00:18:50,320 --> 00:18:52,799
while sending more and more data now

629
00:18:52,799 --> 00:18:54,320
just the nature of how the stack worked

630
00:18:54,320 --> 00:18:55,440
in this

631
00:18:55,440 --> 00:18:57,440
it would still return data even if i'd

632
00:18:57,440 --> 00:18:59,200
overrun the stack but then crash

633
00:18:59,200 --> 00:19:00,960
however if i'd overwritten memory that

634
00:19:00,960 --> 00:19:02,640
being over the 12k that was now

635
00:19:02,640 --> 00:19:03,280
available

636
00:19:03,280 --> 00:19:04,799
the device wouldn't return after i sent

637
00:19:04,799 --> 00:19:06,640
data to it meaning that i'd be able to

638
00:19:06,640 --> 00:19:08,240
work out the entire size of the memory i

639
00:19:08,240 --> 00:19:09,200
was accessing

640
00:19:09,200 --> 00:19:10,960
and overwrite it with any data i wanted

641
00:19:10,960 --> 00:19:13,679
or any return pointers i wanted

642
00:19:13,679 --> 00:19:15,120
here's a quick demo of how this worked

643
00:19:15,120 --> 00:19:17,520
so because i didn't know

644
00:19:17,520 --> 00:19:20,720
how where the program counter needed to

645
00:19:20,720 --> 00:19:22,320
jump to in the bootloader anymore

646
00:19:22,320 --> 00:19:23,360
but virtually the fact that i couldn't

647
00:19:23,360 --> 00:19:25,200
see the bootloader what i ended up doing

648
00:19:25,200 --> 00:19:26,720
was processing from

649
00:19:26,720 --> 00:19:28,720
address one or other program counter

650
00:19:28,720 --> 00:19:30,720
address zero plus one which is how thumb

651
00:19:30,720 --> 00:19:31,280
code

652
00:19:31,280 --> 00:19:34,400
addresses code in this manner and let it

653
00:19:34,400 --> 00:19:34,720
run

654
00:19:34,720 --> 00:19:37,039
until it found an end point which a

655
00:19:37,039 --> 00:19:38,320
address which would allow

656
00:19:38,320 --> 00:19:41,760
it to jump into the raw firmware

657
00:19:41,760 --> 00:19:43,679
we're hitting the end of this now so

658
00:19:43,679 --> 00:19:45,440
what this is doing is filling the entire

659
00:19:45,440 --> 00:19:46,080
stack

660
00:19:46,080 --> 00:19:47,440
with return pointers because i also

661
00:19:47,440 --> 00:19:48,559
didn't know where the return pointers

662
00:19:48,559 --> 00:19:50,000
would be

663
00:19:50,000 --> 00:19:51,840
and what i found is when it got to

664
00:19:51,840 --> 00:19:53,360
address 165

665
00:19:53,360 --> 00:19:56,080
that was the correct position for it to

666
00:19:56,080 --> 00:19:56,640
uh

667
00:19:56,640 --> 00:19:59,039
jump into the unsigned firmware and it

668
00:19:59,039 --> 00:20:00,480
would allow me to bypass the signature

669
00:20:00,480 --> 00:20:02,480
checking

670
00:20:02,480 --> 00:20:03,760
i disclosed this vulnerability to

671
00:20:03,760 --> 00:20:05,520
samsung as well and they

672
00:20:05,520 --> 00:20:07,679
have now patched it on all new

673
00:20:07,679 --> 00:20:10,559
manufactured chipsets from april 2020

674
00:20:10,559 --> 00:20:12,240
and all future chipsets will be patched

675
00:20:12,240 --> 00:20:13,919
so that this doesn't occur

676
00:20:13,919 --> 00:20:17,360
however all the chipsets will still be

677
00:20:17,360 --> 00:20:19,840
attackable using this approach and we'll

678
00:20:19,840 --> 00:20:21,120
still allow custom firmware to be

679
00:20:21,120 --> 00:20:23,600
developed

680
00:20:23,600 --> 00:20:25,520
so because i could write custom firmware

681
00:20:25,520 --> 00:20:27,039
for any of these chips i decided to

682
00:20:27,039 --> 00:20:29,679
aim for the s3 nrn h2 as this was the

683
00:20:29,679 --> 00:20:30,960
newest the fastest and had the most

684
00:20:30,960 --> 00:20:32,159
memory

685
00:20:32,159 --> 00:20:33,520
because i'd only be able to debug things

686
00:20:33,520 --> 00:20:35,679
very c it would be quite complex to

687
00:20:35,679 --> 00:20:36,960
debug but at least i had something to

688
00:20:36,960 --> 00:20:38,960
work with

689
00:20:38,960 --> 00:20:40,880
i downloaded a firmware file that i

690
00:20:40,880 --> 00:20:43,440
found inside a samsung s8 rom

691
00:20:43,440 --> 00:20:45,039
this being the oldest phone which used

692
00:20:45,039 --> 00:20:46,720
this chipset i

693
00:20:46,720 --> 00:20:48,960
found that it had quite a lot of spare

694
00:20:48,960 --> 00:20:50,480
memory compared to the firmware that was

695
00:20:50,480 --> 00:20:52,000
used on the samsung s9

696
00:20:52,000 --> 00:20:53,679
and i could use this to write patching

697
00:20:53,679 --> 00:20:55,200
machine code that i compiled

698
00:20:55,200 --> 00:20:59,120
as needed in order to do this

699
00:20:59,120 --> 00:21:02,080
one all one needs to do is compile c

700
00:21:02,080 --> 00:21:04,080
functions using gcc-c

701
00:21:04,080 --> 00:21:05,760
all this does is create an object file

702
00:21:05,760 --> 00:21:07,679
without any linking or relocation

703
00:21:07,679 --> 00:21:09,440
but gives you raw assembly to work with

704
00:21:09,440 --> 00:21:12,480
or rather raw machine code

705
00:21:12,480 --> 00:21:14,080
stack handling is still handled

706
00:21:14,080 --> 00:21:15,440
appropriately with pushes and pops as

707
00:21:15,440 --> 00:21:16,720
any arm code would

708
00:21:16,720 --> 00:21:19,039
however you would need to implement any

709
00:21:19,039 --> 00:21:20,880
c standard libraries yourself so any mem

710
00:21:20,880 --> 00:21:21,600
copies

711
00:21:21,600 --> 00:21:24,000
any string copies and comparisons would

712
00:21:24,000 --> 00:21:27,039
need to be done by hand

713
00:21:27,280 --> 00:21:30,720
so in c function calls are all generated

714
00:21:30,720 --> 00:21:32,320
as branch and link instructions

715
00:21:32,320 --> 00:21:35,520
so what happens is um code

716
00:21:35,520 --> 00:21:38,799
gets functions are called by um

717
00:21:38,799 --> 00:21:41,280
jumping to a relative address compared

718
00:21:41,280 --> 00:21:42,640
to the current address where the program

719
00:21:42,640 --> 00:21:43,440
counter is

720
00:21:43,440 --> 00:21:44,640
and then it usually pushes some

721
00:21:44,640 --> 00:21:46,240
registers and then pops them at the end

722
00:21:46,240 --> 00:21:48,320
to return back where it was

723
00:21:48,320 --> 00:21:51,440
this can be used to patch out existing

724
00:21:51,440 --> 00:21:52,640
functions in the firmware

725
00:21:52,640 --> 00:21:54,320
or even override them completely as

726
00:21:54,320 --> 00:21:58,159
needed in order to change functionality

727
00:21:58,159 --> 00:21:59,840
branch and link uses two complement and

728
00:21:59,840 --> 00:22:01,280
two's complement relative addresses

729
00:22:01,280 --> 00:22:01,919
which is

730
00:22:01,919 --> 00:22:04,400
some simple binary mathematics but um

731
00:22:04,400 --> 00:22:06,320
can be used to jump relatively from

732
00:22:06,320 --> 00:22:08,240
the current position into where you want

733
00:22:08,240 --> 00:22:10,480
to be and can be patched over any

734
00:22:10,480 --> 00:22:11,760
existing branch and link functions

735
00:22:11,760 --> 00:22:12,720
basically so

736
00:22:12,720 --> 00:22:14,880
if i wanted to change one specific

737
00:22:14,880 --> 00:22:16,159
function to do something else

738
00:22:16,159 --> 00:22:17,840
i could jump to my own functions in that

739
00:22:17,840 --> 00:22:19,760
empty area of memory where i'd patch

740
00:22:19,760 --> 00:22:21,600
them into

741
00:22:21,600 --> 00:22:23,520
i made a made a small build application

742
00:22:23,520 --> 00:22:25,039
for this which literally did all the

743
00:22:25,039 --> 00:22:26,080
linking and relocating

744
00:22:26,080 --> 00:22:27,919
for me by dumping out function calls

745
00:22:27,919 --> 00:22:29,200
from my binaries

746
00:22:29,200 --> 00:22:31,440
and relocating them as needed as well as

747
00:22:31,440 --> 00:22:33,200
performing manual arm patching

748
00:22:33,200 --> 00:22:35,919
as i needed to

749
00:22:36,240 --> 00:22:38,559
first thing i wanted to do is make a

750
00:22:38,559 --> 00:22:40,000
command a

751
00:22:40,000 --> 00:22:41,520
itc function which would allow me to

752
00:22:41,520 --> 00:22:43,600
read arbitrary memory and what i did was

753
00:22:43,600 --> 00:22:44,559
select a specific

754
00:22:44,559 --> 00:22:47,520
vendor specific command this being 2f24

755
00:22:47,520 --> 00:22:48,159
in

756
00:22:48,159 --> 00:22:51,520
the firmware which was used by some

757
00:22:51,520 --> 00:22:53,760
unknown functionality of the device but

758
00:22:53,760 --> 00:22:55,280
was essentially allowed

759
00:22:55,280 --> 00:22:57,840
essentially allowed arbitrary size of

760
00:22:57,840 --> 00:22:59,440
parameters and was allowed to be run

761
00:22:59,440 --> 00:23:01,360
continuously as needed

762
00:23:01,360 --> 00:23:02,880
what i could do was modify this to do

763
00:23:02,880 --> 00:23:04,480
what i wanted to i

764
00:23:04,480 --> 00:23:08,240
searched for morph 0x24 using regex and

765
00:23:08,240 --> 00:23:09,280
ida which literally

766
00:23:09,280 --> 00:23:11,120
let me find exactly how this was loaded

767
00:23:11,120 --> 00:23:12,799
for setting up response editors

768
00:23:12,799 --> 00:23:14,480
and then i overrode the function that

769
00:23:14,480 --> 00:23:16,880
was right before the send function in

770
00:23:16,880 --> 00:23:17,919
i2c

771
00:23:17,919 --> 00:23:19,360
um so that it would jump to my get

772
00:23:19,360 --> 00:23:20,640
arbitrary memory function which would

773
00:23:20,640 --> 00:23:21,600
allow me to

774
00:23:21,600 --> 00:23:23,840
jump read memory or modify memory as

775
00:23:23,840 --> 00:23:25,200
needed to whenever

776
00:23:25,200 --> 00:23:26,640
because writing a firmware took around

777
00:23:26,640 --> 00:23:28,080
20 seconds this was quite a difficult

778
00:23:28,080 --> 00:23:29,840
task and took a while to set up

779
00:23:29,840 --> 00:23:31,360
but when it did it could be expanded as

780
00:23:31,360 --> 00:23:33,760
needed

781
00:23:33,840 --> 00:23:35,679
because i could now send data back i

782
00:23:35,679 --> 00:23:37,679
wanted to take parameters as well

783
00:23:37,679 --> 00:23:39,440
i didn't know exactly where the

784
00:23:39,440 --> 00:23:41,200
parameters were stored in ram just by

785
00:23:41,200 --> 00:23:43,120
virtue of how complex the firmware was

786
00:23:43,120 --> 00:23:44,559
so what i want to do is quickly find

787
00:23:44,559 --> 00:23:46,799
this out i did this by crafting an nci

788
00:23:46,799 --> 00:23:48,960
request which had

789
00:23:48,960 --> 00:23:52,159
f 2f2404 c f a c now f a c f a c is just

790
00:23:52,159 --> 00:23:52,799
a

791
00:23:52,799 --> 00:23:54,559
nice little place holder which i could

792
00:23:54,559 --> 00:23:55,840
search through in ram in order to find

793
00:23:55,840 --> 00:23:57,279
the address of these

794
00:23:57,279 --> 00:23:59,840
um parameters being sent and i use this

795
00:23:59,840 --> 00:24:01,520
to find exactly where this was so i can

796
00:24:01,520 --> 00:24:02,000
now

797
00:24:02,000 --> 00:24:03,679
send and receive commands as needed via

798
00:24:03,679 --> 00:24:06,880
i2c with very little code changes

799
00:24:06,880 --> 00:24:08,000
the first thing i did was dump the

800
00:24:08,000 --> 00:24:10,159
bootloader which was uh

801
00:24:10,159 --> 00:24:12,240
very helpful and i looked at what i was

802
00:24:12,240 --> 00:24:14,080
actually hitting with my

803
00:24:14,080 --> 00:24:15,440
exploit because i hadn't seen this

804
00:24:15,440 --> 00:24:17,360
bootloader before i didn't know what i

805
00:24:17,360 --> 00:24:18,640
was hitting to make this work

806
00:24:18,640 --> 00:24:20,880
what i found that what the bootloader

807
00:24:20,880 --> 00:24:22,159
was doing was loading

808
00:24:22,159 --> 00:24:24,400
from our zero into our zero from the

809
00:24:24,400 --> 00:24:25,440
address now

810
00:24:25,440 --> 00:24:27,039
because we jumped here directly from the

811
00:24:27,039 --> 00:24:28,559
function call we had no idea what

812
00:24:28,559 --> 00:24:31,600
r0 was and so the fact that this worked

813
00:24:31,600 --> 00:24:34,159
at all was quite impressive

814
00:24:34,159 --> 00:24:35,760
what i did was change this to address

815
00:24:35,760 --> 00:24:38,240
173 which was exactly the same as where

816
00:24:38,240 --> 00:24:39,120
we put it

817
00:24:39,120 --> 00:24:40,880
in the original bootloader and allowed

818
00:24:40,880 --> 00:24:42,320
us to jump directly into the firmware

819
00:24:42,320 --> 00:24:44,640
without any problems

820
00:24:44,640 --> 00:24:47,039
now reading out memory is very useful

821
00:24:47,039 --> 00:24:48,880
but because this is an nfc chip i wanted

822
00:24:48,880 --> 00:24:49,520
to make it do

823
00:24:49,520 --> 00:24:52,400
cool nfc things because the chipset

824
00:24:52,400 --> 00:24:54,080
supports multiple protocols such as iso

825
00:24:54,080 --> 00:24:54,799
one one

826
00:24:54,799 --> 00:24:57,120
four four three a iso one four four four

827
00:24:57,120 --> 00:24:59,039
three b and a few others that are all in

828
00:24:59,039 --> 00:25:00,400
the 13.56

829
00:25:00,400 --> 00:25:02,880
megahertz range i wanted to implement

830
00:25:02,880 --> 00:25:03,919
one of those myself

831
00:25:03,919 --> 00:25:06,320
i decided to emulate a myfair classic

832
00:25:06,320 --> 00:25:08,000
tag that's my first project for this

833
00:25:08,000 --> 00:25:09,200
chip

834
00:25:09,200 --> 00:25:10,240
i would need to know a lot about that

835
00:25:10,240 --> 00:25:12,240
hardware register to make this work but

836
00:25:12,240 --> 00:25:15,360
doing so would allow me to work um with

837
00:25:15,360 --> 00:25:16,720
the chip in ways which would allow me to

838
00:25:16,720 --> 00:25:17,360
emulate

839
00:25:17,360 --> 00:25:19,520
any nfc tag i used to proxmox for

840
00:25:19,520 --> 00:25:21,120
debugging throughout as i could see how

841
00:25:21,120 --> 00:25:23,200
nfc was working at a very raw level

842
00:25:23,200 --> 00:25:26,720
and this was very helpful i took all the

843
00:25:26,720 --> 00:25:28,000
nci commands that were sent by

844
00:25:28,000 --> 00:25:29,679
the phone to the chip usually and just

845
00:25:29,679 --> 00:25:31,120
dumped them into a bite array and

846
00:25:31,120 --> 00:25:32,080
replayed them

847
00:25:32,080 --> 00:25:33,520
i then went through each one and found

848
00:25:33,520 --> 00:25:34,880
out any of them which weren't actually

849
00:25:34,880 --> 00:25:36,720
required for the chip to run as i needed

850
00:25:36,720 --> 00:25:39,360
to so that i could uh reduce bloat on

851
00:25:39,360 --> 00:25:40,720
the commands being sent

852
00:25:40,720 --> 00:25:42,400
and then i used what i discovered to be

853
00:25:42,400 --> 00:25:43,840
the rf discover command which is the

854
00:25:43,840 --> 00:25:45,120
last command sent

855
00:25:45,120 --> 00:25:47,039
and took away all the parameters which

856
00:25:47,039 --> 00:25:48,799
set up into nfc reader mode

857
00:25:48,799 --> 00:25:50,320
or used different protocols and just

858
00:25:50,320 --> 00:25:52,480
kept it for protocol 80 which

859
00:25:52,480 --> 00:25:56,000
turned out to be the uh my iso 144

860
00:25:56,000 --> 00:25:59,760
3a tag emulation mode

861
00:26:00,480 --> 00:26:02,080
because i had no data sheets to work

862
00:26:02,080 --> 00:26:03,760
with and the hardware registers were

863
00:26:03,760 --> 00:26:05,039
quite complicated i'd have to look

864
00:26:05,039 --> 00:26:05,760
around

865
00:26:05,760 --> 00:26:07,039
in the firmware to see how these were

866
00:26:07,039 --> 00:26:09,200
used and as there weren't any strings

867
00:26:09,200 --> 00:26:12,000
i would have to infer anything i was

868
00:26:12,000 --> 00:26:12,720
working out

869
00:26:12,720 --> 00:26:15,200
directly from this hardware the first

870
00:26:15,200 --> 00:26:16,799
thing i wanted to do was find out how

871
00:26:16,799 --> 00:26:18,080
enumeration works on the chip now

872
00:26:18,080 --> 00:26:19,760
enumeration on

873
00:26:19,760 --> 00:26:22,240
nfc um works largely the same with

874
00:26:22,240 --> 00:26:24,559
standard communication in nfc however

875
00:26:24,559 --> 00:26:26,559
there are some differences which in

876
00:26:26,559 --> 00:26:28,000
speed which meant

877
00:26:28,000 --> 00:26:29,440
that the chipset was probably doing this

878
00:26:29,440 --> 00:26:31,200
separately or in some hardware level

879
00:26:31,200 --> 00:26:32,320
compared to just doing the standard

880
00:26:32,320 --> 00:26:34,720
communication um the first thing i did

881
00:26:34,720 --> 00:26:35,919
was search for the select command which

882
00:26:35,919 --> 00:26:37,120
is the second command

883
00:26:37,120 --> 00:26:38,320
in enumeration just because i thought

884
00:26:38,320 --> 00:26:40,080
this was more likely to work just by

885
00:26:40,080 --> 00:26:41,840
reject searching for comparison

886
00:26:41,840 --> 00:26:44,720
and 93 93 being the select command this

887
00:26:44,720 --> 00:26:46,000
found an immediate result

888
00:26:46,000 --> 00:26:47,520
loading from a hardware address four

889
00:26:47,520 --> 00:26:49,520
zero zero two zero two hundred

890
00:26:49,520 --> 00:26:51,440
and comparing on that value meaning that

891
00:26:51,440 --> 00:26:52,960
i'd instantly found how this enumeration

892
00:26:52,960 --> 00:26:55,679
was being selected

893
00:26:55,679 --> 00:26:57,600
i placed the phone on a reader and let

894
00:26:57,600 --> 00:26:58,799
it constantly run

895
00:26:58,799 --> 00:27:00,400
and then started dumping from this

896
00:27:00,400 --> 00:27:02,240
hardware just using the i2c function

897
00:27:02,240 --> 00:27:03,840
that i'd implemented earlier

898
00:27:03,840 --> 00:27:05,440
this recovery replaced my results from

899
00:27:05,440 --> 00:27:07,120
ida i found that the reader was

900
00:27:07,120 --> 00:27:08,720
constantly sending wake up commands

901
00:27:08,720 --> 00:27:09,360
which are

902
00:27:09,360 --> 00:27:12,400
hex 52 this allowed me to also work out

903
00:27:12,400 --> 00:27:13,200
other things about the hardware

904
00:27:13,200 --> 00:27:14,559
registers such as the

905
00:27:14,559 --> 00:27:17,039
size and certain other configurations i

906
00:27:17,039 --> 00:27:19,039
could dump out later

907
00:27:19,039 --> 00:27:20,640
this functionality would allow me to do

908
00:27:20,640 --> 00:27:22,240
one-way passive sniffing as well as some

909
00:27:22,240 --> 00:27:22,799
other things

910
00:27:22,799 --> 00:27:24,720
it was very useful for getting the

911
00:27:24,720 --> 00:27:27,679
emulation working

912
00:27:28,120 --> 00:27:30,720
ic14443a communication works in a

913
00:27:30,720 --> 00:27:32,240
certain way for enumeration

914
00:27:32,240 --> 00:27:34,960
it requires three key aspects so what

915
00:27:34,960 --> 00:27:36,399
happens is the reader

916
00:27:36,399 --> 00:27:39,039
sends a wake up or a request command the

917
00:27:39,039 --> 00:27:40,960
tag sends an atqa command which gives

918
00:27:40,960 --> 00:27:43,120
initial information about how the tag is

919
00:27:43,120 --> 00:27:45,679
configured or what kind of tag it is

920
00:27:45,679 --> 00:27:48,000
the reader then select you runs the

921
00:27:48,000 --> 00:27:49,919
select command which returns a uid which

922
00:27:49,919 --> 00:27:50,720
on phones

923
00:27:50,720 --> 00:27:52,320
are forced to be randomized except the

924
00:27:52,320 --> 00:27:53,919
first byte which is always zero eight

925
00:27:53,919 --> 00:27:56,159
to prove that it's not a real tag and

926
00:27:56,159 --> 00:27:57,760
then a sak command

927
00:27:57,760 --> 00:27:59,039
to give information about whether your

928
00:27:59,039 --> 00:28:00,840
id is slightly larger needs further

929
00:28:00,840 --> 00:28:04,159
enumeration or any other changes

930
00:28:04,159 --> 00:28:06,000
wire nci could modify this to a certain

931
00:28:06,000 --> 00:28:07,600
amount however certain bits were set in

932
00:28:07,600 --> 00:28:09,919
any atqa value and stack value i sent

933
00:28:09,919 --> 00:28:11,600
which meant that it was restricted to be

934
00:28:11,600 --> 00:28:13,840
always being known as a phone

935
00:28:13,840 --> 00:28:15,840
i found out later that these values are

936
00:28:15,840 --> 00:28:17,279
probably stored in individual hardware

937
00:28:17,279 --> 00:28:18,640
registers i need to find out how this

938
00:28:18,640 --> 00:28:20,720
worked

939
00:28:20,720 --> 00:28:22,880
i sent specific values to the chip and

940
00:28:22,880 --> 00:28:24,559
then searched through ram to see if i

941
00:28:24,559 --> 00:28:25,279
could find

942
00:28:25,279 --> 00:28:26,960
where they were stored in ram i then

943
00:28:26,960 --> 00:28:28,320
compared this to ida

944
00:28:28,320 --> 00:28:30,559
and found where those the addresses of

945
00:28:30,559 --> 00:28:31,600
these were

946
00:28:31,600 --> 00:28:34,880
compared with hardware addresses

947
00:28:34,880 --> 00:28:36,720
and i found this function which loaded

948
00:28:36,720 --> 00:28:39,200
each sac and adq and uid value into

949
00:28:39,200 --> 00:28:41,760
certain addresses

950
00:28:41,760 --> 00:28:43,440
this would give me quite a lot of

951
00:28:43,440 --> 00:28:45,200
insight in out how tall that works and i

952
00:28:45,200 --> 00:28:47,600
could modify it as needed

953
00:28:47,600 --> 00:28:50,080
i overrode this function and then called

954
00:28:50,080 --> 00:28:51,840
it from within the new function i made

955
00:28:51,840 --> 00:28:53,120
this would allow me to set up all the

956
00:28:53,120 --> 00:28:54,559
hardware as i needed to without me

957
00:28:54,559 --> 00:28:55,919
needing to

958
00:28:55,919 --> 00:28:59,200
do it myself what i then did was over um

959
00:28:59,200 --> 00:29:00,799
overwrote what they had implemented into

960
00:29:00,799 --> 00:29:03,200
the hardware so what uid value and

961
00:29:03,200 --> 00:29:05,679
sac and hqa values they initialized and

962
00:29:05,679 --> 00:29:06,960
put my own ones in

963
00:29:06,960 --> 00:29:08,720
i then confirmed this using approximate

964
00:29:08,720 --> 00:29:10,480
readers to prove that my new uid sac and

965
00:29:10,480 --> 00:29:11,600
atq alpha values

966
00:29:11,600 --> 00:29:14,240
had worked

967
00:29:14,720 --> 00:29:16,320
when i looked on the proper mark i found

968
00:29:16,320 --> 00:29:18,159
that sys was successful and allowed me

969
00:29:18,159 --> 00:29:20,080
for modification of any enumeration so

970
00:29:20,080 --> 00:29:24,000
i had made a custom seven byte uid

971
00:29:24,000 --> 00:29:25,679
set it up to pretend to be a myfair

972
00:29:25,679 --> 00:29:28,080
classic mini tag and

973
00:29:28,080 --> 00:29:31,200
yeah worked absolutely beautiful but

974
00:29:31,200 --> 00:29:32,799
it would not allow me to do full

975
00:29:32,799 --> 00:29:33,919
communication it wouldn't allow me to

976
00:29:33,919 --> 00:29:34,559
emulate

977
00:29:34,559 --> 00:29:36,240
the myfair classic part of the modifier

978
00:29:36,240 --> 00:29:37,919
classic communication just to pretend to

979
00:29:37,919 --> 00:29:40,960
be one on a superficial level

980
00:29:40,960 --> 00:29:42,559
i knew that the chip would respond to

981
00:29:42,559 --> 00:29:44,399
halt and rats commands

982
00:29:44,399 --> 00:29:45,600
rats commands being some more

983
00:29:45,600 --> 00:29:47,279
configuration data being returned and

984
00:29:47,279 --> 00:29:48,720
halt commands being

985
00:29:48,720 --> 00:29:50,799
a more high level communication aspect

986
00:29:50,799 --> 00:29:52,399
of the enumeration setup

987
00:29:52,399 --> 00:29:53,760
i search for the rats command using

988
00:29:53,760 --> 00:29:55,679
comparison e0 which was

989
00:29:55,679 --> 00:29:58,880
the command by used by nfc for that

990
00:29:58,880 --> 00:30:00,159
particular functionality

991
00:30:00,159 --> 00:30:01,440
and found four results and just looked

992
00:30:01,440 --> 00:30:02,960
through them and worked out which one

993
00:30:02,960 --> 00:30:04,000
was which

994
00:30:04,000 --> 00:30:05,440
and found the specific one which was in

995
00:30:05,440 --> 00:30:08,000
use this led me to find the exact state

996
00:30:08,000 --> 00:30:10,799
machine that was used by the chip to do

997
00:30:10,799 --> 00:30:12,000
further communication

998
00:30:12,000 --> 00:30:13,360
and also found some further valid

999
00:30:13,360 --> 00:30:15,279
commands

1000
00:30:15,279 --> 00:30:16,720
further tracing of this found how it

1001
00:30:16,720 --> 00:30:18,640
rested responses so i found how the

1002
00:30:18,640 --> 00:30:19,360
hardware

1003
00:30:19,360 --> 00:30:20,799
registers were set up so i found that it

1004
00:30:20,799 --> 00:30:22,240
was using the same hardware address

1005
00:30:22,240 --> 00:30:24,240
space as the rest of the nfc setup so

1006
00:30:24,240 --> 00:30:26,480
four zero zero two zero zero zero

1007
00:30:26,480 --> 00:30:28,559
however i found that the length was set

1008
00:30:28,559 --> 00:30:30,960
up at zero eight in this address space

1009
00:30:30,960 --> 00:30:33,440
and that the data itself was set up at

1010
00:30:33,440 --> 00:30:35,919
um hex 100 in the stress space which was

1011
00:30:35,919 --> 00:30:37,760
just underneath hex 200 where data was

1012
00:30:37,760 --> 00:30:38,399
received so

1013
00:30:38,399 --> 00:30:40,480
senders and receives were quite next to

1014
00:30:40,480 --> 00:30:41,840
each other but also had quite a lot of

1015
00:30:41,840 --> 00:30:44,559
space to do what they wanted to

1016
00:30:44,559 --> 00:30:46,320
i wrote all these registers out and

1017
00:30:46,320 --> 00:30:47,760
dumped them into a new function which i

1018
00:30:47,760 --> 00:30:48,720
could then

1019
00:30:48,720 --> 00:30:53,120
use to modify as needed

1020
00:30:53,120 --> 00:30:54,480
a basic read command was then

1021
00:30:54,480 --> 00:30:57,519
implemented which is always used by uh

1022
00:30:57,519 --> 00:31:00,480
nfc which um in my fair classic and my

1023
00:31:00,480 --> 00:31:02,320
fair tags in general which is three zero

1024
00:31:02,320 --> 00:31:04,320
and then a block size and then a crc

1025
00:31:04,320 --> 00:31:05,679
which is just a standard and

1026
00:31:05,679 --> 00:31:08,960
an encrypted read while my fair classic

1027
00:31:08,960 --> 00:31:10,399
does encrypt these um

1028
00:31:10,399 --> 00:31:12,080
requests and we'll come to that later

1029
00:31:12,080 --> 00:31:14,240
some my standard myfair tags do not

1030
00:31:14,240 --> 00:31:15,679
and by implementing it i could prove

1031
00:31:15,679 --> 00:31:17,600
that i could do full communication on

1032
00:31:17,600 --> 00:31:20,559
this chip in any way i needed to

1033
00:31:20,559 --> 00:31:22,640
i overrode the entire state machine and

1034
00:31:22,640 --> 00:31:24,320
added my own functionality so i could

1035
00:31:24,320 --> 00:31:25,840
add in write blocks read blocks and

1036
00:31:25,840 --> 00:31:27,760
authentication commands used by

1037
00:31:27,760 --> 00:31:30,559
the myfair classic and i also

1038
00:31:30,559 --> 00:31:32,000
re-implemented the whole command so that

1039
00:31:32,000 --> 00:31:32,720
it called

1040
00:31:32,720 --> 00:31:34,559
the whole command in the actual firmware

1041
00:31:34,559 --> 00:31:36,240
at 5e09

1042
00:31:36,240 --> 00:31:37,840
um so that i could didn't have to affect

1043
00:31:37,840 --> 00:31:38,960
the internal state machine of the

1044
00:31:38,960 --> 00:31:40,559
hardware too much because it was set up

1045
00:31:40,559 --> 00:31:42,720
by this

1046
00:31:42,720 --> 00:31:44,399
i also added some non-standard debugging

1047
00:31:44,399 --> 00:31:46,159
commands such as seven zero

1048
00:31:46,159 --> 00:31:48,480
which allowed me to dump out raw memory

1049
00:31:48,480 --> 00:31:50,399
from the chip via nfc so i could do it

1050
00:31:50,399 --> 00:31:53,679
via i2c or nfc as needed

1051
00:31:53,679 --> 00:31:56,080
with this full control i could emulate

1052
00:31:56,080 --> 00:31:58,159
any iso 1443a tag

1053
00:31:58,159 --> 00:31:59,679
i stuck with the mifa classic but i

1054
00:31:59,679 --> 00:32:01,840
could expand this quite a lot

1055
00:32:01,840 --> 00:32:04,320
the full authentication mechanisms which

1056
00:32:04,320 --> 00:32:05,600
are implemented which are quite old but

1057
00:32:05,600 --> 00:32:07,760
quite simple it authenticates using um

1058
00:32:07,760 --> 00:32:09,519
sort of a standard key which that

1059
00:32:09,519 --> 00:32:10,960
provides them a level of mutual

1060
00:32:10,960 --> 00:32:12,080
authentication

1061
00:32:12,080 --> 00:32:13,760
and while it did work unfortunately

1062
00:32:13,760 --> 00:32:15,360
because i was loading eight bit buffers

1063
00:32:15,360 --> 00:32:16,399
into the

1064
00:32:16,399 --> 00:32:18,559
responses there was no space to modify

1065
00:32:18,559 --> 00:32:20,240
the parity bit which is quite heavily

1066
00:32:20,240 --> 00:32:20,720
used

1067
00:32:20,720 --> 00:32:22,080
in my fair classic as part of the

1068
00:32:22,080 --> 00:32:24,000
encryption

1069
00:32:24,000 --> 00:32:26,640
how this works is every eight bits it

1070
00:32:26,640 --> 00:32:28,399
has an extra bit

1071
00:32:28,399 --> 00:32:31,279
in nfc communication which is used to

1072
00:32:31,279 --> 00:32:32,799
check the parity of the previous data

1073
00:32:32,799 --> 00:32:34,080
and just to make sure that there's no

1074
00:32:34,080 --> 00:32:36,320
communication errors whatsoever now this

1075
00:32:36,320 --> 00:32:37,279
as standard

1076
00:32:37,279 --> 00:32:38,399
was found to be implemented in the

1077
00:32:38,399 --> 00:32:41,039
hardware of the chip so that you

1078
00:32:41,039 --> 00:32:42,399
didn't have to bottle with this in

1079
00:32:42,399 --> 00:32:44,240
software however i found that this meant

1080
00:32:44,240 --> 00:32:45,679
that i couldn't modify

1081
00:32:45,679 --> 00:32:49,360
the um firmware at all in order to

1082
00:32:49,360 --> 00:32:51,440
fully implement my flair classic because

1083
00:32:51,440 --> 00:32:53,360
no standard reader would

1084
00:32:53,360 --> 00:32:54,559
look at this and think that the

1085
00:32:54,559 --> 00:32:56,559
encrypted parity bit was correct i think

1086
00:32:56,559 --> 00:32:58,320
communication was broken

1087
00:32:58,320 --> 00:32:59,760
however i thought it was very likely

1088
00:32:59,760 --> 00:33:00,799
that there was a hardware register

1089
00:33:00,799 --> 00:33:01,519
somewhere

1090
00:33:01,519 --> 00:33:02,880
which would allow for modifying of this

1091
00:33:02,880 --> 00:33:04,640
parity bit um in

1092
00:33:04,640 --> 00:33:06,799
myself however this would mean pushing

1093
00:33:06,799 --> 00:33:08,880
8-bit and 9-bit buffers around

1094
00:33:08,880 --> 00:33:12,320
in some complex ways i modified each

1095
00:33:12,320 --> 00:33:14,000
register used by the hardware and turn

1096
00:33:14,000 --> 00:33:15,440
and see if any responses were changed

1097
00:33:15,440 --> 00:33:17,360
now i had a few interesting outcomes

1098
00:33:17,360 --> 00:33:20,080
like it increased the um sizes of the

1099
00:33:20,080 --> 00:33:21,440
responses in weird ways

1100
00:33:21,440 --> 00:33:23,200
or added strange crcs i've never seen

1101
00:33:23,200 --> 00:33:24,799
before which all had seemed to have some

1102
00:33:24,799 --> 00:33:26,159
functionality which was unrelated to

1103
00:33:26,159 --> 00:33:27,600
what i was trying to find

1104
00:33:27,600 --> 00:33:29,919
however i found address four zero zero

1105
00:33:29,919 --> 00:33:31,360
two zero zero zero four

1106
00:33:31,360 --> 00:33:35,279
by seven bit four thousand i could um

1107
00:33:35,279 --> 00:33:37,360
modify the parity bits as needed all i

1108
00:33:37,360 --> 00:33:38,799
had to do was

1109
00:33:38,799 --> 00:33:40,240
change the size of the responses i was

1110
00:33:40,240 --> 00:33:43,200
sending and send an extra bit per byte

1111
00:33:43,200 --> 00:33:45,279
meaning i was sending nine bit values

1112
00:33:45,279 --> 00:33:46,640
into eight bit buffers

1113
00:33:46,640 --> 00:33:47,600
just meaning that things had to be

1114
00:33:47,600 --> 00:33:49,760
shifted around a bit with this however

1115
00:33:49,760 --> 00:33:51,039
my fair classic could be fully

1116
00:33:51,039 --> 00:33:52,799
implemented and i had

1117
00:33:52,799 --> 00:33:54,399
access to full communication on my third

1118
00:33:54,399 --> 00:33:56,159
classic and it

1119
00:33:56,159 --> 00:33:59,760
worked i also made the

1120
00:33:59,760 --> 00:34:02,240
chip send back right to the my fair

1121
00:34:02,240 --> 00:34:04,159
classic tag via i2c meaning

1122
00:34:04,159 --> 00:34:07,519
if i uploaded a file nfc tag to the chip

1123
00:34:07,519 --> 00:34:09,199
i could then get changes to it back so

1124
00:34:09,199 --> 00:34:10,239
that i could have some persistent

1125
00:34:10,239 --> 00:34:12,000
storage of this data

1126
00:34:12,000 --> 00:34:13,839
now here's a quick demo of this all i've

1127
00:34:13,839 --> 00:34:15,280
done is taken a different phone using

1128
00:34:15,280 --> 00:34:17,040
the nxp

1129
00:34:17,040 --> 00:34:19,040
tag info tool and i've placed it on top

1130
00:34:19,040 --> 00:34:20,560
of my samsung s9

1131
00:34:20,560 --> 00:34:22,639
and what you'll see is that after a

1132
00:34:22,639 --> 00:34:24,239
while after it's uh

1133
00:34:24,239 --> 00:34:25,599
checked all of its keys and checked all

1134
00:34:25,599 --> 00:34:27,440
the authentication it will come back and

1135
00:34:27,440 --> 00:34:28,399
show that it

1136
00:34:28,399 --> 00:34:31,119
was in fact uh identified as a myfair

1137
00:34:31,119 --> 00:34:32,079
classic tag

1138
00:34:32,079 --> 00:34:34,159
and tried to authenticate all of the nfc

1139
00:34:34,159 --> 00:34:35,280
blocks available

1140
00:34:35,280 --> 00:34:38,239
so there we go now i tried a different a

1141
00:34:38,239 --> 00:34:39,839
few different keys and a few different

1142
00:34:39,839 --> 00:34:41,199
settings in here just to make it look

1143
00:34:41,199 --> 00:34:43,040
more interesting but essentially this

1144
00:34:43,040 --> 00:34:44,399
was full implementation of my fair

1145
00:34:44,399 --> 00:34:46,560
classic

1146
00:34:46,560 --> 00:34:48,320
final notes on this are that with this

1147
00:34:48,320 --> 00:34:50,960
you could spoof any 13.56 megahertz

1148
00:34:50,960 --> 00:34:52,159
access control

1149
00:34:52,159 --> 00:34:54,320
while this didn't uh include 125

1150
00:34:54,320 --> 00:34:55,839
kilohertz access controls which is still

1151
00:34:55,839 --> 00:34:56,800
widely used

1152
00:34:56,800 --> 00:34:58,800
it was quite a lot of access you could

1153
00:34:58,800 --> 00:35:01,680
now gain by modifying this setup

1154
00:35:01,680 --> 00:35:03,599
however you also had more esoteric uses

1155
00:35:03,599 --> 00:35:05,040
which uh

1156
00:35:05,040 --> 00:35:06,480
for things like toys and games and

1157
00:35:06,480 --> 00:35:09,520
things which use this functionality

1158
00:35:09,520 --> 00:35:11,040
um despite the fact that i'd patch the

1159
00:35:11,040 --> 00:35:12,720
firmware all other nasty functionality

1160
00:35:12,720 --> 00:35:14,400
of the chip would work as normal so

1161
00:35:14,400 --> 00:35:15,839
if i set it back to act as a reader or

1162
00:35:15,839 --> 00:35:17,520
any other kind of tag it would work like

1163
00:35:17,520 --> 00:35:17,920
that

1164
00:35:17,920 --> 00:35:21,040
absolutely fine you'd i'd find that this

1165
00:35:21,040 --> 00:35:22,560
would probably be more subtle than using

1166
00:35:22,560 --> 00:35:24,640
a prox mark as it was more subtle than a

1167
00:35:24,640 --> 00:35:26,079
dedicated attack tool

1168
00:35:26,079 --> 00:35:27,599
it's a phone which no one expects to

1169
00:35:27,599 --> 00:35:29,280
have any of this functionality built in

1170
00:35:29,280 --> 00:35:31,200
whereas carrying around a proxy market

1171
00:35:31,200 --> 00:35:34,560
or antenna is slightly less subtle

1172
00:35:34,560 --> 00:35:35,920
expansion of this functionality would

1173
00:35:35,920 --> 00:35:37,920
allow you to dump authentication

1174
00:35:37,920 --> 00:35:40,560
and keys off readers just by the virtue

1175
00:35:40,560 --> 00:35:41,200
of how

1176
00:35:41,200 --> 00:35:42,839
some of these authentications are

1177
00:35:42,839 --> 00:35:44,720
implemented and you could

1178
00:35:44,720 --> 00:35:46,720
implement on any supported protocol not

1179
00:35:46,720 --> 00:35:50,079
just iso 1443a but also 4443b

1180
00:35:50,079 --> 00:35:52,240
or anyone supported by the chipset and

1181
00:35:52,240 --> 00:35:53,680
now that the framework is in place it

1182
00:35:53,680 --> 00:35:55,200
would be easy to develop these four

1183
00:35:55,200 --> 00:35:57,119
it's simply a case of combining the code

1184
00:35:57,119 --> 00:35:59,040
now

1185
00:35:59,040 --> 00:36:00,720
i outlined all the vulnerabilities and

1186
00:36:00,720 --> 00:36:02,320
the patches i'd made to samsung and

1187
00:36:02,320 --> 00:36:03,440
they've patched this out

1188
00:36:03,440 --> 00:36:05,760
in their current chip sets as of april

1189
00:36:05,760 --> 00:36:06,880
2020 that means

1190
00:36:06,880 --> 00:36:09,200
chipsets of this version and that were

1191
00:36:09,200 --> 00:36:10,480
manufactured after that date would no

1192
00:36:10,480 --> 00:36:12,000
longer be available to this but there's

1193
00:36:12,000 --> 00:36:13,760
still plenty about that are

1194
00:36:13,760 --> 00:36:15,200
the vulnerability did require root

1195
00:36:15,200 --> 00:36:16,720
access which meant that the phone

1196
00:36:16,720 --> 00:36:18,720
wouldn't be compromised by this attack

1197
00:36:18,720 --> 00:36:20,480
but the chip was compromised in ways

1198
00:36:20,480 --> 00:36:21,839
that would make it much more useful than

1199
00:36:21,839 --> 00:36:23,520
it would be as standard

1200
00:36:23,520 --> 00:36:24,720
we have to remember that phones are

1201
00:36:24,720 --> 00:36:27,280
exploitable embedded devices you

1202
00:36:27,280 --> 00:36:28,960
can treat it like any iot device you're

1203
00:36:28,960 --> 00:36:30,240
attacking as long as you approach it the

1204
00:36:30,240 --> 00:36:30,800
right way

1205
00:36:30,800 --> 00:36:32,320
while the security might be higher

1206
00:36:32,320 --> 00:36:33,520
there's definitely some interesting

1207
00:36:33,520 --> 00:36:34,720
things you can look at

1208
00:36:34,720 --> 00:36:37,119
especially bootloader vulnerabilities

1209
00:36:37,119 --> 00:36:38,880
these are increasingly common and just

1210
00:36:38,880 --> 00:36:40,320
by virtue of the fact that bootloader

1211
00:36:40,320 --> 00:36:42,320
vulnerabilities are in the bootloader

1212
00:36:42,320 --> 00:36:43,680
they're going to remain for years

1213
00:36:43,680 --> 00:36:45,359
because no one can patch them out you've

1214
00:36:45,359 --> 00:36:46,640
got to think of things like the nintendo

1215
00:36:46,640 --> 00:36:47,839
switch exploits

1216
00:36:47,839 --> 00:36:50,000
which had to have fuel hardware

1217
00:36:50,000 --> 00:36:51,680
revisions and still have

1218
00:36:51,680 --> 00:36:53,119
switches out there which are vulnerable

1219
00:36:53,119 --> 00:36:56,000
to bootloader-based vulnerabilities

1220
00:36:56,000 --> 00:36:58,079
um developing custom firmware for

1221
00:36:58,079 --> 00:36:59,599
proprietary chips like this

1222
00:36:59,599 --> 00:37:01,920
is interesting and challenging but it's

1223
00:37:01,920 --> 00:37:03,520
also rewarding you can make some really

1224
00:37:03,520 --> 00:37:05,040
interesting stuff happen with this

1225
00:37:05,040 --> 00:37:06,240
you've got to think about also things

1226
00:37:06,240 --> 00:37:08,000
like broadcom chipsets where people have

1227
00:37:08,000 --> 00:37:10,160
added wi-fi monitor mode at a later date

1228
00:37:10,160 --> 00:37:12,000
or modifications things like bluetooth

1229
00:37:12,000 --> 00:37:13,200
chipsets where you could add extra

1230
00:37:13,200 --> 00:37:14,640
debugging functionality

1231
00:37:14,640 --> 00:37:16,160
and lastly if an undisclosed

1232
00:37:16,160 --> 00:37:17,839
vulnerability is found in an old chip

1233
00:37:17,839 --> 00:37:19,440
it'll likely be in a new one

1234
00:37:19,440 --> 00:37:23,839
thank you very much

1235
00:37:24,720 --> 00:37:26,160
hello everyone thank you very much for

1236
00:37:26,160 --> 00:37:28,000
coming to my talk i hope you enjoyed it

1237
00:37:28,000 --> 00:37:28,640
now um

1238
00:37:28,640 --> 00:37:29,920
i've seen a couple of questions in the

1239
00:37:29,920 --> 00:37:31,520
chat that i'm just going to briefly go

1240
00:37:31,520 --> 00:37:32,320
through and

1241
00:37:32,320 --> 00:37:35,760
hopefully answer them for you firstly uh

1242
00:37:35,760 --> 00:37:37,200
i had a question regarding mobile

1243
00:37:37,200 --> 00:37:38,240
payments now

1244
00:37:38,240 --> 00:37:39,680
due to the nature of this vulnerability

1245
00:37:39,680 --> 00:37:40,800
and the fact that you need to root a

1246
00:37:40,800 --> 00:37:41,920
phone to do it

1247
00:37:41,920 --> 00:37:44,640
it's required that someone would have to

1248
00:37:44,640 --> 00:37:45,760
intentionally be trying to do this in

1249
00:37:45,760 --> 00:37:46,960
the first place now when you work with

1250
00:37:46,960 --> 00:37:48,880
mobile payments especially with samsung

1251
00:37:48,880 --> 00:37:50,640
you have the fear of tripping knocks and

1252
00:37:50,640 --> 00:37:51,839
all sorts of other security measures

1253
00:37:51,839 --> 00:37:53,280
that can be bypassed but it's much more

1254
00:37:53,280 --> 00:37:54,079
difficult

1255
00:37:54,079 --> 00:37:55,440
the whole purpose of bypassing this

1256
00:37:55,440 --> 00:37:57,200
particular chip isn't really to

1257
00:37:57,200 --> 00:37:58,720
affect mobile payments as it won't

1258
00:37:58,720 --> 00:38:00,640
really be affected by this but more to

1259
00:38:00,640 --> 00:38:02,079
expand the functionality of your phone

1260
00:38:02,079 --> 00:38:03,440
into an attack tool

1261
00:38:03,440 --> 00:38:06,560
rather than a device for affecting

1262
00:38:06,560 --> 00:38:07,680
mobile payments which is something you

1263
00:38:07,680 --> 00:38:08,880
wouldn't generally do

1264
00:38:08,880 --> 00:38:12,480
on a uh not a rooted phone anyway

1265
00:38:12,480 --> 00:38:14,000
um with regards to the question about um

1266
00:38:14,000 --> 00:38:15,520
cortex-m chips so

1267
00:38:15,520 --> 00:38:17,119
it's used the chip itself was using a

1268
00:38:17,119 --> 00:38:19,280
secure core architecture now this is a

1269
00:38:19,280 --> 00:38:20,960
more lockdown architecture developed by

1270
00:38:20,960 --> 00:38:22,560
arm which essentially has

1271
00:38:22,560 --> 00:38:25,359
the same capabilities of a cortex-m chip

1272
00:38:25,359 --> 00:38:26,160
but it's used

1273
00:38:26,160 --> 00:38:27,839
purely for these secure applications

1274
00:38:27,839 --> 00:38:28,880
where you don't want to be able to do

1275
00:38:28,880 --> 00:38:29,680
things like

1276
00:38:29,680 --> 00:38:31,920
access ram or access protected memory in

1277
00:38:31,920 --> 00:38:33,040
certain ways now

1278
00:38:33,040 --> 00:38:34,800
the details about how all of this works

1279
00:38:34,800 --> 00:38:36,480
and how it's architected is something

1280
00:38:36,480 --> 00:38:38,160
you need to sign in nda to get from arm

1281
00:38:38,160 --> 00:38:39,680
to do so it's not something you'll fully

1282
00:38:39,680 --> 00:38:40,640
be able to

1283
00:38:40,640 --> 00:38:42,960
be capable of but you can make

1284
00:38:42,960 --> 00:38:44,720
assumptions based on what capabilities

1285
00:38:44,720 --> 00:38:47,280
this particular chip had about what um

1286
00:38:47,280 --> 00:38:48,480
capabilities you would have with a

1287
00:38:48,480 --> 00:38:50,800
secure core now if it was a cortex

1288
00:38:50,800 --> 00:38:52,720
m3 or something of that type i would

1289
00:38:52,720 --> 00:38:54,160
have been more able to write things like

1290
00:38:54,160 --> 00:38:55,839
shell code right into the stack

1291
00:38:55,839 --> 00:38:57,440
and jump to it to perform things like

1292
00:38:57,440 --> 00:38:58,880
adding that magic number to the start of

1293
00:38:58,880 --> 00:38:59,599
the firmware

1294
00:38:59,599 --> 00:39:00,800
so instead of doing that i could add

1295
00:39:00,800 --> 00:39:02,800
those features into my custom firmware

1296
00:39:02,800 --> 00:39:03,440
which

1297
00:39:03,440 --> 00:39:06,480
was effective as well um

1298
00:39:06,480 --> 00:39:08,960
i think that's all the questions we have

1299
00:39:08,960 --> 00:39:10,079
if there are any others

1300
00:39:10,079 --> 00:39:11,359
coming through the chat please let me

1301
00:39:11,359 --> 00:39:14,000
know if not i am i think we are all

1302
00:39:14,000 --> 00:39:21,119
good and thank you for having me

