1
00:00:01,360 --> 00:00:03,600
hello i'm veronica kova

2
00:00:03,600 --> 00:00:06,640
and today i am going to talk about over

3
00:00:06,640 --> 00:00:07,359
the air

4
00:00:07,359 --> 00:00:10,879
bluetooth slow energy hacking

5
00:00:11,599 --> 00:00:14,240
i have been in a security field for many

6
00:00:14,240 --> 00:00:15,519
years

7
00:00:15,519 --> 00:00:19,119
and in 2018 i wanted to do something

8
00:00:19,119 --> 00:00:19,840
that i

9
00:00:19,840 --> 00:00:22,960
had not done before and i started a

10
00:00:22,960 --> 00:00:24,240
company

11
00:00:24,240 --> 00:00:27,599
and has been focusing on researching

12
00:00:27,599 --> 00:00:31,039
bluetooth security

13
00:00:31,039 --> 00:00:34,880
and today i am going to share my story

14
00:00:34,880 --> 00:00:37,200
from knowing almost nothing about

15
00:00:37,200 --> 00:00:38,480
bluetooth

16
00:00:38,480 --> 00:00:42,000
to find the remote code vulnerabilities

17
00:00:42,000 --> 00:00:45,840
in the firmware level

18
00:00:46,640 --> 00:00:49,840
and first i started i started

19
00:00:49,840 --> 00:00:52,960
uh the bruce's security by uh surveying

20
00:00:52,960 --> 00:00:54,399
the existing

21
00:00:54,399 --> 00:00:58,079
bluetooth security researchers then i

22
00:00:58,079 --> 00:01:01,039
read about bluetooth specification which

23
00:01:01,039 --> 00:01:01,760
is actually

24
00:01:01,760 --> 00:01:05,519
uh pretty large but i didn't read all of

25
00:01:05,519 --> 00:01:06,320
it

26
00:01:06,320 --> 00:01:10,479
i generally focusing on the lens field

27
00:01:10,479 --> 00:01:13,760
and embedded headers that programmers

28
00:01:13,760 --> 00:01:16,479
likely make mistakes

29
00:01:16,479 --> 00:01:19,759
then i look for open uh source

30
00:01:19,759 --> 00:01:21,040
implementations

31
00:01:21,040 --> 00:01:23,920
because sometimes documentation wasn't

32
00:01:23,920 --> 00:01:24,400
uh

33
00:01:24,400 --> 00:01:27,520
very vague and for

34
00:01:27,520 --> 00:01:30,000
brutus classy i couldn't find any open

35
00:01:30,000 --> 00:01:32,079
source implementations

36
00:01:32,079 --> 00:01:36,079
but i found zephyr and apache my new

37
00:01:36,079 --> 00:01:38,799
nimble that is a bluetooth low energy

38
00:01:38,799 --> 00:01:39,759
open source

39
00:01:39,759 --> 00:01:43,200
open source implementation

40
00:01:43,600 --> 00:01:46,640
but today i'm going to talk about mainly

41
00:01:46,640 --> 00:01:48,079
focusing on the

42
00:01:48,079 --> 00:01:50,560
ble because that's the one that i have

43
00:01:50,560 --> 00:01:51,600
been focused on

44
00:01:51,600 --> 00:01:54,799
recently and here

45
00:01:54,799 --> 00:01:57,840
there is a ble stack

46
00:01:57,840 --> 00:02:00,960
and there are many protocols and for the

47
00:02:00,960 --> 00:02:02,880
dual chip configuration

48
00:02:02,880 --> 00:02:06,000
these protocols belong to host

49
00:02:06,000 --> 00:02:08,639
and these two protocols belongs to the

50
00:02:08,639 --> 00:02:10,878
ble controller

51
00:02:10,878 --> 00:02:14,480
and the specification define how hc

52
00:02:14,480 --> 00:02:16,720
a host controller interface should be

53
00:02:16,720 --> 00:02:19,440
implemented

54
00:02:20,239 --> 00:02:23,440
through the hci hosts generate

55
00:02:23,440 --> 00:02:28,400
generate hci commands to ble controller

56
00:02:28,400 --> 00:02:32,800
and ble controller generate atci events

57
00:02:32,800 --> 00:02:36,080
to send back the result to the host

58
00:02:36,080 --> 00:02:38,879
and when you receive uh receive ble

59
00:02:38,879 --> 00:02:41,440
packets it also generates hci events

60
00:02:41,440 --> 00:02:44,000
to the host

61
00:02:45,680 --> 00:02:48,080
and for this here single chip

62
00:02:48,080 --> 00:02:49,440
configuration

63
00:02:49,440 --> 00:02:52,480
this all protocols will be

64
00:02:52,480 --> 00:02:55,599
located on the ble controller

65
00:02:55,599 --> 00:02:58,159
but for this configuration the

66
00:02:58,159 --> 00:02:59,360
specification

67
00:02:59,360 --> 00:03:02,159
does not define how hci should be

68
00:03:02,159 --> 00:03:03,599
implemented

69
00:03:03,599 --> 00:03:07,200
so it is up to the implementer they can

70
00:03:07,200 --> 00:03:10,480
use memory cue or they can choose just

71
00:03:10,480 --> 00:03:14,480
not having an explicit hci layer

72
00:03:14,480 --> 00:03:17,599
but this tool our focusing on this link

73
00:03:17,599 --> 00:03:19,840
layer

74
00:03:20,720 --> 00:03:23,599
when i started this research in mid uh

75
00:03:23,599 --> 00:03:24,640
28

76
00:03:24,640 --> 00:03:28,319
2018 there was a literally zero

77
00:03:28,319 --> 00:03:31,360
of uh zero controller specific

78
00:03:31,360 --> 00:03:34,879
vulnerabilities but now

79
00:03:34,879 --> 00:03:37,519
there are 14 of them including a bt

80
00:03:37,519 --> 00:03:38,319
classic

81
00:03:38,319 --> 00:03:42,000
and ble vulnerabilities

82
00:03:42,000 --> 00:03:46,000
of this 14 only

83
00:03:46,000 --> 00:03:49,920
there are only three proven ble rc

84
00:03:49,920 --> 00:03:52,080
vulnerabilities

85
00:03:52,080 --> 00:03:55,040
the first one you probably heard of is

86
00:03:55,040 --> 00:03:56,959
bleeding bit

87
00:03:56,959 --> 00:04:00,879
and the two are the vulnerabilities of

88
00:04:00,879 --> 00:04:05,120
i am going to talk about today today

89
00:04:06,000 --> 00:04:09,200
and let's see why an attacker is

90
00:04:09,200 --> 00:04:11,360
interested in finding this low layer

91
00:04:11,360 --> 00:04:13,040
vulnerabilities

92
00:04:13,040 --> 00:04:15,840
let's say on the tackle form of pc

93
00:04:15,840 --> 00:04:16,720
specific

94
00:04:16,720 --> 00:04:20,639
vulnerability for this case

95
00:04:20,639 --> 00:04:23,840
the attacker can only attack a

96
00:04:23,840 --> 00:04:28,080
single class of the devices

97
00:04:28,080 --> 00:04:30,720
but if an attacker find a vulnerability

98
00:04:30,720 --> 00:04:32,240
on this controller

99
00:04:32,240 --> 00:04:36,639
uh low layer and this controller

100
00:04:36,639 --> 00:04:40,560
used for different classes of devices

101
00:04:40,560 --> 00:04:44,400
he can attack pc or he cannot take car

102
00:04:44,400 --> 00:04:49,198
medical devices or iot devices

103
00:04:49,919 --> 00:04:53,919
and beyond that this low layer

104
00:04:53,919 --> 00:04:56,560
in order to attack this lower layer it

105
00:04:56,560 --> 00:04:58,240
does not require either

106
00:04:58,240 --> 00:05:01,680
authentication or pairing

107
00:05:01,680 --> 00:05:04,160
the attacker just needs to be nearby the

108
00:05:04,160 --> 00:05:05,919
device

109
00:05:05,919 --> 00:05:08,840
and i'm going to talk about four

110
00:05:08,840 --> 00:05:10,000
vulnerabilities

111
00:05:10,000 --> 00:05:13,840
on this low layer today i prepared demos

112
00:05:13,840 --> 00:05:16,479
for the two rca vulnerabilities

113
00:05:16,479 --> 00:05:19,039
and i'll briefly explain two other

114
00:05:19,039 --> 00:05:21,919
vulnerabilities

115
00:05:22,000 --> 00:05:23,280
but before talking about the

116
00:05:23,280 --> 00:05:25,440
vulnerabilities i wanted to

117
00:05:25,440 --> 00:05:28,960
talk about how i set up my lab

118
00:05:28,960 --> 00:05:33,919
in order to start vulnerability hunting

119
00:05:34,960 --> 00:05:39,120
and here is a development board

120
00:05:39,120 --> 00:05:42,080
i recommend to uh start with the

121
00:05:42,080 --> 00:05:42,880
development

122
00:05:42,880 --> 00:05:46,560
uh dab boards because it's easier to

123
00:05:46,560 --> 00:05:49,840
actually find vulnerability and

124
00:05:49,840 --> 00:05:53,120
making exploit because development board

125
00:05:53,120 --> 00:05:54,960
in many cases you can do the hardware

126
00:05:54,960 --> 00:05:56,080
debugging

127
00:05:56,080 --> 00:05:59,280
but just easy it's easier to finding a

128
00:05:59,280 --> 00:05:59,919
vulnerable

129
00:05:59,919 --> 00:06:02,560
vulnerability and making or exploit

130
00:06:02,560 --> 00:06:03,680
compared to the

131
00:06:03,680 --> 00:06:08,080
end product my lab has more than a dozen

132
00:06:08,080 --> 00:06:10,319
dev boards but i'm just showing you this

133
00:06:10,319 --> 00:06:12,639
tool two of them because i'm going to

134
00:06:12,639 --> 00:06:15,680
talk about it today

135
00:06:16,880 --> 00:06:20,720
and there is here some serial converters

136
00:06:20,720 --> 00:06:23,600
just if you have been uh if you have uh

137
00:06:23,600 --> 00:06:24,960
some experience with this software

138
00:06:24,960 --> 00:06:25,919
development

139
00:06:25,919 --> 00:06:29,199
it's just like pre-nap uart is the

140
00:06:29,199 --> 00:06:31,600
basic or the easiest way to debug or

141
00:06:31,600 --> 00:06:33,199
hardware

142
00:06:33,199 --> 00:06:35,840
and i happen to have one here the

143
00:06:35,840 --> 00:06:36,880
leftmost one

144
00:06:36,880 --> 00:06:38,800
this serial converter laying around in

145
00:06:38,800 --> 00:06:41,280
the house and i use this one however it

146
00:06:41,280 --> 00:06:42,800
does not have a cts

147
00:06:42,800 --> 00:06:46,800
and rts lines and it took me for a while

148
00:06:46,800 --> 00:06:47,440
to figure

149
00:06:47,440 --> 00:06:51,280
out even how to see the uart messages

150
00:06:51,280 --> 00:06:52,960
so i do recommend if you're getting the

151
00:06:52,960 --> 00:06:54,319
serial converter

152
00:06:54,319 --> 00:06:57,599
get get ones that has a cts and

153
00:06:57,599 --> 00:07:00,560
rts lines

154
00:07:01,599 --> 00:07:04,720
and here is a hardware debuggers

155
00:07:04,720 --> 00:07:08,479
this here are two upper ones are for

156
00:07:08,479 --> 00:07:12,080
open ocd but using openocd is

157
00:07:12,080 --> 00:07:14,319
required slightly more work than the

158
00:07:14,319 --> 00:07:15,280
sega

159
00:07:15,280 --> 00:07:18,479
jailing debuggers i for the beginners

160
00:07:18,479 --> 00:07:21,039
or the hobbies i recommend using this

161
00:07:21,039 --> 00:07:22,639
sega gel link

162
00:07:22,639 --> 00:07:25,039
for the hobbies you can use this

163
00:07:25,039 --> 00:07:25,840
education

164
00:07:25,840 --> 00:07:28,880
license however for the commercial

165
00:07:28,880 --> 00:07:32,719
you have to get the commercial license

166
00:07:34,240 --> 00:07:37,599
and since i'm enforcing that board i had

167
00:07:37,599 --> 00:07:38,800
to

168
00:07:38,800 --> 00:07:41,919
have a way of power on and off this debt

169
00:07:41,919 --> 00:07:42,639
boards

170
00:07:42,639 --> 00:07:46,160
so i used uhop control and then this

171
00:07:46,160 --> 00:07:49,199
here the usb hub

172
00:07:49,199 --> 00:07:52,479
so the folder can turn it on and off of

173
00:07:52,479 --> 00:07:55,199
my target

174
00:07:55,599 --> 00:07:58,879
and when you generate the arbitrary

175
00:07:58,879 --> 00:08:00,879
ble packet there should be a way to

176
00:08:00,879 --> 00:08:01,919
actually look at them

177
00:08:01,919 --> 00:08:04,240
so you can confirm the packets uh

178
00:08:04,240 --> 00:08:06,240
generated properly

179
00:08:06,240 --> 00:08:08,560
i use the uber tools this is very easy

180
00:08:08,560 --> 00:08:10,319
to use and it has a

181
00:08:10,319 --> 00:08:13,919
very good display however

182
00:08:13,919 --> 00:08:16,160
it looks like a software has not been

183
00:08:16,160 --> 00:08:17,599
updated very recently

184
00:08:17,599 --> 00:08:21,039
so it does not support newer

185
00:08:21,039 --> 00:08:24,400
bluetooth pro of newer bluetooth

186
00:08:24,400 --> 00:08:28,240
protocol features and luckily

187
00:08:28,240 --> 00:08:31,440
there are this sniffle was introduced

188
00:08:31,440 --> 00:08:36,479
at the end of the 2019 at hardware.io

189
00:08:36,479 --> 00:08:39,919
and sniffer does support newer uh

190
00:08:39,919 --> 00:08:42,880
bluetooth specification bluetooth

191
00:08:42,880 --> 00:08:45,919
protocol features

192
00:08:48,160 --> 00:08:51,200
and here's a nordic device and i use the

193
00:08:51,200 --> 00:08:52,800
nordic device in order to generate the

194
00:08:52,800 --> 00:08:55,200
arbitrary packets

195
00:08:55,200 --> 00:08:58,800
i start with the another 52a32

196
00:08:58,800 --> 00:09:01,680
is because this zephyr and nimble has a

197
00:09:01,680 --> 00:09:02,080
lot of

198
00:09:02,080 --> 00:09:04,560
documentations and examples using this

199
00:09:04,560 --> 00:09:05,839
device

200
00:09:05,839 --> 00:09:07,760
that is because the documentation was

201
00:09:07,760 --> 00:09:09,760
written on wire level and

202
00:09:09,760 --> 00:09:13,040
this one was a older dev board

203
00:09:13,040 --> 00:09:15,600
the problem using this older one was in

204
00:09:15,600 --> 00:09:16,320
order to use

205
00:09:16,320 --> 00:09:19,519
us uart i had to

206
00:09:19,519 --> 00:09:22,959
connect my serial converter to dc

207
00:09:22,959 --> 00:09:25,839
some of the individual gpio and it is

208
00:09:25,839 --> 00:09:27,600
kind of cumbersome when you move around

209
00:09:27,600 --> 00:09:28,640
this data board

210
00:09:28,640 --> 00:09:31,040
there's multiple uh cables coming out of

211
00:09:31,040 --> 00:09:32,160
it so

212
00:09:32,160 --> 00:09:36,320
i end up using nrf 5840

213
00:09:36,320 --> 00:09:38,959
and good thing about this board is it

214
00:09:38,959 --> 00:09:40,720
support the virtual comport

215
00:09:40,720 --> 00:09:44,959
so you need only one usb cable

216
00:09:45,360 --> 00:09:48,839
and with this hardware you need a

217
00:09:48,839 --> 00:09:50,480
software and

218
00:09:50,480 --> 00:09:52,320
today i'm going to release the jackpin

219
00:09:52,320 --> 00:09:53,839
nimble

220
00:09:53,839 --> 00:09:56,000
using this jackpin nimble software you

221
00:09:56,000 --> 00:09:57,120
can generate an

222
00:09:57,120 --> 00:10:01,279
arbitrary ble link layer packets

223
00:10:01,279 --> 00:10:04,560
and it will be easy to extend to make

224
00:10:04,560 --> 00:10:07,518
your own folder

225
00:10:07,760 --> 00:10:09,760
checkpoint number come into the two

226
00:10:09,760 --> 00:10:11,040
parts

227
00:10:11,040 --> 00:10:14,160
the first one is the former i made a

228
00:10:14,160 --> 00:10:15,600
modification to the

229
00:10:15,600 --> 00:10:18,399
nimble because of nimble does not

230
00:10:18,399 --> 00:10:20,880
generate a package that violates the

231
00:10:20,880 --> 00:10:23,279
bluetooth specification but we do want

232
00:10:23,279 --> 00:10:23,920
to to

233
00:10:23,920 --> 00:10:26,320
generate the package that doesn't comply

234
00:10:26,320 --> 00:10:29,200
with the specification

235
00:10:29,200 --> 00:10:32,240
and in order to describe this formula

236
00:10:32,240 --> 00:10:35,680
i made a host code here and this host

237
00:10:35,680 --> 00:10:36,640
code is written in

238
00:10:36,640 --> 00:10:40,079
python and this python code

239
00:10:40,079 --> 00:10:43,440
is responsible for making

240
00:10:43,440 --> 00:10:46,240
these arbitrary packets and give it to

241
00:10:46,240 --> 00:10:46,720
the

242
00:10:46,720 --> 00:10:48,640
former and then the formula we're going

243
00:10:48,640 --> 00:10:52,560
to send these packets

244
00:10:52,640 --> 00:10:55,680
now we have left set up then let's look

245
00:10:55,680 --> 00:10:58,480
at a specific chip

246
00:10:58,480 --> 00:11:01,519
the first target is texas instrument

247
00:11:01,519 --> 00:11:04,720
wl 1835 mod chip

248
00:11:04,720 --> 00:11:07,120
and this chip supports bluetooth version

249
00:11:07,120 --> 00:11:09,360
4.2

250
00:11:09,360 --> 00:11:11,839
and this case of develop a board was

251
00:11:11,839 --> 00:11:13,120
slightly different from

252
00:11:13,120 --> 00:11:16,160
other development board units

253
00:11:16,160 --> 00:11:19,040
in that it does not have hardware

254
00:11:19,040 --> 00:11:19,920
debugging

255
00:11:19,920 --> 00:11:23,600
uh exposed and also

256
00:11:23,600 --> 00:11:26,480
uh on this in this chip the bl link

257
00:11:26,480 --> 00:11:27,279
layer

258
00:11:27,279 --> 00:11:30,320
is baked into rom which means the end

259
00:11:30,320 --> 00:11:31,360
product they use

260
00:11:31,360 --> 00:11:34,959
this chip will have the same uh

261
00:11:34,959 --> 00:11:38,000
rom contents as this this device this

262
00:11:38,000 --> 00:11:40,800
development board

263
00:11:41,040 --> 00:11:45,200
and the host or the end product

264
00:11:45,200 --> 00:11:47,839
in order to pass the functionality of

265
00:11:47,839 --> 00:11:48,720
functionality

266
00:11:48,720 --> 00:11:52,000
box or the security vulnerabilities yes

267
00:11:52,000 --> 00:11:56,000
the host use a ti provided patch

268
00:11:56,000 --> 00:11:59,200
and redirect control a floor

269
00:11:59,200 --> 00:12:02,880
into the different new code

270
00:12:02,880 --> 00:12:06,160
nti also provide some tools for the

271
00:12:06,160 --> 00:12:07,519
developers

272
00:12:07,519 --> 00:12:11,120
and one of them is a uh hci tester

273
00:12:11,120 --> 00:12:14,639
and logo and what does this hci tester

274
00:12:14,639 --> 00:12:16,320
does i just mentioned about the patch

275
00:12:16,320 --> 00:12:17,440
file

276
00:12:17,440 --> 00:12:21,360
and the patch part is in binary format

277
00:12:21,360 --> 00:12:25,360
and if you use a hci tester this

278
00:12:25,360 --> 00:12:28,079
tool will translate this binary format

279
00:12:28,079 --> 00:12:28,560
to

280
00:12:28,560 --> 00:12:31,680
human readable strings in the case of

281
00:12:31,680 --> 00:12:34,880
logo when i look at just the uart

282
00:12:34,880 --> 00:12:38,000
message traffic the url messages

283
00:12:38,000 --> 00:12:41,680
actually is in binary format and if you

284
00:12:41,680 --> 00:12:44,320
attach this lower to the uart this lower

285
00:12:44,320 --> 00:12:44,720
will

286
00:12:44,720 --> 00:12:49,360
display log messages in strings

287
00:12:50,399 --> 00:12:53,519
and you we just saw this diagram

288
00:12:53,519 --> 00:12:57,200
in case of this uh ti chip is belong

289
00:12:57,200 --> 00:13:00,880
to this dual chip configuration

290
00:13:00,880 --> 00:13:04,000
and in the demo you will see uh i'm

291
00:13:04,000 --> 00:13:04,720
actually

292
00:13:04,720 --> 00:13:07,279
generating some hci commands in order to

293
00:13:07,279 --> 00:13:09,360
control this uh

294
00:13:09,360 --> 00:13:12,480
ti device

295
00:13:14,480 --> 00:13:17,360
so now i have this development board and

296
00:13:17,360 --> 00:13:19,279
i just need to start from this you know

297
00:13:19,279 --> 00:13:20,240
just read the

298
00:13:20,240 --> 00:13:23,440
one day board so i open uh this patch

299
00:13:23,440 --> 00:13:24,880
file using the

300
00:13:24,880 --> 00:13:28,160
hci tester and i could see there are

301
00:13:28,160 --> 00:13:31,680
many vendor specific right memory

302
00:13:31,680 --> 00:13:33,600
because the patch bar parties you know

303
00:13:33,600 --> 00:13:34,880
to patch

304
00:13:34,880 --> 00:13:37,920
this this

305
00:13:37,920 --> 00:13:41,120
chip that means there can be a read

306
00:13:41,120 --> 00:13:41,680
memory

307
00:13:41,680 --> 00:13:44,240
and i found a read memory in the one of

308
00:13:44,240 --> 00:13:45,199
the files that

309
00:13:45,199 --> 00:13:49,120
ti provides in the file

310
00:13:49,120 --> 00:13:51,120
next to it's the read memory there was a

311
00:13:51,120 --> 00:13:52,320
op call i

312
00:13:52,320 --> 00:13:54,880
took that all called opcode and use the

313
00:13:54,880 --> 00:13:55,440
uh

314
00:13:55,440 --> 00:13:59,680
hci tool which is a linux tool

315
00:13:59,680 --> 00:14:03,600
and i could dump the accessible memory

316
00:14:03,600 --> 00:14:07,440
from uh this data board

317
00:14:07,760 --> 00:14:11,199
and one big step i could basically

318
00:14:11,199 --> 00:14:12,079
reverse this

319
00:14:12,079 --> 00:14:14,320
formula better was i after the

320
00:14:14,320 --> 00:14:15,279
identifying this

321
00:14:15,279 --> 00:14:17,839
log functions i mentioned about the

322
00:14:17,839 --> 00:14:18,959
logger

323
00:14:18,959 --> 00:14:22,399
so this load function send these log

324
00:14:22,399 --> 00:14:24,320
messages in binary format

325
00:14:24,320 --> 00:14:27,680
to the uart and based on this in the

326
00:14:27,680 --> 00:14:28,399
colors

327
00:14:28,399 --> 00:14:31,440
of the basically looking at the colors

328
00:14:31,440 --> 00:14:32,880
of this low function

329
00:14:32,880 --> 00:14:35,279
i could identify some of the function

330
00:14:35,279 --> 00:14:36,240
names

331
00:14:36,240 --> 00:14:39,760
and then some code context

332
00:14:40,720 --> 00:14:44,160
and here's an example when i just

333
00:14:44,160 --> 00:14:48,000
open this formula i just dump the memory

334
00:14:48,000 --> 00:14:50,959
with the ida there is not no information

335
00:14:50,959 --> 00:14:52,959
because there's no symbols

336
00:14:52,959 --> 00:14:56,000
but here this function turns out to be

337
00:14:56,000 --> 00:14:56,880
one of the

338
00:14:56,880 --> 00:15:00,399
low wrapper functions and the first

339
00:15:00,399 --> 00:15:01,199
argument

340
00:15:01,199 --> 00:15:04,800
is the log string id

341
00:15:05,680 --> 00:15:08,800
and after identifying these

342
00:15:08,800 --> 00:15:12,160
many log function wrap like a wrapper

343
00:15:12,160 --> 00:15:13,360
functions

344
00:15:13,360 --> 00:15:16,800
i could see that this particular wrapper

345
00:15:16,800 --> 00:15:20,480
set the loop level to two there is a

346
00:15:20,480 --> 00:15:23,920
level from one to six and it expects

347
00:15:23,920 --> 00:15:27,120
two parameters uh for the

348
00:15:27,120 --> 00:15:29,040
low format string here because you

349
00:15:29,040 --> 00:15:31,440
expect the two parameters here

350
00:15:31,440 --> 00:15:34,720
and for the id once this function takes

351
00:15:34,720 --> 00:15:35,440
this id

352
00:15:35,440 --> 00:15:40,639
it adds 35 80 to this number and

353
00:15:40,639 --> 00:15:43,519
and then figure it out you need to

354
00:15:43,519 --> 00:15:45,600
basically use this string

355
00:15:45,600 --> 00:15:49,199
and based on this string now i can see

356
00:15:49,199 --> 00:15:52,240
the function here name is this

357
00:15:52,240 --> 00:15:57,519
uh this string the perform command

358
00:15:57,519 --> 00:16:00,800
by rep and i made a ida script to repeat

359
00:16:00,800 --> 00:16:03,599
this process

360
00:16:05,279 --> 00:16:07,680
and now i have a lot of steady analysis

361
00:16:07,680 --> 00:16:08,480
information

362
00:16:08,480 --> 00:16:11,199
however many cases this is not enough to

363
00:16:11,199 --> 00:16:12,639
actually identify the

364
00:16:12,639 --> 00:16:14,880
vulnerability or they actually exploit

365
00:16:14,880 --> 00:16:16,959
the vulnerability

366
00:16:16,959 --> 00:16:19,519
so i made a folder i mentioned about the

367
00:16:19,519 --> 00:16:20,639
jackpot nimble

368
00:16:20,639 --> 00:16:23,120
so jack b nimble is basically coded

369
00:16:23,120 --> 00:16:26,320
extracted from this fuzzer

370
00:16:26,320 --> 00:16:28,399
and while i was generating arbitrary

371
00:16:28,399 --> 00:16:31,199
packet and when i crashed the device

372
00:16:31,199 --> 00:16:33,199
the information i'm looking at was not

373
00:16:33,199 --> 00:16:34,880
enough and i will show you example in

374
00:16:34,880 --> 00:16:36,399
the next slide

375
00:16:36,399 --> 00:16:40,399
so i first enjoyed engineered i read the

376
00:16:40,399 --> 00:16:43,680
hard four to heart fault handler code

377
00:16:43,680 --> 00:16:45,680
and they found that there is a flag in

378
00:16:45,680 --> 00:16:47,759
the memory if i set the flag

379
00:16:47,759 --> 00:16:51,360
i could see way more information

380
00:16:51,360 --> 00:16:55,920
and also uh if you i have a way of

381
00:16:55,920 --> 00:16:58,160
hardware debugging i can just check the

382
00:16:58,160 --> 00:17:00,079
register values or the memory

383
00:17:00,079 --> 00:17:02,800
values on the fly but since i don't have

384
00:17:02,800 --> 00:17:03,519
that

385
00:17:03,519 --> 00:17:05,919
i patch this binary in order to read

386
00:17:05,919 --> 00:17:07,760
some register values

387
00:17:07,760 --> 00:17:11,039
or the memory address values and here's

388
00:17:11,039 --> 00:17:12,480
an example

389
00:17:12,480 --> 00:17:15,760
of the logo here if i don't patch in

390
00:17:15,760 --> 00:17:19,039
a binary at all this is the default case

391
00:17:19,039 --> 00:17:22,400
what you can see in the logo

392
00:17:22,400 --> 00:17:24,799
and this particular case is a while

393
00:17:24,799 --> 00:17:25,520
making the

394
00:17:25,520 --> 00:17:27,760
proofable concept code and actually

395
00:17:27,760 --> 00:17:29,840
overload the pc value which we're going

396
00:17:29,840 --> 00:17:32,000
to trigger the hard fault

397
00:17:32,000 --> 00:17:35,360
and in here just it uh re

398
00:17:35,360 --> 00:17:38,480
repeat the similar information here just

399
00:17:38,480 --> 00:17:40,480
repeatedly

400
00:17:40,480 --> 00:17:43,679
so now i patch the binary and let's

401
00:17:43,679 --> 00:17:47,360
look at the first patch here

402
00:17:47,360 --> 00:17:50,160
and this one actually shows the uh uh

403
00:17:50,160 --> 00:17:50,960
just before

404
00:17:50,960 --> 00:17:54,880
step of overflow occurs and here

405
00:17:54,880 --> 00:17:56,720
you don't need to worry about this uh

406
00:17:56,720 --> 00:17:58,320
log string here i just

407
00:17:58,320 --> 00:18:01,360
pick all string id that takes

408
00:18:01,360 --> 00:18:03,280
two parameters this is the information

409
00:18:03,280 --> 00:18:05,600
important information

410
00:18:05,600 --> 00:18:08,080
so i wanted to print out what's the

411
00:18:08,080 --> 00:18:09,280
source address and

412
00:18:09,280 --> 00:18:12,880
what's the length value for the mem copy

413
00:18:12,880 --> 00:18:16,480
and here when i print out it's a heap

414
00:18:16,480 --> 00:18:18,559
address and please remember this one

415
00:18:18,559 --> 00:18:20,240
because when i talked about actual

416
00:18:20,240 --> 00:18:21,200
vulnerability

417
00:18:21,200 --> 00:18:23,760
i will mention this source address again

418
00:18:23,760 --> 00:18:24,720
and also this

419
00:18:24,720 --> 00:18:28,559
length value here and i put the code

420
00:18:28,559 --> 00:18:33,280
just before mem copy is called

421
00:18:34,480 --> 00:18:36,080
and another patch i've done is i

422
00:18:36,080 --> 00:18:37,760
mentioned about default uh

423
00:18:37,760 --> 00:18:41,200
hard fold handler and i set the flag

424
00:18:41,200 --> 00:18:44,720
to 1 so i can see more information

425
00:18:44,720 --> 00:18:48,000
at the time of the crash so now i

426
00:18:48,000 --> 00:18:50,000
see the old register values and the

427
00:18:50,000 --> 00:18:51,039
stack information

428
00:18:51,039 --> 00:18:53,200
and in the following there is a hit

429
00:18:53,200 --> 00:18:57,520
memory information as well

430
00:18:57,520 --> 00:18:59,200
and now let's talk about the uh the

431
00:18:59,200 --> 00:19:01,120
vulnerability that

432
00:19:01,120 --> 00:19:04,320
end to remote code execution

433
00:19:04,320 --> 00:19:06,720
actually i found this uh integer on the

434
00:19:06,720 --> 00:19:07,360
floorbail

435
00:19:07,360 --> 00:19:10,960
while long ago when i disassembled this

436
00:19:10,960 --> 00:19:12,160
formula

437
00:19:12,160 --> 00:19:14,640
i identified the main puppy first and

438
00:19:14,640 --> 00:19:16,559
looked around the older colors

439
00:19:16,559 --> 00:19:18,240
and i could identify these integers on

440
00:19:18,240 --> 00:19:19,679
the floor right away

441
00:19:19,679 --> 00:19:22,320
and which can use to the stack of

442
00:19:22,320 --> 00:19:23,520
overflow

443
00:19:23,520 --> 00:19:26,880
but at the time i didn't have a way of

444
00:19:26,880 --> 00:19:30,160
just reaching this code path

445
00:19:30,160 --> 00:19:32,720
so ever after i'm making the fuzzer i

446
00:19:32,720 --> 00:19:35,039
could i was able to crush the device

447
00:19:35,039 --> 00:19:37,520
and then i could see the uh the actual

448
00:19:37,520 --> 00:19:38,320
vulnerability

449
00:19:38,320 --> 00:19:41,200
can be reachable and the exploitable and

450
00:19:41,200 --> 00:19:42,480
guess what

451
00:19:42,480 --> 00:19:44,640
this mistake is exactly actually same as

452
00:19:44,640 --> 00:19:45,520
bleeding bit

453
00:19:45,520 --> 00:19:48,480
but in the different code ways in the

454
00:19:48,480 --> 00:19:50,320
case of bleeding being it was a

455
00:19:50,320 --> 00:19:52,960
hip overflow flow but mine is a stack

456
00:19:52,960 --> 00:19:54,799
overflow which means

457
00:19:54,799 --> 00:19:57,440
a notetaker can exploit this more

458
00:19:57,440 --> 00:20:00,240
reliably

459
00:20:01,840 --> 00:20:04,840
and let's see when attack actually takes

460
00:20:04,840 --> 00:20:06,000
place

461
00:20:06,000 --> 00:20:09,520
a victim starts scanning

462
00:20:09,520 --> 00:20:12,000
then attacker here you can just send the

463
00:20:12,000 --> 00:20:12,640
militia

464
00:20:12,640 --> 00:20:15,760
of malicious advertisement packet

465
00:20:15,760 --> 00:20:18,159
and you as you see here neither

466
00:20:18,159 --> 00:20:19,679
authentication nor the

467
00:20:19,679 --> 00:20:22,559
pairing required just scanning and

468
00:20:22,559 --> 00:20:25,918
malicious packet that's it

469
00:20:28,000 --> 00:20:31,919
and now take a look at the assembly code

470
00:20:32,400 --> 00:20:35,520
in this function as you see here

471
00:20:35,520 --> 00:20:38,640
the uh function allocate a stack

472
00:20:38,640 --> 00:20:43,120
buffer space for hex to see

473
00:20:43,120 --> 00:20:45,200
and the next easy i actually skip a

474
00:20:45,200 --> 00:20:48,159
little bit instruction here

475
00:20:48,159 --> 00:20:51,120
because it was just irrelevant this r6

476
00:20:51,120 --> 00:20:51,600
value

477
00:20:51,600 --> 00:20:54,720
is a pdu length video is like a packet

478
00:20:54,720 --> 00:20:55,840
data unit length

479
00:20:55,840 --> 00:20:57,600
and then i will show you the format in

480
00:20:57,600 --> 00:20:59,679
the very next slide

481
00:20:59,679 --> 00:21:02,720
it take the length of value

482
00:21:02,720 --> 00:21:05,679
and subtract six here here there is an

483
00:21:05,679 --> 00:21:06,799
integer on the floor

484
00:21:06,799 --> 00:21:10,320
if our six values is smaller than six

485
00:21:10,320 --> 00:21:13,600
this end of uh r6 here becomes really

486
00:21:13,600 --> 00:21:15,360
big number

487
00:21:15,360 --> 00:21:18,480
but next instruction is unsigned by

488
00:21:18,480 --> 00:21:21,600
extension which means it will eliminate

489
00:21:21,600 --> 00:21:24,559
the three most significant bytes and

490
00:21:24,559 --> 00:21:26,559
then leave only the last uh

491
00:21:26,559 --> 00:21:30,720
least significant byte on here

492
00:21:30,720 --> 00:21:33,200
and i want you to actually remember this

493
00:21:33,200 --> 00:21:35,120
part why am i emphasizing because

494
00:21:35,120 --> 00:21:37,360
when i talk about on another my those

495
00:21:37,360 --> 00:21:39,280
are those vulnerability

496
00:21:39,280 --> 00:21:42,880
this actually uh play a big role here

497
00:21:42,880 --> 00:21:45,840
this instruction

498
00:21:46,320 --> 00:21:48,799
and this r6 become here length is a big

499
00:21:48,799 --> 00:21:49,360
number

500
00:21:49,360 --> 00:21:53,200
equals to the length field and the next

501
00:21:53,200 --> 00:21:55,360
r1 if you remember from the previous

502
00:21:55,360 --> 00:21:57,600
slide on the previous slide these art

503
00:21:57,600 --> 00:22:00,799
file value has the hip buffer

504
00:22:00,799 --> 00:22:04,320
address here oops let's see here

505
00:22:04,320 --> 00:22:07,360
it goes to here the source address

506
00:22:07,360 --> 00:22:10,480
and destination address here is a

507
00:22:10,480 --> 00:22:13,679
stack address here so you see there is a

508
00:22:13,679 --> 00:22:17,200
step of overflow and this is how this

509
00:22:17,200 --> 00:22:19,200
packet looks advertisement packet looks

510
00:22:19,200 --> 00:22:20,159
like

511
00:22:20,159 --> 00:22:22,720
this lens field here for the uh this is

512
00:22:22,720 --> 00:22:24,799
from the version 4.2

513
00:22:24,799 --> 00:22:28,080
this 6 bit comes here and which is the

514
00:22:28,080 --> 00:22:29,760
r6 value

515
00:22:29,760 --> 00:22:32,799
and if i put a less than 6

516
00:22:32,799 --> 00:22:36,159
then there's an integer on the flow

517
00:22:36,159 --> 00:22:37,679
and let's see why the programmer make

518
00:22:37,679 --> 00:22:39,280
those kind of mistake

519
00:22:39,280 --> 00:22:41,919
according to to according to the stack

520
00:22:41,919 --> 00:22:43,840
version 4.2 there are

521
00:22:43,840 --> 00:22:46,880
seven pedo types

522
00:22:46,880 --> 00:22:49,840
and all of them has at least actually

523
00:22:49,840 --> 00:22:51,600
six byte data here

524
00:22:51,600 --> 00:22:54,320
so program programmer can think as okay

525
00:22:54,320 --> 00:22:55,679
there is a packing lens i can just

526
00:22:55,679 --> 00:22:56,720
substract six

527
00:22:56,720 --> 00:22:59,360
however if not it is an uh malicious

528
00:22:59,360 --> 00:23:00,400
packet

529
00:23:00,400 --> 00:23:03,520
it can be smaller than the six

530
00:23:03,520 --> 00:23:06,640
now i started developing the exploits

531
00:23:06,640 --> 00:23:09,280
but then the problem is was because of

532
00:23:09,280 --> 00:23:11,120
the background ble traffic

533
00:23:11,120 --> 00:23:14,000
i could not control this uh hip contacts

534
00:23:14,000 --> 00:23:15,120
uh

535
00:23:15,120 --> 00:23:18,159
really uh i could not

536
00:23:18,159 --> 00:23:21,120
control the hip context well you know to

537
00:23:21,120 --> 00:23:22,000
make a reliable

538
00:23:22,000 --> 00:23:26,159
exploit so i come up with an attack

539
00:23:26,159 --> 00:23:28,720
it's a quiet place attack there are a

540
00:23:28,720 --> 00:23:29,200
lot of

541
00:23:29,200 --> 00:23:31,440
uh dos attack uh those vulnerability

542
00:23:31,440 --> 00:23:32,720
including one of mine

543
00:23:32,720 --> 00:23:36,000
and any unsuccessful attack can be a dos

544
00:23:36,000 --> 00:23:38,320
attack

545
00:23:38,320 --> 00:23:42,080
let's see here there is an attacker

546
00:23:42,080 --> 00:23:44,480
and he he wants to take this vl

547
00:23:44,480 --> 00:23:45,679
controller

548
00:23:45,679 --> 00:23:48,080
but now he sees a lot of nearby uh

549
00:23:48,080 --> 00:23:50,240
device adle devices

550
00:23:50,240 --> 00:23:53,200
and you want to quiet them down then you

551
00:23:53,200 --> 00:23:54,240
can just

552
00:23:54,240 --> 00:23:58,559
kill all of them using the dos attack

553
00:23:58,640 --> 00:24:01,360
then finally this attacker can just send

554
00:24:01,360 --> 00:24:02,720
a malicious packet

555
00:24:02,720 --> 00:24:05,919
targeting this victim now

556
00:24:05,919 --> 00:24:09,279
here is a thing i'm not a real attacker

557
00:24:09,279 --> 00:24:11,600
and i cannot kill the old neighbor's bl

558
00:24:11,600 --> 00:24:13,360
devices

559
00:24:13,360 --> 00:24:16,400
so my solution is

560
00:24:16,400 --> 00:24:20,720
i have a bucket a paint bucket

561
00:24:20,720 --> 00:24:23,760
i made a faraday case out of this paint

562
00:24:23,760 --> 00:24:26,158
pocket

563
00:24:26,320 --> 00:24:29,840
and here in order to reduce the uh

564
00:24:29,840 --> 00:24:34,320
background ability noise this is the uh

565
00:24:34,320 --> 00:24:38,640
rf shielding fabric and i wrap my

566
00:24:38,640 --> 00:24:42,960
devices using the tinfoil

567
00:24:42,960 --> 00:24:45,520
and i also actually when i wrap these

568
00:24:45,520 --> 00:24:46,480
all devices

569
00:24:46,480 --> 00:24:49,039
into the bucket i put the uber tools

570
00:24:49,039 --> 00:24:50,159
here in order to

571
00:24:50,159 --> 00:24:52,960
verify actually the background noise has

572
00:24:52,960 --> 00:24:55,840
been reduced

573
00:24:56,640 --> 00:25:00,400
and let's take a look at the demo i set

574
00:25:00,400 --> 00:25:01,440
up my uh

575
00:25:01,440 --> 00:25:05,440
jp nimble here and

576
00:25:05,440 --> 00:25:09,760
attack i'm going to attack this ti

577
00:25:12,840 --> 00:25:15,840
device

578
00:26:44,400 --> 00:26:48,000
okay now let's take a look at the uh

579
00:26:48,000 --> 00:26:51,039
next vulnerability when i report the

580
00:26:51,039 --> 00:26:53,279
first book to the ti i actually made a

581
00:26:53,279 --> 00:26:55,039
poc that overriding the uh

582
00:26:55,039 --> 00:26:58,720
a program counter to the 414141

583
00:26:58,720 --> 00:27:00,640
i thought this basically this

584
00:27:00,640 --> 00:27:01,760
vulnerability

585
00:27:01,760 --> 00:27:03,440
making the poc for this vulnerability

586
00:27:03,440 --> 00:27:05,679
will be very simple just you're going to

587
00:27:05,679 --> 00:27:08,000
be very similar to the first one

588
00:27:08,000 --> 00:27:12,000
because when you see this chord the uh

589
00:27:12,000 --> 00:27:13,919
programmers mistake is the exactly the

590
00:27:13,919 --> 00:27:15,919
same there is on the floor

591
00:27:15,919 --> 00:27:18,960
which we want to call the stack buff

592
00:27:18,960 --> 00:27:20,480
overflow

593
00:27:20,480 --> 00:27:24,399
however it turns out to be uh uh uh the

594
00:27:24,399 --> 00:27:27,039
man uh the manipulating the heat

595
00:27:27,039 --> 00:27:28,559
contents was a bit harder

596
00:27:28,559 --> 00:27:31,919
so for now it is a potential rc but

597
00:27:31,919 --> 00:27:33,840
at some point i'll make a plc for this

598
00:27:33,840 --> 00:27:36,880
uh vulnerability

599
00:27:36,880 --> 00:27:39,520
the difference uh this block from the

600
00:27:39,520 --> 00:27:40,320
the first one

601
00:27:40,320 --> 00:27:44,000
is a victim it should be in the active

602
00:27:44,000 --> 00:27:45,840
scanning

603
00:27:45,840 --> 00:27:48,559
and the victim will receive all this

604
00:27:48,559 --> 00:27:50,159
advertisement

605
00:27:50,159 --> 00:27:53,039
advertisement just like passive scanning

606
00:27:53,039 --> 00:27:53,919
then

607
00:27:53,919 --> 00:27:57,520
victim will generate the scan request

608
00:27:57,520 --> 00:28:00,240
in order to get more information but at

609
00:28:00,240 --> 00:28:01,440
the time

610
00:28:01,440 --> 00:28:04,159
the attacker can generate a malicious

611
00:28:04,159 --> 00:28:06,799
scan response

612
00:28:06,799 --> 00:28:09,760
in the same case it does not require

613
00:28:09,760 --> 00:28:10,240
either

614
00:28:10,240 --> 00:28:13,679
authentication or pairing

615
00:28:14,320 --> 00:28:17,520
and here this pedio type is four and

616
00:28:17,520 --> 00:28:18,880
length doesn't need to be smaller than

617
00:28:18,880 --> 00:28:21,200
the six

618
00:28:21,200 --> 00:28:24,559
now let's look at the next target

619
00:28:24,559 --> 00:28:28,080
next target is silicon left efr 32 mg

620
00:28:28,080 --> 00:28:31,919
a 21 chip i picked this chip because

621
00:28:31,919 --> 00:28:33,760
it supports bluetooth 5 extended

622
00:28:33,760 --> 00:28:35,200
advertisement

623
00:28:35,200 --> 00:28:37,600
and this development board also supports

624
00:28:37,600 --> 00:28:39,520
hardware debugging

625
00:28:39,520 --> 00:28:42,480
and silicon lab provides an sdk and this

626
00:28:42,480 --> 00:28:44,240
sdk comes with a

627
00:28:44,240 --> 00:28:47,200
bluetooth stack in library format and

628
00:28:47,200 --> 00:28:51,200
luckily this library has some symbols

629
00:28:51,360 --> 00:28:54,480
and this silicon lab chip is uh one of

630
00:28:54,480 --> 00:28:57,360
these the single chip configuration

631
00:28:57,360 --> 00:29:00,880
case so all these protocols

632
00:29:00,880 --> 00:29:04,640
resides on the controller device

633
00:29:04,640 --> 00:29:06,320
so when i show you the demo you will not

634
00:29:06,320 --> 00:29:08,480
see any interaction between the host

635
00:29:08,480 --> 00:29:11,440
and the controller through this hci

636
00:29:11,440 --> 00:29:13,840
interface

637
00:29:14,640 --> 00:29:16,720
and now i just started fuzzing extended

638
00:29:16,720 --> 00:29:19,520
advertisement packets

639
00:29:19,520 --> 00:29:22,320
and it but i ran into a problem because

640
00:29:22,320 --> 00:29:23,039
it turns out

641
00:29:23,039 --> 00:29:25,039
initially when i make the photo i

642
00:29:25,039 --> 00:29:26,960
initially use the zephyr

643
00:29:26,960 --> 00:29:29,200
but then this zephyr turns out is not

644
00:29:29,200 --> 00:29:30,960
supporting the extended advertisement

645
00:29:30,960 --> 00:29:32,159
yet

646
00:29:32,159 --> 00:29:36,000
so i had to change my code to use a

647
00:29:36,000 --> 00:29:38,399
nimble

648
00:29:38,840 --> 00:29:41,840
and right after i fought in extended

649
00:29:41,840 --> 00:29:44,480
advertisement i found a dose for right

650
00:29:44,480 --> 00:29:46,080
away

651
00:29:46,080 --> 00:29:48,559
then i fasted more a couple more couple

652
00:29:48,559 --> 00:29:49,120
of days

653
00:29:49,120 --> 00:29:51,679
but there was no crash so i was

654
00:29:51,679 --> 00:29:52,880
wondering whether

655
00:29:52,880 --> 00:29:55,120
my defaults are actually generating the

656
00:29:55,120 --> 00:29:57,120
package properly or not

657
00:29:57,120 --> 00:30:00,080
and from that there was a case i use the

658
00:30:00,080 --> 00:30:00,960
uber to

659
00:30:00,960 --> 00:30:05,120
see the packets but ubertooth does not

660
00:30:05,120 --> 00:30:06,880
support its extended advertisement

661
00:30:06,880 --> 00:30:08,640
packet or the very long

662
00:30:08,640 --> 00:30:10,960
length advertisement packet so i

663
00:30:10,960 --> 00:30:12,159
couldn't see

664
00:30:12,159 --> 00:30:15,360
this you know my generated call so

665
00:30:15,360 --> 00:30:17,440
but luckily there was sniffle which is

666
00:30:17,440 --> 00:30:18,799
supposed to support the

667
00:30:18,799 --> 00:30:22,240
extended advertisement package so when i

668
00:30:22,240 --> 00:30:23,440
use a sniffle

669
00:30:23,440 --> 00:30:26,960
i could not see any of my packets

670
00:30:26,960 --> 00:30:29,440
and turns out when i debugged the nimble

671
00:30:29,440 --> 00:30:30,559
and it turns up

672
00:30:30,559 --> 00:30:32,799
turns out nimble actually does not

673
00:30:32,799 --> 00:30:34,799
allocate enough

674
00:30:34,799 --> 00:30:37,039
time to send really long length

675
00:30:37,039 --> 00:30:39,360
advertisement packets

676
00:30:39,360 --> 00:30:42,480
so i modified the nimble then

677
00:30:42,480 --> 00:30:44,320
i found the crash almost right away

678
00:30:44,320 --> 00:30:45,600
which yields to

679
00:30:45,600 --> 00:30:48,480
an rc bug

680
00:30:49,600 --> 00:30:51,279
so before looking at the icy ball i

681
00:30:51,279 --> 00:30:54,000
wanted to mention about my dosbox

682
00:30:54,000 --> 00:30:56,159
because i wanted to point it out that

683
00:30:56,159 --> 00:30:59,039
not every memorable forward flow

684
00:30:59,039 --> 00:31:02,640
will end up as an rc bug

685
00:31:02,799 --> 00:31:06,799
here is a dose bug

686
00:31:07,120 --> 00:31:09,200
i want you to just focus this here a

687
00:31:09,200 --> 00:31:10,399
little bit

688
00:31:10,399 --> 00:31:13,519
this r2 and rc i6

689
00:31:13,519 --> 00:31:15,760
we're going to have a length value that

690
00:31:15,760 --> 00:31:19,120
is uh attacker can control

691
00:31:19,120 --> 00:31:20,880
and since there is an integer on the

692
00:31:20,880 --> 00:31:22,720
floor on the flow

693
00:31:22,720 --> 00:31:24,480
they will r2 value will become really

694
00:31:24,480 --> 00:31:26,640
big number

695
00:31:26,640 --> 00:31:29,760
but the difference from the previous bug

696
00:31:29,760 --> 00:31:30,240
is

697
00:31:30,240 --> 00:31:32,080
in the previous block there was a

698
00:31:32,080 --> 00:31:33,600
unsigned byte extension

699
00:31:33,600 --> 00:31:35,600
because of this this really big number

700
00:31:35,600 --> 00:31:38,960
four by number becomes just one byte

701
00:31:38,960 --> 00:31:41,760
but this vulnerable code here does not

702
00:31:41,760 --> 00:31:42,399
have

703
00:31:42,399 --> 00:31:46,159
any of these before calling the memo

704
00:31:46,159 --> 00:31:49,440
so when mammoth called with this big

705
00:31:49,440 --> 00:31:50,159
number

706
00:31:50,159 --> 00:31:51,679
it will end up as a memory accident

707
00:31:51,679 --> 00:31:54,799
violation and the chances that in an

708
00:31:54,799 --> 00:31:55,679
attacker can

709
00:31:55,679 --> 00:31:58,799
interrupt this member is really slim so

710
00:31:58,799 --> 00:32:02,559
i call this bug as a dos bar

711
00:32:04,000 --> 00:32:06,720
now let's move on to the hip of overflow

712
00:32:06,720 --> 00:32:08,720
which is an rc bug

713
00:32:08,720 --> 00:32:12,080
and explaining this hip or any any hip

714
00:32:12,080 --> 00:32:13,200
bubble flow

715
00:32:13,200 --> 00:32:14,880
quickly verbally is hard so i'll give

716
00:32:14,880 --> 00:32:17,360
you a really big picture here

717
00:32:17,360 --> 00:32:20,399
when uh this uh silence chip received

718
00:32:20,399 --> 00:32:23,120
a packet it actually chopped into the uh

719
00:32:23,120 --> 00:32:24,799
smaller chunks

720
00:32:24,799 --> 00:32:26,399
which is small chunks actually length is

721
00:32:26,399 --> 00:32:28,559
weird actually is like a hex

722
00:32:28,559 --> 00:32:31,679
45 which is an interesting number

723
00:32:31,679 --> 00:32:34,559
and it maintains unchanged buffer while

724
00:32:34,559 --> 00:32:36,480
he's maintaining this chain buffer a

725
00:32:36,480 --> 00:32:37,360
programmer

726
00:32:37,360 --> 00:32:40,720
programmer made a mistake and i could

727
00:32:40,720 --> 00:32:44,080
actually end up overriding of my memory

728
00:32:44,080 --> 00:32:47,039
chunk boundary and i could override this

729
00:32:47,039 --> 00:32:48,399
memory chunks

730
00:32:48,399 --> 00:32:51,519
metadata pointer and after that i could

731
00:32:51,519 --> 00:32:52,240
override

732
00:32:52,240 --> 00:32:54,720
a function pointer which is for remote

733
00:32:54,720 --> 00:32:57,279
code execution

734
00:32:57,279 --> 00:33:00,320
i report this one to scilab on february

735
00:33:00,320 --> 00:33:01,120
21st

736
00:33:01,120 --> 00:33:04,000
and they fixed march 3rd or 20th which

737
00:33:04,000 --> 00:33:07,360
is very impressive speed

738
00:33:08,320 --> 00:33:10,480
and let's look at the uh what attack

739
00:33:10,480 --> 00:33:12,320
packet looks like

740
00:33:12,320 --> 00:33:15,600
here is the uh see this is the uh

741
00:33:15,600 --> 00:33:19,519
advertisement header and this is the

742
00:33:19,519 --> 00:33:22,559
extended advertisement type

743
00:33:22,559 --> 00:33:25,360
and there is a nested header here and i

744
00:33:25,360 --> 00:33:26,399
could use this

745
00:33:26,399 --> 00:33:30,320
uh length here

746
00:33:30,320 --> 00:33:33,360
and to set to 30 uh

747
00:33:33,360 --> 00:33:36,840
3c which actually triggered some

748
00:33:36,840 --> 00:33:39,840
miscalculation

749
00:33:41,120 --> 00:33:42,880
and if you want to know the details

750
00:33:42,880 --> 00:33:45,200
please read my white paper and

751
00:33:45,200 --> 00:33:50,000
the white paper will describe in detail

752
00:33:50,000 --> 00:33:52,799
and let's look at the uh rca persistent

753
00:33:52,799 --> 00:33:54,640
demo

754
00:33:54,640 --> 00:33:58,480
i set up my uh jp nimble here

755
00:33:58,480 --> 00:34:00,640
and this jp nimble will stand on

756
00:34:00,640 --> 00:34:03,679
malicious package over the air

757
00:34:03,679 --> 00:34:06,240
and we will attack the controller and

758
00:34:06,240 --> 00:34:21,839
you will persist

759
00:36:14,480 --> 00:36:16,400
now i'll briefly explain general

760
00:36:16,400 --> 00:36:19,839
bluetooth security challenges

761
00:36:21,440 --> 00:36:24,160
just like most other embedded systems it

762
00:36:24,160 --> 00:36:25,680
lacks common exploit

763
00:36:25,680 --> 00:36:29,359
mitigations what it means is it is

764
00:36:29,359 --> 00:36:31,599
easier for an attacker to exploit

765
00:36:31,599 --> 00:36:34,800
devices in the wild

766
00:36:36,000 --> 00:36:39,280
and also cheap vendors often do not

767
00:36:39,280 --> 00:36:40,160
support

768
00:36:40,160 --> 00:36:43,520
securable or secure reset what it means

769
00:36:43,520 --> 00:36:45,920
is if an attacker successfully exploits

770
00:36:45,920 --> 00:36:47,040
a device

771
00:36:47,040 --> 00:36:51,119
he can persist on the device

772
00:36:52,079 --> 00:36:54,720
and what does that mean it's easy to

773
00:36:54,720 --> 00:36:55,359
exploit

774
00:36:55,359 --> 00:36:57,440
and easy to proceed what is the impact

775
00:36:57,440 --> 00:36:58,800
of it

776
00:36:58,800 --> 00:37:01,280
well it turns out it's very hard to

777
00:37:01,280 --> 00:37:02,480
assess at the

778
00:37:02,480 --> 00:37:04,880
complete impact over any security

779
00:37:04,880 --> 00:37:06,000
findings

780
00:37:06,000 --> 00:37:08,800
that is because it is hard to identify

781
00:37:08,800 --> 00:37:12,320
end product they use a particular chip

782
00:37:12,320 --> 00:37:15,280
and also it is difficult to identify

783
00:37:15,280 --> 00:37:17,040
different classes of devices

784
00:37:17,040 --> 00:37:21,680
a certain chip is being used either

785
00:37:21,760 --> 00:37:24,240
and just like any other businesses the

786
00:37:24,240 --> 00:37:26,720
customer information is a secret

787
00:37:26,720 --> 00:37:29,920
and it will be up the vendor to notify

788
00:37:29,920 --> 00:37:34,079
any security findings to their customers

789
00:37:34,079 --> 00:37:37,119
and even one worst case is an end pro

790
00:37:37,119 --> 00:37:40,480
uh end product manufacturer may use a

791
00:37:40,480 --> 00:37:41,760
middleman a package

792
00:37:41,760 --> 00:37:44,720
a provider in this if there is this kind

793
00:37:44,720 --> 00:37:46,240
of chain

794
00:37:46,240 --> 00:37:48,320
it is less likely this any security

795
00:37:48,320 --> 00:37:50,240
findings information

796
00:37:50,240 --> 00:37:54,399
is being propagated down this chain

797
00:37:55,040 --> 00:37:58,160
so this is all time i get today and for

798
00:37:58,160 --> 00:37:58,560
any

799
00:37:58,560 --> 00:38:00,320
additional information you can check out

800
00:38:00,320 --> 00:38:01,599
at the github

801
00:38:01,599 --> 00:38:06,160
in this url i want to thank

802
00:38:06,160 --> 00:38:08,160
zeno rafa and marian for the valuable

803
00:38:08,160 --> 00:38:10,680
feedback and thank you for watching my

804
00:38:10,680 --> 00:38:13,680
talk

