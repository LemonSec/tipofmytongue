1
00:00:04,520 --> 00:00:14,340
[Music]

2
00:00:17,440 --> 00:00:17,920
hello

3
00:00:17,920 --> 00:00:20,800
uh welcome uh so today i'm going to be

4
00:00:20,800 --> 00:00:22,960
talking about uh pointer authentication

5
00:00:22,960 --> 00:00:24,400
in the ios kernel

6
00:00:24,400 --> 00:00:25,920
and in particular how pointer

7
00:00:25,920 --> 00:00:28,000
authentication is used to build kernel

8
00:00:28,000 --> 00:00:30,160
control flow integrity uh

9
00:00:30,160 --> 00:00:32,558
now unfortunately this time slot is not

10
00:00:32,558 --> 00:00:34,160
long enough for me to talk about

11
00:00:34,160 --> 00:00:36,559
all the things i would like to share so

12
00:00:36,559 --> 00:00:38,239
if you're interested i highly recommend

13
00:00:38,239 --> 00:00:40,239
checking out either my previous talk on

14
00:00:40,239 --> 00:00:40,879
pac

15
00:00:40,879 --> 00:00:44,000
or the project zero blog so

16
00:00:44,000 --> 00:00:45,520
about a year and a half ago at the

17
00:00:45,520 --> 00:00:47,760
beginning of 2019

18
00:00:47,760 --> 00:00:50,879
i'd written a kernel exploit for ios 12

19
00:00:50,879 --> 00:00:53,600
on the iphone 10s and i'd achieved a

20
00:00:53,600 --> 00:00:54,960
kernel read write primitive

21
00:00:54,960 --> 00:00:57,760
and at this point i had wanted to find a

22
00:00:57,760 --> 00:00:58,160
way

23
00:00:58,160 --> 00:01:01,199
to use kernel read write to execute

24
00:01:01,199 --> 00:01:03,600
arbitrary kernel code that is calling

25
00:01:03,600 --> 00:01:05,438
arbitrary kernel functions

26
00:01:05,438 --> 00:01:08,640
in the ios kernel so the idea

27
00:01:08,640 --> 00:01:11,520
was apple had added this new pack

28
00:01:11,520 --> 00:01:12,080
security

29
00:01:12,080 --> 00:01:15,200
feature and i wanted to find a way to

30
00:01:15,200 --> 00:01:17,759
bypass the control flow integrity uh

31
00:01:17,759 --> 00:01:19,040
that it provided

32
00:01:19,040 --> 00:01:21,280
so i put pointer authentication under

33
00:01:21,280 --> 00:01:22,159
the microscope

34
00:01:22,159 --> 00:01:24,320
and eventually ended up finding five

35
00:01:24,320 --> 00:01:26,640
different ways to bypass

36
00:01:26,640 --> 00:01:29,680
pointer authentication in ios 12

37
00:01:29,680 --> 00:01:33,600
which i then presented in study in pac

38
00:01:33,600 --> 00:01:36,000
so at the time once i had found this

39
00:01:36,000 --> 00:01:36,880
fifth uh

40
00:01:36,880 --> 00:01:40,320
bypass in my original work in 2019

41
00:01:40,320 --> 00:01:42,720
i eventually decided that this fifth

42
00:01:42,720 --> 00:01:43,920
bypass was

43
00:01:43,920 --> 00:01:45,840
uh indicative of kind of systematic

44
00:01:45,840 --> 00:01:47,759
problems with the design

45
00:01:47,759 --> 00:01:49,200
with the original design of pointer

46
00:01:49,200 --> 00:01:51,200
authentication and so

47
00:01:51,200 --> 00:01:53,920
i wanted to give uh you know apple some

48
00:01:53,920 --> 00:01:55,680
time to fix it to improve

49
00:01:55,680 --> 00:01:57,920
the the design a little bit and maybe i

50
00:01:57,920 --> 00:01:59,520
would revisit it

51
00:01:59,520 --> 00:02:02,399
at a later point you know give ios 13 a

52
00:02:02,399 --> 00:02:03,920
chance to fix some of the problems that

53
00:02:03,920 --> 00:02:05,200
i uncovered

54
00:02:05,200 --> 00:02:08,318
so uh now one year later this

55
00:02:08,318 --> 00:02:11,200
talk is my revisiting of pointer

56
00:02:11,200 --> 00:02:13,520
authentication

57
00:02:13,520 --> 00:02:17,120
in ios 13. so what is pointer

58
00:02:17,120 --> 00:02:18,160
authentication

59
00:02:18,160 --> 00:02:22,160
it's a security feature from arm the 8.3

60
00:02:22,160 --> 00:02:24,480
and the basic idea is that here you have

61
00:02:24,480 --> 00:02:25,920
a kernel pointer

62
00:02:25,920 --> 00:02:27,520
and if you look you'll notice that the

63
00:02:27,520 --> 00:02:29,599
upper bits of this pointer

64
00:02:29,599 --> 00:02:31,920
are basically all one they're all kind

65
00:02:31,920 --> 00:02:35,120
of unused storing redundant information

66
00:02:35,120 --> 00:02:37,440
so the idea with pack is to replace

67
00:02:37,440 --> 00:02:39,440
those unused bits of the pointer

68
00:02:39,440 --> 00:02:42,239
with a cryptographic signature over the

69
00:02:42,239 --> 00:02:44,239
lower bits of the pointer

70
00:02:44,239 --> 00:02:46,959
and that what that allows us to do is

71
00:02:46,959 --> 00:02:48,879
basically ensure that these pointers

72
00:02:48,879 --> 00:02:50,720
can't be tampered with

73
00:02:50,720 --> 00:02:54,239
during the operation of the kernel even

74
00:02:54,239 --> 00:02:55,599
if you have a kernel read write

75
00:02:55,599 --> 00:02:57,519
primitive if an attacker tries to modify

76
00:02:57,519 --> 00:02:58,800
these pointers

77
00:02:58,800 --> 00:03:02,159
that should result in this using of this

78
00:03:02,159 --> 00:03:02,879
pointer

79
00:03:02,879 --> 00:03:05,599
causing a kernel panic so there are a

80
00:03:05,599 --> 00:03:07,200
number of different instructions which

81
00:03:07,200 --> 00:03:09,680
are provided by the arm architecture

82
00:03:09,680 --> 00:03:10,879
i'm not going to go into these in

83
00:03:10,879 --> 00:03:12,319
details but these are the instructions

84
00:03:12,319 --> 00:03:13,040
that you use

85
00:03:13,040 --> 00:03:15,519
to manipulate pointer authentication

86
00:03:15,519 --> 00:03:16,800
codes

87
00:03:16,800 --> 00:03:20,080
so how has apple used this uh

88
00:03:20,080 --> 00:03:22,640
security feature in order to implement

89
00:03:22,640 --> 00:03:25,519
control flow integrity in the ios kernel

90
00:03:25,519 --> 00:03:26,560
well there are a number of different

91
00:03:26,560 --> 00:03:28,879
uses of these pointer authentication

92
00:03:28,879 --> 00:03:30,159
keys i'm not going to go into all of

93
00:03:30,159 --> 00:03:31,519
them in detail here

94
00:03:31,519 --> 00:03:33,920
the basic idea is that they segment out

95
00:03:33,920 --> 00:03:34,959
uh different

96
00:03:34,959 --> 00:03:37,360
uh use cases into different

97
00:03:37,360 --> 00:03:40,080
architectural keys so that pointers used

98
00:03:40,080 --> 00:03:42,799
with one key can't be substituted for

99
00:03:42,799 --> 00:03:43,680
other uses

100
00:03:43,680 --> 00:03:45,840
for other pointers using different keys

101
00:03:45,840 --> 00:03:47,200
the only one we're going to be focusing

102
00:03:47,200 --> 00:03:47,840
on

103
00:03:47,840 --> 00:03:51,840
for this talk is a thread saved state

104
00:03:51,840 --> 00:03:53,920
so basically imagine that there you have

105
00:03:53,920 --> 00:03:55,360
a kernel thread

106
00:03:55,360 --> 00:03:57,920
and all of a sudden a timer interrupt

107
00:03:57,920 --> 00:03:59,200
fires

108
00:03:59,200 --> 00:04:01,920
when that happens you're going to jump

109
00:04:01,920 --> 00:04:04,239
execution from the kernel thread over to

110
00:04:04,239 --> 00:04:06,000
the exception handler the the the

111
00:04:06,000 --> 00:04:07,760
exception vector

112
00:04:07,760 --> 00:04:09,840
and in the exception vector you're going

113
00:04:09,840 --> 00:04:10,879
to spill

114
00:04:10,879 --> 00:04:14,000
all of the kernel threads registers out

115
00:04:14,000 --> 00:04:16,160
to memory and then run the interrupt

116
00:04:16,160 --> 00:04:17,199
handler in place

117
00:04:17,199 --> 00:04:18,639
and then when the interrupt handler is

118
00:04:18,639 --> 00:04:20,720
finished running it's going to

119
00:04:20,720 --> 00:04:22,560
pop all of those registers back and then

120
00:04:22,560 --> 00:04:25,040
resume executing the kernel thread

121
00:04:25,040 --> 00:04:27,120
but while those registers are spilled to

122
00:04:27,120 --> 00:04:29,600
memory it's possible that they might be

123
00:04:29,600 --> 00:04:32,800
modified by an attacker with kernel read

124
00:04:32,800 --> 00:04:33,280
write

125
00:04:33,280 --> 00:04:35,600
to try to subvert control flow integrity

126
00:04:35,600 --> 00:04:36,880
so it's very important

127
00:04:36,880 --> 00:04:39,120
that any registers which could be used

128
00:04:39,120 --> 00:04:40,240
to influence uh

129
00:04:40,240 --> 00:04:42,720
kernel control flow those registers need

130
00:04:42,720 --> 00:04:44,160
to be protected

131
00:04:44,160 --> 00:04:45,919
to ensure that they aren't modified by

132
00:04:45,919 --> 00:04:47,440
an attacker and that's what this

133
00:04:47,440 --> 00:04:48,479
function right here

134
00:04:48,479 --> 00:04:50,320
is used for this sign thread state

135
00:04:50,320 --> 00:04:52,000
function is going to

136
00:04:52,000 --> 00:04:55,840
take the address of the saved state blob

137
00:04:55,840 --> 00:04:57,680
where all the registers are being stored

138
00:04:57,680 --> 00:05:00,800
it's going to take the pc register cpsr

139
00:05:00,800 --> 00:05:03,280
and lr so pc is your program counter

140
00:05:03,280 --> 00:05:04,560
which is the address you were executing

141
00:05:04,560 --> 00:05:05,280
from

142
00:05:05,280 --> 00:05:07,440
cpsr is your current program status

143
00:05:07,440 --> 00:05:09,360
register which saved the exception level

144
00:05:09,360 --> 00:05:10,960
that you were previously running at i.e

145
00:05:10,960 --> 00:05:12,400
were you running in the kernel or you

146
00:05:12,400 --> 00:05:13,680
were you in user mode

147
00:05:13,680 --> 00:05:16,240
and lr is your return address register

148
00:05:16,240 --> 00:05:18,000
and assign thread state is going to

149
00:05:18,000 --> 00:05:18,639
entangle

150
00:05:18,639 --> 00:05:21,759
all of these registers into a signature

151
00:05:21,759 --> 00:05:22,400
a pac

152
00:05:22,400 --> 00:05:23,919
protected signature which then gets

153
00:05:23,919 --> 00:05:26,880
stored into your saved state blob

154
00:05:26,880 --> 00:05:28,720
and correspondingly there's also a

155
00:05:28,720 --> 00:05:31,360
function that verifies these signatures

156
00:05:31,360 --> 00:05:33,120
verify thread state for when you want to

157
00:05:33,120 --> 00:05:33,759
actually

158
00:05:33,759 --> 00:05:36,560
pop these registers back out and so this

159
00:05:36,560 --> 00:05:38,080
function is basically going to

160
00:05:38,080 --> 00:05:40,720
regenerate the signature and uh check

161
00:05:40,720 --> 00:05:41,840
that it hasn't been none of the

162
00:05:41,840 --> 00:05:43,680
registers have been tampered with

163
00:05:43,680 --> 00:05:46,400
uh and if it's true that there has been

164
00:05:46,400 --> 00:05:47,840
some sort of tampering

165
00:05:47,840 --> 00:05:51,039
uh then this function will panic uh now

166
00:05:51,039 --> 00:05:52,400
a very important place

167
00:05:52,400 --> 00:05:55,120
for uh this to be used is uh during

168
00:05:55,120 --> 00:05:56,479
exception return

169
00:05:56,479 --> 00:05:59,039
uh so uh as i mentioned before if you

170
00:05:59,039 --> 00:06:00,960
for example are running a kernel thread

171
00:06:00,960 --> 00:06:03,039
and a timer interrupt fires you're gonna

172
00:06:03,039 --> 00:06:04,960
jump to the exception vector

173
00:06:04,960 --> 00:06:06,720
and eventually after running your

174
00:06:06,720 --> 00:06:08,319
interrupt handler to completion

175
00:06:08,319 --> 00:06:10,880
you're going to want to resume executing

176
00:06:10,880 --> 00:06:12,639
the original kernel thread and that's

177
00:06:12,639 --> 00:06:13,039
what

178
00:06:13,039 --> 00:06:15,280
uh this exception return function does

179
00:06:15,280 --> 00:06:16,479
it's going to

180
00:06:16,479 --> 00:06:18,639
return from that exception that was just

181
00:06:18,639 --> 00:06:20,000
handled

182
00:06:20,000 --> 00:06:22,960
so the ending of this function basically

183
00:06:22,960 --> 00:06:23,440
pops

184
00:06:23,440 --> 00:06:26,080
all of those registers that have been

185
00:06:26,080 --> 00:06:26,960
stored

186
00:06:26,960 --> 00:06:29,360
during the exception vector it pops them

187
00:06:29,360 --> 00:06:31,680
back into the architectural registers

188
00:06:31,680 --> 00:06:33,280
which means that this is pretty much the

189
00:06:33,280 --> 00:06:35,039
best rop gadget that you could ever

190
00:06:35,039 --> 00:06:36,240
possibly hope for

191
00:06:36,240 --> 00:06:38,479
it gives you control over every single

192
00:06:38,479 --> 00:06:40,319
register so it's very important

193
00:06:40,319 --> 00:06:43,600
that this thing is protected so

194
00:06:43,600 --> 00:06:46,319
that you cannot just get it called with

195
00:06:46,319 --> 00:06:48,080
arbitrary arguments you want to ensure

196
00:06:48,080 --> 00:06:50,639
that when you do an exception return pc

197
00:06:50,639 --> 00:06:52,319
cpsr and lr

198
00:06:52,319 --> 00:06:55,120
are indeed protected they haven't not

199
00:06:55,120 --> 00:06:56,880
been modified during the execution of

200
00:06:56,880 --> 00:06:58,080
the interrupt handler

201
00:06:58,080 --> 00:07:00,240
and so apple has inserted this call to

202
00:07:00,240 --> 00:07:02,560
verify the thread state before

203
00:07:02,560 --> 00:07:04,720
executing the exception return

204
00:07:04,720 --> 00:07:06,880
instruction

205
00:07:06,880 --> 00:07:09,120
all right so that's an overview of what

206
00:07:09,120 --> 00:07:10,479
pointer authentication

207
00:07:10,479 --> 00:07:12,560
control flow integrity looked like in

208
00:07:12,560 --> 00:07:13,599
ios 12.

209
00:07:13,599 --> 00:07:15,840
now i'm going to briefly summarize just

210
00:07:15,840 --> 00:07:18,720
two of the bypasses that i reported

211
00:07:18,720 --> 00:07:22,720
back in 2019 so jumping all the way to

212
00:07:22,720 --> 00:07:24,720
bypass number four

213
00:07:24,720 --> 00:07:27,599
this was a very interesting pac bypass

214
00:07:27,599 --> 00:07:29,120
from my perspective because it was an

215
00:07:29,120 --> 00:07:30,479
example of something

216
00:07:30,479 --> 00:07:32,720
which only showed up it didn't show up

217
00:07:32,720 --> 00:07:34,240
if you looked at the c code it only

218
00:07:34,240 --> 00:07:35,199
showed up when you

219
00:07:35,199 --> 00:07:37,199
started looking at the assembly so

220
00:07:37,199 --> 00:07:39,120
here's this kernel function ipc k

221
00:07:39,120 --> 00:07:42,400
message clean body and it has a switch

222
00:07:42,400 --> 00:07:43,919
statement in it

223
00:07:43,919 --> 00:07:45,120
and what you'll notice is that it's

224
00:07:45,120 --> 00:07:47,039
loading the jump table for this switch

225
00:07:47,039 --> 00:07:49,520
statement in register x25

226
00:07:49,520 --> 00:07:51,759
and then if you trace the flow of this

227
00:07:51,759 --> 00:07:52,560
register

228
00:07:52,560 --> 00:07:55,520
eventually it loads the jump target into

229
00:07:55,520 --> 00:07:56,800
register x9

230
00:07:56,800 --> 00:07:58,879
and then executes this unprotected

231
00:07:58,879 --> 00:08:02,400
branch instruction through register x9

232
00:08:02,400 --> 00:08:05,199
so in my mind i thought that this was

233
00:08:05,199 --> 00:08:06,240
problematic

234
00:08:06,240 --> 00:08:09,440
because uh if you remember from before

235
00:08:09,440 --> 00:08:12,479
when you have an interrupt delivered

236
00:08:12,479 --> 00:08:15,840
only the pc cpsr and lr registers are

237
00:08:15,840 --> 00:08:16,720
protected

238
00:08:16,720 --> 00:08:18,720
when your thread state gets spilled to

239
00:08:18,720 --> 00:08:21,039
memory in particular neither register

240
00:08:21,039 --> 00:08:22,160
x25 nor

241
00:08:22,160 --> 00:08:24,800
register x9 is protected so they're

242
00:08:24,800 --> 00:08:26,639
vulnerable to be modified

243
00:08:26,639 --> 00:08:29,199
uh by some concurrent kernel right

244
00:08:29,199 --> 00:08:30,080
primitive

245
00:08:30,080 --> 00:08:33,200
um by an attacker in this particular

246
00:08:33,200 --> 00:08:33,679
case

247
00:08:33,679 --> 00:08:36,320
uh even though kind of the idea was to

248
00:08:36,320 --> 00:08:36,958
find

249
00:08:36,958 --> 00:08:38,159
things that were vulnerable to

250
00:08:38,159 --> 00:08:40,159
interrupts i actually found

251
00:08:40,159 --> 00:08:42,159
that there's a function call which

252
00:08:42,159 --> 00:08:45,200
actually directly spills register x25

253
00:08:45,200 --> 00:08:47,760
uh to the stack so there is in fact no

254
00:08:47,760 --> 00:08:48,320
need

255
00:08:48,320 --> 00:08:49,839
uh in the proof of concepts that i

256
00:08:49,839 --> 00:08:52,320
submitted to leverage preemption

257
00:08:52,320 --> 00:08:55,440
in order to take advantage of this uh uh

258
00:08:55,440 --> 00:08:56,240
switch statement

259
00:08:56,240 --> 00:08:58,480
in order to get uh arbitrary kernel code

260
00:08:58,480 --> 00:09:00,640
execution

261
00:09:00,640 --> 00:09:02,959
uh the next bypass that i want to uh

262
00:09:02,959 --> 00:09:04,959
talk about was uh something more of a

263
00:09:04,959 --> 00:09:06,640
fundamental issue that i realized

264
00:09:06,640 --> 00:09:07,440
existed

265
00:09:07,440 --> 00:09:10,480
with signing thread states so here we

266
00:09:10,480 --> 00:09:12,320
have a kernel function which is

267
00:09:12,320 --> 00:09:15,200
creating a new uh thread and what you

268
00:09:15,200 --> 00:09:15,760
can see

269
00:09:15,760 --> 00:09:17,680
is that it has a call to the sign thread

270
00:09:17,680 --> 00:09:19,920
state function from before

271
00:09:19,920 --> 00:09:22,480
now a thing that i noticed is that

272
00:09:22,480 --> 00:09:24,080
interrupts are enabled during

273
00:09:24,080 --> 00:09:26,640
the whole execution of this function and

274
00:09:26,640 --> 00:09:27,839
this is problematic

275
00:09:27,839 --> 00:09:30,320
because uh as you recall from before

276
00:09:30,320 --> 00:09:32,000
sign thread state only protects

277
00:09:32,000 --> 00:09:35,120
your pc cpsr and lr registers and yet

278
00:09:35,120 --> 00:09:35,600
the four

279
00:09:35,600 --> 00:09:37,680
arguments to assign thread state are

280
00:09:37,680 --> 00:09:40,240
passed in registers x0 through x3

281
00:09:40,240 --> 00:09:41,760
which are not protected registers and

282
00:09:41,760 --> 00:09:43,279
therefore could be modified

283
00:09:43,279 --> 00:09:45,279
if an interrupt is delivered directly

284
00:09:45,279 --> 00:09:47,760
before the signed thread state operation

285
00:09:47,760 --> 00:09:50,160
uh but once again kind of in the end i

286
00:09:50,160 --> 00:09:51,600
found that uh

287
00:09:51,600 --> 00:09:54,959
it wasn't actually necessary to um

288
00:09:54,959 --> 00:09:58,080
have uh interrupts be used in order to

289
00:09:58,080 --> 00:09:59,279
trigger this issue

290
00:09:59,279 --> 00:10:01,680
because it turns out that this function

291
00:10:01,680 --> 00:10:02,480
would actually just

292
00:10:02,480 --> 00:10:04,959
read the parameters to sign directly

293
00:10:04,959 --> 00:10:06,000
from memory

294
00:10:06,000 --> 00:10:08,240
if you were to use your kernel right

295
00:10:08,240 --> 00:10:10,320
primitive to swap out this user state

296
00:10:10,320 --> 00:10:10,959
pointer

297
00:10:10,959 --> 00:10:13,040
to some address you control you could

298
00:10:13,040 --> 00:10:15,200
just directly get a signature

299
00:10:15,200 --> 00:10:17,760
on the state without having to mess with

300
00:10:17,760 --> 00:10:19,920
interrupts at all

301
00:10:19,920 --> 00:10:21,680
so those were two of the bypasses that i

302
00:10:21,680 --> 00:10:24,399
found in ios 12.

303
00:10:24,399 --> 00:10:26,640
and after this point i realized you know

304
00:10:26,640 --> 00:10:27,519
this this

305
00:10:27,519 --> 00:10:28,959
signing thread states is kind of

306
00:10:28,959 --> 00:10:31,200
fundamentally insecure i'll give apple

307
00:10:31,200 --> 00:10:32,560
some amount of time

308
00:10:32,560 --> 00:10:34,399
to uh to fix these issues and i'll

309
00:10:34,399 --> 00:10:37,279
revisit pack at a later point in time

310
00:10:37,279 --> 00:10:39,200
so let's look at what has happened in

311
00:10:39,200 --> 00:10:42,880
the intervening year with ios 13.

312
00:10:42,880 --> 00:10:46,000
so fundamentally the kind of uses of

313
00:10:46,000 --> 00:10:47,760
pointer authentication through the ios

314
00:10:47,760 --> 00:10:50,880
kernel fundamentally it's the same stuff

315
00:10:50,880 --> 00:10:53,040
there's no for example data pack using

316
00:10:53,040 --> 00:10:53,920
pac to protect

317
00:10:53,920 --> 00:10:56,480
additional data pointers i was hoping to

318
00:10:56,480 --> 00:10:58,079
see that but it didn't end up making it

319
00:10:58,079 --> 00:11:00,000
into ios 13.

320
00:11:00,000 --> 00:11:02,560
but regardless there is one change which

321
00:11:02,560 --> 00:11:04,240
is worth pointing out

322
00:11:04,240 --> 00:11:06,320
which is that there are two new

323
00:11:06,320 --> 00:11:07,839
protected registers

324
00:11:07,839 --> 00:11:10,480
so if we look at the disassembly of this

325
00:11:10,480 --> 00:11:12,640
sign thread state function

326
00:11:12,640 --> 00:11:14,560
what you'll observe is that rather than

327
00:11:14,560 --> 00:11:16,959
having four parameters as an ios 12

328
00:11:16,959 --> 00:11:19,360
it now has six parameters and the two

329
00:11:19,360 --> 00:11:20,560
additional parameters

330
00:11:20,560 --> 00:11:22,720
are used to sign the values of

331
00:11:22,720 --> 00:11:25,839
architectural registers x16 and x17

332
00:11:25,839 --> 00:11:28,640
now what that means is that x16 and x17

333
00:11:28,640 --> 00:11:30,399
are now kind of considered

334
00:11:30,399 --> 00:11:32,640
interrupt safe in the sense that they

335
00:11:32,640 --> 00:11:35,360
can't be modified during preemption

336
00:11:35,360 --> 00:11:37,839
during an interrupt because any attempts

337
00:11:37,839 --> 00:11:38,959
to modify them

338
00:11:38,959 --> 00:11:42,399
will invalidate the pac signature

339
00:11:42,399 --> 00:11:44,320
and what this has allowed apple to do is

340
00:11:44,320 --> 00:11:45,519
basically harden

341
00:11:45,519 --> 00:11:47,040
their implementation of switch

342
00:11:47,040 --> 00:11:49,120
statements so here you can see the

343
00:11:49,120 --> 00:11:50,399
original switch statement that i

344
00:11:50,399 --> 00:11:53,360
reported in pack bypass number four

345
00:11:53,360 --> 00:11:55,600
and on the right you have the hardened

346
00:11:55,600 --> 00:11:57,200
version in ios 13

347
00:11:57,200 --> 00:11:58,800
where you can see that the switch

348
00:11:58,800 --> 00:12:00,480
statement is only using

349
00:12:00,480 --> 00:12:04,160
uh registers x16 and x17 to conduct this

350
00:12:04,160 --> 00:12:06,399
indirect branch so uh theoretically this

351
00:12:06,399 --> 00:12:07,200
should be

352
00:12:07,200 --> 00:12:09,440
safe from a concurrent modification

353
00:12:09,440 --> 00:12:11,839
during interrupts

354
00:12:11,839 --> 00:12:13,200
all right so that's a high level

355
00:12:13,200 --> 00:12:15,600
overview of the changes to

356
00:12:15,600 --> 00:12:18,959
pointer authentication in ios 13. uh

357
00:12:18,959 --> 00:12:21,200
now let's get to the bulk of the

358
00:12:21,200 --> 00:12:22,240
research uh

359
00:12:22,240 --> 00:12:25,200
for uh this year which was looking at uh

360
00:12:25,200 --> 00:12:27,200
are there still ways to bypass

361
00:12:27,200 --> 00:12:29,519
this hardened uh pointer authentication

362
00:12:29,519 --> 00:12:31,279
based control flow integrity

363
00:12:31,279 --> 00:12:34,480
in ios 13. and the place that i wanted

364
00:12:34,480 --> 00:12:36,800
to start out was revisiting this this

365
00:12:36,800 --> 00:12:38,800
fifth bypass that i had found

366
00:12:38,800 --> 00:12:41,760
uh the first time around uh so if you

367
00:12:41,760 --> 00:12:43,680
recall the fifth bypass was this

368
00:12:43,680 --> 00:12:45,839
issue with a cyan thread state kind of

369
00:12:45,839 --> 00:12:47,360
being fundamentally

370
00:12:47,360 --> 00:12:50,399
insecure due to the use of interrupts uh

371
00:12:50,399 --> 00:12:51,600
so i was very curious

372
00:12:51,600 --> 00:12:54,320
how apple actually addressed this uh in

373
00:12:54,320 --> 00:12:56,000
ios 13.

374
00:12:56,000 --> 00:12:59,200
and it seems like the solution was to

375
00:12:59,200 --> 00:13:02,240
uh basically replace the reading

376
00:13:02,240 --> 00:13:04,880
of parameters from memory with just hard

377
00:13:04,880 --> 00:13:07,519
coding all the parameters to zero

378
00:13:07,519 --> 00:13:08,880
so this is certainly an improvement

379
00:13:08,880 --> 00:13:10,880
because it uh completely nullifies the

380
00:13:10,880 --> 00:13:13,040
technique that i used in my poc

381
00:13:13,040 --> 00:13:15,279
but the fundamental issue is still there

382
00:13:15,279 --> 00:13:16,720
which is that interrupts are still

383
00:13:16,720 --> 00:13:18,880
enabled for the duration of this

384
00:13:18,880 --> 00:13:19,760
function call

385
00:13:19,760 --> 00:13:21,200
meaning that we are still vulnerable to

386
00:13:21,200 --> 00:13:23,600
preemption this is a lot easier to see

387
00:13:23,600 --> 00:13:25,200
if you look at the assembly

388
00:13:25,200 --> 00:13:27,120
so imagine that we're executing the

389
00:13:27,120 --> 00:13:29,120
instruction sequentially and then

390
00:13:29,120 --> 00:13:32,000
right before we get to this sign thread

391
00:13:32,000 --> 00:13:33,040
state

392
00:13:33,040 --> 00:13:35,440
call we have a timer interrupt that

393
00:13:35,440 --> 00:13:36,720
fires and we

394
00:13:36,720 --> 00:13:39,120
immediately jump from here directly to

395
00:13:39,120 --> 00:13:40,320
the timer

396
00:13:40,320 --> 00:13:42,880
interrupt exception vector so now during

397
00:13:42,880 --> 00:13:44,160
this exception vector

398
00:13:44,160 --> 00:13:47,199
as you can see it's going to spill all

399
00:13:47,199 --> 00:13:48,000
of the architectural

400
00:13:48,000 --> 00:13:50,000
registers to memory so you can see x0 x1

401
00:13:50,000 --> 00:13:52,320
x2 x3 x4 x5 all of them get spilled to

402
00:13:52,320 --> 00:13:53,360
memory

403
00:13:53,360 --> 00:13:55,519
uh and because none of those are

404
00:13:55,519 --> 00:13:56,800
protected by

405
00:13:56,800 --> 00:13:59,920
the pac signature they can all be

406
00:13:59,920 --> 00:14:02,240
modified by an attacker

407
00:14:02,240 --> 00:14:05,199
coming in racing during this interrupt

408
00:14:05,199 --> 00:14:06,639
to overwrite them

409
00:14:06,639 --> 00:14:09,040
while the interrupt handler is running

410
00:14:09,040 --> 00:14:10,959
and then once those registers get popped

411
00:14:10,959 --> 00:14:11,360
back

412
00:14:11,360 --> 00:14:14,000
out an attacker has control over all of

413
00:14:14,000 --> 00:14:14,959
the parameters

414
00:14:14,959 --> 00:14:17,199
to the sign thread state function so

415
00:14:17,199 --> 00:14:19,279
once again this is a full

416
00:14:19,279 --> 00:14:23,360
thread state forgery pack bypass

417
00:14:23,360 --> 00:14:25,760
now for a couple of uh complicated

418
00:14:25,760 --> 00:14:26,720
reasons it wasn't

419
00:14:26,720 --> 00:14:29,120
actually easy to trigger this issue

420
00:14:29,120 --> 00:14:30,320
right here

421
00:14:30,320 --> 00:14:32,160
so i started searching for other places

422
00:14:32,160 --> 00:14:33,680
that sign thread state was called where

423
00:14:33,680 --> 00:14:35,120
it might be easier

424
00:14:35,120 --> 00:14:36,880
and i eventually ran across this

425
00:14:36,880 --> 00:14:40,320
function thread state 64 to save state

426
00:14:40,320 --> 00:14:43,120
so this function is the implementation

427
00:14:43,120 --> 00:14:44,000
of the user

428
00:14:44,000 --> 00:14:47,040
system call thread set state which is

429
00:14:47,040 --> 00:14:48,079
responsible for

430
00:14:48,079 --> 00:14:51,279
setting the registers in a user space

431
00:14:51,279 --> 00:14:53,040
thread so imagine that a user space

432
00:14:53,040 --> 00:14:54,800
process has created a new thread

433
00:14:54,800 --> 00:14:56,720
and it wants to set the values of all of

434
00:14:56,720 --> 00:14:59,040
the registers in that thread

435
00:14:59,040 --> 00:15:02,000
so this is the actual implementation of

436
00:15:02,000 --> 00:15:04,079
thread set state in the kernel

437
00:15:04,079 --> 00:15:05,600
and what you can see if you look at the

438
00:15:05,600 --> 00:15:07,600
assembly is that it does something

439
00:15:07,600 --> 00:15:09,440
kind of interesting here so first off

440
00:15:09,440 --> 00:15:10,880
it's returning from this

441
00:15:10,880 --> 00:15:12,639
function with an unprotected ret

442
00:15:12,639 --> 00:15:14,720
instruction and second

443
00:15:14,720 --> 00:15:16,959
the uh return address is actually being

444
00:15:16,959 --> 00:15:17,839
stored

445
00:15:17,839 --> 00:15:21,279
to register x8 for the duration

446
00:15:21,279 --> 00:15:23,199
of this kind of verify thread state then

447
00:15:23,199 --> 00:15:24,320
sign thread state

448
00:15:24,320 --> 00:15:26,959
uh sequence of operations and this is

449
00:15:26,959 --> 00:15:28,160
problematic because

450
00:15:28,160 --> 00:15:30,880
x8 is not a protected register it is

451
00:15:30,880 --> 00:15:31,680
vulnerable

452
00:15:31,680 --> 00:15:34,320
to being modified if an interrupt gets

453
00:15:34,320 --> 00:15:35,199
delivered

454
00:15:35,199 --> 00:15:37,120
somewhere during the operation of this

455
00:15:37,120 --> 00:15:38,480
sequence

456
00:15:38,480 --> 00:15:40,720
so how would you actually use this uh to

457
00:15:40,720 --> 00:15:42,560
bypass pointer authentication

458
00:15:42,560 --> 00:15:44,800
uh let's walk through an example uh so

459
00:15:44,800 --> 00:15:46,320
for this example we're gonna have two

460
00:15:46,320 --> 00:15:46,880
threads

461
00:15:46,880 --> 00:15:49,040
uh thread a is going to be running on

462
00:15:49,040 --> 00:15:50,320
cpu4

463
00:15:50,320 --> 00:15:52,880
so actually having it run on cpu four is

464
00:15:52,880 --> 00:15:53,600
important

465
00:15:53,600 --> 00:15:55,279
because for whatever architectural

466
00:15:55,279 --> 00:15:57,440
reason cpu4 seems to get a lot more

467
00:15:57,440 --> 00:15:58,480
interrupts than

468
00:15:58,480 --> 00:16:01,360
other threads uh so thread a is going to

469
00:16:01,360 --> 00:16:02,800
be just calling thread set state in a

470
00:16:02,800 --> 00:16:03,360
loop

471
00:16:03,360 --> 00:16:05,360
and thread b is going to be checking to

472
00:16:05,360 --> 00:16:08,399
see when cpu4 gets interrupted

473
00:16:08,399 --> 00:16:10,320
so each time thread set state gets

474
00:16:10,320 --> 00:16:11,600
called that's going to jump into the

475
00:16:11,600 --> 00:16:12,639
kernel

476
00:16:12,639 --> 00:16:14,079
and it's going to call machine thread

477
00:16:14,079 --> 00:16:15,759
set state and then

478
00:16:15,759 --> 00:16:17,600
that is going to call the vulnerable

479
00:16:17,600 --> 00:16:19,519
function and as we're kind of

480
00:16:19,519 --> 00:16:21,120
iterating through the instructions this

481
00:16:21,120 --> 00:16:23,360
function eventually at some point we're

482
00:16:23,360 --> 00:16:24,480
going to have

483
00:16:24,480 --> 00:16:26,639
an interrupt arrive and it's going to

484
00:16:26,639 --> 00:16:28,720
cause us to jump to the exception vector

485
00:16:28,720 --> 00:16:31,360
spilling all of our registers to memory

486
00:16:31,360 --> 00:16:33,040
including register x8

487
00:16:33,040 --> 00:16:36,079
which currently holds the return address

488
00:16:36,079 --> 00:16:37,759
so once all these registers have been

489
00:16:37,759 --> 00:16:39,519
spilled to memory uh

490
00:16:39,519 --> 00:16:42,560
execution is going to run in the

491
00:16:42,560 --> 00:16:45,120
interrupt handler and while this is

492
00:16:45,120 --> 00:16:45,680
happening

493
00:16:45,680 --> 00:16:47,839
we're now going to come in on thread b

494
00:16:47,839 --> 00:16:50,320
and see oh look indeed cpu4

495
00:16:50,320 --> 00:16:53,600
is interrupted so it's going to go ahead

496
00:16:53,600 --> 00:16:53,920
and

497
00:16:53,920 --> 00:16:57,519
overwrite the value of register x8

498
00:16:57,519 --> 00:16:59,120
which used to hold the return address

499
00:16:59,120 --> 00:17:00,639
now it's going to be an attacker

500
00:17:00,639 --> 00:17:03,279
controlled value instead

501
00:17:03,279 --> 00:17:06,000
so at this point we now have control

502
00:17:06,000 --> 00:17:07,439
over the return address

503
00:17:07,439 --> 00:17:10,160
and when the interrupt handler finishes

504
00:17:10,160 --> 00:17:11,439
running and it's about to do an

505
00:17:11,439 --> 00:17:12,959
exception return

506
00:17:12,959 --> 00:17:14,559
all of those registers are now going to

507
00:17:14,559 --> 00:17:16,160
be popped back

508
00:17:16,160 --> 00:17:18,319
out of the saved state blob and back

509
00:17:18,319 --> 00:17:19,520
into the registers

510
00:17:19,520 --> 00:17:22,799
giving us control over register x8 when

511
00:17:22,799 --> 00:17:25,199
normal execution resumes uh this means

512
00:17:25,199 --> 00:17:26,799
that uh this move instruction will give

513
00:17:26,799 --> 00:17:28,400
us control over the return address

514
00:17:28,400 --> 00:17:29,200
register

515
00:17:29,200 --> 00:17:31,440
and then this uh rhett instruction is

516
00:17:31,440 --> 00:17:32,320
going to give us

517
00:17:32,320 --> 00:17:35,840
pc control so let's see a demo

518
00:17:35,840 --> 00:17:39,120
all right so uh here we have an iphone

519
00:17:39,120 --> 00:17:41,280
running uh it's an iphone 11 pro running

520
00:17:41,280 --> 00:17:43,039
ios 13.3

521
00:17:43,039 --> 00:17:46,160
and uh it is i'm going to run

522
00:17:46,160 --> 00:17:48,799
a kernel exploit on it uh which is going

523
00:17:48,799 --> 00:17:50,640
to give it a kernel read write primitive

524
00:17:50,640 --> 00:17:53,200
and then i'm going to use that to call

525
00:17:53,200 --> 00:17:54,480
this kernel function

526
00:17:54,480 --> 00:17:57,039
uh io malloc which is going to allocate

527
00:17:57,039 --> 00:17:58,320
uh some memory

528
00:17:58,320 --> 00:17:59,679
from the kernel so this is basically

529
00:17:59,679 --> 00:18:01,360
demonstrating the ability to call

530
00:18:01,360 --> 00:18:03,280
arbitrary kernel functions

531
00:18:03,280 --> 00:18:06,320
uh from user space in spite of uh the

532
00:18:06,320 --> 00:18:08,480
presence of pointer authentication

533
00:18:08,480 --> 00:18:11,919
so if i just run this what i should see

534
00:18:11,919 --> 00:18:15,280
is it'll bypass pack and then

535
00:18:15,280 --> 00:18:17,679
uh immediately i get uh the ability to

536
00:18:17,679 --> 00:18:19,840
call i o malek and it returns this uh

537
00:18:19,840 --> 00:18:20,480
pointer which

538
00:18:20,480 --> 00:18:22,880
does which does indeed look like a

539
00:18:22,880 --> 00:18:23,520
kernel heap

540
00:18:23,520 --> 00:18:26,240
pointer so uh this demonstrates a the

541
00:18:26,240 --> 00:18:27,520
ability to bypass

542
00:18:27,520 --> 00:18:29,440
the control flow integrity mechanism

543
00:18:29,440 --> 00:18:30,799
using preemption

544
00:18:30,799 --> 00:18:33,520
with thread set state so we've

545
00:18:33,520 --> 00:18:35,039
demonstrated being able to

546
00:18:35,039 --> 00:18:37,520
bypass uh control flow integrity using

547
00:18:37,520 --> 00:18:39,840
this uh interrupt-based technique

548
00:18:39,840 --> 00:18:42,799
um but as i kind of thought about uh the

549
00:18:42,799 --> 00:18:44,720
issue here a little bit more

550
00:18:44,720 --> 00:18:47,600
uh it really boils down to uh basically

551
00:18:47,600 --> 00:18:48,160
anytime

552
00:18:48,160 --> 00:18:50,240
interrupts are enabled during this

553
00:18:50,240 --> 00:18:52,240
thread state signing operation

554
00:18:52,240 --> 00:18:54,320
uh that's just fundamentally an unsafe

555
00:18:54,320 --> 00:18:56,160
thing to have happen

556
00:18:56,160 --> 00:18:57,679
but the more i thought about it the more

557
00:18:57,679 --> 00:18:59,840
i realized that this doesn't just apply

558
00:18:59,840 --> 00:19:02,240
to this sign thread state function

559
00:19:02,240 --> 00:19:03,120
basically

560
00:19:03,120 --> 00:19:05,440
any time you have a pac signature being

561
00:19:05,440 --> 00:19:06,320
generated

562
00:19:06,320 --> 00:19:08,720
it needs to be the case that it's either

563
00:19:08,720 --> 00:19:10,559
has interrupts disabled

564
00:19:10,559 --> 00:19:12,720
or it's only using interrupt safe

565
00:19:12,720 --> 00:19:13,840
registers

566
00:19:13,840 --> 00:19:17,280
and so this let me search for other

567
00:19:17,280 --> 00:19:20,480
patterns of a variant of the same bypass

568
00:19:20,480 --> 00:19:22,400
so here you can see an example in this

569
00:19:22,400 --> 00:19:23,520
function b copy in

570
00:19:23,520 --> 00:19:26,880
where we have a unsafe pack ia

571
00:19:26,880 --> 00:19:29,760
operating on registers x3 and x11 i'm

572
00:19:29,760 --> 00:19:31,360
not going to go into this one in detail

573
00:19:31,360 --> 00:19:31,840
but it's

574
00:19:31,840 --> 00:19:34,640
fundamentally the same bypass as before

575
00:19:34,640 --> 00:19:36,799
just with a raw pack ia instruction

576
00:19:36,799 --> 00:19:40,160
rather than this thread set state

577
00:19:40,160 --> 00:19:43,520
all right uh so uh after looking

578
00:19:43,520 --> 00:19:46,000
while i was uh in the process of looking

579
00:19:46,000 --> 00:19:46,960
at the

580
00:19:46,960 --> 00:19:50,480
uh the the bypass involving thread set

581
00:19:50,480 --> 00:19:51,440
state and

582
00:19:51,440 --> 00:19:53,280
interrupts being delivered one of the

583
00:19:53,280 --> 00:19:54,720
things that i had to look at

584
00:19:54,720 --> 00:19:57,760
was how exactly are the

585
00:19:57,760 --> 00:20:00,160
registers spilled to memory during

586
00:20:00,160 --> 00:20:01,280
execution

587
00:20:01,280 --> 00:20:03,919
of the exception vector and i saw

588
00:20:03,919 --> 00:20:05,600
something kind of interesting i wasn't

589
00:20:05,600 --> 00:20:06,640
expecting to see

590
00:20:06,640 --> 00:20:09,440
this but it ended up being another pack

591
00:20:09,440 --> 00:20:10,320
bypass

592
00:20:10,320 --> 00:20:13,200
in the exception vector itself so if you

593
00:20:13,200 --> 00:20:14,159
look closely

594
00:20:14,159 --> 00:20:15,919
what you'll see is that actually the

595
00:20:15,919 --> 00:20:18,240
return address register x30

596
00:20:18,240 --> 00:20:20,799
is being spilled to memory and then just

597
00:20:20,799 --> 00:20:22,559
a few instructions later it's being

598
00:20:22,559 --> 00:20:23,360
re-read

599
00:20:23,360 --> 00:20:25,919
back from memory right before this call

600
00:20:25,919 --> 00:20:27,919
to sign thread state

601
00:20:27,919 --> 00:20:29,760
and this is problematic because this

602
00:20:29,760 --> 00:20:31,679
basically gives the attacker a window

603
00:20:31,679 --> 00:20:33,280
and time to modify

604
00:20:33,280 --> 00:20:34,880
the return address while it's built to

605
00:20:34,880 --> 00:20:36,720
memory before

606
00:20:36,720 --> 00:20:40,080
it has been protected by generating this

607
00:20:40,080 --> 00:20:42,799
pac signature on the saved state

608
00:20:42,799 --> 00:20:45,600
so this is additionally just another pac

609
00:20:45,600 --> 00:20:46,480
bypass

610
00:20:46,480 --> 00:20:48,960
right in the exception vector itself uh

611
00:20:48,960 --> 00:20:50,640
the way you might actually exploit this

612
00:20:50,640 --> 00:20:52,240
is you'd need to find some sort of

613
00:20:52,240 --> 00:20:54,159
gadget which for example is going to

614
00:20:54,159 --> 00:20:55,200
spin while some

615
00:20:55,200 --> 00:20:57,600
memory location is zero and then it's

616
00:20:57,600 --> 00:20:58,240
going to

617
00:20:58,240 --> 00:21:00,480
return with this again an unprotected

618
00:21:00,480 --> 00:21:02,159
ret instruction

619
00:21:02,159 --> 00:21:03,679
so now eventually while this gadget is

620
00:21:03,679 --> 00:21:06,000
executing uh you'll eventually hit a

621
00:21:06,000 --> 00:21:08,400
preemption or an interrupt will fire

622
00:21:08,400 --> 00:21:11,280
and you're going to jump to the uh

623
00:21:11,280 --> 00:21:12,960
exception vector

624
00:21:12,960 --> 00:21:14,480
and so now right at the beginning of

625
00:21:14,480 --> 00:21:15,840
this exception vector you're going to

626
00:21:15,840 --> 00:21:17,840
need to race in another thread so

627
00:21:17,840 --> 00:21:20,480
uh this thread is going to us at the

628
00:21:20,480 --> 00:21:21,200
very beginning

629
00:21:21,200 --> 00:21:23,760
store the return address register to the

630
00:21:23,760 --> 00:21:25,440
saved state blob

631
00:21:25,440 --> 00:21:27,120
and then we need to come in on another

632
00:21:27,120 --> 00:21:28,960
cpu core and immediately

633
00:21:28,960 --> 00:21:31,679
overwrite it to change it to some

634
00:21:31,679 --> 00:21:34,400
attacker-controlled value instead

635
00:21:34,400 --> 00:21:37,200
then just a few instructions later the

636
00:21:37,200 --> 00:21:39,039
exception vector is going to read

637
00:21:39,039 --> 00:21:41,200
the now attacker-controlled return

638
00:21:41,200 --> 00:21:42,480
address value back

639
00:21:42,480 --> 00:21:44,400
in and then it's going to call sign

640
00:21:44,400 --> 00:21:45,919
thread state uh

641
00:21:45,919 --> 00:21:48,880
meaning that we have now uh controlled

642
00:21:48,880 --> 00:21:50,640
the return address that has been

643
00:21:50,640 --> 00:21:52,559
incorporated into this pac signature

644
00:21:52,559 --> 00:21:53,919
giving us control

645
00:21:53,919 --> 00:21:56,159
of where this spin while zero gadget

646
00:21:56,159 --> 00:21:57,600
will return to

647
00:21:57,600 --> 00:22:00,480
at a later point

648
00:22:00,640 --> 00:22:02,480
uh so this was actually another kind of

649
00:22:02,480 --> 00:22:04,320
interesting pack bypass

650
00:22:04,320 --> 00:22:06,559
i hadn't expected to find something just

651
00:22:06,559 --> 00:22:07,919
sitting right there in the exception

652
00:22:07,919 --> 00:22:09,039
vector

653
00:22:09,039 --> 00:22:10,720
but it also kind of got me thinking like

654
00:22:10,720 --> 00:22:12,240
what is the generalization

655
00:22:12,240 --> 00:22:15,120
of this issue here and what i really

656
00:22:15,120 --> 00:22:16,640
eventually settled on was that the

657
00:22:16,640 --> 00:22:18,320
problem was that you're reading

658
00:22:18,320 --> 00:22:21,120
parameters from memory before calling

659
00:22:21,120 --> 00:22:22,480
sign thread state

660
00:22:22,480 --> 00:22:24,559
doing this is kind of fundamentally an

661
00:22:24,559 --> 00:22:26,400
insecure thing to do

662
00:22:26,400 --> 00:22:28,960
since it'll always give an attacker a

663
00:22:28,960 --> 00:22:30,720
window in time to modify

664
00:22:30,720 --> 00:22:33,120
the parameters to the sign thread state

665
00:22:33,120 --> 00:22:34,000
function

666
00:22:34,000 --> 00:22:36,240
so i started looking for other places

667
00:22:36,240 --> 00:22:38,080
where sign thread state is called

668
00:22:38,080 --> 00:22:39,440
where it's going to be reading

669
00:22:39,440 --> 00:22:41,360
parameters from memory

670
00:22:41,360 --> 00:22:43,360
and to my surprise i actually found

671
00:22:43,360 --> 00:22:45,200
another function which does this exact

672
00:22:45,200 --> 00:22:46,320
same thing

673
00:22:46,320 --> 00:22:48,000
so there's this function switch context

674
00:22:48,000 --> 00:22:49,440
which is used during

675
00:22:49,440 --> 00:22:51,679
voluntary kernel context switches so

676
00:22:51,679 --> 00:22:52,559
imagine like

677
00:22:52,559 --> 00:22:54,559
a kernel thread is blocking on a mutex

678
00:22:54,559 --> 00:22:57,760
and yielding execution to another thread

679
00:22:57,760 --> 00:22:59,919
when this happens all of the callee

680
00:22:59,919 --> 00:23:02,159
saved registers are going to be spilled

681
00:23:02,159 --> 00:23:05,120
to your saved state and in particular

682
00:23:05,120 --> 00:23:06,880
that include the return address

683
00:23:06,880 --> 00:23:08,640
which means you have to protect it which

684
00:23:08,640 --> 00:23:11,280
means a call to sign thread state

685
00:23:11,280 --> 00:23:14,880
now when you are when switch context is

686
00:23:14,880 --> 00:23:16,799
calling sign thread state

687
00:23:16,799 --> 00:23:20,000
it actually reads in the value of pc and

688
00:23:20,000 --> 00:23:21,200
cpsr

689
00:23:21,200 --> 00:23:24,159
originally in this saved state blob from

690
00:23:24,159 --> 00:23:24,799
memory

691
00:23:24,799 --> 00:23:27,360
before the signing operation so once

692
00:23:27,360 --> 00:23:28,720
again this is basically

693
00:23:28,720 --> 00:23:31,919
a way to directly get control of the

694
00:23:31,919 --> 00:23:34,320
pc and cpsr registers in the saved state

695
00:23:34,320 --> 00:23:36,000
blob before the signature

696
00:23:36,000 --> 00:23:39,919
gets generated so kind of once again

697
00:23:39,919 --> 00:23:42,480
the switch context is uh responsible for

698
00:23:42,480 --> 00:23:43,200
managing

699
00:23:43,200 --> 00:23:45,360
thread states for voluntary kernel

700
00:23:45,360 --> 00:23:47,039
context switches

701
00:23:47,039 --> 00:23:49,200
and so because this is really doing like

702
00:23:49,200 --> 00:23:51,200
you know voluntary context switches

703
00:23:51,200 --> 00:23:51,840
between

704
00:23:51,840 --> 00:23:54,000
kernel threads that's the reason why

705
00:23:54,000 --> 00:23:56,159
these pc and cpsr registers aren't

706
00:23:56,159 --> 00:23:57,039
needed

707
00:23:57,039 --> 00:23:58,640
and kind of why this thing isn't

708
00:23:58,640 --> 00:24:00,960
fundamentally broken

709
00:24:00,960 --> 00:24:03,360
but what it enables is this really

710
00:24:03,360 --> 00:24:04,240
straightforward

711
00:24:04,240 --> 00:24:07,520
pack bypass basically you wait for some

712
00:24:07,520 --> 00:24:09,360
kernel thread to be active while it's

713
00:24:09,360 --> 00:24:10,799
running and using

714
00:24:10,799 --> 00:24:12,880
all of its registers and while that's

715
00:24:12,880 --> 00:24:14,559
the case you overwrite

716
00:24:14,559 --> 00:24:17,279
the pc and cpsr registers in its saved

717
00:24:17,279 --> 00:24:18,720
state blob

718
00:24:18,720 --> 00:24:20,320
and then eventually this kernel thread

719
00:24:20,320 --> 00:24:21,840
is going to block it's going to call

720
00:24:21,840 --> 00:24:23,520
switch context

721
00:24:23,520 --> 00:24:26,159
and switch context is going to read pc

722
00:24:26,159 --> 00:24:27,919
and cpsr which are again the attacker

723
00:24:27,919 --> 00:24:28,720
controlled

724
00:24:28,720 --> 00:24:30,720
overwritten values it's going to read

725
00:24:30,720 --> 00:24:32,080
those into memory

726
00:24:32,080 --> 00:24:34,640
into registers as parameters to the

727
00:24:34,640 --> 00:24:36,320
called assigned thread state

728
00:24:36,320 --> 00:24:37,600
and therefore those are going to get

729
00:24:37,600 --> 00:24:40,720
signed into the pac signature

730
00:24:40,720 --> 00:24:43,039
and then because you have a valid uh

731
00:24:43,039 --> 00:24:45,919
signature on an attacker controlled

732
00:24:45,919 --> 00:24:49,120
saved state blob you can reuse that save

733
00:24:49,120 --> 00:24:49,679
state

734
00:24:49,679 --> 00:24:52,640
for an exception return operation with

735
00:24:52,640 --> 00:24:54,960
arbitrary pc and cpsr so basically you'd

736
00:24:54,960 --> 00:24:55,919
set cpsr

737
00:24:55,919 --> 00:24:58,799
to be exception level one or kernel mode

738
00:24:58,799 --> 00:25:01,520
and pc you'd set to some attacker

739
00:25:01,520 --> 00:25:04,080
hijacking gadget so this is an

740
00:25:04,080 --> 00:25:06,000
interesting pack bypass as well

741
00:25:06,000 --> 00:25:09,279
i wasn't expecting to find this issue in

742
00:25:09,279 --> 00:25:10,799
like the context switching code which is

743
00:25:10,799 --> 00:25:12,720
called all the time

744
00:25:12,720 --> 00:25:14,480
but kind of once again i wanted to take

745
00:25:14,480 --> 00:25:15,840
a step back and think of

746
00:25:15,840 --> 00:25:17,600
what is kind of the fundamental issue

747
00:25:17,600 --> 00:25:20,159
here uh and pretty soon it dawned on me

748
00:25:20,159 --> 00:25:21,760
that there is really something

749
00:25:21,760 --> 00:25:25,039
much bigger going on here and that is

750
00:25:25,039 --> 00:25:26,000
that there is a design

751
00:25:26,000 --> 00:25:27,679
issue with how these thread states are

752
00:25:27,679 --> 00:25:30,159
managed fundamentally there are two

753
00:25:30,159 --> 00:25:32,000
different ways in which signed thread

754
00:25:32,000 --> 00:25:34,559
states are being used in the kernel

755
00:25:34,559 --> 00:25:36,400
so first off you have the the method

756
00:25:36,400 --> 00:25:38,000
that we are already very familiar with

757
00:25:38,000 --> 00:25:39,760
which is during an exception return so

758
00:25:39,760 --> 00:25:41,200
an interrupt gets delivered

759
00:25:41,200 --> 00:25:42,960
you run your interrupt handler and then

760
00:25:42,960 --> 00:25:44,799
you're calling this exception return

761
00:25:44,799 --> 00:25:45,440
function

762
00:25:45,440 --> 00:25:48,159
to resume execution of the interrupted

763
00:25:48,159 --> 00:25:49,440
thread

764
00:25:49,440 --> 00:25:51,039
so we've already seen that but then

765
00:25:51,039 --> 00:25:52,640
there's this other way in which signed

766
00:25:52,640 --> 00:25:53,840
thread states are used

767
00:25:53,840 --> 00:25:56,400
which is via switch context during

768
00:25:56,400 --> 00:25:59,600
voluntary kernel context switches

769
00:25:59,600 --> 00:26:02,400
and as it turns out these two uses of

770
00:26:02,400 --> 00:26:03,760
signed thread states have

771
00:26:03,760 --> 00:26:06,880
very different security requirements so

772
00:26:06,880 --> 00:26:09,679
for exception returns when you're doing

773
00:26:09,679 --> 00:26:11,440
an exception return back into kernel

774
00:26:11,440 --> 00:26:12,000
mode

775
00:26:12,000 --> 00:26:14,159
you really do care about all three of

776
00:26:14,159 --> 00:26:16,799
the registers pc cpsr and lr

777
00:26:16,799 --> 00:26:18,880
since they all have an effect on what

778
00:26:18,880 --> 00:26:20,720
kernel code gets executed so they all

779
00:26:20,720 --> 00:26:21,919
need to be protected

780
00:26:21,919 --> 00:26:23,600
in order to ensure control flow

781
00:26:23,600 --> 00:26:25,039
integrity

782
00:26:25,039 --> 00:26:28,480
uh for exception returns to user mode so

783
00:26:28,480 --> 00:26:28,960
exam

784
00:26:28,960 --> 00:26:30,880
imagine like a system call and you're

785
00:26:30,880 --> 00:26:33,120
returning from the end of a system call

786
00:26:33,120 --> 00:26:36,400
um you really only care about the cpsr

787
00:26:36,400 --> 00:26:37,600
register

788
00:26:37,600 --> 00:26:39,279
and the reason for that is all you

789
00:26:39,279 --> 00:26:40,880
really care about is that

790
00:26:40,880 --> 00:26:43,200
when you return from the system call you

791
00:26:43,200 --> 00:26:45,760
are indeed jumping back into user space

792
00:26:45,760 --> 00:26:47,760
someone hasn't tampered with cpsr to

793
00:26:47,760 --> 00:26:51,200
make you return into kernel mode instead

794
00:26:51,200 --> 00:26:53,520
so in this case when you're returning to

795
00:26:53,520 --> 00:26:54,240
user mode

796
00:26:54,240 --> 00:26:56,880
you really only care about cpsr and

797
00:26:56,880 --> 00:26:57,440
finally

798
00:26:57,440 --> 00:27:00,320
during a switch context for switch

799
00:27:00,320 --> 00:27:02,400
context we only care about the return

800
00:27:02,400 --> 00:27:04,720
address register pc and cpsr just don't

801
00:27:04,720 --> 00:27:06,960
have meaning in this context

802
00:27:06,960 --> 00:27:09,919
so fundamentally it turns out that since

803
00:27:09,919 --> 00:27:11,039
thread states can be

804
00:27:11,039 --> 00:27:14,559
used in these two really different ways

805
00:27:14,559 --> 00:27:16,720
in order to ensure integrity we really

806
00:27:16,720 --> 00:27:17,679
want to be sure

807
00:27:17,679 --> 00:27:20,159
that thread states signed for use by

808
00:27:20,159 --> 00:27:21,440
switch context

809
00:27:21,440 --> 00:27:24,240
shouldn't be usable by exception return

810
00:27:24,240 --> 00:27:26,399
and also vice versa we don't want thread

811
00:27:26,399 --> 00:27:28,559
states signed for exception return

812
00:27:28,559 --> 00:27:32,320
to be usable by switch context instead

813
00:27:32,320 --> 00:27:34,480
unfortunately as it turns out there's

814
00:27:34,480 --> 00:27:35,679
only one function

815
00:27:35,679 --> 00:27:38,159
cyan thread state which means that

816
00:27:38,159 --> 00:27:38,720
unless

817
00:27:38,720 --> 00:27:40,559
additional care is taken in the

818
00:27:40,559 --> 00:27:41,919
implementation

819
00:27:41,919 --> 00:27:44,240
thread states signed for one purpose can

820
00:27:44,240 --> 00:27:45,919
always be swapped out

821
00:27:45,919 --> 00:27:48,880
and used for the other purpose instead

822
00:27:48,880 --> 00:27:50,399
uh so this gives us kind of

823
00:27:50,399 --> 00:27:53,520
a more fundamental lens on what is

824
00:27:53,520 --> 00:27:54,080
happening

825
00:27:54,080 --> 00:27:56,399
in this bypass which is that a thread

826
00:27:56,399 --> 00:27:58,159
states signed by switch context

827
00:27:58,159 --> 00:28:00,320
for context switching and remember

828
00:28:00,320 --> 00:28:02,080
context switching does not care

829
00:28:02,080 --> 00:28:05,200
about pc and cpsr these

830
00:28:05,200 --> 00:28:08,000
thread states can instead be used for

831
00:28:08,000 --> 00:28:09,440
exception returns

832
00:28:09,440 --> 00:28:13,440
which do care about cpc and cpsr

833
00:28:13,440 --> 00:28:16,080
so this is cool but it also begs kind of

834
00:28:16,080 --> 00:28:17,360
the obvious question

835
00:28:17,360 --> 00:28:20,000
which is what about the inverse can

836
00:28:20,000 --> 00:28:20,880
thread states

837
00:28:20,880 --> 00:28:23,440
signed for use by exception return

838
00:28:23,440 --> 00:28:24,240
instead

839
00:28:24,240 --> 00:28:27,919
be used for switch context

840
00:28:27,919 --> 00:28:29,600
and this actually brought me to what i

841
00:28:29,600 --> 00:28:31,200
think is the coolest uh

842
00:28:31,200 --> 00:28:32,880
pack by pass of all because it was the

843
00:28:32,880 --> 00:28:34,320
one that was staring me in the face the

844
00:28:34,320 --> 00:28:35,360
whole time

845
00:28:35,360 --> 00:28:38,320
uh which is uh how when you swap user

846
00:28:38,320 --> 00:28:40,080
and kernel thread states

847
00:28:40,080 --> 00:28:42,399
so uh if you remember from before there

848
00:28:42,399 --> 00:28:43,679
is this function

849
00:28:43,679 --> 00:28:46,159
a system called thread set state which

850
00:28:46,159 --> 00:28:47,520
basically allows

851
00:28:47,520 --> 00:28:50,960
a process to set the registers in a user

852
00:28:50,960 --> 00:28:52,640
space thread

853
00:28:52,640 --> 00:28:54,399
and it's implemented in the kernel by

854
00:28:54,399 --> 00:28:55,760
this function which we also

855
00:28:55,760 --> 00:28:58,159
saw before in the very first pack bypass

856
00:28:58,159 --> 00:29:00,320
thread state 64 to saved state

857
00:29:00,320 --> 00:29:02,720
which is responsible for verifying the

858
00:29:02,720 --> 00:29:05,039
old user space registers

859
00:29:05,039 --> 00:29:07,039
and then re-setting the new registers

860
00:29:07,039 --> 00:29:08,880
and then re-signing

861
00:29:08,880 --> 00:29:10,640
the thread state such that it has the

862
00:29:10,640 --> 00:29:12,240
new registers instead

863
00:29:12,240 --> 00:29:15,279
with the signature intact uh so now for

864
00:29:15,279 --> 00:29:15,600
this

865
00:29:15,600 --> 00:29:18,559
operation of a thread set state uh we

866
00:29:18,559 --> 00:29:20,799
only really care about cpsr

867
00:29:20,799 --> 00:29:22,320
being restricted we want to make sure

868
00:29:22,320 --> 00:29:24,799
that cpsr is set so that we return

869
00:29:24,799 --> 00:29:28,320
to uh user mode but we really don't care

870
00:29:28,320 --> 00:29:29,840
about the return address

871
00:29:29,840 --> 00:29:32,000
register because it like if you set a

872
00:29:32,000 --> 00:29:33,200
kernel pointer

873
00:29:33,200 --> 00:29:35,120
in your return address register as long

874
00:29:35,120 --> 00:29:37,440
as you're executing in user mode

875
00:29:37,440 --> 00:29:38,799
that'll just cause a seg fault when you

876
00:29:38,799 --> 00:29:40,320
try to return there it's not going to

877
00:29:40,320 --> 00:29:41,039
violate

878
00:29:41,039 --> 00:29:44,080
kernel control flow integrity so thread

879
00:29:44,080 --> 00:29:45,520
set state

880
00:29:45,520 --> 00:29:48,640
is fully secure against exception return

881
00:29:48,640 --> 00:29:51,919
you can't use thread set state to sign

882
00:29:51,919 --> 00:29:54,000
thread states that are then usable by

883
00:29:54,000 --> 00:29:55,200
exception return

884
00:29:55,200 --> 00:29:58,320
to violate kernel control flow integrity

885
00:29:58,320 --> 00:30:01,200
unfortunately this is not at all the

886
00:30:01,200 --> 00:30:01,600
case

887
00:30:01,600 --> 00:30:03,679
if you were to reuse thread states

888
00:30:03,679 --> 00:30:05,840
signed via thread set state with switch

889
00:30:05,840 --> 00:30:09,039
context because switch context really

890
00:30:09,039 --> 00:30:10,720
cares about the return address

891
00:30:10,720 --> 00:30:14,000
but completely ignores cpsr

892
00:30:14,000 --> 00:30:16,480
so this gives us a really lovely kind of

893
00:30:16,480 --> 00:30:17,440
logical

894
00:30:17,440 --> 00:30:21,200
pac bypass which is a very reliable 100

895
00:30:21,200 --> 00:30:22,960
deterministic

896
00:30:22,960 --> 00:30:24,799
uh so once again we're going to create

897
00:30:24,799 --> 00:30:27,279
uh two threads uh thread and thread b

898
00:30:27,279 --> 00:30:29,279
uh and uh we're going to take a close

899
00:30:29,279 --> 00:30:31,279
look at thread a which has

900
00:30:31,279 --> 00:30:34,240
two signed thread states one for uh user

901
00:30:34,240 --> 00:30:34,799
mode

902
00:30:34,799 --> 00:30:37,600
execution and one for kernel execution

903
00:30:37,600 --> 00:30:39,200
so what's going to happen is that thread

904
00:30:39,200 --> 00:30:40,960
a is going to call some system call

905
00:30:40,960 --> 00:30:42,640
which is going to block

906
00:30:42,640 --> 00:30:44,240
and eventually that's going to reach

907
00:30:44,240 --> 00:30:45,679
switch context

908
00:30:45,679 --> 00:30:47,520
so when switch context is called it's

909
00:30:47,520 --> 00:30:49,279
going to save all of the registers

910
00:30:49,279 --> 00:30:51,840
including the return address register

911
00:30:51,840 --> 00:30:53,679
x30 and it's going to

912
00:30:53,679 --> 00:30:55,919
sign that state and then it's going to

913
00:30:55,919 --> 00:30:58,159
cause the thread to block

914
00:30:58,159 --> 00:31:00,960
and while thread a is blocked we're now

915
00:31:00,960 --> 00:31:02,880
going to come in on thread b

916
00:31:02,880 --> 00:31:05,519
and we're going to swap out the pointer

917
00:31:05,519 --> 00:31:06,720
to the user state

918
00:31:06,720 --> 00:31:08,720
so that it now points to the kernel

919
00:31:08,720 --> 00:31:10,720
state instead so this is going to

920
00:31:10,720 --> 00:31:14,320
leave us in this situation where the uh

921
00:31:14,320 --> 00:31:17,360
pointer to the thread a's user state

922
00:31:17,360 --> 00:31:20,320
blob now points to its kernel state blob

923
00:31:20,320 --> 00:31:22,080
uh and at this point we can now call

924
00:31:22,080 --> 00:31:23,519
thread set state

925
00:31:23,519 --> 00:31:27,200
uh on thread a to set the registers in

926
00:31:27,200 --> 00:31:28,720
its kernel state

927
00:31:28,720 --> 00:31:31,279
now of course thread set state as i

928
00:31:31,279 --> 00:31:32,960
mentioned is going to restrict

929
00:31:32,960 --> 00:31:36,000
the value of cpsr but it does not at all

930
00:31:36,000 --> 00:31:37,200
restrict the value

931
00:31:37,200 --> 00:31:39,360
of the return address which means that

932
00:31:39,360 --> 00:31:41,440
if we now unblock thread a

933
00:31:41,440 --> 00:31:43,039
some other kernel thread is going to

934
00:31:43,039 --> 00:31:44,960
context switch to it

935
00:31:44,960 --> 00:31:46,799
and when it does so it's going to load

936
00:31:46,799 --> 00:31:49,200
this completely arbitrary return address

937
00:31:49,200 --> 00:31:52,159
into its registers it's going to verify

938
00:31:52,159 --> 00:31:53,679
the signature that's correct

939
00:31:53,679 --> 00:31:56,640
and then finally it's going to move that

940
00:31:56,640 --> 00:31:58,320
into the return address register

941
00:31:58,320 --> 00:32:01,519
and return once again giving us uh

942
00:32:01,519 --> 00:32:04,159
pc control so let's see a pack a

943
00:32:04,159 --> 00:32:06,240
demonstration of this pack bypass

944
00:32:06,240 --> 00:32:08,559
all right so here again we have uh the

945
00:32:08,559 --> 00:32:09,679
same iphone

946
00:32:09,679 --> 00:32:12,720
and we are going to uh run this

947
00:32:12,720 --> 00:32:16,240
pack bypass to demonstrate uh how to

948
00:32:16,240 --> 00:32:18,880
hijack control flow integrity using the

949
00:32:18,880 --> 00:32:20,720
just discussed uh thread set state

950
00:32:20,720 --> 00:32:22,240
bypass technique

951
00:32:22,240 --> 00:32:24,799
so uh this is actually as i said because

952
00:32:24,799 --> 00:32:26,720
it's a logical bypass it's really

953
00:32:26,720 --> 00:32:28,159
elegant and short

954
00:32:28,159 --> 00:32:29,840
so you can see that the implementation

955
00:32:29,840 --> 00:32:31,760
starts on line 19

956
00:32:31,760 --> 00:32:34,000
and ends on line 92 so that's the

957
00:32:34,000 --> 00:32:35,600
entirety of the code for this bypass

958
00:32:35,600 --> 00:32:36,480
it's very short

959
00:32:36,480 --> 00:32:39,760
completely 100 deterministic and uh

960
00:32:39,760 --> 00:32:41,679
what all this is going to do is it's

961
00:32:41,679 --> 00:32:44,399
going to set the value of the return

962
00:32:44,399 --> 00:32:45,600
address register

963
00:32:45,600 --> 00:32:48,000
to some controlled value uh causing the

964
00:32:48,000 --> 00:32:51,679
phone to panic so we will run that now

965
00:32:51,679 --> 00:32:53,679
and you can see immediately uh the

966
00:32:53,679 --> 00:32:54,799
device panics

967
00:32:54,799 --> 00:32:57,279
and uh if we check the panic log it will

968
00:32:57,279 --> 00:32:58,080
indeed

969
00:32:58,080 --> 00:33:00,880
be uh have this uh return address uh

970
00:33:00,880 --> 00:33:01,760
register set

971
00:33:01,760 --> 00:33:05,360
to uh 4242-42 uh demonstrating

972
00:33:05,360 --> 00:33:08,840
that we have uh broken the control flow

973
00:33:08,840 --> 00:33:11,039
integrity

974
00:33:11,039 --> 00:33:13,440
so uh what are the things that i want to

975
00:33:13,440 --> 00:33:14,799
you to take away from this talk i know

976
00:33:14,799 --> 00:33:17,440
it's been kind of a whirlwind

977
00:33:17,440 --> 00:33:20,480
whirlwind of pack bypasses so uh

978
00:33:20,480 --> 00:33:21,919
like what is the thing that i want you

979
00:33:21,919 --> 00:33:24,159
to walk away

980
00:33:24,159 --> 00:33:27,200
understanding about all of this

981
00:33:27,200 --> 00:33:29,840
when i originally gave the presentation

982
00:33:29,840 --> 00:33:31,679
demonstrating the first five pack

983
00:33:31,679 --> 00:33:34,080
bypasses in 2019

984
00:33:34,080 --> 00:33:37,120
one of my conclusions was that more

985
00:33:37,120 --> 00:33:38,399
thorough analysis

986
00:33:38,399 --> 00:33:40,159
could have helped in the design of

987
00:33:40,159 --> 00:33:42,080
pointer authentication

988
00:33:42,080 --> 00:33:44,320
and while my views now are a little bit

989
00:33:44,320 --> 00:33:45,760
more nuanced i still

990
00:33:45,760 --> 00:33:48,799
stand by this original conclusion

991
00:33:48,799 --> 00:33:52,320
uh even in ios 13 uh pac still

992
00:33:52,320 --> 00:33:55,039
feels quite ad hoc i really don't get a

993
00:33:55,039 --> 00:33:55,760
sense

994
00:33:55,760 --> 00:33:58,480
of what the formal underlying security

995
00:33:58,480 --> 00:33:59,840
model for pac is

996
00:33:59,840 --> 00:34:01,440
that governs all of these design

997
00:34:01,440 --> 00:34:03,760
decisions and as a result

998
00:34:03,760 --> 00:34:06,159
i even though i'm not aware of any i

999
00:34:06,159 --> 00:34:08,719
wouldn't be surprised if at a later

1000
00:34:08,719 --> 00:34:10,639
point it was revealed that

1001
00:34:10,639 --> 00:34:12,560
there are in fact other kind of

1002
00:34:12,560 --> 00:34:13,918
fundamental

1003
00:34:13,918 --> 00:34:15,599
design issues like the one we just

1004
00:34:15,599 --> 00:34:17,520
discussed earlier

1005
00:34:17,520 --> 00:34:20,000
now another thing which i think is worth

1006
00:34:20,000 --> 00:34:20,960
pointing out

1007
00:34:20,960 --> 00:34:23,520
is that when i initially reported uh the

1008
00:34:23,520 --> 00:34:24,960
proof of concepts for i

1009
00:34:24,960 --> 00:34:28,560
the ios 12 bypasses um apple was

1010
00:34:28,560 --> 00:34:31,760
able to fix the uh specific pox that i

1011
00:34:31,760 --> 00:34:32,719
reported

1012
00:34:32,719 --> 00:34:34,960
but they did not address the underlying

1013
00:34:34,960 --> 00:34:35,839
issue for

1014
00:34:35,839 --> 00:34:38,159
that fifth bypass which is that

1015
00:34:38,159 --> 00:34:39,599
interrupts were enabled

1016
00:34:39,599 --> 00:34:42,320
and i find this a little bit uh

1017
00:34:42,320 --> 00:34:44,560
disconcerting because i

1018
00:34:44,560 --> 00:34:46,320
explicitly called out the fact that

1019
00:34:46,320 --> 00:34:48,000
interrupts were dangerous during thread

1020
00:34:48,000 --> 00:34:50,480
state signing operations in my initial

1021
00:34:50,480 --> 00:34:51,599
report

1022
00:34:51,599 --> 00:34:54,399
and even you know one year later uh

1023
00:34:54,399 --> 00:34:55,679
despite this being something that i

1024
00:34:55,679 --> 00:34:56,960
talked about publicly

1025
00:34:56,960 --> 00:34:59,440
it still was uh right there as a

1026
00:34:59,440 --> 00:35:01,119
technique that worked

1027
00:35:01,119 --> 00:35:02,880
so that was a little bit uh

1028
00:35:02,880 --> 00:35:04,800
disconcerting to see that it's taken so

1029
00:35:04,800 --> 00:35:06,400
long and yet it still

1030
00:35:06,400 --> 00:35:09,280
wasn't addressed off the bat um one

1031
00:35:09,280 --> 00:35:10,720
other thing which i think is definitely

1032
00:35:10,720 --> 00:35:12,320
worth pointing out is that it's very

1033
00:35:12,320 --> 00:35:13,599
very important to look

1034
00:35:13,599 --> 00:35:16,800
at the output of your compiler a lot of

1035
00:35:16,800 --> 00:35:18,640
these issues with pointer authentication

1036
00:35:18,640 --> 00:35:20,560
are not visible if you're just looking

1037
00:35:20,560 --> 00:35:21,040
at the c

1038
00:35:21,040 --> 00:35:23,520
code so it is crucially crucially

1039
00:35:23,520 --> 00:35:25,359
important that you pop the kernel

1040
00:35:25,359 --> 00:35:28,000
into a disassembler take it apart look

1041
00:35:28,000 --> 00:35:29,599
at the register allocation

1042
00:35:29,599 --> 00:35:32,400
to get a good understanding of what are

1043
00:35:32,400 --> 00:35:34,160
the low-level characteristics of your

1044
00:35:34,160 --> 00:35:34,530
code

1045
00:35:34,530 --> 00:35:36,480
[Music]

1046
00:35:36,480 --> 00:35:39,200
uh all that uh being said i do still

1047
00:35:39,200 --> 00:35:39,599
think

1048
00:35:39,599 --> 00:35:42,720
that uh pac is a good mitigation i kind

1049
00:35:42,720 --> 00:35:44,079
of see it as a

1050
00:35:44,079 --> 00:35:45,839
pack having two different faces so

1051
00:35:45,839 --> 00:35:48,480
there's pac as an exploit mitigation

1052
00:35:48,480 --> 00:35:51,040
preventing you from getting a kernel

1053
00:35:51,040 --> 00:35:52,560
read write to begin with

1054
00:35:52,560 --> 00:35:54,720
and then there's also pac as control

1055
00:35:54,720 --> 00:35:56,000
flow integrity

1056
00:35:56,000 --> 00:35:58,720
uh making sure that you can't call

1057
00:35:58,720 --> 00:36:00,480
arbitrary kernel functions

1058
00:36:00,480 --> 00:36:02,640
once you have gotten this read write

1059
00:36:02,640 --> 00:36:04,480
primitive uh and so everything that i've

1060
00:36:04,480 --> 00:36:05,839
talked about right now

1061
00:36:05,839 --> 00:36:09,280
is addressing pac as cfi and does not in

1062
00:36:09,280 --> 00:36:11,440
any way diminish pac as an exploit

1063
00:36:11,440 --> 00:36:13,119
mitigation

1064
00:36:13,119 --> 00:36:15,040
and i think that pac has been quite

1065
00:36:15,040 --> 00:36:16,800
successful at eliminating the

1066
00:36:16,800 --> 00:36:19,200
exploitability of certain bug classes

1067
00:36:19,200 --> 00:36:20,960
i think that any time you can force

1068
00:36:20,960 --> 00:36:23,680
attackers to use better bugs

1069
00:36:23,680 --> 00:36:25,440
that's always going to be a win for the

1070
00:36:25,440 --> 00:36:28,560
long-term security of the platform

1071
00:36:28,560 --> 00:36:31,680
um i also think that pac is promising

1072
00:36:31,680 --> 00:36:34,240
that there's a lot of untapped potential

1073
00:36:34,240 --> 00:36:34,880
in it

1074
00:36:34,880 --> 00:36:37,040
improving over time in particular with

1075
00:36:37,040 --> 00:36:39,200
regards to protecting data pointers with

1076
00:36:39,200 --> 00:36:40,079
pac

1077
00:36:40,079 --> 00:36:41,839
and i'm looking forward to seeing some

1078
00:36:41,839 --> 00:36:43,520
promising improvements in this specific

1079
00:36:43,520 --> 00:36:46,480
regard in ios 14.

1080
00:36:46,480 --> 00:36:48,960
uh now the last thing that i want you to

1081
00:36:48,960 --> 00:36:50,079
take away from all of this

1082
00:36:50,079 --> 00:36:52,960
is that as much fun as all this research

1083
00:36:52,960 --> 00:36:55,040
was to conduct

1084
00:36:55,040 --> 00:36:57,440
pack bypass just aren't all that

1085
00:36:57,440 --> 00:36:59,359
important in the grand scheme of things

1086
00:36:59,359 --> 00:37:02,480
like if i'm writing a kernel exploit

1087
00:37:02,480 --> 00:37:04,240
and i've obtained colonel read write i

1088
00:37:04,240 --> 00:37:05,680
really don't see pac

1089
00:37:05,680 --> 00:37:08,240
as like the last step that needs to be

1090
00:37:08,240 --> 00:37:08,960
achieved

1091
00:37:08,960 --> 00:37:10,800
it's more like the cherry on top of

1092
00:37:10,800 --> 00:37:12,400
really nice exploit

1093
00:37:12,400 --> 00:37:15,520
um i could see you know perhaps uh pack

1094
00:37:15,520 --> 00:37:16,880
bypasses might make

1095
00:37:16,880 --> 00:37:18,560
an expensive up charge when you're

1096
00:37:18,560 --> 00:37:20,640
selling an exploit

1097
00:37:20,640 --> 00:37:22,880
for example there may be some threat

1098
00:37:22,880 --> 00:37:24,800
actors out there who have

1099
00:37:24,800 --> 00:37:28,000
uh legacy implants that rely on kernel

1100
00:37:28,000 --> 00:37:29,119
function calling

1101
00:37:29,119 --> 00:37:31,599
uh to accomplish their goals and so for

1102
00:37:31,599 --> 00:37:33,839
these actors it may be

1103
00:37:33,839 --> 00:37:36,560
they would prefer to buy a pack bypass

1104
00:37:36,560 --> 00:37:38,720
rather than like re-implement

1105
00:37:38,720 --> 00:37:41,839
this implant but

1106
00:37:41,839 --> 00:37:44,960
kernel cfi just fundamentally is not

1107
00:37:44,960 --> 00:37:46,960
the last line of defense keeping your

1108
00:37:46,960 --> 00:37:48,800
device safe

1109
00:37:48,800 --> 00:37:50,800
hardening the kernel is always going to

1110
00:37:50,800 --> 00:37:52,560
be more important

1111
00:37:52,560 --> 00:37:55,200
for end user security because it's going

1112
00:37:55,200 --> 00:37:55,760
to prevent

1113
00:37:55,760 --> 00:37:58,480
the attacker from getting read write uh

1114
00:37:58,480 --> 00:37:59,520
to begin with

1115
00:37:59,520 --> 00:38:01,760
and once you have read write i mean it's

1116
00:38:01,760 --> 00:38:03,440
pretty much game over at that point so

1117
00:38:03,440 --> 00:38:05,680
i'm excited to see kernel cfi i think

1118
00:38:05,680 --> 00:38:06,560
it's a really

1119
00:38:06,560 --> 00:38:09,359
cool mitigation um but just

1120
00:38:09,359 --> 00:38:10,640
fundamentally i think

1121
00:38:10,640 --> 00:38:12,800
it is much more important that this

1122
00:38:12,800 --> 00:38:14,079
kernel hardening work

1123
00:38:14,079 --> 00:38:15,920
uh is happening so i don't see these

1124
00:38:15,920 --> 00:38:17,200
pack bypasses as

1125
00:38:17,200 --> 00:38:19,280
all that important in the grand scheme

1126
00:38:19,280 --> 00:38:20,880
of things

1127
00:38:20,880 --> 00:38:22,400
so that's all i have for you today i

1128
00:38:22,400 --> 00:38:24,640
hope you enjoyed watching and

1129
00:38:24,640 --> 00:38:27,759
uh thank you very much

1130
00:38:30,560 --> 00:38:32,160
all right i hope you enjoyed my

1131
00:38:32,160 --> 00:38:34,640
presentation uh i'll try to address

1132
00:38:34,640 --> 00:38:36,640
uh some of the questions that were uh

1133
00:38:36,640 --> 00:38:38,480
raised in the chat right now

1134
00:38:38,480 --> 00:38:41,200
uh so uh first off uh there was a

1135
00:38:41,200 --> 00:38:42,320
question are these

1136
00:38:42,320 --> 00:38:44,480
types of flaws in programming likely to

1137
00:38:44,480 --> 00:38:46,000
continue or become reintroduced

1138
00:38:46,000 --> 00:38:49,200
in the future um so in my

1139
00:38:49,200 --> 00:38:52,960
opinion just based on how i've uh

1140
00:38:52,960 --> 00:38:56,720
understood pac to have changed over time

1141
00:38:56,720 --> 00:39:01,040
uh it doesn't seem like there is a

1142
00:39:01,040 --> 00:39:03,200
comprehensive strategy for pac it feels

1143
00:39:03,200 --> 00:39:05,040
somewhat more ad hoc

1144
00:39:05,040 --> 00:39:08,560
so i wouldn't be surprised if uh

1145
00:39:08,560 --> 00:39:11,440
these types of pack bypasses do persist

1146
00:39:11,440 --> 00:39:12,839
into the future

1147
00:39:12,839 --> 00:39:15,760
um that being said that isn't

1148
00:39:15,760 --> 00:39:18,640
a uh this isn't a certainty uh i could

1149
00:39:18,640 --> 00:39:19,520
certainly see

1150
00:39:19,520 --> 00:39:22,560
uh pac being hardened enough to uh

1151
00:39:22,560 --> 00:39:24,960
make these things become very very rare

1152
00:39:24,960 --> 00:39:25,760
um

1153
00:39:25,760 --> 00:39:27,119
but there isn't anything that i've seen

1154
00:39:27,119 --> 00:39:28,640
yet which demonstrates to me

1155
00:39:28,640 --> 00:39:29,920
comprehensively

1156
00:39:29,920 --> 00:39:33,040
uh that pac is uh robustly

1157
00:39:33,040 --> 00:39:36,560
uh mitigated for cfi um

1158
00:39:36,560 --> 00:39:37,920
and then finally kind of the last thing

1159
00:39:37,920 --> 00:39:39,920
that i want to leave you with just to

1160
00:39:39,920 --> 00:39:42,800
re-drive the last point that i made in

1161
00:39:42,800 --> 00:39:44,400
the talk home

1162
00:39:44,400 --> 00:39:47,680
is that pack bypasses just

1163
00:39:47,680 --> 00:39:50,800
aren't comparable to

1164
00:39:50,800 --> 00:39:54,000
local privilege escalation to begin with

1165
00:39:54,000 --> 00:39:56,720
if you have a bug which gets kernel read

1166
00:39:56,720 --> 00:39:57,839
write on the system

1167
00:39:57,839 --> 00:40:00,240
uh your your device is pretty much toast

1168
00:40:00,240 --> 00:40:02,160
anyway so i don't see these pack

1169
00:40:02,160 --> 00:40:02,960
bypasses

1170
00:40:02,960 --> 00:40:05,680
as all that important uh in the scheme

1171
00:40:05,680 --> 00:40:06,880
of things

1172
00:40:06,880 --> 00:40:08,960
i also see one new question that came up

1173
00:40:08,960 --> 00:40:10,480
could apple disable interrupts on the

1174
00:40:10,480 --> 00:40:12,000
sign thread state to alleviate some of

1175
00:40:12,000 --> 00:40:13,280
these issues

1176
00:40:13,280 --> 00:40:16,240
um yeah so that was one of the things

1177
00:40:16,240 --> 00:40:17,359
that

1178
00:40:17,359 --> 00:40:18,960
is definitely going to be required in

1179
00:40:18,960 --> 00:40:21,599
order to have a secure implementation

1180
00:40:21,599 --> 00:40:23,760
it's not sufficient to just disable it

1181
00:40:23,760 --> 00:40:24,960
during uh

1182
00:40:24,960 --> 00:40:26,800
the function itself it has to also

1183
00:40:26,800 --> 00:40:28,720
include the point at which the arguments

1184
00:40:28,720 --> 00:40:30,319
to the function are loaded into

1185
00:40:30,319 --> 00:40:32,000
registers um

1186
00:40:32,000 --> 00:40:33,680
but yeah that's definitely something

1187
00:40:33,680 --> 00:40:35,839
which needs to uh occur in order for the

1188
00:40:35,839 --> 00:40:37,200
implementation of signed thread state to

1189
00:40:37,200 --> 00:40:37,680
be

1190
00:40:37,680 --> 00:40:40,800
safe so i believe

1191
00:40:40,800 --> 00:40:42,640
that's all the time that i have thank

1192
00:40:42,640 --> 00:40:44,640
you so much everyone for listening

1193
00:40:44,640 --> 00:40:48,960
enjoy the rest of black hat

