1
00:00:04,310 --> 00:00:17,869
[Music]

2
00:00:18,480 --> 00:00:20,320
good morning ladies and gentlemen and

3
00:00:20,320 --> 00:00:22,320
welcome to my talk about http request

4
00:00:22,320 --> 00:00:25,279
smuggling in 2020

5
00:00:25,279 --> 00:00:27,519
my name is amit klein you can read more

6
00:00:27,519 --> 00:00:28,480
about me in this

7
00:00:28,480 --> 00:00:31,119
slide and today we're going to talk

8
00:00:31,119 --> 00:00:33,920
about the http request smuggling

9
00:00:33,920 --> 00:00:35,760
which is an attack that involves three

10
00:00:35,760 --> 00:00:38,480
actors one is the attacker who

11
00:00:38,480 --> 00:00:41,680
who is a practically a client and the

12
00:00:41,680 --> 00:00:42,320
other one

13
00:00:42,320 --> 00:00:45,200
and is there a proxy or firewall and the

14
00:00:45,200 --> 00:00:47,360
third actor is a web server or it can be

15
00:00:47,360 --> 00:00:49,760
a chain of proxies and firewalls leading

16
00:00:49,760 --> 00:00:50,320
to a web

17
00:00:50,320 --> 00:00:52,879
to finally to a web server and the

18
00:00:52,879 --> 00:00:54,960
attack involves the attacker

19
00:00:54,960 --> 00:00:58,640
connecting over port 80 tcp

20
00:00:58,640 --> 00:01:02,320
to the proxy and sending the proxy uh

21
00:01:02,320 --> 00:01:05,920
an http stream consisting of three um

22
00:01:05,920 --> 00:01:09,040
chunks or three parts a followed by b

23
00:01:09,040 --> 00:01:13,280
followed by c and we designate the a

24
00:01:13,280 --> 00:01:16,000
part in red the b part in green and the

25
00:01:16,000 --> 00:01:17,360
c part in blue

26
00:01:17,360 --> 00:01:19,759
the proxy interprets this stream as the

27
00:01:19,759 --> 00:01:21,040
first request being

28
00:01:21,040 --> 00:01:23,759
a followed by b and the second request

29
00:01:23,759 --> 00:01:24,240
is

30
00:01:24,240 --> 00:01:27,600
c and it forwards those two requests to

31
00:01:27,600 --> 00:01:29,280
the web server and the web server

32
00:01:29,280 --> 00:01:32,400
however interprets those two requests as

33
00:01:32,400 --> 00:01:35,439
the stream i'm sorry as a request first

34
00:01:35,439 --> 00:01:36,159
quest a

35
00:01:36,159 --> 00:01:39,360
followed by a second request b

36
00:01:39,360 --> 00:01:42,320
and c and thus it responds with uh the

37
00:01:42,320 --> 00:01:43,840
responses for a

38
00:01:43,840 --> 00:01:47,520
and for bc and the proxy then caches

39
00:01:47,520 --> 00:01:51,119
uh for a b the response for that the web

40
00:01:51,119 --> 00:01:52,799
server provided for a

41
00:01:52,799 --> 00:01:56,079
and more importantly the proxy caches

42
00:01:56,079 --> 00:01:59,200
for c the response that the web server

43
00:01:59,200 --> 00:02:00,240
generated

44
00:02:00,240 --> 00:02:03,759
for the data for the messages bc

45
00:02:03,759 --> 00:02:06,079
and that latter part is exactly where

46
00:02:06,079 --> 00:02:08,959
http request smuggling takes effect

47
00:02:08,959 --> 00:02:12,239
and ends up in web cache poisoning in

48
00:02:12,239 --> 00:02:14,480
this example

49
00:02:14,480 --> 00:02:16,800
this the http request smuggling attack

50
00:02:16,800 --> 00:02:18,480
is also called the

51
00:02:18,480 --> 00:02:23,040
http dsync attack per james cattle's

52
00:02:23,040 --> 00:02:26,000
recent research

53
00:02:26,160 --> 00:02:29,440
just to illustrate this in more detail

54
00:02:29,440 --> 00:02:31,360
this is the street this is an example

55
00:02:31,360 --> 00:02:32,959
string where a

56
00:02:32,959 --> 00:02:36,000
the red part is

57
00:02:36,000 --> 00:02:39,599
is the first uh chunk that uh the proxy

58
00:02:39,599 --> 00:02:40,480
receives

59
00:02:40,480 --> 00:02:42,800
uh in green we see the second chunk and

60
00:02:42,800 --> 00:02:45,280
in blue we see the third chunk

61
00:02:45,280 --> 00:02:49,120
and let's say that uh the proxy uh

62
00:02:49,120 --> 00:02:52,080
interprets the or or uses the last

63
00:02:52,080 --> 00:02:53,519
content sent header

64
00:02:53,519 --> 00:02:56,239
in such case the proxy will interpret

65
00:02:56,239 --> 00:02:56,640
this

66
00:02:56,640 --> 00:03:00,319
stream as two http requests one with

67
00:03:00,319 --> 00:03:03,280
44 bytes body consisting of the red part

68
00:03:03,280 --> 00:03:04,560
followed by the green part

69
00:03:04,560 --> 00:03:06,239
and the second one is the blue part

70
00:03:06,239 --> 00:03:07,840
which is entirely new

71
00:03:07,840 --> 00:03:11,280
http request um

72
00:03:11,280 --> 00:03:14,640
so from the proxy's perspective

73
00:03:14,640 --> 00:03:17,599
the proxy will see the first request for

74
00:03:17,599 --> 00:03:18,720
hello php

75
00:03:18,720 --> 00:03:21,440
and the second request for target html

76
00:03:21,440 --> 00:03:22,159
whereas

77
00:03:22,159 --> 00:03:25,360
say we have a web server

78
00:03:25,360 --> 00:03:28,640
with that interprets the uh

79
00:03:28,640 --> 00:03:30,480
or that uses the first content length

80
00:03:30,480 --> 00:03:32,480
header in such case we'll see the first

81
00:03:32,480 --> 00:03:34,319
request being the red part

82
00:03:34,319 --> 00:03:37,360
uh which is a a request with

83
00:03:37,360 --> 00:03:39,840
zero body lens followed by another

84
00:03:39,840 --> 00:03:40,560
request

85
00:03:40,560 --> 00:03:43,440
green and blue parts so from the web

86
00:03:43,440 --> 00:03:45,280
servers perspective the first request

87
00:03:45,280 --> 00:03:47,760
will be to hello php with zero bytes in

88
00:03:47,760 --> 00:03:48,400
the body

89
00:03:48,400 --> 00:03:50,640
and the second request will be for the

90
00:03:50,640 --> 00:03:52,080
poison html

91
00:03:52,080 --> 00:03:55,280
um resource with some extra headers in

92
00:03:55,280 --> 00:03:56,560
blue

93
00:03:56,560 --> 00:03:59,280
and as you can see the proxy will

94
00:03:59,280 --> 00:04:00,720
therefore cache

95
00:04:00,720 --> 00:04:04,080
for the target html url the data that

96
00:04:04,080 --> 00:04:05,760
the web server provided for

97
00:04:05,760 --> 00:04:09,040
the poison html url and thereby we

98
00:04:09,040 --> 00:04:09,840
achieve a

99
00:04:09,840 --> 00:04:12,879
web cache poisoning

100
00:04:13,120 --> 00:04:15,599
uh a short history of http request

101
00:04:15,599 --> 00:04:16,798
smuggling as we can

102
00:04:16,798 --> 00:04:19,279
see in 2005 that's a decade and a half

103
00:04:19,279 --> 00:04:20,000
ago

104
00:04:20,000 --> 00:04:21,759
uh the seminal paper http request

105
00:04:21,759 --> 00:04:23,919
muggling was published it was followed

106
00:04:23,919 --> 00:04:28,240
by several air research uh

107
00:04:28,240 --> 00:04:31,600
small papers uh and then for almost a

108
00:04:31,600 --> 00:04:33,440
decade there was no

109
00:04:33,440 --> 00:04:36,479
substantial uh research in http request

110
00:04:36,479 --> 00:04:37,680
mark in the https

111
00:04:37,680 --> 00:04:39,759
request muggling area there were of

112
00:04:39,759 --> 00:04:41,680
course vulnerabilities published

113
00:04:41,680 --> 00:04:44,960
but no no significant research as far as

114
00:04:44,960 --> 00:04:46,160
i know

115
00:04:46,160 --> 00:04:49,759
in 2015 2016

116
00:04:49,759 --> 00:04:52,800
regis leroy published his hiding rookies

117
00:04:52,800 --> 00:04:53,759
in http

118
00:04:53,759 --> 00:04:56,800
reviving the interest in this area and

119
00:04:56,800 --> 00:04:59,840
in 2019 james kettle uh published his

120
00:04:59,840 --> 00:05:00,880
series of

121
00:05:00,880 --> 00:05:04,000
papers around http dsync attacks

122
00:05:04,000 --> 00:05:07,120
in blackett usa and in black at

123
00:05:07,120 --> 00:05:10,800
europe so given all this

124
00:05:10,800 --> 00:05:12,800
my question is is http request smuggling

125
00:05:12,800 --> 00:05:14,000
still a thing this is

126
00:05:14,000 --> 00:05:17,360
2020 and we we are after all aware of

127
00:05:17,360 --> 00:05:18,639
the attack for

128
00:05:18,639 --> 00:05:21,440
uh over a decade and a half uh it was

129
00:05:21,440 --> 00:05:23,520
back to the limelight in recent years

130
00:05:23,520 --> 00:05:26,560
thanks to james kettle and regis leroy

131
00:05:26,560 --> 00:05:30,639
and our so our mainstream weapon proxy

132
00:05:30,639 --> 00:05:32,000
server is still vulnerable

133
00:05:32,000 --> 00:05:34,560
uh this the scope of my research is the

134
00:05:34,560 --> 00:05:35,840
usual suspects

135
00:05:35,840 --> 00:05:37,600
and you'd expect them to be all immune

136
00:05:37,600 --> 00:05:40,080
by now but

137
00:05:40,080 --> 00:05:41,919
since i'm here in blackhead the answer

138
00:05:41,919 --> 00:05:43,919
is no

139
00:05:43,919 --> 00:05:46,240
let's see some interesting variants

140
00:05:46,240 --> 00:05:47,840
first is a header

141
00:05:47,840 --> 00:05:49,520
followed by space or card return

142
00:05:49,520 --> 00:05:51,520
followed by some junk for example

143
00:05:51,520 --> 00:05:54,080
content length header followed by the

144
00:05:54,080 --> 00:05:55,600
content length followed by space

145
00:05:55,600 --> 00:05:57,440
followed by abcd

146
00:05:57,440 --> 00:06:00,080
with a value of 20 and as it happens

147
00:06:00,080 --> 00:06:00,800
squids

148
00:06:00,800 --> 00:06:02,800
squid ignores this header completely but

149
00:06:02,800 --> 00:06:04,560
it forwards it as is

150
00:06:04,560 --> 00:06:07,600
whereas abyss x1 web server converts it

151
00:06:07,600 --> 00:06:10,240
uh into just the header part without the

152
00:06:10,240 --> 00:06:11,120
space

153
00:06:11,120 --> 00:06:13,919
or or the junk so cache web cache

154
00:06:13,919 --> 00:06:15,039
poisoning attack

155
00:06:15,039 --> 00:06:18,319
with squid in front of uh of abyss

156
00:06:18,319 --> 00:06:21,520
may cons maybe uh um constructed as

157
00:06:21,520 --> 00:06:22,319
following

158
00:06:22,319 --> 00:06:24,240
we have this the legitimate content

159
00:06:24,240 --> 00:06:26,160
length header with 41 bytes

160
00:06:26,160 --> 00:06:29,280
and uh followed by uh this uh

161
00:06:29,280 --> 00:06:32,319
um not so legit content length header

162
00:06:32,319 --> 00:06:34,080
with space and junk with the value of

163
00:06:34,080 --> 00:06:34,880
three

164
00:06:34,880 --> 00:06:38,319
uh squid uses the valid content length

165
00:06:38,319 --> 00:06:40,720
header and ignores the invalid header so

166
00:06:40,720 --> 00:06:41,280
from

167
00:06:41,280 --> 00:06:43,440
squid's perspective we're talking about

168
00:06:43,440 --> 00:06:45,840
a body length for 41 bytes

169
00:06:45,840 --> 00:06:49,120
whereas abyss uses the second

170
00:06:49,120 --> 00:06:52,240
a content length header which is which

171
00:06:52,240 --> 00:06:54,000
has the value of three from abuses

172
00:06:54,000 --> 00:06:56,400
point of view so abyss will see the

173
00:06:56,400 --> 00:06:58,639
second request for poison html

174
00:06:58,639 --> 00:07:02,479
and serve it whereas um squid

175
00:07:02,479 --> 00:07:04,800
will see the second request as get

176
00:07:04,800 --> 00:07:07,280
welcome html so it will cache

177
00:07:07,280 --> 00:07:10,800
uh the content of the poison url

178
00:07:10,800 --> 00:07:16,319
served by abyss to the url

179
00:07:16,319 --> 00:07:20,560
html and now what if we don't like

180
00:07:20,560 --> 00:07:23,520
this to feed the abyss with two content

181
00:07:23,520 --> 00:07:24,800
songs headers

182
00:07:24,800 --> 00:07:27,520
uh what if we suspect that this will fix

183
00:07:27,520 --> 00:07:27,840
this

184
00:07:27,840 --> 00:07:31,840
soon so we discovered an interesting

185
00:07:31,840 --> 00:07:34,960
abyss behavior something that is also

186
00:07:34,960 --> 00:07:37,840
exhibited by other web servers which is

187
00:07:37,840 --> 00:07:38,639
if the

188
00:07:38,639 --> 00:07:41,120
request is partial it may still be

189
00:07:41,120 --> 00:07:42,080
fulfilled

190
00:07:42,080 --> 00:07:44,000
by the web server and by partial i mean

191
00:07:44,000 --> 00:07:46,000
that the the

192
00:07:46,000 --> 00:07:49,759
full body bytes uh was were not yet uh

193
00:07:49,759 --> 00:07:50,720
received

194
00:07:50,720 --> 00:07:54,240
so um abyss in such case will wait 30

195
00:07:54,240 --> 00:07:55,120
seconds and then

196
00:07:55,120 --> 00:07:57,360
it will invoke the back-end script and

197
00:07:57,360 --> 00:07:58,240
provide the

198
00:07:58,240 --> 00:08:00,400
proxy or the client with the data that

199
00:08:00,400 --> 00:08:02,000
this script

200
00:08:02,000 --> 00:08:05,039
generated and after additional bytes are

201
00:08:05,039 --> 00:08:05,840
received

202
00:08:05,840 --> 00:08:08,639
on the in the tcp connection they will

203
00:08:08,639 --> 00:08:10,400
be silently discarded

204
00:08:10,400 --> 00:08:13,360
until the full body is red and then and

205
00:08:13,360 --> 00:08:15,120
then abyss will start parsing the next

206
00:08:15,120 --> 00:08:16,000
request

207
00:08:16,000 --> 00:08:18,720
so how would what would an attack uh

208
00:08:18,720 --> 00:08:19,360
look like

209
00:08:19,360 --> 00:08:22,319
uh in this case uh we have just the

210
00:08:22,319 --> 00:08:24,000
connection the the invalid

211
00:08:24,000 --> 00:08:26,479
uh content length header uh in which

212
00:08:26,479 --> 00:08:28,879
case uh squid will interpret this as a

213
00:08:28,879 --> 00:08:31,280
zero length uh body request

214
00:08:31,280 --> 00:08:34,000
and will only send the headers to to

215
00:08:34,000 --> 00:08:34,640
abyss

216
00:08:34,640 --> 00:08:37,679
abyss will weight 30 abyss expects 39

217
00:08:37,679 --> 00:08:38,719
bytes in the body

218
00:08:38,719 --> 00:08:41,279
it waits for 30 seconds then invoke

219
00:08:41,279 --> 00:08:41,919
hello

220
00:08:41,919 --> 00:08:43,839
invokes hello php hello php generates

221
00:08:43,839 --> 00:08:46,880
some answer this is forwarded to squid

222
00:08:46,880 --> 00:08:49,120
and then squid sends the next request

223
00:08:49,120 --> 00:08:49,920
that for

224
00:08:49,920 --> 00:08:53,279
its from its point of view this is a get

225
00:08:53,279 --> 00:08:54,959
welcome and so forth

226
00:08:54,959 --> 00:08:57,279
and then abyss will silently discard the

227
00:08:57,279 --> 00:08:59,120
39 bytes that belong to the first

228
00:08:59,120 --> 00:09:00,640
request form's perspective

229
00:09:00,640 --> 00:09:02,800
and start serving the second request

230
00:09:02,800 --> 00:09:05,360
which is get poison html so again

231
00:09:05,360 --> 00:09:09,839
web cache poisoning

232
00:09:10,320 --> 00:09:12,399
some variants interesting variants i

233
00:09:12,399 --> 00:09:14,000
discovered relate to

234
00:09:14,000 --> 00:09:17,200
how mod security plus crs

235
00:09:17,200 --> 00:09:20,320
behave specifically this

236
00:09:20,320 --> 00:09:23,839
community rule set uh mod security plus

237
00:09:23,839 --> 00:09:26,000
plus crs is actually a free and open

238
00:09:26,000 --> 00:09:27,920
source web application firewall

239
00:09:27,920 --> 00:09:30,880
it provides us some rudimentary direct

240
00:09:30,880 --> 00:09:32,399
protection against http request

241
00:09:32,399 --> 00:09:33,360
smuggling

242
00:09:33,360 --> 00:09:36,240
uh it has the perennial levels uh it

243
00:09:36,240 --> 00:09:39,360
runs by default in paranormal level one

244
00:09:39,360 --> 00:09:42,800
and it can it has some more strict rules

245
00:09:42,800 --> 00:09:44,640
in parallel level three or four

246
00:09:44,640 --> 00:09:46,160
but these generate a lot of false

247
00:09:46,160 --> 00:09:47,760
positives so they

248
00:09:47,760 --> 00:09:49,680
practically cannot be used in in

249
00:09:49,680 --> 00:09:51,040
production environments

250
00:09:51,040 --> 00:09:53,440
and our bypass works for paranormal

251
00:09:53,440 --> 00:09:56,720
levels one and two

252
00:09:57,040 --> 00:10:01,120
so let's let's look at it

253
00:10:01,120 --> 00:10:04,160
let's review uh what

254
00:10:04,160 --> 00:10:06,399
what the challenges were and how we uh

255
00:10:06,399 --> 00:10:07,920
we overcame them

256
00:10:07,920 --> 00:10:10,959
um so the problem with uh

257
00:10:10,959 --> 00:10:13,279
the problem with mod security plus crs

258
00:10:13,279 --> 00:10:15,519
is that our http request smangling

259
00:10:15,519 --> 00:10:16,480
payloads

260
00:10:16,480 --> 00:10:19,040
got blocked by the http response

261
00:10:19,040 --> 00:10:21,040
splitting attack

262
00:10:21,040 --> 00:10:24,399
rules so for example uh we have two

263
00:10:24,399 --> 00:10:25,120
rules

264
00:10:25,120 --> 00:10:28,399
uh a 921 130

265
00:10:28,399 --> 00:10:33,839
that looks for a pattern of http slash

266
00:10:33,959 --> 00:10:35,920
091011

267
00:10:35,920 --> 00:10:37,920
and we have another one that looks for

268
00:10:37,920 --> 00:10:39,600
character 10 and line feed in argument

269
00:10:39,600 --> 00:10:40,320
names

270
00:10:40,320 --> 00:10:44,000
both are geared towards blocking http

271
00:10:44,000 --> 00:10:44,839
response

272
00:10:44,839 --> 00:10:47,839
splitting unfortunately for us

273
00:10:47,839 --> 00:10:50,640
they also work against our http request

274
00:10:50,640 --> 00:10:52,000
smuggling payloads

275
00:10:52,000 --> 00:10:54,959
uh walking around the last one the 150

276
00:10:54,959 --> 00:10:56,240
is trivial

277
00:10:56,240 --> 00:10:59,680
we just moved the attack from the what

278
00:10:59,680 --> 00:11:01,680
what what security considers as the

279
00:11:01,680 --> 00:11:02,800
argument name

280
00:11:02,800 --> 00:11:05,120
to the argument value by prepending the

281
00:11:05,120 --> 00:11:06,240
n argument if

282
00:11:06,240 --> 00:11:09,839
a bogus or fake argument name x y equals

283
00:11:09,839 --> 00:11:11,600
something and then we move away from

284
00:11:11,600 --> 00:11:14,560
being an argument name

285
00:11:14,560 --> 00:11:17,600
as for the 130

286
00:11:17,600 --> 00:11:20,480
the trick is to use http 1 2 instead of

287
00:11:20,480 --> 00:11:22,640
http 1011

288
00:11:22,640 --> 00:11:25,279
and as it happens iis apache engines

289
00:11:25,279 --> 00:11:28,160
node.js and the bs respect http 1 2

290
00:11:28,160 --> 00:11:30,880
and they treat it as http 1 1 and in

291
00:11:30,880 --> 00:11:32,240
their

292
00:11:32,240 --> 00:11:35,360
in their proxy head squid h a proxy kdn

293
00:11:35,360 --> 00:11:36,959
traffic respect http

294
00:11:36,959 --> 00:11:40,160
1 2 but converts them into http 1 1.

295
00:11:40,160 --> 00:11:42,000
there's still a small problem with rule

296
00:11:42,000 --> 00:11:43,200
150

297
00:11:43,200 --> 00:11:46,720
uh which is uh triggered

298
00:11:46,720 --> 00:11:49,040
because the the payload contains

299
00:11:49,040 --> 00:11:51,200
something that looks like a unix direct

300
00:11:51,200 --> 00:11:52,240
command execution

301
00:11:52,240 --> 00:11:55,360
the space followed by slash but that can

302
00:11:55,360 --> 00:11:56,480
be walked around too

303
00:11:56,480 --> 00:11:59,600
by using the full proxy url

304
00:11:59,600 --> 00:12:02,560
as you can see below

305
00:12:03,440 --> 00:12:07,839
and then we discovered a much more funny

306
00:12:07,839 --> 00:12:10,720
bypass which is to use content sense

307
00:12:10,720 --> 00:12:11,839
text plain

308
00:12:11,839 --> 00:12:14,320
uh this one in paranoia levels one or

309
00:12:14,320 --> 00:12:15,279
two simply

310
00:12:15,279 --> 00:12:18,480
makes uh the content rules community

311
00:12:18,480 --> 00:12:19,200
rule set

312
00:12:19,200 --> 00:12:22,800
uh to disregard the body entirely and

313
00:12:22,800 --> 00:12:25,360
so we can get our http request smuggling

314
00:12:25,360 --> 00:12:25,839
attack

315
00:12:25,839 --> 00:12:29,040
uh nicely through

316
00:12:29,040 --> 00:12:32,639
the through mod security plus series

317
00:12:32,639 --> 00:12:35,839
and the fifth variant is actually um

318
00:12:35,839 --> 00:12:38,959
is documented

319
00:12:38,959 --> 00:12:40,959
somewhere in burps http request

320
00:12:40,959 --> 00:12:43,440
smuggling module as a 0drap

321
00:12:43,440 --> 00:12:45,440
but i don't think i have seen any

322
00:12:45,440 --> 00:12:47,360
successful

323
00:12:47,360 --> 00:12:50,800
use of that until today

324
00:12:50,800 --> 00:12:53,839
so we discovered that squid ignores a

325
00:12:53,839 --> 00:12:55,920
header propended by a kurd return

326
00:12:55,920 --> 00:12:58,720
it's it just forward it as is and abuse

327
00:12:58,720 --> 00:13:00,240
respects this header

328
00:13:00,240 --> 00:13:03,120
and here's an example of an http request

329
00:13:03,120 --> 00:13:04,399
smuggling attack

330
00:13:04,399 --> 00:13:07,440
ending in web cache poisoning uh using

331
00:13:07,440 --> 00:13:08,639
the wait for it

332
00:13:08,639 --> 00:13:12,880
trick again so we just feed this

333
00:13:12,880 --> 00:13:15,839
this invalid content length header squid

334
00:13:15,839 --> 00:13:16,880
ignores it

335
00:13:16,880 --> 00:13:21,839
and abyss respects it

336
00:13:22,000 --> 00:13:24,160
one last tip for overriding existing

337
00:13:24,160 --> 00:13:26,160
cache items so sometimes a page is

338
00:13:26,160 --> 00:13:28,560
cached and you want to poison it

339
00:13:28,560 --> 00:13:30,720
you can use a cache control no cache for

340
00:13:30,720 --> 00:13:32,800
the request that

341
00:13:32,800 --> 00:13:35,519
that involves this page and the header

342
00:13:35,519 --> 00:13:37,120
may be moved around so you need to be

343
00:13:37,120 --> 00:13:38,240
careful about it

344
00:13:38,240 --> 00:13:40,320
when you calculate the uh payload

345
00:13:40,320 --> 00:13:43,920
lengths and and offsets

346
00:13:44,240 --> 00:13:46,880
uh let's see this uh those variants in

347
00:13:46,880 --> 00:13:49,839
action

348
00:13:53,199 --> 00:13:56,720
we can see we can start with the abyss

349
00:13:56,720 --> 00:13:58,959
web server version as you can see it's

350
00:13:58,959 --> 00:14:00,399
pretty recent

351
00:14:00,399 --> 00:14:03,680
followed by the squid version which you

352
00:14:03,680 --> 00:14:05,440
can see it's fully patched for

353
00:14:05,440 --> 00:14:07,680
at the time of testing and then let's

354
00:14:07,680 --> 00:14:11,680
see now variant one we first

355
00:14:11,680 --> 00:14:15,279
load uh the target page uh

356
00:14:15,279 --> 00:14:17,040
the original target target page which

357
00:14:17,040 --> 00:14:19,440
makes it also

358
00:14:19,440 --> 00:14:23,040
which makes squid cache it

359
00:14:25,519 --> 00:14:30,160
and then we run the smuggling script

360
00:14:30,160 --> 00:14:34,560
to see our options we use now the

361
00:14:34,560 --> 00:14:44,880
first variant

362
00:14:44,880 --> 00:14:47,760
and now we load the same target page in

363
00:14:47,760 --> 00:14:50,079
a different browser to avoid the

364
00:14:50,079 --> 00:14:53,839
browser caching issues and we see indeed

365
00:14:53,839 --> 00:14:59,839
that it is poisoned

366
00:15:00,000 --> 00:15:01,680
moving to var into the second variant

367
00:15:01,680 --> 00:15:03,839
again we load the url

368
00:15:03,839 --> 00:15:08,079
we see that the page is cached correctly

369
00:15:08,079 --> 00:15:13,839
now we run the second variant

370
00:15:21,120 --> 00:15:26,560
the time fast forwards for 30 seconds

371
00:15:26,560 --> 00:15:29,600
and we check that

372
00:15:29,600 --> 00:15:31,600
the page again from a different browser

373
00:15:31,600 --> 00:15:35,519
instance and we see that it's poisoned

374
00:15:38,000 --> 00:15:40,720
finally we run the fifth variant again

375
00:15:40,720 --> 00:15:41,839
we load your

376
00:15:41,839 --> 00:15:44,720
the target url now it's cached in the in

377
00:15:44,720 --> 00:15:46,959
squid

378
00:15:46,959 --> 00:15:50,399
we're on the fifth variant

379
00:15:52,399 --> 00:15:58,160
time is fast forwarding 30 seconds

380
00:15:58,800 --> 00:16:01,920
and we load this url again

381
00:16:01,920 --> 00:16:05,040
so this for the proxy and we see that it

382
00:16:05,040 --> 00:16:05,759
is cached

383
00:16:05,759 --> 00:16:09,920
it is poisoned so

384
00:16:09,920 --> 00:16:12,959
uh i reported all those

385
00:16:12,959 --> 00:16:16,480
variants to squid and abyss and and osp

386
00:16:16,480 --> 00:16:17,519
community rule set

387
00:16:17,519 --> 00:16:20,720
it was fixed in abyss and in wasp

388
00:16:20,720 --> 00:16:22,000
community rule set and

389
00:16:22,000 --> 00:16:25,920
hopefully by the time this presentation

390
00:16:25,920 --> 00:16:29,279
is is screened

391
00:16:29,279 --> 00:16:32,959
uh uh squid will also fix those

392
00:16:32,959 --> 00:16:37,839
issues in its product

393
00:16:38,000 --> 00:16:40,880
and after seeing that the issue is still

394
00:16:40,880 --> 00:16:41,920
real

395
00:16:41,920 --> 00:16:44,160
i started considering what the possible

396
00:16:44,160 --> 00:16:47,120
solutions may be

397
00:16:47,920 --> 00:16:51,360
first i want to

398
00:16:51,360 --> 00:16:54,160
discuss some flawed approaches for

399
00:16:54,160 --> 00:16:57,360
protection against hp request smuggling

400
00:16:57,360 --> 00:16:59,680
for example some people claim that

401
00:16:59,680 --> 00:17:02,160
normalization of outbound http headers

402
00:17:02,160 --> 00:17:03,360
for proxy servers

403
00:17:03,360 --> 00:17:06,480
is a solution and i think that

404
00:17:06,480 --> 00:17:08,720
obviously it's a solution for the http

405
00:17:08,720 --> 00:17:10,559
devices behind the proxy but it's

406
00:17:10,559 --> 00:17:12,880
completely ineffective for all the tasks

407
00:17:12,880 --> 00:17:14,880
that take place between the proxy and

408
00:17:14,880 --> 00:17:17,039
the devices in front of it

409
00:17:17,039 --> 00:17:18,959
so for example if you are a client and

410
00:17:18,959 --> 00:17:21,039
there is a proxy p1

411
00:17:21,039 --> 00:17:23,919
and then your proxy p2 in this chain and

412
00:17:23,919 --> 00:17:26,000
finally there is a web server

413
00:17:26,000 --> 00:17:28,799
then and p1 uses say the first

414
00:17:28,799 --> 00:17:31,360
contentment header and p2 uses the last

415
00:17:31,360 --> 00:17:32,799
content length header

416
00:17:32,799 --> 00:17:34,960
then the then you can mount an http

417
00:17:34,960 --> 00:17:38,080
request smuggling between p1 and p2 now

418
00:17:38,080 --> 00:17:40,880
if you ask whether this is uh whether p2

419
00:17:40,880 --> 00:17:42,400
is to be blamed or to

420
00:17:42,400 --> 00:17:45,679
to shoulder part of the blame

421
00:17:45,679 --> 00:17:48,160
think of the p2 to the web server

422
00:17:48,160 --> 00:17:49,120
connection

423
00:17:49,120 --> 00:17:52,160
as an abstraction for web server ws

424
00:17:52,160 --> 00:17:53,039
prime

425
00:17:53,039 --> 00:17:55,600
so now the client is communicating

426
00:17:55,600 --> 00:17:57,280
through a single proxy p1

427
00:17:57,280 --> 00:18:00,400
to web server ws prime and ws primer c

428
00:18:00,400 --> 00:18:02,320
accepts multiple content length headers

429
00:18:02,320 --> 00:18:03,919
and uses the last one

430
00:18:03,919 --> 00:18:05,760
now would you say in this case the ws

431
00:18:05,760 --> 00:18:07,600
prime is vulnerable to http request

432
00:18:07,600 --> 00:18:08,480
smuggling

433
00:18:08,480 --> 00:18:11,039
because if you say yes then obviously p2

434
00:18:11,039 --> 00:18:13,120
is vulnerable to http request smuggling

435
00:18:13,120 --> 00:18:13,520
because

436
00:18:13,520 --> 00:18:16,720
ws the original ws can be

437
00:18:16,720 --> 00:18:19,760
fully 100 percent rfc compliant

438
00:18:19,760 --> 00:18:21,919
and yet http request smart and web cache

439
00:18:21,919 --> 00:18:23,760
poisoning can take place

440
00:18:23,760 --> 00:18:26,480
so if you accept the premise that in

441
00:18:26,480 --> 00:18:28,799
such case a web server

442
00:18:28,799 --> 00:18:30,960
is vulnerable to http request smuggling

443
00:18:30,960 --> 00:18:34,799
then obviously a proxy is two

444
00:18:35,039 --> 00:18:38,480
same argument applies to having a tcp

445
00:18:38,480 --> 00:18:39,679
connection per each

446
00:18:39,679 --> 00:18:42,160
outbound request again something that

447
00:18:42,160 --> 00:18:44,000
proxy servers

448
00:18:44,000 --> 00:18:47,039
can do it's good for http devices behind

449
00:18:47,039 --> 00:18:48,880
the proxy but it's not effective for

450
00:18:48,880 --> 00:18:49,679
http

451
00:18:49,679 --> 00:18:53,200
devices in front of the proxy

452
00:18:53,200 --> 00:18:56,559
so uh moving back to uh finding a

453
00:18:56,559 --> 00:18:58,080
solution so my first stop

454
00:18:58,080 --> 00:19:00,720
was obviously with mod security plus the

455
00:19:00,720 --> 00:19:02,160
crs

456
00:19:02,160 --> 00:19:04,400
it has some obvious pros like being a

457
00:19:04,400 --> 00:19:06,000
true web application firewall

458
00:19:06,000 --> 00:19:08,480
being free and being open source but it

459
00:19:08,480 --> 00:19:09,679
also has some

460
00:19:09,679 --> 00:19:12,320
some serious cons which is it only

461
00:19:12,320 --> 00:19:13,280
supports a

462
00:19:13,280 --> 00:19:16,240
small subset of web servers and it only

463
00:19:16,240 --> 00:19:18,000
has a rudimentary defense

464
00:19:18,000 --> 00:19:20,559
uh against http request smuggling so

465
00:19:20,559 --> 00:19:21,760
from my perspective

466
00:19:21,760 --> 00:19:25,520
it's not good enough

467
00:19:25,520 --> 00:19:28,320
so i started thinking about what is an

468
00:19:28,320 --> 00:19:29,760
ideal solution

469
00:19:29,760 --> 00:19:33,280
would look like and my concept is

470
00:19:33,280 --> 00:19:35,360
something lightweight and simple and

471
00:19:35,360 --> 00:19:38,000
easy not a fully fledged dwarf

472
00:19:38,000 --> 00:19:40,160
it should be it should focus on specific

473
00:19:40,160 --> 00:19:41,760
protocol attacks like http request

474
00:19:41,760 --> 00:19:42,400
smuggling

475
00:19:42,400 --> 00:19:44,400
and maybe additional attacks it should

476
00:19:44,400 --> 00:19:46,320
be secure obviously

477
00:19:46,320 --> 00:19:48,799
and i want to develop a proof of concept

478
00:19:48,799 --> 00:19:49,600
that doesn't

479
00:19:49,600 --> 00:19:52,160
need to be production quality it just

480
00:19:52,160 --> 00:19:54,400
need to demonstrate a concept that then

481
00:19:54,400 --> 00:19:55,679
vendors can take and

482
00:19:55,679 --> 00:19:58,080
implement in their products or

483
00:19:58,080 --> 00:19:59,440
third-party

484
00:19:59,440 --> 00:20:02,480
security providers can uh

485
00:20:02,480 --> 00:20:06,080
implement as a production and

486
00:20:06,080 --> 00:20:08,720
production uh solution production grade

487
00:20:08,720 --> 00:20:11,200
solution

488
00:20:11,440 --> 00:20:14,159
and more specifically the architecture

489
00:20:14,159 --> 00:20:15,039
would be or

490
00:20:15,039 --> 00:20:18,720
or the the solution would revolve around

491
00:20:18,720 --> 00:20:21,039
having a very strict validation of small

492
00:20:21,039 --> 00:20:23,039
subset of the http standards

493
00:20:23,039 --> 00:20:25,120
so i'm talking about anything that can

494
00:20:25,120 --> 00:20:27,280
affect the request length

495
00:20:27,280 --> 00:20:29,440
uh specifically the content length

496
00:20:29,440 --> 00:20:31,520
header and the transfer encoding header

497
00:20:31,520 --> 00:20:33,760
and having unambiguous line ends and

498
00:20:33,760 --> 00:20:35,120
header block end

499
00:20:35,120 --> 00:20:36,799
and of course monitoring the request

500
00:20:36,799 --> 00:20:38,799
line for uh for verb names

501
00:20:38,799 --> 00:20:41,520
it should be unambiguous because the

502
00:20:41,520 --> 00:20:43,760
verb name sometimes dictates that their

503
00:20:43,760 --> 00:20:46,720
the request mustn't have a body or or

504
00:20:46,720 --> 00:20:48,880
typically doesn't have a body

505
00:20:48,880 --> 00:20:51,520
and an ambiguous protocol designation is

506
00:20:51,520 --> 00:20:55,120
in order to avoid the htp-09 the http 09

507
00:20:55,120 --> 00:20:55,919
syndrome

508
00:20:55,919 --> 00:20:57,679
and maybe other headers that i haven't

509
00:20:57,679 --> 00:21:00,480
thought about yet

510
00:21:00,720 --> 00:21:03,520
i want my solution to be generic so it

511
00:21:03,520 --> 00:21:05,039
doesn't tie to specific

512
00:21:05,039 --> 00:21:08,000
technology or product or platform so

513
00:21:08,000 --> 00:21:09,919
specifically i don't want to rely on

514
00:21:09,919 --> 00:21:12,000
windows lsp or wfp

515
00:21:12,000 --> 00:21:15,200
and it would be nice to have that

516
00:21:15,200 --> 00:21:17,600
that it can be extended beyond the http

517
00:21:17,600 --> 00:21:18,559
like

518
00:21:18,559 --> 00:21:22,000
having a power decrypted the https

519
00:21:22,000 --> 00:21:22,799
traffic

520
00:21:22,799 --> 00:21:25,120
and maybe other protocols and of course

521
00:21:25,120 --> 00:21:27,360
it should be secure so i think that

522
00:21:27,360 --> 00:21:29,760
the only way to do that is with in-path

523
00:21:29,760 --> 00:21:30,799
monitoring and not

524
00:21:30,799 --> 00:21:34,240
something based on sniffing and

525
00:21:34,240 --> 00:21:38,559
architecturally the solution i arrived

526
00:21:38,559 --> 00:21:41,360
to was is the good all the function

527
00:21:41,360 --> 00:21:42,320
hooking

528
00:21:42,320 --> 00:21:45,760
for in this case for for the socket

529
00:21:45,760 --> 00:21:49,760
layer uh functions so a few words about

530
00:21:49,760 --> 00:21:51,039
function hooking

531
00:21:51,039 --> 00:21:54,240
uh while completely non-standard it's de

532
00:21:54,240 --> 00:21:54,960
facto

533
00:21:54,960 --> 00:21:58,400
uh used very commonly in major operating

534
00:21:58,400 --> 00:22:00,400
systems like windows and linux

535
00:22:00,400 --> 00:22:02,240
and there are even cross-platform

536
00:22:02,240 --> 00:22:03,840
function hooking libraries like

537
00:22:03,840 --> 00:22:07,600
fan hook that i use in my in my project

538
00:22:07,600 --> 00:22:09,600
stability and robustness may be an issue

539
00:22:09,600 --> 00:22:12,320
but again this is a proof of concept

540
00:22:12,320 --> 00:22:15,600
library it's not a full product

541
00:22:15,600 --> 00:22:19,840
and uh and hooking is just one piece of

542
00:22:19,840 --> 00:22:21,919
of the game and one needs still to

543
00:22:21,919 --> 00:22:24,240
inject the code

544
00:22:24,240 --> 00:22:26,559
or at least an initial code in windows

545
00:22:26,559 --> 00:22:28,799
this can be done by using a standard dll

546
00:22:28,799 --> 00:22:29,600
injection

547
00:22:29,600 --> 00:22:32,640
in linux you can use ld preload again

548
00:22:32,640 --> 00:22:34,799
problem with stability and again i don't

549
00:22:34,799 --> 00:22:36,240
care about this at this

550
00:22:36,240 --> 00:22:39,600
for this project and the way i

551
00:22:39,600 --> 00:22:41,200
implemented my project is

552
00:22:41,200 --> 00:22:43,760
using two layers one is the socket

553
00:22:43,760 --> 00:22:45,039
obstruction layer

554
00:22:45,039 --> 00:22:48,159
and the other one is the actual firewall

555
00:22:48,159 --> 00:22:50,480
and the socket abstraction layer allows

556
00:22:50,480 --> 00:22:52,720
me to abstract a native socket

557
00:22:52,720 --> 00:22:55,919
into standard open read close view

558
00:22:55,919 --> 00:22:58,000
so i need to manage the sockets from

559
00:22:58,000 --> 00:23:00,320
cradle to to death

560
00:23:00,320 --> 00:23:02,559
and i need of course to maintain a map

561
00:23:02,559 --> 00:23:03,520
from this

562
00:23:03,520 --> 00:23:06,000
socket file descriptor to to a user

563
00:23:06,000 --> 00:23:07,919
object that handles

564
00:23:07,919 --> 00:23:10,480
each socket each socket gets its own

565
00:23:10,480 --> 00:23:12,720
instance of a user object

566
00:23:12,720 --> 00:23:14,400
and i don't want to interfere with the

567
00:23:14,400 --> 00:23:16,400
system operation so there's no buffering

568
00:23:16,400 --> 00:23:17,120
at all

569
00:23:17,120 --> 00:23:21,360
that that i am allowed to introduce

570
00:23:21,360 --> 00:23:23,760
and i signal to the user object

571
00:23:23,760 --> 00:23:25,120
important actions

572
00:23:25,120 --> 00:23:27,919
by using the contract the constructor to

573
00:23:27,919 --> 00:23:29,520
signal a socket open

574
00:23:29,520 --> 00:23:32,720
an on-rate invocation which

575
00:23:32,720 --> 00:23:34,559
signals the socket read and the

576
00:23:34,559 --> 00:23:36,080
destructor signals the socket

577
00:23:36,080 --> 00:23:39,600
closed i provide the user object with

578
00:23:39,600 --> 00:23:41,520
the socket

579
00:23:41,520 --> 00:23:44,559
file descriptor so the user object can

580
00:23:44,559 --> 00:23:46,000
interact with the socket

581
00:23:46,000 --> 00:23:47,679
and the user object signals back to me

582
00:23:47,679 --> 00:23:50,000
in the return value whether it i should

583
00:23:50,000 --> 00:23:53,200
forcibly close the socket

584
00:23:53,200 --> 00:23:55,679
so what do i need to hook you can see

585
00:23:55,679 --> 00:23:56,320
that

586
00:23:56,320 --> 00:23:59,440
in windows i just need to hook

587
00:23:59,440 --> 00:24:01,520
seven functions to get to cover the full

588
00:24:01,520 --> 00:24:05,919
functionality of the usual suspects

589
00:24:05,919 --> 00:24:09,520
and same goes for linux tested in 64

590
00:24:09,520 --> 00:24:10,159
bits

591
00:24:10,159 --> 00:24:13,520
again a nice area of of

592
00:24:13,520 --> 00:24:16,559
web servers is car is covered by

593
00:24:16,559 --> 00:24:20,480
hooking uh seven functions only

594
00:24:20,480 --> 00:24:23,520
while implementing this the socket

595
00:24:23,520 --> 00:24:25,520
obstruction layer i learned a lot about

596
00:24:25,520 --> 00:24:26,960
the internals of

597
00:24:26,960 --> 00:24:31,279
of web servers and and in sockets

598
00:24:31,279 --> 00:24:33,840
of course especially in linux worker

599
00:24:33,840 --> 00:24:35,760
processes and forking must be

600
00:24:35,760 --> 00:24:38,720
supported this is not fully functional

601
00:24:38,720 --> 00:24:42,000
yet in my library i just run a single

602
00:24:42,000 --> 00:24:44,880
process instance of the web server for

603
00:24:44,880 --> 00:24:47,440
testing uh locking of the socket

604
00:24:47,440 --> 00:24:49,440
management table is also desired

605
00:24:49,440 --> 00:24:52,159
so far i haven't implemented it

606
00:24:52,159 --> 00:24:54,000
preserving the correct error state is

607
00:24:54,000 --> 00:24:55,279
mandatory

608
00:24:55,279 --> 00:24:58,320
you can easily crash a system

609
00:24:58,320 --> 00:25:01,360
or or make the system malfunction if you

610
00:25:01,360 --> 00:25:01,919
do not

611
00:25:01,919 --> 00:25:04,720
preserve erno last error and wsa last

612
00:25:04,720 --> 00:25:05,840
error

613
00:25:05,840 --> 00:25:08,080
std out and std error are not always

614
00:25:08,080 --> 00:25:11,120
available so write your own log file

615
00:25:11,120 --> 00:25:13,360
for some bizarre reason squid on linux

616
00:25:13,360 --> 00:25:15,679
doesn't like f claws so i had to

617
00:25:15,679 --> 00:25:18,799
resort to using the direct i o

618
00:25:18,799 --> 00:25:21,840
functions statistically linked

619
00:25:21,840 --> 00:25:24,320
executables with stripped symbols

620
00:25:24,320 --> 00:25:27,360
are a serious problem for my approach so

621
00:25:27,360 --> 00:25:29,919
compiled go products like traffic and

622
00:25:29,919 --> 00:25:32,480
credit are not supported at this time

623
00:25:32,480 --> 00:25:34,799
interestingly enough linux receive

624
00:25:34,799 --> 00:25:35,600
implementation

625
00:25:35,600 --> 00:25:37,760
actually invokes the receive from cisco

626
00:25:37,760 --> 00:25:40,320
this is a bit surprising

627
00:25:40,320 --> 00:25:42,799
accept or accept for are sometimes

628
00:25:42,799 --> 00:25:44,720
invoked with address being now this is

629
00:25:44,720 --> 00:25:45,520
valid but

630
00:25:45,520 --> 00:25:49,200
also surprising and node.js uses a

631
00:25:49,200 --> 00:25:51,039
library called uv lib

632
00:25:51,039 --> 00:25:54,320
which invokes the syscalls directly

633
00:25:54,320 --> 00:25:57,600
so you can't i can't hook uh there's no

634
00:25:57,600 --> 00:25:58,799
point in hooking the

635
00:25:58,799 --> 00:26:01,279
uh usual socket functions i need to hook

636
00:26:01,279 --> 00:26:02,240
specifically

637
00:26:02,240 --> 00:26:04,720
the uv accept four function in this case

638
00:26:04,720 --> 00:26:05,600
in order to get

639
00:26:05,600 --> 00:26:09,039
the full functionality on top of the

640
00:26:09,039 --> 00:26:10,799
socket obstruction layer i

641
00:26:10,799 --> 00:26:13,600
implemented another class called the

642
00:26:13,600 --> 00:26:15,679
request smuggling firewall

643
00:26:15,679 --> 00:26:18,080
that that uses the socket obstruction

644
00:26:18,080 --> 00:26:19,760
layer to implement

645
00:26:19,760 --> 00:26:22,159
the request smartening firewall

646
00:26:22,159 --> 00:26:23,279
surprisingly

647
00:26:23,279 --> 00:26:26,480
and in it enforces the strict rfc 2616

648
00:26:26,480 --> 00:26:28,000
on the relevant parts of the http

649
00:26:28,000 --> 00:26:29,919
request like request line format

650
00:26:29,919 --> 00:26:32,240
header name format uh content sense

651
00:26:32,240 --> 00:26:33,679
transfer encoding

652
00:26:33,679 --> 00:26:36,559
header end of line chunk body format it

653
00:26:36,559 --> 00:26:39,279
it operates with the default deny policy

654
00:26:39,279 --> 00:26:42,480
it only buffers is a single partial

655
00:26:42,480 --> 00:26:45,520
line uh internally it it always sends

656
00:26:45,520 --> 00:26:47,120
the data immediately to the application

657
00:26:47,120 --> 00:26:48,960
to the web server but it buffers

658
00:26:48,960 --> 00:26:52,880
a single partially a partial single line

659
00:26:52,880 --> 00:26:56,080
and so that there's no there's never

660
00:26:56,080 --> 00:26:59,760
a full line with violation transmitted

661
00:26:59,760 --> 00:27:02,320
to the web server so it stops

662
00:27:02,320 --> 00:27:05,360
immediately upon the first violation

663
00:27:05,360 --> 00:27:07,440
and the violation can cause it to send a

664
00:27:07,440 --> 00:27:09,760
400 response as we'll see in a moment

665
00:27:09,760 --> 00:27:13,520
and to terminate the connection and

666
00:27:13,520 --> 00:27:16,320
let's see a demo

667
00:27:17,760 --> 00:27:21,840
okay demo

668
00:27:24,880 --> 00:27:28,640
so we run squid with the rsfw

669
00:27:28,640 --> 00:27:32,080
library and then we try

670
00:27:32,080 --> 00:27:35,840
the first we first load the target page

671
00:27:35,840 --> 00:27:40,799
to squids cache as we usually do

672
00:27:40,799 --> 00:27:45,679
now we run the first variant

673
00:27:47,279 --> 00:27:49,760
we can see that it fails with a 400

674
00:27:49,760 --> 00:27:50,799
response

675
00:27:50,799 --> 00:27:53,360
and if we load the target page again

676
00:27:53,360 --> 00:27:55,918
this time

677
00:27:56,559 --> 00:27:58,159
we can see that it's actually not

678
00:27:58,159 --> 00:28:00,640
poisoned

679
00:28:00,640 --> 00:28:02,720
now we run the second variant if you

680
00:28:02,720 --> 00:28:05,840
remember it should run for 30 seconds

681
00:28:05,840 --> 00:28:09,440
but actually it just exited immediately

682
00:28:09,440 --> 00:28:13,279
and same with the fifth variant

683
00:28:15,440 --> 00:28:19,200
so during my http request smuggling

684
00:28:19,200 --> 00:28:21,840
research i bumped into some interesting

685
00:28:21,840 --> 00:28:24,240
promising or suspicious anomalies in

686
00:28:24,240 --> 00:28:25,440
some http

687
00:28:25,440 --> 00:28:28,960
devices for which i can describe a

688
00:28:28,960 --> 00:28:30,559
matching behavior

689
00:28:30,559 --> 00:28:32,399
so if i found something interesting in a

690
00:28:32,399 --> 00:28:34,159
web server i could describe a matching

691
00:28:34,159 --> 00:28:35,760
behavior in a proxy server

692
00:28:35,760 --> 00:28:38,000
that leads to http request smuggling

693
00:28:38,000 --> 00:28:39,279
however i could not

694
00:28:39,279 --> 00:28:42,399
find this matching behavior in my zoo of

695
00:28:42,399 --> 00:28:45,120
products so far

696
00:28:45,120 --> 00:28:47,039
just to illustrate let's say we go back

697
00:28:47,039 --> 00:28:48,799
to 2005

698
00:28:48,799 --> 00:28:50,799
and i noticed a web server which takes

699
00:28:50,799 --> 00:28:53,039
the first header in a double content

700
00:28:53,039 --> 00:28:54,159
length

701
00:28:54,159 --> 00:28:56,720
request a matching behavior would be

702
00:28:56,720 --> 00:28:58,000
then a proxy server

703
00:28:58,000 --> 00:29:00,399
that takes the last content in such a

704
00:29:00,399 --> 00:29:01,120
request

705
00:29:01,120 --> 00:29:04,320
but keeps both headers but let's say

706
00:29:04,320 --> 00:29:06,159
that in my lab back then i could only

707
00:29:06,159 --> 00:29:08,000
find proxy servers that either take the

708
00:29:08,000 --> 00:29:08,880
first header

709
00:29:08,880 --> 00:29:12,880
or reject the request then in 2005 this

710
00:29:12,880 --> 00:29:14,080
would have been a

711
00:29:14,080 --> 00:29:17,120
very interesting and relevant example

712
00:29:17,120 --> 00:29:20,320
naturally in 2020 this isn't uh there

713
00:29:20,320 --> 00:29:20,799
are

714
00:29:20,799 --> 00:29:24,080
probably no web server proxy server that

715
00:29:24,080 --> 00:29:28,559
behaves so naively but you get the idea

716
00:29:28,559 --> 00:29:32,320
so courage return in a header name

717
00:29:32,320 --> 00:29:35,520
is interpreted as a hyphen so uh

718
00:29:35,520 --> 00:29:38,559
just like i mentioned one web server

719
00:29:38,559 --> 00:29:39,440
treats this

720
00:29:39,440 --> 00:29:42,240
contents kerger 10 length as the header

721
00:29:42,240 --> 00:29:43,600
content length

722
00:29:43,600 --> 00:29:45,200
i suspect this is due to a quick and

723
00:29:45,200 --> 00:29:47,600
dirty upper casing using all with

724
00:29:47,600 --> 00:29:51,200
ox 20. so if you or

725
00:29:51,200 --> 00:29:55,200
ox20 with a card return you get a hyphen

726
00:29:55,200 --> 00:29:57,120
the matching proxy behavior is to simply

727
00:29:57,120 --> 00:29:59,120
ignore this header and forward it as

728
00:29:59,120 --> 00:30:01,520
is and the attack in this case would be

729
00:30:01,520 --> 00:30:03,840
the having a web server

730
00:30:03,840 --> 00:30:06,320
expect a body and using a get request

731
00:30:06,320 --> 00:30:08,080
the web server will immediately forward

732
00:30:08,080 --> 00:30:09,840
the request to the application without a

733
00:30:09,840 --> 00:30:10,799
body

734
00:30:10,799 --> 00:30:13,440
and this and on the other hand the

735
00:30:13,440 --> 00:30:14,559
matching proxy

736
00:30:14,559 --> 00:30:18,000
uh will uh so the matching proxy will

737
00:30:18,000 --> 00:30:18,559
treat it

738
00:30:18,559 --> 00:30:22,240
as a zero length body and the web server

739
00:30:22,240 --> 00:30:24,399
expects a body of a certain length and

740
00:30:24,399 --> 00:30:25,360
therefore a

741
00:30:25,360 --> 00:30:29,120
web cache poisoning ensues unfortunately

742
00:30:29,120 --> 00:30:31,279
for me it is an attacker all proxy

743
00:30:31,279 --> 00:30:32,320
servers i have

744
00:30:32,320 --> 00:30:35,120
either rejected with a 400 response or

745
00:30:35,120 --> 00:30:36,320
modify their

746
00:30:36,320 --> 00:30:38,960
their request

747
00:30:39,679 --> 00:30:43,200
this is this may be uh fixed

748
00:30:43,200 --> 00:30:46,000
by the time this presentation is aired

749
00:30:46,000 --> 00:30:46,799
so

750
00:30:46,799 --> 00:30:50,000
i urge you to to get updates

751
00:30:50,000 --> 00:30:53,520
on my uh for the white paper

752
00:30:53,520 --> 00:30:56,960
uh so i'll be able to hopefully i'll be

753
00:30:56,960 --> 00:30:57,919
able to update

754
00:30:57,919 --> 00:31:02,159
and to name the a relevant web server

755
00:31:02,159 --> 00:31:06,000
in the white paper signed content length

756
00:31:06,000 --> 00:31:08,240
i'm talking about adding a plus sign in

757
00:31:08,240 --> 00:31:09,440
front of the

758
00:31:09,440 --> 00:31:12,320
value obviously it's non-rfc behavior

759
00:31:12,320 --> 00:31:13,200
because the

760
00:31:13,200 --> 00:31:16,320
content length only allowed digits some

761
00:31:16,320 --> 00:31:18,720
proxy implementations use the api

762
00:31:18,720 --> 00:31:21,919
like a2i that does accept the sign

763
00:31:21,919 --> 00:31:23,919
uh the matching web server behavior is

764
00:31:23,919 --> 00:31:25,519
to simply ignore this header and the

765
00:31:25,519 --> 00:31:27,279
attack is obvious the web server has

766
00:31:27,279 --> 00:31:29,360
defacto content length zero

767
00:31:29,360 --> 00:31:31,279
whereas the proxy servers is one two

768
00:31:31,279 --> 00:31:32,960
three four

769
00:31:32,960 --> 00:31:34,880
this doesn't work of course if the proxy

770
00:31:34,880 --> 00:31:36,559
normalizes the content limit header

771
00:31:36,559 --> 00:31:37,120
before

772
00:31:37,120 --> 00:31:40,320
forwarding it to the web server all the

773
00:31:40,320 --> 00:31:42,240
web servers i have either reject or

774
00:31:42,240 --> 00:31:43,600
honor this request as

775
00:31:43,600 --> 00:31:46,799
is so no good here

776
00:31:46,799 --> 00:31:49,840
uh and the vendor the i reported it to

777
00:31:49,840 --> 00:31:51,840
several proxy vendors it was fixed by

778
00:31:51,840 --> 00:31:52,799
squid

779
00:31:52,799 --> 00:31:55,918
abyss and go

780
00:31:56,720 --> 00:31:59,440
content length value with space so i'm

781
00:31:59,440 --> 00:32:00,000
talking about

782
00:32:00,000 --> 00:32:03,039
content length one two space three four

783
00:32:03,039 --> 00:32:06,159
again it's non rfc engines ignores this

784
00:32:06,159 --> 00:32:07,440
header

785
00:32:07,440 --> 00:32:09,760
what i look what i want to find is a

786
00:32:09,760 --> 00:32:11,120
proxy that uses

787
00:32:11,120 --> 00:32:13,120
one of the values one two three four one

788
00:32:13,120 --> 00:32:14,240
two or three four

789
00:32:14,240 --> 00:32:16,720
and four the request a header is is the

790
00:32:16,720 --> 00:32:18,640
attack is obvious

791
00:32:18,640 --> 00:32:20,480
all the proxy servers i have either

792
00:32:20,480 --> 00:32:22,559
reject or remove this header

793
00:32:22,559 --> 00:32:24,880
i reported this to engines and they say

794
00:32:24,880 --> 00:32:26,799
they won't fix it because it doesn't

795
00:32:26,799 --> 00:32:28,720
look like vulnerability in engines the

796
00:32:28,720 --> 00:32:30,399
requests in question

797
00:32:30,399 --> 00:32:32,080
cannot be passed through a compliant

798
00:32:32,080 --> 00:32:34,399
http proxy with the header interpreted

799
00:32:34,399 --> 00:32:37,840
as a content length header so they say

800
00:32:37,840 --> 00:32:40,320
finally

801
00:32:41,120 --> 00:32:42,880
there's one web server that simply

802
00:32:42,880 --> 00:32:45,200
ignores transfer encoding even in http

803
00:32:45,200 --> 00:32:47,200
one one obviously this is not an

804
00:32:47,200 --> 00:32:50,480
rfc compliant behavior

805
00:32:50,480 --> 00:32:52,640
what i look for is a proxy server that

806
00:32:52,640 --> 00:32:54,640
prefers transfer encoding over content

807
00:32:54,640 --> 00:32:56,399
length but does not modify

808
00:32:56,399 --> 00:32:58,640
the request and the attack would be to

809
00:32:58,640 --> 00:33:00,720
send a request with both transfer

810
00:33:00,720 --> 00:33:02,640
encoding and content length where the

811
00:33:02,640 --> 00:33:04,159
proxy would use

812
00:33:04,159 --> 00:33:06,399
the transfer encoding header and the web

813
00:33:06,399 --> 00:33:07,919
server would use the content links

814
00:33:07,919 --> 00:33:09,360
header

815
00:33:09,360 --> 00:33:11,360
all the proxies i have normalize the

816
00:33:11,360 --> 00:33:13,200
request either per the content link

817
00:33:13,200 --> 00:33:14,880
letter or per the transfer encoding

818
00:33:14,880 --> 00:33:15,519
header

819
00:33:15,519 --> 00:33:18,240
so this becomes a non-relevant so i

820
00:33:18,240 --> 00:33:18,720
cannot

821
00:33:18,720 --> 00:33:22,080
exploit it in my lab

822
00:33:23,279 --> 00:33:26,720
to conclude uh

823
00:33:26,720 --> 00:33:28,559
we see that http request smuggling is

824
00:33:28,559 --> 00:33:30,159
still a thing in 2020

825
00:33:30,159 --> 00:33:33,360
in common off-the-shelf software uh

826
00:33:33,360 --> 00:33:34,640
existing open source

827
00:33:34,640 --> 00:33:37,200
solutions are lacking there's there is a

828
00:33:37,200 --> 00:33:38,880
more robust approach for defending

829
00:33:38,880 --> 00:33:40,880
against atp request smuggling and it is

830
00:33:40,880 --> 00:33:42,880
feasible i'm talking about

831
00:33:42,880 --> 00:33:45,840
implementing a lightweight solutions

832
00:33:45,840 --> 00:33:47,840
specifically tailored for http request

833
00:33:47,840 --> 00:33:49,279
modeling

834
00:33:49,279 --> 00:33:52,159
in path it can be applied by vendros or

835
00:33:52,159 --> 00:33:53,279
third-party

836
00:33:53,279 --> 00:33:56,080
security software and there are still

837
00:33:56,080 --> 00:33:57,440
some interesting challenges

838
00:33:57,440 --> 00:34:06,159
in this area thank you very much

839
00:34:06,159 --> 00:34:10,399
right um so thank you very much for

840
00:34:10,399 --> 00:34:13,760
attending my session uh

841
00:34:13,760 --> 00:34:16,560
right now i see there is one question

842
00:34:16,560 --> 00:34:16,960
but

843
00:34:16,960 --> 00:34:19,918
uh what a question this is uh the

844
00:34:19,918 --> 00:34:20,399
question

845
00:34:20,399 --> 00:34:24,879
is uh let me read it for everyone

846
00:34:24,879 --> 00:34:27,040
are there good fuzzing frameworks for

847
00:34:27,040 --> 00:34:29,119
testing for http requests smuggling

848
00:34:29,119 --> 00:34:29,760
besides

849
00:34:29,760 --> 00:34:33,679
manual testing eg through burp or zap

850
00:34:33,679 --> 00:34:37,199
so to the best of my knowledge

851
00:34:37,199 --> 00:34:40,639
some web application scanners

852
00:34:40,639 --> 00:34:44,560
have uh http requests smuggling

853
00:34:44,560 --> 00:34:47,679
testing attacks incorporated

854
00:34:47,679 --> 00:34:51,040
in them uh having said that

855
00:34:51,040 --> 00:34:55,520
i think that there are some obvious

856
00:34:55,760 --> 00:35:00,079
hurdles in automatically testing

857
00:35:00,079 --> 00:35:02,160
for http request smuggling as some of

858
00:35:02,160 --> 00:35:03,440
the uh

859
00:35:03,440 --> 00:35:06,800
people on the on the chat mentioned

860
00:35:06,800 --> 00:35:10,720
so in essence one needs to be

861
00:35:10,720 --> 00:35:14,000
very careful about um the impact of the

862
00:35:14,000 --> 00:35:15,760
attack which can be very tricky in the

863
00:35:15,760 --> 00:35:16,000
case

864
00:35:16,000 --> 00:35:18,720
of http request smuggling including a

865
00:35:18,720 --> 00:35:19,760
long lasting

866
00:35:19,760 --> 00:35:22,960
effect on the uh on the cash

867
00:35:22,960 --> 00:35:26,960
um and uh

868
00:35:26,960 --> 00:35:29,520
at large i think this attack is somewhat

869
00:35:29,520 --> 00:35:33,520
more difficult to control or to

870
00:35:33,920 --> 00:35:37,760
predict the uh the outcome of the exact

871
00:35:37,760 --> 00:35:40,880
attack or the variant compared to other

872
00:35:40,880 --> 00:35:43,280
application vulnerabilities or

873
00:35:43,280 --> 00:35:44,800
application tax

874
00:35:44,800 --> 00:35:49,119
um i think james cattle in his uh

875
00:35:49,119 --> 00:35:51,440
last year's blackhead presentation

876
00:35:51,440 --> 00:35:52,160
touched

877
00:35:52,160 --> 00:35:55,520
uh some of the issues about uh

878
00:35:55,520 --> 00:35:58,160
securely and safely testing for http

879
00:35:58,160 --> 00:36:00,079
requests smuggling but

880
00:36:00,079 --> 00:36:03,680
obviously it's uh it's non-trivial so

881
00:36:03,680 --> 00:36:06,240
the network the net answer or the the

882
00:36:06,240 --> 00:36:07,040
bottom line

883
00:36:07,040 --> 00:36:10,000
uh with respect to this question from at

884
00:36:10,000 --> 00:36:10,720
least

885
00:36:10,720 --> 00:36:13,920
from what i know is that some automatic

886
00:36:13,920 --> 00:36:16,240
application scanners do test for it

887
00:36:16,240 --> 00:36:18,880
but there are in some inherent problems

888
00:36:18,880 --> 00:36:19,680
in

889
00:36:19,680 --> 00:36:23,359
automatic and large-scale testing

890
00:36:23,359 --> 00:36:26,400
uh that perhaps prevent a

891
00:36:26,400 --> 00:36:30,079
large scale and and and and

892
00:36:30,079 --> 00:36:34,560
and intensive fuzzing

893
00:36:34,560 --> 00:36:36,960
around this uh around http request

894
00:36:36,960 --> 00:36:38,320
smuggling

895
00:36:38,320 --> 00:36:40,079
okay and i see that there is now another

896
00:36:40,079 --> 00:36:41,839
question

897
00:36:41,839 --> 00:36:44,078
uh

898
00:36:49,599 --> 00:36:53,040
right so okay i got an excellent

899
00:36:53,040 --> 00:36:54,960
question here when you showed the

900
00:36:54,960 --> 00:36:57,760
poisoned page and on the demo uh it

901
00:36:57,760 --> 00:36:59,359
looked like an attacker injected it

902
00:36:59,359 --> 00:37:00,000
there

903
00:37:00,000 --> 00:37:03,280
i missed the beginning and you

904
00:37:03,280 --> 00:37:05,839
but the the question says you can only

905
00:37:05,839 --> 00:37:08,000
use the http request modeling to access

906
00:37:08,000 --> 00:37:10,400
pages already on the web server right

907
00:37:10,400 --> 00:37:12,400
not for an attacker to introduce new

908
00:37:12,400 --> 00:37:13,359
content

909
00:37:13,359 --> 00:37:16,640
absolutely or you're 100 correct

910
00:37:16,640 --> 00:37:20,160
um but think about it this way

911
00:37:20,160 --> 00:37:22,800
an attacker can still save on on some

912
00:37:22,800 --> 00:37:23,960
sides there are

913
00:37:23,960 --> 00:37:28,000
attacker-controlled content like uh

914
00:37:28,000 --> 00:37:31,119
comments or blogs or or

915
00:37:31,119 --> 00:37:34,320
or personal areas in the website which

916
00:37:34,320 --> 00:37:35,520
the attacker

917
00:37:35,520 --> 00:37:40,079
has a lot of control over uh

918
00:37:40,079 --> 00:37:43,680
and also think about this about this say

919
00:37:43,680 --> 00:37:46,800
let's say that there's a hot

920
00:37:46,800 --> 00:37:51,920
news about some uh i don't know kovit 19

921
00:37:51,920 --> 00:37:56,720
vaccine being tested by by company xyz

922
00:37:56,720 --> 00:38:00,160
uh and then you you uh

923
00:38:00,160 --> 00:38:03,200
replace quote unquote or make this a to

924
00:38:03,200 --> 00:38:04,640
make the url

925
00:38:04,640 --> 00:38:06,800
be cached with the content about the

926
00:38:06,800 --> 00:38:08,240
same company having

927
00:38:08,240 --> 00:38:11,280
an earlier

928
00:38:11,280 --> 00:38:14,560
vaccine variant shown

929
00:38:14,560 --> 00:38:18,480
ineffective and that can that can have

930
00:38:18,480 --> 00:38:21,119
impact on on that company and on the on

931
00:38:21,119 --> 00:38:23,520
the share price of that company

932
00:38:23,520 --> 00:38:27,359
and so what i'm saying is even if

933
00:38:27,359 --> 00:38:30,560
the attacker cannot uh

934
00:38:30,560 --> 00:38:33,280
have his or her own page on the website

935
00:38:33,280 --> 00:38:34,560
so that the

936
00:38:34,560 --> 00:38:38,000
url uh the cached url uh

937
00:38:38,000 --> 00:38:41,119
is uh is cached together of the content

938
00:38:41,119 --> 00:38:42,800
from the attacker's controlled

939
00:38:42,800 --> 00:38:46,079
page the attacker can still uh

940
00:38:46,079 --> 00:38:49,839
incur a lot of damage by having one url

941
00:38:49,839 --> 00:38:50,880
caching the pay

942
00:38:50,880 --> 00:38:53,359
the content from another page which is

943
00:38:53,359 --> 00:38:55,359
not intended for that url

944
00:38:55,359 --> 00:38:58,320
so um so yes but technically you're

945
00:38:58,320 --> 00:38:59,440
absolutely right

946
00:38:59,440 --> 00:39:02,480
you can only do this attack with

947
00:39:02,480 --> 00:39:05,119
a page with a poison page that is

948
00:39:05,119 --> 00:39:06,560
already on the website

949
00:39:06,560 --> 00:39:15,839
absolutely right

950
00:39:18,320 --> 00:39:20,640
actually i don't see any further

951
00:39:20,640 --> 00:39:24,160
questions right now

952
00:39:26,839 --> 00:39:29,839
okay

953
00:39:37,359 --> 00:39:39,920
all right there's another question here

954
00:39:39,920 --> 00:39:43,920
but i think that we can just uh

955
00:39:44,160 --> 00:39:47,119
now so there's a question here sorry

956
00:39:47,119 --> 00:39:48,400
there's a question here about the

957
00:39:48,400 --> 00:39:49,119
variance

958
00:39:49,119 --> 00:39:53,440
uh i demonstrated the attack against uh

959
00:39:53,440 --> 00:39:55,440
the testing against proxies the wasps

960
00:39:55,440 --> 00:39:57,359
built in-house no the attacks were

961
00:39:57,359 --> 00:39:59,599
against a combination of

962
00:39:59,599 --> 00:40:01,680
common off-the-shelf two common

963
00:40:01,680 --> 00:40:03,440
off-the-shelf pieces of software

964
00:40:03,440 --> 00:40:06,160
one is the squid proxy and another one

965
00:40:06,160 --> 00:40:07,200
is at the abyss

966
00:40:07,200 --> 00:40:10,400
x1 server

967
00:40:10,400 --> 00:40:13,440
could http poisoning work

968
00:40:13,440 --> 00:40:16,319
in tandem with a url redirect attack to

969
00:40:16,319 --> 00:40:17,760
another site

970
00:40:17,760 --> 00:40:21,520
i guess the answer to that is

971
00:40:21,520 --> 00:40:25,200
no because the the attacker we are

972
00:40:25,200 --> 00:40:28,480
talking about here about http

973
00:40:28,480 --> 00:40:31,359
requests that are generated by the

974
00:40:31,359 --> 00:40:32,240
attacker

975
00:40:32,240 --> 00:40:35,119
if there's a redirect in the website i

976
00:40:35,119 --> 00:40:37,200
don't think it affects the attack it

977
00:40:37,200 --> 00:40:39,280
only redirect works at the

978
00:40:39,280 --> 00:40:41,040
browser level and we are talking here

979
00:40:41,040 --> 00:40:42,400
about http level

980
00:40:42,400 --> 00:40:45,839
so it's a bit a bit more raw if you if

981
00:40:45,839 --> 00:40:47,200
you get my meaning

982
00:40:47,200 --> 00:40:50,400
uh how do you see the light weight

983
00:40:50,400 --> 00:40:52,000
implementation of your suggested

984
00:40:52,000 --> 00:40:55,200
fixes with hooks on large-scale proxy

985
00:40:55,200 --> 00:40:57,520
networks like cds excellent questions

986
00:40:57,520 --> 00:40:59,280
obviously cdns are not going to

987
00:40:59,280 --> 00:41:01,760
incorporate my code this was more like

988
00:41:01,760 --> 00:41:05,599
a wake-up call for vendors and security

989
00:41:05,599 --> 00:41:06,800
vendors

990
00:41:06,800 --> 00:41:09,920
to show them that http request smuggling

991
00:41:09,920 --> 00:41:13,040
protection is possible and i think the

992
00:41:13,040 --> 00:41:14,000
way to do it

993
00:41:14,000 --> 00:41:17,040
is by focusing on http request smuggling

994
00:41:17,040 --> 00:41:19,760
and providing a excellent security

995
00:41:19,760 --> 00:41:21,680
specifically against this attack

996
00:41:21,680 --> 00:41:24,160
instead of trying a catch-all solution

997
00:41:24,160 --> 00:41:25,200
like uh

998
00:41:25,200 --> 00:41:27,839
application firewall which which has its

999
00:41:27,839 --> 00:41:30,319
problems and and has its drawbacks now

1000
00:41:30,319 --> 00:41:31,920
i'm not saying this is not a useful

1001
00:41:31,920 --> 00:41:33,040
product but

1002
00:41:33,040 --> 00:41:35,040
obviously it's more difficult to deploy

1003
00:41:35,040 --> 00:41:37,440
than a point solution against

1004
00:41:37,440 --> 00:41:40,800
http request smuggling

1005
00:41:41,440 --> 00:41:44,640
um let's see

1006
00:41:44,640 --> 00:41:49,119
anything else

1007
00:41:49,119 --> 00:41:53,599
okay where can you find the content of

1008
00:41:53,599 --> 00:41:54,640
your test scripts

1009
00:41:54,640 --> 00:41:59,200
it i shared the url in the chat room uh

1010
00:41:59,200 --> 00:42:02,319
early in my presentation uh so

1011
00:42:02,319 --> 00:42:04,800
and there's a it will be of course uh in

1012
00:42:04,800 --> 00:42:06,480
a link in my white paper

1013
00:42:06,480 --> 00:42:10,160
that will be published tonight

1014
00:42:13,680 --> 00:42:16,480
all right now i think i think we are

1015
00:42:16,480 --> 00:42:18,079
done here and you can

1016
00:42:18,079 --> 00:42:20,720
contact me directly for if you have

1017
00:42:20,720 --> 00:42:23,759
additional questions

1018
00:42:24,240 --> 00:42:27,280
thank you very much it was a pleasure uh

1019
00:42:27,280 --> 00:42:29,280
providing giving you this presentation

1020
00:42:29,280 --> 00:42:30,880
in blackhead

1021
00:42:30,880 --> 00:42:36,960
and answering your questions thank you

