1
00:00:04,180 --> 00:00:17,720
[Music]

2
00:00:18,080 --> 00:00:19,840
so this talk is about demigod

3
00:00:19,840 --> 00:00:22,080
a new tool that allows you to analyze

4
00:00:22,080 --> 00:00:23,279
kernel rookies

5
00:00:23,279 --> 00:00:26,400
in shockwave emulators

6
00:00:26,560 --> 00:00:29,359
so this project was done by a team of

7
00:00:29,359 --> 00:00:30,240
three people

8
00:00:30,240 --> 00:00:32,800
my name is whitney quinn i'm working in

9
00:00:32,800 --> 00:00:33,680
nan yang

10
00:00:33,680 --> 00:00:36,719
technological university of singapore i

11
00:00:36,719 --> 00:00:37,120
have

12
00:00:37,120 --> 00:00:39,680
many interests that include operating

13
00:00:39,680 --> 00:00:40,480
system

14
00:00:40,480 --> 00:00:43,840
virtualization and binary

15
00:00:43,840 --> 00:00:46,320
and i'm the founder and maintainer of

16
00:00:46,320 --> 00:00:48,559
few open source reversing frameworks

17
00:00:48,559 --> 00:00:50,480
like capstone disassembler

18
00:00:50,480 --> 00:00:55,360
unicorn emulator and keystone assembler

19
00:00:55,360 --> 00:00:57,280
the next team member is win hong kong

20
00:00:57,280 --> 00:00:59,520
he's a researcher at retail cyber

21
00:00:59,520 --> 00:01:00,640
security

22
00:01:00,640 --> 00:01:02,640
he has some interest in fasting and

23
00:01:02,640 --> 00:01:05,358
exploitation

24
00:01:05,680 --> 00:01:09,760
the last team member is domington he's a

25
00:01:09,760 --> 00:01:12,640
security researcher of science tech and

26
00:01:12,640 --> 00:01:15,680
he has interest in fasting and exploits

27
00:01:15,680 --> 00:01:19,759
don is a member of a ctf team named baby

28
00:01:19,759 --> 00:01:20,799
phd

29
00:01:20,799 --> 00:01:23,360
and he made some presentation at

30
00:01:23,360 --> 00:01:24,560
blackhead usa

31
00:01:24,560 --> 00:01:28,320
asia d2 and xcon

32
00:01:28,400 --> 00:01:31,520
so in this talk we will look into the

33
00:01:31,520 --> 00:01:32,640
background

34
00:01:32,640 --> 00:01:36,079
and we present the motivation of this

35
00:01:36,079 --> 00:01:38,479
demigod works and after that we

36
00:01:38,479 --> 00:01:40,400
introduce how we design

37
00:01:40,400 --> 00:01:43,680
how we implemented demigod and

38
00:01:43,680 --> 00:01:47,439
how demigod can emulate kernel rootkits

39
00:01:47,439 --> 00:01:49,920
for different platforms which is windows

40
00:01:49,920 --> 00:01:53,200
mac os and linux we have few demos

41
00:01:53,200 --> 00:01:56,960
in our talks and finally

42
00:01:56,960 --> 00:01:59,600
we introduce some more exciting

43
00:01:59,600 --> 00:02:00,719
applications that

44
00:02:00,719 --> 00:02:04,640
you can build on top of this framework

45
00:02:05,439 --> 00:02:06,880
okay first we look at the background and

46
00:02:06,880 --> 00:02:10,160
motivation of demigod

47
00:02:10,160 --> 00:02:12,319
okay gonna look it we know that computer

48
00:02:12,319 --> 00:02:13,680
system consists of two

49
00:02:13,680 --> 00:02:17,520
main areas with different privileges

50
00:02:17,520 --> 00:02:20,400
first one is user lan which is ring3 in

51
00:02:20,400 --> 00:02:21,680
x86

52
00:02:21,680 --> 00:02:23,440
the second one is os content which is

53
00:02:23,440 --> 00:02:25,280
green 0. so

54
00:02:25,280 --> 00:02:28,400
canon function at the lowest level is a

55
00:02:28,400 --> 00:02:29,599
system

56
00:02:29,599 --> 00:02:31,680
which has a full control on the whole

57
00:02:31,680 --> 00:02:32,720
system

58
00:02:32,720 --> 00:02:34,560
and the malware running inside the

59
00:02:34,560 --> 00:02:37,040
kernel is called kernel root case

60
00:02:37,040 --> 00:02:39,840
and because conor rooked function at the

61
00:02:39,840 --> 00:02:41,360
same level with the kernel

62
00:02:41,360 --> 00:02:44,160
it has a full power so it can defeat all

63
00:02:44,160 --> 00:02:46,720
the monitoring and defensive mechanism

64
00:02:46,720 --> 00:02:49,599
in the system kernel rookies are very

65
00:02:49,599 --> 00:02:51,040
hard to detect and kill

66
00:02:51,040 --> 00:02:53,200
because it can have many chicks to eat

67
00:02:53,200 --> 00:02:54,319
vegetation

68
00:02:54,319 --> 00:02:58,840
or you can even queue or fool any

69
00:02:58,840 --> 00:03:00,560
anti-malware

70
00:03:00,560 --> 00:03:04,560
tones so when

71
00:03:04,560 --> 00:03:06,480
people build the kernel rookies they try

72
00:03:06,480 --> 00:03:08,800
to make it highly compatible

73
00:03:08,800 --> 00:03:11,360
easy to build and easy to maintain so

74
00:03:11,360 --> 00:03:12,159
that's why

75
00:03:12,159 --> 00:03:14,640
most kernel rookies come in the form of

76
00:03:14,640 --> 00:03:16,800
kernel maroons or kernel drivers

77
00:03:16,800 --> 00:03:19,840
which is doses files on windows

78
00:03:19,840 --> 00:03:23,280
dot qx files on mac os or dot ko file on

79
00:03:23,280 --> 00:03:25,680
linux

80
00:03:26,640 --> 00:03:28,720
ok so we want to analyze control quiz

81
00:03:28,720 --> 00:03:32,319
which is not easy at all

82
00:03:32,319 --> 00:03:35,840
we set a target that we want to analyze

83
00:03:35,840 --> 00:03:37,840
kernel rookie coming to some forms

84
00:03:37,840 --> 00:03:38,799
binary forms

85
00:03:38,799 --> 00:03:43,200
which is which means we need to analyze

86
00:03:43,200 --> 00:03:46,720
the sys files or text files or ko files

87
00:03:46,720 --> 00:03:49,280
depending on the platforms

88
00:03:49,280 --> 00:03:52,640
so there are two ways to analyze current

89
00:03:52,640 --> 00:03:54,879
rookies coming in the form of kernel

90
00:03:54,879 --> 00:03:56,239
drivers

91
00:03:56,239 --> 00:03:59,519
first way is that we can use dynamic

92
00:03:59,519 --> 00:04:00,319
analysis

93
00:04:00,319 --> 00:04:04,640
techniques but this way is pretty

94
00:04:04,640 --> 00:04:08,480
troubling nowadays to analyze kernel

95
00:04:08,480 --> 00:04:10,959
root kit

96
00:04:11,120 --> 00:04:13,680
using dynamic analysis techniques we

97
00:04:13,680 --> 00:04:15,040
need two machines

98
00:04:15,040 --> 00:04:17,600
which can be a physical machine or

99
00:04:17,600 --> 00:04:18,639
virtual machines

100
00:04:18,639 --> 00:04:21,759
so we run one rootkit on one machine and

101
00:04:21,759 --> 00:04:22,240
we

102
00:04:22,240 --> 00:04:26,080
run our analysis tune on another machine

103
00:04:26,080 --> 00:04:28,479
and also on the on the second machine

104
00:04:28,479 --> 00:04:30,960
you can run some debugger connect to the

105
00:04:30,960 --> 00:04:34,240
machine that running rookies the problem

106
00:04:34,240 --> 00:04:35,040
with this

107
00:04:35,040 --> 00:04:37,680
solution is that when you analyze the

108
00:04:37,680 --> 00:04:38,880
kernel kit

109
00:04:38,880 --> 00:04:42,960
the kernel rootkit can crash a machine

110
00:04:42,960 --> 00:04:45,680
and because konoroki functions as a very

111
00:04:45,680 --> 00:04:47,040
low level in the system

112
00:04:47,040 --> 00:04:51,120
we have very low visibility on the

113
00:04:51,120 --> 00:04:53,840
activities of the kernel rookies and

114
00:04:53,840 --> 00:04:55,120
finally

115
00:04:55,120 --> 00:04:58,479
most of the analysis stones for malware

116
00:04:58,479 --> 00:05:00,560
are built for easterland but not for the

117
00:05:00,560 --> 00:05:02,479
kernel goodnight good

118
00:05:02,479 --> 00:05:05,600
so in fact we have very few tools that

119
00:05:05,600 --> 00:05:08,880
can analyze kernel rookies nowadays

120
00:05:08,880 --> 00:05:11,039
the second approach is starting analysis

121
00:05:11,039 --> 00:05:12,000
which

122
00:05:12,000 --> 00:05:15,520
is that you put your kernel rookie files

123
00:05:15,520 --> 00:05:17,759
into some analysis tools like idi pro

124
00:05:17,759 --> 00:05:21,120
or binary ninja or whatever

125
00:05:21,120 --> 00:05:24,720
however amazing can locate in static

126
00:05:24,720 --> 00:05:28,720
analysis while assist is also very short

127
00:05:28,720 --> 00:05:30,080
on some

128
00:05:30,080 --> 00:05:32,639
first upon kernel rookie can be packed

129
00:05:32,639 --> 00:05:33,840
and in that case

130
00:05:33,840 --> 00:05:36,880
an assistant starting assistant cannot

131
00:05:36,880 --> 00:05:39,199
recognize them

132
00:05:39,199 --> 00:05:41,759
and actually kernel rookie function

133
00:05:41,759 --> 00:05:43,120
depends on the

134
00:05:43,120 --> 00:05:47,199
kernel settings and most of the time

135
00:05:47,199 --> 00:05:49,199
kernel drivers do not have the settings

136
00:05:49,199 --> 00:05:50,960
so

137
00:05:50,960 --> 00:05:54,560
static analysis stones cannot decode and

138
00:05:54,560 --> 00:05:56,160
recognize

139
00:05:56,160 --> 00:05:59,199
the kernel rookie very well and in fact

140
00:05:59,199 --> 00:06:01,280
we tried many

141
00:06:01,280 --> 00:06:04,720
many static assistant on

142
00:06:04,720 --> 00:06:07,360
kernel rookies and most of them have

143
00:06:07,360 --> 00:06:08,720
many issues with missing

144
00:06:08,720 --> 00:06:12,080
api recognizing wrongly the kernel

145
00:06:12,080 --> 00:06:13,039
structure and

146
00:06:13,039 --> 00:06:15,520
so on

147
00:06:16,080 --> 00:06:18,319
so we think that we need a better tools

148
00:06:18,319 --> 00:06:20,720
for kernel rookies

149
00:06:20,720 --> 00:06:24,080
what if we can analyze

150
00:06:24,080 --> 00:06:27,840
kernel rootkit from userland

151
00:06:27,840 --> 00:06:31,360
in that case we do not have kernel

152
00:06:31,360 --> 00:06:33,199
we do not have a machine class issue

153
00:06:33,199 --> 00:06:35,520
anymore we do not need to set up

154
00:06:35,520 --> 00:06:36,479
separate machine

155
00:06:36,479 --> 00:06:39,120
for analyzing kernel rookies because

156
00:06:39,120 --> 00:06:41,840
because everything is in ring tree

157
00:06:41,840 --> 00:06:44,240
and we do not have much risk with

158
00:06:44,240 --> 00:06:47,280
current level malware

159
00:06:47,280 --> 00:06:50,240
and if everything is in ring tree you

160
00:06:50,240 --> 00:06:52,400
have very good visibility in the current

161
00:06:52,400 --> 00:06:53,440
activities in the

162
00:06:53,440 --> 00:06:56,080
into the activities of kernel rookies

163
00:06:56,080 --> 00:06:58,479
and we can reuse many existing tones

164
00:06:58,479 --> 00:07:03,840
to analyze kernel requests in ringtree

165
00:07:04,240 --> 00:07:07,199
we also want to analyze gun requests in

166
00:07:07,199 --> 00:07:08,639
cross platform and close

167
00:07:08,639 --> 00:07:11,440
architecture way sometimes first of all

168
00:07:11,440 --> 00:07:13,599
it would be very nice if you can analyze

169
00:07:13,599 --> 00:07:16,639
windows kernel rookies on linux and

170
00:07:16,639 --> 00:07:20,000
vice versa we can analyze a

171
00:07:20,000 --> 00:07:21,919
linux kernel kit on windows that would

172
00:07:21,919 --> 00:07:24,960
be even better

173
00:07:24,960 --> 00:07:27,919
and we also want to analyze the first

174
00:07:27,919 --> 00:07:28,639
point

175
00:07:28,639 --> 00:07:32,479
i am gonna rookies on acoustic machine

176
00:07:32,479 --> 00:07:34,720
and if you can do that which is very

177
00:07:34,720 --> 00:07:36,319
nice

178
00:07:36,319 --> 00:07:39,360
and finally a better tune for kernel

179
00:07:39,360 --> 00:07:40,720
requests would allow

180
00:07:40,720 --> 00:07:44,000
us to view

181
00:07:44,000 --> 00:07:48,479
more and better advanced analysis tune

182
00:07:48,479 --> 00:07:51,520
and would be nice if we can build

183
00:07:51,520 --> 00:07:53,840
our

184
00:07:55,360 --> 00:07:58,800
next advanced analysis tool in

185
00:07:58,800 --> 00:08:02,560
high level language like python

186
00:08:03,199 --> 00:08:06,639
so we consider many approach

187
00:08:06,639 --> 00:08:10,479
and we choose emulator approach

188
00:08:10,479 --> 00:08:12,960
so the idea is that we want to emulate a

189
00:08:12,960 --> 00:08:13,680
west kernel

190
00:08:13,680 --> 00:08:17,360
software so we can run

191
00:08:17,360 --> 00:08:19,919
kernel drivers kernel rookies in

192
00:08:19,919 --> 00:08:20,879
emulator mode

193
00:08:20,879 --> 00:08:23,919
in the emulators and because emulator

194
00:08:23,919 --> 00:08:25,039
run in

195
00:08:25,039 --> 00:08:28,080
ring tree so if we can emulate the

196
00:08:28,080 --> 00:08:28,960
kernel rookies

197
00:08:28,960 --> 00:08:32,880
inside the emulator we do not have colon

198
00:08:32,880 --> 00:08:35,200
we do not have a machine class anymore

199
00:08:35,200 --> 00:08:37,039
we don't have issue with setting up

200
00:08:37,039 --> 00:08:39,120
separate machine or virtual machine to

201
00:08:39,120 --> 00:08:41,039
analyze kernel rookies

202
00:08:41,039 --> 00:08:44,000
and we don't have reach with the

203
00:08:44,000 --> 00:08:44,880
analyzing kernel

204
00:08:44,880 --> 00:08:48,000
rookies because we emulate everything in

205
00:08:48,000 --> 00:08:50,640
in the safety sandbox and we can reuse

206
00:08:50,640 --> 00:08:51,040
many

207
00:08:51,040 --> 00:08:54,160
existing tools

208
00:08:54,160 --> 00:08:56,640
if you can analyze kernel rookies inside

209
00:08:56,640 --> 00:09:00,000
emulators you have excellent visibility

210
00:09:00,000 --> 00:09:02,080
because you can see on the execution

211
00:09:02,080 --> 00:09:04,880
code and you can instrument at

212
00:09:04,880 --> 00:09:08,959
virus level

213
00:09:08,959 --> 00:09:11,279
finally if you can use some close

214
00:09:11,279 --> 00:09:13,839
platform and cross architecture emulator

215
00:09:13,839 --> 00:09:15,839
then you can do cross platform

216
00:09:15,839 --> 00:09:17,360
architecture analysis on the kernel

217
00:09:17,360 --> 00:09:18,720
rookies

218
00:09:18,720 --> 00:09:21,440
and in the case if the emulator is used

219
00:09:21,440 --> 00:09:22,000
in

220
00:09:22,000 --> 00:09:25,200
like higher level language like python

221
00:09:25,200 --> 00:09:28,560
then you can easily build our own tones

222
00:09:28,560 --> 00:09:30,640
to analyze many kernel rookies

223
00:09:30,640 --> 00:09:33,600
easily and quickly

224
00:09:34,959 --> 00:09:36,720
okay in the next session we introduce

225
00:09:36,720 --> 00:09:39,200
how how we design and how we

226
00:09:39,200 --> 00:09:42,399
implemented demigod

227
00:09:43,120 --> 00:09:46,240
so let's look at an

228
00:09:46,240 --> 00:09:48,480
existing emulator which is very close to

229
00:09:48,480 --> 00:09:49,680
what we

230
00:09:49,680 --> 00:09:52,240
are looking for we are talking about

231
00:09:52,240 --> 00:09:53,600
chilling emulator

232
00:09:53,600 --> 00:09:56,640
which is open source emulator it support

233
00:09:56,640 --> 00:09:58,160
multiple

234
00:09:58,160 --> 00:10:00,959
operating system so chilling can emulate

235
00:10:00,959 --> 00:10:01,680
windows

236
00:10:01,680 --> 00:10:05,360
macos linux it supports multiple cpu

237
00:10:05,360 --> 00:10:06,240
architectures

238
00:10:06,240 --> 00:10:09,519
so it can handle binary code from

239
00:10:09,519 --> 00:10:13,760
x statistic m m64 and mips

240
00:10:13,760 --> 00:10:16,959
it's between python open source and it

241
00:10:16,959 --> 00:10:19,200
allows you to instrument perform

242
00:10:19,200 --> 00:10:21,680
instrumentation at virus levels

243
00:10:21,680 --> 00:10:26,000
at basic block at injection level

244
00:10:26,000 --> 00:10:28,079
you can also instrument memory accent

245
00:10:28,079 --> 00:10:30,560
and so on

246
00:10:31,120 --> 00:10:35,600
chilling has one very good

247
00:10:35,600 --> 00:10:39,200
debugger viewing which is compatible

248
00:10:39,200 --> 00:10:40,320
with gdp docker

249
00:10:40,320 --> 00:10:44,880
so you can connect many

250
00:10:44,880 --> 00:10:48,480
debugger to the emulator to debug uh

251
00:10:48,480 --> 00:10:51,040
emulate the code running inside and

252
00:10:51,040 --> 00:10:53,440
inside shielding

253
00:10:53,440 --> 00:10:56,160
however the issue with chilling is that

254
00:10:56,160 --> 00:10:57,760
we want to

255
00:10:57,760 --> 00:11:00,720
emulate kernel rookies but chilling is

256
00:11:00,720 --> 00:11:01,519
not built

257
00:11:01,519 --> 00:11:04,000
to handle current code at all it can

258
00:11:04,000 --> 00:11:07,760
only emulate easily encode

259
00:11:07,760 --> 00:11:11,040
so because the loader for conor

260
00:11:11,040 --> 00:11:13,279
maroon is very different from the loader

261
00:11:13,279 --> 00:11:15,120
for user lan binaries

262
00:11:15,120 --> 00:11:18,480
chilling cannot handle content drivers

263
00:11:18,480 --> 00:11:19,839
at all

264
00:11:19,839 --> 00:11:23,360
chilling is not made to emulate kernel

265
00:11:23,360 --> 00:11:24,560
components

266
00:11:24,560 --> 00:11:28,000
kernel apis and the scheme

267
00:11:28,000 --> 00:11:29,839
of chilling is quite different it's

268
00:11:29,839 --> 00:11:31,120
built to

269
00:11:31,120 --> 00:11:33,519
run the easterland code from beginning

270
00:11:33,519 --> 00:11:34,320
to end

271
00:11:34,320 --> 00:11:37,680
but kernel module function differently

272
00:11:37,680 --> 00:11:40,800
we need to load the colon module into

273
00:11:40,800 --> 00:11:42,000
the emulator first

274
00:11:42,000 --> 00:11:45,279
and let it initialize and after that

275
00:11:45,279 --> 00:11:48,800
depending on the user input

276
00:11:48,800 --> 00:11:52,000
gonna rootkit will run different code

277
00:11:52,000 --> 00:11:53,279
part depend on the

278
00:11:53,279 --> 00:11:56,240
depending on the input so it's the

279
00:11:56,240 --> 00:11:57,200
scheme of

280
00:11:57,200 --> 00:11:59,760
emulating the kernel uh driver is quite

281
00:11:59,760 --> 00:12:01,920
different zone from the emulating the

282
00:12:01,920 --> 00:12:04,560
user encode

283
00:12:05,279 --> 00:12:08,639
so the idea is that we fork

284
00:12:08,639 --> 00:12:11,040
chilling emitter and we build demigod on

285
00:12:11,040 --> 00:12:12,720
top of chilling

286
00:12:12,720 --> 00:12:16,560
because of that we can reuse many

287
00:12:16,720 --> 00:12:20,079
existing nice features of shielding

288
00:12:20,079 --> 00:12:22,560
so we can reuse a lot of chilling with

289
00:12:22,560 --> 00:12:24,000
lithium modification

290
00:12:24,000 --> 00:12:27,920
you can reuse simple relocation you can

291
00:12:27,920 --> 00:12:30,079
reuse imported function functionalities

292
00:12:30,079 --> 00:12:31,600
inside the chilling

293
00:12:31,600 --> 00:12:34,959
loaders but you had

294
00:12:34,959 --> 00:12:39,040
you need to view many of our own tones

295
00:12:39,040 --> 00:12:42,399
because chilean do not have those

296
00:12:42,399 --> 00:12:45,279
features first of all we need to emulate

297
00:12:45,279 --> 00:12:47,680
the kernel components our shell

298
00:12:47,680 --> 00:12:50,399
demi god also need to emulate current

299
00:12:50,399 --> 00:12:51,440
apis

300
00:12:51,440 --> 00:12:54,560
by hooking and emulating the emulate on

301
00:12:54,560 --> 00:12:55,279
the current

302
00:12:55,279 --> 00:13:00,320
api semantics and

303
00:13:00,639 --> 00:13:04,959
we also had to do our own

304
00:13:04,959 --> 00:13:09,279
instrumentation for the colon

305
00:13:09,839 --> 00:13:11,680
rookies to work we need to hook and

306
00:13:11,680 --> 00:13:15,120
emulate system kernel api

307
00:13:15,120 --> 00:13:18,880
and for debugging

308
00:13:18,880 --> 00:13:21,360
this is good because you can reuse the

309
00:13:21,360 --> 00:13:22,320
existing

310
00:13:22,320 --> 00:13:25,519
zdb server between inside chilling so

311
00:13:25,519 --> 00:13:26,240
then you got

312
00:13:26,240 --> 00:13:29,360
can independence gdp server

313
00:13:29,360 --> 00:13:32,480
when you emulate the kernel rookies so

314
00:13:32,480 --> 00:13:33,519
we can debug

315
00:13:33,519 --> 00:13:35,360
the kernel rookies running inside the

316
00:13:35,360 --> 00:13:37,760
chilling

317
00:13:39,600 --> 00:13:42,079
so here i want to emphasize one thing

318
00:13:42,079 --> 00:13:42,880
that

319
00:13:42,880 --> 00:13:44,560
makes demigods different from the

320
00:13:44,560 --> 00:13:46,560
chilling the easterline core is

321
00:13:46,560 --> 00:13:49,600
typically only one phase emulation

322
00:13:49,600 --> 00:13:52,320
zit is what shielding does but for

323
00:13:52,320 --> 00:13:53,760
demigod we need to

324
00:13:53,760 --> 00:13:57,440
emulate the kernel rookies in two phase

325
00:13:57,440 --> 00:13:59,920
first we need to load the kernel driver

326
00:13:59,920 --> 00:14:01,199
first

327
00:14:01,199 --> 00:14:04,000
and after that the kernel the kernel

328
00:14:04,000 --> 00:14:05,279
drivers are going to locate

329
00:14:05,279 --> 00:14:09,040
start inside the demo emulator

330
00:14:09,040 --> 00:14:13,040
and wait for the request from users from

331
00:14:13,040 --> 00:14:15,040
the users

332
00:14:15,040 --> 00:14:17,199
so we have to emulate the driver and

333
00:14:17,199 --> 00:14:18,720
keys

334
00:14:18,720 --> 00:14:21,920
for that we need to locate ng to emulate

335
00:14:21,920 --> 00:14:24,000
so for windows we need to locate the

336
00:14:24,000 --> 00:14:25,440
driver ng inside the

337
00:14:25,440 --> 00:14:28,720
doses files for mac os we need to locate

338
00:14:28,720 --> 00:14:32,639
real main shipboard inside the dotx file

339
00:14:32,639 --> 00:14:36,000
for linux.kl files you need to locate

340
00:14:36,000 --> 00:14:40,240
model in it so after that we can

341
00:14:40,240 --> 00:14:42,480
start emulation from the library entry

342
00:14:42,480 --> 00:14:44,160
but reading during the

343
00:14:44,160 --> 00:14:47,839
this phase we need to

344
00:14:47,839 --> 00:14:52,160
monitor and extract on the code path

345
00:14:52,160 --> 00:14:55,680
that we can see when the kernel rookie

346
00:14:55,680 --> 00:14:58,399
was initialized so first of all you want

347
00:14:58,399 --> 00:14:58,720
to

348
00:14:58,720 --> 00:15:02,160
check out the the rootkit system cost

349
00:15:02,160 --> 00:15:03,920
because rokit can override some system

350
00:15:03,920 --> 00:15:04,639
code in

351
00:15:04,639 --> 00:15:07,760
inside the system we need to retrieve

352
00:15:07,760 --> 00:15:10,480
the i o control convex and many other

353
00:15:10,480 --> 00:15:14,160
contacts that depend on the platforms

354
00:15:14,800 --> 00:15:17,199
and the next phase the second phase that

355
00:15:17,199 --> 00:15:20,000
once we get on the

356
00:15:20,000 --> 00:15:22,240
going back on the code path that we want

357
00:15:22,240 --> 00:15:23,120
to

358
00:15:23,120 --> 00:15:26,160
explore we

359
00:15:26,160 --> 00:15:31,199
try to emulate the

360
00:15:31,920 --> 00:15:35,519
code path that users choose to

361
00:15:35,519 --> 00:15:39,360
explore so as this phase

362
00:15:39,360 --> 00:15:44,320
user can decide which code path

363
00:15:44,880 --> 00:15:49,920
they want to emulate and

364
00:15:50,160 --> 00:15:53,440
by doing that they choose input and send

365
00:15:53,440 --> 00:15:54,480
input to

366
00:15:54,480 --> 00:15:58,160
the z-score part and the record can

367
00:15:58,160 --> 00:16:01,360
emulate the cisco part with this input

368
00:16:01,360 --> 00:16:04,240
coming from users

369
00:16:05,040 --> 00:16:07,440
so building typical is very challenging

370
00:16:07,440 --> 00:16:09,360
because emulate kernel is very tough

371
00:16:09,360 --> 00:16:10,399
they have so many

372
00:16:10,399 --> 00:16:12,639
complex completed shockwave components

373
00:16:12,639 --> 00:16:14,480
inside the inside the kernel

374
00:16:14,480 --> 00:16:17,360
but we choose to limit our

375
00:16:17,360 --> 00:16:18,639
implementation

376
00:16:18,639 --> 00:16:22,000
we only emulate enough to make root kit

377
00:16:22,000 --> 00:16:24,320
works

378
00:16:25,199 --> 00:16:28,160
and building lotter for color river is

379
00:16:28,160 --> 00:16:29,360
also very hard

380
00:16:29,360 --> 00:16:31,440
because it's quite different from from

381
00:16:31,440 --> 00:16:34,839
chilling what shilling does

382
00:16:34,839 --> 00:16:38,639
and how to analyze initialized

383
00:16:38,639 --> 00:16:42,560
driver is also not easy not trivial

384
00:16:42,560 --> 00:16:46,160
and during the driver initialization we

385
00:16:46,160 --> 00:16:47,920
need to extract the code bus to be

386
00:16:47,920 --> 00:16:48,959
emulated

387
00:16:48,959 --> 00:16:51,759
and after that how to trigger the code

388
00:16:51,759 --> 00:16:52,720
part with

389
00:16:52,720 --> 00:16:55,839
properly formatted input from users is

390
00:16:55,839 --> 00:17:00,160
also another task we need to consider

391
00:17:00,399 --> 00:17:03,839
so in the next section we i hand over to

392
00:17:03,839 --> 00:17:05,119
mr quang who will

393
00:17:05,119 --> 00:17:08,160
introduce how we implement the

394
00:17:08,160 --> 00:17:09,119
implemented

395
00:17:09,119 --> 00:17:12,240
windows emulator for

396
00:17:12,240 --> 00:17:15,520
windows kernel rookies hello

397
00:17:15,520 --> 00:17:19,359
my name is juan today i will introduce

398
00:17:19,359 --> 00:17:19,919
about

399
00:17:19,919 --> 00:17:23,119
the bigger framework i use demigod to

400
00:17:23,119 --> 00:17:25,839
emulate window driver

401
00:17:25,839 --> 00:17:27,760
there are many things in windows kernel

402
00:17:27,760 --> 00:17:29,440
that we should conserve

403
00:17:29,440 --> 00:17:34,000
the more important thing is antioxidant

404
00:17:34,000 --> 00:17:36,320
so far is known as chrono image of

405
00:17:36,320 --> 00:17:38,640
microsoft window

406
00:17:38,640 --> 00:17:41,120
window cannot contain many components

407
00:17:41,120 --> 00:17:41,840
such as

408
00:17:41,840 --> 00:17:44,840
tech manager memory manager and

409
00:17:44,840 --> 00:17:46,240
scheduler

410
00:17:46,240 --> 00:17:48,400
to emulate windows driver we have to

411
00:17:48,400 --> 00:17:49,520
understand

412
00:17:49,520 --> 00:17:52,960
kernel structures kernel api functions

413
00:17:52,960 --> 00:17:54,720
and right code to copy

414
00:17:54,720 --> 00:17:58,960
or mimic the behaviors of window kernel

415
00:17:58,960 --> 00:18:01,600
i load driver module into emulator and

416
00:18:01,600 --> 00:18:02,400
start

417
00:18:02,400 --> 00:18:05,600
emulating from the entry point

418
00:18:05,600 --> 00:18:09,200
i also in human memory asset

419
00:18:09,200 --> 00:18:12,840
and code execution by using helping

420
00:18:12,840 --> 00:18:14,760
technique after

421
00:18:14,760 --> 00:18:17,840
initialization is complete

422
00:18:17,840 --> 00:18:20,559
i use io control code to communicate

423
00:18:20,559 --> 00:18:23,280
with driver

424
00:18:23,760 --> 00:18:26,880
every driver is a p5

425
00:18:26,880 --> 00:18:31,280
as a subsystem field optional header er

426
00:18:31,280 --> 00:18:34,799
1 so that i have to read the header

427
00:18:34,799 --> 00:18:37,440
file session then write them into memory

428
00:18:37,440 --> 00:18:39,280
of emulator

429
00:18:39,280 --> 00:18:42,720
i also load dependent library result

430
00:18:42,720 --> 00:18:46,000
in part and read table after that

431
00:18:46,000 --> 00:18:48,400
i check the location table to relocate

432
00:18:48,400 --> 00:18:50,400
every address

433
00:18:50,400 --> 00:18:52,880
the second step is setting up cpu

434
00:18:52,880 --> 00:18:54,320
contact

435
00:18:54,320 --> 00:18:57,280
we should set up stack pointer with pi

436
00:18:57,280 --> 00:19:00,480
to stack location

437
00:19:00,640 --> 00:19:04,080
i p point to entry point and control

438
00:19:04,080 --> 00:19:07,520
register some driver

439
00:19:07,520 --> 00:19:11,840
will not work if cr4s register and clf

440
00:19:11,840 --> 00:19:12,480
register

441
00:19:12,480 --> 00:19:16,799
are not set the third step

442
00:19:16,799 --> 00:19:20,799
is industrializing some important

443
00:19:20,799 --> 00:19:22,400
structures such as

444
00:19:22,400 --> 00:19:26,000
variable object e process

445
00:19:26,000 --> 00:19:28,480
and the last one i prepared for driver

446
00:19:28,480 --> 00:19:29,919
engine

447
00:19:29,919 --> 00:19:32,720
the first this is the first driver

448
00:19:32,720 --> 00:19:33,520
contact

449
00:19:33,520 --> 00:19:39,039
and is due to initialize the driver

450
00:19:39,039 --> 00:19:42,480
now i will introduce some internal

451
00:19:42,480 --> 00:19:44,320
structure

452
00:19:44,320 --> 00:19:47,919
the first one is driver object

453
00:19:47,919 --> 00:19:52,160
represents the emit of loaded driver i

454
00:19:52,160 --> 00:19:55,520
initialize some things such as ties

455
00:19:55,520 --> 00:20:00,080
side rib name and major function field

456
00:20:00,080 --> 00:20:03,120
e process represents a process

457
00:20:03,120 --> 00:20:06,240
object there are many

458
00:20:06,240 --> 00:20:08,799
hidden fields and just a look at a

459
00:20:08,799 --> 00:20:12,799
memory reason for this structure

460
00:20:13,200 --> 00:20:16,559
k user say data either that data

461
00:20:16,559 --> 00:20:18,000
structure

462
00:20:18,000 --> 00:20:21,360
is between user mode and kernel mode

463
00:20:21,360 --> 00:20:23,919
component

464
00:20:23,919 --> 00:20:27,039
irp structure represent

465
00:20:27,039 --> 00:20:30,480
an io request packet

466
00:20:30,480 --> 00:20:33,919
io stack location is an energy

467
00:20:33,919 --> 00:20:40,000
in io stack and associated with hrp

468
00:20:40,000 --> 00:20:43,200
mdl either structures associated memory

469
00:20:43,200 --> 00:20:48,240
data storage

470
00:20:48,240 --> 00:20:51,440
driver entry is the first function that

471
00:20:51,440 --> 00:20:52,320
you'll do

472
00:20:52,320 --> 00:20:55,840
in this client driver defense electron

473
00:20:55,840 --> 00:20:56,159
at

474
00:20:56,159 --> 00:20:59,600
energy point the first argument

475
00:20:59,600 --> 00:21:03,600
is the pointer to a driver object

476
00:21:03,600 --> 00:21:04,240
structure

477
00:21:04,240 --> 00:21:06,640
and the second one is a pointer to

478
00:21:06,640 --> 00:21:09,760
unicode string structure

479
00:21:09,760 --> 00:21:12,559
that specifies a path to drive a

480
00:21:12,559 --> 00:21:13,600
parameter key

481
00:21:13,600 --> 00:21:17,200
in registry i also

482
00:21:17,200 --> 00:21:20,720
write some hook api to mimic

483
00:21:20,720 --> 00:21:24,320
window api

484
00:21:25,840 --> 00:21:29,200
i implement hook function to emulate

485
00:21:29,200 --> 00:21:32,880
api and make everything work for example

486
00:21:32,880 --> 00:21:35,280
i will create device will create a fake

487
00:21:35,280 --> 00:21:36,799
object in memory

488
00:21:36,799 --> 00:21:40,080
of emulator to zpram device object

489
00:21:40,080 --> 00:21:43,280
i will complete the quest do nothing but

490
00:21:43,280 --> 00:21:43,840
lock

491
00:21:43,840 --> 00:21:47,280
on the parameter some memory

492
00:21:47,280 --> 00:21:51,280
management concerns such as a location

493
00:21:51,280 --> 00:21:54,080
egg free boom works similar as malloc

494
00:21:54,080 --> 00:21:59,840
and free

495
00:22:00,080 --> 00:22:02,880
after everything is ready user's pay

496
00:22:02,880 --> 00:22:04,880
program can communicate with driver

497
00:22:04,880 --> 00:22:08,400
via io control code or

498
00:22:08,400 --> 00:22:11,600
refi and wi-fi a great

499
00:22:11,600 --> 00:22:15,919
structure irp i o stack location in

500
00:22:15,919 --> 00:22:17,840
memory emulator

501
00:22:17,840 --> 00:22:21,440
i find a structure with appropriate

502
00:22:21,440 --> 00:22:24,159
data setup i will mess for combat

503
00:22:24,159 --> 00:22:25,280
function

504
00:22:25,280 --> 00:22:27,840
and i start emulating from the beginning

505
00:22:27,840 --> 00:22:29,360
function

506
00:22:29,360 --> 00:22:32,159
when everything is complete i did my

507
00:22:32,159 --> 00:22:34,240
written value and written data by

508
00:22:34,240 --> 00:22:35,440
reading

509
00:22:35,440 --> 00:22:38,480
irp structure from emulate

510
00:22:38,480 --> 00:22:41,840
from emulator memory

511
00:22:42,400 --> 00:22:44,640
there are three methods to communicate

512
00:22:44,640 --> 00:22:45,600
with driver

513
00:22:45,600 --> 00:22:48,480
the first method is buffer io so i

514
00:22:48,480 --> 00:22:50,240
create a large enough buffer

515
00:22:50,240 --> 00:22:54,000
in the side and right of z buffer to irb

516
00:22:54,000 --> 00:22:57,039
system buffer the second method is

517
00:22:57,039 --> 00:22:58,240
direct io

518
00:22:58,240 --> 00:23:01,520
i create a buffer to store data

519
00:23:01,520 --> 00:23:06,840
and create a mdl structure for this

520
00:23:06,840 --> 00:23:08,080
buffer

521
00:23:08,080 --> 00:23:11,760
and the last one neither i o

522
00:23:11,760 --> 00:23:14,880
i just set use a buffer fill

523
00:23:14,880 --> 00:23:18,240
a 5 rp structure part 2 card drive of

524
00:23:18,240 --> 00:23:22,000
this buffer

525
00:23:22,000 --> 00:23:25,039
i also pray to tone for reversal the

526
00:23:25,039 --> 00:23:26,320
first tone

527
00:23:26,320 --> 00:23:30,400
is a tune to attack candle mode packer

528
00:23:30,400 --> 00:23:32,880
and the second one is a tool to have

529
00:23:32,880 --> 00:23:33,840
when working with

530
00:23:33,840 --> 00:23:37,280
io control code

531
00:23:37,280 --> 00:23:40,640
now we want some demonstration

532
00:23:40,640 --> 00:23:44,240
the first demo i will debug

533
00:23:44,240 --> 00:23:51,840
a window driver

534
00:24:04,480 --> 00:24:08,559
you see here i am i enable debug mode by

535
00:24:08,559 --> 00:24:12,158
adding the following line

536
00:24:13,440 --> 00:24:16,559
and now i start

537
00:24:16,559 --> 00:24:19,840
to emulate driver

538
00:24:26,960 --> 00:24:30,240
there are driver objects registry

539
00:24:30,240 --> 00:24:36,960
ebola set and user data upgrade

540
00:24:43,600 --> 00:24:47,760
when everything is on driver is ready

541
00:24:47,760 --> 00:24:50,960
i use idi bro

542
00:24:50,960 --> 00:24:54,159
to connect to the partner

543
00:24:54,159 --> 00:24:56,960
999

544
00:24:58,720 --> 00:25:02,320
and after that i can use idea debugger

545
00:25:02,320 --> 00:25:02,640
to

546
00:25:02,640 --> 00:25:15,840
try every instruction

547
00:26:03,760 --> 00:26:06,640
and you can see

548
00:26:07,679 --> 00:26:12,880
this driver bring to consol hello

549
00:26:22,480 --> 00:26:25,840
and then

550
00:26:26,159 --> 00:26:29,919
the second demonstration i want to

551
00:26:29,919 --> 00:26:32,799
introduce about

552
00:26:33,919 --> 00:26:36,159
my

553
00:26:37,600 --> 00:26:41,760
it wife sality mangua

554
00:26:48,960 --> 00:26:51,760
you know sality is a polymorphic 5

555
00:26:51,760 --> 00:26:54,158
factor

556
00:26:54,960 --> 00:26:58,960
it communicates over a peer-to-peer

557
00:26:58,960 --> 00:26:59,600
network

558
00:26:59,600 --> 00:27:03,039
to form a botnet sanity

559
00:27:03,039 --> 00:27:07,039
use a rootkit to block

560
00:27:07,039 --> 00:27:12,158
connection and kill antiv root process

561
00:27:13,360 --> 00:27:16,799
i found a sample from verototo

562
00:27:16,799 --> 00:27:20,720
and i will debug block it from

563
00:27:20,720 --> 00:27:35,840
saturday my way

564
00:28:00,080 --> 00:28:02,960
i have searched and found a variable

565
00:28:02,960 --> 00:28:03,679
variant

566
00:28:03,679 --> 00:28:06,720
of website for beruto

567
00:28:06,720 --> 00:28:17,840
there are 64 and then the detective 5.

568
00:28:20,320 --> 00:28:23,520
at first i have to extract the main

569
00:28:23,520 --> 00:28:24,080
module

570
00:28:24,080 --> 00:28:28,640
from sanity so they use

571
00:28:28,640 --> 00:28:31,600
a simple tool to a checkpoint kit and

572
00:28:31,600 --> 00:28:32,559
load the kit

573
00:28:32,559 --> 00:28:35,360
into memory

574
00:28:38,640 --> 00:28:41,760
this is user mode module is a

575
00:28:41,760 --> 00:28:44,399
dynamic link library and i name it

576
00:28:44,399 --> 00:28:45,440
sality

577
00:28:45,440 --> 00:28:49,440
dot bin i use led

578
00:28:49,440 --> 00:28:52,559
extractor this is a script that i wrote

579
00:28:52,559 --> 00:28:55,678
from another research

580
00:28:57,120 --> 00:29:01,120
after damage of the url i am packed by

581
00:29:01,120 --> 00:29:05,918
using up

582
00:29:10,840 --> 00:29:13,840
nz

583
00:29:38,840 --> 00:29:41,840
so

584
00:30:06,960 --> 00:30:10,320
and then unlock this module

585
00:30:10,320 --> 00:30:23,840
into emulator

586
00:30:42,480 --> 00:30:45,360
and now you can see society sq inside

587
00:30:45,360 --> 00:30:48,000
emulator

588
00:30:48,399 --> 00:30:50,799
there are many there are too many

589
00:30:50,799 --> 00:30:52,399
interesting

590
00:30:52,399 --> 00:30:56,159
emulator speed will spend

591
00:30:56,159 --> 00:31:05,840
much time to execute

592
00:31:41,360 --> 00:31:45,120
now you see this is a sality

593
00:31:45,120 --> 00:31:49,360
my manufacturer service

594
00:31:50,480 --> 00:31:53,600
here is name and we have

595
00:31:53,600 --> 00:31:56,720
a service name and

596
00:31:56,720 --> 00:32:01,840
the binary part

597
00:32:02,960 --> 00:32:06,399
this blocky product of sighting

598
00:32:06,399 --> 00:32:09,519
i will use idi pro debugger

599
00:32:09,519 --> 00:32:15,840
to connect and debug it

600
00:32:35,840 --> 00:32:39,760
i can step every

601
00:32:40,840 --> 00:32:43,840
injustice

602
00:32:44,000 --> 00:32:47,600
so demand will communicate with driver

603
00:32:47,600 --> 00:32:57,840
by using wi-fi function

604
00:33:24,720 --> 00:33:27,840
and the rocket had to thread

605
00:33:27,840 --> 00:33:31,120
the first track in block

606
00:33:31,120 --> 00:33:34,159
on av all antivirus relay

607
00:33:34,159 --> 00:33:37,679
connection and the second one use

608
00:33:37,679 --> 00:33:40,880
to clear process

609
00:33:41,200 --> 00:33:44,320
i will separate by us this thread to

610
00:33:44,320 --> 00:33:53,840
debug player

611
00:34:18,320 --> 00:34:22,599
so i think will find

612
00:34:22,599 --> 00:34:25,760
anti-terminate process

613
00:34:25,760 --> 00:34:28,800
from user mode by using

614
00:34:28,800 --> 00:34:32,079
service decrypt table

615
00:34:32,079 --> 00:34:35,679
and send an array of

616
00:34:35,679 --> 00:34:49,839
advanced to karnaugh mode token module

617
00:35:00,839 --> 00:35:03,839
so

618
00:36:22,079 --> 00:36:25,920
here you see solitary q apple process

619
00:36:25,920 --> 00:36:28,800
with the number

620
00:36:30,000 --> 00:36:33,680
with our pid number

621
00:36:37,839 --> 00:36:41,839
so my demonstration and next

622
00:36:41,839 --> 00:36:45,119
mr don will talk about how they become

623
00:36:45,119 --> 00:36:47,040
work on map or essay

624
00:36:47,040 --> 00:36:50,480
thank you hello

625
00:36:50,480 --> 00:36:53,040
i'm don and i'm gonna talk about the

626
00:36:53,040 --> 00:36:54,320
mechanism of

627
00:36:54,320 --> 00:36:58,880
a demigod for mac os so the macos kernel

628
00:36:58,880 --> 00:37:02,079
is officially known as xnu

629
00:37:02,079 --> 00:37:05,440
and it is a hybrid kernel which combined

630
00:37:05,440 --> 00:37:09,200
from much kernel and bsd kernel

631
00:37:09,200 --> 00:37:12,640
it also brings the format a much old

632
00:37:12,640 --> 00:37:14,560
executable file

633
00:37:14,560 --> 00:37:18,000
the kernel exposes its interface

634
00:37:18,000 --> 00:37:21,520
as known as kpi to let the user use

635
00:37:21,520 --> 00:37:25,119
its functionality and all of them

636
00:37:25,119 --> 00:37:28,880
implement inside the kernel code

637
00:37:28,880 --> 00:37:31,920
like other os macos needs

638
00:37:31,920 --> 00:37:35,280
drivers to control devices they are

639
00:37:35,280 --> 00:37:37,839
called as

640
00:37:38,320 --> 00:37:41,680
kernel extension or kegs the kernel

641
00:37:41,680 --> 00:37:42,640
extension

642
00:37:42,640 --> 00:37:45,839
is a bundle of files and kernel

643
00:37:45,839 --> 00:37:50,160
load it from external space some

644
00:37:50,160 --> 00:37:51,599
interesting information

645
00:37:51,599 --> 00:37:54,640
can be got from info

646
00:37:54,640 --> 00:37:57,680
dot plist inside bundle

647
00:37:57,680 --> 00:38:01,680
our goal is to emulate own code part

648
00:38:01,680 --> 00:38:06,800
from uncle part of a rootkit in the case

649
00:38:06,800 --> 00:38:10,400
so in order to emulate driver i decide

650
00:38:10,400 --> 00:38:11,440
to load both

651
00:38:11,440 --> 00:38:14,960
kernel and kernel extension together

652
00:38:14,960 --> 00:38:17,280
because the kernel is also much older

653
00:38:17,280 --> 00:38:18,320
executable

654
00:38:18,320 --> 00:38:21,359
binary as well as the main component of

655
00:38:21,359 --> 00:38:22,320
the kx

656
00:38:22,320 --> 00:38:26,000
so i can load all of the 764 to emulator

657
00:38:26,000 --> 00:38:28,160
engine

658
00:38:28,160 --> 00:38:31,680
now i have implemented code of all kpis

659
00:38:31,680 --> 00:38:35,680
from the kernel besides like a normal

660
00:38:35,680 --> 00:38:38,720
application i have to resolve local

661
00:38:38,720 --> 00:38:39,839
symbols

662
00:38:39,839 --> 00:38:42,079
and some other dynamic symbols of the

663
00:38:42,079 --> 00:38:43,359
kicks

664
00:38:43,359 --> 00:38:46,880
however the kernel release is kpis

665
00:38:46,880 --> 00:38:49,760
through some dependencies so it is

666
00:38:49,760 --> 00:38:50,800
necessary

667
00:38:50,800 --> 00:38:53,359
to create a jump code as a kind of

668
00:38:53,359 --> 00:38:56,400
indirection calling

669
00:38:56,640 --> 00:39:00,400
next a driver will run

670
00:39:00,400 --> 00:39:03,599
from its initial function and this

671
00:39:03,599 --> 00:39:06,480
entry address can be extracted from

672
00:39:06,480 --> 00:39:07,920
binary symbol

673
00:39:07,920 --> 00:39:11,280
for iokit driver is that method and for

674
00:39:11,280 --> 00:39:12,560
xenric driver

675
00:39:12,560 --> 00:39:16,000
is a is a address store in real men

676
00:39:16,000 --> 00:39:18,400
symbol

677
00:39:18,880 --> 00:39:21,200
before emulating driver i should

678
00:39:21,200 --> 00:39:22,320
initialize

679
00:39:22,320 --> 00:39:25,599
kernel environment i set up mac

680
00:39:25,599 --> 00:39:28,720
policy list by allocating new object

681
00:39:28,720 --> 00:39:32,240
in emulator engine and fill that address

682
00:39:32,240 --> 00:39:35,599
in the target on kernel space the same

683
00:39:35,599 --> 00:39:36,560
thing i will do

684
00:39:36,560 --> 00:39:40,000
for own proc symbol on kernel space

685
00:39:40,000 --> 00:39:43,200
i also create some vinod and

686
00:39:43,200 --> 00:39:46,880
credential then i run emulation for

687
00:39:46,880 --> 00:39:48,079
pre-process

688
00:39:48,079 --> 00:39:53,280
such as attack pro or k-mode info

689
00:39:53,280 --> 00:39:55,440
finally i can go into the entry of

690
00:39:55,440 --> 00:39:57,839
driver

691
00:39:58,480 --> 00:40:01,520
speaking about the instrumentation i map

692
00:40:01,520 --> 00:40:04,560
on kpis which was export

693
00:40:04,560 --> 00:40:08,880
from kernel to user-defined methods

694
00:40:08,880 --> 00:40:11,920
it helps to simplify some features

695
00:40:11,920 --> 00:40:14,240
or we can pass through it and use native

696
00:40:14,240 --> 00:40:15,599
function

697
00:40:15,599 --> 00:40:18,640
on the other hand i can i also hook

698
00:40:18,640 --> 00:40:21,359
kpis to disable multi-thread

699
00:40:21,359 --> 00:40:23,520
functionality

700
00:40:23,520 --> 00:40:26,160
and for some unrelated to horse

701
00:40:26,160 --> 00:40:28,000
environment

702
00:40:28,000 --> 00:40:31,040
function i give driver a chance to

703
00:40:31,040 --> 00:40:33,359
interact with a real machine

704
00:40:33,359 --> 00:40:36,560
for example get attribute list box is a

705
00:40:36,560 --> 00:40:37,359
function

706
00:40:37,359 --> 00:40:39,680
to retrieve every entries in the

707
00:40:39,680 --> 00:40:41,119
directory

708
00:40:41,119 --> 00:40:44,160
so i just scan all the files and photos

709
00:40:44,160 --> 00:40:47,359
in directory and pack them using vfs

710
00:40:47,359 --> 00:40:51,520
attribute pack function from the kernel

711
00:40:51,520 --> 00:40:54,640
about the cisco emulation i just

712
00:40:54,640 --> 00:40:57,359
find the system symbol on load kernel

713
00:40:57,359 --> 00:40:58,400
space

714
00:40:58,400 --> 00:41:01,680
assign arguments to register

715
00:41:01,680 --> 00:41:06,000
and run the entry address

716
00:41:06,000 --> 00:41:10,400
some cases we want to call a native kpi

717
00:41:10,400 --> 00:41:14,319
from a hook kpi normally we have to save

718
00:41:14,319 --> 00:41:15,359
the current

719
00:41:15,359 --> 00:41:18,480
state and run another emulator

720
00:41:18,480 --> 00:41:21,280
but it may screw up when in some

721
00:41:21,280 --> 00:41:23,680
complicated situations

722
00:41:23,680 --> 00:41:26,720
so i construct a

723
00:41:26,720 --> 00:41:30,319
junk code and push its address to stack

724
00:41:30,319 --> 00:41:34,160
as a safe rip

725
00:41:34,160 --> 00:41:36,720
junk code has three main missions

726
00:41:36,720 --> 00:41:37,920
prepare arguments

727
00:41:37,920 --> 00:41:41,280
to register or stack clear stack after

728
00:41:41,280 --> 00:41:42,240
cooling

729
00:41:42,240 --> 00:41:48,880
and jump to native kpi directly

730
00:41:48,880 --> 00:41:52,079
under the kernel there are many events

731
00:41:52,079 --> 00:41:55,680
and contacts need to be emulated so i

732
00:41:55,680 --> 00:41:58,480
build an event management system

733
00:41:58,480 --> 00:42:01,599
to listen a result a resistor request

734
00:42:01,599 --> 00:42:04,880
from driver and emulate the interaction

735
00:42:04,880 --> 00:42:08,720
from user so this will make mac os

736
00:42:08,720 --> 00:42:11,599
from asynchronous system to synchronous

737
00:42:11,599 --> 00:42:13,040
system

738
00:42:13,040 --> 00:42:17,200
i use ems for 60 ctrl

739
00:42:17,200 --> 00:42:21,200
event nke event

740
00:42:21,200 --> 00:42:24,480
some network filter mac

741
00:42:24,480 --> 00:42:28,839
precis converts and chaotic

742
00:42:28,839 --> 00:42:31,920
features so in order to show

743
00:42:31,920 --> 00:42:35,599
how our tool works i will use demi god

744
00:42:35,599 --> 00:42:38,079
to analyze one of the famous rookies on

745
00:42:38,079 --> 00:42:39,200
macos

746
00:42:39,200 --> 00:42:42,720
rublin it was released

747
00:42:42,720 --> 00:42:46,720
full disclosure in 2012.

748
00:42:46,720 --> 00:42:48,640
it can give root through a running

749
00:42:48,640 --> 00:42:49,839
process

750
00:42:49,839 --> 00:42:54,319
hi-fi or folder etc

751
00:42:54,480 --> 00:42:58,000
also it can it couldn't run

752
00:42:58,000 --> 00:43:02,000
on modern kernel due to some reason

753
00:43:02,000 --> 00:43:06,079
such as memory arrangement kpi change

754
00:43:06,079 --> 00:43:09,680
read-only cisco table so to upgrade this

755
00:43:09,680 --> 00:43:10,480
rookie

756
00:43:10,480 --> 00:43:13,839
i use safe rip from

757
00:43:13,839 --> 00:43:16,640
initial function and step back to find

758
00:43:16,640 --> 00:43:18,800
the kernel base

759
00:43:18,800 --> 00:43:22,160
then i scan all the memories to find the

760
00:43:22,160 --> 00:43:23,520
sequence of

761
00:43:23,520 --> 00:43:26,400
cisco handle to determine the cisco

762
00:43:26,400 --> 00:43:27,760
table

763
00:43:27,760 --> 00:43:31,680
moreover i modified the cr0 resistor

764
00:43:31,680 --> 00:43:34,880
to override entries in

765
00:43:34,880 --> 00:43:37,680
cisco table

766
00:43:38,400 --> 00:43:41,359
so here is the demo for running rookie

767
00:43:41,359 --> 00:43:44,400
on the real machine

768
00:43:47,200 --> 00:43:50,640
first i load the driver and

769
00:43:50,640 --> 00:43:54,800
run an agent on user space

770
00:43:54,800 --> 00:43:57,680
from this ui i can command the rublin

771
00:43:57,680 --> 00:44:00,240
easily

772
00:44:03,680 --> 00:44:09,839
like a high up running process

773
00:44:24,240 --> 00:44:37,839
or hi-fi in current directory

774
00:44:47,760 --> 00:44:50,800
uh even remote code execution through

775
00:44:50,800 --> 00:44:54,319
an icmp packet

776
00:44:57,359 --> 00:45:01,359
here i will start the calculator

777
00:45:02,839 --> 00:45:05,839
application

778
00:45:28,880 --> 00:45:32,000
to emulate rublin i load it and run

779
00:45:32,000 --> 00:45:35,119
its initial function then it will

780
00:45:35,119 --> 00:45:36,160
automatically

781
00:45:36,160 --> 00:45:39,760
register some contacts to my ems

782
00:45:39,760 --> 00:45:42,400
i also build some default objects like a

783
00:45:42,400 --> 00:45:43,680
network

784
00:45:43,680 --> 00:45:48,399
cctl arguments and fake processes

785
00:45:49,599 --> 00:46:01,839
here is the demo

786
00:46:10,720 --> 00:46:13,839
now user can pass his input to some

787
00:46:13,839 --> 00:46:16,720
rootkit features

788
00:46:16,720 --> 00:46:21,839
like grand route permission to a

789
00:46:26,839 --> 00:46:29,839
process

790
00:46:33,440 --> 00:46:43,839
hi a process

791
00:46:48,640 --> 00:46:53,359
hi fi whose name is to do

792
00:46:53,359 --> 00:46:57,839
and con ios application

793
00:47:19,599 --> 00:47:22,800
then i can trigger the back door

794
00:47:22,800 --> 00:47:25,839
through pin command

795
00:47:39,280 --> 00:47:42,640
especially i can we can also debug this

796
00:47:42,640 --> 00:47:45,839
rookie by enabling gdb

797
00:47:45,839 --> 00:47:49,280
feature of demigod

798
00:47:49,280 --> 00:47:54,960
this video will demonstrate the debugger

799
00:47:59,280 --> 00:48:01,440
first i will disassemble all the

800
00:48:01,440 --> 00:48:02,640
instructions

801
00:48:02,640 --> 00:48:05,920
that rukit has went through to get the

802
00:48:05,920 --> 00:48:09,680
address i want to set breakpoint

803
00:48:13,440 --> 00:48:20,400
then i start the gdb server

804
00:48:20,400 --> 00:48:25,440
and connect to it from gdb client

805
00:48:32,640 --> 00:48:35,839
now i can step in

806
00:48:35,920 --> 00:48:38,640
step step

807
00:48:39,760 --> 00:48:42,720
set a breakpoint

808
00:48:47,359 --> 00:48:49,839
continue

809
00:48:56,559 --> 00:49:03,839
settle fire breakpoint

810
00:49:06,319 --> 00:49:08,800
continue

811
00:49:11,920 --> 00:49:17,839
dumb resistor

812
00:49:46,160 --> 00:49:49,280
and next mr queen win

813
00:49:49,280 --> 00:49:53,680
show how demigod works on lineups

814
00:49:54,960 --> 00:49:58,160
okay so in this session i introduced how

815
00:49:58,160 --> 00:50:00,720
democrat

816
00:50:00,800 --> 00:50:03,839
support linux kernel

817
00:50:03,839 --> 00:50:05,920
so we can analyze the kernel linux

818
00:50:05,920 --> 00:50:07,280
kernel rookies inside

819
00:50:07,280 --> 00:50:11,119
demigod so linux is

820
00:50:11,119 --> 00:50:12,880
linux kernel is actually a very

821
00:50:12,880 --> 00:50:14,559
complicated

822
00:50:14,559 --> 00:50:17,680
system with many subsystem but for them

823
00:50:17,680 --> 00:50:19,760
we got we only

824
00:50:19,760 --> 00:50:24,839
look got some relevant subsystem

825
00:50:24,839 --> 00:50:27,280
that are enough to make

826
00:50:27,280 --> 00:50:29,280
kernel rocket works the first one is

827
00:50:29,280 --> 00:50:30,319
system calls

828
00:50:30,319 --> 00:50:33,680
because a cisco system can play very

829
00:50:33,680 --> 00:50:37,760
important roles to provide services and

830
00:50:37,760 --> 00:50:39,839
many gunner rookies would override the

831
00:50:39,839 --> 00:50:42,319
system code to provide is

832
00:50:42,319 --> 00:50:45,359
their own functionalities

833
00:50:45,359 --> 00:50:48,720
and we also care about the io io control

834
00:50:48,720 --> 00:50:49,520
system code

835
00:50:49,520 --> 00:50:53,119
because the kernel gonna get

836
00:50:53,119 --> 00:50:56,079
routine can provide some functionality

837
00:50:56,079 --> 00:50:58,000
to the user land via

838
00:50:58,000 --> 00:51:01,280
this system code and also

839
00:51:01,280 --> 00:51:04,800
some other convex that can indirectly

840
00:51:04,800 --> 00:51:07,520
trigger by the insulin that we also need

841
00:51:07,520 --> 00:51:08,960
to emulate their

842
00:51:08,960 --> 00:51:12,160
first upon life high operations

843
00:51:12,160 --> 00:51:15,680
and because kernan rooted in linux

844
00:51:15,680 --> 00:51:19,680
is built in us linux kernel module

845
00:51:19,680 --> 00:51:24,400
in dot ko format so we need to

846
00:51:24,400 --> 00:51:27,040
support the dot key format which is er

847
00:51:27,040 --> 00:51:28,880
format but a bit different from the user

848
00:51:28,880 --> 00:51:30,400
lab

849
00:51:30,400 --> 00:51:33,839
so the goal is that we try to emulate

850
00:51:33,839 --> 00:51:38,640
kernel toolkit in dot kl files

851
00:51:39,359 --> 00:51:42,240
so for the loader of demigod for the dot

852
00:51:42,240 --> 00:51:43,440
ko files

853
00:51:43,440 --> 00:51:46,559
we need to view our own lotter which is

854
00:51:46,559 --> 00:51:47,920
quite different from the lord of

855
00:51:47,920 --> 00:51:51,200
chilling so we need to pass on the

856
00:51:51,200 --> 00:51:53,440
section of ef files and map the

857
00:51:53,440 --> 00:51:55,040
innovation into the

858
00:51:55,040 --> 00:51:58,640
emulator memory and demigod also need to

859
00:51:58,640 --> 00:52:00,800
resolve on the external apis

860
00:52:00,800 --> 00:52:03,440
so we can provide our own implementation

861
00:52:03,440 --> 00:52:05,440
in the emulator

862
00:52:05,440 --> 00:52:08,319
and finally we need to relocate the

863
00:52:08,319 --> 00:52:09,440
external function

864
00:52:09,440 --> 00:52:13,200
and simple data the next

865
00:52:13,200 --> 00:52:16,160
thing demigod had to do is that you need

866
00:52:16,160 --> 00:52:17,760
to set up the cpu context

867
00:52:17,760 --> 00:52:21,440
so the kernel kit can function properly

868
00:52:21,440 --> 00:52:23,200
and one object is that we need to set up

869
00:52:23,200 --> 00:52:25,920
gs segment for current tasks

870
00:52:25,920 --> 00:52:28,720
because many kernel rookies try to

871
00:52:28,720 --> 00:52:31,680
access to the current task

872
00:52:31,680 --> 00:52:35,118
they need gs segment for this

873
00:52:35,520 --> 00:52:38,960
we also need to initialize system

874
00:52:38,960 --> 00:52:42,800
system containment of linux kernel so

875
00:52:42,800 --> 00:52:45,760
the kernel rookie can accept can read

876
00:52:45,760 --> 00:52:48,880
can drive to the system containment

877
00:52:48,880 --> 00:52:51,440
so for this part we have to write the

878
00:52:51,440 --> 00:52:52,400
rest of our

879
00:52:52,400 --> 00:52:54,559
own system called implementation into

880
00:52:54,559 --> 00:52:56,079
the system containment

881
00:52:56,079 --> 00:52:59,040
and we have to hook the system cost so

882
00:52:59,040 --> 00:53:01,920
when the rootkit

883
00:53:01,920 --> 00:53:05,119
access to the system code we can execute

884
00:53:05,119 --> 00:53:05,839
our own

885
00:53:05,839 --> 00:53:09,200
system system call implementation

886
00:53:09,200 --> 00:53:12,240
finally for the loader we have to locate

887
00:53:12,240 --> 00:53:15,520
the initialize function of the dot ko

888
00:53:15,520 --> 00:53:19,520
file which is an init module symbol

889
00:53:21,839 --> 00:53:24,640
to support linux kernel rookies we had

890
00:53:24,640 --> 00:53:25,520
to

891
00:53:25,520 --> 00:53:29,440
we had to emulate many linux structures

892
00:53:29,440 --> 00:53:32,960
like dust chuck for the insulin task

893
00:53:32,960 --> 00:53:36,319
file operation because the root can

894
00:53:36,319 --> 00:53:39,680
modify the vibration

895
00:53:39,680 --> 00:53:42,240
so it can trigger the contact to the

896
00:53:42,240 --> 00:53:43,040
vibration

897
00:53:43,040 --> 00:53:47,119
like read right open and close

898
00:53:47,119 --> 00:53:49,280
we have to support the module structures

899
00:53:49,280 --> 00:53:50,319
because the

900
00:53:50,319 --> 00:53:53,760
kernel rookie can access to the

901
00:53:53,760 --> 00:53:56,480
list of modules inside the system and

902
00:53:56,480 --> 00:53:58,319
modify something like version they try

903
00:53:58,319 --> 00:53:58,960
to

904
00:53:58,960 --> 00:54:03,040
hide some kernel modules so they have to

905
00:54:03,040 --> 00:54:04,800
read and write to the list of the

906
00:54:04,800 --> 00:54:06,480
modules and

907
00:54:06,480 --> 00:54:09,760
we have to support support ratio the few

908
00:54:09,760 --> 00:54:10,079
other

909
00:54:10,079 --> 00:54:12,000
structures we have to support like user

910
00:54:12,000 --> 00:54:13,680
name space

911
00:54:13,680 --> 00:54:16,880
so the kernel kit can modify the user

912
00:54:16,880 --> 00:54:19,280
credential

913
00:54:19,280 --> 00:54:21,280
we have to support file structures

914
00:54:21,280 --> 00:54:23,839
because gonorrhood can modify the file

915
00:54:23,839 --> 00:54:26,000
structure

916
00:54:26,000 --> 00:54:28,079
and some other structures like linux

917
00:54:28,079 --> 00:54:30,800
direct so

918
00:54:31,760 --> 00:54:33,920
this is necessary because some kind we

919
00:54:33,920 --> 00:54:35,599
can try to modify

920
00:54:35,599 --> 00:54:39,839
and hide some directories

921
00:54:40,000 --> 00:54:45,280
okay so we didn't have to emulate the

922
00:54:45,280 --> 00:54:49,119
dot ko file initialization and because

923
00:54:49,119 --> 00:54:52,240
when the kernel rookie when when the

924
00:54:52,240 --> 00:54:55,359
hacker loads the gonna rookie into the

925
00:54:55,359 --> 00:54:56,160
system

926
00:54:56,160 --> 00:54:59,359
they can specify some

927
00:54:59,359 --> 00:55:02,720
optional arguments so

928
00:55:02,720 --> 00:55:06,240
for the demigod to work properly

929
00:55:06,240 --> 00:55:09,200
we have to do the same thing so you also

930
00:55:09,200 --> 00:55:10,559
need to support

931
00:55:10,559 --> 00:55:16,000
option arguments for the dot ko files

932
00:55:18,079 --> 00:55:22,319
and uh okay assist phase user need to

933
00:55:22,319 --> 00:55:25,440
specify the input for the init module

934
00:55:25,440 --> 00:55:28,640
engine and after that the mega can start

935
00:55:28,640 --> 00:55:32,160
to emulate from the init module

936
00:55:32,839 --> 00:55:34,559
symbols

937
00:55:34,559 --> 00:55:37,280
okay we have to hook many looks good

938
00:55:37,280 --> 00:55:40,160
apis for the route it works properly

939
00:55:40,160 --> 00:55:42,000
and here i list some of the most

940
00:55:42,000 --> 00:55:43,920
important apis

941
00:55:43,920 --> 00:55:46,960
inside linux gone

942
00:55:46,960 --> 00:55:49,839
there is some api for

943
00:55:52,000 --> 00:55:55,680
function generation for memory

944
00:55:55,680 --> 00:55:59,280
access for memory

945
00:55:59,280 --> 00:56:02,079
management heap memory management for

946
00:56:02,079 --> 00:56:03,920
device management

947
00:56:03,920 --> 00:56:06,720
and some system cons we have to hope and

948
00:56:06,720 --> 00:56:07,200
we

949
00:56:07,200 --> 00:56:09,040
need to emulate some system system

950
00:56:09,040 --> 00:56:11,599
connection

951
00:56:12,880 --> 00:56:15,359
okay once we can extract on the code

952
00:56:15,359 --> 00:56:17,040
part we care about

953
00:56:17,040 --> 00:56:20,160
doing the current rootkit

954
00:56:20,160 --> 00:56:24,400
init phase we can emulate them

955
00:56:24,400 --> 00:56:27,040
so first of all you can during the init

956
00:56:27,040 --> 00:56:28,720
phase

957
00:56:28,720 --> 00:56:30,960
demigod can extract the system code

958
00:56:30,960 --> 00:56:32,240
because gunnery can

959
00:56:32,240 --> 00:56:34,319
can override some system code so we can

960
00:56:34,319 --> 00:56:36,319
you need to get get them out

961
00:56:36,319 --> 00:56:38,000
and also we need to get all the code

962
00:56:38,000 --> 00:56:39,599
bikes

963
00:56:39,599 --> 00:56:42,839
that can be registered by the kernel

964
00:56:42,839 --> 00:56:44,799
rookies

965
00:56:44,799 --> 00:56:48,240
and after that we need to trigger all

966
00:56:48,240 --> 00:56:52,240
the copa the code path that user want to

967
00:56:52,240 --> 00:56:55,680
emulate so as this phase user child

968
00:56:55,680 --> 00:56:59,200
user can decide the input arguments

969
00:56:59,200 --> 00:57:02,720
for the code part that they decide to

970
00:57:02,720 --> 00:57:05,200
emulate

971
00:57:06,640 --> 00:57:09,920
and yeah here i list some of the most

972
00:57:09,920 --> 00:57:13,040
popular code path that kernel

973
00:57:13,040 --> 00:57:15,279
can

974
00:57:16,079 --> 00:57:18,319
can

975
00:57:19,200 --> 00:57:23,839
can set up and use a need to

976
00:57:23,839 --> 00:57:26,880
specify the input for on those codepaths

977
00:57:26,880 --> 00:57:30,240
if you want to imagine

978
00:57:31,599 --> 00:57:34,799
okay next i have a written demo for

979
00:57:34,799 --> 00:57:37,760
linux so you can see how we can use

980
00:57:37,760 --> 00:57:39,359
demigod to analyze

981
00:57:39,359 --> 00:57:43,920
a kernel kit in linux and

982
00:57:44,160 --> 00:57:45,920
in this case we looked at the kernel

983
00:57:45,920 --> 00:57:48,160
rookie name mohammed

984
00:57:48,160 --> 00:57:51,599
and this one is a very typical kind of

985
00:57:51,599 --> 00:57:52,839
rookie with

986
00:57:52,839 --> 00:57:56,799
a many typical behaviors

987
00:57:56,799 --> 00:58:00,079
first of all mohammed rookit can child

988
00:58:00,079 --> 00:58:00,400
to

989
00:58:00,400 --> 00:58:03,200
high current modules it can hide files

990
00:58:03,200 --> 00:58:04,000
it can hide

991
00:58:04,000 --> 00:58:07,280
network posts it can grant good access

992
00:58:07,280 --> 00:58:09,200
to current process

993
00:58:09,200 --> 00:58:11,839
and this rookie actually overrides many

994
00:58:11,839 --> 00:58:13,599
system cons

995
00:58:13,599 --> 00:58:15,839
and it can also interface with userland

996
00:58:15,839 --> 00:58:17,359
via some

997
00:58:17,359 --> 00:58:21,440
using some customized files in slash pro

998
00:58:21,440 --> 00:58:25,119
file system and actually you can find a

999
00:58:25,119 --> 00:58:27,200
source code of this kernel rootkit on

1000
00:58:27,200 --> 00:58:28,559
github

1001
00:58:28,559 --> 00:58:31,440
so in this demo we try to emulate this

1002
00:58:31,440 --> 00:58:33,520
control kit

1003
00:58:33,520 --> 00:58:37,119
and to do that demigod will

1004
00:58:37,119 --> 00:58:39,040
load the rookit into the memory

1005
00:58:39,040 --> 00:58:40,480
initialize it

1006
00:58:40,480 --> 00:58:43,440
and we try to

1007
00:58:43,599 --> 00:58:48,240
extract the new system cone

1008
00:58:48,240 --> 00:58:50,240
made by the rookit for the right system

1009
00:58:50,240 --> 00:58:51,359
code

1010
00:58:51,359 --> 00:58:54,880
and in the demo we emulate

1011
00:58:54,880 --> 00:58:58,720
the this right system conjecture

1012
00:58:58,720 --> 00:59:02,480
with some selected input and we chase

1013
00:59:02,480 --> 00:59:05,680
all the activities of the

1014
00:59:05,680 --> 00:59:10,000
this rocket with a typical idea

1015
00:59:10,160 --> 00:59:15,839
so here i have the video demo

1016
00:59:17,119 --> 00:59:21,280
okay so here

1017
00:59:21,920 --> 00:59:24,640
you can see that

1018
00:59:25,280 --> 00:59:28,799
i have a gonna look it in the

1019
00:59:29,200 --> 00:59:32,799
file name rookie.ko

1020
00:59:34,160 --> 00:59:38,079
is going to emulate this rootkit.ko

1021
00:59:38,079 --> 00:59:39,599
files

1022
00:59:39,599 --> 00:59:41,280
so you can see that on the screen you

1023
00:59:41,280 --> 00:59:45,280
have two windows the console

1024
00:59:45,280 --> 00:59:48,240
on the left side in which demigod will

1025
00:59:48,240 --> 00:59:50,799
emulate the kernel rookie

1026
00:59:50,799 --> 00:59:54,880
on the right side you run idi pro

1027
00:59:54,880 --> 00:59:58,000
and ida pro will

1028
00:59:58,000 --> 01:00:01,200
be used as a debugger and we connect

1029
01:00:01,200 --> 01:00:02,960
this debugger to the

1030
01:00:02,960 --> 01:00:04,960
kernel rootkit running on the left side

1031
01:00:04,960 --> 01:00:14,640
on the console

1032
01:00:14,640 --> 01:00:16,079
okay so here you can see that on the

1033
01:00:16,079 --> 01:00:18,160
left side when i run the corner look it

1034
01:00:18,160 --> 01:00:19,119
in the

1035
01:00:19,119 --> 01:00:22,160
in the migor emulator the group will

1036
01:00:22,160 --> 01:00:22,799
stop

1037
01:00:22,799 --> 01:00:26,400
and it open the gdb interface

1038
01:00:26,400 --> 01:00:28,920
at the localhost address at the port

1039
01:00:28,920 --> 01:00:31,200
99999

1040
01:00:31,200 --> 01:00:34,000
and we is going to wait for the debugger

1041
01:00:34,000 --> 01:00:36,799
to connect to

1042
01:00:36,880 --> 01:00:40,079
so we run the idi pro debugger on the

1043
01:00:40,079 --> 01:00:41,040
right side

1044
01:00:41,040 --> 01:00:44,079
and we set up the rdap row to connect to

1045
01:00:44,079 --> 01:00:48,480
localhost at the port 9999

1046
01:00:54,640 --> 01:00:56,799
okay see here you can see that i try to

1047
01:00:56,799 --> 01:00:59,359
attach idi pro to the

1048
01:00:59,359 --> 01:01:01,839
gdb difficult inside the emulator on the

1049
01:01:01,839 --> 01:01:11,839
left side

1050
01:01:13,359 --> 01:01:16,079
okay you can see here that once we

1051
01:01:16,079 --> 01:01:18,160
connect the debugger

1052
01:01:18,160 --> 01:01:21,760
idi pro in set we put a breakpoint as a

1053
01:01:21,760 --> 01:01:23,599
initialized function of the kernel

1054
01:01:23,599 --> 01:01:24,960
rookie

1055
01:01:24,960 --> 01:01:28,400
and you can see that in the idi pro

1056
01:01:28,400 --> 01:01:29,040
window

1057
01:01:29,040 --> 01:01:31,440
you can see the code of the debugger

1058
01:01:31,440 --> 01:01:33,839
this is the code of the rootkit

1059
01:01:33,839 --> 01:01:37,280
so now i insert a break bar on the first

1060
01:01:37,280 --> 01:01:40,000
injection which is the cone injection

1061
01:01:40,000 --> 01:01:41,200
and you can see that we can

1062
01:01:41,200 --> 01:01:44,799
use a debugger like normal uh

1063
01:01:44,799 --> 01:01:46,640
uh debugging session with the user

1064
01:01:46,640 --> 01:01:48,480
encode but you can see that you can

1065
01:01:48,480 --> 01:01:53,599
debug kernel code

1066
01:01:53,599 --> 01:01:57,760
so here on the right side i do some

1067
01:01:57,760 --> 01:02:01,039
single step and on the left side you see

1068
01:02:01,039 --> 01:02:02,000
that the colon

1069
01:02:02,000 --> 01:02:05,119
actually runs and you can compare the

1070
01:02:05,119 --> 01:02:06,559
left side the right side scissors

1071
01:02:06,559 --> 01:02:06,960
actually

1072
01:02:06,960 --> 01:02:09,920
exactly the same thing the same

1073
01:02:09,920 --> 01:02:10,720
injection

1074
01:02:10,720 --> 01:02:14,000
get executed but you can see the

1075
01:02:14,000 --> 01:02:16,000
difference is that on the right side

1076
01:02:16,000 --> 01:02:19,599
at this arrest

1077
01:02:19,599 --> 01:02:21,839
in the in the idea pro you can only see

1078
01:02:21,839 --> 01:02:23,359
the cool

1079
01:02:23,359 --> 01:02:25,760
some unknown function but on the left

1080
01:02:25,760 --> 01:02:26,480
side because

1081
01:02:26,480 --> 01:02:29,520
we actually emulate the kernel grid

1082
01:02:29,520 --> 01:02:32,160
you can see that this code actually is a

1083
01:02:32,160 --> 01:02:32,640
is a

1084
01:02:32,640 --> 01:02:36,160
principle function and

1085
01:02:36,160 --> 01:02:39,520
as this place actually the kernel rookie

1086
01:02:39,520 --> 01:02:41,599
print out

1087
01:02:41,599 --> 01:02:48,480
a message which is modern starting

1088
01:02:48,480 --> 01:02:49,760
so you can see that on the right side

1089
01:02:49,760 --> 01:02:51,359
idea pro doesn't seem much better on the

1090
01:02:51,359 --> 01:02:52,400
left side because

1091
01:02:52,400 --> 01:02:54,240
we actually emulate the kernel is you

1092
01:02:54,240 --> 01:02:57,598
can see a lot more information

1093
01:02:59,359 --> 01:03:03,760
okay so i continue to sink and step

1094
01:03:03,760 --> 01:03:07,200
inside the debacle so you can

1095
01:03:07,599 --> 01:03:12,480
you can see how the conduit kit

1096
01:03:14,839 --> 01:03:17,839
executes

1097
01:03:32,400 --> 01:03:34,319
yeah you see here on the right side idea

1098
01:03:34,319 --> 01:03:35,680
bro doesn't see much but on the left

1099
01:03:35,680 --> 01:03:38,079
side we see many more information

1100
01:03:38,079 --> 01:03:40,480
live for sure when you see here that you

1101
01:03:40,480 --> 01:03:41,280
can see here

1102
01:03:41,280 --> 01:03:43,520
see on the left side that based on some

1103
01:03:43,520 --> 01:03:45,440
messages you can see

1104
01:03:45,440 --> 01:03:47,280
the rookie already initialized some

1105
01:03:47,280 --> 01:03:49,280
probe

1106
01:03:49,280 --> 01:03:54,319
some pro file system

1107
01:03:54,319 --> 01:03:58,000
okay here you can see that the initial

1108
01:03:58,000 --> 01:04:00,880
life phase of the rookie is already done

1109
01:04:00,880 --> 01:04:01,200
and

1110
01:04:01,200 --> 01:04:04,480
idea pro doesn't see much but demigod

1111
01:04:04,480 --> 01:04:05,520
can see that

1112
01:04:05,520 --> 01:04:07,839
this rookie modified three now four

1113
01:04:07,839 --> 01:04:09,039
system cons

1114
01:04:09,039 --> 01:04:12,880
read right open and close

1115
01:04:12,880 --> 01:04:15,760
so the next phase that we decide that we

1116
01:04:15,760 --> 01:04:17,039
want to

1117
01:04:17,039 --> 01:04:19,039
explore the right system code made by

1118
01:04:19,039 --> 01:04:20,319
the rookit to see

1119
01:04:20,319 --> 01:04:23,359
what this one does

1120
01:04:23,839 --> 01:04:27,039
so we just continue to change in the

1121
01:04:27,039 --> 01:04:29,520
debugger

1122
01:04:32,079 --> 01:04:34,799
so on the left side actually that the

1123
01:04:34,799 --> 01:04:35,680
for the

1124
01:04:35,680 --> 01:04:37,920
the mirror to work we specify some

1125
01:04:37,920 --> 01:04:38,880
special

1126
01:04:38,880 --> 01:04:41,440
input for the right system call and here

1127
01:04:41,440 --> 01:04:44,319
you can see that

1128
01:04:44,319 --> 01:04:46,480
on the left side you can see that the

1129
01:04:46,480 --> 01:04:47,920
rookie already

1130
01:04:47,920 --> 01:04:51,839
made the current process root

1131
01:04:53,119 --> 01:04:55,839
and after

1132
01:04:56,240 --> 01:04:58,799
right after this right system call

1133
01:04:58,799 --> 01:04:59,839
finish

1134
01:04:59,839 --> 01:05:02,720
the current process become good that's

1135
01:05:02,720 --> 01:05:03,200
what

1136
01:05:03,200 --> 01:05:08,640
this rookie does okay

1137
01:05:08,640 --> 01:05:12,160
that's how the rootkit works

1138
01:05:12,160 --> 01:05:14,559
and you can see that very clearly inside

1139
01:05:14,559 --> 01:05:17,280
the demo

1140
01:05:18,799 --> 01:05:20,559
okay so actually you can see that the

1141
01:05:20,559 --> 01:05:22,000
mega can emulate the

1142
01:05:22,000 --> 01:05:25,599
current rookies but more than that you

1143
01:05:25,599 --> 01:05:27,200
can view many more

1144
01:05:27,200 --> 01:05:31,520
applications on the demigod framework

1145
01:05:31,680 --> 01:05:35,119
so you can debug kernel rookies in

1146
01:05:35,119 --> 01:05:37,839
tree like what i already show you can

1147
01:05:37,839 --> 01:05:41,039
build auto unpacked for conan code

1148
01:05:41,039 --> 01:05:44,160
so in that we can chase code

1149
01:05:44,160 --> 01:05:46,480
inside the kernel rookit today to detect

1150
01:05:46,480 --> 01:05:48,559
the time the code is unpacked

1151
01:05:48,559 --> 01:05:50,799
then we dump and you can auto view

1152
01:05:50,799 --> 01:05:52,720
rebuild the binaries

1153
01:05:52,720 --> 01:05:56,319
you can view i o control analyzer

1154
01:05:56,319 --> 01:06:00,319
so we can automat automatically discover

1155
01:06:00,319 --> 01:06:03,520
on the i o control code with different

1156
01:06:03,520 --> 01:06:05,760
input and you can exchange the code

1157
01:06:05,760 --> 01:06:08,480
bicep i o control code

1158
01:06:08,480 --> 01:06:11,039
you can also use auto summarize rookie

1159
01:06:11,039 --> 01:06:12,240
behavior

1160
01:06:12,240 --> 01:06:17,200
to produce high level reports so

1161
01:06:17,200 --> 01:06:20,799
this idea is that you can view

1162
01:06:20,799 --> 01:06:23,520
uh you can automatically discover

1163
01:06:23,520 --> 01:06:24,160
different

1164
01:06:24,160 --> 01:06:27,359
rootkit paths with different

1165
01:06:27,359 --> 01:06:31,039
random inputs and after that we can

1166
01:06:31,039 --> 01:06:32,240
build a

1167
01:06:32,240 --> 01:06:34,960
summarized report for all the behaviors

1168
01:06:34,960 --> 01:06:36,319
we can see

1169
01:06:36,319 --> 01:06:40,720
when the rookie

1170
01:06:40,720 --> 01:06:42,960
execute with different input on

1171
01:06:42,960 --> 01:06:45,680
different code paths

1172
01:06:45,680 --> 01:06:48,400
and the idea is that it's quite easy to

1173
01:06:48,400 --> 01:06:50,000
do that because they've got

1174
01:06:50,000 --> 01:06:52,720
enabled save execution on checkpoints

1175
01:06:52,720 --> 01:06:54,079
you can take snapshot and

1176
01:06:54,079 --> 01:06:57,200
reverse and there are many many

1177
01:06:57,200 --> 01:07:00,640
other exciting ideas that i waiting for

1178
01:07:00,640 --> 01:07:03,359
you to explore

1179
01:07:04,400 --> 01:07:06,480
so regretting the status and future

1180
01:07:06,480 --> 01:07:08,079
works for demigod

1181
01:07:08,079 --> 01:07:10,880
the mover now already supported windows

1182
01:07:10,880 --> 01:07:11,599
macos

1183
01:07:11,599 --> 01:07:13,520
and linux kernel rookies but there's

1184
01:07:13,520 --> 01:07:15,680
still a lot more work

1185
01:07:15,680 --> 01:07:17,839
in the future we still need to test and

1186
01:07:17,839 --> 01:07:19,200
to improve

1187
01:07:19,200 --> 01:07:21,680
the regard to support more rookies so

1188
01:07:21,680 --> 01:07:23,599
you need to handle more content apis

1189
01:07:23,599 --> 01:07:28,319
more system calls more content subsystem

1190
01:07:28,319 --> 01:07:31,359
and maybe you can

1191
01:07:31,359 --> 01:07:33,280
look forward to supporting more

1192
01:07:33,280 --> 01:07:34,960
platforms besides windows

1193
01:07:34,960 --> 01:07:39,839
macos and linuxconon like ios or android

1194
01:07:39,839 --> 01:07:43,039
and we plan to merge demigod into the

1195
01:07:43,039 --> 01:07:46,640
chilling emulator very soon

1196
01:07:47,200 --> 01:07:50,319
okay here come my conclusion the because

1197
01:07:50,319 --> 01:07:51,839
it's a framework to emulate the kernel

1198
01:07:51,839 --> 01:07:52,720
rookies

1199
01:07:52,720 --> 01:07:55,039
so you can analyze ring zero code from

1200
01:07:55,039 --> 01:07:57,200
ring tree in safety box of the

1201
01:07:57,200 --> 01:08:00,079
emulators so you can monitor you can

1202
01:08:00,079 --> 01:08:01,839
chase you can debug and create

1203
01:08:01,839 --> 01:08:03,920
you can do on cap dynamic and assist

1204
01:08:03,920 --> 01:08:06,240
with uh demi god

1205
01:08:06,240 --> 01:08:07,839
demigod was built on top of the

1206
01:08:07,839 --> 01:08:10,079
excellent chilling emulators

1207
01:08:10,079 --> 01:08:12,960
so we support multi-platforms

1208
01:08:12,960 --> 01:08:15,039
multi-architectures

1209
01:08:15,039 --> 01:08:17,600
demogorgon enable advanced binary

1210
01:08:17,600 --> 01:08:18,238
analysis

1211
01:08:18,238 --> 01:08:21,600
on top of the kernel code and they allow

1212
01:08:21,600 --> 01:08:22,158
you to

1213
01:08:22,158 --> 01:08:24,479
use python language to build your

1214
01:08:24,479 --> 01:08:26,399
analysis students

1215
01:08:26,399 --> 01:08:27,839
and it supports many kind of

1216
01:08:27,839 --> 01:08:30,960
instrumentation so you can

1217
01:08:30,960 --> 01:08:34,158
easily uh analyze the content rookies

1218
01:08:34,158 --> 01:08:36,319
running inside them code

1219
01:08:36,319 --> 01:08:39,679
so we plan to release

1220
01:08:39,679 --> 01:08:41,600
the full source code of demigod

1221
01:08:41,600 --> 01:08:42,960
variation

1222
01:08:42,960 --> 01:08:45,439
and we plan to merge demigod into the

1223
01:08:45,439 --> 01:08:46,479
chilling

1224
01:08:46,479 --> 01:08:52,880
emulator very soon

1225
01:08:52,880 --> 01:08:58,319
okay now q a session

