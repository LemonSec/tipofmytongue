1
00:00:00,030 --> 00:00:03,719
welcome to exploiting the hyper-v IDE

2
00:00:01,890 --> 00:00:07,170
emulator to escape the virtual machine

3
00:00:03,720 --> 00:00:09,450
in Lagoon JKL with joe by lac before we

4
00:00:07,170 --> 00:00:10,950
begin a few brief notes please stop by

5
00:00:09,450 --> 00:00:13,049
the business hall located in Mandalay

6
00:00:10,950 --> 00:00:15,059
Bay Oceanside and shoreline ballrooms on

7
00:00:13,049 --> 00:00:17,220
level 2 during the day and for the

8
00:00:15,059 --> 00:00:19,320
Welcome Reception at 5:30 p.m. tonight

9
00:00:17,220 --> 00:00:21,599
the blackhat Arsenal is in the business

10
00:00:19,320 --> 00:00:24,210
hall in level 2 please join us for the

11
00:00:21,600 --> 00:00:27,689
pony Awards in lagoon JKL which is this

12
00:00:24,210 --> 00:00:31,050
room at 6:30 p.m. and lunch is in

13
00:00:27,689 --> 00:00:32,460
Bayside a be from 1205 to 1:30 please

14
00:00:31,050 --> 00:00:34,079
put your phones on vibrate it makes it

15
00:00:32,460 --> 00:00:35,309
easier for the rest of us to ignore the

16
00:00:34,079 --> 00:00:36,930
rain while you wait for your voicemail

17
00:00:35,309 --> 00:00:44,550
to pick it up now please give a warm

18
00:00:36,930 --> 00:00:46,710
welcome to job Ilyich hi so my name is

19
00:00:44,550 --> 00:00:48,599
Joe and I work for Microsoft on the nsrc

20
00:00:46,710 --> 00:00:50,520
vulnerabilities and mitigations team and

21
00:00:48,600 --> 00:00:51,809
in case you haven't noticed

22
00:00:50,520 --> 00:00:54,270
Microsoft cares quite a bit about

23
00:00:51,809 --> 00:00:55,649
hyper-v and we've actually paid out six

24
00:00:54,270 --> 00:00:57,690
hundred and twenty five thousand dollars

25
00:00:55,649 --> 00:01:00,149
in hyper-v bounties since blackhat last

26
00:00:57,690 --> 00:01:02,129
year today I'm going to be talking about

27
00:01:00,149 --> 00:01:03,989
exploiting a vulnerability that was

28
00:01:02,129 --> 00:01:07,200
reported to us through the hyper-v bug

29
00:01:03,989 --> 00:01:08,729
bounty and also show you how incredibly

30
00:01:07,200 --> 00:01:12,479
impactful some of the bug reports that

31
00:01:08,729 --> 00:01:16,560
you send to us can be so this story

32
00:01:12,479 --> 00:01:17,789
begins sometime in 2017 and I was going

33
00:01:16,560 --> 00:01:20,159
through a number of the hyper-v

34
00:01:17,790 --> 00:01:22,409
emulators at the time and looking for

35
00:01:20,159 --> 00:01:25,950
security bugs I started reviewing the

36
00:01:22,409 --> 00:01:27,390
emulated storage stack and as you might

37
00:01:25,950 --> 00:01:29,820
expect from code that's written in the

38
00:01:27,390 --> 00:01:33,119
90s some of the code in here was a bit

39
00:01:29,820 --> 00:01:34,470
sketchy just as a quick example there

40
00:01:33,119 --> 00:01:36,270
was this function it was called write

41
00:01:34,470 --> 00:01:37,619
data port and the thing that had me a

42
00:01:36,270 --> 00:01:41,039
little bit concerned about this function

43
00:01:37,619 --> 00:01:42,689
was that there was a memo opening with a

44
00:01:41,040 --> 00:01:44,579
pointer that it had a bunch of

45
00:01:42,689 --> 00:01:47,070
arithmetic done on it and it seemed like

46
00:01:44,579 --> 00:01:48,779
some of the arithmetic was checked and

47
00:01:47,070 --> 00:01:50,460
some of the arithmetic definitely was

48
00:01:48,780 --> 00:01:52,799
not checked in this function at least

49
00:01:50,460 --> 00:01:54,960
but other parts of the state machine in

50
00:01:52,799 --> 00:01:57,840
theory were supposed to be validating

51
00:01:54,960 --> 00:02:00,869
that none of these offsets would ever

52
00:01:57,840 --> 00:02:04,350
force the buffer to go out of bounds now

53
00:02:00,869 --> 00:02:06,750
unfortunately for me I did not end up

54
00:02:04,350 --> 00:02:08,758
finding a way to trigger a bug here

55
00:02:06,750 --> 00:02:10,560
because I got sidetracked we had a

56
00:02:08,758 --> 00:02:12,420
meeting with the visual studio team at

57
00:02:10,560 --> 00:02:13,739
Microsoft and they were talking to us

58
00:02:12,420 --> 00:02:15,569
about

59
00:02:13,739 --> 00:02:18,870
class that they were helping create for

60
00:02:15,569 --> 00:02:20,940
C++ called the span and really all that

61
00:02:18,870 --> 00:02:22,890
a span does is it wraps in a race so it

62
00:02:20,940 --> 00:02:24,959
has a pointer it has a size and whenever

63
00:02:22,890 --> 00:02:26,849
you do array accesses it does bounce

64
00:02:24,959 --> 00:02:29,760
checking for you and fast fields if

65
00:02:26,849 --> 00:02:30,720
you're doing an out of bounds access now

66
00:02:29,760 --> 00:02:32,160
one of the things that we're pretty

67
00:02:30,720 --> 00:02:33,989
interested in is how we can make our

68
00:02:32,160 --> 00:02:35,849
products safer and just eliminate

69
00:02:33,989 --> 00:02:37,680
classes of vulnerabilities so this

70
00:02:35,849 --> 00:02:41,339
seemed pretty cool to us and I ended up

71
00:02:37,680 --> 00:02:43,590
switching gears and porting GSL span

72
00:02:41,340 --> 00:02:45,239
into the emulated storage stack because

73
00:02:43,590 --> 00:02:49,680
it seemed like a good candidate based on

74
00:02:45,239 --> 00:02:52,319
what I had seen and as I was wrapping

75
00:02:49,680 --> 00:02:54,840
that up a crash dump appeared on my desk

76
00:02:52,319 --> 00:02:57,089
a researcher that I was working fairly

77
00:02:54,840 --> 00:02:59,010
closely with at the time sent me a crash

78
00:02:57,090 --> 00:03:00,930
dump just as a friendly heads-up and

79
00:02:59,010 --> 00:03:02,940
told me that he would send me a POC

80
00:03:00,930 --> 00:03:08,400
shortly and maybe even work on an

81
00:03:02,940 --> 00:03:11,280
exploit now I didn't want to wait for a

82
00:03:08,400 --> 00:03:13,349
POC because this seemed pretty cool he

83
00:03:11,280 --> 00:03:16,109
had a crash in hyper-v and so I cracked

84
00:03:13,349 --> 00:03:18,000
open the crash dump and lo and behold

85
00:03:16,109 --> 00:03:19,410
the crash dump is actually in the

86
00:03:18,000 --> 00:03:21,720
emulated storage component which I've

87
00:03:19,410 --> 00:03:24,180
been working on and actually the crash

88
00:03:21,720 --> 00:03:26,900
dump is inside of this right data port

89
00:03:24,180 --> 00:03:30,690
function which looked questionable to me

90
00:03:26,900 --> 00:03:32,700
and when I went and looked at what was

91
00:03:30,690 --> 00:03:34,230
going on in that function there were a

92
00:03:32,700 --> 00:03:36,030
couple interesting things to me there

93
00:03:34,230 --> 00:03:38,280
was a buffer here it's called the track

94
00:03:36,030 --> 00:03:40,349
cache buffer and it's 64 kilobytes big

95
00:03:38,280 --> 00:03:43,019
and there's another variable called the

96
00:03:40,349 --> 00:03:44,730
dryest a buffer offset and this variable

97
00:03:43,019 --> 00:03:47,760
ends up getting added to the track hash

98
00:03:44,730 --> 00:03:50,668
buffer but this offset was way bigger

99
00:03:47,760 --> 00:03:53,340
than 64 kilobytes and so it appeared

100
00:03:50,669 --> 00:03:56,040
that this arithmetic that was being done

101
00:03:53,340 --> 00:03:58,739
on the pointer probably wasn't correct

102
00:03:56,040 --> 00:04:00,810
after all now we're gonna talk more

103
00:03:58,739 --> 00:04:02,609
about this in a second but before we

104
00:04:00,810 --> 00:04:04,139
talk more about it I want to give you at

105
00:04:02,609 --> 00:04:06,660
least some understanding as to what this

106
00:04:04,139 --> 00:04:08,400
component is and where it lives nico

107
00:04:06,660 --> 00:04:10,379
when i gave a talk at blackhat last year

108
00:04:08,400 --> 00:04:11,790
about hyper-v architecture so if you

109
00:04:10,379 --> 00:04:13,679
want to know all the gory details you

110
00:04:11,790 --> 00:04:15,150
should check that talk out for the

111
00:04:13,680 --> 00:04:16,500
purposes of this talk though what you

112
00:04:15,150 --> 00:04:19,108
need to know is that hyper-v is

113
00:04:16,500 --> 00:04:21,149
Microsoft's bare-metal hypervisor in

114
00:04:19,108 --> 00:04:23,270
hyper-v we have this concept of

115
00:04:21,149 --> 00:04:25,500
partitions and that just enforces

116
00:04:23,270 --> 00:04:26,669
isolation between the different virtual

117
00:04:25,500 --> 00:04:29,249
machines that are running on the

118
00:04:26,669 --> 00:04:31,080
the hypervisor one force that different

119
00:04:29,249 --> 00:04:32,819
virtual machines cannot interact with

120
00:04:31,080 --> 00:04:34,979
each other's physical memory using

121
00:04:32,819 --> 00:04:36,900
extended page tables and the hypervisor

122
00:04:34,979 --> 00:04:39,389
will intercept attempts to execute

123
00:04:36,900 --> 00:04:40,919
certain instructions like the in and out

124
00:04:39,389 --> 00:04:45,240
instruction which is used to talk

125
00:04:40,919 --> 00:04:46,349
directly to Hardware over i/o ports and

126
00:04:45,240 --> 00:04:47,819
if you try to execute some of those

127
00:04:46,349 --> 00:04:49,529
instructions then the hypervisor will

128
00:04:47,819 --> 00:04:52,319
just emulate them instead so that you

129
00:04:49,529 --> 00:04:55,199
can't end up doing harm to other virtual

130
00:04:52,319 --> 00:04:57,270
machines running on the system in hyper

131
00:04:55,199 --> 00:04:58,800
view we do have one special partition

132
00:04:57,270 --> 00:05:00,299
and that's called the root partition and

133
00:04:58,800 --> 00:05:02,969
it's where the host operating system

134
00:05:00,300 --> 00:05:05,279
lives the host operating system is

135
00:05:02,969 --> 00:05:06,509
effectively responsible for managing all

136
00:05:05,279 --> 00:05:08,610
the virtual machines that run on the

137
00:05:06,509 --> 00:05:11,189
system and one of the things that it

138
00:05:08,610 --> 00:05:12,960
does is it provides device simulation to

139
00:05:11,189 --> 00:05:16,710
those virtual machines if they need it

140
00:05:12,960 --> 00:05:19,198
and then that brings us to the IDE

141
00:05:16,710 --> 00:05:20,628
emulator or the emulated storage

142
00:05:19,199 --> 00:05:23,669
component I use both of those

143
00:05:20,629 --> 00:05:26,099
interchangeably what this diagram shows

144
00:05:23,669 --> 00:05:27,810
is that when the guest operating system

145
00:05:26,099 --> 00:05:29,729
goes and executes an in or out

146
00:05:27,810 --> 00:05:32,189
instruction to do an IO port read or

147
00:05:29,729 --> 00:05:34,680
write that will be intercepted by the

148
00:05:32,189 --> 00:05:36,839
hypervisor the hypervisor will forward

149
00:05:34,680 --> 00:05:39,210
that down to the host operating systems

150
00:05:36,839 --> 00:05:41,159
kernel and host operating systems kernel

151
00:05:39,210 --> 00:05:41,878
will forward that down to the VM worker

152
00:05:41,159 --> 00:05:44,669
process

153
00:05:41,879 --> 00:05:46,919
now there's one VM worker process for

154
00:05:44,669 --> 00:05:48,990
every virtual machine running on the

155
00:05:46,919 --> 00:05:50,580
system and that actually provides one

156
00:05:48,990 --> 00:05:53,460
really nice property for us which is

157
00:05:50,580 --> 00:05:55,289
that if you find a bug in code in the

158
00:05:53,460 --> 00:05:58,229
worker process that just allows you to

159
00:05:55,289 --> 00:06:00,960
crash the worker process that

160
00:05:58,229 --> 00:06:02,938
vulnerability only allows you to create

161
00:06:00,960 --> 00:06:04,409
a denial of service for your own virtual

162
00:06:02,939 --> 00:06:07,830
machine it doesn't actually impact

163
00:06:04,409 --> 00:06:10,199
anything else running on the system now

164
00:06:07,830 --> 00:06:12,389
the VM worker process is where a number

165
00:06:10,199 --> 00:06:13,800
of components live one of them is the

166
00:06:12,389 --> 00:06:17,099
instruction emulator which is

167
00:06:13,800 --> 00:06:18,839
responsible for decoding this i/o port

168
00:06:17,099 --> 00:06:20,610
read or write instruction and terminate

169
00:06:18,839 --> 00:06:22,379
what exactly you're trying to do and

170
00:06:20,610 --> 00:06:24,599
then the instruction emulator will end

171
00:06:22,379 --> 00:06:27,629
up forwarding for that forwarding that

172
00:06:24,599 --> 00:06:30,449
on to the appropriate device simulator

173
00:06:27,629 --> 00:06:32,189
in this case we can assume that it is

174
00:06:30,449 --> 00:06:34,709
going to the emulated storage device

175
00:06:32,189 --> 00:06:36,360
emulator and this is this consists of a

176
00:06:34,709 --> 00:06:39,330
couple components there is the IDE

177
00:06:36,360 --> 00:06:40,409
controller device there are two IDE

178
00:06:39,330 --> 00:06:42,688
channels that are at

179
00:06:40,409 --> 00:06:44,759
that controller device and each channel

180
00:06:42,689 --> 00:06:46,499
has two attachments attached to it and

181
00:06:44,759 --> 00:06:48,629
those attachments can either be hard

182
00:06:46,499 --> 00:06:50,369
drives or optical drives for the

183
00:06:48,629 --> 00:06:53,399
purposes of this talk I'm gonna be using

184
00:06:50,369 --> 00:06:53,999
hard drives and also for the purposes of

185
00:06:53,399 --> 00:06:55,830
this talk

186
00:06:53,999 --> 00:06:58,379
the only i/o ports that actually matter

187
00:06:55,830 --> 00:07:00,359
are one F zero through one F seven the

188
00:06:58,379 --> 00:07:02,399
emulated storage component does emulate

189
00:07:00,360 --> 00:07:06,499
a number of other i/o ports but they

190
00:07:02,399 --> 00:07:06,499
don't matter for this vulnerability

191
00:07:07,789 --> 00:07:13,378
let's talk more about the bug so as I

192
00:07:11,399 --> 00:07:15,689
mentioned I was already working on the

193
00:07:13,379 --> 00:07:19,169
emulated storage component when this

194
00:07:15,689 --> 00:07:21,629
crash dump was sent to us and rather

195
00:07:19,169 --> 00:07:23,248
than wait for the POC to come I decided

196
00:07:21,629 --> 00:07:24,659
I couldn't wait and I wanted to try to

197
00:07:23,249 --> 00:07:25,979
figure out what was actually going on

198
00:07:24,659 --> 00:07:28,169
here it was a little bit of a point of

199
00:07:25,979 --> 00:07:30,119
pride for me because I had clearly

200
00:07:28,169 --> 00:07:32,789
missed this bug when I had first looked

201
00:07:30,119 --> 00:07:34,169
at the function so I spent about half a

202
00:07:32,789 --> 00:07:35,909
day trying to figure out how I could

203
00:07:34,169 --> 00:07:40,409
force this condition to happen and after

204
00:07:35,909 --> 00:07:42,449
about half a day I had a POC created the

205
00:07:40,409 --> 00:07:44,550
vulnerability itself is inside of the

206
00:07:42,449 --> 00:07:47,399
state machine of the emulated storage

207
00:07:44,550 --> 00:07:50,039
device so it's not super straightforward

208
00:07:47,399 --> 00:07:52,289
to show you like a code snippet for like

209
00:07:50,039 --> 00:07:53,789
here's exactly where the bug is but

210
00:07:52,289 --> 00:07:55,829
effectively what was happening here is

211
00:07:53,789 --> 00:07:58,169
that the emulated storage component was

212
00:07:55,829 --> 00:07:59,999
supposed to enforce that this drive

213
00:07:58,169 --> 00:08:03,448
state buffer offset variable would never

214
00:07:59,999 --> 00:08:05,339
get too big and it wasn't enforcing that

215
00:08:03,449 --> 00:08:07,139
correctly so the way that you trigger

216
00:08:05,339 --> 00:08:09,569
the bug is first you do a couple of i/o

217
00:08:07,139 --> 00:08:13,019
port writes just to put this device in a

218
00:08:09,569 --> 00:08:15,479
desired state and then there's this loop

219
00:08:13,019 --> 00:08:17,039
here and it's in dark blue I can try to

220
00:08:15,479 --> 00:08:18,748
highlight this with my laser pointer

221
00:08:17,039 --> 00:08:22,259
this loop right here

222
00:08:18,749 --> 00:08:24,869
every time this loop executes it doesn't

223
00:08:22,259 --> 00:08:26,729
I Oh port right and every i/o port right

224
00:08:24,869 --> 00:08:28,679
that you execute there will end up

225
00:08:26,729 --> 00:08:32,370
incrementing the drive state buffer

226
00:08:28,679 --> 00:08:36,929
offset by 512 so the drive state buffer

227
00:08:32,370 --> 00:08:38,370
offset is always 512 byte aligned now

228
00:08:36,929 --> 00:08:40,438
there's two ways you can go

229
00:08:38,370 --> 00:08:43,198
the first way you can go is you can

230
00:08:40,438 --> 00:08:45,480
issue an i/o port right to port 1 f0 and

231
00:08:43,198 --> 00:08:47,699
when you do that that is going to

232
00:08:45,480 --> 00:08:50,639
trigger a write to the track cache

233
00:08:47,699 --> 00:08:52,410
buffer using this massive drive state

234
00:08:50,639 --> 00:08:53,940
buffer offset so even out of bounds

235
00:08:52,410 --> 00:08:55,170
right

236
00:08:53,940 --> 00:08:57,300
the other way you can go is you can do

237
00:08:55,170 --> 00:08:59,189
an IO port read from that same IO port

238
00:08:57,300 --> 00:09:00,810
and when you do that it will trigger a

239
00:08:59,190 --> 00:09:03,180
read from the tract cache buffer and it

240
00:09:00,810 --> 00:09:06,750
will return that data to you and you

241
00:09:03,180 --> 00:09:07,979
have an out-of-bounds read there if we

242
00:09:06,750 --> 00:09:09,840
look at the functions that are actually

243
00:09:07,980 --> 00:09:12,540
involved and this this is probably too

244
00:09:09,840 --> 00:09:13,680
small to read but I'm just going to talk

245
00:09:12,540 --> 00:09:16,020
through it and you can reference the

246
00:09:13,680 --> 00:09:17,609
slide later if you want to there's this

247
00:09:16,020 --> 00:09:19,290
function inside the emulated storage

248
00:09:17,610 --> 00:09:21,390
component and it's called write data

249
00:09:19,290 --> 00:09:23,310
port and this function has a couple of

250
00:09:21,390 --> 00:09:25,470
key variables it has the track cache

251
00:09:23,310 --> 00:09:27,180
buffer which is this pointer it has the

252
00:09:25,470 --> 00:09:29,850
drive state buffer offset which is this

253
00:09:27,180 --> 00:09:32,420
value that we can increment to to be out

254
00:09:29,850 --> 00:09:35,760
of bounds and that is a unsigned 32-bit

255
00:09:32,420 --> 00:09:39,000
value so you can increment that that

256
00:09:35,760 --> 00:09:40,260
value to be up to four gigabytes big and

257
00:09:39,000 --> 00:09:43,170
the other important variable here is

258
00:09:40,260 --> 00:09:45,930
this current byte variable and this is

259
00:09:43,170 --> 00:09:48,360
always between 0 and 512 gets

260
00:09:45,930 --> 00:09:51,060
incremented every time you read or write

261
00:09:48,360 --> 00:09:56,990
from the track cache buffer and once it

262
00:09:51,060 --> 00:09:59,369
hits 511 it will reset back down to 0

263
00:09:56,990 --> 00:10:01,260
now what this function ends up doing is

264
00:09:59,370 --> 00:10:03,060
it adds these variables together the

265
00:10:01,260 --> 00:10:06,300
buffer the drive state buffer offset and

266
00:10:03,060 --> 00:10:09,030
that current byte and it uses that as

267
00:10:06,300 --> 00:10:11,040
the destination for mmm copy and the

268
00:10:09,030 --> 00:10:12,990
source of the mem copy is the attacker

269
00:10:11,040 --> 00:10:15,390
controlled data that was specified to be

270
00:10:12,990 --> 00:10:17,670
used in the i/o port right so you have a

271
00:10:15,390 --> 00:10:20,370
relative write primitive here with a

272
00:10:17,670 --> 00:10:24,300
attacker controlled 32-bit offset and

273
00:10:20,370 --> 00:10:27,090
attack controlled data and just in case

274
00:10:24,300 --> 00:10:29,430
it isn't super clear the way that you

275
00:10:27,090 --> 00:10:31,860
end up having that full 32-bit offset

276
00:10:29,430 --> 00:10:33,630
under your control is the high 23 bits

277
00:10:31,860 --> 00:10:35,760
come from the drive state buffer offset

278
00:10:33,630 --> 00:10:38,580
because that's always going to be 512

279
00:10:35,760 --> 00:10:43,140
byte aligned and the low 9 bits come

280
00:10:38,580 --> 00:10:44,550
from the current byte now there's a

281
00:10:43,140 --> 00:10:46,260
corresponding function here it's called

282
00:10:44,550 --> 00:10:49,319
read data port it pretty much does the

283
00:10:46,260 --> 00:10:51,960
opposite thing it uses those same three

284
00:10:49,320 --> 00:10:53,430
variables to compute a pointer but

285
00:10:51,960 --> 00:10:55,710
instead of writing to that pointer it

286
00:10:53,430 --> 00:10:57,270
reads from the pointer and it copies

287
00:10:55,710 --> 00:11:00,000
that data into a buffer which will

288
00:10:57,270 --> 00:11:01,500
eventually be returned to the guest so

289
00:11:00,000 --> 00:11:06,920
this gives me a relative read primitive

290
00:11:01,500 --> 00:11:06,920
with a controlled unsigned 32-bit offset

291
00:11:07,680 --> 00:11:13,439
and one thing that was cool and a little

292
00:11:11,519 --> 00:11:14,970
bit unfortunate was that that version of

293
00:11:13,439 --> 00:11:17,309
the emulated storage stack that I had

294
00:11:14,970 --> 00:11:19,110
been porting GSL span into was not

295
00:11:17,309 --> 00:11:21,959
actually vulnerable to this bug because

296
00:11:19,110 --> 00:11:23,879
as soon as you run the POC the VM worker

297
00:11:21,959 --> 00:11:25,229
process would just immediately fast fail

298
00:11:23,879 --> 00:11:26,759
it would never let you go out of bounds

299
00:11:25,230 --> 00:11:28,709
and you would just crash your own

300
00:11:26,759 --> 00:11:31,050
virtual machine and nothing else on the

301
00:11:28,709 --> 00:11:32,339
host was impacted but of course we

302
00:11:31,050 --> 00:11:33,719
hadn't shipped it yet in fact I don't

303
00:11:32,339 --> 00:11:35,759
even think it had been checked in yet

304
00:11:33,720 --> 00:11:38,939
so that doesn't do us any good quite yet

305
00:11:35,759 --> 00:11:40,949
but it is still kind of interesting for

306
00:11:38,939 --> 00:11:42,629
us to see that proactive work we were

307
00:11:40,949 --> 00:11:46,559
doing was actually killing real bugs

308
00:11:42,629 --> 00:11:49,800
that people were finding so let's move

309
00:11:46,559 --> 00:11:52,199
on this bug looked awesome it's you know

310
00:11:49,800 --> 00:11:53,910
I have this 32-bit index that I control

311
00:11:52,199 --> 00:11:55,170
and I can read and write and so I

312
00:11:53,910 --> 00:11:56,910
figured I'd like to try to write an x

313
00:11:55,170 --> 00:11:59,729
plate for it and I figured I'd start

314
00:11:56,910 --> 00:12:01,559
with Server 2012 r2 because it was being

315
00:11:59,730 --> 00:12:03,119
used in cloud environments and also

316
00:12:01,559 --> 00:12:04,709
because I figured it would be easier

317
00:12:03,119 --> 00:12:06,269
than exploiting the latest version of

318
00:12:04,709 --> 00:12:10,229
Windows so it would be a little bit of a

319
00:12:06,269 --> 00:12:12,600
warm-up for me I had a few constraints

320
00:12:10,230 --> 00:12:14,610
with writing this exploit the first

321
00:12:12,600 --> 00:12:16,980
constraint is that the emulated storage

322
00:12:14,610 --> 00:12:19,110
path is slow and the way that I had

323
00:12:16,980 --> 00:12:22,589
written my POC made it even slower than

324
00:12:19,110 --> 00:12:24,660
it needed to be and so I figured that if

325
00:12:22,589 --> 00:12:27,179
the way that I was going to exploit this

326
00:12:24,660 --> 00:12:30,179
bug required me winning some weird

327
00:12:27,179 --> 00:12:33,110
timing or race condition between threads

328
00:12:30,179 --> 00:12:35,850
that's probably not gonna be practical

329
00:12:33,110 --> 00:12:38,519
I'm also limited to only using

330
00:12:35,850 --> 00:12:40,319
generation 1 Virtual Machines hyper-v

331
00:12:38,519 --> 00:12:42,870
has two generations of virtual machines

332
00:12:40,319 --> 00:12:44,248
the emulated storage stack is not

333
00:12:42,870 --> 00:12:46,199
supported on the second generation

334
00:12:44,249 --> 00:12:48,240
really all that that means is that I

335
00:12:46,199 --> 00:12:50,849
have a more limited set of devices that

336
00:12:48,240 --> 00:12:53,160
I can use to try to do things like keep

337
00:12:50,850 --> 00:12:56,249
massaging or build other primitives out

338
00:12:53,160 --> 00:12:59,969
of and of course the VM worker process

339
00:12:56,249 --> 00:13:03,179
is running with control flow guard and

340
00:12:59,970 --> 00:13:05,670
aslr and dep enabled and it is only a

341
00:13:03,179 --> 00:13:07,589
64-bit process you cannot have a 32-bit

342
00:13:05,670 --> 00:13:09,748
hyper-v hosts so the VM worker process

343
00:13:07,589 --> 00:13:11,309
will never be 32 bits and that's a

344
00:13:09,749 --> 00:13:13,709
little bit unfortunate for me because if

345
00:13:11,309 --> 00:13:15,870
it was a 32 bit process and I have a

346
00:13:13,709 --> 00:13:18,268
full control over a 32-bit unsigned

347
00:13:15,870 --> 00:13:20,129
index then I would just immediately have

348
00:13:18,269 --> 00:13:21,510
a full read/write primitive over the

349
00:13:20,129 --> 00:13:25,800
entire virtual address space of the

350
00:13:21,510 --> 00:13:27,840
process but that's not the case here so

351
00:13:25,800 --> 00:13:29,099
the first question that I had is where

352
00:13:27,840 --> 00:13:31,230
does the track cache buffer get

353
00:13:29,100 --> 00:13:33,240
allocated is it in the heap or is it

354
00:13:31,230 --> 00:13:36,360
somewhere else and it turns out that it

355
00:13:33,240 --> 00:13:38,790
is allocated using the virtual Alec API

356
00:13:36,360 --> 00:13:41,400
which is a bottom-up allocator in

357
00:13:38,790 --> 00:13:43,650
Windows and the allocations that are

358
00:13:41,400 --> 00:13:46,079
returned by virtual Alec are always 64

359
00:13:43,650 --> 00:13:48,510
kilobytes aligned and they are made

360
00:13:46,080 --> 00:13:50,130
sequentially to reduce fragmentation in

361
00:13:48,510 --> 00:13:51,990
the virtual address space so I have a

362
00:13:50,130 --> 00:13:53,220
little example here on the side where if

363
00:13:51,990 --> 00:13:55,860
you go and you make a whole bunch of

364
00:13:53,220 --> 00:13:58,710
virtual Alec allocations you will see

365
00:13:55,860 --> 00:14:00,240
that the address just grows 64 kilobytes

366
00:13:58,710 --> 00:14:02,100
at a time or if the allocation is bigger

367
00:14:00,240 --> 00:14:03,330
than 64 kilobytes then it grows by a

368
00:14:02,100 --> 00:14:05,700
larger amount at a time but they're all

369
00:14:03,330 --> 00:14:09,950
sequential and this gave me an idea

370
00:14:05,700 --> 00:14:13,380
which is that it might be possible that

371
00:14:09,950 --> 00:14:16,050
there is some interesting buffer that is

372
00:14:13,380 --> 00:14:18,390
allocated at some predictable offset

373
00:14:16,050 --> 00:14:20,550
from the track cache buffer because

374
00:14:18,390 --> 00:14:23,720
these allocations are all made in such a

375
00:14:20,550 --> 00:14:26,099
you know sequential and predictable way

376
00:14:23,720 --> 00:14:27,750
however it's not guaranteed that that's

377
00:14:26,100 --> 00:14:29,880
going to be the case because if there's

378
00:14:27,750 --> 00:14:31,560
multiple threads calling virtual Alec at

379
00:14:29,880 --> 00:14:33,270
a time then there can still be

380
00:14:31,560 --> 00:14:38,069
unpredictability and how things are laid

381
00:14:33,270 --> 00:14:39,990
out so what I did to figure out if this

382
00:14:38,070 --> 00:14:41,790
was the case or not is I just started

383
00:14:39,990 --> 00:14:44,190
turning virtual machines on and then I

384
00:14:41,790 --> 00:14:46,410
would use a VM map to go and dump the

385
00:14:44,190 --> 00:14:48,750
address space of the VM worker process

386
00:14:46,410 --> 00:14:51,959
and I did this over a whole bunch of

387
00:14:48,750 --> 00:14:53,880
reboots and every time that I would do

388
00:14:51,960 --> 00:14:55,710
it I would record what I was seeing and

389
00:14:53,880 --> 00:14:57,860
I created this memory layout

390
00:14:55,710 --> 00:14:59,640
generalization based off that data and

391
00:14:57,860 --> 00:15:02,640
there are a couple interesting things

392
00:14:59,640 --> 00:15:05,580
here that I noticed so near the top we

393
00:15:02,640 --> 00:15:06,750
have the track hash buffer and after the

394
00:15:05,580 --> 00:15:08,910
track cache buffer we had these

395
00:15:06,750 --> 00:15:10,500
allocations that I was I just refer to

396
00:15:08,910 --> 00:15:13,380
them as the miscellaneous allocations

397
00:15:10,500 --> 00:15:15,770
and it seemed to be typically anywhere

398
00:15:13,380 --> 00:15:18,300
from 64 kilobytes to 3 megabytes and

399
00:15:15,770 --> 00:15:21,810
this immediately kind of messes up my

400
00:15:18,300 --> 00:15:23,790
plan because none of these allocations

401
00:15:21,810 --> 00:15:25,680
look like good corruption targets and

402
00:15:23,790 --> 00:15:28,260
there was a totally variable number of

403
00:15:25,680 --> 00:15:30,270
them after that there was this buffer

404
00:15:28,260 --> 00:15:31,800
called the vram buffer it's 8 megabytes

405
00:15:30,270 --> 00:15:32,310
big and I'll talk more about that in a

406
00:15:31,800 --> 00:15:35,130
second

407
00:15:32,310 --> 00:15:36,540
that was followed by a stack

408
00:15:35,130 --> 00:15:38,490
and I call it the unreliable stack

409
00:15:36,540 --> 00:15:40,079
because it seemed to die a lot and so I

410
00:15:38,490 --> 00:15:42,510
didn't really want to try to corrupt it

411
00:15:40,080 --> 00:15:44,820
because it would just unmask itself a

412
00:15:42,510 --> 00:15:46,170
lot of the times then there was a heap

413
00:15:44,820 --> 00:15:48,090
it was a thousand eighty eight kilobytes

414
00:15:46,170 --> 00:15:49,920
it had a single allocation in it it

415
00:15:48,090 --> 00:15:52,440
wasn't a good corruption target there

416
00:15:49,920 --> 00:15:54,000
were a couple small allocations and then

417
00:15:52,440 --> 00:15:56,310
there was this floppy device

418
00:15:54,000 --> 00:15:58,110
eventlistener stack and one key

419
00:15:56,310 --> 00:15:59,939
observation I had here is that there

420
00:15:58,110 --> 00:16:01,740
seems to be a fixed offset between the

421
00:15:59,940 --> 00:16:05,180
end of that vram buffer and the start of

422
00:16:01,740 --> 00:16:05,180
the floppy device eventlistener stack

423
00:16:05,630 --> 00:16:10,439
now I was thinking that corrupting a

424
00:16:08,340 --> 00:16:12,060
stack would be great because if I

425
00:16:10,440 --> 00:16:13,800
corrupt a stack then I can just ignore

426
00:16:12,060 --> 00:16:16,619
control flow guard since it doesn't

427
00:16:13,800 --> 00:16:18,479
actually protect stacks but the issue is

428
00:16:16,620 --> 00:16:20,340
that there's no predictable offset

429
00:16:18,480 --> 00:16:21,990
between that track cache buffer and any

430
00:16:20,340 --> 00:16:24,540
of the stacks on the system because of

431
00:16:21,990 --> 00:16:27,690
these miscellaneous allocations that

432
00:16:24,540 --> 00:16:30,300
vary in size so much so I really needed

433
00:16:27,690 --> 00:16:33,680
to figure out if there was a reliable

434
00:16:30,300 --> 00:16:36,660
way that I could read and write stacks

435
00:16:33,680 --> 00:16:39,329
so I started looking at this vram buffer

436
00:16:36,660 --> 00:16:41,490
to figure out what it was and it turns

437
00:16:39,330 --> 00:16:44,700
out that this is what is known in

438
00:16:41,490 --> 00:16:47,250
hyper-v lingo as an aperture and all

439
00:16:44,700 --> 00:16:50,430
that an aperture is a shared section

440
00:16:47,250 --> 00:16:52,500
that map's guest physical memory and I'm

441
00:16:50,430 --> 00:16:54,030
of course running in the guest so I can

442
00:16:52,500 --> 00:16:56,430
go and write whatever I want in that

443
00:16:54,030 --> 00:16:57,870
physical memory and whenever I write

444
00:16:56,430 --> 00:17:00,209
data into that physical memory it

445
00:16:57,870 --> 00:17:02,970
immediately shows up inside of this vram

446
00:17:00,210 --> 00:17:05,130
buffer in the VM worker process so

447
00:17:02,970 --> 00:17:07,170
here's what I did I went and wrote a

448
00:17:05,130 --> 00:17:09,689
bunch of markers inside of that vram

449
00:17:07,170 --> 00:17:11,780
buffer and every marker just tells me

450
00:17:09,689 --> 00:17:13,800
how much of the vram buffer is left

451
00:17:11,780 --> 00:17:17,189
you'll see why this is useful in a

452
00:17:13,800 --> 00:17:18,990
second here the next thing I noticed is

453
00:17:17,189 --> 00:17:21,839
that since those miscellaneous

454
00:17:18,990 --> 00:17:24,180
allocations never seemed to be bigger

455
00:17:21,839 --> 00:17:26,579
than three megabytes but the vram buffer

456
00:17:24,180 --> 00:17:29,010
is eight megabytes big I could just

457
00:17:26,579 --> 00:17:30,720
index eight megabytes off the end of

458
00:17:29,010 --> 00:17:32,910
that track cache buffer and I would land

459
00:17:30,720 --> 00:17:34,710
somewhere in the vram buffer now I have

460
00:17:32,910 --> 00:17:36,480
no way to know exactly where I'm gonna

461
00:17:34,710 --> 00:17:40,440
land in it but I will land somewhere in

462
00:17:36,480 --> 00:17:43,740
it and so what I can do here is I can

463
00:17:40,440 --> 00:17:45,930
use my out-of-bounds read and go and

464
00:17:43,740 --> 00:17:47,820
read eight megabytes off the end of that

465
00:17:45,930 --> 00:17:49,800
buffer and then read them

466
00:17:47,820 --> 00:17:51,840
that I wrote into the vram buffer and

467
00:17:49,800 --> 00:17:54,629
that will tell me how far another vrn

468
00:17:51,840 --> 00:17:57,750
buffer I am once I know how far into the

469
00:17:54,630 --> 00:18:00,270
vram buffer I am I know how much further

470
00:17:57,750 --> 00:18:05,520
I need to read out of bounds to get to

471
00:18:00,270 --> 00:18:06,900
the end of that vram buffer and this

472
00:18:05,520 --> 00:18:08,639
gives me pretty much everything that I

473
00:18:06,900 --> 00:18:10,320
need to exploit the bug because there

474
00:18:08,640 --> 00:18:12,450
seemed to be a fixed offset between the

475
00:18:10,320 --> 00:18:14,939
end of the vram buffer and the start of

476
00:18:12,450 --> 00:18:16,590
the floppy device eventlistener stack so

477
00:18:14,940 --> 00:18:18,780
once I find the end of the vram buffer I

478
00:18:16,590 --> 00:18:20,220
now also know how far I need to read and

479
00:18:18,780 --> 00:18:22,560
right out of bounds to get to that stack

480
00:18:20,220 --> 00:18:26,490
and so I can go and I can read from the

481
00:18:22,560 --> 00:18:28,590
stack and leak the address of ntdll and

482
00:18:26,490 --> 00:18:31,290
kernel32 and then I can go and I can

483
00:18:28,590 --> 00:18:34,500
corrupt that stack and write a brought

484
00:18:31,290 --> 00:18:36,330
payload on it there was one little

485
00:18:34,500 --> 00:18:38,190
remaining issue here which is that the

486
00:18:36,330 --> 00:18:40,830
floppy device eventlistener stack needs

487
00:18:38,190 --> 00:18:43,560
to unwind before I can trigger my

488
00:18:40,830 --> 00:18:45,480
payload and this stack was always just

489
00:18:43,560 --> 00:18:48,510
sitting waiting for events to be

490
00:18:45,480 --> 00:18:51,990
signaled to it now nobody really uses

491
00:18:48,510 --> 00:18:53,640
floppy drives anymore and the only way

492
00:18:51,990 --> 00:18:55,260
that it seemed that events would be

493
00:18:53,640 --> 00:18:57,000
signaled to this is if you had a floppy

494
00:18:55,260 --> 00:19:00,000
drive plugged into your virtual machine

495
00:18:57,000 --> 00:19:01,980
and it was doing things but one thing I

496
00:19:00,000 --> 00:19:04,710
did realize is that if I restart the

497
00:19:01,980 --> 00:19:06,330
virtual machine that will also signal

498
00:19:04,710 --> 00:19:07,680
the floppy event device event listener

499
00:19:06,330 --> 00:19:09,240
stack because it will tell that stack

500
00:19:07,680 --> 00:19:12,390
hey the virtual machine is shutting down

501
00:19:09,240 --> 00:19:14,130
so the stack is going away and that will

502
00:19:12,390 --> 00:19:17,730
trigger the stack to unwind and that

503
00:19:14,130 --> 00:19:20,580
will then kick off my payload I have a

504
00:19:17,730 --> 00:19:22,140
little demo here the demos are all

505
00:19:20,580 --> 00:19:27,000
recorded because some of them take a

506
00:19:22,140 --> 00:19:28,980
little while to run but effectively what

507
00:19:27,000 --> 00:19:31,320
I'm doing here is I'm running on a 2012

508
00:19:28,980 --> 00:19:33,990
r2 host and I have this guest operating

509
00:19:31,320 --> 00:19:35,370
system here I run the exploit the first

510
00:19:33,990 --> 00:19:37,920
thing that it does is go and look for

511
00:19:35,370 --> 00:19:39,600
markers inside the vram buffer now it's

512
00:19:37,920 --> 00:19:41,520
found the markers in the vram buffer and

513
00:19:39,600 --> 00:19:44,010
so it's gonna go and read from the stack

514
00:19:41,520 --> 00:19:45,930
look for addresses and then it's gonna

515
00:19:44,010 --> 00:19:47,850
go and corrupt the stack with the

516
00:19:45,930 --> 00:19:50,610
payload that I've created now in this

517
00:19:47,850 --> 00:19:55,469
case the payload is just going to call

518
00:19:50,610 --> 00:19:57,209
win exec to pop calc so it's writing

519
00:19:55,470 --> 00:20:00,360
it's writing it takes a little takes a

520
00:19:57,210 --> 00:20:01,680
little while to do these writes but it's

521
00:20:00,360 --> 00:20:04,020
now finished writing

522
00:20:01,680 --> 00:20:05,850
and the exploit tells me helpfully that

523
00:20:04,020 --> 00:20:08,810
I now need to restart the virtual

524
00:20:05,850 --> 00:20:18,030
machine to actually trigger that payload

525
00:20:08,810 --> 00:20:19,470
and so I go and restart and then if you

526
00:20:18,030 --> 00:20:21,540
use process Explorer you can see that

527
00:20:19,470 --> 00:20:22,740
pop calyx it's in session zero so you

528
00:20:21,540 --> 00:20:25,680
don't actually see it on your desktop

529
00:20:22,740 --> 00:20:30,020
here but we do pop calc and it's running

530
00:20:25,680 --> 00:20:43,860
as the VM worker processes user account

531
00:20:30,020 --> 00:20:45,770
so that's great Oh alrighty so then I

532
00:20:43,860 --> 00:20:48,270
decided to set my sights on something

533
00:20:45,770 --> 00:20:49,560
hopefully more challenging which was the

534
00:20:48,270 --> 00:20:51,270
latest version of Windows at the time

535
00:20:49,560 --> 00:20:53,190
Windows 10 1709

536
00:20:51,270 --> 00:20:55,800
I believe the codename for this was

537
00:20:53,190 --> 00:20:59,480
redstone 3 it was not quite released yet

538
00:20:55,800 --> 00:21:02,280
but it was almost released at this point

539
00:20:59,480 --> 00:21:04,440
so the obvious question is what has

540
00:21:02,280 --> 00:21:06,240
changed right if I'm going after a new

541
00:21:04,440 --> 00:21:08,940
version of Windows can I just do the

542
00:21:06,240 --> 00:21:11,310
exact same thing or not now one big

543
00:21:08,940 --> 00:21:13,170
change that was made was as a result of

544
00:21:11,310 --> 00:21:16,129
an exploit that Jordan rabbit wrote

545
00:21:13,170 --> 00:21:18,990
who's on the OSR team and Microsoft

546
00:21:16,130 --> 00:21:21,480
stack stems and PEVs were no longer

547
00:21:18,990 --> 00:21:23,550
allocated anywhere near the rest of the

548
00:21:21,480 --> 00:21:25,890
bottom up allocations and windows which

549
00:21:23,550 --> 00:21:28,590
means they are not allocated anywhere

550
00:21:25,890 --> 00:21:31,200
near any allocation made using virtual

551
00:21:28,590 --> 00:21:33,240
outlook this means that I can no longer

552
00:21:31,200 --> 00:21:35,370
use my readwrite primitive to read and

553
00:21:33,240 --> 00:21:37,380
write to stacks so that immediately

554
00:21:35,370 --> 00:21:39,840
changes everything about the exploit

555
00:21:37,380 --> 00:21:41,190
effectively we also have more exploit

556
00:21:39,840 --> 00:21:43,230
mitigations that are applied in the

557
00:21:41,190 --> 00:21:45,810
latest version of Windows the vm worker

558
00:21:43,230 --> 00:21:47,520
process had AC G and C I G enabled and

559
00:21:45,810 --> 00:21:49,830
these are just two mitigations that

560
00:21:47,520 --> 00:21:51,540
effectively make it so that the process

561
00:21:49,830 --> 00:21:54,179
itself cannot allocate its own

562
00:21:51,540 --> 00:21:55,770
executable code pages and the only

563
00:21:54,180 --> 00:21:58,290
executable code pages that the kernel

564
00:21:55,770 --> 00:22:02,040
will map in our code pages that are

565
00:21:58,290 --> 00:22:03,690
signed by Microsoft we also have no

566
00:22:02,040 --> 00:22:06,030
child process enabled which means you

567
00:22:03,690 --> 00:22:07,530
can no longer spawn child processes and

568
00:22:06,030 --> 00:22:10,379
we have another mitigation enabled which

569
00:22:07,530 --> 00:22:14,918
prevents you from loading dll's

570
00:22:10,380 --> 00:22:16,179
that are from a network location and we

571
00:22:14,919 --> 00:22:17,830
have a number of control flow guard

572
00:22:16,179 --> 00:22:18,879
improvements that have been made a lot

573
00:22:17,830 --> 00:22:20,918
of these were reported through the

574
00:22:18,879 --> 00:22:23,738
hyper-v bounty or sorry not the hyper-v

575
00:22:20,919 --> 00:22:26,049
bounty but the the mitigations bounty

576
00:22:23,739 --> 00:22:29,679
that we have so we had we had done some

577
00:22:26,049 --> 00:22:31,418
work to harden CFG but really the big

578
00:22:29,679 --> 00:22:33,009
thing here was that since stacks were no

579
00:22:31,419 --> 00:22:34,239
longer allocated near me I was gonna

580
00:22:33,009 --> 00:22:39,220
have to change a lot about how I

581
00:22:34,239 --> 00:22:42,159
exploited this bug so I ended up doing

582
00:22:39,220 --> 00:22:44,619
the the same initial process of using vm

583
00:22:42,159 --> 00:22:47,230
map to go and create this memory layout

584
00:22:44,619 --> 00:22:48,759
generalization and a lot of it was the

585
00:22:47,230 --> 00:22:51,279
same there were a couple important

586
00:22:48,759 --> 00:22:54,669
things though one important thing is

587
00:22:51,279 --> 00:22:57,639
that most of the heaps in the vm worker

588
00:22:54,669 --> 00:22:59,590
process are allocated at a lower virtual

589
00:22:57,639 --> 00:23:02,219
address than the track hash buffer and

590
00:22:59,590 --> 00:23:06,908
that means I cannot read or write them

591
00:23:02,220 --> 00:23:08,980
however there was this one heap that I

592
00:23:06,909 --> 00:23:11,559
am going to refer to as the target heap

593
00:23:08,980 --> 00:23:15,039
for the purposes of this talk it was a

594
00:23:11,559 --> 00:23:16,720
four megabyte heap and I could read and

595
00:23:15,039 --> 00:23:18,940
write that from the track hash buffer

596
00:23:16,720 --> 00:23:20,950
using this out-of-bounds primitive that

597
00:23:18,940 --> 00:23:23,529
I had and the other nice thing is that

598
00:23:20,950 --> 00:23:28,029
this target heap also seemed to be at a

599
00:23:23,529 --> 00:23:30,039
fixed offset from the vram buffer now

600
00:23:28,029 --> 00:23:31,749
one thing that I that I quickly noticed

601
00:23:30,039 --> 00:23:34,239
was that I could use the exact same

602
00:23:31,749 --> 00:23:36,879
technique as before to find the vram

603
00:23:34,239 --> 00:23:37,899
buffer those allocations had not changed

604
00:23:36,879 --> 00:23:39,668
so there was the track cache buffer

605
00:23:37,899 --> 00:23:45,100
miscellaneous allocations and then a

606
00:23:39,669 --> 00:23:46,179
VRAM buffer so with this I had a couple

607
00:23:45,100 --> 00:23:48,459
ideas for how I could go about

608
00:23:46,179 --> 00:23:50,379
exploiting the bug the first thing that

609
00:23:48,460 --> 00:23:53,320
I really wanted to do was I wanted to

610
00:23:50,379 --> 00:23:55,539
find some interesting piece of data that

611
00:23:53,320 --> 00:23:57,070
I could corrupt so that I could boost my

612
00:23:55,539 --> 00:23:58,929
relative read/write primitive to

613
00:23:57,070 --> 00:24:01,689
arbitrary readwrite and I thought there

614
00:23:58,929 --> 00:24:03,249
was if I can get an arbitrary readwrite

615
00:24:01,690 --> 00:24:04,840
primitive then maybe I can leak the

616
00:24:03,249 --> 00:24:07,419
address of a stack and I could just go

617
00:24:04,840 --> 00:24:09,249
cur up the stack again and completely

618
00:24:07,419 --> 00:24:12,070
ignore completely ignore control flow

619
00:24:09,249 --> 00:24:14,379
guard so that seemed great the other

620
00:24:12,070 --> 00:24:16,509
idea I had was I could obviously go and

621
00:24:14,379 --> 00:24:18,820
just corrupt a function pointer and then

622
00:24:16,509 --> 00:24:20,379
I would have to confront control flow

623
00:24:18,820 --> 00:24:24,340
guard head-on I would have to find some

624
00:24:20,379 --> 00:24:25,658
way to bypass it but let's start with

625
00:24:24,340 --> 00:24:28,209
the first one because that's what I

626
00:24:25,659 --> 00:24:29,680
really wanted to make work

627
00:24:28,210 --> 00:24:31,630
first thing that I did was I started

628
00:24:29,680 --> 00:24:33,370
logging all of the heap allocations that

629
00:24:31,630 --> 00:24:35,290
were being made by the VM worker process

630
00:24:33,370 --> 00:24:38,080
so I would turn the virtual machine on

631
00:24:35,290 --> 00:24:40,420
let it run look at the call stack of all

632
00:24:38,080 --> 00:24:42,040
those allocations and look and see if

633
00:24:40,420 --> 00:24:44,350
any of those allocations look like they

634
00:24:42,040 --> 00:24:46,590
could be influenced by the guest like if

635
00:24:44,350 --> 00:24:48,939
I could spray a bunch of allocations and

636
00:24:46,590 --> 00:24:50,800
for any of those allocations then I

637
00:24:48,940 --> 00:24:53,020
wanted to see is there interesting data

638
00:24:50,800 --> 00:24:55,060
in them that if I corrupted I could

639
00:24:53,020 --> 00:24:58,000
boost myself to this arbitrary readwrite

640
00:24:55,060 --> 00:25:00,639
primitive and sadly for me this did not

641
00:24:58,000 --> 00:25:02,590
work out because as it turned out the VM

642
00:25:00,640 --> 00:25:05,620
worker process for a generation one

643
00:25:02,590 --> 00:25:08,080
virtual machine at least has effectively

644
00:25:05,620 --> 00:25:10,929
no ability to spray allocations on the

645
00:25:08,080 --> 00:25:12,820
heap almost all of the allocations are

646
00:25:10,930 --> 00:25:17,760
made up front when the virtual machine

647
00:25:12,820 --> 00:25:20,350
turns on and so it was just a dead end

648
00:25:17,760 --> 00:25:22,060
so I moved on and instead I figured that

649
00:25:20,350 --> 00:25:24,219
I would just go and look at that target

650
00:25:22,060 --> 00:25:26,139
heap and see if there were any out in

651
00:25:24,220 --> 00:25:27,940
any interesting allocations that were

652
00:25:26,140 --> 00:25:30,070
already allocated in the target heap

653
00:25:27,940 --> 00:25:31,750
that had a similar property of having

654
00:25:30,070 --> 00:25:33,280
some interesting piece of data that I

655
00:25:31,750 --> 00:25:35,470
could corrupt and then get an arbitrary

656
00:25:33,280 --> 00:25:37,420
readwrite primitive and one thing that I

657
00:25:35,470 --> 00:25:39,340
spent probably way too much time on but

658
00:25:37,420 --> 00:25:44,080
I just wanted it to work so bad was I

659
00:25:39,340 --> 00:25:45,699
wanted to find an emulator that had like

660
00:25:44,080 --> 00:25:47,919
the the class that implemented the

661
00:25:45,700 --> 00:25:51,760
emulator was allocated inside of that

662
00:25:47,920 --> 00:25:54,340
target heap because I figured if I did

663
00:25:51,760 --> 00:25:57,430
that then I could go and just corrupt

664
00:25:54,340 --> 00:26:00,159
the buffer that that emulator writes IO

665
00:25:57,430 --> 00:26:02,170
port writes into or that it retrieves

666
00:26:00,160 --> 00:26:03,910
i/o port reads from so if I corrupted

667
00:26:02,170 --> 00:26:05,950
that pointer then maybe I could just get

668
00:26:03,910 --> 00:26:08,920
arbitrary readwrite to anywhere in the

669
00:26:05,950 --> 00:26:10,930
address space but it didn't work out the

670
00:26:08,920 --> 00:26:13,030
emulators were effectively never

671
00:26:10,930 --> 00:26:14,380
allocated in this target heap so I

672
00:26:13,030 --> 00:26:16,360
couldn't corrupt the emulators

673
00:26:14,380 --> 00:26:18,010
themselves and I wasn't able to find

674
00:26:16,360 --> 00:26:20,800
anything else in the target heap that

675
00:26:18,010 --> 00:26:25,120
looked like an interesting target for

676
00:26:20,800 --> 00:26:27,070
data corruption okay so I ended up

677
00:26:25,120 --> 00:26:28,750
moving on this this didn't seem like it

678
00:26:27,070 --> 00:26:31,840
was going to work so I figured that

679
00:26:28,750 --> 00:26:33,040
rather than do a data corruption I was

680
00:26:31,840 --> 00:26:36,699
probably gonna have to just go and

681
00:26:33,040 --> 00:26:38,889
confront control flow guard but I

682
00:26:36,700 --> 00:26:40,420
figured maybe that would be easy maybe

683
00:26:38,890 --> 00:26:41,770
what I could do is I could go and just

684
00:26:40,420 --> 00:26:42,040
look at all the binaries that get loaded

685
00:26:41,770 --> 00:26:45,010
in

686
00:26:42,040 --> 00:26:48,280
the worker process and I could find a

687
00:26:45,010 --> 00:26:50,379
binary that was not compiled with

688
00:26:48,280 --> 00:26:51,520
control flow guard at all and if that

689
00:26:50,380 --> 00:26:53,670
was the case then I would have a whole

690
00:26:51,520 --> 00:26:55,930
bunch of unprotected indirect calls so

691
00:26:53,670 --> 00:26:58,900
that would make it hopefully pretty easy

692
00:26:55,930 --> 00:27:00,610
for me to bypass see if cheap but I did

693
00:26:58,900 --> 00:27:03,970
not find any binaries that were not

694
00:27:00,610 --> 00:27:05,889
compiled with control flow garden and I

695
00:27:03,970 --> 00:27:10,480
also wanted to see if I could just find

696
00:27:05,890 --> 00:27:13,810
some indirect calls maybe indirect calls

697
00:27:10,480 --> 00:27:15,130
that were written with assembly that

698
00:27:13,810 --> 00:27:16,540
we're missing control flow guard

699
00:27:15,130 --> 00:27:19,720
instrumentation on that specific

700
00:27:16,540 --> 00:27:21,639
indirect call and once again I hit a

701
00:27:19,720 --> 00:27:23,170
dead end here I could not find any

702
00:27:21,640 --> 00:27:25,570
indirect calls that were loaded into the

703
00:27:23,170 --> 00:27:28,720
worker process that were missing CFG

704
00:27:25,570 --> 00:27:31,389
instrumentation there were a couple of

705
00:27:28,720 --> 00:27:33,190
control flow got bypasses that existed

706
00:27:31,390 --> 00:27:36,040
in some of these binaries some of them

707
00:27:33,190 --> 00:27:38,620
were publicly known at the time however

708
00:27:36,040 --> 00:27:41,500
all of the bypasses that I found either

709
00:27:38,620 --> 00:27:45,070
required that I knew the address of my

710
00:27:41,500 --> 00:27:47,980
current stack which I do not or they

711
00:27:45,070 --> 00:27:50,290
required that I had to win some race

712
00:27:47,980 --> 00:27:52,060
condition between two threads so I had

713
00:27:50,290 --> 00:27:54,790
to get one thread to start executing

714
00:27:52,060 --> 00:27:57,730
down a code path and then I had to do a

715
00:27:54,790 --> 00:27:59,980
write at like a very specific time to

716
00:27:57,730 --> 00:28:01,090
race what that thread was doing and and

717
00:27:59,980 --> 00:28:04,360
that just seemed completely impractical

718
00:28:01,090 --> 00:28:05,620
with the primitive that I had so it

719
00:28:04,360 --> 00:28:07,120
looked like I wasn't gonna be able to

720
00:28:05,620 --> 00:28:12,850
get a super easy control flow guard

721
00:28:07,120 --> 00:28:15,129
bypass so I decided that rather than

722
00:28:12,850 --> 00:28:17,350
look for easy CFG bypasses what I was

723
00:28:15,130 --> 00:28:18,670
going to do was just try to abuse the

724
00:28:17,350 --> 00:28:20,709
coarse-grain nature of control flow

725
00:28:18,670 --> 00:28:23,440
guard and I was gonna make valid

726
00:28:20,710 --> 00:28:25,330
indirect calls that just gave me a

727
00:28:23,440 --> 00:28:27,370
little bit more control over the address

728
00:28:25,330 --> 00:28:32,620
space of the process maybe try to get a

729
00:28:27,370 --> 00:28:34,389
read/write primitive out of it but in

730
00:28:32,620 --> 00:28:37,209
order to do this I needed some building

731
00:28:34,390 --> 00:28:38,860
blocks so I started looking around and

732
00:28:37,210 --> 00:28:41,170
just looking for things that looked

733
00:28:38,860 --> 00:28:43,929
interesting that I could use to start

734
00:28:41,170 --> 00:28:46,300
building an exploit one of the first

735
00:28:43,930 --> 00:28:48,460
things I found was this class it's

736
00:28:46,300 --> 00:28:50,830
called the video dirt listener one

737
00:28:48,460 --> 00:28:52,240
really amazing thing about this class is

738
00:28:50,830 --> 00:28:54,610
that it's allocated in the target heap

739
00:28:52,240 --> 00:28:56,260
so I can corrupt it great that's like my

740
00:28:54,610 --> 00:28:57,820
first requirement right

741
00:28:56,260 --> 00:29:00,850
another nice thing about this class is

742
00:28:57,820 --> 00:29:02,770
that it has virtual functions now one

743
00:29:00,850 --> 00:29:04,689
downside is that those virtual functions

744
00:29:02,770 --> 00:29:06,970
are only triggered when the virtual

745
00:29:04,690 --> 00:29:08,529
machine reboots so I once again have the

746
00:29:06,970 --> 00:29:11,860
situation where I need to reboot the VM

747
00:29:08,529 --> 00:29:14,080
to trigger things but that's okay I can

748
00:29:11,860 --> 00:29:17,080
work with it another nice thing about

749
00:29:14,080 --> 00:29:20,350
this class is that it has a very large

750
00:29:17,080 --> 00:29:23,049
buffer inside of it it's over a page big

751
00:29:20,350 --> 00:29:24,939
and that matters because when you reboot

752
00:29:23,049 --> 00:29:27,309
the virtual machine a lot of the

753
00:29:24,940 --> 00:29:29,649
allocations that are in the heap have

754
00:29:27,309 --> 00:29:31,178
already been freed by the time virtual

755
00:29:29,649 --> 00:29:33,428
functions in this class have been called

756
00:29:31,179 --> 00:29:35,740
and if you're gonna try to execute some

757
00:29:33,429 --> 00:29:38,649
sort of payload you need to be sure that

758
00:29:35,740 --> 00:29:41,080
your payload still exists when you go to

759
00:29:38,649 --> 00:29:44,590
execute it so the fact that this class

760
00:29:41,080 --> 00:29:46,120
both had a virtual function table and it

761
00:29:44,590 --> 00:29:49,090
had this massive buffer work at store

762
00:29:46,120 --> 00:29:51,340
payload was great and then the other

763
00:29:49,090 --> 00:29:54,309
thing is that I can find the address of

764
00:29:51,340 --> 00:29:56,490
comm based DLL and RPC RT for DLL inside

765
00:29:54,309 --> 00:29:58,450
of the target heap

766
00:29:56,490 --> 00:30:00,039
unfortunately for me I could not find

767
00:29:58,450 --> 00:30:01,990
the address of kernel base inside the

768
00:30:00,039 --> 00:30:05,740
target key and I'll talk more about why

769
00:30:01,990 --> 00:30:07,840
that matters in a minute the video dirt

770
00:30:05,740 --> 00:30:09,190
listener object itself it's actually

771
00:30:07,840 --> 00:30:10,720
pretty complicated it has a lot of

772
00:30:09,190 --> 00:30:12,549
things but for the purposes of this talk

773
00:30:10,720 --> 00:30:14,289
there's only two things that matter at

774
00:30:12,549 --> 00:30:16,450
offset 150 there's a V table and

775
00:30:14,289 --> 00:30:18,580
immediately following that V table is

776
00:30:16,450 --> 00:30:20,620
this massive page size buffer that is

777
00:30:18,580 --> 00:30:22,449
completely unused during normal VM

778
00:30:20,620 --> 00:30:28,928
operation so I am free to write whatever

779
00:30:22,450 --> 00:30:31,539
I want into it the next building block

780
00:30:28,929 --> 00:30:33,220
that I found was this cool CFG gadget

781
00:30:31,539 --> 00:30:35,590
I'm just going to refer to it as the

782
00:30:33,220 --> 00:30:37,419
looping in direct caller this there's

783
00:30:35,590 --> 00:30:41,168
this function it's called revert changes

784
00:30:37,419 --> 00:30:42,909
it is a valid indirect call target so if

785
00:30:41,169 --> 00:30:45,730
you hijack a function pointer you can

786
00:30:42,909 --> 00:30:48,789
call this function what this function

787
00:30:45,730 --> 00:30:52,149
does is it takes a contact structure it

788
00:30:48,789 --> 00:30:54,399
follows a list head field inside of that

789
00:30:52,149 --> 00:30:56,610
context structure and loop through a

790
00:30:54,399 --> 00:31:00,580
linked list of these node structures on

791
00:30:56,610 --> 00:31:03,158
every node structure it makes a virtual

792
00:31:00,580 --> 00:31:04,780
function call it does not pass any

793
00:31:03,159 --> 00:31:07,929
parameters to the virtual function call

794
00:31:04,780 --> 00:31:09,100
except for the implied this pointer that

795
00:31:07,929 --> 00:31:11,799
is always passed

796
00:31:09,100 --> 00:31:13,659
you virtual function calls and then it

797
00:31:11,799 --> 00:31:15,580
just keeps looping through the list so

798
00:31:13,660 --> 00:31:17,799
this effectively this effectively gives

799
00:31:15,580 --> 00:31:22,659
me the ability to make an unlimited

800
00:31:17,799 --> 00:31:25,000
unlimited number of indirect calls so

801
00:31:22,660 --> 00:31:26,590
what I can do here is I can have this

802
00:31:25,000 --> 00:31:28,690
video dirt listener object and I can

803
00:31:26,590 --> 00:31:30,939
overlay this context structure into it

804
00:31:28,690 --> 00:31:32,919
such that when the virtual function call

805
00:31:30,940 --> 00:31:34,480
is made on the video dirt listener it

806
00:31:32,919 --> 00:31:37,690
actually calls this river changes

807
00:31:34,480 --> 00:31:39,520
function and that kicks off this loop

808
00:31:37,690 --> 00:31:42,190
where I get to make an unlimited number

809
00:31:39,520 --> 00:31:43,389
of virtual function calls so that's

810
00:31:42,190 --> 00:31:45,010
great I've kind of boosted my

811
00:31:43,390 --> 00:31:47,409
capabilities a little bit right instead

812
00:31:45,010 --> 00:31:49,090
of only being able to make one virtual

813
00:31:47,409 --> 00:31:50,770
function call when the virtual machine

814
00:31:49,090 --> 00:31:55,030
reboots I can now make an unlimited

815
00:31:50,770 --> 00:31:56,260
number unfortunately I don't control the

816
00:31:55,030 --> 00:31:59,020
parameters of any of those virtual

817
00:31:56,260 --> 00:32:01,179
function calls and so it it's not super

818
00:31:59,020 --> 00:32:02,950
useful for me right now but luckily for

819
00:32:01,179 --> 00:32:04,750
me Tomas Garnier has already done some

820
00:32:02,950 --> 00:32:06,340
research in this area and he found that

821
00:32:04,750 --> 00:32:08,530
there's this really interesting function

822
00:32:06,340 --> 00:32:11,020
in the RPC runtime of Windows called ndr

823
00:32:08,530 --> 00:32:13,330
server call 2 and what this function

824
00:32:11,020 --> 00:32:16,539
does it takes a single parameter this

825
00:32:13,330 --> 00:32:18,780
parameter and when the function is

826
00:32:16,539 --> 00:32:22,480
called it will use that parameter to

827
00:32:18,780 --> 00:32:23,830
deserialize some data structures and it

828
00:32:22,480 --> 00:32:26,350
will deserialize those data structures

829
00:32:23,830 --> 00:32:28,539
into the address of a function to call

830
00:32:26,350 --> 00:32:30,789
indirectly now this function needs to be

831
00:32:28,539 --> 00:32:32,559
a valid indirect call target but it will

832
00:32:30,789 --> 00:32:35,049
it'll take that address of that function

833
00:32:32,559 --> 00:32:37,570
and will also deserialize a list of

834
00:32:35,049 --> 00:32:40,440
arguments and you control the number of

835
00:32:37,570 --> 00:32:44,500
arguments and the value of the arguments

836
00:32:40,440 --> 00:32:47,320
so what this means is that I have now a

837
00:32:44,500 --> 00:32:48,970
primitive that will allow me to loop

838
00:32:47,320 --> 00:32:51,939
through and make an unlimited number of

839
00:32:48,970 --> 00:32:54,640
indirect calls but also using this ndr

840
00:32:51,940 --> 00:32:56,470
server call to technique I can have full

841
00:32:54,640 --> 00:32:58,240
control over the number of parameters

842
00:32:56,470 --> 00:33:01,150
and the value of the parameters that are

843
00:32:58,240 --> 00:33:02,230
made to those function calls and really

844
00:33:01,150 --> 00:33:04,210
what this diagram is just illustrating

845
00:33:02,230 --> 00:33:06,580
is that we have these node structures

846
00:33:04,210 --> 00:33:08,650
that we loop through and we overlay an

847
00:33:06,580 --> 00:33:10,360
RPC message structure on top of it which

848
00:33:08,650 --> 00:33:13,030
is the structure that the ndr server

849
00:33:10,360 --> 00:33:15,309
call to function is expecting the first

850
00:33:13,030 --> 00:33:17,408
parameter of both of these structures

851
00:33:15,309 --> 00:33:20,200
the node and the RPC message is a V

852
00:33:17,409 --> 00:33:22,600
table so that aligns well and the only

853
00:33:20,200 --> 00:33:25,090
other parameter that actually matters in

854
00:33:22,600 --> 00:33:27,939
node structure to do this looping

855
00:33:25,090 --> 00:33:32,439
through a linked list is a next field

856
00:33:27,940 --> 00:33:35,679
which is an offset 58 but the RPC

857
00:33:32,440 --> 00:33:38,799
message itself is only hex 50 bytes big

858
00:33:35,679 --> 00:33:41,260
which means that you can safely overlay

859
00:33:38,799 --> 00:33:46,150
these two structures and none of the

860
00:33:41,260 --> 00:33:48,370
fields conflict with each other alright

861
00:33:46,150 --> 00:33:51,520
the last gadget that I found that I

862
00:33:48,370 --> 00:33:52,928
needed was this mem copy gadget so this

863
00:33:51,520 --> 00:33:55,270
is once again a function that is an

864
00:33:52,929 --> 00:33:57,309
indirect call target and it uses the

865
00:33:55,270 --> 00:34:00,639
parameters that are passed to it to make

866
00:33:57,309 --> 00:34:02,830
a call to mem copy and what this ends up

867
00:34:00,640 --> 00:34:04,450
giving me is an arbitrary read/write

868
00:34:02,830 --> 00:34:06,639
primitive because I control the source

869
00:34:04,450 --> 00:34:09,668
the destination and the size of that

870
00:34:06,640 --> 00:34:13,030
call to mem copy however there is this

871
00:34:09,668 --> 00:34:15,850
Evette that I can only are caveat that I

872
00:34:13,030 --> 00:34:20,879
that I can only make this call to mem

873
00:34:15,850 --> 00:34:20,879
copy when the virtual machine reboots

874
00:34:23,399 --> 00:34:29,799
but I figure with this I can probably

875
00:34:27,090 --> 00:34:31,600
get a working exploit the strategy that

876
00:34:29,800 --> 00:34:33,010
I figured I'd use is first I'm going to

877
00:34:31,600 --> 00:34:35,080
get this arbitrary read/write primitive

878
00:34:33,010 --> 00:34:38,050
and I get that using this mem copy

879
00:34:35,080 --> 00:34:40,540
gadget then I need to leak the address

880
00:34:38,050 --> 00:34:41,830
of kernel base and the reason I need to

881
00:34:40,540 --> 00:34:43,359
leak the address of kernel base is

882
00:34:41,830 --> 00:34:46,000
because I want to call the function

883
00:34:43,359 --> 00:34:47,949
virtual protect I'm going to use virtual

884
00:34:46,000 --> 00:34:50,980
protect to make the control flow guard

885
00:34:47,949 --> 00:34:53,230
check function pointer writable this is

886
00:34:50,980 --> 00:34:55,240
the function that gets called every time

887
00:34:53,230 --> 00:34:57,670
you need to validate if some function is

888
00:34:55,239 --> 00:34:59,169
a valid indirect call target or not so I

889
00:34:57,670 --> 00:35:01,300
make that function pointer writable and

890
00:34:59,170 --> 00:35:03,670
then I override it with a function that

891
00:35:01,300 --> 00:35:07,150
always returns yes this is a valid

892
00:35:03,670 --> 00:35:08,320
indirect call target and then once

893
00:35:07,150 --> 00:35:09,040
control flow guard is effectively

894
00:35:08,320 --> 00:35:10,750
neutralized

895
00:35:09,040 --> 00:35:12,640
I can make indirect calls anywhere I

896
00:35:10,750 --> 00:35:16,690
want so I can make an indirect call to

897
00:35:12,640 --> 00:35:17,980
kick off a rope chain so that's exactly

898
00:35:16,690 --> 00:35:19,780
what I did the first thing I need to do

899
00:35:17,980 --> 00:35:21,580
of course is I need to read the target

900
00:35:19,780 --> 00:35:23,980
heap and I need to find the address of

901
00:35:21,580 --> 00:35:25,990
RPC rt4 com base and the video dirt

902
00:35:23,980 --> 00:35:29,830
listener object and it's worth noting

903
00:35:25,990 --> 00:35:32,229
that well these these offsets are

904
00:35:29,830 --> 00:35:33,819
typically fixed so like the offset

905
00:35:32,230 --> 00:35:36,400
between the vram buffer and the target

906
00:35:33,820 --> 00:35:40,059
heap is typically fixed it's

907
00:35:36,400 --> 00:35:45,160
100% of the time so so this will fail

908
00:35:40,059 --> 00:35:46,779
sometimes and you know the the video

909
00:35:45,160 --> 00:35:48,730
dirt listener object itself is not

910
00:35:46,779 --> 00:35:50,170
always allocated in target keep and if

911
00:35:48,730 --> 00:35:52,299
it's not allocated in the target heap

912
00:35:50,170 --> 00:35:54,609
then I need to restart the VM and try

913
00:35:52,299 --> 00:35:56,680
again and every time I have to restart

914
00:35:54,609 --> 00:35:58,538
the VM and try again that's just one

915
00:35:56,680 --> 00:36:00,129
more chance for this whole thing to fail

916
00:35:58,539 --> 00:36:01,779
right because I'm gonna have to go and

917
00:36:00,130 --> 00:36:04,210
refine the target heap but it might not

918
00:36:01,779 --> 00:36:06,069
actually be there and then I crash so

919
00:36:04,210 --> 00:36:08,410
it's worth calling out that this is

920
00:36:06,069 --> 00:36:13,450
actually less reliable than the previous

921
00:36:08,410 --> 00:36:15,098
exploit anyway so I go I find these

922
00:36:13,450 --> 00:36:16,538
addresses and the next thing I'm going

923
00:36:15,099 --> 00:36:18,339
to do is I need to create this mem copy

924
00:36:16,539 --> 00:36:20,589
payload so that I can have my arbitrary

925
00:36:18,339 --> 00:36:22,930
readwrite but there's a problem just

926
00:36:20,589 --> 00:36:25,210
that this is triggered when the virtual

927
00:36:22,930 --> 00:36:27,399
machine is rebooting and the trap cache

928
00:36:25,210 --> 00:36:29,349
buffer and the vram buffer are both

929
00:36:27,400 --> 00:36:31,599
going to be freed as part of the virtual

930
00:36:29,349 --> 00:36:32,980
machine rebooting most of the

931
00:36:31,599 --> 00:36:34,089
allocations in the target he are going

932
00:36:32,980 --> 00:36:37,930
to be freed as part of the virtual

933
00:36:34,089 --> 00:36:42,339
machine rebooting and I am NOT I have no

934
00:36:37,930 --> 00:36:44,558
ability to interact with the with the VM

935
00:36:42,339 --> 00:36:46,859
worker process while that payload is

936
00:36:44,559 --> 00:36:50,200
executing because when I restart the VM

937
00:36:46,859 --> 00:36:52,538
all of the virtual processors of that VM

938
00:36:50,200 --> 00:36:54,220
are stopped and so I just have to wait

939
00:36:52,539 --> 00:36:56,140
for this payload to execute and then

940
00:36:54,220 --> 00:36:58,240
when the virtual machine reboots that

941
00:36:56,140 --> 00:37:02,890
mem copy better have copied the data to

942
00:36:58,240 --> 00:37:04,149
someplace that I can read it now one

943
00:37:02,890 --> 00:37:06,009
convenient thing for me is that while

944
00:37:04,150 --> 00:37:08,470
most of those target heap allocations

945
00:37:06,010 --> 00:37:11,319
get freed the target heap itself does

946
00:37:08,470 --> 00:37:12,848
not get freed and the target heap starts

947
00:37:11,319 --> 00:37:15,308
with this structure it's called the heap

948
00:37:12,849 --> 00:37:18,190
segment header and inside of that heap

949
00:37:15,309 --> 00:37:20,799
segment header there is a field that is

950
00:37:18,190 --> 00:37:22,569
not used at least when the VM worker

951
00:37:20,799 --> 00:37:26,859
process is running it's eight bytes big

952
00:37:22,569 --> 00:37:29,020
and so so that's a place where I could

953
00:37:26,859 --> 00:37:31,839
copy data and it will persist the VM

954
00:37:29,020 --> 00:37:34,450
rebooting when the VM turns back on that

955
00:37:31,839 --> 00:37:36,220
target heap heap segment will still

956
00:37:34,450 --> 00:37:39,730
exist and it will have the data that was

957
00:37:36,220 --> 00:37:43,029
copied there so I use this mem copy

958
00:37:39,730 --> 00:37:44,890
payload to go and copy data into the

959
00:37:43,029 --> 00:37:48,880
target heap and the data that I'm going

960
00:37:44,890 --> 00:37:50,129
to copy there is the is it's an IAT

961
00:37:48,880 --> 00:37:53,250
entry from Rp

962
00:37:50,130 --> 00:37:55,349
TRT four and it's an IP or it's an IAT

963
00:37:53,250 --> 00:37:57,569
entry for Colonel base for a colonel

964
00:37:55,349 --> 00:37:59,819
base function so this effectively allows

965
00:37:57,569 --> 00:38:02,160
me to leak the address of Colonel base

966
00:37:59,819 --> 00:38:03,960
so I restart the virtual machine that

967
00:38:02,160 --> 00:38:06,058
address gets copied in the target heat

968
00:38:03,960 --> 00:38:07,950
and then when the virtual machine

969
00:38:06,059 --> 00:38:11,279
reboots the track cache buffer and the

970
00:38:07,950 --> 00:38:14,220
vram buffer get reallocated and luckily

971
00:38:11,279 --> 00:38:16,710
for me those bottom-up allocations that

972
00:38:14,220 --> 00:38:18,538
are made by virtual alik are very

973
00:38:16,710 --> 00:38:20,430
predictable right because we want to

974
00:38:18,539 --> 00:38:22,529
have very minimal fragmentation in the

975
00:38:20,430 --> 00:38:24,058
address space and that means that the

976
00:38:22,529 --> 00:38:26,220
track cache buffer and the vram buffer

977
00:38:24,059 --> 00:38:27,630
are usually going to be reallocated in

978
00:38:26,220 --> 00:38:29,879
the exact same spot that they were

979
00:38:27,630 --> 00:38:32,400
before which means that I can then

980
00:38:29,880 --> 00:38:36,809
trigger the bug again I can do this out

981
00:38:32,400 --> 00:38:40,109
of bounds read and I can go and read the

982
00:38:36,809 --> 00:38:42,059
target heap and I can read that Colonel

983
00:38:40,109 --> 00:38:45,058
base address out of the the heap segment

984
00:38:42,059 --> 00:38:47,549
header I also need to rescan the target

985
00:38:45,059 --> 00:38:49,079
heap to find a new video dirt listener

986
00:38:47,549 --> 00:38:52,529
object because the video dirt listeners

987
00:38:49,079 --> 00:38:54,150
all got freed and then reallocated so I

988
00:38:52,529 --> 00:38:56,730
find that new video dirt listener object

989
00:38:54,150 --> 00:38:58,680
and now that I know the address of the

990
00:38:56,730 --> 00:39:00,660
colonel base dll I can compute the

991
00:38:58,680 --> 00:39:03,240
address that the virtual protect

992
00:39:00,660 --> 00:39:04,529
function is located inside of it if you

993
00:39:03,240 --> 00:39:06,450
wanted to be a little bit more

994
00:39:04,529 --> 00:39:09,990
professional I guess you would probably

995
00:39:06,450 --> 00:39:12,390
go and read the export address table of

996
00:39:09,990 --> 00:39:14,008
the colonel base DLL so that you

997
00:39:12,390 --> 00:39:17,990
wouldn't need to have hard-coded offsets

998
00:39:14,009 --> 00:39:17,990
but I didn't have time to do that now

999
00:39:19,069 --> 00:39:23,549
that I know the address of the virtual

1000
00:39:21,569 --> 00:39:25,920
protect function I'm going to create my

1001
00:39:23,549 --> 00:39:27,900
final payload what this payload is going

1002
00:39:25,920 --> 00:39:30,329
to do is it's going to first call

1003
00:39:27,900 --> 00:39:32,369
virtual protect and the reason that I

1004
00:39:30,329 --> 00:39:36,930
can call virtual protect is because it

1005
00:39:32,369 --> 00:39:41,450
is a dll export and by default all DLL

1006
00:39:36,930 --> 00:39:43,589
exports are valid in direct call targets

1007
00:39:41,450 --> 00:39:45,210
so I'm going to call virtual protect

1008
00:39:43,589 --> 00:39:47,578
with parameters I control to make that

1009
00:39:45,210 --> 00:39:50,160
CFG check function pointer writable I'm

1010
00:39:47,579 --> 00:39:52,440
going to use the mem copy gadget to

1011
00:39:50,160 --> 00:39:55,170
overwrite the CFG check function pointer

1012
00:39:52,440 --> 00:39:56,910
with a no op function and now that

1013
00:39:55,170 --> 00:40:00,599
control flow guard is neutralized I can

1014
00:39:56,910 --> 00:40:02,460
go ahead and kick off a rope chain so I

1015
00:40:00,599 --> 00:40:03,990
used a relative read pipe I use the

1016
00:40:02,460 --> 00:40:05,700
relative write primitive to go and

1017
00:40:03,990 --> 00:40:09,629
right the new video dirt listener object

1018
00:40:05,700 --> 00:40:12,689
with this payload and I guess it's worth

1019
00:40:09,630 --> 00:40:15,000
mentioning that this payload was fairly

1020
00:40:12,690 --> 00:40:16,530
simple due to all of the explanations

1021
00:40:15,000 --> 00:40:19,320
that have been applied to the VM worker

1022
00:40:16,530 --> 00:40:22,860
process any payload you write has to be

1023
00:40:19,320 --> 00:40:25,830
full Rob and I didn't really have time

1024
00:40:22,860 --> 00:40:28,590
to go and create a super complicated raw

1025
00:40:25,830 --> 00:40:30,900
payload and so I opted to do something a

1026
00:40:28,590 --> 00:40:32,430
bit easier which is that I just wrote a

1027
00:40:30,900 --> 00:40:34,290
raw payload that would go and create a

1028
00:40:32,430 --> 00:40:36,180
new folder on the hard drive just that I

1029
00:40:34,290 --> 00:40:40,470
could demonstrate that I do in fact have

1030
00:40:36,180 --> 00:40:47,819
arbitrary code execution go ahead and

1031
00:40:40,470 --> 00:40:49,560
demo this one now so I'm once again

1032
00:40:47,820 --> 00:40:52,140
going to run this exploit but now I'm

1033
00:40:49,560 --> 00:40:53,820
running on a 1709 host and the screen is

1034
00:40:52,140 --> 00:40:55,859
gonna shift in a second here and that's

1035
00:40:53,820 --> 00:40:57,780
because reading the whole heap takes

1036
00:40:55,860 --> 00:40:59,010
quite a while with this exploit and I

1037
00:40:57,780 --> 00:41:00,570
don't think that everyone wants to sit

1038
00:40:59,010 --> 00:41:04,470
here for 20 minutes watching this thing

1039
00:41:00,570 --> 00:41:06,450
scan the heap so I fast forward so yep

1040
00:41:04,470 --> 00:41:08,970
the window shifts we fast forwarded it's

1041
00:41:06,450 --> 00:41:11,460
almost done reading the heap and it's

1042
00:41:08,970 --> 00:41:14,520
presumably going to find the ARP CRT for

1043
00:41:11,460 --> 00:41:17,220
address the com base address and a video

1044
00:41:14,520 --> 00:41:24,960
direct listener object address and it

1045
00:41:17,220 --> 00:41:26,368
does so now I'm going to start

1046
00:41:24,960 --> 00:41:28,170
corrupting that video turret listener

1047
00:41:26,369 --> 00:41:30,960
object so it's going to build the

1048
00:41:28,170 --> 00:41:34,770
payload that will end up leaking the

1049
00:41:30,960 --> 00:41:36,960
kernel base address for me that payload

1050
00:41:34,770 --> 00:41:38,369
has been written so we need to restart

1051
00:41:36,960 --> 00:41:44,460
the virtual machine to kick that payload

1052
00:41:38,369 --> 00:41:46,500
off alright so the virtual machine has

1053
00:41:44,460 --> 00:41:49,890
rebooted now and then the next thing

1054
00:41:46,500 --> 00:41:51,510
that we need to do is go and recover the

1055
00:41:49,890 --> 00:41:53,310
kernel based address that was leapt and

1056
00:41:51,510 --> 00:41:55,260
then build this second payload which

1057
00:41:53,310 --> 00:42:00,029
neutralizes control flow guard and kicks

1058
00:41:55,260 --> 00:42:01,530
off the raw payload so once again it

1059
00:42:00,030 --> 00:42:02,970
needs to go and read the heap so I'm

1060
00:42:01,530 --> 00:42:05,700
going to fast forward here so that we're

1061
00:42:02,970 --> 00:42:06,990
not here all day it finds everything it

1062
00:42:05,700 --> 00:42:08,580
needs it finds the video turret listener

1063
00:42:06,990 --> 00:42:14,189
object it finds the address of kernel

1064
00:42:08,580 --> 00:42:15,750
base and then it's going to go and write

1065
00:42:14,190 --> 00:42:18,170
this next payload into the video dirt

1066
00:42:15,750 --> 00:42:18,170
listener object

1067
00:42:23,240 --> 00:42:28,919
and it takes a little while

1068
00:42:27,089 --> 00:42:32,130
the ndr server called to technique

1069
00:42:28,920 --> 00:42:34,170
requires I think around a thousand bytes

1070
00:42:32,130 --> 00:42:36,630
per virtual call that you want to make

1071
00:42:34,170 --> 00:42:39,359
and my primitive is fairly slow for

1072
00:42:36,630 --> 00:42:40,829
writing so writing about 3,000 bytes

1073
00:42:39,359 --> 00:42:43,049
takes a bit of time because I mean I'm

1074
00:42:40,829 --> 00:42:45,690
making three virtual calls but I

1075
00:42:43,049 --> 00:42:48,210
finished writing and I restart the

1076
00:42:45,690 --> 00:42:49,740
virtual machine again and the payload

1077
00:42:48,210 --> 00:42:51,990
will get kicked off and I've created a

1078
00:42:49,740 --> 00:43:06,508
new folder on the C Drive so I have

1079
00:42:51,990 --> 00:43:07,979
arbitrary code execution now the VM

1080
00:43:06,509 --> 00:43:10,920
worker process was originally designed

1081
00:43:07,980 --> 00:43:12,569
with least privilege in mind however it

1082
00:43:10,920 --> 00:43:15,509
was it was built quite a while ago and

1083
00:43:12,569 --> 00:43:17,009
so it it doesn't have all of the latest

1084
00:43:15,509 --> 00:43:20,009
and greatest sandboxing technologies on

1085
00:43:17,009 --> 00:43:21,599
Windows it runs with a unique SID not as

1086
00:43:20,009 --> 00:43:23,609
the system at counter network service

1087
00:43:21,599 --> 00:43:25,559
but thus it runs under is part of

1088
00:43:23,609 --> 00:43:27,538
authenticated users so it has access to

1089
00:43:25,559 --> 00:43:30,359
quite a lot of files on the system and

1090
00:43:27,539 --> 00:43:31,739
at the time it had se impersonate

1091
00:43:30,359 --> 00:43:34,499
privilege and a couple other sensitive

1092
00:43:31,739 --> 00:43:37,200
privileges and having se impersonate

1093
00:43:34,499 --> 00:43:40,470
privilege effectively means that you can

1094
00:43:37,200 --> 00:43:42,509
automatically elevate to system so

1095
00:43:40,470 --> 00:43:44,578
achieving system privilege was a matter

1096
00:43:42,509 --> 00:43:47,099
of writing a big rot payload and I

1097
00:43:44,579 --> 00:43:49,049
didn't really want to do that so I

1098
00:43:47,099 --> 00:43:52,440
didn't but that's how that's how you

1099
00:43:49,049 --> 00:43:53,700
would do it if you wanted to now let's

1100
00:43:52,440 --> 00:43:55,170
talk about what we've learned from this

1101
00:43:53,700 --> 00:43:56,609
write because I said that I wanted to

1102
00:43:55,170 --> 00:43:58,619
show you how impactful some of these bug

1103
00:43:56,609 --> 00:44:00,569
reports can be one of the things we

1104
00:43:58,619 --> 00:44:02,339
learned is that writing exploits against

1105
00:44:00,569 --> 00:44:04,170
the latest version of Windows is a lot

1106
00:44:02,339 --> 00:44:06,450
harder and also in this case it was a

1107
00:44:04,170 --> 00:44:07,920
lot less reliable it took me about three

1108
00:44:06,450 --> 00:44:10,828
days to get the exploit working for

1109
00:44:07,920 --> 00:44:14,009
Server 2012 r2 and it took me upwards of

1110
00:44:10,829 --> 00:44:15,359
20 days to get it working on 1709 which

1111
00:44:14,009 --> 00:44:18,329
was the latest version of Windows at the

1112
00:44:15,359 --> 00:44:21,269
time for 2012 r2 it was about 40 percent

1113
00:44:18,329 --> 00:44:23,369
reliable and for 1709 after 20 days of

1114
00:44:21,269 --> 00:44:26,399
work it was like well under 10 percent

1115
00:44:23,369 --> 00:44:28,019
reliable and I'm sure that there are

1116
00:44:26,400 --> 00:44:30,150
some things that you could do to make

1117
00:44:28,019 --> 00:44:31,200
the exploit more reliable but that just

1118
00:44:30,150 --> 00:44:33,150
means more to

1119
00:44:31,200 --> 00:44:35,368
Element time so you're gonna increase

1120
00:44:33,150 --> 00:44:37,200
that time too right exploit and I'm

1121
00:44:35,369 --> 00:44:38,160
personally fairly confident that there's

1122
00:44:37,200 --> 00:44:40,740
no way that you could make this

1123
00:44:38,160 --> 00:44:43,560
completely reliable things that hurt

1124
00:44:40,740 --> 00:44:45,089
reliability were one since I had to go

1125
00:44:43,560 --> 00:44:45,509
in the heap I couldn't corrupt the stack

1126
00:44:45,089 --> 00:44:47,430
anymore

1127
00:44:45,510 --> 00:44:49,680
sometimes I would run into guard pages

1128
00:44:47,430 --> 00:44:51,810
so that would cause me to crash the

1129
00:44:49,680 --> 00:44:54,210
other thing was that I now have to run

1130
00:44:51,810 --> 00:44:56,099
the exploit at least two times because I

1131
00:44:54,210 --> 00:44:59,820
have to pay loads that need to execute

1132
00:44:56,099 --> 00:45:02,430
and every time I run the payload or

1133
00:44:59,820 --> 00:45:04,440
every time I try to go out of balance I

1134
00:45:02,430 --> 00:45:07,560
might not find the heap I'm looking for

1135
00:45:04,440 --> 00:45:09,869
and and I just crash and so every time I

1136
00:45:07,560 --> 00:45:12,410
have to do that it just once again adds

1137
00:45:09,869 --> 00:45:14,880
to the unreliability of the exploit and

1138
00:45:12,410 --> 00:45:17,549
while CFG certainly isn't perfect

1139
00:45:14,880 --> 00:45:19,800
because CFG was in place I couldn't just

1140
00:45:17,550 --> 00:45:21,420
go and corrupt any arbitrary function

1141
00:45:19,800 --> 00:45:23,490
pointer that I saw in the heap I had to

1142
00:45:21,420 --> 00:45:24,869
go and look for very specific objects in

1143
00:45:23,490 --> 00:45:26,939
the heap that I could use to build these

1144
00:45:24,869 --> 00:45:27,990
primitives and sometimes those objects

1145
00:45:26,940 --> 00:45:29,400
weren't in the heap and so I have to

1146
00:45:27,990 --> 00:45:31,799
reboot the virtual machine and look

1147
00:45:29,400 --> 00:45:33,480
again and just once again risk

1148
00:45:31,800 --> 00:45:37,380
crashing looking for these objects that

1149
00:45:33,480 --> 00:45:38,640
I need let's talk about language safety

1150
00:45:37,380 --> 00:45:40,800
one of the things that we've been really

1151
00:45:38,640 --> 00:45:42,118
interested in lately is how we can just

1152
00:45:40,800 --> 00:45:44,579
eliminate vulnerabilities from our

1153
00:45:42,119 --> 00:45:47,010
products and as I mentioned I had

1154
00:45:44,579 --> 00:45:50,250
stopped pen testing this component to go

1155
00:45:47,010 --> 00:45:51,990
import GSL span into it and when we saw

1156
00:45:50,250 --> 00:45:54,210
that GSL span actually killed the bug

1157
00:45:51,990 --> 00:45:56,939
that was a great signal to the hyper-v

1158
00:45:54,210 --> 00:45:59,579
team and other groups in Microsoft that

1159
00:45:56,940 --> 00:46:01,230
using things like GSL span is absolutely

1160
00:45:59,579 --> 00:46:05,280
worthwhile it can save us from really

1161
00:46:01,230 --> 00:46:07,859
nasty issues and in addition to that the

1162
00:46:05,280 --> 00:46:09,660
visual studio team spent a pretty decent

1163
00:46:07,859 --> 00:46:11,339
amount of time going and optimizing span

1164
00:46:09,660 --> 00:46:14,069
for us so that we could use it without

1165
00:46:11,339 --> 00:46:16,589
risking impacting performance in some of

1166
00:46:14,069 --> 00:46:19,349
these components if you look at hyper-v

1167
00:46:16,589 --> 00:46:21,480
code today there is over 200 files that

1168
00:46:19,349 --> 00:46:23,700
have GSL span being used in them which

1169
00:46:21,480 --> 00:46:25,319
is pretty awesome and I honestly think

1170
00:46:23,700 --> 00:46:27,509
that a lot of that can really be

1171
00:46:25,319 --> 00:46:29,220
attributed to this bug report and this

1172
00:46:27,510 --> 00:46:31,319
exploit that was written because without

1173
00:46:29,220 --> 00:46:34,890
that we would just think it was a cool

1174
00:46:31,319 --> 00:46:36,720
technology we've also been doing other

1175
00:46:34,890 --> 00:46:38,310
work to eliminate bug classes so we've

1176
00:46:36,720 --> 00:46:40,348
been aggressively killing uninitialized

1177
00:46:38,310 --> 00:46:42,480
bugs and Windows we've been using safer

1178
00:46:40,349 --> 00:46:44,520
language features and our products we've

1179
00:46:42,480 --> 00:46:46,110
been using static analysis like Cemil

1180
00:46:44,520 --> 00:46:48,180
to go and eliminate specific bug

1181
00:46:46,110 --> 00:46:50,100
patterns in our code and we've also been

1182
00:46:48,180 --> 00:46:54,210
investigating just using safer languages

1183
00:46:50,100 --> 00:46:55,220
like rust Sam boxing is another

1184
00:46:54,210 --> 00:46:57,810
interesting thing to talk about

1185
00:46:55,220 --> 00:47:00,120
virtualization is absolutely the best

1186
00:46:57,810 --> 00:47:03,180
sandbox that we have built at this point

1187
00:47:00,120 --> 00:47:04,920
however the worker process is designed

1188
00:47:03,180 --> 00:47:06,870
to run with lease privilege it doesn't

1189
00:47:04,920 --> 00:47:08,100
need system privilege and so one of the

1190
00:47:06,870 --> 00:47:11,040
things that we started investigating

1191
00:47:08,100 --> 00:47:13,350
after we got this bug report was if it

1192
00:47:11,040 --> 00:47:15,180
would make sense to go and put the VM

1193
00:47:13,350 --> 00:47:17,640
worker process in a stronger sandbox

1194
00:47:15,180 --> 00:47:18,810
just to add another layer of defense and

1195
00:47:17,640 --> 00:47:20,370
depth so that you wouldn't just need a

1196
00:47:18,810 --> 00:47:22,340
worker process bug but you would also

1197
00:47:20,370 --> 00:47:24,870
need a sandbox escape on top of that

1198
00:47:22,340 --> 00:47:26,430
we've done a lot of work in that area we

1199
00:47:24,870 --> 00:47:27,690
don't have anything that's production

1200
00:47:26,430 --> 00:47:29,310
ready yet but we do have working

1201
00:47:27,690 --> 00:47:32,220
prototypes that work for specific

1202
00:47:29,310 --> 00:47:33,810
scenarios and we also went ahead and

1203
00:47:32,220 --> 00:47:35,910
removed se impersonate privilege and

1204
00:47:33,810 --> 00:47:38,730
some other sensitive privileges from the

1205
00:47:35,910 --> 00:47:40,470
worker process in the meantime and this

1206
00:47:38,730 --> 00:47:44,150
is once again work that was really

1207
00:47:40,470 --> 00:47:46,980
motivated by the bug report that we got

1208
00:47:44,150 --> 00:47:48,720
related to that we've seen that

1209
00:47:46,980 --> 00:47:51,000
basically exploits that we've written

1210
00:47:48,720 --> 00:47:53,430
for this hyper-v user mode component and

1211
00:47:51,000 --> 00:47:55,140
kernel mode components in hyper-v we can

1212
00:47:53,430 --> 00:47:57,419
see that the user mode components are a

1213
00:47:55,140 --> 00:47:59,100
lot harder to attack the exploit

1214
00:47:57,420 --> 00:48:01,350
mitigations are more robust in user mode

1215
00:47:59,100 --> 00:48:04,230
we have the ability to use safer

1216
00:48:01,350 --> 00:48:06,990
languages like safe C++ features or rust

1217
00:48:04,230 --> 00:48:08,700
etc and of course we do have potential

1218
00:48:06,990 --> 00:48:10,379
for extreme sandboxing in user mode if

1219
00:48:08,700 --> 00:48:13,080
we choose to you know really go through

1220
00:48:10,380 --> 00:48:15,060
with that and so as a result of this the

1221
00:48:13,080 --> 00:48:16,920
hyper-v team has been investigating

1222
00:48:15,060 --> 00:48:18,480
moving some of their kernel components

1223
00:48:16,920 --> 00:48:21,530
into user mode so that we can take

1224
00:48:18,480 --> 00:48:24,030
advantage of those benefits more and

1225
00:48:21,530 --> 00:48:25,350
finally as you would expect whenever we

1226
00:48:24,030 --> 00:48:27,630
write an exploit we use that to evaluate

1227
00:48:25,350 --> 00:48:29,910
how our exploit mitigations are doing in

1228
00:48:27,630 --> 00:48:31,590
general one thing we noticed was that

1229
00:48:29,910 --> 00:48:34,170
this exploit took advantage of

1230
00:48:31,590 --> 00:48:35,370
indirectly calling DLL exports and we

1231
00:48:34,170 --> 00:48:37,350
actually had a feature at the time

1232
00:48:35,370 --> 00:48:39,000
called export suppression which prevents

1233
00:48:37,350 --> 00:48:41,520
that so we went ahead and turned that on

1234
00:48:39,000 --> 00:48:43,590
for the VM worker process and now part

1235
00:48:41,520 --> 00:48:45,180
of the technique that I used for 1709 is

1236
00:48:43,590 --> 00:48:47,490
broken and you'd have to go back to the

1237
00:48:45,180 --> 00:48:49,140
drawing board there we also have a new

1238
00:48:47,490 --> 00:48:50,850
version of CFG that dave wesson

1239
00:48:49,140 --> 00:48:54,960
announced at blue hat shanghai called

1240
00:48:50,850 --> 00:48:57,720
xfg and when xfg was being worked on we

1241
00:48:54,960 --> 00:48:59,820
went and looked to see how xfg would imp

1242
00:48:57,720 --> 00:49:01,560
this particular exploit and we can

1243
00:48:59,820 --> 00:49:03,660
clearly see that xfg would make this

1244
00:49:01,560 --> 00:49:06,299
exploit substantially harder to pull off

1245
00:49:03,660 --> 00:49:08,129
because the function signatures would no

1246
00:49:06,300 --> 00:49:11,400
longer match between the indirect call

1247
00:49:08,130 --> 00:49:12,960
target and the indirect call site and we

1248
00:49:11,400 --> 00:49:15,330
also use this just to look at potential

1249
00:49:12,960 --> 00:49:17,190
cpu features that we're working on such

1250
00:49:15,330 --> 00:49:20,009
as or not necessarily working on but

1251
00:49:17,190 --> 00:49:21,780
just considering as future options so we

1252
00:49:20,010 --> 00:49:23,460
might look and see how would memory

1253
00:49:21,780 --> 00:49:26,130
tagging impact this how would something

1254
00:49:23,460 --> 00:49:28,560
like Cherry impact this etc so it really

1255
00:49:26,130 --> 00:49:31,590
goes and helps us dive into future

1256
00:49:28,560 --> 00:49:33,060
investments that we should make so my

1257
00:49:31,590 --> 00:49:35,220
point here is that your bug reports all

1258
00:49:33,060 --> 00:49:37,049
matter and not all of them result in us

1259
00:49:35,220 --> 00:49:39,000
going and building a full chain exploit

1260
00:49:37,050 --> 00:49:41,910
for one of our products but at the very

1261
00:49:39,000 --> 00:49:44,099
minimum we use all of this data to

1262
00:49:41,910 --> 00:49:45,810
analyze bug trends and figure out where

1263
00:49:44,099 --> 00:49:48,570
we're currently lagging and where we

1264
00:49:45,810 --> 00:49:50,070
need to invest more and some of the some

1265
00:49:48,570 --> 00:49:52,170
of the vulnerability reports and exploit

1266
00:49:50,070 --> 00:49:54,500
reports that we see are used to drive

1267
00:49:52,170 --> 00:49:56,880
really big investments in our products

1268
00:49:54,500 --> 00:49:58,440
now as I noted we paid six hundred and

1269
00:49:56,880 --> 00:50:01,050
twenty-five thousand dollars since last

1270
00:49:58,440 --> 00:50:03,900
blackhat and hyper-v bounties and 4.4

1271
00:50:01,050 --> 00:50:05,460
million dollars in bounties total so

1272
00:50:03,900 --> 00:50:07,920
please participate in the hyper-v bounty

1273
00:50:05,460 --> 00:50:09,570
we want submissions and also please

1274
00:50:07,920 --> 00:50:11,880
participate in the other bounty programs

1275
00:50:09,570 --> 00:50:14,510
that we have I'm out of time

1276
00:50:11,880 --> 00:50:14,510
thank you

