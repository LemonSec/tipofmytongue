1
00:00:00,000 --> 00:00:04,500
this talk is going beyond coverage

2
00:00:02,009 --> 00:00:06,569
guided buzzing with structured fuzzing

3
00:00:04,500 --> 00:00:09,929
by Jonathan Metz Ben but first we have a

4
00:00:06,569 --> 00:00:12,599
few notes please stop by the business

5
00:00:09,929 --> 00:00:15,179
Hall located in Mandalay Bay Oceanside

6
00:00:12,599 --> 00:00:17,160
and shoreline ballrooms on level 2

7
00:00:15,179 --> 00:00:20,189
during the day and for the Welcome

8
00:00:17,160 --> 00:00:22,410
Reception at 5:30 this evening the

9
00:00:20,189 --> 00:00:24,840
blackhat Arsenal is in the business hall

10
00:00:22,410 --> 00:00:29,779
on level 2 and join us for the pony

11
00:00:24,840 --> 00:00:32,390
awards and lagoon JKL at 6:30

12
00:00:29,779 --> 00:00:38,260
please remember to silence your phones

13
00:00:32,390 --> 00:00:45,200
and without further ado Jonathan Messman

14
00:00:38,260 --> 00:00:45,199
[Applause]

15
00:00:47,450 --> 00:00:52,829
hi everyone thanks for coming in my talk

16
00:00:49,950 --> 00:00:55,350
as I was introduced from Jonathan met

17
00:00:52,829 --> 00:00:57,480
ceman and I'm here to talk about how you

18
00:00:55,350 --> 00:00:59,609
can get more bugs out of coverage guided

19
00:00:57,480 --> 00:01:03,000
buzzing by adding structure awareness to

20
00:00:59,609 --> 00:01:05,099
your fuzzers I first got into fuzzing

21
00:01:03,000 --> 00:01:07,710
while I was in college through AFL I

22
00:01:05,099 --> 00:01:10,380
started using AFL to find bugs in my

23
00:01:07,710 --> 00:01:11,820
school projects and later I moved on to

24
00:01:10,380 --> 00:01:14,520
finding bugs in real software like

25
00:01:11,820 --> 00:01:16,320
sequel Lite with AFL and I was really

26
00:01:14,520 --> 00:01:18,179
amazed by how well AFL worked because

27
00:01:16,320 --> 00:01:21,508
you know I didn't really know much about

28
00:01:18,180 --> 00:01:23,189
how AFL worked at the time and I didn't

29
00:01:21,509 --> 00:01:25,380
know much about the software I was

30
00:01:23,189 --> 00:01:27,000
finding bugs in with AFL but it still

31
00:01:25,380 --> 00:01:28,679
worked so well and you know I thought

32
00:01:27,000 --> 00:01:32,729
what could be better than this tool that

33
00:01:28,680 --> 00:01:34,320
gives us bugs for free so I think the

34
00:01:32,729 --> 00:01:35,759
answer that has got to be structured

35
00:01:34,320 --> 00:01:38,399
fuzzing otherwise I wouldn't be giving

36
00:01:35,759 --> 00:01:40,380
this talk but unfortunately structured

37
00:01:38,400 --> 00:01:42,630
fuzzing doesn't actually give you bugs

38
00:01:40,380 --> 00:01:44,670
for free it forces you to think about

39
00:01:42,630 --> 00:01:46,949
the format that your fuzzing but because

40
00:01:44,670 --> 00:01:48,840
of that thought process and the effort

41
00:01:46,950 --> 00:01:51,780
you put into it you'll end up finding

42
00:01:48,840 --> 00:01:53,159
more bugs so let's fast forward a few

43
00:01:51,780 --> 00:01:55,740
years to when I started working at

44
00:01:53,159 --> 00:01:57,930
Google I wrote a structured fuzzer for

45
00:01:55,740 --> 00:02:00,419
skia which is a graphics library using

46
00:01:57,930 --> 00:02:02,219
Chrome and you could see part of the

47
00:02:00,420 --> 00:02:04,200
header file of that fuzzer on the screen

48
00:02:02,219 --> 00:02:05,548
and so as you can probably guess it took

49
00:02:04,200 --> 00:02:07,560
quite a bit of effort to write that

50
00:02:05,549 --> 00:02:09,330
fuzzer but i think the effort paid off

51
00:02:07,560 --> 00:02:12,200
in the end because the fuzzer found

52
00:02:09,330 --> 00:02:13,970
around 10 vulnerabilities in

53
00:02:12,200 --> 00:02:16,909
that weren't found with unstructured

54
00:02:13,970 --> 00:02:18,170
buzzers like AFL so today I want to

55
00:02:16,909 --> 00:02:20,780
teach you more about this technique

56
00:02:18,170 --> 00:02:22,548
structured buzzing and convince you what

57
00:02:20,780 --> 00:02:26,840
why it's sometimes worth it to pay more

58
00:02:22,549 --> 00:02:29,209
when you could pay less first a little

59
00:02:26,840 --> 00:02:31,760
bit about myself I work at Google on

60
00:02:29,209 --> 00:02:34,069
mainly on fuzzy chrome but we also

61
00:02:31,760 --> 00:02:36,078
develop fuzzy tools that are used by

62
00:02:34,069 --> 00:02:39,109
other open-source projects and one of

63
00:02:36,079 --> 00:02:41,030
these is called OSS fuzz which thank you

64
00:02:39,110 --> 00:02:43,790
Dino for shouting this out during the

65
00:02:41,030 --> 00:02:46,220
keynote today and one of the unofficial

66
00:02:43,790 --> 00:02:48,470
roles I've taken on in Chrome security

67
00:02:46,220 --> 00:02:50,420
is getting people to write structured

68
00:02:48,470 --> 00:02:52,609
fuzzers for Chrome they've been such a

69
00:02:50,420 --> 00:02:54,559
big big win for us there and I'm hoping

70
00:02:52,609 --> 00:02:56,030
today I could do the same for you and

71
00:02:54,560 --> 00:03:00,829
that there'll be a big win for you all

72
00:02:56,030 --> 00:03:02,870
as well so let's define what I mean by

73
00:03:00,829 --> 00:03:05,930
structured fuzzing and see how it

74
00:03:02,870 --> 00:03:08,239
evolved the first generation of fuzzers

75
00:03:05,930 --> 00:03:10,250
were completely black box they knew

76
00:03:08,239 --> 00:03:12,079
nothing about the target that they were

77
00:03:10,250 --> 00:03:14,930
fuzzing and they were also actually

78
00:03:12,079 --> 00:03:17,060
structure unaware which means that they

79
00:03:14,930 --> 00:03:18,889
knew nothing about the format that they

80
00:03:17,060 --> 00:03:21,530
were supposed to be mutating or

81
00:03:18,889 --> 00:03:22,760
generating so they were pretty similar -

82
00:03:21,530 --> 00:03:24,560
they're pretty you were - mentor in that

83
00:03:22,760 --> 00:03:26,599
and they were similar to piping bytes

84
00:03:24,560 --> 00:03:28,730
from you know dev you random to like a

85
00:03:26,599 --> 00:03:32,268
UNIX utility just you know completely

86
00:03:28,730 --> 00:03:34,730
unaware and now the next generation of

87
00:03:32,269 --> 00:03:36,799
fuzzers improved on the effectiveness of

88
00:03:34,730 --> 00:03:40,040
the first generation by being structure

89
00:03:36,799 --> 00:03:41,569
aware there was still black box but it

90
00:03:40,040 --> 00:03:43,370
was this was probably based on the

91
00:03:41,569 --> 00:03:45,828
realization that if you're fuzzing

92
00:03:43,370 --> 00:03:48,379
something like an HTML renderer you're

93
00:03:45,829 --> 00:03:50,209
more likely to find bugs if you give it

94
00:03:48,379 --> 00:03:53,179
inputs that look something like HTML

95
00:03:50,209 --> 00:03:56,060
rather than just you know nonsense from

96
00:03:53,180 --> 00:03:57,739
dev you random now I think the current

97
00:03:56,060 --> 00:03:59,930
generation of fuzzers that most people

98
00:03:57,739 --> 00:04:01,639
are using our coverage guided and

99
00:03:59,930 --> 00:04:04,459
unstructured and this is the technique

100
00:04:01,639 --> 00:04:06,560
that AFL pioneered and a sort of sparked

101
00:04:04,459 --> 00:04:11,299
this like fuzzing revolution that were

102
00:04:06,560 --> 00:04:13,160
in currently and the reason why the AFL

103
00:04:11,299 --> 00:04:14,769
has had such a large effect and in this

104
00:04:13,160 --> 00:04:17,389
technique as well is because

105
00:04:14,769 --> 00:04:19,810
unstructured fuzzing allows people to

106
00:04:17,389 --> 00:04:22,640
use it without actually understanding

107
00:04:19,810 --> 00:04:24,080
much about the format that they're

108
00:04:22,640 --> 00:04:25,400
actually fuzzing but because it's

109
00:04:24,080 --> 00:04:26,960
coverage guided the

110
00:04:25,400 --> 00:04:29,239
buzzer generates progressively more

111
00:04:26,960 --> 00:04:32,210
interesting inputs and that's why it's

112
00:04:29,240 --> 00:04:33,830
actually fairly good at finding bugs now

113
00:04:32,210 --> 00:04:36,500
coverage guided fuzzing is such a big

114
00:04:33,830 --> 00:04:38,508
advance in fuzzing that I'm going to

115
00:04:36,500 --> 00:04:39,860
just assume we're talking about covered

116
00:04:38,509 --> 00:04:42,770
guided fuzzing throughout the rest of

117
00:04:39,860 --> 00:04:45,080
the talk and so I'm just gonna refer to

118
00:04:42,770 --> 00:04:47,060
this as unstructured fuzzing now I think

119
00:04:45,080 --> 00:04:48,770
the next generation of fuzzers will

120
00:04:47,060 --> 00:04:51,139
build off of this coverage got these

121
00:04:48,770 --> 00:04:53,870
advances and coverage guided fussing but

122
00:04:51,139 --> 00:04:56,060
though they'll also be structure aware

123
00:04:53,870 --> 00:04:57,830
and this is what I call structured

124
00:04:56,060 --> 00:05:00,740
fuzzing and by being structured aware I

125
00:04:57,830 --> 00:05:02,690
mean things like they won't do the sort

126
00:05:00,740 --> 00:05:05,389
of general purpose mutations that AFL

127
00:05:02,690 --> 00:05:07,039
does on inputs that they'll do you know

128
00:05:05,389 --> 00:05:09,039
format specific ones like they'll

129
00:05:07,039 --> 00:05:11,060
they'll delete expressions from

130
00:05:09,039 --> 00:05:16,520
JavaScript programs they won't just flip

131
00:05:11,060 --> 00:05:17,840
bits so why you structured fuzzing at

132
00:05:16,520 --> 00:05:19,940
the end of the day I think it's only

133
00:05:17,840 --> 00:05:22,280
worth using a new fuzzing technique if

134
00:05:19,940 --> 00:05:24,590
it helps you find more bugs and that's

135
00:05:22,280 --> 00:05:26,750
exactly what structured frozen can do

136
00:05:24,590 --> 00:05:28,099
for you so let me first demonstrate that

137
00:05:26,750 --> 00:05:30,500
structured fuzzing can help you find

138
00:05:28,099 --> 00:05:34,699
more bugs and explain why it'll help you

139
00:05:30,500 --> 00:05:36,789
find more bugs and to do this I want to

140
00:05:34,699 --> 00:05:39,680
start by sharing a story about how

141
00:05:36,789 --> 00:05:41,360
structured fuzzing found bugs in sequel

142
00:05:39,680 --> 00:05:43,940
light that weren't found with

143
00:05:41,360 --> 00:05:46,880
unstructured fuzzing now I mentioned

144
00:05:43,940 --> 00:05:48,620
fuzzing sequel light in the earlier

145
00:05:46,880 --> 00:05:50,120
slides or at least you know one of the

146
00:05:48,620 --> 00:05:53,229
first projects I would fuzz with AFL was

147
00:05:50,120 --> 00:05:55,250
sequel light and I guess that probably

148
00:05:53,229 --> 00:05:57,650
sequel light might be one of the most

149
00:05:55,250 --> 00:05:59,180
well fuzz projects in the world one of

150
00:05:57,650 --> 00:06:01,400
the groups that fuzz this equal light is

151
00:05:59,180 --> 00:06:03,530
actually my team at Google we fuzz

152
00:06:01,400 --> 00:06:05,900
sequel light through OSS fuzz and we've

153
00:06:03,530 --> 00:06:09,380
been doing it for years through Lib

154
00:06:05,900 --> 00:06:11,030
fuzzer and AFL and I'd say that over the

155
00:06:09,380 --> 00:06:13,250
years we've probably thrown tens of

156
00:06:11,030 --> 00:06:15,739
billions of test cases at sequel light

157
00:06:13,250 --> 00:06:17,599
that were created by AFL and Lib fuzzer

158
00:06:15,740 --> 00:06:18,919
so you would think that with all these

159
00:06:17,599 --> 00:06:21,050
attempts and all this time

160
00:06:18,919 --> 00:06:23,150
AFL and Lib buzzer would have found most

161
00:06:21,050 --> 00:06:26,060
of the bugs in sequel light but

162
00:06:23,150 --> 00:06:28,909
obviously that's not true and we

163
00:06:26,060 --> 00:06:31,400
actually have one of my co-workers

164
00:06:28,909 --> 00:06:33,020
actually last fall Mathew Denton wrote a

165
00:06:31,400 --> 00:06:33,979
structured fuzzer for sequel light and

166
00:06:33,020 --> 00:06:36,590
this fuzzer

167
00:06:33,979 --> 00:06:38,630
would generate SQL statements to be

168
00:06:36,590 --> 00:06:39,919
executed by sequel light

169
00:06:38,630 --> 00:06:41,870
it immediately started finding

170
00:06:39,920 --> 00:06:44,870
vulnerabilities that weren't found by

171
00:06:41,870 --> 00:06:48,700
AFL and Lib buzzer including this heap

172
00:06:44,870 --> 00:06:48,700
overflow that you see on the screen now

173
00:06:49,120 --> 00:06:53,750
that's just an anecdote but we actually

174
00:06:52,580 --> 00:06:55,909
have data to support the use of

175
00:06:53,750 --> 00:06:58,280
structured fuzzing as well in Chrome

176
00:06:55,910 --> 00:07:00,260
probably around 50 vulnerabilities have

177
00:06:58,280 --> 00:07:03,619
been found using structured fuzzing in

178
00:07:00,260 --> 00:07:05,030
about the past two years and some of

179
00:07:03,620 --> 00:07:08,360
these were cases like the previous one

180
00:07:05,030 --> 00:07:09,979
where there was a unstructured fuzzer

181
00:07:08,360 --> 00:07:11,630
and then the structured foster sort of

182
00:07:09,980 --> 00:07:14,000
beat the unstructured fuzzer and finding

183
00:07:11,630 --> 00:07:16,370
bugs but actually there are other cases

184
00:07:14,000 --> 00:07:18,590
where structured fuzzing allowed a

185
00:07:16,370 --> 00:07:20,600
researcher to fuzz code that they

186
00:07:18,590 --> 00:07:22,400
couldn't fuzz with unstructured fuzzing

187
00:07:20,600 --> 00:07:24,980
and I'll explain more about how that

188
00:07:22,400 --> 00:07:26,750
works later on and although we'll only

189
00:07:24,980 --> 00:07:29,150
be discussing structured fuzzing in the

190
00:07:26,750 --> 00:07:31,760
context of like userland code and Lib

191
00:07:29,150 --> 00:07:34,250
buzzer today it's worth noting that

192
00:07:31,760 --> 00:07:35,930
outside of this context there's a lot of

193
00:07:34,250 --> 00:07:38,180
data to support the use of structured

194
00:07:35,930 --> 00:07:40,220
fuzzing as well I think the most notable

195
00:07:38,180 --> 00:07:42,580
of these is sis caller which for those

196
00:07:40,220 --> 00:07:44,510
of you who haven't heard of it is a

197
00:07:42,580 --> 00:07:46,760
structured fuzzing framework for the

198
00:07:44,510 --> 00:07:48,349
Linux kernel that is found I think over

199
00:07:46,760 --> 00:07:52,159
a thousand vulnerabilities in just the

200
00:07:48,350 --> 00:07:54,770
past couple years so why does structured

201
00:07:52,160 --> 00:07:56,090
fuzzing help you find more bugs there

202
00:07:54,770 --> 00:07:57,710
are many reasons but I think they all

203
00:07:56,090 --> 00:07:59,510
really boil down to the fact that

204
00:07:57,710 --> 00:08:01,669
structured fuzzing gives you the

205
00:07:59,510 --> 00:08:02,060
researcher more power to fuzz what you

206
00:08:01,670 --> 00:08:03,860
want

207
00:08:02,060 --> 00:08:06,980
it lets you fuzz where you think the

208
00:08:03,860 --> 00:08:09,950
bugs are going to be let's see how this

209
00:08:06,980 --> 00:08:12,770
compares to unstructured fuzzing at a

210
00:08:09,950 --> 00:08:14,719
high level so if we're fuzzing something

211
00:08:12,770 --> 00:08:17,840
like v8 which is Chrome's JavaScript

212
00:08:14,720 --> 00:08:20,840
engine there's a range of possible

213
00:08:17,840 --> 00:08:23,090
places where bugs can occur on one end

214
00:08:20,840 --> 00:08:25,010
of the spectrum you've got bugs like

215
00:08:23,090 --> 00:08:26,960
parser bugs and then on the other end

216
00:08:25,010 --> 00:08:27,800
you have things like JIT miss compiles

217
00:08:26,960 --> 00:08:29,950
where you actually have to run

218
00:08:27,800 --> 00:08:32,900
JavaScript code to trigger those bugs

219
00:08:29,950 --> 00:08:34,819
now what an unstructured fuzz were like

220
00:08:32,900 --> 00:08:37,909
AFL would do if you were using it the

221
00:08:34,820 --> 00:08:40,700
fuzz v8 is it would take JavaScript

222
00:08:37,909 --> 00:08:43,218
programs and it would pick random bytes

223
00:08:40,700 --> 00:08:45,260
in those programs and change them to

224
00:08:43,219 --> 00:08:47,720
arbitrary values so if we have like an

225
00:08:45,260 --> 00:08:50,210
else keyword in our program AFL might do

226
00:08:47,720 --> 00:08:51,380
something like add 0 into the middle of

227
00:08:50,210 --> 00:08:55,190
our else keyword

228
00:08:51,380 --> 00:08:57,560
and this is gonna fail parsing right l0s

229
00:08:55,190 --> 00:09:00,140
e is not valid JavaScript code anymore

230
00:08:57,560 --> 00:09:03,500
and this is sort of the problem with

231
00:09:00,140 --> 00:09:04,939
using unstructured fuzzing sometimes so

232
00:09:03,500 --> 00:09:07,970
many of the test cases are gonna fail

233
00:09:04,940 --> 00:09:09,650
parsing that what you might have an easy

234
00:09:07,970 --> 00:09:11,150
time finding these sort of parser bugs

235
00:09:09,650 --> 00:09:13,699
you're gonna have a much harder time

236
00:09:11,150 --> 00:09:15,110
finding these bugs that exist higher up

237
00:09:13,700 --> 00:09:17,600
the stack you know at a higher level of

238
00:09:15,110 --> 00:09:19,550
abstraction and so to focus on finding

239
00:09:17,600 --> 00:09:21,980
these bugs that live at this higher

240
00:09:19,550 --> 00:09:23,900
level of abstraction we can with

241
00:09:21,980 --> 00:09:28,580
structured fuzzing we can constrain our

242
00:09:23,900 --> 00:09:31,400
input so that all of our inputs the to

243
00:09:28,580 --> 00:09:33,230
the target obey certain constraints so

244
00:09:31,400 --> 00:09:35,890
with the structured fuzzer we can make

245
00:09:33,230 --> 00:09:38,300
it so that every test case we create is

246
00:09:35,890 --> 00:09:40,310
syntactically valid JavaScript and so we

247
00:09:38,300 --> 00:09:42,349
can be sure that all of these end up

248
00:09:40,310 --> 00:09:44,810
getting executed and this is basically

249
00:09:42,350 --> 00:09:47,060
what I mean by sort of fuzzing where you

250
00:09:44,810 --> 00:09:49,369
think bugs are you're basically focusing

251
00:09:47,060 --> 00:09:52,640
the fuzzers efforts on a certain

252
00:09:49,370 --> 00:09:54,860
subspace of the range of possible inputs

253
00:09:52,640 --> 00:09:56,990
that you think is most likely the

254
00:09:54,860 --> 00:09:59,480
trigger bugs and it's also worth noting

255
00:09:56,990 --> 00:10:01,700
that in v8 in particular and I think

256
00:09:59,480 --> 00:10:03,230
it's true for most programs most bugs

257
00:10:01,700 --> 00:10:05,510
actually tend to live at these higher

258
00:10:03,230 --> 00:10:07,640
levels of abstraction and not just at

259
00:10:05,510 --> 00:10:11,930
the parsing level so by doing this we

260
00:10:07,640 --> 00:10:14,090
are really finding more bugs another way

261
00:10:11,930 --> 00:10:17,839
that controlling your input space with

262
00:10:14,090 --> 00:10:19,820
structured fuzzing can help with fuzzing

263
00:10:17,840 --> 00:10:21,530
efficiency is you can avoid fuzzing

264
00:10:19,820 --> 00:10:25,550
certain code that actually makes it

265
00:10:21,530 --> 00:10:27,140
harder to find bugs and so recently I

266
00:10:25,550 --> 00:10:29,060
was writing a structured buzzer that

267
00:10:27,140 --> 00:10:31,280
produced JavaScript code and one of the

268
00:10:29,060 --> 00:10:32,989
problems this fuzzer had was it

269
00:10:31,280 --> 00:10:34,880
immediately started producing infinite

270
00:10:32,990 --> 00:10:36,800
loops and we don't want to execute

271
00:10:34,880 --> 00:10:39,590
infinite loops when we're fuzzing a

272
00:10:36,800 --> 00:10:42,380
javascript engine like v8 because it's a

273
00:10:39,590 --> 00:10:44,270
huge waste of time you know we'll never

274
00:10:42,380 --> 00:10:45,950
be able to reach code that comes after

275
00:10:44,270 --> 00:10:47,750
the infinite loop and instead we'll just

276
00:10:45,950 --> 00:10:50,120
keep trying the same thing over and over

277
00:10:47,750 --> 00:10:52,220
again and expecting to find the bug so

278
00:10:50,120 --> 00:10:54,380
the simple solution with structured

279
00:10:52,220 --> 00:10:56,860
fuzzing is again constraining the input

280
00:10:54,380 --> 00:10:59,480
space so now instead of just generating

281
00:10:56,860 --> 00:11:00,770
syntactically valid JavaScript I'm only

282
00:10:59,480 --> 00:11:02,930
going to generate syntactically valid

283
00:11:00,770 --> 00:11:06,559
JavaScript where every loop is

284
00:11:02,930 --> 00:11:07,969
and this obviously solves the infinite

285
00:11:06,559 --> 00:11:10,399
loop problem that we have and you can

286
00:11:07,970 --> 00:11:11,720
apply this to other sorts of issues you

287
00:11:10,399 --> 00:11:13,670
might face when fuzzing so you could do

288
00:11:11,720 --> 00:11:15,079
the same to ensure that you know your

289
00:11:13,670 --> 00:11:19,040
JavaScript code doesn't throw any

290
00:11:15,079 --> 00:11:21,019
uncaught exceptions for example now I

291
00:11:19,040 --> 00:11:23,629
think the real power with structured

292
00:11:21,019 --> 00:11:25,759
fuzzing is not in just avoiding fuzzing

293
00:11:23,629 --> 00:11:28,129
certain things but it's and actually

294
00:11:25,759 --> 00:11:30,079
it's in making the fuzzer cover code

295
00:11:28,129 --> 00:11:33,050
that you want to be tested and you want

296
00:11:30,079 --> 00:11:34,998
to find bugs in and a good example of

297
00:11:33,050 --> 00:11:37,910
this was a fuzzer I was recently writing

298
00:11:34,999 --> 00:11:40,550
for PDF iam which is Chrome's PDF reader

299
00:11:37,910 --> 00:11:42,679
now the way I wrote this fuzzer

300
00:11:40,550 --> 00:11:45,079
was I would run the fuzzer for a little

301
00:11:42,679 --> 00:11:47,629
bit then generate a coverage report

302
00:11:45,079 --> 00:11:50,300
using claims coverage tools and see what

303
00:11:47,629 --> 00:11:52,790
code wasn't being covered and so as you

304
00:11:50,300 --> 00:11:56,300
can see on the slide there's a coverage

305
00:11:52,790 --> 00:11:58,309
report that shows that the PDF PDF eum's

306
00:11:56,300 --> 00:12:00,498
barcode feature isn't being covered at

307
00:11:58,309 --> 00:12:03,110
all and there's a simple reason for this

308
00:12:00,499 --> 00:12:05,240
it's because I had no idea that bark

309
00:12:03,110 --> 00:12:06,769
that PDFs actually support barcodes

310
00:12:05,240 --> 00:12:09,769
that's like a feature that they have but

311
00:12:06,769 --> 00:12:11,600
apparently it's actually a thing so the

312
00:12:09,769 --> 00:12:13,939
solution here was just to basically

313
00:12:11,600 --> 00:12:16,279
expand the input space to get the fuzzer

314
00:12:13,939 --> 00:12:18,319
to produce PDFs that contain barcodes

315
00:12:16,279 --> 00:12:20,300
and then I ran another coverage report

316
00:12:18,319 --> 00:12:22,998
afterwards and just confirm that I'm

317
00:12:20,300 --> 00:12:25,699
indeed covering the code I wanted to

318
00:12:22,999 --> 00:12:27,170
cover the barcode feature now this

319
00:12:25,699 --> 00:12:29,359
workflow is something you only really

320
00:12:27,170 --> 00:12:30,709
get with structured fuzzing with an

321
00:12:29,360 --> 00:12:32,870
unstructured fuzzer you could sort of

322
00:12:30,709 --> 00:12:35,329
get it by you know giving seed inputs

323
00:12:32,870 --> 00:12:37,160
and hoping that it can derive similar

324
00:12:35,329 --> 00:12:38,959
inputs from there but it's not like a

325
00:12:37,160 --> 00:12:40,790
tight feedback loop like you have here

326
00:12:38,959 --> 00:12:42,800
and you know here with structured

327
00:12:40,790 --> 00:12:44,599
fuzzing you're almost becoming good part

328
00:12:42,800 --> 00:12:46,459
of the fuzzer where you see code that

329
00:12:44,600 --> 00:12:47,959
isn't being covered and you you know

330
00:12:46,459 --> 00:12:49,729
make a decision whether you think it's

331
00:12:47,959 --> 00:12:51,459
worth covering that code and then you

332
00:12:49,730 --> 00:12:54,079
make the fuzzer cover that code and

333
00:12:51,459 --> 00:12:55,729
that's a point I want to emphasize here

334
00:12:54,079 --> 00:12:57,258
that you know we're making a trade-off

335
00:12:55,730 --> 00:12:59,059
with structured fuzzing where we're

336
00:12:57,259 --> 00:13:02,540
treating some of our time and effort in

337
00:12:59,059 --> 00:13:04,730
order to find more bugs and you know

338
00:13:02,540 --> 00:13:06,679
you'll just have to decide if you think

339
00:13:04,730 --> 00:13:08,389
it's worth covering a fee like one

340
00:13:06,679 --> 00:13:10,759
feature or another feature or covering a

341
00:13:08,389 --> 00:13:12,649
feature more thoroughly or maybe you can

342
00:13:10,759 --> 00:13:14,449
get bugs more cheaply by teaching the

343
00:13:12,649 --> 00:13:16,700
fuzzer about another feature like you'll

344
00:13:14,449 --> 00:13:18,079
notice I'm not covering the barcode

345
00:13:16,700 --> 00:13:20,000
you're fully in the second coverage

346
00:13:18,080 --> 00:13:22,360
report and that's because I decided hey

347
00:13:20,000 --> 00:13:24,980
you know I could probably get more bugs

348
00:13:22,360 --> 00:13:26,420
by teaching the fuzzer about a new

349
00:13:24,980 --> 00:13:30,620
feature you know I've already gotten

350
00:13:26,420 --> 00:13:32,479
bugs out of this barcode thing I did the

351
00:13:30,620 --> 00:13:34,700
last way I'm going to cover that

352
00:13:32,480 --> 00:13:37,010
structured fuzzing can help you fuzz

353
00:13:34,700 --> 00:13:38,840
where you think bugs are is structured

354
00:13:37,010 --> 00:13:40,580
fuzzing can actually make it easier to

355
00:13:38,840 --> 00:13:43,550
fuzz code that doesn't just accept an

356
00:13:40,580 --> 00:13:45,050
array of bytes so a good example of this

357
00:13:43,550 --> 00:13:47,689
that I want used to illustrate this

358
00:13:45,050 --> 00:13:50,270
point is a fuzzer written by a co-worker

359
00:13:47,690 --> 00:13:51,950
of mine Ned Williamson this buzzer was

360
00:13:50,270 --> 00:13:55,400
for app cache which is a chrome feature

361
00:13:51,950 --> 00:13:57,620
app cache had a number of API is that

362
00:13:55,400 --> 00:13:59,630
the fuzzer was trying to find bugs in

363
00:13:57,620 --> 00:14:03,440
and you'll notice that none of these API

364
00:13:59,630 --> 00:14:06,290
is just except a blob of bytes like

365
00:14:03,440 --> 00:14:08,390
unstructured fuzzers produce and so

366
00:14:06,290 --> 00:14:10,010
there's also no place in chrome where

367
00:14:08,390 --> 00:14:13,670
you could just shove in a blob of bytes

368
00:14:10,010 --> 00:14:15,890
and get these functions exercised so

369
00:14:13,670 --> 00:14:18,469
what the fuzzer did was it structured

370
00:14:15,890 --> 00:14:20,990
each of its inputs so that each input

371
00:14:18,470 --> 00:14:22,970
represented a function call to make and

372
00:14:20,990 --> 00:14:25,250
the arguments to pass those functions

373
00:14:22,970 --> 00:14:27,980
now obviously this input can't be

374
00:14:25,250 --> 00:14:29,450
directly used in fuzzing there's nothing

375
00:14:27,980 --> 00:14:30,020
in chrome that understands what this

376
00:14:29,450 --> 00:14:32,570
means

377
00:14:30,020 --> 00:14:34,910
so the fuzzer also just had to interpret

378
00:14:32,570 --> 00:14:37,310
these inputs so it says if you know if

379
00:14:34,910 --> 00:14:39,079
the inputs telling me to call do

380
00:14:37,310 --> 00:14:43,040
requests I'm going to call do requests

381
00:14:39,080 --> 00:14:44,300
and pass in the specified arguments so

382
00:14:43,040 --> 00:14:46,069
to summarise why you should use

383
00:14:44,300 --> 00:14:47,449
structured fuzzing you should use it

384
00:14:46,070 --> 00:14:49,430
because it will help you find more bugs

385
00:14:47,450 --> 00:14:51,350
and it can help you find more bugs

386
00:14:49,430 --> 00:14:53,420
because it gives you the research or

387
00:14:51,350 --> 00:14:55,430
more power into fuzzing what you want

388
00:14:53,420 --> 00:14:57,680
and also because it allows you to fuzz

389
00:14:55,430 --> 00:14:59,239
more things in particular it allows you

390
00:14:57,680 --> 00:15:03,680
to fuzz code that doesn't accept an

391
00:14:59,240 --> 00:15:06,230
array of bytes now that I'm done selling

392
00:15:03,680 --> 00:15:08,359
structured fuzzing to you all I want to

393
00:15:06,230 --> 00:15:10,340
give you very practical advice on how

394
00:15:08,360 --> 00:15:12,440
you can write a structured fuzzer and

395
00:15:10,340 --> 00:15:14,690
I'll cover three techniques that you can

396
00:15:12,440 --> 00:15:16,700
use for writing a structured fuzzer with

397
00:15:14,690 --> 00:15:20,060
Lib buzzer and Lib buzzer for those of

398
00:15:16,700 --> 00:15:22,910
you who don't know is a coverage guided

399
00:15:20,060 --> 00:15:25,069
fuzzer much like AFL it's probably the

400
00:15:22,910 --> 00:15:27,910
main fuzzer that we use in chrome and

401
00:15:25,070 --> 00:15:27,910
OSS fuzz

402
00:15:28,110 --> 00:15:33,009
so the first way you can write a

403
00:15:31,120 --> 00:15:35,860
structured buzzer with lib buzzer is by

404
00:15:33,009 --> 00:15:37,990
defining a lib buzzer custom mutator and

405
00:15:35,860 --> 00:15:40,269
these work pretty much as you might

406
00:15:37,990 --> 00:15:42,970
expect you simply define this function

407
00:15:40,269 --> 00:15:46,509
and live buzzer when mutating test cases

408
00:15:42,970 --> 00:15:49,209
will call this function to mutate test

409
00:15:46,509 --> 00:15:51,160
cases rather than its default mutator so

410
00:15:49,209 --> 00:15:52,869
if we're fussing JavaScript instead of

411
00:15:51,160 --> 00:15:54,930
using the default mutator to do stupid

412
00:15:52,870 --> 00:15:57,759
things like bit flipping well actually

413
00:15:54,930 --> 00:16:00,638
lib buzzer will call your custom mutator

414
00:15:57,759 --> 00:16:02,949
that can do things like you know parse

415
00:16:00,639 --> 00:16:06,519
the JavaScript build an AST and then do

416
00:16:02,949 --> 00:16:08,199
sort of like intelligent mutations it's

417
00:16:06,519 --> 00:16:12,279
a lot of work but you know this

418
00:16:08,199 --> 00:16:14,079
technique is pretty powerful there's an

419
00:16:12,279 --> 00:16:17,019
easier way though and that's where Lib

420
00:16:14,079 --> 00:16:19,089
protobuf mutator comes in Lou protobuf

421
00:16:17,019 --> 00:16:21,100
mutator will actually handle mutation

422
00:16:19,089 --> 00:16:23,709
for you and you only have to do work

423
00:16:21,100 --> 00:16:26,529
around there so let's let me explain

424
00:16:23,709 --> 00:16:29,109
what I mean here so the proto brough

425
00:16:26,529 --> 00:16:31,209
mutator is a custom mutator for protobuf

426
00:16:29,110 --> 00:16:34,149
just like the custom mutaters we just

427
00:16:31,209 --> 00:16:37,119
discussed and protobuf is a data format

428
00:16:34,149 --> 00:16:38,949
like json but with pipes and so what you

429
00:16:37,120 --> 00:16:42,100
can do the insight here is you can use

430
00:16:38,949 --> 00:16:44,439
protobuf to define like a spec or schema

431
00:16:42,100 --> 00:16:47,139
for the inputs you want Lib fuzzer to

432
00:16:44,439 --> 00:16:49,180
mutate so if you see on the slides we

433
00:16:47,139 --> 00:16:51,639
have an ADD expression to find them

434
00:16:49,180 --> 00:16:54,040
protobuf and in this simple case we'll

435
00:16:51,639 --> 00:16:56,649
have two operands that are both integers

436
00:16:54,040 --> 00:16:58,209
but protobuf is rich enough that you can

437
00:16:56,649 --> 00:17:00,279
make each operand

438
00:16:58,209 --> 00:17:02,199
you know an int or float or an int float

439
00:17:00,279 --> 00:17:04,059
or another expression even you know it

440
00:17:02,199 --> 00:17:10,030
gives you the tools that you'd probably

441
00:17:04,059 --> 00:17:12,939
want in this case so lip protobuf

442
00:17:10,030 --> 00:17:17,408
mutator will then create a test case

443
00:17:12,939 --> 00:17:19,600
based on the spec for you and as we see

444
00:17:17,409 --> 00:17:22,419
here we've got you know two operands ten

445
00:17:19,599 --> 00:17:24,609
and nine and you know that's basically

446
00:17:22,419 --> 00:17:26,679
exactly what we intended and so

447
00:17:24,609 --> 00:17:28,959
obviously like we saw before you can't

448
00:17:26,679 --> 00:17:30,549
feed this to anything unless it accepts

449
00:17:28,960 --> 00:17:33,340
protobuf right it's not useful for

450
00:17:30,549 --> 00:17:35,139
fuzzing something like v8 so what we do

451
00:17:33,340 --> 00:17:36,939
is we have our interpreter for this and

452
00:17:35,140 --> 00:17:40,720
our interpreter here will just convert

453
00:17:36,940 --> 00:17:40,960
from this intermediate format into the

454
00:17:40,720 --> 00:17:42,460
tar

455
00:17:40,960 --> 00:17:44,830
good format javascript will take both

456
00:17:42,460 --> 00:17:46,809
operands convert them to strings and add

457
00:17:44,830 --> 00:17:49,270
a plus sign in between them luke

458
00:17:46,809 --> 00:17:51,039
protobuf mutator is extremely effective

459
00:17:49,270 --> 00:17:52,899
and actually all of the fuzzers that

460
00:17:51,039 --> 00:17:55,270
i've covered today have used this

461
00:17:52,899 --> 00:17:56,918
technique the you know this includes

462
00:17:55,270 --> 00:17:59,559
everything from like the skia fuzzer to

463
00:17:56,919 --> 00:18:02,130
the app cache browser which the app

464
00:17:59,559 --> 00:18:06,700
cache fuzzer actually was used in a

465
00:18:02,130 --> 00:18:08,049
recent X was using an exploit that you

466
00:18:06,700 --> 00:18:09,669
know how to sandbox escape and

467
00:18:08,049 --> 00:18:11,620
everything so completely owning Chrome

468
00:18:09,669 --> 00:18:12,340
with the vulnerability found by the app

469
00:18:11,620 --> 00:18:14,379
cache fuzzer

470
00:18:12,340 --> 00:18:17,439
and actually the protobuf mutator was

471
00:18:14,380 --> 00:18:19,690
again used by my coworker Ned to find

472
00:18:17,440 --> 00:18:22,380
the vulnerability in the iOS kernel that

473
00:18:19,690 --> 00:18:25,059
was used in the iOS I think 12.2

474
00:18:22,380 --> 00:18:27,970
jailbreak so you can use it to find some

475
00:18:25,059 --> 00:18:30,158
pretty nice bugs and it's sort of the

476
00:18:27,970 --> 00:18:33,720
technique I'd recommend when in most

477
00:18:30,159 --> 00:18:33,720
cases for writing a structured buzzer

478
00:18:34,140 --> 00:18:40,960
the last option you have is one that's

479
00:18:38,860 --> 00:18:43,600
like a pretty exciting area more for

480
00:18:40,960 --> 00:18:45,610
future work but I don't have fantastic

481
00:18:43,600 --> 00:18:47,709
results from it so far so I'll just sort

482
00:18:45,610 --> 00:18:49,990
of explain it and maybe give some tips

483
00:18:47,710 --> 00:18:53,110
on how you might be able to do it now

484
00:18:49,990 --> 00:18:55,720
imagine you have a black box buzzer

485
00:18:53,110 --> 00:18:58,689
basically something like a Python script

486
00:18:55,720 --> 00:19:00,510
that can mutate HTML files that you then

487
00:18:58,690 --> 00:19:04,090
feed the chrome and try and get crashes

488
00:19:00,510 --> 00:19:06,340
you could convert this into a Lib buzzer

489
00:19:04,090 --> 00:19:08,408
custom mutator to add the power of

490
00:19:06,340 --> 00:19:11,168
coverage guided fuzzing to this black

491
00:19:08,409 --> 00:19:12,909
box buzzer that you have and so some of

492
00:19:11,169 --> 00:19:14,590
the challenges that you might encounter

493
00:19:12,909 --> 00:19:17,169
when doing this that you might have to

494
00:19:14,590 --> 00:19:20,740
overcome are you know if you imagine how

495
00:19:17,169 --> 00:19:22,960
this buzzer works you'll have a corpus

496
00:19:20,740 --> 00:19:25,059
of test cases and your frezzer will pick

497
00:19:22,960 --> 00:19:27,250
one at random mutate it and that gets

498
00:19:25,059 --> 00:19:30,990
fed to your target now if it were a

499
00:19:27,250 --> 00:19:33,250
custom mutator what would happen is

500
00:19:30,990 --> 00:19:34,690
there's a lot this ain't pretty much the

501
00:19:33,250 --> 00:19:36,640
same but there's a last step at the end

502
00:19:34,690 --> 00:19:38,500
where a test case will be added back to

503
00:19:36,640 --> 00:19:40,419
the corpus and this could present the

504
00:19:38,500 --> 00:19:41,620
problem for some fuzzers because they

505
00:19:40,419 --> 00:19:43,299
can't actually mutate their own output

506
00:19:41,620 --> 00:19:45,309
sometimes they're not used to be running

507
00:19:43,299 --> 00:19:48,760
in a kind of loop you know I was

508
00:19:45,309 --> 00:19:51,190
recently converting a font mutator into

509
00:19:48,760 --> 00:19:53,049
a Lib fuzzer custom mutator and the

510
00:19:51,190 --> 00:19:54,370
problem there was you know this this

511
00:19:53,049 --> 00:19:57,029
font mutator would parse

512
00:19:54,370 --> 00:20:00,219
what expected to be semi valid fonts and

513
00:19:57,029 --> 00:20:02,740
mutate them and you know that I would

514
00:20:00,220 --> 00:20:04,210
then feed to the target well you know

515
00:20:02,740 --> 00:20:05,950
once it was mutated

516
00:20:04,210 --> 00:20:08,169
sometimes wouldn't be able to parse

517
00:20:05,950 --> 00:20:10,150
those mutated outputs again so in that

518
00:20:08,169 --> 00:20:13,390
case you could just sort of fall back to

519
00:20:10,150 --> 00:20:15,909
the lib fuzzers default mutator or even

520
00:20:13,390 --> 00:20:17,350
maybe improve your mutator the other

521
00:20:15,909 --> 00:20:19,390
problem you might have to overcome is

522
00:20:17,350 --> 00:20:21,309
sometimes these tools aren't written to

523
00:20:19,390 --> 00:20:23,080
be fast enough to run in this coverage

524
00:20:21,309 --> 00:20:25,690
guided fuzzing loop you know coverage

525
00:20:23,080 --> 00:20:27,879
guided fuzzing works best when it when

526
00:20:25,690 --> 00:20:29,260
it's quick and you know you might want

527
00:20:27,880 --> 00:20:30,580
to need to improve the speed there and

528
00:20:29,260 --> 00:20:34,210
the final thing you might need to

529
00:20:30,580 --> 00:20:36,490
improve is or work on is the fact that

530
00:20:34,210 --> 00:20:37,000
many of these test cases these mutaters

531
00:20:36,490 --> 00:20:39,340
excuse me

532
00:20:37,000 --> 00:20:42,190
are written in languages other than c++

533
00:20:39,340 --> 00:20:45,100
and to call it from a custom mutator you

534
00:20:42,190 --> 00:20:46,659
need to use whatever language the

535
00:20:45,100 --> 00:20:48,370
fuzzers written in you know it probably

536
00:20:46,659 --> 00:20:51,940
has some interface like maybe j and i

537
00:20:48,370 --> 00:20:56,500
for calling the for calling that code

538
00:20:51,940 --> 00:20:58,390
from c++ so to summarize how you can

539
00:20:56,500 --> 00:20:59,830
write a lib fuzzer custom meet it's how

540
00:20:58,390 --> 00:21:02,770
you can write a structured fuzzer using

541
00:20:59,830 --> 00:21:05,439
lib buzzer your first option is to use a

542
00:21:02,770 --> 00:21:07,240
lib buzzer custom mutator your second

543
00:21:05,440 --> 00:21:09,520
option and it's the one I recommend in

544
00:21:07,240 --> 00:21:11,440
most cases is to use the protobuf

545
00:21:09,520 --> 00:21:14,440
mutator and the third thing you can do

546
00:21:11,440 --> 00:21:16,270
which is pretty exciting is taking an

547
00:21:14,440 --> 00:21:18,159
existing black box buzzer you have and

548
00:21:16,270 --> 00:21:21,039
converting it to a lib buzzer custom

549
00:21:18,159 --> 00:21:25,630
mutator to get the power of coverage

550
00:21:21,039 --> 00:21:27,158
guided fuzzing added to your fuzzer so

551
00:21:25,630 --> 00:21:29,320
to summarize what we went over in this

552
00:21:27,159 --> 00:21:30,730
talk you should use structured fuzzing

553
00:21:29,320 --> 00:21:32,620
because it'll help you find more bugs

554
00:21:30,730 --> 00:21:35,559
you know more bugs is really the bottom

555
00:21:32,620 --> 00:21:37,418
line here and to write a structured

556
00:21:35,559 --> 00:21:39,279
fuzzer with lib buzzer you can use

557
00:21:37,419 --> 00:21:43,120
either lib clusters custom mutator

558
00:21:39,279 --> 00:21:45,520
feature or lib protobuf mutator I have

559
00:21:43,120 --> 00:21:46,989
some links at the end of the slides if

560
00:21:45,520 --> 00:21:48,750
anyone wants to check the slides

561
00:21:46,990 --> 00:21:51,820
afterwards and do further reading and

562
00:21:48,750 --> 00:21:55,059
I'll take questions now if anyone has

563
00:21:51,820 --> 00:21:58,350
them can you um can you go up to the

564
00:21:55,059 --> 00:21:58,350
microphone and ask there

565
00:22:00,139 --> 00:22:03,289
thank you

566
00:22:05,460 --> 00:22:10,749
all right so you talk about writing new

567
00:22:08,619 --> 00:22:13,629
buzzers from scratch yeah

568
00:22:10,749 --> 00:22:16,720
however last year there was a puzzle

569
00:22:13,629 --> 00:22:19,869
released which kind of does all this are

570
00:22:16,720 --> 00:22:23,019
you aware of the AFL smart uh yeah I

571
00:22:19,869 --> 00:22:24,488
have heard of AFL smart I'm I skimmed

572
00:22:23,019 --> 00:22:26,769
the paper but it seemed to me like it

573
00:22:24,489 --> 00:22:28,659
was pretty much a similar idea to lib

574
00:22:26,769 --> 00:22:30,450
protobuf mutator where you take you know

575
00:22:28,659 --> 00:22:32,619
you sort of write like peach pits and

576
00:22:30,450 --> 00:22:34,239
yeah it's just a similar idea I think

577
00:22:32,619 --> 00:22:35,830
the lib protobuf mutator you like to

578
00:22:34,239 --> 00:22:37,989
finding you know you're defining a

579
00:22:35,830 --> 00:22:39,639
schema for what you want me to define

580
00:22:37,989 --> 00:22:41,169
the pitched files where you have the

581
00:22:39,639 --> 00:22:43,629
grammar and you also have all of the

582
00:22:41,169 --> 00:22:45,999
advantages AFL with the speed and

583
00:22:43,629 --> 00:22:47,529
efficiency and you can make it structure

584
00:22:45,999 --> 00:22:50,259
where by defining the grammar by

585
00:22:47,529 --> 00:22:52,029
yourself yes yeah you pay by investing

586
00:22:50,259 --> 00:22:53,739
time in defining grammar but Wright has

587
00:22:52,029 --> 00:22:55,480
really good results in real life yeah

588
00:22:53,739 --> 00:22:56,919
yeah I mean I'm familiar with the a

589
00:22:55,480 --> 00:22:58,659
little bit familiar with the work and

590
00:22:56,919 --> 00:23:00,519
yeah they um you know I know that people

591
00:22:58,659 --> 00:23:03,639
that did it you know they they produce a

592
00:23:00,519 --> 00:23:05,320
pretty good work on AFL and yeah I'm I

593
00:23:03,639 --> 00:23:06,609
was pretty impressed with the results

594
00:23:05,320 --> 00:23:08,769
and I think it's pretty comparable to

595
00:23:06,609 --> 00:23:10,239
lip protobuf mutaters so yeah yeah

596
00:23:08,769 --> 00:23:12,460
because I was curious if you're using it

597
00:23:10,239 --> 00:23:14,679
and we're we're not using it but I'm

598
00:23:12,460 --> 00:23:16,179
currently exploring ways to view this

599
00:23:14,679 --> 00:23:17,499
better and so that's definitely one of

600
00:23:16,179 --> 00:23:20,679
the things I'm gonna be looking at yeah

601
00:23:17,499 --> 00:23:22,559
cuz I mean protobuf isn't like a you

602
00:23:20,679 --> 00:23:25,779
know it wasn't designed for making

603
00:23:22,559 --> 00:23:28,869
buzzer grammars right and so you know

604
00:23:25,779 --> 00:23:30,789
maybe something like peaches pits would

605
00:23:28,869 --> 00:23:32,769
be better at that I sort of think that

606
00:23:30,789 --> 00:23:34,330
the fact that protobuf might not have

607
00:23:32,769 --> 00:23:36,299
all these features might be a good thing

608
00:23:34,330 --> 00:23:38,619
you know because in conversion and

609
00:23:36,299 --> 00:23:40,509
interpreting you have unlimited power

610
00:23:38,619 --> 00:23:43,149
right you have full SEPA and everyone

611
00:23:40,509 --> 00:23:45,970
knows how to write C++ already so you

612
00:23:43,149 --> 00:23:47,590
don't need to learn like a new format to

613
00:23:45,970 --> 00:23:49,809
you know write write these effectively

614
00:23:47,590 --> 00:23:51,279
so it might be a feature but I'll

615
00:23:49,809 --> 00:23:53,289
definitely going to be taking a look at

616
00:23:51,279 --> 00:23:55,629
that yeah yeah at the first point you

617
00:23:53,289 --> 00:24:00,580
said converting and we also had to dub

618
00:23:55,629 --> 00:24:02,408
pseudocode phase to interpret that the

619
00:24:00,580 --> 00:24:04,389
decoded results like with the functions

620
00:24:02,409 --> 00:24:06,009
and the headers and you have to parse

621
00:24:04,389 --> 00:24:08,439
that one more time basically adding

622
00:24:06,009 --> 00:24:10,359
another overhead that kinda can already

623
00:24:08,440 --> 00:24:11,619
be done with Al feel smart and we were

624
00:24:10,359 --> 00:24:15,070
really proud with the results we had

625
00:24:11,619 --> 00:24:17,799
with it and yeah I was I was curious if

626
00:24:15,070 --> 00:24:19,010
you if you're even considering using it

627
00:24:17,799 --> 00:24:21,470
in the future instead of right

628
00:24:19,010 --> 00:24:22,490
your own custom fuzzers well I mean I

629
00:24:21,470 --> 00:24:25,970
don't really consider it that

630
00:24:22,490 --> 00:24:27,380
differently that different from you know

631
00:24:25,970 --> 00:24:29,450
writing something with lib protobuf

632
00:24:27,380 --> 00:24:31,850
meteor I mean and that's primarily what

633
00:24:29,450 --> 00:24:34,010
we use for you know writing these things

634
00:24:31,850 --> 00:24:35,959
like I said I think all the examples

635
00:24:34,010 --> 00:24:38,060
that I presented in this talk we're

636
00:24:35,960 --> 00:24:41,770
written using lib protobuf mutator okay

637
00:24:38,060 --> 00:24:41,770
thanks thanks for the question

638
00:24:42,430 --> 00:24:50,559
[Applause]

