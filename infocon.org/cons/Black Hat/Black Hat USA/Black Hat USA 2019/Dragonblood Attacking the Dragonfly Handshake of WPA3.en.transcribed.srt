1
00:00:00,000 --> 00:00:05,640
good morning and welcome to dragonblood

2
00:00:02,490 --> 00:00:09,150
attacking the dragonfly handshake of WPA

3
00:00:05,640 --> 00:00:11,639
three in Laguna GHI our speaker this

4
00:00:09,150 --> 00:00:13,799
morning is Maddie Van Hoff just a couple

5
00:00:11,639 --> 00:00:15,690
of housekeeping things don't forget to

6
00:00:13,799 --> 00:00:17,939
stop by the business hall that's located

7
00:00:15,690 --> 00:00:21,539
in Mandalay Bay Oceanside in shoreline

8
00:00:17,940 --> 00:00:23,789
ballrooms on level two the Welcome

9
00:00:21,539 --> 00:00:24,830
Reception is tonight at 5:30 in those

10
00:00:23,789 --> 00:00:27,240
rooms

11
00:00:24,830 --> 00:00:30,028
the blackhat Arsenal is in the business

12
00:00:27,240 --> 00:00:31,890
hall on level two and don't forget that

13
00:00:30,029 --> 00:00:34,950
tonight is the Pawnee Awards and those

14
00:00:31,890 --> 00:00:36,840
are in Laguna JKL which is just next

15
00:00:34,950 --> 00:00:38,280
door don't forget to silence your phones

16
00:00:36,840 --> 00:00:39,050
and with that I'll turn it over to Mandy

17
00:00:38,280 --> 00:00:42,210
thanks

18
00:00:39,050 --> 00:00:44,879
okay good morning everyone so I am NOT

19
00:00:42,210 --> 00:00:47,670
even off I'm a postdoctoral researcher

20
00:00:44,879 --> 00:00:50,910
at New York University and together with

21
00:00:47,670 --> 00:00:54,390
al Ronan we researched the security of

22
00:00:50,910 --> 00:00:57,029
the dragonfly handshake this is a very

23
00:00:54,390 --> 00:00:58,829
relevant topic because just last year

24
00:00:57,030 --> 00:01:02,430
the dragonfly handshake has been adopted

25
00:00:58,829 --> 00:01:05,670
by WPA three as the new handshake for

26
00:01:02,430 --> 00:01:08,460
this protocol now before dragonfly was

27
00:01:05,670 --> 00:01:11,570
adopted by WPA three it was also and

28
00:01:08,460 --> 00:01:14,429
ready already in use by the EEP PWD

29
00:01:11,570 --> 00:01:16,758
protocol now for those of you that don't

30
00:01:14,430 --> 00:01:19,049
know what the EPW D protocol is

31
00:01:16,759 --> 00:01:22,229
basically it's an authentication

32
00:01:19,049 --> 00:01:24,810
protocol that is used in a relatively

33
00:01:22,229 --> 00:01:27,060
small amount of enterprise Wi-Fi

34
00:01:24,810 --> 00:01:29,880
networks where you attenti kate's using

35
00:01:27,060 --> 00:01:31,619
a username on packets so in this talk

36
00:01:29,880 --> 00:01:34,530
I'm going to present the research that

37
00:01:31,619 --> 00:01:37,159
we did on this handshake arms several

38
00:01:34,530 --> 00:01:40,020
vulnerabilities that we found against it

39
00:01:37,159 --> 00:01:42,630
now first and for all a quick

40
00:01:40,020 --> 00:01:46,798
introduction about what the dragonfly

41
00:01:42,630 --> 00:01:48,689
handshake is so the dragonfly handshake

42
00:01:46,799 --> 00:01:51,570
is something that we call a password

43
00:01:48,689 --> 00:01:55,919
authenticated key exchange or in other

44
00:01:51,570 --> 00:01:58,350
words a pig what does that mean well

45
00:01:55,920 --> 00:02:00,719
first on and for all the obvious thing

46
00:01:58,350 --> 00:02:02,759
it means that authentication is

47
00:02:00,719 --> 00:02:05,309
performed based on a shared password

48
00:02:02,759 --> 00:02:09,000
between for example a client and a

49
00:02:05,310 --> 00:02:10,920
server or a client on an access point on

50
00:02:09,000 --> 00:02:13,620
the case of dragonfly this handshake

51
00:02:10,919 --> 00:02:15,390
provides mutual authentication which

52
00:02:13,620 --> 00:02:17,849
is what you would expect the client has

53
00:02:15,390 --> 00:02:19,738
to prove that it knows the password on

54
00:02:17,849 --> 00:02:21,659
the other hand the access point also has

55
00:02:19,739 --> 00:02:23,610
to prove that it knows the password as

56
00:02:21,659 --> 00:02:27,170
well in other words that you're not

57
00:02:23,610 --> 00:02:30,540
connecting to a rogue access point

58
00:02:27,170 --> 00:02:33,268
like most handshakes dragonfly handshake

59
00:02:30,540 --> 00:02:35,459
also negotiates a fresh session key on

60
00:02:33,269 --> 00:02:37,860
this session key is used after the

61
00:02:35,459 --> 00:02:42,900
handshake to encrypt data frames armed

62
00:02:37,860 --> 00:02:45,480
to protect your normal data traffic now

63
00:02:42,900 --> 00:02:47,940
the interesting property of the

64
00:02:45,480 --> 00:02:50,010
dragonfly handshake is that it also

65
00:02:47,940 --> 00:02:52,440
tries to defend against dictionary

66
00:02:50,010 --> 00:02:56,340
attacks on that it provides forward

67
00:02:52,440 --> 00:03:00,209
secrecy this is a big advantage compared

68
00:02:56,340 --> 00:03:03,450
to wk 2 because for example with wpa2 an

69
00:03:00,209 --> 00:03:06,150
attacker can passively capture the

70
00:03:03,450 --> 00:03:07,738
handshake that someone makes you can

71
00:03:06,150 --> 00:03:10,170
then he or she can then take that

72
00:03:07,739 --> 00:03:12,540
handshake offline on perform offline

73
00:03:10,170 --> 00:03:15,358
dictionary attacks against the password

74
00:03:12,540 --> 00:03:16,828
of the network but I did what dragonfly

75
00:03:15,359 --> 00:03:19,410
handshake is that this is impossible

76
00:03:16,829 --> 00:03:22,579
that dictionary attacks will no longer

77
00:03:19,410 --> 00:03:26,489
be possible either by passive or active

78
00:03:22,579 --> 00:03:27,959
attacks on top of that the dragonfly

79
00:03:26,489 --> 00:03:30,419
handshake is also designed to provide

80
00:03:27,959 --> 00:03:33,060
forward secrecy meaning if I capture

81
00:03:30,419 --> 00:03:35,160
your network traffic today and if a year

82
00:03:33,060 --> 00:03:37,290
later I learn your password of the

83
00:03:35,160 --> 00:03:39,540
network I cannot do anything with that I

84
00:03:37,290 --> 00:03:42,239
cannot go back in time on decrypt

85
00:03:39,540 --> 00:03:43,959
traffic that I captured a year or more

86
00:03:42,239 --> 00:03:47,829
ago

87
00:03:43,959 --> 00:03:50,439
now one other property that certain big

88
00:03:47,829 --> 00:03:53,200
handshakes provides is that they protect

89
00:03:50,439 --> 00:03:54,939
against server compromised but

90
00:03:53,200 --> 00:03:58,599
unfortunately the dragonfly handshake

91
00:03:54,939 --> 00:04:01,060
doesn't have that property so what does

92
00:03:58,599 --> 00:04:03,189
that mean in practice and practice that

93
00:04:01,060 --> 00:04:05,889
means that if someone can compromise

94
00:04:03,189 --> 00:04:08,260
your access points or your router the

95
00:04:05,889 --> 00:04:09,969
attacker is able to for example read the

96
00:04:08,260 --> 00:04:13,510
memory of the device and get the

97
00:04:09,969 --> 00:04:15,430
passwords from the device in contrast

98
00:04:13,510 --> 00:04:18,310
some other pics allow you to store the

99
00:04:15,430 --> 00:04:23,680
the passwords in a salt 'its way that

100
00:04:18,310 --> 00:04:25,090
makes that a lot harder now before we're

101
00:04:23,680 --> 00:04:27,099
going to go into the details of this

102
00:04:25,090 --> 00:04:30,460
handshake let me give a very high-level

103
00:04:27,099 --> 00:04:32,440
description how it works let's assume

104
00:04:30,460 --> 00:04:34,719
that we have a client here a smartphone

105
00:04:32,440 --> 00:04:39,070
that wants to connect to the access

106
00:04:34,720 --> 00:04:40,810
point then before the dragonfly

107
00:04:39,070 --> 00:04:43,990
handshake can be executed

108
00:04:40,810 --> 00:04:46,210
both peers must convert the passwords

109
00:04:43,990 --> 00:04:49,330
which is commonly stored just and plain

110
00:04:46,210 --> 00:04:52,270
ASCII to a so-called group element which

111
00:04:49,330 --> 00:04:54,580
we call P here now why does this have to

112
00:04:52,270 --> 00:04:57,789
be done well the idea is that this group

113
00:04:54,580 --> 00:04:59,650
element P is for example a large number

114
00:04:57,789 --> 00:05:03,400
which can then be used in the

115
00:04:59,650 --> 00:05:04,630
cryptographic operations of dragonfly so

116
00:05:03,400 --> 00:05:07,960
that's the first thing that needs to

117
00:05:04,630 --> 00:05:10,090
happen um once that is done the

118
00:05:07,960 --> 00:05:12,609
handshake essentially consists of two

119
00:05:10,090 --> 00:05:17,710
main phases the first phase is the

120
00:05:12,610 --> 00:05:20,590
commit phase and summarized this is used

121
00:05:17,710 --> 00:05:23,770
to negotiate the session key that the

122
00:05:20,590 --> 00:05:27,039
handshake provides the second phase is

123
00:05:23,770 --> 00:05:30,008
the confirmed phrase as the name implies

124
00:05:27,039 --> 00:05:33,099
this is used to confirm that both peers

125
00:05:30,009 --> 00:05:35,409
negotiated the same session key and this

126
00:05:33,099 --> 00:05:40,180
also proves that they indeed possess the

127
00:05:35,409 --> 00:05:43,479
shared password now the most interesting

128
00:05:40,180 --> 00:05:45,970
part of this handshake is how the S key

129
00:05:43,479 --> 00:05:49,300
password is converted into this group

130
00:05:45,970 --> 00:05:51,849
element P because this is also where

131
00:05:49,300 --> 00:05:56,440
most of the vulnerabilities we discussed

132
00:05:51,849 --> 00:05:58,030
lie before we get to this there's one

133
00:05:56,440 --> 00:05:59,740
important remark and then

134
00:05:58,030 --> 00:06:02,229
that this handshake the dragonfly

135
00:05:59,740 --> 00:06:05,410
handshake can be executed using two

136
00:06:02,230 --> 00:06:08,170
so-called cryptographic groups it can be

137
00:06:05,410 --> 00:06:12,370
executed using mod P groups aren't using

138
00:06:08,170 --> 00:06:15,190
elliptic curves now you may not all know

139
00:06:12,370 --> 00:06:17,980
what these cryptographic groups are so

140
00:06:15,190 --> 00:06:21,430
let me give a very short introduction to

141
00:06:17,980 --> 00:06:23,560
what mod p groups are basically when

142
00:06:21,430 --> 00:06:26,290
you're using mod P groups it means all

143
00:06:23,560 --> 00:06:29,560
your crypto operations happens using

144
00:06:26,290 --> 00:06:33,100
normal numbers this number has to be

145
00:06:29,560 --> 00:06:35,470
smaller than an agreed upon prime for

146
00:06:33,100 --> 00:06:38,410
all members for all numbers in this

147
00:06:35,470 --> 00:06:41,050
cryptographic group the equation you see

148
00:06:38,410 --> 00:06:44,710
here in the second bullet point this one

149
00:06:41,050 --> 00:06:48,160
has to hold now fortunately this math

150
00:06:44,710 --> 00:06:52,270
will not be important but it is good to

151
00:06:48,160 --> 00:06:53,890
briefly introduce this if you're

152
00:06:52,270 --> 00:06:56,109
wondering why are they called mod P

153
00:06:53,890 --> 00:06:58,810
groups well that's this is because all

154
00:06:56,110 --> 00:07:02,590
operations happen modulo the prime of

155
00:06:58,810 --> 00:07:06,070
the group so let's get back to our

156
00:07:02,590 --> 00:07:08,560
original problem here before the

157
00:07:06,070 --> 00:07:11,290
handshake can be executed the plaintext

158
00:07:08,560 --> 00:07:13,600
s key password has to be converted into

159
00:07:11,290 --> 00:07:17,190
an element of this cryptographic group

160
00:07:13,600 --> 00:07:21,430
and the question is how can that be done

161
00:07:17,190 --> 00:07:25,320
well a naive way is to simply take a

162
00:07:21,430 --> 00:07:27,850
hash of the password here denoted by P W

163
00:07:25,320 --> 00:07:30,730
combine that with MAC addresses of the

164
00:07:27,850 --> 00:07:32,110
client on the access point and then use

165
00:07:30,730 --> 00:07:34,750
the result the output of the hash

166
00:07:32,110 --> 00:07:38,320
function which is here called value is

167
00:07:34,750 --> 00:07:40,180
then interpreted as a number we then

168
00:07:38,320 --> 00:07:41,740
perform some kind of special computation

169
00:07:40,180 --> 00:07:44,440
you don't need to know the details here

170
00:07:41,740 --> 00:07:47,170
but basically this transforms the hash

171
00:07:44,440 --> 00:07:51,580
output into a valid member of the script

172
00:07:47,170 --> 00:07:54,730
the graphic group of the ideas that the

173
00:07:51,580 --> 00:08:00,159
results of this formula can then be used

174
00:07:54,730 --> 00:08:02,680
in our cryptographic operations now this

175
00:08:00,160 --> 00:08:05,890
is all nice and well but unfortunately

176
00:08:02,680 --> 00:08:09,220
there is one problem with this namely

177
00:08:05,890 --> 00:08:12,009
for certain mod P groups there's a high

178
00:08:09,220 --> 00:08:15,039
chance that the hash output

179
00:08:12,009 --> 00:08:17,769
oh this algorithm when interpreted as a

180
00:08:15,039 --> 00:08:20,009
number is bigger than the prime of this

181
00:08:17,769 --> 00:08:24,189
cryptographic group that is being used

182
00:08:20,009 --> 00:08:25,929
to simplify the explanation if this

183
00:08:24,189 --> 00:08:27,999
value is bigger than the prime then

184
00:08:25,929 --> 00:08:29,919
essentially this formula doesn't work to

185
00:08:27,999 --> 00:08:33,939
convert the number into an valid member

186
00:08:29,919 --> 00:08:36,240
of the group so how did the designers of

187
00:08:33,938 --> 00:08:40,929
dragonfly decides to tackle that

188
00:08:36,240 --> 00:08:42,879
well they added a condition here where

189
00:08:40,929 --> 00:08:45,489
they are going to check ok is this value

190
00:08:42,879 --> 00:08:48,249
larger than the prime then we need to do

191
00:08:45,490 --> 00:08:51,189
something and what is what do they do

192
00:08:48,249 --> 00:08:54,100
well they decided to include a counter

193
00:08:51,189 --> 00:08:56,860
in the hash value in case in the first

194
00:08:54,100 --> 00:08:58,629
try this hash output was too big they're

195
00:08:56,860 --> 00:09:00,300
simply going to increase the counter and

196
00:08:58,629 --> 00:09:02,559
try again

197
00:09:00,300 --> 00:09:04,199
it's still not the case they will again

198
00:09:02,559 --> 00:09:05,490
increase the counter and try again

199
00:09:04,200 --> 00:09:08,680
[Music]

200
00:09:05,490 --> 00:09:12,730
so maybe some of you will already see

201
00:09:08,680 --> 00:09:15,870
the problem with this algorithm the

202
00:09:12,730 --> 00:09:18,850
problem is that the number of iterations

203
00:09:15,870 --> 00:09:23,139
that are being executed here depends on

204
00:09:18,850 --> 00:09:25,870
the password in other words we have a

205
00:09:23,139 --> 00:09:29,399
side channel leak and I will show how

206
00:09:25,870 --> 00:09:31,899
this can be used to recover the password

207
00:09:29,399 --> 00:09:34,779
what's make what makes the story even

208
00:09:31,899 --> 00:09:38,829
more interesting is that the designers

209
00:09:34,779 --> 00:09:41,410
were actually warned about this when

210
00:09:38,829 --> 00:09:46,569
this dragonfly handshake was proposed

211
00:09:41,410 --> 00:09:48,610
already back in 2010 both the ietf on

212
00:09:46,569 --> 00:09:50,319
the CFR G which are basically two

213
00:09:48,610 --> 00:09:53,019
mailing lists where people discuss new

214
00:09:50,319 --> 00:09:55,779
protocols they want that this handshake

215
00:09:53,019 --> 00:09:59,350
might be susceptible to timing attacks

216
00:09:55,779 --> 00:10:04,209
another side channel attacks so how come

217
00:09:59,350 --> 00:10:07,420
that this algorithm now still managed to

218
00:10:04,209 --> 00:10:11,349
get it to find its way into WPA 3 well

219
00:10:07,420 --> 00:10:14,079
at the time the reply was I'm not sure

220
00:10:11,350 --> 00:10:16,029
how important this problem is I don't

221
00:10:14,079 --> 00:10:18,819
think the designers thought that this

222
00:10:16,029 --> 00:10:20,589
wasn't a very practical attack and there

223
00:10:18,819 --> 00:10:22,110
was also some doubt about whether it

224
00:10:20,589 --> 00:10:23,559
really leaked the shared password

225
00:10:22,110 --> 00:10:25,130
another word

226
00:10:23,559 --> 00:10:27,620
in other words yeah there might be

227
00:10:25,130 --> 00:10:29,810
information that is elite but can you

228
00:10:27,620 --> 00:10:34,700
really recover the password based on

229
00:10:29,810 --> 00:10:36,829
this alone so let me now explain how you

230
00:10:34,700 --> 00:10:40,040
can indeed use this to recover the

231
00:10:36,830 --> 00:10:40,850
password let's say that we have a Wi-Fi

232
00:10:40,040 --> 00:10:44,719
access point

233
00:10:40,850 --> 00:10:47,690
it supports WPA 3 and it uses the

234
00:10:44,720 --> 00:10:50,030
algorithm that I just explained then as

235
00:10:47,690 --> 00:10:52,970
an attacker what I can try to do is I

236
00:10:50,030 --> 00:10:56,300
can try to connect to it and I can

237
00:10:52,970 --> 00:10:59,120
measure how long it takes for the access

238
00:10:56,300 --> 00:11:01,430
point to reply on based on that time I

239
00:10:59,120 --> 00:11:03,200
can derive how many iterations the

240
00:11:01,430 --> 00:11:05,390
access point needed to convert the

241
00:11:03,200 --> 00:11:09,770
password into a member of the crypto

242
00:11:05,390 --> 00:11:12,350
group here in this example it takes the

243
00:11:09,770 --> 00:11:15,800
access point two iterations to transform

244
00:11:12,350 --> 00:11:17,540
the password now how can I use this to

245
00:11:15,800 --> 00:11:21,729
for example perform a dictionary attack

246
00:11:17,540 --> 00:11:24,770
well let's say I have three passwords as

247
00:11:21,730 --> 00:11:27,740
possible candidates then I can as an

248
00:11:24,770 --> 00:11:29,870
attacker run this algorithm offline on

249
00:11:27,740 --> 00:11:32,000
my own laptop and measure how many

250
00:11:29,870 --> 00:11:35,750
iterations it would take if I use a

251
00:11:32,000 --> 00:11:38,600
certain password and in my example here

252
00:11:35,750 --> 00:11:40,580
password one we take one iteration on

253
00:11:38,600 --> 00:11:43,850
the other two passwords we take two

254
00:11:40,580 --> 00:11:47,390
iterations and from this information I

255
00:11:43,850 --> 00:11:49,100
can deduce that password one isn't being

256
00:11:47,390 --> 00:11:54,010
used by the access point because that

257
00:11:49,100 --> 00:11:57,500
doesn't match our observations however a

258
00:11:54,010 --> 00:11:59,810
lot of other passwords are still

259
00:11:57,500 --> 00:12:03,020
possible for example here we don't know

260
00:11:59,810 --> 00:12:05,599
whether password 2 or 3 is being used so

261
00:12:03,020 --> 00:12:09,350
is there a way that we can get more

262
00:12:05,600 --> 00:12:12,260
information and it turns out that there

263
00:12:09,350 --> 00:12:16,340
is because if we look at the algorithm

264
00:12:12,260 --> 00:12:19,069
again we can see that the MAC addresses

265
00:12:16,340 --> 00:12:21,620
of the client on the access point they

266
00:12:19,070 --> 00:12:25,010
also influence how many iterations are

267
00:12:21,620 --> 00:12:27,830
executed so what can we do as an

268
00:12:25,010 --> 00:12:30,590
attacker well as an attacker I can spoof

269
00:12:27,830 --> 00:12:32,480
another MAC address as a client and I

270
00:12:30,590 --> 00:12:35,300
can again measure how many iterations

271
00:12:32,480 --> 00:12:37,610
the access point needs to execute and

272
00:12:35,300 --> 00:12:38,579
then I can spoof another MAC address on

273
00:12:37,610 --> 00:12:40,709
the game measure how

274
00:12:38,579 --> 00:12:44,388
many iterations that the access points

275
00:12:40,709 --> 00:12:47,069
needs so let's go back to our example

276
00:12:44,389 --> 00:12:49,619
let's say as an attacker we now use MAC

277
00:12:47,069 --> 00:12:52,139
address B aren't we measure that the

278
00:12:49,619 --> 00:12:54,089
access point needs one iteration to

279
00:12:52,139 --> 00:12:57,899
convert the passwords into a member of

280
00:12:54,089 --> 00:13:00,899
the crypto group as an attacker we can

281
00:12:57,899 --> 00:13:03,480
again simulate on our own computer how

282
00:13:00,899 --> 00:13:06,329
long how many iterations are needed for

283
00:13:03,480 --> 00:13:09,209
candidate passwords here for example

284
00:13:06,329 --> 00:13:12,649
password - we need 2 iterations while

285
00:13:09,209 --> 00:13:14,969
password 3 would need one iteration and

286
00:13:12,649 --> 00:13:17,910
this means we can conclude that password

287
00:13:14,970 --> 00:13:21,299
2 is not in use we can continue this

288
00:13:17,910 --> 00:13:23,759
approach with more MAC addresses until

289
00:13:21,299 --> 00:13:26,939
we uniquely determines the password of

290
00:13:23,759 --> 00:13:34,079
the network which here on our example is

291
00:13:26,939 --> 00:13:38,339
s word 3 so now the question that you

292
00:13:34,079 --> 00:13:41,099
may have is ok this is possible but how

293
00:13:38,339 --> 00:13:43,079
many MAC addresses do I need to spoof do

294
00:13:41,100 --> 00:13:44,970
I need to measure in order to for

295
00:13:43,079 --> 00:13:48,868
example perform a dictionary attack

296
00:13:44,970 --> 00:13:52,169
using a large dictionary well it turns

297
00:13:48,869 --> 00:13:55,169
out you need very few measurements to do

298
00:13:52,169 --> 00:13:58,709
this for example let's say you take the

299
00:13:55,169 --> 00:14:02,160
RockYou password dump as a reference in

300
00:13:58,709 --> 00:14:04,859
that case you need to spoof around 17

301
00:14:02,160 --> 00:14:07,290
MAC addresses to be able to uniquely

302
00:14:04,860 --> 00:14:11,009
determine the password at least if it is

303
00:14:07,290 --> 00:14:16,439
in the raku database dump so that isn't

304
00:14:11,009 --> 00:14:19,999
too much the main takeaway message here

305
00:14:16,439 --> 00:14:23,099
the main thing to remember is that this

306
00:14:19,999 --> 00:14:25,350
number of iterations that the access

307
00:14:23,100 --> 00:14:28,110
point needs to convert the password into

308
00:14:25,350 --> 00:14:30,559
a group elements this essentially forms

309
00:14:28,110 --> 00:14:33,660
a signature of the password

310
00:14:30,559 --> 00:14:35,910
um this signature can then be used to

311
00:14:33,660 --> 00:14:40,589
perform an offline dictionary or even a

312
00:14:35,910 --> 00:14:42,529
brute-force attack now a final thing

313
00:14:40,589 --> 00:14:45,959
that I haven't explained here yet is

314
00:14:42,529 --> 00:14:48,269
whether it's really possible to measure

315
00:14:45,959 --> 00:14:51,179
how many iterations that the access

316
00:14:48,269 --> 00:14:52,529
point executes I mean is it possible to

317
00:14:51,179 --> 00:14:54,569
do over Wi-Fi because

318
00:14:52,529 --> 00:14:56,459
with Wi-Fi there can be a lot of

319
00:14:54,569 --> 00:15:00,539
overheads messages can be dropped or

320
00:14:56,459 --> 00:15:05,128
delayed so is this feasible to test this

321
00:15:00,539 --> 00:15:07,468
we took a Raspberry Pi 1 on this

322
00:15:05,129 --> 00:15:11,069
Raspberry Pi one we use the open source

323
00:15:07,469 --> 00:15:14,489
host APD software to set up a WPA 3

324
00:15:11,069 --> 00:15:17,878
access point now the this open source

325
00:15:14,489 --> 00:15:20,129
software is also used in nearly all home

326
00:15:17,879 --> 00:15:23,129
routers and in a lot of professional

327
00:15:20,129 --> 00:15:25,379
access points as well and the reason we

328
00:15:23,129 --> 00:15:28,829
picked a Raspberry Pi is because it's

329
00:15:25,379 --> 00:15:31,019
CPU matches the CPU of ordinary home

330
00:15:28,829 --> 00:15:35,069
routers and even some professional

331
00:15:31,019 --> 00:15:36,959
access points it turns out that if we

332
00:15:35,069 --> 00:15:39,238
then measure how long it takes for

333
00:15:36,959 --> 00:15:41,909
access points to reply we can indeed

334
00:15:39,239 --> 00:15:45,899
recover how many iterations the

335
00:15:41,909 --> 00:15:49,229
algorithm needed and our specific setup

336
00:15:45,899 --> 00:15:51,359
we needed to perform around 75 timing

337
00:15:49,229 --> 00:15:53,879
measurements where MAC address to

338
00:15:51,359 --> 00:15:58,139
recover how many iterations that the

339
00:15:53,879 --> 00:16:00,929
access point executed now one remark

340
00:15:58,139 --> 00:16:04,979
here is that if the access point would

341
00:16:00,929 --> 00:16:06,449
use a much better or higher end CPU then

342
00:16:04,979 --> 00:16:08,159
you would need a lot more of these

343
00:16:06,449 --> 00:16:12,059
timing measurements to perform your

344
00:16:08,159 --> 00:16:14,459
attacks however because WPA 3 is mainly

345
00:16:12,059 --> 00:16:17,009
designed to hunt to run on home routers

346
00:16:14,459 --> 00:16:20,669
on the home routers don't always have

347
00:16:17,009 --> 00:16:23,729
the fastest CPU my guess is that at

348
00:16:20,669 --> 00:16:27,949
least for quite some devices this could

349
00:16:23,729 --> 00:16:31,799
have been possible in practice as well

350
00:16:27,949 --> 00:16:34,108
so it's now time to go back to the

351
00:16:31,799 --> 00:16:36,689
beginning of the presentation where if

352
00:16:34,109 --> 00:16:39,329
you still remember I mentioned that the

353
00:16:36,689 --> 00:16:42,059
handshake can be executed using two

354
00:16:39,329 --> 00:16:43,649
types of cryptographic groups the first

355
00:16:42,059 --> 00:16:46,169
one is the one that we just discussed

356
00:16:43,649 --> 00:16:49,799
namely the mod P groups but the other

357
00:16:46,169 --> 00:16:51,869
one is elliptic curves and the question

358
00:16:49,799 --> 00:16:54,449
now is do we have the same kind of side

359
00:16:51,869 --> 00:16:57,409
channels if I decide to use dragon fly

360
00:16:54,449 --> 00:17:00,238
using elliptic elliptic curves

361
00:16:57,409 --> 00:17:02,369
before I can answer that question let me

362
00:17:00,239 --> 00:17:05,639
give a very brief introduction on

363
00:17:02,369 --> 00:17:06,329
elliptic curves basically when we're

364
00:17:05,638 --> 00:17:08,938
using elliptic

365
00:17:06,329 --> 00:17:11,730
curve cryptography all the crypto

366
00:17:08,939 --> 00:17:15,029
operations are performed based on points

367
00:17:11,730 --> 00:17:17,250
on the elliptic curve on the points here

368
00:17:15,029 --> 00:17:19,890
is basically on x and y coordinates

369
00:17:17,250 --> 00:17:23,339
where the x and y must again be smaller

370
00:17:19,890 --> 00:17:27,289
than the prime on the formula that you

371
00:17:23,339 --> 00:17:29,730
see here at the bottom it must also old

372
00:17:27,289 --> 00:17:33,870
fortunately we again don't need to know

373
00:17:29,730 --> 00:17:36,419
all the mathematical details here what

374
00:17:33,870 --> 00:17:39,299
we do need to know is how the passwords

375
00:17:36,419 --> 00:17:42,659
is now converted into a points on the

376
00:17:39,299 --> 00:17:47,039
elliptic curve so how did they decide to

377
00:17:42,659 --> 00:17:51,269
do this um well they took a very similar

378
00:17:47,039 --> 00:17:55,049
approach as in the mod P case so what

379
00:17:51,269 --> 00:17:58,080
happens here is we take a hash of the

380
00:17:55,049 --> 00:18:00,720
password we combine it with the MAC

381
00:17:58,080 --> 00:18:04,500
addresses of the clients on the access

382
00:18:00,720 --> 00:18:07,380
point and we take the outputs of this

383
00:18:04,500 --> 00:18:11,429
hash function as the x coordinates of

384
00:18:07,380 --> 00:18:13,200
our point and then what the algorithm

385
00:18:11,429 --> 00:18:15,690
does it will try to find the

386
00:18:13,200 --> 00:18:19,230
corresponding Y value by essentially

387
00:18:15,690 --> 00:18:21,179
filling in this x value in the form here

388
00:18:19,230 --> 00:18:25,460
in the middle and then seeing if there

389
00:18:21,179 --> 00:18:29,639
is a solution for the Y variable now

390
00:18:25,460 --> 00:18:32,610
from some actually for half of all X

391
00:18:29,639 --> 00:18:35,580
values there is no solution for y so

392
00:18:32,610 --> 00:18:37,049
there's no corresponding Y solution and

393
00:18:35,580 --> 00:18:39,899
to ative lis you can think of this

394
00:18:37,049 --> 00:18:42,600
because there's because we have to take

395
00:18:39,899 --> 00:18:44,729
the square root of this formula you see

396
00:18:42,600 --> 00:18:47,809
there at the bottom on this square root

397
00:18:44,730 --> 00:18:50,639
doesn't always exist

398
00:18:47,809 --> 00:18:52,740
this is a problem because that means

399
00:18:50,639 --> 00:18:55,649
that for certain hash outputs

400
00:18:52,740 --> 00:18:58,470
there's no corresponding Y values how do

401
00:18:55,649 --> 00:19:01,199
we handle this well we handle this in a

402
00:18:58,470 --> 00:19:03,720
very similar way as before we simply

403
00:19:01,200 --> 00:19:05,429
include a counter in the hash if it

404
00:19:03,720 --> 00:19:08,519
happens that we end up with an x value

405
00:19:05,429 --> 00:19:10,260
that has no solution for the Y value we

406
00:19:08,519 --> 00:19:14,159
simply increase the counter by one and

407
00:19:10,260 --> 00:19:17,760
try again so you can see here that we

408
00:19:14,159 --> 00:19:19,500
are again having the same issue because

409
00:19:17,760 --> 00:19:20,140
the number of iterations that are

410
00:19:19,500 --> 00:19:25,120
execute

411
00:19:20,140 --> 00:19:29,190
here depend on the password as well if

412
00:19:25,120 --> 00:19:32,070
we look at the PWD protocol which recall

413
00:19:29,190 --> 00:19:35,500
already used the dragonfly handshake

414
00:19:32,070 --> 00:19:38,379
several years ago this protocol is used

415
00:19:35,500 --> 00:19:41,250
in a small amount of enterprise Wi-Fi

416
00:19:38,380 --> 00:19:44,350
networks then the specification of the

417
00:19:41,250 --> 00:19:46,870
PWD protocol provides no defenses

418
00:19:44,350 --> 00:19:49,110
against this in other words it's

419
00:19:46,870 --> 00:19:51,459
vulnerable to almost exactly the same

420
00:19:49,110 --> 00:19:58,510
timing side-channel that we just

421
00:19:51,460 --> 00:20:02,500
discussed for WPA 3 the situation is

422
00:19:58,510 --> 00:20:05,379
better when they were standardizing W PA

423
00:20:02,500 --> 00:20:07,840
3 they realize that ok there is indeed a

424
00:20:05,380 --> 00:20:10,540
timing leak here and we have to defend

425
00:20:07,840 --> 00:20:13,409
against this on they decided on the

426
00:20:10,540 --> 00:20:17,740
following solution they decided to

427
00:20:13,410 --> 00:20:21,960
always execute 40 iterations no matter

428
00:20:17,740 --> 00:20:21,960
when the password element P was found

429
00:20:22,740 --> 00:20:29,080
this prevents most timing attacks

430
00:20:25,150 --> 00:20:31,180
because if the password here is found in

431
00:20:29,080 --> 00:20:34,179
iteration 10 well then still 40

432
00:20:31,180 --> 00:20:36,550
iterations are Turkey extra iterations

433
00:20:34,180 --> 00:20:41,320
are executed so we have so we always

434
00:20:36,550 --> 00:20:44,770
execute 40 iterations in total this

435
00:20:41,320 --> 00:20:48,189
means that if we use at least if we at

436
00:20:44,770 --> 00:20:53,190
least use NIST curse then there is no

437
00:20:48,190 --> 00:20:55,180
timing leak for WPA 3 in this case

438
00:20:53,190 --> 00:20:58,960
unfortunately though there's also some

439
00:20:55,180 --> 00:21:01,540
bad news the bad news is that WPA 3 was

440
00:20:58,960 --> 00:21:05,020
also designed to support brain pool

441
00:21:01,540 --> 00:21:07,840
elliptic curves on the problem with

442
00:21:05,020 --> 00:21:10,840
brain pool curves is that when using

443
00:21:07,840 --> 00:21:13,929
these curves there's again a high chance

444
00:21:10,840 --> 00:21:16,090
that the output of the hash is larger

445
00:21:13,930 --> 00:21:18,400
than the prime being used by the script

446
00:21:16,090 --> 00:21:20,970
a group on this would again mean that

447
00:21:18,400 --> 00:21:23,110
the remaining cryptographic calculations

448
00:21:20,970 --> 00:21:26,770
they would not be valid it's a

449
00:21:23,110 --> 00:21:31,209
simplified explanation but we can use

450
00:21:26,770 --> 00:21:33,910
this here this means that we must again

451
00:21:31,210 --> 00:21:35,890
see if the X output here is

452
00:21:33,910 --> 00:21:38,740
bigger than the prime and we again need

453
00:21:35,890 --> 00:21:40,770
to solve this somehow so maybe you can

454
00:21:38,740 --> 00:21:44,560
already see where this is going

455
00:21:40,770 --> 00:21:48,129
designers decided to add an if condition

456
00:21:44,560 --> 00:21:49,899
here where if X is bigger than the prime

457
00:21:48,130 --> 00:21:53,680
then we simply immediately go to the

458
00:21:49,900 --> 00:21:57,340
next iteration so can you see the

459
00:21:53,680 --> 00:22:00,250
problem with this algorithm here the

460
00:21:57,340 --> 00:22:04,720
problem is that this code here is now

461
00:22:00,250 --> 00:22:06,520
not always executed and more important

462
00:22:04,720 --> 00:22:08,890
than that the number of times that this

463
00:22:06,520 --> 00:22:13,360
code is not executed depends on the

464
00:22:08,890 --> 00:22:16,630
password being used now this is a bit of

465
00:22:13,360 --> 00:22:19,060
a simplified explanation but the main

466
00:22:16,630 --> 00:22:20,710
idea here is still valid on the main

467
00:22:19,060 --> 00:22:23,950
idea of the attack here against this

468
00:22:20,710 --> 00:22:26,460
algorithm is that by again measuring the

469
00:22:23,950 --> 00:22:30,370
execution time for several MAC addresses

470
00:22:26,460 --> 00:22:32,350
forms a signature of the password how we

471
00:22:30,370 --> 00:22:38,679
can then use the signature to perform

472
00:22:32,350 --> 00:22:42,370
dictionary attacks offline so that

473
00:22:38,680 --> 00:22:44,110
covers all our timing attacks another

474
00:22:42,370 --> 00:22:47,370
type of attack that we can perform

475
00:22:44,110 --> 00:22:49,870
against this algorithm our cache attacks

476
00:22:47,370 --> 00:22:52,389
what do I mean specifically what cache

477
00:22:49,870 --> 00:22:55,239
attacks what I mean is that an attacker

478
00:22:52,390 --> 00:22:58,050
can try to observe which statements in

479
00:22:55,240 --> 00:23:02,530
this algorithm here are being executed

480
00:22:58,050 --> 00:23:04,629
in particular what an attacker can do is

481
00:23:02,530 --> 00:23:07,270
that he or she can use the flush and

482
00:23:04,630 --> 00:23:11,640
reload technique to detect when this

483
00:23:07,270 --> 00:23:14,950
highlighted line here is being executed

484
00:23:11,640 --> 00:23:16,900
this again reveals information about the

485
00:23:14,950 --> 00:23:21,730
password that essentially forms a

486
00:23:16,900 --> 00:23:23,470
signature of the password there is one

487
00:23:21,730 --> 00:23:29,230
important remark here when performing

488
00:23:23,470 --> 00:23:31,750
this attack this is that this this code

489
00:23:29,230 --> 00:23:34,840
is executed 40 times because there are

490
00:23:31,750 --> 00:23:37,960
40 iterations so we also need to know in

491
00:23:34,840 --> 00:23:42,040
which iteration this condition was true

492
00:23:37,960 --> 00:23:43,930
and to handle that we use flush and

493
00:23:42,040 --> 00:23:46,420
reload also in the calculation of this

494
00:23:43,930 --> 00:23:47,450
hash function and we use this to know in

495
00:23:46,420 --> 00:23:49,460
which iteration

496
00:23:47,450 --> 00:23:54,730
are and we can then know in which

497
00:23:49,460 --> 00:23:58,280
iteration the square root indeed existed

498
00:23:54,730 --> 00:24:00,980
apart from this we can also monitor when

499
00:23:58,280 --> 00:24:03,920
the x value was larger than the prime we

500
00:24:00,980 --> 00:24:06,590
can again use flush and reloads we again

501
00:24:03,920 --> 00:24:10,370
also use flush and reloads to detect in

502
00:24:06,590 --> 00:24:12,980
which iteration we are so the takeaway

503
00:24:10,370 --> 00:24:14,780
message here is that cash attacks using

504
00:24:12,980 --> 00:24:16,880
the flush and reload technique they are

505
00:24:14,780 --> 00:24:22,639
also possible against dragonfly

506
00:24:16,880 --> 00:24:24,740
handshake of WPA 3 there are some

507
00:24:22,640 --> 00:24:27,470
important remarks regarding this attack

508
00:24:24,740 --> 00:24:29,540
though and this is that this cash attack

509
00:24:27,470 --> 00:24:32,060
requires a more powerful adversary

510
00:24:29,540 --> 00:24:34,970
because the adversary needs to be able

511
00:24:32,060 --> 00:24:37,970
to run unprivileged codes on the machine

512
00:24:34,970 --> 00:24:39,800
of the victim this can in practice for

513
00:24:37,970 --> 00:24:42,770
example be a malicious Android

514
00:24:39,800 --> 00:24:45,980
applications with very few permissions

515
00:24:42,770 --> 00:24:48,680
or researchers also showed in the past

516
00:24:45,980 --> 00:24:50,390
that against old browsers it's also

517
00:24:48,680 --> 00:24:52,760
possible to perform these cache attacks

518
00:24:50,390 --> 00:24:55,070
from JavaScript although with updated

519
00:24:52,760 --> 00:24:59,780
browsers they have mitigations against

520
00:24:55,070 --> 00:25:02,030
that the second condition is that like

521
00:24:59,780 --> 00:25:03,470
most wife attacks the adversary also

522
00:25:02,030 --> 00:25:07,430
needs to be rooted in range of the

523
00:25:03,470 --> 00:25:09,170
victim so these conditions are quite

524
00:25:07,430 --> 00:25:12,770
high so this is not the most practical

525
00:25:09,170 --> 00:25:15,110
attack however considering that WPA 3 is

526
00:25:12,770 --> 00:25:17,660
a new protocol it is quite surprising

527
00:25:15,110 --> 00:25:22,340
that implementations are vulnerable to

528
00:25:17,660 --> 00:25:24,140
this kind of attack as I mentioned the

529
00:25:22,340 --> 00:25:26,149
information that is leaked using these

530
00:25:24,140 --> 00:25:28,280
cache attacks and again forms the

531
00:25:26,150 --> 00:25:31,100
signature of the password which we can

532
00:25:28,280 --> 00:25:37,670
then use an offline brute force on

533
00:25:31,100 --> 00:25:41,209
dictionary attacks and by this point you

534
00:25:37,670 --> 00:25:44,900
may now realize that both for the timing

535
00:25:41,210 --> 00:25:47,300
attack on the cache attack our decide

536
00:25:44,900 --> 00:25:50,000
Channel leaks that occur they basically

537
00:25:47,300 --> 00:25:52,550
can be used to obtain a signature of the

538
00:25:50,000 --> 00:25:55,340
password so for both our timing attack

539
00:25:52,550 --> 00:25:58,040
on cache attack what we as an adversary

540
00:25:55,340 --> 00:26:00,260
game is a signature of the passwords and

541
00:25:58,040 --> 00:26:01,370
we can then use the signature in a

542
00:26:00,260 --> 00:26:04,230
dictionary of

543
00:26:01,370 --> 00:26:06,959
this means that there will be quite some

544
00:26:04,230 --> 00:26:09,000
benefit to optimizing this offline

545
00:26:06,960 --> 00:26:10,860
dictionary attack and make it as fast as

546
00:26:09,000 --> 00:26:15,690
possible because we can use it in both

547
00:26:10,860 --> 00:26:20,250
situations and we implemented these

548
00:26:15,690 --> 00:26:23,760
optimizations on a GPU when running our

549
00:26:20,250 --> 00:26:26,040
algorithm on Amazon ec2 instances we

550
00:26:23,760 --> 00:26:28,590
found that we can brute-force 10 to the

551
00:26:26,040 --> 00:26:34,290
power 10 passwords for only one dollar

552
00:26:28,590 --> 00:26:36,899
in ec and Amazon spot instances now to

553
00:26:34,290 --> 00:26:41,220
give you a bit of an intuition about how

554
00:26:36,900 --> 00:26:44,100
large this dictionary is basically this

555
00:26:41,220 --> 00:26:46,140
is larger than all known password leaks

556
00:26:44,100 --> 00:26:48,389
so this number is larger than the

557
00:26:46,140 --> 00:26:50,850
RockYou database dump it's larger than

558
00:26:48,390 --> 00:26:53,550
all the passwords and have I been poned

559
00:26:50,850 --> 00:26:56,550
it's larger than all dictionaries of

560
00:26:53,550 --> 00:26:59,370
English words so if you have a

561
00:26:56,550 --> 00:27:02,100
dictionary it will basically cost you $1

562
00:26:59,370 --> 00:27:03,330
to then brute force the password at

563
00:27:02,100 --> 00:27:05,310
least if the implementation is

564
00:27:03,330 --> 00:27:12,389
vulnerable to the timing leaks or the

565
00:27:05,310 --> 00:27:14,700
cache attacks this is quite cheap I'm

566
00:27:12,390 --> 00:27:16,530
inspired by this we also made the

567
00:27:14,700 --> 00:27:18,630
calculation what if we don't just want

568
00:27:16,530 --> 00:27:21,060
to perform a dictionary attack but what

569
00:27:18,630 --> 00:27:23,160
if we want to perform a real real root

570
00:27:21,060 --> 00:27:27,120
force attack and we want to brute force

571
00:27:23,160 --> 00:27:30,680
all passwords of 8 characters and here I

572
00:27:27,120 --> 00:27:34,320
really mean all characters meaning all

573
00:27:30,680 --> 00:27:37,800
256 possibilities for each for each

574
00:27:34,320 --> 00:27:40,260
character in this case when attacking

575
00:27:37,800 --> 00:27:44,250
mod p or brain pool curse that would

576
00:27:40,260 --> 00:27:47,370
cost you about $70 on Amazon spot

577
00:27:44,250 --> 00:27:49,710
instances when you would apply this

578
00:27:47,370 --> 00:27:52,350
against NIST elliptic curves the

579
00:27:49,710 --> 00:27:56,310
computations are more costly on it would

580
00:27:52,350 --> 00:27:58,230
cost fourteen thousand dollars this is a

581
00:27:56,310 --> 00:28:01,889
lot more especially if you would compare

582
00:27:58,230 --> 00:28:03,810
it to the dictionary attacks of wpa2 on

583
00:28:01,890 --> 00:28:07,320
the other hand there is still the same

584
00:28:03,810 --> 00:28:10,860
remark that WPA true at wk 3 is a modern

585
00:28:07,320 --> 00:28:13,700
cryptographic protocol this should not

586
00:28:10,860 --> 00:28:13,699
be possible at all

587
00:28:14,490 --> 00:28:22,140
so that covers the design flaws that we

588
00:28:19,320 --> 00:28:26,070
discovered in dragonfly on top of that

589
00:28:22,140 --> 00:28:28,380
we also looked at recent implementations

590
00:28:26,070 --> 00:28:32,240
of WPA three arms EEP

591
00:28:28,380 --> 00:28:33,710
PWD as well on here we also found some

592
00:28:32,240 --> 00:28:36,270
implementation bugs

593
00:28:33,710 --> 00:28:38,490
so the bug that I described previously

594
00:28:36,270 --> 00:28:40,560
there are really design issues that the

595
00:28:38,490 --> 00:28:42,570
my opinion should be fixed by updating

596
00:28:40,560 --> 00:28:45,629
the standard but we also find some

597
00:28:42,570 --> 00:28:47,850
programming mistakes on the most

598
00:28:45,630 --> 00:28:50,880
important one that we found this was

599
00:28:47,850 --> 00:28:54,709
especially present in PWD implementation

600
00:28:50,880 --> 00:28:58,050
is the so called invalid curve attack

601
00:28:54,710 --> 00:29:01,740
and to give a high-level explanation of

602
00:28:58,050 --> 00:29:05,580
this attack recall that the dragonfly

603
00:29:01,740 --> 00:29:09,360
handshake in the case of WPA 3 or also

604
00:29:05,580 --> 00:29:12,330
in PWD the first phase of this handshake

605
00:29:09,360 --> 00:29:15,719
is the commit phase when using elliptic

606
00:29:12,330 --> 00:29:18,949
curves this commit frame contains a

607
00:29:15,720 --> 00:29:22,890
points on the elliptic curve being used

608
00:29:18,950 --> 00:29:26,040
normally these x and y-coordinates they

609
00:29:22,890 --> 00:29:29,460
must adhere to this specific formula of

610
00:29:26,040 --> 00:29:31,830
the elliptic curve being used but as an

611
00:29:29,460 --> 00:29:34,140
attacker we can try to send two x and

612
00:29:31,830 --> 00:29:37,470
y-coordinates that are not on this

613
00:29:34,140 --> 00:29:40,560
elliptic curve and if the implementation

614
00:29:37,470 --> 00:29:42,600
in this case the access points forgets

615
00:29:40,560 --> 00:29:45,649
to check whether the received x and

616
00:29:42,600 --> 00:29:49,290
y-coordinate are indeed on the curve

617
00:29:45,650 --> 00:29:53,910
this means that the negotiated key will

618
00:29:49,290 --> 00:29:56,250
be predictable so to recap that if we

619
00:29:53,910 --> 00:29:58,350
send an invalid x and y-coordinates the

620
00:29:56,250 --> 00:30:00,720
key that is being calculated by the

621
00:29:58,350 --> 00:30:02,550
access point is predictable it can for

622
00:30:00,720 --> 00:30:06,090
example only have three or a hundred

623
00:30:02,550 --> 00:30:07,860
possible values on the access point

624
00:30:06,090 --> 00:30:10,679
doesn't realize realize that it will

625
00:30:07,860 --> 00:30:12,629
simply continue with the handshake on we

626
00:30:10,680 --> 00:30:15,390
as an attacker can then guess the

627
00:30:12,630 --> 00:30:18,030
session key on based on this guess we

628
00:30:15,390 --> 00:30:20,330
can complete the second phase of the

629
00:30:18,030 --> 00:30:22,350
handshake and we can then successfully

630
00:30:20,330 --> 00:30:26,159
authenticate to the network without

631
00:30:22,350 --> 00:30:28,209
knowing the password in other words this

632
00:30:26,160 --> 00:30:32,680
would bypass authentication

633
00:30:28,210 --> 00:30:34,480
to our surprise all eight PWD protocols

634
00:30:32,680 --> 00:30:36,480
that we looked at we're vulnerable to

635
00:30:34,480 --> 00:30:39,160
this attack

636
00:30:36,480 --> 00:30:42,190
fortunately for WPA three the situation

637
00:30:39,160 --> 00:30:45,130
in this case is a lot better because the

638
00:30:42,190 --> 00:30:47,920
Wi-Fi Alliance in their certification

639
00:30:45,130 --> 00:30:50,140
probe process they check that

640
00:30:47,920 --> 00:30:53,890
implementations properly handles handle

641
00:30:50,140 --> 00:30:56,680
this case but even with this we still

642
00:30:53,890 --> 00:30:59,440
found that the linux IW d client which

643
00:30:56,680 --> 00:31:04,440
is a recently developed Wi-Fi client is

644
00:30:59,440 --> 00:31:04,440
vulnerable to a variation of this attack

645
00:31:05,160 --> 00:31:10,270
another implementation aspect that we

646
00:31:07,720 --> 00:31:15,490
looked at is whether implementations use

647
00:31:10,270 --> 00:31:17,410
a proper source of randomness the reason

648
00:31:15,490 --> 00:31:20,770
why this is important is because if for

649
00:31:17,410 --> 00:31:23,500
example a client or an access point uses

650
00:31:20,770 --> 00:31:26,379
a predictable source of randomness then

651
00:31:23,500 --> 00:31:29,770
based on the exchanged messages that the

652
00:31:26,380 --> 00:31:33,220
handshakes that dragonfly performs we

653
00:31:29,770 --> 00:31:35,650
can recover the password element P so in

654
00:31:33,220 --> 00:31:37,240
other words if the random numbers are

655
00:31:35,650 --> 00:31:41,410
predictable we can recover the password

656
00:31:37,240 --> 00:31:44,830
and we can then connect as a client here

657
00:31:41,410 --> 00:31:48,610
we found that an old EP PWD

658
00:31:44,830 --> 00:31:51,129
implementation of aruba this was the

659
00:31:48,610 --> 00:31:53,080
case the random numbers were roughly

660
00:31:51,130 --> 00:31:55,240
predictable because they were generated

661
00:31:53,080 --> 00:31:57,790
based on the system time um in this case

662
00:31:55,240 --> 00:32:02,320
the password element P could be

663
00:31:57,790 --> 00:32:04,780
recovered this is actually quite an

664
00:32:02,320 --> 00:32:08,350
interesting attack because if we compare

665
00:32:04,780 --> 00:32:12,850
this to wpa2 then with wpa2 we would not

666
00:32:08,350 --> 00:32:15,969
have this issue if with wpa2 we would

667
00:32:12,850 --> 00:32:18,340
use predictable randomness at worst we

668
00:32:15,970 --> 00:32:20,710
might be able to perform some more

669
00:32:18,340 --> 00:32:24,790
efficient dictionary attack or maybe we

670
00:32:20,710 --> 00:32:27,280
can perform a key reinstallation but in

671
00:32:24,790 --> 00:32:30,370
general it doesn't have a much impact of

672
00:32:27,280 --> 00:32:32,320
or wpa2 while with WPA 3 if you use bad

673
00:32:30,370 --> 00:32:35,110
randomness the result is absolutely

674
00:32:32,320 --> 00:32:38,189
catastrophic because an adversary can

675
00:32:35,110 --> 00:32:38,189
recover the password

676
00:32:39,840 --> 00:32:45,279
for now there are not that many WPA 3

677
00:32:43,330 --> 00:32:47,830
implementations yet but here my

678
00:32:45,279 --> 00:32:49,990
prediction is that maybe on a ot devices

679
00:32:47,830 --> 00:32:52,330
which don't have a proper source of

680
00:32:49,990 --> 00:32:57,039
randomness this might be an issue in the

681
00:32:52,330 --> 00:32:59,379
future who knows the last

682
00:32:57,039 --> 00:33:02,529
implementation-specific book that we

683
00:32:59,379 --> 00:33:04,418
looked at is side channels that are in

684
00:33:02,529 --> 00:33:07,840
the design issues but that we still

685
00:33:04,419 --> 00:33:10,120
encountered in some implementations the

686
00:33:07,840 --> 00:33:15,009
one that we found here is again Singh is

687
00:33:10,120 --> 00:33:18,850
again against the PWD protocol on what

688
00:33:15,009 --> 00:33:22,929
we found there is that in the case of

689
00:33:18,850 --> 00:33:26,199
free radius they implemented the extra

690
00:33:22,929 --> 00:33:31,450
defense of executing extra iterations to

691
00:33:26,200 --> 00:33:32,379
try to prevent timing leaks however even

692
00:33:31,450 --> 00:33:34,179
though they implemented this

693
00:33:32,379 --> 00:33:37,449
countermeasure they still made a mistake

694
00:33:34,179 --> 00:33:39,700
here because what I did is that if more

695
00:33:37,450 --> 00:33:44,649
than 10 iterations are needed they

696
00:33:39,700 --> 00:33:46,899
simply abort the handshake in about 1

697
00:33:44,649 --> 00:33:49,090
out of every 2000 handshakes that are

698
00:33:46,899 --> 00:33:51,729
being performed we indeed need more than

699
00:33:49,090 --> 00:33:54,580
10 iterations meaning the handshake will

700
00:33:51,730 --> 00:33:56,740
be aborted as a client we can detect

701
00:33:54,580 --> 00:33:59,678
this as an attacker we can detect when

702
00:33:56,740 --> 00:34:01,840
the handshake is aborted the information

703
00:33:59,679 --> 00:34:06,190
that is leaked in that case again allows

704
00:34:01,840 --> 00:34:08,799
us to recover the password now one other

705
00:34:06,190 --> 00:34:13,510
observation you may now be making is

706
00:34:08,800 --> 00:34:15,520
that in the PWD implementations we

707
00:34:13,510 --> 00:34:17,260
noticed quite some vulnerabilities it

708
00:34:15,520 --> 00:34:17,739
was vulnerable to our invalid kerf

709
00:34:17,260 --> 00:34:21,940
attack

710
00:34:17,739 --> 00:34:23,739
we found sources of math randomness we

711
00:34:21,940 --> 00:34:27,909
now have this implementation specific

712
00:34:23,739 --> 00:34:31,560
side channel with WPA 3 the situation is

713
00:34:27,909 --> 00:34:35,710
a bit better on my guess is because

714
00:34:31,560 --> 00:34:41,619
vendors investing invest a bit more time

715
00:34:35,710 --> 00:34:43,780
in implementing wk3 at least so far so

716
00:34:41,619 --> 00:34:46,270
that covers the implementation specific

717
00:34:43,780 --> 00:34:49,210
attacks the last type of attacks that I

718
00:34:46,270 --> 00:34:54,149
want to discuss are more specific to

719
00:34:49,210 --> 00:34:54,149
Wi-Fi networks on WPA 3

720
00:34:54,418 --> 00:35:01,779
so if we go back to our initial overview

721
00:34:58,240 --> 00:35:04,660
of how the handshake worked recall that

722
00:35:01,780 --> 00:35:07,210
if we perform the handshake the password

723
00:35:04,660 --> 00:35:09,819
has to be converted into a group

724
00:35:07,210 --> 00:35:13,480
elements this has to be done every

725
00:35:09,819 --> 00:35:15,579
single time the handshake is executed we

726
00:35:13,480 --> 00:35:18,760
cannot store this group element offline

727
00:35:15,579 --> 00:35:20,559
on this is because it depends on the MAC

728
00:35:18,760 --> 00:35:22,150
addresses of the devices on in

729
00:35:20,559 --> 00:35:24,520
particular it depends on the MAC address

730
00:35:22,150 --> 00:35:27,609
of the clients so an access points

731
00:35:24,520 --> 00:35:30,190
cannot simply store the group element P

732
00:35:27,609 --> 00:35:32,740
because we as an attacker ganda can then

733
00:35:30,190 --> 00:35:35,260
simply spoof another client MAC address

734
00:35:32,740 --> 00:35:40,118
on the access point then must perform

735
00:35:35,260 --> 00:35:43,780
this calculation again now unfortunately

736
00:35:40,119 --> 00:35:45,700
as you saw here when the access point

737
00:35:43,780 --> 00:35:49,059
converts this passwords into a group

738
00:35:45,700 --> 00:35:52,000
elements it implements this defense

739
00:35:49,059 --> 00:35:55,839
against timing leaks meaning it executes

740
00:35:52,000 --> 00:35:59,109
40 iterations every time a handshake is

741
00:35:55,839 --> 00:36:03,220
being initiated that is quite a large

742
00:35:59,109 --> 00:36:04,930
overheads and practice especially when

743
00:36:03,220 --> 00:36:07,299
you use one of the more secure and

744
00:36:04,930 --> 00:36:11,049
bigger elliptic curve groups this

745
00:36:07,299 --> 00:36:13,450
overhead is quite high for example we

746
00:36:11,049 --> 00:36:16,359
found that against a professional access

747
00:36:13,450 --> 00:36:18,520
point that support that supports one of

748
00:36:16,359 --> 00:36:21,819
these bigger elliptic curves if I would

749
00:36:18,520 --> 00:36:24,309
initiate say ten handshakes per second

750
00:36:21,819 --> 00:36:28,750
this would overload the CPU of the

751
00:36:24,309 --> 00:36:31,030
access point and if I would use a

752
00:36:28,750 --> 00:36:33,579
smaller elliptic curve but still one

753
00:36:31,030 --> 00:36:36,609
that is secure this would be around 70

754
00:36:33,579 --> 00:36:39,280
connections attempt per second if I do

755
00:36:36,609 --> 00:36:41,770
that then the CPU of the access point

756
00:36:39,280 --> 00:36:45,040
would be overloaded which in practice

757
00:36:41,770 --> 00:36:48,309
would mean that other WPA 3 handshakes

758
00:36:45,040 --> 00:36:53,650
would be delayed or would no longer be

759
00:36:48,309 --> 00:36:55,960
possible in other words as a client or

760
00:36:53,650 --> 00:36:58,180
as an adversary we can initiate these

761
00:36:55,960 --> 00:37:03,000
hands and shakes with access points and

762
00:36:58,180 --> 00:37:03,000
cause at the Nile of service attack

763
00:37:03,119 --> 00:37:12,280
another Wi-Fi specific at

764
00:37:06,490 --> 00:37:15,009
that we found is that WPA three also

765
00:37:12,280 --> 00:37:19,090
supports a mode where a network can

766
00:37:15,010 --> 00:37:23,650
simultaneously support both wpa2 on WPA

767
00:37:19,090 --> 00:37:27,760
three at the same time at the decision

768
00:37:23,650 --> 00:37:30,670
that they made here is that both wpa2 on

769
00:37:27,760 --> 00:37:35,950
the WPA three network they would use the

770
00:37:30,670 --> 00:37:39,310
same password now if we were to try to

771
00:37:35,950 --> 00:37:41,049
attack this setup for example let's say

772
00:37:39,310 --> 00:37:43,840
that I find an access point that

773
00:37:41,050 --> 00:37:45,940
supports about two and three then I

774
00:37:43,840 --> 00:37:49,480
could try to set up a malicious access

775
00:37:45,940 --> 00:37:50,920
point that only supports wpa2 and I can

776
00:37:49,480 --> 00:37:54,640
then try to establish a

777
00:37:50,920 --> 00:37:57,430
man-in-the-middle position however that

778
00:37:54,640 --> 00:38:01,540
won't immediately allow you to attack

779
00:37:57,430 --> 00:38:04,000
the handshake because if as an attacker

780
00:38:01,540 --> 00:38:06,400
you are trying to force a victim into

781
00:38:04,000 --> 00:38:09,940
executing the wpa2 handshake

782
00:38:06,400 --> 00:38:13,800
then the wpa2 handshake will detect that

783
00:38:09,940 --> 00:38:16,090
the real access point supports WPA three

784
00:38:13,800 --> 00:38:17,890
meaning the victim will attack

785
00:38:16,090 --> 00:38:19,930
hey well detect hey there's an attack

786
00:38:17,890 --> 00:38:22,750
going on and I'm going to abort the

787
00:38:19,930 --> 00:38:27,069
handshake and that's good because that

788
00:38:22,750 --> 00:38:29,980
means that WPA three when you configure

789
00:38:27,070 --> 00:38:33,250
it this way where you simultaneously

790
00:38:29,980 --> 00:38:37,750
supports both versions then it provides

791
00:38:33,250 --> 00:38:41,320
forward secrecy unfortunately there is

792
00:38:37,750 --> 00:38:45,430
one small problem here it's actually a

793
00:38:41,320 --> 00:38:47,740
big problem namely this partial wpa2

794
00:38:45,430 --> 00:38:50,470
handshake that is being executed that

795
00:38:47,740 --> 00:38:55,540
already provides enough information to

796
00:38:50,470 --> 00:38:57,368
do a dictionary attack against it so

797
00:38:55,540 --> 00:39:00,960
even though the client may detect that

798
00:38:57,369 --> 00:39:03,369
the real access point supports WPS three

799
00:39:00,960 --> 00:39:05,320
by the time it finds that out it's

800
00:39:03,369 --> 00:39:07,450
already too late because the exchanged

801
00:39:05,320 --> 00:39:11,260
messages so far allow you to perform a

802
00:39:07,450 --> 00:39:15,279
dictionary attack so how can we prevent

803
00:39:11,260 --> 00:39:17,650
this well what we can do is we can let

804
00:39:15,280 --> 00:39:20,320
the clients remember whether an access

805
00:39:17,650 --> 00:39:23,830
point previously supported WPA

806
00:39:20,320 --> 00:39:26,830
three and if so then we will only

807
00:39:23,830 --> 00:39:28,930
connect using WPA three in the future

808
00:39:26,830 --> 00:39:30,940
and this prevents this downgrade tech

809
00:39:28,930 --> 00:39:36,819
and this is similar to the thrust on

810
00:39:30,940 --> 00:39:38,950
first usage of SSH or HTTP pinning the

811
00:39:36,820 --> 00:39:41,590
good news is that the Google pixel three

812
00:39:38,950 --> 00:39:44,770
arms the network manager of Linux are

813
00:39:41,590 --> 00:39:47,080
they implemented this defense meaning if

814
00:39:44,770 --> 00:39:52,360
you use that you are secure against this

815
00:39:47,080 --> 00:39:55,420
attack a second kind of downgrade attack

816
00:39:52,360 --> 00:39:57,580
is also possible on this downgrade

817
00:39:55,420 --> 00:40:01,420
attack is against a dragonfly handshake

818
00:39:57,580 --> 00:40:03,069
itself so recall that the dragonfly

819
00:40:01,420 --> 00:40:06,670
handshake can be performed using

820
00:40:03,070 --> 00:40:09,490
multiple cryptographic groups some of

821
00:40:06,670 --> 00:40:10,870
these groups are relatively weak while

822
00:40:09,490 --> 00:40:15,040
other cryptographic groups are

823
00:40:10,870 --> 00:40:17,950
relatively strong it turns out that we

824
00:40:15,040 --> 00:40:21,910
can influence which cryptographic group

825
00:40:17,950 --> 00:40:23,770
a victim will use in particular the way

826
00:40:21,910 --> 00:40:25,690
that's a client on a nexus point for

827
00:40:23,770 --> 00:40:28,180
example negotiate which cryptographic

828
00:40:25,690 --> 00:40:30,460
group is being used is that the nature

829
00:40:28,180 --> 00:40:33,609
the initiator of the handshake will

830
00:40:30,460 --> 00:40:36,040
suggest a cryptographic group that the

831
00:40:33,610 --> 00:40:38,590
device wants to use and then the report

832
00:40:36,040 --> 00:40:42,220
the responder either accepts that group

833
00:40:38,590 --> 00:40:44,740
or ejects it now it turns out that

834
00:40:42,220 --> 00:40:47,319
spoofing this reject message is trivial

835
00:40:44,740 --> 00:40:51,490
meaning we can simply as an adversary

836
00:40:47,320 --> 00:40:53,080
spoof the reject message and then force

837
00:40:51,490 --> 00:40:55,000
the victim into using a weaker

838
00:40:53,080 --> 00:40:59,440
cryptographic group as it would

839
00:40:55,000 --> 00:41:03,310
otherwise use this is a design flaw in

840
00:40:59,440 --> 00:41:05,890
the handshake of dragonfly arms clients

841
00:41:03,310 --> 00:41:08,130
access points are vulnerable to this

842
00:41:05,890 --> 00:41:08,129
attack

843
00:41:08,580 --> 00:41:14,230
so as the last part of this presentation

844
00:41:11,230 --> 00:41:16,800
I want to briefly go over the disclosure

845
00:41:14,230 --> 00:41:19,030
process that we thought that we followed

846
00:41:16,800 --> 00:41:23,890
the mitigations that are being

847
00:41:19,030 --> 00:41:27,520
implemented so what we did here is we

848
00:41:23,890 --> 00:41:30,879
try to notify parties very early with us

849
00:41:27,520 --> 00:41:33,730
hope that we could influence WPA 3 now

850
00:41:30,880 --> 00:41:36,490
during our initial disclosure there

851
00:41:33,730 --> 00:41:38,770
actually some skepticism regarding our

852
00:41:36,490 --> 00:41:41,979
attacks because they mainly consider

853
00:41:38,770 --> 00:41:43,720
this to be implementation floss they

854
00:41:41,980 --> 00:41:45,580
thought all the timing like the timing

855
00:41:43,720 --> 00:41:48,640
leak we can prevent this by executing

856
00:41:45,580 --> 00:41:52,049
extra iterations on the cache attack we

857
00:41:48,640 --> 00:41:53,379
can also prevent this by very carefully

858
00:41:52,050 --> 00:41:57,400
implementing it

859
00:41:53,380 --> 00:41:59,650
um one interesting remark is that one

860
00:41:57,400 --> 00:42:01,210
developer even said oh yeah we actually

861
00:41:59,650 --> 00:42:03,340
knew about one of these downgrade

862
00:42:01,210 --> 00:42:08,920
attacks we just forgot to warn you about

863
00:42:03,340 --> 00:42:11,890
it now the official reaction of the

864
00:42:08,920 --> 00:42:15,880
Wi-Fi Alliance was that they privately

865
00:42:11,890 --> 00:42:20,230
created guidelines to securely implement

866
00:42:15,880 --> 00:42:22,720
WPA 3 unfortunately in these guidelines

867
00:42:20,230 --> 00:42:25,780
they mentioned that rainbow curse are

868
00:42:22,720 --> 00:42:27,609
safe to use but as we discussed even

869
00:42:25,780 --> 00:42:29,350
when using red pool curse some

870
00:42:27,609 --> 00:42:32,290
vulnerabilities some side channels

871
00:42:29,350 --> 00:42:39,790
remain this actually meant we had to do

872
00:42:32,290 --> 00:42:41,500
a second small disclosure now there is

873
00:42:39,790 --> 00:42:44,020
one fundamental issue that remains

874
00:42:41,500 --> 00:42:46,210
though that even if we implement these

875
00:42:44,020 --> 00:42:48,730
backwards compatible countermeasures

876
00:42:46,210 --> 00:42:53,020
there's one big problem with the design

877
00:42:48,730 --> 00:42:56,170
of dragonfly this is that it has to

878
00:42:53,020 --> 00:42:59,350
perform 40 iterations in order to defend

879
00:42:56,170 --> 00:43:01,270
against our time meetings and that's a

880
00:42:59,350 --> 00:43:04,810
very costly thing to do especially on

881
00:43:01,270 --> 00:43:10,150
lightweight devices executing these 40

882
00:43:04,810 --> 00:43:12,340
iterations is too costly and the problem

883
00:43:10,150 --> 00:43:14,830
is even worse here because you might now

884
00:43:12,340 --> 00:43:16,750
think that yeah but if I have a powerful

885
00:43:14,830 --> 00:43:19,779
smartphone or if I have a powerful

886
00:43:16,750 --> 00:43:21,850
laptop then this doesn't matter the CPU

887
00:43:19,780 --> 00:43:25,480
of my device is powerful enough that

888
00:43:21,850 --> 00:43:28,000
this isn't an issue unfortunately what

889
00:43:25,480 --> 00:43:31,480
we see in practice or what's at least a

890
00:43:28,000 --> 00:43:33,460
common practice with wpa2 is that a lot

891
00:43:31,480 --> 00:43:37,690
of times the Wi-Fi handshake is

892
00:43:33,460 --> 00:43:39,400
offloaded to the Wi-Fi radio itself so

893
00:43:37,690 --> 00:43:41,850
that the main CPU doesn't have to care

894
00:43:39,400 --> 00:43:44,800
about the height about the handshake and

895
00:43:41,850 --> 00:43:47,569
unfortunately these lightweight Wi-Fi

896
00:43:44,800 --> 00:43:49,749
chips they are not powerful enough to

897
00:43:47,569 --> 00:43:53,299
always execute these 40 iterations

898
00:43:49,749 --> 00:43:55,698
meaning as an implementer you have to

899
00:43:53,299 --> 00:43:57,890
decide between eight are doing these 40

900
00:43:55,699 --> 00:44:00,680
iterations and possibly being vulnerable

901
00:43:57,890 --> 00:44:03,529
to the nine of service attacks or

902
00:44:00,680 --> 00:44:05,779
consuming a lot of power or not doing

903
00:44:03,529 --> 00:44:10,130
these iterations of possibly being

904
00:44:05,779 --> 00:44:12,410
vulnerable to timing attacks so that's

905
00:44:10,130 --> 00:44:14,660
not a good situation because no matter

906
00:44:12,410 --> 00:44:17,930
what you do you basically end up in a

907
00:44:14,660 --> 00:44:19,999
bad position the good news here though

908
00:44:17,930 --> 00:44:23,769
is that the standard is now being

909
00:44:19,999 --> 00:44:27,680
updated with ways to prevent these

910
00:44:23,769 --> 00:44:29,479
vulnerabilities in a proper way the

911
00:44:27,680 --> 00:44:31,249
first thing that is being done is that

912
00:44:29,479 --> 00:44:33,589
they are now implementing a defense to

913
00:44:31,249 --> 00:44:36,499
prevent these downgrade attacks against

914
00:44:33,589 --> 00:44:40,489
cryptographic groups another design

915
00:44:36,499 --> 00:44:44,959
issue that they are now making is they

916
00:44:40,489 --> 00:44:47,239
is that they modified the algorithm that

917
00:44:44,959 --> 00:44:49,940
converts the passwords into a group

918
00:44:47,239 --> 00:44:54,079
element so that this algorithm can also

919
00:44:49,940 --> 00:44:55,670
at least partly be executed offline this

920
00:44:54,079 --> 00:44:57,769
means it doesn't have to be executed

921
00:44:55,670 --> 00:45:00,890
every single the time you make you

922
00:44:57,769 --> 00:45:02,718
perform a handshake this helps with

923
00:45:00,890 --> 00:45:05,269
allowing you to implement it efficiently

924
00:45:02,719 --> 00:45:07,539
and also makes it more complicated to

925
00:45:05,269 --> 00:45:10,038
perform attacks

926
00:45:07,539 --> 00:45:12,410
I'm not going to go into too much detail

927
00:45:10,039 --> 00:45:16,660
here but some other defenses that they

928
00:45:12,410 --> 00:45:20,299
are now discussing to implement is to

929
00:45:16,660 --> 00:45:22,368
implement this algorithm that converts

930
00:45:20,299 --> 00:45:24,829
the password in a constant time fashion

931
00:45:22,369 --> 00:45:28,309
for both the mod P groups on the

932
00:45:24,829 --> 00:45:30,009
elliptic curve groups to really prevent

933
00:45:28,309 --> 00:45:34,190
these side channel leaks in the

934
00:45:30,009 --> 00:45:36,019
specification itself these suggestions

935
00:45:34,190 --> 00:45:38,539
are actually very good so from an

936
00:45:36,019 --> 00:45:41,439
implementation follows these WPA three

937
00:45:38,539 --> 00:45:43,630
is actually in my opinion a pretty good

938
00:45:41,440 --> 00:45:45,619
protocol

939
00:45:43,630 --> 00:45:48,170
unfortunately these changes are not

940
00:45:45,619 --> 00:45:51,229
backwards compatible so this might lead

941
00:45:48,170 --> 00:45:54,259
to a new revision of WPA 3 it's still

942
00:45:51,229 --> 00:45:56,359
unclear how this will be handled so

943
00:45:54,259 --> 00:45:58,640
there might be also risk of downgrade

944
00:45:56,359 --> 00:46:01,340
attacks against initial version of WPA 3

945
00:45:58,640 --> 00:46:04,140
it's unclear what will happen here

946
00:46:01,340 --> 00:46:07,590
now the final thing I want to say here

947
00:46:04,140 --> 00:46:12,029
is this all this research mean that it's

948
00:46:07,590 --> 00:46:15,570
now very trivial to attack wp3 well the

949
00:46:12,030 --> 00:46:19,890
answer is no WPA 3 is still better than

950
00:46:15,570 --> 00:46:21,690
WPA 2 because with WPA 2 it's really

951
00:46:19,890 --> 00:46:23,940
trivial to perform a dictionary attack

952
00:46:21,690 --> 00:46:26,640
you just capture the handshake don't you

953
00:46:23,940 --> 00:46:28,080
do your dictionary attacks with WPA 3

954
00:46:26,640 --> 00:46:30,029
and you need to perform these timing

955
00:46:28,080 --> 00:46:32,009
attacks you need to perform these cache

956
00:46:30,030 --> 00:46:34,680
attacks and only then can you do the

957
00:46:32,010 --> 00:46:39,030
dictionary attacks so in that sense WPA

958
00:46:34,680 --> 00:46:41,399
3 is better however as a modern security

959
00:46:39,030 --> 00:46:45,570
protocol the vulnerabilities that we

960
00:46:41,400 --> 00:46:46,470
found are really unacceptable so that

961
00:46:45,570 --> 00:46:48,840
concludes my talk

962
00:46:46,470 --> 00:46:52,589
so the takeaway messages here is that

963
00:46:48,840 --> 00:46:54,270
WPA 3 is vulnerable to side channels the

964
00:46:52,590 --> 00:46:57,000
countermeasures here they are quite

965
00:46:54,270 --> 00:47:00,900
costly because of that the standard is

966
00:46:57,000 --> 00:47:04,200
now being updated the planned updates

967
00:47:00,900 --> 00:47:06,900
they're actually quite strong so the

968
00:47:04,200 --> 00:47:08,939
last conclusion here is that if you have

969
00:47:06,900 --> 00:47:12,180
a device that supports WPA 3

970
00:47:08,940 --> 00:47:14,900
yes WP 3 has its flaws but it's still

971
00:47:12,180 --> 00:47:17,700
better so if possible you should use it

972
00:47:14,900 --> 00:47:21,020
so thank you for your attention and if

973
00:47:17,700 --> 00:47:21,020
there are questions feel free to ask

974
00:47:22,120 --> 00:47:25,719
[Applause]

