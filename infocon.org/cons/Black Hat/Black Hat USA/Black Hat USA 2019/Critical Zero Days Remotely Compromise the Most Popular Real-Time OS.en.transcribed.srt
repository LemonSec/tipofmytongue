1
00:00:00,030 --> 00:00:05,400
our next talk you are you are in South

2
00:00:01,920 --> 00:00:07,770
Seas CDF our next talk is critical zero

3
00:00:05,400 --> 00:00:10,800
days remotely compromised the most

4
00:00:07,770 --> 00:00:22,170
popular real-time OS with Ben Zuri and

5
00:00:10,800 --> 00:00:24,320
dozous ceman hey guys thank you for that

6
00:00:22,170 --> 00:00:27,240
introduction

7
00:00:24,320 --> 00:00:29,670
yeah so my name is Ben sorry I'm the VP

8
00:00:27,240 --> 00:00:31,619
of research at Armus and today with me

9
00:00:29,670 --> 00:00:34,309
the door doors booth man whose research

10
00:00:31,619 --> 00:00:36,930
on my team Hey

11
00:00:34,309 --> 00:00:39,149
also in the crowd we have a Greg with

12
00:00:36,930 --> 00:00:40,890
nopales key which is a also part of a

13
00:00:39,149 --> 00:00:43,829
research team and is a big part of the

14
00:00:40,890 --> 00:00:45,420
research we are presenting today Armas

15
00:00:43,829 --> 00:00:47,280
is an agent to the society security

16
00:00:45,420 --> 00:00:49,800
company which which is focused on

17
00:00:47,280 --> 00:00:52,500
security securing IOT devices and manage

18
00:00:49,800 --> 00:00:54,750
devices in both enterprise industrial

19
00:00:52,500 --> 00:00:57,059
and medical organizations in the last

20
00:00:54,750 --> 00:00:59,100
year we've noticed a particular brand of

21
00:00:57,059 --> 00:01:00,839
real-time operating system but is

22
00:00:59,100 --> 00:01:03,149
extensively used by industrial and

23
00:01:00,840 --> 00:01:04,769
medical devices so we decided to take it

24
00:01:03,149 --> 00:01:06,990
apart and see if we can find any

25
00:01:04,769 --> 00:01:08,549
interesting vulnerabilities in it this

26
00:01:06,990 --> 00:01:10,798
research resulted in the discovery of

27
00:01:08,549 --> 00:01:13,409
eleven critical zero-day vulnerabilities

28
00:01:10,799 --> 00:01:15,360
the tcp/ip stack used by this popular

29
00:01:13,409 --> 00:01:20,850
real-time operating system named the

30
00:01:15,360 --> 00:01:21,570
exports so we're gonna start a bit about

31
00:01:20,850 --> 00:01:24,119
VxWorks

32
00:01:21,570 --> 00:01:27,059
just where is it used why is it still

33
00:01:24,119 --> 00:01:28,939
very relevant today then we're going to

34
00:01:27,060 --> 00:01:32,280
cover a bit the history of

35
00:01:28,939 --> 00:01:35,000
vulnerabilities in the tcp/ip stack

36
00:01:32,280 --> 00:01:39,150
implementation various operating systems

37
00:01:35,000 --> 00:01:41,270
then how we go with it about the actual

38
00:01:39,150 --> 00:01:44,490
findings of our research the urgent 11

39
00:01:41,270 --> 00:01:47,039
research and a technical deep dive on

40
00:01:44,490 --> 00:01:50,369
some of the more interesting of these 11

41
00:01:47,040 --> 00:01:53,399
probabilities lastly if we if we

42
00:01:50,369 --> 00:01:55,380
actually have time we'll show it an

43
00:01:53,399 --> 00:01:57,149
interesting interesting case study of a

44
00:01:55,380 --> 00:01:59,610
hospital bedside patient monitor that we

45
00:01:57,149 --> 00:02:04,799
have here today and we'll attempt to do

46
00:01:59,610 --> 00:02:07,110
a live demo of this as well so going

47
00:02:04,799 --> 00:02:09,239
back to the experts what what is VX

48
00:02:07,110 --> 00:02:11,730
works and why should you care about it

49
00:02:09,239 --> 00:02:14,099
VX works is a real-time operating system

50
00:02:11,730 --> 00:02:15,959
it is owned by a company named River and

51
00:02:14,099 --> 00:02:17,640
is actually used by more than 2,000

52
00:02:15,959 --> 00:02:20,190
device manufacturers as the basis for

53
00:02:17,640 --> 00:02:22,738
their device that they have they

54
00:02:20,190 --> 00:02:25,680
manufacture so wind referent produces

55
00:02:22,739 --> 00:02:27,629
the code the VxWorks software but then

56
00:02:25,680 --> 00:02:29,519
there are over 2,000 companies that

57
00:02:27,629 --> 00:02:32,880
takes the source code with operating

58
00:02:29,519 --> 00:02:35,459
system and unit underlying OS for their

59
00:02:32,880 --> 00:02:39,329
devices real-time operating systems

60
00:02:35,459 --> 00:02:41,160
Excel it being compact and reliable such

61
00:02:39,330 --> 00:02:43,470
that can deliver deterministic timings

62
00:02:41,160 --> 00:02:46,140
for various tests running on top of a

63
00:02:43,470 --> 00:02:48,120
priority based scheduler these features

64
00:02:46,140 --> 00:02:50,339
usually fit well with various and other

65
00:02:48,120 --> 00:02:53,370
devices and weeks works is used

66
00:02:50,340 --> 00:02:54,870
extensively in many different devices it

67
00:02:53,370 --> 00:02:56,459
is the most popular real-time operating

68
00:02:54,870 --> 00:02:58,980
system in the market it actually runs on

69
00:02:56,459 --> 00:03:00,209
over 2 billion devices that's the same

70
00:02:58,980 --> 00:03:02,869
number of devices that you would find

71
00:03:00,209 --> 00:03:05,220
powering Android or Windows devices

72
00:03:02,870 --> 00:03:07,819
unlike these operating systems however

73
00:03:05,220 --> 00:03:10,890
this OS suffers from lack of research

74
00:03:07,819 --> 00:03:13,230
and its 32 years of existence only

75
00:03:10,890 --> 00:03:16,768
certain CBE's were found to affected and

76
00:03:13,230 --> 00:03:19,980
are listed and by mitra now that number

77
00:03:16,769 --> 00:03:22,470
has gone to 24 due to our research but

78
00:03:19,980 --> 00:03:24,869
it is still under research extensively

79
00:03:22,470 --> 00:03:27,000
in comparison when you look at Android

80
00:03:24,870 --> 00:03:30,150
for example this always has more than

81
00:03:27,000 --> 00:03:32,190
2,000 CVS listed that affected and it

82
00:03:30,150 --> 00:03:33,690
exists for any quarter of the time sorry

83
00:03:32,190 --> 00:03:35,670
if there isn't much more research to be

84
00:03:33,690 --> 00:03:39,900
done in real-time operating systems envy

85
00:03:35,670 --> 00:03:42,000
export specifically VxWorks is used

86
00:03:39,900 --> 00:03:44,730
everywhere you actually find it in

87
00:03:42,000 --> 00:03:48,720
almost every industry from healthcare to

88
00:03:44,730 --> 00:03:52,470
many factoring aerospace even automotive

89
00:03:48,720 --> 00:03:55,049
defense security all of these all of

90
00:03:52,470 --> 00:03:56,489
these industries use devices that

91
00:03:55,049 --> 00:03:58,829
require these types of real-time

92
00:03:56,489 --> 00:04:03,870
operating systems require these types of

93
00:03:58,829 --> 00:04:08,190
really reliable compact and highly gain

94
00:04:03,870 --> 00:04:10,560
high reliable systems produced by the

95
00:04:08,190 --> 00:04:13,260
most the biggest companies in each of

96
00:04:10,560 --> 00:04:15,269
their respective fields in industrial

97
00:04:13,260 --> 00:04:17,909
devices will find it in walk through

98
00:04:15,269 --> 00:04:19,798
automation in Schneider Electric the

99
00:04:17,910 --> 00:04:24,120
medical devices you find in Philips and

100
00:04:19,798 --> 00:04:25,650
GE and its immense all over the

101
00:04:24,120 --> 00:04:27,840
industries you find

102
00:04:25,650 --> 00:04:32,940
we'll be comin disease even vxworks as

103
00:04:27,840 --> 00:04:35,429
their go-to solution and even if I miss

104
00:04:32,940 --> 00:04:38,610
example if this is NASA which also uses

105
00:04:35,430 --> 00:04:42,139
V exports to drive their spacecraft and

106
00:04:38,610 --> 00:04:42,139
some of the marks for versions as well

107
00:04:42,380 --> 00:04:48,380
ok so going back to tcp/ip stacks why

108
00:04:45,690 --> 00:04:52,350
are they an interesting subject for

109
00:04:48,380 --> 00:04:53,969
research quality research so in many

110
00:04:52,350 --> 00:04:55,560
regards they are considered the holy

111
00:04:53,970 --> 00:04:57,990
grail of our ability research the final

112
00:04:55,560 --> 00:05:00,120
ability in the core networking stack of

113
00:04:57,990 --> 00:05:03,479
an operating system is really something

114
00:05:00,120 --> 00:05:07,410
that can allow an attacker great a great

115
00:05:03,479 --> 00:05:09,419
a lot of power this is because a couple

116
00:05:07,410 --> 00:05:11,340
of things first of all these product

117
00:05:09,419 --> 00:05:14,030
code tcp/ip protocols they go back to

118
00:05:11,340 --> 00:05:17,549
the 80s they are they haven't changed

119
00:05:14,030 --> 00:05:21,510
since so if you find a probability and

120
00:05:17,550 --> 00:05:25,590
then permutation of such protocol it

121
00:05:21,510 --> 00:05:29,010
won't change the code will be changed

122
00:05:25,590 --> 00:05:31,859
almost but also you can bet that they've

123
00:05:29,010 --> 00:05:34,320
already you find really reprimand in the

124
00:05:31,860 --> 00:05:36,570
code as well in addition the network

125
00:05:34,320 --> 00:05:39,840
stack of any operating system will be

126
00:05:36,570 --> 00:05:41,400
running inside the kernel in ring 0 so

127
00:05:39,840 --> 00:05:45,000
the highest privileges that you can

128
00:05:41,400 --> 00:05:46,979
imagine and by nature if you find about

129
00:05:45,000 --> 00:05:49,320
ability in a tcp/ip stack it will be

130
00:05:46,979 --> 00:05:51,180
remotely exploitable right so it's the

131
00:05:49,320 --> 00:05:52,740
network stack of the device if you find

132
00:05:51,180 --> 00:05:54,930
availability in the implementation of

133
00:05:52,740 --> 00:05:57,710
the network stack you can send packets

134
00:05:54,930 --> 00:06:02,910
that will trigger some of the volatility

135
00:05:57,710 --> 00:06:05,310
in the past this there were some

136
00:06:02,910 --> 00:06:07,260
examples of abilities in tcp/ip stacks

137
00:06:05,310 --> 00:06:09,810
back in the 90s we had a couple of these

138
00:06:07,260 --> 00:06:11,430
was affected Windows devices you might

139
00:06:09,810 --> 00:06:14,340
remember the famous wing nuke

140
00:06:11,430 --> 00:06:16,620
vulnerability you had this nice pop up

141
00:06:14,340 --> 00:06:22,380
you click a button and it crashed any

142
00:06:16,620 --> 00:06:24,060
windows 95 an NT device and surprisingly

143
00:06:22,380 --> 00:06:27,389
even today there are examples of this

144
00:06:24,060 --> 00:06:30,780
last year there was this mobility in the

145
00:06:27,389 --> 00:06:32,849
Mac OS and iOS from Apple again do not

146
00:06:30,780 --> 00:06:35,489
have service attack that crashed these

147
00:06:32,849 --> 00:06:37,180
devices by something single ICMP packet

148
00:06:35,490 --> 00:06:39,460
especially crafted one

149
00:06:37,180 --> 00:06:41,980
in most cases though mobility is

150
00:06:39,460 --> 00:06:43,930
discovered in the characteristic weren't

151
00:06:41,980 --> 00:06:45,490
arise to actually being molecule

152
00:06:43,930 --> 00:06:48,400
executions it's there it's where case

153
00:06:45,490 --> 00:06:50,500
and they're more often be an RF service

154
00:06:48,400 --> 00:06:53,380
resource exhaustion and all kind of

155
00:06:50,500 --> 00:06:55,390
these probabilities that are critical

156
00:06:53,380 --> 00:06:59,590
and important but not remote code

157
00:06:55,390 --> 00:07:01,690
execution necessarily what we found is

158
00:06:59,590 --> 00:07:04,239
actually six low abilities but our

159
00:07:01,690 --> 00:07:05,980
remote code execution an additional five

160
00:07:04,240 --> 00:07:07,960
that our information leaks in RF service

161
00:07:05,980 --> 00:07:10,390
and logical flaws together with these

162
00:07:07,960 --> 00:07:13,659
eleven critical vulnerabilities impact

163
00:07:10,390 --> 00:07:16,479
the tcp/ip stack used by VxWorks called

164
00:07:13,660 --> 00:07:18,910
IP net and this stack is the default

165
00:07:16,480 --> 00:07:21,840
built in this 50 stack for VxWorks in

166
00:07:18,910 --> 00:07:25,720
the last thirty years since version 6.5

167
00:07:21,840 --> 00:07:28,090
as I mentioned before V exports power is

168
00:07:25,720 --> 00:07:30,430
around two billion devices and our

169
00:07:28,090 --> 00:07:33,609
estimate is that these mobilities affect

170
00:07:30,430 --> 00:07:36,700
hundreds of millions of that two billion

171
00:07:33,610 --> 00:07:38,020
a total number some of the week's work

172
00:07:36,700 --> 00:07:40,539
slave devices don't have networking

173
00:07:38,020 --> 00:07:42,010
necessarily but the ones that do the

174
00:07:40,540 --> 00:07:47,860
majority of them would be impacted by

175
00:07:42,010 --> 00:07:49,750
this the IP next AK like I said is a

176
00:07:47,860 --> 00:07:51,940
different building stack from VX works

177
00:07:49,750 --> 00:07:55,360
it is now owned and maintained by

178
00:07:51,940 --> 00:07:57,790
Wingrove room as part of their if this

179
00:07:55,360 --> 00:08:00,480
part of VX ports century but in the past

180
00:07:57,790 --> 00:08:03,580
it was actually part of another company

181
00:08:00,480 --> 00:08:05,800
inter peak and it was then sold to other

182
00:08:03,580 --> 00:08:08,440
real-time operating systems this is part

183
00:08:05,800 --> 00:08:11,590
three of 2006 so in the past you'd find

184
00:08:08,440 --> 00:08:12,210
IP netting Greenhills integrity 3dx and

185
00:08:11,590 --> 00:08:14,590
OSC

186
00:08:12,210 --> 00:08:16,150
the disclosure process we've done with

187
00:08:14,590 --> 00:08:17,890
these of all videos it started in March

188
00:08:16,150 --> 00:08:22,120
so it's been five months and score

189
00:08:17,890 --> 00:08:23,500
passes a very complicated one I think in

190
00:08:22,120 --> 00:08:29,020
the sense that again there are many many

191
00:08:23,500 --> 00:08:31,210
impact evangelism and like we we saw in

192
00:08:29,020 --> 00:08:32,679
the week past so we talk business last

193
00:08:31,210 --> 00:08:36,270
week and since then actually there have

194
00:08:32,679 --> 00:08:38,770
been many many advisories like this

195
00:08:36,270 --> 00:08:39,970
companies that come for it and say we're

196
00:08:38,770 --> 00:08:42,130
impacted by this we're working on a

197
00:08:39,970 --> 00:08:44,080
patch and we're trying to meet and we

198
00:08:42,130 --> 00:08:46,570
are offering some mitigation casts so we

199
00:08:44,080 --> 00:08:48,610
saw this in the Philips medical devices

200
00:08:46,570 --> 00:08:51,970
industrial devices from rockledge tiger

201
00:08:48,610 --> 00:08:53,670
and some enterprise type devices like

202
00:08:51,970 --> 00:08:55,990
they work speakers

203
00:08:53,670 --> 00:08:59,500
another interesting example is the sonic

204
00:08:55,990 --> 00:09:02,440
world firewall a firewall that is based

205
00:08:59,500 --> 00:09:05,769
on VX works and that device had actually

206
00:09:02,440 --> 00:09:07,720
or still has around a million of these

207
00:09:05,769 --> 00:09:10,269
his car was exposed to the Internet

208
00:09:07,720 --> 00:09:12,490
you can find them on Shauna SonicWALL

209
00:09:10,269 --> 00:09:14,980
also released the patch and encouraged

210
00:09:12,490 --> 00:09:16,449
and I also do this if you are SonicWALL

211
00:09:14,980 --> 00:09:18,670
firewall user please go ahead and

212
00:09:16,449 --> 00:09:23,920
install that patch because the exporter

213
00:09:18,670 --> 00:09:25,599
is very reading ok so like I said we

214
00:09:23,920 --> 00:09:27,969
found 11 probabilities and they are

215
00:09:25,600 --> 00:09:30,910
actually throughout various subsystems

216
00:09:27,970 --> 00:09:32,440
of the tcp/ip stack there is one from

217
00:09:30,910 --> 00:09:34,540
between the IP stack there are various

218
00:09:32,440 --> 00:09:37,149
variabilities in the sorry neurology in

219
00:09:34,540 --> 00:09:42,040
the IP subsystem various the tcp

220
00:09:37,149 --> 00:09:44,889
subsystem a couple of the dhcp IGMP even

221
00:09:42,040 --> 00:09:47,230
even one very interesting and a fine

222
00:09:44,889 --> 00:09:49,660
availability in the protocol you might

223
00:09:47,230 --> 00:09:53,620
have not heard of her called reverse ARP

224
00:09:49,660 --> 00:09:55,089
and we do touch on that as well so we

225
00:09:53,620 --> 00:09:56,769
want time time to actually cover all of

226
00:09:55,089 --> 00:09:59,290
it we did polish white paper when you

227
00:09:56,769 --> 00:10:01,300
you're good to go and with it but we are

228
00:09:59,290 --> 00:10:02,889
going to touch a couple of these the

229
00:10:01,300 --> 00:10:06,969
most interesting of them and door we'll

230
00:10:02,889 --> 00:10:08,920
start with ike one couple that okay

231
00:10:06,970 --> 00:10:11,199
so the first variety that we're going to

232
00:10:08,920 --> 00:10:14,620
talk about resides inside of the IP

233
00:10:11,199 --> 00:10:15,219
parsing system inside of the IP stack of

234
00:10:14,620 --> 00:10:17,319
VxWorks

235
00:10:15,220 --> 00:10:18,310
and in order to understand it we're

236
00:10:17,319 --> 00:10:20,800
going to need to have a little bit of

237
00:10:18,310 --> 00:10:22,810
background about IP and IP options and i

238
00:10:20,800 --> 00:10:24,819
simpiy else this vulnerability is

239
00:10:22,810 --> 00:10:27,638
especially cool because we can do both

240
00:10:24,819 --> 00:10:31,149
things that are cool the first thing is

241
00:10:27,639 --> 00:10:32,769
that this probability resides in the IP

242
00:10:31,149 --> 00:10:34,660
layer meaning that we can send a

243
00:10:32,769 --> 00:10:36,310
broadcast packet and attack a whole

244
00:10:34,660 --> 00:10:39,969
bunch of these devices with just one

245
00:10:36,310 --> 00:10:42,518
packet and let's dive deep and see how

246
00:10:39,970 --> 00:10:44,829
it works so we all know this this is the

247
00:10:42,519 --> 00:10:47,769
ipv4 header and right at the bottom of

248
00:10:44,829 --> 00:10:50,250
it you have the IP options field this

249
00:10:47,769 --> 00:10:52,870
field is used to extend the protocol and

250
00:10:50,250 --> 00:10:56,260
it basically consists of a type length

251
00:10:52,870 --> 00:10:58,339
value options every options implement

252
00:10:56,260 --> 00:11:00,019
their own type and then there

253
00:10:58,339 --> 00:11:02,749
on that structure inside of the value

254
00:11:00,019 --> 00:11:04,100
field many of these options were leased

255
00:11:02,749 --> 00:11:06,350
throughout the years and we're gonna

256
00:11:04,100 --> 00:11:08,959
focus on a specific one called

257
00:11:06,350 --> 00:11:11,029
the source record routing so these

258
00:11:08,959 --> 00:11:13,309
specific options allow an originating

259
00:11:11,029 --> 00:11:15,139
party of an IP packet to determine the

260
00:11:13,309 --> 00:11:17,209
destination in which the packet must go

261
00:11:15,139 --> 00:11:19,209
through the route in which the packet

262
00:11:17,209 --> 00:11:21,579
must go through to reach the destination

263
00:11:19,209 --> 00:11:25,309
the security implications of it are

264
00:11:21,579 --> 00:11:27,589
obviously bad just looking at what these

265
00:11:25,309 --> 00:11:29,990
options should do and this is why it's a

266
00:11:27,589 --> 00:11:31,759
common practice not to allow this IP

267
00:11:29,990 --> 00:11:34,129
option on your network but to our

268
00:11:31,759 --> 00:11:36,620
surprise fix works supports this to some

269
00:11:34,129 --> 00:11:38,629
degree so as I mentioned every option

270
00:11:36,620 --> 00:11:41,360
implements their own data structure and

271
00:11:38,629 --> 00:11:42,920
in this case is a fairly simple one you

272
00:11:41,360 --> 00:11:44,779
have a pointer which points to the

273
00:11:42,920 --> 00:11:46,490
current routing position and our route

274
00:11:44,779 --> 00:11:49,160
data which basically is just an array of

275
00:11:46,490 --> 00:11:51,949
IP addresses there are hopes for the

276
00:11:49,160 --> 00:11:54,079
packet to go through so let's see how

277
00:11:51,949 --> 00:11:55,790
would a client sending such a packet

278
00:11:54,079 --> 00:11:57,859
would look like first the client needs

279
00:11:55,790 --> 00:11:59,469
to compose the route data meaning that

280
00:11:57,860 --> 00:12:01,999
it has to put inside of the route that

281
00:11:59,470 --> 00:12:03,889
filled all the hops that the packet must

282
00:12:01,999 --> 00:12:06,170
go through and the last hop obviously

283
00:12:03,889 --> 00:12:08,089
being the actual destination it needs to

284
00:12:06,170 --> 00:12:10,790
set destined the packet the first hop

285
00:12:08,089 --> 00:12:12,559
and then set the pointer to the start of

286
00:12:10,790 --> 00:12:14,719
the route data once a router receives

287
00:12:12,559 --> 00:12:16,910
such a packet it advances the pointer

288
00:12:14,720 --> 00:12:18,889
put himself back in the list and then

289
00:12:16,910 --> 00:12:19,490
sends the packet to the next hop this

290
00:12:18,889 --> 00:12:21,350
happens

291
00:12:19,490 --> 00:12:23,389
successively until we reach the final

292
00:12:21,350 --> 00:12:25,790
righto which advances the pointer beyond

293
00:12:23,389 --> 00:12:28,249
the router and that way when the server

294
00:12:25,790 --> 00:12:30,349
receives the packet he knows that he is

295
00:12:28,249 --> 00:12:33,050
the final destination and not just hop

296
00:12:30,350 --> 00:12:35,749
on the way and he can start parsing the

297
00:12:33,050 --> 00:12:37,579
packet now the RFC demands that when the

298
00:12:35,749 --> 00:12:40,069
server would like to answer a client

299
00:12:37,579 --> 00:12:42,888
that send certain IP option he would

300
00:12:40,069 --> 00:12:44,449
have to use the same route that the

301
00:12:42,889 --> 00:12:46,040
packet took in order to reach to it

302
00:12:44,449 --> 00:12:48,679
meaning that he would have to reverse

303
00:12:46,040 --> 00:12:51,949
the route data and send the packet back

304
00:12:48,679 --> 00:12:53,509
in the same manner just in Reverse okay

305
00:12:51,949 --> 00:12:55,399
so there are many cases in which the

306
00:12:53,509 --> 00:12:58,850
server would like to answer an a client

307
00:12:55,399 --> 00:13:01,160
IP packet and one common one is ICMP

308
00:12:58,850 --> 00:13:03,350
evel's some of you may already know this

309
00:13:01,160 --> 00:13:06,589
mechanism basically it's a way for a

310
00:13:03,350 --> 00:13:08,569
server to report a network or networking

311
00:13:06,589 --> 00:13:09,880
level at all without having an

312
00:13:08,569 --> 00:13:12,160
application layer that

313
00:13:09,880 --> 00:13:15,340
that in this case you have a client

314
00:13:12,160 --> 00:13:17,530
sending an IP packet to a closed port on

315
00:13:15,340 --> 00:13:19,060
the server so no application is there to

316
00:13:17,530 --> 00:13:20,290
listen and receive and handle this

317
00:13:19,060 --> 00:13:22,239
packet and the server would like to

318
00:13:20,290 --> 00:13:24,339
report to the client that there is a

319
00:13:22,240 --> 00:13:25,330
problem inside of the packet and he

320
00:13:24,340 --> 00:13:27,700
needs to handle it

321
00:13:25,330 --> 00:13:29,830
so the server wraps the packet inside of

322
00:13:27,700 --> 00:13:31,960
an ICMP packet it specified that the

323
00:13:29,830 --> 00:13:33,970
ICMP type is level in this gate pots

324
00:13:31,960 --> 00:13:36,220
unreachable because there is nothing

325
00:13:33,970 --> 00:13:38,890
listening on that port and then he sends

326
00:13:36,220 --> 00:13:41,590
the packet back to the server so as I

327
00:13:38,890 --> 00:13:43,810
mentioned what happens when a client

328
00:13:41,590 --> 00:13:45,760
sends a packet with the necessary option

329
00:13:43,810 --> 00:13:47,770
as I mentioned there are si demands that

330
00:13:45,760 --> 00:13:50,020
the packet will use the same route back

331
00:13:47,770 --> 00:13:52,329
so when the server will generate the

332
00:13:50,020 --> 00:13:54,790
ICMP arrow it will have to copy the SSRI

333
00:13:52,330 --> 00:13:57,040
option back this seems like a logical

334
00:13:54,790 --> 00:13:58,959
step but what if I tell you that some of

335
00:13:57,040 --> 00:14:01,780
the things that can trigger an ICMP

336
00:13:58,960 --> 00:14:04,090
error is actually problems when passing

337
00:14:01,780 --> 00:14:06,939
the IP option themselves now copying

338
00:14:04,090 --> 00:14:09,790
seems like a good idea not so sure let's

339
00:14:06,940 --> 00:14:11,290
see if it works take on this so

340
00:14:09,790 --> 00:14:14,319
basically this is a very simplified

341
00:14:11,290 --> 00:14:16,810
overview of an IP flow of an IP packet

342
00:14:14,320 --> 00:14:18,490
inside of VxWorks IP stack and you can

343
00:14:16,810 --> 00:14:20,439
see that the packet takes first the

344
00:14:18,490 --> 00:14:22,630
first two stages the one the first one

345
00:14:20,440 --> 00:14:25,240
is the routing logic which determines

346
00:14:22,630 --> 00:14:27,100
whether the packet is destined for us or

347
00:14:25,240 --> 00:14:29,230
nearly to be routed the second one is

348
00:14:27,100 --> 00:14:31,960
the validation step and after the both

349
00:14:29,230 --> 00:14:34,420
steps the packet is considered validated

350
00:14:31,960 --> 00:14:36,880
and sanitized and can be later passed to

351
00:14:34,420 --> 00:14:39,010
the layer 3 handlers so let's imagine an

352
00:14:36,880 --> 00:14:40,720
ICMP echo request has arrived the first

353
00:14:39,010 --> 00:14:43,390
two stages occur now the packet is

354
00:14:40,720 --> 00:14:44,950
validated and sanitized and now the ICMP

355
00:14:43,390 --> 00:14:47,949
handler would like to generate an echo

356
00:14:44,950 --> 00:14:49,750
response so we expose try to be generic

357
00:14:47,950 --> 00:14:52,630
and implement one function that creates

358
00:14:49,750 --> 00:14:53,770
an ICMP packet in this case IP net ICMP

359
00:14:52,630 --> 00:14:55,930
for send

360
00:14:53,770 --> 00:14:57,699
so the ICMP handler will call this

361
00:14:55,930 --> 00:15:00,969
function to generate the echo response

362
00:14:57,700 --> 00:15:03,910
but as I mentioned a lot of a lot of the

363
00:15:00,970 --> 00:15:05,620
both of the first steps can fail and

364
00:15:03,910 --> 00:15:07,630
generate ICMP loz and because we

365
00:15:05,620 --> 00:15:09,580
exported aneri they use the same

366
00:15:07,630 --> 00:15:11,680
function there's a couple of problem

367
00:15:09,580 --> 00:15:14,710
here of course the design is kind of bad

368
00:15:11,680 --> 00:15:17,140
because this function is not aware with

369
00:15:14,710 --> 00:15:19,570
which one called her meaning that it can

370
00:15:17,140 --> 00:15:21,920
be called from error some branches and

371
00:15:19,570 --> 00:15:26,329
still assume the packet is validated

372
00:15:21,920 --> 00:15:27,738
and let's see some of the code so this

373
00:15:26,329 --> 00:15:29,839
is all of the code of the function it

374
00:15:27,739 --> 00:15:32,239
just tries to blindly copy all of the IP

375
00:15:29,839 --> 00:15:34,639
options to the new I simply packet and

376
00:15:32,239 --> 00:15:36,980
it just iterates through all of them and

377
00:15:34,639 --> 00:15:38,959
copies them there's a couple of problems

378
00:15:36,980 --> 00:15:40,730
here the first one is that it assumes

379
00:15:38,959 --> 00:15:43,638
the packet is validated and sanitized

380
00:15:40,730 --> 00:15:45,679
and passed those two first steps meaning

381
00:15:43,639 --> 00:15:47,809
that it trusts the length of the IP

382
00:15:45,679 --> 00:15:50,600
option when copying and using that mem

383
00:15:47,809 --> 00:15:52,730
copy which will co-opt memory giving a

384
00:15:50,600 --> 00:15:55,399
malformed length there's another problem

385
00:15:52,730 --> 00:15:57,589
here that it just goes through every IP

386
00:15:55,399 --> 00:16:00,230
option and try to tries to copy them

387
00:15:57,589 --> 00:16:02,689
which is a problem because in SRL there

388
00:16:00,230 --> 00:16:05,239
is no really logical way to put more

389
00:16:02,689 --> 00:16:08,899
than one and there are States so and

390
00:16:05,239 --> 00:16:12,049
this code is not validated so you can

391
00:16:08,899 --> 00:16:13,819
put multiple malformed SSRI option and

392
00:16:12,049 --> 00:16:15,919
this mem copy will be called with the

393
00:16:13,819 --> 00:16:18,709
length and this will result in a stack

394
00:16:15,919 --> 00:16:20,809
overflow inside of the IP net stack and

395
00:16:18,709 --> 00:16:22,819
we have successfully exploited this bug

396
00:16:20,809 --> 00:16:26,118
in order to execute code inside of

397
00:16:22,819 --> 00:16:27,679
VxWorks IP stack okay so this was a

398
00:16:26,119 --> 00:16:29,929
corner ability but the next one I think

399
00:16:27,679 --> 00:16:32,439
is my favorite it's really simple and

400
00:16:29,929 --> 00:16:34,939
really cute it's in the reverse up

401
00:16:32,439 --> 00:16:36,469
protocol so some of you may ask yourself

402
00:16:34,939 --> 00:16:38,660
what is reversed up you all know up

403
00:16:36,470 --> 00:16:40,910
right you all seen this kind of packet a

404
00:16:38,660 --> 00:16:42,499
client asking the network where is

405
00:16:40,910 --> 00:16:44,809
another client I want to talk to it give

406
00:16:42,499 --> 00:16:46,759
me the data okay but what if I tell you

407
00:16:44,809 --> 00:16:47,959
that you can send a reverse out response

408
00:16:46,759 --> 00:16:50,269
saying to VxWorks

409
00:16:47,959 --> 00:16:53,599
hey this is your IP and we expose

410
00:16:50,269 --> 00:16:55,519
response by saying ok and add the IP to

411
00:16:53,600 --> 00:16:57,410
the interface this is a really weird

412
00:16:55,519 --> 00:16:59,149
behavior and to understand it you need

413
00:16:57,410 --> 00:17:02,899
to know the trap is basically an

414
00:16:59,149 --> 00:17:06,138
ancestor to DHCP and it was used back in

415
00:17:02,899 --> 00:17:08,510
the day to assign addresses to machines

416
00:17:06,138 --> 00:17:10,668
there is no reason for this was to

417
00:17:08,510 --> 00:17:12,740
actually support this it's obsolete many

418
00:17:10,669 --> 00:17:14,539
years now and the problem here is that

419
00:17:12,740 --> 00:17:16,638
big folks doesn't validate that it

420
00:17:14,539 --> 00:17:19,189
actually sends a reverse out request

421
00:17:16,638 --> 00:17:21,678
before passing and handling a reply just

422
00:17:19,189 --> 00:17:24,380
sees a reply and says ok I must've asked

423
00:17:21,679 --> 00:17:27,079
for an IP address let's add it which is

424
00:17:24,380 --> 00:17:29,539
great we have used this bug in order to

425
00:17:27,079 --> 00:17:31,639
build a lot of inside of our research

426
00:17:29,539 --> 00:17:34,690
and most interestingly there are many

427
00:17:31,639 --> 00:17:36,758
devices that had hidden debug features

428
00:17:34,690 --> 00:17:38,909
bind it to a specific IP address so you

429
00:17:36,759 --> 00:17:40,899
can use that to open them really easily

430
00:17:38,909 --> 00:17:42,340
okay so now I'm going to transfer it

431
00:17:40,899 --> 00:17:43,719
back to Ben that's going to talk to you

432
00:17:42,340 --> 00:17:44,289
about some interesting disappear phone

433
00:17:43,720 --> 00:17:48,789
abilities

434
00:17:44,289 --> 00:17:52,029
yeah thank you yeah so that was to

435
00:17:48,789 --> 00:17:55,239
review again the IP options one is Darcy

436
00:17:52,029 --> 00:17:59,259
but we have actually four additional RCS

437
00:17:55,239 --> 00:18:01,349
in the TCP urgent pointer mechanism

438
00:17:59,259 --> 00:18:04,649
we're going to talk about two of these

439
00:18:01,349 --> 00:18:09,460
interesting vulnerabilities to exploit

440
00:18:04,649 --> 00:18:11,049
so basic TCP you have client you have a

441
00:18:09,460 --> 00:18:12,940
server you wanna talk to each other we

442
00:18:11,049 --> 00:18:14,679
do that we are a handshake and then they

443
00:18:12,940 --> 00:18:16,779
can talk to each other you want to learn

444
00:18:14,679 --> 00:18:20,889
more about it I recommend reading this

445
00:18:16,779 --> 00:18:22,929
nice book just for the basic

446
00:18:20,889 --> 00:18:24,998
understanding here I want to just go

447
00:18:22,929 --> 00:18:26,799
back about what is TCP window and then

448
00:18:24,999 --> 00:18:28,950
about the urgent mechanism virgin taken

449
00:18:26,799 --> 00:18:31,359
mechanism so we all know the TCP window

450
00:18:28,950 --> 00:18:33,879
from the network aspect of it it allows

451
00:18:31,359 --> 00:18:36,460
one pier to send multiple segments TCP

452
00:18:33,879 --> 00:18:37,809
segments without reading to wait for

453
00:18:36,460 --> 00:18:39,460
acknowledgement of each of them

454
00:18:37,809 --> 00:18:41,470
that's the TCP window on the network

455
00:18:39,460 --> 00:18:43,960
layer but actually inside the operating

456
00:18:41,470 --> 00:18:46,599
system in the implementation of TCP the

457
00:18:43,960 --> 00:18:49,529
TCP window is a buffer inside the kernel

458
00:18:46,599 --> 00:18:51,908
that is allocated per TCP connection

459
00:18:49,529 --> 00:18:54,279
that saves all the segments that were

460
00:18:51,909 --> 00:18:56,499
received in the in the TCP connection

461
00:18:54,279 --> 00:18:59,919
and once an application wants to read

462
00:18:56,499 --> 00:19:01,299
data from this from the socket it

463
00:18:59,919 --> 00:19:03,669
actually reads from this buffer

464
00:19:01,299 --> 00:19:05,408
allocated inside the kernel so it will

465
00:19:03,669 --> 00:19:08,139
call the receive system call with a

466
00:19:05,409 --> 00:19:09,729
specified length and then the portion of

467
00:19:08,139 --> 00:19:12,668
that buffer will be copied to the

468
00:19:09,729 --> 00:19:15,009
application bathroom so again the only

469
00:19:12,669 --> 00:19:17,049
takeaway from this side if the TCP

470
00:19:15,009 --> 00:19:19,210
window is a buffer inside the operating

471
00:19:17,049 --> 00:19:21,220
system so what is the urgent data

472
00:19:19,210 --> 00:19:21,749
mechanism when you search for TCP urgent

473
00:19:21,220 --> 00:19:24,249
data

474
00:19:21,749 --> 00:19:26,259
muga the first result is a nice answer

475
00:19:24,249 --> 00:19:28,570
the stack overflow says just don't use

476
00:19:26,259 --> 00:19:30,609
origin data and the fact is that it

477
00:19:28,570 --> 00:19:32,439
actually isn't used by modern

478
00:19:30,609 --> 00:19:35,739
applications at all it's a very ancient

479
00:19:32,440 --> 00:19:38,200
mechanism going back to the 80s that

480
00:19:35,739 --> 00:19:40,539
wasn't invented to allow one pier to

481
00:19:38,200 --> 00:19:43,539
send data inside the TCP connection in

482
00:19:40,539 --> 00:19:44,619
an urgent fashion to allow one pier to

483
00:19:43,539 --> 00:19:46,389
stay to the other

484
00:19:44,619 --> 00:19:47,299
please process this urgent data before

485
00:19:46,389 --> 00:19:49,219
you process

486
00:19:47,299 --> 00:19:52,249
thing else in the TCP window that maybe

487
00:19:49,220 --> 00:19:54,110
has been received before so that was the

488
00:19:52,249 --> 00:19:54,769
purpose is this but how was actually

489
00:19:54,110 --> 00:19:57,498
implemented

490
00:19:54,769 --> 00:19:59,929
so actually in each TCP header each TCP

491
00:19:57,499 --> 00:20:01,970
segment there is allocated the 16 bits

492
00:19:59,929 --> 00:20:04,399
of the urgent point or another within

493
00:20:01,970 --> 00:20:05,899
the TCP faggots there is no flag and the

494
00:20:04,399 --> 00:20:08,389
urgent pointer is a relative pointer

495
00:20:05,899 --> 00:20:12,459
inside the TCP stream that points to

496
00:20:08,389 --> 00:20:16,369
we're inside the stream the urgent data

497
00:20:12,460 --> 00:20:18,679
assets and they're the flag means this

498
00:20:16,369 --> 00:20:20,600
this specific segment has urgent data in

499
00:20:18,679 --> 00:20:22,850
it and their departure will point you to

500
00:20:20,600 --> 00:20:24,738
where it is but there are few questions

501
00:20:22,850 --> 00:20:26,719
that are arising just from this data

502
00:20:24,739 --> 00:20:28,730
structure first where exactly does the

503
00:20:26,720 --> 00:20:30,409
urgent pointer point to does is pointing

504
00:20:28,730 --> 00:20:31,789
to the beginning of the urgent data the

505
00:20:30,409 --> 00:20:34,100
end of the urgent data and middleware

506
00:20:31,789 --> 00:20:35,840
doesn't point to and second there is

507
00:20:34,100 --> 00:20:37,488
only an urgent pointer in this since

508
00:20:35,840 --> 00:20:40,039
this structure there isn't an urgent

509
00:20:37,489 --> 00:20:43,879
length so how long can the urgent data

510
00:20:40,039 --> 00:20:47,389
be so to answer these questions let's go

511
00:20:43,879 --> 00:20:50,689
back in time to MU 1981 the first are if

512
00:20:47,389 --> 00:20:53,238
there is a you know not me what anyone I

513
00:20:50,690 --> 00:20:56,929
was a - 6 years old in Turkey was - 14

514
00:20:53,239 --> 00:20:59,269
years old so none of us existed yet and

515
00:20:56,929 --> 00:21:01,100
some guys in the ITF discussed these

516
00:20:59,269 --> 00:21:03,559
questions about the urgent data in the

517
00:21:01,100 --> 00:21:05,719
non-existent what's up work and so the

518
00:21:03,559 --> 00:21:08,029
our first RFC to consider this says you

519
00:21:05,720 --> 00:21:10,940
know one says the urgent pointer points

520
00:21:08,029 --> 00:21:12,470
to the the sequence number of the object

521
00:21:10,940 --> 00:21:15,289
following the originator so it points

522
00:21:12,470 --> 00:21:16,340
past the urgent data okay it sounds

523
00:21:15,289 --> 00:21:19,309
simple enough

524
00:21:16,340 --> 00:21:21,080
however six years later in other RFC

525
00:21:19,309 --> 00:21:23,960
comes along and says no no the data are

526
00:21:21,080 --> 00:21:26,029
c1 the urgent data actually points to

527
00:21:23,960 --> 00:21:28,249
the last it's not the month of following

528
00:21:26,029 --> 00:21:29,950
it and curious after that in other RFC

529
00:21:28,249 --> 00:21:32,539
comes along and states the same

530
00:21:29,950 --> 00:21:34,850
statement it points to the last octet

531
00:21:32,539 --> 00:21:37,220
not the one that following it so there

532
00:21:34,850 --> 00:21:40,309
are these contradictions between the RFC

533
00:21:37,220 --> 00:21:43,309
and 2011 the latest RFC to consider this

534
00:21:40,309 --> 00:21:46,220
came out and said ok I don't know how to

535
00:21:43,309 --> 00:21:47,600
square this problem but let's just say

536
00:21:46,220 --> 00:21:49,879
that if both side of the connection

537
00:21:47,600 --> 00:21:51,529
agree where the pointer points to then

538
00:21:49,879 --> 00:21:54,209
they'll be able to be able to talk to

539
00:21:51,529 --> 00:21:57,320
each other but it does say that

540
00:21:54,210 --> 00:22:00,870
implementation in all the tcp/ip stacks

541
00:21:57,320 --> 00:22:03,000
until that point in time use the first

542
00:22:00,870 --> 00:22:06,270
RFC that says that it points past the

543
00:22:03,000 --> 00:22:09,360
last origin datum okay so if you're a

544
00:22:06,270 --> 00:22:12,210
tcp/ip stack developer today or they

545
00:22:09,360 --> 00:22:14,790
take in 1987 or anywhere on that

546
00:22:12,210 --> 00:22:16,860
timeline you have to ask yourself how am

547
00:22:14,790 --> 00:22:18,750
I going to remain there a generation

548
00:22:16,860 --> 00:22:21,149
mechanism what of the RFC which of the

549
00:22:18,750 --> 00:22:22,500
RFC's should I support and also you need

550
00:22:21,150 --> 00:22:24,090
to ask yourselves again there is the

551
00:22:22,500 --> 00:22:26,310
person we haven't answered yet what is

552
00:22:24,090 --> 00:22:28,770
the length of the urgent data actually

553
00:22:26,310 --> 00:22:30,300
this last RFC for 2011 does state that

554
00:22:28,770 --> 00:22:32,400
because we don't have an urgent length

555
00:22:30,300 --> 00:22:35,010
very urgent data will always be just one

556
00:22:32,400 --> 00:22:36,810
bite so you can see these discrepancies

557
00:22:35,010 --> 00:22:38,610
in the arc seen this map might cause

558
00:22:36,810 --> 00:22:41,700
implementation problems which we will

559
00:22:38,610 --> 00:22:43,229
show in a second how does the data

560
00:22:41,700 --> 00:22:45,840
mechanism work inside the operating

561
00:22:43,230 --> 00:22:48,000
system sorry if you are a client and

562
00:22:45,840 --> 00:22:50,310
want to send some urgent data you need

563
00:22:48,000 --> 00:22:52,110
to set it inside the TCP stream turn on

564
00:22:50,310 --> 00:22:53,280
the origin flag the point of origin

565
00:22:52,110 --> 00:22:54,659
point your summer

566
00:22:53,280 --> 00:22:56,430
I don't know beginning or end of the

567
00:22:54,660 --> 00:22:58,770
turning data and then on the service

568
00:22:56,430 --> 00:23:00,330
side now you need to see that there is

569
00:22:58,770 --> 00:23:02,190
an order data in the stream and split

570
00:23:00,330 --> 00:23:04,320
the urgent data from the non urgent data

571
00:23:02,190 --> 00:23:07,530
then you need to send the server

572
00:23:04,320 --> 00:23:09,060
application a signal stating that there

573
00:23:07,530 --> 00:23:12,030
is urgent data for him to receive in the

574
00:23:09,060 --> 00:23:14,310
loop this is security and then the

575
00:23:12,030 --> 00:23:16,440
application can call a special receive

576
00:23:14,310 --> 00:23:17,820
system call with a special flag message

577
00:23:16,440 --> 00:23:20,700
there will be that state I want to get

578
00:23:17,820 --> 00:23:22,290
this urgent data give it to me and if we

579
00:23:20,700 --> 00:23:23,670
want to receive the regular data the

580
00:23:22,290 --> 00:23:26,280
lawyer the data it will call the regular

581
00:23:23,670 --> 00:23:28,350
receiver so the osu needs to split the

582
00:23:26,280 --> 00:23:30,720
urgent data and the non-avian data and

583
00:23:28,350 --> 00:23:32,250
it needs to know depending on what type

584
00:23:30,720 --> 00:23:34,740
of receiving system call is being called

585
00:23:32,250 --> 00:23:37,430
what type of data to transfer to the

586
00:23:34,740 --> 00:23:41,520
server application and this specific

587
00:23:37,430 --> 00:23:43,410
mechanism is what what is problematic in

588
00:23:41,520 --> 00:23:45,750
vxworks here we can see the function

589
00:23:43,410 --> 00:23:48,630
inside the kernel that implements this

590
00:23:45,750 --> 00:23:51,360
receive system call in VxWorks and what

591
00:23:48,630 --> 00:23:53,340
this code tries to do is understand okay

592
00:23:51,360 --> 00:23:55,770
I was called with the receive of X bytes

593
00:23:53,340 --> 00:23:58,230
so I want to copy X bite from the TCP

594
00:23:55,770 --> 00:24:00,590
window to the user's face but if these

595
00:23:58,230 --> 00:24:03,030
expire contain original data I need to

596
00:24:00,590 --> 00:24:04,230
subtract the length the length field I

597
00:24:03,030 --> 00:24:04,860
need to trim it down so it doesn't

598
00:24:04,230 --> 00:24:06,540
contain

599
00:24:04,860 --> 00:24:08,250
we're generating and this is what

600
00:24:06,540 --> 00:24:09,149
happens in this specific field it's a

601
00:24:08,250 --> 00:24:11,850
specific line

602
00:24:09,150 --> 00:24:13,559
so let's though let's understand the

603
00:24:11,850 --> 00:24:16,350
specific line so let's say a user

604
00:24:13,559 --> 00:24:18,780
requested to receive specific language

605
00:24:16,350 --> 00:24:20,790
but this is the CCP window contains

606
00:24:18,780 --> 00:24:23,970
urgent data in the middle and not urgent

607
00:24:20,790 --> 00:24:26,520
data be sure and after that urgent data

608
00:24:23,970 --> 00:24:28,620
so the receive system call wants to

609
00:24:26,520 --> 00:24:32,010
train the length so it doesn't contain

610
00:24:28,620 --> 00:24:34,709
any urgent data so this is done this way

611
00:24:32,010 --> 00:24:37,049
first it calculates what is a initial

612
00:24:34,710 --> 00:24:38,760
sequence number of the TCP window of the

613
00:24:37,049 --> 00:24:41,429
current TCP window that is done with

614
00:24:38,760 --> 00:24:44,129
this with this two variables and then it

615
00:24:41,429 --> 00:24:46,559
goes to the urgent that's we do know you

616
00:24:44,130 --> 00:24:49,380
know if this as a second start and then

617
00:24:46,559 --> 00:24:51,299
the urgent pointer in vxworks the

618
00:24:49,380 --> 00:24:53,610
default is to support this first RFC so

619
00:24:51,299 --> 00:24:54,990
it points past the urgent data so to get

620
00:24:53,610 --> 00:24:57,659
to the beginning of the urgent data you

621
00:24:54,990 --> 00:24:59,820
do this minus one so now you found where

622
00:24:57,660 --> 00:25:02,040
is the length is that that doesn't

623
00:24:59,820 --> 00:25:03,059
contain any originator that's good so

624
00:25:02,040 --> 00:25:04,470
but there are a couple of problems

625
00:25:03,059 --> 00:25:06,629
actually in this calculation and let's

626
00:25:04,470 --> 00:25:08,130
see one of them first of them is the

627
00:25:06,630 --> 00:25:09,960
edge case of setting the urgent pointer

628
00:25:08,130 --> 00:25:12,240
to zero as I mentioned before the urgent

629
00:25:09,960 --> 00:25:13,679
pointer is a relative pointer to the

630
00:25:12,240 --> 00:25:15,809
current sequence number in the current

631
00:25:13,679 --> 00:25:17,660
segment so the actually variable

632
00:25:15,809 --> 00:25:21,090
Earthling pointer will be sequence start

633
00:25:17,660 --> 00:25:24,090
if we substitute this in the equation

634
00:25:21,090 --> 00:25:27,629
above we can see that sequence star find

635
00:25:24,090 --> 00:25:29,459
a sequence start will will be gone and

636
00:25:27,630 --> 00:25:31,530
then we will be left with minus one so

637
00:25:29,460 --> 00:25:33,780
thank here we'll be under flow this is

638
00:25:31,530 --> 00:25:36,330
important because the length is actually

639
00:25:33,780 --> 00:25:38,129
an unsigned integer so what it once it

640
00:25:36,330 --> 00:25:40,770
is other flowed it will become a very

641
00:25:38,130 --> 00:25:42,540
large number and so if this code try to

642
00:25:40,770 --> 00:25:44,340
trim down the language but in essence

643
00:25:42,540 --> 00:25:46,200
the language actually became a very

644
00:25:44,340 --> 00:25:48,360
large number and now the application

645
00:25:46,200 --> 00:25:50,700
that tried to code received with one

646
00:25:48,360 --> 00:25:52,918
byte actually gets the entire TCP window

647
00:25:50,700 --> 00:25:55,590
so if we have this simple code here that

648
00:25:52,919 --> 00:25:57,510
tries to receive one bite from the from

649
00:25:55,590 --> 00:25:59,820
a TCP connection to the buffer on the

650
00:25:57,510 --> 00:26:02,340
stack the entire TCP window will be

651
00:25:59,820 --> 00:26:04,168
copied out of banks out of bounds to the

652
00:26:02,340 --> 00:26:06,899
application buffer - this will give this

653
00:26:04,169 --> 00:26:08,580
urgent pointer bug this obviously can

654
00:26:06,900 --> 00:26:10,980
cause a stack overflow in this specific

655
00:26:08,580 --> 00:26:12,649
case or if this buffer was allocated on

656
00:26:10,980 --> 00:26:17,460
the heap it can cause and keep overflow

657
00:26:12,650 --> 00:26:19,740
okay so this was the code of this

658
00:26:17,460 --> 00:26:22,799
was caused by the earning your edge case

659
00:26:19,740 --> 00:26:25,770
and this specific bug was actually

660
00:26:22,799 --> 00:26:28,918
averted in some change of code that she

661
00:26:25,770 --> 00:26:30,899
was introduced in the expert 694 however

662
00:26:28,919 --> 00:26:34,020
there are other problems specific line

663
00:26:30,899 --> 00:26:36,360
so we had this urgent pointer problem we

664
00:26:34,020 --> 00:26:38,070
have now other problems and that one of

665
00:26:36,360 --> 00:26:41,189
them is the 5 PI handshake which I

666
00:26:38,070 --> 00:26:43,950
consider now so I said that this line

667
00:26:41,190 --> 00:26:46,440
has multiple issues and actually all for

668
00:26:43,950 --> 00:26:48,980
probabilities that we found or some kind

669
00:26:46,440 --> 00:26:52,320
of edge cases that we can cause this

670
00:26:48,980 --> 00:26:55,169
this this one line two to break this

671
00:26:52,320 --> 00:26:58,230
line has a built in assumption that the

672
00:26:55,169 --> 00:27:00,510
urgent pointer always points beyond the

673
00:26:58,230 --> 00:27:02,640
beginning of the TCP window so one is in

674
00:27:00,510 --> 00:27:05,520
front of the other if that assumption

675
00:27:02,640 --> 00:27:08,100
breaks then this calculation here can

676
00:27:05,520 --> 00:27:09,510
underflow even without the urgent

677
00:27:08,100 --> 00:27:11,189
pointer edge case it can out of any

678
00:27:09,510 --> 00:27:13,620
other concerns mechanism there are

679
00:27:11,190 --> 00:27:18,120
actually many state infusions that we

680
00:27:13,620 --> 00:27:20,399
found that can cause this these two

681
00:27:18,120 --> 00:27:23,279
variables the connection between them to

682
00:27:20,399 --> 00:27:26,250
break so it's complicated and I won't

683
00:27:23,279 --> 00:27:27,539
have time now to go over it in depth you

684
00:27:26,250 --> 00:27:29,159
can read about it in the white paper but

685
00:27:27,539 --> 00:27:31,049
I do want to give one example of this

686
00:27:29,159 --> 00:27:32,730
which is the 5 way hands like what we

687
00:27:31,049 --> 00:27:34,529
call so you all know about the three

688
00:27:32,730 --> 00:27:37,289
already handshake and here we have the 5

689
00:27:34,529 --> 00:27:39,690
3 inches if there are five packets sent

690
00:27:37,289 --> 00:27:42,149
to a VxWorks device that we cause this

691
00:27:39,690 --> 00:27:43,830
state infusion in which the written

692
00:27:42,149 --> 00:27:45,959
pointer and the sequence text both

693
00:27:43,830 --> 00:27:48,600
variables here will be set at different

694
00:27:45,960 --> 00:27:51,059
times and once that is on that once that

695
00:27:48,600 --> 00:27:52,740
happened then this calculation before we

696
00:27:51,059 --> 00:27:54,629
suck an underflow and the same problem

697
00:27:52,740 --> 00:27:55,980
with the length will occur so the first

698
00:27:54,630 --> 00:27:57,779
packet in the five point handshake is

699
00:27:55,980 --> 00:28:01,289
ass in fact you really soon but it has a

700
00:27:57,779 --> 00:28:03,720
TCP option in it an AO option that is

701
00:28:01,289 --> 00:28:05,580
malformed and so what weeks works will

702
00:28:03,720 --> 00:28:07,529
do here is actually allocate allocate

703
00:28:05,580 --> 00:28:10,080
the song with object and drop the packet

704
00:28:07,529 --> 00:28:12,029
but it won't close pocket at all it will

705
00:28:10,080 --> 00:28:13,620
really leave it open now the attacker

706
00:28:12,029 --> 00:28:15,390
can send another packet as Finn seen

707
00:28:13,620 --> 00:28:19,080
urged packet that doesn't make any sense

708
00:28:15,390 --> 00:28:21,870
but that packet will eventually also be

709
00:28:19,080 --> 00:28:24,240
dropped but it will in the process of

710
00:28:21,870 --> 00:28:26,010
being processed it will set the urgent

711
00:28:24,240 --> 00:28:27,750
pointer relative to the sequence number

712
00:28:26,010 --> 00:28:30,360
sending this specific target so now we

713
00:28:27,750 --> 00:28:30,980
set the urgent pointer again the packet

714
00:28:30,360 --> 00:28:33,229
was brought

715
00:28:30,980 --> 00:28:35,330
we didn't get anything act so that I can

716
00:28:33,230 --> 00:28:37,970
send another sim packet in this fact

717
00:28:35,330 --> 00:28:39,230
that you would say this is a regular sin

718
00:28:37,970 --> 00:28:40,549
but he will say it straight another

719
00:28:39,230 --> 00:28:42,799
sequence number for the initial sequence

720
00:28:40,549 --> 00:28:45,168
number and so now the sequence next

721
00:28:42,799 --> 00:28:47,629
variable will be set again so we have

722
00:28:45,169 --> 00:28:49,100
achieved what we set out to do is set

723
00:28:47,630 --> 00:28:51,080
the sequence and next in the urgent

724
00:28:49,100 --> 00:28:52,870
pointer at different times so the

725
00:28:51,080 --> 00:28:55,299
connection between them is broken

726
00:28:52,870 --> 00:28:58,459
eventually now we will get the AK

727
00:28:55,299 --> 00:28:59,840
missing AK and an act and now we've

728
00:28:58,460 --> 00:29:01,700
completed five for a handshake with

729
00:28:59,840 --> 00:29:04,129
these two variables unconnected to each

730
00:29:01,700 --> 00:29:08,000
other if we go back to this equation

731
00:29:04,130 --> 00:29:11,540
and we set these values in the in it we

732
00:29:08,000 --> 00:29:14,870
can see that again

733
00:29:11,540 --> 00:29:16,370
this line will under flow and once it

734
00:29:14,870 --> 00:29:19,129
under flows again the length will be

735
00:29:16,370 --> 00:29:21,199
cast in as an integer and the receive

736
00:29:19,130 --> 00:29:24,260
call from any any server application

737
00:29:21,200 --> 00:29:26,799
that calls receive new TCP socket will

738
00:29:24,260 --> 00:29:31,429
cause an out words out of bounds copy

739
00:29:26,799 --> 00:29:32,690
when you look at both of these and if

740
00:29:31,429 --> 00:29:35,299
our abilities together they actually

741
00:29:32,690 --> 00:29:38,150
impact all week sports versions from a

742
00:29:35,299 --> 00:29:41,900
6.5 up to the last person released last

743
00:29:38,150 --> 00:29:45,100
week or beginning of July actually okay

744
00:29:41,900 --> 00:29:46,880
so there are there are two RCS is a TCP

745
00:29:45,100 --> 00:29:48,500
implementation what what can attacker

746
00:29:46,880 --> 00:29:50,870
you do using these specific

747
00:29:48,500 --> 00:29:52,700
vulnerabilities so there is actually an

748
00:29:50,870 --> 00:29:54,500
interesting use case for this let's

749
00:29:52,700 --> 00:29:56,299
consider this example we have a printer

750
00:29:54,500 --> 00:29:58,760
cracking outbound to a Google cloud

751
00:29:56,299 --> 00:30:00,500
printing service and first of all it

752
00:29:58,760 --> 00:30:03,140
goes out within a server says what is

753
00:30:00,500 --> 00:30:05,500
the IP of the VN of Google cloud that

754
00:30:03,140 --> 00:30:08,090
will resolve and then a TLS connection

755
00:30:05,500 --> 00:30:09,470
will be created between the printer and

756
00:30:08,090 --> 00:30:11,809
the Google cloud so this connection is

757
00:30:09,470 --> 00:30:13,850
secure connection and then because the

758
00:30:11,809 --> 00:30:16,428
TLS is encrypted that connection is a

759
00:30:13,850 --> 00:30:19,219
security but the TCP header actually not

760
00:30:16,429 --> 00:30:21,799
encrypted and divided Beauty we found is

761
00:30:19,220 --> 00:30:23,780
in the parsing of the TCP header so if

762
00:30:21,799 --> 00:30:25,879
we have an attacker here that has some

763
00:30:23,780 --> 00:30:29,000
control of the DNS server in this

764
00:30:25,880 --> 00:30:31,309
example then he can be a matter of the

765
00:30:29,000 --> 00:30:34,190
middle on this connection to the Google

766
00:30:31,309 --> 00:30:37,129
container you can say I am the Google

767
00:30:34,190 --> 00:30:40,970
cloud IP and so the TLS connection would

768
00:30:37,130 --> 00:30:43,280
be going out his IP and now because

769
00:30:40,970 --> 00:30:43,970
again the mobility is in the TCP header

770
00:30:43,280 --> 00:30:45,918
he can

771
00:30:43,970 --> 00:30:48,529
the packet going back from the attacker

772
00:30:45,919 --> 00:30:51,679
to the printer and for example turn on

773
00:30:48,529 --> 00:30:54,919
this urgent zero it's a scenario and

774
00:30:51,679 --> 00:30:57,289
that will exploit the verbal cue on the

775
00:30:54,919 --> 00:30:58,970
printer even if it's behind and not even

776
00:30:57,289 --> 00:31:00,730
if it's secured behind and out so this

777
00:30:58,970 --> 00:31:03,019
is a very unique example of a device

778
00:31:00,730 --> 00:31:06,230
behind an ad that you can attack from

779
00:31:03,019 --> 00:31:08,750
the internet again without needing to

780
00:31:06,230 --> 00:31:12,139
breach the network at all okay so this

781
00:31:08,750 --> 00:31:13,429
is what ezp urgent and now we're going

782
00:31:12,139 --> 00:31:15,469
to talk about the patient monitor that

783
00:31:13,429 --> 00:31:16,360
we have here just a bit and or we'll

784
00:31:15,470 --> 00:31:20,090
walk you through it

785
00:31:16,360 --> 00:31:22,250
okay so we had a lot of fun researching

786
00:31:20,090 --> 00:31:24,080
all of these vulnerabilities and we

787
00:31:22,250 --> 00:31:26,330
wanted to find some devices to exploit

788
00:31:24,080 --> 00:31:28,460
them on this is one interesting case

789
00:31:26,330 --> 00:31:30,740
this is a patient monitor a bedside

790
00:31:28,460 --> 00:31:33,889
hospital patient monitor and he has a

791
00:31:30,740 --> 00:31:36,740
very unique set of qualities first it

792
00:31:33,889 --> 00:31:39,199
runs the Xbox's 6.6 which makes it

793
00:31:36,740 --> 00:31:41,539
vulnerable to the origin zero a variant

794
00:31:39,200 --> 00:31:43,250
that we found it and it has a listening

795
00:31:41,539 --> 00:31:45,470
TCP server that receives to a buffer

796
00:31:43,250 --> 00:31:47,419
that is allocated on the hip that is

797
00:31:45,470 --> 00:31:49,129
great because most of the devices that

798
00:31:47,419 --> 00:31:50,419
we've seen receives on the stack so we

799
00:31:49,129 --> 00:31:52,100
can get away with a simple stack

800
00:31:50,419 --> 00:31:54,350
overflow but in this case we need to

801
00:31:52,100 --> 00:31:55,879
exploit the hip which is interesting to

802
00:31:54,350 --> 00:31:57,678
us because we haven't done it yet and

803
00:31:55,879 --> 00:31:59,389
the most important quality that it has

804
00:31:57,679 --> 00:32:01,399
is when your Google patient point of

805
00:31:59,389 --> 00:32:03,529
weeks works is the first result and you

806
00:32:01,399 --> 00:32:05,479
can buy it on eBay so I'm going to take

807
00:32:03,529 --> 00:32:08,659
it to the three easy steps in order to

808
00:32:05,480 --> 00:32:10,460
obtaining the firm for this device first

809
00:32:08,659 --> 00:32:13,820
you find it on eBay and you convince the

810
00:32:10,460 --> 00:32:15,679
shipper to send it to Israel then you

811
00:32:13,820 --> 00:32:17,539
convince your local FDA that you don't

812
00:32:15,679 --> 00:32:19,460
need an import license to buy a patient

813
00:32:17,539 --> 00:32:21,500
monitor and once you've done all that

814
00:32:19,460 --> 00:32:23,870
you can open it up and spot a PowerPC

815
00:32:21,500 --> 00:32:25,610
JTAG header in it and just dump the

816
00:32:23,870 --> 00:32:27,229
framework and once we did that we were

817
00:32:25,610 --> 00:32:28,850
not surprised to see that there is no

818
00:32:27,230 --> 00:32:31,190
implementation of security and exploit

819
00:32:28,850 --> 00:32:32,990
occations whatsoever there is no data

820
00:32:31,190 --> 00:32:34,730
execution prevention here which is

821
00:32:32,990 --> 00:32:36,740
supported by VX works by turned off

822
00:32:34,730 --> 00:32:39,230
there is no SLR and there is no kernel

823
00:32:36,740 --> 00:32:41,179
use of separation this is not uncommon

824
00:32:39,230 --> 00:32:42,710
on this type of devices most of the

825
00:32:41,179 --> 00:32:44,509
devices that we've seen implement no

826
00:32:42,710 --> 00:32:46,460
security feature whatsoever which makes

827
00:32:44,509 --> 00:32:49,700
exploiting this kind of bugs really

828
00:32:46,460 --> 00:32:51,769
really easy so this as I mentioned it

829
00:32:49,700 --> 00:32:53,960
has the TCP port that is listening and

830
00:32:51,769 --> 00:32:55,549
receives to a buffer on the hip which

831
00:32:53,960 --> 00:32:57,320
means that we're gonna need to exploit

832
00:32:55,549 --> 00:32:58,190
the hip this was a good opportunity for

833
00:32:57,320 --> 00:33:00,230
us to understand

834
00:32:58,190 --> 00:33:02,750
how exactly vixx works hip works and

835
00:33:00,230 --> 00:33:07,070
what are the security implications of it

836
00:33:02,750 --> 00:33:09,950
okay so as you can imagine Vicksburg

837
00:33:07,070 --> 00:33:11,870
ship is pretty trivial hip no security

838
00:33:09,950 --> 00:33:14,419
features are implemented here whatsoever

839
00:33:11,870 --> 00:33:15,799
you have a contiguous memory buffer

840
00:33:14,419 --> 00:33:18,379
which is the hip you have allocated

841
00:33:15,799 --> 00:33:19,879
chunks free chunks and every chunk holds

842
00:33:18,379 --> 00:33:22,699
their own metadata at the start of the

843
00:33:19,879 --> 00:33:24,559
buffer in case of the allocated chunks

844
00:33:22,700 --> 00:33:26,210
you have the two sized awards at the

845
00:33:24,559 --> 00:33:28,309
start you have them also in the free

846
00:33:26,210 --> 00:33:30,019
junk and right after you have the mem

847
00:33:28,309 --> 00:33:31,730
palette pointer the main power pointer

848
00:33:30,019 --> 00:33:34,129
is appointed to a global struck that

849
00:33:31,730 --> 00:33:35,720
describes the hip but because as I

850
00:33:34,129 --> 00:33:38,269
mentioned there is no ISIL out here we

851
00:33:35,720 --> 00:33:40,009
can predict it every time so no problem

852
00:33:38,269 --> 00:33:41,570
there and also we have the head guard

853
00:33:40,009 --> 00:33:43,669
which supposed to be I guess some of

854
00:33:41,570 --> 00:33:45,740
security or reliability feature on the

855
00:33:43,669 --> 00:33:47,659
hip but is it is determining compilation

856
00:33:45,740 --> 00:33:49,519
time of weeks works so not much of a

857
00:33:47,659 --> 00:33:51,860
security feature may be more of a

858
00:33:49,519 --> 00:33:53,629
reliability one in case of the free

859
00:33:51,860 --> 00:33:55,279
chunk you have the same size parameters

860
00:33:53,629 --> 00:33:56,539
but you have a couple of interesting

861
00:33:55,279 --> 00:33:58,580
pointers right there

862
00:33:56,539 --> 00:34:01,759
which are the pointers that put the free

863
00:33:58,580 --> 00:34:03,740
junk inside of the hip free list so what

864
00:34:01,759 --> 00:34:06,769
is a hip free list basically it's just a

865
00:34:03,740 --> 00:34:08,449
list of doubly-linked hip chunks and

866
00:34:06,769 --> 00:34:10,639
every time I user tries to allocate a

867
00:34:08,449 --> 00:34:12,379
chunk the allocator iterates through all

868
00:34:10,639 --> 00:34:15,079
of the free chance and try to find the

869
00:34:12,379 --> 00:34:16,879
one that is right sized for the user to

870
00:34:15,079 --> 00:34:19,819
allocate once it did that it needs to

871
00:34:16,879 --> 00:34:21,848
unlink the free chunk from the free list

872
00:34:19,819 --> 00:34:24,529
and then set it as an allocated chunk

873
00:34:21,849 --> 00:34:26,540
this happens in a very trivial code

874
00:34:24,530 --> 00:34:28,310
inside of the allocator you might you

875
00:34:26,540 --> 00:34:32,029
might have seen this code on your

876
00:34:28,310 --> 00:34:34,190
computer science assignments this is the

877
00:34:32,030 --> 00:34:35,899
basic and linking of a doubly linked

878
00:34:34,190 --> 00:34:38,240
list without any safe and linking

879
00:34:35,899 --> 00:34:41,089
implemented here just the previous chunk

880
00:34:38,239 --> 00:34:43,098
next is my next and so on this is pretty

881
00:34:41,089 --> 00:34:45,739
trivially exploited when you can

882
00:34:43,099 --> 00:34:47,060
overflow those two pointers and this is

883
00:34:45,739 --> 00:34:48,799
called the mirror all right limited

884
00:34:47,060 --> 00:34:51,259
meaning that once we offer flow them

885
00:34:48,800 --> 00:34:53,000
with two values that are addressable and

886
00:34:51,260 --> 00:34:55,250
also meaningful values we can create

887
00:34:53,000 --> 00:34:57,650
mirrored right meaning that one pointer

888
00:34:55,250 --> 00:35:01,160
will be written to another and in

889
00:34:57,650 --> 00:35:03,680
reverse with some offset between them so

890
00:35:01,160 --> 00:35:06,710
what is our heap exploitation strategy

891
00:35:03,680 --> 00:35:08,779
first we are overflowing from obviously

892
00:35:06,710 --> 00:35:11,480
unallocated heap chunk and hoping to hit

893
00:35:08,780 --> 00:35:12,020
a free hip junk in this specific case

894
00:35:11,480 --> 00:35:13,760
the

895
00:35:12,020 --> 00:35:15,560
Mystikal in our favors or no hip

896
00:35:13,760 --> 00:35:18,020
massaging though what sort of was needed

897
00:35:15,560 --> 00:35:21,620
here we just overflow from our hip chunk

898
00:35:18,020 --> 00:35:23,420
right to a free hip chunk and then set

899
00:35:21,620 --> 00:35:25,970
those two pointers in order to achieve

900
00:35:23,420 --> 00:35:27,860
our midlife primitive then we wait for

901
00:35:25,970 --> 00:35:29,779
someone to allocate this buffer this

902
00:35:27,860 --> 00:35:31,670
happens quite often Leon the system that

903
00:35:29,780 --> 00:35:32,120
buffers get allocated and read all the

904
00:35:31,670 --> 00:35:34,550
time

905
00:35:32,120 --> 00:35:36,580
so now we have a mural right and we can

906
00:35:34,550 --> 00:35:39,890
write whatever we want whoever we want

907
00:35:36,580 --> 00:35:41,930
so remember the stroke that I told you

908
00:35:39,890 --> 00:35:43,430
that describes the hip it has some

909
00:35:41,930 --> 00:35:46,580
interesting function pointers in it

910
00:35:43,430 --> 00:35:48,680
these function pointers pointers that

911
00:35:46,580 --> 00:35:51,049
hooks all the allocation and free

912
00:35:48,680 --> 00:35:53,480
functions inside of the memory allocator

913
00:35:51,050 --> 00:35:55,790
and basically we just steal one of them

914
00:35:53,480 --> 00:35:57,860
to get execution time and also we can

915
00:35:55,790 --> 00:35:59,390
execute code before another allocation

916
00:35:57,860 --> 00:36:01,490
occurs or another free occurs so the

917
00:35:59,390 --> 00:36:04,069
heap will remain intact and we will not

918
00:36:01,490 --> 00:36:08,120
destroy anything yet so once we get some

919
00:36:04,070 --> 00:36:11,210
runtime we will just freeze this region

920
00:36:08,120 --> 00:36:13,910
of the hip we just hook every allocation

921
00:36:11,210 --> 00:36:15,290
and every free call that is happening on

922
00:36:13,910 --> 00:36:18,259
the system and if someone tries to

923
00:36:15,290 --> 00:36:20,060
allocate a buffer from our area that we

924
00:36:18,260 --> 00:36:22,370
have destroyed we just ignore that and

925
00:36:20,060 --> 00:36:24,410
if we tries to free we just ignore that

926
00:36:22,370 --> 00:36:26,180
too and in the case of an allocation we

927
00:36:24,410 --> 00:36:28,040
just give it another chunk from another

928
00:36:26,180 --> 00:36:31,270
place on the hip we also have a

929
00:36:28,040 --> 00:36:34,090
primitive that sets a specific that

930
00:36:31,270 --> 00:36:36,980
specific data buffer in the data section

931
00:36:34,090 --> 00:36:38,480
to values that we control we won't talk

932
00:36:36,980 --> 00:36:40,820
about it but as I mentioned there are no

933
00:36:38,480 --> 00:36:43,190
DEP here so executing data is pretty

934
00:36:40,820 --> 00:36:45,500
easy and now I'm going to set up the

935
00:36:43,190 --> 00:36:48,920
live demo and hopefully if we pray to

936
00:36:45,500 --> 00:36:51,230
the demo god it will work yeah can we

937
00:36:48,920 --> 00:36:53,810
switch to the camera under the table so

938
00:36:51,230 --> 00:36:55,940
this is a magic box but there is a

939
00:36:53,810 --> 00:36:58,279
patient monitor article just for the it

940
00:36:55,940 --> 00:37:01,690
reflex too much for the light so we have

941
00:36:58,280 --> 00:37:01,690
to it like this and I can connect myself

942
00:37:02,650 --> 00:37:08,810
yes ok so before door starts this is a

943
00:37:07,400 --> 00:37:11,540
patient water like I said a hospital

944
00:37:08,810 --> 00:37:14,049
bedside patient monitor and it can

945
00:37:11,540 --> 00:37:18,029
connect to multiple vital readings the

946
00:37:14,050 --> 00:37:20,050
part of the oxygen and leg a ECG

947
00:37:18,030 --> 00:37:24,310
electrodes which I want to stick to

948
00:37:20,050 --> 00:37:26,320
myself but actually do work and we

949
00:37:24,310 --> 00:37:28,900
already won the exploit that's before

950
00:37:26,320 --> 00:37:30,460
the talk so so it's like ready and this

951
00:37:28,900 --> 00:37:32,770
active device actually has a built-in

952
00:37:30,460 --> 00:37:34,300
debugger the regular like vxworks

953
00:37:32,770 --> 00:37:36,790
debugger that is turned off by default

954
00:37:34,300 --> 00:37:38,350
but once you run code on it you can turn

955
00:37:36,790 --> 00:37:41,800
on the debugger and that can be your

956
00:37:38,350 --> 00:37:43,630
backdoor to control it various ways and

957
00:37:41,800 --> 00:37:45,460
what we did is upload some code that

958
00:37:43,630 --> 00:37:48,400
will allow us to change the battery

959
00:37:45,460 --> 00:37:54,580
readings and do all kind of stuff so for

960
00:37:48,400 --> 00:37:57,490
example we can change the pulse rating

961
00:37:54,580 --> 00:37:59,500
of me and in the oxygen levels you can

962
00:37:57,490 --> 00:38:01,540
see that I'm not really that excited to

963
00:37:59,500 --> 00:38:04,960
see all of you folks it's just the

964
00:38:01,540 --> 00:38:07,650
monitor says otherwise and now I'm not

965
00:38:04,960 --> 00:38:10,500
dead as well I'm pretty much alive

966
00:38:07,650 --> 00:38:13,420
okay so we've done that and we can also

967
00:38:10,500 --> 00:38:18,340
put whatever wrong on the screen for

968
00:38:13,420 --> 00:38:21,160
example this black hat logos and last

969
00:38:18,340 --> 00:38:23,590
thing like last night just before going

970
00:38:21,160 --> 00:38:25,299
to see I really wanted to see maybe

971
00:38:23,590 --> 00:38:27,280
looking like one doom on this patient

972
00:38:25,300 --> 00:38:30,070
water and I didn't have time to actually

973
00:38:27,280 --> 00:38:32,440
do it but I was able to rather one frame

974
00:38:30,070 --> 00:38:34,630
of doom on the patient monitor and maybe

975
00:38:32,440 --> 00:38:37,750
until last like the next year maybe I

976
00:38:34,630 --> 00:38:41,200
can actually do lately okay so that was

977
00:38:37,750 --> 00:38:43,510
the patient monitor and now if that also

978
00:38:41,200 --> 00:38:47,700
works we can take some questions

979
00:38:43,510 --> 00:38:50,800
Oh actually I do want to summarize a bit

980
00:38:47,700 --> 00:38:55,450
the take over the takeaways and then

981
00:38:50,800 --> 00:38:59,680
we'll do the questions okay so we went

982
00:38:55,450 --> 00:39:01,660
through a lot of material again a very

983
00:38:59,680 --> 00:39:03,790
long research with many any four

984
00:39:01,660 --> 00:39:06,279
abilities in it I think I just want to

985
00:39:03,790 --> 00:39:09,850
go back to a few takeaways from this

986
00:39:06,280 --> 00:39:12,520
talk first with some operating systems I

987
00:39:09,850 --> 00:39:14,529
think our need to get much more

988
00:39:12,520 --> 00:39:17,650
attention from the research community we

989
00:39:14,530 --> 00:39:20,140
from this example we saw two billion

990
00:39:17,650 --> 00:39:23,080
devices running on VxWorks but only

991
00:39:20,140 --> 00:39:25,060
sorry only 13 volt videos founded in the

992
00:39:23,080 --> 00:39:27,430
last 13 years

993
00:39:25,060 --> 00:39:29,220
more work to be done in researching with

994
00:39:27,430 --> 00:39:33,910
our operating systems especially the one

995
00:39:29,220 --> 00:39:35,980
so widely used second we also noticed in

996
00:39:33,910 --> 00:39:38,710
this research all these esoteric

997
00:39:35,980 --> 00:39:40,810
features from tcp/ip stacks that our

998
00:39:38,710 --> 00:39:42,760
practice are not written pointers the

999
00:39:40,810 --> 00:39:44,890
reverse are these stuff are not used in

1000
00:39:42,760 --> 00:39:46,570
practice but are still implemented in

1001
00:39:44,890 --> 00:39:48,700
various stacks and creating attack

1002
00:39:46,570 --> 00:39:51,220
surfaces that he's really not needed so

1003
00:39:48,700 --> 00:39:53,339
steps to phase out these specific

1004
00:39:51,220 --> 00:39:55,899
mechanisms is also needed I think

1005
00:39:53,340 --> 00:39:58,360
boasting the stacks and just possibly as

1006
00:39:55,900 --> 00:40:00,100
well in the RFC's like a new RFC can

1007
00:39:58,360 --> 00:40:02,770
come along and stay no words into the

1008
00:40:00,100 --> 00:40:06,670
pointer and lastly I do think that this

1009
00:40:02,770 --> 00:40:11,380
research also shows the challenge of

1010
00:40:06,670 --> 00:40:14,590
actually finding devices that were px

1011
00:40:11,380 --> 00:40:17,680
works so if you would be a researcher

1012
00:40:14,590 --> 00:40:19,150
for Android or Windows you can buy an

1013
00:40:17,680 --> 00:40:21,009
Android phone and you can research it

1014
00:40:19,150 --> 00:40:22,420
and it's quite easy if you want to

1015
00:40:21,010 --> 00:40:23,830
recent weeks works you need to find out

1016
00:40:22,420 --> 00:40:26,740
what is the device the front of the

1017
00:40:23,830 --> 00:40:29,080
expert that I can actually use for my

1018
00:40:26,740 --> 00:40:31,359
research it's not an easy task to do

1019
00:40:29,080 --> 00:40:32,590
there are many many devices the front VX

1020
00:40:31,360 --> 00:40:34,210
works but it's not an advertised

1021
00:40:32,590 --> 00:40:36,430
operating system and it's not something

1022
00:40:34,210 --> 00:40:39,400
that you go to the store and say I wanna

1023
00:40:36,430 --> 00:40:41,109
buy VxWorks device so there is a

1024
00:40:39,400 --> 00:40:43,510
challenge in identifying what is this

1025
00:40:41,110 --> 00:40:45,490
underlying operating system used by many

1026
00:40:43,510 --> 00:40:48,460
devices many real-time operating systems

1027
00:40:45,490 --> 00:40:52,149
based devices I think this giant also

1028
00:40:48,460 --> 00:40:53,950
needs we need to confront it in order to

1029
00:40:52,150 --> 00:40:56,320
understand the hacked surface of many of

1030
00:40:53,950 --> 00:40:58,359
the devices that surround us and we do

1031
00:40:56,320 --> 00:40:59,500
have 10 minutes surprisingly so if you

1032
00:40:58,360 --> 00:41:00,370
have any question there are three mics

1033
00:40:59,500 --> 00:41:10,780
here

1034
00:41:00,370 --> 00:41:14,980
you're welcome to yeah thank you so I'm

1035
00:41:10,780 --> 00:41:17,010
I demo a lot with IOT SCADA ice it seems

1036
00:41:14,980 --> 00:41:20,530
to be kind of a focus of your company

1037
00:41:17,010 --> 00:41:27,190
I'm frankly surprised you only found 13

1038
00:41:20,530 --> 00:41:28,650
or 14 that you don't have more surprise

1039
00:41:27,190 --> 00:41:30,210
you only found 11

1040
00:41:28,650 --> 00:41:33,240
have you done much with fragmentation

1041
00:41:30,210 --> 00:41:35,100
like the Rose attack or any kind of TCP

1042
00:41:33,240 --> 00:41:38,069
IP fragmentation there is another one

1043
00:41:35,100 --> 00:41:40,110
that came out recently to basically DDoS

1044
00:41:38,070 --> 00:41:42,990
these these devices and just shut them

1045
00:41:40,110 --> 00:41:45,780
down so I'll repeat the question telling

1046
00:41:42,990 --> 00:41:48,180
me okay so you asked me if fragmentation

1047
00:41:45,780 --> 00:41:51,480
in TCP and IP can cause there are

1048
00:41:48,180 --> 00:41:53,430
services on these types of it yeah so we

1049
00:41:51,480 --> 00:41:54,960
did actually look at this the

1050
00:41:53,430 --> 00:41:56,339
implementation of fermentation and we

1051
00:41:54,960 --> 00:41:58,680
didn't find out anything concrete about

1052
00:41:56,340 --> 00:42:01,260
this but it is a good good target for

1053
00:41:58,680 --> 00:42:04,140
research fragmentation in both IP and

1054
00:42:01,260 --> 00:42:06,750
TCP can cause implementation but not in

1055
00:42:04,140 --> 00:42:12,330
this instance though look up the ROS

1056
00:42:06,750 --> 00:42:14,070
attack oh yeah I can I think a thing

1057
00:42:12,330 --> 00:42:16,410
before there are many abilities that

1058
00:42:14,070 --> 00:42:18,630
cause like resource exhaustion a life

1059
00:42:16,410 --> 00:42:20,279
service in the application there but but

1060
00:42:18,630 --> 00:42:22,710
getting it to denial of service that

1061
00:42:20,280 --> 00:42:24,060
actually reboot the device or it causes

1062
00:42:22,710 --> 00:42:27,660
remote to the execution that's another

1063
00:42:24,060 --> 00:42:29,670
type of attack sure yeah

1064
00:42:27,660 --> 00:42:32,759
thanks for the presentation a really

1065
00:42:29,670 --> 00:42:34,440
interesting work did at the beginning of

1066
00:42:32,760 --> 00:42:37,130
the presentation you mentioned that the

1067
00:42:34,440 --> 00:42:40,050
same tcp/ip stack is used in thread acts

1068
00:42:37,130 --> 00:42:42,570
did you guys also investigate to see if

1069
00:42:40,050 --> 00:42:45,450
you could accomplish these same exploits

1070
00:42:42,570 --> 00:42:46,850
in thread acts so we haven't actually

1071
00:42:45,450 --> 00:42:49,350
what we understood from Green River

1072
00:42:46,850 --> 00:42:52,230
which is now own I think that is that

1073
00:42:49,350 --> 00:42:55,020
since 2006 when they purchased

1074
00:42:52,230 --> 00:42:57,870
Iping that these other operating systems

1075
00:42:55,020 --> 00:43:02,430
no longer use liking it but it is

1076
00:42:57,870 --> 00:43:10,200
something to consider yeah he just stole

1077
00:43:02,430 --> 00:43:14,700
my question would control dignity block

1078
00:43:10,200 --> 00:43:17,850
your exploits attempt would control flow

1079
00:43:14,700 --> 00:43:19,830
integrity block your exploits oh well

1080
00:43:17,850 --> 00:43:22,290
that's really not something that exists

1081
00:43:19,830 --> 00:43:25,170
in VxWorks devices I think there are

1082
00:43:22,290 --> 00:43:27,230
much basic stuff that can prevent these

1083
00:43:25,170 --> 00:43:30,240
attacks for being such easy to exploit

1084
00:43:27,230 --> 00:43:33,780
you know the dormant exists in our cell

1085
00:43:30,240 --> 00:43:35,370
our know that no stack Canaries

1086
00:43:33,780 --> 00:43:37,980
they are not implemented in practicing

1087
00:43:35,370 --> 00:43:40,240
many of vicksburg devices and if you

1088
00:43:37,980 --> 00:43:42,570
will another mitigation to that

1089
00:43:40,240 --> 00:43:42,569
even more

