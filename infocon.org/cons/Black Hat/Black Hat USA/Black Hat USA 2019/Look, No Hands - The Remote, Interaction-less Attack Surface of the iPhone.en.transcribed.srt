1
00:00:00,030 --> 00:00:04,140
welcome to look no hands the remote

2
00:00:02,009 --> 00:00:06,750
interactionists attack surface of the

3
00:00:04,140 --> 00:00:09,510
iPhone you're in lagoon GHI and the

4
00:00:06,750 --> 00:00:10,860
speaker is Natalie's ivanovitch before

5
00:00:09,510 --> 00:00:13,349
we begin though we have a few brief

6
00:00:10,860 --> 00:00:15,800
notes please stop by the business Hall

7
00:00:13,349 --> 00:00:18,480
located in Mandalay Bay Oceanside and

8
00:00:15,800 --> 00:00:20,550
shoreline ballrooms on level two during

9
00:00:18,480 --> 00:00:23,369
the day and for the Welcome Reception at

10
00:00:20,550 --> 00:00:25,170
5:30 this evening the blackhat Arsenal

11
00:00:23,369 --> 00:00:27,750
is in the business hall on level 2 and

12
00:00:25,170 --> 00:00:33,809
join us for the pony Awards in lagoon

13
00:00:27,750 --> 00:00:35,519
JKL at 6:30 the rap room for this call

14
00:00:33,809 --> 00:00:38,129
offer for this talk will be in reef a

15
00:00:35,520 --> 00:00:41,010
which is down the hall and please put

16
00:00:38,129 --> 00:00:43,970
your phone on vibrate or silent without

17
00:00:41,010 --> 00:00:47,030
further ado Natalie

18
00:00:43,970 --> 00:00:47,030
[Music]

19
00:00:51,350 --> 00:00:57,900
hi everyone thanks so much for coming

20
00:00:55,280 --> 00:01:00,270
today I'm going to talk about the remote

21
00:00:57,900 --> 00:01:04,230
interaction list attack surface of the

22
00:01:00,270 --> 00:01:07,290
iPhone I'm Natalie savanah bitch and I'm

23
00:01:04,230 --> 00:01:09,240
a member of project zero at Google and I

24
00:01:07,290 --> 00:01:10,890
fell remotes are something we've been

25
00:01:09,240 --> 00:01:13,530
thinking about for a long time

26
00:01:10,890 --> 00:01:16,860
Oh while ago there was this tweet from

27
00:01:13,530 --> 00:01:18,990
chowky that said rumor says that from a

28
00:01:16,860 --> 00:01:21,570
zero-day exploit perspective the

29
00:01:18,990 --> 00:01:24,509
security of iMessage is less than these

30
00:01:21,570 --> 00:01:27,539
other messengers and if you don't know

31
00:01:24,510 --> 00:01:29,760
chowky he runs a rhodium which is a

32
00:01:27,540 --> 00:01:32,460
company that pays for all sorts of

33
00:01:29,760 --> 00:01:35,550
exploits including iPhone exploits and

34
00:01:32,460 --> 00:01:38,429
this says that they'll pay five hundred

35
00:01:35,550 --> 00:01:42,539
thousand dollars for an iMessage remote

36
00:01:38,430 --> 00:01:45,090
and one point five million dollars for

37
00:01:42,540 --> 00:01:49,619
zero click promote jailbreak on an

38
00:01:45,090 --> 00:01:52,080
iPhone also there was this article about

39
00:01:49,619 --> 00:01:55,409
the UAE secret hacking team and their

40
00:01:52,080 --> 00:01:58,620
tool called Karma and some excerpts here

41
00:01:55,409 --> 00:02:01,320
are that it did not require a target to

42
00:01:58,620 --> 00:02:05,580
click and it relied on an undisclosed

43
00:02:01,320 --> 00:02:08,280
vulnerability in iMessage so there's

44
00:02:05,580 --> 00:02:09,810
these little glimmers of the fact that

45
00:02:08,280 --> 00:02:12,300
attackers are using this type of

46
00:02:09,810 --> 00:02:14,280
vulnerability but then when you look at

47
00:02:12,300 --> 00:02:16,470
public research there's not so much

48
00:02:14,280 --> 00:02:19,380
information and there's even people that

49
00:02:16,470 --> 00:02:20,730
doubt that these types of bugs exist so

50
00:02:19,380 --> 00:02:23,519
I wanted to get to the bottom of this

51
00:02:20,730 --> 00:02:26,399
and find out whether these bikes exist

52
00:02:23,519 --> 00:02:30,150
and if so where are they in the system

53
00:02:26,400 --> 00:02:32,459
and how do they work also I wondered was

54
00:02:30,150 --> 00:02:35,130
it just iMessage or are there other

55
00:02:32,459 --> 00:02:37,850
remote attack surfaces too and I

56
00:02:35,130 --> 00:02:41,370
wondered if these bugs are exploitable

57
00:02:37,850 --> 00:02:44,790
so to start off what do I mean by an

58
00:02:41,370 --> 00:02:47,070
interaction list bug or zero click or a

59
00:02:44,790 --> 00:02:49,410
fully remote bug well it means that

60
00:02:47,070 --> 00:02:51,690
there is absolutely no user interaction

61
00:02:49,410 --> 00:02:55,290
required you can just sit a device

62
00:02:51,690 --> 00:02:58,800
somewhere and run your bug or exploit

63
00:02:55,290 --> 00:03:01,769
and it will compromise that device also

64
00:02:58,800 --> 00:03:03,560
I would say a short wait time is a good

65
00:03:01,770 --> 00:03:05,209
requirement to just as

66
00:03:03,560 --> 00:03:06,830
people will be like Oh someone will

67
00:03:05,209 --> 00:03:08,630
eventually unlock their phone someone

68
00:03:06,830 --> 00:03:10,010
will eventually open the browser but

69
00:03:08,630 --> 00:03:11,930
that's not really what we're looking for

70
00:03:10,010 --> 00:03:16,160
here we're looking for the ones that

71
00:03:11,930 --> 00:03:18,620
require no click and work fast and also

72
00:03:16,160 --> 00:03:21,019
they need to require a reasonable set of

73
00:03:18,620 --> 00:03:23,690
identifiers usually a person's email

74
00:03:21,019 --> 00:03:26,330
address or their phone number once you

75
00:03:23,690 --> 00:03:28,670
get into things like IP address or IMEI

76
00:03:26,330 --> 00:03:30,890
you need to also find a way to get that

77
00:03:28,670 --> 00:03:34,819
identifier or it's harder for an

78
00:03:30,890 --> 00:03:38,119
attacker to target someone so thinking

79
00:03:34,819 --> 00:03:40,310
about this this is the remote attack

80
00:03:38,120 --> 00:03:43,700
surface the iPhone that I looked at

81
00:03:40,310 --> 00:03:46,190
there is SMS which is text messages and

82
00:03:43,700 --> 00:03:48,560
then there's all these special sms's

83
00:03:46,190 --> 00:03:51,170
that your carrier can send for example

84
00:03:48,560 --> 00:03:53,900
there is supple which sends GPS

85
00:03:51,170 --> 00:03:57,738
ephemeris data and then there is MMS

86
00:03:53,900 --> 00:04:01,430
which is basically SMS if you have media

87
00:03:57,739 --> 00:04:04,400
attachment and then there is iMessage

88
00:04:01,430 --> 00:04:07,069
which is the messaging client on the

89
00:04:04,400 --> 00:04:09,769
iPhone that uses Apple server for

90
00:04:07,069 --> 00:04:12,380
messages and this regular messages and

91
00:04:09,769 --> 00:04:14,359
then there's extensions have you ever

92
00:04:12,380 --> 00:04:15,320
seen the thing on the iPhone where you

93
00:04:14,359 --> 00:04:17,150
point the camera at your face and

94
00:04:15,320 --> 00:04:18,858
there's a giraffe and you move your

95
00:04:17,149 --> 00:04:21,828
mouth and the giraffe talks like you're

96
00:04:18,858 --> 00:04:24,280
a mouse that's an iMessage extension and

97
00:04:21,829 --> 00:04:28,160
that's also part of the attack surface

98
00:04:24,280 --> 00:04:30,229
and then there are things that you can

99
00:04:28,160 --> 00:04:33,440
go over the public internet there's the

100
00:04:30,229 --> 00:04:36,050
email client if someone sends you an

101
00:04:33,440 --> 00:04:38,419
email sometimes it'll be processed even

102
00:04:36,050 --> 00:04:40,430
if you don't open it yet and then

103
00:04:38,419 --> 00:04:42,680
there's also a packet processing on the

104
00:04:40,430 --> 00:04:45,710
public Internet no you need an IP

105
00:04:42,680 --> 00:04:47,539
address for that first usually so I

106
00:04:45,710 --> 00:04:50,539
started off by looking at SMS and MMS

107
00:04:47,539 --> 00:04:53,419
and in hindsight this was the wrong call

108
00:04:50,539 --> 00:04:53,750
I had this idea that everyone talks

109
00:04:53,419 --> 00:04:56,180
about

110
00:04:53,750 --> 00:04:59,000
iMessage so much you know one must look

111
00:04:56,180 --> 00:05:00,919
for bugs in the other places and there

112
00:04:59,000 --> 00:05:02,300
be lots of bugs in them that was wrong

113
00:05:00,919 --> 00:05:05,330
this was actually a fairly difficult

114
00:05:02,300 --> 00:05:08,000
attack surface so I looked at the column

115
00:05:05,330 --> 00:05:11,990
Center binary which on the iPhone is

116
00:05:08,000 --> 00:05:13,550
where SMS is are processed and gonna

117
00:05:11,990 --> 00:05:15,920
flip through these quickly but this is

118
00:05:13,550 --> 00:05:17,000
the message flow this is more

119
00:05:15,920 --> 00:05:19,340
or people if they want to look at this

120
00:05:17,000 --> 00:05:22,850
at home these were generally the methods

121
00:05:19,340 --> 00:05:28,880
that get executed when you get a raw SMS

122
00:05:22,850 --> 00:05:30,470
and this is a similar diagram for MMS so

123
00:05:28,880 --> 00:05:32,480
the first thing I did was I wrote

124
00:05:30,470 --> 00:05:35,720
applications that exported some of these

125
00:05:32,480 --> 00:05:40,550
symbols and then sizes I'm just sending

126
00:05:35,720 --> 00:05:43,130
random data that didn't work and then I

127
00:05:40,550 --> 00:05:45,890
noticed that the SMS on the iPhone

128
00:05:43,130 --> 00:05:48,980
actually has a built in SMS emulator and

129
00:05:45,890 --> 00:05:50,930
it's incomplete it requires a library

130
00:05:48,980 --> 00:05:53,810
which I assume is on Apple internal

131
00:05:50,930 --> 00:05:57,980
devices but I didn't have so I

132
00:05:53,810 --> 00:06:00,080
reconstructed this library I basically

133
00:05:57,980 --> 00:06:03,350
made up a library that on a jailbroken

134
00:06:00,080 --> 00:06:05,690
iPhone will call the right functions and

135
00:06:03,350 --> 00:06:08,240
it would basically allow you to simulate

136
00:06:05,690 --> 00:06:11,180
a deliverer PDU being sent to your

137
00:06:08,240 --> 00:06:15,560
device and I put this on github today so

138
00:06:11,180 --> 00:06:17,240
if you go to this location you can get a

139
00:06:15,560 --> 00:06:20,450
lot of tools including this SMS

140
00:06:17,240 --> 00:06:22,070
simulator and I use this for fussing but

141
00:06:20,450 --> 00:06:24,590
unfortunately that didn't really work

142
00:06:22,070 --> 00:06:28,250
out either and I didn't find any bugs in

143
00:06:24,590 --> 00:06:30,890
SMS but then I started looking at those

144
00:06:28,250 --> 00:06:33,620
special SMS is that your carrier can

145
00:06:30,890 --> 00:06:36,020
send and one thing that I noticed was

146
00:06:33,620 --> 00:06:38,270
visual voicemail and these are little

147
00:06:36,020 --> 00:06:41,599
voicemail is when you use your mobile

148
00:06:38,270 --> 00:06:43,820
device you'll have an email like format

149
00:06:41,600 --> 00:06:45,500
for your voicemail messages so you'll

150
00:06:43,820 --> 00:06:47,060
see the number and then you'll see the

151
00:06:45,500 --> 00:06:49,490
play button and the message and

152
00:06:47,060 --> 00:06:52,100
sometimes a transcript and the way this

153
00:06:49,490 --> 00:06:53,870
actually works is that your carrier will

154
00:06:52,100 --> 00:06:56,180
send you an SMS and that will have an

155
00:06:53,870 --> 00:06:58,130
IMAP server a location in it then it

156
00:06:56,180 --> 00:07:01,850
will ping that IMAP server and pull down

157
00:06:58,130 --> 00:07:03,050
all your messages and they seemed ok if

158
00:07:01,850 --> 00:07:04,970
it was just the carrier that could do

159
00:07:03,050 --> 00:07:08,270
this but I tried sending the messages

160
00:07:04,970 --> 00:07:10,520
and you could send this from any SMS

161
00:07:08,270 --> 00:07:14,090
device you know I could send it from the

162
00:07:10,520 --> 00:07:16,099
SIM card I bought at the gas station so

163
00:07:14,090 --> 00:07:19,099
I looked at this message a little bit

164
00:07:16,100 --> 00:07:22,520
more and here's an example of it so like

165
00:07:19,100 --> 00:07:26,750
for example would replace bbm AT&T comm

166
00:07:22,520 --> 00:07:28,190
with you no matter shankha comm and then

167
00:07:26,750 --> 00:07:30,650
it would just ping my eye

168
00:07:28,190 --> 00:07:32,960
mapserver and I thought this would

169
00:07:30,650 --> 00:07:37,190
actually be a pretty good attack surface

170
00:07:32,960 --> 00:07:41,060
here's why on iOS devices they use the

171
00:07:37,190 --> 00:07:43,490
same library for bbm as they do for

172
00:07:41,060 --> 00:07:45,470
regular IMAP and email and that's kind

173
00:07:43,490 --> 00:07:48,020
of a change of italic surface when you

174
00:07:45,470 --> 00:07:50,150
think about imap4 email really it's the

175
00:07:48,020 --> 00:07:52,099
server that's the attack surface you

176
00:07:50,150 --> 00:07:54,500
know since the beginning of IMAP people

177
00:07:52,100 --> 00:07:58,370
have tried to compromise servers to read

178
00:07:54,500 --> 00:08:00,320
everyone's emails but the idea of a

179
00:07:58,370 --> 00:08:02,720
client being attacked by a malicious

180
00:08:00,320 --> 00:08:05,150
server that's not really an attack

181
00:08:02,720 --> 00:08:08,000
surface in email because the only used

182
00:08:05,150 --> 00:08:10,030
server as you trust and it's a lot less

183
00:08:08,000 --> 00:08:12,800
common for a user to put any server in

184
00:08:10,030 --> 00:08:15,770
but visual voicemail changes this attack

185
00:08:12,800 --> 00:08:18,500
surface it means now that anyone are

186
00:08:15,770 --> 00:08:20,810
from a remote context can make you ping

187
00:08:18,500 --> 00:08:22,310
an IMAP server for messages so I

188
00:08:20,810 --> 00:08:24,050
wondered if the people who wrote the

189
00:08:22,310 --> 00:08:27,530
library had thought about this context

190
00:08:24,050 --> 00:08:30,590
switch and hardened that surface so I

191
00:08:27,530 --> 00:08:32,299
took a look at it and there are some

192
00:08:30,590 --> 00:08:34,839
limitations here one is that your

193
00:08:32,299 --> 00:08:37,579
carrier has to support it and I put some

194
00:08:34,840 --> 00:08:38,810
asterisks on that in that I think there

195
00:08:37,580 --> 00:08:40,300
is probably ways to get around this

196
00:08:38,809 --> 00:08:44,750
especially if you have a base station

197
00:08:40,299 --> 00:08:46,370
but no guarantees also some carriers

198
00:08:44,750 --> 00:08:49,070
will filter this they'll have for

199
00:08:46,370 --> 00:08:51,020
example firewalls on their network they

200
00:08:49,070 --> 00:08:52,310
prevent you from hitting the server but

201
00:08:51,020 --> 00:08:54,170
there was still lots of SIM cards I

202
00:08:52,310 --> 00:08:57,109
tried this with where that was not the

203
00:08:54,170 --> 00:08:59,360
case and finally your user has to have

204
00:08:57,110 --> 00:09:01,910
used email or voice mail exactly once

205
00:08:59,360 --> 00:09:06,080
they have to have recorded a greeting or

206
00:09:01,910 --> 00:09:09,800
else this doesn't work so I reviewed the

207
00:09:06,080 --> 00:09:12,830
IMAP server in Ida and I didn't find any

208
00:09:09,800 --> 00:09:15,829
bugs that way so I wrote a puzzler that

209
00:09:12,830 --> 00:09:18,620
generated malformed IMAP and then I had

210
00:09:15,830 --> 00:09:20,839
this SMS simulator that I'd written

211
00:09:18,620 --> 00:09:23,330
already so I was able to just make that

212
00:09:20,839 --> 00:09:24,770
ping my device over and over and over

213
00:09:23,330 --> 00:09:27,200
and then it would ping my IMAP server

214
00:09:24,770 --> 00:09:30,230
over and over and over and then get all

215
00:09:27,200 --> 00:09:32,540
the fuzz down input back and doing this

216
00:09:30,230 --> 00:09:36,560
I found one vulnerability

217
00:09:32,540 --> 00:09:40,439
I found this use after free in IMAP name

218
00:09:36,560 --> 00:09:43,949
space processing and the way this works

219
00:09:40,440 --> 00:09:46,680
is there's a command an IMAP called list

220
00:09:43,950 --> 00:09:48,960
and this will get the separator for the

221
00:09:46,680 --> 00:09:50,969
IMAP server which is typically a slash

222
00:09:48,960 --> 00:09:53,730
or a backslash but it could be anything

223
00:09:50,970 --> 00:09:55,770
and then it'll try and get the prefix

224
00:09:53,730 --> 00:09:58,380
which is sometimes necessary to access a

225
00:09:55,770 --> 00:10:00,900
path calling this command called

226
00:09:58,380 --> 00:10:02,520
namespace and what happens is it will

227
00:10:00,900 --> 00:10:04,260
call list and then it will cache this

228
00:10:02,520 --> 00:10:06,930
separator and then it will call

229
00:10:04,260 --> 00:10:09,300
namespace and if namespace fails it will

230
00:10:06,930 --> 00:10:11,520
free the separator in the connection but

231
00:10:09,300 --> 00:10:13,800
then it doesn't check the return value

232
00:10:11,520 --> 00:10:16,880
of this call so what ends up happening

233
00:10:13,800 --> 00:10:19,490
is that it will continue to use this

234
00:10:16,880 --> 00:10:23,760
cached value even though it's been freed

235
00:10:19,490 --> 00:10:25,680
so this is a use after free it lets you

236
00:10:23,760 --> 00:10:28,319
call a selector on a freedom nsobject

237
00:10:25,680 --> 00:10:30,630
but it was also kind of a limited info

238
00:10:28,320 --> 00:10:33,300
leak in that what the system actually

239
00:10:30,630 --> 00:10:35,580
does with this separator is it will save

240
00:10:33,300 --> 00:10:37,290
it for later and then when it tries to

241
00:10:35,580 --> 00:10:40,830
get a mailbox it will actually append it

242
00:10:37,290 --> 00:10:43,439
so sometimes when I use this bug I would

243
00:10:40,830 --> 00:10:45,780
get you know a pointer back or some data

244
00:10:43,440 --> 00:10:48,720
back but it was like super unreliable

245
00:10:45,780 --> 00:10:51,510
like I could get it to like three out of

246
00:10:48,720 --> 00:10:53,340
a thousand times tops and it would lock

247
00:10:51,510 --> 00:10:55,470
the process otherwise I would have to

248
00:10:53,340 --> 00:10:57,990
restart it so I never got this reliable

249
00:10:55,470 --> 00:11:00,540
enough to be able to do anything really

250
00:10:57,990 --> 00:11:03,210
useful with it but it did seem like an

251
00:11:00,540 --> 00:11:06,420
interesting bug so then I started

252
00:11:03,210 --> 00:11:09,390
looking at the email client um so what

253
00:11:06,420 --> 00:11:12,449
happened here is that looking at this

254
00:11:09,390 --> 00:11:15,180
IMAP server I did find some parts that

255
00:11:12,450 --> 00:11:17,190
were only accessible via email for

256
00:11:15,180 --> 00:11:20,459
example I'm a would only process certain

257
00:11:17,190 --> 00:11:21,990
mime types so I wondered if I could hit

258
00:11:20,460 --> 00:11:24,600
some of this code just by sending an

259
00:11:21,990 --> 00:11:27,630
email so I tested this with the native

260
00:11:24,600 --> 00:11:31,020
email client on the iPhone I'll admit I

261
00:11:27,630 --> 00:11:33,170
I'm not clear on how realistic this

262
00:11:31,020 --> 00:11:35,910
setup is there's kind of two concerns

263
00:11:33,170 --> 00:11:37,560
one is that email addresses or email

264
00:11:35,910 --> 00:11:39,750
providers sometimes use third-party

265
00:11:37,560 --> 00:11:42,540
clients and the other is that email

266
00:11:39,750 --> 00:11:43,980
providers sometimes filter content so I

267
00:11:42,540 --> 00:11:45,930
think it would be hard to come up with a

268
00:11:43,980 --> 00:11:47,730
universal bug in mail because you have

269
00:11:45,930 --> 00:11:50,729
to worry about every email provider or

270
00:11:47,730 --> 00:11:54,150
filtering it but I did my testing with

271
00:11:50,730 --> 00:11:57,600
Gmail set up on the Native Client and

272
00:11:54,150 --> 00:11:59,640
hey I found one bug that worked found

273
00:11:57,600 --> 00:12:02,330
this one by code review as well and it

274
00:11:59,640 --> 00:12:04,819
turned out to be fixed already

275
00:12:02,330 --> 00:12:06,870
basically it looked like it was

276
00:12:04,820 --> 00:12:09,930
exploitable but difficult to exploit in

277
00:12:06,870 --> 00:12:12,410
11.3 and by 12 the functionality had

278
00:12:09,930 --> 00:12:15,180
been removed so it wasn't there anymore

279
00:12:12,410 --> 00:12:18,560
and it is probably the strangest bug I

280
00:12:15,180 --> 00:12:22,050
have ever seen it was very very unusual

281
00:12:18,560 --> 00:12:24,900
so basically in email you have a mime

282
00:12:22,050 --> 00:12:27,540
type which is the type of the message so

283
00:12:24,900 --> 00:12:30,240
it's like your text or your HTML or your

284
00:12:27,540 --> 00:12:33,000
JPEG and the way it processes the mime

285
00:12:30,240 --> 00:12:35,910
type is that it will take the mime type

286
00:12:33,000 --> 00:12:40,230
as a string and append to code to it and

287
00:12:35,910 --> 00:12:42,540
then call that method and that works

288
00:12:40,230 --> 00:12:45,150
except there are other methods that

289
00:12:42,540 --> 00:12:47,040
start with the code so you could call

290
00:12:45,150 --> 00:12:49,709
all these other methods and some of them

291
00:12:47,040 --> 00:12:52,290
had different numbers of parameters or

292
00:12:49,710 --> 00:12:54,750
unexpected functionality or that sort of

293
00:12:52,290 --> 00:12:58,890
thing so once again this led to a crash

294
00:12:54,750 --> 00:13:00,029
in 11.3 but in 12 there were just few

295
00:12:58,890 --> 00:13:04,110
more functions that started with the

296
00:13:00,029 --> 00:13:08,130
code so it didn't quite work out so then

297
00:13:04,110 --> 00:13:12,420
I started looking at iMessage iMessage

298
00:13:08,130 --> 00:13:16,020
is the default messenger on the iPhone

299
00:13:12,420 --> 00:13:18,180
it can send messages to both Macs and

300
00:13:16,020 --> 00:13:22,199
iPhones and it's an encrypted

301
00:13:18,180 --> 00:13:23,849
peer-to-peer messaging format it has

302
00:13:22,200 --> 00:13:26,820
many many formatting features I

303
00:13:23,850 --> 00:13:29,070
mentioned extensions there's other

304
00:13:26,820 --> 00:13:31,980
things like you can send bold text that

305
00:13:29,070 --> 00:13:36,300
sort of thing and I worked with Samuel

306
00:13:31,980 --> 00:13:39,900
gross on this part of the project so um

307
00:13:36,300 --> 00:13:41,670
to start off Samuel gross wrote a Thai

308
00:13:39,900 --> 00:13:44,339
message sending an intercepting client

309
00:13:41,670 --> 00:13:47,610
it was pretty cool so basically it just

310
00:13:44,339 --> 00:13:50,250
used Frida to hook specifically the

311
00:13:47,610 --> 00:13:51,660
dictionary being encoded or decoded and

312
00:13:50,250 --> 00:13:54,630
then you could see the incoming outgoing

313
00:13:51,660 --> 00:13:57,000
messages and it works on a Mac or an

314
00:13:54,630 --> 00:13:58,770
iPhone and it's a little bit more work

315
00:13:57,000 --> 00:14:00,150
so I guess for sending you all we want

316
00:13:58,770 --> 00:14:02,160
to send from a Mac there's no good

317
00:14:00,150 --> 00:14:03,600
reason to send from an iPhone but

318
00:14:02,160 --> 00:14:06,329
sometimes you want to see the message

319
00:14:03,600 --> 00:14:07,830
received by the iPhone and that was a

320
00:14:06,329 --> 00:14:10,160
little bit of work to set up

321
00:14:07,830 --> 00:14:13,200
we ended up getting it working on both

322
00:14:10,160 --> 00:14:14,850
so this is what an iMessage looked like

323
00:14:13,200 --> 00:14:18,120
and you can see it has some interesting

324
00:14:14,850 --> 00:14:21,480
fields there's like the P equals and

325
00:14:18,120 --> 00:14:24,150
that's here sending it to there's the

326
00:14:21,480 --> 00:14:26,820
text which is hello blackhat a few other

327
00:14:24,150 --> 00:14:30,199
things the version here's what we think

328
00:14:26,820 --> 00:14:33,120
kind of the interesting fields were I

329
00:14:30,200 --> 00:14:35,160
mentioned the text and then there's this

330
00:14:33,120 --> 00:14:37,650
plug-in stuff so there's the balloon

331
00:14:35,160 --> 00:14:41,370
identifier which is kind of like a mime

332
00:14:37,650 --> 00:14:43,290
type for iMessage it'll say like oh this

333
00:14:41,370 --> 00:14:45,570
is a talking draft or this is

334
00:14:43,290 --> 00:14:50,010
handwriting or that sort of thing and

335
00:14:45,570 --> 00:14:51,990
then the BP is the plug-in data and that

336
00:14:50,010 --> 00:14:54,470
will use the data that's interpreted

337
00:14:51,990 --> 00:14:57,240
based on this balloon identifier and

338
00:14:54,470 --> 00:14:58,050
then there's kind of two more

339
00:14:57,240 --> 00:14:59,910
interesting ones there's the

340
00:14:58,050 --> 00:15:02,339
participants which is where it goes and

341
00:14:59,910 --> 00:15:04,260
then there's the attribution ish info

342
00:15:02,340 --> 00:15:07,590
and this is basically related to

343
00:15:04,260 --> 00:15:08,819
attachments where they're from so we

344
00:15:07,590 --> 00:15:10,980
started to look at iMessage

345
00:15:08,820 --> 00:15:14,550
serialization because we noticed that

346
00:15:10,980 --> 00:15:17,840
these two fields BP and API we're

347
00:15:14,550 --> 00:15:20,339
serialized using nskeyedarchiver

348
00:15:17,840 --> 00:15:22,440
serialization and basically this is a

349
00:15:20,340 --> 00:15:26,400
format which is a plist which is

350
00:15:22,440 --> 00:15:28,800
basically an XML format and in this XML

351
00:15:26,400 --> 00:15:31,050
format it contains classes and then it

352
00:15:28,800 --> 00:15:33,420
will call on the classes a method called

353
00:15:31,050 --> 00:15:36,839
init with coder to actually instantiate

354
00:15:33,420 --> 00:15:39,540
the class and there have been some past

355
00:15:36,840 --> 00:15:41,880
bugs in it with coders including a few

356
00:15:39,540 --> 00:15:45,000
that allowed local privilege escalation

357
00:15:41,880 --> 00:15:47,580
and found by Ian beer and here's an

358
00:15:45,000 --> 00:15:51,510
example of something serialized with

359
00:15:47,580 --> 00:15:56,580
nskeyedarchiver serialization starting

360
00:15:51,510 --> 00:15:58,200
on the left you can see that there's the

361
00:15:56,580 --> 00:16:00,750
class so this is an nsurl

362
00:15:58,200 --> 00:16:03,440
you can see the class hierarchy and what

363
00:16:00,750 --> 00:16:07,110
what'll happen is when this is decoded

364
00:16:03,440 --> 00:16:08,760
this object on the right will reference

365
00:16:07,110 --> 00:16:10,560
that class and then it'll calling it

366
00:16:08,760 --> 00:16:12,780
with coder and then in it with coder

367
00:16:10,560 --> 00:16:15,599
will decode these two fields the NS dot

368
00:16:12,780 --> 00:16:18,990
base and the ana start relative and then

369
00:16:15,600 --> 00:16:21,630
you can see the base is 6 which actually

370
00:16:18,990 --> 00:16:24,449
references this string now - encode see

371
00:16:21,630 --> 00:16:27,930
so this format will be - serialized into

372
00:16:24,449 --> 00:16:30,870
an nsurl object in that way so

373
00:16:27,930 --> 00:16:33,899
serialization has a few security

374
00:16:30,870 --> 00:16:36,899
features one of them is NS secure coding

375
00:16:33,899 --> 00:16:39,959
and this is basically two features one

376
00:16:36,899 --> 00:16:42,480
is it requires that when a class creates

377
00:16:39,959 --> 00:16:44,399
an init with coder they also have to

378
00:16:42,480 --> 00:16:46,860
create another method and this method

379
00:16:44,399 --> 00:16:49,110
cannot be inherited it has to be created

380
00:16:46,860 --> 00:16:50,490
directly and basically this just means

381
00:16:49,110 --> 00:16:52,230
that you cannot create an init with

382
00:16:50,490 --> 00:16:54,949
coder by mistake if you're a developer

383
00:16:52,230 --> 00:16:57,480
you have to have exposed it on purpose

384
00:16:54,949 --> 00:16:59,250
the other thing is that it requires a

385
00:16:57,480 --> 00:17:01,470
list of allowed classes to be provided

386
00:16:59,250 --> 00:17:03,300
when you're to serializing so if you're

387
00:17:01,470 --> 00:17:06,600
say to see realizing that URL you have

388
00:17:03,300 --> 00:17:09,688
to say I wanted to serialize a URL or I

389
00:17:06,599 --> 00:17:11,549
want to serialize a URL or a dictionary

390
00:17:09,689 --> 00:17:14,750
but you can't just leave it blank you

391
00:17:11,549 --> 00:17:16,799
have to limit it in some sort of way

392
00:17:14,750 --> 00:17:19,799
unfortunately this and I secure coding

393
00:17:16,799 --> 00:17:21,829
is not enabled by default in fact

394
00:17:19,799 --> 00:17:25,530
there's what I call safe and unsafe

395
00:17:21,829 --> 00:17:27,658
initialization methods for mesquita and

396
00:17:25,530 --> 00:17:29,940
archiver's and you can see there's the

397
00:17:27,659 --> 00:17:31,710
safe ones at the top and the unsafe ones

398
00:17:29,940 --> 00:17:35,700
at the bottom and there's especially

399
00:17:31,710 --> 00:17:37,799
this one I mean could anyone ever forget

400
00:17:35,700 --> 00:17:42,210
which one of these is safe and which one

401
00:17:37,799 --> 00:17:44,129
of these is unsafe so we thought that it

402
00:17:42,210 --> 00:17:48,110
might be a good idea to see if anyone

403
00:17:44,130 --> 00:17:50,429
accidentally did decoding insecurely

404
00:17:48,110 --> 00:17:54,270
there currently exists as I mentioned

405
00:17:50,429 --> 00:17:56,820
where serialization happens um there's

406
00:17:54,270 --> 00:18:00,960
this VP in in springboard which is the

407
00:17:56,820 --> 00:18:04,980
user user interface for the iPhone and

408
00:18:00,960 --> 00:18:07,289
this will basically first decode this BP

409
00:18:04,980 --> 00:18:09,409
and then if it's an extension it will

410
00:18:07,289 --> 00:18:12,510
also call this method preview text on it

411
00:18:09,409 --> 00:18:16,679
which in practice is only used if a link

412
00:18:12,510 --> 00:18:18,770
is being sent and mr. note in my opinion

413
00:18:16,679 --> 00:18:20,760
to kind of be the best attack surface

414
00:18:18,770 --> 00:18:22,830
because I had the largest array of

415
00:18:20,760 --> 00:18:24,990
classes it would decode and also I was a

416
00:18:22,830 --> 00:18:28,860
very high a privilege level it runs as

417
00:18:24,990 --> 00:18:30,750
mobile and it has no sandbox and then

418
00:18:28,860 --> 00:18:32,939
there's also mobile SMS which is the

419
00:18:30,750 --> 00:18:34,320
actual SMS app which also decodes this

420
00:18:32,940 --> 00:18:36,600
with one click

421
00:18:34,320 --> 00:18:39,000
and then there's ATI which is an IM

422
00:18:36,600 --> 00:18:42,750
agent and this one has kind of a smaller

423
00:18:39,000 --> 00:18:47,240
attack surface because it doesn't code

424
00:18:42,750 --> 00:18:49,470
as many classes so our first idea was

425
00:18:47,240 --> 00:18:51,630
let's find an insecure deserialization

426
00:18:49,470 --> 00:18:53,940
call and then let's create a WebKit

427
00:18:51,630 --> 00:18:55,590
instance and then exploitation will be

428
00:18:53,940 --> 00:18:57,300
solved because there's a lot of WebKit

429
00:18:55,590 --> 00:18:59,459
vulnerabilities and there's a lot of nil

430
00:18:57,300 --> 00:19:00,840
and exploitation methods and maybe we

431
00:18:59,460 --> 00:19:03,210
could get a next way to work this way

432
00:19:00,840 --> 00:19:04,679
and yeah we looked at springboard and we

433
00:19:03,210 --> 00:19:06,900
looked at Allium agent and yeah we did

434
00:19:04,680 --> 00:19:11,160
not find any insecure calls even though

435
00:19:06,900 --> 00:19:12,720
the API was a little bit confusing um so

436
00:19:11,160 --> 00:19:13,770
then we decided let's look at these

437
00:19:12,720 --> 00:19:16,590
extensions

438
00:19:13,770 --> 00:19:18,389
you know the requite a few of them and

439
00:19:16,590 --> 00:19:20,850
some of them looked new so it seemed

440
00:19:18,390 --> 00:19:22,620
like a good attack surface and we hope

441
00:19:20,850 --> 00:19:25,649
that maybe they would misuse it a see

442
00:19:22,620 --> 00:19:28,500
realized the object and I found this

443
00:19:25,650 --> 00:19:32,760
vulnerability which it's not a very good

444
00:19:28,500 --> 00:19:34,950
quality bug pretty much this extension

445
00:19:32,760 --> 00:19:37,110
would decode a byte array and it would

446
00:19:34,950 --> 00:19:39,180
also decode a length of the byte array

447
00:19:37,110 --> 00:19:40,409
and then it would read out of bounds and

448
00:19:39,180 --> 00:19:41,700
would trust the length of the byte array

449
00:19:40,410 --> 00:19:42,720
even though the byte array that's

450
00:19:41,700 --> 00:19:46,200
actually to serialize could have a

451
00:19:42,720 --> 00:19:48,000
different length so I don't think this

452
00:19:46,200 --> 00:19:49,080
is a very exploitive old bug but I

453
00:19:48,000 --> 00:19:50,610
thought it was kind of interesting in

454
00:19:49,080 --> 00:19:55,500
the first place that you could have a

455
00:19:50,610 --> 00:19:57,330
bug like this remotely so we looked even

456
00:19:55,500 --> 00:20:00,300
more one thing that we looked at a lot

457
00:19:57,330 --> 00:20:03,060
was this link presentation layer so the

458
00:20:00,300 --> 00:20:06,720
link presentation is if you send someone

459
00:20:03,060 --> 00:20:08,850
a link they'll get a preview of the link

460
00:20:06,720 --> 00:20:10,650
look at an image maybe a preview of the

461
00:20:08,850 --> 00:20:13,260
text I think this actually has fairly

462
00:20:10,650 --> 00:20:16,590
good design in that the person who sends

463
00:20:13,260 --> 00:20:19,140
the link takes all the risk it is loaded

464
00:20:16,590 --> 00:20:21,060
on their device process with WebKit on

465
00:20:19,140 --> 00:20:22,560
their device and then only the results

466
00:20:21,060 --> 00:20:25,740
the image the text is sent to the other

467
00:20:22,560 --> 00:20:28,139
device so we were hoping that maybe we

468
00:20:25,740 --> 00:20:30,570
could find a way to trick this to make

469
00:20:28,140 --> 00:20:32,550
it so that maybe the link gets loaded on

470
00:20:30,570 --> 00:20:33,659
the receiving device and then that's a

471
00:20:32,550 --> 00:20:36,720
WebKit instance that could be

472
00:20:33,660 --> 00:20:40,590
exploitable but we looked and looked and

473
00:20:36,720 --> 00:20:44,370
didn't find anything like this so then

474
00:20:40,590 --> 00:20:46,350
the other idea was to see if we could

475
00:20:44,370 --> 00:20:47,860
find a bug in the supported

476
00:20:46,350 --> 00:20:50,379
deserialization code

477
00:20:47,860 --> 00:20:53,439
so we went through all the available and

478
00:20:50,380 --> 00:20:56,049
it with code or implementations and and

479
00:20:53,440 --> 00:20:58,960
there were a lot so thinking about this

480
00:20:56,049 --> 00:21:01,750
BP field that gets decoded in

481
00:20:58,960 --> 00:21:03,429
springboard this is the list of a cloud

482
00:21:01,750 --> 00:21:05,320
classes I won't read them all but it's

483
00:21:03,429 --> 00:21:08,019
like nsdictionary and a string and a lot

484
00:21:05,320 --> 00:21:10,899
of other things they do have to support

485
00:21:08,019 --> 00:21:12,640
secure coding but most things that

486
00:21:10,899 --> 00:21:13,959
inherit from these classes do anyhow

487
00:21:12,640 --> 00:21:18,760
because they're meant for some type of

488
00:21:13,960 --> 00:21:21,130
use from a different process but what's

489
00:21:18,760 --> 00:21:24,519
also interesting is that the subclasses

490
00:21:21,130 --> 00:21:27,070
were allowed to and the subclasses come

491
00:21:24,519 --> 00:21:29,230
from every library that is loaded into

492
00:21:27,070 --> 00:21:31,870
springboard even if it's not like not

493
00:21:29,230 --> 00:21:33,639
intended for serialization every one of

494
00:21:31,870 --> 00:21:36,070
these class sub classes that allow

495
00:21:33,639 --> 00:21:38,379
serialization that gets loaded is

496
00:21:36,070 --> 00:21:40,480
allowed and this wasn't the entire idea

497
00:21:38,380 --> 00:21:42,820
of a shared cache it does actually have

498
00:21:40,480 --> 00:21:45,190
to be DL opened or explicitly imported

499
00:21:42,820 --> 00:21:50,439
but it was still quite a large attack

500
00:21:45,190 --> 00:21:52,510
surface so we look at these and I found

501
00:21:50,440 --> 00:21:56,080
this vulnerability which is also a

502
00:21:52,510 --> 00:21:59,019
little bit unusual the problem is that

503
00:21:56,080 --> 00:22:04,299
it allows a subclass of NS data that is

504
00:21:59,019 --> 00:22:06,789
file backed so that means that you load

505
00:22:04,299 --> 00:22:08,500
the NS data and then you have a file

506
00:22:06,789 --> 00:22:10,750
location and then when you use the NS

507
00:22:08,500 --> 00:22:14,730
data that file is the data in the NS

508
00:22:10,750 --> 00:22:16,899
data and this kind of had two problems

509
00:22:14,730 --> 00:22:18,639
one was that it trusted the

510
00:22:16,899 --> 00:22:20,649
serialization length even though the

511
00:22:18,639 --> 00:22:22,479
file could be shorter so let's say you

512
00:22:20,649 --> 00:22:24,428
had like a 10 by trial and you said it

513
00:22:22,480 --> 00:22:27,100
was 20 bytes long the rest of that would

514
00:22:24,429 --> 00:22:28,630
just be uninitialized memory but then

515
00:22:27,100 --> 00:22:31,029
there's another problem which turned out

516
00:22:28,630 --> 00:22:33,370
to be a bit more serious which is that

517
00:22:31,029 --> 00:22:34,630
that's supposed to be a local file but

518
00:22:33,370 --> 00:22:36,850
the check for that turned out to be

519
00:22:34,630 --> 00:22:39,580
faulty so you could fetch this from a

520
00:22:36,850 --> 00:22:41,860
URL which means this bug have a very

521
00:22:39,580 --> 00:22:46,389
interesting effect which is that you can

522
00:22:41,860 --> 00:22:48,519
retrieve a file from an iPhone remotely

523
00:22:46,389 --> 00:22:50,620
without any user interaction the way

524
00:22:48,519 --> 00:22:54,460
this works is that you create the NS

525
00:22:50,620 --> 00:22:57,070
data with the file and then you convert

526
00:22:54,460 --> 00:22:58,779
it to the NS URL and this is a very long

527
00:22:57,070 --> 00:23:00,820
process so I'm going to gloss over it a

528
00:22:58,779 --> 00:23:02,830
bit but basically there were enough

529
00:23:00,820 --> 00:23:04,000
objects could does she realize that so

530
00:23:02,830 --> 00:23:05,860
that you could encode it and you can

531
00:23:04,000 --> 00:23:08,320
make it a URL then you would use this

532
00:23:05,860 --> 00:23:10,030
bug again and visit the URL because

533
00:23:08,320 --> 00:23:13,060
you're allowed to visit a remote URL and

534
00:23:10,030 --> 00:23:15,940
then this would just send you whatever

535
00:23:13,060 --> 00:23:17,770
file for example the SMS database you

536
00:23:15,940 --> 00:23:21,810
were pointing to though it did have a

537
00:23:17,770 --> 00:23:24,340
size limitation about 40 kilobytes so

538
00:23:21,810 --> 00:23:26,350
we're thinking about this and this very

539
00:23:24,340 --> 00:23:31,000
interesting bug and then Samuel had this

540
00:23:26,350 --> 00:23:33,909
idea what happens if a class does not

541
00:23:31,000 --> 00:23:37,120
have an init with coder and you try to

542
00:23:33,910 --> 00:23:40,180
instantiate it and the answer weirdly is

543
00:23:37,120 --> 00:23:41,709
regular inheritance rules apply so let's

544
00:23:40,180 --> 00:23:43,600
say in it with code are calls in it with

545
00:23:41,710 --> 00:23:45,610
capacity and you're a subclass it will

546
00:23:43,600 --> 00:23:48,159
call the subclasses in it with capacity

547
00:23:45,610 --> 00:23:51,340
and so on for lots of different methods

548
00:23:48,160 --> 00:23:53,890
and there were a few inheritance checks

549
00:23:51,340 --> 00:23:55,209
so some instantiations they would say

550
00:23:53,890 --> 00:23:59,650
like oh this has to be inherited

551
00:23:55,210 --> 00:24:02,590
directly but not always so we found this

552
00:23:59,650 --> 00:24:05,380
vulnerability which is basically there's

553
00:24:02,590 --> 00:24:09,909
this class a PF array that had in it

554
00:24:05,380 --> 00:24:11,730
with objects count defined and this is

555
00:24:09,910 --> 00:24:14,170
called by array in it with coder but

556
00:24:11,730 --> 00:24:16,600
unfortunately this array class I'm

557
00:24:14,170 --> 00:24:18,160
assuming everything that's in it already

558
00:24:16,600 --> 00:24:19,780
has a reference because it doesn't keep

559
00:24:18,160 --> 00:24:22,630
a reference to things that are in the

560
00:24:19,780 --> 00:24:24,760
array so if you create this array and

561
00:24:22,630 --> 00:24:28,690
then you drop all the references to the

562
00:24:24,760 --> 00:24:31,750
objects in the array those objects just

563
00:24:28,690 --> 00:24:35,800
get freed so that's a very interesting

564
00:24:31,750 --> 00:24:38,620
bug but then you know it gets even more

565
00:24:35,800 --> 00:24:41,950
complicated than that so remember the P

566
00:24:38,620 --> 00:24:44,620
list I showed you where there is the

567
00:24:41,950 --> 00:24:48,870
numeric reference to the object the

568
00:24:44,620 --> 00:24:51,879
string what if there's a cycle what if

569
00:24:48,870 --> 00:24:54,070
you know an object points back to itself

570
00:24:51,880 --> 00:24:55,990
with the reference or what if the object

571
00:24:54,070 --> 00:24:58,210
goes through another few objects and

572
00:24:55,990 --> 00:25:02,620
then points back to itself and the

573
00:24:58,210 --> 00:25:04,570
answer is it gets complicated so how

574
00:25:02,620 --> 00:25:07,840
does the serialization actually work in

575
00:25:04,570 --> 00:25:09,780
this context well the start of let's say

576
00:25:07,840 --> 00:25:13,689
you're to serializing and s some class

577
00:25:09,780 --> 00:25:16,840
well it will allocate that some class

578
00:25:13,690 --> 00:25:18,580
then it will put that in a temporary

579
00:25:16,840 --> 00:25:20,980
dictionary which by the way doesn't have

580
00:25:18,580 --> 00:25:23,139
any references it's assuming that the

581
00:25:20,980 --> 00:25:24,610
fact that you decoded it means that you

582
00:25:23,140 --> 00:25:26,290
already ever or the fact that you

583
00:25:24,610 --> 00:25:28,659
allocated it means you already have a

584
00:25:26,290 --> 00:25:31,240
reference then it calls init with coder

585
00:25:28,660 --> 00:25:33,100
and that happens and then it will clear

586
00:25:31,240 --> 00:25:35,920
the template dictionary and put it in a

587
00:25:33,100 --> 00:25:38,980
permanent dictionary now what happens if

588
00:25:35,920 --> 00:25:41,140
you decode an object twice well now you

589
00:25:38,980 --> 00:25:44,580
have these checks and what this will do

590
00:25:41,140 --> 00:25:48,070
is it will pull it out at the dictionary

591
00:25:44,580 --> 00:25:49,689
then make a copy of it and then it'll

592
00:25:48,070 --> 00:25:51,970
also check the permanent dictionary and

593
00:25:49,690 --> 00:25:55,110
then go through the init with coder um

594
00:25:51,970 --> 00:25:57,730
so this has some interesting problems

595
00:25:55,110 --> 00:25:59,500
one is that the object can be used

596
00:25:57,730 --> 00:26:01,780
before the in it with coder is complete

597
00:25:59,500 --> 00:26:04,720
which isn't great that might violate

598
00:26:01,780 --> 00:26:08,080
some assumptions but there's this other

599
00:26:04,720 --> 00:26:09,850
problem which is if you look at it like

600
00:26:08,080 --> 00:26:11,919
in the documentation what an init

601
00:26:09,850 --> 00:26:13,870
function is supposed to do it is not

602
00:26:11,920 --> 00:26:16,840
guaranteed to return the object created

603
00:26:13,870 --> 00:26:19,179
by Alec it can actually free that object

604
00:26:16,840 --> 00:26:21,550
and return its own object if it wants

605
00:26:19,180 --> 00:26:23,860
and this temporary dictionary has no

606
00:26:21,550 --> 00:26:26,889
references so you could free the last

607
00:26:23,860 --> 00:26:29,820
reference in your in it and then use the

608
00:26:26,890 --> 00:26:32,490
thing from the temp dict and it would

609
00:26:29,820 --> 00:26:35,530
not have any references to it and

610
00:26:32,490 --> 00:26:37,420
actually never had found any bugs using

611
00:26:35,530 --> 00:26:38,740
the second problem but I just found it

612
00:26:37,420 --> 00:26:40,420
interesting because it's something that

613
00:26:38,740 --> 00:26:43,680
I think is like problematic with the

614
00:26:40,420 --> 00:26:46,870
design that you know could cause a bug

615
00:26:43,680 --> 00:26:52,480
but what all the bugs ended up being in

616
00:26:46,870 --> 00:26:53,889
is this cycle problem where the union

617
00:26:52,480 --> 00:26:57,780
with coder is not complete and

618
00:26:53,890 --> 00:27:00,400
unfortunately this vulnerability was not

619
00:26:57,780 --> 00:27:02,950
remediated properly in the fix so I have

620
00:27:00,400 --> 00:27:05,980
I removed the class but basically the

621
00:27:02,950 --> 00:27:08,290
idea was is there is a class that when

622
00:27:05,980 --> 00:27:11,860
you decode it it creates a singly lit

623
00:27:08,290 --> 00:27:14,470
list link of things and then it will

624
00:27:11,860 --> 00:27:17,709
based on that that list of things create

625
00:27:14,470 --> 00:27:19,330
a buffer and then it will put things

626
00:27:17,710 --> 00:27:22,420
from the linked list into the buffer and

627
00:27:19,330 --> 00:27:24,129
if you can cycle in this you can end up

628
00:27:22,420 --> 00:27:26,119
in a situation where the buffer is too

629
00:27:24,130 --> 00:27:29,089
small the linked list is

630
00:27:26,119 --> 00:27:30,889
calculated its length is calculated the

631
00:27:29,089 --> 00:27:33,289
buffer is allocated and it's actually

632
00:27:30,889 --> 00:27:35,448
not done completing that list so this

633
00:27:33,289 --> 00:27:37,999
ends up being and out of bounds read

634
00:27:35,449 --> 00:27:40,819
with you can call all the methods on and

635
00:27:37,999 --> 00:27:43,669
it's kind of an interesting bug and so

636
00:27:40,819 --> 00:27:45,678
this has a lot of stuff missing but this

637
00:27:43,669 --> 00:27:48,019
is mostly just if you've ever wondered

638
00:27:45,679 --> 00:27:51,859
you know how do i POC this stuff the

639
00:27:48,019 --> 00:27:54,439
answer is I look like a crazy person

640
00:27:51,859 --> 00:27:56,749
drawing these diagrams all day and it

641
00:27:54,439 --> 00:27:58,849
took about eight hours to make this

642
00:27:56,749 --> 00:28:01,719
diagram with the pointer bad into an

643
00:27:58,849 --> 00:28:05,839
actual object that caused a crash

644
00:28:01,719 --> 00:28:09,499
I'm sorry another bug like that involves

645
00:28:05,839 --> 00:28:10,489
cycles as well and this was in a

646
00:28:09,499 --> 00:28:13,519
dictionary called

647
00:28:10,489 --> 00:28:15,019
NS known key dictionary one and this is

648
00:28:13,519 --> 00:28:19,099
a dictionary where you have to declare

649
00:28:15,019 --> 00:28:21,459
the keys upfront and you'll get a lot of

650
00:28:19,099 --> 00:28:24,468
optimization in return for that and

651
00:28:21,459 --> 00:28:26,419
basically this you would provide an

652
00:28:24,469 --> 00:28:30,139
array of key data and you would also

653
00:28:26,419 --> 00:28:32,299
provide a length and the length would

654
00:28:30,139 --> 00:28:35,629
eventually be checked to be consistent

655
00:28:32,299 --> 00:28:37,609
with the key data but it didn't happen

656
00:28:35,629 --> 00:28:38,869
soon enough so you would have the length

657
00:28:37,609 --> 00:28:40,938
and yelling you would be decoding the

658
00:28:38,869 --> 00:28:44,149
key and then you could end up using this

659
00:28:40,939 --> 00:28:45,919
class before it was done and then that

660
00:28:44,149 --> 00:28:47,349
length won't be checked yet and this

661
00:28:45,919 --> 00:28:50,089
ended up being a memory corruption

662
00:28:47,349 --> 00:28:52,359
vulnerability where it would go out of

663
00:28:50,089 --> 00:28:56,178
bounds before it hit this length check

664
00:28:52,359 --> 00:28:59,448
so I was actually interesting so what

665
00:28:56,179 --> 00:29:01,399
this gene you might have would be why

666
00:28:59,449 --> 00:29:03,709
are there so many bugs in this

667
00:29:01,399 --> 00:29:07,218
nskeyedarchiver I think I showed you

668
00:29:03,709 --> 00:29:12,189
three but we reported about eight at

669
00:29:07,219 --> 00:29:14,809
this point and it seems to be one of the

670
00:29:12,189 --> 00:29:17,959
luckiest interfaces in the remote attack

671
00:29:14,809 --> 00:29:21,379
surface and here's why let's say you

672
00:29:17,959 --> 00:29:24,259
have a URL and you wanted to code a URL

673
00:29:21,379 --> 00:29:27,529
and one thing that's already surprising

674
00:29:24,259 --> 00:29:28,759
is the attack surface of that depends a

675
00:29:27,529 --> 00:29:30,499
lot on how you compile it

676
00:29:28,759 --> 00:29:32,419
it depends specifically on what

677
00:29:30,499 --> 00:29:34,639
frameworks you include while you're

678
00:29:32,419 --> 00:29:37,519
compiling it but let's say you do this

679
00:29:34,639 --> 00:29:39,649
with just one framework which is user

680
00:29:37,519 --> 00:29:43,370
notifications then what's your attacks

681
00:29:39,650 --> 00:29:45,800
surface well you have the nsurl and it

682
00:29:43,370 --> 00:29:48,830
with coder which makes sense and then

683
00:29:45,800 --> 00:29:51,290
let's say in your class you create a URL

684
00:29:48,830 --> 00:29:57,050
subclass then that in it with coder is

685
00:29:51,290 --> 00:29:59,899
in the attack surface too and then you

686
00:29:57,050 --> 00:30:01,909
have any subclass of URL which is in all

687
00:29:59,900 --> 00:30:04,250
the frameworks you included and I just

688
00:30:01,910 --> 00:30:07,370
included this one framework which is UN

689
00:30:04,250 --> 00:30:10,310
security scope URL but there's more

690
00:30:07,370 --> 00:30:12,919
attack surface so what does NS URL and

691
00:30:10,310 --> 00:30:17,090
it with coder look like this is kind of

692
00:30:12,920 --> 00:30:19,580
a pseudo code dramatization of this URL

693
00:30:17,090 --> 00:30:22,699
with a few things missing but what's

694
00:30:19,580 --> 00:30:25,879
important is one thing I will try to do

695
00:30:22,700 --> 00:30:27,200
is to code an NS data and if that's the

696
00:30:25,880 --> 00:30:29,150
case he will try and treat that like a

697
00:30:27,200 --> 00:30:31,100
bookmark and this is actually a whole

698
00:30:29,150 --> 00:30:33,530
second serialization format that it will

699
00:30:31,100 --> 00:30:38,030
try to the code which is a tack surface

700
00:30:33,530 --> 00:30:41,510
and alternately if that doesn't work out

701
00:30:38,030 --> 00:30:44,000
it will try and decode these strings and

702
00:30:41,510 --> 00:30:46,180
it'll decode the URL base and the URL

703
00:30:44,000 --> 00:30:50,270
relative and then create your NS URL

704
00:30:46,180 --> 00:30:51,950
which is interesting that means that now

705
00:30:50,270 --> 00:30:54,440
you have strings in the attack surface

706
00:30:51,950 --> 00:30:56,270
and now you have data in the attack

707
00:30:54,440 --> 00:30:58,220
surface so now you have all the

708
00:30:56,270 --> 00:31:00,200
subclasses of those included in your

709
00:30:58,220 --> 00:31:02,360
attack surface so you have this NS

710
00:31:00,200 --> 00:31:04,820
dispatch data and it's localized string

711
00:31:02,360 --> 00:31:06,770
I won't read them all out but everything

712
00:31:04,820 --> 00:31:08,570
in there's two default frameworks which

713
00:31:06,770 --> 00:31:10,370
are always included core foundation and

714
00:31:08,570 --> 00:31:12,740
foundation plus there's this user

715
00:31:10,370 --> 00:31:14,689
notifications and now we have a total of

716
00:31:12,740 --> 00:31:19,850
five and it with coder is also included

717
00:31:14,690 --> 00:31:22,610
here and then you got to continue all

718
00:31:19,850 --> 00:31:24,800
the way down and right so for example

719
00:31:22,610 --> 00:31:27,110
now you have this UN localized string

720
00:31:24,800 --> 00:31:29,000
and it with coder this one decodes an NS

721
00:31:27,110 --> 00:31:31,939
array so what are all the subclasses of

722
00:31:29,000 --> 00:31:33,950
the NS array and then this NS localized

723
00:31:31,940 --> 00:31:35,870
string decodes dictionary date and

724
00:31:33,950 --> 00:31:37,670
number well now you need to include all

725
00:31:35,870 --> 00:31:42,649
the subclasses of those in your attack

726
00:31:37,670 --> 00:31:48,170
surface so then there's this problem

727
00:31:42,650 --> 00:31:50,990
with the sub classing without the in it

728
00:31:48,170 --> 00:31:52,550
with coder so for example the string in

729
00:31:50,990 --> 00:31:53,149
it with coder will call init with string

730
00:31:52,550 --> 00:31:54,769
so

731
00:31:53,149 --> 00:31:57,589
now every subclass within a net with

732
00:31:54,769 --> 00:32:02,679
string is included and likewise with the

733
00:31:57,589 --> 00:32:04,969
NS data there's an it with fight so this

734
00:32:02,679 --> 00:32:06,529
increases the attack surface and keep in

735
00:32:04,969 --> 00:32:09,080
mind you also have to do this with like

736
00:32:06,529 --> 00:32:10,969
the NS array the NS dictionary and also

737
00:32:09,080 --> 00:32:13,549
any objects that get decoded when

738
00:32:10,969 --> 00:32:16,039
creating those and what's funny about

739
00:32:13,549 --> 00:32:20,210
this is if you're decoding a URL you

740
00:32:16,039 --> 00:32:23,289
probably just want a string right 99.9%

741
00:32:20,210 --> 00:32:27,379
of the time no one's actually using this

742
00:32:23,289 --> 00:32:30,049
and this gets even worse imagine adding

743
00:32:27,379 --> 00:32:32,689
a few extra aloud classes letting able

744
00:32:30,049 --> 00:32:34,580
to code an array of URLs or let's say

745
00:32:32,690 --> 00:32:36,859
you know you want to import a few more

746
00:32:34,580 --> 00:32:39,619
libraries or like dozens of libraries

747
00:32:36,859 --> 00:32:43,789
like springboard does and imagine being

748
00:32:39,619 --> 00:32:45,830
a developer trying to secure this my

749
00:32:43,789 --> 00:32:47,779
opinion is that securing a class in the

750
00:32:45,830 --> 00:32:50,599
face of nskeyedarchiver is an

751
00:32:47,779 --> 00:32:51,950
intractable problem there are just too

752
00:32:50,599 --> 00:32:54,678
many inter dependencies between

753
00:32:51,950 --> 00:32:56,869
unrelated components and it requires

754
00:32:54,679 --> 00:32:59,479
full knowledge of all other components

755
00:32:56,869 --> 00:33:00,709
which might be ok if you're asshole but

756
00:32:59,479 --> 00:33:03,019
if you're for example a third-party

757
00:33:00,710 --> 00:33:04,190
developer trying to do this how are you

758
00:33:03,019 --> 00:33:07,369
gonna know that you gotta worry about

759
00:33:04,190 --> 00:33:11,839
this being that you know you and scope

760
00:33:07,369 --> 00:33:13,549
URL it also means that small changes to

761
00:33:11,839 --> 00:33:17,539
low risk components have unexpected

762
00:33:13,549 --> 00:33:19,969
consequences my suspicion is that the

763
00:33:17,539 --> 00:33:21,799
majority of these bugs did not occur

764
00:33:19,969 --> 00:33:23,330
because someone wanted to add this to

765
00:33:21,799 --> 00:33:25,580
the attacks or sisters surface of

766
00:33:23,330 --> 00:33:27,349
iMessage they happen because someone

767
00:33:25,580 --> 00:33:28,789
added in it with coder to the calculator

768
00:33:27,349 --> 00:33:32,089
and then they wanted to add two numbers

769
00:33:28,789 --> 00:33:34,519
in springboard and someone imported this

770
00:33:32,089 --> 00:33:36,440
library and no one thought of the fact

771
00:33:34,519 --> 00:33:40,070
that these are going to combine in a

772
00:33:36,440 --> 00:33:42,919
weird way and cause bugs so this is a

773
00:33:40,070 --> 00:33:44,960
situation and where I think this design

774
00:33:42,919 --> 00:33:48,289
causes a lot of security with problems

775
00:33:44,960 --> 00:33:52,009
and it's very problematic um so now I'm

776
00:33:48,289 --> 00:33:57,589
going to show a few demos here umm the

777
00:33:52,009 --> 00:34:00,519
first one is of this bug that allows for

778
00:33:57,589 --> 00:34:02,479
remote files to be fetched and

779
00:34:00,519 --> 00:34:04,549
unfortunately this is very low

780
00:34:02,479 --> 00:34:06,560
production value this is me typing with

781
00:34:04,549 --> 00:34:09,500
one hand well I hold my

782
00:34:06,560 --> 00:34:14,000
with the other but you can see here I

783
00:34:09,500 --> 00:34:17,540
have a message and the message has an

784
00:34:14,000 --> 00:34:22,159
image in it and then I'm sending an

785
00:34:17,540 --> 00:34:23,570
iMessage and that's kind of how the tool

786
00:34:22,159 --> 00:34:26,690
works you just like run it on the

787
00:34:23,570 --> 00:34:30,350
command line and then gotta wait for

788
00:34:26,690 --> 00:34:31,970
this message to appear this is the one

789
00:34:30,350 --> 00:34:33,650
that's trying to get the SMS database

790
00:34:31,969 --> 00:34:35,689
it's a little bit slow because

791
00:34:33,650 --> 00:34:38,120
unfortunately the way that URL decoding

792
00:34:35,690 --> 00:34:39,950
ended up working you have to send a URL

793
00:34:38,120 --> 00:34:41,810
that's equal in size to the data you

794
00:34:39,949 --> 00:34:44,949
want to retrieve so these messages kind

795
00:34:41,810 --> 00:34:44,949
of arrive pretty slowly

796
00:35:01,370 --> 00:35:07,850
so um I prepared this second message so

797
00:35:05,570 --> 00:35:09,830
what happened is I pulled the location

798
00:35:07,850 --> 00:35:12,380
of that image out of the SMS database

799
00:35:09,830 --> 00:35:13,520
and I put in the location here so I

800
00:35:12,380 --> 00:35:15,170
didn't have to type with my left hand

801
00:35:13,520 --> 00:35:16,460
while holding the camera but in real

802
00:35:15,170 --> 00:35:19,340
life you would get that from the

803
00:35:16,460 --> 00:35:23,630
database and put it in the message and

804
00:35:19,340 --> 00:35:25,760
then I'm sending it again and then this

805
00:35:23,630 --> 00:35:30,710
is going to be the message that gets the

806
00:35:25,760 --> 00:35:32,860
image so once again gotta wait for it to

807
00:35:30,710 --> 00:35:32,860
arrive

808
00:35:35,970 --> 00:35:39,149
[Music]

809
00:35:43,850 --> 00:35:47,049
[Music]

810
00:35:59,970 --> 00:36:03,029
it's funny I totally know the message

811
00:36:01,590 --> 00:36:06,720
will arrive but every time I watch this

812
00:36:03,030 --> 00:36:09,390
video I still get a little nervous so

813
00:36:06,720 --> 00:36:12,750
you can see the JPEG header there and

814
00:36:09,390 --> 00:36:14,700
then I pulled the file off the server

815
00:36:12,750 --> 00:36:16,290
and unfortunately the encoding you get

816
00:36:14,700 --> 00:36:17,910
is kind of complicated and requires

817
00:36:16,290 --> 00:36:19,410
quite a bit of decoding so I just pull

818
00:36:17,910 --> 00:36:23,180
it off and then run this Python script

819
00:36:19,410 --> 00:36:23,180
to decoder to decode it

820
00:36:27,110 --> 00:36:40,800
and then look it's the same image I also

821
00:36:38,730 --> 00:36:42,450
have a second demo here which I have to

822
00:36:40,800 --> 00:36:47,240
confess we got working about two hours

823
00:36:42,450 --> 00:36:50,310
ago which is an example of an exploit

824
00:36:47,240 --> 00:36:53,129
this exploit uses an unfixed bug but

825
00:36:50,310 --> 00:36:54,990
there's nothing specific about it I

826
00:36:53,130 --> 00:36:58,380
think in particular that it would work

827
00:36:54,990 --> 00:37:01,350
with that pfoa issue I think it would

828
00:36:58,380 --> 00:37:04,620
work with the other out of bounds and

829
00:37:01,350 --> 00:37:07,799
memory corruption issues and right now

830
00:37:04,620 --> 00:37:11,190
this doesn't apply pestpac

831
00:37:07,800 --> 00:37:12,950
but we're working on it and so the way

832
00:37:11,190 --> 00:37:17,910
this works I'm saying you will Road it

833
00:37:12,950 --> 00:37:21,299
the idea is that you use I am agent as a

834
00:37:17,910 --> 00:37:24,120
crash Oracle to break a SLR so when you

835
00:37:21,300 --> 00:37:26,430
send a message via iMessage you get a

836
00:37:24,120 --> 00:37:28,130
confirmation back so the idea is if you

837
00:37:26,430 --> 00:37:30,629
lay out certain things in memory

838
00:37:28,130 --> 00:37:31,200
sometimes it will crash and sometimes it

839
00:37:30,630 --> 00:37:32,640
won't

840
00:37:31,200 --> 00:37:35,069
and based on like whether you hear back

841
00:37:32,640 --> 00:37:36,930
again you can basically infer things

842
00:37:35,070 --> 00:37:40,490
about how things are laid out in memory

843
00:37:36,930 --> 00:37:44,640
and this has to be I am agent because

844
00:37:40,490 --> 00:37:46,200
springboard is a very noisy crash or for

845
00:37:44,640 --> 00:37:48,420
a while it would actually freeze up the

846
00:37:46,200 --> 00:37:50,790
device if you crashed it enough but I am

847
00:37:48,420 --> 00:37:53,160
agent will restart consistently so that

848
00:37:50,790 --> 00:37:55,350
made it better and then so the first

849
00:37:53,160 --> 00:37:57,750
thing that happens is this but will

850
00:37:55,350 --> 00:38:00,980
break a SLR by using this Oracle and

851
00:37:57,750 --> 00:38:03,510
then basically it will use a heap spray

852
00:38:00,980 --> 00:38:06,800
to create this thing the fake

853
00:38:03,510 --> 00:38:09,570
objective-c object and then that will

854
00:38:06,800 --> 00:38:13,590
typically call selectors in objective-c

855
00:38:09,570 --> 00:38:15,240
so here we go and any

856
00:38:13,590 --> 00:38:19,110
Samuels demos have a way to enter

857
00:38:15,240 --> 00:38:22,410
production value than my demos so here

858
00:38:19,110 --> 00:38:24,360
is the version and here's showing that

859
00:38:22,410 --> 00:38:27,450
nothing's in contacts this is someone

860
00:38:24,360 --> 00:38:29,640
you have never messes before and then

861
00:38:27,450 --> 00:38:32,160
this demo shows incoming messages on

862
00:38:29,640 --> 00:38:33,690
purpose this isn't necessary but it's

863
00:38:32,160 --> 00:38:34,560
kind of a borrowing demo if you're just

864
00:38:33,690 --> 00:38:37,050
sitting here

865
00:38:34,560 --> 00:38:39,570
so you'll see messages coming in and

866
00:38:37,050 --> 00:38:44,730
those are the Oracle that's bypassing

867
00:38:39,570 --> 00:38:46,560
aslr and you can see type yeah

868
00:38:44,730 --> 00:38:51,000
I'm assuming that actual attackers

869
00:38:46,560 --> 00:38:52,799
wouldn't do that but maybe so this is

870
00:38:51,000 --> 00:38:54,720
also sped up in time so you can see the

871
00:38:52,800 --> 00:38:58,280
time at the top and this takes I think

872
00:38:54,720 --> 00:38:58,279
about six minutes total

873
00:39:06,280 --> 00:39:11,360
[Music]

874
00:39:17,700 --> 00:39:25,529
so there we go and now we're getting

875
00:39:19,740 --> 00:39:28,740
ready to pop calc and so basically what

876
00:39:25,530 --> 00:39:29,760
this is doing is that it's trying to lay

877
00:39:28,740 --> 00:39:31,140
out the heap and then it's actually

878
00:39:29,760 --> 00:39:33,569
checking and checking the notifications

879
00:39:31,140 --> 00:39:34,650
to make sure that things are actually in

880
00:39:33,569 --> 00:39:52,430
the right place before it hits the

881
00:39:34,650 --> 00:39:54,119
trigger yeah there's a cow so um

882
00:39:52,430 --> 00:39:57,210
unfortunately I think I could probably

883
00:39:54,119 --> 00:39:59,640
do a whole other talk about both of

884
00:39:57,210 --> 00:40:01,260
those a demos so I have included a lot

885
00:39:59,640 --> 00:40:03,390
of detail but we will be blogging about

886
00:40:01,260 --> 00:40:05,250
them sure at least so watch our project

887
00:40:03,390 --> 00:40:07,200
zero blog if you want to know the

888
00:40:05,250 --> 00:40:11,700
nitty-gritty of exactly how those two

889
00:40:07,200 --> 00:40:14,549
demos worked um so in conclusion fully

890
00:40:11,700 --> 00:40:16,230
remote iphone bugs do exist we found

891
00:40:14,549 --> 00:40:18,540
about ten of them so I think that at

892
00:40:16,230 --> 00:40:21,420
least puts the rest the question of are

893
00:40:18,540 --> 00:40:23,279
there really bugs like that the remote

894
00:40:21,420 --> 00:40:28,440
attack surface included a lot of things

895
00:40:23,280 --> 00:40:31,410
including SMS MMS bbm email and iMessage

896
00:40:28,440 --> 00:40:33,630
and we found bugs in V via email and

897
00:40:31,410 --> 00:40:35,640
iMessage so it's certainly not just an

898
00:40:33,630 --> 00:40:38,069
iMessage thing though the majority of

899
00:40:35,640 --> 00:40:40,049
the bugs were there um there were design

900
00:40:38,069 --> 00:40:44,009
problems with iMessage serialization

901
00:40:40,049 --> 00:40:46,170
that make it especially bro prone like

902
00:40:44,010 --> 00:40:50,540
surface I do want to say that this is

903
00:40:46,170 --> 00:40:52,440
also a fairly old old attack surface

904
00:40:50,540 --> 00:40:54,630
serialization was used for other things

905
00:40:52,440 --> 00:40:56,250
that weren't iMessage for a long time

906
00:40:54,630 --> 00:40:57,240
before iMessage so this is kind of a

907
00:40:56,250 --> 00:41:00,359
difficult problem

908
00:40:57,240 --> 00:41:03,569
how you cut stuff down but right now

909
00:41:00,359 --> 00:41:06,328
even with the NS secure coding there

910
00:41:03,569 --> 00:41:08,069
still is a lot of security problems and

911
00:41:06,329 --> 00:41:09,809
it's because of that exploding attack

912
00:41:08,069 --> 00:41:12,558
surface there's just no good way to

913
00:41:09,809 --> 00:41:14,760
evaluate or reduce the attack surface of

914
00:41:12,559 --> 00:41:16,770
something your deserializing

915
00:41:14,760 --> 00:41:21,150
even if you are just too serializing one

916
00:41:16,770 --> 00:41:23,220
string URL um there are methods for an

917
00:41:21,150 --> 00:41:25,020
attacker to send malformed messages and

918
00:41:23,220 --> 00:41:27,779
most formats and we actually released

919
00:41:25,020 --> 00:41:31,109
them today so if you take a look at this

920
00:41:27,780 --> 00:41:33,690
URL we have the I message sender

921
00:41:31,109 --> 00:41:35,970
there's the IMAP server and there's the

922
00:41:33,690 --> 00:41:38,730
SMS tools I'm hoping that people will

923
00:41:35,970 --> 00:41:40,259
use these to look more at iMessage and

924
00:41:38,730 --> 00:41:42,569
hopefully report some bugs that we

925
00:41:40,259 --> 00:41:44,700
didn't find in this project and I want

926
00:41:42,569 --> 00:41:46,230
to end off by just reiterating that this

927
00:41:44,700 --> 00:41:48,538
is an especially dangerous attack

928
00:41:46,230 --> 00:41:50,309
surface it doesn't require proximity to

929
00:41:48,539 --> 00:41:52,769
a user it doesn't require our network

930
00:41:50,309 --> 00:41:53,789
intercepts these are basically bugs that

931
00:41:52,769 --> 00:41:57,089
anyone can use

932
00:41:53,789 --> 00:41:58,170
I'm from anywhere to attack anyone and I

933
00:41:57,089 --> 00:42:00,299
think that makes them especially

934
00:41:58,170 --> 00:42:02,430
dangerous so it's important we do what

935
00:42:00,299 --> 00:42:04,470
we can to reduce the number of these

936
00:42:02,430 --> 00:42:08,210
bugs and make them less available to

937
00:42:04,470 --> 00:42:08,209
attackers thanks a lot

938
00:42:09,370 --> 00:42:13,290
[Applause]

