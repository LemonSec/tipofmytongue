1
00:00:00,030 --> 00:00:05,430
good morning you're in Jasmine and this

2
00:00:03,570 --> 00:00:07,529
session is denial-of-service with a

3
00:00:05,430 --> 00:00:09,629
fistful of packets exploiting

4
00:00:07,529 --> 00:00:12,990
algorithmic complexity vulnerabilities

5
00:00:09,630 --> 00:00:14,940
by Nathan Hockey and David Renard II but

6
00:00:12,990 --> 00:00:16,890
first we have a few announcements the

7
00:00:14,940 --> 00:00:19,350
black hat Arsenal is in the business

8
00:00:16,890 --> 00:00:22,500
hall in level two there's a mimosa event

9
00:00:19,350 --> 00:00:25,289
at 11:50 and an ice cream social at 3:20

10
00:00:22,500 --> 00:00:28,529
in the business hall lunch is in Bayside

11
00:00:25,289 --> 00:00:30,929
a B from 1:00 to 2:30 and don't forget

12
00:00:28,529 --> 00:00:33,360
the merchandise store on level two and

13
00:00:30,929 --> 00:00:36,930
session recordings from sock they have a

14
00:00:33,360 --> 00:00:39,000
desk on every level please silence your

15
00:00:36,930 --> 00:00:43,519
phones and without further delay please

16
00:00:39,000 --> 00:00:43,519
welcome Nathan hockey and Dave Bernardi

17
00:00:45,890 --> 00:00:49,079
thanks for that introduction good

18
00:00:47,969 --> 00:00:51,360
morning everybody thank you for coming

19
00:00:49,079 --> 00:00:53,370
my name is David Renard II joined by my

20
00:00:51,360 --> 00:00:54,870
colleague Nathan hockey and we're gonna

21
00:00:53,370 --> 00:00:56,640
talk to you guys today I got about

22
00:00:54,870 --> 00:00:58,559
algorithmic complexity vulnerabilities

23
00:00:56,640 --> 00:01:02,219
and how you too can cause denial service

24
00:00:58,559 --> 00:01:04,140
with only a fistful of packets so Nathan

25
00:01:02,219 --> 00:01:06,659
and I are both security researchers at a

26
00:01:04,140 --> 00:01:08,310
company called two six labs we work in

27
00:01:06,659 --> 00:01:10,260
vulnerability research cyber security

28
00:01:08,310 --> 00:01:11,700
and I know you guys are really here

29
00:01:10,260 --> 00:01:14,189
because Nathan's bio mentioned he's a

30
00:01:11,700 --> 00:01:15,630
broomball national champion but please

31
00:01:14,189 --> 00:01:19,110
hold any broomball related questions

32
00:01:15,630 --> 00:01:20,580
until after the talk okay so what are we

33
00:01:19,110 --> 00:01:22,619
gonna talk about today so I'm gonna

34
00:01:20,580 --> 00:01:24,000
start off with a recap of what

35
00:01:22,619 --> 00:01:25,950
algorithmic complexity vulnerabilities

36
00:01:24,000 --> 00:01:27,840
are how they present themselves some

37
00:01:25,950 --> 00:01:29,670
historical examples and then we're gonna

38
00:01:27,840 --> 00:01:31,259
launch into three new algorithmic

39
00:01:29,670 --> 00:01:33,659
complexity vulnerabilities that Nathan

40
00:01:31,259 --> 00:01:34,979
and I discovered over the past year and

41
00:01:33,659 --> 00:01:36,750
then we're gonna wrap up with some

42
00:01:34,979 --> 00:01:38,729
defense and mitigation techniques and

43
00:01:36,750 --> 00:01:39,960
we're going to introduce a ce soit which

44
00:01:38,729 --> 00:01:41,610
is an open source tool we help

45
00:01:39,960 --> 00:01:42,479
contribute to that we'll be presenting

46
00:01:41,610 --> 00:01:45,810
at Arsenal

47
00:01:42,479 --> 00:01:46,950
shortly after this okay

48
00:01:45,810 --> 00:01:49,200
so what's an algorithmic complexity

49
00:01:46,950 --> 00:01:51,149
vulnerability so we're talking about is

50
00:01:49,200 --> 00:01:53,820
a resource exhaustion attack resulting

51
00:01:51,149 --> 00:01:55,470
in denial of service the cause for this

52
00:01:53,820 --> 00:01:58,048
is you have some back-end algorithm

53
00:01:55,470 --> 00:01:59,520
that's processing some user input and it

54
00:01:58,049 --> 00:02:01,770
has unacceptable worst-case performance

55
00:01:59,520 --> 00:02:03,298
and that worst-case performance could

56
00:02:01,770 --> 00:02:05,820
mean a couple of things you could

57
00:02:03,299 --> 00:02:08,550
exhaust CPU resources which we call an

58
00:02:05,820 --> 00:02:11,370
AC time attack or you could exhaust some

59
00:02:08,550 --> 00:02:13,470
space resource either disk space or RAM

60
00:02:11,370 --> 00:02:15,840
which we call an AC space attack

61
00:02:13,470 --> 00:02:18,330
just to give you an idea this is kind of

62
00:02:15,840 --> 00:02:20,220
a toy example you could imagine some

63
00:02:18,330 --> 00:02:22,350
server somewhere they implement

64
00:02:20,220 --> 00:02:24,359
insertion sort on user submitted input

65
00:02:22,350 --> 00:02:26,489
and they might do this because they

66
00:02:24,360 --> 00:02:29,820
think our users are really nice and they

67
00:02:26,490 --> 00:02:31,590
usually submit sorted data and in the

68
00:02:29,820 --> 00:02:33,239
sorted case insertion sort takes a

69
00:02:31,590 --> 00:02:35,310
linear amount of time so it's relatively

70
00:02:33,240 --> 00:02:37,590
efficient they wouldn't be considering

71
00:02:35,310 --> 00:02:39,420
that an attacker might submit a reverse

72
00:02:37,590 --> 00:02:41,340
sorted list which would have quadratic

73
00:02:39,420 --> 00:02:43,380
time and could cause denial of service

74
00:02:41,340 --> 00:02:44,760
and this is kind of like a silly toy

75
00:02:43,380 --> 00:02:46,320
example there are way better sorting

76
00:02:44,760 --> 00:02:48,149
algorithms but this gives you the kind

77
00:02:46,320 --> 00:02:49,980
of idea of what Nathan and I were

78
00:02:48,150 --> 00:02:52,050
hunting so we're trying to find these

79
00:02:49,980 --> 00:02:53,609
corner case inputs that generate the

80
00:02:52,050 --> 00:02:55,830
worst case performance for some back-end

81
00:02:53,610 --> 00:02:57,210
algorithm and I'll note here that a lot

82
00:02:55,830 --> 00:02:59,700
of the ways that we typically use for

83
00:02:57,210 --> 00:03:03,680
exploring input space like fuzzing don't

84
00:02:59,700 --> 00:03:06,269
necessarily find these kinds of inputs

85
00:03:03,680 --> 00:03:07,560
so I want to give a little bit of

86
00:03:06,270 --> 00:03:09,330
motivation for why we're talking about

87
00:03:07,560 --> 00:03:10,710
this because I think algorithmic

88
00:03:09,330 --> 00:03:11,970
complexity vulnerabilities have been

89
00:03:10,710 --> 00:03:14,820
around as long as people have been

90
00:03:11,970 --> 00:03:16,140
implementing algorithms but we feel that

91
00:03:14,820 --> 00:03:18,840
there's kind of a gap and awareness

92
00:03:16,140 --> 00:03:20,940
that's affecting the community and it's

93
00:03:18,840 --> 00:03:23,040
it's sort of at all different stages so

94
00:03:20,940 --> 00:03:24,810
you have application designers who maybe

95
00:03:23,040 --> 00:03:26,280
aren't considering the risks of

96
00:03:24,810 --> 00:03:28,980
algorithmic complexity vulnerabilities

97
00:03:26,280 --> 00:03:31,320
when designing applications developers

98
00:03:28,980 --> 00:03:33,000
and pen testers not incorporating

99
00:03:31,320 --> 00:03:34,829
algorithmic complexity vulnerabilities

100
00:03:33,000 --> 00:03:37,050
like known vulnerabilities into their

101
00:03:34,830 --> 00:03:39,750
test Suites and then vulnerability

102
00:03:37,050 --> 00:03:42,600
researchers we've noticed this problem

103
00:03:39,750 --> 00:03:44,550
where vulnerabilities are discovered and

104
00:03:42,600 --> 00:03:47,190
because of the CVE cycle and sort of how

105
00:03:44,550 --> 00:03:49,440
vulnerabilities are talked about they're

106
00:03:47,190 --> 00:03:51,060
not tied to like new applications so we

107
00:03:49,440 --> 00:03:54,510
see the same vulnerabilities come up

108
00:03:51,060 --> 00:03:56,010
again and again and again and so Nathan

109
00:03:54,510 --> 00:03:58,320
and I come at this from a little bit of

110
00:03:56,010 --> 00:03:59,640
a unique perspective we spent the past

111
00:03:58,320 --> 00:04:02,700
three years working on this research

112
00:03:59,640 --> 00:04:04,470
program called DARPA stack and part of

113
00:04:02,700 --> 00:04:06,030
the point of that program was to hunt

114
00:04:04,470 --> 00:04:08,160
for algorithmic complexity

115
00:04:06,030 --> 00:04:10,019
vulnerabilities so DARPA would make

116
00:04:08,160 --> 00:04:12,030
these kind of challenge problems where

117
00:04:10,019 --> 00:04:14,100
they would give us a program and they'd

118
00:04:12,030 --> 00:04:16,709
asked very pointed questions is this

119
00:04:14,100 --> 00:04:19,589
question is this program vulnerable and

120
00:04:16,709 --> 00:04:21,750
what would you need to exploit it so we

121
00:04:19,589 --> 00:04:24,159
spent three years working on these toy

122
00:04:21,750 --> 00:04:26,530
programs and that

123
00:04:24,160 --> 00:04:28,510
program wrapped up earlier this year and

124
00:04:26,530 --> 00:04:31,809
we were curious you know how how hard is

125
00:04:28,510 --> 00:04:32,920
it to find these things in the wild just

126
00:04:31,810 --> 00:04:35,260
to make sure we're all on the same page

127
00:04:32,920 --> 00:04:36,790
here when you mentioned denial of

128
00:04:35,260 --> 00:04:39,219
service a lot of people initially think

129
00:04:36,790 --> 00:04:41,740
Oh DDoS like that's denial of service

130
00:04:39,220 --> 00:04:44,470
and I just want to contrast how AC

131
00:04:41,740 --> 00:04:45,880
vulnerabilities sort of work compared to

132
00:04:44,470 --> 00:04:48,160
distributed denial of service

133
00:04:45,880 --> 00:04:50,170
so in DDoS you have some botnet and

134
00:04:48,160 --> 00:04:51,490
basically you have a bunch of bots

135
00:04:50,170 --> 00:04:53,350
they're communicating with the server

136
00:04:51,490 --> 00:04:55,210
and you get denial of service because

137
00:04:53,350 --> 00:04:56,980
you have so many BOTS trying to connect

138
00:04:55,210 --> 00:04:58,989
so the effort that you're putting into

139
00:04:56,980 --> 00:05:00,250
this attack is sort of reflected on the

140
00:04:58,990 --> 00:05:03,040
server giving you the denial service

141
00:05:00,250 --> 00:05:05,560
effect and this is expensive you need

142
00:05:03,040 --> 00:05:08,800
you know a large botnet to do this in

143
00:05:05,560 --> 00:05:11,170
contrast an AC vulnerability typically

144
00:05:08,800 --> 00:05:13,750
is a relatively compact payload like a

145
00:05:11,170 --> 00:05:15,730
fistful of packets submitted by a single

146
00:05:13,750 --> 00:05:17,110
user and you get the same you know

147
00:05:15,730 --> 00:05:19,300
denial of service effect on the server

148
00:05:17,110 --> 00:05:22,840
so easy vulnerabilities are much cheaper

149
00:05:19,300 --> 00:05:25,570
than DDoS additionally they can be a

150
00:05:22,840 --> 00:05:27,489
little quieter than DDoS algorithmic

151
00:05:25,570 --> 00:05:29,320
complexity vulnerabilities are a design

152
00:05:27,490 --> 00:05:30,460
problem they come out of intended

153
00:05:29,320 --> 00:05:32,530
functionality right that's how the

154
00:05:30,460 --> 00:05:34,299
program was implemented so they don't

155
00:05:32,530 --> 00:05:36,010
present themselves the same way that

156
00:05:34,300 --> 00:05:37,540
other denial service effects present

157
00:05:36,010 --> 00:05:41,530
themselves you're not necessarily gonna

158
00:05:37,540 --> 00:05:44,440
get tons of error messages or excessive

159
00:05:41,530 --> 00:05:46,030
logging or unusual traffic it's a

160
00:05:44,440 --> 00:05:48,370
regular user interacting with your

161
00:05:46,030 --> 00:05:50,169
service and this can make some

162
00:05:48,370 --> 00:05:52,810
algorithmic complexity attacks kind of

163
00:05:50,169 --> 00:05:54,969
insidious you could have a payload that

164
00:05:52,810 --> 00:05:57,250
is designed to cause denial of service

165
00:05:54,970 --> 00:05:59,590
for two minutes or five minutes and then

166
00:05:57,250 --> 00:06:02,800
once the algorithm completes processing

167
00:05:59,590 --> 00:06:04,690
it the normal functionality resumes so

168
00:06:02,800 --> 00:06:07,120
we've seen even security researchers

169
00:06:04,690 --> 00:06:09,190
ignore symptoms of denial service or

170
00:06:07,120 --> 00:06:10,240
algorithmic complexity attacks and think

171
00:06:09,190 --> 00:06:11,800
that they're just some sort of anomaly

172
00:06:10,240 --> 00:06:15,820
right you just turn off the server turn

173
00:06:11,800 --> 00:06:17,380
it back on and everything is fine this

174
00:06:15,820 --> 00:06:19,270
isn't something new again this has been

175
00:06:17,380 --> 00:06:21,010
around for a long time I just want to

176
00:06:19,270 --> 00:06:22,570
highlight there's some talks in recent

177
00:06:21,010 --> 00:06:23,680
years that you maybe have seen that

178
00:06:22,570 --> 00:06:27,780
highlight algorithmic complexity

179
00:06:23,680 --> 00:06:31,180
vulnerabilities so in 2011 klinken valda

180
00:06:27,780 --> 00:06:32,799
discovered that a bunch of hash table

181
00:06:31,180 --> 00:06:34,720
implementations we're using linked lists

182
00:06:32,800 --> 00:06:35,410
to resolve hash collisions this is a bad

183
00:06:34,720 --> 00:06:37,320
idea

184
00:06:35,410 --> 00:06:39,780
because it's really easy to create

185
00:06:37,320 --> 00:06:41,670
collisions so you can basically submit a

186
00:06:39,780 --> 00:06:44,039
bunch of HTTP parameters for example

187
00:06:41,670 --> 00:06:47,940
that all collide and cause that linked

188
00:06:44,040 --> 00:06:49,710
list to grow more recently in 2016

189
00:06:47,940 --> 00:06:52,140
Cara Maria gave a talk here at blackhat

190
00:06:49,710 --> 00:06:54,390
about decompression bombs so a

191
00:06:52,140 --> 00:06:56,150
decompression bomb is a natural

192
00:06:54,390 --> 00:06:58,440
corollary to having very efficient

193
00:06:56,150 --> 00:06:59,760
decompression algorithms so if you have

194
00:06:58,440 --> 00:07:01,860
an efficient decompression algorithm

195
00:06:59,760 --> 00:07:03,659
then you're gonna have some small input

196
00:07:01,860 --> 00:07:07,620
that decompresses to some huge size

197
00:07:03,660 --> 00:07:09,330
causing like a space effect also in 2016

198
00:07:07,620 --> 00:07:11,280
Eric Davidson gave a talk about

199
00:07:09,330 --> 00:07:13,080
revisiting regular expression

200
00:07:11,280 --> 00:07:15,059
denial-of-service let's let's let's dig

201
00:07:13,080 --> 00:07:18,240
into redox real quick so to explain

202
00:07:15,060 --> 00:07:20,070
what's going on there so in redose you

203
00:07:18,240 --> 00:07:22,250
have some regular expression and you

204
00:07:20,070 --> 00:07:25,290
want to parse some candidate string and

205
00:07:22,250 --> 00:07:26,880
a typical way of representing your

206
00:07:25,290 --> 00:07:28,770
regular expression is through some

207
00:07:26,880 --> 00:07:30,990
finite automata so in this case we have

208
00:07:28,770 --> 00:07:33,599
an NFA that's generated by that regular

209
00:07:30,990 --> 00:07:36,290
expression in red and you'll notice that

210
00:07:33,600 --> 00:07:38,940
there's some ambiguity in that NFA so

211
00:07:36,290 --> 00:07:41,160
there are multiple outgoing arrows that

212
00:07:38,940 --> 00:07:43,380
represent the same character so when the

213
00:07:41,160 --> 00:07:46,260
Santa Fe parses that candidate string a

214
00:07:43,380 --> 00:07:48,990
AAA B it's going to pick some path

215
00:07:46,260 --> 00:07:51,330
through this NFA when it hits that B

216
00:07:48,990 --> 00:07:53,880
it's a non matching string and it's

217
00:07:51,330 --> 00:07:57,240
gonna say oh wait a minute I maybe took

218
00:07:53,880 --> 00:07:58,950
a bad path so it'll go back it will

219
00:07:57,240 --> 00:08:00,650
revisit all those potential paths and

220
00:07:58,950 --> 00:08:03,060
I'll end up traversing all 16 of them

221
00:08:00,650 --> 00:08:05,580
this could be a big problem if you have

222
00:08:03,060 --> 00:08:07,830
Moraes in that string and you can get

223
00:08:05,580 --> 00:08:09,840
denial-of-service that way and this has

224
00:08:07,830 --> 00:08:11,880
been known for like a decade at this

225
00:08:09,840 --> 00:08:15,840
point so you'd assume that we've got

226
00:08:11,880 --> 00:08:19,080
this pretty well handled not so much so

227
00:08:15,840 --> 00:08:20,789
in just one month ago CloudFlare went

228
00:08:19,080 --> 00:08:23,940
down on the East Coast for about half an

229
00:08:20,790 --> 00:08:26,580
hour because of a redose issue and then

230
00:08:23,940 --> 00:08:28,140
three years ago Stack Exchange went down

231
00:08:26,580 --> 00:08:30,030
because of this regular expression that

232
00:08:28,140 --> 00:08:32,340
tries to parse out white space from

233
00:08:30,030 --> 00:08:34,559
entries some of the various user figured

234
00:08:32,340 --> 00:08:36,990
this out and basically submitted a post

235
00:08:34,559 --> 00:08:38,218
to cause denial of service and in a

236
00:08:36,990 --> 00:08:39,210
minor miracle they were able to recover

237
00:08:38,219 --> 00:08:40,710
in half an hour

238
00:08:39,210 --> 00:08:43,400
without being able to Google the

239
00:08:40,710 --> 00:08:43,400
symptoms on Stack Overflow

240
00:08:43,669 --> 00:08:48,990
okay so I just want to give you guys a

241
00:08:46,470 --> 00:08:50,460
little bit of a like a some background

242
00:08:48,990 --> 00:08:54,330
in sort of how we were approaching some

243
00:08:50,460 --> 00:08:55,410
of these problems in stack so one thing

244
00:08:54,330 --> 00:08:57,510
that we were trying to do is we were

245
00:08:55,410 --> 00:08:59,370
trying to find common algorithmic

246
00:08:57,510 --> 00:09:01,500
complexity vulnerabilities for standard

247
00:08:59,370 --> 00:09:04,080
file formats so we were hunting for like

248
00:09:01,500 --> 00:09:06,990
decompression bombs etc and in doing so

249
00:09:04,080 --> 00:09:08,730
we started looking at PDFs you know file

250
00:09:06,990 --> 00:09:10,050
format that we all use and we ended up

251
00:09:08,730 --> 00:09:14,160
discovering something kind of

252
00:09:10,050 --> 00:09:16,740
interesting there which is a time attack

253
00:09:14,160 --> 00:09:18,750
against PDF parsers so imagine you're

254
00:09:16,740 --> 00:09:21,240
trying to parse the content of some PDF

255
00:09:18,750 --> 00:09:24,000
you're trying to extract the content we

256
00:09:21,240 --> 00:09:25,500
have a way of constructing PDFs where

257
00:09:24,000 --> 00:09:28,410
you get a time attack against that

258
00:09:25,500 --> 00:09:31,170
parser without going over a certain

259
00:09:28,410 --> 00:09:33,390
memory ceiling so this isn't quite a

260
00:09:31,170 --> 00:09:35,520
decompression bomb right the ID the name

261
00:09:33,390 --> 00:09:37,380
decompression bomb signifies this

262
00:09:35,520 --> 00:09:39,540
explosion of data so that's not what's

263
00:09:37,380 --> 00:09:41,550
happening here you have this time effect

264
00:09:39,540 --> 00:09:43,560
while using a sort of relatively small

265
00:09:41,550 --> 00:09:44,459
amount of data so bomb is maybe not the

266
00:09:43,560 --> 00:09:46,369
right word

267
00:09:44,460 --> 00:09:48,870
we decided napalm was more appropriate

268
00:09:46,370 --> 00:09:50,790
it's sort of this long burning fire

269
00:09:48,870 --> 00:09:54,300
right it's going to keep consuming that

270
00:09:50,790 --> 00:09:57,990
CPU resource without ever using the the

271
00:09:54,300 --> 00:10:00,089
memory or consuming too much memory so

272
00:09:57,990 --> 00:10:02,580
we approached this starting with a

273
00:10:00,090 --> 00:10:05,520
traditional decompression bomb so dgr

274
00:10:02,580 --> 00:10:08,070
Stevens wrote a blog post in 2008 about

275
00:10:05,520 --> 00:10:11,160
these PDF stream objects which are in

276
00:10:08,070 --> 00:10:12,450
the PDF specification and he noted that

277
00:10:11,160 --> 00:10:13,890
these can be used to construct a

278
00:10:12,450 --> 00:10:16,020
traditional decompression bomb within

279
00:10:13,890 --> 00:10:18,449
PDF basically how that works

280
00:10:16,020 --> 00:10:20,819
PDF stream objects are pretty simple you

281
00:10:18,450 --> 00:10:23,520
have some data in blue and then you have

282
00:10:20,820 --> 00:10:25,800
a set of filters in red that operate in

283
00:10:23,520 --> 00:10:27,420
sequence on that data so the output of

284
00:10:25,800 --> 00:10:29,849
your first filter goes into your second

285
00:10:27,420 --> 00:10:31,469
filter so on and so forth and when

286
00:10:29,850 --> 00:10:33,960
Stevens noted is that within the PDF

287
00:10:31,470 --> 00:10:36,060
spec one of the defined filters is flate

288
00:10:33,960 --> 00:10:38,190
decode fleet decode is a decompression

289
00:10:36,060 --> 00:10:42,000
algorithm it's companion for deflate

290
00:10:38,190 --> 00:10:43,560
which is used in PNG zip Jesus Tom and

291
00:10:42,000 --> 00:10:45,540
compression algorithm so it makes sense

292
00:10:43,560 --> 00:10:47,660
for them to have chosen to include this

293
00:10:45,540 --> 00:10:50,459
just for for decoding some random data

294
00:10:47,660 --> 00:10:52,260
but of course you have this efficient

295
00:10:50,460 --> 00:10:55,610
decompression algorithm now so you can

296
00:10:52,260 --> 00:10:57,380
make a decompression bomb moreover

297
00:10:55,610 --> 00:10:59,660
Stevens noted that because you can stack

298
00:10:57,380 --> 00:11:01,430
these filters one after another you can

299
00:10:59,660 --> 00:11:03,110
actually get like a nested decompression

300
00:11:01,430 --> 00:11:04,430
bomb because Slayton deflate or

301
00:11:03,110 --> 00:11:06,589
block-based so you actually end up

302
00:11:04,430 --> 00:11:09,349
getting a magnified effect if you

303
00:11:06,589 --> 00:11:13,310
compress a blow entropy input multiple

304
00:11:09,350 --> 00:11:15,649
times so we implemented this bomb in

305
00:11:13,310 --> 00:11:17,239
fact I think we're the first people to

306
00:11:15,649 --> 00:11:18,950
actually implement this bomb so he

307
00:11:17,240 --> 00:11:21,470
describes how this bomb would work in

308
00:11:18,950 --> 00:11:24,170
his blog post but we could not find a

309
00:11:21,470 --> 00:11:25,940
POC anywhere on the Internet which of

310
00:11:24,170 --> 00:11:28,510
course meant that every PDF parser that

311
00:11:25,940 --> 00:11:30,680
we looked at was vulnerable to this bomb

312
00:11:28,510 --> 00:11:33,170
but we noticed a couple of things what

313
00:11:30,680 --> 00:11:35,689
we were looking at it so the first is

314
00:11:33,170 --> 00:11:38,510
that when you do this decompression that

315
00:11:35,690 --> 00:11:39,860
that decompression causes a small time

316
00:11:38,510 --> 00:11:42,769
effect it's going to take a couple of

317
00:11:39,860 --> 00:11:44,600
seconds to decompress that data the

318
00:11:42,769 --> 00:11:46,459
other thing we noticed was that in the

319
00:11:44,600 --> 00:11:48,680
PDF spec you can put as many of these

320
00:11:46,459 --> 00:11:49,040
PDF stream objects into a single page as

321
00:11:48,680 --> 00:11:52,609
you'd like

322
00:11:49,040 --> 00:11:54,260
there's no constraints on how many PDF

323
00:11:52,610 --> 00:11:55,820
stream objects you can put there and in

324
00:11:54,260 --> 00:11:57,860
fact you can pass them by reference so

325
00:11:55,820 --> 00:11:59,300
you just like put a little pointer to

326
00:11:57,860 --> 00:12:02,750
where your PDF stream object is and

327
00:11:59,300 --> 00:12:06,229
it'll load another PDF stream object so

328
00:12:02,750 --> 00:12:07,699
our idea was maybe there's a way for us

329
00:12:06,230 --> 00:12:10,040
to put a bunch of kind of small

330
00:12:07,699 --> 00:12:12,800
decompression bombs into a single PDF

331
00:12:10,040 --> 00:12:15,230
have them loaded one after another and

332
00:12:12,800 --> 00:12:17,029
cause some sustained time effect right

333
00:12:15,230 --> 00:12:19,070
have have each one of those bombs take a

334
00:12:17,029 --> 00:12:21,079
little bit of time and then sort of have

335
00:12:19,070 --> 00:12:24,170
a bunch of them cumulatively cause a

336
00:12:21,079 --> 00:12:26,359
large time effect so how can we

337
00:12:24,170 --> 00:12:29,089
translate this AC space attack into an

338
00:12:26,360 --> 00:12:31,339
AC time attack there's a little bit of a

339
00:12:29,089 --> 00:12:34,339
problem here the problem is that when

340
00:12:31,339 --> 00:12:37,519
you're loading those those decompression

341
00:12:34,339 --> 00:12:39,019
bombs in a single page typically you're

342
00:12:37,519 --> 00:12:41,779
gonna you want to display the whole page

343
00:12:39,019 --> 00:12:44,089
right so if you're loading each

344
00:12:41,779 --> 00:12:45,709
compression bomb into a single page then

345
00:12:44,089 --> 00:12:47,779
eventually you're going to have a

346
00:12:45,709 --> 00:12:49,369
cumulative build-up of the the memory

347
00:12:47,779 --> 00:12:53,000
and eventually you're gonna run out of

348
00:12:49,370 --> 00:12:55,250
memory on that process so our idea was

349
00:12:53,000 --> 00:12:57,589
let's see if we can't find a way to free

350
00:12:55,250 --> 00:12:59,029
up that memory if we could somehow free

351
00:12:57,589 --> 00:13:00,860
up the memory used by each of those

352
00:12:59,029 --> 00:13:02,269
decompression bombs then we could have a

353
00:13:00,860 --> 00:13:04,220
graph kind of like the one displayed

354
00:13:02,269 --> 00:13:06,890
here where your

355
00:13:04,220 --> 00:13:10,130
deflating causing this or sorry your

356
00:13:06,890 --> 00:13:12,800
fleeting causing this this growth in the

357
00:13:10,130 --> 00:13:14,360
the memory but also a time effect but

358
00:13:12,800 --> 00:13:16,010
then you free up the memory and so in

359
00:13:14,360 --> 00:13:17,720
you're able to repeat this process over

360
00:13:16,010 --> 00:13:20,270
and over again and get a sustained time

361
00:13:17,720 --> 00:13:21,320
effect against the server so we're going

362
00:13:20,270 --> 00:13:24,170
to go back and we're going to look at

363
00:13:21,320 --> 00:13:27,350
more of the filters available in the PDF

364
00:13:24,170 --> 00:13:30,349
stream specification you might think

365
00:13:27,350 --> 00:13:32,120
like okay is there just like a deflate

366
00:13:30,350 --> 00:13:34,490
decode like an opposite where you can

367
00:13:32,120 --> 00:13:36,770
compress the the data back down and you

368
00:13:34,490 --> 00:13:38,690
can't there's no like inverse set of

369
00:13:36,770 --> 00:13:41,300
filters but there are some filters that

370
00:13:38,690 --> 00:13:42,650
will shrink the data that you give it so

371
00:13:41,300 --> 00:13:44,780
this is a pretty sensible filter it's

372
00:13:42,650 --> 00:13:46,910
called ascii hex decode and what it does

373
00:13:44,780 --> 00:13:48,920
is it takes pairs of valid hex

374
00:13:46,910 --> 00:13:51,140
characters and converts them into their

375
00:13:48,920 --> 00:13:53,630
ASCII equivalent so here I've got some

376
00:13:51,140 --> 00:13:57,800
ASCII or some hex characters converted

377
00:13:53,630 --> 00:14:00,710
to the word smoky and so our idea is we

378
00:13:57,800 --> 00:14:03,170
want to use fleet decode to grow some

379
00:14:00,710 --> 00:14:05,660
you know decompression bomb that's gonna

380
00:14:03,170 --> 00:14:07,130
take a lot of time but then if at the

381
00:14:05,660 --> 00:14:09,350
end of that process we run a bunch of

382
00:14:07,130 --> 00:14:11,990
ascii hex decode filters we can shrink

383
00:14:09,350 --> 00:14:13,460
the size of that stored data because

384
00:14:11,990 --> 00:14:15,320
each time you run ascii hex decode

385
00:14:13,460 --> 00:14:17,870
you're reducing the size of the data by

386
00:14:15,320 --> 00:14:20,810
a factor of two right two bytes give you

387
00:14:17,870 --> 00:14:24,050
one byte of output the problem with this

388
00:14:20,810 --> 00:14:26,510
is that you need valid hex characters to

389
00:14:24,050 --> 00:14:28,280
hand to ASCII hex key code right if you

390
00:14:26,510 --> 00:14:31,670
don't do that then the parser will throw

391
00:14:28,280 --> 00:14:33,199
an error so we're looking for some kind

392
00:14:31,670 --> 00:14:36,319
of like almost fixed point behavior

393
00:14:33,200 --> 00:14:38,510
where we pass it hex characters we run

394
00:14:36,320 --> 00:14:41,690
ascii hex decode decoded as ascii and

395
00:14:38,510 --> 00:14:43,460
get back valid hex characters this might

396
00:14:41,690 --> 00:14:45,800
seem like kind of a challenging problem

397
00:14:43,460 --> 00:14:47,750
it's like you know how do you sort of

398
00:14:45,800 --> 00:14:49,699
think through these cycles but it

399
00:14:47,750 --> 00:14:52,880
actually is pretty easy once you learn

400
00:14:49,700 --> 00:14:55,370
this one weird trick it turns out that

401
00:14:52,880 --> 00:14:57,560
in the ascii encoding through total

402
00:14:55,370 --> 00:15:01,339
coincidence the character 3 has hex

403
00:14:57,560 --> 00:15:03,469
encoding 3 3 which means if you start

404
00:15:01,339 --> 00:15:05,360
with a string of all fries you're on

405
00:15:03,470 --> 00:15:07,100
ascii hex decode on it you're going to

406
00:15:05,360 --> 00:15:09,110
get back a string of all threes again up

407
00:15:07,100 --> 00:15:11,839
half the length so if you start with a

408
00:15:09,110 --> 00:15:13,030
string let's say a wanker factor power

409
00:15:11,839 --> 00:15:14,770
of 2

410
00:15:13,030 --> 00:15:18,189
and you can eventually reduce the size

411
00:15:14,770 --> 00:15:20,140
to a single bite so this is what one of

412
00:15:18,190 --> 00:15:22,750
these little little fires looks like

413
00:15:20,140 --> 00:15:24,580
you've got your data and you've got a

414
00:15:22,750 --> 00:15:27,340
set of filters you're starting by using

415
00:15:24,580 --> 00:15:29,140
fleet decode to grow that decompression

416
00:15:27,340 --> 00:15:31,860
bomb and then you're running ascii hex

417
00:15:29,140 --> 00:15:34,270
decode to shrink the size of the data

418
00:15:31,860 --> 00:15:36,490
it's cut off here you can see there are

419
00:15:34,270 --> 00:15:38,020
six ascii hex key codes and the set of

420
00:15:36,490 --> 00:15:39,760
filters so that would reduce it by a

421
00:15:38,020 --> 00:15:41,020
factor of two to the six and you know if

422
00:15:39,760 --> 00:15:46,000
you add another one it'll keep reducing

423
00:15:41,020 --> 00:15:48,520
it so this gives us a recipe for

424
00:15:46,000 --> 00:15:50,170
creating PDF napalm so you start by

425
00:15:48,520 --> 00:15:52,000
guessing whatever the RAM limitations

426
00:15:50,170 --> 00:15:53,469
are of the system you're attacking and

427
00:15:52,000 --> 00:15:55,510
you don't have to have a type down just

428
00:15:53,470 --> 00:15:57,750
guess something reasonable you may be a

429
00:15:55,510 --> 00:16:01,050
gigabyte 500 Meg's something like that

430
00:15:57,750 --> 00:16:04,360
you then deflate a bunch of threes and

431
00:16:01,050 --> 00:16:06,219
then you encode that into a PDF stream

432
00:16:04,360 --> 00:16:08,350
object with Fleet decode filters to

433
00:16:06,220 --> 00:16:11,680
unpack it and then ascii hex decode

434
00:16:08,350 --> 00:16:13,570
filters to crush down the memory you

435
00:16:11,680 --> 00:16:15,550
then take those PDF stream objects and

436
00:16:13,570 --> 00:16:17,560
you fill a PDF page with references to

437
00:16:15,550 --> 00:16:19,000
that PDF stream object and that's going

438
00:16:17,560 --> 00:16:21,310
to give you that sort of sawtooth graph

439
00:16:19,000 --> 00:16:23,050
we saw earlier right it's going to take

440
00:16:21,310 --> 00:16:25,089
some time during those flight decodes

441
00:16:23,050 --> 00:16:26,380
and then in the ascii hex decodes it's

442
00:16:25,090 --> 00:16:29,320
going to free up all that memory that

443
00:16:26,380 --> 00:16:35,080
you're using so let's take a look at a

444
00:16:29,320 --> 00:16:38,680
demo here whoops okay so on the on your

445
00:16:35,080 --> 00:16:41,110
left we've got a simple java program

446
00:16:38,680 --> 00:16:44,349
this is written using high text which is

447
00:16:41,110 --> 00:16:46,270
a java PDF parsing library i'm not

448
00:16:44,350 --> 00:16:48,100
picking on eye text here again this is a

449
00:16:46,270 --> 00:16:51,069
problem in the PDF specification itself

450
00:16:48,100 --> 00:16:52,960
it's not a implementation bug and

451
00:16:51,070 --> 00:16:55,870
basically what we're doing here is we're

452
00:16:52,960 --> 00:16:58,030
just extracting the first page of this

453
00:16:55,870 --> 00:16:59,740
PDF and we're just trying to get the

454
00:16:58,030 --> 00:17:01,329
contents of that first page and I've got

455
00:16:59,740 --> 00:17:06,790
some timing information here that we're

456
00:17:01,330 --> 00:17:09,940
going to look at so so I don't script

457
00:17:06,790 --> 00:17:13,359
commands first we're going to run this

458
00:17:09,940 --> 00:17:14,890
program on basically the skeleton of a

459
00:17:13,359 --> 00:17:17,199
PDF this just has all the necessary

460
00:17:14,890 --> 00:17:19,510
headers that you'd want on a PDF if

461
00:17:17,200 --> 00:17:21,240
there's nothing in it okay it takes 16

462
00:17:19,510 --> 00:17:23,859
milliseconds so it's pretty fast

463
00:17:21,240 --> 00:17:25,900
let's take a look at DD R Stephens

464
00:17:23,859 --> 00:17:26,250
traditional decompression box so this is

465
00:17:25,900 --> 00:17:31,170
the

466
00:17:26,250 --> 00:17:33,720
effect okay it's going to take a few

467
00:17:31,170 --> 00:17:35,820
seconds here and you'll notice that this

468
00:17:33,720 --> 00:17:38,220
is a pretty small file okay so we

469
00:17:35,820 --> 00:17:42,000
eventually got an out of memory error so

470
00:17:38,220 --> 00:17:45,570
this file was only like 1,800 bytes

471
00:17:42,000 --> 00:17:48,840
they're pretty small and we were getting

472
00:17:45,570 --> 00:17:49,679
the JVM two gigs of PEEP space so this

473
00:17:48,840 --> 00:17:50,909
is really small

474
00:17:49,680 --> 00:17:53,250
I don't know if you guys mess around

475
00:17:50,910 --> 00:17:54,900
with PDFs at all but they're big like

476
00:17:53,250 --> 00:17:56,850
typically megabytes hundreds of

477
00:17:54,900 --> 00:17:59,460
kilobytes in size so you could easily

478
00:17:56,850 --> 00:18:01,709
hide this in an existing PDF and no one

479
00:17:59,460 --> 00:18:03,300
would notice from the size difference so

480
00:18:01,710 --> 00:18:06,600
that's your traditional decompression

481
00:18:03,300 --> 00:18:10,440
balm and now let's look at our bomb our

482
00:18:06,600 --> 00:18:13,709
napalm here okay so it's again

483
00:18:10,440 --> 00:18:15,420
relatively small under five K and as

484
00:18:13,710 --> 00:18:19,440
soon as this updates you'll see we've

485
00:18:15,420 --> 00:18:22,950
hit 100% CPU utilization this will stay

486
00:18:19,440 --> 00:18:24,930
at 100% for the next ten minutes and

487
00:18:22,950 --> 00:18:26,640
like I mentioned earlier these are

488
00:18:24,930 --> 00:18:29,040
configurable you could easily extend the

489
00:18:26,640 --> 00:18:37,160
effect at a small cost to the size of

490
00:18:29,040 --> 00:18:40,590
this bomb okay so what's the impact here

491
00:18:37,160 --> 00:18:42,150
so we looked at a bunch of spec

492
00:18:40,590 --> 00:18:43,439
compliant implementations and I want to

493
00:18:42,150 --> 00:18:45,270
I want to reiterate this this is a

494
00:18:43,440 --> 00:18:47,880
problem in the PDF specification itself

495
00:18:45,270 --> 00:18:49,230
right the PDF specification says you

496
00:18:47,880 --> 00:18:51,620
have these PF stream objects you have

497
00:18:49,230 --> 00:18:53,910
these filters you should respect them

498
00:18:51,620 --> 00:18:56,189
it's not that interesting

499
00:18:53,910 --> 00:18:58,470
- cause denial service to your local PDF

500
00:18:56,190 --> 00:19:00,000
you know Adobe Acrobat or something you

501
00:18:58,470 --> 00:19:01,860
just close it and go on with your day

502
00:19:00,000 --> 00:19:05,520
it's a bigger deal if you're trying to

503
00:19:01,860 --> 00:19:06,840
parse PDF server-side so why am i why

504
00:19:05,520 --> 00:19:09,270
might you do that why might you accept

505
00:19:06,840 --> 00:19:11,929
the PDF from a user we looked at a

506
00:19:09,270 --> 00:19:15,660
couple of different OCR applications so

507
00:19:11,930 --> 00:19:17,640
one use case is you have an accounting

508
00:19:15,660 --> 00:19:19,800
software and you want to allow your

509
00:19:17,640 --> 00:19:21,780
clients to submit receipts and you're

510
00:19:19,800 --> 00:19:23,430
going to use OCR to pull off line items

511
00:19:21,780 --> 00:19:25,560
from those receipts so we actually

512
00:19:23,430 --> 00:19:27,390
identified several applications that do

513
00:19:25,560 --> 00:19:31,710
this and they're all vulnerable to this

514
00:19:27,390 --> 00:19:33,390
attack so we contacted these vendors

515
00:19:31,710 --> 00:19:34,920
went through responsible disclosure and

516
00:19:33,390 --> 00:19:37,560
we came up with a handful of mitigation

517
00:19:34,920 --> 00:19:39,450
techniques so the first thing that you

518
00:19:37,560 --> 00:19:41,940
can do is DV

519
00:19:39,450 --> 00:19:44,100
from the PDF spec and Institute some

520
00:19:41,940 --> 00:19:45,809
input sanitization so specifically for

521
00:19:44,100 --> 00:19:49,590
our attack if you disallow repeated

522
00:19:45,809 --> 00:19:51,269
filters then you can't attack it

523
00:19:49,590 --> 00:19:53,699
you could also limit the number of PF

524
00:19:51,269 --> 00:19:55,260
stream objects in a given PDF page

525
00:19:53,700 --> 00:19:58,529
there's no reason to have a hundred or

526
00:19:55,260 --> 00:20:01,080
two hundred or a thousand but this might

527
00:19:58,529 --> 00:20:02,279
not cover all the potential ways you

528
00:20:01,080 --> 00:20:04,740
know that you can generate this kind of

529
00:20:02,279 --> 00:20:06,389
effect so really the safest thing to do

530
00:20:04,740 --> 00:20:07,980
is since too hard resource controls

531
00:20:06,389 --> 00:20:10,469
especially for some server-side

532
00:20:07,980 --> 00:20:12,179
application you don't want a PDF that

533
00:20:10,470 --> 00:20:13,919
takes you ten gigabytes of memory to

534
00:20:12,179 --> 00:20:16,080
load you also don't want a PDF that

535
00:20:13,919 --> 00:20:18,690
takes you ten minutes to load so if you

536
00:20:16,080 --> 00:20:20,309
just you know I set hard caps on runtime

537
00:20:18,690 --> 00:20:22,529
and memory then you can avoid some of

538
00:20:20,309 --> 00:20:23,879
these problems okay we're gonna see

539
00:20:22,529 --> 00:20:26,490
these themes sort of come up again and

540
00:20:23,880 --> 00:20:33,929
again in the other vulnerabilities which

541
00:20:26,490 --> 00:20:34,760
Nathan will talk about now thank you

542
00:20:33,929 --> 00:20:37,409
David

543
00:20:34,760 --> 00:20:39,529
the next vulnerability I have to share

544
00:20:37,409 --> 00:20:42,809
with you today is an unauthenticated

545
00:20:39,529 --> 00:20:46,380
vulnerability in open source Linux VNC

546
00:20:42,809 --> 00:20:47,668
servers and unlike the AC time effect

547
00:20:46,380 --> 00:20:50,720
which we just saw we're gonna be

548
00:20:47,669 --> 00:20:52,769
generating an AC space effect this time

549
00:20:50,720 --> 00:20:55,740
make sure we're talking about the same

550
00:20:52,769 --> 00:20:57,360
thing you know what is a VNC server all

551
00:20:55,740 --> 00:20:59,630
you need to know is you remotely access

552
00:20:57,360 --> 00:21:03,658
the computer get a graphical view and

553
00:20:59,630 --> 00:21:05,789
for Windows users it's like RDP a common

554
00:21:03,659 --> 00:21:09,360
use case would be if your system

555
00:21:05,789 --> 00:21:12,210
administrator and you want to access all

556
00:21:09,360 --> 00:21:13,649
of the computers in your network make

557
00:21:12,210 --> 00:21:17,460
changes from the comfort of your own

558
00:21:13,649 --> 00:21:20,459
desk so let me set the scene for you

559
00:21:17,460 --> 00:21:23,970
sitting at my desk and working on a

560
00:21:20,460 --> 00:21:26,340
project and my VM is out of memory this

561
00:21:23,970 --> 00:21:27,840
is weird it's you know 32 gigabyte hard

562
00:21:26,340 --> 00:21:31,439
drive and I'm not doing anything

563
00:21:27,840 --> 00:21:33,269
particularly memory intensive so I go

564
00:21:31,440 --> 00:21:35,970
and check it out and there's one file

565
00:21:33,269 --> 00:21:39,539
it's a VNC log file and it's 30

566
00:21:35,970 --> 00:21:42,330
gigabytes large like why is this file so

567
00:21:39,539 --> 00:21:47,129
large but one thing I could do is just

568
00:21:42,330 --> 00:21:48,389
delete it and get on with my work but I

569
00:21:47,130 --> 00:21:50,940
was thinking about algorithmic

570
00:21:48,389 --> 00:21:52,639
complexity vulnerabilities and looking

571
00:21:50,940 --> 00:21:55,990
at it and like this just didn't

572
00:21:52,640 --> 00:21:58,580
right so I took a look at the file and

573
00:21:55,990 --> 00:22:01,280
saw something like this near it near the

574
00:21:58,580 --> 00:22:04,030
top and you can see here that there are

575
00:22:01,280 --> 00:22:07,550
these lines printing other clients and

576
00:22:04,030 --> 00:22:10,010
each one has an additional IP address in

577
00:22:07,550 --> 00:22:12,290
it it said AHA this is an algorithmic

578
00:22:10,010 --> 00:22:16,660
complexity vulnerability I can make the

579
00:22:12,290 --> 00:22:20,170
space on this file grow quite large and

580
00:22:16,660 --> 00:22:22,640
the idea for this was to just add

581
00:22:20,170 --> 00:22:25,190
additional connections and make each of

582
00:22:22,640 --> 00:22:27,980
these lines longer and longer so to

583
00:22:25,190 --> 00:22:31,880
investigate this we went into the code

584
00:22:27,980 --> 00:22:34,010
and found this chunk found this because

585
00:22:31,880 --> 00:22:38,090
you can see the other clients line being

586
00:22:34,010 --> 00:22:39,560
logged here and this chunk of code is

587
00:22:38,090 --> 00:22:42,560
called every time there's a new

588
00:22:39,560 --> 00:22:44,120
connection to the VNC server and sure

589
00:22:42,560 --> 00:22:46,490
enough there's this for loop here which

590
00:22:44,120 --> 00:22:49,159
is printing the IP address of every

591
00:22:46,490 --> 00:22:51,170
connected client so there's no limit

592
00:22:49,160 --> 00:22:55,730
here it's not going to stop after 10 or

593
00:22:51,170 --> 00:22:58,100
20 there's no limit so pretty simple

594
00:22:55,730 --> 00:23:00,890
recipe for growing the disk space here

595
00:22:58,100 --> 00:23:03,560
we can create multiple TCP connections

596
00:23:00,890 --> 00:23:05,330
to the server we're gonna keep those

597
00:23:03,560 --> 00:23:07,220
connections open because if you allow

598
00:23:05,330 --> 00:23:08,899
one to close then the number of

599
00:23:07,220 --> 00:23:11,500
connected clients goes down and you

600
00:23:08,900 --> 00:23:13,370
don't get the same growth in the file

601
00:23:11,500 --> 00:23:15,650
but as long as you keep these

602
00:23:13,370 --> 00:23:18,560
connections open each one is gonna add a

603
00:23:15,650 --> 00:23:20,810
longer line to the log file and you

604
00:23:18,560 --> 00:23:24,139
might say you know each one's only 11 or

605
00:23:20,810 --> 00:23:25,429
12 bytes larger for the IP address but

606
00:23:24,140 --> 00:23:28,160
if you do this enough times you're

607
00:23:25,430 --> 00:23:32,270
getting a quadratic effect given the

608
00:23:28,160 --> 00:23:36,020
number of connections so let's take a

609
00:23:32,270 --> 00:23:39,139
look at how this works to get you

610
00:23:36,020 --> 00:23:41,540
oriented on the left side you've got a

611
00:23:39,140 --> 00:23:44,750
black screen that's showing the log file

612
00:23:41,540 --> 00:23:46,399
for a VNC server that I've got up the

613
00:23:44,750 --> 00:23:48,770
red is showing the current size of the

614
00:23:46,400 --> 00:23:52,160
server in bytes and we've got the CPU

615
00:23:48,770 --> 00:23:53,690
showing in the bottom right so first

616
00:23:52,160 --> 00:23:58,790
thing I'm gonna do is just connect to

617
00:23:53,690 --> 00:24:02,540
this VNC server and notice I have to

618
00:23:58,790 --> 00:24:05,750
input a password here but once I do that

619
00:24:02,540 --> 00:24:06,290
I can connect to this VNC server and you

620
00:24:05,750 --> 00:24:09,820
should see

621
00:24:06,290 --> 00:24:12,500
some vlogs showing up here on the bottom

622
00:24:09,820 --> 00:24:15,620
so now what I'm gonna do is make some

623
00:24:12,500 --> 00:24:18,200
netcat connections to this so 20 times

624
00:24:15,620 --> 00:24:20,419
I'm just gonna connect to localhost in

625
00:24:18,200 --> 00:24:22,880
5901 which is where this is running and

626
00:24:20,420 --> 00:24:26,480
sleep a second so that you can see

627
00:24:22,880 --> 00:24:28,060
what's happening on the logs so very

628
00:24:26,480 --> 00:24:30,530
similar effect to what we saw before

629
00:24:28,060 --> 00:24:34,159
these other client lines getting longer

630
00:24:30,530 --> 00:24:37,639
and longer we've already got you know 7k

631
00:24:34,160 --> 00:24:38,960
and growing of input so once this

632
00:24:37,640 --> 00:24:42,050
finishes though you know that was only

633
00:24:38,960 --> 00:24:45,710
20 let's do this many more times and see

634
00:24:42,050 --> 00:24:47,990
how large we can make this file so I'm

635
00:24:45,710 --> 00:24:49,580
gonna remove the statement the law sleep

636
00:24:47,990 --> 00:24:57,830
statements are not here all day and do

637
00:24:49,580 --> 00:24:59,210
this 800 times you can see as as we saw

638
00:24:57,830 --> 00:25:01,669
from the code that there's no limit on

639
00:24:59,210 --> 00:25:03,530
this just each time it's printing a

640
00:25:01,670 --> 00:25:06,440
whole bunch of IP addresses in a big

641
00:25:03,530 --> 00:25:12,320
block and we're now up near 4 megabytes

642
00:25:06,440 --> 00:25:15,560
of input the logical question next would

643
00:25:12,320 --> 00:25:18,649
be you know can I do this 8,000 times

644
00:25:15,560 --> 00:25:23,120
and you would think maybe you can but in

645
00:25:18,650 --> 00:25:24,890
fact you can't the reason for that is a

646
00:25:23,120 --> 00:25:27,139
kind of bonus vulnerability that we

647
00:25:24,890 --> 00:25:29,510
found when looking at this and this

648
00:25:27,140 --> 00:25:32,810
one's not really an AC vulnerability

649
00:25:29,510 --> 00:25:35,180
it's it causes a similar AC effect but

650
00:25:32,810 --> 00:25:38,300
this one's more of a bug but it causes

651
00:25:35,180 --> 00:25:42,380
infinite logging and denial of service

652
00:25:38,300 --> 00:25:44,750
to the VNC server so here's some

653
00:25:42,380 --> 00:25:47,510
definitely not vulnerable code that's

654
00:25:44,750 --> 00:25:50,570
getting called each time you have a new

655
00:25:47,510 --> 00:25:52,070
connection to the VNC server and some

656
00:25:50,570 --> 00:25:55,490
things to highlight here are that

657
00:25:52,070 --> 00:25:58,370
there's this sock it's the accept call

658
00:25:55,490 --> 00:26:00,740
is returning a file descriptor and if

659
00:25:58,370 --> 00:26:03,169
this were for some reason to fail you

660
00:26:00,740 --> 00:26:06,920
would print a logging message to the log

661
00:26:03,170 --> 00:26:09,590
file so I said it's not vulnerable but

662
00:26:06,920 --> 00:26:12,050
but maybe it is so what happens if we

663
00:26:09,590 --> 00:26:13,730
run out of these file descriptors as

664
00:26:12,050 --> 00:26:16,159
we're giving one out every time there's

665
00:26:13,730 --> 00:26:18,980
a new connection well the answer for

666
00:26:16,160 --> 00:26:19,950
except if you look in the man pages so

667
00:26:18,980 --> 00:26:23,549
I'll give you an

668
00:26:19,950 --> 00:26:25,139
file error now if you get an e/m file

669
00:26:23,549 --> 00:26:28,110
error we were just returning from that

670
00:26:25,139 --> 00:26:29,789
function but there's still this new

671
00:26:28,110 --> 00:26:30,719
connection out there that needs to be

672
00:26:29,789 --> 00:26:31,980
processed

673
00:26:30,720 --> 00:26:36,029
we haven't fulfilled that requirement

674
00:26:31,980 --> 00:26:37,620
yet and if you have a new connection

675
00:26:36,029 --> 00:26:39,590
waiting to be processed well what do you

676
00:26:37,620 --> 00:26:41,518
do well you call that same chunk of code

677
00:26:39,590 --> 00:26:43,379
so it's like hey there's a new

678
00:26:41,519 --> 00:26:45,840
connection and then like you realize oh

679
00:26:43,380 --> 00:26:47,610
no there's too many open files but like

680
00:26:45,840 --> 00:26:49,649
hey there's a new connection I need to

681
00:26:47,610 --> 00:26:50,610
process that's still out there and so on

682
00:26:49,649 --> 00:26:55,350
and so on

683
00:26:50,610 --> 00:26:57,658
this doesn't really stop so the recipe

684
00:26:55,350 --> 00:27:00,330
for exploiting this disk space and time

685
00:26:57,659 --> 00:27:02,700
is the same steps as before we're gonna

686
00:27:00,330 --> 00:27:05,490
create the two connections you know the

687
00:27:02,700 --> 00:27:06,899
TCP connections keep them open we're

688
00:27:05,490 --> 00:27:09,600
gonna repeat this until we're out of

689
00:27:06,899 --> 00:27:13,260
file descriptors and for our testing

690
00:27:09,600 --> 00:27:15,029
that was around 1024 if you're you limit

691
00:27:13,260 --> 00:27:17,070
is higher than that for some reason you

692
00:27:15,029 --> 00:27:19,529
actually hit a different error condition

693
00:27:17,070 --> 00:27:22,500
that we're not going to talk about but

694
00:27:19,529 --> 00:27:25,200
assuming assuming 1024 your next

695
00:27:22,500 --> 00:27:27,750
connection attempt triggers an infinite

696
00:27:25,200 --> 00:27:29,580
loop that I was talking about and I want

697
00:27:27,750 --> 00:27:31,590
to highlight here that this isn't like

698
00:27:29,580 --> 00:27:34,379
the previous case where we were sending

699
00:27:31,590 --> 00:27:36,779
one connection and getting one line to

700
00:27:34,380 --> 00:27:38,850
the log file it's one connection and

701
00:27:36,779 --> 00:27:40,799
getting infinitely many lines to this

702
00:27:38,850 --> 00:27:45,379
log file or at least until you're out of

703
00:27:40,799 --> 00:27:49,830
disk space now let's go back to our demo

704
00:27:45,380 --> 00:27:52,649
we've sent about 800 connections I'm

705
00:27:49,830 --> 00:27:58,830
gonna send 250 more just to get us over

706
00:27:52,649 --> 00:28:02,219
that 1024 limit and we were at you know

707
00:27:58,830 --> 00:28:05,220
4 megabytes we should see here there

708
00:28:02,220 --> 00:28:07,529
there you go this infinite logging of as

709
00:28:05,220 --> 00:28:10,260
fast as it can printing out these log

710
00:28:07,529 --> 00:28:12,919
messages the CPU is now up near a

711
00:28:10,260 --> 00:28:17,789
hundred percent over a hundred percent

712
00:28:12,919 --> 00:28:19,799
and we're growing this log file at you

713
00:28:17,789 --> 00:28:21,899
know a megabyte every few seconds sort

714
00:28:19,799 --> 00:28:25,440
of as fast as this computer can can

715
00:28:21,899 --> 00:28:30,449
process them and if we go back to our

716
00:28:25,440 --> 00:28:32,549
VNC server and try to connect we'll

717
00:28:30,450 --> 00:28:33,790
confirm that we have indeed achieve

718
00:28:32,549 --> 00:28:36,220
denial of service

719
00:28:33,790 --> 00:28:43,720
there's you can't get additional

720
00:28:36,220 --> 00:28:45,610
connections to this VNC server so what

721
00:28:43,720 --> 00:28:47,920
are the impacts if you were watching

722
00:28:45,610 --> 00:28:49,810
really closely you might have noticed

723
00:28:47,920 --> 00:28:51,700
that these log files that were printing

724
00:28:49,810 --> 00:28:54,070
out we're not the ones that were shown

725
00:28:51,700 --> 00:28:57,580
in in the code there and that's because

726
00:28:54,070 --> 00:29:00,399
I was showing you a demo from tight VNC

727
00:28:57,580 --> 00:29:02,889
but code from turbo VNC and what we

728
00:29:00,400 --> 00:29:04,840
found was that there the VNC servers

729
00:29:02,890 --> 00:29:07,150
kind of legacy servers that are out

730
00:29:04,840 --> 00:29:09,010
there all played some giant game of

731
00:29:07,150 --> 00:29:12,670
telephone somewhere down the line and

732
00:29:09,010 --> 00:29:15,940
shared these chunks of code with each

733
00:29:12,670 --> 00:29:18,040
other and so this vulnerability persists

734
00:29:15,940 --> 00:29:21,160
across multiple VNC servers that we

735
00:29:18,040 --> 00:29:23,080
looked at another thing I want to

736
00:29:21,160 --> 00:29:25,780
highlight is that you know we saw that

737
00:29:23,080 --> 00:29:27,820
my VNC server had a password and I never

738
00:29:25,780 --> 00:29:30,070
needed that any kind of credentials for

739
00:29:27,820 --> 00:29:32,530
this VNC server just the ability to

740
00:29:30,070 --> 00:29:35,560
connect to it so I was sending you know

741
00:29:32,530 --> 00:29:38,980
a thousand you know a handful of fistful

742
00:29:35,560 --> 00:29:43,030
of three-way handshakes and achieving

743
00:29:38,980 --> 00:29:44,770
denial of service so we went through the

744
00:29:43,030 --> 00:29:47,620
responsible disclosure process with

745
00:29:44,770 --> 00:29:51,430
these VNC servers and some of the

746
00:29:47,620 --> 00:29:53,830
solutions we came up with were first an

747
00:29:51,430 --> 00:29:57,160
algorithmic change so just not logging

748
00:29:53,830 --> 00:29:59,409
the list of other clients and the reason

749
00:29:57,160 --> 00:30:01,390
for this was that we had enough

750
00:29:59,410 --> 00:30:03,760
information from other things in the log

751
00:30:01,390 --> 00:30:05,250
you know when clients were connecting

752
00:30:03,760 --> 00:30:07,810
and when they were disconnecting to

753
00:30:05,250 --> 00:30:09,340
recreate this list of other clients if

754
00:30:07,810 --> 00:30:12,610
we ever really needed it without

755
00:30:09,340 --> 00:30:15,879
printing out 800 IP addresses at one

756
00:30:12,610 --> 00:30:19,030
time the other thing you can do is an

757
00:30:15,880 --> 00:30:20,950
input sanitization effort limiting the

758
00:30:19,030 --> 00:30:22,930
maximum number of client connections

759
00:30:20,950 --> 00:30:25,270
that are allowed to your VNC server at

760
00:30:22,930 --> 00:30:27,820
one time so you probably don't need a

761
00:30:25,270 --> 00:30:32,920
thousand people accessing the VNC server

762
00:30:27,820 --> 00:30:34,899
at the same time so let's jump ahead now

763
00:30:32,920 --> 00:30:36,220
to the final vulnerability we're going

764
00:30:34,900 --> 00:30:38,730
to talk about and this is an

765
00:30:36,220 --> 00:30:41,890
unauthenticated denial of service in

766
00:30:38,730 --> 00:30:43,450
Dropbox is password strength estimation

767
00:30:41,890 --> 00:30:45,340
tool called Xia cvbl

768
00:30:43,450 --> 00:30:45,710
it's the bottom six letters on the

769
00:30:45,340 --> 00:30:47,470
keyboard

770
00:30:45,710 --> 00:30:50,379
[Music]

771
00:30:47,470 --> 00:30:52,330
so what is this tool it's designed to

772
00:30:50,379 --> 00:30:54,969
replace some of the archaic password

773
00:30:52,330 --> 00:30:56,620
policies that we use now that are like

774
00:30:54,970 --> 00:30:59,830
you need a capital letter and a

775
00:30:56,620 --> 00:31:01,899
lowercase letter and a number and some

776
00:30:59,830 --> 00:31:04,029
special character so we've known for a

777
00:31:01,899 --> 00:31:06,279
long time that we can still create and

778
00:31:04,029 --> 00:31:09,629
people do create really weak passwords

779
00:31:06,279 --> 00:31:12,100
using these policies like abc123

780
00:31:09,629 --> 00:31:16,178
exclamation point fits all the

781
00:31:12,100 --> 00:31:20,019
parameters not very strong so what zxe

782
00:31:16,179 --> 00:31:21,879
VPN threads to do is create a measure of

783
00:31:20,019 --> 00:31:23,679
how difficult it's going to be for an

784
00:31:21,879 --> 00:31:26,830
attacker to actually guess your password

785
00:31:23,679 --> 00:31:28,720
and one of one of the things they

786
00:31:26,830 --> 00:31:31,000
decided at attacker was going to do was

787
00:31:28,720 --> 00:31:33,399
have a list of all of these commonly

788
00:31:31,000 --> 00:31:37,690
used weak passwords and go through those

789
00:31:33,399 --> 00:31:41,139
among other techniques so any password

790
00:31:37,690 --> 00:31:44,769
that's commonly used is already feral as

791
00:31:41,139 --> 00:31:48,309
rated week by this service let's take a

792
00:31:44,769 --> 00:31:50,980
look at how it works let's say I have my

793
00:31:48,309 --> 00:31:53,408
name up here and a common password and

794
00:31:50,980 --> 00:31:56,710
today's date and I put those together as

795
00:31:53,409 --> 00:31:59,590
a password this tool is gonna parse all

796
00:31:56,710 --> 00:32:01,240
three of them and break it up into these

797
00:31:59,590 --> 00:32:04,120
three chunks and then we're gonna

798
00:32:01,240 --> 00:32:07,960
analyze how these work and give a score

799
00:32:04,120 --> 00:32:09,309
for each of these three independently so

800
00:32:07,960 --> 00:32:11,559
you'll notice that the first one is

801
00:32:09,309 --> 00:32:13,450
recognized as a male name password

802
00:32:11,559 --> 00:32:15,279
belongs to the dictionary called

803
00:32:13,450 --> 00:32:18,820
passwords which is a list of common

804
00:32:15,279 --> 00:32:21,159
passwords and then the third part is

805
00:32:18,820 --> 00:32:24,850
represented is recognized as a date you

806
00:32:21,159 --> 00:32:27,039
know eight-eight 2019 and each one of

807
00:32:24,850 --> 00:32:29,230
these gets a score and to get a total

808
00:32:27,039 --> 00:32:31,269
score for your password you combine

809
00:32:29,230 --> 00:32:33,580
these and we're making a conservative

810
00:32:31,269 --> 00:32:35,470
assumption here that the the attacker

811
00:32:33,580 --> 00:32:38,168
knows the exact structure of your

812
00:32:35,470 --> 00:32:39,759
password but not the exact contents and

813
00:32:38,169 --> 00:32:42,399
so that's how you can combine these

814
00:32:39,759 --> 00:32:45,759
three scores to get one score for how

815
00:32:42,399 --> 00:32:47,469
strong your password is one thing I want

816
00:32:45,759 --> 00:32:49,929
to highlight here is that I put an @

817
00:32:47,470 --> 00:32:53,649
symbol in my name but it was still

818
00:32:49,929 --> 00:32:55,539
somehow recognized as Nathan so let's

819
00:32:53,649 --> 00:32:59,469
take a look at how that worked how they

820
00:32:55,539 --> 00:33:01,640
took the @ sign and turned it to an a so

821
00:32:59,470 --> 00:33:03,940
this meat substitution algorithm

822
00:33:01,640 --> 00:33:06,980
let's take the example of password I've

823
00:33:03,940 --> 00:33:10,490
used an outside-in a zero and KITT in

824
00:33:06,980 --> 00:33:13,250
place of a a no the Dropbox tool is

825
00:33:10,490 --> 00:33:15,530
going to go and look at it it's table

826
00:33:13,250 --> 00:33:19,429
predefined table of leet characters and

827
00:33:15,530 --> 00:33:21,920
finds the @ sign and the zero and find

828
00:33:19,429 --> 00:33:23,480
that those are replaced by a Ana and

829
00:33:21,920 --> 00:33:25,730
it'll make that replacement so we're

830
00:33:23,480 --> 00:33:27,830
back to the word password and that's

831
00:33:25,730 --> 00:33:30,380
when it's gonna do the dictionary lookup

832
00:33:27,830 --> 00:33:34,309
to find whether this word is in this

833
00:33:30,380 --> 00:33:37,340
list of dictionaries password will be in

834
00:33:34,309 --> 00:33:39,980
the common list and worried that this is

835
00:33:37,340 --> 00:33:42,379
not very strong another thing that

836
00:33:39,980 --> 00:33:44,450
happens is that password it's not just

837
00:33:42,380 --> 00:33:46,460
looking for the word password this is a

838
00:33:44,450 --> 00:33:48,980
quadratic time algorithm looking at

839
00:33:46,460 --> 00:33:52,820
every single substring of your password

840
00:33:48,980 --> 00:33:57,679
in case you had two words put together

841
00:33:52,820 --> 00:33:59,720
or something like that let's look at a

842
00:33:57,679 --> 00:34:02,630
second example blackhat but I've used a

843
00:33:59,720 --> 00:34:04,549
vertical bar in the outside again the

844
00:34:02,630 --> 00:34:07,149
vertical bar is special because it can

845
00:34:04,549 --> 00:34:09,590
be replaced by an i or an L

846
00:34:07,149 --> 00:34:13,489
according to dropboxes tables of

847
00:34:09,590 --> 00:34:15,980
characters so we need to look at both of

848
00:34:13,489 --> 00:34:18,469
these possibilities in or to determine

849
00:34:15,980 --> 00:34:21,320
the strength of our password so in the

850
00:34:18,469 --> 00:34:24,770
first case we get the AK hat this is not

851
00:34:21,320 --> 00:34:28,220
a real word and so it's not as bad as

852
00:34:24,770 --> 00:34:31,639
password doesn't show up in any of the

853
00:34:28,219 --> 00:34:34,000
dictionaries but then we look at

854
00:34:31,639 --> 00:34:37,129
replacing the vertical bar with an L and

855
00:34:34,000 --> 00:34:39,679
we get black hat instead and that is in

856
00:34:37,129 --> 00:34:42,549
the list of common passwords so to stop

857
00:34:39,679 --> 00:34:47,810
using black hat as a password you guys

858
00:34:42,550 --> 00:34:49,879
that that got some bad rating and we

859
00:34:47,810 --> 00:34:52,969
take the two scores we take the worst of

860
00:34:49,879 --> 00:34:56,960
these two scores and determine that

861
00:34:52,969 --> 00:34:58,819
black hat is not very strong so notice

862
00:34:56,960 --> 00:35:01,970
how we had to do kind of twice the work

863
00:34:58,820 --> 00:35:04,250
here in order to figure out how strong

864
00:35:01,970 --> 00:35:05,899
our password was and there are actually

865
00:35:04,250 --> 00:35:08,000
three of these characters that are

866
00:35:05,900 --> 00:35:11,359
ambiguous there's the vertical bar the

867
00:35:08,000 --> 00:35:13,400
one in the seven so we asked ourselves

868
00:35:11,359 --> 00:35:14,859
what happens if you put all three of

869
00:35:13,400 --> 00:35:17,049
these together

870
00:35:14,859 --> 00:35:20,109
in fact you don't get twice the work now

871
00:35:17,049 --> 00:35:23,049
you get eight times the work so you have

872
00:35:20,109 --> 00:35:24,759
to look at all possibilities for the

873
00:35:23,049 --> 00:35:28,390
different replacements for each of these

874
00:35:24,759 --> 00:35:31,150
three characters so for each of these

875
00:35:28,390 --> 00:35:33,308
eight possibilities now we make the

876
00:35:31,150 --> 00:35:35,859
replacements we get eight different

877
00:35:33,309 --> 00:35:37,239
words we put these eight words through

878
00:35:35,859 --> 00:35:39,308
the dictionary match this again a

879
00:35:37,239 --> 00:35:40,119
quadratic time algorithm looking out the

880
00:35:39,309 --> 00:35:45,099
substrings

881
00:35:40,119 --> 00:35:47,920
of every single one and then we find

882
00:35:45,099 --> 00:35:49,959
that lollipop is in there which is not

883
00:35:47,920 --> 00:35:52,329
strong so it's only one of those eight

884
00:35:49,959 --> 00:35:56,859
is weak but together you know we take

885
00:35:52,329 --> 00:36:00,130
the weakest of those so we've done eight

886
00:35:56,859 --> 00:36:03,729
times the effort now from what we would

887
00:36:00,130 --> 00:36:05,170
normally do so we ask ourselves you know

888
00:36:03,729 --> 00:36:07,019
what's the worst that can happen here

889
00:36:05,170 --> 00:36:09,489
putting together some of these things

890
00:36:07,019 --> 00:36:11,499
the first thing is that I've said a few

891
00:36:09,489 --> 00:36:13,479
times now it's a quadratic algorithm

892
00:36:11,499 --> 00:36:15,759
we're looking at this every single

893
00:36:13,479 --> 00:36:17,229
substring of the password so we're just

894
00:36:15,759 --> 00:36:20,499
gonna make our password as long as

895
00:36:17,229 --> 00:36:22,598
possible then we have these three

896
00:36:20,499 --> 00:36:25,660
special characters which have multiple

897
00:36:22,599 --> 00:36:30,910
possible substitutions so we're going to

898
00:36:25,660 --> 00:36:32,890
use all three of those and finally we'll

899
00:36:30,910 --> 00:36:34,420
now have eight replacement tables and

900
00:36:32,890 --> 00:36:36,609
we're gonna make all eight of those

901
00:36:34,420 --> 00:36:38,589
replacement tables as large as possible

902
00:36:36,609 --> 00:36:41,348
by putting in every other lead character

903
00:36:38,589 --> 00:36:44,529
and when you put all three of these

904
00:36:41,349 --> 00:36:47,880
requirements together you end up with a

905
00:36:44,529 --> 00:36:47,880
password that looks something like this

906
00:36:50,969 --> 00:36:56,349
Dropbox asked a similar question of

907
00:36:54,609 --> 00:36:58,690
what's the worst that can happen but

908
00:36:56,349 --> 00:37:02,170
they really looked at what the average

909
00:36:58,690 --> 00:37:05,309
case was because they took a list of

910
00:37:02,170 --> 00:37:07,959
common passwords like 30,000 of them and

911
00:37:05,309 --> 00:37:10,209
ran their tool against each of those

912
00:37:07,959 --> 00:37:12,848
passwords and found the worst case to be

913
00:37:10,209 --> 00:37:13,989
about a hundred milliseconds and they

914
00:37:12,849 --> 00:37:16,150
recommended because they knew that

915
00:37:13,989 --> 00:37:18,789
making longer passwords would make it

916
00:37:16,150 --> 00:37:20,589
run longer to cut off the password out

917
00:37:18,789 --> 00:37:22,239
of a hundred characters but there's

918
00:37:20,589 --> 00:37:25,839
nothing in their library that actually

919
00:37:22,239 --> 00:37:28,780
enforces that so when we ran our

920
00:37:25,839 --> 00:37:31,450
worst-case password we found that this

921
00:37:28,780 --> 00:37:34,450
actually took almost six seconds in in

922
00:37:31,450 --> 00:37:37,529
the 100 character case 24 seconds for

923
00:37:34,450 --> 00:37:40,660
twice that many characters and for a

924
00:37:37,530 --> 00:37:45,820
1000 character password it took over 22

925
00:37:40,660 --> 00:37:47,830
minutes now there's no reason that we

926
00:37:45,820 --> 00:37:49,990
had to stop at 1000 characters other

927
00:37:47,830 --> 00:37:53,069
what other than we got kind of bored

928
00:37:49,990 --> 00:37:58,180
running this you know and waiting for

929
00:37:53,070 --> 00:37:59,710
quite long amounts of time let's talk

930
00:37:58,180 --> 00:38:01,660
about the impact a little bit that was

931
00:37:59,710 --> 00:38:04,300
initially written this tool in

932
00:38:01,660 --> 00:38:06,069
CoffeeScript but because it is a really

933
00:38:04,300 --> 00:38:08,410
good tool and it's the only one that

934
00:38:06,070 --> 00:38:09,790
does this sort of measurement it's been

935
00:38:08,410 --> 00:38:12,029
adopted by a lot of different

936
00:38:09,790 --> 00:38:15,090
programming languages and implemented in

937
00:38:12,030 --> 00:38:17,350
many different programming languages and

938
00:38:15,090 --> 00:38:18,850
you'll notice here that some of these

939
00:38:17,350 --> 00:38:21,460
programming languages unlike

940
00:38:18,850 --> 00:38:26,500
CoffeeScript are made to be run

941
00:38:21,460 --> 00:38:29,290
server-side not client-side this also

942
00:38:26,500 --> 00:38:32,260
shows up in a number of enterprise

943
00:38:29,290 --> 00:38:33,850
software so Dropbox is one and we also

944
00:38:32,260 --> 00:38:36,700
went through the responsible disclosure

945
00:38:33,850 --> 00:38:38,529
process with stripe and JetBrains so

946
00:38:36,700 --> 00:38:40,569
some big-name companies who are using

947
00:38:38,530 --> 00:38:44,560
this and they're using it on their user

948
00:38:40,570 --> 00:38:46,960
signup page what this means is that you

949
00:38:44,560 --> 00:38:48,730
can go to a user signup page and put in

950
00:38:46,960 --> 00:38:52,840
a password without having any

951
00:38:48,730 --> 00:38:54,790
credentials for that server and if

952
00:38:52,840 --> 00:38:56,350
you're running this server-side then

953
00:38:54,790 --> 00:38:58,240
that will get sent to the server and

954
00:38:56,350 --> 00:39:00,880
they'll measure how strong your password

955
00:38:58,240 --> 00:39:04,270
is if they're not doing any other kind

956
00:39:00,880 --> 00:39:07,030
of mitigations then the this will run on

957
00:39:04,270 --> 00:39:11,740
their server for 22 minutes or however

958
00:39:07,030 --> 00:39:13,260
long it takes on their servers and one

959
00:39:11,740 --> 00:39:15,549
of the reasons you might do this

960
00:39:13,260 --> 00:39:17,620
server-side is because if you actually

961
00:39:15,550 --> 00:39:20,170
want to make sure that your users are

962
00:39:17,620 --> 00:39:23,140
giving you strong passwords then you

963
00:39:20,170 --> 00:39:24,520
want to verify at server-side because

964
00:39:23,140 --> 00:39:26,890
someone could get around things

965
00:39:24,520 --> 00:39:28,570
client-side it can warn you that you

966
00:39:26,890 --> 00:39:30,549
don't have a strong password but you

967
00:39:28,570 --> 00:39:32,620
could submit it anyway so that's why you

968
00:39:30,550 --> 00:39:37,510
might check server-side whether or not

969
00:39:32,620 --> 00:39:41,319
they've given you a strong password so

970
00:39:37,510 --> 00:39:42,670
we have a demo for this what I have here

971
00:39:41,320 --> 00:39:44,740
is a docker container

972
00:39:42,670 --> 00:39:46,810
not attacking any live version of JEP

973
00:39:44,740 --> 00:39:49,540
rains right now but we have JetBrains in

974
00:39:46,810 --> 00:39:51,850
a docker container locally we have the

975
00:39:49,540 --> 00:39:54,730
CPU here and this is the user signup

976
00:39:51,850 --> 00:39:57,580
page so again I have no credentials on

977
00:39:54,730 --> 00:40:01,330
Jefferies but I'm gonna sign up as a

978
00:39:57,580 --> 00:40:03,279
user here and without putting in any

979
00:40:01,330 --> 00:40:05,799
other identifying information and I

980
00:40:03,280 --> 00:40:08,560
don't have to submit a full completed

981
00:40:05,800 --> 00:40:12,100
application I can just copy this

982
00:40:08,560 --> 00:40:14,080
password before I paste it in I'll just

983
00:40:12,100 --> 00:40:16,839
point out you know how quickly you get a

984
00:40:14,080 --> 00:40:19,660
response for fare strong if I'm just

985
00:40:16,840 --> 00:40:21,460
typing in some small password so it's

986
00:40:19,660 --> 00:40:25,720
generally very responsive and has

987
00:40:21,460 --> 00:40:29,200
limited impact on the CPU but now if I

988
00:40:25,720 --> 00:40:31,720
paste in this password we'll see the CPU

989
00:40:29,200 --> 00:40:34,330
go up and notice how we don't have any

990
00:40:31,720 --> 00:40:37,899
kind of review of how strong this

991
00:40:34,330 --> 00:40:39,880
password is and this effect will last

992
00:40:37,900 --> 00:40:44,020
for quite a while because we've used the

993
00:40:39,880 --> 00:40:46,300
1000 characters the other thing I'm

994
00:40:44,020 --> 00:40:48,400
gonna do here is add some extra

995
00:40:46,300 --> 00:40:51,070
characters to resubmit this password a

996
00:40:48,400 --> 00:40:53,350
few times and then we'll see what

997
00:40:51,070 --> 00:40:58,410
happens to another user in a different

998
00:40:53,350 --> 00:41:01,450
tab so just add some more characters add

999
00:40:58,410 --> 00:41:04,120
to the load here and then I've got you

1000
00:41:01,450 --> 00:41:07,870
know a valid user who is trying to sign

1001
00:41:04,120 --> 00:41:10,120
in at the same time and they can put in

1002
00:41:07,870 --> 00:41:12,069
their password and they're now not

1003
00:41:10,120 --> 00:41:16,900
getting any feedback on how strong that

1004
00:41:12,070 --> 00:41:19,150
password is they might not recognize

1005
00:41:16,900 --> 00:41:22,480
this and can you know put in the second

1006
00:41:19,150 --> 00:41:24,190
password and try and register but good

1007
00:41:22,480 --> 00:41:26,170
luck to them as this servers going to be

1008
00:41:24,190 --> 00:41:29,100
working very hard on processing my

1009
00:41:26,170 --> 00:41:32,170
malicious password for quite a long time

1010
00:41:29,100 --> 00:41:33,700
the same effect would be would happen if

1011
00:41:32,170 --> 00:41:35,620
you were trying to log in and already

1012
00:41:33,700 --> 00:41:39,270
had credentials and we're trying to log

1013
00:41:35,620 --> 00:41:39,270
in as a legitimate user

1014
00:41:45,760 --> 00:41:50,720
so some of the things you can do I

1015
00:41:48,020 --> 00:41:53,359
mentioned that Dropbox recommends you

1016
00:41:50,720 --> 00:41:56,118
know cutting off the input at a hundred

1017
00:41:53,359 --> 00:41:58,609
bytes you could set some threshold using

1018
00:41:56,119 --> 00:42:00,440
input sanitization to say if you've

1019
00:41:58,609 --> 00:42:04,490
given me a long password I'm just gonna

1020
00:42:00,440 --> 00:42:07,190
evaluate the first part of it but that

1021
00:42:04,490 --> 00:42:09,200
may not be enough because we saw even

1022
00:42:07,190 --> 00:42:12,710
with a hundred characters that this

1023
00:42:09,200 --> 00:42:14,118
could take up to six seconds and so 100

1024
00:42:12,710 --> 00:42:16,910
millisecond if you're expecting a

1025
00:42:14,119 --> 00:42:18,770
hundred milliseconds something 60 times

1026
00:42:16,910 --> 00:42:20,569
that may not be acceptable for your

1027
00:42:18,770 --> 00:42:23,859
servers if you're getting a lot of these

1028
00:42:20,569 --> 00:42:26,299
requests that can have a high cost

1029
00:42:23,859 --> 00:42:29,058
another thing you can do is have better

1030
00:42:26,299 --> 00:42:31,369
algorithms so this dictionary match

1031
00:42:29,059 --> 00:42:34,240
looks at every single substring of the

1032
00:42:31,369 --> 00:42:36,740
password I don't think it needs to

1033
00:42:34,240 --> 00:42:39,348
you're not gonna find a dictionary match

1034
00:42:36,740 --> 00:42:40,819
on the first 999 characters of the

1035
00:42:39,349 --> 00:42:43,279
password if you don't have anything in

1036
00:42:40,819 --> 00:42:45,920
your dictionary that's 999 characters

1037
00:42:43,279 --> 00:42:47,869
large so you can probably have some

1038
00:42:45,920 --> 00:42:50,630
better algorithms that improve this

1039
00:42:47,869 --> 00:42:53,480
algorithm and it may still be quadratic

1040
00:42:50,630 --> 00:42:56,690
time but here we've seen you know when

1041
00:42:53,480 --> 00:43:02,000
we added the character tables that you

1042
00:42:56,690 --> 00:43:03,859
know where the the coefficients here are

1043
00:43:02,000 --> 00:43:09,200
important it's not just the Big O

1044
00:43:03,859 --> 00:43:12,078
runtime that we care about so to wrap up

1045
00:43:09,200 --> 00:43:13,669
here what are some things that we can do

1046
00:43:12,079 --> 00:43:15,200
there there have been some common themes

1047
00:43:13,670 --> 00:43:18,589
throughout this so one of them is

1048
00:43:15,200 --> 00:43:21,558
selecting better algorithms ones that

1049
00:43:18,589 --> 00:43:25,038
shorten the number the coefficient in

1050
00:43:21,559 --> 00:43:26,779
your algorithm or the Big O runtime when

1051
00:43:25,039 --> 00:43:28,670
you're designing and selecting these

1052
00:43:26,779 --> 00:43:30,230
algorithms don't just think about the

1053
00:43:28,670 --> 00:43:32,809
average case and the same goes for

1054
00:43:30,230 --> 00:43:34,520
testing them think about what's the

1055
00:43:32,809 --> 00:43:36,440
worst that can happen here you know

1056
00:43:34,520 --> 00:43:38,839
think about designing for the worst case

1057
00:43:36,440 --> 00:43:42,349
and if there's a worse case that you

1058
00:43:38,839 --> 00:43:44,750
don't like consider input sanitization

1059
00:43:42,349 --> 00:43:50,450
if it's not a valid input that you want

1060
00:43:44,750 --> 00:43:52,609
your users to be giving you so David and

1061
00:43:50,450 --> 00:43:55,038
I are co-authors of a tool along with a

1062
00:43:52,609 --> 00:43:56,839
couple of our co-workers and we'll be

1063
00:43:55,039 --> 00:43:59,960
presenting this tool at Arsenal

1064
00:43:56,839 --> 00:44:02,390
right after this at 11:30 what it does

1065
00:43:59,960 --> 00:44:04,219
is allows us to generate worst-case

1066
00:44:02,390 --> 00:44:06,200
inputs to some of these common

1067
00:44:04,219 --> 00:44:09,079
algorithms that we know are used in a

1068
00:44:06,200 --> 00:44:11,259
lot of applications so will generate the

1069
00:44:09,079 --> 00:44:14,660
worst case inputs given some

1070
00:44:11,259 --> 00:44:16,849
requirements and you'll be able to

1071
00:44:14,660 --> 00:44:19,219
generate those worst case inputs that

1072
00:44:16,849 --> 00:44:22,969
hit these corner cases and generate bad

1073
00:44:19,219 --> 00:44:25,660
outcomes another tool is reduce

1074
00:44:22,969 --> 00:44:28,339
identification so David talked about

1075
00:44:25,660 --> 00:44:30,769
regular expression denial of service and

1076
00:44:28,339 --> 00:44:32,989
we have a tool that'll take a regular

1077
00:44:30,769 --> 00:44:34,910
expression and tell you whether or not

1078
00:44:32,989 --> 00:44:38,650
it's vulnerable to some catastrophic

1079
00:44:34,910 --> 00:44:42,440
backtracking and we're also releasing

1080
00:44:38,650 --> 00:44:46,039
pocs for the two vulnerabilities we

1081
00:44:42,440 --> 00:44:47,989
talked about the PDF and the password

1082
00:44:46,039 --> 00:44:51,170
checking vulnerabilities those are part

1083
00:44:47,989 --> 00:44:53,779
built into a CSV which is life now at

1084
00:44:51,170 --> 00:44:56,690
this github link so again we'll be at

1085
00:44:53,779 --> 00:44:58,099
Arsenal at 11:30 at Station three couple

1086
00:44:56,690 --> 00:44:59,390
of our coworkers will be presenting

1087
00:44:58,099 --> 00:45:03,289
there and we encourage you to check it

1088
00:44:59,390 --> 00:45:06,379
out so finally as a member the audience

1089
00:45:03,289 --> 00:45:09,349
what can you do well for pen testers you

1090
00:45:06,380 --> 00:45:11,719
can incorporate AC vulnerabilities into

1091
00:45:09,349 --> 00:45:13,460
your testing we hope that a cease point

1092
00:45:11,719 --> 00:45:15,440
will help with that but also coming up

1093
00:45:13,460 --> 00:45:19,609
with your own test Suites and really

1094
00:45:15,440 --> 00:45:21,799
making AC Security a habit for

1095
00:45:19,609 --> 00:45:26,598
developers developing with the worst

1096
00:45:21,799 --> 00:45:29,599
case inputs in mind so ask yourself what

1097
00:45:26,599 --> 00:45:30,979
is the worst that can happen we think

1098
00:45:29,599 --> 00:45:34,219
you know if you ask that question up

1099
00:45:30,979 --> 00:45:35,660
front and not later on you know if you

1100
00:45:34,219 --> 00:45:37,579
if you don't ask that question up front

1101
00:45:35,660 --> 00:45:40,700
you may not like the answer later on

1102
00:45:37,579 --> 00:45:43,910
and finally for researchers you know

1103
00:45:40,700 --> 00:45:45,680
granted David and I had the years of

1104
00:45:43,910 --> 00:45:48,348
experience on Stack looking at these

1105
00:45:45,680 --> 00:45:50,390
types of vulnerabilities but one of the

1106
00:45:48,349 --> 00:45:52,519
things that really surprised us was when

1107
00:45:50,390 --> 00:45:55,910
we looked at these particular targets it

1108
00:45:52,519 --> 00:45:57,738
was a matter of you know days not months

1109
00:45:55,910 --> 00:45:59,899
or years that we were looking at these

1110
00:45:57,739 --> 00:46:02,509
particular targets and found these

1111
00:45:59,900 --> 00:46:04,460
vulnerabilities that leads us to believe

1112
00:46:02,509 --> 00:46:07,640
that these are really prevalent in other

1113
00:46:04,460 --> 00:46:09,079
software and so one of you out there may

1114
00:46:07,640 --> 00:46:10,520
be the next one to find one

1115
00:46:09,079 --> 00:46:13,520
we hope this talk

1116
00:46:10,520 --> 00:46:15,259
helped you know some of the warning

1117
00:46:13,520 --> 00:46:16,930
signs of a sieve ulnar abilities and be

1118
00:46:15,260 --> 00:46:20,620
able to identify them better and

1119
00:46:16,930 --> 00:46:23,270
recognize them for what they are and

1120
00:46:20,620 --> 00:46:25,730
when you do find one and see something

1121
00:46:23,270 --> 00:46:27,500
say something you know tell other people

1122
00:46:25,730 --> 00:46:31,460
about it so we can get better as a

1123
00:46:27,500 --> 00:46:33,950
community so thanks for your attention

1124
00:46:31,460 --> 00:46:35,660
we have a blog page up or we'll be

1125
00:46:33,950 --> 00:46:37,640
posting some more information about

1126
00:46:35,660 --> 00:46:39,710
these vulnerabilities and AC

1127
00:46:37,640 --> 00:46:41,629
vulnerabilities in general there's our

1128
00:46:39,710 --> 00:46:44,270
contact information and again we'll be

1129
00:46:41,630 --> 00:46:46,670
at Arsenal at 11:30 in the business hall

1130
00:46:44,270 --> 00:46:48,560
we hope you'll join us there and we've

1131
00:46:46,670 --> 00:46:52,820
got a few minutes for questions from the

1132
00:46:48,560 --> 00:46:52,960
aisle mics if anyone has any no thank

1133
00:46:52,820 --> 00:46:53,060
you

1134
00:46:52,960 --> 00:46:58,630
[Music]

1135
00:46:53,060 --> 00:46:58,630
[Applause]

