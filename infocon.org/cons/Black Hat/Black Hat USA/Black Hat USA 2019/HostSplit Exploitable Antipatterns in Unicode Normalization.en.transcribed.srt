1
00:00:00,000 --> 00:00:04,170
hello everybody and welcome to blackhat

2
00:00:02,100 --> 00:00:06,330
I appreciate everybody showing up for

3
00:00:04,170 --> 00:00:09,120
this talk today we're going over hosts

4
00:00:06,330 --> 00:00:10,920
split which is X Co exploitable

5
00:00:09,120 --> 00:00:14,099
anti-patterns and Unicode normalization

6
00:00:10,920 --> 00:00:15,299
so I appreciate you guys joining us and

7
00:00:14,099 --> 00:00:18,840
I want to go ahead and introduce

8
00:00:15,299 --> 00:00:21,300
Jonathan Burch hi Jonathan

9
00:00:18,840 --> 00:00:26,759
you give him a round of applause thank

10
00:00:21,300 --> 00:00:28,710
you okay so I'm Jonathan Burch with

11
00:00:26,760 --> 00:00:31,320
Microsoft Office security and this is

12
00:00:28,710 --> 00:00:34,710
host split exploitable anti-patterns and

13
00:00:31,320 --> 00:00:35,820
unicode normalization what I'm talking

14
00:00:34,710 --> 00:00:38,250
about today is essentially a new

15
00:00:35,820 --> 00:00:39,960
category of vulnerability this is an

16
00:00:38,250 --> 00:00:41,640
attack pattern that I found to work

17
00:00:39,960 --> 00:00:44,250
against a broad range of software and

18
00:00:41,640 --> 00:00:46,739
although this is a unicode vulnerability

19
00:00:44,250 --> 00:00:48,750
this is not a homograft attack this is

20
00:00:46,739 --> 00:00:50,430
not about fooling human eyeballs this is

21
00:00:48,750 --> 00:00:53,610
about fooling software bypassing

22
00:00:50,430 --> 00:00:55,559
security checks also I want to emphasize

23
00:00:53,610 --> 00:00:56,879
that though I work for Microsoft and

24
00:00:55,559 --> 00:00:59,129
I'll be discussing Microsoft

25
00:00:56,879 --> 00:01:00,960
vulnerabilities in this talk I've also

26
00:00:59,129 --> 00:01:02,550
found vulnerabilities of this type in a

27
00:01:00,960 --> 00:01:04,559
number of other products that are not

28
00:01:02,550 --> 00:01:07,320
Microsoft and I'll be discussing those

29
00:01:04,559 --> 00:01:09,179
as well I'm giving this talk because

30
00:01:07,320 --> 00:01:10,770
this is a vulnerability that works too

31
00:01:09,180 --> 00:01:13,080
well this is something I'm hoping people

32
00:01:10,770 --> 00:01:14,399
in this room will go and fix you

33
00:01:13,080 --> 00:01:16,229
probably have software that is

34
00:01:14,400 --> 00:01:17,850
vulnerable to this or maybe you'll go

35
00:01:16,229 --> 00:01:18,960
hack someone else's software that tool

36
00:01:17,850 --> 00:01:20,509
novel to this that will make it better

37
00:01:18,960 --> 00:01:23,220
too

38
00:01:20,509 --> 00:01:24,990
so here's an agenda for my talk I'm

39
00:01:23,220 --> 00:01:26,759
gonna give some background on how

40
00:01:24,990 --> 00:01:28,439
Unicode host names work that's

41
00:01:26,759 --> 00:01:30,509
internationalized domain names ID ends

42
00:01:28,439 --> 00:01:32,579
I'll describe what I call the hosts

43
00:01:30,509 --> 00:01:34,439
split attack which allows an attacker to

44
00:01:32,579 --> 00:01:37,048
create a URL which is parsed as

45
00:01:34,439 --> 00:01:38,429
belonging to one host name but resolved

46
00:01:37,049 --> 00:01:41,909
as belonging to a different host name

47
00:01:38,430 --> 00:01:43,890
I'll then give you a rundown of an

48
00:01:41,909 --> 00:01:45,630
example exploit where I show how you

49
00:01:43,890 --> 00:01:49,320
could have used host split to steal

50
00:01:45,630 --> 00:01:50,789
ooofff tokens from office 365 I'll talk

51
00:01:49,320 --> 00:01:52,079
about other software I found that's

52
00:01:50,790 --> 00:01:53,759
vulnerable I'll tell you what was

53
00:01:52,079 --> 00:01:56,969
vulnerable and what's still vulnerable

54
00:01:53,759 --> 00:01:59,189
I'll explain host bond which is a

55
00:01:56,969 --> 00:02:01,649
variant attack it works like in somewhat

56
00:01:59,189 --> 00:02:03,809
different software I'll explain how you

57
00:02:01,649 --> 00:02:05,009
can test for these issues even either in

58
00:02:03,810 --> 00:02:07,200
your own software or something you're

59
00:02:05,009 --> 00:02:09,330
trying to attack and I'll give you some

60
00:02:07,200 --> 00:02:13,319
best practices for preventing this issue

61
00:02:09,330 --> 00:02:15,420
or for fixing it so I

62
00:02:13,319 --> 00:02:17,578
penetration tester at Microsoft i hack

63
00:02:15,420 --> 00:02:18,929
office Word Excel the services that go

64
00:02:17,579 --> 00:02:21,540
with those so why am I looking at

65
00:02:18,930 --> 00:02:23,549
Unicode URLs well a couple of years ago

66
00:02:21,540 --> 00:02:25,138
I was at lunch with some other

67
00:02:23,549 --> 00:02:26,519
penetration testers at Microsoft and

68
00:02:25,139 --> 00:02:29,579
someone mentioned oh you can now get

69
00:02:26,519 --> 00:02:31,680
host names in the.net TLD that have

70
00:02:29,579 --> 00:02:33,209
Unicode or sorry have hieroglyphic

71
00:02:31,680 --> 00:02:35,010
characters so you could get single

72
00:02:33,209 --> 00:02:36,359
character host names and this was kind

73
00:02:35,010 --> 00:02:39,418
of cool we all just went and got one

74
00:02:36,359 --> 00:02:40,739
over lunch and I got this one and yeah

75
00:02:39,419 --> 00:02:42,629
that's a man writings huger off

76
00:02:40,739 --> 00:02:45,150
simultaneously maybe it's a metaphor for

77
00:02:42,629 --> 00:02:47,219
something but this got me to thinking

78
00:02:45,150 --> 00:02:50,879
how does this work how do a Unicode host

79
00:02:47,219 --> 00:02:52,290
names in URLs work and well in my

80
00:02:50,879 --> 00:02:53,879
position I get to do some open-ended

81
00:02:52,290 --> 00:02:55,560
security research so I spent some time

82
00:02:53,879 --> 00:02:56,939
looking at that I will to see if there

83
00:02:55,560 --> 00:02:59,250
were vulnerabilities and how Unicode

84
00:02:56,939 --> 00:03:01,980
host names are processed and yes there

85
00:02:59,250 --> 00:03:03,599
are but in order to explain them I'll

86
00:03:01,980 --> 00:03:04,888
have to give you the same background I

87
00:03:03,599 --> 00:03:06,569
learned I'll have to explain to you a

88
00:03:04,889 --> 00:03:10,530
bit about how internationalized domain

89
00:03:06,569 --> 00:03:12,000
names that's ID ends work so the first

90
00:03:10,530 --> 00:03:14,159
thing that's important to understand is

91
00:03:12,000 --> 00:03:17,849
that really the internet just runs on a

92
00:03:14,159 --> 00:03:19,948
ski so if you're doing a DNS lookup if

93
00:03:17,849 --> 00:03:23,310
you're doing a same-origin check that's

94
00:03:19,949 --> 00:03:25,439
all done with ascii so by the end these

95
00:03:23,310 --> 00:03:27,209
internationalized domain names the way

96
00:03:25,439 --> 00:03:28,680
they work is that every host name

97
00:03:27,209 --> 00:03:30,870
actually has two forms there's a-you

98
00:03:28,680 --> 00:03:33,030
label which contains Unicode characters

99
00:03:30,870 --> 00:03:35,370
it's nice for maybe showing a URL to

100
00:03:33,030 --> 00:03:37,290
someone in their native language but if

101
00:03:35,370 --> 00:03:40,530
there's a corresponding a label that's

102
00:03:37,290 --> 00:03:42,060
an ASCII string and these have a direct

103
00:03:40,530 --> 00:03:44,729
one-to-one relationship with each other

104
00:03:42,060 --> 00:03:47,310
and there are RFC defined algorithms for

105
00:03:44,729 --> 00:03:49,019
converting between them so there is two

106
00:03:47,310 --> 00:03:51,030
ascii to go from the unicode to the

107
00:03:49,019 --> 00:03:53,489
ascii and there's two unicode to go from

108
00:03:51,030 --> 00:03:55,709
the ascii to the unicode how those

109
00:03:53,489 --> 00:03:56,879
algorithms work is the crux of the

110
00:03:55,709 --> 00:03:57,780
vulnerabilities i'll be talking about

111
00:03:56,879 --> 00:04:01,649
today's so I'm going to give some

112
00:03:57,780 --> 00:04:04,439
details on those so going from Unicode

113
00:04:01,650 --> 00:04:06,989
to ASCII that to ASCII algorithm has two

114
00:04:04,439 --> 00:04:08,340
steps there is a normalization step

115
00:04:06,989 --> 00:04:10,169
where you convert all of the Unicode

116
00:04:08,340 --> 00:04:12,599
characters to a standardized form it's

117
00:04:10,169 --> 00:04:14,819
called a KC normalized form and this is

118
00:04:12,599 --> 00:04:17,159
sort of like making a string lower case

119
00:04:14,819 --> 00:04:19,139
before indexing it it's to make it sort

120
00:04:17,159 --> 00:04:21,298
of standardized and comparable and then

121
00:04:19,139 --> 00:04:23,969
there's the second step to convert the

122
00:04:21,298 --> 00:04:25,380
host names to ASCII this is called Punic

123
00:04:23,969 --> 00:04:26,230
coding and you're going to take Unicode

124
00:04:25,380 --> 00:04:28,600
characters and

125
00:04:26,230 --> 00:04:31,570
convert them into an ASCII encoding I'll

126
00:04:28,600 --> 00:04:32,770
detail those a little bit so if you look

127
00:04:31,570 --> 00:04:35,290
at the characters on the left side of

128
00:04:32,770 --> 00:04:36,849
this slide there is this a with

129
00:04:35,290 --> 00:04:38,800
combining ring above character there's

130
00:04:36,850 --> 00:04:40,630
the angstrom symbol and then there's an

131
00:04:38,800 --> 00:04:42,820
ASCII a with a combining ring above

132
00:04:40,630 --> 00:04:44,950
character after it these all look the

133
00:04:42,820 --> 00:04:46,210
same but someone trying to type this

134
00:04:44,950 --> 00:04:48,909
character might have typed any one of

135
00:04:46,210 --> 00:04:50,169
these you really want software to treat

136
00:04:48,910 --> 00:04:52,660
them as the same thing though that's

137
00:04:50,170 --> 00:04:55,480
where the normalization step is there so

138
00:04:52,660 --> 00:04:57,220
when you're converting any of these to

139
00:04:55,480 --> 00:04:58,930
an ASCII hostname you normalize them

140
00:04:57,220 --> 00:05:01,450
first and these all normalize to this

141
00:04:58,930 --> 00:05:03,850
lowercase a with combining ring above

142
00:05:01,450 --> 00:05:05,500
character now there's a couple of

143
00:05:03,850 --> 00:05:07,060
important things to notice about this

144
00:05:05,500 --> 00:05:09,240
first in one of these cases we've got

145
00:05:07,060 --> 00:05:11,650
two characters that become one character

146
00:05:09,240 --> 00:05:13,240
also we've got an ASCII character with a

147
00:05:11,650 --> 00:05:15,429
Unicode character that just becomes one

148
00:05:13,240 --> 00:05:17,680
unicode character both of those can

149
00:05:15,430 --> 00:05:19,150
happen the other way around also you

150
00:05:17,680 --> 00:05:21,220
sometimes have unicode characters that

151
00:05:19,150 --> 00:05:22,810
normalized to ASCII and one character

152
00:05:21,220 --> 00:05:25,420
that more normalized this to multiple

153
00:05:22,810 --> 00:05:28,600
characters and I will get back to this

154
00:05:25,420 --> 00:05:30,250
step because it's kind of critical after

155
00:05:28,600 --> 00:05:32,230
normalization does what's called punic

156
00:05:30,250 --> 00:05:34,360
coding this is where you convert Unicode

157
00:05:32,230 --> 00:05:36,100
characters to ASCII so if you look at

158
00:05:34,360 --> 00:05:37,690
this string this is this mask which is I

159
00:05:36,100 --> 00:05:40,330
guess the Norwegian word for seagull

160
00:05:37,690 --> 00:05:41,830
this has a single Unicode character in

161
00:05:40,330 --> 00:05:43,900
it which is that a with a combining ring

162
00:05:41,830 --> 00:05:45,219
above it when this gets Punic coded you

163
00:05:43,900 --> 00:05:45,700
get the string at the bottom of the

164
00:05:45,220 --> 00:05:47,980
slide

165
00:05:45,700 --> 00:05:50,590
this starts with an X and - which is

166
00:05:47,980 --> 00:05:52,600
called an ace that just means this part

167
00:05:50,590 --> 00:05:54,700
of the host name is Punic code this is

168
00:05:52,600 --> 00:05:56,260
followed by the ASCII characters from

169
00:05:54,700 --> 00:05:58,120
the original host name in the same order

170
00:05:56,260 --> 00:06:00,099
so everything but that a with a ring

171
00:05:58,120 --> 00:06:03,820
above it and then after that you have a

172
00:06:00,100 --> 00:06:05,980
- with this mu a this mu a is actually a

173
00:06:03,820 --> 00:06:08,380
set of instructions for an RFC to find

174
00:06:05,980 --> 00:06:09,940
state machine which can be executed to

175
00:06:08,380 --> 00:06:11,650
put the a with a ring above it back in

176
00:06:09,940 --> 00:06:13,960
there so those are just instructions

177
00:06:11,650 --> 00:06:15,700
that say put an A with a ring above it

178
00:06:13,960 --> 00:06:19,510
between the next-to-last and last

179
00:06:15,700 --> 00:06:21,280
characters of the ASCII now going the

180
00:06:19,510 --> 00:06:23,320
other way going from the ascii to

181
00:06:21,280 --> 00:06:25,510
unicode is simple you just run that RFC

182
00:06:23,320 --> 00:06:27,490
defined state machine so you just take

183
00:06:25,510 --> 00:06:29,080
that anyway and you run it and you get

184
00:06:27,490 --> 00:06:30,460
an A with a combining ring above it back

185
00:06:29,080 --> 00:06:31,919
in your string then you throw away the

186
00:06:30,460 --> 00:06:34,210
ACE and then you've got your host name

187
00:06:31,920 --> 00:06:35,920
you don't try to reverse the

188
00:06:34,210 --> 00:06:37,570
normalization because there's no way to

189
00:06:35,920 --> 00:06:39,070
do that so you end up getting the

190
00:06:37,570 --> 00:06:41,770
normalized form out of this

191
00:06:39,070 --> 00:06:44,500
now the RFC that defines how this works

192
00:06:41,770 --> 00:06:45,940
the i-dna RFC says that when you take an

193
00:06:44,500 --> 00:06:47,830
ASCII hostname and convert it to a

194
00:06:45,940 --> 00:06:49,480
Unicode hostname you have to then take

195
00:06:47,830 --> 00:06:51,640
the Unicode host and you get converted

196
00:06:49,480 --> 00:06:52,920
back to ASCII again and make sure it's

197
00:06:51,640 --> 00:06:54,760
the same thing you started with

198
00:06:52,920 --> 00:06:56,290
otherwise you're supposed to go into

199
00:06:54,760 --> 00:06:58,240
some sort of an error flow throw an

200
00:06:56,290 --> 00:06:59,130
exception that kind of thing but if you

201
00:06:58,240 --> 00:07:01,660
think about it

202
00:06:59,130 --> 00:07:03,820
the average user scenario is never going

203
00:07:01,660 --> 00:07:05,410
to hit this so you can imagine that some

204
00:07:03,820 --> 00:07:10,240
people implementing this might not have

205
00:07:05,410 --> 00:07:12,010
actually added that check well there's

206
00:07:10,240 --> 00:07:13,690
one other thing to understand here which

207
00:07:12,010 --> 00:07:15,430
is that there's three different

208
00:07:13,690 --> 00:07:18,820
standards for how all of this works

209
00:07:15,430 --> 00:07:20,590
there's ID in a 2003 which is from 2003

210
00:07:18,820 --> 00:07:23,140
and was the first way that I DNA worked

211
00:07:20,590 --> 00:07:25,390
there's ID in a 2008 which tried to fix

212
00:07:23,140 --> 00:07:26,919
ID in a 2003 by not allowing as many

213
00:07:25,390 --> 00:07:29,080
characters and also changing the way

214
00:07:26,920 --> 00:07:30,580
certain characters normalized but I

215
00:07:29,080 --> 00:07:32,620
caused a lot of problems for certain

216
00:07:30,580 --> 00:07:34,450
languages this meant that in some cases

217
00:07:32,620 --> 00:07:36,970
you might have a host name that under ID

218
00:07:34,450 --> 00:07:38,560
in a 2003 had one ASCII version but

219
00:07:36,970 --> 00:07:39,880
under ID and a 2008 had a different

220
00:07:38,560 --> 00:07:42,700
ASCII version and different people might

221
00:07:39,880 --> 00:07:45,610
own those so then there was ID and a

222
00:07:42,700 --> 00:07:48,190
2008 plus UTS 46 which tried to patch

223
00:07:45,610 --> 00:07:51,040
this by essentially having a conversion

224
00:07:48,190 --> 00:07:52,210
layer before I DNA 2008 this said well

225
00:07:51,040 --> 00:07:54,280
we're gonna take all the characters that

226
00:07:52,210 --> 00:07:55,539
ID and a 2008 treats differently and

227
00:07:54,280 --> 00:07:57,460
we're going to try to convert them into

228
00:07:55,540 --> 00:07:59,500
what ID in a 2003 would have done and

229
00:07:57,460 --> 00:08:01,900
then hand the whole thing out off to ID

230
00:07:59,500 --> 00:08:03,190
and a 2008 the result is that none of

231
00:08:01,900 --> 00:08:05,140
these are really the same as each other

232
00:08:03,190 --> 00:08:06,969
they're all a little bit different and

233
00:08:05,140 --> 00:08:10,180
different vulnerabilities work on each

234
00:08:06,970 --> 00:08:13,780
one so I've now given you some

235
00:08:10,180 --> 00:08:15,220
background on how ideas work how ID ends

236
00:08:13,780 --> 00:08:16,690
work rather and now I'll just go

237
00:08:15,220 --> 00:08:19,600
describe what I call the host split

238
00:08:16,690 --> 00:08:21,940
vulnerability so if you remember that

239
00:08:19,600 --> 00:08:23,470
normalization step I mentioned where all

240
00:08:21,940 --> 00:08:25,030
of those aids with rings above them

241
00:08:23,470 --> 00:08:28,000
became that lowercase a with a ring

242
00:08:25,030 --> 00:08:29,260
above it well what if there were unicode

243
00:08:28,000 --> 00:08:31,510
character is that when you normalize

244
00:08:29,260 --> 00:08:33,130
them they became ASCII characters but

245
00:08:31,510 --> 00:08:34,750
specifically ASCII characters that had

246
00:08:33,130 --> 00:08:38,770
syntax significance wherever you were

247
00:08:34,750 --> 00:08:41,169
going to use them like say this so here

248
00:08:38,770 --> 00:08:42,789
you have u plus 2100 this is the account

249
00:08:41,169 --> 00:08:45,250
of character it's supposed to be used

250
00:08:42,789 --> 00:08:46,780
for addressing envelopes but it turns

251
00:08:45,250 --> 00:08:48,640
out that when you normalize this unicode

252
00:08:46,780 --> 00:08:53,079
character it becomes asking

253
00:08:48,640 --> 00:08:54,790
a /c so if you think about this this is

254
00:08:53,079 --> 00:08:57,099
kind of a funny thing that forward-slash

255
00:08:54,790 --> 00:08:59,170
is an important character in URLs that's

256
00:08:57,100 --> 00:09:00,670
the path separator so what happens if

257
00:08:59,170 --> 00:09:03,760
you use one of these characters in a

258
00:09:00,670 --> 00:09:07,899
hostname like this so here we have evil

259
00:09:03,760 --> 00:09:10,180
see account of example comm well if we

260
00:09:07,899 --> 00:09:12,279
run the task e algorithm against this if

261
00:09:10,180 --> 00:09:14,199
we do the conversion to make this an

262
00:09:12,279 --> 00:09:17,589
ASCII hostname so we could do say a DNS

263
00:09:14,200 --> 00:09:20,680
lookup you get this you get evil dot C a

264
00:09:17,589 --> 00:09:22,089
/ C dot example comm and now the punic

265
00:09:20,680 --> 00:09:23,829
coding doesn't happen because you only

266
00:09:22,089 --> 00:09:26,290
be unicode when you've still got unicode

267
00:09:23,829 --> 00:09:28,029
characters after normalization so we

268
00:09:26,290 --> 00:09:31,149
just have this new ASCII host name

269
00:09:28,029 --> 00:09:33,339
instead and if you look at this it

270
00:09:31,149 --> 00:09:36,040
started off as a subdomain of example

271
00:09:33,339 --> 00:09:38,769
comm but now it's not now it's just evil

272
00:09:36,040 --> 00:09:40,689
dot CA with a path and presumably this

273
00:09:38,769 --> 00:09:44,019
is like some place where evil Canadian

274
00:09:40,690 --> 00:09:45,790
people hang out or something but the

275
00:09:44,019 --> 00:09:49,660
host name here has changed because of

276
00:09:45,790 --> 00:09:52,870
this normalization step so that seems

277
00:09:49,660 --> 00:09:54,160
problematic but does that work and yes

278
00:09:52,870 --> 00:09:56,740
that works really really well

279
00:09:54,160 --> 00:09:58,620
unfortunately it doesn't work as well as

280
00:09:56,740 --> 00:10:00,790
it did when I started doing my research

281
00:09:58,620 --> 00:10:02,620
but I found this whole nor build in a

282
00:10:00,790 --> 00:10:05,529
lot of places I first found this in edge

283
00:10:02,620 --> 00:10:07,870
and ie but I found issues also in dotnet

284
00:10:05,529 --> 00:10:09,180
Python Java and also a lot of other

285
00:10:07,870 --> 00:10:11,769
places I'm going to talk about today

286
00:10:09,180 --> 00:10:14,739
I'll start without edge and I Eve owner

287
00:10:11,769 --> 00:10:17,949
ability though so it turns out that some

288
00:10:14,740 --> 00:10:21,040
websites will return how HTTP response

289
00:10:17,949 --> 00:10:23,439
header is using utf-8 and if edge

290
00:10:21,040 --> 00:10:26,709
encountered an HTTP redirect response

291
00:10:23,440 --> 00:10:28,209
see a 302 where the location header in

292
00:10:26,709 --> 00:10:30,099
the response contained unicode

293
00:10:28,209 --> 00:10:31,599
characters it would normalize those

294
00:10:30,100 --> 00:10:34,449
unicode characters in the response

295
00:10:31,600 --> 00:10:36,790
header so if you had this URL this evil

296
00:10:34,449 --> 00:10:39,310
dot c account of example comm as the

297
00:10:36,790 --> 00:10:41,199
location header for a redirect edge and

298
00:10:39,310 --> 00:10:44,349
ie would actually just go to evil about

299
00:10:41,199 --> 00:10:46,000
CA instead so that's clearly a bug

300
00:10:44,350 --> 00:10:48,310
that's clearly not what you want the

301
00:10:46,000 --> 00:10:51,490
browser to do but why does it matter how

302
00:10:48,310 --> 00:10:52,810
do you exploit that well I'll tell you

303
00:10:51,490 --> 00:10:56,160
how you could have stolen OAuth tokens

304
00:10:52,810 --> 00:10:59,349
from office 365 using that vulnerability

305
00:10:56,160 --> 00:11:01,089
so a little background on Oh a sort of a

306
00:10:59,350 --> 00:11:01,740
refresher if you look at the OAuth

307
00:11:01,089 --> 00:11:04,200
authorization

308
00:11:01,740 --> 00:11:06,180
code flow this is what you're going to

309
00:11:04,200 --> 00:11:08,220
use if you've got some website where you

310
00:11:06,180 --> 00:11:09,569
want users to authenticate to it but you

311
00:11:08,220 --> 00:11:11,340
don't want to deal with usernames and

312
00:11:09,570 --> 00:11:13,050
passwords yourself you're going to let

313
00:11:11,340 --> 00:11:14,700
some other service do that so you

314
00:11:13,050 --> 00:11:16,770
redirect to that other service you say

315
00:11:14,700 --> 00:11:18,570
here's my application ID and here's the

316
00:11:16,770 --> 00:11:21,329
redirect URI I want you to send and off

317
00:11:18,570 --> 00:11:23,010
the kindy authentication token to that

318
00:11:21,330 --> 00:11:24,510
other service is going to ascend to get

319
00:11:23,010 --> 00:11:25,950
the user maybe they enter a username and

320
00:11:24,510 --> 00:11:28,200
password maybe they've just got a cookie

321
00:11:25,950 --> 00:11:30,120
and then it redirects to that redirect

322
00:11:28,200 --> 00:11:34,410
URI with a token probably in a query

323
00:11:30,120 --> 00:11:36,510
string something like that so this would

324
00:11:34,410 --> 00:11:38,100
be problematic if any website could

325
00:11:36,510 --> 00:11:40,710
start this flow and have the redirect

326
00:11:38,100 --> 00:11:42,510
URI go to itself so if I could make my

327
00:11:40,710 --> 00:11:44,520
evil calm and say oh I'm going to

328
00:11:42,510 --> 00:11:48,660
redirect to say the office Authenticator

329
00:11:44,520 --> 00:11:50,490
and my redirect URI is evil calm and my

330
00:11:48,660 --> 00:11:51,660
application ideas office it would be bad

331
00:11:50,490 --> 00:11:53,280
if the office that then they catered

332
00:11:51,660 --> 00:11:55,199
just authenticated the user and sent the

333
00:11:53,280 --> 00:11:58,110
token be my evil com because then I'd

334
00:11:55,200 --> 00:11:59,700
have some users token this is prevented

335
00:11:58,110 --> 00:12:02,400
and OAuth by essentially having a low

336
00:11:59,700 --> 00:12:04,680
list for where this redirect can go for

337
00:12:02,400 --> 00:12:06,480
any given application ID there is some

338
00:12:04,680 --> 00:12:08,400
pattern that says well these are the

339
00:12:06,480 --> 00:12:11,430
okay redirect your eyes for this

340
00:12:08,400 --> 00:12:14,400
application but how does that work well

341
00:12:11,430 --> 00:12:16,380
in olaf 1.0 it was really common to see

342
00:12:14,400 --> 00:12:18,630
redirect URI allow lists that were just

343
00:12:16,380 --> 00:12:21,720
start on something calm like start out

344
00:12:18,630 --> 00:12:24,150
office com so if you had this URI with

345
00:12:21,720 --> 00:12:26,160
the ebola account of that office com

346
00:12:24,150 --> 00:12:28,500
then ends with dot office com so it's

347
00:12:26,160 --> 00:12:30,030
okay it's important to remember that

348
00:12:28,500 --> 00:12:31,920
when software is dealing with URLs

349
00:12:30,030 --> 00:12:34,470
mostly it doesn't think about is this a

350
00:12:31,920 --> 00:12:36,030
Unicode URL or is this an ASCII URL it

351
00:12:34,470 --> 00:12:37,740
just says oh I've got a string it's a

352
00:12:36,030 --> 00:12:40,380
hostname well I'll do a regular

353
00:12:37,740 --> 00:12:42,750
expression against it so normally no one

354
00:12:40,380 --> 00:12:44,730
normalizes their URLs before doing these

355
00:12:42,750 --> 00:12:46,800
sort of security checks so that

356
00:12:44,730 --> 00:12:50,670
comparison works and you get a flow like

357
00:12:46,800 --> 00:12:53,189
this you have some attacker website it

358
00:12:50,670 --> 00:12:55,229
says to the office Authenticator well ok

359
00:12:53,190 --> 00:12:57,900
I'm office comm I want to use the office

360
00:12:55,230 --> 00:13:00,630
application ID and my redirect URI is

361
00:12:57,900 --> 00:13:03,720
this evil dot C account of that office

362
00:13:00,630 --> 00:13:05,939
com the service says well that ends with

363
00:13:03,720 --> 00:13:08,940
office comm or dot office com so that's

364
00:13:05,940 --> 00:13:10,770
ok I'll get a token I'll redirect to it

365
00:13:08,940 --> 00:13:12,030
and then it goes to edge if you're

366
00:13:10,770 --> 00:13:13,420
browsing an edge and edge actually goes

367
00:13:12,030 --> 00:13:14,500
to evil dot CA

368
00:13:13,420 --> 00:13:16,540
so it's not actually a subdomain of

369
00:13:14,500 --> 00:13:20,950
office calm and evil that CA gets your

370
00:13:16,540 --> 00:13:22,930
token instead but this is oweth 1.0 and

371
00:13:20,950 --> 00:13:26,020
no one uses oauth 1.0 anymore at least

372
00:13:22,930 --> 00:13:27,359
not a lot of software does modern oweth

373
00:13:26,020 --> 00:13:30,160
doesn't work this way

374
00:13:27,360 --> 00:13:31,540
modern OAuth generally has an allow less

375
00:13:30,160 --> 00:13:33,610
pattern that says it has to be this

376
00:13:31,540 --> 00:13:37,540
exact hostname and often you'll see this

377
00:13:33,610 --> 00:13:39,040
exact path for a given application so

378
00:13:37,540 --> 00:13:41,170
the attack I've been describing won't

379
00:13:39,040 --> 00:13:42,610
work for that the attack I've been

380
00:13:41,170 --> 00:13:44,560
describing only works for essentially a

381
00:13:42,610 --> 00:13:47,080
subdomain check something with a

382
00:13:44,560 --> 00:13:49,180
wild-card and that's not what we've got

383
00:13:47,080 --> 00:13:51,870
anymore but there is a tool we can use

384
00:13:49,180 --> 00:13:54,699
to get around this and that's redirects

385
00:13:51,870 --> 00:13:57,280
so in 2014 a researcher named Wang Jing

386
00:13:54,700 --> 00:14:00,610
publicized a vulnerability he described

387
00:13:57,280 --> 00:14:02,380
he called covert redirect which said

388
00:14:00,610 --> 00:14:04,690
essentially well if you've got an OAuth

389
00:14:02,380 --> 00:14:06,640
Authenticator that will send the token

390
00:14:04,690 --> 00:14:08,440
to some endpoint which also has an open

391
00:14:06,640 --> 00:14:09,819
the redirect vulnerability then maybe

392
00:14:08,440 --> 00:14:12,580
you can steal that token by essentially

393
00:14:09,820 --> 00:14:14,080
redirecting the token to your site maybe

394
00:14:12,580 --> 00:14:15,400
you can pull it out of the referre or

395
00:14:14,080 --> 00:14:18,070
maybe you actually have redirect

396
00:14:15,400 --> 00:14:21,130
behavior that forwards the token this

397
00:14:18,070 --> 00:14:23,650
didn't receive a really good and was

398
00:14:21,130 --> 00:14:25,540
well reception from the security

399
00:14:23,650 --> 00:14:27,459
community no one seemed very impressed

400
00:14:25,540 --> 00:14:29,500
by this but it turns out the host split

401
00:14:27,460 --> 00:14:30,760
attack to make this much easier to do it

402
00:14:29,500 --> 00:14:33,040
makes it much easier to find open

403
00:14:30,760 --> 00:14:36,400
redirects and that is how you could have

404
00:14:33,040 --> 00:14:39,610
attacked office 365 so often start live

405
00:14:36,400 --> 00:14:41,860
comm was a valid redirect endpoint for

406
00:14:39,610 --> 00:14:43,390
office o auth tokens it also had

407
00:14:41,860 --> 00:14:45,580
redirect functionality that would try to

408
00:14:43,390 --> 00:14:49,240
make to redirect to any sub domain of

409
00:14:45,580 --> 00:14:51,250
Dropbox com in combination you could

410
00:14:49,240 --> 00:14:53,650
have used this URL as your OAuth

411
00:14:51,250 --> 00:14:56,890
redirect target to actually steal tokens

412
00:14:53,650 --> 00:14:59,920
so if you look at this URL the target

413
00:14:56,890 --> 00:15:02,260
here for the redirect once you get to

414
00:14:59,920 --> 00:15:06,189
often start live comm is evil dot C

415
00:15:02,260 --> 00:15:08,530
account of Dropbox com and that ends

416
00:15:06,190 --> 00:15:10,840
with Dropbox com so office thought live

417
00:15:08,530 --> 00:15:12,610
comm said well that's ok but it sent

418
00:15:10,840 --> 00:15:14,710
that as a redirect to edge and I'd said

419
00:15:12,610 --> 00:15:16,930
oh I'll go to evil dot CA and that's

420
00:15:14,710 --> 00:15:19,030
where the token got forwarded to accept

421
00:15:16,930 --> 00:15:21,760
this didn't quite work because we were

422
00:15:19,030 --> 00:15:23,770
lucky it turned out that some of our

423
00:15:21,760 --> 00:15:26,770
middleware had a utf-8 double encoding

424
00:15:23,770 --> 00:15:27,199
bug so that any utf-8 response header

425
00:15:26,770 --> 00:15:30,680
acts

426
00:15:27,200 --> 00:15:33,050
utf8 mm hooded and so that redirect

427
00:15:30,680 --> 00:15:35,989
actually went to evil dot C and a bunch

428
00:15:33,050 --> 00:15:38,300
of garbage Dropbox comm and it turns out

429
00:15:35,990 --> 00:15:39,950
that browsers wouldn't even do that but

430
00:15:38,300 --> 00:15:41,390
this put in kind of an awkward position

431
00:15:39,950 --> 00:15:41,870
this meant we had a bug in our

432
00:15:41,390 --> 00:15:44,750
middleware

433
00:15:41,870 --> 00:15:47,690
that we couldn't allow to be patched on

434
00:15:44,750 --> 00:15:49,370
our middleware until we fixed edge and

435
00:15:47,690 --> 00:15:51,170
ie so we actually had the monitor

436
00:15:49,370 --> 00:15:52,670
patches for a middleware to make sure

437
00:15:51,170 --> 00:15:53,990
that this didn't get fixed or that we

438
00:15:52,670 --> 00:15:59,750
didn't accept the patch where it got

439
00:15:53,990 --> 00:16:01,520
fixed until we fixed our stuff okay so

440
00:15:59,750 --> 00:16:04,910
that's how the vulnerability works

441
00:16:01,520 --> 00:16:06,949
what's vulnerable to this well first

442
00:16:04,910 --> 00:16:08,959
it's not just the example I gave it's

443
00:16:06,950 --> 00:16:11,540
not just oh ah 'the host names are

444
00:16:08,960 --> 00:16:13,580
security identifiers there's a whole RFC

445
00:16:11,540 --> 00:16:17,569
about if you misinterpret security

446
00:16:13,580 --> 00:16:19,640
identifiers is bad stuff this can do

447
00:16:17,570 --> 00:16:21,020
lots of different things because a lot

448
00:16:19,640 --> 00:16:22,670
of places host names are used to

449
00:16:21,020 --> 00:16:24,860
essentially decide whether something is

450
00:16:22,670 --> 00:16:26,780
an okay place to do something it's also

451
00:16:24,860 --> 00:16:28,400
not just edge I've found this

452
00:16:26,780 --> 00:16:29,780
vulnerability all over the place I'll be

453
00:16:28,400 --> 00:16:31,430
going through a lot of different places

454
00:16:29,780 --> 00:16:33,770
later in this talk and it's also not

455
00:16:31,430 --> 00:16:35,599
just this account of character there's a

456
00:16:33,770 --> 00:16:37,939
really long list of unicode characters

457
00:16:35,600 --> 00:16:39,590
you can do this trick with I've got them

458
00:16:37,940 --> 00:16:41,540
at the end of this slide deck it's also

459
00:16:39,590 --> 00:16:43,910
in my white paper here's a few examples

460
00:16:41,540 --> 00:16:45,500
though so like an interrobang character

461
00:16:43,910 --> 00:16:48,410
normalizes the question mark exclamation

462
00:16:45,500 --> 00:16:50,720
point so it pushes everything after it

463
00:16:48,410 --> 00:16:53,240
just into the query string a full-width

464
00:16:50,720 --> 00:16:55,010
solidus character turns into just a

465
00:16:53,240 --> 00:16:57,410
forward slash full width number sign

466
00:16:55,010 --> 00:16:59,600
becomes number sign full width app

467
00:16:57,410 --> 00:17:01,280
becomes commercial at which is nice for

468
00:16:59,600 --> 00:17:05,660
attacking email so there's a lot of

469
00:17:01,280 --> 00:17:08,300
possibilities here it's also important

470
00:17:05,660 --> 00:17:09,860
to understand the specific idna version

471
00:17:08,300 --> 00:17:12,619
that's being implemented in software

472
00:17:09,859 --> 00:17:15,050
matters pure i-dna 2008 is not

473
00:17:12,619 --> 00:17:16,790
vulnerable to host split pure ID and a

474
00:17:15,050 --> 00:17:17,810
2008 does not allow any of the

475
00:17:16,790 --> 00:17:21,889
characters that let you do these

476
00:17:17,810 --> 00:17:25,839
shenanigans ID in a 2003 or ID in a 2008

477
00:17:21,890 --> 00:17:28,250
plus UTS 46 are vulnerable though

478
00:17:25,839 --> 00:17:29,750
however in both of those cases there's a

479
00:17:28,250 --> 00:17:32,030
flag we could have used which was used

480
00:17:29,750 --> 00:17:33,980
STD 3 ASCII rules which says essentially

481
00:17:32,030 --> 00:17:35,930
when you normalize a host name make sure

482
00:17:33,980 --> 00:17:37,460
afterwards the host name only contains

483
00:17:35,930 --> 00:17:40,070
characters that are supposed to be there

484
00:17:37,460 --> 00:17:43,160
in host names but nobody uses that

485
00:17:40,070 --> 00:17:45,770
lack and nobody uses pure ID in a 2008

486
00:17:43,160 --> 00:17:49,310
and why do they not do that well it's

487
00:17:45,770 --> 00:17:51,620
because of underscores so the STD three

488
00:17:49,310 --> 00:17:53,899
rules for URLs from way back

489
00:17:51,620 --> 00:17:56,629
old RFC's say that a hostname can only

490
00:17:53,900 --> 00:17:59,210
have alphanumeric characters dashes and

491
00:17:56,630 --> 00:18:01,940
periods but it turns out that lots of

492
00:17:59,210 --> 00:18:05,120
old URIs especially internet host names

493
00:18:01,940 --> 00:18:06,890
have underscores in them and if you use

494
00:18:05,120 --> 00:18:08,149
the STD 3 ASCII rules you just can't

495
00:18:06,890 --> 00:18:11,390
talk to host names that contain

496
00:18:08,150 --> 00:18:13,910
underscores anymore and that wasn't

497
00:18:11,390 --> 00:18:16,010
really acceptable to anyone so no one

498
00:18:13,910 --> 00:18:17,330
uses this flag and everyone's vulnerable

499
00:18:16,010 --> 00:18:22,040
because they want to talk to host names

500
00:18:17,330 --> 00:18:23,629
that have underscores in them that said

501
00:18:22,040 --> 00:18:25,730
browsers at least are safe now I

502
00:18:23,630 --> 00:18:28,820
reported the ad to naïve ulnar ability

503
00:18:25,730 --> 00:18:30,560
to nsrc this was patched in February now

504
00:18:28,820 --> 00:18:32,360
it's the case that edge and ie when they

505
00:18:30,560 --> 00:18:35,149
encounter an HTTP redirect like this

506
00:18:32,360 --> 00:18:38,060
they just won't redirect if the location

507
00:18:35,150 --> 00:18:39,320
header has one of these characters in it

508
00:18:38,060 --> 00:18:40,820
that would suddenly change something

509
00:18:39,320 --> 00:18:43,179
with syntax significance so the host

510
00:18:40,820 --> 00:18:46,070
name changes the redirect isn't followed

511
00:18:43,180 --> 00:18:48,020
Firefox and Chrome never had this bug so

512
00:18:46,070 --> 00:18:49,850
they've always been safe from it Safari

513
00:18:48,020 --> 00:18:51,920
does something very strange where if it

514
00:18:49,850 --> 00:18:53,840
gets a utf-8 location header for a

515
00:18:51,920 --> 00:18:55,670
redirect at % encodes it and then does

516
00:18:53,840 --> 00:18:59,330
the DNS lookup on the % encoded version

517
00:18:55,670 --> 00:18:59,750
which doesn't work so I don't know what

518
00:18:59,330 --> 00:19:02,060
that's about

519
00:18:59,750 --> 00:19:03,230
it's probably not exploitable but maybe

520
00:19:02,060 --> 00:19:07,760
someone can figure out something they

521
00:19:03,230 --> 00:19:10,220
can do with that but other Microsoft

522
00:19:07,760 --> 00:19:12,230
stuff was vulnerable as well Don net was

523
00:19:10,220 --> 00:19:14,240
vulnerable so that on that framework has

524
00:19:12,230 --> 00:19:16,400
classes for dealing with your eyes it

525
00:19:14,240 --> 00:19:18,500
has the URI builder which can be used to

526
00:19:16,400 --> 00:19:20,420
pull the hostname out of a URL and it

527
00:19:18,500 --> 00:19:21,920
has the ID n mapping class which can be

528
00:19:20,420 --> 00:19:24,200
used to convert a hostname between

529
00:19:21,920 --> 00:19:25,850
unicode and ascii and it turns out that

530
00:19:24,200 --> 00:19:27,890
if you used URI builder on one of these

531
00:19:25,850 --> 00:19:30,169
host names so this canada dot c account

532
00:19:27,890 --> 00:19:31,700
of dot products at office com it would

533
00:19:30,170 --> 00:19:33,770
say well the host name is that whole

534
00:19:31,700 --> 00:19:35,960
thing but then if you used ID and

535
00:19:33,770 --> 00:19:38,270
mapping to convert the host name from

536
00:19:35,960 --> 00:19:40,700
unicode to ascii so you could say do a

537
00:19:38,270 --> 00:19:42,470
DNS lookup make a request to this URL

538
00:19:40,700 --> 00:19:44,720
well suddenly the host name is actually

539
00:19:42,470 --> 00:19:46,430
now canada dot CA because it would do

540
00:19:44,720 --> 00:19:49,040
that normalization for you and there was

541
00:19:46,430 --> 00:19:50,180
nothing that said this wasn't ok this

542
00:19:49,040 --> 00:19:51,830
meant that if you're writing software

543
00:19:50,180 --> 00:19:53,570
that's dealing with URLs and you're

544
00:19:51,830 --> 00:19:56,540
probably just dealing with the URL as

545
00:19:53,570 --> 00:19:58,490
string and probably doing comparisons on

546
00:19:56,540 --> 00:20:01,550
it without trying to convert it to ascii

547
00:19:58,490 --> 00:20:03,350
you would do the wrong thing you would

548
00:20:01,550 --> 00:20:05,060
see a URL as being a subdomain of some

549
00:20:03,350 --> 00:20:06,320
host name but it wasn't and then when

550
00:20:05,060 --> 00:20:08,800
you try to make a request to it you

551
00:20:06,320 --> 00:20:12,200
would make a request to something else

552
00:20:08,800 --> 00:20:13,730
this is also fixed now I reported this

553
00:20:12,200 --> 00:20:15,920
to nsrc as well and this was also

554
00:20:13,730 --> 00:20:18,310
patched in February and it was back

555
00:20:15,920 --> 00:20:20,600
ported so even Don that - oh is good now

556
00:20:18,310 --> 00:20:22,070
the way it works now is when you've got

557
00:20:20,600 --> 00:20:24,469
a hostname and it's going to be

558
00:20:22,070 --> 00:20:26,179
converted to ascii then they pull out

559
00:20:24,470 --> 00:20:27,650
just a hostname they converted to ascii

560
00:20:26,180 --> 00:20:29,240
they say well does the host thing we

561
00:20:27,650 --> 00:20:30,950
ended up with have characters in it that

562
00:20:29,240 --> 00:20:33,080
shouldn't be in a host name if it does

563
00:20:30,950 --> 00:20:34,700
throw an exception so the code on that

564
00:20:33,080 --> 00:20:39,139
previous slide now shows a system that

565
00:20:34,700 --> 00:20:41,090
URI format exception fixing frameworks

566
00:20:39,140 --> 00:20:42,740
is a big deal because a lot of stuff was

567
00:20:41,090 --> 00:20:45,169
vulnerable because Don net was

568
00:20:42,740 --> 00:20:47,180
vulnerable an example of this is fiddler

569
00:20:45,170 --> 00:20:49,430
fiddler was a product made by telluric

570
00:20:47,180 --> 00:20:51,590
it's an HTTP traffic monitoring tool a

571
00:20:49,430 --> 00:20:53,420
lot of people use it to do penetration

572
00:20:51,590 --> 00:20:55,310
testing but also just testing software

573
00:20:53,420 --> 00:20:57,110
that talks to networks and it turned out

574
00:20:55,310 --> 00:20:58,460
that if you were running fiddler every

575
00:20:57,110 --> 00:21:00,919
browser was vulnerable to host plate

576
00:20:58,460 --> 00:21:03,170
redirects because fiddler would do the

577
00:21:00,920 --> 00:21:04,850
thing where would intercept that HTTP

578
00:21:03,170 --> 00:21:06,230
redirect response it would take the

579
00:21:04,850 --> 00:21:08,270
location header and it would normalize

580
00:21:06,230 --> 00:21:10,760
it for you and then hand the normalized

581
00:21:08,270 --> 00:21:12,770
version off to the browser and so Chrome

582
00:21:10,760 --> 00:21:14,060
and Firefox would also have the wrong

583
00:21:12,770 --> 00:21:15,889
redirects if you were running fiddler

584
00:21:14,060 --> 00:21:18,020
but they didn't have to fix anything we

585
00:21:15,890 --> 00:21:19,910
fixed net and because the framework is

586
00:21:18,020 --> 00:21:21,379
better now because the classes they rely

587
00:21:19,910 --> 00:21:24,620
on are fixed fiddler no longer has a

588
00:21:21,380 --> 00:21:27,920
vulnerability either but dotnet was not

589
00:21:24,620 --> 00:21:30,949
the only vulnerable framework Python was

590
00:21:27,920 --> 00:21:33,140
also vulnerable so in Python there's a

591
00:21:30,950 --> 00:21:35,360
built-in library called URL Lib which is

592
00:21:33,140 --> 00:21:38,600
used for parsing host names and things

593
00:21:35,360 --> 00:21:40,610
out of URLs and Python also has encoding

594
00:21:38,600 --> 00:21:42,709
is where you can map hostname astray

595
00:21:40,610 --> 00:21:44,990
from i-dna to utf-8 and things like that

596
00:21:42,710 --> 00:21:47,090
and this is essentially the same

597
00:21:44,990 --> 00:21:49,040
vulnerability that don net had if you

598
00:21:47,090 --> 00:21:50,570
tried to parse the host name out of a

599
00:21:49,040 --> 00:21:52,370
URL where you've got one of these hosts

600
00:21:50,570 --> 00:21:56,290
split characters so here it's Canada see

601
00:21:52,370 --> 00:21:56,290
a count of that Microsoft com

602
00:21:56,350 --> 00:22:01,310
it would say the host name is that whole

603
00:21:59,030 --> 00:22:03,710
thing it wouldn't break it where that

604
00:22:01,310 --> 00:22:06,050
host split character is but if you took

605
00:22:03,710 --> 00:22:07,100
that same URL and then you said well I

606
00:22:06,050 --> 00:22:09,049
want to convert the host name

607
00:22:07,100 --> 00:22:11,750
a ski so you can do like an actual

608
00:22:09,049 --> 00:22:15,168
request to it well that a oversee

609
00:22:11,750 --> 00:22:16,549
becomes a /c and now when your request

610
00:22:15,169 --> 00:22:18,070
is made it's going somewhere else and

611
00:22:16,549 --> 00:22:20,570
the host name is something different and

612
00:22:18,070 --> 00:22:22,460
I need to share this with the credit for

613
00:22:20,570 --> 00:22:24,409
this vulnerability with penny he was an

614
00:22:22,460 --> 00:22:25,940
intern at Microsoft when I found this he

615
00:22:24,410 --> 00:22:27,590
helped me work out the details in Python

616
00:22:25,940 --> 00:22:29,780
we actually did this at a hackathon a

617
00:22:27,590 --> 00:22:31,189
while back now this was one

618
00:22:29,780 --> 00:22:32,600
vulnerability in Python that was similar

619
00:22:31,190 --> 00:22:35,990
to dotnet but Python actually had a

620
00:22:32,600 --> 00:22:37,639
different vulnerability as well so the

621
00:22:35,990 --> 00:22:39,409
issue I've been talking about here

622
00:22:37,640 --> 00:22:41,840
allows you to essentially make something

623
00:22:39,409 --> 00:22:44,030
that was a subdomain of some URL or some

624
00:22:41,840 --> 00:22:45,889
hostname and now isn't but Python how to

625
00:22:44,030 --> 00:22:48,789
vulnerability that let you just swap the

626
00:22:45,890 --> 00:22:51,650
hostname in a URL and it works like this

627
00:22:48,789 --> 00:22:53,480
so here we're using the sort of

628
00:22:51,650 --> 00:22:55,669
old-school basic auth syntax

629
00:22:53,480 --> 00:22:58,039
you got user name colon password at some

630
00:22:55,669 --> 00:23:00,799
host name except the user name here has

631
00:22:58,039 --> 00:23:02,270
a full-width number sign in it and the

632
00:23:00,799 --> 00:23:04,460
trick here is that before the

633
00:23:02,270 --> 00:23:05,870
normalization happens that full-width

634
00:23:04,460 --> 00:23:07,669
number sign is just part of the username

635
00:23:05,870 --> 00:23:09,590
so the hostname is actually the thing

636
00:23:07,669 --> 00:23:11,330
after the ACT and that's what Python

637
00:23:09,590 --> 00:23:13,760
will tell you it is but once he

638
00:23:11,330 --> 00:23:15,500
normalized this well it turns out that

639
00:23:13,760 --> 00:23:18,679
the username would also get normalized

640
00:23:15,500 --> 00:23:20,299
and that full-width number son becomes a

641
00:23:18,679 --> 00:23:22,010
pound sign now and so everything after

642
00:23:20,299 --> 00:23:24,289
it is defragment and the hostname is

643
00:23:22,010 --> 00:23:25,580
just whatever was before it so in this

644
00:23:24,289 --> 00:23:27,110
case the host name goes from being

645
00:23:25,580 --> 00:23:31,580
products dot office comm to being

646
00:23:27,110 --> 00:23:34,639
bing.com I reported both of these to

647
00:23:31,580 --> 00:23:36,949
Python and they fixed both of these they

648
00:23:34,640 --> 00:23:39,880
were different CVEs but at this point if

649
00:23:36,950 --> 00:23:42,740
you're using Python you should be okay

650
00:23:39,880 --> 00:23:43,880
Python was not the only third-party

651
00:23:42,740 --> 00:23:47,559
framework that was vulnerable either

652
00:23:43,880 --> 00:23:47,559
though Java also had this issue

653
00:23:49,830 --> 00:23:57,749
and I'll give you a second to look at

654
00:23:51,899 --> 00:23:59,070
that while I take a drink but this is

655
00:23:57,749 --> 00:24:01,649
essentially the same vulnerability to

656
00:23:59,070 --> 00:24:05,189
the dotnet and Python hat we're here

657
00:24:01,649 --> 00:24:07,080
we're using the URL class in Java along

658
00:24:05,190 --> 00:24:10,289
with the IDN class we're pulling the

659
00:24:07,080 --> 00:24:12,090
hostname out using the URL class and one

660
00:24:10,289 --> 00:24:15,330
before we convert the hostname to ascii

661
00:24:12,090 --> 00:24:16,439
the URL here is again going to have the

662
00:24:15,330 --> 00:24:18,570
hostname be the whole thing

663
00:24:16,440 --> 00:24:21,989
the evil dot c and this is the account

664
00:24:18,570 --> 00:24:24,269
of character the microsoft calm but

665
00:24:21,989 --> 00:24:25,619
after we use the ID n dot ascii method

666
00:24:24,269 --> 00:24:27,119
to convert the host him to ASCII which

667
00:24:25,619 --> 00:24:29,789
you have to do in java if you want to

668
00:24:27,119 --> 00:24:33,539
make a request now the host name is evil

669
00:24:29,789 --> 00:24:36,210
dot CA I reported this issue to Oracle

670
00:24:33,539 --> 00:24:37,739
and this was fixed in July I haven't had

671
00:24:36,210 --> 00:24:40,980
a chance to review the fix because this

672
00:24:37,739 --> 00:24:44,159
was pretty recent but hopefully this is

673
00:24:40,980 --> 00:24:45,269
good now as well okay so that was a

674
00:24:44,159 --> 00:24:46,440
bunch of frameworks but what if you're

675
00:24:45,269 --> 00:24:48,179
writing native code well if you're

676
00:24:46,440 --> 00:24:51,330
writing native code in Windows your code

677
00:24:48,179 --> 00:24:53,489
probably is vulnerable so if you're

678
00:24:51,330 --> 00:24:56,119
using IDM to ask you to convert a

679
00:24:53,489 --> 00:24:58,889
Unicode hostname to an ASCII hostname

680
00:24:56,119 --> 00:25:01,139
that windows API will actually also

681
00:24:58,889 --> 00:25:03,209
convert the account a character to a /c

682
00:25:01,139 --> 00:25:04,379
and all of the other characters that I

683
00:25:03,210 --> 00:25:06,929
mentioned that also let you do these

684
00:25:04,379 --> 00:25:09,748
tricks work as well but this is

685
00:25:06,929 --> 00:25:11,850
necessary ID and ASCII is an RFC defined

686
00:25:09,749 --> 00:25:14,279
algorithm there are things that it's

687
00:25:11,850 --> 00:25:16,049
used for that are not host names if the

688
00:25:14,279 --> 00:25:18,809
behavior of this changed a lot of other

689
00:25:16,049 --> 00:25:21,149
things would break it does have a flag

690
00:25:18,809 --> 00:25:22,889
which is the use STD 3 ASCII rules flag

691
00:25:21,149 --> 00:25:25,649
I mentioned before if you use that it is

692
00:25:22,889 --> 00:25:27,029
safe but then it won't accept host names

693
00:25:25,649 --> 00:25:30,299
with underscores so there's a trade-off

694
00:25:27,029 --> 00:25:33,480
there you'll have the same issue of your

695
00:25:30,299 --> 00:25:35,460
writing native code in Linux so in Linux

696
00:25:33,480 --> 00:25:38,279
there's the cannula by DN in Lib ID in

697
00:25:35,460 --> 00:25:39,989
two libraries which I use to convert

698
00:25:38,279 --> 00:25:43,590
hostname is between unicode mouse key

699
00:25:39,989 --> 00:25:46,379
and in both cases they will also convert

700
00:25:43,590 --> 00:25:47,789
a count of two a forward slash c and all

701
00:25:46,379 --> 00:25:50,549
of the other host splits stuff works as

702
00:25:47,789 --> 00:25:52,830
well for libido n you can fix it by

703
00:25:50,549 --> 00:25:55,679
using the use STD 3 ox key rules flag

704
00:25:52,830 --> 00:25:59,189
for the body and two you can use node TR

705
00:25:55,679 --> 00:26:01,649
46 again no underscores if you use those

706
00:25:59,190 --> 00:26:03,059
flags I did contact the maintainer zuv

707
00:26:01,649 --> 00:26:05,100
live ID n about this in

708
00:26:03,059 --> 00:26:06,899
they said it was by design and I agree

709
00:26:05,100 --> 00:26:08,939
they're in exactly the same boat as

710
00:26:06,899 --> 00:26:10,439
Windows is with this this is an RFC

711
00:26:08,940 --> 00:26:12,409
defined algorithm they can't change how

712
00:26:10,440 --> 00:26:15,230
it works either

713
00:26:12,409 --> 00:26:18,480
okay so that was host split and that

714
00:26:15,230 --> 00:26:21,090
only worked against Ida in a 2003 or

715
00:26:18,480 --> 00:26:22,620
idat 2008 plus UTS 46 but I've got a

716
00:26:21,090 --> 00:26:28,678
different attack that works against pure

717
00:26:22,620 --> 00:26:30,570
ID and a 2008 so I didn't a 2008 doesn't

718
00:26:28,679 --> 00:26:33,210
allow any of the characters that an able

719
00:26:30,570 --> 00:26:35,249
host split they won't normalize them but

720
00:26:33,210 --> 00:26:37,259
it does allow two characters that the

721
00:26:35,249 --> 00:26:38,970
other two specifications don't and

722
00:26:37,259 --> 00:26:42,179
that's the zero with Joyner and the 0

723
00:26:38,970 --> 00:26:43,499
with non joiner characters identity 2003

724
00:26:42,179 --> 00:26:45,840
doesn't let you use these in host names

725
00:26:43,499 --> 00:26:47,220
because they're invisible so you would

726
00:26:45,840 --> 00:26:48,629
have the problem where user couldn't

727
00:26:47,220 --> 00:26:50,549
tell the difference between some host

728
00:26:48,629 --> 00:26:53,549
name and the same hosting plus an

729
00:26:50,549 --> 00:26:54,749
invisible character somewhere in it but

730
00:26:53,549 --> 00:26:56,158
it turns out that these characters are

731
00:26:54,749 --> 00:26:58,110
important for rendering certain

732
00:26:56,159 --> 00:26:59,970
languages for languages that use daven

733
00:26:58,110 --> 00:27:02,639
agario through script for instance they

734
00:26:59,970 --> 00:27:04,769
change the way the ligatures work so I'd

735
00:27:02,639 --> 00:27:07,229
na 2008 allows these characters and host

736
00:27:04,769 --> 00:27:08,669
names but conditionally only if the

737
00:27:07,230 --> 00:27:10,080
joiner character is between two

738
00:27:08,669 --> 00:27:15,929
characters that would render differently

739
00:27:10,080 --> 00:27:17,610
because it's there so if you put one of

740
00:27:15,929 --> 00:27:19,289
these characters in a host name if you

741
00:27:17,610 --> 00:27:21,809
just make some hosting like micro and

742
00:27:19,289 --> 00:27:23,730
then a 0 with Joyner soft calm and then

743
00:27:21,809 --> 00:27:25,559
try to use itna 2008 to convert it to a

744
00:27:23,730 --> 00:27:27,240
ski that won't get you anywhere it'll

745
00:27:25,559 --> 00:27:29,490
just throw away the 0 with Joyner so

746
00:27:27,240 --> 00:27:30,419
it's just Microsoft calm but you

747
00:27:29,490 --> 00:27:31,860
remember what I said about the

748
00:27:30,419 --> 00:27:33,960
round-trip check that when you're going

749
00:27:31,860 --> 00:27:35,428
from ascii to Unicode you're supposed to

750
00:27:33,960 --> 00:27:36,779
go back from Unicode to ask you and make

751
00:27:35,429 --> 00:27:39,899
sure you ended up with the same thing

752
00:27:36,779 --> 00:27:42,840
well that isn't really implemented very

753
00:27:39,899 --> 00:27:44,428
often so it turns out that in i-dna 2008

754
00:27:42,840 --> 00:27:45,928
implementations is often the case that

755
00:27:44,429 --> 00:27:47,999
if you write your own software to do the

756
00:27:45,929 --> 00:27:49,769
punic coding and put app unicode at 0

757
00:27:47,999 --> 00:27:51,840
with Joyner in there they're ok with

758
00:27:49,769 --> 00:27:54,840
that so you can make a hostname like

759
00:27:51,840 --> 00:27:57,149
this this is xn - - Microsoft - for 690

760
00:27:54,840 --> 00:27:58,769
com where that's got app Unicode at 0

761
00:27:57,149 --> 00:28:01,918
with joinha between micro and soft and

762
00:27:58,769 --> 00:28:05,340
most ID and a 2008 implementations were

763
00:28:01,919 --> 00:28:07,470
happy to accept that host name but

764
00:28:05,340 --> 00:28:09,570
that's problematic so there's two issues

765
00:28:07,470 --> 00:28:10,740
here first you've got this ASCII host

766
00:28:09,570 --> 00:28:11,789
name but if you're going to show this to

767
00:28:10,740 --> 00:28:14,519
a user you're going to convert it to

768
00:28:11,789 --> 00:28:16,360
Unicode again and if you do that well

769
00:28:14,519 --> 00:28:18,190
then it just looks like Microsoft com

770
00:28:16,360 --> 00:28:20,110
zero with Joyner somewhere in it sure

771
00:28:18,190 --> 00:28:22,420
but it's an invisible character the user

772
00:28:20,110 --> 00:28:23,709
can't tell and also if you remember what

773
00:28:22,420 --> 00:28:25,150
I said about zero with Joyner is getting

774
00:28:23,710 --> 00:28:27,790
thrown away when you go from Unicode to

775
00:28:25,150 --> 00:28:29,290
ASCII that's what happens here so if you

776
00:28:27,790 --> 00:28:31,178
convert this hostname from ASCII to

777
00:28:29,290 --> 00:28:33,700
Unicode then back to ASCII is just

778
00:28:31,179 --> 00:28:35,620
Microsoft comm so you've got the host

779
00:28:33,700 --> 00:28:37,179
names that essentially mutate they go

780
00:28:35,620 --> 00:28:41,100
from not being something to actually

781
00:28:37,179 --> 00:28:43,960
being something and that is exploitable

782
00:28:41,100 --> 00:28:47,830
so the host plant owner ability as an

783
00:28:43,960 --> 00:28:49,360
example say you've got some email server

784
00:28:47,830 --> 00:28:50,740
out there that's that emailed out some

785
00:28:49,360 --> 00:28:52,899
cloud host net that you want to

786
00:28:50,740 --> 00:28:55,059
impersonate so you go register your own

787
00:28:52,900 --> 00:28:56,320
domain and you stick up Unicode to deal

788
00:28:55,059 --> 00:28:58,870
with Joyner in it but it's otherwise the

789
00:28:56,320 --> 00:29:01,299
same as theirs so you make this xn - -

790
00:28:58,870 --> 00:29:03,370
email - xt3 B dot some cloud host net

791
00:29:01,299 --> 00:29:05,650
where that's got a p-- unicode at 0 with

792
00:29:03,370 --> 00:29:07,149
Joyner between the E and the M what

793
00:29:05,650 --> 00:29:10,570
happens if we send an email from that

794
00:29:07,150 --> 00:29:12,640
server well let's say we set the server

795
00:29:10,570 --> 00:29:14,620
up we go use let's encrypt to get a

796
00:29:12,640 --> 00:29:16,030
certificate because you can they're okay

797
00:29:14,620 --> 00:29:18,969
with anything that's an ASCII host name

798
00:29:16,030 --> 00:29:21,760
and if you can set actual DNS records

799
00:29:18,970 --> 00:29:23,679
you can set up D kam SPF d mark make it

800
00:29:21,760 --> 00:29:27,280
all look legit you send email from this

801
00:29:23,679 --> 00:29:29,710
to Gmail and Gmail will decode the punic

802
00:29:27,280 --> 00:29:31,440
code and it will show it as coming from

803
00:29:29,710 --> 00:29:35,350
the server you're trying to impersonate

804
00:29:31,440 --> 00:29:36,910
so xn - - email etc will just show up as

805
00:29:35,350 --> 00:29:40,090
email about some cloud host on that in

806
00:29:36,910 --> 00:29:41,679
Gmail they do the SPF and DKIM checks

807
00:29:40,090 --> 00:29:44,110
but they do it on the ASCII before doing

808
00:29:41,679 --> 00:29:46,540
the decode so it looks legitimate but

809
00:29:44,110 --> 00:29:48,549
it's not and then if you try to reply to

810
00:29:46,540 --> 00:29:51,070
that email Gmail will throw away the 0

811
00:29:48,549 --> 00:29:52,360
with Joyner again and then it goes to

812
00:29:51,070 --> 00:29:54,399
the real thing you're trying to

813
00:29:52,360 --> 00:29:56,469
impersonate so it lets you do kind of an

814
00:29:54,400 --> 00:29:57,970
interesting phishing attack you can send

815
00:29:56,470 --> 00:30:02,140
email as anybody but you can't receive

816
00:29:57,970 --> 00:30:04,059
the replies I did report this to Google

817
00:30:02,140 --> 00:30:05,020
in February they've acknowledged the

818
00:30:04,059 --> 00:30:06,700
issue they've said that they're

819
00:30:05,020 --> 00:30:08,290
monitoring their services to make sure

820
00:30:06,700 --> 00:30:10,299
that no one is exploiting this attack

821
00:30:08,290 --> 00:30:14,470
against their users it's still there

822
00:30:10,299 --> 00:30:16,389
though also besides Google besides T

823
00:30:14,470 --> 00:30:18,730
mail lib ID and - is also vulnerable to

824
00:30:16,390 --> 00:30:20,380
this host bond issue if you take that

825
00:30:18,730 --> 00:30:22,600
same host name with the punic coded 0

826
00:30:20,380 --> 00:30:24,190
with Joyner in it that I described the

827
00:30:22,600 --> 00:30:27,010
one where it's micro 0 with during a

828
00:30:24,190 --> 00:30:29,410
soft calm and you tell lib ID and - to

829
00:30:27,010 --> 00:30:29,860
decode it or if you did then it would do

830
00:30:29,410 --> 00:30:31,510
that

831
00:30:29,860 --> 00:30:32,770
and you would get Microsoft comm with a

832
00:30:31,510 --> 00:30:34,690
zero with joiner in the middle of it

833
00:30:32,770 --> 00:30:36,040
which you can't see if you're in bass

834
00:30:34,690 --> 00:30:37,450
you'd probably get a box and you'd

835
00:30:36,040 --> 00:30:40,389
notice but if you're in a GUI you

836
00:30:37,450 --> 00:30:41,679
probably wouldn't I did report this to

837
00:30:40,390 --> 00:30:45,070
the maintainer of the by the end and

838
00:30:41,679 --> 00:30:47,470
this was fixed in Lib IDN to version 2.2

839
00:30:45,070 --> 00:30:48,850
point o as far as I'm aware the only

840
00:30:47,470 --> 00:30:50,799
district at use is out right now is

841
00:30:48,850 --> 00:30:52,659
Debbie and unstable so you might want to

842
00:30:50,799 --> 00:30:54,910
talk to whoever maintains your distro to

843
00:30:52,660 --> 00:30:56,260
get them to pick this up as well and I

844
00:30:54,910 --> 00:30:57,820
need the share credit with for this

845
00:30:56,260 --> 00:31:00,429
vulnerability with Tim Florian and

846
00:30:57,820 --> 00:31:01,600
Nico's they helped work out the fix for

847
00:31:00,429 --> 00:31:03,429
this they helped worked out additional

848
00:31:01,600 --> 00:31:05,350
test cases they made sure fixing this

849
00:31:03,429 --> 00:31:09,460
didn't break anything else so thanks to

850
00:31:05,350 --> 00:31:10,830
them there are a lot of limitations on

851
00:31:09,460 --> 00:31:13,179
this host bond vulnerability though

852
00:31:10,830 --> 00:31:17,199
first like I said it only works against

853
00:31:13,179 --> 00:31:20,110
pure ID and a 2008 ID in a 2003 does not

854
00:31:17,200 --> 00:31:21,760
allow 0 with joiners and so on it's also

855
00:31:20,110 --> 00:31:24,250
only ever going to be exploitable where

856
00:31:21,760 --> 00:31:26,350
you've got software that takes a URL

857
00:31:24,250 --> 00:31:28,540
that could be a nasty URL as Punic coded

858
00:31:26,350 --> 00:31:30,129
and it's gonna decode it to Unicode and

859
00:31:28,540 --> 00:31:31,750
usually that only happens if it's

860
00:31:30,130 --> 00:31:33,160
displaying it to a user so this is

861
00:31:31,750 --> 00:31:36,460
usually only exploitable if there's a

862
00:31:33,160 --> 00:31:38,470
GUI somewhere involved most

863
00:31:36,460 --> 00:31:41,169
significantly though you can't get host

864
00:31:38,470 --> 00:31:43,299
names like this if you go to do a domain

865
00:31:41,169 --> 00:31:44,830
registrar like say I don't know GoDaddy

866
00:31:43,299 --> 00:31:47,918
or something and you try to get like

867
00:31:44,830 --> 00:31:50,168
that xn - - Microsoft etc com they'll

868
00:31:47,919 --> 00:31:51,460
just say no some of them think they can

869
00:31:50,169 --> 00:31:52,960
get it they'll take your money and then

870
00:31:51,460 --> 00:31:55,840
later this is a oh no we couldn't get

871
00:31:52,960 --> 00:31:57,640
that so you can't get host names like

872
00:31:55,840 --> 00:31:59,080
this from domain registrar's but

873
00:31:57,640 --> 00:32:01,360
providers of third level domains

874
00:31:59,080 --> 00:32:02,649
generally do let you get these there's

875
00:32:01,360 --> 00:32:04,600
lots of services out there we'll let

876
00:32:02,650 --> 00:32:07,120
that we'll let you buy a subdomain of

877
00:32:04,600 --> 00:32:09,219
their host name and those services

878
00:32:07,120 --> 00:32:11,320
generally don't care about whether the

879
00:32:09,220 --> 00:32:13,090
punic code in your ascii sub domain is

880
00:32:11,320 --> 00:32:15,309
actually not Punic code you're supposed

881
00:32:13,090 --> 00:32:17,428
to be able to use so that's how you

882
00:32:15,309 --> 00:32:20,350
attack this sort of thing

883
00:32:17,429 --> 00:32:22,919
okay so I've described host split and

884
00:32:20,350 --> 00:32:26,559
host on how do you test for these issues

885
00:32:22,919 --> 00:32:28,150
well testing for host split is pretty

886
00:32:26,559 --> 00:32:29,860
easy if you can monitor network traffic

887
00:32:28,150 --> 00:32:31,330
if you got some application running on

888
00:32:29,860 --> 00:32:33,668
your machine you can see what we're

889
00:32:31,330 --> 00:32:35,230
across that's making that all you do is

890
00:32:33,669 --> 00:32:36,850
you give it a URL that has one of these

891
00:32:35,230 --> 00:32:38,980
magic hosts split characters in it and

892
00:32:36,850 --> 00:32:42,939
you see what kind of DNS lookup it tries

893
00:32:38,980 --> 00:32:43,760
to perform if you use a URL like this

894
00:32:42,940 --> 00:32:46,430
like this

895
00:32:43,760 --> 00:32:49,100
see account of binkham what you want to

896
00:32:46,430 --> 00:32:51,470
look for is a DNS lookup for Canada CA

897
00:32:49,100 --> 00:32:54,679
that means it's actually decoding that

898
00:32:51,470 --> 00:32:56,150
character in the hostname into ASCII and

899
00:32:54,680 --> 00:32:56,710
then making a DNS lookup for the wrong

900
00:32:56,150 --> 00:32:59,840
thing

901
00:32:56,710 --> 00:33:01,160
the ideal result for this sort of a test

902
00:32:59,840 --> 00:33:03,649
case is that it just doesn't make the

903
00:33:01,160 --> 00:33:05,840
request but if it makes your request or

904
00:33:03,650 --> 00:33:08,710
a DNS lookup for some weird Unicode is

905
00:33:05,840 --> 00:33:11,060
subdomain of Bing comm that's also okay

906
00:33:08,710 --> 00:33:13,760
it's not ideal but it's probably not

907
00:33:11,060 --> 00:33:15,800
exploitable if you can't monitor a

908
00:33:13,760 --> 00:33:17,390
network traffic though there's a

909
00:33:15,800 --> 00:33:20,629
somewhat more complicated test case that

910
00:33:17,390 --> 00:33:23,000
you can use and that's this what you can

911
00:33:20,630 --> 00:33:24,650
do is you can go and register a couple

912
00:33:23,000 --> 00:33:27,200
of domains in here I'll call them a calm

913
00:33:24,650 --> 00:33:29,990
and be calm and free be calm you'll make

914
00:33:27,200 --> 00:33:31,550
a DNS wildcard record that says all

915
00:33:29,990 --> 00:33:33,530
subdomains of be com

916
00:33:31,550 --> 00:33:35,419
go to the same server and then for both

917
00:33:33,530 --> 00:33:36,649
a calm and be calm you'll set up servers

918
00:33:35,420 --> 00:33:38,450
that will just record all the network

919
00:33:36,650 --> 00:33:40,250
traffic that goes to them then you'll

920
00:33:38,450 --> 00:33:42,050
give a URL like this to the thing you're

921
00:33:40,250 --> 00:33:45,230
trying to test say it's someone else's

922
00:33:42,050 --> 00:33:47,419
web service where it's a calm and then a

923
00:33:45,230 --> 00:33:50,630
full-width solidus and then like X be

924
00:33:47,420 --> 00:33:53,360
calm and what this is going to do is if

925
00:33:50,630 --> 00:33:54,680
this is vulnerable to hosts split the

926
00:33:53,360 --> 00:33:56,000
software that you're looking at it's

927
00:33:54,680 --> 00:33:58,070
going to decode that full-width solidus

928
00:33:56,000 --> 00:34:00,560
into a forward slash and it will try to

929
00:33:58,070 --> 00:34:01,970
make a request to a calm if it's not

930
00:34:00,560 --> 00:34:03,620
vulnerable it either won't make a

931
00:34:01,970 --> 00:34:05,780
request or it'll make a request to be

932
00:34:03,620 --> 00:34:07,070
calm and since you're recording network

933
00:34:05,780 --> 00:34:10,969
traffic on both servers you know which

934
00:34:07,070 --> 00:34:13,460
one of those it did this lets you test

935
00:34:10,969 --> 00:34:18,290
things that you can directly monitor the

936
00:34:13,460 --> 00:34:20,570
traffic for host bond is a little more

937
00:34:18,290 --> 00:34:23,060
complicated to test for for host bond

938
00:34:20,570 --> 00:34:24,649
you need to consider cases where there

939
00:34:23,060 --> 00:34:26,330
might be an untrusted URL that's

940
00:34:24,649 --> 00:34:27,980
provided to your software that it's

941
00:34:26,330 --> 00:34:29,840
going to be converted to unicode this

942
00:34:27,980 --> 00:34:31,909
usually means that someone's providing

943
00:34:29,840 --> 00:34:35,750
you a URL that's going to show up inside

944
00:34:31,909 --> 00:34:37,370
of a GUI somewhere and once you've

945
00:34:35,750 --> 00:34:38,989
identified the cases where that's going

946
00:34:37,370 --> 00:34:40,969
to happen there's a lot of different

947
00:34:38,989 --> 00:34:43,370
test cases you need to try so there's a

948
00:34:40,969 --> 00:34:44,928
zero with joiner I mentioned so you can

949
00:34:43,370 --> 00:34:47,750
use a Punic coded 0 with joiner and

950
00:34:44,929 --> 00:34:49,490
there's an example here and that should

951
00:34:47,750 --> 00:34:50,629
not be rendered as a zero with joiner

952
00:34:49,489 --> 00:34:52,790
that should always either show off this

953
00:34:50,629 --> 00:34:54,139
Punic code not be rendered but it should

954
00:34:52,790 --> 00:34:57,000
never happen that it just turns into

955
00:34:54,139 --> 00:34:59,340
something that looks like it's not there

956
00:34:57,000 --> 00:35:00,480
you can also you should also test what

957
00:34:59,340 --> 00:35:02,820
I'm calling the bubble numbers these are

958
00:35:00,480 --> 00:35:04,890
unicode characters that are essentially

959
00:35:02,820 --> 00:35:07,350
numerals with circles around them they

960
00:35:04,890 --> 00:35:08,879
normalized to just asking numerals so

961
00:35:07,350 --> 00:35:12,839
sometimes you'll see essentially a

962
00:35:08,880 --> 00:35:14,220
2-step normalization and for those what

963
00:35:12,840 --> 00:35:16,080
you want is essentially that it's either

964
00:35:14,220 --> 00:35:18,060
rejected or it shows up as Punic code it

965
00:35:16,080 --> 00:35:19,950
shouldn't show up as the circled numeral

966
00:35:18,060 --> 00:35:22,380
and it should not show up as just an

967
00:35:19,950 --> 00:35:25,319
ASCII numeral finally there's the Greek

968
00:35:22,380 --> 00:35:27,180
question mark character which is kind of

969
00:35:25,320 --> 00:35:28,770
a magical unicode character that lots of

970
00:35:27,180 --> 00:35:30,029
software likes to turn into semicolons

971
00:35:28,770 --> 00:35:33,660
even if it's not trying to do

972
00:35:30,030 --> 00:35:35,160
normalization for complicated reasons so

973
00:35:33,660 --> 00:35:36,629
you computer code one of those and if

974
00:35:35,160 --> 00:35:39,089
you stick that in a host name it should

975
00:35:36,630 --> 00:35:40,770
never look like a semicolon anything

976
00:35:39,090 --> 00:35:43,350
that looks like a semicolon from that

977
00:35:40,770 --> 00:35:44,490
Punic code is a vulnerability and this

978
00:35:43,350 --> 00:35:46,980
is a sort of thing that you might use to

979
00:35:44,490 --> 00:35:48,660
attack lists of host names or maybe

980
00:35:46,980 --> 00:35:53,010
email where you have semicolons to

981
00:35:48,660 --> 00:35:54,569
separate different things and you also

982
00:35:53,010 --> 00:35:56,490
need to remember that the host spawned

983
00:35:54,570 --> 00:35:59,430
vulnerability is not just a web

984
00:35:56,490 --> 00:36:00,930
vulnerability so I explained earlier how

985
00:35:59,430 --> 00:36:02,580
this could be used against email but a

986
00:36:00,930 --> 00:36:05,460
host bond can also be used as an attack

987
00:36:02,580 --> 00:36:07,460
against I am protocols like sip or other

988
00:36:05,460 --> 00:36:10,080
network protocols that use host names

989
00:36:07,460 --> 00:36:13,200
either directly or an email addresses or

990
00:36:10,080 --> 00:36:15,390
something like that one useful test case

991
00:36:13,200 --> 00:36:17,819
for host bond if you're using it with or

992
00:36:15,390 --> 00:36:19,500
trying to test email is to essentially

993
00:36:17,820 --> 00:36:22,350
send email to an email address you

994
00:36:19,500 --> 00:36:24,900
control but at a second recipient which

995
00:36:22,350 --> 00:36:27,390
has one of these vApp unicode host names

996
00:36:24,900 --> 00:36:29,070
in it it probably won't receive email

997
00:36:27,390 --> 00:36:31,350
but you can see what it looks like when

998
00:36:29,070 --> 00:36:33,210
you receive the email and if that second

999
00:36:31,350 --> 00:36:35,040
recipient shows up with the bad punic

1000
00:36:33,210 --> 00:36:39,030
code it decoded that's also a

1001
00:36:35,040 --> 00:36:40,500
vulnerability okay so that's how you

1002
00:36:39,030 --> 00:36:43,080
test for this what are some best

1003
00:36:40,500 --> 00:36:44,610
practices for preventing this

1004
00:36:43,080 --> 00:36:47,640
vulnerability or fixing it in your

1005
00:36:44,610 --> 00:36:48,740
software well first and this is

1006
00:36:47,640 --> 00:36:50,910
something I really want to emphasize

1007
00:36:48,740 --> 00:36:54,080
software needs to make all of its

1008
00:36:50,910 --> 00:36:56,069
decisions about host names using ASCII

1009
00:36:54,080 --> 00:36:57,660
most software if it's dealing with a

1010
00:36:56,070 --> 00:37:00,210
host name has something that's just a

1011
00:36:57,660 --> 00:37:02,670
string some type called string maybe and

1012
00:37:00,210 --> 00:37:05,490
it's not thinking about well is this an

1013
00:37:02,670 --> 00:37:06,630
ascii URL is this a unicode URL so if

1014
00:37:05,490 --> 00:37:08,520
you're doing some sort of a comparison

1015
00:37:06,630 --> 00:37:10,870
or a regular expression against a

1016
00:37:08,520 --> 00:37:13,900
hostname before you do that you

1017
00:37:10,870 --> 00:37:15,130
must convert it to an ascii hostname if

1018
00:37:13,900 --> 00:37:17,050
this is something you can set as a

1019
00:37:15,130 --> 00:37:20,680
security policy it's a good rule only

1020
00:37:17,050 --> 00:37:22,540
compare host names as ascii lots of code

1021
00:37:20,680 --> 00:37:24,250
does this wrong lots of platform code

1022
00:37:22,540 --> 00:37:28,870
does this wrong this is really pervasive

1023
00:37:24,250 --> 00:37:30,880
as a vulnerability second if you're

1024
00:37:28,870 --> 00:37:33,279
doing conversions in your own software

1025
00:37:30,880 --> 00:37:35,020
between unicode and ascii host names you

1026
00:37:33,280 --> 00:37:38,500
need to use the STD three ASCII Rules

1027
00:37:35,020 --> 00:37:40,060
flag if you're using the STD three ASCII

1028
00:37:38,500 --> 00:37:41,740
rules flag and you try to convert a

1029
00:37:40,060 --> 00:37:43,570
Unicode hostname to an ASCII hostname

1030
00:37:41,740 --> 00:37:45,040
and it's going to introduce some syntax

1031
00:37:43,570 --> 00:37:48,190
character like a forward slash

1032
00:37:45,040 --> 00:37:49,720
it'll just fail this does mean that you

1033
00:37:48,190 --> 00:37:51,940
can no longer talk to host names that

1034
00:37:49,720 --> 00:37:53,709
contain underscores you might want to

1035
00:37:51,940 --> 00:37:55,240
set a policy that says we don't make

1036
00:37:53,710 --> 00:38:00,160
host names with underscores anymore it

1037
00:37:55,240 --> 00:38:02,350
makes this issue easier to fix finally

1038
00:38:00,160 --> 00:38:04,410
you might have code that relies on

1039
00:38:02,350 --> 00:38:06,819
platform code that's already vulnerable

1040
00:38:04,410 --> 00:38:09,730
there's lots of api's out there that are

1041
00:38:06,820 --> 00:38:11,500
vulnerable to host split what you can do

1042
00:38:09,730 --> 00:38:13,150
is write a wrapper function that says

1043
00:38:11,500 --> 00:38:15,310
before I call this API I'm going to make

1044
00:38:13,150 --> 00:38:17,650
sure the URL I passed to it isn't going

1045
00:38:15,310 --> 00:38:19,930
to cause a hosted vulnerability so what

1046
00:38:17,650 --> 00:38:22,600
you can do is essentially do an ASCII

1047
00:38:19,930 --> 00:38:23,830
conversion yourself on just the host

1048
00:38:22,600 --> 00:38:26,350
name and see if the host name you end up

1049
00:38:23,830 --> 00:38:27,640
with contains syntax characters or you

1050
00:38:26,350 --> 00:38:29,080
can just use the STD three off scheme

1051
00:38:27,640 --> 00:38:32,500
Google's five when you do that before

1052
00:38:29,080 --> 00:38:34,270
you pass it off to the platform code for

1053
00:38:32,500 --> 00:38:35,650
the other side of things for host pond

1054
00:38:34,270 --> 00:38:38,650
vulnerabilities you need to worry about

1055
00:38:35,650 --> 00:38:41,610
cases where an ASCII URL is being passed

1056
00:38:38,650 --> 00:38:44,710
to something maybe just a URL string

1057
00:38:41,610 --> 00:38:46,510
that's going to display it or otherwise

1058
00:38:44,710 --> 00:38:47,680
deal with it might convert it to Unicode

1059
00:38:46,510 --> 00:38:49,210
a lot of how this is going to be

1060
00:38:47,680 --> 00:38:52,029
controls of different sort that you

1061
00:38:49,210 --> 00:38:54,220
might be using if you're going to pass a

1062
00:38:52,030 --> 00:38:56,350
hostname off to a control what you want

1063
00:38:54,220 --> 00:38:58,569
to do is essentially try converting it

1064
00:38:56,350 --> 00:39:00,130
to Unicode if it's punic code and then

1065
00:38:58,570 --> 00:39:01,300
convert it back to ASCII and make sure

1066
00:39:00,130 --> 00:39:04,990
you end up with the same thing you

1067
00:39:01,300 --> 00:39:06,580
started with if the host name you end up

1068
00:39:04,990 --> 00:39:09,100
with at the end isn't what you started

1069
00:39:06,580 --> 00:39:10,779
with you want to just throw away the URL

1070
00:39:09,100 --> 00:39:12,279
not hand it off to the control not hand

1071
00:39:10,780 --> 00:39:14,140
it off to the API so your wrapper

1072
00:39:12,280 --> 00:39:16,530
function prevents about the thing from

1073
00:39:14,140 --> 00:39:16,529
happening

1074
00:39:17,800 --> 00:39:21,040
so I'm hoping that people in this

1075
00:39:19,480 --> 00:39:23,620
audience people who see this talk though

1076
00:39:21,040 --> 00:39:25,029
and make this better please test your

1077
00:39:23,620 --> 00:39:27,819
software for Unicode normalization

1078
00:39:25,030 --> 00:39:30,970
vulnerabilities please only compare host

1079
00:39:27,820 --> 00:39:32,890
names as ASCII make a policy for that if

1080
00:39:30,970 --> 00:39:34,390
it's something that you can do and if

1081
00:39:32,890 --> 00:39:35,290
you're someone who attacks things if

1082
00:39:34,390 --> 00:39:37,779
you're on the other side of things

1083
00:39:35,290 --> 00:39:39,610
please go get bounties with this this

1084
00:39:37,780 --> 00:39:41,710
vulnerability has worked in almost

1085
00:39:39,610 --> 00:39:43,240
everything I've looked at and so I'm

1086
00:39:41,710 --> 00:39:44,830
expecting it still works in a lot of a

1087
00:39:43,240 --> 00:39:46,029
lot of things I haven't looked at all

1088
00:39:44,830 --> 00:39:48,279
the software out there I haven't even

1089
00:39:46,030 --> 00:39:50,710
looked at most of the platforms people

1090
00:39:48,280 --> 00:39:52,750
build web services on so there's

1091
00:39:50,710 --> 00:39:54,730
probably lots of places you can go and

1092
00:39:52,750 --> 00:39:56,800
get fun CVEs maybe some money out of

1093
00:39:54,730 --> 00:39:58,270
this and if you do that people will pay

1094
00:39:56,800 --> 00:40:03,850
attention and this will also start to

1095
00:39:58,270 --> 00:40:06,310
get better and that's my goal for the

1096
00:40:03,850 --> 00:40:09,000
day and that's all I had to say so are

1097
00:40:06,310 --> 00:40:19,759
there any questions from that

1098
00:40:09,000 --> 00:40:19,760
[Applause]

