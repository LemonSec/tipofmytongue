1
00:00:00,030 --> 00:00:05,700
good afternoon welcome to periscope an

2
00:00:03,060 --> 00:00:07,890
effective probing and fuzzing network

3
00:00:05,700 --> 00:00:11,490
for hardware for the Hardware OS

4
00:00:07,890 --> 00:00:15,410
boundary we're in the Jasmine room the

5
00:00:11,490 --> 00:00:18,529
speaker this afternoon is doc young song

6
00:00:15,410 --> 00:00:21,000
and a couple of notes before we begin

7
00:00:18,529 --> 00:00:23,279
please stop by the business hall it's

8
00:00:21,000 --> 00:00:26,039
located in a Mandalay Bay Oceanside and

9
00:00:23,279 --> 00:00:28,019
shoreline ballrooms and level 2 you can

10
00:00:26,039 --> 00:00:29,580
stop by during the day and then this

11
00:00:28,019 --> 00:00:30,330
evening there's the Welcome Reception of

12
00:00:29,580 --> 00:00:33,180
5:30

13
00:00:30,330 --> 00:00:36,690
also the blackhat Arsenal is in the

14
00:00:33,180 --> 00:00:39,210
business hall on level 2 finally join us

15
00:00:36,690 --> 00:00:44,670
for the pony Awards in the lagoon JKL

16
00:00:39,210 --> 00:00:46,829
and at 18:30 just out of courtesy to

17
00:00:44,670 --> 00:00:49,920
your fellow attendees please put your

18
00:00:46,829 --> 00:00:51,420
phone on vibrate and if you have

19
00:00:49,920 --> 00:00:53,670
questions at the end of the session

20
00:00:51,420 --> 00:00:56,430
there are microphones located on either

21
00:00:53,670 --> 00:00:58,680
side so please use the microphones to

22
00:00:56,430 --> 00:01:08,130
ask any questions and with that I'd like

23
00:00:58,680 --> 00:01:10,170
to invite up to the stage thank you for

24
00:01:08,130 --> 00:01:13,649
the introduction I'm talking song I'm a

25
00:01:10,170 --> 00:01:15,540
PhD student at UC Irvine I'm gonna

26
00:01:13,650 --> 00:01:17,430
present our work periscope

27
00:01:15,540 --> 00:01:19,530
an effective probing and fuzzing

28
00:01:17,430 --> 00:01:22,229
framework for the Hardware OS boundary

29
00:01:19,530 --> 00:01:24,869
so this work is a joint work with my

30
00:01:22,229 --> 00:01:27,590
collaborators from UC Irvine T Oberlin

31
00:01:24,869 --> 00:01:30,600
Missy Santa Barbara and ko Lubin

32
00:01:27,590 --> 00:01:33,240
so today the security of peripheral

33
00:01:30,600 --> 00:01:35,298
devices remains questionable as has been

34
00:01:33,240 --> 00:01:38,548
demonstrated by security researchers

35
00:01:35,299 --> 00:01:41,130
peripheral chips such as Wi-Fi chips or

36
00:01:38,549 --> 00:01:43,439
basement chips that expose an interface

37
00:01:41,130 --> 00:01:46,170
to the external world can be compromised

38
00:01:43,439 --> 00:01:49,139
over-the-air by just sending maliciously

39
00:01:46,170 --> 00:01:51,720
crafted packets to the device so all

40
00:01:49,140 --> 00:01:54,240
that was needed was proximity with the

41
00:01:51,720 --> 00:01:57,750
victim device that has its Wi-Fi or

42
00:01:54,240 --> 00:02:00,240
cellular network enabled so let me give

43
00:01:57,750 --> 00:02:03,210
you a couple of examples here so a

44
00:02:00,240 --> 00:02:05,939
prominent example of a porifera TAC is

45
00:02:03,210 --> 00:02:08,940
it is the broadband attack presented

46
00:02:05,939 --> 00:02:11,280
here at blackhat two years ago the

47
00:02:08,940 --> 00:02:14,130
attack demonstrated what they call is a

48
00:02:11,280 --> 00:02:17,790
fully remote exploit fully remote in

49
00:02:14,130 --> 00:02:18,960
that they do not require any user

50
00:02:17,790 --> 00:02:21,510
interaction at all

51
00:02:18,960 --> 00:02:23,550
so the vulnerability triggered and

52
00:02:21,510 --> 00:02:26,940
Exploited here is in the association

53
00:02:23,550 --> 00:02:28,800
process of the Wi-Fi protocol that does

54
00:02:26,940 --> 00:02:33,150
not require any user interaction nor

55
00:02:28,800 --> 00:02:35,460
authentication so with arbitrary code

56
00:02:33,150 --> 00:02:37,890
execution on the Wi-Fi chip this

57
00:02:35,460 --> 00:02:39,960
specific attack demonstrated a worm

58
00:02:37,890 --> 00:02:43,320
attack that surprised across different

59
00:02:39,960 --> 00:02:45,570
devices nearby and this slide shows a

60
00:02:43,320 --> 00:02:48,810
vulnerability that was used in a

61
00:02:45,570 --> 00:02:51,000
baseband exploit at demonstrated at

62
00:02:48,810 --> 00:02:52,530
mobile point to home and it was

63
00:02:51,000 --> 00:02:55,110
demonstrated that this vulnerability

64
00:02:52,530 --> 00:02:57,300
allows arbitrary code execution and

65
00:02:55,110 --> 00:02:59,730
arbitrary code execution was

66
00:02:57,300 --> 00:03:02,460
demonstrated by writing a file to a file

67
00:02:59,730 --> 00:03:05,130
system that the baseband chip had access

68
00:03:02,460 --> 00:03:07,590
to so what these attacks have in common

69
00:03:05,130 --> 00:03:10,500
is that they compromised peripheral

70
00:03:07,590 --> 00:03:13,920
devices without coming to physical

71
00:03:10,500 --> 00:03:15,780
contact with the peripheral device when

72
00:03:13,920 --> 00:03:19,890
you think about other peripheral attacks

73
00:03:15,780 --> 00:03:22,350
like USB attacks they depend on the

74
00:03:19,890 --> 00:03:26,010
victim plugging in the malicious DSP

75
00:03:22,350 --> 00:03:28,500
devices people actually do plug them in

76
00:03:26,010 --> 00:03:30,359
unfortunately but still remote

77
00:03:28,500 --> 00:03:33,740
peripheral attacks are probably more

78
00:03:30,360 --> 00:03:37,140
dangerous because they are more stealthy

79
00:03:33,740 --> 00:03:39,510
so with a peripheral compromise how can

80
00:03:37,140 --> 00:03:41,160
the attacker can compromise the

81
00:03:39,510 --> 00:03:44,160
operating system running on the main

82
00:03:41,160 --> 00:03:46,650
processor after compromising peripheral

83
00:03:44,160 --> 00:03:50,549
device the attacker is faced with what's

84
00:03:46,650 --> 00:03:52,890
called Hardware West interface just like

85
00:03:50,550 --> 00:03:55,320
iOS kernels protect themselves from user

86
00:03:52,890 --> 00:03:57,660
space processes at the boundary of the

87
00:03:55,320 --> 00:03:59,700
system call interface at this boundary

88
00:03:57,660 --> 00:04:04,170
of the Hardware OS interface they

89
00:03:59,700 --> 00:04:07,560
protect from peripheral devices that

90
00:04:04,170 --> 00:04:11,640
could potentially turn malicious so

91
00:04:07,560 --> 00:04:13,740
among others there are two mechanisms of

92
00:04:11,640 --> 00:04:17,209
implementing the hardware os interface

93
00:04:13,740 --> 00:04:19,829
or the devices attached to the PCI bus

94
00:04:17,209 --> 00:04:22,560
memory mapped i/o and direct memory

95
00:04:19,829 --> 00:04:24,419
access so in memory mapped i/o the

96
00:04:22,560 --> 00:04:24,990
device and the driver communicate with

97
00:04:24,419 --> 00:04:27,060
each other

98
00:04:24,990 --> 00:04:29,490
by writing to and reading from device

99
00:04:27,060 --> 00:04:31,620
memory and in the case of direct memory

100
00:04:29,490 --> 00:04:34,860
access the communication medium is

101
00:04:31,620 --> 00:04:36,900
memory pages in the main memory so by

102
00:04:34,860 --> 00:04:39,330
compromising this Hardware West

103
00:04:36,900 --> 00:04:42,030
interface the attacker can effectively

104
00:04:39,330 --> 00:04:45,030
turn a peripheral compromised into a

105
00:04:42,030 --> 00:04:47,130
full operating system compromised so

106
00:04:45,030 --> 00:04:49,380
given the importance of this hardware

107
00:04:47,130 --> 00:04:52,800
with the interface as well as the real

108
00:04:49,380 --> 00:04:55,950
threat posed by recent attacks in our

109
00:04:52,800 --> 00:05:00,210
work we aim to analyze the security of

110
00:04:55,950 --> 00:05:01,979
this Hardware of Hardware OS interface

111
00:05:00,210 --> 00:05:05,219
operating under the following threat

112
00:05:01,979 --> 00:05:07,430
model so we assume that the attacker has

113
00:05:05,220 --> 00:05:11,070
compromised the device and can write

114
00:05:07,430 --> 00:05:14,850
malicious values in both MMA oh and DMA

115
00:05:11,070 --> 00:05:17,479
mappings so our goal by analyzing this

116
00:05:14,850 --> 00:05:19,710
Hardware OS interface is to discover

117
00:05:17,479 --> 00:05:22,020
vulnerabilities in the driver in the

118
00:05:19,710 --> 00:05:23,940
kernel which can be triggered and

119
00:05:22,020 --> 00:05:27,960
exploited by an attacker on a

120
00:05:23,940 --> 00:05:29,969
compromised device let me take a step

121
00:05:27,960 --> 00:05:32,310
back here a bit to provide you with a

122
00:05:29,970 --> 00:05:35,460
more complete and detailed picture of

123
00:05:32,310 --> 00:05:37,680
the OS kernel attack surface so as we

124
00:05:35,460 --> 00:05:39,299
all know besides the hardware west

125
00:05:37,680 --> 00:05:41,789
boundary there is a more conventional

126
00:05:39,300 --> 00:05:44,700
attack surface which is the system call

127
00:05:41,789 --> 00:05:48,000
boundary and speaking of Android these

128
00:05:44,700 --> 00:05:50,520
days there are a diverse set of sand

129
00:05:48,000 --> 00:05:53,280
boxes deployed to narrow down this

130
00:05:50,520 --> 00:05:55,950
system called attack surface exposed to

131
00:05:53,280 --> 00:05:59,010
user space adversaries for example apps

132
00:05:55,950 --> 00:06:00,950
are strongly sandbox the discretionary

133
00:05:59,010 --> 00:06:04,860
and mandatory access control and

134
00:06:00,950 --> 00:06:07,860
potentially more dangerous code such as

135
00:06:04,860 --> 00:06:10,860
JavaScript code runs in a stronger

136
00:06:07,860 --> 00:06:13,080
sandbox and most of our kernel drivers

137
00:06:10,860 --> 00:06:16,950
are behind the hardware abstraction

138
00:06:13,080 --> 00:06:19,710
layer and accesses to IO devices are

139
00:06:16,950 --> 00:06:22,229
mediated through the slightly more

140
00:06:19,710 --> 00:06:24,270
privileged user space daemons which

141
00:06:22,229 --> 00:06:27,300
means that you need to first compromise

142
00:06:24,270 --> 00:06:31,409
those demons to even start talking to an

143
00:06:27,300 --> 00:06:33,990
IO kernel driver Hardware OS boundary on

144
00:06:31,410 --> 00:06:37,200
the other hand does have an isolation

145
00:06:33,990 --> 00:06:39,690
mechanism iommu and basically iommu

146
00:06:37,200 --> 00:06:40,039
limits the memory regions that can be

147
00:06:39,690 --> 00:06:42,590
asked

148
00:06:40,040 --> 00:06:45,440
by a peripheral device to only those

149
00:06:42,590 --> 00:06:49,549
regions that are explicitly mapped by

150
00:06:45,440 --> 00:06:52,610
the operating system but still with

151
00:06:49,550 --> 00:06:55,700
iommu a peripheral device basically

152
00:06:52,610 --> 00:06:58,550
still talks directly to the kernel

153
00:06:55,700 --> 00:07:01,159
driver with the running with the kernel

154
00:06:58,550 --> 00:07:03,350
privilege on the main processor at least

155
00:07:01,160 --> 00:07:07,310
in the monolithic mainstream operating

156
00:07:03,350 --> 00:07:09,560
system kernels and there are two ways to

157
00:07:07,310 --> 00:07:12,890
reach these OS kernel attack surfaces

158
00:07:09,560 --> 00:07:14,990
our first is it through user space

159
00:07:12,890 --> 00:07:17,599
processes and all and the second is

160
00:07:14,990 --> 00:07:19,400
through a pray for our farming so how

161
00:07:17,600 --> 00:07:23,570
difficult would it be given a memory

162
00:07:19,400 --> 00:07:26,450
error to exploit to compromise either

163
00:07:23,570 --> 00:07:29,060
user space processes or prefer a form

164
00:07:26,450 --> 00:07:31,400
where if you look at memory exploit

165
00:07:29,060 --> 00:07:33,620
mitigations deployed and to protect user

166
00:07:31,400 --> 00:07:35,570
space processes and to protect a

167
00:07:33,620 --> 00:07:38,540
peripheral form where the differences

168
00:07:35,570 --> 00:07:40,490
are quite significant so in fact one of

169
00:07:38,540 --> 00:07:42,710
the major enabling regions for for

170
00:07:40,490 --> 00:07:45,110
peripheral compromise is that peripheral

171
00:07:42,710 --> 00:07:47,870
devices are typically resource

172
00:07:45,110 --> 00:07:49,730
constrained and they lack basic memory

173
00:07:47,870 --> 00:07:53,210
exploit mitigation mechanisms such as

174
00:07:49,730 --> 00:07:56,000
data execution prevention or address

175
00:07:53,210 --> 00:07:58,969
space layout randomization so peripheral

176
00:07:56,000 --> 00:08:03,260
farmer runs on microcontrollers which

177
00:07:58,970 --> 00:08:06,380
often black MMU or user mode supervisor

178
00:08:03,260 --> 00:08:09,110
mode separation for example the Broadcom

179
00:08:06,380 --> 00:08:11,690
Wi-Fi chip that was targeted in the

180
00:08:09,110 --> 00:08:15,800
broad on attack for example had its

181
00:08:11,690 --> 00:08:18,200
entire ram read write executable in

182
00:08:15,800 --> 00:08:20,960
contrast user space programs in android

183
00:08:18,200 --> 00:08:23,420
running on the capable arm v8 main

184
00:08:20,960 --> 00:08:25,760
processor have all the commodity

185
00:08:23,420 --> 00:08:28,940
mitigation mechanisms turned on control

186
00:08:25,760 --> 00:08:31,010
flow integrity ASR RDP and secure

187
00:08:28,940 --> 00:08:33,159
hardened heap allocator and so on

188
00:08:31,010 --> 00:08:36,200
so it makes sense for an attacker

189
00:08:33,159 --> 00:08:38,569
looking to compromise an operating

190
00:08:36,200 --> 00:08:45,290
system to turn to peripheral attack

191
00:08:38,570 --> 00:08:47,270
surface so for these two peripheral for

192
00:08:45,290 --> 00:08:50,420
these two attack surfaces two OS kernel

193
00:08:47,270 --> 00:08:51,949
there are many analysis tools available

194
00:08:50,420 --> 00:08:54,319
already

195
00:08:51,950 --> 00:08:57,020
examples include sis color the popular

196
00:08:54,320 --> 00:08:59,240
kernel buzzer that primarily targets the

197
00:08:57,020 --> 00:09:02,870
system call interface which now has the

198
00:08:59,240 --> 00:09:05,540
USB fuzzing support here we add our tool

199
00:09:02,870 --> 00:09:07,250
periscope that can complement existing

200
00:09:05,540 --> 00:09:10,459
approaches that can analyze hardware

201
00:09:07,250 --> 00:09:12,680
West interface now let me get back to

202
00:09:10,460 --> 00:09:16,010
our focus Hardware OS boundary and

203
00:09:12,680 --> 00:09:18,410
explain in more detail what existing

204
00:09:16,010 --> 00:09:20,240
approaches are and how periscope can be

205
00:09:18,410 --> 00:09:22,790
useful in light of these existing

206
00:09:20,240 --> 00:09:24,800
approaches so the first approach we find

207
00:09:22,790 --> 00:09:27,770
is a device of that patient approach

208
00:09:24,800 --> 00:09:31,490
that adapts or reprograms the device

209
00:09:27,770 --> 00:09:34,340
such that it can send arbitrary values

210
00:09:31,490 --> 00:09:37,640
to the driver and examines drivers

211
00:09:34,340 --> 00:09:40,550
response while not interested and can be

212
00:09:37,640 --> 00:09:42,740
always independent the effort is device

213
00:09:40,550 --> 00:09:45,439
specific which needs to be duplicated

214
00:09:42,740 --> 00:09:48,010
for each and individual device which

215
00:09:45,440 --> 00:09:50,390
does not scale given a large number of

216
00:09:48,010 --> 00:09:53,630
proprietary devices that are out there

217
00:09:50,390 --> 00:09:56,210
it has also it has limited visibility

218
00:09:53,630 --> 00:09:59,980
into the drivers behavior the second

219
00:09:56,210 --> 00:09:59,980
approach we find is the dynamic approach

220
00:10:00,490 --> 00:10:05,510
the second approach we find is a virtual

221
00:10:03,380 --> 00:10:07,790
machine based approach where the analyst

222
00:10:05,510 --> 00:10:10,010
runs the entire system including the

223
00:10:07,790 --> 00:10:12,890
device and the driver on a virtualized

224
00:10:10,010 --> 00:10:15,350
environment while virtual machine

225
00:10:12,890 --> 00:10:18,590
provides convenient mechanisms to

226
00:10:15,350 --> 00:10:21,140
interpose the execution of its guests it

227
00:10:18,590 --> 00:10:23,600
requires either emulated device or

228
00:10:21,140 --> 00:10:25,840
hardware virtualization support this can

229
00:10:23,600 --> 00:10:28,010
be problematic because in many cases

230
00:10:25,840 --> 00:10:30,670
emulated device implementation is not

231
00:10:28,010 --> 00:10:33,740
available and in some platforms

232
00:10:30,670 --> 00:10:36,290
hypervisor level access is not exposed

233
00:10:33,740 --> 00:10:39,830
and users for example in production

234
00:10:36,290 --> 00:10:41,750
smartphones the third approach we find

235
00:10:39,830 --> 00:10:43,880
is a symbolic execution based approach

236
00:10:41,750 --> 00:10:46,940
which removes the need for devices

237
00:10:43,880 --> 00:10:49,310
altogether and instead it replaces IO

238
00:10:46,940 --> 00:10:53,330
mappings with symbolic unconstrained

239
00:10:49,310 --> 00:10:55,790
symbolic variables so but inherits

240
00:10:53,330 --> 00:10:58,360
inherits though the downside of symbolic

241
00:10:55,790 --> 00:11:01,699
execution it may not scale well to a

242
00:10:58,360 --> 00:11:06,040
real-world large device driver because

243
00:11:01,700 --> 00:11:09,830
of for example constrain solving cost

244
00:11:06,040 --> 00:11:11,719
our approach is an internal dynamic

245
00:11:09,830 --> 00:11:14,180
approach which does not require any

246
00:11:11,720 --> 00:11:17,240
change on the device side nor does it

247
00:11:14,180 --> 00:11:20,270
require any new card require the system

248
00:11:17,240 --> 00:11:22,220
to run in a virtualized environment what

249
00:11:20,270 --> 00:11:24,740
it in cell requires because it's an

250
00:11:22,220 --> 00:11:27,170
internal approach is recompilation of

251
00:11:24,740 --> 00:11:31,400
the kernel as long as the kernel can get

252
00:11:27,170 --> 00:11:34,130
recompiled and can be flashed periscope

253
00:11:31,400 --> 00:11:37,490
can be useful in many existing testing

254
00:11:34,130 --> 00:11:39,560
environments regardless of whether the

255
00:11:37,490 --> 00:11:42,080
underlying device is Hardware

256
00:11:39,560 --> 00:11:46,069
virtualized emulated or running on bare

257
00:11:42,080 --> 00:11:49,510
metal so based on the observation that

258
00:11:46,070 --> 00:11:51,320
both mm IO and DMA are memory based

259
00:11:49,510 --> 00:11:53,750
communication at least from the

260
00:11:51,320 --> 00:11:56,090
perspective of the main processor we

261
00:11:53,750 --> 00:11:58,160
take a page v page fault based

262
00:11:56,090 --> 00:12:00,110
monitoring approach to interpose the

263
00:11:58,160 --> 00:12:04,760
interactions between the device and the

264
00:12:00,110 --> 00:12:07,280
driver this allows us to examine and

265
00:12:04,760 --> 00:12:10,010
potentially to influence the traffic

266
00:12:07,280 --> 00:12:12,860
between the device and the driver at a

267
00:12:10,010 --> 00:12:14,720
very fine grain grain granularity

268
00:12:12,860 --> 00:12:18,380
basically at the level of individual

269
00:12:14,720 --> 00:12:21,620
memory accesses and all within the

270
00:12:18,380 --> 00:12:23,750
kernel so here is the overview of how

271
00:12:21,620 --> 00:12:25,970
periscope works first when the device

272
00:12:23,750 --> 00:12:29,300
driver allocates either mmio

273
00:12:25,970 --> 00:12:31,850
and DMA mappings periscope marks these

274
00:12:29,300 --> 00:12:33,890
allocated pages as not present by

275
00:12:31,850 --> 00:12:36,740
modifying the corresponding page table

276
00:12:33,890 --> 00:12:39,410
entries in the page table we do so by

277
00:12:36,740 --> 00:12:43,370
hooking into the kernels anime oh and

278
00:12:39,410 --> 00:12:46,459
DMA allocation api's and when the device

279
00:12:43,370 --> 00:12:48,980
driver later accesses these Mme oh and

280
00:12:46,460 --> 00:12:53,020
DMA mappings page fault exceptions will

281
00:12:48,980 --> 00:12:56,120
be triggered and control flows into the

282
00:12:53,020 --> 00:12:58,490
kernels page fault handler we hook into

283
00:12:56,120 --> 00:13:00,950
this kernel page fault handler to call

284
00:12:58,490 --> 00:13:03,590
our page fault handler in which we

285
00:13:00,950 --> 00:13:06,320
examine the fault and call user

286
00:13:03,590 --> 00:13:08,710
registered hooks that can be implemented

287
00:13:06,320 --> 00:13:12,020
by the analyst for a wide variety of

288
00:13:08,710 --> 00:13:15,140
analysis purposes and then periscope

289
00:13:12,020 --> 00:13:18,500
transfers the control back to the device

290
00:13:15,140 --> 00:13:21,560
driver to resume its normal execution

291
00:13:18,500 --> 00:13:24,020
so on top of this framework we designed

292
00:13:21,560 --> 00:13:26,599
and implemented paraquad's a father that

293
00:13:24,020 --> 00:13:29,329
enables adversarial analysis of the

294
00:13:26,600 --> 00:13:31,640
Hardware OS boundary so the goal of para

295
00:13:29,330 --> 00:13:33,830
fuss as I mentioned is to find

296
00:13:31,640 --> 00:13:36,650
vulnerabilities in the in the driver

297
00:13:33,830 --> 00:13:38,810
they can be triggered and potentially

298
00:13:36,650 --> 00:13:41,569
exploited by an attacker on a

299
00:13:38,810 --> 00:13:43,969
compromised device so there are four

300
00:13:41,570 --> 00:13:47,750
peripherals for these drivers read

301
00:13:43,970 --> 00:13:51,050
accesses to MMM IO and DMA mappings

302
00:13:47,750 --> 00:13:53,090
because the values being read by the

303
00:13:51,050 --> 00:13:57,109
device driver can be under the attackers

304
00:13:53,090 --> 00:14:00,140
control under our threat model to this

305
00:13:57,110 --> 00:14:02,630
and para files implements a custom hook

306
00:14:00,140 --> 00:14:05,120
that is registered with the periscope

307
00:14:02,630 --> 00:14:08,480
framework so the winner whenever a

308
00:14:05,120 --> 00:14:11,570
driver makes a read access to an IO

309
00:14:08,480 --> 00:14:14,540
netting the hook requests fuzzing that

310
00:14:11,570 --> 00:14:17,270
read access that's being made so the

311
00:14:14,540 --> 00:14:20,240
injector component of para fuss receives

312
00:14:17,270 --> 00:14:23,300
an input generated by the phaser running

313
00:14:20,240 --> 00:14:25,970
in user space and injects the fodder

314
00:14:23,300 --> 00:14:28,780
supplied value to the destination

315
00:14:25,970 --> 00:14:32,660
register of defaulting instruction and

316
00:14:28,780 --> 00:14:34,760
it resumes drivers execution from the

317
00:14:32,660 --> 00:14:37,730
instruction that immediately follows

318
00:14:34,760 --> 00:14:39,230
defaulting instruction because now the

319
00:14:37,730 --> 00:14:42,980
faulting instruction has now been

320
00:14:39,230 --> 00:14:45,740
emulated or fast so the same procedure

321
00:14:42,980 --> 00:14:49,070
repeats for each drivers read access

322
00:14:45,740 --> 00:14:51,590
until the injected value leads to any

323
00:14:49,070 --> 00:14:54,800
observable error such as a second

324
00:14:51,590 --> 00:14:56,720
segmentation fault before explaining our

325
00:14:54,800 --> 00:14:59,240
fuzzing in more detail

326
00:14:56,720 --> 00:15:02,600
let me quickly review our threat model

327
00:14:59,240 --> 00:15:04,880
in more detail since peripheral devices

328
00:15:02,600 --> 00:15:07,790
and device drivers on the main processor

329
00:15:04,880 --> 00:15:10,880
each runs on a separate processor

330
00:15:07,790 --> 00:15:14,270
operating on their own clock the

331
00:15:10,880 --> 00:15:17,060
attacker cannot only write any value to

332
00:15:14,270 --> 00:15:20,180
the i/o mapping but also at any time

333
00:15:17,060 --> 00:15:23,989
even multiple times and potentially in

334
00:15:20,180 --> 00:15:26,479
between drivers read accesses so this

335
00:15:23,990 --> 00:15:28,700
adversarial capability creates a

336
00:15:26,480 --> 00:15:31,010
possibility of double fetch box in

337
00:15:28,700 --> 00:15:33,440
drivers handling IO

338
00:15:31,010 --> 00:15:35,930
mappings so double fetch bugs are a

339
00:15:33,440 --> 00:15:38,240
class of time of check - time of use

340
00:15:35,930 --> 00:15:40,489
race conditions and let me give you a

341
00:15:38,240 --> 00:15:42,500
concrete example of a double fetch bug

342
00:15:40,490 --> 00:15:45,530
here so on the right hand side of the

343
00:15:42,500 --> 00:15:48,200
slide the driver is about to fetch two

344
00:15:45,530 --> 00:15:50,770
bites from an i/o mapping and checks if

345
00:15:48,200 --> 00:15:53,870
the fetched value is less than FF

346
00:15:50,770 --> 00:15:56,510
because the fetched value is indeed less

347
00:15:53,870 --> 00:15:58,760
than FF the track passes and the control

348
00:15:56,510 --> 00:16:02,660
flows into the basic block that's

349
00:15:58,760 --> 00:16:05,060
protected by the track and at this point

350
00:16:02,660 --> 00:16:07,280
the driver of the peripheral device

351
00:16:05,060 --> 00:16:10,099
makes a malicious update of the same

352
00:16:07,280 --> 00:16:12,560
exact bites that were just fetched by

353
00:16:10,100 --> 00:16:16,640
the driver and then the driver fetches

354
00:16:12,560 --> 00:16:19,790
the same two bytes again at this point

355
00:16:16,640 --> 00:16:22,130
the fact that the driver has passed this

356
00:16:19,790 --> 00:16:25,520
if condition track is no longer valid

357
00:16:22,130 --> 00:16:27,470
and subsequent uses of this value might

358
00:16:25,520 --> 00:16:30,170
cause the driver to perform an

359
00:16:27,470 --> 00:16:32,750
unintended or potentially exploitable

360
00:16:30,170 --> 00:16:36,110
operations such as buffer overflow in

361
00:16:32,750 --> 00:16:38,900
this example so with this in mind with

362
00:16:36,110 --> 00:16:42,410
we design the following further input

363
00:16:38,900 --> 00:16:45,590
consumption model so the idea is here is

364
00:16:42,410 --> 00:16:49,250
that to sequentially consume the bites

365
00:16:45,590 --> 00:16:52,310
in the photo generated input to provide

366
00:16:49,250 --> 00:16:55,010
a different value to each fetch

367
00:16:52,310 --> 00:16:59,140
regardless of whether it is overlapping

368
00:16:55,010 --> 00:17:02,720
with any of the previous patches or not

369
00:16:59,140 --> 00:17:05,720
so let me give you an example given a

370
00:17:02,720 --> 00:17:07,459
photo generated input the driver fetches

371
00:17:05,720 --> 00:17:10,610
two bytes from an i/o mapping and

372
00:17:07,459 --> 00:17:13,310
peripherals consumes the first avail two

373
00:17:10,609 --> 00:17:16,129
available bytes from the photo generated

374
00:17:13,310 --> 00:17:20,089
input and if there is an overlapping

375
00:17:16,130 --> 00:17:22,490
fetch peripherals consumes the next to

376
00:17:20,089 --> 00:17:25,220
available bytes in the fodder generated

377
00:17:22,490 --> 00:17:27,980
input non-overlapping fetches of course

378
00:17:25,220 --> 00:17:32,570
also consumes the next to available

379
00:17:27,980 --> 00:17:34,910
bytes in the photo generated input so to

380
00:17:32,570 --> 00:17:37,370
explain how all of this fits into a

381
00:17:34,910 --> 00:17:40,340
bigger picture and eventually form a

382
00:17:37,370 --> 00:17:42,469
fuzzing loop let me quickly explain how

383
00:17:40,340 --> 00:17:45,290
device interrupts are typically handled

384
00:17:42,470 --> 00:17:47,750
in operating system kernels so the Linux

385
00:17:45,290 --> 00:17:50,750
Paige Europe and Link can be subdivided

386
00:17:47,750 --> 00:17:53,090
into top half and bottom half and link

387
00:17:50,750 --> 00:17:55,400
of interrupts the top half interrupt

388
00:17:53,090 --> 00:17:57,169
handler mostly it's just acknowledges

389
00:17:55,400 --> 00:17:59,510
the interrupts and queues up the data

390
00:17:57,170 --> 00:18:03,850
associated with that interrupts to be

391
00:17:59,510 --> 00:18:06,320
later processed by the device driver

392
00:18:03,850 --> 00:18:08,750
because most of the work is done by

393
00:18:06,320 --> 00:18:11,510
bottom half handlers we aligned each

394
00:18:08,750 --> 00:18:13,280
iteration of the fuzzing loop to one of

395
00:18:11,510 --> 00:18:16,310
the bottom half handler mechanisms

396
00:18:13,280 --> 00:18:19,730
called a software interrupt handler or

397
00:18:16,310 --> 00:18:22,580
soft irq so at various points in time

398
00:18:19,730 --> 00:18:26,150
that the kernel finds it convenient the

399
00:18:22,580 --> 00:18:28,340
kernel calls the one of the bottom half

400
00:18:26,150 --> 00:18:31,640
handlers registered by the device driver

401
00:18:28,340 --> 00:18:33,530
a single execution of a software

402
00:18:31,640 --> 00:18:35,930
interrupt handler corresponds to a

403
00:18:33,530 --> 00:18:39,080
single iteration of the fuzzing loop and

404
00:18:35,930 --> 00:18:42,230
in each iteration the Jacobites

405
00:18:39,080 --> 00:18:45,439
in the in a single photo generated input

406
00:18:42,230 --> 00:18:49,010
or consecutively consumed according to

407
00:18:45,440 --> 00:18:51,740
our father' input consumption model so

408
00:18:49,010 --> 00:18:53,870
we hope to do so we hope the entrance

409
00:18:51,740 --> 00:18:56,450
and the exit of the software in our

410
00:18:53,870 --> 00:18:59,959
handler and we switch the fuzzy input

411
00:18:56,450 --> 00:19:04,490
after each exit of software in our

412
00:18:59,960 --> 00:19:07,180
handler and we based our prototype

413
00:19:04,490 --> 00:19:10,580
implementation on Linux kernel version

414
00:19:07,180 --> 00:19:14,300
4.4 for armed p8 architecture which

415
00:19:10,580 --> 00:19:18,710
reported to loose kernel version 3.1 and

416
00:19:14,300 --> 00:19:21,980
we used AFL as our fuzzing front-end in

417
00:19:18,710 --> 00:19:25,520
our experiment we targeted to Wi-Fi

418
00:19:21,980 --> 00:19:27,950
drivers running inside popular to

419
00:19:25,520 --> 00:19:30,560
popular smartphones the Qualcomm Wi-Fi

420
00:19:27,950 --> 00:19:32,870
driver running in Google pixel 2 and the

421
00:19:30,560 --> 00:19:37,370
Broadcom Wi-Fi driver running some in

422
00:19:32,870 --> 00:19:39,709
Samsung's Galaxy s6 let me quickly

423
00:19:37,370 --> 00:19:42,860
highlight some of the characteristics of

424
00:19:39,710 --> 00:19:45,530
these targets too and to explain the

425
00:19:42,860 --> 00:19:47,449
challenges that these targets pose on

426
00:19:45,530 --> 00:19:50,000
any analysis efforts

427
00:19:47,450 --> 00:19:51,740
first of all these drivers are one of

428
00:19:50,000 --> 00:19:54,320
the largest in terms of the number of

429
00:19:51,740 --> 00:19:56,180
source lines of code both drivers

430
00:19:54,320 --> 00:19:57,740
consists of more than hundreds of

431
00:19:56,180 --> 00:19:59,140
thousands of lines of code which is

432
00:19:57,740 --> 00:20:02,050
beyond

433
00:19:59,140 --> 00:20:05,830
beyond the effort of like many beyond

434
00:20:02,050 --> 00:20:07,870
the manual effort and they also they're

435
00:20:05,830 --> 00:20:09,939
also highly concurrent making heavy use

436
00:20:07,870 --> 00:20:13,120
of kernel threads and bottom-up

437
00:20:09,940 --> 00:20:15,340
interrupt handlers to maximize the

438
00:20:13,120 --> 00:20:19,179
concurrency and responsiveness of the

439
00:20:15,340 --> 00:20:20,949
system and lots of code run in a

440
00:20:19,180 --> 00:20:23,650
interrupts context or kernel thread

441
00:20:20,950 --> 00:20:26,170
context which means that existing system

442
00:20:23,650 --> 00:20:30,160
called folders may not be used to

443
00:20:26,170 --> 00:20:32,530
directly reach those basic blocks also

444
00:20:30,160 --> 00:20:34,660
note emulation emulated device

445
00:20:32,530 --> 00:20:37,420
implementation is available to our

446
00:20:34,660 --> 00:20:40,900
knowledge and the production smartphones

447
00:20:37,420 --> 00:20:43,210
do not expose the el2 privilege level to

448
00:20:40,900 --> 00:20:48,940
users so hypervisor based of course

449
00:20:43,210 --> 00:20:51,970
cannot be easily applied at least these

450
00:20:48,940 --> 00:20:55,420
are the results in total by applying our

451
00:20:51,970 --> 00:20:58,240
tools we found 15 vulnerabilities 9 of

452
00:20:55,420 --> 00:21:01,780
which were previously unknown and 8 new

453
00:20:58,240 --> 00:21:04,210
series were assigned we found not just

454
00:21:01,780 --> 00:21:07,330
most common types of vulnerabilities

455
00:21:04,210 --> 00:21:11,830
like buffer ovaries or over rights but

456
00:21:07,330 --> 00:21:14,919
also double fetch issues and also kernel

457
00:21:11,830 --> 00:21:19,030
address disclosure to the peripheral

458
00:21:14,920 --> 00:21:22,900
device let me discuss these three bugs

459
00:21:19,030 --> 00:21:25,840
in the next slide so let me start with

460
00:21:22,900 --> 00:21:28,930
this simple buffer overflow are found in

461
00:21:25,840 --> 00:21:31,840
in the core common Wi-Fi driver so the

462
00:21:28,930 --> 00:21:35,470
problem here was a driver the driver

463
00:21:31,840 --> 00:21:37,929
used a value read from an i/o mapping as

464
00:21:35,470 --> 00:21:40,980
an index into an array without

465
00:21:37,930 --> 00:21:44,800
validating the the size of the buffer

466
00:21:40,980 --> 00:21:48,990
which is now patched by adding a

467
00:21:44,800 --> 00:21:53,139
validation check before the use of index

468
00:21:48,990 --> 00:21:56,230
and let me describe the table fetch

469
00:21:53,140 --> 00:21:59,470
issue we found in the Broadcom Wi-Fi

470
00:21:56,230 --> 00:22:01,840
driver so the double fetch bug started

471
00:21:59,470 --> 00:22:04,930
with the driver initially fetching a

472
00:22:01,840 --> 00:22:07,000
message from an i/o mapping for an

473
00:22:04,930 --> 00:22:09,760
integrity check that verifies the

474
00:22:07,000 --> 00:22:11,470
checksum of the entire message only if

475
00:22:09,760 --> 00:22:13,870
the message

476
00:22:11,470 --> 00:22:16,710
test this integrity check the driver

477
00:22:13,870 --> 00:22:19,120
starts to process the message

478
00:22:16,710 --> 00:22:21,520
unfortunately the driver performs an

479
00:22:19,120 --> 00:22:24,010
overlapping fetch from the i/o mapping

480
00:22:21,520 --> 00:22:27,700
at which point the integrity of the

481
00:22:24,010 --> 00:22:30,129
message can no longer be guaranteed when

482
00:22:27,700 --> 00:22:32,200
this value was being read by the device

483
00:22:30,130 --> 00:22:32,770
driver from the i/o mapping our our

484
00:22:32,200 --> 00:22:35,650
fuzzer

485
00:22:32,770 --> 00:22:38,740
was the value and the first value was

486
00:22:35,650 --> 00:22:41,610
used as an index into an array leading

487
00:22:38,740 --> 00:22:41,610
the system to crash

488
00:22:42,900 --> 00:22:48,460
let me also describe the kernel address

489
00:22:45,970 --> 00:22:50,710
leak or disclosure we found so the

490
00:22:48,460 --> 00:22:53,340
symptom of this book as we encountered

491
00:22:50,710 --> 00:22:57,039
was a kernel crash caused by directly

492
00:22:53,340 --> 00:23:02,770
referencing a value provided our fuzzer

493
00:22:57,039 --> 00:23:04,780
as a pointer after our investigation we

494
00:23:02,770 --> 00:23:06,668
found that a kernel pointer was being

495
00:23:04,780 --> 00:23:09,250
disclosed in the first in the first

496
00:23:06,669 --> 00:23:13,090
place to the peripheral device in the

497
00:23:09,250 --> 00:23:16,360
name of cookie the device internally

498
00:23:13,090 --> 00:23:18,879
uses these cookie values and writes them

499
00:23:16,360 --> 00:23:21,399
back to another io mapping which is

500
00:23:18,880 --> 00:23:25,179
subsequently read and D referenced by

501
00:23:21,400 --> 00:23:27,460
the kernel driver so our father forced

502
00:23:25,179 --> 00:23:29,950
the cookie value when the drip and the

503
00:23:27,460 --> 00:23:32,740
driver was reading the value from the

504
00:23:29,950 --> 00:23:34,990
i/o mapping and led the kernel to crash

505
00:23:32,740 --> 00:23:40,720
so this vulnerability could have been

506
00:23:34,990 --> 00:23:43,000
used by an attacker to bypass Kasr R so

507
00:23:40,720 --> 00:23:46,350
this is the performance of our fuzzer

508
00:23:43,000 --> 00:23:50,110
so the fuzzing throughput ranged about

509
00:23:46,350 --> 00:23:51,699
seven to twenty four inputs per second

510
00:23:50,110 --> 00:23:56,860
depending on the nature of the i/o

511
00:23:51,700 --> 00:23:59,010
mapping we've reversed and it primarily

512
00:23:56,860 --> 00:24:01,840
depends on the number of page faults

513
00:23:59,010 --> 00:24:04,330
triggered in each iteration for example

514
00:24:01,840 --> 00:24:10,570
50 page faults per iteration gives

515
00:24:04,330 --> 00:24:13,870
around 20 20 inputs per second although

516
00:24:10,570 --> 00:24:16,720
it cannot be directly compared we also

517
00:24:13,870 --> 00:24:19,120
ran this color on the same device on

518
00:24:16,720 --> 00:24:22,809
pixel two and we found that it achieved

519
00:24:19,120 --> 00:24:24,040
about on average 24 programs executions

520
00:24:22,809 --> 00:24:29,020
per second with a Mac

521
00:24:24,040 --> 00:24:32,080
around 60 with that I'd like to conclude

522
00:24:29,020 --> 00:24:34,090
with three key takeaways so colonel

523
00:24:32,080 --> 00:24:36,399
drivers are vulnerable as evidenced by

524
00:24:34,090 --> 00:24:39,309
the number of vulnerabilities we found

525
00:24:36,400 --> 00:24:41,500
in our fuzzing campaign so combined with

526
00:24:39,309 --> 00:24:44,850
remote prefer compromise it poses

527
00:24:41,500 --> 00:24:46,960
serious threat to OS kernel security and

528
00:24:44,850 --> 00:24:49,719
vulnerabilities that occur along the

529
00:24:46,960 --> 00:24:52,410
Hardware OS boundary can be subtle not

530
00:24:49,720 --> 00:24:56,049
just memory corruption vulnerabilities

531
00:24:52,410 --> 00:24:59,830
but also other kernel address disclosure

532
00:24:56,049 --> 00:25:02,620
or leak and double fetch issues and our

533
00:24:59,830 --> 00:25:04,960
tools can be effective at exposing and

534
00:25:02,620 --> 00:25:10,389
finding these vulnerabilities along the

535
00:25:04,960 --> 00:25:13,390
hardware responder the the top the

536
00:25:10,390 --> 00:25:15,580
content of the talk was based on a paper

537
00:25:13,390 --> 00:25:18,610
pulley published earlier this year at

538
00:25:15,580 --> 00:25:22,030
NDS s so if you are interested you can

539
00:25:18,610 --> 00:25:24,699
have a look with that I'd like to thank

540
00:25:22,030 --> 00:25:26,820
you all for your attention and happy I'm

541
00:25:24,700 --> 00:25:34,800
happy to take any questions

542
00:25:26,820 --> 00:25:34,800
[Applause]

543
00:25:57,130 --> 00:26:04,830
so for the Wi-Fi bugs where you really

544
00:26:00,970 --> 00:26:08,440
speaking the protocol or just fuzzing

545
00:26:04,830 --> 00:26:12,280
locally like could be remotely

546
00:26:08,440 --> 00:26:14,860
exploitable oh yeah it was not actually

547
00:26:12,280 --> 00:26:18,210
related to the Wi-Fi protocol but more

548
00:26:14,860 --> 00:26:21,879
of a like proprietary implementation

549
00:26:18,210 --> 00:26:23,200
between the interaction of the

550
00:26:21,880 --> 00:26:25,179
interaction between the device and the

551
00:26:23,200 --> 00:26:27,910
driver like low-level management of

552
00:26:25,179 --> 00:26:30,179
buffers green buffers those store of

553
00:26:27,910 --> 00:26:30,179
things

554
00:26:53,140 --> 00:27:01,739
thank you

555
00:26:55,390 --> 00:27:01,739
[Applause]

