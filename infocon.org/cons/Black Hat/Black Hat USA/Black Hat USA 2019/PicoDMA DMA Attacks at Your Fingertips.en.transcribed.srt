1
00:00:00,030 --> 00:00:04,290
good morning welcome to blackhat

2
00:00:02,730 --> 00:00:08,400
briefings day one

3
00:00:04,290 --> 00:00:12,599
this is Pico DMA DMA attacks at your

4
00:00:08,400 --> 00:00:14,880
fingertips by men block sell and Joel

5
00:00:12,599 --> 00:00:16,920
Sandin please turn off your cell phones

6
00:00:14,880 --> 00:00:17,940
or put them on vibrate so we don't have

7
00:00:16,920 --> 00:00:22,580
to hear your voice now

8
00:00:17,940 --> 00:00:25,109
thank you much thank you sir

9
00:00:22,580 --> 00:00:27,240
all right everybody thanks for coming

10
00:00:25,109 --> 00:00:30,539
welcome to Pico DMA DMA attack see your

11
00:00:27,240 --> 00:00:32,850
fingertips just to say a little bit

12
00:00:30,539 --> 00:00:34,380
about us my colleague Ben black sole was

13
00:00:32,850 --> 00:00:36,750
a principal security consulting with

14
00:00:34,380 --> 00:00:37,920
nada Sano and later NCC group and he's

15
00:00:36,750 --> 00:00:40,860
currently an independent Hardware

16
00:00:37,920 --> 00:00:42,420
researcher I was also with mana Sano and

17
00:00:40,860 --> 00:00:45,090
later NCC group as a senior security

18
00:00:42,420 --> 00:00:46,890
consultant and I'm a principal a lot of

19
00:00:45,090 --> 00:00:51,210
korah and we help startups bootstrap

20
00:00:46,890 --> 00:00:52,469
their security practice just to give you

21
00:00:51,210 --> 00:00:53,969
an agenda about the talk we're going to

22
00:00:52,469 --> 00:00:56,129
give you some background on DMA attacks

23
00:00:53,969 --> 00:00:57,480
we're going to talk about a wireless DMA

24
00:00:56,129 --> 00:01:01,800
implant that we developed called picot

25
00:00:57,480 --> 00:01:04,259
DMA we'll do a deep dive on FPGA PCI and

26
00:01:01,800 --> 00:01:07,500
DMA engineering we'll talk about the

27
00:01:04,260 --> 00:01:10,650
radio module hardware and software try

28
00:01:07,500 --> 00:01:15,240
to do a live demo conclusions and future

29
00:01:10,650 --> 00:01:17,729
work so what do we mean when we say a

30
00:01:15,240 --> 00:01:19,770
DMA attack DMA is short for direct

31
00:01:17,729 --> 00:01:21,539
memory access and these attacks

32
00:01:19,770 --> 00:01:23,580
traditionally involved an attacker that

33
00:01:21,540 --> 00:01:26,880
gets physical access to a device a

34
00:01:23,580 --> 00:01:28,890
workstation or laptop an attacker

35
00:01:26,880 --> 00:01:30,298
targets high-speed expansion ports like

36
00:01:28,890 --> 00:01:33,240
Thunderbolt and Express card on the

37
00:01:30,299 --> 00:01:36,390
device and uses hardware to read and

38
00:01:33,240 --> 00:01:37,949
write physical memory when you're

39
00:01:36,390 --> 00:01:40,710
performing a DMA attack you can recover

40
00:01:37,950 --> 00:01:42,780
sensitive data from physical memory like

41
00:01:40,710 --> 00:01:45,360
cryptographic secrets and passwords and

42
00:01:42,780 --> 00:01:46,799
you can also make changes to running

43
00:01:45,360 --> 00:01:48,600
software on the device to backdoor the

44
00:01:46,799 --> 00:01:50,640
target machine and that can allow you to

45
00:01:48,600 --> 00:01:51,298
read files bypass authentication if the

46
00:01:50,640 --> 00:01:53,340
machine is locked

47
00:01:51,299 --> 00:01:57,030
essentially compromised the machine

48
00:01:53,340 --> 00:01:57,659
entirely there's a lot of great previous

49
00:01:57,030 --> 00:01:59,790
work here

50
00:01:57,659 --> 00:02:01,140
I'm just going to cover a few talks but

51
00:01:59,790 --> 00:02:03,509
there's a lot more out there

52
00:02:01,140 --> 00:02:05,310
Jill fits really kick things off sort of

53
00:02:03,509 --> 00:02:07,320
in the public sphere of research with

54
00:02:05,310 --> 00:02:10,259
his slot screamer project

55
00:02:07,320 --> 00:02:11,859
and he took a USB 3380 reference board

56
00:02:10,258 --> 00:02:13,179
weaponized it

57
00:02:11,860 --> 00:02:15,730
turns it into a very stealthy DMA

58
00:02:13,180 --> 00:02:18,520
hardware implant you can see it on the

59
00:02:15,730 --> 00:02:20,200
right it's a PCI Express card looks very

60
00:02:18,520 --> 00:02:22,060
innocuous if you install it into a

61
00:02:20,200 --> 00:02:23,950
server and you have physical access you

62
00:02:22,060 --> 00:02:27,910
can connect to the USB port and read

63
00:02:23,950 --> 00:02:30,459
four gigs of memory both frisk has been

64
00:02:27,910 --> 00:02:34,120
working on the PCI leach DMA attack

65
00:02:30,460 --> 00:02:34,750
suite since 2016 and I really can't do

66
00:02:34,120 --> 00:02:36,970
it justice

67
00:02:34,750 --> 00:02:40,360
in just one slide the capabilities are

68
00:02:36,970 --> 00:02:42,850
amazing it not only allows read writes

69
00:02:40,360 --> 00:02:45,130
and searches of physical memory supports

70
00:02:42,850 --> 00:02:47,170
multiple hardware platforms but it has a

71
00:02:45,130 --> 00:02:49,660
whole suite of software implants that

72
00:02:47,170 --> 00:02:52,420
you can use to compromise a target and

73
00:02:49,660 --> 00:02:55,239
perform various attacks and it's not

74
00:02:52,420 --> 00:02:56,859
just a research project PCI leach is

75
00:02:55,239 --> 00:03:00,250
very reliable you can use it on real

76
00:02:56,860 --> 00:03:04,330
engagements its robust and really a

77
00:03:00,250 --> 00:03:06,070
remarkable tool and there's a series of

78
00:03:04,330 --> 00:03:07,930
research presentations by I'm gonna

79
00:03:06,070 --> 00:03:11,019
mispronounce the names I apologize

80
00:03:07,930 --> 00:03:14,739
Fabian Perry go Eric Alexandre Ghazi and

81
00:03:11,020 --> 00:03:18,549
Jeffrey Cesare nee from sin active and

82
00:03:14,739 --> 00:03:19,989
Airbus and they looked at firmware on HP

83
00:03:18,549 --> 00:03:23,410
Enterprise integrated lights-out

84
00:03:19,989 --> 00:03:25,030
firmware identified vulnerabilities that

85
00:03:23,410 --> 00:03:27,160
allow them to compromise at that

86
00:03:25,030 --> 00:03:29,200
firmware from a management network

87
00:03:27,160 --> 00:03:32,200
segment and then they use DMA attacks

88
00:03:29,200 --> 00:03:35,140
from the ILO to pivot into the host of

89
00:03:32,200 --> 00:03:36,910
that machine so when I say that DMA

90
00:03:35,140 --> 00:03:38,470
attacks are traditionally performed with

91
00:03:36,910 --> 00:03:40,660
physical access this is something that

92
00:03:38,470 --> 00:03:43,239
definitely breaks the trend really

93
00:03:40,660 --> 00:03:45,130
groundbreaking research not only was a

94
00:03:43,239 --> 00:03:46,890
groundbreaking research they also added

95
00:03:45,130 --> 00:03:48,670
integration with PCI leach and

96
00:03:46,890 --> 00:03:50,649
demonstrated how you can perform these

97
00:03:48,670 --> 00:03:52,690
attacks using PCI Leach and we relied

98
00:03:50,650 --> 00:03:54,790
heavily on that integration for our own

99
00:03:52,690 --> 00:03:59,590
work so definitely check that stuff out

100
00:03:54,790 --> 00:04:01,840
I also want to mention you know a

101
00:03:59,590 --> 00:04:03,430
keystroke injection tools heat implants

102
00:04:01,840 --> 00:04:05,920
I think we're all familiar with these

103
00:04:03,430 --> 00:04:07,920
the hack five USB rubber ducky is a good

104
00:04:05,920 --> 00:04:10,600
example that's commercially available

105
00:04:07,920 --> 00:04:11,950
it's a lot like a DMA attack in some

106
00:04:10,600 --> 00:04:14,140
ways if you have physical access to a

107
00:04:11,950 --> 00:04:16,478
machine that's unlocked you can inject

108
00:04:14,140 --> 00:04:18,279
keystrokes exfiltrate data compromise

109
00:04:16,478 --> 00:04:20,829
the machine there's been a lot of

110
00:04:18,279 --> 00:04:22,210
research in this space and you know I'd

111
00:04:20,829 --> 00:04:24,640
say the thing that really sets apart

112
00:04:22,210 --> 00:04:25,440
recent projects is a greater degree of

113
00:04:24,640 --> 00:04:29,310
deception

114
00:04:25,440 --> 00:04:32,040
in the design of the the hardware itself

115
00:04:29,310 --> 00:04:33,210
and wireless capabilities so turnips

116
00:04:32,040 --> 00:04:34,890
school is a good example this was a

117
00:04:33,210 --> 00:04:37,739
project by Michael Osmond Dominic's bill

118
00:04:34,890 --> 00:04:39,690
and Jared boom and they built a you know

119
00:04:37,740 --> 00:04:41,580
USB cable that had wireless capabilities

120
00:04:39,690 --> 00:04:43,050
if you plug the cable into your machine

121
00:04:41,580 --> 00:04:45,570
someone with wireless access to that

122
00:04:43,050 --> 00:04:48,060
cable can inject keystrokes there's the

123
00:04:45,570 --> 00:04:50,820
USB ninja developed by vincent lu kevin

124
00:04:48,060 --> 00:04:53,280
Mitnick and folks from procs grind it's

125
00:04:50,820 --> 00:04:56,310
commercially available very similar the

126
00:04:53,280 --> 00:04:59,039
kiss wid from Luke abort bond gionee

127
00:04:56,310 --> 00:05:00,690
a really cool wireless keystroke

128
00:04:59,040 --> 00:05:03,510
injecting tool commercially available

129
00:05:00,690 --> 00:05:06,300
and he's also developing the we delete

130
00:05:03,510 --> 00:05:09,480
which integrates a sim 800 L GSM modem

131
00:05:06,300 --> 00:05:10,860
so you can access it from anywhere the

132
00:05:09,480 --> 00:05:12,810
MAL tronics internal key loggers

133
00:05:10,860 --> 00:05:16,080
pictured on the right there on the

134
00:05:12,810 --> 00:05:18,030
bottom it's an internal key logger what

135
00:05:16,080 --> 00:05:19,650
sets it apart is it's very tiny it's a

136
00:05:18,030 --> 00:05:21,510
one centimeter squared it's persistent

137
00:05:19,650 --> 00:05:24,179
you put it into the keyboard permanently

138
00:05:21,510 --> 00:05:26,789
looks very innocuous you know to someone

139
00:05:24,180 --> 00:05:28,830
who to an untrained eye and might not

140
00:05:26,790 --> 00:05:30,450
look like anything malicious but it

141
00:05:28,830 --> 00:05:31,950
captures every keystroke that flows

142
00:05:30,450 --> 00:05:34,979
through that keyboard and lets you

143
00:05:31,950 --> 00:05:36,539
retrieve them wirelessly so really a lot

144
00:05:34,980 --> 00:05:38,010
of advancements in this space that I

145
00:05:36,540 --> 00:05:41,580
think are relevant to the research that

146
00:05:38,010 --> 00:05:45,120
we've done DMA attacks they're not just

147
00:05:41,580 --> 00:05:47,280
sorry DMA is not just for attackers it's

148
00:05:45,120 --> 00:05:49,620
an invaluable tool for forensic analysis

149
00:05:47,280 --> 00:05:51,630
you know you can capture memory from a

150
00:05:49,620 --> 00:05:54,960
machine and then use tools like

151
00:05:51,630 --> 00:05:56,520
volatility and recall to extract the

152
00:05:54,960 --> 00:05:58,979
memory contents of running processes

153
00:05:56,520 --> 00:06:01,349
from there you can look at what files

154
00:05:58,980 --> 00:06:04,050
those processes have opened what network

155
00:06:01,350 --> 00:06:06,480
connections they are making and do root

156
00:06:04,050 --> 00:06:11,130
cause analysis in the event of an

157
00:06:06,480 --> 00:06:13,110
incident just to give you a concrete a

158
00:06:11,130 --> 00:06:16,469
practical sort of end-to-end DMA attack

159
00:06:13,110 --> 00:06:18,780
example using PCI leach jean-christophe

160
00:06:16,470 --> 00:06:20,820
Dylan a on the syntactic blog has a

161
00:06:18,780 --> 00:06:22,710
really nice write-up about a consulting

162
00:06:20,820 --> 00:06:24,210
engagement he was on where he used PCI

163
00:06:22,710 --> 00:06:25,890
leach and he was tasked with

164
00:06:24,210 --> 00:06:29,270
compromising a hardened Windows

165
00:06:25,890 --> 00:06:31,940
workstation so the iommu was enabled

166
00:06:29,270 --> 00:06:33,830
other protections were in place he first

167
00:06:31,940 --> 00:06:36,319
was able to reset the bios to disable

168
00:06:33,830 --> 00:06:37,969
the iommu which didn't prevent the

169
00:06:36,319 --> 00:06:39,319
machine from booting unfortunately that

170
00:06:37,970 --> 00:06:40,610
wasn't part of the measurements that

171
00:06:39,319 --> 00:06:42,919
were being taken before the machine

172
00:06:40,610 --> 00:06:45,530
booted once he was able to boot it with

173
00:06:42,919 --> 00:06:46,789
the iommu disabled he physically opened

174
00:06:45,530 --> 00:06:49,669
the device you can see a picture here of

175
00:06:46,789 --> 00:06:52,849
that laptop open connected to an m2 slot

176
00:06:49,669 --> 00:06:55,909
in the laptop connected an FPGA should

177
00:06:52,849 --> 00:06:58,009
say and then use the PCI to PCI leach

178
00:06:55,910 --> 00:07:00,080
tool that I mentioned to patch the

179
00:06:58,009 --> 00:07:01,490
memory on that laptop and actually

180
00:07:00,080 --> 00:07:03,440
unlock it and login so it was a

181
00:07:01,490 --> 00:07:05,300
successful engagement from his

182
00:07:03,440 --> 00:07:08,539
perspective and a really cool write-up

183
00:07:05,300 --> 00:07:11,870
that you should check out and just to

184
00:07:08,539 --> 00:07:14,568
talk about the goals for this project at

185
00:07:11,870 --> 00:07:16,970
the on sent at the onset our goal was

186
00:07:14,569 --> 00:07:20,599
develop a DMA capable hardware implant

187
00:07:16,970 --> 00:07:22,580
and we wanted it to be small our idea

188
00:07:20,599 --> 00:07:23,900
was the implant would be persistent she

189
00:07:22,580 --> 00:07:26,210
would install it once and leave it in

190
00:07:23,900 --> 00:07:28,310
place and we wanted to incorporate

191
00:07:26,210 --> 00:07:30,169
wireless capabilities so you didn't have

192
00:07:28,310 --> 00:07:32,840
to have wireless access or sorry

193
00:07:30,169 --> 00:07:33,919
physical access when actually performing

194
00:07:32,840 --> 00:07:36,469
the attack you could access it

195
00:07:33,919 --> 00:07:38,270
wirelessly and just any interest of time

196
00:07:36,469 --> 00:07:40,190
for the initial prototype we really

197
00:07:38,270 --> 00:07:43,698
wanted to use off-the-shelf hardware if

198
00:07:40,190 --> 00:07:45,710
possible and our hope was to develop

199
00:07:43,699 --> 00:07:48,409
proof-of-concept demonstrations of new

200
00:07:45,710 --> 00:07:50,680
attack and defense scenarios and also to

201
00:07:48,409 --> 00:07:53,180
release the software and documentation

202
00:07:50,680 --> 00:07:55,130
so other researchers will have low cost

203
00:07:53,180 --> 00:07:59,180
building blocks for new applications

204
00:07:55,130 --> 00:08:01,009
offensive and defensive alike we

205
00:07:59,180 --> 00:08:03,800
developed an initial prototype that this

206
00:08:01,009 --> 00:08:06,289
is the Pico DMA as you can see it's

207
00:08:03,800 --> 00:08:07,580
quite small fits on a keychain where it

208
00:08:06,289 --> 00:08:10,310
is an earring

209
00:08:07,580 --> 00:08:14,060
it's DMA capable so you can do 64-bit

210
00:08:10,310 --> 00:08:18,050
streaming reads and 64-bit writes and we

211
00:08:14,060 --> 00:08:20,270
also incorporate an FPGA enabled search

212
00:08:18,050 --> 00:08:23,120
capability so the FPGA can actually

213
00:08:20,270 --> 00:08:24,799
search for words in memory that may be

214
00:08:23,120 --> 00:08:27,530
interesting to you

215
00:08:24,800 --> 00:08:30,199
it's PCI leach compatible so all the

216
00:08:27,530 --> 00:08:32,449
attacks there you can potentially mount

217
00:08:30,199 --> 00:08:36,039
using this hardware device and we built

218
00:08:32,450 --> 00:08:36,039
it using commodity hardware

219
00:08:36,940 --> 00:08:40,690
the Pico DMA is highly embeddable we see

220
00:08:39,460 --> 00:08:42,580
here on the right it's installed in a

221
00:08:40,690 --> 00:08:45,700
machine it's really easy to install you

222
00:08:42,580 --> 00:08:47,320
just need access to an M to a or e key

223
00:08:45,700 --> 00:08:51,070
expansion slot or you can use adapters

224
00:08:47,320 --> 00:08:52,990
to put it into other slots fits in small

225
00:08:51,070 --> 00:08:55,360
places here it's installed in a Intel

226
00:08:52,990 --> 00:08:56,290
nook which is pre palatial as far as the

227
00:08:55,360 --> 00:08:59,410
implant is concerned

228
00:08:56,290 --> 00:09:04,270
plenty of room that machine is actually

229
00:08:59,410 --> 00:09:05,709
sitting next to me here and the Pico DMA

230
00:09:04,270 --> 00:09:07,660
supports out-of-band access so it

231
00:09:05,709 --> 00:09:10,599
doesn't rely on network access on the

232
00:09:07,660 --> 00:09:13,209
target machine the target machine

233
00:09:10,600 --> 00:09:17,440
doesn't have network access that's ok

234
00:09:13,209 --> 00:09:20,079
the Pico ain't even Pico DMA has its own

235
00:09:17,440 --> 00:09:22,390
network access so it's small and

236
00:09:20,080 --> 00:09:26,580
self-reliant and hopefully suited to a

237
00:09:22,390 --> 00:09:28,600
big set of targets and so you know

238
00:09:26,580 --> 00:09:30,459
wireless implants like these they

239
00:09:28,600 --> 00:09:32,589
decouple the act of installing the

240
00:09:30,459 --> 00:09:34,660
implant from performing the actual DMA

241
00:09:32,589 --> 00:09:36,610
attack you can install the implant and

242
00:09:34,660 --> 00:09:40,180
then weeks or months later actually

243
00:09:36,610 --> 00:09:41,860
perform exploitation and it gives an

244
00:09:40,180 --> 00:09:44,410
attacker more possibilities as far as

245
00:09:41,860 --> 00:09:46,390
deployment is concerned interdiction

246
00:09:44,410 --> 00:09:47,920
attacks are a good example an attacker

247
00:09:46,390 --> 00:09:51,250
can intercept the device when it's in

248
00:09:47,920 --> 00:09:53,020
transit and powered down and install a

249
00:09:51,250 --> 00:09:56,140
physical implant or a software implant

250
00:09:53,020 --> 00:09:58,990
for that matter plenty of organizations

251
00:09:56,140 --> 00:10:01,000
rely on third party contractors as you

252
00:09:58,990 --> 00:10:02,740
know hands and eyes technicians for

253
00:10:01,000 --> 00:10:05,200
working on servers and data centers and

254
00:10:02,740 --> 00:10:07,450
so on an attacker with temporary

255
00:10:05,200 --> 00:10:10,209
physical access to a server that a Dun

256
00:10:07,450 --> 00:10:12,010
racket doing routine maintenance can

257
00:10:10,209 --> 00:10:13,839
install the implant put it back on the

258
00:10:12,010 --> 00:10:16,510
rack and then that attacker can later

259
00:10:13,839 --> 00:10:19,420
use that implant to to actually perform

260
00:10:16,510 --> 00:10:21,250
the attack you can imagine scenarios

261
00:10:19,420 --> 00:10:23,260
where an attacker may have legitimate

262
00:10:21,250 --> 00:10:24,970
physical access to machine an example is

263
00:10:23,260 --> 00:10:27,400
a you know an employee that has access

264
00:10:24,970 --> 00:10:28,870
to a workstation as part of their job

265
00:10:27,400 --> 00:10:31,240
duties and then they leave the

266
00:10:28,870 --> 00:10:33,190
organization but before they leave it

267
00:10:31,240 --> 00:10:35,620
they leave a little bit of hardware

268
00:10:33,190 --> 00:10:38,589
behind and when that workstation is

269
00:10:35,620 --> 00:10:40,209
issued to a new employee that creep that

270
00:10:38,589 --> 00:10:43,390
former employee would then have access

271
00:10:40,209 --> 00:10:44,949
to perform the attack and of course

272
00:10:43,390 --> 00:10:46,930
organizations that are provisioning

273
00:10:44,950 --> 00:10:49,149
hardware they could install hardware

274
00:10:46,930 --> 00:10:54,520
an implant like this and do for remote

275
00:10:49,149 --> 00:10:57,430
forensics later on and the decoupling

276
00:10:54,520 --> 00:10:59,199
allows you know new attack variations

277
00:10:57,430 --> 00:11:03,670
new variations on existing attacks that

278
00:10:59,200 --> 00:11:05,050
we've seen in past research we don't

279
00:11:03,670 --> 00:11:05,800
need access to the machine when it's

280
00:11:05,050 --> 00:11:07,810
live anymore

281
00:11:05,800 --> 00:11:10,540
and that means we can capture you know

282
00:11:07,810 --> 00:11:12,699
ephemeral credentials that may only be

283
00:11:10,540 --> 00:11:15,339
in memory at certain times examples are

284
00:11:12,700 --> 00:11:18,399
you know GPG agent loading keys into

285
00:11:15,339 --> 00:11:19,870
memory or SSH agent of course session

286
00:11:18,399 --> 00:11:23,890
cookies associated with sessions on the

287
00:11:19,870 --> 00:11:25,390
machine or a good target and it's not an

288
00:11:23,890 --> 00:11:27,640
attack that necessarily happens at a

289
00:11:25,390 --> 00:11:29,410
single point in time you can do ongoing

290
00:11:27,640 --> 00:11:31,449
profiling you can collect activity logs

291
00:11:29,410 --> 00:11:34,120
from the target screenshots stuff like

292
00:11:31,450 --> 00:11:37,360
that over time because the implant stays

293
00:11:34,120 --> 00:11:39,640
put and because you're installing it and

294
00:11:37,360 --> 00:11:41,020
leaving it in place any protections and

295
00:11:39,640 --> 00:11:42,760
there are some in various operating

296
00:11:41,020 --> 00:11:44,770
systems disabling external ports when

297
00:11:42,760 --> 00:11:48,880
the machine unlocked those protections

298
00:11:44,770 --> 00:11:50,230
don't apply in this context and we've

299
00:11:48,880 --> 00:11:52,810
already sort of alluded to some of the

300
00:11:50,230 --> 00:11:56,320
key ingredients here we need an FPGA

301
00:11:52,810 --> 00:11:58,029
platform for actually doing DMA in order

302
00:11:56,320 --> 00:12:01,270
to facilitate wireless access we need a

303
00:11:58,029 --> 00:12:02,650
radio module it's probably not going to

304
00:12:01,270 --> 00:12:06,250
be the same device so we need a way to

305
00:12:02,650 --> 00:12:07,930
connect them software obviously and this

306
00:12:06,250 --> 00:12:10,180
brings me to the Pico EVB which is a

307
00:12:07,930 --> 00:12:13,870
commercially available FPGA platform

308
00:12:10,180 --> 00:12:15,939
from RHS Research LLC here's a picture

309
00:12:13,870 --> 00:12:21,700
of it as you can see it literally fits

310
00:12:15,940 --> 00:12:25,060
on a fingertip it's very tiny and it's

311
00:12:21,700 --> 00:12:27,190
an excellent DMA platform so we have a

312
00:12:25,060 --> 00:12:28,660
block diagram on the right it's

313
00:12:27,190 --> 00:12:30,550
commercially available like I mentioned

314
00:12:28,660 --> 00:12:34,060
it was launched on crowd supply runs

315
00:12:30,550 --> 00:12:37,719
about 220 bucks it has a powerful FPGA

316
00:12:34,060 --> 00:12:40,709
on an Arctic 7 XC 7 a 50 T it's really

317
00:12:37,720 --> 00:12:44,709
tiny it's a 2 point 2 by 3 centimeters

318
00:12:40,709 --> 00:12:47,680
as I mentioned it plugs into M 2 AE

319
00:12:44,709 --> 00:12:49,469
slots so you know a lot of flexibility

320
00:12:47,680 --> 00:12:52,149
as far as where you can install it and

321
00:12:49,470 --> 00:12:54,070
really important for us is it comes with

322
00:12:52,149 --> 00:12:56,920
expansion capabilities out of the box so

323
00:12:54,070 --> 00:12:58,120
if you look at the block diagram there

324
00:12:56,920 --> 00:13:00,250
are

325
00:12:58,120 --> 00:13:01,600
multi-purpose i/o connectors and

326
00:13:00,250 --> 00:13:04,690
high-speed digital i/o connectors over

327
00:13:01,600 --> 00:13:07,810
there on the left side and so you can

328
00:13:04,690 --> 00:13:10,090
interface it with other devices what it

329
00:13:07,810 --> 00:13:12,670
doesn't come with is any actual way to

330
00:13:10,090 --> 00:13:15,810
do DMA so it's a lot of software

331
00:13:12,670 --> 00:13:17,740
engineering that goes into that and I'll

332
00:13:15,810 --> 00:13:23,699
send it over to Ben to talk about

333
00:13:17,740 --> 00:13:27,280
building the prototype okay

334
00:13:23,700 --> 00:13:30,310
so the basic challenge with this is PCI

335
00:13:27,280 --> 00:13:32,439
is high-bandwidth low-latency and PCI

336
00:13:30,310 --> 00:13:35,020
transactions can complete in the order

337
00:13:32,440 --> 00:13:36,730
of 10 microseconds and remote

338
00:13:35,020 --> 00:13:39,670
communication of course we're talking

339
00:13:36,730 --> 00:13:41,170
milliseconds and you know Wi-Fi oh maybe

340
00:13:39,670 --> 00:13:42,459
we have enough bandwidth for these kind

341
00:13:41,170 --> 00:13:45,490
of transactions but something like Laura

342
00:13:42,460 --> 00:13:47,050
radio where the bandwidth is so much

343
00:13:45,490 --> 00:13:50,680
smaller it's hundreds and maybe

344
00:13:47,050 --> 00:13:53,079
thousands of bytes per second and so our

345
00:13:50,680 --> 00:13:54,819
platform at high level it's similar to

346
00:13:53,080 --> 00:13:58,240
previous platforms that we use an FPGA

347
00:13:54,820 --> 00:14:00,490
to talk to the PCI Express bus and where

348
00:13:58,240 --> 00:14:03,970
we differ is previous platforms and

349
00:14:00,490 --> 00:14:04,510
basically QFP qpc I am requests on the

350
00:14:03,970 --> 00:14:06,730
FPGA

351
00:14:04,510 --> 00:14:10,630
we do a lot more person on the only FPGA

352
00:14:06,730 --> 00:14:14,050
and yeah and we provide a simple

353
00:14:10,630 --> 00:14:16,000
interface for doing DC a PCI DMA and we

354
00:14:14,050 --> 00:14:19,150
provided yeah I suppose a spy interface

355
00:14:16,000 --> 00:14:21,360
um when we were initially thinking about

356
00:14:19,150 --> 00:14:24,640
it we went through a couple of ideas and

357
00:14:21,360 --> 00:14:25,840
the initial idea that a lot of people

358
00:14:24,640 --> 00:14:27,760
talk about is putting a soft core on the

359
00:14:25,840 --> 00:14:29,440
FPGA and the reason we rejected this

360
00:14:27,760 --> 00:14:30,939
idea is it it looked like it was gonna

361
00:14:29,440 --> 00:14:33,490
require a lot more engineering basically

362
00:14:30,940 --> 00:14:37,000
and to get the performance out of a soft

363
00:14:33,490 --> 00:14:38,800
core to to process PCI packets and

364
00:14:37,000 --> 00:14:40,420
you're either gonna need to add custom

365
00:14:38,800 --> 00:14:43,390
instructions or a lot of one chip

366
00:14:40,420 --> 00:14:44,949
buffering and since we had a set fixed

367
00:14:43,390 --> 00:14:47,290
set of functionality we decided just to

368
00:14:44,950 --> 00:14:50,200
implement those instructions directly

369
00:14:47,290 --> 00:14:51,819
and we decided still to include a

370
00:14:50,200 --> 00:14:53,530
microcontroller in the system that gives

371
00:14:51,820 --> 00:14:55,780
us flexibility and with remote

372
00:14:53,530 --> 00:14:58,470
communication and potentially updating

373
00:14:55,780 --> 00:15:02,470
the FPGA and these kind of things and

374
00:14:58,470 --> 00:15:04,120
for a future platform idea if we use the

375
00:15:02,470 --> 00:15:06,100
specialized PCB for instance and a

376
00:15:04,120 --> 00:15:08,680
lower-cost FPGA which is possible when

377
00:15:06,100 --> 00:15:10,780
the price per unit could easily be below

378
00:15:08,680 --> 00:15:13,000
$50 so there's definitely room for it

379
00:15:10,780 --> 00:15:14,829
improvement there but we wanted to get

380
00:15:13,000 --> 00:15:16,510
moving quick and with off-the-shelf

381
00:15:14,830 --> 00:15:20,500
components yet we can make progress

382
00:15:16,510 --> 00:15:23,080
pretty quickly and okay so I'm gonna

383
00:15:20,500 --> 00:15:24,370
talk a little bit about what we require

384
00:15:23,080 --> 00:15:27,190
from the PC I expect what we're gonna be

385
00:15:24,370 --> 00:15:29,860
using to perform these PCI DMA attacks

386
00:15:27,190 --> 00:15:31,180
and I'm gonna start off simple PCI

387
00:15:29,860 --> 00:15:33,190
connectors I'm sure you're all familiar

388
00:15:31,180 --> 00:15:35,530
there's like standard connectors which

389
00:15:33,190 --> 00:15:38,050
are you know in desktop and server class

390
00:15:35,530 --> 00:15:40,689
motherboards have been for tens of years

391
00:15:38,050 --> 00:15:43,870
and yeah maybe even know for twenty

392
00:15:40,690 --> 00:15:45,820
years now but now nowadays you just have

393
00:15:43,870 --> 00:15:48,580
there m dot 2 M slot which is ubiquitous

394
00:15:45,820 --> 00:15:51,010
in mobile devices and this is partly

395
00:15:48,580 --> 00:15:53,410
from high-performance SSD is becoming

396
00:15:51,010 --> 00:15:56,350
much more common and but it's also used

397
00:15:53,410 --> 00:16:01,000
for things like you know Wi-Fi cards and

398
00:15:56,350 --> 00:16:04,600
which user a slash e key SSDs use em key

399
00:16:01,000 --> 00:16:05,710
and the keying is done by physical

400
00:16:04,600 --> 00:16:07,810
knotch if you've ever looked to the

401
00:16:05,710 --> 00:16:10,830
connector and yeah it was a physical

402
00:16:07,810 --> 00:16:13,780
notch that prevents you from putting

403
00:16:10,830 --> 00:16:16,420
different and PCI cards into different

404
00:16:13,780 --> 00:16:18,160
slots the actual pins themselves the

405
00:16:16,420 --> 00:16:19,719
different differential pairs of wires

406
00:16:18,160 --> 00:16:21,550
they mean this means if you're sending

407
00:16:19,720 --> 00:16:22,930
like a high bit one while I will contain

408
00:16:21,550 --> 00:16:26,020
a high value and the other one a low

409
00:16:22,930 --> 00:16:27,729
value this helps reduce noise electrical

410
00:16:26,020 --> 00:16:31,120
noise and things like that and improve

411
00:16:27,730 --> 00:16:34,120
signal integrity and the devices will

412
00:16:31,120 --> 00:16:36,700
perform link width negotiation which

413
00:16:34,120 --> 00:16:38,650
allows basically some of the pairs to

414
00:16:36,700 --> 00:16:41,320
not be working interesting this kind of

415
00:16:38,650 --> 00:16:42,910
allows you to do to mechanically alter

416
00:16:41,320 --> 00:16:44,560
the connectors so for instance if

417
00:16:42,910 --> 00:16:47,170
there's this interesting users of people

418
00:16:44,560 --> 00:16:48,760
previously wanting to put graphics cards

419
00:16:47,170 --> 00:16:51,310
and motherboards only have a single and

420
00:16:48,760 --> 00:16:52,839
PCI Lane slot and they've kind of like

421
00:16:51,310 --> 00:16:54,160
chopped up you can do something similar

422
00:16:52,839 --> 00:16:56,530
with them got two connectors as well

423
00:16:54,160 --> 00:16:58,630
where you sand down the notch and in

424
00:16:56,530 --> 00:17:00,100
between and then you can shove a and n

425
00:16:58,630 --> 00:17:02,530
dot two connector in a different in

426
00:17:00,100 --> 00:17:06,790
different slot but you can also just use

427
00:17:02,530 --> 00:17:09,579
an adapter and there's adaptive for all

428
00:17:06,790 --> 00:17:15,659
different types of PCI Express forms and

429
00:17:09,579 --> 00:17:18,938
mm dot two slots have also different

430
00:17:15,660 --> 00:17:22,810
different additional interfaces and they

431
00:17:18,939 --> 00:17:24,360
supply so USB i2c etc and for instance

432
00:17:22,810 --> 00:17:27,250
the AE / e key

433
00:17:24,359 --> 00:17:31,120
Wireless cards using and the piggery VB

434
00:17:27,250 --> 00:17:33,160
that we're using as our base has USB on

435
00:17:31,120 --> 00:17:35,830
it as well so the adapter in the middle

436
00:17:33,160 --> 00:17:37,450
of the image there and you can see that

437
00:17:35,830 --> 00:17:38,919
it's accordant exposed USB header and

438
00:17:37,450 --> 00:17:40,810
that allows you to route back USB to the

439
00:17:38,920 --> 00:17:43,420
host for our cases of course we only

440
00:17:40,810 --> 00:17:46,030
care about the PCI eiite PCI Express so

441
00:17:43,420 --> 00:17:47,980
we don't care about the USB and but if

442
00:17:46,030 --> 00:17:52,899
you do yeah you gonna have to read those

443
00:17:47,980 --> 00:17:54,520
signals externally the PCI Express

444
00:17:52,900 --> 00:17:56,620
terminology talks about endpoint devices

445
00:17:54,520 --> 00:17:58,810
connected to a root complex that's just

446
00:17:56,620 --> 00:18:01,860
you know your endpoint talking to a host

447
00:17:58,810 --> 00:18:03,909
device and it is packet based but it

448
00:18:01,860 --> 00:18:04,990
looks when you're when you're working

449
00:18:03,910 --> 00:18:06,370
with it it looks a bit more like a

450
00:18:04,990 --> 00:18:09,790
traditional busting that you're

451
00:18:06,370 --> 00:18:12,070
performing and memory reads writes to

452
00:18:09,790 --> 00:18:14,020
memory location store to IO reports

453
00:18:12,070 --> 00:18:17,679
rather than just sending packets with

454
00:18:14,020 --> 00:18:20,260
data and there's a physical and a data

455
00:18:17,680 --> 00:18:21,400
link layer and we're gonna not talk

456
00:18:20,260 --> 00:18:24,360
about those because that's gonna be

457
00:18:21,400 --> 00:18:26,980
handled by the FPGA vendor provided code

458
00:18:24,360 --> 00:18:28,949
and we're gonna just talk about the

459
00:18:26,980 --> 00:18:31,750
transaction layer which sits on top and

460
00:18:28,950 --> 00:18:33,850
the other thing to point out is PCI

461
00:18:31,750 --> 00:18:36,040
Express is you know designed for memory

462
00:18:33,850 --> 00:18:39,520
transfers and they are usually host

463
00:18:36,040 --> 00:18:40,960
initiated but obviously for our use case

464
00:18:39,520 --> 00:18:43,360
we're going to be initiating them on

465
00:18:40,960 --> 00:18:45,970
device and getting the completions back

466
00:18:43,360 --> 00:18:47,139
from the host so the summary of the

467
00:18:45,970 --> 00:18:49,270
summary of this slide is basically there

468
00:18:47,140 --> 00:18:51,760
is no security built into PCI Express

469
00:18:49,270 --> 00:18:53,320
and that's kind of a valid threat model

470
00:18:51,760 --> 00:18:54,760
right it's a high bandwidth protocol

471
00:18:53,320 --> 00:18:56,379
that's for physical interconnect and

472
00:18:54,760 --> 00:18:57,790
it's not normally exposed to attack

473
00:18:56,380 --> 00:19:02,230
their attackers or anything like that

474
00:18:57,790 --> 00:19:04,470
and but that's why the basis of why a

475
00:19:02,230 --> 00:19:06,580
PCI Express DMA attacks from work and

476
00:19:04,470 --> 00:19:09,720
Nyonya identification had done is

477
00:19:06,580 --> 00:19:14,830
there's a 16-bit physical address that's

478
00:19:09,720 --> 00:19:16,330
dictated by the host and and as will be

479
00:19:14,830 --> 00:19:18,100
reported back to the device but it's not

480
00:19:16,330 --> 00:19:19,679
configured by the device and there's a

481
00:19:18,100 --> 00:19:23,639
device ID which is read from the

482
00:19:19,680 --> 00:19:25,930
device's configuration space and that is

483
00:19:23,640 --> 00:19:27,550
is written by the device and that's why

484
00:19:25,930 --> 00:19:29,530
these DMA attacks can actually work is

485
00:19:27,550 --> 00:19:33,129
that it's self-reported right you can

486
00:19:29,530 --> 00:19:35,500
report any device ID and a lot of DMA

487
00:19:33,130 --> 00:19:37,390
tax work by reporting device IDs of

488
00:19:35,500 --> 00:19:38,200
devices that have special privileges

489
00:19:37,390 --> 00:19:40,330
such as

490
00:19:38,200 --> 00:19:42,309
buff's mastering which is the term for

491
00:19:40,330 --> 00:19:46,509
being able to initiate DMA request sin

492
00:19:42,309 --> 00:19:48,190
psi M okay so Toa transactionally of

493
00:19:46,509 --> 00:19:49,570
packets is a bunch of different ones we

494
00:19:48,190 --> 00:19:50,619
only really care about the memory

495
00:19:49,570 --> 00:19:52,330
transactions the read and write to

496
00:19:50,619 --> 00:19:53,830
memory and that we're going to be

497
00:19:52,330 --> 00:19:55,330
initiating from our device and will

498
00:19:53,830 --> 00:19:57,309
receive back completions there's a

499
00:19:55,330 --> 00:19:59,529
number of other ones configuration

500
00:19:57,309 --> 00:20:01,149
freedom right gops will will be going on

501
00:19:59,529 --> 00:20:03,489
those will be handled by the FPGA and

502
00:20:01,149 --> 00:20:05,889
that we we won't have to encode ourself

503
00:20:03,489 --> 00:20:08,049
and there's a number of other requests

504
00:20:05,889 --> 00:20:10,570
such as I request those those are mostly

505
00:20:08,049 --> 00:20:14,259
for legacy compatibility there's

506
00:20:10,570 --> 00:20:15,428
probably an attack surface there and but

507
00:20:14,259 --> 00:20:19,029
it's not something we're gonna go into

508
00:20:15,429 --> 00:20:21,220
in this in this talk and so this is kind

509
00:20:19,029 --> 00:20:22,840
of an outline of an example TLP and I'm

510
00:20:21,220 --> 00:20:25,059
just gonna go over some key fields

511
00:20:22,840 --> 00:20:28,749
there's a link field in the top right

512
00:20:25,059 --> 00:20:31,928
hand corner this is a length set the

513
00:20:28,749 --> 00:20:35,789
number of 32-bit words data words data

514
00:20:31,929 --> 00:20:38,320
payload in in the TLP it's timber and

515
00:20:35,789 --> 00:20:40,960
the length combined with the address

516
00:20:38,320 --> 00:20:43,960
must across a 4 kilobyte boundary which

517
00:20:40,960 --> 00:20:45,700
we managed to do during design and the

518
00:20:43,960 --> 00:20:47,830
annoying thing about working in PCI

519
00:20:45,700 --> 00:20:49,960
Express is a number of hosts tend to

520
00:20:47,830 --> 00:20:51,189
allow you to kind of work to be

521
00:20:49,960 --> 00:20:52,989
providing incorrect

522
00:20:51,190 --> 00:20:55,090
you know requests and then suddenly

523
00:20:52,989 --> 00:20:56,830
they'll decide okay you're you know not

524
00:20:55,090 --> 00:20:57,730
working anymore you're something's gone

525
00:20:56,830 --> 00:20:59,199
wrong with your device and then they'll

526
00:20:57,730 --> 00:21:01,179
shut off access it makes it very hard to

527
00:20:59,200 --> 00:21:03,039
debug issues because you know it's

528
00:21:01,179 --> 00:21:06,580
working and then it stops working

529
00:21:03,039 --> 00:21:07,658
randomly but yeah so you visit there's

530
00:21:06,580 --> 00:21:09,489
lots of kind of small things along

531
00:21:07,659 --> 00:21:09,850
aspect that you need to check out like

532
00:21:09,489 --> 00:21:12,070
that

533
00:21:09,850 --> 00:21:14,109
the next field along going right to left

534
00:21:12,070 --> 00:21:15,519
on the top line is the type field that's

535
00:21:14,109 --> 00:21:18,908
pretty self-explanatory that's just the

536
00:21:15,519 --> 00:21:21,879
TLB type and then there's a two-bit bit

537
00:21:18,909 --> 00:21:24,340
field the format field which just

538
00:21:21,879 --> 00:21:27,039
signifies if the payload contains data

539
00:21:24,340 --> 00:21:30,519
and also if the dress type is a 32-bit

540
00:21:27,039 --> 00:21:33,899
or 64-bit address so the way that your

541
00:21:30,519 --> 00:21:37,389
dressing works in PCI Express is if you

542
00:21:33,899 --> 00:21:39,639
only want to address either write or

543
00:21:37,389 --> 00:21:42,639
read to a 32-bit address you have to use

544
00:21:39,639 --> 00:21:47,649
a 32-bit address you can't pack it into

545
00:21:42,639 --> 00:21:50,019
a 64-bit value otherwise again it will

546
00:21:47,649 --> 00:21:51,370
potentially accept your transactions but

547
00:21:50,019 --> 00:21:54,550
then might decide your

548
00:21:51,370 --> 00:21:57,219
you know a damaged device or something

549
00:21:54,550 --> 00:22:00,220
the net the next line down we have on

550
00:21:57,220 --> 00:22:02,920
the right the bike enables that just

551
00:22:00,220 --> 00:22:06,850
selects whether the bikes in the first

552
00:22:02,920 --> 00:22:08,830
data and said few bit word and the last

553
00:22:06,850 --> 00:22:13,659
one are enabled and that allows you to

554
00:22:08,830 --> 00:22:15,820
do non 32-bit word addresses and so

555
00:22:13,660 --> 00:22:18,100
basically the address that you provide

556
00:22:15,820 --> 00:22:20,800
as you can see must be aligned to 32

557
00:22:18,100 --> 00:22:22,419
bits the address counts from the 31st

558
00:22:20,800 --> 00:22:27,100
bit down to the down to the second

559
00:22:22,420 --> 00:22:29,020
rather than the 0 the 0 bit and skipping

560
00:22:27,100 --> 00:22:30,429
tag if we go over to request ID the

561
00:22:29,020 --> 00:22:32,550
request ID is the physical idea

562
00:22:30,430 --> 00:22:34,450
mentioned yeah this will be set or

563
00:22:32,550 --> 00:22:36,879
relayed from the house back to the

564
00:22:34,450 --> 00:22:38,410
endpoint and then the endpoint should

565
00:22:36,880 --> 00:22:40,210
use this on request again this is

566
00:22:38,410 --> 00:22:42,430
another thing you can not provide the

567
00:22:40,210 --> 00:22:43,840
correct risk request ID and it may work

568
00:22:42,430 --> 00:22:45,970
for a while and then it will stop

569
00:22:43,840 --> 00:22:48,520
working so yeah good to good to provide

570
00:22:45,970 --> 00:22:49,930
the right request ID and the tag field

571
00:22:48,520 --> 00:22:55,240
is the last field in the middle in the

572
00:22:49,930 --> 00:22:57,430
second row and that basically is a an

573
00:22:55,240 --> 00:23:00,370
identify the nm point can associate with

574
00:22:57,430 --> 00:23:02,320
streams of packets or within a

575
00:23:00,370 --> 00:23:04,810
particular packet and it basically

576
00:23:02,320 --> 00:23:07,510
defines the ordering used with the PCI

577
00:23:04,810 --> 00:23:11,260
specification so for instance different

578
00:23:07,510 --> 00:23:12,730
different tags the packets may read

579
00:23:11,260 --> 00:23:14,020
completions may return at different

580
00:23:12,730 --> 00:23:16,570
times there's no ordering guaranteed

581
00:23:14,020 --> 00:23:18,970
there but a packet writing to the same

582
00:23:16,570 --> 00:23:21,700
tag will always come back in the same

583
00:23:18,970 --> 00:23:24,700
order it's and it's this by default was

584
00:23:21,700 --> 00:23:26,200
a 5 bit tag allowed so that sets you 3

585
00:23:24,700 --> 00:23:28,510
different values but there's extensions

586
00:23:26,200 --> 00:23:29,920
that allow up to 8 bits and it's mostly

587
00:23:28,510 --> 00:23:34,510
a performance thing but it's something

588
00:23:29,920 --> 00:23:37,740
we all use ok so now a quick overview of

589
00:23:34,510 --> 00:23:40,180
the FPGA concepts we'll be using and

590
00:23:37,740 --> 00:23:41,890
FPGA is if you're not familiar of

591
00:23:40,180 --> 00:23:44,470
synchronous circuits as programmable

592
00:23:41,890 --> 00:23:46,690
logic gates this means and you can

593
00:23:44,470 --> 00:23:49,930
emulate circuitry on an integrated chip

594
00:23:46,690 --> 00:23:53,560
it runs very fast and they commonly used

595
00:23:49,930 --> 00:23:58,060
for simulation of a6 and and also to

596
00:23:53,560 --> 00:23:59,679
work on io that's very timing

597
00:23:58,060 --> 00:24:01,360
constrained either very quickly or

598
00:23:59,680 --> 00:24:02,799
requires very precise timing

599
00:24:01,360 --> 00:24:07,059
and there's a wide range of CrossFit

600
00:24:02,799 --> 00:24:10,330
FPGAs I've put a few up here the letter

601
00:24:07,059 --> 00:24:11,530
C cp5 on the left is not the cheapest

602
00:24:10,330 --> 00:24:13,240
FPGA you can get you can get much

603
00:24:11,530 --> 00:24:16,299
cheaper ones and similarly on the right

604
00:24:13,240 --> 00:24:18,400
the Xilinx vu9 P and it's not the most

605
00:24:16,299 --> 00:24:20,500
expensive FPGA you can get the thing

606
00:24:18,400 --> 00:24:24,970
they have in common these ones is they

607
00:24:20,500 --> 00:24:27,429
all provide the PCI Express tools that

608
00:24:24,970 --> 00:24:28,720
we need to do DMA attacks obviously for

609
00:24:27,429 --> 00:24:30,549
our case we can just go for the cheaper

610
00:24:28,720 --> 00:24:33,700
ones the reason why we're not using and

611
00:24:30,549 --> 00:24:36,160
the lattice EC p5 here is just for

612
00:24:33,700 --> 00:24:39,280
tooling reasons and also obviously the

613
00:24:36,160 --> 00:24:41,470
piggery VB comes with the Xilinx FPGA in

614
00:24:39,280 --> 00:24:46,600
the middle there and the reason you

615
00:24:41,470 --> 00:24:49,630
don't see more FPGA tooling sorry or

616
00:24:46,600 --> 00:24:51,459
more FPGA you know implemented things

617
00:24:49,630 --> 00:24:53,460
implemented on PJs it's just there they

618
00:24:51,460 --> 00:24:55,690
can be a real pain to develop with and

619
00:24:53,460 --> 00:24:59,260
as I'm sure anyone would agree whose

620
00:24:55,690 --> 00:25:01,870
work with them and so the the way the

621
00:24:59,260 --> 00:25:05,200
way the FPGA but the device itself has

622
00:25:01,870 --> 00:25:07,719
look-up tables use a you know similar to

623
00:25:05,200 --> 00:25:08,650
look-up tables in a you know what when

624
00:25:07,720 --> 00:25:10,840
you're designing software or something

625
00:25:08,650 --> 00:25:12,669
like that and the difference is that

626
00:25:10,840 --> 00:25:16,649
they change value according to some

627
00:25:12,669 --> 00:25:19,179
clock that's routed along the FPGA and

628
00:25:16,650 --> 00:25:21,490
there's also hard cause an FPGA it's not

629
00:25:19,179 --> 00:25:23,410
just look up tables and and the reason

630
00:25:21,490 --> 00:25:25,480
you want these is things that are

631
00:25:23,410 --> 00:25:27,130
implemented in hardened cores require a

632
00:25:25,480 --> 00:25:28,960
lot less buy space and can potentially

633
00:25:27,130 --> 00:25:32,200
operate at a much higher frequency and

634
00:25:28,960 --> 00:25:35,169
so although PC FPGAs on the previous

635
00:25:32,200 --> 00:25:37,390
slide have an PCI Express controllers

636
00:25:35,169 --> 00:25:39,640
and that will take care of the physical

637
00:25:37,390 --> 00:25:41,350
layer and data link layer for PCI

638
00:25:39,640 --> 00:25:43,410
Express which is why we didn't talk

639
00:25:41,350 --> 00:25:46,240
about it in the in the last section and

640
00:25:43,410 --> 00:25:47,980
some some implementation some libraries

641
00:25:46,240 --> 00:25:49,840
provided by the vendors will also do the

642
00:25:47,980 --> 00:25:51,580
transaction layer processing for you as

643
00:25:49,840 --> 00:25:52,780
well but that's something obviously we

644
00:25:51,580 --> 00:25:53,980
want to control ourselves is we're going

645
00:25:52,780 --> 00:25:59,080
to be doing something slightly

646
00:25:53,980 --> 00:26:02,260
non-standard and so designing for with

647
00:25:59,080 --> 00:26:04,570
FPGA as I mentioned can be a pain the

648
00:26:02,260 --> 00:26:06,340
tooling is improving but feels like real

649
00:26:04,570 --> 00:26:09,460
step back and to software development

650
00:26:06,340 --> 00:26:11,290
and there are some interesting open

651
00:26:09,460 --> 00:26:13,000
source projects such as yo sis and and

652
00:26:11,290 --> 00:26:15,070
other things out there but it's still

653
00:26:13,000 --> 00:26:17,830
not on par with yeah software design

654
00:26:15,070 --> 00:26:19,840
and in particular and you know the

655
00:26:17,830 --> 00:26:23,019
approach you take designing encoding and

656
00:26:19,840 --> 00:26:27,340
debugging is different and bugs can be a

657
00:26:23,019 --> 00:26:30,429
real pain to to discover as I'll show a

658
00:26:27,340 --> 00:26:31,750
bit later an FPGA and and so the best

659
00:26:30,429 --> 00:26:33,250
way to approach this is similar to a

660
00:26:31,750 --> 00:26:35,320
software development approach you want

661
00:26:33,250 --> 00:26:37,360
to be writing what's called test benches

662
00:26:35,320 --> 00:26:39,279
for FPGA is similar to unit tests and

663
00:26:37,360 --> 00:26:41,408
early on to make sure your you know you

664
00:26:39,279 --> 00:26:43,539
verify your behavior there's two main

665
00:26:41,409 --> 00:26:45,940
classes of design and FPGA there's

666
00:26:43,539 --> 00:26:48,070
register transfer level and behavioral

667
00:26:45,940 --> 00:26:52,210
synthesis register transfer level is

668
00:26:48,070 --> 00:26:53,980
somewhat analogous to assembly and that

669
00:26:52,210 --> 00:26:56,139
you're you're writing very specific

670
00:26:53,980 --> 00:26:57,250
design that you're gonna know the exact

671
00:26:56,139 --> 00:26:59,229
timing and things like that and

672
00:26:57,250 --> 00:27:00,940
behavioral synthesis is more like

673
00:26:59,230 --> 00:27:02,710
working with a high-level language and

674
00:27:00,940 --> 00:27:04,179
this trade offs to the approach but

675
00:27:02,710 --> 00:27:06,009
using behavioral synthesis can be a lot

676
00:27:04,179 --> 00:27:09,129
more productive similar as similar as

677
00:27:06,009 --> 00:27:11,710
using a high level language can be but

678
00:27:09,129 --> 00:27:13,418
often the issue one of the issues of

679
00:27:11,710 --> 00:27:14,620
working with an fpga is you're quite

680
00:27:13,419 --> 00:27:16,899
constrained by what you could fit on

681
00:27:14,620 --> 00:27:20,408
there and then so to get the performance

682
00:27:16,899 --> 00:27:22,840
and to get the low utilization of the

683
00:27:20,409 --> 00:27:25,360
device resources and you often want to

684
00:27:22,840 --> 00:27:28,330
work on a register transfer level which

685
00:27:25,360 --> 00:27:31,658
is what we did and although we used

686
00:27:28,330 --> 00:27:34,120
these classes and there's other tools as

687
00:27:31,659 --> 00:27:36,519
well till these will compile down to and

688
00:27:34,120 --> 00:27:40,870
very log VHDL which are the RTL and

689
00:27:36,519 --> 00:27:42,909
languages and the benefit here is just

690
00:27:40,870 --> 00:27:46,178
you get you know modern language support

691
00:27:42,909 --> 00:27:48,009
and you and you can test things almost

692
00:27:46,179 --> 00:27:50,860
as a software approach before you test

693
00:27:48,009 --> 00:27:52,360
it on device and which you can do

694
00:27:50,860 --> 00:27:54,490
somewhat with traditional tooling but

695
00:27:52,360 --> 00:27:56,199
it's it's a lot smoother and a lot

696
00:27:54,490 --> 00:28:00,129
smoother and the other main major

697
00:27:56,200 --> 00:28:01,990
benefit is yeah some of these tool and

698
00:28:00,129 --> 00:28:03,490
can prevent what domain arrows so when

699
00:28:01,990 --> 00:28:04,659
you're running logic on an FPGA you

700
00:28:03,490 --> 00:28:06,610
often dealing with multiple clock

701
00:28:04,659 --> 00:28:08,769
domains so for instance for our use case

702
00:28:06,610 --> 00:28:10,299
we have M PCI Express running running a

703
00:28:08,769 --> 00:28:11,590
one clock domain we have we're gonna

704
00:28:10,299 --> 00:28:12,850
have spy rang at a different clock

705
00:28:11,590 --> 00:28:14,350
domain and we're gonna have logic in the

706
00:28:12,850 --> 00:28:16,959
middle that's running a third clock

707
00:28:14,350 --> 00:28:18,549
domain if you aren't careful and you're

708
00:28:16,960 --> 00:28:20,649
transferring data across these plot

709
00:28:18,549 --> 00:28:23,760
domains you can easily introduce errors

710
00:28:20,649 --> 00:28:25,989
and such as metastability issues where

711
00:28:23,760 --> 00:28:27,250
signals appear to have different values

712
00:28:25,990 --> 00:28:28,509
different places and it becomes

713
00:28:27,250 --> 00:28:30,429
dependent on and

714
00:28:28,509 --> 00:28:33,609
the values you receive on things become

715
00:28:30,429 --> 00:28:35,229
dependent on the physical length of

716
00:28:33,609 --> 00:28:37,989
wires in the FPGA which is obviously not

717
00:28:35,229 --> 00:28:41,139
what you want and traditional cooling

718
00:28:37,989 --> 00:28:42,729
does does of course allow you to you

719
00:28:41,139 --> 00:28:45,008
know report when there are errors along

720
00:28:42,729 --> 00:28:46,599
these lines and things like that but but

721
00:28:45,009 --> 00:28:48,940
some of these miss neele to new tooling

722
00:28:46,599 --> 00:28:51,489
has specific for instance type safety

723
00:28:48,940 --> 00:28:53,769
the rent set which is you know useful

724
00:28:51,489 --> 00:28:54,969
the the downside of doing this is

725
00:28:53,769 --> 00:28:57,309
there's an additional compilation step

726
00:28:54,969 --> 00:28:59,349
in the process which you know when

727
00:28:57,309 --> 00:29:00,879
things go wrong it became it can be

728
00:28:59,349 --> 00:29:06,208
harder to find out where in the stack it

729
00:29:00,879 --> 00:29:09,029
went wrong okay so this is what an FPGA

730
00:29:06,209 --> 00:29:12,429
tool chain looks like this is actually a

731
00:29:09,029 --> 00:29:13,869
silent Vivaro and as I mentioned they

732
00:29:12,429 --> 00:29:17,669
were all like proprietary further and

733
00:29:13,869 --> 00:29:20,769
they will work only for specific devices

734
00:29:17,669 --> 00:29:22,329
so synthesis and implementation are

735
00:29:20,769 --> 00:29:24,999
basically the compilation step for an

736
00:29:22,329 --> 00:29:26,979
FPGA and synthesis and takes your code

737
00:29:24,999 --> 00:29:30,249
and produces a netlist which is similar

738
00:29:26,979 --> 00:29:32,199
to IR and in the software world and then

739
00:29:30,249 --> 00:29:34,809
the implementation step takes that IR

740
00:29:32,199 --> 00:29:36,279
and makes it device device specific to

741
00:29:34,809 --> 00:29:40,569
generate a bit stream that you can then

742
00:29:36,279 --> 00:29:42,190
program an FPGA with and the unusual

743
00:29:40,569 --> 00:29:43,959
thing about this particular view is this

744
00:29:42,190 --> 00:29:46,599
this is a block view that I think is

745
00:29:43,959 --> 00:29:48,009
quite unique to the Xilinx provider to

746
00:29:46,599 --> 00:29:49,678
all their might maybe other vendors

747
00:29:48,009 --> 00:29:52,299
provide something similar I'm not sure

748
00:29:49,679 --> 00:29:53,829
the benefit of working so when we are

749
00:29:52,299 --> 00:29:56,168
coding the various modules we are

750
00:29:53,829 --> 00:29:59,289
working at the you know very log VHDL

751
00:29:56,169 --> 00:30:00,489
level but and it can be useful to have a

752
00:29:59,289 --> 00:30:02,139
block for you like this where you're

753
00:30:00,489 --> 00:30:03,819
connecting the components visually

754
00:30:02,139 --> 00:30:05,769
because as you can see there's a there's

755
00:30:03,819 --> 00:30:07,539
quite a few like inputs and outputs on

756
00:30:05,769 --> 00:30:10,479
various modules this is actually not the

757
00:30:07,539 --> 00:30:11,649
largest or the module with the largest

758
00:30:10,479 --> 00:30:13,749
number of inputs and outputs on the

759
00:30:11,649 --> 00:30:16,359
device and it can be a real pain just

760
00:30:13,749 --> 00:30:18,249
disconnecting the connecting things in

761
00:30:16,359 --> 00:30:20,139
source code which just it's basically

762
00:30:18,249 --> 00:30:22,329
you know writing out the same name

763
00:30:20,139 --> 00:30:23,619
imagine providing a function argument to

764
00:30:22,329 --> 00:30:25,119
like a hundred different places and just

765
00:30:23,619 --> 00:30:27,189
repeat them doing it's it can be tiring

766
00:30:25,119 --> 00:30:29,139
and this allows you to connect

767
00:30:27,190 --> 00:30:30,279
disconnect wise very easily and the

768
00:30:29,139 --> 00:30:31,899
other thing I want to mention here is

769
00:30:30,279 --> 00:30:34,179
you might be able to see it I'm not sure

770
00:30:31,899 --> 00:30:36,339
how large is on the on the right there's

771
00:30:34,179 --> 00:30:39,419
a integrated logic analyzer and that's

772
00:30:36,339 --> 00:30:41,480
how we're gonna do bug stuff on the FPGA

773
00:30:39,419 --> 00:30:42,980
so

774
00:30:41,480 --> 00:30:46,899
when you have an integrated logic

775
00:30:42,980 --> 00:30:49,039
analyzer on epj you can set it up to

776
00:30:46,899 --> 00:30:51,379
provide you waveforms of what's

777
00:30:49,039 --> 00:30:54,039
happening on the FPGA so the waveforms

778
00:30:51,380 --> 00:30:56,809
and I'm not sure how visible that is but

779
00:30:54,039 --> 00:30:59,240
it basically provides you with readings

780
00:30:56,809 --> 00:31:02,809
of the values over time on particularly

781
00:30:59,240 --> 00:31:05,529
wires that you select and you can set up

782
00:31:02,809 --> 00:31:07,940
trigger points 400% conditions to

783
00:31:05,529 --> 00:31:09,769
trigger the integrated logic analyzer to

784
00:31:07,940 --> 00:31:11,990
start recording because the FPGA is run

785
00:31:09,769 --> 00:31:13,880
so quick and the integrated logic

786
00:31:11,990 --> 00:31:15,799
analyzer uses resources on the FPGA

787
00:31:13,880 --> 00:31:18,470
you'll limit it to a very small window

788
00:31:15,799 --> 00:31:19,879
this it's a lot more painful than kind

789
00:31:18,470 --> 00:31:22,970
of printf debugging in the software

790
00:31:19,880 --> 00:31:25,279
world and but it's definitely necessary

791
00:31:22,970 --> 00:31:27,889
and for instance if you're if you are

792
00:31:25,279 --> 00:31:29,720
sending PCI Express requests and you

793
00:31:27,889 --> 00:31:35,389
know receiving response back you might

794
00:31:29,720 --> 00:31:38,600
set a a trigger on okay when we send a

795
00:31:35,389 --> 00:31:40,490
PCI Express request and then it will

796
00:31:38,600 --> 00:31:41,840
capture let's say 100 clocks worth of

797
00:31:40,490 --> 00:31:44,179
data and then you can look back and see

798
00:31:41,840 --> 00:31:46,928
okay yeah I can see my request going out

799
00:31:44,179 --> 00:31:49,220
I can see there's a valid ready

800
00:31:46,929 --> 00:31:50,630
signaling going on but my date it was

801
00:31:49,220 --> 00:31:53,299
malformed for some reason and then you

802
00:31:50,630 --> 00:31:56,870
could obviously try and tricks back okay

803
00:31:53,299 --> 00:32:01,879
so that's enough background and PCI

804
00:31:56,870 --> 00:32:05,239
meets FPGA so what we wanted to provide

805
00:32:01,880 --> 00:32:08,870
was PCI DMA as a simple interface right

806
00:32:05,240 --> 00:32:11,990
and we wanted to provide as a spline

807
00:32:08,870 --> 00:32:13,969
face as well so we only wanted to

808
00:32:11,990 --> 00:32:18,559
provide the kind of simple functions

809
00:32:13,970 --> 00:32:19,909
necessary the search function is is

810
00:32:18,559 --> 00:32:21,980
particularly useful having that on the

811
00:32:19,909 --> 00:32:24,320
FPGA because we can massively reduce

812
00:32:21,980 --> 00:32:27,139
downstream bandwidth required and for

813
00:32:24,320 --> 00:32:28,760
the spy consumer and also potentially

814
00:32:27,139 --> 00:32:31,820
what the spy consumer wants to send out

815
00:32:28,760 --> 00:32:33,440
over radio comms and we could add

816
00:32:31,820 --> 00:32:36,139
additional spy commands it does require

817
00:32:33,440 --> 00:32:38,149
more engineering and it can be a pain

818
00:32:36,139 --> 00:32:39,350
because we're not working a software

819
00:32:38,149 --> 00:32:40,908
level so you're you have to design

820
00:32:39,350 --> 00:32:43,549
additional circuitry to to run

821
00:32:40,909 --> 00:32:45,289
additional commands and the commands

822
00:32:43,549 --> 00:32:46,610
that we provide asynchronous that means

823
00:32:45,289 --> 00:32:48,500
you initiate them and then collect the

824
00:32:46,610 --> 00:32:50,629
results apart from the read apart from

825
00:32:48,500 --> 00:32:52,440
the write command so for instance for

826
00:32:50,629 --> 00:32:54,540
the read command you would send

827
00:32:52,440 --> 00:32:56,610
the reach mind along with a 64-bit

828
00:32:54,540 --> 00:32:58,470
address and then you would send another

829
00:32:56,610 --> 00:33:00,540
command I'm asking whether the command

830
00:32:58,470 --> 00:33:03,330
had fished the read command had finished

831
00:33:00,540 --> 00:33:06,629
and also you know how much was read and

832
00:33:03,330 --> 00:33:08,639
also the data that was read and so just

833
00:33:06,630 --> 00:33:10,800
a quick overview of spy this is one spy

834
00:33:08,640 --> 00:33:14,820
one slight overview and spies pretty

835
00:33:10,800 --> 00:33:17,460
ubiquitous in both microcontroller and

836
00:33:14,820 --> 00:33:19,340
then all all electronic devices and it's

837
00:33:17,460 --> 00:33:21,630
really simple to implement I think my

838
00:33:19,340 --> 00:33:23,760
implementation for the FPGA is like

839
00:33:21,630 --> 00:33:26,760
twenty or thirty lines long very easy to

840
00:33:23,760 --> 00:33:28,710
get get moving with and it's also pretty

841
00:33:26,760 --> 00:33:31,379
decent performance you know it runs it

842
00:33:28,710 --> 00:33:36,150
20 megahertz that's so you go like 20

843
00:33:31,380 --> 00:33:38,220
megabits the the FPGA is obviously way

844
00:33:36,150 --> 00:33:41,340
more bandwidth than that but it's it's

845
00:33:38,220 --> 00:33:43,260
not insubstantial allows us to get

846
00:33:41,340 --> 00:33:46,500
engaged off the FPGA and onto the

847
00:33:43,260 --> 00:33:49,740
microcontroller and there are other

848
00:33:46,500 --> 00:33:51,840
options and such as I I do see in you

849
00:33:49,740 --> 00:33:53,880
arts and but spy was pretty easy to get

850
00:33:51,840 --> 00:33:55,949
started with and the other thing to note

851
00:33:53,880 --> 00:33:59,280
is these are Marsha master initiated

852
00:33:55,950 --> 00:34:01,650
commands so that means when we want to

853
00:33:59,280 --> 00:34:06,720
send a command from the microphone table

854
00:34:01,650 --> 00:34:08,668
to the FPGA we in our case in reverse to

855
00:34:06,720 --> 00:34:11,250
this diagram we right raise the slave

856
00:34:08,668 --> 00:34:12,719
select line and that tells the FPGA okay

857
00:34:11,250 --> 00:34:15,060
there's a command coming and then we

858
00:34:12,719 --> 00:34:17,928
send out and receive bytes and according

859
00:34:15,060 --> 00:34:20,639
to some clock that's also sent along and

860
00:34:17,929 --> 00:34:24,320
wrong from the microcontroller to the

861
00:34:20,639 --> 00:34:27,389
FPGA okay so this is an overview of the

862
00:34:24,320 --> 00:34:29,070
what's on the FPGA itself each box here

863
00:34:27,389 --> 00:34:30,510
is an independent state machine because

864
00:34:29,070 --> 00:34:35,639
it's a circuit they're all running at

865
00:34:30,510 --> 00:34:38,340
the same time so to start off the red

866
00:34:35,639 --> 00:34:42,540
areas in the in the top left and bottom

867
00:34:38,340 --> 00:34:46,139
left that's the PCI Express clock domain

868
00:34:42,540 --> 00:34:48,989
so there's a transition there and from

869
00:34:46,139 --> 00:34:50,669
the red from red PCI Quatermain into the

870
00:34:48,989 --> 00:34:52,500
main logic which is all in the white

871
00:34:50,668 --> 00:34:54,600
domain and then similarly on the top

872
00:34:52,500 --> 00:34:58,380
right we have the the blue air which is

873
00:34:54,600 --> 00:35:01,560
this spy clock domain and yeah so

874
00:34:58,380 --> 00:35:04,610
basically the spy spy interface is very

875
00:35:01,560 --> 00:35:07,009
simple it takes a 1 by argument which is

876
00:35:04,610 --> 00:35:09,590
or one by argument and sixty four-bit

877
00:35:07,010 --> 00:35:13,640
argue our arguments the first bite sorry

878
00:35:09,590 --> 00:35:15,470
is the command identify the spy module

879
00:35:13,640 --> 00:35:18,290
and in the top right that basically

880
00:35:15,470 --> 00:35:19,939
takes the bitstream and assembles it

881
00:35:18,290 --> 00:35:21,890
into bytes the command processor

882
00:35:19,940 --> 00:35:25,160
assembles those bytes into commands and

883
00:35:21,890 --> 00:35:26,660
and with their arguments and so for

884
00:35:25,160 --> 00:35:28,490
indicate in the case of a search command

885
00:35:26,660 --> 00:35:32,990
the command will be passed to search and

886
00:35:28,490 --> 00:35:36,049
slash probe controller and obviously

887
00:35:32,990 --> 00:35:38,270
it's initiated by the commander and the

888
00:35:36,050 --> 00:35:39,950
search probe control itself will take

889
00:35:38,270 --> 00:35:42,259
that command and it's put it up into a

890
00:35:39,950 --> 00:35:45,350
bunch of windows and and pass it on to a

891
00:35:42,260 --> 00:35:47,780
number of different search control units

892
00:35:45,350 --> 00:35:51,710
and this is mainly for performance and

893
00:35:47,780 --> 00:35:54,530
it can be the sound tags and requests

894
00:35:51,710 --> 00:35:55,700
will be like fail or stall and if you

895
00:35:54,530 --> 00:35:57,440
have different tags associated with

896
00:35:55,700 --> 00:35:59,960
different regions you can get better

897
00:35:57,440 --> 00:36:01,340
performance and pipeliner and dislike

898
00:35:59,960 --> 00:36:02,900
those search units themselves contain a

899
00:36:01,340 --> 00:36:04,760
little bit of state according to you

900
00:36:02,900 --> 00:36:07,460
know like where they are in memory and

901
00:36:04,760 --> 00:36:09,710
also a window of what they've seen so

902
00:36:07,460 --> 00:36:12,500
they can yeah

903
00:36:09,710 --> 00:36:14,120
collect search results and the search

904
00:36:12,500 --> 00:36:18,410
controller and the search units will

905
00:36:14,120 --> 00:36:21,859
generate TRPs PCIT LPS that would be

906
00:36:18,410 --> 00:36:25,069
passed out to the hosts and then

907
00:36:21,860 --> 00:36:27,950
similarly we received back key Opie's in

908
00:36:25,070 --> 00:36:30,470
the in the top left and we have a stream

909
00:36:27,950 --> 00:36:32,629
reassemble and state machine and yeah

910
00:36:30,470 --> 00:36:35,629
basically when you're receiving gops

911
00:36:32,630 --> 00:36:37,460
back and as I mentioned earlier for one

912
00:36:35,630 --> 00:36:39,640
particular tag they will be ordered but

913
00:36:37,460 --> 00:36:42,800
it can be that the state of missing and

914
00:36:39,640 --> 00:36:45,470
failures and and obviously you are such

915
00:36:42,800 --> 00:36:47,720
controller and read buffer they expect

916
00:36:45,470 --> 00:36:49,790
continuous streams and so we try and

917
00:36:47,720 --> 00:36:52,730
reassemble into continuous stream and

918
00:36:49,790 --> 00:36:53,930
also we can send out more and TLPs if we

919
00:36:52,730 --> 00:36:56,150
think with miss date or something like

920
00:36:53,930 --> 00:36:58,069
that and we can also tag the data stream

921
00:36:56,150 --> 00:36:59,480
with useful information such as the tag

922
00:36:58,070 --> 00:37:02,090
that's associated with the data stream

923
00:36:59,480 --> 00:37:05,270
and how many bytes are remaining in a

924
00:37:02,090 --> 00:37:06,380
particular request so for a reader quest

925
00:37:05,270 --> 00:37:07,970
it just gets passed on to the read

926
00:37:06,380 --> 00:37:09,710
buffer the reason we have a fork a

927
00:37:07,970 --> 00:37:12,589
kilobyte read buffer is there's really

928
00:37:09,710 --> 00:37:15,050
no reason to have to ever read less than

929
00:37:12,590 --> 00:37:19,270
four kilobytes even if the spike man

930
00:37:15,050 --> 00:37:21,650
only wants a single byte

931
00:37:19,270 --> 00:37:23,509
the PCI Express is so much quicker that

932
00:37:21,650 --> 00:37:27,140
we can just fill a 4 kilobyte M buffer

933
00:37:23,510 --> 00:37:29,210
and there's no reason not to okay so

934
00:37:27,140 --> 00:37:30,980
there was there's a number of issues we

935
00:37:29,210 --> 00:37:32,390
had during this one was compiling

936
00:37:30,980 --> 00:37:36,380
induced metastability

937
00:37:32,390 --> 00:37:38,569
and basically because we'd added an

938
00:37:36,380 --> 00:37:40,070
additional compilation step there was a

939
00:37:38,570 --> 00:37:41,540
case where some of our logic was getting

940
00:37:40,070 --> 00:37:43,700
optimized out so this relates back to

941
00:37:41,540 --> 00:37:45,080
how those different clock domains said

942
00:37:43,700 --> 00:37:47,899
passing data between different clock

943
00:37:45,080 --> 00:37:50,029
demands and we done the correct approach

944
00:37:47,900 --> 00:37:51,710
of double red string data which is

945
00:37:50,030 --> 00:37:54,590
what's required to remove metastability

946
00:37:51,710 --> 00:37:57,080
but there was a case and it might have

947
00:37:54,590 --> 00:37:59,300
maybe was a user error but it could also

948
00:37:57,080 --> 00:38:01,580
be in a compiler error and there was

949
00:37:59,300 --> 00:38:05,030
removing or optimizing let's say I think

950
00:38:01,580 --> 00:38:08,420
it was shifting how the register who was

951
00:38:05,030 --> 00:38:10,220
retiming some of the registers so what

952
00:38:08,420 --> 00:38:14,210
happens when you have medicine ability

953
00:38:10,220 --> 00:38:16,040
is you have these issues where you can

954
00:38:14,210 --> 00:38:17,750
you have it you can test it value let's

955
00:38:16,040 --> 00:38:23,630
say X is equal to 1 you texted it test

956
00:38:17,750 --> 00:38:25,130
it X equal to 0 and and the tip at

957
00:38:23,630 --> 00:38:26,840
different spots will be taken instead of

958
00:38:25,130 --> 00:38:30,950
Y being assigned 0 it's assigned one and

959
00:38:26,840 --> 00:38:32,630
and it's basically due to the result

960
00:38:30,950 --> 00:38:35,180
that actually happens is dependent on

961
00:38:32,630 --> 00:38:36,650
the physical characteristics of the FPGA

962
00:38:35,180 --> 00:38:38,419
where some ways are like slightly longer

963
00:38:36,650 --> 00:38:41,630
and and this shouldn't happen right it's

964
00:38:38,420 --> 00:38:45,020
a bug of course there's also like

965
00:38:41,630 --> 00:38:46,850
another many other pain points one is

966
00:38:45,020 --> 00:38:50,390
kind of the indian madness of working

967
00:38:46,850 --> 00:38:52,549
with encapsulation inside encapsulation

968
00:38:50,390 --> 00:38:53,690
studying capsulation and eunice dealing

969
00:38:52,550 --> 00:38:55,820
with different engines is obviously a

970
00:38:53,690 --> 00:38:59,260
very common problem but as we build up

971
00:38:55,820 --> 00:39:01,580
encapsulation layers it just becomes

972
00:38:59,260 --> 00:39:03,620
it's almost as someone who's tried to

973
00:39:01,580 --> 00:39:06,020
trip you up really and so for instance

974
00:39:03,620 --> 00:39:08,600
when you're running a 64-bit address 6

975
00:39:06,020 --> 00:39:11,300
bit bit value to 64 bit address you'll

976
00:39:08,600 --> 00:39:12,440
write the high bits of the address then

977
00:39:11,300 --> 00:39:14,270
you write the low bits and then you

978
00:39:12,440 --> 00:39:15,350
write the low bits of the data and then

979
00:39:14,270 --> 00:39:17,630
the high bits of the address it's

980
00:39:15,350 --> 00:39:19,640
backwards right which and you know it's

981
00:39:17,630 --> 00:39:23,030
not a difficult thing but it definitely

982
00:39:19,640 --> 00:39:27,529
tripped me up so yeah and there's

983
00:39:23,030 --> 00:39:29,210
there's numerous other things that are

984
00:39:27,530 --> 00:39:32,600
can trip you up so for instance before

985
00:39:29,210 --> 00:39:36,140
previously I talked about and the the

986
00:39:32,600 --> 00:39:37,790
length and the address not crossing like

987
00:39:36,140 --> 00:39:40,790
a page boundary a 4 kilobyte page

988
00:39:37,790 --> 00:39:43,160
boundary and and also as I mentioned

989
00:39:40,790 --> 00:39:45,710
having that stuff not fail immediately

990
00:39:43,160 --> 00:39:47,299
having it fail like after you've made

991
00:39:45,710 --> 00:39:50,930
some requests can be a real pain in

992
00:39:47,300 --> 00:39:52,840
debugging those issues and yeah ok so

993
00:39:50,930 --> 00:39:55,310
I'll hand over to Joe now for

994
00:39:52,840 --> 00:40:02,510
integrating with the PyCon module thanks

995
00:39:55,310 --> 00:40:05,330
Ben awesome so as we know there's no

996
00:40:02,510 --> 00:40:07,340
radio on the pico EVB and we needed a

997
00:40:05,330 --> 00:40:09,710
second device to handle communication

998
00:40:07,340 --> 00:40:11,750
with the outside world and we settled on

999
00:40:09,710 --> 00:40:14,990
the PyCon family of microcontrollers for

1000
00:40:11,750 --> 00:40:16,670
developing our prototype they run micro

1001
00:40:14,990 --> 00:40:18,740
Python so they run an embedded Python

1002
00:40:16,670 --> 00:40:22,400
interpreter the idea being that we would

1003
00:40:18,740 --> 00:40:24,890
drive DMA via spy we're talking to the

1004
00:40:22,400 --> 00:40:26,450
FPGA and an expose a TCP server that

1005
00:40:24,890 --> 00:40:31,069
supports reads and writes of physical

1006
00:40:26,450 --> 00:40:33,259
memory and PyCon looked to be a perfect

1007
00:40:31,070 --> 00:40:37,310
candidate for this implementing this

1008
00:40:33,260 --> 00:40:39,350
prototype pythons easy to develop in the

1009
00:40:37,310 --> 00:40:41,960
Python family has modules that include

1010
00:40:39,350 --> 00:40:45,549
up to 5 different radio technologies so

1011
00:40:41,960 --> 00:40:48,710
you have 802 11 BGN LTE Laura and others

1012
00:40:45,550 --> 00:40:50,600
it's easily expanded via spy which is

1013
00:40:48,710 --> 00:40:52,010
what we ended up using IDE you see you

1014
00:40:50,600 --> 00:40:53,509
have lots of pins available for GPIO

1015
00:40:52,010 --> 00:40:55,310
some of the other platforms we looked at

1016
00:40:53,510 --> 00:40:57,410
were smaller but they just didn't have

1017
00:40:55,310 --> 00:41:00,590
enough pins and it's pretty tiny it's

1018
00:40:57,410 --> 00:41:04,129
not as big as the Pico EVB but close 5.5

1019
00:41:00,590 --> 00:41:05,600
by two centimeters but they're also

1020
00:41:04,130 --> 00:41:07,790
challenges working with the PI comm in

1021
00:41:05,600 --> 00:41:10,339
this context we're trying to support

1022
00:41:07,790 --> 00:41:13,340
64-bit reads and writes but the PI comm

1023
00:41:10,340 --> 00:41:15,170
has an extensive dual core Alex 6 CPU

1024
00:41:13,340 --> 00:41:17,650
it's a 32-bit architecture so you can

1025
00:41:15,170 --> 00:41:20,780
natively represent 64-bit values

1026
00:41:17,650 --> 00:41:23,300
something to account for memory is

1027
00:41:20,780 --> 00:41:25,310
naturally limited 4 Meg's of RAM 8 banks

1028
00:41:23,300 --> 00:41:27,680
of flash even though you're developing

1029
00:41:25,310 --> 00:41:29,990
in Python you have to be careful with

1030
00:41:27,680 --> 00:41:32,060
data copies heap fragmentation can

1031
00:41:29,990 --> 00:41:34,669
affect the stability of the device and

1032
00:41:32,060 --> 00:41:37,130
we don't want it timing out not being

1033
00:41:34,670 --> 00:41:39,070
accessible and you know we're relying on

1034
00:41:37,130 --> 00:41:41,500
spy which is compared to PCI

1035
00:41:39,070 --> 00:41:42,550
comparatively low band

1036
00:41:41,500 --> 00:41:44,980
but these none of these were

1037
00:41:42,550 --> 00:41:48,100
deal-breakers our software accounts for

1038
00:41:44,980 --> 00:41:49,600
these challenges and just to give you

1039
00:41:48,100 --> 00:41:51,549
sort of a visual representation of the

1040
00:41:49,600 --> 00:41:53,140
software stack on the radio side so Ben

1041
00:41:51,550 --> 00:41:55,150
was talking about the purple square the

1042
00:41:53,140 --> 00:41:56,950
Pico DMA we're communicating with that

1043
00:41:55,150 --> 00:41:59,410
over spy and then if we follow the

1044
00:41:56,950 --> 00:42:01,899
bouncing ball we have more complex

1045
00:41:59,410 --> 00:42:05,109
layers for communicating with the Pico

1046
00:42:01,900 --> 00:42:06,940
DMA we have a Ross PI modules by WI it

1047
00:42:05,110 --> 00:42:10,990
supports fixed length reads and writes

1048
00:42:06,940 --> 00:42:13,060
and 32k searches over memory which is

1049
00:42:10,990 --> 00:42:15,750
value that we found stable but we're

1050
00:42:13,060 --> 00:42:18,549
hoping to increase there's a more

1051
00:42:15,750 --> 00:42:20,350
complex module spy util that sports

1052
00:42:18,550 --> 00:42:22,060
block based reads writes and searches so

1053
00:42:20,350 --> 00:42:24,009
it allows you to operate over larger

1054
00:42:22,060 --> 00:42:27,940
ranges of memory and sort of abstracts

1055
00:42:24,010 --> 00:42:30,160
away the fixed block sizes of the FPGA

1056
00:42:27,940 --> 00:42:31,540
itself and the last piece that we

1057
00:42:30,160 --> 00:42:34,180
implemented that was really important is

1058
00:42:31,540 --> 00:42:37,450
streaming reads and writes so basically

1059
00:42:34,180 --> 00:42:40,299
we have a spy DMA object that takes a

1060
00:42:37,450 --> 00:42:43,180
socket and shoves data out on it in

1061
00:42:40,300 --> 00:42:44,320
response to read and write requests and

1062
00:42:43,180 --> 00:42:46,990
I mentioned earlier we have a server

1063
00:42:44,320 --> 00:42:50,290
thread that takes inbound read and write

1064
00:42:46,990 --> 00:42:53,470
commands in the format that PCI liche

1065
00:42:50,290 --> 00:42:55,690
sends with the raw TCP device so we can

1066
00:42:53,470 --> 00:42:58,319
point TC we can point PCI leach at this

1067
00:42:55,690 --> 00:43:02,710
thing and start reading and writing

1068
00:42:58,320 --> 00:43:04,540
memory in terms of connectivity throwing

1069
00:43:02,710 --> 00:43:06,880
this in as a wiring guide in the top

1070
00:43:04,540 --> 00:43:09,040
right you see the Pico EVB that's the

1071
00:43:06,880 --> 00:43:10,830
back of the board there are general

1072
00:43:09,040 --> 00:43:13,990
multi-purpose i/o pins on the bottom

1073
00:43:10,830 --> 00:43:16,569
they're oriented with pin one at the top

1074
00:43:13,990 --> 00:43:19,209
and that connects to the Associated pins

1075
00:43:16,570 --> 00:43:23,200
on the PI comm you can get wires on

1076
00:43:19,210 --> 00:43:25,710
digi-key that are quite long so it's

1077
00:43:23,200 --> 00:43:28,330
flexible in terms of where you deploy it

1078
00:43:25,710 --> 00:43:30,990
and you'll notice that the the the v in

1079
00:43:28,330 --> 00:43:33,400
the VN pin is read and I'll tell you why

1080
00:43:30,990 --> 00:43:36,819
there are some fun gotchas as far as

1081
00:43:33,400 --> 00:43:40,240
integration goes connecting the 3.3 volt

1082
00:43:36,820 --> 00:43:42,490
pin on the PI com2 the Pico EVB as you'd

1083
00:43:40,240 --> 00:43:44,319
expect would kill the Pico EVB and I

1084
00:43:42,490 --> 00:43:48,149
don't recommend doing this two days

1085
00:43:44,320 --> 00:43:48,150
before the conference don't pull a Joel

1086
00:43:48,210 --> 00:43:53,560
code uploads often die and the Python

1087
00:43:51,670 --> 00:43:54,010
becomes unbootable and you'll want to

1088
00:43:53,560 --> 00:43:55,630
have

1089
00:43:54,010 --> 00:43:58,480
tool handy in the bottom right I have my

1090
00:43:55,630 --> 00:44:01,720
tool that I made precision craftsmanship

1091
00:43:58,480 --> 00:44:03,930
and kind of representative of my state

1092
00:44:01,720 --> 00:44:06,609
of mind throughout this project you can

1093
00:44:03,930 --> 00:44:08,669
hold pin 12 high and boot into a

1094
00:44:06,609 --> 00:44:11,259
recovery mode end up doing that a lot

1095
00:44:08,670 --> 00:44:14,530
the wireless configuration is brittle

1096
00:44:11,260 --> 00:44:16,570
and dangerous so be careful and now

1097
00:44:14,530 --> 00:44:18,160
let's try some live demos so we have the

1098
00:44:16,570 --> 00:44:21,220
the nut box that I mentioned up here

1099
00:44:18,160 --> 00:44:23,770
it's running Ubuntu 1604 o 6 we have a 4

1100
00:44:21,220 --> 00:44:26,529
8 o 58 generic kernel which is supported

1101
00:44:23,770 --> 00:44:29,350
by PCI leach it's a soft target vtg is

1102
00:44:26,530 --> 00:44:31,420
disabled we've disabled kernel ASLR not

1103
00:44:29,350 --> 00:44:33,549
a defense against DMA attacks by any

1104
00:44:31,420 --> 00:44:36,010
means but it does gives us reliable

1105
00:44:33,550 --> 00:44:38,350
offsets for expedience in the demo and

1106
00:44:36,010 --> 00:44:40,450
this machine's happen to be it happens

1107
00:44:38,350 --> 00:44:42,220
to be air gapped there aren't working

1108
00:44:40,450 --> 00:44:44,529
drivers for that kernel version that are

1109
00:44:42,220 --> 00:44:49,180
packaged so it has no connectivity other

1110
00:44:44,530 --> 00:44:54,190
than the Pico DMA so let's let's give

1111
00:44:49,180 --> 00:44:58,000
this a try alright so we will start by

1112
00:44:54,190 --> 00:45:05,800
connecting oh shit sorry

1113
00:44:58,000 --> 00:45:07,900
choose how do I do that there we go

1114
00:45:05,800 --> 00:45:10,830
awesome okay so we've connected to the

1115
00:45:07,900 --> 00:45:16,350
the the radio itself we're gonna log in

1116
00:45:10,830 --> 00:45:16,350
the black hat password here goes nothing

1117
00:45:16,740 --> 00:45:21,299
good and now we have a Python rebel so

1118
00:45:27,240 --> 00:45:34,240
now we will run our demo so far so good

1119
00:45:30,960 --> 00:45:38,530
awesome so bump up the font size a

1120
00:45:34,240 --> 00:45:40,868
little bit and we'll get started so we

1121
00:45:38,530 --> 00:45:42,130
have little basic system information the

1122
00:45:40,869 --> 00:45:44,800
important thing here is note that the

1123
00:45:42,130 --> 00:45:45,730
heap is quite small for okay we have a

1124
00:45:44,800 --> 00:45:47,350
little bit of information about the

1125
00:45:45,730 --> 00:45:50,200
device itself it's running at 160

1126
00:45:47,350 --> 00:45:52,830
megahertz here's the pin outs this is

1127
00:45:50,200 --> 00:45:55,930
configurable on the PyCon side is useful

1128
00:45:52,830 --> 00:45:57,400
we have a server running and seems to be

1129
00:45:55,930 --> 00:45:59,589
alive is running is true it's a good

1130
00:45:57,400 --> 00:46:01,540
sign now we'll get into actual

1131
00:45:59,590 --> 00:46:03,970
communication with the FPGA so let's

1132
00:46:01,540 --> 00:46:05,620
test SPI connectivity

1133
00:46:03,970 --> 00:46:07,419
and we're running a thousand trials and

1134
00:46:05,620 --> 00:46:09,970
we have a failure rate of zero which is

1135
00:46:07,420 --> 00:46:14,350
good because during development we did

1136
00:46:09,970 --> 00:46:16,450
have failure rates that were higher do a

1137
00:46:14,350 --> 00:46:20,069
quick read of memory seems to be working

1138
00:46:16,450 --> 00:46:22,569
now we're gonna find the base address

1139
00:46:20,070 --> 00:46:24,760
sorry I hit tab they're finding the base

1140
00:46:22,570 --> 00:46:26,980
address of the kernel and we're using

1141
00:46:24,760 --> 00:46:28,300
search to do so so that seems to be

1142
00:46:26,980 --> 00:46:30,100
working well that's a good sign

1143
00:46:28,300 --> 00:46:35,620
and we're going to do a second read of

1144
00:46:30,100 --> 00:46:37,720
the first page of the Linux kernel I'm

1145
00:46:35,620 --> 00:46:40,299
gonna skip PCIe each integration because

1146
00:46:37,720 --> 00:46:42,100
because of time but we'll see PC I'll

1147
00:46:40,300 --> 00:46:46,600
each in a second but we can also read

1148
00:46:42,100 --> 00:46:50,380
and write using PCI leach and now let's

1149
00:46:46,600 --> 00:46:54,190
try a write to memory so nice quiet

1150
00:46:50,380 --> 00:46:56,830
location in kernel memory all nulls now

1151
00:46:54,190 --> 00:46:59,770
we will do a right here you see pretty

1152
00:46:56,830 --> 00:47:02,620
crude black hat logo and okay the device

1153
00:46:59,770 --> 00:47:09,480
seems pretty healthy so let's move into

1154
00:47:02,620 --> 00:47:11,410
something a little more interesting so

1155
00:47:09,480 --> 00:47:13,840
we're actually able to compute the

1156
00:47:11,410 --> 00:47:16,569
offsets that PCI which requires FPGA

1157
00:47:13,840 --> 00:47:19,270
side but in the interest of time I've

1158
00:47:16,570 --> 00:47:20,830
supplying them on the command line and

1159
00:47:19,270 --> 00:47:27,910
now we're trying to load a kernel mode

1160
00:47:20,830 --> 00:47:29,799
implant takes a little takes a minute or

1161
00:47:27,910 --> 00:47:33,100
two I think if we look over here yep we

1162
00:47:29,800 --> 00:47:35,490
got activity here reads and writes looks

1163
00:47:33,100 --> 00:47:35,490
healthy

1164
00:47:43,730 --> 00:47:52,070
it's uh it's a lot slower here than it

1165
00:47:45,650 --> 00:47:54,740
is elsewhere there's our first try okay

1166
00:47:52,070 --> 00:47:57,530
great so here's the offsets that we're

1167
00:47:54,740 --> 00:48:00,109
using we've inserted code into the

1168
00:47:57,530 --> 00:48:03,859
kernel and it looks like PCI leach is

1169
00:48:00,109 --> 00:48:06,859
happy so we've now compromised this air

1170
00:48:03,859 --> 00:48:08,480
gap machine and now we're going to pull

1171
00:48:06,859 --> 00:48:10,670
sensitive credentials using this

1172
00:48:08,480 --> 00:48:13,280
software implant PCI leach of course

1173
00:48:10,670 --> 00:48:17,300
doing the heavy lifting here so we'll

1174
00:48:13,280 --> 00:48:21,350
start with some user credentials that

1175
00:48:17,300 --> 00:48:23,480
seems to be working I think we only have

1176
00:48:21,350 --> 00:48:25,790
a minute and a half left so I am going

1177
00:48:23,480 --> 00:48:28,640
to switch back to slides but long story

1178
00:48:25,790 --> 00:48:38,720
short pulling credentials works we can

1179
00:48:28,640 --> 00:48:40,790
do whatever we want at this point all

1180
00:48:38,720 --> 00:48:43,009
right so just some some quick takeaways

1181
00:48:40,790 --> 00:48:45,250
EMEA implants are more flexible as we

1182
00:48:43,010 --> 00:48:47,420
saw give us new variations in attacks

1183
00:48:45,250 --> 00:48:49,940
the Pico EVB is definitely a great

1184
00:48:47,420 --> 00:48:52,070
platform for DNA research and we dealt

1185
00:48:49,940 --> 00:48:53,630
with plenty of challenges developing a

1186
00:48:52,070 --> 00:48:56,060
working prototype but we were able to

1187
00:48:53,630 --> 00:48:58,100
overcome them we're planning to release

1188
00:48:56,060 --> 00:49:00,740
all our software check out github comm

1189
00:48:58,100 --> 00:49:01,549
Pico DMA the radio software should be up

1190
00:49:00,740 --> 00:49:03,859
there today

1191
00:49:01,550 --> 00:49:05,270
I just haven't posted it yet FPGA

1192
00:49:03,859 --> 00:49:06,200
software is coming Ben's just going to

1193
00:49:05,270 --> 00:49:08,720
clean it up a little bit

1194
00:49:06,200 --> 00:49:11,359
we do have a PCI leach client that you

1195
00:49:08,720 --> 00:49:13,850
can use with the radio and other useful

1196
00:49:11,359 --> 00:49:15,049
tools that we've developed and then we

1197
00:49:13,850 --> 00:49:17,420
have 40-second can you just pull the

1198
00:49:15,050 --> 00:49:19,840
turbo up again let's just see if it

1199
00:49:17,420 --> 00:49:24,260
worked just so you guys know we're not

1200
00:49:19,840 --> 00:49:26,930
pulling your leg yeah okay so here we

1201
00:49:24,260 --> 00:49:30,800
have aw aw spreads hold from the device

1202
00:49:26,930 --> 00:49:32,600
and 30 seconds so I don't think we have

1203
00:49:30,800 --> 00:49:34,730
time for questions now but there is a

1204
00:49:32,600 --> 00:49:37,400
follow up room and we're happy to do

1205
00:49:34,730 --> 00:49:39,920
live demos and answer questions there so

1206
00:49:37,400 --> 00:49:41,480
thank you so much everyone thanks for

1207
00:49:39,920 --> 00:49:42,540
coming thanks to oaf and all the other

1208
00:49:41,480 --> 00:49:46,820
researchers I mentioned

1209
00:49:42,540 --> 00:49:46,820
[Applause]

