1
00:00:00,000 --> 00:00:05,819
this session is attacking iPhone XS Max

2
00:00:03,149 --> 00:00:09,540
and this room is South Pacific and our

3
00:00:05,819 --> 00:00:11,370
speaker is TLA Y so I don't have a great

4
00:00:09,540 --> 00:00:12,989
deal to cover because I think most

5
00:00:11,370 --> 00:00:15,030
things are sort of wrapping up but don't

6
00:00:12,990 --> 00:00:17,279
forget the merchandise store on level 2

7
00:00:15,030 --> 00:00:19,198
and session recordings mess ok they have

8
00:00:17,279 --> 00:00:21,270
a desk on every level and the other

9
00:00:19,199 --> 00:00:23,340
thing to remember is to put your cell

10
00:00:21,270 --> 00:00:25,948
phone on vibrate please it's way more

11
00:00:23,340 --> 00:00:28,439
pleasant for everybody else that way so

12
00:00:25,949 --> 00:00:31,460
without further ado please join me in

13
00:00:28,439 --> 00:00:39,239
providing a warm welcome to TLA well

14
00:00:31,460 --> 00:00:41,820
thank you thank you thank you so much

15
00:00:39,239 --> 00:00:45,269
for coming to my second talk this year

16
00:00:41,820 --> 00:00:48,539
and the title is attacking iPhone 10s

17
00:00:45,270 --> 00:00:51,780
Mac's the work is about how we do break

18
00:00:48,539 --> 00:00:55,410
the iPhone TX max last year the work was

19
00:00:51,780 --> 00:00:58,410
done by me and how she and we are the

20
00:00:55,410 --> 00:01:00,510
members of Kim Pangu we we did release

21
00:00:58,410 --> 00:01:03,538
two breakthroughs in the past for many

22
00:01:00,510 --> 00:01:05,399
times and unfortunately who didn't come

23
00:01:03,539 --> 00:01:09,049
here for personal reason so the

24
00:01:05,400 --> 00:01:12,720
presentation will be done by myself and

25
00:01:09,049 --> 00:01:15,479
this is the a plan of the talk and the

26
00:01:12,720 --> 00:01:18,990
first I'm going to introduce Colonel

27
00:01:15,479 --> 00:01:22,890
Bach in the UNIX domain socket me xnu

28
00:01:18,990 --> 00:01:25,339
kernel and I will analyze the root cause

29
00:01:22,890 --> 00:01:29,630
and the patent after that I will

30
00:01:25,340 --> 00:01:33,360
describe how we exploit hit the park for

31
00:01:29,630 --> 00:01:37,439
from devices before iPhone 10 smacks

32
00:01:33,360 --> 00:01:40,229
that has ate her chips and after that I

33
00:01:37,439 --> 00:01:43,679
will explain why our original export

34
00:01:40,229 --> 00:01:46,740
didn't work for the latest hardware

35
00:01:43,680 --> 00:01:50,520
model because of the hardware based

36
00:01:46,740 --> 00:01:52,770
mechanism called a pack and I will

37
00:01:50,520 --> 00:01:56,460
analyze the implementation of the pack

38
00:01:52,770 --> 00:01:59,520
on iPhone and then we were good to say

39
00:01:56,460 --> 00:02:03,780
how we're a it's portable and do breaks

40
00:01:59,520 --> 00:02:06,420
iPhone 10s max and conclude the talk so

41
00:02:03,780 --> 00:02:08,580
I'm I think most of attendees here are

42
00:02:06,420 --> 00:02:11,038
familiar with UNIX dome and socket but

43
00:02:08,580 --> 00:02:12,810
just in case I will please allow me to

44
00:02:11,038 --> 00:02:15,510
use to page

45
00:02:12,810 --> 00:02:18,620
to explain the basic usage of UNIX

46
00:02:15,510 --> 00:02:22,829
domain socket UNIX domain socket is a

47
00:02:18,620 --> 00:02:25,920
mechanism that allows different process

48
00:02:22,830 --> 00:02:28,260
on the same device to do the data

49
00:02:25,920 --> 00:02:32,040
exchange so it's a inter process

50
00:02:28,260 --> 00:02:35,849
communication channel the two piece of

51
00:02:32,040 --> 00:02:38,040
code here shows how the basically usage

52
00:02:35,849 --> 00:02:40,079
of the UNIX domain socket you don't have

53
00:02:38,040 --> 00:02:42,989
to read the code I will explain for you

54
00:02:40,080 --> 00:02:45,989
so basically you create a socket and the

55
00:02:42,989 --> 00:02:49,049
specify is a UNIX domain socket and a

56
00:02:45,989 --> 00:02:52,290
being for the floor side you need to

57
00:02:49,049 --> 00:02:55,019
bind a socket to a file pass and then

58
00:02:52,290 --> 00:02:58,530
you can read the socket as if it's a

59
00:02:55,019 --> 00:03:01,769
file or whatever so you can do it from

60
00:02:58,530 --> 00:03:04,709
the socket and a fall client what you

61
00:03:01,769 --> 00:03:07,950
need to do is first you create a socket

62
00:03:04,709 --> 00:03:11,430
and the rather than binding it to a file

63
00:03:07,950 --> 00:03:14,310
path you need to connect the socket to

64
00:03:11,430 --> 00:03:18,209
the file path that is used by the server

65
00:03:14,310 --> 00:03:21,030
and then you are able to write to the

66
00:03:18,209 --> 00:03:23,609
socket the data you write to the socket

67
00:03:21,030 --> 00:03:26,280
will be received by the Theroux

68
00:03:23,609 --> 00:03:30,450
so this is a basic usage very basic

69
00:03:26,280 --> 00:03:32,549
usage of UNIX domain sockets so let's

70
00:03:30,450 --> 00:03:37,048
say what happened in the kernel let's

71
00:03:32,549 --> 00:03:40,739
move our eye into the kernel so first

72
00:03:37,049 --> 00:03:42,780
when we create a UNIX domain socket the

73
00:03:40,739 --> 00:03:46,019
socket function will trap into the

74
00:03:42,780 --> 00:03:48,840
kernel and then a bunch of our sequence

75
00:03:46,019 --> 00:03:52,500
of kernel functions will be executed and

76
00:03:48,840 --> 00:03:57,120
including I so created underlying to

77
00:03:52,500 --> 00:03:59,700
know I saw a log u NT attached and among

78
00:03:57,120 --> 00:04:03,630
after the execution of such kernel

79
00:03:59,700 --> 00:04:07,069
functions a number of kernel data

80
00:04:03,630 --> 00:04:10,590
structures will be updated all created

81
00:04:07,069 --> 00:04:13,380
among such data structures we just need

82
00:04:10,590 --> 00:04:16,350
to remember that the kernel will create

83
00:04:13,380 --> 00:04:20,519
a structure called soft socket and

84
00:04:16,350 --> 00:04:22,620
another structure called UN PCB and the

85
00:04:20,519 --> 00:04:25,620
reference registers relationship between

86
00:04:22,620 --> 00:04:26,490
the two structures looks very simple so

87
00:04:25,620 --> 00:04:30,060
basically

88
00:04:26,490 --> 00:04:33,539
I saw protocol the circuit structure has

89
00:04:30,060 --> 00:04:36,449
a field called SEO PCB which points to

90
00:04:33,539 --> 00:04:38,849
UM PCB and the you implicitly has a

91
00:04:36,449 --> 00:04:42,810
field called the Olympia socket which

92
00:04:38,849 --> 00:04:46,560
points back to the socket after that we

93
00:04:42,810 --> 00:04:48,630
bind the socket to a file name what

94
00:04:46,560 --> 00:04:51,780
happened in the kernel is this that the

95
00:04:48,630 --> 00:04:54,870
binder this call trapped in traps into

96
00:04:51,780 --> 00:04:57,719
the kernel and it will eventually call

97
00:04:54,870 --> 00:04:59,370
function called the UMP bind for the

98
00:04:57,720 --> 00:05:02,610
first impression

99
00:04:59,370 --> 00:05:05,099
UMP bind is surrounded by socket lock

100
00:05:02,610 --> 00:05:09,659
and unlock so for the first impression

101
00:05:05,099 --> 00:05:12,690
this function seems not visible what you

102
00:05:09,659 --> 00:05:15,090
imply bind data is it will create a new

103
00:05:12,690 --> 00:05:18,990
window the specified is type is very

104
00:05:15,090 --> 00:05:23,099
sock and update the related pointing

105
00:05:18,990 --> 00:05:26,400
relationship to be specific you in PCB

106
00:05:23,099 --> 00:05:29,069
will update its field called UMP

107
00:05:26,400 --> 00:05:31,560
winnowed which we appoint you the

108
00:05:29,069 --> 00:05:33,960
winnowed and as we know that we has

109
00:05:31,560 --> 00:05:37,280
another field called V underline socket

110
00:05:33,960 --> 00:05:41,580
which will point back to the socket so

111
00:05:37,280 --> 00:05:46,258
it's very clear relationship but if you

112
00:05:41,580 --> 00:05:48,719
took a further look and UMP bind you

113
00:05:46,259 --> 00:05:52,530
will notice actually there is a

114
00:05:48,719 --> 00:05:55,440
temporary unlock because creation of a

115
00:05:52,530 --> 00:05:58,109
node is kind of time consuming so the

116
00:05:55,440 --> 00:06:01,380
kernel doesn't want to lock the cicadas

117
00:05:58,110 --> 00:06:03,780
for a very long time so there is a

118
00:06:01,380 --> 00:06:06,659
temporary unlock during the creation of

119
00:06:03,780 --> 00:06:10,229
the the winnowed it's good for

120
00:06:06,659 --> 00:06:14,610
performance but it introduced a risk

121
00:06:10,229 --> 00:06:17,190
condition so the kernel function will be

122
00:06:14,610 --> 00:06:19,620
executed in this sequence and the red

123
00:06:17,190 --> 00:06:22,800
box here marked the temporary unlock

124
00:06:19,620 --> 00:06:25,830
that means and the beginning UMP binder

125
00:06:22,800 --> 00:06:29,849
is protect protected by the lock but due

126
00:06:25,830 --> 00:06:30,990
to the temporary a lock we can risk into

127
00:06:29,849 --> 00:06:34,770
UMP bind

128
00:06:30,990 --> 00:06:38,460
assume we have to thrice the two strides

129
00:06:34,770 --> 00:06:41,250
are trying to bind the same socket to

130
00:06:38,460 --> 00:06:42,020
two different fire paths what would

131
00:06:41,250 --> 00:06:47,250
happen

132
00:06:42,020 --> 00:06:49,049
so the to bind function we are trapped

133
00:06:47,250 --> 00:06:51,330
into the kernel and finally you won't be

134
00:06:49,050 --> 00:06:55,740
binary will be executed and at the same

135
00:06:51,330 --> 00:06:58,710
time and two we nose will be created and

136
00:06:55,740 --> 00:07:01,400
but you in PCB will only keep a by

137
00:06:58,710 --> 00:07:04,859
reference to one of the two windows and

138
00:07:01,400 --> 00:07:07,650
but the two-way nose will both how

139
00:07:04,860 --> 00:07:12,150
reference how a pointer pointing back to

140
00:07:07,650 --> 00:07:14,340
the socket so and this moment nothing

141
00:07:12,150 --> 00:07:16,469
wrong so there's no panic no memory

142
00:07:14,340 --> 00:07:20,369
corruption just a 2-way knows they are

143
00:07:16,470 --> 00:07:23,130
holding the same Haunter now let's say

144
00:07:20,370 --> 00:07:25,560
we don't care about great if what

145
00:07:23,130 --> 00:07:27,900
happened if we close the socket the

146
00:07:25,560 --> 00:07:30,920
closed traps into the kernel and fine

147
00:07:27,900 --> 00:07:33,719
you later will go to are so close i

148
00:07:30,920 --> 00:07:37,290
school i so close will cling up the

149
00:07:33,720 --> 00:07:40,260
memory and the socket will be afraid on

150
00:07:37,290 --> 00:07:43,320
the UN PCB will be afraid one of the way

151
00:07:40,260 --> 00:07:46,469
nose will be cleaned the so the pointer

152
00:07:43,320 --> 00:07:49,469
will be clean we will be clean clear to

153
00:07:46,470 --> 00:07:51,720
be zero but there is another way note

154
00:07:49,470 --> 00:07:55,140
there's no reference to this way note

155
00:07:51,720 --> 00:07:57,630
so this we know the still holding the

156
00:07:55,140 --> 00:08:00,930
pointer pointing back to afraid memory

157
00:07:57,630 --> 00:08:03,180
so after we close the socket

158
00:08:00,930 --> 00:08:06,380
okay and this moment nothing wrong so

159
00:08:03,180 --> 00:08:09,750
there's no panic no memory corruption

160
00:08:06,380 --> 00:08:14,820
but we can trigger or use of a free or

161
00:08:09,750 --> 00:08:17,250
UAF by connecting to the to fire pass if

162
00:08:14,820 --> 00:08:20,340
we call connect connect us another

163
00:08:17,250 --> 00:08:22,320
socket to the two different file paths

164
00:08:20,340 --> 00:08:25,739
because we don't know which file path is

165
00:08:22,320 --> 00:08:29,670
holding the dangling pointer so we we

166
00:08:25,740 --> 00:08:32,460
can connect twice connect kernel

167
00:08:29,670 --> 00:08:34,890
function is complicated but it will

168
00:08:32,460 --> 00:08:38,760
usually will go to a function called UMP

169
00:08:34,890 --> 00:08:41,880
Connect and what you in pconnect do is

170
00:08:38,760 --> 00:08:45,630
this material tries to look hard the we

171
00:08:41,880 --> 00:08:49,350
node by the file name if the we note in

172
00:08:45,630 --> 00:08:52,050
there is comparable to confirm that the

173
00:08:49,350 --> 00:08:55,230
we know the type is we saw

174
00:08:52,050 --> 00:08:58,620
we suck if it's a we stock it we will

175
00:08:55,230 --> 00:09:01,680
try to fetch access its member Reece oak

176
00:08:58,620 --> 00:09:04,260
we socket and then the we circuit will

177
00:09:01,680 --> 00:09:07,680
be passed into a function called socket

178
00:09:04,260 --> 00:09:09,750
lock so the dangling pointer in one of

179
00:09:07,680 --> 00:09:14,609
the windows will pass into this function

180
00:09:09,750 --> 00:09:17,880
is a typical UAS this page shows the

181
00:09:14,610 --> 00:09:20,700
minimum of POC code for the back

182
00:09:17,880 --> 00:09:24,750
basically you can create a two socket

183
00:09:20,700 --> 00:09:28,140
and for the first one you run to thrice

184
00:09:24,750 --> 00:09:30,720
the truth rights bind the socket to two

185
00:09:28,140 --> 00:09:34,620
different file pass if you it's very

186
00:09:30,720 --> 00:09:38,430
easy to to win the the risk condition

187
00:09:34,620 --> 00:09:41,160
after that you close the socket so you

188
00:09:38,430 --> 00:09:44,459
will create a dangling pointer in one of

189
00:09:41,160 --> 00:09:47,100
the two windows after that you connected

190
00:09:44,460 --> 00:09:48,240
the another socket to the two different

191
00:09:47,100 --> 00:09:51,270
file paths

192
00:09:48,240 --> 00:09:55,850
likely you will trigger a panic or some

193
00:09:51,270 --> 00:09:59,340
some weird thing so this is the park and

194
00:09:55,850 --> 00:10:04,680
I think the back was finally fixed in

195
00:09:59,340 --> 00:10:05,640
version 12.2 and the fit the fixed is

196
00:10:04,680 --> 00:10:08,160
kind of tricky

197
00:10:05,640 --> 00:10:12,270
now the bind function is still

198
00:10:08,160 --> 00:10:14,189
reasonable but after UMP binary takes a

199
00:10:12,270 --> 00:10:19,100
log to the socket it will check whether

200
00:10:14,190 --> 00:10:22,350
during PCB we know this is now or not so

201
00:10:19,100 --> 00:10:24,270
although it's still reasonable but it's

202
00:10:22,350 --> 00:10:29,750
only when we know the we'll have a

203
00:10:24,270 --> 00:10:32,699
reference to the socket so it is fixed

204
00:10:29,750 --> 00:10:36,510
there's no public civilly so very likely

205
00:10:32,700 --> 00:10:43,080
is audited by Apple internal security

206
00:10:36,510 --> 00:10:46,050
team so after I found the bug I realized

207
00:10:43,080 --> 00:10:48,570
that actually more and more bugs they

208
00:10:46,050 --> 00:10:52,199
are caused by temporary unlocks over

209
00:10:48,570 --> 00:10:53,610
discovered recently and for example a

210
00:10:52,200 --> 00:10:56,400
couple months ago

211
00:10:53,610 --> 00:11:00,390
embr from Google Protege row released

212
00:10:56,400 --> 00:11:02,699
the bug in VM copy operation it's also

213
00:11:00,390 --> 00:11:05,080
caused by a temporal log and the two

214
00:11:02,700 --> 00:11:08,080
years ago Adam has a bug in

215
00:11:05,080 --> 00:11:10,660
okay especially in our surface allocated

216
00:11:08,080 --> 00:11:13,600
Molly oh it's also caused by a temporary

217
00:11:10,660 --> 00:11:16,569
unlock so we can find the same part in

218
00:11:13,600 --> 00:11:21,180
box in different modules like IO cage

219
00:11:16,570 --> 00:11:24,610
and VM and also socket so I believe that

220
00:11:21,180 --> 00:11:27,069
temporary a lock will become very

221
00:11:24,610 --> 00:11:29,560
important bug pattern so when we do bug

222
00:11:27,070 --> 00:11:31,630
funding I maybe we should pay more

223
00:11:29,560 --> 00:11:36,959
attention on this kind of temporary or

224
00:11:31,630 --> 00:11:40,840
not okay now we go to the explosion

225
00:11:36,960 --> 00:11:44,400
exploitation how we exported bark on old

226
00:11:40,840 --> 00:11:47,380
iOS devices then to reserved ETL chips

227
00:11:44,400 --> 00:11:48,520
so because it's a finally the risk

228
00:11:47,380 --> 00:11:53,320
condition turns into

229
00:11:48,520 --> 00:11:55,990
UAF let's take a look at the use the

230
00:11:53,320 --> 00:11:59,770
dangling pointer socket will be used by

231
00:11:55,990 --> 00:12:04,120
the function called socket socket lock

232
00:11:59,770 --> 00:12:06,120
you'd you may you may not want to read

233
00:12:04,120 --> 00:12:09,790
all the code but if you look an albino

234
00:12:06,120 --> 00:12:12,790
binding binary version you will find how

235
00:12:09,790 --> 00:12:16,510
how beautiful the bug it is so first

236
00:12:12,790 --> 00:12:20,219
there is a function pointer home after

237
00:12:16,510 --> 00:12:23,620
to the reference from of read socket and

238
00:12:20,220 --> 00:12:28,090
if we can bypass that there's another

239
00:12:23,620 --> 00:12:31,930
right the the drug will see a return

240
00:12:28,090 --> 00:12:36,970
address to the freed circuit so the

241
00:12:31,930 --> 00:12:41,260
binary binary word may be clear so the

242
00:12:36,970 --> 00:12:44,290
first from dangling pointer it will try

243
00:12:41,260 --> 00:12:48,490
to access a cattle pointer from offset

244
00:12:44,290 --> 00:12:51,010
zero acts 1:8 and from that point hurry

245
00:12:48,490 --> 00:12:54,130
to get another function pointer from

246
00:12:51,010 --> 00:12:57,880
offset Dirac 68 and make a function call

247
00:12:54,130 --> 00:13:01,150
if it's not zero if we can avoid this

248
00:12:57,880 --> 00:13:03,820
function call we and the second red box

249
00:13:01,150 --> 00:13:06,790
you will see a return address it's saved

250
00:13:03,820 --> 00:13:09,310
to the fridge circuit so the

251
00:13:06,790 --> 00:13:14,410
exploitation is kind of straightforward

252
00:13:09,310 --> 00:13:16,930
so we create a number of sockets and for

253
00:13:14,410 --> 00:13:18,259
one of them we don't we don't have to

254
00:13:16,930 --> 00:13:20,719
know which one but

255
00:13:18,259 --> 00:13:24,229
one of them we can explore to the risk

256
00:13:20,720 --> 00:13:26,919
condition unp bite and we can create a

257
00:13:24,229 --> 00:13:29,600
two-way note one of the windows holding

258
00:13:26,919 --> 00:13:31,759
tank bloom counter to the socket and

259
00:13:29,600 --> 00:13:35,660
then we of course we close the socket

260
00:13:31,759 --> 00:13:39,649
the socket is frayed but one of the

261
00:13:35,660 --> 00:13:42,589
windows do has a dangling pointer after

262
00:13:39,649 --> 00:13:45,739
that we closed all the sockets we

263
00:13:42,589 --> 00:13:48,139
created and we trigger the zoom garbage

264
00:13:45,739 --> 00:13:52,069
collection so all the memory will be

265
00:13:48,139 --> 00:13:54,889
reclaimed by the kernel after that we

266
00:13:52,069 --> 00:13:58,759
can spray a lot of control board data

267
00:13:54,889 --> 00:14:01,429
like OS data buffer or pipe buffer

268
00:13:58,759 --> 00:14:04,899
whatever you like so we call them fix

269
00:14:01,429 --> 00:14:08,720
sockets and we make sure that the offset

270
00:14:04,899 --> 00:14:12,439
0 X 1 8 me no fixed sockets pointing to

271
00:14:08,720 --> 00:14:17,269
a fixed or leak people address so how to

272
00:14:12,439 --> 00:14:19,699
get the the people address first in my

273
00:14:17,269 --> 00:14:22,579
opinion people dress leaks are not very

274
00:14:19,699 --> 00:14:25,579
hard on iOS so you Hamill you can use in

275
00:14:22,579 --> 00:14:29,149
public parks or you can just do some

276
00:14:25,579 --> 00:14:31,878
very simple 3 and then occupying or fix

277
00:14:29,149 --> 00:14:34,579
triple address is very very likely so

278
00:14:31,879 --> 00:14:40,569
basically you have many ways to get that

279
00:14:34,579 --> 00:14:45,349
fixed address after that if we make the

280
00:14:40,569 --> 00:14:48,529
venue and offset 0 X 0 X 6 8 in the

281
00:14:45,350 --> 00:14:50,480
fixed fixed hip addresses 0 what would

282
00:14:48,529 --> 00:14:52,609
happen so the following instructions

283
00:14:50,480 --> 00:14:55,789
will be executed in a box so basically

284
00:14:52,609 --> 00:14:59,029
the function return address will be

285
00:14:55,789 --> 00:15:01,909
right - we will be written to the Freid

286
00:14:59,029 --> 00:15:05,239
memory to the to the memory not free

287
00:15:01,909 --> 00:15:09,649
memory sorry and return to the OS data

288
00:15:05,239 --> 00:15:13,730
or pipe buffer we can retrieve such data

289
00:15:09,649 --> 00:15:18,619
back and then here sorry is bypassed so

290
00:15:13,730 --> 00:15:22,309
if we make the venue and offset 0 x 6 8

291
00:15:18,619 --> 00:15:24,529
for the fixed hit buffer the following

292
00:15:22,309 --> 00:15:27,199
instructions in the box will be executed

293
00:15:24,529 --> 00:15:29,899
so basically it's a up to artistic

294
00:15:27,199 --> 00:15:31,640
control so the rest work for jailbreak

295
00:15:29,899 --> 00:15:35,120
is we just chained

296
00:15:31,640 --> 00:15:37,490
our god is love God is so it's easy

297
00:15:35,120 --> 00:15:42,590
because a lot of work already done that

298
00:15:37,490 --> 00:15:46,340
but after we go to the new device that

299
00:15:42,590 --> 00:15:48,830
is iPhone 10 smacks with a tray of chips

300
00:15:46,340 --> 00:15:52,370
which one our exploit we found a dozen

301
00:15:48,830 --> 00:15:55,730
it didn't work to be accurate for the

302
00:15:52,370 --> 00:15:59,210
minimum QC that trigger panic we join it

303
00:15:55,730 --> 00:16:01,610
on the device okay it's again it can

304
00:15:59,210 --> 00:16:05,600
trigger the panic that means the bug was

305
00:16:01,610 --> 00:16:07,730
there and we are just our exploit a

306
00:16:05,600 --> 00:16:11,120
little bit and we got the info leak

307
00:16:07,730 --> 00:16:15,290
first okay I'm resiliency everything

308
00:16:11,120 --> 00:16:17,840
seems okay but when we try to hijack the

309
00:16:15,290 --> 00:16:22,130
culture flow we got some trouble look

310
00:16:17,840 --> 00:16:25,010
this is the the left side is in the

311
00:16:22,130 --> 00:16:27,260
instructions on the old devices that we

312
00:16:25,010 --> 00:16:29,870
are we can hijack the country flow

313
00:16:27,260 --> 00:16:33,350
because the function pointer is fetched

314
00:16:29,870 --> 00:16:35,480
from dangling afraid the memory though

315
00:16:33,350 --> 00:16:38,990
finally there's instruction called a br

316
00:16:35,480 --> 00:16:41,840
rx-8 so if we can control X H we

317
00:16:38,990 --> 00:16:45,500
basically the BR will jump to our target

318
00:16:41,840 --> 00:16:48,800
and we can successfully hijacked the

319
00:16:45,500 --> 00:16:51,890
country flow but for the new devices

320
00:16:48,800 --> 00:16:54,979
that has eight health devices for the

321
00:16:51,890 --> 00:16:57,290
same source code it will generate a new

322
00:16:54,980 --> 00:17:02,030
instruction called a beer Raz

323
00:16:57,290 --> 00:17:05,839
what's that so we can we will trigger a

324
00:17:02,030 --> 00:17:08,270
panic during the PRI anything that says

325
00:17:05,839 --> 00:17:13,190
because a new mechanism called Pak was

326
00:17:08,270 --> 00:17:16,579
introduced in the new iOS device so when

327
00:17:13,190 --> 00:17:20,080
I submit this proposal to blackhat few

328
00:17:16,579 --> 00:17:23,929
work publicly discussed a pack and

329
00:17:20,079 --> 00:17:27,198
discussed is effectiveness but look at

330
00:17:23,930 --> 00:17:29,780
this page now so many excellent research

331
00:17:27,199 --> 00:17:33,050
and disclosure and just a couple hours

332
00:17:29,780 --> 00:17:36,260
ago Apple had a talk in the same room on

333
00:17:33,050 --> 00:17:39,110
the same stage discussed the tax and

334
00:17:36,260 --> 00:17:41,390
rotation so I willing to go much details

335
00:17:39,110 --> 00:17:42,990
here with we will go through some

336
00:17:41,390 --> 00:17:46,860
high-level idea and

337
00:17:42,990 --> 00:17:51,270
say how effective it is so pact was

338
00:17:46,860 --> 00:17:54,510
introduced King way 8.3 is a hardware

339
00:17:51,270 --> 00:17:57,120
based solution for pointer integrity to

340
00:17:54,510 --> 00:17:59,370
me the high-level idea is this Kamin

341
00:17:57,120 --> 00:18:03,330
pointer new minder is a kernel pointer

342
00:17:59,370 --> 00:18:06,479
or a user space pointer if you lookin at

343
00:18:03,330 --> 00:18:09,899
a high base it's either all ones or

344
00:18:06,480 --> 00:18:12,929
zeros this always means is a kernel

345
00:18:09,899 --> 00:18:15,330
pointer all zeros means is is a user

346
00:18:12,929 --> 00:18:18,090
space pointer apparently you don't have

347
00:18:15,330 --> 00:18:20,939
to use so many beasts to indicate a is a

348
00:18:18,090 --> 00:18:24,539
kernel pointer or user space pointer so

349
00:18:20,940 --> 00:18:26,730
how to leverage such a new space to

350
00:18:24,539 --> 00:18:30,270
protect the integrity of a pointer

351
00:18:26,730 --> 00:18:33,630
that's the initial situation of the pack

352
00:18:30,270 --> 00:18:38,490
so give me a pointer I think only the

353
00:18:33,630 --> 00:18:41,520
lower 39 bits could be used to funding

354
00:18:38,490 --> 00:18:46,190
the real physical address the high level

355
00:18:41,520 --> 00:18:47,370
the high 25 bits are kind of unused so

356
00:18:46,190 --> 00:18:50,159
on

357
00:18:47,370 --> 00:18:52,350
ETL device there's a new set of

358
00:18:50,159 --> 00:18:56,850
instructions called pack instructions

359
00:18:52,350 --> 00:19:00,629
which will calculate a secure hash of

360
00:18:56,850 --> 00:19:05,789
the caiman pointer it will calculate a

361
00:19:00,630 --> 00:19:09,240
hash value based according to context or

362
00:19:05,789 --> 00:19:13,710
called modifier and a set of security

363
00:19:09,240 --> 00:19:16,350
keys so what a pack instruction data is

364
00:19:13,710 --> 00:19:19,350
this given point her it will generate

365
00:19:16,350 --> 00:19:23,209
hash code and the third the hash code

366
00:19:19,350 --> 00:19:27,149
into the the pointer mark the high

367
00:19:23,210 --> 00:19:31,380
twenty the high twenty five B's so the

368
00:19:27,149 --> 00:19:33,330
yellow part so for pack the pointer

369
00:19:31,380 --> 00:19:36,299
there is another set of instructions

370
00:19:33,330 --> 00:19:39,330
called audit instructions the auditor

371
00:19:36,299 --> 00:19:42,379
attractions the idea this so we just

372
00:19:39,330 --> 00:19:44,760
recalculate a hash code of the pointer

373
00:19:42,380 --> 00:19:48,240
according to the modifier and as a

374
00:19:44,760 --> 00:19:51,570
secure case and we compare the newly

375
00:19:48,240 --> 00:19:55,860
calculated hash code against the the

376
00:19:51,570 --> 00:19:58,919
hash code inserted in the PAC pointer

377
00:19:55,860 --> 00:20:01,740
if they match that means the pointer is

378
00:19:58,920 --> 00:20:05,340
not corrupted the audit instructions

379
00:20:01,740 --> 00:20:08,010
will produce the original pointer if

380
00:20:05,340 --> 00:20:10,620
there is a mismatch that means the

381
00:20:08,010 --> 00:20:13,679
pointer is kind of thick or corrupted

382
00:20:10,620 --> 00:20:17,040
the audit instructions will generate her

383
00:20:13,679 --> 00:20:19,230
in 1e the pointer it will mask some

384
00:20:17,040 --> 00:20:21,600
peace in the pointer which I record

385
00:20:19,230 --> 00:20:26,190
so the error code will make the whole

386
00:20:21,600 --> 00:20:30,178
pointer humanity so the PR is in

387
00:20:26,190 --> 00:20:33,960
instruction it equals auditor is a and

388
00:20:30,179 --> 00:20:37,080
then B are so what a the data is the

389
00:20:33,960 --> 00:20:39,620
first of audit of the integrity of x8

390
00:20:37,080 --> 00:20:42,840
and then jump to the original address

391
00:20:39,620 --> 00:20:46,199
because we have no idea about the

392
00:20:42,840 --> 00:20:50,189
security case we don't know how to

393
00:20:46,200 --> 00:20:53,790
generate a valid hash code so basically

394
00:20:50,190 --> 00:20:57,270
even we have actually control our x8 we

395
00:20:53,790 --> 00:21:01,950
will trigger a kernel panic for the brr

396
00:20:57,270 --> 00:21:05,809
instruction so we have to reveal the

397
00:21:01,950 --> 00:21:14,700
Dovan ability and see what we can do

398
00:21:05,809 --> 00:21:18,059
okay this is how we trigger the UAF we

399
00:21:14,700 --> 00:21:19,830
trigger the UF by connecting the another

400
00:21:18,059 --> 00:21:21,928
circuit through the different file path

401
00:21:19,830 --> 00:21:26,850
and finally the kernel we would go to

402
00:21:21,929 --> 00:21:30,540
UMP connect and for our original exploit

403
00:21:26,850 --> 00:21:32,610
we mainly focus on socket lock that's

404
00:21:30,540 --> 00:21:37,500
the first use to the dumb balloon

405
00:21:32,610 --> 00:21:40,129
pointer so if we can avoid that we will

406
00:21:37,500 --> 00:21:44,190
get the second the use of the read

407
00:21:40,130 --> 00:21:47,610
socket or a dangling pointer so that the

408
00:21:44,190 --> 00:21:51,600
socket will be passed into function

409
00:21:47,610 --> 00:21:54,030
called sock socket unlock so basically

410
00:21:51,600 --> 00:21:56,668
let's click looking at the second use

411
00:21:54,030 --> 00:22:00,299
socket unlock is very received very

412
00:21:56,669 --> 00:22:02,790
similar to socket lock except the key

413
00:22:00,299 --> 00:22:03,840
slanted as sockets reference counter

414
00:22:02,790 --> 00:22:06,990
turns to zero

415
00:22:03,840 --> 00:22:09,590
yes Sol Kadi is also maintained by

416
00:22:06,990 --> 00:22:13,730
reference counter so what would happen

417
00:22:09,590 --> 00:22:15,139
the reference counter turns to zero we

418
00:22:13,730 --> 00:22:17,750
reviewed a code

419
00:22:15,140 --> 00:22:21,980
finally we find socket unlock will

420
00:22:17,750 --> 00:22:26,020
finally go to key free okay we have a

421
00:22:21,980 --> 00:22:30,350
way to make a treat risk condition into

422
00:22:26,020 --> 00:22:35,110
UAF and based on at UF we got a chance

423
00:22:30,350 --> 00:22:38,959
to make a double free so this is our new

424
00:22:35,110 --> 00:22:42,500
exploitation strategies first again with

425
00:22:38,960 --> 00:22:45,710
the same we create a number of circuits

426
00:22:42,500 --> 00:22:48,799
and the for one of them we explore the

427
00:22:45,710 --> 00:22:51,820
risk condition issue and we create a

428
00:22:48,799 --> 00:22:54,830
dangling pointer in one of the ways nose

429
00:22:51,820 --> 00:22:57,408
after then we close all the sulcus and

430
00:22:54,830 --> 00:23:00,678
and the trigger the resume garbage

431
00:22:57,409 --> 00:23:06,260
collection after then we spray control

432
00:23:00,679 --> 00:23:09,669
data and we call it fixed focus but the

433
00:23:06,260 --> 00:23:13,370
theme thing is we make sure the offset

434
00:23:09,669 --> 00:23:19,039
zero acts 1:8 and in the fixed sock is

435
00:23:13,370 --> 00:23:23,270
point to a fixed hippo address and after

436
00:23:19,039 --> 00:23:27,470
that what we do is we connect another

437
00:23:23,270 --> 00:23:31,789
socket through the file names and what

438
00:23:27,470 --> 00:23:34,520
we can do is if we can control if we

439
00:23:31,789 --> 00:23:38,870
carefully control the reference counter

440
00:23:34,520 --> 00:23:43,549
field in the OS data it will go to key

441
00:23:38,870 --> 00:23:47,149
free so the OS data buffer will be read

442
00:23:43,549 --> 00:23:49,908
by the key free function so the key OSD

443
00:23:47,149 --> 00:23:55,428
the buffer will be freed as if it were a

444
00:23:49,909 --> 00:24:00,039
socket then we spray again but this time

445
00:23:55,429 --> 00:24:03,409
we spray a number of all ool aft of lon

446
00:24:00,039 --> 00:24:06,230
pause descriptors we are mock message

447
00:24:03,409 --> 00:24:09,470
it's also a very typical exploiting

448
00:24:06,230 --> 00:24:14,210
technique by currently do break throughs

449
00:24:09,470 --> 00:24:18,820
and the purpose is we want to occupy the

450
00:24:14,210 --> 00:24:22,970
free to SD buffer with oil post buffer

451
00:24:18,820 --> 00:24:25,419
after that we free all the OS data

452
00:24:22,970 --> 00:24:27,890
and so all the OS databar afraid

453
00:24:25,420 --> 00:24:32,240
wonderful the OS data buffer actually

454
00:24:27,890 --> 00:24:34,730
now is Ohio post buffer so oh well the

455
00:24:32,240 --> 00:24:40,580
old I'll post buffer will be frayed as

456
00:24:34,730 --> 00:24:43,160
if it's all a state buffer after that we

457
00:24:40,580 --> 00:24:46,429
can spray a number of OS that again this

458
00:24:43,160 --> 00:24:49,700
time our purpose purpose is that our new

459
00:24:46,430 --> 00:24:54,440
OS data buffer will occupy the freedo

460
00:24:49,700 --> 00:24:59,300
our post buffer and this time we can

461
00:24:54,440 --> 00:25:01,850
refill the pointer in refill that the

462
00:24:59,300 --> 00:25:06,830
way no in the OSD the buffer pointing to

463
00:25:01,850 --> 00:25:09,080
a fake pot structure so now what we do

464
00:25:06,830 --> 00:25:12,379
now is we just receive all the mock

465
00:25:09,080 --> 00:25:15,980
message and then we will guinness and

466
00:25:12,380 --> 00:25:20,440
write to a thick object to a thick pot

467
00:25:15,980 --> 00:25:24,860
so yes as I said earlier x' is a very

468
00:25:20,440 --> 00:25:28,100
typical exploitation technique now by

469
00:25:24,860 --> 00:25:32,689
building a fictional task object we can

470
00:25:28,100 --> 00:25:36,139
easily get up to a kernel read and write

471
00:25:32,690 --> 00:25:40,160
based on the task of task task 4p0

472
00:25:36,140 --> 00:25:42,980
technique so far so good so since we

473
00:25:40,160 --> 00:25:47,180
already get after after a kernel code

474
00:25:42,980 --> 00:25:53,030
read and write do we need to fight

475
00:25:47,180 --> 00:25:57,980
against pack so in the past if after we

476
00:25:53,030 --> 00:25:58,670
get tasks for p0 we can easily pass the

477
00:25:57,980 --> 00:26:01,040
kernel

478
00:25:58,670 --> 00:26:04,670
no matter the data or some other

479
00:26:01,040 --> 00:26:08,840
sensitive data structures so we can

480
00:26:04,670 --> 00:26:12,590
easily ND we can easily add a new trust

481
00:26:08,840 --> 00:26:14,840
dynamic trust cache so we can bypass the

482
00:26:12,590 --> 00:26:18,649
code signing checks in the user space we

483
00:26:14,840 --> 00:26:23,379
can run up to encode we want but on ETL

484
00:26:18,650 --> 00:26:26,660
devices when we try to add some dynamic

485
00:26:23,380 --> 00:26:30,500
trust cache it will trigger some new

486
00:26:26,660 --> 00:26:32,870
panic is some panic looks like this so

487
00:26:30,500 --> 00:26:36,110
apparently besides pack

488
00:26:32,870 --> 00:26:37,299
Apple has some other medications on a 12

489
00:26:36,110 --> 00:26:40,969
devices

490
00:26:37,299 --> 00:26:46,309
so we analyzed the colonel we find out

491
00:26:40,970 --> 00:26:49,519
some new kernel segments and dead and if

492
00:26:46,309 --> 00:26:54,678
you went to a post talk or taco our

493
00:26:49,519 --> 00:26:59,330
school is called a PR so a lot of a PPR

494
00:26:54,679 --> 00:27:01,250
segments introduced and there is a

495
00:26:59,330 --> 00:27:04,460
segment called the PP our text

496
00:27:01,250 --> 00:27:07,130
it contains a lot of code the code for

497
00:27:04,460 --> 00:27:09,830
Pima related functions code signature is

498
00:27:07,130 --> 00:27:12,440
related functions as well as trust cash

499
00:27:09,830 --> 00:27:16,010
related functions but the question is

500
00:27:12,440 --> 00:27:19,279
the code in this segment is not a

501
00:27:16,010 --> 00:27:24,740
suitable or unless a special register is

502
00:27:19,279 --> 00:27:27,860
set to some special value so the only

503
00:27:24,740 --> 00:27:32,620
entry point to set this special register

504
00:27:27,860 --> 00:27:36,469
is some code in PPR trend segment so

505
00:27:32,620 --> 00:27:41,408
this the code in this segment is used to

506
00:27:36,470 --> 00:27:41,409
dispatch course to function GPIO text

507
00:27:41,529 --> 00:27:48,320
okay let me explain this so based on

508
00:27:45,260 --> 00:27:50,870
task for period Tasker for PID zeroes

509
00:27:48,320 --> 00:27:55,158
right capcity

510
00:27:50,870 --> 00:27:59,389
in the past before iPhone 7 we are able

511
00:27:55,159 --> 00:28:02,179
to write any where for the for kernel

512
00:27:59,389 --> 00:28:05,360
image like including the cold segments

513
00:28:02,179 --> 00:28:08,750
and all the data segments but the scene

514
00:28:05,360 --> 00:28:12,229
so I phone salmon or magnesium code

515
00:28:08,750 --> 00:28:16,309
ggrrr was introduced and you may already

516
00:28:12,230 --> 00:28:19,730
knew that from Apple stock so the code

517
00:28:16,309 --> 00:28:23,389
segment is protected by them the memory

518
00:28:19,730 --> 00:28:27,549
MMU controller so what we can do is we

519
00:28:23,389 --> 00:28:32,620
can only patch the data segments but on

520
00:28:27,549 --> 00:28:35,658
iphone 10s after a PR was introduced

521
00:28:32,620 --> 00:28:39,678
some special data segment called PB

522
00:28:35,659 --> 00:28:44,870
iodate can only be written by the code

523
00:28:39,679 --> 00:28:49,280
inside the PPR text so even we have TR p

524
00:28:44,870 --> 00:28:58,010
0 we can only have limited right

525
00:28:49,280 --> 00:29:01,760
city for some kernel data so - and some

526
00:28:58,010 --> 00:29:06,350
new dynamic trust cash we want code as

527
00:29:01,760 --> 00:29:09,350
corrosion in the kernel so we begin to

528
00:29:06,350 --> 00:29:15,340
look for unprotected a control flow

529
00:29:09,350 --> 00:29:15,340
transfer points and we revealed a lot of

530
00:29:15,700 --> 00:29:21,820
we revealed a lot of points like

531
00:29:18,800 --> 00:29:26,840
indirect function calls context wishes

532
00:29:21,820 --> 00:29:29,990
interrupt handlers and I strongly refer

533
00:29:26,840 --> 00:29:33,889
you to Brandon's work a study impact

534
00:29:29,990 --> 00:29:37,760
which was this published in mistake this

535
00:29:33,890 --> 00:29:43,540
year and he proposed us so many ways to

536
00:29:37,760 --> 00:29:47,720
bypass pack and so for us what we did is

537
00:29:43,540 --> 00:29:50,899
after we review this country flow

538
00:29:47,720 --> 00:29:53,240
transfer points or special function

539
00:29:50,900 --> 00:29:57,020
called the thread exception return jumps

540
00:29:53,240 --> 00:30:00,230
to our eyes where the exception return

541
00:29:57,020 --> 00:30:04,010
is used to return us right from the

542
00:30:00,230 --> 00:30:07,100
kernel to user mode and there's special

543
00:30:04,010 --> 00:30:09,800
instruction code return or exactly

544
00:30:07,100 --> 00:30:13,699
return this instruction is supposed to

545
00:30:09,800 --> 00:30:18,080
transfer Australia which trapped in into

546
00:30:13,700 --> 00:30:21,860
the kernel back to the user mode so when

547
00:30:18,080 --> 00:30:25,550
you return is executed the CPU will

548
00:30:21,860 --> 00:30:30,260
restore peace paid from SP SR and the

549
00:30:25,550 --> 00:30:32,840
branch to the target by yard register if

550
00:30:30,260 --> 00:30:36,410
you look at the binary code you will

551
00:30:32,840 --> 00:30:41,149
find actually the two registers will be

552
00:30:36,410 --> 00:30:44,300
cited by X 0 and X 1 and both are 0 and

553
00:30:41,150 --> 00:30:49,520
X 1 actually they are read from or

554
00:30:44,300 --> 00:30:51,409
kernel memory so if we can control the

555
00:30:49,520 --> 00:30:55,070
two memory loss

556
00:30:51,410 --> 00:30:58,370
we are able to control IVA turn we can

557
00:30:55,070 --> 00:31:01,250
force the Yi returned tom to actually

558
00:30:58,370 --> 00:31:02,040
kernel address in the kernel rather than

559
00:31:01,250 --> 00:31:06,210
back

560
00:31:02,040 --> 00:31:10,139
the user space by the way the same trick

561
00:31:06,210 --> 00:31:15,120
was used by Gambier for his kernel iOS

562
00:31:10,140 --> 00:31:18,600
kernel debugger and but there is a

563
00:31:15,120 --> 00:31:20,729
special function before he returned we

564
00:31:18,600 --> 00:31:24,389
don't know his name but according to the

565
00:31:20,730 --> 00:31:28,230
panic string we named it a GOP detector

566
00:31:24,390 --> 00:31:30,660
what this function does is I think it's

567
00:31:28,230 --> 00:31:33,450
supposed to attack the integrity of the

568
00:31:30,660 --> 00:31:36,270
save destroy the context and the

569
00:31:33,450 --> 00:31:40,640
beginning we thought oh there's no

570
00:31:36,270 --> 00:31:43,730
chance but my friend told me ok

571
00:31:40,640 --> 00:31:46,620
something's wrong here

572
00:31:43,730 --> 00:31:50,730
after compare the newly calculated hash

573
00:31:46,620 --> 00:31:54,260
code against compare it with the one

574
00:31:50,730 --> 00:31:57,390
stored in the context even the

575
00:31:54,260 --> 00:32:00,330
mismatching nothing's wrong after the

576
00:31:57,390 --> 00:32:04,860
compare instruction it just returned so

577
00:32:00,330 --> 00:32:09,600
the early return will award coding the

578
00:32:04,860 --> 00:32:12,330
panic function so what we can do we can

579
00:32:09,600 --> 00:32:16,010
make a stripe MCUs right tramping into

580
00:32:12,330 --> 00:32:18,720
the kernel like we can make us rather

581
00:32:16,010 --> 00:32:22,350
receiving some Mac message so it will

582
00:32:18,720 --> 00:32:26,280
travel into kernel and then based on the

583
00:32:22,350 --> 00:32:30,540
task for PID 0 we are able to change the

584
00:32:26,280 --> 00:32:35,340
silver thread context especially here

585
00:32:30,540 --> 00:32:38,600
are your 1 and SPR yawen and after that

586
00:32:35,340 --> 00:32:41,909
we can seen a message - that's right

587
00:32:38,600 --> 00:32:46,050
after receiving that kernel message

588
00:32:41,910 --> 00:32:49,980
that's right it's supposed to return to

589
00:32:46,050 --> 00:32:53,940
the user space but when ye return

590
00:32:49,980 --> 00:32:57,000
instruction is executed we are we got a

591
00:32:53,940 --> 00:33:00,930
chance to gain after a code execution so

592
00:32:57,000 --> 00:33:03,630
what we do is we can make the u-turn

593
00:33:00,930 --> 00:33:09,290
jumped into a special function that in

594
00:33:03,630 --> 00:33:13,770
tax is 0x20 file in the PPI Oh triumph

595
00:33:09,290 --> 00:33:15,399
which will load trust cash as if the

596
00:33:13,770 --> 00:33:19,629
kernel is loading

597
00:33:15,400 --> 00:33:22,570
trust cash so we are able to end our

598
00:33:19,630 --> 00:33:26,590
trust cash and we got SSS environment

599
00:33:22,570 --> 00:33:31,960
iPhone tears Max and sex for the top PR

600
00:33:26,590 --> 00:33:34,750
environment okay this is a fix the fix

601
00:33:31,960 --> 00:33:39,180
is so easy after the compare you should

602
00:33:34,750 --> 00:33:43,960
dump right you shouldn't just return

603
00:33:39,180 --> 00:33:46,240
okay the conclusion so first for the

604
00:33:43,960 --> 00:33:49,690
back part we believed and the temporary

605
00:33:46,240 --> 00:33:53,200
unlock is becoming a very important back

606
00:33:49,690 --> 00:33:56,679
patent so when we do source code level

607
00:33:53,200 --> 00:33:59,410
or binary level auditing we should pay

608
00:33:56,679 --> 00:34:04,809
more attention on this kind of pattern

609
00:33:59,410 --> 00:34:07,660
and I post new medication pack and ppl

610
00:34:04,809 --> 00:34:10,029
they accurate and the combination of the

611
00:34:07,660 --> 00:34:13,210
two mechanisms made a lot of trouble for

612
00:34:10,030 --> 00:34:16,389
us but I don't think it will end the

613
00:34:13,210 --> 00:34:19,540
memory corruption wall and more

614
00:34:16,389 --> 00:34:21,490
importantly a good design need very good

615
00:34:19,540 --> 00:34:24,129
and a complete implementation and

616
00:34:21,489 --> 00:34:27,370
interval box may need to a total bypass

617
00:34:24,129 --> 00:34:29,839
for the whole design okay thank you I'm

618
00:34:27,370 --> 00:34:39,149
happy to answer your questions

619
00:34:29,840 --> 00:34:39,149
[Applause]

