1
00:00:00,000 --> 00:00:05,100
good morning welcome to breaking

2
00:00:02,280 --> 00:00:08,220
encrypted databases generic attacks and

3
00:00:05,100 --> 00:00:11,010
range queries in lagune GHI with Marie

4
00:00:08,220 --> 00:00:14,040
Sarah Allah showed each a before you

5
00:00:11,010 --> 00:00:16,340
begin a few brief notes stop by the

6
00:00:14,040 --> 00:00:19,080
business hall located in Mandalay Bay

7
00:00:16,340 --> 00:00:22,020
Oceanside and shoreline ballrooms on

8
00:00:19,080 --> 00:00:25,169
level 2 the blackhat arsenal is in the

9
00:00:22,020 --> 00:00:27,869
business hall on level 2 lunch is in

10
00:00:25,170 --> 00:00:30,449
Bayside a B from 1:00 to 2:30

11
00:00:27,869 --> 00:00:33,329
don't forget the merchandise store is on

12
00:00:30,449 --> 00:00:36,480
level 2 and session recordings from s ok

13
00:00:33,329 --> 00:00:38,700
they have a desk on every level thank

14
00:00:36,480 --> 00:00:40,680
you for putting your phone on vibrate it

15
00:00:38,700 --> 00:00:41,910
makes it easier for the rest of us so

16
00:00:40,680 --> 00:00:44,460
ignore the ringing while you wait for

17
00:00:41,910 --> 00:00:46,078
your voicemail to pick it up please use

18
00:00:44,460 --> 00:00:48,480
the microphone and the aisles for any

19
00:00:46,079 --> 00:00:54,510
questions following the talk and with

20
00:00:48,480 --> 00:01:00,809
that let us welcome our speaker thank

21
00:00:54,510 --> 00:01:03,030
you so first a little bit about me

22
00:01:00,809 --> 00:01:04,378
my background is in mathematics and I'm

23
00:01:03,030 --> 00:01:06,360
a researcher in cryptography

24
00:01:04,379 --> 00:01:08,430
I studied math at the University of

25
00:01:06,360 --> 00:01:10,799
Waterloo in Canada then went on to do a

26
00:01:08,430 --> 00:01:12,689
PhD at Royal Holloway in the UK I'm now

27
00:01:10,799 --> 00:01:14,939
working as a security consultant with

28
00:01:12,689 --> 00:01:18,240
NCC group cryptography services in New

29
00:01:14,939 --> 00:01:20,399
York my PhD thesis is about building and

30
00:01:18,240 --> 00:01:22,080
breaking encrypted search schemes for

31
00:01:20,400 --> 00:01:24,150
numeric data and that's what I'm going

32
00:01:22,080 --> 00:01:25,798
to talk to you about today two attacks

33
00:01:24,150 --> 00:01:30,390
on my colleagues and I developed and

34
00:01:25,799 --> 00:01:32,159
analyzed during my PhD studies the

35
00:01:30,390 --> 00:01:34,290
motivation for my research is data

36
00:01:32,159 --> 00:01:37,170
breaches thousands if not millions of

37
00:01:34,290 --> 00:01:39,030
organizations store our sensitive

38
00:01:37,170 --> 00:01:42,180
information whether that's medical

39
00:01:39,030 --> 00:01:43,500
financial or personal here's a selection

40
00:01:42,180 --> 00:01:45,500
of data breaches and the number of

41
00:01:43,500 --> 00:01:48,479
Records compromised from just this year

42
00:01:45,500 --> 00:01:50,369
data breaches have become so common that

43
00:01:48,479 --> 00:01:52,320
there are now services like have I been

44
00:01:50,369 --> 00:01:56,030
poned that will check if your email or

45
00:01:52,320 --> 00:01:58,529
user ID appeared in the latest leak I

46
00:01:56,030 --> 00:02:00,299
like thinking about whether we could use

47
00:01:58,530 --> 00:02:01,890
cryptography to make these leaks less

48
00:02:00,299 --> 00:02:03,659
harmful while keeping whatever

49
00:02:01,890 --> 00:02:05,430
functionality is needed on the stored

50
00:02:03,659 --> 00:02:07,710
data the reasons it was stored in the

51
00:02:05,430 --> 00:02:09,420
first place for example is there a way

52
00:02:07,710 --> 00:02:11,640
to encrypt medical records so that

53
00:02:09,419 --> 00:02:13,049
policymakers can still efficiently query

54
00:02:11,640 --> 00:02:13,798
the data to look for trends and make

55
00:02:13,050 --> 00:02:15,540
this

56
00:02:13,799 --> 00:02:17,459
but someone who runs off with the disk

57
00:02:15,540 --> 00:02:19,798
on which it's stored gets nothing but

58
00:02:17,459 --> 00:02:22,109
useless encrypted data or maybe a

59
00:02:19,799 --> 00:02:23,760
curious data center employee doesn't get

60
00:02:22,109 --> 00:02:26,189
access to the data even though their

61
00:02:23,760 --> 00:02:27,689
sysadmin on the database server I'm

62
00:02:26,189 --> 00:02:29,280
interested in both creating and

63
00:02:27,689 --> 00:02:31,439
attacking these special cryptographic

64
00:02:29,280 --> 00:02:33,390
techniques but of course since this is

65
00:02:31,439 --> 00:02:35,879
blackhat I'll focus on the attacks today

66
00:02:33,390 --> 00:02:38,159
I'll tell you how leakage from encrypted

67
00:02:35,879 --> 00:02:44,399
databases can be exploited by an

68
00:02:38,159 --> 00:02:46,319
adversary I'm going to introduce these

69
00:02:44,400 --> 00:02:47,670
encrypted database attacks by telling

70
00:02:46,319 --> 00:02:49,230
you about them through a lens you might

71
00:02:47,670 --> 00:02:51,988
be more familiar with side-channel

72
00:02:49,230 --> 00:02:54,480
attacks these are attacks that exploit

73
00:02:51,989 --> 00:02:56,400
vulnerabilities in the implementations

74
00:02:54,480 --> 00:02:58,290
of algorithms or protocols not the

75
00:02:56,400 --> 00:03:00,840
designs of the algorithms or protocols

76
00:02:58,290 --> 00:03:03,120
themselves for example if two parties

77
00:03:00,840 --> 00:03:06,389
are communicating a side-channel could

78
00:03:03,120 --> 00:03:08,129
be the voice of their the voice in which

79
00:03:06,389 --> 00:03:11,970
they're talking the identities of the

80
00:03:08,129 --> 00:03:14,790
two parties how long the message is or

81
00:03:11,970 --> 00:03:18,750
the volume of the conversation or when

82
00:03:14,790 --> 00:03:20,760
it happens and of course if these two

83
00:03:18,750 --> 00:03:22,019
parties are machines there are many

84
00:03:20,760 --> 00:03:24,358
other side channels like power

85
00:03:22,019 --> 00:03:27,180
consumption electromagnetic radiation

86
00:03:24,359 --> 00:03:29,729
memory usage CPU usage cache solutions

87
00:03:27,180 --> 00:03:31,109
and so on what's leaked through these

88
00:03:29,729 --> 00:03:33,780
side channels can reveal information

89
00:03:31,109 --> 00:03:35,790
about the actual message contents or if

90
00:03:33,780 --> 00:03:39,930
cryptography is involved something about

91
00:03:35,790 --> 00:03:42,120
the secret key so for example there have

92
00:03:39,930 --> 00:03:44,010
been side channel attacks on keystroke

93
00:03:42,120 --> 00:03:47,459
recovery from timing information in

94
00:03:44,010 --> 00:03:49,590
interactive SSH mode there's been video

95
00:03:47,459 --> 00:03:51,810
stream identification based solely on

96
00:03:49,590 --> 00:03:54,569
traffic burst analysis of an encrypted

97
00:03:51,810 --> 00:03:57,239
video stream and a classic cryptographic

98
00:03:54,569 --> 00:03:58,798
side channel you can use error messages

99
00:03:57,239 --> 00:04:01,379
about whether or not a ciphertext

100
00:03:58,799 --> 00:04:05,430
decrypts to have correct padding or not

101
00:04:01,379 --> 00:04:07,918
to actually decrypt that ciphertext what

102
00:04:05,430 --> 00:04:09,509
we think about as side channel attacks

103
00:04:07,919 --> 00:04:11,849
actually have a lot in common with

104
00:04:09,509 --> 00:04:13,228
attacks on encrypted databases they're

105
00:04:11,849 --> 00:04:15,119
all about exploiting leakage or

106
00:04:13,229 --> 00:04:19,409
unintentional information leaks from

107
00:04:15,120 --> 00:04:21,090
communication between two parties and

108
00:04:19,409 --> 00:04:23,219
encrypt a database attacks the two

109
00:04:21,089 --> 00:04:25,409
parties are at client who queries its

110
00:04:23,219 --> 00:04:27,210
data to retrieve particular records or

111
00:04:25,409 --> 00:04:29,340
rows based on their value

112
00:04:27,210 --> 00:04:35,549
and a database server who's hosting the

113
00:04:29,340 --> 00:04:36,960
data this briefing is about new kinds of

114
00:04:35,550 --> 00:04:38,220
side-channel attacks that can break

115
00:04:36,960 --> 00:04:40,380
database encryption

116
00:04:38,220 --> 00:04:42,419
they exploit leakage from numeric range

117
00:04:40,380 --> 00:04:45,240
queries like which records have values

118
00:04:42,419 --> 00:04:49,770
between 1 and 5 between the client and

119
00:04:45,240 --> 00:04:52,020
database server these attacks exploit

120
00:04:49,770 --> 00:04:54,120
what we call access pattern leakage or

121
00:04:52,020 --> 00:04:56,400
which rows in the database match the

122
00:04:54,120 --> 00:05:00,060
query and volume leakage which is how

123
00:04:56,400 --> 00:05:01,198
many rows match the query the attacks

124
00:05:00,060 --> 00:05:03,000
use this leakage to break encryption

125
00:05:01,199 --> 00:05:05,310
even if everything in the database is

126
00:05:03,000 --> 00:05:07,080
encrypted an adversary can figure out if

127
00:05:05,310 --> 00:05:09,650
the plaintext can figure out the

128
00:05:07,080 --> 00:05:11,609
plaintext if these side channels exist

129
00:05:09,650 --> 00:05:13,440
so I'll start with an overview of

130
00:05:11,610 --> 00:05:15,030
existing approaches to securing out

131
00:05:13,440 --> 00:05:16,710
source databases that allow range

132
00:05:15,030 --> 00:05:18,539
queries these will cover different

133
00:05:16,710 --> 00:05:21,330
scenarios like trusting the database

134
00:05:18,539 --> 00:05:22,830
server but not the network or trusting

135
00:05:21,330 --> 00:05:25,020
the database server but being worried

136
00:05:22,830 --> 00:05:29,609
about the risk of disk threat disk theft

137
00:05:25,020 --> 00:05:31,080
or not trusting the database server then

138
00:05:29,610 --> 00:05:33,270
we'll get to the attacks I'll explain

139
00:05:31,080 --> 00:05:35,210
how exploiting this leakage can lead to

140
00:05:33,270 --> 00:05:37,198
breaking encryption in the databases

141
00:05:35,210 --> 00:05:38,729
finally I'll share what I think are

142
00:05:37,199 --> 00:05:41,039
important points for practitioners to

143
00:05:38,729 --> 00:05:47,490
consider when evaluating such schemes

144
00:05:41,039 --> 00:05:49,349
for their organizations here again is

145
00:05:47,490 --> 00:05:51,300
our basic architecture we have a client

146
00:05:49,349 --> 00:05:55,500
on the left and a database server on the

147
00:05:51,300 --> 00:05:57,180
right the server storing a database

148
00:05:55,500 --> 00:05:59,849
which you can picture as just a table

149
00:05:57,180 --> 00:06:02,010
with two columns the first column is the

150
00:05:59,849 --> 00:06:04,289
primary key which is unique for all rows

151
00:06:02,010 --> 00:06:06,870
here we just assume it's sequential for

152
00:06:04,289 --> 00:06:09,599
simplicity the second column is the

153
00:06:06,870 --> 00:06:11,280
value a number between 1 and n which is

154
00:06:09,599 --> 00:06:13,949
the attribute that the client is going

155
00:06:11,280 --> 00:06:15,840
to select rows on for example in a

156
00:06:13,949 --> 00:06:17,789
medical database ID could be some kind

157
00:06:15,840 --> 00:06:19,948
of anonymized patient identifier and

158
00:06:17,789 --> 00:06:21,960
value could be the patient's age for

159
00:06:19,949 --> 00:06:23,849
instance the table could have more

160
00:06:21,960 --> 00:06:26,219
columns but for this setting we assume

161
00:06:23,849 --> 00:06:31,199
the client always queries records based

162
00:06:26,220 --> 00:06:33,389
on just this one and the type of queries

163
00:06:31,199 --> 00:06:35,550
the client makes is range queries it

164
00:06:33,389 --> 00:06:37,139
always retrieves records based on

165
00:06:35,550 --> 00:06:39,479
whether their value falls in some

166
00:06:37,139 --> 00:06:41,180
continuous numeric range like 1 through

167
00:06:39,479 --> 00:06:43,460
5

168
00:06:41,180 --> 00:06:45,230
if you're familiar with sequel this

169
00:06:43,460 --> 00:06:48,109
would be a query of the form select star

170
00:06:45,230 --> 00:06:51,590
from table where value between x and y

171
00:06:48,110 --> 00:06:53,510
the two end points of the range but the

172
00:06:51,590 --> 00:06:55,549
particular query language or database

173
00:06:53,510 --> 00:06:57,710
engine isn't important as long as two

174
00:06:55,550 --> 00:06:59,960
things hold first the client always

175
00:06:57,710 --> 00:07:01,729
makes range queries over some finite set

176
00:06:59,960 --> 00:07:04,310
of values which we can assume is the

177
00:07:01,730 --> 00:07:06,500
integers from 1 to N and second that the

178
00:07:04,310 --> 00:07:09,440
database server always correctly returns

179
00:07:06,500 --> 00:07:15,140
the IDS of rows whose values fall in

180
00:07:09,440 --> 00:07:16,300
that range securing data is all about

181
00:07:15,140 --> 00:07:18,710
understanding the threat model

182
00:07:16,300 --> 00:07:20,750
historically protecting queries and

183
00:07:18,710 --> 00:07:24,080
results from a network eavesdropper was

184
00:07:20,750 --> 00:07:25,370
the first step the client and server can

185
00:07:24,080 --> 00:07:27,320
protect their communications by

186
00:07:25,370 --> 00:07:29,300
encrypting them we know how to do this

187
00:07:27,320 --> 00:07:30,830
we have TLS the client and server can

188
00:07:29,300 --> 00:07:33,260
use that for authentication and

189
00:07:30,830 --> 00:07:35,510
negotiating a session key to encrypt the

190
00:07:33,260 --> 00:07:37,340
queries and responses so anyone who sees

191
00:07:35,510 --> 00:07:38,930
the packets doesn't know what the query

192
00:07:37,340 --> 00:07:39,880
was or which records in the database

193
00:07:38,930 --> 00:07:42,740
matched it

194
00:07:39,880 --> 00:07:44,480
but of course encrypting data on the

195
00:07:42,740 --> 00:07:47,090
wire doesn't protect against everything

196
00:07:44,480 --> 00:07:49,460
as people began to outsource their data

197
00:07:47,090 --> 00:07:50,989
to the cloud or Big Data Centers they

198
00:07:49,460 --> 00:07:52,820
had to update their threat models to

199
00:07:50,990 --> 00:07:55,010
account for the risk of disks theft

200
00:07:52,820 --> 00:07:59,960
which as we saw before actually still

201
00:07:55,010 --> 00:08:01,460
happens in real world encryption at the

202
00:07:59,960 --> 00:08:04,039
file system level or column level

203
00:08:01,460 --> 00:08:05,780
addresses this issue suppose the client

204
00:08:04,040 --> 00:08:08,270
wants to query its data usually the

205
00:08:05,780 --> 00:08:09,830
process goes like this it uses TLS to

206
00:08:08,270 --> 00:08:12,530
encrypt its query and sends it to the

207
00:08:09,830 --> 00:08:14,270
server the server decrypt it consults

208
00:08:12,530 --> 00:08:16,609
its search index and fetches the

209
00:08:14,270 --> 00:08:18,770
relevant encrypted pages from disk it

210
00:08:16,610 --> 00:08:20,540
decrypts them in memory processes the

211
00:08:18,770 --> 00:08:23,150
results re-encrypt them and sends them

212
00:08:20,540 --> 00:08:25,760
back to the client whatever is on disk

213
00:08:23,150 --> 00:08:27,409
stays encrypted the entire time so even

214
00:08:25,760 --> 00:08:27,950
if someone breaks in and grabs the hard

215
00:08:27,410 --> 00:08:32,300
drive

216
00:08:27,950 --> 00:08:33,980
they won't see unencrypted data pretty

217
00:08:32,299 --> 00:08:35,719
much all major database vendors offer

218
00:08:33,980 --> 00:08:37,880
some variant of this usually called

219
00:08:35,720 --> 00:08:40,070
transparent data encryption or native

220
00:08:37,880 --> 00:08:41,419
encryption these solutions usually don't

221
00:08:40,070 --> 00:08:43,790
have any noticeable effect on

222
00:08:41,419 --> 00:08:45,770
performance the server can still index

223
00:08:43,789 --> 00:08:47,900
the plaintext data so range queries can

224
00:08:45,770 --> 00:08:50,060
be answered efficiently some of these

225
00:08:47,900 --> 00:08:51,770
solutions also offer more granular field

226
00:08:50,060 --> 00:08:54,319
level encryption like format preserving

227
00:08:51,770 --> 00:08:54,829
encryption or tokenization but the data

228
00:08:54,320 --> 00:08:56,900
encryption

229
00:08:54,830 --> 00:08:58,760
he is usually still managed by the

230
00:08:56,900 --> 00:09:01,160
server in a key store attached to the

231
00:08:58,760 --> 00:09:05,330
server hopefully not on the same disk as

232
00:09:01,160 --> 00:09:07,189
the data itself but even if the data

233
00:09:05,330 --> 00:09:09,410
encryption key isn't stored on the same

234
00:09:07,190 --> 00:09:11,600
disk as the data it's often accessible

235
00:09:09,410 --> 00:09:13,219
to curious database administrators sis

236
00:09:11,600 --> 00:09:15,590
admin's or anyone who gained such

237
00:09:13,220 --> 00:09:17,630
permissions to prevent a full database

238
00:09:15,590 --> 00:09:19,820
server system compromise from revealing

239
00:09:17,630 --> 00:09:22,100
this stored data it needs to be

240
00:09:19,820 --> 00:09:25,750
encrypted by the client itself or via

241
00:09:22,100 --> 00:09:27,860
proxy before it even gets to the server

242
00:09:25,750 --> 00:09:29,270
but if the data stays encrypted the

243
00:09:27,860 --> 00:09:32,030
whole time how can it possibly be

244
00:09:29,270 --> 00:09:34,100
queried to me this is the problem with

245
00:09:32,030 --> 00:09:35,510
the most interesting solutions not only

246
00:09:34,100 --> 00:09:37,850
because they ensure the database doesn't

247
00:09:35,510 --> 00:09:39,170
see raw unencrypted data but because

248
00:09:37,850 --> 00:09:40,730
there are some really cool techniques

249
00:09:39,170 --> 00:09:43,339
that allow efficiently retrieving that

250
00:09:40,730 --> 00:09:45,590
data in industry these solutions are

251
00:09:43,340 --> 00:09:47,840
usually called client-side field level

252
00:09:45,590 --> 00:09:49,220
encryption instead of being in a key

253
00:09:47,840 --> 00:09:51,350
store attached to the database server

254
00:09:49,220 --> 00:09:55,820
the data encryption keys are entirely

255
00:09:51,350 --> 00:09:57,290
controlled by the client such solutions

256
00:09:55,820 --> 00:09:59,060
are offered for instance by Microsoft

257
00:09:57,290 --> 00:10:00,980
and they're always encrypted products

258
00:09:59,060 --> 00:10:03,020
which offers field level encryption in

259
00:10:00,980 --> 00:10:05,090
client-side drivers or MongoDB is

260
00:10:03,020 --> 00:10:06,829
upcoming for point to release also

261
00:10:05,090 --> 00:10:11,570
companies like cipher cloud offer

262
00:10:06,830 --> 00:10:13,760
encryption proxies usually these

263
00:10:11,570 --> 00:10:15,370
client-side encryption solutions offer

264
00:10:13,760 --> 00:10:18,260
only two types of encryption

265
00:10:15,370 --> 00:10:20,030
deterministic and randomized let's take

266
00:10:18,260 --> 00:10:21,740
a closer look at these two types and

267
00:10:20,030 --> 00:10:24,110
then a third type called order

268
00:10:21,740 --> 00:10:26,180
preserving encryption as we'll see one

269
00:10:24,110 --> 00:10:28,550
of these leaks repetition in the plain

270
00:10:26,180 --> 00:10:31,160
texts and makes range queries possible

271
00:10:28,550 --> 00:10:33,020
but inefficient one of them is secure

272
00:10:31,160 --> 00:10:35,900
but doesn't support range queries at all

273
00:10:33,020 --> 00:10:40,329
and one leaks order but makes range

274
00:10:35,900 --> 00:10:42,590
queries as efficient as on plain text so

275
00:10:40,330 --> 00:10:45,170
deterministic encryption is probably the

276
00:10:42,590 --> 00:10:47,120
most widely used way to support queries

277
00:10:45,170 --> 00:10:49,640
on encrypted data since it leaks

278
00:10:47,120 --> 00:10:51,440
equality but it doesn't offer much more

279
00:10:49,640 --> 00:10:53,660
functionality than that only exact

280
00:10:51,440 --> 00:10:56,630
matches with deterministic encryption

281
00:10:53,660 --> 00:10:58,880
any repeated plaintext values show up as

282
00:10:56,630 --> 00:11:01,280
repeated ciphertext values in this

283
00:10:58,880 --> 00:11:04,900
example each row that had a value of 0

284
00:11:01,280 --> 00:11:07,130
will have the exact same ciphertext

285
00:11:04,900 --> 00:11:08,889
this makes range queries possible

286
00:11:07,130 --> 00:11:11,019
instead of requesting all rep

287
00:11:08,889 --> 00:11:12,970
with values between zero and three the

288
00:11:11,019 --> 00:11:14,859
client can request all records whose

289
00:11:12,970 --> 00:11:16,859
values are in the set of encryptions of

290
00:11:14,859 --> 00:11:19,329
zero or one or two or three

291
00:11:16,859 --> 00:11:21,279
although range queries are possible the

292
00:11:19,329 --> 00:11:23,019
fact remains that any repetitions in the

293
00:11:21,279 --> 00:11:25,720
plaintext will show up in the ciphertext

294
00:11:23,019 --> 00:11:27,609
and this can be exploited when combined

295
00:11:25,720 --> 00:11:29,350
with just a little information about

296
00:11:27,609 --> 00:11:31,959
what the distribution of values actually

297
00:11:29,350 --> 00:11:34,059
is these attacks were evaluated on

298
00:11:31,959 --> 00:11:39,969
medical data sets by Naveed Perot and

299
00:11:34,059 --> 00:11:41,709
Wright and many others after with

300
00:11:39,970 --> 00:11:44,290
randomized encryption the server can't

301
00:11:41,709 --> 00:11:45,939
index the data or group values using

302
00:11:44,290 --> 00:11:48,129
randomized encryption would make all

303
00:11:45,939 --> 00:11:49,719
encryptions of zero different but then

304
00:11:48,129 --> 00:11:54,459
the server would have no way to select

305
00:11:49,720 --> 00:11:56,169
all of the records with value 0 order

306
00:11:54,459 --> 00:11:58,089
preserving encryption is another method

307
00:11:56,169 --> 00:12:00,040
of encrypting numeric data which does

308
00:11:58,089 --> 00:12:02,139
exactly what it sounds like if the

309
00:12:00,040 --> 00:12:03,998
plaintext a is less than the plaintext B

310
00:12:02,139 --> 00:12:06,220
then the ciphertext for a will be less

311
00:12:03,999 --> 00:12:08,079
than the ciphertext for B this allows

312
00:12:06,220 --> 00:12:11,439
range queries and sorting over the

313
00:12:08,079 --> 00:12:13,868
cipher texts if the client encrypts

314
00:12:11,439 --> 00:12:16,149
values with ope before sending them to

315
00:12:13,869 --> 00:12:18,449
the server the server can still index

316
00:12:16,149 --> 00:12:20,559
the data just as if it was clear text

317
00:12:18,449 --> 00:12:23,319
unencrypted but it doesn't learn the

318
00:12:20,559 --> 00:12:25,238
exact values when the client wants to

319
00:12:23,319 --> 00:12:27,248
perform a range query all it has to do

320
00:12:25,239 --> 00:12:29,619
is encrypt the endpoints of that range

321
00:12:27,249 --> 00:12:31,569
so for example a query for records with

322
00:12:29,619 --> 00:12:33,579
values between 0 and 15 would become a

323
00:12:31,569 --> 00:12:39,819
range query for cipher text between say

324
00:12:33,579 --> 00:12:41,859
84 and 23:07 unfortunately it was proven

325
00:12:39,819 --> 00:12:43,599
that even an ideal order preserving

326
00:12:41,860 --> 00:12:46,209
encryption scheme the one that behaves

327
00:12:43,600 --> 00:12:48,669
like any old random order preserving

328
00:12:46,209 --> 00:12:51,279
function has to leak a lot more than

329
00:12:48,669 --> 00:12:53,739
just the order of to plain texts in

330
00:12:51,279 --> 00:12:56,709
particular about half of the plaintext

331
00:12:53,739 --> 00:12:57,579
bits leaked and therefore this doesn't

332
00:12:56,709 --> 00:12:59,439
offer much security

333
00:12:57,579 --> 00:13:01,299
especially when the scheme is

334
00:12:59,439 --> 00:13:04,389
deterministic and additionally leaks

335
00:13:01,299 --> 00:13:06,399
which values are repeated this motivated

336
00:13:04,389 --> 00:13:09,220
new schemes that sacrifice a little bit

337
00:13:06,399 --> 00:13:13,839
less security while still allowing range

338
00:13:09,220 --> 00:13:15,309
queries and sorting these include

339
00:13:13,839 --> 00:13:16,629
techniques like order revealing

340
00:13:15,309 --> 00:13:18,160
encryption which is just a

341
00:13:16,629 --> 00:13:20,259
generalization of order preserving

342
00:13:18,160 --> 00:13:22,120
encryption instead of directly looking

343
00:13:20,259 --> 00:13:23,740
at the cipher text to compare them you

344
00:13:22,120 --> 00:13:25,720
need to compute a function over each

345
00:13:23,740 --> 00:13:27,940
pair of cipher texts to know which one

346
00:13:25,720 --> 00:13:29,350
is smaller and there are other schemes

347
00:13:27,940 --> 00:13:31,690
that do more complicated things like

348
00:13:29,350 --> 00:13:33,790
build search index that the server can

349
00:13:31,690 --> 00:13:36,370
traverse itself destroying nodes along

350
00:13:33,790 --> 00:13:38,920
the way as it goes these schemes leak a

351
00:13:36,370 --> 00:13:43,930
lot less than ope but they still leak

352
00:13:38,920 --> 00:13:45,400
something now suppose you combine all of

353
00:13:43,930 --> 00:13:47,020
these types of encryption you encrypt

354
00:13:45,400 --> 00:13:49,660
the queries and responses between the

355
00:13:47,020 --> 00:13:51,640
client and server you encrypt data at

356
00:13:49,660 --> 00:13:53,350
the page level and you have the client

357
00:13:51,640 --> 00:13:54,220
encrypt everything before even sending

358
00:13:53,350 --> 00:13:56,650
it to the server

359
00:13:54,220 --> 00:14:01,420
what could still leak to the adversary

360
00:13:56,650 --> 00:14:03,579
via side channels well the server needs

361
00:14:01,420 --> 00:14:06,310
to know which records match the query in

362
00:14:03,580 --> 00:14:08,410
order to return the correct results so

363
00:14:06,310 --> 00:14:11,890
the identifier of the records that match

364
00:14:08,410 --> 00:14:15,730
the query in other words the access

365
00:14:11,890 --> 00:14:17,220
pattern can leech seconds even though

366
00:14:15,730 --> 00:14:20,410
the client surfer traffic is encrypted

367
00:14:17,220 --> 00:14:22,000
there's no hiding its length so the

368
00:14:20,410 --> 00:14:24,490
number of records that matched each

369
00:14:22,000 --> 00:14:30,279
query can also leave we call this volume

370
00:14:24,490 --> 00:14:33,640
leakage the key point is that regardless

371
00:14:30,279 --> 00:14:35,070
of which fancy encryption or combination

372
00:14:33,640 --> 00:14:37,750
of types of encryption is used

373
00:14:35,070 --> 00:14:39,730
practically all schemes leak which

374
00:14:37,750 --> 00:14:42,610
records match the query or how many

375
00:14:39,730 --> 00:14:44,560
records matched it how exactly this

376
00:14:42,610 --> 00:14:46,870
leaks can vary it could be from some one

377
00:14:44,560 --> 00:14:48,670
man in the middling the responses from

378
00:14:46,870 --> 00:14:50,709
the database to the client it could be

379
00:14:48,670 --> 00:14:53,349
getting access to logs for undos and

380
00:14:50,709 --> 00:14:55,390
redos or query profiling on the server

381
00:14:53,350 --> 00:14:59,529
or it could be from an adversary just

382
00:14:55,390 --> 00:15:01,569
observing traffic volume for an in-depth

383
00:14:59,529 --> 00:15:03,550
look at where such leakage can arise in

384
00:15:01,570 --> 00:15:05,230
the exam in the case of a my sequel

385
00:15:03,550 --> 00:15:06,790
server I recommend my colleagues paper

386
00:15:05,230 --> 00:15:09,700
why your encrypted database is not

387
00:15:06,790 --> 00:15:13,089
secure it's an important question to

388
00:15:09,700 --> 00:15:14,770
extract this leakage and exactly how to

389
00:15:13,089 --> 00:15:17,140
do it but it's orthogonal to what I'll

390
00:15:14,770 --> 00:15:21,100
present today I'm gonna focus on what we

391
00:15:17,140 --> 00:15:23,319
can learn once we have this leakage in

392
00:15:21,100 --> 00:15:25,750
this first part we saw various ways to

393
00:15:23,320 --> 00:15:27,250
secure a database encrypting the

394
00:15:25,750 --> 00:15:29,280
connections between the client and

395
00:15:27,250 --> 00:15:31,630
server protects against eavesdroppers

396
00:15:29,280 --> 00:15:34,360
server-side file system level encryption

397
00:15:31,630 --> 00:15:35,769
mitigates disks EFT and client-side

398
00:15:34,360 --> 00:15:39,519
encryption of data can

399
00:15:35,769 --> 00:15:49,360
data entirely inaccessible even to the

400
00:15:39,519 --> 00:15:51,249
database admin but even when all of

401
00:15:49,360 --> 00:15:55,029
these protections are used some

402
00:15:51,249 --> 00:15:57,009
information still leaks now we come to

403
00:15:55,029 --> 00:16:01,689
attacks on leakage from range queries on

404
00:15:57,009 --> 00:16:03,339
an encrypted database as you recall

405
00:16:01,689 --> 00:16:05,230
here's the model the client makes a

406
00:16:03,339 --> 00:16:07,839
range query whose endpoints are hidden

407
00:16:05,230 --> 00:16:09,429
sends it to the server the server finds

408
00:16:07,839 --> 00:16:12,399
the matching rows and then sends back

409
00:16:09,429 --> 00:16:14,860
the matching row IDs to the client

410
00:16:12,399 --> 00:16:17,529
somehow some way the adversary learns

411
00:16:14,860 --> 00:16:20,920
what those row IDs are it learns which

412
00:16:17,529 --> 00:16:24,809
records match the query so what can it

413
00:16:20,920 --> 00:16:24,809
do s-- about values in the database

414
00:16:25,079 --> 00:16:28,809
range queries have some pretty important

415
00:16:27,339 --> 00:16:32,069
properties let's look at an example

416
00:16:28,809 --> 00:16:34,360
consider this database with ten records

417
00:16:32,069 --> 00:16:40,509
suppose the first range query matches

418
00:16:34,360 --> 00:16:41,980
records two three five and ten and then

419
00:16:40,509 --> 00:16:45,220
there's a second range query and the

420
00:16:41,980 --> 00:16:47,439
adversary learns it matched rows 1 2 4 5

421
00:16:45,220 --> 00:16:49,809
& 8 the adversary has actually already

422
00:16:47,439 --> 00:16:52,629
learned something range queries are

423
00:16:49,809 --> 00:16:54,699
continuous intervals since records 2 & 5

424
00:16:52,629 --> 00:16:56,499
were matched by both queries their

425
00:16:54,699 --> 00:16:59,410
values must be between the values of

426
00:16:56,499 --> 00:17:02,769
records 3 & 10 on one side and 1 4 & 8

427
00:16:59,410 --> 00:17:04,809
on the other side let's take a closer

428
00:17:02,769 --> 00:17:07,510
look the adversary knows there are 10

429
00:17:04,809 --> 00:17:09,398
records after observing two queries it

430
00:17:07,510 --> 00:17:11,230
can split the records into four sets

431
00:17:09,398 --> 00:17:15,158
based on whether they matched either

432
00:17:11,230 --> 00:17:17,289
query 1 or 2 or both or neither since

433
00:17:15,159 --> 00:17:19,120
each query has a corresponding range of

434
00:17:17,289 --> 00:17:21,549
values and the intersection of two

435
00:17:19,119 --> 00:17:24,010
ranges is also a continuous range we can

436
00:17:21,549 --> 00:17:26,770
actually order 3 of the sets of records

437
00:17:24,010 --> 00:17:29,080
like this the adversary can deduce that

438
00:17:26,770 --> 00:17:31,570
records 3 & 10 have values less than

439
00:17:29,080 --> 00:17:34,210
records 2 & 5 which have values less

440
00:17:31,570 --> 00:17:38,639
than records 1 4 & 8 it hasn't learned

441
00:17:34,210 --> 00:17:41,110
anything about records 6 9 6 7 & 9 yet

442
00:17:38,639 --> 00:17:42,969
one way to use this is for example

443
00:17:41,110 --> 00:17:44,889
suppose the adversary happens to learn

444
00:17:42,970 --> 00:17:46,600
through some other side channel the

445
00:17:44,889 --> 00:17:47,799
value of record - then

446
00:17:46,600 --> 00:17:51,340
and learned some bits of information

447
00:17:47,799 --> 00:17:53,918
about the values of Records 1 3 4 8 and

448
00:17:51,340 --> 00:17:56,049
10 as the adversary observes more

449
00:17:53,919 --> 00:17:57,880
queries they can keep performing these

450
00:17:56,049 --> 00:18:00,340
set intersections to group together the

451
00:17:57,880 --> 00:18:03,220
records and sort them by value but

452
00:18:00,340 --> 00:18:05,110
there's an easier way there's already a

453
00:18:03,220 --> 00:18:07,000
data structure we can use to encode the

454
00:18:05,110 --> 00:18:09,070
information in Access pattern leakage

455
00:18:07,000 --> 00:18:11,679
it's called a PQ tree and it was

456
00:18:09,070 --> 00:18:13,870
discovered nearly 45 years ago the idea

457
00:18:11,679 --> 00:18:15,789
of using a PQ tree to order records in a

458
00:18:13,870 --> 00:18:17,889
database isn't new but it was never used

459
00:18:15,789 --> 00:18:21,400
to actually reconstruct the values like

460
00:18:17,890 --> 00:18:24,970
we're doing a PQ tree has two types of

461
00:18:21,400 --> 00:18:28,030
notes P nodes and Q notes its purpose is

462
00:18:24,970 --> 00:18:33,159
to encode a set of orderings on some

463
00:18:28,030 --> 00:18:35,918
base set here 1 2 & 3 the children of P

464
00:18:33,159 --> 00:18:38,350
nodes can be reordered in any way for

465
00:18:35,919 --> 00:18:41,020
example if a P node has 3 children than

466
00:18:38,350 --> 00:18:45,158
there are 3 factorial or 6 possible

467
00:18:41,020 --> 00:18:47,168
orderings of its children the children

468
00:18:45,159 --> 00:18:49,390
of a Q node on the other hand can only

469
00:18:47,169 --> 00:18:52,450
be reflected there are only two possible

470
00:18:49,390 --> 00:18:54,669
orderings of its children we're going to

471
00:18:52,450 --> 00:18:56,620
use PQ trees to keep track of what are

472
00:18:54,669 --> 00:18:59,620
the possible orderings of the records

473
00:18:56,620 --> 00:19:01,689
based on the access pattern linkage once

474
00:18:59,620 --> 00:19:03,820
we have them in as many groups as there

475
00:19:01,690 --> 00:19:06,220
are possible values we'll have worked

476
00:19:03,820 --> 00:19:12,010
out the exact value of every row in the

477
00:19:06,220 --> 00:19:14,230
database going back to the example with

478
00:19:12,010 --> 00:19:16,809
10 records we'd start with a single P

479
00:19:14,230 --> 00:19:18,460
node with 10 children all orderings are

480
00:19:16,809 --> 00:19:22,059
possible since we haven't observed any

481
00:19:18,460 --> 00:19:24,190
access pattern linkage after seeing the

482
00:19:22,059 --> 00:19:26,649
first query we essentially need to

483
00:19:24,190 --> 00:19:28,179
rearrange the items in the PQ tree so

484
00:19:26,650 --> 00:19:31,990
that the records that matched it are

485
00:19:28,179 --> 00:19:34,299
next to each other so the tree gets a

486
00:19:31,990 --> 00:19:39,700
new child P node with the four records

487
00:19:34,299 --> 00:19:41,470
that matched as its children after the

488
00:19:39,700 --> 00:19:44,020
second query we again need to rearrange

489
00:19:41,470 --> 00:19:47,679
the leaves so that the ones matching the

490
00:19:44,020 --> 00:19:49,840
query are next to each other now things

491
00:19:47,679 --> 00:19:53,110
go get more interesting a Q node appears

492
00:19:49,840 --> 00:19:54,699
it has three children one for one for

493
00:19:53,110 --> 00:19:57,250
each group of records that match only

494
00:19:54,700 --> 00:19:58,900
the first query one for the group of

495
00:19:57,250 --> 00:20:00,160
records that matched both the first and

496
00:19:58,900 --> 00:20:01,690
second query and

497
00:20:00,160 --> 00:20:03,730
one for those that matched only the

498
00:20:01,690 --> 00:20:05,500
second query the three records that

499
00:20:03,730 --> 00:20:09,460
haven't matched any queries our children

500
00:20:05,500 --> 00:20:12,160
of the root P node as we see more

501
00:20:09,460 --> 00:20:14,320
queries we can keep reducing the number

502
00:20:12,160 --> 00:20:17,560
of orderings in the PQ tree using the

503
00:20:14,320 --> 00:20:19,419
access pattern leakage the procedure

504
00:20:17,560 --> 00:20:21,250
procedure to do this is a bit tedious

505
00:20:19,420 --> 00:20:24,670
with lots of cases so I won't present

506
00:20:21,250 --> 00:20:26,470
the details what's happening again is

507
00:20:24,670 --> 00:20:28,540
that we need to rearrange the nodes of

508
00:20:26,470 --> 00:20:32,260
the PQ tree so that whatever leaves

509
00:20:28,540 --> 00:20:35,560
matched are continuous and all of the

510
00:20:32,260 --> 00:20:39,670
orderings encoded in this tree they're

511
00:20:35,560 --> 00:20:41,740
next to each other after a while with

512
00:20:39,670 --> 00:20:44,550
enough different queries we end up with

513
00:20:41,740 --> 00:20:47,020
a PQ tree that has a Q node at the root

514
00:20:44,550 --> 00:20:48,820
what this means is that we figured out

515
00:20:47,020 --> 00:20:50,980
the order of all the records from

516
00:20:48,820 --> 00:20:53,740
smallest to largest or largest to

517
00:20:50,980 --> 00:20:56,020
smallest the Q nodes children are groups

518
00:20:53,740 --> 00:20:57,430
of records with the same value if two

519
00:20:56,020 --> 00:20:59,139
records have the same value then they

520
00:20:57,430 --> 00:21:00,880
have to match exactly the same set of

521
00:20:59,140 --> 00:21:02,500
queries there can't be a range query

522
00:21:00,880 --> 00:21:05,440
that matches one of these records but

523
00:21:02,500 --> 00:21:06,940
not the other and now we actually have

524
00:21:05,440 --> 00:21:10,450
enough information to determine the

525
00:21:06,940 --> 00:21:12,760
value of every record the first group is

526
00:21:10,450 --> 00:21:17,080
record with value 1 the second group is

527
00:21:12,760 --> 00:21:19,090
records with value 2 and so on the

528
00:21:17,080 --> 00:21:22,300
adversary can completely reconstruct all

529
00:21:19,090 --> 00:21:23,830
values in the database now you might be

530
00:21:22,300 --> 00:21:26,320
wondering how many queries does the

531
00:21:23,830 --> 00:21:29,409
adversary need to see to get the leakage

532
00:21:26,320 --> 00:21:31,179
of to get this far clearly if it sees

533
00:21:29,410 --> 00:21:32,710
likud from only one query repeated over

534
00:21:31,180 --> 00:21:35,230
and over and over again the attack isn't

535
00:21:32,710 --> 00:21:37,870
gonna succeed to analyze how many

536
00:21:35,230 --> 00:21:40,450
queries are necessary we need to assume

537
00:21:37,870 --> 00:21:43,090
that the queries the adversary sees are

538
00:21:40,450 --> 00:21:45,430
sampled from some fixed distribution say

539
00:21:43,090 --> 00:21:48,850
the uniform distribution every range is

540
00:21:45,430 --> 00:21:50,560
just as likely as every other range then

541
00:21:48,850 --> 00:21:52,480
we can apply some powerful results from

542
00:21:50,560 --> 00:21:54,490
statistical learning theory to say that

543
00:21:52,480 --> 00:21:57,270
with high probability after some number

544
00:21:54,490 --> 00:22:00,370
of queries the attack will succeed

545
00:21:57,270 --> 00:22:02,440
specifically if the rows if the values

546
00:22:00,370 --> 00:22:04,959
in each rows can have one of n possible

547
00:22:02,440 --> 00:22:07,420
values in other words if our goal is to

548
00:22:04,960 --> 00:22:09,610
get a PQ tree consisting of one Q node

549
00:22:07,420 --> 00:22:12,690
with n children then the number of

550
00:22:09,610 --> 00:22:13,860
required queries is about n log M

551
00:22:12,690 --> 00:22:16,350
so if there are a hundred possible

552
00:22:13,860 --> 00:22:18,719
values then after about five hundred

553
00:22:16,350 --> 00:22:20,189
queries the attack will succeed so for

554
00:22:18,720 --> 00:22:22,170
instance if we're doing this attack on a

555
00:22:20,190 --> 00:22:24,510
database of patient ages it would take

556
00:22:22,170 --> 00:22:26,910
about this many if queries are chosen

557
00:22:24,510 --> 00:22:29,879
uniformly at random to determine every

558
00:22:26,910 --> 00:22:31,500
patient's age now if you were paying

559
00:22:29,880 --> 00:22:33,420
close attention you might have noticed

560
00:22:31,500 --> 00:22:35,640
that this approach relies on there being

561
00:22:33,420 --> 00:22:39,600
at least one record with every value

562
00:22:35,640 --> 00:22:41,550
from 1 to n but we can actually adopt

563
00:22:39,600 --> 00:22:43,919
the analysis to count how many queries

564
00:22:41,550 --> 00:22:45,870
are required if all we want to do is get

565
00:22:43,920 --> 00:22:46,890
sorted groups of records whose values

566
00:22:45,870 --> 00:22:49,199
are close enough

567
00:22:46,890 --> 00:22:51,270
this applies when there isn't at least

568
00:22:49,200 --> 00:22:54,180
one record with each of the values from

569
00:22:51,270 --> 00:22:55,889
1 to n for this kind of approximate

570
00:22:54,180 --> 00:22:58,470
reconstruction the number of required

571
00:22:55,890 --> 00:23:00,450
queries no longer depends on n it

572
00:22:58,470 --> 00:23:03,060
depends only on how close you want the

573
00:23:00,450 --> 00:23:05,670
values to be relative to n which to me

574
00:23:03,060 --> 00:23:07,169
seems a bit magical for example to group

575
00:23:05,670 --> 00:23:10,110
together records whose values are at

576
00:23:07,170 --> 00:23:12,810
most 5% apart you need only 60 or so

577
00:23:10,110 --> 00:23:15,780
queries regardless of whether that 5% is

578
00:23:12,810 --> 00:23:20,460
of N equals 50 or N equals 500 or n

579
00:23:15,780 --> 00:23:22,560
equals 5,000 this attack showed how

580
00:23:20,460 --> 00:23:24,150
access pattern leakage is sufficient to

581
00:23:22,560 --> 00:23:26,429
order all records and group them by

582
00:23:24,150 --> 00:23:28,590
value from which we can deduce the value

583
00:23:26,430 --> 00:23:31,560
of every single row in the database by

584
00:23:28,590 --> 00:23:34,409
passing the encryption it uses a PQ tree

585
00:23:31,560 --> 00:23:36,030
to encode the leakage along the way even

586
00:23:34,410 --> 00:23:37,980
without the leakage from sufficiently

587
00:23:36,030 --> 00:23:40,260
many queries to exactly determine the

588
00:23:37,980 --> 00:23:43,080
values it's possible to approximately

589
00:23:40,260 --> 00:23:47,370
recover the values and if you want more

590
00:23:43,080 --> 00:23:49,290
details have a look at my paper access

591
00:23:47,370 --> 00:23:50,879
pattern is pretty significant leakage

592
00:23:49,290 --> 00:23:53,129
and in your threat model maybe it

593
00:23:50,880 --> 00:23:54,870
doesn't leak to the adversary volume

594
00:23:53,130 --> 00:23:56,610
leakage on the other hands can be

595
00:23:54,870 --> 00:23:57,959
observed more easily you don't need to

596
00:23:56,610 --> 00:24:00,149
be a persistent adversary whose

597
00:23:57,960 --> 00:24:02,730
compromised a database server to know

598
00:24:00,150 --> 00:24:05,850
how many records match the query even a

599
00:24:02,730 --> 00:24:07,650
network adversary could have access to

600
00:24:05,850 --> 00:24:11,250
this side channel just by monitoring

601
00:24:07,650 --> 00:24:13,590
network traffic but of course the number

602
00:24:11,250 --> 00:24:15,180
of records matching each quarry could

603
00:24:13,590 --> 00:24:17,939
leak in some other way in server side

604
00:24:15,180 --> 00:24:19,740
log files for instance there are plenty

605
00:24:17,940 --> 00:24:21,840
of settings where an adversary can't see

606
00:24:19,740 --> 00:24:26,520
access pattern leakage but it can see

607
00:24:21,840 --> 00:24:28,889
volume leakage suppose that somehow

608
00:24:26,520 --> 00:24:31,620
some way the adversary learns how many

609
00:24:28,890 --> 00:24:34,230
records match every possible range query

610
00:24:31,620 --> 00:24:36,959
it has the entire set of possible query

611
00:24:34,230 --> 00:24:39,330
volumes it doesn't know which query

612
00:24:36,960 --> 00:24:41,700
corresponds to which volume it just sees

613
00:24:39,330 --> 00:24:43,740
the volumes it's going to use these

614
00:24:41,700 --> 00:24:45,750
volumes to determine exactly how many

615
00:24:43,740 --> 00:24:48,330
records there are with each value in the

616
00:24:45,750 --> 00:24:49,950
database if the query distribution can

617
00:24:48,330 --> 00:24:52,139
be modeled it's possible to figure out

618
00:24:49,950 --> 00:24:54,030
again how many queries a network

619
00:24:52,140 --> 00:24:55,590
adversary would need to observe before

620
00:24:54,030 --> 00:25:02,160
it gets all volumes I'll say more about

621
00:24:55,590 --> 00:25:04,199
that later so whether it's by observing

622
00:25:02,160 --> 00:25:06,300
queries or finding some valuable log

623
00:25:04,200 --> 00:25:08,510
file on the server the adversary learns

624
00:25:06,300 --> 00:25:11,490
the set of all possible query volumes

625
00:25:08,510 --> 00:25:13,710
let R be the maximum observed volume

626
00:25:11,490 --> 00:25:16,140
this has to be the volume of the entire

627
00:25:13,710 --> 00:25:20,160
range 1 through n also the number of

628
00:25:16,140 --> 00:25:22,020
rows in the database the idea of our

629
00:25:20,160 --> 00:25:24,570
attack is to identify what we call

630
00:25:22,020 --> 00:25:27,480
elementary volumes among the set of all

631
00:25:24,570 --> 00:25:29,850
volumes elementary volumes are the

632
00:25:27,480 --> 00:25:32,610
volumes of elementary ranges which are

633
00:25:29,850 --> 00:25:37,320
the ranges from 1 to 1 1 to 2 1 2 3 and

634
00:25:32,610 --> 00:25:39,719
so on up to 1 to n if we can identify

635
00:25:37,320 --> 00:25:42,870
which volumes correspond to the

636
00:25:39,720 --> 00:25:44,900
elementary queries then we can deduce

637
00:25:42,870 --> 00:25:47,428
exactly how many records have each value

638
00:25:44,900 --> 00:25:49,200
just subtract the volume of the case

639
00:25:47,429 --> 00:25:51,570
elementary query from the k plus first

640
00:25:49,200 --> 00:25:55,470
elementary query and you get the number

641
00:25:51,570 --> 00:25:57,689
of records with value k plus 1 the

642
00:25:55,470 --> 00:25:59,820
attack succeeds if we identify the set

643
00:25:57,690 --> 00:26:04,890
of elementary volumes so this is now our

644
00:25:59,820 --> 00:26:07,399
goal elementary volumes and ranges have

645
00:26:04,890 --> 00:26:09,800
some pretty special properties first

646
00:26:07,400 --> 00:26:13,170
every elementary range has a

647
00:26:09,800 --> 00:26:15,840
complimentary query such that the sum of

648
00:26:13,170 --> 00:26:18,990
their volumes is exactly our the total

649
00:26:15,840 --> 00:26:22,909
number of rows in the database this is

650
00:26:18,990 --> 00:26:26,520
because any elementary range 1 through I

651
00:26:22,910 --> 00:26:29,070
there exists the query 1 plus I through

652
00:26:26,520 --> 00:26:32,629
n and their volumes have to add up to R

653
00:26:29,070 --> 00:26:37,260
so every elementary range is are

654
00:26:32,630 --> 00:26:39,330
complemented we can send second any

655
00:26:37,260 --> 00:26:40,260
possible range with any two endpoints

656
00:26:39,330 --> 00:26:42,689
either

657
00:26:40,260 --> 00:26:45,299
is an elementary range or is a

658
00:26:42,690 --> 00:26:47,400
difference of elementary ranges if the

659
00:26:45,299 --> 00:26:49,740
left endpoint is one it's an elementary

660
00:26:47,400 --> 00:26:51,360
range by definition if not we can write

661
00:26:49,740 --> 00:26:54,950
it as the difference of two elementary

662
00:26:51,360 --> 00:26:57,209
ranges like you see on the screen and

663
00:26:54,950 --> 00:26:59,730
the third property is that the

664
00:26:57,210 --> 00:27:03,570
difference of any two elementary ranges

665
00:26:59,730 --> 00:27:06,720
is also a range so the difference of any

666
00:27:03,570 --> 00:27:14,639
two elementary volumes also has to be an

667
00:27:06,720 --> 00:27:16,350
observed volume we're going to build a

668
00:27:14,640 --> 00:27:18,450
graph to identify these elementary

669
00:27:16,350 --> 00:27:21,270
volumes using the three properties along

670
00:27:18,450 --> 00:27:23,370
the way first

671
00:27:21,270 --> 00:27:31,139
the nodes of the graph are all of the

672
00:27:23,370 --> 00:27:33,270
observed volumes next we'll draw an edge

673
00:27:31,140 --> 00:27:35,130
between any two nodes if the difference

674
00:27:33,270 --> 00:27:37,530
of their volumes was also an observed

675
00:27:35,130 --> 00:27:39,390
volume in this example there's no edge

676
00:27:37,530 --> 00:27:41,100
between 12 and 8 because their

677
00:27:39,390 --> 00:27:45,210
difference four was not an observed

678
00:27:41,100 --> 00:27:47,820
volume the crucial observation is that

679
00:27:45,210 --> 00:27:52,110
in this graph there will be a sub graph

680
00:27:47,820 --> 00:27:55,049
of the elementary volumes their nodes in

681
00:27:52,110 --> 00:27:57,780
this graph will form a clique which is a

682
00:27:55,049 --> 00:27:59,730
sub set of nodes that are all directly

683
00:27:57,780 --> 00:28:02,910
connected to one another this is a

684
00:27:59,730 --> 00:28:05,250
maximally connected sub set of nodes and

685
00:28:02,910 --> 00:28:07,350
this is because of property 3 the

686
00:28:05,250 --> 00:28:10,440
difference of any two elementary ranges

687
00:28:07,350 --> 00:28:14,780
is also arranged so there must be edges

688
00:28:10,440 --> 00:28:17,850
between every pair of elementary volumes

689
00:28:14,780 --> 00:28:19,290
further the volumes generated by that

690
00:28:17,850 --> 00:28:20,909
clique the volumes of the nodes

691
00:28:19,290 --> 00:28:23,129
themselves and the differences of

692
00:28:20,910 --> 00:28:25,919
volumes which we can assign to the edges

693
00:28:23,130 --> 00:28:27,929
have to generate the entire set of all

694
00:28:25,919 --> 00:28:30,120
volumes this is because of the second

695
00:28:27,929 --> 00:28:31,890
property every range either is an

696
00:28:30,120 --> 00:28:35,639
elementary range or is a difference of

697
00:28:31,890 --> 00:28:37,860
two elementary ranges so using these

698
00:28:35,640 --> 00:28:40,169
properties of range queries we build a

699
00:28:37,860 --> 00:28:42,030
graph using the observed volumes the

700
00:28:40,169 --> 00:28:44,309
properties mean that if we find it click

701
00:28:42,030 --> 00:28:46,830
and it generates all volumes we've

702
00:28:44,309 --> 00:28:48,720
identified the elementary volumes from

703
00:28:46,830 --> 00:28:51,178
which we can reconstruct all element

704
00:28:48,720 --> 00:28:52,679
counts in the database so all we have to

705
00:28:51,179 --> 00:28:53,910
do is find a clique in this graph and

706
00:28:52,679 --> 00:28:55,500
we're done

707
00:28:53,910 --> 00:28:57,000
but in general if you remember some

708
00:28:55,500 --> 00:28:59,460
graph theory this is a pretty hard

709
00:28:57,000 --> 00:29:01,530
problem however we can use some tricks

710
00:28:59,460 --> 00:29:05,640
to find a clique efficiently in most

711
00:29:01,530 --> 00:29:08,010
cases our reconstruction algorithm has

712
00:29:05,640 --> 00:29:09,930
two phases pre-processing and more

713
00:29:08,010 --> 00:29:11,670
traditional clique finding which isn't

714
00:29:09,930 --> 00:29:13,820
always needed so I won't talk about it

715
00:29:11,670 --> 00:29:13,820
much

716
00:29:14,540 --> 00:29:20,010
specifically in the first phase

717
00:29:16,880 --> 00:29:22,850
pre-processing what we'll do is grow a

718
00:29:20,010 --> 00:29:25,530
set of necessary elementary volumes and

719
00:29:22,850 --> 00:29:27,570
shrink a set of candidate elementary

720
00:29:25,530 --> 00:29:29,490
volumes until they're the same set in

721
00:29:27,570 --> 00:29:32,879
which case we've identified the set of

722
00:29:29,490 --> 00:29:34,380
elementary volumes will do this by

723
00:29:32,880 --> 00:29:36,300
alternating reducing the set of

724
00:29:34,380 --> 00:29:39,480
candidate volumes and augmenting the set

725
00:29:36,300 --> 00:29:41,700
of necessary volumes so let's do an

726
00:29:39,480 --> 00:29:43,410
example here's our starting graph each

727
00:29:41,700 --> 00:29:45,060
volume gets a node and there's an edge

728
00:29:43,410 --> 00:29:46,740
between two nodes if the difference of

729
00:29:45,060 --> 00:29:49,320
their volumes was also an observed

730
00:29:46,740 --> 00:29:52,040
volume to start all the nodes are

731
00:29:49,320 --> 00:29:54,600
candidate elementary volumes in green

732
00:29:52,040 --> 00:29:57,149
now first we'll reduce the set of

733
00:29:54,600 --> 00:29:59,340
candidates using property 1 any node

734
00:29:57,150 --> 00:30:02,790
that doesn't have an our complimentary

735
00:29:59,340 --> 00:30:06,030
volume is out of a candidate set so for

736
00:30:02,790 --> 00:30:07,530
example volume 5 has no complement

737
00:30:06,030 --> 00:30:11,100
because there was no arranged quarry

738
00:30:07,530 --> 00:30:19,290
with volume 15 so 5 is out of the set of

739
00:30:11,100 --> 00:30:21,480
candidate elementary volumes next we can

740
00:30:19,290 --> 00:30:23,310
build up the set of necessary elementary

741
00:30:21,480 --> 00:30:26,340
volumes by adding the smallest and

742
00:30:23,310 --> 00:30:27,960
largest complementary volumes the

743
00:30:26,340 --> 00:30:30,600
largest must be the total number of

744
00:30:27,960 --> 00:30:32,940
records are the volume of the range 1

745
00:30:30,600 --> 00:30:35,129
through n an elementary range by

746
00:30:32,940 --> 00:30:36,720
definition and because of properties of

747
00:30:35,130 --> 00:30:39,270
elementary ranges the smallest

748
00:30:36,720 --> 00:30:42,450
complimented volume must also be an

749
00:30:39,270 --> 00:30:44,940
elementary volume then we go back to

750
00:30:42,450 --> 00:30:47,040
pruning the candidate set we can remove

751
00:30:44,940 --> 00:30:49,530
all nodes that aren't adjacent to all

752
00:30:47,040 --> 00:30:51,450
necessary elementary volumes in orange

753
00:30:49,530 --> 00:30:53,490
since we're looking for a clique and

754
00:30:51,450 --> 00:30:57,480
every node is adjacent to every other

755
00:30:53,490 --> 00:30:58,770
node in a clique so maybe you can see

756
00:30:57,480 --> 00:31:02,850
the clique now but we'll do one more

757
00:30:58,770 --> 00:31:06,000
step if we go back to augmenting the set

758
00:31:02,850 --> 00:31:07,169
of necessary volumes v was an observed

759
00:31:06,000 --> 00:31:09,660
volume and it

760
00:31:07,170 --> 00:31:11,910
in only one way in the current graph as

761
00:31:09,660 --> 00:31:15,390
the difference between the volumes 12

762
00:31:11,910 --> 00:31:20,310
and 17 an edge between two candidate

763
00:31:15,390 --> 00:31:22,380
volumes that aren't yet necessary since

764
00:31:20,310 --> 00:31:23,940
every volume is either an elementary

765
00:31:22,380 --> 00:31:25,950
volume or the difference of two

766
00:31:23,940 --> 00:31:30,360
elementary volumes and we observed

767
00:31:25,950 --> 00:31:39,720
volume five this means 12 and 17 must be

768
00:31:30,360 --> 00:31:42,330
elementary volumes and now we're done

769
00:31:39,720 --> 00:31:44,070
all nodes are necessary and we can see

770
00:31:42,330 --> 00:31:53,129
that these four nodes generate the

771
00:31:44,070 --> 00:31:55,770
entire set of observed volumes so to

772
00:31:53,130 --> 00:31:57,840
exploit volume leakage we first built a

773
00:31:55,770 --> 00:32:00,420
graph using all of the observed volumes

774
00:31:57,840 --> 00:32:02,850
we use properties of range queries to

775
00:32:00,420 --> 00:32:05,790
identify the special elementary volumes

776
00:32:02,850 --> 00:32:07,590
which form a clique then we use the

777
00:32:05,790 --> 00:32:11,600
elementary volumes to directly

778
00:32:07,590 --> 00:32:14,459
reconstruct all counts in the database

779
00:32:11,600 --> 00:32:16,080
with only volume leakage it's impossible

780
00:32:14,460 --> 00:32:17,580
to know whether we've recovered element

781
00:32:16,080 --> 00:32:20,010
counts from smallest to largest or

782
00:32:17,580 --> 00:32:21,810
largest to smallest if the element

783
00:32:20,010 --> 00:32:24,360
counts were mirrored we'd still see the

784
00:32:21,810 --> 00:32:26,370
exact same set of volumes so what we've

785
00:32:24,360 --> 00:32:28,139
constructed is actually the counts of

786
00:32:26,370 --> 00:32:33,659
all elements in a database up to

787
00:32:28,140 --> 00:32:36,180
reflection one last thing I said I'd

788
00:32:33,660 --> 00:32:38,460
come back to how many range queries do

789
00:32:36,180 --> 00:32:41,640
we need to observe to get the complete

790
00:32:38,460 --> 00:32:43,380
set of all range volumes to analyze this

791
00:32:41,640 --> 00:32:45,840
we need to model the query distribution

792
00:32:43,380 --> 00:32:50,010
somehow so suppose all ranges are

793
00:32:45,840 --> 00:32:52,070
equally likely then we can apply what's

794
00:32:50,010 --> 00:32:54,510
called a coupon collector bound in

795
00:32:52,070 --> 00:32:56,250
general this tells you if you have a

796
00:32:54,510 --> 00:32:59,420
bunch of things and you pick one at a

797
00:32:56,250 --> 00:33:01,920
time blindly at random then put it back

798
00:32:59,420 --> 00:33:04,350
it tells you how many times you'll need

799
00:33:01,920 --> 00:33:06,180
to repeat this until you've chosen each

800
00:33:04,350 --> 00:33:08,850
of those things at least once

801
00:33:06,180 --> 00:33:12,030
here it applies with the things being

802
00:33:08,850 --> 00:33:14,669
all the possible range queries so using

803
00:33:12,030 --> 00:33:17,520
this coupon collector bound we can say

804
00:33:14,670 --> 00:33:19,920
that if queries are drawn uniformly at

805
00:33:17,520 --> 00:33:20,700
random the number of queries until the

806
00:33:19,920 --> 00:33:23,999
adversary

807
00:33:20,700 --> 00:33:28,980
seen all volumes is about n squared log

808
00:33:23,999 --> 00:33:31,259
n if you're interested in more details

809
00:33:28,980 --> 00:33:34,619
about volume attacks and some extensions

810
00:33:31,259 --> 00:33:37,499
to them like if a records value is

811
00:33:34,619 --> 00:33:39,988
updated how to recover that value or if

812
00:33:37,499 --> 00:33:45,330
a record is inserted how to recover its

813
00:33:39,989 --> 00:33:47,070
value have a look at my paper leaking

814
00:33:45,330 --> 00:33:48,928
access pattern and volume of query

815
00:33:47,070 --> 00:33:51,149
results can be devastating and lead to

816
00:33:48,929 --> 00:33:53,999
bypassing database encryption regardless

817
00:33:51,149 --> 00:33:55,889
of what type of encryption is used so

818
00:33:53,999 --> 00:33:57,690
what can be done I'm not a risk

819
00:33:55,889 --> 00:33:59,789
management expert I can't tell you which

820
00:33:57,690 --> 00:34:01,470
threat model is right for you but I can

821
00:33:59,789 --> 00:34:04,019
suggest what to keep in mind when

822
00:34:01,470 --> 00:34:05,970
evaluating a solution so here are some

823
00:34:04,019 --> 00:34:07,409
recommendations for practitioners from

824
00:34:05,970 --> 00:34:07,980
my point of view the point of view of a

825
00:34:07,409 --> 00:34:13,349
cryptographer

826
00:34:07,980 --> 00:34:16,679
I suggest analyzing leakage from two

827
00:34:13,349 --> 00:34:18,869
angles first making a comprehensive list

828
00:34:16,679 --> 00:34:21,540
of all types of leakage that could occur

829
00:34:18,869 --> 00:34:23,639
in your solution and seconds looking at

830
00:34:21,540 --> 00:34:25,168
specific points or operations and

831
00:34:23,639 --> 00:34:29,069
thinking about what type of leakage

832
00:34:25,168 --> 00:34:31,529
could arise there leakage can arise from

833
00:34:29,069 --> 00:34:33,899
properties related to values queries and

834
00:34:31,530 --> 00:34:36,059
responses besides leaking the actual

835
00:34:33,899 --> 00:34:38,460
values themselves the records can leak

836
00:34:36,059 --> 00:34:40,619
the ordering of values existence of

837
00:34:38,460 --> 00:34:42,299
certain specific values a number of

838
00:34:40,619 --> 00:34:44,280
distinct values the distance between

839
00:34:42,299 --> 00:34:47,009
values whether values are repeated and

840
00:34:44,280 --> 00:34:49,290
so on the repetition allows frequency

841
00:34:47,010 --> 00:34:51,119
analysis attacks an adversary that

842
00:34:49,290 --> 00:34:53,969
already knows a little bit about the

843
00:34:51,119 --> 00:34:55,950
distribution of values can infer a lot

844
00:34:53,969 --> 00:35:00,480
about specific values if their

845
00:34:55,949 --> 00:35:03,390
frequencies are leaked queries can leak

846
00:35:00,480 --> 00:35:06,109
information about the endpoints when a

847
00:35:03,390 --> 00:35:08,609
query is repeated the width of the range

848
00:35:06,109 --> 00:35:13,078
when one range is a subset of another

849
00:35:08,609 --> 00:35:15,119
range and so on besides leaking which

850
00:35:13,079 --> 00:35:18,000
rows matched or how many rows matched

851
00:35:15,119 --> 00:35:19,859
answers to queries can also leak for

852
00:35:18,000 --> 00:35:22,319
example when two sets of matching

853
00:35:19,859 --> 00:35:25,078
records are the same or which records

854
00:35:22,319 --> 00:35:26,790
match the most queries or so on for a

855
00:35:25,079 --> 00:35:28,890
pretty comprehensive list of the types

856
00:35:26,790 --> 00:35:30,930
of leakage I refer you to Kamara Dollaz

857
00:35:28,890 --> 00:35:33,470
paper structured encryption and leakage

858
00:35:30,930 --> 00:35:33,470
suppression

859
00:35:35,810 --> 00:35:40,049
next I suggest you think about what

860
00:35:38,250 --> 00:35:42,540
points in the implementation all these

861
00:35:40,050 --> 00:35:43,980
kinds of leakage could arise for example

862
00:35:42,540 --> 00:35:45,720
it could be when you do an initial

863
00:35:43,980 --> 00:35:48,000
upload of rows in the database

864
00:35:45,720 --> 00:35:52,049
it could be during this bulk upload or a

865
00:35:48,000 --> 00:35:53,820
single insert later on it could be when

866
00:35:52,050 --> 00:35:56,839
you make a single query or when you make

867
00:35:53,820 --> 00:36:01,320
a batch of queries or when you're

868
00:35:56,839 --> 00:36:02,849
profiling the queries it could also be

869
00:36:01,320 --> 00:36:06,119
when performing some maintenance

870
00:36:02,849 --> 00:36:08,460
operations like backups key rotation or

871
00:36:06,119 --> 00:36:10,740
updating the search index you can do a

872
00:36:08,460 --> 00:36:12,869
kind of differential analysis what

873
00:36:10,740 --> 00:36:19,229
changes in the adversaries view when two

874
00:36:12,869 --> 00:36:20,880
things are not the same there's no magic

875
00:36:19,230 --> 00:36:22,349
solution when it comes to side-channel

876
00:36:20,880 --> 00:36:23,640
leakage you're going to have to make

877
00:36:22,349 --> 00:36:26,070
some trade-offs in your encrypted

878
00:36:23,640 --> 00:36:28,020
database solutions so in addition to

879
00:36:26,070 --> 00:36:29,430
considering what could leak and where

880
00:36:28,020 --> 00:36:31,109
you can think about which of the

881
00:36:29,430 --> 00:36:35,368
following techniques for mitigating

882
00:36:31,109 --> 00:36:37,200
leakage would be accessible you could

883
00:36:35,369 --> 00:36:39,569
restrict the type or granularity of

884
00:36:37,200 --> 00:36:41,160
queries for example for range queries

885
00:36:39,569 --> 00:36:43,470
you could force the endpoints of the

886
00:36:41,160 --> 00:36:47,310
range to always be multiples of five or

887
00:36:43,470 --> 00:36:49,740
ten you could add dummy records to your

888
00:36:47,310 --> 00:36:51,480
database if you're using a solution that

889
00:36:49,740 --> 00:36:53,520
leaks frequency information this could

890
00:36:51,480 --> 00:37:00,540
help hide frequency information making

891
00:36:53,520 --> 00:37:03,420
all values appear equally likely you can

892
00:37:00,540 --> 00:37:04,829
also make dummy queries if you leak some

893
00:37:03,420 --> 00:37:07,140
information about the distribution of

894
00:37:04,829 --> 00:37:10,230
queries you can smooth this out by

895
00:37:07,140 --> 00:37:13,940
adding dummy queries and of course you

896
00:37:10,230 --> 00:37:16,290
can also trust Hardware on the server

897
00:37:13,940 --> 00:37:18,780
now what you'll be trading for more

898
00:37:16,290 --> 00:37:20,759
security could be things like incomplete

899
00:37:18,780 --> 00:37:23,160
query results so you get almost all

900
00:37:20,760 --> 00:37:25,109
records in the range you requested or it

901
00:37:23,160 --> 00:37:28,020
could be just probabilistically correct

902
00:37:25,109 --> 00:37:32,160
results with either false positives or

903
00:37:28,020 --> 00:37:34,440
false negatives and a common trade-off

904
00:37:32,160 --> 00:37:36,899
is sacrificing efficiency when querying

905
00:37:34,440 --> 00:37:38,760
the data so maybe a range query takes

906
00:37:36,900 --> 00:37:40,950
multiple rounds of interaction with the

907
00:37:38,760 --> 00:37:43,530
server or maybe there's some

908
00:37:40,950 --> 00:37:47,578
post-processing of results necessary on

909
00:37:43,530 --> 00:37:49,200
the client side or maybe this means that

910
00:37:47,579 --> 00:37:52,319
on the server you can't do any

911
00:37:49,200 --> 00:37:55,308
compression of values or duplication of

912
00:37:52,319 --> 00:37:57,450
data or you can't batch queries

913
00:37:55,309 --> 00:38:02,339
different trade offs can be acceptable

914
00:37:57,450 --> 00:38:04,410
in different situations all right we've

915
00:38:02,339 --> 00:38:06,209
made it to the end this briefing was

916
00:38:04,410 --> 00:38:08,249
about new kinds of side channel attacks

917
00:38:06,209 --> 00:38:12,118
that can break database encryption for

918
00:38:08,249 --> 00:38:14,578
numeric data the two kinds of leakage we

919
00:38:12,119 --> 00:38:17,039
considered access pattern leakage and

920
00:38:14,579 --> 00:38:18,930
volume leakage can arise from say an

921
00:38:17,039 --> 00:38:22,979
adversary who's compromised the database

922
00:38:18,930 --> 00:38:24,989
server or just a network eavesdropper an

923
00:38:22,979 --> 00:38:27,269
adversary can use access pattern leakage

924
00:38:24,989 --> 00:38:28,709
along with the PQ tree to figure out the

925
00:38:27,269 --> 00:38:31,578
value of every record in the database

926
00:38:28,709 --> 00:38:36,209
either exactly or approximately

927
00:38:31,579 --> 00:38:38,789
bypassing any encryption using volume

928
00:38:36,209 --> 00:38:41,038
leakage an adversary can create and

929
00:38:38,789 --> 00:38:43,859
prune a graph to identify these special

930
00:38:41,039 --> 00:38:45,749
elementary volumes which in turn will

931
00:38:43,859 --> 00:38:50,279
lead to completely determining how many

932
00:38:45,749 --> 00:38:52,259
records have each value these attacks

933
00:38:50,279 --> 00:38:54,239
apply to any kind of scheme supporting

934
00:38:52,259 --> 00:38:56,640
numeric range queries that have these

935
00:38:54,239 --> 00:38:58,349
site channels there's no simple way to

936
00:38:56,640 --> 00:39:00,420
eliminate this leakage and all threat

937
00:38:58,349 --> 00:39:02,309
models nor our access pattern leakage

938
00:39:00,420 --> 00:39:04,650
and volume leakage the only kinds of

939
00:39:02,309 --> 00:39:06,180
harmful leakage but there do exist some

940
00:39:04,650 --> 00:39:07,979
countermeasures like adding dummy

941
00:39:06,180 --> 00:39:09,509
records making dummy queries or

942
00:39:07,979 --> 00:39:13,948
increasing the amount of client-side

943
00:39:09,509 --> 00:39:15,420
post-processing of query results at the

944
00:39:13,949 --> 00:39:16,799
beginning I suggested thinking of

945
00:39:15,420 --> 00:39:19,170
encrypted database attacks a

946
00:39:16,799 --> 00:39:20,969
side-channel attacks and we can learn

947
00:39:19,170 --> 00:39:22,949
something from there the black and

948
00:39:20,969 --> 00:39:25,559
baakir padding Oracle attack which was

949
00:39:22,949 --> 00:39:28,289
from 1998 is still regularly found in

950
00:39:25,559 --> 00:39:29,910
the wild today if we don't take sides

951
00:39:28,289 --> 00:39:32,130
and attacks on encrypted databases

952
00:39:29,910 --> 00:39:33,989
seriously now I think they could be with

953
00:39:32,130 --> 00:39:35,339
us for decades so it's worth it to

954
00:39:33,989 --> 00:39:38,039
analyze what we can learn from

955
00:39:35,339 --> 00:39:40,699
side-channel leakage thank you I'm happy

956
00:39:38,039 --> 00:39:40,699
to take any questions

957
00:39:44,900 --> 00:39:51,309
[Applause]

958
00:39:48,430 --> 00:39:54,470
[Music]

959
00:39:51,309 --> 00:39:57,829
hello thank you very much that was

960
00:39:54,470 --> 00:40:00,439
really interesting and fascinating and

961
00:39:57,829 --> 00:40:04,130
if your answer is going to be I should

962
00:40:00,440 --> 00:40:08,450
read your paper that's fine but I didn't

963
00:40:04,130 --> 00:40:14,349
get how in your example you could see

964
00:40:08,450 --> 00:40:14,348
that note 5 did not have an R complement

965
00:40:14,500 --> 00:40:22,130
okay so we had the entire set of query

966
00:40:19,309 --> 00:40:23,809
volumes we we assumed that our set of

967
00:40:22,130 --> 00:40:26,509
observed query volumes is complete for

968
00:40:23,809 --> 00:40:29,960
every possible range query and we had

969
00:40:26,509 --> 00:40:31,220
that the maximum of those volumes was 20

970
00:40:29,960 --> 00:40:33,349
I think if I remember correctly the

971
00:40:31,220 --> 00:40:39,109
total number of records so 20 is the

972
00:40:33,349 --> 00:40:41,119
value of the range 1 through N and there

973
00:40:39,109 --> 00:40:43,490
was a query with volume 5 we don't know

974
00:40:41,119 --> 00:40:47,720
which range but there was no query with

975
00:40:43,490 --> 00:40:49,250
volume 15 so there was no our complement

976
00:40:47,720 --> 00:40:51,439
as we say in that way does that answer

977
00:40:49,250 --> 00:40:53,569
your question about how we could see

978
00:40:51,440 --> 00:40:56,529
whether thank you very much yes I think

979
00:40:53,569 --> 00:40:56,529
thank you for your question

980
00:40:59,240 --> 00:41:05,328
yeah I'm in the center thank you blinded

981
00:41:03,829 --> 00:41:08,539
by the light

982
00:41:05,329 --> 00:41:12,559
how did you find the peak you tree data

983
00:41:08,539 --> 00:41:14,480
structure research yeah in I mean I'm

984
00:41:12,559 --> 00:41:16,940
always curious how people go about doing

985
00:41:14,480 --> 00:41:18,589
this and hot and what type of research

986
00:41:16,940 --> 00:41:21,130
did you do to get it one of my

987
00:41:18,589 --> 00:41:24,259
colleagues found it in this instance I

988
00:41:21,130 --> 00:41:26,180
don't know if he uses some special

989
00:41:24,259 --> 00:41:28,509
academic search engine or just spend

990
00:41:26,180 --> 00:41:30,500
hours and hours looking at old

991
00:41:28,509 --> 00:41:33,380
theoretical computer science papers I'm

992
00:41:30,500 --> 00:41:35,599
not sure that's a good question probably

993
00:41:33,380 --> 00:41:40,359
lots of googling of different query

994
00:41:35,599 --> 00:41:40,359
terms Thanks

995
00:41:41,990 --> 00:41:46,339
I'm over yeah you're looking at me

996
00:41:44,089 --> 00:41:48,650
doctor thanks very much this really

997
00:41:46,339 --> 00:41:50,270
interesting talk I'm blown away I'm

998
00:41:48,650 --> 00:41:54,230
mostly interested in the protective

999
00:41:50,270 --> 00:41:57,440
aspect and you totally lost me near the

1000
00:41:54,230 --> 00:42:00,470
end when you talked about using dummy

1001
00:41:57,440 --> 00:42:04,580
queries as a mitigation strategy is the

1002
00:42:00,470 --> 00:42:06,500
idea just that we're going to flood

1003
00:42:04,580 --> 00:42:09,230
extra legitimate queries from the

1004
00:42:06,500 --> 00:42:11,690
clients so that the observer has to

1005
00:42:09,230 --> 00:42:14,210
observe more transactions before they

1006
00:42:11,690 --> 00:42:17,630
can build their model or are you talking

1007
00:42:14,210 --> 00:42:22,550
about somehow returning illogical like

1008
00:42:17,630 --> 00:42:23,990
disjoint ranges to stymie the building

1009
00:42:22,550 --> 00:42:25,970
of their model that's a very good

1010
00:42:23,990 --> 00:42:28,700
question how can making dummy queries

1011
00:42:25,970 --> 00:42:30,200
help with these kinds of leakage so for

1012
00:42:28,700 --> 00:42:32,240
access pattern leakage and volume

1013
00:42:30,200 --> 00:42:35,029
leakage I don't think they actually help

1014
00:42:32,240 --> 00:42:37,970
mitigate any any vulnerabilities there

1015
00:42:35,030 --> 00:42:41,660
but there are other attacks that work

1016
00:42:37,970 --> 00:42:44,509
using the distribution of ranges so it

1017
00:42:41,660 --> 00:42:48,200
assumes that the queried ranges have

1018
00:42:44,510 --> 00:42:50,630
some distribution and using say the

1019
00:42:48,200 --> 00:42:54,200
distribution of volumes how many times

1020
00:42:50,630 --> 00:42:56,410
you saw on average a query with a

1021
00:42:54,200 --> 00:43:00,589
certain volume you can use that to

1022
00:42:56,410 --> 00:43:02,480
attack volume leakage so for the attacks

1023
00:43:00,589 --> 00:43:04,880
I presented it's not a countermeasure

1024
00:43:02,480 --> 00:43:06,920
because we're not we don't care about

1025
00:43:04,880 --> 00:43:09,680
the distribution of queries but there

1026
00:43:06,920 --> 00:43:12,890
are other attacks I can point you to one

1027
00:43:09,680 --> 00:43:15,680
paper by culeros at all where they use

1028
00:43:12,890 --> 00:43:18,589
the distribution of queries to attack

1029
00:43:15,680 --> 00:43:22,190
volumes great question very much thank

1030
00:43:18,589 --> 00:43:24,740
you one more question toner great

1031
00:43:22,190 --> 00:43:25,730
presentation by the way um one question

1032
00:43:24,740 --> 00:43:29,330
I had is this when you're doing these

1033
00:43:25,730 --> 00:43:31,190
modeling of analyzing all these numbers

1034
00:43:29,330 --> 00:43:33,400
and so forth did you take into

1035
00:43:31,190 --> 00:43:35,390
consideration eventual consistency

1036
00:43:33,400 --> 00:43:37,369
versus strong consistency in the

1037
00:43:35,390 --> 00:43:39,379
databases and how that might have an

1038
00:43:37,369 --> 00:43:42,710
impact on those volume numbers that

1039
00:43:39,380 --> 00:43:44,990
you're trying to extract no I didn't I'm

1040
00:43:42,710 --> 00:43:46,580
actually not familiar with those types

1041
00:43:44,990 --> 00:43:49,189
of consistency and how they would affect

1042
00:43:46,580 --> 00:43:53,109
our attack but that sounds like an

1043
00:43:49,190 --> 00:43:56,710
interesting real problem to consider

1044
00:43:53,109 --> 00:43:56,710
thank you for your question

1045
00:43:59,720 --> 00:44:04,950
thank you

1046
00:44:01,220 --> 00:44:04,950
[Applause]

