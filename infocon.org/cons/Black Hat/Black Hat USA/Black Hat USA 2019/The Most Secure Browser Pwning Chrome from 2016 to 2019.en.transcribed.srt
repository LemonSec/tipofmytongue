1
00:00:00,000 --> 00:00:05,100
hello everyone welcome to Islander e aí

2
00:00:02,280 --> 00:00:09,660
and welcome to the most secure browser

3
00:00:05,100 --> 00:00:10,920
pronin Pony Chrome in 2016 to 2019 with

4
00:00:09,660 --> 00:00:13,019
gunman leo

5
00:00:10,920 --> 00:00:14,610
before we begin I've got a few notes if

6
00:00:13,019 --> 00:00:17,340
you'll stop by the business hall located

7
00:00:14,610 --> 00:00:19,320
in Mandalay Bay Oceanside and shoreline

8
00:00:17,340 --> 00:00:21,509
level 2 that's where the Welcome

9
00:00:19,320 --> 00:00:22,980
Reception will be at 5:30 and it's also

10
00:00:21,510 --> 00:00:25,949
where the blackhat arsenal is being

11
00:00:22,980 --> 00:00:30,840
hosted the Pony Awards tonight are in

12
00:00:25,949 --> 00:00:35,730
Lagoon JKL at 18:30 lunch is in Bayside

13
00:00:30,840 --> 00:00:37,590
a B and from 1205 to 1:30 if you'd do me

14
00:00:35,730 --> 00:00:39,180
a favor and do what they said a second

15
00:00:37,590 --> 00:00:41,100
ago and silence your phones for me that

16
00:00:39,180 --> 00:00:42,450
would be great and other than that let's

17
00:00:41,100 --> 00:00:56,640
get a great round of applause and get

18
00:00:42,450 --> 00:00:58,410
this talk started this is coming from

19
00:00:56,640 --> 00:01:00,780
Hansen a keen lab to give you the talk

20
00:00:58,410 --> 00:01:06,030
the most secure browser honing Chrome

21
00:01:00,780 --> 00:01:07,740
from 2016 to 2019 you have probably

22
00:01:06,030 --> 00:01:09,900
noticed that there should be two

23
00:01:07,740 --> 00:01:12,689
speakers here but only one this is

24
00:01:09,900 --> 00:01:15,689
because my partner Jen cannot come

25
00:01:12,689 --> 00:01:18,449
because of the visa so but don't worry I

26
00:01:15,689 --> 00:01:20,758
will have him share his part and we are

27
00:01:18,450 --> 00:01:23,070
both security researchers at Hanson a

28
00:01:20,759 --> 00:01:25,290
chem lab and we have participated in

29
00:01:23,070 --> 00:01:28,770
Porto on for several times and have won

30
00:01:25,290 --> 00:01:31,560
three months of course and I'll pretend

31
00:01:28,770 --> 00:01:37,560
dentition is in four parts let's go to

32
00:01:31,560 --> 00:01:41,159
the first part the eg set now let's step

33
00:01:37,560 --> 00:01:43,680
method in the terminal set is short for

34
00:01:41,159 --> 00:01:46,649
semantic equivalent transform Jung came

35
00:01:43,680 --> 00:01:49,979
up with the idea in the late 2016 and

36
00:01:46,649 --> 00:01:52,320
added into his father it's easy to use

37
00:01:49,979 --> 00:01:55,710
we fit it with just good files and it

38
00:01:52,320 --> 00:01:58,350
gives us new jobs to the files before we

39
00:01:55,710 --> 00:02:01,408
go into details of set let's see the

40
00:01:58,350 --> 00:02:04,110
state of the art nowadays when we talk

41
00:02:01,409 --> 00:02:05,909
about broth exploitations the JavaScript

42
00:02:04,110 --> 00:02:08,250
engine has been more and more active

43
00:02:05,909 --> 00:02:10,140
target more and more people began their

44
00:02:08,250 --> 00:02:13,230
research in this field and publicize

45
00:02:10,139 --> 00:02:15,119
their findings such as papers and toes

46
00:02:13,230 --> 00:02:18,018
this year only they are fuzzy Liana

47
00:02:15,120 --> 00:02:21,480
Kodiak you missed both are missing fools

48
00:02:18,019 --> 00:02:23,760
so what is father there are many answers

49
00:02:21,480 --> 00:02:26,640
here are two of them on the one hand the

50
00:02:23,760 --> 00:02:29,399
father is an IO process it consumes the

51
00:02:26,640 --> 00:02:31,170
input and gives output on the other hand

52
00:02:29,400 --> 00:02:33,150
the father can be viewed as a searching

53
00:02:31,170 --> 00:02:35,369
process we are hunting for crashes

54
00:02:33,150 --> 00:02:37,230
aren't we different wheels bring

55
00:02:35,370 --> 00:02:39,780
different questions one of the most

56
00:02:37,230 --> 00:02:41,548
important questions that why there is no

57
00:02:39,780 --> 00:02:47,310
mutation based the father looks like

58
00:02:41,549 --> 00:02:49,920
this it receives just crew the fire and

59
00:02:47,310 --> 00:02:52,950
transform it into the abstract syntax

60
00:02:49,920 --> 00:02:55,858
tree then it stops notation on the ast

61
00:02:52,950 --> 00:02:58,619
and finally to transform the mutated ast

62
00:02:55,859 --> 00:03:00,980
into GS again of course it will also

63
00:02:58,620 --> 00:03:03,510
implement the buildings including the

64
00:03:00,980 --> 00:03:05,970
beauties objects and beauty beauty

65
00:03:03,510 --> 00:03:08,399
methods the cheese is the creation of

66
00:03:05,970 --> 00:03:10,950
the scopes the records the variable and

67
00:03:08,400 --> 00:03:12,840
the type information if a variable is a

68
00:03:10,950 --> 00:03:16,349
function we are also interested in its

69
00:03:12,840 --> 00:03:18,480
signature when compute comes to mutation

70
00:03:16,349 --> 00:03:20,929
there are different strategies crossed

71
00:03:18,480 --> 00:03:24,030
over like the sprites face in the AFL

72
00:03:20,930 --> 00:03:26,880
also it can do add delete replace and

73
00:03:24,030 --> 00:03:28,829
the other modifications back to the

74
00:03:26,880 --> 00:03:31,500
question where there is no paper or

75
00:03:28,829 --> 00:03:33,750
toast like this my answer is that the

76
00:03:31,500 --> 00:03:35,579
idea is so instinctive that nobody

77
00:03:33,750 --> 00:03:37,980
thinks either deserve to mention in

78
00:03:35,579 --> 00:03:41,579
public like what I am doing now but

79
00:03:37,980 --> 00:03:43,950
actually it is very effective and this

80
00:03:41,579 --> 00:03:46,260
is the first part he found the mvh which

81
00:03:43,950 --> 00:03:49,250
is exploitable it's a typical

82
00:03:46,260 --> 00:03:51,899
redeafination bug it redefines the s

83
00:03:49,250 --> 00:03:53,519
concatenate above symbol and breaks up

84
00:03:51,900 --> 00:03:55,980
the assumption of v8

85
00:03:53,519 --> 00:03:58,709
he found a bug but it doesn't belong to

86
00:03:55,980 --> 00:04:01,768
him someone else report to Google and

87
00:03:58,709 --> 00:04:04,139
you may notice the question mark in the

88
00:04:01,769 --> 00:04:07,139
title but actually the bug is very good

89
00:04:04,139 --> 00:04:09,470
to exploit the total exploit which pops

90
00:04:07,139 --> 00:04:12,810
up a calculator is no more than 13 lines

91
00:04:09,470 --> 00:04:14,940
if you are interested in the garbage

92
00:04:12,810 --> 00:04:18,570
collection of v8 this bug is a good

93
00:04:14,940 --> 00:04:21,149
startup and so Park creation is the most

94
00:04:18,570 --> 00:04:25,229
annoying it also reminds me of another

95
00:04:21,149 --> 00:04:27,109
bug that is we used it to Paul H

96
00:04:25,229 --> 00:04:29,688
processor in point 1 mm

97
00:04:27,110 --> 00:04:32,060
sixteen is also a redefinition bug we

98
00:04:29,689 --> 00:04:34,879
found it by fuzzy but the bug is too

99
00:04:32,060 --> 00:04:36,710
easy to audit and that's why we were so

100
00:04:34,879 --> 00:04:40,069
nervous we're lucky chair took on edge

101
00:04:36,710 --> 00:04:43,549
before us this bad experience tries to

102
00:04:40,069 --> 00:04:45,919
think how to avoid a collision looking

103
00:04:43,550 --> 00:04:48,520
at a piece of code I am lost in thought

104
00:04:45,919 --> 00:04:51,560
what should we expect from this seed

105
00:04:48,520 --> 00:04:55,370
Epoque like this or this

106
00:04:51,560 --> 00:05:00,500
my answer is no imagine that our seed is

107
00:04:55,370 --> 00:05:02,779
here and a POC is here but I don't

108
00:05:00,500 --> 00:05:05,750
expect that I can find it because the

109
00:05:02,779 --> 00:05:08,800
search headspace is too large we must be

110
00:05:05,750 --> 00:05:08,800
a lucky oh sorry

111
00:05:11,949 --> 00:05:19,520
we must be a lucky dog if we find it and

112
00:05:15,169 --> 00:05:21,590
how about this looks good and there are

113
00:05:19,520 --> 00:05:24,859
still two stars in the searching space

114
00:05:21,590 --> 00:05:27,619
it can be smaller and there are even no

115
00:05:24,860 --> 00:05:29,449
stars but don't worry we should believe

116
00:05:27,620 --> 00:05:32,539
that there are many hidden stars in the

117
00:05:29,449 --> 00:05:34,639
picture and this is what set us in the

118
00:05:32,539 --> 00:05:38,120
picture they are so close to each other

119
00:05:34,639 --> 00:05:40,159
that you cannot hear from them set tries

120
00:05:38,120 --> 00:05:46,069
to find the pot very similar to the seed

121
00:05:40,159 --> 00:05:48,860
and we found CVE 2016 51 98 from this

122
00:05:46,069 --> 00:05:52,129
seed we used it to come from a mobile

123
00:05:48,860 --> 00:05:55,099
point 1 2016 let's see what's a deal

124
00:05:52,129 --> 00:05:57,129
with the seed it erupted the assignment

125
00:05:55,099 --> 00:06:00,169
statement with the function clack

126
00:05:57,129 --> 00:06:02,210
collaboration declaration of course we

127
00:06:00,169 --> 00:06:04,099
must quote at the original position

128
00:06:02,210 --> 00:06:08,029
because JavaScript doesn't implement

129
00:06:04,099 --> 00:06:11,120
dynamic scope and we use check hatch in

130
00:06:08,029 --> 00:06:13,129
case it introduces new arrows here in

131
00:06:11,120 --> 00:06:15,710
fact the check hatch is very important

132
00:06:13,129 --> 00:06:19,250
it stopped the compiler to inline the

133
00:06:15,710 --> 00:06:22,279
small new small function and we inserted

134
00:06:19,250 --> 00:06:25,279
an empty loop in general empty loop can

135
00:06:22,279 --> 00:06:28,639
speed up the optimization and we repeat

136
00:06:25,279 --> 00:06:30,680
into the check hash statement because we

137
00:06:28,639 --> 00:06:33,469
either changed something about handling

138
00:06:30,680 --> 00:06:38,319
the recursion we rewrote the park in the

139
00:06:33,469 --> 00:06:38,319
form of for loop and that is my job

140
00:06:39,220 --> 00:06:44,330
that's how side mutate secede the new

141
00:06:42,500 --> 00:06:47,300
files are very similar to the original

142
00:06:44,330 --> 00:06:49,820
seed but they have different CFG and D F

143
00:06:47,300 --> 00:06:54,290
G and we expect compiler will generate

144
00:06:49,820 --> 00:06:56,210
different JIT codes the list is far from

145
00:06:54,290 --> 00:06:59,060
being complete but it shows some very

146
00:06:56,210 --> 00:07:01,430
useful transform with transformations we

147
00:06:59,060 --> 00:07:04,130
also labor issue with stars most us

148
00:07:01,430 --> 00:07:07,940
means more effective at least you know

149
00:07:04,130 --> 00:07:10,540
of other luminous reps statements with

150
00:07:07,940 --> 00:07:13,280
loop structures such as for in a while

151
00:07:10,540 --> 00:07:16,580
we have seen function eyes empty loop

152
00:07:13,280 --> 00:07:18,530
and repeating or last example said also

153
00:07:16,580 --> 00:07:21,200
inserts some statements which triggers

154
00:07:18,530 --> 00:07:23,570
garbage collection Keynesian eyes

155
00:07:21,200 --> 00:07:26,780
includes jump and compare such as if

156
00:07:23,570 --> 00:07:28,849
statements take function eyes as an

157
00:07:26,780 --> 00:07:31,609
example what can we do with this

158
00:07:28,850 --> 00:07:34,880
assignment statement there are at least

159
00:07:31,610 --> 00:07:36,740
seven kinds of transformations besides

160
00:07:34,880 --> 00:07:39,320
each function can be both global or

161
00:07:36,740 --> 00:07:42,280
local so there must be much informations

162
00:07:39,320 --> 00:07:45,230
we can take it's like the isomers

163
00:07:42,280 --> 00:07:47,150
isomers they have the the same elements

164
00:07:45,230 --> 00:07:48,860
but different structures and their

165
00:07:47,150 --> 00:07:52,190
characteristics are totally different

166
00:07:48,860 --> 00:07:55,340
and here's a story from him in the

167
00:07:52,190 --> 00:07:57,590
first-person narrative perspective ever

168
00:07:55,340 --> 00:08:00,080
disabled all the other faces but only

169
00:07:57,590 --> 00:08:02,630
enabled the sad face Iran defies the

170
00:08:00,080 --> 00:08:04,760
three nights on my post of his pro and

171
00:08:02,630 --> 00:08:07,490
every morning I opened the door and took

172
00:08:04,760 --> 00:08:09,680
a peep at the screen and in the third

173
00:08:07,490 --> 00:08:12,080
day I found a crash detection at that

174
00:08:09,680 --> 00:08:13,730
moment I was quite confident that the

175
00:08:12,080 --> 00:08:17,810
crash must be good and are likely to be

176
00:08:13,730 --> 00:08:20,510
exploitable all the transformations of

177
00:08:17,810 --> 00:08:23,180
set also have the smart version when we

178
00:08:20,510 --> 00:08:26,120
know the context for example if there is

179
00:08:23,180 --> 00:08:28,160
a number or array we can use the number

180
00:08:26,120 --> 00:08:31,550
or the length of the array as the loop

181
00:08:28,160 --> 00:08:35,240
times in the for loop statement we just

182
00:08:31,550 --> 00:08:37,849
uncomment the lines so that said can Co

183
00:08:35,240 --> 00:08:39,650
work without all other faces and set

184
00:08:37,849 --> 00:08:43,960
them can take the advantage of the

185
00:08:39,650 --> 00:08:43,959
information collected in the early phase

186
00:08:44,200 --> 00:08:50,209
there are some results from our fathers

187
00:08:47,330 --> 00:08:52,959
you may notice that the keyword for is

188
00:08:50,209 --> 00:08:55,939
we're and that's what we expect from set

189
00:08:52,959 --> 00:09:00,099
the last one is the bug we used in March

190
00:08:55,939 --> 00:09:03,110
this year and we found it in early 2018

191
00:09:00,100 --> 00:09:05,059
we ever found a bug which had existed

192
00:09:03,110 --> 00:09:08,149
for more than four years and we used it

193
00:09:05,059 --> 00:09:10,279
to post a fairy in 2017 the difference

194
00:09:08,149 --> 00:09:15,079
between the city and the park is only a

195
00:09:10,279 --> 00:09:17,689
four loop that is amazing and as

196
00:09:15,079 --> 00:09:19,819
everyone knows exploitation is another

197
00:09:17,689 --> 00:09:21,559
key point in planning contests so in

198
00:09:19,819 --> 00:09:23,779
this section we will share some

199
00:09:21,559 --> 00:09:27,469
interesting cases and odd exploitation

200
00:09:23,779 --> 00:09:31,009
technique here is the first case we want

201
00:09:27,470 --> 00:09:35,089
to share this is the park of CVE 2017 50

202
00:09:31,009 --> 00:09:37,160
53 which is used in Cointreau 2017 this

203
00:09:35,089 --> 00:09:39,019
is a very typical redefinition bug and

204
00:09:37,160 --> 00:09:42,019
it gives us the out-of-bounds access

205
00:09:39,019 --> 00:09:44,480
capability however not like the other

206
00:09:42,019 --> 00:09:46,490
arrays functions index often includes

207
00:09:44,480 --> 00:09:49,519
can only return a boolean value or an

208
00:09:46,490 --> 00:09:51,559
integer so there is no auto bond right

209
00:09:49,519 --> 00:09:54,439
and we cannot get a pointer from this

210
00:09:51,559 --> 00:09:57,019
out of concrete and it's worth

211
00:09:54,439 --> 00:09:59,209
mentioning that in May this year Steven

212
00:09:57,019 --> 00:10:01,610
from Google posted a technical article

213
00:09:59,209 --> 00:10:05,540
and project zeros blog about exploiting

214
00:10:01,610 --> 00:10:07,879
a similar bug in GOG in the blog Steven

215
00:10:05,540 --> 00:10:09,920
introduced a way for leaking the array

216
00:10:07,879 --> 00:10:12,139
buffer back in store suggests so I'm not

217
00:10:09,920 --> 00:10:14,209
going to talk more about it but there's

218
00:10:12,139 --> 00:10:16,699
the difference between two bugs in this

219
00:10:14,209 --> 00:10:19,459
redefinition bug we can set the arrest

220
00:10:16,699 --> 00:10:22,609
length to zero and its elemental ray

221
00:10:19,459 --> 00:10:24,679
will point to the amplification which

222
00:10:22,610 --> 00:10:29,119
means we can leak the pointers located

223
00:10:24,679 --> 00:10:31,220
in pre-allocated outer space in 2017

224
00:10:29,119 --> 00:10:35,299
there is a code space pointer in the old

225
00:10:31,220 --> 00:10:37,999
space so we can lick it after we got the

226
00:10:35,299 --> 00:10:40,220
address of the code space we can put our

227
00:10:37,999 --> 00:10:41,990
share code which is constructed by

228
00:10:40,220 --> 00:10:44,540
double value in giaggi

229
00:10:41,990 --> 00:10:47,779
on the old tunnel code space this is

230
00:10:44,540 --> 00:10:49,639
also known as Jackie's burry so the only

231
00:10:47,779 --> 00:10:53,540
thing we need is to control the PC

232
00:10:49,639 --> 00:10:56,059
register to jump to our share code also

233
00:10:53,540 --> 00:10:58,579
similar to Stephens approach we use the

234
00:10:56,059 --> 00:11:01,129
string compare for next step there are

235
00:10:58,579 --> 00:11:03,270
several stream types in v8 for external

236
00:11:01,129 --> 00:11:05,640
string in a holder pointer which points

237
00:11:03,270 --> 00:11:09,390
to another training other components for

238
00:11:05,640 --> 00:11:11,730
example the WTF stream in blink and the

239
00:11:09,390 --> 00:11:13,980
stream in other components always use

240
00:11:11,730 --> 00:11:17,220
virtual function code for the comparison

241
00:11:13,980 --> 00:11:19,200
during the index of search so if we can

242
00:11:17,220 --> 00:11:21,750
fake an external stream and a controller

243
00:11:19,200 --> 00:11:25,590
virtual table we will have the PC

244
00:11:21,750 --> 00:11:27,780
control and here's the layout of the fix

245
00:11:25,590 --> 00:11:30,120
external stream that happy information

246
00:11:27,780 --> 00:11:32,370
of the stream is stored in the tag field

247
00:11:30,120 --> 00:11:35,700
so we need to carefully construct the

248
00:11:32,370 --> 00:11:37,710
map and the external pointer points to

249
00:11:35,700 --> 00:11:40,200
the fixed virtual table while the

250
00:11:37,710 --> 00:11:43,410
comparison function is at the 5th index

251
00:11:40,200 --> 00:11:45,330
of the virtual table and after carefully

252
00:11:43,410 --> 00:11:48,209
constructing a stream we put the address

253
00:11:45,330 --> 00:11:50,940
of the fix external string on create

254
00:11:48,210 --> 00:11:51,630
heap and use the auto found compared

255
00:11:50,940 --> 00:11:53,730
with chigger

256
00:11:51,630 --> 00:11:56,280
the virtual function call and a jump to

257
00:11:53,730 --> 00:12:01,320
our share code so that is the first case

258
00:11:56,280 --> 00:12:03,990
we want to share before the next case

259
00:12:01,320 --> 00:12:05,610
let's go back to mobile point 1 2016 and

260
00:12:03,990 --> 00:12:08,880
this is my first exploit

261
00:12:05,610 --> 00:12:11,430
I'm just crypt they are to optimize the

262
00:12:08,880 --> 00:12:13,560
function and in check function the

263
00:12:11,430 --> 00:12:15,390
optimized code would write the number

264
00:12:13,560 --> 00:12:18,449
directly to the property in a few

265
00:12:15,390 --> 00:12:21,180
assembly however we have already reset

266
00:12:18,450 --> 00:12:23,220
the global variable m in sitio our

267
00:12:21,180 --> 00:12:27,329
function so it will lead to out of

268
00:12:23,220 --> 00:12:29,610
bounds right empty fixed array in this

269
00:12:27,330 --> 00:12:31,830
but we proved that the out-of-bounds

270
00:12:29,610 --> 00:12:34,320
access our empty fixed array can lead to

271
00:12:31,830 --> 00:12:36,120
arbitrary adjust read and write and if

272
00:12:34,320 --> 00:12:38,750
you are interested in the exploitation

273
00:12:36,120 --> 00:12:42,540
you can find my talk on classic West

274
00:12:38,750 --> 00:12:45,360
2017 here I really want to recommend

275
00:12:42,540 --> 00:12:46,500
that the properties I really want to

276
00:12:45,360 --> 00:12:49,740
recommend the properties for

277
00:12:46,500 --> 00:12:52,410
exploitation and min is a challenge in

278
00:12:49,740 --> 00:12:55,170
series if you have which is produced by

279
00:12:52,410 --> 00:12:57,719
cell oh it's not a difficult change but

280
00:12:55,170 --> 00:13:00,780
I found that almost all public exploits

281
00:12:57,720 --> 00:13:03,540
take advantage of confusion of the table

282
00:13:00,780 --> 00:13:04,470
array and the elements array except for

283
00:13:03,540 --> 00:13:07,170
seller himself

284
00:13:04,470 --> 00:13:09,360
hello to the took advantage of the

285
00:13:07,170 --> 00:13:11,729
mismatch between the script array under

286
00:13:09,360 --> 00:13:13,740
the properties and I think it is more

287
00:13:11,730 --> 00:13:16,490
convenient because it doesn't need to

288
00:13:13,740 --> 00:13:16,490
fake object

289
00:13:16,910 --> 00:13:21,230
this approach this approach depends on

290
00:13:19,160 --> 00:13:24,530
the wrong information in descriptor

291
00:13:21,230 --> 00:13:27,380
array which is stored in map so the map

292
00:13:24,530 --> 00:13:28,819
up of the object must stay valid but

293
00:13:27,380 --> 00:13:33,170
sometimes the situation is more

294
00:13:28,820 --> 00:13:36,290
difficult this is one of my Park which

295
00:13:33,170 --> 00:13:38,990
can achieve code execution in v8 in one

296
00:13:36,290 --> 00:13:41,000
of the older version of v8 this bucket

297
00:13:38,990 --> 00:13:43,370
writes undefined to map and the property

298
00:13:41,000 --> 00:13:46,760
field so it will destroy the map of the

299
00:13:43,370 --> 00:13:51,770
object and in such case we cannot use

300
00:13:46,760 --> 00:13:55,310
the traditional ways to exploit it this

301
00:13:51,770 --> 00:13:57,410
is the standard by bug 4.1 2017 this is

302
00:13:55,310 --> 00:13:59,719
also a low quality but like the previous

303
00:13:57,410 --> 00:14:01,490
one because of the time I'm not going to

304
00:13:59,720 --> 00:14:03,830
introduce the details of this part and

305
00:14:01,490 --> 00:14:05,930
in summary this bug has the

306
00:14:03,830 --> 00:14:09,020
out-of-bounds pop on the newly allocated

307
00:14:05,930 --> 00:14:11,060
hash table and the offset of pop

308
00:14:09,020 --> 00:14:13,910
operation depends on the high four paths

309
00:14:11,060 --> 00:14:16,550
of the pointer which obviously cannot be

310
00:14:13,910 --> 00:14:18,530
predicted or controlled so it is more

311
00:14:16,550 --> 00:14:22,790
like an uncontrollable use of the free

312
00:14:18,530 --> 00:14:25,189
rather than the out of bounds really to

313
00:14:22,790 --> 00:14:27,620
exploit these low quality bugs we put

314
00:14:25,190 --> 00:14:30,440
forward the JIT fragment in mobile point

315
00:14:27,620 --> 00:14:35,420
or 2016 let's take a look at the

316
00:14:30,440 --> 00:14:37,910
assembly code first you take out the

317
00:14:35,420 --> 00:14:41,449
hard coding adjusts from the global

318
00:14:37,910 --> 00:14:45,650
variable s and then you take out the

319
00:14:41,450 --> 00:14:48,770
property array of the global object net

320
00:14:45,650 --> 00:14:51,100
it directly write the number to the

321
00:14:48,770 --> 00:14:55,670
first property of the property array and

322
00:14:51,100 --> 00:14:57,830
finally it returns undefined we can find

323
00:14:55,670 --> 00:15:00,560
that there is no map check in this

324
00:14:57,830 --> 00:15:04,840
optimizer function in general in general

325
00:15:00,560 --> 00:15:08,030
there is no always there is always sorry

326
00:15:04,840 --> 00:15:11,360
in general there is always no map check

327
00:15:08,030 --> 00:15:14,030
on the global variable but if you modify

328
00:15:11,360 --> 00:15:16,780
this global variable v8 will notify the

329
00:15:14,030 --> 00:15:20,329
optimize the function to be optimized

330
00:15:16,780 --> 00:15:23,569
but think about this question what if we

331
00:15:20,330 --> 00:15:25,790
modify the global object by mistake or

332
00:15:23,570 --> 00:15:28,370
in other words if we can use memory

333
00:15:25,790 --> 00:15:30,379
corruption to modify the global object

334
00:15:28,370 --> 00:15:33,449
we were the function by out

335
00:15:30,379 --> 00:15:36,689
the answer is no so we put forward a

336
00:15:33,449 --> 00:15:38,669
template for the of this approach first

337
00:15:36,689 --> 00:15:40,919
we prepare the global object and its

338
00:15:38,669 --> 00:15:42,779
properties and then we prepare the check

339
00:15:40,919 --> 00:15:44,239
function to write on its properties and

340
00:15:42,779 --> 00:15:47,459
optimize it

341
00:15:44,239 --> 00:15:51,149
after that we triggered our bug to

342
00:15:47,459 --> 00:15:52,829
corrupt the global object s and finally

343
00:15:51,149 --> 00:15:55,229
we check the optimize the function again

344
00:15:52,829 --> 00:15:59,939
and write it directly on the corrupted

345
00:15:55,229 --> 00:16:02,909
object and take the second bug as an

346
00:15:59,939 --> 00:16:05,069
example as I said just now the out of

347
00:16:02,909 --> 00:16:07,379
bounds read always access on the freedom

348
00:16:05,069 --> 00:16:11,878
memory so we first prepare so many set

349
00:16:07,379 --> 00:16:14,189
objects live on v8 heap because the out

350
00:16:11,879 --> 00:16:16,709
of bounds read is uncontrollable so we

351
00:16:14,189 --> 00:16:18,329
have to achieve the bug locally and we

352
00:16:16,709 --> 00:16:21,149
use instance of to check the return

353
00:16:18,329 --> 00:16:22,919
pointer instance of it's very safe which

354
00:16:21,149 --> 00:16:25,289
can avoid a segmentation fault during

355
00:16:22,919 --> 00:16:28,470
the loop if we found a pointer which

356
00:16:25,289 --> 00:16:32,369
points to a set object we save it in the

357
00:16:28,470 --> 00:16:34,349
global variable and then we prepare the

358
00:16:32,369 --> 00:16:38,699
properties and we optimize the function

359
00:16:34,349 --> 00:16:41,009
on the global variable and actually the

360
00:16:38,699 --> 00:16:43,649
set object is released so after we see

361
00:16:41,009 --> 00:16:44,819
so many now objects it will be

362
00:16:43,649 --> 00:16:48,659
overwritten by now

363
00:16:44,819 --> 00:16:50,639
and finally we figure they optimize the

364
00:16:48,659 --> 00:16:53,159
function again it will directly write

365
00:16:50,639 --> 00:16:55,619
the prepared value to now and the

366
00:16:53,159 --> 00:16:58,379
following step is as the same as the out

367
00:16:55,619 --> 00:16:59,970
of context s are empty fixed array this

368
00:16:58,379 --> 00:17:02,399
is just an example that ticket

369
00:16:59,970 --> 00:17:04,169
advantages of the elimination in

370
00:17:02,399 --> 00:17:04,980
optimize the function to exploit the low

371
00:17:04,169 --> 00:17:09,289
quality bugs

372
00:17:04,980 --> 00:17:12,269
I believe you can find more of it and

373
00:17:09,289 --> 00:17:15,898
now let's go to the third part the

374
00:17:12,269 --> 00:17:17,730
chrome sandbox that passed since 2016 we

375
00:17:15,898 --> 00:17:20,279
have successfully pon chrome three times

376
00:17:17,730 --> 00:17:22,949
in different ways the first time is

377
00:17:20,279 --> 00:17:25,319
mobile point one 2016 we use the logical

378
00:17:22,949 --> 00:17:28,259
bug in renderer to start the webview in

379
00:17:25,319 --> 00:17:30,269
privileged app and then we attacked the

380
00:17:28,259 --> 00:17:34,620
webview again to obtain a code execution

381
00:17:30,269 --> 00:17:36,960
with high privilege in recent years

382
00:17:34,620 --> 00:17:39,809
kernel is a very popular text service in

383
00:17:36,960 --> 00:17:41,610
process and box type has however do to

384
00:17:39,809 --> 00:17:42,750
win 3-2 key lockdown it is very

385
00:17:41,610 --> 00:17:44,689
difficult to

386
00:17:42,750 --> 00:17:49,140
attack colonel inside the chrome sandbox

387
00:17:44,690 --> 00:17:51,330
in 2017 we found that CFS is a good

388
00:17:49,140 --> 00:17:54,299
attack surface which can be accessed in

389
00:17:51,330 --> 00:17:59,340
Chrome and we success successfully got

390
00:17:54,299 --> 00:18:01,110
system at that time unfortunately this

391
00:17:59,340 --> 00:18:05,580
attack surface is killed in grass

392
00:18:01,110 --> 00:18:07,620
redstone 3 by the sandbox token the

393
00:18:05,580 --> 00:18:10,230
third time is much this year we use the

394
00:18:07,620 --> 00:18:11,969
use of the free part in indexdb to web

395
00:18:10,230 --> 00:18:14,880
has chrome sandbox and this is the main

396
00:18:11,970 --> 00:18:17,159
carry in researching a pc attack is very

397
00:18:14,880 --> 00:18:17,700
popular this year at the end of last

398
00:18:17,159 --> 00:18:19,620
year

399
00:18:17,700 --> 00:18:22,169
neither one is impressive publicly said

400
00:18:19,620 --> 00:18:24,149
that we attack against a PC after that

401
00:18:22,169 --> 00:18:26,700
Matt grant from project zero of the

402
00:18:24,150 --> 00:18:28,289
posterior blog about HTC bugs we have

403
00:18:26,700 --> 00:18:32,130
learned a lot from their career sharings

404
00:18:28,289 --> 00:18:34,289
so I want to thank them here before we

405
00:18:32,130 --> 00:18:37,289
go deep into the bug we need to know

406
00:18:34,289 --> 00:18:40,590
more about indexdb here's the example of

407
00:18:37,289 --> 00:18:43,799
using the activity in JavaScript first

408
00:18:40,590 --> 00:18:45,720
we can open database with the given DB

409
00:18:43,799 --> 00:18:48,658
name and the version the function will

410
00:18:45,720 --> 00:18:51,090
return our request and then we can bind

411
00:18:48,659 --> 00:18:53,159
some callbacks to the request if the

412
00:18:51,090 --> 00:18:55,918
database is successfully open it will be

413
00:18:53,159 --> 00:18:58,260
sent back through the operator needy the

414
00:18:55,919 --> 00:19:00,929
callback and we can obtain the database

415
00:18:58,260 --> 00:19:02,940
object from the event argument after

416
00:19:00,929 --> 00:19:05,640
that we can create an object store and

417
00:19:02,940 --> 00:19:09,510
index on the database we can also use

418
00:19:05,640 --> 00:19:13,860
deleted database to delete the index DB

419
00:19:09,510 --> 00:19:16,020
database because we already have

420
00:19:13,860 --> 00:19:18,539
colleagues coaching in renderer we can

421
00:19:16,020 --> 00:19:21,629
directly call a PC functions in native

422
00:19:18,539 --> 00:19:24,480
way there are three abuse interfaces

423
00:19:21,630 --> 00:19:27,000
religious related to index DB and we

424
00:19:24,480 --> 00:19:30,960
will focus on the first one which is

425
00:19:27,000 --> 00:19:34,140
related to our vulnerability there are 6

426
00:19:30,960 --> 00:19:40,140
GC functions defined in a DB factual

427
00:19:34,140 --> 00:19:42,240
interface we can easily construct our

428
00:19:40,140 --> 00:19:45,809
POC in a PC course

429
00:19:42,240 --> 00:19:47,820
firstly we call open on DB 1 which we

430
00:19:45,809 --> 00:19:50,668
will first initialize the database in

431
00:19:47,820 --> 00:19:53,220
the browser side after the database is

432
00:19:50,669 --> 00:19:56,070
completely opened we call an accessory

433
00:19:53,220 --> 00:19:56,410
IPC functions inside the callback of the

434
00:19:56,070 --> 00:19:59,649
first

435
00:19:56,410 --> 00:20:02,500
open it should be noted that not like

436
00:19:59,650 --> 00:20:04,900
the first call the last three operations

437
00:20:02,500 --> 00:20:08,230
must be performed together and these

438
00:20:04,900 --> 00:20:10,180
operations are all as asynchronous so

439
00:20:08,230 --> 00:20:17,710
each operation cannot be completely

440
00:20:10,180 --> 00:20:20,920
executed a DB factor is responsible for

441
00:20:17,710 --> 00:20:24,460
managing in the X DB database and there

442
00:20:20,920 --> 00:20:27,040
is a database map in index DB factory

443
00:20:24,460 --> 00:20:29,590
which holds a role pointer to index DB

444
00:20:27,040 --> 00:20:32,530
database notice that role point is very

445
00:20:29,590 --> 00:20:36,399
dangerous in C++ because there is no any

446
00:20:32,530 --> 00:20:38,530
protection on a row pointer after the

447
00:20:36,400 --> 00:20:41,170
deleted database with the fourth course

448
00:20:38,530 --> 00:20:45,639
flag the raw pointer in the database map

449
00:20:41,170 --> 00:20:47,860
should be removed however there is an

450
00:20:45,640 --> 00:20:50,350
active open request when we try to first

451
00:20:47,860 --> 00:20:52,090
close the database the open request will

452
00:20:50,350 --> 00:20:55,419
be performed during the first course and

453
00:20:52,090 --> 00:20:57,070
it will create a new connection we can

454
00:20:55,420 --> 00:20:58,960
take a look at the code if we

455
00:20:57,070 --> 00:21:03,510
coordinated with the fourth close flag

456
00:20:58,960 --> 00:21:06,250
it will first close it immediately and

457
00:21:03,510 --> 00:21:08,290
during the first course the connections

458
00:21:06,250 --> 00:21:10,510
to the database are iterated and a

459
00:21:08,290 --> 00:21:12,790
fourth closed however if there is a

460
00:21:10,510 --> 00:21:14,680
pending connection waiting to open the

461
00:21:12,790 --> 00:21:16,420
request would execute once all the other

462
00:21:14,680 --> 00:21:19,810
connections were destroyed and the

463
00:21:16,420 --> 00:21:22,270
create a new connection as a result the

464
00:21:19,810 --> 00:21:25,720
connect the connections and the active

465
00:21:22,270 --> 00:21:28,600
request is not empty so the to debug

466
00:21:25,720 --> 00:21:31,660
checks failed most seriously it will

467
00:21:28,600 --> 00:21:35,830
prevent the database being removed from

468
00:21:31,660 --> 00:21:38,170
the database map and finally we use

469
00:21:35,830 --> 00:21:41,080
about transactions for database to

470
00:21:38,170 --> 00:21:42,880
remove to remove all transactions it

471
00:21:41,080 --> 00:21:44,980
will release the database since or

472
00:21:42,880 --> 00:21:47,530
references to the database are cleared

473
00:21:44,980 --> 00:21:51,640
so the row pointer in database map

474
00:21:47,530 --> 00:21:54,790
points to a freedom memory now we have a

475
00:21:51,640 --> 00:21:56,770
row pointer that has been released then

476
00:21:54,790 --> 00:21:59,440
we need to find out where it is being

477
00:21:56,770 --> 00:22:01,300
used after some auditing ion we

478
00:21:59,440 --> 00:22:03,750
understood more about open and a deleted

479
00:22:01,300 --> 00:22:03,750
database

480
00:22:04,290 --> 00:22:09,550
these two functions are very similar

481
00:22:06,640 --> 00:22:10,330
tick open as an example when we start

482
00:22:09,550 --> 00:22:12,279
opening

483
00:22:10,330 --> 00:22:14,739
database you know we were first search

484
00:22:12,279 --> 00:22:17,649
in database in map according to the DB

485
00:22:14,739 --> 00:22:20,019
name and its origin if fun it will

486
00:22:17,649 --> 00:22:22,449
directly return the database pointer in

487
00:22:20,019 --> 00:22:25,330
in the database map to perform the

488
00:22:22,450 --> 00:22:27,399
following operations in other words we

489
00:22:25,330 --> 00:22:32,408
can do open and the delete operation on

490
00:22:27,399 --> 00:22:34,029
a free database to exploit Chrome on

491
00:22:32,409 --> 00:22:35,679
Windows we need to learn some basic

492
00:22:34,029 --> 00:22:38,200
knowledge before we start writing our

493
00:22:35,679 --> 00:22:40,499
exploit firstly there is no control flow

494
00:22:38,200 --> 00:22:43,089
guard in chrome process on Windows

495
00:22:40,499 --> 00:22:44,979
certainly the library adjusts in every

496
00:22:43,089 --> 00:22:46,749
process on Windows has seams so we can

497
00:22:44,979 --> 00:22:49,869
obtain the library address from the

498
00:22:46,749 --> 00:22:51,669
compromised renderer process certainly

499
00:22:49,869 --> 00:22:54,488
there are many virtual function calls in

500
00:22:51,669 --> 00:22:56,889
C++ implementation so it is easy to

501
00:22:54,489 --> 00:22:59,709
control PC raddest the only thing we

502
00:22:56,889 --> 00:23:02,678
need is a hip adjust to put our Rob King

503
00:22:59,709 --> 00:23:06,279
on so we need to leak leak hip adjust

504
00:23:02,679 --> 00:23:08,649
first we also noticed that if we

505
00:23:06,279 --> 00:23:10,959
successfully opened a database it will

506
00:23:08,649 --> 00:23:13,599
return some information such as a DB

507
00:23:10,959 --> 00:23:15,820
name and object store names and the

508
00:23:13,599 --> 00:23:18,339
opposed object of paste gene structure

509
00:23:15,820 --> 00:23:20,559
and we all know that string is very good

510
00:23:18,339 --> 00:23:23,369
for info leak so until now everything

511
00:23:20,559 --> 00:23:26,289
looks fine let's take a look at the code

512
00:23:23,369 --> 00:23:28,599
the connection open connection and the

513
00:23:26,289 --> 00:23:30,820
deleted database are very similar when

514
00:23:28,599 --> 00:23:33,849
we call open or delete the database they

515
00:23:30,820 --> 00:23:36,579
won't do it immediately instead the

516
00:23:33,849 --> 00:23:39,489
first create we first create a new

517
00:23:36,579 --> 00:23:41,259
request and then they pass the new

518
00:23:39,489 --> 00:23:47,049
requested to a panel request the

519
00:23:41,259 --> 00:23:49,269
function in a panel request the newly

520
00:23:47,049 --> 00:23:51,519
created connection request is pushed to

521
00:23:49,269 --> 00:23:55,539
pending requests which is a circular

522
00:23:51,519 --> 00:23:57,429
queue and if there is no active request

523
00:23:55,539 --> 00:24:02,679
it will process the request secured

524
00:23:57,429 --> 00:24:04,690
immediately in process request secured

525
00:24:02,679 --> 00:24:07,239
it takes out the first request of the

526
00:24:04,690 --> 00:24:12,759
queue and then called virtual function

527
00:24:07,239 --> 00:24:14,649
perform on the request in the perform

528
00:24:12,759 --> 00:24:16,779
function we can see that if we can

529
00:24:14,649 --> 00:24:18,728
successfully open the database you know

530
00:24:16,779 --> 00:24:21,279
will send back to connect a connection

531
00:24:18,729 --> 00:24:21,729
and the DBS metadata via unsuccess go

532
00:24:21,279 --> 00:24:24,169
back

533
00:24:21,729 --> 00:24:26,269
besides metadata is a member

534
00:24:24,169 --> 00:24:28,730
object of structure tab index DB

535
00:24:26,269 --> 00:24:32,090
database metadata which includes a basis

536
00:24:28,730 --> 00:24:34,429
gene obviously we can easily control the

537
00:24:32,090 --> 00:24:37,939
stream seems info leak is not difficult

538
00:24:34,429 --> 00:24:40,159
to us and after carefully constructing

539
00:24:37,940 --> 00:24:42,830
the fake in the activity data base as

540
00:24:40,159 --> 00:24:47,539
successfully reached the unsuccess

541
00:24:42,830 --> 00:24:50,899
callback but then I got the sorry but

542
00:24:47,539 --> 00:24:53,739
there got a second machine fault after

543
00:24:50,899 --> 00:24:57,408
some debugging I found out the reason

544
00:24:53,739 --> 00:25:00,409
this is because there is also an STD map

545
00:24:57,409 --> 00:25:04,129
in metadata which is implemented as red

546
00:25:00,409 --> 00:25:06,649
black G in C++ during the Quebec

547
00:25:04,129 --> 00:25:08,869
construction it has to copy construct

548
00:25:06,649 --> 00:25:12,320
the index DB database method data

549
00:25:08,869 --> 00:25:16,609
structure which needs to iterate the STD

550
00:25:12,320 --> 00:25:18,470
map the end of the RPG traversal we

551
00:25:16,609 --> 00:25:21,199
appointed to the object itself and

552
00:25:18,470 --> 00:25:23,869
represent the end this means we have

553
00:25:21,200 --> 00:25:26,269
taught we have to know the the address

554
00:25:23,869 --> 00:25:28,488
of metadata itself to enter the

555
00:25:26,269 --> 00:25:31,909
traversal but we don't know anything

556
00:25:28,489 --> 00:25:33,649
about the HIPAA Jess so we have no

557
00:25:31,909 --> 00:25:37,429
choice but to find other ways to

558
00:25:33,649 --> 00:25:42,049
continue our exploitation let's go back

559
00:25:37,429 --> 00:25:45,350
to a panel request the actual request is

560
00:25:42,049 --> 00:25:48,109
a member of index of DB database which

561
00:25:45,350 --> 00:25:50,379
is fully controlled and if it is non

562
00:25:48,109 --> 00:25:52,850
zero the function will return directly

563
00:25:50,379 --> 00:25:57,469
so that we can avoid a segmentation

564
00:25:52,850 --> 00:25:59,840
fault in process requests the queue now

565
00:25:57,470 --> 00:26:02,299
let's stop the boring code analysis and

566
00:25:59,840 --> 00:26:04,970
to see the results in the debugger first

567
00:26:02,299 --> 00:26:08,899
we construct office with exploit we

568
00:26:04,970 --> 00:26:11,600
prepared an array buffer incest hex 148

569
00:26:08,899 --> 00:26:14,719
which is in the same set class as the

570
00:26:11,600 --> 00:26:18,259
index DB database and we set the active

571
00:26:14,720 --> 00:26:20,720
request to 101 then we use blob to do

572
00:26:18,259 --> 00:26:24,259
hips Prix it is worth mentioning that

573
00:26:20,720 --> 00:26:26,960
blob is the most popular object for

574
00:26:24,259 --> 00:26:29,629
springing chrome and finally we

575
00:26:26,960 --> 00:26:31,730
coordinated database need need to add

576
00:26:29,629 --> 00:26:34,428
one more thing here delete database is

577
00:26:31,730 --> 00:26:37,070
is the same as in the XD we in open

578
00:26:34,429 --> 00:26:39,279
since we won't pro process the requested

579
00:26:37,070 --> 00:26:39,279
kill

580
00:26:39,970 --> 00:26:46,280
in debugger we set a breakpoint at the

581
00:26:43,760 --> 00:26:49,100
deleted database function and notice

582
00:26:46,280 --> 00:26:51,710
that the RDI register represents the

583
00:26:49,100 --> 00:26:54,949
first parameter in Linux which points to

584
00:26:51,710 --> 00:26:57,410
our magic number 1 1 1 and this means we

585
00:26:54,950 --> 00:27:01,160
have already controlled the index DB

586
00:26:57,410 --> 00:27:04,220
database and here's the memory of index

587
00:27:01,160 --> 00:27:06,890
DB database before the deletion and then

588
00:27:04,220 --> 00:27:09,860
we continue the execution and received a

589
00:27:06,890 --> 00:27:12,770
gift we surprising you find that after

590
00:27:09,860 --> 00:27:15,229
the deleted database there is a keeper

591
00:27:12,770 --> 00:27:17,960
pointer on the object and everything

592
00:27:15,230 --> 00:27:21,680
goes well so what is the key pointer

593
00:27:17,960 --> 00:27:25,400
here let's go back to a pen request

594
00:27:21,680 --> 00:27:28,280
again remember that penny requests is a

595
00:27:25,400 --> 00:27:30,920
member of a skew structure if we leave

596
00:27:28,280 --> 00:27:33,590
everything 0 it will automatically in

597
00:27:30,920 --> 00:27:35,810
need during the first push operation it

598
00:27:33,590 --> 00:27:38,899
will first allocate a container buffer

599
00:27:35,810 --> 00:27:41,870
for storing its elements and then store

600
00:27:38,900 --> 00:27:45,350
the container pointer to itself so we

601
00:27:41,870 --> 00:27:47,959
must as thank you for this gift and

602
00:27:45,350 --> 00:27:51,020
remember that the object is not only an

603
00:27:47,960 --> 00:27:53,150
index DB database but also a blob so we

604
00:27:51,020 --> 00:27:57,650
can easily read the the keeper pointer

605
00:27:53,150 --> 00:27:59,960
from the blob now we got the he purges

606
00:27:57,650 --> 00:28:02,570
the following step is almost a copy from

607
00:27:59,960 --> 00:28:04,670
net and new class this exploit so thank

608
00:28:02,570 --> 00:28:07,939
them again and I will skip this part

609
00:28:04,670 --> 00:28:10,310
quickly there is a virtual call in to

610
00:28:07,940 --> 00:28:13,670
delete and we can easily control the

611
00:28:10,310 --> 00:28:15,830
virtual table they exploited change is

612
00:28:13,670 --> 00:28:17,780
shown in this diagram first we cheated

613
00:28:15,830 --> 00:28:21,230
about to release the index DB database

614
00:28:17,780 --> 00:28:23,300
they whisper a blob three blobs to fill

615
00:28:21,230 --> 00:28:25,880
the hole after that we caught a little

616
00:28:23,300 --> 00:28:28,730
database and a liquid HIPAA pointer from

617
00:28:25,880 --> 00:28:30,710
the blob and next we freed the leaked

618
00:28:28,730 --> 00:28:33,590
blob and refill the hole with new

619
00:28:30,710 --> 00:28:36,620
content then we spray so many pitch

620
00:28:33,590 --> 00:28:38,899
heaps which includes our blob chain and

621
00:28:36,620 --> 00:28:42,110
finally we trigger the virtual function

622
00:28:38,900 --> 00:28:44,030
call and a start Rob actually there are

623
00:28:42,110 --> 00:28:46,729
some obstacles in the in the

624
00:28:44,030 --> 00:28:49,460
exploitation for example chrome uses

625
00:28:46,730 --> 00:28:51,650
kisima lock for skip management and in

626
00:28:49,460 --> 00:28:54,770
all bug the index TV

627
00:28:51,650 --> 00:28:56,840
is in the IDB threat well the blob

628
00:28:54,770 --> 00:28:59,330
allocation is in the arrow threat and

629
00:28:56,840 --> 00:29:02,110
actually it is very difficult to feel

630
00:28:59,330 --> 00:29:03,980
the whole from different strata cache

631
00:29:02,110 --> 00:29:05,689
unfortunately because of the time I

632
00:29:03,980 --> 00:29:07,850
cannot share more about the details of

633
00:29:05,690 --> 00:29:10,840
TC Malik and if you are interested we

634
00:29:07,850 --> 00:29:13,699
can discuss after the talk

635
00:29:10,840 --> 00:29:15,709
since the exploit on Windows is not

636
00:29:13,700 --> 00:29:18,800
fresh and not very difficult so it

637
00:29:15,710 --> 00:29:20,690
prepared more for my audience in

638
00:29:18,800 --> 00:29:22,639
addition to v8 and the index TV

639
00:29:20,690 --> 00:29:25,370
vulnerabilities we also report to the

640
00:29:22,640 --> 00:29:27,680
three Chrome OS bugs for ponen so we

641
00:29:25,370 --> 00:29:29,629
need to exploit chrome sandbox on Chrome

642
00:29:27,680 --> 00:29:33,380
OS which is much more difficult

643
00:29:29,630 --> 00:29:36,410
challenge the first thing I need to say

644
00:29:33,380 --> 00:29:38,810
is that chrome and Chrome OS is very

645
00:29:36,410 --> 00:29:41,150
similar to it on Linux because Chrome OS

646
00:29:38,810 --> 00:29:43,460
is actually a Linux kernel-based

647
00:29:41,150 --> 00:29:45,800
operating system so the following

648
00:29:43,460 --> 00:29:48,830
exploit and the demo is actually on

649
00:29:45,800 --> 00:29:51,500
Linux but the approach is FEMA on Chrome

650
00:29:48,830 --> 00:29:54,230
OS to the best of our knowledge it might

651
00:29:51,500 --> 00:29:59,510
be the first public exploit after the C

652
00:29:54,230 --> 00:30:02,960
after the CF is deployed on Chrome so

653
00:29:59,510 --> 00:30:05,000
now so let's check the difference the

654
00:30:02,960 --> 00:30:06,920
biggest difficulty on Chrome OS and

655
00:30:05,000 --> 00:30:10,430
Linux is the clone control flow

656
00:30:06,920 --> 00:30:13,130
integrity which protects or in indirect

657
00:30:10,430 --> 00:30:14,050
costs so we cannot attack the virtual

658
00:30:13,130 --> 00:30:16,430
function anymore

659
00:30:14,050 --> 00:30:17,990
besides the binary and the library

660
00:30:16,430 --> 00:30:20,480
adjusts in main process is different

661
00:30:17,990 --> 00:30:22,630
from the renderer process so we have no

662
00:30:20,480 --> 00:30:27,350
binary and the library adjust this time

663
00:30:22,630 --> 00:30:30,020
in history we cannot find any purpose

664
00:30:27,350 --> 00:30:33,010
methods on clone control flow integrity

665
00:30:30,020 --> 00:30:35,900
except stack based corruption

666
00:30:33,010 --> 00:30:38,090
however stack based attack is also very

667
00:30:35,900 --> 00:30:39,680
difficult in chrome first we need to

668
00:30:38,090 --> 00:30:43,639
know the strategist and the binaries

669
00:30:39,680 --> 00:30:46,430
adjust and even worse chrome uses thread

670
00:30:43,640 --> 00:30:48,590
pool for handling IPC messages so we

671
00:30:46,430 --> 00:30:51,260
might attack thread stack which is a

672
00:30:48,590 --> 00:30:53,510
little bit random besides it also

673
00:30:51,260 --> 00:30:55,760
requires high demand arbitrary address

674
00:30:53,510 --> 00:30:59,980
the right capabilities in summary this

675
00:30:55,760 --> 00:31:02,720
seems to be an impossible task for me

676
00:30:59,980 --> 00:31:05,570
but don't forget that chrome is a huge

677
00:31:02,720 --> 00:31:08,600
system we can easily tamper with lots of

678
00:31:05,570 --> 00:31:11,509
through memory corruption not only the

679
00:31:08,600 --> 00:31:13,488
traditional PC control so don't be

680
00:31:11,509 --> 00:31:17,779
chapped by rules just a free your

681
00:31:13,489 --> 00:31:19,580
imagination there are more than 100

682
00:31:17,779 --> 00:31:21,619
flags in Chrome and some of them are

683
00:31:19,580 --> 00:31:24,379
interesting when I was reading the

684
00:31:21,619 --> 00:31:27,019
Chrome's documentation I found that the

685
00:31:24,379 --> 00:31:30,080
renderer command prefix might be the one

686
00:31:27,019 --> 00:31:35,570
I needed to think more about it let's

687
00:31:30,080 --> 00:31:37,849
check how a renderer process start each

688
00:31:35,570 --> 00:31:40,570
rendering process corresponds to a run

689
00:31:37,849 --> 00:31:42,859
render process host in process ID

690
00:31:40,570 --> 00:31:46,570
responsible for the management of the

691
00:31:42,859 --> 00:31:49,340
process during the initialized

692
00:31:46,570 --> 00:31:51,769
initialization it first gets the value

693
00:31:49,340 --> 00:31:56,539
of rendered command prefix from browser

694
00:31:51,769 --> 00:31:58,789
command line and then it prepares the

695
00:31:56,539 --> 00:32:02,479
renderer command prefix value to the

696
00:31:58,789 --> 00:32:05,119
command line variable finally if you use

697
00:32:02,479 --> 00:32:08,450
the variable to launch the child process

698
00:32:05,119 --> 00:32:10,488
this means if we can if we are able to

699
00:32:08,450 --> 00:32:13,309
control the value of renderer command

700
00:32:10,489 --> 00:32:16,279
prefix we will control the command line

701
00:32:13,309 --> 00:32:19,820
of the child process and launch anything

702
00:32:16,279 --> 00:32:22,190
we want and here's the example start

703
00:32:19,820 --> 00:32:26,239
chrome with the renderer command prefix

704
00:32:22,190 --> 00:32:31,580
flag the value will be pretend prepended

705
00:32:26,239 --> 00:32:34,519
to chow the process command line as we

706
00:32:31,580 --> 00:32:37,129
said when the command command prefix is

707
00:32:34,519 --> 00:32:39,019
stored in browser command line so the

708
00:32:37,129 --> 00:32:41,629
next question is that what is the

709
00:32:39,019 --> 00:32:43,639
browser command line after little

710
00:32:41,629 --> 00:32:45,949
research we found that it is from a

711
00:32:43,639 --> 00:32:48,949
static function which returns a global

712
00:32:45,950 --> 00:32:53,979
pointer and all command lines are saved

713
00:32:48,950 --> 00:32:53,979
in the switches of the globe of arrival

714
00:32:54,940 --> 00:33:00,919
so for command line injection we only

715
00:32:58,099 --> 00:33:03,229
needed two things the first one is a

716
00:33:00,919 --> 00:33:05,989
binary adjust because the global pointer

717
00:33:03,229 --> 00:33:09,019
is located in the BSS segment and

718
00:33:05,989 --> 00:33:11,539
secondly we need an 8 bytes write to

719
00:33:09,019 --> 00:33:14,480
hijack the pointer the machine seems

720
00:33:11,539 --> 00:33:18,408
much easier but until now we only have a

721
00:33:14,480 --> 00:33:20,870
he purges no more leak and no right so I

722
00:33:18,409 --> 00:33:23,370
want more

723
00:33:20,870 --> 00:33:24,449
luckily bisque U is more valuable than

724
00:33:23,370 --> 00:33:27,120
we expected

725
00:33:24,450 --> 00:33:29,550
his name's miss implement some basic

726
00:33:27,120 --> 00:33:32,729
structures some of them are very similar

727
00:33:29,550 --> 00:33:33,600
to STD but a little bit different miss Q

728
00:33:32,730 --> 00:33:36,690
is an example

729
00:33:33,600 --> 00:33:39,050
it is like STD kill but use the circular

730
00:33:36,690 --> 00:33:40,260
D Q instead of the cure for its

731
00:33:39,050 --> 00:33:43,350
container-based

732
00:33:40,260 --> 00:33:48,090
miss Q is a 4.0 size structure the

733
00:33:43,350 --> 00:33:50,100
layout is as follows the first field of

734
00:33:48,090 --> 00:33:53,909
with Q is a container pointer which

735
00:33:50,100 --> 00:33:55,590
points to the elements array and the

736
00:33:53,910 --> 00:33:58,230
second field is the size of the

737
00:33:55,590 --> 00:34:01,409
container ray the third field is the

738
00:33:58,230 --> 00:34:03,720
front index of a cure and the the

739
00:34:01,410 --> 00:34:08,220
lasting field is the real index of the

740
00:34:03,720 --> 00:34:11,490
cure remember that we can append a

741
00:34:08,219 --> 00:34:13,439
request for any x with no side effect so

742
00:34:11,489 --> 00:34:20,569
we can play with the q of really and

743
00:34:13,440 --> 00:34:23,760
there are two different situations if

744
00:34:20,570 --> 00:34:26,490
the queue is not full it will push the

745
00:34:23,760 --> 00:34:28,500
new request to the container since we

746
00:34:26,489 --> 00:34:30,750
can fully control the container pointer

747
00:34:28,500 --> 00:34:35,460
we can write the new requester pointer

748
00:34:30,750 --> 00:34:38,030
to any urges and if the size is equal to

749
00:34:35,460 --> 00:34:41,040
the length we were expanded as storage

750
00:34:38,030 --> 00:34:43,380
automatically in detail it will increase

751
00:34:41,040 --> 00:34:46,560
the storage by 1/4 which needed to

752
00:34:43,380 --> 00:34:48,780
reallocate the buffer it first allocates

753
00:34:46,560 --> 00:34:51,210
a new buffer then move the previous

754
00:34:48,780 --> 00:34:54,140
memory to the new buffer finally it

755
00:34:51,210 --> 00:34:56,668
frees the previous buffer pointer

756
00:34:54,139 --> 00:34:58,799
similarly the previous point is

757
00:34:56,668 --> 00:35:03,690
controllable so we got the Archery's

758
00:34:58,800 --> 00:35:06,120
adjust 3 but be careful of the memory

759
00:35:03,690 --> 00:35:09,060
move it will clear the memory according

760
00:35:06,120 --> 00:35:11,069
to the given size so before free we have

761
00:35:09,060 --> 00:35:14,040
to guarantee that the buffer size is

762
00:35:11,070 --> 00:35:20,040
larger than the queue size and we have

763
00:35:14,040 --> 00:35:23,790
to thank you again then let's see how to

764
00:35:20,040 --> 00:35:26,340
take advantage of the archer free every

765
00:35:23,790 --> 00:35:30,060
time we call it a database the length of

766
00:35:26,340 --> 00:35:31,850
the pending requests increases by 1 so

767
00:35:30,060 --> 00:35:36,140
here we first increase in

768
00:35:31,850 --> 00:35:38,240
Chris the length of the queue 234 here's

769
00:35:36,140 --> 00:35:42,620
the memory of Penny request of the first

770
00:35:38,240 --> 00:35:45,259
division and after we delete database

771
00:35:42,620 --> 00:35:49,310
third times the length of the queue goes

772
00:35:45,260 --> 00:35:52,850
to three and the fourth division we are

773
00:35:49,310 --> 00:35:57,100
cheek area log the size increases by 1/4

774
00:35:52,850 --> 00:36:00,259
and and previous buffer is cleared after

775
00:35:57,100 --> 00:36:05,420
34 divisions the size of the queue goes

776
00:36:00,260 --> 00:36:08,090
to 42 which is hacked 150 parts remember

777
00:36:05,420 --> 00:36:11,450
that the size of blob and the index DB

778
00:36:08,090 --> 00:36:14,450
database are both 148 so they are all in

779
00:36:11,450 --> 00:36:19,419
the same size class in kisima lock which

780
00:36:14,450 --> 00:36:22,250
actually consumed 160 bytes in memory

781
00:36:19,420 --> 00:36:24,920
since we have already read a thousand of

782
00:36:22,250 --> 00:36:26,870
blobs with in the same size the

783
00:36:24,920 --> 00:36:29,030
container buffer will have high

784
00:36:26,870 --> 00:36:31,390
probability of being surrounded by the

785
00:36:29,030 --> 00:36:31,390
blocks

786
00:36:32,590 --> 00:36:37,280
next we'll read the address of the

787
00:36:34,910 --> 00:36:39,379
container buffer from the blob that will

788
00:36:37,280 --> 00:36:45,080
rival leakages should be the value of

789
00:36:39,380 --> 00:36:47,720
container pointer and then we subtract

790
00:36:45,080 --> 00:36:51,350
the leakage as from the size of the

791
00:36:47,720 --> 00:36:53,330
structure and this is very important as

792
00:36:51,350 --> 00:36:55,490
I said the container is surrounded by

793
00:36:53,330 --> 00:37:04,250
the blobs so the new point is very

794
00:36:55,490 --> 00:37:07,069
likely to point to a blob so here's a

795
00:37:04,250 --> 00:37:09,980
diagram the leak the leakage has points

796
00:37:07,070 --> 00:37:12,650
to a blob that we sprayed then we use

797
00:37:09,980 --> 00:37:19,220
the archery free to release the leak yes

798
00:37:12,650 --> 00:37:21,260
and the blob is read and then we

799
00:37:19,220 --> 00:37:25,669
immediately open a new database with a

800
00:37:21,260 --> 00:37:27,920
different name thanks to thread cache

801
00:37:25,670 --> 00:37:30,110
the newly created database can reuse

802
00:37:27,920 --> 00:37:33,140
that the space just released very stable

803
00:37:30,110 --> 00:37:38,780
so now there is a database pointing to

804
00:37:33,140 --> 00:37:40,910
the same place as the blob the handles

805
00:37:38,780 --> 00:37:43,370
of the blob imports size are still valid

806
00:37:40,910 --> 00:37:47,049
so we can also use the proper to read

807
00:37:43,370 --> 00:37:47,049
the content of the new database

808
00:37:47,279 --> 00:37:59,109
from the vtable of indexeddb database we

809
00:37:51,160 --> 00:38:02,109
got the binary edges the last remaining

810
00:37:59,109 --> 00:38:04,359
problem is the eight bytes right we

811
00:38:02,109 --> 00:38:07,269
cannot fully Nick and control the index

812
00:38:04,359 --> 00:38:12,308
DB database so we can try more RPC calls

813
00:38:07,269 --> 00:38:15,328
in our DB database interface according

814
00:38:12,309 --> 00:38:17,709
to the FEC name we choose two candidates

815
00:38:15,329 --> 00:38:23,140
rename objects store and the rename

816
00:38:17,709 --> 00:38:25,359
index remember that object stores are

817
00:38:23,140 --> 00:38:29,410
stored in an STD map which is a member

818
00:38:25,359 --> 00:38:31,630
of metadata while indexes are studying

819
00:38:29,410 --> 00:38:36,279
an STD map which is a member of object

820
00:38:31,630 --> 00:38:39,069
store just as the name implies the two

821
00:38:36,279 --> 00:38:43,059
FEC costs can modify the name of object

822
00:38:39,069 --> 00:38:45,579
store and index let's take a look at the

823
00:38:43,059 --> 00:38:48,219
rename object store first before

824
00:38:45,579 --> 00:38:50,739
renaming it will check if the current

825
00:38:48,219 --> 00:38:53,769
name is the same as the one it saved

826
00:38:50,739 --> 00:38:55,690
previously and I found it and I found it

827
00:38:53,769 --> 00:38:59,379
is a little bit difficult to bypass this

828
00:38:55,690 --> 00:39:02,469
check so I turned to the next one there

829
00:38:59,380 --> 00:39:04,390
are also many checks rename index but

830
00:39:02,469 --> 00:39:07,479
fortunately they are not very difficult

831
00:39:04,390 --> 00:39:10,118
to bypass besides we can find that the

832
00:39:07,479 --> 00:39:13,089
comment is interesting it is to do

833
00:39:10,119 --> 00:39:17,680
comment to add the same check as new

834
00:39:13,089 --> 00:39:20,170
rename object store eventually we can

835
00:39:17,680 --> 00:39:22,209
modify the name at first I thought I

836
00:39:20,170 --> 00:39:24,729
could do arbitrary address right through

837
00:39:22,209 --> 00:39:27,430
the strings character array but I found

838
00:39:24,729 --> 00:39:29,499
out that rename was Dumba's to remove we

839
00:39:27,430 --> 00:39:31,749
should cost the original character array

840
00:39:29,499 --> 00:39:34,209
to be freed and then replaced with a new

841
00:39:31,749 --> 00:39:36,009
one let's take a look at this stream

842
00:39:34,209 --> 00:39:38,680
there are two different forms of stream

843
00:39:36,009 --> 00:39:41,829
if the string length is greater than 24

844
00:39:38,680 --> 00:39:45,249
bytes it will use an external buffer to

845
00:39:41,829 --> 00:39:47,650
store its data and as t remove will

846
00:39:45,249 --> 00:39:51,488
freed the external buffer and are

847
00:39:47,650 --> 00:39:54,549
replaced by a new one well if the string

848
00:39:51,489 --> 00:39:59,680
length is less than 24 bytes it will

849
00:39:54,549 --> 00:40:02,320
inline the data and in this situation

850
00:39:59,680 --> 00:40:04,419
even with SD move it will see if we will

851
00:40:02,320 --> 00:40:06,820
rest on the control the data through the

852
00:40:04,420 --> 00:40:09,340
original place remember that we only

853
00:40:06,820 --> 00:40:11,050
need eight pads right so it is enough

854
00:40:09,340 --> 00:40:13,410
for us to can show the pointer of the

855
00:40:11,050 --> 00:40:13,410
command line

856
00:40:15,750 --> 00:40:21,370
that's the diagram of the objects notice

857
00:40:19,510 --> 00:40:23,590
that everything in the graph is

858
00:40:21,370 --> 00:40:28,630
controlled by us and we can modify the

859
00:40:23,590 --> 00:40:31,270
index name through a PC because

860
00:40:28,630 --> 00:40:35,020
everything is in control we can set the

861
00:40:31,270 --> 00:40:37,750
index metadata to the address of global

862
00:40:35,020 --> 00:40:41,470
command line pointer which is in BSS

863
00:40:37,750 --> 00:40:43,330
segment at the beginning the pointer

864
00:40:41,470 --> 00:40:47,250
points to the original command line

865
00:40:43,330 --> 00:40:50,380
which we cannot control and then we use

866
00:40:47,250 --> 00:40:55,200
rename index to change the pointer and

867
00:40:50,380 --> 00:40:55,200
point to our fixed command line object

868
00:40:55,440 --> 00:41:01,630
so now we can control the command line

869
00:40:58,000 --> 00:41:04,510
of the browser and here is the version

870
00:41:01,630 --> 00:41:06,750
in JavaScript and surprisingly I found I

871
00:41:04,510 --> 00:41:09,790
was able to put everything in one blob

872
00:41:06,750 --> 00:41:12,250
actually there are more obstacles and

873
00:41:09,790 --> 00:41:14,050
difficulties during the exploitation but

874
00:41:12,250 --> 00:41:18,250
because of the time I cannot share them

875
00:41:14,050 --> 00:41:31,240
all so at the end of our talk let's see

876
00:41:18,250 --> 00:41:34,860
the demo here is official official build

877
00:41:31,240 --> 00:41:38,439
of Chrome and then we visit our website

878
00:41:34,860 --> 00:41:43,120
the first part is v8 exploit and it will

879
00:41:38,440 --> 00:41:45,940
be very quick and the v8 exploit will

880
00:41:43,120 --> 00:41:48,930
patch the renderer process so that we

881
00:41:45,940 --> 00:41:51,550
can call the IPC functions directly and

882
00:41:48,930 --> 00:41:59,430
remember that we have to spray thousand

883
00:41:51,550 --> 00:42:04,030
of drops so it might take some time and

884
00:41:59,430 --> 00:42:06,759
in the in the last stage we open a new

885
00:42:04,030 --> 00:42:12,570
render process by the a frame in browser

886
00:42:06,760 --> 00:42:12,570
and let's check the task list

887
00:42:18,750 --> 00:42:26,710
now we can see that we successfully

888
00:42:22,680 --> 00:42:29,109
prepared our command to the child

889
00:42:26,710 --> 00:42:32,020
process of Chrome and it will download

890
00:42:29,110 --> 00:42:39,100
the batch script from our server and

891
00:42:32,020 --> 00:42:40,750
execute it so that is all for my

892
00:42:39,100 --> 00:42:41,440
presentation thank you for your

893
00:42:40,750 --> 00:42:47,699
attention

894
00:42:41,440 --> 00:42:47,699
[Applause]

