1
00:00:00,030 --> 00:00:03,809
good morning welcome to processing

2
00:00:02,220 --> 00:00:07,890
detection techniques gotta catch them

3
00:00:03,810 --> 00:00:10,710
all in south CCDF with its cutler and

4
00:00:07,890 --> 00:00:12,840
amid climb before weekend I have a few

5
00:00:10,710 --> 00:00:14,820
brief notes stop by the business hall

6
00:00:12,840 --> 00:00:17,250
located in Manoa Bay Oceanside and

7
00:00:14,820 --> 00:00:19,289
shoreline ballrooms on level 2 during

8
00:00:17,250 --> 00:00:20,759
the day and for the Welcome Reception at

9
00:00:19,289 --> 00:00:22,890
5:30 p.m. tonight

10
00:00:20,760 --> 00:00:25,980
the blackhead arsenal is in the business

11
00:00:22,890 --> 00:00:29,519
hall on level 2 lunch will be served in

12
00:00:25,980 --> 00:00:31,830
Bayside a bee from 1 p.m. until 2:30

13
00:00:29,519 --> 00:00:33,899
p.m. don't forget to merchandise store

14
00:00:31,830 --> 00:00:35,640
on level 2 as well and thank you for

15
00:00:33,899 --> 00:00:41,640
putting your phones on vibrate we're

16
00:00:35,640 --> 00:00:43,469
ready to get started thank you Thank You

17
00:00:41,640 --> 00:00:46,230
Lena and welcome to our presentation

18
00:00:43,469 --> 00:00:49,320
about process injection techniques and

19
00:00:46,230 --> 00:00:52,860
we have itsy Cutler here and this is

20
00:00:49,320 --> 00:00:54,300
some words about it sick and my name is

21
00:00:52,860 --> 00:00:57,960
amit klein and you can read a bit about

22
00:00:54,300 --> 00:01:01,559
me there and we started researching

23
00:00:57,960 --> 00:01:05,280
process injection techniques back in

24
00:01:01,559 --> 00:01:07,530
late 2018 we wanted to explore this area

25
00:01:05,280 --> 00:01:09,570
and see if we can find a new techniques

26
00:01:07,530 --> 00:01:12,330
and something interesting to say about

27
00:01:09,570 --> 00:01:13,619
this and pretty much pretty soon we

28
00:01:12,330 --> 00:01:15,810
discovered that there is actually no

29
00:01:13,619 --> 00:01:17,280
comprehensive collection or catalog or

30
00:01:15,810 --> 00:01:19,259
compendium of process injection

31
00:01:17,280 --> 00:01:21,540
techniques moreover there was no

32
00:01:19,259 --> 00:01:24,450
separation of what we call a true

33
00:01:21,540 --> 00:01:28,049
process injection techniques from a more

34
00:01:24,450 --> 00:01:30,540
liberal approach taken by some authors

35
00:01:28,049 --> 00:01:33,750
to this term where in the lamp into

36
00:01:30,540 --> 00:01:35,450
process injection some related but not

37
00:01:33,750 --> 00:01:39,090
true process injection techniques like

38
00:01:35,450 --> 00:01:44,790
Halloween or spawning we did not find

39
00:01:39,090 --> 00:01:46,710
any categorization system for describing

40
00:01:44,790 --> 00:01:48,600
the differences between the sub

41
00:01:46,710 --> 00:01:50,908
techniques such as memory location

42
00:01:48,600 --> 00:01:53,280
memory writing and them and code

43
00:01:50,909 --> 00:01:54,840
execution there was no analysis in

44
00:01:53,280 --> 00:01:56,820
comparison between the various

45
00:01:54,840 --> 00:01:59,579
techniques out there and there was no

46
00:01:56,820 --> 00:02:01,589
update for Windows 10 as several

47
00:01:59,579 --> 00:02:04,770
techniques are pretty old from the back

48
00:02:01,590 --> 00:02:06,329
from the Windows XP days and the 32-bit

49
00:02:04,770 --> 00:02:08,489
architecture and it was not clear to us

50
00:02:06,329 --> 00:02:10,160
whether they can be ported as is to

51
00:02:08,489 --> 00:02:14,970
Windows 10 with its new security

52
00:02:10,160 --> 00:02:18,640
mechanisms and their 64-bit architecture

53
00:02:14,970 --> 00:02:20,980
before we proceed let me do some kudos

54
00:02:18,640 --> 00:02:22,929
and give some kudos to the individuals

55
00:02:20,980 --> 00:02:24,819
and companies for inventing and

56
00:02:22,930 --> 00:02:26,650
developing documenting and puttin and

57
00:02:24,819 --> 00:02:29,829
providing proof of concept to many many

58
00:02:26,650 --> 00:02:33,610
process injection techniques among them

59
00:02:29,830 --> 00:02:36,640
are atom of hexa corn or John the people

60
00:02:33,610 --> 00:02:38,440
at the in silo and except it's also

61
00:02:36,640 --> 00:02:40,420
known as the evil bit in there of course

62
00:02:38,440 --> 00:02:43,959
many many more authors and contributors

63
00:02:40,420 --> 00:02:45,609
and of course head tipped to endgame for

64
00:02:43,959 --> 00:02:47,440
providing the first compilation of

65
00:02:45,610 --> 00:02:49,239
injection techniques although not all of

66
00:02:47,440 --> 00:02:53,319
them were true process injection

67
00:02:49,239 --> 00:02:56,370
techniques so how do we how do we define

68
00:02:53,319 --> 00:02:58,958
true true process injection its

69
00:02:56,370 --> 00:03:00,700
injecting code or logic from one live

70
00:02:58,959 --> 00:03:03,430
user space process which is typically

71
00:03:00,700 --> 00:03:05,048
malware to another live user space

72
00:03:03,430 --> 00:03:07,269
process which the target of the

73
00:03:05,049 --> 00:03:10,720
injection which is typically a benign or

74
00:03:07,269 --> 00:03:13,180
a legitimate process this is in contrast

75
00:03:10,720 --> 00:03:15,879
off and contrast to a process spawning

76
00:03:13,180 --> 00:03:17,650
and hollowing also some other pre

77
00:03:15,879 --> 00:03:21,399
execution techniques like DLL hijacking

78
00:03:17,650 --> 00:03:25,180
a a PP cert a PP need less people riders

79
00:03:21,400 --> 00:03:27,910
image file execution options etc what's

80
00:03:25,180 --> 00:03:29,200
so interesting about Windows 10 and 60

81
00:03:27,910 --> 00:03:31,079
64-bit architecture

82
00:03:29,200 --> 00:03:34,388
well in Windows 10 there were several

83
00:03:31,079 --> 00:03:38,769
new security mechanisms introduced to

84
00:03:34,389 --> 00:03:41,139
mitigate remote process exploitation but

85
00:03:38,769 --> 00:03:43,840
they also have a significant impact on

86
00:03:41,139 --> 00:03:46,569
process injection on local process

87
00:03:43,840 --> 00:03:48,880
injection specifically safety control

88
00:03:46,569 --> 00:03:51,910
flow guard prevents indirect calls to

89
00:03:48,880 --> 00:03:54,250
non improved addresses and the c IG the

90
00:03:51,910 --> 00:03:57,010
code integrity guard only allows modules

91
00:03:54,250 --> 00:03:59,650
or DLL signed by Microsoft or Microsoft

92
00:03:57,010 --> 00:04:01,450
or W hql to be loaded into the process

93
00:03:59,650 --> 00:04:04,900
memory and they we will explain exactly

94
00:04:01,450 --> 00:04:08,768
how this effects process injection the

95
00:04:04,900 --> 00:04:11,859
x64 architecture as opposed to x86

96
00:04:08,769 --> 00:04:13,540
32-bit architecture has a different

97
00:04:11,859 --> 00:04:16,418
column convention where in the first

98
00:04:13,540 --> 00:04:18,728
four arguments are stored in volatile

99
00:04:16,418 --> 00:04:21,130
registers r6 RDX r8 and r9

100
00:04:18,728 --> 00:04:24,900
so in invoking functions for example

101
00:04:21,130 --> 00:04:26,060
from Rob gadget or from other mechanisms

102
00:04:24,900 --> 00:04:28,039
necessitate

103
00:04:26,060 --> 00:04:30,110
control over some or all these registers

104
00:04:28,040 --> 00:04:33,470
which is sometimes hard to come by

105
00:04:30,110 --> 00:04:36,650
also in x64 there is no pop or registers

106
00:04:33,470 --> 00:04:39,290
so this makes it difficult to populate

107
00:04:36,650 --> 00:04:43,549
registered with desired values in rock

108
00:04:39,290 --> 00:04:45,800
gadgets and so forth we found a lot of

109
00:04:43,550 --> 00:04:47,930
proof of concepts for project process

110
00:04:45,800 --> 00:04:50,510
injection out there they were excellent

111
00:04:47,930 --> 00:04:53,780
proof of concepts in the sense that they

112
00:04:50,510 --> 00:04:57,380
were not not just good proof of concepts

113
00:04:53,780 --> 00:04:59,119
they were excellent ones and because

114
00:04:57,380 --> 00:05:01,669
they were excellent ones because they

115
00:04:59,120 --> 00:05:04,669
checked for error conditions and

116
00:05:01,669 --> 00:05:07,039
exceptions they handled both 32-bit

117
00:05:04,669 --> 00:05:09,250
architecture and 64-bit architecture in

118
00:05:07,040 --> 00:05:12,260
fact when they wanted to demonstrate a

119
00:05:09,250 --> 00:05:14,660
specific say memorizing technique they

120
00:05:12,260 --> 00:05:16,880
coupled with some execution technique to

121
00:05:14,660 --> 00:05:19,630
provide an end-to-end process injection

122
00:05:16,880 --> 00:05:23,570
demonstration including in this case a

123
00:05:19,630 --> 00:05:26,300
an arbitrary executing arbitrary code a

124
00:05:23,570 --> 00:05:28,610
user chosen arbitrary code this made a

125
00:05:26,300 --> 00:05:30,800
proof of concept pretty large in this

126
00:05:28,610 --> 00:05:33,740
case if you can read it it's a fifteen

127
00:05:30,800 --> 00:05:35,900
hundred lines of code and for a

128
00:05:33,740 --> 00:05:37,700
researcher to try to figure out what

129
00:05:35,900 --> 00:05:39,859
exactly is the innovation here where

130
00:05:37,700 --> 00:05:42,169
what is the essence of the technique it

131
00:05:39,860 --> 00:05:44,270
becomes very difficult as opposed to

132
00:05:42,169 --> 00:05:45,770
what we would what we had in mind is

133
00:05:44,270 --> 00:05:47,330
something like the right hand side where

134
00:05:45,770 --> 00:05:49,909
I knew there are five there are three

135
00:05:47,330 --> 00:05:52,450
lines actually they show up as 5 because

136
00:05:49,910 --> 00:05:54,979
the we have a word wrapping here

137
00:05:52,450 --> 00:05:57,950
detailing the exact writing technique

138
00:05:54,979 --> 00:05:59,960
and that's what we were missing

139
00:05:57,950 --> 00:06:04,820
in the proof of concept or the

140
00:05:59,960 --> 00:06:06,680
discussions that that existed to date so

141
00:06:04,820 --> 00:06:08,930
the scope of our research is therefore

142
00:06:06,680 --> 00:06:10,640
true process injection running a

143
00:06:08,930 --> 00:06:13,039
sequence of logical commands in the

144
00:06:10,640 --> 00:06:14,870
target process as opposed to making that

145
00:06:13,039 --> 00:06:18,289
target process spawn another process

146
00:06:14,870 --> 00:06:21,850
which is far less interesting recent

147
00:06:18,289 --> 00:06:25,070
Windows 10 less a version 1803 and above

148
00:06:21,850 --> 00:06:27,800
64-bit in injecting process 64-bit

149
00:06:25,070 --> 00:06:30,349
target process both medium integrity non

150
00:06:27,800 --> 00:06:34,520
no requirement for administrative rights

151
00:06:30,350 --> 00:06:36,080
and we wanted to in value 8 the process

152
00:06:34,520 --> 00:06:38,919
injection techniques against Windows 10

153
00:06:36,080 --> 00:06:42,169
protection specifically CFG in CAG

154
00:06:38,919 --> 00:06:44,000
with respect to CFG what we had in mind

155
00:06:42,169 --> 00:06:46,669
or what we discovered that there are two

156
00:06:44,000 --> 00:06:49,639
the three story strategies for handling

157
00:06:46,669 --> 00:06:51,620
CFG either the attacker the malware

158
00:06:49,639 --> 00:06:53,090
disable CFG in the target process which

159
00:06:51,620 --> 00:06:55,240
is possible through a standard windows

160
00:06:53,090 --> 00:06:57,440
api set process valid hole targets

161
00:06:55,240 --> 00:07:00,169
however if you think about it this

162
00:06:57,440 --> 00:07:03,139
invocation is in itself quite suspicious

163
00:07:00,169 --> 00:07:05,750
for one process to inflict on another

164
00:07:03,139 --> 00:07:07,580
and also it may be disabled or

165
00:07:05,750 --> 00:07:09,919
restricted in the future by Microsoft

166
00:07:07,580 --> 00:07:13,940
because it because it may be too potent

167
00:07:09,919 --> 00:07:18,080
and then we can do we can allocate or

168
00:07:13,940 --> 00:07:21,500
set the executable memory thereby making

169
00:07:18,080 --> 00:07:24,469
all the location CFG valid this is an

170
00:07:21,500 --> 00:07:27,680
using virtual okie X virtual protecta X

171
00:07:24,470 --> 00:07:30,800
and others however what we have here is

172
00:07:27,680 --> 00:07:32,810
one process allocating executable pages

173
00:07:30,800 --> 00:07:34,220
in another process and we all understand

174
00:07:32,810 --> 00:07:37,220
what's going to happen next so this is

175
00:07:34,220 --> 00:07:38,690
extremely suspicious activity so an

176
00:07:37,220 --> 00:07:39,470
attacker probably wants to avoid that

177
00:07:38,690 --> 00:07:41,060
one as well

178
00:07:39,470 --> 00:07:44,000
which leaves us with the third option

179
00:07:41,060 --> 00:07:45,770
which is the most difficult and most in

180
00:07:44,000 --> 00:07:47,570
hardest to come by and therefore most

181
00:07:45,770 --> 00:07:49,909
interesting which is playing by the

182
00:07:47,570 --> 00:07:52,479
rules so what we what attacker needs to

183
00:07:49,910 --> 00:07:55,580
do is write in non-executable data's is

184
00:07:52,479 --> 00:07:58,219
typically a rope chain and then use some

185
00:07:55,580 --> 00:08:00,349
CFG agnostic execution method to run a

186
00:07:58,220 --> 00:08:03,440
stack Peapod and start executing the

187
00:08:00,349 --> 00:08:05,990
Rope gadget and that the emphasis is on

188
00:08:03,440 --> 00:08:08,860
CFG agnostic execution method which is

189
00:08:05,990 --> 00:08:13,000
the rare man or minority of the

190
00:08:08,860 --> 00:08:13,000
execution methods as we'll see later

191
00:08:13,060 --> 00:08:19,370
regarding other defenses including CI G

192
00:08:16,270 --> 00:08:22,099
they could be turned off by used by

193
00:08:19,370 --> 00:08:24,320
invoking locally set process mitigation

194
00:08:22,099 --> 00:08:26,120
policy which takes three arguments and

195
00:08:24,320 --> 00:08:28,159
therefore could be used with empty queue

196
00:08:26,120 --> 00:08:31,160
a PC thread to execute at the target

197
00:08:28,160 --> 00:08:35,060
process however this as of 1809 does not

198
00:08:31,160 --> 00:08:36,890
work among those protection mechanisms

199
00:08:35,059 --> 00:08:38,569
CAG is the most painful for process

200
00:08:36,890 --> 00:08:42,620
injection because it prevents loading of

201
00:08:38,570 --> 00:08:45,170
arbitrary dll's so what are the typical

202
00:08:42,620 --> 00:08:47,959
process injection building blocks we

203
00:08:45,170 --> 00:08:49,939
have memory allocation which may be

204
00:08:47,959 --> 00:08:51,109
implicit if we use a code cave or stack

205
00:08:49,940 --> 00:08:53,750
or or or

206
00:08:51,110 --> 00:08:56,329
Hiep location we need to consider page

207
00:08:53,750 --> 00:08:59,750
permission issues is it can we allocate

208
00:08:56,329 --> 00:09:02,000
executable pages or not what control we

209
00:08:59,750 --> 00:09:05,300
have over the location address and

210
00:09:02,000 --> 00:09:07,130
whether the addresses are CFG valid then

211
00:09:05,300 --> 00:09:09,500
we need to write something useful into

212
00:09:07,130 --> 00:09:11,000
that memory and the question who when

213
00:09:09,500 --> 00:09:12,860
and with memory writing technique the

214
00:09:11,000 --> 00:09:14,630
questions are what what we can write can

215
00:09:12,860 --> 00:09:16,430
we write arbitrary data or is it

216
00:09:14,630 --> 00:09:19,000
restricted in size when character set

217
00:09:16,430 --> 00:09:21,109
and whether the right is atomic or not

218
00:09:19,000 --> 00:09:23,240
finally there's the execution third

219
00:09:21,110 --> 00:09:25,820
technique and the questions are whether

220
00:09:23,240 --> 00:09:27,920
the target has to be a CFG valid address

221
00:09:25,820 --> 00:09:29,630
what control do we have over the

222
00:09:27,920 --> 00:09:31,130
registers and what limitations or

223
00:09:29,630 --> 00:09:33,589
prerequisites there are for this

224
00:09:31,130 --> 00:09:36,370
execution technique and there are a lot

225
00:09:33,589 --> 00:09:40,250
of techniques that are quite restricted

226
00:09:36,370 --> 00:09:42,140
so without much ado let's go over to

227
00:09:40,250 --> 00:09:45,500
process injection techniques I'm going

228
00:09:42,140 --> 00:09:47,390
to describe some interesting some known

229
00:09:45,500 --> 00:09:47,899
and then some interesting and

230
00:09:47,390 --> 00:09:50,300
lesser-known

231
00:09:47,899 --> 00:09:52,700
techniques and and try to and try to

232
00:09:50,300 --> 00:09:56,000
analyze and and provide some insights

233
00:09:52,700 --> 00:09:58,670
about them so we start with the classic

234
00:09:56,000 --> 00:10:00,589
memory allocation technique in which we

235
00:09:58,670 --> 00:10:03,769
allocate a memory in the target process

236
00:10:00,589 --> 00:10:05,839
using virtual Allah key X as we and as

237
00:10:03,769 --> 00:10:07,790
we all know we can allocate executable

238
00:10:05,839 --> 00:10:11,480
pages by simply by requesting the page

239
00:10:07,790 --> 00:10:13,399
execute property fled and for such

240
00:10:11,480 --> 00:10:15,470
executable pages windows conveniently

241
00:10:13,399 --> 00:10:18,829
automatically sets all the region to be

242
00:10:15,470 --> 00:10:20,810
CFG valid comes in very handy as a

243
00:10:18,829 --> 00:10:22,489
variant we can allocate only read write

244
00:10:20,810 --> 00:10:25,518
pages and then add the execution

245
00:10:22,490 --> 00:10:27,470
executable flag using virtual protecta X

246
00:10:25,519 --> 00:10:29,029
in that case as well windows

247
00:10:27,470 --> 00:10:31,910
automatically sets all the region to be

248
00:10:29,029 --> 00:10:33,500
safety aware and then we have the

249
00:10:31,910 --> 00:10:37,130
classic write process memory memory

250
00:10:33,500 --> 00:10:38,540
writing technique you will Freud process

251
00:10:37,130 --> 00:10:40,370
memory there are no restrictions and no

252
00:10:38,540 --> 00:10:43,670
limitations address is fully controlled

253
00:10:40,370 --> 00:10:45,589
by us and if g if the allocation is sets

254
00:10:43,670 --> 00:10:47,719
the execution privileges then all we

255
00:10:45,589 --> 00:10:49,730
know already that all the region is CFG

256
00:10:47,720 --> 00:10:52,279
evaluators so which makes us very happy

257
00:10:49,730 --> 00:10:54,860
and cg has no impact because we are not

258
00:10:52,279 --> 00:10:56,959
talking about DLL 0 and finally does the

259
00:10:54,860 --> 00:10:59,029
classic execution technique using

260
00:10:56,959 --> 00:10:59,959
creative mode thread has no

261
00:10:59,029 --> 00:11:03,560
prerequisites

262
00:10:59,959 --> 00:11:04,959
no impact for C ig4 for safety the

263
00:11:03,560 --> 00:11:07,449
target execution

264
00:11:04,960 --> 00:11:09,910
be a valid CFG target meaning windows

265
00:11:07,450 --> 00:11:12,010
will check at the remote process if the

266
00:11:09,910 --> 00:11:15,160
address is CFG valid and if it's not it

267
00:11:12,010 --> 00:11:17,410
will crash and as for registers we'll

268
00:11:15,160 --> 00:11:19,779
only control a single register or six so

269
00:11:17,410 --> 00:11:26,020
whatever we invoke here has to take up

270
00:11:19,779 --> 00:11:28,600
to one argument we also have classic DLL

271
00:11:26,020 --> 00:11:30,670
injection execution techniques one of

272
00:11:28,600 --> 00:11:33,670
them would be using create remote thread

273
00:11:30,670 --> 00:11:37,740
again assuming that we already have the

274
00:11:33,670 --> 00:11:41,979
DLL pass in memory using one of their

275
00:11:37,740 --> 00:11:43,899
using a writing technique then you we

276
00:11:41,980 --> 00:11:47,050
can invoke create a MOSFET that invokes

277
00:11:43,899 --> 00:11:49,600
load library a with the single argument

278
00:11:47,050 --> 00:11:53,349
being a pointer to this to the memory

279
00:11:49,600 --> 00:11:54,970
that we filled with the DLL path as a

280
00:11:53,350 --> 00:11:57,700
pro the prerequisites are pretty obvious

281
00:11:54,970 --> 00:11:59,410
the DLL should be on this we should we

282
00:11:57,700 --> 00:12:01,000
need to have a writing technique to

283
00:11:59,410 --> 00:12:03,730
write the DLL path to the target process

284
00:12:01,000 --> 00:12:06,399
interestingly the execution occurs

285
00:12:03,730 --> 00:12:10,150
because the loader law the loader runs

286
00:12:06,399 --> 00:12:13,600
DLL main during the deal during loading

287
00:12:10,150 --> 00:12:16,779
the loading of the DLL and this DLL main

288
00:12:13,600 --> 00:12:19,330
function is restricted because it's

289
00:12:16,779 --> 00:12:21,610
executed under the loader lock so there

290
00:12:19,330 --> 00:12:24,400
are several restrictions away there's a

291
00:12:21,610 --> 00:12:26,529
URL now paper show that provides

292
00:12:24,400 --> 00:12:29,319
information from Microsoft what those

293
00:12:26,529 --> 00:12:32,080
restrictions are nevertheless it's still

294
00:12:29,320 --> 00:12:35,200
very useful as if G has no impact on

295
00:12:32,080 --> 00:12:38,709
this technique because the load library

296
00:12:35,200 --> 00:12:41,680
a is obviously as if G valid address in

297
00:12:38,709 --> 00:12:43,420
the target process however CAG will

298
00:12:41,680 --> 00:12:45,430
block this technique assuming that this

299
00:12:43,420 --> 00:12:47,349
DLL is not signed by Microsoft and

300
00:12:45,430 --> 00:12:50,739
unless you have the Microsoft code

301
00:12:47,350 --> 00:12:53,380
signing key the CAG will block this this

302
00:12:50,740 --> 00:12:55,660
execution method I want to note that

303
00:12:53,380 --> 00:12:57,670
this variant can there are variants

304
00:12:55,660 --> 00:13:00,969
using queue user ABC and empty queue a

305
00:12:57,670 --> 00:13:04,420
piece is coming which end up with the

306
00:13:00,970 --> 00:13:06,910
same conditions more or less another

307
00:13:04,420 --> 00:13:10,180
classic DLL injection technique is using

308
00:13:06,910 --> 00:13:12,790
set windows hook X in which case the

309
00:13:10,180 --> 00:13:16,180
idea here is that this deal that we put

310
00:13:12,790 --> 00:13:16,709
our provides windows with a dll to be

311
00:13:16,180 --> 00:13:21,000
loaded

312
00:13:16,710 --> 00:13:24,500
whenever a specific event is triggered

313
00:13:21,000 --> 00:13:27,450
in the in the target process and

314
00:13:24,500 --> 00:13:30,360
following this set windows hook acts we

315
00:13:27,450 --> 00:13:33,630
trigger we artificially trigger this

316
00:13:30,360 --> 00:13:37,589
condition this this event in the target

317
00:13:33,630 --> 00:13:40,770
thread and so that it forces loading our

318
00:13:37,589 --> 00:13:43,080
DLL executing the event handler function

319
00:13:40,770 --> 00:13:45,060
in this DLL of course the prerequisite

320
00:13:43,080 --> 00:13:47,339
is that there's the little disk and it

321
00:13:45,060 --> 00:13:49,109
exports a required function which is

322
00:13:47,339 --> 00:13:51,420
obviously under the attackers control no

323
00:13:49,110 --> 00:13:55,589
problems there and again see IG will

324
00:13:51,420 --> 00:13:58,020
block this technique we are moving to

325
00:13:55,589 --> 00:14:01,230
the classic ADC execution technique

326
00:13:58,020 --> 00:14:03,689
which uses q user if you see the windows

327
00:14:01,230 --> 00:14:06,959
API standard function or the internal

328
00:14:03,690 --> 00:14:10,320
function NT q a PC thread which is more

329
00:14:06,959 --> 00:14:12,180
flexible the prerequisites here starts

330
00:14:10,320 --> 00:14:14,550
to be start becoming interesting because

331
00:14:12,180 --> 00:14:16,380
we here we acquire that the thread must

332
00:14:14,550 --> 00:14:19,020
be in an alert able state and I'll

333
00:14:16,380 --> 00:14:20,970
explain this that in the next slide and

334
00:14:19,020 --> 00:14:23,520
Sergey has of course no impact and the

335
00:14:20,970 --> 00:14:26,910
CNC FG requires that the target

336
00:14:23,520 --> 00:14:28,770
execution be a valid CFG target as for

337
00:14:26,910 --> 00:14:30,839
registers you can see that in Q user a

338
00:14:28,770 --> 00:14:32,579
PC will only control our six one

339
00:14:30,839 --> 00:14:35,850
register one one argument function

340
00:14:32,580 --> 00:14:37,980
whereas in NT qu q a PC thread will

341
00:14:35,850 --> 00:14:41,100
control our six RDX and the lower half

342
00:14:37,980 --> 00:14:47,400
of our eight so we have control over two

343
00:14:41,100 --> 00:14:49,410
and a half registers so what is is a lot

344
00:14:47,400 --> 00:14:51,510
about what does it mean for a third to

345
00:14:49,410 --> 00:14:53,670
be in a logical state well taking it

346
00:14:51,510 --> 00:14:56,010
straight for Microsoft documentation it

347
00:14:53,670 --> 00:15:00,209
means that the thread is inside one of

348
00:14:56,010 --> 00:15:03,240
the is running is a this is not just an

349
00:15:00,209 --> 00:15:05,880
idling in one of the five next functions

350
00:15:03,240 --> 00:15:08,430
sleepy X wait for single object X wait

351
00:15:05,880 --> 00:15:11,339
for multiple objects its signal object

352
00:15:08,430 --> 00:15:15,270
and wait and real MSG wait for multiple

353
00:15:11,339 --> 00:15:17,100
objects X and actually for a complex

354
00:15:15,270 --> 00:15:18,649
enough software like office software

355
00:15:17,100 --> 00:15:22,079
Explorer

356
00:15:18,649 --> 00:15:24,900
browsers it's quite common to find at

357
00:15:22,079 --> 00:15:27,150
least one thread in an alert about state

358
00:15:24,900 --> 00:15:28,829
if you think about it and any thread

359
00:15:27,150 --> 00:15:30,069
that waits for an object wait for a

360
00:15:28,829 --> 00:15:33,069
signal and

361
00:15:30,070 --> 00:15:35,080
actually is in an alert about state and

362
00:15:33,070 --> 00:15:37,060
also of importance here and I don't

363
00:15:35,080 --> 00:15:39,010
think that this is a documented

364
00:15:37,060 --> 00:15:41,469
elsewhere is that it's quite easy to

365
00:15:39,010 --> 00:15:43,360
detect this alert about that the third

366
00:15:41,470 --> 00:15:45,190
is in an in an alert about state because

367
00:15:43,360 --> 00:15:49,660
all those internal functions in which

368
00:15:45,190 --> 00:15:55,780
the thread is actually parking it will

369
00:15:49,660 --> 00:15:58,270
be at the function entry plus hex 40

370
00:15:55,780 --> 00:16:00,939
which is right which is the our IP right

371
00:15:58,270 --> 00:16:03,640
after the Cisco all those five internal

372
00:16:00,940 --> 00:16:07,000
functions share the same structure and

373
00:16:03,640 --> 00:16:10,330
it's always a Cisco and at the end of

374
00:16:07,000 --> 00:16:14,590
the Cisco it's a hex 14 so if you see

375
00:16:10,330 --> 00:16:17,110
the RFP for thread in in sleepy XA plus

376
00:16:14,590 --> 00:16:19,450
say a hex 14 or in signal object and

377
00:16:17,110 --> 00:16:21,160
white plus hex 14 it means that the

378
00:16:19,450 --> 00:16:22,750
thread is in an alert about state

379
00:16:21,160 --> 00:16:32,670
otherwise it is not in an ineligible

380
00:16:22,750 --> 00:16:35,680
state moving to the yeah so that was the

381
00:16:32,670 --> 00:16:37,810
APC style execution and now moving to a

382
00:16:35,680 --> 00:16:41,229
classic thread hijacking execution

383
00:16:37,810 --> 00:16:45,119
technique suspend inject and resume as

384
00:16:41,230 --> 00:16:47,890
IR for short again the naive

385
00:16:45,120 --> 00:16:51,150
representation of this attack is opening

386
00:16:47,890 --> 00:16:55,330
the thread suspending the thread and

387
00:16:51,150 --> 00:16:59,350
then using set thread context with with

388
00:16:55,330 --> 00:17:01,390
our IP pointing at our desired location

389
00:16:59,350 --> 00:17:03,880
and resume thread and the third of the

390
00:17:01,390 --> 00:17:07,170
zoom with the our IP in our desired

391
00:17:03,880 --> 00:17:10,480
location and start executing our code

392
00:17:07,170 --> 00:17:13,420
now there are no prerequisites actually

393
00:17:10,480 --> 00:17:14,970
to this technique CFG surprisingly

394
00:17:13,420 --> 00:17:18,100
enough has no impact

395
00:17:14,970 --> 00:17:21,490
except for RSP which is restricted to

396
00:17:18,099 --> 00:17:24,030
the if we choose to change the RSP value

397
00:17:21,490 --> 00:17:26,650
it has to remain within the stack region

398
00:17:24,030 --> 00:17:30,220
as for control of registers here's a

399
00:17:26,650 --> 00:17:34,240
puzzle in some processes we could exert

400
00:17:30,220 --> 00:17:36,820
control over all registers using set

401
00:17:34,240 --> 00:17:39,610
thread context in other processes more

402
00:17:36,820 --> 00:17:42,250
interesting processes I admit we could

403
00:17:39,610 --> 00:17:43,779
not modify we could not control the

404
00:17:42,250 --> 00:17:46,029
volatile registers RA

405
00:17:43,779 --> 00:17:49,239
our six our X and our eight to our 11

406
00:17:46,029 --> 00:17:53,649
the reason why something some processes

407
00:17:49,239 --> 00:17:55,599
are more controllable and some are less

408
00:17:53,649 --> 00:17:58,539
control is somewhat of a puzzle to me

409
00:17:55,599 --> 00:18:01,830
and probably requires more research or

410
00:17:58,539 --> 00:18:04,779
maybe there's something I'm missing

411
00:18:01,830 --> 00:18:06,399
at any rate our assumption is that we

412
00:18:04,779 --> 00:18:08,139
have no control over the volatile

413
00:18:06,399 --> 00:18:10,059
registers and as I mentioned earlier

414
00:18:08,139 --> 00:18:14,289
control over RSP is limited to stock

415
00:18:10,059 --> 00:18:16,928
reservation if our - if we do not have

416
00:18:14,289 --> 00:18:19,479
the ability to write executable code

417
00:18:16,929 --> 00:18:24,820
pages into the target process we can use

418
00:18:19,479 --> 00:18:27,940
we can use data there as rob chain in

419
00:18:24,820 --> 00:18:30,519
which case we set the are IP of the

420
00:18:27,940 --> 00:18:33,099
thread to a stack pivot gadget to set

421
00:18:30,519 --> 00:18:36,009
the RSP to the control memory and and

422
00:18:33,099 --> 00:18:39,129
the return command will start executing

423
00:18:36,009 --> 00:18:44,349
the rope chain instead of running a

424
00:18:39,129 --> 00:18:47,559
native code here's a less known but very

425
00:18:44,349 --> 00:18:48,939
impressive technique from I think 2007

426
00:18:47,559 --> 00:18:50,769
called ghost writing

427
00:18:48,940 --> 00:18:55,029
it's a monolithic technique in the sense

428
00:18:50,769 --> 00:18:57,519
that it provide it allows writing it

429
00:18:55,029 --> 00:18:59,649
combines writing and execution it

430
00:18:57,519 --> 00:19:03,190
similar to thread hijacking but it has

431
00:18:59,649 --> 00:19:05,309
the built-in memory writing part so

432
00:19:03,190 --> 00:19:09,659
memory writing is achieved in in steps

433
00:19:05,309 --> 00:19:11,979
in writing one key word in each step and

434
00:19:09,659 --> 00:19:13,950
using set thread context to set the

435
00:19:11,979 --> 00:19:17,349
registers and at the end of each step

436
00:19:13,950 --> 00:19:19,259
the thread is is locked in an infinite

437
00:19:17,349 --> 00:19:21,700
loop which is a success marker for us

438
00:19:19,259 --> 00:19:24,519
telling us we can move to the next step

439
00:19:21,700 --> 00:19:26,710
so the required Rob gadgets are we have

440
00:19:24,519 --> 00:19:31,409
a sink gadget this infinite loop as

441
00:19:26,710 --> 00:19:33,849
simple as a jump - - so it looks forever

442
00:19:31,409 --> 00:19:36,129
then we also have need to have a write

443
00:19:33,849 --> 00:19:37,718
budget something like move to the

444
00:19:36,129 --> 00:19:40,570
address in RDI

445
00:19:37,719 --> 00:19:42,519
the contents of our BX and do a return

446
00:19:40,570 --> 00:19:44,739
later and the stack we vote for

447
00:19:42,519 --> 00:19:47,879
something clever equivalent and the

448
00:19:44,739 --> 00:19:50,769
first step we just write the write the

449
00:19:47,879 --> 00:19:52,699
onto the stack the address of the

450
00:19:50,769 --> 00:19:55,549
infinite loop

451
00:19:52,700 --> 00:19:58,429
and return to that so the infinite loops

452
00:19:55,549 --> 00:20:03,379
are running once we detect that we again

453
00:19:58,429 --> 00:20:05,450
set the thread context to say to into

454
00:20:03,379 --> 00:20:08,238
writing arbitrary keywords using our di

455
00:20:05,450 --> 00:20:11,539
and our BX and setting our speed one

456
00:20:08,239 --> 00:20:14,840
step one step back so that when they

457
00:20:11,539 --> 00:20:17,359
write a write gadget we finish with

458
00:20:14,840 --> 00:20:22,459
return it will jump back to the infinite

459
00:20:17,359 --> 00:20:24,889
loop and once we have built the memory

460
00:20:22,460 --> 00:20:27,440
to our desire we can move to the

461
00:20:24,889 --> 00:20:32,418
execution by executing a stack without

462
00:20:27,440 --> 00:20:35,419
using sets read context again some tips

463
00:20:32,419 --> 00:20:38,149
about regarding unused stack as memory

464
00:20:35,419 --> 00:20:40,070
which we we can use in this technique as

465
00:20:38,149 --> 00:20:45,168
well in the stack bombing technique that

466
00:20:40,070 --> 00:20:47,119
will describe in a moment it's we can

467
00:20:45,169 --> 00:20:50,119
maintain we need to maintain distance

468
00:20:47,119 --> 00:20:52,369
from the official top of stack so in

469
00:20:50,119 --> 00:20:56,090
order to leave room for win API call

470
00:20:52,369 --> 00:20:59,629
stack meaning we need to allow the stack

471
00:20:56,090 --> 00:21:02,869
to grow a bit when some internal

472
00:20:59,629 --> 00:21:05,029
functions are invoked otherwise if we do

473
00:21:02,869 --> 00:21:08,980
not do that if we write if we use the

474
00:21:05,029 --> 00:21:13,309
stack right right behind TOS it will get

475
00:21:08,980 --> 00:21:16,039
mangled or wiped by invoking internal

476
00:21:13,309 --> 00:21:18,350
functions and so no good so needs to

477
00:21:16,039 --> 00:21:21,169
keep some distance we mean we can't go

478
00:21:18,350 --> 00:21:24,049
too far because the stack is limited to

479
00:21:21,169 --> 00:21:26,419
one megabyte typically and so in order

480
00:21:24,049 --> 00:21:29,059
to achieve those goals we need to grow

481
00:21:26,419 --> 00:21:33,049
the stack by touching memory page size

482
00:21:29,059 --> 00:21:37,668
intervals because if we if we do once we

483
00:21:33,049 --> 00:21:43,009
touch this if want to touch the a guard

484
00:21:37,669 --> 00:21:46,909
page the stack grows accordingly also in

485
00:21:43,009 --> 00:21:50,299
writing code use when writing code using

486
00:21:46,909 --> 00:21:54,619
this new stack location - the alignment

487
00:21:50,299 --> 00:21:56,899
required from stack which is 16 bytes so

488
00:21:54,619 --> 00:21:58,519
back to analyzing ghost writing the

489
00:21:56,899 --> 00:22:01,959
prerequisite is simply that we have

490
00:21:58,519 --> 00:22:05,110
writable memory as we can

491
00:22:01,960 --> 00:22:08,440
as as hinted before we can use the this

492
00:22:05,110 --> 00:22:11,110
unused the unused part of the stack and

493
00:22:08,440 --> 00:22:13,299
see if G has no impact except ours

494
00:22:11,110 --> 00:22:16,928
except for the restriction over RS be

495
00:22:13,299 --> 00:22:18,610
CAG obviously has no impact and we have

496
00:22:16,929 --> 00:22:21,159
for control over it it says there's no

497
00:22:18,610 --> 00:22:23,340
guaranteed control over Hotel registers

498
00:22:21,159 --> 00:22:30,399
as I mentioned before and as I said

499
00:22:23,340 --> 00:22:32,379
control over our space limited another

500
00:22:30,399 --> 00:22:35,370
interesting writing technique is

501
00:22:32,380 --> 00:22:39,460
assuming that there is a shared memory

502
00:22:35,370 --> 00:22:42,789
section in the target process in such

503
00:22:39,460 --> 00:22:47,799
case assuming that we know this shared

504
00:22:42,789 --> 00:22:50,049
memory name assured now section name and

505
00:22:47,799 --> 00:22:52,840
size which could we can easily find out

506
00:22:50,049 --> 00:22:55,000
assuming back at home assuming that we

507
00:22:52,840 --> 00:22:57,340
know which software we target and which

508
00:22:55,000 --> 00:23:01,659
build it is these things don't change a

509
00:22:57,340 --> 00:23:02,918
lot with we open this shared memory map

510
00:23:01,659 --> 00:23:05,830
this shared memory to the malware

511
00:23:02,919 --> 00:23:09,520
process we write our payload at the end

512
00:23:05,830 --> 00:23:12,730
of this shared memory section and

513
00:23:09,520 --> 00:23:14,639
finally we we search we opened up the

514
00:23:12,730 --> 00:23:17,649
target process and we search for

515
00:23:14,640 --> 00:23:20,710
sections that are for memory regions

516
00:23:17,649 --> 00:23:23,889
that have the same properties as the

517
00:23:20,710 --> 00:23:28,480
shared memory in terms of size and in

518
00:23:23,890 --> 00:23:31,390
flags and if once we find that we all we

519
00:23:28,480 --> 00:23:33,909
read the last bytes of those of that

520
00:23:31,390 --> 00:23:35,799
shipment of that memory area in the

521
00:23:33,909 --> 00:23:38,890
target process we compare it to our

522
00:23:35,799 --> 00:23:41,918
payload and if it's indeed they shared

523
00:23:38,890 --> 00:23:44,590
memory region then our then this then

524
00:23:41,919 --> 00:23:46,720
we'll find a match and we will what we

525
00:23:44,590 --> 00:23:49,240
have at hand at this moment is our

526
00:23:46,720 --> 00:23:51,370
payload at a known location at a known

527
00:23:49,240 --> 00:23:53,320
address in the target process and then

528
00:23:51,370 --> 00:23:57,039
we can proceed to do whatever you like

529
00:23:53,320 --> 00:23:58,870
with this with this data so the

530
00:23:57,039 --> 00:24:01,120
prerequisites are obviously the target

531
00:23:58,870 --> 00:24:03,100
process has readwrite shared memory that

532
00:24:01,120 --> 00:24:07,178
a conductor attacker knows this name the

533
00:24:03,100 --> 00:24:09,428
name and size of this session memory CFG

534
00:24:07,179 --> 00:24:11,889
is not interesting this is right a

535
00:24:09,429 --> 00:24:13,360
memory writing technique and CAG has no

536
00:24:11,889 --> 00:24:15,270
impact we're not dealing with the LS

537
00:24:13,360 --> 00:24:18,370
here

538
00:24:15,270 --> 00:24:22,480
moving to the atom bombing writing

539
00:24:18,370 --> 00:24:25,239
technique so as I as we saw earlier the

540
00:24:22,480 --> 00:24:27,450
full proof of concept in 1500 lines of

541
00:24:25,240 --> 00:24:32,860
code but the essence of the technique

542
00:24:27,450 --> 00:24:35,680
assuming some simplifications here like

543
00:24:32,860 --> 00:24:38,620
we let's say the payload length is is

544
00:24:35,680 --> 00:24:40,540
smaller than 256 bytes and assuming that

545
00:24:38,620 --> 00:24:43,149
there are no Nullah bytes in the payload

546
00:24:40,540 --> 00:24:45,159
except terminating now bytes what we

547
00:24:43,150 --> 00:24:47,800
simply need to do in the mallow process

548
00:24:45,160 --> 00:24:51,010
is define an atom object for Windows

549
00:24:47,800 --> 00:24:54,310
with this payload as the content and

550
00:24:51,010 --> 00:24:56,710
then using anti q a PC thread which can

551
00:24:54,310 --> 00:24:59,200
invoke any function in the target

552
00:24:56,710 --> 00:25:02,010
process up to with up to three arguments

553
00:24:59,200 --> 00:25:05,980
we invoke the global get atom name a

554
00:25:02,010 --> 00:25:10,360
with this item name the target a address

555
00:25:05,980 --> 00:25:15,010
for the for the payload and the size and

556
00:25:10,360 --> 00:25:17,790
the size of the payload and and it will

557
00:25:15,010 --> 00:25:20,650
run global get atom in name a in the

558
00:25:17,790 --> 00:25:22,990
target process which will copy the item

559
00:25:20,650 --> 00:25:26,440
data the payload into the desired

560
00:25:22,990 --> 00:25:30,430
address which is very neat the original

561
00:25:26,440 --> 00:25:33,370
paper does not right now bytes they

562
00:25:30,430 --> 00:25:36,690
assume that the the target memory is

563
00:25:33,370 --> 00:25:39,280
zeroed out because they use a code cave

564
00:25:36,690 --> 00:25:40,810
and we devised a technique to right now

565
00:25:39,280 --> 00:25:43,300
bytes it's all in our paper if you're

566
00:25:40,810 --> 00:25:46,870
interested the prerequisites here B is

567
00:25:43,300 --> 00:25:49,180
because we use a PC execution technique

568
00:25:46,870 --> 00:25:52,620
the thread must be in an alert able to

569
00:25:49,180 --> 00:25:55,090
stay but that's not typically a problem

570
00:25:52,620 --> 00:25:58,000
and this is a writing technique so

571
00:25:55,090 --> 00:26:03,090
there's no impact for c FG + 4 c IG is

572
00:25:58,000 --> 00:26:03,090
Iravan because it's not a dll and

573
00:26:03,180 --> 00:26:10,720
another interesting location + writing

574
00:26:07,090 --> 00:26:13,629
technically lumped together in this in

575
00:26:10,720 --> 00:26:17,650
this one is the forcing mapping of

576
00:26:13,630 --> 00:26:22,120
section on the target process in this

577
00:26:17,650 --> 00:26:25,390
case we define a section in the in them

578
00:26:22,120 --> 00:26:27,939
our we fill it with our data and then we

579
00:26:25,390 --> 00:26:30,310
forcefully map it into the target

580
00:26:27,940 --> 00:26:33,280
process using empty map view of section

581
00:26:30,310 --> 00:26:35,740
which also allocates a they allocate the

582
00:26:33,280 --> 00:26:38,410
memory in the target section and if we

583
00:26:35,740 --> 00:26:40,630
ask for page execute it will also set

584
00:26:38,410 --> 00:26:45,160
the whole memory region to be safe

585
00:26:40,630 --> 00:26:47,470
JaVale it the downside is that it cannot

586
00:26:45,160 --> 00:26:49,330
be used for an already allocated nor so

587
00:26:47,470 --> 00:26:54,940
this one cannot be used to say write

588
00:26:49,330 --> 00:26:56,860
data on the stack as for CFG as I

589
00:26:54,940 --> 00:26:58,900
mentioned earlier the memory allocated

590
00:26:56,860 --> 00:27:01,300
with page execution privileges become

591
00:26:58,900 --> 00:27:05,800
becomes a valid CFG target which is very

592
00:27:01,300 --> 00:27:08,440
neat and here is a cute execution

593
00:27:05,800 --> 00:27:12,790
technique it's what we call a map +

594
00:27:08,440 --> 00:27:16,650
rewrite in which we we and map a

595
00:27:12,790 --> 00:27:21,180
prominent DLL in the target process

596
00:27:16,650 --> 00:27:25,870
specifically anti DLL is of course a

597
00:27:21,180 --> 00:27:30,190
probably ideal choice what we need to do

598
00:27:25,870 --> 00:27:34,629
is to add up this this DLL and then and

599
00:27:30,190 --> 00:27:37,270
then map a mapper section back exactly

600
00:27:34,630 --> 00:27:39,340
in the same size to the exact address of

601
00:27:37,270 --> 00:27:43,480
the original anti DLL in the target

602
00:27:39,340 --> 00:27:45,669
process and so the execute with so next

603
00:27:43,480 --> 00:27:49,000
time whenever an nth ideal function is

604
00:27:45,670 --> 00:27:50,710
involved our own code will run the way

605
00:27:49,000 --> 00:27:53,530
to do it is a bit more tricky and

606
00:27:50,710 --> 00:27:55,210
requires a attention to details first of

607
00:27:53,530 --> 00:27:56,680
course the process the whole process the

608
00:27:55,210 --> 00:27:57,430
whole target process needs to be

609
00:27:56,680 --> 00:28:00,520
suspended

610
00:27:57,430 --> 00:28:04,360
otherwise if someone if some thread will

611
00:28:00,520 --> 00:28:06,970
invoke function at ntdll once anti DLL

612
00:28:04,360 --> 00:28:11,169
is unmapped but before our code is there

613
00:28:06,970 --> 00:28:14,410
it will obviously crash the process then

614
00:28:11,170 --> 00:28:19,330
we can just write data there we need to

615
00:28:14,410 --> 00:28:22,660
return retain the the context of many s

616
00:28:19,330 --> 00:28:26,230
internal variable and ntdll variables to

617
00:28:22,660 --> 00:28:28,600
do so what we need to do is copy the

618
00:28:26,230 --> 00:28:30,590
original content of the whole ant idle

619
00:28:28,600 --> 00:28:34,189
region today

620
00:28:30,590 --> 00:28:36,740
malware process then patch some

621
00:28:34,190 --> 00:28:41,270
functions of anti DLL I can t close and

622
00:28:36,740 --> 00:28:43,220
then write this data back to the to the

623
00:28:41,270 --> 00:28:46,430
target process instead of the origin

624
00:28:43,220 --> 00:28:49,670
once we hung up the original anti DLL

625
00:28:46,430 --> 00:28:51,770
otherwise if we don't do that it will

626
00:28:49,670 --> 00:28:55,220
the process is very likely to crash

627
00:28:51,770 --> 00:28:56,810
because of inconsistencies and of course

628
00:28:55,220 --> 00:28:59,930
we need to flush the instruction cache

629
00:28:56,810 --> 00:29:02,510
in order to tell the CPU not to use the

630
00:28:59,930 --> 00:29:11,060
old any old code from the old Oh aunt

631
00:29:02,510 --> 00:29:14,530
ideally it cached since all the some

632
00:29:11,060 --> 00:29:18,950
since the memory that we allocate in

633
00:29:14,530 --> 00:29:22,700
inside the target process replaces the

634
00:29:18,950 --> 00:29:25,100
old ntdll any all entry points in mt dll

635
00:29:22,700 --> 00:29:27,230
all functions in MTD lab must be CFG

636
00:29:25,100 --> 00:29:29,899
valid fortunately if we use either

637
00:29:27,230 --> 00:29:38,510
virtual lk x or NT map your section this

638
00:29:29,900 --> 00:29:42,020
is taken care of and then there is a

639
00:29:38,510 --> 00:29:44,540
bunch of callback override execution

640
00:29:42,020 --> 00:29:47,420
techniques what we call i lumped

641
00:29:44,540 --> 00:29:49,909
together a whole lot of execution

642
00:29:47,420 --> 00:29:55,280
techniques starting with set window long

643
00:29:49,910 --> 00:29:57,220
PTR propagate control inject lp/cd W&F

644
00:29:55,280 --> 00:30:00,320
and the whole shuttle like techniques

645
00:29:57,220 --> 00:30:05,320
together because they share the same

646
00:30:00,320 --> 00:30:08,899
concept what they do is they write the

647
00:30:05,320 --> 00:30:11,260
target code or logic into the in the

648
00:30:08,900 --> 00:30:14,210
desired process and then the execution

649
00:30:11,260 --> 00:30:16,430
revolves around finding or obtaining a

650
00:30:14,210 --> 00:30:18,800
memory address of an object of a virtual

651
00:30:16,430 --> 00:30:21,290
table specific object or specific

652
00:30:18,800 --> 00:30:23,930
callback function of specific function

653
00:30:21,290 --> 00:30:26,450
table which in itself may be tricky

654
00:30:23,930 --> 00:30:28,340
because the object may may or may not be

655
00:30:26,450 --> 00:30:30,380
there depending on the nature of the

656
00:30:28,340 --> 00:30:32,449
process for example whether the process

657
00:30:30,380 --> 00:30:34,310
uses a LPC or not whether the core

658
00:30:32,450 --> 00:30:37,370
process is in console application or not

659
00:30:34,310 --> 00:30:39,830
whether the process has a private

660
00:30:37,370 --> 00:30:41,679
clipboard or not it's not it's not a

661
00:30:39,830 --> 00:30:44,990
very generic

662
00:30:41,680 --> 00:30:47,780
approach is what I'm saying

663
00:30:44,990 --> 00:30:50,870
this finding / obtaining can be done

664
00:30:47,780 --> 00:30:53,780
either via a standard windows API like

665
00:30:50,870 --> 00:30:56,540
get window long PDR over a memory search

666
00:30:53,780 --> 00:30:59,840
which is the case for a PC that they

667
00:30:56,540 --> 00:31:02,540
opposite attack once this object is

668
00:30:59,840 --> 00:31:04,490
found we replace the object or the

669
00:31:02,540 --> 00:31:06,530
callback function using one of the

670
00:31:04,490 --> 00:31:09,530
writing techniques or using the standard

671
00:31:06,530 --> 00:31:13,040
API if it applies like a set window hook

672
00:31:09,530 --> 00:31:15,320
acts as a sorry set a window long PDR to

673
00:31:13,040 --> 00:31:18,440
point at the at our choice

674
00:31:15,320 --> 00:31:22,850
show is chosen functional code and this

675
00:31:18,440 --> 00:31:27,770
this for all such techniques must be CFG

676
00:31:22,850 --> 00:31:30,110
valid target and it also it may require

677
00:31:27,770 --> 00:31:34,240
some object or code adjustments in order

678
00:31:30,110 --> 00:31:37,399
to make the process stable not crash

679
00:31:34,240 --> 00:31:39,800
finally we trigger the execution again

680
00:31:37,400 --> 00:31:43,970
this may be tricky in some technical

681
00:31:39,800 --> 00:31:46,570
some approaches as the as the triggering

682
00:31:43,970 --> 00:31:50,110
event may or may not be deterministic

683
00:31:46,570 --> 00:31:51,980
and post exposed

684
00:31:50,110 --> 00:31:55,159
injection we need to restore the

685
00:31:51,980 --> 00:31:58,880
original object or callback here's an

686
00:31:55,160 --> 00:32:01,430
example of very concise and simplified

687
00:31:58,880 --> 00:32:06,770
example and using controlling jet as an

688
00:32:01,430 --> 00:32:08,900
example the idea here is that a console

689
00:32:06,770 --> 00:32:11,060
application mind you this is now have

690
00:32:08,900 --> 00:32:15,950
quite a restricted set of processes a

691
00:32:11,060 --> 00:32:19,310
console application stores a handler for

692
00:32:15,950 --> 00:32:24,290
the control inject event in its kernel

693
00:32:19,310 --> 00:32:25,820
base single handler variable there's a

694
00:32:24,290 --> 00:32:28,930
bit of a complication here because the

695
00:32:25,820 --> 00:32:33,110
the pointer store there is encoded

696
00:32:28,930 --> 00:32:34,640
fortunately we can use we can use the

697
00:32:33,110 --> 00:32:37,459
function our tail and code remote

698
00:32:34,640 --> 00:32:42,620
pointer from within them our process

699
00:32:37,460 --> 00:32:45,620
itself to encode our target our target

700
00:32:42,620 --> 00:32:48,649
code location using the same using the

701
00:32:45,620 --> 00:32:52,040
encoding schemers in the key of the

702
00:32:48,650 --> 00:32:54,080
target process so once we do that we

703
00:32:52,040 --> 00:32:56,918
copy this address the

704
00:32:54,080 --> 00:32:59,480
copy the data they encoded a pointer to

705
00:32:56,919 --> 00:33:01,970
kernel-based single handler at the

706
00:32:59,480 --> 00:33:05,779
target process using any memory writing

707
00:33:01,970 --> 00:33:08,450
technique technique we like and and of

708
00:33:05,779 --> 00:33:11,179
course we have our code they're already

709
00:33:08,450 --> 00:33:14,120
using any memory writing technique we

710
00:33:11,179 --> 00:33:16,490
like and finally what remains to do is

711
00:33:14,120 --> 00:33:18,529
to for us to do is to trigger the

712
00:33:16,490 --> 00:33:22,309
execution and we do that by simulating

713
00:33:18,529 --> 00:33:26,029
the control see event first we say we

714
00:33:22,309 --> 00:33:29,090
simulate pressing control using send

715
00:33:26,029 --> 00:33:32,149
input and then we simulate pressing the

716
00:33:29,090 --> 00:33:34,789
C character with post message and that's

717
00:33:32,149 --> 00:33:36,709
once that happens this function is

718
00:33:34,789 --> 00:33:38,240
involved and code starts running our

719
00:33:36,710 --> 00:33:46,370
code starts running in the target

720
00:33:38,240 --> 00:33:51,860
process and now finally we move to our

721
00:33:46,370 --> 00:33:53,510
own little set of new techniques we

722
00:33:51,860 --> 00:33:56,449
first describe a memory writing

723
00:33:53,510 --> 00:34:00,669
technique using a memset or memo which

724
00:33:56,450 --> 00:34:03,440
has some very interesting properties

725
00:34:00,669 --> 00:34:07,370
what we do here is assuming that we

726
00:34:03,440 --> 00:34:10,790
write our our data to the destination to

727
00:34:07,370 --> 00:34:14,540
the target process bite by by using

728
00:34:10,790 --> 00:34:16,909
memset and invoking memset in the target

729
00:34:14,540 --> 00:34:19,940
process using empty queue a pc thread

730
00:34:16,909 --> 00:34:21,970
now remember it takes it it can invoke

731
00:34:19,940 --> 00:34:24,320
function a function of 3 argument

732
00:34:21,969 --> 00:34:26,569
fortunately memset uses exactly 3

733
00:34:24,320 --> 00:34:29,629
arguments the destination address which

734
00:34:26,570 --> 00:34:32,270
we control the one by data and the

735
00:34:29,629 --> 00:34:34,940
length which for us the interesting

736
00:34:32,270 --> 00:34:37,280
length is the useful length is 1 this

737
00:34:34,940 --> 00:34:40,460
way we invoke memset once and write a

738
00:34:37,280 --> 00:34:42,859
single byte in any desired address in

739
00:34:40,460 --> 00:34:45,619
the target process we can do a loop over

740
00:34:42,859 --> 00:34:47,330
and write whatever we like and write

741
00:34:45,619 --> 00:34:49,639
arbitrary data to arbitrary memory

742
00:34:47,330 --> 00:34:51,609
location in memory locations in the

743
00:34:49,639 --> 00:34:55,970
process in the target process and

744
00:34:51,609 --> 00:34:57,950
finally we can make it atomic by by

745
00:34:55,969 --> 00:35:00,649
writing the data to some temporary

746
00:34:57,950 --> 00:35:04,569
address not in use temporary buffer not

747
00:35:00,650 --> 00:35:04,569
in use and then copying the buffer

748
00:35:04,750 --> 00:35:11,530
in a single atomic step using man moves

749
00:35:08,540 --> 00:35:16,220
which allows us to move to it to to

750
00:35:11,530 --> 00:35:17,990
using again empty queue a PC thread with

751
00:35:16,220 --> 00:35:20,839
man moved and taking three arguments

752
00:35:17,990 --> 00:35:23,930
destination addresses source address and

753
00:35:20,840 --> 00:35:30,680
length thereby we can achieve atomic

754
00:35:23,930 --> 00:35:33,589
memory writing safety note that although

755
00:35:30,680 --> 00:35:36,500
we evoke a empty queue a piece is read

756
00:35:33,590 --> 00:35:39,470
as if G has no effect on us because the

757
00:35:36,500 --> 00:35:43,070
target functions the MM set and memo are

758
00:35:39,470 --> 00:35:45,439
of course safe G valid and we can write

759
00:35:43,070 --> 00:35:47,090
to any address in fact the only purpose

760
00:35:45,440 --> 00:35:49,370
it is that the thread must be in an

761
00:35:47,090 --> 00:35:51,770
alert able state and the memory should

762
00:35:49,370 --> 00:35:55,310
be allocated which are not not as

763
00:35:51,770 --> 00:35:57,890
serious problems and finally we describe

764
00:35:55,310 --> 00:35:59,750
here our stack bombing execution

765
00:35:57,890 --> 00:36:02,720
technique which is a new execution

766
00:35:59,750 --> 00:36:07,700
technique in this case the idea is

767
00:36:02,720 --> 00:36:10,689
pretty simple we are using get thread

768
00:36:07,700 --> 00:36:15,950
context to obtain the threads

769
00:36:10,690 --> 00:36:18,260
top of stack the threads are SP and if

770
00:36:15,950 --> 00:36:20,779
the thread is in an alert able state is

771
00:36:18,260 --> 00:36:23,180
I'm taking a simple example here it

772
00:36:20,780 --> 00:36:26,750
means that when the thread resumes from

773
00:36:23,180 --> 00:36:30,649
it's a lot about state as well as we see

774
00:36:26,750 --> 00:36:32,720
here it will immediately after the Sisko

775
00:36:30,650 --> 00:36:34,610
it will immediately return there is no

776
00:36:32,720 --> 00:36:37,040
manipulation of the stack there is no

777
00:36:34,610 --> 00:36:39,980
manipulation of registers which is very

778
00:36:37,040 --> 00:36:42,080
handy so once this if the stack if the

779
00:36:39,980 --> 00:36:46,280
target thread is in an alert of all

780
00:36:42,080 --> 00:36:49,310
state it means that if we now write the

781
00:36:46,280 --> 00:36:55,840
address of the list of the destination

782
00:36:49,310 --> 00:37:00,620
code in the in a in the others of

783
00:36:55,840 --> 00:37:02,990
pointed by our SP the thread will will

784
00:37:00,620 --> 00:37:05,930
actually branch the return in the thread

785
00:37:02,990 --> 00:37:08,990
will immediately branch to our own code

786
00:37:05,930 --> 00:37:13,319
and that's essentially the idea we're in

787
00:37:08,990 --> 00:37:16,390
our POC in the white paper in

788
00:37:13,320 --> 00:37:19,240
we will see this we will see that we'll

789
00:37:16,390 --> 00:37:22,240
see how we implemented this using the

790
00:37:19,240 --> 00:37:24,609
unused stack as an additional memory we

791
00:37:22,240 --> 00:37:29,009
built their Rock gadget and we have this

792
00:37:24,610 --> 00:37:31,960
the thread actually running running

793
00:37:29,010 --> 00:37:34,600
stack people into the rock gadget and

794
00:37:31,960 --> 00:37:38,890
start executing our Rob gadget and all

795
00:37:34,600 --> 00:37:42,990
this without resorting to allocating

796
00:37:38,890 --> 00:37:42,990
executable memory in the target process

797
00:37:45,580 --> 00:37:51,940
[Music]

798
00:37:47,910 --> 00:37:54,310
so the per acquisition is our that that

799
00:37:51,940 --> 00:37:57,190
is in a lot of a state there's no impact

800
00:37:54,310 --> 00:37:59,290
over CFG and as I mentioned the paper

801
00:37:57,190 --> 00:38:04,450
injector includes the fully functional

802
00:37:59,290 --> 00:38:06,490
code we we also looked at three two we

803
00:38:04,450 --> 00:38:09,250
also discovered two methods with no

804
00:38:06,490 --> 00:38:12,279
longer work if anyone if anyone can

805
00:38:09,250 --> 00:38:16,360
provide us with a working example will

806
00:38:12,280 --> 00:38:19,840
be much delighted and to summarize we've

807
00:38:16,360 --> 00:38:22,540
seen several writing techniques actually

808
00:38:19,840 --> 00:38:24,940
file them and these are prepared their

809
00:38:22,540 --> 00:38:27,850
properties we've seen a lot over 20

810
00:38:24,940 --> 00:38:30,340
execution techniques but only four of

811
00:38:27,850 --> 00:38:32,529
them are safety agnostic the thread

812
00:38:30,340 --> 00:38:35,560
execution hijacking suspending jack

813
00:38:32,530 --> 00:38:39,910
resume ghost writing and override and

814
00:38:35,560 --> 00:38:42,790
our own stack bombing if you're

815
00:38:39,910 --> 00:38:44,740
interested in loading a DLL into the

816
00:38:42,790 --> 00:38:47,100
target process without writing a system

817
00:38:44,740 --> 00:38:49,629
deal without writing its name first

818
00:38:47,100 --> 00:38:52,779
fortune we have a nice trick for you you

819
00:38:49,630 --> 00:38:56,680
can use a kernel base it contains a list

820
00:38:52,780 --> 00:39:00,550
of over 1,000 system DLL names including

821
00:38:56,680 --> 00:39:02,350
MS HTML shell 32 and we 98.2 ll so if

822
00:39:00,550 --> 00:39:04,300
your favorite web gadget happens to be

823
00:39:02,350 --> 00:39:06,759
there and the dealer is not already

824
00:39:04,300 --> 00:39:10,570
loaded is a nifty way of loading your

825
00:39:06,760 --> 00:39:12,400
system DLL into a target process and now

826
00:39:10,570 --> 00:39:15,340
I'm handing it over to Itzik

827
00:39:12,400 --> 00:39:17,859
Thank You Amit okay so as Amit mentioned

828
00:39:15,340 --> 00:39:19,450
in addition to the theory that we did

829
00:39:17,859 --> 00:39:21,190
and the research we're going to release

830
00:39:19,450 --> 00:39:23,230
the tool today called inject bra

831
00:39:21,190 --> 00:39:24,460
injector implements all the different

832
00:39:23,230 --> 00:39:26,740
techniques that the meat is just

833
00:39:24,460 --> 00:39:28,060
detailed as well as the

834
00:39:26,740 --> 00:39:30,368
bombing technique that we have

835
00:39:28,060 --> 00:39:32,740
introduced so you can go right now to

836
00:39:30,369 --> 00:39:36,400
get up and download your copy it's free

837
00:39:32,740 --> 00:39:38,290
it's open source let's talk about what

838
00:39:36,400 --> 00:39:40,089
the high-level structure of conject bra

839
00:39:38,290 --> 00:39:42,400
a little bit about the philosophy of the

840
00:39:40,089 --> 00:39:43,990
design before it soap injector is a

841
00:39:42,400 --> 00:39:46,930
visual studio solution that contains

842
00:39:43,990 --> 00:39:49,540
four projects as Amit mentioned some of

843
00:39:46,930 --> 00:39:51,069
the attacks required dll artifacts so we

844
00:39:49,540 --> 00:39:53,349
provide those out-of-the-box

845
00:39:51,070 --> 00:39:55,210
let's account for the first two and then

846
00:39:53,349 --> 00:39:57,670
we have the pin director tool itself it

847
00:39:55,210 --> 00:39:59,830
contains the demo and the techniques and

848
00:39:57,670 --> 00:40:02,410
for your convenience we also include the

849
00:39:59,830 --> 00:40:05,410
test process Adamic program that in

850
00:40:02,410 --> 00:40:07,420
sometimes will also put the the thread

851
00:40:05,410 --> 00:40:09,220
in the alert able state as Amit mention

852
00:40:07,420 --> 00:40:11,710
itself prerequisites for some of the

853
00:40:09,220 --> 00:40:13,720
techniques so conveniently the program

854
00:40:11,710 --> 00:40:15,070
will do it for you as well now stepping

855
00:40:13,720 --> 00:40:17,169
back a little bit about what's the

856
00:40:15,070 --> 00:40:18,700
philosophy behind conject run so as a

857
00:40:17,170 --> 00:40:20,650
mid mentioned the research took a lot of

858
00:40:18,700 --> 00:40:22,689
effort collecting different scripts and

859
00:40:20,650 --> 00:40:24,910
organized them together into a framework

860
00:40:22,690 --> 00:40:28,180
we decided to take it to the next step

861
00:40:24,910 --> 00:40:30,490
and we basically utilize C in C++ static

862
00:40:28,180 --> 00:40:32,799
type system to create and break Stickley

863
00:40:30,490 --> 00:40:35,229
break down the concept into through

864
00:40:32,800 --> 00:40:37,720
different classes types that together

865
00:40:35,230 --> 00:40:40,810
can combine into a process injection

866
00:40:37,720 --> 00:40:42,970
execution so how does it look like so

867
00:40:40,810 --> 00:40:45,609
here is the first example of how you

868
00:40:42,970 --> 00:40:48,009
implement stack bombing with injector ax

869
00:40:45,609 --> 00:40:50,410
the first class is providing the code

870
00:40:48,010 --> 00:40:52,359
execution and again this is a thread

871
00:40:50,410 --> 00:40:53,560
suspending Jack to resume not to be

872
00:40:52,359 --> 00:40:55,509
confused with the other technique that

873
00:40:53,560 --> 00:40:58,000
emitters presented this is just a

874
00:40:55,510 --> 00:41:00,640
conceptual logic of what's going to

875
00:40:58,000 --> 00:41:03,130
happen and then the second class is the

876
00:41:00,640 --> 00:41:06,040
actual writing to the memory as you can

877
00:41:03,130 --> 00:41:07,869
see net QA PC trade with memset and the

878
00:41:06,040 --> 00:41:10,000
third class is actually the

879
00:41:07,869 --> 00:41:11,920
implementation of the payload so as you

880
00:41:10,000 --> 00:41:14,109
can see you can easily mix and match you

881
00:41:11,920 --> 00:41:16,210
can take every different class and you

882
00:41:14,109 --> 00:41:18,040
can prototype existing techniques and

883
00:41:16,210 --> 00:41:22,830
expand them or you can try different

884
00:41:18,040 --> 00:41:22,830
components and now let's have a demo

885
00:41:32,039 --> 00:41:36,039
okay so what do we see here there's two

886
00:41:34,329 --> 00:41:38,019
seam these windows one of them is a

887
00:41:36,039 --> 00:41:39,459
green that's going to be the victim the

888
00:41:38,019 --> 00:41:42,999
other one's gonna be the red that's

889
00:41:39,459 --> 00:41:44,948
gonna be the attacker process first we

890
00:41:42,999 --> 00:41:47,169
launch the test program as you can see

891
00:41:44,949 --> 00:41:49,839
it will print for your convenience the

892
00:41:47,170 --> 00:41:59,650
PABT ad and put the threads into an

893
00:41:49,839 --> 00:42:01,509
eligible state then we're going to

894
00:41:59,650 --> 00:42:03,309
switch into pink egg drop we're going to

895
00:42:01,509 --> 00:42:05,589
run it without any arguments we're gonna

896
00:42:03,309 --> 00:42:07,059
get the usage usage due to all the

897
00:42:05,589 --> 00:42:09,549
different techniques in combination

898
00:42:07,059 --> 00:42:12,039
again just the demo tool not limiting

899
00:42:09,549 --> 00:42:14,440
the a possibility just common frequency

900
00:42:12,039 --> 00:42:16,269
combinations and then once we choose the

901
00:42:14,440 --> 00:42:19,359
right combination we enter the details

902
00:42:16,269 --> 00:42:21,609
of the process ID and the thread ID and

903
00:42:19,359 --> 00:42:22,930
the injection will happen the payload

904
00:42:21,609 --> 00:42:25,420
right now that the program is designed

905
00:42:22,930 --> 00:42:27,160
to run with is a simple hello world pop

906
00:42:25,420 --> 00:42:30,099
box that you can see the just popped

907
00:42:27,160 --> 00:42:32,140
here that's essentially the completion

908
00:42:30,099 --> 00:42:41,859
and the visual indicator that the

909
00:42:32,140 --> 00:42:43,538
injection was successful moving on to

910
00:42:41,859 --> 00:42:46,180
the second technique as Amit mentioned

911
00:42:43,539 --> 00:42:48,369
the growth writing it's very exotic very

912
00:42:46,180 --> 00:42:50,589
interesting to implement as you can see

913
00:42:48,369 --> 00:42:53,019
again the first top class control D code

914
00:42:50,589 --> 00:42:54,999
execution second class control the

915
00:42:53,019 --> 00:42:56,769
actual writing here we implemented the

916
00:42:54,999 --> 00:42:58,868
go for in technique and another a

917
00:42:56,769 --> 00:43:03,180
different payload that matched together

918
00:42:58,869 --> 00:43:03,180
and let's see how it works

919
00:43:08,279 --> 00:43:12,269
again we invoke the test program

920
00:43:19,270 --> 00:43:25,810
I'm sure it's running yep going back

921
00:43:22,930 --> 00:43:26,799
into the reject row again we will Bryant

922
00:43:25,810 --> 00:43:41,650
again just to see all the different

923
00:43:26,800 --> 00:43:43,780
options again the payload here is a

924
00:43:41,650 --> 00:43:45,730
visual indication of the other word box

925
00:43:43,780 --> 00:43:53,140
again another successful process

926
00:43:45,730 --> 00:43:55,330
injection okay so for the for the quick

927
00:43:53,140 --> 00:43:57,520
ones you can see that this first class

928
00:43:55,330 --> 00:43:59,290
is already been used in the past so if

929
00:43:57,520 --> 00:44:01,000
you look at the process of spending

930
00:43:59,290 --> 00:44:03,009
checked and resumed complex that's the

931
00:44:01,000 --> 00:44:04,900
same class that we use for the stack

932
00:44:03,010 --> 00:44:06,820
bombing again the concept of the

933
00:44:04,900 --> 00:44:08,950
mix-and-match and reusable components

934
00:44:06,820 --> 00:44:11,290
really starts to give back at this point

935
00:44:08,950 --> 00:44:13,480
here we only need to implement the uh

936
00:44:11,290 --> 00:44:15,400
map and map using a specific writer

937
00:44:13,480 --> 00:44:18,640
which is the combination of the create

938
00:44:15,400 --> 00:44:21,150
file map do file and map and then view

939
00:44:18,640 --> 00:44:23,379
it again and again this combination

940
00:44:21,150 --> 00:44:26,560
together with the payload that has been

941
00:44:23,380 --> 00:44:28,690
passed specifically will result in a

942
00:44:26,560 --> 00:44:30,730
process injection technique so again

943
00:44:28,690 --> 00:44:33,040
this is just how easy it is to either

944
00:44:30,730 --> 00:44:43,240
prototype a new technique or using an

945
00:44:33,040 --> 00:44:45,490
existing one here as a mid mention it

946
00:44:43,240 --> 00:44:47,799
requires a program that has multiple

947
00:44:45,490 --> 00:44:50,649
different functionalities and complexity

948
00:44:47,800 --> 00:44:52,180
to actually be using it so this in this

949
00:44:50,650 --> 00:44:54,130
example we're not going to actually use

950
00:44:52,180 --> 00:44:56,618
our test process we're going to use

951
00:44:54,130 --> 00:44:58,869
Explorer process as a result that's a

952
00:44:56,619 --> 00:45:01,900
quick batch script just to find out the

953
00:44:58,869 --> 00:45:03,609
PID of Explorer now we're going to

954
00:45:01,900 --> 00:45:10,060
attack the Explorer process in the

955
00:45:03,609 --> 00:45:13,240
computer we're going to enter the PID

956
00:45:10,060 --> 00:45:20,070
and then touching the taskbar we'll get

957
00:45:13,240 --> 00:45:20,069
the job done here with this

958
00:45:22,349 --> 00:45:27,880
and there's but not at least actually

959
00:45:26,020 --> 00:45:29,859
what before the last we have been

960
00:45:27,880 --> 00:45:31,480
setting the long pointer here again you

961
00:45:29,859 --> 00:45:34,119
can see the complexity of the framework

962
00:45:31,480 --> 00:45:36,430
comes into play we're using a specific

963
00:45:34,119 --> 00:45:38,859
code execution and then we're using a

964
00:45:36,430 --> 00:45:40,808
convertible to actually reuse a very

965
00:45:38,859 --> 00:45:42,700
primitive writing technique which is a

966
00:45:40,809 --> 00:45:44,920
combination of virtual allocate and

967
00:45:42,700 --> 00:45:47,020
write process together with the payload

968
00:45:44,920 --> 00:45:49,359
and that's all combined nicely into

969
00:45:47,020 --> 00:45:51,788
these one huge instance of a class and

970
00:45:49,359 --> 00:45:55,259
then invoking it with the inject method

971
00:45:51,789 --> 00:46:01,029
at the the bottom will get the job done

972
00:45:55,260 --> 00:46:02,920
so here's a quick demo it's important to

973
00:46:01,029 --> 00:46:04,900
note that since as Amit explained

974
00:46:02,920 --> 00:46:07,089
there's a specific structure that

975
00:46:04,900 --> 00:46:09,069
requires to be retrieved and changed in

976
00:46:07,089 --> 00:46:11,470
this particular case we're not using a

977
00:46:09,069 --> 00:46:14,500
test process the actual conjecture does

978
00:46:11,470 --> 00:46:17,470
the location of the PID and retrieves

979
00:46:14,500 --> 00:46:20,380
the relevant abstract for you so this is

980
00:46:17,470 --> 00:46:22,779
going to be all things extra doing zero

981
00:46:20,380 --> 00:46:28,569
zero indicating no actual process ID

982
00:46:22,779 --> 00:46:30,220
needs to be specified and last but not

983
00:46:28,569 --> 00:46:32,650
least it's the atomic bonding

984
00:46:30,220 --> 00:46:34,808
implementation in projector here again

985
00:46:32,650 --> 00:46:37,150
you can see the Q user eighty-three

986
00:46:34,809 --> 00:46:39,010
being the code execution class and then

987
00:46:37,150 --> 00:46:41,349
a combination of open thread open

988
00:46:39,010 --> 00:46:43,480
process virtual allocation and global

989
00:46:41,349 --> 00:46:45,730
IDI atom to complete the actual writing

990
00:46:43,480 --> 00:46:47,799
and as you can see you can control the

991
00:46:45,730 --> 00:46:51,390
payload the different flags and you can

992
00:46:47,799 --> 00:46:51,390
experiment with different variation

993
00:46:55,740 --> 00:47:01,558
again we will be using the Explorer as a

994
00:46:58,839 --> 00:47:01,558
test process

995
00:47:12,970 --> 00:47:19,660
and here with this excellent well that

996
00:47:17,650 --> 00:47:23,079
would be the left them of the day to

997
00:47:19,660 --> 00:47:26,290
meet back to you thank you it's sick so

998
00:47:23,079 --> 00:47:28,960
to summarize what we what we have you is

999
00:47:26,290 --> 00:47:31,960
the a map of the vast territory of true

1000
00:47:28,960 --> 00:47:34,119
process injection and we provide an

1001
00:47:31,960 --> 00:47:36,130
analysis and comparison in a single

1002
00:47:34,119 --> 00:47:39,609
collection and posit Ori available in

1003
00:47:36,130 --> 00:47:42,130
our github we also provide you of course

1004
00:47:39,609 --> 00:47:43,990
the library ejector for the

1005
00:47:42,130 --> 00:47:45,849
mix-and-match generation of process

1006
00:47:43,990 --> 00:47:47,859
injection attacks which is a mighty

1007
00:47:45,849 --> 00:47:50,050
mighty important because this mix and

1008
00:47:47,859 --> 00:47:52,230
match allows us to cover various

1009
00:47:50,050 --> 00:47:56,440
combinations that are not provided in

1010
00:47:52,230 --> 00:47:58,480
imposes a today and we described a new

1011
00:47:56,440 --> 00:48:01,569
safe Diagnostics execution technique the

1012
00:47:58,480 --> 00:48:03,339
stack bomb being technique and memory in

1013
00:48:01,569 --> 00:48:08,770
a memorizing technique coupled with it

1014
00:48:03,339 --> 00:48:10,540
based on memset and move over APC thank

1015
00:48:08,770 --> 00:48:13,960
you very much I believe we have time for

1016
00:48:10,540 --> 00:48:15,609
a few questions you can use it just step

1017
00:48:13,960 --> 00:48:18,359
up to the microphone step up to the

1018
00:48:15,609 --> 00:48:18,359
microphone please

1019
00:48:24,970 --> 00:48:31,759
oh okay thank you

1020
00:48:27,800 --> 00:48:31,760
[Applause]

