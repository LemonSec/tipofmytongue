1
00:00:00,000 --> 00:00:04,859
good afternoon and welcome to this talk

2
00:00:02,760 --> 00:00:05,670
is behind the scenes of iOS and Mac

3
00:00:04,859 --> 00:00:08,550
security

4
00:00:05,670 --> 00:00:11,759
this is South Pacific and our speaker is

5
00:00:08,550 --> 00:00:13,290
Yvonne curse stick so if that means a

6
00:00:11,759 --> 00:00:14,519
lot to you you're in the right place so

7
00:00:13,290 --> 00:00:17,549
thank you very much

8
00:00:14,519 --> 00:00:19,500
just a few little notes before and we

9
00:00:17,550 --> 00:00:21,660
begin so stop by the business hall

10
00:00:19,500 --> 00:00:24,000
located in Mandalay Bay Oceanside and

11
00:00:21,660 --> 00:00:25,800
shoreline ballrooms on level two the

12
00:00:24,000 --> 00:00:27,150
black cat hostel is in the business hall

13
00:00:25,800 --> 00:00:29,939
on level two

14
00:00:27,150 --> 00:00:31,979
lunches in Bayside a/b from 1:00 to 2:30

15
00:00:29,939 --> 00:00:33,930
and don't forget the merchandise store

16
00:00:31,980 --> 00:00:36,840
on level two and session recordings mess

17
00:00:33,930 --> 00:00:38,489
ok they have a desk on every level just

18
00:00:36,840 --> 00:00:40,500
as a final reminder please make sure

19
00:00:38,489 --> 00:00:43,649
your cell phones are on vibrate it's way

20
00:00:40,500 --> 00:00:45,809
nicer for everybody else but without

21
00:00:43,649 --> 00:00:47,910
further ado let's get started and please

22
00:00:45,809 --> 00:00:54,828
join me in giving our speaker a warm

23
00:00:47,910 --> 00:00:56,910
welcome Ivana Kirsten Thank You Chuck

24
00:00:54,829 --> 00:01:00,629
great to be here

25
00:00:56,910 --> 00:01:01,828
my name is Yvonne I run seer security

26
00:01:00,629 --> 00:01:03,120
engineering and architecture this is the

27
00:01:01,829 --> 00:01:04,409
group at Apple that's enter and

28
00:01:03,120 --> 00:01:07,048
responsible for the security of

29
00:01:04,409 --> 00:01:08,610
everything that we ship to our users we

30
00:01:07,049 --> 00:01:10,140
have a lot to cover today so we're gonna

31
00:01:08,610 --> 00:01:13,530
just jump right into it and start

32
00:01:10,140 --> 00:01:15,299
talking about Mac secure boot we have

33
00:01:13,530 --> 00:01:17,549
been investing heavily in to Mac OS

34
00:01:15,299 --> 00:01:20,310
security some things that you may have

35
00:01:17,549 --> 00:01:21,659
noticed are things like gatekeeper and

36
00:01:20,310 --> 00:01:24,750
user privacy protection which are

37
00:01:21,659 --> 00:01:26,759
features that we pioneered in the Mac OS

38
00:01:24,750 --> 00:01:27,330
Mojave and continue to improve in

39
00:01:26,759 --> 00:01:29,790
Catalina

40
00:01:27,330 --> 00:01:33,420
so in Catalina gatekeeper is getting

41
00:01:29,790 --> 00:01:35,240
vastly expanded there'll be malware

42
00:01:33,420 --> 00:01:37,590
checks in virtually every execution path

43
00:01:35,240 --> 00:01:39,960
software has to be notarized to run and

44
00:01:37,590 --> 00:01:41,490
then user data protections which we

45
00:01:39,960 --> 00:01:43,860
introduced with Mojave was a way of

46
00:01:41,490 --> 00:01:46,048
forcing apps to require user consent

47
00:01:43,860 --> 00:01:47,790
before being able to access highway

48
00:01:46,049 --> 00:01:50,220
sensitive user data like these

49
00:01:47,790 --> 00:01:53,250
categories anytime an app tried to do

50
00:01:50,220 --> 00:01:55,229
this and not use traditional API it

51
00:01:53,250 --> 00:01:57,630
would pop a dialog like this in Catalina

52
00:01:55,229 --> 00:02:00,450
we went and added many more areas to be

53
00:01:57,630 --> 00:02:02,009
covered by this protection so we've been

54
00:02:00,450 --> 00:02:03,540
investing heavily in this but these are

55
00:02:02,009 --> 00:02:05,670
all features that are visible to the

56
00:02:03,540 --> 00:02:07,979
user and what about things that are

57
00:02:05,670 --> 00:02:11,610
lower in the stack what about secure

58
00:02:07,979 --> 00:02:13,860
boot we have an incredibly powerful

59
00:02:11,610 --> 00:02:16,980
secure boot implementation on iOS it's

60
00:02:13,860 --> 00:02:19,500
hardened it's been running for 11 years

61
00:02:16,980 --> 00:02:21,450
and we think it's state-of-the-art but

62
00:02:19,500 --> 00:02:23,070
what that means is that we have a very

63
00:02:21,450 --> 00:02:25,140
clear picture of the kind of security

64
00:02:23,070 --> 00:02:27,570
requirements that we would place on a

65
00:02:25,140 --> 00:02:29,369
Mac secure boot implementation and when

66
00:02:27,570 --> 00:02:32,190
we looked at the way secure boot tends

67
00:02:29,370 --> 00:02:34,470
to work on x86 systems traditionally

68
00:02:32,190 --> 00:02:36,990
it's done with ufi secure boot we found

69
00:02:34,470 --> 00:02:38,910
that it doesn't meet almost any of our

70
00:02:36,990 --> 00:02:42,090
security requirements for Makela secure

71
00:02:38,910 --> 00:02:44,310
boot so what we decided to do instead is

72
00:02:42,090 --> 00:02:46,530
build our Mac secure boot on top of the

73
00:02:44,310 --> 00:02:48,209
t2 security trip this is our second

74
00:02:46,530 --> 00:02:50,550
generation custom silicon for the Mac

75
00:02:48,209 --> 00:02:53,730
dedicated to security it brings a secure

76
00:02:50,550 --> 00:02:56,820
Enclave coprocessor with it in the way

77
00:02:53,730 --> 00:02:58,470
our secure boot now works is that t2 is

78
00:02:56,820 --> 00:02:59,850
actually what initializes boot before

79
00:02:58,470 --> 00:03:01,530
passing over to x86

80
00:02:59,850 --> 00:03:03,540
so if we break that down when power

81
00:03:01,530 --> 00:03:05,220
comes online the t2 rom runs and

82
00:03:03,540 --> 00:03:07,100
continues to cryptographic we verify

83
00:03:05,220 --> 00:03:09,870
every subsequent step of boot

84
00:03:07,100 --> 00:03:11,730
terminating with ufi firmware which is

85
00:03:09,870 --> 00:03:14,550
still verified of the t2 side before

86
00:03:11,730 --> 00:03:16,410
being moved over to x86 and executed

87
00:03:14,550 --> 00:03:18,269
where it will continue to check the

88
00:03:16,410 --> 00:03:21,810
remaining pieces of boot finally

89
00:03:18,269 --> 00:03:23,070
culminating in Mac OS running now it

90
00:03:21,810 --> 00:03:25,320
turns out that there are some critical

91
00:03:23,070 --> 00:03:27,180
challenges with bringing a powerful

92
00:03:25,320 --> 00:03:30,209
secure boot implementation to Mac that

93
00:03:27,180 --> 00:03:33,120
don't exist on Iowa's most importantly

94
00:03:30,209 --> 00:03:35,489
direct memory access attacks that are

95
00:03:33,120 --> 00:03:37,350
possible from physical accessories which

96
00:03:35,489 --> 00:03:39,209
can basically read and write post memory

97
00:03:37,350 --> 00:03:41,640
without any involvement from the CPU as

98
00:03:39,209 --> 00:03:43,799
well as an architectural feature of PCIe

99
00:03:41,640 --> 00:03:45,510
which is called option ramps or or arms

100
00:03:43,799 --> 00:03:47,190
which are device specific drivers for

101
00:03:45,510 --> 00:03:48,570
the early boot environment so I'm going

102
00:03:47,190 --> 00:03:50,220
to walk you through what we have to do

103
00:03:48,570 --> 00:03:53,220
to be able to contend with these

104
00:03:50,220 --> 00:03:54,989
challenges before that a very quick

105
00:03:53,220 --> 00:03:57,900
refresher this is operating systems 101

106
00:03:54,989 --> 00:03:59,790
how page tables work so this is a CPU

107
00:03:57,900 --> 00:04:01,680
running in normal 64-bit protected mode

108
00:03:59,790 --> 00:04:03,660
it's asking to read some memory from a

109
00:04:01,680 --> 00:04:05,370
virtual address that goes to the MMU

110
00:04:03,660 --> 00:04:07,470
which actually turns around consults

111
00:04:05,370 --> 00:04:08,970
page tables determines that this virtual

112
00:04:07,470 --> 00:04:10,769
address corresponds to a specific

113
00:04:08,970 --> 00:04:12,630
physical address of memory and that is

114
00:04:10,769 --> 00:04:14,160
the data that gets returned this is

115
00:04:12,630 --> 00:04:15,660
important because it'll be the basis of

116
00:04:14,160 --> 00:04:17,238
many of the systems that I'll be

117
00:04:15,660 --> 00:04:21,060
discussing with you in a moment

118
00:04:17,238 --> 00:04:22,770
so I mentioned DNA the reason this

119
00:04:21,060 --> 00:04:24,690
exists is because certain kinds of

120
00:04:22,770 --> 00:04:26,039
accessories have to be able to do very

121
00:04:24,690 --> 00:04:27,690
high throughput transfers if you're

122
00:04:26,039 --> 00:04:29,640
talking about storage or graphics or

123
00:04:27,690 --> 00:04:31,950
network cards you really want them to be

124
00:04:29,640 --> 00:04:34,169
able to move data interim without having

125
00:04:31,950 --> 00:04:36,270
to go through the normal cpu path but

126
00:04:34,170 --> 00:04:37,650
what that means is in the good case a

127
00:04:36,270 --> 00:04:39,330
network interface card can take a

128
00:04:37,650 --> 00:04:40,919
network packet that came in and DMA it

129
00:04:39,330 --> 00:04:43,349
directly into a packet buffer that's

130
00:04:40,920 --> 00:04:45,300
been allocated in the kernel heap in the

131
00:04:43,350 --> 00:04:48,570
bad case the same device could take

132
00:04:45,300 --> 00:04:50,550
malicious code and simply place it over

133
00:04:48,570 --> 00:04:54,420
to running curdle completely taking over

134
00:04:50,550 --> 00:04:56,520
execution of the system so in blue

135
00:04:54,420 --> 00:04:58,290
introduced a technology called vtd which

136
00:04:56,520 --> 00:05:00,120
is a way to initialize an input-output

137
00:04:58,290 --> 00:05:01,920
memory management unit to manage these

138
00:05:00,120 --> 00:05:04,080
kind of DMA transfers and we have used

139
00:05:01,920 --> 00:05:08,070
this technology to protect the kernel

140
00:05:04,080 --> 00:05:14,520
since OS 10 Mountain Lion in 2012 so

141
00:05:08,070 --> 00:05:17,310
here's the premise with vtd rvtd packet

142
00:05:14,520 --> 00:05:19,469
buffer here would say look only the

143
00:05:17,310 --> 00:05:21,150
packet buffer is writable by the

144
00:05:19,470 --> 00:05:23,070
accessory for DMA everything else is

145
00:05:21,150 --> 00:05:24,510
simply not mapped which means that the

146
00:05:23,070 --> 00:05:29,010
network packet could never go and

147
00:05:24,510 --> 00:05:30,450
override the mac OS kernel so before btv

148
00:05:29,010 --> 00:05:32,190
was introduced you were able to plug in

149
00:05:30,450 --> 00:05:34,349
a malicious underworld accessory while

150
00:05:32,190 --> 00:05:36,270
Mac OS kernel was running and you could

151
00:05:34,350 --> 00:05:38,760
simply go and do the moshus DMA and take

152
00:05:36,270 --> 00:05:41,880
over execution of the system when in

153
00:05:38,760 --> 00:05:43,440
2012 we've shipped vtd by setting up BPD

154
00:05:41,880 --> 00:05:44,730
early enough before thunderboy

155
00:05:43,440 --> 00:05:46,620
accessories could be used

156
00:05:44,730 --> 00:05:48,360
we simply prevent the DISA tach because

157
00:05:46,620 --> 00:05:50,220
by the time you could plug in a

158
00:05:48,360 --> 00:05:51,780
thunderbolt accessory it was contained

159
00:05:50,220 --> 00:05:54,000
with the DD and it would no longer do

160
00:05:51,780 --> 00:05:56,669
malicious DNA but there is an obvious

161
00:05:54,000 --> 00:05:58,830
question here what if you plug in the

162
00:05:56,669 --> 00:06:00,539
malicious accessory earlier specifically

163
00:05:58,830 --> 00:06:03,960
what if you plug it in before Mac OS is

164
00:06:00,540 --> 00:06:05,669
even running it turns out that BPD was

165
00:06:03,960 --> 00:06:08,400
originally really intended for operating

166
00:06:05,669 --> 00:06:10,620
systems and it wasn't until 2015 that

167
00:06:08,400 --> 00:06:13,320
Intel published the paper showing how he

168
00:06:10,620 --> 00:06:15,840
could be used inside the UEFI firmware

169
00:06:13,320 --> 00:06:19,290
environment we implemented this and we

170
00:06:15,840 --> 00:06:20,909
shipped at the 26 in 2016 which meant

171
00:06:19,290 --> 00:06:24,510
essentially taking this architectural

172
00:06:20,910 --> 00:06:26,960
lip of moving VTD setup from mac OS side

173
00:06:24,510 --> 00:06:29,280
to much earlier during ufi

174
00:06:26,960 --> 00:06:32,219
initialization and before Mochis

175
00:06:29,280 --> 00:06:35,159
accessories could be connected that

176
00:06:32,220 --> 00:06:37,950
solved that problem but it turns out

177
00:06:35,160 --> 00:06:40,890
that PCIe devices are initialized even

178
00:06:37,950 --> 00:06:41,670
earlier during firmware boot and so the

179
00:06:40,890 --> 00:06:43,979
way to address the

180
00:06:41,670 --> 00:06:46,230
is once again picking up the vtd setup

181
00:06:43,980 --> 00:06:48,420
and making sure it can take place before

182
00:06:46,230 --> 00:06:51,750
a single PCIe device is initialized and

183
00:06:48,420 --> 00:06:56,610
is therefore able to do malicious DMA we

184
00:06:51,750 --> 00:06:58,260
deployed this protection as well but it

185
00:06:56,610 --> 00:07:00,900
turns out there is one interesting piece

186
00:06:58,260 --> 00:07:03,780
of this still left we talked about UEFI

187
00:07:00,900 --> 00:07:06,390
firmware as this monolithic box and what

188
00:07:03,780 --> 00:07:09,270
actually ends up happening is that unify

189
00:07:06,390 --> 00:07:11,039
firmware boot has two stages there's the

190
00:07:09,270 --> 00:07:12,510
stage that we think of as normal ufi

191
00:07:11,040 --> 00:07:13,770
firmware and this is where we now have

192
00:07:12,510 --> 00:07:15,450
DVDs setup and we have all the

193
00:07:13,770 --> 00:07:17,070
protections we want but there's a

194
00:07:15,450 --> 00:07:20,039
portion of unified that executes before

195
00:07:17,070 --> 00:07:22,969
ram is available this is our pre ramp

196
00:07:20,040 --> 00:07:26,880
firmware in the during that execution

197
00:07:22,970 --> 00:07:28,530
PCIe bus zero devices which are these

198
00:07:26,880 --> 00:07:31,890
hyper privileged Hardware vices like

199
00:07:28,530 --> 00:07:34,080
SATA controllers X HDI controllers the

200
00:07:31,890 --> 00:07:36,240
management engine they are all initial

201
00:07:34,080 --> 00:07:37,859
eyes and by virtue of being initialized

202
00:07:36,240 --> 00:07:39,510
at this point of the boot process they

203
00:07:37,860 --> 00:07:43,920
are able to execute malicious DMA

204
00:07:39,510 --> 00:07:45,719
immediately so the answer feels pretty

205
00:07:43,920 --> 00:07:47,490
straightforward we could pick up vpv

206
00:07:45,720 --> 00:07:50,040
setup and we could somehow move it

207
00:07:47,490 --> 00:07:54,150
before PCI bus 0 devices are initialized

208
00:07:50,040 --> 00:07:56,010
but there's a catch vtd relies on an ion

209
00:07:54,150 --> 00:07:58,109
of you being configured you configure an

210
00:07:56,010 --> 00:08:00,570
iommu by pointing it at page tables and

211
00:07:58,110 --> 00:08:03,570
page tables have to live in RAM but Ram

212
00:08:00,570 --> 00:08:07,020
is not up yet here's what this actually

213
00:08:03,570 --> 00:08:08,190
looks like this is the moment before Ram

214
00:08:07,020 --> 00:08:09,690
is up and running you'll see the lower

215
00:08:08,190 --> 00:08:14,490
right-hand corner that's not initialized

216
00:08:09,690 --> 00:08:20,850
yet and there's a moment where execution

217
00:08:14,490 --> 00:08:22,170
transfers Ram is just coming online the

218
00:08:20,850 --> 00:08:24,090
moment frame comes on line we're going

219
00:08:22,170 --> 00:08:27,240
to try and take the ufi firmware from

220
00:08:24,090 --> 00:08:30,419
the t2 side and copy it into running Ram

221
00:08:27,240 --> 00:08:31,800
but at this exact moment we have placed

222
00:08:30,420 --> 00:08:33,870
the firmware there we have not yet even

223
00:08:31,800 --> 00:08:35,909
begin executing a single instruction and

224
00:08:33,870 --> 00:08:38,190
of course VPP is not configured which

225
00:08:35,909 --> 00:08:41,159
means that a malicious PCIe bus 0 device

226
00:08:38,190 --> 00:08:43,290
can strike right now while this form our

227
00:08:41,159 --> 00:08:44,730
code is in memory but hasn't run yet and

228
00:08:43,289 --> 00:08:50,189
replace it with malicious code

229
00:08:44,730 --> 00:08:51,570
completely taking over the system so

230
00:08:50,190 --> 00:08:54,540
what do you do in a situation like this

231
00:08:51,570 --> 00:08:55,130
how do you deploy BCD when you can't put

232
00:08:54,540 --> 00:08:57,230
a page there

233
00:08:55,130 --> 00:09:01,279
well here's the answer you initialized a

234
00:08:57,230 --> 00:09:03,050
table full of zeros and you say that's

235
00:09:01,279 --> 00:09:05,509
gonna be our root table and we're gonna

236
00:09:03,050 --> 00:09:08,689
use it for vtd as well as for interrupts

237
00:09:05,509 --> 00:09:11,810
remapping and if you take our firmware

238
00:09:08,690 --> 00:09:13,880
and take a look at some of the bytes in

239
00:09:11,810 --> 00:09:16,339
it you'll find this interesting section

240
00:09:13,880 --> 00:09:19,990
that is really just all zeros but it

241
00:09:16,339 --> 00:09:22,490
turns out that all of these zeros are a

242
00:09:19,990 --> 00:09:26,089
compiled page table that we were able to

243
00:09:22,490 --> 00:09:28,870
place into our UEFI firmware binary this

244
00:09:26,089 --> 00:09:32,779
means that we can during initialization

245
00:09:28,870 --> 00:09:34,940
before Ram is up point BPD at what looks

246
00:09:32,779 --> 00:09:36,439
like a page table but again is really

247
00:09:34,940 --> 00:09:38,779
just a bunch of bytes mapped in the

248
00:09:36,440 --> 00:09:41,899
processor cache out of our firmware

249
00:09:38,779 --> 00:09:43,939
binary what this gives us is the

250
00:09:41,899 --> 00:09:46,759
following property the moment the ufi

251
00:09:43,940 --> 00:09:50,060
firmware moves into x86 Ram when ram has

252
00:09:46,759 --> 00:09:51,769
finally come online btv is already up

253
00:09:50,060 --> 00:09:54,079
and running and if a malicious PCIe bus

254
00:09:51,769 --> 00:09:56,360
0 device attempts to actually go and

255
00:09:54,079 --> 00:09:59,508
override that firmware the VTT will

256
00:09:56,360 --> 00:10:01,160
consult page tables again that's our set

257
00:09:59,509 --> 00:10:03,740
of zeros which translates to deny

258
00:10:01,160 --> 00:10:07,100
everything and the transfer will be

259
00:10:03,740 --> 00:10:09,470
denied so in this way we're able to do

260
00:10:07,100 --> 00:10:11,949
BTD set up before PCIe bus zero is

261
00:10:09,470 --> 00:10:14,290
capable of doing any malicious DMA I

262
00:10:11,949 --> 00:10:16,579
also mentioned option roms

263
00:10:14,290 --> 00:10:18,860
option roms are interesting they're an

264
00:10:16,579 --> 00:10:20,750
architectural property of PCIe and the

265
00:10:18,860 --> 00:10:22,189
way to think about it is maybe you're

266
00:10:20,750 --> 00:10:24,230
booting your system from something like

267
00:10:22,189 --> 00:10:25,730
an external RAID controller your boot

268
00:10:24,230 --> 00:10:27,170
firmware doesn't know how to talk to the

269
00:10:25,730 --> 00:10:29,360
RAID controller and therefore it

270
00:10:27,170 --> 00:10:31,550
couldn't boot from it so PCIe provides

271
00:10:29,360 --> 00:10:33,889
this ability for this external accessory

272
00:10:31,550 --> 00:10:36,920
to say hey boot environment I have a

273
00:10:33,889 --> 00:10:38,139
driver here it is run it and you'll know

274
00:10:36,920 --> 00:10:41,779
how to talk to me

275
00:10:38,139 --> 00:10:43,670
unfortunately that option ROM runs in

276
00:10:41,779 --> 00:10:45,800
ring zero along with the rest of all of

277
00:10:43,670 --> 00:10:47,689
you Fi which means that any code that

278
00:10:45,800 --> 00:10:48,740
runs after the storm runs including the

279
00:10:47,689 --> 00:10:51,219
booter and the kernel could be

280
00:10:48,740 --> 00:10:53,120
completely compromised by an overwrite

281
00:10:51,220 --> 00:10:54,860
secure is essentially what this looks

282
00:10:53,120 --> 00:10:56,660
like you'll see that everything is in

283
00:10:54,860 --> 00:10:58,220
ring 0 sharing one virtual memory space

284
00:10:56,660 --> 00:11:00,259
that means that every one of these

285
00:10:58,220 --> 00:11:02,829
option roms can go and directly write

286
00:11:00,259 --> 00:11:06,559
over a core UEFI firmware if necessary

287
00:11:02,829 --> 00:11:07,910
what we want to do here is first pull

288
00:11:06,559 --> 00:11:08,930
out all the option arms and put them in

289
00:11:07,910 --> 00:11:10,250
a ring 3

290
00:11:08,930 --> 00:11:11,689
which is substantially less privileged

291
00:11:10,250 --> 00:11:13,610
but we want to go one step further and

292
00:11:11,690 --> 00:11:17,600
give them each their own virtual memory

293
00:11:13,610 --> 00:11:19,850
space finally we want to initialize our

294
00:11:17,600 --> 00:11:21,860
option arm sandbox driver which is going

295
00:11:19,850 --> 00:11:24,620
to mediate what these options are

296
00:11:21,860 --> 00:11:26,930
actually capable of doing so one option

297
00:11:24,620 --> 00:11:28,670
I'm trying to interfere with another or

298
00:11:26,930 --> 00:11:30,529
trying to interfere with direct for ufi

299
00:11:28,670 --> 00:11:33,589
firmware would simply be denied by the

300
00:11:30,529 --> 00:11:36,020
same box driver the premise here is that

301
00:11:33,589 --> 00:11:39,890
the option arm sandbox can limit both

302
00:11:36,020 --> 00:11:41,569
what all runs can call and which

303
00:11:39,890 --> 00:11:44,149
interfaces they can install what they

304
00:11:41,570 --> 00:11:46,040
can publish and we can do this in a way

305
00:11:44,149 --> 00:11:47,270
where normal options that are benign

306
00:11:46,040 --> 00:11:49,670
they're actually trying to help

307
00:11:47,270 --> 00:11:53,420
accessories be used continue to work

308
00:11:49,670 --> 00:11:55,130
without any issue but an option ROM that

309
00:11:53,420 --> 00:11:56,899
tries to say for example allow me to

310
00:11:55,130 --> 00:11:58,730
write to the NVRA interface which stores

311
00:11:56,899 --> 00:12:00,050
security configuration would simply be

312
00:11:58,730 --> 00:12:03,620
denied but the option arm the sandbox

313
00:12:00,050 --> 00:12:05,060
meanwhile the first two option roms that

314
00:12:03,620 --> 00:12:06,440
are just saying I'm a driver for the

315
00:12:05,060 --> 00:12:09,020
piece of hardware I came with are

316
00:12:06,440 --> 00:12:10,670
allowed through the third one continue

317
00:12:09,020 --> 00:12:11,839
to try to misbehave says I'm a secure

318
00:12:10,670 --> 00:12:13,610
booth driver that's what I'm trying to

319
00:12:11,839 --> 00:12:17,870
publish the option i'm sandbox is going

320
00:12:13,610 --> 00:12:19,310
to block this as well the easiest way to

321
00:12:17,870 --> 00:12:21,200
think about this is that the first thing

322
00:12:19,310 --> 00:12:23,540
the optional sandbox does is restrict

323
00:12:21,200 --> 00:12:25,370
the option ramp to only be able to talk

324
00:12:23,540 --> 00:12:26,930
to the device in its sandbox which is

325
00:12:25,370 --> 00:12:30,320
the device that the option run came with

326
00:12:26,930 --> 00:12:34,060
and this we PD policy continues to allow

327
00:12:30,320 --> 00:12:35,900
DMA between the device in its option ROM

328
00:12:34,060 --> 00:12:37,910
preserving the high throughput property

329
00:12:35,900 --> 00:12:39,529
that we wanted from DMA and the Oram

330
00:12:37,910 --> 00:12:42,949
doesn't haven't even have to be VPD

331
00:12:39,529 --> 00:12:44,570
aware so I want to show you what this

332
00:12:42,950 --> 00:12:54,529
looks like very quickly can we switch

333
00:12:44,570 --> 00:12:56,300
the demo please okay what I have here is

334
00:12:54,529 --> 00:12:58,730
the Intel simek's full system simulation

335
00:12:56,300 --> 00:13:01,189
environment and I've booted it to a

336
00:12:58,730 --> 00:13:03,290
point where we are simulating that a

337
00:13:01,190 --> 00:13:05,450
malicious accessory is plugged in and

338
00:13:03,290 --> 00:13:07,610
has a malicious option ROM so you can

339
00:13:05,450 --> 00:13:09,709
see the entries at the bottom left this

340
00:13:07,610 --> 00:13:12,500
is where option arm started to run it

341
00:13:09,709 --> 00:13:14,959
located that it has access to 568

342
00:13:12,500 --> 00:13:17,480
handles in the ufi environment and close

343
00:13:14,959 --> 00:13:19,250
to 1500 published protocols it was able

344
00:13:17,480 --> 00:13:21,650
to go through them and locate the one

345
00:13:19,250 --> 00:13:22,499
for Apple secure boot and find its

346
00:13:21,650 --> 00:13:24,468
address

347
00:13:22,499 --> 00:13:26,699
and the interesting thing here is that

348
00:13:24,469 --> 00:13:29,279
if we look at the current protection

349
00:13:26,699 --> 00:13:30,959
level you'll see that this malware where

350
00:13:29,279 --> 00:13:38,549
we have a breakpoint is running in ring

351
00:13:30,959 --> 00:13:40,199
zero so if we now continue booting the

352
00:13:38,549 --> 00:13:41,639
malware will proceed and find our target

353
00:13:40,199 --> 00:13:45,238
function the target function in this

354
00:13:41,639 --> 00:13:47,159
case is the firmware password screen and

355
00:13:45,239 --> 00:13:49,649
the function that validates whether the

356
00:13:47,159 --> 00:13:50,789
correct firmware password was entered so

357
00:13:49,649 --> 00:13:56,759
let me show you what that looks like as

358
00:13:50,789 --> 00:13:58,739
well if I disassemble at that address

359
00:13:56,759 --> 00:14:00,029
that the malware found you see basically

360
00:13:58,739 --> 00:14:03,059
call to the function that will validate

361
00:14:00,029 --> 00:14:04,829
the password it will make sure that zero

362
00:14:03,059 --> 00:14:06,299
is reached zero success and if it's not

363
00:14:04,829 --> 00:14:09,839
it's gonna jump elsewhere and say the

364
00:14:06,299 --> 00:14:11,759
password was not correct but if I let

365
00:14:09,839 --> 00:14:13,349
the malware continue to run it'll go and

366
00:14:11,759 --> 00:14:15,809
modify its target and if we now

367
00:14:13,349 --> 00:14:17,189
disassemble the very same address you'll

368
00:14:15,809 --> 00:14:18,629
see that this was completely patched out

369
00:14:17,189 --> 00:14:20,759
and replaced with something that'll

370
00:14:18,629 --> 00:14:23,159
allow any password to go through indeed

371
00:14:20,759 --> 00:14:26,099
if we continue execution this is our

372
00:14:23,159 --> 00:14:28,229
malware firmware password screen that's

373
00:14:26,099 --> 00:14:32,189
our hacker Mallory wearing a black hat

374
00:14:28,229 --> 00:14:38,729
and I can type any password into the

375
00:14:32,189 --> 00:14:44,639
screen and boot will continue as if I

376
00:14:38,729 --> 00:14:46,019
supplied the correct password we're

377
00:14:44,639 --> 00:14:47,759
going to bring up simek's now in a

378
00:14:46,019 --> 00:14:51,899
different configuration we're going to

379
00:14:47,759 --> 00:14:54,059
say same situation but in a piece of

380
00:14:51,899 --> 00:14:56,999
unified that is running our option

381
00:14:54,059 --> 00:15:00,738
around sandbox we expect a pretty

382
00:14:56,999 --> 00:15:03,569
different situation here for one thing

383
00:15:00,739 --> 00:15:05,879
we expect the bring the current

384
00:15:03,569 --> 00:15:07,618
protection level to be different we also

385
00:15:05,879 --> 00:15:09,239
expect that simply the number of

386
00:15:07,619 --> 00:15:10,829
interfaces that will be published and

387
00:15:09,239 --> 00:15:12,479
available to the malware is

388
00:15:10,829 --> 00:15:14,488
substantially different than what we saw

389
00:15:12,479 --> 00:15:17,339
before and indeed here we are the

390
00:15:14,489 --> 00:15:18,689
malware is now running if I look at the

391
00:15:17,339 --> 00:15:19,949
current protection level we are no

392
00:15:18,689 --> 00:15:22,589
longer in ring zero we are deep

393
00:15:19,949 --> 00:15:24,269
privileged in ring 3 you'll notice that

394
00:15:22,589 --> 00:15:25,829
the malware tried to enumerate to every

395
00:15:24,269 --> 00:15:28,859
handle and protocol available and found

396
00:15:25,829 --> 00:15:32,059
three and six down from nearly 500 and

397
00:15:28,859 --> 00:15:34,710
1500 which is just a massive surface

398
00:15:32,059 --> 00:15:36,719
attack surface area reduction

399
00:15:34,710 --> 00:15:38,340
and finally when tried to find at the

400
00:15:36,720 --> 00:15:40,230
Apple secure booth protocol in order to

401
00:15:38,340 --> 00:15:44,520
try and patch it it just couldn't find

402
00:15:40,230 --> 00:15:45,960
it when the den tried to blindly patch

403
00:15:44,520 --> 00:15:48,300
something it took a page fault and

404
00:15:45,960 --> 00:15:49,770
simply couldn't do anything we're now at

405
00:15:48,300 --> 00:15:51,420
the real firmware screen it was not able

406
00:15:49,770 --> 00:15:55,650
to patch any of that and if I try an

407
00:15:51,420 --> 00:15:57,959
arbitrary password in this screen it's

408
00:15:55,650 --> 00:16:10,439
simply rejected thank you back the main

409
00:15:57,960 --> 00:16:12,210
machine of course what option on the

410
00:16:10,440 --> 00:16:13,980
sandbox means is that attackers will be

411
00:16:12,210 --> 00:16:15,840
driven now the privilege escalation

412
00:16:13,980 --> 00:16:17,400
attacks in sandbox escapes so we didn't

413
00:16:15,840 --> 00:16:19,890
stop here we added a strong set of

414
00:16:17,400 --> 00:16:21,930
exploit mitigations to efi on d2 systems

415
00:16:19,890 --> 00:16:24,150
that's everything from stack cookies

416
00:16:21,930 --> 00:16:25,699
maps map and even suspect her and mel

417
00:16:24,150 --> 00:16:28,380
down mitigations

418
00:16:25,700 --> 00:16:30,720
in short the ppph security trip let us

419
00:16:28,380 --> 00:16:32,370
take some key secure boot properties

420
00:16:30,720 --> 00:16:34,020
from our iOS secure booth bring them to

421
00:16:32,370 --> 00:16:37,920
the Mac and far out class UEFI secure

422
00:16:34,020 --> 00:16:40,500
booth based systems we also built DMA

423
00:16:37,920 --> 00:16:42,270
protections for PCIe bus 0 which are

424
00:16:40,500 --> 00:16:44,400
state-of-the-art protection against DMA

425
00:16:42,270 --> 00:16:46,620
attacks targeting firmware in fact we

426
00:16:44,400 --> 00:16:48,240
are the first company to do this as well

427
00:16:46,620 --> 00:16:50,100
as the Mac around sandbox which provides

428
00:16:48,240 --> 00:16:53,220
a new and novel defense against

429
00:16:50,100 --> 00:16:56,450
malicious option roms here again we were

430
00:16:53,220 --> 00:16:58,460
the first to build a system like this

431
00:16:56,450 --> 00:17:03,360
I'm gonna switch gears and talk about

432
00:16:58,460 --> 00:17:05,430
iOS code integrity protection iOS has

433
00:17:03,360 --> 00:17:08,579
always had code integrity protection

434
00:17:05,430 --> 00:17:11,490
since day one both were Uslan and for

435
00:17:08,579 --> 00:17:13,708
kernel but before iOS 9 this was a

436
00:17:11,490 --> 00:17:16,020
software only protection the check was

437
00:17:13,709 --> 00:17:19,500
done only at booth and a single kernel

438
00:17:16,020 --> 00:17:23,730
ride gadget was able to fully disable

439
00:17:19,500 --> 00:17:25,410
the system so with iOS 9 we said we

440
00:17:23,730 --> 00:17:27,870
wanted to take a harder look at a

441
00:17:25,410 --> 00:17:30,480
stronger kernel integrity protection

442
00:17:27,869 --> 00:17:33,389
mechanism and we specifically wanted to

443
00:17:30,480 --> 00:17:35,190
build something that could live with in

444
00:17:33,390 --> 00:17:37,290
the harshest threat model we could

445
00:17:35,190 --> 00:17:39,720
imagine with arbitrary kernel read write

446
00:17:37,290 --> 00:17:43,580
arbitrary instruction pointer control an

447
00:17:39,720 --> 00:17:43,580
arbitrary readwrite via DMA

448
00:17:44,340 --> 00:17:50,740
so v-0 was our soccer only prototype and

449
00:17:48,430 --> 00:17:54,400
the way it worked is by creating a

450
00:17:50,740 --> 00:17:56,260
secure l3 monitor that would create an

451
00:17:54,400 --> 00:17:58,930
array of Colonel page tables index

452
00:17:56,260 --> 00:18:00,810
hashes periodically would verify them in

453
00:17:58,930 --> 00:18:03,340
with panic if there was a mismatch and

454
00:18:00,810 --> 00:18:05,620
as we expected this was effective

455
00:18:03,340 --> 00:18:07,300
against long lived patches but a monitor

456
00:18:05,620 --> 00:18:10,419
like this is inherently vulnerable to

457
00:18:07,300 --> 00:18:12,430
racists which we knew so here's just

458
00:18:10,420 --> 00:18:14,290
what death monitor looks like you can

459
00:18:12,430 --> 00:18:17,920
see the matter code collecting all the

460
00:18:14,290 --> 00:18:19,960
hashes on the right and that's a fairly

461
00:18:17,920 --> 00:18:21,990
straightforward l3 implementation what's

462
00:18:19,960 --> 00:18:25,270
interesting about this use of yield tree

463
00:18:21,990 --> 00:18:28,060
is that it's pretty unusual yield tree

464
00:18:25,270 --> 00:18:31,120
does not get direct access to user land

465
00:18:28,060 --> 00:18:33,580
or kernel page tables so what we have to

466
00:18:31,120 --> 00:18:36,280
do instead is use the fact that l3 has

467
00:18:33,580 --> 00:18:39,070
access to floating-point instructions

468
00:18:36,280 --> 00:18:40,810
and interrupts to force the kernel to

469
00:18:39,070 --> 00:18:45,100
periodically trap into the monitor

470
00:18:40,810 --> 00:18:46,389
letting us go and do these checks this

471
00:18:45,100 --> 00:18:48,429
is an interesting prototype but we

472
00:18:46,390 --> 00:18:50,800
learned some pretty immediate tactical

473
00:18:48,430 --> 00:18:53,740
lessons from this which is as we knew

474
00:18:50,800 --> 00:18:56,020
inherently vulnerable to racist it's not

475
00:18:53,740 --> 00:18:57,250
enough to just protect code we also have

476
00:18:56,020 --> 00:19:01,389
to protect a bunch of critical data

477
00:18:57,250 --> 00:19:02,770
regions and it would be much easier to

478
00:19:01,390 --> 00:19:04,240
build a hardware architecture that

479
00:19:02,770 --> 00:19:05,770
actually supports our security

480
00:19:04,240 --> 00:19:08,560
requirements than trying to do this in

481
00:19:05,770 --> 00:19:10,030
the other direction so with iPhone 7 we

482
00:19:08,560 --> 00:19:12,879
introduced kernel integrity protection

483
00:19:10,030 --> 00:19:14,950
v1 and this was the first time that we

484
00:19:12,880 --> 00:19:16,960
built new hardware specifically tailored

485
00:19:14,950 --> 00:19:19,270
to our goals we had three key

486
00:19:16,960 --> 00:19:21,730
requirements for our threat model that

487
00:19:19,270 --> 00:19:23,379
we wanted to be met in Hardware the CPU

488
00:19:21,730 --> 00:19:25,480
would not allow any modification of

489
00:19:23,380 --> 00:19:27,670
kernel memory it would prevent any yell

490
00:19:25,480 --> 00:19:29,800
execution near one execution of non

491
00:19:27,670 --> 00:19:31,570
kernel memory and the memory controller

492
00:19:29,800 --> 00:19:34,510
would prevent DMA writes to the

493
00:19:31,570 --> 00:19:37,030
protected physical range so this is what

494
00:19:34,510 --> 00:19:39,450
that looks like and the important thing

495
00:19:37,030 --> 00:19:42,940
to realize about this is the MMU here is

496
00:19:39,450 --> 00:19:44,800
overriding page tables when it comes to

497
00:19:42,940 --> 00:19:46,750
how the kernel is mapped in other words

498
00:19:44,800 --> 00:19:48,730
the MMU will make it so that the kernel

499
00:19:46,750 --> 00:19:50,740
is only ever read only even if page

500
00:19:48,730 --> 00:19:56,560
tables say that it's in fact read and

501
00:19:50,740 --> 00:19:57,110
write this gave us a very strong design

502
00:19:56,560 --> 00:19:58,639
for code

503
00:19:57,110 --> 00:20:00,500
but it turned out that protecting data

504
00:19:58,640 --> 00:20:01,250
required quite a bit of additional

505
00:20:00,500 --> 00:20:03,920
finesse

506
00:20:01,250 --> 00:20:06,650
neither kernel integrity protection v-0

507
00:20:03,920 --> 00:20:08,840
nor v1 which I just showed you do

508
00:20:06,650 --> 00:20:11,000
anything to prevent modification of TTB

509
00:20:08,840 --> 00:20:12,830
r1 this is the register that tells the

510
00:20:11,000 --> 00:20:16,040
CPU where to actually find the kernels

511
00:20:12,830 --> 00:20:18,620
page tables and so in keep we one to

512
00:20:16,040 --> 00:20:20,510
protect against an attack on TTP r1 we

513
00:20:18,620 --> 00:20:22,250
have to set up a very very careful

514
00:20:20,510 --> 00:20:24,440
initialization sequence that makes sure

515
00:20:22,250 --> 00:20:26,150
that by the time the CPU is done

516
00:20:24,440 --> 00:20:28,280
initializing there remain no

517
00:20:26,150 --> 00:20:31,580
instructions that could be used by an

518
00:20:28,280 --> 00:20:33,020
attacker to modify TTB r1 we were able

519
00:20:31,580 --> 00:20:34,730
to do that but it required a pretty

520
00:20:33,020 --> 00:20:36,980
substantial rework of our kernel cache

521
00:20:34,730 --> 00:20:39,470
layout it also required build time

522
00:20:36,980 --> 00:20:41,150
checks that no tpb r1 right gadget was

523
00:20:39,470 --> 00:20:44,570
inadvertently introduced into the kernel

524
00:20:41,150 --> 00:20:46,490
cache the upside though is that it was

525
00:20:44,570 --> 00:20:48,710
very effective at protecting kernel it's

526
00:20:46,490 --> 00:20:51,020
code integrity there was only one known

527
00:20:48,710 --> 00:20:52,549
public bypass ever and it was a simple

528
00:20:51,020 --> 00:20:54,350
off by one error in a protection range

529
00:20:52,549 --> 00:21:03,440
calculation which we immediately

530
00:20:54,350 --> 00:21:05,418
addressed with iPhone 10s we decided to

531
00:21:03,440 --> 00:21:07,640
go further we took all the lessons from

532
00:21:05,419 --> 00:21:10,510
kit v1 and applied them to the next

533
00:21:07,640 --> 00:21:14,179
version of kernel integrity protection

534
00:21:10,510 --> 00:21:16,070
the key idea here is to vastly simplify

535
00:21:14,179 --> 00:21:18,530
the design and get something that is

536
00:21:16,070 --> 00:21:21,678
much more secure as a result so all the

537
00:21:18,530 --> 00:21:24,918
control bits that would allow changes to

538
00:21:21,679 --> 00:21:26,770
things like DTB r1 or DMM you are now

539
00:21:24,919 --> 00:21:29,450
guaranteed in the hardware as

540
00:21:26,770 --> 00:21:30,410
unmodifiable and this replaces our

541
00:21:29,450 --> 00:21:33,650
complicated the initialization

542
00:21:30,410 --> 00:21:35,900
instructions from KP one another thing

543
00:21:33,650 --> 00:21:37,520
we did in KP 2 is we vastly simplify the

544
00:21:35,900 --> 00:21:39,049
interaction with power management power

545
00:21:37,520 --> 00:21:41,179
management transitions frequently

546
00:21:39,049 --> 00:21:44,270
introduced brittleness or fragility into

547
00:21:41,179 --> 00:21:46,640
security properties and here keep me to

548
00:21:44,270 --> 00:21:48,410
simply preserved kernel integrity

549
00:21:46,640 --> 00:21:52,580
protection configuration across power

550
00:21:48,410 --> 00:21:55,010
management transitions in summary we

551
00:21:52,580 --> 00:21:57,110
gained robust enforcement of kernel code

552
00:21:55,010 --> 00:21:58,640
and the read-only data integrity with a

553
00:21:57,110 --> 00:22:00,799
hardware implementation that is tailored

554
00:21:58,640 --> 00:22:02,330
to software security requirements and

555
00:22:00,799 --> 00:22:04,190
this is something that only Apple can do

556
00:22:02,330 --> 00:22:06,500
because we control the silicon and we

557
00:22:04,190 --> 00:22:07,730
control the software in this feature

558
00:22:06,500 --> 00:22:09,530
ended up being a pretty critical

559
00:22:07,730 --> 00:22:11,080
foundation for the next generation of

560
00:22:09,530 --> 00:22:13,670
our security features

561
00:22:11,080 --> 00:22:15,679
one thing we learned when building Kip

562
00:22:13,670 --> 00:22:17,900
is that we could benefit from another

563
00:22:15,680 --> 00:22:19,550
kind of CPU primitive this is something

564
00:22:17,900 --> 00:22:23,840
we call fast permission restrictions or

565
00:22:19,550 --> 00:22:25,490
APR are in the chip in iPhone 10 the way

566
00:22:23,840 --> 00:22:27,889
to think about this is it's a CPU

567
00:22:25,490 --> 00:22:32,510
register to very quickly take a piece of

568
00:22:27,890 --> 00:22:34,820
memory that is rwx and restrict it to a

569
00:22:32,510 --> 00:22:37,190
more restrictive configuration per

570
00:22:34,820 --> 00:22:38,929
thread by doing it this way where the

571
00:22:37,190 --> 00:22:41,300
processor register we don't have to take

572
00:22:38,930 --> 00:22:43,010
a syst call we don't have to take at the

573
00:22:41,300 --> 00:22:44,990
time to walk page tables and flush them

574
00:22:43,010 --> 00:22:46,370
just to change permissions which is a

575
00:22:44,990 --> 00:22:48,830
really substantial performance

576
00:22:46,370 --> 00:22:51,290
improvement so here's what this looks

577
00:22:48,830 --> 00:22:53,419
like in practice before APR existed this

578
00:22:51,290 --> 00:22:55,670
is a memory diagram of a process that

579
00:22:53,420 --> 00:22:57,380
relies in the JavaScript for JIT and

580
00:22:55,670 --> 00:23:01,280
you'll see that the JIT memory is mapped

581
00:22:57,380 --> 00:23:03,290
read write and execute with a PR R what

582
00:23:01,280 --> 00:23:07,310
we do is only for JavaScript core

583
00:23:03,290 --> 00:23:09,590
execution threads do we set a non write

584
00:23:07,310 --> 00:23:11,690
APR our mask which means that the DOS

585
00:23:09,590 --> 00:23:13,820
threads have effectively only read and

586
00:23:11,690 --> 00:23:15,590
execute access to the region whereas of

587
00:23:13,820 --> 00:23:21,830
course the JIT compiler sets a no

588
00:23:15,590 --> 00:23:23,720
execute mask giving it read and write so

589
00:23:21,830 --> 00:23:28,159
that's great but what about protecting

590
00:23:23,720 --> 00:23:31,280
userland code integrity tip gives us a

591
00:23:28,160 --> 00:23:34,430
very strong mechanism for kernel text

592
00:23:31,280 --> 00:23:36,379
but it does this with the MMU relying on

593
00:23:34,430 --> 00:23:38,870
being able to override page tables

594
00:23:36,380 --> 00:23:39,920
because kernel code is static user

595
00:23:38,870 --> 00:23:42,020
length code is not static it's

596
00:23:39,920 --> 00:23:45,740
dynamically loaded we would somehow need

597
00:23:42,020 --> 00:23:47,240
some kind of dynamic override so with

598
00:23:45,740 --> 00:23:50,450
iPhone 10s who introduced the page

599
00:23:47,240 --> 00:23:52,040
protection layer or ppl it ensures that

600
00:23:50,450 --> 00:23:53,870
user length code cannot be modified

601
00:23:52,040 --> 00:23:55,940
after a signature check completes it

602
00:23:53,870 --> 00:23:57,889
builds on top of the other hardware

603
00:23:55,940 --> 00:23:59,690
mechanisms we've built before and it

604
00:23:57,890 --> 00:24:01,820
basically hoists management of page

605
00:23:59,690 --> 00:24:04,700
tables and code signing validation into

606
00:24:01,820 --> 00:24:07,820
a very very small trusted computing base

607
00:24:04,700 --> 00:24:09,740
that is tightly audited it guarantees

608
00:24:07,820 --> 00:24:11,210
that only code running within the page

609
00:24:09,740 --> 00:24:14,450
protection layer can actually alter

610
00:24:11,210 --> 00:24:17,810
these protected pages so this is pretty

611
00:24:14,450 --> 00:24:20,179
interesting here's what it does it takes

612
00:24:17,810 --> 00:24:21,460
kernel code and basically splits it into

613
00:24:20,179 --> 00:24:24,310
two worlds

614
00:24:21,460 --> 00:24:28,390
ppl code as well as its heap and data

615
00:24:24,310 --> 00:24:31,690
page tables are simply not writable

616
00:24:28,390 --> 00:24:35,550
during normal execution in fact ppl code

617
00:24:31,690 --> 00:24:37,540
is not even executable it's read-only

618
00:24:35,550 --> 00:24:39,370
then we have the special pair of

619
00:24:37,540 --> 00:24:41,980
trampolines that can be used to

620
00:24:39,370 --> 00:24:43,330
transition into ppl mode but in a very

621
00:24:41,980 --> 00:24:45,430
carefully controlled fashion

622
00:24:43,330 --> 00:24:49,929
deathtrap alene for example prevent a

623
00:24:45,430 --> 00:24:51,730
rabbit AK from entering ppl once we

624
00:24:49,930 --> 00:24:54,010
enter ppl mode through the trampoline

625
00:24:51,730 --> 00:24:57,040
which verifies that the trampoline fully

626
00:24:54,010 --> 00:25:00,550
completed executing we suddenly flip our

627
00:24:57,040 --> 00:25:03,159
ppl data in page tables using a prr to

628
00:25:00,550 --> 00:25:05,169
be both readable and writeable and we

629
00:25:03,160 --> 00:25:06,580
can turn ppl code into executable code

630
00:25:05,170 --> 00:25:09,070
that can go and make whatever changes

631
00:25:06,580 --> 00:25:11,260
are necessary once that code finishes

632
00:25:09,070 --> 00:25:13,689
running we can exit ppl mode and restore

633
00:25:11,260 --> 00:25:18,490
normal kernel mode in a way that's fully

634
00:25:13,690 --> 00:25:20,650
validated the page protection layer in

635
00:25:18,490 --> 00:25:22,240
short gives us something pretty amazing

636
00:25:20,650 --> 00:25:24,280
it gives a system-wide dynamic code

637
00:25:22,240 --> 00:25:27,250
integrity enforcement even under the

638
00:25:24,280 --> 00:25:28,930
assumption of a compromised kernel and

639
00:25:27,250 --> 00:25:30,790
it provides a massive attack surface

640
00:25:28,930 --> 00:25:33,460
reduction for code signing validation

641
00:25:30,790 --> 00:25:35,320
and page table management on top of that

642
00:25:33,460 --> 00:25:37,030
it does this all with really low

643
00:25:35,320 --> 00:25:39,460
overhead there are no hypervisor traps

644
00:25:37,030 --> 00:25:41,500
there's no nested page tables it's very

645
00:25:39,460 --> 00:25:51,100
very fast because we were able to build

646
00:25:41,500 --> 00:25:52,870
this into our silicon now we're in a

647
00:25:51,100 --> 00:25:54,429
pretty good place about code integrity

648
00:25:52,870 --> 00:25:59,530
both in kernel and in userland

649
00:25:54,430 --> 00:26:04,510
but what about control flow last year

650
00:25:59,530 --> 00:26:07,090
with iOS 12 we build support in iPhone

651
00:26:04,510 --> 00:26:09,129
10s for RB 8 point 3 pointer

652
00:26:07,090 --> 00:26:10,629
authentication instructions these are

653
00:26:09,130 --> 00:26:11,920
instructions that basically use spare

654
00:26:10,630 --> 00:26:14,410
bits and a pointer to store a

655
00:26:11,920 --> 00:26:15,880
cryptographic hash and this mechanism is

656
00:26:14,410 --> 00:26:17,440
designed to be robust in the presence of

657
00:26:15,880 --> 00:26:18,880
even arbitrary readwrite primitives so

658
00:26:17,440 --> 00:26:21,310
let me give you an intuitive sense for

659
00:26:18,880 --> 00:26:23,010
how this works there's a set of keys and

660
00:26:21,310 --> 00:26:25,179
I'll explain more about them in a moment

661
00:26:23,010 --> 00:26:27,700
one of them is selected for the write

662
00:26:25,180 --> 00:26:29,440
operation a pointer is taken optional

663
00:26:27,700 --> 00:26:30,970
with some extra data for diversification

664
00:26:29,440 --> 00:26:33,280
that's all passed into an encryption

665
00:26:30,970 --> 00:26:34,930
function which produces signature which

666
00:26:33,280 --> 00:26:36,460
we use to generate our sign pointers

667
00:26:34,930 --> 00:26:37,960
here's the premise this is a real

668
00:26:36,460 --> 00:26:40,480
pointer really if you look at it it has

669
00:26:37,960 --> 00:26:42,550
an address and some padding so a sign

670
00:26:40,480 --> 00:26:44,820
operation will go perform the signature

671
00:26:42,550 --> 00:26:47,409
stop the signature into the padding a

672
00:26:44,820 --> 00:26:49,360
later authenticate operation will check

673
00:26:47,410 --> 00:26:51,100
whether that signature is correct and if

674
00:26:49,360 --> 00:26:53,169
it is it will just zero it out which

675
00:26:51,100 --> 00:26:57,629
will turn this pointer back into a valid

676
00:26:53,170 --> 00:26:59,740
pointer if the signature check fails

677
00:26:57,630 --> 00:27:02,920
instead of zeroing the South we will

678
00:26:59,740 --> 00:27:05,110
leave the high bit set which turn this

679
00:27:02,920 --> 00:27:06,610
into an invalid pointer it's a pointer

680
00:27:05,110 --> 00:27:11,560
that the next time is the referenced

681
00:27:06,610 --> 00:27:12,729
will simply crash we do this with five

682
00:27:11,560 --> 00:27:17,139
different keys

683
00:27:12,730 --> 00:27:18,820
ia IB da DB and G a the way to the cheat

684
00:27:17,140 --> 00:27:22,390
sheet here is I keys our instruction

685
00:27:18,820 --> 00:27:24,820
keys D Keys our data Keys and then a

686
00:27:22,390 --> 00:27:27,340
keys are generated randomly at boot

687
00:27:24,820 --> 00:27:29,860
versus B keys which are generated I knew

688
00:27:27,340 --> 00:27:32,590
every time a process is created the

689
00:27:29,860 --> 00:27:34,719
reason that a keys are generated once at

690
00:27:32,590 --> 00:27:37,810
boot and then reused across processes is

691
00:27:34,720 --> 00:27:41,110
because iOS being a mobile environment

692
00:27:37,810 --> 00:27:42,970
that is memory constrained takes a

693
00:27:41,110 --> 00:27:44,889
strong set of performance optimizations

694
00:27:42,970 --> 00:27:47,260
in the form of D Wildey shared cache and

695
00:27:44,890 --> 00:27:49,510
many other ways to basically map the

696
00:27:47,260 --> 00:27:52,660
same code into every userland process

697
00:27:49,510 --> 00:27:55,000
and so if we insisted on not having any

698
00:27:52,660 --> 00:27:56,590
shared point our dedication keys across

699
00:27:55,000 --> 00:27:58,870
different processes we would be paying

700
00:27:56,590 --> 00:28:00,669
an unacceptable memory overhead of many

701
00:27:58,870 --> 00:28:03,310
megabytes just to have the system

702
00:28:00,670 --> 00:28:04,930
running ultimately these keys because

703
00:28:03,310 --> 00:28:06,700
they're backed by hardware are not

704
00:28:04,930 --> 00:28:09,700
readable by an attacker regardless of

705
00:28:06,700 --> 00:28:11,680
the level of privilege so what do we do

706
00:28:09,700 --> 00:28:14,260
with this well

707
00:28:11,680 --> 00:28:16,390
we protect a number of types of pointers

708
00:28:14,260 --> 00:28:19,180
to code here you see for each one of

709
00:28:16,390 --> 00:28:20,860
these what kind of key is used and then

710
00:28:19,180 --> 00:28:25,930
on the right hand side you see what is

711
00:28:20,860 --> 00:28:29,439
used for diversification here's a again

712
00:28:25,930 --> 00:28:31,690
intuitive example this is before back we

713
00:28:29,440 --> 00:28:33,160
have a function Prolog would normally

714
00:28:31,690 --> 00:28:34,600
store the link register on the stack we

715
00:28:33,160 --> 00:28:36,910
would run the function at the end we

716
00:28:34,600 --> 00:28:40,449
would restore the link register and we

717
00:28:36,910 --> 00:28:42,190
would return to it which pack we add

718
00:28:40,450 --> 00:28:43,510
this pair of instructions the first of

719
00:28:42,190 --> 00:28:45,880
them you see in the upper right hand

720
00:28:43,510 --> 00:28:48,250
corner basically says hey take the link

721
00:28:45,880 --> 00:28:51,010
register use the IB

722
00:28:48,250 --> 00:28:52,990
is the per process code key in the

723
00:28:51,010 --> 00:28:56,460
storage address of this specific thing

724
00:28:52,990 --> 00:28:58,840
on the stack as a diversifier signed apt

725
00:28:56,460 --> 00:29:01,480
so that when we're finished executing a

726
00:28:58,840 --> 00:29:03,220
single instruction will both verify that

727
00:29:01,480 --> 00:29:08,590
the signature is correct and return to

728
00:29:03,220 --> 00:29:10,570
it we don't just protect code with this

729
00:29:08,590 --> 00:29:14,050
we also protect pointers to data and

730
00:29:10,570 --> 00:29:16,330
pointers to code via data so these are

731
00:29:14,050 --> 00:29:19,350
some of the most important ones we don't

732
00:29:16,330 --> 00:29:22,300
want an attacker to be able to redirect

733
00:29:19,350 --> 00:29:24,399
kernel code flow by waiting until an

734
00:29:22,300 --> 00:29:26,169
exception is being taken in kernel

735
00:29:24,400 --> 00:29:27,730
thread state is being spilled and then

736
00:29:26,170 --> 00:29:31,480
simply overriding that kernel thread

737
00:29:27,730 --> 00:29:33,040
state so to fix that we sign and hash a

738
00:29:31,480 --> 00:29:34,750
number of items in the kernel thread

739
00:29:33,040 --> 00:29:37,600
States to prevent modification during

740
00:29:34,750 --> 00:29:39,280
the exception handler the other one

741
00:29:37,600 --> 00:29:42,760
that's interesting here is C++ vtable

742
00:29:39,280 --> 00:29:45,129
pointers we use PAC to protect both c++

743
00:29:42,760 --> 00:29:46,480
me table pointers and entries which is

744
00:29:45,130 --> 00:29:49,180
interesting because it has an additional

745
00:29:46,480 --> 00:29:51,010
property over just control flow

746
00:29:49,180 --> 00:29:53,590
integrity it's actually a very effective

747
00:29:51,010 --> 00:29:59,140
mitigation against use after free

748
00:29:53,590 --> 00:30:01,149
attacks on C++ objects not only could an

749
00:29:59,140 --> 00:30:03,370
attacker no longer fake a V table

750
00:30:01,150 --> 00:30:07,480
pointer during exploitation of a user at

751
00:30:03,370 --> 00:30:10,840
the free bug but we actually record the

752
00:30:07,480 --> 00:30:13,150
intended prototype of a function and to

753
00:30:10,840 --> 00:30:15,010
make sure during signature checking that

754
00:30:13,150 --> 00:30:16,630
the thing that we're actually going to

755
00:30:15,010 --> 00:30:18,340
jump to matches that prototype which

756
00:30:16,630 --> 00:30:24,190
means that type confusion attacks are

757
00:30:18,340 --> 00:30:26,679
very very difficult we first shipped

758
00:30:24,190 --> 00:30:28,900
this type on 10s and iOS 12 but in iOS

759
00:30:26,680 --> 00:30:31,420
13 we have been firing on all cylinders

760
00:30:28,900 --> 00:30:35,340
in getting broad adoption of pack across

761
00:30:31,420 --> 00:30:37,510
different parts of the system in iOS 13

762
00:30:35,340 --> 00:30:40,689
authentication failures failures in pack

763
00:30:37,510 --> 00:30:42,460
during kernel execution abort they no

764
00:30:40,690 --> 00:30:44,260
longer just generate an invalid pointer

765
00:30:42,460 --> 00:30:45,310
that will later be the reference they

766
00:30:44,260 --> 00:30:47,410
cause a full abort

767
00:30:45,310 --> 00:30:49,389
we have adoption across every Apple text

768
00:30:47,410 --> 00:30:50,800
we've hardened our jump tables we've

769
00:30:49,390 --> 00:30:52,570
hardened our objective-c message

770
00:30:50,800 --> 00:30:54,700
dispatch handling we've hardened our

771
00:30:52,570 --> 00:30:57,250
exception handlers and in JavaScript or

772
00:30:54,700 --> 00:30:59,620
JIT and extra data with yours throughout

773
00:30:57,250 --> 00:31:02,580
to increase the protection level on

774
00:30:59,620 --> 00:31:02,580
JavaScript core as well

775
00:31:02,890 --> 00:31:09,500
in a future software update to iOS 13 we

776
00:31:06,440 --> 00:31:12,740
are going to start also signing high

777
00:31:09,500 --> 00:31:14,780
value data structures not code not

778
00:31:12,740 --> 00:31:16,700
pointers just data structures that are

779
00:31:14,780 --> 00:31:18,080
really high value to potential attackers

780
00:31:16,700 --> 00:31:21,490
so that's everything from processes and

781
00:31:18,080 --> 00:31:23,090
tasks to code signing structure members

782
00:31:21,490 --> 00:31:35,179
structures in the virtual memory

783
00:31:23,090 --> 00:31:36,889
subsystem in certain IPC structures well

784
00:31:35,179 --> 00:31:41,059
but not least I want to talk about find

785
00:31:36,890 --> 00:31:43,640
mine this is a new feature that feels

786
00:31:41,059 --> 00:31:45,678
like a bit of practical magic we want to

787
00:31:43,640 --> 00:31:48,050
help users be able to find their lost

788
00:31:45,679 --> 00:31:50,510
devices even when those devices are

789
00:31:48,050 --> 00:31:53,629
offline we want to make it the case that

790
00:31:50,510 --> 00:31:56,150
any device in proximity can help find a

791
00:31:53,630 --> 00:31:58,010
lost device even if that device belonged

792
00:31:56,150 --> 00:32:00,830
to someone who is a complete stranger to

793
00:31:58,010 --> 00:32:02,450
the owner so the way we want to do this

794
00:32:00,830 --> 00:32:04,250
is to have offline devices communicate

795
00:32:02,450 --> 00:32:05,900
via bluetooth with any participating

796
00:32:04,250 --> 00:32:08,150
stranger who might be a finder in this

797
00:32:05,900 --> 00:32:10,880
case these finders would then report

798
00:32:08,150 --> 00:32:12,679
their location in the time stamp and the

799
00:32:10,880 --> 00:32:17,360
owner would use their second device to

800
00:32:12,679 --> 00:32:18,740
find the last device doing this in the

801
00:32:17,360 --> 00:32:20,659
straightforward way the way it's been

802
00:32:18,740 --> 00:32:22,820
traditionally done doesn't work if you

803
00:32:20,660 --> 00:32:24,530
assign a static identifier to a device

804
00:32:22,820 --> 00:32:27,260
that it kept broadcasting you could just

805
00:32:24,530 --> 00:32:29,059
track that device anywhere it moves and

806
00:32:27,260 --> 00:32:30,379
even if you rotated the identifier the

807
00:32:29,059 --> 00:32:32,240
finder would not actually be able to

808
00:32:30,380 --> 00:32:33,980
encrypt location end to end which means

809
00:32:32,240 --> 00:32:35,929
that whatever server was being contacted

810
00:32:33,980 --> 00:32:40,670
would actually have access to all of

811
00:32:35,929 --> 00:32:42,470
this location information we had a much

812
00:32:40,670 --> 00:32:44,630
more rigorous set of security and

813
00:32:42,470 --> 00:32:46,520
privacy goals we wanted to make sure

814
00:32:44,630 --> 00:32:48,860
that location reports are not accessible

815
00:32:46,520 --> 00:32:50,540
to Apple servers under any circumstances

816
00:32:48,860 --> 00:32:53,149
that Apple service can neither read nor

817
00:32:50,540 --> 00:32:55,428
modify nor even add bogus location

818
00:32:53,150 --> 00:32:57,500
reports we also wanted to protect

819
00:32:55,429 --> 00:32:59,390
finders both their identities and

820
00:32:57,500 --> 00:33:01,250
location in a way that's never revealed

821
00:32:59,390 --> 00:33:02,929
to Apple servers we wouldn't want to

822
00:33:01,250 --> 00:33:04,220
record any finder identities and we'd

823
00:33:02,929 --> 00:33:05,660
want to make sure that any reported

824
00:33:04,220 --> 00:33:08,750
location is encrypted in a way that

825
00:33:05,660 --> 00:33:10,820
Apple service cannot read lastly we want

826
00:33:08,750 --> 00:33:13,550
to make sure that whatever data a device

827
00:33:10,820 --> 00:33:14,658
is broadcasting when lost cannot be used

828
00:33:13,550 --> 00:33:19,129
to track it

829
00:33:14,659 --> 00:33:24,679
except by the owner so how does this

830
00:33:19,129 --> 00:33:26,570
work each device undergoes a setup

831
00:33:24,679 --> 00:33:28,399
procedure it generates an illiquid

832
00:33:26,570 --> 00:33:31,340
elliptic curve p224

833
00:33:28,399 --> 00:33:34,189
key pair and as well as a symmetric key

834
00:33:31,340 --> 00:33:36,080
in stores all of this in iCloud keychain

835
00:33:34,190 --> 00:33:39,529
where every other device belonging to

836
00:33:36,080 --> 00:33:40,728
the same user can access them the use of

837
00:33:39,529 --> 00:33:43,220
p224

838
00:33:40,729 --> 00:33:45,830
is key here because it generates a 28

839
00:33:43,220 --> 00:33:49,609
byte public key which means we can just

840
00:33:45,830 --> 00:33:54,399
barely stop it in the 32 byte packet

841
00:33:49,609 --> 00:33:54,399
limit for Bluetooth under version 5.0

842
00:33:54,460 --> 00:33:59,149
when a device wants to broadcast its

843
00:33:56,720 --> 00:34:01,369
location it figures out the current time

844
00:33:59,149 --> 00:34:04,428
period which for us is 15 minutes long

845
00:34:01,369 --> 00:34:06,228
and derives a symmetric key from the

846
00:34:04,429 --> 00:34:09,260
original symmetric key that is specific

847
00:34:06,229 --> 00:34:13,789
to this time period the KDF diffused

848
00:34:09,260 --> 00:34:16,940
here is ansi x9 63 with sha-256 if

849
00:34:13,789 --> 00:34:19,069
you're curious and the broadcasting

850
00:34:16,940 --> 00:34:22,309
device also drives an anti tracking

851
00:34:19,069 --> 00:34:24,469
secret pair which is in turn used to

852
00:34:22,309 --> 00:34:26,779
unlink ibly diversify the original

853
00:34:24,469 --> 00:34:29,089
public key every 15 minutes in other

854
00:34:26,779 --> 00:34:30,649
words every 15 minutes a new public key

855
00:34:29,089 --> 00:34:32,779
is generated that even though it is

856
00:34:30,649 --> 00:34:35,089
clearly connected to the original public

857
00:34:32,779 --> 00:34:36,770
key no one except the owner of that key

858
00:34:35,089 --> 00:34:39,469
pair can figure out that these are

859
00:34:36,770 --> 00:34:42,109
linked finally it is this unlink ibly

860
00:34:39,469 --> 00:34:44,000
diversified public key specific to this

861
00:34:42,109 --> 00:34:48,230
15-minute time period that is broadcast

862
00:34:44,000 --> 00:34:50,960
and nearby finders when a finder

863
00:34:48,230 --> 00:34:54,949
receives a broadcast like this it does

864
00:34:50,960 --> 00:34:56,059
something called ici IES encryption to

865
00:34:54,949 --> 00:34:59,379
the public key that's being broadcast

866
00:34:56,059 --> 00:35:01,250
the way to think about EC is is its

867
00:34:59,380 --> 00:35:03,950
non-interactive elliptic curve

868
00:35:01,250 --> 00:35:05,539
diffie-hellman to the key as well as a

869
00:35:03,950 --> 00:35:08,210
symmetric key derivation and finally an

870
00:35:05,539 --> 00:35:11,480
encryption to that symmetric key in our

871
00:35:08,210 --> 00:35:14,029
case that's what al GCM the finder also

872
00:35:11,480 --> 00:35:16,160
takes this public key that it received

873
00:35:14,029 --> 00:35:18,349
it hashes it which turns into a lookup

874
00:35:16,160 --> 00:35:20,299
index and basically the finder will turn

875
00:35:18,349 --> 00:35:23,000
around and tell the Apple servers hey

876
00:35:20,299 --> 00:35:25,720
for this lookup index store this

877
00:35:23,000 --> 00:35:25,720
encrypted data

878
00:35:26,369 --> 00:35:31,349
when an owner then later tries to locate

879
00:35:29,009 --> 00:35:32,789
their lost device what they will do

880
00:35:31,349 --> 00:35:35,039
starting in the lower left-hand corner

881
00:35:32,789 --> 00:35:36,539
is first they will retrieve their

882
00:35:35,039 --> 00:35:39,359
original information from iCloud

883
00:35:36,539 --> 00:35:41,670
keychain they will start going backwards

884
00:35:39,359 --> 00:35:45,390
in time in 15-minute intervals from

885
00:35:41,670 --> 00:35:47,519
right now computing each diversified

886
00:35:45,390 --> 00:35:51,089
public key that was active for that

887
00:35:47,519 --> 00:35:52,828
device in that 15 minute time period for

888
00:35:51,089 --> 00:35:55,109
each of those it will compute what

889
00:35:52,829 --> 00:35:57,989
lookup index that device would have been

890
00:35:55,109 --> 00:36:00,299
reported under and finally it will query

891
00:35:57,989 --> 00:36:02,940
the Apple Server database and say hey do

892
00:36:00,299 --> 00:36:04,859
you have a report for this index if the

893
00:36:02,940 --> 00:36:07,140
answer is yes the report comes back as

894
00:36:04,859 --> 00:36:10,440
an encrypted blob which the owner can

895
00:36:07,140 --> 00:36:14,509
now easy is decrypt to retrieve the

896
00:36:10,440 --> 00:36:14,509
location timeline of their lost device I

897
00:36:15,829 --> 00:36:21,779
love this because it's a novel design

898
00:36:18,569 --> 00:36:24,479
and it enables something that feels

899
00:36:21,779 --> 00:36:27,509
powerful which is to turn all of us into

900
00:36:24,479 --> 00:36:29,989
potential finders for Waze devices even

901
00:36:27,509 --> 00:36:31,950
though we don't know each other but the

902
00:36:29,989 --> 00:36:34,710
privacy properties that are maintained

903
00:36:31,950 --> 00:36:36,989
here are exceptionally rigorous both in

904
00:36:34,710 --> 00:36:40,200
terms of protection to device owners and

905
00:36:36,989 --> 00:36:43,460
finders in the devices themselves in

906
00:36:40,200 --> 00:36:43,460
their own track ability

907
00:36:51,270 --> 00:36:58,360
so here's what we talked about we built

908
00:36:56,920 --> 00:37:01,090
a world-class secure booth

909
00:36:58,360 --> 00:37:04,150
implementation for the Mac using the t2

910
00:37:01,090 --> 00:37:06,430
security chip and deployed a series of

911
00:37:04,150 --> 00:37:09,160
novel industry-first protections like

912
00:37:06,430 --> 00:37:12,549
PCIe bus 0 as well as the option around

913
00:37:09,160 --> 00:37:13,960
sandbox to significantly strengthen the

914
00:37:12,550 --> 00:37:16,030
secure boot process and deliver

915
00:37:13,960 --> 00:37:19,600
something that drives us to the level of

916
00:37:16,030 --> 00:37:23,050
meeting our requirements with the iOS

917
00:37:19,600 --> 00:37:25,270
code integrity protection we iterated on

918
00:37:23,050 --> 00:37:27,250
a series of approaches using our ability

919
00:37:25,270 --> 00:37:29,320
to build silicon in the right software

920
00:37:27,250 --> 00:37:31,150
until we converged on a set of

921
00:37:29,320 --> 00:37:33,990
mechanisms that give us very strong

922
00:37:31,150 --> 00:37:37,720
protection for kernel code and data

923
00:37:33,990 --> 00:37:39,910
userland code and lastly using pointer

924
00:37:37,720 --> 00:37:44,310
notification the ability to constrain

925
00:37:39,910 --> 00:37:44,310
control flow to exactly what is expected

926
00:37:44,790 --> 00:37:51,070
lastly we find my we took something that

927
00:37:48,610 --> 00:37:53,290
felt like it should be possible but for

928
00:37:51,070 --> 00:37:55,090
which traditional approaches were simply

929
00:37:53,290 --> 00:37:57,550
unacceptable to us from a privacy and

930
00:37:55,090 --> 00:37:59,500
security perspective and we found a way

931
00:37:57,550 --> 00:38:01,090
to meet those strong requirements and

932
00:37:59,500 --> 00:38:07,930
make this something that we can make

933
00:38:01,090 --> 00:38:13,120
available to everyone I'd like to share

934
00:38:07,930 --> 00:38:15,129
some news with you in 2016 at blackhat

935
00:38:13,120 --> 00:38:17,859
we introduced the Apple security bounty

936
00:38:15,130 --> 00:38:20,350
and what we did was very different than

937
00:38:17,860 --> 00:38:21,940
most bounties to the time instead of

938
00:38:20,350 --> 00:38:25,360
focusing on a wide variety of categories

939
00:38:21,940 --> 00:38:27,910
or trying to have many many reports from

940
00:38:25,360 --> 00:38:30,700
many people even if they're of low

941
00:38:27,910 --> 00:38:33,129
immediate impact we said we're going to

942
00:38:30,700 --> 00:38:35,799
focus on only the most high impact

943
00:38:33,130 --> 00:38:37,870
categories of vulnerabilities we're

944
00:38:35,800 --> 00:38:40,360
going to constrain our platforms to iOS

945
00:38:37,870 --> 00:38:43,089
and iCloud and we will invite a very

946
00:38:40,360 --> 00:38:46,090
small number of exceptional researchers

947
00:38:43,090 --> 00:38:49,030
to participate in this bounty program at

948
00:38:46,090 --> 00:38:53,410
the time our maximum payout of $200,000

949
00:38:49,030 --> 00:38:56,140
was the largest in the industry this has

950
00:38:53,410 --> 00:38:58,060
worked really well for us even though we

951
00:38:56,140 --> 00:39:00,759
focused on only the most high-impact

952
00:38:58,060 --> 00:39:03,100
vulnerabilities and invited only a very

953
00:39:00,760 --> 00:39:04,740
small number of researchers we received

954
00:39:03,100 --> 00:39:06,450
around 50 there

955
00:39:04,740 --> 00:39:11,520
high-value reports in these

956
00:39:06,450 --> 00:39:15,359
exceptionally critical categories but

957
00:39:11,520 --> 00:39:16,530
we'd like to take this further I'm happy

958
00:39:15,360 --> 00:39:18,300
to announce that the Apple security

959
00:39:16,530 --> 00:39:28,230
bounty will be open to all researchers

960
00:39:18,300 --> 00:39:31,350
in the fall thank you and we're going to

961
00:39:28,230 --> 00:39:35,640
expand our platforms as well from iCloud

962
00:39:31,350 --> 00:39:49,589
and iOS we're adding TV OS iPad OS and

963
00:39:35,640 --> 00:39:51,390
watch OS and Mac OS we have completely

964
00:39:49,590 --> 00:39:54,810
revised and expanded our bounty

965
00:39:51,390 --> 00:39:56,190
categories I'm not going to be showing

966
00:39:54,810 --> 00:39:57,930
you the whole list today but I will

967
00:39:56,190 --> 00:39:59,790
highlight some of the most important

968
00:39:57,930 --> 00:40:02,520
ones so this is our new list of

969
00:39:59,790 --> 00:40:04,619
top-level categories the iCloud category

970
00:40:02,520 --> 00:40:06,450
remains effectively unchanged but the

971
00:40:04,619 --> 00:40:09,690
device ID categories are now completely

972
00:40:06,450 --> 00:40:11,759
different they focus on attack via

973
00:40:09,690 --> 00:40:13,980
physical access attack via a user

974
00:40:11,760 --> 00:40:16,140
installed app a network attack that

975
00:40:13,980 --> 00:40:18,030
requires user interaction and lastly a

976
00:40:16,140 --> 00:40:21,839
network attack that requires no user

977
00:40:18,030 --> 00:40:23,580
interaction for each of these

978
00:40:21,840 --> 00:40:25,650
subcategories for each of these

979
00:40:23,580 --> 00:40:29,600
categories the maximum payout per

980
00:40:25,650 --> 00:40:33,570
subcategory will be $100,000 for iCloud

981
00:40:29,600 --> 00:40:36,810
up to $100,000 for lockscreen bypass up

982
00:40:33,570 --> 00:40:41,330
to 250,000 dollars for user data

983
00:40:36,810 --> 00:40:43,500
extraction via physical access up to

984
00:40:41,330 --> 00:40:45,569
$100,000 for unauthorized access to

985
00:40:43,500 --> 00:40:49,920
high-value user data from a user

986
00:40:45,570 --> 00:40:53,940
installed app up to 150,000 for kernel

987
00:40:49,920 --> 00:40:56,100
code execution and up to 250,000 for CPU

988
00:40:53,940 --> 00:41:01,109
side-channel attacks against current

989
00:40:56,100 --> 00:41:03,930
Apple silicon for one-click unauthorized

990
00:41:01,109 --> 00:41:07,770
access to high-value user data it'll be

991
00:41:03,930 --> 00:41:11,970
up to $150,000 for one-click kernel code

992
00:41:07,770 --> 00:41:14,790
execution up to 250,000 dollars and

993
00:41:11,970 --> 00:41:16,319
finally in the hardest category of

994
00:41:14,790 --> 00:41:18,580
network attacks with no user interaction

995
00:41:16,320 --> 00:41:19,780
a zero click radio the

996
00:41:18,580 --> 00:41:24,610
colonel with physical proximity

997
00:41:19,780 --> 00:41:26,680
escalation is up to $250,000 in the zero

998
00:41:24,610 --> 00:41:32,920
click access the high-value user data

999
00:41:26,680 --> 00:41:36,730
will be up to $500,000 we're going one

1000
00:41:32,920 --> 00:41:38,800
step further in certain pre-release

1001
00:41:36,730 --> 00:41:41,380
builds like beta releases that we make

1002
00:41:38,800 --> 00:41:44,170
available to our developers that we will

1003
00:41:41,380 --> 00:41:46,510
designate any vulnerabilities that are

1004
00:41:44,170 --> 00:41:48,580
discovered in those pre-release builds

1005
00:41:46,510 --> 00:41:51,250
which were not introduced prior and are

1006
00:41:48,580 --> 00:41:54,759
reported to us before that operating

1007
00:41:51,250 --> 00:41:57,760
system goes out to the customers we will

1008
00:41:54,760 --> 00:42:06,940
offer a 50% bonus on top of all of those

1009
00:41:57,760 --> 00:42:08,500
payouts the second best reason to have a

1010
00:42:06,940 --> 00:42:10,270
bug bounty is to find out about a

1011
00:42:08,500 --> 00:42:12,010
vulnerability that is already in the

1012
00:42:10,270 --> 00:42:13,600
users hands and fix it quickly but the

1013
00:42:12,010 --> 00:42:15,310
number one best reason to have a bounty

1014
00:42:13,600 --> 00:42:19,480
is to find a vulnerability before it

1015
00:42:15,310 --> 00:42:22,420
ever hits a customer's hands we also

1016
00:42:19,480 --> 00:42:24,700
thought about what it's like to get

1017
00:42:22,420 --> 00:42:29,350
started with one ability research on our

1018
00:42:24,700 --> 00:42:31,899
platform iOS changes are hard to come by

1019
00:42:29,350 --> 00:42:33,490
and we want to attract some of the

1020
00:42:31,900 --> 00:42:35,560
exceptional researchers who have thus

1021
00:42:33,490 --> 00:42:38,680
far been focusing their time on other

1022
00:42:35,560 --> 00:42:40,660
platforms today many of them tell us

1023
00:42:38,680 --> 00:42:42,609
that they look at our platform and they

1024
00:42:40,660 --> 00:42:44,710
want to do iOS research but the bar is

1025
00:42:42,610 --> 00:42:46,450
just too high they would have to first

1026
00:42:44,710 --> 00:42:49,480
have a full chain just to bootstrap

1027
00:42:46,450 --> 00:42:51,700
their research we also feel like

1028
00:42:49,480 --> 00:42:53,920
existing iOS researcher researchers

1029
00:42:51,700 --> 00:42:58,810
should not have to hold back chains to

1030
00:42:53,920 --> 00:43:00,580
be able to continue their research so

1031
00:42:58,810 --> 00:43:04,060
I'm proud today to announce the iOS

1032
00:43:00,580 --> 00:43:06,670
security research device program this is

1033
00:43:04,060 --> 00:43:09,940
an unprecedented fully apple supported

1034
00:43:06,670 --> 00:43:12,880
iOS security research platform it comes

1035
00:43:09,940 --> 00:43:15,220
with SSH a root shell and advanced debug

1036
00:43:12,880 --> 00:43:17,050
capabilities right out of the box using

1037
00:43:15,220 --> 00:43:20,589
a new researcher fusing that's neither

1038
00:43:17,050 --> 00:43:26,140
production nor development while this

1039
00:43:20,590 --> 00:43:28,960
program will be by application only we

1040
00:43:26,140 --> 00:43:30,580
will evaluate applications from anyone

1041
00:43:28,960 --> 00:43:32,500
with a track record of high quality

1042
00:43:30,580 --> 00:43:37,150
system security research

1043
00:43:32,500 --> 00:43:44,650
on any platform this program is coming

1044
00:43:37,150 --> 00:43:46,180
next year the Apple security banning

1045
00:43:44,650 --> 00:43:48,850
have served as well and we're excited to

1046
00:43:46,180 --> 00:43:51,339
take it to the next stage we will invite

1047
00:43:48,850 --> 00:43:53,560
all of you to participate in the fall we

1048
00:43:51,340 --> 00:43:56,350
have a new fully expanded revised set of

1049
00:43:53,560 --> 00:43:59,350
categories we have by far the highest

1050
00:43:56,350 --> 00:44:00,850
maximum payouts in the industry and we

1051
00:43:59,350 --> 00:44:03,520
have the iOS security research device

1052
00:44:00,850 --> 00:44:07,630
program for exceptional researchers that

1053
00:44:03,520 --> 00:44:11,230
are new to our platform but we asked

1054
00:44:07,630 --> 00:44:13,990
ourselves one last question what if

1055
00:44:11,230 --> 00:44:15,970
someone came to us with a 0 click iOS

1056
00:44:13,990 --> 00:44:19,899
full chain with kernel code execution

1057
00:44:15,970 --> 00:44:22,379
and persistence I'm happy to announce

1058
00:44:19,900 --> 00:44:24,690
that we would reward it with up to a

1059
00:44:22,380 --> 00:44:30,619
million dollars

1060
00:44:24,690 --> 00:44:30,619
[Applause]

