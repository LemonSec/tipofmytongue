1
00:00:00,030 --> 00:00:04,680
well good morning everybody welcome to

2
00:00:02,100 --> 00:00:06,629
blackhat 2019 as you go on and make your

3
00:00:04,680 --> 00:00:08,068
way on inside go ahead and scoot toward

4
00:00:06,629 --> 00:00:11,518
the middle of the rows to make room for

5
00:00:08,069 --> 00:00:13,860
those that are filing in welcome to a

6
00:00:11,519 --> 00:00:17,070
decade after black and baakir oh six RS

7
00:00:13,860 --> 00:00:20,730
a signature forgery still works in the

8
00:00:17,070 --> 00:00:22,920
room jasmine with see you so this

9
00:00:20,730 --> 00:00:25,170
morning I've just got a few brief notes

10
00:00:22,920 --> 00:00:27,029
before we begin make sure to stop by the

11
00:00:25,170 --> 00:00:28,980
business hall located in Mandalay Bay

12
00:00:27,029 --> 00:00:30,990
Oceanside and shoreline ballrooms on

13
00:00:28,980 --> 00:00:33,960
level two during the day and for a

14
00:00:30,990 --> 00:00:36,120
welcome reception at at 5:30 tonight the

15
00:00:33,960 --> 00:00:38,520
blackhat Arsenal is located in the

16
00:00:36,120 --> 00:00:41,699
business hall on level two and then join

17
00:00:38,520 --> 00:00:44,010
us for the pony Awards in lagoon GHI at

18
00:00:41,700 --> 00:00:47,640
18:30 and then also lunch will be served

19
00:00:44,010 --> 00:00:49,410
in Bayside a be from 1205 to 1:30 and

20
00:00:47,640 --> 00:00:51,059
then thank you for putting your phone on

21
00:00:49,410 --> 00:00:53,519
vibrate it makes it easier for the rest

22
00:00:51,059 --> 00:00:54,839
of us to ignore the ringing while you

23
00:00:53,520 --> 00:00:57,449
wait for your voicemail to pick it up

24
00:00:54,840 --> 00:01:08,310
without any further ado I present see

25
00:00:57,449 --> 00:01:10,470
you okay thank you

26
00:01:08,310 --> 00:01:13,260
good morning and thank you for coming to

27
00:01:10,470 --> 00:01:16,020
this session in this talk we'll look at

28
00:01:13,260 --> 00:01:18,689
the problem of blame borrow six hours a

29
00:01:16,020 --> 00:01:20,580
day sure for your attack and we'll go

30
00:01:18,689 --> 00:01:24,389
through how it still works after more

31
00:01:20,580 --> 00:01:27,479
than a decade so first a little bit

32
00:01:24,390 --> 00:01:29,880
about myself my name is Cu and I was

33
00:01:27,479 --> 00:01:31,679
born and raised in Hong Kong I just got

34
00:01:29,880 --> 00:01:34,798
my PhD in computer science from Purdue

35
00:01:31,680 --> 00:01:36,610
University last week and thank you thank

36
00:01:34,799 --> 00:01:39,200
you

37
00:01:36,610 --> 00:01:41,600
and I'll be joining the Department of

38
00:01:39,200 --> 00:01:44,360
Information engineering at cuhk in Hong

39
00:01:41,600 --> 00:01:46,100
Kong next year chk is one of the top

40
00:01:44,360 --> 00:01:49,039
public research universities in Hong

41
00:01:46,100 --> 00:01:50,929
Kong and my research has interest is

42
00:01:49,040 --> 00:01:52,670
mainly on the insecure design and

43
00:01:50,930 --> 00:01:56,180
implementations of different different

44
00:01:52,670 --> 00:01:58,700
protocols okay so before we get into the

45
00:01:56,180 --> 00:02:01,909
technical details right let's start with

46
00:01:58,700 --> 00:02:05,180
a little brain teaser so if I give you X

47
00:02:01,909 --> 00:02:07,549
all nine certificates as a sec IPSec and

48
00:02:05,180 --> 00:02:10,670
DNS sack what is common among these

49
00:02:07,549 --> 00:02:12,380
protocols okay so you might be thinking

50
00:02:10,669 --> 00:02:15,500
that they all have our C's of course

51
00:02:12,380 --> 00:02:17,660
right you might be thinking that they

52
00:02:15,500 --> 00:02:21,019
all security critical sure but that's

53
00:02:17,660 --> 00:02:24,109
not the point so it might not be obvious

54
00:02:21,019 --> 00:02:27,230
in at first but turns out that they can

55
00:02:24,110 --> 00:02:31,310
all benefit from the pkcs1 version 1.5

56
00:02:27,230 --> 00:02:33,140
hours 8 inches right so I guess now

57
00:02:31,310 --> 00:02:36,080
would be a good time to review the tax

58
00:02:33,140 --> 00:02:38,600
preparers a secure so for the signer to

59
00:02:36,080 --> 00:02:42,950
sign for message M what the signer would

60
00:02:38,600 --> 00:02:46,250
do is to compute H of M and then raise

61
00:02:42,950 --> 00:02:48,440
hash of M 2 T mod n T is obviously the

62
00:02:46,250 --> 00:02:53,120
private exponent and being the modulus

63
00:02:48,440 --> 00:02:55,579
and then you get a signature so now to

64
00:02:53,120 --> 00:02:57,980
verify that s is indeed a valid

65
00:02:55,579 --> 00:03:01,400
signature of message m what the fire

66
00:02:57,980 --> 00:03:03,500
would do is to take us and race it to e

67
00:03:01,400 --> 00:03:06,470
more n where e is obviously the public

68
00:03:03,500 --> 00:03:11,829
exponent and then compare and see

69
00:03:06,470 --> 00:03:14,510
whether it's equal to H of M very simple

70
00:03:11,829 --> 00:03:16,450
unfortunately reality is usually much

71
00:03:14,510 --> 00:03:19,670
more complex than what you would expect

72
00:03:16,450 --> 00:03:21,798
the first problem here is that the

73
00:03:19,670 --> 00:03:23,208
verifier has to know what hash algorithm

74
00:03:21,799 --> 00:03:25,970
to use right so there are so many

75
00:03:23,209 --> 00:03:28,100
different choices and the second problem

76
00:03:25,970 --> 00:03:31,880
here is that the modulus n is usually

77
00:03:28,100 --> 00:03:34,700
much much longer than the output of hash

78
00:03:31,880 --> 00:03:36,620
algorithms so for example nowadays I

79
00:03:34,700 --> 00:03:40,190
think it is fairly common to see a

80
00:03:36,620 --> 00:03:43,489
modulus of at least 2048 bit but the

81
00:03:40,190 --> 00:03:45,440
char outputs are fairly small so because

82
00:03:43,489 --> 00:03:49,040
of that what you need is some metadata

83
00:03:45,440 --> 00:03:50,510
and some padding which is exactly why we

84
00:03:49,040 --> 00:03:54,079
have this pkcs1

85
00:03:50,510 --> 00:03:56,739
family of standards so pkcs1 defines

86
00:03:54,080 --> 00:03:59,090
both encryption and secure schemes

87
00:03:56,739 --> 00:04:01,970
even though there are newer versions of

88
00:03:59,090 --> 00:04:04,970
the standard as of today I think for RSA

89
00:04:01,970 --> 00:04:07,310
sinkers the version 1.5 standard is

90
00:04:04,970 --> 00:04:09,019
still the most widely used one for

91
00:04:07,310 --> 00:04:11,180
example certificates of Google and

92
00:04:09,019 --> 00:04:15,910
Wikipedia they are all signed using this

93
00:04:11,180 --> 00:04:19,608
version 1.5 scheme so in this scheme to

94
00:04:15,910 --> 00:04:22,669
sign for message m instead of computing

95
00:04:19,608 --> 00:04:25,460
hash of M raised to D mod n the signer

96
00:04:22,669 --> 00:04:28,729
would instead do K raise to D mod N and

97
00:04:25,460 --> 00:04:33,169
K looks like this right so K starts with

98
00:04:28,729 --> 00:04:35,539
an initial bite of 0 followed by a byte

99
00:04:33,169 --> 00:04:38,750
of block type which for a signature has

100
00:04:35,539 --> 00:04:40,969
to be a 1 and then you have a bunch of

101
00:04:38,750 --> 00:04:43,580
padding bytes it for a signature it has

102
00:04:40,970 --> 00:04:45,770
to be text a decimal FF all the way it

103
00:04:43,580 --> 00:04:47,389
has to be at least a byte long and the

104
00:04:45,770 --> 00:04:51,020
point of having padding is of course to

105
00:04:47,389 --> 00:04:53,389
make a as long as the modulus N and then

106
00:04:51,020 --> 00:04:56,240
you have the end of padding 0 and then

107
00:04:53,389 --> 00:04:59,270
you have a es structure which is a de

108
00:04:56,240 --> 00:05:00,979
are encoded asn.1 structure containing

109
00:04:59,270 --> 00:05:03,349
the metadata describing the hash

110
00:05:00,979 --> 00:05:08,330
algorithm as well as the actual hash of

111
00:05:03,349 --> 00:05:11,090
M and the N code AS looks like this it's

112
00:05:08,330 --> 00:05:12,590
a chunk of bytes so the example I'm

113
00:05:11,090 --> 00:05:14,960
using here assumes that the hash

114
00:05:12,590 --> 00:05:17,780
algorithm is sha-1 and the message m is

115
00:05:14,960 --> 00:05:20,750
hello world so notice that this is a di

116
00:05:17,780 --> 00:05:25,369
encoded object so it is basically a tree

117
00:05:20,750 --> 00:05:29,449
of tackling value triplets so the first

118
00:05:25,370 --> 00:05:32,539
value bytes can be separated into two

119
00:05:29,449 --> 00:05:35,659
sub trees the first one is made of two

120
00:05:32,539 --> 00:05:37,760
child nodes the first leaf node would

121
00:05:35,659 --> 00:05:39,860
actually give you the oid the object

122
00:05:37,760 --> 00:05:41,990
identifier of the hash algorithm the

123
00:05:39,860 --> 00:05:44,180
second leaf node would give you the

124
00:05:41,990 --> 00:05:46,220
algorithm parameters which for most of

125
00:05:44,180 --> 00:05:48,530
the hash algorithm that we use today we

126
00:05:46,220 --> 00:05:51,380
don't really use a parameter so we just

127
00:05:48,530 --> 00:05:53,169
put a now parameter T and then finally

128
00:05:51,380 --> 00:06:05,620
the second subtree

129
00:05:53,169 --> 00:06:09,250
the last leaf note of this thanks pal

130
00:06:05,620 --> 00:06:11,080
in this tree so the length values

131
00:06:09,250 --> 00:06:13,030
actually add up from the leaf node all

132
00:06:11,080 --> 00:06:18,070
the way back to the root in the benign

133
00:06:13,030 --> 00:06:20,919
cases so now given a signature s in this

134
00:06:18,070 --> 00:06:23,229
version 1.5 scheme what the verifier

135
00:06:20,919 --> 00:06:26,500
would do is to check signature s and

136
00:06:23,229 --> 00:06:29,650
raise it to emote n let's call it out

137
00:06:26,500 --> 00:06:31,990
and now you look exactly like K from

138
00:06:29,650 --> 00:06:34,060
before so now what the verify has to do

139
00:06:31,990 --> 00:06:36,820
is to first check whether R is well

140
00:06:34,060 --> 00:06:38,919
formed and then the verify would compute

141
00:06:36,820 --> 00:06:42,849
a chop em and see whether it matches

142
00:06:38,919 --> 00:06:45,010
with the hash inside out and turns out

143
00:06:42,850 --> 00:06:46,510
this is problematic there are all kinds

144
00:06:45,010 --> 00:06:49,659
of leniency is in the world from this

145
00:06:46,510 --> 00:06:52,210
check which brings us to blacken burgers

146
00:06:49,660 --> 00:06:54,400
low exponent attack so this is yet

147
00:06:52,210 --> 00:06:57,159
another clip to attack attributed to

148
00:06:54,400 --> 00:06:59,530
Danube linebacker so I think the first

149
00:06:57,160 --> 00:07:01,690
documented report came in crypto 6 ROM

150
00:06:59,530 --> 00:07:03,250
session so basically you figure out that

151
00:07:01,690 --> 00:07:06,039
some implementations of the state

152
00:07:03,250 --> 00:07:09,220
certification would accept a out prime

153
00:07:06,039 --> 00:07:13,990
that looks a lot like ow but with extra

154
00:07:09,220 --> 00:07:15,639
garbage bytes trolling after AES and

155
00:07:13,990 --> 00:07:17,470
because of that existential forgery is

156
00:07:15,639 --> 00:07:19,750
possible when the public exponent is

157
00:07:17,470 --> 00:07:21,849
small meaning that an attacker can

158
00:07:19,750 --> 00:07:25,030
generate signatures for some message M

159
00:07:21,849 --> 00:07:28,150
without possessing the private exponent

160
00:07:25,030 --> 00:07:29,979
B and this is one of the major

161
00:07:28,150 --> 00:07:33,400
contributing factors to the push for

162
00:07:29,979 --> 00:07:35,969
using a bigger Yi but because smaller Yi

163
00:07:33,400 --> 00:07:38,349
is more efficient for the safer fire

164
00:07:35,970 --> 00:07:41,380
historically many protocols actually

165
00:07:38,349 --> 00:07:43,800
prescribed the use of eco-city for

166
00:07:41,380 --> 00:07:46,449
example the RCS for DNS AK I think they

167
00:07:43,800 --> 00:07:50,310
recommend equal to 3 under certain

168
00:07:46,449 --> 00:07:53,560
circumstances ok and speaking of

169
00:07:50,310 --> 00:07:57,130
Blankenbaker there are at least two

170
00:07:53,560 --> 00:08:00,639
lines of attacks on pkcs1 31.5

171
00:07:57,130 --> 00:08:03,130
attributed to him one is the padding

172
00:08:00,639 --> 00:08:07,810
Oracle attack which of course inspired a

173
00:08:03,130 --> 00:08:10,199
lot of follow-up research and for safer

174
00:08:07,810 --> 00:08:14,440
vacation which is the focus of this talk

175
00:08:10,199 --> 00:08:17,349
the first report came from I think Amy

176
00:08:14,440 --> 00:08:18,280
in 2006 and then in 2008 there are some

177
00:08:17,349 --> 00:08:20,650
follow-up

178
00:08:18,280 --> 00:08:23,950
research on the attack algorithm as well

179
00:08:20,650 --> 00:08:26,169
as the analysis and then in 2014 I

180
00:08:23,950 --> 00:08:29,020
believe Intel security wrote a report

181
00:08:26,170 --> 00:08:32,590
saying that certain versions of Mozilla

182
00:08:29,020 --> 00:08:36,579
NSS is susceptible to variance of the

183
00:08:32,590 --> 00:08:39,370
original attack and then in 2016 there's

184
00:08:36,580 --> 00:08:42,700
another report claiming that the Python

185
00:08:39,370 --> 00:08:45,130
hours a module is also problematic and

186
00:08:42,700 --> 00:08:47,710
the legacy of linebacker whose exists of

187
00:08:45,130 --> 00:08:50,320
course did not end there because this

188
00:08:47,710 --> 00:08:52,720
year at the end ESS 20 or 2019 we

189
00:08:50,320 --> 00:08:54,880
published a new paper you know finding

190
00:08:52,720 --> 00:08:57,130
more variants of the behin bahu sex

191
00:08:54,880 --> 00:08:59,290
attack in different implementations so

192
00:08:57,130 --> 00:09:01,950
since both of these are on a ps1 version

193
00:08:59,290 --> 00:09:04,120
1.5 and both of them are attributed to

194
00:09:01,950 --> 00:09:07,170
the new black power I think it would be

195
00:09:04,120 --> 00:09:10,510
useful to give you a high overview of

196
00:09:07,170 --> 00:09:13,060
what are the differences so the the

197
00:09:10,510 --> 00:09:16,510
padding Oracle attack it is exploiting

198
00:09:13,060 --> 00:09:18,819
some site you know leakages the goal of

199
00:09:16,510 --> 00:09:21,339
that is to kind of get a decryption

200
00:09:18,820 --> 00:09:24,580
Oracle out of it and the victim there

201
00:09:21,339 --> 00:09:27,580
would be typically having the private

202
00:09:24,580 --> 00:09:30,810
key the private exponent for decryption

203
00:09:27,580 --> 00:09:33,550
to happen but for Accenture for vacation

204
00:09:30,810 --> 00:09:36,099
the victim is actually a safer fire

205
00:09:33,550 --> 00:09:37,870
without holding the products ponent what

206
00:09:36,100 --> 00:09:41,950
the sanctuary fire has is the public key

207
00:09:37,870 --> 00:09:44,290
and due to some logical flaws inside the

208
00:09:41,950 --> 00:09:47,290
sensor for vacation code in some cases

209
00:09:44,290 --> 00:09:51,689
it tastes possible to generate fixed

210
00:09:47,290 --> 00:09:54,939
nature's for sale forgery to happen okay

211
00:09:51,690 --> 00:09:57,970
now one thing I learned as a PhD student

212
00:09:54,940 --> 00:10:01,030
and as well as a teaching assistant is

213
00:09:57,970 --> 00:10:04,390
that if somewhere someone slipped on a

214
00:10:01,030 --> 00:10:06,400
banana peel chances are you know

215
00:10:04,390 --> 00:10:08,170
somewhere else someone would also sleep

216
00:10:06,400 --> 00:10:10,949
on a different but similar looking

217
00:10:08,170 --> 00:10:12,810
banana peel so going back to the

218
00:10:10,950 --> 00:10:15,310
original brain teaser

219
00:10:12,810 --> 00:10:16,810
turns out the implementations of all

220
00:10:15,310 --> 00:10:20,469
these different protocols they can all

221
00:10:16,810 --> 00:10:21,900
suffer from this pkcs1 31.5 I would say

222
00:10:20,470 --> 00:10:25,240
centures

223
00:10:21,900 --> 00:10:26,980
so why was the attack possible right so

224
00:10:25,240 --> 00:10:29,650
the root cause of the problem is that

225
00:10:26,980 --> 00:10:30,380
the site refer fire would accept certain

226
00:10:29,650 --> 00:10:32,600
malformed

227
00:10:30,380 --> 00:10:35,120
put with some garbage bites left

228
00:10:32,600 --> 00:10:36,740
unchecked and as I explained later this

229
00:10:35,120 --> 00:10:41,390
can happen in many different locations

230
00:10:36,740 --> 00:10:43,070
not only at the end of our and even

231
00:10:41,390 --> 00:10:46,130
though a longer modulus would make

232
00:10:43,070 --> 00:10:49,040
factorizations supposedly harder in this

233
00:10:46,130 --> 00:10:51,439
case if you're using this floor to do

234
00:10:49,040 --> 00:10:52,730
sanction forgery a larger a longer

235
00:10:51,440 --> 00:10:54,650
modulus will actually make it easier

236
00:10:52,730 --> 00:10:57,530
because the attacker will have more

237
00:10:54,650 --> 00:10:59,209
garbage bits to play with and this can

238
00:10:57,530 --> 00:11:04,910
be used to handle a slightly longer hash

239
00:10:59,210 --> 00:11:07,100
or a slightly larger e so to find this

240
00:11:04,910 --> 00:11:09,110
kind of potential blind baka Oh sex

241
00:11:07,100 --> 00:11:10,910
attacks we would like to see how the

242
00:11:09,110 --> 00:11:13,190
input bytes are being validated by the

243
00:11:10,910 --> 00:11:16,459
central fire fire and if there are

244
00:11:13,190 --> 00:11:19,760
enough unchecked garbage bytes then

245
00:11:16,460 --> 00:11:21,640
thank you for German our position is

246
00:11:19,760 --> 00:11:25,580
that this is a problem well-suited for

247
00:11:21,640 --> 00:11:28,250
simple execution so to use in my

248
00:11:25,580 --> 00:11:30,920
execution to confine these potential by

249
00:11:28,250 --> 00:11:33,980
Ibaka with six attacks so we try to

250
00:11:30,920 --> 00:11:36,589
automatically generate con colic test

251
00:11:33,980 --> 00:11:38,780
cases for this particular problem the

252
00:11:36,590 --> 00:11:41,660
key observation there is that the size

253
00:11:38,780 --> 00:11:44,510
of components used by PA SS one version

254
00:11:41,660 --> 00:11:46,670
1.5 they exhibit very nice linear

255
00:11:44,510 --> 00:11:48,140
relations right for example the

256
00:11:46,670 --> 00:11:50,120
summation of the length of all the

257
00:11:48,140 --> 00:11:53,600
components they have to be exactly as

258
00:11:50,120 --> 00:11:55,480
long as the size of the modulus and also

259
00:11:53,600 --> 00:11:58,130
if you think about the DL encoded

260
00:11:55,480 --> 00:12:01,370
structure the length also add up from

261
00:11:58,130 --> 00:12:03,110
the leaf back to the root so what we can

262
00:12:01,370 --> 00:12:05,600
do is programmatically capture these

263
00:12:03,110 --> 00:12:08,570
linear constraints and then we ask

264
00:12:05,600 --> 00:12:11,150
simple execution to kind of find satisfy

265
00:12:08,570 --> 00:12:13,280
both solutions on the fly and based on

266
00:12:11,150 --> 00:12:15,439
that we can automatically pack mixture

267
00:12:13,280 --> 00:12:18,829
of symbolic and concrete components into

268
00:12:15,440 --> 00:12:21,410
the test buffers and once we have these

269
00:12:18,830 --> 00:12:23,990
con colic test cases generated we can

270
00:12:21,410 --> 00:12:26,540
use in my execution to extract the

271
00:12:23,990 --> 00:12:29,690
sensor verification logic and abstract

272
00:12:26,540 --> 00:12:31,969
them in in terms of logical formulas so

273
00:12:29,690 --> 00:12:35,510
this is a very useful abstraction

274
00:12:31,970 --> 00:12:37,280
because it helps us understand what and

275
00:12:35,510 --> 00:12:39,860
how things are being checked inside the

276
00:12:37,280 --> 00:12:41,089
sensor for vacation code and with the

277
00:12:39,860 --> 00:12:42,529
formula abstraction we can also

278
00:12:41,089 --> 00:12:44,689
automatically cross

279
00:12:42,529 --> 00:12:48,259
eight different implementations to see

280
00:12:44,689 --> 00:12:51,348
whether they agree with each other so we

281
00:12:48,259 --> 00:12:55,069
applied our technique into analyzing 15

282
00:12:51,349 --> 00:12:57,889
recent implementations of pkcs1 for 1.5

283
00:12:55,069 --> 00:13:00,769
hours a static verification including

284
00:12:57,889 --> 00:13:04,039
some ssl libraries crypto libraries SSH

285
00:13:00,769 --> 00:13:06,919
and IPSec implementations so turns out

286
00:13:04,039 --> 00:13:09,729
six of them are overly lenient and four

287
00:13:06,919 --> 00:13:12,319
of them are susceptible to a practical

288
00:13:09,729 --> 00:13:15,949
sexual forgery under a small public

289
00:13:12,319 --> 00:13:20,419
exponent confirming my theory on people

290
00:13:15,949 --> 00:13:22,539
slipping on banana peels so the first

291
00:13:20,419 --> 00:13:25,279
problem we found was in open Swan

292
00:13:22,539 --> 00:13:27,968
we found the open Swan was ignoring

293
00:13:25,279 --> 00:13:30,649
padding bytes it's a simple oversight

294
00:13:27,969 --> 00:13:33,199
but with severe implications because

295
00:13:30,649 --> 00:13:35,569
attackers can exploit this for a second

296
00:13:33,199 --> 00:13:37,669
signature forgery so what the attacker

297
00:13:35,569 --> 00:13:40,909
can do is to use this milk on our prime

298
00:13:37,669 --> 00:13:43,429
and hide garbage bytes in the unchecked

299
00:13:40,909 --> 00:13:46,519
padding bytes so what the attacker wants

300
00:13:43,429 --> 00:13:48,169
is to find a and B such that a cube we

301
00:13:46,519 --> 00:13:51,229
give you what is needed to match before

302
00:13:48,169 --> 00:13:53,029
the garbage the least significant bits

303
00:13:51,229 --> 00:13:55,369
of BG will give you what is needed after

304
00:13:53,029 --> 00:13:58,099
garbage and the rest would stay inside

305
00:13:55,369 --> 00:13:59,659
unchecked garbage bags and once you

306
00:13:58,099 --> 00:14:02,359
found it then the fixed nature is simply

307
00:13:59,659 --> 00:14:04,399
a plus B so if you're interested in the

308
00:14:02,359 --> 00:14:08,809
exact algorithm I'll refer you to our

309
00:14:04,399 --> 00:14:10,729
NDS s paper so to convince the

310
00:14:08,809 --> 00:14:14,059
developers of open Swan we send them a

311
00:14:10,729 --> 00:14:16,729
bunch of generator fixators that would

312
00:14:14,059 --> 00:14:20,029
work against any modulus of our chosen

313
00:14:16,729 --> 00:14:21,799
size I think they liked our fixators and

314
00:14:20,029 --> 00:14:23,599
in fact they took one of our fixator and

315
00:14:21,799 --> 00:14:27,409
turned it into a new unit test in

316
00:14:23,599 --> 00:14:30,919
they're so strict and of course they

317
00:14:27,409 --> 00:14:33,139
also fix the problems okay so let's move

318
00:14:30,919 --> 00:14:34,069
on to strongswan the first problem we

319
00:14:33,139 --> 00:14:36,319
found in strongswan

320
00:14:34,069 --> 00:14:38,988
is that they're not checking algorithm

321
00:14:36,319 --> 00:14:41,059
parameters this is a classical flaw

322
00:14:38,989 --> 00:14:43,279
found in the new TRS and firefox many

323
00:14:41,059 --> 00:14:44,749
many years ago and of course this is

324
00:14:43,279 --> 00:14:47,119
exploitable for central forgery

325
00:14:44,749 --> 00:14:48,679
basically the attacker can hide garbage

326
00:14:47,119 --> 00:14:52,039
fights in the unchecked algorithm

327
00:14:48,679 --> 00:14:55,250
parameter and then a dot opens one at

328
00:14:52,039 --> 00:14:57,079
algorithm to January fixtures

329
00:14:55,250 --> 00:14:58,850
the second problem in strongswan was

330
00:14:57,079 --> 00:15:02,359
that they are accepting trolling bytes

331
00:14:58,850 --> 00:15:04,370
after the algorithm object identifier so

332
00:15:02,360 --> 00:15:06,800
interestingly in strong swans

333
00:15:04,370 --> 00:15:08,540
implementation the oid is not matched

334
00:15:06,800 --> 00:15:10,128
exactly so what they're doing is a

335
00:15:08,540 --> 00:15:12,469
variant of the longest prefix match

336
00:15:10,129 --> 00:15:15,199
which means on the left-hand side you

337
00:15:12,470 --> 00:15:17,300
have to correct the encoded o ID for

338
00:15:15,199 --> 00:15:21,349
sha-1 and on the right-hand side you

339
00:15:17,300 --> 00:15:23,930
have the the correct ID added with some

340
00:15:21,350 --> 00:15:26,060
extra trolling garbage bytes after the

341
00:15:23,930 --> 00:15:28,069
oid and because of the longest prefix

342
00:15:26,060 --> 00:15:31,209
match both would be recognized as

343
00:15:28,069 --> 00:15:34,519
correct or IDs for java and knowing that

344
00:15:31,209 --> 00:15:36,680
an attacker can hide garbage after the

345
00:15:34,519 --> 00:15:38,600
correct ID and again using the open

346
00:15:36,680 --> 00:15:42,800
swalot algorithm you can generate F

347
00:15:38,600 --> 00:15:45,259
exchangers fortunately songs drones one

348
00:15:42,800 --> 00:15:49,399
quickly fix the problems after we send

349
00:15:45,259 --> 00:15:51,709
them a report and you might be thinking

350
00:15:49,399 --> 00:15:54,639
that in the x.509 ecosystem for example

351
00:15:51,709 --> 00:15:57,339
there are not too many ecosystem used

352
00:15:54,639 --> 00:15:59,600
but we noticed that in the IP sac

353
00:15:57,339 --> 00:16:02,980
ecosystem they are still key generation

354
00:15:59,600 --> 00:16:06,769
programs that forces equals to 3 so

355
00:16:02,980 --> 00:16:08,870
depending on the deployment scenario the

356
00:16:06,769 --> 00:16:10,610
flaws in opens one in strong's one can

357
00:16:08,870 --> 00:16:13,579
potentially be used to break

358
00:16:10,610 --> 00:16:18,199
authentication in IP Sybase VPN

359
00:16:13,579 --> 00:16:21,469
deployments ok so then we also found a

360
00:16:18,199 --> 00:16:24,050
couple of problems in xt RS so the first

361
00:16:21,470 --> 00:16:26,930
issue is that they were accepting

362
00:16:24,050 --> 00:16:28,819
charleen garbage bytes or so that means

363
00:16:26,930 --> 00:16:32,388
the original buyer borrows X attack

364
00:16:28,819 --> 00:16:35,000
would simply work and then on top of

365
00:16:32,389 --> 00:16:37,309
that they are also ignoring some prefix

366
00:16:35,000 --> 00:16:39,410
bytes of the ps1 version of

367
00:16:37,309 --> 00:16:41,750
one-point-five scheme so the first 10

368
00:16:39,410 --> 00:16:43,699
bytes are not being checked at all which

369
00:16:41,750 --> 00:16:46,730
means you can actually make it easier to

370
00:16:43,699 --> 00:16:49,040
to win the signature for the game so by

371
00:16:46,730 --> 00:16:51,620
making the first 90 bits or 0 you can

372
00:16:49,040 --> 00:16:54,199
reduce the distance between to construct

373
00:16:51,620 --> 00:16:56,750
a consecutive cubes so it would be much

374
00:16:54,199 --> 00:16:58,490
easier to find fixed nature meaning that

375
00:16:56,750 --> 00:17:02,959
the attacker doesn't even need to do a

376
00:16:58,490 --> 00:17:04,039
lot of brute force trials so the third

377
00:17:02,959 --> 00:17:07,158
issue in x-ers

378
00:17:04,039 --> 00:17:08,689
was that they were ignoring the

379
00:17:07,159 --> 00:17:11,299
algorithm identifier

380
00:17:08,689 --> 00:17:13,489
so given this encoder a s and the

381
00:17:11,299 --> 00:17:16,608
passing code so this complete Chung

382
00:17:13,489 --> 00:17:18,589
would be skipped by their pattern this

383
00:17:16,608 --> 00:17:21,739
is probably because certificates already

384
00:17:18,589 --> 00:17:24,938
have an explicit field telling the same

385
00:17:21,739 --> 00:17:27,259
server via which hash algorithm to use

386
00:17:24,939 --> 00:17:28,940
but just because you know the hash

387
00:17:27,259 --> 00:17:31,279
algorithm from outside doesn't mean that

388
00:17:28,940 --> 00:17:32,989
this can be skipped because attacker can

389
00:17:31,279 --> 00:17:36,019
then use this mail phone our prime to

390
00:17:32,989 --> 00:17:38,869
hide garbage values inside the unchecked

391
00:17:36,019 --> 00:17:41,179
algorithm identifier and then again you

392
00:17:38,869 --> 00:17:44,449
use a open swalot algorithm you can

393
00:17:41,179 --> 00:17:48,259
generate exchangers finally one more

394
00:17:44,450 --> 00:17:52,669
issue in x-ers we found that xes was

395
00:17:48,259 --> 00:17:54,559
trusting the declared length without any

396
00:17:52,669 --> 00:17:58,909
sanity checks so what that means is that

397
00:17:54,559 --> 00:18:00,889
if you take the encode that a s and an

398
00:17:58,909 --> 00:18:03,590
an attacker can put absolutely large

399
00:18:00,889 --> 00:18:06,019
values in the lengths in the declared

400
00:18:03,590 --> 00:18:07,728
length to track the same server fire

401
00:18:06,019 --> 00:18:10,399
into performing some illegal memory

402
00:18:07,729 --> 00:18:13,340
access so as a proof of concept we

403
00:18:10,399 --> 00:18:15,199
declared a really large really long hash

404
00:18:13,340 --> 00:18:17,959
output and we managed to crash the

405
00:18:15,200 --> 00:18:20,869
server fire and this is particularly

406
00:18:17,960 --> 00:18:23,210
problematic because the way that a XTS

407
00:18:20,869 --> 00:18:25,129
does certificate validation is in a

408
00:18:23,210 --> 00:18:27,409
bottom-up manner so what that means is

409
00:18:25,129 --> 00:18:30,080
that even if in the wild nobody is using

410
00:18:27,409 --> 00:18:31,519
small public exponent any man in the

411
00:18:30,080 --> 00:18:34,220
middle can just inject the fixing

412
00:18:31,519 --> 00:18:35,840
certificate with equal to 3 and crash

413
00:18:34,220 --> 00:18:37,849
the FIR fire before the verify has a

414
00:18:35,840 --> 00:18:42,678
chance to traverse a chain all the way

415
00:18:37,849 --> 00:18:45,200
up to some trust a good anchor we help

416
00:18:42,679 --> 00:18:48,409
them develop the fix originally for the

417
00:18:45,200 --> 00:18:50,149
esp8266 port and later our patch has

418
00:18:48,409 --> 00:18:53,419
been accepted by the upstream a XTS

419
00:18:50,149 --> 00:18:55,518
maintainer which is good because xcr

420
00:18:53,419 --> 00:18:57,259
seems to be somewhat popular I think

421
00:18:55,519 --> 00:19:01,099
according to sauce for every week there

422
00:18:57,259 --> 00:19:03,349
are 20 to 30 downloads finally there are

423
00:19:01,099 --> 00:19:06,200
some other Linnaean sees for example in

424
00:19:03,349 --> 00:19:09,229
matrix ssl we found that for the length

425
00:19:06,200 --> 00:19:11,450
values there it would accept the safety

426
00:19:09,229 --> 00:19:14,960
profile would accept many possible

427
00:19:11,450 --> 00:19:16,639
values that means some bits in the

428
00:19:14,960 --> 00:19:19,309
middle of a s can take arbitrary any

429
00:19:16,639 --> 00:19:21,199
values but that doesn't seem to be long

430
00:19:19,309 --> 00:19:21,800
enough to mount a immediate practical

431
00:19:21,200 --> 00:19:23,690
attack

432
00:19:21,800 --> 00:19:27,200
and there are other variants of these

433
00:19:23,690 --> 00:19:30,140
leniency also in my TRS and Lipton

434
00:19:27,200 --> 00:19:32,900
cooked fortunately even though we don't

435
00:19:30,140 --> 00:19:35,830
have a immediate attack the matrix s or

436
00:19:32,900 --> 00:19:39,800
so developers quickly fix this problem

437
00:19:35,830 --> 00:19:42,379
okay so here are the lesson learned so

438
00:19:39,800 --> 00:19:45,110
the first lesson learned is that cutting

439
00:19:42,380 --> 00:19:47,120
kkona is not cool right so they're given

440
00:19:45,110 --> 00:19:49,070
a specification there are some mandated

441
00:19:47,120 --> 00:19:52,159
checks if you do not follow the

442
00:19:49,070 --> 00:19:54,020
requirements faithfully right it's

443
00:19:52,160 --> 00:19:56,270
tantamount to planting a ticking time

444
00:19:54,020 --> 00:19:58,040
bomb and I promised that it would come

445
00:19:56,270 --> 00:19:59,570
back and haunt you right so I mentioned

446
00:19:58,040 --> 00:20:02,090
earlier that after more than a decade

447
00:19:59,570 --> 00:20:06,679
these are texts it works which is kind

448
00:20:02,090 --> 00:20:08,060
of cool the second thing is I think

449
00:20:06,680 --> 00:20:11,150
developers should learn from each

450
00:20:08,060 --> 00:20:12,980
other's mistakes especially when they

451
00:20:11,150 --> 00:20:15,500
are implementing the same standard right

452
00:20:12,980 --> 00:20:17,930
so if you slipped on a banana peel you

453
00:20:15,500 --> 00:20:22,100
better warn the whole world that bananas

454
00:20:17,930 --> 00:20:24,560
can be really evil right so for

455
00:20:22,100 --> 00:20:28,370
communicating common vulnerabilities we

456
00:20:24,560 --> 00:20:29,659
do have CVEs but apparently that's not

457
00:20:28,370 --> 00:20:31,669
good enough I think it would be

458
00:20:29,660 --> 00:20:33,650
interesting to see how we can I guess

459
00:20:31,670 --> 00:20:35,720
disseminate these informations to

460
00:20:33,650 --> 00:20:37,820
different different developers so that

461
00:20:35,720 --> 00:20:39,830
we can can enforce community learning

462
00:20:37,820 --> 00:20:41,810
right like I said there are so many open

463
00:20:39,830 --> 00:20:44,090
standards and there are many competing

464
00:20:41,810 --> 00:20:45,530
implementations basically doing the same

465
00:20:44,090 --> 00:20:50,149
thing so they should be able to learn

466
00:20:45,530 --> 00:20:52,810
you know from each other's mistakes and

467
00:20:50,150 --> 00:20:54,890
finally parting is hard right so

468
00:20:52,810 --> 00:20:59,200
particularly when you are given a

469
00:20:54,890 --> 00:21:01,520
complex structure with many optional

470
00:20:59,200 --> 00:21:02,780
features right so if you're trying to

471
00:21:01,520 --> 00:21:04,910
handle all these different different

472
00:21:02,780 --> 00:21:07,790
cases it's kind of like walking through

473
00:21:04,910 --> 00:21:10,790
a maze right and another important

474
00:21:07,790 --> 00:21:13,310
observation here is that robustness what

475
00:21:10,790 --> 00:21:15,230
robustness means really depends on the

476
00:21:13,310 --> 00:21:18,350
context so if you're thinking about a

477
00:21:15,230 --> 00:21:20,600
generic parser it is perfectly fine to

478
00:21:18,350 --> 00:21:23,149
assume that the parser would be still

479
00:21:20,600 --> 00:21:24,919
able to salvage some useful information

480
00:21:23,150 --> 00:21:27,380
out of a malformed input and letter

481
00:21:24,920 --> 00:21:29,300
computation proceed but that is not

482
00:21:27,380 --> 00:21:31,850
probably not what you want for a

483
00:21:29,300 --> 00:21:34,620
security critical task like signature

484
00:21:31,850 --> 00:21:36,209
verification for example

485
00:21:34,620 --> 00:21:39,469
and and I guess in the long run it would

486
00:21:36,210 --> 00:21:42,390
be good to think about the trade-offs

487
00:21:39,470 --> 00:21:45,419
between flexibility and complexity right

488
00:21:42,390 --> 00:21:48,120
so in many cases being flexible being

489
00:21:45,419 --> 00:21:50,210
future-proof is really good but you have

490
00:21:48,120 --> 00:21:52,739
to also - you have to also think about

491
00:21:50,210 --> 00:21:55,770
at what cost right so in some cases

492
00:21:52,740 --> 00:21:57,630
making it really complex so complex that

493
00:21:55,770 --> 00:21:59,668
in fact people are messing up their

494
00:21:57,630 --> 00:22:05,789
implementation then you don't actually

495
00:21:59,669 --> 00:22:07,230
gain security okay so with that how we

496
00:22:05,789 --> 00:22:09,270
also like to take this opportunity to

497
00:22:07,230 --> 00:22:11,580
thank my collaborators from the U of

498
00:22:09,270 --> 00:22:14,309
Iowa as far as my two advisors from

499
00:22:11,580 --> 00:22:16,460
Purdue University and we said I think we

500
00:22:14,309 --> 00:22:18,720
have roughly four minutes for questions

501
00:22:16,460 --> 00:22:26,049
thank you so much

502
00:22:18,720 --> 00:22:26,049
[Applause]

503
00:22:27,460 --> 00:22:36,980
any questions hi how long does it take

504
00:22:35,270 --> 00:22:38,929
for forging a signature for a

505
00:22:36,980 --> 00:22:40,370
certificate with this technique would

506
00:22:38,929 --> 00:22:42,230
you mind speaking up a little bit I

507
00:22:40,370 --> 00:22:44,360
could then how long was it taking to

508
00:22:42,230 --> 00:22:49,160
produce the forged signatures with your

509
00:22:44,360 --> 00:22:51,229
method so the I think the time required

510
00:22:49,160 --> 00:22:53,240
really depends on the different

511
00:22:51,230 --> 00:22:55,850
parameters for example the size of the

512
00:22:53,240 --> 00:23:01,789
modulus and which hash algorithm you are

513
00:22:55,850 --> 00:23:05,570
choosing in many cases it's almost oh

514
00:23:01,789 --> 00:23:08,059
one I think so like I said if you have a

515
00:23:05,570 --> 00:23:10,580
longer modulus then it tends to be easy

516
00:23:08,059 --> 00:23:12,678
to forge but then if you have a longer

517
00:23:10,580 --> 00:23:14,928
hash output then you lose you know

518
00:23:12,679 --> 00:23:17,510
garbage bytes so you want more of them

519
00:23:14,929 --> 00:23:21,140
but I think in most of the cases it's

520
00:23:17,510 --> 00:23:23,900
almost a 1 because so the flaws that I

521
00:23:21,140 --> 00:23:27,530
presented you can use them in tandem to

522
00:23:23,900 --> 00:23:29,390
maximize the playroom that you have as

523
00:23:27,530 --> 00:23:32,750
an attacker so then I think most of them

524
00:23:29,390 --> 00:23:35,450
all one the original analysis I think if

525
00:23:32,750 --> 00:23:37,460
you are assuming a 1024 bit modulus then

526
00:23:35,450 --> 00:23:45,500
it's about two to nineteen put forth

527
00:23:37,460 --> 00:23:49,909
trials ok thank you so much so any other

528
00:23:45,500 --> 00:23:52,250
questions if you are shy you are too shy

529
00:23:49,909 --> 00:23:56,409
to ask you can meet me in the wrap-up

530
00:23:52,250 --> 00:23:56,409
room if you want and we can talk more

531
00:23:58,330 --> 00:24:01,330
okay

532
00:24:02,370 --> 00:24:05,518
thank you

