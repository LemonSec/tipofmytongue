1
00:00:00,000 --> 00:00:07,429
good afternoon welcome to chip glitching

2
00:00:05,400 --> 00:00:10,800
the silicon of the connected world

3
00:00:07,429 --> 00:00:14,070
this is Lagoon JKL

4
00:00:10,800 --> 00:00:23,070
and our speakers are josh co and thomas

5
00:00:14,070 --> 00:00:27,090
roth - hello welcome to chip top failure

6
00:00:23,070 --> 00:00:29,039
so to get started who are we so we had

7
00:00:27,090 --> 00:00:31,560
team of three persons unfortunately only

8
00:00:29,039 --> 00:00:33,780
two of us can be here today we have

9
00:00:31,560 --> 00:00:37,649
Dimitri neat auspice off with a PhD in

10
00:00:33,780 --> 00:00:41,370
chip security if Josh stetko and myself

11
00:00:37,649 --> 00:00:43,680
Thomas Roth and yeah before we start we

12
00:00:41,370 --> 00:00:45,750
have some special thanks to Colin or

13
00:00:43,680 --> 00:00:47,670
Flynn who helped us out with a ton of

14
00:00:45,750 --> 00:00:49,140
questions on the details and really on

15
00:00:47,670 --> 00:00:50,760
what are we doing

16
00:00:49,140 --> 00:00:52,230
he's a hardware blockchain expert you

17
00:00:50,760 --> 00:00:55,289
should totally check out his talk later

18
00:00:52,230 --> 00:00:56,640
today he's also an author of circuits

19
00:00:55,289 --> 00:00:59,730
summer so if you want to get your copy

20
00:00:56,640 --> 00:01:02,070
signed he'll be happy to do it for you

21
00:00:59,730 --> 00:01:03,660
and he's also the Builder of the chip

22
00:01:02,070 --> 00:01:06,780
Whisperer which is a wonderful device

23
00:01:03,660 --> 00:01:11,189
for for glitching for differential power

24
00:01:06,780 --> 00:01:13,860
analysis and so on in this talk we want

25
00:01:11,189 --> 00:01:15,779
to give you three core takeaways first

26
00:01:13,860 --> 00:01:18,630
off glitching is easier than you think

27
00:01:15,780 --> 00:01:21,270
so 9 months ago I never a glitch the

28
00:01:18,630 --> 00:01:23,729
chip and now we've glitched a couple of

29
00:01:21,270 --> 00:01:26,399
them and you really don't need to know

30
00:01:23,729 --> 00:01:29,880
much about hardware it's really easy to

31
00:01:26,400 --> 00:01:31,409
do if you get the basics down and it can

32
00:01:29,880 --> 00:01:33,149
also become part of your software and

33
00:01:31,409 --> 00:01:34,770
hardware development life cycle we don't

34
00:01:33,150 --> 00:01:36,180
need to rely on other people to tell you

35
00:01:34,770 --> 00:01:38,220
whether your chip is susceptible to

36
00:01:36,180 --> 00:01:40,259
glitching but we want to show you how

37
00:01:38,220 --> 00:01:44,280
can how you can do it yourself and how

38
00:01:40,259 --> 00:01:46,290
you can do it yourself cheaply yeah why

39
00:01:44,280 --> 00:01:47,759
are we here so we all do a lot of

40
00:01:46,290 --> 00:01:50,640
hardware and software security

41
00:01:47,759 --> 00:01:52,380
consulting and we suddenly see chips

42
00:01:50,640 --> 00:01:55,290
being considered as part of the threat

43
00:01:52,380 --> 00:01:57,270
model and if we talk about the threat of

44
00:01:55,290 --> 00:01:59,009
glitching a lot of people seem to think

45
00:01:57,270 --> 00:02:00,539
that glitching is magic and that it's

46
00:01:59,009 --> 00:02:04,020
really hard to do and that it's not a

47
00:02:00,540 --> 00:02:05,189
realistic attack scenario and we want to

48
00:02:04,020 --> 00:02:08,310
change this we want to make it more

49
00:02:05,189 --> 00:02:10,739
accessible we want to to really show how

50
00:02:08,310 --> 00:02:12,060
easy it is to do and why is this getting

51
00:02:10,739 --> 00:02:13,950
more important and why is this

52
00:02:12,060 --> 00:02:14,240
interesting well you can basically apply

53
00:02:13,950 --> 00:02:17,040
the

54
00:02:14,240 --> 00:02:18,720
methodology of hack once and break-in

55
00:02:17,040 --> 00:02:21,090
everywhere if you manage to break break

56
00:02:18,720 --> 00:02:22,650
at single-chip you can break any device

57
00:02:21,090 --> 00:02:24,480
that's based on this chip and you

58
00:02:22,650 --> 00:02:26,010
basically have a general O'Day that is

59
00:02:24,480 --> 00:02:29,340
unfixable without the new hardware

60
00:02:26,010 --> 00:02:31,769
version we also think that security

61
00:02:29,340 --> 00:02:34,110
devices are essential for a lot of use

62
00:02:31,770 --> 00:02:36,450
cases and so we want to see chip vendors

63
00:02:34,110 --> 00:02:39,570
and also developers improve their

64
00:02:36,450 --> 00:02:42,269
protections against glitching and also

65
00:02:39,570 --> 00:02:43,950
as you will see even chips that claim

66
00:02:42,270 --> 00:02:48,209
they are very secure might not be as

67
00:02:43,950 --> 00:02:49,950
secure as you would want them to be so

68
00:02:48,209 --> 00:02:52,410
if you start off what is Fault

69
00:02:49,950 --> 00:02:55,109
injections so fault injection is a term

70
00:02:52,410 --> 00:02:56,579
mainly used by professionals who we in

71
00:02:55,110 --> 00:02:59,880
the hacker community just call it

72
00:02:56,580 --> 00:03:02,400
glitching and the idea behind glitching

73
00:02:59,880 --> 00:03:04,500
is you basically introduce faults into

74
00:03:02,400 --> 00:03:06,180
your chips so for example you cut the

75
00:03:04,500 --> 00:03:08,880
power for a very very short amount of

76
00:03:06,180 --> 00:03:11,220
time and see how the chip behaves you

77
00:03:08,880 --> 00:03:13,519
change the period of the clock signal or

78
00:03:11,220 --> 00:03:14,940
if you're calling you start injecting

79
00:03:13,520 --> 00:03:16,890
electromagnetic shocks

80
00:03:14,940 --> 00:03:21,300
basically pointing a laser at your

81
00:03:16,890 --> 00:03:23,970
processor what we'll talk about today is

82
00:03:21,300 --> 00:03:26,130
mainly voltage glitching and so the idea

83
00:03:23,970 --> 00:03:27,989
behind voltage glitching is that we cut

84
00:03:26,130 --> 00:03:30,329
the power to the chip for a very very

85
00:03:27,989 --> 00:03:32,489
short amount of time and at a very very

86
00:03:30,330 --> 00:03:34,769
precisely timed moment and this can

87
00:03:32,489 --> 00:03:36,360
cause undefined behavior and so for

88
00:03:34,769 --> 00:03:39,120
example if you look at the data sheet of

89
00:03:36,360 --> 00:03:41,670
the chip it defines the safe operating

90
00:03:39,120 --> 00:03:43,700
area in which you basically see how with

91
00:03:41,670 --> 00:03:47,339
the chip is stable in these conditions

92
00:03:43,700 --> 00:03:49,018
but what happens if we go beyond these

93
00:03:47,340 --> 00:03:51,900
conditions and start doing some

94
00:03:49,019 --> 00:03:55,410
interesting stuff so for example we

95
00:03:51,900 --> 00:03:57,810
could as shown on this video introduce a

96
00:03:55,410 --> 00:03:59,310
very short drop in the power pulse and

97
00:03:57,810 --> 00:04:02,310
this can cause a lot of strange behavior

98
00:03:59,310 --> 00:04:04,200
and so just to summarize the basic idea

99
00:04:02,310 --> 00:04:06,239
behind glitching is you wait for a

100
00:04:04,200 --> 00:04:08,130
trigger event you wait for a certain

101
00:04:06,239 --> 00:04:09,540
delay and then you run your glitch and

102
00:04:08,130 --> 00:04:12,030
then you hope to do something

103
00:04:09,540 --> 00:04:14,070
interesting so for example if you do

104
00:04:12,030 --> 00:04:16,108
this on a device you might trigger on

105
00:04:14,070 --> 00:04:18,478
device boot you wait until you're right

106
00:04:16,108 --> 00:04:20,370
in the bootloader you glitch during the

107
00:04:18,478 --> 00:04:23,570
firmware validation check and you might

108
00:04:20,370 --> 00:04:26,340
be able to do the modified firmware and

109
00:04:23,570 --> 00:04:28,150
some very susceptible parts in the chip

110
00:04:26,340 --> 00:04:31,119
are for example flash reads

111
00:04:28,150 --> 00:04:33,340
basically if you if you read flash data

112
00:04:31,120 --> 00:04:35,350
it takes a lot of power in the chip now

113
00:04:33,340 --> 00:04:37,539
we can interrupt this power and if that

114
00:04:35,350 --> 00:04:40,210
happens we basically get back undefined

115
00:04:37,540 --> 00:04:42,699
or garbled data so for example here we

116
00:04:40,210 --> 00:04:45,159
have a power trace of a boot up of a

117
00:04:42,699 --> 00:04:48,130
chip basically this area is where the

118
00:04:45,160 --> 00:04:50,229
boot ROM the the code that is embedded

119
00:04:48,130 --> 00:04:52,389
in the chip is ran and we can see

120
00:04:50,229 --> 00:04:55,000
there's a huge power spike where the

121
00:04:52,389 --> 00:04:56,710
flash loads start and we can do the same

122
00:04:55,000 --> 00:04:59,979
with RAM so let's for example say we

123
00:04:56,710 --> 00:05:01,810
have a bootloader that has a method we

124
00:04:59,979 --> 00:05:04,180
call to check whether the firmware that

125
00:05:01,810 --> 00:05:06,400
is on the device is valid and then we

126
00:05:04,180 --> 00:05:09,510
have a simple boolean check if firmware

127
00:05:06,400 --> 00:05:12,370
is valid then we boot our our firmware

128
00:05:09,510 --> 00:05:14,919
but if we manage to insert the glitch

129
00:05:12,370 --> 00:05:17,680
write it as this check if we manage to

130
00:05:14,919 --> 00:05:19,810
flip a single bit the boolean condition

131
00:05:17,680 --> 00:05:21,039
will evaluate to true and suddenly we

132
00:05:19,810 --> 00:05:26,800
are able to boot for example a

133
00:05:21,039 --> 00:05:29,260
compromised firmware so yeah how do you

134
00:05:26,800 --> 00:05:32,130
actually do this my colleague Josh is

135
00:05:29,260 --> 00:05:36,159
kind of walk you through it

136
00:05:32,130 --> 00:05:39,430
all right so we're gonna talk about the

137
00:05:36,160 --> 00:05:40,780
three steps to success so what are the

138
00:05:39,430 --> 00:05:42,849
three methods that we have to do to

139
00:05:40,780 --> 00:05:44,888
apply the method of looking at a new

140
00:05:42,849 --> 00:05:46,270
target and getting ready well there's

141
00:05:44,889 --> 00:05:48,910
always a prepare step so that's step

142
00:05:46,270 --> 00:05:50,740
number one then we have to write some

143
00:05:48,910 --> 00:05:52,630
firmware so unfortunately if your

144
00:05:50,740 --> 00:05:53,770
Hardware person this this is the part

145
00:05:52,630 --> 00:05:55,240
you don't like or if you're a firmware

146
00:05:53,770 --> 00:05:56,859
person this is what you would like to do

147
00:05:55,240 --> 00:06:01,360
but we have to write some firmware and

148
00:05:56,860 --> 00:06:05,139
then we hook it up and butch it so part

149
00:06:01,360 --> 00:06:06,820
1 prepping the device so in this part we

150
00:06:05,139 --> 00:06:08,800
have to do some research about the

151
00:06:06,820 --> 00:06:11,169
target that we're interested in and we

152
00:06:08,800 --> 00:06:14,139
have to read the datasheet and get some

153
00:06:11,169 --> 00:06:15,820
information specifically for voltage

154
00:06:14,139 --> 00:06:20,610
glitching we're very interested in how

155
00:06:15,820 --> 00:06:22,719
the power demeans are set up and most

156
00:06:20,610 --> 00:06:24,130
modern microcontrollers are going to

157
00:06:22,720 --> 00:06:26,620
have multiple different voltages

158
00:06:24,130 --> 00:06:28,449
especially as they migrate into systems

159
00:06:26,620 --> 00:06:32,710
on shipping and get more complicated for

160
00:06:28,449 --> 00:06:35,020
example there could be a main VCC if 3.3

161
00:06:32,710 --> 00:06:37,390
volts that also could be the mean and

162
00:06:35,020 --> 00:06:40,210
logic i/o so that also could be 3.3

163
00:06:37,390 --> 00:06:41,860
volts however the CPU core and the logic

164
00:06:40,210 --> 00:06:44,400
for the CPU may run at a lower of

165
00:06:41,860 --> 00:06:46,660
Oh point seven to 1.2 volts and

166
00:06:44,400 --> 00:06:50,260
depending on the chip that may either be

167
00:06:46,660 --> 00:06:53,440
fed in externally or it's internally

168
00:06:50,260 --> 00:06:54,940
regulated lastly if there's a radio like

169
00:06:53,440 --> 00:06:56,740
Wi-Fi or Bluetooth or something that may

170
00:06:54,940 --> 00:06:59,020
require a different voltage so all this

171
00:06:56,740 --> 00:07:00,760
is we are just doing this reconnaissance

172
00:06:59,020 --> 00:07:02,380
trying to gather information about the

173
00:07:00,760 --> 00:07:06,190
chip we're trying to talk understand the

174
00:07:02,380 --> 00:07:07,570
power domains so if we look at you know

175
00:07:06,190 --> 00:07:12,070
the datasheet we may see something like

176
00:07:07,570 --> 00:07:14,650
this this is the NRF I believe and NRF

177
00:07:12,070 --> 00:07:17,860
52 which is a popular Bluetooth chip

178
00:07:14,650 --> 00:07:19,870
found the many IOT devices and this is

179
00:07:17,860 --> 00:07:21,550
just a diagram explaining how some of

180
00:07:19,870 --> 00:07:24,160
the internal power circuitry works and

181
00:07:21,550 --> 00:07:25,900
this is really useful because we really

182
00:07:24,160 --> 00:07:30,760
going to need this information to help

183
00:07:25,900 --> 00:07:32,409
build out the glitcher so let's make

184
00:07:30,760 --> 00:07:34,120
block diagrams because block diagrams

185
00:07:32,410 --> 00:07:35,860
are fun and so let's take the

186
00:07:34,120 --> 00:07:39,040
microcontroller and we were kind of

187
00:07:35,860 --> 00:07:42,840
using this example a CPU core Wi-Fi IP

188
00:07:39,040 --> 00:07:46,330
block and GPIO we have these three

189
00:07:42,840 --> 00:07:48,310
voltages in this hypothetical example

190
00:07:46,330 --> 00:07:49,810
there all right now they're being fed by

191
00:07:48,310 --> 00:07:52,270
three three but internally they're doing

192
00:07:49,810 --> 00:07:55,630
different things and that makes a

193
00:07:52,270 --> 00:07:57,070
difference because well internally we

194
00:07:55,630 --> 00:07:59,320
may want to be touching different parts

195
00:07:57,070 --> 00:08:01,480
of the logic so there's could be this

196
00:07:59,320 --> 00:08:03,370
core regulator that comes in two three

197
00:08:01,480 --> 00:08:05,920
three the feed the CPU core there could

198
00:08:03,370 --> 00:08:08,850
be also a different voltage regulator to

199
00:08:05,920 --> 00:08:12,190
drop the voltage down to one point three

200
00:08:08,850 --> 00:08:14,890
and so we're just kind of building out

201
00:08:12,190 --> 00:08:16,870
the block diagram here and so then also

202
00:08:14,890 --> 00:08:19,240
three three might just have no regulator

203
00:08:16,870 --> 00:08:22,030
because it's going right to the GPIO IP

204
00:08:19,240 --> 00:08:24,760
block so that's all useful information

205
00:08:22,030 --> 00:08:26,979
well you know now we know how and we

206
00:08:24,760 --> 00:08:30,430
have a hypothesis how the internal IP

207
00:08:26,980 --> 00:08:33,100
voltage and power systems work let's now

208
00:08:30,430 --> 00:08:36,729
look externally so externally the chip

209
00:08:33,100 --> 00:08:38,950
we have this capacitor and so that those

210
00:08:36,729 --> 00:08:41,130
two lines there on that thing is just

211
00:08:38,950 --> 00:08:44,229
the electrical symbol for capacitor and

212
00:08:41,130 --> 00:08:46,900
it's external to the chip and this is

213
00:08:44,229 --> 00:08:49,300
often recommended by microcontrollers if

214
00:08:46,900 --> 00:08:51,000
you look in the reference design and

215
00:08:49,300 --> 00:08:53,189
because what this external capacitor

216
00:08:51,000 --> 00:08:55,889
does is

217
00:08:53,190 --> 00:08:57,209
to use the software example if you are

218
00:08:55,889 --> 00:08:59,279
familiar with databases you know you've

219
00:08:57,209 --> 00:09:01,319
got MongoDB but that's it's really

220
00:08:59,279 --> 00:09:02,970
expensive to go talk to MongoDB so what

221
00:09:01,319 --> 00:09:05,279
do you need from that obviously you need

222
00:09:02,970 --> 00:09:06,810
memcached so memcache acts as this

223
00:09:05,279 --> 00:09:09,300
little cache that's quicker to access

224
00:09:06,810 --> 00:09:10,560
than going all these back to Mongo kind

225
00:09:09,300 --> 00:09:12,300
of a similar idea with external

226
00:09:10,560 --> 00:09:14,369
capacitors you can go all the way back

227
00:09:12,300 --> 00:09:15,508
to the power source and get that voltage

228
00:09:14,370 --> 00:09:17,459
but if you have an external capacitor

229
00:09:15,509 --> 00:09:20,279
there kind of acts like a little bit of

230
00:09:17,459 --> 00:09:24,329
a cache and so if you take those

231
00:09:20,279 --> 00:09:26,189
external capacitors off it's stable I

232
00:09:24,329 --> 00:09:28,949
mean we're getting 3.3 volts but it's

233
00:09:26,189 --> 00:09:30,660
very fuzzy and so that very fuzzy signal

234
00:09:28,949 --> 00:09:33,628
is indicative that there's lots of

235
00:09:30,660 --> 00:09:35,189
ripple in the power supply this is the

236
00:09:33,629 --> 00:09:37,259
fact we're going to exploit when we do

237
00:09:35,189 --> 00:09:39,300
the glitch but this this isn't what if

238
00:09:37,259 --> 00:09:41,910
you're trying to build something this is

239
00:09:39,300 --> 00:09:44,219
really not what you want you want the

240
00:09:41,910 --> 00:09:47,009
capacitor there to get a nice clean

241
00:09:44,220 --> 00:09:50,730
three point three single trace so for

242
00:09:47,009 --> 00:09:52,579
glitching though give her those caps now

243
00:09:50,730 --> 00:09:55,470
the other thing that's interesting is

244
00:09:52,579 --> 00:09:57,000
you know in we've done over Conesus we

245
00:09:55,470 --> 00:09:59,970
look at this datasheet we're trying to

246
00:09:57,000 --> 00:10:03,029
glitch the logic what's nice about this

247
00:09:59,970 --> 00:10:04,529
block diagram is that that logic pin

248
00:10:03,029 --> 00:10:07,620
that's coming out external to the

249
00:10:04,529 --> 00:10:10,920
capacitor that bypasses this core

250
00:10:07,620 --> 00:10:13,319
regulators and so what's really nice is

251
00:10:10,920 --> 00:10:16,199
when we remove that capacitor take it

252
00:10:13,319 --> 00:10:18,660
out of place we can potentially access

253
00:10:16,199 --> 00:10:20,819
that that voltage to that logic port

254
00:10:18,660 --> 00:10:25,319
directly and so that's going to be very

255
00:10:20,819 --> 00:10:27,870
useful for us later on and so sometimes

256
00:10:25,319 --> 00:10:30,959
this is called BDD core there could be

257
00:10:27,870 --> 00:10:32,579
different names on the datasheet but the

258
00:10:30,959 --> 00:10:35,040
the key insight here is that we have a

259
00:10:32,579 --> 00:10:36,870
nice direct access to the internal CPU

260
00:10:35,040 --> 00:10:38,699
core we don't have to provide just three

261
00:10:36,870 --> 00:10:40,170
three because that voltage regulator is

262
00:10:38,699 --> 00:10:42,029
kind of in the way it's going to be

263
00:10:40,170 --> 00:10:45,259
messing things up and now we can supply

264
00:10:42,029 --> 00:10:48,329
voltage directly to the CPU recorder so

265
00:10:45,259 --> 00:10:51,600
this we're sticking with the NRF example

266
00:10:48,329 --> 00:10:53,849
this is just the NRF 52 on kind of a

267
00:10:51,600 --> 00:10:58,050
breakout board in a slightly productized

268
00:10:53,850 --> 00:10:59,250
form and this is again we look at the

269
00:10:58,050 --> 00:11:00,990
ditch the method is look at the data

270
00:10:59,250 --> 00:11:02,699
sheet get some information we now we

271
00:11:00,990 --> 00:11:04,680
know there's external capacitors that we

272
00:11:02,699 --> 00:11:06,060
may want to remove to get better access

273
00:11:04,680 --> 00:11:08,550
so

274
00:11:06,060 --> 00:11:12,180
those things in red are those external

275
00:11:08,550 --> 00:11:15,599
capacitors they're in the way you know

276
00:11:12,180 --> 00:11:17,819
we want to get rid of those however this

277
00:11:15,600 --> 00:11:19,860
is the point where you know trying to do

278
00:11:17,820 --> 00:11:22,770
it ghost attack is also I should say

279
00:11:19,860 --> 00:11:25,380
more art than science there's a lot of

280
00:11:22,770 --> 00:11:28,260
factors that can cause an issue one of

281
00:11:25,380 --> 00:11:30,210
which is if the manufacturer is

282
00:11:28,260 --> 00:11:33,569
recommending that you add capacitors to

283
00:11:30,210 --> 00:11:35,460
make your system be more stable removing

284
00:11:33,570 --> 00:11:38,970
them makes them more unstable some chips

285
00:11:35,460 --> 00:11:42,630
may not boot without them so kind of

286
00:11:38,970 --> 00:11:45,900
depends on the chip but if you take

287
00:11:42,630 --> 00:11:49,110
those out may not run stable however so

288
00:11:45,900 --> 00:11:52,110
for a VD core we can overcome this and

289
00:11:49,110 --> 00:11:54,060
we can provide a nice clean VDD core

290
00:11:52,110 --> 00:11:57,870
directly with an external power supply

291
00:11:54,060 --> 00:12:00,689
so we're big fans of these cheap

292
00:11:57,870 --> 00:12:03,210
programmable external power supplies you

293
00:12:00,690 --> 00:12:04,740
basically cut a wall work you wire it up

294
00:12:03,210 --> 00:12:07,440
and then you've got a nice custom wall

295
00:12:04,740 --> 00:12:10,380
power supply and there's even open

296
00:12:07,440 --> 00:12:12,180
firmware for this and it has a serial

297
00:12:10,380 --> 00:12:14,700
interface if you dig around and you can

298
00:12:12,180 --> 00:12:17,729
control it externally so relatively

299
00:12:14,700 --> 00:12:20,340
cheap and super fun if you need extra

300
00:12:17,730 --> 00:12:23,280
volt power supply so this is kind of our

301
00:12:20,340 --> 00:12:25,560
go-to power supply and yeah so the

302
00:12:23,280 --> 00:12:29,069
insight then again is we don't want to

303
00:12:25,560 --> 00:12:30,290
glitch 3.34 this microcontroller because

304
00:12:29,070 --> 00:12:32,100
that poor regulators in the way

305
00:12:30,290 --> 00:12:34,140
regulator is going to be fighting the

306
00:12:32,100 --> 00:12:35,850
glitch we want to go directly to the

307
00:12:34,140 --> 00:12:39,270
logic or so that's mainly where the

308
00:12:35,850 --> 00:12:41,640
interesting things are happening so we

309
00:12:39,270 --> 00:12:45,500
provide that external voltage and we

310
00:12:41,640 --> 00:12:48,230
that's where we conclude and if you look

311
00:12:45,500 --> 00:12:51,120
this is basically you know we took the

312
00:12:48,230 --> 00:12:53,310
this board remove the capacitor soldered

313
00:12:51,120 --> 00:12:54,900
or wire and now we're directly where we

314
00:12:53,310 --> 00:12:59,250
want to be we've got tapped to the Vedic

315
00:12:54,900 --> 00:13:00,480
or the media core in this case and so

316
00:12:59,250 --> 00:13:02,460
this is basically and that's all the

317
00:13:00,480 --> 00:13:04,830
prep that you have to do so so it's a

318
00:13:02,460 --> 00:13:06,870
lot of paperwork I mean a lot of reading

319
00:13:04,830 --> 00:13:08,280
the paperwork it's a lot of you know

320
00:13:06,870 --> 00:13:10,500
learning about the chip but the actual

321
00:13:08,280 --> 00:13:12,660
physical hands-on prep for this one was

322
00:13:10,500 --> 00:13:12,990
just once you have figured out where

323
00:13:12,660 --> 00:13:15,819
that is

324
00:13:12,990 --> 00:13:18,920
remove the capacitors at the wire

325
00:13:15,820 --> 00:13:20,329
okay so this is now we're going to be

326
00:13:18,920 --> 00:13:24,290
talking about what's the test firmware

327
00:13:20,329 --> 00:13:26,719
that we have to write and so this is not

328
00:13:24,290 --> 00:13:29,360
unlike traditional embedded development

329
00:13:26,720 --> 00:13:32,089
where we have to do us to bring up so

330
00:13:29,360 --> 00:13:34,250
it's very dependent on the manufacturer

331
00:13:32,089 --> 00:13:35,899
of the chip and this is where you it's

332
00:13:34,250 --> 00:13:37,940
either super easy if someone else has

333
00:13:35,899 --> 00:13:39,889
done it and you copy the project win or

334
00:13:37,940 --> 00:13:41,360
you actually have to download the

335
00:13:39,889 --> 00:13:42,920
vendors that's okay and then figure out

336
00:13:41,360 --> 00:13:44,750
why that doesn't compile and fight

337
00:13:42,920 --> 00:13:48,279
through lots of problems of why you

338
00:13:44,750 --> 00:13:50,690
can't get the blue key to work so but

339
00:13:48,279 --> 00:13:52,550
basically we're trying to keep the

340
00:13:50,690 --> 00:13:54,800
firmware very simple we really just want

341
00:13:52,550 --> 00:13:57,589
to initialize the system we need to

342
00:13:54,800 --> 00:13:59,899
provide a good clean trigger for the

343
00:13:57,589 --> 00:14:02,569
glitcher to work and we need to also

344
00:13:59,899 --> 00:14:04,250
know when we're done so we know what

345
00:14:02,569 --> 00:14:06,469
does this look like when we build this

346
00:14:04,250 --> 00:14:08,810
firmware so if we kind of think about an

347
00:14:06,470 --> 00:14:12,769
Arduino example so Arduino is a nice

348
00:14:08,810 --> 00:14:14,349
simple API it's pretty clear you know

349
00:14:12,769 --> 00:14:16,940
when here we're gonna walk through

350
00:14:14,350 --> 00:14:18,529
basically this example firmware and this

351
00:14:16,940 --> 00:14:22,279
is all you would need to write for a

352
00:14:18,529 --> 00:14:24,889
test target or something similar so and

353
00:14:22,279 --> 00:14:27,620
the device has the boot you know so the

354
00:14:24,889 --> 00:14:29,120
boot rom is going to take care of that

355
00:14:27,620 --> 00:14:31,550
for us and then it's going to launch

356
00:14:29,120 --> 00:14:34,370
user code and then once we get into user

357
00:14:31,550 --> 00:14:37,189
space we have to do things like perhaps

358
00:14:34,370 --> 00:14:39,050
configure clocks so whatever clock speed

359
00:14:37,190 --> 00:14:41,360
you want to write enable or disable the

360
00:14:39,050 --> 00:14:42,949
Breanna detector configure some pins and

361
00:14:41,360 --> 00:14:46,459
here we're setting these two pins to the

362
00:14:42,949 --> 00:14:49,310
output then we have to set the pin to

363
00:14:46,459 --> 00:14:51,469
trigger as a high so in the kind of you

364
00:14:49,310 --> 00:14:53,180
know where we're at is we're kind of

365
00:14:51,470 --> 00:14:55,490
talking about generic approach to

366
00:14:53,180 --> 00:14:56,660
glitching a glitching a chip and this

367
00:14:55,490 --> 00:14:58,550
stage we're talking about making just

368
00:14:56,660 --> 00:15:00,620
kind of the generic firmware and so to

369
00:14:58,550 --> 00:15:03,380
make it easy on ourselves we just toggle

370
00:15:00,620 --> 00:15:05,329
the GPIO high and we can have a nice

371
00:15:03,380 --> 00:15:09,860
clean trigger for any system and that's

372
00:15:05,329 --> 00:15:12,170
exactly what we do then the you know

373
00:15:09,860 --> 00:15:14,180
what it is that to get this indicator of

374
00:15:12,170 --> 00:15:15,709
success what we're looking at is we're

375
00:15:14,180 --> 00:15:18,290
looking at a flash lead and so we're

376
00:15:15,709 --> 00:15:19,939
gonna be talking into it that's that's

377
00:15:18,290 --> 00:15:22,370
interesting because there's code there

378
00:15:19,939 --> 00:15:24,889
and there could be a secrets there and

379
00:15:22,370 --> 00:15:26,720
so we're particularly interested to see

380
00:15:24,889 --> 00:15:30,470
if our glitch effect

381
00:15:26,720 --> 00:15:32,990
affected a flash read so basically what

382
00:15:30,470 --> 00:15:35,120
we do is we loop we have something known

383
00:15:32,990 --> 00:15:36,800
in the flash I'm that could be data that

384
00:15:35,120 --> 00:15:38,870
you sucked in there could be some of the

385
00:15:36,800 --> 00:15:40,969
code somehow you know what's interpret

386
00:15:38,870 --> 00:15:44,350
what the flash reads should be and we

387
00:15:40,970 --> 00:15:46,850
just loop around and then eventually

388
00:15:44,350 --> 00:15:50,720
when we're going to apply the glitch if

389
00:15:46,850 --> 00:15:52,610
it's not what's expected we went right

390
00:15:50,720 --> 00:15:54,319
so the glitch was successful you would

391
00:15:52,610 --> 00:15:55,850
expect my controller to always

392
00:15:54,319 --> 00:15:58,339
consistently read the same thing from

393
00:15:55,850 --> 00:16:00,290
flash right so you would think this you

394
00:15:58,339 --> 00:16:04,399
know shouldn't exit but it does when we

395
00:16:00,290 --> 00:16:06,410
apply a bunch and so what does this look

396
00:16:04,399 --> 00:16:09,589
like on an oscilloscope and so this is

397
00:16:06,410 --> 00:16:11,149
just an example these are the two traces

398
00:16:09,589 --> 00:16:13,550
of those two GPIO pins we were

399
00:16:11,149 --> 00:16:15,110
previously talking about and let's just

400
00:16:13,550 --> 00:16:17,269
go through those steps of what you would

401
00:16:15,110 --> 00:16:19,399
expect to see on a sillas cope which is

402
00:16:17,269 --> 00:16:22,819
very helpful when you're trying to do

403
00:16:19,399 --> 00:16:25,250
this kind of attack so you start off the

404
00:16:22,819 --> 00:16:27,560
microcontroller has booted now in this

405
00:16:25,250 --> 00:16:29,089
section it's preparing the system clocks

406
00:16:27,560 --> 00:16:31,250
doing all that system bring up stuff

407
00:16:29,089 --> 00:16:35,029
that we just have to do in order to run

408
00:16:31,250 --> 00:16:36,889
our to run our code so here's where the

409
00:16:35,029 --> 00:16:38,959
more interesting bits start we have to

410
00:16:36,889 --> 00:16:40,970
trigger the event for the Glitter so

411
00:16:38,959 --> 00:16:43,550
this is just we artificially in this

412
00:16:40,970 --> 00:16:47,050
case meet at the GPIO high on a real

413
00:16:43,550 --> 00:16:50,180
target this could be something else and

414
00:16:47,050 --> 00:16:51,740
then there's but one of the key

415
00:16:50,180 --> 00:16:54,859
parameters and the Glitter is how much

416
00:16:51,740 --> 00:16:56,720
to delay right so we're trying to we're

417
00:16:54,860 --> 00:16:58,910
trying to glitch that flash free that

418
00:16:56,720 --> 00:17:01,360
happened in that loop so the glitcher

419
00:16:58,910 --> 00:17:03,589
takes this thomas mentioned there's this

420
00:17:01,360 --> 00:17:05,480
programmable delay that we can take and

421
00:17:03,589 --> 00:17:08,630
this is what we see in the next scope

422
00:17:05,480 --> 00:17:10,099
trace then we insert the glitch and so

423
00:17:08,630 --> 00:17:12,770
this is where we're hoping that we get

424
00:17:10,099 --> 00:17:14,948
that exact precise moment to trigger the

425
00:17:12,770 --> 00:17:18,500
glitch or if the insert the glitch and

426
00:17:14,949 --> 00:17:20,900
what happens well that depends on what

427
00:17:18,500 --> 00:17:23,599
your indicator of success was so in this

428
00:17:20,900 --> 00:17:25,370
case yeah so that could be you know

429
00:17:23,599 --> 00:17:26,928
we've got another GPIO signal we've

430
00:17:25,369 --> 00:17:28,899
broken out something happen on serial

431
00:17:26,929 --> 00:17:33,049
but however you set up that system

432
00:17:28,900 --> 00:17:35,480
that's the indicator and so yeah part

433
00:17:33,049 --> 00:17:38,430
three of this is talking about you know

434
00:17:35,480 --> 00:17:41,890
what is the culture that we made

435
00:17:38,430 --> 00:17:43,860
okay so the chip that fell glitcher

436
00:17:41,890 --> 00:17:48,670
consists of mainly three main components

437
00:17:43,860 --> 00:17:50,919
there is this FPGA and so we were using

438
00:17:48,670 --> 00:17:55,900
the digital and C mod a seven so it's

439
00:17:50,920 --> 00:17:59,230
just a Arctic's FPGA it's about 70 US

440
00:17:55,900 --> 00:18:03,580
dollars it's has one Piemonte connector

441
00:17:59,230 --> 00:18:06,640
has a nice USB UART pretty small

442
00:18:03,580 --> 00:18:08,020
we need a the other component that were

443
00:18:06,640 --> 00:18:09,790
using is we were talking about there's

444
00:18:08,020 --> 00:18:11,680
lots of signals we want to be able to

445
00:18:09,790 --> 00:18:13,659
drop the voltage so there's a couple

446
00:18:11,680 --> 00:18:16,270
different techniques for that the thing

447
00:18:13,660 --> 00:18:18,940
that we're using is an analog switch or

448
00:18:16,270 --> 00:18:22,000
a multiplexer and that's what the middle

449
00:18:18,940 --> 00:18:24,750
board is so that multiplexer costs about

450
00:18:22,000 --> 00:18:27,430
a dollar eighty in single quantity and

451
00:18:24,750 --> 00:18:31,270
that goes on the Piemonte connector

452
00:18:27,430 --> 00:18:33,220
there and then we need that DPS 3003

453
00:18:31,270 --> 00:18:33,760
power supply because which is about

454
00:18:33,220 --> 00:18:36,580
twenty bucks

455
00:18:33,760 --> 00:18:39,250
and that's going to help feed in the

456
00:18:36,580 --> 00:18:41,500
voltages that we want and so yeah the

457
00:18:39,250 --> 00:18:43,750
nice things about using an FPGA is we

458
00:18:41,500 --> 00:18:46,240
get super precise timing timing down to

459
00:18:43,750 --> 00:18:47,680
the so we can control individual clock

460
00:18:46,240 --> 00:18:50,650
cycles which isn't I mean we get that

461
00:18:47,680 --> 00:18:53,590
clock cycle precision running at 100

462
00:18:50,650 --> 00:18:56,020
megahertz and yeah part of this as we're

463
00:18:53,590 --> 00:19:00,300
gonna be really seeing the Vera log for

464
00:18:56,020 --> 00:19:04,330
this project as well and so the P mod

465
00:19:00,300 --> 00:19:07,240
specifically is using the max 4619 it's

466
00:19:04,330 --> 00:19:10,600
a three channel analog switch and it has

467
00:19:07,240 --> 00:19:12,490
a nice Pima it has a nice it's a

468
00:19:10,600 --> 00:19:14,560
standard Pima header on one end on the

469
00:19:12,490 --> 00:19:18,250
other jumper is a standard point one

470
00:19:14,560 --> 00:19:21,520
inch header easy for bread boarding we

471
00:19:18,250 --> 00:19:24,370
do have PCBs with us so I brought like

472
00:19:21,520 --> 00:19:26,830
200 or some so if you see me afterwards

473
00:19:24,370 --> 00:19:28,330
if I'll happily give you a PCB and this

474
00:19:26,830 --> 00:19:30,550
is now we're just you know what is this

475
00:19:28,330 --> 00:19:32,070
analog switch for those that are you

476
00:19:30,550 --> 00:19:34,990
know I'm familiar with how this works

477
00:19:32,070 --> 00:19:36,159
basically so there's there's three

478
00:19:34,990 --> 00:19:39,370
channels right now we're just talking

479
00:19:36,160 --> 00:19:42,070
about one channel Channel X and so

480
00:19:39,370 --> 00:19:43,899
channel for any channel X that being the

481
00:19:42,070 --> 00:19:47,679
output there could be two different

482
00:19:43,900 --> 00:19:49,420
inputs so typically what we our inputs

483
00:19:47,680 --> 00:19:50,920
are usually some voltage level and

484
00:19:49,420 --> 00:19:54,400
ground so X zero

485
00:19:50,920 --> 00:19:56,080
would be 1.2 volts for a VDD core x1

486
00:19:54,400 --> 00:19:57,850
will be ground and what we want to do is

487
00:19:56,080 --> 00:20:00,129
switch between them and so the way that

488
00:19:57,850 --> 00:20:02,620
works with an analog switch is you apply

489
00:20:00,130 --> 00:20:06,429
power or it's also called enable signal

490
00:20:02,620 --> 00:20:08,799
and it'll switch over and so it's a

491
00:20:06,429 --> 00:20:10,179
three channel so all that is when you do

492
00:20:08,799 --> 00:20:11,889
that in three channels is it looks like

493
00:20:10,179 --> 00:20:14,170
this and so now there's a lot of wires

494
00:20:11,890 --> 00:20:18,520
going on there but it's one channel

495
00:20:14,170 --> 00:20:20,650
multiplying and yeah that power supply

496
00:20:18,520 --> 00:20:22,870
we talked about immediately we're using

497
00:20:20,650 --> 00:20:25,030
it to supply VDD core like I said

498
00:20:22,870 --> 00:20:26,428
control about UART which is super nice

499
00:20:25,030 --> 00:20:28,600
get them on you can get them on Amazon

500
00:20:26,429 --> 00:20:31,990
and when you hook up all this together

501
00:20:28,600 --> 00:20:34,270
you have the FPGA so we're using that as

502
00:20:31,990 --> 00:20:36,730
the main so there's a post software

503
00:20:34,270 --> 00:20:39,070
that's driving this with Python talking

504
00:20:36,730 --> 00:20:41,559
to the FPGA over UART and then it has

505
00:20:39,070 --> 00:20:43,899
the trigger pin to know when to trigger

506
00:20:41,559 --> 00:20:45,850
the glitch it has this a success

507
00:20:43,900 --> 00:20:48,070
indicator and so that you know depends

508
00:20:45,850 --> 00:20:50,230
on what the particular target is we have

509
00:20:48,070 --> 00:20:51,610
the power an able signal going to them

510
00:20:50,230 --> 00:20:54,280
the MUX to switch between the two

511
00:20:51,610 --> 00:20:56,500
voltages there's also the glitch an evil

512
00:20:54,280 --> 00:20:58,480
signal that is doing the same thing into

513
00:20:56,500 --> 00:21:02,049
VDD core and all of us going to your

514
00:20:58,480 --> 00:21:03,790
device under test and yeah so we're

515
00:21:02,049 --> 00:21:06,820
gonna put this all together and I've

516
00:21:03,790 --> 00:21:08,950
since wasn't a big believer in 3d

517
00:21:06,820 --> 00:21:11,049
modeling things first because it's like

518
00:21:08,950 --> 00:21:13,080
I make the PCB get everything hooked up

519
00:21:11,049 --> 00:21:15,580
then see what it looks like afterwards

520
00:21:13,080 --> 00:21:17,760
sometimes I'm starting to learn that

521
00:21:15,580 --> 00:21:20,049
it's useful to do a 3d modeling before

522
00:21:17,760 --> 00:21:22,900
because sometimes you have some fails

523
00:21:20,049 --> 00:21:24,970
like when you have the P mod and the

524
00:21:22,900 --> 00:21:26,500
glitcher now you have to stack them

525
00:21:24,970 --> 00:21:30,790
vertically and it kind of sticks up like

526
00:21:26,500 --> 00:21:32,500
a nice L connector so protip 3d model

527
00:21:30,790 --> 00:21:34,510
it's getting easier with lots of

528
00:21:32,500 --> 00:21:37,630
different CAD tools you'll see

529
00:21:34,510 --> 00:21:41,379
embarrassment on slides and now we're

530
00:21:37,630 --> 00:21:44,230
ready to glitch awesome yes so um thanks

531
00:21:41,380 --> 00:21:45,460
Josh so you know that we know all the

532
00:21:44,230 --> 00:21:47,110
components that are involved in glitch

533
00:21:45,460 --> 00:21:50,530
in your board let's actually go about

534
00:21:47,110 --> 00:21:52,299
doing it so you asset for the FPGA we

535
00:21:50,530 --> 00:21:54,540
need a minute a bit stream which is

536
00:21:52,299 --> 00:21:57,490
basically the firmware of an FPGA and

537
00:21:54,540 --> 00:21:59,110
our FPGA bitstream provides a very

538
00:21:57,490 --> 00:22:00,790
simple serial interface that lets you

539
00:21:59,110 --> 00:22:04,809
adjust the settings such as the pulse

540
00:22:00,790 --> 00:22:06,730
width the power reset the delay between

541
00:22:04,809 --> 00:22:08,259
trigger and the glitch and also some

542
00:22:06,730 --> 00:22:10,330
other options such as whether you want

543
00:22:08,259 --> 00:22:12,460
to power cycle the device on on every

544
00:22:10,330 --> 00:22:14,860
glitch attempt and inspired by the new

545
00:22:12,460 --> 00:22:18,190
chip Whisperer we actually build a full

546
00:22:14,860 --> 00:22:20,498
control library in Jupiter notebook so

547
00:22:18,190 --> 00:22:23,289
this is super easy to use as basically

548
00:22:20,499 --> 00:22:25,149
self-documenting so you just open the

549
00:22:23,289 --> 00:22:28,029
jupiter notebook you configure the

550
00:22:25,149 --> 00:22:30,279
serial port and then you can write a

551
00:22:28,029 --> 00:22:32,679
really really simple admitting software

552
00:22:30,279 --> 00:22:34,600
in like I don't know 20 lines of code

553
00:22:32,679 --> 00:22:37,600
and basically all you have to do to

554
00:22:34,600 --> 00:22:39,340
configure the glitcher is you set up

555
00:22:37,600 --> 00:22:41,799
power pools which is basically how long

556
00:22:39,340 --> 00:22:43,990
do you need to cut the power to fully

557
00:22:41,799 --> 00:22:45,340
power of the device because sometimes

558
00:22:43,990 --> 00:22:48,070
you will get stuck and you need to

559
00:22:45,340 --> 00:22:51,999
reboot it and so on then we basically

560
00:22:48,070 --> 00:22:53,799
just have a success indicator we iterate

561
00:22:51,999 --> 00:22:56,289
over a delay range so for example you

562
00:22:53,799 --> 00:22:58,749
the key to glitching is trying a million

563
00:22:56,289 --> 00:23:00,730
different delays trying a million

564
00:22:58,749 --> 00:23:02,710
different pulls with and so on and you

565
00:23:00,730 --> 00:23:04,539
can automate this really easy in a

566
00:23:02,710 --> 00:23:08,169
couple of lines you just do a loop

567
00:23:04,539 --> 00:23:10,029
between delay from and delay to you set

568
00:23:08,169 --> 00:23:13,389
the command to set that delay to you the

569
00:23:10,029 --> 00:23:15,730
glitching board we just have a success

570
00:23:13,389 --> 00:23:17,949
indicator to break later on and then we

571
00:23:15,730 --> 00:23:20,049
just iterate over a range of pulses and

572
00:23:17,950 --> 00:23:21,909
so basically what this does is it's just

573
00:23:20,049 --> 00:23:24,279
it says how long is the each pulse

574
00:23:21,909 --> 00:23:25,929
actually active and this varies

575
00:23:24,279 --> 00:23:27,129
massively depending on your target so

576
00:23:25,929 --> 00:23:28,629
for example if your chip is running

577
00:23:27,129 --> 00:23:30,820
really really quickly at 100 megahertz

578
00:23:28,629 --> 00:23:33,009
you want this to be really really short

579
00:23:30,820 --> 00:23:35,408
but if you're targeting a slower chip

580
00:23:33,009 --> 00:23:37,659
such as one that we will see later this

581
00:23:35,409 --> 00:23:39,940
can be also really really long value and

582
00:23:37,659 --> 00:23:41,529
then you basically just send a view to

583
00:23:39,940 --> 00:23:44,289
come on to the board you wait a couple

584
00:23:41,529 --> 00:23:46,419
of minutes and then you for example in

585
00:23:44,289 --> 00:23:48,490
this case we just check the status of

586
00:23:46,419 --> 00:23:50,919
the GPIO whether our success pin went

587
00:23:48,490 --> 00:23:53,499
high and if you did we print a nice

588
00:23:50,919 --> 00:23:55,210
success message and that's it so how

589
00:23:53,499 --> 00:23:57,610
does this look in action so once you

590
00:23:55,210 --> 00:23:59,649
found some good values this is how the

591
00:23:57,610 --> 00:24:01,600
Glitter runs so you basically just hit

592
00:23:59,649 --> 00:24:04,059
run on the jupiter notebook you can see

593
00:24:01,600 --> 00:24:06,789
the progress bar indicating the range of

594
00:24:04,059 --> 00:24:08,918
the pulse we are in and on top of that

595
00:24:06,789 --> 00:24:11,529
is the delay and in this case we can see

596
00:24:08,919 --> 00:24:13,179
that with just roughly 200 attempts we

597
00:24:11,529 --> 00:24:15,129
successfully glitch the chip and that's

598
00:24:13,179 --> 00:24:18,309
really all it took you so you basically

599
00:24:15,129 --> 00:24:20,350
take the fpga they take a multiplexer

600
00:24:18,309 --> 00:24:22,210
you hook that all up into Python and

601
00:24:20,350 --> 00:24:23,860
you're ready to glitch no magic no

602
00:24:22,210 --> 00:24:29,830
expensive equipment it's really really

603
00:24:23,860 --> 00:24:32,559
trivial and so let's our goals for this

604
00:24:29,830 --> 00:24:34,299
we're basically two to five targets

605
00:24:32,559 --> 00:24:37,210
there are commonly used in IOT devices

606
00:24:34,299 --> 00:24:39,760
because we think this is where Musa of

607
00:24:37,210 --> 00:24:42,039
the new security issues will be

608
00:24:39,760 --> 00:24:44,039
happening and it should be a modern ship

609
00:24:42,039 --> 00:24:46,330
it shouldn't be a ten-year-old ship that

610
00:24:44,039 --> 00:24:48,400
doesn't have any protections anyway and

611
00:24:46,330 --> 00:24:51,970
we wanted to test many different vendors

612
00:24:48,400 --> 00:24:54,220
that we commonly see and so we went down

613
00:24:51,970 --> 00:24:57,850
through the list of four main targets so

614
00:24:54,220 --> 00:24:59,919
the first one is the NRF 50 to 84 zero

615
00:24:57,850 --> 00:25:02,110
which is a ship that is very commonly

616
00:24:59,919 --> 00:25:04,299
used in Bluetooth devices variables and

617
00:25:02,110 --> 00:25:06,340
so on so for example something like a

618
00:25:04,299 --> 00:25:09,010
dash button might use it then we have

619
00:25:06,340 --> 00:25:11,678
the ESP 32 which is a super common Wi-Fi

620
00:25:09,010 --> 00:25:13,780
Bluetooth chip we have this ml 11 which

621
00:25:11,679 --> 00:25:16,990
is a high security microcontroller and

622
00:25:13,780 --> 00:25:20,620
then the stm32 f2 and others from the

623
00:25:16,990 --> 00:25:22,240
series and our goals for this were to

624
00:25:20,620 --> 00:25:25,120
compute the chips in real-world

625
00:25:22,240 --> 00:25:27,159
conditions and just identify whether

626
00:25:25,120 --> 00:25:28,959
chip is susceptible to glitching attacks

627
00:25:27,159 --> 00:25:31,750
so the idea is not to necessarily have a

628
00:25:28,960 --> 00:25:33,610
fully exploit for chips but just to give

629
00:25:31,750 --> 00:25:35,080
a very simple way of checking whether

630
00:25:33,610 --> 00:25:36,908
the chip you are going to use in your

631
00:25:35,080 --> 00:25:38,980
product is susceptible to glitching or

632
00:25:36,909 --> 00:25:41,049
not and we also want to be able to test

633
00:25:38,980 --> 00:25:43,929
the chips in situ so for example we just

634
00:25:41,049 --> 00:25:46,150
order bread basic development board

635
00:25:43,929 --> 00:25:48,280
solder off some capacitors and then we

636
00:25:46,150 --> 00:25:50,140
go ahead and good chip without having to

637
00:25:48,280 --> 00:25:52,059
design a custom board without having to

638
00:25:50,140 --> 00:25:53,799
solder a lot of stuff all you need is a

639
00:25:52,059 --> 00:25:57,370
hot air gun and the soldering iron and

640
00:25:53,799 --> 00:26:02,530
that's it so let's start with the Nordic

641
00:25:57,370 --> 00:26:05,049
NRF 50 to 80 for zero so for this one we

642
00:26:02,530 --> 00:26:06,879
basically use the make a diary micro dev

643
00:26:05,049 --> 00:26:10,330
kit which is pretty nice cassette you

644
00:26:06,880 --> 00:26:12,970
can you get everything but portable and

645
00:26:10,330 --> 00:26:15,220
it's very commonly used in small IOT

646
00:26:12,970 --> 00:26:16,900
sensors and in this case as we've seen

647
00:26:15,220 --> 00:26:18,970
earlier the target preparation that we

648
00:26:16,900 --> 00:26:20,950
need to do is really just remove a

649
00:26:18,970 --> 00:26:23,760
couple of capacitors so in this case

650
00:26:20,950 --> 00:26:26,860
it's just these six

651
00:26:23,760 --> 00:26:29,140
add a crude jumper wire and now we are

652
00:26:26,860 --> 00:26:31,270
ready to glitch and so what we did is we

653
00:26:29,140 --> 00:26:32,020
wrote a very simple test firmware that

654
00:26:31,270 --> 00:26:34,120
does what we saw

655
00:26:32,020 --> 00:26:36,580
basically you boot the chip it puts a

656
00:26:34,120 --> 00:26:38,290
trigger line high and then we ditch a

657
00:26:36,580 --> 00:26:41,260
fast read and we check if we are

658
00:26:38,290 --> 00:26:44,950
successful in this case on the NR 52 we

659
00:26:41,260 --> 00:26:46,960
were successful after 1.5 hours we had a

660
00:26:44,950 --> 00:26:49,240
successful digitech we were able to

661
00:26:46,960 --> 00:26:51,730
glitch application code and we managed

662
00:26:49,240 --> 00:26:54,040
to get this glitch attempt really stable

663
00:26:51,730 --> 00:26:56,170
at roughly 100 attempts for a successful

664
00:26:54,040 --> 00:26:57,670
glitch we tested this against a couple

665
00:26:56,170 --> 00:27:00,070
of demo firmwares and we were able to

666
00:26:57,670 --> 00:27:02,280
find some critical vulnerabilities in a

667
00:27:00,070 --> 00:27:05,139
very short amount of time using this and

668
00:27:02,280 --> 00:27:07,180
yeah very trivial to do and will release

669
00:27:05,140 --> 00:27:09,820
both the schematic to do this and also

670
00:27:07,180 --> 00:27:13,630
the test firmware on our github

671
00:27:09,820 --> 00:27:15,280
I guess later this week the next one

672
00:27:13,630 --> 00:27:18,160
that I think is really interesting is

673
00:27:15,280 --> 00:27:21,220
the ESP 32 because this CPU is really

674
00:27:18,160 --> 00:27:23,440
fast so compared to our FPGA which runs

675
00:27:21,220 --> 00:27:27,220
at 100 megahertz this chip can run at

676
00:27:23,440 --> 00:27:28,900
162 240 megahertz and it has Bluetooth

677
00:27:27,220 --> 00:27:31,660
and Wi-Fi and it's very very commonly

678
00:27:28,900 --> 00:27:33,760
found in new IOT products so for example

679
00:27:31,660 --> 00:27:35,500
we had multiple customers who use this

680
00:27:33,760 --> 00:27:37,690
chip and if you use the secure boot

681
00:27:35,500 --> 00:27:40,140
features of this chip and so this was a

682
00:27:37,690 --> 00:27:42,310
really interesting target to us and so

683
00:27:40,140 --> 00:27:44,530
as we've mentioned before we need to

684
00:27:42,310 --> 00:27:46,389
find out which power rails do we need to

685
00:27:44,530 --> 00:27:49,000
attack so all you need to do is you look

686
00:27:46,390 --> 00:27:50,710
into the datasheet and you find the

687
00:27:49,000 --> 00:27:52,780
embedded power supply and you see that

688
00:27:50,710 --> 00:27:54,610
there are a couple of of caps you need

689
00:27:52,780 --> 00:27:57,520
to remove but unfortunately in the case

690
00:27:54,610 --> 00:27:59,169
of the ESP 32 you also need to get rid

691
00:27:57,520 --> 00:28:00,730
of this stick and and you can see that

692
00:27:59,170 --> 00:28:02,830
kind of messed up the board while doing

693
00:28:00,730 --> 00:28:05,670
it and just sold it on some magnet wires

694
00:28:02,830 --> 00:28:08,470
to the weak core parts right here and

695
00:28:05,670 --> 00:28:10,990
yeah and we are ready to go basically to

696
00:28:08,470 --> 00:28:14,410
write our test from where in the case of

697
00:28:10,990 --> 00:28:16,540
the ESP 32 we actually decided to write

698
00:28:14,410 --> 00:28:17,800
the test former in Arduino because it's

699
00:28:16,540 --> 00:28:19,960
really simple and it allows you to

700
00:28:17,800 --> 00:28:21,730
really simply select different clock

701
00:28:19,960 --> 00:28:24,760
speeds and you can see our sketch for

702
00:28:21,730 --> 00:28:27,100
just testing the glitches like 30 lines

703
00:28:24,760 --> 00:28:28,810
or so and we basically just do a fluff

704
00:28:27,100 --> 00:28:31,740
read on an address where we know the

705
00:28:28,810 --> 00:28:34,960
value and then once that value changes

706
00:28:31,740 --> 00:28:37,300
we set up a successful and committed

707
00:28:34,960 --> 00:28:40,240
without glitch and to drive the board we

708
00:28:37,300 --> 00:28:42,460
put it in one of those nice programmer

709
00:28:40,240 --> 00:28:44,080
boards which provide the 3.3 volts

710
00:28:42,460 --> 00:28:45,460
needed for the chip and allow us to

711
00:28:44,080 --> 00:28:46,899
really easily also

712
00:28:45,460 --> 00:28:48,700
switch out chips after we broke them

713
00:28:46,899 --> 00:28:52,168
because sometimes you will break chips

714
00:28:48,700 --> 00:28:55,179
during doing this so yeah

715
00:28:52,169 --> 00:28:57,190
oops sorry in this case we got our first

716
00:28:55,179 --> 00:28:58,779
successful attack after three hours and

717
00:28:57,190 --> 00:29:00,850
so this was a day where we managed to

718
00:28:58,779 --> 00:29:02,980
glitch three different chips in a single

719
00:29:00,850 --> 00:29:04,990
day which is really amazing because it's

720
00:29:02,980 --> 00:29:08,500
it takes no time to set up it takes no

721
00:29:04,990 --> 00:29:11,020
time to to to try anything because it

722
00:29:08,500 --> 00:29:12,760
will just run on on its own we slightly

723
00:29:11,020 --> 00:29:15,520
have to adjust that because basically

724
00:29:12,760 --> 00:29:17,559
the ESP takes a very long time to boot

725
00:29:15,520 --> 00:29:19,270
up and so we needed to have an enter

726
00:29:17,559 --> 00:29:21,460
this loop where we always push up the

727
00:29:19,270 --> 00:29:23,020
trigger and we couldn't just reboot it

728
00:29:21,460 --> 00:29:24,669
on every test so we had to adjust the

729
00:29:23,020 --> 00:29:25,899
test logic a bit but you will see that

730
00:29:24,669 --> 00:29:28,000
in the jupiter notebooks will be

731
00:29:25,899 --> 00:29:30,668
releasing for the ESP now we got this

732
00:29:28,000 --> 00:29:33,399
yes p32 is stable within roughly 10,000

733
00:29:30,669 --> 00:29:36,309
attempts and this has some interesting

734
00:29:33,399 --> 00:29:40,350
impact especially when you when you look

735
00:29:36,309 --> 00:29:44,200
at the secure boot features of the chip

736
00:29:40,350 --> 00:29:49,389
so this chip I'm super excited about

737
00:29:44,200 --> 00:29:53,620
microchips ml 11 so this chip is a world

738
00:29:49,390 --> 00:29:56,919
class out for low-power MCU for IOT and

739
00:29:53,620 --> 00:29:58,719
security and it's so secure it literally

740
00:29:56,919 --> 00:30:01,510
won the best contribution to IOT

741
00:29:58,720 --> 00:30:03,700
security and if you just search for the

742
00:30:01,510 --> 00:30:07,990
word secure on the website you will find

743
00:30:03,700 --> 00:30:10,529
57 minutes so this chip is 57 times more

744
00:30:07,990 --> 00:30:13,929
secure than some of the other chips and

745
00:30:10,529 --> 00:30:15,820
if we read the datasheet one of the

746
00:30:13,929 --> 00:30:17,890
things that that really set us off was

747
00:30:15,820 --> 00:30:20,950
basically there's a factory calibrated

748
00:30:17,890 --> 00:30:22,950
brownout detector on VDD core and so the

749
00:30:20,950 --> 00:30:25,600
idea behind the brownout detector is it

750
00:30:22,950 --> 00:30:27,130
issues on the power lines and so for

751
00:30:25,600 --> 00:30:28,959
example if your voltage drops too low

752
00:30:27,130 --> 00:30:31,390
the brownout detector will for example

753
00:30:28,960 --> 00:30:34,179
reboot your chip or reset your device or

754
00:30:31,390 --> 00:30:37,870
whatever and so we were kind of curious

755
00:30:34,179 --> 00:30:39,490
whether we can glitch it and it was very

756
00:30:37,870 --> 00:30:41,168
surprising he said the first time we

757
00:30:39,490 --> 00:30:44,340
thought we actually messed it up because

758
00:30:41,169 --> 00:30:47,590
we had success literally after 5 minutes

759
00:30:44,340 --> 00:30:50,529
so it's super susceptible to voltage

760
00:30:47,590 --> 00:30:53,289
glitching it's one of it's a secure chip

761
00:30:50,529 --> 00:30:55,600
and what's an issue for us is basically

762
00:30:53,289 --> 00:30:59,110
we have customers coming to us that want

763
00:30:55,600 --> 00:31:01,480
to use this chip as an HSM as a heresy

764
00:30:59,110 --> 00:31:03,459
he module besides their mainship because

765
00:31:01,480 --> 00:31:05,529
it's so it helps so many security

766
00:31:03,460 --> 00:31:08,049
features but then once you start looking

767
00:31:05,529 --> 00:31:10,120
at it it gets really really really easy

768
00:31:08,049 --> 00:31:12,010
to bypass and so for example we found a

769
00:31:10,120 --> 00:31:14,110
bypass of the secure reference

770
00:31:12,010 --> 00:31:16,379
bootloader which runs on trap zone and

771
00:31:14,110 --> 00:31:18,879
basically allows you to write a

772
00:31:16,380 --> 00:31:20,260
validated firmware the disclosure of

773
00:31:18,880 --> 00:31:23,140
that is in progress we hope to be able

774
00:31:20,260 --> 00:31:26,590
to release it soon and some more fun

775
00:31:23,140 --> 00:31:29,200
stuff on this chip and just one of the

776
00:31:26,590 --> 00:31:31,600
things so just how easy is it to glitch

777
00:31:29,200 --> 00:31:34,269
so I come from an from South Germany and

778
00:31:31,600 --> 00:31:36,580
we are really really really cheap so

779
00:31:34,269 --> 00:31:38,470
$100 for glitcher sounds really

780
00:31:36,580 --> 00:31:42,549
expensive like I don't know how many

781
00:31:38,470 --> 00:31:44,889
beers that is but it's a lot so and so

782
00:31:42,549 --> 00:31:48,429
the idea was how cheap can we get this

783
00:31:44,889 --> 00:31:51,219
glitch and so we built the five dollar

784
00:31:48,429 --> 00:31:53,200
picture basically we take one of the

785
00:31:51,220 --> 00:31:56,409
cheapest microcontrollers you can find

786
00:31:53,200 --> 00:31:58,179
on the geeky and AAT tiny 85 the

787
00:31:56,409 --> 00:32:00,580
multiplexer and you end up with roughly

788
00:31:58,179 --> 00:32:03,460
three or four dollars of equipment to

789
00:32:00,580 --> 00:32:07,379
which this high-security chip using very

790
00:32:03,460 --> 00:32:11,980
sophisticated lab setup on a breadboard

791
00:32:07,380 --> 00:32:13,510
so yeah that's how you break the very

792
00:32:11,980 --> 00:32:16,990
secure trust zone enabled

793
00:32:13,510 --> 00:32:19,539
microcontroller for five dollars and I

794
00:32:16,990 --> 00:32:21,639
will last but not least the stm32 f2

795
00:32:19,539 --> 00:32:23,919
which we call the million dollar

796
00:32:21,639 --> 00:32:28,899
microcontroller you will see why in just

797
00:32:23,919 --> 00:32:34,000
a moment okay so now we're going to talk

798
00:32:28,899 --> 00:32:36,820
about the stm32 f2 a5 so some of you may

799
00:32:34,000 --> 00:32:40,139
have seen her talk at well it fail we

800
00:32:36,820 --> 00:32:42,340
presented this at cccc last December and

801
00:32:40,139 --> 00:32:45,309
we talked about all the different things

802
00:32:42,340 --> 00:32:48,399
mainly breaking Bitcoin hardware wallets

803
00:32:45,309 --> 00:32:50,529
I promise if the word Bitcoin trig

804
00:32:48,399 --> 00:32:52,360
triggers you you can just think smart

805
00:32:50,529 --> 00:32:56,080
fridge we're not gonna get into the

806
00:32:52,360 --> 00:32:57,850
application so so don't don't worry

807
00:32:56,080 --> 00:32:59,830
about the word cryptocurrency Bitcoin

808
00:32:57,850 --> 00:33:03,219
you can just replace that in your head

809
00:32:59,830 --> 00:33:06,399
and all this still applies but yeah so

810
00:33:03,220 --> 00:33:09,370
we did this talk there was lots of

811
00:33:06,399 --> 00:33:12,520
previous work on this there was a one

812
00:33:09,370 --> 00:33:15,550
the papers had not yet been released

813
00:33:12,520 --> 00:33:16,690
believe it was how to apply at all the

814
00:33:15,550 --> 00:33:18,850
verifying code read out protection

815
00:33:16,690 --> 00:33:22,390
claims and so that's that's now public

816
00:33:18,850 --> 00:33:26,139
so you can go read that paper and yeah

817
00:33:22,390 --> 00:33:28,570
so let's now deep dive on the stm32 so

818
00:33:26,140 --> 00:33:32,460
the sem 32 F 205 is a general-purpose

819
00:33:28,570 --> 00:33:36,070
microcontroller it's an arm cortex-m 3 a

820
00:33:32,460 --> 00:33:38,140
very popular chip for there's a lots of

821
00:33:36,070 --> 00:33:40,090
oh it's a just general-purpose

822
00:33:38,140 --> 00:33:42,820
microcontroller can be used in all sorts

823
00:33:40,090 --> 00:33:44,860
of things it's also used as one of the

824
00:33:42,820 --> 00:33:48,280
main reference designs for a Bitcoin

825
00:33:44,860 --> 00:33:50,949
cryptocurrency wallet in this product

826
00:33:48,280 --> 00:33:54,550
called the treasurer so you know Thomas

827
00:33:50,950 --> 00:33:56,890
looked at 11 we saw the security 57

828
00:33:54,550 --> 00:33:58,720
times secure so we want to look at the

829
00:33:56,890 --> 00:34:02,440
data sheet for the stm32 and see how

830
00:33:58,720 --> 00:34:05,440
many times it mentions security not many

831
00:34:02,440 --> 00:34:07,360
times so I mean this is we got the nice

832
00:34:05,440 --> 00:34:09,668
frowny face trying to find the word

833
00:34:07,360 --> 00:34:11,290
security and that's because this is a

834
00:34:09,668 --> 00:34:15,489
general-purpose microcontroller it's not

835
00:34:11,290 --> 00:34:17,409
meant for the doesn't even mention

836
00:34:15,489 --> 00:34:18,939
security and the thing but it does have

837
00:34:17,409 --> 00:34:22,419
an interesting feature of readout

838
00:34:18,940 --> 00:34:25,030
protection and so in this family of

839
00:34:22,418 --> 00:34:27,940
microcontrollers this is the from the SD

840
00:34:25,030 --> 00:34:29,889
micros website there's different ones

841
00:34:27,940 --> 00:34:35,740
for different configurations and

842
00:34:29,889 --> 00:34:38,770
different cortexes m0 core m3 m4 and now

843
00:34:35,739 --> 00:34:41,229
basically there is a boot ROM or

844
00:34:38,770 --> 00:34:44,949
glitches clutch attacks for these

845
00:34:41,230 --> 00:34:48,219
susceptible chips to this family and and

846
00:34:44,949 --> 00:34:52,750
yeah so that's the crosses are starting

847
00:34:48,219 --> 00:34:55,089
to stack up and this one is yeah so and

848
00:34:52,750 --> 00:34:56,379
then yeah that for the four would also

849
00:34:55,090 --> 00:34:59,050
be an interesting one the seeks that's

850
00:34:56,379 --> 00:35:00,940
also when it's not yet done but that one

851
00:34:59,050 --> 00:35:03,820
has like a mega flash and is also very

852
00:35:00,940 --> 00:35:06,520
popular as well and the SD and micro

853
00:35:03,820 --> 00:35:07,900
family so we talked about previously we

854
00:35:06,520 --> 00:35:10,630
have to do some research we have to kind

855
00:35:07,900 --> 00:35:13,180
of figure out about the attack we want

856
00:35:10,630 --> 00:35:15,340
to do and if the firmware is pretty

857
00:35:13,180 --> 00:35:17,350
decent we may not be able to get an

858
00:35:15,340 --> 00:35:18,880
application level glitch so a few years

859
00:35:17,350 --> 00:35:20,920
ago I gave a talk at DEFCON tried to

860
00:35:18,880 --> 00:35:22,420
glitch the treasure application code was

861
00:35:20,920 --> 00:35:24,430
unsuccessful and

862
00:35:22,420 --> 00:35:27,549
so when we all teamed up we knew we had

863
00:35:24,430 --> 00:35:29,589
to move to the bootrom and so the

864
00:35:27,549 --> 00:35:32,470
bootrom the only really security feature

865
00:35:29,589 --> 00:35:34,869
the stm32 has is this readout protection

866
00:35:32,470 --> 00:35:36,129
and it's not in the main data sheet

867
00:35:34,869 --> 00:35:38,140
there's this app known you have to find

868
00:35:36,130 --> 00:35:40,510
but basically there's three levels of

869
00:35:38,140 --> 00:35:42,910
readout protection readout protection -

870
00:35:40,510 --> 00:35:45,130
so now I'm just going to say RDP - now

871
00:35:42,910 --> 00:35:48,279
we all know the acronym our ITP 2 is the

872
00:35:45,130 --> 00:35:50,829
as the highest the highest security

873
00:35:48,280 --> 00:35:53,140
which means you have no access our DP 0

874
00:35:50,829 --> 00:35:55,240
means full access so at least secure and

875
00:35:53,140 --> 00:35:58,569
our DP 1 is this kind of in-between

876
00:35:55,240 --> 00:36:01,029
state and what's interesting about this

877
00:35:58,569 --> 00:36:04,359
particular chip is how they implemented

878
00:36:01,030 --> 00:36:07,420
this so there's justice if al you we're

879
00:36:04,359 --> 00:36:12,880
looking for and it has to be a a for our

880
00:36:07,420 --> 00:36:17,140
DP 0 CC far - B - and it's not a or CC

881
00:36:12,880 --> 00:36:20,020
and you're an RDP 1 so that means if we

882
00:36:17,140 --> 00:36:23,129
can make that not be that value we can

883
00:36:20,020 --> 00:36:28,420
downgrade from our DB 2 to our DP 1 and

884
00:36:23,130 --> 00:36:30,069
so the way to do this is basically - so

885
00:36:28,420 --> 00:36:32,740
look at the bootloader suite so we were

886
00:36:30,069 --> 00:36:34,240
able to dump the boot ROM and one of the

887
00:36:32,740 --> 00:36:36,578
things we were interested so we have the

888
00:36:34,240 --> 00:36:40,240
hypothesis you know does already p only

889
00:36:36,579 --> 00:36:42,069
get read on the boot rom and so you know

890
00:36:40,240 --> 00:36:44,308
we looked through all the code did some

891
00:36:42,069 --> 00:36:47,410
reverse engineering of the boot ROM and

892
00:36:44,309 --> 00:36:51,760
which is readable we had to do some open

893
00:36:47,410 --> 00:36:55,029
OCD tricks but then we found essentially

894
00:36:51,760 --> 00:36:56,980
that the there was no checks found so as

895
00:36:55,030 --> 00:37:01,450
all these checks are only for our DP 0

896
00:36:56,980 --> 00:37:03,280
and so now let's take the methodology

897
00:37:01,450 --> 00:37:06,790
that we were showing before of how to do

898
00:37:03,280 --> 00:37:08,079
a glitch and kind of apply it post facto

899
00:37:06,790 --> 00:37:10,359
to what we did because when we

900
00:37:08,079 --> 00:37:12,849
originally did this it was a lot of

901
00:37:10,359 --> 00:37:14,799
floating around and it took three months

902
00:37:12,849 --> 00:37:16,420
of just coordinated effort the glitcher

903
00:37:14,799 --> 00:37:18,549
didn't run for three months but it

904
00:37:16,420 --> 00:37:21,040
that's a much much time of us redoing it

905
00:37:18,549 --> 00:37:24,509
but now post facto we can make it look

906
00:37:21,040 --> 00:37:27,130
easy apply the method and you win so

907
00:37:24,510 --> 00:37:29,170
like this happens in the boot ROM so

908
00:37:27,130 --> 00:37:31,569
we're interested in in analyzing the

909
00:37:29,170 --> 00:37:33,579
blue boot ROM for the boot ROM glitch so

910
00:37:31,569 --> 00:37:36,049
first thing that happens is the power on

911
00:37:33,579 --> 00:37:38,359
reset event after the power on

912
00:37:36,049 --> 00:37:39,650
said event the microcontroller is going

913
00:37:38,359 --> 00:37:41,179
to go into the boot ROM and that it's

914
00:37:39,650 --> 00:37:43,339
going to run the code that's in the boot

915
00:37:41,179 --> 00:37:45,199
rom so that boot rom could be doing

916
00:37:43,339 --> 00:37:48,288
different things depending on different

917
00:37:45,199 --> 00:37:49,880
pins but after the boot run is done and

918
00:37:48,289 --> 00:37:51,229
and specifically it's going to be

919
00:37:49,880 --> 00:37:53,299
reading RDP that's what we're interested

920
00:37:51,229 --> 00:37:57,259
in but then it's gonna launch user code

921
00:37:53,299 --> 00:37:58,880
and so we know that the boot rom it's

922
00:37:57,259 --> 00:38:01,459
going to read RDP from this internal

923
00:37:58,880 --> 00:38:06,439
flash so that's where we need to insert

924
00:38:01,459 --> 00:38:07,759
the glitch so this is super stool on

925
00:38:06,439 --> 00:38:10,129
that investigative phase we're still

926
00:38:07,759 --> 00:38:11,900
trying to learn about the target so what

927
00:38:10,130 --> 00:38:14,569
we now recommend is that you know before

928
00:38:11,900 --> 00:38:16,309
you move on to a new target you study

929
00:38:14,569 --> 00:38:18,619
the boot process with an oscilloscope

930
00:38:16,309 --> 00:38:20,150
and figure out some timing information

931
00:38:18,619 --> 00:38:22,309
because that's going to help you figure

932
00:38:20,150 --> 00:38:23,959
out your delay and your where to apply

933
00:38:22,309 --> 00:38:26,809
the picture so we're looking at the

934
00:38:23,959 --> 00:38:29,359
oscilloscope of the supply voltage on

935
00:38:26,809 --> 00:38:30,679
the top an i/o pin on the bottom and

936
00:38:29,359 --> 00:38:34,279
here we're just trying to measure the

937
00:38:30,679 --> 00:38:36,619
time to user code which is about 1.8

938
00:38:34,279 --> 00:38:40,099
milliseconds so that's how long it takes

939
00:38:36,619 --> 00:38:41,660
to get boot it into user code and then

940
00:38:40,099 --> 00:38:44,499
we can tell that because you know

941
00:38:41,660 --> 00:38:47,209
there's lots of interesting activity and

942
00:38:44,499 --> 00:38:49,549
yeah and so here then we also have the

943
00:38:47,209 --> 00:38:53,049
supply voltage and a reset pin and now

944
00:38:49,549 --> 00:38:55,400
we're trying to show that yep so what

945
00:38:53,049 --> 00:38:57,229
was so one of the most important things

946
00:38:55,400 --> 00:38:59,929
is the the problem we had with this chip

947
00:38:57,229 --> 00:39:02,089
is that they the pawn takes different

948
00:38:59,929 --> 00:39:04,339
amounts of time every every time you

949
00:39:02,089 --> 00:39:06,619
boot it and so basically the the PLL's

950
00:39:04,339 --> 00:39:09,049
and so on me to synchronize and some

951
00:39:06,619 --> 00:39:12,019
capacitors charge up or whatever but

952
00:39:09,049 --> 00:39:13,759
basically the first 1.4 milliseconds of

953
00:39:12,019 --> 00:39:15,258
the boot nothing happens and we couldn't

954
00:39:13,759 --> 00:39:18,079
get a reliable trigger because it was

955
00:39:15,259 --> 00:39:19,699
always moving every time that the

956
00:39:18,079 --> 00:39:20,989
execution speed was different but then

957
00:39:19,699 --> 00:39:22,400
we found out at one point four

958
00:39:20,989 --> 00:39:25,640
milliseconds roughly in the boot process

959
00:39:22,400 --> 00:39:27,469
the reception shoots high and we can use

960
00:39:25,640 --> 00:39:30,910
that as the perfect trigger of when the

961
00:39:27,469 --> 00:39:35,509
boot rom starts executing so all right

962
00:39:30,910 --> 00:39:37,368
Thank You Thomas and then and for the

963
00:39:35,509 --> 00:39:39,229
power consumption the technique is

964
00:39:37,369 --> 00:39:41,420
basically using a shot measurement so we

965
00:39:39,229 --> 00:39:44,299
have a shunt resistor to measure the

966
00:39:41,420 --> 00:39:47,090
power and we're in the boot ROM we were

967
00:39:44,299 --> 00:39:48,800
were interested in again

968
00:39:47,090 --> 00:39:50,120
you got the reset also looking at the

969
00:39:48,800 --> 00:39:52,400
power consumption with the shunt

970
00:39:50,120 --> 00:39:55,970
resistor and we see when the bootrom

971
00:39:52,400 --> 00:39:58,480
starts execution we're also in what

972
00:39:55,970 --> 00:40:02,240
we're trying to find is when these flash

973
00:39:58,480 --> 00:40:05,030
option bytes are going to be read and so

974
00:40:02,240 --> 00:40:08,089
when we look at that power trace we see

975
00:40:05,030 --> 00:40:09,710
a lot more activity once the flash

976
00:40:08,090 --> 00:40:12,410
starts get into a book and get getting

977
00:40:09,710 --> 00:40:14,150
involved and we can pair that up with

978
00:40:12,410 --> 00:40:16,310
our app application application in

979
00:40:14,150 --> 00:40:19,460
execution and now we have a nice map of

980
00:40:16,310 --> 00:40:21,710
where everything happens so this is what

981
00:40:19,460 --> 00:40:23,930
it this is how we started right through

982
00:40:21,710 --> 00:40:25,700
took the FPGA the analog switch now

983
00:40:23,930 --> 00:40:27,589
we've seen these a few times here we

984
00:40:25,700 --> 00:40:29,089
have a debugger that's a new component

985
00:40:27,590 --> 00:40:32,870
because now we're interested in reading

986
00:40:29,090 --> 00:40:34,670
when we have access to the when our DP

987
00:40:32,870 --> 00:40:37,690
one's downgraded and in this case our

988
00:40:34,670 --> 00:40:40,790
target is to tresor and this is

989
00:40:37,690 --> 00:40:43,100
inserting the glitch so we saw an

990
00:40:40,790 --> 00:40:48,560
example of that before and this is this

991
00:40:43,100 --> 00:40:50,600
was the glitch on the stm32 and we we

992
00:40:48,560 --> 00:40:52,310
did this over about three months of the

993
00:40:50,600 --> 00:40:53,630
active glitching different parts of the

994
00:40:52,310 --> 00:40:54,830
world all actively running this

995
00:40:53,630 --> 00:40:57,560
collision setup so it was very much a

996
00:40:54,830 --> 00:40:59,360
very much team effort eventually we were

997
00:40:57,560 --> 00:41:02,150
able to insert the glitch into the boot

998
00:40:59,360 --> 00:41:05,480
ROM and we were able to connect with a

999
00:41:02,150 --> 00:41:09,230
debugger and a dunk rated so we were now

1000
00:41:05,480 --> 00:41:11,530
even though we set our DP to and that

1001
00:41:09,230 --> 00:41:14,810
was set in the flash we are now at RDP 1

1002
00:41:11,530 --> 00:41:17,090
so the key to doing this and the key to

1003
00:41:14,810 --> 00:41:20,290
kind of making this cool to know the

1004
00:41:17,090 --> 00:41:23,030
parameters of the clutch and so so now

1005
00:41:20,290 --> 00:41:24,950
after working with traceur we're happy

1006
00:41:23,030 --> 00:41:27,320
to release these parameters and so these

1007
00:41:24,950 --> 00:41:30,580
numbers are essentially clock cycles at

1008
00:41:27,320 --> 00:41:34,370
a hundred megahertz so the delay is that

1009
00:41:30,580 --> 00:41:36,529
17900 clock cycles with a pulse of 50

1010
00:41:34,370 --> 00:41:40,490
clock cycles and yeah we're gonna put

1011
00:41:36,530 --> 00:41:41,780
this up on github and this again it we

1012
00:41:40,490 --> 00:41:43,600
were this particular device was the

1013
00:41:41,780 --> 00:41:47,900
treasurer but it's also applicable to

1014
00:41:43,600 --> 00:41:50,420
anything that runs in stm32 f2 and we

1015
00:41:47,900 --> 00:41:52,490
think it was pretty reliable so we did a

1016
00:41:50,420 --> 00:41:55,130
scatterplot of what our success looks

1017
00:41:52,490 --> 00:41:57,529
like and these were all the successful

1018
00:41:55,130 --> 00:42:00,880
collisions at exactly that delay so this

1019
00:41:57,530 --> 00:42:03,400
is about 120 attempts and all of them

1020
00:42:00,880 --> 00:42:05,080
hit pretty much at the same spot so this

1021
00:42:03,400 --> 00:42:10,810
is a pretty reliable glitch for the

1022
00:42:05,080 --> 00:42:13,060
stm32 f2 have a 2:05 and in this case

1023
00:42:10,810 --> 00:42:15,610
the application was this again a

1024
00:42:13,060 --> 00:42:17,680
cryptocurrency wallet so what do you do

1025
00:42:15,610 --> 00:42:19,930
with that glitch when you're in RDP one

1026
00:42:17,680 --> 00:42:21,279
well you can read SRAM is that

1027
00:42:19,930 --> 00:42:24,310
interesting depends on the application

1028
00:42:21,280 --> 00:42:27,190
it is interesting if you ever use SRAM

1029
00:42:24,310 --> 00:42:29,020
which seems to be popular on

1030
00:42:27,190 --> 00:42:31,480
microcontrollers so if you put secrets

1031
00:42:29,020 --> 00:42:34,030
in there you can read them out if those

1032
00:42:31,480 --> 00:42:36,280
secrets are a cryptocurrency seed that

1033
00:42:34,030 --> 00:42:37,680
basically equals money then so that's as

1034
00:42:36,280 --> 00:42:39,610
much as I'll get into cryptocurrency

1035
00:42:37,680 --> 00:42:41,319
Photowall at that fail if you're if

1036
00:42:39,610 --> 00:42:44,230
you're interested in more of the exploit

1037
00:42:41,320 --> 00:42:46,690
we originally made this butcher now it's

1038
00:42:44,230 --> 00:42:49,150
very specific for the stm32 so I have

1039
00:42:46,690 --> 00:42:51,610
some of these unpopulated PCBs with me

1040
00:42:49,150 --> 00:42:56,560
but this is very targeted with a socket

1041
00:42:51,610 --> 00:42:58,000
for the stm32 and basically for the

1042
00:42:56,560 --> 00:43:01,000
motivation of that we wanted to kind of

1043
00:42:58,000 --> 00:43:02,890
generalize this and that's what we hope

1044
00:43:01,000 --> 00:43:05,500
to show with that methodology and the

1045
00:43:02,890 --> 00:43:07,839
how to adapt it to other part lines and

1046
00:43:05,500 --> 00:43:10,600
so you know we're talking about

1047
00:43:07,840 --> 00:43:12,640
basically attacking here and glitching

1048
00:43:10,600 --> 00:43:15,220
and so you know what what can we do

1049
00:43:12,640 --> 00:43:17,319
about it so one thing you could do is

1050
00:43:15,220 --> 00:43:19,660
during the design component time is just

1051
00:43:17,320 --> 00:43:21,460
choose a component that has glitch

1052
00:43:19,660 --> 00:43:23,980
monitors so you know if you're searching

1053
00:43:21,460 --> 00:43:25,540
for a part and it doesn't mention

1054
00:43:23,980 --> 00:43:28,570
security or doesn't mention

1055
00:43:25,540 --> 00:43:30,400
voltage protection you know and if

1056
00:43:28,570 --> 00:43:31,840
that's important to your design you may

1057
00:43:30,400 --> 00:43:33,730
want to look for something else the

1058
00:43:31,840 --> 00:43:36,190
brownout detector is not necessarily

1059
00:43:33,730 --> 00:43:38,650
glitch defense so parent detector is

1060
00:43:36,190 --> 00:43:41,320
generally there for power monitoring not

1061
00:43:38,650 --> 00:43:42,970
necessarily for coaching so that you

1062
00:43:41,320 --> 00:43:45,100
know most likely it's not going to see

1063
00:43:42,970 --> 00:43:46,569
you other thing you consider is active

1064
00:43:45,100 --> 00:43:49,180
tamper basically don't let someone

1065
00:43:46,570 --> 00:43:49,870
physically get access to your design out

1066
00:43:49,180 --> 00:43:52,240
to the chip

1067
00:43:49,870 --> 00:43:54,759
depending on the situation this may or

1068
00:43:52,240 --> 00:43:56,470
may not be applicable but if they can't

1069
00:43:54,760 --> 00:43:58,450
get access to the chip it's going to be

1070
00:43:56,470 --> 00:44:01,810
hard to insert the glitch right next to

1071
00:43:58,450 --> 00:44:04,029
the park if you're building the product

1072
00:44:01,810 --> 00:44:06,910
you should test your design so hopefully

1073
00:44:04,030 --> 00:44:09,340
we now we all know that it can be done

1074
00:44:06,910 --> 00:44:11,710
very cheaply cheap amount of components

1075
00:44:09,340 --> 00:44:13,780
you know we recommend that you test your

1076
00:44:11,710 --> 00:44:14,230
design for glitching before you release

1077
00:44:13,780 --> 00:44:15,640
it

1078
00:44:14,230 --> 00:44:18,840
and lastly there are some tricks the

1079
00:44:15,640 --> 00:44:21,040
right glitch resistant software they but

1080
00:44:18,840 --> 00:44:23,710
none of that helps if the software is

1081
00:44:21,040 --> 00:44:26,950
burned into the boot rom so not much you

1082
00:44:23,710 --> 00:44:30,970
can do there and then we'll let Thomas

1083
00:44:26,950 --> 00:44:32,290
yeah so just as a conclusion chips with

1084
00:44:30,970 --> 00:44:34,330
your pet wait for really glitch able

1085
00:44:32,290 --> 00:44:37,590
there are some more chips that we looked

1086
00:44:34,330 --> 00:44:41,410
at such as the 80s MD 21 and so on and

1087
00:44:37,590 --> 00:44:43,660
they they all are very trivial to glitch

1088
00:44:41,410 --> 00:44:45,460
basically and it can be done really on

1089
00:44:43,660 --> 00:44:48,009
the cheap and on the very very cheap as

1090
00:44:45,460 --> 00:44:49,570
you've seen before and but also just

1091
00:44:48,010 --> 00:44:51,880
because the chip is literal that's not

1092
00:44:49,570 --> 00:44:54,130
equal and exploit you still need to be

1093
00:44:51,880 --> 00:44:56,710
able to get your glitter stable enough

1094
00:44:54,130 --> 00:44:59,110
so just because your chip is susceptible

1095
00:44:56,710 --> 00:45:01,180
to VHS does not necessarily mean it's

1096
00:44:59,110 --> 00:45:03,520
trivial to exploit it just means that

1097
00:45:01,180 --> 00:45:05,980
there's a high risk of somebody maybe

1098
00:45:03,520 --> 00:45:08,020
being able to get a stable glitch and

1099
00:45:05,980 --> 00:45:09,940
they you should really have a deep look

1100
00:45:08,020 --> 00:45:13,650
at your design and see why your

1101
00:45:09,940 --> 00:45:17,200
protection strategies for that chip

1102
00:45:13,650 --> 00:45:18,940
releases on chip not fail will release

1103
00:45:17,200 --> 00:45:20,710
the firmware or will the bitstream and

1104
00:45:18,940 --> 00:45:23,650
very lock for the chip fail glitter

1105
00:45:20,710 --> 00:45:25,810
glitter in this case oops I will release

1106
00:45:23,650 --> 00:45:28,570
all the PCBs we talked about so for the

1107
00:45:25,810 --> 00:45:31,360
max for the RT glitter for the trésor

1108
00:45:28,570 --> 00:45:33,160
and all the target tests for where we

1109
00:45:31,360 --> 00:45:35,530
also will release some tools for Diedre

1110
00:45:33,160 --> 00:45:39,819
to make Goodrem reverse engineering much

1111
00:45:35,530 --> 00:45:42,670
easier yeah so thank you we hope to get

1112
00:45:39,820 --> 00:45:44,860
our website life either today or later

1113
00:45:42,670 --> 00:45:45,370
this week you can reach us on crypto

1114
00:45:44,860 --> 00:45:48,880
Tronics

1115
00:45:45,370 --> 00:45:52,370
dot-com and levity thank you very much

1116
00:45:48,880 --> 00:45:55,800
and yeah thank you

1117
00:45:52,370 --> 00:45:55,799
[Applause]

