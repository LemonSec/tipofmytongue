1
00:00:01,130 --> 00:00:14,690
[Music]

2
00:00:14,719 --> 00:00:17,600
hello welcome to this session

3
00:00:17,600 --> 00:00:19,279
in the next 40 minutes we will be

4
00:00:19,279 --> 00:00:21,920
talking about malware and how we we

5
00:00:21,920 --> 00:00:24,160
evaded the behavioral detection of

6
00:00:24,160 --> 00:00:26,560
state-of-the-art anti-virus and endpoint

7
00:00:26,560 --> 00:00:28,800
detection and response solutions with

8
00:00:28,800 --> 00:00:31,519
this new flavor of distributed malware

9
00:00:31,519 --> 00:00:34,480
rope for rope driven execution

10
00:00:34,480 --> 00:00:36,960
the theme behind this research uh me you

11
00:00:36,960 --> 00:00:38,800
might remember me from the last two

12
00:00:38,800 --> 00:00:41,280
editions of blackhead europe where i've

13
00:00:41,280 --> 00:00:42,800
been talking about

14
00:00:42,800 --> 00:00:45,520
malwa revations with first blue pill

15
00:00:45,520 --> 00:00:47,600
this framework for disarming malware

16
00:00:47,600 --> 00:00:50,719
revisions and last year is that with new

17
00:00:50,719 --> 00:00:52,640
microarchitectural primitives for

18
00:00:52,640 --> 00:00:54,480
hypervisor detection

19
00:00:54,480 --> 00:00:56,559
and this is a joint work with lorenz

20
00:00:56,559 --> 00:00:59,680
nvidia lorenzo holds a master degree in

21
00:00:59,680 --> 00:01:01,760
cyber security from my institutions

22
00:01:01,760 --> 00:01:04,559
against university of rome and is really

23
00:01:04,559 --> 00:01:06,880
passionate about windows internals and

24
00:01:06,880 --> 00:01:09,600
reverse engineering research so together

25
00:01:09,600 --> 00:01:11,840
we have been working on the problem of

26
00:01:11,840 --> 00:01:13,040
how

27
00:01:13,040 --> 00:01:17,360
av and edr solutions they flag

28
00:01:17,360 --> 00:01:19,600
untrusted software as malicious using

29
00:01:19,600 --> 00:01:23,119
behavioral analysis so when you have a

30
00:01:23,119 --> 00:01:25,520
an untrusted piece of software what you

31
00:01:25,520 --> 00:01:28,479
can do with an av or adr solution you

32
00:01:28,479 --> 00:01:29,439
can

33
00:01:29,439 --> 00:01:30,880
scan its code

34
00:01:30,880 --> 00:01:33,680
and try to match it against known

35
00:01:33,680 --> 00:01:36,400
signatures for known threats but when

36
00:01:36,400 --> 00:01:38,720
you're facing a new threat what you can

37
00:01:38,720 --> 00:01:41,200
do is you can attempt behavioral

38
00:01:41,200 --> 00:01:42,720
analysis so

39
00:01:42,720 --> 00:01:45,439
it's what is behavioral really

40
00:01:45,439 --> 00:01:48,079
behavioral is a type of analysis that is

41
00:01:48,079 --> 00:01:51,200
dynamic so it will monitor the execution

42
00:01:51,200 --> 00:01:53,759
units in your system for actions

43
00:01:53,759 --> 00:01:56,640
involving registry manipulation file

44
00:01:56,640 --> 00:01:59,119
system network and so on

45
00:01:59,119 --> 00:02:01,759
and you will try to see if the actions

46
00:02:01,759 --> 00:02:03,920
are of a process

47
00:02:03,920 --> 00:02:06,000
they will match some

48
00:02:06,000 --> 00:02:07,840
some known patterns some let's say

49
00:02:07,840 --> 00:02:10,239
dynamic execution signatures that are

50
00:02:10,239 --> 00:02:12,400
typical of malicious behaviors the

51
00:02:12,400 --> 00:02:14,640
moment that you you match such a

52
00:02:14,640 --> 00:02:17,360
sequence the av or edr will raise an

53
00:02:17,360 --> 00:02:19,680
alert and we'll ask the user typically

54
00:02:19,680 --> 00:02:21,200
what to do and

55
00:02:21,200 --> 00:02:23,120
will possibly

56
00:02:23,120 --> 00:02:24,239
halt

57
00:02:24,239 --> 00:02:26,959
to a grind a new threat so what are the

58
00:02:26,959 --> 00:02:28,720
limits of current approaches to

59
00:02:28,720 --> 00:02:31,120
behavioral analysis then and this is

60
00:02:31,120 --> 00:02:33,680
what we asked ourselves when we started

61
00:02:33,680 --> 00:02:36,160
this research so in this talk i will

62
00:02:36,160 --> 00:02:37,440
cover

63
00:02:37,440 --> 00:02:40,000
state of the art what we did to improve

64
00:02:40,000 --> 00:02:40,720
it

65
00:02:40,720 --> 00:02:43,519
uh we'll present this concept rob detail

66
00:02:43,519 --> 00:02:45,200
its implementation

67
00:02:45,200 --> 00:02:47,680
and two new bypasses which might be of

68
00:02:47,680 --> 00:02:50,160
independent interest to get around the

69
00:02:50,160 --> 00:02:53,680
mitigations of windows 10 for

70
00:02:53,680 --> 00:02:55,440
the windows defender exploit guard

71
00:02:55,440 --> 00:02:57,760
component we will be presenting their

72
00:02:57,760 --> 00:03:00,400
experimental results discuss them and

73
00:03:00,400 --> 00:03:03,200
talk about what our directions for

74
00:03:03,200 --> 00:03:05,280
further research in this area and what

75
00:03:05,280 --> 00:03:07,680
to what we can do to defend ourselves

76
00:03:07,680 --> 00:03:09,760
from these threats

77
00:03:09,760 --> 00:03:11,680
first a few more words on behavioral

78
00:03:11,680 --> 00:03:13,200
analysis um

79
00:03:13,200 --> 00:03:14,959
so you you have this

80
00:03:14,959 --> 00:03:17,200
infamous untrusted piece of software and

81
00:03:17,200 --> 00:03:19,599
what you do is you you start executing

82
00:03:19,599 --> 00:03:22,640
it on a typical in a very tight leash so

83
00:03:22,640 --> 00:03:25,440
you are uh shepherding every interaction

84
00:03:25,440 --> 00:03:27,280
with the operating system looking for

85
00:03:27,280 --> 00:03:28,959
something suspicious

86
00:03:28,959 --> 00:03:30,560
but then at some point you have to let

87
00:03:30,560 --> 00:03:32,239
this process go otherwise you're

88
00:03:32,239 --> 00:03:35,440
introducing uh expensive slow down so

89
00:03:35,440 --> 00:03:38,000
you may be breaking the functionality so

90
00:03:38,000 --> 00:03:39,920
this application will

91
00:03:39,920 --> 00:03:42,319
now run pretty much unleashed after the

92
00:03:42,319 --> 00:03:44,799
initial stage except that you keep an

93
00:03:44,799 --> 00:03:47,519
eye on it you will be still monitoring

94
00:03:47,519 --> 00:03:49,440
relevant actions

95
00:03:49,440 --> 00:03:51,840
and to this end you will be using user

96
00:03:51,840 --> 00:03:54,000
space hooks mini filters and other

97
00:03:54,000 --> 00:03:55,360
standard means

98
00:03:55,360 --> 00:03:57,120
and typically you do this for one

99
00:03:57,120 --> 00:03:58,799
process so

100
00:03:58,799 --> 00:04:01,439
at a time so the granularity uh for

101
00:04:01,439 --> 00:04:03,680
looking at events is the actions of a

102
00:04:03,680 --> 00:04:05,120
single process

103
00:04:05,120 --> 00:04:07,680
or sometimes you can extend this to to

104
00:04:07,680 --> 00:04:10,000
its children but in general that's

105
00:04:10,000 --> 00:04:12,080
that's the high level picture

106
00:04:12,080 --> 00:04:13,840
and

107
00:04:13,840 --> 00:04:16,720
have tried to to get around a

108
00:04:16,720 --> 00:04:20,238
heuristic detection of the behavior by

109
00:04:20,238 --> 00:04:22,320
by using this idea of distributed

110
00:04:22,320 --> 00:04:25,280
malware so to present the the the

111
00:04:25,280 --> 00:04:27,520
concept of distributed malware a nice

112
00:04:27,520 --> 00:04:29,600
work recent work

113
00:04:29,600 --> 00:04:30,800
in the area

114
00:04:30,800 --> 00:04:33,280
use the use the title of this novel the

115
00:04:33,280 --> 00:04:37,440
naked sun where robots according to

116
00:04:37,440 --> 00:04:39,520
to the first law

117
00:04:39,520 --> 00:04:41,520
in the novel they cannot harm humans

118
00:04:41,520 --> 00:04:42,720
they cannot

119
00:04:42,720 --> 00:04:45,600
carry a task that will deliberately harm

120
00:04:45,600 --> 00:04:46,639
a human

121
00:04:46,639 --> 00:04:49,600
however what happens is that each robot

122
00:04:49,600 --> 00:04:52,400
in the end turns out to to to make an

123
00:04:52,400 --> 00:04:54,080
action that

124
00:04:54,080 --> 00:04:56,560
on its own doesn't harm a human but if

125
00:04:56,560 --> 00:04:58,160
you take the outcome of all the

126
00:04:58,160 --> 00:05:00,720
aggregated actions then something bad

127
00:05:00,720 --> 00:05:02,800
occurs and this is what you can do with

128
00:05:02,800 --> 00:05:05,280
distributed malware you take a payload

129
00:05:05,280 --> 00:05:08,080
you can dilute the temporal and special

130
00:05:08,080 --> 00:05:10,000
footprint of the actions of this payload

131
00:05:10,000 --> 00:05:12,080
to multiple cooperating entities

132
00:05:12,080 --> 00:05:14,639
processes for instance and the trick is

133
00:05:14,639 --> 00:05:17,199
that no single entity alerts the av or

134
00:05:17,199 --> 00:05:19,600
adr so you manage to stay below the

135
00:05:19,600 --> 00:05:21,600
deduction threshold with each unit and

136
00:05:21,600 --> 00:05:23,039
you're

137
00:05:23,039 --> 00:05:23,600
fine fine

138
00:05:23,600 --> 00:05:25,440
to speak because in the end those

139
00:05:25,440 --> 00:05:27,840
solutions the current implementations

140
00:05:27,840 --> 00:05:28,800
they

141
00:05:28,800 --> 00:05:31,520
they're still an easy prey of av and edr

142
00:05:31,520 --> 00:05:32,960
solutions because they have some

143
00:05:32,960 --> 00:05:34,880
conspicuous traits

144
00:05:34,880 --> 00:05:37,280
there are currently two main approaches

145
00:05:37,280 --> 00:05:40,000
to distributed malware the first is to

146
00:05:40,000 --> 00:05:43,440
use a set of processes that you create

147
00:05:43,440 --> 00:05:45,360
on the spot a doc

148
00:05:45,360 --> 00:05:48,000
and you can even make this process

149
00:05:48,000 --> 00:05:49,199
resemble

150
00:05:49,199 --> 00:05:51,840
normal applications like mimicry attacks

151
00:05:51,840 --> 00:05:54,240
but to stay undetected

152
00:05:54,240 --> 00:05:55,840
in the presence of state-of-the-art

153
00:05:55,840 --> 00:05:58,160
solutions you need a very high number of

154
00:05:58,160 --> 00:06:01,360
processes and also to avoid correlation

155
00:06:01,360 --> 00:06:02,960
you should make

156
00:06:02,960 --> 00:06:04,960
should make sure that each process is

157
00:06:04,960 --> 00:06:07,039
seen as independent of the other but if

158
00:06:07,039 --> 00:06:07,919
you are

159
00:06:07,919 --> 00:06:10,560
all creating them at once that's that's

160
00:06:10,560 --> 00:06:13,600
a bit difficult to do

161
00:06:13,600 --> 00:06:16,240
i believe that a more promising avenue

162
00:06:16,240 --> 00:06:18,639
is the one explored by other researchers

163
00:06:18,639 --> 00:06:22,160
that abuse existing processes by taking

164
00:06:22,160 --> 00:06:24,240
a payload chopping this payload in

165
00:06:24,240 --> 00:06:26,960
pieces and spreading the pieces

166
00:06:26,960 --> 00:06:29,600
of this of this malware along along with

167
00:06:29,600 --> 00:06:32,160
an emulator inside victim processes and

168
00:06:32,160 --> 00:06:33,919
these processes are already running on

169
00:06:33,919 --> 00:06:36,319
the machine typically processes that

170
00:06:36,319 --> 00:06:38,960
have lots of activity so you are

171
00:06:38,960 --> 00:06:41,039
literally interleaving malicious

172
00:06:41,039 --> 00:06:42,960
activities in a long long trace of

173
00:06:42,960 --> 00:06:44,720
benign activities

174
00:06:44,720 --> 00:06:47,280
problems here are that injecting code is

175
00:06:47,280 --> 00:06:49,599
noisy you are introducing or modifying

176
00:06:49,599 --> 00:06:51,360
executable memory

177
00:06:51,360 --> 00:06:53,599
and your you have bought the the

178
00:06:53,599 --> 00:06:55,680
components of the payload and you have

179
00:06:55,680 --> 00:06:57,759
this emulator that coordinates the

180
00:06:57,759 --> 00:06:59,280
execution

181
00:06:59,280 --> 00:07:01,199
and you're also introducing quite a

182
00:07:01,199 --> 00:07:03,360
number of memory regions because you are

183
00:07:03,360 --> 00:07:06,240
you are retrofitting a normal executable

184
00:07:06,240 --> 00:07:08,639
which uses many regions so does the

185
00:07:08,639 --> 00:07:10,800
emulator so you're introducing lots of

186
00:07:10,800 --> 00:07:11,919
artifacts

187
00:07:11,919 --> 00:07:13,680
in the address space

188
00:07:13,680 --> 00:07:15,919
and plus there is also another problem

189
00:07:15,919 --> 00:07:17,759
now

190
00:07:17,759 --> 00:07:18,960
it's

191
00:07:18,960 --> 00:07:21,360
the problem is the availability of

192
00:07:21,360 --> 00:07:23,360
hardening mitigations in operating

193
00:07:23,360 --> 00:07:26,080
systems to reduce the stock surface of

194
00:07:26,080 --> 00:07:28,560
applications against next generation

195
00:07:28,560 --> 00:07:31,360
malware and exploits so

196
00:07:31,360 --> 00:07:33,120
there are in the windows defender

197
00:07:33,120 --> 00:07:35,039
exploit card uh

198
00:07:35,039 --> 00:07:36,319
wdag

199
00:07:36,319 --> 00:07:38,560
system there are a number of mitigations

200
00:07:38,560 --> 00:07:41,440
that are obtained for applications like

201
00:07:41,440 --> 00:07:44,400
arbitrary code guard which prevents the

202
00:07:44,400 --> 00:07:46,800
allocation or modification of executable

203
00:07:46,800 --> 00:07:49,919
memory you have code integrity guard

204
00:07:49,919 --> 00:07:52,560
that essentially allows you to load only

205
00:07:52,560 --> 00:07:55,120
signed modules and con modules

206
00:07:55,120 --> 00:07:57,599
and you have mitigations like export and

207
00:07:57,599 --> 00:08:00,639
import address filtering that break the

208
00:08:00,639 --> 00:08:03,360
usual lookup sequences that injected

209
00:08:03,360 --> 00:08:07,199
payloads used to locate apis so this is

210
00:08:07,199 --> 00:08:09,599
becoming more difficult for

211
00:08:09,599 --> 00:08:13,039
for distributed malware and

212
00:08:13,039 --> 00:08:16,800
in the end to to realize a successful

213
00:08:16,800 --> 00:08:19,199
distributed instance of malware

214
00:08:19,199 --> 00:08:21,759
you might want to have a design that

215
00:08:21,759 --> 00:08:24,160
supports a flexible delivery of payload

216
00:08:24,160 --> 00:08:26,160
that can work with different injection

217
00:08:26,160 --> 00:08:28,800
primitives with very

218
00:08:28,800 --> 00:08:31,199
limited constraints on the capabilities

219
00:08:31,199 --> 00:08:33,440
of the primitive and at the same time

220
00:08:33,440 --> 00:08:34,958
you want to have

221
00:08:34,958 --> 00:08:36,880
a very small footprint for the

222
00:08:36,880 --> 00:08:39,279
distributed runtime emulator or any

223
00:08:39,279 --> 00:08:42,080
other component that you need to assist

224
00:08:42,080 --> 00:08:44,080
this distributed execution in the

225
00:08:44,080 --> 00:08:45,920
coordination otherwise you would you can

226
00:08:45,920 --> 00:08:48,560
just fingerprint the emulator

227
00:08:48,560 --> 00:08:50,959
also you may want to comply with arduino

228
00:08:50,959 --> 00:08:53,120
mitigations because this those can gain

229
00:08:53,120 --> 00:08:55,440
popularity in the next years at the same

230
00:08:55,440 --> 00:08:56,320
time

231
00:08:56,320 --> 00:08:58,640
uh once you succeed in this you might

232
00:08:58,640 --> 00:09:00,959
also want to keep the code and that of

233
00:09:00,959 --> 00:09:03,839
your distributed payload hidden as much

234
00:09:03,839 --> 00:09:06,880
as possible to avoid uh the possibility

235
00:09:06,880 --> 00:09:10,480
of dynamic signatures for it

236
00:09:10,480 --> 00:09:11,839
on its code

237
00:09:11,839 --> 00:09:14,959
so what we can do well we asked this

238
00:09:14,959 --> 00:09:18,000
this question to ourselves and we we

239
00:09:18,000 --> 00:09:20,880
tried to revisit the architecture of an

240
00:09:20,880 --> 00:09:22,560
injection-based distributed malware

241
00:09:22,560 --> 00:09:23,600
concept

242
00:09:23,600 --> 00:09:24,800
and

243
00:09:24,800 --> 00:09:28,080
we we have another component that is in

244
00:09:28,080 --> 00:09:30,399
charge of injecting a number of victim

245
00:09:30,399 --> 00:09:31,839
processes

246
00:09:31,839 --> 00:09:33,600
and will inject those victims with a

247
00:09:33,600 --> 00:09:35,920
bootstrap component this bootstrap

248
00:09:35,920 --> 00:09:38,000
component will set up to distributed

249
00:09:38,000 --> 00:09:40,880
execution where we have a payload that

250
00:09:40,880 --> 00:09:42,880
is arranged in chunks

251
00:09:42,880 --> 00:09:44,800
and each chunk

252
00:09:44,800 --> 00:09:47,279
can be executed by victims but the key

253
00:09:47,279 --> 00:09:50,240
is that each chunk is expressed using

254
00:09:50,240 --> 00:09:52,480
code that is already in the victim so we

255
00:09:52,480 --> 00:09:54,640
are not introducing any code

256
00:09:54,640 --> 00:09:57,920
and to assist the execution with hosting

257
00:09:57,920 --> 00:09:59,279
this payload

258
00:09:59,279 --> 00:10:02,640
hosting the memory so global memory hip

259
00:10:02,640 --> 00:10:04,880
memory and all the

260
00:10:04,880 --> 00:10:07,040
mental data that you need for execution

261
00:10:07,040 --> 00:10:10,079
coordination we use a single

262
00:10:10,079 --> 00:10:13,360
a single medium we have one

263
00:10:13,360 --> 00:10:15,760
medium and one memory region to host

264
00:10:15,760 --> 00:10:18,640
everything at once and for this we use a

265
00:10:18,640 --> 00:10:21,040
non-inspectable cover channel in more

266
00:10:21,040 --> 00:10:23,920
detail the the two main ingredients of

267
00:10:23,920 --> 00:10:26,000
our architecture are return reader

268
00:10:26,000 --> 00:10:27,120
programming

269
00:10:27,120 --> 00:10:29,839
and transactional tfs with this

270
00:10:29,839 --> 00:10:32,160
combination we realize a distributed

271
00:10:32,160 --> 00:10:34,320
drop driven execution

272
00:10:34,320 --> 00:10:36,399
that we call drop

273
00:10:36,399 --> 00:10:38,079
in more detail return oriented

274
00:10:38,079 --> 00:10:40,000
programming well if you don't know

275
00:10:40,000 --> 00:10:41,760
return rated programming it's a

276
00:10:41,760 --> 00:10:44,480
well-known exploitation technique that

277
00:10:44,480 --> 00:10:45,760
has

278
00:10:45,760 --> 00:10:48,480
reassembles code fragments that are in

279
00:10:48,480 --> 00:10:50,480
the address space of an application to

280
00:10:50,480 --> 00:10:53,040
carry out the desired semantics for an

281
00:10:53,040 --> 00:10:55,680
attacker but you can do a lot more than

282
00:10:55,680 --> 00:10:59,040
exploitation so in our case we use rob

283
00:10:59,040 --> 00:11:02,000
to encode the distributed payload using

284
00:11:02,000 --> 00:11:05,040
rob gadgets that are in some code module

285
00:11:05,040 --> 00:11:06,880
that all the victims have

286
00:11:06,880 --> 00:11:08,000
loaded

287
00:11:08,000 --> 00:11:10,480
and by doing so we avoid the need of

288
00:11:10,480 --> 00:11:12,959
having writable and executable memory

289
00:11:12,959 --> 00:11:15,440
the same time we will use prop also to

290
00:11:15,440 --> 00:11:17,839
get around some of the mitigations of

291
00:11:17,839 --> 00:11:19,920
wdag

292
00:11:19,920 --> 00:11:21,920
the other ingredients is transactional

293
00:11:21,920 --> 00:11:25,040
tfs so this is an abstraction available

294
00:11:25,040 --> 00:11:27,760
in windows that allows you to perform

295
00:11:27,760 --> 00:11:29,680
transient changes to

296
00:11:29,680 --> 00:11:32,160
to the contents of a file on the file

297
00:11:32,160 --> 00:11:34,399
system and

298
00:11:34,399 --> 00:11:37,279
unless you commit these changes only

299
00:11:37,279 --> 00:11:40,800
processes that have a handle to an mtfs

300
00:11:40,800 --> 00:11:43,680
transaction can see those modifications

301
00:11:43,680 --> 00:11:46,640
that you made not even an anti-virus can

302
00:11:46,640 --> 00:11:49,040
so with this we obtain an unexpectable

303
00:11:49,040 --> 00:11:51,440
cover channel and in this cover channel

304
00:11:51,440 --> 00:11:52,639
we will

305
00:11:52,639 --> 00:11:54,320
place the payload and we will also

306
00:11:54,320 --> 00:11:56,399
orchestrate the communications between

307
00:11:56,399 --> 00:11:58,639
the entities and this is this is

308
00:11:58,639 --> 00:12:01,360
possible also because we drop the code

309
00:12:01,360 --> 00:12:03,760
that we need to write it's just data so

310
00:12:03,760 --> 00:12:06,720
we have one big region inside this

311
00:12:06,720 --> 00:12:08,800
txf file

312
00:12:08,800 --> 00:12:11,680
and uh now let's let's analyze each

313
00:12:11,680 --> 00:12:14,240
component of the architecture in detail

314
00:12:14,240 --> 00:12:16,480
we have the loader the loader is

315
00:12:16,480 --> 00:12:19,120
responsible first of all for selecting

316
00:12:19,120 --> 00:12:21,839
suitable victim processes so you may

317
00:12:21,839 --> 00:12:24,800
want to start for instance for

318
00:12:24,800 --> 00:12:27,200
picking processes that are active on the

319
00:12:27,200 --> 00:12:29,440
network if you need to exchange

320
00:12:29,440 --> 00:12:32,959
information when over the network um

321
00:12:32,959 --> 00:12:34,800
applications that have hyphal system

322
00:12:34,800 --> 00:12:36,880
activities so you might follow some

323
00:12:36,880 --> 00:12:40,160
criteria then what you do is you

324
00:12:40,160 --> 00:12:41,440
prepare

325
00:12:41,440 --> 00:12:43,680
an ntfs transaction so you take some

326
00:12:43,680 --> 00:12:46,160
file or you create one you create a

327
00:12:46,160 --> 00:12:48,480
transaction on it we will call this file

328
00:12:48,480 --> 00:12:50,399
the ropd xf

329
00:12:50,399 --> 00:12:53,120
then you can just empty the any content

330
00:12:53,120 --> 00:12:54,720
that is in there and you will place

331
00:12:54,720 --> 00:12:58,160
there the rope chains and the metadata

332
00:12:58,160 --> 00:12:59,600
and then what you do is you will

333
00:12:59,600 --> 00:13:02,079
duplicate a handle to the transaction

334
00:13:02,079 --> 00:13:04,560
for each victim process so the victim

335
00:13:04,560 --> 00:13:08,320
can look into the this transient content

336
00:13:08,320 --> 00:13:10,880
and then in the end once you once you've

337
00:13:10,880 --> 00:13:13,120
achieved all this step you will inject a

338
00:13:13,120 --> 00:13:15,440
component in the victim along with a

339
00:13:15,440 --> 00:13:18,000
copy of this transacted handle the

340
00:13:18,000 --> 00:13:20,639
specific per victim copy

341
00:13:20,639 --> 00:13:22,240
the bootstrap component that you're

342
00:13:22,240 --> 00:13:24,160
injecting is in charge of making the

343
00:13:24,160 --> 00:13:26,720
victim load the transacted file the rob

344
00:13:26,720 --> 00:13:28,800
txf and

345
00:13:28,800 --> 00:13:31,760
the victim will fetch the contents

346
00:13:31,760 --> 00:13:33,760
that are needed from the file to

347
00:13:33,760 --> 00:13:37,200
schedule the execution of rob code and

348
00:13:37,200 --> 00:13:39,199
will arrange coordination with other

349
00:13:39,199 --> 00:13:41,839
victims when this is necessary

350
00:13:41,839 --> 00:13:44,079
and also the the bootstrap component

351
00:13:44,079 --> 00:13:45,760
will help

352
00:13:45,760 --> 00:13:46,720
in the

353
00:13:46,720 --> 00:13:49,680
covert resolution of the apis that are

354
00:13:49,680 --> 00:13:51,360
needed for the functioning of the

355
00:13:51,360 --> 00:13:53,519
malware

356
00:13:53,519 --> 00:13:56,320
a few more words on the transacted file

357
00:13:56,320 --> 00:13:59,360
so we are arranging the payload as a

358
00:13:59,360 --> 00:14:02,000
sequence of chunk and each chunk can be

359
00:14:02,000 --> 00:14:04,480
executed independently so each victim

360
00:14:04,480 --> 00:14:06,560
will execute one or more chunks over

361
00:14:06,560 --> 00:14:08,959
time and

362
00:14:08,959 --> 00:14:12,399
chunks are placed in the interrupt xf

363
00:14:12,399 --> 00:14:15,600
alongside their memory so program memory

364
00:14:15,600 --> 00:14:18,399
will be part of the transacted file uh

365
00:14:18,399 --> 00:14:21,360
global's hip everything will be in there

366
00:14:21,360 --> 00:14:24,079
in there along with metadata for the

367
00:14:24,079 --> 00:14:26,240
rope run time so

368
00:14:26,240 --> 00:14:28,560
the addresses of the apis that we have

369
00:14:28,560 --> 00:14:32,000
located in a covert manner but also

370
00:14:32,000 --> 00:14:34,880
handles that you need for instance when

371
00:14:34,880 --> 00:14:36,639
processes they have to work on the same

372
00:14:36,639 --> 00:14:39,760
objects each each process will need to

373
00:14:39,760 --> 00:14:41,760
work on its own handle think of a

374
00:14:41,760 --> 00:14:44,880
circuit or a file so you we have we have

375
00:14:44,880 --> 00:14:47,040
provisions for that too

376
00:14:47,040 --> 00:14:49,920
and we support two execution modes one

377
00:14:49,920 --> 00:14:52,399
we call it continuous and by that we

378
00:14:52,399 --> 00:14:55,040
mean that really any victim can execute

379
00:14:55,040 --> 00:14:57,680
any chunk we just need to preserve the

380
00:14:57,680 --> 00:15:00,480
order and the mutual exclusion so that

381
00:15:00,480 --> 00:15:03,040
every victim mexic sorry

382
00:15:03,040 --> 00:15:06,079
every chunk gets executed by exactly one

383
00:15:06,079 --> 00:15:08,959
victim and so we we provide coordination

384
00:15:08,959 --> 00:15:12,320
we drop and we have a staged mode where

385
00:15:12,320 --> 00:15:14,959
uh we can have that sequences of chunks

386
00:15:14,959 --> 00:15:17,920
uh are to be run by specific victims so

387
00:15:17,920 --> 00:15:20,880
if you have for instance uh some the

388
00:15:20,880 --> 00:15:22,160
loading phase

389
00:15:22,160 --> 00:15:22,959
uh

390
00:15:22,959 --> 00:15:25,040
dedicated chunks for the loading stuff

391
00:15:25,040 --> 00:15:27,680
for sending stuff to the internet those

392
00:15:27,680 --> 00:15:30,240
might better be run by network active

393
00:15:30,240 --> 00:15:31,519
process

394
00:15:31,519 --> 00:15:34,160
and in these cases you might also have

395
00:15:34,160 --> 00:15:37,759
that coordination might be dedicated to

396
00:15:37,759 --> 00:15:40,240
to the payload or can still be provided

397
00:15:40,240 --> 00:15:42,800
by rob

398
00:15:43,040 --> 00:15:45,600
with this design we are getting a number

399
00:15:45,600 --> 00:15:47,519
of advantages we we don't need to

400
00:15:47,519 --> 00:15:50,399
allocate or modify executable memory

401
00:15:50,399 --> 00:15:51,120
we

402
00:15:51,120 --> 00:15:54,000
we use one just one shared medium for

403
00:15:54,000 --> 00:15:56,399
code and data no many regions like

404
00:15:56,399 --> 00:15:59,279
before we comply by design with acg and

405
00:15:59,279 --> 00:16:00,639
cig

406
00:16:00,639 --> 00:16:02,560
and also we are making in-memory

407
00:16:02,560 --> 00:16:05,759
inspection harder for av and edrs

408
00:16:05,759 --> 00:16:07,440
because in the end if they

409
00:16:07,440 --> 00:16:09,759
try to look at what we are

410
00:16:09,759 --> 00:16:11,839
what we have injected in those victims

411
00:16:11,839 --> 00:16:13,519
they will find a bunch of gadgets

412
00:16:13,519 --> 00:16:15,519
addresses and data they will not find

413
00:16:15,519 --> 00:16:18,240
code because rope adds one level of

414
00:16:18,240 --> 00:16:20,160
indirection to

415
00:16:20,160 --> 00:16:22,160
due to the execution so you need drop

416
00:16:22,160 --> 00:16:24,240
aware analysis to look for actual

417
00:16:24,240 --> 00:16:25,680
instructions

418
00:16:25,680 --> 00:16:28,480
but now i have to convince you that

419
00:16:28,480 --> 00:16:30,720
this actually works and how we made it

420
00:16:30,720 --> 00:16:32,880
work so there are a number of challenges

421
00:16:32,880 --> 00:16:35,519
that we should be discussing and we will

422
00:16:35,519 --> 00:16:37,360
start with the injection of the

423
00:16:37,360 --> 00:16:39,680
bootstrap component because i i promise

424
00:16:39,680 --> 00:16:41,440
that there will be no

425
00:16:41,440 --> 00:16:44,079
writable and executable memory but also

426
00:16:44,079 --> 00:16:47,279
we have to talk about a gadget source so

427
00:16:47,279 --> 00:16:48,800
actually we

428
00:16:48,800 --> 00:16:51,040
we thought of a way of addressing the

429
00:16:51,040 --> 00:16:53,519
first two challenges at once

430
00:16:53,519 --> 00:16:56,480
and uh in doing so we

431
00:16:56,480 --> 00:16:58,480
in the whole implementation actually we

432
00:16:58,480 --> 00:17:01,120
had to come up with two novel bypasses

433
00:17:01,120 --> 00:17:04,240
for the mitigations of wdag so i will be

434
00:17:04,240 --> 00:17:06,079
covering this

435
00:17:06,079 --> 00:17:08,799
now let's start with the first bypass

436
00:17:08,799 --> 00:17:11,199
but the the problem that we have to face

437
00:17:11,199 --> 00:17:13,280
is that we need to deliver this

438
00:17:13,280 --> 00:17:15,599
bootstrap component to victims

439
00:17:15,599 --> 00:17:19,679
and at the same time we we need to to

440
00:17:19,679 --> 00:17:22,240
make sure that all victims

441
00:17:22,240 --> 00:17:24,480
they share a gadget source that is good

442
00:17:24,480 --> 00:17:26,799
enough for supporting the execution of

443
00:17:26,799 --> 00:17:28,160
our payload

444
00:17:28,160 --> 00:17:28,960
so

445
00:17:28,960 --> 00:17:29,760
um

446
00:17:29,760 --> 00:17:32,240
this has to to meet the following

447
00:17:32,240 --> 00:17:33,520
constraints

448
00:17:33,520 --> 00:17:34,960
we can only use

449
00:17:34,960 --> 00:17:37,600
signed code modules no writable and

450
00:17:37,600 --> 00:17:40,400
executable memory and most importantly

451
00:17:40,400 --> 00:17:43,760
we should not spook an av or edr with

452
00:17:43,760 --> 00:17:45,679
conspicuous actions

453
00:17:45,679 --> 00:17:48,240
what we can do well at first we thought

454
00:17:48,240 --> 00:17:51,120
of phantom dll hollowing which up to

455
00:17:51,120 --> 00:17:53,760
last year was

456
00:17:53,760 --> 00:17:56,320
the only documented injection that could

457
00:17:56,320 --> 00:17:58,720
get around call integrity guard

458
00:17:58,720 --> 00:18:01,440
and the idea of phantom dll lollowing is

459
00:18:01,440 --> 00:18:03,600
to take a windows dll

460
00:18:03,600 --> 00:18:06,880
create a a transaction on it and then

461
00:18:06,880 --> 00:18:09,280
you can change the contents of this dll

462
00:18:09,280 --> 00:18:11,520
as you once you want so you can place

463
00:18:11,520 --> 00:18:13,840
stuff in there for instance the

464
00:18:13,840 --> 00:18:16,320
bootstrap component then you write those

465
00:18:16,320 --> 00:18:19,520
changes in a transaction and you create

466
00:18:19,520 --> 00:18:23,679
a section object so um you use uh

467
00:18:23,679 --> 00:18:26,000
windows primitives for creating a

468
00:18:26,000 --> 00:18:27,919
section and then you can force the

469
00:18:27,919 --> 00:18:30,080
victim processors to map

470
00:18:30,080 --> 00:18:32,080
this section in their memory so you're

471
00:18:32,080 --> 00:18:34,320
forcing the victims to load them

472
00:18:34,320 --> 00:18:36,880
problem is uh now

473
00:18:36,880 --> 00:18:38,480
all the state-of-the-art solutions

474
00:18:38,480 --> 00:18:40,799
pretty much stay they're monitoring this

475
00:18:40,799 --> 00:18:42,720
kind of behavior

476
00:18:42,720 --> 00:18:45,840
we also thought that we could be instead

477
00:18:45,840 --> 00:18:49,120
uh creating the dissection

478
00:18:49,120 --> 00:18:50,880
directly from the victim because if the

479
00:18:50,880 --> 00:18:52,799
victim does that maybe it's it's not

480
00:18:52,799 --> 00:18:54,240
that suspicious

481
00:18:54,240 --> 00:18:58,160
problem is it uh with the recent updates

482
00:18:58,160 --> 00:19:01,679
of from the end of last year to wdag if

483
00:19:01,679 --> 00:19:04,400
you try to do anti-create section from

484
00:19:04,400 --> 00:19:05,120
uh

485
00:19:05,120 --> 00:19:07,440
a process that is cig enabled you will

486
00:19:07,440 --> 00:19:10,240
get this error so you will get invalid

487
00:19:10,240 --> 00:19:11,520
image

488
00:19:11,520 --> 00:19:15,360
and what to do then well

489
00:19:15,360 --> 00:19:18,080
we we our bypass works like that we

490
00:19:18,080 --> 00:19:18,960
still

491
00:19:18,960 --> 00:19:21,600
create a transacted file on a windows

492
00:19:21,600 --> 00:19:23,039
dll

493
00:19:23,039 --> 00:19:25,280
we change the contents

494
00:19:25,280 --> 00:19:28,559
for placing extra stuff in there and we

495
00:19:28,559 --> 00:19:30,160
create a section

496
00:19:30,160 --> 00:19:33,120
then what we do is we duplicate a handle

497
00:19:33,120 --> 00:19:34,400
to the section

498
00:19:34,400 --> 00:19:36,320
for our victims

499
00:19:36,320 --> 00:19:38,880
and we inject a rock chain

500
00:19:38,880 --> 00:19:40,640
in the victim

501
00:19:40,640 --> 00:19:43,360
so that the victim will map

502
00:19:43,360 --> 00:19:46,240
this section with their own handle

503
00:19:46,240 --> 00:19:49,440
and also we are resuming the own

504
00:19:49,440 --> 00:19:52,240
activities of the victim so it will be a

505
00:19:52,240 --> 00:19:54,480
one-off thing we will quickly interrupt

506
00:19:54,480 --> 00:19:56,559
the execution and

507
00:19:56,559 --> 00:19:57,360
uh

508
00:19:57,360 --> 00:20:00,559
map our transacted dll and resume the

509
00:20:00,559 --> 00:20:02,960
normal activities in more detail we use

510
00:20:02,960 --> 00:20:05,919
a very simple drop chain in total it's

511
00:20:05,919 --> 00:20:09,520
uh five gadgets of one instruction each

512
00:20:09,520 --> 00:20:12,480
that uh we'll set up the arguments for

513
00:20:12,480 --> 00:20:14,799
empty map view section so we'll call in

514
00:20:14,799 --> 00:20:16,640
the map view section from within the

515
00:20:16,640 --> 00:20:18,480
apple with the victim

516
00:20:18,480 --> 00:20:21,840
on the handle and we'll um

517
00:20:21,840 --> 00:20:25,200
we'll parse the output so the

518
00:20:25,200 --> 00:20:28,559
the address where this module is loaded

519
00:20:28,559 --> 00:20:31,039
and we'll combine this with the offset

520
00:20:31,039 --> 00:20:32,720
of the code that we want to run inside

521
00:20:32,720 --> 00:20:35,440
the module and what happens actually is

522
00:20:35,440 --> 00:20:38,159
that the chain also contains a context

523
00:20:38,159 --> 00:20:41,120
object with the cpu registers

524
00:20:41,120 --> 00:20:43,679
that that the victim uh yeah that they

525
00:20:43,679 --> 00:20:46,080
were a part of the

526
00:20:46,080 --> 00:20:48,320
of the own activities of the victim when

527
00:20:48,320 --> 00:20:51,600
when we interrupted it and so we will

528
00:20:51,600 --> 00:20:54,080
run the decide code and upon return from

529
00:20:54,080 --> 00:20:56,320
this code drop chain will take over

530
00:20:56,320 --> 00:20:58,640
column t continue and restore this

531
00:20:58,640 --> 00:21:00,240
context

532
00:21:00,240 --> 00:21:02,080
with this technique we just obtain

533
00:21:02,080 --> 00:21:04,720
multiple advantages at once

534
00:21:04,720 --> 00:21:07,120
first of all we can add all the gadgets

535
00:21:07,120 --> 00:21:10,400
that we want to dll so if we don't have

536
00:21:10,400 --> 00:21:12,720
enough gadgets or we want gadgets that

537
00:21:12,720 --> 00:21:15,360
are easier to work with we have that

538
00:21:15,360 --> 00:21:17,440
we can place the bootstrap component

539
00:21:17,440 --> 00:21:19,679
inside the dll

540
00:21:19,679 --> 00:21:22,000
so we can use a rope chain or we can

541
00:21:22,000 --> 00:21:24,240
even write this as a shell code if we

542
00:21:24,240 --> 00:21:25,360
want

543
00:21:25,360 --> 00:21:29,120
and uh we will have that uh the victim

544
00:21:29,120 --> 00:21:30,799
will be loading

545
00:21:30,799 --> 00:21:32,720
this this dll

546
00:21:32,720 --> 00:21:35,600
so all the victims can load the same dll

547
00:21:35,600 --> 00:21:38,159
and actually the victim will spawn the

548
00:21:38,159 --> 00:21:40,480
execution of the payload that we want

549
00:21:40,480 --> 00:21:42,799
there will be no remote thread no remote

550
00:21:42,799 --> 00:21:45,280
apc we will just have that in the

551
00:21:45,280 --> 00:21:47,919
implementation we use the an initial

552
00:21:47,919 --> 00:21:50,320
sequence that creates a thread so a

553
00:21:50,320 --> 00:21:53,120
normal internal thread and we'll

554
00:21:53,120 --> 00:21:55,360
return to the drop chain immediately and

555
00:21:55,360 --> 00:21:57,600
with empty continue the execution we

556
00:21:57,600 --> 00:22:00,559
resume with that said this is just an

557
00:22:00,559 --> 00:22:02,640
implementation shortcut

558
00:22:02,640 --> 00:22:05,600
you take any other injection primitive

559
00:22:05,600 --> 00:22:07,840
drop should work fine with this we just

560
00:22:07,840 --> 00:22:09,919
gained a lot of time in the

561
00:22:09,919 --> 00:22:10,840
in the

562
00:22:10,840 --> 00:22:14,159
implementation um and we complied with

563
00:22:14,159 --> 00:22:16,960
the we met the first few challenges now

564
00:22:16,960 --> 00:22:18,720
we also have to comply with drop

565
00:22:18,720 --> 00:22:21,760
mitigations because wdag is offering

566
00:22:21,760 --> 00:22:24,480
also mitigations for rope you have stuck

567
00:22:24,480 --> 00:22:27,039
pivot which checks the

568
00:22:27,039 --> 00:22:29,919
the range of the stack pointer when you

569
00:22:29,919 --> 00:22:32,480
invoke a sensitive api so what we do is

570
00:22:32,480 --> 00:22:34,799
we make api calls from the native stock

571
00:22:34,799 --> 00:22:36,559
with which stacks

572
00:22:36,559 --> 00:22:39,120
and then there's color check and cmx

573
00:22:39,120 --> 00:22:40,559
which validate

574
00:22:40,559 --> 00:22:42,640
the call site and the return site of

575
00:22:42,640 --> 00:22:44,799
apis here we didn't really invent

576
00:22:44,799 --> 00:22:46,880
anything new there are gadgets that

577
00:22:46,880 --> 00:22:49,200
break those analysis there's right of

578
00:22:49,200 --> 00:22:52,000
passage or in case you use a shell code

579
00:22:52,000 --> 00:22:53,840
for the bootstrap component you can

580
00:22:53,840 --> 00:22:55,919
issue calls from there and this will be

581
00:22:55,919 --> 00:22:59,039
fine for for those mitigations

582
00:22:59,039 --> 00:23:01,760
uh we observe that the flow in the w

583
00:23:01,760 --> 00:23:04,400
group mitigations is that while they

584
00:23:04,400 --> 00:23:05,280
they

585
00:23:05,280 --> 00:23:07,679
they shepherd antigrade section or

586
00:23:07,679 --> 00:23:10,640
create file mapping those api state they

587
00:23:10,640 --> 00:23:14,159
just ignore and team up field section so

588
00:23:14,159 --> 00:23:17,440
the in our injection hour bypass for acg

589
00:23:17,440 --> 00:23:20,159
and cig will be and will go unnoticed

590
00:23:20,159 --> 00:23:24,400
also by drop mitigations of windows

591
00:23:24,400 --> 00:23:26,320
fourth challenge we have to deal with

592
00:23:26,320 --> 00:23:30,000
drop encoding so we have a malware and

593
00:23:30,000 --> 00:23:32,080
we really don't want to write

594
00:23:32,080 --> 00:23:34,159
drop code for this malware because it

595
00:23:34,159 --> 00:23:36,480
won't scale i mean writing rope code can

596
00:23:36,480 --> 00:23:37,440
be fun

597
00:23:37,440 --> 00:23:38,240
but

598
00:23:38,240 --> 00:23:39,360
if you

599
00:23:39,360 --> 00:23:42,640
it's it's demanding and existing tools

600
00:23:42,640 --> 00:23:46,720
they're meant for exploitation mostly um

601
00:23:46,720 --> 00:23:48,140
they don't bring a

602
00:23:48,140 --> 00:23:49,360
[Music]

603
00:23:49,360 --> 00:23:52,799
full expressivity for writing programs

604
00:23:52,799 --> 00:23:55,600
um we wanted some automation so

605
00:23:55,600 --> 00:23:58,320
we obtained some in the end

606
00:23:58,320 --> 00:24:00,080
we borrowed some ideas from prior

607
00:24:00,080 --> 00:24:02,400
research such as drop injector which was

608
00:24:02,400 --> 00:24:05,120
presented at plaquet a few years ago

609
00:24:05,120 --> 00:24:08,080
and we used uh the standard visual

610
00:24:08,080 --> 00:24:09,760
studio compiler with specific

611
00:24:09,760 --> 00:24:12,240
compilation settings to simplify the

612
00:24:12,240 --> 00:24:14,880
structure of the code then what we did

613
00:24:14,880 --> 00:24:16,960
is since we don't want to to mess with

614
00:24:16,960 --> 00:24:19,039
the stock because we have the chain

615
00:24:19,039 --> 00:24:20,400
on there

616
00:24:20,400 --> 00:24:23,120
we are removing all stack variables and

617
00:24:23,120 --> 00:24:25,360
we are promoting them to global

618
00:24:25,360 --> 00:24:26,480
variables

619
00:24:26,480 --> 00:24:28,799
actually all the global variables will

620
00:24:28,799 --> 00:24:30,799
be part of a single

621
00:24:30,799 --> 00:24:33,039
big data structure they will be just

622
00:24:33,039 --> 00:24:35,440
fields and this works fine as long as

623
00:24:35,440 --> 00:24:38,320
you don't have recursion this works fine

624
00:24:38,320 --> 00:24:41,679
the reason is that then when we need to

625
00:24:41,679 --> 00:24:42,880
to look up

626
00:24:42,880 --> 00:24:44,880
this information in memory or in the

627
00:24:44,880 --> 00:24:47,279
file we can just do relative

628
00:24:47,279 --> 00:24:49,679
displacement we just need to to take the

629
00:24:49,679 --> 00:24:52,400
address of this data structure and

630
00:24:52,400 --> 00:24:54,799
compute displacements for our access so

631
00:24:54,799 --> 00:24:56,080
that's handy

632
00:24:56,080 --> 00:24:58,720
we obtain an output that is like a shell

633
00:24:58,720 --> 00:25:00,799
code simple shellcode

634
00:25:00,799 --> 00:25:03,039
and we we

635
00:25:03,039 --> 00:25:05,520
look up basic blocks in there each basic

636
00:25:05,520 --> 00:25:08,080
block will become a chunk and we will

637
00:25:08,080 --> 00:25:10,080
look up gadgets that are suitable for

638
00:25:10,080 --> 00:25:12,159
destruction in every basic block we will

639
00:25:12,159 --> 00:25:14,559
build some sorts of

640
00:25:14,559 --> 00:25:17,120
chain skeleton that is almost complete

641
00:25:17,120 --> 00:25:19,600
and we will complete it by hand

642
00:25:19,600 --> 00:25:22,320
for future work we are thinking of using

643
00:25:22,320 --> 00:25:25,279
the raindrop obfuscator that recently

644
00:25:25,279 --> 00:25:26,960
became available

645
00:25:26,960 --> 00:25:29,039
which supports fully automated drop

646
00:25:29,039 --> 00:25:31,360
binary of writing so

647
00:25:31,360 --> 00:25:33,600
there are some extensions to do

648
00:25:33,600 --> 00:25:35,600
like to to comply with the rock

649
00:25:35,600 --> 00:25:37,360
mitigations of windows or even to

650
00:25:37,360 --> 00:25:39,120
support windows binaries because it's

651
00:25:39,120 --> 00:25:42,240
for linux but it's very promising and we

652
00:25:42,240 --> 00:25:45,760
will like to to do that for the future

653
00:25:45,760 --> 00:25:48,640
and finally one more challenge to to

654
00:25:48,640 --> 00:25:52,480
deal with is the lookup of apis

655
00:25:52,480 --> 00:25:54,799
in victim processes that are hardened

656
00:25:54,799 --> 00:25:56,559
against those lookups

657
00:25:56,559 --> 00:26:00,159
and so here it comes our new bypass

658
00:26:00,159 --> 00:26:03,360
but looking at ppis is needed both in

659
00:26:03,360 --> 00:26:05,279
the bootstrap component

660
00:26:05,279 --> 00:26:06,240
and

661
00:26:06,240 --> 00:26:08,480
of course in the chunks so the malware

662
00:26:08,480 --> 00:26:10,799
my also decide to

663
00:26:10,799 --> 00:26:11,840
to

664
00:26:11,840 --> 00:26:13,760
use uh

665
00:26:13,760 --> 00:26:16,000
yeah all sorts of apis and you need

666
00:26:16,000 --> 00:26:18,640
flexibility in this sense

667
00:26:18,640 --> 00:26:20,559
if you use get procedure address then

668
00:26:20,559 --> 00:26:23,279
you're alerting an av or adr so it's not

669
00:26:23,279 --> 00:26:24,799
an option

670
00:26:24,799 --> 00:26:28,320
you can say okay i will be importing or

671
00:26:28,320 --> 00:26:30,799
solving all the apis from the loader

672
00:26:30,799 --> 00:26:33,360
component but this will be suspicious

673
00:26:33,360 --> 00:26:35,279
and you will give away lots of

674
00:26:35,279 --> 00:26:37,120
information

675
00:26:37,120 --> 00:26:39,760
and normally what you do is you know you

676
00:26:39,760 --> 00:26:42,400
you deploy you deploy your own get pro

677
00:26:42,400 --> 00:26:44,559
coders sequence but there are double

678
00:26:44,559 --> 00:26:46,880
deck defense of start prep that break

679
00:26:46,880 --> 00:26:49,679
those codes and there's export address

680
00:26:49,679 --> 00:26:53,360
filtering and import address filtering

681
00:26:53,360 --> 00:26:56,240
those mitigations they they work in very

682
00:26:56,240 --> 00:26:59,120
similar manner they monitor accesses

683
00:26:59,120 --> 00:27:01,120
that you make to the expert or import

684
00:27:01,120 --> 00:27:03,679
address table of rpe module that is

685
00:27:03,679 --> 00:27:06,240
loaded in memory they do that by using a

686
00:27:06,240 --> 00:27:08,240
guard page so at the moment that an

687
00:27:08,240 --> 00:27:10,159
instruction access

688
00:27:10,159 --> 00:27:13,039
uh this region you you will you will

689
00:27:13,039 --> 00:27:15,279
have an exception the handler will kick

690
00:27:15,279 --> 00:27:18,320
in and we will allow the access if this

691
00:27:18,320 --> 00:27:19,679
instructions

692
00:27:19,679 --> 00:27:22,799
is coming from a legit module

693
00:27:22,799 --> 00:27:24,399
legit module

694
00:27:24,399 --> 00:27:26,799
well this wouldn't be a black cat talk

695
00:27:26,799 --> 00:27:29,919
without a meme so legit module

696
00:27:29,919 --> 00:27:32,320
this is where the shoe pinches

697
00:27:32,320 --> 00:27:34,640
because what you can do is you can take

698
00:27:34,640 --> 00:27:37,679
any legit windows dll which is already

699
00:27:37,679 --> 00:27:41,360
in memory and you find a gadget in there

700
00:27:41,360 --> 00:27:43,760
that can make an arbitrary read

701
00:27:43,760 --> 00:27:46,000
so you need a gadget that just can read

702
00:27:46,000 --> 00:27:48,799
from an arbitrary address and what you

703
00:27:48,799 --> 00:27:50,880
do every time you have to access a

704
00:27:50,880 --> 00:27:53,520
guarded region so for instance the

705
00:27:53,520 --> 00:27:55,600
export address table you you use the

706
00:27:55,600 --> 00:27:57,919
gadget for the referencing that memory

707
00:27:57,919 --> 00:27:59,679
because the moment you do

708
00:27:59,679 --> 00:28:01,600
for the guard page handler

709
00:28:01,600 --> 00:28:04,480
it will see oh it's from camera 32 so

710
00:28:04,480 --> 00:28:05,919
that's fine

711
00:28:05,919 --> 00:28:08,080
and so you have your bypass

712
00:28:08,080 --> 00:28:10,320
you might also use job for that we did

713
00:28:10,320 --> 00:28:12,559
that jump rinded programming we also

714
00:28:12,559 --> 00:28:14,559
used that for

715
00:28:14,559 --> 00:28:16,559
another proof of concept for

716
00:28:16,559 --> 00:28:19,679
import address stable hijacking uh very

717
00:28:19,679 --> 00:28:22,000
quickly so if you have your code that

718
00:28:22,000 --> 00:28:23,919
for instance is looking up to the list

719
00:28:23,919 --> 00:28:26,720
of names what you can do is you can drop

720
00:28:26,720 --> 00:28:30,240
the access to the sensitive part

721
00:28:30,240 --> 00:28:33,200
here in this c code by by using this

722
00:28:33,200 --> 00:28:35,200
this procedure which is really simple

723
00:28:35,200 --> 00:28:37,520
you you prepare the address for where

724
00:28:37,520 --> 00:28:39,200
you want to read you call the gadget and

725
00:28:39,200 --> 00:28:43,039
you read the result it's simple as that

726
00:28:43,039 --> 00:28:45,279
so now we have ticked all the boxes for

727
00:28:45,279 --> 00:28:49,039
the challenges let's evaluate a rope on

728
00:28:49,039 --> 00:28:51,039
state-of-the-art solutions to see if it

729
00:28:51,039 --> 00:28:54,200
works and we consider 10 products six

730
00:28:54,200 --> 00:28:57,200
antiviruses and four ddrs

731
00:28:57,200 --> 00:28:59,360
we consider all the available

732
00:28:59,360 --> 00:29:01,840
mitigations that are obtained on wdag

733
00:29:01,840 --> 00:29:04,480
plus the system defaults

734
00:29:04,480 --> 00:29:06,960
we target victim applications running

735
00:29:06,960 --> 00:29:08,880
with medium integrity level

736
00:29:08,880 --> 00:29:11,679
and we inject them with payloads that

737
00:29:11,679 --> 00:29:15,120
would alert an ev or edr if you run them

738
00:29:15,120 --> 00:29:17,679
standalone but in rob

739
00:29:17,679 --> 00:29:20,159
they should be protected and we will see

740
00:29:20,159 --> 00:29:22,159
if it's the case and we also make a

741
00:29:22,159 --> 00:29:24,799
comparison with the time which is the

742
00:29:24,799 --> 00:29:27,279
state of the art in uh distributed

743
00:29:27,279 --> 00:29:30,559
malware based on injection techniques

744
00:29:30,559 --> 00:29:33,679
in more details uh wwe mitigations they

745
00:29:33,679 --> 00:29:35,200
have um

746
00:29:35,200 --> 00:29:36,880
yeah there are some

747
00:29:36,880 --> 00:29:38,240
implementation flaws or

748
00:29:38,240 --> 00:29:40,720
incompatibilities we run them in audit

749
00:29:40,720 --> 00:29:43,279
mode and we consider different

750
00:29:43,279 --> 00:29:45,360
combinations for when a mitigation

751
00:29:45,360 --> 00:29:47,760
cannot be used with another but in

752
00:29:47,760 --> 00:29:50,720
general our concept is sorry our rope

753
00:29:50,720 --> 00:29:52,080
concept is

754
00:29:52,080 --> 00:29:55,279
meant to deceive the high level idea so

755
00:29:55,279 --> 00:29:56,799
we wanted to see even a perfect

756
00:29:56,799 --> 00:29:59,440
implementation of this counter measure

757
00:29:59,440 --> 00:30:01,600
and uh

758
00:30:01,600 --> 00:30:04,880
we want to do that using uh the smallest

759
00:30:04,880 --> 00:30:07,039
number of victims as possible to really

760
00:30:07,039 --> 00:30:09,440
stress the approach so with with two

761
00:30:09,440 --> 00:30:12,159
victims we are really pushing the

762
00:30:12,159 --> 00:30:14,559
boundaries of distributed

763
00:30:14,559 --> 00:30:16,640
uh instead of taking many processes for

764
00:30:16,640 --> 00:30:19,919
diluting this payload and in particular

765
00:30:19,919 --> 00:30:22,640
with us two payloads one for the

766
00:30:22,640 --> 00:30:25,440
continuous execution mode and in this

767
00:30:25,440 --> 00:30:28,000
case we are either modifying the windows

768
00:30:28,000 --> 00:30:30,480
registry to achieve persistence or we

769
00:30:30,480 --> 00:30:32,720
play with the boot sequence of windows

770
00:30:32,720 --> 00:30:34,880
and in the other case we do the stage

771
00:30:34,880 --> 00:30:36,399
mode where we have a download and

772
00:30:36,399 --> 00:30:39,360
execute sequence so one victim like

773
00:30:39,360 --> 00:30:41,120
browser we download the powershell

774
00:30:41,120 --> 00:30:43,360
script and another victim will execute

775
00:30:43,360 --> 00:30:44,799
the script

776
00:30:44,799 --> 00:30:46,960
and what are we going to get surprise

777
00:30:46,960 --> 00:30:50,720
surprise well we received

778
00:30:50,720 --> 00:30:53,279
the products 8 out of 10

779
00:30:53,279 --> 00:30:55,600
without triggering any mitigations of

780
00:30:55,600 --> 00:30:57,120
wdag

781
00:30:57,120 --> 00:30:59,360
for the two products that

782
00:30:59,360 --> 00:31:02,240
are no were not completely deceived we

783
00:31:02,240 --> 00:31:04,720
noticed that um

784
00:31:04,720 --> 00:31:07,440
they blocked our attempt to do open

785
00:31:07,440 --> 00:31:09,760
process even though the our process was

786
00:31:09,760 --> 00:31:11,760
entitled had the right

787
00:31:11,760 --> 00:31:15,279
rights and we also noticed that the

788
00:31:15,279 --> 00:31:18,640
these anti-viruses were giving fake

789
00:31:18,640 --> 00:31:21,519
outputs to duplicate handles so this is

790
00:31:21,519 --> 00:31:23,440
this is not nothing new really for

791
00:31:23,440 --> 00:31:27,360
people that do av reverse engineering so

792
00:31:27,360 --> 00:31:28,480
and it's

793
00:31:28,480 --> 00:31:31,120
you can work around these problems with

794
00:31:31,120 --> 00:31:33,600
other off-the-shelf techniques but the

795
00:31:33,600 --> 00:31:35,840
important messages here is also that

796
00:31:35,840 --> 00:31:37,679
state-of-the-art approaches like the

797
00:31:37,679 --> 00:31:40,880
time they are detected by in this case

798
00:31:40,880 --> 00:31:43,360
by seven products

799
00:31:43,360 --> 00:31:45,760
what we learned uh from our experiments

800
00:31:45,760 --> 00:31:47,120
is uh

801
00:31:47,120 --> 00:31:49,760
while uh that evading user mode api

802
00:31:49,760 --> 00:31:52,080
hooks is not really necessary was

803
00:31:52,080 --> 00:31:54,399
necessary only for one product was

804
00:31:54,399 --> 00:31:57,120
blocking the injection stage

805
00:31:57,120 --> 00:32:01,279
but uh we were able to deceive using the

806
00:32:01,279 --> 00:32:03,919
the windows and windows 64 apis we

807
00:32:03,919 --> 00:32:06,320
didn't even try the direct system calls

808
00:32:06,320 --> 00:32:08,000
for the record

809
00:32:08,000 --> 00:32:10,640
and uh only the injection stage is

810
00:32:10,640 --> 00:32:12,960
fragile because it's not distributed for

811
00:32:12,960 --> 00:32:15,279
the distributed payload we didn't evade

812
00:32:15,279 --> 00:32:16,960
the api hooks

813
00:32:16,960 --> 00:32:20,159
we also learned that

814
00:32:20,640 --> 00:32:23,360
these mitigations like export address

815
00:32:23,360 --> 00:32:25,440
filtering or import address filtering

816
00:32:25,440 --> 00:32:27,200
they're promising they can break many

817
00:32:27,200 --> 00:32:29,679
many injection patterns when they start

818
00:32:29,679 --> 00:32:32,799
to the payloads look up uh apis but they

819
00:32:32,799 --> 00:32:35,279
can be deceived so we believe

820
00:32:35,279 --> 00:32:37,200
there is more work needed there and more

821
00:32:37,200 --> 00:32:40,159
importantly we think that rob it's

822
00:32:40,159 --> 00:32:42,720
apparently delivered the blind side hit

823
00:32:42,720 --> 00:32:45,679
to these products and if you want to

824
00:32:45,679 --> 00:32:49,279
mitigate rope by uh fixing individual

825
00:32:49,279 --> 00:32:52,159
aspects like i will block rope or i will

826
00:32:52,159 --> 00:32:53,120
block

827
00:32:53,120 --> 00:32:55,679
transacted files or

828
00:32:55,679 --> 00:32:58,880
i will disallow the trade creation you

829
00:32:58,880 --> 00:33:02,000
can try other means so other code reuse

830
00:33:02,000 --> 00:33:04,399
flavors other covered mediums or instead

831
00:33:04,399 --> 00:33:06,240
of creating an internal trade you can

832
00:33:06,240 --> 00:33:08,080
schedule an apc

833
00:33:08,080 --> 00:33:10,159
there are more opportunities this can be

834
00:33:10,159 --> 00:33:12,399
interesting also for fireless research

835
00:33:12,399 --> 00:33:13,360
so

836
00:33:13,360 --> 00:33:14,240
uh

837
00:33:14,240 --> 00:33:16,080
we believe that

838
00:33:16,080 --> 00:33:18,159
it's it's necessary for distributed

839
00:33:18,159 --> 00:33:21,600
malware to have defenses that see the

840
00:33:21,600 --> 00:33:23,200
threat as a whole

841
00:33:23,200 --> 00:33:25,200
and not just try to mitigate the

842
00:33:25,200 --> 00:33:27,200
individual symptoms

843
00:33:27,200 --> 00:33:30,399
to this end we believe that behavioral

844
00:33:30,399 --> 00:33:32,720
analysis should strive to correlate

845
00:33:32,720 --> 00:33:34,640
execution units

846
00:33:34,640 --> 00:33:37,200
this is easier easier say than none

847
00:33:37,200 --> 00:33:40,480
because in the end if you try to analyze

848
00:33:40,480 --> 00:33:42,559
many processes as a whole

849
00:33:42,559 --> 00:33:44,799
well you face scalability issues you

850
00:33:44,799 --> 00:33:45,919
might

851
00:33:45,919 --> 00:33:48,000
you might face a lot of information that

852
00:33:48,000 --> 00:33:49,600
you have to process

853
00:33:49,600 --> 00:33:53,039
and to correlate and also to do

854
00:33:53,039 --> 00:33:55,519
to understand when processes are related

855
00:33:55,519 --> 00:33:57,919
to each other you should keep track of

856
00:33:57,919 --> 00:33:59,519
all the injection techniques that keep

857
00:33:59,519 --> 00:34:02,320
appearing so what we can what we suggest

858
00:34:02,320 --> 00:34:04,880
instead you say is that you can follow

859
00:34:04,880 --> 00:34:08,159
the duplication of objects handles and

860
00:34:08,159 --> 00:34:10,399
the sharing of object it seems promising

861
00:34:10,399 --> 00:34:11,918
because in the m to support a

862
00:34:11,918 --> 00:34:14,560
distributed execution you will need to

863
00:34:14,560 --> 00:34:18,000
use standard operating system means for

864
00:34:18,000 --> 00:34:21,040
handles and objects further duplication

865
00:34:21,040 --> 00:34:23,599
so this can be promising also we believe

866
00:34:23,599 --> 00:34:24,399
that

867
00:34:24,399 --> 00:34:26,560
code reuse aware analysis will be

868
00:34:26,560 --> 00:34:27,760
interesting

869
00:34:27,760 --> 00:34:30,399
uh an interesting addition for in-memory

870
00:34:30,399 --> 00:34:32,079
scanning in memory analysis of

871
00:34:32,079 --> 00:34:35,119
anti-viruses there are some works in the

872
00:34:35,119 --> 00:34:37,918
academic literature that are promising

873
00:34:37,918 --> 00:34:39,918
and we also think that

874
00:34:39,918 --> 00:34:42,800
it's important to invest on

875
00:34:42,800 --> 00:34:46,079
technologies that allow to robustly

876
00:34:46,079 --> 00:34:48,639
intercept and evict or robustly

877
00:34:48,639 --> 00:34:51,040
intercept the invocation of sensitive

878
00:34:51,040 --> 00:34:53,040
apis that you cannot just bypass the

879
00:34:53,040 --> 00:34:54,000
hooks

880
00:34:54,000 --> 00:34:55,119
so

881
00:34:55,119 --> 00:34:57,200
there are opportunities like

882
00:34:57,200 --> 00:34:59,599
event tracing or windows or

883
00:34:59,599 --> 00:35:01,920
breakpoints that are implemented using

884
00:35:01,920 --> 00:35:04,079
extended page tables there are many

885
00:35:04,079 --> 00:35:05,760
opportunities

886
00:35:05,760 --> 00:35:08,640
uh i hope you enjoyed our research and

887
00:35:08,640 --> 00:35:10,400
enjoyed this talk

888
00:35:10,400 --> 00:35:12,640
uh there is also a paper that is

889
00:35:12,640 --> 00:35:15,119
detailing our concept if you're

890
00:35:15,119 --> 00:35:17,920
interested you you can look at it and

891
00:35:17,920 --> 00:35:20,560
most importantly i'm very

892
00:35:20,560 --> 00:35:22,960
i would be very happy to take your

893
00:35:22,960 --> 00:35:25,280
questions and answer them now thank you

894
00:35:25,280 --> 00:35:28,680
for your attention

