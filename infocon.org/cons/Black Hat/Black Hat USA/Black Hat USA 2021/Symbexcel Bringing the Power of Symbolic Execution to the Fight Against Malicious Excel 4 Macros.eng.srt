1
00:00:01,130 --> 00:00:14,320
[Music]

2
00:00:14,320 --> 00:00:16,640
the power of symbolic execution to the

3
00:00:16,640 --> 00:00:20,320
fight against malicious excel for macros

4
00:00:20,320 --> 00:00:21,760
this work

5
00:00:21,760 --> 00:00:23,760
is the result of the collaboration

6
00:00:23,760 --> 00:00:25,840
between four people

7
00:00:25,840 --> 00:00:29,599
myself nicola aguado fabio pagani and

8
00:00:29,599 --> 00:00:32,558
stefano ortolan

9
00:00:32,558 --> 00:00:36,320
fabio pagani and nicola aguaro are

10
00:00:36,320 --> 00:00:39,040
working at ucsb in the sac lab while

11
00:00:39,040 --> 00:00:41,840
myself and stefano ortolani are working

12
00:00:41,840 --> 00:00:46,079
at the threat analysis unit at vmware

13
00:00:46,079 --> 00:00:49,760
excel 4 macros are used in malware

14
00:00:49,760 --> 00:00:51,680
mostly to

15
00:00:51,680 --> 00:00:53,199
as the first

16
00:00:53,199 --> 00:00:56,239
step in a malware infection an excel

17
00:00:56,239 --> 00:00:59,039
file with excel for macros is sent

18
00:00:59,039 --> 00:01:02,160
usually as an attachment and then the

19
00:01:02,160 --> 00:01:04,799
macro gets executed and download another

20
00:01:04,799 --> 00:01:07,280
component that makes the malware more

21
00:01:07,280 --> 00:01:09,680
persistent there are many families they

22
00:01:09,680 --> 00:01:12,880
use this mechanism to achieve a first

23
00:01:12,880 --> 00:01:16,560
foothold on the computer of users we

24
00:01:16,560 --> 00:01:19,759
observe this with trigbot danabot golgi

25
00:01:19,759 --> 00:01:21,759
z loader you name it

26
00:01:21,759 --> 00:01:24,560
we have been tracking at vmware this

27
00:01:24,560 --> 00:01:26,479
threat since the very beginning

28
00:01:26,479 --> 00:01:27,280
of

29
00:01:27,280 --> 00:01:31,759
2020 and we have observed a continuous

30
00:01:31,759 --> 00:01:34,240
evolution of the techniques that are

31
00:01:34,240 --> 00:01:37,680
used to avoid detection and avoid

32
00:01:37,680 --> 00:01:39,040
analysis

33
00:01:39,040 --> 00:01:42,560
so what are excel 4 macros

34
00:01:42,560 --> 00:01:45,600
it's a legacy feature of excel

35
00:01:45,600 --> 00:01:49,360
that has been made obsolete by

36
00:01:49,360 --> 00:01:51,680
vba macros

37
00:01:51,680 --> 00:01:55,040
the difference between excel for macro

38
00:01:55,040 --> 00:01:55,920
and

39
00:01:55,920 --> 00:01:58,320
vba macro is the fact that

40
00:01:58,320 --> 00:01:59,840
vba macro

41
00:01:59,840 --> 00:02:03,040
are enabled by default but they cannot

42
00:02:03,040 --> 00:02:06,320
access the underlying operating system

43
00:02:06,320 --> 00:02:09,520
while excel 4 macros need to be

44
00:02:09,520 --> 00:02:11,920
enabled explicitly

45
00:02:11,920 --> 00:02:15,599
but then they have full access to the

46
00:02:15,599 --> 00:02:17,760
underlying capability of the operating

47
00:02:17,760 --> 00:02:20,239
system and for example they can execute

48
00:02:20,239 --> 00:02:21,360
commands

49
00:02:21,360 --> 00:02:24,319
using powershell and they can start

50
00:02:24,319 --> 00:02:27,280
programs and so forth and so on

51
00:02:27,280 --> 00:02:28,400
so

52
00:02:28,400 --> 00:02:32,080
if you look at your common idea of excel

53
00:02:32,080 --> 00:02:33,680
for macro they're limited to the

54
00:02:33,680 --> 00:02:36,720
workbook they're operating on and you

55
00:02:36,720 --> 00:02:39,440
cannot interact with environment excel

56
00:02:39,440 --> 00:02:41,440
for functions instead

57
00:02:41,440 --> 00:02:44,160
can access the win api

58
00:02:44,160 --> 00:02:47,040
directly they can access the file system

59
00:02:47,040 --> 00:02:50,080
directly and therefore they're a very

60
00:02:50,080 --> 00:02:54,800
powerful mechanism uh to gain access to

61
00:02:54,800 --> 00:02:57,440
the computer in which the excel for

62
00:02:57,440 --> 00:02:59,920
spreadsheet is running

63
00:02:59,920 --> 00:03:01,519
it's important to understand how they

64
00:03:01,519 --> 00:03:02,800
work there is

65
00:03:02,800 --> 00:03:04,879
in this spreadsheet there is a first

66
00:03:04,879 --> 00:03:08,159
cell called the auto open cell

67
00:03:08,159 --> 00:03:10,319
where the execution starts

68
00:03:10,319 --> 00:03:13,200
after that execution

69
00:03:13,200 --> 00:03:17,440
continues in the underlying cell

70
00:03:17,440 --> 00:03:20,640
until there is a transfer of execution

71
00:03:20,640 --> 00:03:23,120
that can happen in a number of ways for

72
00:03:23,120 --> 00:03:26,159
example using the go to function the run

73
00:03:26,159 --> 00:03:28,799
function or a user defined function

74
00:03:28,799 --> 00:03:31,519
at the same time the data in the cell

75
00:03:31,519 --> 00:03:32,640
can be

76
00:03:32,640 --> 00:03:36,799
modified dynamically using the formula

77
00:03:36,799 --> 00:03:39,840
and formula field functions so

78
00:03:39,840 --> 00:03:42,319
for example a formula function could

79
00:03:42,319 --> 00:03:45,120
write some code in terms

80
00:03:45,120 --> 00:03:46,959
expressed in terms of function in a

81
00:03:46,959 --> 00:03:49,599
specific cell and then

82
00:03:49,599 --> 00:03:52,159
the program could jump to that cell and

83
00:03:52,159 --> 00:03:54,640
therefore there is the chance of doing

84
00:03:54,640 --> 00:03:57,599
dynamic execution of code

85
00:03:57,599 --> 00:03:59,760
to give you an idea of what the bad guys

86
00:03:59,760 --> 00:04:00,640
do

87
00:04:00,640 --> 00:04:02,879
with these capabilities

88
00:04:02,879 --> 00:04:04,640
this is an example

89
00:04:04,640 --> 00:04:08,959
of a macro that checks if there is mouse

90
00:04:08,959 --> 00:04:12,239
and audio in the underlying system this

91
00:04:12,239 --> 00:04:13,200
is done

92
00:04:13,200 --> 00:04:17,199
so that they can avoid being analyzed in

93
00:04:17,199 --> 00:04:20,560
sandboxes they don't have a mouse or an

94
00:04:20,560 --> 00:04:22,639
audio system attached

95
00:04:22,639 --> 00:04:25,280
we saw evasion of this type of technique

96
00:04:25,280 --> 00:04:26,800
for example

97
00:04:26,800 --> 00:04:30,160
while the previous example was a hidden

98
00:04:30,160 --> 00:04:31,520
macro

99
00:04:31,520 --> 00:04:32,400
sheet

100
00:04:32,400 --> 00:04:34,400
in the new example we saw the very

101
00:04:34,400 --> 00:04:37,520
hidden macro sheet that requires a

102
00:04:37,520 --> 00:04:41,280
manual operation in order to expose the

103
00:04:41,280 --> 00:04:43,600
content of the

104
00:04:43,600 --> 00:04:44,560
of the

105
00:04:44,560 --> 00:04:47,040
actual macro and in addition we see

106
00:04:47,040 --> 00:04:49,759
newer vision tricks for example

107
00:04:49,759 --> 00:04:53,280
a check on the size of the display

108
00:04:53,280 --> 00:04:55,199
other things that we see we saw

109
00:04:55,199 --> 00:04:58,720
throughout you know 2020 and 2021 is the

110
00:04:58,720 --> 00:05:00,880
use for example of the char

111
00:05:00,880 --> 00:05:04,160
function in order to collate together uh

112
00:05:04,160 --> 00:05:07,360
one letter by letter the whole content

113
00:05:07,360 --> 00:05:09,520
of a macro

114
00:05:09,520 --> 00:05:11,919
or the use of time dependency for

115
00:05:11,919 --> 00:05:15,280
example uh in in this case there is a

116
00:05:15,280 --> 00:05:18,479
macro that uses specific day

117
00:05:18,479 --> 00:05:20,000
as a key

118
00:05:20,000 --> 00:05:23,360
to actually decrypt the contents of the

119
00:05:23,360 --> 00:05:26,479
macro so for example if

120
00:05:26,479 --> 00:05:28,479
you do it in the wrong day

121
00:05:28,479 --> 00:05:30,960
you obtain just gibberish

122
00:05:30,960 --> 00:05:32,960
but on the right day

123
00:05:32,960 --> 00:05:36,560
you have the correct macro

124
00:05:36,560 --> 00:05:38,479
this of course um

125
00:05:38,479 --> 00:05:40,960
can create all sorts of problems

126
00:05:40,960 --> 00:05:43,280
uh and another another technique that is

127
00:05:43,280 --> 00:05:46,960
used by done by malware authors is the

128
00:05:46,960 --> 00:05:48,160
use of

129
00:05:48,160 --> 00:05:49,600
register

130
00:05:49,600 --> 00:05:52,320
in order to create custom names for

131
00:05:52,320 --> 00:05:54,560
specific function so the register

132
00:05:54,560 --> 00:05:56,800
function in excel for macro can

133
00:05:56,800 --> 00:05:59,440
associate any kind of label to any kind

134
00:05:59,440 --> 00:06:02,160
of function and by doing this the

135
00:06:02,160 --> 00:06:05,680
malware authors try to avoid

136
00:06:05,680 --> 00:06:08,720
signature matches and static analysis on

137
00:06:08,720 --> 00:06:10,560
the code itself

138
00:06:10,560 --> 00:06:11,600
so

139
00:06:11,600 --> 00:06:13,440
you can see from this that there are

140
00:06:13,440 --> 00:06:15,280
problems with obfuscation because there

141
00:06:15,280 --> 00:06:17,680
are so many techniques in that can be

142
00:06:17,680 --> 00:06:20,720
used in order to obfuscate a malware

143
00:06:20,720 --> 00:06:24,000
some techniques can prevent detection

144
00:06:24,000 --> 00:06:28,319
some can even help detection however

145
00:06:28,319 --> 00:06:30,800
the idea obfuscation problem is still

146
00:06:30,800 --> 00:06:33,120
very hard and we need the obfuscation

147
00:06:33,120 --> 00:06:35,039
because we want to understand all the

148
00:06:35,039 --> 00:06:37,759
possible behaviors of a specific macro

149
00:06:37,759 --> 00:06:39,520
not the ones associated with a single

150
00:06:39,520 --> 00:06:43,440
execution and also we want to extract

151
00:06:43,440 --> 00:06:46,000
the indicators of compromise as i don't

152
00:06:46,000 --> 00:06:47,840
know if you notice in the previous slide

153
00:06:47,840 --> 00:06:50,639
you can see that there are a number of

154
00:06:50,639 --> 00:06:53,360
domains that are used or executable that

155
00:06:53,360 --> 00:06:55,599
are used and that information is

156
00:06:55,599 --> 00:06:58,160
important in order to create

157
00:06:58,160 --> 00:07:00,720
threat feeds that allow

158
00:07:00,720 --> 00:07:04,000
systems to detect this type of macros

159
00:07:04,000 --> 00:07:05,599
reliably

160
00:07:05,599 --> 00:07:08,560
so at the moment deaf skating these

161
00:07:08,560 --> 00:07:12,160
macros is an error prone manual task

162
00:07:12,160 --> 00:07:14,319
that requires a lot of manual work

163
00:07:14,319 --> 00:07:16,400
muscle because static analysis does not

164
00:07:16,400 --> 00:07:19,199
work because it's heavily obfuscated and

165
00:07:19,199 --> 00:07:22,479
also dynamic analysis only gives you one

166
00:07:22,479 --> 00:07:25,919
sort of thread of execution so we want

167
00:07:25,919 --> 00:07:29,599
to automate the obfuscation but what

168
00:07:29,599 --> 00:07:31,840
how can we handle all these

169
00:07:31,840 --> 00:07:34,800
environmental checks that make a

170
00:07:34,800 --> 00:07:37,199
particular macro only work if the right

171
00:07:37,199 --> 00:07:39,919
boundary conditions are correct how can

172
00:07:39,919 --> 00:07:43,039
we guess the right value and here we

173
00:07:43,039 --> 00:07:45,120
introduce the the power of symbolic

174
00:07:45,120 --> 00:07:47,520
execution this is a program analysis

175
00:07:47,520 --> 00:07:48,479
technique

176
00:07:48,479 --> 00:07:49,599
that

177
00:07:49,599 --> 00:07:51,599
uses symbolic

178
00:07:51,599 --> 00:07:54,479
values in order to represent

179
00:07:54,479 --> 00:07:56,879
all possible executions at least in

180
00:07:56,879 --> 00:07:58,960
theory so the basic idea is that in

181
00:07:58,960 --> 00:08:00,879
symbolic execution you interpret the

182
00:08:00,879 --> 00:08:03,199
code and whenever there is an input from

183
00:08:03,199 --> 00:08:05,520
the outside environment you keep that

184
00:08:05,520 --> 00:08:07,520
value symbolic

185
00:08:07,520 --> 00:08:10,800
so when a conditional statement is found

186
00:08:10,800 --> 00:08:13,759
and the conditional statement relies of

187
00:08:13,759 --> 00:08:16,560
on one of these symbolic values instead

188
00:08:16,560 --> 00:08:20,560
of taking a single decision you fork

189
00:08:20,560 --> 00:08:23,440
you know a new state so you you sort of

190
00:08:23,440 --> 00:08:26,960
proceed both ways and depending on what

191
00:08:26,960 --> 00:08:31,039
branch you decide to progress you add a

192
00:08:31,039 --> 00:08:33,839
constraint over the value of the

193
00:08:33,839 --> 00:08:36,719
symbolic variable at a certain point you

194
00:08:36,719 --> 00:08:39,120
might reach a point of interest in your

195
00:08:39,120 --> 00:08:42,080
code and at that point you can ask a

196
00:08:42,080 --> 00:08:44,800
constraint solver to automatically

197
00:08:44,800 --> 00:08:47,600
provide you with a value that satisfies

198
00:08:47,600 --> 00:08:49,680
the constraints that will take you to

199
00:08:49,680 --> 00:08:51,200
that point

200
00:08:51,200 --> 00:08:53,920
and you can use this technique to obtain

201
00:08:53,920 --> 00:08:56,800
automatically de-obfuscated code

202
00:08:56,800 --> 00:08:58,720
well let me tell you a little bit

203
00:08:58,720 --> 00:09:00,560
about symbolic execution with this

204
00:09:00,560 --> 00:09:04,480
example so we have very simple code

205
00:09:04,480 --> 00:09:06,320
and you can see at the very beginning we

206
00:09:06,320 --> 00:09:09,120
have a state and we read some input so

207
00:09:09,120 --> 00:09:12,480
our variable x at this point is a

208
00:09:12,480 --> 00:09:15,200
symbolic variable so we don't know what

209
00:09:15,200 --> 00:09:15,920
uh

210
00:09:15,920 --> 00:09:17,920
value it is it's not five it's not seven

211
00:09:17,920 --> 00:09:20,160
it's just a symbolic value so we sort of

212
00:09:20,160 --> 00:09:23,680
like uh weight to make a decision on

213
00:09:23,680 --> 00:09:25,680
that particular value of course in the

214
00:09:25,680 --> 00:09:27,279
following

215
00:09:27,279 --> 00:09:29,920
line we actually compute a value based

216
00:09:29,920 --> 00:09:31,839
on that symbolic value and so we have to

217
00:09:31,839 --> 00:09:34,399
keep track of the fact that y

218
00:09:34,399 --> 00:09:37,519
is x plus one so a symbolic value plus

219
00:09:37,519 --> 00:09:38,480
one

220
00:09:38,480 --> 00:09:40,959
and then we encounter our first

221
00:09:40,959 --> 00:09:43,760
constraint we have a conditional

222
00:09:43,760 --> 00:09:47,200
y greater or equal to ten and so we have

223
00:09:47,200 --> 00:09:48,560
to sort of

224
00:09:48,560 --> 00:09:51,360
split our execution in two possible

225
00:09:51,360 --> 00:09:53,040
state one

226
00:09:53,040 --> 00:09:56,080
that will be followed if the constraint

227
00:09:56,080 --> 00:09:59,040
y less than ten is uh

228
00:09:59,040 --> 00:10:02,800
true and one if the constraint y greater

229
00:10:02,800 --> 00:10:06,320
or equal 10 is true and you go on

230
00:10:06,320 --> 00:10:10,000
then for example you can have another

231
00:10:10,000 --> 00:10:13,519
if then else in this case is based on x

232
00:10:13,519 --> 00:10:15,760
symbolic variable and therefore the

233
00:10:15,760 --> 00:10:20,079
relevant state is split again to track

234
00:10:20,079 --> 00:10:20,880
all

235
00:10:20,880 --> 00:10:21,920
possible

236
00:10:21,920 --> 00:10:23,120
outcomes

237
00:10:23,120 --> 00:10:25,680
but at this point we are at the

238
00:10:25,680 --> 00:10:28,399
interesting code and so we can now

239
00:10:28,399 --> 00:10:31,040
concretize the state and we can ask the

240
00:10:31,040 --> 00:10:34,800
solver hey give me a value of x that

241
00:10:34,800 --> 00:10:38,079
actually will drive the execution of

242
00:10:38,079 --> 00:10:40,079
this code to this point to the

243
00:10:40,079 --> 00:10:42,800
interesting code so you can avoid

244
00:10:42,800 --> 00:10:44,959
testing for the errors you just get to

245
00:10:44,959 --> 00:10:47,279
your code you have your state and you

246
00:10:47,279 --> 00:10:50,079
get the magic value they will lead you

247
00:10:50,079 --> 00:10:52,000
to the place where you want and you

248
00:10:52,000 --> 00:10:54,959
already can understand how this can lead

249
00:10:54,959 --> 00:10:57,839
to the point where you will have the

250
00:10:57,839 --> 00:11:00,880
interesting de-obfuscating code

251
00:11:00,880 --> 00:11:02,640
and i just want to say wait wait a

252
00:11:02,640 --> 00:11:05,200
minute how do you do this

253
00:11:05,200 --> 00:11:06,320
well

254
00:11:06,320 --> 00:11:09,279
nicole aguado will explain the

255
00:11:09,279 --> 00:11:13,600
nitty-gritty details of how this is done

256
00:11:13,600 --> 00:11:15,279
hello everyone and thank you giovanni

257
00:11:15,279 --> 00:11:17,360
for the introduction so now we'll talk

258
00:11:17,360 --> 00:11:19,920
about our approach and implementation of

259
00:11:19,920 --> 00:11:22,320
the sim excel symbolic execution engine

260
00:11:22,320 --> 00:11:24,640
for excel for macros

261
00:11:24,640 --> 00:11:26,800
to start off and before delving into the

262
00:11:26,800 --> 00:11:29,279
details of symbolic execution i would

263
00:11:29,279 --> 00:11:31,040
like to talk a little bit about concrete

264
00:11:31,040 --> 00:11:32,160
analysis

265
00:11:32,160 --> 00:11:34,079
concrete analysis is a good tool for

266
00:11:34,079 --> 00:11:36,160
post infection analysis and the

267
00:11:36,160 --> 00:11:38,800
obfuscation of xl4 macros

268
00:11:38,800 --> 00:11:42,399
it will not execute the excel for sample

269
00:11:42,399 --> 00:11:45,120
but it will instead load the xls file

270
00:11:45,120 --> 00:11:47,600
into memory and start interpreting all

271
00:11:47,600 --> 00:11:50,000
of the instructions from the entry point

272
00:11:50,000 --> 00:11:52,160
down to the actual execution of the

273
00:11:52,160 --> 00:11:53,680
modular payload

274
00:11:53,680 --> 00:11:54,880
since the initial environment

275
00:11:54,880 --> 00:11:57,120
configuration is not known it is

276
00:11:57,120 --> 00:11:59,279
possible with concrete analysis to use

277
00:11:59,279 --> 00:12:01,760
brute force and forced execution in

278
00:12:01,760 --> 00:12:03,600
order to automatically figure out what

279
00:12:03,600 --> 00:12:05,920
the correct environment configuration is

280
00:12:05,920 --> 00:12:07,600
and sidestep the environment

281
00:12:07,600 --> 00:12:08,880
configuration

282
00:12:08,880 --> 00:12:10,800
a good example of a complete analysis

283
00:12:10,800 --> 00:12:13,519
tool for excel for macros is the xlm

284
00:12:13,519 --> 00:12:15,920
macro diffusator developed by desect

285
00:12:15,920 --> 00:12:18,480
modeler which is a great tool that poses

286
00:12:18,480 --> 00:12:20,399
the basis for our symbolic analysis

287
00:12:20,399 --> 00:12:21,839
approach

288
00:12:21,839 --> 00:12:23,839
now the problem with concrete analysis

289
00:12:23,839 --> 00:12:26,079
is that first it will need some human

290
00:12:26,079 --> 00:12:27,279
input

291
00:12:27,279 --> 00:12:29,519
because either a human analyst will need

292
00:12:29,519 --> 00:12:32,240
to manually inspect the malware sample

293
00:12:32,240 --> 00:12:33,440
and figure out what the correct

294
00:12:33,440 --> 00:12:35,440
environment variables are

295
00:12:35,440 --> 00:12:37,600
or it will need to

296
00:12:37,600 --> 00:12:39,680
manually inspect the sample and figure

297
00:12:39,680 --> 00:12:42,000
out what variables we should perforce

298
00:12:42,000 --> 00:12:44,880
and how to efficiently reforce them

299
00:12:44,880 --> 00:12:47,360
this as you can expect will quickly get

300
00:12:47,360 --> 00:12:49,440
inspecting effective because as the

301
00:12:49,440 --> 00:12:52,480
malware starts to use more environment

302
00:12:52,480 --> 00:12:54,720
variables and the search space becomes

303
00:12:54,720 --> 00:12:56,560
larger and larger

304
00:12:56,560 --> 00:12:59,200
this approach will no longer work

305
00:12:59,200 --> 00:13:01,600
symbolic execution on the other hand

306
00:13:01,600 --> 00:13:03,519
will understand how these environment

307
00:13:03,519 --> 00:13:06,959
variables are generated propagated and

308
00:13:06,959 --> 00:13:09,360
used during the execution

309
00:13:09,360 --> 00:13:11,360
and will allow us to reason more

310
00:13:11,360 --> 00:13:14,160
formally about the environment and

311
00:13:14,160 --> 00:13:16,079
leverage this additional information in

312
00:13:16,079 --> 00:13:17,920
order to solve the constraints in the

313
00:13:17,920 --> 00:13:21,839
most efficient way possible

314
00:13:21,839 --> 00:13:23,839
our architecture is

315
00:13:23,839 --> 00:13:26,399
composed of three main components the

316
00:13:26,399 --> 00:13:28,639
loader simulation manager and the solver

317
00:13:28,639 --> 00:13:30,000
backhand

318
00:13:30,000 --> 00:13:32,480
the loader component is where the xls

319
00:13:32,480 --> 00:13:35,440
file is loaded into memory

320
00:13:35,440 --> 00:13:37,920
the simulation manager is essentially a

321
00:13:37,920 --> 00:13:39,519
state orchestrator

322
00:13:39,519 --> 00:13:42,880
and will as you can see from the image

323
00:13:42,880 --> 00:13:44,959
during the execution manage multiple

324
00:13:44,959 --> 00:13:46,000
states

325
00:13:46,000 --> 00:13:48,800
where every state has its own copy of

326
00:13:48,800 --> 00:13:52,079
the environment memory and constraints

327
00:13:52,079 --> 00:13:53,760
finally the last component in our

328
00:13:53,760 --> 00:13:56,560
architecture is a solver backhand

329
00:13:56,560 --> 00:13:58,399
which is where we keep track of the

330
00:13:58,399 --> 00:14:00,639
constraints and we will solve constraint

331
00:14:00,639 --> 00:14:04,639
to proceed with the symbolic execution

332
00:14:04,880 --> 00:14:07,120
we will now talk briefly about these

333
00:14:07,120 --> 00:14:08,639
three components

334
00:14:08,639 --> 00:14:12,800
and we will start off with a loader

335
00:14:12,880 --> 00:14:15,839
the loader is where the xls file which

336
00:14:15,839 --> 00:14:18,720
comes in the bfade format will be parsed

337
00:14:18,720 --> 00:14:20,639
and loaded into memory

338
00:14:20,639 --> 00:14:22,399
the loader will create an initial

339
00:14:22,399 --> 00:14:24,000
simulation manager

340
00:14:24,000 --> 00:14:26,240
and initialize its memory and its

341
00:14:26,240 --> 00:14:28,320
environment

342
00:14:28,320 --> 00:14:30,160
accordingly to the file that is just

343
00:14:30,160 --> 00:14:32,160
loaded into memory

344
00:14:32,160 --> 00:14:34,399
so at this point we have two choices in

345
00:14:34,399 --> 00:14:36,320
order to implement the loader we can

346
00:14:36,320 --> 00:14:38,160
decide to implement a loader in a static

347
00:14:38,160 --> 00:14:39,120
fashion

348
00:14:39,120 --> 00:14:41,839
or in a more dynamic fashion

349
00:14:41,839 --> 00:14:44,079
an example of a loader implemented in a

350
00:14:44,079 --> 00:14:45,279
static way

351
00:14:45,279 --> 00:14:48,639
is the xlr d2 library developed again by

352
00:14:48,639 --> 00:14:51,680
desect modeler which is a good approach

353
00:14:51,680 --> 00:14:54,720
fast but less robust than the dynamic

354
00:14:54,720 --> 00:14:57,519
alternative so if you want to use a more

355
00:14:57,519 --> 00:14:59,600
dynamic approach

356
00:14:59,600 --> 00:15:01,519
what you can do is instead to use the

357
00:15:01,519 --> 00:15:04,160
windows component object model which

358
00:15:04,160 --> 00:15:06,880
allows us to interface directly with

359
00:15:06,880 --> 00:15:08,160
excel

360
00:15:08,160 --> 00:15:11,199
so load the file into memory and in this

361
00:15:11,199 --> 00:15:13,760
way avoid many of the vision techniques

362
00:15:13,760 --> 00:15:16,399
that we commonly see in the most modern

363
00:15:16,399 --> 00:15:20,480
wave of xl4 malware samples

364
00:15:20,560 --> 00:15:22,560
the second component in our architecture

365
00:15:22,560 --> 00:15:25,120
is the simulation manager the simulation

366
00:15:25,120 --> 00:15:26,720
manager is essentially a state

367
00:15:26,720 --> 00:15:29,600
orchestrator as we have already said

368
00:15:29,600 --> 00:15:32,880
so what it will do is initialize an

369
00:15:32,880 --> 00:15:35,199
initial state that will start the

370
00:15:35,199 --> 00:15:37,839
execution from the entry point

371
00:15:37,839 --> 00:15:39,519
it will then implement

372
00:15:39,519 --> 00:15:41,920
a step function that transitions from

373
00:15:41,920 --> 00:15:45,040
one state to the successful state

374
00:15:45,040 --> 00:15:48,240
while taking care of updating the memory

375
00:15:48,240 --> 00:15:51,839
the environment and the constraints

376
00:15:52,079 --> 00:15:54,160
every state will contain its own copy of

377
00:15:54,160 --> 00:15:56,639
the memory environmental constraints

378
00:15:56,639 --> 00:15:58,560
where the memory contains the cell

379
00:15:58,560 --> 00:16:01,920
values formulas cell information and the

380
00:16:01,920 --> 00:16:04,399
defined names the cell information are

381
00:16:04,399 --> 00:16:05,199
like

382
00:16:05,199 --> 00:16:08,320
the font that is used font size that is

383
00:16:08,320 --> 00:16:11,040
used in the cell etc while the defined

384
00:16:11,040 --> 00:16:14,320
names are global names which are shared

385
00:16:14,320 --> 00:16:16,800
all across the spreadsheet

386
00:16:16,800 --> 00:16:19,440
environment variables are what is used

387
00:16:19,440 --> 00:16:21,279
by the modular authors

388
00:16:21,279 --> 00:16:24,720
for sandbox detection an example of some

389
00:16:24,720 --> 00:16:26,639
environment variables

390
00:16:26,639 --> 00:16:29,360
is the window height and the operating

391
00:16:29,360 --> 00:16:31,519
system which is in use

392
00:16:31,519 --> 00:16:32,800
since the initial environment

393
00:16:32,800 --> 00:16:34,160
configuration

394
00:16:34,160 --> 00:16:35,360
and the correct environment

395
00:16:35,360 --> 00:16:37,680
configuration for the modular execution

396
00:16:37,680 --> 00:16:41,279
is unknown what we do is associate a

397
00:16:41,279 --> 00:16:44,560
symbolic variable with each one of these

398
00:16:44,560 --> 00:16:46,959
environment variables and this allows us

399
00:16:46,959 --> 00:16:49,680
to figure out later during the execution

400
00:16:49,680 --> 00:16:51,360
what the correct value for that

401
00:16:51,360 --> 00:16:54,639
particular environment variable is

402
00:16:54,639 --> 00:16:55,920
finally

403
00:16:55,920 --> 00:16:58,399
constraints are what will characterize

404
00:16:58,399 --> 00:17:01,680
the malware execution meaning that

405
00:17:01,680 --> 00:17:03,920
the modeler will take one range or

406
00:17:03,920 --> 00:17:06,160
another branch when executing a

407
00:17:06,160 --> 00:17:08,480
conditional instruction depending on the

408
00:17:08,480 --> 00:17:10,959
constraints that are set on the state an

409
00:17:10,959 --> 00:17:13,919
example of a constraint is window height

410
00:17:13,919 --> 00:17:16,559
greater than 390 and this type of

411
00:17:16,559 --> 00:17:18,480
constraints are propagated

412
00:17:18,480 --> 00:17:20,400
throughout the execution to the

413
00:17:20,400 --> 00:17:22,720
successful states so every time that the

414
00:17:22,720 --> 00:17:25,280
step function is called

415
00:17:25,280 --> 00:17:27,760
these constraints will be propagated to

416
00:17:27,760 --> 00:17:31,640
this successful state

417
00:17:32,000 --> 00:17:34,480
the step function is what will take care

418
00:17:34,480 --> 00:17:37,919
to execute every cell and every formula

419
00:17:37,919 --> 00:17:39,600
the first thing that the step function

420
00:17:39,600 --> 00:17:40,559
does

421
00:17:40,559 --> 00:17:42,720
is to parse these formulas

422
00:17:42,720 --> 00:17:45,039
in order to generate an abstract syntax

423
00:17:45,039 --> 00:17:47,440
3 or ast

424
00:17:47,440 --> 00:17:49,440
this is done by using an extended

425
00:17:49,440 --> 00:17:52,559
bacchus normal form grammar or ebnf and

426
00:17:52,559 --> 00:17:55,840
a look ahead left to right parser

427
00:17:55,840 --> 00:17:57,679
which we implemented using the larc

428
00:17:57,679 --> 00:17:59,120
library

429
00:17:59,120 --> 00:18:01,280
after parsing the formula and generating

430
00:18:01,280 --> 00:18:02,960
the ast

431
00:18:02,960 --> 00:18:05,280
the step function will dispatch the

432
00:18:05,280 --> 00:18:06,480
execution

433
00:18:06,480 --> 00:18:08,880
to the correct formula handlers which

434
00:18:08,880 --> 00:18:11,440
will take care of updating the memory

435
00:18:11,440 --> 00:18:13,200
accessing the environment

436
00:18:13,200 --> 00:18:16,160
generating and adding new constraints or

437
00:18:16,160 --> 00:18:18,080
creating new branches whenever a

438
00:18:18,080 --> 00:18:22,080
conditional instruction is executed

439
00:18:22,480 --> 00:18:25,280
now in order to make this all more clear

440
00:18:25,280 --> 00:18:27,919
let's look at some examples so in this

441
00:18:27,919 --> 00:18:29,760
case we will start execution from this

442
00:18:29,760 --> 00:18:32,799
from the cell a1 and the cell a1

443
00:18:32,799 --> 00:18:34,720
contains the formula char

444
00:18:34,720 --> 00:18:37,600
with the parameter 72 the chart formula

445
00:18:37,600 --> 00:18:40,000
is very common in this kind of samples

446
00:18:40,000 --> 00:18:42,640
and essentially translate from the ascii

447
00:18:42,640 --> 00:18:44,559
representation of the character to the

448
00:18:44,559 --> 00:18:47,200
character itself and so in this case it

449
00:18:47,200 --> 00:18:49,280
will update the memory and write the

450
00:18:49,280 --> 00:18:53,679
character h to the destination cell a1

451
00:18:53,679 --> 00:18:56,720
after executing the cell a1 the step

452
00:18:56,720 --> 00:18:59,280
function will continue and step into the

453
00:18:59,280 --> 00:19:00,640
cell a2

454
00:19:00,640 --> 00:19:02,799
the cell a2 contains the formula get

455
00:19:02,799 --> 00:19:05,120
workspace 14.

456
00:19:05,120 --> 00:19:07,200
get workspace is a special type of

457
00:19:07,200 --> 00:19:10,799
formula that will access the environment

458
00:19:10,799 --> 00:19:12,320
and in this case

459
00:19:12,320 --> 00:19:13,919
read the value of the environment

460
00:19:13,919 --> 00:19:16,880
variable workspace 14 which corresponds

461
00:19:16,880 --> 00:19:19,679
to the workspace height

462
00:19:19,679 --> 00:19:20,960
after reading the value from the

463
00:19:20,960 --> 00:19:22,240
environment

464
00:19:22,240 --> 00:19:24,400
this will write its value

465
00:19:24,400 --> 00:19:26,320
into the cell

466
00:19:26,320 --> 00:19:28,799
at the address a2

467
00:19:28,799 --> 00:19:31,440
so you can see how the symbolic variable

468
00:19:31,440 --> 00:19:34,160
is now no longer only in the environment

469
00:19:34,160 --> 00:19:34,960
but

470
00:19:34,960 --> 00:19:37,679
has also been propagated into the memory

471
00:19:37,679 --> 00:19:39,600
and will be used later for further

472
00:19:39,600 --> 00:19:42,240
computation

473
00:19:42,640 --> 00:19:45,600
after stepping the cell a2 the cell a3

474
00:19:45,600 --> 00:19:48,080
will be executed and you can see here

475
00:19:48,080 --> 00:19:48,960
that

476
00:19:48,960 --> 00:19:52,160
a conditional instruction is executed

477
00:19:52,160 --> 00:19:55,039
the if formula takes three parameters

478
00:19:55,039 --> 00:19:58,000
first the condition itself

479
00:19:58,000 --> 00:20:00,240
then the true branch and then the false

480
00:20:00,240 --> 00:20:01,280
branch

481
00:20:01,280 --> 00:20:03,039
in this case you can see that the

482
00:20:03,039 --> 00:20:04,880
conditional

483
00:20:04,880 --> 00:20:07,919
the condition is symbolic

484
00:20:07,919 --> 00:20:10,159
and so we don't know if we have to

485
00:20:10,159 --> 00:20:12,320
execute the true branch or the false

486
00:20:12,320 --> 00:20:13,600
branch

487
00:20:13,600 --> 00:20:17,200
and thus we generate two branches

488
00:20:17,200 --> 00:20:19,520
write the correct values to the correct

489
00:20:19,520 --> 00:20:23,760
cells so 75 and 76 to the cell a3 in the

490
00:20:23,760 --> 00:20:25,039
two branches

491
00:20:25,039 --> 00:20:26,559
and finally

492
00:20:26,559 --> 00:20:29,440
generate and add the correct constraints

493
00:20:29,440 --> 00:20:31,200
to the two states

494
00:20:31,200 --> 00:20:33,679
we will add the constraint workspace 14

495
00:20:33,679 --> 00:20:37,039
greater than 390 to the true branch and

496
00:20:37,039 --> 00:20:40,480
will space 14 less or equal than 390 to

497
00:20:40,480 --> 00:20:42,640
the fullest branch and then continue

498
00:20:42,640 --> 00:20:45,919
with the symbolic execution

499
00:20:46,000 --> 00:20:48,720
now at cell a4 we have a slightly more

500
00:20:48,720 --> 00:20:51,200
complicated formula

501
00:20:51,200 --> 00:20:53,919
as usual the step function will parse

502
00:20:53,919 --> 00:20:55,600
this formula and generate the

503
00:20:55,600 --> 00:20:58,000
corresponding abstract syntax tree which

504
00:20:58,000 --> 00:21:00,240
you can see in the image

505
00:21:00,240 --> 00:21:02,320
as you can see one of the leaf nodes in

506
00:21:02,320 --> 00:21:04,320
this case is symbolic

507
00:21:04,320 --> 00:21:08,320
and it's the variable workspace 14 again

508
00:21:08,320 --> 00:21:10,480
during the execution of the formula the

509
00:21:10,480 --> 00:21:13,120
handlers will propagate this value and

510
00:21:13,120 --> 00:21:16,000
generate a symbolic expression

511
00:21:16,000 --> 00:21:18,720
that will be then written into the cell

512
00:21:18,720 --> 00:21:21,280
a4

513
00:21:24,080 --> 00:21:25,200
now that you've seen some of the

514
00:21:25,200 --> 00:21:27,600
examples let's have a look at our silver

515
00:21:27,600 --> 00:21:28,960
backend

516
00:21:28,960 --> 00:21:31,440
what we use for our silver backend is

517
00:21:31,440 --> 00:21:34,960
the z3 smt solver which is a very common

518
00:21:34,960 --> 00:21:36,480
smt solver

519
00:21:36,480 --> 00:21:38,320
and we believe that the most interesting

520
00:21:38,320 --> 00:21:41,200
use case for our tool

521
00:21:41,200 --> 00:21:44,159
is the execution of a symbolic payload

522
00:21:44,159 --> 00:21:46,240
however what i mean with a symbolic

523
00:21:46,240 --> 00:21:48,720
payload so let's look at an example

524
00:21:48,720 --> 00:21:50,960
let's go back to our example

525
00:21:50,960 --> 00:21:54,000
and when executing a cell a5 you can see

526
00:21:54,000 --> 00:21:56,880
here that we execute the formula formula

527
00:21:56,880 --> 00:21:59,760
fill which takes two parameters an

528
00:21:59,760 --> 00:22:02,960
expression and a destination cell

529
00:22:02,960 --> 00:22:04,720
in this case the expression is a

530
00:22:04,720 --> 00:22:07,280
concatenation of multiple characters so

531
00:22:07,280 --> 00:22:08,799
the first thing

532
00:22:08,799 --> 00:22:11,200
that the handler for the formula we'll

533
00:22:11,200 --> 00:22:13,679
do is to read these characters from the

534
00:22:13,679 --> 00:22:14,799
memory

535
00:22:14,799 --> 00:22:16,960
concatenate them

536
00:22:16,960 --> 00:22:19,360
and write the result finally into the

537
00:22:19,360 --> 00:22:21,760
destination cell a6

538
00:22:21,760 --> 00:22:23,919
as you can see the values that we read

539
00:22:23,919 --> 00:22:25,280
from the environment

540
00:22:25,280 --> 00:22:27,600
are not all concrete some of them are

541
00:22:27,600 --> 00:22:28,960
symbolic

542
00:22:28,960 --> 00:22:31,120
so we will have a new symbolic

543
00:22:31,120 --> 00:22:33,200
expression which we marked a symbolic

544
00:22:33,200 --> 00:22:34,960
expression 2

545
00:22:34,960 --> 00:22:36,640
that is going to be written to the cell

546
00:22:36,640 --> 00:22:38,000
a6

547
00:22:38,000 --> 00:22:39,120
however

548
00:22:39,120 --> 00:22:42,000
after executing a cell at a5 the step

549
00:22:42,000 --> 00:22:43,679
function will continue executing

550
00:22:43,679 --> 00:22:46,559
execution

551
00:22:46,559 --> 00:22:50,640
and execute the cell a6

552
00:22:50,640 --> 00:22:54,000
a6 however contain a symbolic expression

553
00:22:54,000 --> 00:22:56,880
and we don't know yet how to execute a

554
00:22:56,880 --> 00:22:58,559
symbolic expression

555
00:22:58,559 --> 00:23:00,240
obviously

556
00:23:00,240 --> 00:23:02,880
the solution for this is to concretize

557
00:23:02,880 --> 00:23:04,159
the values

558
00:23:04,159 --> 00:23:05,039
and

559
00:23:05,039 --> 00:23:07,600
generate multiple possible concrete

560
00:23:07,600 --> 00:23:08,559
solutions

561
00:23:08,559 --> 00:23:11,360
that we will later execute in our

562
00:23:11,360 --> 00:23:13,440
symbolic execution engine

563
00:23:13,440 --> 00:23:14,720
however

564
00:23:14,720 --> 00:23:17,840
how many solution do we have here

565
00:23:17,840 --> 00:23:19,840
in this case the expression is pretty

566
00:23:19,840 --> 00:23:21,039
simple

567
00:23:21,039 --> 00:23:22,880
it will read four variables for the

568
00:23:22,880 --> 00:23:23,840
memory

569
00:23:23,840 --> 00:23:25,520
for cells

570
00:23:25,520 --> 00:23:28,559
and two of them are concrete so a1 and

571
00:23:28,559 --> 00:23:31,200
a3 and those only have one solution

572
00:23:31,200 --> 00:23:35,120
while two of them a2 and a4 are symbolic

573
00:23:35,120 --> 00:23:38,159
and both depend on the symbolic variable

574
00:23:38,159 --> 00:23:40,720
workspace 14.

575
00:23:40,720 --> 00:23:43,200
workspace 14 is an integer symbolic

576
00:23:43,200 --> 00:23:44,640
variable

577
00:23:44,640 --> 00:23:45,360
so

578
00:23:45,360 --> 00:23:47,520
it will have 2 to the power of 32

579
00:23:47,520 --> 00:23:48,960
solutions

580
00:23:48,960 --> 00:23:52,240
and you can imagine how this is not what

581
00:23:52,240 --> 00:23:54,400
we want to do we don't want to execute

582
00:23:54,400 --> 00:23:57,120
to the to the 32 instructions

583
00:23:57,120 --> 00:24:00,559
or generate 2-32 branches

584
00:24:00,559 --> 00:24:01,919
but

585
00:24:01,919 --> 00:24:04,159
the question now becomes can we do

586
00:24:04,159 --> 00:24:06,240
better than this

587
00:24:06,240 --> 00:24:10,080
and our answer is that yes we can

588
00:24:10,080 --> 00:24:12,640
and the optimization that we introduce

589
00:24:12,640 --> 00:24:15,200
are two the first one is the concept of

590
00:24:15,200 --> 00:24:16,799
observers

591
00:24:16,799 --> 00:24:19,679
we strategically introduce some observer

592
00:24:19,679 --> 00:24:22,880
variables into the z3 expressions in

593
00:24:22,880 --> 00:24:24,640
order to make the constraint solving

594
00:24:24,640 --> 00:24:26,400
more manageable

595
00:24:26,400 --> 00:24:28,480
an observer variables is essentially an

596
00:24:28,480 --> 00:24:30,320
intermediate variable

597
00:24:30,320 --> 00:24:32,880
that will hide a sub-expression

598
00:24:32,880 --> 00:24:35,360
and observe its value throughout the

599
00:24:35,360 --> 00:24:37,919
execution

600
00:24:37,919 --> 00:24:40,320
looking at the cell a4 the expression

601
00:24:40,320 --> 00:24:42,720
that is now contained in that cell is

602
00:24:42,720 --> 00:24:47,360
workspace 14 greater than 390 plus 84

603
00:24:47,360 --> 00:24:50,000
which is then a boolean sub expression

604
00:24:50,000 --> 00:24:54,159
workspace 14 within 390 plus a concrete

605
00:24:54,159 --> 00:24:56,159
integer 84.

606
00:24:56,159 --> 00:24:57,440
however

607
00:24:57,440 --> 00:24:59,679
when we are symbolically executing the

608
00:24:59,679 --> 00:25:00,720
sample

609
00:25:00,720 --> 00:25:03,600
and we want to query all the possible

610
00:25:03,600 --> 00:25:07,600
models associated with this cell

611
00:25:07,600 --> 00:25:09,919
what we will get in this case is all the

612
00:25:09,919 --> 00:25:11,760
models associated with the symbolic

613
00:25:11,760 --> 00:25:12,799
variable

614
00:25:12,799 --> 00:25:14,880
workspace 14

615
00:25:14,880 --> 00:25:17,039
but what we really need are only the two

616
00:25:17,039 --> 00:25:21,120
models associated with the true or false

617
00:25:21,120 --> 00:25:25,360
solutions of the boolean sub expression

618
00:25:25,360 --> 00:25:27,520
what we can do is introduce an observer

619
00:25:27,520 --> 00:25:29,279
variable which is going to be equal to

620
00:25:29,279 --> 00:25:34,080
workspace 14 greater than 390.

621
00:25:34,080 --> 00:25:37,200
thus the value in the cell a4 will now

622
00:25:37,200 --> 00:25:39,840
be observer plus 84.

623
00:25:39,840 --> 00:25:41,840
and now the three we're perfectly

624
00:25:41,840 --> 00:25:44,159
understand that this expression can have

625
00:25:44,159 --> 00:25:46,559
at most two solution and we will be able

626
00:25:46,559 --> 00:25:49,520
to query the models and continue with

627
00:25:49,520 --> 00:25:51,760
the symbolic execution without an

628
00:25:51,760 --> 00:25:55,240
additional overhead

629
00:25:56,000 --> 00:25:58,799
second optimization that we introduced

630
00:25:58,799 --> 00:26:01,200
is called smart concretization

631
00:26:01,200 --> 00:26:03,440
so the problem here is that even when

632
00:26:03,440 --> 00:26:06,159
introducing the concept of observers

633
00:26:06,159 --> 00:26:08,720
we will still have many solutions

634
00:26:08,720 --> 00:26:12,480
associated with every symbolic variable

635
00:26:12,480 --> 00:26:15,600
what we can do however when solving and

636
00:26:15,600 --> 00:26:18,159
concretizing an expression

637
00:26:18,159 --> 00:26:20,559
is to filter the possible complete

638
00:26:20,559 --> 00:26:23,360
values considering the excel for

639
00:26:23,360 --> 00:26:25,760
grammars we already know which variables

640
00:26:25,760 --> 00:26:28,799
which values are correct or incorrect

641
00:26:28,799 --> 00:26:30,400
and we can then use the excel for

642
00:26:30,400 --> 00:26:33,440
grammar as an oracle in order to filter

643
00:26:33,440 --> 00:26:35,840
these values and mark those that are

644
00:26:35,840 --> 00:26:37,120
invalid

645
00:26:37,120 --> 00:26:39,039
while only considering

646
00:26:39,039 --> 00:26:41,440
the valid expressions

647
00:26:41,440 --> 00:26:44,080
so in this case we filter out all of the

648
00:26:44,080 --> 00:26:46,400
values that are all invalid

649
00:26:46,400 --> 00:26:49,200
and we will have only the halt formula

650
00:26:49,200 --> 00:26:50,799
which is going to be written to the cell

651
00:26:50,799 --> 00:26:53,600
a6 as a concrete formula before

652
00:26:53,600 --> 00:26:58,000
continuing with this execution

653
00:26:59,679 --> 00:27:02,400
now that we have seen some examples and

654
00:27:02,400 --> 00:27:04,880
how the solver backhand works

655
00:27:04,880 --> 00:27:06,559
let's have a look at how this works in

656
00:27:06,559 --> 00:27:08,400
practice so let's have a look at the

657
00:27:08,400 --> 00:27:11,840
malware sample analysis

658
00:27:12,080 --> 00:27:13,360
this sample

659
00:27:13,360 --> 00:27:16,159
is a sample which was observed

660
00:27:16,159 --> 00:27:17,679
during the last three months and

661
00:27:17,679 --> 00:27:20,320
reported during the last three months it

662
00:27:20,320 --> 00:27:23,520
is a fairly complex sample composed of

663
00:27:23,520 --> 00:27:26,320
multiple stages and 2d obfuscation

664
00:27:26,320 --> 00:27:27,440
routines

665
00:27:27,440 --> 00:27:29,120
what you can see in red in the

666
00:27:29,120 --> 00:27:31,520
counterflow graph are the errored or

667
00:27:31,520 --> 00:27:33,279
pruned branches due to our

668
00:27:33,279 --> 00:27:35,360
concretization

669
00:27:35,360 --> 00:27:36,799
strategy

670
00:27:36,799 --> 00:27:39,279
while what you can see in green

671
00:27:39,279 --> 00:27:41,360
is the symbolic payload which are all

672
00:27:41,360 --> 00:27:43,120
those cells

673
00:27:43,120 --> 00:27:45,279
that depends on environment variables

674
00:27:45,279 --> 00:27:47,279
and that we need to concretize when

675
00:27:47,279 --> 00:27:49,440
executing them in order to correctly

676
00:27:49,440 --> 00:27:52,480
execute the sample

677
00:27:52,559 --> 00:27:54,799
this sample we start executing from the

678
00:27:54,799 --> 00:27:56,799
defuscation routine 1

679
00:27:56,799 --> 00:27:59,120
which implements a simple transposition

680
00:27:59,120 --> 00:28:01,520
cipher which is used to obfuscate only

681
00:28:01,520 --> 00:28:03,919
the first stage

682
00:28:03,919 --> 00:28:04,799
this

683
00:28:04,799 --> 00:28:05,840
cipher

684
00:28:05,840 --> 00:28:08,159
will loop through all the payloads and

685
00:28:08,159 --> 00:28:10,000
through all the characters

686
00:28:10,000 --> 00:28:13,600
and generate from the obfuscated

687
00:28:13,600 --> 00:28:15,679
payload

688
00:28:15,679 --> 00:28:18,559
obfuscated payload for the stage one

689
00:28:18,559 --> 00:28:21,520
this looks something like this

690
00:28:21,520 --> 00:28:24,240
the malware sample we simply rearrange

691
00:28:24,240 --> 00:28:26,159
some values from memory

692
00:28:26,159 --> 00:28:27,919
and thus generated the obfuscated

693
00:28:27,919 --> 00:28:30,000
payload

694
00:28:30,000 --> 00:28:31,600
after the obfuscating the payload it

695
00:28:31,600 --> 00:28:34,240
will start executing stage 1 which is a

696
00:28:34,240 --> 00:28:36,159
simple stage that only spawns a new

697
00:28:36,159 --> 00:28:38,320
process in order

698
00:28:38,320 --> 00:28:40,720
as innovation techniques in order to

699
00:28:40,720 --> 00:28:43,600
confuse static and dynamic analysis and

700
00:28:43,600 --> 00:28:45,919
it will initialize the deposition of the

701
00:28:45,919 --> 00:28:48,640
next stage

702
00:28:49,600 --> 00:28:52,080
then we will execute the obfuscation

703
00:28:52,080 --> 00:28:54,080
routine 2 which is slightly different

704
00:28:54,080 --> 00:28:55,200
from what we have seen in the

705
00:28:55,200 --> 00:28:56,960
obfuscation routine 1

706
00:28:56,960 --> 00:28:59,039
and in this case is an implementation of

707
00:28:59,039 --> 00:29:01,760
pigeon ear cipher which is still fairly

708
00:29:01,760 --> 00:29:03,840
simple this is

709
00:29:03,840 --> 00:29:06,559
used with different decryption keys in

710
00:29:06,559 --> 00:29:08,799
order to obfuscate the

711
00:29:08,799 --> 00:29:11,279
second third and fourth stage of the

712
00:29:11,279 --> 00:29:14,240
malware execution

713
00:29:14,480 --> 00:29:17,440
the virginia cipher will start from the

714
00:29:17,440 --> 00:29:19,919
obfuscated version of the payload

715
00:29:19,919 --> 00:29:22,880
shift it considering the decryption key

716
00:29:22,880 --> 00:29:24,840
and finally generate the obfuscated

717
00:29:24,840 --> 00:29:27,840
payload so after the obfuscation we will

718
00:29:27,840 --> 00:29:29,760
execute stage 2

719
00:29:29,760 --> 00:29:32,320
which will write 5 characters of the

720
00:29:32,320 --> 00:29:34,240
final decryption key and these

721
00:29:34,240 --> 00:29:36,640
characters are generated using different

722
00:29:36,640 --> 00:29:38,320
evasion techniques

723
00:29:38,320 --> 00:29:40,880
for example the modeler will check for

724
00:29:40,880 --> 00:29:43,840
alternate data streams or adts

725
00:29:43,840 --> 00:29:45,360
it will check some environment

726
00:29:45,360 --> 00:29:46,799
configuration

727
00:29:46,799 --> 00:29:50,159
or the consistency of the system clock

728
00:29:50,159 --> 00:29:52,640
what is interesting to note here

729
00:29:52,640 --> 00:29:54,559
is that the malware will not simply

730
00:29:54,559 --> 00:29:57,760
abort execution if these values are not

731
00:29:57,760 --> 00:30:00,159
what what it is expecting to see

732
00:30:00,159 --> 00:30:02,559
but it will instead de-obfuscate

733
00:30:02,559 --> 00:30:04,320
incorrectly

734
00:30:04,320 --> 00:30:06,320
and this is why symbolic execution is

735
00:30:06,320 --> 00:30:09,120
interesting

736
00:30:09,120 --> 00:30:09,919
so

737
00:30:09,919 --> 00:30:11,200
the second time that we run the

738
00:30:11,200 --> 00:30:13,919
application routine 2

739
00:30:13,919 --> 00:30:16,080
you can see as in the as

740
00:30:16,080 --> 00:30:17,760
in the description key there are some

741
00:30:17,760 --> 00:30:19,600
symbolic values

742
00:30:19,600 --> 00:30:22,000
and those the decrypted payload is going

743
00:30:22,000 --> 00:30:24,080
to be symbolic

744
00:30:24,080 --> 00:30:27,039
and indeed you can see in the control

745
00:30:27,039 --> 00:30:29,279
photograph for the stage 3

746
00:30:29,279 --> 00:30:31,440
that most of the formulas that we

747
00:30:31,440 --> 00:30:32,720
execute

748
00:30:32,720 --> 00:30:35,200
will have to be concretized

749
00:30:35,200 --> 00:30:36,880
stage three

750
00:30:36,880 --> 00:30:40,399
is the symbolic stage

751
00:30:40,559 --> 00:30:43,120
and will write the sixth and seventh

752
00:30:43,120 --> 00:30:46,799
characters of the final decryption key

753
00:30:46,799 --> 00:30:48,399
in order to generate these characters

754
00:30:48,399 --> 00:30:51,120
the malware will execute some more

755
00:30:51,120 --> 00:30:53,600
evasion techniques like checking for the

756
00:30:53,600 --> 00:30:55,919
file system implementation or checking

757
00:30:55,919 --> 00:31:00,000
for the excel micro security settings

758
00:31:00,880 --> 00:31:03,120
we will then run again the deposition

759
00:31:03,120 --> 00:31:05,919
routine 2 before starting to execute the

760
00:31:05,919 --> 00:31:08,480
final stage of the monitor

761
00:31:08,480 --> 00:31:12,640
this final stage is the infection stage

762
00:31:12,640 --> 00:31:15,600
the malware at this stage will download

763
00:31:15,600 --> 00:31:19,840
a malicious windows dll and register it

764
00:31:19,840 --> 00:31:22,960
using the rundlll.exe

765
00:31:22,960 --> 00:31:25,039
executable

766
00:31:25,039 --> 00:31:28,080
it is interesting to note how first as

767
00:31:28,080 --> 00:31:31,039
you can see in the graph again this

768
00:31:31,039 --> 00:31:33,200
payload is completely symbolic

769
00:31:33,200 --> 00:31:35,519
we will need to compromise every formula

770
00:31:35,519 --> 00:31:37,760
before executing it

771
00:31:37,760 --> 00:31:40,559
and as you can see from the branch

772
00:31:40,559 --> 00:31:42,960
in this specific sample if the first

773
00:31:42,960 --> 00:31:44,640
download fails

774
00:31:44,640 --> 00:31:46,880
the sample is configured in order to

775
00:31:46,880 --> 00:31:49,679
access a second endpoint in order to

776
00:31:49,679 --> 00:31:53,519
download the malicious dll

777
00:31:54,320 --> 00:31:57,519
now you might be wondering okay then but

778
00:31:57,519 --> 00:31:59,840
why do i need to de-obfuscate this

779
00:31:59,840 --> 00:32:01,679
sample

780
00:32:01,679 --> 00:32:04,320
and the answer is that

781
00:32:04,320 --> 00:32:06,559
we did the obfuscation we are able to

782
00:32:06,559 --> 00:32:09,760
extract some indicators of compromise

783
00:32:09,760 --> 00:32:11,600
that would otherwise be impossible to

784
00:32:11,600 --> 00:32:14,480
extract

785
00:32:14,480 --> 00:32:16,000
some examples of indicators of

786
00:32:16,000 --> 00:32:18,000
compromise are

787
00:32:18,000 --> 00:32:19,600
files that are accessed during the

788
00:32:19,600 --> 00:32:22,000
execution other strings or other

789
00:32:22,000 --> 00:32:23,840
executables are used

790
00:32:23,840 --> 00:32:26,720
or urls that are accessed in order to

791
00:32:26,720 --> 00:32:29,519
download the payload or to download

792
00:32:29,519 --> 00:32:33,360
other files that are used by the modeler

793
00:32:33,760 --> 00:32:36,399
so we will now look at our evaluation

794
00:32:36,399 --> 00:32:39,120
and comparison with other similar tools

795
00:32:39,120 --> 00:32:40,799
and techniques

796
00:32:40,799 --> 00:32:43,440
for the application of excel for samples

797
00:32:43,440 --> 00:32:46,080
first in order to evaluate our tool

798
00:32:46,080 --> 00:32:49,440
we collected and analyzed roughly 4 700

799
00:32:49,440 --> 00:32:52,559
samples which were reported and observed

800
00:32:52,559 --> 00:32:54,320
in the last six months

801
00:32:54,320 --> 00:32:56,919
we classified these samples in roughly

802
00:32:56,919 --> 00:33:01,279
480 clusters of distinct behavior

803
00:33:01,279 --> 00:33:03,519
many of these samples still have a very

804
00:33:03,519 --> 00:33:05,840
low detection rate in virus total which

805
00:33:05,840 --> 00:33:08,320
we think is interesting and

806
00:33:08,320 --> 00:33:12,240
many are still undetected

807
00:33:12,799 --> 00:33:14,960
what you can see in this table is the

808
00:33:14,960 --> 00:33:16,640
number of samples

809
00:33:16,640 --> 00:33:17,679
that

810
00:33:17,679 --> 00:33:20,559
can be correctly obfuscated using a

811
00:33:20,559 --> 00:33:23,360
concrete approach or a symbolic approach

812
00:33:23,360 --> 00:33:25,039
you can see how using a concrete

813
00:33:25,039 --> 00:33:26,399
obfuscator

814
00:33:26,399 --> 00:33:29,039
we can only de-obfuscate correctly

815
00:33:29,039 --> 00:33:33,039
a little more than 1800 samples or 320

816
00:33:33,039 --> 00:33:34,240
clusters

817
00:33:34,240 --> 00:33:36,640
while using simvaxcell we are able to

818
00:33:36,640 --> 00:33:39,200
duplicate correctly more than 3 000

819
00:33:39,200 --> 00:33:43,279
samples and more than 400 clusters

820
00:33:43,279 --> 00:33:45,760
however now if you look at the symbolic

821
00:33:45,760 --> 00:33:47,279
samples alone

822
00:33:47,279 --> 00:33:49,679
which are the focus of our research and

823
00:33:49,679 --> 00:33:52,080
of our tool you can see how with the

824
00:33:52,080 --> 00:33:54,159
concrete obfuscator you are able to

825
00:33:54,159 --> 00:33:56,799
duplicate correctly only very few

826
00:33:56,799 --> 00:33:59,679
symbolic samples and symbolic clusters

827
00:33:59,679 --> 00:34:02,080
while with simp excel you are able to

828
00:34:02,080 --> 00:34:05,120
duplicate correctly more than 170

829
00:34:05,120 --> 00:34:07,679
symbolic samples and 91 symbolic

830
00:34:07,679 --> 00:34:11,760
clusters of distinct behaviors

831
00:34:11,918 --> 00:34:12,960
so now

832
00:34:12,960 --> 00:34:14,480
as a conclusion

833
00:34:14,480 --> 00:34:17,199
except for macros are still an ongoing

834
00:34:17,199 --> 00:34:19,520
and evolving threat they are very

835
00:34:19,520 --> 00:34:21,599
difficult to analyze and to detect

836
00:34:21,599 --> 00:34:24,399
accurately due to the set of evasion

837
00:34:24,399 --> 00:34:27,040
techniques which are used in the modern

838
00:34:27,040 --> 00:34:29,760
waves of this kind of malwares

839
00:34:29,760 --> 00:34:32,960
we believe the symbolic execution

840
00:34:32,960 --> 00:34:34,560
provides

841
00:34:34,560 --> 00:34:37,440
a way to analyze the samples

842
00:34:37,440 --> 00:34:40,079
which would otherwise be impossible or

843
00:34:40,079 --> 00:34:42,399
very hard to deal with skate using a

844
00:34:42,399 --> 00:34:45,280
concrete diaper skater this would allow

845
00:34:45,280 --> 00:34:46,480
to

846
00:34:46,480 --> 00:34:48,719
accurately the obfuscated samples and

847
00:34:48,719 --> 00:34:51,599
therefore accurate classify the samples

848
00:34:51,599 --> 00:34:54,560
as benign or malicious

849
00:34:54,560 --> 00:34:56,960
so thank you for your attention this is

850
00:34:56,960 --> 00:34:58,640
it for this talk

851
00:34:58,640 --> 00:35:01,200
if you have any questions or comments we

852
00:35:01,200 --> 00:35:03,280
will be here and very happy to answer

853
00:35:03,280 --> 00:35:05,839
them

