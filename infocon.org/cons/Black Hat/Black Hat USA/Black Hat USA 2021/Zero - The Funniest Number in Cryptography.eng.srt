1
00:00:01,130 --> 00:00:14,700
[Music]

2
00:00:15,120 --> 00:00:18,560
hi i am happy to share with you my fun

3
00:00:18,560 --> 00:00:21,600
uh journey exploring zero number in uh

4
00:00:21,600 --> 00:00:23,279
cryptography

5
00:00:23,279 --> 00:00:24,960
uh it's uh

6
00:00:24,960 --> 00:00:26,720
it's the i think that is the funniest

7
00:00:26,720 --> 00:00:29,599
number in cryptography and uh i hope

8
00:00:29,599 --> 00:00:32,079
that you will enjoy

9
00:00:32,079 --> 00:00:33,920
my journey

10
00:00:33,920 --> 00:00:35,040
so

11
00:00:35,040 --> 00:00:38,320
uh the agenda is we will introduce a few

12
00:00:38,320 --> 00:00:41,200
terminology and

13
00:00:41,200 --> 00:00:44,239
after that we will describe a high level

14
00:00:44,239 --> 00:00:45,600
attack idea

15
00:00:45,600 --> 00:00:48,000
for instance like zero signature or

16
00:00:48,000 --> 00:00:50,160
splitting zero attack

17
00:00:50,160 --> 00:00:52,079
this talk is

18
00:00:52,079 --> 00:00:55,920
crypt purely cryptographic talk so it is

19
00:00:55,920 --> 00:00:57,440
technical

20
00:00:57,440 --> 00:01:00,879
however i i'd like to get across the

21
00:01:00,879 --> 00:01:03,680
the main ideas of the attack

22
00:01:03,680 --> 00:01:07,920
so we we i want you to

23
00:01:07,920 --> 00:01:09,760
get attention in the first 10 minutes

24
00:01:09,760 --> 00:01:12,159
and after that you can get back to sleep

25
00:01:12,159 --> 00:01:14,240
uh the rest for the rest of the talk i

26
00:01:14,240 --> 00:01:16,080
will only describe

27
00:01:16,080 --> 00:01:17,840
the the detail

28
00:01:17,840 --> 00:01:20,240
of the attack

29
00:01:20,240 --> 00:01:22,720
but the the high level idea of the

30
00:01:22,720 --> 00:01:24,479
attack is simple

31
00:01:24,479 --> 00:01:25,439
and

32
00:01:25,439 --> 00:01:28,000
i hope that i can get across

33
00:01:28,000 --> 00:01:30,960
those attack ideas so let's introduce a

34
00:01:30,960 --> 00:01:32,000
few

35
00:01:32,000 --> 00:01:34,640
basic terminology that we will use in

36
00:01:34,640 --> 00:01:35,439
this

37
00:01:35,439 --> 00:01:36,880
in this talk

38
00:01:36,880 --> 00:01:38,640
um

39
00:01:38,640 --> 00:01:41,759
so the the talk is about zero related

40
00:01:41,759 --> 00:01:42,960
bugs

41
00:01:42,960 --> 00:01:44,159
um

42
00:01:44,159 --> 00:01:47,759
in both the standard graph in and in all

43
00:01:47,759 --> 00:01:50,799
four crypto libraries that implement the

44
00:01:50,799 --> 00:01:54,960
standard craft including uh ethereum

45
00:01:54,960 --> 00:01:56,399
hiromi

46
00:01:56,399 --> 00:02:00,320
miguel and supranational

47
00:02:00,320 --> 00:02:03,600
so there are two types of box here that

48
00:02:03,600 --> 00:02:06,159
i will discuss the first one

49
00:02:06,159 --> 00:02:09,119
is the implementation bug where

50
00:02:09,119 --> 00:02:11,200
the libraries don't

51
00:02:11,200 --> 00:02:14,720
follow the security check that mandated

52
00:02:14,720 --> 00:02:16,480
by the standard

53
00:02:16,480 --> 00:02:18,879
the second

54
00:02:18,879 --> 00:02:22,239
bug is the standard graph box and it's

55
00:02:22,239 --> 00:02:24,720
pretty serious because all four

56
00:02:24,720 --> 00:02:28,000
libraries will follow the standard

57
00:02:28,000 --> 00:02:28,879
and

58
00:02:28,879 --> 00:02:30,720
as the consequence

59
00:02:30,720 --> 00:02:36,840
of both of them will have the same bug

60
00:02:37,280 --> 00:02:39,840
so this this talk focus on signature

61
00:02:39,840 --> 00:02:41,280
verification

62
00:02:41,280 --> 00:02:43,040
um

63
00:02:43,040 --> 00:02:44,160
we

64
00:02:44,160 --> 00:02:47,040
for the signer will have the the private

65
00:02:47,040 --> 00:02:47,840
key

66
00:02:47,840 --> 00:02:50,879
which is denoted as low kx

67
00:02:50,879 --> 00:02:52,000
and

68
00:02:52,000 --> 00:02:54,480
public key is the uppercase x and the

69
00:02:54,480 --> 00:02:56,000
message m

70
00:02:56,000 --> 00:02:57,360
so

71
00:02:57,360 --> 00:02:59,920
we will we will not focus on the signing

72
00:02:59,920 --> 00:03:02,319
operation instead we will focus on

73
00:03:02,319 --> 00:03:04,560
signature verification

74
00:03:04,560 --> 00:03:06,400
signature verification is

75
00:03:06,400 --> 00:03:10,000
pretty complicated in our case but the

76
00:03:10,000 --> 00:03:11,840
the high level idea is pretty simple

77
00:03:11,840 --> 00:03:14,159
essentially it to check a certain

78
00:03:14,159 --> 00:03:16,480
function equals to zero

79
00:03:16,480 --> 00:03:18,800
and our focus

80
00:03:18,800 --> 00:03:21,760
is the number zero as we'll see uh

81
00:03:21,760 --> 00:03:23,440
shortly

82
00:03:23,440 --> 00:03:25,519
so what's up with zero right

83
00:03:25,519 --> 00:03:27,040
uh you know like in signature

84
00:03:27,040 --> 00:03:29,280
verification essentially we check

85
00:03:29,280 --> 00:03:30,959
whether a certain function equals to

86
00:03:30,959 --> 00:03:34,159
zero however as you see

87
00:03:34,159 --> 00:03:37,360
uh and you all know and love that you

88
00:03:37,360 --> 00:03:39,440
know whenever you multiply number zero

89
00:03:39,440 --> 00:03:41,840
with any number you get back zero it

90
00:03:41,840 --> 00:03:44,799
doesn't depend on the number at all

91
00:03:44,799 --> 00:03:47,760
and this is how we will exploit

92
00:03:47,760 --> 00:03:50,879
this uh very naive

93
00:03:50,879 --> 00:03:52,239
property

94
00:03:52,239 --> 00:03:55,760
to to attack uh crypto libraries and

95
00:03:55,760 --> 00:03:59,120
standard draft itself

96
00:03:59,519 --> 00:04:02,319
uh another concept that i'd like to

97
00:04:02,319 --> 00:04:03,519
introduce

98
00:04:03,519 --> 00:04:07,120
is called aggregate signature

99
00:04:07,120 --> 00:04:09,760
uh if if you've been working in

100
00:04:09,760 --> 00:04:12,080
traditional cryptography you you rarely

101
00:04:12,080 --> 00:04:14,480
seen this concept but it's pretty

102
00:04:14,480 --> 00:04:17,440
popular in cryptocurrency

103
00:04:17,440 --> 00:04:18,560
because

104
00:04:18,560 --> 00:04:20,798
because it has a very attractive

105
00:04:20,798 --> 00:04:23,120
property think about that you have to

106
00:04:23,120 --> 00:04:24,000
send

107
00:04:24,000 --> 00:04:27,040
millions of signature

108
00:04:27,040 --> 00:04:29,680
and you have to fi verify millions of

109
00:04:29,680 --> 00:04:30,880
signature

110
00:04:30,880 --> 00:04:31,759
uh

111
00:04:31,759 --> 00:04:34,880
so it it costs bandwidth and it costs

112
00:04:34,880 --> 00:04:36,479
cpu time

113
00:04:36,479 --> 00:04:38,960
uh instead in the aggregate signature

114
00:04:38,960 --> 00:04:41,840
scheme we will have one single alligator

115
00:04:41,840 --> 00:04:43,520
that will

116
00:04:43,520 --> 00:04:45,840
aggregate millions of signature into one

117
00:04:45,840 --> 00:04:48,320
short signature which in our case is

118
00:04:48,320 --> 00:04:49,199
only

119
00:04:49,199 --> 00:04:51,840
about 96 bytes

120
00:04:51,840 --> 00:04:54,320
and the verifier instead of verifying

121
00:04:54,320 --> 00:04:56,320
millions of signatures is only verified

122
00:04:56,320 --> 00:04:59,360
one single signature

123
00:04:59,360 --> 00:05:03,280
so this the uh but you know like any

124
00:05:03,280 --> 00:05:07,280
new crypto construction has weaknesses

125
00:05:07,280 --> 00:05:09,120
and it's not

126
00:05:09,120 --> 00:05:10,400
the the topic

127
00:05:10,400 --> 00:05:13,759
of this talk but we will try to exploit

128
00:05:13,759 --> 00:05:17,280
a certain box in aggregate signature

129
00:05:17,280 --> 00:05:18,880
um

130
00:05:18,880 --> 00:05:20,960
as as i mentioned above you know the

131
00:05:20,960 --> 00:05:24,720
standard trap was aware of the danger of

132
00:05:24,720 --> 00:05:25,840
uh

133
00:05:25,840 --> 00:05:29,680
of zero signature therefore

134
00:05:29,680 --> 00:05:33,039
therefore they they request implementers

135
00:05:33,039 --> 00:05:34,639
to check

136
00:05:34,639 --> 00:05:38,160
zero signature and zero public key

137
00:05:38,160 --> 00:05:38,960
and

138
00:05:38,960 --> 00:05:40,000
this is the

139
00:05:40,000 --> 00:05:42,560
as an attacker we will try to bypass

140
00:05:42,560 --> 00:05:43,680
that check

141
00:05:43,680 --> 00:05:46,400
so that's that one type of

142
00:05:46,400 --> 00:05:48,639
bug that we will discuss in details

143
00:05:48,639 --> 00:05:50,639
later

144
00:05:50,639 --> 00:05:53,520
however like the standard draft missed

145
00:05:53,520 --> 00:05:55,440
an important case

146
00:05:55,440 --> 00:05:56,800
where

147
00:05:56,800 --> 00:05:59,280
you know even though

148
00:05:59,280 --> 00:06:01,840
the each signature or public key is

149
00:06:01,840 --> 00:06:04,240
different from zero there's some it

150
00:06:04,240 --> 00:06:06,479
might be zero right for instance think

151
00:06:06,479 --> 00:06:09,280
about a very simple case when you have

152
00:06:09,280 --> 00:06:11,039
the first signature is one and the

153
00:06:11,039 --> 00:06:13,199
second signature is minus one then the

154
00:06:13,199 --> 00:06:16,639
sum is zero and you can still uh bypass

155
00:06:16,639 --> 00:06:19,039
the verification just by this very

156
00:06:19,039 --> 00:06:21,039
simple observation

157
00:06:21,039 --> 00:06:21,919
uh

158
00:06:21,919 --> 00:06:24,880
so okay now now basically you can go

159
00:06:24,880 --> 00:06:27,680
back to sleep the the rest of the talk

160
00:06:27,680 --> 00:06:29,120
is more

161
00:06:29,120 --> 00:06:30,960
or less

162
00:06:30,960 --> 00:06:31,840
this

163
00:06:31,840 --> 00:06:34,960
slide but it fill in the details like

164
00:06:34,960 --> 00:06:35,840
how

165
00:06:35,840 --> 00:06:39,039
it actually works from the mathematical

166
00:06:39,039 --> 00:06:42,160
point of view there will be some demos

167
00:06:42,160 --> 00:06:46,000
but if you can understand this light

168
00:06:46,000 --> 00:06:50,000
then then i'm already really happy

169
00:06:50,000 --> 00:06:50,960
okay

170
00:06:50,960 --> 00:06:53,840
so a little curve i will have only 30

171
00:06:53,840 --> 00:06:56,800
seconds to introduce elliptic curve so

172
00:06:56,800 --> 00:06:58,960
so the elliptic curve as you can see is

173
00:06:58,960 --> 00:07:00,400
the blue lines

174
00:07:00,400 --> 00:07:01,599
on the graph

175
00:07:01,599 --> 00:07:02,479
and

176
00:07:02,479 --> 00:07:04,560
to add two points

177
00:07:04,560 --> 00:07:07,919
p and q we draw a lines through

178
00:07:07,919 --> 00:07:10,960
the pawns p and q and it will cut the

179
00:07:10,960 --> 00:07:14,639
elliptic curve at another point r prime

180
00:07:14,639 --> 00:07:17,520
but that point is not a sum of uh p and

181
00:07:17,520 --> 00:07:21,520
q instead is the negative is the sum of

182
00:07:21,520 --> 00:07:24,080
p and q

183
00:07:26,160 --> 00:07:27,280
for for

184
00:07:27,280 --> 00:07:29,280
for the purpose of this talk we're not

185
00:07:29,280 --> 00:07:30,880
going to discuss

186
00:07:30,880 --> 00:07:32,960
how the addition

187
00:07:32,960 --> 00:07:36,560
is computed or you know like complicated

188
00:07:36,560 --> 00:07:39,840
math all we need to know is

189
00:07:39,840 --> 00:07:42,319
addition operations

190
00:07:42,319 --> 00:07:44,639
so essentially you can think of elliptic

191
00:07:44,639 --> 00:07:45,520
curve

192
00:07:45,520 --> 00:07:47,840
somehow magically defined addition

193
00:07:47,840 --> 00:07:49,039
operation

194
00:07:49,039 --> 00:07:51,280
and it has a zero point

195
00:07:51,280 --> 00:07:53,199
uh the nice thing about zero point is

196
00:07:53,199 --> 00:07:56,400
whenever you add zero point two up to

197
00:07:56,400 --> 00:07:59,440
any point p then you will get back uh

198
00:07:59,440 --> 00:08:01,759
the point p

199
00:08:01,759 --> 00:08:04,639
in in our case uh we

200
00:08:04,639 --> 00:08:06,720
we defined uh

201
00:08:06,720 --> 00:08:09,599
and we fix uh a base point g on the

202
00:08:09,599 --> 00:08:10,879
generator

203
00:08:10,879 --> 00:08:14,160
and when we add g together n times

204
00:08:14,160 --> 00:08:17,039
then we will get back zero and n is

205
00:08:17,039 --> 00:08:19,440
called the order of the point

206
00:08:19,440 --> 00:08:21,759
uh essentially

207
00:08:21,759 --> 00:08:23,680
all we need to remember

208
00:08:23,680 --> 00:08:24,560
is

209
00:08:24,560 --> 00:08:26,240
elliptical defined the addition

210
00:08:26,240 --> 00:08:29,599
operation and it defined the zero point

211
00:08:29,599 --> 00:08:31,520
uh there is we we don't need anything

212
00:08:31,520 --> 00:08:34,880
else more complicated that than that

213
00:08:34,880 --> 00:08:36,958
all right

214
00:08:36,958 --> 00:08:40,479
so another concept that we will

215
00:08:40,479 --> 00:08:42,880
talk about is called pairing

216
00:08:42,880 --> 00:08:45,600
so pairing is essentially is just a maps

217
00:08:45,600 --> 00:08:48,480
from two point p and q

218
00:08:48,480 --> 00:08:51,040
uh to a number

219
00:08:51,040 --> 00:08:53,839
technically it's a match from two group

220
00:08:53,839 --> 00:08:55,440
to a finite field

221
00:08:55,440 --> 00:08:56,240
but

222
00:08:56,240 --> 00:08:58,640
for the purpose of this talk

223
00:08:58,640 --> 00:09:02,640
that technical details is not important

224
00:09:02,640 --> 00:09:03,920
what we

225
00:09:03,920 --> 00:09:07,360
need to remember is it maps two points

226
00:09:07,360 --> 00:09:08,480
to a number

227
00:09:08,480 --> 00:09:09,279
and

228
00:09:09,279 --> 00:09:10,320
that's it

229
00:09:10,320 --> 00:09:13,600
so pairing has a few nice property

230
00:09:13,600 --> 00:09:16,320
uh which is called bilinear property

231
00:09:16,320 --> 00:09:18,399
that we will use over and over again

232
00:09:18,399 --> 00:09:21,040
whenever you look at pairing base

233
00:09:21,040 --> 00:09:22,399
cryptography

234
00:09:22,399 --> 00:09:25,120
so the first property is if you add two

235
00:09:25,120 --> 00:09:27,360
points on the left hand side

236
00:09:27,360 --> 00:09:29,920
and on the right hand side you will have

237
00:09:29,920 --> 00:09:32,320
the product

238
00:09:32,320 --> 00:09:34,320
of pairings

239
00:09:34,320 --> 00:09:36,880
and the second property is

240
00:09:36,880 --> 00:09:41,040
uh pairing of a times b p and b times q

241
00:09:41,040 --> 00:09:42,480
equals to

242
00:09:42,480 --> 00:09:45,680
pairing of p and q to the power of a

243
00:09:45,680 --> 00:09:46,720
times b

244
00:09:46,720 --> 00:09:50,399
what it means is you can move the

245
00:09:50,399 --> 00:09:53,279
coefficient of the points

246
00:09:53,279 --> 00:09:55,279
to the exponent

247
00:09:55,279 --> 00:09:57,839
and if you look from the right to the

248
00:09:57,839 --> 00:09:58,959
left

249
00:09:58,959 --> 00:10:02,000
it means that you can move the exponent

250
00:10:02,000 --> 00:10:02,959
to

251
00:10:02,959 --> 00:10:06,560
to the coefficient of the point

252
00:10:06,560 --> 00:10:09,440
and using this property you can see that

253
00:10:09,440 --> 00:10:13,360
pairing of a b and b q equals to pairing

254
00:10:13,360 --> 00:10:17,600
of bp and aq and we will use this

255
00:10:17,600 --> 00:10:21,040
property over and over again

256
00:10:21,040 --> 00:10:24,160
in our case pay attention to the edge

257
00:10:24,160 --> 00:10:25,920
case

258
00:10:25,920 --> 00:10:27,120
that

259
00:10:27,120 --> 00:10:28,560
that i

260
00:10:28,560 --> 00:10:30,079
i stressed there

261
00:10:30,079 --> 00:10:32,800
basically the pairing of

262
00:10:32,800 --> 00:10:37,040
uh zero points and arbitrary points is

263
00:10:37,040 --> 00:10:40,399
is one no matter what that point is

264
00:10:40,399 --> 00:10:41,760
uh so

265
00:10:41,760 --> 00:10:44,399
so we will basically exploit this

266
00:10:44,399 --> 00:10:46,320
observation

267
00:10:46,320 --> 00:10:50,000
to for four hour attack

268
00:10:51,440 --> 00:10:55,600
one of the the simplest yet elegant

269
00:10:55,600 --> 00:10:58,399
application of appearing is bls

270
00:10:58,399 --> 00:11:01,440
signature the way it works is simple to

271
00:11:01,440 --> 00:11:05,279
to compute the signature of a message m

272
00:11:05,279 --> 00:11:08,320
all we do is to hash the message m to a

273
00:11:08,320 --> 00:11:09,519
point

274
00:11:09,519 --> 00:11:13,279
on the curve and we multiply

275
00:11:13,279 --> 00:11:15,120
by a number x

276
00:11:15,120 --> 00:11:18,800
and that's it you can't find a sim

277
00:11:18,800 --> 00:11:19,839
simpler

278
00:11:19,839 --> 00:11:21,519
uh signature

279
00:11:21,519 --> 00:11:24,000
than that

280
00:11:24,240 --> 00:11:27,839
so how do we verify uh bls signature

281
00:11:27,839 --> 00:11:30,399
basically to verify the bls signature we

282
00:11:30,399 --> 00:11:32,640
will compute two pairing

283
00:11:32,640 --> 00:11:35,040
uh the the first

284
00:11:35,040 --> 00:11:37,519
one is the pairing of the signature and

285
00:11:37,519 --> 00:11:39,040
the base point g

286
00:11:39,040 --> 00:11:42,079
and on the right hand side is a pairing

287
00:11:42,079 --> 00:11:44,959
of the hash and the public key x

288
00:11:44,959 --> 00:11:46,240
so

289
00:11:46,240 --> 00:11:47,839
why does work

290
00:11:47,839 --> 00:11:50,320
so if you look at the equation you can

291
00:11:50,320 --> 00:11:52,880
see that the signature is the x time

292
00:11:52,880 --> 00:11:54,560
hash right

293
00:11:54,560 --> 00:11:57,440
and you can move the coefficient x to

294
00:11:57,440 --> 00:11:59,519
the exponent you so you move x to the

295
00:11:59,519 --> 00:12:00,639
exponent

296
00:12:00,639 --> 00:12:02,959
and then you move x to the right

297
00:12:02,959 --> 00:12:05,279
component of the pairing and it's

298
00:12:05,279 --> 00:12:06,720
actually just

299
00:12:06,720 --> 00:12:10,600
uh the public key

300
00:12:10,959 --> 00:12:13,600
all right so

301
00:12:13,600 --> 00:12:15,920
for the purpose of this talk we'll pay

302
00:12:15,920 --> 00:12:19,440
attention again on the zero signature

303
00:12:19,440 --> 00:12:22,720
and zero public key so in the in that

304
00:12:22,720 --> 00:12:24,480
edge cage

305
00:12:24,480 --> 00:12:27,600
the pairing of the signature with

306
00:12:27,600 --> 00:12:31,360
the base part always equals to zero

307
00:12:31,360 --> 00:12:34,480
and the pairing of the

308
00:12:34,480 --> 00:12:35,600
message

309
00:12:35,600 --> 00:12:37,279
with zero publicly

310
00:12:37,279 --> 00:12:40,399
also equals to zero what it means is the

311
00:12:40,399 --> 00:12:43,680
signature is valid for all messages

312
00:12:43,680 --> 00:12:46,320
and this this is this is

313
00:12:46,320 --> 00:12:49,040
has a lot of advantage from the attacker

314
00:12:49,040 --> 00:12:50,839
point of view

315
00:12:50,839 --> 00:12:53,680
because because whenever the verifier

316
00:12:53,680 --> 00:12:56,160
verified the signature the verifier

317
00:12:56,160 --> 00:12:58,079
learns nothing

318
00:12:58,079 --> 00:13:00,480
from the verifier point of view whenever

319
00:13:00,480 --> 00:13:02,720
you verify this you want to

320
00:13:02,720 --> 00:13:05,279
to learn something that what message has

321
00:13:05,279 --> 00:13:07,920
been signed but in this case

322
00:13:07,920 --> 00:13:11,440
before and after verification

323
00:13:11,440 --> 00:13:14,320
there is no difference

324
00:13:16,079 --> 00:13:18,160
the the standard graph

325
00:13:18,160 --> 00:13:21,120
was aware of this issue that's why is it

326
00:13:21,120 --> 00:13:23,760
asks all the implementation to check for

327
00:13:23,760 --> 00:13:24,880
for xero

328
00:13:24,880 --> 00:13:28,000
however let's see whether we can bypass

329
00:13:28,000 --> 00:13:31,680
the check in practice

330
00:13:32,000 --> 00:13:34,000
so i i need to describe to you a little

331
00:13:34,000 --> 00:13:36,880
bit more details how

332
00:13:36,880 --> 00:13:38,000
how it

333
00:13:38,000 --> 00:13:40,560
how the points and

334
00:13:40,560 --> 00:13:43,199
uh and by the representation of the

335
00:13:43,199 --> 00:13:44,320
point

336
00:13:44,320 --> 00:13:45,199
so

337
00:13:45,199 --> 00:13:46,399
in

338
00:13:46,399 --> 00:13:48,800
in in the software there is no thing

339
00:13:48,800 --> 00:13:52,000
called points right everything is byte

340
00:13:52,000 --> 00:13:53,199
so

341
00:13:53,199 --> 00:13:56,399
but however there is multiple byte

342
00:13:56,399 --> 00:13:59,120
arrays that map to the same point

343
00:13:59,120 --> 00:14:01,040
and that is fine

344
00:14:01,040 --> 00:14:04,639
from from the signature perspective

345
00:14:04,639 --> 00:14:06,720
what is ethereum

346
00:14:06,720 --> 00:14:09,040
elliptical library does

347
00:14:09,040 --> 00:14:12,880
is it only check the canonical

348
00:14:12,880 --> 00:14:15,360
representation of the point

349
00:14:15,360 --> 00:14:18,399
and it doesn't check all the other

350
00:14:18,399 --> 00:14:19,839
white arrays

351
00:14:19,839 --> 00:14:22,160
so as an attacker

352
00:14:22,160 --> 00:14:24,880
what we does is very simple we just need

353
00:14:24,880 --> 00:14:26,639
to find

354
00:14:26,639 --> 00:14:28,000
a different

355
00:14:28,000 --> 00:14:31,199
by the way presentation of that point

356
00:14:31,199 --> 00:14:32,720
and then

357
00:14:32,720 --> 00:14:35,360
ethereum elliptical library will just

358
00:14:35,360 --> 00:14:37,760
accept it

359
00:14:37,760 --> 00:14:38,480
i

360
00:14:38,480 --> 00:14:42,399
i have a short demo here

361
00:14:42,399 --> 00:14:43,120
so

362
00:14:43,120 --> 00:14:45,360
in this case we have a zero public key

363
00:14:45,360 --> 00:14:47,600
and this is the kinetico presentation we

364
00:14:47,600 --> 00:14:50,000
have zero signature and then we will

365
00:14:50,000 --> 00:14:51,920
generate a random message

366
00:14:51,920 --> 00:14:55,519
and the verify will return true as you

367
00:14:55,519 --> 00:14:59,000
will see shortly

368
00:15:04,079 --> 00:15:08,240
okay so let's continue to bls aggregate

369
00:15:08,240 --> 00:15:09,760
signature

370
00:15:09,760 --> 00:15:12,399
so in the past bls signature is

371
00:15:12,399 --> 00:15:15,120
attractive because it's sharp however

372
00:15:15,120 --> 00:15:17,920
because of advanced cryptanalysis

373
00:15:17,920 --> 00:15:20,320
cryptographer has to increase

374
00:15:20,320 --> 00:15:22,880
security parameters so it's not shot

375
00:15:22,880 --> 00:15:26,560
anymore however bls signature has an

376
00:15:26,560 --> 00:15:28,000
attractive

377
00:15:28,000 --> 00:15:30,320
property it allows

378
00:15:30,320 --> 00:15:32,800
signature aggregation

379
00:15:32,800 --> 00:15:35,120
so the idea is

380
00:15:35,120 --> 00:15:37,199
instead of verifying millions of

381
00:15:37,199 --> 00:15:39,360
signature we will

382
00:15:39,360 --> 00:15:42,639
have an alligator that will aggregate

383
00:15:42,639 --> 00:15:45,759
all of them into one signature and then

384
00:15:45,759 --> 00:15:49,440
we will only verify that signature

385
00:15:49,440 --> 00:15:52,839
that sounds magic right but but it

386
00:15:52,839 --> 00:15:54,880
works and

387
00:15:54,880 --> 00:15:57,120
in our cases

388
00:15:57,120 --> 00:16:00,720
the the verification is to compute

389
00:16:00,720 --> 00:16:01,600
uh

390
00:16:01,600 --> 00:16:04,160
some pairing on the left hand side we

391
00:16:04,160 --> 00:16:06,240
compute a pairing of the signature and

392
00:16:06,240 --> 00:16:07,600
the base point

393
00:16:07,600 --> 00:16:09,600
and the right hand side

394
00:16:09,600 --> 00:16:14,480
is the product of pairing of

395
00:16:14,480 --> 00:16:18,320
hash and public keys

396
00:16:19,120 --> 00:16:19,920
so

397
00:16:19,920 --> 00:16:21,600
how does work

398
00:16:21,600 --> 00:16:22,959
basically

399
00:16:22,959 --> 00:16:25,360
it will use the property that we

400
00:16:25,360 --> 00:16:27,040
mentioned in the

401
00:16:27,040 --> 00:16:29,040
in the parent section

402
00:16:29,040 --> 00:16:30,800
uh the

403
00:16:30,800 --> 00:16:34,160
the first equation we only write

404
00:16:34,160 --> 00:16:36,399
the the definition of

405
00:16:36,399 --> 00:16:38,720
signature right it's the sum of two

406
00:16:38,720 --> 00:16:40,000
signature

407
00:16:40,000 --> 00:16:41,839
and uh

408
00:16:41,839 --> 00:16:44,560
in the second and third equation we move

409
00:16:44,560 --> 00:16:46,320
the coefficient

410
00:16:46,320 --> 00:16:48,560
from the left component to the right

411
00:16:48,560 --> 00:16:50,240
component

412
00:16:50,240 --> 00:16:51,040
and

413
00:16:51,040 --> 00:16:52,880
essentially

414
00:16:52,880 --> 00:16:54,959
the private key time g is just the

415
00:16:54,959 --> 00:16:57,599
public key

416
00:16:58,560 --> 00:17:01,600
so in this in the special case when the

417
00:17:01,600 --> 00:17:04,640
other messages equal to each other then

418
00:17:04,640 --> 00:17:07,520
we will have a very fast algorithm

419
00:17:07,520 --> 00:17:10,559
and it's called fast aggregate verify

420
00:17:10,559 --> 00:17:12,400
basically because

421
00:17:12,400 --> 00:17:14,880
all the messages equal to each other

422
00:17:14,880 --> 00:17:17,599
they're hash equal to each other

423
00:17:17,599 --> 00:17:20,799
and as you can see from the equation

424
00:17:20,799 --> 00:17:22,959
instead of computing

425
00:17:22,959 --> 00:17:25,359
two pairing we will only compute one

426
00:17:25,359 --> 00:17:28,640
pairing with the aggregation of the

427
00:17:28,640 --> 00:17:29,840
public key

428
00:17:29,840 --> 00:17:32,400
pay attention to the aggregation of

429
00:17:32,400 --> 00:17:33,840
public key because

430
00:17:33,840 --> 00:17:38,559
this is exactly where we will exploit

431
00:17:41,919 --> 00:17:46,480
so in this in this case the standard

432
00:17:46,480 --> 00:17:49,200
is correct but all the implement

433
00:17:49,200 --> 00:17:52,000
a few implementations such as

434
00:17:52,000 --> 00:17:55,039
mglagro and herome

435
00:17:55,039 --> 00:17:56,640
is not correct

436
00:17:56,640 --> 00:17:59,039
basically

437
00:17:59,039 --> 00:18:04,160
the library checked for zero public key

438
00:18:04,160 --> 00:18:06,480
but it only checked

439
00:18:06,480 --> 00:18:08,880
single public key it doesn't check the

440
00:18:08,880 --> 00:18:10,880
aggregate public key

441
00:18:10,880 --> 00:18:14,720
but as an attacker we can create public

442
00:18:14,720 --> 00:18:17,919
keys so that that sum is zero and we

443
00:18:17,919 --> 00:18:21,120
also use zero signature

444
00:18:21,120 --> 00:18:24,480
as you can see the pairing of zero

445
00:18:24,480 --> 00:18:26,799
signature and

446
00:18:26,799 --> 00:18:29,039
the page point is one

447
00:18:29,039 --> 00:18:31,039
and uh

448
00:18:31,039 --> 00:18:33,440
and the pairing of the hash

449
00:18:33,440 --> 00:18:36,080
and the public key

450
00:18:36,080 --> 00:18:39,919
is also one uh you also want yes so

451
00:18:39,919 --> 00:18:42,160
what it means is the etiquette signature

452
00:18:42,160 --> 00:18:44,559
is valid for all messages

453
00:18:44,559 --> 00:18:46,320
and it's the same

454
00:18:46,320 --> 00:18:48,320
attack it's just that

455
00:18:48,320 --> 00:18:51,039
in this case we split

456
00:18:51,039 --> 00:18:53,840
zero into multiple parts

457
00:18:53,840 --> 00:18:56,400
each part is different from zero

458
00:18:56,400 --> 00:18:58,799
but their sum is zero so that we can

459
00:18:58,799 --> 00:19:03,039
bypass the verification check

460
00:19:03,919 --> 00:19:07,520
i will have a small demo here for

461
00:19:07,520 --> 00:19:09,039
mglagro

462
00:19:09,039 --> 00:19:11,840
bos

463
00:19:12,720 --> 00:19:15,280
library

464
00:19:16,320 --> 00:19:18,720
so we will create

465
00:19:18,720 --> 00:19:21,679
two keys whose sum is zero

466
00:19:21,679 --> 00:19:23,840
and then we will send the zero

467
00:19:23,840 --> 00:19:26,240
signatures so this is the canonical

468
00:19:26,240 --> 00:19:28,400
presentation of the signature and then

469
00:19:28,400 --> 00:19:30,880
we'll generate a random message

470
00:19:30,880 --> 00:19:33,520
and fast aggregate verify

471
00:19:33,520 --> 00:19:37,960
will return true as well

472
00:19:39,520 --> 00:19:42,400
now let's move on to

473
00:19:42,400 --> 00:19:46,000
a bug in the standard draft itself

474
00:19:46,000 --> 00:19:48,880
so this this is the general case

475
00:19:48,880 --> 00:19:53,200
when the message might not equal to each

476
00:19:53,200 --> 00:19:54,160
other

477
00:19:54,160 --> 00:19:56,160
on the left hand side

478
00:19:56,160 --> 00:19:58,480
you have the pairing of the aggregate

479
00:19:58,480 --> 00:20:01,520
signature with the base point g

480
00:20:01,520 --> 00:20:03,520
on the right hand side

481
00:20:03,520 --> 00:20:05,120
is the product

482
00:20:05,120 --> 00:20:07,679
of pairing between

483
00:20:07,679 --> 00:20:11,120
hash and message and public key

484
00:20:11,120 --> 00:20:13,840
so the standard craft underestimate

485
00:20:13,840 --> 00:20:14,640
that's

486
00:20:14,640 --> 00:20:17,679
this case and so it's vulnerable to the

487
00:20:17,679 --> 00:20:20,080
splitting zero attack

488
00:20:20,080 --> 00:20:21,679
and

489
00:20:21,679 --> 00:20:25,360
all libraries including ethereum

490
00:20:25,360 --> 00:20:26,799
michelangelo

491
00:20:26,799 --> 00:20:28,880
supranational blast

492
00:20:28,880 --> 00:20:31,760
or harami are vulnerable

493
00:20:31,760 --> 00:20:33,120
because

494
00:20:33,120 --> 00:20:35,919
they all follow the standard

495
00:20:35,919 --> 00:20:38,480
so this is this is a very important

496
00:20:38,480 --> 00:20:42,640
point and i want to stress that

497
00:20:42,640 --> 00:20:45,039
when cryptographer writes

498
00:20:45,039 --> 00:20:46,000
you know

499
00:20:46,000 --> 00:20:47,840
scientific papers

500
00:20:47,840 --> 00:20:50,400
maybe no one actually read your papers

501
00:20:50,400 --> 00:20:53,679
but when you write standard even if it's

502
00:20:53,679 --> 00:20:55,520
just a draft

503
00:20:55,520 --> 00:20:59,520
people will follow your standard and if

504
00:20:59,520 --> 00:21:01,440
you're not careful

505
00:21:01,440 --> 00:21:03,840
and you don't treat the standard

506
00:21:03,840 --> 00:21:06,559
seriously then

507
00:21:06,559 --> 00:21:09,840
the consequence is disaster because

508
00:21:09,840 --> 00:21:13,360
everyone will implement your vulnerable

509
00:21:13,360 --> 00:21:16,360
standard

510
00:21:17,440 --> 00:21:18,799
so

511
00:21:18,799 --> 00:21:22,240
in in in the in the general case uh does

512
00:21:22,240 --> 00:21:24,400
i will display the splitting zero attack

513
00:21:24,400 --> 00:21:27,760
against the standard and all libraries

514
00:21:27,760 --> 00:21:29,360
so

515
00:21:29,360 --> 00:21:32,240
in this there are two two types of

516
00:21:32,240 --> 00:21:34,640
attack vector here on the left hand side

517
00:21:34,640 --> 00:21:36,080
you can see that

518
00:21:36,080 --> 00:21:40,159
if a signature is valid for a message m

519
00:21:40,159 --> 00:21:41,039
and

520
00:21:41,039 --> 00:21:44,640
then it's also valid for a different set

521
00:21:44,640 --> 00:21:45,840
of message

522
00:21:45,840 --> 00:21:49,919
in our case is valid for m1

523
00:21:49,919 --> 00:21:50,720
and

524
00:21:50,720 --> 00:21:52,080
m and m

525
00:21:52,080 --> 00:21:55,120
for rm it doesn't depend on m at all as

526
00:21:55,120 --> 00:21:56,559
we can see

527
00:21:56,559 --> 00:22:01,440
uh in the demo that i will show later

528
00:22:01,440 --> 00:22:03,039
the attack

529
00:22:03,039 --> 00:22:05,360
card doesn't even need to sign the

530
00:22:05,360 --> 00:22:07,200
message m at all

531
00:22:07,200 --> 00:22:08,960
because

532
00:22:08,960 --> 00:22:11,840
because the the verifier actually never

533
00:22:11,840 --> 00:22:14,000
verifies single signature all the

534
00:22:14,000 --> 00:22:16,880
verifier verifies is the aggregate

535
00:22:16,880 --> 00:22:19,200
signature

536
00:22:19,200 --> 00:22:21,840
and the second attack vector is on the

537
00:22:21,840 --> 00:22:23,440
right hand side

538
00:22:23,440 --> 00:22:27,280
is if if sigma is a valid signature for

539
00:22:27,280 --> 00:22:29,919
m1 and m2 m2

540
00:22:29,919 --> 00:22:33,600
then it's also a valid signature for m1

541
00:22:33,600 --> 00:22:37,120
m3 m3 for all m3

542
00:22:37,120 --> 00:22:39,120
it doesn't depend

543
00:22:39,120 --> 00:22:41,919
on the message m3

544
00:22:41,919 --> 00:22:44,400
at all

545
00:22:45,280 --> 00:22:49,039
okay so i will show you a short demo

546
00:22:49,039 --> 00:22:51,679
about splitting zero attack against

547
00:22:51,679 --> 00:22:54,480
supranational plus library

548
00:22:54,480 --> 00:22:58,240
and and standard craft

549
00:23:01,039 --> 00:23:02,640
so here we have the user public

550
00:23:02,640 --> 00:23:03,840
signature

551
00:23:03,840 --> 00:23:07,520
sigma 3 and the attacker will create two

552
00:23:07,520 --> 00:23:10,159
keys so that their sum is zero and the

553
00:23:10,159 --> 00:23:12,240
signature will be valid for a completely

554
00:23:12,240 --> 00:23:14,960
different set

555
00:23:15,039 --> 00:23:17,760
as you can see that we will print we

556
00:23:17,760 --> 00:23:20,240
will create an arbitrary message and

557
00:23:20,240 --> 00:23:22,960
then we will print out the result of

558
00:23:22,960 --> 00:23:25,520
aggregate signature verify

559
00:23:25,520 --> 00:23:27,679
in the screen you can see that result is

560
00:23:27,679 --> 00:23:30,000
true

561
00:23:33,200 --> 00:23:36,960
but it's not the end of the story yet

562
00:23:36,960 --> 00:23:39,039
the standard even have

563
00:23:39,039 --> 00:23:41,760
a mathematical mistake

564
00:23:41,760 --> 00:23:42,880
so

565
00:23:42,880 --> 00:23:44,320
basically

566
00:23:44,320 --> 00:23:48,880
a very simple requirement is it must

567
00:23:48,880 --> 00:23:50,559
be correct right

568
00:23:50,559 --> 00:23:53,120
what it means is when

569
00:23:53,120 --> 00:23:56,000
you use two equivalent

570
00:23:56,000 --> 00:23:57,360
interface

571
00:23:57,360 --> 00:23:59,919
then it must return the same result it's

572
00:23:59,919 --> 00:24:02,480
a very basic

573
00:24:02,480 --> 00:24:05,520
correct net requirements however the

574
00:24:05,520 --> 00:24:07,919
standard graph has a bug

575
00:24:07,919 --> 00:24:10,000
which will return completely two

576
00:24:10,000 --> 00:24:12,000
different results even for the same

577
00:24:12,000 --> 00:24:13,279
input

578
00:24:13,279 --> 00:24:17,440
and it costs consensus work a few

579
00:24:17,440 --> 00:24:20,960
clarification on the consensus bug means

580
00:24:20,960 --> 00:24:21,760
here

581
00:24:21,760 --> 00:24:24,400
consensus here only means that when you

582
00:24:24,400 --> 00:24:27,360
have one

583
00:24:27,440 --> 00:24:29,840
one data and signature

584
00:24:29,840 --> 00:24:33,200
but you have multiple interpretations of

585
00:24:33,200 --> 00:24:35,600
the same data and signature

586
00:24:35,600 --> 00:24:38,480
it doesn't mean consensus in the sense

587
00:24:38,480 --> 00:24:40,159
of the blockchain

588
00:24:40,159 --> 00:24:42,799
technology

589
00:24:43,279 --> 00:24:46,880
and here i will show you a demo that

590
00:24:46,880 --> 00:24:49,360
two equivalent

591
00:24:49,360 --> 00:24:52,720
interface will return different results

592
00:24:52,720 --> 00:24:57,039
for the same data and signature

593
00:24:57,039 --> 00:24:59,440
basically we will have

594
00:24:59,440 --> 00:25:02,559
two keys whose sums is zero and then we

595
00:25:02,559 --> 00:25:03,679
will

596
00:25:03,679 --> 00:25:07,440
use two api one effect aggregate verify

597
00:25:07,440 --> 00:25:11,600
and the other is aggregate verify

598
00:25:12,000 --> 00:25:14,080
as you can see in the screen one return

599
00:25:14,080 --> 00:25:18,240
false and the other return true

600
00:25:18,400 --> 00:25:19,600
okay

601
00:25:19,600 --> 00:25:21,039
so

602
00:25:21,039 --> 00:25:24,000
to to to wrap up uh

603
00:25:24,000 --> 00:25:26,240
why why splitting zero attack is

604
00:25:26,240 --> 00:25:30,320
dangerous what makes is special right

605
00:25:30,320 --> 00:25:32,640
for the aggregate signature

606
00:25:32,640 --> 00:25:33,600
case

607
00:25:33,600 --> 00:25:35,840
the attacker private key are completely

608
00:25:35,840 --> 00:25:38,720
randomized even though their sum is zero

609
00:25:38,720 --> 00:25:41,760
but from the outsider perspective they

610
00:25:41,760 --> 00:25:44,240
don't know x1 and x2

611
00:25:44,240 --> 00:25:46,400
what it means is the attacker fully

612
00:25:46,400 --> 00:25:49,200
protects its private key and the attack

613
00:25:49,200 --> 00:25:50,640
cost is free

614
00:25:50,640 --> 00:25:53,679
which is very different from the single

615
00:25:53,679 --> 00:25:56,720
signature case where the attacker leaked

616
00:25:56,720 --> 00:25:59,679
its private key

617
00:25:59,679 --> 00:26:00,640
from

618
00:26:00,640 --> 00:26:03,120
the defender point of view

619
00:26:03,120 --> 00:26:05,360
detecting colluded key is very

620
00:26:05,360 --> 00:26:07,279
challenging because

621
00:26:07,279 --> 00:26:11,120
it's equivalent to finding solution to a

622
00:26:11,120 --> 00:26:14,159
very hard problem

623
00:26:14,159 --> 00:26:15,279
which

624
00:26:15,279 --> 00:26:16,960
which i think

625
00:26:16,960 --> 00:26:19,760
no one knows how to solve

626
00:26:19,760 --> 00:26:22,480
and finally

627
00:26:22,480 --> 00:26:24,559
in for the aggregate signature the

628
00:26:24,559 --> 00:26:26,400
verifier only

629
00:26:26,400 --> 00:26:28,960
verifies the aggregate signature it

630
00:26:28,960 --> 00:26:30,640
never sees

631
00:26:30,640 --> 00:26:33,600
single signature at all and so it never

632
00:26:33,600 --> 00:26:36,240
verifies single signatures

633
00:26:36,240 --> 00:26:38,880
and so the verifier will never be sure

634
00:26:38,880 --> 00:26:41,039
what happened in the past

635
00:26:41,039 --> 00:26:42,799
and it lead to

636
00:26:42,799 --> 00:26:45,840
different kind of attack at the

637
00:26:45,840 --> 00:26:47,600
at the application

638
00:26:47,600 --> 00:26:50,000
layers

639
00:26:50,000 --> 00:26:53,360
uh thanks for your attention i hope that

640
00:26:53,360 --> 00:26:54,720
you enjoy

641
00:26:54,720 --> 00:26:56,400
uh the

642
00:26:56,400 --> 00:26:59,440
the zero key and appreciate the number

643
00:26:59,440 --> 00:27:02,720
zero in cryptography because i think

644
00:27:02,720 --> 00:27:03,919
like

645
00:27:03,919 --> 00:27:06,720
this this zero number has been ignored

646
00:27:06,720 --> 00:27:07,919
in the past

647
00:27:07,919 --> 00:27:10,000
but in the different contexts for

648
00:27:10,000 --> 00:27:11,679
aggregate signature

649
00:27:11,679 --> 00:27:14,720
its role becomes important and we should

650
00:27:14,720 --> 00:27:18,480
pay attention to it thank you

