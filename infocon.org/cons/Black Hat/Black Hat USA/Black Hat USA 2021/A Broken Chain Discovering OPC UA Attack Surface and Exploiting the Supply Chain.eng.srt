1
00:00:01,130 --> 00:00:14,320
[Music]

2
00:00:14,320 --> 00:00:16,239
hello everyone this is a broken chain

3
00:00:16,239 --> 00:00:18,720
discovering opc-ua at tax office and

4
00:00:18,720 --> 00:00:20,720
exploiting the supply chain

5
00:00:20,720 --> 00:00:23,039
my name is eran jacob i'm a security

6
00:00:23,039 --> 00:00:25,519
research team leader at otorio

7
00:00:25,519 --> 00:00:28,000
otorio is an industrial cyber security

8
00:00:28,000 --> 00:00:30,480
solutions and services provider and

9
00:00:30,480 --> 00:00:32,479
along with me on this project worked

10
00:00:32,479 --> 00:00:34,800
roman volkin and alonzini on the fasting

11
00:00:34,800 --> 00:00:36,880
part

12
00:00:36,880 --> 00:00:38,559
let's do a quick overview of what we are

13
00:00:38,559 --> 00:00:40,160
going to talk about first we are going

14
00:00:40,160 --> 00:00:42,079
to start with some intro

15
00:00:42,079 --> 00:00:45,120
on opcway and why we decided to research

16
00:00:45,120 --> 00:00:46,320
it

17
00:00:46,320 --> 00:00:48,879
we will continue to discover the attack

18
00:00:48,879 --> 00:00:51,360
surface of different implementations

19
00:00:51,360 --> 00:00:53,680
and afterwards we will exploit some of

20
00:00:53,680 --> 00:00:56,320
the implementations we found

21
00:00:56,320 --> 00:00:58,079
at the end we will cover some fuzzing

22
00:00:58,079 --> 00:01:00,320
work we have done

23
00:01:00,320 --> 00:01:02,719
so let's start

24
00:01:02,719 --> 00:01:04,720
automation protocols are used in many

25
00:01:04,720 --> 00:01:06,880
cyber physical systems we can find them

26
00:01:06,880 --> 00:01:09,439
in factories critical infrastructures

27
00:01:09,439 --> 00:01:12,000
and even in your company's building

28
00:01:12,000 --> 00:01:14,159
along the years many automation vendors

29
00:01:14,159 --> 00:01:16,640
have created their own proprietary

30
00:01:16,640 --> 00:01:19,600
protocols for these purposes

31
00:01:19,600 --> 00:01:21,280
which caused some issues in

32
00:01:21,280 --> 00:01:23,439
interoperability between devices of

33
00:01:23,439 --> 00:01:26,839
different vendors

34
00:01:26,960 --> 00:01:29,920
along with movement well towards more

35
00:01:29,920 --> 00:01:31,920
connected environments in industrial

36
00:01:31,920 --> 00:01:33,200
environments

37
00:01:33,200 --> 00:01:35,680
there were some issues in security in

38
00:01:35,680 --> 00:01:39,759
these protocols that were not originally

39
00:01:39,759 --> 00:01:43,200
designed for this kind of security

40
00:01:43,520 --> 00:01:45,040
the companies have decided to create the

41
00:01:45,040 --> 00:01:47,759
opc foundation which is a consortium

42
00:01:47,759 --> 00:01:50,479
that is responsible for open and secure

43
00:01:50,479 --> 00:01:52,840
communication for industrial

44
00:01:52,840 --> 00:01:55,600
needs the foundation first created the

45
00:01:55,600 --> 00:01:58,240
opc classic which is a protocol that is

46
00:01:58,240 --> 00:02:00,560
made of multiple specifications

47
00:02:00,560 --> 00:02:03,360
providing open and secure communication

48
00:02:03,360 --> 00:02:06,320
for different needs of the industry

49
00:02:06,320 --> 00:02:08,800
and while it was widely adopted

50
00:02:08,800 --> 00:02:11,840
there were some issues in this protocol

51
00:02:11,840 --> 00:02:13,599
first of all it is based on the

52
00:02:13,599 --> 00:02:15,200
microsoft decom

53
00:02:15,200 --> 00:02:16,959
which is a proprietary and close

54
00:02:16,959 --> 00:02:19,680
protocol of microsoft making the opc

55
00:02:19,680 --> 00:02:22,560
classic not that open

56
00:02:22,560 --> 00:02:25,040
another issue was the use of dynamic

57
00:02:25,040 --> 00:02:26,080
ports

58
00:02:26,080 --> 00:02:28,319
which made firewall configurations very

59
00:02:28,319 --> 00:02:30,720
hard for this protocol

60
00:02:30,720 --> 00:02:32,239
along with some other issues and

61
00:02:32,239 --> 00:02:34,319
security concerns the foundation have

62
00:02:34,319 --> 00:02:37,519
decided to create a new protocol

63
00:02:37,519 --> 00:02:40,720
the new protocol is opc ua

64
00:02:40,720 --> 00:02:43,360
opc unified architecture is basically

65
00:02:43,360 --> 00:02:45,360
everything we could ask for

66
00:02:45,360 --> 00:02:47,360
it is security-minded

67
00:02:47,360 --> 00:02:50,319
cross-vendor platform independent very

68
00:02:50,319 --> 00:02:52,800
maintained and very flexible and of

69
00:02:52,800 --> 00:02:55,120
course supporting the industry 4.0 and

70
00:02:55,120 --> 00:02:57,440
smart manufacturing

71
00:02:57,440 --> 00:03:00,159
opc ua can be used across the whole

72
00:03:00,159 --> 00:03:02,000
industrial ecosystem

73
00:03:02,000 --> 00:03:03,920
starting from field devices in the ot

74
00:03:03,920 --> 00:03:08,238
network all the way to the itn cloud

75
00:03:08,400 --> 00:03:10,800
for example opc ua can be used between

76
00:03:10,800 --> 00:03:11,920
controllers

77
00:03:11,920 --> 00:03:13,440
hmis

78
00:03:13,440 --> 00:03:18,959
f2 scada mes and erp in the it network

79
00:03:18,959 --> 00:03:20,800
opecua is also supporting cloud

80
00:03:20,800 --> 00:03:22,400
communication

81
00:03:22,400 --> 00:03:24,720
and if needed it can be used for field

82
00:03:24,720 --> 00:03:27,440
level communication and with tsn it is

83
00:03:27,440 --> 00:03:30,000
real time

84
00:03:30,640 --> 00:03:32,720
as you see opcwa provides us with great

85
00:03:32,720 --> 00:03:33,840
power

86
00:03:33,840 --> 00:03:35,680
but with great power comes great

87
00:03:35,680 --> 00:03:37,280
responsibility

88
00:03:37,280 --> 00:03:39,760
and any compromise of this protocol

89
00:03:39,760 --> 00:03:41,360
may compromise the whole industrial

90
00:03:41,360 --> 00:03:43,440
ecosystem

91
00:03:43,440 --> 00:03:45,519
that is leading us to the motivation for

92
00:03:45,519 --> 00:03:47,519
our research

93
00:03:47,519 --> 00:03:50,080
well basically opcua is the next thing

94
00:03:50,080 --> 00:03:52,319
in industrial communication

95
00:03:52,319 --> 00:03:54,480
we can see it is highly adopted by many

96
00:03:54,480 --> 00:03:57,280
vendors and many of our clients

97
00:03:57,280 --> 00:03:58,959
and if compromised it has some

98
00:03:58,959 --> 00:04:01,280
significant potential impact

99
00:04:01,280 --> 00:04:03,120
mainly because it is used to connect

100
00:04:03,120 --> 00:04:05,840
very sensitive internal ot networks with

101
00:04:05,840 --> 00:04:08,480
more external and more exposed it and

102
00:04:08,480 --> 00:04:11,359
cloud environments

103
00:04:12,000 --> 00:04:13,920
now we can start discovering the attack

104
00:04:13,920 --> 00:04:16,639
surface of different implementations

105
00:04:16,639 --> 00:04:18,560
and we are going to start with the

106
00:04:18,560 --> 00:04:20,880
specifications

107
00:04:20,880 --> 00:04:23,280
the opc foundation provides full and

108
00:04:23,280 --> 00:04:26,000
open specifications for opc ua

109
00:04:26,000 --> 00:04:28,880
they publish the online and along with

110
00:04:28,880 --> 00:04:30,800
them we can find multiple open source

111
00:04:30,800 --> 00:04:32,960
implementations that were published by

112
00:04:32,960 --> 00:04:35,040
the foundation

113
00:04:35,040 --> 00:04:36,639
most of these implementations are now

114
00:04:36,639 --> 00:04:37,919
legacy

115
00:04:37,919 --> 00:04:40,080
but the dotted standard that is based on

116
00:04:40,080 --> 00:04:43,840
the dotnet legacy is still maintained

117
00:04:44,880 --> 00:04:46,560
there are multiple other open

118
00:04:46,560 --> 00:04:48,479
communication stacks and commercial sdks

119
00:04:48,479 --> 00:04:49,919
available

120
00:04:49,919 --> 00:04:52,240
and if we look on the opc foundation

121
00:04:52,240 --> 00:04:55,280
website we can find listed many products

122
00:04:55,280 --> 00:04:58,719
that are using opcwa

123
00:04:59,520 --> 00:05:01,600
now we wanted to check

124
00:05:01,600 --> 00:05:03,840
what implementation is used in

125
00:05:03,840 --> 00:05:05,199
common products

126
00:05:05,199 --> 00:05:06,000
and

127
00:05:06,000 --> 00:05:07,840
we checked some of these products in our

128
00:05:07,840 --> 00:05:11,120
lab and found out that

129
00:05:11,120 --> 00:05:13,440
softing and unifi automation sdks along

130
00:05:13,440 --> 00:05:16,400
with the opc foundation

131
00:05:16,400 --> 00:05:17,840
communication stocks

132
00:05:17,840 --> 00:05:19,840
are being widely used

133
00:05:19,840 --> 00:05:22,320
and we found two main variations of them

134
00:05:22,320 --> 00:05:24,720
one is a native version and the other is

135
00:05:24,720 --> 00:05:27,199
dot net

136
00:05:27,360 --> 00:05:29,199
focusing a bit on the

137
00:05:29,199 --> 00:05:31,360
native version of the sdks and

138
00:05:31,360 --> 00:05:32,880
communication stacks

139
00:05:32,880 --> 00:05:35,919
we can see that the ua stack dll

140
00:05:35,919 --> 00:05:37,520
of the foundation

141
00:05:37,520 --> 00:05:39,039
is the same name for the unified

142
00:05:39,039 --> 00:05:41,919
automation sdk

143
00:05:42,479 --> 00:05:46,639
but this was not the same library

144
00:05:46,880 --> 00:05:49,280
well this was not such a surprise for us

145
00:05:49,280 --> 00:05:52,000
since kaspersky also mentioned this

146
00:05:52,000 --> 00:05:54,080
subject in a report they have done in

147
00:05:54,080 --> 00:05:55,440
2018

148
00:05:55,440 --> 00:05:56,880
mentioning there are some third-party

149
00:05:56,880 --> 00:05:59,039
applications that are using modified

150
00:05:59,039 --> 00:06:02,240
versions of the ua stack

151
00:06:02,240 --> 00:06:05,199
we checked it truly and found out that

152
00:06:05,199 --> 00:06:08,479
both softing and unifi automation sdks

153
00:06:08,479 --> 00:06:10,479
are based on the foundation original

154
00:06:10,479 --> 00:06:11,520
stack

155
00:06:11,520 --> 00:06:14,719
which is now legacy

156
00:06:14,960 --> 00:06:17,039
looking at the dotnet version of these

157
00:06:17,039 --> 00:06:21,840
sdks we found the same thing

158
00:06:22,880 --> 00:06:25,360
now if we go back to our attack surface

159
00:06:25,360 --> 00:06:27,199
we can see that there are some popular

160
00:06:27,199 --> 00:06:30,639
commercial sdks that are based on

161
00:06:30,639 --> 00:06:32,080
the foundations

162
00:06:32,080 --> 00:06:34,120
most of them legacy now communication

163
00:06:34,120 --> 00:06:36,720
communication stocks

164
00:06:36,720 --> 00:06:38,639
along with some other open communication

165
00:06:38,639 --> 00:06:42,479
stocks and sdks

166
00:06:44,400 --> 00:06:46,560
we don't have the full details on all

167
00:06:46,560 --> 00:06:48,800
the products that are using opc ua but

168
00:06:48,800 --> 00:06:51,039
from what we've been able to see and

169
00:06:51,039 --> 00:06:53,039
according to some statements of the opc

170
00:06:53,039 --> 00:06:54,720
foundation

171
00:06:54,720 --> 00:06:57,360
we understand that most of the products

172
00:06:57,360 --> 00:06:59,520
are using commercial sdks

173
00:06:59,520 --> 00:07:00,319
or

174
00:07:00,319 --> 00:07:01,919
the communication stack made by the

175
00:07:01,919 --> 00:07:04,479
foundation

176
00:07:06,400 --> 00:07:09,120
now if we focus on the upper part in

177
00:07:09,120 --> 00:07:11,199
this attack surface we can see a clear

178
00:07:11,199 --> 00:07:13,120
chain of dependency

179
00:07:13,120 --> 00:07:15,280
starting from the foundations

180
00:07:15,280 --> 00:07:17,360
original communication stocks through

181
00:07:17,360 --> 00:07:20,479
commercial sdks all the way to

182
00:07:20,479 --> 00:07:24,319
products made by large vendors

183
00:07:24,319 --> 00:07:26,400
but before we start exploiting this

184
00:07:26,400 --> 00:07:27,919
chain of dependency

185
00:07:27,919 --> 00:07:29,120
let's first

186
00:07:29,120 --> 00:07:30,960
cover some previous work done in this

187
00:07:30,960 --> 00:07:32,960
area

188
00:07:32,960 --> 00:07:34,960
first we have the opc foundation

189
00:07:34,960 --> 00:07:37,120
security working group which is actively

190
00:07:37,120 --> 00:07:38,880
working on securing these important

191
00:07:38,880 --> 00:07:41,440
protocols and we even have the chance to

192
00:07:41,440 --> 00:07:42,880
meet with them

193
00:07:42,880 --> 00:07:44,080
but there are some independent

194
00:07:44,080 --> 00:07:46,240
researches that have been done such as

195
00:07:46,240 --> 00:07:48,479
the research from the bsi

196
00:07:48,479 --> 00:07:51,440
that covered threats specifications and

197
00:07:51,440 --> 00:07:53,440
the rtc implementation

198
00:07:53,440 --> 00:07:55,440
and they were also able to find memory

199
00:07:55,440 --> 00:07:58,400
leak in the foundation stack

200
00:07:58,400 --> 00:08:00,319
kaspersky have done another research in

201
00:08:00,319 --> 00:08:01,840
2018

202
00:08:01,840 --> 00:08:03,680
covering applications using the

203
00:08:03,680 --> 00:08:05,120
foundation stack

204
00:08:05,120 --> 00:08:06,800
and were able to find issues in

205
00:08:06,800 --> 00:08:08,960
third-party products and products made

206
00:08:08,960 --> 00:08:11,599
by the foundations themselves

207
00:08:11,599 --> 00:08:14,639
in 2020 they published another paper on

208
00:08:14,639 --> 00:08:17,599
ncc fuzzing

209
00:08:18,000 --> 00:08:20,319
claudia have published another paper

210
00:08:20,319 --> 00:08:22,720
recently that is discussing opc and

211
00:08:22,720 --> 00:08:25,599
opcua vulnerabilities

212
00:08:25,599 --> 00:08:27,599
they found some issues in products that

213
00:08:27,599 --> 00:08:31,120
are not part of our supply chain

214
00:08:31,280 --> 00:08:32,958
along the years many academic papers

215
00:08:32,958 --> 00:08:34,479
have been published and if you are

216
00:08:34,479 --> 00:08:37,360
looking for securing your own opc server

217
00:08:37,360 --> 00:08:39,599
or client i recommend you reading one of

218
00:08:39,599 --> 00:08:41,839
these

219
00:08:42,399 --> 00:08:44,159
well it is about time for us to start

220
00:08:44,159 --> 00:08:46,320
exploiting our supply chain

221
00:08:46,320 --> 00:08:48,399
and we of course going to begin with the

222
00:08:48,399 --> 00:08:51,200
specifications

223
00:08:52,480 --> 00:08:54,160
looking at specifications we can find

224
00:08:54,160 --> 00:08:57,279
there is a standard opcwa connection

225
00:08:57,279 --> 00:08:59,200
starting from a low arc

226
00:08:59,200 --> 00:09:02,399
followed by a secure channel initiation

227
00:09:02,399 --> 00:09:04,160
the secure channel provides us with

228
00:09:04,160 --> 00:09:06,640
confidentiality integrity and

229
00:09:06,640 --> 00:09:09,200
application authentication

230
00:09:09,200 --> 00:09:11,040
after the secure channel is initiated we

231
00:09:11,040 --> 00:09:13,279
have the session layer which provides

232
00:09:13,279 --> 00:09:15,760
another layer of security in the form of

233
00:09:15,760 --> 00:09:19,600
user authentication and authorization

234
00:09:19,760 --> 00:09:22,399
after the two of these we can send our

235
00:09:22,399 --> 00:09:24,959
messages in a secure way such as read

236
00:09:24,959 --> 00:09:27,760
write and call

237
00:09:29,200 --> 00:09:31,279
reading the reference we looked mainly

238
00:09:31,279 --> 00:09:32,959
for areas

239
00:09:32,959 --> 00:09:34,720
that may be more

240
00:09:34,720 --> 00:09:38,000
risky for implementations

241
00:09:38,000 --> 00:09:40,640
there are many of them but we focus on

242
00:09:40,640 --> 00:09:42,560
three of them

243
00:09:42,560 --> 00:09:45,200
first we have the complex data types

244
00:09:45,200 --> 00:09:47,600
some data types in opc ua are very

245
00:09:47,600 --> 00:09:48,880
flexible

246
00:09:48,880 --> 00:09:51,120
and we decided we can try and use them

247
00:09:51,120 --> 00:09:54,640
for exploiting different parts of it

248
00:09:54,640 --> 00:09:57,360
another area is the flexible encoding

249
00:09:57,360 --> 00:09:59,680
opc ui message can contain different

250
00:09:59,680 --> 00:10:04,959
coding and even binary and xml together

251
00:10:04,959 --> 00:10:06,959
and the third subject is press security

252
00:10:06,959 --> 00:10:08,320
messages

253
00:10:08,320 --> 00:10:11,200
some opc ua messages does not require

254
00:10:11,200 --> 00:10:12,640
any security

255
00:10:12,640 --> 00:10:15,120
and for example we have the messages

256
00:10:15,120 --> 00:10:17,279
that are used to create the secure

257
00:10:17,279 --> 00:10:19,680
channel or messages that are part of the

258
00:10:19,680 --> 00:10:22,719
discovery service

259
00:10:25,200 --> 00:10:27,680
if we are taking these three areas in

260
00:10:27,680 --> 00:10:29,120
the opc ua

261
00:10:29,120 --> 00:10:30,959
we can try and check if the dotnet

262
00:10:30,959 --> 00:10:33,040
starter con standard communication stack

263
00:10:33,040 --> 00:10:35,200
by the opc foundation is vulnerable to

264
00:10:35,200 --> 00:10:37,279
any issues in this area

265
00:10:37,279 --> 00:10:38,880
we decided to focus on the dotted

266
00:10:38,880 --> 00:10:40,640
standard mainly because it's the only

267
00:10:40,640 --> 00:10:42,720
one that is still maintained and we

268
00:10:42,720 --> 00:10:45,120
found it being used by many

269
00:10:45,120 --> 00:10:48,800
vendors and large products

270
00:10:50,320 --> 00:10:52,720
looking at the.net stock we knew that

271
00:10:52,720 --> 00:10:54,800
memory corruption issues are

272
00:10:54,800 --> 00:10:57,200
not much a thing in dot net

273
00:10:57,200 --> 00:10:59,120
but dotnet still doesn't like the

274
00:10:59,120 --> 00:11:00,800
function calls

275
00:11:00,800 --> 00:11:02,880
2d precursion in dotnet

276
00:11:02,880 --> 00:11:04,560
may cause the

277
00:11:04,560 --> 00:11:06,560
application to crash

278
00:11:06,560 --> 00:11:07,839
and

279
00:11:07,839 --> 00:11:10,160
here it is very interesting because

280
00:11:10,160 --> 00:11:12,959
in the opc ua we have objects that are

281
00:11:12,959 --> 00:11:15,600
so flexible they can call and contain

282
00:11:15,600 --> 00:11:17,600
the same object underneath

283
00:11:17,600 --> 00:11:20,720
making them nested objects

284
00:11:20,720 --> 00:11:22,880
the reference alert of such risk when

285
00:11:22,880 --> 00:11:25,279
describing nested data types

286
00:11:25,279 --> 00:11:27,519
and a related issue was already found in

287
00:11:27,519 --> 00:11:29,120
the past

288
00:11:29,120 --> 00:11:32,720
in extension object decoding

289
00:11:32,720 --> 00:11:35,279
looking at the foundations.net stack

290
00:11:35,279 --> 00:11:36,560
we can find the source code many

291
00:11:36,560 --> 00:11:39,440
limitations of the nesting level

292
00:11:39,440 --> 00:11:41,920
but we felt this is not very systematic

293
00:11:41,920 --> 00:11:45,599
and decided to check it truly

294
00:11:46,240 --> 00:11:48,320
well we have a few nested data types in

295
00:11:48,320 --> 00:11:50,079
opc ua

296
00:11:50,079 --> 00:11:52,000
first we have the variant

297
00:11:52,000 --> 00:11:54,079
which is basically a union and can

298
00:11:54,079 --> 00:11:56,399
contain any built-in data types

299
00:11:56,399 --> 00:11:57,760
or array

300
00:11:57,760 --> 00:12:00,560
and matrix

301
00:12:00,800 --> 00:12:02,880
extension object is also an interesting

302
00:12:02,880 --> 00:12:05,279
data type it is a structured container

303
00:12:05,279 --> 00:12:07,920
it can contain any opc use structure

304
00:12:07,920 --> 00:12:10,800
in xml or binary this is very

305
00:12:10,800 --> 00:12:13,440
interesting because opcwa structures can

306
00:12:13,440 --> 00:12:15,600
contain different data types including

307
00:12:15,600 --> 00:12:18,720
extension object itself

308
00:12:19,040 --> 00:12:21,279
diagnostic info is much simpler and it's

309
00:12:21,279 --> 00:12:23,360
basically just able to contain an

310
00:12:23,360 --> 00:12:26,399
optional diagnostic info object

311
00:12:26,399 --> 00:12:28,639
and the data value is able to call

312
00:12:28,639 --> 00:12:31,040
variant that can contain another data

313
00:12:31,040 --> 00:12:33,360
value

314
00:12:33,839 --> 00:12:36,000
looking at these data types

315
00:12:36,000 --> 00:12:37,680
we were able to find

316
00:12:37,680 --> 00:12:40,560
issue in the variant decoding

317
00:12:40,560 --> 00:12:44,079
in the xml decoder of the ocua

318
00:12:44,079 --> 00:12:45,600
here on the left

319
00:12:45,600 --> 00:12:48,240
you can see the read variant function

320
00:12:48,240 --> 00:12:51,120
calling read matrix that is able to call

321
00:12:51,120 --> 00:12:52,800
read variant directly without any

322
00:12:52,800 --> 00:12:55,040
limitation allowing us to perform

323
00:12:55,040 --> 00:12:58,079
unlimited nesting

324
00:12:58,959 --> 00:13:01,440
this is placed in the xml decoder for

325
00:13:01,440 --> 00:13:04,399
the opc ua and all we need to crash the

326
00:13:04,399 --> 00:13:07,120
sdk using this is to create a large

327
00:13:07,120 --> 00:13:09,839
enough xml something like this but

328
00:13:09,839 --> 00:13:11,920
much larger

329
00:13:11,920 --> 00:13:14,160
and

330
00:13:14,399 --> 00:13:17,120
we need to find a way to get it into

331
00:13:17,120 --> 00:13:18,880
the xml decoder

332
00:13:18,880 --> 00:13:21,120
we have done this using the extension

333
00:13:21,120 --> 00:13:22,240
objects

334
00:13:22,240 --> 00:13:26,000
which are able to contain xml decoded

335
00:13:26,000 --> 00:13:27,440
structures

336
00:13:27,440 --> 00:13:29,200
and using the extension objects we are

337
00:13:29,200 --> 00:13:31,360
able to pivot our way into vulnerable

338
00:13:31,360 --> 00:13:32,959
parts of the stack

339
00:13:32,959 --> 00:13:35,120
and

340
00:13:35,120 --> 00:13:37,200
using them before channel session

341
00:13:37,200 --> 00:13:40,639
security we are able to crash the sdk

342
00:13:40,639 --> 00:13:41,839
before

343
00:13:41,839 --> 00:13:45,600
any security is initiated

344
00:13:46,240 --> 00:13:47,760
here we can see an example for

345
00:13:47,760 --> 00:13:50,079
exploitation of this issue in secure

346
00:13:50,079 --> 00:13:52,720
channel initiation

347
00:13:52,720 --> 00:13:54,160
we have an extension object in the

348
00:13:54,160 --> 00:13:56,639
message header and

349
00:13:56,639 --> 00:13:58,399
we just have to change the encoding for

350
00:13:58,399 --> 00:14:00,079
the extension object and append our

351
00:14:00,079 --> 00:14:01,440
payload

352
00:14:01,440 --> 00:14:04,079
and we get a crush

353
00:14:04,079 --> 00:14:05,920
but that was not enough for most

354
00:14:05,920 --> 00:14:07,120
application

355
00:14:07,120 --> 00:14:08,959
because we had to find a way to send

356
00:14:08,959 --> 00:14:11,440
much larger xml payload

357
00:14:11,440 --> 00:14:12,880
and most of the applications were

358
00:14:12,880 --> 00:14:17,199
limiting us by the buffer size

359
00:14:17,199 --> 00:14:19,920
so we used chunks

360
00:14:19,920 --> 00:14:22,320
opcua allows us to send messages in

361
00:14:22,320 --> 00:14:23,279
chunks

362
00:14:23,279 --> 00:14:25,760
and reaching message size up to 4 to 16

363
00:14:25,760 --> 00:14:27,600
megabytes in the configuration we

364
00:14:27,600 --> 00:14:30,320
checked

365
00:14:30,320 --> 00:14:32,240
but chunks are not supported in the open

366
00:14:32,240 --> 00:14:33,760
requests

367
00:14:33,760 --> 00:14:36,079
so this time we used a pre-security

368
00:14:36,079 --> 00:14:38,480
message find servers which is part of

369
00:14:38,480 --> 00:14:40,160
the discovery service

370
00:14:40,160 --> 00:14:42,320
that is by design not requiring a

371
00:14:42,320 --> 00:14:45,279
security

372
00:14:45,279 --> 00:14:47,519
sending this message with our vulnerable

373
00:14:47,519 --> 00:14:49,360
xml

374
00:14:49,360 --> 00:14:51,120
we were able to crash any dotnet

375
00:14:51,120 --> 00:14:54,160
application we've checked

376
00:14:55,360 --> 00:14:58,079
this six years old zero day can be found

377
00:14:58,079 --> 00:15:01,600
in the opc foundation's legacy standard

378
00:15:01,600 --> 00:15:02,560
and

379
00:15:02,560 --> 00:15:06,399
softing and unified automation sdks

380
00:15:07,279 --> 00:15:09,199
if we try to demonstrate how this can be

381
00:15:09,199 --> 00:15:11,760
exploited here we have a main site and

382
00:15:11,760 --> 00:15:14,079
two remote sites connected to it

383
00:15:14,079 --> 00:15:15,839
and in the middle we have the scada that

384
00:15:15,839 --> 00:15:18,000
is communicating with two of the remote

385
00:15:18,000 --> 00:15:19,920
sites

386
00:15:19,920 --> 00:15:22,160
an attacker on the main site may be able

387
00:15:22,160 --> 00:15:24,959
to send a malicious packet to the opcwa

388
00:15:24,959 --> 00:15:27,440
servers making them crash

389
00:15:27,440 --> 00:15:29,120
and cause a lot of visibility and

390
00:15:29,120 --> 00:15:31,600
control

391
00:15:32,560 --> 00:15:34,639
this action may cause a total shutdown

392
00:15:34,639 --> 00:15:36,560
for many factories

393
00:15:36,560 --> 00:15:39,199
and can be performed also from a remote

394
00:15:39,199 --> 00:15:41,839
site

395
00:15:42,240 --> 00:15:43,759
in this scenario we have an attacker

396
00:15:43,759 --> 00:15:46,079
that has access to one of the opc ua

397
00:15:46,079 --> 00:15:47,040
servers

398
00:15:47,040 --> 00:15:50,079
or main the middle in its network

399
00:15:50,079 --> 00:15:52,720
the attacker can response the opca

400
00:15:52,720 --> 00:15:54,560
client of the scada with a malicious

401
00:15:54,560 --> 00:15:59,199
response and get the same result

402
00:16:02,240 --> 00:16:04,720
now let's try and cover another area

403
00:16:04,720 --> 00:16:07,199
again around the xml but this time with

404
00:16:07,199 --> 00:16:09,839
the xml processing library

405
00:16:09,839 --> 00:16:12,160
we know that xml processing in dotnet

406
00:16:12,160 --> 00:16:14,959
may be a bit tricky on some versions

407
00:16:14,959 --> 00:16:16,000
and

408
00:16:16,000 --> 00:16:17,759
we noticed there were multiple

409
00:16:17,759 --> 00:16:20,399
vulnerabilities in these areas before

410
00:16:20,399 --> 00:16:22,240
but it was a great chance for us to

411
00:16:22,240 --> 00:16:26,000
check the commercial sdks

412
00:16:26,000 --> 00:16:28,800
looking for the modified versions

413
00:16:28,800 --> 00:16:30,880
we found in unified automation

414
00:16:30,880 --> 00:16:34,160
this piece of code and if you look here

415
00:16:34,160 --> 00:16:38,720
we have an unsafe xml document loading

416
00:16:38,720 --> 00:16:40,720
this allows an attacker that is able to

417
00:16:40,720 --> 00:16:43,600
load xml into this function

418
00:16:43,600 --> 00:16:46,720
to perform http requests into the

419
00:16:46,720 --> 00:16:48,240
internal subnet

420
00:16:48,240 --> 00:16:52,480
and leak files from the attack device

421
00:16:52,480 --> 00:16:54,079
code refactoring reintroduced this

422
00:16:54,079 --> 00:16:56,079
vulnerability after it was fixed in the

423
00:16:56,079 --> 00:16:57,680
dotnet standard

424
00:16:57,680 --> 00:16:59,600
and we can exploit it in the same way of

425
00:16:59,600 --> 00:17:02,639
an extension object

426
00:17:03,600 --> 00:17:05,919
a scenario for this kind of attack is

427
00:17:05,919 --> 00:17:08,000
pretty simple we have an attacker in the

428
00:17:08,000 --> 00:17:10,720
it network and we have an

429
00:17:10,720 --> 00:17:13,199
internal ot network that is accessible

430
00:17:13,199 --> 00:17:14,880
to it

431
00:17:14,880 --> 00:17:16,640
the attacker

432
00:17:16,640 --> 00:17:18,400
can send a malicious packet to the opc

433
00:17:18,400 --> 00:17:19,520
ua server

434
00:17:19,520 --> 00:17:21,520
retrieve sensitive files

435
00:17:21,520 --> 00:17:24,079
and send malicious requests into the

436
00:17:24,079 --> 00:17:26,879
internal network

437
00:17:29,039 --> 00:17:30,720
let's continue with another type of

438
00:17:30,720 --> 00:17:32,960
commercial sdk this time we are going to

439
00:17:32,960 --> 00:17:36,480
focus on an sdk that is based on the ncc

440
00:17:36,480 --> 00:17:38,480
legacy stack

441
00:17:38,480 --> 00:17:41,520
we chose softing cpp sdk which is used

442
00:17:41,520 --> 00:17:43,600
by many vendors

443
00:17:43,600 --> 00:17:48,399
and is supporting multiple platforms

444
00:17:48,640 --> 00:17:51,039
the software cvp can run on vxworks

445
00:17:51,039 --> 00:17:53,360
windows and linux and is made of

446
00:17:53,360 --> 00:17:55,760
multiple libraries

447
00:17:55,760 --> 00:17:57,520
on the bottom here we can see the tv5

448
00:17:57,520 --> 00:17:58,720
stack

449
00:17:58,720 --> 00:18:01,280
which is basically an extended version

450
00:18:01,280 --> 00:18:05,039
for the opc foundation nc stack

451
00:18:05,679 --> 00:18:08,160
above it we have the tb5ot

452
00:18:08,160 --> 00:18:10,880
that is in charge on stack sdk level

453
00:18:10,880 --> 00:18:12,480
processing

454
00:18:12,480 --> 00:18:15,440
and on the top we have tb5 cpp

455
00:18:15,440 --> 00:18:17,600
that is the interface for integrating

456
00:18:17,600 --> 00:18:21,039
applications with the sdk

457
00:18:21,760 --> 00:18:23,520
here we focused on the integration

458
00:18:23,520 --> 00:18:26,080
between the extended version of the ncc

459
00:18:26,080 --> 00:18:30,080
stack and the tb5 ot library

460
00:18:30,080 --> 00:18:32,000
an interesting fact is while the

461
00:18:32,000 --> 00:18:33,840
foundation is using

462
00:18:33,840 --> 00:18:36,640
c structures for representing decoded

463
00:18:36,640 --> 00:18:38,640
opc ua objects

464
00:18:38,640 --> 00:18:41,039
the tv5 ot is using

465
00:18:41,039 --> 00:18:44,400
a cpp object made by softing for the

466
00:18:44,400 --> 00:18:45,280
same

467
00:18:45,280 --> 00:18:47,678
purpose

468
00:18:47,760 --> 00:18:49,919
and if we try to walk through the

469
00:18:49,919 --> 00:18:52,400
process from binary message into cvp

470
00:18:52,400 --> 00:18:53,440
objects

471
00:18:53,440 --> 00:18:54,559
we can hear

472
00:18:54,559 --> 00:18:56,400
see that a binary message is first

473
00:18:56,400 --> 00:18:58,960
processed by the tb5 stack

474
00:18:58,960 --> 00:19:00,400
validated

475
00:19:00,400 --> 00:19:03,200
and if everything is okay we get some c

476
00:19:03,200 --> 00:19:05,360
structures

477
00:19:05,360 --> 00:19:09,679
the t5 ot using these c structures for

478
00:19:09,679 --> 00:19:12,320
its own purposes or if interesting it

479
00:19:12,320 --> 00:19:16,240
saves them into cpp objects

480
00:19:16,720 --> 00:19:20,000
our focus is here we looked for issues

481
00:19:20,000 --> 00:19:23,280
in the transfer from c structures to cpp

482
00:19:23,280 --> 00:19:25,200
objects

483
00:19:25,200 --> 00:19:27,919
but finding issues in the cpp object

484
00:19:27,919 --> 00:19:31,200
setters is not that easy because

485
00:19:31,200 --> 00:19:33,760
any input for these functions is first

486
00:19:33,760 --> 00:19:37,440
validated both by the tb5 stack and the

487
00:19:37,440 --> 00:19:39,840
ot

488
00:19:39,919 --> 00:19:43,280
so we had to find a c structure that is

489
00:19:43,280 --> 00:19:45,039
flexible enough

490
00:19:45,039 --> 00:19:47,520
to introduce unexpected input

491
00:19:47,520 --> 00:19:50,639
to the cvp object

492
00:19:50,880 --> 00:19:52,640
for that purpose

493
00:19:52,640 --> 00:19:56,160
we have the foundations extension object

494
00:19:56,160 --> 00:19:58,640
this is how the foundation see structure

495
00:19:58,640 --> 00:20:01,200
of the extension object is looking this

496
00:20:01,200 --> 00:20:03,919
is not how an extension object is passed

497
00:20:03,919 --> 00:20:05,760
through communication but how it is

498
00:20:05,760 --> 00:20:08,480
saved in memory

499
00:20:08,799 --> 00:20:11,200
the extension object structure is made

500
00:20:11,200 --> 00:20:12,880
of three main parts

501
00:20:12,880 --> 00:20:14,799
the first part is the id of the

502
00:20:14,799 --> 00:20:17,760
contained structure

503
00:20:17,840 --> 00:20:19,679
after that we have the encoding of the

504
00:20:19,679 --> 00:20:21,120
internal structure

505
00:20:21,120 --> 00:20:22,960
and in the end we have a union that

506
00:20:22,960 --> 00:20:26,960
representing the contained structure

507
00:20:26,960 --> 00:20:28,960
if we zoom into the body of the

508
00:20:28,960 --> 00:20:31,039
contained structure we can see it can

509
00:20:31,039 --> 00:20:33,360
contain three types of

510
00:20:33,360 --> 00:20:35,200
structures

511
00:20:35,200 --> 00:20:37,600
first way is representing the structure

512
00:20:37,600 --> 00:20:40,320
in a binary format this is used for

513
00:20:40,320 --> 00:20:42,960
structures that are not supported by the

514
00:20:42,960 --> 00:20:44,880
stack

515
00:20:44,880 --> 00:20:46,240
another option

516
00:20:46,240 --> 00:20:49,840
is saving it as an xml element

517
00:20:49,840 --> 00:20:51,760
and because the ncc stack is not

518
00:20:51,760 --> 00:20:54,480
supporting xml decoding it is basically

519
00:20:54,480 --> 00:20:56,880
the same

520
00:20:57,280 --> 00:21:00,640
the third one is an actual decoded

521
00:21:00,640 --> 00:21:02,799
structure in

522
00:21:02,799 --> 00:21:05,200
ncc structure that is containing the

523
00:21:05,200 --> 00:21:06,240
internal

524
00:21:06,240 --> 00:21:08,559
object

525
00:21:08,559 --> 00:21:10,400
and we basically have here two options

526
00:21:10,400 --> 00:21:11,120
for

527
00:21:11,120 --> 00:21:14,000
encoded body

528
00:21:15,440 --> 00:21:17,919
it's muscle we must understand that this

529
00:21:17,919 --> 00:21:18,799
both

530
00:21:18,799 --> 00:21:21,360
parts of the structure must be validated

531
00:21:21,360 --> 00:21:23,919
before any access to the body union is

532
00:21:23,919 --> 00:21:26,880
done otherwise we may access in 32

533
00:21:26,880 --> 00:21:30,400
instead of a pointer

534
00:21:30,400 --> 00:21:32,880
looking at the sdk object setters we

535
00:21:32,880 --> 00:21:34,720
could find some setters that are

536
00:21:34,720 --> 00:21:36,880
accepting extension objects

537
00:21:36,880 --> 00:21:38,000
but

538
00:21:38,000 --> 00:21:40,000
most of them were validating both the

539
00:21:40,000 --> 00:21:44,120
type id and the encoding

540
00:21:44,480 --> 00:21:46,400
after looking a bit deeper we found a

541
00:21:46,400 --> 00:21:48,480
few that missed validation on the

542
00:21:48,480 --> 00:21:50,480
encoding part

543
00:21:50,480 --> 00:21:52,320
meaning that

544
00:21:52,320 --> 00:21:54,640
if we have any option for making the

545
00:21:54,640 --> 00:21:57,679
body not a decoded object but a byte

546
00:21:57,679 --> 00:21:59,120
string for example

547
00:21:59,120 --> 00:22:03,039
we may be able to crush the sdk

548
00:22:04,080 --> 00:22:07,200
but we must remember that type ids that

549
00:22:07,200 --> 00:22:09,600
are known by the tb5 stacks

550
00:22:09,600 --> 00:22:12,080
are automatically decoded and all of the

551
00:22:12,080 --> 00:22:14,960
types we found were supported by the tb5

552
00:22:14,960 --> 00:22:17,280
stack

553
00:22:17,440 --> 00:22:20,640
we have two options for bypassing it

554
00:22:20,640 --> 00:22:22,880
one of them is pretty simple is just

555
00:22:22,880 --> 00:22:25,200
using xml decoding for the internal

556
00:22:25,200 --> 00:22:27,679
structure which is not supported by the

557
00:22:27,679 --> 00:22:30,080
ncc stack and it will be saved as a

558
00:22:30,080 --> 00:22:32,000
by-string

559
00:22:32,000 --> 00:22:33,679
another option we have

560
00:22:33,679 --> 00:22:35,840
is using the type id

561
00:22:35,840 --> 00:22:38,159
the id of the internal structure can be

562
00:22:38,159 --> 00:22:40,400
represented in different ways

563
00:22:40,400 --> 00:22:42,559
and the ncc stack is supporting only

564
00:22:42,559 --> 00:22:44,720
numeric version of it

565
00:22:44,720 --> 00:22:47,840
so if we send and by string identifier

566
00:22:47,840 --> 00:22:50,080
in a specific length it would be enough

567
00:22:50,080 --> 00:22:52,400
to bypass the checks of the sdk

568
00:22:52,400 --> 00:22:57,840
and provide us with an undecoded object

569
00:22:58,080 --> 00:22:59,919
now that we have a c structure that is

570
00:22:59,919 --> 00:23:01,760
received by the sdk

571
00:23:01,760 --> 00:23:02,559
and

572
00:23:02,559 --> 00:23:05,440
is valid on the type id field but

573
00:23:05,440 --> 00:23:08,320
contains a byte string in its body all

574
00:23:08,320 --> 00:23:10,559
we need to do is to find a way to get it

575
00:23:10,559 --> 00:23:13,679
through the object setter function

576
00:23:13,679 --> 00:23:15,440
unfortunately

577
00:23:15,440 --> 00:23:17,440
this was not working for any of the

578
00:23:17,440 --> 00:23:20,799
extension objects you used for so far

579
00:23:20,799 --> 00:23:23,039
and all of them were used internally in

580
00:23:23,039 --> 00:23:25,280
the tb5 ot without being set into an

581
00:23:25,280 --> 00:23:27,360
object

582
00:23:27,360 --> 00:23:28,320
well

583
00:23:28,320 --> 00:23:31,360
this was kind of an opportunity for us

584
00:23:31,360 --> 00:23:33,760
we wanted to check another area of the

585
00:23:33,760 --> 00:23:35,200
opc ua

586
00:23:35,200 --> 00:23:37,440
the pub sub extension

587
00:23:37,440 --> 00:23:40,159
pub sub is a new extension

588
00:23:40,159 --> 00:23:42,720
for the opc ua protocol

589
00:23:42,720 --> 00:23:43,760
and

590
00:23:43,760 --> 00:23:46,320
we decide we are going to find a message

591
00:23:46,320 --> 00:23:48,720
that is part of pub sub that will be set

592
00:23:48,720 --> 00:23:51,600
into a cpp object setup which allow will

593
00:23:51,600 --> 00:23:53,120
allow us to crush

594
00:23:53,120 --> 00:23:54,240
pub sub

595
00:23:54,240 --> 00:23:56,320
applications

596
00:23:56,320 --> 00:23:58,640
a word about pub sub

597
00:23:58,640 --> 00:24:01,120
pub sub is a publish subscribe model for

598
00:24:01,120 --> 00:24:04,080
the opc ua it is using udp packets and

599
00:24:04,080 --> 00:24:06,320
it is slightly different

600
00:24:06,320 --> 00:24:08,400
there are two main

601
00:24:08,400 --> 00:24:09,440
usages

602
00:24:09,440 --> 00:24:12,480
for pub sub one of them is

603
00:24:12,480 --> 00:24:14,480
through a relay broker

604
00:24:14,480 --> 00:24:17,120
that is publishing the messages to many

605
00:24:17,120 --> 00:24:19,360
subscribers this is mainly used in the

606
00:24:19,360 --> 00:24:20,720
cloud

607
00:24:20,720 --> 00:24:22,320
and there are some

608
00:24:22,320 --> 00:24:24,640
secure multicast options that is used

609
00:24:24,640 --> 00:24:26,240
for field level communication for

610
00:24:26,240 --> 00:24:28,240
example essential publishing information

611
00:24:28,240 --> 00:24:31,880
to multiple subscribers

612
00:24:32,240 --> 00:24:35,360
looking for an exploitable message we

613
00:24:35,360 --> 00:24:36,240
found

614
00:24:36,240 --> 00:24:39,520
one message that contained variant

615
00:24:39,520 --> 00:24:42,880
and was set into an object setter

616
00:24:42,880 --> 00:24:45,600
using the variant we can add any object

617
00:24:45,600 --> 00:24:48,000
we want under this variant including our

618
00:24:48,000 --> 00:24:51,200
malicious extension object

619
00:24:51,440 --> 00:24:53,360
and if we try to demo the use of this

620
00:24:53,360 --> 00:24:54,559
message

621
00:24:54,559 --> 00:24:56,960
we can see here

622
00:24:56,960 --> 00:25:00,760
that there is our publisher on the right

623
00:25:00,760 --> 00:25:03,360
communicating with multiple subscribers

624
00:25:03,360 --> 00:25:07,679
on the left through a multicast network

625
00:25:07,679 --> 00:25:10,080
these subscribers are constantly keep

626
00:25:10,080 --> 00:25:12,880
getting messages from this publisher

627
00:25:12,880 --> 00:25:15,279
and on the right top we have our

628
00:25:15,279 --> 00:25:16,960
attacker

629
00:25:16,960 --> 00:25:17,919
which

630
00:25:17,919 --> 00:25:19,600
is also connected to the multicast

631
00:25:19,600 --> 00:25:20,880
network

632
00:25:20,880 --> 00:25:23,840
and if he will send our malicious pocket

633
00:25:23,840 --> 00:25:26,159
we will see the subscriber crashing one

634
00:25:26,159 --> 00:25:29,480
after the other

635
00:25:33,200 --> 00:25:34,799
we were able to find

636
00:25:34,799 --> 00:25:36,720
seven object setters that were not

637
00:25:36,720 --> 00:25:39,279
protected against this attack

638
00:25:39,279 --> 00:25:41,679
and we assumed that this issue is not

639
00:25:41,679 --> 00:25:44,960
only exist in softing

640
00:25:45,200 --> 00:25:47,440
looking at the opc foundation code again

641
00:25:47,440 --> 00:25:49,679
we found the same issue in the sample

642
00:25:49,679 --> 00:25:52,559
server of the ncc stack

643
00:25:52,559 --> 00:25:54,480
and we managed to crash it

644
00:25:54,480 --> 00:25:58,960
with the same methods we presented

645
00:26:00,960 --> 00:26:02,720
this is about time for us to continue to

646
00:26:02,720 --> 00:26:04,720
the last part in our chain

647
00:26:04,720 --> 00:26:07,440
the products

648
00:26:07,840 --> 00:26:09,679
we know products

649
00:26:09,679 --> 00:26:12,720
that are integrating ocua are facing

650
00:26:12,720 --> 00:26:14,159
different risks

651
00:26:14,159 --> 00:26:15,840
one of them are

652
00:26:15,840 --> 00:26:17,919
configurations related

653
00:26:17,919 --> 00:26:19,200
which means that

654
00:26:19,200 --> 00:26:21,679
because of the configuration of opcua is

655
00:26:21,679 --> 00:26:24,400
so complex there is high possibility

656
00:26:24,400 --> 00:26:26,720
for different applications to miss some

657
00:26:26,720 --> 00:26:28,080
important parts

658
00:26:28,080 --> 00:26:30,320
and

659
00:26:30,880 --> 00:26:33,039
end up with an unsecured client or

660
00:26:33,039 --> 00:26:35,279
server

661
00:26:35,279 --> 00:26:37,200
but since they have been done a lot of

662
00:26:37,200 --> 00:26:39,039
work in this area and there are many

663
00:26:39,039 --> 00:26:40,400
tools for

664
00:26:40,400 --> 00:26:42,320
providing these tests

665
00:26:42,320 --> 00:26:44,559
we decided to focus on the integration

666
00:26:44,559 --> 00:26:46,400
of the

667
00:26:46,400 --> 00:26:48,559
products with the opcwa sdk or

668
00:26:48,559 --> 00:26:51,440
communication stack

669
00:26:51,600 --> 00:26:54,480
here we have an image of unified

670
00:26:54,480 --> 00:26:56,320
automation sdk

671
00:26:56,320 --> 00:26:58,880
and we can see in the bottom our system

672
00:26:58,880 --> 00:26:59,919
vendor

673
00:26:59,919 --> 00:27:01,520
system

674
00:27:01,520 --> 00:27:03,039
we can see in the bottom the vendor

675
00:27:03,039 --> 00:27:06,159
system that is integrated with the sdk

676
00:27:06,159 --> 00:27:09,200
through multiple interfaces

677
00:27:09,200 --> 00:27:11,760
unified automations are defining

678
00:27:11,760 --> 00:27:13,840
multiple required interfaces and

679
00:27:13,840 --> 00:27:16,320
optional interfaces for the integration

680
00:27:16,320 --> 00:27:17,840
process

681
00:27:17,840 --> 00:27:21,279
and we checked i o manager interface and

682
00:27:21,279 --> 00:27:23,360
could see that some products are

683
00:27:23,360 --> 00:27:25,760
actually implementing it

684
00:27:25,760 --> 00:27:27,360
but this time

685
00:27:27,360 --> 00:27:30,080
we understood that this issue must be

686
00:27:30,080 --> 00:27:32,720
tested in a more generic way

687
00:27:32,720 --> 00:27:35,200
so we used our own made

688
00:27:35,200 --> 00:27:36,799
father

689
00:27:36,799 --> 00:27:39,679
our father is a network-based father

690
00:27:39,679 --> 00:27:41,039
that is using

691
00:27:41,039 --> 00:27:43,440
structured mutations on the internal

692
00:27:43,440 --> 00:27:46,720
parameters and on the packets or message

693
00:27:46,720 --> 00:27:49,679
flow

694
00:27:49,679 --> 00:27:51,200
the io manager

695
00:27:51,200 --> 00:27:53,279
we implemented

696
00:27:53,279 --> 00:27:56,880
was read write and monitor items packets

697
00:27:56,880 --> 00:27:59,600
and we focused on fighting the objects

698
00:27:59,600 --> 00:28:02,399
that are being passed to the underlying

699
00:28:02,399 --> 00:28:04,480
device

700
00:28:04,480 --> 00:28:06,720
we yet haven't found any significant

701
00:28:06,720 --> 00:28:09,200
issues but we are still working on

702
00:28:09,200 --> 00:28:11,919
expanding the mutations to be more opi

703
00:28:11,919 --> 00:28:16,919
specific and covering more products

704
00:28:17,840 --> 00:28:19,919
to sum up

705
00:28:19,919 --> 00:28:23,200
opc ua is a very powerful protocol

706
00:28:23,200 --> 00:28:25,039
but if compromised

707
00:28:25,039 --> 00:28:27,919
it can be used by attackers targeting

708
00:28:27,919 --> 00:28:30,960
cyber physical systems

709
00:28:30,960 --> 00:28:32,080
and

710
00:28:32,080 --> 00:28:34,559
if we look at the supply chain we

711
00:28:34,559 --> 00:28:35,679
discovered

712
00:28:35,679 --> 00:28:36,960
any impact

713
00:28:36,960 --> 00:28:38,880
to the first part in our chain may

714
00:28:38,880 --> 00:28:41,600
impact many products

715
00:28:41,600 --> 00:28:44,000
we used specific parts in the op-ua for

716
00:28:44,000 --> 00:28:46,080
demonstrating exploitations of the

717
00:28:46,080 --> 00:28:47,279
supply chain

718
00:28:47,279 --> 00:28:49,840
for example complex objects dynamic

719
00:28:49,840 --> 00:28:50,960
encoding

720
00:28:50,960 --> 00:28:54,159
and unsecured messages

721
00:28:54,159 --> 00:28:56,000
but it's still important to remember

722
00:28:56,000 --> 00:28:58,559
that opc-ua is one of the most secure

723
00:28:58,559 --> 00:29:00,640
industrial protocols right now

724
00:29:00,640 --> 00:29:03,360
and we only recommend users

725
00:29:03,360 --> 00:29:05,360
to use additional security measures and

726
00:29:05,360 --> 00:29:07,200
of course make sure the configuration is

727
00:29:07,200 --> 00:29:09,440
proper

728
00:29:09,440 --> 00:29:11,200
i want to thank matandu brushing for the

729
00:29:11,200 --> 00:29:13,600
mentoring in this project and of course

730
00:29:13,600 --> 00:29:15,840
roman volkin and alonzini for the

731
00:29:15,840 --> 00:29:17,440
fuzzing part

732
00:29:17,440 --> 00:29:19,679
i am iran jacob and feel free to contact

733
00:29:19,679 --> 00:29:21,600
me if you have any comments

734
00:29:21,600 --> 00:29:23,120
or questions

735
00:29:23,120 --> 00:29:25,918
thank you

