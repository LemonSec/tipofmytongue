1
00:00:01,130 --> 00:00:14,399
[Music]

2
00:00:14,400 --> 00:00:16,720
hello everyone thanks for attending my

3
00:00:16,720 --> 00:00:18,560
talk crushing your way to medium

4
00:00:18,560 --> 00:00:21,279
integrity exploiting the pdb parser for

5
00:00:21,279 --> 00:00:23,840
privilege escalation

6
00:00:23,840 --> 00:00:26,240
my name is gal and in the past few years

7
00:00:26,240 --> 00:00:27,840
i've been doing security research for

8
00:00:27,840 --> 00:00:30,240
palo alto networks mainly in the fields

9
00:00:30,240 --> 00:00:32,640
of fuzzing vulnerabilities exploits and

10
00:00:32,640 --> 00:00:33,920
mitigations

11
00:00:33,920 --> 00:00:36,480
i've also been awarded as microsoft msrc

12
00:00:36,480 --> 00:00:38,879
most valuable security researcher for

13
00:00:38,879 --> 00:00:40,960
the past three years in evo for

14
00:00:40,960 --> 00:00:42,719
discovering over 40 different

15
00:00:42,719 --> 00:00:46,559
vulnerabilities in microsoft products

16
00:00:46,559 --> 00:00:48,640
today in this talk we'll discuss one of

17
00:00:48,640 --> 00:00:50,640
the more interesting bugs i discovered

18
00:00:50,640 --> 00:00:53,520
last year and how it can be exploited

19
00:00:53,520 --> 00:00:55,520
and i'd start by explaining what our pdb

20
00:00:55,520 --> 00:00:57,920
files how i discovered vulnerabilities

21
00:00:57,920 --> 00:01:00,239
in microsoft's pdb parser

22
00:01:00,239 --> 00:01:02,399
followed by the different attack surface

23
00:01:02,399 --> 00:01:07,040
into that parser and exploit and a demo

24
00:01:07,040 --> 00:01:09,600
so pdb file store debugging information

25
00:01:09,600 --> 00:01:11,840
also known as symbols about a windows

26
00:01:11,840 --> 00:01:13,680
executable program

27
00:01:13,680 --> 00:01:15,920
those are stored on top of these files

28
00:01:15,920 --> 00:01:17,600
rather than the executable files

29
00:01:17,600 --> 00:01:18,799
themselves

30
00:01:18,799 --> 00:01:21,119
they contain things like function names

31
00:01:21,119 --> 00:01:24,320
globals type information and so on and

32
00:01:24,320 --> 00:01:26,320
are created from source files during the

33
00:01:26,320 --> 00:01:28,000
build process

34
00:01:28,000 --> 00:01:29,840
then they are used by debuggers to

35
00:01:29,840 --> 00:01:32,079
display the debugging information in a

36
00:01:32,079 --> 00:01:34,159
meaningful way throughout the debugging

37
00:01:34,159 --> 00:01:35,680
session

38
00:01:35,680 --> 00:01:38,159
here is an example of using windebug to

39
00:01:38,159 --> 00:01:40,640
load the pdb file of notepad and then

40
00:01:40,640 --> 00:01:43,360
use the x command to simply dump all

41
00:01:43,360 --> 00:01:46,320
symbols from it

42
00:01:46,320 --> 00:01:48,240
the pdb file format itself is a

43
00:01:48,240 --> 00:01:50,159
propriety file format invented by

44
00:01:50,159 --> 00:01:53,520
microsoft it is binary and is built on

45
00:01:53,520 --> 00:01:56,560
top of another file format called msf

46
00:01:56,560 --> 00:01:58,240
which is a simple file system-like

47
00:01:58,240 --> 00:02:00,399
format that allows to store different

48
00:02:00,399 --> 00:02:03,280
streams onto a single file

49
00:02:03,280 --> 00:02:05,920
while there's no public rfc document by

50
00:02:05,920 --> 00:02:08,560
microsoft for that format they open

51
00:02:08,560 --> 00:02:11,038
source the code for producing pdb files

52
00:02:11,038 --> 00:02:13,200
so non-microsoft compilers can produce

53
00:02:13,200 --> 00:02:15,200
them too

54
00:02:15,200 --> 00:02:17,440
the parser for pdb files is implemented

55
00:02:17,440 --> 00:02:19,440
in debughelp.dll

56
00:02:19,440 --> 00:02:21,599
which is a shared library that's shipped

57
00:02:21,599 --> 00:02:24,480
by windows by default on every windows

58
00:02:24,480 --> 00:02:25,760
installation

59
00:02:25,760 --> 00:02:28,560
and it provides an api to debug process

60
00:02:28,560 --> 00:02:31,519
load pdb files extract symbols data and

61
00:02:31,519 --> 00:02:33,760
so on

62
00:02:33,760 --> 00:02:36,319
so the initial goal for this project was

63
00:02:36,319 --> 00:02:38,160
trying to identify vulnerabilities in

64
00:02:38,160 --> 00:02:40,080
the pdb person code

65
00:02:40,080 --> 00:02:42,560
and the way i decided to do so is to use

66
00:02:42,560 --> 00:02:44,000
fuzzing

67
00:02:44,000 --> 00:02:45,920
and my fuzzing setup was quite

68
00:02:45,920 --> 00:02:47,360
straightforward

69
00:02:47,360 --> 00:02:49,760
i started by collecting a corpus or an

70
00:02:49,760 --> 00:02:52,239
initial set of valid pdb files from

71
00:02:52,239 --> 00:02:54,000
several sources

72
00:02:54,000 --> 00:02:56,640
then i coded my test harness program

73
00:02:56,640 --> 00:02:59,040
which is a program that simply loads a

74
00:02:59,040 --> 00:03:02,319
single pdb file from disk and parse it

75
00:03:02,319 --> 00:03:04,480
using the debug help seam load module

76
00:03:04,480 --> 00:03:06,400
api

77
00:03:06,400 --> 00:03:08,400
then i used the very well-known open

78
00:03:08,400 --> 00:03:11,200
source fuzzer called win afl to do the

79
00:03:11,200 --> 00:03:14,560
actual fuzzing and win nfl is a mutation

80
00:03:14,560 --> 00:03:17,280
based fuzzer and the basic workflow for

81
00:03:17,280 --> 00:03:19,360
mutation-based fuzzers is that they

82
00:03:19,360 --> 00:03:22,000
select a single input from the corpus

83
00:03:22,000 --> 00:03:24,000
they then create a new test case by

84
00:03:24,000 --> 00:03:26,720
mutating that sample doing things like

85
00:03:26,720 --> 00:03:28,879
bit flips and byte flips

86
00:03:28,879 --> 00:03:30,480
they run the test case through the test

87
00:03:30,480 --> 00:03:33,120
harness and check if it crashed and then

88
00:03:33,120 --> 00:03:36,799
repeats that process infinitely

89
00:03:36,799 --> 00:03:38,799
there are many optimizations when afl

90
00:03:38,799 --> 00:03:41,200
does on that basic workflow but i won't

91
00:03:41,200 --> 00:03:43,519
go into details about it right now

92
00:03:43,519 --> 00:03:46,720
because winfl is very well documented

93
00:03:46,720 --> 00:03:48,959
and this is not a fuzzy talk

94
00:03:48,959 --> 00:03:50,400
but what i want you to take away from

95
00:03:50,400 --> 00:03:51,760
here if you haven't done fuzzing

96
00:03:51,760 --> 00:03:54,239
yourself is that setting this up is very

97
00:03:54,239 --> 00:03:56,640
simple and in a couple of hours

98
00:03:56,640 --> 00:03:58,959
collecting a corpus and writing the test

99
00:03:58,959 --> 00:04:01,760
harness in the way when afl expects you

100
00:04:01,760 --> 00:04:03,920
can bootstrap your fuzzing campaign and

101
00:04:03,920 --> 00:04:06,319
this requires no much knowledge of the

102
00:04:06,319 --> 00:04:09,519
pdb file format at that stage

103
00:04:09,519 --> 00:04:12,480
and here is win afl's dashboard from

104
00:04:12,480 --> 00:04:15,360
fuzzing the pdb parser on a single core

105
00:04:15,360 --> 00:04:17,839
for three days and as you can see it

106
00:04:17,839 --> 00:04:20,399
discovered over 200 different crashes in

107
00:04:20,399 --> 00:04:23,600
that fuzzer in that parser

108
00:04:23,600 --> 00:04:24,960
so

109
00:04:24,960 --> 00:04:26,479
that was a pretty good starting point

110
00:04:26,479 --> 00:04:29,199
for that project and then i decided to

111
00:04:29,199 --> 00:04:31,120
look for an attack surface to exploit

112
00:04:31,120 --> 00:04:32,400
those bugs

113
00:04:32,400 --> 00:04:34,479
and my initial talk was to use remote

114
00:04:34,479 --> 00:04:36,080
symbol servers

115
00:04:36,080 --> 00:04:38,160
remote symbol servers is a feature of

116
00:04:38,160 --> 00:04:41,280
debuggers when you debug some program

117
00:04:41,280 --> 00:04:43,199
you can set the path to remote symbol

118
00:04:43,199 --> 00:04:46,479
server either by http or smb

119
00:04:46,479 --> 00:04:48,639
and then the debugger would fetch simple

120
00:04:48,639 --> 00:04:50,880
files from that server throughout the

121
00:04:50,880 --> 00:04:52,800
debugging session

122
00:04:52,800 --> 00:04:55,360
the most common pdb symbol server in the

123
00:04:55,360 --> 00:04:58,080
world is probably microsoft symbol

124
00:04:58,080 --> 00:05:01,120
server which hosts the binaries the pdb

125
00:05:01,120 --> 00:05:03,360
files for most binaries ever shipped

126
00:05:03,360 --> 00:05:04,720
with windows

127
00:05:04,720 --> 00:05:06,639
but many software development groups

128
00:05:06,639 --> 00:05:09,440
have their own internal pdb server where

129
00:05:09,440 --> 00:05:12,080
they push symbols to their software

130
00:05:12,080 --> 00:05:14,639
throughout the cicd process

131
00:05:14,639 --> 00:05:16,160
and my thought was that given the

132
00:05:16,160 --> 00:05:18,400
attacker controls or many in the middle

133
00:05:18,400 --> 00:05:19,600
the connection

134
00:05:19,600 --> 00:05:21,199
between the victim machine and that

135
00:05:21,199 --> 00:05:23,600
symbol server he could serve arbitrary

136
00:05:23,600 --> 00:05:26,639
pdbs and crush or exploit the victim's

137
00:05:26,639 --> 00:05:29,280
debugger remotely

138
00:05:29,280 --> 00:05:31,120
this is a screenshot showing that

139
00:05:31,120 --> 00:05:33,680
actually works i was debugging notepad

140
00:05:33,680 --> 00:05:35,919
with that wind debug below setting the

141
00:05:35,919 --> 00:05:38,960
sim pad to remote server by smb and then

142
00:05:38,960 --> 00:05:41,600
loading one of the pdb files when afl

143
00:05:41,600 --> 00:05:42,880
discovered

144
00:05:42,880 --> 00:05:45,600
and as you can see that debugger itself

145
00:05:45,600 --> 00:05:48,080
crashed with an access validation in the

146
00:05:48,080 --> 00:05:50,080
pdb parsing code

147
00:05:50,080 --> 00:05:51,680
so this shows that the attack surface

148
00:05:51,680 --> 00:05:52,800
can work

149
00:05:52,800 --> 00:05:55,039
and at this point and this was about a

150
00:05:55,039 --> 00:05:57,520
year ago i decided to report that issue

151
00:05:57,520 --> 00:05:59,840
to microsoft msrc

152
00:05:59,840 --> 00:06:02,000
i chose one of the pdb files that seemed

153
00:06:02,000 --> 00:06:04,479
more likely to be exploited and reported

154
00:06:04,479 --> 00:06:07,840
that info along with the attack surface

155
00:06:07,840 --> 00:06:10,000
and microsoft replied about a month

156
00:06:10,000 --> 00:06:12,319
later saying that this bug doesn't meet

157
00:06:12,319 --> 00:06:14,800
the bar for security servicing and they

158
00:06:14,800 --> 00:06:17,440
closed that case

159
00:06:17,440 --> 00:06:19,759
my understanding from the reply is that

160
00:06:19,759 --> 00:06:21,520
the reason why is that they thought the

161
00:06:21,520 --> 00:06:24,080
attack surface is too complex or too

162
00:06:24,080 --> 00:06:25,600
unlikely

163
00:06:25,600 --> 00:06:27,440
and as you can see they said that the

164
00:06:27,440 --> 00:06:28,880
attacker would have to control the

165
00:06:28,880 --> 00:06:30,720
symbol servers or man in the middle of

166
00:06:30,720 --> 00:06:32,479
the connection and the victim would have

167
00:06:32,479 --> 00:06:34,880
to manually load the pdb file from that

168
00:06:34,880 --> 00:06:36,479
server

169
00:06:36,479 --> 00:06:38,400
and they did say they are likely going

170
00:06:38,400 --> 00:06:40,319
to fix that in some future product

171
00:06:40,319 --> 00:06:42,720
release but no cve is going to be

172
00:06:42,720 --> 00:06:44,479
assigned

173
00:06:44,479 --> 00:06:46,240
so at this point i left this project

174
00:06:46,240 --> 00:06:48,319
aside for a while and didn't report the

175
00:06:48,319 --> 00:06:50,160
other bugs to microsoft because they

176
00:06:50,160 --> 00:06:52,560
didn't seem to be interested

177
00:06:52,560 --> 00:06:54,720
but then following a conversation with a

178
00:06:54,720 --> 00:06:57,120
friend of mine i realized that they

179
00:06:57,120 --> 00:06:58,800
rejected this because of the attack

180
00:06:58,800 --> 00:06:59,840
surface

181
00:06:59,840 --> 00:07:02,000
so maybe i should look for other attack

182
00:07:02,000 --> 00:07:03,199
surfaces

183
00:07:03,199 --> 00:07:05,039
maybe there are other flows or other

184
00:07:05,039 --> 00:07:07,759
components in windows that parse pdb

185
00:07:07,759 --> 00:07:08,720
files

186
00:07:08,720 --> 00:07:10,560
and it doesn't necessarily have to be a

187
00:07:10,560 --> 00:07:12,960
remote code execution flow maybe there

188
00:07:12,960 --> 00:07:16,240
is some privilege service or process

189
00:07:16,240 --> 00:07:18,880
that loads pdb files from disk that i

190
00:07:18,880 --> 00:07:21,120
can exploit for elevating privileges on

191
00:07:21,120 --> 00:07:23,280
a local machine

192
00:07:23,280 --> 00:07:24,960
and the way i approached this was very

193
00:07:24,960 --> 00:07:27,360
simple i started by doing a text search

194
00:07:27,360 --> 00:07:29,360
for the stream debug help in all

195
00:07:29,360 --> 00:07:30,960
binaries under the same windows

196
00:07:30,960 --> 00:07:32,400
directory

197
00:07:32,400 --> 00:07:34,560
and that search will dead about 30

198
00:07:34,560 --> 00:07:37,440
different executables and two of them

199
00:07:37,440 --> 00:07:39,840
immediately caught my attention those

200
00:07:39,840 --> 00:07:43,120
are fault wrap.dll and wear.dll

201
00:07:43,120 --> 00:07:45,280
and the reason why is they are part of

202
00:07:45,280 --> 00:07:47,840
the windows aero reporting suit which is

203
00:07:47,840 --> 00:07:50,080
a component of windows which already

204
00:07:50,080 --> 00:07:52,240
researched into quite depth in the last

205
00:07:52,240 --> 00:07:54,720
two years discovering over 15 different

206
00:07:54,720 --> 00:07:56,479
vulnerabilities in it

207
00:07:56,479 --> 00:07:58,319
and you can check out my blue talk from

208
00:07:58,319 --> 00:08:00,400
last year if you're interested in that

209
00:08:00,400 --> 00:08:02,080
topic

210
00:08:02,080 --> 00:08:04,000
so let me do a quick recap of how

211
00:08:04,000 --> 00:08:06,240
windows error reporting works

212
00:08:06,240 --> 00:08:08,000
windows error report in purpose is to

213
00:08:08,000 --> 00:08:10,000
collect information regarding crashes or

214
00:08:10,000 --> 00:08:12,639
hangs in a windows endpoint and report

215
00:08:12,639 --> 00:08:14,639
them to microsoft cloud for further

216
00:08:14,639 --> 00:08:17,680
diagnostics and the way it works is that

217
00:08:17,680 --> 00:08:19,840
each time a process crash

218
00:08:19,840 --> 00:08:22,160
from its exception handler it talks

219
00:08:22,160 --> 00:08:25,199
through alpc to where svc the windows

220
00:08:25,199 --> 00:08:27,520
error reporting service pretty much

221
00:08:27,520 --> 00:08:29,759
saying hey where's vc i am about to

222
00:08:29,759 --> 00:08:31,360
crush

223
00:08:31,360 --> 00:08:33,519
where's vcn10 will end up calling the

224
00:08:33,519 --> 00:08:36,640
function create processes user to spawn

225
00:08:36,640 --> 00:08:39,039
a new instance of a worker process

226
00:08:39,039 --> 00:08:41,599
called warfall.exe

227
00:08:41,599 --> 00:08:45,040
warfall.exe in turn would actually read

228
00:08:45,040 --> 00:08:47,040
the data from that crashing process

229
00:08:47,040 --> 00:08:49,600
producing that crash report and report

230
00:08:49,600 --> 00:08:51,519
it to microsoft

231
00:08:51,519 --> 00:08:53,600
now despite the fact that where svc is

232
00:08:53,600 --> 00:08:55,920
the one creating wareholt it creates it

233
00:08:55,920 --> 00:08:58,080
as a child process of that crushing

234
00:08:58,080 --> 00:09:01,839
process rather than of its own

235
00:09:01,839 --> 00:09:04,080
i reverse engineer webfall to see how it

236
00:09:04,080 --> 00:09:06,640
used debug help and i found out that it

237
00:09:06,640 --> 00:09:08,800
is being used to parse the stack trace

238
00:09:08,800 --> 00:09:11,200
of the crushing thread in that crushing

239
00:09:11,200 --> 00:09:12,240
process

240
00:09:12,240 --> 00:09:14,399
and then it produces a stack phrase hash

241
00:09:14,399 --> 00:09:16,640
based on it and adds it on top of the

242
00:09:16,640 --> 00:09:18,720
error report

243
00:09:18,720 --> 00:09:20,480
and i guess the reason why is that

244
00:09:20,480 --> 00:09:21,920
microsoft are getting millions of

245
00:09:21,920 --> 00:09:24,080
crashes a day and they want to be able

246
00:09:24,080 --> 00:09:27,920
to group those crashes by stacked race

247
00:09:27,920 --> 00:09:30,080
so that's the actual soda code from

248
00:09:30,080 --> 00:09:32,480
warefold showing the usage of the bug

249
00:09:32,480 --> 00:09:33,360
help

250
00:09:33,360 --> 00:09:35,440
and it is used in a function called util

251
00:09:35,440 --> 00:09:37,600
gut stack trace which gets the process

252
00:09:37,600 --> 00:09:40,480
id and thread id of the crashing process

253
00:09:40,480 --> 00:09:42,880
it then opens that process with all

254
00:09:42,880 --> 00:09:45,600
access and passes the handle to that

255
00:09:45,600 --> 00:09:48,800
process onto the debug help function sim

256
00:09:48,800 --> 00:09:50,720
initialize

257
00:09:50,720 --> 00:09:52,720
the purpose of sim initialize is to

258
00:09:52,720 --> 00:09:55,360
initialize the symbols handler for that

259
00:09:55,360 --> 00:09:57,760
specific crushing process

260
00:09:57,760 --> 00:10:00,240
later on wherefold will end up calling

261
00:10:00,240 --> 00:10:02,640
the function stack walk in a loop

262
00:10:02,640 --> 00:10:05,360
obtaining one stack frame at a time from

263
00:10:05,360 --> 00:10:08,000
that crushing process

264
00:10:08,000 --> 00:10:09,680
now one thing we have to more carefully

265
00:10:09,680 --> 00:10:12,079
examine is the third argument to sim

266
00:10:12,079 --> 00:10:14,880
initialize which is a boolean flag

267
00:10:14,880 --> 00:10:17,600
called f invade process

268
00:10:17,600 --> 00:10:20,240
f invite process is set to true by where

269
00:10:20,240 --> 00:10:22,959
fault and that means that at that time

270
00:10:22,959 --> 00:10:25,600
sim initialize would try to load the pdb

271
00:10:25,600 --> 00:10:28,720
file for every loaded module or dll in

272
00:10:28,720 --> 00:10:31,279
that crashing process

273
00:10:31,279 --> 00:10:33,440
and you can see it here in that process

274
00:10:33,440 --> 00:10:36,480
monitor snipped where i crashed notepad

275
00:10:36,480 --> 00:10:38,880
and the warehole handling that crush

276
00:10:38,880 --> 00:10:41,519
try to load the pdb file from notepad

277
00:10:41,519 --> 00:10:45,519
ntdl kernel 32 kernel base and it will

278
00:10:45,519 --> 00:10:48,079
do that for every module loaded into

279
00:10:48,079 --> 00:10:50,399
notepad

280
00:10:50,399 --> 00:10:52,560
so now that we know that warehold parse

281
00:10:52,560 --> 00:10:55,040
pdb files let's discuss what permissions

282
00:10:55,040 --> 00:10:57,680
or privileges warehold runs as

283
00:10:57,680 --> 00:11:00,320
and warfald usually runs with the same

284
00:11:00,320 --> 00:11:03,120
permissions as of the crushing process

285
00:11:03,120 --> 00:11:04,880
and this makes sense because it has to

286
00:11:04,880 --> 00:11:07,120
open that process and read its memory in

287
00:11:07,120 --> 00:11:09,440
order to produce the cross report

288
00:11:09,440 --> 00:11:11,360
but there's one exception for that which

289
00:11:11,360 --> 00:11:13,440
i was already familiar with at that

290
00:11:13,440 --> 00:11:15,440
point because i discovered another

291
00:11:15,440 --> 00:11:17,839
vulnerability in that flow

292
00:11:17,839 --> 00:11:18,640
and

293
00:11:18,640 --> 00:11:20,800
if the crushing process runs under the

294
00:11:20,800 --> 00:11:23,279
low integrity level then the werefold

295
00:11:23,279 --> 00:11:25,680
handling that crush runs under medium

296
00:11:25,680 --> 00:11:29,920
integrity level which is more privileged

297
00:11:29,920 --> 00:11:32,079
so for non-windows folks let's discuss

298
00:11:32,079 --> 00:11:34,880
what are integrity levels and integrity

299
00:11:34,880 --> 00:11:37,519
levels is a feature that was introduced

300
00:11:37,519 --> 00:11:39,839
by microsoft at windows vista because

301
00:11:39,839 --> 00:11:42,160
they realized that most users run as

302
00:11:42,160 --> 00:11:44,079
local administrator accounts on their

303
00:11:44,079 --> 00:11:46,160
machines and that means that if an

304
00:11:46,160 --> 00:11:48,160
attacker exploits vulnerability in the

305
00:11:48,160 --> 00:11:51,120
context of a process running as local

306
00:11:51,120 --> 00:11:53,760
administrator it completely owns that

307
00:11:53,760 --> 00:11:54,959
system

308
00:11:54,959 --> 00:11:56,639
and microsoft wanted to come up with

309
00:11:56,639 --> 00:11:58,959
some mechanism to further restrict

310
00:11:58,959 --> 00:12:02,000
processes or contact sets that run under

311
00:12:02,000 --> 00:12:04,800
the same user accounts

312
00:12:04,800 --> 00:12:06,959
this is a process explorer snipped from

313
00:12:06,959 --> 00:12:10,279
my windows 10 machine and as you can see

314
00:12:10,279 --> 00:12:12,639
explorer.exe the windows shell for

315
00:12:12,639 --> 00:12:15,360
instance runs under medium integrity

316
00:12:15,360 --> 00:12:18,160
under my account as opposed to process

317
00:12:18,160 --> 00:12:20,959
explorer itself which runs under high

318
00:12:20,959 --> 00:12:24,720
integrity level which is more privileged

319
00:12:24,720 --> 00:12:27,279
now the law integrity is usually used

320
00:12:27,279 --> 00:12:29,680
for application sandboxing

321
00:12:29,680 --> 00:12:31,760
for instance the internet explorer

322
00:12:31,760 --> 00:12:34,320
renderer processes run under low

323
00:12:34,320 --> 00:12:35,839
integrity level

324
00:12:35,839 --> 00:12:38,160
those processes render all the html and

325
00:12:38,160 --> 00:12:40,560
javascript provided by remote http

326
00:12:40,560 --> 00:12:42,880
servers which is a logic that's very

327
00:12:42,880 --> 00:12:44,480
much likely to have security

328
00:12:44,480 --> 00:12:46,160
vulnerabilities in

329
00:12:46,160 --> 00:12:48,880
so microsoft wanted to restrict those

330
00:12:48,880 --> 00:12:51,120
processes and if an attacker exploits a

331
00:12:51,120 --> 00:12:53,440
vulnerability in that context you'd only

332
00:12:53,440 --> 00:12:55,680
run at low integrity and be limited with

333
00:12:55,680 --> 00:12:58,079
what you can do to that system

334
00:12:58,079 --> 00:13:00,240
so browser exploit chains nowadays

335
00:13:00,240 --> 00:13:03,360
usually chain a renderer rc exploit

336
00:13:03,360 --> 00:13:06,000
followed by another bug to escape the

337
00:13:06,000 --> 00:13:07,680
sandbox

338
00:13:07,680 --> 00:13:10,000
and that's the game plan for our attack

339
00:13:10,000 --> 00:13:11,839
surface this is exactly what i'm going

340
00:13:11,839 --> 00:13:14,240
to try to achieve elevate privileges

341
00:13:14,240 --> 00:13:17,839
from low integrity to medium integrity

342
00:13:17,839 --> 00:13:19,920
and i'd assume i'll already run code at

343
00:13:19,920 --> 00:13:22,320
native level on low integrity on the

344
00:13:22,320 --> 00:13:24,399
system that i'm exploiting

345
00:13:24,399 --> 00:13:27,040
so from that low integrity process i'd

346
00:13:27,040 --> 00:13:29,600
write the malphone pdb file discovered

347
00:13:29,600 --> 00:13:30,959
to disk

348
00:13:30,959 --> 00:13:33,440
then i crash my own process which will

349
00:13:33,440 --> 00:13:35,760
spawn where fault at medium integrity to

350
00:13:35,760 --> 00:13:37,360
handle that crash

351
00:13:37,360 --> 00:13:39,760
and hopefully that instance of warehouse

352
00:13:39,760 --> 00:13:42,639
would load the pdb file from disk and

353
00:13:42,639 --> 00:13:44,800
the pdb parsing bug would be triggered

354
00:13:44,800 --> 00:13:47,680
in its context and if i exploit that i

355
00:13:47,680 --> 00:13:50,560
could elevate privileges

356
00:13:50,560 --> 00:13:52,399
so to do so there's one problem i have

357
00:13:52,399 --> 00:13:53,920
to solve

358
00:13:53,920 --> 00:13:56,720
i cannot write to most paths on disk as

359
00:13:56,720 --> 00:13:59,440
low integrity and this is one of the

360
00:13:59,440 --> 00:14:01,760
basic restrictions that no integrity

361
00:14:01,760 --> 00:14:02,639
level

362
00:14:02,639 --> 00:14:04,000
poses

363
00:14:04,000 --> 00:14:05,680
so

364
00:14:05,680 --> 00:14:07,120
there are a few directories that are

365
00:14:07,120 --> 00:14:09,600
writable by intention like the app data

366
00:14:09,600 --> 00:14:11,839
local load directory and are the users

367
00:14:11,839 --> 00:14:14,800
directory so i can write my malform pdb

368
00:14:14,800 --> 00:14:17,600
files to that directory but how can i

369
00:14:17,600 --> 00:14:20,720
get wherefold to load it from there

370
00:14:20,720 --> 00:14:22,880
and apparently there's a very easy

371
00:14:22,880 --> 00:14:24,560
workaround for that

372
00:14:24,560 --> 00:14:26,800
when you compile some binary the

373
00:14:26,800 --> 00:14:29,440
compiler puts the path to the pdb file

374
00:14:29,440 --> 00:14:32,320
at the time of compilation onto the pe

375
00:14:32,320 --> 00:14:35,120
executable header of that binary

376
00:14:35,120 --> 00:14:36,959
and if you later debug your code on the

377
00:14:36,959 --> 00:14:39,120
same machine you compiled it then the

378
00:14:39,120 --> 00:14:40,880
debugger would know where to fetch that

379
00:14:40,880 --> 00:14:42,800
pdb file from

380
00:14:42,800 --> 00:14:45,120
and apparently the bug help honors that

381
00:14:45,120 --> 00:14:47,600
value which means that given that i can

382
00:14:47,600 --> 00:14:49,760
run my own executable at low

383
00:14:49,760 --> 00:14:52,399
intermediate level i could set the pdb

384
00:14:52,399 --> 00:14:55,279
file path on that pe header onto the app

385
00:14:55,279 --> 00:14:57,600
data local load directory and wherefall

386
00:14:57,600 --> 00:15:00,720
would load the pdb file from there

387
00:15:00,720 --> 00:15:04,160
and you can see it here in this snipped

388
00:15:04,160 --> 00:15:06,079
and the process explorer snipped above i

389
00:15:06,079 --> 00:15:09,279
ran self crash at low integrity and when

390
00:15:09,279 --> 00:15:11,040
it crashed it spawned wherefold on

391
00:15:11,040 --> 00:15:13,440
medium integrity to handle that crash

392
00:15:13,440 --> 00:15:15,600
and the windy bug's name below

393
00:15:15,600 --> 00:15:18,320
is debugging that instance of wherefold

394
00:15:18,320 --> 00:15:21,120
and as you can see warehold crashed with

395
00:15:21,120 --> 00:15:23,519
an access violation in the pdb parsing

396
00:15:23,519 --> 00:15:25,760
code at medium integrity

397
00:15:25,760 --> 00:15:28,240
which shows that this attack surface in

398
00:15:28,240 --> 00:15:30,639
fact works and can be used to elevate

399
00:15:30,639 --> 00:15:33,120
privileges

400
00:15:33,120 --> 00:15:34,880
so now let's start the second part of

401
00:15:34,880 --> 00:15:37,680
this talk where i discussed into depth

402
00:15:37,680 --> 00:15:40,160
one of the pdb parsing bugs in debug

403
00:15:40,160 --> 00:15:43,120
help and how it can be exploited in that

404
00:15:43,120 --> 00:15:44,720
context

405
00:15:44,720 --> 00:15:47,519
so this is a very simplified soda code

406
00:15:47,519 --> 00:15:50,480
of the bug in debug help

407
00:15:50,480 --> 00:15:53,279
first some integer index value is read

408
00:15:53,279 --> 00:15:55,920
directly from that pdb file

409
00:15:55,920 --> 00:15:58,639
and attacker has full control over that

410
00:15:58,639 --> 00:16:00,000
value

411
00:16:00,000 --> 00:16:01,920
then there are certain checks on that

412
00:16:01,920 --> 00:16:04,480
index which we'll discuss later on

413
00:16:04,480 --> 00:16:06,720
and that index is used to select an

414
00:16:06,720 --> 00:16:08,720
object from an array of objects that's

415
00:16:08,720 --> 00:16:11,680
already been initialized at that point

416
00:16:11,680 --> 00:16:14,639
but that index value is not used as is

417
00:16:14,639 --> 00:16:17,360
but the value 1 is subtracted from that

418
00:16:17,360 --> 00:16:18,720
index value

419
00:16:18,720 --> 00:16:20,639
and the reason why is that this is a one

420
00:16:20,639 --> 00:16:23,120
based index onto the array while array

421
00:16:23,120 --> 00:16:26,079
access in cnc plus plus is a zero based

422
00:16:26,079 --> 00:16:27,040
access

423
00:16:27,040 --> 00:16:30,959
so debugger had to correlate the two

424
00:16:30,959 --> 00:16:33,279
finally on that selected object a

425
00:16:33,279 --> 00:16:36,720
virtual function call is being called

426
00:16:36,720 --> 00:16:39,920
now microsoft did have a few checks on

427
00:16:39,920 --> 00:16:42,000
that index value to make sure that it

428
00:16:42,000 --> 00:16:44,000
doesn't go out of bound of the array and

429
00:16:44,000 --> 00:16:46,880
its value is not too high or too low

430
00:16:46,880 --> 00:16:48,560
but they were missing a check for the

431
00:16:48,560 --> 00:16:51,920
value of zero and if that index value is

432
00:16:51,920 --> 00:16:54,320
zero this one is still subtracted from

433
00:16:54,320 --> 00:16:57,360
that index and the negative one cell of

434
00:16:57,360 --> 00:17:00,079
the array is going to be selected and

435
00:17:00,079 --> 00:17:01,519
this results in a type confusion

436
00:17:01,519 --> 00:17:04,400
vulnerability confusing whatever data we

437
00:17:04,400 --> 00:17:07,280
have just prior to that array

438
00:17:07,280 --> 00:17:10,160
with an object pointer

439
00:17:10,160 --> 00:17:12,240
so what's on the negative one index of

440
00:17:12,240 --> 00:17:13,599
that array

441
00:17:13,599 --> 00:17:15,760
i found out that that array itself is

442
00:17:15,760 --> 00:17:18,959
allocated on the windows hip and prior

443
00:17:18,959 --> 00:17:21,599
to every hip location you have the hip

444
00:17:21,599 --> 00:17:23,839
header which describes some metadata

445
00:17:23,839 --> 00:17:26,400
regarding that specific location

446
00:17:26,400 --> 00:17:28,319
and that means that the only primitive

447
00:17:28,319 --> 00:17:31,280
that this bug allows is to type confuse

448
00:17:31,280 --> 00:17:34,960
the hip header with an object pointer

449
00:17:34,960 --> 00:17:36,400
so i decided to take a look at what the

450
00:17:36,400 --> 00:17:38,240
heap header looks like

451
00:17:38,240 --> 00:17:40,799
and it is an eight bytes header prior to

452
00:17:40,799 --> 00:17:42,640
every hip allocation

453
00:17:42,640 --> 00:17:44,559
and given that i try to exploit that

454
00:17:44,559 --> 00:17:47,039
vulnerability in the context of a 32-bit

455
00:17:47,039 --> 00:17:49,600
process which i promise i will later

456
00:17:49,600 --> 00:17:51,120
tell you why

457
00:17:51,120 --> 00:17:52,720
this means that i'm going to treat the

458
00:17:52,720 --> 00:17:55,520
lower part the lower d word or four

459
00:17:55,520 --> 00:17:58,160
bytes of that header as an object

460
00:17:58,160 --> 00:18:00,080
pointer

461
00:18:00,080 --> 00:18:03,120
so the hip entry structure describes the

462
00:18:03,120 --> 00:18:04,000
actual

463
00:18:04,000 --> 00:18:07,520
struct of that hip header and as you can

464
00:18:07,520 --> 00:18:10,320
see those last four byte meaning is the

465
00:18:10,320 --> 00:18:13,360
previous size segment offset and unused

466
00:18:13,360 --> 00:18:17,039
bytes part of that hipaa location

467
00:18:17,039 --> 00:18:19,280
and my initial toll was that maybe i can

468
00:18:19,280 --> 00:18:22,640
control or predict those values somehow

469
00:18:22,640 --> 00:18:24,400
because i do have a certain degree of

470
00:18:24,400 --> 00:18:27,120
control over the objects array

471
00:18:27,120 --> 00:18:29,120
but then i found out that windows has a

472
00:18:29,120 --> 00:18:31,280
feature that's called hip encoding that

473
00:18:31,280 --> 00:18:33,760
prevents me from doing so

474
00:18:33,760 --> 00:18:35,919
hip encoding is a security cookie-like

475
00:18:35,919 --> 00:18:38,000
feature that aims to prevent

476
00:18:38,000 --> 00:18:39,760
exploitation of hip overrun

477
00:18:39,760 --> 00:18:41,280
vulnerabilities

478
00:18:41,280 --> 00:18:42,880
and the way it works is that the

479
00:18:42,880 --> 00:18:46,480
allocator encodes or source the value of

480
00:18:46,480 --> 00:18:49,360
the hip headers in memory with a random

481
00:18:49,360 --> 00:18:50,960
sort key

482
00:18:50,960 --> 00:18:53,919
and what that poses on attackers imagine

483
00:18:53,919 --> 00:18:56,080
in the past they had a primitive to

484
00:18:56,080 --> 00:18:57,520
overflow the hip

485
00:18:57,520 --> 00:19:00,400
so what they used to do is to

486
00:19:00,400 --> 00:19:04,000
override the adjacent or next hip header

487
00:19:04,000 --> 00:19:05,600
for the next chunk

488
00:19:05,600 --> 00:19:08,000
and set it to arbitrary values and there

489
00:19:08,000 --> 00:19:09,840
were pretty good exploitation primitives

490
00:19:09,840 --> 00:19:11,840
you could construct with that

491
00:19:11,840 --> 00:19:14,400
but given that hip encoding feature

492
00:19:14,400 --> 00:19:16,480
unless they leak that

493
00:19:16,480 --> 00:19:20,080
random key they cannot do so

494
00:19:20,080 --> 00:19:22,080
so the key itself is an 8 byte key

495
00:19:22,080 --> 00:19:24,960
that's generated per hip at runtime in

496
00:19:24,960 --> 00:19:28,400
the empty dll rtlp create encoding

497
00:19:28,400 --> 00:19:29,760
function

498
00:19:29,760 --> 00:19:31,440
but i found out that there's a weakness

499
00:19:31,440 --> 00:19:34,160
in its in its implementation

500
00:19:34,160 --> 00:19:36,840
and part of that key is always set to

501
00:19:36,840 --> 00:19:40,480
zeros more specifically the higher two

502
00:19:40,480 --> 00:19:43,200
bytes of the lower part of that header

503
00:19:43,200 --> 00:19:44,960
are set to zero

504
00:19:44,960 --> 00:19:46,960
and if you recall if you saw something

505
00:19:46,960 --> 00:19:49,200
with zero then its value would remain

506
00:19:49,200 --> 00:19:52,080
clear text and that means that microsoft

507
00:19:52,080 --> 00:19:54,799
wanted to keep those two bytes of their

508
00:19:54,799 --> 00:19:56,559
original content

509
00:19:56,559 --> 00:19:59,440
and not encoded and i'm not really sure

510
00:19:59,440 --> 00:20:02,080
why it could be for some compatibility

511
00:20:02,080 --> 00:20:06,480
reason or for some optimization

512
00:20:06,480 --> 00:20:08,960
given that is the hip header value

513
00:20:08,960 --> 00:20:10,640
predictable

514
00:20:10,640 --> 00:20:13,919
now imagine this is the content of that

515
00:20:13,919 --> 00:20:15,200
hip header

516
00:20:15,200 --> 00:20:17,360
so the fake object pointer is going to

517
00:20:17,360 --> 00:20:20,799
be treated as its lower part and the

518
00:20:20,799 --> 00:20:23,360
most significant bite in that fake

519
00:20:23,360 --> 00:20:26,720
pointer meaning is the unused bytes part

520
00:20:26,720 --> 00:20:28,960
of that hip buffer

521
00:20:28,960 --> 00:20:30,480
and unused bytes

522
00:20:30,480 --> 00:20:32,400
meaning is the difference between the

523
00:20:32,400 --> 00:20:35,120
size the user asked for when he

524
00:20:35,120 --> 00:20:37,760
allocated that hip chunk and the size of

525
00:20:37,760 --> 00:20:39,760
buffer he actually got because there

526
00:20:39,760 --> 00:20:41,760
might be a difference between the two

527
00:20:41,760 --> 00:20:43,840
depending on how the allocator manages

528
00:20:43,840 --> 00:20:45,039
the hip

529
00:20:45,039 --> 00:20:49,039
and that value remains of clear text and

530
00:20:49,039 --> 00:20:51,760
i found out that for object array which

531
00:20:51,760 --> 00:20:54,320
is a very small location from my test

532
00:20:54,320 --> 00:20:55,120
case

533
00:20:55,120 --> 00:20:57,679
it only consists three pointers or 12

534
00:20:57,679 --> 00:20:59,039
bytes in size

535
00:20:59,039 --> 00:21:01,360
then the unused bytes part of that

536
00:21:01,360 --> 00:21:03,919
header is predictable and most of the

537
00:21:03,919 --> 00:21:07,760
times would be equal to the value of 18

538
00:21:07,760 --> 00:21:10,240
and this means that despite the fact i

539
00:21:10,240 --> 00:21:12,960
cannot fully predict the content of that

540
00:21:12,960 --> 00:21:16,000
fake object pointer i can tell for sure

541
00:21:16,000 --> 00:21:18,240
that it would only only point to a low

542
00:21:18,240 --> 00:21:20,080
user mode address

543
00:21:20,080 --> 00:21:22,159
and as you'll see later on this is

544
00:21:22,159 --> 00:21:26,159
sufficient for me to exploit this bug

545
00:21:26,159 --> 00:21:28,240
now what i'm trying to achieve here is

546
00:21:28,240 --> 00:21:30,720
to set the index value to zero which

547
00:21:30,720 --> 00:21:32,400
would trigger the type confusion

548
00:21:32,400 --> 00:21:33,760
vulnerability

549
00:21:33,760 --> 00:21:36,080
and then because a virtual function

550
00:21:36,080 --> 00:21:38,880
called is called upon that buffer a con

551
00:21:38,880 --> 00:21:42,159
opponent object that fake object pointer

552
00:21:42,159 --> 00:21:44,080
then this means that that value is going

553
00:21:44,080 --> 00:21:46,799
to be the reference twice to obtain the

554
00:21:46,799 --> 00:21:49,440
address of that virtual function

555
00:21:49,440 --> 00:21:51,679
and that address is likely not even

556
00:21:51,679 --> 00:21:54,240
allocated in the context of where fault

557
00:21:54,240 --> 00:21:57,280
so if as an attacker i'd be able to

558
00:21:57,280 --> 00:22:00,320
allocate it and control its content this

559
00:22:00,320 --> 00:22:01,840
means i'd be able to hijack the

560
00:22:01,840 --> 00:22:03,280
execution flow

561
00:22:03,280 --> 00:22:05,919
and trigger a primitive to call any

562
00:22:05,919 --> 00:22:08,320
absolute address i want in the context

563
00:22:08,320 --> 00:22:10,320
of wherefolds

564
00:22:10,320 --> 00:22:13,600
and to do that i've told you before

565
00:22:13,600 --> 00:22:15,679
why would i be exploiting this bug in

566
00:22:15,679 --> 00:22:18,159
the context of 32 bit

567
00:22:18,159 --> 00:22:20,480
and i found out that if a 32-bit

568
00:22:20,480 --> 00:22:23,840
executable crushes then the worse we see

569
00:22:23,840 --> 00:22:26,640
that spawns where fault for that crash

570
00:22:26,640 --> 00:22:29,840
handling would spawn the 32-bit version

571
00:22:29,840 --> 00:22:31,280
of warefold

572
00:22:31,280 --> 00:22:33,360
and that makes exploitation of this bug

573
00:22:33,360 --> 00:22:36,240
much easier because it is easier to

574
00:22:36,240 --> 00:22:39,039
spray the memory of a 32-bit address

575
00:22:39,039 --> 00:22:41,919
space versus to 64-bit which is much

576
00:22:41,919 --> 00:22:44,880
larger and also the allocators are way

577
00:22:44,880 --> 00:22:49,520
more predictable in their 32-bit version

578
00:22:49,520 --> 00:22:55,200
so how exactly would i spray the memory

579
00:22:55,200 --> 00:22:57,120
i had to come up with a primitive that

580
00:22:57,120 --> 00:22:59,039
allows me to alter somewhere false

581
00:22:59,039 --> 00:23:01,600
address space from that crashing process

582
00:23:01,600 --> 00:23:04,480
running at low integrity i can obviously

583
00:23:04,480 --> 00:23:07,600
cannot write to its memory directly

584
00:23:07,600 --> 00:23:09,600
directly because i run at a lower

585
00:23:09,600 --> 00:23:11,440
integrity level

586
00:23:11,440 --> 00:23:14,799
and if you recall i told you before that

587
00:23:14,799 --> 00:23:17,919
sim initialize loads the pdb files for

588
00:23:17,919 --> 00:23:20,000
all loaded modules in that crashing

589
00:23:20,000 --> 00:23:21,360
process

590
00:23:21,360 --> 00:23:23,520
so i decided to split my exploit

591
00:23:23,520 --> 00:23:26,720
functionality into two pdb files

592
00:23:26,720 --> 00:23:28,960
the first one would spray the address

593
00:23:28,960 --> 00:23:31,919
space of where fault and the second one

594
00:23:31,919 --> 00:23:33,919
would trigger the vulnerability in the

595
00:23:33,919 --> 00:23:36,159
context of fault

596
00:23:36,159 --> 00:23:38,400
and the reason why i chose to do so is

597
00:23:38,400 --> 00:23:41,440
that i have a lot of constraints on the

598
00:23:41,440 --> 00:23:44,080
pdb file that triggers the vulnerability

599
00:23:44,080 --> 00:23:46,400
its file format has to be

600
00:23:46,400 --> 00:23:48,080
in a certain way

601
00:23:48,080 --> 00:23:50,480
and i didn't want to solve those

602
00:23:50,480 --> 00:23:52,799
constraints along with the ability to

603
00:23:52,799 --> 00:23:55,679
spray the memory of wherefold from that

604
00:23:55,679 --> 00:23:57,200
same pdb file

605
00:23:57,200 --> 00:23:58,480
so this is why i split that

606
00:23:58,480 --> 00:24:00,640
functionality and i had to come up with

607
00:24:00,640 --> 00:24:04,799
a spray primitive from the first pdb

608
00:24:04,799 --> 00:24:07,919
so my initial attempt was to create a

609
00:24:07,919 --> 00:24:10,480
very large pdb file with some repeated

610
00:24:10,480 --> 00:24:13,440
pattern that i can look up in warehouse

611
00:24:13,440 --> 00:24:14,640
memory

612
00:24:14,640 --> 00:24:16,799
and i found out that debug help maps

613
00:24:16,799 --> 00:24:19,679
that entire pdb file into memory

614
00:24:19,679 --> 00:24:21,679
regardless of its size

615
00:24:21,679 --> 00:24:24,960
using the map view of file api

616
00:24:24,960 --> 00:24:28,320
and map viewer file maps memory at very

617
00:24:28,320 --> 00:24:31,039
predictable locations in 32-bit it would

618
00:24:31,039 --> 00:24:34,320
try to allocate the top most

619
00:24:34,320 --> 00:24:36,640
option with 64

620
00:24:36,640 --> 00:24:38,960
k bits alignment so that's quite

621
00:24:38,960 --> 00:24:40,720
predictable and that's pretty good from

622
00:24:40,720 --> 00:24:43,440
my spray primitive and i found out that

623
00:24:43,440 --> 00:24:46,720
the bug help doesn't unmap that pdb file

624
00:24:46,720 --> 00:24:49,440
from memory up until sim initialize

625
00:24:49,440 --> 00:24:52,960
exits even if the content of that pdb

626
00:24:52,960 --> 00:24:56,559
file is completely invalid and not a pdb

627
00:24:56,559 --> 00:24:58,559
file at all

628
00:24:58,559 --> 00:25:00,880
so this is really good for me because it

629
00:25:00,880 --> 00:25:02,799
means that by the time i trigger the

630
00:25:02,799 --> 00:25:05,840
vulnerability and the second pdb file is

631
00:25:05,840 --> 00:25:08,640
loaded the spread memory of the first

632
00:25:08,640 --> 00:25:11,919
pdb file remains in place which i can

633
00:25:11,919 --> 00:25:13,760
count off

634
00:25:13,760 --> 00:25:16,640
so how exactly is my exploit going to

635
00:25:16,640 --> 00:25:17,840
look like

636
00:25:17,840 --> 00:25:19,919
i'd start by running my code at low

637
00:25:19,919 --> 00:25:23,279
integrity and then i write two pdb files

638
00:25:23,279 --> 00:25:26,240
onto the disk to the appdata local loan

639
00:25:26,240 --> 00:25:27,600
directory

640
00:25:27,600 --> 00:25:31,039
spray dot pdb and trigger.pdb

641
00:25:31,039 --> 00:25:33,600
then i'd crush my own process at low

642
00:25:33,600 --> 00:25:35,919
integrity which would spawn an instance

643
00:25:35,919 --> 00:25:38,400
of where fault at medium integrity to

644
00:25:38,400 --> 00:25:40,640
handle that crash

645
00:25:40,640 --> 00:25:42,480
now the address space of where fault at

646
00:25:42,480 --> 00:25:45,200
that point is going to be quite clean

647
00:25:45,200 --> 00:25:48,080
because it is a newly created process

648
00:25:48,080 --> 00:25:50,320
and then it would call sim initialize

649
00:25:50,320 --> 00:25:52,559
with the handle from my own crushing

650
00:25:52,559 --> 00:25:54,799
process at low integrity

651
00:25:54,799 --> 00:25:57,279
and i would set it up in such a way that

652
00:25:57,279 --> 00:26:00,240
it would first load spray dot pdb and

653
00:26:00,240 --> 00:26:03,120
then would load trigger.pdb and i can

654
00:26:03,120 --> 00:26:05,760
control that because the pdbs are loaded

655
00:26:05,760 --> 00:26:08,000
by the order in the pebb

656
00:26:08,000 --> 00:26:10,880
ldr loaded modules list

657
00:26:10,880 --> 00:26:14,320
so spray dot pdb file would be first

658
00:26:14,320 --> 00:26:16,799
read and mapped into memory which would

659
00:26:16,799 --> 00:26:19,120
allocate a very large portion of the

660
00:26:19,120 --> 00:26:21,679
user mode address space of where fault

661
00:26:21,679 --> 00:26:24,559
with content that as an attacker i fully

662
00:26:24,559 --> 00:26:26,400
control

663
00:26:26,400 --> 00:26:28,960
then trigger.pdb file is going to be

664
00:26:28,960 --> 00:26:31,200
mapped into memory

665
00:26:31,200 --> 00:26:33,600
and that would trigger the pdb parsing

666
00:26:33,600 --> 00:26:35,279
vulnerability in the context of

667
00:26:35,279 --> 00:26:37,840
warehouse treating the hip header as an

668
00:26:37,840 --> 00:26:39,600
object pointer

669
00:26:39,600 --> 00:26:41,679
and hopefully that pointer being

670
00:26:41,679 --> 00:26:44,240
pointing to a very low user mode address

671
00:26:44,240 --> 00:26:47,120
is going to point somewhere onto my

672
00:26:47,120 --> 00:26:49,600
spray pdb file buffer and this means

673
00:26:49,600 --> 00:26:51,600
that i would have full control over the

674
00:26:51,600 --> 00:26:54,159
content of that object and i'd be able

675
00:26:54,159 --> 00:26:56,720
to hijack the execution flow and call

676
00:26:56,720 --> 00:26:58,640
any absolute address i want in the

677
00:26:58,640 --> 00:27:01,279
context of warehouse

678
00:27:01,279 --> 00:27:03,200
and this is a windy bug snipped

679
00:27:03,200 --> 00:27:07,200
debugging warehouse itself at that state

680
00:27:07,200 --> 00:27:09,520
proving that i can call any address i

681
00:27:09,520 --> 00:27:12,320
want as you can see the esi register

682
00:27:12,320 --> 00:27:13,679
points to the

683
00:27:13,679 --> 00:27:17,039
zero e0 address and i could set it to

684
00:27:17,039 --> 00:27:19,279
any arbitrary address i want at that

685
00:27:19,279 --> 00:27:21,679
point which means that i could hijack

686
00:27:21,679 --> 00:27:23,360
the flow

687
00:27:23,360 --> 00:27:25,200
but the next question would be where

688
00:27:25,200 --> 00:27:27,840
should i call to because my goal is to

689
00:27:27,840 --> 00:27:30,640
be able to execute arbitrary code

690
00:27:30,640 --> 00:27:32,640
at the context of warehouse

691
00:27:32,640 --> 00:27:34,960
and if you closely examined the slide

692
00:27:34,960 --> 00:27:38,480
before you probably see that cfg or

693
00:27:38,480 --> 00:27:40,640
control flow integrity which is a

694
00:27:40,640 --> 00:27:42,320
mitigation and microsoft added at

695
00:27:42,320 --> 00:27:43,760
windows 10

696
00:27:43,760 --> 00:27:47,600
windows 8 is enabled on warehouse

697
00:27:47,600 --> 00:27:49,760
and cfg is a control flow integrity

698
00:27:49,760 --> 00:27:53,120
mitigation that aims to prevent drop and

699
00:27:53,120 --> 00:27:54,799
code we use attacks

700
00:27:54,799 --> 00:27:56,960
and the way it works is that the

701
00:27:56,960 --> 00:27:59,760
compiler instruments every indirect call

702
00:27:59,760 --> 00:28:03,679
or jump and add a call to a to a stub in

703
00:28:03,679 --> 00:28:07,039
anti-dll which verifies that the call

704
00:28:07,039 --> 00:28:09,279
target was in fact supposed to be called

705
00:28:09,279 --> 00:28:10,720
indirectly

706
00:28:10,720 --> 00:28:13,440
and the pe itself manages all the

707
00:28:13,440 --> 00:28:16,240
locations that are supposed to be called

708
00:28:16,240 --> 00:28:18,799
in directory and the loader works with

709
00:28:18,799 --> 00:28:20,960
that list

710
00:28:20,960 --> 00:28:23,520
so i cannot just jump to a rock chain

711
00:28:23,520 --> 00:28:25,919
and pivot the stack as i used to do

712
00:28:25,919 --> 00:28:29,279
before with exploits prior to cfg

713
00:28:29,279 --> 00:28:32,080
but i found out that current32 load

714
00:28:32,080 --> 00:28:35,200
library is a valid cfg target at that

715
00:28:35,200 --> 00:28:37,919
context and this means i can simply call

716
00:28:37,919 --> 00:28:40,320
it a load library is a function that

717
00:28:40,320 --> 00:28:43,200
allows you to load a dll dynamically

718
00:28:43,200 --> 00:28:44,559
into the process

719
00:28:44,559 --> 00:28:47,120
so all i have to do is write another

720
00:28:47,120 --> 00:28:50,080
file a dll file into the appdata local

721
00:28:50,080 --> 00:28:51,440
load directory

722
00:28:51,440 --> 00:28:53,679
then have load library load it and run

723
00:28:53,679 --> 00:28:57,039
my payload from its entry point

724
00:28:57,039 --> 00:29:00,000
now aslr is not really an issue here and

725
00:29:00,000 --> 00:29:01,760
what i mean by that is that i have to

726
00:29:01,760 --> 00:29:03,919
find the address of load library at

727
00:29:03,919 --> 00:29:07,039
runtime and put it onto my spray pdb

728
00:29:07,039 --> 00:29:08,320
file

729
00:29:08,320 --> 00:29:10,799
but dls are loaded at the same base

730
00:29:10,799 --> 00:29:12,960
address at windows regardless of

731
00:29:12,960 --> 00:29:15,279
integrity level and this means that i

732
00:29:15,279 --> 00:29:17,520
can simply fetch the address of load

733
00:29:17,520 --> 00:29:20,480
library at runtime from my low integrity

734
00:29:20,480 --> 00:29:23,440
process and then build my spray buffer

735
00:29:23,440 --> 00:29:26,320
dynamically based on that address and

736
00:29:26,320 --> 00:29:29,760
put it onto my pdb file

737
00:29:29,760 --> 00:29:31,679
now the last thing i have to take care

738
00:29:31,679 --> 00:29:34,000
about is how to control the argument to

739
00:29:34,000 --> 00:29:36,399
load library because it is the path of

740
00:29:36,399 --> 00:29:39,440
the dll that's about to be loaded

741
00:29:39,440 --> 00:29:40,960
and there's a different calling

742
00:29:40,960 --> 00:29:43,440
convention between the original virtual

743
00:29:43,440 --> 00:29:45,360
function call and that call to load

744
00:29:45,360 --> 00:29:47,919
library which means that i don't control

745
00:29:47,919 --> 00:29:50,960
the argument pushed onto the stack

746
00:29:50,960 --> 00:29:53,279
but i found a workaround for that

747
00:29:53,279 --> 00:29:55,520
i found a gadget function in the bug

748
00:29:55,520 --> 00:29:59,440
help itself which is a valid call target

749
00:29:59,440 --> 00:30:02,080
and that function accepts one argument

750
00:30:02,080 --> 00:30:04,000
in as the this pointer which i do

751
00:30:04,000 --> 00:30:05,200
control

752
00:30:05,200 --> 00:30:08,000
and it reads some buffer from that

753
00:30:08,000 --> 00:30:11,200
object and pushes it back onto the stack

754
00:30:11,200 --> 00:30:13,200
then it also reads another function

755
00:30:13,200 --> 00:30:15,919
pointer from that same object and calls

756
00:30:15,919 --> 00:30:17,440
it indirectly

757
00:30:17,440 --> 00:30:19,600
again with cfgna build

758
00:30:19,600 --> 00:30:22,320
so all i had to do is to change the two

759
00:30:22,320 --> 00:30:24,559
i have my exploit called this gadget

760
00:30:24,559 --> 00:30:26,960
function which reorders the arguments

761
00:30:26,960 --> 00:30:29,520
and then it would call load library for

762
00:30:29,520 --> 00:30:31,360
me

763
00:30:31,360 --> 00:30:34,080
and this is a demo showing that actually

764
00:30:34,080 --> 00:30:35,200
works

765
00:30:35,200 --> 00:30:38,480
i start by running cmd as low integrity

766
00:30:38,480 --> 00:30:40,480
level which i'll show you by the output

767
00:30:40,480 --> 00:30:42,480
of the omi command

768
00:30:42,480 --> 00:30:44,480
then i go to the updater local load

769
00:30:44,480 --> 00:30:47,520
directory and run my exploit code from

770
00:30:47,520 --> 00:30:49,279
there

771
00:30:49,279 --> 00:30:51,360
as you can see that spawned another

772
00:30:51,360 --> 00:30:53,200
instance of cmd

773
00:30:53,200 --> 00:30:55,279
but this time it runs under medium

774
00:30:55,279 --> 00:30:57,600
integrity level which shows that i was

775
00:30:57,600 --> 00:31:01,200
able to elevate privileges from low to

776
00:31:01,200 --> 00:31:03,600
medium

777
00:31:03,600 --> 00:31:05,519
so now after we've seen the first demo

778
00:31:05,519 --> 00:31:08,000
for the stock i wanted to make thing a

779
00:31:08,000 --> 00:31:10,880
little bit harder and use that same

780
00:31:10,880 --> 00:31:13,519
exploit to escape the internet explorer

781
00:31:13,519 --> 00:31:15,840
enhanced protected mod sandbox

782
00:31:15,840 --> 00:31:17,919
now enhanced protected mode is a feature

783
00:31:17,919 --> 00:31:20,559
of internet explorer that is not enabled

784
00:31:20,559 --> 00:31:22,880
by default you have to check it through

785
00:31:22,880 --> 00:31:24,799
internet explorer settings

786
00:31:24,799 --> 00:31:26,960
and if you do so then the renderer

787
00:31:26,960 --> 00:31:30,080
processes run under app container

788
00:31:30,080 --> 00:31:32,640
which is an even more strict environment

789
00:31:32,640 --> 00:31:34,960
than the low integrity process

790
00:31:34,960 --> 00:31:37,120
but i don't have the time to go into the

791
00:31:37,120 --> 00:31:39,600
exact details of how app container works

792
00:31:39,600 --> 00:31:41,679
so i won't discuss it right now

793
00:31:41,679 --> 00:31:44,080
but what you need to do to know for this

794
00:31:44,080 --> 00:31:46,720
exploit is that if that random process

795
00:31:46,720 --> 00:31:49,039
of internet explorer crashes under app

796
00:31:49,039 --> 00:31:51,039
container the warehouse handling that

797
00:31:51,039 --> 00:31:53,279
crash would also run under medium

798
00:31:53,279 --> 00:31:55,200
integrity level

799
00:31:55,200 --> 00:31:58,399
so my plan was to run my code at that

800
00:31:58,399 --> 00:32:01,120
rendered process crush it and exploit

801
00:32:01,120 --> 00:32:02,799
the bug the same way

802
00:32:02,799 --> 00:32:04,880
but i found out that the pdb bug behaves

803
00:32:04,880 --> 00:32:07,039
differently in that context

804
00:32:07,039 --> 00:32:09,840
and that effect object pointer or lower

805
00:32:09,840 --> 00:32:12,799
part of the hip entry points to a kernel

806
00:32:12,799 --> 00:32:15,840
mod address rather than a very low user

807
00:32:15,840 --> 00:32:17,360
mode address

808
00:32:17,360 --> 00:32:19,760
and after some debugging i figure out

809
00:32:19,760 --> 00:32:20,799
why

810
00:32:20,799 --> 00:32:23,600
in case internet explorer crashes

811
00:32:23,600 --> 00:32:26,159
that object survey is allocated on the

812
00:32:26,159 --> 00:32:28,880
low fragmentation hip which is the

813
00:32:28,880 --> 00:32:32,080
optimized hip implementation of windows

814
00:32:32,080 --> 00:32:35,760
and the ip entry structure on the lfh

815
00:32:35,760 --> 00:32:38,080
looks a little bit different and that

816
00:32:38,080 --> 00:32:40,399
address because of that ends up being a

817
00:32:40,399 --> 00:32:42,640
kernel mod address which i obviously

818
00:32:42,640 --> 00:32:45,120
cannot allocate and the referencing it

819
00:32:45,120 --> 00:32:48,240
will result in an access violation

820
00:32:48,240 --> 00:32:50,480
and the reason why it happens is that

821
00:32:50,480 --> 00:32:52,960
warehouse reads a lot of memory from

822
00:32:52,960 --> 00:32:55,519
that crashing process and from my own

823
00:32:55,519 --> 00:32:57,440
process that didn't do much work at the

824
00:32:57,440 --> 00:32:58,720
time

825
00:32:58,720 --> 00:33:01,600
the lfh was not kicked in because the l

826
00:33:01,600 --> 00:33:03,840
phage kicks in only after a certain

827
00:33:03,840 --> 00:33:06,880
number of allocations at a specific size

828
00:33:06,880 --> 00:33:09,600
are done and then it would put that

829
00:33:09,600 --> 00:33:13,279
bucket of buffers onto the lfh

830
00:33:13,279 --> 00:33:15,039
so for internet explorer that's a very

831
00:33:15,039 --> 00:33:17,600
busy process that's not the case and

832
00:33:17,600 --> 00:33:20,960
this is why that bug behaved differently

833
00:33:20,960 --> 00:33:23,360
so my original thought was that maybe

834
00:33:23,360 --> 00:33:25,840
i'd exploit another pdb parsing bug to

835
00:33:25,840 --> 00:33:27,519
exploit the enhanced protected mod

836
00:33:27,519 --> 00:33:28,720
sandbox

837
00:33:28,720 --> 00:33:31,200
but then i found out that i am allowed

838
00:33:31,200 --> 00:33:33,679
to create child processes from internet

839
00:33:33,679 --> 00:33:36,000
explorer sandbox they would still run

840
00:33:36,000 --> 00:33:38,080
under app container but this is

841
00:33:38,080 --> 00:33:39,600
sufficient for me

842
00:33:39,600 --> 00:33:42,720
and all i had to do was to chain a proxy

843
00:33:42,720 --> 00:33:45,279
process here in the middle internet

844
00:33:45,279 --> 00:33:47,679
explorer would run it and then that

845
00:33:47,679 --> 00:33:50,159
process would crash and i just simply

846
00:33:50,159 --> 00:33:53,519
tried the bug that same way

847
00:33:53,519 --> 00:33:55,679
and this is the final demo for this talk

848
00:33:55,679 --> 00:33:57,840
showing this actually works i'd be

849
00:33:57,840 --> 00:34:00,240
running internet explorer and show you

850
00:34:00,240 --> 00:34:02,880
that the rendering process runs under an

851
00:34:02,880 --> 00:34:04,720
app container

852
00:34:04,720 --> 00:34:07,200
then i would inject my code into that

853
00:34:07,200 --> 00:34:08,879
app container process

854
00:34:08,879 --> 00:34:10,879
mimicking an attacker exploiting a

855
00:34:10,879 --> 00:34:12,879
vulnerability in the context of that

856
00:34:12,879 --> 00:34:14,480
renderer

857
00:34:14,480 --> 00:34:16,399
and as you can see

858
00:34:16,399 --> 00:34:18,800
another instance of cmd was spawned

859
00:34:18,800 --> 00:34:21,599
again at medium integrity level

860
00:34:21,599 --> 00:34:23,199
showing i was able to escape the

861
00:34:23,199 --> 00:34:25,040
internet explorer enhanced protected

862
00:34:25,040 --> 00:34:27,918
mode sandbox and run code at medium

863
00:34:27,918 --> 00:34:30,159
level

864
00:34:30,159 --> 00:34:32,960
so after writing those pocs i reported

865
00:34:32,960 --> 00:34:34,480
the bug to microsoft

866
00:34:34,480 --> 00:34:36,800
again with the new attack surface

867
00:34:36,800 --> 00:34:39,440
details and now they agreed that it does

868
00:34:39,440 --> 00:34:41,599
meet the bar for security servicing and

869
00:34:41,599 --> 00:34:43,679
that it should be fixed

870
00:34:43,679 --> 00:34:45,918
and their fix was quite simple it was

871
00:34:45,918 --> 00:34:48,399
shipped a few months later and all they

872
00:34:48,399 --> 00:34:51,119
did is to make warfall long no longer

873
00:34:51,119 --> 00:34:53,839
parse pdb files from disk

874
00:34:53,839 --> 00:34:56,480
and the way they did that is to call the

875
00:34:56,480 --> 00:34:59,280
function sim set extended option which

876
00:34:59,280 --> 00:35:02,640
tweaks the way sim initialize works and

877
00:35:02,640 --> 00:35:04,880
they used an undocumented argument of

878
00:35:04,880 --> 00:35:07,280
the value 3 which reverse engineer and

879
00:35:07,280 --> 00:35:10,400
debug help i found out that simply means

880
00:35:10,400 --> 00:35:13,280
do not load pdb files

881
00:35:13,280 --> 00:35:15,440
and that basically killed the attack

882
00:35:15,440 --> 00:35:18,079
surface of having wherefold parsed

883
00:35:18,079 --> 00:35:21,119
malformed pdbs

884
00:35:21,119 --> 00:35:23,920
now that would be all for this talk and

885
00:35:23,920 --> 00:35:25,920
a few takeaways i want you to take from

886
00:35:25,920 --> 00:35:26,720
here

887
00:35:26,720 --> 00:35:29,119
is first of all that fuzzing is a very

888
00:35:29,119 --> 00:35:31,359
efficient tool to find vulnerabilities

889
00:35:31,359 --> 00:35:33,119
in the right targets and that's

890
00:35:33,119 --> 00:35:35,119
something that every security researcher

891
00:35:35,119 --> 00:35:37,760
should have in his toolbelt

892
00:35:37,760 --> 00:35:40,400
next my exploit worked on the latest

893
00:35:40,400 --> 00:35:42,400
windows 10 at the time despite all

894
00:35:42,400 --> 00:35:43,760
mitigations

895
00:35:43,760 --> 00:35:46,000
and the main reason it was quite easy to

896
00:35:46,000 --> 00:35:48,640
exploit was that i could trigger the bug

897
00:35:48,640 --> 00:35:50,240
in the context of the 32-bit

898
00:35:50,240 --> 00:35:53,119
compatibility layer which is just not as

899
00:35:53,119 --> 00:35:56,960
strongly mitigated as 64-bit

900
00:35:56,960 --> 00:35:59,040
next if you have one bug there might be

901
00:35:59,040 --> 00:36:01,440
multiple attack surfaces into exploiting

902
00:36:01,440 --> 00:36:03,920
it especially if that bug is in some

903
00:36:03,920 --> 00:36:05,760
shared library

904
00:36:05,760 --> 00:36:09,280
and finally the fix by microsoft didn't

905
00:36:09,280 --> 00:36:11,760
fix the debug help bug and it exists in

906
00:36:11,760 --> 00:36:14,160
code until today they only kill the

907
00:36:14,160 --> 00:36:15,599
attack surface

908
00:36:15,599 --> 00:36:18,079
so maybe you guys can find other attack

909
00:36:18,079 --> 00:36:20,560
surfaces into that parser and trigger

910
00:36:20,560 --> 00:36:22,880
that bag on your own

911
00:36:22,880 --> 00:36:25,440
thank you very much that be all

912
00:36:25,440 --> 00:36:27,200
if you have any questions now be a good

913
00:36:27,200 --> 00:36:29,440
time to ask and otherwise you can always

914
00:36:29,440 --> 00:36:31,359
ping me on twitter

915
00:36:31,359 --> 00:36:34,400
thank you very much

