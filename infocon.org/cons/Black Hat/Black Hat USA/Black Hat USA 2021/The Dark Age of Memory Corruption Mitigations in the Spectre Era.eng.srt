1
00:00:01,130 --> 00:00:14,320
[Music]

2
00:00:14,320 --> 00:00:16,400
hello everyone thanks uh for attending

3
00:00:16,400 --> 00:00:18,640
uh our session today we are gonna show

4
00:00:18,640 --> 00:00:21,119
you how we can bypass memory corruption

5
00:00:21,119 --> 00:00:22,880
and mitigation using a speculative

6
00:00:22,880 --> 00:00:24,240
execution

7
00:00:24,240 --> 00:00:26,080
before going to the details of our talk

8
00:00:26,080 --> 00:00:28,960
a little bit about ourselves um my name

9
00:00:28,960 --> 00:00:30,880
is andre mambretti and i'm a system

10
00:00:30,880 --> 00:00:32,800
security researcher at ibm research in

11
00:00:32,800 --> 00:00:36,239
zurich i'm also a phd student at

12
00:00:36,239 --> 00:00:40,000
northeastern university along

13
00:00:40,000 --> 00:00:41,840
with me

14
00:00:41,840 --> 00:00:44,640
there is alexander sandulescu she works

15
00:00:44,640 --> 00:00:45,440
at

16
00:00:45,440 --> 00:00:48,320
google and in the security team

17
00:00:48,320 --> 00:00:50,160
and she's a former colleague of us in

18
00:00:50,160 --> 00:00:52,239
ibm research where this work was

19
00:00:52,239 --> 00:00:53,440
actually

20
00:00:53,440 --> 00:00:54,719
done

21
00:00:54,719 --> 00:00:56,399
okay before

22
00:00:56,399 --> 00:00:58,640
going into the details of the technical

23
00:00:58,640 --> 00:01:00,719
details of our talk we need to

24
00:01:00,719 --> 00:01:04,239
uh look at what transient execution is

25
00:01:04,239 --> 00:01:06,320
transit execution

26
00:01:06,320 --> 00:01:09,119
uh it's a type of execution that happens

27
00:01:09,119 --> 00:01:11,119
in modern cpus

28
00:01:11,119 --> 00:01:13,439
that are highly

29
00:01:13,439 --> 00:01:16,400
optimized and these cpus whenever there

30
00:01:16,400 --> 00:01:19,360
is a like a possibility to guess

31
00:01:19,360 --> 00:01:21,759
for future operations to optimize the

32
00:01:21,759 --> 00:01:23,840
pipeline they will employ transient

33
00:01:23,840 --> 00:01:25,520
execution that

34
00:01:25,520 --> 00:01:27,040
will start

35
00:01:27,040 --> 00:01:28,799
the execution of a series of transient

36
00:01:28,799 --> 00:01:30,159
instructions

37
00:01:30,159 --> 00:01:32,000
and these instructions will cross the

38
00:01:32,000 --> 00:01:33,520
pipeline

39
00:01:33,520 --> 00:01:35,360
in the back end of the cpu

40
00:01:35,360 --> 00:01:37,439
and

41
00:01:37,439 --> 00:01:40,960
their output is actually unknown so

42
00:01:40,960 --> 00:01:42,960
we don't know uh what is going to be the

43
00:01:42,960 --> 00:01:45,040
uh the possible outcome for for each one

44
00:01:45,040 --> 00:01:47,680
of these distractions until the very end

45
00:01:47,680 --> 00:01:50,799
and the cpu uh will decide uh when they

46
00:01:50,799 --> 00:01:52,960
reach the end of the pipeline if

47
00:01:52,960 --> 00:01:54,880
retiring these instructions

48
00:01:54,880 --> 00:01:57,520
and that means that their side effects

49
00:01:57,520 --> 00:02:00,079
will be architecturally visible to our

50
00:02:00,079 --> 00:02:01,520
program

51
00:02:01,520 --> 00:02:04,560
and or basically squash these

52
00:02:04,560 --> 00:02:05,920
instructions

53
00:02:05,920 --> 00:02:08,318
and that means that the cpu has decided

54
00:02:08,318 --> 00:02:09,119
that

55
00:02:09,119 --> 00:02:12,480
uh the optimization the

56
00:02:12,480 --> 00:02:15,120
the gas that was employed was actually

57
00:02:15,120 --> 00:02:16,720
not correct and these distractions are

58
00:02:16,720 --> 00:02:18,560
not needed anymore

59
00:02:18,560 --> 00:02:20,800
and therefore we'll try to lower back

60
00:02:20,800 --> 00:02:22,160
all the side effects that these

61
00:02:22,160 --> 00:02:24,239
instructions have left in the back end

62
00:02:24,239 --> 00:02:25,520
of the cpu

63
00:02:25,520 --> 00:02:28,319
the problem is that this rolling back

64
00:02:28,319 --> 00:02:31,760
of the state of the micro architecture

65
00:02:31,760 --> 00:02:34,239
is not complete and

66
00:02:34,239 --> 00:02:36,959
actually these this uh allows for a

67
00:02:36,959 --> 00:02:39,360
possibility for attacks

68
00:02:39,360 --> 00:02:41,760
so an attack in the transit execution uh

69
00:02:41,760 --> 00:02:43,760
works as follow we have like some

70
00:02:43,760 --> 00:02:45,360
transient destruction that is generated

71
00:02:45,360 --> 00:02:48,560
by the cpu because of some optimization

72
00:02:48,560 --> 00:02:50,319
and these transient instruction will

73
00:02:50,319 --> 00:02:51,440
access

74
00:02:51,440 --> 00:02:53,760
a secret the idea here is that by

75
00:02:53,760 --> 00:02:55,440
accessing the secret

76
00:02:55,440 --> 00:02:57,360
they will these distractions they will

77
00:02:57,360 --> 00:02:59,519
leave some footprint in the micro

78
00:02:59,519 --> 00:03:01,840
architecture that are not rolled back by

79
00:03:01,840 --> 00:03:03,680
the cpu when this destruction will be

80
00:03:03,680 --> 00:03:04,959
squashed

81
00:03:04,959 --> 00:03:07,599
and an attacker through one of the many

82
00:03:07,599 --> 00:03:09,360
side channels that are available in the

83
00:03:09,360 --> 00:03:13,040
micro architecture will be able to leak

84
00:03:13,040 --> 00:03:17,280
this footprint and will be able to

85
00:03:17,280 --> 00:03:20,080
uh find out what was the secret that was

86
00:03:20,080 --> 00:03:21,440
accessed

87
00:03:21,440 --> 00:03:24,400
so what are the uh what is the threat

88
00:03:24,400 --> 00:03:26,480
model for uh for this type of attacks so

89
00:03:26,480 --> 00:03:28,480
the threat model is always

90
00:03:28,480 --> 00:03:30,959
a victim programmer that is holding a

91
00:03:30,959 --> 00:03:33,840
secret and is handling a secret and that

92
00:03:33,840 --> 00:03:35,599
is that uh

93
00:03:35,599 --> 00:03:37,360
this victim program

94
00:03:37,360 --> 00:03:40,319
running on a cpu that employs a

95
00:03:40,319 --> 00:03:42,319
transient execution

96
00:03:42,319 --> 00:03:44,640
will leave some side effects behind and

97
00:03:44,640 --> 00:03:47,040
we will have an attacker program running

98
00:03:47,040 --> 00:03:50,560
on the same machine that is trying to

99
00:03:50,560 --> 00:03:51,599
uh

100
00:03:51,599 --> 00:03:53,680
look at these footprints that is left

101
00:03:53,680 --> 00:03:55,760
behind and try to

102
00:03:55,760 --> 00:03:58,480
guess what was the secret handled by the

103
00:03:58,480 --> 00:04:00,640
by the victim program

104
00:04:00,640 --> 00:04:02,879
so let's now have a look at one example

105
00:04:02,879 --> 00:04:05,360
of a speculative execution attacks let's

106
00:04:05,360 --> 00:04:06,400
have a look

107
00:04:06,400 --> 00:04:09,040
at the spectra version 101 which is also

108
00:04:09,040 --> 00:04:11,760
known as a speculative buffer overflow

109
00:04:11,760 --> 00:04:14,080
that was presented by kirianski back in

110
00:04:14,080 --> 00:04:17,759
2018. this this attack leverages a piece

111
00:04:17,759 --> 00:04:20,880
of code such as this one where we have

112
00:04:20,880 --> 00:04:22,560
a buffer

113
00:04:22,560 --> 00:04:24,240
and we have a bounce check on this

114
00:04:24,240 --> 00:04:25,280
buffer

115
00:04:25,280 --> 00:04:27,600
before making a store towards the buffer

116
00:04:27,600 --> 00:04:28,800
so

117
00:04:28,800 --> 00:04:29,759
um

118
00:04:29,759 --> 00:04:32,880
here is the layout on the of the stack

119
00:04:32,880 --> 00:04:35,600
of of this uh little snippet of code we

120
00:04:35,600 --> 00:04:37,360
have the array and we have like some

121
00:04:37,360 --> 00:04:40,840
other information stored in the stack

122
00:04:40,840 --> 00:04:43,759
so when we start to execute this piece

123
00:04:43,759 --> 00:04:45,759
of code when we reach this instruction

124
00:04:45,759 --> 00:04:47,040
as you can see

125
00:04:47,040 --> 00:04:49,360
the size of the array is not present

126
00:04:49,360 --> 00:04:51,120
into the cache we assume that this value

127
00:04:51,120 --> 00:04:53,120
is not present in the cache and we also

128
00:04:53,120 --> 00:04:56,000
assume that the x the value of x is

129
00:04:56,000 --> 00:04:59,040
under attacker control and it's actually

130
00:04:59,040 --> 00:05:01,280
out of bound

131
00:05:01,280 --> 00:05:04,160
the cpu modern cpu since the size of

132
00:05:04,160 --> 00:05:07,440
array is not ready will not stall but it

133
00:05:07,440 --> 00:05:10,400
will start to speculative execute and if

134
00:05:10,400 --> 00:05:12,240
we assume that this piece of code was

135
00:05:12,240 --> 00:05:13,680
executed

136
00:05:13,680 --> 00:05:16,479
many times before with vaccine bound

137
00:05:16,479 --> 00:05:19,039
the cpu will be tricked to think that

138
00:05:19,039 --> 00:05:21,440
the x is inbound also this time and so

139
00:05:21,440 --> 00:05:24,160
the cpu will move on to this instruction

140
00:05:24,160 --> 00:05:26,639
and it will perform the

141
00:05:26,639 --> 00:05:27,919
the store

142
00:05:27,919 --> 00:05:29,280
this store that is out of bound

143
00:05:29,280 --> 00:05:31,600
basically we are going to achieve

144
00:05:31,600 --> 00:05:32,560
the

145
00:05:32,560 --> 00:05:35,840
buffer overflow in a speculative manner

146
00:05:35,840 --> 00:05:38,800
as i said x is under attacker control

147
00:05:38,800 --> 00:05:41,600
and we assume that the attacker is

148
00:05:41,600 --> 00:05:43,600
powerful enough to know where for

149
00:05:43,600 --> 00:05:45,440
instance the return value on the stack

150
00:05:45,440 --> 00:05:46,160
is

151
00:05:46,160 --> 00:05:47,360
stored

152
00:05:47,360 --> 00:05:50,240
the attacker will be able to override

153
00:05:50,240 --> 00:05:53,280
the the return value and

154
00:05:53,280 --> 00:05:55,440
if you assume that the speculative

155
00:05:55,440 --> 00:05:57,840
window is actually long enough to reach

156
00:05:57,840 --> 00:05:59,360
this return

157
00:05:59,360 --> 00:06:01,919
uh the attacker will be able to

158
00:06:01,919 --> 00:06:04,720
perform basically a speculative control

159
00:06:04,720 --> 00:06:06,639
flow hijack using the value that was

160
00:06:06,639 --> 00:06:10,160
overwritten on the on the stack

161
00:06:11,440 --> 00:06:13,440
at this stage basically the attacker is

162
00:06:13,440 --> 00:06:15,680
able to steer speculative execution

163
00:06:15,680 --> 00:06:18,319
wherever he wants and the idea is that

164
00:06:18,319 --> 00:06:19,039
we

165
00:06:19,039 --> 00:06:21,280
the attacker will want to send the

166
00:06:21,280 --> 00:06:23,199
speculative execution towards a piece of

167
00:06:23,199 --> 00:06:24,639
code that we call a

168
00:06:24,639 --> 00:06:27,600
speculative execution

169
00:06:27,600 --> 00:06:30,160
side channel send gadget

170
00:06:30,160 --> 00:06:31,280
and

171
00:06:31,280 --> 00:06:34,000
this gadget will allow the attacker to

172
00:06:34,000 --> 00:06:37,440
leave some footprint that

173
00:06:37,759 --> 00:06:39,680
that can be read out

174
00:06:39,680 --> 00:06:42,800
from another process using the

175
00:06:42,800 --> 00:06:45,440
unknown side channel

176
00:06:45,440 --> 00:06:47,199
this type of attacks is not the only

177
00:06:47,199 --> 00:06:48,800
attack that

178
00:06:48,800 --> 00:06:50,639
allows us to achieve a speculative

179
00:06:50,639 --> 00:06:52,240
control flow hijacks

180
00:06:52,240 --> 00:06:54,319
there are many other ways to achieve

181
00:06:54,319 --> 00:06:56,639
this very powerful primitive let's have

182
00:06:56,639 --> 00:06:58,800
a look at the overview on how can we

183
00:06:58,800 --> 00:07:00,400
achieve a speculative control flow

184
00:07:00,400 --> 00:07:01,440
hijacks

185
00:07:01,440 --> 00:07:02,639
so

186
00:07:02,639 --> 00:07:04,080
we can achieve a

187
00:07:04,080 --> 00:07:06,560
specialty control fly jacks by

188
00:07:06,560 --> 00:07:08,800
leveraging microarchitectural components

189
00:07:08,800 --> 00:07:11,599
such as the rsb and the btb

190
00:07:11,599 --> 00:07:13,840
the rsb the return stack buffer is used

191
00:07:13,840 --> 00:07:15,120
to predict

192
00:07:15,120 --> 00:07:17,759
return instructions when the value is

193
00:07:17,759 --> 00:07:19,759
not ready on the stack

194
00:07:19,759 --> 00:07:22,240
or the btb is used to predict the

195
00:07:22,240 --> 00:07:24,000
possible outcome of an indirect column

196
00:07:24,000 --> 00:07:25,599
in direct jumps

197
00:07:25,599 --> 00:07:26,560
where

198
00:07:26,560 --> 00:07:29,039
the the the target is not known during

199
00:07:29,039 --> 00:07:30,400
execution

200
00:07:30,400 --> 00:07:31,599
and

201
00:07:31,599 --> 00:07:33,520
these works have

202
00:07:33,520 --> 00:07:34,880
proven that

203
00:07:34,880 --> 00:07:36,560
this type of attacks actually work we

204
00:07:36,560 --> 00:07:38,639
can poison this

205
00:07:38,639 --> 00:07:40,960
internal structure of the cpu

206
00:07:40,960 --> 00:07:42,639
and then have a victim

207
00:07:42,639 --> 00:07:44,879
use those poison value and basically

208
00:07:44,879 --> 00:07:46,720
redirect the victim wherever we want in

209
00:07:46,720 --> 00:07:49,360
a speculative control hijack manner

210
00:07:49,360 --> 00:07:50,800
the other on the other side of the

211
00:07:50,800 --> 00:07:52,800
spectrum we have

212
00:07:52,800 --> 00:07:54,479
we can achieve speculative control for

213
00:07:54,479 --> 00:07:57,759
hijacks using architecturally

214
00:07:57,759 --> 00:07:59,440
architectural components such as

215
00:07:59,440 --> 00:08:02,080
registers and memory locations

216
00:08:02,080 --> 00:08:03,759
and we can

217
00:08:03,759 --> 00:08:05,759
poison these elements

218
00:08:05,759 --> 00:08:08,720
either with a speculative override

219
00:08:08,720 --> 00:08:10,879
or a concrete override at the

220
00:08:10,879 --> 00:08:12,479
architectural level

221
00:08:12,479 --> 00:08:14,560
and we can overwrite in both of the

222
00:08:14,560 --> 00:08:17,280
cases backward and forward edges

223
00:08:17,280 --> 00:08:19,360
so this uh a

224
00:08:19,360 --> 00:08:23,039
big family uh of this sub-family of

225
00:08:23,039 --> 00:08:24,720
speculative control fly jacks we call

226
00:08:24,720 --> 00:08:27,599
them spear speculative architectural

227
00:08:27,599 --> 00:08:30,719
control for hijacks

228
00:08:30,879 --> 00:08:33,279
the first case the speculative

229
00:08:33,279 --> 00:08:35,599
override of a backward edge was actually

230
00:08:35,599 --> 00:08:38,320
already considered by kenyansky in the

231
00:08:38,320 --> 00:08:40,799
speculative buffer overflow however the

232
00:08:40,799 --> 00:08:43,200
other three cases nobody has ever looked

233
00:08:43,200 --> 00:08:46,160
at them and we did it in our work

234
00:08:46,160 --> 00:08:47,440
so we

235
00:08:47,440 --> 00:08:48,880
tried to find

236
00:08:48,880 --> 00:08:50,720
use cases for these

237
00:08:50,720 --> 00:08:52,959
three other overrides

238
00:08:52,959 --> 00:08:55,120
and what we did was like we started to

239
00:08:55,120 --> 00:08:57,120
look at the mitigations uh memory

240
00:08:57,120 --> 00:08:58,880
corruption mitigations

241
00:08:58,880 --> 00:09:01,120
we started to look at the these memory

242
00:09:01,120 --> 00:09:02,880
corruption mitigations because for

243
00:09:02,880 --> 00:09:04,480
instance if we have an architecture

244
00:09:04,480 --> 00:09:06,480
override of a backward edge which is a

245
00:09:06,480 --> 00:09:08,800
normal buffer overflow of course if

246
00:09:08,800 --> 00:09:10,800
there is no mitigation in place we can

247
00:09:10,800 --> 00:09:12,480
perform a buffer overflow so memory

248
00:09:12,480 --> 00:09:14,399
corruption we can exploit the memory

249
00:09:14,399 --> 00:09:16,399
correction vulnerability so we don't

250
00:09:16,399 --> 00:09:19,200
really need the speculative execution

251
00:09:19,200 --> 00:09:21,200
but in the case of

252
00:09:21,200 --> 00:09:22,880
where we have this primitive but the

253
00:09:22,880 --> 00:09:25,200
primitive is mitigated by the for

254
00:09:25,200 --> 00:09:27,360
instance a stock smashing protector

255
00:09:27,360 --> 00:09:28,320
then

256
00:09:28,320 --> 00:09:30,080
we wanted to investigate if we can

257
00:09:30,080 --> 00:09:32,880
leverage speculative execution to bypass

258
00:09:32,880 --> 00:09:35,200
uh such protection and still perform

259
00:09:35,200 --> 00:09:36,959
some sort of attack

260
00:09:36,959 --> 00:09:40,160
the first step we did that towards uh

261
00:09:40,160 --> 00:09:42,800
towards analyzing these three cases was

262
00:09:42,800 --> 00:09:46,000
actually using a tool that we wrote to

263
00:09:46,000 --> 00:09:48,560
observe a speculative execution and

264
00:09:48,560 --> 00:09:50,160
called the speculator that we published

265
00:09:50,160 --> 00:09:52,640
the taxa 2019

266
00:09:52,640 --> 00:09:54,080
and

267
00:09:54,080 --> 00:09:56,560
with speculator what we tried to do was

268
00:09:56,560 --> 00:09:58,080
actually to

269
00:09:58,080 --> 00:10:00,640
verify if we can perform this control

270
00:10:00,640 --> 00:10:02,160
flow hijack

271
00:10:02,160 --> 00:10:05,279
and we brought for each one of the cases

272
00:10:05,279 --> 00:10:07,839
a smaller snippet of a small test such

273
00:10:07,839 --> 00:10:09,040
as this one

274
00:10:09,040 --> 00:10:10,880
this one is a refers to the

275
00:10:10,880 --> 00:10:12,560
architectural override of a backward

276
00:10:12,560 --> 00:10:13,920
edge

277
00:10:13,920 --> 00:10:16,560
and what we this test

278
00:10:16,560 --> 00:10:18,560
works as follows so we

279
00:10:18,560 --> 00:10:22,079
we first make a copy of the return value

280
00:10:22,079 --> 00:10:24,320
that we have on the stack and we save

281
00:10:24,320 --> 00:10:27,200
the in a different memory location then

282
00:10:27,200 --> 00:10:29,680
we perform the architectural override we

283
00:10:29,680 --> 00:10:33,200
basically simulate a buffer overflow

284
00:10:33,200 --> 00:10:36,399
and we point the new return address

285
00:10:36,399 --> 00:10:38,399
towards the target location of our

286
00:10:38,399 --> 00:10:39,600
choosing

287
00:10:39,600 --> 00:10:40,800
then we

288
00:10:40,800 --> 00:10:44,560
use a cl flash instruction to evict the

289
00:10:44,560 --> 00:10:47,120
save the return value

290
00:10:47,120 --> 00:10:48,720
so that when we

291
00:10:48,720 --> 00:10:50,720
reach this comparison that is going to

292
00:10:50,720 --> 00:10:53,040
try to figure out if the value on the

293
00:10:53,040 --> 00:10:55,040
stock and the value saved are actually

294
00:10:55,040 --> 00:10:57,279
the same

295
00:10:57,279 --> 00:11:00,480
basically the cpu will not be ready to

296
00:11:00,480 --> 00:11:02,560
execute this instruction until the store

297
00:11:02,560 --> 00:11:04,720
threat comes back from

298
00:11:04,720 --> 00:11:06,720
from main memory and so we trigger

299
00:11:06,720 --> 00:11:09,360
speculative execution at this point

300
00:11:09,360 --> 00:11:11,519
of course this at the architectural

301
00:11:11,519 --> 00:11:13,279
level this piece of code will always

302
00:11:13,279 --> 00:11:15,920
reach the function my exit

303
00:11:15,920 --> 00:11:16,640
but

304
00:11:16,640 --> 00:11:18,880
since we are starting we are

305
00:11:18,880 --> 00:11:21,440
tricking the cpu to actually start

306
00:11:21,440 --> 00:11:24,640
speculative execution at this comparison

307
00:11:24,640 --> 00:11:26,800
we expect the speculative execution to

308
00:11:26,800 --> 00:11:30,160
actually reach this return instruction

309
00:11:30,160 --> 00:11:31,279
and if

310
00:11:31,279 --> 00:11:34,000
this piece of code reaches the return

311
00:11:34,000 --> 00:11:36,720
instruction then it will it will use the

312
00:11:36,720 --> 00:11:39,120
poison value that we have on the stack

313
00:11:39,120 --> 00:11:41,920
so we will send the execution to our

314
00:11:41,920 --> 00:11:44,399
target location and speculator is able

315
00:11:44,399 --> 00:11:46,160
to see if speculative execution will

316
00:11:46,160 --> 00:11:48,320
reach the target location or not so

317
00:11:48,320 --> 00:11:50,079
these are the results of our findings

318
00:11:50,079 --> 00:11:52,399
for each one of the

319
00:11:52,399 --> 00:11:54,320
of the tests we brought in each one of

320
00:11:54,320 --> 00:11:57,440
the cases and as you can see we

321
00:11:57,440 --> 00:11:59,120
have a speculative control hijacks

322
00:11:59,120 --> 00:12:00,639
happening almost hundred percent of the

323
00:12:00,639 --> 00:12:01,600
time

324
00:12:01,600 --> 00:12:04,959
so this type of hijack happens of course

325
00:12:04,959 --> 00:12:06,399
this is a

326
00:12:06,399 --> 00:12:07,920
lab test

327
00:12:07,920 --> 00:12:08,959
so

328
00:12:08,959 --> 00:12:11,360
it's really far from an actual attack

329
00:12:11,360 --> 00:12:13,360
real world attack but it's a the first

330
00:12:13,360 --> 00:12:15,360
step to understand if these attacks are

331
00:12:15,360 --> 00:12:18,800
possible or not alexandra uh now will

332
00:12:18,800 --> 00:12:20,880
basically walk you through to actually

333
00:12:20,880 --> 00:12:23,200
the real world

334
00:12:23,200 --> 00:12:25,120
attack that we build

335
00:12:25,120 --> 00:12:27,440
after we figure out that control flow

336
00:12:27,440 --> 00:12:29,360
hijack actually is possible in these

337
00:12:29,360 --> 00:12:32,880
cases we demonstrate a local arbitrary

338
00:12:32,880 --> 00:12:35,200
memory read attack using the spear

339
00:12:35,200 --> 00:12:37,360
architectural backward edge override

340
00:12:37,360 --> 00:12:39,120
attack vector

341
00:12:39,120 --> 00:12:41,680
the scheme here shows an overview of the

342
00:12:41,680 --> 00:12:45,040
steps required to perform the attack

343
00:12:45,040 --> 00:12:47,920
the attack has a preparation phase

344
00:12:47,920 --> 00:12:49,839
in steps one and two

345
00:12:49,839 --> 00:12:53,040
where eviction sets are identified

346
00:12:53,040 --> 00:12:55,120
memory used by the side channel is

347
00:12:55,120 --> 00:12:58,560
flushed and rope gadgets are prepared

348
00:12:58,560 --> 00:13:01,440
the attacker then submits the payload to

349
00:13:01,440 --> 00:13:03,440
the victim in step 3.

350
00:13:03,440 --> 00:13:05,920
the payload is crafted to exploit the

351
00:13:05,920 --> 00:13:08,000
stack buffer overflow

352
00:13:08,000 --> 00:13:10,160
here traditional exploitation of the

353
00:13:10,160 --> 00:13:13,040
memory safety violation is prevented by

354
00:13:13,040 --> 00:13:14,240
ssp

355
00:13:14,240 --> 00:13:15,279
however

356
00:13:15,279 --> 00:13:17,680
the attacker uses a speculative

357
00:13:17,680 --> 00:13:21,120
execution attack to bypass the mechanism

358
00:13:21,120 --> 00:13:23,839
by overwriting the return address and

359
00:13:23,839 --> 00:13:26,320
obtaining a speculative control flow

360
00:13:26,320 --> 00:13:28,800
hijack

361
00:13:28,800 --> 00:13:31,680
as a result the victim is tricked into

362
00:13:31,680 --> 00:13:34,480
executing a side channel send of

363
00:13:34,480 --> 00:13:37,839
attacker chosen memory location

364
00:13:37,839 --> 00:13:41,120
this happens in step 6.

365
00:13:41,120 --> 00:13:42,399
this is

366
00:13:42,399 --> 00:13:45,040
achieved with the rob component which

367
00:13:45,040 --> 00:13:47,519
reuses code snippets from the victim

368
00:13:47,519 --> 00:13:49,760
program

369
00:13:49,760 --> 00:13:52,240
which are selected and primed in the

370
00:13:52,240 --> 00:13:54,480
initialization phase

371
00:13:54,480 --> 00:13:56,320
the attacker can then execute the

372
00:13:56,320 --> 00:13:58,560
corresponding side channel receive in

373
00:13:58,560 --> 00:14:00,560
step 7.

374
00:14:00,560 --> 00:14:02,959
the success rate of the attack is

375
00:14:02,959 --> 00:14:06,079
increased by concurrently executing an

376
00:14:06,079 --> 00:14:08,079
eviction loop to lengthen the

377
00:14:08,079 --> 00:14:10,000
speculation window

378
00:14:10,000 --> 00:14:12,480
with previously computed eviction sets

379
00:14:12,480 --> 00:14:15,760
for the stack canary

380
00:14:15,760 --> 00:14:18,560
the spear attack vector

381
00:14:18,560 --> 00:14:21,839
present in an ssp hardened program

382
00:14:21,839 --> 00:14:24,079
will provide us with the necessary

383
00:14:24,079 --> 00:14:26,800
speculative execution primitive

384
00:14:26,800 --> 00:14:29,760
for arbitrary victim memory read

385
00:14:29,760 --> 00:14:32,000
we'll first discuss the vulnerability

386
00:14:32,000 --> 00:14:36,000
and the necessary attack building blocks

387
00:14:36,240 --> 00:14:38,160
this code example

388
00:14:38,160 --> 00:14:40,480
shows a function which is vulnerable to

389
00:14:40,480 --> 00:14:43,120
stack buffer overflow but is protected

390
00:14:43,120 --> 00:14:44,800
by ssp

391
00:14:44,800 --> 00:14:49,279
um there is a call to mem copy

392
00:14:49,279 --> 00:14:52,320
um that which has like an attacker

393
00:14:52,320 --> 00:14:55,680
controlled source and size uh which

394
00:14:55,680 --> 00:14:57,440
overwrites the stack

395
00:14:57,440 --> 00:15:00,880
past the store return address

396
00:15:00,880 --> 00:15:02,560
the malicious payload will be

397
00:15:02,560 --> 00:15:04,560
architecturally written to the stack in

398
00:15:04,560 --> 00:15:06,320
this case

399
00:15:06,320 --> 00:15:08,000
the canary check

400
00:15:08,000 --> 00:15:09,920
makes the stack buffer overflow

401
00:15:09,920 --> 00:15:13,360
vulnerability unexploitable

402
00:15:13,360 --> 00:15:15,440
in an attempt like this

403
00:15:15,440 --> 00:15:17,839
the program will abort due to the canary

404
00:15:17,839 --> 00:15:20,079
mismatch

405
00:15:20,079 --> 00:15:22,560
however

406
00:15:22,639 --> 00:15:25,440
even if ssp protects against the

407
00:15:25,440 --> 00:15:27,680
architectural exploitation of this

408
00:15:27,680 --> 00:15:30,480
vulnerability it also provides us with

409
00:15:30,480 --> 00:15:33,199
the primitives for a speculative control

410
00:15:33,199 --> 00:15:34,560
flow hijack

411
00:15:34,560 --> 00:15:37,600
the canary check executed before the

412
00:15:37,600 --> 00:15:40,160
function return will trigger the

413
00:15:40,160 --> 00:15:42,000
speculative execution

414
00:15:42,000 --> 00:15:44,320
if the instruction operands are not

415
00:15:44,320 --> 00:15:45,759
cached

416
00:15:45,759 --> 00:15:48,480
and in order to trigger the speculative

417
00:15:48,480 --> 00:15:50,639
execution of the vulnerable path which

418
00:15:50,639 --> 00:15:53,279
is the one taken the attacker will send

419
00:15:53,279 --> 00:15:55,920
a number of valid requests prior to the

420
00:15:55,920 --> 00:15:57,360
malicious one

421
00:15:57,360 --> 00:16:00,639
uh in our experiments uh five valid

422
00:16:00,639 --> 00:16:02,959
requests are enough to train the pattern

423
00:16:02,959 --> 00:16:06,160
history table uh such that

424
00:16:06,160 --> 00:16:09,199
um the uh the taken branch will be

425
00:16:09,199 --> 00:16:12,800
executed speculatively after the canary

426
00:16:12,800 --> 00:16:15,279
cache miss

427
00:16:16,880 --> 00:16:19,680
the compiler generated assembly code for

428
00:16:19,680 --> 00:16:22,880
ssp shows the exact operations and

429
00:16:22,880 --> 00:16:24,800
control flow graph

430
00:16:24,800 --> 00:16:26,800
in the function prologue the global

431
00:16:26,800 --> 00:16:29,759
canary value is stored on the stack

432
00:16:29,759 --> 00:16:32,560
and before return the canary integrity

433
00:16:32,560 --> 00:16:35,279
is checked by comparing the value stored

434
00:16:35,279 --> 00:16:37,920
on the stack with the global value

435
00:16:37,920 --> 00:16:40,079
this introduces the first attack

436
00:16:40,079 --> 00:16:43,199
prerequisite namely the canary eviction

437
00:16:43,199 --> 00:16:46,399
this triggers the speculative execution

438
00:16:46,399 --> 00:16:48,639
of the taken branch leading to

439
00:16:48,639 --> 00:16:51,199
speculative control flow hijacking

440
00:16:51,199 --> 00:16:53,440
the next attack prerequisite

441
00:16:53,440 --> 00:16:56,639
is a reliable rid primitive constructed

442
00:16:56,639 --> 00:16:58,880
from rope gadgets that are present in

443
00:16:58,880 --> 00:17:01,279
the victim memory space

444
00:17:01,279 --> 00:17:02,560
even if

445
00:17:02,560 --> 00:17:06,000
ssp is supposed to protect against

446
00:17:06,000 --> 00:17:09,439
the function ever reaching the return

447
00:17:09,439 --> 00:17:11,439
with the corrupted stack

448
00:17:11,439 --> 00:17:14,240
at speculative return the control flow

449
00:17:14,240 --> 00:17:18,400
reaches the attacker-crafted drop chain

450
00:17:18,400 --> 00:17:21,199
in our experimental setup we tested a

451
00:17:21,199 --> 00:17:23,039
drop chain with five gadgets in the

452
00:17:23,039 --> 00:17:26,079
stock and and also a stack private with

453
00:17:26,079 --> 00:17:29,679
five gadgets and we concluded that the

454
00:17:29,679 --> 00:17:33,120
buffer override size must be greater or

455
00:17:33,120 --> 00:17:36,960
equal to 50 to sorry 40 bytes to fit the

456
00:17:36,960 --> 00:17:38,960
chain

457
00:17:38,960 --> 00:17:41,520
the victim stack canary eviction will

458
00:17:41,520 --> 00:17:43,440
give the attacker a large enough

459
00:17:43,440 --> 00:17:46,640
speculation window for the spear attack

460
00:17:46,640 --> 00:17:48,720
the first step of the attack

461
00:17:48,720 --> 00:17:50,080
is finding

462
00:17:50,080 --> 00:17:52,640
the correct eviction sets for the for

463
00:17:52,640 --> 00:17:54,640
the victim step canary

464
00:17:54,640 --> 00:17:57,200
we use uh two different processes for

465
00:17:57,200 --> 00:17:59,120
the attack that communicate to share

466
00:17:59,120 --> 00:18:00,480
memory

467
00:18:00,480 --> 00:18:02,799
one of the attackers it is compiled with

468
00:18:02,799 --> 00:18:05,919
ssb is the one on the right

469
00:18:05,919 --> 00:18:09,039
they both run a synchronous

470
00:18:09,039 --> 00:18:11,120
loop

471
00:18:11,120 --> 00:18:15,200
the first one will load one llc eviction

472
00:18:15,200 --> 00:18:18,080
set and the second one will probe the

473
00:18:18,080 --> 00:18:19,919
canary access time

474
00:18:19,919 --> 00:18:22,799
and for exactly one eviction set the

475
00:18:22,799 --> 00:18:25,440
attacker program on the right will

476
00:18:25,440 --> 00:18:28,799
encounter a cache miss and as a result

477
00:18:28,799 --> 00:18:31,520
the attacker will know the exact llc

478
00:18:31,520 --> 00:18:34,160
slides and cache set corresponding to

479
00:18:34,160 --> 00:18:37,440
the canary of the other process

480
00:18:37,440 --> 00:18:38,559
now

481
00:18:38,559 --> 00:18:41,280
the next part the attacker must make

482
00:18:41,280 --> 00:18:44,160
sure that the victim canary

483
00:18:44,160 --> 00:18:46,320
lies in the same physical memory

484
00:18:46,320 --> 00:18:48,720
location as the one discovered

485
00:18:48,720 --> 00:18:50,640
previously

486
00:18:50,640 --> 00:18:54,080
we evaluated the reuse of the underlying

487
00:18:54,080 --> 00:18:56,960
physical page of the canary in three

488
00:18:56,960 --> 00:18:58,799
different setups

489
00:18:58,799 --> 00:19:00,160
the first setup

490
00:19:00,160 --> 00:19:03,440
is when the victim program is exact by

491
00:19:03,440 --> 00:19:05,360
the attacker

492
00:19:05,360 --> 00:19:07,360
in the second setup the victim is a

493
00:19:07,360 --> 00:19:10,960
separate process spawned by the attacker

494
00:19:10,960 --> 00:19:13,600
and in a third setup the victim is a

495
00:19:13,600 --> 00:19:16,000
completely separate process running on

496
00:19:16,000 --> 00:19:18,400
the same system as the attacker

497
00:19:18,400 --> 00:19:21,200
the canary page reuse success will be

498
00:19:21,200 --> 00:19:22,480
100

499
00:19:22,480 --> 00:19:25,679
for the first two cases due to

500
00:19:25,679 --> 00:19:28,480
the body allocator the allocation and

501
00:19:28,480 --> 00:19:30,960
allocation patterns

502
00:19:30,960 --> 00:19:33,520
but for the latter use case the success

503
00:19:33,520 --> 00:19:35,520
will depend on the

504
00:19:35,520 --> 00:19:38,400
resident memory statistics

505
00:19:38,400 --> 00:19:41,200
granularity present on the machine that

506
00:19:41,200 --> 00:19:43,919
detects the attack runs on

507
00:19:43,919 --> 00:19:45,840
in this example

508
00:19:45,840 --> 00:19:48,640
we'll consider the first scenario

509
00:19:48,640 --> 00:19:51,440
where the attacker process will execute

510
00:19:51,440 --> 00:19:52,960
the victim program

511
00:19:52,960 --> 00:19:55,919
and thus the canary memory page

512
00:19:55,919 --> 00:20:00,720
is preserved at a victim startup

513
00:20:01,679 --> 00:20:05,360
the sets that were previously

514
00:20:05,360 --> 00:20:06,640
previously

515
00:20:06,640 --> 00:20:08,320
computed

516
00:20:08,320 --> 00:20:10,640
are still

517
00:20:10,640 --> 00:20:12,320
are still usable

518
00:20:12,320 --> 00:20:14,400
such that

519
00:20:14,400 --> 00:20:17,760
the attacker can now evict the canary

520
00:20:17,760 --> 00:20:18,880
value

521
00:20:18,880 --> 00:20:22,240
in the victim process

522
00:20:25,360 --> 00:20:28,400
to address the canary eviction we came

523
00:20:28,400 --> 00:20:30,559
up with a novel approach of

524
00:20:30,559 --> 00:20:33,440
the victim victim data for existing

525
00:20:33,440 --> 00:20:36,559
methods incur high penalty

526
00:20:36,559 --> 00:20:39,600
on the on the rope execution success

527
00:20:39,600 --> 00:20:41,840
our method has the advantage of being

528
00:20:41,840 --> 00:20:43,280
non-intrusive

529
00:20:43,280 --> 00:20:45,679
and noise-free compared to existing

530
00:20:45,679 --> 00:20:48,679
solutions

531
00:20:49,120 --> 00:20:52,080
now regarding speculative drop

532
00:20:52,080 --> 00:20:54,880
the attack payload uh is composed of

533
00:20:54,880 --> 00:20:57,280
carefully carefully uh chosen rob

534
00:20:57,280 --> 00:20:59,840
gadgets that are prepared prepared as

535
00:20:59,840 --> 00:21:03,280
part of the initialization phase in step

536
00:21:03,280 --> 00:21:04,559
one

537
00:21:04,559 --> 00:21:07,200
the gadgets must be chosen from code

538
00:21:07,200 --> 00:21:10,400
pages that are already present in victim

539
00:21:10,400 --> 00:21:15,280
memory and have a valid tlb mapping

540
00:21:15,280 --> 00:21:17,919
moreover during a rock chain

541
00:21:17,919 --> 00:21:19,760
initialization phase

542
00:21:19,760 --> 00:21:22,240
the attacker executes the chain in a

543
00:21:22,240 --> 00:21:25,840
loop um pinned to the same physical core

544
00:21:25,840 --> 00:21:27,600
as the victim process

545
00:21:27,600 --> 00:21:30,640
this uh in our experiments lower the

546
00:21:30,640 --> 00:21:33,200
chances of instruction cache misses

547
00:21:33,200 --> 00:21:36,000
during a rock chain execution

548
00:21:36,000 --> 00:21:38,559
the canary eviction will ensure a long

549
00:21:38,559 --> 00:21:40,799
enough speculation window inside of

550
00:21:40,799 --> 00:21:44,240
which we run the attack payload the

551
00:21:44,240 --> 00:21:46,480
outcome of this attack is the side

552
00:21:46,480 --> 00:21:48,000
channel send

553
00:21:48,000 --> 00:21:50,400
represented by an effect on the cache

554
00:21:50,400 --> 00:21:52,640
which cannot be rolled back when

555
00:21:52,640 --> 00:21:55,840
misprediction is detected

556
00:21:55,840 --> 00:21:58,480
in contrast with a traditional drop

557
00:21:58,480 --> 00:22:01,600
speculative rope gadgets must be chosen

558
00:22:01,600 --> 00:22:03,679
such that the chain has the minimum

559
00:22:03,679 --> 00:22:05,600
possible length

560
00:22:05,600 --> 00:22:07,919
in the paper we show exactly what

561
00:22:07,919 --> 00:22:11,039
gadgets worked in our attack and from

562
00:22:11,039 --> 00:22:12,799
what libraries and binaries we obtain

563
00:22:12,799 --> 00:22:14,000
those gadgets

564
00:22:14,000 --> 00:22:16,559
uh in this example however the gadgets

565
00:22:16,559 --> 00:22:18,960
are the basic building blocks

566
00:22:18,960 --> 00:22:22,000
of the successful arbitrary victim

567
00:22:22,000 --> 00:22:25,039
memory read followed by a side channel

568
00:22:25,039 --> 00:22:26,960
sent

569
00:22:26,960 --> 00:22:28,960
in the first gadget

570
00:22:28,960 --> 00:22:31,919
we see that uh there is a load

571
00:22:31,919 --> 00:22:35,600
of the victim secret uh byte

572
00:22:35,600 --> 00:22:38,799
um this load uh to increase the success

573
00:22:38,799 --> 00:22:40,640
of the attack this load should hit the

574
00:22:40,640 --> 00:22:43,039
cache

575
00:22:43,120 --> 00:22:44,799
this will provide

576
00:22:44,799 --> 00:22:46,559
during the speculation window will

577
00:22:46,559 --> 00:22:48,960
provide the attacker with

578
00:22:48,960 --> 00:22:51,440
the victim secret bike that they

579
00:22:51,440 --> 00:22:53,679
intend to leak

580
00:22:53,679 --> 00:22:55,520
the second

581
00:22:55,520 --> 00:22:58,400
the next gadget will compute the exact

582
00:22:58,400 --> 00:23:01,200
offset in the side channel array

583
00:23:01,200 --> 00:23:03,679
that corresponds to the victim secret

584
00:23:03,679 --> 00:23:05,840
byte value

585
00:23:05,840 --> 00:23:08,960
to reduce the noise at the receive end

586
00:23:08,960 --> 00:23:11,120
each side channel array element is of

587
00:23:11,120 --> 00:23:13,840
size 256

588
00:23:13,840 --> 00:23:16,320
the noise source here comes from

589
00:23:16,320 --> 00:23:18,799
adjacent cache lines being fetched

590
00:23:18,799 --> 00:23:22,559
together with the requested line next

591
00:23:22,559 --> 00:23:25,039
the side channel

592
00:23:25,039 --> 00:23:27,520
the side channel array base is added to

593
00:23:27,520 --> 00:23:30,240
the previously computed offset resulting

594
00:23:30,240 --> 00:23:33,360
in the memory address of the entry

595
00:23:33,360 --> 00:23:35,760
corresponding to the victim secret byte

596
00:23:35,760 --> 00:23:36,880
value

597
00:23:36,880 --> 00:23:40,080
and lastly a load is performed

598
00:23:40,080 --> 00:23:41,919
in order to bring

599
00:23:41,919 --> 00:23:44,240
this exact side channel array element in

600
00:23:44,240 --> 00:23:47,200
cache this operation represents the side

601
00:23:47,200 --> 00:23:51,080
channel send operation

602
00:23:51,679 --> 00:23:54,880
the attack uses the de facto option in

603
00:23:54,880 --> 00:23:57,120
speculative execution attacks

604
00:23:57,120 --> 00:23:59,360
namely the cache site channel

605
00:23:59,360 --> 00:24:01,520
although other side channels would work

606
00:24:01,520 --> 00:24:03,440
as well here

607
00:24:03,440 --> 00:24:05,520
the cache side channel can use any

608
00:24:05,520 --> 00:24:07,600
shared memory region between attacker

609
00:24:07,600 --> 00:24:10,159
and victim as side channel array

610
00:24:10,159 --> 00:24:13,520
for example any dynamic library used by

611
00:24:13,520 --> 00:24:15,440
the victim program

612
00:24:15,440 --> 00:24:18,159
the shared space constraints that we

613
00:24:18,159 --> 00:24:20,400
found

614
00:24:20,400 --> 00:24:24,559
the attack needs at least 64 kilobytes

615
00:24:24,559 --> 00:24:27,600
size and eventually low noise

616
00:24:27,600 --> 00:24:29,919
the attacker may prefer a shared library

617
00:24:29,919 --> 00:24:32,000
which is not accessed in close time

618
00:24:32,000 --> 00:24:33,919
proximity with the attack

619
00:24:33,919 --> 00:24:36,880
for convenience here we used

620
00:24:36,880 --> 00:24:38,960
leap thread

621
00:24:38,960 --> 00:24:41,520
the side channel array is primed by the

622
00:24:41,520 --> 00:24:43,840
attacker immediately after sending the

623
00:24:43,840 --> 00:24:46,640
payload by flashing all array elements

624
00:24:46,640 --> 00:24:48,720
from all cache levels

625
00:24:48,720 --> 00:24:51,039
since the memory area is shared between

626
00:24:51,039 --> 00:24:53,200
the attacker and victim the attacker can

627
00:24:53,200 --> 00:24:55,600
execute this phase on its side

628
00:24:55,600 --> 00:24:57,600
the attacker triggers the side-channel

629
00:24:57,600 --> 00:25:00,880
send operation on the victim by crafting

630
00:25:00,880 --> 00:25:03,279
a payload that triggers the spear

631
00:25:03,279 --> 00:25:05,360
vulnerable code path

632
00:25:05,360 --> 00:25:06,400
and

633
00:25:06,400 --> 00:25:08,799
eventually hijacks the program control

634
00:25:08,799 --> 00:25:11,279
flow during speculation window

635
00:25:11,279 --> 00:25:13,279
in step 7

636
00:25:13,279 --> 00:25:16,640
the attacker will probe the array

637
00:25:16,640 --> 00:25:18,000
to

638
00:25:18,000 --> 00:25:21,520
read the side channel signal sent by the

639
00:25:21,520 --> 00:25:23,440
speculative rope

640
00:25:23,440 --> 00:25:25,520
in the absence of noise

641
00:25:25,520 --> 00:25:28,880
the probing will result in one single

642
00:25:28,880 --> 00:25:31,679
side channel array element cached this

643
00:25:31,679 --> 00:25:34,400
would reveal the victim secret

644
00:25:34,400 --> 00:25:37,360
value corresponding to the signal array

645
00:25:37,360 --> 00:25:40,360
element

646
00:25:42,799 --> 00:25:45,760
uh the end-to-end spear architectural

647
00:25:45,760 --> 00:25:49,039
backward edge override attack

648
00:25:49,039 --> 00:25:50,640
results in a local

649
00:25:50,640 --> 00:25:53,039
arbitrary memory read

650
00:25:53,039 --> 00:25:55,520
of the victim memory we achieved an

651
00:25:55,520 --> 00:25:58,320
end-to-end uh leakage rate of 0.3 bytes

652
00:25:58,320 --> 00:25:59,760
per second

653
00:25:59,760 --> 00:26:01,039
um

654
00:26:01,039 --> 00:26:03,279
to increase the success rate uh there is

655
00:26:03,279 --> 00:26:05,679
a phase in our attack where the attacker

656
00:26:05,679 --> 00:26:08,559
needs to run co-located with the victim

657
00:26:08,559 --> 00:26:11,039
but for a short period of time

658
00:26:11,039 --> 00:26:14,000
various noise sources require the attack

659
00:26:14,000 --> 00:26:16,240
to be executed multiple times in order

660
00:26:16,240 --> 00:26:18,720
to distinguish a clear signal

661
00:26:18,720 --> 00:26:21,039
during situational receive for this

662
00:26:21,039 --> 00:26:24,240
reason we ran the attack 100 times for

663
00:26:24,240 --> 00:26:27,360
each victim by to filter out the noise

664
00:26:27,360 --> 00:26:30,480
and our measurements in here include the

665
00:26:30,480 --> 00:26:33,039
victim crash and startup times

666
00:26:33,039 --> 00:26:35,440
the attack works on sky lake and coffee

667
00:26:35,440 --> 00:26:36,559
lake with

668
00:26:36,559 --> 00:26:37,440
all

669
00:26:37,440 --> 00:26:40,720
spectre mitigations enabled and we also

670
00:26:40,720 --> 00:26:44,000
tested on two ubuntu versions 16.4 and

671
00:26:44,000 --> 00:26:45,600
20.4

672
00:26:45,600 --> 00:26:48,960
we observed a slight uh success rate

673
00:26:48,960 --> 00:26:53,279
change in 20.4 due to the another bean

674
00:26:53,279 --> 00:26:55,039
utils version

675
00:26:55,039 --> 00:26:57,840
and to increase the attack success and

676
00:26:57,840 --> 00:26:59,840
reduce the noise

677
00:26:59,840 --> 00:27:03,120
further work would be needed on the rope

678
00:27:03,120 --> 00:27:05,360
chain optimization side

679
00:27:05,360 --> 00:27:08,240
attacker and victim synchronization and

680
00:27:08,240 --> 00:27:10,880
less noisy side channel arrays

681
00:27:10,880 --> 00:27:12,640
for the next part

682
00:27:12,640 --> 00:27:14,720
mitigations and

683
00:27:14,720 --> 00:27:17,520
future work i'll leave andrea to

684
00:27:17,520 --> 00:27:21,279
continue thank you alexandra um so

685
00:27:21,279 --> 00:27:22,960
uh as the at the beginning of the

686
00:27:22,960 --> 00:27:25,760
presentation uh i was mentioning that we

687
00:27:25,760 --> 00:27:29,360
didn't we also looked at other use cases

688
00:27:29,360 --> 00:27:30,640
and uh

689
00:27:30,640 --> 00:27:32,159
among these use cases there is the

690
00:27:32,159 --> 00:27:34,559
memory safe languages

691
00:27:34,559 --> 00:27:36,799
in this category we looked at

692
00:27:36,799 --> 00:27:39,679
go and rasta in particular and we found

693
00:27:39,679 --> 00:27:40,880
out that

694
00:27:40,880 --> 00:27:43,279
both of the these languages when they

695
00:27:43,279 --> 00:27:45,600
introduce security checks

696
00:27:45,600 --> 00:27:47,679
they basically introduce avenues for us

697
00:27:47,679 --> 00:27:50,000
spear attacks they both are affected we

698
00:27:50,000 --> 00:27:52,640
brought pocs for each one of the

699
00:27:52,640 --> 00:27:54,240
these two languages

700
00:27:54,240 --> 00:27:56,720
and for go we conducted the go security

701
00:27:56,720 --> 00:27:59,279
team in november 2019 and we discussed

702
00:27:59,279 --> 00:28:02,000
with them of possible solutions and uh

703
00:28:02,000 --> 00:28:04,159
the outcome of our discussion was uh

704
00:28:04,159 --> 00:28:06,559
this new spectre flag that was

705
00:28:06,559 --> 00:28:10,000
introduced in ago version 115

706
00:28:10,000 --> 00:28:11,279
uh and so

707
00:28:11,279 --> 00:28:13,760
we with the use of this flag basically

708
00:28:13,760 --> 00:28:14,960
um

709
00:28:14,960 --> 00:28:17,120
these problems this pr problem was was

710
00:28:17,120 --> 00:28:20,399
uh resolved for uh rust we reported

711
00:28:20,399 --> 00:28:22,799
our findings in december 2020 and we are

712
00:28:22,799 --> 00:28:25,440
currently in discussion to uh towards a

713
00:28:25,440 --> 00:28:29,600
solution for this more details about

714
00:28:29,600 --> 00:28:32,159
our work on memories uh safe languages

715
00:28:32,159 --> 00:28:37,200
can be found in our eurosmp 2021 paper

716
00:28:37,200 --> 00:28:39,520
the final use case that we looked in uh

717
00:28:39,520 --> 00:28:41,760
during our work was actually the control

718
00:28:41,760 --> 00:28:43,760
flow integrity case that

719
00:28:43,760 --> 00:28:46,399
is related to the architectural override

720
00:28:46,399 --> 00:28:48,240
of forward edges

721
00:28:48,240 --> 00:28:49,919
in this case we looked at the

722
00:28:49,919 --> 00:28:53,120
implementation of the llvmc5 and the gcc

723
00:28:53,120 --> 00:28:54,480
vtv

724
00:28:54,480 --> 00:28:58,000
we found out that llvm cfi was actually

725
00:28:58,000 --> 00:29:00,480
not by possible using spear attacks and

726
00:29:00,480 --> 00:29:02,320
this is due to one

727
00:29:02,320 --> 00:29:06,080
very fortunate design decision from llvm

728
00:29:06,080 --> 00:29:07,760
that basically embeds some of the

729
00:29:07,760 --> 00:29:10,320
metadata within the pointer and so when

730
00:29:10,320 --> 00:29:11,120
we

731
00:29:11,120 --> 00:29:12,880
try to evict the metadata we also

732
00:29:12,880 --> 00:29:14,640
evicted pointer and and so the

733
00:29:14,640 --> 00:29:17,440
speculative execution will block

734
00:29:17,440 --> 00:29:19,120
and and also there are other checks that

735
00:29:19,120 --> 00:29:21,360
llvmcfi introduces but there are against

736
00:29:21,360 --> 00:29:23,520
the constant that are in line in the

737
00:29:23,520 --> 00:29:26,159
code so we cannot really evict those and

738
00:29:26,159 --> 00:29:28,320
to start our uh

739
00:29:28,320 --> 00:29:29,760
our attack

740
00:29:29,760 --> 00:29:33,120
for uh gcc tv instead uh the type of

741
00:29:33,120 --> 00:29:36,000
checks that the gccvtv introduces is

742
00:29:36,000 --> 00:29:38,240
actually vulnerable to spear and we have

743
00:29:38,240 --> 00:29:41,279
a smaller poc that that proves it

744
00:29:41,279 --> 00:29:44,159
um one key point from our analysis of

745
00:29:44,159 --> 00:29:46,640
control flow integrity is uh is really

746
00:29:46,640 --> 00:29:49,039
that uh this type of attacks the spear

747
00:29:49,039 --> 00:29:50,960
attacks are really implement

748
00:29:50,960 --> 00:29:53,440
implementation dependent so each one of

749
00:29:53,440 --> 00:29:55,360
the mitigations each one of the versions

750
00:29:55,360 --> 00:29:57,279
of the mitigations that

751
00:29:57,279 --> 00:30:00,000
are out there should be verified to be

752
00:30:00,000 --> 00:30:02,080
uh resilient against this type of

753
00:30:02,080 --> 00:30:05,679
attacks again more details on how we did

754
00:30:05,679 --> 00:30:09,039
our analysis on control for integrity

755
00:30:09,039 --> 00:30:12,480
is available in our eurosmp paper

756
00:30:12,480 --> 00:30:15,440
so we so far we didn't really speak much

757
00:30:15,440 --> 00:30:17,679
about mitigations there are of course

758
00:30:17,679 --> 00:30:19,760
mitigations against our

759
00:30:19,760 --> 00:30:21,679
spear attacks

760
00:30:21,679 --> 00:30:24,720
one set of mitigations is actually

761
00:30:24,720 --> 00:30:26,480
instrumentation of the application that

762
00:30:26,480 --> 00:30:28,960
we want to protect

763
00:30:28,960 --> 00:30:32,240
the the there are already

764
00:30:32,240 --> 00:30:33,600
compiler

765
00:30:33,600 --> 00:30:35,600
passes that helps

766
00:30:35,600 --> 00:30:37,840
the user to instrument the application

767
00:30:37,840 --> 00:30:39,520
against against the spear for instance

768
00:30:39,520 --> 00:30:41,679
we have the llvm speculation speculative

769
00:30:41,679 --> 00:30:43,600
load hardening

770
00:30:43,600 --> 00:30:45,360
the problem with this type of approach

771
00:30:45,360 --> 00:30:48,559
of inlining defenses is that

772
00:30:48,559 --> 00:30:50,799
there is always a very fine line between

773
00:30:50,799 --> 00:30:51,600
a

774
00:30:51,600 --> 00:30:53,279
harder trade-off between you know

775
00:30:53,279 --> 00:30:55,520
coverage and overhead so

776
00:30:55,520 --> 00:30:56,480
the more

777
00:30:56,480 --> 00:30:57,360
uh

778
00:30:57,360 --> 00:31:00,159
patterns in the code we we protect

779
00:31:00,159 --> 00:31:03,039
uh the higher is the overhead and so

780
00:31:03,039 --> 00:31:05,279
it's very hard to find which are the

781
00:31:05,279 --> 00:31:07,919
sensible uh code patterns that we want

782
00:31:07,919 --> 00:31:09,760
to protect versus the one that we want

783
00:31:09,760 --> 00:31:10,799
to leave

784
00:31:10,799 --> 00:31:12,320
not protected

785
00:31:12,320 --> 00:31:14,240
um examples of this type of

786
00:31:14,240 --> 00:31:16,080
instrumentation there are fencing

787
00:31:16,080 --> 00:31:17,600
instruction that can be in line in the

788
00:31:17,600 --> 00:31:20,720
code there is a branchless masking or

789
00:31:20,720 --> 00:31:24,080
construct such as red pulling

790
00:31:24,080 --> 00:31:27,600
there are other type of mitigations that

791
00:31:27,600 --> 00:31:30,320
the microarchitectural community

792
00:31:30,320 --> 00:31:33,120
has been working on and these these

793
00:31:33,120 --> 00:31:35,760
mitigations aim to change the design in

794
00:31:35,760 --> 00:31:39,279
which the uh the cpu uh works

795
00:31:39,279 --> 00:31:41,360
and the idea one line of work is

796
00:31:41,360 --> 00:31:43,600
actually to introduce data flow analysis

797
00:31:43,600 --> 00:31:46,559
in the cpu pipeline such that

798
00:31:46,559 --> 00:31:49,279
the cpu will be able to

799
00:31:49,279 --> 00:31:51,600
identify unsafe operations and will be

800
00:31:51,600 --> 00:31:53,519
able to block those unsafe operations to

801
00:31:53,519 --> 00:31:54,960
take place

802
00:31:54,960 --> 00:31:57,519
and delay them when it's safe for them

803
00:31:57,519 --> 00:31:59,519
to be executed them

804
00:31:59,519 --> 00:32:01,760
this line of work would actually prevent

805
00:32:01,760 --> 00:32:05,440
completely all our spirit attacks

806
00:32:05,440 --> 00:32:07,679
the second line of work instead focuses

807
00:32:07,679 --> 00:32:10,399
on changing the um

808
00:32:10,399 --> 00:32:12,960
the cash hierarchy design

809
00:32:12,960 --> 00:32:14,559
such that the

810
00:32:14,559 --> 00:32:16,880
side channels and cover channels in the

811
00:32:16,880 --> 00:32:18,159
in the cache

812
00:32:18,159 --> 00:32:20,080
will be eliminated

813
00:32:20,080 --> 00:32:21,919
while this is effective

814
00:32:21,919 --> 00:32:24,320
uh for certain sphere attacks that are

815
00:32:24,320 --> 00:32:25,600
based on the

816
00:32:25,600 --> 00:32:26,880
on the cache

817
00:32:26,880 --> 00:32:28,640
uh

818
00:32:28,640 --> 00:32:30,640
they do not work for a spear attacks

819
00:32:30,640 --> 00:32:32,320
that are mounted with

820
00:32:32,320 --> 00:32:34,240
other side channels for instance support

821
00:32:34,240 --> 00:32:37,679
contention or b2b

822
00:32:38,000 --> 00:32:40,640
one problem with this type of design

823
00:32:40,640 --> 00:32:43,200
approach is that they only cover new

824
00:32:43,200 --> 00:32:44,720
iterations of the cpu but they don't

825
00:32:44,720 --> 00:32:49,360
cover currently existing architecture

826
00:32:49,360 --> 00:32:51,679
um so what are the takeaway ways of our

827
00:32:51,679 --> 00:32:54,000
talk so we we showed that we are able to

828
00:32:54,000 --> 00:32:56,480
bypass using a sphere

829
00:32:56,480 --> 00:32:57,360
current

830
00:32:57,360 --> 00:33:00,399
mitigations and memory safety mechanism

831
00:33:00,399 --> 00:33:04,000
to leak confidential data

832
00:33:04,000 --> 00:33:05,200
one

833
00:33:05,200 --> 00:33:07,200
key point here is that

834
00:33:07,200 --> 00:33:09,840
new and old mitigation should be

835
00:33:09,840 --> 00:33:12,000
analyzed to see if they are actually

836
00:33:12,000 --> 00:33:14,399
resilient against these attacks and some

837
00:33:14,399 --> 00:33:16,880
of the design must change to basically

838
00:33:16,880 --> 00:33:19,039
make sure that the spear attacks are not

839
00:33:19,039 --> 00:33:22,158
possible against them

840
00:33:22,720 --> 00:33:24,799
as alexandra showed you these type of

841
00:33:24,799 --> 00:33:25,840
attacks

842
00:33:25,840 --> 00:33:29,360
in real-world settings have many stages

843
00:33:29,360 --> 00:33:31,760
and they are relatively in each one of

844
00:33:31,760 --> 00:33:34,480
these stages as a success rate

845
00:33:34,480 --> 00:33:35,360
and

846
00:33:35,360 --> 00:33:37,360
everything should

847
00:33:37,360 --> 00:33:39,440
work together to have a successful

848
00:33:39,440 --> 00:33:40,480
attack but

849
00:33:40,480 --> 00:33:42,240
it is also sure that they are practical

850
00:33:42,240 --> 00:33:45,039
that we can achieve an end-to-end attack

851
00:33:45,039 --> 00:33:47,760
and the idea here is that with new tools

852
00:33:47,760 --> 00:33:50,559
more tailor tools again towards like

853
00:33:50,559 --> 00:33:52,880
automating each one of the phases will

854
00:33:52,880 --> 00:33:54,240
improve again

855
00:33:54,240 --> 00:33:56,080
the practicality of this uh of these

856
00:33:56,080 --> 00:33:57,760
type of attacks

857
00:33:57,760 --> 00:34:00,559
finally in a in our end-to-end poc we

858
00:34:00,559 --> 00:34:02,799
employ speculative rope and we show that

859
00:34:02,799 --> 00:34:04,880
it's possible to use speculative drop in

860
00:34:04,880 --> 00:34:07,039
in these attacks and

861
00:34:07,039 --> 00:34:09,199
this technique actually helps a great

862
00:34:09,199 --> 00:34:12,480
deal to for instance build uh complex

863
00:34:12,480 --> 00:34:15,440
gadgets such as the spectral v1 gadgets

864
00:34:15,440 --> 00:34:16,879
such and send

865
00:34:16,879 --> 00:34:18,639
that

866
00:34:18,639 --> 00:34:21,760
really uh is hard to find in normally in

867
00:34:21,760 --> 00:34:25,040
in a in the user's code

868
00:34:25,040 --> 00:34:27,440
in general uh we foresee that

869
00:34:27,440 --> 00:34:29,839
speculative execution attacks will be

870
00:34:29,839 --> 00:34:32,639
the challenge for the next decade

871
00:34:32,639 --> 00:34:36,960
so far uh we still lack of many tools

872
00:34:36,960 --> 00:34:39,679
uh to understand and study and build

873
00:34:39,679 --> 00:34:42,560
these attacks as well as like only very

874
00:34:42,560 --> 00:34:44,560
few attacks have been uh been studied

875
00:34:44,560 --> 00:34:46,239
then we've believed that there is the

876
00:34:46,239 --> 00:34:49,040
attack surface still quite large to be

877
00:34:49,040 --> 00:34:50,159
explored

878
00:34:50,159 --> 00:34:53,040
and also we will need to work a lot in

879
00:34:53,040 --> 00:34:55,199
defenses because as i was mentioning

880
00:34:55,199 --> 00:34:56,960
before for instance in the inlining type

881
00:34:56,960 --> 00:34:58,640
of defenses it's very hard to find the

882
00:34:58,640 --> 00:35:00,800
right trade-off and so we might need to

883
00:35:00,800 --> 00:35:03,520
come up with a better heuristic for this

884
00:35:03,520 --> 00:35:06,800
and with this i conclude here are some

885
00:35:06,800 --> 00:35:08,560
of the references that we used during

886
00:35:08,560 --> 00:35:10,800
our talk

887
00:35:10,800 --> 00:35:13,440
if you have any questions

888
00:35:13,440 --> 00:35:16,160
thank you

