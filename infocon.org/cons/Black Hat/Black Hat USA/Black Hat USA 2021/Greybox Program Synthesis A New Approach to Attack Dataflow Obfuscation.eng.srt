1
00:00:01,130 --> 00:00:13,919
[Music]

2
00:00:13,920 --> 00:00:15,759
hello everyone so thank you for being

3
00:00:15,759 --> 00:00:18,480
here uh welcome to this virtual talk

4
00:00:18,480 --> 00:00:21,439
about graybox program synthesis

5
00:00:21,439 --> 00:00:21,870
um

6
00:00:21,870 --> 00:00:23,279
[Music]

7
00:00:23,279 --> 00:00:25,680
so just few words about me i'm robin

8
00:00:25,680 --> 00:00:27,599
david i'm a software security engineer

9
00:00:27,599 --> 00:00:30,480
at quarks lab a french cyber security

10
00:00:30,480 --> 00:00:31,599
company

11
00:00:31,599 --> 00:00:33,440
and i'm working on obfuscation and

12
00:00:33,440 --> 00:00:35,840
especially the obfuscations

13
00:00:35,840 --> 00:00:39,920
and many ways to automate bug discovery

14
00:00:39,920 --> 00:00:42,239
okay so what is the agenda of today i'm

15
00:00:42,239 --> 00:00:43,920
first going to get some definitions

16
00:00:43,920 --> 00:00:46,879
about obfuscation and synthesis

17
00:00:46,879 --> 00:00:49,280
then i'm going to describe our gray box

18
00:00:49,280 --> 00:00:51,360
synthesis algorithms that we use for the

19
00:00:51,360 --> 00:00:53,360
obfuscations

20
00:00:53,360 --> 00:00:55,520
and then i'm going to

21
00:00:55,520 --> 00:00:57,680
describe the implementations and

22
00:00:57,680 --> 00:01:00,640
the use cases on which we applied

23
00:01:00,640 --> 00:01:03,039
this approach

24
00:01:03,039 --> 00:01:07,200
okay let's jump straight to obfuscation

25
00:01:07,200 --> 00:01:09,600
what is obfuscation

26
00:01:09,600 --> 00:01:12,080
we usually refer it to the the means of

27
00:01:12,080 --> 00:01:13,680
transforming a program into a

28
00:01:13,680 --> 00:01:16,240
semantically equivalent program but

29
00:01:16,240 --> 00:01:18,000
which is meant to be harder to

30
00:01:18,000 --> 00:01:19,840
understand

31
00:01:19,840 --> 00:01:21,280
why we do that

32
00:01:21,280 --> 00:01:24,640
mostly to protect intellectual property

33
00:01:24,640 --> 00:01:26,320
so we do find a presentation also in

34
00:01:26,320 --> 00:01:27,840
malware but

35
00:01:27,840 --> 00:01:31,840
most of the time uh we find it in

36
00:01:31,840 --> 00:01:34,640
mobile applications softwares

37
00:01:34,640 --> 00:01:36,799
from completely legitimate companies and

38
00:01:36,799 --> 00:01:38,960
so on so

39
00:01:38,960 --> 00:01:42,240
we less often see it in malware

40
00:01:42,240 --> 00:01:44,720
so how we do that

41
00:01:44,720 --> 00:01:47,200
so the idea is to within the program you

42
00:01:47,200 --> 00:01:50,000
want to protect the valuable assets

43
00:01:50,000 --> 00:01:52,079
and what are the valuable assets in the

44
00:01:52,079 --> 00:01:53,119
program

45
00:01:53,119 --> 00:01:54,960
usually it's the program logics or the

46
00:01:54,960 --> 00:01:57,040
algorithms

47
00:01:57,040 --> 00:01:59,439
or the data the data can be strings

48
00:01:59,439 --> 00:02:01,119
constant although all these kind of

49
00:02:01,119 --> 00:02:03,360
things

50
00:02:04,000 --> 00:02:07,119
so we usually

51
00:02:07,119 --> 00:02:08,720
uh separate

52
00:02:08,720 --> 00:02:10,959
obfuscation into three categories the

53
00:02:10,959 --> 00:02:12,800
first one is the control flow

54
00:02:12,800 --> 00:02:14,239
observations

55
00:02:14,239 --> 00:02:16,879
where the goal is to hide the logic the

56
00:02:16,879 --> 00:02:19,520
logic of the flow of execution so

57
00:02:19,520 --> 00:02:22,480
at the bottom you see a small cfg of

58
00:02:22,480 --> 00:02:24,720
functions and on the right the

59
00:02:24,720 --> 00:02:27,200
obfuscated versions of the exact same

60
00:02:27,200 --> 00:02:28,319
functions

61
00:02:28,319 --> 00:02:30,319
so there's plenty of applications for

62
00:02:30,319 --> 00:02:32,640
doing so like virtualization flattening

63
00:02:32,640 --> 00:02:36,160
or pack predicates and so on

64
00:02:36,160 --> 00:02:38,000
and otherwise you have

65
00:02:38,000 --> 00:02:40,319
the second category which is data flow

66
00:02:40,319 --> 00:02:42,640
applications which aims at adding

67
00:02:42,640 --> 00:02:46,400
constant strings keys and so on

68
00:02:46,400 --> 00:02:48,080
and for that there is also plenty of

69
00:02:48,080 --> 00:02:49,760
different obfuscation techniques like

70
00:02:49,760 --> 00:02:51,200
data encoding

71
00:02:51,200 --> 00:02:53,440
mba that we are going to discuss white

72
00:02:53,440 --> 00:02:54,640
boxes

73
00:02:54,640 --> 00:02:57,839
encoding and so on

74
00:02:59,120 --> 00:03:01,360
so in this talk we are going to focus on

75
00:03:01,360 --> 00:03:03,920
data obfuscations and more especially on

76
00:03:03,920 --> 00:03:07,680
mba which is mixed boolean arithmetic

77
00:03:07,680 --> 00:03:09,840
what is mixed boolean arithmetic is the

78
00:03:09,840 --> 00:03:11,200
mean of

79
00:03:11,200 --> 00:03:14,720
scrambling expressions using

80
00:03:14,720 --> 00:03:18,319
so bitwise operators like xor and r and

81
00:03:18,319 --> 00:03:21,200
so on and arithmetic operators like plus

82
00:03:21,200 --> 00:03:22,159
minus

83
00:03:22,159 --> 00:03:23,280
and so on

84
00:03:23,280 --> 00:03:26,080
so here is the so we have a small a plus

85
00:03:26,080 --> 00:03:27,680
b expression

86
00:03:27,680 --> 00:03:28,480
uh

87
00:03:28,480 --> 00:03:30,879
and on sophisticated we transform it

88
00:03:30,879 --> 00:03:32,879
with a semantically equivalent

89
00:03:32,879 --> 00:03:35,120
expressions but that is more difficult

90
00:03:35,120 --> 00:03:37,040
to understand

91
00:03:37,040 --> 00:03:38,959
so the questions from a reverse

92
00:03:38,959 --> 00:03:41,519
engineering point of view is how do we

93
00:03:41,519 --> 00:03:44,560
get back the original expressions

94
00:03:44,560 --> 00:03:47,040
and that is the difficult questions

95
00:03:47,040 --> 00:03:48,720
because unlike

96
00:03:48,720 --> 00:03:51,200
control flow obfuscations the the answer

97
00:03:51,200 --> 00:03:52,239
is not

98
00:03:52,239 --> 00:03:53,360
boolean

99
00:03:53,360 --> 00:03:54,159
uh

100
00:03:54,159 --> 00:03:56,000
with control flow observations you

101
00:03:56,000 --> 00:03:58,080
sometimes want to negate branches make

102
00:03:58,080 --> 00:03:59,519
sure uh

103
00:03:59,519 --> 00:04:01,680
check that some of them are dead or so

104
00:04:01,680 --> 00:04:04,400
on but here you really want to recover

105
00:04:04,400 --> 00:04:06,720
the original expression and that is

106
00:04:06,720 --> 00:04:08,959
difficult

107
00:04:08,959 --> 00:04:10,239
so

108
00:04:10,239 --> 00:04:12,720
obfuscations yields two distinct

109
00:04:12,720 --> 00:04:15,120
research problem

110
00:04:15,120 --> 00:04:17,040
the first one is

111
00:04:17,040 --> 00:04:18,959
locating the data that you want to

112
00:04:18,959 --> 00:04:20,560
deficit

113
00:04:20,560 --> 00:04:22,479
and that's highly dependent on the

114
00:04:22,479 --> 00:04:25,440
targets that you are looking at

115
00:04:25,440 --> 00:04:27,280
what you are looking for into the

116
00:04:27,280 --> 00:04:29,280
programs what you want to attack or

117
00:04:29,280 --> 00:04:33,040
retrieve so this is mostly manual and

118
00:04:33,040 --> 00:04:37,280
this is also distinct for each target

119
00:04:37,280 --> 00:04:39,280
and the second problems when you're the

120
00:04:39,280 --> 00:04:41,680
obfuscating programs it's the the deal

121
00:04:41,680 --> 00:04:44,240
fiscation itself so you

122
00:04:44,240 --> 00:04:48,639
it's um once you've found found uh the

123
00:04:48,639 --> 00:04:50,880
data that you want to diffuse get so how

124
00:04:50,880 --> 00:04:52,479
do you deal with this kit do you have to

125
00:04:52,479 --> 00:04:53,600
skate it

126
00:04:53,600 --> 00:04:56,080
and synthesis in a only address this

127
00:04:56,080 --> 00:04:57,600
second issue so

128
00:04:57,600 --> 00:04:59,440
you first have to find

129
00:04:59,440 --> 00:05:01,759
the data register or memory that you

130
00:05:01,759 --> 00:05:03,440
want to duplicate

131
00:05:03,440 --> 00:05:05,360
so i wanted to highlight these two

132
00:05:05,360 --> 00:05:06,720
different issues

133
00:05:06,720 --> 00:05:09,840
in the obfuscation

134
00:05:09,840 --> 00:05:11,680
now i'm going to describe what is

135
00:05:11,680 --> 00:05:15,840
synthesis so synthesis is the mean of

136
00:05:15,840 --> 00:05:17,199
deriving

137
00:05:17,199 --> 00:05:19,680
creating a program given high level

138
00:05:19,680 --> 00:05:22,160
specifications and some additional

139
00:05:22,160 --> 00:05:23,520
constraints

140
00:05:23,520 --> 00:05:25,039
over it

141
00:05:25,039 --> 00:05:27,199
for combination it can be faster program

142
00:05:27,199 --> 00:05:28,720
for the authentication it could be

143
00:05:28,720 --> 00:05:31,759
smaller or more readable program

144
00:05:31,759 --> 00:05:33,360
so

145
00:05:33,360 --> 00:05:35,600
for program synthesis so you usually

146
00:05:35,600 --> 00:05:37,520
have a programming input and that

147
00:05:37,520 --> 00:05:40,400
program is the specifications it encodes

148
00:05:40,400 --> 00:05:42,639
the semantic the behavior that you want

149
00:05:42,639 --> 00:05:45,919
to preserve throughout the synthesis

150
00:05:45,919 --> 00:05:47,919
so you give it a synthesizer that

151
00:05:47,919 --> 00:05:50,800
optimizes some constraints like

152
00:05:50,800 --> 00:05:53,199
speed size or whatever

153
00:05:53,199 --> 00:05:54,960
and then you obtain the new program

154
00:05:54,960 --> 00:05:57,280
which satisfy your

155
00:05:57,280 --> 00:05:59,440
specifications so semantic and the

156
00:05:59,440 --> 00:06:02,080
constraints

157
00:06:02,240 --> 00:06:03,759
so there is two

158
00:06:03,759 --> 00:06:06,240
main use cases for program synthesis the

159
00:06:06,240 --> 00:06:08,560
first one is optimizations

160
00:06:08,560 --> 00:06:10,960
and people doing opinion optimization

161
00:06:10,960 --> 00:06:12,720
with synthesis you usually call it

162
00:06:12,720 --> 00:06:15,120
superior optimization

163
00:06:15,120 --> 00:06:18,160
and there's two nice works for that i

164
00:06:18,160 --> 00:06:21,199
recommend the super

165
00:06:21,199 --> 00:06:23,919
work made by john reger and some folks

166
00:06:23,919 --> 00:06:25,280
at google

167
00:06:25,280 --> 00:06:27,520
and also stock

168
00:06:27,520 --> 00:06:29,440
and but we are going to focus on the

169
00:06:29,440 --> 00:06:31,759
observation in this talk

170
00:06:31,759 --> 00:06:34,400
but but as one might notice this is

171
00:06:34,400 --> 00:06:36,319
basically the same issue at the core

172
00:06:36,319 --> 00:06:38,240
level you have a program and you want to

173
00:06:38,240 --> 00:06:39,520
make it more

174
00:06:39,520 --> 00:06:42,080
more small more efficient

175
00:06:42,080 --> 00:06:43,759
so the you're basically solving the same

176
00:06:43,759 --> 00:06:44,880
issues

177
00:06:44,880 --> 00:06:46,800
um with both optimization and the

178
00:06:46,800 --> 00:06:48,560
obfuscation

179
00:06:48,560 --> 00:06:50,720
okay so for the obfuscation

180
00:06:50,720 --> 00:06:52,800
through synthesis there is multiple

181
00:06:52,800 --> 00:06:54,639
approaches existing

182
00:06:54,639 --> 00:06:56,639
templates stochastic

183
00:06:56,639 --> 00:06:59,599
search based enumerative and so on

184
00:06:59,599 --> 00:07:03,120
i'll give you a small uh overview of the

185
00:07:03,120 --> 00:07:06,400
work that has been done in the past

186
00:07:06,400 --> 00:07:08,560
so the first works i've found about this

187
00:07:08,560 --> 00:07:11,680
is the work performed by royal frauds um

188
00:07:11,680 --> 00:07:13,680
in 2014

189
00:07:13,680 --> 00:07:17,440
is truly a pioneer in this field

190
00:07:17,440 --> 00:07:19,520
then there is the works by nino eros

191
00:07:19,520 --> 00:07:22,160
which was at crosslab at that time

192
00:07:22,160 --> 00:07:24,479
about spam so spam is not truly

193
00:07:24,479 --> 00:07:26,800
synthesis it's more like patterns and

194
00:07:26,800 --> 00:07:28,800
rewriting rules

195
00:07:28,800 --> 00:07:30,560
but yeah that's

196
00:07:30,560 --> 00:07:33,440
one of the first works targeting

197
00:07:33,440 --> 00:07:34,720
um

198
00:07:34,720 --> 00:07:37,520
mbas and giving some implementations for

199
00:07:37,520 --> 00:07:39,680
for it

200
00:07:39,680 --> 00:07:43,440
then in 2017 you have the work of

201
00:07:43,440 --> 00:07:44,960
cynthia that has been published at

202
00:07:44,960 --> 00:07:46,800
usenix and they use the stochastic

203
00:07:46,800 --> 00:07:49,599
approach using monte carlo search tree

204
00:07:49,599 --> 00:07:51,199
i'm not going to describe that approach

205
00:07:51,199 --> 00:07:52,000
but

206
00:07:52,000 --> 00:07:55,360
it does it's really interesting approach

207
00:07:55,360 --> 00:07:59,039
lately in 2020 we did published some

208
00:07:59,039 --> 00:08:02,080
academic results in an academic venue

209
00:08:02,080 --> 00:08:04,160
about our approach that we called q

210
00:08:04,160 --> 00:08:05,599
synth

211
00:08:05,599 --> 00:08:08,720
which is based on the name enumerative

212
00:08:08,720 --> 00:08:10,479
search

213
00:08:10,479 --> 00:08:12,400
and lately this year

214
00:08:12,400 --> 00:08:13,599
there is

215
00:08:13,599 --> 00:08:14,879
some

216
00:08:14,879 --> 00:08:17,520
interest for mbas and synthesis so there

217
00:08:17,520 --> 00:08:19,280
is more works that have been published

218
00:08:19,280 --> 00:08:20,720
in xintia

219
00:08:20,720 --> 00:08:22,240
msint which is basically the

220
00:08:22,240 --> 00:08:23,680
implementations

221
00:08:23,680 --> 00:08:25,759
and implementation of kucints using

222
00:08:25,759 --> 00:08:27,280
miasma

223
00:08:27,280 --> 00:08:29,680
by the same people of cynthia

224
00:08:29,680 --> 00:08:31,520
and loki which is more

225
00:08:31,520 --> 00:08:32,958
oriented than

226
00:08:32,958 --> 00:08:35,919
making obfuscation more resilient to

227
00:08:35,919 --> 00:08:38,320
synthesis

228
00:08:38,320 --> 00:08:41,200
okay so what is gray box synthesis i'm

229
00:08:41,200 --> 00:08:44,159
going to describe the algorithm

230
00:08:44,159 --> 00:08:46,560
so our approach um

231
00:08:46,560 --> 00:08:49,680
use two components uh a symbolic

232
00:08:49,680 --> 00:08:52,320
executions and a synthesizer so the

233
00:08:52,320 --> 00:08:54,000
basic workflow is that you have a

234
00:08:54,000 --> 00:08:57,200
program you execute it symbolically

235
00:08:57,200 --> 00:08:58,880
then you obtain some expressions that

236
00:08:58,880 --> 00:09:01,120
you want to simplify you give it to the

237
00:09:01,120 --> 00:09:02,880
synthesizer and hopefully you obtain

238
00:09:02,880 --> 00:09:06,000
some synthesized expressions

239
00:09:06,000 --> 00:09:09,040
so we only use symbolic execution as a

240
00:09:09,040 --> 00:09:11,040
mean to obtain some data from

241
00:09:11,040 --> 00:09:13,360
expressions if you're able to

242
00:09:13,360 --> 00:09:15,839
retrieve uh expressions that comes from

243
00:09:15,839 --> 00:09:17,360
with a different approach that's

244
00:09:17,360 --> 00:09:19,920
perfectly fine for us

245
00:09:19,920 --> 00:09:21,600
because this is not the main of the

246
00:09:21,600 --> 00:09:23,200
algorithms we just want to have

247
00:09:23,200 --> 00:09:25,600
expressions that we want to simplify

248
00:09:25,600 --> 00:09:27,680
in practice we can we do our symbolic

249
00:09:27,680 --> 00:09:29,920
execution statically or dynamically on

250
00:09:29,920 --> 00:09:31,279
the trace

251
00:09:31,279 --> 00:09:32,399
that works

252
00:09:32,399 --> 00:09:34,240
the same

253
00:09:34,240 --> 00:09:36,640
and so to give you a little overview of

254
00:09:36,640 --> 00:09:38,000
how it works so

255
00:09:38,000 --> 00:09:39,680
here is a small mba

256
00:09:39,680 --> 00:09:41,680
at assembly level

257
00:09:41,680 --> 00:09:43,920
if you execute it with a symbolic

258
00:09:43,920 --> 00:09:46,320
executor it will lift it to an

259
00:09:46,320 --> 00:09:48,800
intermediate representation

260
00:09:48,800 --> 00:09:51,519
encoding the semantic

261
00:09:51,519 --> 00:09:53,279
and let's say that you want to have the

262
00:09:53,279 --> 00:09:55,519
area x5 at the end here

263
00:09:55,519 --> 00:09:57,760
what you are going to obtain is an

264
00:09:57,760 --> 00:09:59,839
abstract syntax tree

265
00:09:59,839 --> 00:10:00,959
of

266
00:10:00,959 --> 00:10:05,120
representing the area x5

267
00:10:05,120 --> 00:10:06,160
value

268
00:10:06,160 --> 00:10:09,040
at that location

269
00:10:09,519 --> 00:10:11,279
so

270
00:10:11,279 --> 00:10:13,760
our graybox synthesizer takes

271
00:10:13,760 --> 00:10:16,079
asts of expression as input that's

272
00:10:16,079 --> 00:10:18,959
really the input of the synthesizer we

273
00:10:18,959 --> 00:10:21,360
want you we have a huge st and we want

274
00:10:21,360 --> 00:10:24,079
to obtain something which is smaller

275
00:10:24,079 --> 00:10:26,560
and it's based on two components the

276
00:10:26,560 --> 00:10:28,959
input output oracle

277
00:10:28,959 --> 00:10:31,200
which is our main contributions in terms

278
00:10:31,200 --> 00:10:33,279
of synthesis so that's the black box

279
00:10:33,279 --> 00:10:36,399
components i'm going to describe it

280
00:10:36,399 --> 00:10:38,480
and we also have the ast simplification

281
00:10:38,480 --> 00:10:40,079
algorithms which is the white box

282
00:10:40,079 --> 00:10:41,760
component

283
00:10:41,760 --> 00:10:43,760
and so the id is the following

284
00:10:43,760 --> 00:10:45,440
you have your expressions you try to

285
00:10:45,440 --> 00:10:47,839
synthesize from the root node

286
00:10:47,839 --> 00:10:49,760
if you do not does not succeed you're

287
00:10:49,760 --> 00:10:51,279
just going to iterate through the

288
00:10:51,279 --> 00:10:53,040
subnodes

289
00:10:53,040 --> 00:10:55,920
trying to simplify opportunistically

290
00:10:55,920 --> 00:10:58,079
sub sub expressions

291
00:10:58,079 --> 00:10:59,680
and that's why you are going to have in

292
00:10:59,680 --> 00:11:01,839
and outs between the black box oracle

293
00:11:01,839 --> 00:11:05,839
and the ast simplification algorithm

294
00:11:05,839 --> 00:11:08,320
um so the black box purely black box

295
00:11:08,320 --> 00:11:11,760
approach when we say black box it's um

296
00:11:11,760 --> 00:11:14,640
usually referring at the comparing the

297
00:11:14,640 --> 00:11:18,800
input and output behavior of the program

298
00:11:18,800 --> 00:11:20,720
so you're not considering the semantics

299
00:11:20,720 --> 00:11:21,920
so

300
00:11:21,920 --> 00:11:24,000
that's a good thing when you're dealing

301
00:11:24,000 --> 00:11:26,640
with obfuscations

302
00:11:26,640 --> 00:11:28,720
but you have a huge search space to to

303
00:11:28,720 --> 00:11:32,079
look for and the boolean is uh

304
00:11:32,079 --> 00:11:36,079
the result is boolean because um

305
00:11:36,079 --> 00:11:38,399
either you synthesize it all at once or

306
00:11:38,399 --> 00:11:40,839
it does not synthesis it at

307
00:11:40,839 --> 00:11:42,560
all

308
00:11:42,560 --> 00:11:44,240
and on the other hand when we refer to

309
00:11:44,240 --> 00:11:46,720
the white white box aspects it works for

310
00:11:46,720 --> 00:11:48,560
symbolic execution fading and things

311
00:11:48,560 --> 00:11:49,760
like this

312
00:11:49,760 --> 00:11:52,560
white box is manipulating

313
00:11:52,560 --> 00:11:54,880
the semantic of the expressions through

314
00:11:54,880 --> 00:11:56,959
its syntactic representation which is

315
00:11:56,959 --> 00:11:59,600
usually the ir

316
00:11:59,600 --> 00:12:02,240
and in our context it means that you are

317
00:12:02,240 --> 00:12:04,079
going to manipulate

318
00:12:04,079 --> 00:12:06,560
the ast itself and the expressions the

319
00:12:06,560 --> 00:12:08,800
operators that are have been are being

320
00:12:08,800 --> 00:12:11,600
used and so on so

321
00:12:11,600 --> 00:12:13,360
the good point is that you consider the

322
00:12:13,360 --> 00:12:15,040
exact semantic

323
00:12:15,040 --> 00:12:16,720
of the expressions

324
00:12:16,720 --> 00:12:18,800
but as we are dealing with obfuscation

325
00:12:18,800 --> 00:12:21,360
we are hindered by the syntactic

326
00:12:21,360 --> 00:12:24,800
complexity of the expressions

327
00:12:24,800 --> 00:12:27,279
so balancing between the two is really

328
00:12:27,279 --> 00:12:28,880
um

329
00:12:28,880 --> 00:12:32,560
a good choice from our point of view

330
00:12:32,560 --> 00:12:35,600
so now i'm going to describe a bit the

331
00:12:35,600 --> 00:12:38,720
input output synthesis oracle so let's

332
00:12:38,720 --> 00:12:40,880
consider here that you have

333
00:12:40,880 --> 00:12:43,519
a plus b an expression that is known and

334
00:12:43,519 --> 00:12:45,440
a black box for which you want to know

335
00:12:45,440 --> 00:12:46,720
what is

336
00:12:46,720 --> 00:12:48,639
his behavior

337
00:12:48,639 --> 00:12:50,560
what you are going to do is to

338
00:12:50,560 --> 00:12:52,480
generate some uh

339
00:12:52,480 --> 00:12:54,639
input vectors that give some valuation

340
00:12:54,639 --> 00:12:56,720
for a and b and you're going to

341
00:12:56,720 --> 00:12:58,399
give them to the expressions you're

342
00:12:58,399 --> 00:13:00,639
going to evaluate the expressions with

343
00:13:00,639 --> 00:13:02,959
those inputs

344
00:13:02,959 --> 00:13:04,399
and then you obtain

345
00:13:04,399 --> 00:13:06,399
an output vector

346
00:13:06,399 --> 00:13:08,240
and if at some point

347
00:13:08,240 --> 00:13:10,480
the values are all the same

348
00:13:10,480 --> 00:13:14,160
what you can deduce is that um

349
00:13:14,160 --> 00:13:17,040
the black box here is indeed doing an a

350
00:13:17,040 --> 00:13:19,760
plus b operation so that's the basic

351
00:13:19,760 --> 00:13:22,160
idea behind black box input output

352
00:13:22,160 --> 00:13:24,719
synthesis

353
00:13:25,200 --> 00:13:26,560
and what we do

354
00:13:26,560 --> 00:13:28,800
to perform some such

355
00:13:28,800 --> 00:13:30,240
computations

356
00:13:30,240 --> 00:13:32,240
and this is the three-inch strength of

357
00:13:32,240 --> 00:13:35,120
our approach is that

358
00:13:35,120 --> 00:13:37,600
we are going to pre-compute

359
00:13:37,600 --> 00:13:39,760
uh all the possible expressions if you

360
00:13:39,760 --> 00:13:42,240
can say so we take a grammar

361
00:13:42,240 --> 00:13:44,639
with some operators and variables and

362
00:13:44,639 --> 00:13:46,480
what we are going to generate all the

363
00:13:46,480 --> 00:13:49,360
possible expressions up to a given bound

364
00:13:49,360 --> 00:13:51,199
of view obviously

365
00:13:51,199 --> 00:13:53,040
and we are going to evaluate those

366
00:13:53,040 --> 00:13:55,920
expressions on the the input vector to

367
00:13:55,920 --> 00:13:58,160
obtain the output vector

368
00:13:58,160 --> 00:14:01,440
and that gives us this mapping of output

369
00:14:01,440 --> 00:14:04,880
vector to the associated expressions

370
00:14:04,880 --> 00:14:07,680
and so when you want to evaluate to

371
00:14:07,680 --> 00:14:09,600
perform the synthesis of a given black

372
00:14:09,600 --> 00:14:11,040
box here for instance you're going to

373
00:14:11,040 --> 00:14:12,639
evaluate it

374
00:14:12,639 --> 00:14:15,120
you obtain the output vector

375
00:14:15,120 --> 00:14:17,360
and if you find it in our in your table

376
00:14:17,360 --> 00:14:20,480
you know which expression it's encoding

377
00:14:20,480 --> 00:14:22,800
and so the strength here is that you

378
00:14:22,800 --> 00:14:25,839
generate this table only once

379
00:14:25,839 --> 00:14:27,680
offline

380
00:14:27,680 --> 00:14:29,680
and then you're going to use it when you

381
00:14:29,680 --> 00:14:32,320
are go you are synthesizing

382
00:14:32,320 --> 00:14:35,199
the perf the the output vector this

383
00:14:35,199 --> 00:14:37,839
approach is basically unsound because

384
00:14:37,839 --> 00:14:40,240
if the vector is too small you might

385
00:14:40,240 --> 00:14:42,560
miss some behaviors

386
00:14:42,560 --> 00:14:44,560
but you can also check the equivalence

387
00:14:44,560 --> 00:14:46,240
to make sure that you're synthesizing

388
00:14:46,240 --> 00:14:47,360
something

389
00:14:47,360 --> 00:14:49,519
equivalent

390
00:14:49,519 --> 00:14:51,279
but the question here is

391
00:14:51,279 --> 00:14:52,959
what happens if

392
00:14:52,959 --> 00:14:55,199
you cannot synthesize the root node and

393
00:14:55,199 --> 00:14:57,360
that this is where

394
00:14:57,360 --> 00:14:59,839
the white box ast search is going to

395
00:14:59,839 --> 00:15:01,519
come into place

396
00:15:01,519 --> 00:15:04,160
and the idea of iterating through the

397
00:15:04,160 --> 00:15:07,279
sub nodes is to be able to

398
00:15:07,279 --> 00:15:09,279
synthesize

399
00:15:09,279 --> 00:15:11,680
obtain a partial synthesis of the

400
00:15:11,680 --> 00:15:14,240
expression

401
00:15:14,240 --> 00:15:16,480
and here is the the original strategy

402
00:15:16,480 --> 00:15:19,199
that we've implemented so you we were in

403
00:15:19,199 --> 00:15:21,839
iterating the the st and

404
00:15:21,839 --> 00:15:23,920
replacing things that we've been able to

405
00:15:23,920 --> 00:15:26,160
synthesize and at the end we substitute

406
00:15:26,160 --> 00:15:27,360
all of them

407
00:15:27,360 --> 00:15:29,130
and we obtained the resulting

408
00:15:29,130 --> 00:15:30,240
[Music]

409
00:15:30,240 --> 00:15:33,120
de-obfuscated expressions

410
00:15:33,120 --> 00:15:35,279
some of you might have noticed here that

411
00:15:35,279 --> 00:15:36,959
we have some complexity issues because

412
00:15:36,959 --> 00:15:39,279
we are restarting from the root node at

413
00:15:39,279 --> 00:15:41,519
each iterations to iterate through the

414
00:15:41,519 --> 00:15:42,959
whole ast

415
00:15:42,959 --> 00:15:44,720
so on huge

416
00:15:44,720 --> 00:15:49,680
ast that might be kind of complicated

417
00:15:50,000 --> 00:15:52,560
we also experimented a few other

418
00:15:52,560 --> 00:15:55,040
strategies that was fixing those

419
00:15:55,040 --> 00:15:58,240
complexity issues so the first one was

420
00:15:58,240 --> 00:16:01,680
a top-down approach

421
00:16:01,680 --> 00:16:03,839
where we ether it through the ast only

422
00:16:03,839 --> 00:16:06,560
once so it's like a divide and conquer

423
00:16:06,560 --> 00:16:09,120
and as we go we simplify the nodes that

424
00:16:09,120 --> 00:16:11,600
we are able to to synthesize

425
00:16:11,600 --> 00:16:15,279
it's not the optimal um algorithm but

426
00:16:15,279 --> 00:16:17,519
this is the fastest

427
00:16:17,519 --> 00:16:19,519
and then we had the top down and bottom

428
00:16:19,519 --> 00:16:21,600
up approach which was also replacing

429
00:16:21,600 --> 00:16:24,320
with placeholder variables so v1 was the

430
00:16:24,320 --> 00:16:27,360
placeholders and you do it recursively

431
00:16:27,360 --> 00:16:29,360
so the algorithm is more

432
00:16:29,360 --> 00:16:31,440
efficient and you obtain something which

433
00:16:31,440 --> 00:16:33,120
is more

434
00:16:33,120 --> 00:16:34,959
smaller than the

435
00:16:34,959 --> 00:16:38,079
simple divide and conquer algorithm

436
00:16:38,079 --> 00:16:39,519
so we experimented with all these

437
00:16:39,519 --> 00:16:42,880
strategies there's probably others to

438
00:16:42,880 --> 00:16:45,600
to implement

439
00:16:46,480 --> 00:16:49,120
and the questions that we we had in mind

440
00:16:49,120 --> 00:16:51,680
is how much how many

441
00:16:51,680 --> 00:16:53,279
sub expressions

442
00:16:53,279 --> 00:16:56,160
we were able to synthesize on the whole

443
00:16:56,160 --> 00:16:58,320
big ast and so we made a small

444
00:16:58,320 --> 00:17:00,240
visualization of the algorithms to to

445
00:17:00,240 --> 00:17:01,920
look at it

446
00:17:01,920 --> 00:17:03,360
and as you can see even though you're

447
00:17:03,360 --> 00:17:05,119
not we are not able to synthesize the

448
00:17:05,119 --> 00:17:07,359
whole ast at least we are able to

449
00:17:07,359 --> 00:17:08,559
synthesize

450
00:17:08,559 --> 00:17:10,640
many many uh

451
00:17:10,640 --> 00:17:14,720
sub expressions within this big asd

452
00:17:14,720 --> 00:17:17,839
and that this is where the gray box

453
00:17:17,839 --> 00:17:19,199
combinations

454
00:17:19,199 --> 00:17:21,280
helps

455
00:17:21,280 --> 00:17:25,119
synthesizing expressions

456
00:17:27,119 --> 00:17:30,480
we have some other examples here

457
00:17:30,480 --> 00:17:32,799
here are the top left you have like uh

458
00:17:32,799 --> 00:17:36,880
ns ast which is uh something like uh

459
00:17:36,880 --> 00:17:39,600
hundred thousands of nodes big

460
00:17:39,600 --> 00:17:41,120
and as you can see we are able to

461
00:17:41,120 --> 00:17:42,640
synthesize many

462
00:17:42,640 --> 00:17:45,280
at many locations and we reduce its size

463
00:17:45,280 --> 00:17:46,880
like

464
00:17:46,880 --> 00:17:49,679
significantly

465
00:17:55,360 --> 00:17:59,360
and here is the result as a graphics

466
00:17:59,360 --> 00:18:00,400
okay so

467
00:18:00,400 --> 00:18:02,240
now i'd just like to discuss the table

468
00:18:02,240 --> 00:18:04,480
generation process which is also a

469
00:18:04,480 --> 00:18:07,120
critical part of our

470
00:18:07,120 --> 00:18:08,960
uh algorithm

471
00:18:08,960 --> 00:18:11,840
so when you do generate all those tables

472
00:18:11,840 --> 00:18:13,360
you have to evaluate millions of

473
00:18:13,360 --> 00:18:14,799
expressions

474
00:18:14,799 --> 00:18:16,559
in order to create this mapping from

475
00:18:16,559 --> 00:18:19,520
outputs to expressions

476
00:18:19,520 --> 00:18:21,280
so what we did is

477
00:18:21,280 --> 00:18:21,470
two

478
00:18:21,470 --> 00:18:22,559
[Music]

479
00:18:22,559 --> 00:18:24,400
interesting thing is memorizations of

480
00:18:24,400 --> 00:18:26,720
the intermediate values so

481
00:18:26,720 --> 00:18:28,559
for instance a plus b will be only

482
00:18:28,559 --> 00:18:31,039
evaluated once

483
00:18:31,039 --> 00:18:32,960
and then the result will be recombined

484
00:18:32,960 --> 00:18:34,880
with all the other operators and

485
00:18:34,880 --> 00:18:36,240
expressions

486
00:18:36,240 --> 00:18:37,039
to

487
00:18:37,039 --> 00:18:39,760
to improve it but we kept keep it in

488
00:18:39,760 --> 00:18:41,120
memory

489
00:18:41,120 --> 00:18:43,520
and we're also using jiting to evaluate

490
00:18:43,520 --> 00:18:46,480
the expressions at native speed

491
00:18:46,480 --> 00:18:48,240
because our implementation is in python

492
00:18:48,240 --> 00:18:51,919
but all the evaluation is made in c

493
00:18:51,919 --> 00:18:53,600
so what we have been able to reach is

494
00:18:53,600 --> 00:18:56,799
like 25 000 expressions per seconds in

495
00:18:56,799 --> 00:18:58,960
terms of throughput

496
00:18:58,960 --> 00:19:02,559
and we now have tables of

497
00:19:02,679 --> 00:19:05,440
375 million entries which is

498
00:19:05,440 --> 00:19:08,559
kind of satisfying

499
00:19:08,840 --> 00:19:12,320
um where does we store them

500
00:19:12,320 --> 00:19:14,000
at the beginning we were using pickle

501
00:19:14,000 --> 00:19:15,440
files uh

502
00:19:15,440 --> 00:19:17,440
one year ago but

503
00:19:17,440 --> 00:19:19,280
it's only works for like one million

504
00:19:19,280 --> 00:19:20,480
entries

505
00:19:20,480 --> 00:19:21,440
um

506
00:19:21,440 --> 00:19:24,880
because it takes time to to deserialize

507
00:19:24,880 --> 00:19:26,480
a pickle object

508
00:19:26,480 --> 00:19:28,720
so it was not sufficient

509
00:19:28,720 --> 00:19:33,039
then we tried like a relational model

510
00:19:33,039 --> 00:19:35,679
of database but

511
00:19:35,679 --> 00:19:37,919
we either have the insertions or the

512
00:19:37,919 --> 00:19:40,559
lookup to be linear in the number of

513
00:19:40,559 --> 00:19:42,559
entries so when you have millions and

514
00:19:42,559 --> 00:19:45,360
millions of entries it does not work

515
00:19:45,360 --> 00:19:48,240
so we ended up using leveldb which is a

516
00:19:48,240 --> 00:19:50,960
key value database made by google and

517
00:19:50,960 --> 00:19:53,679
that's working like a charm

518
00:19:53,679 --> 00:19:55,919
and that ensures um

519
00:19:55,919 --> 00:19:58,400
logarithmic lookup and that's really

520
00:19:58,400 --> 00:20:00,240
that was a constraint that we wanted to

521
00:20:00,240 --> 00:20:01,919
make sure

522
00:20:01,919 --> 00:20:03,200
to have

523
00:20:03,200 --> 00:20:04,080
and

524
00:20:04,080 --> 00:20:08,240
we have so the lookup in db here is like

525
00:20:08,240 --> 00:20:10,520
um in average like

526
00:20:10,520 --> 00:20:13,200
122 microseconds and

527
00:20:13,200 --> 00:20:16,320
if you realize that's really the

528
00:20:16,320 --> 00:20:18,480
the synthesis time the

529
00:20:18,480 --> 00:20:20,880
the input the so you compute the output

530
00:20:20,880 --> 00:20:22,640
vector and the synthesis time is only

531
00:20:22,640 --> 00:20:26,559
like 100 microseconds

532
00:20:26,720 --> 00:20:28,880
um

533
00:20:28,880 --> 00:20:30,720
then you make we made some experiments

534
00:20:30,720 --> 00:20:32,550
to try improving the

535
00:20:32,550 --> 00:20:33,799
[Music]

536
00:20:33,799 --> 00:20:36,000
representativity of tables that we were

537
00:20:36,000 --> 00:20:38,320
generating and as

538
00:20:38,320 --> 00:20:41,280
mixing variables with operators is

539
00:20:41,280 --> 00:20:44,240
really done in a

540
00:20:44,240 --> 00:20:46,559
combinatorial way

541
00:20:46,559 --> 00:20:48,880
sometimes expressions generated and are

542
00:20:48,880 --> 00:20:52,400
not optimal and so here you can see

543
00:20:52,400 --> 00:20:53,600
the kind of

544
00:20:53,600 --> 00:20:55,679
operation expressions that we do

545
00:20:55,679 --> 00:20:57,039
generate

546
00:20:57,039 --> 00:20:59,360
and we tried using simpy to perform some

547
00:20:59,360 --> 00:21:01,200
linearizations of equation of

548
00:21:01,200 --> 00:21:03,840
expressions and what we obtain is the

549
00:21:03,840 --> 00:21:05,360
things on the right

550
00:21:05,360 --> 00:21:07,360
so that's really great to

551
00:21:07,360 --> 00:21:08,400
further

552
00:21:08,400 --> 00:21:11,600
improve the size of expressions but

553
00:21:11,600 --> 00:21:14,080
it completely kills the generation

554
00:21:14,080 --> 00:21:16,159
performances and it has some other

555
00:21:16,159 --> 00:21:18,559
issues that makes it very difficult to

556
00:21:18,559 --> 00:21:20,559
use it in practice so

557
00:21:20,559 --> 00:21:21,840
in practice we don't use it

558
00:21:21,840 --> 00:21:23,760
unfortunately

559
00:21:23,760 --> 00:21:26,799
but that was a good trial

560
00:21:26,799 --> 00:21:28,880
the second thing that we do

561
00:21:28,880 --> 00:21:31,600
is expression learning

562
00:21:31,600 --> 00:21:34,960
and that was based on some weird uh

563
00:21:34,960 --> 00:21:37,039
observations that we made during our

564
00:21:37,039 --> 00:21:38,240
experiment

565
00:21:38,240 --> 00:21:40,720
sometimes we were giving the synthesizer

566
00:21:40,720 --> 00:21:43,360
and expressions on what was coming out

567
00:21:43,360 --> 00:21:46,240
is an expressions which was bigger than

568
00:21:46,240 --> 00:21:49,280
the input one so we were like what the

569
00:21:49,280 --> 00:21:51,280
what the is going on

570
00:21:51,280 --> 00:21:52,799
so

571
00:21:52,799 --> 00:21:54,480
when we looked at uh

572
00:21:54,480 --> 00:21:56,880
at these expressions it was actually

573
00:21:56,880 --> 00:21:58,880
expressions involving

574
00:21:58,880 --> 00:22:01,840
things that were not in our tables so

575
00:22:01,840 --> 00:22:04,080
mostly constant

576
00:22:04,080 --> 00:22:04,880
so

577
00:22:04,880 --> 00:22:07,280
this was our inputs and this was our

578
00:22:07,280 --> 00:22:09,840
outputs

579
00:22:10,840 --> 00:22:13,919
so what we can do with that is basically

580
00:22:13,919 --> 00:22:15,360
we can

581
00:22:15,360 --> 00:22:17,919
update the table with the new expression

582
00:22:17,919 --> 00:22:19,760
that we have just learned

583
00:22:19,760 --> 00:22:21,280
so we have not been able to synthesize

584
00:22:21,280 --> 00:22:22,799
the expressions but at least we have

585
00:22:22,799 --> 00:22:26,000
improved our table that improve constant

586
00:22:26,000 --> 00:22:26,960
uh

587
00:22:26,960 --> 00:22:29,919
and did mean that over time tables can

588
00:22:29,919 --> 00:22:31,520
theoretically

589
00:22:31,520 --> 00:22:33,600
become better and better

590
00:22:33,600 --> 00:22:36,000
so that's great

591
00:22:36,000 --> 00:22:38,559
and by the way it's for like generic

592
00:22:38,559 --> 00:22:41,039
constant like one and so on we now

593
00:22:41,039 --> 00:22:43,280
introduce them in our table generation

594
00:22:43,280 --> 00:22:44,720
process but

595
00:22:44,720 --> 00:22:47,280
um we cannot animate all the constants

596
00:22:47,280 --> 00:22:49,280
so

597
00:22:49,280 --> 00:22:54,159
we we still can learn the new expression

598
00:22:54,159 --> 00:22:55,200
so

599
00:22:55,200 --> 00:22:57,760
let's talk about benchmarks so these

600
00:22:57,760 --> 00:23:00,320
were these were are the benchmark that

601
00:23:00,320 --> 00:23:01,840
we did

602
00:23:01,840 --> 00:23:03,039
um

603
00:23:03,039 --> 00:23:06,000
for academic publications we

604
00:23:06,000 --> 00:23:08,000
targeted the binaries sophisticated with

605
00:23:08,000 --> 00:23:11,679
tigress and we did compared against ctf

606
00:23:11,679 --> 00:23:13,600
against which we had like really good

607
00:23:13,600 --> 00:23:16,000
result

608
00:23:16,159 --> 00:23:18,000
and since then

609
00:23:18,000 --> 00:23:20,240
we kept improving our

610
00:23:20,240 --> 00:23:22,720
algorithm and implementations

611
00:23:22,720 --> 00:23:24,960
so

612
00:23:25,360 --> 00:23:27,840
we still use the four data sets which

613
00:23:27,840 --> 00:23:30,799
are available online um

614
00:23:30,799 --> 00:23:34,240
we used so ea is encode arithmetic so

615
00:23:34,240 --> 00:23:37,240
it's basically mbas we also mixed

616
00:23:37,240 --> 00:23:40,080
virtualizations and mbas

617
00:23:40,080 --> 00:23:43,440
and on mbas and encode data which are

618
00:23:43,440 --> 00:23:46,320
all uh tigress transformations

619
00:23:46,320 --> 00:23:48,720
and so we have four benchmarks

620
00:23:48,720 --> 00:23:51,600
the first line is the paper results and

621
00:23:51,600 --> 00:23:54,000
as you can see we kept improving things

622
00:23:54,000 --> 00:23:55,520
over time

623
00:23:55,520 --> 00:23:57,600
and now we really have

624
00:23:57,600 --> 00:24:01,279
good even better if you can say results

625
00:24:01,279 --> 00:24:03,600
for instance on the last data sets

626
00:24:03,600 --> 00:24:05,919
we obtained like 90 percent improvements

627
00:24:05,919 --> 00:24:07,279
in terms of

628
00:24:07,279 --> 00:24:11,440
exp synthesized expression size

629
00:24:11,760 --> 00:24:13,600
and in terms of speed

630
00:24:13,600 --> 00:24:16,559
for some of them we have like up to 67

631
00:24:16,559 --> 00:24:18,799
persons improvements i think it's the

632
00:24:18,799 --> 00:24:20,400
second one here

633
00:24:20,400 --> 00:24:24,080
we we turn to two minutes 49 seconds to

634
00:24:24,080 --> 00:24:26,240
55 seconds

635
00:24:26,240 --> 00:24:28,799
so that's great and here we are talking

636
00:24:28,799 --> 00:24:31,600
about like 500 obfuscated expressions to

637
00:24:31,600 --> 00:24:34,320
the of skate

638
00:24:35,200 --> 00:24:37,760
implementations we implemented that into

639
00:24:37,760 --> 00:24:40,320
the q synthesis utility which is our own

640
00:24:40,320 --> 00:24:42,240
implementations that we

641
00:24:42,240 --> 00:24:44,720
are releasing for

642
00:24:44,720 --> 00:24:47,840
this talk

643
00:24:48,159 --> 00:24:50,799
q synthesis is based on multiple order

644
00:24:50,799 --> 00:24:52,640
frameworks um

645
00:24:52,640 --> 00:24:54,880
the most significant one is triton which

646
00:24:54,880 --> 00:24:57,919
is doing the symbolic executions for us

647
00:24:57,919 --> 00:25:00,720
we also integrated it into trace which

648
00:25:00,720 --> 00:25:03,600
uh which is our own time travel debugger

649
00:25:03,600 --> 00:25:06,000
that we use internally at quarks lab

650
00:25:06,000 --> 00:25:08,320
um which is unfortunately not open

651
00:25:08,320 --> 00:25:10,480
source at the moment

652
00:25:10,480 --> 00:25:12,799
and as i already mentioned we use dragon

653
00:25:12,799 --> 00:25:14,559
ffe which is also developed at quartzlab

654
00:25:14,559 --> 00:25:17,039
for the editing of expressions we use

655
00:25:17,039 --> 00:25:19,840
leveldb for the storage

656
00:25:19,840 --> 00:25:23,120
we also integrated q synthesis to ida

657
00:25:23,120 --> 00:25:24,159
pro

658
00:25:24,159 --> 00:25:26,720
we use fastappy to serve the tables to

659
00:25:26,720 --> 00:25:29,360
be able to perform some lookups as

660
00:25:29,360 --> 00:25:31,440
with a rest api

661
00:25:31,440 --> 00:25:33,760
and i did not mentioned it explicitly

662
00:25:33,760 --> 00:25:36,880
but what we wanted to have is

663
00:25:36,880 --> 00:25:38,640
once you have the obfuscated expression

664
00:25:38,640 --> 00:25:40,480
you want to have like

665
00:25:40,480 --> 00:25:41,200
to

666
00:25:41,200 --> 00:25:43,120
re-obtained uh

667
00:25:43,120 --> 00:25:45,919
the final code executable code

668
00:25:45,919 --> 00:25:47,760
and for that we use arribo which is also

669
00:25:47,760 --> 00:25:49,279
developed quarks lab which is open

670
00:25:49,279 --> 00:25:50,799
source

671
00:25:50,799 --> 00:25:53,919
and that takes inputs triton expressions

672
00:25:53,919 --> 00:25:57,039
translate them to llvm and through lvm

673
00:25:57,039 --> 00:26:00,240
lite we are able to recompile the the

674
00:26:00,240 --> 00:26:03,440
obfuscated expressions

675
00:26:04,480 --> 00:26:05,440
and then

676
00:26:05,440 --> 00:26:07,600
i'm going to show you the integrations

677
00:26:07,600 --> 00:26:10,320
into ida that we've performed so it will

678
00:26:10,320 --> 00:26:12,720
give you a great overview of how all

679
00:26:12,720 --> 00:26:15,279
that works

680
00:26:15,760 --> 00:26:18,080
so here we have a small functions which

681
00:26:18,080 --> 00:26:20,000
is basically

682
00:26:20,000 --> 00:26:23,200
a mba that we want to simplify

683
00:26:23,200 --> 00:26:25,360
we are going to load launch queue

684
00:26:25,360 --> 00:26:26,720
synthesis

685
00:26:26,720 --> 00:26:28,720
and we are going to has to synthesize

686
00:26:28,720 --> 00:26:31,039
from here

687
00:26:31,039 --> 00:26:33,520
uh to the end of the basic block we ask

688
00:26:33,520 --> 00:26:39,480
here to synthesize the register array x

689
00:26:40,240 --> 00:26:42,080
we are going to load the

690
00:26:42,080 --> 00:26:45,678
tables that we want to use

691
00:26:46,080 --> 00:26:48,240
then we just run triton the symbolic

692
00:26:48,240 --> 00:26:50,159
execution to obtain the expressions so

693
00:26:50,159 --> 00:26:54,159
here the expression is 124 nodes

694
00:26:54,159 --> 00:26:56,400
big and contains three different inputs

695
00:26:56,400 --> 00:26:59,840
like rdi rcx and rdx

696
00:26:59,840 --> 00:27:02,320
we can highlight the dependencies

697
00:27:02,320 --> 00:27:04,640
to and we can see here that all the

698
00:27:04,640 --> 00:27:06,080
instructions are involved in the

699
00:27:06,080 --> 00:27:08,480
computations of the array x value at the

700
00:27:08,480 --> 00:27:09,679
end

701
00:27:09,679 --> 00:27:14,159
we can look at the ast that we obtained

702
00:27:15,440 --> 00:27:17,919
which is not that big actually

703
00:27:17,919 --> 00:27:19,760
and then we just have to run the

704
00:27:19,760 --> 00:27:22,240
synthesis and that's almost instant here

705
00:27:22,240 --> 00:27:24,320
you can see that this is the resulting

706
00:27:24,320 --> 00:27:27,440
expressions uh we reduce this size by 92

707
00:27:27,440 --> 00:27:29,600
percent

708
00:27:29,600 --> 00:27:34,199
and we can visualize the asd

709
00:27:34,880 --> 00:27:37,039
which is kind of small

710
00:27:37,039 --> 00:27:39,039
and so what we want to do here is

711
00:27:39,039 --> 00:27:40,260
basically we want to

712
00:27:40,260 --> 00:27:41,600
[Music]

713
00:27:41,600 --> 00:27:43,600
to reassemble the expericated

714
00:27:43,600 --> 00:27:46,000
expressions back to assembly

715
00:27:46,000 --> 00:27:47,679
and this is exactly what we are going to

716
00:27:47,679 --> 00:27:48,880
do here

717
00:27:48,880 --> 00:27:50,880
so we are going to call arribo which is

718
00:27:50,880 --> 00:27:53,120
going to call llvm lite which is a

719
00:27:53,120 --> 00:27:55,200
binding for llvm so we recompile the

720
00:27:55,200 --> 00:27:58,159
expressions and we obtain

721
00:27:58,159 --> 00:27:59,679
compiled code

722
00:27:59,679 --> 00:28:00,880
so here we are going to patch the

723
00:28:00,880 --> 00:28:02,880
function bytes shrink the functions

724
00:28:02,880 --> 00:28:04,640
because it's only in a single basic

725
00:28:04,640 --> 00:28:07,679
block and we can do it

726
00:28:12,000 --> 00:28:14,480
and there it is we just

727
00:28:14,480 --> 00:28:16,880
patched back the instructions only the

728
00:28:16,880 --> 00:28:19,200
instructions that are involved in the

729
00:28:19,200 --> 00:28:20,880
computation so we keep

730
00:28:20,880 --> 00:28:22,880
the

731
00:28:22,880 --> 00:28:25,440
prologue and ep log and here you can see

732
00:28:25,440 --> 00:28:29,200
the expressions with the xor add and

733
00:28:29,200 --> 00:28:33,200
we charge the difficulty the expression

734
00:28:33,200 --> 00:28:35,039
so that was for the demo

735
00:28:35,039 --> 00:28:36,640
um

736
00:28:36,640 --> 00:28:39,600
showing you how how do we do use it

737
00:28:39,600 --> 00:28:41,440
and now we are going to discuss

738
00:28:41,440 --> 00:28:44,960
the use cases on which we are we tried

739
00:28:44,960 --> 00:28:47,520
uh our implementation

740
00:28:47,520 --> 00:28:50,960
so we first tried on yanzo llvm which is

741
00:28:50,960 --> 00:28:54,080
an obfuscator llvm derivatives that was

742
00:28:54,080 --> 00:28:56,480
published last year and that is actually

743
00:28:56,480 --> 00:28:57,600
really

744
00:28:57,600 --> 00:29:00,399
a decent obfuscator the obfuscations are

745
00:29:00,399 --> 00:29:02,559
kind of great

746
00:29:02,559 --> 00:29:04,559
there's multiple of them and but we are

747
00:29:04,559 --> 00:29:06,240
going to focus on the

748
00:29:06,240 --> 00:29:10,000
vm and the obfuscate constants

749
00:29:10,000 --> 00:29:13,360
so the vm is basically going to replace

750
00:29:13,360 --> 00:29:15,679
um arithmetic operations and bitwise

751
00:29:15,679 --> 00:29:17,919
operations with calls to functions that

752
00:29:17,919 --> 00:29:20,720
are going to do them so you can see here

753
00:29:20,720 --> 00:29:21,679
the

754
00:29:21,679 --> 00:29:24,240
the handler for the ad

755
00:29:24,240 --> 00:29:26,960
and for synthesis is like almost instant

756
00:29:26,960 --> 00:29:29,120
in this case we can just synthesize it

757
00:29:29,120 --> 00:29:31,520
and what we obtained in our case is the

758
00:29:31,520 --> 00:29:33,760
functions which is basically

759
00:29:33,760 --> 00:29:34,799
uh

760
00:29:34,799 --> 00:29:38,640
le rex rci plus rdi and red

761
00:29:38,640 --> 00:29:41,440
so yeah that's pretty straightforward

762
00:29:41,440 --> 00:29:44,559
for the synthesizer

763
00:29:46,159 --> 00:29:48,720
they use multiple mbas and they also use

764
00:29:48,720 --> 00:29:51,760
mbas to obfuscate constant

765
00:29:51,760 --> 00:29:52,720
and

766
00:29:52,720 --> 00:29:55,279
so i would like to give some precisions

767
00:29:55,279 --> 00:29:56,880
on constant

768
00:29:56,880 --> 00:30:00,240
so there is two two two cases uh either

769
00:30:00,240 --> 00:30:01,760
you have expressions that are using

770
00:30:01,760 --> 00:30:04,559
constant like a and that beef

771
00:30:04,559 --> 00:30:07,600
uh we cannot synthesize such expressions

772
00:30:07,600 --> 00:30:09,039
unless you have

773
00:30:09,039 --> 00:30:11,600
this ex this constant in your in your

774
00:30:11,600 --> 00:30:13,120
tables

775
00:30:13,120 --> 00:30:14,880
but as you cannot enumerate all the

776
00:30:14,880 --> 00:30:16,960
possible constants you probably don't

777
00:30:16,960 --> 00:30:19,039
have this constant and you're not going

778
00:30:19,039 --> 00:30:21,200
to be able to synthesize

779
00:30:21,200 --> 00:30:24,640
the expressions once it's diversified

780
00:30:24,640 --> 00:30:25,520
but

781
00:30:25,520 --> 00:30:28,640
what we can do is that we can synthesize

782
00:30:28,640 --> 00:30:30,480
constants themselves

783
00:30:30,480 --> 00:30:33,360
so opaque constant is going to take a

784
00:30:33,360 --> 00:30:35,200
constant and to

785
00:30:35,200 --> 00:30:37,360
introduce some spurious variables and

786
00:30:37,360 --> 00:30:40,320
perform some mbas and to compute the the

787
00:30:40,320 --> 00:30:41,520
constant

788
00:30:41,520 --> 00:30:45,120
but that we can synthesize it

789
00:30:45,120 --> 00:30:47,760
and this is a small example that we

790
00:30:47,760 --> 00:30:48,720
have

791
00:30:48,720 --> 00:30:51,679
generated through yarns or lvm

792
00:30:51,679 --> 00:30:53,840
and the idea from a synthesis point of

793
00:30:53,840 --> 00:30:55,840
view is that

794
00:30:55,840 --> 00:30:58,399
you take the expression if you evaluate

795
00:30:58,399 --> 00:31:01,200
it on all the inputs and you always

796
00:31:01,200 --> 00:31:04,080
obtain the same output it means that the

797
00:31:04,080 --> 00:31:05,279
inputs

798
00:31:05,279 --> 00:31:06,799
does not

799
00:31:06,799 --> 00:31:08,320
performs any

800
00:31:08,320 --> 00:31:11,120
modifications on the resulting value

801
00:31:11,120 --> 00:31:13,039
and that means that

802
00:31:13,039 --> 00:31:14,720
they are not used and that you are

803
00:31:14,720 --> 00:31:18,840
basically encoding a constant

804
00:31:19,039 --> 00:31:20,240
so

805
00:31:20,240 --> 00:31:22,960
in during the synthesis process if the

806
00:31:22,960 --> 00:31:24,960
output happens to be always the same for

807
00:31:24,960 --> 00:31:27,440
all the inputs we know that we are on a

808
00:31:27,440 --> 00:31:29,760
constant and we can just evaluate it to

809
00:31:29,760 --> 00:31:33,360
obtain the associated constant

810
00:31:33,360 --> 00:31:36,559
in this case it's just zero

811
00:31:36,559 --> 00:31:37,919
and the second use case that we've

812
00:31:37,919 --> 00:31:40,080
looked at is uh

813
00:31:40,080 --> 00:31:42,320
the windows kernel

814
00:31:42,320 --> 00:31:45,120
and especially some patchwork functions

815
00:31:45,120 --> 00:31:47,279
so

816
00:31:47,279 --> 00:31:49,760
these those functions in the kernel are

817
00:31:49,760 --> 00:31:52,399
known to be obfuscated with a framework

818
00:31:52,399 --> 00:31:54,320
called warbird

819
00:31:54,320 --> 00:31:56,480
so i've not looked into details into

820
00:31:56,480 --> 00:31:58,320
into that but

821
00:31:58,320 --> 00:32:00,960
it's a colleague pinpointing me that

822
00:32:00,960 --> 00:32:02,880
does this function and i'm i've looked

823
00:32:02,880 --> 00:32:04,240
at the code on it

824
00:32:04,240 --> 00:32:06,000
it's true that it seems to contain like

825
00:32:06,000 --> 00:32:07,440
uh weird

826
00:32:07,440 --> 00:32:09,600
arithmetic operations

827
00:32:09,600 --> 00:32:10,799
that

828
00:32:10,799 --> 00:32:12,840
could probably be

829
00:32:12,840 --> 00:32:15,919
simplified i don't know whether it's mba

830
00:32:15,919 --> 00:32:18,720
or or not but

831
00:32:18,720 --> 00:32:19,600
but

832
00:32:19,600 --> 00:32:22,960
we can do a few things about this

833
00:32:22,960 --> 00:32:24,480
and here is a small example of the

834
00:32:24,480 --> 00:32:25,519
result

835
00:32:25,519 --> 00:32:27,440
in the ida

836
00:32:27,440 --> 00:32:29,279
plugin

837
00:32:29,279 --> 00:32:31,840
so we executed some this basic block for

838
00:32:31,840 --> 00:32:32,799
instance

839
00:32:32,799 --> 00:32:35,840
which was yielding this ast and we were

840
00:32:35,840 --> 00:32:38,080
able to synthesize it to something

841
00:32:38,080 --> 00:32:40,159
smaller

842
00:32:40,159 --> 00:32:42,159
which the resulting assembly is the

843
00:32:42,159 --> 00:32:43,840
following

844
00:32:43,840 --> 00:32:44,559
so

845
00:32:44,559 --> 00:32:46,640
i've not looked that much into details

846
00:32:46,640 --> 00:32:49,440
but um i recommend you to

847
00:32:49,440 --> 00:32:51,039
to look at the two links that are on the

848
00:32:51,039 --> 00:32:53,120
slide if you want to know more about

849
00:32:53,120 --> 00:32:56,678
this obfuscator

850
00:32:57,279 --> 00:32:59,440
and then the last use case that we've

851
00:32:59,440 --> 00:33:03,840
looked at is some messaging application

852
00:33:03,840 --> 00:33:06,960
that are being used by

853
00:33:06,960 --> 00:33:10,080
youngsters mostly to send ephemeral

854
00:33:10,080 --> 00:33:11,279
messages

855
00:33:11,279 --> 00:33:14,240
and it does contain the lots of mbas

856
00:33:14,240 --> 00:33:16,640
and that's good for us and we can try to

857
00:33:16,640 --> 00:33:19,279
rejuvenate them

858
00:33:19,279 --> 00:33:22,640
and actually so here is a small example

859
00:33:22,640 --> 00:33:26,240
for arm 64

860
00:33:26,240 --> 00:33:29,600
where it generates like a huge ast with

861
00:33:29,600 --> 00:33:31,440
5000 nodes

862
00:33:31,440 --> 00:33:35,039
with one inputs and it's actually

863
00:33:35,039 --> 00:33:39,679
encoding a constant like 0x 0x7 b2

864
00:33:39,679 --> 00:33:42,480
so we are kind of happy with that

865
00:33:42,480 --> 00:33:44,640
we've been able to synthesize multiple

866
00:33:44,640 --> 00:33:45,679
of them

867
00:33:45,679 --> 00:33:48,799
um but yeah once again it would require

868
00:33:48,799 --> 00:33:51,840
like a more in-depth uh research to to

869
00:33:51,840 --> 00:33:53,360
know what

870
00:33:53,360 --> 00:33:57,279
these mbas were used for

871
00:33:57,360 --> 00:34:00,399
okay uh quick conclusions so our grey

872
00:34:00,399 --> 00:34:02,799
box algorithms it's like a good balance

873
00:34:02,799 --> 00:34:04,880
between the black box and white box

874
00:34:04,880 --> 00:34:07,840
aspect because we can opportunistically

875
00:34:07,840 --> 00:34:09,918
synthesize sub-expressions while pure

876
00:34:09,918 --> 00:34:12,960
black box cannot

877
00:34:13,199 --> 00:34:15,040
we still have issues that most

878
00:34:15,040 --> 00:34:18,320
approaches have like to target the

879
00:34:18,320 --> 00:34:20,800
expressions using constant

880
00:34:20,800 --> 00:34:23,918
but we do have ideas on how to

881
00:34:23,918 --> 00:34:25,760
to address them

882
00:34:25,760 --> 00:34:27,520
um

883
00:34:27,520 --> 00:34:29,760
and as takeaways so breaking

884
00:34:29,760 --> 00:34:31,440
notification is still crucial it's still

885
00:34:31,440 --> 00:34:33,280
the first step

886
00:34:33,280 --> 00:34:35,119
that you have to do before

887
00:34:35,119 --> 00:34:38,239
doing further reversing

888
00:34:38,239 --> 00:34:41,520
um synthesis only address a certain part

889
00:34:41,520 --> 00:34:43,599
of the division process mean meaning

890
00:34:43,599 --> 00:34:44,800
that

891
00:34:44,800 --> 00:34:47,440
it's able to synthesize to simplify

892
00:34:47,440 --> 00:34:49,599
expressions once you've located them

893
00:34:49,599 --> 00:34:52,000
into the program so you first have to

894
00:34:52,000 --> 00:34:53,839
solve the first issue which is

895
00:34:53,839 --> 00:34:56,560
finding what you want to diffuse within

896
00:34:56,560 --> 00:34:58,640
the program and that's always the most

897
00:34:58,640 --> 00:35:02,000
difficult part

898
00:35:02,000 --> 00:35:03,760
we also use it to

899
00:35:03,760 --> 00:35:05,680
synthesis to assess our horn of the

900
00:35:05,680 --> 00:35:08,000
skeleton which is called quarksep shield

901
00:35:08,000 --> 00:35:10,240
and that allows us to continuously

902
00:35:10,240 --> 00:35:12,240
improve it to make sure it's the

903
00:35:12,240 --> 00:35:16,320
obfuscation we generate is resilient

904
00:35:16,320 --> 00:35:19,680
and of the like like usual uh what makes

905
00:35:19,680 --> 00:35:22,480
a notification post potent is

906
00:35:22,480 --> 00:35:24,400
carefully mixing it with

907
00:35:24,400 --> 00:35:27,040
other transformations

908
00:35:27,040 --> 00:35:31,839
an mba taken alone can usually be broken

909
00:35:31,920 --> 00:35:34,240
and last i would just want to do some

910
00:35:34,240 --> 00:35:36,320
acknowledgement to luigi coniglio

911
00:35:36,320 --> 00:35:38,400
kickstarted that approach in our dynamic

912
00:35:38,400 --> 00:35:40,160
tracing framework

913
00:35:40,160 --> 00:35:42,480
and jonathan sarwan then with whom we

914
00:35:42,480 --> 00:35:43,599
tweaked

915
00:35:43,599 --> 00:35:45,119
to to make it more efficient on this

916
00:35:45,119 --> 00:35:48,000
kind of use cases

917
00:35:48,000 --> 00:35:50,400
and that's all for me

918
00:35:50,400 --> 00:35:51,599
if you have any questions does not

919
00:35:51,599 --> 00:35:54,160
hesitate to to ask

920
00:35:54,160 --> 00:35:55,920
feel free to ping me i would be happy to

921
00:35:55,920 --> 00:35:58,480
answer any of your questions so thank

922
00:35:58,480 --> 00:36:01,880
you very much

