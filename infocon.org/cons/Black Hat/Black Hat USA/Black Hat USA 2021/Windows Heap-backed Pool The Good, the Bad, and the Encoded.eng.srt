1
00:00:01,130 --> 00:00:13,840
[Music]

2
00:00:13,840 --> 00:00:16,239
hi everyone good morning or evening

3
00:00:16,239 --> 00:00:18,000
wherever you are

4
00:00:18,000 --> 00:00:19,520
uh i'm your den

5
00:00:19,520 --> 00:00:21,840
and i'll be talking today about the

6
00:00:21,840 --> 00:00:25,519
windows pool and how it changed since

7
00:00:25,519 --> 00:00:28,640
windows 10 redstone 5 and how that

8
00:00:28,640 --> 00:00:31,840
impacts us mostly from an exploit

9
00:00:31,840 --> 00:00:33,440
development or

10
00:00:33,440 --> 00:00:36,000
exploit defense perspective

11
00:00:36,000 --> 00:00:38,320
so before i start i'll just introduce

12
00:00:38,320 --> 00:00:40,320
myself as you as usual

13
00:00:40,320 --> 00:00:43,280
i'm a software engineer at crowdstrike

14
00:00:43,280 --> 00:00:45,280
before crowdstrike i worked at central

15
00:00:45,280 --> 00:00:47,120
one i did

16
00:00:47,120 --> 00:00:50,559
security research and software testing

17
00:00:50,559 --> 00:00:53,280
i'm also a circus artist doing aerial

18
00:00:53,280 --> 00:00:54,320
arts

19
00:00:54,320 --> 00:00:56,719
and i used to be a pastry chef

20
00:00:56,719 --> 00:00:59,199
and outside of my day job i teach

21
00:00:59,199 --> 00:01:01,680
windows internals classes with alex

22
00:01:01,680 --> 00:01:03,840
nesco at insiders

23
00:01:03,840 --> 00:01:04,879
um

24
00:01:04,879 --> 00:01:05,760
i

25
00:01:05,760 --> 00:01:08,479
blog and generally rant about windows

26
00:01:08,479 --> 00:01:10,880
and security and stuff on twitter or in

27
00:01:10,880 --> 00:01:12,560
a blog that's here on the slide if

28
00:01:12,560 --> 00:01:15,920
you're interested later

29
00:01:17,119 --> 00:01:19,680
all right so your topic to anyone who

30
00:01:19,680 --> 00:01:22,400
isn't familiar the windows kernel pool

31
00:01:22,400 --> 00:01:25,280
is similar to the user mode heap

32
00:01:25,280 --> 00:01:28,000
it's used for any kind of dynamic memory

33
00:01:28,000 --> 00:01:30,400
anything that needs to be allocated or

34
00:01:30,400 --> 00:01:33,040
modified during runtime is going to go

35
00:01:33,040 --> 00:01:34,560
in the kernel pool

36
00:01:34,560 --> 00:01:37,200
now unlike user mode where every process

37
00:01:37,200 --> 00:01:38,640
has its own heap

38
00:01:38,640 --> 00:01:41,680
in the kernel all the code running in

39
00:01:41,680 --> 00:01:44,720
the kernel is going to use the same

40
00:01:44,720 --> 00:01:46,479
pools there are a few different kernel

41
00:01:46,479 --> 00:01:49,280
pools of where the biggest difference is

42
00:01:49,280 --> 00:01:50,560
some are

43
00:01:50,560 --> 00:01:52,880
paid memory and some are non-paged

44
00:01:52,880 --> 00:01:55,200
memory but there are a few other kinds

45
00:01:55,200 --> 00:01:59,119
as well such as a special pool etc

46
00:01:59,119 --> 00:02:01,600
now the pool is a pretty

47
00:02:01,600 --> 00:02:03,520
common and popular target

48
00:02:03,520 --> 00:02:05,680
for kernel exploits for example using

49
00:02:05,680 --> 00:02:09,119
buffer overflows to overwrite the next

50
00:02:09,119 --> 00:02:11,760
for a location or the one after that

51
00:02:11,760 --> 00:02:13,040
to

52
00:02:13,040 --> 00:02:16,000
gain data corruption attacks to

53
00:02:16,000 --> 00:02:18,640
use for data corruption attacks

54
00:02:18,640 --> 00:02:21,200
and hopefully ultimately getting

55
00:02:21,200 --> 00:02:24,319
ring zero code execution

56
00:02:24,319 --> 00:02:25,680
and that's been going on for a lot of

57
00:02:25,680 --> 00:02:28,640
years there have been all sorts of

58
00:02:28,640 --> 00:02:32,160
smaller mitigations around that but as a

59
00:02:32,160 --> 00:02:33,599
technique

60
00:02:33,599 --> 00:02:37,280
um techniques using um the kernel pool

61
00:02:37,280 --> 00:02:39,840
for exploitation are still

62
00:02:39,840 --> 00:02:42,080
relatively common as far as curl

63
00:02:42,080 --> 00:02:44,480
exploits go

64
00:02:44,480 --> 00:02:47,440
now the second thing for the second

65
00:02:47,440 --> 00:02:48,959
thing that current pools are used for

66
00:02:48,959 --> 00:02:50,640
for exploitation

67
00:02:50,640 --> 00:02:53,680
is information leaks so because since

68
00:02:53,680 --> 00:02:56,239
aslr the addresses of drivers the

69
00:02:56,239 --> 00:02:58,400
addresses of objects in the kernel

70
00:02:58,400 --> 00:02:59,519
are

71
00:02:59,519 --> 00:03:01,519
changing every boot you can't predict

72
00:03:01,519 --> 00:03:03,200
them so

73
00:03:03,200 --> 00:03:05,280
you can use the kernel pool for example

74
00:03:05,280 --> 00:03:07,200
if you have uninitialized memory there

75
00:03:07,200 --> 00:03:09,440
that's going to be returned to user mode

76
00:03:09,440 --> 00:03:11,440
you get all sorts of random stuff that

77
00:03:11,440 --> 00:03:13,760
were in the kernel pool random kernel

78
00:03:13,760 --> 00:03:16,879
pointers uh you can get all sorts of

79
00:03:16,879 --> 00:03:19,440
fun information leaks there

80
00:03:19,440 --> 00:03:22,400
now that has been mostly mitigated in

81
00:03:22,400 --> 00:03:24,080
windows 10

82
00:03:24,080 --> 00:03:27,840
with a new api ex allocate pool 2 that

83
00:03:27,840 --> 00:03:29,360
zeroes out

84
00:03:29,360 --> 00:03:32,159
pool locations once they're allocated

85
00:03:32,159 --> 00:03:33,840
then even if you

86
00:03:33,840 --> 00:03:35,599
have an initial uh you don't have

87
00:03:35,599 --> 00:03:37,200
uninitialized memory anymore you're not

88
00:03:37,200 --> 00:03:38,720
going to leak

89
00:03:38,720 --> 00:03:42,000
random pull data to use remote okay it's

90
00:03:42,000 --> 00:03:44,560
all going to be zeros but that allocate

91
00:03:44,560 --> 00:03:47,599
but that new allocation

92
00:03:47,599 --> 00:03:49,920
api only mitigates

93
00:03:49,920 --> 00:03:51,599
one attack vector

94
00:03:51,599 --> 00:03:54,799
and there are still many more

95
00:03:54,799 --> 00:03:56,959
um and if we look at

96
00:03:56,959 --> 00:03:59,920
the apis that are exposed to third-party

97
00:03:59,920 --> 00:04:02,239
callers in the kernel meaning kernel

98
00:04:02,239 --> 00:04:04,400
code that is not running inside the

99
00:04:04,400 --> 00:04:06,159
kernel itself

100
00:04:06,159 --> 00:04:08,400
if we're just looking at the allocation

101
00:04:08,400 --> 00:04:11,439
apis we see at least 10 here that's just

102
00:04:11,439 --> 00:04:14,319
the ones i got from ida when i open it

103
00:04:14,319 --> 00:04:15,840
up

104
00:04:15,840 --> 00:04:19,440
that doesn't include any of the other

105
00:04:19,440 --> 00:04:24,160
apis that handle pool or any of the

106
00:04:24,160 --> 00:04:26,960
apis running underneath them that aren't

107
00:04:26,960 --> 00:04:29,199
exported and there are lots and lots and

108
00:04:29,199 --> 00:04:31,199
lots and lots of functions doing super

109
00:04:31,199 --> 00:04:32,800
complicated things

110
00:04:32,800 --> 00:04:35,120
and in general handling the kernel pool

111
00:04:35,120 --> 00:04:37,199
is a really

112
00:04:37,199 --> 00:04:39,759
uh complicated thing for the system to

113
00:04:39,759 --> 00:04:41,040
do it just keeps getting more

114
00:04:41,040 --> 00:04:44,479
complicated the more memory

115
00:04:44,479 --> 00:04:47,280
the kernel uses

116
00:04:47,280 --> 00:04:51,120
but from a developer or defender or

117
00:04:51,120 --> 00:04:52,800
exploit perspective

118
00:04:52,800 --> 00:04:55,600
before rs-5 the pool was a relatively

119
00:04:55,600 --> 00:04:57,840
simple thing because it had pretty

120
00:04:57,840 --> 00:05:00,080
simple structures

121
00:05:00,080 --> 00:05:02,960
as far as the exploit was concerned we

122
00:05:02,960 --> 00:05:04,800
could look at the pool on a per page

123
00:05:04,800 --> 00:05:07,199
basis every pool page started with a

124
00:05:07,199 --> 00:05:09,199
pool header that had some information

125
00:05:09,199 --> 00:05:10,400
about the

126
00:05:10,400 --> 00:05:13,440
block size the previous block size

127
00:05:13,440 --> 00:05:16,560
uh the type of pool it's in and a pool

128
00:05:16,560 --> 00:05:19,680
tag used to identify the allocation

129
00:05:19,680 --> 00:05:22,240
after each pool header there was the

130
00:05:22,240 --> 00:05:24,800
data after that another pool header

131
00:05:24,800 --> 00:05:26,479
telling us information about the next

132
00:05:26,479 --> 00:05:28,800
block its size whether it's allocated or

133
00:05:28,800 --> 00:05:32,560
free etc etc data another pool header so

134
00:05:32,560 --> 00:05:33,840
on and so on

135
00:05:33,840 --> 00:05:36,400
if we chose a random address in the pool

136
00:05:36,400 --> 00:05:38,240
we could go to the beginning of the page

137
00:05:38,240 --> 00:05:39,919
start parsing from the beginning of the

138
00:05:39,919 --> 00:05:42,080
page and have all the information we

139
00:05:42,080 --> 00:05:43,919
needed about everything in that pool

140
00:05:43,919 --> 00:05:44,800
page

141
00:05:44,800 --> 00:05:48,960
it was easy to parse all the data was

142
00:05:48,960 --> 00:05:50,880
clear text it was

143
00:05:50,880 --> 00:05:53,520
very easy to read it was also very easy

144
00:05:53,520 --> 00:05:57,840
to fake if you use the buffer overflow

145
00:05:57,840 --> 00:06:00,080
vulnerability to override the next

146
00:06:00,080 --> 00:06:02,639
location you could just for example fake

147
00:06:02,639 --> 00:06:05,199
the next allocation

148
00:06:05,199 --> 00:06:07,360
and tell the system that it's way

149
00:06:07,360 --> 00:06:10,080
smaller or way larger it actually is and

150
00:06:10,080 --> 00:06:13,440
get all sorts of nice techniques there

151
00:06:13,440 --> 00:06:16,560
but that was before rs5

152
00:06:16,560 --> 00:06:18,639
since rs5 things look a little bit

153
00:06:18,639 --> 00:06:21,840
differently and the structures of the

154
00:06:21,840 --> 00:06:22,720
pool

155
00:06:22,720 --> 00:06:25,759
look something like this

156
00:06:25,759 --> 00:06:27,039
which is

157
00:06:27,039 --> 00:06:29,440
way way way more than just

158
00:06:29,440 --> 00:06:32,160
a single pool page this is a little bit

159
00:06:32,160 --> 00:06:35,360
overwhelming we'll go over some of it in

160
00:06:35,360 --> 00:06:36,560
this talk

161
00:06:36,560 --> 00:06:39,520
um of course not every exploit or

162
00:06:39,520 --> 00:06:41,280
defender will need to handle all these

163
00:06:41,280 --> 00:06:42,800
structures but a lot of them are

164
00:06:42,800 --> 00:06:45,840
relevant we can't just look at a single

165
00:06:45,840 --> 00:06:46,840
page

166
00:06:46,840 --> 00:06:50,000
anymore because with this new pool model

167
00:06:50,000 --> 00:06:51,759
um

168
00:06:51,759 --> 00:06:55,360
it the system switches to a completely

169
00:06:55,360 --> 00:06:57,199
new design

170
00:06:57,199 --> 00:06:58,639
which is

171
00:06:58,639 --> 00:07:01,039
the same as the design of the user mode

172
00:07:01,039 --> 00:07:05,520
heap now we're not looking at a per page

173
00:07:05,520 --> 00:07:07,840
view anymore single pages don't really

174
00:07:07,840 --> 00:07:10,960
mean that much in the modern kernel pool

175
00:07:10,960 --> 00:07:13,840
instead we're looking at a model of

176
00:07:13,840 --> 00:07:17,120
segments and sub segments

177
00:07:17,120 --> 00:07:19,440
and all sorts of different things like

178
00:07:19,440 --> 00:07:22,000
that that require knowing the system a

179
00:07:22,000 --> 00:07:24,240
lot better just to figure out what we're

180
00:07:24,240 --> 00:07:26,479
looking at but if anyone is familiar

181
00:07:26,479 --> 00:07:28,560
with the internal structures of the user

182
00:07:28,560 --> 00:07:30,639
mode heap this will be very very similar

183
00:07:30,639 --> 00:07:33,360
it now uses the same libraries with

184
00:07:33,360 --> 00:07:35,759
minor differences to

185
00:07:35,759 --> 00:07:38,160
make it work properly for the kernel

186
00:07:38,160 --> 00:07:39,520
needs

187
00:07:39,520 --> 00:07:42,080
which means you can now look at both

188
00:07:42,080 --> 00:07:44,400
user mode and kernel mode heaps in a

189
00:07:44,400 --> 00:07:46,319
very similar way

190
00:07:46,319 --> 00:07:48,160
which is both good and bad and we'll see

191
00:07:48,160 --> 00:07:50,080
later why

192
00:07:50,080 --> 00:07:52,000
the one thing that hasn't changed is

193
00:07:52,000 --> 00:07:54,879
large pool the large pool was managed by

194
00:07:54,879 --> 00:07:57,280
the va space and still is nothing

195
00:07:57,280 --> 00:07:59,120
changed there but we're not going to

196
00:07:59,120 --> 00:08:01,599
talk about the large pool today

197
00:08:01,599 --> 00:08:03,680
practically everything else

198
00:08:03,680 --> 00:08:05,759
is now different

199
00:08:05,759 --> 00:08:07,680
um

200
00:08:07,680 --> 00:08:10,080
one more thing that is different is that

201
00:08:10,080 --> 00:08:12,400
until rs5 we didn't really care all that

202
00:08:12,400 --> 00:08:14,800
much about the size of separate blocks

203
00:08:14,800 --> 00:08:16,319
the main thing that we heard that we

204
00:08:16,319 --> 00:08:18,319
cared about when choosing where to

205
00:08:18,319 --> 00:08:20,400
allocate a single block is

206
00:08:20,400 --> 00:08:22,160
whether it's large enough to go in the

207
00:08:22,160 --> 00:08:24,960
large pool or not if it's small enough

208
00:08:24,960 --> 00:08:27,039
to not go into large pool it went in the

209
00:08:27,039 --> 00:08:28,080
same

210
00:08:28,080 --> 00:08:30,160
regular pages everything else

211
00:08:30,160 --> 00:08:33,279
that's not true anymore now we do very

212
00:08:33,279 --> 00:08:35,919
much hear about specific sizes of pool

213
00:08:35,919 --> 00:08:38,479
blocks and later in this talk we'll see

214
00:08:38,479 --> 00:08:40,240
why

215
00:08:40,240 --> 00:08:42,880
now this new model every

216
00:08:42,880 --> 00:08:45,200
separate pool has

217
00:08:45,200 --> 00:08:47,440
one structure one large structure

218
00:08:47,440 --> 00:08:49,120
managing it that structure is the

219
00:08:49,120 --> 00:08:50,800
segment heap

220
00:08:50,800 --> 00:08:52,720
that's allocated in the beginning of

221
00:08:52,720 --> 00:08:54,959
every pool the first by of the first

222
00:08:54,959 --> 00:08:55,839
page

223
00:08:55,839 --> 00:08:57,600
has the segment heap and all the

224
00:08:57,600 --> 00:08:59,920
structures contained in it

225
00:08:59,920 --> 00:09:02,959
it has a lot of metadata information

226
00:09:02,959 --> 00:09:05,839
for example what address do allocations

227
00:09:05,839 --> 00:09:07,519
start in

228
00:09:07,519 --> 00:09:09,760
what pages are committed what pages are

229
00:09:09,760 --> 00:09:12,480
uncommitted

230
00:09:12,720 --> 00:09:16,720
amounts of allocated and free pages all

231
00:09:16,720 --> 00:09:18,640
sorts of pointers to

232
00:09:18,640 --> 00:09:21,040
different structures that are needed to

233
00:09:21,040 --> 00:09:23,120
manage separate parts of the pool and

234
00:09:23,120 --> 00:09:25,040
that's a start that's a structure that's

235
00:09:25,040 --> 00:09:26,560
good to know and it has all sorts of

236
00:09:26,560 --> 00:09:27,920
interesting information when you're

237
00:09:27,920 --> 00:09:31,600
looking at an individual pool

238
00:09:31,600 --> 00:09:33,600
now i mentioned that

239
00:09:33,600 --> 00:09:34,959
sizes do

240
00:09:34,959 --> 00:09:37,120
matter now more than they used to and

241
00:09:37,120 --> 00:09:39,200
they matter in two different ways the

242
00:09:39,200 --> 00:09:41,120
first one is

243
00:09:41,120 --> 00:09:43,040
do they belong in

244
00:09:43,040 --> 00:09:44,720
the large pool

245
00:09:44,720 --> 00:09:46,959
if they do they go into large pool as

246
00:09:46,959 --> 00:09:48,000
always

247
00:09:48,000 --> 00:09:50,399
and if they don't belong in a large pool

248
00:09:50,399 --> 00:09:52,720
we have a second split

249
00:09:52,720 --> 00:09:54,160
is the address

250
00:09:54,160 --> 00:09:55,880
over or under

251
00:09:55,880 --> 00:09:58,640
508 kilobytes

252
00:09:58,640 --> 00:10:01,519
because if the address is over 508

253
00:10:01,519 --> 00:10:04,480
kilobytes it's a pretty um not the

254
00:10:04,480 --> 00:10:07,519
address the size is over 508 kilobytes

255
00:10:07,519 --> 00:10:10,320
it's a pretty large allocation and we

256
00:10:10,320 --> 00:10:12,079
don't really need to look at small

257
00:10:12,079 --> 00:10:15,120
resolutions such as a single page uh you

258
00:10:15,120 --> 00:10:17,760
can fit a whole lot of pages in 508

259
00:10:17,760 --> 00:10:20,240
kilobytes and there's no need to

260
00:10:20,240 --> 00:10:23,360
handle them on a per page basis because

261
00:10:23,360 --> 00:10:24,800
the system doesn't really care about the

262
00:10:24,800 --> 00:10:26,720
data inside the application

263
00:10:26,720 --> 00:10:29,120
instead it can handle

264
00:10:29,120 --> 00:10:31,120
those we won't call them large

265
00:10:31,120 --> 00:10:32,560
allocations because they're not in a

266
00:10:32,560 --> 00:10:36,240
large pool but let's call them um big

267
00:10:36,240 --> 00:10:39,040
allocations it can handle them with a

268
00:10:39,040 --> 00:10:40,640
larger resolution in a way that's more

269
00:10:40,640 --> 00:10:42,000
efficient

270
00:10:42,000 --> 00:10:44,160
now if the pool block is a small one

271
00:10:44,160 --> 00:10:48,000
which is under 508 kilobytes

272
00:10:48,000 --> 00:10:49,839
it can still be pretty small it can be

273
00:10:49,839 --> 00:10:52,480
20 30 40 bytes

274
00:10:52,480 --> 00:10:54,480
then we still need to handle it in

275
00:10:54,480 --> 00:10:57,680
smaller units of one page or less than a

276
00:10:57,680 --> 00:11:00,800
page and handle them sort of the same

277
00:11:00,800 --> 00:11:03,519
way we used to but we'll see how that's

278
00:11:03,519 --> 00:11:06,000
still not exactly true

279
00:11:06,000 --> 00:11:09,760
and now in the segment heap we have

280
00:11:09,760 --> 00:11:11,200
two segments

281
00:11:11,200 --> 00:11:13,839
the first segments in the first segment

282
00:11:13,839 --> 00:11:16,240
represented both by a heapsed context

283
00:11:16,240 --> 00:11:17,440
structure

284
00:11:17,440 --> 00:11:20,959
um is used for small allocations up to

285
00:11:20,959 --> 00:11:24,880
508 kilobytes and the second segment or

286
00:11:24,880 --> 00:11:27,760
seg context is used for

287
00:11:27,760 --> 00:11:30,240
allocations that are medium-sized

288
00:11:30,240 --> 00:11:35,760
meaning 508 kilobytes up to 8128

289
00:11:35,760 --> 00:11:38,160
which is the limit uh over it everything

290
00:11:38,160 --> 00:11:40,320
is large

291
00:11:40,320 --> 00:11:42,079
and each one of these set contacts

292
00:11:42,079 --> 00:11:44,160
handles a different

293
00:11:44,160 --> 00:11:46,399
um base unit

294
00:11:46,399 --> 00:11:48,800
for small blocks the

295
00:11:48,800 --> 00:11:51,040
base unit we're talking about is one

296
00:11:51,040 --> 00:11:53,600
page for medium blocks in the second

297
00:11:53,600 --> 00:11:56,160
heapset context the base unit we'll talk

298
00:11:56,160 --> 00:11:59,279
about is 16 pages so now instead of

299
00:11:59,279 --> 00:12:01,920
talking about pages we're talking about

300
00:12:01,920 --> 00:12:04,880
basic units

301
00:12:07,440 --> 00:12:09,360
but if we're looking at a single

302
00:12:09,360 --> 00:12:10,560
allocation

303
00:12:10,560 --> 00:12:12,320
we do want to know

304
00:12:12,320 --> 00:12:13,600
what

305
00:12:13,600 --> 00:12:16,079
seg context it uses to know which

306
00:12:16,079 --> 00:12:17,760
structure you want to look at

307
00:12:17,760 --> 00:12:20,480
so to know that we have a new bitmap but

308
00:12:20,480 --> 00:12:23,440
it has three layers like a lot of kernel

309
00:12:23,440 --> 00:12:28,399
bitmaps do and for this bitmap every

310
00:12:28,399 --> 00:12:31,440
um every allocation every

311
00:12:31,440 --> 00:12:34,560
every byte is represented by two bits

312
00:12:34,560 --> 00:12:36,639
and if those two bits have a value of

313
00:12:36,639 --> 00:12:40,240
zero this is a large pool

314
00:12:40,240 --> 00:12:43,519
if the value is one it's a small pool

315
00:12:43,519 --> 00:12:46,000
block meaning it's represent it's used

316
00:12:46,000 --> 00:12:48,480
in the first set context for small

317
00:12:48,480 --> 00:12:52,160
blocks and if the bitmap value is two

318
00:12:52,160 --> 00:12:54,720
it's a medium block and we need to

319
00:12:54,720 --> 00:12:56,480
go to the second

320
00:12:56,480 --> 00:12:59,120
set context to look at it three is not

321
00:12:59,120 --> 00:13:01,279
really used it has sort of inconsistent

322
00:13:01,279 --> 00:13:04,079
interpretation but

323
00:13:04,079 --> 00:13:07,839
it's best to to ignore it

324
00:13:08,959 --> 00:13:11,839
now inside that heapset context again

325
00:13:11,839 --> 00:13:15,600
we're talking about um basic basic units

326
00:13:15,600 --> 00:13:18,880
of either one or 16 pages

327
00:13:18,880 --> 00:13:20,880
of basic information

328
00:13:20,880 --> 00:13:21,920
and

329
00:13:21,920 --> 00:13:24,480
inside of that inside of each of them we

330
00:13:24,480 --> 00:13:27,120
have a split into segments where each

331
00:13:27,120 --> 00:13:29,680
segment handles a certain amount of

332
00:13:29,680 --> 00:13:32,000
memory

333
00:13:32,000 --> 00:13:34,480
so in the first seg context for small

334
00:13:34,480 --> 00:13:37,200
blocks each segment handles one megabyte

335
00:13:37,200 --> 00:13:38,399
of memory

336
00:13:38,399 --> 00:13:41,279
in the second it handles 16 megabytes of

337
00:13:41,279 --> 00:13:43,519
memory so they handle the same amount of

338
00:13:43,519 --> 00:13:46,720
units but the unit size is different and

339
00:13:46,720 --> 00:13:48,800
we can go to set context to iterate the

340
00:13:48,800 --> 00:13:51,519
list of segments and find each and every

341
00:13:51,519 --> 00:13:54,399
segment managed by the set context

342
00:13:54,399 --> 00:13:57,600
and if we want to parse them handle them

343
00:13:57,600 --> 00:14:00,959
in whatever way we want

344
00:14:00,959 --> 00:14:02,800
so this is just to reiterate because

345
00:14:02,800 --> 00:14:04,560
there are a lot of new structures here

346
00:14:04,560 --> 00:14:07,839
there's a lot of new data going on uh so

347
00:14:07,839 --> 00:14:09,920
we have a segment heap in the beginning

348
00:14:09,920 --> 00:14:12,560
of the pool that segment heap has two

349
00:14:12,560 --> 00:14:15,360
set contexts for different size

350
00:14:15,360 --> 00:14:16,720
allocations

351
00:14:16,720 --> 00:14:19,920
and in each one of these same contexts

352
00:14:19,920 --> 00:14:23,040
we have a list of segments and from

353
00:14:23,040 --> 00:14:24,560
those segments

354
00:14:24,560 --> 00:14:27,839
we can get to the actual allocations

355
00:14:27,839 --> 00:14:29,760
now how do we do that

356
00:14:29,760 --> 00:14:32,720
the heat page segment structure is in

357
00:14:32,720 --> 00:14:34,240
is in the beginning

358
00:14:34,240 --> 00:14:36,160
of the

359
00:14:36,160 --> 00:14:38,560
segment meaning for every pull block if

360
00:14:38,560 --> 00:14:40,720
we go to the beginning of its segment

361
00:14:40,720 --> 00:14:42,240
meaning either the beginning of the

362
00:14:42,240 --> 00:14:45,199
megabyte or the beginning of its 16

363
00:14:45,199 --> 00:14:47,360
megabytes we'll find the heap page

364
00:14:47,360 --> 00:14:48,880
segment structure

365
00:14:48,880 --> 00:14:52,000
now that structure has an array of 256

366
00:14:52,000 --> 00:14:54,079
descriptors

367
00:14:54,079 --> 00:14:56,480
and each descriptor represents a basic

368
00:14:56,480 --> 00:14:58,240
unit

369
00:14:58,240 --> 00:14:59,440
and

370
00:14:59,440 --> 00:15:02,240
the descriptor in the descriptor array

371
00:15:02,240 --> 00:15:05,519
gives us information about the basic

372
00:15:05,519 --> 00:15:08,079
unit um

373
00:15:08,079 --> 00:15:10,639
what type of unit it is and we'll talk

374
00:15:10,639 --> 00:15:13,440
about the different types of units later

375
00:15:13,440 --> 00:15:15,600
is it the beginning of a range the

376
00:15:15,600 --> 00:15:18,800
middle of a range is it used not used

377
00:15:18,800 --> 00:15:19,920
etc

378
00:15:19,920 --> 00:15:23,519
and using the index of the descriptor we

379
00:15:23,519 --> 00:15:24,880
can just

380
00:15:24,880 --> 00:15:28,320
multiply that by the size of a base unit

381
00:15:28,320 --> 00:15:31,199
jump there and get to the actual address

382
00:15:31,199 --> 00:15:33,680
in that range and we'll see how we do

383
00:15:33,680 --> 00:15:34,560
that

384
00:15:34,560 --> 00:15:36,320
another thing that we have in the page

385
00:15:36,320 --> 00:15:38,959
segment and we have that in this diagram

386
00:15:38,959 --> 00:15:41,360
is we have a signature and that

387
00:15:41,360 --> 00:15:43,199
signature can lead us back to the heaps

388
00:15:43,199 --> 00:15:44,720
and context

389
00:15:44,720 --> 00:15:47,519
but go on to signature

390
00:15:47,519 --> 00:15:50,079
because it's not a pointer you if you

391
00:15:50,079 --> 00:15:52,480
look at it you'll see a value like the

392
00:15:52,480 --> 00:15:54,399
one on the slide that looks like

393
00:15:54,399 --> 00:15:56,079
complete garbage

394
00:15:56,079 --> 00:15:58,240
because that's not a direct pointer to

395
00:15:58,240 --> 00:16:01,120
this say context it's an encode it's an

396
00:16:01,120 --> 00:16:04,079
encoded pointer that's encoded with the

397
00:16:04,079 --> 00:16:06,480
segment address and

398
00:16:06,480 --> 00:16:07,600
um

399
00:16:07,600 --> 00:16:09,759
a magic value that's hardcore in the

400
00:16:09,759 --> 00:16:12,480
kernel and a heap key

401
00:16:12,480 --> 00:16:14,880
there are new keys now in the kernel

402
00:16:14,880 --> 00:16:17,120
that are of course non-exported and

403
00:16:17,120 --> 00:16:19,040
generated on boot that are used to

404
00:16:19,040 --> 00:16:22,320
encode all sorts of things because this

405
00:16:22,320 --> 00:16:24,160
design change in the pool it was done

406
00:16:24,160 --> 00:16:26,720
mostly for performance reasons

407
00:16:26,720 --> 00:16:29,839
but they also added some security

408
00:16:29,839 --> 00:16:32,959
improvements such as encoding all sorts

409
00:16:32,959 --> 00:16:35,839
of interesting values to avoid inflicts

410
00:16:35,839 --> 00:16:37,920
to make exploitation harder to make it

411
00:16:37,920 --> 00:16:41,120
so that if you want to exploit the pool

412
00:16:41,120 --> 00:16:43,680
you won't just need your initial

413
00:16:43,680 --> 00:16:46,000
vulnerability in your first primitive

414
00:16:46,000 --> 00:16:49,199
you will also need a whole lot of

415
00:16:49,199 --> 00:16:51,680
information disclosures just to get the

416
00:16:51,680 --> 00:16:54,000
pointers you need and this is one of

417
00:16:54,000 --> 00:16:56,720
them so you don't have a direct pointer

418
00:16:56,720 --> 00:16:59,120
back to a heapside context you have an

419
00:16:59,120 --> 00:17:01,680
encoded one that you need to have all

420
00:17:01,680 --> 00:17:04,400
sorts of

421
00:17:04,400 --> 00:17:06,640
very specific information that's not

422
00:17:06,640 --> 00:17:09,599
even all that easy to get in the kernel

423
00:17:09,599 --> 00:17:12,480
to decode it and we'll see that heap key

424
00:17:12,480 --> 00:17:13,919
being used in all sorts of other

425
00:17:13,919 --> 00:17:16,079
contexts later

426
00:17:16,079 --> 00:17:17,919
and we talked about the descriptors and

427
00:17:17,919 --> 00:17:21,760
how the descriptors describe what type

428
00:17:21,760 --> 00:17:22,799
of

429
00:17:22,799 --> 00:17:25,839
um unit this is what kind of

430
00:17:25,839 --> 00:17:27,439
range this is

431
00:17:27,439 --> 00:17:29,039
and now i need to talk about the second

432
00:17:29,039 --> 00:17:30,000
case

433
00:17:30,000 --> 00:17:33,360
uh the second place where the pull block

434
00:17:33,360 --> 00:17:35,120
size matters

435
00:17:35,120 --> 00:17:38,160
because now we don't just care if the

436
00:17:38,160 --> 00:17:41,039
pull block is smaller or larger than 508

437
00:17:41,039 --> 00:17:43,919
kilobytes we also care if it's a common

438
00:17:43,919 --> 00:17:45,440
size or not

439
00:17:45,440 --> 00:17:47,840
when they say common size i mean

440
00:17:47,840 --> 00:17:48,919
one of

441
00:17:48,919 --> 00:17:52,480
129 common sizes that were hardcoded in

442
00:17:52,480 --> 00:17:55,520
the kernel things like 10 bytes 20 bytes

443
00:17:55,520 --> 00:17:56,960
30 bytes

444
00:17:56,960 --> 00:17:59,520
100 bytes 200 bytes

445
00:17:59,520 --> 00:18:01,919
sizes that we expect to see very often

446
00:18:01,919 --> 00:18:03,679
in the kernel

447
00:18:03,679 --> 00:18:06,480
and for those sizes we have

448
00:18:06,480 --> 00:18:09,520
one type of sub segment called lfh or

449
00:18:09,520 --> 00:18:11,520
low fragmentation heap

450
00:18:11,520 --> 00:18:14,160
because if we have a lot of pull block

451
00:18:14,160 --> 00:18:17,039
size let's say 20 bytes

452
00:18:17,039 --> 00:18:18,559
then

453
00:18:18,559 --> 00:18:20,720
we don't necessarily need to have a

454
00:18:20,720 --> 00:18:22,480
header like a pool header for each of

455
00:18:22,480 --> 00:18:25,760
them we can just have a sub segment of

456
00:18:25,760 --> 00:18:27,200
only

457
00:18:27,200 --> 00:18:31,120
block size 20 20 hex bytes right one

458
00:18:31,120 --> 00:18:32,640
after the other

459
00:18:32,640 --> 00:18:34,240
and then we don't really need a header

460
00:18:34,240 --> 00:18:35,840
for each we just know that all the

461
00:18:35,840 --> 00:18:37,520
blocks here

462
00:18:37,520 --> 00:18:39,520
have the same size

463
00:18:39,520 --> 00:18:40,559
and

464
00:18:40,559 --> 00:18:43,280
it's very easy to find them with simple

465
00:18:43,280 --> 00:18:45,520
arithmetic um and we can save a whole

466
00:18:45,520 --> 00:18:47,840
lot of space on headers that aren't

467
00:18:47,840 --> 00:18:49,280
really necessary

468
00:18:49,280 --> 00:18:53,280
so for 129 common sizes

469
00:18:53,280 --> 00:18:54,400
up to

470
00:18:54,400 --> 00:18:58,000
uh 4 000 hex bytes

471
00:18:58,000 --> 00:18:58,880
we

472
00:18:58,880 --> 00:18:59,760
have

473
00:18:59,760 --> 00:19:00,799
um

474
00:19:00,799 --> 00:19:03,280
we have lfh sub segments now each type

475
00:19:03,280 --> 00:19:06,000
of lfa sub segment each

476
00:19:06,000 --> 00:19:09,679
uh each each range of lfh

477
00:19:09,679 --> 00:19:11,120
sub segment

478
00:19:11,120 --> 00:19:15,840
will only have blocks of one of the 129

479
00:19:15,840 --> 00:19:17,760
common sizes

480
00:19:17,760 --> 00:19:20,559
so we could have one range that handles

481
00:19:20,559 --> 00:19:23,919
block size 20 bytes one range that

482
00:19:23,919 --> 00:19:27,360
handles block size 40 bytes another one

483
00:19:27,360 --> 00:19:32,160
candles block size 100 bytes etc etc

484
00:19:32,160 --> 00:19:34,160
and then we have the second type of

485
00:19:34,160 --> 00:19:35,200
segment

486
00:19:35,200 --> 00:19:38,640
vs or variable size and that handles

487
00:19:38,640 --> 00:19:40,400
everything else anything that doesn't

488
00:19:40,400 --> 00:19:41,280
fit

489
00:19:41,280 --> 00:19:45,280
in one of the lfh buckets goes in a vs

490
00:19:45,280 --> 00:19:47,840
sub segment now with via subsegment we

491
00:19:47,840 --> 00:19:50,480
can't know in advance the size of all

492
00:19:50,480 --> 00:19:52,960
the sub segments because each one can

493
00:19:52,960 --> 00:19:55,919
have a different block size so for those

494
00:19:55,919 --> 00:19:59,120
we will have a header for every block

495
00:19:59,120 --> 00:20:00,720
but in cases

496
00:20:00,720 --> 00:20:02,320
where we can

497
00:20:02,320 --> 00:20:06,159
save some space we will use lfh and just

498
00:20:06,159 --> 00:20:08,400
know that all the blocks in this range

499
00:20:08,400 --> 00:20:11,919
have the same size

500
00:20:16,960 --> 00:20:18,640
and here we can see what the ranges look

501
00:20:18,640 --> 00:20:21,919
like now in this slide i made it so

502
00:20:21,919 --> 00:20:24,320
both ranges have the same

503
00:20:24,320 --> 00:20:25,919
size

504
00:20:25,919 --> 00:20:28,400
and notes this is not always the case we

505
00:20:28,400 --> 00:20:29,440
can have

506
00:20:29,440 --> 00:20:33,039
an lfh range that is four pages

507
00:20:33,039 --> 00:20:35,520
and immediately after it a vs range of

508
00:20:35,520 --> 00:20:38,480
is 11 pages we can't know in advance

509
00:20:38,480 --> 00:20:40,480
the size of the different ranges how

510
00:20:40,480 --> 00:20:42,400
many pages there will be

511
00:20:42,400 --> 00:20:43,440
we'll have

512
00:20:43,440 --> 00:20:46,480
ranges that cross page boundaries the

513
00:20:46,480 --> 00:20:48,480
only way to know the size of a range is

514
00:20:48,480 --> 00:20:49,440
to go

515
00:20:49,440 --> 00:20:52,080
to the beginning of a segment and look

516
00:20:52,080 --> 00:20:53,440
at the

517
00:20:53,440 --> 00:20:56,559
descriptors the range descriptors

518
00:20:56,559 --> 00:20:59,039
which will have information such as what

519
00:20:59,039 --> 00:21:03,039
type of range is this is it lfa is it vs

520
00:21:03,039 --> 00:21:06,000
uh is this unit in the beginning of a

521
00:21:06,000 --> 00:21:07,679
sub-segment is it in the middle of a

522
00:21:07,679 --> 00:21:09,120
sub-segment

523
00:21:09,120 --> 00:21:12,960
uh what is the offset of this descriptor

524
00:21:12,960 --> 00:21:15,039
from the beginning of the sub-segment

525
00:21:15,039 --> 00:21:17,039
etc you will really just need to go to a

526
00:21:17,039 --> 00:21:19,600
segment if you pick a random page

527
00:21:19,600 --> 00:21:22,000
you don't have a good way to know

528
00:21:22,000 --> 00:21:24,000
what type of sub segment it is or where

529
00:21:24,000 --> 00:21:26,159
it begins so you just need to use the

530
00:21:26,159 --> 00:21:28,240
segment for that

531
00:21:28,240 --> 00:21:31,120
now like i mentioned uh elephant sub

532
00:21:31,120 --> 00:21:33,120
segments just have a header in the

533
00:21:33,120 --> 00:21:35,360
beginning of the sub segment which is a

534
00:21:35,360 --> 00:21:38,720
heap lfh subsegment

535
00:21:38,720 --> 00:21:39,760
structure

536
00:21:39,760 --> 00:21:42,559
and that has information about most

537
00:21:42,559 --> 00:21:45,600
importantly what block sizes are handled

538
00:21:45,600 --> 00:21:48,000
in the sub segment

539
00:21:48,000 --> 00:21:50,240
what blocks are allocated which ones are

540
00:21:50,240 --> 00:21:51,200
free

541
00:21:51,200 --> 00:21:53,840
and all sorts of other metadata

542
00:21:53,840 --> 00:21:56,320
for vs sub segments

543
00:21:56,320 --> 00:21:58,240
we have a different structure that is

544
00:21:58,240 --> 00:22:00,320
again in the beginning of the subsegment

545
00:22:00,320 --> 00:22:03,120
it's called the heap vs subsegment and

546
00:22:03,120 --> 00:22:05,440
that gives us some metadata about the

547
00:22:05,440 --> 00:22:06,720
segment

548
00:22:06,720 --> 00:22:09,760
but here we do need a header for every

549
00:22:09,760 --> 00:22:12,159
separate pro block because each one has

550
00:22:12,159 --> 00:22:13,760
a different size

551
00:22:13,760 --> 00:22:16,400
so we have a heap beast chunk header for

552
00:22:16,400 --> 00:22:18,720
every pull block that has

553
00:22:18,720 --> 00:22:20,799
information about the block and most

554
00:22:20,799 --> 00:22:22,880
importantly its size

555
00:22:22,880 --> 00:22:24,960
now anything that has

556
00:22:24,960 --> 00:22:27,280
explicit sizes is now going to be

557
00:22:27,280 --> 00:22:28,559
encoded

558
00:22:28,559 --> 00:22:30,960
so this will be the lfh sub segment

559
00:22:30,960 --> 00:22:34,159
header and the heap vs chunk header both

560
00:22:34,159 --> 00:22:35,919
have size information so both will be

561
00:22:35,919 --> 00:22:37,039
encoded

562
00:22:37,039 --> 00:22:39,600
the vs headers will be encoded with the

563
00:22:39,600 --> 00:22:42,480
heap key and the lfh sub segment will be

564
00:22:42,480 --> 00:22:45,679
encoded with the lfh key which is

565
00:22:45,679 --> 00:22:49,360
another key also determined at boot also

566
00:22:49,360 --> 00:22:52,720
saved in the kernel and not exported

567
00:22:52,720 --> 00:22:56,400
now for every data block it will start

568
00:22:56,400 --> 00:22:58,080
with a pool header just for

569
00:22:58,080 --> 00:23:00,880
compatibility reasons and as a place to

570
00:23:00,880 --> 00:23:03,039
store the uh

571
00:23:03,039 --> 00:23:04,960
the pool tag

572
00:23:04,960 --> 00:23:07,440
but you can't use them to iterate the

573
00:23:07,440 --> 00:23:08,480
pool anymore

574
00:23:08,480 --> 00:23:11,200
or to parse it because only allocated

575
00:23:11,200 --> 00:23:13,360
blocks will have pull headers for free

576
00:23:13,360 --> 00:23:14,320
blocks

577
00:23:14,320 --> 00:23:16,080
you can't count on them having pull

578
00:23:16,080 --> 00:23:18,880
headers it might be there because no one

579
00:23:18,880 --> 00:23:21,120
overwrote it might be there's just junk

580
00:23:21,120 --> 00:23:22,480
information

581
00:23:22,480 --> 00:23:24,960
but to iterate free blocks you really

582
00:23:24,960 --> 00:23:26,640
need the actual

583
00:23:26,640 --> 00:23:29,760
structures used by the kernel to manage

584
00:23:29,760 --> 00:23:32,320
the pool pool header is just

585
00:23:32,320 --> 00:23:34,000
a nice thing to have there for

586
00:23:34,000 --> 00:23:35,919
compatibility for allocated blocks it's

587
00:23:35,919 --> 00:23:37,760
a good place to find the pool tag but

588
00:23:37,760 --> 00:23:40,559
not much else

589
00:23:45,600 --> 00:23:47,279
now one way to

590
00:23:47,279 --> 00:23:50,400
find lfh and via sub segments is to go

591
00:23:50,400 --> 00:23:53,520
to the beginning of the segment and walk

592
00:23:53,520 --> 00:23:54,640
the

593
00:23:54,640 --> 00:23:57,039
range descriptors one by one and figure

594
00:23:57,039 --> 00:24:00,159
out for every unit is this an lfh or a

595
00:24:00,159 --> 00:24:02,000
vs subsequent

596
00:24:02,000 --> 00:24:04,799
another way is

597
00:24:04,799 --> 00:24:06,880
going to the heap

598
00:24:06,880 --> 00:24:11,360
to the segment heap structure and

599
00:24:11,360 --> 00:24:12,720
looking

600
00:24:12,720 --> 00:24:14,320
looking there for

601
00:24:14,320 --> 00:24:17,200
vs and lfh contexts

602
00:24:17,200 --> 00:24:20,159
these manage lfh and

603
00:24:20,159 --> 00:24:24,080
vs subsegments in the pool they have a

604
00:24:24,080 --> 00:24:25,279
linked list

605
00:24:25,279 --> 00:24:28,080
of all the sub-segments of that type and

606
00:24:28,080 --> 00:24:31,360
they also have callbacks that

607
00:24:31,360 --> 00:24:34,320
point to management functions functions

608
00:24:34,320 --> 00:24:37,120
used for allocating uh freeing

609
00:24:37,120 --> 00:24:40,240
committing etc memory because we treat

610
00:24:40,240 --> 00:24:42,720
the kernel treats lfh and vs memory

611
00:24:42,720 --> 00:24:44,240
differently

612
00:24:44,240 --> 00:24:45,440
it's all just

613
00:24:45,440 --> 00:24:47,679
reiterates uh and gives a little bit

614
00:24:47,679 --> 00:24:50,480
more details about the specific encoding

615
00:24:50,480 --> 00:24:51,679
usually

616
00:24:51,679 --> 00:24:54,080
things are encoded with either the lfh

617
00:24:54,080 --> 00:24:55,520
or the hip key

618
00:24:55,520 --> 00:24:58,640
and the address of the header or the sub

619
00:24:58,640 --> 00:25:00,880
segment or where the wherever the

620
00:25:00,880 --> 00:25:03,600
structure is

621
00:25:04,640 --> 00:25:07,200
this is just about the vs and lfh

622
00:25:07,200 --> 00:25:09,360
contexts in the

623
00:25:09,360 --> 00:25:12,320
segment heap each of them has callbacks

624
00:25:12,320 --> 00:25:13,039
to

625
00:25:13,039 --> 00:25:15,440
kernel functions that are used to

626
00:25:15,440 --> 00:25:18,880
manage this type of memory

627
00:25:19,120 --> 00:25:22,320
now here we can see the lfh buckets

628
00:25:22,320 --> 00:25:24,799
they are hard coded in the kernel in an

629
00:25:24,799 --> 00:25:26,400
array

630
00:25:26,400 --> 00:25:30,080
first we have a hops of 10 hex bytes

631
00:25:30,080 --> 00:25:31,919
from zero

632
00:25:31,919 --> 00:25:34,480
to um

633
00:25:34,480 --> 00:25:39,039
to uh 200 or actually 400 then

634
00:25:39,039 --> 00:25:42,720
um hops with larger

635
00:25:42,720 --> 00:25:44,000
resolution

636
00:25:44,000 --> 00:25:46,960
and in total we have 129

637
00:25:46,960 --> 00:25:48,480
sizes

638
00:25:48,480 --> 00:25:51,840
up until 4 000 hex files meaning only

639
00:25:51,840 --> 00:25:54,240
said context zero the one that handles

640
00:25:54,240 --> 00:25:58,720
small allocations has lh sub sub

641
00:25:58,720 --> 00:26:02,000
segments anything larger than 4 000 x

642
00:26:02,000 --> 00:26:04,640
bytes will

643
00:26:04,640 --> 00:26:07,919
always be vs subsegment because these

644
00:26:07,919 --> 00:26:10,559
are these sizes are too large that we

645
00:26:10,559 --> 00:26:12,400
don't expect to have all that many of

646
00:26:12,400 --> 00:26:13,679
them

647
00:26:13,679 --> 00:26:15,919
another thing is once in a while you

648
00:26:15,919 --> 00:26:18,559
might also see

649
00:26:18,559 --> 00:26:20,960
one of these common sizes in a vs

650
00:26:20,960 --> 00:26:23,600
subsequent that's because

651
00:26:23,600 --> 00:26:24,720
we don't

652
00:26:24,720 --> 00:26:27,440
um the car won't activate lfh buckets

653
00:26:27,440 --> 00:26:30,880
until there are at least 16 allocations

654
00:26:30,880 --> 00:26:33,200
of that size so

655
00:26:33,200 --> 00:26:36,320
the first 16 allocations of pool of

656
00:26:36,320 --> 00:26:38,559
block size uh 20

657
00:26:38,559 --> 00:26:40,640
20 hex bytes

658
00:26:40,640 --> 00:26:43,520
will go in vs sub segments only after 16

659
00:26:43,520 --> 00:26:46,080
locations the girl will say oh okay

660
00:26:46,080 --> 00:26:48,080
there are enough pull blocks of that

661
00:26:48,080 --> 00:26:49,039
size

662
00:26:49,039 --> 00:26:51,600
will activate this lfh bucket will

663
00:26:51,600 --> 00:26:52,480
create

664
00:26:52,480 --> 00:26:56,240
an lfh sub segment for block sized 20

665
00:26:56,240 --> 00:26:59,039
bytes but you will still see a few

666
00:26:59,039 --> 00:27:00,799
blocks that were allocated before the

667
00:27:00,799 --> 00:27:03,039
bucket was activated so you can still

668
00:27:03,039 --> 00:27:04,320
see them in

669
00:27:04,320 --> 00:27:06,880
vs blocks

670
00:27:06,880 --> 00:27:09,360
and this just shows how these structures

671
00:27:09,360 --> 00:27:11,600
are connected just zooming in on

672
00:27:11,600 --> 00:27:13,679
different parts of that huge scary

673
00:27:13,679 --> 00:27:17,960
diagram from the beginning of the talk

674
00:27:22,000 --> 00:27:23,360
now we've talked about the internal

675
00:27:23,360 --> 00:27:25,039
structures or at least the part of them

676
00:27:25,039 --> 00:27:28,240
that is relevant uh for us in this case

677
00:27:28,240 --> 00:27:31,200
now how does this affect exploitation

678
00:27:31,200 --> 00:27:35,039
mostly this very much limits

679
00:27:35,039 --> 00:27:38,159
modern pool exploitation because

680
00:27:38,159 --> 00:27:39,840
with this new

681
00:27:39,840 --> 00:27:41,120
design

682
00:27:41,120 --> 00:27:43,520
spraying the pool is way way way harder

683
00:27:43,520 --> 00:27:45,039
because

684
00:27:45,039 --> 00:27:48,159
we need to account for what type of

685
00:27:48,159 --> 00:27:49,600
sub-segment

686
00:27:49,600 --> 00:27:51,279
this pool this

687
00:27:51,279 --> 00:27:53,520
object that we're spraying is going to

688
00:27:53,520 --> 00:27:56,559
end up in is it a common size we will go

689
00:27:56,559 --> 00:27:58,799
in lfa sub-segments

690
00:27:58,799 --> 00:28:01,279
is this a non-common size we'll go in vs

691
00:28:01,279 --> 00:28:03,440
sub segments if this is a via sub

692
00:28:03,440 --> 00:28:06,640
segment then every block has an encoded

693
00:28:06,640 --> 00:28:08,320
header

694
00:28:08,320 --> 00:28:10,080
how do we handle that

695
00:28:10,080 --> 00:28:12,559
also sub segments cross page boundaries

696
00:28:12,559 --> 00:28:14,159
so we need to account for all sorts of

697
00:28:14,159 --> 00:28:17,679
things like um weird alignments because

698
00:28:17,679 --> 00:28:19,360
there are all sorts of weird alignments

699
00:28:19,360 --> 00:28:21,760
going on with this new model

700
00:28:21,760 --> 00:28:23,039
also

701
00:28:23,039 --> 00:28:25,760
we don't necessarily know that all of

702
00:28:25,760 --> 00:28:29,120
our sprayed objects will necessarily end

703
00:28:29,120 --> 00:28:30,720
up in the same

704
00:28:30,720 --> 00:28:32,720
sub-segment even if it's the same

705
00:28:32,720 --> 00:28:35,600
sub-segment type we can have

706
00:28:35,600 --> 00:28:39,279
four pages of lfh sub-segments then nine

707
00:28:39,279 --> 00:28:42,480
pages of v8 are via sub-segment then

708
00:28:42,480 --> 00:28:46,480
five pages of another lfh sub segment

709
00:28:46,480 --> 00:28:49,039
but of a different size we don't

710
00:28:49,039 --> 00:28:51,840
necessarily know that

711
00:28:51,840 --> 00:28:54,080
we'll have all of our straight objects

712
00:28:54,080 --> 00:28:56,320
immediately one after the other

713
00:28:56,320 --> 00:28:58,880
we can't know that the

714
00:28:58,880 --> 00:29:01,440
uh pull block we're overflowing

715
00:29:01,440 --> 00:29:04,000
is not at the end of a sub segment and

716
00:29:04,000 --> 00:29:06,000
will overflow a different

717
00:29:06,000 --> 00:29:08,720
uh a different sub segment

718
00:29:08,720 --> 00:29:09,679
if

719
00:29:09,679 --> 00:29:12,399
uh we're trying to use a buffer overflow

720
00:29:12,399 --> 00:29:14,000
we will need to

721
00:29:14,000 --> 00:29:16,000
get a buffer overflow

722
00:29:16,000 --> 00:29:19,120
in a pull block that is the same size as

723
00:29:19,120 --> 00:29:21,120
the blocks were sprayed otherwise they

724
00:29:21,120 --> 00:29:23,760
could end up in different sub segments

725
00:29:23,760 --> 00:29:26,000
even if they're both lfh sizes they will

726
00:29:26,000 --> 00:29:28,559
end up in different lfh sub segments

727
00:29:28,559 --> 00:29:30,399
if we're going to overflow a block in a

728
00:29:30,399 --> 00:29:32,240
vs sub segment

729
00:29:32,240 --> 00:29:34,960
then we're going to overflow the next vs

730
00:29:34,960 --> 00:29:37,440
chunk header that isn't encoded and if

731
00:29:37,440 --> 00:29:39,200
we don't fake it correctly then when the

732
00:29:39,200 --> 00:29:41,840
kernel tries to handle it it will decode

733
00:29:41,840 --> 00:29:45,360
it and will most likely just crash

734
00:29:45,360 --> 00:29:48,159
in one way or another and faking it is

735
00:29:48,159 --> 00:29:50,399
really hard because to

736
00:29:50,399 --> 00:29:52,799
encode it properly we need all we need

737
00:29:52,799 --> 00:29:53,600
like

738
00:29:53,600 --> 00:29:55,679
two or three different information

739
00:29:55,679 --> 00:29:58,559
disclosures that are very non-trivial

740
00:29:58,559 --> 00:30:00,159
anymore

741
00:30:00,159 --> 00:30:01,120
so

742
00:30:01,120 --> 00:30:02,720
it doesn't make it impossible but it

743
00:30:02,720 --> 00:30:05,600
doesn't make it a lot harder than this

744
00:30:05,600 --> 00:30:08,480
used to be

745
00:30:08,480 --> 00:30:09,840
that's one thing

746
00:30:09,840 --> 00:30:11,760
um

747
00:30:11,760 --> 00:30:13,760
and we also have all the different

748
00:30:13,760 --> 00:30:15,760
mitigations that were added before this

749
00:30:15,760 --> 00:30:17,600
change such as

750
00:30:17,600 --> 00:30:20,240
the new allocation api that zeroes out

751
00:30:20,240 --> 00:30:21,600
allocations

752
00:30:21,600 --> 00:30:24,480
once they're made meaning

753
00:30:24,480 --> 00:30:27,760
it removes a lot of the information like

754
00:30:27,760 --> 00:30:30,159
information links that used to exist

755
00:30:30,159 --> 00:30:32,480
and now and we need way more information

756
00:30:32,480 --> 00:30:35,840
links to for example in code and fake

757
00:30:35,840 --> 00:30:38,480
pull headers or decode pool headers if

758
00:30:38,480 --> 00:30:39,760
we can read them

759
00:30:39,760 --> 00:30:42,480
that makes it even harder

760
00:30:42,480 --> 00:30:44,399
another thing is there used to be a lot

761
00:30:44,399 --> 00:30:47,120
of pool overflows

762
00:30:47,120 --> 00:30:48,720
of buffer overflow techniques in the

763
00:30:48,720 --> 00:30:50,559
pool that

764
00:30:50,559 --> 00:30:53,360
took advantage of object headers and

765
00:30:53,360 --> 00:30:55,200
corrupting them a lot of these things

766
00:30:55,200 --> 00:30:57,760
were mitigated too in the last few years

767
00:30:57,760 --> 00:31:02,399
making this also a little bit harder

768
00:31:03,600 --> 00:31:07,039
but it isn't all that bad um

769
00:31:07,039 --> 00:31:09,679
because there are still some benefits

770
00:31:09,679 --> 00:31:12,559
too one of them which is pretty cool and

771
00:31:12,559 --> 00:31:15,760
was discovered by alex inesco when we

772
00:31:15,760 --> 00:31:17,039
initially

773
00:31:17,039 --> 00:31:19,840
researched the new pool design

774
00:31:19,840 --> 00:31:22,640
is that one of the kernel pools that

775
00:31:22,640 --> 00:31:23,919
used to

776
00:31:23,919 --> 00:31:25,760
exist and now isn't

777
00:31:25,760 --> 00:31:28,720
um isn't used all that much anymore is

778
00:31:28,720 --> 00:31:32,640
the executable non-paged pool because

779
00:31:32,640 --> 00:31:35,120
up until windows 8

780
00:31:35,120 --> 00:31:35,710
the

781
00:31:35,710 --> 00:31:36,799
[Music]

782
00:31:36,799 --> 00:31:39,840
or windows 7 i think the default

783
00:31:39,840 --> 00:31:42,080
non-paged pool was executable for all

784
00:31:42,080 --> 00:31:44,880
sorts of historical reasons

785
00:31:44,880 --> 00:31:48,080
and since then things changed the

786
00:31:48,080 --> 00:31:50,799
default non-page pool is now uh

787
00:31:50,799 --> 00:31:54,000
non-executable non-page pool nx

788
00:31:54,000 --> 00:31:57,919
but a non-page pool still exists sort of

789
00:31:57,919 --> 00:31:58,880
in most

790
00:31:58,880 --> 00:32:02,000
most systems it's not used anymore but

791
00:32:02,000 --> 00:32:04,880
since the pool type still exists

792
00:32:04,880 --> 00:32:07,919
uh there is still a segment heap for it

793
00:32:07,919 --> 00:32:10,159
and because there is a segment heap for

794
00:32:10,159 --> 00:32:12,640
it we need to have at least one page of

795
00:32:12,640 --> 00:32:15,440
executable non-paged pool to allocate

796
00:32:15,440 --> 00:32:17,120
the segment heap in

797
00:32:17,120 --> 00:32:19,600
so if you know where to find it there is

798
00:32:19,600 --> 00:32:22,880
still one read write execute page in the

799
00:32:22,880 --> 00:32:24,000
kernel

800
00:32:24,000 --> 00:32:24,880
now

801
00:32:24,880 --> 00:32:27,679
yes there is a segment heap structure

802
00:32:27,679 --> 00:32:30,080
there that you don't really want to

803
00:32:30,080 --> 00:32:31,200
corrupt

804
00:32:31,200 --> 00:32:32,720
but that structure with all the

805
00:32:32,720 --> 00:32:34,720
different nested structures in it takes

806
00:32:34,720 --> 00:32:39,039
about half a page around 800 hex bytes

807
00:32:39,039 --> 00:32:41,840
that leaves you with about half a page

808
00:32:41,840 --> 00:32:43,200
of

809
00:32:43,200 --> 00:32:46,080
read write execute memory in the kernel

810
00:32:46,080 --> 00:32:48,320
even if no one uses

811
00:32:48,320 --> 00:32:49,440
any

812
00:32:49,440 --> 00:32:52,159
regular non-page to pull memory at all

813
00:32:52,159 --> 00:32:54,559
so that's a nice little place for your

814
00:32:54,559 --> 00:32:56,480
kernel shell code if you

815
00:32:56,480 --> 00:32:58,640
have an arbitrary right vulnerability

816
00:32:58,640 --> 00:33:00,799
and manage to find that page it's a nice

817
00:33:00,799 --> 00:33:02,799
place to drop your

818
00:33:02,799 --> 00:33:04,320
shell code

819
00:33:04,320 --> 00:33:06,399
of course that doesn't work with hvci

820
00:33:06,399 --> 00:33:08,559
because with hvci the executable

821
00:33:08,559 --> 00:33:11,600
non-page pool doesn't exist anymore but

822
00:33:11,600 --> 00:33:14,720
very very very few systems use hvci so

823
00:33:14,720 --> 00:33:18,000
that's still a pretty cool trick

824
00:33:18,240 --> 00:33:20,480
um and here's proof i

825
00:33:20,480 --> 00:33:24,320
use this uh windbag command to find the

826
00:33:24,320 --> 00:33:27,679
executable non-paged pool dumped its pte

827
00:33:27,679 --> 00:33:30,000
and we can see that i actually have a

828
00:33:30,000 --> 00:33:33,039
page of read write execute memory on my

829
00:33:33,039 --> 00:33:36,799
system which i think is very cool

830
00:33:36,960 --> 00:33:40,640
another thing is the secure pool because

831
00:33:40,640 --> 00:33:43,200
now with hyper-v we have the secure

832
00:33:43,200 --> 00:33:44,960
kernel that is completely protected from

833
00:33:44,960 --> 00:33:47,679
normal kernel uh regular kernel code

834
00:33:47,679 --> 00:33:50,559
can't access it and one of the things

835
00:33:50,559 --> 00:33:52,960
that we got there is the secure pool

836
00:33:52,960 --> 00:33:54,240
it's a

837
00:33:54,240 --> 00:33:55,440
pool that is

838
00:33:55,440 --> 00:33:56,799
read write

839
00:33:56,799 --> 00:34:00,480
in vtl1 in the secure kernel and read

840
00:34:00,480 --> 00:34:03,679
only for normal kernel code and its

841
00:34:03,679 --> 00:34:07,200
purpose is to let third party drivers

842
00:34:07,200 --> 00:34:09,040
allocate memory that they don't want

843
00:34:09,040 --> 00:34:11,918
anyone to be able to override to avoid

844
00:34:11,918 --> 00:34:14,399
data corruption attacks

845
00:34:14,399 --> 00:34:17,040
and since all pools now use the same

846
00:34:17,040 --> 00:34:19,839
design that means the secure pool uses

847
00:34:19,839 --> 00:34:22,159
that design too

848
00:34:22,159 --> 00:34:24,879
and another thing that alex discovered

849
00:34:24,879 --> 00:34:28,079
in that research is that

850
00:34:28,079 --> 00:34:29,918
the secure pool

851
00:34:29,918 --> 00:34:32,239
it has a read-only mapping

852
00:34:32,239 --> 00:34:34,560
for the normal kernel to read and that

853
00:34:34,560 --> 00:34:36,320
read-only mapping

854
00:34:36,320 --> 00:34:37,839
contained

855
00:34:37,839 --> 00:34:39,918
the whole pool including

856
00:34:39,918 --> 00:34:42,320
the segment heap structure on the first

857
00:34:42,320 --> 00:34:43,199
page

858
00:34:43,199 --> 00:34:45,199
and what we know about the segment heap

859
00:34:45,199 --> 00:34:48,399
is it has all sorts of pointers and

860
00:34:48,399 --> 00:34:50,079
because it was a

861
00:34:50,079 --> 00:34:51,040
mapping

862
00:34:51,040 --> 00:34:53,359
of vtl1 that has a different address

863
00:34:53,359 --> 00:34:55,199
space that should not be

864
00:34:55,199 --> 00:34:58,079
exposed to the normal kernel it should

865
00:34:58,079 --> 00:35:01,040
be aslod

866
00:35:01,520 --> 00:35:04,160
having that structure mapped into vtl0

867
00:35:04,160 --> 00:35:06,640
into the normal kernel linked all sorts

868
00:35:06,640 --> 00:35:08,720
of different addresses and the most

869
00:35:08,720 --> 00:35:12,240
interesting ones were the callbacks in

870
00:35:12,240 --> 00:35:15,119
the vs and lph context because these

871
00:35:15,119 --> 00:35:17,680
callbacks point to

872
00:35:17,680 --> 00:35:21,040
uh kernel functions to that are used to

873
00:35:21,040 --> 00:35:23,599
allocate free etc

874
00:35:23,599 --> 00:35:25,760
lfh and vs

875
00:35:25,760 --> 00:35:26,800
blocks

876
00:35:26,800 --> 00:35:29,520
and for the secure in the secure pool

877
00:35:29,520 --> 00:35:31,839
these pointed two addresses of functions

878
00:35:31,839 --> 00:35:34,079
in the secure kernel that should not be

879
00:35:34,079 --> 00:35:36,400
available to normal kernel

880
00:35:36,400 --> 00:35:39,359
now since alex um discovered and

881
00:35:39,359 --> 00:35:42,240
reported that this was fixed the

882
00:35:42,240 --> 00:35:44,640
segment heath is not mapped into the

883
00:35:44,640 --> 00:35:46,560
normal kernel anymore so you can't use

884
00:35:46,560 --> 00:35:49,040
that but there are still a few

885
00:35:49,040 --> 00:35:51,920
um address leaks there using other

886
00:35:51,920 --> 00:35:54,800
structures such as the heap page segment

887
00:35:54,800 --> 00:35:57,200
that leaks the addresses of the secure

888
00:35:57,200 --> 00:36:00,000
pool itself and addresses of the

889
00:36:00,000 --> 00:36:02,720
metadata heap where the segment heap is

890
00:36:02,720 --> 00:36:04,160
now allocated

891
00:36:04,160 --> 00:36:07,200
so not as critical as

892
00:36:07,200 --> 00:36:08,960
leaking the address to the secure pool

893
00:36:08,960 --> 00:36:11,839
but still some vtl1 to vtl0 address

894
00:36:11,839 --> 00:36:14,160
leaks that might be useful to someone at

895
00:36:14,160 --> 00:36:16,079
some point and those

896
00:36:16,079 --> 00:36:20,079
aren't patched as of today

897
00:36:20,640 --> 00:36:23,280
now before i finish the talk i want to

898
00:36:23,280 --> 00:36:24,839
show a few

899
00:36:24,839 --> 00:36:27,599
interesting tools that you can use to

900
00:36:27,599 --> 00:36:29,839
analyze the pool if you're using wind

901
00:36:29,839 --> 00:36:32,880
bag you can use bank pool it was broken

902
00:36:32,880 --> 00:36:35,359
for a while now it's back it works in

903
00:36:35,359 --> 00:36:37,200
about 98

904
00:36:37,200 --> 00:36:39,599
of cases still a little bit slow but it

905
00:36:39,599 --> 00:36:41,040
does work

906
00:36:41,040 --> 00:36:43,280
i also wrote a pull extension that works

907
00:36:43,280 --> 00:36:46,320
similarly to bank pool it's

908
00:36:46,320 --> 00:36:48,480
a lot faster and has a few other cool

909
00:36:48,480 --> 00:36:50,079
features that i'll release after the

910
00:36:50,079 --> 00:36:51,200
talk

911
00:36:51,200 --> 00:36:53,599
and the coolest one is

912
00:36:53,599 --> 00:36:56,720
a gui tool called pool viewer that i

913
00:36:56,720 --> 00:36:59,520
wrote that looks like

914
00:36:59,520 --> 00:37:02,800
this i already loaded the dump in it of

915
00:37:02,800 --> 00:37:05,599
the current machine just i preloaded it

916
00:37:05,599 --> 00:37:07,440
because it's a little bit slow

917
00:37:07,440 --> 00:37:09,760
and you can use it to

918
00:37:09,760 --> 00:37:11,440
view

919
00:37:11,440 --> 00:37:14,480
general ma general data about your pools

920
00:37:14,480 --> 00:37:17,280
what heaps you have what types how many

921
00:37:17,280 --> 00:37:19,920
blocks some call statistics like the

922
00:37:19,920 --> 00:37:21,520
common pool tags

923
00:37:21,520 --> 00:37:24,160
including empty pool tag

924
00:37:24,160 --> 00:37:26,079
and how many blocks you have of each

925
00:37:26,079 --> 00:37:27,200
type

926
00:37:27,200 --> 00:37:29,839
unsurprisingly the most common one is

927
00:37:29,839 --> 00:37:31,280
lfh

928
00:37:31,280 --> 00:37:33,040
and if you want you can go to the second

929
00:37:33,040 --> 00:37:33,839
tab

930
00:37:33,839 --> 00:37:37,760
and view blocks individually you can

931
00:37:37,760 --> 00:37:40,240
filter them based on whatever it is that

932
00:37:40,240 --> 00:37:42,320
you want to filter

933
00:37:42,320 --> 00:37:44,960
and use that as the beginning

934
00:37:44,960 --> 00:37:47,200
as either investigating your pool or

935
00:37:47,200 --> 00:37:49,520
looking into specific

936
00:37:49,520 --> 00:37:51,119
addresses

937
00:37:51,119 --> 00:37:54,000
trying to find all sorts of um weird or

938
00:37:54,000 --> 00:37:55,920
interesting information

939
00:37:55,920 --> 00:37:57,920
it knows how to open an existing dump

940
00:37:57,920 --> 00:38:00,240
file or if it's running as

941
00:38:00,240 --> 00:38:02,240
an admin you can analyze your live

942
00:38:02,240 --> 00:38:04,640
machine which just create a dump of your

943
00:38:04,640 --> 00:38:06,880
current machine and opens it

944
00:38:06,880 --> 00:38:08,720
or you can export all your cool blocks

945
00:38:08,720 --> 00:38:13,359
to uh csv and run whatever data analysis

946
00:38:13,359 --> 00:38:15,200
tools you have

947
00:38:15,200 --> 00:38:16,839
on

948
00:38:16,839 --> 00:38:19,119
them so

949
00:38:19,119 --> 00:38:20,800
uh that's it for now of course there are

950
00:38:20,800 --> 00:38:21,920
a lot

951
00:38:21,920 --> 00:38:23,599
there is a lot more to do here for

952
00:38:23,599 --> 00:38:25,440
example there is a very very very cool

953
00:38:25,440 --> 00:38:27,040
research done by

954
00:38:27,040 --> 00:38:29,440
a few people from synactiv

955
00:38:29,440 --> 00:38:30,480
showing

956
00:38:30,480 --> 00:38:33,440
specific showing new exploitation

957
00:38:33,440 --> 00:38:34,720
techniques

958
00:38:34,720 --> 00:38:38,720
um using this new pool design uh there

959
00:38:38,720 --> 00:38:41,040
will be more research in the future i

960
00:38:41,040 --> 00:38:43,119
hope and there is a lot more to discover

961
00:38:43,119 --> 00:38:44,000
and do

962
00:38:44,000 --> 00:38:46,800
in this context and for anything that

963
00:38:46,800 --> 00:38:48,800
you want i'm available for questions

964
00:38:48,800 --> 00:38:49,680
here

965
00:38:49,680 --> 00:38:52,880
on twitter on email or on any platform

966
00:38:52,880 --> 00:38:55,520
uh where you managed to find me so thank

967
00:38:55,520 --> 00:38:58,000
you for coming to my talk and i hope you

968
00:38:58,000 --> 00:39:00,000
uh and i hope you learned something

969
00:39:00,000 --> 00:39:02,800
about the windows pool and exploiting it

970
00:39:02,800 --> 00:39:06,040
thank you

