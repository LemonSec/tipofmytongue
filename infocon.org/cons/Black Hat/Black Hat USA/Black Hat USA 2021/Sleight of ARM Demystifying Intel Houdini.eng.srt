1
00:00:01,130 --> 00:00:14,690
[Music]

2
00:00:15,360 --> 00:00:16,560
hello and thanks for joining this

3
00:00:16,560 --> 00:00:19,359
session um i'm brian and today i'll be

4
00:00:19,359 --> 00:00:21,279
talking about intel's houdini binary

5
00:00:21,279 --> 00:00:22,480
translator

6
00:00:22,480 --> 00:00:25,599
before that quickly above myself um i

7
00:00:25,599 --> 00:00:26,800
studied electrical engineering at the

8
00:00:26,800 --> 00:00:29,039
cooper union and currently working as a

9
00:00:29,039 --> 00:00:31,039
security consultant at with the ncc

10
00:00:31,039 --> 00:00:32,558
group

11
00:00:32,558 --> 00:00:34,640
i like to build random bits of hardware

12
00:00:34,640 --> 00:00:37,840
and also like to reverse engineer

13
00:00:37,840 --> 00:00:39,680
things other people built both hardware

14
00:00:39,680 --> 00:00:41,520
and software

15
00:00:41,520 --> 00:00:42,960
lately i've been doing a lot of android

16
00:00:42,960 --> 00:00:46,480
testing and sometimes mandatory android

17
00:00:46,480 --> 00:00:48,399
malware analysis

18
00:00:48,399 --> 00:00:50,960
so let's get right to android

19
00:00:50,960 --> 00:00:52,399
you guys probably know android is one of

20
00:00:52,399 --> 00:00:54,399
the largest operating systems for mobile

21
00:00:54,399 --> 00:00:55,520
devices

22
00:00:55,520 --> 00:00:56,399
and

23
00:00:56,399 --> 00:00:58,480
you can write android apps in java and

24
00:00:58,480 --> 00:01:00,079
kotlin officially

25
00:01:00,079 --> 00:01:02,879
and you could also write

26
00:01:02,879 --> 00:01:04,799
components of those apps in c and c plus

27
00:01:04,799 --> 00:01:08,159
plus using the native development kit

28
00:01:08,159 --> 00:01:10,080
uh android was originally built around

29
00:01:10,080 --> 00:01:12,560
arm platforms armed devices

30
00:01:12,560 --> 00:01:13,920
and

31
00:01:13,920 --> 00:01:15,759
later google has added support official

32
00:01:15,759 --> 00:01:18,560
support for x86 devices as well

33
00:01:18,560 --> 00:01:20,960
just to mention there there has been uh

34
00:01:20,960 --> 00:01:21,920
out of

35
00:01:21,920 --> 00:01:24,080
out of tree support for android and x86

36
00:01:24,080 --> 00:01:25,920
prior to that as well such as the

37
00:01:25,920 --> 00:01:28,240
android x86 project

38
00:01:28,240 --> 00:01:30,240
so there are two main types of android

39
00:01:30,240 --> 00:01:31,520
devices

40
00:01:31,520 --> 00:01:33,520
that's on x86 now

41
00:01:33,520 --> 00:01:36,799
those are x86 chromebooks and x86 hosts

42
00:01:36,799 --> 00:01:40,759
running commercial android emulators

43
00:01:40,880 --> 00:01:42,240
however there is a general lack of

44
00:01:42,240 --> 00:01:44,880
support for x86 and apps

45
00:01:44,880 --> 00:01:46,320
and that's because again like i

46
00:01:46,320 --> 00:01:48,159
mentioned andrew was originally built

47
00:01:48,159 --> 00:01:50,240
around arm so most of the devices are

48
00:01:50,240 --> 00:01:51,360
still armed

49
00:01:51,360 --> 00:01:53,680
and if you are app developer and if you

50
00:01:53,680 --> 00:01:55,360
have native code they don't actually

51
00:01:55,360 --> 00:01:57,040
require the only only thing they require

52
00:01:57,040 --> 00:01:58,880
is the arm builds and no other

53
00:01:58,880 --> 00:02:00,960
architectures are required

54
00:02:00,960 --> 00:02:03,199
so

55
00:02:03,680 --> 00:02:06,159
yeah only a few developers end up

56
00:02:06,159 --> 00:02:08,878
shipping x86 binaries for the apks

57
00:02:08,878 --> 00:02:10,479
but many of the apps actually contain

58
00:02:10,479 --> 00:02:12,080
native code

59
00:02:12,080 --> 00:02:15,040
so how do these x86 android devices

60
00:02:15,040 --> 00:02:18,640
support running these arm native

61
00:02:18,640 --> 00:02:21,200
applications

62
00:02:21,200 --> 00:02:23,200
the inter answer is the intel's

63
00:02:23,200 --> 00:02:24,800
proprietary

64
00:02:24,800 --> 00:02:26,959
houdini binary translator

65
00:02:26,959 --> 00:02:29,520
it was co-designed by google to work

66
00:02:29,520 --> 00:02:30,800
with android

67
00:02:30,800 --> 00:02:33,120
and this is the key piece that enables

68
00:02:33,120 --> 00:02:35,599
arm native applications to run on x86

69
00:02:35,599 --> 00:02:37,360
devices

70
00:02:37,360 --> 00:02:39,920
it's a it's a little black box shattered

71
00:02:39,920 --> 00:02:42,080
mystery there's

72
00:02:42,080 --> 00:02:43,280
barely any mention of it on their

73
00:02:43,280 --> 00:02:44,480
websites and there's no public

74
00:02:44,480 --> 00:02:45,920
documentation

75
00:02:45,920 --> 00:02:48,080
and it seems like several vendors

76
00:02:48,080 --> 00:02:50,239
vendors may be obfuscating trying to use

77
00:02:50,239 --> 00:02:51,920
their

78
00:02:51,920 --> 00:02:54,959
try to hide their usage of

79
00:02:54,959 --> 00:02:56,239
houdini

80
00:02:56,239 --> 00:02:58,239
and we notice there are three variants

81
00:02:58,239 --> 00:02:59,280
that are

82
00:02:59,280 --> 00:03:01,680
around

83
00:03:03,280 --> 00:03:07,040
so houdini is used in on x86 mobile

84
00:03:07,040 --> 00:03:09,519
phones phones which aren't really around

85
00:03:09,519 --> 00:03:10,879
anymore

86
00:03:10,879 --> 00:03:13,360
and also x86 chromebooks and this is

87
00:03:13,360 --> 00:03:15,280
actually how we got it specifically the

88
00:03:15,280 --> 00:03:17,440
32-bit x86

89
00:03:17,440 --> 00:03:19,200
implementing the

90
00:03:19,200 --> 00:03:21,920
32-bit arm

91
00:03:21,920 --> 00:03:24,239
houdini is also found in commercial

92
00:03:24,239 --> 00:03:26,319
android emulators both bluestacks and

93
00:03:26,319 --> 00:03:27,200
knox

94
00:03:27,200 --> 00:03:29,360
use or at least have the option to

95
00:03:29,360 --> 00:03:30,720
enable

96
00:03:30,720 --> 00:03:33,280
lipodini

97
00:03:33,280 --> 00:03:35,519
and android x86

98
00:03:35,519 --> 00:03:38,000
has it as well

99
00:03:38,000 --> 00:03:40,799
interestingly um from a

100
00:03:40,799 --> 00:03:43,360
talk from defcon 26 a few years ago

101
00:03:43,360 --> 00:03:46,799
bluestacks you renamed the library from

102
00:03:46,799 --> 00:03:48,239
le poudini to

103
00:03:48,239 --> 00:03:50,959
like something like lib3b trans.so for

104
00:03:50,959 --> 00:03:53,200
some unknown reason

105
00:03:53,200 --> 00:03:54,799
i believe knox does something similar as

106
00:03:54,799 --> 00:03:57,040
well

107
00:03:58,560 --> 00:04:01,840
so houdini is basically an interpreter

108
00:04:01,840 --> 00:04:03,840
for arm instructions

109
00:04:03,840 --> 00:04:06,080
and it's essentially a while loop around

110
00:04:06,080 --> 00:04:07,760
a switch

111
00:04:07,760 --> 00:04:09,920
and it also keeps track of the

112
00:04:09,920 --> 00:04:12,720
the emulator arm processor

113
00:04:12,720 --> 00:04:14,480
it reads um

114
00:04:14,480 --> 00:04:16,079
note that it does not do just-in-time

115
00:04:16,079 --> 00:04:18,720
compilation um as there's no x86

116
00:04:18,720 --> 00:04:21,680
constructions output to be run at a time

117
00:04:21,680 --> 00:04:24,720
and houdini is mainly two components

118
00:04:24,720 --> 00:04:27,440
the first is houdini it's it's used to

119
00:04:27,440 --> 00:04:30,000
run executable binaries and the second

120
00:04:30,000 --> 00:04:33,120
is lipodeny which is used to load shared

121
00:04:33,120 --> 00:04:36,479
objects and other libraries

122
00:04:37,680 --> 00:04:38,960
so

123
00:04:38,960 --> 00:04:41,040
yeah so houdini can run arm executable

124
00:04:41,040 --> 00:04:43,280
binaries both static and dynamic

125
00:04:43,280 --> 00:04:44,479
for dynamic

126
00:04:44,479 --> 00:04:47,280
executables it actually has its own set

127
00:04:47,280 --> 00:04:50,479
of pre-compiled libraries for arm and

128
00:04:50,479 --> 00:04:56,120
android that it uses from those pads

129
00:04:58,639 --> 00:05:00,560
so you can see in the screenshot below

130
00:05:00,560 --> 00:05:04,000
the um the system i'm running on is x86

131
00:05:04,000 --> 00:05:06,639
the file i'm trying to run is arm

132
00:05:06,639 --> 00:05:08,320
and it ran just fine

133
00:05:08,320 --> 00:05:10,240
now you might be wondering how where how

134
00:05:10,240 --> 00:05:11,759
does houdini come in i've never invoked

135
00:05:11,759 --> 00:05:13,840
it and this is actually a feature of the

136
00:05:13,840 --> 00:05:16,639
linux kernel called bin format misc

137
00:05:16,639 --> 00:05:18,240
and if you aren't familiar here's a

138
00:05:18,240 --> 00:05:20,160
quick

139
00:05:20,160 --> 00:05:24,759
intro whatever um

140
00:05:24,960 --> 00:05:26,880
so bin format mist is a capability of

141
00:05:26,880 --> 00:05:29,120
the linux kernel or feature

142
00:05:29,120 --> 00:05:31,280
and it basically lets you

143
00:05:31,280 --> 00:05:33,440
register customer interpreters for

144
00:05:33,440 --> 00:05:35,520
custom binary format it's very similar

145
00:05:35,520 --> 00:05:37,919
to how a shebang works for bash or

146
00:05:37,919 --> 00:05:40,719
python scripts

147
00:05:40,960 --> 00:05:43,840
so you can see the uh

148
00:05:43,840 --> 00:05:44,960
the

149
00:05:44,960 --> 00:05:47,440
see that houdini has

150
00:05:47,440 --> 00:05:51,199
registered interpreters for itself

151
00:05:51,199 --> 00:05:53,360
and so what this basically does is if i

152
00:05:53,360 --> 00:05:54,639
type in

153
00:05:54,639 --> 00:05:57,280
hello and i call try to execute kernel

154
00:05:57,280 --> 00:05:58,560
will see that and try to compare the

155
00:05:58,560 --> 00:06:00,319
magic bytes and if it matches it will

156
00:06:00,319 --> 00:06:03,440
convert it into system bin houdini

157
00:06:03,440 --> 00:06:06,440
hello

158
00:06:06,720 --> 00:06:09,280
so the second component lipodynia so

159
00:06:09,280 --> 00:06:12,560
is a shared object itself built for x86

160
00:06:12,560 --> 00:06:15,120
but it can be used to load arm objects

161
00:06:15,120 --> 00:06:16,560
shared objects

162
00:06:16,560 --> 00:06:17,840
and it was mainly designed to use

163
00:06:17,840 --> 00:06:19,680
android native bridge to run arm native

164
00:06:19,680 --> 00:06:21,199
code

165
00:06:21,199 --> 00:06:22,639
so let's talk about android native

166
00:06:22,639 --> 00:06:24,639
bridge um

167
00:06:24,639 --> 00:06:26,080
it is the main interface that android

168
00:06:26,080 --> 00:06:28,000
uses to talk to librodini

169
00:06:28,000 --> 00:06:30,319
and it's part of the android runtime and

170
00:06:30,319 --> 00:06:33,120
it's it's primary feature is to

171
00:06:33,120 --> 00:06:35,919
support running native code in different

172
00:06:35,919 --> 00:06:38,560
architectures

173
00:06:40,319 --> 00:06:43,039
so as it's part of android runtime it's

174
00:06:43,039 --> 00:06:45,600
initialized on boot and it reads that

175
00:06:45,600 --> 00:06:48,240
system property to see what file has to

176
00:06:48,240 --> 00:06:52,240
load if it's set to zero it's disabled

177
00:06:52,240 --> 00:06:53,360
um

178
00:06:53,360 --> 00:06:55,840
actually android x86 project uses their

179
00:06:55,840 --> 00:06:58,400
own version of uh called lib

180
00:06:58,400 --> 00:07:01,360
own implementation called libmb.so but

181
00:07:01,360 --> 00:07:02,880
when you look at the source it's it's

182
00:07:02,880 --> 00:07:04,639
actually just a thin wrapper around le

183
00:07:04,639 --> 00:07:07,440
perdini um

184
00:07:07,440 --> 00:07:09,199
also interestingly they if you go

185
00:07:09,199 --> 00:07:11,759
through the source trees um

186
00:07:11,759 --> 00:07:13,120
throughout different tags they seem to

187
00:07:13,120 --> 00:07:15,440
have moved around the link and the code

188
00:07:15,440 --> 00:07:18,240
to download lippoudini and uses some dot

189
00:07:18,240 --> 00:07:21,759
cn link shorteners and

190
00:07:22,240 --> 00:07:23,680
yeah

191
00:07:23,680 --> 00:07:25,120
so this means that

192
00:07:25,120 --> 00:07:26,720
so native bridge is actually not

193
00:07:26,720 --> 00:07:28,479
specific to arm it just defines an

194
00:07:28,479 --> 00:07:31,120
interface for a translation layer

195
00:07:31,120 --> 00:07:32,880
that also means

196
00:07:32,880 --> 00:07:36,800
if you implement a native bridge

197
00:07:36,800 --> 00:07:38,080
you could

198
00:07:38,080 --> 00:07:39,919
write your own custom binary translation

199
00:07:39,919 --> 00:07:41,440
layer for different architectures such

200
00:07:41,440 --> 00:07:45,599
as mips on x86 and whatnot

201
00:07:45,599 --> 00:07:47,840
and nativebridge defines interfaces with

202
00:07:47,840 --> 00:07:49,599
these callbacks that i'll be talking

203
00:07:49,599 --> 00:07:51,440
about but before that i want to talk to

204
00:07:51,440 --> 00:07:53,759
you about uh

205
00:07:53,759 --> 00:07:56,160
java native interface so java native

206
00:07:56,160 --> 00:07:58,639
interface is basically interconnect that

207
00:07:58,639 --> 00:08:00,479
connects the java side of our code with

208
00:08:00,479 --> 00:08:02,160
our native code

209
00:08:02,160 --> 00:08:03,680
um

210
00:08:03,680 --> 00:08:06,400
and the struct shown on the right is the

211
00:08:06,400 --> 00:08:08,400
jni m

212
00:08:08,400 --> 00:08:10,840
struct which mostly consists

213
00:08:10,840 --> 00:08:14,080
of it's a bag of function pointers

214
00:08:14,080 --> 00:08:16,560
and whenever the java side calls any

215
00:08:16,560 --> 00:08:18,639
native code this the pointer to the

216
00:08:18,639 --> 00:08:22,000
struct is passed as the first argument

217
00:08:22,000 --> 00:08:24,319
so that when our native code written in

218
00:08:24,319 --> 00:08:26,800
c wants to call interact with the java

219
00:08:26,800 --> 00:08:28,639
world it could use these functions such

220
00:08:28,639 --> 00:08:31,199
as like find class alloc or call object

221
00:08:31,199 --> 00:08:32,159
methods

222
00:08:32,159 --> 00:08:34,080
and it would it's equivalent to a low

223
00:08:34,080 --> 00:08:37,360
level reflection api for java

224
00:08:37,360 --> 00:08:40,519
in c

225
00:08:42,159 --> 00:08:44,000
so going back to the callbacks the first

226
00:08:44,000 --> 00:08:46,560
them which is the native bridge runtime

227
00:08:46,560 --> 00:08:47,920
callbacks

228
00:08:47,920 --> 00:08:49,440
as far as this talk is concerned this is

229
00:08:49,440 --> 00:08:51,279
not that important and it's

230
00:08:51,279 --> 00:08:52,880
these callbacks are provided from the

231
00:08:52,880 --> 00:08:55,680
native bridge to the houdini so liberty

232
00:08:55,680 --> 00:08:57,600
could interact with native bridge

233
00:08:57,600 --> 00:09:00,320
native functions

234
00:09:00,320 --> 00:09:02,320
the more interesting callbacks are the

235
00:09:02,320 --> 00:09:04,399
native bridge callbacks

236
00:09:04,399 --> 00:09:06,160
and

237
00:09:06,160 --> 00:09:07,519
this is how

238
00:09:07,519 --> 00:09:10,480
our native bridge from the android side

239
00:09:10,480 --> 00:09:15,360
enter can call code into our houdini

240
00:09:15,360 --> 00:09:16,800
so

241
00:09:16,800 --> 00:09:17,519
i

242
00:09:17,519 --> 00:09:19,360
cut out

243
00:09:19,360 --> 00:09:21,440
some of the functions on on the right

244
00:09:21,440 --> 00:09:23,040
but some of the interesting ones are

245
00:09:23,040 --> 00:09:25,760
initialize probably guess what that does

246
00:09:25,760 --> 00:09:27,760
uh load library which acts similarly to

247
00:09:27,760 --> 00:09:29,120
a dl open

248
00:09:29,120 --> 00:09:31,040
and get trampoline which acts similar to

249
00:09:31,040 --> 00:09:33,360
dlcent but we'll talk about why that's

250
00:09:33,360 --> 00:09:35,440
interesting later

251
00:09:35,440 --> 00:09:38,080
and this struct is actually

252
00:09:38,080 --> 00:09:41,040
an exported symbol on liboudini.so via

253
00:09:41,040 --> 00:09:43,600
the name nativebridge itf and you can

254
00:09:43,600 --> 00:09:45,600
see that here

255
00:09:45,600 --> 00:09:46,720
so

256
00:09:46,720 --> 00:09:48,399
and that's the uh the picture is

257
00:09:48,399 --> 00:09:50,090
actually the

258
00:09:50,090 --> 00:09:51,760
[Music]

259
00:09:51,760 --> 00:09:53,600
data the structure

260
00:09:53,600 --> 00:09:55,760
in the binary and you can see all the

261
00:09:55,760 --> 00:09:57,279
function pointers right there except for

262
00:09:57,279 --> 00:09:58,320
the last one

263
00:09:58,320 --> 00:10:01,440
i guess that's unsupported

264
00:10:02,399 --> 00:10:04,800
so to kind of put this all together this

265
00:10:04,800 --> 00:10:07,760
is how it works on on a normal arm on

266
00:10:07,760 --> 00:10:09,680
arm

267
00:10:09,680 --> 00:10:11,200
app

268
00:10:11,200 --> 00:10:12,399
system

269
00:10:12,399 --> 00:10:13,920
so your

270
00:10:13,920 --> 00:10:16,959
android code runs and android app runs

271
00:10:16,959 --> 00:10:19,120
and it wants to load a library

272
00:10:19,120 --> 00:10:20,079
and then

273
00:10:20,079 --> 00:10:22,480
so the android runtime will call dl open

274
00:10:22,480 --> 00:10:25,200
on your native code libnative.so

275
00:10:25,200 --> 00:10:26,959
and when you want to call a function the

276
00:10:26,959 --> 00:10:28,560
android runtime does a dlcim which

277
00:10:28,560 --> 00:10:30,160
returns a function pointer to our native

278
00:10:30,160 --> 00:10:31,200
function

279
00:10:31,200 --> 00:10:33,839
and then you could jump to it

280
00:10:33,839 --> 00:10:36,640
and our native code could also interact

281
00:10:36,640 --> 00:10:39,440
with the java world using the jnim

282
00:10:39,440 --> 00:10:40,959
function pointers that i mentioned

283
00:10:40,959 --> 00:10:42,240
before

284
00:10:42,240 --> 00:10:44,240
so this is pretty simple under normal

285
00:10:44,240 --> 00:10:46,079
circumstances

286
00:10:46,079 --> 00:10:48,240
now when you have a cross architecture

287
00:10:48,240 --> 00:10:49,760
app or

288
00:10:49,760 --> 00:10:53,120
not a cross architecture app but a

289
00:10:53,120 --> 00:10:56,240
arm native code running on x86 android

290
00:10:56,240 --> 00:10:58,399
with native brits and lipodini loaded it

291
00:10:58,399 --> 00:11:00,720
looks something like this

292
00:11:00,720 --> 00:11:01,440
so

293
00:11:01,440 --> 00:11:02,959
before anything happens before your app

294
00:11:02,959 --> 00:11:04,959
is loaded on boot native bridge is

295
00:11:04,959 --> 00:11:07,279
initialized and it reads that system

296
00:11:07,279 --> 00:11:09,600
property from a few slides back and then

297
00:11:09,600 --> 00:11:12,320
dl opens the houdini.so

298
00:11:12,320 --> 00:11:13,200
and

299
00:11:13,200 --> 00:11:15,040
liberating that iso is actually so you

300
00:11:15,040 --> 00:11:17,279
could just use dl open and dlc it gets

301
00:11:17,279 --> 00:11:20,320
the callbacks via the native bridge itf

302
00:11:20,320 --> 00:11:22,000
symbol

303
00:11:22,000 --> 00:11:23,760
and then it calls initialize which isn't

304
00:11:23,760 --> 00:11:25,440
shown in the diagram

305
00:11:25,440 --> 00:11:27,680
so this before the app happens when you

306
00:11:27,680 --> 00:11:30,320
launch the app and the app requests

307
00:11:30,320 --> 00:11:31,120
a

308
00:11:31,120 --> 00:11:32,720
native library with something like

309
00:11:32,720 --> 00:11:34,640
system.load library

310
00:11:34,640 --> 00:11:37,040
um the native bridge does not do a dl

311
00:11:37,040 --> 00:11:38,959
open because it's native bridge is

312
00:11:38,959 --> 00:11:41,600
enabled so instead does a load library

313
00:11:41,600 --> 00:11:43,839
library on the libradini binary through

314
00:11:43,839 --> 00:11:45,279
the callbacks

315
00:11:45,279 --> 00:11:49,439
and that loads our arm native code

316
00:11:50,079 --> 00:11:51,920
and then when our

317
00:11:51,920 --> 00:11:53,920
app code wants to call a function it

318
00:11:53,920 --> 00:11:56,480
calls get trampoline

319
00:11:56,480 --> 00:11:58,720
so we can't actually use dlcm directly

320
00:11:58,720 --> 00:11:59,760
because

321
00:11:59,760 --> 00:12:01,600
one dl open would not open it because

322
00:12:01,600 --> 00:12:03,440
it's a different architecture and two

323
00:12:03,440 --> 00:12:05,519
dlc will give you the

324
00:12:05,519 --> 00:12:07,920
pointer directly to the native code and

325
00:12:07,920 --> 00:12:09,519
we can't call that from our android

326
00:12:09,519 --> 00:12:11,760
runtime because our native code is armed

327
00:12:11,760 --> 00:12:13,600
and our android runtime is running on

328
00:12:13,600 --> 00:12:15,600
x86 processor

329
00:12:15,600 --> 00:12:17,200
so the function pointer that's returned

330
00:12:17,200 --> 00:12:19,120
by get trampoline and actually a stub

331
00:12:19,120 --> 00:12:20,800
into the interpreter

332
00:12:20,800 --> 00:12:23,200
and when you call it

333
00:12:23,200 --> 00:12:25,680
the interpreter starts working

334
00:12:25,680 --> 00:12:27,519
and it starts reading the native code

335
00:12:27,519 --> 00:12:30,959
and starts emulating these instructions

336
00:12:30,959 --> 00:12:33,040
so i mentioned previously that um

337
00:12:33,040 --> 00:12:35,279
whenever you call native code the

338
00:12:35,279 --> 00:12:37,360
java side

339
00:12:37,360 --> 00:12:38,720
gives the

340
00:12:38,720 --> 00:12:40,800
pointer to the jni instruct function

341
00:12:40,800 --> 00:12:42,079
pointers

342
00:12:42,079 --> 00:12:43,839
as the first argument

343
00:12:43,839 --> 00:12:46,079
uh similar to how why we can't call dl

344
00:12:46,079 --> 00:12:48,320
sim on our native library we can pass

345
00:12:48,320 --> 00:12:51,120
our jni instruct directly from native

346
00:12:51,120 --> 00:12:53,519
bridge into our native

347
00:12:53,519 --> 00:12:54,399
code

348
00:12:54,399 --> 00:12:55,839
because the function pointers you would

349
00:12:55,839 --> 00:12:57,600
get are

350
00:12:57,600 --> 00:13:00,480
pointing to functions written in x86

351
00:13:00,480 --> 00:13:02,000
so to handle this

352
00:13:02,000 --> 00:13:04,720
um lee houdini creates its own jni

353
00:13:04,720 --> 00:13:06,880
instruct and it's filter function

354
00:13:06,880 --> 00:13:09,920
pointers that

355
00:13:11,040 --> 00:13:12,480
it's for the function filter function

356
00:13:12,480 --> 00:13:14,079
pointers

357
00:13:14,079 --> 00:13:16,880
that lead to uh trap instructions

358
00:13:16,880 --> 00:13:19,279
and when our native code wants to call a

359
00:13:19,279 --> 00:13:22,639
function in jnim it loads looks at that

360
00:13:22,639 --> 00:13:23,440
and

361
00:13:23,440 --> 00:13:25,519
executes those trap instructions and our

362
00:13:25,519 --> 00:13:27,200
interpreter knows which trap

363
00:13:27,200 --> 00:13:30,000
instructions those are and it uses the

364
00:13:30,000 --> 00:13:31,440
jni and

365
00:13:31,440 --> 00:13:34,320
struck cached when it was called and

366
00:13:34,320 --> 00:13:35,200
then

367
00:13:35,200 --> 00:13:38,079
that's the blue line turning into red

368
00:13:38,079 --> 00:13:39,600
so

369
00:13:39,600 --> 00:13:41,360
basically our native code runs that trap

370
00:13:41,360 --> 00:13:43,040
instruction and interpreter sees that

371
00:13:43,040 --> 00:13:45,279
and does the jnam call and returns back

372
00:13:45,279 --> 00:13:47,120
to native code and when native code is

373
00:13:47,120 --> 00:13:48,800
done it turns back to the interpreter

374
00:13:48,800 --> 00:13:51,120
which turns back to wherever you called

375
00:13:51,120 --> 00:13:53,440
um the function pointer

376
00:13:53,440 --> 00:13:57,440
initially from our java

377
00:13:57,920 --> 00:13:59,199
that was a

378
00:13:59,199 --> 00:14:01,199
mouthful

379
00:14:01,199 --> 00:14:03,760
so now that we have a good uh somewhat

380
00:14:03,760 --> 00:14:05,440
understanding of how

381
00:14:05,440 --> 00:14:08,639
liberdini and native bridge gets loaded

382
00:14:08,639 --> 00:14:10,000
together

383
00:14:10,000 --> 00:14:11,920
we could start delving

384
00:14:11,920 --> 00:14:13,519
deeper into

385
00:14:13,519 --> 00:14:15,519
how it works internally

386
00:14:15,519 --> 00:14:19,360
starting starting with memory um

387
00:14:19,760 --> 00:14:22,079
lipidini seems to load uh leave houdini

388
00:14:22,079 --> 00:14:24,320
loads all of the libraries in the same

389
00:14:24,320 --> 00:14:27,360
address space both arm and x86

390
00:14:27,360 --> 00:14:29,360
and it also doesn't have any like

391
00:14:29,360 --> 00:14:32,000
special magic translation between arm

392
00:14:32,000 --> 00:14:34,800
memory addresses and x86 addresses which

393
00:14:34,800 --> 00:14:36,480
means they're all

394
00:14:36,480 --> 00:14:39,040
accessible with each other

395
00:14:39,040 --> 00:14:40,079
um

396
00:14:40,079 --> 00:14:41,760
and there but there is a separate

397
00:14:41,760 --> 00:14:45,199
allocation for arm stack and you can see

398
00:14:45,199 --> 00:14:47,760
it here this is a snippet from

399
00:14:47,760 --> 00:14:50,160
the process memory map using self pid

400
00:14:50,160 --> 00:14:52,000
map

401
00:14:52,000 --> 00:14:54,320
and you can see our native library and

402
00:14:54,320 --> 00:14:56,839
lipuidine loaded

403
00:14:56,839 --> 00:14:59,839
um these are the arm libraries that are

404
00:14:59,839 --> 00:15:01,680
loaded and the ones on the bottom are

405
00:15:01,680 --> 00:15:03,120
x86

406
00:15:03,120 --> 00:15:04,639
so they are in this in fact in the same

407
00:15:04,639 --> 00:15:06,320
address space

408
00:15:06,320 --> 00:15:09,600
um and lift c is loaded for both the arm

409
00:15:09,600 --> 00:15:12,720
version and x86 version and we could

410
00:15:12,720 --> 00:15:14,000
also see

411
00:15:14,000 --> 00:15:16,160
some anonymous memory mapped and our

412
00:15:16,160 --> 00:15:19,199
stack is somewhere in there

413
00:15:20,320 --> 00:15:22,160
so let's go to the next part which is

414
00:15:22,160 --> 00:15:24,560
how the houdini actually executes the

415
00:15:24,560 --> 00:15:25,600
instructions

416
00:15:25,600 --> 00:15:27,920
so i mentioned previously it's basically

417
00:15:27,920 --> 00:15:30,399
a switch inside a while loop plus a

418
00:15:30,399 --> 00:15:31,519
state machine to keep track of the

419
00:15:31,519 --> 00:15:34,639
register states processor states and

420
00:15:34,639 --> 00:15:37,279
this portion shows the

421
00:15:37,279 --> 00:15:38,800
kind of like the fetch decode and

422
00:15:38,800 --> 00:15:40,880
dispatch portion of it

423
00:15:40,880 --> 00:15:42,079
and

424
00:15:42,079 --> 00:15:44,639
i'm going to describe the

425
00:15:44,639 --> 00:15:47,440
the comments in the next slide

426
00:15:47,440 --> 00:15:49,839
so what it does is it

427
00:15:49,839 --> 00:15:51,920
basically reads the instruction from

428
00:15:51,920 --> 00:15:53,360
memory

429
00:15:53,360 --> 00:15:55,199
it checks in uh

430
00:15:55,199 --> 00:15:57,920
checks the first four bits which in arm

431
00:15:57,920 --> 00:16:00,240
is the condition code field and if it's

432
00:16:00,240 --> 00:16:02,000
your x0e

433
00:16:02,000 --> 00:16:04,480
which means always it continues and if

434
00:16:04,480 --> 00:16:06,800
it's not it jumps somewhere to what to

435
00:16:06,800 --> 00:16:08,800
see whether they should continue running

436
00:16:08,800 --> 00:16:10,320
the instruction

437
00:16:10,320 --> 00:16:11,839
um

438
00:16:11,839 --> 00:16:13,360
so when we get to that point it

439
00:16:13,360 --> 00:16:16,160
concatenates the bits 20 to 27

440
00:16:16,160 --> 00:16:18,399
with bits four to seven

441
00:16:18,399 --> 00:16:20,800
and then uses that as an index into the

442
00:16:20,800 --> 00:16:22,560
instruction table

443
00:16:22,560 --> 00:16:25,120
which is shown on the right

444
00:16:25,120 --> 00:16:26,079
and

445
00:16:26,079 --> 00:16:28,639
you can see it's just filled with

446
00:16:28,639 --> 00:16:32,079
function pointers addresses

447
00:16:32,240 --> 00:16:35,120
so for example our move r0r1 instruction

448
00:16:35,120 --> 00:16:37,279
and arm looks like that and when you do

449
00:16:37,279 --> 00:16:40,880
the math you get an index of 0x181

450
00:16:40,880 --> 00:16:42,160
and after you're doing some more

451
00:16:42,160 --> 00:16:44,160
calculation you find that the

452
00:16:44,160 --> 00:16:46,399
instruction handler for the move

453
00:16:46,399 --> 00:16:50,480
instruction is at 4bc004

454
00:16:50,480 --> 00:16:52,399
and just to show you what it looks like

455
00:16:52,399 --> 00:16:54,800
at 4bc04

456
00:16:54,800 --> 00:16:56,399
we have the function pointer to

457
00:16:56,399 --> 00:16:58,560
instruction move 1 and on the right side

458
00:16:58,560 --> 00:17:01,599
is giga's

459
00:17:02,160 --> 00:17:05,679
decompiled function

460
00:17:05,679 --> 00:17:06,880
um

461
00:17:06,880 --> 00:17:10,079
yeah so somewhere in there there is uh

462
00:17:10,079 --> 00:17:11,839
there's some code that moves register

463
00:17:11,839 --> 00:17:15,679
values around around like line 22 and 27

464
00:17:15,679 --> 00:17:18,720
but you also notice that

465
00:17:18,720 --> 00:17:20,880
each instruction handler takes two

466
00:17:20,880 --> 00:17:22,640
parameters the first is the instruction

467
00:17:22,640 --> 00:17:24,799
itself so it could decode the rest of

468
00:17:24,799 --> 00:17:26,799
the fields from it

469
00:17:26,799 --> 00:17:28,400
and the second

470
00:17:28,400 --> 00:17:30,840
argument is the processor state

471
00:17:30,840 --> 00:17:32,559
struct

472
00:17:32,559 --> 00:17:34,320
and

473
00:17:34,320 --> 00:17:35,840
so yeah that's where all the register

474
00:17:35,840 --> 00:17:37,280
values are stored so let's talk about

475
00:17:37,280 --> 00:17:38,880
that

476
00:17:38,880 --> 00:17:40,799
the processor state struct stores the

477
00:17:40,799 --> 00:17:42,960
arm registers as well as other important

478
00:17:42,960 --> 00:17:44,480
processor states

479
00:17:44,480 --> 00:17:45,200
so

480
00:17:45,200 --> 00:17:47,520
that was what i was able to reverse from

481
00:17:47,520 --> 00:17:50,000
look looking at the labrudini binary but

482
00:17:50,000 --> 00:17:52,480
you could see like the first 64 bytes

483
00:17:52,480 --> 00:17:55,520
are used to store the 16 registers of

484
00:17:55,520 --> 00:17:56,640
arm

485
00:17:56,640 --> 00:17:58,160
there is also a field that tells it

486
00:17:58,160 --> 00:18:01,520
whether it's in thomas mode or not

487
00:18:01,520 --> 00:18:02,799
and there's some other things that i

488
00:18:02,799 --> 00:18:03,679
don't

489
00:18:03,679 --> 00:18:06,240
really know what they do

490
00:18:06,240 --> 00:18:08,480
so

491
00:18:09,120 --> 00:18:10,640
since this keeps track of the process

492
00:18:10,640 --> 00:18:11,440
state

493
00:18:11,440 --> 00:18:12,640
if we

494
00:18:12,640 --> 00:18:14,799
know where it is we would be able to

495
00:18:14,799 --> 00:18:17,200
read and write to it and which means we

496
00:18:17,200 --> 00:18:19,760
could change register values or for

497
00:18:19,760 --> 00:18:21,679
example if we change r15 which is a

498
00:18:21,679 --> 00:18:23,360
program counter for arm

499
00:18:23,360 --> 00:18:24,799
and if you change the value it would

500
00:18:24,799 --> 00:18:27,039
switch execution to a different location

501
00:18:27,039 --> 00:18:30,960
so syscalls are up next um how does sys

502
00:18:30,960 --> 00:18:32,000
calls work

503
00:18:32,000 --> 00:18:34,640
um it works just like any other uh

504
00:18:34,640 --> 00:18:36,960
instruction decoding so just like

505
00:18:36,960 --> 00:18:39,440
previously it sees a syscall instruction

506
00:18:39,440 --> 00:18:40,720
it will go to the instruction table and

507
00:18:40,720 --> 00:18:42,640
jump to the right handler and this is

508
00:18:42,640 --> 00:18:47,039
actually where the system handlers begin

509
00:18:47,039 --> 00:18:49,840
and they also follow the same

510
00:18:49,840 --> 00:18:51,360
form function

511
00:18:51,360 --> 00:18:53,039
prototype so it takes the instruction

512
00:18:53,039 --> 00:18:54,080
the

513
00:18:54,080 --> 00:18:55,120
itself

514
00:18:55,120 --> 00:18:58,880
and the pointer to the processor state

515
00:18:58,880 --> 00:19:00,240
but you might notice that it actually

516
00:19:00,240 --> 00:19:03,039
does not issue a x86 test call here

517
00:19:03,039 --> 00:19:05,039
directly

518
00:19:05,039 --> 00:19:07,600
it only sets the svc number field with

519
00:19:07,600 --> 00:19:09,280
the syscall number

520
00:19:09,280 --> 00:19:11,600
and the actual syscall is made further

521
00:19:11,600 --> 00:19:14,080
along the uh execution

522
00:19:14,080 --> 00:19:15,360
in the

523
00:19:15,360 --> 00:19:17,280
the while loop

524
00:19:17,280 --> 00:19:19,600
um

525
00:19:19,760 --> 00:19:20,799
yeah

526
00:19:20,799 --> 00:19:21,520
so

527
00:19:21,520 --> 00:19:23,120
while most of the syscalls are simple

528
00:19:23,120 --> 00:19:26,320
enough and they're just wrapped and

529
00:19:26,320 --> 00:19:29,120
re-performed in x86

530
00:19:29,120 --> 00:19:30,160
we

531
00:19:30,160 --> 00:19:31,120
thought

532
00:19:31,120 --> 00:19:33,919
one specific syscall was of interest and

533
00:19:33,919 --> 00:19:36,320
that is the clones this call

534
00:19:36,320 --> 00:19:39,039
and i also wrote a fork because nowadays

535
00:19:39,039 --> 00:19:41,919
you use fork it goes to lip c1 with

536
00:19:41,919 --> 00:19:43,520
lipsy fork

537
00:19:43,520 --> 00:19:44,400
which

538
00:19:44,400 --> 00:19:47,840
does a clone syscall instead

539
00:19:47,840 --> 00:19:49,919
so we want to see how that worked

540
00:19:49,919 --> 00:19:53,120
and as i mentioned like

541
00:19:53,120 --> 00:19:55,520
uh arm syscalls are intercepted and

542
00:19:55,520 --> 00:19:58,559
handled by lipoutini in x86

543
00:19:58,559 --> 00:20:02,000
so for clone it clones the process in

544
00:20:02,000 --> 00:20:04,799
x86 and then

545
00:20:04,799 --> 00:20:07,039
each the child and the parent handles

546
00:20:07,039 --> 00:20:08,080
the

547
00:20:08,080 --> 00:20:11,440
logic to convert it you know back into

548
00:20:11,440 --> 00:20:14,159
how the arm would see it

549
00:20:14,159 --> 00:20:17,200
and clone actually takes an argument

550
00:20:17,200 --> 00:20:19,200
called child stack so you could give it

551
00:20:19,200 --> 00:20:20,400
a memory buffer

552
00:20:20,400 --> 00:20:21,760
memory pointer

553
00:20:21,760 --> 00:20:23,840
and tell the kernel to use this as a

554
00:20:23,840 --> 00:20:25,039
child stack

555
00:20:25,039 --> 00:20:26,400
and this is actually not passed to

556
00:20:26,400 --> 00:20:27,760
kernel directly

557
00:20:27,760 --> 00:20:29,120
because

558
00:20:29,120 --> 00:20:31,679
um the top of the dot child stack is the

559
00:20:31,679 --> 00:20:34,080
return address so if you if we if

560
00:20:34,080 --> 00:20:36,320
lipoedini gave the memory that arm

561
00:20:36,320 --> 00:20:39,039
provided directly to the x86 kernel

562
00:20:39,039 --> 00:20:40,400
it would return

563
00:20:40,400 --> 00:20:42,640
to an arm address which it won't be able

564
00:20:42,640 --> 00:20:43,679
to run

565
00:20:43,679 --> 00:20:47,120
so instead liputini creates an rwx page

566
00:20:47,120 --> 00:20:51,120
and passes that as a child stack

567
00:20:52,320 --> 00:20:54,400
so now we have an insight somewhat

568
00:20:54,400 --> 00:20:56,240
inside of how the emulator works

569
00:20:56,240 --> 00:20:58,320
internally

570
00:20:58,320 --> 00:20:59,840
we could try to do some fun things with

571
00:20:59,840 --> 00:21:02,480
it for example if we we could try to see

572
00:21:02,480 --> 00:21:04,480
if whether our code is running under the

573
00:21:04,480 --> 00:21:07,280
houdini or not um and try to check that

574
00:21:07,280 --> 00:21:09,039
we could check for the host processor

575
00:21:09,039 --> 00:21:10,400
right because we'll be running in our

576
00:21:10,400 --> 00:21:11,520
arm

577
00:21:11,520 --> 00:21:14,000
code but if we want to see if it's

578
00:21:14,000 --> 00:21:15,760
running under houdini you could check

579
00:21:15,760 --> 00:21:17,679
the host processor architecture and you

580
00:21:17,679 --> 00:21:19,760
could do it from java using like

581
00:21:19,760 --> 00:21:22,000
osr to get property or by reading the

582
00:21:22,000 --> 00:21:24,000
prox cpu info

583
00:21:24,000 --> 00:21:25,679
but this will actually not work because

584
00:21:25,679 --> 00:21:27,360
houdini hides this

585
00:21:27,360 --> 00:21:28,880
and

586
00:21:28,880 --> 00:21:30,559
i'll albeit not very well and you

587
00:21:30,559 --> 00:21:32,320
actually might be able to tell because

588
00:21:32,320 --> 00:21:34,159
if you look carefully the os arch

589
00:21:34,159 --> 00:21:36,320
properties has rnv7l

590
00:21:36,320 --> 00:21:38,799
which is not what the cpu info says

591
00:21:38,799 --> 00:21:42,000
which says it's rnv8 processor rev1

592
00:21:42,000 --> 00:21:45,120
arc64 with the hardware serial number of

593
00:21:45,120 --> 00:21:47,840
or hardware version of placeholder

594
00:21:47,840 --> 00:21:50,158
um

595
00:21:50,720 --> 00:21:51,800
great um

596
00:21:51,800 --> 00:21:53,120
[Music]

597
00:21:53,120 --> 00:21:55,520
so another thing we could do is also uh

598
00:21:55,520 --> 00:21:58,880
check the memory maps

599
00:21:58,880 --> 00:22:01,039
one to check if lipodenia is loaded and

600
00:22:01,039 --> 00:22:03,840
two to see if there's both arm and x86

601
00:22:03,840 --> 00:22:07,199
binaries going on in there

602
00:22:07,360 --> 00:22:09,840
however we think the best

603
00:22:09,840 --> 00:22:13,600
way to do this is quietly because all

604
00:22:13,600 --> 00:22:15,840
the methods we mentioned above required

605
00:22:15,840 --> 00:22:17,919
use of some syscall like opening these

606
00:22:17,919 --> 00:22:19,520
files or doing some

607
00:22:19,520 --> 00:22:23,360
memory mapping related assist calls

608
00:22:23,360 --> 00:22:24,320
so

609
00:22:24,320 --> 00:22:26,640
the best implementation is one that's

610
00:22:26,640 --> 00:22:27,919
quiet and

611
00:22:27,919 --> 00:22:29,280
hard to detect

612
00:22:29,280 --> 00:22:31,200
and we came up with one way

613
00:22:31,200 --> 00:22:34,000
um and because i i mentioned previously

614
00:22:34,000 --> 00:22:35,200
um

615
00:22:35,200 --> 00:22:39,600
lipodini provides a fake arm jni vamp

616
00:22:39,600 --> 00:22:40,480
pointer

617
00:22:40,480 --> 00:22:42,559
which has trap instructions

618
00:22:42,559 --> 00:22:44,080
we could try to read that instruction

619
00:22:44,080 --> 00:22:46,400
and see if it's a valid arm instruction

620
00:22:46,400 --> 00:22:47,360
or

621
00:22:47,360 --> 00:22:51,199
also valid but it's a trap instruction

622
00:22:51,440 --> 00:22:52,720
another fun thing we could do with

623
00:22:52,720 --> 00:22:56,240
houdini is we could try to escape to x86

624
00:22:56,240 --> 00:22:58,080
because it is a

625
00:22:58,080 --> 00:23:01,039
fake virtual

626
00:23:01,039 --> 00:23:03,360
emulator right so

627
00:23:03,360 --> 00:23:04,400
their now

628
00:23:04,400 --> 00:23:07,280
container break out is pretty popular so

629
00:23:07,280 --> 00:23:08,880
we could try to see if we could break

630
00:23:08,880 --> 00:23:10,320
out of x86

631
00:23:10,320 --> 00:23:12,240
and we could do it a few ways and one

632
00:23:12,240 --> 00:23:13,600
way would be

633
00:23:13,600 --> 00:23:16,799
calling and protect and overriding code

634
00:23:16,799 --> 00:23:19,120
so we have an executable

635
00:23:19,120 --> 00:23:20,480
memory

636
00:23:20,480 --> 00:23:22,960
however this is not subtle again because

637
00:23:22,960 --> 00:23:25,360
we're using a syscall and

638
00:23:25,360 --> 00:23:27,200
i mean if you're doing analysis on these

639
00:23:27,200 --> 00:23:29,679
apps some some process calls and protect

640
00:23:29,679 --> 00:23:32,159
and you might be suspicious of it

641
00:23:32,159 --> 00:23:34,400
so without doing that we could also do

642
00:23:34,400 --> 00:23:37,600
x86 stack manipulations um we could try

643
00:23:37,600 --> 00:23:39,840
to find the stack and clobber with raw

644
00:23:39,840 --> 00:23:40,960
payloads

645
00:23:40,960 --> 00:23:42,960
um we could try to overwrite the return

646
00:23:42,960 --> 00:23:44,640
address function pointer

647
00:23:44,640 --> 00:23:46,960
but the hard part would be to

648
00:23:46,960 --> 00:23:48,880
you know getting the raw payload finding

649
00:23:48,880 --> 00:23:51,120
the drop chains or finding our

650
00:23:51,120 --> 00:23:54,320
executable page to run in

651
00:23:55,279 --> 00:23:57,840
this is not an issue because the houdini

652
00:23:57,840 --> 00:23:59,600
provides

653
00:23:59,600 --> 00:24:00,880
if you notice

654
00:24:00,880 --> 00:24:02,480
if you were

655
00:24:02,480 --> 00:24:03,600
if you look carefully in the previous

656
00:24:03,600 --> 00:24:04,799
slide there were also there were

657
00:24:04,799 --> 00:24:06,720
actually multiple read write execute

658
00:24:06,720 --> 00:24:07,760
pages

659
00:24:07,760 --> 00:24:10,000
um which means you could write code to

660
00:24:10,000 --> 00:24:12,000
it and just jump to it

661
00:24:12,000 --> 00:24:16,000
um in x86 you would uh

662
00:24:16,000 --> 00:24:18,480
yeah just to show what some of these

663
00:24:18,480 --> 00:24:21,440
other pages are being used for um this

664
00:24:21,440 --> 00:24:24,960
memory region contains our fake

665
00:24:24,960 --> 00:24:27,840
arm jnim

666
00:24:28,559 --> 00:24:30,400
arm jni instruct

667
00:24:30,400 --> 00:24:34,559
and this address is used for arm stack

668
00:24:34,559 --> 00:24:36,159
so going back to the read write execute

669
00:24:36,159 --> 00:24:38,000
pages um

670
00:24:38,000 --> 00:24:39,440
we could write code too and jump to it

671
00:24:39,440 --> 00:24:41,760
and if you're in x86 you still have to

672
00:24:41,760 --> 00:24:43,520
figure out how to get our program

673
00:24:43,520 --> 00:24:45,919
counter or instruction pointer to go to

674
00:24:45,919 --> 00:24:47,520
the actual address

675
00:24:47,520 --> 00:24:50,000
but since we have executable pages

676
00:24:50,000 --> 00:24:52,480
but on arm we we're running arm code so

677
00:24:52,480 --> 00:24:54,559
we could just jump to it

678
00:24:54,559 --> 00:24:57,039
um the harder problem might be trying to

679
00:24:57,039 --> 00:25:00,400
find the red drive execute pages

680
00:25:00,400 --> 00:25:02,480
this is also not an issue because

681
00:25:02,480 --> 00:25:04,720
apparently houdini does not care about

682
00:25:04,720 --> 00:25:07,520
the execute

683
00:25:08,320 --> 00:25:10,080
this makes sense as an interpreter

684
00:25:10,080 --> 00:25:11,200
because

685
00:25:11,200 --> 00:25:12,960
libridini's interpreter

686
00:25:12,960 --> 00:25:14,640
and

687
00:25:14,640 --> 00:25:16,880
it treats the instructions as the or to

688
00:25:16,880 --> 00:25:17,760
it

689
00:25:17,760 --> 00:25:20,640
instructions are to the host just data

690
00:25:20,640 --> 00:25:22,799
so as an interpreter if you can read the

691
00:25:22,799 --> 00:25:24,880
data it will read the instructions it

692
00:25:24,880 --> 00:25:26,320
will run them

693
00:25:26,320 --> 00:25:27,200
so

694
00:25:27,200 --> 00:25:29,200
therefore the arm libraries themselves

695
00:25:29,200 --> 00:25:31,200
are not loaded with the execute bit set

696
00:25:31,200 --> 00:25:32,640
on their pages

697
00:25:32,640 --> 00:25:34,240
so as you can imagine this is pretty

698
00:25:34,240 --> 00:25:36,320
trivial to abuse i just write code

699
00:25:36,320 --> 00:25:39,120
anywhere and jump to it

700
00:25:39,120 --> 00:25:41,440
and here is my proof concept for running

701
00:25:41,440 --> 00:25:43,279
it on a the

702
00:25:43,279 --> 00:25:45,360
executable version of houdini

703
00:25:45,360 --> 00:25:48,799
so in main i allocate some memory um

704
00:25:48,799 --> 00:25:50,080
actually the first version of this code

705
00:25:50,080 --> 00:25:51,840
i wrote it was not on stack it was on

706
00:25:51,840 --> 00:25:53,039
the um

707
00:25:53,039 --> 00:25:55,360
and uninternalized is that on

708
00:25:55,360 --> 00:25:56,720
the heap or

709
00:25:56,720 --> 00:25:57,840
it was in an

710
00:25:57,840 --> 00:26:00,960
an uninitialized data section

711
00:26:00,960 --> 00:26:04,320
and i write some instructions to it and

712
00:26:04,320 --> 00:26:05,840
this specifically adds

713
00:26:05,840 --> 00:26:09,760
r0 1 to r0 and then returns

714
00:26:09,760 --> 00:26:11,520
and then i cast it to function pointers

715
00:26:11,520 --> 00:26:13,679
and then call it

716
00:26:13,679 --> 00:26:16,880
so under on real armed devices

717
00:26:16,880 --> 00:26:18,799
this would cause a set fall because you

718
00:26:18,799 --> 00:26:20,080
should not be able to execute from the

719
00:26:20,080 --> 00:26:21,520
stack

720
00:26:21,520 --> 00:26:22,640
or the heap

721
00:26:22,640 --> 00:26:24,640
given that their proper protection is in

722
00:26:24,640 --> 00:26:25,679
place

723
00:26:25,679 --> 00:26:27,840
but if you run it through the houdini

724
00:26:27,840 --> 00:26:30,080
you can see on the bottom they ran just

725
00:26:30,080 --> 00:26:32,080
fine

726
00:26:32,080 --> 00:26:35,520
and i for the lid houdini version

727
00:26:35,520 --> 00:26:37,760
i have some demos including some of the

728
00:26:37,760 --> 00:26:40,159
things i talked about earlier

729
00:26:40,159 --> 00:26:41,440
so

730
00:26:41,440 --> 00:26:43,440
this is on the chromebook

731
00:26:43,440 --> 00:26:46,480
and i built an app that's houdini tools

732
00:26:46,480 --> 00:26:50,159
for both arm and x86 versions on it

733
00:26:50,159 --> 00:26:52,400
they're built off of the same code

734
00:26:52,400 --> 00:26:53,679
um it just i

735
00:26:53,679 --> 00:26:56,080
set it so that it builds them separately

736
00:26:56,080 --> 00:26:58,000
for different architectures

737
00:26:58,000 --> 00:27:00,080
so on the top is our x86 build and on

738
00:27:00,080 --> 00:27:03,360
the bottom is our arm build and on x86

739
00:27:03,360 --> 00:27:07,840
we see the cpu info um

740
00:27:07,840 --> 00:27:10,320
the screen we saw or it reports normally

741
00:27:10,320 --> 00:27:12,320
right we have our gender and intel and

742
00:27:12,320 --> 00:27:15,120
the top it says i-686 from system get

743
00:27:15,120 --> 00:27:17,039
property

744
00:27:17,039 --> 00:27:18,880
now on the bottom

745
00:27:18,880 --> 00:27:21,279
we saw basically what we saw earlier

746
00:27:21,279 --> 00:27:24,880
osrt says armv7 and when we read prox

747
00:27:24,880 --> 00:27:30,320
cpu info it says rv8 which is not rv7

748
00:27:30,799 --> 00:27:34,320
and hardware placeholder

749
00:27:34,320 --> 00:27:37,840
so the second tab demonstrates the uh

750
00:27:37,840 --> 00:27:39,679
detection method we could use one

751
00:27:39,679 --> 00:27:40,960
possible detection method we could use

752
00:27:40,960 --> 00:27:44,159
by using the jni m function pointers

753
00:27:44,159 --> 00:27:45,600
so when i click fetch all it would

754
00:27:45,600 --> 00:27:48,159
actually from the native side return the

755
00:27:48,159 --> 00:27:50,000
addresses of n

756
00:27:50,000 --> 00:27:51,039
and m

757
00:27:51,039 --> 00:27:52,799
get version function pointer and the

758
00:27:52,799 --> 00:27:54,080
bottom tool will

759
00:27:54,080 --> 00:27:57,678
dereference that function pointer as

760
00:27:58,640 --> 00:28:00,399
double words

761
00:28:00,399 --> 00:28:02,799
so we see that on x86

762
00:28:02,799 --> 00:28:04,480
um when we dereference the function

763
00:28:04,480 --> 00:28:07,520
point nerd it looks like there are

764
00:28:07,520 --> 00:28:09,520
some push instructions

765
00:28:09,520 --> 00:28:10,960
as you would often see in the beginning

766
00:28:10,960 --> 00:28:13,520
of a function

767
00:28:13,679 --> 00:28:17,640
but when we try this on

768
00:28:18,240 --> 00:28:21,440
yeah when we try this on the arm version

769
00:28:21,440 --> 00:28:23,760
we actually get

770
00:28:23,760 --> 00:28:25,840
we also get value instructions under get

771
00:28:25,840 --> 00:28:28,000
version and get call static and method

772
00:28:28,000 --> 00:28:30,320
but they're not they they're they are

773
00:28:30,320 --> 00:28:32,240
the system system called trap

774
00:28:32,240 --> 00:28:34,799
instructions uh denoted by ef and the

775
00:28:34,799 --> 00:28:37,440
number follows it is the actual syscall

776
00:28:37,440 --> 00:28:39,760
number

777
00:28:42,840 --> 00:28:44,399
oops

778
00:28:44,399 --> 00:28:46,960
and the third tab is just a tool um

779
00:28:46,960 --> 00:28:49,919
utility that's useful and it reads

780
00:28:49,919 --> 00:28:52,559
uh proc self maps to see what's loaded

781
00:28:52,559 --> 00:28:55,120
in there so x86 there is no like the

782
00:28:55,120 --> 00:28:56,799
predini

783
00:28:56,799 --> 00:28:58,640
loaded this is filtered because there's

784
00:28:58,640 --> 00:29:00,640
way too much stuff in there but there's

785
00:29:00,640 --> 00:29:03,440
no lip houdini loaded on and in if you

786
00:29:03,440 --> 00:29:04,720
read the maps

787
00:29:04,720 --> 00:29:06,240
you could see there's

788
00:29:06,240 --> 00:29:08,799
lee houdini loaded in there as well as

789
00:29:08,799 --> 00:29:10,159
um

790
00:29:10,159 --> 00:29:12,559
a bunch of arm libraries

791
00:29:12,559 --> 00:29:13,520
uh

792
00:29:13,520 --> 00:29:14,960
i'm having a little trouble finding it

793
00:29:14,960 --> 00:29:17,120
here uh

794
00:29:17,120 --> 00:29:18,799
right there's the arm library and then

795
00:29:18,799 --> 00:29:20,799
i'm like where's lippidini

796
00:29:20,799 --> 00:29:24,880
and then i find it here right there

797
00:29:24,880 --> 00:29:26,720
right

798
00:29:26,720 --> 00:29:27,440
so

799
00:29:27,440 --> 00:29:28,559
the last

800
00:29:28,559 --> 00:29:30,559
tab is our font tab

801
00:29:30,559 --> 00:29:31,520
so

802
00:29:31,520 --> 00:29:34,080
i built this little layout um

803
00:29:34,080 --> 00:29:35,279
where the left side will be the

804
00:29:35,279 --> 00:29:36,720
instruction i want to run and the right

805
00:29:36,720 --> 00:29:38,840
side will be the

806
00:29:38,840 --> 00:29:42,480
uh the result when you run the code and

807
00:29:42,480 --> 00:29:45,520
all it does is it it

808
00:29:45,600 --> 00:29:48,080
it pushes the bytes on the left side

809
00:29:48,080 --> 00:29:51,039
onto the stack or actually in in in on

810
00:29:51,039 --> 00:29:52,880
the heap on the native side and then

811
00:29:52,880 --> 00:29:55,600
jumps to it so

812
00:29:55,600 --> 00:29:57,039
and i i didn't want to remember all the

813
00:29:57,039 --> 00:29:59,600
op codes so it's i put some buttons in

814
00:29:59,600 --> 00:30:01,600
there to fill it in

815
00:30:01,600 --> 00:30:02,399
um

816
00:30:02,399 --> 00:30:04,960
so this would obviously not work because

817
00:30:04,960 --> 00:30:06,559
this does not have lip houdini loaded

818
00:30:06,559 --> 00:30:08,399
and it it's at and

819
00:30:08,399 --> 00:30:09,600
x86

820
00:30:09,600 --> 00:30:10,880
so it crashed

821
00:30:10,880 --> 00:30:12,880
and that is what would happen on real

822
00:30:12,880 --> 00:30:14,159
arm devices as well because it's going

823
00:30:14,159 --> 00:30:17,120
to try to execute from the heap

824
00:30:17,120 --> 00:30:19,440
but when you have a system

825
00:30:19,440 --> 00:30:20,399
running

826
00:30:20,399 --> 00:30:22,399
on x86

827
00:30:22,399 --> 00:30:24,000
that's running arm native code with lip

828
00:30:24,000 --> 00:30:25,120
houdini

829
00:30:25,120 --> 00:30:26,559
this

830
00:30:26,559 --> 00:30:28,799
works and when i click run

831
00:30:28,799 --> 00:30:31,679
um it incremented the five

832
00:30:31,679 --> 00:30:32,720
um

833
00:30:32,720 --> 00:30:34,960
so yeah i you can see the actual bytes

834
00:30:34,960 --> 00:30:39,840
here e2 8 blah blah one which is arm for

835
00:30:39,840 --> 00:30:42,080
add r0 or zero one so that increments

836
00:30:42,080 --> 00:30:44,000
one and returns which is why i named the

837
00:30:44,000 --> 00:30:46,159
increment

838
00:30:46,159 --> 00:30:48,480
the second um and yeah i could change

839
00:30:48,480 --> 00:30:50,799
the the value i call the function with

840
00:30:50,799 --> 00:30:53,919
with r0 r1r2 and the second one adds the

841
00:30:53,919 --> 00:30:56,240
two integers numbers together seven and

842
00:30:56,240 --> 00:30:58,559
two i get nine the second one is

843
00:30:58,559 --> 00:30:59,519
the third

844
00:30:59,519 --> 00:31:02,480
tab third program is multiply so it

845
00:31:02,480 --> 00:31:06,080
multiplies r1 and r2 and adds it to r0

846
00:31:06,080 --> 00:31:11,039
so in this case would be 20 90 97 right

847
00:31:11,039 --> 00:31:13,360
and the last program i prepared is the

848
00:31:13,360 --> 00:31:16,000
get sp which would just return the stack

849
00:31:16,000 --> 00:31:18,640
pointer from the arm side

850
00:31:18,640 --> 00:31:20,159
and takes no parameters so it doesn't

851
00:31:20,159 --> 00:31:23,200
really matter and that is the stack

852
00:31:23,200 --> 00:31:26,640
address of the arm

853
00:31:26,640 --> 00:31:28,880
processor

854
00:31:28,880 --> 00:31:30,720
now just to show that this is actually

855
00:31:30,720 --> 00:31:33,200
you know um

856
00:31:33,200 --> 00:31:34,640
being sent into the native code and

857
00:31:34,640 --> 00:31:36,640
written to the to memory and being

858
00:31:36,640 --> 00:31:39,440
executed you could just change it i i

859
00:31:39,440 --> 00:31:41,200
wrote it so that you you could actually

860
00:31:41,200 --> 00:31:43,360
type in real bytes and it would pass it

861
00:31:43,360 --> 00:31:45,200
and write to memory and jump to it so if

862
00:31:45,200 --> 00:31:47,279
i change it to f which should be the r15

863
00:31:47,279 --> 00:31:49,360
which is the program counter for arm it

864
00:31:49,360 --> 00:31:51,519
would give me where the function

865
00:31:51,519 --> 00:31:54,000
itself is located where it's executing

866
00:31:54,000 --> 00:31:55,440
so yeah it is changing around a little

867
00:31:55,440 --> 00:31:56,880
bit because

868
00:31:56,880 --> 00:31:57,919
this is not on the stack this is

869
00:31:57,919 --> 00:32:00,720
actually on the heap so malloc and free

870
00:32:00,720 --> 00:32:01,840
so it's going to change around a little

871
00:32:01,840 --> 00:32:02,640
bit

872
00:32:02,640 --> 00:32:04,000
but you can see that when i change the

873
00:32:04,000 --> 00:32:06,640
code it actually returns something i can

874
00:32:06,640 --> 00:32:08,000
show that here instead of incrementing

875
00:32:08,000 --> 00:32:09,840
one i increment two and just happen to

876
00:32:09,840 --> 00:32:12,000
know that's the correct bit to change

877
00:32:12,000 --> 00:32:12,880
um

878
00:32:12,880 --> 00:32:15,519
it the r0 is seven and incremented by

879
00:32:15,519 --> 00:32:17,679
two um and if i want to compare the

880
00:32:17,679 --> 00:32:19,440
incremented by three i could change the

881
00:32:19,440 --> 00:32:21,519
instruction to incremented three and we

882
00:32:21,519 --> 00:32:22,640
get ten

883
00:32:22,640 --> 00:32:24,399
um you could do this multiple times as

884
00:32:24,399 --> 00:32:25,200
well

885
00:32:25,200 --> 00:32:27,440
just to really show that this is the

886
00:32:27,440 --> 00:32:31,120
dynamic code execution

887
00:32:31,519 --> 00:32:34,240
that was a demo

888
00:32:35,919 --> 00:32:38,080
so

889
00:32:38,399 --> 00:32:40,720
what can we do with these fun features

890
00:32:40,720 --> 00:32:44,240
of luputini well

891
00:32:44,480 --> 00:32:46,559
we know that uh

892
00:32:46,559 --> 00:32:48,880
apps are often analyzed by security

893
00:32:48,880 --> 00:32:50,799
researchers and app stores and they

894
00:32:50,799 --> 00:32:52,640
mostly do it in three ways when they run

895
00:32:52,640 --> 00:32:55,120
in sandbox environments

896
00:32:55,120 --> 00:32:56,880
they could do it in real arm devices or

897
00:32:56,880 --> 00:32:58,480
fully virtualized

898
00:32:58,480 --> 00:33:01,519
device environment like chemu or x86

899
00:33:01,519 --> 00:33:04,159
android emulators kind of like vms

900
00:33:04,159 --> 00:33:05,919
so real arm devices will be the best

901
00:33:05,919 --> 00:33:08,320
because it will give you actual

902
00:33:08,320 --> 00:33:10,559
real behavior of how it would work

903
00:33:10,559 --> 00:33:12,399
uh the thing is sometimes it's hard to

904
00:33:12,399 --> 00:33:14,960
instrument and it's it's hard to do at a

905
00:33:14,960 --> 00:33:17,039
larger scale

906
00:33:17,039 --> 00:33:19,360
and the second best option would be

907
00:33:19,360 --> 00:33:20,960
fully virtualize our environments like

908
00:33:20,960 --> 00:33:24,000
chemu but this has a significant

909
00:33:24,000 --> 00:33:25,840
performance hit because you're emulating

910
00:33:25,840 --> 00:33:27,279
the entire stack

911
00:33:27,279 --> 00:33:28,799
the

912
00:33:28,799 --> 00:33:31,279
hardware

913
00:33:31,440 --> 00:33:33,760
the third option would be using

914
00:33:33,760 --> 00:33:37,440
commercial android emulators or like

915
00:33:37,440 --> 00:33:38,480
the

916
00:33:38,480 --> 00:33:40,559
android sdks android emulators which run

917
00:33:40,559 --> 00:33:42,720
on x86

918
00:33:42,720 --> 00:33:44,240
and these

919
00:33:44,240 --> 00:33:46,399
are these also have a performance hit

920
00:33:46,399 --> 00:33:48,080
but not as much as a fully virtualized

921
00:33:48,080 --> 00:33:50,320
one and if you use liphoudini you could

922
00:33:50,320 --> 00:33:51,919
also analyze

923
00:33:51,919 --> 00:33:54,159
arm native code on this while

924
00:33:54,159 --> 00:33:58,080
the android part is x86

925
00:33:58,080 --> 00:33:59,760
so

926
00:33:59,760 --> 00:34:01,200
also note if

927
00:34:01,200 --> 00:34:02,960
if an app expresses different behavior

928
00:34:02,960 --> 00:34:04,480
depending on which one of these

929
00:34:04,480 --> 00:34:06,640
environments it's running on that would

930
00:34:06,640 --> 00:34:09,679
obviously one harder to detect and two

931
00:34:09,679 --> 00:34:11,679
it'd be hard to analyze because you have

932
00:34:11,679 --> 00:34:14,159
inconsistent behavior

933
00:34:14,159 --> 00:34:17,199
so using this what if we could key in

934
00:34:17,199 --> 00:34:18,879
this

935
00:34:18,879 --> 00:34:21,359
method so

936
00:34:21,359 --> 00:34:23,839
what if a malware were to detect whether

937
00:34:23,839 --> 00:34:25,918
it's running on the lipoutini or not and

938
00:34:25,918 --> 00:34:28,639
say if there's no leproudini it comes to

939
00:34:28,639 --> 00:34:30,320
conclusion that it's not under analysis

940
00:34:30,320 --> 00:34:33,359
and starts doing malicious behaviors

941
00:34:33,359 --> 00:34:35,199
and when there is lipidini it thinks

942
00:34:35,199 --> 00:34:37,440
that there is analysis and does not do

943
00:34:37,440 --> 00:34:39,359
any malicious behaviors

944
00:34:39,359 --> 00:34:40,960
so

945
00:34:40,960 --> 00:34:42,800
another example is if you know for a

946
00:34:42,800 --> 00:34:44,639
fact that a certain analysis or a

947
00:34:44,639 --> 00:34:45,839
certain

948
00:34:45,839 --> 00:34:48,480
app store or whatever is using one of

949
00:34:48,480 --> 00:34:50,000
these methods

950
00:34:50,000 --> 00:34:52,399
to analyze the apps you can use that as

951
00:34:52,399 --> 00:34:55,040
fingerprinting

952
00:34:56,079 --> 00:34:57,839
conversely

953
00:34:57,839 --> 00:35:00,640
on a malware could be

954
00:35:00,640 --> 00:35:04,000
could be running malicious

955
00:35:04,000 --> 00:35:07,440
behaviors when it detects leboudini so

956
00:35:07,440 --> 00:35:09,200
that it could use

957
00:35:09,200 --> 00:35:11,920
abuse the lebrodini to further obfuscate

958
00:35:11,920 --> 00:35:13,800
itself using the fun features that i

959
00:35:13,800 --> 00:35:16,800
demonstrated um so for example we don't

960
00:35:16,800 --> 00:35:18,880
know what the play store uses nowadays

961
00:35:18,880 --> 00:35:20,800
but it does not seem like they're using

962
00:35:20,800 --> 00:35:22,320
um

963
00:35:22,320 --> 00:35:23,839
it's it does not seem like it doesn't

964
00:35:23,839 --> 00:35:25,200
seem like they're uh

965
00:35:25,200 --> 00:35:28,720
running the arm apks on x836 devices

966
00:35:28,720 --> 00:35:30,560
lip houdini so

967
00:35:30,560 --> 00:35:32,240
this would be a use case for something

968
00:35:32,240 --> 00:35:34,560
like that

969
00:35:37,680 --> 00:35:38,800
yeah

970
00:35:38,800 --> 00:35:40,960
so with all these issues

971
00:35:40,960 --> 00:35:43,119
we have some recommendations to

972
00:35:43,119 --> 00:35:45,040
vendors and platforms

973
00:35:45,040 --> 00:35:47,119
first of all drop the unnecessary rwx

974
00:35:47,119 --> 00:35:48,560
pages

975
00:35:48,560 --> 00:35:52,560
because that would not itself give

976
00:35:53,119 --> 00:35:54,960
give it access to run code but it would

977
00:35:54,960 --> 00:35:57,119
make it easier once you figure out how

978
00:35:57,119 --> 00:35:58,480
so

979
00:35:58,480 --> 00:36:00,640
if it's really necessary

980
00:36:00,640 --> 00:36:04,560
perform a finer page permission control

981
00:36:04,560 --> 00:36:06,320
implement an efficient

982
00:36:06,320 --> 00:36:07,440
nx

983
00:36:07,440 --> 00:36:10,560
slash userline page table implementation

984
00:36:10,560 --> 00:36:11,520
and

985
00:36:11,520 --> 00:36:13,440
we understand checking the page table

986
00:36:13,440 --> 00:36:15,280
every time an instruction is loaded

987
00:36:15,280 --> 00:36:17,760
would incur a significant overhead so

988
00:36:17,760 --> 00:36:20,480
instead what we recommend is you keep

989
00:36:20,480 --> 00:36:22,400
track of the page mappings in process in

990
00:36:22,400 --> 00:36:25,040
a data structure and perform checks only

991
00:36:25,040 --> 00:36:27,760
if the instruction currently running

992
00:36:27,760 --> 00:36:30,000
is in a different page than the

993
00:36:30,000 --> 00:36:33,200
instruction that ran previously

994
00:36:33,200 --> 00:36:34,560
and lastly if you're going to go through

995
00:36:34,560 --> 00:36:36,000
all this you might as well use

996
00:36:36,000 --> 00:36:38,720
virtualization which has all the

997
00:36:38,720 --> 00:36:40,560
pretty efficient

998
00:36:40,560 --> 00:36:42,640
implementation of the nx bit and the

999
00:36:42,640 --> 00:36:44,800
page table implementation

1000
00:36:44,800 --> 00:36:46,960
so we'll actually discuss how actually

1001
00:36:46,960 --> 00:36:48,880
we could actually implement the

1002
00:36:48,880 --> 00:36:50,720
user land page table and the annex bit

1003
00:36:50,720 --> 00:36:53,359
implementation

1004
00:36:53,440 --> 00:36:55,839
this could be done a couple ways one we

1005
00:36:55,839 --> 00:36:58,400
only trust the executable section on

1006
00:36:58,400 --> 00:36:59,280
load

1007
00:36:59,280 --> 00:37:01,200
um

1008
00:37:01,200 --> 00:37:02,720
fairly obvious

1009
00:37:02,720 --> 00:37:03,760
two

1010
00:37:03,760 --> 00:37:05,040
we

1011
00:37:05,040 --> 00:37:07,200
whenever we load a new page we check

1012
00:37:07,200 --> 00:37:09,920
from uh or execute from a new page we

1013
00:37:09,920 --> 00:37:12,480
check proc self maps and then

1014
00:37:12,480 --> 00:37:13,920
add that into the data structure for

1015
00:37:13,920 --> 00:37:15,599
caching

1016
00:37:15,599 --> 00:37:17,599
and three we could um

1017
00:37:17,599 --> 00:37:21,200
in libradini we could for example

1018
00:37:21,200 --> 00:37:23,040
you could have functionality in map and

1019
00:37:23,040 --> 00:37:25,760
protect to track the syst permissions

1020
00:37:25,760 --> 00:37:28,640
um so when a program calls map with

1021
00:37:28,640 --> 00:37:31,200
execute permission um it does the map

1022
00:37:31,200 --> 00:37:32,960
but also keeps adds it to this data

1023
00:37:32,960 --> 00:37:34,720
structure where it's

1024
00:37:34,720 --> 00:37:38,320
set as execute or not execute

1025
00:37:38,320 --> 00:37:41,040
but the ideal solution combines

1026
00:37:41,040 --> 00:37:43,040
the number two and number three

1027
00:37:43,040 --> 00:37:45,359
with the number two checked performed as

1028
00:37:45,359 --> 00:37:48,240
a catch-all kind of and this also has

1029
00:37:48,240 --> 00:37:50,880
extra benefits which is it now it can

1030
00:37:50,880 --> 00:37:53,040
now support dynamic straight object

1031
00:37:53,040 --> 00:37:54,880
loading via dl open

1032
00:37:54,880 --> 00:37:56,000
um

1033
00:37:56,000 --> 00:37:58,079
because dl open would do that and deal

1034
00:37:58,079 --> 00:37:59,920
open would run and it would do all the

1035
00:37:59,920 --> 00:38:02,720
sys calls and though it's

1036
00:38:02,720 --> 00:38:04,720
basically you've implemented a page

1037
00:38:04,720 --> 00:38:07,040
table in user space and

1038
00:38:07,040 --> 00:38:08,079
uh

1039
00:38:08,079 --> 00:38:09,280
yeah

1040
00:38:09,280 --> 00:38:10,800
the second thing is

1041
00:38:10,800 --> 00:38:13,200
because it also works normally now with

1042
00:38:13,200 --> 00:38:15,440
proper protection you could also

1043
00:38:15,440 --> 00:38:17,040
you could now

1044
00:38:17,040 --> 00:38:18,560
support legitimate just-in-time

1045
00:38:18,560 --> 00:38:21,440
compilation and obviously after

1046
00:38:21,440 --> 00:38:23,280
it's done running the

1047
00:38:23,280 --> 00:38:25,760
output code you should create and clear

1048
00:38:25,760 --> 00:38:28,800
it and so you can't to prevent page

1049
00:38:28,800 --> 00:38:31,119
views attacks

1050
00:38:31,119 --> 00:38:33,040
uh so the data structure we're talking

1051
00:38:33,040 --> 00:38:35,119
about that keeps track of the pages

1052
00:38:35,119 --> 00:38:38,320
is basically our useland page table and

1053
00:38:38,320 --> 00:38:40,800
that and should be heavily heavily

1054
00:38:40,800 --> 00:38:43,440
heavily protected

1055
00:38:43,440 --> 00:38:45,359
such as it should only be writable when

1056
00:38:45,359 --> 00:38:46,400
being updated

1057
00:38:46,400 --> 00:38:49,119
it could be surrounded by guard pages or

1058
00:38:49,119 --> 00:38:50,240
and it should definitely not be

1059
00:38:50,240 --> 00:38:54,078
accessible to arm processor

1060
00:38:55,040 --> 00:38:56,000
um

1061
00:38:56,000 --> 00:38:58,240
so for if anyone's doing

1062
00:38:58,240 --> 00:39:00,720
analysis of these android application

1063
00:39:00,720 --> 00:39:03,040
um for dynamic glasses it's highly

1064
00:39:03,040 --> 00:39:05,359
recommended to also run it under

1065
00:39:05,359 --> 00:39:08,240
libertini environments to see if it does

1066
00:39:08,240 --> 00:39:09,839
any uh

1067
00:39:09,839 --> 00:39:13,440
it shows any uh different behaviors and

1068
00:39:13,440 --> 00:39:15,280
if you're running static analysis

1069
00:39:15,280 --> 00:39:16,079
um

1070
00:39:16,079 --> 00:39:17,520
you should be looking for any access and

1071
00:39:17,520 --> 00:39:20,000
weird red memory accesses to

1072
00:39:20,000 --> 00:39:21,839
the houdini pages

1073
00:39:21,839 --> 00:39:24,240
and attempting to execute from

1074
00:39:24,240 --> 00:39:26,079
non-executable pages

1075
00:39:26,079 --> 00:39:27,359
and

1076
00:39:27,359 --> 00:39:29,119
scanning the jni function pointers

1077
00:39:29,119 --> 00:39:32,720
because that's what i would be doing

1078
00:39:33,599 --> 00:39:35,680
and that brings us to the conclusion uh

1079
00:39:35,680 --> 00:39:37,680
houdini introduces a number of security

1080
00:39:37,680 --> 00:39:39,839
weaknesses into

1081
00:39:39,839 --> 00:39:42,400
things that use it and

1082
00:39:42,400 --> 00:39:44,960
those impact the both the emulated

1083
00:39:44,960 --> 00:39:46,960
section emulated arm

1084
00:39:46,960 --> 00:39:51,520
processor and the host x86 code

1085
00:39:51,520 --> 00:39:53,119
and these issues overall undermine

1086
00:39:53,119 --> 00:39:56,920
coordinative code hardening

1087
00:39:57,040 --> 00:39:59,200
so

1088
00:39:59,359 --> 00:40:01,200
we could have

1089
00:40:01,200 --> 00:40:02,880
it's possible

1090
00:40:02,880 --> 00:40:03,920
that

1091
00:40:03,920 --> 00:40:05,520
these issues could have been caught

1092
00:40:05,520 --> 00:40:08,640
earlier had houdini been more public and

1093
00:40:08,640 --> 00:40:11,359
more easily accessible which would mean

1094
00:40:11,359 --> 00:40:13,440
more people would have looked at it

1095
00:40:13,440 --> 00:40:16,319
that's just what we think

1096
00:40:17,440 --> 00:40:18,640
um and

1097
00:40:18,640 --> 00:40:20,160
that's the only presentation but i want

1098
00:40:20,160 --> 00:40:23,359
to give a big special thanks to jeff for

1099
00:40:23,359 --> 00:40:25,119
mentoring this research

1100
00:40:25,119 --> 00:40:28,560
and come developing the methodology

1101
00:40:28,560 --> 00:40:31,440
uh jennifer for great support with all

1102
00:40:31,440 --> 00:40:34,079
the research and

1103
00:40:34,079 --> 00:40:36,400
feedback great feedback and effie for

1104
00:40:36,400 --> 00:40:37,839
basically bootstrapping this research

1105
00:40:37,839 --> 00:40:39,520
including the chromebook i was doing the

1106
00:40:39,520 --> 00:40:40,880
testing on

1107
00:40:40,880 --> 00:40:41,760
and

1108
00:40:41,760 --> 00:40:43,599
and thanks everyone for joining the

1109
00:40:43,599 --> 00:40:48,520
session and we'll have q a

