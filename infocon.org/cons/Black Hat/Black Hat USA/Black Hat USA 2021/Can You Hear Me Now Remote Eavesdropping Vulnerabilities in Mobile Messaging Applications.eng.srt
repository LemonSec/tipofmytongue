1
00:00:01,130 --> 00:00:14,699
[Music]

2
00:00:22,560 --> 00:00:24,160
hi everyone

3
00:00:24,160 --> 00:00:25,920
thanks so much for coming

4
00:00:25,920 --> 00:00:27,599
today i'm going to talk about remote

5
00:00:27,599 --> 00:00:29,760
eavesdropping vulnerabilities in mobile

6
00:00:29,760 --> 00:00:32,558
messaging applications

7
00:00:32,558 --> 00:00:35,360
i'm natalie slovanovic and i'm a member

8
00:00:35,360 --> 00:00:37,600
of project xero at google

9
00:00:37,600 --> 00:00:40,079
and i've become a bit of a messaging

10
00:00:40,079 --> 00:00:42,640
enthusiast so today i'm going to share

11
00:00:42,640 --> 00:00:45,520
my latest research on mobile messaging

12
00:00:45,520 --> 00:00:48,000
applications

13
00:00:48,000 --> 00:00:50,480
you might remember that about two years

14
00:00:50,480 --> 00:00:53,360
ago there was the group facetime

15
00:00:53,360 --> 00:00:55,199
vulnerability

16
00:00:55,199 --> 00:00:57,199
and this was a really unusual

17
00:00:57,199 --> 00:00:59,039
vulnerability

18
00:00:59,039 --> 00:01:02,480
that um the way it worked was that you

19
00:01:02,480 --> 00:01:04,959
could start a group facetime call

20
00:01:04,959 --> 00:01:08,080
and then if you added someone to the

21
00:01:08,080 --> 00:01:10,240
call again it would automatically

22
00:01:10,240 --> 00:01:13,040
connect the call so the end effect of

23
00:01:13,040 --> 00:01:14,640
this was that

24
00:01:14,640 --> 00:01:16,880
you could force a call with someone else

25
00:01:16,880 --> 00:01:19,840
without them ever touching their phone

26
00:01:19,840 --> 00:01:21,280
so you could listen to their

27
00:01:21,280 --> 00:01:24,560
surroundings without their consent

28
00:01:24,560 --> 00:01:27,759
and this vulnerability was unusual in a

29
00:01:27,759 --> 00:01:29,360
few ways

30
00:01:29,360 --> 00:01:31,200
one was that it was available through

31
00:01:31,200 --> 00:01:32,960
the user interface

32
00:01:32,960 --> 00:01:36,159
so it was actually reported by a number

33
00:01:36,159 --> 00:01:38,840
of people including some middle

34
00:01:38,840 --> 00:01:41,920
schoolers and um you didn't need any

35
00:01:41,920 --> 00:01:44,399
special equipment or to modify your

36
00:01:44,399 --> 00:01:46,479
phone to use it which actually made it

37
00:01:46,479 --> 00:01:49,200
quite a severe vulnerability it even led

38
00:01:49,200 --> 00:01:51,680
to a downtime of great group facetime

39
00:01:51,680 --> 00:01:53,040
because they immediately took down the

40
00:01:53,040 --> 00:01:55,520
feature while they fixed the bug but

41
00:01:55,520 --> 00:01:57,840
what was also unusual about this bug was

42
00:01:57,840 --> 00:01:59,920
its impact

43
00:01:59,920 --> 00:02:01,600
well there have been exploits in the

44
00:02:01,600 --> 00:02:04,479
past which use memory corruption to

45
00:02:04,479 --> 00:02:06,960
escalate privileges and then eventually

46
00:02:06,960 --> 00:02:08,639
turn on the microphone

47
00:02:08,639 --> 00:02:10,479
so that an attacker can listen to a

48
00:02:10,479 --> 00:02:11,840
remote party

49
00:02:11,840 --> 00:02:14,239
i'd never seen a vulnerability where

50
00:02:14,239 --> 00:02:16,720
there's a logic bug that allows this

51
00:02:16,720 --> 00:02:18,560
directly

52
00:02:18,560 --> 00:02:20,319
and this is what i'm focusing on in this

53
00:02:20,319 --> 00:02:21,280
talk

54
00:02:21,280 --> 00:02:24,400
i wanted to think more about

55
00:02:24,400 --> 00:02:25,599
this um

56
00:02:25,599 --> 00:02:26,879
in my opinion unprecedented

57
00:02:26,879 --> 00:02:28,640
vulnerability type

58
00:02:28,640 --> 00:02:30,640
where there are logic bugs in a calling

59
00:02:30,640 --> 00:02:33,840
state machine that allows um access to

60
00:02:33,840 --> 00:02:37,120
remote audio video on a device

61
00:02:37,120 --> 00:02:39,840
and figure out how they happen

62
00:02:39,840 --> 00:02:42,879
and whether they exist in other

63
00:02:42,879 --> 00:02:44,800
applications

64
00:02:44,800 --> 00:02:47,040
so i started off by trying to figure out

65
00:02:47,040 --> 00:02:49,599
how this bug class works and then i

66
00:02:49,599 --> 00:02:53,680
investigated other apps for similar bugs

67
00:02:53,680 --> 00:02:54,640
so

68
00:02:54,640 --> 00:02:56,720
how does audio and video conferencing

69
00:02:56,720 --> 00:02:58,879
work in general

70
00:02:58,879 --> 00:03:01,280
well most applications use something

71
00:03:01,280 --> 00:03:03,360
called webrtc

72
00:03:03,360 --> 00:03:04,879
webrtc

73
00:03:04,879 --> 00:03:08,319
is both a protocol with specification

74
00:03:08,319 --> 00:03:10,560
and a specific audio and video

75
00:03:10,560 --> 00:03:12,480
conferencing library maintained by

76
00:03:12,480 --> 00:03:15,519
google so it's an overloaded term

77
00:03:15,519 --> 00:03:18,640
but in terms of google's webrtc library

78
00:03:18,640 --> 00:03:21,760
it's used by all major browsers

79
00:03:21,760 --> 00:03:24,879
and most mobile applications

80
00:03:24,879 --> 00:03:26,560
the only two video conferencing

81
00:03:26,560 --> 00:03:29,040
implementations that i'm aware of that

82
00:03:29,040 --> 00:03:30,959
don't use webrtc

83
00:03:30,959 --> 00:03:34,640
are whatsapp and facetime but regardless

84
00:03:34,640 --> 00:03:36,959
the alternatives they use have the same

85
00:03:36,959 --> 00:03:39,519
design their protocols are very similar

86
00:03:39,519 --> 00:03:42,400
to webrtc even though they don't use

87
00:03:42,400 --> 00:03:45,360
google's libwebrtc

88
00:03:45,360 --> 00:03:47,040
so how does this work

89
00:03:47,040 --> 00:03:50,000
well on a high level webrtc works by

90
00:03:50,000 --> 00:03:52,560
starting off a call with signaling and

91
00:03:52,560 --> 00:03:55,519
signaling is where information is

92
00:03:55,519 --> 00:03:58,239
exchanged between the two peers and the

93
00:03:58,239 --> 00:04:00,239
sort of information that will be

94
00:04:00,239 --> 00:04:02,879
exchanged is things like cryptographic

95
00:04:02,879 --> 00:04:05,680
keys and what codecs they support

96
00:04:05,680 --> 00:04:09,519
and then once they've agreed on these

97
00:04:09,519 --> 00:04:10,799
then there'll be a peer-to-peer

98
00:04:10,799 --> 00:04:13,280
connection and this is the second stage

99
00:04:13,280 --> 00:04:15,360
of the connection

100
00:04:15,360 --> 00:04:17,918
and my thinking was that when you think

101
00:04:17,918 --> 00:04:20,399
of these vulnerabilities that allow

102
00:04:20,399 --> 00:04:22,240
remote eavesdropping

103
00:04:22,240 --> 00:04:24,160
they should be errors in the signaling

104
00:04:24,160 --> 00:04:27,680
stage what's actually going wrong here

105
00:04:27,680 --> 00:04:30,000
is that this peer-to-peer media

106
00:04:30,000 --> 00:04:32,639
connection is being set up

107
00:04:32,639 --> 00:04:35,199
basically before the user is ready

108
00:04:35,199 --> 00:04:38,639
and that's an error in signaling

109
00:04:38,639 --> 00:04:39,600
so

110
00:04:39,600 --> 00:04:42,400
how signaling works in more detail

111
00:04:42,400 --> 00:04:45,600
is that for a two-person call typically

112
00:04:45,600 --> 00:04:48,479
there's a caller and there's a callee

113
00:04:48,479 --> 00:04:51,360
and the caller's device will send an sdp

114
00:04:51,360 --> 00:04:53,919
offer and the callee will return an

115
00:04:53,919 --> 00:04:54,880
answer

116
00:04:54,880 --> 00:04:58,320
sdp is a session description protocol

117
00:04:58,320 --> 00:05:00,160
and it's basically just a text format

118
00:05:00,160 --> 00:05:02,320
that can contain all sorts of

119
00:05:02,320 --> 00:05:05,039
information like crypto keys and codec

120
00:05:05,039 --> 00:05:06,160
types

121
00:05:06,160 --> 00:05:09,039
so this information gets exchanged

122
00:05:09,039 --> 00:05:11,280
and then the devices will exchange what

123
00:05:11,280 --> 00:05:12,960
are called candidates

124
00:05:12,960 --> 00:05:15,360
and these are possible ways for the

125
00:05:15,360 --> 00:05:16,800
devices to connect

126
00:05:16,800 --> 00:05:19,280
so it might be the device's udp address

127
00:05:19,280 --> 00:05:22,639
their tcp address some various nat stun

128
00:05:22,639 --> 00:05:24,639
turn addresses

129
00:05:24,639 --> 00:05:27,199
and these are done after they offer an

130
00:05:27,199 --> 00:05:29,280
answer and there can actually be more

131
00:05:29,280 --> 00:05:31,840
than one exchanged because these often

132
00:05:31,840 --> 00:05:34,320
take time for the device to determine

133
00:05:34,320 --> 00:05:35,840
but something important to keep in mind

134
00:05:35,840 --> 00:05:37,440
is offers and answers can also have

135
00:05:37,440 --> 00:05:39,440
candidates in them so if there's

136
00:05:39,440 --> 00:05:40,800
something that the device knows right

137
00:05:40,800 --> 00:05:43,280
away like it's udp

138
00:05:43,280 --> 00:05:46,080
ip address that can be in the offer or

139
00:05:46,080 --> 00:05:47,680
the answer

140
00:05:47,680 --> 00:05:50,240
but once separation has been exchanged

141
00:05:50,240 --> 00:05:54,000
then there can be a p2p media connection

142
00:05:54,000 --> 00:05:56,000
and this is where audio and video can be

143
00:05:56,000 --> 00:05:57,600
sent

144
00:05:57,600 --> 00:05:59,120
but there's one more feature that

145
00:05:59,120 --> 00:06:00,960
actually makes this work

146
00:06:00,960 --> 00:06:02,960
and this is called tracks

147
00:06:02,960 --> 00:06:05,600
tracks is the programming construct in

148
00:06:05,600 --> 00:06:06,960
webrtc

149
00:06:06,960 --> 00:06:10,880
that represents a camera or a microphone

150
00:06:10,880 --> 00:06:12,720
and this needs to be added to the peer

151
00:06:12,720 --> 00:06:15,680
connection before any input is streamed

152
00:06:15,680 --> 00:06:17,280
from these devices

153
00:06:17,280 --> 00:06:19,039
and this can be done at any time during

154
00:06:19,039 --> 00:06:22,000
a call even if the p2p connection hasn't

155
00:06:22,000 --> 00:06:23,840
been established so this could be done

156
00:06:23,840 --> 00:06:25,440
at the beginning and then as soon as the

157
00:06:25,440 --> 00:06:27,520
connection is established the media will

158
00:06:27,520 --> 00:06:30,720
be sent or the pdp connection can be set

159
00:06:30,720 --> 00:06:32,720
up and then the track can be enabled or

160
00:06:32,720 --> 00:06:35,039
disabled later this can even be done in

161
00:06:35,039 --> 00:06:37,759
the middle of the call and this is often

162
00:06:37,759 --> 00:06:40,800
how mute functionality is implemented

163
00:06:40,800 --> 00:06:42,720
by either

164
00:06:42,720 --> 00:06:45,330
disabling a track or by removing it

165
00:06:45,330 --> 00:06:47,199
[Music]

166
00:06:47,199 --> 00:06:48,319
so then what causes these

167
00:06:48,319 --> 00:06:51,919
vulnerabilities i posited that this was

168
00:06:51,919 --> 00:06:55,039
due to the state machines that are used

169
00:06:55,039 --> 00:06:55,759
to

170
00:06:55,759 --> 00:06:58,000
handle offers answers candidates and

171
00:06:58,000 --> 00:07:00,240
tracks i thought these bugs were

172
00:07:00,240 --> 00:07:01,759
probably caused by that type of

173
00:07:01,759 --> 00:07:03,120
vulnerability

174
00:07:03,120 --> 00:07:05,599
and i didn't actually look into the face

175
00:07:05,599 --> 00:07:07,840
time bug or well i did but i never quite

176
00:07:07,840 --> 00:07:10,720
figured out what caused it

177
00:07:10,720 --> 00:07:12,400
but based on my understanding of how

178
00:07:12,400 --> 00:07:14,319
video conferencing works i think this is

179
00:07:14,319 --> 00:07:16,160
how the majority of bugs like this would

180
00:07:16,160 --> 00:07:18,240
work

181
00:07:18,240 --> 00:07:19,360
and i think

182
00:07:19,360 --> 00:07:21,360
as far as root cause goes there's a few

183
00:07:21,360 --> 00:07:22,960
ways this could happen

184
00:07:22,960 --> 00:07:24,560
one possibility

185
00:07:24,560 --> 00:07:26,720
is that the developers make a mistake in

186
00:07:26,720 --> 00:07:28,240
their state machine

187
00:07:28,240 --> 00:07:30,400
they either don't realize there's this

188
00:07:30,400 --> 00:07:31,680
edge case where they call it could

189
00:07:31,680 --> 00:07:34,240
connect or they have a good state

190
00:07:34,240 --> 00:07:36,000
machine but they make a mistake in the

191
00:07:36,000 --> 00:07:38,639
code and it doesn't work correctly

192
00:07:38,639 --> 00:07:40,639
but i also think it's possible that

193
00:07:40,639 --> 00:07:42,479
developers misunderstand the webrtc

194
00:07:42,479 --> 00:07:44,400
contra constructs

195
00:07:44,400 --> 00:07:45,759
their theoretical understanding of

196
00:07:45,759 --> 00:07:47,120
webrtct

197
00:07:47,120 --> 00:07:49,599
is not how it really works so they end

198
00:07:49,599 --> 00:07:52,080
up introducing bugs that way

199
00:07:52,080 --> 00:07:53,759
and finally i think it's possible that

200
00:07:53,759 --> 00:07:56,720
webrtc itself will have bugs that can

201
00:07:56,720 --> 00:07:59,199
cause this type of eavesdropping problem

202
00:07:59,199 --> 00:08:01,520
i haven't actually seen this

203
00:08:01,520 --> 00:08:03,840
any bug that is caused by a bug in

204
00:08:03,840 --> 00:08:06,000
webrtc but i do think it's at least

205
00:08:06,000 --> 00:08:07,599
theoretically possible

206
00:08:07,599 --> 00:08:10,319
that there are bugs in webrtc that could

207
00:08:10,319 --> 00:08:12,630
cause signaling not to work as expected

208
00:08:12,630 --> 00:08:14,000
[Music]

209
00:08:14,000 --> 00:08:15,919
so then i decided i was going to go

210
00:08:15,919 --> 00:08:18,240
about and try and find some

211
00:08:18,240 --> 00:08:20,319
vulnerabilities in state machines i

212
00:08:20,319 --> 00:08:23,039
started off by trying to understand the

213
00:08:23,039 --> 00:08:24,560
state machine

214
00:08:24,560 --> 00:08:27,520
and then i thought about possible

215
00:08:27,520 --> 00:08:29,599
problems the state machines could have

216
00:08:29,599 --> 00:08:32,719
and then finally i tested the problems

217
00:08:32,719 --> 00:08:34,320
to see whether i could actually

218
00:08:34,320 --> 00:08:36,000
reproduce the vulnerabilities i thought

219
00:08:36,000 --> 00:08:38,799
these state machines had

220
00:08:38,799 --> 00:08:40,799
so to start off i tried to understand

221
00:08:40,799 --> 00:08:42,640
the state machines

222
00:08:42,640 --> 00:08:44,240
and um

223
00:08:44,240 --> 00:08:46,880
in some situations it was really easy

224
00:08:46,880 --> 00:08:48,560
some projects such as signal and

225
00:08:48,560 --> 00:08:49,839
telegram

226
00:08:49,839 --> 00:08:51,760
especially signal document their state

227
00:08:51,760 --> 00:08:53,440
machines very well

228
00:08:53,440 --> 00:08:55,279
and my opinion is that all projects

229
00:08:55,279 --> 00:08:56,880
should do this

230
00:08:56,880 --> 00:08:58,720
even if it's a closed source project i

231
00:08:58,720 --> 00:09:00,800
think this is a good idea for developers

232
00:09:00,800 --> 00:09:02,080
to do

233
00:09:02,080 --> 00:09:04,240
it make sure that the developers

234
00:09:04,240 --> 00:09:06,240
understand the state machines and how

235
00:09:06,240 --> 00:09:09,200
they work and i think it's very possible

236
00:09:09,200 --> 00:09:11,519
that you can find vulnerabilities just

237
00:09:11,519 --> 00:09:14,560
by learning more about the state machine

238
00:09:14,560 --> 00:09:16,240
but of course this wasn't possible

239
00:09:16,240 --> 00:09:18,720
especially for closed source projects so

240
00:09:18,720 --> 00:09:21,920
what i did is i used frida to hook

241
00:09:21,920 --> 00:09:24,160
signaling on an android device

242
00:09:24,160 --> 00:09:26,720
i would hook the code that

243
00:09:26,720 --> 00:09:29,600
handled offers answers candidates and

244
00:09:29,600 --> 00:09:31,839
tracks so this is incoming and then i'd

245
00:09:31,839 --> 00:09:35,279
manipulate the user interface i would

246
00:09:35,279 --> 00:09:36,640
make a call

247
00:09:36,640 --> 00:09:39,200
and then answer it on the other side and

248
00:09:39,200 --> 00:09:40,959
then i'd make an incoming call and

249
00:09:40,959 --> 00:09:42,080
answer it

250
00:09:42,080 --> 00:09:43,839
and just see what order of things

251
00:09:43,839 --> 00:09:45,040
happened in

252
00:09:45,040 --> 00:09:48,080
this did allow me to right away

253
00:09:48,080 --> 00:09:50,560
exclude some apps there were some apps

254
00:09:50,560 --> 00:09:52,399
where when you made a call

255
00:09:52,399 --> 00:09:54,480
absolutely nothing happened until the

256
00:09:54,480 --> 00:09:56,080
user on the other side picked up the

257
00:09:56,080 --> 00:09:56,880
call

258
00:09:56,880 --> 00:09:59,279
and in that case um

259
00:09:59,279 --> 00:10:01,440
it's very unlikely that that app has

260
00:10:01,440 --> 00:10:02,640
this type

261
00:10:02,640 --> 00:10:05,040
of vulnerability because this type of

262
00:10:05,040 --> 00:10:07,120
vulnerability happens before the user is

263
00:10:07,120 --> 00:10:08,560
interacted with the device and if the

264
00:10:08,560 --> 00:10:10,560
user has to interact with the device in

265
00:10:10,560 --> 00:10:13,680
order to have any attack surface at all

266
00:10:13,680 --> 00:10:16,720
the sort of bug probably doesn't exist

267
00:10:16,720 --> 00:10:19,200
but most applications did do some things

268
00:10:19,200 --> 00:10:21,920
before the user picked up the call

269
00:10:21,920 --> 00:10:24,160
so then i would look further into it

270
00:10:24,160 --> 00:10:24,880
and

271
00:10:24,880 --> 00:10:27,440
after that i uh would sometimes

272
00:10:27,440 --> 00:10:30,160
decompile the app with apk tool and see

273
00:10:30,160 --> 00:10:32,880
what webrtc natives were called

274
00:10:32,880 --> 00:10:34,720
sometimes people will use tools to

275
00:10:34,720 --> 00:10:37,920
recompile the smallie in java i didn't

276
00:10:37,920 --> 00:10:39,279
do this i just looked at the smallie

277
00:10:39,279 --> 00:10:42,800
directly and figured out basically when

278
00:10:42,800 --> 00:10:45,279
all the functions that

279
00:10:45,279 --> 00:10:47,839
handled offers or answers candidates or

280
00:10:47,839 --> 00:10:49,360
tracks was called

281
00:10:49,360 --> 00:10:50,240
and

282
00:10:50,240 --> 00:10:51,279
wrote down what i thought the state

283
00:10:51,279 --> 00:10:55,040
machine was and then thought about it

284
00:10:55,040 --> 00:10:55,839
so

285
00:10:55,839 --> 00:10:57,839
what sort of problems could happen with

286
00:10:57,839 --> 00:10:59,360
a state machine

287
00:10:59,360 --> 00:11:01,440
well you typically have a message flow

288
00:11:01,440 --> 00:11:03,440
from one peer to the other

289
00:11:03,440 --> 00:11:04,880
that's supposed to happen in an expected

290
00:11:04,880 --> 00:11:05,839
order

291
00:11:05,839 --> 00:11:08,160
so some things you can do is you can

292
00:11:08,160 --> 00:11:10,160
send extra messages

293
00:11:10,160 --> 00:11:13,760
you can draw messages you can not send

294
00:11:13,760 --> 00:11:16,800
specific messages that are expected

295
00:11:16,800 --> 00:11:19,040
you can send messages in the wrong order

296
00:11:19,040 --> 00:11:20,160
and i think this was the most

297
00:11:20,160 --> 00:11:22,880
interesting one sending messages in the

298
00:11:22,880 --> 00:11:24,480
wrong direction

299
00:11:24,480 --> 00:11:26,560
so basically sometimes there are message

300
00:11:26,560 --> 00:11:29,680
types that are intended to go from

301
00:11:29,680 --> 00:11:31,120
caller to cali

302
00:11:31,120 --> 00:11:32,640
you know what if you sent them from

303
00:11:32,640 --> 00:11:35,040
colleen to caller instead

304
00:11:35,040 --> 00:11:37,920
and finally sometimes there were what

305
00:11:37,920 --> 00:11:40,560
i'll call secret message types sometimes

306
00:11:40,560 --> 00:11:42,480
there were types of messages that were

307
00:11:42,480 --> 00:11:45,760
sent from one peer to the other

308
00:11:45,760 --> 00:11:47,920
and um

309
00:11:47,920 --> 00:11:49,680
they were not documented they were just

310
00:11:49,680 --> 00:11:52,160
like special types that didn't show up

311
00:11:52,160 --> 00:11:54,480
in the course of a normal call

312
00:11:54,480 --> 00:11:56,880
but um could happen

313
00:11:56,880 --> 00:11:59,440
and just be clear um what i mean by uh

314
00:11:59,440 --> 00:12:00,959
messages here

315
00:12:00,959 --> 00:12:04,000
most state machines are set up with some

316
00:12:04,000 --> 00:12:06,800
type of peer-to-peer signaling message

317
00:12:06,800 --> 00:12:08,639
usually this is actually the message

318
00:12:08,639 --> 00:12:10,639
type used by the application

319
00:12:10,639 --> 00:12:12,800
so for example in facebook it's a

320
00:12:12,800 --> 00:12:14,399
facebook message

321
00:12:14,399 --> 00:12:16,959
and in signal it's a signal message and

322
00:12:16,959 --> 00:12:19,120
usually these apps will set up calls by

323
00:12:19,120 --> 00:12:21,040
sending a series of messages to each

324
00:12:21,040 --> 00:12:22,639
other that include the offer and the

325
00:12:22,639 --> 00:12:24,880
answer and the candidates to set up the

326
00:12:24,880 --> 00:12:25,300
call

327
00:12:25,300 --> 00:12:26,800
[Music]

328
00:12:26,800 --> 00:12:28,800
so now i'm going to go through a few

329
00:12:28,800 --> 00:12:31,360
vulnerabilities i found and explain what

330
00:12:31,360 --> 00:12:33,040
actually caused them in the state

331
00:12:33,040 --> 00:12:34,240
machine

332
00:12:34,240 --> 00:12:37,680
to start off i found two similar

333
00:12:37,680 --> 00:12:39,519
vulnerabilities

334
00:12:39,519 --> 00:12:41,760
in signal messenger

335
00:12:41,760 --> 00:12:44,399
and facebook messenger and these were

336
00:12:44,399 --> 00:12:47,839
both due to state mismanagement

337
00:12:47,839 --> 00:12:50,240
the signal vulnerability i reported and

338
00:12:50,240 --> 00:12:53,120
it was fixed in 2019 and the root cause

339
00:12:53,120 --> 00:12:53,920
was

340
00:12:53,920 --> 00:12:55,440
was confusion between the caller and the

341
00:12:55,440 --> 00:12:57,279
cauli state so there was a message that

342
00:12:57,279 --> 00:12:58,959
was supposed to go from caller to collee

343
00:12:58,959 --> 00:13:00,880
but instead i sent it from kali to

344
00:13:00,880 --> 00:13:02,000
caller

345
00:13:02,000 --> 00:13:04,399
i found a similar bug in facebook

346
00:13:04,399 --> 00:13:06,480
messenger which was reported and fixed

347
00:13:06,480 --> 00:13:08,000
in 2020

348
00:13:08,000 --> 00:13:10,240
and it was a similar root cause

349
00:13:10,240 --> 00:13:12,720
involving state mismanagement but in

350
00:13:12,720 --> 00:13:14,880
this case it was that i could send a

351
00:13:14,880 --> 00:13:17,200
message that was only supposed to be

352
00:13:17,200 --> 00:13:19,200
sent when the call was established

353
00:13:19,200 --> 00:13:21,440
before the call was established

354
00:13:21,440 --> 00:13:23,279
and both of these vulnerabilities

355
00:13:23,279 --> 00:13:25,360
allowed audio to be transmitted without

356
00:13:25,360 --> 00:13:27,600
user consent so i could make a call to

357
00:13:27,600 --> 00:13:29,360
another device and listen to their

358
00:13:29,360 --> 00:13:30,959
surroundings

359
00:13:30,959 --> 00:13:32,959
and here's how this signal vulnerability

360
00:13:32,959 --> 00:13:36,000
worked the call setup is pretty typical

361
00:13:36,000 --> 00:13:36,800
so

362
00:13:36,800 --> 00:13:39,199
the caller sends the sdp offer you get

363
00:13:39,199 --> 00:13:41,680
the answer back you exchange candidates

364
00:13:41,680 --> 00:13:44,480
and then p2p media is set up and this is

365
00:13:44,480 --> 00:13:45,920
fairly typical

366
00:13:45,920 --> 00:13:48,639
this is how a lot of webrtc calls get

367
00:13:48,639 --> 00:13:49,600
set up

368
00:13:49,600 --> 00:13:52,240
and then the phone would be ringing on

369
00:13:52,240 --> 00:13:54,079
the cali side and then the callee

370
00:13:54,079 --> 00:13:56,160
presses the button to answer the call on

371
00:13:56,160 --> 00:13:58,000
the kali side that just adds the track

372
00:13:58,000 --> 00:14:00,399
directly but on the caller side it would

373
00:14:00,399 --> 00:14:03,360
send this one last message to say yes i

374
00:14:03,360 --> 00:14:06,880
am connected and then um

375
00:14:06,880 --> 00:14:08,399
the track would be added on the caller

376
00:14:08,399 --> 00:14:10,560
side and the call would be officially

377
00:14:10,560 --> 00:14:12,000
started

378
00:14:12,000 --> 00:14:14,480
but what if you do this

379
00:14:14,480 --> 00:14:15,920
what if you send this message from

380
00:14:15,920 --> 00:14:18,160
caller to cali what this would do is it

381
00:14:18,160 --> 00:14:20,000
would add the track before the colleague

382
00:14:20,000 --> 00:14:21,600
had picked up the call so this would

383
00:14:21,600 --> 00:14:24,320
just immediately establish a call

384
00:14:24,320 --> 00:14:26,800
yes this was an interesting bug

385
00:14:26,800 --> 00:14:29,279
and i do want to mention the signal

386
00:14:29,279 --> 00:14:31,040
since then has vastly changed how their

387
00:14:31,040 --> 00:14:33,120
calling state machine works

388
00:14:33,120 --> 00:14:34,800
and now if you don't have someone in

389
00:14:34,800 --> 00:14:37,360
your contacts you actually need to

390
00:14:37,360 --> 00:14:39,680
interact with the phone before the offer

391
00:14:39,680 --> 00:14:41,680
is even sent and that's a really big

392
00:14:41,680 --> 00:14:43,519
improvement but this is how the state

393
00:14:43,519 --> 00:14:46,880
machine worked in 2019

394
00:14:46,880 --> 00:14:49,120
so here's another vulnerability i found

395
00:14:49,120 --> 00:14:51,360
and this was in it was basically the

396
00:14:51,360 --> 00:14:53,920
exact same vulnerability occurred in two

397
00:14:53,920 --> 00:14:56,800
applications geochat which is popular in

398
00:14:56,800 --> 00:15:00,079
india and mocha which is popular in

399
00:15:00,079 --> 00:15:01,440
vietnam

400
00:15:01,440 --> 00:15:03,839
and both of these

401
00:15:03,839 --> 00:15:06,079
were caused by the developers not

402
00:15:06,079 --> 00:15:07,440
understanding

403
00:15:07,440 --> 00:15:08,399
that

404
00:15:08,399 --> 00:15:10,399
candidates can occur in offers so this

405
00:15:10,399 --> 00:15:12,720
was just a pure misunderstanding

406
00:15:12,720 --> 00:15:14,160
a webrtc

407
00:15:14,160 --> 00:15:16,639
features and they both allowed audio and

408
00:15:16,639 --> 00:15:18,639
video to be transmitted without consent

409
00:15:18,639 --> 00:15:20,240
so it would basically pick up a video

410
00:15:20,240 --> 00:15:22,560
call

411
00:15:23,440 --> 00:15:24,800
so the way this worked is these were

412
00:15:24,800 --> 00:15:27,360
actually server mediated

413
00:15:27,360 --> 00:15:29,519
so and actually all of these bugs are

414
00:15:29,519 --> 00:15:32,079
but in this case the server's behavior

415
00:15:32,079 --> 00:15:34,160
is actually relevant

416
00:15:34,160 --> 00:15:36,720
so the device would exchange an offer

417
00:15:36,720 --> 00:15:38,320
and an answer

418
00:15:38,320 --> 00:15:40,959
but of course the offer would be sent to

419
00:15:40,959 --> 00:15:42,480
a server and then the server would send

420
00:15:42,480 --> 00:15:44,399
it to the device and then the callee

421
00:15:44,399 --> 00:15:45,920
would send their answer to the server

422
00:15:45,920 --> 00:15:47,120
which and then the server would send it

423
00:15:47,120 --> 00:15:48,639
to the caller

424
00:15:48,639 --> 00:15:51,120
but here's where it gets interesting

425
00:15:51,120 --> 00:15:52,880
then both sides would start exchanging

426
00:15:52,880 --> 00:15:55,120
candidates but the server wouldn't share

427
00:15:55,120 --> 00:15:58,959
them the server would just um keep them

428
00:15:58,959 --> 00:16:01,519
and then the phone is ringing

429
00:16:01,519 --> 00:16:03,440
and the

430
00:16:03,440 --> 00:16:05,759
callee would eventually hit the accept

431
00:16:05,759 --> 00:16:06,800
button

432
00:16:06,800 --> 00:16:08,800
and then the server would let all the

433
00:16:08,800 --> 00:16:10,079
candidates free

434
00:16:10,079 --> 00:16:12,720
and give them to the other side and then

435
00:16:12,720 --> 00:16:14,800
this would call cause the call to

436
00:16:14,800 --> 00:16:16,320
connect and then you can actually in

437
00:16:16,320 --> 00:16:19,440
webrtc put an event on p2p media

438
00:16:19,440 --> 00:16:20,880
connecting

439
00:16:20,880 --> 00:16:23,040
and this is where the track was actually

440
00:16:23,040 --> 00:16:25,920
added in geochat

441
00:16:25,920 --> 00:16:27,839
and the problem here

442
00:16:27,839 --> 00:16:30,800
is that um what if you have an offer

443
00:16:30,800 --> 00:16:32,000
with candidates you know what if you can

444
00:16:32,000 --> 00:16:33,600
kind of guess what some of them will be

445
00:16:33,600 --> 00:16:35,600
and then send them then this immediately

446
00:16:35,600 --> 00:16:37,920
connects right it's offer answer that's

447
00:16:37,920 --> 00:16:39,279
all they need to connect and then it

448
00:16:39,279 --> 00:16:40,720
will trigger this event and it'll add

449
00:16:40,720 --> 00:16:41,839
the track

450
00:16:41,839 --> 00:16:43,920
and a video will be sent

451
00:16:43,920 --> 00:16:47,920
and this was the vulnerability

452
00:16:47,920 --> 00:16:49,600
and

453
00:16:49,600 --> 00:16:51,199
you might ask

454
00:16:51,199 --> 00:16:53,519
why did they design it this way

455
00:16:53,519 --> 00:16:56,399
i think the reason they did this

456
00:16:56,399 --> 00:16:58,880
was that you always have this problem

457
00:16:58,880 --> 00:17:01,120
with webrtc where you have to make a

458
00:17:01,120 --> 00:17:03,440
security trade-off either you set up the

459
00:17:03,440 --> 00:17:05,520
p2p connection

460
00:17:05,520 --> 00:17:07,439
before the user picks up the call and

461
00:17:07,439 --> 00:17:09,119
then there's always the risk that an

462
00:17:09,119 --> 00:17:11,199
attacker sends media

463
00:17:11,199 --> 00:17:14,000
and that attack surface is available

464
00:17:14,000 --> 00:17:16,319
and of course you can wait until after

465
00:17:16,319 --> 00:17:18,240
the call has been answered to send the

466
00:17:18,240 --> 00:17:20,000
offer and the answer

467
00:17:20,000 --> 00:17:21,679
and that works as well but that has a

468
00:17:21,679 --> 00:17:23,520
performance cost because once the users

469
00:17:23,520 --> 00:17:25,039
picked up the call they have to wait for

470
00:17:25,039 --> 00:17:28,160
it to connect so i think this was a way

471
00:17:28,160 --> 00:17:31,840
to try and have the best of both worlds

472
00:17:31,840 --> 00:17:33,440
and set up some of the connection but

473
00:17:33,440 --> 00:17:36,080
not all of the connection and have it

474
00:17:36,080 --> 00:17:38,720
both have a low attack surface and be

475
00:17:38,720 --> 00:17:40,720
fast to set up

476
00:17:40,720 --> 00:17:43,600
but unfortunately it didn't work

477
00:17:43,600 --> 00:17:44,880
and i think this should also be a

478
00:17:44,880 --> 00:17:46,880
warning that it's not a good idea to

479
00:17:46,880 --> 00:17:49,679
come up with creative ways to make

480
00:17:49,679 --> 00:17:51,679
webrtc more efficient

481
00:17:51,679 --> 00:17:53,679
there are documented ways to set up

482
00:17:53,679 --> 00:17:55,600
calls in webrtc

483
00:17:55,600 --> 00:17:57,919
and it's the most secure choice to stick

484
00:17:57,919 --> 00:17:59,520
to them and accept that you do have to

485
00:17:59,520 --> 00:18:01,520
make a security trade-off

486
00:18:01,520 --> 00:18:03,679
and decide whether you want to reduce

487
00:18:03,679 --> 00:18:05,120
the remote attack surface of your

488
00:18:05,120 --> 00:18:09,360
application or have it connect quickly

489
00:18:09,360 --> 00:18:11,840
so finally i found this vulnerability in

490
00:18:11,840 --> 00:18:14,559
google duo and this was found and fixed

491
00:18:14,559 --> 00:18:16,960
in 2020

492
00:18:16,960 --> 00:18:19,919
and um its root cause is increment

493
00:18:19,919 --> 00:18:21,919
incorrect asynchronous logic which is

494
00:18:21,919 --> 00:18:23,919
what a lot of people would call a race

495
00:18:23,919 --> 00:18:25,919
condition and it was kind of interesting

496
00:18:25,919 --> 00:18:28,320
because it didn't allow audio or video

497
00:18:28,320 --> 00:18:31,600
to be transmitted it just allowed a few

498
00:18:31,600 --> 00:18:34,720
frames of video to be transmitted

499
00:18:34,720 --> 00:18:37,440
and this is i guess not as useful as say

500
00:18:37,440 --> 00:18:40,000
turning on video for a long time

501
00:18:40,000 --> 00:18:41,440
but still you know the ability to turn

502
00:18:41,440 --> 00:18:42,960
on someone's camera

503
00:18:42,960 --> 00:18:44,880
and take a few photos and then turn it

504
00:18:44,880 --> 00:18:48,720
off again is still fairly concerning

505
00:18:48,720 --> 00:18:50,400
so how did this work

506
00:18:50,400 --> 00:18:54,559
well the way um duo would exchange their

507
00:18:54,559 --> 00:18:56,720
offer answering candidates

508
00:18:56,720 --> 00:18:58,720
is fairly typical

509
00:18:58,720 --> 00:19:00,799
except that

510
00:19:00,799 --> 00:19:04,400
they would add the track to video and

511
00:19:04,400 --> 00:19:05,200
then

512
00:19:05,200 --> 00:19:08,240
as soon as the sdp offer is received

513
00:19:08,240 --> 00:19:09,600
they would turn it off using this

514
00:19:09,600 --> 00:19:11,520
function called

515
00:19:11,520 --> 00:19:14,320
sender.set parameters and normally this

516
00:19:14,320 --> 00:19:15,840
would work fine

517
00:19:15,840 --> 00:19:17,679
but notice that these are asynchronous

518
00:19:17,679 --> 00:19:20,160
calls but still in a normal situation

519
00:19:20,160 --> 00:19:21,919
you send the offer you turn off the

520
00:19:21,919 --> 00:19:24,000
video you send back the answer

521
00:19:24,000 --> 00:19:26,640
candidates get sent media is set up and

522
00:19:26,640 --> 00:19:28,320
then the user accepts and then the same

523
00:19:28,320 --> 00:19:30,480
function is used to turn the track back

524
00:19:30,480 --> 00:19:31,679
on

525
00:19:31,679 --> 00:19:33,200
here's what could happen

526
00:19:33,200 --> 00:19:36,480
what if this is very very slow

527
00:19:36,480 --> 00:19:38,320
and it turned out that i found a way to

528
00:19:38,320 --> 00:19:39,520
do this

529
00:19:39,520 --> 00:19:42,000
it turns out that the thread cue used

530
00:19:42,000 --> 00:19:44,799
for this call to set parameters was

531
00:19:44,799 --> 00:19:47,440
actually the same thread queue that was

532
00:19:47,440 --> 00:19:52,960
used for incoming sctp data in webrtc

533
00:19:52,960 --> 00:19:54,799
so i made something that would exchange

534
00:19:54,799 --> 00:19:56,080
the offer and the answer and the

535
00:19:56,080 --> 00:19:58,720
candidates and set up the pdp media

536
00:19:58,720 --> 00:20:00,799
and then received a lot of data and then

537
00:20:00,799 --> 00:20:02,480
i would just send this over and over and

538
00:20:02,480 --> 00:20:04,080
over again with more and more data

539
00:20:04,080 --> 00:20:06,080
queuing up and eventually i was able to

540
00:20:06,080 --> 00:20:08,400
get it in a situation where this set

541
00:20:08,400 --> 00:20:11,440
parameters was called really really late

542
00:20:11,440 --> 00:20:13,840
and sometimes you get into the situation

543
00:20:13,840 --> 00:20:15,120
where the media was actually

544
00:20:15,120 --> 00:20:17,039
transmitting before it was turned off

545
00:20:17,039 --> 00:20:18,799
and this meant that the video would turn

546
00:20:18,799 --> 00:20:20,640
on for a few frames send them and turn

547
00:20:20,640 --> 00:20:21,520
off

548
00:20:21,520 --> 00:20:23,600
and that turned out to be kind of a cool

549
00:20:23,600 --> 00:20:25,840
bug

550
00:20:25,840 --> 00:20:28,720
so how did i test these vulnerabilities

551
00:20:28,720 --> 00:20:31,280
well it was a bit painful if they were

552
00:20:31,280 --> 00:20:34,559
open source apps that was great

553
00:20:34,559 --> 00:20:36,080
i would

554
00:20:36,080 --> 00:20:38,480
recompile them change what they do

555
00:20:38,480 --> 00:20:40,480
and set all the messages i want

556
00:20:40,480 --> 00:20:42,720
otherwise i would use frida to change

557
00:20:42,720 --> 00:20:44,880
the state machine call flow

558
00:20:44,880 --> 00:20:47,120
and this was painful especially since

559
00:20:47,120 --> 00:20:48,960
most of these apps were obfuscated you

560
00:20:48,960 --> 00:20:51,520
know i'd call a dot a dot a dot b

561
00:20:51,520 --> 00:20:53,200
and then get the wrong one and call it

562
00:20:53,200 --> 00:20:55,120
again but with enough work i'd figured

563
00:20:55,120 --> 00:20:57,200
out how to call to send the messages and

564
00:20:57,200 --> 00:20:59,120
then call them in frida

565
00:20:59,120 --> 00:21:01,280
and um reproduce all these issues and

566
00:21:01,280 --> 00:21:02,799
for all of them i had frieda scripts

567
00:21:02,799 --> 00:21:04,799
that would actually work

568
00:21:04,799 --> 00:21:08,000
but this did require an extra step in

569
00:21:08,000 --> 00:21:09,360
facebook messenger and i just wanted to

570
00:21:09,360 --> 00:21:11,360
share this because i thought it was a

571
00:21:11,360 --> 00:21:12,799
bit cool

572
00:21:12,799 --> 00:21:15,039
so facebook messenger uses something

573
00:21:15,039 --> 00:21:17,120
called facebook thrift and it's open

574
00:21:17,120 --> 00:21:19,280
source you can find it on github it's a

575
00:21:19,280 --> 00:21:20,960
branch of thrift

576
00:21:20,960 --> 00:21:24,320
and thrift is a format where you provide

577
00:21:24,320 --> 00:21:26,799
a protocol definition

578
00:21:26,799 --> 00:21:30,159
and then the code is generated so that

579
00:21:30,159 --> 00:21:32,720
you can decode and encode messages

580
00:21:32,720 --> 00:21:33,520
and

581
00:21:33,520 --> 00:21:35,039
this is how

582
00:21:35,039 --> 00:21:37,120
a lot of messages in facebook messenger

583
00:21:37,120 --> 00:21:39,840
especially the mobile versions work

584
00:21:39,840 --> 00:21:42,000
and i looked at how facebook thrift

585
00:21:42,000 --> 00:21:44,799
worked and it turns out that they call

586
00:21:44,799 --> 00:21:46,880
this function right field begin every

587
00:21:46,880 --> 00:21:49,120
time they start writing an object so

588
00:21:49,120 --> 00:21:51,360
this is um an object being encoded

589
00:21:51,360 --> 00:21:52,799
before it's sent

590
00:21:52,799 --> 00:21:54,799
so i went through and i found this in

591
00:21:54,799 --> 00:21:55,840
source

592
00:21:55,840 --> 00:21:56,720
but

593
00:21:56,720 --> 00:21:58,480
then i looked at where it was called

594
00:21:58,480 --> 00:22:00,240
and it was kind of interesting it turns

595
00:22:00,240 --> 00:22:02,320
out that when

596
00:22:02,320 --> 00:22:05,760
thrift is compiled in c it actually

597
00:22:05,760 --> 00:22:08,880
writes the field name of

598
00:22:08,880 --> 00:22:11,280
the field that it's writing even though

599
00:22:11,280 --> 00:22:13,039
in the serialization format that

600
00:22:13,039 --> 00:22:15,039
facebook uses this will never actually

601
00:22:15,039 --> 00:22:17,600
end up in the packet or the message but

602
00:22:17,600 --> 00:22:20,320
it'll still write this string

603
00:22:20,320 --> 00:22:23,600
for some reason so you can actually read

604
00:22:23,600 --> 00:22:26,640
the name of the fields in the definition

605
00:22:26,640 --> 00:22:28,799
right out of the binary so you can see

606
00:22:28,799 --> 00:22:30,640
in this one there's the x map and then

607
00:22:30,640 --> 00:22:33,120
there's the id and the uri

608
00:22:33,120 --> 00:22:35,440
and for example for the uri there's the

609
00:22:35,440 --> 00:22:36,960
eight and the two and one of these is

610
00:22:36,960 --> 00:22:39,440
the field id and the other

611
00:22:39,440 --> 00:22:43,039
is the type of the field and i used this

612
00:22:43,039 --> 00:22:46,559
to create the schema and then i was able

613
00:22:46,559 --> 00:22:48,240
to go through

614
00:22:48,240 --> 00:22:51,360
and find the entire format of a p2p

615
00:22:51,360 --> 00:22:52,559
message

616
00:22:52,559 --> 00:22:54,880
in facebook thrift which is a facebook

617
00:22:54,880 --> 00:22:57,280
messenger's message format this took

618
00:22:57,280 --> 00:22:58,880
quite a long time

619
00:22:58,880 --> 00:23:02,000
this ended up being a roughly 300 line

620
00:23:02,000 --> 00:23:04,880
definition in facebook thrift

621
00:23:04,880 --> 00:23:07,440
but i was able to do some cool things

622
00:23:07,440 --> 00:23:08,640
with it

623
00:23:08,640 --> 00:23:10,320
i

624
00:23:10,320 --> 00:23:13,840
was first able to

625
00:23:13,840 --> 00:23:15,600
compile it in c

626
00:23:15,600 --> 00:23:18,880
and then load that compilation into ida

627
00:23:18,880 --> 00:23:21,360
so that i could read the packet types

628
00:23:21,360 --> 00:23:23,760
out of

629
00:23:23,760 --> 00:23:25,520
read the packet types in ida and figure

630
00:23:25,520 --> 00:23:27,679
out how the packets were handled i was

631
00:23:27,679 --> 00:23:30,559
also able to compile this with

632
00:23:30,559 --> 00:23:32,880
thrift in python and i was able to load

633
00:23:32,880 --> 00:23:35,600
that python into frida

634
00:23:35,600 --> 00:23:37,039
and then what was cool about that is

635
00:23:37,039 --> 00:23:39,360
that i could use this to create my own

636
00:23:39,360 --> 00:23:41,520
facebook thrift messages and send them

637
00:23:41,520 --> 00:23:44,559
and this is how i decoded this

638
00:23:44,559 --> 00:23:46,640
facebook thrift message and i want to

639
00:23:46,640 --> 00:23:48,400
say that this was something that took a

640
00:23:48,400 --> 00:23:50,240
huge amount of time it took about a

641
00:23:50,240 --> 00:23:52,480
month to figure out how to do this and i

642
00:23:52,480 --> 00:23:55,039
actually tried two other times and spent

643
00:23:55,039 --> 00:23:57,120
two weeks and then gave up

644
00:23:57,120 --> 00:23:59,200
so just in case you're wondering is it

645
00:23:59,200 --> 00:24:00,799
possible to figure out some of these

646
00:24:00,799 --> 00:24:02,320
custom formats for messaging

647
00:24:02,320 --> 00:24:04,400
applications and use them to find this

648
00:24:04,400 --> 00:24:06,559
type of bug yes it is though it's time

649
00:24:06,559 --> 00:24:07,840
consuming

650
00:24:07,840 --> 00:24:10,159
but in the end i did manage to

651
00:24:10,159 --> 00:24:12,159
be able to decode and create these

652
00:24:12,159 --> 00:24:14,559
message types well enough that

653
00:24:14,559 --> 00:24:16,240
i could

654
00:24:16,240 --> 00:24:18,480
find and reproduce this issue

655
00:24:18,480 --> 00:24:20,720
in facebook messenger

656
00:24:20,720 --> 00:24:22,400
so what's the root causes of these types

657
00:24:22,400 --> 00:24:24,559
of issues i think the main one is lack

658
00:24:24,559 --> 00:24:26,320
of understanding of this vulnerability

659
00:24:26,320 --> 00:24:27,360
type

660
00:24:27,360 --> 00:24:28,240
it

661
00:24:28,240 --> 00:24:30,559
was unprecedented until that face time

662
00:24:30,559 --> 00:24:32,720
bug occurred so i think part of the

663
00:24:32,720 --> 00:24:34,720
problem is just developers don't know

664
00:24:34,720 --> 00:24:36,720
that this can happen they don't know

665
00:24:36,720 --> 00:24:39,440
they need to be careful about it and

666
00:24:39,440 --> 00:24:40,960
they don't know that they need to test

667
00:24:40,960 --> 00:24:42,720
their state machines for this sort of

668
00:24:42,720 --> 00:24:43,600
thing

669
00:24:43,600 --> 00:24:45,520
i also think that

670
00:24:45,520 --> 00:24:48,080
some developers don't understand all the

671
00:24:48,080 --> 00:24:50,159
webrtc features

672
00:24:50,159 --> 00:24:51,919
and honestly they aren't always well

673
00:24:51,919 --> 00:24:54,320
documented though that's getting better

674
00:24:54,320 --> 00:24:57,039
and this leads to these vulnerabilities

675
00:24:57,039 --> 00:24:59,279
and finally there is this design choice

676
00:24:59,279 --> 00:25:01,919
of whether you set up the pdp connection

677
00:25:01,919 --> 00:25:04,000
before the call is answered and i went

678
00:25:04,000 --> 00:25:05,679
over with what the trade-offs are but

679
00:25:05,679 --> 00:25:08,080
just a reminder if you don't do anything

680
00:25:08,080 --> 00:25:10,320
before a call is answered there's no

681
00:25:10,320 --> 00:25:12,080
attack surface

682
00:25:12,080 --> 00:25:15,039
and then there is basically no chance of

683
00:25:15,039 --> 00:25:16,799
fully remote vulnerability zero click

684
00:25:16,799 --> 00:25:18,559
vulnerabilities because the user has to

685
00:25:18,559 --> 00:25:21,039
click for there to be any attack surface

686
00:25:21,039 --> 00:25:23,120
and that's the most secure design even

687
00:25:23,120 --> 00:25:25,360
though there are downsides with regards

688
00:25:25,360 --> 00:25:27,840
to performance

689
00:25:27,840 --> 00:25:29,840
um in conclusion

690
00:25:29,840 --> 00:25:32,240
video conferencing signaling state bugs

691
00:25:32,240 --> 00:25:34,159
are common

692
00:25:34,159 --> 00:25:36,799
i looked at several applications and

693
00:25:36,799 --> 00:25:38,799
basically every application i looked at

694
00:25:38,799 --> 00:25:40,240
had this bug

695
00:25:40,240 --> 00:25:42,080
when the facetime bug came out it seemed

696
00:25:42,080 --> 00:25:43,919
special and unique but it was really

697
00:25:43,919 --> 00:25:45,440
because no one had looked for this type

698
00:25:45,440 --> 00:25:47,039
of bug

699
00:25:47,039 --> 00:25:48,640
and most apps i looked at were

700
00:25:48,640 --> 00:25:50,159
vulnerable

701
00:25:50,159 --> 00:25:51,600
some of these problems can be attributed

702
00:25:51,600 --> 00:25:53,200
to webrtc

703
00:25:53,200 --> 00:25:55,840
it's designed as documentation but a lot

704
00:25:55,840 --> 00:25:57,919
of them can't most of them it was

705
00:25:57,919 --> 00:26:00,320
actually the application developers that

706
00:26:00,320 --> 00:26:02,080
made the mistake

707
00:26:02,080 --> 00:26:03,440
so i think it's important that

708
00:26:03,440 --> 00:26:04,960
developers be careful when they design

709
00:26:04,960 --> 00:26:06,720
their calling state machines it's

710
00:26:06,720 --> 00:26:08,000
important that people be aware of this

711
00:26:08,000 --> 00:26:09,440
type of bug

712
00:26:09,440 --> 00:26:11,279
and people be aware

713
00:26:11,279 --> 00:26:12,960
that their state machines don't just

714
00:26:12,960 --> 00:26:14,880
need to work they need to consider the

715
00:26:14,880 --> 00:26:18,159
possibility that attackers are going to

716
00:26:18,159 --> 00:26:19,919
try and use it to connect a call without

717
00:26:19,919 --> 00:26:22,159
a user's consent and finally i just want

718
00:26:22,159 --> 00:26:24,000
to say that this is an area that needs

719
00:26:24,000 --> 00:26:25,600
more research

720
00:26:25,600 --> 00:26:28,159
so i only looked at one-on-one calls in

721
00:26:28,159 --> 00:26:30,000
this i only looked at calls where one

722
00:26:30,000 --> 00:26:31,440
person calls another person and they

723
00:26:31,440 --> 00:26:34,720
answer i didn't even look at group calls

724
00:26:34,720 --> 00:26:35,600
and this was the number of

725
00:26:35,600 --> 00:26:37,520
vulnerabilities i found so i think if

726
00:26:37,520 --> 00:26:39,360
someone looks at this even more debt in

727
00:26:39,360 --> 00:26:41,919
even more depth there's probably even

728
00:26:41,919 --> 00:26:44,480
more bugs like that so i'm hoping that

729
00:26:44,480 --> 00:26:46,880
this talk can be a starting point

730
00:26:46,880 --> 00:26:48,880
and other people can think more about

731
00:26:48,880 --> 00:26:51,600
this and find other cool calling mistake

732
00:26:51,600 --> 00:26:54,159
machines bugs

733
00:26:54,159 --> 00:26:55,520
so that's it

734
00:26:55,520 --> 00:26:57,679
thanks a lot we'll now have time for

735
00:26:57,679 --> 00:26:59,840
questions and if i don't get to your

736
00:26:59,840 --> 00:27:02,480
question feel free to check out our blog

737
00:27:02,480 --> 00:27:05,600
or feel free to contact me i love

738
00:27:05,600 --> 00:27:07,679
answering questions from people thanks a

739
00:27:07,679 --> 00:27:10,679
lot

