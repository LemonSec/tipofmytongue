1
00:00:01,130 --> 00:00:13,759
[Music]

2
00:00:13,759 --> 00:00:16,000
hi everyone i'm matthew and today saba

3
00:00:16,000 --> 00:00:17,199
and i are going to be telling you about

4
00:00:17,199 --> 00:00:18,880
deep reach which is an attack that we

5
00:00:18,880 --> 00:00:22,400
developed against databases

6
00:00:23,279 --> 00:00:24,880
encryption is one of the most important

7
00:00:24,880 --> 00:00:26,960
tools for protecting sensitive data both

8
00:00:26,960 --> 00:00:28,960
at rest and in transit

9
00:00:28,960 --> 00:00:30,640
additionally compression is often

10
00:00:30,640 --> 00:00:32,880
carried paired with encryption in order

11
00:00:32,880 --> 00:00:34,800
to save on storage costs

12
00:00:34,800 --> 00:00:36,880
however combining the two can be risky

13
00:00:36,880 --> 00:00:38,719
and sometimes leak the underlying plain

14
00:00:38,719 --> 00:00:40,320
text information

15
00:00:40,320 --> 00:00:42,079
this class of vulnerabilities is known

16
00:00:42,079 --> 00:00:45,680
as a compression side channel

17
00:00:45,680 --> 00:00:47,280
one context in which encryption and

18
00:00:47,280 --> 00:00:49,120
compression are commonly combined is in

19
00:00:49,120 --> 00:00:51,600
databases which brings us to our attack

20
00:00:51,600 --> 00:00:53,120
debreach

21
00:00:53,120 --> 00:00:55,039
in debreach an attacker is able to

22
00:00:55,039 --> 00:00:57,520
recover other uses and users encrypted

23
00:00:57,520 --> 00:00:59,680
content by utilizing a compression psi

24
00:00:59,680 --> 00:01:00,960
channel

25
00:01:00,960 --> 00:01:03,280
we were able to extend on techniques and

26
00:01:03,280 --> 00:01:06,560
the name of the crime and breach attacks

27
00:01:06,560 --> 00:01:07,920
beyond

28
00:01:07,920 --> 00:01:09,840
the web security context and to the

29
00:01:09,840 --> 00:01:12,400
database context and debreach is

30
00:01:12,400 --> 00:01:14,400
we believe the first

31
00:01:14,400 --> 00:01:16,240
compression side channel attack on a

32
00:01:16,240 --> 00:01:19,600
real world database system

33
00:01:21,280 --> 00:01:22,799
just a quick roadmap of what we're going

34
00:01:22,799 --> 00:01:24,720
to talk about today so saba is going to

35
00:01:24,720 --> 00:01:27,759
walk you through some background on

36
00:01:27,759 --> 00:01:29,759
encryption and compression and databases

37
00:01:29,759 --> 00:01:32,000
and side channel tasks in general then

38
00:01:32,000 --> 00:01:33,119
i'm going to tell you about how our

39
00:01:33,119 --> 00:01:34,720
attack works

40
00:01:34,720 --> 00:01:36,640
some of the implementation roadblocks

41
00:01:36,640 --> 00:01:39,680
and solutions that we came up with

42
00:01:39,680 --> 00:01:40,960
i'm going to talk about how efficient

43
00:01:40,960 --> 00:01:42,479
and accurate we were able to make our

44
00:01:42,479 --> 00:01:43,520
attack

45
00:01:43,520 --> 00:01:44,799
and then finally i'm going to discuss

46
00:01:44,799 --> 00:01:47,680
some possible mitigation so that you uh

47
00:01:47,680 --> 00:01:50,320
you will be able to avoid this attack or

48
00:01:50,320 --> 00:01:52,960
similar attacks on your own systems

49
00:01:52,960 --> 00:01:54,560
and now i'm going to hand it over to

50
00:01:54,560 --> 00:01:56,159
sabo to give you some necessary

51
00:01:56,159 --> 00:01:58,399
background information all right thanks

52
00:01:58,399 --> 00:02:01,520
matthew so let's start out by

53
00:02:01,520 --> 00:02:03,040
um talking about what we mean when we

54
00:02:03,040 --> 00:02:04,560
say an encryption scheme is secure so

55
00:02:04,560 --> 00:02:05,920
when we say encryption is secure

56
00:02:05,920 --> 00:02:07,520
informally we're saying that a cipher

57
00:02:07,520 --> 00:02:09,520
text reveals nothing about the message

58
00:02:09,520 --> 00:02:11,599
that's being encrypted

59
00:02:11,599 --> 00:02:14,000
except the message's length and this

60
00:02:14,000 --> 00:02:15,680
accept the message's length is the piece

61
00:02:15,680 --> 00:02:17,200
that kind of allows compression side

62
00:02:17,200 --> 00:02:19,200
channel attacks to happen so what a

63
00:02:19,200 --> 00:02:20,800
compression side channel is going to do

64
00:02:20,800 --> 00:02:23,040
the key idea is to use compression to

65
00:02:23,040 --> 00:02:25,520
reveal messages length

66
00:02:25,520 --> 00:02:27,120
and then by looking at length

67
00:02:27,120 --> 00:02:28,319
information we're able to learn

68
00:02:28,319 --> 00:02:30,000
something about the message contents and

69
00:02:30,000 --> 00:02:31,040
that's where the compression side

70
00:02:31,040 --> 00:02:33,360
channel comes from so messages that

71
00:02:33,360 --> 00:02:35,040
compress more are shorter messages that

72
00:02:35,040 --> 00:02:39,120
compress less are larger and if you can

73
00:02:39,120 --> 00:02:40,480
set it so that learning something about

74
00:02:40,480 --> 00:02:42,480
the message length tells you about the

75
00:02:42,480 --> 00:02:44,319
the message content then you have a

76
00:02:44,319 --> 00:02:46,319
compression side channel

77
00:02:46,319 --> 00:02:47,760
so compression side channels have

78
00:02:47,760 --> 00:02:49,599
famously been used in the crime and

79
00:02:49,599 --> 00:02:53,040
breach attacks to break tls and i'm

80
00:02:53,040 --> 00:02:54,640
going to give a very very high level

81
00:02:54,640 --> 00:02:56,080
overview of the intuition behind these

82
00:02:56,080 --> 00:02:58,080
attacks just so we can draw some lessons

83
00:02:58,080 --> 00:02:59,519
on how compression side channels can be

84
00:02:59,519 --> 00:03:00,400
used

85
00:03:00,400 --> 00:03:02,400
so the setting here is we have a client

86
00:03:02,400 --> 00:03:04,720
and a server who have a compressed and

87
00:03:04,720 --> 00:03:06,400
encrypted channel between the two of

88
00:03:06,400 --> 00:03:08,480
them over which they send secret

89
00:03:08,480 --> 00:03:10,480
information that they that they want to

90
00:03:10,480 --> 00:03:11,920
send to each other

91
00:03:11,920 --> 00:03:13,200
and there's an attacker who wants to

92
00:03:13,200 --> 00:03:14,239
learn the secrets that they're

93
00:03:14,239 --> 00:03:16,640
communicating with each other

94
00:03:16,640 --> 00:03:18,560
so what the attacker has to be able to

95
00:03:18,560 --> 00:03:20,080
do to make this attack work is the

96
00:03:20,080 --> 00:03:21,440
attacker has a guess as to what the

97
00:03:21,440 --> 00:03:22,959
secrets might be

98
00:03:22,959 --> 00:03:24,720
and the attacker gets the client to

99
00:03:24,720 --> 00:03:26,239
include its guess in the messages that

100
00:03:26,239 --> 00:03:28,319
it sends to the server so for example

101
00:03:28,319 --> 00:03:30,000
the attacker could be the client might

102
00:03:30,000 --> 00:03:31,280
navigate to a web page that has some

103
00:03:31,280 --> 00:03:33,360
malicious javascript and the javascript

104
00:03:33,360 --> 00:03:35,280
gets the gets the client to send the

105
00:03:35,280 --> 00:03:36,959
attacker's guests as part of the

106
00:03:36,959 --> 00:03:38,480
messages that are sent over the secure

107
00:03:38,480 --> 00:03:40,480
channel so now the messages between the

108
00:03:40,480 --> 00:03:41,840
client and the server will include not

109
00:03:41,840 --> 00:03:43,040
only the secrets that they're sending

110
00:03:43,040 --> 00:03:44,959
back and forth but also the guests that

111
00:03:44,959 --> 00:03:46,640
the attacker has as to what the secrets

112
00:03:46,640 --> 00:03:48,400
might be

113
00:03:48,400 --> 00:03:50,720
the final step of the attack is for the

114
00:03:50,720 --> 00:03:52,640
adversary to be able to observe the size

115
00:03:52,640 --> 00:03:54,319
of the encrypted messages that are going

116
00:03:54,319 --> 00:03:55,680
back and forth between the server and

117
00:03:55,680 --> 00:03:57,840
the client and the idea is that the

118
00:03:57,840 --> 00:03:59,760
adversary is looking to see if the if

119
00:03:59,760 --> 00:04:01,120
the guest kind of compresses with the

120
00:04:01,120 --> 00:04:02,959
secrets so if the guess is correct and

121
00:04:02,959 --> 00:04:04,480
it's exactly the same as the secrets

122
00:04:04,480 --> 00:04:06,159
that are being sent back and forth these

123
00:04:06,159 --> 00:04:07,519
things will compress together and the

124
00:04:07,519 --> 00:04:09,680
message won't get that big so the

125
00:04:09,680 --> 00:04:10,879
adversary will know that it has a

126
00:04:10,879 --> 00:04:13,200
correct guess on the other hand if the

127
00:04:13,200 --> 00:04:14,720
guess and the secret don't compress with

128
00:04:14,720 --> 00:04:15,840
each other if they're just different

129
00:04:15,840 --> 00:04:16,959
things that are not compressible

130
00:04:16,959 --> 00:04:18,720
together then the attacker knows that it

131
00:04:18,720 --> 00:04:20,478
gets wrong and they can guess something

132
00:04:20,478 --> 00:04:21,839
else and it can do this iteratively

133
00:04:21,839 --> 00:04:23,919
until it gets the secrets right

134
00:04:23,919 --> 00:04:25,440
so let's zoom out and think about what

135
00:04:25,440 --> 00:04:27,280
the what is required to make an attack

136
00:04:27,280 --> 00:04:28,960
like this work

137
00:04:28,960 --> 00:04:30,320
so the first requirement is that

138
00:04:30,320 --> 00:04:31,840
encryption and compression have to be

139
00:04:31,840 --> 00:04:33,520
used together here

140
00:04:33,520 --> 00:04:35,280
and of course this is happening and it's

141
00:04:35,280 --> 00:04:38,000
important that encryption always comes

142
00:04:38,000 --> 00:04:40,400
after compression because if you

143
00:04:40,400 --> 00:04:42,479
compress before you encrypt then you get

144
00:04:42,479 --> 00:04:43,680
the compression and then you encrypt but

145
00:04:43,680 --> 00:04:45,759
if you uh do it the other way around

146
00:04:45,759 --> 00:04:47,520
then the encryption is going to make the

147
00:04:47,520 --> 00:04:49,440
messages look kind of random and random

148
00:04:49,440 --> 00:04:50,960
strings are incompressible so the

149
00:04:50,960 --> 00:04:52,479
compressor won't do anything for you so

150
00:04:52,479 --> 00:04:53,440
if you want to use encryption and

151
00:04:53,440 --> 00:04:55,120
compression together compression always

152
00:04:55,120 --> 00:04:56,560
has to come first

153
00:04:56,560 --> 00:04:58,400
that's the first requirement

154
00:04:58,400 --> 00:05:00,000
next requirement is the attacker is

155
00:05:00,000 --> 00:05:02,639
somehow able to inject messages into

156
00:05:02,639 --> 00:05:04,479
this compressed and encrypted channel

157
00:05:04,479 --> 00:05:06,800
between the client and the server

158
00:05:06,800 --> 00:05:08,320
and the third requirement is that the

159
00:05:08,320 --> 00:05:10,320
attacker has to have access to the size

160
00:05:10,320 --> 00:05:11,520
of the messages that are going back

161
00:05:11,520 --> 00:05:13,039
between these parties

162
00:05:13,039 --> 00:05:14,320
and the question we want to answer in

163
00:05:14,320 --> 00:05:16,479
this work is where else do all these

164
00:05:16,479 --> 00:05:18,240
factors come together

165
00:05:18,240 --> 00:05:20,400
and uh from the title and from math's

166
00:05:20,400 --> 00:05:22,560
introduction you know that databases are

167
00:05:22,560 --> 00:05:24,400
a place where all of these factors are

168
00:05:24,400 --> 00:05:26,400
going to come together

169
00:05:26,400 --> 00:05:28,880
so i'm going to give now some background

170
00:05:28,880 --> 00:05:30,639
on how encryption and compression work

171
00:05:30,639 --> 00:05:33,600
in mariadb and the nodb storage engine

172
00:05:33,600 --> 00:05:35,520
just because these are this is what we

173
00:05:35,520 --> 00:05:37,919
use to instantiate our attack although

174
00:05:37,919 --> 00:05:40,080
the attack in general can apply to many

175
00:05:40,080 --> 00:05:42,000
different dbmss and different storage

176
00:05:42,000 --> 00:05:43,199
engines

177
00:05:43,199 --> 00:05:45,600
so mariadb offers what's called data at

178
00:05:45,600 --> 00:05:47,840
rest encryption which is a feature that

179
00:05:47,840 --> 00:05:49,520
transparently encrypts data before

180
00:05:49,520 --> 00:05:50,880
writing to disk so it has a bunch of

181
00:05:50,880 --> 00:05:52,479
different offers for key management but

182
00:05:52,479 --> 00:05:54,000
ultimately what happens is whatever

183
00:05:54,000 --> 00:05:56,639
storage your engine you're using uh does

184
00:05:56,639 --> 00:05:58,080
its management of the tables in the

185
00:05:58,080 --> 00:05:59,440
database and then when it's time to

186
00:05:59,440 --> 00:06:01,440
write those tables to disk there is a

187
00:06:01,440 --> 00:06:03,520
transparent encryption step that happens

188
00:06:03,520 --> 00:06:05,039
just before the right to disk takes

189
00:06:05,039 --> 00:06:08,000
place easy enough

190
00:06:08,000 --> 00:06:10,080
also murray to be offers many options

191
00:06:10,080 --> 00:06:11,759
for compression

192
00:06:11,759 --> 00:06:12,960
which as i mentioned before always

193
00:06:12,960 --> 00:06:15,199
happens before the encryption so one is

194
00:06:15,199 --> 00:06:16,639
called storage engine independent

195
00:06:16,639 --> 00:06:18,960
compression this is a mariadb feature

196
00:06:18,960 --> 00:06:21,840
that uh kind of compresses the contents

197
00:06:21,840 --> 00:06:24,080
of each cell within a table this is good

198
00:06:24,080 --> 00:06:25,840
if you're if you have a database table

199
00:06:25,840 --> 00:06:27,680
that has like large strings or large

200
00:06:27,680 --> 00:06:29,280
blobs of text that you're putting into

201
00:06:29,280 --> 00:06:30,639
it and you just want to compress those

202
00:06:30,639 --> 00:06:32,720
things but it doesn't do any compression

203
00:06:32,720 --> 00:06:34,400
between different parts of a table so

204
00:06:34,400 --> 00:06:35,520
between different rows or different

205
00:06:35,520 --> 00:06:37,280
columns

206
00:06:37,280 --> 00:06:40,160
um then there is inno db's compression

207
00:06:40,160 --> 00:06:42,240
features which do allow this so innodb

208
00:06:42,240 --> 00:06:44,400
has table compression and transparent

209
00:06:44,400 --> 00:06:46,400
page compression which are two different

210
00:06:46,400 --> 00:06:48,400
compression offerings and i'm going to

211
00:06:48,400 --> 00:06:49,759
focus on the transparent page

212
00:06:49,759 --> 00:06:51,120
compression because it's the more recent

213
00:06:51,120 --> 00:06:53,199
one it has some performance benefits

214
00:06:53,199 --> 00:06:55,199
over the table compression it's also

215
00:06:55,199 --> 00:06:56,319
simpler and it's going to be the one

216
00:06:56,319 --> 00:06:58,400
that we're going to use in our attack

217
00:06:58,400 --> 00:07:00,400
so how does energy's page compression

218
00:07:00,400 --> 00:07:02,479
work well it handles compression

219
00:07:02,479 --> 00:07:04,240
transparently before encrypting and

220
00:07:04,240 --> 00:07:05,840
writing to disk so just like the

221
00:07:05,840 --> 00:07:07,440
encryption was transparent just before

222
00:07:07,440 --> 00:07:08,960
the write to disk the compression is

223
00:07:08,960 --> 00:07:10,639
going to transparently happen on the

224
00:07:10,639 --> 00:07:12,880
table before that table is encrypted and

225
00:07:12,880 --> 00:07:14,639
written to disk

226
00:07:14,639 --> 00:07:16,720
so how does this work the compression is

227
00:07:16,720 --> 00:07:18,800
going to compress the data within each

228
00:07:18,800 --> 00:07:21,599
database page so in the nodb storage

229
00:07:21,599 --> 00:07:23,759
engine um each

230
00:07:23,759 --> 00:07:26,000
table is broken up into 16 kilobyte

231
00:07:26,000 --> 00:07:27,199
pages

232
00:07:27,199 --> 00:07:29,360
and the compression feature is going to

233
00:07:29,360 --> 00:07:31,840
compress each of these pages separately

234
00:07:31,840 --> 00:07:33,599
before writing them to disk or before

235
00:07:33,599 --> 00:07:34,880
encrypting them and then writing them to

236
00:07:34,880 --> 00:07:36,800
disk so as you can see on the slide

237
00:07:36,800 --> 00:07:38,639
there's going to be some kind of empty

238
00:07:38,639 --> 00:07:40,479
space

239
00:07:40,479 --> 00:07:42,800
after each compressed page before the

240
00:07:42,800 --> 00:07:44,479
next page begins

241
00:07:44,479 --> 00:07:46,479
and what the file system is going to do

242
00:07:46,479 --> 00:07:47,759
is it's going to use a feature called

243
00:07:47,759 --> 00:07:50,080
hole punching to reclaim this empty

244
00:07:50,080 --> 00:07:52,560
space and use it for other stuff

245
00:07:52,560 --> 00:07:54,000
so what hole punching allows the file to

246
00:07:54,000 --> 00:07:55,919
do is if there's a file that's sparse

247
00:07:55,919 --> 00:07:57,680
and it has a big gap in it

248
00:07:57,680 --> 00:07:59,680
it can do a hole punch in the file and

249
00:07:59,680 --> 00:08:02,000
take that punch away and the hole punch

250
00:08:02,000 --> 00:08:03,280
has to be in a multiple of four

251
00:08:03,280 --> 00:08:04,639
kilobytes because the file system page

252
00:08:04,639 --> 00:08:06,400
is typically going to be four kilobytes

253
00:08:06,400 --> 00:08:08,160
and the hole punching kind of applies to

254
00:08:08,160 --> 00:08:10,560
whole pages at a time so if you have a

255
00:08:10,560 --> 00:08:12,240
little bit of extra compression beyond

256
00:08:12,240 --> 00:08:14,479
the one page mark or if the page

257
00:08:14,479 --> 00:08:16,639
if a database page doesn't compress

258
00:08:16,639 --> 00:08:18,720
enough to result in saving an entire

259
00:08:18,720 --> 00:08:20,479
file system page then there isn't going

260
00:08:20,479 --> 00:08:21,840
to be a hole punch

261
00:08:21,840 --> 00:08:25,120
and what this means is that uh

262
00:08:25,120 --> 00:08:26,879
this compression feature only helps when

263
00:08:26,879 --> 00:08:29,039
there's enough compression to remove a

264
00:08:29,039 --> 00:08:30,960
whole file system page

265
00:08:30,960 --> 00:08:33,039
otherwise you don't get the compression

266
00:08:33,039 --> 00:08:34,399
and this is important for our attack

267
00:08:34,399 --> 00:08:35,919
because it affects the granularity of

268
00:08:35,919 --> 00:08:37,919
information that an attacker can get

269
00:08:37,919 --> 00:08:40,399
about how much compression is happening

270
00:08:40,399 --> 00:08:43,039
in the database table

271
00:08:43,039 --> 00:08:44,560
so in terms of the actual compression

272
00:08:44,560 --> 00:08:47,120
algorithms that are being used um page

273
00:08:47,120 --> 00:08:48,640
compression

274
00:08:48,640 --> 00:08:49,839
supports a number of different

275
00:08:49,839 --> 00:08:53,200
algorithms but only zlib lz4 and snappy

276
00:08:53,200 --> 00:08:54,800
are installed by default in a standard

277
00:08:54,800 --> 00:08:56,720
ubuntu build

278
00:08:56,720 --> 00:08:58,399
and all three of these have a similar

279
00:08:58,399 --> 00:09:00,160
structure they begin with a sliding

280
00:09:00,160 --> 00:09:01,440
window compression where there's a

281
00:09:01,440 --> 00:09:03,360
sliding window that begins at the

282
00:09:03,360 --> 00:09:05,600
beginning of the page of the database

283
00:09:05,600 --> 00:09:08,000
page and whenever it finds a duplicate

284
00:09:08,000 --> 00:09:09,680
of a string that has occurred earlier in

285
00:09:09,680 --> 00:09:11,600
the window it'll remove the second

286
00:09:11,600 --> 00:09:13,440
instance of the string and replace it

287
00:09:13,440 --> 00:09:15,040
with a reference back to the first

288
00:09:15,040 --> 00:09:16,959
instance of the string what this means

289
00:09:16,959 --> 00:09:18,160
is the second instance of the string

290
00:09:18,160 --> 00:09:19,279
doesn't need to appear in the file

291
00:09:19,279 --> 00:09:21,279
anymore and that makes the file smaller

292
00:09:21,279 --> 00:09:24,000
allowing it to be compressed

293
00:09:24,000 --> 00:09:26,000
zlib has an additional step that's not

294
00:09:26,000 --> 00:09:27,839
present in the other two and this is a

295
00:09:27,839 --> 00:09:29,600
huffman coding step where at the end

296
00:09:29,600 --> 00:09:30,880
after doing the sliding window

297
00:09:30,880 --> 00:09:33,519
compression it compresses more

298
00:09:33,519 --> 00:09:35,040
frequently occurring strings by giving

299
00:09:35,040 --> 00:09:37,279
them shorter representations

300
00:09:37,279 --> 00:09:38,560
and this is something that matthew will

301
00:09:38,560 --> 00:09:40,399
talk about later that kind of has some

302
00:09:40,399 --> 00:09:42,000
complications for when it comes to

303
00:09:42,000 --> 00:09:44,640
making an attack on these things

304
00:09:44,640 --> 00:09:46,240
so with that background matthew's now

305
00:09:46,240 --> 00:09:51,000
gonna tell us about our actual attack

306
00:09:52,240 --> 00:09:53,519
thanks saba

307
00:09:53,519 --> 00:09:55,760
so first i want to talk a little bit

308
00:09:55,760 --> 00:09:57,279
about the threat model or the

309
00:09:57,279 --> 00:09:58,959
capabilities that an attacker needs to

310
00:09:58,959 --> 00:10:01,600
achieve in order to pull off the attack

311
00:10:01,600 --> 00:10:02,880
first of all an attacker needs the

312
00:10:02,880 --> 00:10:04,640
ability to insert and update into a

313
00:10:04,640 --> 00:10:06,640
database table

314
00:10:06,640 --> 00:10:08,160
also an attacker needs to be able to

315
00:10:08,160 --> 00:10:10,720
assess the size of the compressed table

316
00:10:10,720 --> 00:10:12,560
note that these two requirements mirror

317
00:10:12,560 --> 00:10:13,839
the requirements for the breach and

318
00:10:13,839 --> 00:10:15,440
crime attacks that saba talked about

319
00:10:15,440 --> 00:10:17,440
earlier

320
00:10:17,440 --> 00:10:18,959
we believe that this threat model is

321
00:10:18,959 --> 00:10:22,800
realistic and achievable and here's how

322
00:10:22,800 --> 00:10:24,480
insert and update capability can be

323
00:10:24,480 --> 00:10:26,399
achieved through a front-end web

324
00:10:26,399 --> 00:10:28,640
interface that's backed up by a database

325
00:10:28,640 --> 00:10:29,519
table

326
00:10:29,519 --> 00:10:30,959
something that's really common in a lot

327
00:10:30,959 --> 00:10:33,600
of databases for example if the table

328
00:10:33,600 --> 00:10:36,560
was account metadata the web interface

329
00:10:36,560 --> 00:10:39,600
could be your edit profile or create

330
00:10:39,600 --> 00:10:41,600
profile page

331
00:10:41,600 --> 00:10:43,360
additionally mariadb provides these

332
00:10:43,360 --> 00:10:46,160
things called column level permissions

333
00:10:46,160 --> 00:10:47,120
which

334
00:10:47,120 --> 00:10:48,000
can

335
00:10:48,000 --> 00:10:50,160
grant partial selectability on only

336
00:10:50,160 --> 00:10:51,519
certain columns

337
00:10:51,519 --> 00:10:53,839
and using this partial selectability an

338
00:10:53,839 --> 00:10:56,240
attacker can be can gain update ability

339
00:10:56,240 --> 00:10:58,480
on the entire table

340
00:10:58,480 --> 00:11:00,399
as long as they only read those columns

341
00:11:00,399 --> 00:11:02,640
while they're doing the updates

342
00:11:02,640 --> 00:11:03,839
so

343
00:11:03,839 --> 00:11:05,760
uh it would kind of be a coincidence for

344
00:11:05,760 --> 00:11:07,040
the permissions to be set up that way

345
00:11:07,040 --> 00:11:08,480
but it is possible for the database

346
00:11:08,480 --> 00:11:10,160
permissions to just be set up in such a

347
00:11:10,160 --> 00:11:11,920
way that you have insert and update

348
00:11:11,920 --> 00:11:13,600
capability but you can't read the whole

349
00:11:13,600 --> 00:11:15,839
table

350
00:11:15,839 --> 00:11:17,600
additionally to be able to assess the

351
00:11:17,600 --> 00:11:20,000
size of the compressed table an attacker

352
00:11:20,000 --> 00:11:22,399
can read the size of the table file file

353
00:11:22,399 --> 00:11:24,160
if they can gain read access to the file

354
00:11:24,160 --> 00:11:25,200
system

355
00:11:25,200 --> 00:11:26,880
so they need to gain some sort of read

356
00:11:26,880 --> 00:11:27,760
access

357
00:11:27,760 --> 00:11:29,360
but once they do they can just use a

358
00:11:29,360 --> 00:11:31,760
tool like ls to see how big the table

359
00:11:31,760 --> 00:11:34,880
space file is

360
00:11:35,519 --> 00:11:37,600
an attacker could also

361
00:11:37,600 --> 00:11:38,720
monitor

362
00:11:38,720 --> 00:11:40,480
network packets if

363
00:11:40,480 --> 00:11:42,720
if database backups were happening and

364
00:11:42,720 --> 00:11:45,120
see how big those were are but um that's

365
00:11:45,120 --> 00:11:47,839
probably more complicated and not as

366
00:11:47,839 --> 00:11:49,440
easy as just getting read access to the

367
00:11:49,440 --> 00:11:51,920
file system in most cases

368
00:11:51,920 --> 00:11:53,839
one final thing to note is that if an

369
00:11:53,839 --> 00:11:55,600
attacker is not able to achieve update

370
00:11:55,600 --> 00:11:57,360
permissions

371
00:11:57,360 --> 00:11:59,120
but can get right access on the file

372
00:11:59,120 --> 00:12:01,120
system then they can force an update by

373
00:12:01,120 --> 00:12:02,639
rolling back the table file and

374
00:12:02,639 --> 00:12:03,920
inserting

375
00:12:03,920 --> 00:12:06,399
so this requires more comprehensive file

376
00:12:06,399 --> 00:12:08,560
system access but fewer database

377
00:12:08,560 --> 00:12:10,560
permissions and it's just a

378
00:12:10,560 --> 00:12:12,399
different means of gaining the necessary

379
00:12:12,399 --> 00:12:14,320
capabilities um

380
00:12:14,320 --> 00:12:15,839
that would slow down the attack

381
00:12:15,839 --> 00:12:17,839
significantly though because

382
00:12:17,839 --> 00:12:19,680
forcibly rolling back the table is a lot

383
00:12:19,680 --> 00:12:22,160
slower than just running one update

384
00:12:22,160 --> 00:12:25,120
sql command

385
00:12:25,120 --> 00:12:26,720
now i'm going to talk a little bit about

386
00:12:26,720 --> 00:12:28,480
our attack algorithm

387
00:12:28,480 --> 00:12:29,920
and on the right here i'm going to keep

388
00:12:29,920 --> 00:12:32,320
this diagram of table layout

389
00:12:32,320 --> 00:12:34,720
in which this blue rectangle is one file

390
00:12:34,720 --> 00:12:37,440
system page so four kilobytes

391
00:12:37,440 --> 00:12:38,399
initially

392
00:12:38,399 --> 00:12:40,160
we just have some plain text that was

393
00:12:40,160 --> 00:12:42,639
inserted by other users

394
00:12:42,639 --> 00:12:44,240
that's represented by the green

395
00:12:44,240 --> 00:12:45,360
rectangle

396
00:12:45,360 --> 00:12:47,040
it could be any any number of rows as

397
00:12:47,040 --> 00:12:50,800
long as it fits on this file system page

398
00:12:50,800 --> 00:12:52,320
one thing to remember with this attack

399
00:12:52,320 --> 00:12:54,560
is we're only recovering information

400
00:12:54,560 --> 00:12:57,040
from the most recent file system page uh

401
00:12:57,040 --> 00:12:58,639
because that's how large the compression

402
00:12:58,639 --> 00:13:01,600
window is

403
00:13:01,600 --> 00:13:04,320
sorry we are only recovering information

404
00:13:04,320 --> 00:13:06,320
from the most recent database page

405
00:13:06,320 --> 00:13:07,680
because that's how large the compression

406
00:13:07,680 --> 00:13:10,239
window is

407
00:13:12,000 --> 00:13:14,079
first an attacker is going to add random

408
00:13:14,079 --> 00:13:17,440
filler rows until the table grows

409
00:13:17,440 --> 00:13:20,160
these filler rows are just normal rows

410
00:13:20,160 --> 00:13:22,000
with the text fields filled with some

411
00:13:22,000 --> 00:13:23,040
random

412
00:13:23,040 --> 00:13:25,120
non-compressible text

413
00:13:25,120 --> 00:13:26,320
they're going to keep inserting rows

414
00:13:26,320 --> 00:13:28,399
until they overflow the file system page

415
00:13:28,399 --> 00:13:31,839
and a new page is added

416
00:13:31,839 --> 00:13:34,079
once they overflow the page and a new

417
00:13:34,079 --> 00:13:35,360
one is added

418
00:13:35,360 --> 00:13:36,880
they're going to update the first filler

419
00:13:36,880 --> 00:13:38,880
row to contain their guess which is

420
00:13:38,880 --> 00:13:42,240
represented by that yellow box there

421
00:13:42,240 --> 00:13:44,959
one thing to uh or the key idea here is

422
00:13:44,959 --> 00:13:46,000
that if

423
00:13:46,000 --> 00:13:48,480
the guess is a repeated string from the

424
00:13:48,480 --> 00:13:50,000
target plain text

425
00:13:50,000 --> 00:13:51,120
then

426
00:13:51,120 --> 00:13:53,680
some compression will take place and if

427
00:13:53,680 --> 00:13:55,040
it's not then

428
00:13:55,040 --> 00:13:58,160
no compression will take place

429
00:13:58,160 --> 00:13:59,680
the attacker then wants to figure out

430
00:13:59,680 --> 00:14:01,839
how compressive how much the gas

431
00:14:01,839 --> 00:14:03,440
compressed with the plain text and to do

432
00:14:03,440 --> 00:14:05,839
so they're going to bite by bite make

433
00:14:05,839 --> 00:14:08,480
the filler rows compressible

434
00:14:08,480 --> 00:14:10,399
this takes the form

435
00:14:10,399 --> 00:14:12,800
in practice of just switching the text

436
00:14:12,800 --> 00:14:15,760
in the filler rows to all be the same

437
00:14:15,760 --> 00:14:18,079
character from whatever random filler

438
00:14:18,079 --> 00:14:19,519
they were before

439
00:14:19,519 --> 00:14:21,680
so the attacker goes by by

440
00:14:21,680 --> 00:14:23,120
making them compressible until

441
00:14:23,120 --> 00:14:25,440
eventually the whole table will have

442
00:14:25,440 --> 00:14:27,600
compressed enough such that it fits back

443
00:14:27,600 --> 00:14:30,560
on the old file system page and a hold

444
00:14:30,560 --> 00:14:32,399
punch will take place as sava talked

445
00:14:32,399 --> 00:14:34,320
about earlier

446
00:14:34,320 --> 00:14:35,839
so that whole bunch will happen the

447
00:14:35,839 --> 00:14:37,519
table will shrink

448
00:14:37,519 --> 00:14:39,519
and the number of bytes until the table

449
00:14:39,519 --> 00:14:41,120
shrinks is going to be what determines

450
00:14:41,120 --> 00:14:43,680
this guess's compressibility score and

451
00:14:43,680 --> 00:14:44,720
that's what we're going to use to

452
00:14:44,720 --> 00:14:47,839
compare guesses against each other

453
00:14:47,839 --> 00:14:49,440
the key idea behind compressibility

454
00:14:49,440 --> 00:14:51,199
scores is just that a guess that results

455
00:14:51,199 --> 00:14:53,360
in a more compressible table layout

456
00:14:53,360 --> 00:14:55,600
because it is repeated from the target

457
00:14:55,600 --> 00:14:57,199
plaintext should have a higher

458
00:14:57,199 --> 00:15:00,319
compressibility score

459
00:15:00,560 --> 00:15:02,480
we're going to calculate it uh

460
00:15:02,480 --> 00:15:05,199
by defining this term bg

461
00:15:05,199 --> 00:15:07,519
for guess g which is the number of bytes

462
00:15:07,519 --> 00:15:08,880
that we made compressible in order to

463
00:15:08,880 --> 00:15:10,480
shrink the table that's represented by

464
00:15:10,480 --> 00:15:12,320
the gray portion in this table layout

465
00:15:12,320 --> 00:15:13,440
diagram

466
00:15:13,440 --> 00:15:14,880
we're then just going to say that the

467
00:15:14,880 --> 00:15:18,399
compressibility score cg is 1 over bg

468
00:15:18,399 --> 00:15:20,160
so therefore if a guess was very

469
00:15:20,160 --> 00:15:21,760
compressible with the target plaintext

470
00:15:21,760 --> 00:15:24,959
it would take fewer bytes in order to it

471
00:15:24,959 --> 00:15:26,720
would take uh switching fewer bytes in

472
00:15:26,720 --> 00:15:28,959
order to compress the table or shrink

473
00:15:28,959 --> 00:15:30,240
the table

474
00:15:30,240 --> 00:15:32,160
and therefore

475
00:15:32,160 --> 00:15:33,600
uh the compressibility score will be

476
00:15:33,600 --> 00:15:34,480
higher

477
00:15:34,480 --> 00:15:36,399
whereas if a guess did not compress the

478
00:15:36,399 --> 00:15:38,399
target plaintext it will take

479
00:15:38,399 --> 00:15:40,399
more bytes and therefore the

480
00:15:40,399 --> 00:15:44,399
compressibility score will be lower

481
00:15:45,120 --> 00:15:46,480
so

482
00:15:46,480 --> 00:15:48,560
the aforementioned algorithm kind of

483
00:15:48,560 --> 00:15:51,040
lends itself very nicely to two main

484
00:15:51,040 --> 00:15:53,680
attack varieties the first one is the k

485
00:15:53,680 --> 00:15:57,279
of n attack which is given n options

486
00:15:57,279 --> 00:15:59,360
which k are most likely to be in the

487
00:15:59,360 --> 00:16:01,120
table

488
00:16:01,120 --> 00:16:03,680
and implementing this uh given the prior

489
00:16:03,680 --> 00:16:05,680
algorithm is is pretty simple it's just

490
00:16:05,680 --> 00:16:07,839
we run that algorithm on all n of the

491
00:16:07,839 --> 00:16:09,680
guesses and we pick the k guesses with

492
00:16:09,680 --> 00:16:12,480
the highest compressibility scores

493
00:16:12,480 --> 00:16:14,880
um so now that you have some algorithmic

494
00:16:14,880 --> 00:16:16,320
background i'm going to pause from the

495
00:16:16,320 --> 00:16:18,800
presentation briefly and and start a

496
00:16:18,800 --> 00:16:20,560
little demo so you can see the kvn

497
00:16:20,560 --> 00:16:23,839
attack in action

498
00:16:24,320 --> 00:16:25,279
so

499
00:16:25,279 --> 00:16:28,320
i have here a list of 500 names that

500
00:16:28,320 --> 00:16:30,480
were just randomly generated from

501
00:16:30,480 --> 00:16:33,920
commonly used names in the us

502
00:16:33,920 --> 00:16:36,079
and i'm going to generate a random

503
00:16:36,079 --> 00:16:37,920
number

504
00:16:37,920 --> 00:16:40,240
110. so we're going to take the name at

505
00:16:40,240 --> 00:16:42,800
index 110

506
00:16:42,800 --> 00:16:46,000
named villanueva

507
00:16:47,440 --> 00:16:49,839
and this name is going to be inserted

508
00:16:49,839 --> 00:16:51,440
into the table that we're about to set

509
00:16:51,440 --> 00:16:52,560
up

510
00:16:52,560 --> 00:16:54,320
now i'm going to do some quick table

511
00:16:54,320 --> 00:16:56,720
setup

512
00:16:58,000 --> 00:16:59,440
make sure that

513
00:16:59,440 --> 00:17:04,279
the table is not currently there

514
00:17:07,679 --> 00:17:11,839
now going to create a table

515
00:17:12,880 --> 00:17:15,439
um so the table in this case is just

516
00:17:15,439 --> 00:17:18,240
going to consist of a primary key id

517
00:17:18,240 --> 00:17:19,919
which is an integer

518
00:17:19,919 --> 00:17:22,240
and a varchar data field which will

519
00:17:22,240 --> 00:17:23,760
contain the name

520
00:17:23,760 --> 00:17:26,480
um the engine is in adb compression and

521
00:17:26,480 --> 00:17:28,160
encryption are both on so we're going to

522
00:17:28,160 --> 00:17:29,919
create it

523
00:17:29,919 --> 00:17:31,520
we're now going to insert the name that

524
00:17:31,520 --> 00:17:33,840
we just randomly chose into the victim

525
00:17:33,840 --> 00:17:36,240
table

526
00:17:37,039 --> 00:17:38,960
and then finally just going to confirm

527
00:17:38,960 --> 00:17:40,640
that that is the only thing in the table

528
00:17:40,640 --> 00:17:41,760
right now

529
00:17:41,760 --> 00:17:43,760
there you have it there's one row in the

530
00:17:43,760 --> 00:17:45,440
table

531
00:17:45,440 --> 00:17:48,160
now going to run

532
00:17:48,160 --> 00:17:50,320
our attack

533
00:17:50,320 --> 00:17:52,320
in order to

534
00:17:52,320 --> 00:17:56,250
figure out what we just inserted so

535
00:17:56,250 --> 00:17:59,359
[Music]

536
00:17:59,440 --> 00:18:00,880
we're going to run this demo it's going

537
00:18:00,880 --> 00:18:02,160
to take a second but you're going to see

538
00:18:02,160 --> 00:18:04,960
that it's inserting filler rows

539
00:18:04,960 --> 00:18:06,320
um

540
00:18:06,320 --> 00:18:08,960
it took 29 insertions for the table it's

541
00:18:08,960 --> 00:18:10,320
calculating some reference scores i'm

542
00:18:10,320 --> 00:18:12,080
going to talk about that in a second and

543
00:18:12,080 --> 00:18:14,559
now it's starting to try each guess so

544
00:18:14,559 --> 00:18:16,880
the actual act of trying the guesses um

545
00:18:16,880 --> 00:18:17,840
takes

546
00:18:17,840 --> 00:18:19,120
a couple minutes

547
00:18:19,120 --> 00:18:19,919
so

548
00:18:19,919 --> 00:18:21,520
i'm going to return to the presentation

549
00:18:21,520 --> 00:18:22,880
and we're going to check in later to see

550
00:18:22,880 --> 00:18:25,280
how we did

551
00:18:26,480 --> 00:18:28,480
in addition to the k of n attack there's

552
00:18:28,480 --> 00:18:30,000
another attack that the prior algorithm

553
00:18:30,000 --> 00:18:31,600
really lends itself to

554
00:18:31,600 --> 00:18:33,360
and that's the decision attack which

555
00:18:33,360 --> 00:18:35,760
just asks for a given guess is it in the

556
00:18:35,760 --> 00:18:38,720
table yes or no

557
00:18:39,039 --> 00:18:40,880
this is decidedly more complicated than

558
00:18:40,880 --> 00:18:43,120
the k of n attack mainly because we need

559
00:18:43,120 --> 00:18:44,640
a reference point for the

560
00:18:44,640 --> 00:18:46,400
compressibility scores

561
00:18:46,400 --> 00:18:47,919
we need to know what does the positive

562
00:18:47,919 --> 00:18:48,960
case look like and what does the

563
00:18:48,960 --> 00:18:50,320
negative case look like what do the

564
00:18:50,320 --> 00:18:51,919
scores mean

565
00:18:51,919 --> 00:18:53,280
to find these reference points we're

566
00:18:53,280 --> 00:18:54,640
going to calculate compressibility

567
00:18:54,640 --> 00:18:56,880
scores scs and snow for strings that we

568
00:18:56,880 --> 00:18:59,840
know are in and not in the table

569
00:18:59,840 --> 00:19:01,679
to determine sks what we're going to do

570
00:19:01,679 --> 00:19:03,200
is we're going to take a substring from

571
00:19:03,200 --> 00:19:04,640
the first filler route that's the same

572
00:19:04,640 --> 00:19:06,240
length as the guess and we're going to

573
00:19:06,240 --> 00:19:08,080
insert it into the second failure and

574
00:19:08,080 --> 00:19:08,960
then we're going to determine the

575
00:19:08,960 --> 00:19:11,919
compressibility score of that layout

576
00:19:11,919 --> 00:19:14,400
so this is kind of mocking the positive

577
00:19:14,400 --> 00:19:16,320
case because we know for a fact that

578
00:19:16,320 --> 00:19:18,000
there's a repeated string that we just

579
00:19:18,000 --> 00:19:20,320
inserted into the filler data

580
00:19:20,320 --> 00:19:21,679
to determine snow we're going to do

581
00:19:21,679 --> 00:19:23,039
something very similar but we're going

582
00:19:23,039 --> 00:19:24,720
to use a random string instead of a

583
00:19:24,720 --> 00:19:26,880
repeated substring

584
00:19:26,880 --> 00:19:28,480
the idea here is that the random string

585
00:19:28,480 --> 00:19:30,480
is very unlikely to occur elsewhere in

586
00:19:30,480 --> 00:19:32,559
the table

587
00:19:32,559 --> 00:19:34,080
then with these reference points we're

588
00:19:34,080 --> 00:19:36,160
going to say that a guesses score if a

589
00:19:36,160 --> 00:19:37,840
guesses score is within some threshold

590
00:19:37,840 --> 00:19:41,039
of ses relative to snow we answer yes

591
00:19:41,039 --> 00:19:42,400
the reason why we need to do some

592
00:19:42,400 --> 00:19:44,320
threshold instead of trying to do an

593
00:19:44,320 --> 00:19:46,880
exact match is because as i'm going to

594
00:19:46,880 --> 00:19:48,480
talk about in a little bit there are

595
00:19:48,480 --> 00:19:50,160
some sources of noise in the side

596
00:19:50,160 --> 00:19:53,520
channel that can obscure how uh what the

597
00:19:53,520 --> 00:19:57,200
compressibility scores precisely mean

598
00:19:57,600 --> 00:19:59,600
one final attack that we can build out

599
00:19:59,600 --> 00:20:01,679
of our prior algorithm is a character by

600
00:20:01,679 --> 00:20:02,640
character

601
00:20:02,640 --> 00:20:05,120
extraction attack in which we use a k of

602
00:20:05,120 --> 00:20:08,320
n attack as a subroutine to extract the

603
00:20:08,320 --> 00:20:11,520
plain text one character at a time

604
00:20:11,520 --> 00:20:12,640
um so i'm going to talk through the

605
00:20:12,640 --> 00:20:15,679
basic algorithm for this type of attack

606
00:20:15,679 --> 00:20:16,880
and then i'm also going to talk about

607
00:20:16,880 --> 00:20:18,960
some difficulties that we've encountered

608
00:20:18,960 --> 00:20:20,400
and we're currently encountering while

609
00:20:20,400 --> 00:20:23,120
implementing this

610
00:20:23,360 --> 00:20:25,280
so we start with some known prefix that

611
00:20:25,280 --> 00:20:27,200
we strongly believe occurs in the table

612
00:20:27,200 --> 00:20:29,440
in this case the secret code is

613
00:20:29,440 --> 00:20:31,440
from the prefix we're going to generate

614
00:20:31,440 --> 00:20:34,559
n guesses where n is the size of the

615
00:20:34,559 --> 00:20:36,559
size of the alphabet of all possible

616
00:20:36,559 --> 00:20:37,840
characters

617
00:20:37,840 --> 00:20:40,080
so if we're doing all english uppercase

618
00:20:40,080 --> 00:20:42,080
and lowercase characters n would be 52

619
00:20:42,080 --> 00:20:44,000
for example

620
00:20:44,000 --> 00:20:46,159
these n guesses are going to be fed into

621
00:20:46,159 --> 00:20:47,600
a one of n

622
00:20:47,600 --> 00:20:50,400
attack sub module which will pick which

623
00:20:50,400 --> 00:20:54,720
one option is most likely out of all 52

624
00:20:54,720 --> 00:20:56,799
or all n

625
00:20:56,799 --> 00:20:58,400
in this case let's say that the first

626
00:20:58,400 --> 00:21:01,120
case a is the most likely

627
00:21:01,120 --> 00:21:02,720
we're going to take the most likely case

628
00:21:02,720 --> 00:21:04,240
and we're going to make it the new

629
00:21:04,240 --> 00:21:05,840
prefix

630
00:21:05,840 --> 00:21:08,159
from the new prefix we're going to

631
00:21:08,159 --> 00:21:10,640
generate a new set of n guesses and

632
00:21:10,640 --> 00:21:12,240
repeat over and over until we've

633
00:21:12,240 --> 00:21:15,520
extracted the entire plaintext

634
00:21:15,520 --> 00:21:17,760
um one thing to note here however is

635
00:21:17,760 --> 00:21:19,600
that

636
00:21:19,600 --> 00:21:21,280
if you look at these n guesses the

637
00:21:21,280 --> 00:21:23,200
correct option and the incorrect option

638
00:21:23,200 --> 00:21:25,600
only differ by one character

639
00:21:25,600 --> 00:21:26,880
therefore we expect that their

640
00:21:26,880 --> 00:21:28,960
compressibility scores will be quite

641
00:21:28,960 --> 00:21:30,559
similar

642
00:21:30,559 --> 00:21:32,400
and we're a lot more vulnerable to

643
00:21:32,400 --> 00:21:34,720
sources of noise in the side channel as

644
00:21:34,720 --> 00:21:36,960
such this is still a work in progress

645
00:21:36,960 --> 00:21:38,559
and we're working on developing a

646
00:21:38,559 --> 00:21:41,039
practical and accurate implementation

647
00:21:41,039 --> 00:21:42,559
but we believe that the eventual

648
00:21:42,559 --> 00:21:44,480
solution will consist of this basic

649
00:21:44,480 --> 00:21:46,960
algorithm

650
00:21:47,039 --> 00:21:48,320
now i'm going to talk through some

651
00:21:48,320 --> 00:21:50,159
roadblocks that we encountered

652
00:21:50,159 --> 00:21:51,440
while uh

653
00:21:51,440 --> 00:21:53,280
while implementing our attack and the

654
00:21:53,280 --> 00:21:56,400
solutions that we use to overcome them

655
00:21:56,400 --> 00:21:59,120
one problem that we saw uh repeatedly

656
00:21:59,120 --> 00:22:00,320
was what we ended up calling the

657
00:22:00,320 --> 00:22:02,880
substring super string problem

658
00:22:02,880 --> 00:22:04,799
we saw that we got a much higher rate of

659
00:22:04,799 --> 00:22:06,320
false positives when a guess is a

660
00:22:06,320 --> 00:22:08,480
substring or a superstring that is what

661
00:22:08,480 --> 00:22:10,000
is in the table is a substring of the

662
00:22:10,000 --> 00:22:11,039
guess

663
00:22:11,039 --> 00:22:12,640
in the substring case

664
00:22:12,640 --> 00:22:13,919
we see that

665
00:22:13,919 --> 00:22:17,360
the guess can is not an exact match for

666
00:22:17,360 --> 00:22:19,600
the plaintext but the ground in the

667
00:22:19,600 --> 00:22:22,000
guess will match with the ground truth

668
00:22:22,000 --> 00:22:23,919
and the plaintext or sorry the ground

669
00:22:23,919 --> 00:22:26,799
from the ground truth in the plaintext

670
00:22:26,799 --> 00:22:28,640
and compression will happen so the guess

671
00:22:28,640 --> 00:22:31,919
will appear very compressible

672
00:22:31,919 --> 00:22:33,919
in the superstring case

673
00:22:33,919 --> 00:22:37,120
we see that again the guess has a

674
00:22:37,120 --> 00:22:39,039
the guess or much of the guess matches

675
00:22:39,039 --> 00:22:40,320
the plaintext and will therefore

676
00:22:40,320 --> 00:22:41,919
compress

677
00:22:41,919 --> 00:22:44,880
making us vulnerable to false positives

678
00:22:44,880 --> 00:22:47,520
one thing to note is the substring case

679
00:22:47,520 --> 00:22:50,159
is not really that bad

680
00:22:50,159 --> 00:22:52,480
we're still identifying a valid

681
00:22:52,480 --> 00:22:55,440
substring that occurs in the table

682
00:22:55,440 --> 00:22:56,960
which is the goal of the attack so it's

683
00:22:56,960 --> 00:22:58,720
not really a false positive

684
00:22:58,720 --> 00:23:00,320
and it really drives from the point the

685
00:23:00,320 --> 00:23:02,240
importance of the attacker having a good

686
00:23:02,240 --> 00:23:04,960
set of initial guesses

687
00:23:04,960 --> 00:23:07,120
the superstring case however is quite

688
00:23:07,120 --> 00:23:09,760
bad this is a true false positive the

689
00:23:09,760 --> 00:23:11,919
guess occurs nowhere in the table and we

690
00:23:11,919 --> 00:23:13,600
would really like to avoid situations

691
00:23:13,600 --> 00:23:15,520
like this

692
00:23:15,520 --> 00:23:17,600
to address the superstring problem we

693
00:23:17,600 --> 00:23:20,000
switched to using the ses snow reference

694
00:23:20,000 --> 00:23:22,480
point strategy on all guesses

695
00:23:22,480 --> 00:23:24,159
now guess this score is determined by

696
00:23:24,159 --> 00:23:29,200
how close it is to s relative to s no

697
00:23:29,200 --> 00:23:31,679
and then since ses is calculated using a

698
00:23:31,679 --> 00:23:33,760
string that's the same length as the gas

699
00:23:33,760 --> 00:23:35,600
superstring guesses will only appear

700
00:23:35,600 --> 00:23:37,919
partially compressible relative to an

701
00:23:37,919 --> 00:23:40,480
exact match so in the prior example

702
00:23:40,480 --> 00:23:42,320
ground truth regarding

703
00:23:42,320 --> 00:23:44,640
will only appear partially compressible

704
00:23:44,640 --> 00:23:46,159
compared to something of that length

705
00:23:46,159 --> 00:23:48,840
that was actually a precise

706
00:23:48,840 --> 00:23:51,440
match unfortunately we're still slightly

707
00:23:51,440 --> 00:23:53,200
vulnerable to false positives if the

708
00:23:53,200 --> 00:23:55,200
super string is not much longer than the

709
00:23:55,200 --> 00:23:57,200
ground truth because we might be within

710
00:23:57,200 --> 00:24:00,320
the threshold of s yes that is necessary

711
00:24:00,320 --> 00:24:03,760
to say yes it's in the table

712
00:24:03,760 --> 00:24:06,080
so while this is a big improvement

713
00:24:06,080 --> 00:24:07,600
in cases such as the character by

714
00:24:07,600 --> 00:24:09,360
character extraction tab where the

715
00:24:09,360 --> 00:24:11,760
strings only differ by one character we

716
00:24:11,760 --> 00:24:13,440
still sometimes

717
00:24:13,440 --> 00:24:15,919
fall victim to this superstring problem

718
00:24:15,919 --> 00:24:18,640
so as i alluded to a couple times before

719
00:24:18,640 --> 00:24:20,480
we also encountered various sources of

720
00:24:20,480 --> 00:24:22,240
noise in the side channel that obscured

721
00:24:22,240 --> 00:24:24,159
the signal

722
00:24:24,159 --> 00:24:27,440
the first source of noise that we saw

723
00:24:27,440 --> 00:24:30,000
was from huffman and gooding and

724
00:24:30,000 --> 00:24:32,320
this is uh is utilized in the lzip

725
00:24:32,320 --> 00:24:34,000
compression algorithm

726
00:24:34,000 --> 00:24:36,480
so in huffman encoding

727
00:24:36,480 --> 00:24:38,960
the precise ratio of characters relative

728
00:24:38,960 --> 00:24:40,799
to other characters

729
00:24:40,799 --> 00:24:43,840
can change how compressive can change

730
00:24:43,840 --> 00:24:46,080
how compressible the table is even if

731
00:24:46,080 --> 00:24:49,039
the guess is not compressing with

732
00:24:49,039 --> 00:24:51,200
the target plain text and since when

733
00:24:51,200 --> 00:24:53,440
we're inserting guesses we are changing

734
00:24:53,440 --> 00:24:56,000
this ratio slightly this introduces some

735
00:24:56,000 --> 00:24:57,679
source of noise

736
00:24:57,679 --> 00:24:58,880
luckily

737
00:24:58,880 --> 00:25:00,559
this typically does not overwhelm the

738
00:25:00,559 --> 00:25:03,440
signal in the k of n or decision attacks

739
00:25:03,440 --> 00:25:05,200
because the compression of the guess is

740
00:25:05,200 --> 00:25:07,679
so much greater than the minor changes

741
00:25:07,679 --> 00:25:10,320
due to huffman coding however it poses a

742
00:25:10,320 --> 00:25:11,919
pretty serious problem for the character

743
00:25:11,919 --> 00:25:14,400
by character extraction attack

744
00:25:14,400 --> 00:25:15,520
in which

745
00:25:15,520 --> 00:25:17,440
we're only changing one character at a

746
00:25:17,440 --> 00:25:21,200
time so the signal is weaker

747
00:25:21,600 --> 00:25:23,919
we're continuing to address this problem

748
00:25:23,919 --> 00:25:25,440
and um

749
00:25:25,440 --> 00:25:27,520
the breach paper holds some useful hints

750
00:25:27,520 --> 00:25:29,039
that i won't have the time to talk about

751
00:25:29,039 --> 00:25:31,440
today but we think that they'll come in

752
00:25:31,440 --> 00:25:33,440
handy as we continue to implement the

753
00:25:33,440 --> 00:25:36,400
character by character extraction attack

754
00:25:36,400 --> 00:25:38,000
another source of noise was compression

755
00:25:38,000 --> 00:25:39,840
with irrelevant parts of the tablespace

756
00:25:39,840 --> 00:25:42,000
file such as metadata or our own filler

757
00:25:42,000 --> 00:25:42,880
rows

758
00:25:42,880 --> 00:25:44,720
so if the guess compresses with these

759
00:25:44,720 --> 00:25:46,320
it'll have a high compressibility score

760
00:25:46,320 --> 00:25:47,760
even though it doesn't match the target

761
00:25:47,760 --> 00:25:49,120
plain text

762
00:25:49,120 --> 00:25:51,200
a solution here is to randomly choose

763
00:25:51,200 --> 00:25:53,120
the filler data from some disjoint

764
00:25:53,120 --> 00:25:55,360
alphabet that we believe will not occur

765
00:25:55,360 --> 00:25:57,919
anywhere else in the table

766
00:25:57,919 --> 00:25:59,840
this prevents compression with our own

767
00:25:59,840 --> 00:26:02,320
filler data and managed to mostly

768
00:26:02,320 --> 00:26:03,760
eliminate this source of noise in the

769
00:26:03,760 --> 00:26:05,200
side channel because it appears that

770
00:26:05,200 --> 00:26:07,200
compression with metadata is relatively

771
00:26:07,200 --> 00:26:10,159
unlikely

772
00:26:10,159 --> 00:26:11,360
additionally

773
00:26:11,360 --> 00:26:13,679
we we saw some we occasionally saw

774
00:26:13,679 --> 00:26:16,240
compression within the guess itself

775
00:26:16,240 --> 00:26:18,400
uh for example if a guess contains many

776
00:26:18,400 --> 00:26:20,880
repeated substrings it'll shrink because

777
00:26:20,880 --> 00:26:22,799
it's compressing within itself it'll

778
00:26:22,799 --> 00:26:24,320
appear very compressible even though it

779
00:26:24,320 --> 00:26:25,600
doesn't match

780
00:26:25,600 --> 00:26:27,919
anything in the target plaintext

781
00:26:27,919 --> 00:26:29,760
solution here is to penalize the

782
00:26:29,760 --> 00:26:32,080
internally compressible guesses

783
00:26:32,080 --> 00:26:34,960
one way to do so is to break ties based

784
00:26:34,960 --> 00:26:36,400
on what is more or less internally

785
00:26:36,400 --> 00:26:38,400
compressible or we could actually

786
00:26:38,400 --> 00:26:40,159
decrease the compressibility scores of

787
00:26:40,159 --> 00:26:43,760
very internally compressible guesses

788
00:26:43,840 --> 00:26:46,000
the necessity of this solution kind of

789
00:26:46,000 --> 00:26:48,000
depends on the format of the guesses and

790
00:26:48,000 --> 00:26:50,000
can be toggled on and off as needed by

791
00:26:50,000 --> 00:26:52,159
the attacker

792
00:26:52,159 --> 00:26:53,520
finally

793
00:26:53,520 --> 00:26:55,279
lots of deletions and updates can lead

794
00:26:55,279 --> 00:26:57,840
to a fragmented table space which can

795
00:26:57,840 --> 00:26:59,919
make our insertions happen on different

796
00:26:59,919 --> 00:27:02,880
pages leading to unexpected behavior

797
00:27:02,880 --> 00:27:05,919
luckily this situation is fairly easy to

798
00:27:05,919 --> 00:27:08,159
detect because we just get nonsensical

799
00:27:08,159 --> 00:27:09,600
output

800
00:27:09,600 --> 00:27:11,600
and since we can detect it we can then

801
00:27:11,600 --> 00:27:13,440
retry and hopefully our previous failed

802
00:27:13,440 --> 00:27:15,520
attempt filled up all those fragments in

803
00:27:15,520 --> 00:27:18,240
the table space

804
00:27:19,120 --> 00:27:21,679
one final optimization that we took was

805
00:27:21,679 --> 00:27:23,760
to maximize to maximize the efficiency

806
00:27:23,760 --> 00:27:24,880
of our attack

807
00:27:24,880 --> 00:27:27,120
um relates to minimizing the number of

808
00:27:27,120 --> 00:27:28,960
database actions that we're performing

809
00:27:28,960 --> 00:27:30,480
which is very important for evading

810
00:27:30,480 --> 00:27:31,760
detection

811
00:27:31,760 --> 00:27:33,520
so previously the real bottleneck for

812
00:27:33,520 --> 00:27:35,840
database actions was when we were

813
00:27:35,840 --> 00:27:37,919
continually updating in order to find

814
00:27:37,919 --> 00:27:41,840
the precise boundary at which

815
00:27:41,840 --> 00:27:43,840
at which the table will shrink back to

816
00:27:43,840 --> 00:27:45,600
that prior page

817
00:27:45,600 --> 00:27:47,360
so previously we performed a linear

818
00:27:47,360 --> 00:27:50,399
search across this entire all this whole

819
00:27:50,399 --> 00:27:51,919
filler row

820
00:27:51,919 --> 00:27:53,440
to find the boundary which as you can

821
00:27:53,440 --> 00:27:55,760
see is painfully slow

822
00:27:55,760 --> 00:27:56,640
um

823
00:27:56,640 --> 00:27:58,720
if r is the maximum row size it could

824
00:27:58,720 --> 00:28:00,799
take up to r updates in order to find

825
00:28:00,799 --> 00:28:03,600
that boundary

826
00:28:03,600 --> 00:28:05,520
we switched to using a binary search

827
00:28:05,520 --> 00:28:07,760
method to find that cutoff point which

828
00:28:07,760 --> 00:28:10,000
now only takes log base two of our

829
00:28:10,000 --> 00:28:12,399
updates for gets so big improvement as

830
00:28:12,399 --> 00:28:14,640
you can see

831
00:28:14,640 --> 00:28:16,960
um

832
00:28:16,960 --> 00:28:19,039
now i'm going to talk a little bit about

833
00:28:19,039 --> 00:28:20,880
how just how efficient and accurate we

834
00:28:20,880 --> 00:28:23,120
were able to make our attack

835
00:28:23,120 --> 00:28:25,520
so that binary search optimization

836
00:28:25,520 --> 00:28:27,279
really helped quite a bit

837
00:28:27,279 --> 00:28:29,279
again if we say that r is the maximum

838
00:28:29,279 --> 00:28:31,200
size of a row

839
00:28:31,200 --> 00:28:33,440
then while we're inserting uh while

840
00:28:33,440 --> 00:28:35,360
we're inserting filler rows we must

841
00:28:35,360 --> 00:28:37,279
initially insert at most page size

842
00:28:37,279 --> 00:28:39,440
divided by r rows in order to overfill

843
00:28:39,440 --> 00:28:40,799
the page

844
00:28:40,799 --> 00:28:43,279
so in practice with a mostly empty page

845
00:28:43,279 --> 00:28:46,159
in r two equals 200 it takes around 30

846
00:28:46,159 --> 00:28:48,000
insertions

847
00:28:48,000 --> 00:28:49,679
and then as we explained before it takes

848
00:28:49,679 --> 00:28:52,080
just log base 2 updates per guess log

849
00:28:52,080 --> 00:28:54,320
base 2 of r updates per guess to find

850
00:28:54,320 --> 00:28:56,480
that boundary at which point the table

851
00:28:56,480 --> 00:28:58,880
shrinks back to its prior size

852
00:28:58,880 --> 00:29:01,600
so for n guesses we perform only o of r

853
00:29:01,600 --> 00:29:04,720
plus n log r database actions

854
00:29:04,720 --> 00:29:06,559
um

855
00:29:06,559 --> 00:29:08,720
we found that this was quite performant

856
00:29:08,720 --> 00:29:12,960
and in practice when r is 200 200 bytes

857
00:29:12,960 --> 00:29:15,760
a single guess takes only about 0.2 to

858
00:29:15,760 --> 00:29:17,840
0.4 seconds

859
00:29:17,840 --> 00:29:18,640
and

860
00:29:18,640 --> 00:29:22,640
on the order of 10 updates

861
00:29:23,679 --> 00:29:25,600
or fewer

862
00:29:25,600 --> 00:29:27,760
so in terms of accuracy we were quite

863
00:29:27,760 --> 00:29:29,200
pleased with the results we were able to

864
00:29:29,200 --> 00:29:32,720
achieve in this experiment

865
00:29:32,720 --> 00:29:36,240
we inserted some number k

866
00:29:36,240 --> 00:29:38,240
rows onto a page which were randomly

867
00:29:38,240 --> 00:29:40,640
chosen from a name set very similar to

868
00:29:40,640 --> 00:29:42,480
the one that you saw in the demo

869
00:29:42,480 --> 00:29:44,559
then if we inserted k records onto the

870
00:29:44,559 --> 00:29:46,799
page we would run the k event extraction

871
00:29:46,799 --> 00:29:47,840
attack

872
00:29:47,840 --> 00:29:49,520
through all possible

873
00:29:49,520 --> 00:29:51,120
options that those records were randomly

874
00:29:51,120 --> 00:29:53,840
chosen from and try and pick which k

875
00:29:53,840 --> 00:29:56,000
were inserted

876
00:29:56,000 --> 00:29:58,320
for low values of k or when there's not

877
00:29:58,320 --> 00:30:01,120
many records on the page

878
00:30:01,120 --> 00:30:03,679
we uh achieved very high accuracy levels

879
00:30:03,679 --> 00:30:06,559
so if you look at one it's over 95

880
00:30:06,559 --> 00:30:09,360
for two and four uh they're also over

881
00:30:09,360 --> 00:30:10,640
ninety percent

882
00:30:10,640 --> 00:30:13,039
also note that this x-axis is on a log

883
00:30:13,039 --> 00:30:16,159
scale and then even as k gets quite high

884
00:30:16,159 --> 00:30:17,120
so there's

885
00:30:17,120 --> 00:30:18,559
uh fifty

886
00:30:18,559 --> 00:30:20,880
over fifty or over a hundred rows on the

887
00:30:20,880 --> 00:30:24,080
page we remain we are still able to

888
00:30:24,080 --> 00:30:25,440
extract

889
00:30:25,440 --> 00:30:29,039
75 or 70 plus percent of those records

890
00:30:29,039 --> 00:30:31,679
on average

891
00:30:32,799 --> 00:30:34,640
one last thing i want to note

892
00:30:34,640 --> 00:30:36,240
is that

893
00:30:36,240 --> 00:30:38,080
it's there's nothing really specific

894
00:30:38,080 --> 00:30:39,679
about marine tv and industries

895
00:30:39,679 --> 00:30:40,880
implementation that makes them

896
00:30:40,880 --> 00:30:43,840
vulnerable to this attack

897
00:30:43,840 --> 00:30:46,240
the the issue is more fundamental it's

898
00:30:46,240 --> 00:30:48,159
that the database compresses attacker

899
00:30:48,159 --> 00:30:50,399
and victim data together and this occurs

900
00:30:50,399 --> 00:30:51,919
in all sorts of database management

901
00:30:51,919 --> 00:30:53,760
systems and storage engines

902
00:30:53,760 --> 00:30:56,159
as such we believe that other rdbms's

903
00:30:56,159 --> 00:30:57,919
and storage engines are likely

904
00:30:57,919 --> 00:30:59,679
vulnerable to the same attack or very

905
00:30:59,679 --> 00:31:01,200
similar attacks

906
00:31:01,200 --> 00:31:03,360
we think that mysql is especially likely

907
00:31:03,360 --> 00:31:05,279
to be vulnerable since marie dv is just

908
00:31:05,279 --> 00:31:08,080
a fork of mysql and mysql also uses the

909
00:31:08,080 --> 00:31:11,439
nodd storage engine

910
00:31:11,919 --> 00:31:13,519
now i'm going to go over some possible

911
00:31:13,519 --> 00:31:17,120
mitigations for our attack

912
00:31:17,760 --> 00:31:18,960
there are really two classes of

913
00:31:18,960 --> 00:31:21,200
mitigations there's prevention which is

914
00:31:21,200 --> 00:31:24,320
what dbas and developers who are using

915
00:31:24,320 --> 00:31:26,240
databases can use to avoid falling

916
00:31:26,240 --> 00:31:28,080
victim to this sort of attack and then

917
00:31:28,080 --> 00:31:29,679
there's actually patching the problem

918
00:31:29,679 --> 00:31:31,360
which are more recommendations for the

919
00:31:31,360 --> 00:31:33,440
mariadb developers or other database

920
00:31:33,440 --> 00:31:36,159
developers themselves

921
00:31:36,159 --> 00:31:37,919
in terms of profession prevention we

922
00:31:37,919 --> 00:31:39,840
have a few strategies

923
00:31:39,840 --> 00:31:41,200
first of all

924
00:31:41,200 --> 00:31:43,200
don't use column level commercials for

925
00:31:43,200 --> 00:31:45,440
select capabilities

926
00:31:45,440 --> 00:31:47,279
this attack clearly showed that these

927
00:31:47,279 --> 00:31:49,600
are broken and they provide attackers

928
00:31:49,600 --> 00:31:51,279
with half the necessary capabilities

929
00:31:51,279 --> 00:31:52,880
because they allow you to update over

930
00:31:52,880 --> 00:31:55,679
the whole table

931
00:31:55,840 --> 00:31:57,600
and then therefore

932
00:31:57,600 --> 00:31:58,880
once you gain

933
00:31:58,880 --> 00:32:00,399
read access to the file system they

934
00:32:00,399 --> 00:32:02,559
allow you to read the whole table

935
00:32:02,559 --> 00:32:05,679
or much of the table

936
00:32:05,679 --> 00:32:07,120
additionally

937
00:32:07,120 --> 00:32:08,960
dbas or developers could monitor

938
00:32:08,960 --> 00:32:11,679
database usage for unusual activity

939
00:32:11,679 --> 00:32:13,519
patterns

940
00:32:13,519 --> 00:32:15,279
this will look pretty similar to denial

941
00:32:15,279 --> 00:32:17,360
of service detection if a single user is

942
00:32:17,360 --> 00:32:19,200
performing an unusually high number of

943
00:32:19,200 --> 00:32:21,120
inserts and updates or a very unusual

944
00:32:21,120 --> 00:32:23,279
pattern of inserts and updates then it

945
00:32:23,279 --> 00:32:24,960
might be a good idea to block them from

946
00:32:24,960 --> 00:32:27,200
the database for some period of time

947
00:32:27,200 --> 00:32:29,519
however remember that after the binary

948
00:32:29,519 --> 00:32:32,159
search optimization this takes

949
00:32:32,159 --> 00:32:35,600
uh checking one guess takes only about

950
00:32:35,600 --> 00:32:40,159
30 insertions and 10 or so updates

951
00:32:40,159 --> 00:32:42,720
therefore this ddos detection strategy

952
00:32:42,720 --> 00:32:45,120
might be difficult if an attacker is

953
00:32:45,120 --> 00:32:48,240
only checking a small number of guesses

954
00:32:48,240 --> 00:32:50,159
the only foolproof method for preventing

955
00:32:50,159 --> 00:32:53,279
this attack is to turn off compression

956
00:32:53,279 --> 00:32:55,679
or alternatively switch to using the

957
00:32:55,679 --> 00:32:57,519
storage engine independent compression

958
00:32:57,519 --> 00:32:59,760
offering that really provides

959
00:32:59,760 --> 00:33:01,519
in both of those cases

960
00:33:01,519 --> 00:33:03,360
attacker data will not be compressed

961
00:33:03,360 --> 00:33:05,519
with victim data recall that in the

962
00:33:05,519 --> 00:33:07,840
storage engine independent compression

963
00:33:07,840 --> 00:33:10,240
compression only happens within database

964
00:33:10,240 --> 00:33:13,760
cells so within a column and row

965
00:33:15,200 --> 00:33:16,960
obviously there's some performance hit

966
00:33:16,960 --> 00:33:18,720
for turning off compression and storage

967
00:33:18,720 --> 00:33:20,559
will become more expensive however if

968
00:33:20,559 --> 00:33:21,840
the data is

969
00:33:21,840 --> 00:33:24,640
very sensitive

970
00:33:24,640 --> 00:33:26,080
this might be worth it in order to

971
00:33:26,080 --> 00:33:28,399
protect the data

972
00:33:28,399 --> 00:33:30,000
in terms of actually patching the

973
00:33:30,000 --> 00:33:33,360
vulnerability we have a few suggestions

974
00:33:33,360 --> 00:33:35,200
we believe that column level permissions

975
00:33:35,200 --> 00:33:37,679
for select should probably be deprecated

976
00:33:37,679 --> 00:33:39,440
or at least recommended against until a

977
00:33:39,440 --> 00:33:42,720
more comprehensive solution is found

978
00:33:42,720 --> 00:33:44,399
that's for the same reasons as mentioned

979
00:33:44,399 --> 00:33:46,799
earlier

980
00:33:47,200 --> 00:33:48,480
additionally

981
00:33:48,480 --> 00:33:50,720
marietv could offer a compression option

982
00:33:50,720 --> 00:33:53,360
that compresses only within rows so

983
00:33:53,360 --> 00:33:55,120
attacker data and victim data is not

984
00:33:55,120 --> 00:33:57,200
compressing together so storage engine

985
00:33:57,200 --> 00:33:58,960
independent compression compresses only

986
00:33:58,960 --> 00:33:59,919
within

987
00:33:59,919 --> 00:34:03,519
road columns so specific cells

988
00:34:03,519 --> 00:34:05,760
but perhaps compressing within rows will

989
00:34:05,760 --> 00:34:08,560
be more performant than that while

990
00:34:08,560 --> 00:34:10,239
avoiding this issue

991
00:34:10,239 --> 00:34:12,320
another idea would be to compress only

992
00:34:12,320 --> 00:34:14,560
within rows inserted by the same user

993
00:34:14,560 --> 00:34:15,918
and user group

994
00:34:15,918 --> 00:34:18,480
so this feature doesn't exist yet but if

995
00:34:18,480 --> 00:34:20,239
it were added then it would prevent

996
00:34:20,239 --> 00:34:21,918
attackers from

997
00:34:21,918 --> 00:34:23,359
compressing with and therefore

998
00:34:23,359 --> 00:34:24,639
discovering

999
00:34:24,639 --> 00:34:27,760
other users data

1000
00:34:29,359 --> 00:34:31,918
so now i'm going to go quickly check in

1001
00:34:31,918 --> 00:34:34,480
on how our demo went it should be done

1002
00:34:34,480 --> 00:34:36,159
by now

1003
00:34:36,159 --> 00:34:38,480
so we see down here

1004
00:34:38,480 --> 00:34:41,440
let's make this a little bigger

1005
00:34:41,440 --> 00:34:43,599
it's able to uncover the secret name

1006
00:34:43,599 --> 00:34:45,199
james villanueva remember that we

1007
00:34:45,199 --> 00:34:46,839
inserted that

1008
00:34:46,839 --> 00:34:48,960
above um

1009
00:34:48,960 --> 00:34:50,159
so

1010
00:34:50,159 --> 00:34:52,159
hooray

1011
00:34:52,159 --> 00:34:54,560
okay and now a quick conclusion

1012
00:34:54,560 --> 00:34:56,079
so in summary

1013
00:34:56,079 --> 00:34:57,839
uh deep reach is an attack on

1014
00:34:57,839 --> 00:35:00,240
compression and encryption in databases

1015
00:35:00,240 --> 00:35:02,240
it derives from a simple and achievable

1016
00:35:02,240 --> 00:35:04,720
threat model and it is efficient and

1017
00:35:04,720 --> 00:35:05,760
accurate

1018
00:35:05,760 --> 00:35:07,359
we believe that this really drives home

1019
00:35:07,359 --> 00:35:09,359
the point that compression and

1020
00:35:09,359 --> 00:35:11,040
encryption should be combined very

1021
00:35:11,040 --> 00:35:14,079
carefully lest you or your system fall

1022
00:35:14,079 --> 00:35:15,599
victim to a compression side channel

1023
00:35:15,599 --> 00:35:16,960
attack

1024
00:35:16,960 --> 00:35:19,040
additionally it raises the question of

1025
00:35:19,040 --> 00:35:21,839
what other context besides databases and

1026
00:35:21,839 --> 00:35:23,599
besides web security

1027
00:35:23,599 --> 00:35:25,359
may be vulnerable to such compression

1028
00:35:25,359 --> 00:35:27,520
side channel attacks and i think

1029
00:35:27,520 --> 00:35:28,880
there's plenty of opportunities for

1030
00:35:28,880 --> 00:35:31,200
future work to address that

1031
00:35:31,200 --> 00:35:32,160
okay

1032
00:35:32,160 --> 00:35:36,640
thank you happy to take any questions

