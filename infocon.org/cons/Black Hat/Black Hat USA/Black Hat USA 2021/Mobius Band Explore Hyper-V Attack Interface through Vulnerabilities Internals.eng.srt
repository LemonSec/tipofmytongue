1
00:00:01,130 --> 00:00:14,690
[Music]

2
00:00:15,519 --> 00:00:17,520
hello everyone let's introduce myself

3
00:00:17,520 --> 00:00:20,080
first my name is john ho ho i have been

4
00:00:20,080 --> 00:00:22,160
working on virtualization security and

5
00:00:22,160 --> 00:00:24,320
hyper race security research for many

6
00:00:24,320 --> 00:00:28,800
years i was awarded the 2019 and 2020. i

7
00:00:28,800 --> 00:00:30,880
might start the most valuable

8
00:00:30,880 --> 00:00:33,440
security researchers

9
00:00:33,440 --> 00:00:35,280
i also want to introduce my partner

10
00:00:35,280 --> 00:00:38,000
transgender he is the technical director

11
00:00:38,000 --> 00:00:39,760
at 360

12
00:00:39,760 --> 00:00:42,640
and the leads the i sword lib whose

13
00:00:42,640 --> 00:00:45,920
family focuses on

14
00:00:45,920 --> 00:00:48,399
operating system kernels virtualization

15
00:00:48,399 --> 00:00:50,960
technology and computer security in this

16
00:00:50,960 --> 00:00:54,719
topic he made an indelible contribution

17
00:00:54,719 --> 00:00:57,120
this topic is divided into the following

18
00:00:57,120 --> 00:00:58,480
six parts

19
00:00:58,480 --> 00:01:01,760
i simplifies the hyperlink architecture

20
00:01:01,760 --> 00:01:04,239
as the picture shows next i will

21
00:01:04,239 --> 00:01:05,840
introduce important temporary

22
00:01:05,840 --> 00:01:07,439
fundamental

23
00:01:07,439 --> 00:01:10,400
components the first important component

24
00:01:10,400 --> 00:01:12,880
is the hypervisor component

25
00:01:12,880 --> 00:01:15,040
hypervisor component implements the

26
00:01:15,040 --> 00:01:17,280
following functions

27
00:01:17,280 --> 00:01:20,080
the next important component is vm bus

28
00:01:20,080 --> 00:01:21,200
component

29
00:01:21,200 --> 00:01:24,479
when bus exists in room zero level of

30
00:01:24,479 --> 00:01:27,040
host machine and guest machine it is

31
00:01:27,040 --> 00:01:29,680
used for dates transmission between the

32
00:01:29,680 --> 00:01:31,200
guest and host

33
00:01:31,200 --> 00:01:34,000
vmbox uses vm call instruction and

34
00:01:34,000 --> 00:01:36,320
interrupt injection

35
00:01:36,320 --> 00:01:39,119
technology to implement notification

36
00:01:39,119 --> 00:01:41,280
between guest and host

37
00:01:41,280 --> 00:01:43,200
there are some host drivers that

38
00:01:43,200 --> 00:01:45,360
implementation

39
00:01:45,360 --> 00:01:46,640
hyper risk

40
00:01:46,640 --> 00:01:48,799
device in virtualization in gaston

41
00:01:48,799 --> 00:01:51,360
machine for example

42
00:01:51,360 --> 00:01:53,520
network virtualization component

43
00:01:53,520 --> 00:01:56,399
implements the function of a virtual

44
00:01:56,399 --> 00:01:59,520
network adapter in guest

45
00:01:59,520 --> 00:02:02,320
these host drivers all use members to

46
00:02:02,320 --> 00:02:04,640
communicate with the guest

47
00:02:04,640 --> 00:02:07,360
vmwp process is the most important

48
00:02:07,360 --> 00:02:10,800
program of hybrid android 3. one virtual

49
00:02:10,800 --> 00:02:14,480
machine instance corresponds to one

50
00:02:14,480 --> 00:02:18,480
bmwp process many heparin components are

51
00:02:18,480 --> 00:02:21,840
included in bmwp process

52
00:02:21,840 --> 00:02:25,200
these components communicate with vm

53
00:02:25,200 --> 00:02:29,200
members through io read and write

54
00:02:29,520 --> 00:02:32,080
when bus pass in need function is used

55
00:02:32,080 --> 00:02:36,400
for initialized linux guest

56
00:02:36,480 --> 00:02:39,120
index function initialize heparin and

57
00:02:39,120 --> 00:02:40,560
register

58
00:02:40,560 --> 00:02:44,400
but first then invoke hvac

59
00:02:44,400 --> 00:02:47,280
log function to and

60
00:02:47,280 --> 00:02:48,640
sends a

61
00:02:48,640 --> 00:02:50,640
connect request on the

62
00:02:50,640 --> 00:02:53,120
partitions arrest connection

63
00:02:53,120 --> 00:02:55,680
in the end send a request to get all

64
00:02:55,680 --> 00:02:57,280
pending offers

65
00:02:57,280 --> 00:03:00,480
reinvest open function is used for guest

66
00:03:00,480 --> 00:03:01,760
van bus

67
00:03:01,760 --> 00:03:03,120
device

68
00:03:03,120 --> 00:03:06,080
initialize in this function first unlock

69
00:03:06,080 --> 00:03:07,760
can continue

70
00:03:07,760 --> 00:03:10,560
pages for members ring buffer and

71
00:03:10,560 --> 00:03:14,879
initialize vm bus ring buffer second

72
00:03:14,879 --> 00:03:18,879
establish a gp adr for specified buffer

73
00:03:18,879 --> 00:03:20,480
second

74
00:03:20,480 --> 00:03:21,760
third

75
00:03:21,760 --> 00:03:23,360
send a

76
00:03:23,360 --> 00:03:26,239
open channel message to host

77
00:03:26,239 --> 00:03:28,799
when bus and package function is used

78
00:03:28,799 --> 00:03:30,080
for

79
00:03:30,080 --> 00:03:32,720
sending send gets the data to host on

80
00:03:32,720 --> 00:03:34,959
the right it is the

81
00:03:34,959 --> 00:03:37,840
calling chain of this function

82
00:03:37,840 --> 00:03:40,959
do fast hyper call will execute vm call

83
00:03:40,959 --> 00:03:43,840
instruction and hypervisor will follow

84
00:03:43,840 --> 00:03:46,480
vm exists invent

85
00:03:46,480 --> 00:03:48,879
when bus online function is used for

86
00:03:48,879 --> 00:03:52,239
received data from host index function a

87
00:03:52,239 --> 00:03:54,480
callback function will be invoked at the

88
00:03:54,480 --> 00:03:55,599
red mark

89
00:03:55,599 --> 00:03:57,519
the callback function partner will be

90
00:03:57,519 --> 00:04:00,400
set in ram bus open function there are

91
00:04:00,400 --> 00:04:02,760
two functions the

92
00:04:02,760 --> 00:04:06,720
kmclp vm bus isr is used for distribute

93
00:04:06,720 --> 00:04:09,120
gated to host driver

94
00:04:09,120 --> 00:04:11,400
such as vm switch

95
00:04:11,400 --> 00:04:15,840
kmcrp vm bus manual is used for to

96
00:04:15,840 --> 00:04:18,720
distribute gets the data to host user

97
00:04:18,720 --> 00:04:19,600
mode

98
00:04:19,600 --> 00:04:21,918
components such as vmui

99
00:04:21,918 --> 00:04:23,040
devices

100
00:04:23,040 --> 00:04:26,160
the example of ring zero date passes as

101
00:04:26,160 --> 00:04:27,280
follows

102
00:04:27,280 --> 00:04:30,320
the guest data pointer is the function's

103
00:04:30,320 --> 00:04:32,880
third parameter because the data set is

104
00:04:32,880 --> 00:04:35,120
the function's first parameter

105
00:04:35,120 --> 00:04:38,000
the example of rune3 datapath is as

106
00:04:38,000 --> 00:04:39,360
follows

107
00:04:39,360 --> 00:04:42,479
the function path complete irp list will

108
00:04:42,479 --> 00:04:43,840
be invoked

109
00:04:43,840 --> 00:04:46,479
index function iocomplete request will

110
00:04:46,479 --> 00:04:49,840
be invoked in wind debug rp command will

111
00:04:49,840 --> 00:04:52,880
display information about an io request

112
00:04:52,880 --> 00:04:54,560
package

113
00:04:54,560 --> 00:04:58,400
the stress stock batteries is as follows

114
00:04:58,400 --> 00:05:01,600
the vmi sequel component is waiting for

115
00:05:01,600 --> 00:05:04,639
data from the guest

116
00:05:04,880 --> 00:05:08,320
i will take eng realized brush as an

117
00:05:08,320 --> 00:05:11,440
example explain why hebrews is difficult

118
00:05:11,440 --> 00:05:13,680
eng realized brush

119
00:05:13,680 --> 00:05:14,720
integer

120
00:05:14,720 --> 00:05:17,120
overflow is uses this function to

121
00:05:17,120 --> 00:05:19,919
realize kernel pool function

122
00:05:19,919 --> 00:05:22,240
we can construct a memory read and read

123
00:05:22,240 --> 00:05:24,960
by controlling the content of

124
00:05:24,960 --> 00:05:27,120
bitmap objects and the

125
00:05:27,120 --> 00:05:30,160
palette object it is easy to control

126
00:05:30,160 --> 00:05:32,240
palette object in windows kernel by

127
00:05:32,240 --> 00:05:34,960
using grid palette api

128
00:05:34,960 --> 00:05:36,639
this is the differences between

129
00:05:36,639 --> 00:05:39,199
traditional windows eop exploit and the

130
00:05:39,199 --> 00:05:42,080
hyperware exploits about attack

131
00:05:42,080 --> 00:05:45,039
interface traditional eop has a lot of

132
00:05:45,039 --> 00:05:48,560
apis ring0 will be able to read data

133
00:05:48,560 --> 00:05:51,600
from user mode address directly but

134
00:05:51,600 --> 00:05:53,759
hyperlink has no aps and all data

135
00:05:53,759 --> 00:05:55,199
transmitted

136
00:05:55,199 --> 00:05:58,880
via vm bus ring zero enabled to read

137
00:05:58,880 --> 00:06:02,479
data from guest memory speeds directly

138
00:06:02,479 --> 00:06:03,919
about

139
00:06:03,919 --> 00:06:07,520
object lock and free traditional upload

140
00:06:07,520 --> 00:06:09,440
exploit has a lot of object can be

141
00:06:09,440 --> 00:06:11,120
abused so far

142
00:06:11,120 --> 00:06:13,440
a lock on the free kernel object is easy

143
00:06:13,440 --> 00:06:15,919
control construct memory with android by

144
00:06:15,919 --> 00:06:18,800
controlling the content of

145
00:06:18,800 --> 00:06:20,479
kernel objects

146
00:06:20,479 --> 00:06:22,960
hyperbolic export has no suitable object

147
00:06:22,960 --> 00:06:25,759
for abuse but i'm still looking for

148
00:06:25,759 --> 00:06:28,639
and the unable to control

149
00:06:28,639 --> 00:06:31,520
object lock and free directly

150
00:06:31,520 --> 00:06:34,800
even cannot control the timing of object

151
00:06:34,800 --> 00:06:35,759
about

152
00:06:35,759 --> 00:06:37,600
a lock and free

153
00:06:37,600 --> 00:06:41,199
because of a vm bus mechanism

154
00:06:41,199 --> 00:06:43,520
there are very little contact in the

155
00:06:43,520 --> 00:06:46,880
object that can be controlled from gas

156
00:06:46,880 --> 00:06:50,400
about toc to your vulnerability now two

157
00:06:50,400 --> 00:06:54,000
key factors in toc to u vulnerability

158
00:06:54,000 --> 00:06:56,639
one is that the parameter passed from a

159
00:06:56,639 --> 00:06:59,360
user mode program should be a pointer

160
00:06:59,360 --> 00:07:02,479
the other is that system called handle

161
00:07:02,479 --> 00:07:05,280
fetches the parameter from user memory

162
00:07:05,280 --> 00:07:06,880
more than once

163
00:07:06,880 --> 00:07:11,039
but heparin of data are transmitted

164
00:07:11,039 --> 00:07:14,639
where vm bus ring0 enabled to read data

165
00:07:14,639 --> 00:07:15,599
from

166
00:07:15,599 --> 00:07:18,319
gesture memory space directly

167
00:07:18,319 --> 00:07:21,120
this is why hyper is difficult

168
00:07:21,120 --> 00:07:22,800
that's talking about vulnerability

169
00:07:22,800 --> 00:07:25,759
details the first rce

170
00:07:25,759 --> 00:07:28,240
vulnerability introduced is the cv 2019

171
00:07:28,240 --> 00:07:31,240
2019.0620

172
00:07:31,840 --> 00:07:34,280
this vulnerability exists in

173
00:07:34,280 --> 00:07:37,919
vhdmp and store vnp says fail the

174
00:07:37,919 --> 00:07:40,720
picture in the stock batteries when this

175
00:07:40,720 --> 00:07:43,520
vulnerability is triggered the root case

176
00:07:43,520 --> 00:07:46,000
of this vulnerability is into vmware's

177
00:07:46,000 --> 00:07:48,319
channel packet complete function test

178
00:07:48,319 --> 00:07:51,360
with the same first parameter

179
00:07:51,360 --> 00:07:53,759
as shown in the picture the vm bus

180
00:07:53,759 --> 00:07:55,919
channel packet complete function will be

181
00:07:55,919 --> 00:07:57,520
invoked either

182
00:07:57,520 --> 00:08:03,240
complete sketchy request offset 0x2d7

183
00:08:03,280 --> 00:08:04,879
let's set a

184
00:08:04,879 --> 00:08:06,400
breakpoint here

185
00:08:06,400 --> 00:08:09,039
trigger this issue and see what happened

186
00:08:09,039 --> 00:08:11,280
invid back

187
00:08:11,280 --> 00:08:13,520
spread trigger this breakpoint and

188
00:08:13,520 --> 00:08:15,919
calling vmp channel packet complete

189
00:08:15,919 --> 00:08:17,440
function with a

190
00:08:17,440 --> 00:08:20,360
blah blah blah four zero

191
00:08:20,360 --> 00:08:23,599
c0500 as the first parameter

192
00:08:23,599 --> 00:08:26,080
and then another thread triggered this

193
00:08:26,080 --> 00:08:29,680
pawn to breakpoint 2 and calling vmbox

194
00:08:29,680 --> 00:08:31,599
channel packet complete function with

195
00:08:31,599 --> 00:08:34,559
the same first parameter and then blue

196
00:08:34,559 --> 00:08:36,240
screen

197
00:08:36,240 --> 00:08:38,799
that's lss

198
00:08:38,799 --> 00:08:40,799
let's understand uh let's

199
00:08:40,799 --> 00:08:43,599
analyze this vulnerability

200
00:08:43,599 --> 00:08:45,440
the following stock batteries can be

201
00:08:45,440 --> 00:08:48,399
triggered in normal procedure so leave

202
00:08:48,399 --> 00:08:51,760
it alone let's look like the next one

203
00:08:51,760 --> 00:08:53,760
the following stock batteries can be

204
00:08:53,760 --> 00:08:55,200
triggered only

205
00:08:55,200 --> 00:08:58,000
perform extra sketchy action second

206
00:08:58,000 --> 00:09:00,399
parameter of set asus memory is not

207
00:09:00,399 --> 00:09:01,360
known

208
00:09:01,360 --> 00:09:02,880
as you can see

209
00:09:02,880 --> 00:09:06,480
as v4 offset its memory is not zero

210
00:09:06,480 --> 00:09:09,600
above stack batteries will be triggered

211
00:09:09,600 --> 00:09:13,040
by reverse engineering i find it perform

212
00:09:13,040 --> 00:09:16,000
extra sketchy action second parameter of

213
00:09:16,000 --> 00:09:18,480
that its memory is set by complete

214
00:09:18,480 --> 00:09:20,399
offload request

215
00:09:20,399 --> 00:09:23,519
in function complete offload request the

216
00:09:23,519 --> 00:09:26,959
value of v6 offset 0x58

217
00:09:26,959 --> 00:09:30,160
is passed to v33

218
00:09:30,160 --> 00:09:34,160
and then could be 33 at 0x40

219
00:09:34,160 --> 00:09:34,880
in

220
00:09:34,880 --> 00:09:38,399
win 20 v 20 offset

221
00:09:38,399 --> 00:09:42,320
0x to zeros memory actually the value of

222
00:09:42,320 --> 00:09:46,240
v20 offset 0x to 0 is the value of

223
00:09:46,240 --> 00:09:48,880
perform extra sketchy

224
00:09:48,880 --> 00:09:53,040
actions second parameter of set 8

225
00:09:53,040 --> 00:09:55,680
in complete offload request

226
00:09:55,680 --> 00:09:59,360
function where is the value of v6 offset

227
00:09:59,360 --> 00:10:00,720
0x

228
00:10:00,720 --> 00:10:03,600
from 8b set

229
00:10:03,600 --> 00:10:04,800
by reward

230
00:10:04,800 --> 00:10:07,680
by reverse engineering i found

231
00:10:07,680 --> 00:10:10,480
command the copy operation aboard

232
00:10:10,480 --> 00:10:13,839
function set the value of v6 offset

233
00:10:13,839 --> 00:10:16,720
0x508

234
00:10:16,720 --> 00:10:19,680
at the red mark in the picture it is the

235
00:10:19,680 --> 00:10:21,279
function

236
00:10:21,279 --> 00:10:24,000
offload table skin bin such as a

237
00:10:24,000 --> 00:10:27,040
specified offload op object

238
00:10:27,040 --> 00:10:29,519
through its second parameter the second

239
00:10:29,519 --> 00:10:32,240
parameter can be controlled by guests

240
00:10:32,240 --> 00:10:34,800
if an offload table insert log the

241
00:10:34,800 --> 00:10:37,760
function will insert a offload op object

242
00:10:37,760 --> 00:10:40,880
into off offload table we can invoke

243
00:10:40,880 --> 00:10:43,440
this function by calling skyc command

244
00:10:43,440 --> 00:10:47,760
right using taken function command

245
00:10:47,760 --> 00:10:49,760
write using taken function can be

246
00:10:49,760 --> 00:10:52,240
triggered from guest and some data in

247
00:10:52,240 --> 00:10:54,560
this function will be can be controlled

248
00:10:54,560 --> 00:10:55,839
from gas

249
00:10:55,839 --> 00:10:59,760
let's see what offload table insert lock

250
00:10:59,760 --> 00:11:02,320
the function looks like

251
00:11:02,320 --> 00:11:04,880
in the picture this function also

252
00:11:04,880 --> 00:11:06,240
invokes

253
00:11:06,240 --> 00:11:08,800
offload table skimping function

254
00:11:08,800 --> 00:11:11,519
the second parameter of

255
00:11:11,519 --> 00:11:12,480
table

256
00:11:12,480 --> 00:11:14,560
offload tables gimping

257
00:11:14,560 --> 00:11:16,959
also can be controlled from guest in the

258
00:11:16,959 --> 00:11:19,600
following code a specified

259
00:11:19,600 --> 00:11:22,800
offload op object will be inserted

260
00:11:22,800 --> 00:11:24,320
into a

261
00:11:24,320 --> 00:11:26,800
offload table

262
00:11:26,800 --> 00:11:29,440
now we can use command red

263
00:11:29,440 --> 00:11:32,079
right using taken and the command copy

264
00:11:32,079 --> 00:11:34,000
operation about to trigger the following

265
00:11:34,000 --> 00:11:35,920
stack batteries

266
00:11:35,920 --> 00:11:36,800
but

267
00:11:36,800 --> 00:11:39,200
let's look at the

268
00:11:39,200 --> 00:11:42,399
command copy operation function first in

269
00:11:42,399 --> 00:11:44,640
the function the value of v file can be

270
00:11:44,640 --> 00:11:46,480
controlled from guest

271
00:11:46,480 --> 00:11:48,800
impulse i call it

272
00:11:48,800 --> 00:11:50,160
out code

273
00:11:50,160 --> 00:11:53,760
if the value of v5 is 0x11

274
00:11:53,760 --> 00:11:56,240
will invoke command right using taken

275
00:11:56,240 --> 00:12:00,800
function if the value of v5 is 0x1c

276
00:12:00,800 --> 00:12:02,079
will invoke

277
00:12:02,079 --> 00:12:05,040
command copy operation above function

278
00:12:05,040 --> 00:12:07,040
this is the poc

279
00:12:07,040 --> 00:12:08,959
cbd

280
00:12:08,959 --> 00:12:12,079
2 4 reserve0124s used for command copy

281
00:12:12,079 --> 00:12:15,519
operation about 5 to 8 is used for

282
00:12:15,519 --> 00:12:18,320
command rate using taken

283
00:12:18,320 --> 00:12:21,200
now let's track this vulnerability and

284
00:12:21,200 --> 00:12:22,720
backing

285
00:12:22,720 --> 00:12:26,000
first off load table insert lock the

286
00:12:26,000 --> 00:12:28,079
second parameter is uh

287
00:12:28,079 --> 00:12:31,079
0x45464800

288
00:12:32,720 --> 00:12:35,279
and then return value as zero

289
00:12:35,279 --> 00:12:37,519
then insert a offload ob

290
00:12:37,519 --> 00:12:41,040
op object into offload table and then

291
00:12:41,040 --> 00:12:43,760
command copy operation about such as a

292
00:12:43,760 --> 00:12:45,600
specified

293
00:12:45,600 --> 00:12:48,880
object in offload table and return

294
00:12:48,880 --> 00:12:51,680
an object pointer

295
00:12:51,680 --> 00:12:52,560
next

296
00:12:52,560 --> 00:12:56,240
put a pointer into this object offset 0x

297
00:12:56,240 --> 00:13:00,720
file its memory continue program under

298
00:13:00,720 --> 00:13:03,519
complete offload request breakpoint will

299
00:13:03,519 --> 00:13:04,560
trigger

300
00:13:04,560 --> 00:13:07,600
you can see the rcx register value is

301
00:13:07,600 --> 00:13:09,360
the ball pointer

302
00:13:09,360 --> 00:13:12,000
continue in this picture

303
00:13:12,000 --> 00:13:14,079
when bus channel package complete

304
00:13:14,079 --> 00:13:16,560
functions first parameter is the above

305
00:13:16,560 --> 00:13:18,000
counter

306
00:13:18,000 --> 00:13:20,720
and then another thread called vmware's

307
00:13:20,720 --> 00:13:22,560
channel packet complete function with

308
00:13:22,560 --> 00:13:24,959
the same first parameter

309
00:13:24,959 --> 00:13:28,560
about applied exploit syncing

310
00:13:28,560 --> 00:13:31,040
the poc has a chance to

311
00:13:31,040 --> 00:13:34,320
cast uf so i should find a suitable

312
00:13:34,320 --> 00:13:36,000
object for

313
00:13:36,000 --> 00:13:39,279
kernel spree but no object of a suitable

314
00:13:39,279 --> 00:13:41,279
accessible fund

315
00:13:41,279 --> 00:13:45,399
now i will introduce cbe20190720

316
00:13:45,839 --> 00:13:48,079
as shown in the picture this is the

317
00:13:48,079 --> 00:13:50,079
stock batteries when this vulnerability

318
00:13:50,079 --> 00:13:52,959
is triggered as you can see

319
00:13:52,959 --> 00:13:55,440
system crashed at a delic

320
00:13:55,440 --> 00:13:57,519
gpdl view if

321
00:13:57,519 --> 00:14:00,000
and referenced let's see what looks like

322
00:14:00,000 --> 00:14:04,160
in function unmapped gpa dr view

323
00:14:04,160 --> 00:14:06,880
in map gpdo view function

324
00:14:06,880 --> 00:14:09,680
lookup element generic table such as a

325
00:14:09,680 --> 00:14:11,839
generic table for an element that

326
00:14:11,839 --> 00:14:14,880
matches the specified data the specified

327
00:14:14,880 --> 00:14:17,920
data address address is a re it's

328
00:14:17,920 --> 00:14:21,040
address the specified data's content is

329
00:14:21,040 --> 00:14:22,959
a1 and a2

330
00:14:22,959 --> 00:14:26,079
v4 is the matching element pointer and

331
00:14:26,079 --> 00:14:28,399
the password v4 as the second parameter

332
00:14:28,399 --> 00:14:31,920
of function delayed gpidr view if

333
00:14:31,920 --> 00:14:34,800
unreferenced

334
00:14:34,800 --> 00:14:37,440
delete gpudl will

335
00:14:37,440 --> 00:14:40,639
reference the delete v4 from a

336
00:14:40,639 --> 00:14:42,639
generic table and free

337
00:14:42,639 --> 00:14:45,680
by reverse engineering i find delete

338
00:14:45,680 --> 00:14:49,120
element gp generic table avr

339
00:14:49,120 --> 00:14:51,680
not only deletes a specified

340
00:14:51,680 --> 00:14:54,079
element from a general table but also

341
00:14:54,079 --> 00:14:55,839
free the

342
00:14:55,839 --> 00:14:58,720
specified element and i find

343
00:14:58,720 --> 00:15:01,440
unmapped gpadl wheels second parameter

344
00:15:01,440 --> 00:15:04,720
is gpedial handle gpidl handle can be

345
00:15:04,720 --> 00:15:07,360
controlled by a guest machine

346
00:15:07,360 --> 00:15:10,000
i found by calling function vm bus tier

347
00:15:10,000 --> 00:15:13,440
down gp adrian gaston machine

348
00:15:13,440 --> 00:15:16,560
we can reach to function unmapped gpadio

349
00:15:16,560 --> 00:15:19,360
will host and the gp adr handle can be

350
00:15:19,360 --> 00:15:21,760
controlled by a gas machine

351
00:15:21,760 --> 00:15:24,000
there are some important information

352
00:15:24,000 --> 00:15:27,839
about mmf adl view this function running

353
00:15:27,839 --> 00:15:31,199
at a multi-threaded

354
00:15:31,199 --> 00:15:32,800
environment

355
00:15:32,800 --> 00:15:34,880
actually multi-core

356
00:15:34,880 --> 00:15:37,360
process environment

357
00:15:37,360 --> 00:15:38,959
this function second parameter

358
00:15:38,959 --> 00:15:41,920
controlled by gaster data gpidl and the

359
00:15:41,920 --> 00:15:43,759
first parameter can be controlled by

360
00:15:43,759 --> 00:15:46,720
what channel we used indirectly

361
00:15:46,720 --> 00:15:49,040
as shown in picture i divide this

362
00:15:49,040 --> 00:15:51,279
function into three parts with different

363
00:15:51,279 --> 00:15:52,399
colors

364
00:15:52,399 --> 00:15:55,759
slid one already acquired the

365
00:15:55,759 --> 00:15:59,040
spin lock and the invoke

366
00:15:59,040 --> 00:16:01,600
lookup element generic table reveal and

367
00:16:01,600 --> 00:16:05,360
then exit the graphical region

368
00:16:05,360 --> 00:16:08,720
step two doing something and try to

369
00:16:08,720 --> 00:16:11,040
acquire the spin lock

370
00:16:11,040 --> 00:16:14,800
state 3 will invoke delete gpatlview if

371
00:16:14,800 --> 00:16:17,759
i referenced and exists the

372
00:16:17,759 --> 00:16:19,759
crypto region

373
00:16:19,759 --> 00:16:23,040
now we assume the following situation

374
00:16:23,040 --> 00:16:24,880
there are two threads threat a and

375
00:16:24,880 --> 00:16:27,519
thread b they are running on different

376
00:16:27,519 --> 00:16:28,720
cpus

377
00:16:28,720 --> 00:16:31,440
thread a and thread b will run into mf

378
00:16:31,440 --> 00:16:33,920
gp adr at the same time

379
00:16:33,920 --> 00:16:36,720
both of two thread call function map gpa

380
00:16:36,720 --> 00:16:39,360
dl view has a same parameter

381
00:16:39,360 --> 00:16:41,759
and the thread is a little more faster

382
00:16:41,759 --> 00:16:45,759
than thread b according to a ball assume

383
00:16:45,759 --> 00:16:48,480
the following is the two thread step

384
00:16:48,480 --> 00:16:49,759
step

385
00:16:49,759 --> 00:16:52,320
thread a will first acquire the spring

386
00:16:52,320 --> 00:16:54,959
lock thread a is in state 1 and holds

387
00:16:54,959 --> 00:16:57,680
the log at the same time thread b will

388
00:16:57,680 --> 00:16:59,600
waiting for the spring lock

389
00:16:59,600 --> 00:17:02,160
step 2 thread a call function element

390
00:17:02,160 --> 00:17:04,160
generate table avail and return a

391
00:17:04,160 --> 00:17:06,720
pointer pointer a then straight a

392
00:17:06,720 --> 00:17:09,599
release the spring lock step three

393
00:17:09,599 --> 00:17:12,720
thread b acquire the sim spring lock

394
00:17:12,720 --> 00:17:14,959
thread a acquires bin lock and waiting

395
00:17:14,959 --> 00:17:16,480
for the spin lock

396
00:17:16,480 --> 00:17:19,280
now thread a is in

397
00:17:19,280 --> 00:17:22,079
state two thread b is instead one and

398
00:17:22,079 --> 00:17:23,359
host log

399
00:17:23,359 --> 00:17:26,799
step four thread b call function look up

400
00:17:26,799 --> 00:17:29,280
element general table and return a

401
00:17:29,280 --> 00:17:31,200
pointer pointer b

402
00:17:31,200 --> 00:17:33,360
and then it release the

403
00:17:33,360 --> 00:17:35,280
spin lock because two thread call

404
00:17:35,280 --> 00:17:37,919
function map gpadl will have a same

405
00:17:37,919 --> 00:17:40,640
parameter pointer b is equal to pointer

406
00:17:40,640 --> 00:17:41,919
a

407
00:17:41,919 --> 00:17:44,480
step five thread a will

408
00:17:44,480 --> 00:17:46,480
acquire the spin lock and the invoke

409
00:17:46,480 --> 00:17:49,280
function delete gpidr view if

410
00:17:49,280 --> 00:17:51,840
unreferenced to free memory which

411
00:17:51,840 --> 00:17:54,720
pointer 8.2 and delete point array from

412
00:17:54,720 --> 00:17:56,240
a generic table

413
00:17:56,240 --> 00:17:59,520
then thread b is in state 2 thread a is

414
00:17:59,520 --> 00:18:00,960
in state three

415
00:18:00,960 --> 00:18:04,160
step six thread b will

416
00:18:04,160 --> 00:18:06,080
acquire the spin lock and the invoke

417
00:18:06,080 --> 00:18:09,280
function delete gpadl will if i

418
00:18:09,280 --> 00:18:11,919
reference the free memory which point b

419
00:18:11,919 --> 00:18:14,799
points to because point a is equal to

420
00:18:14,799 --> 00:18:16,000
point b

421
00:18:16,000 --> 00:18:19,360
delete gpadl will if a reference will

422
00:18:19,360 --> 00:18:21,600
use the already free memories

423
00:18:21,600 --> 00:18:24,080
pointer as the second parameter then

424
00:18:24,080 --> 00:18:25,440
casual

425
00:18:25,440 --> 00:18:27,760
so if we want to check this issue we

426
00:18:27,760 --> 00:18:31,039
must have two necessary conditions

427
00:18:31,039 --> 00:18:33,840
one there are two no

428
00:18:33,840 --> 00:18:35,200
interfering

429
00:18:35,200 --> 00:18:37,120
threats run to function

430
00:18:37,120 --> 00:18:40,000
unmapped gpadl view two two threads call

431
00:18:40,000 --> 00:18:41,679
this function has the same second

432
00:18:41,679 --> 00:18:45,280
parameter in a word have a same gpa dll

433
00:18:45,280 --> 00:18:46,320
handle

434
00:18:46,320 --> 00:18:48,320
functionally i find two thread call

435
00:18:48,320 --> 00:18:51,280
function and map gpadl will have a sim

436
00:18:51,280 --> 00:18:52,799
second parameter

437
00:18:52,799 --> 00:18:53,840
and the

438
00:18:53,840 --> 00:18:55,520
guest machine

439
00:18:55,520 --> 00:18:57,440
environment i can control these two

440
00:18:57,440 --> 00:18:59,720
threads be able to become two

441
00:18:59,720 --> 00:19:02,799
non-interfering threads the picture is

442
00:19:02,799 --> 00:19:05,520
these two thread stock batteries

443
00:19:05,520 --> 00:19:07,919
threat one can be triggered by some

444
00:19:07,919 --> 00:19:10,880
revoke receive buffer message and the

445
00:19:10,880 --> 00:19:13,679
gpdr teardown message in your guest

446
00:19:13,679 --> 00:19:15,760
machine the picture is the

447
00:19:15,760 --> 00:19:18,559
implementation in poc thread b can be

448
00:19:18,559 --> 00:19:21,200
triggered by a simulation press system

449
00:19:21,200 --> 00:19:23,440
receipt key in a

450
00:19:23,440 --> 00:19:25,200
the machine the picture is the

451
00:19:25,200 --> 00:19:28,000
implementation in poc mirror reset

452
00:19:28,000 --> 00:19:30,559
system can be triggered an important

453
00:19:30,559 --> 00:19:32,960
thread to control both thread one and

454
00:19:32,960 --> 00:19:35,520
thread two become two non-interfering

455
00:19:35,520 --> 00:19:38,160
threads the following is the important

456
00:19:38,160 --> 00:19:40,080
thread stock batteries

457
00:19:40,080 --> 00:19:41,679
but the important thread should be

458
00:19:41,679 --> 00:19:44,160
running before thread run and thread two

459
00:19:44,160 --> 00:19:46,320
so we should use the following coding

460
00:19:46,320 --> 00:19:50,000
plc to set function revoke result

461
00:19:50,000 --> 00:19:52,799
receive buffer work adam into a

462
00:19:52,799 --> 00:19:54,960
sleep state the following is the

463
00:19:54,960 --> 00:19:58,559
implementation in poc

464
00:19:58,559 --> 00:20:02,480
the pre-sample of about code in poc as a

465
00:20:02,480 --> 00:20:05,039
set function revoke receive buffer work

466
00:20:05,039 --> 00:20:08,880
item second parameter offset 0x zeros

467
00:20:08,880 --> 00:20:10,240
memory to

468
00:20:10,240 --> 00:20:13,200
a not zero value and in this function

469
00:20:13,200 --> 00:20:15,840
we'll enter a sleep state until

470
00:20:15,840 --> 00:20:20,000
offset 0x e0's memory set to zero

471
00:20:20,000 --> 00:20:22,640
functionally we can also use reset

472
00:20:22,640 --> 00:20:27,039
system to set zero in offset zero xz

473
00:20:27,039 --> 00:20:30,400
zeros memory indirectly

474
00:20:30,400 --> 00:20:32,600
now we can create two

475
00:20:32,600 --> 00:20:35,360
non-interference stretch stress

476
00:20:35,360 --> 00:20:37,520
run to function

477
00:20:37,520 --> 00:20:40,159
unmapped gpa dl wheel at the same time

478
00:20:40,159 --> 00:20:42,240
indirectly

479
00:20:42,240 --> 00:20:43,200
now that's

480
00:20:43,200 --> 00:20:44,799
trigger and debugging needs

481
00:20:44,799 --> 00:20:47,520
vulnerability in debugging log you can

482
00:20:47,520 --> 00:20:50,320
see the poc triggered important thread

483
00:20:50,320 --> 00:20:53,760
the pvt pass gaster stock and then at

484
00:20:53,760 --> 00:20:56,080
the red mark you can see the thread 2

485
00:20:56,080 --> 00:20:59,039
stock batteries the value of gp adr

486
00:20:59,039 --> 00:21:01,200
handle is e1e14

487
00:21:01,200 --> 00:21:03,440
the following in the following debugging

488
00:21:03,440 --> 00:21:06,080
log it is a thread 1

489
00:21:06,080 --> 00:21:08,159
stack batteries

490
00:21:08,159 --> 00:21:11,760
the value of gpadl handle is even even 4

491
00:21:11,760 --> 00:21:14,960
2 and then breakpoint 4 will trigger

492
00:21:14,960 --> 00:21:17,919
tracks the return values of lookup

493
00:21:17,919 --> 00:21:20,640
element generic table are same

494
00:21:20,640 --> 00:21:22,000
and boom

495
00:21:22,000 --> 00:21:23,600
as you can see the kernel pool is

496
00:21:23,600 --> 00:21:27,760
already free it's a typical u.s issue

497
00:21:27,760 --> 00:21:30,240
the root keys offer this vulnerability

498
00:21:30,240 --> 00:21:33,200
is risk condition because of vm shutdown

499
00:21:33,200 --> 00:21:36,080
then will also recycle the vm resource

500
00:21:36,080 --> 00:21:38,480
but we can also use some vm results and

501
00:21:38,480 --> 00:21:40,720
doing something for example in this case

502
00:21:40,720 --> 00:21:42,960
sender revokes receive buffer message

503
00:21:42,960 --> 00:21:46,000
when vm reset in a word your source will

504
00:21:46,000 --> 00:21:49,120
auto recycle i think this is a tip

505
00:21:49,120 --> 00:21:51,520
for bug hunting

506
00:21:51,520 --> 00:21:53,760
about applied thinking i think i should

507
00:21:53,760 --> 00:21:56,400
find a suitable object for kernel spuri

508
00:21:56,400 --> 00:21:58,480
but i found the time window between two

509
00:21:58,480 --> 00:22:01,039
threads is very short chronosphere

510
00:22:01,039 --> 00:22:03,840
control 3 is not easy to succeed now i

511
00:22:03,840 --> 00:22:05,679
thought maybe i should use interrupter

512
00:22:05,679 --> 00:22:07,520
to interfere

513
00:22:07,520 --> 00:22:10,159
with the one of the threads then case

514
00:22:10,159 --> 00:22:12,320
thread switching increase the time

515
00:22:12,320 --> 00:22:13,440
window

516
00:22:13,440 --> 00:22:16,400
but the stretch lock is a spin lock

517
00:22:16,400 --> 00:22:17,200
so

518
00:22:17,200 --> 00:22:20,000
i can't do it

519
00:22:20,400 --> 00:22:25,120
the latest rc vulnerability is a cv 2020

520
00:22:25,120 --> 00:22:26,799
16

521
00:22:26,799 --> 00:22:28,159
8 9

522
00:22:28,159 --> 00:22:32,159
1 this picture is the thing of the crash

523
00:22:32,159 --> 00:22:35,039
it is a uf issue in hyperbole root

524
00:22:35,039 --> 00:22:37,600
partitions vmwp process

525
00:22:37,600 --> 00:22:40,080
the vulnerability requests

526
00:22:40,080 --> 00:22:42,720
windows server category os and needs

527
00:22:42,720 --> 00:22:44,960
some settings

528
00:22:44,960 --> 00:22:48,080
in virtual switch manager select a

529
00:22:48,080 --> 00:22:51,440
network adapter that must support srov

530
00:22:51,440 --> 00:22:54,240
at the heart level for example i select

531
00:22:54,240 --> 00:22:56,039
the intel

532
00:22:56,039 --> 00:22:59,280
x540 address adapter

533
00:22:59,280 --> 00:23:03,120
the issue exists in function flash gva

534
00:23:03,120 --> 00:23:05,200
translation cac

535
00:23:05,200 --> 00:23:07,600
let's see what it looks like

536
00:23:07,600 --> 00:23:10,320
it is the code of this function

537
00:23:10,320 --> 00:23:13,520
and the right at the red mark

538
00:23:13,520 --> 00:23:15,840
gva translation

539
00:23:15,840 --> 00:23:17,520
cac invoke

540
00:23:17,520 --> 00:23:20,799
under contact remove reference

541
00:23:20,799 --> 00:23:24,320
and the contact removed with reference

542
00:23:24,320 --> 00:23:25,760
invoke

543
00:23:25,760 --> 00:23:28,880
decrement user connect to free of vm

544
00:23:28,880 --> 00:23:30,080
b

545
00:23:30,080 --> 00:23:32,159
com mmo

546
00:23:32,159 --> 00:23:36,000
handler adapter object if the function

547
00:23:36,000 --> 00:23:38,159
under contact remove

548
00:23:38,159 --> 00:23:42,000
reference first parameter of set minus

549
00:23:42,000 --> 00:23:43,600
0x5

550
00:23:43,600 --> 00:23:46,640
0 value is 1. actually the first

551
00:23:46,640 --> 00:23:48,679
parameter of size minus

552
00:23:48,679 --> 00:23:50,799
0x50 is a

553
00:23:50,799 --> 00:23:53,039
reference counter's address in the

554
00:23:53,039 --> 00:23:54,080
following

555
00:23:54,080 --> 00:23:55,440
presentation

556
00:23:55,440 --> 00:23:58,159
the reference counter will be referred

557
00:23:58,159 --> 00:24:02,799
to as key riff contour

558
00:24:02,960 --> 00:24:06,000
handle hd callback can also invoke

559
00:24:06,000 --> 00:24:09,360
decrement user count to decrease an

560
00:24:09,360 --> 00:24:12,960
object's reference count the key riff

561
00:24:12,960 --> 00:24:15,679
coins can be modified by this function

562
00:24:15,679 --> 00:24:19,200
the poc code is ctrl vmwp process runs

563
00:24:19,200 --> 00:24:21,919
to function handle vhd

564
00:24:21,919 --> 00:24:24,960
callback offset 0xaae

565
00:24:24,960 --> 00:24:28,400
the principle of the code is send the

566
00:24:28,400 --> 00:24:33,520
pci bus d0 entry and the pci bus d0 exit

567
00:24:33,520 --> 00:24:37,279
message the pocx control vmwp process

568
00:24:37,279 --> 00:24:41,200
runs to address flash gva translation

569
00:24:41,200 --> 00:24:44,080
keck offset 0x9e

570
00:24:44,080 --> 00:24:48,480
this code rest 2 and 0 to an io address

571
00:24:48,480 --> 00:24:50,640
but what is it

572
00:24:50,640 --> 00:24:52,799
by referring the

573
00:24:52,799 --> 00:24:55,360
this kernel source tree

574
00:24:55,360 --> 00:24:58,480
i find the offset is a

575
00:24:58,480 --> 00:25:02,240
pci commands i o address and the right 2

576
00:25:02,240 --> 00:25:05,360
and the 0 to an l right address maybe

577
00:25:05,360 --> 00:25:08,960
means enable and disable

578
00:25:08,960 --> 00:25:11,760
response in memory space

579
00:25:11,760 --> 00:25:13,120
now let's trigger this back and

580
00:25:13,120 --> 00:25:15,679
debugging for example the key riff

581
00:25:15,679 --> 00:25:19,039
contour is like this omit some debug can

582
00:25:19,039 --> 00:25:21,520
contact and we come to the place where

583
00:25:21,520 --> 00:25:24,000
the issue happened in the picture the

584
00:25:24,000 --> 00:25:25,279
key riff

585
00:25:25,279 --> 00:25:26,559
counter is

586
00:25:26,559 --> 00:25:29,200
decremented by one item

587
00:25:29,200 --> 00:25:32,960
v when d complete completation hundred

588
00:25:32,960 --> 00:25:36,559
hundred phd callback offset zero x a

589
00:25:36,559 --> 00:25:37,279
e

590
00:25:37,279 --> 00:25:39,760
in the following debugging log the key

591
00:25:39,760 --> 00:25:42,559
riff counter's value is 1

592
00:25:42,559 --> 00:25:45,600
vmp com mmi oh

593
00:25:45,600 --> 00:25:49,120
handle adapter object will be recycled

594
00:25:49,120 --> 00:25:50,000
now

595
00:25:50,000 --> 00:25:53,440
the risk object has not been free yet

596
00:25:53,440 --> 00:25:55,200
that's single step tracking and

597
00:25:55,200 --> 00:25:59,520
debugging the bmwp process runs to

598
00:25:59,520 --> 00:26:03,520
flash gva translation cac and invoke

599
00:26:03,520 --> 00:26:05,919
context remove reference

600
00:26:05,919 --> 00:26:08,159
enable the breakpoint 3 and you can see

601
00:26:08,159 --> 00:26:11,440
the stock batteries of recycle this

602
00:26:11,440 --> 00:26:12,799
object

603
00:26:12,799 --> 00:26:15,679
let's enable breakpoint 0 and continue

604
00:26:15,679 --> 00:26:17,039
running this

605
00:26:17,039 --> 00:26:20,320
process in the picture emulate vp

606
00:26:20,320 --> 00:26:22,000
actually

607
00:26:22,000 --> 00:26:23,120
attempt

608
00:26:23,120 --> 00:26:24,919
emulation of set

609
00:26:24,919 --> 00:26:28,640
0x290 uses a already free hip memory the

610
00:26:28,640 --> 00:26:31,960
rcx register value is the

611
00:26:31,960 --> 00:26:33,600
vmb

612
00:26:33,600 --> 00:26:38,640
com mmio hunter objector object address

613
00:26:38,640 --> 00:26:40,960
if we can control the contact of this

614
00:26:40,960 --> 00:26:44,159
object that has been freed here

615
00:26:44,159 --> 00:26:47,600
maybe we can control the irp register

616
00:26:47,600 --> 00:26:49,679
so i thought i should find a suitable

617
00:26:49,679 --> 00:26:51,279
object of

618
00:26:51,279 --> 00:26:52,799
hip 3 in

619
00:26:52,799 --> 00:26:56,960
bmwp process but i'm still looking for

620
00:26:56,960 --> 00:26:59,200
about attack interface

621
00:26:59,200 --> 00:27:02,799
a figure is an overview of a

622
00:27:02,799 --> 00:27:04,880
hyperbolic attack interface where the

623
00:27:04,880 --> 00:27:06,960
red markers represent

624
00:27:06,960 --> 00:27:09,440
the component where the vulnerability

625
00:27:09,440 --> 00:27:12,000
have been disclosed so far

626
00:27:12,000 --> 00:27:15,120
hypervisor attack interface has can be

627
00:27:15,120 --> 00:27:16,480
reached by

628
00:27:16,480 --> 00:27:19,279
executing vm call instruction reading

629
00:27:19,279 --> 00:27:21,120
and writing

630
00:27:21,120 --> 00:27:23,360
msr register

631
00:27:23,360 --> 00:27:27,279
operating apic address and running

632
00:27:27,279 --> 00:27:29,279
net is the

633
00:27:29,279 --> 00:27:31,679
virtual machine vmware's attack

634
00:27:31,679 --> 00:27:34,000
interface can be reached by sending

635
00:27:34,000 --> 00:27:35,360
channel message

636
00:27:35,360 --> 00:27:37,039
host driver

637
00:27:37,039 --> 00:27:39,840
tech interface can be reached by calling

638
00:27:39,840 --> 00:27:42,880
vmware send package function to sender

639
00:27:42,880 --> 00:27:45,360
gaster data to a specified virtual

640
00:27:45,360 --> 00:27:46,399
device

641
00:27:46,399 --> 00:27:48,399
the figure shows the relationships

642
00:27:48,399 --> 00:27:50,799
between the driver fails in

643
00:27:50,799 --> 00:27:52,880
virtual machine and the ring three

644
00:27:52,880 --> 00:27:55,440
components in the host machine

645
00:27:55,440 --> 00:27:57,120
including thoughts

646
00:27:57,120 --> 00:27:58,960
there are some of my thoughts on

647
00:27:58,960 --> 00:28:00,320
hyperbaric

648
00:28:00,320 --> 00:28:02,799
security research i think heparin still

649
00:28:02,799 --> 00:28:05,520
has low hanging apples because some new

650
00:28:05,520 --> 00:28:07,840
vulnerability trigger logic is very

651
00:28:07,840 --> 00:28:08,799
shallow

652
00:28:08,799 --> 00:28:11,200
and it makes more sense to make a way to

653
00:28:11,200 --> 00:28:14,480
export hyperwhip and export is far more

654
00:28:14,480 --> 00:28:17,279
vulnerable like than poc it makes sense

655
00:28:17,279 --> 00:28:20,240
to pay attention to hyper-v

656
00:28:20,240 --> 00:28:21,440
updates

657
00:28:21,440 --> 00:28:24,159
new features and new updates of some

658
00:28:24,159 --> 00:28:26,480
components make it easier to find the

659
00:28:26,480 --> 00:28:29,679
vulnerability it is an easy way for

660
00:28:29,679 --> 00:28:31,279
bug counting

661
00:28:31,279 --> 00:28:33,120
there are some might there are some

662
00:28:33,120 --> 00:28:36,240
thoughts on potential attack interface

663
00:28:36,240 --> 00:28:39,039
the package direct function in

664
00:28:39,039 --> 00:28:42,159
vm switch and the work direct device are

665
00:28:42,159 --> 00:28:44,799
not enabled in default

666
00:28:44,799 --> 00:28:48,720
configuration which becomes a potential

667
00:28:48,720 --> 00:28:50,320
attack interface

668
00:28:50,320 --> 00:28:53,600
pci pass-through and notice the

669
00:28:53,600 --> 00:28:57,679
virtualization are also good research

670
00:28:57,679 --> 00:28:58,480
because

671
00:28:58,480 --> 00:29:00,720
these functions are not com commonly

672
00:29:00,720 --> 00:29:02,159
used

673
00:29:02,159 --> 00:29:06,080
thank you for your listening

