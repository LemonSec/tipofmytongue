1
00:00:01,130 --> 00:00:14,239
[Music]

2
00:00:14,240 --> 00:00:16,880
hello everyone welcome to our talk my

3
00:00:16,880 --> 00:00:19,680
name is jin long from 360 alpha lab

4
00:00:19,680 --> 00:00:21,840
today my colleague joe pong and i are

5
00:00:21,840 --> 00:00:23,600
going to share and support chain to

6
00:00:23,600 --> 00:00:26,000
remotely root modern android devices

7
00:00:26,000 --> 00:00:28,400
with only two vulnerabilities

8
00:00:28,400 --> 00:00:30,720
this work is also contributed by han

9
00:00:30,720 --> 00:00:33,520
hong li and monsanto we are all security

10
00:00:33,520 --> 00:00:36,399
researchers at 360 alpha lab

11
00:00:36,399 --> 00:00:38,480
our team mainly focuses on mobile

12
00:00:38,480 --> 00:00:41,360
security including trust zone kernel

13
00:00:41,360 --> 00:00:44,480
applications like browser and so on we

14
00:00:44,480 --> 00:00:46,320
have reported more than 400

15
00:00:46,320 --> 00:00:48,960
vulnerabilities to top vendors and won

16
00:00:48,960 --> 00:00:51,920
the highest reward of the asr program in

17
00:00:51,920 --> 00:00:53,360
2017

18
00:00:53,360 --> 00:00:57,039
and google apr in 2019

19
00:00:57,039 --> 00:00:59,359
we also successfully planned many

20
00:00:59,359 --> 00:01:04,160
targets in poncho on and tm4 contests

21
00:01:04,720 --> 00:01:08,400
this talk many consists of four parts

22
00:01:08,400 --> 00:01:10,560
a brief review of the remote attack

23
00:01:10,560 --> 00:01:13,360
surface of android devices followed by

24
00:01:13,360 --> 00:01:16,159
the overview of our exploit chain

25
00:01:16,159 --> 00:01:17,920
then we will detail the root cause of

26
00:01:17,920 --> 00:01:20,000
this vulnerabilities and share the

27
00:01:20,000 --> 00:01:21,840
export strategy

28
00:01:21,840 --> 00:01:24,240
at last we will present a demo of

29
00:01:24,240 --> 00:01:28,080
remotely rooting a pixel 4.

30
00:01:28,080 --> 00:01:30,079
so let's get started

31
00:01:30,079 --> 00:01:32,479
for mobile device there are usually two

32
00:01:32,479 --> 00:01:34,799
types of entry points for known for

33
00:01:34,799 --> 00:01:37,040
non-physical attacks

34
00:01:37,040 --> 00:01:40,479
technologies such as bluetooth nfc and

35
00:01:40,479 --> 00:01:42,560
baseband allow mobile for remote

36
00:01:42,560 --> 00:01:44,079
communications

37
00:01:44,079 --> 00:01:46,640
so attackers can send malicious traffic

38
00:01:46,640 --> 00:01:48,960
to the connected device

39
00:01:48,960 --> 00:01:51,680
this kind of tech often doesn't need

40
00:01:51,680 --> 00:01:54,479
user interaction but is more limited in

41
00:01:54,479 --> 00:01:57,280
range as compared to the attack over the

42
00:01:57,280 --> 00:01:59,600
internet

43
00:01:59,600 --> 00:02:02,560
technologies such as mailing instant

44
00:02:02,560 --> 00:02:04,799
messaging and web browsers can be

45
00:02:04,799 --> 00:02:07,119
targeted over the internet

46
00:02:07,119 --> 00:02:09,520
and have a larger test service on their

47
00:02:09,520 --> 00:02:10,560
own

48
00:02:10,560 --> 00:02:12,879
as they often must deal with executing

49
00:02:12,879 --> 00:02:15,680
applications logic rendering of web

50
00:02:15,680 --> 00:02:19,280
pages and other online protocols

51
00:02:19,280 --> 00:02:22,239
a typical remote solution is to use the

52
00:02:22,239 --> 00:02:25,360
browser as the entry point to obtain

53
00:02:25,360 --> 00:02:27,599
code execution capabilities in the

54
00:02:27,599 --> 00:02:29,040
render process

55
00:02:29,040 --> 00:02:32,239
since this process is highly sandboxed

56
00:02:32,239 --> 00:02:34,720
attackers need to change other box for

57
00:02:34,720 --> 00:02:36,560
escaping the sandbox

58
00:02:36,560 --> 00:02:39,519
and elevating privileged to system user

59
00:02:39,519 --> 00:02:41,840
or root

60
00:02:41,840 --> 00:02:44,080
since the last time our team discovered

61
00:02:44,080 --> 00:02:46,239
the tv zone explorer chain to achieve

62
00:02:46,239 --> 00:02:48,959
one click remote route on pixel 3

63
00:02:48,959 --> 00:02:51,280
we once again said afterwards this goal

64
00:02:51,280 --> 00:02:54,000
targeting new pixel devices with latest

65
00:02:54,000 --> 00:02:56,480
updates

66
00:02:56,800 --> 00:02:59,360
we named the new explorer chain man code

67
00:02:59,360 --> 00:03:03,120
and reported to google in july 2020

68
00:03:03,120 --> 00:03:04,959
so why mangkhut

69
00:03:04,959 --> 00:03:07,760
in september 2018 a typhon named

70
00:03:07,760 --> 00:03:10,800
mangkhut formed on the pacific ocean

71
00:03:10,800 --> 00:03:13,040
at about the same time a powerful

72
00:03:13,040 --> 00:03:15,120
vulnerability was introduced into the

73
00:03:15,120 --> 00:03:18,239
angel kernel which we used in this

74
00:03:18,239 --> 00:03:20,640
exploit chain to escalate from the

75
00:03:20,640 --> 00:03:24,159
highly sandbox process to root

76
00:03:24,159 --> 00:03:26,159
while the typhoon monkeys caused

77
00:03:26,159 --> 00:03:28,640
extensive damage in the real world

78
00:03:28,640 --> 00:03:30,560
the vulnerability may show its

79
00:03:30,560 --> 00:03:34,799
destructive power in cyberspace

80
00:03:35,440 --> 00:03:38,080
the exploit chain only consists of two

81
00:03:38,080 --> 00:03:41,200
bugs a type confusion bug in chrome

82
00:03:41,200 --> 00:03:43,680
and a kernel box which can be leveraged

83
00:03:43,680 --> 00:03:44,799
to ask

84
00:03:44,799 --> 00:03:46,959
to escalate from the highly sandbox

85
00:03:46,959 --> 00:03:49,040
process to root

86
00:03:49,040 --> 00:03:51,280
this chain affects a wide range of

87
00:03:51,280 --> 00:03:53,519
devices running multiple versions of

88
00:03:53,519 --> 00:03:55,120
android system

89
00:03:55,120 --> 00:03:57,760
and it is the first reported exploit

90
00:03:57,760 --> 00:04:00,480
chain to remotely rooting pixel 4

91
00:04:00,480 --> 00:04:01,200
and

92
00:04:01,200 --> 00:04:04,000
acknowledge it in google vrp annual

93
00:04:04,000 --> 00:04:06,480
report

94
00:04:07,040 --> 00:04:09,200
so here is the first step

95
00:04:09,200 --> 00:04:13,200
rce in chrome render process

96
00:04:13,760 --> 00:04:16,880
this bug exists in the promised or

97
00:04:16,880 --> 00:04:19,440
settled building function of chrome's vh

98
00:04:19,440 --> 00:04:21,279
javascript engine

99
00:04:21,279 --> 00:04:24,320
let's take a look at the function first

100
00:04:24,320 --> 00:04:26,800
it accepts an iterable object as

101
00:04:26,800 --> 00:04:29,440
parameter in which each member is a

102
00:04:29,440 --> 00:04:30,720
promise

103
00:04:30,720 --> 00:04:32,560
the function returns a promise

104
00:04:32,560 --> 00:04:35,919
immediately and the output promise is

105
00:04:35,919 --> 00:04:38,960
fulfilled with the jazz array only after

106
00:04:38,960 --> 00:04:42,240
all the giving promises have settled the

107
00:04:42,240 --> 00:04:44,479
array contains objects that each

108
00:04:44,479 --> 00:04:47,199
describes the outcome of each input

109
00:04:47,199 --> 00:04:49,680
promise

110
00:04:49,759 --> 00:04:51,520
here is an example

111
00:04:51,520 --> 00:04:54,320
the input contains two promises

112
00:04:54,320 --> 00:04:57,440
one is fulfilled with value one and the

113
00:04:57,440 --> 00:05:00,560
other is rejected with arrow two

114
00:05:00,560 --> 00:05:02,800
promise all settled returns a new

115
00:05:02,800 --> 00:05:04,800
promise as its output

116
00:05:04,800 --> 00:05:08,400
and we call the then method on it

117
00:05:08,400 --> 00:05:11,440
since all input promises have settled we

118
00:05:11,440 --> 00:05:14,320
get the result array in a callback

119
00:05:14,320 --> 00:05:17,199
the result array contains two objects

120
00:05:17,199 --> 00:05:20,560
adding the stereo and index one

121
00:05:20,560 --> 00:05:25,800
describing the output of input vertices

122
00:05:26,400 --> 00:05:28,880
from the perspective of code

123
00:05:28,880 --> 00:05:30,479
implementation

124
00:05:30,479 --> 00:05:34,160
way h needs to manage a result.js array

125
00:05:34,160 --> 00:05:36,840
and analog some space for storing the

126
00:05:36,840 --> 00:05:39,360
outcome for example when the first

127
00:05:39,360 --> 00:05:42,880
moment is fulfilled v8 stores the result

128
00:05:42,880 --> 00:05:45,759
in the fixed array adding that zero

129
00:05:45,759 --> 00:05:48,400
more importantly user could get the

130
00:05:48,400 --> 00:05:50,720
adjust array only after all the giving

131
00:05:50,720 --> 00:05:53,600
promises have settled which means if

132
00:05:53,600 --> 00:05:56,319
there is any promise stays in pending

133
00:05:56,319 --> 00:05:58,639
state where it would not return the jazz

134
00:05:58,639 --> 00:06:01,440
great to user

135
00:06:02,000 --> 00:06:04,880
so how does v8 know all promises are

136
00:06:04,880 --> 00:06:08,479
settled this requires a cross-context

137
00:06:08,479 --> 00:06:12,000
variable named remaining nms count

138
00:06:12,000 --> 00:06:14,800
it is initialized with the number of

139
00:06:14,800 --> 00:06:18,639
input promises and is decreased by 1

140
00:06:18,639 --> 00:06:21,280
when the promise is settled

141
00:06:21,280 --> 00:06:24,319
when it becomes 0 v8 would return the

142
00:06:24,319 --> 00:06:27,120
resultant rate

143
00:06:28,639 --> 00:06:31,840
according to the specification a promise

144
00:06:31,840 --> 00:06:34,479
is said to be settled if it is either

145
00:06:34,479 --> 00:06:36,880
fulfilled or rejected

146
00:06:36,880 --> 00:06:39,360
so either resolve animate function or

147
00:06:39,360 --> 00:06:42,240
reject element function will get call

148
00:06:42,240 --> 00:06:44,560
depending on the promise is fulfilled or

149
00:06:44,560 --> 00:06:46,160
rejected

150
00:06:46,160 --> 00:06:48,560
and both of them were eventually called

151
00:06:48,560 --> 00:06:51,360
promise or resolve elements closure

152
00:06:51,360 --> 00:06:53,120
function

153
00:06:53,120 --> 00:06:55,919
this is way well where it stores the

154
00:06:55,919 --> 00:06:58,639
promise outcome to a resultant rate and

155
00:06:58,639 --> 00:07:00,560
counts down the number of remaining

156
00:07:00,560 --> 00:07:03,840
pending promises

157
00:07:05,840 --> 00:07:08,400
this function is implemented using

158
00:07:08,400 --> 00:07:10,240
torque language

159
00:07:10,240 --> 00:07:12,240
whose syntax looks like

160
00:07:12,240 --> 00:07:13,680
typescript

161
00:07:13,680 --> 00:07:16,000
we can see that it reads remaining ms

162
00:07:16,000 --> 00:07:18,400
count from the function context slot

163
00:07:18,400 --> 00:07:19,280
first

164
00:07:19,280 --> 00:07:22,560
and subtract 1 and save it back to the

165
00:07:22,560 --> 00:07:24,240
context

166
00:07:24,240 --> 00:07:27,280
when remaining anim's count becomes to 0

167
00:07:27,280 --> 00:07:29,520
the function will return an array of

168
00:07:29,520 --> 00:07:32,719
objects as a result

169
00:07:34,400 --> 00:07:36,319
normally add the resolve element

170
00:07:36,319 --> 00:07:38,319
function where reject animate function

171
00:07:38,319 --> 00:07:41,360
should only be called once at most

172
00:07:41,360 --> 00:07:43,280
which means turning a pending promise

173
00:07:43,280 --> 00:07:46,240
into a full field or rejected state

174
00:07:46,240 --> 00:07:49,280
but what if we could call them both

175
00:07:49,280 --> 00:07:51,680
the remaining enemies count would be

176
00:07:51,680 --> 00:07:53,280
decreased by 2

177
00:07:53,280 --> 00:07:56,319
and it would become to 0 when only half

178
00:07:56,319 --> 00:07:59,440
of input promises are settled

179
00:07:59,440 --> 00:08:01,919
as a result user will get the result

180
00:08:01,919 --> 00:08:05,680
array at an earlier time

181
00:08:06,479 --> 00:08:09,599
here is a profile concept about how to

182
00:08:09,599 --> 00:08:12,400
get these two functions we call the

183
00:08:12,400 --> 00:08:14,960
promise or settled function on our

184
00:08:14,960 --> 00:08:17,039
custom divide class

185
00:08:17,039 --> 00:08:19,520
where it would call the resolve method

186
00:08:19,520 --> 00:08:21,360
to get next promise

187
00:08:21,360 --> 00:08:24,000
and try to call the dam method defined

188
00:08:24,000 --> 00:08:27,199
on the next premise we can see that

189
00:08:27,199 --> 00:08:29,680
resolve anime function and reject enemy

190
00:08:29,680 --> 00:08:31,120
function are

191
00:08:31,120 --> 00:08:33,360
passed as parameters

192
00:08:33,360 --> 00:08:35,440
that's how we get these two functions

193
00:08:35,440 --> 00:08:37,760
and we can call any of them whenever we

194
00:08:37,760 --> 00:08:40,240
want

195
00:08:40,240 --> 00:08:43,200
so this may result in type confusion if

196
00:08:43,200 --> 00:08:45,920
the attacker gets the dot array and

197
00:08:45,920 --> 00:08:47,600
there are actually still something

198
00:08:47,600 --> 00:08:50,800
performances needs to process

199
00:08:50,800 --> 00:08:53,600
vas believes that the backing store is

200
00:08:53,600 --> 00:08:56,320
always a fixed array while we can change

201
00:08:56,320 --> 00:08:58,800
it to a number dictionary

202
00:08:58,800 --> 00:09:01,600
suppose the first promise is settled

203
00:09:01,600 --> 00:09:04,320
then v8 tries to write the result to a

204
00:09:04,320 --> 00:09:07,839
fixed array at index 0.

205
00:09:07,839 --> 00:09:10,800
actually grew up the metadata field of a

206
00:09:10,800 --> 00:09:13,760
number dictionary

207
00:09:15,040 --> 00:09:17,440
the approach to achieve out-of-bounds

208
00:09:17,440 --> 00:09:19,680
right seems very straightforward at

209
00:09:19,680 --> 00:09:21,120
first bounce

210
00:09:21,120 --> 00:09:23,600
when it stores a value to the result

211
00:09:23,600 --> 00:09:26,240
array it first checks whether the index

212
00:09:26,240 --> 00:09:29,279
is in bounds of the array

213
00:09:29,279 --> 00:09:31,760
if the index is smaller than the array

214
00:09:31,760 --> 00:09:34,720
length way it just stores the value is

215
00:09:34,720 --> 00:09:36,560
back in store

216
00:09:36,560 --> 00:09:38,880
with type confusion even though the

217
00:09:38,880 --> 00:09:41,519
array length could be a large number

218
00:09:41,519 --> 00:09:44,560
which can be which can bypass the inbox

219
00:09:44,560 --> 00:09:45,360
check

220
00:09:45,360 --> 00:09:47,200
the size of number dictionary may be

221
00:09:47,200 --> 00:09:48,560
small

222
00:09:48,560 --> 00:09:50,800
thus and other bonds right could be

223
00:09:50,800 --> 00:09:54,240
triggered at line eight

224
00:09:55,600 --> 00:09:58,240
unfortunately this would only crash the

225
00:09:58,240 --> 00:10:00,560
process because there is another

226
00:10:00,560 --> 00:10:03,120
outbound check when torque compiler

227
00:10:03,120 --> 00:10:05,279
generates code like that

228
00:10:05,279 --> 00:10:08,079
so we want to figure out another way

229
00:10:08,079 --> 00:10:10,800
another constraint is that we cannot

230
00:10:10,800 --> 00:10:12,720
control the content of data to be

231
00:10:12,720 --> 00:10:15,680
writing precisely it is always an

232
00:10:15,680 --> 00:10:18,720
address of a js object which describes

233
00:10:18,720 --> 00:10:22,880
the outcome of the settled promise

234
00:10:24,640 --> 00:10:26,800
since the output points white is not

235
00:10:26,800 --> 00:10:29,839
working so what else is valuable to

236
00:10:29,839 --> 00:10:33,600
overwrite inside the number dictionary

237
00:10:33,600 --> 00:10:36,560
the capacity field indicates the maximum

238
00:10:36,560 --> 00:10:38,800
number of entries the dictionary can

239
00:10:38,800 --> 00:10:42,560
have which seems to be a good target

240
00:10:42,560 --> 00:10:44,959
by overwriting these fields with the

241
00:10:44,959 --> 00:10:48,399
address of a js object which is usually

242
00:10:48,399 --> 00:10:50,560
a relatively large number

243
00:10:50,560 --> 00:10:53,120
we can trigger out of bounds axis

244
00:10:53,120 --> 00:10:55,200
through the victim array

245
00:10:55,200 --> 00:10:56,959
however this

246
00:10:56,959 --> 00:11:00,480
offset of autobahn out of bounds axis is

247
00:11:00,480 --> 00:11:01,519
not

248
00:11:01,519 --> 00:11:04,240
predictable because of the way of way to

249
00:11:04,240 --> 00:11:07,920
read or write a dictionary

250
00:11:08,720 --> 00:11:11,279
after more research we choose to corrupt

251
00:11:11,279 --> 00:11:13,440
a max number key field

252
00:11:13,440 --> 00:11:15,760
which converts the type confusion block

253
00:11:15,760 --> 00:11:20,160
to another out of bounds read problem

254
00:11:21,360 --> 00:11:24,160
max number key indicates the maximum

255
00:11:24,160 --> 00:11:26,880
valid index of number dictionary and

256
00:11:26,880 --> 00:11:29,920
more importantly its least significant

257
00:11:29,920 --> 00:11:32,480
bit indicates whether there is special

258
00:11:32,480 --> 00:11:36,320
elements in the array such as accessors

259
00:11:36,320 --> 00:11:39,200
for example if we define a gather at

260
00:11:39,200 --> 00:11:42,160
index 0 the array is treated as a

261
00:11:42,160 --> 00:11:44,959
special array because it will trigger

262
00:11:44,959 --> 00:11:47,200
user-defined codes while accessing the

263
00:11:47,200 --> 00:11:49,600
element

264
00:11:50,079 --> 00:11:52,880
if the bit is set to 1 it means the

265
00:11:52,880 --> 00:11:56,079
number dictionary has no special element

266
00:11:56,079 --> 00:11:58,480
but by exploring the type confusion bug

267
00:11:58,480 --> 00:12:00,639
we can corrupt these fields with the

268
00:12:00,639 --> 00:12:03,279
address of a js object

269
00:12:03,279 --> 00:12:06,560
and the least significant bit of any hip

270
00:12:06,560 --> 00:12:08,639
object addressed in v8

271
00:12:08,639 --> 00:12:10,880
is exactly one

272
00:12:10,880 --> 00:12:13,120
so taken together we can make the

273
00:12:13,120 --> 00:12:17,200
special array not that special

274
00:12:18,240 --> 00:12:21,200
so the next step is to find a place

275
00:12:21,200 --> 00:12:23,839
where we can use our special array to

276
00:12:23,839 --> 00:12:26,320
gain more powerful ability

277
00:12:26,320 --> 00:12:29,120
in this case the array prototype concat

278
00:12:29,120 --> 00:12:31,839
api would do the trick

279
00:12:31,839 --> 00:12:35,360
in iterate animate function it calls has

280
00:12:35,360 --> 00:12:37,440
only simple elements to check whether

281
00:12:37,440 --> 00:12:40,240
there is there are accessors on the

282
00:12:40,240 --> 00:12:42,560
receiver's elements

283
00:12:42,560 --> 00:12:45,440
as described before our special array

284
00:12:45,440 --> 00:12:48,399
could bypass the chip this check so that

285
00:12:48,399 --> 00:12:50,880
get element would be called in the first

286
00:12:50,880 --> 00:12:54,399
pass however there are in fact accessors

287
00:12:54,399 --> 00:12:56,160
defined on it

288
00:12:56,160 --> 00:12:59,360
which we can call back to our

289
00:12:59,360 --> 00:13:02,079
user-defined javascript codes

290
00:13:02,079 --> 00:13:04,880
and out of pawns read would be triggered

291
00:13:04,880 --> 00:13:06,959
if the array length has been changed to

292
00:13:06,959 --> 00:13:09,120
a smaller value while the iteration

293
00:13:09,120 --> 00:13:11,120
continues

294
00:13:11,120 --> 00:13:13,279
so we have successfully converted the

295
00:13:13,279 --> 00:13:15,600
type confusion bar to another out of

296
00:13:15,600 --> 00:13:18,240
bounds read

297
00:13:18,839 --> 00:13:22,639
block and the rest of work is not hard

298
00:13:22,639 --> 00:13:25,519
to achieve code execution from this oob

299
00:13:25,519 --> 00:13:28,320
read condition so i'm going to give a

300
00:13:28,320 --> 00:13:30,480
brief introduction here

301
00:13:30,480 --> 00:13:33,279
first we can link the address of a

302
00:13:33,279 --> 00:13:36,320
revolver's back in store and second fake

303
00:13:36,320 --> 00:13:40,240
a double jazz array in this red buffer

304
00:13:40,240 --> 00:13:42,480
then trigger the out of bounds read

305
00:13:42,480 --> 00:13:44,480
again to review the reference of the

306
00:13:44,480 --> 00:13:47,199
vague array in javascript holes

307
00:13:47,199 --> 00:13:50,160
first use the fake array to modify a

308
00:13:50,160 --> 00:13:52,639
victim a revolver's memory layout for

309
00:13:52,639 --> 00:13:56,320
object for actually read and write

310
00:13:56,320 --> 00:13:59,519
and next step is to write shellcode to a

311
00:13:59,519 --> 00:14:01,600
web assembly called arl

312
00:14:01,600 --> 00:14:03,839
and finally calls the webassembly

313
00:14:03,839 --> 00:14:07,839
function to execute shellcode

314
00:14:08,800 --> 00:14:10,880
now we can compromise the current render

315
00:14:10,880 --> 00:14:14,160
process and i'll hand it over to joepong

316
00:14:14,160 --> 00:14:16,880
to show you how to escape the sandbox to

317
00:14:16,880 --> 00:14:19,360
root privilege

318
00:14:19,360 --> 00:14:21,920
thanks jerome next i will share with you

319
00:14:21,920 --> 00:14:24,320
how to escape from sandballs to root

320
00:14:24,320 --> 00:14:26,800
with the bender bark with font

321
00:14:26,800 --> 00:14:29,519
first i will introduce why bender was

322
00:14:29,519 --> 00:14:32,240
choosing as a research target and seeing

323
00:14:32,240 --> 00:14:34,320
the cost of debug

324
00:14:34,320 --> 00:14:36,480
after we finally bark in order to verify

325
00:14:36,480 --> 00:14:39,920
the usability we first exploit it in a

326
00:14:39,920 --> 00:14:41,680
trusted app environment

327
00:14:41,680 --> 00:14:43,199
this part will be introduced in the

328
00:14:43,199 --> 00:14:44,800
third part

329
00:14:44,800 --> 00:14:47,600
after proving the utility of the bark

330
00:14:47,600 --> 00:14:49,360
we further complete

331
00:14:49,360 --> 00:14:50,959
the privileged escalation in the

332
00:14:50,959 --> 00:14:52,959
sandboxing environment

333
00:14:52,959 --> 00:14:54,959
this part is also one of the most

334
00:14:54,959 --> 00:14:56,160
interesting

335
00:14:56,160 --> 00:14:57,519
things today

336
00:14:57,519 --> 00:15:01,760
finally i will show you a demonstration

337
00:15:01,760 --> 00:15:04,560
in the team in zong exploration we used

338
00:15:04,560 --> 00:15:06,480
three vulnerabilities

339
00:15:06,480 --> 00:15:08,320
two of which were used to elevate

340
00:15:08,320 --> 00:15:11,040
permissions from sandbox to route this

341
00:15:11,040 --> 00:15:14,000
year we set out again and try to use

342
00:15:14,000 --> 00:15:15,680
only one bug

343
00:15:15,680 --> 00:15:18,000
to achieve this

344
00:15:18,000 --> 00:15:20,720
an android system vendor is one few

345
00:15:20,720 --> 00:15:22,880
drivers and it can be accessed inside

346
00:15:22,880 --> 00:15:24,560
the sandbox

347
00:15:24,560 --> 00:15:25,279
so

348
00:15:25,279 --> 00:15:27,600
its vulnerability can be directly used

349
00:15:27,600 --> 00:15:30,320
for sandbox escape

350
00:15:30,320 --> 00:15:31,440
this time

351
00:15:31,440 --> 00:15:34,079
we look to the vulnerability mining

352
00:15:34,079 --> 00:15:37,040
target on bender

353
00:15:37,040 --> 00:15:39,839
in fact the bender mulch has always been

354
00:15:39,839 --> 00:15:43,120
a hot topic for security researchers

355
00:15:43,120 --> 00:15:45,199
since the water job vulnerability has

356
00:15:45,199 --> 00:15:47,040
found

357
00:15:47,040 --> 00:15:48,880
multiple parks

358
00:15:48,880 --> 00:15:51,279
have been found in band driver for

359
00:15:51,279 --> 00:15:54,880
example project zero team fund one in

360
00:15:54,880 --> 00:15:57,920
2019 and the blue first stack team found

361
00:15:57,920 --> 00:16:00,399
one in 2020

362
00:16:00,399 --> 00:16:02,639
statistics shows that

363
00:16:02,639 --> 00:16:06,240
there is a barg for every 1000 and to my

364
00:16:06,240 --> 00:16:08,959
son and 500 lines of code

365
00:16:08,959 --> 00:16:10,800
and it's been the same file to those

366
00:16:10,800 --> 00:16:14,079
less than 6000 lines of code

367
00:16:14,079 --> 00:16:16,800
so we have to think about one question

368
00:16:16,800 --> 00:16:19,920
is there still such serious security

369
00:16:19,920 --> 00:16:21,600
park

370
00:16:21,600 --> 00:16:24,320
of course the answer is yes

371
00:16:24,320 --> 00:16:27,680
and that's why we're here today

372
00:16:27,680 --> 00:16:29,600
the band rules is like a new canadian

373
00:16:29,600 --> 00:16:30,959
warhead and the brothers are saying

374
00:16:30,959 --> 00:16:32,959
you'd like a launch pad

375
00:16:32,959 --> 00:16:35,360
the compilation of these two

376
00:16:35,360 --> 00:16:38,480
will become an incontinental nuclear

377
00:16:38,480 --> 00:16:40,000
power

378
00:16:40,000 --> 00:16:41,680
next

379
00:16:41,680 --> 00:16:44,160
i will introduce in detail how to use a

380
00:16:44,160 --> 00:16:46,959
band of vulnerability to achieve stable

381
00:16:46,959 --> 00:16:50,240
kernel archery read and write and

382
00:16:50,240 --> 00:16:54,000
finally get rooted in the sandbox

383
00:16:54,160 --> 00:16:57,040
a complete vendor communication process

384
00:16:57,040 --> 00:17:00,160
has a total of four steps first the

385
00:17:00,160 --> 00:17:02,079
clients send the bc transaction to the

386
00:17:02,079 --> 00:17:04,640
kernel and the kernel forward the

387
00:17:04,640 --> 00:17:06,799
request to a server

388
00:17:06,799 --> 00:17:09,839
using the server reply bc reply to the

389
00:17:09,839 --> 00:17:12,079
kernel after processing

390
00:17:12,079 --> 00:17:13,119
and

391
00:17:13,119 --> 00:17:14,480
forward it

392
00:17:14,480 --> 00:17:18,679
to the client and after process

393
00:17:18,959 --> 00:17:21,280
one point we want to pay attention to is

394
00:17:21,280 --> 00:17:22,480
that

395
00:17:22,480 --> 00:17:24,959
uh when sending the band object

396
00:17:24,959 --> 00:17:26,880
a better load object in the kernel will

397
00:17:26,880 --> 00:17:28,400
be created

398
00:17:28,400 --> 00:17:30,640
the better work it contains well insert

399
00:17:30,640 --> 00:17:33,120
into the strategy linkedin list

400
00:17:33,120 --> 00:17:35,679
and the reference to abandon note will

401
00:17:35,679 --> 00:17:38,160
also be inserted into the proper waves

402
00:17:38,160 --> 00:17:41,760
by node tree of target process

403
00:17:41,760 --> 00:17:44,480
normally clinic can process bandwidth

404
00:17:44,480 --> 00:17:47,200
load time work by spending threaded raid

405
00:17:47,200 --> 00:17:48,559
function

406
00:17:48,559 --> 00:17:49,840
however

407
00:17:49,840 --> 00:17:52,400
there is another way to process bandwork

408
00:17:52,400 --> 00:17:54,720
which is by sending vendors throughout

409
00:17:54,720 --> 00:17:56,640
the data command to trigger the battery

410
00:17:56,640 --> 00:17:59,120
network

411
00:17:59,360 --> 00:18:02,000
but this function has a risk problem

412
00:18:02,000 --> 00:18:04,960
after w is removed from machine

413
00:18:04,960 --> 00:18:07,840
there is a low load protection anymore

414
00:18:07,840 --> 00:18:10,320
so there is a risk window before

415
00:18:10,320 --> 00:18:12,799
accessing download type

416
00:18:12,799 --> 00:18:15,120
if the bandwagon finished between this

417
00:18:15,120 --> 00:18:16,160
window

418
00:18:16,160 --> 00:18:19,840
it will cause uaf problem

419
00:18:19,840 --> 00:18:20,720
then

420
00:18:20,720 --> 00:18:23,280
we take a look at when brand work as

421
00:18:23,280 --> 00:18:25,120
afraid before

422
00:18:25,120 --> 00:18:27,200
then radius work

423
00:18:27,200 --> 00:18:28,480
from this picture

424
00:18:28,480 --> 00:18:31,440
we can see after the server receives and

425
00:18:31,440 --> 00:18:34,240
processes the banner object it will send

426
00:18:34,240 --> 00:18:36,080
bc buffer free

427
00:18:36,080 --> 00:18:37,919
command to the kernel

428
00:18:37,919 --> 00:18:40,240
after receiving this command the kernel

429
00:18:40,240 --> 00:18:42,640
will find the corresponding better load

430
00:18:42,640 --> 00:18:44,960
according to a banner wave

431
00:18:44,960 --> 00:18:48,000
and decrease the reference counter

432
00:18:48,000 --> 00:18:50,000
if it is down to zero

433
00:18:50,000 --> 00:18:52,880
the banner load will be reduced

434
00:18:52,880 --> 00:18:55,520
if the rate succeeds

435
00:18:55,520 --> 00:18:57,520
a well-caused standard load to be

436
00:18:57,520 --> 00:19:00,880
reduced before accessing w time

437
00:19:00,880 --> 00:19:01,679
so

438
00:19:01,679 --> 00:19:04,400
how can we exploit this uaf

439
00:19:04,400 --> 00:19:05,840
vulnerability

440
00:19:05,840 --> 00:19:08,320
the key point of the uam vulnerability

441
00:19:08,320 --> 00:19:11,760
is used in the band radius function

442
00:19:11,760 --> 00:19:13,360
there are two branches that can

443
00:19:13,360 --> 00:19:15,919
configure the keyboard operation

444
00:19:15,919 --> 00:19:16,799
so

445
00:19:16,799 --> 00:19:19,600
this uaf problem can be converted into

446
00:19:19,600 --> 00:19:20,640
the

447
00:19:20,640 --> 00:19:22,320
double free problem if

448
00:19:22,320 --> 00:19:25,840
we can control the w type

449
00:19:26,559 --> 00:19:29,360
what we can do with adobe 3 which high

450
00:19:29,360 --> 00:19:31,520
check frame is to allocate a specific

451
00:19:31,520 --> 00:19:34,400
memory and write any content into it

452
00:19:34,400 --> 00:19:36,080
that's interesting

453
00:19:36,080 --> 00:19:38,240
we can use it to modify the swapper to

454
00:19:38,240 --> 00:19:41,360
achieve qsma attack

455
00:19:41,360 --> 00:19:43,600
next i will introduce the details about

456
00:19:43,600 --> 00:19:46,160
this process

457
00:19:46,160 --> 00:19:48,000
there are four steps to complete this

458
00:19:48,000 --> 00:19:49,120
thing

459
00:19:49,120 --> 00:19:50,840
for a uef

460
00:19:50,840 --> 00:19:53,600
problem the first step of course is

461
00:19:53,600 --> 00:19:56,240
using step unit hipsters to modify the

462
00:19:56,240 --> 00:19:58,880
content of a freight buffer

463
00:19:58,880 --> 00:20:00,960
because we want to launch customer

464
00:20:00,960 --> 00:20:02,240
attack

465
00:20:02,240 --> 00:20:06,000
kernel-based adjustment is needed also

466
00:20:06,000 --> 00:20:07,919
and then we'll talk about how to hijack

467
00:20:07,919 --> 00:20:12,000
brain boost and achieve customer attack

468
00:20:12,000 --> 00:20:14,720
it's not easy to do heavy spray as shown

469
00:20:14,720 --> 00:20:16,640
in the december code

470
00:20:16,640 --> 00:20:18,720
from unlocked to use there are only a

471
00:20:18,720 --> 00:20:21,760
few instructions to execute

472
00:20:21,760 --> 00:20:24,159
so the wrist windows

473
00:20:24,159 --> 00:20:27,039
was very narrow thus it's very difficult

474
00:20:27,039 --> 00:20:30,799
to change w type by doing hand spray

475
00:20:30,799 --> 00:20:32,000
this is a

476
00:20:32,000 --> 00:20:34,159
similar problem we have encountered when

477
00:20:34,159 --> 00:20:36,000
exploiting water job

478
00:20:36,000 --> 00:20:38,880
vulnerability

479
00:20:38,960 --> 00:20:40,159
similarly

480
00:20:40,159 --> 00:20:42,159
there are only a few instructions

481
00:20:42,159 --> 00:20:44,559
between unload and use

482
00:20:44,559 --> 00:20:47,440
the race window is also very short

483
00:20:47,440 --> 00:20:50,400
so what increase the success rate of

484
00:20:50,400 --> 00:20:52,080
risk

485
00:20:52,080 --> 00:20:53,840
throw analysis

486
00:20:53,840 --> 00:20:56,080
we found that the wake up q function is

487
00:20:56,080 --> 00:20:58,799
used in the mutax unlock operation

488
00:20:58,799 --> 00:21:02,640
let's have a look at this function

489
00:21:02,640 --> 00:21:06,320
we can see wake up q eventually course

490
00:21:06,320 --> 00:21:09,440
try to wake up to wake up other threat

491
00:21:09,440 --> 00:21:11,919
which means the mutex unlock operation

492
00:21:11,919 --> 00:21:14,720
will actively give up the cpu

493
00:21:14,720 --> 00:21:17,280
therefore we can bind buildable strat

494
00:21:17,280 --> 00:21:19,120
into one cpu

495
00:21:19,120 --> 00:21:20,559
and then use

496
00:21:20,559 --> 00:21:24,960
um mutex lock to wake up other

497
00:21:24,960 --> 00:21:26,320
race threat

498
00:21:26,320 --> 00:21:29,520
by this method you get nearly 100

499
00:21:29,520 --> 00:21:31,760
success rate

500
00:21:31,760 --> 00:21:34,159
but same method can be uh cannot be used

501
00:21:34,159 --> 00:21:36,960
here because spin knock is used in van

502
00:21:36,960 --> 00:21:39,280
der rien at queen workhead

503
00:21:39,280 --> 00:21:41,919
and when spin-off is reduced it will not

504
00:21:41,919 --> 00:21:45,679
wake up other spread that is to say

505
00:21:45,679 --> 00:21:50,000
it will not actively give up cpu

506
00:21:50,320 --> 00:21:52,559
actually there are two main ways to

507
00:21:52,559 --> 00:21:55,840
improve the success rate of history

508
00:21:55,840 --> 00:21:58,320
the first one in old school method just

509
00:21:58,320 --> 00:22:00,559
spend a cpu and increase number of half

510
00:22:00,559 --> 00:22:02,400
spring thread

511
00:22:02,400 --> 00:22:04,960
under preference scheduling

512
00:22:04,960 --> 00:22:07,360
you can always spend a chance in a race

513
00:22:07,360 --> 00:22:09,280
window

514
00:22:09,280 --> 00:22:11,520
a second one is special

515
00:22:11,520 --> 00:22:13,440
increase the number of band objects can

516
00:22:13,440 --> 00:22:15,679
also increase possibility

517
00:22:15,679 --> 00:22:17,919
because better radius work unsealed in

518
00:22:17,919 --> 00:22:20,799
loop assessment work

519
00:22:20,799 --> 00:22:23,120
more band objects means more chance to

520
00:22:23,120 --> 00:22:25,280
create wristing

521
00:22:25,280 --> 00:22:27,600
and another advantage is that spray

522
00:22:27,600 --> 00:22:30,240
figure will enter default branch and it

523
00:22:30,240 --> 00:22:34,799
won't result in any system of luminances

524
00:22:35,440 --> 00:22:38,159
as for the heav spray method we use send

525
00:22:38,159 --> 00:22:39,200
the message

526
00:22:39,200 --> 00:22:41,919
and once the history is completed

527
00:22:41,919 --> 00:22:44,559
a key free operation with an offset

528
00:22:44,559 --> 00:22:46,480
of 8 will be triggered

529
00:22:46,480 --> 00:22:48,960
and if we release the slab or copied by

530
00:22:48,960 --> 00:22:51,520
send message we can build a double phase

531
00:22:51,520 --> 00:22:53,679
scene

532
00:22:53,679 --> 00:22:56,320
after solving these three problems

533
00:22:56,320 --> 00:22:58,240
our next target is to need kernel

534
00:22:58,240 --> 00:22:59,840
address

535
00:22:59,840 --> 00:23:01,360
let's take a look at the method of

536
00:23:01,360 --> 00:23:03,679
converting the double phase first

537
00:23:03,679 --> 00:23:05,120
when double type is tempered with

538
00:23:05,120 --> 00:23:08,559
transaction completed by h3

539
00:23:08,559 --> 00:23:11,440
operation of k3w will be triggered

540
00:23:11,440 --> 00:23:12,240
and

541
00:23:12,240 --> 00:23:14,720
the offset of bandwagon invented load is

542
00:23:14,720 --> 00:23:17,360
8. so a double free with a certain

543
00:23:17,360 --> 00:23:20,879
offset will be formed

544
00:23:21,679 --> 00:23:23,600
this page shows the whole process of

545
00:23:23,600 --> 00:23:25,760
converting the uaf bar into the double

546
00:23:25,760 --> 00:23:27,120
free product

547
00:23:27,120 --> 00:23:29,120
the first step is to use send the

548
00:23:29,120 --> 00:23:31,520
message to do the hip spray

549
00:23:31,520 --> 00:23:33,120
if it raises

550
00:23:33,120 --> 00:23:34,720
succeed

551
00:23:34,720 --> 00:23:37,120
a plus eight will be treated as a heap

552
00:23:37,120 --> 00:23:38,480
and radius

553
00:23:38,480 --> 00:23:41,200
first after calling received message

554
00:23:41,200 --> 00:23:44,320
they will be released therefore a and a

555
00:23:44,320 --> 00:23:45,440
plus h

556
00:23:45,440 --> 00:23:47,679
exceeds uh unfriend news at the same

557
00:23:47,679 --> 00:23:49,679
time

558
00:23:49,679 --> 00:23:51,679
and there is overlap

559
00:23:51,679 --> 00:23:54,480
on memory area

560
00:23:54,480 --> 00:23:56,000
name let's have a look at the second

561
00:23:56,000 --> 00:23:57,440
file structure

562
00:23:57,440 --> 00:23:59,679
sigfi is a common structure type of

563
00:23:59,679 --> 00:24:02,480
virtual file system in linux

564
00:24:02,480 --> 00:24:04,640
multiple files in product directory is

565
00:24:04,640 --> 00:24:06,880
managed as sacrifice

566
00:24:06,880 --> 00:24:09,200
for some spanish software like product

567
00:24:09,200 --> 00:24:10,960
cpu info

568
00:24:10,960 --> 00:24:13,840
op field is a global structure address

569
00:24:13,840 --> 00:24:15,919
which can be used to nix kernel-based

570
00:24:15,919 --> 00:24:17,600
address

571
00:24:17,600 --> 00:24:18,559
so

572
00:24:18,559 --> 00:24:21,360
how to detect the how to mix the op

573
00:24:21,360 --> 00:24:22,720
pointer

574
00:24:22,720 --> 00:24:25,039
there are many five steps

575
00:24:25,039 --> 00:24:27,039
the first step of course is to trigger

576
00:24:27,039 --> 00:24:29,840
the mark and name we need to concoct a

577
00:24:29,840 --> 00:24:32,400
plus eight with banner load

578
00:24:32,400 --> 00:24:34,960
and then we call

579
00:24:34,960 --> 00:24:37,279
the same message to reduce aid

580
00:24:37,279 --> 00:24:40,720
now we can occupy a with signifier

581
00:24:40,720 --> 00:24:43,520
and core band thread rate to rate pdr

582
00:24:43,520 --> 00:24:46,720
out which is the op field of

583
00:24:46,720 --> 00:24:49,039
the circuit file

584
00:24:49,039 --> 00:24:51,279
the following content is relatively

585
00:24:51,279 --> 00:24:53,679
simple

586
00:24:53,919 --> 00:24:55,760
similar to the unique

587
00:24:55,760 --> 00:24:57,200
kernel address

588
00:24:57,200 --> 00:24:59,120
british hijacking can be roughly divided

589
00:24:59,120 --> 00:25:01,679
into six steps

590
00:25:01,679 --> 00:25:02,799
first step

591
00:25:02,799 --> 00:25:05,360
is to spray withstand message after the

592
00:25:05,360 --> 00:25:07,679
bug is triggered a plus 8 will be

593
00:25:07,679 --> 00:25:10,000
released and then we call receiving

594
00:25:10,000 --> 00:25:11,840
message to range a

595
00:25:11,840 --> 00:25:14,960
currently both a and a plus 8 is only

596
00:25:14,960 --> 00:25:16,320
finished

597
00:25:16,320 --> 00:25:20,240
the next steps are very interesting

598
00:25:20,559 --> 00:25:22,320
they will reallocate

599
00:25:22,320 --> 00:25:24,799
a back by sending message and red x into

600
00:25:24,799 --> 00:25:26,480
it

601
00:25:26,480 --> 00:25:29,679
now francis freddie's head is a plus 8

602
00:25:29,679 --> 00:25:32,240
then we call the master gate

603
00:25:32,240 --> 00:25:35,279
and get a plus 8 back now fringe the

604
00:25:35,279 --> 00:25:37,120
head x is x

605
00:25:37,120 --> 00:25:39,520
send a message again

606
00:25:39,520 --> 00:25:41,200
we can write any content into the

607
00:25:41,200 --> 00:25:43,840
address x

608
00:25:44,320 --> 00:25:46,880
now the next step is to

609
00:25:46,880 --> 00:25:49,600
launch customer attack

610
00:25:49,600 --> 00:25:51,760
there are first things we need to pay

611
00:25:51,760 --> 00:25:53,440
attention to

612
00:25:53,440 --> 00:25:55,279
kernel code segment physical start

613
00:25:55,279 --> 00:25:56,679
address is

614
00:25:56,679 --> 00:26:00,320
a20840 and ksma attack's basic map

615
00:26:00,320 --> 00:26:03,120
inside is one gigabyte so fake page

616
00:26:03,120 --> 00:26:06,159
table yields address 870 and

617
00:26:06,159 --> 00:26:09,360
offset 840 is needed when raid will

618
00:26:09,360 --> 00:26:12,320
write kernel code

619
00:26:12,320 --> 00:26:14,799
after each round of attempts it is

620
00:26:14,799 --> 00:26:16,720
necessary to check whether the page

621
00:26:16,720 --> 00:26:20,240
table has been successfully modified

622
00:26:20,240 --> 00:26:23,039
constantly writing explored in c we use

623
00:26:23,039 --> 00:26:25,039
that zhang and long jump to process

624
00:26:25,039 --> 00:26:26,559
exception

625
00:26:26,559 --> 00:26:28,960
if an exception is triggered any means

626
00:26:28,960 --> 00:26:31,520
swapper has been hasn't been modified

627
00:26:31,520 --> 00:26:33,840
yet

628
00:26:34,559 --> 00:26:37,840
according to the previously shared

629
00:26:37,840 --> 00:26:38,720
gamma

630
00:26:38,720 --> 00:26:41,279
we successfully completed the local

631
00:26:41,279 --> 00:26:44,080
privilege escalation

632
00:26:44,080 --> 00:26:46,000
as proven usability of this

633
00:26:46,000 --> 00:26:47,440
vulnerability

634
00:26:47,440 --> 00:26:49,919
they tried to complete the probability

635
00:26:49,919 --> 00:26:53,200
escalation sandbox to take further use

636
00:26:53,200 --> 00:26:57,120
of this power of this vulnerability

637
00:26:57,120 --> 00:26:59,440
there is no doubt that there are many

638
00:26:59,440 --> 00:27:02,799
restriction restrictions in the sandbox

639
00:27:02,799 --> 00:27:05,200
the first one is limited syscore which

640
00:27:05,200 --> 00:27:07,679
means we can't ban cpu anymore

641
00:27:07,679 --> 00:27:08,720
also

642
00:27:08,720 --> 00:27:11,919
buy any devices access is strictly

643
00:27:11,919 --> 00:27:13,360
restricted

644
00:27:13,360 --> 00:27:15,760
not to mention writing files

645
00:27:15,760 --> 00:27:18,320
any chrome sandbox enables its own vpnf

646
00:27:18,320 --> 00:27:19,440
rules

647
00:27:19,440 --> 00:27:23,120
the number one is that chrome is 32 bits

648
00:27:23,120 --> 00:27:25,840
and by kernel in 64 bits

649
00:27:25,840 --> 00:27:28,480
it has two effect the first is that it

650
00:27:28,480 --> 00:27:31,440
will cause its qualcomm patch ability

651
00:27:31,440 --> 00:27:32,880
problem

652
00:27:32,880 --> 00:27:38,480
a second is that ksma attack is not work

653
00:27:39,440 --> 00:27:41,360
therefore when we try to pull the local

654
00:27:41,360 --> 00:27:43,679
scale material sandbox

655
00:27:43,679 --> 00:27:46,480
we encounter two silver challenges

656
00:27:46,480 --> 00:27:49,039
the first one is load bending cpu

657
00:27:49,039 --> 00:27:50,240
so

658
00:27:50,240 --> 00:27:51,840
triggering the bark will be very

659
00:27:51,840 --> 00:27:53,279
difficult

660
00:27:53,279 --> 00:27:55,840
the second one is no ksma

661
00:27:55,840 --> 00:27:58,080
it means we have to find a total new

662
00:27:58,080 --> 00:28:00,559
solution which no one has used before

663
00:28:00,559 --> 00:28:03,440
but luckily send message still can be

664
00:28:03,440 --> 00:28:07,120
used to do hip spray

665
00:28:08,480 --> 00:28:10,880
these two limitations forces us to find

666
00:28:10,880 --> 00:28:12,399
a new solution

667
00:28:12,399 --> 00:28:14,080
which is very challenging

668
00:28:14,080 --> 00:28:16,399
but interesting

669
00:28:16,399 --> 00:28:18,640
we decided to solve the first problem

670
00:28:18,640 --> 00:28:19,520
first

671
00:28:19,520 --> 00:28:21,679
corresponding to hype feng shui we want

672
00:28:21,679 --> 00:28:24,159
to introduce a new concept called cpu

673
00:28:24,159 --> 00:28:25,679
functioning

674
00:28:25,679 --> 00:28:27,840
i think there are two factors that

675
00:28:27,840 --> 00:28:30,720
determine the success rate of race

676
00:28:30,720 --> 00:28:33,279
the first one is time slice

677
00:28:33,279 --> 00:28:35,440
it's a lot harder to understand

678
00:28:35,440 --> 00:28:37,760
that reducing time slice

679
00:28:37,760 --> 00:28:40,720
can increase the possibility to

680
00:28:40,720 --> 00:28:43,600
switch cpu in the risk window

681
00:28:43,600 --> 00:28:44,880
otherwise

682
00:28:44,880 --> 00:28:46,880
increase with schedule time can increase

683
00:28:46,880 --> 00:28:49,840
the possibility to let code block in

684
00:28:49,840 --> 00:28:52,240
different threads execute in a specific

685
00:28:52,240 --> 00:28:54,720
sequence

686
00:28:55,120 --> 00:28:57,120
based on these two factors

687
00:28:57,120 --> 00:28:59,279
we found some key method of cpu

688
00:28:59,279 --> 00:29:00,720
functionality

689
00:29:00,720 --> 00:29:02,399
the first one is creating multiple

690
00:29:02,399 --> 00:29:05,120
padding straps to increase

691
00:29:05,120 --> 00:29:06,640
cpu node

692
00:29:06,640 --> 00:29:09,120
penny thread does nothing but makes cpu

693
00:29:09,120 --> 00:29:10,799
very busy

694
00:29:10,799 --> 00:29:13,039
the second one is to adjust

695
00:29:13,039 --> 00:29:14,720
thread priority

696
00:29:14,720 --> 00:29:17,679
to influence surround time slice and

697
00:29:17,679 --> 00:29:20,480
with schedule time

698
00:29:20,480 --> 00:29:23,200
the last trick is to get currently long

699
00:29:23,200 --> 00:29:26,640
cpu is radiant from prostate file rather

700
00:29:26,640 --> 00:29:29,440
than the gas cpu

701
00:29:29,440 --> 00:29:31,679
this is also helpful for us to do heavy

702
00:29:31,679 --> 00:29:34,240
functioning

703
00:29:35,440 --> 00:29:38,159
after solving the first challenge

704
00:29:38,159 --> 00:29:41,360
we start to solve the second one

705
00:29:41,360 --> 00:29:43,760
before looking for a new solution we

706
00:29:43,760 --> 00:29:46,480
decided to we decided

707
00:29:46,480 --> 00:29:49,279
uh take a new look at historical exploit

708
00:29:49,279 --> 00:29:51,679
examples that

709
00:29:51,679 --> 00:29:55,120
have stable auction reading and writing

710
00:29:55,120 --> 00:29:56,320
and

711
00:29:56,320 --> 00:29:59,520
looking for some inspiration

712
00:29:59,520 --> 00:30:01,600
from these two methods we found

713
00:30:01,600 --> 00:30:03,440
something interesting

714
00:30:03,440 --> 00:30:05,600
that is controlling the pointer to get

715
00:30:05,600 --> 00:30:06,960
after read

716
00:30:06,960 --> 00:30:08,559
and write

717
00:30:08,559 --> 00:30:10,080
let's keep going

718
00:30:10,080 --> 00:30:12,640
the common elements of this two message

719
00:30:12,640 --> 00:30:15,200
is memory issue

720
00:30:15,200 --> 00:30:17,360
but that's why in one testing

721
00:30:17,360 --> 00:30:21,520
it has two elements we just mentioned

722
00:30:21,520 --> 00:30:24,480
through the analysis of these cases we

723
00:30:24,480 --> 00:30:27,279
found two interesting basic elements

724
00:30:27,279 --> 00:30:29,279
the first one is memory share which

725
00:30:29,279 --> 00:30:32,320
means to use the shared data to achieve

726
00:30:32,320 --> 00:30:36,559
arbitrary read and write for example if

727
00:30:36,559 --> 00:30:39,679
structure a and structure b overlapped

728
00:30:39,679 --> 00:30:41,520
and we can use

729
00:30:41,520 --> 00:30:44,559
pointer instruct b to read or write then

730
00:30:44,559 --> 00:30:46,480
we can control pdr

731
00:30:46,480 --> 00:30:49,840
the pointer through structure

732
00:30:49,840 --> 00:30:54,399
to get after read or write

733
00:30:54,399 --> 00:30:56,720
different from the first element

734
00:30:56,720 --> 00:30:59,679
the second element does not focus on

735
00:30:59,679 --> 00:31:02,080
how to control the pointer

736
00:31:02,080 --> 00:31:04,320
but to combine the code logic to achieve

737
00:31:04,320 --> 00:31:08,240
stable object rate in write

738
00:31:08,240 --> 00:31:10,240
this dominates two elements

739
00:31:10,240 --> 00:31:12,640
we found several structures

740
00:31:12,640 --> 00:31:15,039
after they cooperated with each other it

741
00:31:15,039 --> 00:31:16,480
would like the filtering of chemical

742
00:31:16,480 --> 00:31:19,279
reaction bursting out here's power

743
00:31:19,279 --> 00:31:21,440
immediately

744
00:31:21,440 --> 00:31:22,559
first

745
00:31:22,559 --> 00:31:25,039
let's have a let us have a look at a

746
00:31:25,039 --> 00:31:28,158
h-map interface

747
00:31:28,480 --> 00:31:30,799
this structure is saved as a pointer to

748
00:31:30,799 --> 00:31:32,720
file private data

749
00:31:32,720 --> 00:31:35,360
again their functioning of the astronaut

750
00:31:35,360 --> 00:31:37,279
interface can raise a section of memory

751
00:31:37,279 --> 00:31:39,279
from a kernel

752
00:31:39,279 --> 00:31:41,200
if a private port

753
00:31:41,200 --> 00:31:43,360
if the private data pointer can be

754
00:31:43,360 --> 00:31:44,880
tampered with

755
00:31:44,880 --> 00:31:47,200
it can read content from any kernel

756
00:31:47,200 --> 00:31:48,799
address

757
00:31:48,799 --> 00:31:50,080
similarly

758
00:31:50,080 --> 00:31:51,840
you can use the set product mask

759
00:31:51,840 --> 00:31:53,919
function to modify the content

760
00:31:53,919 --> 00:31:56,720
of specified address

761
00:31:56,720 --> 00:32:01,120
but due to the limitation of code itself

762
00:32:01,120 --> 00:32:03,760
the most practical usage is to write

763
00:32:03,760 --> 00:32:06,158
zero

764
00:32:07,840 --> 00:32:08,720
and

765
00:32:08,720 --> 00:32:11,519
with the help of set name function

766
00:32:11,519 --> 00:32:14,080
after write after writing can also

767
00:32:14,080 --> 00:32:16,799
achieve to some extent

768
00:32:16,799 --> 00:32:19,760
now let's take a look at simplify

769
00:32:19,760 --> 00:32:21,440
the first element of six fire and

770
00:32:21,440 --> 00:32:24,000
structure is the box pointer

771
00:32:24,000 --> 00:32:26,000
the data can be rated from box pointer

772
00:32:26,000 --> 00:32:28,000
to the user mode by calling the second

773
00:32:28,000 --> 00:32:30,880
rate of operation

774
00:32:30,880 --> 00:32:33,279
once the buff pointer is temporary it

775
00:32:33,279 --> 00:32:35,600
means we can reading data from any

776
00:32:35,600 --> 00:32:37,840
address

777
00:32:37,840 --> 00:32:40,000
writing the more interesting because the

778
00:32:40,000 --> 00:32:41,840
confirm is only circle bar with

779
00:32:41,840 --> 00:32:43,600
controllable content

780
00:32:43,600 --> 00:32:46,880
and is not subject to permission control

781
00:32:46,880 --> 00:32:48,960
the way to modify its content is to

782
00:32:48,960 --> 00:32:51,039
modify the threading

783
00:32:51,039 --> 00:32:52,720
corresponding operations in the kernel

784
00:32:52,720 --> 00:32:54,840
is divided into two

785
00:32:54,840 --> 00:32:58,000
steps the first is to save thread name

786
00:32:58,000 --> 00:33:00,399
to the task com

787
00:33:00,399 --> 00:33:02,799
when a user tries to read content from

788
00:33:02,799 --> 00:33:05,279
com the kernel will call the construct

789
00:33:05,279 --> 00:33:08,720
function to write content of

790
00:33:08,720 --> 00:33:12,399
column into the memory 25 second firebox

791
00:33:12,399 --> 00:33:15,600
throw circuit print

792
00:33:15,679 --> 00:33:17,919
if the buff pointer can be temporary at

793
00:33:17,919 --> 00:33:19,360
this time

794
00:33:19,360 --> 00:33:23,679
the actual address right is achieved

795
00:33:23,679 --> 00:33:26,480
if item cannot achieve up to rate or

796
00:33:26,480 --> 00:33:29,200
write but it can be used to repeatedly

797
00:33:29,200 --> 00:33:31,600
write up three eight byte data to the

798
00:33:31,600 --> 00:33:33,360
kernel fixed memory

799
00:33:33,360 --> 00:33:34,559
which is

800
00:33:34,559 --> 00:33:37,799
very useful

801
00:33:38,399 --> 00:33:40,559
i have already introduced three

802
00:33:40,559 --> 00:33:42,799
structures and the related functions

803
00:33:42,799 --> 00:33:44,880
that can be used to achieve

804
00:33:44,880 --> 00:33:47,840
actually read and write so how to

805
00:33:47,840 --> 00:33:50,559
achieve this target at first

806
00:33:50,559 --> 00:33:54,080
what we think of is to use ashman

807
00:33:54,080 --> 00:33:56,640
and the powerpoint shows we first need

808
00:33:56,640 --> 00:33:59,120
to modify predator 1

809
00:33:59,120 --> 00:34:01,600
and which makes us be able to modify the

810
00:34:01,600 --> 00:34:03,279
private data too

811
00:34:03,279 --> 00:34:04,960
then we can use

812
00:34:04,960 --> 00:34:08,320
fire to to raise or write tattoo memory

813
00:34:08,320 --> 00:34:09,599
however

814
00:34:09,599 --> 00:34:11,839
the conditions that need to be met are

815
00:34:11,839 --> 00:34:14,239
two nicks and one right

816
00:34:14,239 --> 00:34:16,560
it's difficult to meet right

817
00:34:16,560 --> 00:34:17,359
so

818
00:34:17,359 --> 00:34:20,879
is there a better solution

819
00:34:20,879 --> 00:34:22,960
combining the characteristics of this

820
00:34:22,960 --> 00:34:25,839
solution of this vulnerability

821
00:34:25,839 --> 00:34:28,159
we finally found in a most perfect

822
00:34:28,159 --> 00:34:29,359
solution

823
00:34:29,359 --> 00:34:30,800
first of all

824
00:34:30,800 --> 00:34:33,239
size of these two structures is exactly

825
00:34:33,239 --> 00:34:35,119
128

826
00:34:35,119 --> 00:34:35,918
so

827
00:34:35,918 --> 00:34:38,800
it can be allocated on the same page

828
00:34:38,800 --> 00:34:41,520
because there is an eighth part of that

829
00:34:41,520 --> 00:34:43,839
when a vulnerability is triggered

830
00:34:43,839 --> 00:34:46,239
if you can make this two structures a

831
00:34:46,239 --> 00:34:47,359
digestion

832
00:34:47,359 --> 00:34:49,520
when you allocate them

833
00:34:49,520 --> 00:34:52,159
you can make data field of import item

834
00:34:52,159 --> 00:34:56,000
overlap with above field of circuit fire

835
00:34:56,000 --> 00:34:58,160
once setup is completed

836
00:34:58,160 --> 00:35:01,520
stable arbitrary read and write can

837
00:35:01,520 --> 00:35:04,240
can be completed without any leak or

838
00:35:04,240 --> 00:35:07,040
right condition

839
00:35:07,760 --> 00:35:10,800
it's either of the plan is determined

840
00:35:10,800 --> 00:35:13,119
only a few steps are needed first step

841
00:35:13,119 --> 00:35:15,599
is to prepare some holes before

842
00:35:15,599 --> 00:35:18,400
circumference will behave functionally

843
00:35:18,400 --> 00:35:20,480
the same step is to fill this holes with

844
00:35:20,480 --> 00:35:22,720
bender load but

845
00:35:22,720 --> 00:35:24,640
here is a little trouble

846
00:35:24,640 --> 00:35:26,960
aopa structure is allocated before

847
00:35:26,960 --> 00:35:30,000
sacrifice and it cannot be deallocated

848
00:35:30,000 --> 00:35:32,000
separately

849
00:35:32,000 --> 00:35:33,440
the solution is to control the

850
00:35:33,440 --> 00:35:36,320
allocation order

851
00:35:36,320 --> 00:35:38,720
through continuous testing we found that

852
00:35:38,720 --> 00:35:40,960
eventually can help us

853
00:35:40,960 --> 00:35:44,480
accomplish this task will

854
00:35:44,480 --> 00:35:46,960
it has several characteristics

855
00:35:46,960 --> 00:35:49,040
first it can be accessed by in the

856
00:35:49,040 --> 00:35:50,640
sandbox

857
00:35:50,640 --> 00:35:53,680
and closing event d will immediately be

858
00:35:53,680 --> 00:35:56,960
allocated to this lab

859
00:35:57,680 --> 00:35:59,520
control a controlling closing sequence

860
00:35:59,520 --> 00:36:02,800
of umd so that slab allocation can be

861
00:36:02,800 --> 00:36:05,680
carried out in a specific order

862
00:36:05,680 --> 00:36:08,640
as shown in powerpoint

863
00:36:08,640 --> 00:36:11,760
we firstly close the event of d3 and the

864
00:36:11,760 --> 00:36:14,960
enclosed event event of d1

865
00:36:14,960 --> 00:36:16,720
and then the order of the hit blocks in

866
00:36:16,720 --> 00:36:19,520
the freighters will be invented fd1

867
00:36:19,520 --> 00:36:21,359
then event of d3

868
00:36:21,359 --> 00:36:23,280
in fact this corresponds to the

869
00:36:23,280 --> 00:36:26,839
allocation order

870
00:36:29,920 --> 00:36:33,200
now after the preparations

871
00:36:33,200 --> 00:36:35,760
we go to create the exec bar and the

872
00:36:35,760 --> 00:36:38,000
structure corresponding to the op field

873
00:36:38,000 --> 00:36:40,560
can separate from the second file

874
00:36:40,560 --> 00:36:41,839
at this point

875
00:36:41,839 --> 00:36:44,960
just close event of d2 again to leave

876
00:36:44,960 --> 00:36:46,240
the hole

877
00:36:46,240 --> 00:36:48,000
before circuit bar

878
00:36:48,000 --> 00:36:50,400
now we can fill the holes with bender

879
00:36:50,400 --> 00:36:51,359
loads

880
00:36:51,359 --> 00:36:55,040
next step is trigger k3 say plus 8 and

881
00:36:55,040 --> 00:36:57,359
allocate the save class 8 back for the

882
00:36:57,359 --> 00:37:00,078
import item

883
00:37:00,560 --> 00:37:02,720
now we have the ability to rate and

884
00:37:02,720 --> 00:37:05,040
write at any address

885
00:37:05,040 --> 00:37:07,040
but we still need to

886
00:37:07,040 --> 00:37:08,560
make the kernel address before we can

887
00:37:08,560 --> 00:37:09,680
continue

888
00:37:09,680 --> 00:37:10,800
however

889
00:37:10,800 --> 00:37:12,800
it is very interesting that we only need

890
00:37:12,800 --> 00:37:14,720
to replace the input item with vendor

891
00:37:14,720 --> 00:37:16,240
load

892
00:37:16,240 --> 00:37:18,560
it's not difficult to find that

893
00:37:18,560 --> 00:37:20,560
the last failed

894
00:37:20,560 --> 00:37:23,040
event load is doubly linked list

895
00:37:23,040 --> 00:37:25,119
which points itself

896
00:37:25,119 --> 00:37:26,960
when initialized

897
00:37:26,960 --> 00:37:27,680
so

898
00:37:27,680 --> 00:37:29,839
when we overwrite the buff pointer with

899
00:37:29,839 --> 00:37:32,480
the pre-pointer content after the banner

900
00:37:32,480 --> 00:37:35,440
load can be leaked

901
00:37:35,440 --> 00:37:36,480
you already

902
00:37:36,480 --> 00:37:38,800
the last step is to close the sdnix and

903
00:37:38,800 --> 00:37:42,000
set the uiid to zero but it's not enough

904
00:37:42,000 --> 00:37:43,599
yet

905
00:37:43,599 --> 00:37:45,280
when writing exploit

906
00:37:45,280 --> 00:37:47,520
we failed to reverse a shell after

907
00:37:47,520 --> 00:37:50,560
closing scenarios and there is no way to

908
00:37:50,560 --> 00:37:52,880
bypass bpf directly

909
00:37:52,880 --> 00:37:56,640
so when we disable ppf

910
00:37:57,520 --> 00:38:00,320
so we have to disable the ppf

911
00:38:00,320 --> 00:38:02,960
setting filter to long won't work

912
00:38:02,960 --> 00:38:05,200
we have to set in the filter

913
00:38:05,200 --> 00:38:07,280
uh to the financing

914
00:38:07,280 --> 00:38:11,119
element to turn off the ppf

915
00:38:12,480 --> 00:38:13,839
finally

916
00:38:13,839 --> 00:38:15,680
i would like to point out some

917
00:38:15,680 --> 00:38:17,440
shortcomings of this

918
00:38:17,440 --> 00:38:18,400
schema

919
00:38:18,400 --> 00:38:19,760
difficult for

920
00:38:19,760 --> 00:38:22,240
the size of sucfar band and load ipo

921
00:38:22,240 --> 00:38:23,760
item structures

922
00:38:23,760 --> 00:38:26,880
are exactly 128

923
00:38:26,880 --> 00:38:28,720
but these structures may differ in

924
00:38:28,720 --> 00:38:31,280
different system versions

925
00:38:31,280 --> 00:38:34,400
the size and of the structure change the

926
00:38:34,400 --> 00:38:36,960
current plane may fail

927
00:38:36,960 --> 00:38:38,720
the second point is that we still need

928
00:38:38,720 --> 00:38:40,400
to adapt this

929
00:38:40,400 --> 00:38:42,240
as linux enforcing

930
00:38:42,240 --> 00:38:43,040
so

931
00:38:43,040 --> 00:38:45,200
could it be done automatically with the

932
00:38:45,200 --> 00:38:46,640
ability of

933
00:38:46,640 --> 00:38:49,119
after read and write

934
00:38:49,119 --> 00:38:52,880
i'd like to do this question for you

935
00:38:52,880 --> 00:38:55,440
finally let me show you a demonstration

936
00:38:55,440 --> 00:38:59,160
we have recorded

937
00:39:02,400 --> 00:39:03,760
at first

938
00:39:03,760 --> 00:39:05,440
we will check the

939
00:39:05,440 --> 00:39:07,040
chrome and the

940
00:39:07,040 --> 00:39:10,000
android version

941
00:39:12,079 --> 00:39:14,320
after check is done we will use the

942
00:39:14,320 --> 00:39:16,960
chrome browser to access

943
00:39:16,960 --> 00:39:18,240
an attacker

944
00:39:18,240 --> 00:39:19,520
and attack

945
00:39:19,520 --> 00:39:21,839
page

946
00:39:22,880 --> 00:39:27,040
as you can see we reversed a shell

947
00:39:27,040 --> 00:39:29,119
and this is a root show

948
00:39:29,119 --> 00:39:31,920
now we use this shirt to install an app

949
00:39:31,920 --> 00:39:35,640
and start it

950
00:39:46,560 --> 00:39:48,640
first we need to download from internet

951
00:39:48,640 --> 00:39:50,240
and

952
00:39:50,240 --> 00:39:54,160
call a pm installed to install the app

953
00:39:54,160 --> 00:39:56,800
and use the am command to start the

954
00:39:56,800 --> 00:39:59,800
activity

955
00:40:10,160 --> 00:40:12,079
let's take us a few

956
00:40:12,079 --> 00:40:15,079
seconds

957
00:40:25,599 --> 00:40:28,160
as you can see app is installed and

958
00:40:28,160 --> 00:40:30,160
started

959
00:40:30,160 --> 00:40:34,759
okay thank you any questions

