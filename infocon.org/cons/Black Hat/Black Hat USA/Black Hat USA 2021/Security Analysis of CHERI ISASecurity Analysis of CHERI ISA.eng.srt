1
00:00:01,130 --> 00:00:14,690
[Music]

2
00:00:15,040 --> 00:00:17,119
hello all this is nicholas jolly i will

3
00:00:17,119 --> 00:00:19,119
be co-presenting this talk with sarah

4
00:00:19,119 --> 00:00:21,279
moore we both work at the microsoft

5
00:00:21,279 --> 00:00:24,800
security response center vmsrc i'm based

6
00:00:24,800 --> 00:00:28,840
in the uk in cheltenham and tsar is in

7
00:00:28,840 --> 00:00:31,760
israel we are very happy to be talking

8
00:00:31,760 --> 00:00:34,239
about cherry today

9
00:00:34,239 --> 00:00:37,680
so why are we here and why cherry well

10
00:00:37,680 --> 00:00:39,840
the short answer to this question is

11
00:00:39,840 --> 00:00:41,760
that we are haunted by memory safety

12
00:00:41,760 --> 00:00:44,320
issues as you can see on this graph

13
00:00:44,320 --> 00:00:46,320
which represents the number of msrt

14
00:00:46,320 --> 00:00:49,039
cases for memory safety issues that we

15
00:00:49,039 --> 00:00:52,399
had over the past five years the trend

16
00:00:52,399 --> 00:00:54,640
isn't really going down memory safety

17
00:00:54,640 --> 00:00:56,480
issues is something that we are going to

18
00:00:56,480 --> 00:00:57,600
see

19
00:00:57,600 --> 00:00:59,840
in the years to come

20
00:00:59,840 --> 00:01:01,840
why is that because enforcing memory

21
00:01:01,840 --> 00:01:04,879
safety this is a non-trivial problem

22
00:01:04,879 --> 00:01:07,280
there are solutions to this such as safe

23
00:01:07,280 --> 00:01:10,479
languages like rust or net but the

24
00:01:10,479 --> 00:01:12,400
problem with this is that this hardly

25
00:01:12,400 --> 00:01:14,400
scales it's

26
00:01:14,400 --> 00:01:17,600
very difficult and obviously very costly

27
00:01:17,600 --> 00:01:20,159
to rewrite everything in the safe

28
00:01:20,159 --> 00:01:22,799
language so what else can we do well we

29
00:01:22,799 --> 00:01:25,360
can push for more mitigations but the

30
00:01:25,360 --> 00:01:27,439
problem with mitigations is that at the

31
00:01:27,439 --> 00:01:29,680
end of the day they only make

32
00:01:29,680 --> 00:01:31,840
the attacker's life a bit harder those

33
00:01:31,840 --> 00:01:33,920
mitigations they are rarely a silver

34
00:01:33,920 --> 00:01:37,040
bullet and each year there are events or

35
00:01:37,040 --> 00:01:39,600
competitions like for example pontoon

36
00:01:39,600 --> 00:01:42,000
that remind us that we are losing the

37
00:01:42,000 --> 00:01:45,200
battle we make the attacker's life a bit

38
00:01:45,200 --> 00:01:47,200
harder but

39
00:01:47,200 --> 00:01:48,640
in the end it's still possible to

40
00:01:48,640 --> 00:01:51,280
exploit memory safety issues so what

41
00:01:51,280 --> 00:01:53,600
else can we consider well there are

42
00:01:53,600 --> 00:01:55,280
hardware solutions

43
00:01:55,280 --> 00:01:57,439
something like cherry for example and

44
00:01:57,439 --> 00:01:59,600
that's why we're here today

45
00:01:59,600 --> 00:02:01,360
so in the following slides i will be

46
00:02:01,360 --> 00:02:02,960
assuming that you've never heard about

47
00:02:02,960 --> 00:02:05,600
cherry so we'll be giving a very short

48
00:02:05,600 --> 00:02:06,880
introduction

49
00:02:06,880 --> 00:02:08,399
and then we'll be talking about some

50
00:02:08,399 --> 00:02:10,639
vulnerabilities and attacks that we've

51
00:02:10,639 --> 00:02:12,800
tried against cherry

52
00:02:12,800 --> 00:02:14,959
and finally we'll be talking about some

53
00:02:14,959 --> 00:02:17,200
work in progress and we'll be giving a

54
00:02:17,200 --> 00:02:18,400
few words

55
00:02:18,400 --> 00:02:21,599
in conclusion regarding our research

56
00:02:21,599 --> 00:02:22,640
all right

57
00:02:22,640 --> 00:02:24,640
let's go

58
00:02:24,640 --> 00:02:26,959
so what is cherry a cherry has been

59
00:02:26,959 --> 00:02:29,280
developed by folks from the cambridge

60
00:02:29,280 --> 00:02:32,720
university and sri international with

61
00:02:32,720 --> 00:02:35,040
special safety in mind from the very

62
00:02:35,040 --> 00:02:38,480
beginning it extends a traditional isas

63
00:02:38,480 --> 00:02:42,000
such as arm mips or wrist five

64
00:02:42,000 --> 00:02:44,879
with new instructions to provide special

65
00:02:44,879 --> 00:02:45,920
safety

66
00:02:45,920 --> 00:02:48,480
so in this research in our research

67
00:02:48,480 --> 00:02:50,560
i should mention that we've only looking

68
00:02:50,560 --> 00:02:54,080
we've only looked at the mips and arm

69
00:02:54,080 --> 00:02:56,480
implementations the army implementation

70
00:02:56,480 --> 00:02:59,200
will be referred as morale in the next

71
00:02:59,200 --> 00:03:00,800
slides

72
00:03:00,800 --> 00:03:03,840
so this new model introduces a new data

73
00:03:03,840 --> 00:03:06,560
type called capability so this is a very

74
00:03:06,560 --> 00:03:08,879
central point uh and we're going to talk

75
00:03:08,879 --> 00:03:10,959
about capability uh

76
00:03:10,959 --> 00:03:14,000
for in in the center presentation so pay

77
00:03:14,000 --> 00:03:15,599
attention to this

78
00:03:15,599 --> 00:03:18,000
so capability you can see this as an

79
00:03:18,000 --> 00:03:20,319
extended pointer a pointer with extra

80
00:03:20,319 --> 00:03:21,519
information

81
00:03:21,519 --> 00:03:23,120
and such capability

82
00:03:23,120 --> 00:03:25,680
takes exactly 16 bytes

83
00:03:25,680 --> 00:03:30,560
in memory plus one bit for a tag so in

84
00:03:30,560 --> 00:03:34,959
total this is 129 bits so the tag is

85
00:03:34,959 --> 00:03:38,319
very important this is the bit that

86
00:03:38,319 --> 00:03:41,120
protects the capability the capability

87
00:03:41,120 --> 00:03:44,480
cannot be forged it is unforgeable so if

88
00:03:44,480 --> 00:03:47,920
you try to dereference a capability that

89
00:03:47,920 --> 00:03:49,920
doesn't take set

90
00:03:49,920 --> 00:03:51,840
you will trigger a fault

91
00:03:51,840 --> 00:03:55,040
if you try to overwrite a capability

92
00:03:55,040 --> 00:03:57,680
you will instantly clear the tag

93
00:03:57,680 --> 00:04:00,560
so this tag is super important

94
00:04:00,560 --> 00:04:02,480
so obviously cherry is a bit more than

95
00:04:02,480 --> 00:04:05,200
that and if you're curious or if you

96
00:04:05,200 --> 00:04:07,360
want to know more i encourage you to

97
00:04:07,360 --> 00:04:09,360
have a look at the cherry documentation

98
00:04:09,360 --> 00:04:12,159
provided by the commerce university it's

99
00:04:12,159 --> 00:04:14,400
super interesting

100
00:04:14,400 --> 00:04:16,320
so coming back to those capabilities

101
00:04:16,320 --> 00:04:19,040
what can we find in them well we can

102
00:04:19,040 --> 00:04:20,959
find of course the virtual address so

103
00:04:20,959 --> 00:04:23,520
this is the pointer that we commonly see

104
00:04:23,520 --> 00:04:26,000
every day when we're dealing with c

105
00:04:26,000 --> 00:04:28,240
we can find a few other fields such as

106
00:04:28,240 --> 00:04:29,840
the permissions so this is the

107
00:04:29,840 --> 00:04:31,759
permissions to

108
00:04:31,759 --> 00:04:34,639
to the object pointed by the address is

109
00:04:34,639 --> 00:04:36,960
it readable is it writeable is it

110
00:04:36,960 --> 00:04:39,680
executable i remember there is another

111
00:04:39,680 --> 00:04:44,160
field called type so this represents

112
00:04:44,160 --> 00:04:47,280
whether the capability is sealed or not

113
00:04:47,280 --> 00:04:48,960
sealed means that the capability some

114
00:04:48,960 --> 00:04:52,199
capabilities can be made immutable or

115
00:04:52,199 --> 00:04:54,960
non-dereferenceable for example so you

116
00:04:54,960 --> 00:04:57,840
can find this by reading the o type

117
00:04:57,840 --> 00:04:58,800
field

118
00:04:58,800 --> 00:05:00,800
and the last field that you can find in

119
00:05:00,800 --> 00:05:03,199
your capability is a length

120
00:05:03,199 --> 00:05:06,160
so this length is represented using

121
00:05:06,160 --> 00:05:08,560
compressed bounds

122
00:05:08,560 --> 00:05:11,759
and because of the compression for large

123
00:05:11,759 --> 00:05:15,440
allocations uh just slightly more memory

124
00:05:15,440 --> 00:05:18,479
can be sometimes allocated and this in

125
00:05:18,479 --> 00:05:21,039
this very specific case it's still

126
00:05:21,039 --> 00:05:24,240
possible to get some out of bounds

127
00:05:24,240 --> 00:05:27,280
access but those accesses will never

128
00:05:27,280 --> 00:05:29,840
lead to some memory safety issues that's

129
00:05:29,840 --> 00:05:32,160
because just a bit more memory has been

130
00:05:32,160 --> 00:05:35,360
allocated for capability this is just a

131
00:05:35,360 --> 00:05:37,680
note but it's important to

132
00:05:37,680 --> 00:05:40,000
to have that in mind the next slide is

133
00:05:40,000 --> 00:05:42,080
going to show you what's a capability uh

134
00:05:42,080 --> 00:05:44,240
you when you're debugging a program so

135
00:05:44,240 --> 00:05:46,800
on the left side you can see uh

136
00:05:46,800 --> 00:05:49,280
traditional registers and on the right

137
00:05:49,280 --> 00:05:51,360
side you can see a bunch of capabilities

138
00:05:51,360 --> 00:05:53,680
so for example this one is c3 which

139
00:05:53,680 --> 00:05:56,319
points to some memory that is read and

140
00:05:56,319 --> 00:05:58,880
writeable

141
00:05:58,880 --> 00:06:01,680
so where are we using capabilities well

142
00:06:01,680 --> 00:06:03,759
the answer to that is pretty much

143
00:06:03,759 --> 00:06:05,600
everywhere

144
00:06:05,600 --> 00:06:08,880
when you're programming and when you are

145
00:06:08,880 --> 00:06:11,039
allocating some objects for example

146
00:06:11,039 --> 00:06:13,360
whether those are in the stack or in the

147
00:06:13,360 --> 00:06:16,160
hip you'll be dealing with a capability

148
00:06:16,160 --> 00:06:17,919
if you're defining some function

149
00:06:17,919 --> 00:06:20,400
pointers your will be you will be

150
00:06:20,400 --> 00:06:23,120
dealing with a capability again

151
00:06:23,120 --> 00:06:25,520
and what about and also good stuff

152
00:06:25,520 --> 00:06:28,400
well you will be dealing also with a

153
00:06:28,400 --> 00:06:30,960
capability so say that you're you're

154
00:06:30,960 --> 00:06:32,639
doing uh stuff

155
00:06:32,639 --> 00:06:34,319
in the stack for example then you will

156
00:06:34,319 --> 00:06:36,560
be dealing with a capability say that

157
00:06:36,560 --> 00:06:37,520
you are

158
00:06:37,520 --> 00:06:39,520
doing some c prospers programming and

159
00:06:39,520 --> 00:06:41,680
you are dealing with some zippers press

160
00:06:41,680 --> 00:06:43,759
objects that have some v table

161
00:06:43,759 --> 00:06:45,440
here again you'll be dealing with some

162
00:06:45,440 --> 00:06:46,880
capabilities

163
00:06:46,880 --> 00:06:49,120
so when you're programming

164
00:06:49,120 --> 00:06:51,120
the compiler will under most of the

165
00:06:51,120 --> 00:06:53,280
capabilities that the program will be

166
00:06:53,280 --> 00:06:54,479
using

167
00:06:54,479 --> 00:06:56,960
and for under the hood staff this will

168
00:06:56,960 --> 00:06:59,680
be the responsibility of the loader to

169
00:06:59,680 --> 00:07:02,800
create those capabilities so obviously

170
00:07:02,800 --> 00:07:04,080
this model

171
00:07:04,080 --> 00:07:07,360
suggests that the programmer is aware of

172
00:07:07,360 --> 00:07:09,599
specific changes

173
00:07:09,599 --> 00:07:12,319
changes like for example casts

174
00:07:12,319 --> 00:07:14,800
casting a pointer to an integer is

175
00:07:14,800 --> 00:07:17,360
something allowed in cherry however the

176
00:07:17,360 --> 00:07:19,840
contrary is a bit more difficult you

177
00:07:19,840 --> 00:07:22,479
cannot for example cast from hint to

178
00:07:22,479 --> 00:07:24,560
pointer this is not possible what you

179
00:07:24,560 --> 00:07:27,759
can do is you can cast from in pointer t

180
00:07:27,759 --> 00:07:29,680
to pointer that's a load

181
00:07:29,680 --> 00:07:32,240
and something also that uh we need to

182
00:07:32,240 --> 00:07:34,560
have in mind is that mem copy or memo

183
00:07:34,560 --> 00:07:36,960
operations are tag preserving which

184
00:07:36,960 --> 00:07:38,639
means that if you try to copy a bunch of

185
00:07:38,639 --> 00:07:41,039
capabilities from one place to another

186
00:07:41,039 --> 00:07:44,960
then the tag bit will be preserved

187
00:07:44,960 --> 00:07:47,039
it's very important to have this concept

188
00:07:47,039 --> 00:07:50,639
when you think about exploitation

189
00:07:50,639 --> 00:07:53,039
so this is a short slide to show you

190
00:07:53,039 --> 00:07:55,280
what's a capability in

191
00:07:55,280 --> 00:07:57,120
in the compiler after

192
00:07:57,120 --> 00:07:59,280
the program has been compiled so those

193
00:07:59,280 --> 00:08:02,000
three lines of of c code

194
00:08:02,000 --> 00:08:05,039
shows a buffer overflow so here we have

195
00:08:05,039 --> 00:08:07,360
a stack buffer of exactly 10 bytes that

196
00:08:07,360 --> 00:08:08,639
has been defined

197
00:08:08,639 --> 00:08:10,400
and you can see that a special

198
00:08:10,400 --> 00:08:12,400
instruction here is setting the length

199
00:08:12,400 --> 00:08:15,199
of the capability to 16 bytes and if you

200
00:08:15,199 --> 00:08:17,199
try to

201
00:08:17,199 --> 00:08:18,800
write out of the bounds of these

202
00:08:18,800 --> 00:08:21,120
capabilities then you'll get a thought a

203
00:08:21,120 --> 00:08:23,520
secret if you were trying to read out of

204
00:08:23,520 --> 00:08:27,360
bounds of this capability you get again

205
00:08:27,360 --> 00:08:29,120
a secret

206
00:08:29,120 --> 00:08:31,440
so this is almost the same example but

207
00:08:31,440 --> 00:08:33,760
this time with the hip so here we

208
00:08:33,760 --> 00:08:35,360
haven't shown

209
00:08:35,360 --> 00:08:37,679
the location where the length of the

210
00:08:37,679 --> 00:08:40,080
capability is set but this is basically

211
00:08:40,080 --> 00:08:42,320
the responsibility of the allocator here

212
00:08:42,320 --> 00:08:45,360
in this example of malloc malloc will

213
00:08:45,360 --> 00:08:47,200
set the length of the capability and

214
00:08:47,200 --> 00:08:49,360
then the program will use it and here

215
00:08:49,360 --> 00:08:51,360
since we are trying to write out amount

216
00:08:51,360 --> 00:08:54,320
of capabilities will be triggering a

217
00:08:54,320 --> 00:08:56,800
secret

218
00:08:56,880 --> 00:08:59,200
so if you've followed so far and if you

219
00:08:59,200 --> 00:09:01,839
like to write exploit now is a good time

220
00:09:01,839 --> 00:09:05,120
to be to start worry about sharing

221
00:09:05,120 --> 00:09:07,760
why well cherry has two main impacts the

222
00:09:07,760 --> 00:09:10,480
first impact obviously is for special

223
00:09:10,480 --> 00:09:11,680
safety

224
00:09:11,680 --> 00:09:13,760
out-of-bound vulnerabilities those are

225
00:09:13,760 --> 00:09:16,279
no longer a security concern they are

226
00:09:16,279 --> 00:09:18,800
deterministically mitigated which means

227
00:09:18,800 --> 00:09:21,120
no buffer overflows no stack overflows

228
00:09:21,120 --> 00:09:22,720
no things like that

229
00:09:22,720 --> 00:09:25,200
and the other consequence is that one

230
00:09:25,200 --> 00:09:27,760
cannot manufacture a pointer so think

231
00:09:27,760 --> 00:09:30,640
about attacks like rope where

232
00:09:30,640 --> 00:09:32,880
the attacker is trying to craft some

233
00:09:32,880 --> 00:09:36,000
arbitrary pointers those are no longer

234
00:09:36,000 --> 00:09:37,279
possible

235
00:09:37,279 --> 00:09:39,760
so in in summary cherry is a game

236
00:09:39,760 --> 00:09:42,000
changer for the attacker

237
00:09:42,000 --> 00:09:44,480
trying to exploit a memory safety issues

238
00:09:44,480 --> 00:09:46,880
is something that is much much much

239
00:09:46,880 --> 00:09:50,399
harder for the attacker to do let's see

240
00:09:50,399 --> 00:09:52,959
a quick example some quick example so if

241
00:09:52,959 --> 00:09:54,800
you have a primitive where you can

242
00:09:54,800 --> 00:09:57,200
corrupt a few bits or perhaps the

243
00:09:57,200 --> 00:09:59,519
entirety of a monitor then cherry is

244
00:09:59,519 --> 00:10:02,000
going to raise a tag bit violation

245
00:10:02,000 --> 00:10:04,399
so this violation won't happen on the

246
00:10:04,399 --> 00:10:06,720
moment that you grab the pointer it will

247
00:10:06,720 --> 00:10:08,399
happen on the moment you're already

248
00:10:08,399 --> 00:10:10,079
referencing it

249
00:10:10,079 --> 00:10:12,959
if you try to uh write out of bounds

250
00:10:12,959 --> 00:10:15,279
read or write out of bounds of a

251
00:10:15,279 --> 00:10:17,279
of a buffer you will get this time a

252
00:10:17,279 --> 00:10:20,000
length violation the only corner case

253
00:10:20,000 --> 00:10:22,320
where it would still be possible to get

254
00:10:22,320 --> 00:10:24,320
some buffer overflow is when you're

255
00:10:24,320 --> 00:10:28,560
trying uh to uh overflow from some intra

256
00:10:28,560 --> 00:10:30,959
objects so typically some c struct where

257
00:10:30,959 --> 00:10:33,519
you'd be using a buffer followed by an

258
00:10:33,519 --> 00:10:35,279
integer or a pointer or something like

259
00:10:35,279 --> 00:10:36,880
that in that case

260
00:10:36,880 --> 00:10:39,200
it would require a special compiler flag

261
00:10:39,200 --> 00:10:42,800
to get rid of the issues

262
00:10:43,360 --> 00:10:45,519
so what else well there is isn't only

263
00:10:45,519 --> 00:10:49,120
special safety um the problem uh is that

264
00:10:49,120 --> 00:10:52,240
there are other issues such as such as a

265
00:10:52,240 --> 00:10:54,240
temporal safety issues like double

266
00:10:54,240 --> 00:10:57,200
freeze uh use after freeze etc those are

267
00:10:57,200 --> 00:10:59,440
still theoretically exploitable with

268
00:10:59,440 --> 00:11:00,480
sharing

269
00:11:00,480 --> 00:11:02,320
there are other things also such as type

270
00:11:02,320 --> 00:11:05,839
confusions or uninitialized

271
00:11:05,839 --> 00:11:09,760
memory vulnerabilities and actually sar

272
00:11:09,760 --> 00:11:12,320
in the next slide is going to give you

273
00:11:12,320 --> 00:11:15,040
a very interesting example of this

274
00:11:15,040 --> 00:11:17,360
and so now i'm going to leave you with

275
00:11:17,360 --> 00:11:19,360
sar who will be talking about those

276
00:11:19,360 --> 00:11:22,560
vulnerabilities one last word uh

277
00:11:22,560 --> 00:11:25,360
cherry is very good at mitigating

278
00:11:25,360 --> 00:11:28,959
exploits it makes x it makes writing

279
00:11:28,959 --> 00:11:30,800
exploits

280
00:11:30,800 --> 00:11:33,440
tasks much much much harder than what it

281
00:11:33,440 --> 00:11:34,720
was before

282
00:11:34,720 --> 00:11:37,279
all right sar it's up to you now

283
00:11:37,279 --> 00:11:38,800
thank you so much nico for this great

284
00:11:38,800 --> 00:11:40,640
introduction now

285
00:11:40,640 --> 00:11:42,240
so let's discuss some of the attacks

286
00:11:42,240 --> 00:11:43,519
that are still possible on cherries

287
00:11:43,519 --> 00:11:45,839
about the platforms so as sure i say it

288
00:11:45,839 --> 00:11:47,680
does not mitigate type confusions at the

289
00:11:47,680 --> 00:11:49,760
architectural level we can still create

290
00:11:49,760 --> 00:11:51,200
type confusion scenarios between

291
00:11:51,200 --> 00:11:53,120
different simple space objects and this

292
00:11:53,120 --> 00:11:54,480
of course is the very powerful

293
00:11:54,480 --> 00:11:56,560
expectation primitive of calling

294
00:11:56,560 --> 00:11:58,720
arbitrarily existing methods of

295
00:11:58,720 --> 00:12:01,120
different objects v tables and from this

296
00:12:01,120 --> 00:12:02,320
we can of course scroll up some

297
00:12:02,320 --> 00:12:04,000
important metadata to escalate

298
00:12:04,000 --> 00:12:05,360
privileges and to trigger some

299
00:12:05,360 --> 00:12:07,360
information disclosures all of that

300
00:12:07,360 --> 00:12:09,120
actually reminds me the famous park

301
00:12:09,120 --> 00:12:11,440
bypass that was found in objective c and

302
00:12:11,440 --> 00:12:13,440
relied on the fact that the isa pointer

303
00:12:13,440 --> 00:12:15,440
was not protected by pak

304
00:12:15,440 --> 00:12:17,519
this is from the amazing talks and

305
00:12:17,519 --> 00:12:20,320
sailor head at 36 c3 and as you can see

306
00:12:20,320 --> 00:12:22,240
and before the pack era we could just

307
00:12:22,240 --> 00:12:23,839
corrupt the ici printer and fake the

308
00:12:23,839 --> 00:12:26,079
entire class descriptor with all of the

309
00:12:26,079 --> 00:12:27,920
vtables function pointers and basically

310
00:12:27,920 --> 00:12:29,920
everything and this just gave us the

311
00:12:29,920 --> 00:12:31,839
primitive of gaining full control over

312
00:12:31,839 --> 00:12:33,680
the pc register and jump to an arbitrary

313
00:12:33,680 --> 00:12:36,880
address now given park this is no longer

314
00:12:36,880 --> 00:12:38,160
possible of course because all of the

315
00:12:38,160 --> 00:12:40,000
function pointers and all of the

316
00:12:40,000 --> 00:12:42,320
references to code are signed by pac

317
00:12:42,320 --> 00:12:44,560
that being said the ic printer itself

318
00:12:44,560 --> 00:12:46,560
was not sunway pack at the beginning it

319
00:12:46,560 --> 00:12:48,720
is today by the way and because it was

320
00:12:48,720 --> 00:12:50,639
attacked pointer and therefore we could

321
00:12:50,639 --> 00:12:52,560
still corrupt the isa pointer and make

322
00:12:52,560 --> 00:12:54,959
it point to a fake class descriptor that

323
00:12:54,959 --> 00:12:58,560
contains valid legitimate v tables and

324
00:12:58,560 --> 00:13:00,160
and this of course give us the

325
00:13:00,160 --> 00:13:01,920
explanation primitive of calling

326
00:13:01,920 --> 00:13:04,079
arbitrary existing methods in different

327
00:13:04,079 --> 00:13:06,560
objective-c objects this kind of type of

328
00:13:06,560 --> 00:13:08,639
confusions attack are very powerful and

329
00:13:08,639 --> 00:13:11,120
they are still possible on cherry

330
00:13:11,120 --> 00:13:13,760
okay now let's discuss exploitation of

331
00:13:13,760 --> 00:13:15,839
cherry isa from in high level point of

332
00:13:15,839 --> 00:13:16,800
view

333
00:13:16,800 --> 00:13:18,720
so we all know how this classic circle

334
00:13:18,720 --> 00:13:21,040
of life works right we find some of them

335
00:13:21,040 --> 00:13:23,600
zero day we shape some memory layout we

336
00:13:23,600 --> 00:13:26,160
trigger the vulnerability we do

337
00:13:26,160 --> 00:13:28,399
corruption of some target structure and

338
00:13:28,399 --> 00:13:30,720
from this point we gain

339
00:13:30,720 --> 00:13:32,399
arbitrary or relative read write

340
00:13:32,399 --> 00:13:34,160
primitives and from this point it's a

341
00:13:34,160 --> 00:13:36,560
game over it's a clear win now given

342
00:13:36,560 --> 00:13:38,639
cherry this phase of gaining relative

343
00:13:38,639 --> 00:13:40,399
arbitrary right primitive is actually

344
00:13:40,399 --> 00:13:42,560
kind of broken in the sense that if you

345
00:13:42,560 --> 00:13:44,800
want to gain a truly generic arbitrary

346
00:13:44,800 --> 00:13:46,399
read writes you need to gain a

347
00:13:46,399 --> 00:13:48,800
capability with a link that spans then

348
00:13:48,800 --> 00:13:50,560
the entire virtual outdoor space and

349
00:13:50,560 --> 00:13:52,000
there is no good reason the allocator

350
00:13:52,000 --> 00:13:55,760
will generate you such a capability

351
00:13:55,760 --> 00:13:56,720
please note that this makes the

352
00:13:56,720 --> 00:13:59,519
allocator to be in the sense some

353
00:13:59,519 --> 00:14:01,360
of the part of the tcp of the trusted

354
00:14:01,360 --> 00:14:03,199
components because the allocator

355
00:14:03,199 --> 00:14:06,000
actually uses dedicated instructions to

356
00:14:06,000 --> 00:14:07,839
change and edit and modify existing

357
00:14:07,839 --> 00:14:09,600
capabilities so we really need to make

358
00:14:09,600 --> 00:14:10,959
sure that the allocator cannot be

359
00:14:10,959 --> 00:14:12,880
compromised and that it checks the

360
00:14:12,880 --> 00:14:15,120
integrity of its own metadata before it

361
00:14:15,120 --> 00:14:17,839
uses it okay great so cherry introduces

362
00:14:17,839 --> 00:14:19,760
a new restriction right we cannot craft

363
00:14:19,760 --> 00:14:21,920
painters and we cannot fake pointers in

364
00:14:21,920 --> 00:14:23,680
any way this of course applies to

365
00:14:23,680 --> 00:14:27,519
everything function pointers v tables um

366
00:14:27,519 --> 00:14:29,440
return addresses structures buffers

367
00:14:29,440 --> 00:14:32,399
literally everything we can even know

368
00:14:32,399 --> 00:14:34,720
and longer though and partial corruption

369
00:14:34,720 --> 00:14:36,399
which is a very elegant and convenient

370
00:14:36,399 --> 00:14:38,320
trick and for instance if you want to

371
00:14:38,320 --> 00:14:40,560
deal with slr and you don't want to lick

372
00:14:40,560 --> 00:14:42,560
the entropy bits so you can just corrupt

373
00:14:42,560 --> 00:14:44,240
the lsb part of a pointer and you can

374
00:14:44,240 --> 00:14:46,480
move it backward or forward in memory

375
00:14:46,480 --> 00:14:48,560
such attacks are not possible on cherry

376
00:14:48,560 --> 00:14:51,040
at all because even if you flip one bits

377
00:14:51,040 --> 00:14:52,959
in a capability you clear the tag and

378
00:14:52,959 --> 00:14:55,279
you will just trigger a cherry exception

379
00:14:55,279 --> 00:14:56,880
when you will try to dereference this

380
00:14:56,880 --> 00:14:59,920
capability okay so what we can still do

381
00:14:59,920 --> 00:15:01,839
is we can move an existing capability

382
00:15:01,839 --> 00:15:04,079
from one place to another and this of

383
00:15:04,079 --> 00:15:06,160
course opens a pretty wide range of

384
00:15:06,160 --> 00:15:08,320
opportunities for us and for instance if

385
00:15:08,320 --> 00:15:10,000
we want to exploit and use after free

386
00:15:10,000 --> 00:15:11,360
bug

387
00:15:11,360 --> 00:15:13,440
does not mitigate temporal safety at the

388
00:15:13,440 --> 00:15:15,120
architectural level as well

389
00:15:15,120 --> 00:15:17,360
so we can just replace a structure a

390
00:15:17,360 --> 00:15:19,600
with a structure b in memory and we can

391
00:15:19,600 --> 00:15:22,160
choose our structures such that the v

392
00:15:22,160 --> 00:15:24,240
tables or some other pointers will be at

393
00:15:24,240 --> 00:15:26,399
the same offsets and we can treat these

394
00:15:26,399 --> 00:15:28,959
pointers differently this kind of type

395
00:15:28,959 --> 00:15:31,360
confusions attack are very powerful and

396
00:15:31,360 --> 00:15:33,440
they can be converted into a very

397
00:15:33,440 --> 00:15:35,120
exploitation

398
00:15:35,120 --> 00:15:36,880
primitives

399
00:15:36,880 --> 00:15:38,880
okay now let's talk about slr this is

400
00:15:38,880 --> 00:15:41,759
really fun slr means nothing on cherry

401
00:15:41,759 --> 00:15:44,320
and because we cannot corrupt or fake

402
00:15:44,320 --> 00:15:46,480
pointers in any way there is zero value

403
00:15:46,480 --> 00:15:48,800
for us to know the layout of the virtual

404
00:15:48,800 --> 00:15:50,560
address space right we really don't care

405
00:15:50,560 --> 00:15:51,920
where the star keep and leaps are

406
00:15:51,920 --> 00:15:54,560
located because we cannot even use this

407
00:15:54,560 --> 00:15:56,639
information in our exploits to begin

408
00:15:56,639 --> 00:15:59,120
with and and this is of course by design

409
00:15:59,120 --> 00:16:00,880
when people build the model of cherry

410
00:16:00,880 --> 00:16:02,720
they try to create a threat model where

411
00:16:02,720 --> 00:16:04,399
we can assume that we can give the

412
00:16:04,399 --> 00:16:06,240
attackers the entire layout of all of

413
00:16:06,240 --> 00:16:07,600
the virtual address space and it

414
00:16:07,600 --> 00:16:09,759
shouldn't help them at all

415
00:16:09,759 --> 00:16:11,519
i really do want to make a very

416
00:16:11,519 --> 00:16:13,279
important distinction here

417
00:16:13,279 --> 00:16:16,240
between bypassing slr and generic

418
00:16:16,240 --> 00:16:18,160
information disclosures because while we

419
00:16:18,160 --> 00:16:19,839
really don't care about people leaking

420
00:16:19,839 --> 00:16:21,600
capabilities and know the layout of the

421
00:16:21,600 --> 00:16:23,680
virtual address space we really do carry

422
00:16:23,680 --> 00:16:25,360
and we don't want attackers to be able

423
00:16:25,360 --> 00:16:27,680
to leak secret or confidential data

424
00:16:27,680 --> 00:16:29,680
across different security domains we

425
00:16:29,680 --> 00:16:31,279
even have some models such as the home

426
00:16:31,279 --> 00:16:33,199
sandbox for windows that rely on the

427
00:16:33,199 --> 00:16:35,440
fact that you cannot leak secrets in the

428
00:16:35,440 --> 00:16:37,519
homes and box for windows for example if

429
00:16:37,519 --> 00:16:39,279
you lick the port names from outside the

430
00:16:39,279 --> 00:16:41,279
sandbox you can escape the sandbox by

431
00:16:41,279 --> 00:16:44,720
design so we really do care about that

432
00:16:44,720 --> 00:16:47,839
okay now let's go to the exploitation

433
00:16:47,839 --> 00:16:49,519
so we have a

434
00:16:49,519 --> 00:16:52,240
port of jsc over pure capability cherry

435
00:16:52,240 --> 00:16:54,880
this is very convenient uh we use that

436
00:16:54,880 --> 00:16:56,800
in our first offensive research on

437
00:16:56,800 --> 00:16:59,040
cherry mips and we still use that in our

438
00:16:59,040 --> 00:17:01,199
research on morelo which is cherry on

439
00:17:01,199 --> 00:17:03,759
arm javascript engines are just a great

440
00:17:03,759 --> 00:17:05,599
place to export vulnerabilities in right

441
00:17:05,599 --> 00:17:07,760
we have a script in language which is

442
00:17:07,760 --> 00:17:10,000
highly convenient for exploitation and

443
00:17:10,000 --> 00:17:11,760
ever since morello we have jeets which

444
00:17:11,760 --> 00:17:14,720
is fantastic because jit compilers are

445
00:17:14,720 --> 00:17:16,880
have been proven to be a very rich place

446
00:17:16,880 --> 00:17:18,959
for bugs and for security issues so it

447
00:17:18,959 --> 00:17:20,480
just looks like the right place to start

448
00:17:20,480 --> 00:17:22,720
from and i want to start with an amazing

449
00:17:22,720 --> 00:17:24,720
bar an uninitialized

450
00:17:24,720 --> 00:17:28,640
stock in jsc full credit goes to bruno

451
00:17:28,640 --> 00:17:30,960
and then to lucatodesco the one and only

452
00:17:30,960 --> 00:17:32,799
who did an amazing job exploiting this

453
00:17:32,799 --> 00:17:34,799
vulnerability and all of this

454
00:17:34,799 --> 00:17:36,960
understanding of the root cause is based

455
00:17:36,960 --> 00:17:38,960
on their work so let's see what's going

456
00:17:38,960 --> 00:17:41,760
on here so as we all know registers is a

457
00:17:41,760 --> 00:17:43,840
limited resource right

458
00:17:43,840 --> 00:17:44,720
and

459
00:17:44,720 --> 00:17:46,400
in many cases we need to free up some

460
00:17:46,400 --> 00:17:48,720
registers when we have no ones available

461
00:17:48,720 --> 00:17:50,160
and in order to do so we need to

462
00:17:50,160 --> 00:17:51,360
implement

463
00:17:51,360 --> 00:17:53,520
some kind of a context switch

464
00:17:53,520 --> 00:17:55,039
we need to take all of the values that

465
00:17:55,039 --> 00:17:56,960
are currently stored in the registers

466
00:17:56,960 --> 00:17:58,000
and just

467
00:17:58,000 --> 00:18:00,160
store them to some piece of memory start

468
00:18:00,160 --> 00:18:02,640
hip or whatever and then later on when

469
00:18:02,640 --> 00:18:05,360
we want to continue the execution we

470
00:18:05,360 --> 00:18:07,600
need to restore all of these values from

471
00:18:07,600 --> 00:18:09,679
memory into the corresponding registers

472
00:18:09,679 --> 00:18:11,600
and then keep going

473
00:18:11,600 --> 00:18:13,440
and in many cases these values are being

474
00:18:13,440 --> 00:18:15,200
written to the stack

475
00:18:15,200 --> 00:18:18,160
okay great now the jsc register

476
00:18:18,160 --> 00:18:20,160
allocator makes this very interesting

477
00:18:20,160 --> 00:18:21,840
assumption that allocations happen

478
00:18:21,840 --> 00:18:24,240
unconditionally and this is interesting

479
00:18:24,240 --> 00:18:27,120
because if we have some flow in jsc that

480
00:18:27,120 --> 00:18:29,360
has a conditional branch and then does a

481
00:18:29,360 --> 00:18:31,120
register allocation

482
00:18:31,120 --> 00:18:33,039
it means that we can skip this register

483
00:18:33,039 --> 00:18:34,960
allocation and therefore we may skip all

484
00:18:34,960 --> 00:18:36,960
of these rights into the stack and this

485
00:18:36,960 --> 00:18:38,559
is very problematic because if there

486
00:18:38,559 --> 00:18:41,200
will be some flow later on uh that will

487
00:18:41,200 --> 00:18:43,200
try to use a value that is corresponding

488
00:18:43,200 --> 00:18:45,280
to a supposedly spilled register from

489
00:18:45,280 --> 00:18:48,480
before we just created here a scenario

490
00:18:48,480 --> 00:18:51,039
of using of uninitialized value from the

491
00:18:51,039 --> 00:18:52,480
stack

492
00:18:52,480 --> 00:18:54,240
and this gets super interesting because

493
00:18:54,240 --> 00:18:56,720
we can use the jit compiler to compile

494
00:18:56,720 --> 00:18:58,640
some javascript functions that fetch a

495
00:18:58,640 --> 00:19:00,720
pointer or in our case a capability on

496
00:19:00,720 --> 00:19:03,120
cherry a pointer from the stack that

497
00:19:03,120 --> 00:19:05,120
points to some js object of a certain

498
00:19:05,120 --> 00:19:07,440
type and you can use our bug in order to

499
00:19:07,440 --> 00:19:09,679
make the stack address to contain an

500
00:19:09,679 --> 00:19:11,360
uninitialized value

501
00:19:11,360 --> 00:19:13,039
and therefore we can shape this stack

502
00:19:13,039 --> 00:19:15,280
and upfront to drop their capability a

503
00:19:15,280 --> 00:19:17,600
valid capability that points to a

504
00:19:17,600 --> 00:19:20,559
different js object of a different type

505
00:19:20,559 --> 00:19:22,480
and this is how we can convert in a very

506
00:19:22,480 --> 00:19:25,200
elegant way this uninitialized use from

507
00:19:25,200 --> 00:19:28,320
the stack into a type confusion

508
00:19:28,320 --> 00:19:30,320
okay great so let's see some code so

509
00:19:30,320 --> 00:19:33,039
this function com compile string slice

510
00:19:33,039 --> 00:19:34,799
is the function

511
00:19:34,799 --> 00:19:36,480
that contains the bug and as you can see

512
00:19:36,480 --> 00:19:38,400
we have our conditional branch and then

513
00:19:38,400 --> 00:19:40,480
we have some register allocation and of

514
00:19:40,480 --> 00:19:42,559
course this register allocation may need

515
00:19:42,559 --> 00:19:44,960
to write some data into the stack and

516
00:19:44,960 --> 00:19:46,880
but if we will take the conditional

517
00:19:46,880 --> 00:19:48,559
branch we just keep the register

518
00:19:48,559 --> 00:19:50,559
allocation and all of this area on the

519
00:19:50,559 --> 00:19:53,039
stack will just remain uninitialized

520
00:19:53,039 --> 00:19:55,120
okay great now we said that we can

521
00:19:55,120 --> 00:19:56,799
control then initialize and shape the

522
00:19:56,799 --> 00:19:58,240
stack right so let's see how we can do

523
00:19:58,240 --> 00:20:00,400
it this is actually super simple if you

524
00:20:00,400 --> 00:20:01,919
want to write some data to the stack

525
00:20:01,919 --> 00:20:03,600
let's just call a function which

526
00:20:03,600 --> 00:20:05,679
allocate it on stack frame and then have

527
00:20:05,679 --> 00:20:07,280
this function to write some data into

528
00:20:07,280 --> 00:20:09,280
its own local stack frame and then when

529
00:20:09,280 --> 00:20:11,280
this function returns all of the data

530
00:20:11,280 --> 00:20:13,600
that we just wrote to the stack simply

531
00:20:13,600 --> 00:20:15,679
remains there until something else will

532
00:20:15,679 --> 00:20:17,440
come and override it

533
00:20:17,440 --> 00:20:19,919
so in our case we can simply implement

534
00:20:19,919 --> 00:20:21,919
two different javascript functions of

535
00:20:21,919 --> 00:20:24,799
one and opt that are basically identical

536
00:20:24,799 --> 00:20:26,720
and we just use them with different kind

537
00:20:26,720 --> 00:20:28,400
of objects we just pass them as

538
00:20:28,400 --> 00:20:30,480
arguments capabilities that points to

539
00:20:30,480 --> 00:20:34,159
two different js objects and so in this

540
00:20:34,159 --> 00:20:36,880
case for example let's call opt one with

541
00:20:36,880 --> 00:20:39,440
capability that points to a js object of

542
00:20:39,440 --> 00:20:42,240
type a and then we will call opt with a

543
00:20:42,240 --> 00:20:44,480
capability that points to a js object of

544
00:20:44,480 --> 00:20:46,960
type b and then because of the bug opt

545
00:20:46,960 --> 00:20:49,520
will fetch from the stack a capability

546
00:20:49,520 --> 00:20:51,679
that it believes that points to type b

547
00:20:51,679 --> 00:20:54,240
because we use the jit compiler and we

548
00:20:54,240 --> 00:20:56,159
train this function to be compiled with

549
00:20:56,159 --> 00:20:57,840
type b but

550
00:20:57,840 --> 00:21:00,080
opt one actually wrote something to this

551
00:21:00,080 --> 00:21:02,799
and to this uninitialized value on the

552
00:21:02,799 --> 00:21:04,799
stack and this something is a capability

553
00:21:04,799 --> 00:21:06,880
that points to type a and this is how we

554
00:21:06,880 --> 00:21:10,159
can con create this type confusion

555
00:21:10,159 --> 00:21:12,400
okay now let's see the plc and actually

556
00:21:12,400 --> 00:21:13,840
we can do

557
00:21:13,840 --> 00:21:16,080
more in this plc we can convert the type

558
00:21:16,080 --> 00:21:18,559
confusion to be out of bound read in a

559
00:21:18,559 --> 00:21:21,919
very simple way and great vlog and great

560
00:21:21,919 --> 00:21:24,320
curse to luca for this exploit again

561
00:21:24,320 --> 00:21:27,120
so what we have is just a lot of useless

562
00:21:27,120 --> 00:21:29,280
accesses to the stock to make sure that

563
00:21:29,280 --> 00:21:31,360
we have the stack frame that we want and

564
00:21:31,360 --> 00:21:33,200
then we need to do a type proof this is

565
00:21:33,200 --> 00:21:35,280
very important we need to fetch for some

566
00:21:35,280 --> 00:21:37,360
field in the object because this will

567
00:21:37,360 --> 00:21:39,200
tell the data flow graph that it can

568
00:21:39,200 --> 00:21:41,760
emit some structure checks and this is

569
00:21:41,760 --> 00:21:43,679
super important because we have a type

570
00:21:43,679 --> 00:21:45,760
confusion and these structural checks

571
00:21:45,760 --> 00:21:46,799
may break

572
00:21:46,799 --> 00:21:50,480
the exploits and it could cache us and

573
00:21:50,480 --> 00:21:52,480
then we do the bug trigger we call slice

574
00:21:52,480 --> 00:21:54,240
on a string which calls compile string

575
00:21:54,240 --> 00:21:56,320
slice the function that contains the bug

576
00:21:56,320 --> 00:21:58,000
and this creates the uninitialized on

577
00:21:58,000 --> 00:22:00,400
the stack and then we call get by offset

578
00:22:00,400 --> 00:22:03,039
but this get by offsets with big

579
00:22:03,039 --> 00:22:05,520
it will be called on an arbitrarily type

580
00:22:05,520 --> 00:22:07,679
red from the stack instead of on a

581
00:22:07,679 --> 00:22:09,760
proven type

582
00:22:09,760 --> 00:22:10,720
okay

583
00:22:10,720 --> 00:22:12,640
so this is super simple let's see how we

584
00:22:12,640 --> 00:22:15,520
can complete this out of one grid so we

585
00:22:15,520 --> 00:22:17,360
just need a

586
00:22:17,360 --> 00:22:19,039
to define some

587
00:22:19,039 --> 00:22:21,600
some objects and we just create an

588
00:22:21,600 --> 00:22:23,600
object with five fields and then another

589
00:22:23,600 --> 00:22:25,440
object with four fields and then we need

590
00:22:25,440 --> 00:22:27,760
to repeat this second object because we

591
00:22:27,760 --> 00:22:29,520
have an out of bound read here so we

592
00:22:29,520 --> 00:22:31,840
want two continuous allocations on the

593
00:22:31,840 --> 00:22:32,640
heap

594
00:22:32,640 --> 00:22:34,080
and

595
00:22:34,080 --> 00:22:34,799
and

596
00:22:34,799 --> 00:22:37,120
different types on jsc are actually

597
00:22:37,120 --> 00:22:39,760
allocated in different areas and then

598
00:22:39,760 --> 00:22:42,559
we'll just try to fetch to read a field

599
00:22:42,559 --> 00:22:44,400
a from obj2

600
00:22:44,400 --> 00:22:46,320
but because of the type confusion we

601
00:22:46,320 --> 00:22:48,640
actually use the offset of a in obj1

602
00:22:48,640 --> 00:22:51,039
which is clearly clearly an out of bound

603
00:22:51,039 --> 00:22:54,960
for obj2 okay great fantastic um

604
00:22:54,960 --> 00:22:56,799
now let's talk for a minute

605
00:22:56,799 --> 00:22:58,480
and talk about this that it's pretty

606
00:22:58,480 --> 00:22:59,600
well that we're standing here and

607
00:22:59,600 --> 00:23:01,520
talking about out of bound on sharing

608
00:23:01,520 --> 00:23:03,440
because we said the cherry i say does

609
00:23:03,440 --> 00:23:05,840
mitigate special safety in the

610
00:23:05,840 --> 00:23:07,919
architectural level so yes it does

611
00:23:07,919 --> 00:23:10,159
through and cherry does a wonderful job

612
00:23:10,159 --> 00:23:12,080
in deterministically mitigate special

613
00:23:12,080 --> 00:23:13,600
safety at the

614
00:23:13,600 --> 00:23:15,679
architectural level but if you want to

615
00:23:15,679 --> 00:23:17,280
get all of these guarantees from the

616
00:23:17,280 --> 00:23:19,600
architecture you need to use it right

617
00:23:19,600 --> 00:23:21,919
for instance you absolutely need to make

618
00:23:21,919 --> 00:23:24,000
sure that your allocators for star keep

619
00:23:24,000 --> 00:23:26,240
in global set the accurate bounds in all

620
00:23:26,240 --> 00:23:28,240
of the couple in all of the capabilities

621
00:23:28,240 --> 00:23:30,159
they return

622
00:23:30,159 --> 00:23:31,919
and as it turns out in the prototype

623
00:23:31,919 --> 00:23:33,520
that we were

624
00:23:33,520 --> 00:23:36,080
working on the cherry bsd over morelo

625
00:23:36,080 --> 00:23:37,679
all of the allocators for start keeping

626
00:23:37,679 --> 00:23:40,000
global did a fantastic job

627
00:23:40,000 --> 00:23:42,480
but the allocator for the jsl heap did

628
00:23:42,480 --> 00:23:45,360
not and it just sets 16k for bands for

629
00:23:45,360 --> 00:23:48,320
all of the allocations that it's

630
00:23:48,320 --> 00:23:51,120
um that it's like returns and this is

631
00:23:51,120 --> 00:23:53,520
why this technique works on morelo just

632
00:23:53,520 --> 00:23:56,960
as it works on ubuntu x64 or like ios or

633
00:23:56,960 --> 00:23:59,919
any other platform and now this actually

634
00:23:59,919 --> 00:24:01,760
was fixed in a

635
00:24:01,760 --> 00:24:04,000
dev branch of webkit over cherry so we

636
00:24:04,000 --> 00:24:05,360
can actually see the difference on the

637
00:24:05,360 --> 00:24:07,120
left hand side you can see the main

638
00:24:07,120 --> 00:24:08,000
branch

639
00:24:08,000 --> 00:24:09,440
with the bug and you can see that all of

640
00:24:09,440 --> 00:24:12,480
the capabilities have a 16k for bounce

641
00:24:12,480 --> 00:24:14,080
and on the right hand side you can

642
00:24:14,080 --> 00:24:16,640
simply see that all of the capabilities

643
00:24:16,640 --> 00:24:19,120
have accurate bounds

644
00:24:19,120 --> 00:24:21,520
okay great and this is the commit a

645
00:24:21,520 --> 00:24:22,720
fantastic

646
00:24:22,720 --> 00:24:25,200
job by brett from the university of

647
00:24:25,200 --> 00:24:28,240
cambridge okay now we have a very stable

648
00:24:28,240 --> 00:24:30,159
out of boundary right so let's see what

649
00:24:30,159 --> 00:24:32,240
we can do with it we already agreed that

650
00:24:32,240 --> 00:24:34,000
asl is out of the picture it's

651
00:24:34,000 --> 00:24:36,880
absolutely not interesting and this is a

652
00:24:36,880 --> 00:24:38,720
good time to talk about structure ids

653
00:24:38,720 --> 00:24:41,039
every type in jsc has a unique structure

654
00:24:41,039 --> 00:24:42,320
id a tilted

655
00:24:42,320 --> 00:24:45,200
bits that are stored as the first deload

656
00:24:45,200 --> 00:24:47,279
of every object

657
00:24:47,279 --> 00:24:49,840
and attackers supposedly need to know a

658
00:24:49,840 --> 00:24:51,440
valid structure id in order to fake

659
00:24:51,440 --> 00:24:53,279
objects in memory because there are many

660
00:24:53,279 --> 00:24:55,200
structure checks that make sure that

661
00:24:55,200 --> 00:24:56,799
every time that we are about to operate

662
00:24:56,799 --> 00:24:58,159
on some objects

663
00:24:58,159 --> 00:25:00,480
we need to make sure that this object is

664
00:25:00,480 --> 00:25:02,159
of the type that we are expecting from

665
00:25:02,159 --> 00:25:03,919
it to be

666
00:25:03,919 --> 00:25:04,720
uh

667
00:25:04,720 --> 00:25:06,159
and

668
00:25:06,159 --> 00:25:07,600
back in the day it was actually very

669
00:25:07,600 --> 00:25:09,760
easy to guess and predict these

670
00:25:09,760 --> 00:25:12,000
structure ideas you could just spray a

671
00:25:12,000 --> 00:25:13,760
lot of like different types and objects

672
00:25:13,760 --> 00:25:14,880
and then you could guess that for

673
00:25:14,880 --> 00:25:17,200
instance structured thousands is of a

674
00:25:17,200 --> 00:25:18,880
certain type and it works fantastic and

675
00:25:18,880 --> 00:25:20,880
everybody did it and because everybody

676
00:25:20,880 --> 00:25:23,039
did it apple added a randomization that

677
00:25:23,039 --> 00:25:24,880
called structure radio randomization

678
00:25:24,880 --> 00:25:26,799
that does exactly what its name suggests

679
00:25:26,799 --> 00:25:28,159
it just randomizes all of the structure

680
00:25:28,159 --> 00:25:30,159
ideas and this is a very good example

681
00:25:30,159 --> 00:25:31,840
for mitigation that it would be very

682
00:25:31,840 --> 00:25:34,480
interesting for us to bypass on cherry

683
00:25:34,480 --> 00:25:35,679
because even though there are many

684
00:25:35,679 --> 00:25:37,919
mitigations that we might remove given

685
00:25:37,919 --> 00:25:41,039
cherry such as acelav

686
00:25:41,039 --> 00:25:42,880
and some others this is a very good

687
00:25:42,880 --> 00:25:44,320
example of a mitigation that we still

688
00:25:44,320 --> 00:25:45,840
want to keep around

689
00:25:45,840 --> 00:25:48,640
because it make a faking structures more

690
00:25:48,640 --> 00:25:49,840
difficult

691
00:25:49,840 --> 00:25:51,279
okay so

692
00:25:51,279 --> 00:25:53,600
let's try to leak some structure id and

693
00:25:53,600 --> 00:25:54,720
this is actually something that you can

694
00:25:54,720 --> 00:25:56,880
see in many webkit exploits today most

695
00:25:56,880 --> 00:25:59,039
of the exploits just opened with

696
00:25:59,039 --> 00:26:01,120
a licking a valid

697
00:26:01,120 --> 00:26:04,480
saxophone structure ready okay and this

698
00:26:04,480 --> 00:26:06,559
is the commits that added the

699
00:26:06,559 --> 00:26:09,120
randomization of the structure ideas so

700
00:26:09,120 --> 00:26:13,120
this is the the part of uh likable plc

701
00:26:13,120 --> 00:26:14,080
that

702
00:26:14,080 --> 00:26:16,080
did compile the javascript functions as

703
00:26:16,080 --> 00:26:18,799
in and and as you can see we have the

704
00:26:18,799 --> 00:26:21,200
definitions for all of the objects and

705
00:26:21,200 --> 00:26:23,120
we set a pattern here in objects to an

706
00:26:23,120 --> 00:26:25,120
victim so we could identify them in

707
00:26:25,120 --> 00:26:27,600
memory and this is on morelo and you can

708
00:26:27,600 --> 00:26:29,520
simply see that obj2 and victim are

709
00:26:29,520 --> 00:26:31,840
allocated continuously on the hip and

710
00:26:31,840 --> 00:26:34,320
the first deal in both of these objects

711
00:26:34,320 --> 00:26:37,919
is the 32-bit structure ids and clearly

712
00:26:37,919 --> 00:26:39,360
we can understand it if we'll just

713
00:26:39,360 --> 00:26:41,600
trigger the art of madrid

714
00:26:41,600 --> 00:26:43,039
from obj2

715
00:26:43,039 --> 00:26:45,120
to victim we'll just fetch and read the

716
00:26:45,120 --> 00:26:46,559
structure id

717
00:26:46,559 --> 00:26:48,880
of victim and this is exactly what

718
00:26:48,880 --> 00:26:52,480
happens and and now we will go back to

719
00:26:52,480 --> 00:26:54,559
nico which will show us the second

720
00:26:54,559 --> 00:26:56,400
vulnerability and the second exploit

721
00:26:56,400 --> 00:26:57,520
thank you

722
00:26:57,520 --> 00:27:01,600
thank you sir that was super interesting

723
00:27:01,600 --> 00:27:02,720
so we first

724
00:27:02,720 --> 00:27:06,880
had a look at cherry in summer 2020 and

725
00:27:06,880 --> 00:27:10,159
we looked particularly at jsc on cherry

726
00:27:10,159 --> 00:27:12,559
bsd on actually cherry mips

727
00:27:12,559 --> 00:27:15,120
the question that we had was that we

728
00:27:15,120 --> 00:27:17,440
knew that sherry was very good at

729
00:27:17,440 --> 00:27:19,679
mitigating special safety issue but we

730
00:27:19,679 --> 00:27:21,520
knew that there was still a concern with

731
00:27:21,520 --> 00:27:24,240
temporal safety so our question was

732
00:27:24,240 --> 00:27:26,720
provided with special safety would we

733
00:27:26,720 --> 00:27:28,720
still be able to exploit a temporal

734
00:27:28,720 --> 00:27:30,080
safety issue

735
00:27:30,080 --> 00:27:32,640
so to try to solve this question we

736
00:27:32,640 --> 00:27:35,760
looked we looked at jc and we wanted to

737
00:27:35,760 --> 00:27:38,080
have a look at some cvs and see if we

738
00:27:38,080 --> 00:27:40,240
could still exploit those

739
00:27:40,240 --> 00:27:43,200
problem that we faced is that

740
00:27:43,200 --> 00:27:46,159
well one of one of the problem with

741
00:27:46,159 --> 00:27:49,520
with jsc on mips is that jit the jit is

742
00:27:49,520 --> 00:27:50,720
unsupported

743
00:27:50,720 --> 00:27:52,559
and there were something else like the

744
00:27:52,559 --> 00:27:55,360
gc garbage collection that wasn't really

745
00:27:55,360 --> 00:27:57,440
working so we couldn't really trigger

746
00:27:57,440 --> 00:28:00,000
some use after three issues so instead

747
00:28:00,000 --> 00:28:01,600
we went for the easy way and we

748
00:28:01,600 --> 00:28:04,399
introduced a stack user factor free

749
00:28:04,399 --> 00:28:06,320
stack uaf

750
00:28:06,320 --> 00:28:08,559
so why this kind of issue the reason is

751
00:28:08,559 --> 00:28:10,880
a few years ago we had a bunch of test

752
00:28:10,880 --> 00:28:14,880
cases in chakra and the scenario here

753
00:28:14,880 --> 00:28:17,279
was that in some cases it was possible

754
00:28:17,279 --> 00:28:19,520
with the jit to allocate an object in

755
00:28:19,520 --> 00:28:21,360
the stack and because of the bug in

756
00:28:21,360 --> 00:28:23,120
chakra it would be possible for an

757
00:28:23,120 --> 00:28:26,159
attacker later to uh

758
00:28:26,159 --> 00:28:29,840
to use that reference and so this would

759
00:28:29,840 --> 00:28:32,080
give him the ability to read and write

760
00:28:32,080 --> 00:28:35,039
stuff in the stack so this was a super

761
00:28:35,039 --> 00:28:37,440
powerful primitive so we were a bit

762
00:28:37,440 --> 00:28:39,840
curious about those issues and we wanted

763
00:28:39,840 --> 00:28:42,399
to see how far cherry

764
00:28:42,399 --> 00:28:45,840
would be able to mitigate those

765
00:28:46,159 --> 00:28:48,480
so to do that we decided to introduce a

766
00:28:48,480 --> 00:28:49,360
bug

767
00:28:49,360 --> 00:28:51,520
in the era buffer so something very

768
00:28:51,520 --> 00:28:54,240
simple so here we just chant a couple of

769
00:28:54,240 --> 00:28:57,279
lines and so instead of dealing with the

770
00:28:57,279 --> 00:28:58,960
hip the array buffer would now be

771
00:28:58,960 --> 00:29:00,480
dealing with the stack

772
00:29:00,480 --> 00:29:03,200
so a trigger would be super simple so we

773
00:29:03,200 --> 00:29:04,799
would just allocate a normal array

774
00:29:04,799 --> 00:29:06,960
buffer and then we would slice it and

775
00:29:06,960 --> 00:29:10,080
that would give a view to the stack

776
00:29:10,080 --> 00:29:13,039
to the attacker so what can we do with

777
00:29:13,039 --> 00:29:15,760
that well if you know sar

778
00:29:15,760 --> 00:29:17,679
you know that once you've got your read

779
00:29:17,679 --> 00:29:20,240
and write permittee well it's game over

780
00:29:20,240 --> 00:29:22,720
so we want to get to the same state but

781
00:29:22,720 --> 00:29:25,039
here we have cherry to deal with

782
00:29:25,039 --> 00:29:28,000
so first what can what

783
00:29:28,000 --> 00:29:30,159
where do we want to go first we want to

784
00:29:30,159 --> 00:29:33,279
see if we can copy a capability from one

785
00:29:33,279 --> 00:29:35,919
place to another without losing the tag

786
00:29:35,919 --> 00:29:37,279
the tag bits

787
00:29:37,279 --> 00:29:39,120
so at first i thought that this would be

788
00:29:39,120 --> 00:29:42,320
easy i would just have to use

789
00:29:42,320 --> 00:29:44,320
some known types in javascript that

790
00:29:44,320 --> 00:29:47,919
would be using 128 bits

791
00:29:47,919 --> 00:29:50,080
the problem with the gic at least on

792
00:29:50,080 --> 00:29:52,399
mips is that there is no

793
00:29:52,399 --> 00:29:55,039
such objects that uh that exists at my

794
00:29:55,039 --> 00:29:56,080
at most

795
00:29:56,080 --> 00:29:57,360
float takes

796
00:29:57,360 --> 00:30:00,640
64 bits and so if you try to copy two

797
00:30:00,640 --> 00:30:03,760
floats then obviously you will lose the

798
00:30:03,760 --> 00:30:05,039
the tag bit

799
00:30:05,039 --> 00:30:07,039
so this proved to be a bit more

800
00:30:07,039 --> 00:30:10,320
difficult than expected

801
00:30:10,320 --> 00:30:13,279
so by looking for move online copy the

802
00:30:13,279 --> 00:30:16,159
source code we noticed two methods typed

803
00:30:16,159 --> 00:30:19,039
our reset and slice

804
00:30:19,039 --> 00:30:21,120
and it turns out that when

805
00:30:21,120 --> 00:30:23,520
the destination and source have the same

806
00:30:23,520 --> 00:30:26,240
type it's possible to enter this

807
00:30:26,240 --> 00:30:27,840
particular

808
00:30:27,840 --> 00:30:30,159
piece of code and here as you can see

809
00:30:30,159 --> 00:30:32,240
there is a main move

810
00:30:32,240 --> 00:30:34,320
so which means that

811
00:30:34,320 --> 00:30:36,799
if we are

812
00:30:36,799 --> 00:30:40,640
using set uh typed reset with two array

813
00:30:40,640 --> 00:30:43,440
buffers that have the same type then

814
00:30:43,440 --> 00:30:46,399
we'll be uh able to copy a capability

815
00:30:46,399 --> 00:30:47,360
from

816
00:30:47,360 --> 00:30:49,679
one array buffer located in the stack to

817
00:30:49,679 --> 00:30:51,840
another array buffer in the heap so

818
00:30:51,840 --> 00:30:54,320
that's already a good step

819
00:30:54,320 --> 00:30:58,000
now can we read from anywhere well not

820
00:30:58,000 --> 00:31:00,760
exactly anywhere you cannot read from

821
00:31:00,760 --> 00:31:03,600
4141.41 for example this is not possible

822
00:31:03,600 --> 00:31:05,360
with cherry you have to read from a

823
00:31:05,360 --> 00:31:06,880
valid capability

824
00:31:06,880 --> 00:31:09,200
so what can we do for example we can

825
00:31:09,200 --> 00:31:10,000
read

826
00:31:10,000 --> 00:31:12,159
capabilities in the stack but can we

827
00:31:12,159 --> 00:31:14,399
really read from those capabilities well

828
00:31:14,399 --> 00:31:16,559
it turns out that with re-entrancy

829
00:31:16,559 --> 00:31:18,480
applied on the length argument

830
00:31:18,480 --> 00:31:20,960
we could for example trigger again the

831
00:31:20,960 --> 00:31:24,080
same issue and this time alter will

832
00:31:24,080 --> 00:31:26,720
change the sorcery capability

833
00:31:26,720 --> 00:31:28,320
so we would be

834
00:31:28,320 --> 00:31:31,519
triggering twice the issue once to get

835
00:31:31,519 --> 00:31:33,120
into

836
00:31:33,120 --> 00:31:34,559
the set function

837
00:31:34,559 --> 00:31:36,799
then we would trigger around 20 and then

838
00:31:36,799 --> 00:31:39,039
we would trigger again the same issue to

839
00:31:39,039 --> 00:31:41,679
overwrite the source array and

840
00:31:41,679 --> 00:31:44,080
in that state we will be able to read

841
00:31:44,080 --> 00:31:47,279
from anywhere and i mean from any valid

842
00:31:47,279 --> 00:31:49,519
capability so this is already a good

843
00:31:49,519 --> 00:31:51,120
step

844
00:31:51,120 --> 00:31:53,120
now can we write

845
00:31:53,120 --> 00:31:54,799
anything anywhere

846
00:31:54,799 --> 00:31:56,799
well the answer to that is likely i'm

847
00:31:56,799 --> 00:31:58,480
saying likely because i didn't already

848
00:31:58,480 --> 00:31:59,679
explore

849
00:31:59,679 --> 00:32:02,080
this possibility it turns out that the

850
00:32:02,080 --> 00:32:04,240
bug that we introduced was already quite

851
00:32:04,240 --> 00:32:06,799
powerful we were able to write things in

852
00:32:06,799 --> 00:32:08,640
the stack so we were able to correct

853
00:32:08,640 --> 00:32:11,600
pointers no need to be able to write

854
00:32:11,600 --> 00:32:14,000
something anywhere but if you look at

855
00:32:14,000 --> 00:32:15,840
set or slides it's

856
00:32:15,840 --> 00:32:19,279
likely that you'd be able to do exactly

857
00:32:19,279 --> 00:32:21,360
the same thing

858
00:32:21,360 --> 00:32:23,440
so now that we have that in mind where

859
00:32:23,440 --> 00:32:25,919
are we going so ideally we would want to

860
00:32:25,919 --> 00:32:28,399
reach a function that would

861
00:32:28,399 --> 00:32:30,640
that would allow the attacker to execute

862
00:32:30,640 --> 00:32:32,480
an arbitrary command something like

863
00:32:32,480 --> 00:32:35,039
system for example where can we find a

864
00:32:35,039 --> 00:32:37,600
system libsy.system it turns out that

865
00:32:37,600 --> 00:32:39,600
there is one place where we can find it

866
00:32:39,600 --> 00:32:42,320
it's a cherry capability table and it

867
00:32:42,320 --> 00:32:44,559
also turns out that the cherry cabbage

868
00:32:44,559 --> 00:32:47,360
table is used everywhere by the compiler

869
00:32:47,360 --> 00:32:49,919
you're going to see tons of references

870
00:32:49,919 --> 00:32:51,600
to it in the stack

871
00:32:51,600 --> 00:32:54,240
so this makes it super convenient for

872
00:32:54,240 --> 00:32:56,000
the attacker you cannot

873
00:32:56,000 --> 00:32:58,399
you can just read a pointer to a cherry

874
00:32:58,399 --> 00:33:00,640
capability table and then traverse that

875
00:33:00,640 --> 00:33:03,519
pointer up to finding a pointer to

876
00:33:03,519 --> 00:33:04,880
system

877
00:33:04,880 --> 00:33:07,200
so this is what we are going to do we

878
00:33:07,200 --> 00:33:10,480
are going to traverse enough capability

879
00:33:10,480 --> 00:33:12,880
up to reading system and then we'll find

880
00:33:12,880 --> 00:33:15,760
a way to get rc

881
00:33:15,760 --> 00:33:18,559
so how to get rc so one could for

882
00:33:18,559 --> 00:33:20,960
example just try to overwrite a return

883
00:33:20,960 --> 00:33:22,159
address

884
00:33:22,159 --> 00:33:24,720
with a capability to system but the

885
00:33:24,720 --> 00:33:26,640
problem with that is that because of the

886
00:33:26,640 --> 00:33:30,799
current convention uh system would use

887
00:33:30,799 --> 00:33:33,360
its first argument in a register and so

888
00:33:33,360 --> 00:33:35,840
if you try to overwrite a return address

889
00:33:35,840 --> 00:33:38,320
then you'd also have to make sure that

890
00:33:38,320 --> 00:33:41,039
this particular register would be set to

891
00:33:41,039 --> 00:33:42,559
uh your uh

892
00:33:42,559 --> 00:33:44,399
your your own value

893
00:33:44,399 --> 00:33:46,640
and because of that it makes things uh

894
00:33:46,640 --> 00:33:48,240
really hard

895
00:33:48,240 --> 00:33:50,480
to to implement it might be possible but

896
00:33:50,480 --> 00:33:53,679
definitely harder so what we did instead

897
00:33:53,679 --> 00:33:56,799
is that we targeted a saved c plus plus

898
00:33:56,799 --> 00:33:58,080
object

899
00:33:58,080 --> 00:34:01,120
in the stack so an object with a v table

900
00:34:01,120 --> 00:34:03,519
and here it would be super easy actually

901
00:34:03,519 --> 00:34:06,480
to fake a v table you can with cherry

902
00:34:06,480 --> 00:34:08,560
you just see you can as i said in the

903
00:34:08,560 --> 00:34:10,639
beginning of the table is just again a

904
00:34:10,639 --> 00:34:13,280
capability a capability to some other

905
00:34:13,280 --> 00:34:15,760
capabilities so something that is easy

906
00:34:15,760 --> 00:34:18,320
to to achieve with uh with an array

907
00:34:18,320 --> 00:34:20,560
buffer so we would just create an array

908
00:34:20,560 --> 00:34:22,719
buffer and then add some offset in this

909
00:34:22,719 --> 00:34:25,440
array buffer copy the capabilities

910
00:34:25,440 --> 00:34:28,320
to system and that would be rv table

911
00:34:28,320 --> 00:34:31,599
something really easy in the end

912
00:34:31,599 --> 00:34:33,760
and so in the end we just need to

913
00:34:33,760 --> 00:34:36,399
overwrite two pointers two capabilities

914
00:34:36,399 --> 00:34:39,119
in the stack one for dc plus plus object

915
00:34:39,119 --> 00:34:41,280
and one for

916
00:34:41,280 --> 00:34:43,280
for the argument

917
00:34:43,280 --> 00:34:45,359
and then we'll just wait for the stack

918
00:34:45,359 --> 00:34:48,399
to and win to execute or payload

919
00:34:48,399 --> 00:34:50,879
and so this is a result i agree with you

920
00:34:50,879 --> 00:34:52,800
that this isn't very impressive but at

921
00:34:52,800 --> 00:34:55,599
least it works you can see a ping to uh

922
00:34:55,599 --> 00:34:58,480
some some websites executed just from

923
00:34:58,480 --> 00:35:03,440
loaded uh a script with jsc

924
00:35:03,440 --> 00:35:05,680
and now i'm going to hand over again to

925
00:35:05,680 --> 00:35:08,320
sar who will be talking about some work

926
00:35:08,320 --> 00:35:10,960
in progress and we'll be concluding

927
00:35:10,960 --> 00:35:12,560
thank you thank you so much nico this

928
00:35:12,560 --> 00:35:15,280
was super interesting okay so now let's

929
00:35:15,280 --> 00:35:17,280
talk about how we can present some

930
00:35:17,280 --> 00:35:20,480
hardening of cherry so as we saw cherry

931
00:35:20,480 --> 00:35:21,680
isa

932
00:35:21,680 --> 00:35:24,160
gives us known for non-foldable

933
00:35:24,160 --> 00:35:26,880
references to virtual memory and bounce

934
00:35:26,880 --> 00:35:28,480
and permission check at the

935
00:35:28,480 --> 00:35:30,480
architectural level which is amazing

936
00:35:30,480 --> 00:35:31,359
and

937
00:35:31,359 --> 00:35:33,760
if we just use cherry aware compiler and

938
00:35:33,760 --> 00:35:37,040
runtime we could actually achieve um

939
00:35:37,040 --> 00:35:38,880
deterministic mitigation for all of the

940
00:35:38,880 --> 00:35:40,640
special safety variants and it's

941
00:35:40,640 --> 00:35:43,040
fantastic and this means that we just

942
00:35:43,040 --> 00:35:45,359
left with temple safety type safety

943
00:35:45,359 --> 00:35:46,880
allocator safety and probably some other

944
00:35:46,880 --> 00:35:49,440
stuff that we need to care about

945
00:35:49,440 --> 00:35:51,440
and we just want to mention here that

946
00:35:51,440 --> 00:35:53,119
there are some fantastic and really

947
00:35:53,119 --> 00:35:55,200
impressive work in progress projects

948
00:35:55,200 --> 00:35:57,200
they try to present software solutions

949
00:35:57,200 --> 00:35:59,760
for these backlashes a very good example

950
00:35:59,760 --> 00:36:01,760
is cornucopia which is capability

951
00:36:01,760 --> 00:36:04,320
revocation it's an extension

952
00:36:04,320 --> 00:36:05,599
for the virtual

953
00:36:05,599 --> 00:36:09,200
memory subsystem in cherry bcd and it's

954
00:36:09,200 --> 00:36:10,720
um

955
00:36:10,720 --> 00:36:12,000
it's simply

956
00:36:12,000 --> 00:36:13,520
represents a

957
00:36:13,520 --> 00:36:16,000
deterministic mitigation

958
00:36:16,000 --> 00:36:18,000
for c and c plus plus heap temporal

959
00:36:18,000 --> 00:36:20,240
safety issues mostly focused on heap use

960
00:36:20,240 --> 00:36:22,480
after freeze and we don't have time to

961
00:36:22,480 --> 00:36:24,240
talk about all of the details but there

962
00:36:24,240 --> 00:36:26,480
is a great paper that you can check out

963
00:36:26,480 --> 00:36:28,960
and there is actually the code in a

964
00:36:28,960 --> 00:36:30,880
dedicated branch of cherry bsd that

965
00:36:30,880 --> 00:36:32,640
implements capability

966
00:36:32,640 --> 00:36:35,760
revocation so please check it out

967
00:36:35,760 --> 00:36:38,400
another very important example is jit

968
00:36:38,400 --> 00:36:40,640
jit is always a very sensitive and very

969
00:36:40,640 --> 00:36:43,280
very dangerous place and for instance we

970
00:36:43,280 --> 00:36:45,200
do want to make sure that we can enforce

971
00:36:45,200 --> 00:36:47,119
right so x right we don't want to have

972
00:36:47,119 --> 00:36:49,920
one physical page that is both writable

973
00:36:49,920 --> 00:36:52,079
and executable at the same time so

974
00:36:52,079 --> 00:36:53,760
instead of just having two different

975
00:36:53,760 --> 00:36:55,760
virtual mappings that the first one is

976
00:36:55,760 --> 00:36:57,440
read right and the second one is it

977
00:36:57,440 --> 00:36:59,119
executes we can just have two different

978
00:36:59,119 --> 00:37:01,040
capabilities the first one is read right

979
00:37:01,040 --> 00:37:02,960
and the other one is executed and it's

980
00:37:02,960 --> 00:37:05,520
very elegant and this is very good

981
00:37:05,520 --> 00:37:08,240
example for the fact that cherry isa

982
00:37:08,240 --> 00:37:11,040
is also provide us very

983
00:37:11,040 --> 00:37:13,359
very like unique set of abilities in

984
00:37:13,359 --> 00:37:15,359
hardware that we can take advantage on

985
00:37:15,359 --> 00:37:17,920
from software in order to implement a

986
00:37:17,920 --> 00:37:19,839
more elegant and stable software

987
00:37:19,839 --> 00:37:21,599
solutions

988
00:37:21,599 --> 00:37:24,560
and and this is for instance a

989
00:37:24,560 --> 00:37:26,800
commit from brett from the

990
00:37:26,800 --> 00:37:29,680
university of cambridge that implements

991
00:37:29,680 --> 00:37:32,240
this idea of just like having and

992
00:37:32,240 --> 00:37:34,640
capabilities that are only

993
00:37:34,640 --> 00:37:37,440
recreatable or executable in the

994
00:37:37,440 --> 00:37:40,400
executable allocator okay so some

995
00:37:40,400 --> 00:37:42,720
takeaways cherry isa

996
00:37:42,720 --> 00:37:44,480
mitigates a very wide range of

997
00:37:44,480 --> 00:37:46,720
backlashes at the architectural level

998
00:37:46,720 --> 00:37:49,440
fantastic and cherry i say significantly

999
00:37:49,440 --> 00:37:52,480
like raises the uh the the bar for

1000
00:37:52,480 --> 00:37:54,560
exploitation uh

1001
00:37:54,560 --> 00:37:57,520
in a very elegant in a very unique way

1002
00:37:57,520 --> 00:37:59,520
and it's very important to keep in mind

1003
00:37:59,520 --> 00:38:01,839
that cherry offers a lot of abilities in

1004
00:38:01,839 --> 00:38:03,599
hardware just like we said that you can

1005
00:38:03,599 --> 00:38:06,240
take advantage on from software

1006
00:38:06,240 --> 00:38:08,400
and it's very important to keep in mind

1007
00:38:08,400 --> 00:38:10,400
that it's only the beginning there is so

1008
00:38:10,400 --> 00:38:12,560
much to innovate research and to develop

1009
00:38:12,560 --> 00:38:14,079
in

1010
00:38:14,079 --> 00:38:16,640
in this area so we absolutely hope that

1011
00:38:16,640 --> 00:38:19,040
all of you will like jump by and we'll

1012
00:38:19,040 --> 00:38:22,720
try to help to make cherry and um better

1013
00:38:22,720 --> 00:38:23,680
and

1014
00:38:23,680 --> 00:38:26,400
stronger and now it's time for shout

1015
00:38:26,400 --> 00:38:28,079
outs and this project could not have

1016
00:38:28,079 --> 00:38:30,000
been done without an amazing force for

1017
00:38:30,000 --> 00:38:32,640
many different teams and organizations

1018
00:38:32,640 --> 00:38:35,520
msrc msr cambridge and like many other

1019
00:38:35,520 --> 00:38:37,520
partners we cannot mention all of you

1020
00:38:37,520 --> 00:38:39,440
but thank you so much

1021
00:38:39,440 --> 00:38:41,680
it was super fun to work together and to

1022
00:38:41,680 --> 00:38:44,240
collaborate on this project here are

1023
00:38:44,240 --> 00:38:45,920
some references that you can follow on

1024
00:38:45,920 --> 00:38:49,200
cherry and thank you

