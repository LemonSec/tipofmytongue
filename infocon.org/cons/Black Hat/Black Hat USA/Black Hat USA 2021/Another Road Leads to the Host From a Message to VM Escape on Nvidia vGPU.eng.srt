1
00:00:01,130 --> 00:00:14,000
[Music]

2
00:00:14,000 --> 00:00:16,800
hello everyone and welcome to my talk i

3
00:00:16,800 --> 00:00:18,960
am mun chang chen and today i am going

4
00:00:18,960 --> 00:00:21,920
to talk about my recent research on gpu

5
00:00:21,920 --> 00:00:23,519
virtualization

6
00:00:23,519 --> 00:00:25,519
named another road leads to the host

7
00:00:25,519 --> 00:00:28,240
from a message to vm escape on nvidia 3

8
00:00:28,240 --> 00:00:31,240
gpu

9
00:00:31,840 --> 00:00:34,559
and first a little introduce myself

10
00:00:34,559 --> 00:00:37,600
i'm now doing security research in many

11
00:00:37,600 --> 00:00:40,000
fields including virtualization web

12
00:00:40,000 --> 00:00:41,680
browser iot

13
00:00:41,680 --> 00:00:42,480
and

14
00:00:42,480 --> 00:00:44,480
well as you can see i almost changed my

15
00:00:44,480 --> 00:00:46,480
research directions every year to learn

16
00:00:46,480 --> 00:00:48,719
from different fields and i am now

17
00:00:48,719 --> 00:00:51,120
interested in and also studying further

18
00:00:51,120 --> 00:00:54,718
developing and machine learning

19
00:00:55,199 --> 00:00:58,000
and here introduced to my team i am now

20
00:00:58,000 --> 00:01:00,800
working in tencent red team and which is

21
00:01:00,800 --> 00:01:02,960
funded by tencent security platform

22
00:01:02,960 --> 00:01:05,199
department and we have researchers in

23
00:01:05,199 --> 00:01:07,439
many fields like aiot

24
00:01:07,439 --> 00:01:10,560
mobile devices and cloud virtualization

25
00:01:10,560 --> 00:01:16,000
and now i also listed our homepage here

26
00:01:16,479 --> 00:01:19,280
um okay and here's the agenda of my talk

27
00:01:19,280 --> 00:01:21,520
today first i will introduce the

28
00:01:21,520 --> 00:01:24,000
backgrounds of my research and then the

29
00:01:24,000 --> 00:01:26,400
structures of their installers and

30
00:01:26,400 --> 00:01:28,640
following the most important part the

31
00:01:28,640 --> 00:01:31,439
vrpc message and its handling in the end

32
00:01:31,439 --> 00:01:33,759
i will sum up some security best

33
00:01:33,759 --> 00:01:38,400
practices and my devices on using vgpu

34
00:01:38,400 --> 00:01:40,720
okay here we go

35
00:01:40,720 --> 00:01:43,360
and let's start from introducing the gpu

36
00:01:43,360 --> 00:01:45,520
virtualization gpu virtualization

37
00:01:45,520 --> 00:01:48,079
technique allow users to share a gpu

38
00:01:48,079 --> 00:01:50,240
card in their own vms

39
00:01:50,240 --> 00:01:52,799
it is used in virus applications such as

40
00:01:52,799 --> 00:01:54,560
desktop virtualization

41
00:01:54,560 --> 00:01:57,040
cloud gaming and compute computational

42
00:01:57,040 --> 00:01:58,079
science

43
00:01:58,079 --> 00:02:00,159
it is

44
00:02:00,159 --> 00:02:02,560
generally involve one or more techniques

45
00:02:02,560 --> 00:02:05,680
such as device emulation api remoting

46
00:02:05,680 --> 00:02:07,759
fixed pass-through and the mediated

47
00:02:07,759 --> 00:02:10,720
pass-through in fixed pass-through a gpu

48
00:02:10,720 --> 00:02:13,599
is accessed directly by a single virtual

49
00:02:13,599 --> 00:02:16,560
machine exclusively and permanently

50
00:02:16,560 --> 00:02:19,120
and this achieves

51
00:02:19,120 --> 00:02:22,080
almost native performance in mediated

52
00:02:22,080 --> 00:02:24,400
device pass-through the hypervisor sends

53
00:02:24,400 --> 00:02:26,480
java visual commands from guests

54
00:02:26,480 --> 00:02:28,480
directly to the gpu

55
00:02:28,480 --> 00:02:30,800
this is a form of hardware assisted

56
00:02:30,800 --> 00:02:32,879
virtualization and achieves near nature

57
00:02:32,879 --> 00:02:34,080
performance

58
00:02:34,080 --> 00:02:37,040
and as you can see a media amd intel

59
00:02:37,040 --> 00:02:40,799
they all support the vgpu

60
00:02:41,840 --> 00:02:44,800
now let's move to the specific product

61
00:02:44,800 --> 00:02:46,720
the nvidia vgpu

62
00:02:46,720 --> 00:02:49,360
and it can be used in a data center

63
00:02:49,360 --> 00:02:51,519
allowed gpus to be shared across

64
00:02:51,519 --> 00:02:53,920
multiple virtual machines and according

65
00:02:53,920 --> 00:02:56,400
to nvidia many famous cloud service

66
00:02:56,400 --> 00:02:58,879
providers are providing the gpu service

67
00:02:58,879 --> 00:03:01,200
and some are in pass remote some are

68
00:03:01,200 --> 00:03:04,159
using full vtpu functionalities

69
00:03:04,159 --> 00:03:07,120
the vgpu is restricted to certain data

70
00:03:07,120 --> 00:03:09,760
center and high-end cards like tesla and

71
00:03:09,760 --> 00:03:12,080
google

72
00:03:12,080 --> 00:03:15,280
and after you have registered an nvidia

73
00:03:15,280 --> 00:03:17,440
enterprise account you can download the

74
00:03:17,440 --> 00:03:20,159
installer from its application hub

75
00:03:20,159 --> 00:03:22,319
and you should choose suitable installer

76
00:03:22,319 --> 00:03:24,239
for your environment our test

77
00:03:24,239 --> 00:03:26,959
environment is a server with a tesla t4

78
00:03:26,959 --> 00:03:30,560
and operating system is sent to osh

79
00:03:30,560 --> 00:03:32,560
after you downloaded the installers you

80
00:03:32,560 --> 00:03:34,680
can find two different installers with

81
00:03:34,680 --> 00:03:38,400
extension.run the vgpu kvm.run should be

82
00:03:38,400 --> 00:03:40,400
installed in the host machine and the

83
00:03:40,400 --> 00:03:41,760
great

84
00:03:41,760 --> 00:03:43,599
grid.run should be installed in the

85
00:03:43,599 --> 00:03:44,879
guest machine

86
00:03:44,879 --> 00:03:45,840
after

87
00:03:45,840 --> 00:03:47,200
it's installed

88
00:03:47,200 --> 00:03:48,840
they will have a

89
00:03:48,840 --> 00:03:51,840
nvidia.ko in both guest machine and host

90
00:03:51,840 --> 00:03:54,720
machine the installer can be extracted

91
00:03:54,720 --> 00:03:57,280
again and you can find some open source

92
00:03:57,280 --> 00:04:01,239
files in both installers

93
00:04:01,280 --> 00:04:03,760
it's same as other nvidia gear visual

94
00:04:03,760 --> 00:04:07,280
drivers the nvidia dot ko has some open

95
00:04:07,280 --> 00:04:09,840
source files but critical code logics

96
00:04:09,840 --> 00:04:12,720
are close to us and you can search for

97
00:04:12,720 --> 00:04:15,040
dodge all binary files for its closed

98
00:04:15,040 --> 00:04:18,320
source part and other components such as

99
00:04:18,320 --> 00:04:21,399
nvidia vgpu manager and live nvidia

100
00:04:21,399 --> 00:04:24,240
vgpu.so which which is also called as

101
00:04:24,240 --> 00:04:27,280
the vgpu plugin they are both close to

102
00:04:27,280 --> 00:04:29,840
size

103
00:04:31,360 --> 00:04:34,320
and the demon nvidia vgpu manager will

104
00:04:34,320 --> 00:04:37,280
run in the background in the host and it

105
00:04:37,280 --> 00:04:40,720
will spawn itself when a guest

106
00:04:40,720 --> 00:04:43,320
is starting the guest must use uh

107
00:04:43,320 --> 00:04:46,160
gpu-mediated device pass-through mode

108
00:04:46,160 --> 00:04:48,960
the right center figure shows the loop

109
00:04:48,960 --> 00:04:51,199
which view manager will fork itself when

110
00:04:51,199 --> 00:04:52,720
there's a

111
00:04:52,720 --> 00:04:54,639
guest is started

112
00:04:54,639 --> 00:04:57,919
the vgpu plugin is loaded by nvidia vgvu

113
00:04:57,919 --> 00:05:00,240
manager and the plugin plays the main

114
00:05:00,240 --> 00:05:01,360
role

115
00:05:01,360 --> 00:05:03,919
which is responsible with communicating

116
00:05:03,919 --> 00:05:05,440
with the guests

117
00:05:05,440 --> 00:05:08,160
the guests use a mechanism called vrpc

118
00:05:08,160 --> 00:05:11,039
to send requests within the hypervisor

119
00:05:11,039 --> 00:05:15,120
and processed by the lib nvidia vgpu.so

120
00:05:15,120 --> 00:05:18,320
and as you can see the main logic stays

121
00:05:18,320 --> 00:05:19,840
in the plugin so

122
00:05:19,840 --> 00:05:22,240
here we will take a closer look at the

123
00:05:22,240 --> 00:05:24,880
plugin

124
00:05:24,880 --> 00:05:28,080
the vgpu plugin receives and processes

125
00:05:28,080 --> 00:05:30,639
vgpu requests whenever there are some

126
00:05:30,639 --> 00:05:32,880
new data in the rim buffer it will take

127
00:05:32,880 --> 00:05:35,039
the data out and check if it's a legal

128
00:05:35,039 --> 00:05:36,639
vrpc message

129
00:05:36,639 --> 00:05:39,600
the vrpc message is limited to a maximum

130
00:05:39,600 --> 00:05:42,160
4 kilobytes and the vrpc message can be

131
00:05:42,160 --> 00:05:45,680
very frequently sent so it is using a

132
00:05:45,680 --> 00:05:47,520
global area to

133
00:05:47,520 --> 00:05:49,520
store the vrpc message

134
00:05:49,520 --> 00:05:51,919
if the vrpc message is legal it will

135
00:05:51,919 --> 00:05:54,560
call the handler for vrpc message

136
00:05:54,560 --> 00:05:56,319
and the function names are all

137
00:05:56,319 --> 00:05:59,680
obfuscated and shows in six digit

138
00:05:59,680 --> 00:06:02,720
numbers between mv and vgpu and you can

139
00:06:02,720 --> 00:06:04,720
find the log stream which view message

140
00:06:04,720 --> 00:06:07,600
signature mismatch to locators

141
00:06:07,600 --> 00:06:09,680
to locate the color of the message

142
00:06:09,680 --> 00:06:12,479
handler function

143
00:06:12,560 --> 00:06:15,919
and here we have a simplified model and

144
00:06:15,919 --> 00:06:18,240
honestly you don't need to focus on most

145
00:06:18,240 --> 00:06:20,560
part of this picture all we need to know

146
00:06:20,560 --> 00:06:23,759
is the nvidia dot ko in the guest sends

147
00:06:23,759 --> 00:06:26,639
the vrvc message the vlp message is

148
00:06:26,639 --> 00:06:29,039
processed by the plugin in the daemon

149
00:06:29,039 --> 00:06:31,600
process nvidia vgpu manager and the

150
00:06:31,600 --> 00:06:34,880
nvidia vgv manager will communicate with

151
00:06:34,880 --> 00:06:38,000
the nvidia dot ko on host and all of

152
00:06:38,000 --> 00:06:40,800
this is enough

153
00:06:41,520 --> 00:06:44,560
here's also a table listed the structure

154
00:06:44,560 --> 00:06:47,680
of vrpc message the vrpc message is

155
00:06:47,680 --> 00:06:50,560
consisted with a 32 bytes header and the

156
00:06:50,560 --> 00:06:52,960
rest is the message body you can treat

157
00:06:52,960 --> 00:06:55,360
the message as an array of little ending

158
00:06:55,360 --> 00:06:57,440
unsigned integer

159
00:06:57,440 --> 00:06:59,840
normally you will only care about the

160
00:06:59,840 --> 00:07:02,160
package size and vrpc command number

161
00:07:02,160 --> 00:07:05,280
sections in the header

162
00:07:06,720 --> 00:07:10,000
first let's put the vrpc message sender

163
00:07:10,000 --> 00:07:12,240
aside i will introduce later after

164
00:07:12,240 --> 00:07:14,720
receiving the message the vgpu manager

165
00:07:14,720 --> 00:07:16,960
running on host machine will try to

166
00:07:16,960 --> 00:07:19,039
check whether the message is legal

167
00:07:19,039 --> 00:07:21,759
because vgpu manager uses messages in

168
00:07:21,759 --> 00:07:24,880
this way on both windows and linux and

169
00:07:24,880 --> 00:07:27,599
some messages are system specific it

170
00:07:27,599 --> 00:07:30,080
will block some wrong messages at this

171
00:07:30,080 --> 00:07:31,440
step

172
00:07:31,440 --> 00:07:34,080
the wrong messages is such as some

173
00:07:34,080 --> 00:07:37,759
unsupported message sent by the windows

174
00:07:37,759 --> 00:07:39,599
windows client

175
00:07:39,599 --> 00:07:42,080
from the guest to the linux host and

176
00:07:42,080 --> 00:07:45,599
after the check is over it will call the

177
00:07:45,599 --> 00:07:47,360
corresponding handler according to the

178
00:07:47,360 --> 00:07:50,080
message number if any error occurs in

179
00:07:50,080 --> 00:07:52,240
the handler an error reporting function

180
00:07:52,240 --> 00:07:54,800
will generate an error message if no

181
00:07:54,800 --> 00:07:57,759
error occurs it will copy the vrpc

182
00:07:57,759 --> 00:08:01,039
message body which is stored in the host

183
00:08:01,039 --> 00:08:01,919
before

184
00:08:01,919 --> 00:08:05,199
back to the guest machine and during the

185
00:08:05,199 --> 00:08:07,039
message processing the content of the

186
00:08:07,039 --> 00:08:09,360
rpc message body stored in the host may

187
00:08:09,360 --> 00:08:12,360
change

188
00:08:12,720 --> 00:08:15,120
and do you remember the error handling

189
00:08:15,120 --> 00:08:17,840
we have mentioned earlier and it will

190
00:08:17,840 --> 00:08:20,000
generate different error messages for

191
00:08:20,000 --> 00:08:20,960
different

192
00:08:20,960 --> 00:08:23,759
for for each rpc message before the

193
00:08:23,759 --> 00:08:26,080
function returns and this is an

194
00:08:26,080 --> 00:08:28,319
interesting step you can see there's

195
00:08:28,319 --> 00:08:31,199
also a big switch case

196
00:08:31,199 --> 00:08:33,760
in the error handler so

197
00:08:33,760 --> 00:08:36,080
as a security researcher we may also

198
00:08:36,080 --> 00:08:39,680
want to test this function

199
00:08:39,760 --> 00:08:42,320
until the mystery of this function is

200
00:08:42,320 --> 00:08:44,800
discovered uh the

201
00:08:44,800 --> 00:08:47,440
meaning of the vrpc messages has never

202
00:08:47,440 --> 00:08:50,880
been known by myself so after carefully

203
00:08:50,880 --> 00:08:53,440
analyzing its code we were surprised to

204
00:08:53,440 --> 00:08:56,000
find a lot of information this error

205
00:08:56,000 --> 00:08:57,920
handling function saves the meaning of

206
00:08:57,920 --> 00:08:59,920
each message and each field

207
00:08:59,920 --> 00:09:00,720
in

208
00:09:00,720 --> 00:09:03,519
in this way we can more easily find from

209
00:09:03,519 --> 00:09:06,080
the message name which

210
00:09:06,080 --> 00:09:07,839
the rpc message name

211
00:09:07,839 --> 00:09:10,160
which operations look more dangerous and

212
00:09:10,160 --> 00:09:12,560
more likely to have vulnerabilities

213
00:09:12,560 --> 00:09:14,880
for example the top center figure shows

214
00:09:14,880 --> 00:09:18,320
o x 17 rbc message is named rbc unlock

215
00:09:18,320 --> 00:09:20,800
event and we know it is allocating

216
00:09:20,800 --> 00:09:23,440
something and it has three members each

217
00:09:23,440 --> 00:09:26,800
kind for body offset zero h object for

218
00:09:26,800 --> 00:09:28,320
for body

219
00:09:28,320 --> 00:09:31,839
index one and notifying this for body uh

220
00:09:31,839 --> 00:09:33,360
index two

221
00:09:33,360 --> 00:09:35,200
and in addition to get a lot of

222
00:09:35,200 --> 00:09:37,120
information from this function we are

223
00:09:37,120 --> 00:09:39,680
also very interested in the switch case

224
00:09:39,680 --> 00:09:41,440
that comes with it

225
00:09:41,440 --> 00:09:43,600
from the perspective of developers

226
00:09:43,600 --> 00:09:46,160
because the complexity of search case

227
00:09:46,160 --> 00:09:48,720
even if the company has a code review

228
00:09:48,720 --> 00:09:51,440
experts may not be able to review the

229
00:09:51,440 --> 00:09:55,279
all the details of all branches so after

230
00:09:55,279 --> 00:09:58,000
we have marked the pseudo code generated

231
00:09:58,000 --> 00:10:01,680
by ada we copied it into the ide and the

232
00:10:01,680 --> 00:10:03,600
meta meta father

233
00:10:03,600 --> 00:10:06,720
so in short our father skips the message

234
00:10:06,720 --> 00:10:09,040
processing parts but directly calls the

235
00:10:09,040 --> 00:10:11,920
error handling function the input sample

236
00:10:11,920 --> 00:10:14,480
of father is the vrpc message generated

237
00:10:14,480 --> 00:10:17,440
by file engine so we use further to

238
00:10:17,440 --> 00:10:18,880
check whether the error handling

239
00:10:18,880 --> 00:10:21,360
function can handle various errors

240
00:10:21,360 --> 00:10:22,560
correctly

241
00:10:22,560 --> 00:10:25,440
and further did find a signature v but

242
00:10:25,440 --> 00:10:28,160
this problem has been fixed in a newer

243
00:10:28,160 --> 00:10:30,640
version but anyway it brings a lot of

244
00:10:30,640 --> 00:10:33,680
communism for the follow up an analysis

245
00:10:33,680 --> 00:10:37,359
in this obfuscated binary

246
00:10:37,440 --> 00:10:40,000
and here i have listed six important

247
00:10:40,000 --> 00:10:42,399
vrpc messages they will be introduced

248
00:10:42,399 --> 00:10:44,880
later as you can see there are many

249
00:10:44,880 --> 00:10:47,440
messages except each client and edge

250
00:10:47,440 --> 00:10:49,680
device these two handles are very

251
00:10:49,680 --> 00:10:52,160
important among the cores although they

252
00:10:52,160 --> 00:10:54,800
are called handles the values are not as

253
00:10:54,800 --> 00:10:56,560
random as you might think on the

254
00:10:56,560 --> 00:10:59,519
contrary we can specify almost any

255
00:10:59,519 --> 00:11:02,079
integer as a handle so let's start from

256
00:11:02,079 --> 00:11:05,839
reading the rbc message handler

257
00:11:06,480 --> 00:11:08,959
we have mentioned how to locate its

258
00:11:08,959 --> 00:11:11,519
outer function earlier so here's another

259
00:11:11,519 --> 00:11:13,360
string you can use to locate in the

260
00:11:13,360 --> 00:11:15,839
middle of the handler you can see here

261
00:11:15,839 --> 00:11:16,800
also

262
00:11:16,800 --> 00:11:19,440
many things to ensure that the handler

263
00:11:19,440 --> 00:11:23,040
and the message is correct

264
00:11:23,120 --> 00:11:25,360
and some lines below the check you can

265
00:11:25,360 --> 00:11:27,519
see there's a big switch case the

266
00:11:27,519 --> 00:11:29,839
variable it is switching case is vgpu

267
00:11:29,839 --> 00:11:31,680
message which is a message number from

268
00:11:31,680 --> 00:11:34,560
the vrpc header you can see the function

269
00:11:34,560 --> 00:11:37,040
table is a big array stores the pointers

270
00:11:37,040 --> 00:11:39,440
to different handlers

271
00:11:39,440 --> 00:11:41,519
the easiest way to get the function

272
00:11:41,519 --> 00:11:43,600
table is of course

273
00:11:43,600 --> 00:11:45,920
set a breakpoint here and grab them all

274
00:11:45,920 --> 00:11:49,120
the handlers are fixed and so once you

275
00:11:49,120 --> 00:11:51,360
calculated all the handlers you are okay

276
00:11:51,360 --> 00:11:53,040
to do the further

277
00:11:53,040 --> 00:11:55,600
static analysis for each handler

278
00:11:55,600 --> 00:11:57,600
the second argument to the handler is

279
00:11:57,600 --> 00:12:00,160
the vrpc message buffer let's remember

280
00:12:00,160 --> 00:12:04,320
this information and start to find our

281
00:12:04,320 --> 00:12:06,560
box

282
00:12:06,560 --> 00:12:09,040
so we already know how messages are

283
00:12:09,040 --> 00:12:10,399
stored in the host

284
00:12:10,399 --> 00:12:12,880
and now how do we send vrpc message from

285
00:12:12,880 --> 00:12:15,680
the guest since the detail of how the

286
00:12:15,680 --> 00:12:17,920
guests will send a message are not what

287
00:12:17,920 --> 00:12:20,320
we care about in our earlier stage of

288
00:12:20,320 --> 00:12:22,959
reverse engineering in order to avoid

289
00:12:22,959 --> 00:12:25,639
the complexity we decided to patch

290
00:12:25,639 --> 00:12:29,120
nvidia.ko of the guest machine and this

291
00:12:29,120 --> 00:12:31,920
means we will reuse its code but with a

292
00:12:31,920 --> 00:12:34,079
patched value to send a custom vrpc

293
00:12:34,079 --> 00:12:36,959
message but how to find a function that

294
00:12:36,959 --> 00:12:39,040
is sending a message we already know

295
00:12:39,040 --> 00:12:41,519
that the vrpc message consists of a

296
00:12:41,519 --> 00:12:44,720
signature vrpc in this header plus other

297
00:12:44,720 --> 00:12:47,040
fields by analyzing the nvidia manager

298
00:12:47,040 --> 00:12:49,519
on the host machine but if you search

299
00:12:49,519 --> 00:12:52,320
for screen vrpc in the guest driver you

300
00:12:52,320 --> 00:12:55,040
may not get any useful information

301
00:12:55,040 --> 00:12:57,519
however if you if we search for integer

302
00:12:57,519 --> 00:13:00,639
cprv which is a little ending byte order

303
00:13:00,639 --> 00:13:01,600
we can

304
00:13:01,600 --> 00:13:04,000
locate a function whose content matches

305
00:13:04,000 --> 00:13:06,639
our known information very well by

306
00:13:06,639 --> 00:13:08,959
checking its reference we can confirm

307
00:13:08,959 --> 00:13:10,880
that this function is initializing our

308
00:13:10,880 --> 00:13:13,360
vrbc message header and the second

309
00:13:13,360 --> 00:13:15,760
parameter is used to control the rbc

310
00:13:15,760 --> 00:13:17,680
message number the third parameter is

311
00:13:17,680 --> 00:13:21,839
used to indicate the required size

312
00:13:22,000 --> 00:13:24,079
as you can see this size will be added

313
00:13:24,079 --> 00:13:27,040
with header size which is 32 bytes to

314
00:13:27,040 --> 00:13:30,000
fill in the message so remember don't

315
00:13:30,000 --> 00:13:33,200
set it too close to four kilobytes the

316
00:13:33,200 --> 00:13:35,760
size the size section so

317
00:13:35,760 --> 00:13:39,199
that is to prevent the message uh from

318
00:13:39,199 --> 00:13:43,920
failing the immediate managers uh check

319
00:13:44,800 --> 00:13:47,199
and uh interestingly we found that there

320
00:13:47,199 --> 00:13:49,839
are two functions that always appear in

321
00:13:49,839 --> 00:13:53,279
peers and so based on intuition we can

322
00:13:53,279 --> 00:13:55,360
also guess that the second function is

323
00:13:55,360 --> 00:13:58,240
used to send a vrpc message the picture

324
00:13:58,240 --> 00:14:00,399
on the right shows the renamed functions

325
00:14:00,399 --> 00:14:02,720
the code in between two functions is

326
00:14:02,720 --> 00:14:05,199
obviously filling the vrpc body with

327
00:14:05,199 --> 00:14:06,800
specific values

328
00:14:06,800 --> 00:14:11,440
and here a2 plus 608 plus 32 represents

329
00:14:11,440 --> 00:14:14,880
data field of vrpc body with index 0 and

330
00:14:14,880 --> 00:14:18,399
36 means data field of body in this one

331
00:14:18,399 --> 00:14:20,880
and so on

332
00:14:21,040 --> 00:14:23,360
after sending the message send the vrpc

333
00:14:23,360 --> 00:14:25,519
message will wait for the host to return

334
00:14:25,519 --> 00:14:27,920
the result so

335
00:14:27,920 --> 00:14:30,079
after doing that we can also use this

336
00:14:30,079 --> 00:14:32,639
code logic to obtain its return value

337
00:14:32,639 --> 00:14:34,399
the reading of the return value is the

338
00:14:34,399 --> 00:14:37,199
same as we are writing the vrpc message

339
00:14:37,199 --> 00:14:40,240
body so you can just read the data from

340
00:14:40,240 --> 00:14:42,160
the a3 plus

341
00:14:42,160 --> 00:14:45,360
608 cluster offsets the question is

342
00:14:45,360 --> 00:14:47,519
which function should we choose to patch

343
00:14:47,519 --> 00:14:49,760
to find the answer we set a breakpoint

344
00:14:49,760 --> 00:14:52,320
on the vrpc initialization function and

345
00:14:52,320 --> 00:14:57,240
then we found a function called mv0777rm

346
00:14:57,440 --> 00:15:00,240
which is very lucky number and it will

347
00:15:00,240 --> 00:15:02,480
be called every time the guest driver is

348
00:15:02,480 --> 00:15:05,279
loaded and however it should be noticed

349
00:15:05,279 --> 00:15:07,920
that while nvidia is updating the driver

350
00:15:07,920 --> 00:15:11,600
the standards of skated name may change

351
00:15:11,600 --> 00:15:14,399
from our observation this number may

352
00:15:14,399 --> 00:15:17,440
become larger in the newer versions so

353
00:15:17,440 --> 00:15:20,000
when we wrote this slide it has already

354
00:15:20,000 --> 00:15:20,959
gone

355
00:15:20,959 --> 00:15:24,800
increased to 779

356
00:15:25,279 --> 00:15:27,920
and on the other side there's also a

357
00:15:27,920 --> 00:15:30,480
file named nvidia.ko in the house kernel

358
00:15:30,480 --> 00:15:33,040
which confuses us at first and

359
00:15:33,040 --> 00:15:36,160
fortunately we quickly figured out its

360
00:15:36,160 --> 00:15:39,279
relationship with nvidia.ko in the guest

361
00:15:39,279 --> 00:15:42,240
machine and in addition because part of

362
00:15:42,240 --> 00:15:44,880
its code is open source so it can also

363
00:15:44,880 --> 00:15:47,360
help us understand an important process

364
00:15:47,360 --> 00:15:49,360
either which is the meaning of

365
00:15:49,360 --> 00:15:53,040
parameters when is entering rmio control

366
00:15:53,040 --> 00:15:55,759
if you have audited nvidia vgpu manager

367
00:15:55,759 --> 00:15:57,680
you may find that

368
00:15:57,680 --> 00:15:58,399
the

369
00:15:58,399 --> 00:16:01,680
the almost every io control sent by vgpu

370
00:16:01,680 --> 00:16:05,040
manager will get into io control so this

371
00:16:05,040 --> 00:16:08,240
also explains why rmi control is not

372
00:16:08,240 --> 00:16:11,120
open sourced by nvidia because it is

373
00:16:11,120 --> 00:16:15,279
strongly related with the vgpu logic

374
00:16:15,279 --> 00:16:17,120
according to the code comments we can

375
00:16:17,120 --> 00:16:20,839
also know that rm stands for resource

376
00:16:20,839 --> 00:16:23,440
manager the figure on the right is a

377
00:16:23,440 --> 00:16:25,440
function that you will often see when

378
00:16:25,440 --> 00:16:29,040
auditing the vgp plugin i named it

379
00:16:29,040 --> 00:16:31,759
according to its log as mvrm control

380
00:16:31,759 --> 00:16:33,440
which is the main entry point for

381
00:16:33,440 --> 00:16:34,560
sending

382
00:16:34,560 --> 00:16:37,600
rmi control from host user space the

383
00:16:37,600 --> 00:16:40,240
data used to send is usually a structure

384
00:16:40,240 --> 00:16:43,040
allocated on the stack its last three

385
00:16:43,040 --> 00:16:46,160
parameters are usually command data and

386
00:16:46,160 --> 00:16:48,880
size and you can use the ioc size or

387
00:16:48,880 --> 00:16:51,440
iocnr macro to pass them as here shown

388
00:16:51,440 --> 00:16:54,160
in the bottom left to get their original

389
00:16:54,160 --> 00:16:55,519
definitions

390
00:16:55,519 --> 00:16:58,160
however the size used in the manager may

391
00:16:58,160 --> 00:17:00,320
be different from actual definition so

392
00:17:00,320 --> 00:17:05,039
it's just for your references only

393
00:17:05,039 --> 00:17:08,319
and next when we're trying to exploit

394
00:17:08,319 --> 00:17:11,119
some vulnerabilities so we are also very

395
00:17:11,119 --> 00:17:13,679
surprised to find that its main program

396
00:17:13,679 --> 00:17:17,280
did not enable the aslr i guess it is

397
00:17:17,280 --> 00:17:20,079
because um that it needs to be

398
00:17:20,079 --> 00:17:22,000
compatible with other logic in some

399
00:17:22,000 --> 00:17:24,240
drivers at the same time it is not

400
00:17:24,240 --> 00:17:26,640
protected by stat cannery two so

401
00:17:26,640 --> 00:17:30,000
therefore uh except for the address of

402
00:17:30,000 --> 00:17:32,480
dot s or libraries it loads which have a

403
00:17:32,480 --> 00:17:35,120
certain degree of randomnesses but the

404
00:17:35,120 --> 00:17:37,600
vgp manager itself does not enable the

405
00:17:37,600 --> 00:17:42,000
slr so this make it easier to exploit uh

406
00:17:42,000 --> 00:17:43,919
those vulnerabilities

407
00:17:43,919 --> 00:17:44,720
and

408
00:17:44,720 --> 00:17:47,760
let's take a look at its startup process

409
00:17:47,760 --> 00:17:49,919
the main program runs in the form of a

410
00:17:49,919 --> 00:17:52,480
daemon and the child process is spawned

411
00:17:52,480 --> 00:17:54,640
by the main process through fork when

412
00:17:54,640 --> 00:17:56,880
the hypervisor is started

413
00:17:56,880 --> 00:17:59,280
so every time the child process starts

414
00:17:59,280 --> 00:18:01,360
the memory layout of child process is

415
00:18:01,360 --> 00:18:04,320
the same as main process and the crash

416
00:18:04,320 --> 00:18:06,480
of child process will not affect the

417
00:18:06,480 --> 00:18:08,720
main process at all if the hypervisor

418
00:18:08,720 --> 00:18:11,840
process restarts the child process will

419
00:18:11,840 --> 00:18:13,200
also restart

420
00:18:13,200 --> 00:18:15,360
and although immediately gpu manager is

421
00:18:15,360 --> 00:18:19,039
multi-threaded if we use a guest in the

422
00:18:19,039 --> 00:18:22,720
simplest text mode it will behave like a

423
00:18:22,720 --> 00:18:25,200
single threaded process

424
00:18:25,200 --> 00:18:27,360
that is because the text mode guest

425
00:18:27,360 --> 00:18:29,760
sends almost no requests to the vgp

426
00:18:29,760 --> 00:18:32,240
plugin so no matter how many times the

427
00:18:32,240 --> 00:18:34,720
client's vgp manager is restarted its

428
00:18:34,720 --> 00:18:36,799
memory layout will almost

429
00:18:36,799 --> 00:18:39,200
stay the same every time which also

430
00:18:39,200 --> 00:18:41,120
provides communities for us to make

431
00:18:41,120 --> 00:18:43,840
multiple attempts

432
00:18:44,320 --> 00:18:46,720
and although the main process does not

433
00:18:46,720 --> 00:18:48,480
have slr

434
00:18:48,480 --> 00:18:51,280
the main process also has only a few

435
00:18:51,280 --> 00:18:53,760
functions therefore we still need to pay

436
00:18:53,760 --> 00:18:56,000
attention to the more feature-rich and

437
00:18:56,000 --> 00:18:59,280
more concentrated vgp plug-in

438
00:18:59,280 --> 00:19:02,160
by the plug-in it is address randomized

439
00:19:02,160 --> 00:19:04,480
so we also need to find a way to bypass

440
00:19:04,480 --> 00:19:07,360
the slr the vulnerability of information

441
00:19:07,360 --> 00:19:10,000
disclosure will be our first choice but

442
00:19:10,000 --> 00:19:12,559
it is obvious that the amount of reverse

443
00:19:12,559 --> 00:19:14,559
engineering is too much for us

444
00:19:14,559 --> 00:19:16,160
and

445
00:19:16,160 --> 00:19:18,960
at this point my analysis has been going

446
00:19:18,960 --> 00:19:21,360
for some time and i have marked almost

447
00:19:21,360 --> 00:19:24,640
70 percent of key functions

448
00:19:24,640 --> 00:19:27,440
of the vgpu plugin in ada and centered

449
00:19:27,440 --> 00:19:30,240
on the message handler function

450
00:19:30,240 --> 00:19:32,559
therefore it is better to directly

451
00:19:32,559 --> 00:19:34,720
generate dossier files through eda

452
00:19:34,720 --> 00:19:36,960
pretending to audit an open source

453
00:19:36,960 --> 00:19:40,160
software we first tried to use static

454
00:19:40,160 --> 00:19:42,960
code analysis tool to do this work

455
00:19:42,960 --> 00:19:45,440
but the result was not very good

456
00:19:45,440 --> 00:19:48,640
so let's rethink about it if we want to

457
00:19:48,640 --> 00:19:51,280
get the leak data we needed to put the

458
00:19:51,280 --> 00:19:53,440
liquid value in our vrpc message and

459
00:19:53,440 --> 00:19:55,120
then return to the guest

460
00:19:55,120 --> 00:19:57,919
this writing process requires

461
00:19:57,919 --> 00:19:58,960
is to

462
00:19:58,960 --> 00:20:02,159
operate on a keyword operation

463
00:20:02,159 --> 00:20:05,120
because the address of a 64-bit program

464
00:20:05,120 --> 00:20:08,080
is equivalent to a keyword so i try to

465
00:20:08,080 --> 00:20:10,400
search the code where the vrpc body is

466
00:20:10,400 --> 00:20:12,960
on the left side of the assignment which

467
00:20:12,960 --> 00:20:15,760
is the equal mark and they're operating

468
00:20:15,760 --> 00:20:17,760
on keyword

469
00:20:17,760 --> 00:20:21,120
or keyword as the risk or void as risk

470
00:20:21,120 --> 00:20:23,840
and soon we located three places but

471
00:20:23,840 --> 00:20:26,480
only this one in the figure below miss

472
00:20:26,480 --> 00:20:28,720
our requirement

473
00:20:28,720 --> 00:20:31,280
and let's take a look here in detail and

474
00:20:31,280 --> 00:20:35,360
this code belongs to message ox35 rbc

475
00:20:35,360 --> 00:20:39,360
updated pd2 and at the top if the vrpc

476
00:20:39,360 --> 00:20:41,840
body data we passed in has a value it

477
00:20:41,840 --> 00:20:44,400
will write the address of its own local

478
00:20:44,400 --> 00:20:46,400
variable into the corresponding position

479
00:20:46,400 --> 00:20:48,559
of vrpc message body

480
00:20:48,559 --> 00:20:51,120
then if it passes nvm control

481
00:20:51,120 --> 00:20:53,679
successfully that is io control does not

482
00:20:53,679 --> 00:20:55,600
written an error the message handler

483
00:20:55,600 --> 00:20:59,200
will return successfully as afterwards

484
00:20:59,200 --> 00:21:01,520
and this stack pointer will remain in

485
00:21:01,520 --> 00:21:04,080
the vrpc body and return to the guest

486
00:21:04,080 --> 00:21:06,320
this is a perfect information leak

487
00:21:06,320 --> 00:21:08,960
because assuming that the client's vgpu

488
00:21:08,960 --> 00:21:11,280
manager is like a single thread

489
00:21:11,280 --> 00:21:13,360
it means that the stack pointer it

490
00:21:13,360 --> 00:21:15,679
returns here will always have same

491
00:21:15,679 --> 00:21:18,559
offset relatively to the start of the

492
00:21:18,559 --> 00:21:20,559
stack area

493
00:21:20,559 --> 00:21:22,799
but we have some trouble when we are

494
00:21:22,799 --> 00:21:24,960
debugging it the out control fails every

495
00:21:24,960 --> 00:21:28,640
time and this structure is as big as

496
00:21:28,640 --> 00:21:31,760
16 by its data obviously uh brute

497
00:21:31,760 --> 00:21:33,280
forcing is

498
00:21:33,280 --> 00:21:36,080
pretty sorry obviously uh brute forcing

499
00:21:36,080 --> 00:21:38,720
it is unreasonable so we use that gdp

500
00:21:38,720 --> 00:21:42,000
script to fuse it and finally we made it

501
00:21:42,000 --> 00:21:45,280
return successfully

502
00:21:45,280 --> 00:21:48,720
and compares to brutal forcing of 164

503
00:21:48,720 --> 00:21:50,960
bytes it's better to use a little

504
00:21:50,960 --> 00:21:53,200
randomization during the funding and

505
00:21:53,200 --> 00:21:55,520
through the messages

506
00:21:55,520 --> 00:21:58,559
ox2 and aux turning we can create to

507
00:21:58,559 --> 00:22:00,880
handle the value is manually specified

508
00:22:00,880 --> 00:22:03,760
by us and we know that these two handles

509
00:22:03,760 --> 00:22:06,159
is often used by message handlers so

510
00:22:06,159 --> 00:22:08,799
after we created these two handles we

511
00:22:08,799 --> 00:22:12,080
wrote a huge loop in the gdp script the

512
00:22:12,080 --> 00:22:13,520
loop script

513
00:22:13,520 --> 00:22:15,840
the loop will randomly set the value of

514
00:22:15,840 --> 00:22:18,559
each field from a set of fixed values

515
00:22:18,559 --> 00:22:20,320
such as 0

516
00:22:20,320 --> 00:22:24,240
1 o x 1 0 0 and

517
00:22:24,240 --> 00:22:27,280
o f 7 f ffffs

518
00:22:27,280 --> 00:22:30,720
like this and including those two handle

519
00:22:30,720 --> 00:22:32,559
values

520
00:22:32,559 --> 00:22:35,280
and the loop modifies the value of some

521
00:22:35,280 --> 00:22:37,440
of the variables randomly if there's no

522
00:22:37,440 --> 00:22:39,360
findings after a period of time the

523
00:22:39,360 --> 00:22:41,760
variables are randomized again

524
00:22:41,760 --> 00:22:44,240
we use a fixed pseudo random number

525
00:22:44,240 --> 00:22:46,720
generator so it can be easily reproduced

526
00:22:46,720 --> 00:22:48,880
if we run into any problems

527
00:22:48,880 --> 00:22:52,640
and we finally pass the check

528
00:22:53,520 --> 00:22:56,400
in addition to aslr we also need some

529
00:22:56,400 --> 00:22:58,640
memory corruption to complete the entire

530
00:22:58,640 --> 00:23:00,960
exploit chain when i was auditing the

531
00:23:00,960 --> 00:23:02,960
handler i found several very large

532
00:23:02,960 --> 00:23:05,120
functions each of which has many

533
00:23:05,120 --> 00:23:07,760
thousand lines of code i've always liked

534
00:23:07,760 --> 00:23:10,000
to audit those super large functions

535
00:23:10,000 --> 00:23:12,159
superlative functions always means super

536
00:23:12,159 --> 00:23:15,039
large super big complexity

537
00:23:15,039 --> 00:23:17,120
the code may be good and safe in the

538
00:23:17,120 --> 00:23:19,919
first but after a period of time

539
00:23:19,919 --> 00:23:22,559
the code will change more or less and

540
00:23:22,559 --> 00:23:25,520
maybe is uh to improve code efficiency

541
00:23:25,520 --> 00:23:27,440
or add some features

542
00:23:27,440 --> 00:23:29,280
the problem of large

543
00:23:29,280 --> 00:23:30,240
logical

544
00:23:30,240 --> 00:23:32,799
blocks is then exposed

545
00:23:32,799 --> 00:23:34,880
even with code reviews unit test is

546
00:23:34,880 --> 00:23:36,480
still very difficult for technical

547
00:23:36,480 --> 00:23:38,720
experts or software engineers to analyze

548
00:23:38,720 --> 00:23:41,200
the sample changes in the code to each

549
00:23:41,200 --> 00:23:43,279
branch of this huge function

550
00:23:43,279 --> 00:23:46,400
and the message name of ox1a is dma

551
00:23:46,400 --> 00:23:49,840
control dma has always been a hot spot

552
00:23:49,840 --> 00:23:52,159
for security researchers this is an

553
00:23:52,159 --> 00:23:54,799
operation that crosses the boundary

554
00:23:54,799 --> 00:23:57,679
between the software and hardware it is

555
00:23:57,679 --> 00:23:59,840
definitely an important logic to

556
00:23:59,840 --> 00:24:04,080
analysis even other software such as qmu

557
00:24:04,080 --> 00:24:05,360
and

558
00:24:05,360 --> 00:24:08,320
here is dma plus rpc this is as

559
00:24:08,320 --> 00:24:10,400
conspicuous as a warning sign on the

560
00:24:10,400 --> 00:24:13,600
side of the road there are two very

561
00:24:13,600 --> 00:24:15,600
long callback functions which are used

562
00:24:15,600 --> 00:24:17,279
for data industrialization and

563
00:24:17,279 --> 00:24:20,720
finalization before and after dma and

564
00:24:20,720 --> 00:24:24,159
there is very long if then and send io

565
00:24:24,159 --> 00:24:25,679
control expression in the middle of this

566
00:24:25,679 --> 00:24:28,320
handler you can easily spot it and it's

567
00:24:28,320 --> 00:24:30,320
sending the io control that excuse the

568
00:24:30,320 --> 00:24:32,880
dma request

569
00:24:32,880 --> 00:24:35,440
this handler will call dma control get

570
00:24:35,440 --> 00:24:38,320
parameter size with the dma number

571
00:24:38,320 --> 00:24:41,600
memory lock to allocate a buffer for dma

572
00:24:41,600 --> 00:24:44,640
sizer vary from different dma numbers it

573
00:24:44,640 --> 00:24:47,600
should be mentioned that idea may have

574
00:24:47,600 --> 00:24:49,679
bugs when generating the pseudo code for

575
00:24:49,679 --> 00:24:52,400
this function the return value looks

576
00:24:52,400 --> 00:24:54,720
well looks smaller than correct value

577
00:24:54,720 --> 00:24:57,440
than in in the error so i will i

578
00:24:57,440 --> 00:24:59,919
recommend you to refer to the assembly

579
00:24:59,919 --> 00:25:02,799
code to get the real allocation size i

580
00:25:02,799 --> 00:25:04,960
named the initialization function as

581
00:25:04,960 --> 00:25:07,120
first half processor it will fill the

582
00:25:07,120 --> 00:25:09,600
data according to the dma command and we

583
00:25:09,600 --> 00:25:11,279
have found two vulnerabilities in this

584
00:25:11,279 --> 00:25:14,279
function

585
00:25:14,320 --> 00:25:16,480
let's let's take a look in the first

586
00:25:16,480 --> 00:25:19,279
half processor when the dma commands we

587
00:25:19,279 --> 00:25:23,080
send our osc6370102

588
00:25:23,679 --> 00:25:26,559
i will call them one and o2 for short

589
00:25:26,559 --> 00:25:28,320
the function logic in the first half

590
00:25:28,320 --> 00:25:31,360
processor seem a bit wrong especially

591
00:25:31,360 --> 00:25:34,400
o2 o2's while loop is equivalent to the

592
00:25:34,400 --> 00:25:36,320
memory copy

593
00:25:36,320 --> 00:25:38,480
also the o1 is

594
00:25:38,480 --> 00:25:39,279
is

595
00:25:39,279 --> 00:25:41,520
is also very similar to memory copy but

596
00:25:41,520 --> 00:25:43,760
it will skip some bytes

597
00:25:43,760 --> 00:25:46,080
and you can see neither of these two

598
00:25:46,080 --> 00:25:48,640
cases limited how many bytes to copy

599
00:25:48,640 --> 00:25:51,120
because in the pseudo code edda didn't

600
00:25:51,120 --> 00:25:53,919
put 0 2 into switch case but instead

601
00:25:53,919 --> 00:25:55,919
using a go 2 to jump to his handler so

602
00:25:55,919 --> 00:25:59,200
we didn't saw 02 at our first glance

603
00:25:59,200 --> 00:26:02,159
and so our exploit will use the branch

604
00:26:02,159 --> 00:26:03,120
of

605
00:26:03,120 --> 00:26:06,120
c63701

606
00:26:06,640 --> 00:26:09,120
the branch of o1 will copy data with

607
00:26:09,120 --> 00:26:12,320
host please look at this code

608
00:26:12,320 --> 00:26:14,720
in the bottom left figure it will copy

609
00:26:14,720 --> 00:26:17,200
data to the dma buffer with index 9

610
00:26:17,200 --> 00:26:20,159
multiplies i and then plus 3 to 10. for

611
00:26:20,159 --> 00:26:23,360
example when i is equal to 0 the buffs

612
00:26:23,360 --> 00:26:25,840
in digs 3 to 10 will be filled with

613
00:26:25,840 --> 00:26:29,200
values in the next iteration when i

614
00:26:29,200 --> 00:26:31,679
equals 1 buffs index

615
00:26:31,679 --> 00:26:34,880
12 to 19 will be filled with values

616
00:26:34,880 --> 00:26:37,200
in other words every time each is

617
00:26:37,200 --> 00:26:40,960
turning 4 bytes it will skip 4 bytes

618
00:26:40,960 --> 00:26:45,520
i will call those 4 bytes as host later

619
00:26:46,320 --> 00:26:49,120
and since it is a heap overflow we

620
00:26:49,120 --> 00:26:51,360
should be interested in the data after

621
00:26:51,360 --> 00:26:54,480
the overflowed heap after a flow after a

622
00:26:54,480 --> 00:26:56,240
few hundred bytes we found an

623
00:26:56,240 --> 00:26:59,039
interesting hip trunk the content seems

624
00:26:59,039 --> 00:27:01,200
to be a structure with several points

625
00:27:01,200 --> 00:27:02,480
started

626
00:27:02,480 --> 00:27:04,960
let's attach the vgp manager set an

627
00:27:04,960 --> 00:27:07,200
access breakpoint on this memory trunk

628
00:27:07,200 --> 00:27:09,600
and then resume the program as soon as

629
00:27:09,600 --> 00:27:12,159
the vrpc returned the excess breakpoint

630
00:27:12,159 --> 00:27:14,480
was triggered we found that the caller

631
00:27:14,480 --> 00:27:16,080
is a function located in the main

632
00:27:16,080 --> 00:27:18,880
program but but not a vgb plugin as

633
00:27:18,880 --> 00:27:21,200
shown in the figure blog this function

634
00:27:21,200 --> 00:27:23,200
is comparing an address to the value

635
00:27:23,200 --> 00:27:26,640
stored in this memory trunk

636
00:27:27,039 --> 00:27:29,039
the memory trunk where we set the

637
00:27:29,039 --> 00:27:32,000
breakpoint is a node in a linked list

638
00:27:32,000 --> 00:27:34,159
the code is testing whether the pointer

639
00:27:34,159 --> 00:27:35,919
is the same as the

640
00:27:35,919 --> 00:27:38,240
first item in the linked list if they

641
00:27:38,240 --> 00:27:40,960
are the same it will remove the item

642
00:27:40,960 --> 00:27:43,520
from the linked list after some attempts

643
00:27:43,520 --> 00:27:45,360
we found that in the picture on the

644
00:27:45,360 --> 00:27:48,799
right if v16 is set to zero

645
00:27:48,799 --> 00:27:52,480
then you can pass subroutine 404 beo and

646
00:27:52,480 --> 00:27:55,520
then enter the function set item value i

647
00:27:55,520 --> 00:27:57,600
named this function but the name

648
00:27:57,600 --> 00:28:00,159
somewhat is somewhat ambitious

649
00:28:00,159 --> 00:28:02,559
from the perspective of the attacker

650
00:28:02,559 --> 00:28:04,960
this function is setting the value of a

651
00:28:04,960 --> 00:28:07,200
certain memory block and from the

652
00:28:07,200 --> 00:28:09,520
developer's point of view this function

653
00:28:09,520 --> 00:28:11,840
is used to remove nodes from the linked

654
00:28:11,840 --> 00:28:13,520
list

655
00:28:13,520 --> 00:28:16,240
let's take a close look at the code

656
00:28:16,240 --> 00:28:17,919
logic

657
00:28:17,919 --> 00:28:20,240
and this function and you can see such a

658
00:28:20,240 --> 00:28:22,799
text book like chain removal operation

659
00:28:22,799 --> 00:28:25,039
and as you know the work of removing the

660
00:28:25,039 --> 00:28:26,320
chain will

661
00:28:26,320 --> 00:28:29,120
inevitably modify the proof and the next

662
00:28:29,120 --> 00:28:32,000
value of nodes before and after it

663
00:28:32,000 --> 00:28:34,399
does this operation remind you of the

664
00:28:34,399 --> 00:28:36,960
unlinked operation of mlok in the older

665
00:28:36,960 --> 00:28:38,640
version of labc

666
00:28:38,640 --> 00:28:41,200
we will also use this opportunity to set

667
00:28:41,200 --> 00:28:43,600
the previous and next values in

668
00:28:43,600 --> 00:28:47,199
vulnerability exploitation

669
00:28:47,279 --> 00:28:49,600
okay let's read the code again the

670
00:28:49,600 --> 00:28:52,240
variable p is the memory trunk of load

671
00:28:52,240 --> 00:28:54,240
by us so its value is totally

672
00:28:54,240 --> 00:28:56,640
controllable and moreover

673
00:28:56,640 --> 00:28:59,520
this function will call and map or am on

674
00:28:59,520 --> 00:29:01,440
map according to the value of memory

675
00:29:01,440 --> 00:29:03,120
trunk p after

676
00:29:03,120 --> 00:29:06,159
finishing the link linked list operation

677
00:29:06,159 --> 00:29:10,159
so we can set p pref to map dot got

678
00:29:10,159 --> 00:29:13,520
minus the offset of next field relative

679
00:29:13,520 --> 00:29:15,760
to the beginning of the structure

680
00:29:15,760 --> 00:29:18,960
then set p next to the address of our

681
00:29:18,960 --> 00:29:22,240
first row gadget when we write p next to

682
00:29:22,240 --> 00:29:22,960
p

683
00:29:22,960 --> 00:29:25,919
prep next the god of map will be

684
00:29:25,919 --> 00:29:27,840
overwritten with the address of the

685
00:29:27,840 --> 00:29:29,919
first love gadget

686
00:29:29,919 --> 00:29:32,559
but there's a problem here you can see

687
00:29:32,559 --> 00:29:34,240
it will also set p

688
00:29:34,240 --> 00:29:37,279
next prev to p prep

689
00:29:37,279 --> 00:29:40,399
p next is now the address of the first

690
00:29:40,399 --> 00:29:43,360
row gadget p next to previous just a few

691
00:29:43,360 --> 00:29:46,240
bytes behind the rope gadget this means

692
00:29:46,240 --> 00:29:49,360
if you want to exploit it in this way we

693
00:29:49,360 --> 00:29:51,760
also need the memory trunk of first row

694
00:29:51,760 --> 00:29:53,440
gadget to be readable

695
00:29:53,440 --> 00:29:56,399
of course it's also to be executable but

696
00:29:56,399 --> 00:29:59,679
the rwx memory is rarely seen now so

697
00:29:59,679 --> 00:30:02,559
here it is it leaves us a big question

698
00:30:02,559 --> 00:30:04,799
mark

699
00:30:05,360 --> 00:30:08,720
and to my surprise the program have

700
00:30:08,720 --> 00:30:11,760
many rwx pages and they are all used as

701
00:30:11,760 --> 00:30:14,399
a stack this means that we can put shell

702
00:30:14,399 --> 00:30:16,399
code on the stack and then use a stack

703
00:30:16,399 --> 00:30:18,880
address as the first rope get its

704
00:30:18,880 --> 00:30:21,679
address the first thing came into my

705
00:30:21,679 --> 00:30:24,559
mind was some functions like main they

706
00:30:24,559 --> 00:30:26,480
are called earlier and their stack

707
00:30:26,480 --> 00:30:28,799
frames will remain in the program and

708
00:30:28,799 --> 00:30:31,200
almost don't change therefore i dump the

709
00:30:31,200 --> 00:30:33,200
stack memory and search for the rope

710
00:30:33,200 --> 00:30:35,679
gadgets there are some gadgets but i did

711
00:30:35,679 --> 00:30:38,240
not find any rope gadgets that met my

712
00:30:38,240 --> 00:30:39,679
needs so

713
00:30:39,679 --> 00:30:42,080
now there's only one way that is i need

714
00:30:42,080 --> 00:30:44,240
to find a way to put the rope gadget on

715
00:30:44,240 --> 00:30:47,360
the stack manually

716
00:30:47,360 --> 00:30:48,159
um

717
00:30:48,159 --> 00:30:50,480
one japanese find a function and that

718
00:30:50,480 --> 00:30:53,120
function will use a very super and

719
00:30:53,120 --> 00:30:55,440
unusually large amount of stack space

720
00:30:55,440 --> 00:30:58,000
and it will modify the memory area that

721
00:30:58,000 --> 00:31:01,200
is located very deep in the stack and

722
00:31:01,200 --> 00:31:03,279
when that function x is the stack memory

723
00:31:03,279 --> 00:31:05,120
it applies so for

724
00:31:05,120 --> 00:31:07,200
sorry the stack memory it applies for

725
00:31:07,200 --> 00:31:09,440
will rarely have a chance to be reused

726
00:31:09,440 --> 00:31:11,519
by other functions so my gadget can

727
00:31:11,519 --> 00:31:15,760
leave the leave in the stack in this way

728
00:31:15,840 --> 00:31:18,559
now i only need to search for the dot c

729
00:31:18,559 --> 00:31:21,840
file supported by adapt i used a regular

730
00:31:21,840 --> 00:31:24,000
expression to search who is using a lot

731
00:31:24,000 --> 00:31:27,279
of stack memory i've got some candidates

732
00:31:27,279 --> 00:31:29,440
and after i compare the function among

733
00:31:29,440 --> 00:31:32,159
them i'm sure that the processor of the

734
00:31:32,159 --> 00:31:35,679
message of 3c will be my choice

735
00:31:35,679 --> 00:31:38,399
it takes up about 47 kilobytes of stack

736
00:31:38,399 --> 00:31:40,320
memory please check the snapshot in the

737
00:31:40,320 --> 00:31:42,480
top and also the function is quite

738
00:31:42,480 --> 00:31:44,000
simple

739
00:31:44,000 --> 00:31:46,240
after entering it it will copy the value

740
00:31:46,240 --> 00:31:49,600
from vrpc message body index 6 to stack

741
00:31:49,600 --> 00:31:51,519
variable v55

742
00:31:51,519 --> 00:31:56,360
and v5 is located at rsp plus ox

743
00:31:56,360 --> 00:32:00,080
b88 then it is used to send an our

744
00:32:00,080 --> 00:32:02,720
control if error happens in the out

745
00:32:02,720 --> 00:32:04,559
control it will report an error and adds

746
00:32:04,559 --> 00:32:07,200
it directly this can be a primitive for

747
00:32:07,200 --> 00:32:09,279
placing shell code on a stack it only

748
00:32:09,279 --> 00:32:12,640
does necessary operations and exits with

749
00:32:12,640 --> 00:32:15,039
minimal influence to the overall memory

750
00:32:15,039 --> 00:32:17,440
layout

751
00:32:17,840 --> 00:32:20,000
now we have this primitive to put a

752
00:32:20,000 --> 00:32:22,240
gadget on the stack so how do we combine

753
00:32:22,240 --> 00:32:24,159
this with unlink process

754
00:32:24,159 --> 00:32:26,640
first we write a 4 byte row gadget to

755
00:32:26,640 --> 00:32:29,039
the stack and thanks to the fork you can

756
00:32:29,039 --> 00:32:31,760
treat it as a single threaded program

757
00:32:31,760 --> 00:32:33,600
waiting for external input to do the

758
00:32:33,600 --> 00:32:34,880
task

759
00:32:34,880 --> 00:32:37,760
therefore as long as order of each vrp's

760
00:32:37,760 --> 00:32:40,159
message is not changed the relative

761
00:32:40,159 --> 00:32:42,240
offset of the rope gadget to the

762
00:32:42,240 --> 00:32:44,320
beginning of the stack memory is also

763
00:32:44,320 --> 00:32:45,600
unchanged

764
00:32:45,600 --> 00:32:48,480
and furthermore all objects relative

765
00:32:48,480 --> 00:32:51,120
offset that we will use later our

766
00:32:51,120 --> 00:32:54,159
exploit chain won't change either

767
00:32:54,159 --> 00:32:57,200
so now we can finish the last step which

768
00:32:57,200 --> 00:33:00,720
is assign p pref to p next prep the rope

769
00:33:00,720 --> 00:33:03,760
gadget we used is move r s p rsi then

770
00:33:03,760 --> 00:33:06,799
return the figure in the right talk

771
00:33:06,799 --> 00:33:09,600
explains the reason why i choose to

772
00:33:09,600 --> 00:33:11,840
set the rsi

773
00:33:11,840 --> 00:33:14,559
the rbx in the figure is

774
00:33:14,559 --> 00:33:15,519
memory

775
00:33:15,519 --> 00:33:18,399
is pointing to the memory trunk p so rsi

776
00:33:18,399 --> 00:33:21,600
is got from controllable memory area the

777
00:33:21,600 --> 00:33:24,320
lens parameter of map has type of side

778
00:33:24,320 --> 00:33:26,240
key which is always the same length of a

779
00:33:26,240 --> 00:33:29,120
pointer so we can move a pointer into

780
00:33:29,120 --> 00:33:30,320
the

781
00:33:30,320 --> 00:33:34,000
into this rsi register from p plus h the

782
00:33:34,000 --> 00:33:36,799
pointer points to our fake stack which

783
00:33:36,799 --> 00:33:40,720
are the memory trunks before variable p

784
00:33:40,720 --> 00:33:43,679
and don't forget we already set the map

785
00:33:43,679 --> 00:33:46,480
to this row of gadget one so when mf is

786
00:33:46,480 --> 00:33:49,200
called actually our rope gave it to a

787
00:33:49,200 --> 00:33:51,360
rung so we can complete the stack

788
00:33:51,360 --> 00:33:54,960
private through our roof gadget so

789
00:33:54,960 --> 00:33:58,200
everything now looks fine but because

790
00:33:58,200 --> 00:34:01,039
c63701 will have holes when coping the

791
00:34:01,039 --> 00:34:03,440
data the stack will also carry four

792
00:34:03,440 --> 00:34:06,399
bytes of zeros in many places but

793
00:34:06,399 --> 00:34:08,639
this can be avoided by choosing rubber

794
00:34:08,639 --> 00:34:11,119
gadgets carefully

795
00:34:11,119 --> 00:34:13,280
now let's deal with these holes

796
00:34:13,280 --> 00:34:15,280
regarding this memory hose we can use

797
00:34:15,280 --> 00:34:17,839
those hose clearly when we adjust the

798
00:34:17,839 --> 00:34:20,719
memory layout for example we can treat

799
00:34:20,719 --> 00:34:23,119
them as the number zero or use four

800
00:34:23,119 --> 00:34:26,639
bytes as a higher 32 bits of address

801
00:34:26,639 --> 00:34:27,599
the

802
00:34:27,599 --> 00:34:30,000
main pro that the main manager process

803
00:34:30,000 --> 00:34:32,000
is loaded on address

804
00:34:32,000 --> 00:34:33,040
four

805
00:34:33,040 --> 00:34:36,800
with 5 0's but this is a 64-bit program

806
00:34:36,800 --> 00:34:39,918
so using the four bytes of zeros as part

807
00:34:39,918 --> 00:34:42,639
of memory and address is visible

808
00:34:42,639 --> 00:34:45,040
also we can choose a suitable rope

809
00:34:45,040 --> 00:34:49,760
gadget to either pop it out or skip it

810
00:34:49,760 --> 00:34:52,320
adjusting memory layout with those holes

811
00:34:52,320 --> 00:34:54,480
is a very time consuming step in the

812
00:34:54,480 --> 00:34:58,560
debugging so it needs some patience

813
00:34:58,560 --> 00:35:00,960
and after i figured out the memory

814
00:35:00,960 --> 00:35:03,839
layout and wrote the whole poc now we

815
00:35:03,839 --> 00:35:06,160
need to patch guest kernel driver to

816
00:35:06,160 --> 00:35:07,599
send messages

817
00:35:07,599 --> 00:35:08,560
i

818
00:35:08,560 --> 00:35:11,040
manually patched a large area in the

819
00:35:11,040 --> 00:35:14,240
guest driver in advance so basically all

820
00:35:14,240 --> 00:35:16,640
we need to do now is to split the

821
00:35:16,640 --> 00:35:20,079
bytecode of the plc into many assemblies

822
00:35:20,079 --> 00:35:24,320
to write data into vrpc message buffer

823
00:35:24,320 --> 00:35:27,280
the rax in the figure represents

824
00:35:27,280 --> 00:35:30,320
represents the start address of the vrpc

825
00:35:30,320 --> 00:35:32,800
buffer as you can see this is very

826
00:35:32,800 --> 00:35:35,680
painful i have made a program to help me

827
00:35:35,680 --> 00:35:37,839
to do the most of work

828
00:35:37,839 --> 00:35:39,839
and it can help me to calculate the

829
00:35:39,839 --> 00:35:42,720
offset the value and the barcodes and

830
00:35:42,720 --> 00:35:47,760
generate a patched guest nvidia.ko file

831
00:35:47,760 --> 00:35:49,920
when the patched guest driver is

832
00:35:49,920 --> 00:35:51,920
prepared now it's time to trigger the

833
00:35:51,920 --> 00:35:54,480
vulnerability i have found two different

834
00:35:54,480 --> 00:35:57,119
styles of hypervisors during the test

835
00:35:57,119 --> 00:35:58,880
one is

836
00:35:58,880 --> 00:36:01,200
that the hypervisor does not exit when

837
00:36:01,200 --> 00:36:02,560
the clients

838
00:36:02,560 --> 00:36:06,480
restart the system restarts and the type

839
00:36:06,480 --> 00:36:09,200
two is when the client restarts the

840
00:36:09,200 --> 00:36:11,440
hypervisor also exists

841
00:36:11,440 --> 00:36:13,760
because retrieval manager will also exit

842
00:36:13,760 --> 00:36:16,079
when the hypervisor process answers

843
00:36:16,079 --> 00:36:18,160
therefore i have listed two methods for

844
00:36:18,160 --> 00:36:20,640
trigging the vulnerability

845
00:36:20,640 --> 00:36:21,359
the

846
00:36:21,359 --> 00:36:23,119
the method too

847
00:36:23,119 --> 00:36:25,839
does not require you to reboot the guest

848
00:36:25,839 --> 00:36:27,119
machine

849
00:36:27,119 --> 00:36:28,960
you can choose one of them according to

850
00:36:28,960 --> 00:36:32,000
your environment they are equivalent

851
00:36:32,000 --> 00:36:35,040
to myself i prefer to use the method one

852
00:36:35,040 --> 00:36:38,560
because it takes less steps

853
00:36:39,119 --> 00:36:42,000
and finally we can trigger this

854
00:36:42,000 --> 00:36:43,839
vulnerability from the guest and wrong

855
00:36:43,839 --> 00:36:46,960
archery program in the host machine with

856
00:36:46,960 --> 00:36:50,000
with root privilege the overall success

857
00:36:50,000 --> 00:36:53,760
rate is about 40 to 50

858
00:36:53,760 --> 00:36:56,480
and that's because sometimes the stack

859
00:36:56,480 --> 00:36:58,560
address can move

860
00:36:58,560 --> 00:37:01,040
forward or afterwards a little bit when

861
00:37:01,040 --> 00:37:03,520
vgpu plugin is loaded

862
00:37:03,520 --> 00:37:06,320
but you can restart your guest machine

863
00:37:06,320 --> 00:37:08,960
as many times as you want in a cloud

864
00:37:08,960 --> 00:37:11,599
environment so i think that

865
00:37:11,599 --> 00:37:14,160
doesn't matter

866
00:37:14,160 --> 00:37:17,040
because the time is limited so instead

867
00:37:17,040 --> 00:37:20,000
of a long video here i only put a

868
00:37:20,000 --> 00:37:22,640
snapshot and which is showing the moment

869
00:37:22,640 --> 00:37:23,440
of

870
00:37:23,440 --> 00:37:24,880
calculator is

871
00:37:24,880 --> 00:37:29,200
popped up in our host machine

872
00:37:30,800 --> 00:37:31,599
and

873
00:37:31,599 --> 00:37:34,720
in the end is some security practice in

874
00:37:34,720 --> 00:37:38,079
using the gpu and most important thing

875
00:37:38,079 --> 00:37:41,040
is update your software regularly and

876
00:37:41,040 --> 00:37:43,200
because the nvidia vgpu manager is

877
00:37:43,200 --> 00:37:45,520
running in root so maybe you can use

878
00:37:45,520 --> 00:37:48,560
your firewall to restrict what it can do

879
00:37:48,560 --> 00:37:51,839
or use a host intrusion preparation

880
00:37:51,839 --> 00:37:55,520
system to monitor the process activities

881
00:37:55,520 --> 00:37:58,079
and also administrators should monitor

882
00:37:58,079 --> 00:38:00,480
strange crashes on the host machine and

883
00:38:00,480 --> 00:38:04,160
report report them to nvidia when you

884
00:38:04,160 --> 00:38:07,119
think it is a dangerous crash

885
00:38:07,119 --> 00:38:08,480
and when there's

886
00:38:08,480 --> 00:38:12,800
zero day and some hot fix patches

887
00:38:12,880 --> 00:38:14,400
which you can also call them as

888
00:38:14,400 --> 00:38:16,880
workarounds they could also be applied

889
00:38:16,880 --> 00:38:19,920
for example you can loop some vulnerable

890
00:38:19,920 --> 00:38:22,160
message handlers or functions that are

891
00:38:22,160 --> 00:38:25,839
not frequently used

892
00:38:27,280 --> 00:38:28,400
and

893
00:38:28,400 --> 00:38:31,359
here are some cves that are involved in

894
00:38:31,359 --> 00:38:34,160
this talk and some vulnerabilities are

895
00:38:34,160 --> 00:38:35,680
scheduled to

896
00:38:35,680 --> 00:38:37,440
some other vulnerabilities are scheduled

897
00:38:37,440 --> 00:38:41,440
to be fixed in the end of july and

898
00:38:41,440 --> 00:38:43,359
this talk is recorded earlier so they

899
00:38:43,359 --> 00:38:47,040
are not listed here and due to the

900
00:38:47,040 --> 00:38:49,680
responsible vulnerability disclosure

901
00:38:49,680 --> 00:38:51,359
program so we have

902
00:38:51,359 --> 00:38:54,800
removed some contents from this slide

903
00:38:54,800 --> 00:38:56,880
the deleted contents does not affect the

904
00:38:56,880 --> 00:39:01,200
completeness of the speech and so

905
00:39:01,200 --> 00:39:04,240
please follow the official security uh

906
00:39:04,240 --> 00:39:06,480
bulletin and updating your

907
00:39:06,480 --> 00:39:08,960
product in time if you think your

908
00:39:08,960 --> 00:39:10,480
products are

909
00:39:10,480 --> 00:39:13,480
affected

910
00:39:14,160 --> 00:39:17,200
and that's all and thank you very much

911
00:39:17,200 --> 00:39:21,640
for your listening thank you

