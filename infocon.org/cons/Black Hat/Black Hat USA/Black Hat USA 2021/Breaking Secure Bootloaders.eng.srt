1
00:00:01,130 --> 00:00:14,700
[Music]

2
00:00:17,279 --> 00:00:18,800
hello everyone my name is christopher

3
00:00:18,800 --> 00:00:19,920
wade and today we're going to be talking

4
00:00:19,920 --> 00:00:22,160
about breaking secure boot loaders

5
00:00:22,160 --> 00:00:23,680
the purpose of this talk is to outline

6
00:00:23,680 --> 00:00:25,119
how signature protection mechanisms are

7
00:00:25,119 --> 00:00:26,720
used in smartphones to protect both the

8
00:00:26,720 --> 00:00:28,400
core firmware of the device and its

9
00:00:28,400 --> 00:00:30,320
peripheral hardware this is implemented

10
00:00:30,320 --> 00:00:31,679
at the bootloader level which also

11
00:00:31,679 --> 00:00:34,079
provides facilities for firmware updates

12
00:00:34,079 --> 00:00:35,600
and other management tooling which can

13
00:00:35,600 --> 00:00:37,280
allow you to interface with the device

14
00:00:37,280 --> 00:00:38,559
we're going to be outlining state two

15
00:00:38,559 --> 00:00:40,160
weaknesses in these update protocols in

16
00:00:40,160 --> 00:00:41,520
two different ships which can be used to

17
00:00:41,520 --> 00:00:43,360
exploit uh be exploited to bypass these

18
00:00:43,360 --> 00:00:46,320
signature protection mechanisms

19
00:00:46,320 --> 00:00:47,680
a bit about me before we start my name

20
00:00:47,680 --> 00:00:49,039
is christopher wade i'm a security

21
00:00:49,039 --> 00:00:50,399
consultant at penn test partners where i

22
00:00:50,399 --> 00:00:52,239
mainly work in hardware testing and iot

23
00:00:52,239 --> 00:00:54,000
testing

24
00:00:54,000 --> 00:00:55,520
so the first project we'll be discussing

25
00:00:55,520 --> 00:00:57,680
is my attacks against the qualcomm sgm

26
00:00:57,680 --> 00:01:00,239
660 android bootloader so i purchased an

27
00:01:00,239 --> 00:01:01,680
android smartphone to do some mobile

28
00:01:01,680 --> 00:01:03,440
research with a similar chip to this and

29
00:01:03,440 --> 00:01:04,879
realized i needed root access in order

30
00:01:04,879 --> 00:01:06,720
to use all my testing tools

31
00:01:06,720 --> 00:01:08,240
on this particular device it required

32
00:01:08,240 --> 00:01:09,600
unlocking the bootloader which disabled

33
00:01:09,600 --> 00:01:10,960
signature verification mechanism

34
00:01:10,960 --> 00:01:12,880
mechanisms on the device

35
00:01:12,880 --> 00:01:15,040
but in this case it required an unlock

36
00:01:15,040 --> 00:01:17,840
tool from the manufacturer

37
00:01:17,840 --> 00:01:19,840
so some smartphone manufacturers often

38
00:01:19,840 --> 00:01:21,360
uh modify the bootloader which is

39
00:01:21,360 --> 00:01:23,680
provided by qualcomm and node who add

40
00:01:23,680 --> 00:01:25,040
custom functionality which requires

41
00:01:25,040 --> 00:01:26,240
custom tools from them in order to

42
00:01:26,240 --> 00:01:28,159
unlock their boot loader and other add

43
00:01:28,159 --> 00:01:29,840
other certain features

44
00:01:29,840 --> 00:01:31,759
um or sometimes to remove bootloader

45
00:01:31,759 --> 00:01:34,000
unlocking entirely this often requires

46
00:01:34,000 --> 00:01:34,960
creating a user account on that

47
00:01:34,960 --> 00:01:36,479
manufacturer's website and waiting for a

48
00:01:36,479 --> 00:01:38,079
small period of time such as 7 days to

49
00:01:38,079 --> 00:01:39,360
28 days

50
00:01:39,360 --> 00:01:41,200
a lot of them performed using custom usb

51
00:01:41,200 --> 00:01:42,399
commands which are usually done via

52
00:01:42,399 --> 00:01:44,399
fastboot on qualcomm devices and there

53
00:01:44,399 --> 00:01:45,759
are a good few reasons why they would do

54
00:01:45,759 --> 00:01:47,360
this the first one is to prevent

55
00:01:47,360 --> 00:01:49,200
inexperienced users from being tricked

56
00:01:49,200 --> 00:01:50,399
into deliberately weaken their phone

57
00:01:50,399 --> 00:01:52,720
security or to stop third parties from

58
00:01:52,720 --> 00:01:54,560
deploying malicious software to devices

59
00:01:54,560 --> 00:01:56,320
before sending them out to users

60
00:01:56,320 --> 00:01:57,920
and lastly of course manufacturers can

61
00:01:57,920 --> 00:01:59,439
track who is unlocking their bootloaders

62
00:01:59,439 --> 00:02:00,799
in order to see what kind of research is

63
00:02:00,799 --> 00:02:03,119
being done

64
00:02:03,119 --> 00:02:04,719
so on the particular device i was

65
00:02:04,719 --> 00:02:06,640
looking at i managed to um analyze a

66
00:02:06,640 --> 00:02:08,160
bootloader unlock so i waited the seven

67
00:02:08,160 --> 00:02:10,239
days and decided to see what the

68
00:02:10,239 --> 00:02:11,840
functionality was of the custom tool

69
00:02:11,840 --> 00:02:14,239
that's provided by the manufacturer

70
00:02:14,239 --> 00:02:18,080
using the usb keypad usb pcapp usb

71
00:02:18,080 --> 00:02:20,080
library i could analyze all of the data

72
00:02:20,080 --> 00:02:21,599
going back and forth from the usb host

73
00:02:21,599 --> 00:02:23,440
of the usb device and found that during

74
00:02:23,440 --> 00:02:25,680
the unlock process it would send a 256

75
00:02:25,680 --> 00:02:27,360
byte signature which was downloaded from

76
00:02:27,360 --> 00:02:28,800
the manufacturer's servers and sent to

77
00:02:28,800 --> 00:02:30,640
the phone using a small bit of data that

78
00:02:30,640 --> 00:02:33,120
was sent from the phone to the server

79
00:02:33,120 --> 00:02:34,480
this is verified by the bootloader which

80
00:02:34,480 --> 00:02:36,319
then unlocked the locking restrictions

81
00:02:36,319 --> 00:02:37,680
and allowed you to root the device as

82
00:02:37,680 --> 00:02:39,760
needed i found this quite interesting so

83
00:02:39,760 --> 00:02:41,120
i decided to use an older phone of mine

84
00:02:41,120 --> 00:02:42,560
which by the same manufacturer in order

85
00:02:42,560 --> 00:02:44,720
to analyze this functionality i also set

86
00:02:44,720 --> 00:02:46,080
myself a personal talent to try and

87
00:02:46,080 --> 00:02:47,760
break this functionality on this new

88
00:02:47,760 --> 00:02:49,120
phone before the seven day waiting

89
00:02:49,120 --> 00:02:51,120
period

90
00:02:51,120 --> 00:02:53,040
the device i was uh looking into was a

91
00:02:53,040 --> 00:02:54,879
mid-range phone released in 2017 which

92
00:02:54,879 --> 00:02:57,280
used the qualcomm snapdragon 660 chipset

93
00:02:57,280 --> 00:02:59,280
which is an arm 64 architect chips

94
00:02:59,280 --> 00:03:01,599
that's quite common in smartphones

95
00:03:01,599 --> 00:03:03,120
i prefixed they unlocked the bootloader

96
00:03:03,120 --> 00:03:04,159
on this particular phone for the same

97
00:03:04,159 --> 00:03:05,599
kinds of research but found that i could

98
00:03:05,599 --> 00:03:06,800
look at it again quite easily for this

99
00:03:06,800 --> 00:03:08,720
project using fastboot

100
00:03:08,720 --> 00:03:09,840
and the bootloader itself has been

101
00:03:09,840 --> 00:03:10,959
modified to add further custom

102
00:03:10,959 --> 00:03:12,720
functionality on top of the bootloader

103
00:03:12,720 --> 00:03:14,879
unlocking restrictions

104
00:03:14,879 --> 00:03:16,640
so fastboot is a command interface used

105
00:03:16,640 --> 00:03:18,400
for android boot loaders or most android

106
00:03:18,400 --> 00:03:20,800
boot loaders using a basic usb interface

107
00:03:20,800 --> 00:03:22,560
commands and responses are sent in raw

108
00:03:22,560 --> 00:03:24,400
text in most circumstances apart from

109
00:03:24,400 --> 00:03:26,319
some very specific ones including

110
00:03:26,319 --> 00:03:28,159
functionality like rebooting the device

111
00:03:28,159 --> 00:03:29,920
flashing certain partitions downloading

112
00:03:29,920 --> 00:03:31,920
data or getting device info from the

113
00:03:31,920 --> 00:03:33,280
device and of course unlocking the

114
00:03:33,280 --> 00:03:35,360
bootloader

115
00:03:35,360 --> 00:03:36,959
this can be implemented using standard

116
00:03:36,959 --> 00:03:39,040
usb library such as lib usb just by

117
00:03:39,040 --> 00:03:40,720
enumerating the usb device and then

118
00:03:40,720 --> 00:03:42,640
sending data over the bulk end point and

119
00:03:42,640 --> 00:03:44,400
receiving data back asynchronously

120
00:03:44,400 --> 00:03:46,080
literally sending ascii data back and

121
00:03:46,080 --> 00:03:47,760
forth there are libraries that exist for

122
00:03:47,760 --> 00:03:48,879
this purpose that are largely

123
00:03:48,879 --> 00:03:50,000
unnecessary for any standard

124
00:03:50,000 --> 00:03:53,120
functionality on the device

125
00:03:53,120 --> 00:03:55,519
um the abl bootloader is the bootloader

126
00:03:55,519 --> 00:03:57,599
which provides um this boost usb

127
00:03:57,599 --> 00:03:58,879
interface it's actually a second stage

128
00:03:58,879 --> 00:04:00,799
bootloader which is loaded into ram from

129
00:04:00,799 --> 00:04:02,480
the first bootloader which verifies the

130
00:04:02,480 --> 00:04:04,159
android operating system as well as

131
00:04:04,159 --> 00:04:05,200
allows for all this management

132
00:04:05,200 --> 00:04:07,280
functionality and it can be accessed via

133
00:04:07,280 --> 00:04:09,760
adb or via button combinations on boot

134
00:04:09,760 --> 00:04:10,879
on the phone

135
00:04:10,879 --> 00:04:12,560
it's stored in the abr partition on the

136
00:04:12,560 --> 00:04:14,640
device and is stored as a ua5 file

137
00:04:14,640 --> 00:04:16,639
system meaning it's a file system stored

138
00:04:16,639 --> 00:04:19,199
within an l file in that partition this

139
00:04:19,199 --> 00:04:21,358
can be extracted with the tool uefi

140
00:04:21,358 --> 00:04:22,720
firmware password to find a portable

141
00:04:22,720 --> 00:04:25,120
executable called linux loader and this

142
00:04:25,120 --> 00:04:27,280
can be loaded directly into wider the

143
00:04:27,280 --> 00:04:28,960
bass bootloader provided while qualcomm

144
00:04:28,960 --> 00:04:30,320
has source code available but this is

145
00:04:30,320 --> 00:04:31,919
modified by vendors meaning i could use

146
00:04:31,919 --> 00:04:33,360
this source code as a reference for this

147
00:04:33,360 --> 00:04:34,960
project but it wouldn't give me all of

148
00:04:34,960 --> 00:04:36,080
the functionality used by different

149
00:04:36,080 --> 00:04:38,320
users

150
00:04:38,320 --> 00:04:40,000
analysis of the bootloader being

151
00:04:40,000 --> 00:04:41,680
performed quite easily all fastboot

152
00:04:41,680 --> 00:04:42,960
commands are stored in a table it's

153
00:04:42,960 --> 00:04:45,199
literally a ascii text and a function

154
00:04:45,199 --> 00:04:47,199
callback which can be analyzed in turn

155
00:04:47,199 --> 00:04:49,680
along to see every function callback and

156
00:04:49,680 --> 00:04:51,120
every kind of ascii command that's can

157
00:04:51,120 --> 00:04:52,880
be used on that particular bootloader

158
00:04:52,880 --> 00:04:55,040
this can aid in identifying non-standard

159
00:04:55,040 --> 00:04:57,600
commands or helps you in identifying

160
00:04:57,600 --> 00:04:59,040
non-standard functionality within these

161
00:04:59,040 --> 00:05:00,880
commands there's a lot of locking

162
00:05:00,880 --> 00:05:02,560
strings in the firmware of the

163
00:05:02,560 --> 00:05:04,800
bootloader meaning that one can really

164
00:05:04,800 --> 00:05:06,560
easily understand what's going on with

165
00:05:06,560 --> 00:05:08,240
each piece of code just by reading the

166
00:05:08,240 --> 00:05:11,360
strings that are coming out of it

167
00:05:11,360 --> 00:05:13,120
um i decided to start looking at the

168
00:05:13,120 --> 00:05:14,400
flash command to start with because the

169
00:05:14,400 --> 00:05:16,240
flash command usually only

170
00:05:16,240 --> 00:05:17,440
flashes partitions on unlocked

171
00:05:17,440 --> 00:05:19,520
bootloaders but what we really wanted to

172
00:05:19,520 --> 00:05:21,759
do was try and flash partitions while it

173
00:05:21,759 --> 00:05:23,199
was locked to start with this would

174
00:05:23,199 --> 00:05:24,560
allow me to do things like modify the

175
00:05:24,560 --> 00:05:26,639
device info of the phone in order to set

176
00:05:26,639 --> 00:05:28,560
the unlock bit for instance

177
00:05:28,560 --> 00:05:30,080
um the command had been modified by the

178
00:05:30,080 --> 00:05:31,520
manufacturer to allow for flashing of

179
00:05:31,520 --> 00:05:35,199
very specific custom partitions um which

180
00:05:35,199 --> 00:05:36,800
instead of being flashed to the phone

181
00:05:36,800 --> 00:05:38,400
would be parsed by some extra processing

182
00:05:38,400 --> 00:05:39,680
which would do some string parsing in

183
00:05:39,680 --> 00:05:42,160
order to essentially pass out a list of

184
00:05:42,160 --> 00:05:44,400
crcs that were used by the device as

185
00:05:44,400 --> 00:05:46,400
part of the firmware update process

186
00:05:46,400 --> 00:05:47,840
um there was potential for memory

187
00:05:47,840 --> 00:05:49,199
corruption here because it was custom

188
00:05:49,199 --> 00:05:50,880
functionality and because it bypassed

189
00:05:50,880 --> 00:05:52,320
the locking restrictions that are

190
00:05:52,320 --> 00:05:53,840
usually on the flash command i thought

191
00:05:53,840 --> 00:05:56,400
it'd be a good place to start

192
00:05:56,400 --> 00:05:57,919
um unfortunately during this process i

193
00:05:57,919 --> 00:05:59,280
made a mistake in my implementation

194
00:05:59,280 --> 00:06:01,120
which is actually how i found the actual

195
00:06:01,120 --> 00:06:02,319
vulnerability we're going to exploit

196
00:06:02,319 --> 00:06:03,280
today

197
00:06:03,280 --> 00:06:05,039
i'd assumed that the way that this

198
00:06:05,039 --> 00:06:06,560
process would work is i'd say i wanted

199
00:06:06,560 --> 00:06:08,479
to flash a partition and then send the

200
00:06:08,479 --> 00:06:10,800
payload of that partition to be flashed

201
00:06:10,800 --> 00:06:12,400
however what you're supposed to do is

202
00:06:12,400 --> 00:06:14,319
send the download command or the payload

203
00:06:14,319 --> 00:06:16,240
size then save it send the payload of

204
00:06:16,240 --> 00:06:18,240
the exact size of that payload size and

205
00:06:18,240 --> 00:06:19,520
then you say which partition you want to

206
00:06:19,520 --> 00:06:21,840
flash and that data is flashed from ram

207
00:06:21,840 --> 00:06:23,440
into that partition

208
00:06:23,440 --> 00:06:25,520
i accidentally left an incorrect flash

209
00:06:25,520 --> 00:06:27,199
command after my first flash command as

210
00:06:27,199 --> 00:06:28,880
well which meant

211
00:06:28,880 --> 00:06:30,319
that after sending that second flash

212
00:06:30,319 --> 00:06:31,840
command the bootloader would completely

213
00:06:31,840 --> 00:06:32,880
crash

214
00:06:32,880 --> 00:06:35,120
the lack of a download command was my um

215
00:06:35,120 --> 00:06:37,039
assumed reason for this because that was

216
00:06:37,039 --> 00:06:38,000
the only thing different between what

217
00:06:38,000 --> 00:06:38,800
you're meant to do and what you're not

218
00:06:38,800 --> 00:06:40,560
meant to do meaning that the device has

219
00:06:40,560 --> 00:06:42,080
probably not interpreted my commands

220
00:06:42,080 --> 00:06:44,479
correctly and has actually used my large

221
00:06:44,479 --> 00:06:48,319
data payload as a command in of itself

222
00:06:48,319 --> 00:06:49,680
what i'd found is when i'd sent this

223
00:06:49,680 --> 00:06:52,080
large payload um to start off with usb

224
00:06:52,080 --> 00:06:53,680
connectivity stopped functioning

225
00:06:53,680 --> 00:06:55,120
entirely and i had to do a hard reset on

226
00:06:55,120 --> 00:06:56,880
the phone in order to get it back into a

227
00:06:56,880 --> 00:06:58,800
working state i'd hold down the volume

228
00:06:58,800 --> 00:07:00,160
down button on the power button for 10

229
00:07:00,160 --> 00:07:02,400
seconds and then the phone would reboot

230
00:07:02,400 --> 00:07:05,360
and everything would start working again

231
00:07:05,360 --> 00:07:06,960
i started with a smaller payload size to

232
00:07:06,960 --> 00:07:08,080
see if that would crash the phone and

233
00:07:08,080 --> 00:07:09,440
that didn't work so what i ended up

234
00:07:09,440 --> 00:07:11,280
doing was using a binary search approach

235
00:07:11,280 --> 00:07:13,360
where i took a large size and a minimum

236
00:07:13,360 --> 00:07:15,199
size and

237
00:07:15,199 --> 00:07:16,960
went halfway between those and if the

238
00:07:16,960 --> 00:07:18,639
phone crashed with the value halfway

239
00:07:18,639 --> 00:07:20,639
between those i could then have it again

240
00:07:20,639 --> 00:07:22,560
or double it again as needed

241
00:07:22,560 --> 00:07:24,240
um by rebooting the phone and doing this

242
00:07:24,240 --> 00:07:25,599
so i could find the payload size that

243
00:07:25,599 --> 00:07:27,680
was uh of the maximum before it would

244
00:07:27,680 --> 00:07:31,360
crash was 1 1 ba e 0.

245
00:07:31,360 --> 00:07:32,880
due to this unusual memory size i assume

246
00:07:32,880 --> 00:07:34,000
this is going to be some kind of buffer

247
00:07:34,000 --> 00:07:35,840
overflow however with no debugging

248
00:07:35,840 --> 00:07:38,479
functionality functionality available on

249
00:07:38,479 --> 00:07:40,560
the phone identifying how this memory

250
00:07:40,560 --> 00:07:41,840
corruption could be overwritten would be

251
00:07:41,840 --> 00:07:43,199
difficult especially due to the fact

252
00:07:43,199 --> 00:07:44,479
that the bootloader used stack canaries

253
00:07:44,479 --> 00:07:46,479
on all functions meaning if i triggered

254
00:07:46,479 --> 00:07:47,759
the stat canary the phone would still

255
00:07:47,759 --> 00:07:50,080
crash and it could look like a valid um

256
00:07:50,080 --> 00:07:51,280
exploit of some kind but wouldn't

257
00:07:51,280 --> 00:07:53,280
actually do anything so i decided to do

258
00:07:53,280 --> 00:07:54,879
was send the next byte in the sequence

259
00:07:54,879 --> 00:07:57,599
so 1 1 bae e1 bytes of data i'd modify

260
00:07:57,599 --> 00:07:59,759
the last byte and increment that last

261
00:07:59,759 --> 00:08:02,000
byte value while rebooting the phone and

262
00:08:02,000 --> 00:08:03,280
if the phone didn't crash while sending

263
00:08:03,280 --> 00:08:04,960
a certain value it was likely that i'd

264
00:08:04,960 --> 00:08:07,199
found the next byte in the uh sequence

265
00:08:07,199 --> 00:08:08,800
uh the next byte was identified to be

266
00:08:08,800 --> 00:08:10,400
oxff meaning that it took me quite a

267
00:08:10,400 --> 00:08:12,639
long time to go through the entire 256

268
00:08:12,639 --> 00:08:15,680
values that are available there

269
00:08:15,680 --> 00:08:17,039
by constantly power cycling like this

270
00:08:17,039 --> 00:08:18,560
and incrementing the byte value finding

271
00:08:18,560 --> 00:08:19,840
a valid one and then moving to the next

272
00:08:19,840 --> 00:08:21,199
byte in the sequence i could probably

273
00:08:21,199 --> 00:08:23,199
generate a reasonable facsimile of the

274
00:08:23,199 --> 00:08:24,960
memory that was in that place in the

275
00:08:24,960 --> 00:08:26,879
current memory going on it wouldn't be

276
00:08:26,879 --> 00:08:28,319
the exact memory in use but it would be

277
00:08:28,319 --> 00:08:29,520
enough to not rush the bootloader and

278
00:08:29,520 --> 00:08:30,879
would possibly align would get some kind

279
00:08:30,879 --> 00:08:32,399
of code execution

280
00:08:32,399 --> 00:08:33,599
once this was generated it could

281
00:08:33,599 --> 00:08:35,599
potentially be modified to gain code

282
00:08:35,599 --> 00:08:37,839
execution of course and then

283
00:08:37,839 --> 00:08:38,719
i

284
00:08:38,719 --> 00:08:40,559
would be able to unlock the bootloader

285
00:08:40,559 --> 00:08:42,320
hopefully but what i really wanted was a

286
00:08:42,320 --> 00:08:43,519
way of automating this process to

287
00:08:43,519 --> 00:08:47,279
receive more bikes than was required

288
00:08:47,440 --> 00:08:49,279
um it was suggested that removal of the

289
00:08:49,279 --> 00:08:51,040
phone battery and usb relay bay could be

290
00:08:51,040 --> 00:08:52,560
used to automate this power cycling on

291
00:08:52,560 --> 00:08:54,320
the phone however this would require

292
00:08:54,320 --> 00:08:56,640
moving removing uh glue from the case

293
00:08:56,640 --> 00:08:58,399
and uh removing the battery as well

294
00:08:58,399 --> 00:09:00,080
which was going to be quite intensive

295
00:09:00,080 --> 00:09:02,080
and quite um damaging to the phone so

296
00:09:02,080 --> 00:09:03,760
what i did instead was wrap a hair tie

297
00:09:03,760 --> 00:09:05,120
around the volume down on power buttons

298
00:09:05,120 --> 00:09:06,160
on the phone

299
00:09:06,160 --> 00:09:08,000
and what this did was cause the phone to

300
00:09:08,000 --> 00:09:09,839
go into a boot loop would restart into

301
00:09:09,839 --> 00:09:11,839
the bootloader constantly allow for usb

302
00:09:11,839 --> 00:09:13,120
to be accessed for a very short amount

303
00:09:13,120 --> 00:09:15,120
of time about five seconds which was

304
00:09:15,120 --> 00:09:16,480
enough of time for me to try and test my

305
00:09:16,480 --> 00:09:18,959
buffer overflow

306
00:09:18,959 --> 00:09:21,040
i modified my original fastboot tool

307
00:09:21,040 --> 00:09:22,399
that i was using to try and exploit this

308
00:09:22,399 --> 00:09:24,000
device to make it loop around and

309
00:09:24,000 --> 00:09:25,839
constantly try this particular attack

310
00:09:25,839 --> 00:09:27,920
i'm going to verify two key things

311
00:09:27,920 --> 00:09:29,760
whether there was a string response

312
00:09:29,760 --> 00:09:31,360
saying flashing fail to my invalid

313
00:09:31,360 --> 00:09:33,200
partition being written and whether the

314
00:09:33,200 --> 00:09:35,200
phone would crash afterwards each

315
00:09:35,200 --> 00:09:37,120
iteration of this took 10 to 30 seconds

316
00:09:37,120 --> 00:09:39,120
however

317
00:09:39,120 --> 00:09:40,640
i left the phone overnight to perform

318
00:09:40,640 --> 00:09:42,080
this loop and found that it generated

319
00:09:42,080 --> 00:09:44,000
0x34 bytes of data which didn't crash

320
00:09:44,000 --> 00:09:45,600
the phone this was data that could be

321
00:09:45,600 --> 00:09:46,640
sent to the phone and then it wouldn't

322
00:09:46,640 --> 00:09:48,800
crash straight away the repeated byte

323
00:09:48,800 --> 00:09:50,959
values um and lack of default stack

324
00:09:50,959 --> 00:09:52,480
canary which in this particular phone

325
00:09:52,480 --> 00:09:54,240
before it'd be modified by the hardware

326
00:09:54,240 --> 00:09:56,800
randomizer with c-o-c-o-c-o-c-o meant

327
00:09:56,800 --> 00:09:58,160
that this was likely to not be the stack

328
00:09:58,160 --> 00:09:59,360
it could be something even more

329
00:09:59,360 --> 00:10:01,360
interesting what i did note was all of

330
00:10:01,360 --> 00:10:03,279
the 32-bit words here were found to be

331
00:10:03,279 --> 00:10:04,160
arm

332
00:10:04,160 --> 00:10:07,040
64 op codes

333
00:10:07,040 --> 00:10:08,880
so most not codes while valid operations

334
00:10:08,880 --> 00:10:09,600
wouldn't be the same as in the

335
00:10:09,600 --> 00:10:10,880
bootloader but they would be fairly

336
00:10:10,880 --> 00:10:12,560
similar things that handle the stack

337
00:10:12,560 --> 00:10:14,320
like pushing and popping and things that

338
00:10:14,320 --> 00:10:15,680
branch to different function calls would

339
00:10:15,680 --> 00:10:17,120
have to be fairly accurate in order to

340
00:10:17,120 --> 00:10:19,120
work properly however things like just

341
00:10:19,120 --> 00:10:20,800
data general data management and things

342
00:10:20,800 --> 00:10:22,240
that just move data around in a very

343
00:10:22,240 --> 00:10:24,160
basic way would not necessarily have to

344
00:10:24,160 --> 00:10:25,519
be accurate

345
00:10:25,519 --> 00:10:27,680
searching for the um stack management

346
00:10:27,680 --> 00:10:29,440
from operations in the bootloader that

347
00:10:29,440 --> 00:10:30,800
i'd loaded into wider unfortunately

348
00:10:30,800 --> 00:10:32,640
didn't yield any useful results from

349
00:10:32,640 --> 00:10:34,880
this

350
00:10:35,680 --> 00:10:38,000
arm64 operations can have a huge number

351
00:10:38,000 --> 00:10:39,600
of different uh quirks that mean they

352
00:10:39,600 --> 00:10:41,040
aren't exactly the same in two different

353
00:10:41,040 --> 00:10:42,959
pieces of firmware so for one thing

354
00:10:42,959 --> 00:10:44,720
there's unused bits on some operations

355
00:10:44,720 --> 00:10:46,160
which um either don't change the

356
00:10:46,160 --> 00:10:47,920
functionality or only change it

357
00:10:47,920 --> 00:10:50,880
superficially um registers in arm64 can

358
00:10:50,880 --> 00:10:53,040
be accessed as both 32-bit and 64-bit

359
00:10:53,040 --> 00:10:55,839
values um which can sometimes cause

360
00:10:55,839 --> 00:10:57,680
issues but sometimes if the compiler is

361
00:10:57,680 --> 00:10:59,279
only compiling the 64-bit but treating

362
00:10:59,279 --> 00:11:01,680
live 32-bit it will access it in the

363
00:11:01,680 --> 00:11:02,880
correct way

364
00:11:02,880 --> 00:11:04,640
um and also branch conditions can have

365
00:11:04,640 --> 00:11:06,160
conditions for jumping which may have

366
00:11:06,160 --> 00:11:08,000
been met by my brute forcing of this

367
00:11:08,000 --> 00:11:09,920
dump these future features in general

368
00:11:09,920 --> 00:11:12,000
would mean that i could change this code

369
00:11:12,000 --> 00:11:13,920
that i generated would work as needed

370
00:11:13,920 --> 00:11:15,600
but would not necessarily be 100

371
00:11:15,600 --> 00:11:18,000
accurate

372
00:11:18,240 --> 00:11:19,680
um i decided to use the branch and link

373
00:11:19,680 --> 00:11:20,959
instruction which is the function

374
00:11:20,959 --> 00:11:22,720
calling instruction and because it was

375
00:11:22,720 --> 00:11:25,279
one that was least likely to be common

376
00:11:25,279 --> 00:11:27,279
in the rest of the code the stack

377
00:11:27,279 --> 00:11:29,519
pushing value value and operation would

378
00:11:29,519 --> 00:11:31,440
probably be similar throughout the

379
00:11:31,440 --> 00:11:32,800
firmware and probably be found in lots

380
00:11:32,800 --> 00:11:34,320
of different places

381
00:11:34,320 --> 00:11:36,160
and to perform the text search remove

382
00:11:36,160 --> 00:11:38,160
the first nibble which um handles some

383
00:11:38,160 --> 00:11:39,839
part of the relative addressing and i

384
00:11:39,839 --> 00:11:41,680
found that this would probably find um

385
00:11:41,680 --> 00:11:43,600
function jumps that was in a similar

386
00:11:43,600 --> 00:11:45,279
relative address space to my dumped op

387
00:11:45,279 --> 00:11:47,200
code and this would mean for instance if

388
00:11:47,200 --> 00:11:48,720
there's a string comparison a secure

389
00:11:48,720 --> 00:11:50,000
string comparison next to each other in

390
00:11:50,000 --> 00:11:51,440
the firmware and i'd actually

391
00:11:51,440 --> 00:11:52,880
accidentally jump to one on the other it

392
00:11:52,880 --> 00:11:54,000
would

393
00:11:54,000 --> 00:11:55,760
behave appropriately

394
00:11:55,760 --> 00:11:57,200
this identified a single valid

395
00:11:57,200 --> 00:11:59,040
instruction in the crc list parser which

396
00:11:59,040 --> 00:12:00,720
was the parser for the partition that i

397
00:12:00,720 --> 00:12:02,800
was flashing and the op codes were

398
00:12:02,800 --> 00:12:04,720
similar to what was in the memory dump

399
00:12:04,720 --> 00:12:06,480
when i looked at them directly but not

400
00:12:06,480 --> 00:12:09,120
exactly the right

401
00:12:09,120 --> 00:12:10,800
so analysis of the offset showed that

402
00:12:10,800 --> 00:12:12,399
the bootloader in its entirety is being

403
00:12:12,399 --> 00:12:14,880
overwritten over one zero one zero zero

404
00:12:14,880 --> 00:12:16,480
zero bytes of data

405
00:12:16,480 --> 00:12:18,320
and because the bootloader is executed

406
00:12:18,320 --> 00:12:20,560
from ram demonstrated by this overflow

407
00:12:20,560 --> 00:12:22,160
um i could just completely overwrite it

408
00:12:22,160 --> 00:12:23,600
with itself and the bootloader would

409
00:12:23,600 --> 00:12:25,279
continue to function normally wouldn't

410
00:12:25,279 --> 00:12:27,600
crash and nothing would go wrong

411
00:12:27,600 --> 00:12:29,360
i got the original bootloader binary

412
00:12:29,360 --> 00:12:30,959
from the file system as i could before

413
00:12:30,959 --> 00:12:32,560
but i could have also got it from an ota

414
00:12:32,560 --> 00:12:34,800
update and i could fully overwrite it in

415
00:12:34,800 --> 00:12:36,880
the uh using my tool to identify that

416
00:12:36,880 --> 00:12:38,880
this was accurate from here i could

417
00:12:38,880 --> 00:12:40,320
modify the bootloader to run any

418
00:12:40,320 --> 00:12:42,160
unsigned code i wanted so knock out

419
00:12:42,160 --> 00:12:44,079
functions modify functionality in order

420
00:12:44,079 --> 00:12:46,880
to add what i wanted to

421
00:12:46,880 --> 00:12:48,639
so to unlock the bootloader on this

422
00:12:48,639 --> 00:12:50,240
particular phone i needed to jump back

423
00:12:50,240 --> 00:12:52,480
past the rsa check which was used to

424
00:12:52,480 --> 00:12:54,320
perform the bootleg odor unlocker was

425
00:12:54,320 --> 00:12:56,639
performed to verify whether unlocks were

426
00:12:56,639 --> 00:12:57,760
permitted

427
00:12:57,760 --> 00:12:58,959
i could generate a simple branch

428
00:12:58,959 --> 00:13:00,560
instruction using uh the relative

429
00:13:00,560 --> 00:13:01,839
addresses between the functionality

430
00:13:01,839 --> 00:13:03,519
overflowed and the unlocked bootloader

431
00:13:03,519 --> 00:13:05,279
functions so i could modify the exact

432
00:13:05,279 --> 00:13:06,800
function i was already using to change

433
00:13:06,800 --> 00:13:08,079
the functionality

434
00:13:08,079 --> 00:13:10,320
i use the shell storm online arm64

435
00:13:10,320 --> 00:13:11,760
assembler for this as it's very quickly

436
00:13:11,760 --> 00:13:12,880
to

437
00:13:12,880 --> 00:13:15,200
allows you to very quickly uh generate

438
00:13:15,200 --> 00:13:17,279
um assembler code for this particular

439
00:13:17,279 --> 00:13:18,320
purpose

440
00:13:18,320 --> 00:13:19,839
the process would be very difficult to

441
00:13:19,839 --> 00:13:21,920
debug but a successful um unlock would

442
00:13:21,920 --> 00:13:23,760
be very easy to identify by virtue of

443
00:13:23,760 --> 00:13:25,440
the phone restarting itself erasing

444
00:13:25,440 --> 00:13:28,079
itself and being unlocked

445
00:13:28,079 --> 00:13:29,920
so here's a quick view of how this runs

446
00:13:29,920 --> 00:13:32,000
so i run making rungs it's a c plus plus

447
00:13:32,000 --> 00:13:33,760
application

448
00:13:33,760 --> 00:13:34,959
and um

449
00:13:34,959 --> 00:13:36,800
it would send my data try and flash crc

450
00:13:36,800 --> 00:13:38,800
list and when it sent flash the rc list

451
00:13:38,800 --> 00:13:40,320
it would actually jump to the bootloader

452
00:13:40,320 --> 00:13:42,160
unlock command which would send an okay

453
00:13:42,160 --> 00:13:44,079
response and then because i'd messed up

454
00:13:44,079 --> 00:13:45,360
some of my stack handling in my

455
00:13:45,360 --> 00:13:47,360
particular operation what would happen

456
00:13:47,360 --> 00:13:49,199
is it would then sign 512 bytes of

457
00:13:49,199 --> 00:13:51,199
corrupted data via usb i couldn't

458
00:13:51,199 --> 00:13:52,800
ascertain the reason for this but this

459
00:13:52,800 --> 00:13:54,720
demonstrated that the

460
00:13:54,720 --> 00:13:56,079
buffer overflow had occurred the phone

461
00:13:56,079 --> 00:13:57,680
would crash and then it would start out

462
00:13:57,680 --> 00:14:00,880
with an unlocked bootloader

463
00:14:00,880 --> 00:14:02,160
i was able to procure a second

464
00:14:02,160 --> 00:14:04,320
smartphone which also used the stm660 of

465
00:14:04,320 --> 00:14:05,839
this purpose unfortunately the original

466
00:14:05,839 --> 00:14:08,440
phone i'd worked with um which was using

467
00:14:08,440 --> 00:14:11,279
stm665 before this whole project was not

468
00:14:11,279 --> 00:14:12,639
vulnerable to this vulnerability in the

469
00:14:12,639 --> 00:14:14,160
same way so i couldn't really use it to

470
00:14:14,160 --> 00:14:15,760
continue this project

471
00:14:15,760 --> 00:14:17,760
this particular phone however had all

472
00:14:17,760 --> 00:14:18,959
boot loader unlocking functionality

473
00:14:18,959 --> 00:14:20,399
disabled by the manufacturer meaning

474
00:14:20,399 --> 00:14:21,920
that if i wanted to unlock the

475
00:14:21,920 --> 00:14:23,120
bootloader it would be very helpful but

476
00:14:23,120 --> 00:14:25,120
it would also bypass some protections on

477
00:14:25,120 --> 00:14:26,320
their end

478
00:14:26,320 --> 00:14:27,760
um it was identified to be using a

479
00:14:27,760 --> 00:14:29,440
similar signature verification approach

480
00:14:29,440 --> 00:14:31,279
as the original phone i found this is a

481
00:14:31,279 --> 00:14:32,880
very common approach just because it's

482
00:14:32,880 --> 00:14:36,320
easy to implement and fairly secure

483
00:14:36,320 --> 00:14:38,320
i took an ota image for the device um

484
00:14:38,320 --> 00:14:39,600
because unfortunately i couldn't dump

485
00:14:39,600 --> 00:14:41,040
the bootloader directly because if the

486
00:14:41,040 --> 00:14:43,680
bootloader the bootloader is locked

487
00:14:43,680 --> 00:14:46,240
and it showed um the code which blocked

488
00:14:46,240 --> 00:14:47,519
the bootloader unlocked so you would run

489
00:14:47,519 --> 00:14:49,839
a bootloader unlock command uh or rather

490
00:14:49,839 --> 00:14:51,519
an oem unlock command or a flashing

491
00:14:51,519 --> 00:14:53,600
unlock command and it would tell you

492
00:14:53,600 --> 00:14:55,839
it's not permitted because um the

493
00:14:55,839 --> 00:14:57,360
signature didn't match

494
00:14:57,360 --> 00:14:59,120
um i also found there's no hidden

495
00:14:59,120 --> 00:15:00,240
bootloader commands here which would

496
00:15:00,240 --> 00:15:01,199
directly allow me to unlock the

497
00:15:01,199 --> 00:15:03,199
bootloader

498
00:15:03,199 --> 00:15:04,880
initially i tried my old crash using the

499
00:15:04,880 --> 00:15:06,560
same amount of data size and the device

500
00:15:06,560 --> 00:15:07,680
still functioned implying that the

501
00:15:07,680 --> 00:15:09,600
vulnerability may not still be present

502
00:15:09,600 --> 00:15:11,360
however i sent a much larger margin

503
00:15:11,360 --> 00:15:13,519
payload size of eight megabytes and this

504
00:15:13,519 --> 00:15:14,560
crashed the phone implying that the

505
00:15:14,560 --> 00:15:16,160
memory layout was slightly different but

506
00:15:16,160 --> 00:15:18,800
the freeflow was still there

507
00:15:18,800 --> 00:15:20,639
manual analysis demonstrated that the

508
00:15:20,639 --> 00:15:22,000
bootloader was overwritten after four

509
00:15:22,000 --> 00:15:24,079
zero three zero zero zero bytes instead

510
00:15:24,079 --> 00:15:26,160
of the original one zero one zero zero

511
00:15:26,160 --> 00:15:28,240
on the first device and with this a

512
00:15:28,240 --> 00:15:29,600
bootloader unlock could be rapidly

513
00:15:29,600 --> 00:15:30,800
developed

514
00:15:30,800 --> 00:15:31,920
a single branch instruction was

515
00:15:31,920 --> 00:15:33,600
identified which jumped past the

516
00:15:33,600 --> 00:15:35,519
bootloader unlock command if it couldn't

517
00:15:35,519 --> 00:15:37,680
verify that signature and simply by

518
00:15:37,680 --> 00:15:39,120
writing a nop instruction over this

519
00:15:39,120 --> 00:15:40,959
using my buffer overflow i could unlock

520
00:15:40,959 --> 00:15:42,240
the bootloader and allow the phone to be

521
00:15:42,240 --> 00:15:44,480
rooted i disclosed this vulnerability to

522
00:15:44,480 --> 00:15:46,639
qualcomm because it directly impacted

523
00:15:46,639 --> 00:15:49,040
them because it was probably um

524
00:15:49,040 --> 00:15:53,519
available on all stm660 based phones

525
00:15:53,600 --> 00:15:55,279
one thing i wanted to add to this was um

526
00:15:55,279 --> 00:15:57,360
bypassing the user data protection on

527
00:15:57,360 --> 00:15:59,040
qualcomm's phones now

528
00:15:59,040 --> 00:16:00,560
qualcomm's chips encrypt the user data

529
00:16:00,560 --> 00:16:02,560
partition even if you don't use a pin or

530
00:16:02,560 --> 00:16:04,800
any kind of encryption because of um

531
00:16:04,800 --> 00:16:06,480
internal security mechanisms on the chip

532
00:16:06,480 --> 00:16:08,639
itself this prevents forensic chip off

533
00:16:08,639 --> 00:16:10,079
analysis meaning that if someone removed

534
00:16:10,079 --> 00:16:12,160
the emmc or the ufs from your phone they

535
00:16:12,160 --> 00:16:14,560
couldn't directly access your user data

536
00:16:14,560 --> 00:16:16,079
however and if an unlocked bootloader

537
00:16:16,079 --> 00:16:17,440
tries to access this partition without

538
00:16:17,440 --> 00:16:19,279
erasing it on the bootloader unlock it's

539
00:16:19,279 --> 00:16:20,720
identified as being corrupted because

540
00:16:20,720 --> 00:16:22,959
the unlocked b loader can no longer

541
00:16:22,959 --> 00:16:24,959
access the encryption keys for this

542
00:16:24,959 --> 00:16:26,560
however bypass of these protections

543
00:16:26,560 --> 00:16:28,240
could allow the user data to be accessed

544
00:16:28,240 --> 00:16:30,320
for both um gaining access to sensitive

545
00:16:30,320 --> 00:16:32,800
user data but also some fun useful

546
00:16:32,800 --> 00:16:34,560
purposes that could be of value to

547
00:16:34,560 --> 00:16:35,680
someone who wanted to root that phone in

548
00:16:35,680 --> 00:16:38,319
the first place

549
00:16:38,399 --> 00:16:40,079
so using qualcomm source code which was

550
00:16:40,079 --> 00:16:41,519
available the encryption process could

551
00:16:41,519 --> 00:16:43,519
be analyzed the encryption keys are

552
00:16:43,519 --> 00:16:44,959
intentionally inaccessible even with

553
00:16:44,959 --> 00:16:46,560
code execution because they're internal

554
00:16:46,560 --> 00:16:48,240
to the chip and i found that the

555
00:16:48,240 --> 00:16:50,000
bootloader itself used an internal api

556
00:16:50,000 --> 00:16:51,279
to decrypt the partition which wasn't

557
00:16:51,279 --> 00:16:53,839
modifiable by my exploit this api

558
00:16:53,839 --> 00:16:54,959
verifies whether it's unlocked and

559
00:16:54,959 --> 00:16:56,320
whether the firmware is signed before

560
00:16:56,320 --> 00:16:57,440
giving the

561
00:16:57,440 --> 00:16:59,839
appropriate encryption uh commands to

562
00:16:59,839 --> 00:17:02,800
the user data partition

563
00:17:02,800 --> 00:17:04,720
the boot fabric command is a command in

564
00:17:04,720 --> 00:17:06,400
the bootloader which loads and executes

565
00:17:06,400 --> 00:17:08,559
android uh android images deployed via

566
00:17:08,559 --> 00:17:10,959
usb from ram so you can send them and

567
00:17:10,959 --> 00:17:12,640
boot them temporarily this is for things

568
00:17:12,640 --> 00:17:13,679
like

569
00:17:13,679 --> 00:17:16,480
deploying custom recovery partitions etc

570
00:17:16,480 --> 00:17:18,079
it was noted that the verification

571
00:17:18,079 --> 00:17:19,520
execution of the image were two separate

572
00:17:19,520 --> 00:17:20,799
functions in this and in all other

573
00:17:20,799 --> 00:17:22,799
places in the um bootloader but here it

574
00:17:22,799 --> 00:17:24,240
was particularly prominent

575
00:17:24,240 --> 00:17:26,079
and that there's a high likelihood that

576
00:17:26,079 --> 00:17:27,599
i could put some code in between these

577
00:17:27,599 --> 00:17:30,160
two function calls in order to

578
00:17:30,160 --> 00:17:32,320
swap out a signed image with an unside

579
00:17:32,320 --> 00:17:34,000
image after verifying that the image was

580
00:17:34,000 --> 00:17:35,919
valid and decrypting the user data

581
00:17:35,919 --> 00:17:38,480
partition

582
00:17:38,559 --> 00:17:40,080
uh the boot command receives the full

583
00:17:40,080 --> 00:17:41,760
android boot image which has a special

584
00:17:41,760 --> 00:17:43,760
custom format via the fastboot download

585
00:17:43,760 --> 00:17:45,200
command which was outlined at the start

586
00:17:45,200 --> 00:17:46,960
of this talk which is loaded into ram

587
00:17:46,960 --> 00:17:49,520
verified and executed so by patching the

588
00:17:49,520 --> 00:17:50,960
boot command the behavior could be

589
00:17:50,960 --> 00:17:52,559
altered for this time

590
00:17:52,559 --> 00:17:54,080
time of check to time if you use that

591
00:17:54,080 --> 00:17:56,480
just outlined instead of sending one one

592
00:17:56,480 --> 00:17:57,840
image two could be sent and then swapped

593
00:17:57,840 --> 00:17:59,919
after verification so what i did was

594
00:17:59,919 --> 00:18:01,280
create a tool which sent three pieces of

595
00:18:01,280 --> 00:18:03,440
data to achieve this a four byte offsite

596
00:18:03,440 --> 00:18:06,000
to a unsigned image a signed image and

597
00:18:06,000 --> 00:18:07,520
then the unsigned malicious image

598
00:18:07,520 --> 00:18:10,080
containing my own code

599
00:18:10,080 --> 00:18:11,440
uh the boot command itself doesn't

600
00:18:11,440 --> 00:18:12,720
function on locked boot loaders in the

601
00:18:12,720 --> 00:18:13,919
first place so the first thing i needed

602
00:18:13,919 --> 00:18:17,200
to do was modify that so what i did was

603
00:18:17,200 --> 00:18:18,960
take the branch that says that there's

604
00:18:18,960 --> 00:18:19,760
uh

605
00:18:19,760 --> 00:18:21,360
commands are not allowed in lock states

606
00:18:21,360 --> 00:18:22,960
and made that change the pointer from to

607
00:18:22,960 --> 00:18:24,880
be pointing at my offsets to be pointing

608
00:18:24,880 --> 00:18:26,320
at the signed image just by adding four

609
00:18:26,320 --> 00:18:27,280
to it

610
00:18:27,280 --> 00:18:28,720
this would allow the

611
00:18:28,720 --> 00:18:30,559
thing to boot with my signed image and

612
00:18:30,559 --> 00:18:32,160
everything would start working again and

613
00:18:32,160 --> 00:18:36,080
also bypass this routing protection

614
00:18:36,160 --> 00:18:38,400
um there were about four or five

615
00:18:38,400 --> 00:18:39,840
function calls between the verification

616
00:18:39,840 --> 00:18:41,440
and the booting at this point and they

617
00:18:41,440 --> 00:18:42,320
used to be found to be largely

618
00:18:42,320 --> 00:18:43,520
unnecessary to boot android they're

619
00:18:43,520 --> 00:18:45,280
mainly just shopkeeping stuff to keep

620
00:18:45,280 --> 00:18:47,039
everything clean before booting into

621
00:18:47,039 --> 00:18:48,160
android

622
00:18:48,160 --> 00:18:50,000
by removing these i could um overwrite

623
00:18:50,000 --> 00:18:51,200
them with five separate spare

624
00:18:51,200 --> 00:18:53,039
instructions to be patched in and this

625
00:18:53,039 --> 00:18:54,640
would be sufficient for me to swap from

626
00:18:54,640 --> 00:18:57,520
my signed image to my unsigned image

627
00:18:57,520 --> 00:18:59,520
how this would occur was move my pointer

628
00:18:59,520 --> 00:19:01,280
back to the start of my payload which

629
00:19:01,280 --> 00:19:02,480
was the offset

630
00:19:02,480 --> 00:19:05,120
read that offset value and then add that

631
00:19:05,120 --> 00:19:06,960
offset value to my current pointer what

632
00:19:06,960 --> 00:19:09,679
this would do was go from the start of

633
00:19:09,679 --> 00:19:11,280
the point at the start of my original

634
00:19:11,280 --> 00:19:12,640
pointer and jump it straight to my

635
00:19:12,640 --> 00:19:14,400
unsigned image and then what i need to

636
00:19:14,400 --> 00:19:16,240
do is point this new pointer into the

637
00:19:16,240 --> 00:19:18,160
data structure of the image buffer which

638
00:19:18,160 --> 00:19:19,600
would then be executed from the boot

639
00:19:19,600 --> 00:19:21,039
linux function

640
00:19:21,039 --> 00:19:22,160
this would be sufficient to swap the

641
00:19:22,160 --> 00:19:24,400
signed image with the unsigned image and

642
00:19:24,400 --> 00:19:26,000
patching this code and executing in this

643
00:19:26,000 --> 00:19:27,600
manner was effective meaning that i

644
00:19:27,600 --> 00:19:31,919
could bypass these user data protections

645
00:19:31,919 --> 00:19:33,360
so there's a few cool things you can do

646
00:19:33,360 --> 00:19:35,280
with this such as tethered route so

647
00:19:35,280 --> 00:19:37,200
unlocking the bootloader on your phone

648
00:19:37,200 --> 00:19:38,640
wipes all of the user data because you

649
00:19:38,640 --> 00:19:39,919
can't access obviously the encrypted

650
00:19:39,919 --> 00:19:42,240
partition anymore and to stop um

651
00:19:42,240 --> 00:19:44,880
malicious users from accessing old data

652
00:19:44,880 --> 00:19:46,480
permanent routing as well exposes the

653
00:19:46,480 --> 00:19:48,160
device to a much greater risk which we

654
00:19:48,160 --> 00:19:50,000
don't really want

655
00:19:50,000 --> 00:19:52,080
and really permanently rebooting the

656
00:19:52,080 --> 00:19:53,919
device isn't necessarily necessary for

657
00:19:53,919 --> 00:19:56,480
most users in most cases so by deploying

658
00:19:56,480 --> 00:19:57,840
a rooted android image by this time

659
00:19:57,840 --> 00:19:59,200
we've checked to time a fuse attack

660
00:19:59,200 --> 00:20:00,720
these problems could be resolved because

661
00:20:00,720 --> 00:20:02,799
rebooting would um stop executing that

662
00:20:02,799 --> 00:20:05,440
bootloader from ram and load the proper

663
00:20:05,440 --> 00:20:08,080
signed bootloader again and a booler a

664
00:20:08,080 --> 00:20:09,600
android image of this type could be

665
00:20:09,600 --> 00:20:11,440
easily generated just using the amazing

666
00:20:11,440 --> 00:20:13,679
magisk app

667
00:20:13,679 --> 00:20:15,840
um you could also use this to bypass a

668
00:20:15,840 --> 00:20:18,480
user's lock screen by loading into a

669
00:20:18,480 --> 00:20:21,600
recovery partition like tw rp quickly or

670
00:20:21,600 --> 00:20:22,640
by um

671
00:20:22,640 --> 00:20:24,880
running an android image which uh didn't

672
00:20:24,880 --> 00:20:26,480
have these protections or any other

673
00:20:26,480 --> 00:20:27,679
thing you could modify the entire

674
00:20:27,679 --> 00:20:30,640
functionality of the kernel and the low

675
00:20:30,640 --> 00:20:33,200
level root file system using this attack

676
00:20:33,200 --> 00:20:34,799
um temporarily while the phone was

677
00:20:34,799 --> 00:20:36,000
booting

678
00:20:36,000 --> 00:20:37,600
this allows you to bypass all of these

679
00:20:37,600 --> 00:20:40,640
lock screen protections

680
00:20:40,640 --> 00:20:42,640
the last thing you could do was bypass

681
00:20:42,640 --> 00:20:44,320
the encryption on phones at a higher

682
00:20:44,320 --> 00:20:46,000
level so via developer functionality

683
00:20:46,000 --> 00:20:47,039
android phones can add further

684
00:20:47,039 --> 00:20:48,480
encryption requiring you to put in a pin

685
00:20:48,480 --> 00:20:50,799
number or a password um

686
00:20:50,799 --> 00:20:52,559
on boots in order to access the user

687
00:20:52,559 --> 00:20:54,559
data partition so on top of the original

688
00:20:54,559 --> 00:20:55,919
encryption it's already there as

689
00:20:55,919 --> 00:20:58,720
standard this ad this

690
00:20:58,720 --> 00:21:00,720
boot image can be modified still however

691
00:21:00,720 --> 00:21:02,640
because it's not encrypted and you could

692
00:21:02,640 --> 00:21:04,720
then add your own back door for instance

693
00:21:04,720 --> 00:21:06,640
one could modify a boot image so that it

694
00:21:06,640 --> 00:21:09,679
had a brother shell on it um deployed to

695
00:21:09,679 --> 00:21:10,720
the phone and then when the person

696
00:21:10,720 --> 00:21:12,159
unlocked their phone you would have

697
00:21:12,159 --> 00:21:15,440
access to their user data via a shell

698
00:21:15,440 --> 00:21:16,799
just by uploading the image in the same

699
00:21:16,799 --> 00:21:18,400
way as before using this type of time

700
00:21:18,400 --> 00:21:20,880
abuse attack but modifying one of the

701
00:21:20,880 --> 00:21:22,240
init shell scripts in the root file

702
00:21:22,240 --> 00:21:24,400
system to add an interpreter shell one

703
00:21:24,400 --> 00:21:26,080
could just get a temperature this way

704
00:21:26,080 --> 00:21:27,840
obviously it's not entirely a viable

705
00:21:27,840 --> 00:21:31,520
attack but it is quite interesting

706
00:21:31,520 --> 00:21:32,640
this time of checkered time of use

707
00:21:32,640 --> 00:21:34,159
attack was also disclosed to qualcomm

708
00:21:34,159 --> 00:21:36,080
but um we also discussed the fact that

709
00:21:36,080 --> 00:21:37,360
the attack was only possible with this

710
00:21:37,360 --> 00:21:39,360
initial buffer overflow vulnerability so

711
00:21:39,360 --> 00:21:40,799
patching above realflow would mean this

712
00:21:40,799 --> 00:21:42,400
vulnerability would not be possible as

713
00:21:42,400 --> 00:21:43,360
well

714
00:21:43,360 --> 00:21:44,880
um patching the phone to prevent this

715
00:21:44,880 --> 00:21:46,480
attack would also be difficult because

716
00:21:46,480 --> 00:21:49,360
it's uh using uh unmodifiable apis that

717
00:21:49,360 --> 00:21:51,440
can't be changed by either part of the

718
00:21:51,440 --> 00:21:52,960
bootloader that i was modifying for this

719
00:21:52,960 --> 00:21:54,480
particular project

720
00:21:54,480 --> 00:21:56,240
um these weaknesses however could allow

721
00:21:56,240 --> 00:21:57,520
an attack with physical access to get a

722
00:21:57,520 --> 00:21:59,200
huge amount of access to their phones

723
00:21:59,200 --> 00:22:01,919
which they didn't have before

724
00:22:01,919 --> 00:22:03,360
so the second project i'm going to

725
00:22:03,360 --> 00:22:05,440
discuss today is the nxpn series which

726
00:22:05,440 --> 00:22:06,320
is a

727
00:22:06,320 --> 00:22:07,840
series of nfc chips used in both

728
00:22:07,840 --> 00:22:09,840
smartphones and embedded electronics and

729
00:22:09,840 --> 00:22:11,200
by breaking the firmware protections on

730
00:22:11,200 --> 00:22:12,880
these chips one can add new nfc

731
00:22:12,880 --> 00:22:15,039
capabilities to both their smartphone

732
00:22:15,039 --> 00:22:17,280
and their hobbyist product if they had

733
00:22:17,280 --> 00:22:20,000
um enough time and resources to do so

734
00:22:20,000 --> 00:22:22,320
um the nxpc pen series is extremely

735
00:22:22,320 --> 00:22:23,600
popular it's used in millions of

736
00:22:23,600 --> 00:22:25,760
smartphones by bearing manufacturers and

737
00:22:25,760 --> 00:22:27,840
any exploits that i would identify would

738
00:22:27,840 --> 00:22:29,440
probably be transferable across a large

739
00:22:29,440 --> 00:22:32,159
number of smartphones

740
00:22:32,159 --> 00:22:33,880
so i focused on the

741
00:22:33,880 --> 00:22:36,400
nxpn553 which the nfc chip used solely

742
00:22:36,400 --> 00:22:38,320
in mobile devices

743
00:22:38,320 --> 00:22:39,600
and was found to bear strong

744
00:22:39,600 --> 00:22:41,039
similarities between the piano five or

745
00:22:41,039 --> 00:22:43,280
seven p and five right p and five iphone

746
00:22:43,280 --> 00:22:45,039
and the piano five one eight zero they

747
00:22:45,039 --> 00:22:46,720
all use similar firmware update files

748
00:22:46,720 --> 00:22:49,039
and protocols they all use the cortex

749
00:22:49,039 --> 00:22:50,240
architecture and they all had very

750
00:22:50,240 --> 00:22:52,480
little republic research available there

751
00:22:52,480 --> 00:22:54,240
were other chips in the series like the

752
00:22:54,240 --> 00:22:57,280
pn544 which uh didn't have um arm

753
00:22:57,280 --> 00:22:59,200
processors and used things like 8051 but

754
00:22:59,200 --> 00:23:00,559
i didn't focus on them for this partic

755
00:23:00,559 --> 00:23:03,440
particular project

756
00:23:03,440 --> 00:23:05,360
so on smartphones these chips are

757
00:23:05,360 --> 00:23:07,360
confused communicated with by the itc in

758
00:23:07,360 --> 00:23:11,600
face at a dev nq nci um which uses um

759
00:23:11,600 --> 00:23:13,360
standard i2c communication sent over

760
00:23:13,360 --> 00:23:16,000
this interface um by sending this

761
00:23:16,000 --> 00:23:17,600
standard nci protocol which is a

762
00:23:17,600 --> 00:23:19,679
standard protocol used for nfc

763
00:23:19,679 --> 00:23:21,440
smartphone chips and other smartphone

764
00:23:21,440 --> 00:23:24,240
nfc chips or rather an embedded nfc

765
00:23:24,240 --> 00:23:26,000
chips but then it also used a custom

766
00:23:26,000 --> 00:23:28,400
protocol for former firmware updates

767
00:23:28,400 --> 00:23:30,480
communication uh all these firmware

768
00:23:30,480 --> 00:23:31,679
updates and communications could be

769
00:23:31,679 --> 00:23:33,360
performed using adb logcat just on a

770
00:23:33,360 --> 00:23:35,039
standard smartphone but i was using a

771
00:23:35,039 --> 00:23:36,559
rooted one for this process to access

772
00:23:36,559 --> 00:23:38,960
the hardware

773
00:23:38,960 --> 00:23:41,120
um tracing the firmware updates can be

774
00:23:41,120 --> 00:23:42,240
very helpful in understanding the

775
00:23:42,240 --> 00:23:43,520
protocol without having to read too much

776
00:23:43,520 --> 00:23:45,919
source code um and i found that the

777
00:23:45,919 --> 00:23:47,120
firmware updates would only occur if the

778
00:23:47,120 --> 00:23:49,360
two signed firmware versions on the

779
00:23:49,360 --> 00:23:51,200
firmware updates differed and as there

780
00:23:51,200 --> 00:23:53,120
were two firmware updates in the file

781
00:23:53,120 --> 00:23:54,640
system of the phone i was using in the

782
00:23:54,640 --> 00:23:57,919
pn553 firmware and rec so i could swap

783
00:23:57,919 --> 00:23:59,039
these in order to force a firmware

784
00:23:59,039 --> 00:24:00,880
update to occur and trace how it worked

785
00:24:00,880 --> 00:24:02,400
i could also trace some of the functions

786
00:24:02,400 --> 00:24:03,600
and commands against the available

787
00:24:03,600 --> 00:24:06,000
source code

788
00:24:06,000 --> 00:24:07,679
so the firmware update is quite unique

789
00:24:07,679 --> 00:24:09,760
to on xp chipset consists of a one byte

790
00:24:09,760 --> 00:24:11,279
status a one byte size a one byte

791
00:24:11,279 --> 00:24:13,279
command um a variable length of

792
00:24:13,279 --> 00:24:15,840
parameters and a crc16 value and these

793
00:24:15,840 --> 00:24:17,840
can be encapsulated

794
00:24:17,840 --> 00:24:19,679
oxfc byte chunks for large payloads

795
00:24:19,679 --> 00:24:20,880
meaning that the large payloads we'll be

796
00:24:20,880 --> 00:24:22,400
discussing later could be fit into those

797
00:24:22,400 --> 00:24:26,480
small sizes as just encapsulated data

798
00:24:26,480 --> 00:24:29,440
reason writes the devnqci trans um were

799
00:24:29,440 --> 00:24:30,559
found to translate communication

800
00:24:30,559 --> 00:24:34,799
directly to i2c and io controls on the

801
00:24:34,799 --> 00:24:36,799
chip would be used to

802
00:24:36,799 --> 00:24:38,799
swap between power modes from off on and

803
00:24:38,799 --> 00:24:41,120
boot loader mode

804
00:24:41,120 --> 00:24:42,799
the firmware file format was found to be

805
00:24:42,799 --> 00:24:45,520
an l file but more of a library to be

806
00:24:45,520 --> 00:24:47,360
honest because the file only had one

807
00:24:47,360 --> 00:24:48,799
sector which contained a lot of binary

808
00:24:48,799 --> 00:24:51,120
formatted data that wasn't executable

809
00:24:51,120 --> 00:24:52,960
and the data was actually the commands

810
00:24:52,960 --> 00:24:54,159
that need to be run for a firmware

811
00:24:54,159 --> 00:24:56,080
update in sequence for firmware updates

812
00:24:56,080 --> 00:24:57,760
and these commands could be extracted to

813
00:24:57,760 --> 00:24:59,520
rebuild rebuild the firmware image as it

814
00:24:59,520 --> 00:25:01,840
was unencrypted

815
00:25:01,840 --> 00:25:03,279
the co write command was found to be

816
00:25:03,279 --> 00:25:04,640
used throughout this process the first

817
00:25:04,640 --> 00:25:06,080
command was uh

818
00:25:06,080 --> 00:25:08,000
found to contain unknown high entry data

819
00:25:08,000 --> 00:25:10,640
including a hash and a signature and all

820
00:25:10,640 --> 00:25:12,400
subsequent commands were found to

821
00:25:12,400 --> 00:25:15,120
contain a 24-bit address a 16-bit size

822
00:25:15,120 --> 00:25:16,559
and the data payload followed by an

823
00:25:16,559 --> 00:25:18,559
unknown hash these commands were found

824
00:25:18,559 --> 00:25:20,880
to be required to be performed in a very

825
00:25:20,880 --> 00:25:22,799
specific sequence which was the sequence

826
00:25:22,799 --> 00:25:24,159
they were found in the file otherwise

827
00:25:24,159 --> 00:25:25,919
they wouldn't execute and the whole

828
00:25:25,919 --> 00:25:28,960
update process would fail

829
00:25:28,960 --> 00:25:30,400
the memory dressers the twenty football

830
00:25:30,400 --> 00:25:31,919
bit ones at the start commands uh aided

831
00:25:31,919 --> 00:25:33,360
in reconstructing the firmware but i

832
00:25:33,360 --> 00:25:34,640
found that the firmware data was

833
00:25:34,640 --> 00:25:36,159
extremely small not covering everything

834
00:25:36,159 --> 00:25:38,240
that would be required with an nfc chip

835
00:25:38,240 --> 00:25:40,000
there are also multiple code references

836
00:25:40,000 --> 00:25:41,840
in there which were in an accessible

837
00:25:41,840 --> 00:25:43,840
memory regions that were likely to be in

838
00:25:43,840 --> 00:25:46,080
the bootloader as sort of like um core

839
00:25:46,080 --> 00:25:49,360
libraries for the device to function

840
00:25:49,360 --> 00:25:50,799
uh two commands were found to read back

841
00:25:50,799 --> 00:25:53,600
memory from the chip a2 and e0 a2 was a

842
00:25:53,600 --> 00:25:54,640
standard command which allowed you to

843
00:25:54,640 --> 00:25:56,159
read back arbitrary memory but only

844
00:25:56,159 --> 00:25:57,919
memory that was also allowed to be

845
00:25:57,919 --> 00:25:59,279
written to for firmware updates which is

846
00:25:59,279 --> 00:26:01,520
limited to a very small address space

847
00:26:01,520 --> 00:26:03,120
and these area is found to

848
00:26:03,120 --> 00:26:04,480
calculate a checksum of memory and

849
00:26:04,480 --> 00:26:07,279
provide a four byte um bit of configure

850
00:26:07,279 --> 00:26:08,880
pi piece of configuration data back

851
00:26:08,880 --> 00:26:10,000
which could be stitched together by

852
00:26:10,000 --> 00:26:12,080
sending incrementing addresses to this

853
00:26:12,080 --> 00:26:13,600
command in order to generate the whole

854
00:26:13,600 --> 00:26:15,679
payload

855
00:26:15,679 --> 00:26:17,919
this included a large block of random

856
00:26:17,919 --> 00:26:21,440
data in this memory dump over size oxc0

857
00:26:21,440 --> 00:26:23,360
followed by the value one zero zero zero

858
00:26:23,360 --> 00:26:26,559
one which was um likely to be the rsa

859
00:26:26,559 --> 00:26:28,320
exponent used by the rsa public key here

860
00:26:28,320 --> 00:26:30,799
so the large bit of uh high entropy data

861
00:26:30,799 --> 00:26:33,200
was likely to be the public key here

862
00:26:33,200 --> 00:26:34,960
this size they did not identifying the

863
00:26:34,960 --> 00:26:36,400
signature algorithms that were probably

864
00:26:36,400 --> 00:26:39,440
used as part of the firmware update

865
00:26:39,440 --> 00:26:40,880
um there was an unknown hash at the

866
00:26:40,880 --> 00:26:42,320
start end of every block that i couldn't

867
00:26:42,320 --> 00:26:44,240
work out um which i assumed to be

868
00:26:44,240 --> 00:26:45,840
sha-256 to start with but it didn't

869
00:26:45,840 --> 00:26:47,039
match the contents of the packet that

870
00:26:47,039 --> 00:26:48,480
was being sent

871
00:26:48,480 --> 00:26:50,080
i tried multiple other hashing

872
00:26:50,080 --> 00:26:51,840
algorithms however these had no valid

873
00:26:51,840 --> 00:26:53,840
results and it just wouldn't work if i

874
00:26:53,840 --> 00:26:55,600
um verified this against any of the data

875
00:26:55,600 --> 00:26:57,520
however i later identified that the hash

876
00:26:57,520 --> 00:26:59,360
was for the next block in the sequence

877
00:26:59,360 --> 00:27:01,360
so um we'll be discussing how that works

878
00:27:01,360 --> 00:27:02,640
now

879
00:27:02,640 --> 00:27:04,320
so the first co command consists of a

880
00:27:04,320 --> 00:27:06,960
version number a sha256 hash and then a

881
00:27:06,960 --> 00:27:08,799
signature of that hash and the version

882
00:27:08,799 --> 00:27:11,039
number this is a hash of the next block

883
00:27:11,039 --> 00:27:13,039
which also contains a hash and this sort

884
00:27:13,039 --> 00:27:15,440
of cascades around the firmware update

885
00:27:15,440 --> 00:27:17,520
so that all of the hashes has to match

886
00:27:17,520 --> 00:27:19,200
as it goes along for the next one in the

887
00:27:19,200 --> 00:27:20,720
sequence and

888
00:27:20,720 --> 00:27:23,520
um meaning that you were forced to that

889
00:27:23,520 --> 00:27:25,360
only blocks a written device would be

890
00:27:25,360 --> 00:27:27,200
valid and they wouldn't write invalid

891
00:27:27,200 --> 00:27:30,240
data blocks to the chip so as each

892
00:27:30,240 --> 00:27:32,080
sequence went along the sha-256 would be

893
00:27:32,080 --> 00:27:33,919
verified and it if it wasn't valid the

894
00:27:33,919 --> 00:27:35,840
sequence would stop there however i did

895
00:27:35,840 --> 00:27:37,840
notice that the final black had no hash

896
00:27:37,840 --> 00:27:41,039
um because i had no subsequent block

897
00:27:41,039 --> 00:27:42,640
i performed some targeted fuzzing during

898
00:27:42,640 --> 00:27:43,679
this process it was a much longer

899
00:27:43,679 --> 00:27:44,799
process than it sounds his trying to

900
00:27:44,799 --> 00:27:46,399
reverse engineer this chip

901
00:27:46,399 --> 00:27:47,520
and i did this both on the firmware

902
00:27:47,520 --> 00:27:49,520
update protocol and the nci interfaces

903
00:27:49,520 --> 00:27:51,440
and i found that the chip itself in the

904
00:27:51,440 --> 00:27:53,679
firmware side had a bunch of hidden

905
00:27:53,679 --> 00:27:55,279
vendor specific configurations which

906
00:27:55,279 --> 00:27:57,279
could be accessed via the nci config

907
00:27:57,279 --> 00:27:58,399
right command

908
00:27:58,399 --> 00:28:00,320
by incrementing a bit wise value um to

909
00:28:00,320 --> 00:28:02,640
these configurations um

910
00:28:02,640 --> 00:28:04,960
was uh performed in order to see how

911
00:28:04,960 --> 00:28:06,000
this would change how the chip

912
00:28:06,000 --> 00:28:07,600
functioned but what this ended up doing

913
00:28:07,600 --> 00:28:09,200
was bricking the core functionality of

914
00:28:09,200 --> 00:28:10,880
the chip so the bootloader would still

915
00:28:10,880 --> 00:28:13,200
function but the core firmware would not

916
00:28:13,200 --> 00:28:15,360
and i couldn't overwrite the firmware

917
00:28:15,360 --> 00:28:17,279
these particular configurations from the

918
00:28:17,279 --> 00:28:19,840
bootloader either

919
00:28:19,840 --> 00:28:21,279
however i decided to persevere with the

920
00:28:21,279 --> 00:28:22,320
bootloader decide to see if i could

921
00:28:22,320 --> 00:28:24,799
break past this limitation it was noted

922
00:28:24,799 --> 00:28:26,159
that the last block of the firmware was

923
00:28:26,159 --> 00:28:28,320
um written multiple time able to be

924
00:28:28,320 --> 00:28:29,440
written multiple times so i could send

925
00:28:29,440 --> 00:28:31,120
the last block which had no hash

926
00:28:31,120 --> 00:28:32,480
constantly and there'd be no problems

927
00:28:32,480 --> 00:28:33,840
with that meaning that it was likely

928
00:28:33,840 --> 00:28:35,679
that the hash of the previous block

929
00:28:35,679 --> 00:28:36,960
which was used for verification of this

930
00:28:36,960 --> 00:28:39,440
block was remained in memory constantly

931
00:28:39,440 --> 00:28:40,559
this meant that there's a potential

932
00:28:40,559 --> 00:28:42,000
opportunity for overwriting the hashing

933
00:28:42,000 --> 00:28:44,159
memory just by potentially sending

934
00:28:44,159 --> 00:28:45,919
corrupted commands that wasn't a right

935
00:28:45,919 --> 00:28:47,200
sequence command

936
00:28:47,200 --> 00:28:48,880
um and this was attempted so i sent an

937
00:28:48,880 --> 00:28:51,200
invalid command of e0 the same size of

938
00:28:51,200 --> 00:28:52,799
the firmware so a big empty block

939
00:28:52,799 --> 00:28:55,600
followed by a um corrupted sha-256 hash

940
00:28:55,600 --> 00:28:57,760
at the end and to see what would happen

941
00:28:57,760 --> 00:28:59,440
at the end this prevented the last block

942
00:28:59,440 --> 00:29:01,039
from being written implying that over in

943
00:29:01,039 --> 00:29:03,919
the hash in memory

944
00:29:04,240 --> 00:29:06,799
modified hashes could be written

945
00:29:06,799 --> 00:29:08,080
in the right portion of memory for this

946
00:29:08,080 --> 00:29:10,399
process in order to write

947
00:29:10,399 --> 00:29:12,159
uh unverified and unsight dangerous this

948
00:29:12,159 --> 00:29:14,960
process as long as the shah 256 hash

949
00:29:14,960 --> 00:29:16,799
implemented in this militia this

950
00:29:16,799 --> 00:29:19,279
modified packet was correct

951
00:29:19,279 --> 00:29:21,600
i could write into memory and then write

952
00:29:21,600 --> 00:29:23,919
the matching block to it no matter what

953
00:29:23,919 --> 00:29:24,799
it was

954
00:29:24,799 --> 00:29:25,919
this essentially allowed me to write

955
00:29:25,919 --> 00:29:27,360
arbitrary memory blocks over the code

956
00:29:27,360 --> 00:29:28,960
that was already there and bypass all of

957
00:29:28,960 --> 00:29:30,559
the signature verification mechanisms in

958
00:29:30,559 --> 00:29:32,240
firmware updates allowing me to

959
00:29:32,240 --> 00:29:35,039
overwrite the broken config as well

960
00:29:35,039 --> 00:29:36,640
so using a dump of the working config

961
00:29:36,640 --> 00:29:37,679
which i got at the start of this whole

962
00:29:37,679 --> 00:29:39,600
reverse engineering process

963
00:29:39,600 --> 00:29:40,399
i could

964
00:29:40,399 --> 00:29:41,919
generate a hash for the new config and

965
00:29:41,919 --> 00:29:43,600
overwrite it in the correct place

966
00:29:43,600 --> 00:29:45,200
this repaired the chip and it proved

967
00:29:45,200 --> 00:29:46,880
that arbitrary memory rights were

968
00:29:46,880 --> 00:29:48,480
functioning as wanted

969
00:29:48,480 --> 00:29:50,320
but this was only the start and i wanted

970
00:29:50,320 --> 00:29:51,600
to dump the bootloader from the chip to

971
00:29:51,600 --> 00:29:54,799
get a full overview of how it worked

972
00:29:54,799 --> 00:29:56,320
so all standard functions including mem

973
00:29:56,320 --> 00:29:57,840
copies and string compies and things

974
00:29:57,840 --> 00:29:59,360
like that were stored in the bootloader

975
00:29:59,360 --> 00:30:00,640
with limited functionality and natural

976
00:30:00,640 --> 00:30:02,880
firmware update however the nci version

977
00:30:02,880 --> 00:30:04,320
number command which was part of the

978
00:30:04,320 --> 00:30:06,240
firmware update was found to be there

979
00:30:06,240 --> 00:30:08,320
and jumped into from the core bootloader

980
00:30:08,320 --> 00:30:10,640
into this function as part of the main

981
00:30:10,640 --> 00:30:13,039
foot and we're running um this version

982
00:30:13,039 --> 00:30:14,399
number was easy to identify memory just

983
00:30:14,399 --> 00:30:16,320
by buying research and save its function

984
00:30:16,320 --> 00:30:18,799
references that um accessed it

985
00:30:18,799 --> 00:30:20,640
i found a function was called using this

986
00:30:20,640 --> 00:30:23,120
version number and the pointer um and i

987
00:30:23,120 --> 00:30:24,799
decided that this was likely to be a mem

988
00:30:24,799 --> 00:30:26,320
copy function

989
00:30:26,320 --> 00:30:28,640
and if i wrote this i could identify how

990
00:30:28,640 --> 00:30:30,880
this worked

991
00:30:30,880 --> 00:30:32,720
so the branch instructions this mem copy

992
00:30:32,720 --> 00:30:34,000
function can be overwritten to point to

993
00:30:34,000 --> 00:30:35,760
a custom function which i wanted to

994
00:30:35,760 --> 00:30:38,640
write in c so using c in the gcc-c flag

995
00:30:38,640 --> 00:30:40,240
i could write a custom empty function

996
00:30:40,240 --> 00:30:42,000
which could be then modified as i went

997
00:30:42,000 --> 00:30:43,360
along the process in order to change how

998
00:30:43,360 --> 00:30:44,559
this functioned

999
00:30:44,559 --> 00:30:46,000
its effect on the version number command

1000
00:30:46,000 --> 00:30:47,679
could be observed after flashing and see

1001
00:30:47,679 --> 00:30:49,919
what was going on and the lack of data

1002
00:30:49,919 --> 00:30:51,279
and response after sending this empty

1003
00:30:51,279 --> 00:30:53,360
function implied that the mem copy was

1004
00:30:53,360 --> 00:30:55,440
actually a mem copy for responses from

1005
00:30:55,440 --> 00:30:57,360
the nci version number command which i

1006
00:30:57,360 --> 00:30:59,919
could then leverage further

1007
00:30:59,919 --> 00:31:02,159
the location of ram was i um assumed to

1008
00:31:02,159 --> 00:31:04,000
be at one zero zero zero due to the

1009
00:31:04,000 --> 00:31:05,519
firmware referencing this address space

1010
00:31:05,519 --> 00:31:07,679
right reads and writes and the overhead

1011
00:31:07,679 --> 00:31:09,279
mem copy was changed to search for a new

1012
00:31:09,279 --> 00:31:12,159
leak value in ram so when i sent the nci

1013
00:31:12,159 --> 00:31:14,480
version number command i modified it to

1014
00:31:14,480 --> 00:31:16,159
contain the value f a c

1015
00:31:16,159 --> 00:31:17,440
f a c

1016
00:31:17,440 --> 00:31:19,760
this uh provided a global pointer in

1017
00:31:19,760 --> 00:31:22,080
memory at one zero zero zero seven so

1018
00:31:22,080 --> 00:31:23,840
right to the start of this ram which i

1019
00:31:23,840 --> 00:31:27,200
could then modify to um get that value

1020
00:31:27,200 --> 00:31:28,640
as an arbitrary point which i could then

1021
00:31:28,640 --> 00:31:30,399
to use to dump arbitrary data from the

1022
00:31:30,399 --> 00:31:33,600
chip allowing me to dump the bootloader

1023
00:31:33,600 --> 00:31:35,440
so with this and rebooting the chip

1024
00:31:35,440 --> 00:31:37,039
while sending this nci command i could

1025
00:31:37,039 --> 00:31:38,399
stitch the bootloader back together

1026
00:31:38,399 --> 00:31:40,320
again and then disassemble it in either

1027
00:31:40,320 --> 00:31:42,480
demonstrating that this was a valid read

1028
00:31:42,480 --> 00:31:43,840
this functionality could be extended

1029
00:31:43,840 --> 00:31:45,679
further if i wanted to to modify the

1030
00:31:45,679 --> 00:31:47,360
core nfc functionality of the chip

1031
00:31:47,360 --> 00:31:48,559
however at this point i would just want

1032
00:31:48,559 --> 00:31:50,640
to disclose it because it's quite a high

1033
00:31:50,640 --> 00:31:53,360
risk vulnerability for this chip

1034
00:31:53,360 --> 00:31:54,799
um i wanted to replicate it further as

1035
00:31:54,799 --> 00:31:57,360
well including on the pn5180 which is a

1036
00:31:57,360 --> 00:31:59,200
chip often used by hobbyists for nfc

1037
00:31:59,200 --> 00:32:00,480
connectivity

1038
00:32:00,480 --> 00:32:02,640
it has a similar architecture to the

1039
00:32:02,640 --> 00:32:05,120
pm503 in both the firmware updates

1040
00:32:05,120 --> 00:32:07,760
and the actual cpu architecture however

1041
00:32:07,760 --> 00:32:10,080
it used a custom communication protocol

1042
00:32:10,080 --> 00:32:10,799
for

1043
00:32:10,799 --> 00:32:12,799
communication over the spi interface

1044
00:32:12,799 --> 00:32:14,080
provided and i connected it to a

1045
00:32:14,080 --> 00:32:16,399
raspberry pi to mod uh modify its

1046
00:32:16,399 --> 00:32:17,840
functionality

1047
00:32:17,840 --> 00:32:19,440
um the firmware update process was the

1048
00:32:19,440 --> 00:32:21,039
same but it did have a buy to the start

1049
00:32:21,039 --> 00:32:22,000
that was different which was used for

1050
00:32:22,000 --> 00:32:23,600
read and writes but that was largely

1051
00:32:23,600 --> 00:32:25,360
superficial however this meant that i

1052
00:32:25,360 --> 00:32:27,039
could um perform the entire signature

1053
00:32:27,039 --> 00:32:30,159
bypass again in the same way

1054
00:32:30,159 --> 00:32:31,519
um i wanted to dump the bootloader from

1055
00:32:31,519 --> 00:32:33,440
this chip as well so i

1056
00:32:33,440 --> 00:32:34,399
used a command in the chips

1057
00:32:34,399 --> 00:32:36,480
communication protocol which read

1058
00:32:36,480 --> 00:32:38,080
arbitrary memory from an eeprom pointer

1059
00:32:38,080 --> 00:32:40,159
which was stored in the firmware and

1060
00:32:40,159 --> 00:32:41,679
modified this to point to different

1061
00:32:41,679 --> 00:32:44,159
arbitrary memory in large blocks so by

1062
00:32:44,159 --> 00:32:45,600
overwriting this and redeploying the

1063
00:32:45,600 --> 00:32:47,360
firmware after modifying this pointer i

1064
00:32:47,360 --> 00:32:48,720
could then read that part of memory

1065
00:32:48,720 --> 00:32:50,080
re-deploy the firmware and do this over

1066
00:32:50,080 --> 00:32:51,760
and over again to stitch the

1067
00:32:51,760 --> 00:32:53,120
eeprom back together this would be a

1068
00:32:53,120 --> 00:32:54,559
slow process but it would demonstrate

1069
00:32:54,559 --> 00:32:55,840
that i could dump this bootloader and

1070
00:32:55,840 --> 00:32:58,320
analyze it

1071
00:32:58,320 --> 00:33:00,080
um this vulnerability was likely to be

1072
00:33:00,080 --> 00:33:01,760
also vulnerable and they are

1073
00:33:01,760 --> 00:33:05,679
available on the pn547 pn548 and pn551

1074
00:33:05,679 --> 00:33:07,200
among others

1075
00:33:07,200 --> 00:33:09,200
and this chip allows an attacker with

1076
00:33:09,200 --> 00:33:10,799
access to firmware updates either by the

1077
00:33:10,799 --> 00:33:13,039
hobbyist project or via root access on

1078
00:33:13,039 --> 00:33:14,480
their phone to completely take over the

1079
00:33:14,480 --> 00:33:16,000
functionality of the chip

1080
00:33:16,000 --> 00:33:17,919
um this will provide some custom

1081
00:33:17,919 --> 00:33:19,679
functionality but um not a huge amount

1082
00:33:19,679 --> 00:33:20,960
of malicious stuff could be done with

1083
00:33:20,960 --> 00:33:23,120
this apart from very specific spoofing

1084
00:33:23,120 --> 00:33:25,039
capabilities on the nfc chip

1085
00:33:25,039 --> 00:33:26,480
um on smartphones this would require

1086
00:33:26,480 --> 00:33:27,600
root access

1087
00:33:27,600 --> 00:33:30,159
as stated um which would be quite

1088
00:33:30,159 --> 00:33:32,080
difficult to perform to perform any

1089
00:33:32,080 --> 00:33:33,600
backdoor attacks on this particular chip

1090
00:33:33,600 --> 00:33:35,039
and there'd be much better things you

1091
00:33:35,039 --> 00:33:36,799
can do at that time however in hobbyist

1092
00:33:36,799 --> 00:33:38,360
projects this would expand the

1093
00:33:38,360 --> 00:33:40,480
capabilities of the chip really far and

1094
00:33:40,480 --> 00:33:42,320
give you a lot more control over how the

1095
00:33:42,320 --> 00:33:44,799
chip worked for you

1096
00:33:44,799 --> 00:33:46,399
um the vulnerability was disclosed to

1097
00:33:46,399 --> 00:33:48,559
nxp in june 2020 and they confirmed that

1098
00:33:48,559 --> 00:33:49,760
it affected multiple chips in their

1099
00:33:49,760 --> 00:33:51,600
product line and they request a long

1100
00:33:51,600 --> 00:33:54,240
remediation period up to august 2021

1101
00:33:54,240 --> 00:33:56,080
which i agreed to due to the fact that

1102
00:33:56,080 --> 00:33:57,519
this would require alteration of the

1103
00:33:57,519 --> 00:33:59,200
primary bootloader on a bunch of

1104
00:33:59,200 --> 00:34:01,200
different chips which is a complex thing

1105
00:34:01,200 --> 00:34:02,559
when you're trying to replace the

1106
00:34:02,559 --> 00:34:04,720
bootloader from the firmware on any kind

1107
00:34:04,720 --> 00:34:06,399
of chip you're running the risk that

1108
00:34:06,399 --> 00:34:07,760
there'll be a power cut or something

1109
00:34:07,760 --> 00:34:09,440
will go wrong and that chip will be

1110
00:34:09,440 --> 00:34:11,040
irrevocably

1111
00:34:11,040 --> 00:34:12,879
irrevocably broken so the phone will

1112
00:34:12,879 --> 00:34:13,760
never

1113
00:34:13,760 --> 00:34:16,239
have nfc capabilities or again and

1114
00:34:16,239 --> 00:34:17,760
because of this um

1115
00:34:17,760 --> 00:34:19,359
they did it in phase rollouts which was

1116
00:34:19,359 --> 00:34:20,480
the right approach

1117
00:34:20,480 --> 00:34:21,760
and

1118
00:34:21,760 --> 00:34:23,918
as they went along the vulnerability was

1119
00:34:23,918 --> 00:34:26,239
patched um the current generation of nxp

1120
00:34:26,239 --> 00:34:28,000
chips including the sn series are not

1121
00:34:28,000 --> 00:34:29,040
affected due to the fact they have

1122
00:34:29,040 --> 00:34:30,719
higher security and some of them

1123
00:34:30,719 --> 00:34:32,480
implement encryption on top of the

1124
00:34:32,480 --> 00:34:34,719
signing which means that memory handling

1125
00:34:34,719 --> 00:34:36,079
is just completely different and also i

1126
00:34:36,079 --> 00:34:37,918
think the bootloader has been changed

1127
00:34:37,918 --> 00:34:39,520
sufficiently that this vulnerability is

1128
00:34:39,520 --> 00:34:42,079
just no longer present on modern nxp nfc

1129
00:34:42,079 --> 00:34:44,000
chips

1130
00:34:44,000 --> 00:34:45,679
special thanks to qualcomm and xp for

1131
00:34:45,679 --> 00:34:47,280
remediating the findings and this being

1132
00:34:47,280 --> 00:34:49,280
very verbose with me about how the

1133
00:34:49,280 --> 00:34:50,639
processes were going they were both

1134
00:34:50,639 --> 00:34:52,159
extremely helpful in helping me

1135
00:34:52,159 --> 00:34:53,440
understand what they were doing in order

1136
00:34:53,440 --> 00:34:56,719
to read their uh the findings and they

1137
00:34:56,719 --> 00:34:58,240
were very communicative throughout the

1138
00:34:58,240 --> 00:34:59,520
entire process

1139
00:34:59,520 --> 00:35:01,280
um for my signature protections are only

1140
00:35:01,280 --> 00:35:03,440
as good as their implementation so if

1141
00:35:03,440 --> 00:35:05,359
there's a small weakness such as the

1142
00:35:05,359 --> 00:35:07,200
buffer overflow or

1143
00:35:07,200 --> 00:35:08,720
even something smaller sometimes like a

1144
00:35:08,720 --> 00:35:10,400
cryptographic weakness

1145
00:35:10,400 --> 00:35:11,920
these things can be bypassed in order to

1146
00:35:11,920 --> 00:35:14,800
generate your own uh firmware payloads

1147
00:35:14,800 --> 00:35:16,320
common ships are still great targets for

1148
00:35:16,320 --> 00:35:18,000
this as they have impact and some people

1149
00:35:18,000 --> 00:35:20,400
assume that these are already um secure

1150
00:35:20,400 --> 00:35:21,920
because they've got so many eyes on them

1151
00:35:21,920 --> 00:35:23,760
but this isn't always the case

1152
00:35:23,760 --> 00:35:25,440
um bootloader vulnerabilities are common

1153
00:35:25,440 --> 00:35:27,440
even in popular hardware

1154
00:35:27,440 --> 00:35:31,800
and that's the end thank you very much

