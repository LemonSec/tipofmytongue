1
00:00:01,130 --> 00:00:14,239
[Music]

2
00:00:14,240 --> 00:00:17,279
hello everyone welcome to our talk hack

3
00:00:17,279 --> 00:00:20,080
different pumping ios 14 with generation

4
00:00:20,080 --> 00:00:22,400
z bugs

5
00:00:22,400 --> 00:00:24,800
this talk is brought to you by jojo and

6
00:00:24,800 --> 00:00:27,199
xi jin dong

7
00:00:27,199 --> 00:00:29,679
this is the agenda the talk is mainly

8
00:00:29,679 --> 00:00:33,040
about two bugs used on tempo cup 2020 on

9
00:00:33,040 --> 00:00:35,600
iphone category this is the very first

10
00:00:35,600 --> 00:00:38,239
successful public challenge after park

11
00:00:38,239 --> 00:00:39,840
has been introduced

12
00:00:39,840 --> 00:00:41,840
we will cover materials from attack

13
00:00:41,840 --> 00:00:44,800
surface to the bug and detail steps of

14
00:00:44,800 --> 00:00:47,440
exploitation

15
00:00:47,440 --> 00:00:51,760
now meet this new old attack surface

16
00:00:51,760 --> 00:00:53,840
my previous presentation on black hat

17
00:00:53,840 --> 00:00:56,559
europe 2020 talk about several effective

18
00:00:56,559 --> 00:00:58,719
cases that leverage inter-process

19
00:00:58,719 --> 00:01:01,359
javascript injection to escape safari

20
00:01:01,359 --> 00:01:03,600
sandbox on mac os

21
00:01:03,600 --> 00:01:06,000
it's possible to directly bypass the

22
00:01:06,000 --> 00:01:08,880
sandbox without initial code execution

23
00:01:08,880 --> 00:01:12,720
just by abusing url scheme

24
00:01:12,720 --> 00:01:15,840
url scheme is a vector for web to app

25
00:01:15,840 --> 00:01:17,119
navigation

26
00:01:17,119 --> 00:01:19,680
safari has a trusted list that don't

27
00:01:19,680 --> 00:01:22,320
require user action to automatically

28
00:01:22,320 --> 00:01:23,680
open an app

29
00:01:23,680 --> 00:01:26,479
including app store mail and digital

30
00:01:26,479 --> 00:01:28,640
contents from itunes

31
00:01:28,640 --> 00:01:31,840
and this applies to ios 2.

32
00:01:31,840 --> 00:01:35,479
what we were targeting is this

33
00:01:35,479 --> 00:01:38,560
com.apple.mobile store

34
00:01:38,560 --> 00:01:40,479
it was actually not the first time that

35
00:01:40,479 --> 00:01:43,600
this pre-installed app got abused

36
00:01:43,600 --> 00:01:46,320
on mobile.com 2014

37
00:01:46,320 --> 00:01:50,079
loki used this itm ss url to directly

38
00:01:50,079 --> 00:01:53,439
open a third-party website in ios app

39
00:01:53,439 --> 00:01:56,479
where no sandbox was applied

40
00:01:56,479 --> 00:02:02,840
it was assigned with cve 2014 aa40

41
00:02:03,520 --> 00:02:07,439
since that a trust list was applied

42
00:02:07,439 --> 00:02:10,080
before the navigation itunes store

43
00:02:10,080 --> 00:02:13,200
downloads a list of trusted domains from

44
00:02:13,200 --> 00:02:14,000
this

45
00:02:14,000 --> 00:02:17,000
sandbox.itunes.apple.com

46
00:02:17,599 --> 00:02:18,480
and

47
00:02:18,480 --> 00:02:21,360
reads out the trusted domains list

48
00:02:21,360 --> 00:02:24,400
and compares the url with that

49
00:02:24,400 --> 00:02:27,920
besides it only accepts https and has

50
00:02:27,920 --> 00:02:29,680
ssl pinning

51
00:02:29,680 --> 00:02:31,680
but loki lately found a process

52
00:02:31,680 --> 00:02:33,959
scripting on

53
00:02:33,959 --> 00:02:36,160
widgets.itunes.apple.com to pawn it

54
00:02:36,160 --> 00:02:38,400
again

55
00:02:39,200 --> 00:02:42,720
now let's meet the first bug

56
00:02:42,720 --> 00:02:45,120
generation z is used to describe kids

57
00:02:45,120 --> 00:02:49,599
born between mid to late 1990s and early

58
00:02:49,599 --> 00:02:52,080
19 2010

59
00:02:52,080 --> 00:02:54,560
the bugs were both introduced before

60
00:02:54,560 --> 00:02:56,239
2012

61
00:02:56,239 --> 00:03:00,319
so they happened to be part of it

62
00:03:00,560 --> 00:03:04,000
this first box could affect a wide range

63
00:03:04,000 --> 00:03:06,159
of ios versions

64
00:03:06,159 --> 00:03:08,319
and it's easy to exploit

65
00:03:08,319 --> 00:03:10,560
so part of the proof of concept is

66
00:03:10,560 --> 00:03:13,920
redacted to help protect users that stay

67
00:03:13,920 --> 00:03:14,879
below

68
00:03:14,879 --> 00:03:18,560
ios 14.3 due to hardware limitations or

69
00:03:18,560 --> 00:03:20,480
at the will

70
00:03:20,480 --> 00:03:22,480
let's go back to itunes store by

71
00:03:22,480 --> 00:03:24,319
auditing the following methods we found

72
00:03:24,319 --> 00:03:26,799
another bypass this is an url first

73
00:03:26,799 --> 00:03:29,760
supported by ios 3. the difference is

74
00:03:29,760 --> 00:03:32,000
that it still requires the domain to be

75
00:03:32,000 --> 00:03:33,200
trusted

76
00:03:33,200 --> 00:03:35,519
but the url of the page is not limited

77
00:03:35,519 --> 00:03:38,959
to https making it

78
00:03:38,959 --> 00:03:39,920
capable

79
00:03:39,920 --> 00:03:41,760
making it vulnerable to men in the

80
00:03:41,760 --> 00:03:44,239
middle attack

81
00:03:44,239 --> 00:03:47,440
this url is simply itms double slash and

82
00:03:47,440 --> 00:03:49,840
some part of it is redacted then we

83
00:03:49,840 --> 00:03:52,319
append the parameter name url it will

84
00:03:52,319 --> 00:03:55,040
navigate to the url when the domain

85
00:03:55,040 --> 00:03:58,239
matches the trusted list

86
00:03:58,239 --> 00:04:00,799
what surprised me is that it accepts

87
00:04:00,799 --> 00:04:03,519
data url as well where arbitrary html

88
00:04:03,519 --> 00:04:05,040
could be injected

89
00:04:05,040 --> 00:04:07,280
so we don't have to follow the trusted

90
00:04:07,280 --> 00:04:08,159
list

91
00:04:08,159 --> 00:04:10,400
at all in other words this is a

92
00:04:10,400 --> 00:04:12,319
client-side reflected cross-site

93
00:04:12,319 --> 00:04:14,480
scripting the limitation

94
00:04:14,480 --> 00:04:16,238
here is that it always appends a

95
00:04:16,238 --> 00:04:19,279
question mark at the end of the data url

96
00:04:19,279 --> 00:04:22,400
trying in to say extra parameters

97
00:04:22,400 --> 00:04:25,919
this breaks the base64 encoding

98
00:04:25,919 --> 00:04:29,840
so we have to use plane here

99
00:04:30,320 --> 00:04:32,400
this is the proof that the bug has been

100
00:04:32,400 --> 00:04:33,600
there since

101
00:04:33,600 --> 00:04:37,080
the year 2009

102
00:04:37,680 --> 00:04:41,360
it's not a webkit exploit but web kit

103
00:04:41,360 --> 00:04:43,759
attack by using a simple location

104
00:04:43,759 --> 00:04:46,080
assignment we escalate javascript

105
00:04:46,080 --> 00:04:50,639
execution to a special local web wheel

106
00:04:51,199 --> 00:04:53,280
and here's an alternate trigger named

107
00:04:53,280 --> 00:04:54,880
itms

108
00:04:54,880 --> 00:04:58,400
ui it suffers the exact the same bug but

109
00:04:58,400 --> 00:05:00,320
instead it links to storky ui

110
00:05:00,320 --> 00:05:02,880
services.app which is also responsible

111
00:05:02,880 --> 00:05:05,600
for installing enterprise ota apps it

112
00:05:05,600 --> 00:05:07,759
has no navigation animation so it's very

113
00:05:07,759 --> 00:05:11,440
low profile but idms ui is not in the

114
00:05:11,440 --> 00:05:14,000
trusted list of mobile safari so it

115
00:05:14,000 --> 00:05:16,240
requires one more confirmation but it

116
00:05:16,240 --> 00:05:18,479
makes no difference for other one-click

117
00:05:18,479 --> 00:05:20,639
vectors like airdrop imessage and

118
00:05:20,639 --> 00:05:23,039
third-party instant messengers that

119
00:05:23,039 --> 00:05:26,080
don't want for external app navigation

120
00:05:26,080 --> 00:05:29,840
this bug was assigned to cv 2021

121
00:05:29,840 --> 00:05:32,840
748

122
00:05:32,960 --> 00:05:34,479
so what's the difference for this

123
00:05:34,479 --> 00:05:37,440
webview first this app itunes store is

124
00:05:37,440 --> 00:05:39,120
signed with dynamic cosigning

125
00:05:39,120 --> 00:05:40,800
entitlement that means that it can use

126
00:05:40,800 --> 00:05:41,840
cheat

127
00:05:41,840 --> 00:05:44,560
and this su web wheel is actually a

128
00:05:44,560 --> 00:05:47,280
subclass of ui webview where

129
00:05:47,280 --> 00:05:47,919
it

130
00:05:47,919 --> 00:05:51,360
uses in process js context breach and in

131
00:05:51,360 --> 00:05:53,199
process rendering

132
00:05:53,199 --> 00:05:54,080
so

133
00:05:54,080 --> 00:05:56,240
this is a very special webview that all

134
00:05:56,240 --> 00:05:58,479
of the webkit exploits work here both

135
00:05:58,479 --> 00:06:00,479
dom and cheat

136
00:06:00,479 --> 00:06:03,280
some of the webkit mitigations are gone

137
00:06:03,280 --> 00:06:04,560
since it's in

138
00:06:04,560 --> 00:06:07,919
ui webview there's no renderer sandbox

139
00:06:07,919 --> 00:06:08,880
only

140
00:06:08,880 --> 00:06:12,319
the only sandbox is the app container

141
00:06:12,319 --> 00:06:14,960
so it's capable of loading shell code in

142
00:06:14,960 --> 00:06:16,960
app context

143
00:06:16,960 --> 00:06:19,280
but there is one thing that it has no

144
00:06:19,280 --> 00:06:22,080
render auto restart so the exploit only

145
00:06:22,080 --> 00:06:24,400
has one chance to run otherwise this app

146
00:06:24,400 --> 00:06:26,880
crashes

147
00:06:27,440 --> 00:06:29,360
with

148
00:06:29,360 --> 00:06:31,199
so here we have to learn one thing name

149
00:06:31,199 --> 00:06:33,520
web scripting with web scripting

150
00:06:33,520 --> 00:06:35,919
javascript can invoke navi native

151
00:06:35,919 --> 00:06:38,319
objective c message some of the data

152
00:06:38,319 --> 00:06:40,160
types are automatically converted

153
00:06:40,160 --> 00:06:42,560
between them

154
00:06:42,560 --> 00:06:45,919
this is the bridge between two languages

155
00:06:45,919 --> 00:06:48,319
js context bridge is only available for

156
00:06:48,319 --> 00:06:50,639
the deprecated ui webview

157
00:06:50,639 --> 00:06:53,599
the actual implementation is in process

158
00:06:53,599 --> 00:06:56,000
within the renderer

159
00:06:56,000 --> 00:06:58,720
in other words the app the app itself

160
00:06:58,720 --> 00:07:01,039
and in s2 webview all of the messengers

161
00:07:01,039 --> 00:07:03,039
are under this itunes namespace of

162
00:07:03,039 --> 00:07:05,680
globaldisk the methods are bounded to an

163
00:07:05,680 --> 00:07:09,759
instance of an sjscript interface

164
00:07:09,759 --> 00:07:12,000
there is a bridge named itunes.telephony

165
00:07:12,000 --> 00:07:14,479
that exposes the current phone number

166
00:07:14,479 --> 00:07:17,440
and the operator name to the gs

167
00:07:17,440 --> 00:07:18,560
it has

168
00:07:18,560 --> 00:07:21,360
a custom xml http

169
00:07:21,360 --> 00:07:23,680
request implementation with no same

170
00:07:23,680 --> 00:07:25,360
origin policy

171
00:07:25,360 --> 00:07:27,919
it limits the domains of the request but

172
00:07:27,919 --> 00:07:30,319
doesn't check for the scheme so it

173
00:07:30,319 --> 00:07:32,639
doesn't matter the domain name doesn't

174
00:07:32,639 --> 00:07:35,199
matter in the file url so this x this

175
00:07:35,199 --> 00:07:38,800
special xml http request can be abused

176
00:07:38,800 --> 00:07:42,000
to read local files but unfortunately it

177
00:07:42,000 --> 00:07:44,080
only supports string and this app is

178
00:07:44,080 --> 00:07:46,960
sandbox afro after all so we cannot just

179
00:07:46,960 --> 00:07:50,479
simply read the photos at this moment

180
00:07:50,479 --> 00:07:52,479
since that since this app is part of the

181
00:07:52,479 --> 00:07:55,120
itunes store apple id is visible to the

182
00:07:55,120 --> 00:07:56,720
javascript

183
00:07:56,720 --> 00:07:59,440
it even has a utility to read the cookie

184
00:07:59,440 --> 00:08:01,120
from apple.com

185
00:08:01,120 --> 00:08:02,960
i've noticed an interesting phenomenon

186
00:08:02,960 --> 00:08:06,240
that any outgoing http requests will

187
00:08:06,240 --> 00:08:08,160
send extra headers related to the

188
00:08:08,160 --> 00:08:10,319
account to the account no matter what

189
00:08:10,319 --> 00:08:13,039
the domain is for example in this

190
00:08:13,039 --> 00:08:14,879
request we can even see those critical

191
00:08:14,879 --> 00:08:17,199
tokens for two-factor authentication

192
00:08:17,199 --> 00:08:19,759
with one more authorization header it's

193
00:08:19,759 --> 00:08:24,000
possible to talk to the app store server

194
00:08:24,000 --> 00:08:26,479
and here comes the most interesting part

195
00:08:26,479 --> 00:08:28,479
you can even get a list of all of the

196
00:08:28,479 --> 00:08:31,120
in-store apps and launch them by bundle

197
00:08:31,120 --> 00:08:34,240
identifier for example calculator

198
00:08:34,240 --> 00:08:36,000
so this could have been the most

199
00:08:36,000 --> 00:08:38,240
embarrassing bug ever

200
00:08:38,240 --> 00:08:41,039
it's only one cross-scripting away from

201
00:08:41,039 --> 00:08:44,000
launching the calculator from web on the

202
00:08:44,000 --> 00:08:46,320
states of the art phone

203
00:08:46,320 --> 00:08:50,080
with no memory corruption at all

204
00:08:50,160 --> 00:08:51,120
now

205
00:08:51,120 --> 00:08:55,600
let's it's time for memory corruption

206
00:08:55,600 --> 00:08:56,720
first

207
00:08:56,720 --> 00:09:00,000
it's a type confusion that don't crash

208
00:09:00,000 --> 00:09:03,360
but leak useful information to us this

209
00:09:03,360 --> 00:09:05,680
itunes door window has its setter and

210
00:09:05,680 --> 00:09:08,959
getter message exported to jscontext

211
00:09:08,959 --> 00:09:10,720
we can assign an

212
00:09:10,720 --> 00:09:13,600
arbitrary objective c object we send

213
00:09:13,600 --> 00:09:16,720
involved type to itunes window

214
00:09:16,720 --> 00:09:19,040
when we try to read the value it always

215
00:09:19,040 --> 00:09:22,399
tries to invoke this tag method on the

216
00:09:22,399 --> 00:09:25,279
object we just assigned

217
00:09:25,279 --> 00:09:27,440
so if you have ios background you must

218
00:09:27,440 --> 00:09:30,080
be very familiar to this message when an

219
00:09:30,080 --> 00:09:32,640
unknown selector is sent to an object

220
00:09:32,640 --> 00:09:35,279
the runtime throws a message like this

221
00:09:35,279 --> 00:09:38,399
with the address of the object

222
00:09:38,399 --> 00:09:40,160
the funny thing is that we can catch

223
00:09:40,160 --> 00:09:42,320
this exception message in javascript

224
00:09:42,320 --> 00:09:44,399
giving us the primitive for leaking

225
00:09:44,399 --> 00:09:46,240
object object

226
00:09:46,240 --> 00:09:48,480
first we call setter to associate an

227
00:09:48,480 --> 00:09:50,720
arbitrary object then use this itunes

228
00:09:50,720 --> 00:09:53,760
style window to trigger the selector if

229
00:09:53,760 --> 00:09:55,920
the object doesn't have a method named

230
00:09:55,920 --> 00:09:58,160
tag we captured we can capture the

231
00:09:58,160 --> 00:09:59,600
address of it

232
00:09:59,600 --> 00:10:02,959
and this exception message

233
00:10:03,279 --> 00:10:06,560
with this primitive we break the asll

234
00:10:06,560 --> 00:10:09,440
without a further read primitive

235
00:10:09,440 --> 00:10:11,760
objective-c runtime uses various

236
00:10:11,760 --> 00:10:13,839
techniques to save memories such as tag

237
00:10:13,839 --> 00:10:16,959
pointer and share instances the edges of

238
00:10:16,959 --> 00:10:19,839
certain data are always static from dsc

239
00:10:19,839 --> 00:10:21,120
for instance

240
00:10:21,120 --> 00:10:23,839
infinity in javascript maps to kcf

241
00:10:23,839 --> 00:10:25,920
number positive infinity

242
00:10:25,920 --> 00:10:28,720
simply by reading the address of

243
00:10:28,720 --> 00:10:30,320
boolean force

244
00:10:30,320 --> 00:10:33,120
we get the base address of every single

245
00:10:33,120 --> 00:10:35,680
library

246
00:10:37,200 --> 00:10:40,079
now this is a uaf with only two

247
00:10:40,079 --> 00:10:43,279
instructions introduced by hour six in

248
00:10:43,279 --> 00:10:46,480
this method x selector excluded from web

249
00:10:46,480 --> 00:10:49,600
script it always returns zero

250
00:10:49,600 --> 00:10:52,160
so what could possibly go wrong with

251
00:10:52,160 --> 00:10:53,920
this

252
00:10:53,920 --> 00:10:58,000
here's part of the documentation

253
00:10:58,240 --> 00:11:00,720
it's too long generate let's check out

254
00:11:00,720 --> 00:11:02,560
this highlighted sentence

255
00:11:02,560 --> 00:11:05,440
you should expose only methods that you

256
00:11:05,440 --> 00:11:08,880
know are secure to export a message this

257
00:11:08,880 --> 00:11:11,440
function should return no

258
00:11:11,440 --> 00:11:14,000
for that message selector

259
00:11:14,000 --> 00:11:16,720
so this is the access control between

260
00:11:16,720 --> 00:11:19,200
objective c and javascript world by

261
00:11:19,200 --> 00:11:20,640
returning no

262
00:11:20,640 --> 00:11:23,920
all of these lectures are exposed to js

263
00:11:23,920 --> 00:11:27,360
including this dm demo log

264
00:11:27,360 --> 00:11:30,000
the free in objective c

265
00:11:30,000 --> 00:11:32,160
this is also the root cause of our

266
00:11:32,160 --> 00:11:34,399
previous information leak bug that

267
00:11:34,399 --> 00:11:36,640
allows calling both the setter and the

268
00:11:36,640 --> 00:11:40,319
getter of a private property

269
00:11:40,640 --> 00:11:45,519
now it's literally free then use

270
00:11:46,320 --> 00:11:48,720
issue crash a message sent immediately

271
00:11:48,720 --> 00:11:51,920
with an involved object pointer

272
00:11:51,920 --> 00:11:55,120
showing that it's a use after free

273
00:11:55,120 --> 00:11:56,720
the way this is what it looked like on

274
00:11:56,720 --> 00:11:58,160
ios 6

275
00:11:58,160 --> 00:12:00,800
when it was first introduced

276
00:12:00,800 --> 00:12:03,160
this was assigned by 3 to

277
00:12:03,160 --> 00:12:07,480
2021 1864.

278
00:12:08,000 --> 00:12:12,079
now let's focus on the exploitation

279
00:12:12,079 --> 00:12:14,320
modern smartphones have evolved to make

280
00:12:14,320 --> 00:12:17,200
exploits harder at this point aslr has

281
00:12:17,200 --> 00:12:19,920
already been bypassed but we still got

282
00:12:19,920 --> 00:12:22,000
some million dollar protections to take

283
00:12:22,000 --> 00:12:23,440
into account

284
00:12:23,440 --> 00:12:25,920
this is not a traditional webkit exploit

285
00:12:25,920 --> 00:12:28,959
as some migrations like gta cage package

286
00:12:28,959 --> 00:12:31,200
and structure id randomization don't

287
00:12:31,200 --> 00:12:33,760
matter because we don't use webkit for

288
00:12:33,760 --> 00:12:36,079
primitive at all

289
00:12:36,079 --> 00:12:38,560
apr could stop us from easily getting

290
00:12:38,560 --> 00:12:40,480
shell code executed but it looked

291
00:12:40,480 --> 00:12:43,200
promising to bypass

292
00:12:43,200 --> 00:12:45,600
park is the major problem and besides

293
00:12:45,600 --> 00:12:47,839
the objective c wrong time was hardened

294
00:12:47,839 --> 00:12:51,040
before the competition which is our main

295
00:12:51,040 --> 00:12:53,519
concern

296
00:12:53,519 --> 00:12:55,440
now we managed to perform messages sent

297
00:12:55,440 --> 00:12:57,200
on control memory

298
00:12:57,200 --> 00:12:59,600
the key to forge various classes for

299
00:12:59,600 --> 00:13:03,519
exploitation is the essay pointer which

300
00:13:03,519 --> 00:13:06,560
tells both the type and runtime members

301
00:13:06,560 --> 00:13:08,160
of an object

302
00:13:08,160 --> 00:13:12,079
between rs14 to rs14.4

303
00:13:12,079 --> 00:13:15,279
is a pointer is signed but not checked

304
00:13:15,279 --> 00:13:17,360
leaving us the last chance to do the

305
00:13:17,360 --> 00:13:20,360
work

306
00:13:22,880 --> 00:13:24,880
now let's debunk this exploit on an

307
00:13:24,880 --> 00:13:27,200
up-to-date ios device without any

308
00:13:27,200 --> 00:13:30,079
virtual machine or research

309
00:13:30,079 --> 00:13:32,800
device we can import this private apis

310
00:13:32,800 --> 00:13:35,760
to the debuggable app

311
00:13:35,760 --> 00:13:38,399
since the ui web view uses in-process

312
00:13:38,399 --> 00:13:40,320
rendering all of the exceptions are

313
00:13:40,320 --> 00:13:42,880
catchable within the debugger so let's

314
00:13:42,880 --> 00:13:44,399
load this private frameworks and

315
00:13:44,399 --> 00:13:48,560
initialize an suv you controller to load

316
00:13:48,560 --> 00:13:52,240
the html and don't forget to enable um

317
00:13:52,240 --> 00:13:56,240
64e to play with the pack

318
00:13:56,639 --> 00:13:58,800
now it's time to build a fake object

319
00:13:58,800 --> 00:14:01,360
primitive

320
00:14:01,360 --> 00:14:03,279
let's first allocate a new object and

321
00:14:03,279 --> 00:14:06,399
hold the dangling reference

322
00:14:06,399 --> 00:14:08,720
there are dozens of

323
00:14:08,720 --> 00:14:10,639
make blablabla methods that allocate

324
00:14:10,639 --> 00:14:13,199
different types of object and the size

325
00:14:13,199 --> 00:14:15,600
of this object are known to us

326
00:14:15,600 --> 00:14:19,040
we can use we can free them and reclaim

327
00:14:19,040 --> 00:14:21,680
the memory to turn into a type confusion

328
00:14:21,680 --> 00:14:24,800
but we need a malloc primitive that can

329
00:14:24,800 --> 00:14:25,680
both

330
00:14:25,680 --> 00:14:29,120
control the learners and the content

331
00:14:29,120 --> 00:14:31,600
first i tried this address off and then

332
00:14:31,600 --> 00:14:34,480
a base tray learns an s string

333
00:14:34,480 --> 00:14:36,560
this doesn't work for reclaiming the

334
00:14:36,560 --> 00:14:39,920
free memory because an scf string has

335
00:14:39,920 --> 00:14:43,199
two phones and in this case it uses

336
00:14:43,199 --> 00:14:45,199
non-inline form

337
00:14:45,199 --> 00:14:46,320
that hold

338
00:14:46,320 --> 00:14:48,320
that holds a reference to a string in

339
00:14:48,320 --> 00:14:50,240
js6 heap

340
00:14:50,240 --> 00:14:51,440
so

341
00:14:51,440 --> 00:14:54,399
we since we cannot allocate and b tree

342
00:14:54,399 --> 00:14:58,240
learns string in objective c slur hip

343
00:14:58,240 --> 00:15:01,600
this doesn't work and so that so does a

344
00:15:01,600 --> 00:15:04,160
rebuffer

345
00:15:04,800 --> 00:15:07,360
after a bit of reverse engineering work

346
00:15:07,360 --> 00:15:09,920
i found this message which is perfectly

347
00:15:09,920 --> 00:15:11,360
binary safe

348
00:15:11,360 --> 00:15:14,240
and with controllable learns

349
00:15:14,240 --> 00:15:16,959
when calling this add multiple

350
00:15:16,959 --> 00:15:20,560
multipart data with name and type

351
00:15:20,560 --> 00:15:22,880
it checks the url

352
00:15:22,880 --> 00:15:25,760
when it's a data ui it tries to decode

353
00:15:25,760 --> 00:15:28,320
the data payload and pull it in the same

354
00:15:28,320 --> 00:15:30,880
heap of objectives wrong time

355
00:15:30,880 --> 00:15:33,440
so it's perfectly binary safe and

356
00:15:33,440 --> 00:15:36,240
there's control

357
00:15:36,240 --> 00:15:37,839
so here's the

358
00:15:37,839 --> 00:15:38,880
here's the

359
00:15:38,880 --> 00:15:41,279
the idea of the the exploitation steps

360
00:15:41,279 --> 00:15:43,600
first we allocate a

361
00:15:43,600 --> 00:15:47,120
seo script xml http store request

362
00:15:47,120 --> 00:15:49,600
and we use this facebook uh itunes dot

363
00:15:49,600 --> 00:15:51,600
create facebook request to do them

364
00:15:51,600 --> 00:15:53,040
unlock

365
00:15:53,040 --> 00:15:54,880
just remember that this as you script

366
00:15:54,880 --> 00:16:00,720
xml https store request its size is 192.

367
00:16:00,720 --> 00:16:04,000
so we have to create a string

368
00:16:04,000 --> 00:16:07,040
to convert to data uin that matches the

369
00:16:07,040 --> 00:16:10,000
same size

370
00:16:10,160 --> 00:16:11,440
now call the

371
00:16:11,440 --> 00:16:13,600
lock to get a dangling pointer and

372
00:16:13,600 --> 00:16:16,079
reclaim the memory

373
00:16:16,079 --> 00:16:19,279
when we're trying to access the this w

374
00:16:19,279 --> 00:16:21,600
is going to hit this

375
00:16:21,600 --> 00:16:24,480
is going to crash at messages 10

376
00:16:24,480 --> 00:16:27,120
where the memory look where

377
00:16:27,120 --> 00:16:30,079
we see the memory cl the memory are

378
00:16:30,079 --> 00:16:32,638
controlled

379
00:16:32,800 --> 00:16:36,240
before 812 getting objective c messages

380
00:16:36,240 --> 00:16:38,560
sent on control memory is enough for pc

381
00:16:38,560 --> 00:16:42,000
control so we can use group to abuse the

382
00:16:42,000 --> 00:16:44,320
dynamic co-signing entitlement and load

383
00:16:44,320 --> 00:16:46,399
shell code and this should have been the

384
00:16:46,399 --> 00:16:48,639
most privileged context that allows

385
00:16:48,639 --> 00:16:51,680
shell coding since jsc has been dropped

386
00:16:51,680 --> 00:16:53,040
on ios

387
00:16:53,040 --> 00:16:54,399
but now

388
00:16:54,399 --> 00:16:56,480
it is still possible to do the selector

389
00:16:56,480 --> 00:16:58,320
oriented programming

390
00:16:58,320 --> 00:17:00,720
actually this is much harder after after

391
00:17:00,720 --> 00:17:04,400
hours 14.5 because of sign it is a and

392
00:17:04,400 --> 00:17:07,760
an s invocation hardening

393
00:17:07,760 --> 00:17:09,760
at this point we can forge a bitrate

394
00:17:09,760 --> 00:17:13,199
object to see objects so with the leaked

395
00:17:13,199 --> 00:17:17,119
address we have all of the isa

396
00:17:17,119 --> 00:17:20,400
and this fake object must be smaller

397
00:17:20,400 --> 00:17:24,079
than su-script xml http store request

398
00:17:24,079 --> 00:17:27,839
so my choice is to fake a nns data and

399
00:17:27,839 --> 00:17:30,400
cause its to string to leak the memory

400
00:17:30,400 --> 00:17:33,600
content because finally it will cause a

401
00:17:33,600 --> 00:17:36,640
nice data description inside

402
00:17:36,640 --> 00:17:39,360
which yells the hexdump of the memory so

403
00:17:39,360 --> 00:17:40,880
it's perfectly

404
00:17:40,880 --> 00:17:43,360
binary safe memory dumper

405
00:17:43,360 --> 00:17:46,000
the contents must be less than 24 bytes

406
00:17:46,000 --> 00:17:47,440
or otherwise

407
00:17:47,440 --> 00:17:49,600
it will be truncated but i can

408
00:17:49,600 --> 00:17:51,360
repeatedly use it to dump the whole

409
00:17:51,360 --> 00:17:52,799
memory range

410
00:17:52,799 --> 00:17:54,720
the fake structure is look like looks

411
00:17:54,720 --> 00:17:56,080
like this

412
00:17:56,080 --> 00:18:00,000
first the i is a it's not and the learns

413
00:18:00,000 --> 00:18:02,640
and followed by the location is so it's

414
00:18:02,640 --> 00:18:05,840
perfectly a victory read with a bitry

415
00:18:05,840 --> 00:18:07,280
learns

416
00:18:07,280 --> 00:18:10,720
just uh and don't forget to keep this

417
00:18:10,720 --> 00:18:13,280
the allocated member to

418
00:18:13,280 --> 00:18:15,600
must to keep it as now

419
00:18:15,600 --> 00:18:18,720
otherwise is consider a function pointer

420
00:18:18,720 --> 00:18:20,320
and call when

421
00:18:20,320 --> 00:18:23,039
and free this next data later

422
00:18:23,039 --> 00:18:24,720
and call this function

423
00:18:24,720 --> 00:18:29,000
which will obviously crash

424
00:18:29,919 --> 00:18:32,320
now we can use an even better fake

425
00:18:32,320 --> 00:18:34,320
object primitive

426
00:18:34,320 --> 00:18:35,280
because

427
00:18:35,280 --> 00:18:37,600
currently this malloc primitive

428
00:18:37,600 --> 00:18:40,000
returns an immutable buffer it's better

429
00:18:40,000 --> 00:18:42,480
to use an array buffer because it's

430
00:18:42,480 --> 00:18:45,120
mutable we can modify the forged object

431
00:18:45,120 --> 00:18:47,280
on the fly and reuse them

432
00:18:47,280 --> 00:18:49,440
and we need a much bigger buffer for

433
00:18:49,440 --> 00:18:51,480
various fake objects and post

434
00:18:51,480 --> 00:18:53,280
exploitation

435
00:18:53,280 --> 00:18:55,440
here are two approaches

436
00:18:55,440 --> 00:18:59,120
number one the hip spray approach

437
00:18:59,120 --> 00:19:01,520
first we need to ship spray plenty of

438
00:19:01,520 --> 00:19:04,160
array buffers

439
00:19:04,160 --> 00:19:05,600
now to

440
00:19:05,600 --> 00:19:07,679
when we're trying to refill the dangling

441
00:19:07,679 --> 00:19:10,480
pointer with a fake object we use a

442
00:19:10,480 --> 00:19:12,320
fixed address

443
00:19:12,320 --> 00:19:14,640
with to build a

444
00:19:14,640 --> 00:19:16,559
an s array

445
00:19:16,559 --> 00:19:18,799
where the content points to a fixed

446
00:19:18,799 --> 00:19:19,840
address

447
00:19:19,840 --> 00:19:24,000
if it hits one of the array buffer

448
00:19:24,000 --> 00:19:27,120
we try to dereference this pointer show

449
00:19:27,120 --> 00:19:29,360
results in a nested

450
00:19:29,360 --> 00:19:31,120
unless array

451
00:19:31,120 --> 00:19:32,880
and in this

452
00:19:32,880 --> 00:19:36,640
array buffer we fill them with

453
00:19:36,640 --> 00:19:39,679
thousands of different or an asset rate

454
00:19:39,679 --> 00:19:41,200
where

455
00:19:41,200 --> 00:19:42,320
did

456
00:19:42,320 --> 00:19:46,080
where the number inside this array

457
00:19:46,080 --> 00:19:49,280
is the identifier

458
00:19:49,280 --> 00:19:52,080
so now we read the description of this

459
00:19:52,080 --> 00:19:53,840
fake object

460
00:19:53,840 --> 00:19:57,120
it's basically be when it it hits the uh

461
00:19:57,120 --> 00:19:59,360
one of the array buffer it will be

462
00:19:59,360 --> 00:20:01,039
treated like a

463
00:20:01,039 --> 00:20:03,760
nasty anes array with

464
00:20:03,760 --> 00:20:06,480
one number inside so by reading the

465
00:20:06,480 --> 00:20:08,559
description we can know which rebuffer

466
00:20:08,559 --> 00:20:12,080
hits the target address

467
00:20:12,880 --> 00:20:15,280
now trigger garbage collection to re to

468
00:20:15,280 --> 00:20:17,840
release the others and keep reusing this

469
00:20:17,840 --> 00:20:21,840
only one array buffer

470
00:20:22,640 --> 00:20:25,520
in this approach

471
00:20:25,520 --> 00:20:29,200
i use this i use the tag pointer to

472
00:20:29,200 --> 00:20:31,360
build the fake nest number

473
00:20:31,360 --> 00:20:33,440
on ios 14

474
00:20:33,440 --> 00:20:36,480
tag pointer has been hardened using an

475
00:20:36,480 --> 00:20:39,280
obfuscation

476
00:20:39,280 --> 00:20:42,240
before it was clearly to see the bits

477
00:20:42,240 --> 00:20:44,640
and number but after

478
00:20:44,640 --> 00:20:49,200
the obfuscation it seemed totally random

479
00:20:49,200 --> 00:20:51,679
at this point we can still use address

480
00:20:51,679 --> 00:20:54,159
of primitive for thousands of thousand

481
00:20:54,159 --> 00:20:57,679
times but when it comes to hip spray

482
00:20:57,679 --> 00:20:59,760
it's going to be very slow because it

483
00:20:59,760 --> 00:21:02,720
throws an exception every time an emit

484
00:21:02,720 --> 00:21:04,159
system

485
00:21:04,159 --> 00:21:06,400
system logs

486
00:21:06,400 --> 00:21:07,360
so

487
00:21:07,360 --> 00:21:08,799
what's inside this standpoint

488
00:21:08,799 --> 00:21:11,919
obfuscation is that an objective c debug

489
00:21:11,919 --> 00:21:14,559
checkpointer obfuscator is randomized

490
00:21:14,559 --> 00:21:16,960
per process

491
00:21:16,960 --> 00:21:19,120
the tag pointer use

492
00:21:19,120 --> 00:21:22,559
xor to obfuscate it

493
00:21:22,559 --> 00:21:26,240
since we have this address of primitive

494
00:21:26,240 --> 00:21:29,919
with one known pair of float float64

495
00:21:29,919 --> 00:21:33,840
number in js and the obfuscating pointer

496
00:21:33,840 --> 00:21:37,039
in objective c is possible to calculate

497
00:21:37,039 --> 00:21:39,919
the arbitrary value using the following

498
00:21:39,919 --> 00:21:42,919
algorithm

499
00:21:45,039 --> 00:21:48,080
but as but after the the temple cup i

500
00:21:48,080 --> 00:21:50,240
found another better approach without

501
00:21:50,240 --> 00:21:52,240
hip spray

502
00:21:52,240 --> 00:21:53,200
because

503
00:21:53,200 --> 00:21:56,159
as i mentioned before this app can only

504
00:21:56,159 --> 00:21:59,039
crash once so

505
00:21:59,039 --> 00:22:02,159
if it crashes everything stops

506
00:22:02,159 --> 00:22:05,280
so hip spray is less reliable

507
00:22:05,280 --> 00:22:06,960
we can use this

508
00:22:06,960 --> 00:22:09,679
arbitrary read and address of primitive

509
00:22:09,679 --> 00:22:11,280
to leak the backing

510
00:22:11,280 --> 00:22:15,840
store of an array buffer directly

511
00:22:15,840 --> 00:22:17,520
at this context

512
00:22:17,520 --> 00:22:20,799
the address of the array buffer

513
00:22:20,799 --> 00:22:22,320
is the

514
00:22:22,320 --> 00:22:26,960
data pointer is protected by pack cage

515
00:22:26,960 --> 00:22:29,520
but it only matters to webkit since we

516
00:22:29,520 --> 00:22:30,799
don't have to

517
00:22:30,799 --> 00:22:34,480
build a fake into a array with fake

518
00:22:34,480 --> 00:22:37,360
vector pointer it doesn't matter at all

519
00:22:37,360 --> 00:22:40,880
we can just we all gonna do is to strip

520
00:22:40,880 --> 00:22:43,679
the sign bits to get the real address of

521
00:22:43,679 --> 00:22:46,960
the backhand store and use it to

522
00:22:46,960 --> 00:22:50,080
create various fake objects in objective

523
00:22:50,080 --> 00:22:53,600
c as objective c don't check

524
00:22:53,600 --> 00:22:54,960
the pack

525
00:22:54,960 --> 00:22:57,440
for it

526
00:22:58,000 --> 00:22:59,039
so

527
00:22:59,039 --> 00:23:02,000
let's get into the slap time this is an

528
00:23:02,000 --> 00:23:03,919
exploitation

529
00:23:03,919 --> 00:23:06,320
technique invented by project zero it

530
00:23:06,320 --> 00:23:09,280
uses a series of ns invocations in an

531
00:23:09,280 --> 00:23:10,480
asset rate

532
00:23:10,480 --> 00:23:11,919
it calls

533
00:23:11,919 --> 00:23:14,320
unless array make objective

534
00:23:14,320 --> 00:23:17,679
make objects perform selector invoked

535
00:23:17,679 --> 00:23:19,360
to perform

536
00:23:19,360 --> 00:23:20,960
invocations

537
00:23:20,960 --> 00:23:22,480
respectively

538
00:23:22,480 --> 00:23:24,960
so with proper gadgets is capable of

539
00:23:24,960 --> 00:23:29,120
calling a b3 c functions

540
00:23:29,600 --> 00:23:32,559
but after project zero publish its

541
00:23:32,559 --> 00:23:36,080
i message zero click exploitation

542
00:23:36,080 --> 00:23:38,240
apple add a sixty

543
00:23:38,240 --> 00:23:40,640
six uh three

544
00:23:40,640 --> 00:23:43,360
32 bit random cookie to an sm location

545
00:23:43,360 --> 00:23:46,480
to prevent exploitation

546
00:23:46,480 --> 00:23:50,159
we since we already have the aslr bypass

547
00:23:50,159 --> 00:23:52,880
and a b3 read we can read

548
00:23:52,880 --> 00:23:56,799
this number from this magic cookie value

549
00:23:56,799 --> 00:23:58,400
to get the random

550
00:23:58,400 --> 00:24:01,200
to get this random cookie

551
00:24:01,200 --> 00:24:03,279
and what's more we need a kickstarter to

552
00:24:03,279 --> 00:24:04,400
call the

553
00:24:04,400 --> 00:24:06,960
invoke method

554
00:24:06,960 --> 00:24:09,120
on the allocation

555
00:24:09,120 --> 00:24:11,440
it must have been a dialogue method that

556
00:24:11,440 --> 00:24:14,960
performs in work selector on a member of

557
00:24:14,960 --> 00:24:16,080
self

558
00:24:16,080 --> 00:24:18,480
this is a candidate we found in this

559
00:24:18,480 --> 00:24:21,760
itunes store that it caused in work on

560
00:24:21,760 --> 00:24:23,120
offset

561
00:24:23,120 --> 00:24:27,760
a zero uh offset and a certain offset

562
00:24:27,760 --> 00:24:31,360
to kickstarter slop chain

563
00:24:31,360 --> 00:24:33,679
but we still need a double free

564
00:24:33,679 --> 00:24:35,679
primitive because

565
00:24:35,679 --> 00:24:37,520
we have to call it the outlook the

566
00:24:37,520 --> 00:24:40,080
unlock method but this sk store reveal

567
00:24:40,080 --> 00:24:42,000
control view controller is not a

568
00:24:42,000 --> 00:24:45,039
subclass of suvscript object just to

569
00:24:45,039 --> 00:24:46,480
remember

570
00:24:46,480 --> 00:24:48,080
the everything

571
00:24:48,080 --> 00:24:49,200
that

572
00:24:49,200 --> 00:24:51,679
why we can call this the unlock is that

573
00:24:51,679 --> 00:24:54,080
the a selector excluded from web script

574
00:24:54,080 --> 00:24:56,799
returns zero false

575
00:24:56,799 --> 00:24:57,520
but

576
00:24:57,520 --> 00:24:59,840
this is not a subclass of s2script

577
00:24:59,840 --> 00:25:01,919
object so that it falls back to the

578
00:25:01,919 --> 00:25:05,039
default implementation of an x object

579
00:25:05,039 --> 00:25:08,559
where it doesn't allow the unlock method

580
00:25:08,559 --> 00:25:10,799
we cannot simply call

581
00:25:10,799 --> 00:25:14,320
this dialog in js

582
00:25:14,320 --> 00:25:17,039
my workaround is that is to find a class

583
00:25:17,039 --> 00:25:18,000
that

584
00:25:18,000 --> 00:25:21,039
is a subclass of s2script object

585
00:25:21,039 --> 00:25:23,760
and it has a setter

586
00:25:23,760 --> 00:25:26,000
for associating other as you script

587
00:25:26,000 --> 00:25:26,880
object

588
00:25:26,880 --> 00:25:28,799
to its properties

589
00:25:28,799 --> 00:25:30,080
it will

590
00:25:30,080 --> 00:25:33,679
it releases the the external references

591
00:25:33,679 --> 00:25:34,640
to

592
00:25:34,640 --> 00:25:37,840
the objects upon the allocation

593
00:25:37,840 --> 00:25:40,240
here is our candidate su-script

594
00:25:40,240 --> 00:25:42,640
segmented control item

595
00:25:42,640 --> 00:25:45,039
it can be allocated in js by calling

596
00:25:45,039 --> 00:25:48,159
itunes dot make segmented control

597
00:25:48,159 --> 00:25:50,080
dot create segment

598
00:25:50,080 --> 00:25:52,640
and it has a property setter set user

599
00:25:52,640 --> 00:25:55,520
info that accept a b3 as your script

600
00:25:55,520 --> 00:25:57,679
object

601
00:25:57,679 --> 00:26:00,640
now the steps are like this

602
00:26:00,640 --> 00:26:05,520
we allocate a new item as an object a

603
00:26:05,520 --> 00:26:08,400
now allocate new object b to lately

604
00:26:08,400 --> 00:26:11,279
become a dangling pointer here we chose

605
00:26:11,279 --> 00:26:14,080
seo script window

606
00:26:14,080 --> 00:26:16,799
now trigger

607
00:26:16,799 --> 00:26:20,799
now we assign the object b to the user

608
00:26:20,799 --> 00:26:24,720
info property before triggering the uaf

609
00:26:24,720 --> 00:26:27,039
now we can free object b

610
00:26:27,039 --> 00:26:29,760
and reclaim it with a fake

611
00:26:29,760 --> 00:26:32,480
ns array

612
00:26:33,440 --> 00:26:36,159
so we use the fake the array buffer to

613
00:26:36,159 --> 00:26:38,480
prepare for the slop chain to build

614
00:26:38,480 --> 00:26:40,559
everything we need the invoke ns

615
00:26:40,559 --> 00:26:42,799
invocation and these

616
00:26:42,799 --> 00:26:45,440
targets this cancel request

617
00:26:45,440 --> 00:26:49,520
and this fake store reveal controller

618
00:26:49,520 --> 00:26:51,440
now

619
00:26:51,440 --> 00:26:54,480
we call this dialog on object 8 to free

620
00:26:54,480 --> 00:26:56,640
everything again and kick start the

621
00:26:56,640 --> 00:26:59,440
execution

622
00:27:00,320 --> 00:27:04,678
the fake code look like this

623
00:27:06,720 --> 00:27:11,279
uh on ios 14.3 list signing gadgets were

624
00:27:11,279 --> 00:27:13,600
still available we can use this signing

625
00:27:13,600 --> 00:27:16,240
gadget and code

626
00:27:16,240 --> 00:27:19,200
called arbitrary seek functions using

627
00:27:19,200 --> 00:27:22,960
dlc and invoke using implementation

628
00:27:22,960 --> 00:27:24,960
but here's no limitation that project

629
00:27:24,960 --> 00:27:26,880
zero didn't solve that

630
00:27:26,880 --> 00:27:29,919
when using those gadgets involved using

631
00:27:29,919 --> 00:27:32,159
aimp the first

632
00:27:32,159 --> 00:27:35,039
argument of the c call where where this

633
00:27:35,039 --> 00:27:38,080
is which is the self pointer it cannot

634
00:27:38,080 --> 00:27:40,559
be zero

635
00:27:40,559 --> 00:27:43,120
i solved this problem because i have to

636
00:27:43,120 --> 00:27:47,039
use this c function cause with the first

637
00:27:47,039 --> 00:27:49,440
argument as zero so i solve this problem

638
00:27:49,440 --> 00:27:53,039
by using callbacks for example this cf

639
00:27:53,039 --> 00:27:55,120
set applied function from core

640
00:27:55,120 --> 00:27:57,919
foundation fully controls up to two

641
00:27:57,919 --> 00:27:59,919
arbitrary arguments

642
00:27:59,919 --> 00:28:03,039
first i can build a fake

643
00:28:03,039 --> 00:28:05,279
set object

644
00:28:05,279 --> 00:28:06,720
now i call this

645
00:28:06,720 --> 00:28:09,919
set apply function with a assigned

646
00:28:09,919 --> 00:28:12,399
pointer on it

647
00:28:12,399 --> 00:28:13,679
the second

648
00:28:13,679 --> 00:28:16,000
the second function the second argument

649
00:28:16,000 --> 00:28:18,159
is the sign point function point and the

650
00:28:18,159 --> 00:28:21,919
third function argument is the context

651
00:28:21,919 --> 00:28:24,880
applied to this exit function which is

652
00:28:24,880 --> 00:28:27,039
the second argument and the first

653
00:28:27,039 --> 00:28:30,080
argument is the second member of this ns

654
00:28:30,080 --> 00:28:32,399
set

655
00:28:35,679 --> 00:28:37,039
so

656
00:28:37,039 --> 00:28:39,760
at this point we need to load shell code

657
00:28:39,760 --> 00:28:41,840
we use this well-known perform cheat

658
00:28:41,840 --> 00:28:44,880
memo copy gadget to

659
00:28:44,880 --> 00:28:46,159
write

660
00:28:46,159 --> 00:28:48,559
the jit red region

661
00:28:48,559 --> 00:28:50,240
this is actually

662
00:28:50,240 --> 00:28:52,640
p thread jeep right protect mp and mem

663
00:28:52,640 --> 00:28:55,919
cop inside some special registers needs

664
00:28:55,919 --> 00:28:58,080
to be altered to change permissions of

665
00:28:58,080 --> 00:28:59,520
the jit page

666
00:28:59,520 --> 00:29:02,399
it used to be in line everywhere but

667
00:29:02,399 --> 00:29:05,200
don't know why this function is public

668
00:29:05,200 --> 00:29:06,880
on ios 14

669
00:29:06,880 --> 00:29:08,559
which made it

670
00:29:08,559 --> 00:29:10,840
extremely simple with our

671
00:29:10,840 --> 00:29:13,919
primitives so apple in line this

672
00:29:13,919 --> 00:29:18,159
function again after 10 foot cup

673
00:29:18,880 --> 00:29:21,279
so after loading the shell code i still

674
00:29:21,279 --> 00:29:23,200
need a pack bypass to jump to the

675
00:29:23,200 --> 00:29:25,760
shortcode in siri i can obtain a sign

676
00:29:25,760 --> 00:29:28,240
pointer to a jit function first then

677
00:29:28,240 --> 00:29:30,559
overwrite its machine code

678
00:29:30,559 --> 00:29:32,960
then but i chose a straightforward more

679
00:29:32,960 --> 00:29:35,520
straightforward approach instead

680
00:29:35,520 --> 00:29:38,159
that to find an unprotected

681
00:29:38,159 --> 00:29:41,840
global offset table pointers

682
00:29:41,840 --> 00:29:44,399
lists are unprotected jump to on

683
00:29:44,399 --> 00:29:48,240
authenticated function pointers

684
00:29:48,240 --> 00:29:51,039
here's an example in this swift

685
00:29:51,039 --> 00:29:52,240
uh during

686
00:29:52,240 --> 00:29:55,440
in this function of sweep runtime

687
00:29:55,440 --> 00:29:58,320
it loads a

688
00:29:59,039 --> 00:30:01,440
function pointer from a globe a writable

689
00:30:01,440 --> 00:30:05,360
global offset table entry

690
00:30:05,360 --> 00:30:06,320
and

691
00:30:06,320 --> 00:30:09,360
it calls this sweep uh this function

692
00:30:09,360 --> 00:30:10,720
inside

693
00:30:10,720 --> 00:30:11,760
where

694
00:30:11,760 --> 00:30:13,279
the second

695
00:30:13,279 --> 00:30:16,799
argument is the function pointer with an

696
00:30:16,799 --> 00:30:21,120
indirect jump with no authentication

697
00:30:21,440 --> 00:30:26,960
this is assigned by cve 2021 1796

698
00:30:26,960 --> 00:30:30,399
i will first use dr open to load this

699
00:30:30,399 --> 00:30:32,799
swift wrong time library and use

700
00:30:32,799 --> 00:30:35,360
arbitrary write primitive to override

701
00:30:35,360 --> 00:30:38,480
this got

702
00:30:38,480 --> 00:30:41,600
this got entry with the with the pointer

703
00:30:41,600 --> 00:30:44,240
to the shell code and finally i call

704
00:30:44,240 --> 00:30:46,960
this function to jump to the shell code

705
00:30:46,960 --> 00:30:50,320
it was patched by swift long time after

706
00:30:50,320 --> 00:30:52,720
10 foot cup

707
00:30:52,720 --> 00:30:54,799
now since we have since we have the

708
00:30:54,799 --> 00:30:57,200
shell code execution it's easy to spoil

709
00:30:57,200 --> 00:31:01,120
all of these registers like this

710
00:31:01,120 --> 00:31:03,679
for the post exploitation this app is

711
00:31:03,679 --> 00:31:05,840
pretty privileged that it can access

712
00:31:05,840 --> 00:31:09,360
context camera and sms and even

713
00:31:09,360 --> 00:31:12,159
apple account settings and install mdm

714
00:31:12,159 --> 00:31:14,159
profile to gain persist traffic

715
00:31:14,159 --> 00:31:15,440
monitoring

716
00:31:15,440 --> 00:31:17,279
and don't forget that since we have

717
00:31:17,279 --> 00:31:19,360
shell code here we can load further job

718
00:31:19,360 --> 00:31:22,159
break payload it has much more io kit

719
00:31:22,159 --> 00:31:24,960
and userland services compared to the

720
00:31:24,960 --> 00:31:28,320
webkit cheat process

721
00:31:28,320 --> 00:31:31,279
here's a takeaways from this talk

722
00:31:31,279 --> 00:31:34,320
we introduced we have present two bugs

723
00:31:34,320 --> 00:31:37,200
from late 2000 2000's that stupid

724
00:31:37,200 --> 00:31:39,600
state-of-the-art modifications

725
00:31:39,600 --> 00:31:41,519
and sometimes you don't need a single

726
00:31:41,519 --> 00:31:44,320
byte of memory corruption to run a

727
00:31:44,320 --> 00:31:48,399
unselected receipt calculator from web

728
00:31:48,399 --> 00:31:51,200
plus get the victim's apple id and phone

729
00:31:51,200 --> 00:31:52,159
number

730
00:31:52,159 --> 00:31:54,159
with this and tricks in order to bypass

731
00:31:54,159 --> 00:31:56,399
those million dollar protections

732
00:31:56,399 --> 00:31:58,159
and some of the instant messengers can

733
00:31:58,159 --> 00:32:00,720
also be the effective vectors for the

734
00:32:00,720 --> 00:32:04,720
url skin bugs we talked about today

735
00:32:04,880 --> 00:32:07,039
this talk has so many references to the

736
00:32:07,039 --> 00:32:08,559
following materials

737
00:32:08,559 --> 00:32:10,399
if you want to go further on this topic

738
00:32:10,399 --> 00:32:12,840
i strongly recommend you to read

739
00:32:12,840 --> 00:32:15,279
them thank you for listening to talk

740
00:32:15,279 --> 00:32:17,919
today if you have any questions feel

741
00:32:17,919 --> 00:32:19,360
free to ask them

742
00:32:19,360 --> 00:32:22,360
thanks

