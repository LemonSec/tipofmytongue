1
00:00:01,130 --> 00:00:14,699
[Music]

2
00:00:15,839 --> 00:00:17,359
do you speak my language today's

3
00:00:17,359 --> 00:00:19,039
presentation is about static analysis

4
00:00:19,039 --> 00:00:20,640
tools how we can make them communicate

5
00:00:20,640 --> 00:00:22,720
with each other enabling security teams

6
00:00:22,720 --> 00:00:24,080
to have a deeper understanding of their

7
00:00:24,080 --> 00:00:25,920
attack surface and allowing them to

8
00:00:25,920 --> 00:00:28,240
identify complex vulnerabilities

9
00:00:28,240 --> 00:00:29,840
to set the scene for this talk i would

10
00:00:29,840 --> 00:00:31,439
like to show you three code snippets of

11
00:00:31,439 --> 00:00:34,079
increasing complexity the first one here

12
00:00:34,079 --> 00:00:36,880
is the simplest in one function we take

13
00:00:36,880 --> 00:00:39,200
user input create a query and then

14
00:00:39,200 --> 00:00:41,840
execute that as a mysql query as we all

15
00:00:41,840 --> 00:00:43,200
know there is a sql injection

16
00:00:43,200 --> 00:00:44,559
vulnerability here but because

17
00:00:44,559 --> 00:00:46,719
everything happens in one function it's

18
00:00:46,719 --> 00:00:49,039
easy to solve this problem with linters

19
00:00:49,039 --> 00:00:50,960
grip and other tools you won't spend we

20
00:00:50,960 --> 00:00:52,800
won't be spending too much time speaking

21
00:00:52,800 --> 00:00:54,640
about this problem

22
00:00:54,640 --> 00:00:57,280
in real code you often have wrappers

23
00:00:57,280 --> 00:00:59,120
abstractions and other and frameworks

24
00:00:59,120 --> 00:01:00,320
that would make the call graph more

25
00:01:00,320 --> 00:01:02,640
complex this code here is vulnerable to

26
00:01:02,640 --> 00:01:04,720
the same sql injection vulnerability but

27
00:01:04,720 --> 00:01:06,400
in order to find this vulnerability here

28
00:01:06,400 --> 00:01:08,159
you would need to inflow analysis there

29
00:01:08,159 --> 00:01:09,920
are open source tools from facebook and

30
00:01:09,920 --> 00:01:11,760
other companies that would help you to

31
00:01:11,760 --> 00:01:13,760
solve this problem we'll briefly talk

32
00:01:13,760 --> 00:01:15,119
about team flow analysis in this

33
00:01:15,119 --> 00:01:16,799
presentation to get the basic

34
00:01:16,799 --> 00:01:17,759
information on the background

35
00:01:17,759 --> 00:01:19,360
information that we need for our next

36
00:01:19,360 --> 00:01:22,640
example our presentation mainly is about

37
00:01:22,640 --> 00:01:25,119
this code here note in the left hand

38
00:01:25,119 --> 00:01:27,360
side we have php code and on the right

39
00:01:27,360 --> 00:01:29,759
hand side we have python code this code

40
00:01:29,759 --> 00:01:31,360
is also vulnerable to the sql injection

41
00:01:31,360 --> 00:01:33,920
vulnerability the code on the php on the

42
00:01:33,920 --> 00:01:35,920
left hand side starts as the previous

43
00:01:35,920 --> 00:01:38,240
example but then we do an rbc call to

44
00:01:38,240 --> 00:01:40,240
fetch data which takes us to the python

45
00:01:40,240 --> 00:01:41,920
code that have a sql injection

46
00:01:41,920 --> 00:01:43,840
vulnerability the sequential probability

47
00:01:43,840 --> 00:01:46,240
exists but in in two different code

48
00:01:46,240 --> 00:01:47,439
bases

49
00:01:47,439 --> 00:01:49,520
i am ibrahim muhammad and today we'll be

50
00:01:49,520 --> 00:01:51,600
speaking about cross reputaine flow

51
00:01:51,600 --> 00:01:53,200
analysis before we dive into the

52
00:01:53,200 --> 00:01:55,119
presentation let me introduce myself i'm

53
00:01:55,119 --> 00:01:56,880
a security engineer and facebook

54
00:01:56,880 --> 00:01:58,719
application security team i've been

55
00:01:58,719 --> 00:02:00,240
working for facebook for around five

56
00:02:00,240 --> 00:02:02,719
years i focus on detecting security

57
00:02:02,719 --> 00:02:04,079
vulnerabilities doing manual code review

58
00:02:04,079 --> 00:02:05,600
to detect security vulnerabilities but i

59
00:02:05,600 --> 00:02:07,360
also like to spend a lot of time with

60
00:02:07,360 --> 00:02:08,959
software engineer to see how can we

61
00:02:08,959 --> 00:02:10,720
automate the detection of these security

62
00:02:10,720 --> 00:02:12,879
vulnerabilities over the past five years

63
00:02:12,879 --> 00:02:14,800
i've been working on zongcolon and pisa

64
00:02:14,800 --> 00:02:16,959
both are static analysis tool for php

65
00:02:16,959 --> 00:02:18,640
and python before facebook i used to be

66
00:02:18,640 --> 00:02:19,920
as a security i used to work as a

67
00:02:19,920 --> 00:02:22,560
security consultant mostly focusing on

68
00:02:22,560 --> 00:02:25,040
penetration testing red team exercises

69
00:02:25,040 --> 00:02:27,120
and also code reviews

70
00:02:27,120 --> 00:02:29,360
with me out of the way let's talk about

71
00:02:29,360 --> 00:02:30,160
our

72
00:02:30,160 --> 00:02:31,840
agenda for today or

73
00:02:31,840 --> 00:02:33,840
so we'll first start with the motivation

74
00:02:33,840 --> 00:02:36,239
uh basically we'll talk about how common

75
00:02:36,239 --> 00:02:38,400
is this uh sql injection example how

76
00:02:38,400 --> 00:02:40,080
common this code pattern here and then

77
00:02:40,080 --> 00:02:42,239
we will go into single repo analysis

78
00:02:42,239 --> 00:02:44,319
we'll take that sql injection that lives

79
00:02:44,319 --> 00:02:46,000
in one code base and see how can we find

80
00:02:46,000 --> 00:02:47,760
this with tinfoil analysis uh in this

81
00:02:47,760 --> 00:02:49,280
section we'll try to get the background

82
00:02:49,280 --> 00:02:51,440
information for the section after cross

83
00:02:51,440 --> 00:02:53,040
free potential analysis which we will

84
00:02:53,040 --> 00:02:55,280
dive deep into info analysis how we can

85
00:02:55,280 --> 00:02:57,440
find that sql injection between two

86
00:02:57,440 --> 00:03:00,400
different uh code bases and then to the

87
00:03:00,400 --> 00:03:02,239
example flow which is my favorite

88
00:03:02,239 --> 00:03:04,239
section here because we will show you a

89
00:03:04,239 --> 00:03:06,480
real vulnerability that we have found

90
00:03:06,480 --> 00:03:09,280
with course repo analysis and showing

91
00:03:09,280 --> 00:03:11,360
you the real impact here and then i

92
00:03:11,360 --> 00:03:13,760
would like to end up with looking for it

93
00:03:13,760 --> 00:03:16,720
how i see this moving uh over time and

94
00:03:16,720 --> 00:03:19,280
sharing some thoughts and ideas now

95
00:03:19,280 --> 00:03:21,120
let's start with this sql injection

96
00:03:21,120 --> 00:03:22,480
example probably when you have seen this

97
00:03:22,480 --> 00:03:24,480
code you either think it's like

98
00:03:24,480 --> 00:03:27,200
is this common uh how common is this in

99
00:03:27,200 --> 00:03:29,120
in code basis or the other idea is like

100
00:03:29,120 --> 00:03:30,799
yeah i have seen this in our code base

101
00:03:30,799 --> 00:03:32,640
i've seen this we're doing this all over

102
00:03:32,640 --> 00:03:33,680
the place but

103
00:03:33,680 --> 00:03:35,440
to give you more background and context

104
00:03:35,440 --> 00:03:37,360
about this usually when you build system

105
00:03:37,360 --> 00:03:39,120
you start with something like this so

106
00:03:39,120 --> 00:03:42,000
you have uh one application monolithic

107
00:03:42,000 --> 00:03:44,000
code base has more of your application

108
00:03:44,000 --> 00:03:45,760
logic that connects with one database to

109
00:03:45,760 --> 00:03:48,080
read and retrieve data but sooner or

110
00:03:48,080 --> 00:03:49,599
later we realize that there are a couple

111
00:03:49,599 --> 00:03:51,120
of problems here one this is not very

112
00:03:51,120 --> 00:03:52,239
scalable

113
00:03:52,239 --> 00:03:54,560
also might have not the best not the

114
00:03:54,560 --> 00:03:56,560
best performance and then you will start

115
00:03:56,560 --> 00:03:58,640
to move into that direction here so you

116
00:03:58,640 --> 00:04:00,400
have your application logic and you have

117
00:04:00,400 --> 00:04:02,319
different services that communicate with

118
00:04:02,319 --> 00:04:04,239
your application logic previously these

119
00:04:04,239 --> 00:04:05,840
were part of your application logic but

120
00:04:05,840 --> 00:04:07,519
now your application logic is less

121
00:04:07,519 --> 00:04:08,959
encode and you have different dedicated

122
00:04:08,959 --> 00:04:11,360
services this approach is kind of is

123
00:04:11,360 --> 00:04:13,280
becoming more popular because you can

124
00:04:13,280 --> 00:04:14,959
take the service scale it you can write

125
00:04:14,959 --> 00:04:16,399
the service let's say the authentication

126
00:04:16,399 --> 00:04:17,918
service you can write this in c or c

127
00:04:17,918 --> 00:04:19,839
plus which is more performant than what

128
00:04:19,839 --> 00:04:21,199
language that you use in application

129
00:04:21,199 --> 00:04:23,600
logic and to take as an example so we

130
00:04:23,600 --> 00:04:25,040
have twitter here this is a slide from

131
00:04:25,040 --> 00:04:27,520
twitter around 2014

132
00:04:27,520 --> 00:04:30,000
you can see one monolithic code base

133
00:04:30,000 --> 00:04:32,400
connecting to the database to store and

134
00:04:32,400 --> 00:04:34,560
retrieve data which is normal and

135
00:04:34,560 --> 00:04:36,880
natural to do in the beginning of your

136
00:04:36,880 --> 00:04:39,600
system before like very kind of hard

137
00:04:39,600 --> 00:04:42,160
scaling limitations but then we see

138
00:04:42,160 --> 00:04:44,720
twitter evolving to that there to to

139
00:04:44,720 --> 00:04:47,040
that design here a lot of services

140
00:04:47,040 --> 00:04:48,800
communicating with each other and again

141
00:04:48,800 --> 00:04:50,960
this is normal as you scale another

142
00:04:50,960 --> 00:04:54,000
example is netflix again initially you

143
00:04:54,000 --> 00:04:55,199
start with

144
00:04:55,199 --> 00:04:57,199
one monolithic codebase one monolithic

145
00:04:57,199 --> 00:04:59,759
database but then you see them evolving

146
00:04:59,759 --> 00:05:01,280
into something like this a lot of

147
00:05:01,280 --> 00:05:03,039
services communicating with each other

148
00:05:03,039 --> 00:05:04,000
so

149
00:05:04,000 --> 00:05:06,720
that sql injection or that

150
00:05:06,720 --> 00:05:08,720
vulnerabilities that exist between

151
00:05:08,720 --> 00:05:10,479
different code bases they are there

152
00:05:10,479 --> 00:05:12,240
because you have now your application

153
00:05:12,240 --> 00:05:13,680
connecting with services but just

154
00:05:13,680 --> 00:05:15,199
availability lives between these

155
00:05:15,199 --> 00:05:17,199
services it's deeper in your attack

156
00:05:17,199 --> 00:05:19,360
surface but they do exist

157
00:05:19,360 --> 00:05:21,440
in our case in our demo example we have

158
00:05:21,440 --> 00:05:23,840
an application logic written in php and

159
00:05:23,840 --> 00:05:25,759
our backend service written in python

160
00:05:25,759 --> 00:05:27,360
and the sql injection is split between

161
00:05:27,360 --> 00:05:28,080
both

162
00:05:28,080 --> 00:05:30,320
another case why cross repo is important

163
00:05:30,320 --> 00:05:33,199
is scalability so in facebook we know

164
00:05:33,199 --> 00:05:35,680
that it's difficult to review code

165
00:05:35,680 --> 00:05:36,720
manually

166
00:05:36,720 --> 00:05:38,240
as security engineers you don't have a

167
00:05:38,240 --> 00:05:39,520
lot of security engineers comparing to

168
00:05:39,520 --> 00:05:41,120
the software engineer teams

169
00:05:41,120 --> 00:05:43,120
that you have so we need automation and

170
00:05:43,120 --> 00:05:45,360
we rely heavily on static analysis so we

171
00:05:45,360 --> 00:05:46,880
usually follow this strategy here you

172
00:05:46,880 --> 00:05:48,400
have your code base analyze this with

173
00:05:48,400 --> 00:05:49,680
static analysis

174
00:05:49,680 --> 00:05:52,000
security engineers review the results

175
00:05:52,000 --> 00:05:54,000
and identify valid vulnerabilities this

176
00:05:54,000 --> 00:05:56,080
scales scales up very well and we will

177
00:05:56,080 --> 00:05:58,240
see that but and also you can take this

178
00:05:58,240 --> 00:06:00,160
apply to different products it also

179
00:06:00,160 --> 00:06:01,759
scales and it enables us to scale our

180
00:06:01,759 --> 00:06:03,600
security team but when you draw the full

181
00:06:03,600 --> 00:06:05,520
picture you have something like this so

182
00:06:05,520 --> 00:06:07,440
you have your user facing applications

183
00:06:07,440 --> 00:06:08,880
connecting with back-end servers what do

184
00:06:08,880 --> 00:06:10,720
you do with the back-end services do we

185
00:06:10,720 --> 00:06:12,000
run static analysis without any

186
00:06:12,000 --> 00:06:13,600
information about their attack surface

187
00:06:13,600 --> 00:06:15,840
from user-facing application if we do

188
00:06:15,840 --> 00:06:19,039
that the noise will be high and we won't

189
00:06:19,039 --> 00:06:21,280
be able to tackle that noisy issues and

190
00:06:21,280 --> 00:06:23,280
we want to have a good idea of which

191
00:06:23,280 --> 00:06:24,800
vulnerabilities are exploitable

192
00:06:24,800 --> 00:06:26,560
reachable from outside versus which ones

193
00:06:26,560 --> 00:06:28,560
are only internally reachable or even

194
00:06:28,560 --> 00:06:30,080
not reachable at all because there are

195
00:06:30,080 --> 00:06:32,000
no servers that is calling that

196
00:06:32,000 --> 00:06:34,080
and also we know that we cannot manually

197
00:06:34,080 --> 00:06:35,199
review these back-end services because

198
00:06:35,199 --> 00:06:37,199
they are a lot it's not the way to scale

199
00:06:37,199 --> 00:06:39,120
so with cross-repo analysis we are able

200
00:06:39,120 --> 00:06:41,919
to find the full path the full attack

201
00:06:41,919 --> 00:06:43,840
surface until we had the service which

202
00:06:43,840 --> 00:06:45,199
helps us a lot

203
00:06:45,199 --> 00:06:47,520
with scaling

204
00:06:47,520 --> 00:06:50,639
i now let's jump into static analysis

205
00:06:50,639 --> 00:06:52,160
static analysis is one of the worlds

206
00:06:52,160 --> 00:06:52,880
that

207
00:06:52,880 --> 00:06:54,720
can be easily overloaded it can mean

208
00:06:54,720 --> 00:06:56,560
different things running grip on files

209
00:06:56,560 --> 00:06:58,160
scroll starting assets linters are

210
00:06:58,160 --> 00:06:59,680
corresponding analysis but what do we

211
00:06:59,680 --> 00:07:01,680
mean by static analysis here is obtain

212
00:07:01,680 --> 00:07:03,280
flow analysis and if you don't know what

213
00:07:03,280 --> 00:07:05,280
data analysis mean that is fine because

214
00:07:05,280 --> 00:07:06,479
this is what i'm going to show you next

215
00:07:06,479 --> 00:07:09,120
so let's go back to our single repo

216
00:07:09,120 --> 00:07:10,720
example here sql injection so we know

217
00:07:10,720 --> 00:07:13,440
there is a sql injection here and uh

218
00:07:13,440 --> 00:07:15,599
in order for me to show you how to

219
00:07:15,599 --> 00:07:17,120
influence us can find that sql induction

220
00:07:17,120 --> 00:07:18,800
let's follow this approach let's find

221
00:07:18,800 --> 00:07:20,000
the vulnerability with manual code

222
00:07:20,000 --> 00:07:22,560
review manually and then see how a team

223
00:07:22,560 --> 00:07:24,319
flow analysis tool will find this uh

224
00:07:24,319 --> 00:07:26,479
vulnerability for us so manually what

225
00:07:26,479 --> 00:07:27,759
you would do you will start reviewing

226
00:07:27,759 --> 00:07:29,680
code so you will start from wrap get

227
00:07:29,680 --> 00:07:32,000
page name you will realize it calls the

228
00:07:32,000 --> 00:07:34,000
get page name and then you will go into

229
00:07:34,000 --> 00:07:36,080
git page name you realize it calls the

230
00:07:36,080 --> 00:07:38,160
request and once you go into that you

231
00:07:38,160 --> 00:07:40,319
also realize that it calls returns the

232
00:07:40,319 --> 00:07:41,919
super global php request so you know

233
00:07:41,919 --> 00:07:43,680
that super global

234
00:07:43,680 --> 00:07:45,759
the request which is a user controlled

235
00:07:45,759 --> 00:07:48,080
input goes back to get page name and

236
00:07:48,080 --> 00:07:50,479
returns to the wrap gate page name you

237
00:07:50,479 --> 00:07:51,680
will take that information and then

238
00:07:51,680 --> 00:07:53,039
review the second function which is the

239
00:07:53,039 --> 00:07:54,879
wrap fetch data you go there it takes

240
00:07:54,879 --> 00:07:56,879
the arguments call fetch data and then

241
00:07:56,879 --> 00:07:59,360
you go one step deeper it also uh it

242
00:07:59,360 --> 00:08:01,120
takes the argument concatenate this with

243
00:08:01,120 --> 00:08:04,639
a string and it calls mysql query as a

244
00:08:04,639 --> 00:08:05,840
security engineer or a security

245
00:08:05,840 --> 00:08:07,360
consultant you will realize that okay

246
00:08:07,360 --> 00:08:08,639
there is probably a sql injection

247
00:08:08,639 --> 00:08:10,800
vulnerability here mysql query is not

248
00:08:10,800 --> 00:08:13,199
sql safe if there's no validation or uh

249
00:08:13,199 --> 00:08:15,120
data standardization happens and because

250
00:08:15,120 --> 00:08:16,800
we have user controlled the input from

251
00:08:16,800 --> 00:08:19,360
rav gate page name to wrap fetch data

252
00:08:19,360 --> 00:08:21,440
then that is a sql injection now let's

253
00:08:21,440 --> 00:08:22,879
put the teen flow static analysis head

254
00:08:22,879 --> 00:08:24,319
on and see how can we detect this with

255
00:08:24,319 --> 00:08:26,160
teen analysis or how a team flow

256
00:08:26,160 --> 00:08:28,319
analysis tool should work so it will

257
00:08:28,319 --> 00:08:30,479
work more or less the same so the tool

258
00:08:30,479 --> 00:08:32,479
will start from the wrap gateway chain

259
00:08:32,479 --> 00:08:34,799
and try to analyze this function but to

260
00:08:34,799 --> 00:08:36,399
give you an a good understanding of how

261
00:08:36,399 --> 00:08:38,159
it works let's start from the deepest

262
00:08:38,159 --> 00:08:40,240
call or the request function so when the

263
00:08:40,240 --> 00:08:42,000
team's analysis tool analyzes this

264
00:08:42,000 --> 00:08:44,000
function it will say this function is

265
00:08:44,000 --> 00:08:46,399
returning a user controlled source so

266
00:08:46,399 --> 00:08:49,200
what is a source so a source means is a

267
00:08:49,200 --> 00:08:50,959
function or a method that returns

268
00:08:50,959 --> 00:08:53,279
tainted data or data that the flow

269
00:08:53,279 --> 00:08:55,519
analysis tool want to track across the

270
00:08:55,519 --> 00:08:56,959
call graph the team flow analysis will

271
00:08:56,959 --> 00:08:59,519
want to see where this data is going so

272
00:08:59,519 --> 00:09:01,519
here we're marking the return of this

273
00:09:01,519 --> 00:09:03,519
request as user controlled source this

274
00:09:03,519 --> 00:09:05,680
is the initial configuration that we

275
00:09:05,680 --> 00:09:07,440
give the tool so the tool knows that

276
00:09:07,440 --> 00:09:08,959
okay this is returning user controlled

277
00:09:08,959 --> 00:09:11,279
source it will also analyze uh get page

278
00:09:11,279 --> 00:09:13,680
name which also return uh the result

279
00:09:13,680 --> 00:09:15,360
from request which also use a control

280
00:09:15,360 --> 00:09:17,040
source we'll do the same with the wrap

281
00:09:17,040 --> 00:09:18,480
gate page name and then now the tools

282
00:09:18,480 --> 00:09:20,399
know that x is coming from my user

283
00:09:20,399 --> 00:09:22,880
control source now the team analysis

284
00:09:22,880 --> 00:09:24,560
will analyze wrap pitch data which

285
00:09:24,560 --> 00:09:26,720
realize that fetch data calls into

286
00:09:26,720 --> 00:09:29,200
passes the argument into mysql query and

287
00:09:29,200 --> 00:09:30,800
mysql query will be provided in the

288
00:09:30,800 --> 00:09:33,839
configuration as a sql i sync so what is

289
00:09:33,839 --> 00:09:36,560
a sync a sync is a function

290
00:09:36,560 --> 00:09:40,399
that we want uh we want to see any

291
00:09:40,399 --> 00:09:42,000
tainted data that flow into that

292
00:09:42,000 --> 00:09:43,519
function whenever there is tainted data

293
00:09:43,519 --> 00:09:45,120
that flows into that function we want to

294
00:09:45,120 --> 00:09:47,040
create an issue or we want to highlight

295
00:09:47,040 --> 00:09:49,360
that flow so the mysql query is our

296
00:09:49,360 --> 00:09:50,959
initial configuration and then the tone

297
00:09:50,959 --> 00:09:53,040
flow analysis tool knows that fetch data

298
00:09:53,040 --> 00:09:55,040
leads to a sql sync and also know that

299
00:09:55,040 --> 00:09:58,000
wrap fetch data leads also to a sql sync

300
00:09:58,000 --> 00:09:58,880
and

301
00:09:58,880 --> 00:10:01,200
and now with these two combined we will

302
00:10:01,200 --> 00:10:02,880
have a rule that says

303
00:10:02,880 --> 00:10:04,880
if you have a source coming from user

304
00:10:04,880 --> 00:10:06,560
controlled and

305
00:10:06,560 --> 00:10:09,519
that flowing into a sink of type sql i

306
00:10:09,519 --> 00:10:11,440
then that is a potential sql injection

307
00:10:11,440 --> 00:10:14,560
vulnerability to see everything in one

308
00:10:14,560 --> 00:10:16,160
slide

309
00:10:16,160 --> 00:10:18,000
you have the trace here so a trace is

310
00:10:18,000 --> 00:10:20,320
how the data is flowing between a source

311
00:10:20,320 --> 00:10:22,959
to a sink we start from the bottom left

312
00:10:22,959 --> 00:10:25,440
request return a source which forward

313
00:10:25,440 --> 00:10:26,959
that to get page name which was that to

314
00:10:26,959 --> 00:10:29,120
wrap gate page name and then the root in

315
00:10:29,120 --> 00:10:30,880
the root get response we take that

316
00:10:30,880 --> 00:10:33,200
argument pass it down until we hit our

317
00:10:33,200 --> 00:10:35,279
sync the mysql query

318
00:10:35,279 --> 00:10:36,480
sync here

319
00:10:36,480 --> 00:10:38,000
with this technology

320
00:10:38,000 --> 00:10:39,519
we were able

321
00:10:39,519 --> 00:10:42,480
to create three tools that does exactly

322
00:10:42,480 --> 00:10:45,200
the same zone clan attain flow analysis

323
00:10:45,200 --> 00:10:47,680
tool for hacc it analyzes facebook.com

324
00:10:47,680 --> 00:10:49,200
oculus.com and other websites that are

325
00:10:49,200 --> 00:10:51,040
powered by hack i think zone clan

326
00:10:51,040 --> 00:10:52,800
analyzes around 100 millions lines of

327
00:10:52,800 --> 00:10:56,399
code uh in in our code base pisa is our

328
00:10:56,399 --> 00:10:58,320
static analysis tool for python it's

329
00:10:58,320 --> 00:11:01,040
open source it is free and we use this

330
00:11:01,040 --> 00:11:03,760
to scan and protect instagram.com

331
00:11:03,760 --> 00:11:05,839
mariana trench which is our recently

332
00:11:05,839 --> 00:11:07,920
open source stainflow analysis tool for

333
00:11:07,920 --> 00:11:09,839
java and android code we use mariah

334
00:11:09,839 --> 00:11:11,440
trying to analyze our mobile application

335
00:11:11,440 --> 00:11:13,120
on our java backend

336
00:11:13,120 --> 00:11:15,440
services these three static analysis

337
00:11:15,440 --> 00:11:17,200
tool rely on the same technology that

338
00:11:17,200 --> 00:11:19,600
i've just explained to you

339
00:11:19,600 --> 00:11:21,839
to see how these work and what's kind of

340
00:11:21,839 --> 00:11:23,600
when do they work let's look at this

341
00:11:23,600 --> 00:11:26,079
kind of architecture diagram so security

342
00:11:26,079 --> 00:11:27,680
engineers define sources things and

343
00:11:27,680 --> 00:11:30,160
rules for every tool depending depending

344
00:11:30,160 --> 00:11:32,000
on the code base we run the correct tool

345
00:11:32,000 --> 00:11:34,000
so php we're on zonkland python we run

346
00:11:34,000 --> 00:11:36,560
pisa java we're in a trench we analyze

347
00:11:36,560 --> 00:11:38,160
the code store the result into the

348
00:11:38,160 --> 00:11:40,959
database for a later consumption or a

349
00:11:40,959 --> 00:11:43,279
triage by security engineers

350
00:11:43,279 --> 00:11:45,839
and with that we were able to find fifty

351
00:11:45,839 --> 00:11:47,440
percent of the vulnerable

352
00:11:47,440 --> 00:11:48,959
vulnerabilities that we found through

353
00:11:48,959 --> 00:11:50,959
automation so fifty percent of all the

354
00:11:50,959 --> 00:11:52,320
security vulnerability that we found

355
00:11:52,320 --> 00:11:54,800
from white hat from uh manual code

356
00:11:54,800 --> 00:11:57,200
reviews 50 of that number came from

357
00:11:57,200 --> 00:11:58,959
automation automation include static

358
00:11:58,959 --> 00:12:00,480
analysis and dynamic analysis but big

359
00:12:00,480 --> 00:12:01,839
portion of that came from static

360
00:12:01,839 --> 00:12:03,279
analysis and from the tools that i've

361
00:12:03,279 --> 00:12:05,519
just explained to you now

362
00:12:05,519 --> 00:12:08,000
with single repo analysis out of the way

363
00:12:08,000 --> 00:12:10,160
let's jump into the main topic or the

364
00:12:10,160 --> 00:12:12,639
cross repo team flow analysis let's go

365
00:12:12,639 --> 00:12:14,240
to that sql injection and how we can

366
00:12:14,240 --> 00:12:16,079
find that sql injection across two code

367
00:12:16,079 --> 00:12:18,880
bases with tin flow analysis uh we'll

368
00:12:18,880 --> 00:12:20,560
follow the same approach we will start

369
00:12:20,560 --> 00:12:22,560
off with doing this with manual code

370
00:12:22,560 --> 00:12:24,240
review and then see how a inflow

371
00:12:24,240 --> 00:12:26,880
analysis tool will find this for us so

372
00:12:26,880 --> 00:12:28,639
with manual code review you will

373
00:12:28,639 --> 00:12:30,320
probably start from the php side we know

374
00:12:30,320 --> 00:12:32,079
how it starts from the previous example

375
00:12:32,079 --> 00:12:33,839
but then you realize that there is a

376
00:12:33,839 --> 00:12:36,880
socket you're creating a http client

377
00:12:36,880 --> 00:12:38,079
you're calling some service and you're

378
00:12:38,079 --> 00:12:40,240
fetching data and then sooner you you

379
00:12:40,240 --> 00:12:42,240
realize that this is thrift so as you're

380
00:12:42,240 --> 00:12:43,600
reading the code as a security engineer

381
00:12:43,600 --> 00:12:45,440
you will realize that this is a thrift

382
00:12:45,440 --> 00:12:46,880
gold what is a thrift thrift is a

383
00:12:46,880 --> 00:12:48,480
lightweight language independent

384
00:12:48,480 --> 00:12:51,839
software stack for point to point rpc uh

385
00:12:51,839 --> 00:12:53,680
implementation so thrift you can think

386
00:12:53,680 --> 00:12:55,440
of it as an abstraction that would allow

387
00:12:55,440 --> 00:12:57,839
software engineers to define a service

388
00:12:57,839 --> 00:13:00,399
that says i have a service that that is

389
00:13:00,399 --> 00:13:02,320
exporting this api

390
00:13:02,320 --> 00:13:04,079
i write this and enter in an interface

391
00:13:04,079 --> 00:13:05,600
language and then thrift will auto

392
00:13:05,600 --> 00:13:08,320
generate good for all clients to connect

393
00:13:08,320 --> 00:13:10,320
to that service and it will create stubs

394
00:13:10,320 --> 00:13:12,560
for how the server should be implemented

395
00:13:12,560 --> 00:13:13,600
so

396
00:13:13,600 --> 00:13:15,600
that's good here it's auto generated

397
00:13:15,600 --> 00:13:17,600
code or like that the page service async

398
00:13:17,600 --> 00:13:19,519
client this client is auto generated

399
00:13:19,519 --> 00:13:21,839
code and we use this internally to be

400
00:13:21,839 --> 00:13:23,600
able to have this rpc connections

401
00:13:23,600 --> 00:13:26,399
between services uh and and and client

402
00:13:26,399 --> 00:13:28,320
so after you gain that knowledge and

403
00:13:28,320 --> 00:13:30,320
notice this is an extra overhead for

404
00:13:30,320 --> 00:13:32,720
security engineers which is a very

405
00:13:32,720 --> 00:13:34,160
manual process which is part of the

406
00:13:34,160 --> 00:13:36,000
manual review and it would be great if

407
00:13:36,000 --> 00:13:38,800
you can make static analysis aware and

408
00:13:38,800 --> 00:13:41,440
familiar with that so once you do this

409
00:13:41,440 --> 00:13:42,720
you would want probably to know okay

410
00:13:42,720 --> 00:13:44,160
what is the service that i'm calling and

411
00:13:44,160 --> 00:13:46,320
you realize it's page service

412
00:13:46,320 --> 00:13:48,880
from the client class page service async

413
00:13:48,880 --> 00:13:50,240
client so

414
00:13:50,240 --> 00:13:52,079
to sum this up you have two flows one

415
00:13:52,079 --> 00:13:54,000
here is coming from the request so the

416
00:13:54,000 --> 00:13:56,399
the user uh the data coming from user

417
00:13:56,399 --> 00:13:58,560
controlled and then flowing into a call

418
00:13:58,560 --> 00:14:00,959
to a thrift service now

419
00:14:00,959 --> 00:14:03,040
with that we jump into the other part

420
00:14:03,040 --> 00:14:04,959
which is the server implementation it is

421
00:14:04,959 --> 00:14:06,800
implemented in python here again i know

422
00:14:06,800 --> 00:14:08,800
there's a lot of code but it's part of

423
00:14:08,800 --> 00:14:10,800
thrift being aware of that

424
00:14:10,800 --> 00:14:12,399
let's focus on the function that we care

425
00:14:12,399 --> 00:14:14,959
about fetch data this is very simple it

426
00:14:14,959 --> 00:14:16,480
takes an argument

427
00:14:16,480 --> 00:14:19,199
construct a query and execute that query

428
00:14:19,199 --> 00:14:21,360
as a sql query from the cursor execute

429
00:14:21,360 --> 00:14:23,199
from a manual code review perspective

430
00:14:23,199 --> 00:14:24,800
you take the argument which you know

431
00:14:24,800 --> 00:14:28,320
from php is user controlled and then you

432
00:14:28,320 --> 00:14:30,399
go into cursor execute which

433
00:14:30,399 --> 00:14:32,160
also you know that if there's no data

434
00:14:32,160 --> 00:14:33,600
validation or

435
00:14:33,600 --> 00:14:35,839
sanitization this will lead to a sql

436
00:14:35,839 --> 00:14:37,920
injection now with both in mind so you

437
00:14:37,920 --> 00:14:39,600
know there's the php part that is user

438
00:14:39,600 --> 00:14:40,959
control that is calling the service and

439
00:14:40,959 --> 00:14:42,240
here is the implementation of that

440
00:14:42,240 --> 00:14:44,240
service you have your sql injection with

441
00:14:44,240 --> 00:14:46,800
manual code review so if we were to find

442
00:14:46,800 --> 00:14:48,639
this with thin flow analysis uh you

443
00:14:48,639 --> 00:14:50,079
probably want something like this so if

444
00:14:50,079 --> 00:14:52,639
i have a php static analysis tool

445
00:14:52,639 --> 00:14:54,880
that can review the code and can

446
00:14:54,880 --> 00:14:56,639
understand that this is a call to a 3 of

447
00:14:56,639 --> 00:14:57,519
service

448
00:14:57,519 --> 00:14:59,519
we can probably use oncloud for that and

449
00:14:59,519 --> 00:15:01,519
then if i have a python static analysis

450
00:15:01,519 --> 00:15:04,560
tool that can review the code and also

451
00:15:04,560 --> 00:15:06,959
identify that this function is a service

452
00:15:06,959 --> 00:15:09,120
a thrift service implementation we can

453
00:15:09,120 --> 00:15:11,680
use pisa for that and somehow make these

454
00:15:11,680 --> 00:15:13,839
tools connect to each other and the

455
00:15:13,839 --> 00:15:17,040
zomcon says hey pisa i know that someone

456
00:15:17,040 --> 00:15:18,399
that is user controlled input or

457
00:15:18,399 --> 00:15:20,000
interested in but going to the service

458
00:15:20,000 --> 00:15:21,920
and then pc says oh and this also is

459
00:15:21,920 --> 00:15:23,680
going to a sql injection let's see that

460
00:15:23,680 --> 00:15:25,519
in action so

461
00:15:25,519 --> 00:15:28,079
the uh wrap get page name so from let's

462
00:15:28,079 --> 00:15:29,279
let's put the thing for an access tool

463
00:15:29,279 --> 00:15:31,040
and see how the team flawless tool will

464
00:15:31,040 --> 00:15:33,440
or zonecon will analyze this codebase so

465
00:15:33,440 --> 00:15:35,360
it will start usually with analyzing the

466
00:15:35,360 --> 00:15:36,880
code normally so it analyzes this code

467
00:15:36,880 --> 00:15:38,880
but then it also realized that okay

468
00:15:38,880 --> 00:15:40,639
there is a thrift goal here so we want

469
00:15:40,639 --> 00:15:43,920
to mark all thrift calls as syncs

470
00:15:43,920 --> 00:15:45,759
whenever we're calling a thrift service

471
00:15:45,759 --> 00:15:48,079
you want to mark this as a sync so i we

472
00:15:48,079 --> 00:15:50,720
map all user controlled input to that

473
00:15:50,720 --> 00:15:52,480
thrift service and once you do this we

474
00:15:52,480 --> 00:15:54,880
call we call this the producer run so

475
00:15:54,880 --> 00:15:56,320
the zonecon is running and identifying

476
00:15:56,320 --> 00:15:59,040
flows from user input to these services

477
00:15:59,040 --> 00:16:01,440
in a producer run and you want to store

478
00:16:01,440 --> 00:16:03,040
we call this a partial flow because the

479
00:16:03,040 --> 00:16:05,440
flow is not leading to a real sync it's

480
00:16:05,440 --> 00:16:06,959
leading to that

481
00:16:06,959 --> 00:16:08,800
kind of intermediate sync which is the

482
00:16:08,800 --> 00:16:10,480
thrift rpc you want to have this

483
00:16:10,480 --> 00:16:12,079
information and then store it into a

484
00:16:12,079 --> 00:16:14,240
database so we see here we're storing

485
00:16:14,240 --> 00:16:16,639
this data which here the the information

486
00:16:16,639 --> 00:16:18,639
external user controlled input going to

487
00:16:18,639 --> 00:16:20,959
page service fetch data notice here that

488
00:16:20,959 --> 00:16:23,839
we are not using the page service async

489
00:16:23,839 --> 00:16:25,279
client or the page service client we're

490
00:16:25,279 --> 00:16:27,360
using the canonical name of the service

491
00:16:27,360 --> 00:16:29,360
and not the actual client name that is

492
00:16:29,360 --> 00:16:31,759
auto generated from thrift once you do

493
00:16:31,759 --> 00:16:33,600
this let's go to the python part so

494
00:16:33,600 --> 00:16:35,600
python the first thing that you want

495
00:16:35,600 --> 00:16:37,120
your static analysis tool to be familiar

496
00:16:37,120 --> 00:16:38,720
with that this is a thrift

497
00:16:38,720 --> 00:16:40,480
implementation or this is the

498
00:16:40,480 --> 00:16:42,800
implementation of uh my thrift call so

499
00:16:42,800 --> 00:16:44,480
once the tool knows this and this is

500
00:16:44,480 --> 00:16:46,720
before the analysis the tool will need

501
00:16:46,720 --> 00:16:48,959
to look up that database and say okay do

502
00:16:48,959 --> 00:16:51,120
i have any information that i need to be

503
00:16:51,120 --> 00:16:53,759
aware of before my analysis

504
00:16:53,759 --> 00:16:55,839
and uh so the tool will look up with the

505
00:16:55,839 --> 00:16:57,040
canonical name it figure out the

506
00:16:57,040 --> 00:16:58,480
canonical name and then it will look up

507
00:16:58,480 --> 00:17:00,160
into the database we realize that

508
00:17:00,160 --> 00:17:01,920
donclan have actually stored some data

509
00:17:01,920 --> 00:17:04,240
there for the tool for to be to be used

510
00:17:04,240 --> 00:17:06,000
before the analysis so the tool will

511
00:17:06,000 --> 00:17:07,760
take that information augment its

512
00:17:07,760 --> 00:17:09,520
initial model so now before the analysis

513
00:17:09,520 --> 00:17:10,640
i will augment that information i will

514
00:17:10,640 --> 00:17:12,079
keep in mind that zomcon told me that

515
00:17:12,079 --> 00:17:13,679
there is user controlled input here and

516
00:17:13,679 --> 00:17:15,679
then i will just analyze normally and

517
00:17:15,679 --> 00:17:17,199
eventually you will be able to find that

518
00:17:17,199 --> 00:17:19,760
sql injection the coming two slides are

519
00:17:19,760 --> 00:17:21,679
they have a lot of information but i

520
00:17:21,679 --> 00:17:23,520
i'll try to abstract as much as i can

521
00:17:23,520 --> 00:17:25,359
but i would really like to show you or

522
00:17:25,359 --> 00:17:27,119
give you a sense of what goes under the

523
00:17:27,119 --> 00:17:29,360
hood for these two tools so

524
00:17:29,360 --> 00:17:32,559
here is the model or the tint uh summary

525
00:17:32,559 --> 00:17:34,400
from zonk line you see here we have

526
00:17:34,400 --> 00:17:36,559
external user controlled input coming

527
00:17:36,559 --> 00:17:39,280
from a rob get page name and flowing to

528
00:17:39,280 --> 00:17:42,080
the paid service async client fetch data

529
00:17:42,080 --> 00:17:44,320
which is marked as a sync here notice

530
00:17:44,320 --> 00:17:46,720
that the service name or the sync name

531
00:17:46,720 --> 00:17:48,799
is the actual service async client not

532
00:17:48,799 --> 00:17:51,360
the canonical name and then what we want

533
00:17:51,360 --> 00:17:54,640
to do is take that and then create the

534
00:17:54,640 --> 00:17:56,720
kind of partial flow from that so we

535
00:17:56,720 --> 00:17:58,559
replace the name with the canonical name

536
00:17:58,559 --> 00:18:00,559
page service fetch data and source and

537
00:18:00,559 --> 00:18:02,400
then we store that into a database so

538
00:18:02,400 --> 00:18:04,559
this is just uh this box here is the

539
00:18:04,559 --> 00:18:06,160
same as this book but here stored as a

540
00:18:06,160 --> 00:18:08,480
row in the database now

541
00:18:08,480 --> 00:18:11,280
on the python side what this is the

542
00:18:11,280 --> 00:18:13,679
summary before anything which is empty

543
00:18:13,679 --> 00:18:15,520
we don't know anything and what you want

544
00:18:15,520 --> 00:18:16,960
the static answers tool to know that

545
00:18:16,960 --> 00:18:18,640
okay this is a thrift implementation let

546
00:18:18,640 --> 00:18:20,240
me look up the database so it looks at

547
00:18:20,240 --> 00:18:22,240
the database it finds information coming

548
00:18:22,240 --> 00:18:24,320
from zonkline which is the producer

549
00:18:24,320 --> 00:18:26,400
and this is the consumer run or the one

550
00:18:26,400 --> 00:18:27,919
that will re use the data from the

551
00:18:27,919 --> 00:18:30,480
producer before the analysis so and it

552
00:18:30,480 --> 00:18:32,480
augments these models again before the

553
00:18:32,480 --> 00:18:34,880
analysis we augment this model with

554
00:18:34,880 --> 00:18:36,480
external user control coming from zone

555
00:18:36,480 --> 00:18:38,480
client and then start analyzing that

556
00:18:38,480 --> 00:18:40,400
python code and after analyzing that

557
00:18:40,400 --> 00:18:42,720
python code then you see here we are

558
00:18:42,720 --> 00:18:45,039
going to this uh full you have the full

559
00:18:45,039 --> 00:18:46,240
thin flow we have external user

560
00:18:46,240 --> 00:18:48,320
controlled going to the sql injection

561
00:18:48,320 --> 00:18:49,919
and now we have the sql injection

562
00:18:49,919 --> 00:18:51,760
vulnerability between two different code

563
00:18:51,760 --> 00:18:54,559
bases with stain flow analysis to see

564
00:18:54,559 --> 00:18:56,320
everything in one slide let's see our

565
00:18:56,320 --> 00:18:57,760
trace so

566
00:18:57,760 --> 00:18:59,440
the trace starts like similar to the

567
00:18:59,440 --> 00:19:00,880
previous example we start from request

568
00:19:00,880 --> 00:19:03,120
top left corner on the left hand side we

569
00:19:03,120 --> 00:19:04,799
see the php part on the right hand side

570
00:19:04,799 --> 00:19:06,720
we see the python part

571
00:19:06,720 --> 00:19:09,440
the root here is the canonical name of

572
00:19:09,440 --> 00:19:11,440
the service and the function name so

573
00:19:11,440 --> 00:19:13,039
this is like the canonical connection

574
00:19:13,039 --> 00:19:15,600
point and you see here the mangling and

575
00:19:15,600 --> 00:19:18,240
de-mangling of uh the service name so in

576
00:19:18,240 --> 00:19:20,080
the php the client called page service

577
00:19:20,080 --> 00:19:21,840
async client and on the right side is

578
00:19:21,840 --> 00:19:23,520
the page service handler which is the

579
00:19:23,520 --> 00:19:26,320
implementation for that service uh and

580
00:19:26,320 --> 00:19:28,080
yeah just the data flows from here to

581
00:19:28,080 --> 00:19:30,799
the service and then uh from the service

582
00:19:30,799 --> 00:19:33,280
back into the this thing function here

583
00:19:33,280 --> 00:19:36,480
so to recap if you want to do or to have

584
00:19:36,480 --> 00:19:38,720
like cross repotential analysis between

585
00:19:38,720 --> 00:19:40,640
uh taint analysis tools the first thing

586
00:19:40,640 --> 00:19:43,039
is that you want to mark your all rpc

587
00:19:43,039 --> 00:19:45,600
calls as things in our case this was fb

588
00:19:45,600 --> 00:19:47,760
thrift calls so we want to mark these as

589
00:19:47,760 --> 00:19:48,640
syncs

590
00:19:48,640 --> 00:19:50,480
so we can find the flows between user

591
00:19:50,480 --> 00:19:53,120
control to these things and then you

592
00:19:53,120 --> 00:19:54,880
want to define canonical connection

593
00:19:54,880 --> 00:19:56,799
points so given a service from the

594
00:19:56,799 --> 00:19:58,240
server implementation

595
00:19:58,240 --> 00:19:59,760
class or the actual implementation what

596
00:19:59,760 --> 00:20:01,120
kind of how can i go to the canonical

597
00:20:01,120 --> 00:20:02,480
connection point of that service and

598
00:20:02,480 --> 00:20:04,559
from the client call how can i find that

599
00:20:04,559 --> 00:20:06,320
canonical connection point because this

600
00:20:06,320 --> 00:20:07,760
kind of connection point is important

601
00:20:07,760 --> 00:20:08,640
because this is how you're going to

602
00:20:08,640 --> 00:20:11,440
store your data intermediately between

603
00:20:11,440 --> 00:20:12,799
these services and you'll be able to

604
00:20:12,799 --> 00:20:15,520
look up this data and then you want your

605
00:20:15,520 --> 00:20:16,960
engines to be able to find the flows

606
00:20:16,960 --> 00:20:18,799
from user controller input to the

607
00:20:18,799 --> 00:20:21,120
thrift goal which we call them the

608
00:20:21,120 --> 00:20:22,480
partial flows and this is in the

609
00:20:22,480 --> 00:20:25,440
producer run and then once the consumer

610
00:20:25,440 --> 00:20:26,880
engine or the other engine that's

611
00:20:26,880 --> 00:20:28,640
augmenting its initial model with that

612
00:20:28,640 --> 00:20:31,200
it can load this partial model

613
00:20:31,200 --> 00:20:33,039
and then start the analysis from there

614
00:20:33,039 --> 00:20:34,080
and last thing you want to make sure

615
00:20:34,080 --> 00:20:36,080
that you store this data

616
00:20:36,080 --> 00:20:37,120
in one

617
00:20:37,120 --> 00:20:38,559
in a format that you're able to

618
00:20:38,559 --> 00:20:41,039
visualize the entire flow seamlessly

619
00:20:41,039 --> 00:20:42,240
across code basis which is very

620
00:20:42,240 --> 00:20:43,520
important so security engineers and

621
00:20:43,520 --> 00:20:46,240
software engineers can act on that

622
00:20:46,240 --> 00:20:48,320
let's go back to our design diagram so

623
00:20:48,320 --> 00:20:49,919
it used to look something like this

624
00:20:49,919 --> 00:20:52,000
before cross three potential analysis

625
00:20:52,000 --> 00:20:54,000
but after crossfit influences it looks

626
00:20:54,000 --> 00:20:56,480
like this i know it is a lot here to

627
00:20:56,480 --> 00:20:58,720
take in so let's break it apart

628
00:20:58,720 --> 00:20:59,840
uh

629
00:20:59,840 --> 00:21:02,080
this is the producer run zonklan running

630
00:21:02,080 --> 00:21:03,520
in php we have security engineer

631
00:21:03,520 --> 00:21:05,440
defining sources and syncs remember now

632
00:21:05,440 --> 00:21:08,240
we have the syncs also as our rpc calls

633
00:21:08,240 --> 00:21:10,799
so zoneclone analysis php stores the

634
00:21:10,799 --> 00:21:12,000
results in the database normally but we

635
00:21:12,000 --> 00:21:14,000
have an extra step of extracting this

636
00:21:14,000 --> 00:21:16,000
partial model and storing them into a

637
00:21:16,000 --> 00:21:17,679
database that we call crtec and we will

638
00:21:17,679 --> 00:21:19,840
define in coming slides

639
00:21:19,840 --> 00:21:22,720
and then now on the consumer run pisa

640
00:21:22,720 --> 00:21:24,960
before the analysis it will look up the

641
00:21:24,960 --> 00:21:28,400
crtec to augment any initial model for

642
00:21:28,400 --> 00:21:30,240
thrift implementation we'll do the

643
00:21:30,240 --> 00:21:32,000
analysis normally store everything in

644
00:21:32,000 --> 00:21:34,080
the database and security engineers can

645
00:21:34,080 --> 00:21:36,559
see the entire flow there

646
00:21:36,559 --> 00:21:39,280
so what is crtx crtec is a tool

647
00:21:39,280 --> 00:21:41,440
independent store obtained information

648
00:21:41,440 --> 00:21:43,440
in the tool agnostic format so we want

649
00:21:43,440 --> 00:21:45,679
these tools to use that cirtec or an

650
00:21:45,679 --> 00:21:47,520
abstraction on top of db

651
00:21:47,520 --> 00:21:49,760
to store it in information uh to store

652
00:21:49,760 --> 00:21:51,600
to push and pull tainted informations

653
00:21:51,600 --> 00:21:53,760
these information are tool agnostic so

654
00:21:53,760 --> 00:21:56,159
zoom clone can push model pisa can pull

655
00:21:56,159 --> 00:21:59,440
that model and reuse it in its analysis

656
00:21:59,440 --> 00:22:00,559
now

657
00:22:00,559 --> 00:22:02,240
let's see how can we view the traces

658
00:22:02,240 --> 00:22:03,760
it's important to view the traces

659
00:22:03,760 --> 00:22:05,520
seamlessly so you can abstract all the

660
00:22:05,520 --> 00:22:07,200
complexities in between and all the

661
00:22:07,200 --> 00:22:08,720
overhead between of the thrift services

662
00:22:08,720 --> 00:22:10,400
or these connection

663
00:22:10,400 --> 00:22:12,799
points for security engineers for single

664
00:22:12,799 --> 00:22:15,280
repo analysis viewing the traces is

665
00:22:15,280 --> 00:22:16,960
straightforward you start with the root

666
00:22:16,960 --> 00:22:19,760
and then you expand the traces uh to the

667
00:22:19,760 --> 00:22:21,360
source leaf and to the sink leaf so you

668
00:22:21,360 --> 00:22:22,960
start at the root and then you go here

669
00:22:22,960 --> 00:22:24,720
uh drop drop traverse until you hit your

670
00:22:24,720 --> 00:22:26,799
sink leaf and then you go here until you

671
00:22:26,799 --> 00:22:28,880
hit your source leaf for

672
00:22:28,880 --> 00:22:31,840
uh cross revo analysis theoretically you

673
00:22:31,840 --> 00:22:33,360
want to do the same but there are a

674
00:22:33,360 --> 00:22:35,679
couple of differences one is the actual

675
00:22:35,679 --> 00:22:37,440
flow under the hood looks something like

676
00:22:37,440 --> 00:22:39,760
this source to a sink thrift call and

677
00:22:39,760 --> 00:22:41,679
then from the thrift implementation to

678
00:22:41,679 --> 00:22:43,440
your sink this is one difference the

679
00:22:43,440 --> 00:22:45,120
other difference is that

680
00:22:45,120 --> 00:22:46,720
these if you notice that like the one on

681
00:22:46,720 --> 00:22:48,000
the left and the other side are actually

682
00:22:48,000 --> 00:22:49,840
two different systems zonklan and pisa

683
00:22:49,840 --> 00:22:51,280
yes it happened that we created them at

684
00:22:51,280 --> 00:22:52,799
facebook but they are two different

685
00:22:52,799 --> 00:22:54,080
systems they can be in two different

686
00:22:54,080 --> 00:22:56,240
databases and they have their own

687
00:22:56,240 --> 00:22:58,320
different tables so you want to have

688
00:22:58,320 --> 00:23:00,720
some meta information of when you reach

689
00:23:00,720 --> 00:23:02,240
that route how can you go to the other

690
00:23:02,240 --> 00:23:03,280
part so

691
00:23:03,280 --> 00:23:04,880
in order to

692
00:23:04,880 --> 00:23:06,880
view the cross repo traces you start

693
00:23:06,880 --> 00:23:08,480
from the right hand side

694
00:23:08,480 --> 00:23:10,480
which is the flow from the service

695
00:23:10,480 --> 00:23:12,640
implementation to the sink so you start

696
00:23:12,640 --> 00:23:15,039
from here you expand the trace until you

697
00:23:15,039 --> 00:23:16,960
hit the sink leaf you also expand until

698
00:23:16,960 --> 00:23:18,720
you hit the source if your source leaf

699
00:23:18,720 --> 00:23:20,960
is the thrift implementation or that

700
00:23:20,960 --> 00:23:23,120
canonical connection point once you hit

701
00:23:23,120 --> 00:23:24,559
that canonical connection point you go

702
00:23:24,559 --> 00:23:27,360
to the crtech to find who are the

703
00:23:27,360 --> 00:23:29,919
producers or who are the other engines

704
00:23:29,919 --> 00:23:31,440
that are storing data

705
00:23:31,440 --> 00:23:32,880
into into my run and then once you go

706
00:23:32,880 --> 00:23:35,440
there you go into the database from

707
00:23:35,440 --> 00:23:37,679
crtec switch to the right db switch to

708
00:23:37,679 --> 00:23:39,440
the right tool take that information and

709
00:23:39,440 --> 00:23:41,120
then you expand the trace normally

710
00:23:41,120 --> 00:23:43,039
backward until you hit the source leaf

711
00:23:43,039 --> 00:23:44,960
and this is how you get like from the

712
00:23:44,960 --> 00:23:47,840
user input to the thrift call and then

713
00:23:47,840 --> 00:23:51,039
from the thrift implementation to the

714
00:23:51,039 --> 00:23:53,279
actual sync your sql sync

715
00:23:53,279 --> 00:23:56,159
now we know how we uh find the sql

716
00:23:56,159 --> 00:23:58,240
injection single repo how we find sql

717
00:23:58,240 --> 00:23:59,840
ejection cross repo

718
00:23:59,840 --> 00:24:02,320
how does this work so we can actually

719
00:24:02,320 --> 00:24:05,120
find true bugs how this is deployed at

720
00:24:05,120 --> 00:24:06,320
facebook so we can find true

721
00:24:06,320 --> 00:24:09,039
vulnerabilities so we start with like

722
00:24:09,039 --> 00:24:11,600
configuring our producer runs so usually

723
00:24:11,600 --> 00:24:13,360
you want your producer runs to map all

724
00:24:13,360 --> 00:24:15,200
your attack surface you remember that

725
00:24:15,200 --> 00:24:16,720
picture we're showing you have user

726
00:24:16,720 --> 00:24:18,559
applica user facing application so you

727
00:24:18,559 --> 00:24:21,520
want all your uh engines to be working

728
00:24:21,520 --> 00:24:24,080
on this user application uh uh

729
00:24:24,080 --> 00:24:26,400
uh user facing applications to map all

730
00:24:26,400 --> 00:24:27,840
the attack surface so we have zonk on

731
00:24:27,840 --> 00:24:30,159
analyzing facebook peace analyzing

732
00:24:30,159 --> 00:24:31,760
instagram android application analyzing

733
00:24:31,760 --> 00:24:34,559
our uh maria trench analyzing or our all

734
00:24:34,559 --> 00:24:37,120
our mobile applications uh you might be

735
00:24:37,120 --> 00:24:38,880
wondering why do we need to analyze the

736
00:24:38,880 --> 00:24:40,240
mobile application and know what are the

737
00:24:40,240 --> 00:24:42,159
entry points to our back end if we will

738
00:24:42,159 --> 00:24:44,480
mark everything on the back end as user

739
00:24:44,480 --> 00:24:46,720
control like if you mark all

740
00:24:46,720 --> 00:24:49,120
uh entry points on your web tier why do

741
00:24:49,120 --> 00:24:50,640
you need the mobile application i will

742
00:24:50,640 --> 00:24:52,080
show you in a couple of slides why this

743
00:24:52,080 --> 00:24:54,880
is uh important now our consumers we

744
00:24:54,880 --> 00:24:57,360
mentioned that uh we use fp thrift and

745
00:24:57,360 --> 00:24:59,200
rely heavily on fp thrift so anything

746
00:24:59,200 --> 00:25:01,760
that relies on fb thrift we

747
00:25:01,760 --> 00:25:03,600
analyze this you have implementation in

748
00:25:03,600 --> 00:25:06,159
php python and java all right how

749
00:25:06,159 --> 00:25:08,080
regularly do we run so now we know how

750
00:25:08,080 --> 00:25:10,640
these are configured so we have uh we

751
00:25:10,640 --> 00:25:12,640
run on all the code like when it lands

752
00:25:12,640 --> 00:25:14,880
or when it's pushed we run there which

753
00:25:14,880 --> 00:25:16,720
we call it the master run uh it's

754
00:25:16,720 --> 00:25:18,640
usually multiple times a day and for any

755
00:25:18,640 --> 00:25:20,559
new findings we found a task but we

756
00:25:20,559 --> 00:25:22,320
actually also want to do better than

757
00:25:22,320 --> 00:25:24,080
that we don't want the wait for the

758
00:25:24,080 --> 00:25:26,000
vulnerability to be pushed or for the

759
00:25:26,000 --> 00:25:28,080
coat to land we want to catch it before

760
00:25:28,080 --> 00:25:29,600
this so we have another mode which is

761
00:25:29,600 --> 00:25:31,919
the pull request mode so with every pull

762
00:25:31,919 --> 00:25:34,720
request that engineer creates we review

763
00:25:34,720 --> 00:25:36,960
the code before that pull request and

764
00:25:36,960 --> 00:25:38,880
after that pull request and we see if

765
00:25:38,880 --> 00:25:40,480
there is any new vulnerabilities any new

766
00:25:40,480 --> 00:25:42,480
vulnerabilities we attribute it to that

767
00:25:42,480 --> 00:25:44,480
pull request if we are confident about

768
00:25:44,480 --> 00:25:46,000
the vulnerability we automatically

769
00:25:46,000 --> 00:25:47,760
comment in the code to prevent this from

770
00:25:47,760 --> 00:25:49,520
landing and we provide guidance to the

771
00:25:49,520 --> 00:25:51,840
engineers to prevent that sequential rc

772
00:25:51,840 --> 00:25:53,520
but if we're not very confident from the

773
00:25:53,520 --> 00:25:55,279
vulnerability we loop in the security

774
00:25:55,279 --> 00:25:57,200
engineers to ask them tutorials that

775
00:25:57,200 --> 00:25:58,720
vulnerability for us

776
00:25:58,720 --> 00:26:00,000
now to the

777
00:26:00,000 --> 00:26:02,400
most favorite part for me the actual

778
00:26:02,400 --> 00:26:03,679
vulnerability that we found or an

779
00:26:03,679 --> 00:26:05,919
example of an actual vulnerability we

780
00:26:05,919 --> 00:26:07,520
have found

781
00:26:07,520 --> 00:26:09,520
two things i'd like to mention one

782
00:26:09,520 --> 00:26:12,000
because this cross repo flows so they

783
00:26:12,000 --> 00:26:13,520
are expected to be

784
00:26:13,520 --> 00:26:15,360
slightly complex so i apologize in

785
00:26:15,360 --> 00:26:16,880
advance for this i'll try to do my best

786
00:26:16,880 --> 00:26:19,120
to abstract the code for you the other

787
00:26:19,120 --> 00:26:20,799
thing is that this vulnerability was

788
00:26:20,799 --> 00:26:23,600
found in a testing environment as in

789
00:26:23,600 --> 00:26:25,679
the code landed and everything but the

790
00:26:25,679 --> 00:26:27,039
code was only enabled for the

791
00:26:27,039 --> 00:26:29,120
development team this did not affect any

792
00:26:29,120 --> 00:26:31,360
real users uh or

793
00:26:31,360 --> 00:26:32,400
no one

794
00:26:32,400 --> 00:26:35,120
really has been affected by this

795
00:26:35,120 --> 00:26:36,960
so let me start with

796
00:26:36,960 --> 00:26:38,880
giving you an overview of the

797
00:26:38,880 --> 00:26:40,720
vulnerabilities so one it is a remote

798
00:26:40,720 --> 00:26:42,559
command execution yes we have found the

799
00:26:42,559 --> 00:26:44,480
remote command execution was close repo

800
00:26:44,480 --> 00:26:47,840
analysis uh which for me is like amazing

801
00:26:47,840 --> 00:26:50,400
uh all right so the floor starts from uh

802
00:26:50,400 --> 00:26:53,360
workplace uh and ends in a python

803
00:26:53,360 --> 00:26:54,880
service so workplace if you're not

804
00:26:54,880 --> 00:26:56,640
familiar with workplace is something

805
00:26:56,640 --> 00:26:58,640
very similar to facebook but it's for

806
00:26:58,640 --> 00:27:00,480
companies to be able to communicate and

807
00:27:00,480 --> 00:27:02,640
collaborate so for employees inside

808
00:27:02,640 --> 00:27:04,080
companies to be able to communicate or

809
00:27:04,080 --> 00:27:06,240
collaborate we actually use workplace

810
00:27:06,240 --> 00:27:08,480
internally and uh workplace has a

811
00:27:08,480 --> 00:27:10,720
feature so workplaces and php so it's

812
00:27:10,720 --> 00:27:12,320
being analyzed by zonkel and it has a

813
00:27:12,320 --> 00:27:15,279
feature for video call rooms or uh so

814
00:27:15,279 --> 00:27:17,360
you can create a virtual room where you

815
00:27:17,360 --> 00:27:19,760
uh video call with your co-workers and

816
00:27:19,760 --> 00:27:22,080
your teammates and that service has part

817
00:27:22,080 --> 00:27:24,080
of it that was written in python and the

818
00:27:24,080 --> 00:27:25,919
remote con execution where in that

819
00:27:25,919 --> 00:27:28,960
python service but you're in like the

820
00:27:28,960 --> 00:27:30,399
the application that is part of your

821
00:27:30,399 --> 00:27:33,039
attack service is workplace now let's go

822
00:27:33,039 --> 00:27:35,360
one step deeper let's look at our trace

823
00:27:35,360 --> 00:27:36,960
this is our crease here i know it's a

824
00:27:36,960 --> 00:27:39,120
lot to take in but let's break the mark

825
00:27:39,120 --> 00:27:42,000
the left-hand side is the php part your

826
00:27:42,000 --> 00:27:43,919
your kind of uh

827
00:27:43,919 --> 00:27:45,760
initial attack surface or your entry

828
00:27:45,760 --> 00:27:47,200
point for the attack surface and we will

829
00:27:47,200 --> 00:27:48,799
start reviewing the code from here or

830
00:27:48,799 --> 00:27:50,320
seeing the code from here the right hand

831
00:27:50,320 --> 00:27:51,840
side is the python part again we will

832
00:27:51,840 --> 00:27:53,679
dive into this deeper two things i want

833
00:27:53,679 --> 00:27:55,520
to highlight here one this is the

834
00:27:55,520 --> 00:27:58,080
canonical name for the service as we

835
00:27:58,080 --> 00:27:59,840
have seen in the

836
00:27:59,840 --> 00:28:01,919
demo example this is the canonical name

837
00:28:01,919 --> 00:28:04,320
is the root of the tree but also here

838
00:28:04,320 --> 00:28:06,480
also is this is the producer run id

839
00:28:06,480 --> 00:28:07,840
which i've mentioned earlier it is

840
00:28:07,840 --> 00:28:09,360
important to be able to get that meta

841
00:28:09,360 --> 00:28:11,039
information when you're viewing the

842
00:28:11,039 --> 00:28:12,159
trace

843
00:28:12,159 --> 00:28:16,480
seamlessly now let's dive deeper more so

844
00:28:16,480 --> 00:28:18,799
from the code let's start with the php

845
00:28:18,799 --> 00:28:20,960
part so as you can see here this is a

846
00:28:20,960 --> 00:28:23,600
graphql mutation root field if you're

847
00:28:23,600 --> 00:28:25,120
not very familiar with graphql so

848
00:28:25,120 --> 00:28:27,200
graphql you can think of it as a rest

849
00:28:27,200 --> 00:28:30,399
api that our mobile applications used to

850
00:28:30,399 --> 00:28:32,799
connect to the server so from an from a

851
00:28:32,799 --> 00:28:34,720
security engineer perspective this is

852
00:28:34,720 --> 00:28:36,399
your entry point or part of your attack

853
00:28:36,399 --> 00:28:38,720
surface so the argument data here is

854
00:28:38,720 --> 00:28:40,720
user controlled so what we do is that we

855
00:28:40,720 --> 00:28:43,520
take data and we forward this to the gen

856
00:28:43,520 --> 00:28:44,559
spawn

857
00:28:44,559 --> 00:28:46,640
function one thing to highlight here

858
00:28:46,640 --> 00:28:48,720
this is the check that made sure that

859
00:28:48,720 --> 00:28:50,559
this code is only enabled for the

860
00:28:50,559 --> 00:28:52,880
development team now let's go one step

861
00:28:52,880 --> 00:28:55,600
deeper into inside the gen spawn so gen

862
00:28:55,600 --> 00:28:56,559
spawn

863
00:28:56,559 --> 00:28:58,080
takes the route which we know is user

864
00:28:58,080 --> 00:28:59,760
controlled from the previous frame and

865
00:28:59,760 --> 00:29:02,159
then creates a request and calls the

866
00:29:02,159 --> 00:29:04,640
client start very similar to our

867
00:29:04,640 --> 00:29:06,320
example demo where you have like service

868
00:29:06,320 --> 00:29:07,600
name and then start so here we're

869
00:29:07,600 --> 00:29:09,520
calling the start function on some

870
00:29:09,520 --> 00:29:12,880
service and the request object is user

871
00:29:12,880 --> 00:29:14,480
controlled or contained tainted

872
00:29:14,480 --> 00:29:16,960
information now this is the last frame

873
00:29:16,960 --> 00:29:19,440
before we jump into the python part so

874
00:29:19,440 --> 00:29:20,559
now

875
00:29:20,559 --> 00:29:22,000
we will jump into the python product

876
00:29:22,000 --> 00:29:24,320
here is the definition of that function

877
00:29:24,320 --> 00:29:25,840
or the implementation of the start

878
00:29:25,840 --> 00:29:28,640
function request is user controlled or

879
00:29:28,640 --> 00:29:31,679
it contains user data contains stated

880
00:29:31,679 --> 00:29:33,360
data and we take request and we forward

881
00:29:33,360 --> 00:29:34,559
that into

882
00:29:34,559 --> 00:29:37,120
start async inside start async the

883
00:29:37,120 --> 00:29:39,120
request we access the route member from

884
00:29:39,120 --> 00:29:41,360
that which is also user controlled input

885
00:29:41,360 --> 00:29:42,720
we uh

886
00:29:42,720 --> 00:29:45,840
created the args uh variable which we

887
00:29:45,840 --> 00:29:46,880
later

888
00:29:46,880 --> 00:29:48,240
use that also with some string

889
00:29:48,240 --> 00:29:50,240
interpolation to create the exit command

890
00:29:50,240 --> 00:29:52,799
and eventually called the vmxx last

891
00:29:52,799 --> 00:29:55,120
frame in our vulnerability here is the

892
00:29:55,120 --> 00:29:56,480
vm exec

893
00:29:56,480 --> 00:29:58,720
we take the command and then we call ssh

894
00:29:58,720 --> 00:30:02,080
client exit command the ssh client is a

895
00:30:02,080 --> 00:30:04,159
client class in the parameco library

896
00:30:04,159 --> 00:30:06,399
parame is a python third-party library

897
00:30:06,399 --> 00:30:08,720
that allows you to ssh into machine and

898
00:30:08,720 --> 00:30:11,120
execute command if the command

899
00:30:11,120 --> 00:30:13,279
object contain untrusted input you can

900
00:30:13,279 --> 00:30:14,720
have a command injection vulnerability

901
00:30:14,720 --> 00:30:17,039
here and this is what we have here so

902
00:30:17,039 --> 00:30:19,919
the entire flow starting from the php

903
00:30:19,919 --> 00:30:22,480
part going into the python part and

904
00:30:22,480 --> 00:30:24,000
eventually leading to a remote command

905
00:30:24,000 --> 00:30:26,399
execution from the exit command called

906
00:30:26,399 --> 00:30:28,399
of parameco

907
00:30:28,399 --> 00:30:31,520
rce in 2021 yes we managed to find this

908
00:30:31,520 --> 00:30:33,440
and we managed to find this with cross

909
00:30:33,440 --> 00:30:36,480
reputation for analysis no manual review

910
00:30:36,480 --> 00:30:38,880
being done to find this just the tools

911
00:30:38,880 --> 00:30:41,120
saying this is a potential rc here to

912
00:30:41,120 --> 00:30:43,520
reach it and yes it is a potential rce

913
00:30:43,520 --> 00:30:45,679
it's very difficult to find rces and

914
00:30:45,679 --> 00:30:47,279
with our tooling we were able to find

915
00:30:47,279 --> 00:30:49,039
this and we were able to find this in a

916
00:30:49,039 --> 00:30:50,480
testing environment before it lands and

917
00:30:50,480 --> 00:30:53,679
affect any of our users or our products

918
00:30:53,679 --> 00:30:54,799
there's a lot of challenges and

919
00:30:54,799 --> 00:30:56,640
improvements to take this from here too

920
00:30:56,640 --> 00:30:58,880
and keep in improving on this one of the

921
00:30:58,880 --> 00:31:01,360
challenges that we want to work on is

922
00:31:01,360 --> 00:31:03,600
false positives or a bad signal to noise

923
00:31:03,600 --> 00:31:05,919
ratio because of some sanitization

924
00:31:05,919 --> 00:31:09,120
happening in one path so one on in php

925
00:31:09,120 --> 00:31:10,640
or in the python some sanitization

926
00:31:10,640 --> 00:31:12,799
happening in these two paths when we

927
00:31:12,799 --> 00:31:14,960
send this information across crtec or

928
00:31:14,960 --> 00:31:17,279
when we send this tint information we

929
00:31:17,279 --> 00:31:18,799
don't necessarily send oh there's a

930
00:31:18,799 --> 00:31:20,000
validation here we just said there's

931
00:31:20,000 --> 00:31:22,640
user input going to the sync here but if

932
00:31:22,640 --> 00:31:25,039
there's end casting or enum casting that

933
00:31:25,039 --> 00:31:27,039
can lead to bad signatures ratio and we

934
00:31:27,039 --> 00:31:28,960
are actually working on this

935
00:31:28,960 --> 00:31:31,039
improvement there's also the creation

936
00:31:31,039 --> 00:31:32,799
points for fb thrift we want to make it

937
00:31:32,799 --> 00:31:35,840
easier for anyone to create extra

938
00:31:35,840 --> 00:31:38,159
connection points so how you can support

939
00:31:38,159 --> 00:31:40,399
grpc how can you support apache thrift

940
00:31:40,399 --> 00:31:42,000
or any other tools similar to if you

941
00:31:42,000 --> 00:31:44,640
third or even how can you support normal

942
00:31:44,640 --> 00:31:47,760
http calls that the implementation in a

943
00:31:47,760 --> 00:31:49,360
django application or flask application

944
00:31:49,360 --> 00:31:51,600
inside your environment uh

945
00:31:51,600 --> 00:31:52,799
also

946
00:31:52,799 --> 00:31:54,399
as you see in the real example that

947
00:31:54,399 --> 00:31:56,240
we've shared with you the the trace is

948
00:31:56,240 --> 00:31:58,480
slightly complex and this is expected

949
00:31:58,480 --> 00:32:00,080
because the cross shoot flows but it

950
00:32:00,080 --> 00:32:01,519
would be great if we can come up with

951
00:32:01,519 --> 00:32:03,840
some creative ways to make the flow

952
00:32:03,840 --> 00:32:06,320
simpler and simpler so that engineers

953
00:32:06,320 --> 00:32:09,279
can easily understand and act on that

954
00:32:09,279 --> 00:32:11,279
fixed ownership who should fix that sql

955
00:32:11,279 --> 00:32:12,880
injection uh

956
00:32:12,880 --> 00:32:14,399
in the demo example who should fix the

957
00:32:14,399 --> 00:32:17,360
rce is it the service or the client

958
00:32:17,360 --> 00:32:20,159
calling the service so uh sometimes yes

959
00:32:20,159 --> 00:32:21,679
the server's responsibility is to make

960
00:32:21,679 --> 00:32:23,120
sure that the service is

961
00:32:23,120 --> 00:32:25,919
self-sustained and like secure by itself

962
00:32:25,919 --> 00:32:28,000
uh but also sometimes the vulnerability

963
00:32:28,000 --> 00:32:28,799
if this

964
00:32:28,799 --> 00:32:30,799
if let's say missing permission checks

965
00:32:30,799 --> 00:32:32,880
the clients sometimes would need to to

966
00:32:32,880 --> 00:32:34,480
perform these authorization checks

967
00:32:34,480 --> 00:32:37,760
before it calls uh the service uh

968
00:32:37,760 --> 00:32:39,200
looking forward i see there are there

969
00:32:39,200 --> 00:32:41,440
are different ways where this can evolve

970
00:32:41,440 --> 00:32:43,919
over time i'll start first with uh this

971
00:32:43,919 --> 00:32:45,440
direction here so research to

972
00:32:45,440 --> 00:32:47,039
standardize the taint flow summaries it

973
00:32:47,039 --> 00:32:49,200
would be great if we have more research

974
00:32:49,200 --> 00:32:51,120
around how the influence summaries can

975
00:32:51,120 --> 00:32:53,360
be too agnostic can be standardized and

976
00:32:53,360 --> 00:32:54,799
can represent everything it would be

977
00:32:54,799 --> 00:32:56,799
great for for pisa to be able to

978
00:32:56,799 --> 00:32:58,640
communicate with cosql with rips with

979
00:32:58,640 --> 00:33:00,640
other static analysis tools to build

980
00:33:00,640 --> 00:33:03,679
more complex ideas uh on top of that the

981
00:33:03,679 --> 00:33:05,279
other idea is the mobile attack surface

982
00:33:05,279 --> 00:33:07,039
so the mobile attack surface

983
00:33:07,039 --> 00:33:08,320
if you think that you usually have your

984
00:33:08,320 --> 00:33:10,080
exported components and requests from

985
00:33:10,080 --> 00:33:12,000
back end exported components how other

986
00:33:12,000 --> 00:33:13,519
applications on the same device

987
00:33:13,519 --> 00:33:15,600
communicate with your application but

988
00:33:15,600 --> 00:33:17,279
request from back end how is your

989
00:33:17,279 --> 00:33:19,679
backend is communicating with your phone

990
00:33:19,679 --> 00:33:21,039
should you mark all the requests from

991
00:33:21,039 --> 00:33:22,480
your back end as

992
00:33:22,480 --> 00:33:24,399
potentially user controlled or like

993
00:33:24,399 --> 00:33:27,039
untrusted input or should you mark your

994
00:33:27,039 --> 00:33:28,480
everything coming for your back end as

995
00:33:28,480 --> 00:33:30,399
trusted input

996
00:33:30,399 --> 00:33:32,559
both are have like pros and cons but

997
00:33:32,559 --> 00:33:34,720
with cross reporting flow analysis you

998
00:33:34,720 --> 00:33:36,559
will be able to find exactly and

999
00:33:36,559 --> 00:33:38,480
precisely what is coming from your back

1000
00:33:38,480 --> 00:33:40,640
end that is user controlled input and

1001
00:33:40,640 --> 00:33:42,080
how does this affect your mobile

1002
00:33:42,080 --> 00:33:43,840
application another

1003
00:33:43,840 --> 00:33:45,360
improvement area that i can i can think

1004
00:33:45,360 --> 00:33:46,720
of back in storage is most of the

1005
00:33:46,720 --> 00:33:48,480
systems today or most of the

1006
00:33:48,480 --> 00:33:50,240
in-flow analysis systems today if you

1007
00:33:50,240 --> 00:33:51,519
have user control input going to a

1008
00:33:51,519 --> 00:33:53,600
database and somewhere else in your code

1009
00:33:53,600 --> 00:33:55,760
you read that input from database and

1010
00:33:55,760 --> 00:33:59,279
then you go to eval or some rce sync

1011
00:33:59,279 --> 00:34:00,880
most of the info analysis tool we will

1012
00:34:00,880 --> 00:34:02,880
not be able to find that vulnerability

1013
00:34:02,880 --> 00:34:05,440
for you because for them the back end is

1014
00:34:05,440 --> 00:34:07,440
a black hole or the back and everything

1015
00:34:07,440 --> 00:34:09,119
from the back end is tainted and

1016
00:34:09,119 --> 00:34:11,520
untrusted which is very very noisy with

1017
00:34:11,520 --> 00:34:12,879
cross street potential analysis you will

1018
00:34:12,879 --> 00:34:15,040
be able to see precisely what's that

1019
00:34:15,040 --> 00:34:16,879
this is an example here so imagine you

1020
00:34:16,879 --> 00:34:19,679
have a request save image you store an

1021
00:34:19,679 --> 00:34:21,440
image with some name that is stored into

1022
00:34:21,440 --> 00:34:22,960
the database and then somewhere else in

1023
00:34:22,960 --> 00:34:24,480
the code another request or another

1024
00:34:24,480 --> 00:34:27,280
endpoint that view an image with an id

1025
00:34:27,280 --> 00:34:29,199
retrieves that from the database the

1026
00:34:29,199 --> 00:34:31,280
image the content and the name that you

1027
00:34:31,280 --> 00:34:32,960
provided in the first request there is a

1028
00:34:32,960 --> 00:34:34,960
path reversal vulnerability here

1029
00:34:34,960 --> 00:34:36,639
most of the tools nowadays will not be

1030
00:34:36,639 --> 00:34:38,079
able to detect this vulnerability but

1031
00:34:38,079 --> 00:34:40,159
with crosstree potential analysis or the

1032
00:34:40,159 --> 00:34:42,879
same mechanism you will be able to know

1033
00:34:42,879 --> 00:34:44,159
that whenever you're retrieving this

1034
00:34:44,159 --> 00:34:45,599
data from the database it was user

1035
00:34:45,599 --> 00:34:47,679
tainted in the first request and then

1036
00:34:47,679 --> 00:34:50,000
you'll be able to see the entire flow

1037
00:34:50,000 --> 00:34:52,079
giving you kind of a better view of your

1038
00:34:52,079 --> 00:34:54,159
attack surface

1039
00:34:54,159 --> 00:34:56,800
last idea for this to grow which is one

1040
00:34:56,800 --> 00:34:58,160
of my favorite is

1041
00:34:58,160 --> 00:35:00,720
privacy relevant flows imagine mariana

1042
00:35:00,720 --> 00:35:02,480
trench working with zonglan or some of

1043
00:35:02,480 --> 00:35:04,640
our back end and our stool where you can

1044
00:35:04,640 --> 00:35:06,400
see a flow coming from a sensitive

1045
00:35:06,400 --> 00:35:09,359
sensor speaker camera gps location

1046
00:35:09,359 --> 00:35:11,200
fingerprint i know they mostly stay in

1047
00:35:11,200 --> 00:35:13,040
the device but imagine you have this

1048
00:35:13,040 --> 00:35:14,800
ability where you see the data coming

1049
00:35:14,800 --> 00:35:16,240
from the sensor we're reading the data

1050
00:35:16,240 --> 00:35:18,240
from the sensor we're sending this data

1051
00:35:18,240 --> 00:35:19,839
across our back end and what we do with

1052
00:35:19,839 --> 00:35:22,160
this data with our back end so with

1053
00:35:22,160 --> 00:35:23,839
cross reporting for us is with mariana

1054
00:35:23,839 --> 00:35:26,160
attention speaking with pisa or zonclan

1055
00:35:26,160 --> 00:35:27,920
you will be able to find that flow you

1056
00:35:27,920 --> 00:35:29,839
will be able to find flow leaving from a

1057
00:35:29,839 --> 00:35:31,920
sensor going to your back end and what

1058
00:35:31,920 --> 00:35:33,920
do you do with data

1059
00:35:33,920 --> 00:35:35,680
at the back end

1060
00:35:35,680 --> 00:35:37,520
takeaways

1061
00:35:37,520 --> 00:35:38,400
so

1062
00:35:38,400 --> 00:35:39,680
if you're an application security

1063
00:35:39,680 --> 00:35:40,960
engineer

1064
00:35:40,960 --> 00:35:42,240
on application security teams you

1065
00:35:42,240 --> 00:35:43,520
probably know that there is a lot of

1066
00:35:43,520 --> 00:35:45,200
code there

1067
00:35:45,200 --> 00:35:47,359
you have a lot to review use static

1068
00:35:47,359 --> 00:35:50,640
analysis it scales scaled with us

1069
00:35:50,640 --> 00:35:52,800
we have great open source tools they're

1070
00:35:52,800 --> 00:35:54,079
free to use

1071
00:35:54,079 --> 00:35:55,839
and they have great documentation you

1072
00:35:55,839 --> 00:35:58,160
can go and try them right away you have

1073
00:35:58,160 --> 00:35:59,920
all the knowledge to build cross

1074
00:35:59,920 --> 00:36:02,480
reputation flow analysis so go and try

1075
00:36:02,480 --> 00:36:04,320
it out for security consultants you

1076
00:36:04,320 --> 00:36:05,760
might think it's like i don't own code i

1077
00:36:05,760 --> 00:36:08,240
just do good reviews uh now and then

1078
00:36:08,240 --> 00:36:09,599
maybe i don't need to use stainflow

1079
00:36:09,599 --> 00:36:10,800
analysis

1080
00:36:10,800 --> 00:36:13,680
yes and no so uh if you have python code

1081
00:36:13,680 --> 00:36:15,359
or java code you can just get a quick

1082
00:36:15,359 --> 00:36:17,599
head start by analyzing this with python

1083
00:36:17,599 --> 00:36:19,440
and uh meritorious but what you really

1084
00:36:19,440 --> 00:36:21,760
can use is if you have a question like

1085
00:36:21,760 --> 00:36:23,599
what are all the ways that i can get an

1086
00:36:23,599 --> 00:36:25,680
rc in python or what are all the

1087
00:36:25,680 --> 00:36:26,560
all the ways that i can get sql

1088
00:36:26,560 --> 00:36:28,480
injection in mariana trench we have our

1089
00:36:28,480 --> 00:36:31,280
configuration open source these have all

1090
00:36:31,280 --> 00:36:33,200
the ways that an rce can happen in

1091
00:36:33,200 --> 00:36:34,960
python a sql injection can happen in

1092
00:36:34,960 --> 00:36:36,800
java and you can look at these

1093
00:36:36,800 --> 00:36:38,480
configuration and get this knowledge

1094
00:36:38,480 --> 00:36:39,680
quickly and know if this is a

1095
00:36:39,680 --> 00:36:41,359
vulnerability if this flow can lead to

1096
00:36:41,359 --> 00:36:43,280
vulnerability or not and if you find a

1097
00:36:43,280 --> 00:36:44,720
new uh

1098
00:36:44,720 --> 00:36:46,480
kind of api or something that can lead

1099
00:36:46,480 --> 00:36:48,079
to rc please feel free to share it with

1100
00:36:48,079 --> 00:36:49,359
us on our configuration and if you

1101
00:36:49,359 --> 00:36:50,880
really want to see everything working in

1102
00:36:50,880 --> 00:36:52,480
action if you really want to see grocery

1103
00:36:52,480 --> 00:36:54,240
potentials working in action feel free

1104
00:36:54,240 --> 00:36:57,200
to join us at fp.com careers for

1105
00:36:57,200 --> 00:36:59,280
aesthetic analysis researchers

1106
00:36:59,280 --> 00:37:01,040
all our static analysis tools are open

1107
00:37:01,040 --> 00:37:02,640
source feel free to look at the code

1108
00:37:02,640 --> 00:37:04,960
feel free to participate with any ideas

1109
00:37:04,960 --> 00:37:06,880
or thoughts that you have in mind also

1110
00:37:06,880 --> 00:37:08,400
it would be great if you can reach if

1111
00:37:08,400 --> 00:37:09,680
you can spend more time researching

1112
00:37:09,680 --> 00:37:12,320
about tool agnes agnostic taint

1113
00:37:12,320 --> 00:37:15,119
summaries uh last slide which is the

1114
00:37:15,119 --> 00:37:17,440
most important for me is i'd like to

1115
00:37:17,440 --> 00:37:19,520
thank everyone whose name is here they

1116
00:37:19,520 --> 00:37:21,280
have played a very very important role

1117
00:37:21,280 --> 00:37:23,200
for the success of this presentation i

1118
00:37:23,200 --> 00:37:26,320
hope really you liked it

1119
00:37:26,320 --> 00:37:27,920
thank you everyone thank you for your

1120
00:37:27,920 --> 00:37:29,359
time and i'm looking forward for your

1121
00:37:29,359 --> 00:37:32,359
questions

